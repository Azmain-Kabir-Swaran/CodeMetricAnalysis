{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "HttpFSServer.java",
  "functionName": "get",
  "functionId": "get___path-String(annotations-@PathParam(\"path\"))__uriInfo-UriInfo(annotations-@Context)__op-OperationParam(annotations-@QueryParam(OperationParam.NAME))__params-Parameters(annotations-@Context)__request-HttpServletRequest(annotations-@Context)",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs-httpfs/src/main/java/org/apache/hadoop/fs/http/server/HttpFSServer.java",
  "functionStartLine": 215,
  "functionEndLine": 456,
  "numCommitsSeen": 106,
  "timeTaken": 7944,
  "changeHistory": [
    "59aac002834aaeb6475faad4c894b8c764957f68",
    "4ede8bce28aadc62007ad65dc6d44be550632b5f",
    "3037762b2ca2bee0a281b16455c8592173f92315",
    "3ae775d74029b6ae82263739f598ceb25c597dcd",
    "ad5256e44dffba2e9994f2db27d9ae71eab690e8",
    "6dcfef79afe97eda6d09fe2567bb4d4074223141",
    "396ce0d9f470a5e8af03987ad6396d0f08b3d225",
    "2f867115a819327a50cf9c8caa56e0e5a85cabb9",
    "931a49800ef05ee0a6fdc143be1799abb228735d",
    "ea2895f4ed5031809d856faa52e9de5b9501bdea",
    "d8bab3dcb693b2773ede9a6e4f71ae85ee056f79",
    "8a40953058d50d421d62b71067a13b626b3cba1f",
    "47e0321ee91149331e6ae72e7caa41d1de078b6c",
    "828429dec1a7fd3bb5aab6f5bd81423cf8fcbc90",
    "065d9ec5d93e37b4bbd6fd27cb411dc58b0fb686",
    "46162a213f60f915df76c60b0412f45a021e1e7e",
    "8bfbec8cfb7fe7c7affef98b17c1a07b81fe27f0",
    "d263653ae22217439d1740c936d1c78e1644d73e",
    "f4711ef3ab4bb9676303d0aff79ff3d004f239ff",
    "3334306512b5dc932814fded31a89ba1ee97cd9f"
  ],
  "changeHistoryShort": {
    "59aac002834aaeb6475faad4c894b8c764957f68": "Ybodychange",
    "4ede8bce28aadc62007ad65dc6d44be550632b5f": "Ybodychange",
    "3037762b2ca2bee0a281b16455c8592173f92315": "Ybodychange",
    "3ae775d74029b6ae82263739f598ceb25c597dcd": "Ybodychange",
    "ad5256e44dffba2e9994f2db27d9ae71eab690e8": "Ymultichange(Yparameterchange,Ybodychange)",
    "6dcfef79afe97eda6d09fe2567bb4d4074223141": "Ybodychange",
    "396ce0d9f470a5e8af03987ad6396d0f08b3d225": "Ybodychange",
    "2f867115a819327a50cf9c8caa56e0e5a85cabb9": "Ybodychange",
    "931a49800ef05ee0a6fdc143be1799abb228735d": "Ybodychange",
    "ea2895f4ed5031809d856faa52e9de5b9501bdea": "Ybodychange",
    "d8bab3dcb693b2773ede9a6e4f71ae85ee056f79": "Ybodychange",
    "8a40953058d50d421d62b71067a13b626b3cba1f": "Ybodychange",
    "47e0321ee91149331e6ae72e7caa41d1de078b6c": "Ybodychange",
    "828429dec1a7fd3bb5aab6f5bd81423cf8fcbc90": "Ymultichange(Yparameterchange,Ybodychange)",
    "065d9ec5d93e37b4bbd6fd27cb411dc58b0fb686": "Ymultichange(Yparameterchange,Ybodychange)",
    "46162a213f60f915df76c60b0412f45a021e1e7e": "Ybodychange",
    "8bfbec8cfb7fe7c7affef98b17c1a07b81fe27f0": "Ybodychange",
    "d263653ae22217439d1740c936d1c78e1644d73e": "Ymultichange(Yparameterchange,Ybodychange)",
    "f4711ef3ab4bb9676303d0aff79ff3d004f239ff": "Ybodychange",
    "3334306512b5dc932814fded31a89ba1ee97cd9f": "Yintroduced"
  },
  "changeHistoryDetails": {
    "59aac002834aaeb6475faad4c894b8c764957f68": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-15066. HttpFS: Implement setErasureCodingPolicy , unsetErasureCodingPolicy , getErasureCodingPolicy. Contributed by hemanthboyina.\n",
      "commitDate": "06/01/20 6:10 PM",
      "commitName": "59aac002834aaeb6475faad4c894b8c764957f68",
      "commitAuthor": "Takanobu Asanuma",
      "commitDateOld": "02/12/19 4:38 PM",
      "commitNameOld": "4ede8bce28aadc62007ad65dc6d44be550632b5f",
      "commitAuthorOld": "Takanobu Asanuma",
      "daysBetweenCommits": 35.06,
      "commitsBetweenForRepo": 110,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,234 +1,242 @@\n   public Response get(@PathParam(\"path\") String path,\n                       @Context UriInfo uriInfo,\n                       @QueryParam(OperationParam.NAME) OperationParam op,\n                       @Context Parameters params,\n                       @Context HttpServletRequest request)\n     throws IOException, FileSystemAccessException {\n     UserGroupInformation user \u003d HttpUserGroupInformation.get();\n     Response response;\n     path \u003d makeAbsolute(path);\n     MDC.put(HttpFSFileSystem.OP_PARAM, op.value().name());\n     MDC.put(\"hostname\", request.getRemoteAddr());\n     switch (op.value()) {\n     case OPEN: {\n       Boolean noRedirect \u003d params.get(\n           NoRedirectParam.NAME, NoRedirectParam.class);\n       if (noRedirect) {\n         URI redirectURL \u003d createOpenRedirectionURL(uriInfo);\n         final String js \u003d JsonUtil.toJsonString(\"Location\", redirectURL);\n         response \u003d Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n       } else {\n         //Invoking the command directly using an unmanaged FileSystem that is\n         // released by the FileSystemReleaseFilter\n         final FSOperations.FSOpen command \u003d new FSOperations.FSOpen(path);\n         final FileSystem fs \u003d createFileSystem(user);\n         InputStream is \u003d null;\n         UserGroupInformation ugi \u003d UserGroupInformation\n             .createProxyUser(user.getShortUserName(),\n                 UserGroupInformation.getLoginUser());\n         try {\n           is \u003d ugi.doAs(new PrivilegedExceptionAction\u003cInputStream\u003e() {\n             @Override\n             public InputStream run() throws Exception {\n               return command.execute(fs);\n             }\n           });\n         } catch (InterruptedException ie) {\n           LOG.info(\"Open interrupted.\", ie);\n           Thread.currentThread().interrupt();\n         }\n         Long offset \u003d params.get(OffsetParam.NAME, OffsetParam.class);\n         Long len \u003d params.get(LenParam.NAME, LenParam.class);\n         AUDIT_LOG.info(\"[{}] offset [{}] len [{}]\",\n             new Object[] { path, offset, len });\n         InputStreamEntity entity \u003d new InputStreamEntity(is, offset, len);\n         response \u003d Response.ok(entity).type(MediaType.APPLICATION_OCTET_STREAM)\n             .build();\n       }\n       break;\n     }\n     case GETFILESTATUS: {\n       FSOperations.FSFileStatus command \u003d new FSOperations.FSFileStatus(path);\n       Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case LISTSTATUS: {\n       String filter \u003d params.get(FilterParam.NAME, FilterParam.class);\n       FSOperations.FSListStatus command \u003d\n           new FSOperations.FSListStatus(path, filter);\n       Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}] filter [{}]\", path, (filter !\u003d null) ? filter : \"-\");\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETHOMEDIRECTORY: {\n       enforceRootPath(op.value(), path);\n       FSOperations.FSHomeDir command \u003d new FSOperations.FSHomeDir();\n       JSONObject json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"\");\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case INSTRUMENTATION: {\n       enforceRootPath(op.value(), path);\n       Groups groups \u003d HttpFSServerWebApp.get().get(Groups.class);\n       List\u003cString\u003e userGroups \u003d groups.getGroups(user.getShortUserName());\n       if (!userGroups.contains(HttpFSServerWebApp.get().getAdminGroup())) {\n         throw new AccessControlException(\n             \"User not in HttpFSServer admin group\");\n       }\n       Instrumentation instrumentation \u003d\n           HttpFSServerWebApp.get().get(Instrumentation.class);\n       Map snapshot \u003d instrumentation.getSnapshot();\n       response \u003d Response.ok(snapshot).build();\n       break;\n     }\n     case GETCONTENTSUMMARY: {\n       FSOperations.FSContentSummary command \u003d\n           new FSOperations.FSContentSummary(path);\n       Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETQUOTAUSAGE: {\n       FSOperations.FSQuotaUsage command \u003d\n           new FSOperations.FSQuotaUsage(path);\n       Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETFILECHECKSUM: {\n       FSOperations.FSFileChecksum command \u003d\n           new FSOperations.FSFileChecksum(path);\n \n       Boolean noRedirect \u003d params.get(\n           NoRedirectParam.NAME, NoRedirectParam.class);\n       AUDIT_LOG.info(\"[{}]\", path);\n       if (noRedirect) {\n         URI redirectURL \u003d createOpenRedirectionURL(uriInfo);\n         final String js \u003d JsonUtil.toJsonString(\"Location\", redirectURL);\n         response \u003d Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n       } else {\n         Map json \u003d fsExecute(user, command);\n         response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       }\n       break;\n     }\n     case GETFILEBLOCKLOCATIONS: {\n       response \u003d Response.status(Response.Status.BAD_REQUEST).build();\n       break;\n     }\n     case GETACLSTATUS: {\n       FSOperations.FSAclStatus command \u003d new FSOperations.FSAclStatus(path);\n       Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"ACL status for [{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETXATTRS: {\n       List\u003cString\u003e xattrNames \u003d\n           params.getValues(XAttrNameParam.NAME, XAttrNameParam.class);\n       XAttrCodec encoding \u003d\n           params.get(XAttrEncodingParam.NAME, XAttrEncodingParam.class);\n       FSOperations.FSGetXAttrs command \u003d\n           new FSOperations.FSGetXAttrs(path, xattrNames, encoding);\n       @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"XAttrs for [{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case LISTXATTRS: {\n       FSOperations.FSListXAttrs command \u003d new FSOperations.FSListXAttrs(path);\n       @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"XAttr names for [{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case LISTSTATUS_BATCH: {\n       String startAfter \u003d params.get(\n           HttpFSParametersProvider.StartAfterParam.NAME,\n           HttpFSParametersProvider.StartAfterParam.class);\n       byte[] token \u003d HttpFSUtils.EMPTY_BYTES;\n       if (startAfter !\u003d null) {\n         token \u003d startAfter.getBytes(Charsets.UTF_8);\n       }\n       FSOperations.FSListStatusBatch command \u003d new FSOperations\n           .FSListStatusBatch(path, token);\n       @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}] token [{}]\", path, token);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETTRASHROOT: {\n       FSOperations.FSTrashRoot command \u003d new FSOperations.FSTrashRoot(path);\n       JSONObject json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETALLSTORAGEPOLICY: {\n       FSOperations.FSGetAllStoragePolicies command \u003d\n           new FSOperations.FSGetAllStoragePolicies();\n       JSONObject json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETSTORAGEPOLICY: {\n       FSOperations.FSGetStoragePolicy command \u003d\n           new FSOperations.FSGetStoragePolicy(path);\n       JSONObject json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETSNAPSHOTDIFF: {\n       String oldSnapshotName \u003d params.get(OldSnapshotNameParam.NAME,\n           OldSnapshotNameParam.class);\n       String snapshotName \u003d params.get(SnapshotNameParam.NAME,\n           SnapshotNameParam.class);\n       FSOperations.FSGetSnapshotDiff command \u003d\n           new FSOperations.FSGetSnapshotDiff(path, oldSnapshotName,\n               snapshotName);\n       String js \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETSNAPSHOTTABLEDIRECTORYLIST: {\n       FSOperations.FSGetSnapshottableDirListing command \u003d\n           new FSOperations.FSGetSnapshottableDirListing();\n       String js \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", \"/\");\n       response \u003d Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETSERVERDEFAULTS: {\n       FSOperations.FSGetServerDefaults command \u003d\n           new FSOperations.FSGetServerDefaults();\n       String js \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", \"/\");\n       response \u003d Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case CHECKACCESS: {\n       String mode \u003d params.get(FsActionParam.NAME, FsActionParam.class);\n       FsActionParam fsparam \u003d new FsActionParam(mode);\n       FSOperations.FSAccess command \u003d new FSOperations.FSAccess(path,\n           FsAction.getFsAction(fsparam.value()));\n       fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", \"/\");\n       response \u003d Response.ok().build();\n       break;\n     }\n+    case GETECPOLICY: {\n+      FSOperations.FSGetErasureCodingPolicy command \u003d\n+          new FSOperations.FSGetErasureCodingPolicy(path);\n+      String js \u003d fsExecute(user, command);\n+      AUDIT_LOG.info(\"[{}]\", path);\n+      response \u003d Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n+      break;\n+    }\n     default: {\n       throw new IOException(\n           MessageFormat.format(\"Invalid HTTP GET operation [{0}]\", op.value()));\n     }\n     }\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Response get(@PathParam(\"path\") String path,\n                      @Context UriInfo uriInfo,\n                      @QueryParam(OperationParam.NAME) OperationParam op,\n                      @Context Parameters params,\n                      @Context HttpServletRequest request)\n    throws IOException, FileSystemAccessException {\n    UserGroupInformation user \u003d HttpUserGroupInformation.get();\n    Response response;\n    path \u003d makeAbsolute(path);\n    MDC.put(HttpFSFileSystem.OP_PARAM, op.value().name());\n    MDC.put(\"hostname\", request.getRemoteAddr());\n    switch (op.value()) {\n    case OPEN: {\n      Boolean noRedirect \u003d params.get(\n          NoRedirectParam.NAME, NoRedirectParam.class);\n      if (noRedirect) {\n        URI redirectURL \u003d createOpenRedirectionURL(uriInfo);\n        final String js \u003d JsonUtil.toJsonString(\"Location\", redirectURL);\n        response \u003d Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n      } else {\n        //Invoking the command directly using an unmanaged FileSystem that is\n        // released by the FileSystemReleaseFilter\n        final FSOperations.FSOpen command \u003d new FSOperations.FSOpen(path);\n        final FileSystem fs \u003d createFileSystem(user);\n        InputStream is \u003d null;\n        UserGroupInformation ugi \u003d UserGroupInformation\n            .createProxyUser(user.getShortUserName(),\n                UserGroupInformation.getLoginUser());\n        try {\n          is \u003d ugi.doAs(new PrivilegedExceptionAction\u003cInputStream\u003e() {\n            @Override\n            public InputStream run() throws Exception {\n              return command.execute(fs);\n            }\n          });\n        } catch (InterruptedException ie) {\n          LOG.info(\"Open interrupted.\", ie);\n          Thread.currentThread().interrupt();\n        }\n        Long offset \u003d params.get(OffsetParam.NAME, OffsetParam.class);\n        Long len \u003d params.get(LenParam.NAME, LenParam.class);\n        AUDIT_LOG.info(\"[{}] offset [{}] len [{}]\",\n            new Object[] { path, offset, len });\n        InputStreamEntity entity \u003d new InputStreamEntity(is, offset, len);\n        response \u003d Response.ok(entity).type(MediaType.APPLICATION_OCTET_STREAM)\n            .build();\n      }\n      break;\n    }\n    case GETFILESTATUS: {\n      FSOperations.FSFileStatus command \u003d new FSOperations.FSFileStatus(path);\n      Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case LISTSTATUS: {\n      String filter \u003d params.get(FilterParam.NAME, FilterParam.class);\n      FSOperations.FSListStatus command \u003d\n          new FSOperations.FSListStatus(path, filter);\n      Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}] filter [{}]\", path, (filter !\u003d null) ? filter : \"-\");\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETHOMEDIRECTORY: {\n      enforceRootPath(op.value(), path);\n      FSOperations.FSHomeDir command \u003d new FSOperations.FSHomeDir();\n      JSONObject json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"\");\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case INSTRUMENTATION: {\n      enforceRootPath(op.value(), path);\n      Groups groups \u003d HttpFSServerWebApp.get().get(Groups.class);\n      List\u003cString\u003e userGroups \u003d groups.getGroups(user.getShortUserName());\n      if (!userGroups.contains(HttpFSServerWebApp.get().getAdminGroup())) {\n        throw new AccessControlException(\n            \"User not in HttpFSServer admin group\");\n      }\n      Instrumentation instrumentation \u003d\n          HttpFSServerWebApp.get().get(Instrumentation.class);\n      Map snapshot \u003d instrumentation.getSnapshot();\n      response \u003d Response.ok(snapshot).build();\n      break;\n    }\n    case GETCONTENTSUMMARY: {\n      FSOperations.FSContentSummary command \u003d\n          new FSOperations.FSContentSummary(path);\n      Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETQUOTAUSAGE: {\n      FSOperations.FSQuotaUsage command \u003d\n          new FSOperations.FSQuotaUsage(path);\n      Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETFILECHECKSUM: {\n      FSOperations.FSFileChecksum command \u003d\n          new FSOperations.FSFileChecksum(path);\n\n      Boolean noRedirect \u003d params.get(\n          NoRedirectParam.NAME, NoRedirectParam.class);\n      AUDIT_LOG.info(\"[{}]\", path);\n      if (noRedirect) {\n        URI redirectURL \u003d createOpenRedirectionURL(uriInfo);\n        final String js \u003d JsonUtil.toJsonString(\"Location\", redirectURL);\n        response \u003d Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n      } else {\n        Map json \u003d fsExecute(user, command);\n        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      }\n      break;\n    }\n    case GETFILEBLOCKLOCATIONS: {\n      response \u003d Response.status(Response.Status.BAD_REQUEST).build();\n      break;\n    }\n    case GETACLSTATUS: {\n      FSOperations.FSAclStatus command \u003d new FSOperations.FSAclStatus(path);\n      Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"ACL status for [{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETXATTRS: {\n      List\u003cString\u003e xattrNames \u003d\n          params.getValues(XAttrNameParam.NAME, XAttrNameParam.class);\n      XAttrCodec encoding \u003d\n          params.get(XAttrEncodingParam.NAME, XAttrEncodingParam.class);\n      FSOperations.FSGetXAttrs command \u003d\n          new FSOperations.FSGetXAttrs(path, xattrNames, encoding);\n      @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"XAttrs for [{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case LISTXATTRS: {\n      FSOperations.FSListXAttrs command \u003d new FSOperations.FSListXAttrs(path);\n      @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"XAttr names for [{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case LISTSTATUS_BATCH: {\n      String startAfter \u003d params.get(\n          HttpFSParametersProvider.StartAfterParam.NAME,\n          HttpFSParametersProvider.StartAfterParam.class);\n      byte[] token \u003d HttpFSUtils.EMPTY_BYTES;\n      if (startAfter !\u003d null) {\n        token \u003d startAfter.getBytes(Charsets.UTF_8);\n      }\n      FSOperations.FSListStatusBatch command \u003d new FSOperations\n          .FSListStatusBatch(path, token);\n      @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}] token [{}]\", path, token);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETTRASHROOT: {\n      FSOperations.FSTrashRoot command \u003d new FSOperations.FSTrashRoot(path);\n      JSONObject json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETALLSTORAGEPOLICY: {\n      FSOperations.FSGetAllStoragePolicies command \u003d\n          new FSOperations.FSGetAllStoragePolicies();\n      JSONObject json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETSTORAGEPOLICY: {\n      FSOperations.FSGetStoragePolicy command \u003d\n          new FSOperations.FSGetStoragePolicy(path);\n      JSONObject json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETSNAPSHOTDIFF: {\n      String oldSnapshotName \u003d params.get(OldSnapshotNameParam.NAME,\n          OldSnapshotNameParam.class);\n      String snapshotName \u003d params.get(SnapshotNameParam.NAME,\n          SnapshotNameParam.class);\n      FSOperations.FSGetSnapshotDiff command \u003d\n          new FSOperations.FSGetSnapshotDiff(path, oldSnapshotName,\n              snapshotName);\n      String js \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETSNAPSHOTTABLEDIRECTORYLIST: {\n      FSOperations.FSGetSnapshottableDirListing command \u003d\n          new FSOperations.FSGetSnapshottableDirListing();\n      String js \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", \"/\");\n      response \u003d Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETSERVERDEFAULTS: {\n      FSOperations.FSGetServerDefaults command \u003d\n          new FSOperations.FSGetServerDefaults();\n      String js \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", \"/\");\n      response \u003d Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case CHECKACCESS: {\n      String mode \u003d params.get(FsActionParam.NAME, FsActionParam.class);\n      FsActionParam fsparam \u003d new FsActionParam(mode);\n      FSOperations.FSAccess command \u003d new FSOperations.FSAccess(path,\n          FsAction.getFsAction(fsparam.value()));\n      fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", \"/\");\n      response \u003d Response.ok().build();\n      break;\n    }\n    case GETECPOLICY: {\n      FSOperations.FSGetErasureCodingPolicy command \u003d\n          new FSOperations.FSGetErasureCodingPolicy(path);\n      String js \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    default: {\n      throw new IOException(\n          MessageFormat.format(\"Invalid HTTP GET operation [{0}]\", op.value()));\n    }\n    }\n    return response;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-httpfs/src/main/java/org/apache/hadoop/fs/http/server/HttpFSServer.java",
      "extendedDetails": {}
    },
    "4ede8bce28aadc62007ad65dc6d44be550632b5f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9695. HTTPFS - CHECKACCESS operation missing. Contributed by hemanthboyina\n",
      "commitDate": "02/12/19 4:38 PM",
      "commitName": "4ede8bce28aadc62007ad65dc6d44be550632b5f",
      "commitAuthor": "Takanobu Asanuma",
      "commitDateOld": "20/11/19 10:51 AM",
      "commitNameOld": "3037762b2ca2bee0a281b16455c8592173f92315",
      "commitAuthorOld": "Inigo Goiri",
      "daysBetweenCommits": 12.24,
      "commitsBetweenForRepo": 37,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,224 +1,234 @@\n   public Response get(@PathParam(\"path\") String path,\n                       @Context UriInfo uriInfo,\n                       @QueryParam(OperationParam.NAME) OperationParam op,\n                       @Context Parameters params,\n                       @Context HttpServletRequest request)\n     throws IOException, FileSystemAccessException {\n     UserGroupInformation user \u003d HttpUserGroupInformation.get();\n     Response response;\n     path \u003d makeAbsolute(path);\n     MDC.put(HttpFSFileSystem.OP_PARAM, op.value().name());\n     MDC.put(\"hostname\", request.getRemoteAddr());\n     switch (op.value()) {\n     case OPEN: {\n       Boolean noRedirect \u003d params.get(\n           NoRedirectParam.NAME, NoRedirectParam.class);\n       if (noRedirect) {\n         URI redirectURL \u003d createOpenRedirectionURL(uriInfo);\n         final String js \u003d JsonUtil.toJsonString(\"Location\", redirectURL);\n         response \u003d Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n       } else {\n         //Invoking the command directly using an unmanaged FileSystem that is\n         // released by the FileSystemReleaseFilter\n         final FSOperations.FSOpen command \u003d new FSOperations.FSOpen(path);\n         final FileSystem fs \u003d createFileSystem(user);\n         InputStream is \u003d null;\n         UserGroupInformation ugi \u003d UserGroupInformation\n             .createProxyUser(user.getShortUserName(),\n                 UserGroupInformation.getLoginUser());\n         try {\n           is \u003d ugi.doAs(new PrivilegedExceptionAction\u003cInputStream\u003e() {\n             @Override\n             public InputStream run() throws Exception {\n               return command.execute(fs);\n             }\n           });\n         } catch (InterruptedException ie) {\n           LOG.info(\"Open interrupted.\", ie);\n           Thread.currentThread().interrupt();\n         }\n         Long offset \u003d params.get(OffsetParam.NAME, OffsetParam.class);\n         Long len \u003d params.get(LenParam.NAME, LenParam.class);\n         AUDIT_LOG.info(\"[{}] offset [{}] len [{}]\",\n             new Object[] { path, offset, len });\n         InputStreamEntity entity \u003d new InputStreamEntity(is, offset, len);\n         response \u003d Response.ok(entity).type(MediaType.APPLICATION_OCTET_STREAM)\n             .build();\n       }\n       break;\n     }\n     case GETFILESTATUS: {\n       FSOperations.FSFileStatus command \u003d new FSOperations.FSFileStatus(path);\n       Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case LISTSTATUS: {\n       String filter \u003d params.get(FilterParam.NAME, FilterParam.class);\n       FSOperations.FSListStatus command \u003d\n           new FSOperations.FSListStatus(path, filter);\n       Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}] filter [{}]\", path, (filter !\u003d null) ? filter : \"-\");\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETHOMEDIRECTORY: {\n       enforceRootPath(op.value(), path);\n       FSOperations.FSHomeDir command \u003d new FSOperations.FSHomeDir();\n       JSONObject json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"\");\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case INSTRUMENTATION: {\n       enforceRootPath(op.value(), path);\n       Groups groups \u003d HttpFSServerWebApp.get().get(Groups.class);\n       List\u003cString\u003e userGroups \u003d groups.getGroups(user.getShortUserName());\n       if (!userGroups.contains(HttpFSServerWebApp.get().getAdminGroup())) {\n         throw new AccessControlException(\n             \"User not in HttpFSServer admin group\");\n       }\n       Instrumentation instrumentation \u003d\n           HttpFSServerWebApp.get().get(Instrumentation.class);\n       Map snapshot \u003d instrumentation.getSnapshot();\n       response \u003d Response.ok(snapshot).build();\n       break;\n     }\n     case GETCONTENTSUMMARY: {\n       FSOperations.FSContentSummary command \u003d\n           new FSOperations.FSContentSummary(path);\n       Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETQUOTAUSAGE: {\n       FSOperations.FSQuotaUsage command \u003d\n           new FSOperations.FSQuotaUsage(path);\n       Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETFILECHECKSUM: {\n       FSOperations.FSFileChecksum command \u003d\n           new FSOperations.FSFileChecksum(path);\n \n       Boolean noRedirect \u003d params.get(\n           NoRedirectParam.NAME, NoRedirectParam.class);\n       AUDIT_LOG.info(\"[{}]\", path);\n       if (noRedirect) {\n         URI redirectURL \u003d createOpenRedirectionURL(uriInfo);\n         final String js \u003d JsonUtil.toJsonString(\"Location\", redirectURL);\n         response \u003d Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n       } else {\n         Map json \u003d fsExecute(user, command);\n         response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       }\n       break;\n     }\n     case GETFILEBLOCKLOCATIONS: {\n       response \u003d Response.status(Response.Status.BAD_REQUEST).build();\n       break;\n     }\n     case GETACLSTATUS: {\n       FSOperations.FSAclStatus command \u003d new FSOperations.FSAclStatus(path);\n       Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"ACL status for [{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETXATTRS: {\n       List\u003cString\u003e xattrNames \u003d\n           params.getValues(XAttrNameParam.NAME, XAttrNameParam.class);\n       XAttrCodec encoding \u003d\n           params.get(XAttrEncodingParam.NAME, XAttrEncodingParam.class);\n       FSOperations.FSGetXAttrs command \u003d\n           new FSOperations.FSGetXAttrs(path, xattrNames, encoding);\n       @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"XAttrs for [{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case LISTXATTRS: {\n       FSOperations.FSListXAttrs command \u003d new FSOperations.FSListXAttrs(path);\n       @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"XAttr names for [{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case LISTSTATUS_BATCH: {\n       String startAfter \u003d params.get(\n           HttpFSParametersProvider.StartAfterParam.NAME,\n           HttpFSParametersProvider.StartAfterParam.class);\n       byte[] token \u003d HttpFSUtils.EMPTY_BYTES;\n       if (startAfter !\u003d null) {\n         token \u003d startAfter.getBytes(Charsets.UTF_8);\n       }\n       FSOperations.FSListStatusBatch command \u003d new FSOperations\n           .FSListStatusBatch(path, token);\n       @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}] token [{}]\", path, token);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETTRASHROOT: {\n       FSOperations.FSTrashRoot command \u003d new FSOperations.FSTrashRoot(path);\n       JSONObject json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETALLSTORAGEPOLICY: {\n       FSOperations.FSGetAllStoragePolicies command \u003d\n           new FSOperations.FSGetAllStoragePolicies();\n       JSONObject json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETSTORAGEPOLICY: {\n       FSOperations.FSGetStoragePolicy command \u003d\n           new FSOperations.FSGetStoragePolicy(path);\n       JSONObject json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETSNAPSHOTDIFF: {\n       String oldSnapshotName \u003d params.get(OldSnapshotNameParam.NAME,\n           OldSnapshotNameParam.class);\n       String snapshotName \u003d params.get(SnapshotNameParam.NAME,\n           SnapshotNameParam.class);\n       FSOperations.FSGetSnapshotDiff command \u003d\n           new FSOperations.FSGetSnapshotDiff(path, oldSnapshotName,\n               snapshotName);\n       String js \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETSNAPSHOTTABLEDIRECTORYLIST: {\n       FSOperations.FSGetSnapshottableDirListing command \u003d\n           new FSOperations.FSGetSnapshottableDirListing();\n       String js \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", \"/\");\n       response \u003d Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETSERVERDEFAULTS: {\n       FSOperations.FSGetServerDefaults command \u003d\n           new FSOperations.FSGetServerDefaults();\n       String js \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", \"/\");\n       response \u003d Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n+    case CHECKACCESS: {\n+      String mode \u003d params.get(FsActionParam.NAME, FsActionParam.class);\n+      FsActionParam fsparam \u003d new FsActionParam(mode);\n+      FSOperations.FSAccess command \u003d new FSOperations.FSAccess(path,\n+          FsAction.getFsAction(fsparam.value()));\n+      fsExecute(user, command);\n+      AUDIT_LOG.info(\"[{}]\", \"/\");\n+      response \u003d Response.ok().build();\n+      break;\n+    }\n     default: {\n       throw new IOException(\n           MessageFormat.format(\"Invalid HTTP GET operation [{0}]\", op.value()));\n     }\n     }\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Response get(@PathParam(\"path\") String path,\n                      @Context UriInfo uriInfo,\n                      @QueryParam(OperationParam.NAME) OperationParam op,\n                      @Context Parameters params,\n                      @Context HttpServletRequest request)\n    throws IOException, FileSystemAccessException {\n    UserGroupInformation user \u003d HttpUserGroupInformation.get();\n    Response response;\n    path \u003d makeAbsolute(path);\n    MDC.put(HttpFSFileSystem.OP_PARAM, op.value().name());\n    MDC.put(\"hostname\", request.getRemoteAddr());\n    switch (op.value()) {\n    case OPEN: {\n      Boolean noRedirect \u003d params.get(\n          NoRedirectParam.NAME, NoRedirectParam.class);\n      if (noRedirect) {\n        URI redirectURL \u003d createOpenRedirectionURL(uriInfo);\n        final String js \u003d JsonUtil.toJsonString(\"Location\", redirectURL);\n        response \u003d Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n      } else {\n        //Invoking the command directly using an unmanaged FileSystem that is\n        // released by the FileSystemReleaseFilter\n        final FSOperations.FSOpen command \u003d new FSOperations.FSOpen(path);\n        final FileSystem fs \u003d createFileSystem(user);\n        InputStream is \u003d null;\n        UserGroupInformation ugi \u003d UserGroupInformation\n            .createProxyUser(user.getShortUserName(),\n                UserGroupInformation.getLoginUser());\n        try {\n          is \u003d ugi.doAs(new PrivilegedExceptionAction\u003cInputStream\u003e() {\n            @Override\n            public InputStream run() throws Exception {\n              return command.execute(fs);\n            }\n          });\n        } catch (InterruptedException ie) {\n          LOG.info(\"Open interrupted.\", ie);\n          Thread.currentThread().interrupt();\n        }\n        Long offset \u003d params.get(OffsetParam.NAME, OffsetParam.class);\n        Long len \u003d params.get(LenParam.NAME, LenParam.class);\n        AUDIT_LOG.info(\"[{}] offset [{}] len [{}]\",\n            new Object[] { path, offset, len });\n        InputStreamEntity entity \u003d new InputStreamEntity(is, offset, len);\n        response \u003d Response.ok(entity).type(MediaType.APPLICATION_OCTET_STREAM)\n            .build();\n      }\n      break;\n    }\n    case GETFILESTATUS: {\n      FSOperations.FSFileStatus command \u003d new FSOperations.FSFileStatus(path);\n      Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case LISTSTATUS: {\n      String filter \u003d params.get(FilterParam.NAME, FilterParam.class);\n      FSOperations.FSListStatus command \u003d\n          new FSOperations.FSListStatus(path, filter);\n      Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}] filter [{}]\", path, (filter !\u003d null) ? filter : \"-\");\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETHOMEDIRECTORY: {\n      enforceRootPath(op.value(), path);\n      FSOperations.FSHomeDir command \u003d new FSOperations.FSHomeDir();\n      JSONObject json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"\");\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case INSTRUMENTATION: {\n      enforceRootPath(op.value(), path);\n      Groups groups \u003d HttpFSServerWebApp.get().get(Groups.class);\n      List\u003cString\u003e userGroups \u003d groups.getGroups(user.getShortUserName());\n      if (!userGroups.contains(HttpFSServerWebApp.get().getAdminGroup())) {\n        throw new AccessControlException(\n            \"User not in HttpFSServer admin group\");\n      }\n      Instrumentation instrumentation \u003d\n          HttpFSServerWebApp.get().get(Instrumentation.class);\n      Map snapshot \u003d instrumentation.getSnapshot();\n      response \u003d Response.ok(snapshot).build();\n      break;\n    }\n    case GETCONTENTSUMMARY: {\n      FSOperations.FSContentSummary command \u003d\n          new FSOperations.FSContentSummary(path);\n      Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETQUOTAUSAGE: {\n      FSOperations.FSQuotaUsage command \u003d\n          new FSOperations.FSQuotaUsage(path);\n      Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETFILECHECKSUM: {\n      FSOperations.FSFileChecksum command \u003d\n          new FSOperations.FSFileChecksum(path);\n\n      Boolean noRedirect \u003d params.get(\n          NoRedirectParam.NAME, NoRedirectParam.class);\n      AUDIT_LOG.info(\"[{}]\", path);\n      if (noRedirect) {\n        URI redirectURL \u003d createOpenRedirectionURL(uriInfo);\n        final String js \u003d JsonUtil.toJsonString(\"Location\", redirectURL);\n        response \u003d Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n      } else {\n        Map json \u003d fsExecute(user, command);\n        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      }\n      break;\n    }\n    case GETFILEBLOCKLOCATIONS: {\n      response \u003d Response.status(Response.Status.BAD_REQUEST).build();\n      break;\n    }\n    case GETACLSTATUS: {\n      FSOperations.FSAclStatus command \u003d new FSOperations.FSAclStatus(path);\n      Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"ACL status for [{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETXATTRS: {\n      List\u003cString\u003e xattrNames \u003d\n          params.getValues(XAttrNameParam.NAME, XAttrNameParam.class);\n      XAttrCodec encoding \u003d\n          params.get(XAttrEncodingParam.NAME, XAttrEncodingParam.class);\n      FSOperations.FSGetXAttrs command \u003d\n          new FSOperations.FSGetXAttrs(path, xattrNames, encoding);\n      @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"XAttrs for [{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case LISTXATTRS: {\n      FSOperations.FSListXAttrs command \u003d new FSOperations.FSListXAttrs(path);\n      @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"XAttr names for [{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case LISTSTATUS_BATCH: {\n      String startAfter \u003d params.get(\n          HttpFSParametersProvider.StartAfterParam.NAME,\n          HttpFSParametersProvider.StartAfterParam.class);\n      byte[] token \u003d HttpFSUtils.EMPTY_BYTES;\n      if (startAfter !\u003d null) {\n        token \u003d startAfter.getBytes(Charsets.UTF_8);\n      }\n      FSOperations.FSListStatusBatch command \u003d new FSOperations\n          .FSListStatusBatch(path, token);\n      @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}] token [{}]\", path, token);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETTRASHROOT: {\n      FSOperations.FSTrashRoot command \u003d new FSOperations.FSTrashRoot(path);\n      JSONObject json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETALLSTORAGEPOLICY: {\n      FSOperations.FSGetAllStoragePolicies command \u003d\n          new FSOperations.FSGetAllStoragePolicies();\n      JSONObject json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETSTORAGEPOLICY: {\n      FSOperations.FSGetStoragePolicy command \u003d\n          new FSOperations.FSGetStoragePolicy(path);\n      JSONObject json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETSNAPSHOTDIFF: {\n      String oldSnapshotName \u003d params.get(OldSnapshotNameParam.NAME,\n          OldSnapshotNameParam.class);\n      String snapshotName \u003d params.get(SnapshotNameParam.NAME,\n          SnapshotNameParam.class);\n      FSOperations.FSGetSnapshotDiff command \u003d\n          new FSOperations.FSGetSnapshotDiff(path, oldSnapshotName,\n              snapshotName);\n      String js \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETSNAPSHOTTABLEDIRECTORYLIST: {\n      FSOperations.FSGetSnapshottableDirListing command \u003d\n          new FSOperations.FSGetSnapshottableDirListing();\n      String js \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", \"/\");\n      response \u003d Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETSERVERDEFAULTS: {\n      FSOperations.FSGetServerDefaults command \u003d\n          new FSOperations.FSGetServerDefaults();\n      String js \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", \"/\");\n      response \u003d Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case CHECKACCESS: {\n      String mode \u003d params.get(FsActionParam.NAME, FsActionParam.class);\n      FsActionParam fsparam \u003d new FsActionParam(mode);\n      FSOperations.FSAccess command \u003d new FSOperations.FSAccess(path,\n          FsAction.getFsAction(fsparam.value()));\n      fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", \"/\");\n      response \u003d Response.ok().build();\n      break;\n    }\n    default: {\n      throw new IOException(\n          MessageFormat.format(\"Invalid HTTP GET operation [{0}]\", op.value()));\n    }\n    }\n    return response;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-httpfs/src/main/java/org/apache/hadoop/fs/http/server/HttpFSServer.java",
      "extendedDetails": {}
    },
    "3037762b2ca2bee0a281b16455c8592173f92315": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14949. Add getServerDefaults() support to HttpFS. Contributed by hemanthboyina.\n",
      "commitDate": "20/11/19 10:51 AM",
      "commitName": "3037762b2ca2bee0a281b16455c8592173f92315",
      "commitAuthor": "Inigo Goiri",
      "commitDateOld": "30/07/19 4:01 PM",
      "commitNameOld": "3ae775d74029b6ae82263739f598ceb25c597dcd",
      "commitAuthorOld": "Chao Sun",
      "daysBetweenCommits": 112.83,
      "commitsBetweenForRepo": 818,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,216 +1,224 @@\n   public Response get(@PathParam(\"path\") String path,\n                       @Context UriInfo uriInfo,\n                       @QueryParam(OperationParam.NAME) OperationParam op,\n                       @Context Parameters params,\n                       @Context HttpServletRequest request)\n     throws IOException, FileSystemAccessException {\n     UserGroupInformation user \u003d HttpUserGroupInformation.get();\n     Response response;\n     path \u003d makeAbsolute(path);\n     MDC.put(HttpFSFileSystem.OP_PARAM, op.value().name());\n     MDC.put(\"hostname\", request.getRemoteAddr());\n     switch (op.value()) {\n     case OPEN: {\n       Boolean noRedirect \u003d params.get(\n           NoRedirectParam.NAME, NoRedirectParam.class);\n       if (noRedirect) {\n         URI redirectURL \u003d createOpenRedirectionURL(uriInfo);\n         final String js \u003d JsonUtil.toJsonString(\"Location\", redirectURL);\n         response \u003d Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n       } else {\n         //Invoking the command directly using an unmanaged FileSystem that is\n         // released by the FileSystemReleaseFilter\n         final FSOperations.FSOpen command \u003d new FSOperations.FSOpen(path);\n         final FileSystem fs \u003d createFileSystem(user);\n         InputStream is \u003d null;\n         UserGroupInformation ugi \u003d UserGroupInformation\n             .createProxyUser(user.getShortUserName(),\n                 UserGroupInformation.getLoginUser());\n         try {\n           is \u003d ugi.doAs(new PrivilegedExceptionAction\u003cInputStream\u003e() {\n             @Override\n             public InputStream run() throws Exception {\n               return command.execute(fs);\n             }\n           });\n         } catch (InterruptedException ie) {\n           LOG.info(\"Open interrupted.\", ie);\n           Thread.currentThread().interrupt();\n         }\n         Long offset \u003d params.get(OffsetParam.NAME, OffsetParam.class);\n         Long len \u003d params.get(LenParam.NAME, LenParam.class);\n         AUDIT_LOG.info(\"[{}] offset [{}] len [{}]\",\n             new Object[] { path, offset, len });\n         InputStreamEntity entity \u003d new InputStreamEntity(is, offset, len);\n         response \u003d Response.ok(entity).type(MediaType.APPLICATION_OCTET_STREAM)\n             .build();\n       }\n       break;\n     }\n     case GETFILESTATUS: {\n       FSOperations.FSFileStatus command \u003d new FSOperations.FSFileStatus(path);\n       Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case LISTSTATUS: {\n       String filter \u003d params.get(FilterParam.NAME, FilterParam.class);\n       FSOperations.FSListStatus command \u003d\n           new FSOperations.FSListStatus(path, filter);\n       Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}] filter [{}]\", path, (filter !\u003d null) ? filter : \"-\");\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETHOMEDIRECTORY: {\n       enforceRootPath(op.value(), path);\n       FSOperations.FSHomeDir command \u003d new FSOperations.FSHomeDir();\n       JSONObject json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"\");\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case INSTRUMENTATION: {\n       enforceRootPath(op.value(), path);\n       Groups groups \u003d HttpFSServerWebApp.get().get(Groups.class);\n       List\u003cString\u003e userGroups \u003d groups.getGroups(user.getShortUserName());\n       if (!userGroups.contains(HttpFSServerWebApp.get().getAdminGroup())) {\n         throw new AccessControlException(\n             \"User not in HttpFSServer admin group\");\n       }\n       Instrumentation instrumentation \u003d\n           HttpFSServerWebApp.get().get(Instrumentation.class);\n       Map snapshot \u003d instrumentation.getSnapshot();\n       response \u003d Response.ok(snapshot).build();\n       break;\n     }\n     case GETCONTENTSUMMARY: {\n       FSOperations.FSContentSummary command \u003d\n           new FSOperations.FSContentSummary(path);\n       Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETQUOTAUSAGE: {\n       FSOperations.FSQuotaUsage command \u003d\n           new FSOperations.FSQuotaUsage(path);\n       Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETFILECHECKSUM: {\n       FSOperations.FSFileChecksum command \u003d\n           new FSOperations.FSFileChecksum(path);\n \n       Boolean noRedirect \u003d params.get(\n           NoRedirectParam.NAME, NoRedirectParam.class);\n       AUDIT_LOG.info(\"[{}]\", path);\n       if (noRedirect) {\n         URI redirectURL \u003d createOpenRedirectionURL(uriInfo);\n         final String js \u003d JsonUtil.toJsonString(\"Location\", redirectURL);\n         response \u003d Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n       } else {\n         Map json \u003d fsExecute(user, command);\n         response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       }\n       break;\n     }\n     case GETFILEBLOCKLOCATIONS: {\n       response \u003d Response.status(Response.Status.BAD_REQUEST).build();\n       break;\n     }\n     case GETACLSTATUS: {\n       FSOperations.FSAclStatus command \u003d new FSOperations.FSAclStatus(path);\n       Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"ACL status for [{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETXATTRS: {\n       List\u003cString\u003e xattrNames \u003d\n           params.getValues(XAttrNameParam.NAME, XAttrNameParam.class);\n       XAttrCodec encoding \u003d\n           params.get(XAttrEncodingParam.NAME, XAttrEncodingParam.class);\n       FSOperations.FSGetXAttrs command \u003d\n           new FSOperations.FSGetXAttrs(path, xattrNames, encoding);\n       @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"XAttrs for [{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case LISTXATTRS: {\n       FSOperations.FSListXAttrs command \u003d new FSOperations.FSListXAttrs(path);\n       @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"XAttr names for [{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case LISTSTATUS_BATCH: {\n       String startAfter \u003d params.get(\n           HttpFSParametersProvider.StartAfterParam.NAME,\n           HttpFSParametersProvider.StartAfterParam.class);\n       byte[] token \u003d HttpFSUtils.EMPTY_BYTES;\n       if (startAfter !\u003d null) {\n         token \u003d startAfter.getBytes(Charsets.UTF_8);\n       }\n       FSOperations.FSListStatusBatch command \u003d new FSOperations\n           .FSListStatusBatch(path, token);\n       @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}] token [{}]\", path, token);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETTRASHROOT: {\n       FSOperations.FSTrashRoot command \u003d new FSOperations.FSTrashRoot(path);\n       JSONObject json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETALLSTORAGEPOLICY: {\n       FSOperations.FSGetAllStoragePolicies command \u003d\n           new FSOperations.FSGetAllStoragePolicies();\n       JSONObject json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETSTORAGEPOLICY: {\n       FSOperations.FSGetStoragePolicy command \u003d\n           new FSOperations.FSGetStoragePolicy(path);\n       JSONObject json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETSNAPSHOTDIFF: {\n       String oldSnapshotName \u003d params.get(OldSnapshotNameParam.NAME,\n           OldSnapshotNameParam.class);\n       String snapshotName \u003d params.get(SnapshotNameParam.NAME,\n           SnapshotNameParam.class);\n       FSOperations.FSGetSnapshotDiff command \u003d\n           new FSOperations.FSGetSnapshotDiff(path, oldSnapshotName,\n               snapshotName);\n       String js \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETSNAPSHOTTABLEDIRECTORYLIST: {\n       FSOperations.FSGetSnapshottableDirListing command \u003d\n           new FSOperations.FSGetSnapshottableDirListing();\n       String js \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", \"/\");\n       response \u003d Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n+    case GETSERVERDEFAULTS: {\n+      FSOperations.FSGetServerDefaults command \u003d\n+          new FSOperations.FSGetServerDefaults();\n+      String js \u003d fsExecute(user, command);\n+      AUDIT_LOG.info(\"[{}]\", \"/\");\n+      response \u003d Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n+      break;\n+    }\n     default: {\n       throw new IOException(\n           MessageFormat.format(\"Invalid HTTP GET operation [{0}]\", op.value()));\n     }\n     }\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Response get(@PathParam(\"path\") String path,\n                      @Context UriInfo uriInfo,\n                      @QueryParam(OperationParam.NAME) OperationParam op,\n                      @Context Parameters params,\n                      @Context HttpServletRequest request)\n    throws IOException, FileSystemAccessException {\n    UserGroupInformation user \u003d HttpUserGroupInformation.get();\n    Response response;\n    path \u003d makeAbsolute(path);\n    MDC.put(HttpFSFileSystem.OP_PARAM, op.value().name());\n    MDC.put(\"hostname\", request.getRemoteAddr());\n    switch (op.value()) {\n    case OPEN: {\n      Boolean noRedirect \u003d params.get(\n          NoRedirectParam.NAME, NoRedirectParam.class);\n      if (noRedirect) {\n        URI redirectURL \u003d createOpenRedirectionURL(uriInfo);\n        final String js \u003d JsonUtil.toJsonString(\"Location\", redirectURL);\n        response \u003d Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n      } else {\n        //Invoking the command directly using an unmanaged FileSystem that is\n        // released by the FileSystemReleaseFilter\n        final FSOperations.FSOpen command \u003d new FSOperations.FSOpen(path);\n        final FileSystem fs \u003d createFileSystem(user);\n        InputStream is \u003d null;\n        UserGroupInformation ugi \u003d UserGroupInformation\n            .createProxyUser(user.getShortUserName(),\n                UserGroupInformation.getLoginUser());\n        try {\n          is \u003d ugi.doAs(new PrivilegedExceptionAction\u003cInputStream\u003e() {\n            @Override\n            public InputStream run() throws Exception {\n              return command.execute(fs);\n            }\n          });\n        } catch (InterruptedException ie) {\n          LOG.info(\"Open interrupted.\", ie);\n          Thread.currentThread().interrupt();\n        }\n        Long offset \u003d params.get(OffsetParam.NAME, OffsetParam.class);\n        Long len \u003d params.get(LenParam.NAME, LenParam.class);\n        AUDIT_LOG.info(\"[{}] offset [{}] len [{}]\",\n            new Object[] { path, offset, len });\n        InputStreamEntity entity \u003d new InputStreamEntity(is, offset, len);\n        response \u003d Response.ok(entity).type(MediaType.APPLICATION_OCTET_STREAM)\n            .build();\n      }\n      break;\n    }\n    case GETFILESTATUS: {\n      FSOperations.FSFileStatus command \u003d new FSOperations.FSFileStatus(path);\n      Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case LISTSTATUS: {\n      String filter \u003d params.get(FilterParam.NAME, FilterParam.class);\n      FSOperations.FSListStatus command \u003d\n          new FSOperations.FSListStatus(path, filter);\n      Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}] filter [{}]\", path, (filter !\u003d null) ? filter : \"-\");\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETHOMEDIRECTORY: {\n      enforceRootPath(op.value(), path);\n      FSOperations.FSHomeDir command \u003d new FSOperations.FSHomeDir();\n      JSONObject json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"\");\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case INSTRUMENTATION: {\n      enforceRootPath(op.value(), path);\n      Groups groups \u003d HttpFSServerWebApp.get().get(Groups.class);\n      List\u003cString\u003e userGroups \u003d groups.getGroups(user.getShortUserName());\n      if (!userGroups.contains(HttpFSServerWebApp.get().getAdminGroup())) {\n        throw new AccessControlException(\n            \"User not in HttpFSServer admin group\");\n      }\n      Instrumentation instrumentation \u003d\n          HttpFSServerWebApp.get().get(Instrumentation.class);\n      Map snapshot \u003d instrumentation.getSnapshot();\n      response \u003d Response.ok(snapshot).build();\n      break;\n    }\n    case GETCONTENTSUMMARY: {\n      FSOperations.FSContentSummary command \u003d\n          new FSOperations.FSContentSummary(path);\n      Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETQUOTAUSAGE: {\n      FSOperations.FSQuotaUsage command \u003d\n          new FSOperations.FSQuotaUsage(path);\n      Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETFILECHECKSUM: {\n      FSOperations.FSFileChecksum command \u003d\n          new FSOperations.FSFileChecksum(path);\n\n      Boolean noRedirect \u003d params.get(\n          NoRedirectParam.NAME, NoRedirectParam.class);\n      AUDIT_LOG.info(\"[{}]\", path);\n      if (noRedirect) {\n        URI redirectURL \u003d createOpenRedirectionURL(uriInfo);\n        final String js \u003d JsonUtil.toJsonString(\"Location\", redirectURL);\n        response \u003d Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n      } else {\n        Map json \u003d fsExecute(user, command);\n        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      }\n      break;\n    }\n    case GETFILEBLOCKLOCATIONS: {\n      response \u003d Response.status(Response.Status.BAD_REQUEST).build();\n      break;\n    }\n    case GETACLSTATUS: {\n      FSOperations.FSAclStatus command \u003d new FSOperations.FSAclStatus(path);\n      Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"ACL status for [{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETXATTRS: {\n      List\u003cString\u003e xattrNames \u003d\n          params.getValues(XAttrNameParam.NAME, XAttrNameParam.class);\n      XAttrCodec encoding \u003d\n          params.get(XAttrEncodingParam.NAME, XAttrEncodingParam.class);\n      FSOperations.FSGetXAttrs command \u003d\n          new FSOperations.FSGetXAttrs(path, xattrNames, encoding);\n      @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"XAttrs for [{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case LISTXATTRS: {\n      FSOperations.FSListXAttrs command \u003d new FSOperations.FSListXAttrs(path);\n      @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"XAttr names for [{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case LISTSTATUS_BATCH: {\n      String startAfter \u003d params.get(\n          HttpFSParametersProvider.StartAfterParam.NAME,\n          HttpFSParametersProvider.StartAfterParam.class);\n      byte[] token \u003d HttpFSUtils.EMPTY_BYTES;\n      if (startAfter !\u003d null) {\n        token \u003d startAfter.getBytes(Charsets.UTF_8);\n      }\n      FSOperations.FSListStatusBatch command \u003d new FSOperations\n          .FSListStatusBatch(path, token);\n      @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}] token [{}]\", path, token);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETTRASHROOT: {\n      FSOperations.FSTrashRoot command \u003d new FSOperations.FSTrashRoot(path);\n      JSONObject json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETALLSTORAGEPOLICY: {\n      FSOperations.FSGetAllStoragePolicies command \u003d\n          new FSOperations.FSGetAllStoragePolicies();\n      JSONObject json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETSTORAGEPOLICY: {\n      FSOperations.FSGetStoragePolicy command \u003d\n          new FSOperations.FSGetStoragePolicy(path);\n      JSONObject json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETSNAPSHOTDIFF: {\n      String oldSnapshotName \u003d params.get(OldSnapshotNameParam.NAME,\n          OldSnapshotNameParam.class);\n      String snapshotName \u003d params.get(SnapshotNameParam.NAME,\n          SnapshotNameParam.class);\n      FSOperations.FSGetSnapshotDiff command \u003d\n          new FSOperations.FSGetSnapshotDiff(path, oldSnapshotName,\n              snapshotName);\n      String js \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETSNAPSHOTTABLEDIRECTORYLIST: {\n      FSOperations.FSGetSnapshottableDirListing command \u003d\n          new FSOperations.FSGetSnapshottableDirListing();\n      String js \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", \"/\");\n      response \u003d Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETSERVERDEFAULTS: {\n      FSOperations.FSGetServerDefaults command \u003d\n          new FSOperations.FSGetServerDefaults();\n      String js \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", \"/\");\n      response \u003d Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    default: {\n      throw new IOException(\n          MessageFormat.format(\"Invalid HTTP GET operation [{0}]\", op.value()));\n    }\n    }\n    return response;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-httpfs/src/main/java/org/apache/hadoop/fs/http/server/HttpFSServer.java",
      "extendedDetails": {}
    },
    "3ae775d74029b6ae82263739f598ceb25c597dcd": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14034. Support getQuotaUsage API in WebHDFS. Contributed by Chao Sun.\n\nSigned-off-by: Wei-Chiu Chuang \u003cweichiu@apache.org\u003e\n",
      "commitDate": "30/07/19 4:01 PM",
      "commitName": "3ae775d74029b6ae82263739f598ceb25c597dcd",
      "commitAuthor": "Chao Sun",
      "commitDateOld": "16/11/18 9:12 AM",
      "commitNameOld": "ad5256e44dffba2e9994f2db27d9ae71eab690e8",
      "commitAuthorOld": "Weiwei Yang",
      "daysBetweenCommits": 256.24,
      "commitsBetweenForRepo": 1818,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,208 +1,216 @@\n   public Response get(@PathParam(\"path\") String path,\n                       @Context UriInfo uriInfo,\n                       @QueryParam(OperationParam.NAME) OperationParam op,\n                       @Context Parameters params,\n                       @Context HttpServletRequest request)\n     throws IOException, FileSystemAccessException {\n     UserGroupInformation user \u003d HttpUserGroupInformation.get();\n     Response response;\n     path \u003d makeAbsolute(path);\n     MDC.put(HttpFSFileSystem.OP_PARAM, op.value().name());\n     MDC.put(\"hostname\", request.getRemoteAddr());\n     switch (op.value()) {\n     case OPEN: {\n       Boolean noRedirect \u003d params.get(\n           NoRedirectParam.NAME, NoRedirectParam.class);\n       if (noRedirect) {\n         URI redirectURL \u003d createOpenRedirectionURL(uriInfo);\n         final String js \u003d JsonUtil.toJsonString(\"Location\", redirectURL);\n         response \u003d Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n       } else {\n         //Invoking the command directly using an unmanaged FileSystem that is\n         // released by the FileSystemReleaseFilter\n         final FSOperations.FSOpen command \u003d new FSOperations.FSOpen(path);\n         final FileSystem fs \u003d createFileSystem(user);\n         InputStream is \u003d null;\n         UserGroupInformation ugi \u003d UserGroupInformation\n             .createProxyUser(user.getShortUserName(),\n                 UserGroupInformation.getLoginUser());\n         try {\n           is \u003d ugi.doAs(new PrivilegedExceptionAction\u003cInputStream\u003e() {\n             @Override\n             public InputStream run() throws Exception {\n               return command.execute(fs);\n             }\n           });\n         } catch (InterruptedException ie) {\n           LOG.info(\"Open interrupted.\", ie);\n           Thread.currentThread().interrupt();\n         }\n         Long offset \u003d params.get(OffsetParam.NAME, OffsetParam.class);\n         Long len \u003d params.get(LenParam.NAME, LenParam.class);\n         AUDIT_LOG.info(\"[{}] offset [{}] len [{}]\",\n             new Object[] { path, offset, len });\n         InputStreamEntity entity \u003d new InputStreamEntity(is, offset, len);\n         response \u003d Response.ok(entity).type(MediaType.APPLICATION_OCTET_STREAM)\n             .build();\n       }\n       break;\n     }\n     case GETFILESTATUS: {\n       FSOperations.FSFileStatus command \u003d new FSOperations.FSFileStatus(path);\n       Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case LISTSTATUS: {\n       String filter \u003d params.get(FilterParam.NAME, FilterParam.class);\n       FSOperations.FSListStatus command \u003d\n           new FSOperations.FSListStatus(path, filter);\n       Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}] filter [{}]\", path, (filter !\u003d null) ? filter : \"-\");\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETHOMEDIRECTORY: {\n       enforceRootPath(op.value(), path);\n       FSOperations.FSHomeDir command \u003d new FSOperations.FSHomeDir();\n       JSONObject json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"\");\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case INSTRUMENTATION: {\n       enforceRootPath(op.value(), path);\n       Groups groups \u003d HttpFSServerWebApp.get().get(Groups.class);\n       List\u003cString\u003e userGroups \u003d groups.getGroups(user.getShortUserName());\n       if (!userGroups.contains(HttpFSServerWebApp.get().getAdminGroup())) {\n         throw new AccessControlException(\n             \"User not in HttpFSServer admin group\");\n       }\n       Instrumentation instrumentation \u003d\n           HttpFSServerWebApp.get().get(Instrumentation.class);\n       Map snapshot \u003d instrumentation.getSnapshot();\n       response \u003d Response.ok(snapshot).build();\n       break;\n     }\n     case GETCONTENTSUMMARY: {\n       FSOperations.FSContentSummary command \u003d\n           new FSOperations.FSContentSummary(path);\n       Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n+    case GETQUOTAUSAGE: {\n+      FSOperations.FSQuotaUsage command \u003d\n+          new FSOperations.FSQuotaUsage(path);\n+      Map json \u003d fsExecute(user, command);\n+      AUDIT_LOG.info(\"[{}]\", path);\n+      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n+      break;\n+    }\n     case GETFILECHECKSUM: {\n       FSOperations.FSFileChecksum command \u003d\n           new FSOperations.FSFileChecksum(path);\n \n       Boolean noRedirect \u003d params.get(\n           NoRedirectParam.NAME, NoRedirectParam.class);\n       AUDIT_LOG.info(\"[{}]\", path);\n       if (noRedirect) {\n         URI redirectURL \u003d createOpenRedirectionURL(uriInfo);\n         final String js \u003d JsonUtil.toJsonString(\"Location\", redirectURL);\n         response \u003d Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n       } else {\n         Map json \u003d fsExecute(user, command);\n         response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       }\n       break;\n     }\n     case GETFILEBLOCKLOCATIONS: {\n       response \u003d Response.status(Response.Status.BAD_REQUEST).build();\n       break;\n     }\n     case GETACLSTATUS: {\n       FSOperations.FSAclStatus command \u003d new FSOperations.FSAclStatus(path);\n       Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"ACL status for [{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETXATTRS: {\n       List\u003cString\u003e xattrNames \u003d\n           params.getValues(XAttrNameParam.NAME, XAttrNameParam.class);\n       XAttrCodec encoding \u003d\n           params.get(XAttrEncodingParam.NAME, XAttrEncodingParam.class);\n       FSOperations.FSGetXAttrs command \u003d\n           new FSOperations.FSGetXAttrs(path, xattrNames, encoding);\n       @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"XAttrs for [{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case LISTXATTRS: {\n       FSOperations.FSListXAttrs command \u003d new FSOperations.FSListXAttrs(path);\n       @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"XAttr names for [{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case LISTSTATUS_BATCH: {\n       String startAfter \u003d params.get(\n           HttpFSParametersProvider.StartAfterParam.NAME,\n           HttpFSParametersProvider.StartAfterParam.class);\n       byte[] token \u003d HttpFSUtils.EMPTY_BYTES;\n       if (startAfter !\u003d null) {\n         token \u003d startAfter.getBytes(Charsets.UTF_8);\n       }\n       FSOperations.FSListStatusBatch command \u003d new FSOperations\n           .FSListStatusBatch(path, token);\n       @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}] token [{}]\", path, token);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETTRASHROOT: {\n       FSOperations.FSTrashRoot command \u003d new FSOperations.FSTrashRoot(path);\n       JSONObject json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETALLSTORAGEPOLICY: {\n       FSOperations.FSGetAllStoragePolicies command \u003d\n           new FSOperations.FSGetAllStoragePolicies();\n       JSONObject json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETSTORAGEPOLICY: {\n       FSOperations.FSGetStoragePolicy command \u003d\n           new FSOperations.FSGetStoragePolicy(path);\n       JSONObject json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETSNAPSHOTDIFF: {\n       String oldSnapshotName \u003d params.get(OldSnapshotNameParam.NAME,\n           OldSnapshotNameParam.class);\n       String snapshotName \u003d params.get(SnapshotNameParam.NAME,\n           SnapshotNameParam.class);\n       FSOperations.FSGetSnapshotDiff command \u003d\n           new FSOperations.FSGetSnapshotDiff(path, oldSnapshotName,\n               snapshotName);\n       String js \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETSNAPSHOTTABLEDIRECTORYLIST: {\n       FSOperations.FSGetSnapshottableDirListing command \u003d\n           new FSOperations.FSGetSnapshottableDirListing();\n       String js \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", \"/\");\n       response \u003d Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     default: {\n       throw new IOException(\n           MessageFormat.format(\"Invalid HTTP GET operation [{0}]\", op.value()));\n     }\n     }\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Response get(@PathParam(\"path\") String path,\n                      @Context UriInfo uriInfo,\n                      @QueryParam(OperationParam.NAME) OperationParam op,\n                      @Context Parameters params,\n                      @Context HttpServletRequest request)\n    throws IOException, FileSystemAccessException {\n    UserGroupInformation user \u003d HttpUserGroupInformation.get();\n    Response response;\n    path \u003d makeAbsolute(path);\n    MDC.put(HttpFSFileSystem.OP_PARAM, op.value().name());\n    MDC.put(\"hostname\", request.getRemoteAddr());\n    switch (op.value()) {\n    case OPEN: {\n      Boolean noRedirect \u003d params.get(\n          NoRedirectParam.NAME, NoRedirectParam.class);\n      if (noRedirect) {\n        URI redirectURL \u003d createOpenRedirectionURL(uriInfo);\n        final String js \u003d JsonUtil.toJsonString(\"Location\", redirectURL);\n        response \u003d Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n      } else {\n        //Invoking the command directly using an unmanaged FileSystem that is\n        // released by the FileSystemReleaseFilter\n        final FSOperations.FSOpen command \u003d new FSOperations.FSOpen(path);\n        final FileSystem fs \u003d createFileSystem(user);\n        InputStream is \u003d null;\n        UserGroupInformation ugi \u003d UserGroupInformation\n            .createProxyUser(user.getShortUserName(),\n                UserGroupInformation.getLoginUser());\n        try {\n          is \u003d ugi.doAs(new PrivilegedExceptionAction\u003cInputStream\u003e() {\n            @Override\n            public InputStream run() throws Exception {\n              return command.execute(fs);\n            }\n          });\n        } catch (InterruptedException ie) {\n          LOG.info(\"Open interrupted.\", ie);\n          Thread.currentThread().interrupt();\n        }\n        Long offset \u003d params.get(OffsetParam.NAME, OffsetParam.class);\n        Long len \u003d params.get(LenParam.NAME, LenParam.class);\n        AUDIT_LOG.info(\"[{}] offset [{}] len [{}]\",\n            new Object[] { path, offset, len });\n        InputStreamEntity entity \u003d new InputStreamEntity(is, offset, len);\n        response \u003d Response.ok(entity).type(MediaType.APPLICATION_OCTET_STREAM)\n            .build();\n      }\n      break;\n    }\n    case GETFILESTATUS: {\n      FSOperations.FSFileStatus command \u003d new FSOperations.FSFileStatus(path);\n      Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case LISTSTATUS: {\n      String filter \u003d params.get(FilterParam.NAME, FilterParam.class);\n      FSOperations.FSListStatus command \u003d\n          new FSOperations.FSListStatus(path, filter);\n      Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}] filter [{}]\", path, (filter !\u003d null) ? filter : \"-\");\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETHOMEDIRECTORY: {\n      enforceRootPath(op.value(), path);\n      FSOperations.FSHomeDir command \u003d new FSOperations.FSHomeDir();\n      JSONObject json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"\");\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case INSTRUMENTATION: {\n      enforceRootPath(op.value(), path);\n      Groups groups \u003d HttpFSServerWebApp.get().get(Groups.class);\n      List\u003cString\u003e userGroups \u003d groups.getGroups(user.getShortUserName());\n      if (!userGroups.contains(HttpFSServerWebApp.get().getAdminGroup())) {\n        throw new AccessControlException(\n            \"User not in HttpFSServer admin group\");\n      }\n      Instrumentation instrumentation \u003d\n          HttpFSServerWebApp.get().get(Instrumentation.class);\n      Map snapshot \u003d instrumentation.getSnapshot();\n      response \u003d Response.ok(snapshot).build();\n      break;\n    }\n    case GETCONTENTSUMMARY: {\n      FSOperations.FSContentSummary command \u003d\n          new FSOperations.FSContentSummary(path);\n      Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETQUOTAUSAGE: {\n      FSOperations.FSQuotaUsage command \u003d\n          new FSOperations.FSQuotaUsage(path);\n      Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETFILECHECKSUM: {\n      FSOperations.FSFileChecksum command \u003d\n          new FSOperations.FSFileChecksum(path);\n\n      Boolean noRedirect \u003d params.get(\n          NoRedirectParam.NAME, NoRedirectParam.class);\n      AUDIT_LOG.info(\"[{}]\", path);\n      if (noRedirect) {\n        URI redirectURL \u003d createOpenRedirectionURL(uriInfo);\n        final String js \u003d JsonUtil.toJsonString(\"Location\", redirectURL);\n        response \u003d Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n      } else {\n        Map json \u003d fsExecute(user, command);\n        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      }\n      break;\n    }\n    case GETFILEBLOCKLOCATIONS: {\n      response \u003d Response.status(Response.Status.BAD_REQUEST).build();\n      break;\n    }\n    case GETACLSTATUS: {\n      FSOperations.FSAclStatus command \u003d new FSOperations.FSAclStatus(path);\n      Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"ACL status for [{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETXATTRS: {\n      List\u003cString\u003e xattrNames \u003d\n          params.getValues(XAttrNameParam.NAME, XAttrNameParam.class);\n      XAttrCodec encoding \u003d\n          params.get(XAttrEncodingParam.NAME, XAttrEncodingParam.class);\n      FSOperations.FSGetXAttrs command \u003d\n          new FSOperations.FSGetXAttrs(path, xattrNames, encoding);\n      @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"XAttrs for [{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case LISTXATTRS: {\n      FSOperations.FSListXAttrs command \u003d new FSOperations.FSListXAttrs(path);\n      @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"XAttr names for [{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case LISTSTATUS_BATCH: {\n      String startAfter \u003d params.get(\n          HttpFSParametersProvider.StartAfterParam.NAME,\n          HttpFSParametersProvider.StartAfterParam.class);\n      byte[] token \u003d HttpFSUtils.EMPTY_BYTES;\n      if (startAfter !\u003d null) {\n        token \u003d startAfter.getBytes(Charsets.UTF_8);\n      }\n      FSOperations.FSListStatusBatch command \u003d new FSOperations\n          .FSListStatusBatch(path, token);\n      @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}] token [{}]\", path, token);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETTRASHROOT: {\n      FSOperations.FSTrashRoot command \u003d new FSOperations.FSTrashRoot(path);\n      JSONObject json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETALLSTORAGEPOLICY: {\n      FSOperations.FSGetAllStoragePolicies command \u003d\n          new FSOperations.FSGetAllStoragePolicies();\n      JSONObject json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETSTORAGEPOLICY: {\n      FSOperations.FSGetStoragePolicy command \u003d\n          new FSOperations.FSGetStoragePolicy(path);\n      JSONObject json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETSNAPSHOTDIFF: {\n      String oldSnapshotName \u003d params.get(OldSnapshotNameParam.NAME,\n          OldSnapshotNameParam.class);\n      String snapshotName \u003d params.get(SnapshotNameParam.NAME,\n          SnapshotNameParam.class);\n      FSOperations.FSGetSnapshotDiff command \u003d\n          new FSOperations.FSGetSnapshotDiff(path, oldSnapshotName,\n              snapshotName);\n      String js \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETSNAPSHOTTABLEDIRECTORYLIST: {\n      FSOperations.FSGetSnapshottableDirListing command \u003d\n          new FSOperations.FSGetSnapshottableDirListing();\n      String js \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", \"/\");\n      response \u003d Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    default: {\n      throw new IOException(\n          MessageFormat.format(\"Invalid HTTP GET operation [{0}]\", op.value()));\n    }\n    }\n    return response;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-httpfs/src/main/java/org/apache/hadoop/fs/http/server/HttpFSServer.java",
      "extendedDetails": {}
    },
    "ad5256e44dffba2e9994f2db27d9ae71eab690e8": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-14063. Support noredirect param for CREATE/APPEND/OPEN/GETFILECHECKSUM in HttpFS. Contributed by Íñigo Goiri.\n",
      "commitDate": "16/11/18 9:12 AM",
      "commitName": "ad5256e44dffba2e9994f2db27d9ae71eab690e8",
      "commitAuthor": "Weiwei Yang",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-14063. Support noredirect param for CREATE/APPEND/OPEN/GETFILECHECKSUM in HttpFS. Contributed by Íñigo Goiri.\n",
          "commitDate": "16/11/18 9:12 AM",
          "commitName": "ad5256e44dffba2e9994f2db27d9ae71eab690e8",
          "commitAuthor": "Weiwei Yang",
          "commitDateOld": "11/10/18 3:01 PM",
          "commitNameOld": "6dcfef79afe97eda6d09fe2567bb4d4074223141",
          "commitAuthorOld": "Siyao Meng",
          "daysBetweenCommits": 35.8,
          "commitsBetweenForRepo": 324,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,190 +1,208 @@\n   public Response get(@PathParam(\"path\") String path,\n+                      @Context UriInfo uriInfo,\n                       @QueryParam(OperationParam.NAME) OperationParam op,\n                       @Context Parameters params,\n                       @Context HttpServletRequest request)\n     throws IOException, FileSystemAccessException {\n     UserGroupInformation user \u003d HttpUserGroupInformation.get();\n     Response response;\n     path \u003d makeAbsolute(path);\n     MDC.put(HttpFSFileSystem.OP_PARAM, op.value().name());\n     MDC.put(\"hostname\", request.getRemoteAddr());\n     switch (op.value()) {\n     case OPEN: {\n-      //Invoking the command directly using an unmanaged FileSystem that is\n-      // released by the FileSystemReleaseFilter\n-      final FSOperations.FSOpen command \u003d new FSOperations.FSOpen(path);\n-      final FileSystem fs \u003d createFileSystem(user);\n-      InputStream is \u003d null;\n-      UserGroupInformation ugi \u003d UserGroupInformation\n-          .createProxyUser(user.getShortUserName(),\n-              UserGroupInformation.getLoginUser());\n-      try {\n-        is \u003d ugi.doAs(new PrivilegedExceptionAction\u003cInputStream\u003e() {\n-          @Override\n-          public InputStream run() throws Exception {\n-            return command.execute(fs);\n-          }\n-        });\n-      } catch (InterruptedException ie) {\n-        LOG.info(\"Open interrupted.\", ie);\n-        Thread.currentThread().interrupt();\n+      Boolean noRedirect \u003d params.get(\n+          NoRedirectParam.NAME, NoRedirectParam.class);\n+      if (noRedirect) {\n+        URI redirectURL \u003d createOpenRedirectionURL(uriInfo);\n+        final String js \u003d JsonUtil.toJsonString(\"Location\", redirectURL);\n+        response \u003d Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n+      } else {\n+        //Invoking the command directly using an unmanaged FileSystem that is\n+        // released by the FileSystemReleaseFilter\n+        final FSOperations.FSOpen command \u003d new FSOperations.FSOpen(path);\n+        final FileSystem fs \u003d createFileSystem(user);\n+        InputStream is \u003d null;\n+        UserGroupInformation ugi \u003d UserGroupInformation\n+            .createProxyUser(user.getShortUserName(),\n+                UserGroupInformation.getLoginUser());\n+        try {\n+          is \u003d ugi.doAs(new PrivilegedExceptionAction\u003cInputStream\u003e() {\n+            @Override\n+            public InputStream run() throws Exception {\n+              return command.execute(fs);\n+            }\n+          });\n+        } catch (InterruptedException ie) {\n+          LOG.info(\"Open interrupted.\", ie);\n+          Thread.currentThread().interrupt();\n+        }\n+        Long offset \u003d params.get(OffsetParam.NAME, OffsetParam.class);\n+        Long len \u003d params.get(LenParam.NAME, LenParam.class);\n+        AUDIT_LOG.info(\"[{}] offset [{}] len [{}]\",\n+            new Object[] { path, offset, len });\n+        InputStreamEntity entity \u003d new InputStreamEntity(is, offset, len);\n+        response \u003d Response.ok(entity).type(MediaType.APPLICATION_OCTET_STREAM)\n+            .build();\n       }\n-      Long offset \u003d params.get(OffsetParam.NAME, OffsetParam.class);\n-      Long len \u003d params.get(LenParam.NAME, LenParam.class);\n-      AUDIT_LOG.info(\"[{}] offset [{}] len [{}]\",\n-          new Object[] { path, offset, len });\n-      InputStreamEntity entity \u003d new InputStreamEntity(is, offset, len);\n-      response \u003d\n-          Response.ok(entity).type(MediaType.APPLICATION_OCTET_STREAM).build();\n       break;\n     }\n     case GETFILESTATUS: {\n       FSOperations.FSFileStatus command \u003d new FSOperations.FSFileStatus(path);\n       Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case LISTSTATUS: {\n       String filter \u003d params.get(FilterParam.NAME, FilterParam.class);\n       FSOperations.FSListStatus command \u003d\n           new FSOperations.FSListStatus(path, filter);\n       Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}] filter [{}]\", path, (filter !\u003d null) ? filter : \"-\");\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETHOMEDIRECTORY: {\n       enforceRootPath(op.value(), path);\n       FSOperations.FSHomeDir command \u003d new FSOperations.FSHomeDir();\n       JSONObject json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"\");\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case INSTRUMENTATION: {\n       enforceRootPath(op.value(), path);\n       Groups groups \u003d HttpFSServerWebApp.get().get(Groups.class);\n       List\u003cString\u003e userGroups \u003d groups.getGroups(user.getShortUserName());\n       if (!userGroups.contains(HttpFSServerWebApp.get().getAdminGroup())) {\n         throw new AccessControlException(\n             \"User not in HttpFSServer admin group\");\n       }\n       Instrumentation instrumentation \u003d\n           HttpFSServerWebApp.get().get(Instrumentation.class);\n       Map snapshot \u003d instrumentation.getSnapshot();\n       response \u003d Response.ok(snapshot).build();\n       break;\n     }\n     case GETCONTENTSUMMARY: {\n       FSOperations.FSContentSummary command \u003d\n           new FSOperations.FSContentSummary(path);\n       Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETFILECHECKSUM: {\n       FSOperations.FSFileChecksum command \u003d\n           new FSOperations.FSFileChecksum(path);\n-      Map json \u003d fsExecute(user, command);\n+\n+      Boolean noRedirect \u003d params.get(\n+          NoRedirectParam.NAME, NoRedirectParam.class);\n       AUDIT_LOG.info(\"[{}]\", path);\n-      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n+      if (noRedirect) {\n+        URI redirectURL \u003d createOpenRedirectionURL(uriInfo);\n+        final String js \u003d JsonUtil.toJsonString(\"Location\", redirectURL);\n+        response \u003d Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n+      } else {\n+        Map json \u003d fsExecute(user, command);\n+        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n+      }\n       break;\n     }\n     case GETFILEBLOCKLOCATIONS: {\n       response \u003d Response.status(Response.Status.BAD_REQUEST).build();\n       break;\n     }\n     case GETACLSTATUS: {\n       FSOperations.FSAclStatus command \u003d new FSOperations.FSAclStatus(path);\n       Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"ACL status for [{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETXATTRS: {\n       List\u003cString\u003e xattrNames \u003d\n           params.getValues(XAttrNameParam.NAME, XAttrNameParam.class);\n       XAttrCodec encoding \u003d\n           params.get(XAttrEncodingParam.NAME, XAttrEncodingParam.class);\n       FSOperations.FSGetXAttrs command \u003d\n           new FSOperations.FSGetXAttrs(path, xattrNames, encoding);\n       @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"XAttrs for [{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case LISTXATTRS: {\n       FSOperations.FSListXAttrs command \u003d new FSOperations.FSListXAttrs(path);\n       @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"XAttr names for [{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case LISTSTATUS_BATCH: {\n       String startAfter \u003d params.get(\n           HttpFSParametersProvider.StartAfterParam.NAME,\n           HttpFSParametersProvider.StartAfterParam.class);\n       byte[] token \u003d HttpFSUtils.EMPTY_BYTES;\n       if (startAfter !\u003d null) {\n         token \u003d startAfter.getBytes(Charsets.UTF_8);\n       }\n       FSOperations.FSListStatusBatch command \u003d new FSOperations\n           .FSListStatusBatch(path, token);\n       @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}] token [{}]\", path, token);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETTRASHROOT: {\n       FSOperations.FSTrashRoot command \u003d new FSOperations.FSTrashRoot(path);\n       JSONObject json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETALLSTORAGEPOLICY: {\n       FSOperations.FSGetAllStoragePolicies command \u003d\n           new FSOperations.FSGetAllStoragePolicies();\n       JSONObject json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETSTORAGEPOLICY: {\n       FSOperations.FSGetStoragePolicy command \u003d\n           new FSOperations.FSGetStoragePolicy(path);\n       JSONObject json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETSNAPSHOTDIFF: {\n       String oldSnapshotName \u003d params.get(OldSnapshotNameParam.NAME,\n           OldSnapshotNameParam.class);\n       String snapshotName \u003d params.get(SnapshotNameParam.NAME,\n           SnapshotNameParam.class);\n       FSOperations.FSGetSnapshotDiff command \u003d\n           new FSOperations.FSGetSnapshotDiff(path, oldSnapshotName,\n               snapshotName);\n       String js \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETSNAPSHOTTABLEDIRECTORYLIST: {\n       FSOperations.FSGetSnapshottableDirListing command \u003d\n           new FSOperations.FSGetSnapshottableDirListing();\n       String js \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", \"/\");\n       response \u003d Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     default: {\n       throw new IOException(\n           MessageFormat.format(\"Invalid HTTP GET operation [{0}]\", op.value()));\n     }\n     }\n     return response;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Response get(@PathParam(\"path\") String path,\n                      @Context UriInfo uriInfo,\n                      @QueryParam(OperationParam.NAME) OperationParam op,\n                      @Context Parameters params,\n                      @Context HttpServletRequest request)\n    throws IOException, FileSystemAccessException {\n    UserGroupInformation user \u003d HttpUserGroupInformation.get();\n    Response response;\n    path \u003d makeAbsolute(path);\n    MDC.put(HttpFSFileSystem.OP_PARAM, op.value().name());\n    MDC.put(\"hostname\", request.getRemoteAddr());\n    switch (op.value()) {\n    case OPEN: {\n      Boolean noRedirect \u003d params.get(\n          NoRedirectParam.NAME, NoRedirectParam.class);\n      if (noRedirect) {\n        URI redirectURL \u003d createOpenRedirectionURL(uriInfo);\n        final String js \u003d JsonUtil.toJsonString(\"Location\", redirectURL);\n        response \u003d Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n      } else {\n        //Invoking the command directly using an unmanaged FileSystem that is\n        // released by the FileSystemReleaseFilter\n        final FSOperations.FSOpen command \u003d new FSOperations.FSOpen(path);\n        final FileSystem fs \u003d createFileSystem(user);\n        InputStream is \u003d null;\n        UserGroupInformation ugi \u003d UserGroupInformation\n            .createProxyUser(user.getShortUserName(),\n                UserGroupInformation.getLoginUser());\n        try {\n          is \u003d ugi.doAs(new PrivilegedExceptionAction\u003cInputStream\u003e() {\n            @Override\n            public InputStream run() throws Exception {\n              return command.execute(fs);\n            }\n          });\n        } catch (InterruptedException ie) {\n          LOG.info(\"Open interrupted.\", ie);\n          Thread.currentThread().interrupt();\n        }\n        Long offset \u003d params.get(OffsetParam.NAME, OffsetParam.class);\n        Long len \u003d params.get(LenParam.NAME, LenParam.class);\n        AUDIT_LOG.info(\"[{}] offset [{}] len [{}]\",\n            new Object[] { path, offset, len });\n        InputStreamEntity entity \u003d new InputStreamEntity(is, offset, len);\n        response \u003d Response.ok(entity).type(MediaType.APPLICATION_OCTET_STREAM)\n            .build();\n      }\n      break;\n    }\n    case GETFILESTATUS: {\n      FSOperations.FSFileStatus command \u003d new FSOperations.FSFileStatus(path);\n      Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case LISTSTATUS: {\n      String filter \u003d params.get(FilterParam.NAME, FilterParam.class);\n      FSOperations.FSListStatus command \u003d\n          new FSOperations.FSListStatus(path, filter);\n      Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}] filter [{}]\", path, (filter !\u003d null) ? filter : \"-\");\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETHOMEDIRECTORY: {\n      enforceRootPath(op.value(), path);\n      FSOperations.FSHomeDir command \u003d new FSOperations.FSHomeDir();\n      JSONObject json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"\");\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case INSTRUMENTATION: {\n      enforceRootPath(op.value(), path);\n      Groups groups \u003d HttpFSServerWebApp.get().get(Groups.class);\n      List\u003cString\u003e userGroups \u003d groups.getGroups(user.getShortUserName());\n      if (!userGroups.contains(HttpFSServerWebApp.get().getAdminGroup())) {\n        throw new AccessControlException(\n            \"User not in HttpFSServer admin group\");\n      }\n      Instrumentation instrumentation \u003d\n          HttpFSServerWebApp.get().get(Instrumentation.class);\n      Map snapshot \u003d instrumentation.getSnapshot();\n      response \u003d Response.ok(snapshot).build();\n      break;\n    }\n    case GETCONTENTSUMMARY: {\n      FSOperations.FSContentSummary command \u003d\n          new FSOperations.FSContentSummary(path);\n      Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETFILECHECKSUM: {\n      FSOperations.FSFileChecksum command \u003d\n          new FSOperations.FSFileChecksum(path);\n\n      Boolean noRedirect \u003d params.get(\n          NoRedirectParam.NAME, NoRedirectParam.class);\n      AUDIT_LOG.info(\"[{}]\", path);\n      if (noRedirect) {\n        URI redirectURL \u003d createOpenRedirectionURL(uriInfo);\n        final String js \u003d JsonUtil.toJsonString(\"Location\", redirectURL);\n        response \u003d Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n      } else {\n        Map json \u003d fsExecute(user, command);\n        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      }\n      break;\n    }\n    case GETFILEBLOCKLOCATIONS: {\n      response \u003d Response.status(Response.Status.BAD_REQUEST).build();\n      break;\n    }\n    case GETACLSTATUS: {\n      FSOperations.FSAclStatus command \u003d new FSOperations.FSAclStatus(path);\n      Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"ACL status for [{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETXATTRS: {\n      List\u003cString\u003e xattrNames \u003d\n          params.getValues(XAttrNameParam.NAME, XAttrNameParam.class);\n      XAttrCodec encoding \u003d\n          params.get(XAttrEncodingParam.NAME, XAttrEncodingParam.class);\n      FSOperations.FSGetXAttrs command \u003d\n          new FSOperations.FSGetXAttrs(path, xattrNames, encoding);\n      @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"XAttrs for [{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case LISTXATTRS: {\n      FSOperations.FSListXAttrs command \u003d new FSOperations.FSListXAttrs(path);\n      @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"XAttr names for [{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case LISTSTATUS_BATCH: {\n      String startAfter \u003d params.get(\n          HttpFSParametersProvider.StartAfterParam.NAME,\n          HttpFSParametersProvider.StartAfterParam.class);\n      byte[] token \u003d HttpFSUtils.EMPTY_BYTES;\n      if (startAfter !\u003d null) {\n        token \u003d startAfter.getBytes(Charsets.UTF_8);\n      }\n      FSOperations.FSListStatusBatch command \u003d new FSOperations\n          .FSListStatusBatch(path, token);\n      @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}] token [{}]\", path, token);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETTRASHROOT: {\n      FSOperations.FSTrashRoot command \u003d new FSOperations.FSTrashRoot(path);\n      JSONObject json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETALLSTORAGEPOLICY: {\n      FSOperations.FSGetAllStoragePolicies command \u003d\n          new FSOperations.FSGetAllStoragePolicies();\n      JSONObject json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETSTORAGEPOLICY: {\n      FSOperations.FSGetStoragePolicy command \u003d\n          new FSOperations.FSGetStoragePolicy(path);\n      JSONObject json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETSNAPSHOTDIFF: {\n      String oldSnapshotName \u003d params.get(OldSnapshotNameParam.NAME,\n          OldSnapshotNameParam.class);\n      String snapshotName \u003d params.get(SnapshotNameParam.NAME,\n          SnapshotNameParam.class);\n      FSOperations.FSGetSnapshotDiff command \u003d\n          new FSOperations.FSGetSnapshotDiff(path, oldSnapshotName,\n              snapshotName);\n      String js \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETSNAPSHOTTABLEDIRECTORYLIST: {\n      FSOperations.FSGetSnapshottableDirListing command \u003d\n          new FSOperations.FSGetSnapshottableDirListing();\n      String js \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", \"/\");\n      response \u003d Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    default: {\n      throw new IOException(\n          MessageFormat.format(\"Invalid HTTP GET operation [{0}]\", op.value()));\n    }\n    }\n    return response;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs-httpfs/src/main/java/org/apache/hadoop/fs/http/server/HttpFSServer.java",
          "extendedDetails": {
            "oldValue": "[path-String(annotations-@PathParam(\"path\")), op-OperationParam(annotations-@QueryParam(OperationParam.NAME)), params-Parameters(annotations-@Context), request-HttpServletRequest(annotations-@Context)]",
            "newValue": "[path-String(annotations-@PathParam(\"path\")), uriInfo-UriInfo(annotations-@Context), op-OperationParam(annotations-@QueryParam(OperationParam.NAME)), params-Parameters(annotations-@Context), request-HttpServletRequest(annotations-@Context)]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-14063. Support noredirect param for CREATE/APPEND/OPEN/GETFILECHECKSUM in HttpFS. Contributed by Íñigo Goiri.\n",
          "commitDate": "16/11/18 9:12 AM",
          "commitName": "ad5256e44dffba2e9994f2db27d9ae71eab690e8",
          "commitAuthor": "Weiwei Yang",
          "commitDateOld": "11/10/18 3:01 PM",
          "commitNameOld": "6dcfef79afe97eda6d09fe2567bb4d4074223141",
          "commitAuthorOld": "Siyao Meng",
          "daysBetweenCommits": 35.8,
          "commitsBetweenForRepo": 324,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,190 +1,208 @@\n   public Response get(@PathParam(\"path\") String path,\n+                      @Context UriInfo uriInfo,\n                       @QueryParam(OperationParam.NAME) OperationParam op,\n                       @Context Parameters params,\n                       @Context HttpServletRequest request)\n     throws IOException, FileSystemAccessException {\n     UserGroupInformation user \u003d HttpUserGroupInformation.get();\n     Response response;\n     path \u003d makeAbsolute(path);\n     MDC.put(HttpFSFileSystem.OP_PARAM, op.value().name());\n     MDC.put(\"hostname\", request.getRemoteAddr());\n     switch (op.value()) {\n     case OPEN: {\n-      //Invoking the command directly using an unmanaged FileSystem that is\n-      // released by the FileSystemReleaseFilter\n-      final FSOperations.FSOpen command \u003d new FSOperations.FSOpen(path);\n-      final FileSystem fs \u003d createFileSystem(user);\n-      InputStream is \u003d null;\n-      UserGroupInformation ugi \u003d UserGroupInformation\n-          .createProxyUser(user.getShortUserName(),\n-              UserGroupInformation.getLoginUser());\n-      try {\n-        is \u003d ugi.doAs(new PrivilegedExceptionAction\u003cInputStream\u003e() {\n-          @Override\n-          public InputStream run() throws Exception {\n-            return command.execute(fs);\n-          }\n-        });\n-      } catch (InterruptedException ie) {\n-        LOG.info(\"Open interrupted.\", ie);\n-        Thread.currentThread().interrupt();\n+      Boolean noRedirect \u003d params.get(\n+          NoRedirectParam.NAME, NoRedirectParam.class);\n+      if (noRedirect) {\n+        URI redirectURL \u003d createOpenRedirectionURL(uriInfo);\n+        final String js \u003d JsonUtil.toJsonString(\"Location\", redirectURL);\n+        response \u003d Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n+      } else {\n+        //Invoking the command directly using an unmanaged FileSystem that is\n+        // released by the FileSystemReleaseFilter\n+        final FSOperations.FSOpen command \u003d new FSOperations.FSOpen(path);\n+        final FileSystem fs \u003d createFileSystem(user);\n+        InputStream is \u003d null;\n+        UserGroupInformation ugi \u003d UserGroupInformation\n+            .createProxyUser(user.getShortUserName(),\n+                UserGroupInformation.getLoginUser());\n+        try {\n+          is \u003d ugi.doAs(new PrivilegedExceptionAction\u003cInputStream\u003e() {\n+            @Override\n+            public InputStream run() throws Exception {\n+              return command.execute(fs);\n+            }\n+          });\n+        } catch (InterruptedException ie) {\n+          LOG.info(\"Open interrupted.\", ie);\n+          Thread.currentThread().interrupt();\n+        }\n+        Long offset \u003d params.get(OffsetParam.NAME, OffsetParam.class);\n+        Long len \u003d params.get(LenParam.NAME, LenParam.class);\n+        AUDIT_LOG.info(\"[{}] offset [{}] len [{}]\",\n+            new Object[] { path, offset, len });\n+        InputStreamEntity entity \u003d new InputStreamEntity(is, offset, len);\n+        response \u003d Response.ok(entity).type(MediaType.APPLICATION_OCTET_STREAM)\n+            .build();\n       }\n-      Long offset \u003d params.get(OffsetParam.NAME, OffsetParam.class);\n-      Long len \u003d params.get(LenParam.NAME, LenParam.class);\n-      AUDIT_LOG.info(\"[{}] offset [{}] len [{}]\",\n-          new Object[] { path, offset, len });\n-      InputStreamEntity entity \u003d new InputStreamEntity(is, offset, len);\n-      response \u003d\n-          Response.ok(entity).type(MediaType.APPLICATION_OCTET_STREAM).build();\n       break;\n     }\n     case GETFILESTATUS: {\n       FSOperations.FSFileStatus command \u003d new FSOperations.FSFileStatus(path);\n       Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case LISTSTATUS: {\n       String filter \u003d params.get(FilterParam.NAME, FilterParam.class);\n       FSOperations.FSListStatus command \u003d\n           new FSOperations.FSListStatus(path, filter);\n       Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}] filter [{}]\", path, (filter !\u003d null) ? filter : \"-\");\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETHOMEDIRECTORY: {\n       enforceRootPath(op.value(), path);\n       FSOperations.FSHomeDir command \u003d new FSOperations.FSHomeDir();\n       JSONObject json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"\");\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case INSTRUMENTATION: {\n       enforceRootPath(op.value(), path);\n       Groups groups \u003d HttpFSServerWebApp.get().get(Groups.class);\n       List\u003cString\u003e userGroups \u003d groups.getGroups(user.getShortUserName());\n       if (!userGroups.contains(HttpFSServerWebApp.get().getAdminGroup())) {\n         throw new AccessControlException(\n             \"User not in HttpFSServer admin group\");\n       }\n       Instrumentation instrumentation \u003d\n           HttpFSServerWebApp.get().get(Instrumentation.class);\n       Map snapshot \u003d instrumentation.getSnapshot();\n       response \u003d Response.ok(snapshot).build();\n       break;\n     }\n     case GETCONTENTSUMMARY: {\n       FSOperations.FSContentSummary command \u003d\n           new FSOperations.FSContentSummary(path);\n       Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETFILECHECKSUM: {\n       FSOperations.FSFileChecksum command \u003d\n           new FSOperations.FSFileChecksum(path);\n-      Map json \u003d fsExecute(user, command);\n+\n+      Boolean noRedirect \u003d params.get(\n+          NoRedirectParam.NAME, NoRedirectParam.class);\n       AUDIT_LOG.info(\"[{}]\", path);\n-      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n+      if (noRedirect) {\n+        URI redirectURL \u003d createOpenRedirectionURL(uriInfo);\n+        final String js \u003d JsonUtil.toJsonString(\"Location\", redirectURL);\n+        response \u003d Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n+      } else {\n+        Map json \u003d fsExecute(user, command);\n+        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n+      }\n       break;\n     }\n     case GETFILEBLOCKLOCATIONS: {\n       response \u003d Response.status(Response.Status.BAD_REQUEST).build();\n       break;\n     }\n     case GETACLSTATUS: {\n       FSOperations.FSAclStatus command \u003d new FSOperations.FSAclStatus(path);\n       Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"ACL status for [{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETXATTRS: {\n       List\u003cString\u003e xattrNames \u003d\n           params.getValues(XAttrNameParam.NAME, XAttrNameParam.class);\n       XAttrCodec encoding \u003d\n           params.get(XAttrEncodingParam.NAME, XAttrEncodingParam.class);\n       FSOperations.FSGetXAttrs command \u003d\n           new FSOperations.FSGetXAttrs(path, xattrNames, encoding);\n       @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"XAttrs for [{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case LISTXATTRS: {\n       FSOperations.FSListXAttrs command \u003d new FSOperations.FSListXAttrs(path);\n       @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"XAttr names for [{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case LISTSTATUS_BATCH: {\n       String startAfter \u003d params.get(\n           HttpFSParametersProvider.StartAfterParam.NAME,\n           HttpFSParametersProvider.StartAfterParam.class);\n       byte[] token \u003d HttpFSUtils.EMPTY_BYTES;\n       if (startAfter !\u003d null) {\n         token \u003d startAfter.getBytes(Charsets.UTF_8);\n       }\n       FSOperations.FSListStatusBatch command \u003d new FSOperations\n           .FSListStatusBatch(path, token);\n       @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}] token [{}]\", path, token);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETTRASHROOT: {\n       FSOperations.FSTrashRoot command \u003d new FSOperations.FSTrashRoot(path);\n       JSONObject json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETALLSTORAGEPOLICY: {\n       FSOperations.FSGetAllStoragePolicies command \u003d\n           new FSOperations.FSGetAllStoragePolicies();\n       JSONObject json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETSTORAGEPOLICY: {\n       FSOperations.FSGetStoragePolicy command \u003d\n           new FSOperations.FSGetStoragePolicy(path);\n       JSONObject json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETSNAPSHOTDIFF: {\n       String oldSnapshotName \u003d params.get(OldSnapshotNameParam.NAME,\n           OldSnapshotNameParam.class);\n       String snapshotName \u003d params.get(SnapshotNameParam.NAME,\n           SnapshotNameParam.class);\n       FSOperations.FSGetSnapshotDiff command \u003d\n           new FSOperations.FSGetSnapshotDiff(path, oldSnapshotName,\n               snapshotName);\n       String js \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETSNAPSHOTTABLEDIRECTORYLIST: {\n       FSOperations.FSGetSnapshottableDirListing command \u003d\n           new FSOperations.FSGetSnapshottableDirListing();\n       String js \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", \"/\");\n       response \u003d Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     default: {\n       throw new IOException(\n           MessageFormat.format(\"Invalid HTTP GET operation [{0}]\", op.value()));\n     }\n     }\n     return response;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Response get(@PathParam(\"path\") String path,\n                      @Context UriInfo uriInfo,\n                      @QueryParam(OperationParam.NAME) OperationParam op,\n                      @Context Parameters params,\n                      @Context HttpServletRequest request)\n    throws IOException, FileSystemAccessException {\n    UserGroupInformation user \u003d HttpUserGroupInformation.get();\n    Response response;\n    path \u003d makeAbsolute(path);\n    MDC.put(HttpFSFileSystem.OP_PARAM, op.value().name());\n    MDC.put(\"hostname\", request.getRemoteAddr());\n    switch (op.value()) {\n    case OPEN: {\n      Boolean noRedirect \u003d params.get(\n          NoRedirectParam.NAME, NoRedirectParam.class);\n      if (noRedirect) {\n        URI redirectURL \u003d createOpenRedirectionURL(uriInfo);\n        final String js \u003d JsonUtil.toJsonString(\"Location\", redirectURL);\n        response \u003d Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n      } else {\n        //Invoking the command directly using an unmanaged FileSystem that is\n        // released by the FileSystemReleaseFilter\n        final FSOperations.FSOpen command \u003d new FSOperations.FSOpen(path);\n        final FileSystem fs \u003d createFileSystem(user);\n        InputStream is \u003d null;\n        UserGroupInformation ugi \u003d UserGroupInformation\n            .createProxyUser(user.getShortUserName(),\n                UserGroupInformation.getLoginUser());\n        try {\n          is \u003d ugi.doAs(new PrivilegedExceptionAction\u003cInputStream\u003e() {\n            @Override\n            public InputStream run() throws Exception {\n              return command.execute(fs);\n            }\n          });\n        } catch (InterruptedException ie) {\n          LOG.info(\"Open interrupted.\", ie);\n          Thread.currentThread().interrupt();\n        }\n        Long offset \u003d params.get(OffsetParam.NAME, OffsetParam.class);\n        Long len \u003d params.get(LenParam.NAME, LenParam.class);\n        AUDIT_LOG.info(\"[{}] offset [{}] len [{}]\",\n            new Object[] { path, offset, len });\n        InputStreamEntity entity \u003d new InputStreamEntity(is, offset, len);\n        response \u003d Response.ok(entity).type(MediaType.APPLICATION_OCTET_STREAM)\n            .build();\n      }\n      break;\n    }\n    case GETFILESTATUS: {\n      FSOperations.FSFileStatus command \u003d new FSOperations.FSFileStatus(path);\n      Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case LISTSTATUS: {\n      String filter \u003d params.get(FilterParam.NAME, FilterParam.class);\n      FSOperations.FSListStatus command \u003d\n          new FSOperations.FSListStatus(path, filter);\n      Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}] filter [{}]\", path, (filter !\u003d null) ? filter : \"-\");\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETHOMEDIRECTORY: {\n      enforceRootPath(op.value(), path);\n      FSOperations.FSHomeDir command \u003d new FSOperations.FSHomeDir();\n      JSONObject json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"\");\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case INSTRUMENTATION: {\n      enforceRootPath(op.value(), path);\n      Groups groups \u003d HttpFSServerWebApp.get().get(Groups.class);\n      List\u003cString\u003e userGroups \u003d groups.getGroups(user.getShortUserName());\n      if (!userGroups.contains(HttpFSServerWebApp.get().getAdminGroup())) {\n        throw new AccessControlException(\n            \"User not in HttpFSServer admin group\");\n      }\n      Instrumentation instrumentation \u003d\n          HttpFSServerWebApp.get().get(Instrumentation.class);\n      Map snapshot \u003d instrumentation.getSnapshot();\n      response \u003d Response.ok(snapshot).build();\n      break;\n    }\n    case GETCONTENTSUMMARY: {\n      FSOperations.FSContentSummary command \u003d\n          new FSOperations.FSContentSummary(path);\n      Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETFILECHECKSUM: {\n      FSOperations.FSFileChecksum command \u003d\n          new FSOperations.FSFileChecksum(path);\n\n      Boolean noRedirect \u003d params.get(\n          NoRedirectParam.NAME, NoRedirectParam.class);\n      AUDIT_LOG.info(\"[{}]\", path);\n      if (noRedirect) {\n        URI redirectURL \u003d createOpenRedirectionURL(uriInfo);\n        final String js \u003d JsonUtil.toJsonString(\"Location\", redirectURL);\n        response \u003d Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n      } else {\n        Map json \u003d fsExecute(user, command);\n        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      }\n      break;\n    }\n    case GETFILEBLOCKLOCATIONS: {\n      response \u003d Response.status(Response.Status.BAD_REQUEST).build();\n      break;\n    }\n    case GETACLSTATUS: {\n      FSOperations.FSAclStatus command \u003d new FSOperations.FSAclStatus(path);\n      Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"ACL status for [{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETXATTRS: {\n      List\u003cString\u003e xattrNames \u003d\n          params.getValues(XAttrNameParam.NAME, XAttrNameParam.class);\n      XAttrCodec encoding \u003d\n          params.get(XAttrEncodingParam.NAME, XAttrEncodingParam.class);\n      FSOperations.FSGetXAttrs command \u003d\n          new FSOperations.FSGetXAttrs(path, xattrNames, encoding);\n      @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"XAttrs for [{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case LISTXATTRS: {\n      FSOperations.FSListXAttrs command \u003d new FSOperations.FSListXAttrs(path);\n      @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"XAttr names for [{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case LISTSTATUS_BATCH: {\n      String startAfter \u003d params.get(\n          HttpFSParametersProvider.StartAfterParam.NAME,\n          HttpFSParametersProvider.StartAfterParam.class);\n      byte[] token \u003d HttpFSUtils.EMPTY_BYTES;\n      if (startAfter !\u003d null) {\n        token \u003d startAfter.getBytes(Charsets.UTF_8);\n      }\n      FSOperations.FSListStatusBatch command \u003d new FSOperations\n          .FSListStatusBatch(path, token);\n      @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}] token [{}]\", path, token);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETTRASHROOT: {\n      FSOperations.FSTrashRoot command \u003d new FSOperations.FSTrashRoot(path);\n      JSONObject json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETALLSTORAGEPOLICY: {\n      FSOperations.FSGetAllStoragePolicies command \u003d\n          new FSOperations.FSGetAllStoragePolicies();\n      JSONObject json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETSTORAGEPOLICY: {\n      FSOperations.FSGetStoragePolicy command \u003d\n          new FSOperations.FSGetStoragePolicy(path);\n      JSONObject json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETSNAPSHOTDIFF: {\n      String oldSnapshotName \u003d params.get(OldSnapshotNameParam.NAME,\n          OldSnapshotNameParam.class);\n      String snapshotName \u003d params.get(SnapshotNameParam.NAME,\n          SnapshotNameParam.class);\n      FSOperations.FSGetSnapshotDiff command \u003d\n          new FSOperations.FSGetSnapshotDiff(path, oldSnapshotName,\n              snapshotName);\n      String js \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETSNAPSHOTTABLEDIRECTORYLIST: {\n      FSOperations.FSGetSnapshottableDirListing command \u003d\n          new FSOperations.FSGetSnapshottableDirListing();\n      String js \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", \"/\");\n      response \u003d Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    default: {\n      throw new IOException(\n          MessageFormat.format(\"Invalid HTTP GET operation [{0}]\", op.value()));\n    }\n    }\n    return response;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs-httpfs/src/main/java/org/apache/hadoop/fs/http/server/HttpFSServer.java",
          "extendedDetails": {}
        }
      ]
    },
    "6dcfef79afe97eda6d09fe2567bb4d4074223141": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13878. HttpFS: Implement GETSNAPSHOTTABLEDIRECTORYLIST. Contributed by Siyao Meng.\n\nSigned-off-by: Wei-Chiu Chuang \u003cweichiu@apache.org\u003e\n",
      "commitDate": "11/10/18 3:01 PM",
      "commitName": "6dcfef79afe97eda6d09fe2567bb4d4074223141",
      "commitAuthor": "Siyao Meng",
      "commitDateOld": "04/10/18 3:17 PM",
      "commitNameOld": "396ce0d9f470a5e8af03987ad6396d0f08b3d225",
      "commitAuthorOld": "Siyao Meng",
      "daysBetweenCommits": 6.99,
      "commitsBetweenForRepo": 80,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,182 +1,190 @@\n   public Response get(@PathParam(\"path\") String path,\n                       @QueryParam(OperationParam.NAME) OperationParam op,\n                       @Context Parameters params,\n                       @Context HttpServletRequest request)\n     throws IOException, FileSystemAccessException {\n     UserGroupInformation user \u003d HttpUserGroupInformation.get();\n     Response response;\n     path \u003d makeAbsolute(path);\n     MDC.put(HttpFSFileSystem.OP_PARAM, op.value().name());\n     MDC.put(\"hostname\", request.getRemoteAddr());\n     switch (op.value()) {\n     case OPEN: {\n       //Invoking the command directly using an unmanaged FileSystem that is\n       // released by the FileSystemReleaseFilter\n       final FSOperations.FSOpen command \u003d new FSOperations.FSOpen(path);\n       final FileSystem fs \u003d createFileSystem(user);\n       InputStream is \u003d null;\n       UserGroupInformation ugi \u003d UserGroupInformation\n           .createProxyUser(user.getShortUserName(),\n               UserGroupInformation.getLoginUser());\n       try {\n         is \u003d ugi.doAs(new PrivilegedExceptionAction\u003cInputStream\u003e() {\n           @Override\n           public InputStream run() throws Exception {\n             return command.execute(fs);\n           }\n         });\n       } catch (InterruptedException ie) {\n         LOG.info(\"Open interrupted.\", ie);\n         Thread.currentThread().interrupt();\n       }\n       Long offset \u003d params.get(OffsetParam.NAME, OffsetParam.class);\n       Long len \u003d params.get(LenParam.NAME, LenParam.class);\n       AUDIT_LOG.info(\"[{}] offset [{}] len [{}]\",\n           new Object[] { path, offset, len });\n       InputStreamEntity entity \u003d new InputStreamEntity(is, offset, len);\n       response \u003d\n           Response.ok(entity).type(MediaType.APPLICATION_OCTET_STREAM).build();\n       break;\n     }\n     case GETFILESTATUS: {\n       FSOperations.FSFileStatus command \u003d new FSOperations.FSFileStatus(path);\n       Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case LISTSTATUS: {\n       String filter \u003d params.get(FilterParam.NAME, FilterParam.class);\n       FSOperations.FSListStatus command \u003d\n           new FSOperations.FSListStatus(path, filter);\n       Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}] filter [{}]\", path, (filter !\u003d null) ? filter : \"-\");\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETHOMEDIRECTORY: {\n       enforceRootPath(op.value(), path);\n       FSOperations.FSHomeDir command \u003d new FSOperations.FSHomeDir();\n       JSONObject json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"\");\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case INSTRUMENTATION: {\n       enforceRootPath(op.value(), path);\n       Groups groups \u003d HttpFSServerWebApp.get().get(Groups.class);\n       List\u003cString\u003e userGroups \u003d groups.getGroups(user.getShortUserName());\n       if (!userGroups.contains(HttpFSServerWebApp.get().getAdminGroup())) {\n         throw new AccessControlException(\n             \"User not in HttpFSServer admin group\");\n       }\n       Instrumentation instrumentation \u003d\n           HttpFSServerWebApp.get().get(Instrumentation.class);\n       Map snapshot \u003d instrumentation.getSnapshot();\n       response \u003d Response.ok(snapshot).build();\n       break;\n     }\n     case GETCONTENTSUMMARY: {\n       FSOperations.FSContentSummary command \u003d\n           new FSOperations.FSContentSummary(path);\n       Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETFILECHECKSUM: {\n       FSOperations.FSFileChecksum command \u003d\n           new FSOperations.FSFileChecksum(path);\n       Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETFILEBLOCKLOCATIONS: {\n       response \u003d Response.status(Response.Status.BAD_REQUEST).build();\n       break;\n     }\n     case GETACLSTATUS: {\n       FSOperations.FSAclStatus command \u003d new FSOperations.FSAclStatus(path);\n       Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"ACL status for [{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETXATTRS: {\n       List\u003cString\u003e xattrNames \u003d\n           params.getValues(XAttrNameParam.NAME, XAttrNameParam.class);\n       XAttrCodec encoding \u003d\n           params.get(XAttrEncodingParam.NAME, XAttrEncodingParam.class);\n       FSOperations.FSGetXAttrs command \u003d\n           new FSOperations.FSGetXAttrs(path, xattrNames, encoding);\n       @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"XAttrs for [{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case LISTXATTRS: {\n       FSOperations.FSListXAttrs command \u003d new FSOperations.FSListXAttrs(path);\n       @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"XAttr names for [{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case LISTSTATUS_BATCH: {\n       String startAfter \u003d params.get(\n           HttpFSParametersProvider.StartAfterParam.NAME,\n           HttpFSParametersProvider.StartAfterParam.class);\n       byte[] token \u003d HttpFSUtils.EMPTY_BYTES;\n       if (startAfter !\u003d null) {\n         token \u003d startAfter.getBytes(Charsets.UTF_8);\n       }\n       FSOperations.FSListStatusBatch command \u003d new FSOperations\n           .FSListStatusBatch(path, token);\n       @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}] token [{}]\", path, token);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETTRASHROOT: {\n       FSOperations.FSTrashRoot command \u003d new FSOperations.FSTrashRoot(path);\n       JSONObject json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETALLSTORAGEPOLICY: {\n       FSOperations.FSGetAllStoragePolicies command \u003d\n           new FSOperations.FSGetAllStoragePolicies();\n       JSONObject json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETSTORAGEPOLICY: {\n       FSOperations.FSGetStoragePolicy command \u003d\n           new FSOperations.FSGetStoragePolicy(path);\n       JSONObject json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETSNAPSHOTDIFF: {\n       String oldSnapshotName \u003d params.get(OldSnapshotNameParam.NAME,\n           OldSnapshotNameParam.class);\n       String snapshotName \u003d params.get(SnapshotNameParam.NAME,\n           SnapshotNameParam.class);\n       FSOperations.FSGetSnapshotDiff command \u003d\n           new FSOperations.FSGetSnapshotDiff(path, oldSnapshotName,\n               snapshotName);\n       String js \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n+    case GETSNAPSHOTTABLEDIRECTORYLIST: {\n+      FSOperations.FSGetSnapshottableDirListing command \u003d\n+          new FSOperations.FSGetSnapshottableDirListing();\n+      String js \u003d fsExecute(user, command);\n+      AUDIT_LOG.info(\"[{}]\", \"/\");\n+      response \u003d Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n+      break;\n+    }\n     default: {\n       throw new IOException(\n           MessageFormat.format(\"Invalid HTTP GET operation [{0}]\", op.value()));\n     }\n     }\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Response get(@PathParam(\"path\") String path,\n                      @QueryParam(OperationParam.NAME) OperationParam op,\n                      @Context Parameters params,\n                      @Context HttpServletRequest request)\n    throws IOException, FileSystemAccessException {\n    UserGroupInformation user \u003d HttpUserGroupInformation.get();\n    Response response;\n    path \u003d makeAbsolute(path);\n    MDC.put(HttpFSFileSystem.OP_PARAM, op.value().name());\n    MDC.put(\"hostname\", request.getRemoteAddr());\n    switch (op.value()) {\n    case OPEN: {\n      //Invoking the command directly using an unmanaged FileSystem that is\n      // released by the FileSystemReleaseFilter\n      final FSOperations.FSOpen command \u003d new FSOperations.FSOpen(path);\n      final FileSystem fs \u003d createFileSystem(user);\n      InputStream is \u003d null;\n      UserGroupInformation ugi \u003d UserGroupInformation\n          .createProxyUser(user.getShortUserName(),\n              UserGroupInformation.getLoginUser());\n      try {\n        is \u003d ugi.doAs(new PrivilegedExceptionAction\u003cInputStream\u003e() {\n          @Override\n          public InputStream run() throws Exception {\n            return command.execute(fs);\n          }\n        });\n      } catch (InterruptedException ie) {\n        LOG.info(\"Open interrupted.\", ie);\n        Thread.currentThread().interrupt();\n      }\n      Long offset \u003d params.get(OffsetParam.NAME, OffsetParam.class);\n      Long len \u003d params.get(LenParam.NAME, LenParam.class);\n      AUDIT_LOG.info(\"[{}] offset [{}] len [{}]\",\n          new Object[] { path, offset, len });\n      InputStreamEntity entity \u003d new InputStreamEntity(is, offset, len);\n      response \u003d\n          Response.ok(entity).type(MediaType.APPLICATION_OCTET_STREAM).build();\n      break;\n    }\n    case GETFILESTATUS: {\n      FSOperations.FSFileStatus command \u003d new FSOperations.FSFileStatus(path);\n      Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case LISTSTATUS: {\n      String filter \u003d params.get(FilterParam.NAME, FilterParam.class);\n      FSOperations.FSListStatus command \u003d\n          new FSOperations.FSListStatus(path, filter);\n      Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}] filter [{}]\", path, (filter !\u003d null) ? filter : \"-\");\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETHOMEDIRECTORY: {\n      enforceRootPath(op.value(), path);\n      FSOperations.FSHomeDir command \u003d new FSOperations.FSHomeDir();\n      JSONObject json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"\");\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case INSTRUMENTATION: {\n      enforceRootPath(op.value(), path);\n      Groups groups \u003d HttpFSServerWebApp.get().get(Groups.class);\n      List\u003cString\u003e userGroups \u003d groups.getGroups(user.getShortUserName());\n      if (!userGroups.contains(HttpFSServerWebApp.get().getAdminGroup())) {\n        throw new AccessControlException(\n            \"User not in HttpFSServer admin group\");\n      }\n      Instrumentation instrumentation \u003d\n          HttpFSServerWebApp.get().get(Instrumentation.class);\n      Map snapshot \u003d instrumentation.getSnapshot();\n      response \u003d Response.ok(snapshot).build();\n      break;\n    }\n    case GETCONTENTSUMMARY: {\n      FSOperations.FSContentSummary command \u003d\n          new FSOperations.FSContentSummary(path);\n      Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETFILECHECKSUM: {\n      FSOperations.FSFileChecksum command \u003d\n          new FSOperations.FSFileChecksum(path);\n      Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETFILEBLOCKLOCATIONS: {\n      response \u003d Response.status(Response.Status.BAD_REQUEST).build();\n      break;\n    }\n    case GETACLSTATUS: {\n      FSOperations.FSAclStatus command \u003d new FSOperations.FSAclStatus(path);\n      Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"ACL status for [{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETXATTRS: {\n      List\u003cString\u003e xattrNames \u003d\n          params.getValues(XAttrNameParam.NAME, XAttrNameParam.class);\n      XAttrCodec encoding \u003d\n          params.get(XAttrEncodingParam.NAME, XAttrEncodingParam.class);\n      FSOperations.FSGetXAttrs command \u003d\n          new FSOperations.FSGetXAttrs(path, xattrNames, encoding);\n      @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"XAttrs for [{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case LISTXATTRS: {\n      FSOperations.FSListXAttrs command \u003d new FSOperations.FSListXAttrs(path);\n      @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"XAttr names for [{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case LISTSTATUS_BATCH: {\n      String startAfter \u003d params.get(\n          HttpFSParametersProvider.StartAfterParam.NAME,\n          HttpFSParametersProvider.StartAfterParam.class);\n      byte[] token \u003d HttpFSUtils.EMPTY_BYTES;\n      if (startAfter !\u003d null) {\n        token \u003d startAfter.getBytes(Charsets.UTF_8);\n      }\n      FSOperations.FSListStatusBatch command \u003d new FSOperations\n          .FSListStatusBatch(path, token);\n      @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}] token [{}]\", path, token);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETTRASHROOT: {\n      FSOperations.FSTrashRoot command \u003d new FSOperations.FSTrashRoot(path);\n      JSONObject json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETALLSTORAGEPOLICY: {\n      FSOperations.FSGetAllStoragePolicies command \u003d\n          new FSOperations.FSGetAllStoragePolicies();\n      JSONObject json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETSTORAGEPOLICY: {\n      FSOperations.FSGetStoragePolicy command \u003d\n          new FSOperations.FSGetStoragePolicy(path);\n      JSONObject json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETSNAPSHOTDIFF: {\n      String oldSnapshotName \u003d params.get(OldSnapshotNameParam.NAME,\n          OldSnapshotNameParam.class);\n      String snapshotName \u003d params.get(SnapshotNameParam.NAME,\n          SnapshotNameParam.class);\n      FSOperations.FSGetSnapshotDiff command \u003d\n          new FSOperations.FSGetSnapshotDiff(path, oldSnapshotName,\n              snapshotName);\n      String js \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETSNAPSHOTTABLEDIRECTORYLIST: {\n      FSOperations.FSGetSnapshottableDirListing command \u003d\n          new FSOperations.FSGetSnapshottableDirListing();\n      String js \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", \"/\");\n      response \u003d Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    default: {\n      throw new IOException(\n          MessageFormat.format(\"Invalid HTTP GET operation [{0}]\", op.value()));\n    }\n    }\n    return response;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-httpfs/src/main/java/org/apache/hadoop/fs/http/server/HttpFSServer.java",
      "extendedDetails": {}
    },
    "396ce0d9f470a5e8af03987ad6396d0f08b3d225": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13877. HttpFS: Implement GETSNAPSHOTDIFF. Contributed by Siyao Meng.\n\nSigned-off-by: Wei-Chiu Chuang \u003cweichiu@apache.org\u003e\n",
      "commitDate": "04/10/18 3:17 PM",
      "commitName": "396ce0d9f470a5e8af03987ad6396d0f08b3d225",
      "commitAuthor": "Siyao Meng",
      "commitDateOld": "24/09/18 10:40 AM",
      "commitNameOld": "8de5c923b432a670f6822189e7131d2df7b5a336",
      "commitAuthorOld": "Siyao Meng",
      "daysBetweenCommits": 10.19,
      "commitsBetweenForRepo": 75,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,169 +1,182 @@\n   public Response get(@PathParam(\"path\") String path,\n                       @QueryParam(OperationParam.NAME) OperationParam op,\n                       @Context Parameters params,\n                       @Context HttpServletRequest request)\n     throws IOException, FileSystemAccessException {\n     UserGroupInformation user \u003d HttpUserGroupInformation.get();\n     Response response;\n     path \u003d makeAbsolute(path);\n     MDC.put(HttpFSFileSystem.OP_PARAM, op.value().name());\n     MDC.put(\"hostname\", request.getRemoteAddr());\n     switch (op.value()) {\n     case OPEN: {\n       //Invoking the command directly using an unmanaged FileSystem that is\n       // released by the FileSystemReleaseFilter\n       final FSOperations.FSOpen command \u003d new FSOperations.FSOpen(path);\n       final FileSystem fs \u003d createFileSystem(user);\n       InputStream is \u003d null;\n       UserGroupInformation ugi \u003d UserGroupInformation\n           .createProxyUser(user.getShortUserName(),\n               UserGroupInformation.getLoginUser());\n       try {\n         is \u003d ugi.doAs(new PrivilegedExceptionAction\u003cInputStream\u003e() {\n           @Override\n           public InputStream run() throws Exception {\n             return command.execute(fs);\n           }\n         });\n       } catch (InterruptedException ie) {\n         LOG.info(\"Open interrupted.\", ie);\n         Thread.currentThread().interrupt();\n       }\n       Long offset \u003d params.get(OffsetParam.NAME, OffsetParam.class);\n       Long len \u003d params.get(LenParam.NAME, LenParam.class);\n       AUDIT_LOG.info(\"[{}] offset [{}] len [{}]\",\n           new Object[] { path, offset, len });\n       InputStreamEntity entity \u003d new InputStreamEntity(is, offset, len);\n       response \u003d\n           Response.ok(entity).type(MediaType.APPLICATION_OCTET_STREAM).build();\n       break;\n     }\n     case GETFILESTATUS: {\n       FSOperations.FSFileStatus command \u003d new FSOperations.FSFileStatus(path);\n       Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case LISTSTATUS: {\n       String filter \u003d params.get(FilterParam.NAME, FilterParam.class);\n       FSOperations.FSListStatus command \u003d\n           new FSOperations.FSListStatus(path, filter);\n       Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}] filter [{}]\", path, (filter !\u003d null) ? filter : \"-\");\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETHOMEDIRECTORY: {\n       enforceRootPath(op.value(), path);\n       FSOperations.FSHomeDir command \u003d new FSOperations.FSHomeDir();\n       JSONObject json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"\");\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case INSTRUMENTATION: {\n       enforceRootPath(op.value(), path);\n       Groups groups \u003d HttpFSServerWebApp.get().get(Groups.class);\n       List\u003cString\u003e userGroups \u003d groups.getGroups(user.getShortUserName());\n       if (!userGroups.contains(HttpFSServerWebApp.get().getAdminGroup())) {\n         throw new AccessControlException(\n             \"User not in HttpFSServer admin group\");\n       }\n       Instrumentation instrumentation \u003d\n           HttpFSServerWebApp.get().get(Instrumentation.class);\n       Map snapshot \u003d instrumentation.getSnapshot();\n       response \u003d Response.ok(snapshot).build();\n       break;\n     }\n     case GETCONTENTSUMMARY: {\n       FSOperations.FSContentSummary command \u003d\n           new FSOperations.FSContentSummary(path);\n       Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETFILECHECKSUM: {\n       FSOperations.FSFileChecksum command \u003d\n           new FSOperations.FSFileChecksum(path);\n       Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETFILEBLOCKLOCATIONS: {\n       response \u003d Response.status(Response.Status.BAD_REQUEST).build();\n       break;\n     }\n     case GETACLSTATUS: {\n       FSOperations.FSAclStatus command \u003d new FSOperations.FSAclStatus(path);\n       Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"ACL status for [{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETXATTRS: {\n       List\u003cString\u003e xattrNames \u003d\n           params.getValues(XAttrNameParam.NAME, XAttrNameParam.class);\n       XAttrCodec encoding \u003d\n           params.get(XAttrEncodingParam.NAME, XAttrEncodingParam.class);\n       FSOperations.FSGetXAttrs command \u003d\n           new FSOperations.FSGetXAttrs(path, xattrNames, encoding);\n       @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"XAttrs for [{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case LISTXATTRS: {\n       FSOperations.FSListXAttrs command \u003d new FSOperations.FSListXAttrs(path);\n       @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"XAttr names for [{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case LISTSTATUS_BATCH: {\n       String startAfter \u003d params.get(\n           HttpFSParametersProvider.StartAfterParam.NAME,\n           HttpFSParametersProvider.StartAfterParam.class);\n       byte[] token \u003d HttpFSUtils.EMPTY_BYTES;\n       if (startAfter !\u003d null) {\n         token \u003d startAfter.getBytes(Charsets.UTF_8);\n       }\n       FSOperations.FSListStatusBatch command \u003d new FSOperations\n           .FSListStatusBatch(path, token);\n       @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}] token [{}]\", path, token);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETTRASHROOT: {\n       FSOperations.FSTrashRoot command \u003d new FSOperations.FSTrashRoot(path);\n       JSONObject json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETALLSTORAGEPOLICY: {\n       FSOperations.FSGetAllStoragePolicies command \u003d\n           new FSOperations.FSGetAllStoragePolicies();\n       JSONObject json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETSTORAGEPOLICY: {\n       FSOperations.FSGetStoragePolicy command \u003d\n           new FSOperations.FSGetStoragePolicy(path);\n       JSONObject json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n+    case GETSNAPSHOTDIFF: {\n+      String oldSnapshotName \u003d params.get(OldSnapshotNameParam.NAME,\n+          OldSnapshotNameParam.class);\n+      String snapshotName \u003d params.get(SnapshotNameParam.NAME,\n+          SnapshotNameParam.class);\n+      FSOperations.FSGetSnapshotDiff command \u003d\n+          new FSOperations.FSGetSnapshotDiff(path, oldSnapshotName,\n+              snapshotName);\n+      String js \u003d fsExecute(user, command);\n+      AUDIT_LOG.info(\"[{}]\", path);\n+      response \u003d Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n+      break;\n+    }\n     default: {\n       throw new IOException(\n           MessageFormat.format(\"Invalid HTTP GET operation [{0}]\", op.value()));\n     }\n     }\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Response get(@PathParam(\"path\") String path,\n                      @QueryParam(OperationParam.NAME) OperationParam op,\n                      @Context Parameters params,\n                      @Context HttpServletRequest request)\n    throws IOException, FileSystemAccessException {\n    UserGroupInformation user \u003d HttpUserGroupInformation.get();\n    Response response;\n    path \u003d makeAbsolute(path);\n    MDC.put(HttpFSFileSystem.OP_PARAM, op.value().name());\n    MDC.put(\"hostname\", request.getRemoteAddr());\n    switch (op.value()) {\n    case OPEN: {\n      //Invoking the command directly using an unmanaged FileSystem that is\n      // released by the FileSystemReleaseFilter\n      final FSOperations.FSOpen command \u003d new FSOperations.FSOpen(path);\n      final FileSystem fs \u003d createFileSystem(user);\n      InputStream is \u003d null;\n      UserGroupInformation ugi \u003d UserGroupInformation\n          .createProxyUser(user.getShortUserName(),\n              UserGroupInformation.getLoginUser());\n      try {\n        is \u003d ugi.doAs(new PrivilegedExceptionAction\u003cInputStream\u003e() {\n          @Override\n          public InputStream run() throws Exception {\n            return command.execute(fs);\n          }\n        });\n      } catch (InterruptedException ie) {\n        LOG.info(\"Open interrupted.\", ie);\n        Thread.currentThread().interrupt();\n      }\n      Long offset \u003d params.get(OffsetParam.NAME, OffsetParam.class);\n      Long len \u003d params.get(LenParam.NAME, LenParam.class);\n      AUDIT_LOG.info(\"[{}] offset [{}] len [{}]\",\n          new Object[] { path, offset, len });\n      InputStreamEntity entity \u003d new InputStreamEntity(is, offset, len);\n      response \u003d\n          Response.ok(entity).type(MediaType.APPLICATION_OCTET_STREAM).build();\n      break;\n    }\n    case GETFILESTATUS: {\n      FSOperations.FSFileStatus command \u003d new FSOperations.FSFileStatus(path);\n      Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case LISTSTATUS: {\n      String filter \u003d params.get(FilterParam.NAME, FilterParam.class);\n      FSOperations.FSListStatus command \u003d\n          new FSOperations.FSListStatus(path, filter);\n      Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}] filter [{}]\", path, (filter !\u003d null) ? filter : \"-\");\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETHOMEDIRECTORY: {\n      enforceRootPath(op.value(), path);\n      FSOperations.FSHomeDir command \u003d new FSOperations.FSHomeDir();\n      JSONObject json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"\");\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case INSTRUMENTATION: {\n      enforceRootPath(op.value(), path);\n      Groups groups \u003d HttpFSServerWebApp.get().get(Groups.class);\n      List\u003cString\u003e userGroups \u003d groups.getGroups(user.getShortUserName());\n      if (!userGroups.contains(HttpFSServerWebApp.get().getAdminGroup())) {\n        throw new AccessControlException(\n            \"User not in HttpFSServer admin group\");\n      }\n      Instrumentation instrumentation \u003d\n          HttpFSServerWebApp.get().get(Instrumentation.class);\n      Map snapshot \u003d instrumentation.getSnapshot();\n      response \u003d Response.ok(snapshot).build();\n      break;\n    }\n    case GETCONTENTSUMMARY: {\n      FSOperations.FSContentSummary command \u003d\n          new FSOperations.FSContentSummary(path);\n      Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETFILECHECKSUM: {\n      FSOperations.FSFileChecksum command \u003d\n          new FSOperations.FSFileChecksum(path);\n      Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETFILEBLOCKLOCATIONS: {\n      response \u003d Response.status(Response.Status.BAD_REQUEST).build();\n      break;\n    }\n    case GETACLSTATUS: {\n      FSOperations.FSAclStatus command \u003d new FSOperations.FSAclStatus(path);\n      Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"ACL status for [{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETXATTRS: {\n      List\u003cString\u003e xattrNames \u003d\n          params.getValues(XAttrNameParam.NAME, XAttrNameParam.class);\n      XAttrCodec encoding \u003d\n          params.get(XAttrEncodingParam.NAME, XAttrEncodingParam.class);\n      FSOperations.FSGetXAttrs command \u003d\n          new FSOperations.FSGetXAttrs(path, xattrNames, encoding);\n      @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"XAttrs for [{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case LISTXATTRS: {\n      FSOperations.FSListXAttrs command \u003d new FSOperations.FSListXAttrs(path);\n      @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"XAttr names for [{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case LISTSTATUS_BATCH: {\n      String startAfter \u003d params.get(\n          HttpFSParametersProvider.StartAfterParam.NAME,\n          HttpFSParametersProvider.StartAfterParam.class);\n      byte[] token \u003d HttpFSUtils.EMPTY_BYTES;\n      if (startAfter !\u003d null) {\n        token \u003d startAfter.getBytes(Charsets.UTF_8);\n      }\n      FSOperations.FSListStatusBatch command \u003d new FSOperations\n          .FSListStatusBatch(path, token);\n      @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}] token [{}]\", path, token);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETTRASHROOT: {\n      FSOperations.FSTrashRoot command \u003d new FSOperations.FSTrashRoot(path);\n      JSONObject json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETALLSTORAGEPOLICY: {\n      FSOperations.FSGetAllStoragePolicies command \u003d\n          new FSOperations.FSGetAllStoragePolicies();\n      JSONObject json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETSTORAGEPOLICY: {\n      FSOperations.FSGetStoragePolicy command \u003d\n          new FSOperations.FSGetStoragePolicy(path);\n      JSONObject json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETSNAPSHOTDIFF: {\n      String oldSnapshotName \u003d params.get(OldSnapshotNameParam.NAME,\n          OldSnapshotNameParam.class);\n      String snapshotName \u003d params.get(SnapshotNameParam.NAME,\n          SnapshotNameParam.class);\n      FSOperations.FSGetSnapshotDiff command \u003d\n          new FSOperations.FSGetSnapshotDiff(path, oldSnapshotName,\n              snapshotName);\n      String js \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(js).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    default: {\n      throw new IOException(\n          MessageFormat.format(\"Invalid HTTP GET operation [{0}]\", op.value()));\n    }\n    }\n    return response;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-httpfs/src/main/java/org/apache/hadoop/fs/http/server/HttpFSServer.java",
      "extendedDetails": {}
    },
    "2f867115a819327a50cf9c8caa56e0e5a85cabb9": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HDFS-6874. Add GETFILEBLOCKLOCATIONS operation to HttpFS.  Contributed by Weiwei Yang\"\n\nThis reverts commit 931a49800ef05ee0a6fdc143be1799abb228735d.\n\n Conflicts:\n\thadoop-hdfs-project/hadoop-hdfs-httpfs/src/main/java/org/apache/hadoop/fs/http/client/HttpFSFileSystem.java\n\thadoop-hdfs-project/hadoop-hdfs-httpfs/src/main/java/org/apache/hadoop/fs/http/server/FSOperations.java\n\thadoop-hdfs-project/hadoop-hdfs-httpfs/src/test/java/org/apache/hadoop/fs/http/client/BaseTestHttpFSWith.java\n",
      "commitDate": "14/09/17 3:02 PM",
      "commitName": "2f867115a819327a50cf9c8caa56e0e5a85cabb9",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "08/08/17 11:58 PM",
      "commitNameOld": "8a4bff02c1534c6bf529726f2bbe414ac4c172e8",
      "commitAuthorOld": "Wei-Chiu Chuang",
      "daysBetweenCommits": 36.63,
      "commitsBetweenForRepo": 345,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,187 +1,169 @@\n   public Response get(@PathParam(\"path\") String path,\n                       @QueryParam(OperationParam.NAME) OperationParam op,\n                       @Context Parameters params,\n                       @Context HttpServletRequest request)\n     throws IOException, FileSystemAccessException {\n     UserGroupInformation user \u003d HttpUserGroupInformation.get();\n     Response response;\n     path \u003d makeAbsolute(path);\n     MDC.put(HttpFSFileSystem.OP_PARAM, op.value().name());\n     MDC.put(\"hostname\", request.getRemoteAddr());\n     switch (op.value()) {\n     case OPEN: {\n       //Invoking the command directly using an unmanaged FileSystem that is\n       // released by the FileSystemReleaseFilter\n       final FSOperations.FSOpen command \u003d new FSOperations.FSOpen(path);\n       final FileSystem fs \u003d createFileSystem(user);\n       InputStream is \u003d null;\n       UserGroupInformation ugi \u003d UserGroupInformation\n           .createProxyUser(user.getShortUserName(),\n               UserGroupInformation.getLoginUser());\n       try {\n         is \u003d ugi.doAs(new PrivilegedExceptionAction\u003cInputStream\u003e() {\n           @Override\n           public InputStream run() throws Exception {\n             return command.execute(fs);\n           }\n         });\n       } catch (InterruptedException ie) {\n         LOG.info(\"Open interrupted.\", ie);\n         Thread.currentThread().interrupt();\n       }\n       Long offset \u003d params.get(OffsetParam.NAME, OffsetParam.class);\n       Long len \u003d params.get(LenParam.NAME, LenParam.class);\n       AUDIT_LOG.info(\"[{}] offset [{}] len [{}]\",\n           new Object[] { path, offset, len });\n       InputStreamEntity entity \u003d new InputStreamEntity(is, offset, len);\n       response \u003d\n           Response.ok(entity).type(MediaType.APPLICATION_OCTET_STREAM).build();\n       break;\n     }\n     case GETFILESTATUS: {\n       FSOperations.FSFileStatus command \u003d new FSOperations.FSFileStatus(path);\n       Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case LISTSTATUS: {\n       String filter \u003d params.get(FilterParam.NAME, FilterParam.class);\n       FSOperations.FSListStatus command \u003d\n           new FSOperations.FSListStatus(path, filter);\n       Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}] filter [{}]\", path, (filter !\u003d null) ? filter : \"-\");\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETHOMEDIRECTORY: {\n       enforceRootPath(op.value(), path);\n       FSOperations.FSHomeDir command \u003d new FSOperations.FSHomeDir();\n       JSONObject json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"\");\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case INSTRUMENTATION: {\n       enforceRootPath(op.value(), path);\n       Groups groups \u003d HttpFSServerWebApp.get().get(Groups.class);\n       List\u003cString\u003e userGroups \u003d groups.getGroups(user.getShortUserName());\n       if (!userGroups.contains(HttpFSServerWebApp.get().getAdminGroup())) {\n         throw new AccessControlException(\n             \"User not in HttpFSServer admin group\");\n       }\n       Instrumentation instrumentation \u003d\n           HttpFSServerWebApp.get().get(Instrumentation.class);\n       Map snapshot \u003d instrumentation.getSnapshot();\n       response \u003d Response.ok(snapshot).build();\n       break;\n     }\n     case GETCONTENTSUMMARY: {\n       FSOperations.FSContentSummary command \u003d\n           new FSOperations.FSContentSummary(path);\n       Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETFILECHECKSUM: {\n       FSOperations.FSFileChecksum command \u003d\n           new FSOperations.FSFileChecksum(path);\n       Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETFILEBLOCKLOCATIONS: {\n-      long offset \u003d 0;\n-      // In case length is not given, reset to max long\n-      // in order to retrieve all file block locations\n-      long len \u003d Long.MAX_VALUE;\n-      Long offsetParam \u003d params.get(OffsetParam.NAME, OffsetParam.class);\n-      Long lenParam \u003d params.get(LenParam.NAME, LenParam.class);\n-      AUDIT_LOG.info(\"[{}] offset [{}] len [{}]\",\n-          new Object[] {path, offsetParam, lenParam});\n-      if (offsetParam !\u003d null \u0026\u0026 offsetParam.longValue() \u003e 0) {\n-        offset \u003d offsetParam.longValue();\n-      }\n-      if (lenParam !\u003d null \u0026\u0026 lenParam.longValue() \u003e 0) {\n-        len \u003d lenParam.longValue();\n-      }\n-      FSOperations.FSFileBlockLocations command \u003d\n-          new FSOperations.FSFileBlockLocations(path, offset, len);\n-      @SuppressWarnings(\"rawtypes\") Map locations \u003d fsExecute(user, command);\n-      final String json \u003d JsonUtil.toJsonString(\"BlockLocations\", locations);\n-      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n+      response \u003d Response.status(Response.Status.BAD_REQUEST).build();\n       break;\n     }\n     case GETACLSTATUS: {\n       FSOperations.FSAclStatus command \u003d new FSOperations.FSAclStatus(path);\n       Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"ACL status for [{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETXATTRS: {\n       List\u003cString\u003e xattrNames \u003d\n           params.getValues(XAttrNameParam.NAME, XAttrNameParam.class);\n       XAttrCodec encoding \u003d\n           params.get(XAttrEncodingParam.NAME, XAttrEncodingParam.class);\n       FSOperations.FSGetXAttrs command \u003d\n           new FSOperations.FSGetXAttrs(path, xattrNames, encoding);\n       @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"XAttrs for [{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case LISTXATTRS: {\n       FSOperations.FSListXAttrs command \u003d new FSOperations.FSListXAttrs(path);\n       @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"XAttr names for [{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case LISTSTATUS_BATCH: {\n       String startAfter \u003d params.get(\n           HttpFSParametersProvider.StartAfterParam.NAME,\n           HttpFSParametersProvider.StartAfterParam.class);\n       byte[] token \u003d HttpFSUtils.EMPTY_BYTES;\n       if (startAfter !\u003d null) {\n         token \u003d startAfter.getBytes(Charsets.UTF_8);\n       }\n       FSOperations.FSListStatusBatch command \u003d new FSOperations\n           .FSListStatusBatch(path, token);\n       @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}] token [{}]\", path, token);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETTRASHROOT: {\n       FSOperations.FSTrashRoot command \u003d new FSOperations.FSTrashRoot(path);\n       JSONObject json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETALLSTORAGEPOLICY: {\n       FSOperations.FSGetAllStoragePolicies command \u003d\n           new FSOperations.FSGetAllStoragePolicies();\n       JSONObject json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETSTORAGEPOLICY: {\n       FSOperations.FSGetStoragePolicy command \u003d\n           new FSOperations.FSGetStoragePolicy(path);\n       JSONObject json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     default: {\n       throw new IOException(\n           MessageFormat.format(\"Invalid HTTP GET operation [{0}]\", op.value()));\n     }\n     }\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Response get(@PathParam(\"path\") String path,\n                      @QueryParam(OperationParam.NAME) OperationParam op,\n                      @Context Parameters params,\n                      @Context HttpServletRequest request)\n    throws IOException, FileSystemAccessException {\n    UserGroupInformation user \u003d HttpUserGroupInformation.get();\n    Response response;\n    path \u003d makeAbsolute(path);\n    MDC.put(HttpFSFileSystem.OP_PARAM, op.value().name());\n    MDC.put(\"hostname\", request.getRemoteAddr());\n    switch (op.value()) {\n    case OPEN: {\n      //Invoking the command directly using an unmanaged FileSystem that is\n      // released by the FileSystemReleaseFilter\n      final FSOperations.FSOpen command \u003d new FSOperations.FSOpen(path);\n      final FileSystem fs \u003d createFileSystem(user);\n      InputStream is \u003d null;\n      UserGroupInformation ugi \u003d UserGroupInformation\n          .createProxyUser(user.getShortUserName(),\n              UserGroupInformation.getLoginUser());\n      try {\n        is \u003d ugi.doAs(new PrivilegedExceptionAction\u003cInputStream\u003e() {\n          @Override\n          public InputStream run() throws Exception {\n            return command.execute(fs);\n          }\n        });\n      } catch (InterruptedException ie) {\n        LOG.info(\"Open interrupted.\", ie);\n        Thread.currentThread().interrupt();\n      }\n      Long offset \u003d params.get(OffsetParam.NAME, OffsetParam.class);\n      Long len \u003d params.get(LenParam.NAME, LenParam.class);\n      AUDIT_LOG.info(\"[{}] offset [{}] len [{}]\",\n          new Object[] { path, offset, len });\n      InputStreamEntity entity \u003d new InputStreamEntity(is, offset, len);\n      response \u003d\n          Response.ok(entity).type(MediaType.APPLICATION_OCTET_STREAM).build();\n      break;\n    }\n    case GETFILESTATUS: {\n      FSOperations.FSFileStatus command \u003d new FSOperations.FSFileStatus(path);\n      Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case LISTSTATUS: {\n      String filter \u003d params.get(FilterParam.NAME, FilterParam.class);\n      FSOperations.FSListStatus command \u003d\n          new FSOperations.FSListStatus(path, filter);\n      Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}] filter [{}]\", path, (filter !\u003d null) ? filter : \"-\");\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETHOMEDIRECTORY: {\n      enforceRootPath(op.value(), path);\n      FSOperations.FSHomeDir command \u003d new FSOperations.FSHomeDir();\n      JSONObject json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"\");\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case INSTRUMENTATION: {\n      enforceRootPath(op.value(), path);\n      Groups groups \u003d HttpFSServerWebApp.get().get(Groups.class);\n      List\u003cString\u003e userGroups \u003d groups.getGroups(user.getShortUserName());\n      if (!userGroups.contains(HttpFSServerWebApp.get().getAdminGroup())) {\n        throw new AccessControlException(\n            \"User not in HttpFSServer admin group\");\n      }\n      Instrumentation instrumentation \u003d\n          HttpFSServerWebApp.get().get(Instrumentation.class);\n      Map snapshot \u003d instrumentation.getSnapshot();\n      response \u003d Response.ok(snapshot).build();\n      break;\n    }\n    case GETCONTENTSUMMARY: {\n      FSOperations.FSContentSummary command \u003d\n          new FSOperations.FSContentSummary(path);\n      Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETFILECHECKSUM: {\n      FSOperations.FSFileChecksum command \u003d\n          new FSOperations.FSFileChecksum(path);\n      Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETFILEBLOCKLOCATIONS: {\n      response \u003d Response.status(Response.Status.BAD_REQUEST).build();\n      break;\n    }\n    case GETACLSTATUS: {\n      FSOperations.FSAclStatus command \u003d new FSOperations.FSAclStatus(path);\n      Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"ACL status for [{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETXATTRS: {\n      List\u003cString\u003e xattrNames \u003d\n          params.getValues(XAttrNameParam.NAME, XAttrNameParam.class);\n      XAttrCodec encoding \u003d\n          params.get(XAttrEncodingParam.NAME, XAttrEncodingParam.class);\n      FSOperations.FSGetXAttrs command \u003d\n          new FSOperations.FSGetXAttrs(path, xattrNames, encoding);\n      @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"XAttrs for [{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case LISTXATTRS: {\n      FSOperations.FSListXAttrs command \u003d new FSOperations.FSListXAttrs(path);\n      @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"XAttr names for [{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case LISTSTATUS_BATCH: {\n      String startAfter \u003d params.get(\n          HttpFSParametersProvider.StartAfterParam.NAME,\n          HttpFSParametersProvider.StartAfterParam.class);\n      byte[] token \u003d HttpFSUtils.EMPTY_BYTES;\n      if (startAfter !\u003d null) {\n        token \u003d startAfter.getBytes(Charsets.UTF_8);\n      }\n      FSOperations.FSListStatusBatch command \u003d new FSOperations\n          .FSListStatusBatch(path, token);\n      @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}] token [{}]\", path, token);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETTRASHROOT: {\n      FSOperations.FSTrashRoot command \u003d new FSOperations.FSTrashRoot(path);\n      JSONObject json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETALLSTORAGEPOLICY: {\n      FSOperations.FSGetAllStoragePolicies command \u003d\n          new FSOperations.FSGetAllStoragePolicies();\n      JSONObject json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETSTORAGEPOLICY: {\n      FSOperations.FSGetStoragePolicy command \u003d\n          new FSOperations.FSGetStoragePolicy(path);\n      JSONObject json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    default: {\n      throw new IOException(\n          MessageFormat.format(\"Invalid HTTP GET operation [{0}]\", op.value()));\n    }\n    }\n    return response;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-httpfs/src/main/java/org/apache/hadoop/fs/http/server/HttpFSServer.java",
      "extendedDetails": {}
    },
    "931a49800ef05ee0a6fdc143be1799abb228735d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6874. Add GETFILEBLOCKLOCATIONS operation to HttpFS.  Contributed by Weiwei Yang\n",
      "commitDate": "12/07/17 2:15 PM",
      "commitName": "931a49800ef05ee0a6fdc143be1799abb228735d",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "commitDateOld": "07/12/16 3:52 PM",
      "commitNameOld": "ea2895f4ed5031809d856faa52e9de5b9501bdea",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 216.89,
      "commitsBetweenForRepo": 1115,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,169 +1,187 @@\n   public Response get(@PathParam(\"path\") String path,\n                       @QueryParam(OperationParam.NAME) OperationParam op,\n                       @Context Parameters params,\n                       @Context HttpServletRequest request)\n     throws IOException, FileSystemAccessException {\n     UserGroupInformation user \u003d HttpUserGroupInformation.get();\n     Response response;\n     path \u003d makeAbsolute(path);\n     MDC.put(HttpFSFileSystem.OP_PARAM, op.value().name());\n     MDC.put(\"hostname\", request.getRemoteAddr());\n     switch (op.value()) {\n     case OPEN: {\n       //Invoking the command directly using an unmanaged FileSystem that is\n       // released by the FileSystemReleaseFilter\n       final FSOperations.FSOpen command \u003d new FSOperations.FSOpen(path);\n       final FileSystem fs \u003d createFileSystem(user);\n       InputStream is \u003d null;\n       UserGroupInformation ugi \u003d UserGroupInformation\n           .createProxyUser(user.getShortUserName(),\n               UserGroupInformation.getLoginUser());\n       try {\n         is \u003d ugi.doAs(new PrivilegedExceptionAction\u003cInputStream\u003e() {\n           @Override\n           public InputStream run() throws Exception {\n             return command.execute(fs);\n           }\n         });\n       } catch (InterruptedException ie) {\n         LOG.info(\"Open interrupted.\", ie);\n         Thread.currentThread().interrupt();\n       }\n       Long offset \u003d params.get(OffsetParam.NAME, OffsetParam.class);\n       Long len \u003d params.get(LenParam.NAME, LenParam.class);\n       AUDIT_LOG.info(\"[{}] offset [{}] len [{}]\",\n           new Object[] { path, offset, len });\n       InputStreamEntity entity \u003d new InputStreamEntity(is, offset, len);\n       response \u003d\n           Response.ok(entity).type(MediaType.APPLICATION_OCTET_STREAM).build();\n       break;\n     }\n     case GETFILESTATUS: {\n       FSOperations.FSFileStatus command \u003d new FSOperations.FSFileStatus(path);\n       Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case LISTSTATUS: {\n       String filter \u003d params.get(FilterParam.NAME, FilterParam.class);\n       FSOperations.FSListStatus command \u003d\n           new FSOperations.FSListStatus(path, filter);\n       Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}] filter [{}]\", path, (filter !\u003d null) ? filter : \"-\");\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETHOMEDIRECTORY: {\n       enforceRootPath(op.value(), path);\n       FSOperations.FSHomeDir command \u003d new FSOperations.FSHomeDir();\n       JSONObject json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"\");\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case INSTRUMENTATION: {\n       enforceRootPath(op.value(), path);\n       Groups groups \u003d HttpFSServerWebApp.get().get(Groups.class);\n       List\u003cString\u003e userGroups \u003d groups.getGroups(user.getShortUserName());\n       if (!userGroups.contains(HttpFSServerWebApp.get().getAdminGroup())) {\n         throw new AccessControlException(\n             \"User not in HttpFSServer admin group\");\n       }\n       Instrumentation instrumentation \u003d\n           HttpFSServerWebApp.get().get(Instrumentation.class);\n       Map snapshot \u003d instrumentation.getSnapshot();\n       response \u003d Response.ok(snapshot).build();\n       break;\n     }\n     case GETCONTENTSUMMARY: {\n       FSOperations.FSContentSummary command \u003d\n           new FSOperations.FSContentSummary(path);\n       Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETFILECHECKSUM: {\n       FSOperations.FSFileChecksum command \u003d\n           new FSOperations.FSFileChecksum(path);\n       Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETFILEBLOCKLOCATIONS: {\n-      response \u003d Response.status(Response.Status.BAD_REQUEST).build();\n+      long offset \u003d 0;\n+      // In case length is not given, reset to max long\n+      // in order to retrieve all file block locations\n+      long len \u003d Long.MAX_VALUE;\n+      Long offsetParam \u003d params.get(OffsetParam.NAME, OffsetParam.class);\n+      Long lenParam \u003d params.get(LenParam.NAME, LenParam.class);\n+      AUDIT_LOG.info(\"[{}] offset [{}] len [{}]\",\n+          new Object[] {path, offsetParam, lenParam});\n+      if (offsetParam !\u003d null \u0026\u0026 offsetParam.longValue() \u003e 0) {\n+        offset \u003d offsetParam.longValue();\n+      }\n+      if (lenParam !\u003d null \u0026\u0026 lenParam.longValue() \u003e 0) {\n+        len \u003d lenParam.longValue();\n+      }\n+      FSOperations.FSFileBlockLocations command \u003d\n+          new FSOperations.FSFileBlockLocations(path, offset, len);\n+      @SuppressWarnings(\"rawtypes\") Map locations \u003d fsExecute(user, command);\n+      final String json \u003d JsonUtil.toJsonString(\"BlockLocations\", locations);\n+      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETACLSTATUS: {\n       FSOperations.FSAclStatus command \u003d new FSOperations.FSAclStatus(path);\n       Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"ACL status for [{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETXATTRS: {\n       List\u003cString\u003e xattrNames \u003d\n           params.getValues(XAttrNameParam.NAME, XAttrNameParam.class);\n       XAttrCodec encoding \u003d\n           params.get(XAttrEncodingParam.NAME, XAttrEncodingParam.class);\n       FSOperations.FSGetXAttrs command \u003d\n           new FSOperations.FSGetXAttrs(path, xattrNames, encoding);\n       @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"XAttrs for [{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case LISTXATTRS: {\n       FSOperations.FSListXAttrs command \u003d new FSOperations.FSListXAttrs(path);\n       @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"XAttr names for [{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case LISTSTATUS_BATCH: {\n       String startAfter \u003d params.get(\n           HttpFSParametersProvider.StartAfterParam.NAME,\n           HttpFSParametersProvider.StartAfterParam.class);\n       byte[] token \u003d HttpFSUtils.EMPTY_BYTES;\n       if (startAfter !\u003d null) {\n         token \u003d startAfter.getBytes(Charsets.UTF_8);\n       }\n       FSOperations.FSListStatusBatch command \u003d new FSOperations\n           .FSListStatusBatch(path, token);\n       @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}] token [{}]\", path, token);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETTRASHROOT: {\n       FSOperations.FSTrashRoot command \u003d new FSOperations.FSTrashRoot(path);\n       JSONObject json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETALLSTORAGEPOLICY: {\n       FSOperations.FSGetAllStoragePolicies command \u003d\n           new FSOperations.FSGetAllStoragePolicies();\n       JSONObject json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETSTORAGEPOLICY: {\n       FSOperations.FSGetStoragePolicy command \u003d\n           new FSOperations.FSGetStoragePolicy(path);\n       JSONObject json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     default: {\n       throw new IOException(\n           MessageFormat.format(\"Invalid HTTP GET operation [{0}]\", op.value()));\n     }\n     }\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Response get(@PathParam(\"path\") String path,\n                      @QueryParam(OperationParam.NAME) OperationParam op,\n                      @Context Parameters params,\n                      @Context HttpServletRequest request)\n    throws IOException, FileSystemAccessException {\n    UserGroupInformation user \u003d HttpUserGroupInformation.get();\n    Response response;\n    path \u003d makeAbsolute(path);\n    MDC.put(HttpFSFileSystem.OP_PARAM, op.value().name());\n    MDC.put(\"hostname\", request.getRemoteAddr());\n    switch (op.value()) {\n    case OPEN: {\n      //Invoking the command directly using an unmanaged FileSystem that is\n      // released by the FileSystemReleaseFilter\n      final FSOperations.FSOpen command \u003d new FSOperations.FSOpen(path);\n      final FileSystem fs \u003d createFileSystem(user);\n      InputStream is \u003d null;\n      UserGroupInformation ugi \u003d UserGroupInformation\n          .createProxyUser(user.getShortUserName(),\n              UserGroupInformation.getLoginUser());\n      try {\n        is \u003d ugi.doAs(new PrivilegedExceptionAction\u003cInputStream\u003e() {\n          @Override\n          public InputStream run() throws Exception {\n            return command.execute(fs);\n          }\n        });\n      } catch (InterruptedException ie) {\n        LOG.info(\"Open interrupted.\", ie);\n        Thread.currentThread().interrupt();\n      }\n      Long offset \u003d params.get(OffsetParam.NAME, OffsetParam.class);\n      Long len \u003d params.get(LenParam.NAME, LenParam.class);\n      AUDIT_LOG.info(\"[{}] offset [{}] len [{}]\",\n          new Object[] { path, offset, len });\n      InputStreamEntity entity \u003d new InputStreamEntity(is, offset, len);\n      response \u003d\n          Response.ok(entity).type(MediaType.APPLICATION_OCTET_STREAM).build();\n      break;\n    }\n    case GETFILESTATUS: {\n      FSOperations.FSFileStatus command \u003d new FSOperations.FSFileStatus(path);\n      Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case LISTSTATUS: {\n      String filter \u003d params.get(FilterParam.NAME, FilterParam.class);\n      FSOperations.FSListStatus command \u003d\n          new FSOperations.FSListStatus(path, filter);\n      Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}] filter [{}]\", path, (filter !\u003d null) ? filter : \"-\");\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETHOMEDIRECTORY: {\n      enforceRootPath(op.value(), path);\n      FSOperations.FSHomeDir command \u003d new FSOperations.FSHomeDir();\n      JSONObject json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"\");\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case INSTRUMENTATION: {\n      enforceRootPath(op.value(), path);\n      Groups groups \u003d HttpFSServerWebApp.get().get(Groups.class);\n      List\u003cString\u003e userGroups \u003d groups.getGroups(user.getShortUserName());\n      if (!userGroups.contains(HttpFSServerWebApp.get().getAdminGroup())) {\n        throw new AccessControlException(\n            \"User not in HttpFSServer admin group\");\n      }\n      Instrumentation instrumentation \u003d\n          HttpFSServerWebApp.get().get(Instrumentation.class);\n      Map snapshot \u003d instrumentation.getSnapshot();\n      response \u003d Response.ok(snapshot).build();\n      break;\n    }\n    case GETCONTENTSUMMARY: {\n      FSOperations.FSContentSummary command \u003d\n          new FSOperations.FSContentSummary(path);\n      Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETFILECHECKSUM: {\n      FSOperations.FSFileChecksum command \u003d\n          new FSOperations.FSFileChecksum(path);\n      Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETFILEBLOCKLOCATIONS: {\n      long offset \u003d 0;\n      // In case length is not given, reset to max long\n      // in order to retrieve all file block locations\n      long len \u003d Long.MAX_VALUE;\n      Long offsetParam \u003d params.get(OffsetParam.NAME, OffsetParam.class);\n      Long lenParam \u003d params.get(LenParam.NAME, LenParam.class);\n      AUDIT_LOG.info(\"[{}] offset [{}] len [{}]\",\n          new Object[] {path, offsetParam, lenParam});\n      if (offsetParam !\u003d null \u0026\u0026 offsetParam.longValue() \u003e 0) {\n        offset \u003d offsetParam.longValue();\n      }\n      if (lenParam !\u003d null \u0026\u0026 lenParam.longValue() \u003e 0) {\n        len \u003d lenParam.longValue();\n      }\n      FSOperations.FSFileBlockLocations command \u003d\n          new FSOperations.FSFileBlockLocations(path, offset, len);\n      @SuppressWarnings(\"rawtypes\") Map locations \u003d fsExecute(user, command);\n      final String json \u003d JsonUtil.toJsonString(\"BlockLocations\", locations);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETACLSTATUS: {\n      FSOperations.FSAclStatus command \u003d new FSOperations.FSAclStatus(path);\n      Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"ACL status for [{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETXATTRS: {\n      List\u003cString\u003e xattrNames \u003d\n          params.getValues(XAttrNameParam.NAME, XAttrNameParam.class);\n      XAttrCodec encoding \u003d\n          params.get(XAttrEncodingParam.NAME, XAttrEncodingParam.class);\n      FSOperations.FSGetXAttrs command \u003d\n          new FSOperations.FSGetXAttrs(path, xattrNames, encoding);\n      @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"XAttrs for [{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case LISTXATTRS: {\n      FSOperations.FSListXAttrs command \u003d new FSOperations.FSListXAttrs(path);\n      @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"XAttr names for [{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case LISTSTATUS_BATCH: {\n      String startAfter \u003d params.get(\n          HttpFSParametersProvider.StartAfterParam.NAME,\n          HttpFSParametersProvider.StartAfterParam.class);\n      byte[] token \u003d HttpFSUtils.EMPTY_BYTES;\n      if (startAfter !\u003d null) {\n        token \u003d startAfter.getBytes(Charsets.UTF_8);\n      }\n      FSOperations.FSListStatusBatch command \u003d new FSOperations\n          .FSListStatusBatch(path, token);\n      @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}] token [{}]\", path, token);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETTRASHROOT: {\n      FSOperations.FSTrashRoot command \u003d new FSOperations.FSTrashRoot(path);\n      JSONObject json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETALLSTORAGEPOLICY: {\n      FSOperations.FSGetAllStoragePolicies command \u003d\n          new FSOperations.FSGetAllStoragePolicies();\n      JSONObject json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETSTORAGEPOLICY: {\n      FSOperations.FSGetStoragePolicy command \u003d\n          new FSOperations.FSGetStoragePolicy(path);\n      JSONObject json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    default: {\n      throw new IOException(\n          MessageFormat.format(\"Invalid HTTP GET operation [{0}]\", op.value()));\n    }\n    }\n    return response;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-httpfs/src/main/java/org/apache/hadoop/fs/http/server/HttpFSServer.java",
      "extendedDetails": {}
    },
    "ea2895f4ed5031809d856faa52e9de5b9501bdea": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8630. WebHDFS : Support get/set/unset StoragePolicy. Contributed by Surendra Singh Lilhore.\n",
      "commitDate": "07/12/16 3:52 PM",
      "commitName": "ea2895f4ed5031809d856faa52e9de5b9501bdea",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "04/11/16 6:06 PM",
      "commitNameOld": "d8bab3dcb693b2773ede9a6e4f71ae85ee056f79",
      "commitAuthorOld": "Xiao Chen",
      "daysBetweenCommits": 32.95,
      "commitsBetweenForRepo": 236,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,153 +1,169 @@\n   public Response get(@PathParam(\"path\") String path,\n                       @QueryParam(OperationParam.NAME) OperationParam op,\n                       @Context Parameters params,\n                       @Context HttpServletRequest request)\n     throws IOException, FileSystemAccessException {\n     UserGroupInformation user \u003d HttpUserGroupInformation.get();\n     Response response;\n     path \u003d makeAbsolute(path);\n     MDC.put(HttpFSFileSystem.OP_PARAM, op.value().name());\n     MDC.put(\"hostname\", request.getRemoteAddr());\n     switch (op.value()) {\n     case OPEN: {\n       //Invoking the command directly using an unmanaged FileSystem that is\n       // released by the FileSystemReleaseFilter\n       final FSOperations.FSOpen command \u003d new FSOperations.FSOpen(path);\n       final FileSystem fs \u003d createFileSystem(user);\n       InputStream is \u003d null;\n       UserGroupInformation ugi \u003d UserGroupInformation\n           .createProxyUser(user.getShortUserName(),\n               UserGroupInformation.getLoginUser());\n       try {\n         is \u003d ugi.doAs(new PrivilegedExceptionAction\u003cInputStream\u003e() {\n           @Override\n           public InputStream run() throws Exception {\n             return command.execute(fs);\n           }\n         });\n       } catch (InterruptedException ie) {\n         LOG.info(\"Open interrupted.\", ie);\n         Thread.currentThread().interrupt();\n       }\n       Long offset \u003d params.get(OffsetParam.NAME, OffsetParam.class);\n       Long len \u003d params.get(LenParam.NAME, LenParam.class);\n       AUDIT_LOG.info(\"[{}] offset [{}] len [{}]\",\n           new Object[] { path, offset, len });\n       InputStreamEntity entity \u003d new InputStreamEntity(is, offset, len);\n       response \u003d\n           Response.ok(entity).type(MediaType.APPLICATION_OCTET_STREAM).build();\n       break;\n     }\n     case GETFILESTATUS: {\n       FSOperations.FSFileStatus command \u003d new FSOperations.FSFileStatus(path);\n       Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case LISTSTATUS: {\n       String filter \u003d params.get(FilterParam.NAME, FilterParam.class);\n       FSOperations.FSListStatus command \u003d\n           new FSOperations.FSListStatus(path, filter);\n       Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}] filter [{}]\", path, (filter !\u003d null) ? filter : \"-\");\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETHOMEDIRECTORY: {\n       enforceRootPath(op.value(), path);\n       FSOperations.FSHomeDir command \u003d new FSOperations.FSHomeDir();\n       JSONObject json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"\");\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case INSTRUMENTATION: {\n       enforceRootPath(op.value(), path);\n       Groups groups \u003d HttpFSServerWebApp.get().get(Groups.class);\n       List\u003cString\u003e userGroups \u003d groups.getGroups(user.getShortUserName());\n       if (!userGroups.contains(HttpFSServerWebApp.get().getAdminGroup())) {\n         throw new AccessControlException(\n             \"User not in HttpFSServer admin group\");\n       }\n       Instrumentation instrumentation \u003d\n           HttpFSServerWebApp.get().get(Instrumentation.class);\n       Map snapshot \u003d instrumentation.getSnapshot();\n       response \u003d Response.ok(snapshot).build();\n       break;\n     }\n     case GETCONTENTSUMMARY: {\n       FSOperations.FSContentSummary command \u003d\n           new FSOperations.FSContentSummary(path);\n       Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETFILECHECKSUM: {\n       FSOperations.FSFileChecksum command \u003d\n           new FSOperations.FSFileChecksum(path);\n       Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETFILEBLOCKLOCATIONS: {\n       response \u003d Response.status(Response.Status.BAD_REQUEST).build();\n       break;\n     }\n     case GETACLSTATUS: {\n       FSOperations.FSAclStatus command \u003d new FSOperations.FSAclStatus(path);\n       Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"ACL status for [{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETXATTRS: {\n       List\u003cString\u003e xattrNames \u003d\n           params.getValues(XAttrNameParam.NAME, XAttrNameParam.class);\n       XAttrCodec encoding \u003d\n           params.get(XAttrEncodingParam.NAME, XAttrEncodingParam.class);\n       FSOperations.FSGetXAttrs command \u003d\n           new FSOperations.FSGetXAttrs(path, xattrNames, encoding);\n       @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"XAttrs for [{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case LISTXATTRS: {\n       FSOperations.FSListXAttrs command \u003d new FSOperations.FSListXAttrs(path);\n       @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"XAttr names for [{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case LISTSTATUS_BATCH: {\n       String startAfter \u003d params.get(\n           HttpFSParametersProvider.StartAfterParam.NAME,\n           HttpFSParametersProvider.StartAfterParam.class);\n       byte[] token \u003d HttpFSUtils.EMPTY_BYTES;\n       if (startAfter !\u003d null) {\n         token \u003d startAfter.getBytes(Charsets.UTF_8);\n       }\n       FSOperations.FSListStatusBatch command \u003d new FSOperations\n           .FSListStatusBatch(path, token);\n       @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}] token [{}]\", path, token);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETTRASHROOT: {\n       FSOperations.FSTrashRoot command \u003d new FSOperations.FSTrashRoot(path);\n       JSONObject json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n+    case GETALLSTORAGEPOLICY: {\n+      FSOperations.FSGetAllStoragePolicies command \u003d\n+          new FSOperations.FSGetAllStoragePolicies();\n+      JSONObject json \u003d fsExecute(user, command);\n+      AUDIT_LOG.info(\"[{}]\", path);\n+      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n+      break;\n+    }\n+    case GETSTORAGEPOLICY: {\n+      FSOperations.FSGetStoragePolicy command \u003d\n+          new FSOperations.FSGetStoragePolicy(path);\n+      JSONObject json \u003d fsExecute(user, command);\n+      AUDIT_LOG.info(\"[{}]\", path);\n+      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n+      break;\n+    }\n     default: {\n       throw new IOException(\n           MessageFormat.format(\"Invalid HTTP GET operation [{0}]\", op.value()));\n     }\n     }\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Response get(@PathParam(\"path\") String path,\n                      @QueryParam(OperationParam.NAME) OperationParam op,\n                      @Context Parameters params,\n                      @Context HttpServletRequest request)\n    throws IOException, FileSystemAccessException {\n    UserGroupInformation user \u003d HttpUserGroupInformation.get();\n    Response response;\n    path \u003d makeAbsolute(path);\n    MDC.put(HttpFSFileSystem.OP_PARAM, op.value().name());\n    MDC.put(\"hostname\", request.getRemoteAddr());\n    switch (op.value()) {\n    case OPEN: {\n      //Invoking the command directly using an unmanaged FileSystem that is\n      // released by the FileSystemReleaseFilter\n      final FSOperations.FSOpen command \u003d new FSOperations.FSOpen(path);\n      final FileSystem fs \u003d createFileSystem(user);\n      InputStream is \u003d null;\n      UserGroupInformation ugi \u003d UserGroupInformation\n          .createProxyUser(user.getShortUserName(),\n              UserGroupInformation.getLoginUser());\n      try {\n        is \u003d ugi.doAs(new PrivilegedExceptionAction\u003cInputStream\u003e() {\n          @Override\n          public InputStream run() throws Exception {\n            return command.execute(fs);\n          }\n        });\n      } catch (InterruptedException ie) {\n        LOG.info(\"Open interrupted.\", ie);\n        Thread.currentThread().interrupt();\n      }\n      Long offset \u003d params.get(OffsetParam.NAME, OffsetParam.class);\n      Long len \u003d params.get(LenParam.NAME, LenParam.class);\n      AUDIT_LOG.info(\"[{}] offset [{}] len [{}]\",\n          new Object[] { path, offset, len });\n      InputStreamEntity entity \u003d new InputStreamEntity(is, offset, len);\n      response \u003d\n          Response.ok(entity).type(MediaType.APPLICATION_OCTET_STREAM).build();\n      break;\n    }\n    case GETFILESTATUS: {\n      FSOperations.FSFileStatus command \u003d new FSOperations.FSFileStatus(path);\n      Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case LISTSTATUS: {\n      String filter \u003d params.get(FilterParam.NAME, FilterParam.class);\n      FSOperations.FSListStatus command \u003d\n          new FSOperations.FSListStatus(path, filter);\n      Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}] filter [{}]\", path, (filter !\u003d null) ? filter : \"-\");\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETHOMEDIRECTORY: {\n      enforceRootPath(op.value(), path);\n      FSOperations.FSHomeDir command \u003d new FSOperations.FSHomeDir();\n      JSONObject json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"\");\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case INSTRUMENTATION: {\n      enforceRootPath(op.value(), path);\n      Groups groups \u003d HttpFSServerWebApp.get().get(Groups.class);\n      List\u003cString\u003e userGroups \u003d groups.getGroups(user.getShortUserName());\n      if (!userGroups.contains(HttpFSServerWebApp.get().getAdminGroup())) {\n        throw new AccessControlException(\n            \"User not in HttpFSServer admin group\");\n      }\n      Instrumentation instrumentation \u003d\n          HttpFSServerWebApp.get().get(Instrumentation.class);\n      Map snapshot \u003d instrumentation.getSnapshot();\n      response \u003d Response.ok(snapshot).build();\n      break;\n    }\n    case GETCONTENTSUMMARY: {\n      FSOperations.FSContentSummary command \u003d\n          new FSOperations.FSContentSummary(path);\n      Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETFILECHECKSUM: {\n      FSOperations.FSFileChecksum command \u003d\n          new FSOperations.FSFileChecksum(path);\n      Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETFILEBLOCKLOCATIONS: {\n      response \u003d Response.status(Response.Status.BAD_REQUEST).build();\n      break;\n    }\n    case GETACLSTATUS: {\n      FSOperations.FSAclStatus command \u003d new FSOperations.FSAclStatus(path);\n      Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"ACL status for [{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETXATTRS: {\n      List\u003cString\u003e xattrNames \u003d\n          params.getValues(XAttrNameParam.NAME, XAttrNameParam.class);\n      XAttrCodec encoding \u003d\n          params.get(XAttrEncodingParam.NAME, XAttrEncodingParam.class);\n      FSOperations.FSGetXAttrs command \u003d\n          new FSOperations.FSGetXAttrs(path, xattrNames, encoding);\n      @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"XAttrs for [{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case LISTXATTRS: {\n      FSOperations.FSListXAttrs command \u003d new FSOperations.FSListXAttrs(path);\n      @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"XAttr names for [{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case LISTSTATUS_BATCH: {\n      String startAfter \u003d params.get(\n          HttpFSParametersProvider.StartAfterParam.NAME,\n          HttpFSParametersProvider.StartAfterParam.class);\n      byte[] token \u003d HttpFSUtils.EMPTY_BYTES;\n      if (startAfter !\u003d null) {\n        token \u003d startAfter.getBytes(Charsets.UTF_8);\n      }\n      FSOperations.FSListStatusBatch command \u003d new FSOperations\n          .FSListStatusBatch(path, token);\n      @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}] token [{}]\", path, token);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETTRASHROOT: {\n      FSOperations.FSTrashRoot command \u003d new FSOperations.FSTrashRoot(path);\n      JSONObject json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETALLSTORAGEPOLICY: {\n      FSOperations.FSGetAllStoragePolicies command \u003d\n          new FSOperations.FSGetAllStoragePolicies();\n      JSONObject json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETSTORAGEPOLICY: {\n      FSOperations.FSGetStoragePolicy command \u003d\n          new FSOperations.FSGetStoragePolicy(path);\n      JSONObject json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    default: {\n      throw new IOException(\n          MessageFormat.format(\"Invalid HTTP GET operation [{0}]\", op.value()));\n    }\n    }\n    return response;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-httpfs/src/main/java/org/apache/hadoop/fs/http/server/HttpFSServer.java",
      "extendedDetails": {}
    },
    "d8bab3dcb693b2773ede9a6e4f71ae85ee056f79": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10756. Expose getTrashRoot to HTTPFS and WebHDFS. Contributed by Yuanbo Liu.\n",
      "commitDate": "04/11/16 6:06 PM",
      "commitName": "d8bab3dcb693b2773ede9a6e4f71ae85ee056f79",
      "commitAuthor": "Xiao Chen",
      "commitDateOld": "27/10/16 4:09 PM",
      "commitNameOld": "5877f20f9c3f6f0afa505715e9a2ee312475af17",
      "commitAuthorOld": "Robert Kanter",
      "daysBetweenCommits": 8.08,
      "commitsBetweenForRepo": 71,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,146 +1,153 @@\n   public Response get(@PathParam(\"path\") String path,\n                       @QueryParam(OperationParam.NAME) OperationParam op,\n                       @Context Parameters params,\n                       @Context HttpServletRequest request)\n     throws IOException, FileSystemAccessException {\n     UserGroupInformation user \u003d HttpUserGroupInformation.get();\n     Response response;\n     path \u003d makeAbsolute(path);\n     MDC.put(HttpFSFileSystem.OP_PARAM, op.value().name());\n     MDC.put(\"hostname\", request.getRemoteAddr());\n     switch (op.value()) {\n     case OPEN: {\n       //Invoking the command directly using an unmanaged FileSystem that is\n       // released by the FileSystemReleaseFilter\n       final FSOperations.FSOpen command \u003d new FSOperations.FSOpen(path);\n       final FileSystem fs \u003d createFileSystem(user);\n       InputStream is \u003d null;\n       UserGroupInformation ugi \u003d UserGroupInformation\n           .createProxyUser(user.getShortUserName(),\n               UserGroupInformation.getLoginUser());\n       try {\n         is \u003d ugi.doAs(new PrivilegedExceptionAction\u003cInputStream\u003e() {\n           @Override\n           public InputStream run() throws Exception {\n             return command.execute(fs);\n           }\n         });\n       } catch (InterruptedException ie) {\n         LOG.info(\"Open interrupted.\", ie);\n         Thread.currentThread().interrupt();\n       }\n       Long offset \u003d params.get(OffsetParam.NAME, OffsetParam.class);\n       Long len \u003d params.get(LenParam.NAME, LenParam.class);\n       AUDIT_LOG.info(\"[{}] offset [{}] len [{}]\",\n           new Object[] { path, offset, len });\n       InputStreamEntity entity \u003d new InputStreamEntity(is, offset, len);\n       response \u003d\n           Response.ok(entity).type(MediaType.APPLICATION_OCTET_STREAM).build();\n       break;\n     }\n     case GETFILESTATUS: {\n       FSOperations.FSFileStatus command \u003d new FSOperations.FSFileStatus(path);\n       Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case LISTSTATUS: {\n       String filter \u003d params.get(FilterParam.NAME, FilterParam.class);\n       FSOperations.FSListStatus command \u003d\n           new FSOperations.FSListStatus(path, filter);\n       Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}] filter [{}]\", path, (filter !\u003d null) ? filter : \"-\");\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETHOMEDIRECTORY: {\n       enforceRootPath(op.value(), path);\n       FSOperations.FSHomeDir command \u003d new FSOperations.FSHomeDir();\n       JSONObject json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"\");\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case INSTRUMENTATION: {\n       enforceRootPath(op.value(), path);\n       Groups groups \u003d HttpFSServerWebApp.get().get(Groups.class);\n       List\u003cString\u003e userGroups \u003d groups.getGroups(user.getShortUserName());\n       if (!userGroups.contains(HttpFSServerWebApp.get().getAdminGroup())) {\n         throw new AccessControlException(\n             \"User not in HttpFSServer admin group\");\n       }\n       Instrumentation instrumentation \u003d\n           HttpFSServerWebApp.get().get(Instrumentation.class);\n       Map snapshot \u003d instrumentation.getSnapshot();\n       response \u003d Response.ok(snapshot).build();\n       break;\n     }\n     case GETCONTENTSUMMARY: {\n       FSOperations.FSContentSummary command \u003d\n           new FSOperations.FSContentSummary(path);\n       Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETFILECHECKSUM: {\n       FSOperations.FSFileChecksum command \u003d\n           new FSOperations.FSFileChecksum(path);\n       Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETFILEBLOCKLOCATIONS: {\n       response \u003d Response.status(Response.Status.BAD_REQUEST).build();\n       break;\n     }\n     case GETACLSTATUS: {\n       FSOperations.FSAclStatus command \u003d new FSOperations.FSAclStatus(path);\n       Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"ACL status for [{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETXATTRS: {\n       List\u003cString\u003e xattrNames \u003d\n           params.getValues(XAttrNameParam.NAME, XAttrNameParam.class);\n       XAttrCodec encoding \u003d\n           params.get(XAttrEncodingParam.NAME, XAttrEncodingParam.class);\n       FSOperations.FSGetXAttrs command \u003d\n           new FSOperations.FSGetXAttrs(path, xattrNames, encoding);\n       @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"XAttrs for [{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case LISTXATTRS: {\n       FSOperations.FSListXAttrs command \u003d new FSOperations.FSListXAttrs(path);\n       @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"XAttr names for [{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case LISTSTATUS_BATCH: {\n       String startAfter \u003d params.get(\n           HttpFSParametersProvider.StartAfterParam.NAME,\n           HttpFSParametersProvider.StartAfterParam.class);\n       byte[] token \u003d HttpFSUtils.EMPTY_BYTES;\n       if (startAfter !\u003d null) {\n         token \u003d startAfter.getBytes(Charsets.UTF_8);\n       }\n       FSOperations.FSListStatusBatch command \u003d new FSOperations\n           .FSListStatusBatch(path, token);\n       @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}] token [{}]\", path, token);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n+    case GETTRASHROOT: {\n+      FSOperations.FSTrashRoot command \u003d new FSOperations.FSTrashRoot(path);\n+      JSONObject json \u003d fsExecute(user, command);\n+      AUDIT_LOG.info(\"[{}]\", path);\n+      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n+      break;\n+    }\n     default: {\n       throw new IOException(\n           MessageFormat.format(\"Invalid HTTP GET operation [{0}]\", op.value()));\n     }\n     }\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Response get(@PathParam(\"path\") String path,\n                      @QueryParam(OperationParam.NAME) OperationParam op,\n                      @Context Parameters params,\n                      @Context HttpServletRequest request)\n    throws IOException, FileSystemAccessException {\n    UserGroupInformation user \u003d HttpUserGroupInformation.get();\n    Response response;\n    path \u003d makeAbsolute(path);\n    MDC.put(HttpFSFileSystem.OP_PARAM, op.value().name());\n    MDC.put(\"hostname\", request.getRemoteAddr());\n    switch (op.value()) {\n    case OPEN: {\n      //Invoking the command directly using an unmanaged FileSystem that is\n      // released by the FileSystemReleaseFilter\n      final FSOperations.FSOpen command \u003d new FSOperations.FSOpen(path);\n      final FileSystem fs \u003d createFileSystem(user);\n      InputStream is \u003d null;\n      UserGroupInformation ugi \u003d UserGroupInformation\n          .createProxyUser(user.getShortUserName(),\n              UserGroupInformation.getLoginUser());\n      try {\n        is \u003d ugi.doAs(new PrivilegedExceptionAction\u003cInputStream\u003e() {\n          @Override\n          public InputStream run() throws Exception {\n            return command.execute(fs);\n          }\n        });\n      } catch (InterruptedException ie) {\n        LOG.info(\"Open interrupted.\", ie);\n        Thread.currentThread().interrupt();\n      }\n      Long offset \u003d params.get(OffsetParam.NAME, OffsetParam.class);\n      Long len \u003d params.get(LenParam.NAME, LenParam.class);\n      AUDIT_LOG.info(\"[{}] offset [{}] len [{}]\",\n          new Object[] { path, offset, len });\n      InputStreamEntity entity \u003d new InputStreamEntity(is, offset, len);\n      response \u003d\n          Response.ok(entity).type(MediaType.APPLICATION_OCTET_STREAM).build();\n      break;\n    }\n    case GETFILESTATUS: {\n      FSOperations.FSFileStatus command \u003d new FSOperations.FSFileStatus(path);\n      Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case LISTSTATUS: {\n      String filter \u003d params.get(FilterParam.NAME, FilterParam.class);\n      FSOperations.FSListStatus command \u003d\n          new FSOperations.FSListStatus(path, filter);\n      Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}] filter [{}]\", path, (filter !\u003d null) ? filter : \"-\");\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETHOMEDIRECTORY: {\n      enforceRootPath(op.value(), path);\n      FSOperations.FSHomeDir command \u003d new FSOperations.FSHomeDir();\n      JSONObject json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"\");\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case INSTRUMENTATION: {\n      enforceRootPath(op.value(), path);\n      Groups groups \u003d HttpFSServerWebApp.get().get(Groups.class);\n      List\u003cString\u003e userGroups \u003d groups.getGroups(user.getShortUserName());\n      if (!userGroups.contains(HttpFSServerWebApp.get().getAdminGroup())) {\n        throw new AccessControlException(\n            \"User not in HttpFSServer admin group\");\n      }\n      Instrumentation instrumentation \u003d\n          HttpFSServerWebApp.get().get(Instrumentation.class);\n      Map snapshot \u003d instrumentation.getSnapshot();\n      response \u003d Response.ok(snapshot).build();\n      break;\n    }\n    case GETCONTENTSUMMARY: {\n      FSOperations.FSContentSummary command \u003d\n          new FSOperations.FSContentSummary(path);\n      Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETFILECHECKSUM: {\n      FSOperations.FSFileChecksum command \u003d\n          new FSOperations.FSFileChecksum(path);\n      Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETFILEBLOCKLOCATIONS: {\n      response \u003d Response.status(Response.Status.BAD_REQUEST).build();\n      break;\n    }\n    case GETACLSTATUS: {\n      FSOperations.FSAclStatus command \u003d new FSOperations.FSAclStatus(path);\n      Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"ACL status for [{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETXATTRS: {\n      List\u003cString\u003e xattrNames \u003d\n          params.getValues(XAttrNameParam.NAME, XAttrNameParam.class);\n      XAttrCodec encoding \u003d\n          params.get(XAttrEncodingParam.NAME, XAttrEncodingParam.class);\n      FSOperations.FSGetXAttrs command \u003d\n          new FSOperations.FSGetXAttrs(path, xattrNames, encoding);\n      @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"XAttrs for [{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case LISTXATTRS: {\n      FSOperations.FSListXAttrs command \u003d new FSOperations.FSListXAttrs(path);\n      @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"XAttr names for [{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case LISTSTATUS_BATCH: {\n      String startAfter \u003d params.get(\n          HttpFSParametersProvider.StartAfterParam.NAME,\n          HttpFSParametersProvider.StartAfterParam.class);\n      byte[] token \u003d HttpFSUtils.EMPTY_BYTES;\n      if (startAfter !\u003d null) {\n        token \u003d startAfter.getBytes(Charsets.UTF_8);\n      }\n      FSOperations.FSListStatusBatch command \u003d new FSOperations\n          .FSListStatusBatch(path, token);\n      @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}] token [{}]\", path, token);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETTRASHROOT: {\n      FSOperations.FSTrashRoot command \u003d new FSOperations.FSTrashRoot(path);\n      JSONObject json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    default: {\n      throw new IOException(\n          MessageFormat.format(\"Invalid HTTP GET operation [{0}]\", op.value()));\n    }\n    }\n    return response;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-httpfs/src/main/java/org/apache/hadoop/fs/http/server/HttpFSServer.java",
      "extendedDetails": {}
    },
    "8a40953058d50d421d62b71067a13b626b3cba1f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10823. Implement HttpFSFileSystem#listStatusIterator.\n",
      "commitDate": "16/09/16 3:37 PM",
      "commitName": "8a40953058d50d421d62b71067a13b626b3cba1f",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "03/06/16 5:21 PM",
      "commitNameOld": "47e0321ee91149331e6ae72e7caa41d1de078b6c",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 104.93,
      "commitsBetweenForRepo": 801,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,131 +1,146 @@\n   public Response get(@PathParam(\"path\") String path,\n                       @QueryParam(OperationParam.NAME) OperationParam op,\n                       @Context Parameters params,\n                       @Context HttpServletRequest request)\n     throws IOException, FileSystemAccessException {\n     UserGroupInformation user \u003d HttpUserGroupInformation.get();\n     Response response;\n     path \u003d makeAbsolute(path);\n     MDC.put(HttpFSFileSystem.OP_PARAM, op.value().name());\n     MDC.put(\"hostname\", request.getRemoteAddr());\n     switch (op.value()) {\n     case OPEN: {\n       //Invoking the command directly using an unmanaged FileSystem that is\n       // released by the FileSystemReleaseFilter\n       final FSOperations.FSOpen command \u003d new FSOperations.FSOpen(path);\n       final FileSystem fs \u003d createFileSystem(user);\n       InputStream is \u003d null;\n       UserGroupInformation ugi \u003d UserGroupInformation\n           .createProxyUser(user.getShortUserName(),\n               UserGroupInformation.getLoginUser());\n       try {\n         is \u003d ugi.doAs(new PrivilegedExceptionAction\u003cInputStream\u003e() {\n           @Override\n           public InputStream run() throws Exception {\n             return command.execute(fs);\n           }\n         });\n       } catch (InterruptedException ie) {\n         LOG.info(\"Open interrupted.\", ie);\n         Thread.currentThread().interrupt();\n       }\n       Long offset \u003d params.get(OffsetParam.NAME, OffsetParam.class);\n       Long len \u003d params.get(LenParam.NAME, LenParam.class);\n       AUDIT_LOG.info(\"[{}] offset [{}] len [{}]\",\n           new Object[] { path, offset, len });\n       InputStreamEntity entity \u003d new InputStreamEntity(is, offset, len);\n       response \u003d\n           Response.ok(entity).type(MediaType.APPLICATION_OCTET_STREAM).build();\n       break;\n     }\n     case GETFILESTATUS: {\n       FSOperations.FSFileStatus command \u003d new FSOperations.FSFileStatus(path);\n       Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case LISTSTATUS: {\n       String filter \u003d params.get(FilterParam.NAME, FilterParam.class);\n       FSOperations.FSListStatus command \u003d\n           new FSOperations.FSListStatus(path, filter);\n       Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}] filter [{}]\", path, (filter !\u003d null) ? filter : \"-\");\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETHOMEDIRECTORY: {\n       enforceRootPath(op.value(), path);\n       FSOperations.FSHomeDir command \u003d new FSOperations.FSHomeDir();\n       JSONObject json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"\");\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case INSTRUMENTATION: {\n       enforceRootPath(op.value(), path);\n       Groups groups \u003d HttpFSServerWebApp.get().get(Groups.class);\n       List\u003cString\u003e userGroups \u003d groups.getGroups(user.getShortUserName());\n       if (!userGroups.contains(HttpFSServerWebApp.get().getAdminGroup())) {\n         throw new AccessControlException(\n             \"User not in HttpFSServer admin group\");\n       }\n       Instrumentation instrumentation \u003d\n           HttpFSServerWebApp.get().get(Instrumentation.class);\n       Map snapshot \u003d instrumentation.getSnapshot();\n       response \u003d Response.ok(snapshot).build();\n       break;\n     }\n     case GETCONTENTSUMMARY: {\n       FSOperations.FSContentSummary command \u003d\n           new FSOperations.FSContentSummary(path);\n       Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETFILECHECKSUM: {\n       FSOperations.FSFileChecksum command \u003d\n           new FSOperations.FSFileChecksum(path);\n       Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"[{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETFILEBLOCKLOCATIONS: {\n       response \u003d Response.status(Response.Status.BAD_REQUEST).build();\n       break;\n     }\n     case GETACLSTATUS: {\n       FSOperations.FSAclStatus command \u003d new FSOperations.FSAclStatus(path);\n       Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"ACL status for [{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case GETXATTRS: {\n       List\u003cString\u003e xattrNames \u003d\n           params.getValues(XAttrNameParam.NAME, XAttrNameParam.class);\n       XAttrCodec encoding \u003d\n           params.get(XAttrEncodingParam.NAME, XAttrEncodingParam.class);\n       FSOperations.FSGetXAttrs command \u003d\n           new FSOperations.FSGetXAttrs(path, xattrNames, encoding);\n       @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"XAttrs for [{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n     case LISTXATTRS: {\n       FSOperations.FSListXAttrs command \u003d new FSOperations.FSListXAttrs(path);\n       @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n       AUDIT_LOG.info(\"XAttr names for [{}]\", path);\n       response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n       break;\n     }\n+    case LISTSTATUS_BATCH: {\n+      String startAfter \u003d params.get(\n+          HttpFSParametersProvider.StartAfterParam.NAME,\n+          HttpFSParametersProvider.StartAfterParam.class);\n+      byte[] token \u003d HttpFSUtils.EMPTY_BYTES;\n+      if (startAfter !\u003d null) {\n+        token \u003d startAfter.getBytes(Charsets.UTF_8);\n+      }\n+      FSOperations.FSListStatusBatch command \u003d new FSOperations\n+          .FSListStatusBatch(path, token);\n+      @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n+      AUDIT_LOG.info(\"[{}] token [{}]\", path, token);\n+      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n+      break;\n+    }\n     default: {\n       throw new IOException(\n           MessageFormat.format(\"Invalid HTTP GET operation [{0}]\", op.value()));\n     }\n     }\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Response get(@PathParam(\"path\") String path,\n                      @QueryParam(OperationParam.NAME) OperationParam op,\n                      @Context Parameters params,\n                      @Context HttpServletRequest request)\n    throws IOException, FileSystemAccessException {\n    UserGroupInformation user \u003d HttpUserGroupInformation.get();\n    Response response;\n    path \u003d makeAbsolute(path);\n    MDC.put(HttpFSFileSystem.OP_PARAM, op.value().name());\n    MDC.put(\"hostname\", request.getRemoteAddr());\n    switch (op.value()) {\n    case OPEN: {\n      //Invoking the command directly using an unmanaged FileSystem that is\n      // released by the FileSystemReleaseFilter\n      final FSOperations.FSOpen command \u003d new FSOperations.FSOpen(path);\n      final FileSystem fs \u003d createFileSystem(user);\n      InputStream is \u003d null;\n      UserGroupInformation ugi \u003d UserGroupInformation\n          .createProxyUser(user.getShortUserName(),\n              UserGroupInformation.getLoginUser());\n      try {\n        is \u003d ugi.doAs(new PrivilegedExceptionAction\u003cInputStream\u003e() {\n          @Override\n          public InputStream run() throws Exception {\n            return command.execute(fs);\n          }\n        });\n      } catch (InterruptedException ie) {\n        LOG.info(\"Open interrupted.\", ie);\n        Thread.currentThread().interrupt();\n      }\n      Long offset \u003d params.get(OffsetParam.NAME, OffsetParam.class);\n      Long len \u003d params.get(LenParam.NAME, LenParam.class);\n      AUDIT_LOG.info(\"[{}] offset [{}] len [{}]\",\n          new Object[] { path, offset, len });\n      InputStreamEntity entity \u003d new InputStreamEntity(is, offset, len);\n      response \u003d\n          Response.ok(entity).type(MediaType.APPLICATION_OCTET_STREAM).build();\n      break;\n    }\n    case GETFILESTATUS: {\n      FSOperations.FSFileStatus command \u003d new FSOperations.FSFileStatus(path);\n      Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case LISTSTATUS: {\n      String filter \u003d params.get(FilterParam.NAME, FilterParam.class);\n      FSOperations.FSListStatus command \u003d\n          new FSOperations.FSListStatus(path, filter);\n      Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}] filter [{}]\", path, (filter !\u003d null) ? filter : \"-\");\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETHOMEDIRECTORY: {\n      enforceRootPath(op.value(), path);\n      FSOperations.FSHomeDir command \u003d new FSOperations.FSHomeDir();\n      JSONObject json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"\");\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case INSTRUMENTATION: {\n      enforceRootPath(op.value(), path);\n      Groups groups \u003d HttpFSServerWebApp.get().get(Groups.class);\n      List\u003cString\u003e userGroups \u003d groups.getGroups(user.getShortUserName());\n      if (!userGroups.contains(HttpFSServerWebApp.get().getAdminGroup())) {\n        throw new AccessControlException(\n            \"User not in HttpFSServer admin group\");\n      }\n      Instrumentation instrumentation \u003d\n          HttpFSServerWebApp.get().get(Instrumentation.class);\n      Map snapshot \u003d instrumentation.getSnapshot();\n      response \u003d Response.ok(snapshot).build();\n      break;\n    }\n    case GETCONTENTSUMMARY: {\n      FSOperations.FSContentSummary command \u003d\n          new FSOperations.FSContentSummary(path);\n      Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETFILECHECKSUM: {\n      FSOperations.FSFileChecksum command \u003d\n          new FSOperations.FSFileChecksum(path);\n      Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETFILEBLOCKLOCATIONS: {\n      response \u003d Response.status(Response.Status.BAD_REQUEST).build();\n      break;\n    }\n    case GETACLSTATUS: {\n      FSOperations.FSAclStatus command \u003d new FSOperations.FSAclStatus(path);\n      Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"ACL status for [{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETXATTRS: {\n      List\u003cString\u003e xattrNames \u003d\n          params.getValues(XAttrNameParam.NAME, XAttrNameParam.class);\n      XAttrCodec encoding \u003d\n          params.get(XAttrEncodingParam.NAME, XAttrEncodingParam.class);\n      FSOperations.FSGetXAttrs command \u003d\n          new FSOperations.FSGetXAttrs(path, xattrNames, encoding);\n      @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"XAttrs for [{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case LISTXATTRS: {\n      FSOperations.FSListXAttrs command \u003d new FSOperations.FSListXAttrs(path);\n      @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"XAttr names for [{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case LISTSTATUS_BATCH: {\n      String startAfter \u003d params.get(\n          HttpFSParametersProvider.StartAfterParam.NAME,\n          HttpFSParametersProvider.StartAfterParam.class);\n      byte[] token \u003d HttpFSUtils.EMPTY_BYTES;\n      if (startAfter !\u003d null) {\n        token \u003d startAfter.getBytes(Charsets.UTF_8);\n      }\n      FSOperations.FSListStatusBatch command \u003d new FSOperations\n          .FSListStatusBatch(path, token);\n      @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}] token [{}]\", path, token);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    default: {\n      throw new IOException(\n          MessageFormat.format(\"Invalid HTTP GET operation [{0}]\", op.value()));\n    }\n    }\n    return response;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-httpfs/src/main/java/org/apache/hadoop/fs/http/server/HttpFSServer.java",
      "extendedDetails": {}
    },
    "47e0321ee91149331e6ae72e7caa41d1de078b6c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10481. HTTPFS server should correctly impersonate as end user to open file. Contributed by Xiao Chen.\n",
      "commitDate": "03/06/16 5:21 PM",
      "commitName": "47e0321ee91149331e6ae72e7caa41d1de078b6c",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "25/04/15 9:41 PM",
      "commitNameOld": "8f3946cd4013eaeaafbaf7d038f3920f74c8457e",
      "commitAuthorOld": "Xiaoyu Yao",
      "daysBetweenCommits": 404.82,
      "commitsBetweenForRepo": 2976,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,123 +1,131 @@\n   public Response get(@PathParam(\"path\") String path,\n                       @QueryParam(OperationParam.NAME) OperationParam op,\n                       @Context Parameters params,\n                       @Context HttpServletRequest request)\n     throws IOException, FileSystemAccessException {\n     UserGroupInformation user \u003d HttpUserGroupInformation.get();\n     Response response;\n     path \u003d makeAbsolute(path);\n     MDC.put(HttpFSFileSystem.OP_PARAM, op.value().name());\n     MDC.put(\"hostname\", request.getRemoteAddr());\n     switch (op.value()) {\n-      case OPEN: {\n-        //Invoking the command directly using an unmanaged FileSystem that is\n-        // released by the FileSystemReleaseFilter\n-        FSOperations.FSOpen command \u003d new FSOperations.FSOpen(path);\n-        FileSystem fs \u003d createFileSystem(user);\n-        InputStream is \u003d command.execute(fs);\n-        Long offset \u003d params.get(OffsetParam.NAME, OffsetParam.class);\n-        Long len \u003d params.get(LenParam.NAME, LenParam.class);\n-        AUDIT_LOG.info(\"[{}] offset [{}] len [{}]\",\n-                       new Object[]{path, offset, len});\n-        InputStreamEntity entity \u003d new InputStreamEntity(is, offset, len);\n-        response \u003d\n+    case OPEN: {\n+      //Invoking the command directly using an unmanaged FileSystem that is\n+      // released by the FileSystemReleaseFilter\n+      final FSOperations.FSOpen command \u003d new FSOperations.FSOpen(path);\n+      final FileSystem fs \u003d createFileSystem(user);\n+      InputStream is \u003d null;\n+      UserGroupInformation ugi \u003d UserGroupInformation\n+          .createProxyUser(user.getShortUserName(),\n+              UserGroupInformation.getLoginUser());\n+      try {\n+        is \u003d ugi.doAs(new PrivilegedExceptionAction\u003cInputStream\u003e() {\n+          @Override\n+          public InputStream run() throws Exception {\n+            return command.execute(fs);\n+          }\n+        });\n+      } catch (InterruptedException ie) {\n+        LOG.info(\"Open interrupted.\", ie);\n+        Thread.currentThread().interrupt();\n+      }\n+      Long offset \u003d params.get(OffsetParam.NAME, OffsetParam.class);\n+      Long len \u003d params.get(LenParam.NAME, LenParam.class);\n+      AUDIT_LOG.info(\"[{}] offset [{}] len [{}]\",\n+          new Object[] { path, offset, len });\n+      InputStreamEntity entity \u003d new InputStreamEntity(is, offset, len);\n+      response \u003d\n           Response.ok(entity).type(MediaType.APPLICATION_OCTET_STREAM).build();\n-        break;\n-      }\n-      case GETFILESTATUS: {\n-        FSOperations.FSFileStatus command \u003d\n-          new FSOperations.FSFileStatus(path);\n-        Map json \u003d fsExecute(user, command);\n-        AUDIT_LOG.info(\"[{}]\", path);\n-        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n-        break;\n-      }\n-      case LISTSTATUS: {\n-        String filter \u003d params.get(FilterParam.NAME, FilterParam.class);\n-        FSOperations.FSListStatus command \u003d new FSOperations.FSListStatus(\n-          path, filter);\n-        Map json \u003d fsExecute(user, command);\n-        AUDIT_LOG.info(\"[{}] filter [{}]\", path,\n-                       (filter !\u003d null) ? filter : \"-\");\n-        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n-        break;\n-      }\n-      case GETHOMEDIRECTORY: {\n-        enforceRootPath(op.value(), path);\n-        FSOperations.FSHomeDir command \u003d new FSOperations.FSHomeDir();\n-        JSONObject json \u003d fsExecute(user, command);\n-        AUDIT_LOG.info(\"\");\n-        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n-        break;\n-      }\n-      case INSTRUMENTATION: {\n-        enforceRootPath(op.value(), path);\n-        Groups groups \u003d HttpFSServerWebApp.get().get(Groups.class);\n-        List\u003cString\u003e userGroups \u003d groups.getGroups(user.getShortUserName());\n-        if (!userGroups.contains(HttpFSServerWebApp.get().getAdminGroup())) {\n-          throw new AccessControlException(\n+      break;\n+    }\n+    case GETFILESTATUS: {\n+      FSOperations.FSFileStatus command \u003d new FSOperations.FSFileStatus(path);\n+      Map json \u003d fsExecute(user, command);\n+      AUDIT_LOG.info(\"[{}]\", path);\n+      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n+      break;\n+    }\n+    case LISTSTATUS: {\n+      String filter \u003d params.get(FilterParam.NAME, FilterParam.class);\n+      FSOperations.FSListStatus command \u003d\n+          new FSOperations.FSListStatus(path, filter);\n+      Map json \u003d fsExecute(user, command);\n+      AUDIT_LOG.info(\"[{}] filter [{}]\", path, (filter !\u003d null) ? filter : \"-\");\n+      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n+      break;\n+    }\n+    case GETHOMEDIRECTORY: {\n+      enforceRootPath(op.value(), path);\n+      FSOperations.FSHomeDir command \u003d new FSOperations.FSHomeDir();\n+      JSONObject json \u003d fsExecute(user, command);\n+      AUDIT_LOG.info(\"\");\n+      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n+      break;\n+    }\n+    case INSTRUMENTATION: {\n+      enforceRootPath(op.value(), path);\n+      Groups groups \u003d HttpFSServerWebApp.get().get(Groups.class);\n+      List\u003cString\u003e userGroups \u003d groups.getGroups(user.getShortUserName());\n+      if (!userGroups.contains(HttpFSServerWebApp.get().getAdminGroup())) {\n+        throw new AccessControlException(\n             \"User not in HttpFSServer admin group\");\n-        }\n-        Instrumentation instrumentation \u003d\n+      }\n+      Instrumentation instrumentation \u003d\n           HttpFSServerWebApp.get().get(Instrumentation.class);\n-        Map snapshot \u003d instrumentation.getSnapshot();\n-        response \u003d Response.ok(snapshot).build();\n-        break;\n-      }\n-      case GETCONTENTSUMMARY: {\n-        FSOperations.FSContentSummary command \u003d\n+      Map snapshot \u003d instrumentation.getSnapshot();\n+      response \u003d Response.ok(snapshot).build();\n+      break;\n+    }\n+    case GETCONTENTSUMMARY: {\n+      FSOperations.FSContentSummary command \u003d\n           new FSOperations.FSContentSummary(path);\n-        Map json \u003d fsExecute(user, command);\n-        AUDIT_LOG.info(\"[{}]\", path);\n-        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n-        break;\n-      }\n-      case GETFILECHECKSUM: {\n-        FSOperations.FSFileChecksum command \u003d\n+      Map json \u003d fsExecute(user, command);\n+      AUDIT_LOG.info(\"[{}]\", path);\n+      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n+      break;\n+    }\n+    case GETFILECHECKSUM: {\n+      FSOperations.FSFileChecksum command \u003d\n           new FSOperations.FSFileChecksum(path);\n-        Map json \u003d fsExecute(user, command);\n-        AUDIT_LOG.info(\"[{}]\", path);\n-        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n-        break;\n-      }\n-      case GETFILEBLOCKLOCATIONS: {\n-        response \u003d Response.status(Response.Status.BAD_REQUEST).build();\n-        break;\n-      }\n-      case GETACLSTATUS: {\n-        FSOperations.FSAclStatus command \u003d\n-                new FSOperations.FSAclStatus(path);\n-        Map json \u003d fsExecute(user, command);\n-        AUDIT_LOG.info(\"ACL status for [{}]\", path);\n-        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n-        break;\n-      }\n-      case GETXATTRS: {\n-        List\u003cString\u003e xattrNames \u003d params.getValues(XAttrNameParam.NAME, \n-            XAttrNameParam.class);\n-        XAttrCodec encoding \u003d params.get(XAttrEncodingParam.NAME, \n-            XAttrEncodingParam.class);\n-        FSOperations.FSGetXAttrs command \u003d new FSOperations.FSGetXAttrs(path, \n-            xattrNames, encoding);\n-        @SuppressWarnings(\"rawtypes\")\n-        Map json \u003d fsExecute(user, command);\n-        AUDIT_LOG.info(\"XAttrs for [{}]\", path);\n-        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n-        break;\n-      }\n-      case LISTXATTRS: {\n-        FSOperations.FSListXAttrs command \u003d new FSOperations.FSListXAttrs(path);\n-        @SuppressWarnings(\"rawtypes\")\n-        Map json \u003d fsExecute(user, command);\n-        AUDIT_LOG.info(\"XAttr names for [{}]\", path);\n-        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n-        break;\n-      }\n-      default: {\n-        throw new IOException(\n-          MessageFormat.format(\"Invalid HTTP GET operation [{0}]\",\n-                               op.value()));\n-      }\n+      Map json \u003d fsExecute(user, command);\n+      AUDIT_LOG.info(\"[{}]\", path);\n+      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n+      break;\n+    }\n+    case GETFILEBLOCKLOCATIONS: {\n+      response \u003d Response.status(Response.Status.BAD_REQUEST).build();\n+      break;\n+    }\n+    case GETACLSTATUS: {\n+      FSOperations.FSAclStatus command \u003d new FSOperations.FSAclStatus(path);\n+      Map json \u003d fsExecute(user, command);\n+      AUDIT_LOG.info(\"ACL status for [{}]\", path);\n+      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n+      break;\n+    }\n+    case GETXATTRS: {\n+      List\u003cString\u003e xattrNames \u003d\n+          params.getValues(XAttrNameParam.NAME, XAttrNameParam.class);\n+      XAttrCodec encoding \u003d\n+          params.get(XAttrEncodingParam.NAME, XAttrEncodingParam.class);\n+      FSOperations.FSGetXAttrs command \u003d\n+          new FSOperations.FSGetXAttrs(path, xattrNames, encoding);\n+      @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n+      AUDIT_LOG.info(\"XAttrs for [{}]\", path);\n+      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n+      break;\n+    }\n+    case LISTXATTRS: {\n+      FSOperations.FSListXAttrs command \u003d new FSOperations.FSListXAttrs(path);\n+      @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n+      AUDIT_LOG.info(\"XAttr names for [{}]\", path);\n+      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n+      break;\n+    }\n+    default: {\n+      throw new IOException(\n+          MessageFormat.format(\"Invalid HTTP GET operation [{0}]\", op.value()));\n+    }\n     }\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Response get(@PathParam(\"path\") String path,\n                      @QueryParam(OperationParam.NAME) OperationParam op,\n                      @Context Parameters params,\n                      @Context HttpServletRequest request)\n    throws IOException, FileSystemAccessException {\n    UserGroupInformation user \u003d HttpUserGroupInformation.get();\n    Response response;\n    path \u003d makeAbsolute(path);\n    MDC.put(HttpFSFileSystem.OP_PARAM, op.value().name());\n    MDC.put(\"hostname\", request.getRemoteAddr());\n    switch (op.value()) {\n    case OPEN: {\n      //Invoking the command directly using an unmanaged FileSystem that is\n      // released by the FileSystemReleaseFilter\n      final FSOperations.FSOpen command \u003d new FSOperations.FSOpen(path);\n      final FileSystem fs \u003d createFileSystem(user);\n      InputStream is \u003d null;\n      UserGroupInformation ugi \u003d UserGroupInformation\n          .createProxyUser(user.getShortUserName(),\n              UserGroupInformation.getLoginUser());\n      try {\n        is \u003d ugi.doAs(new PrivilegedExceptionAction\u003cInputStream\u003e() {\n          @Override\n          public InputStream run() throws Exception {\n            return command.execute(fs);\n          }\n        });\n      } catch (InterruptedException ie) {\n        LOG.info(\"Open interrupted.\", ie);\n        Thread.currentThread().interrupt();\n      }\n      Long offset \u003d params.get(OffsetParam.NAME, OffsetParam.class);\n      Long len \u003d params.get(LenParam.NAME, LenParam.class);\n      AUDIT_LOG.info(\"[{}] offset [{}] len [{}]\",\n          new Object[] { path, offset, len });\n      InputStreamEntity entity \u003d new InputStreamEntity(is, offset, len);\n      response \u003d\n          Response.ok(entity).type(MediaType.APPLICATION_OCTET_STREAM).build();\n      break;\n    }\n    case GETFILESTATUS: {\n      FSOperations.FSFileStatus command \u003d new FSOperations.FSFileStatus(path);\n      Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case LISTSTATUS: {\n      String filter \u003d params.get(FilterParam.NAME, FilterParam.class);\n      FSOperations.FSListStatus command \u003d\n          new FSOperations.FSListStatus(path, filter);\n      Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}] filter [{}]\", path, (filter !\u003d null) ? filter : \"-\");\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETHOMEDIRECTORY: {\n      enforceRootPath(op.value(), path);\n      FSOperations.FSHomeDir command \u003d new FSOperations.FSHomeDir();\n      JSONObject json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"\");\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case INSTRUMENTATION: {\n      enforceRootPath(op.value(), path);\n      Groups groups \u003d HttpFSServerWebApp.get().get(Groups.class);\n      List\u003cString\u003e userGroups \u003d groups.getGroups(user.getShortUserName());\n      if (!userGroups.contains(HttpFSServerWebApp.get().getAdminGroup())) {\n        throw new AccessControlException(\n            \"User not in HttpFSServer admin group\");\n      }\n      Instrumentation instrumentation \u003d\n          HttpFSServerWebApp.get().get(Instrumentation.class);\n      Map snapshot \u003d instrumentation.getSnapshot();\n      response \u003d Response.ok(snapshot).build();\n      break;\n    }\n    case GETCONTENTSUMMARY: {\n      FSOperations.FSContentSummary command \u003d\n          new FSOperations.FSContentSummary(path);\n      Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETFILECHECKSUM: {\n      FSOperations.FSFileChecksum command \u003d\n          new FSOperations.FSFileChecksum(path);\n      Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"[{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETFILEBLOCKLOCATIONS: {\n      response \u003d Response.status(Response.Status.BAD_REQUEST).build();\n      break;\n    }\n    case GETACLSTATUS: {\n      FSOperations.FSAclStatus command \u003d new FSOperations.FSAclStatus(path);\n      Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"ACL status for [{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case GETXATTRS: {\n      List\u003cString\u003e xattrNames \u003d\n          params.getValues(XAttrNameParam.NAME, XAttrNameParam.class);\n      XAttrCodec encoding \u003d\n          params.get(XAttrEncodingParam.NAME, XAttrEncodingParam.class);\n      FSOperations.FSGetXAttrs command \u003d\n          new FSOperations.FSGetXAttrs(path, xattrNames, encoding);\n      @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"XAttrs for [{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    case LISTXATTRS: {\n      FSOperations.FSListXAttrs command \u003d new FSOperations.FSListXAttrs(path);\n      @SuppressWarnings(\"rawtypes\") Map json \u003d fsExecute(user, command);\n      AUDIT_LOG.info(\"XAttr names for [{}]\", path);\n      response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n      break;\n    }\n    default: {\n      throw new IOException(\n          MessageFormat.format(\"Invalid HTTP GET operation [{0}]\", op.value()));\n    }\n    }\n    return response;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-httpfs/src/main/java/org/apache/hadoop/fs/http/server/HttpFSServer.java",
      "extendedDetails": {}
    },
    "828429dec1a7fd3bb5aab6f5bd81423cf8fcbc90": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-7232. Populate hostname in httpfs audit log (Zoran Dimitrijevic via aw)\n",
      "commitDate": "23/10/14 2:06 PM",
      "commitName": "828429dec1a7fd3bb5aab6f5bd81423cf8fcbc90",
      "commitAuthor": "Allen Wittenauer",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-7232. Populate hostname in httpfs audit log (Zoran Dimitrijevic via aw)\n",
          "commitDate": "23/10/14 2:06 PM",
          "commitName": "828429dec1a7fd3bb5aab6f5bd81423cf8fcbc90",
          "commitAuthor": "Allen Wittenauer",
          "commitDateOld": "13/08/14 1:27 PM",
          "commitNameOld": "065d9ec5d93e37b4bbd6fd27cb411dc58b0fb686",
          "commitAuthorOld": "Alejandro Abdelnur",
          "daysBetweenCommits": 71.03,
          "commitsBetweenForRepo": 700,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,121 +1,123 @@\n   public Response get(@PathParam(\"path\") String path,\n                       @QueryParam(OperationParam.NAME) OperationParam op,\n-                      @Context Parameters params)\n+                      @Context Parameters params,\n+                      @Context HttpServletRequest request)\n     throws IOException, FileSystemAccessException {\n     UserGroupInformation user \u003d HttpUserGroupInformation.get();\n     Response response;\n     path \u003d makeAbsolute(path);\n     MDC.put(HttpFSFileSystem.OP_PARAM, op.value().name());\n+    MDC.put(\"hostname\", request.getRemoteAddr());\n     switch (op.value()) {\n       case OPEN: {\n         //Invoking the command directly using an unmanaged FileSystem that is\n         // released by the FileSystemReleaseFilter\n         FSOperations.FSOpen command \u003d new FSOperations.FSOpen(path);\n         FileSystem fs \u003d createFileSystem(user);\n         InputStream is \u003d command.execute(fs);\n         Long offset \u003d params.get(OffsetParam.NAME, OffsetParam.class);\n         Long len \u003d params.get(LenParam.NAME, LenParam.class);\n         AUDIT_LOG.info(\"[{}] offset [{}] len [{}]\",\n                        new Object[]{path, offset, len});\n         InputStreamEntity entity \u003d new InputStreamEntity(is, offset, len);\n         response \u003d\n           Response.ok(entity).type(MediaType.APPLICATION_OCTET_STREAM).build();\n         break;\n       }\n       case GETFILESTATUS: {\n         FSOperations.FSFileStatus command \u003d\n           new FSOperations.FSFileStatus(path);\n         Map json \u003d fsExecute(user, command);\n         AUDIT_LOG.info(\"[{}]\", path);\n         response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n         break;\n       }\n       case LISTSTATUS: {\n         String filter \u003d params.get(FilterParam.NAME, FilterParam.class);\n         FSOperations.FSListStatus command \u003d new FSOperations.FSListStatus(\n           path, filter);\n         Map json \u003d fsExecute(user, command);\n         AUDIT_LOG.info(\"[{}] filter [{}]\", path,\n                        (filter !\u003d null) ? filter : \"-\");\n         response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n         break;\n       }\n       case GETHOMEDIRECTORY: {\n         enforceRootPath(op.value(), path);\n         FSOperations.FSHomeDir command \u003d new FSOperations.FSHomeDir();\n         JSONObject json \u003d fsExecute(user, command);\n         AUDIT_LOG.info(\"\");\n         response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n         break;\n       }\n       case INSTRUMENTATION: {\n         enforceRootPath(op.value(), path);\n         Groups groups \u003d HttpFSServerWebApp.get().get(Groups.class);\n         List\u003cString\u003e userGroups \u003d groups.getGroups(user.getShortUserName());\n         if (!userGroups.contains(HttpFSServerWebApp.get().getAdminGroup())) {\n           throw new AccessControlException(\n             \"User not in HttpFSServer admin group\");\n         }\n         Instrumentation instrumentation \u003d\n           HttpFSServerWebApp.get().get(Instrumentation.class);\n         Map snapshot \u003d instrumentation.getSnapshot();\n         response \u003d Response.ok(snapshot).build();\n         break;\n       }\n       case GETCONTENTSUMMARY: {\n         FSOperations.FSContentSummary command \u003d\n           new FSOperations.FSContentSummary(path);\n         Map json \u003d fsExecute(user, command);\n         AUDIT_LOG.info(\"[{}]\", path);\n         response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n         break;\n       }\n       case GETFILECHECKSUM: {\n         FSOperations.FSFileChecksum command \u003d\n           new FSOperations.FSFileChecksum(path);\n         Map json \u003d fsExecute(user, command);\n         AUDIT_LOG.info(\"[{}]\", path);\n         response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n         break;\n       }\n       case GETFILEBLOCKLOCATIONS: {\n         response \u003d Response.status(Response.Status.BAD_REQUEST).build();\n         break;\n       }\n       case GETACLSTATUS: {\n         FSOperations.FSAclStatus command \u003d\n                 new FSOperations.FSAclStatus(path);\n         Map json \u003d fsExecute(user, command);\n         AUDIT_LOG.info(\"ACL status for [{}]\", path);\n         response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n         break;\n       }\n       case GETXATTRS: {\n         List\u003cString\u003e xattrNames \u003d params.getValues(XAttrNameParam.NAME, \n             XAttrNameParam.class);\n         XAttrCodec encoding \u003d params.get(XAttrEncodingParam.NAME, \n             XAttrEncodingParam.class);\n         FSOperations.FSGetXAttrs command \u003d new FSOperations.FSGetXAttrs(path, \n             xattrNames, encoding);\n         @SuppressWarnings(\"rawtypes\")\n         Map json \u003d fsExecute(user, command);\n         AUDIT_LOG.info(\"XAttrs for [{}]\", path);\n         response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n         break;\n       }\n       case LISTXATTRS: {\n         FSOperations.FSListXAttrs command \u003d new FSOperations.FSListXAttrs(path);\n         @SuppressWarnings(\"rawtypes\")\n         Map json \u003d fsExecute(user, command);\n         AUDIT_LOG.info(\"XAttr names for [{}]\", path);\n         response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n         break;\n       }\n       default: {\n         throw new IOException(\n           MessageFormat.format(\"Invalid HTTP GET operation [{0}]\",\n                                op.value()));\n       }\n     }\n     return response;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Response get(@PathParam(\"path\") String path,\n                      @QueryParam(OperationParam.NAME) OperationParam op,\n                      @Context Parameters params,\n                      @Context HttpServletRequest request)\n    throws IOException, FileSystemAccessException {\n    UserGroupInformation user \u003d HttpUserGroupInformation.get();\n    Response response;\n    path \u003d makeAbsolute(path);\n    MDC.put(HttpFSFileSystem.OP_PARAM, op.value().name());\n    MDC.put(\"hostname\", request.getRemoteAddr());\n    switch (op.value()) {\n      case OPEN: {\n        //Invoking the command directly using an unmanaged FileSystem that is\n        // released by the FileSystemReleaseFilter\n        FSOperations.FSOpen command \u003d new FSOperations.FSOpen(path);\n        FileSystem fs \u003d createFileSystem(user);\n        InputStream is \u003d command.execute(fs);\n        Long offset \u003d params.get(OffsetParam.NAME, OffsetParam.class);\n        Long len \u003d params.get(LenParam.NAME, LenParam.class);\n        AUDIT_LOG.info(\"[{}] offset [{}] len [{}]\",\n                       new Object[]{path, offset, len});\n        InputStreamEntity entity \u003d new InputStreamEntity(is, offset, len);\n        response \u003d\n          Response.ok(entity).type(MediaType.APPLICATION_OCTET_STREAM).build();\n        break;\n      }\n      case GETFILESTATUS: {\n        FSOperations.FSFileStatus command \u003d\n          new FSOperations.FSFileStatus(path);\n        Map json \u003d fsExecute(user, command);\n        AUDIT_LOG.info(\"[{}]\", path);\n        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n        break;\n      }\n      case LISTSTATUS: {\n        String filter \u003d params.get(FilterParam.NAME, FilterParam.class);\n        FSOperations.FSListStatus command \u003d new FSOperations.FSListStatus(\n          path, filter);\n        Map json \u003d fsExecute(user, command);\n        AUDIT_LOG.info(\"[{}] filter [{}]\", path,\n                       (filter !\u003d null) ? filter : \"-\");\n        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n        break;\n      }\n      case GETHOMEDIRECTORY: {\n        enforceRootPath(op.value(), path);\n        FSOperations.FSHomeDir command \u003d new FSOperations.FSHomeDir();\n        JSONObject json \u003d fsExecute(user, command);\n        AUDIT_LOG.info(\"\");\n        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n        break;\n      }\n      case INSTRUMENTATION: {\n        enforceRootPath(op.value(), path);\n        Groups groups \u003d HttpFSServerWebApp.get().get(Groups.class);\n        List\u003cString\u003e userGroups \u003d groups.getGroups(user.getShortUserName());\n        if (!userGroups.contains(HttpFSServerWebApp.get().getAdminGroup())) {\n          throw new AccessControlException(\n            \"User not in HttpFSServer admin group\");\n        }\n        Instrumentation instrumentation \u003d\n          HttpFSServerWebApp.get().get(Instrumentation.class);\n        Map snapshot \u003d instrumentation.getSnapshot();\n        response \u003d Response.ok(snapshot).build();\n        break;\n      }\n      case GETCONTENTSUMMARY: {\n        FSOperations.FSContentSummary command \u003d\n          new FSOperations.FSContentSummary(path);\n        Map json \u003d fsExecute(user, command);\n        AUDIT_LOG.info(\"[{}]\", path);\n        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n        break;\n      }\n      case GETFILECHECKSUM: {\n        FSOperations.FSFileChecksum command \u003d\n          new FSOperations.FSFileChecksum(path);\n        Map json \u003d fsExecute(user, command);\n        AUDIT_LOG.info(\"[{}]\", path);\n        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n        break;\n      }\n      case GETFILEBLOCKLOCATIONS: {\n        response \u003d Response.status(Response.Status.BAD_REQUEST).build();\n        break;\n      }\n      case GETACLSTATUS: {\n        FSOperations.FSAclStatus command \u003d\n                new FSOperations.FSAclStatus(path);\n        Map json \u003d fsExecute(user, command);\n        AUDIT_LOG.info(\"ACL status for [{}]\", path);\n        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n        break;\n      }\n      case GETXATTRS: {\n        List\u003cString\u003e xattrNames \u003d params.getValues(XAttrNameParam.NAME, \n            XAttrNameParam.class);\n        XAttrCodec encoding \u003d params.get(XAttrEncodingParam.NAME, \n            XAttrEncodingParam.class);\n        FSOperations.FSGetXAttrs command \u003d new FSOperations.FSGetXAttrs(path, \n            xattrNames, encoding);\n        @SuppressWarnings(\"rawtypes\")\n        Map json \u003d fsExecute(user, command);\n        AUDIT_LOG.info(\"XAttrs for [{}]\", path);\n        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n        break;\n      }\n      case LISTXATTRS: {\n        FSOperations.FSListXAttrs command \u003d new FSOperations.FSListXAttrs(path);\n        @SuppressWarnings(\"rawtypes\")\n        Map json \u003d fsExecute(user, command);\n        AUDIT_LOG.info(\"XAttr names for [{}]\", path);\n        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n        break;\n      }\n      default: {\n        throw new IOException(\n          MessageFormat.format(\"Invalid HTTP GET operation [{0}]\",\n                               op.value()));\n      }\n    }\n    return response;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs-httpfs/src/main/java/org/apache/hadoop/fs/http/server/HttpFSServer.java",
          "extendedDetails": {
            "oldValue": "[path-String(annotations-@PathParam(\"path\")), op-OperationParam(annotations-@QueryParam(OperationParam.NAME)), params-Parameters(annotations-@Context)]",
            "newValue": "[path-String(annotations-@PathParam(\"path\")), op-OperationParam(annotations-@QueryParam(OperationParam.NAME)), params-Parameters(annotations-@Context), request-HttpServletRequest(annotations-@Context)]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-7232. Populate hostname in httpfs audit log (Zoran Dimitrijevic via aw)\n",
          "commitDate": "23/10/14 2:06 PM",
          "commitName": "828429dec1a7fd3bb5aab6f5bd81423cf8fcbc90",
          "commitAuthor": "Allen Wittenauer",
          "commitDateOld": "13/08/14 1:27 PM",
          "commitNameOld": "065d9ec5d93e37b4bbd6fd27cb411dc58b0fb686",
          "commitAuthorOld": "Alejandro Abdelnur",
          "daysBetweenCommits": 71.03,
          "commitsBetweenForRepo": 700,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,121 +1,123 @@\n   public Response get(@PathParam(\"path\") String path,\n                       @QueryParam(OperationParam.NAME) OperationParam op,\n-                      @Context Parameters params)\n+                      @Context Parameters params,\n+                      @Context HttpServletRequest request)\n     throws IOException, FileSystemAccessException {\n     UserGroupInformation user \u003d HttpUserGroupInformation.get();\n     Response response;\n     path \u003d makeAbsolute(path);\n     MDC.put(HttpFSFileSystem.OP_PARAM, op.value().name());\n+    MDC.put(\"hostname\", request.getRemoteAddr());\n     switch (op.value()) {\n       case OPEN: {\n         //Invoking the command directly using an unmanaged FileSystem that is\n         // released by the FileSystemReleaseFilter\n         FSOperations.FSOpen command \u003d new FSOperations.FSOpen(path);\n         FileSystem fs \u003d createFileSystem(user);\n         InputStream is \u003d command.execute(fs);\n         Long offset \u003d params.get(OffsetParam.NAME, OffsetParam.class);\n         Long len \u003d params.get(LenParam.NAME, LenParam.class);\n         AUDIT_LOG.info(\"[{}] offset [{}] len [{}]\",\n                        new Object[]{path, offset, len});\n         InputStreamEntity entity \u003d new InputStreamEntity(is, offset, len);\n         response \u003d\n           Response.ok(entity).type(MediaType.APPLICATION_OCTET_STREAM).build();\n         break;\n       }\n       case GETFILESTATUS: {\n         FSOperations.FSFileStatus command \u003d\n           new FSOperations.FSFileStatus(path);\n         Map json \u003d fsExecute(user, command);\n         AUDIT_LOG.info(\"[{}]\", path);\n         response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n         break;\n       }\n       case LISTSTATUS: {\n         String filter \u003d params.get(FilterParam.NAME, FilterParam.class);\n         FSOperations.FSListStatus command \u003d new FSOperations.FSListStatus(\n           path, filter);\n         Map json \u003d fsExecute(user, command);\n         AUDIT_LOG.info(\"[{}] filter [{}]\", path,\n                        (filter !\u003d null) ? filter : \"-\");\n         response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n         break;\n       }\n       case GETHOMEDIRECTORY: {\n         enforceRootPath(op.value(), path);\n         FSOperations.FSHomeDir command \u003d new FSOperations.FSHomeDir();\n         JSONObject json \u003d fsExecute(user, command);\n         AUDIT_LOG.info(\"\");\n         response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n         break;\n       }\n       case INSTRUMENTATION: {\n         enforceRootPath(op.value(), path);\n         Groups groups \u003d HttpFSServerWebApp.get().get(Groups.class);\n         List\u003cString\u003e userGroups \u003d groups.getGroups(user.getShortUserName());\n         if (!userGroups.contains(HttpFSServerWebApp.get().getAdminGroup())) {\n           throw new AccessControlException(\n             \"User not in HttpFSServer admin group\");\n         }\n         Instrumentation instrumentation \u003d\n           HttpFSServerWebApp.get().get(Instrumentation.class);\n         Map snapshot \u003d instrumentation.getSnapshot();\n         response \u003d Response.ok(snapshot).build();\n         break;\n       }\n       case GETCONTENTSUMMARY: {\n         FSOperations.FSContentSummary command \u003d\n           new FSOperations.FSContentSummary(path);\n         Map json \u003d fsExecute(user, command);\n         AUDIT_LOG.info(\"[{}]\", path);\n         response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n         break;\n       }\n       case GETFILECHECKSUM: {\n         FSOperations.FSFileChecksum command \u003d\n           new FSOperations.FSFileChecksum(path);\n         Map json \u003d fsExecute(user, command);\n         AUDIT_LOG.info(\"[{}]\", path);\n         response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n         break;\n       }\n       case GETFILEBLOCKLOCATIONS: {\n         response \u003d Response.status(Response.Status.BAD_REQUEST).build();\n         break;\n       }\n       case GETACLSTATUS: {\n         FSOperations.FSAclStatus command \u003d\n                 new FSOperations.FSAclStatus(path);\n         Map json \u003d fsExecute(user, command);\n         AUDIT_LOG.info(\"ACL status for [{}]\", path);\n         response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n         break;\n       }\n       case GETXATTRS: {\n         List\u003cString\u003e xattrNames \u003d params.getValues(XAttrNameParam.NAME, \n             XAttrNameParam.class);\n         XAttrCodec encoding \u003d params.get(XAttrEncodingParam.NAME, \n             XAttrEncodingParam.class);\n         FSOperations.FSGetXAttrs command \u003d new FSOperations.FSGetXAttrs(path, \n             xattrNames, encoding);\n         @SuppressWarnings(\"rawtypes\")\n         Map json \u003d fsExecute(user, command);\n         AUDIT_LOG.info(\"XAttrs for [{}]\", path);\n         response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n         break;\n       }\n       case LISTXATTRS: {\n         FSOperations.FSListXAttrs command \u003d new FSOperations.FSListXAttrs(path);\n         @SuppressWarnings(\"rawtypes\")\n         Map json \u003d fsExecute(user, command);\n         AUDIT_LOG.info(\"XAttr names for [{}]\", path);\n         response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n         break;\n       }\n       default: {\n         throw new IOException(\n           MessageFormat.format(\"Invalid HTTP GET operation [{0}]\",\n                                op.value()));\n       }\n     }\n     return response;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Response get(@PathParam(\"path\") String path,\n                      @QueryParam(OperationParam.NAME) OperationParam op,\n                      @Context Parameters params,\n                      @Context HttpServletRequest request)\n    throws IOException, FileSystemAccessException {\n    UserGroupInformation user \u003d HttpUserGroupInformation.get();\n    Response response;\n    path \u003d makeAbsolute(path);\n    MDC.put(HttpFSFileSystem.OP_PARAM, op.value().name());\n    MDC.put(\"hostname\", request.getRemoteAddr());\n    switch (op.value()) {\n      case OPEN: {\n        //Invoking the command directly using an unmanaged FileSystem that is\n        // released by the FileSystemReleaseFilter\n        FSOperations.FSOpen command \u003d new FSOperations.FSOpen(path);\n        FileSystem fs \u003d createFileSystem(user);\n        InputStream is \u003d command.execute(fs);\n        Long offset \u003d params.get(OffsetParam.NAME, OffsetParam.class);\n        Long len \u003d params.get(LenParam.NAME, LenParam.class);\n        AUDIT_LOG.info(\"[{}] offset [{}] len [{}]\",\n                       new Object[]{path, offset, len});\n        InputStreamEntity entity \u003d new InputStreamEntity(is, offset, len);\n        response \u003d\n          Response.ok(entity).type(MediaType.APPLICATION_OCTET_STREAM).build();\n        break;\n      }\n      case GETFILESTATUS: {\n        FSOperations.FSFileStatus command \u003d\n          new FSOperations.FSFileStatus(path);\n        Map json \u003d fsExecute(user, command);\n        AUDIT_LOG.info(\"[{}]\", path);\n        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n        break;\n      }\n      case LISTSTATUS: {\n        String filter \u003d params.get(FilterParam.NAME, FilterParam.class);\n        FSOperations.FSListStatus command \u003d new FSOperations.FSListStatus(\n          path, filter);\n        Map json \u003d fsExecute(user, command);\n        AUDIT_LOG.info(\"[{}] filter [{}]\", path,\n                       (filter !\u003d null) ? filter : \"-\");\n        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n        break;\n      }\n      case GETHOMEDIRECTORY: {\n        enforceRootPath(op.value(), path);\n        FSOperations.FSHomeDir command \u003d new FSOperations.FSHomeDir();\n        JSONObject json \u003d fsExecute(user, command);\n        AUDIT_LOG.info(\"\");\n        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n        break;\n      }\n      case INSTRUMENTATION: {\n        enforceRootPath(op.value(), path);\n        Groups groups \u003d HttpFSServerWebApp.get().get(Groups.class);\n        List\u003cString\u003e userGroups \u003d groups.getGroups(user.getShortUserName());\n        if (!userGroups.contains(HttpFSServerWebApp.get().getAdminGroup())) {\n          throw new AccessControlException(\n            \"User not in HttpFSServer admin group\");\n        }\n        Instrumentation instrumentation \u003d\n          HttpFSServerWebApp.get().get(Instrumentation.class);\n        Map snapshot \u003d instrumentation.getSnapshot();\n        response \u003d Response.ok(snapshot).build();\n        break;\n      }\n      case GETCONTENTSUMMARY: {\n        FSOperations.FSContentSummary command \u003d\n          new FSOperations.FSContentSummary(path);\n        Map json \u003d fsExecute(user, command);\n        AUDIT_LOG.info(\"[{}]\", path);\n        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n        break;\n      }\n      case GETFILECHECKSUM: {\n        FSOperations.FSFileChecksum command \u003d\n          new FSOperations.FSFileChecksum(path);\n        Map json \u003d fsExecute(user, command);\n        AUDIT_LOG.info(\"[{}]\", path);\n        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n        break;\n      }\n      case GETFILEBLOCKLOCATIONS: {\n        response \u003d Response.status(Response.Status.BAD_REQUEST).build();\n        break;\n      }\n      case GETACLSTATUS: {\n        FSOperations.FSAclStatus command \u003d\n                new FSOperations.FSAclStatus(path);\n        Map json \u003d fsExecute(user, command);\n        AUDIT_LOG.info(\"ACL status for [{}]\", path);\n        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n        break;\n      }\n      case GETXATTRS: {\n        List\u003cString\u003e xattrNames \u003d params.getValues(XAttrNameParam.NAME, \n            XAttrNameParam.class);\n        XAttrCodec encoding \u003d params.get(XAttrEncodingParam.NAME, \n            XAttrEncodingParam.class);\n        FSOperations.FSGetXAttrs command \u003d new FSOperations.FSGetXAttrs(path, \n            xattrNames, encoding);\n        @SuppressWarnings(\"rawtypes\")\n        Map json \u003d fsExecute(user, command);\n        AUDIT_LOG.info(\"XAttrs for [{}]\", path);\n        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n        break;\n      }\n      case LISTXATTRS: {\n        FSOperations.FSListXAttrs command \u003d new FSOperations.FSListXAttrs(path);\n        @SuppressWarnings(\"rawtypes\")\n        Map json \u003d fsExecute(user, command);\n        AUDIT_LOG.info(\"XAttr names for [{}]\", path);\n        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n        break;\n      }\n      default: {\n        throw new IOException(\n          MessageFormat.format(\"Invalid HTTP GET operation [{0}]\",\n                               op.value()));\n      }\n    }\n    return response;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs-httpfs/src/main/java/org/apache/hadoop/fs/http/server/HttpFSServer.java",
          "extendedDetails": {}
        }
      ]
    },
    "065d9ec5d93e37b4bbd6fd27cb411dc58b0fb686": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-6849. Replace HttpFS custom proxyuser handling with common implementation. (tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1617831 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "13/08/14 1:27 PM",
      "commitName": "065d9ec5d93e37b4bbd6fd27cb411dc58b0fb686",
      "commitAuthor": "Alejandro Abdelnur",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-6849. Replace HttpFS custom proxyuser handling with common implementation. (tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1617831 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "13/08/14 1:27 PM",
          "commitName": "065d9ec5d93e37b4bbd6fd27cb411dc58b0fb686",
          "commitAuthor": "Alejandro Abdelnur",
          "commitDateOld": "24/06/14 8:59 AM",
          "commitNameOld": "46162a213f60f915df76c60b0412f45a021e1e7e",
          "commitAuthorOld": "Alejandro Abdelnur",
          "daysBetweenCommits": 50.19,
          "commitsBetweenForRepo": 363,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,122 +1,121 @@\n-  public Response get(@Context Principal user,\n-                      @PathParam(\"path\") String path,\n+  public Response get(@PathParam(\"path\") String path,\n                       @QueryParam(OperationParam.NAME) OperationParam op,\n                       @Context Parameters params)\n     throws IOException, FileSystemAccessException {\n+    UserGroupInformation user \u003d HttpUserGroupInformation.get();\n     Response response;\n     path \u003d makeAbsolute(path);\n     MDC.put(HttpFSFileSystem.OP_PARAM, op.value().name());\n-    String doAs \u003d params.get(DoAsParam.NAME, DoAsParam.class);\n     switch (op.value()) {\n       case OPEN: {\n         //Invoking the command directly using an unmanaged FileSystem that is\n         // released by the FileSystemReleaseFilter\n         FSOperations.FSOpen command \u003d new FSOperations.FSOpen(path);\n-        FileSystem fs \u003d createFileSystem(user, doAs);\n+        FileSystem fs \u003d createFileSystem(user);\n         InputStream is \u003d command.execute(fs);\n         Long offset \u003d params.get(OffsetParam.NAME, OffsetParam.class);\n         Long len \u003d params.get(LenParam.NAME, LenParam.class);\n         AUDIT_LOG.info(\"[{}] offset [{}] len [{}]\",\n                        new Object[]{path, offset, len});\n         InputStreamEntity entity \u003d new InputStreamEntity(is, offset, len);\n         response \u003d\n           Response.ok(entity).type(MediaType.APPLICATION_OCTET_STREAM).build();\n         break;\n       }\n       case GETFILESTATUS: {\n         FSOperations.FSFileStatus command \u003d\n           new FSOperations.FSFileStatus(path);\n-        Map json \u003d fsExecute(user, doAs, command);\n+        Map json \u003d fsExecute(user, command);\n         AUDIT_LOG.info(\"[{}]\", path);\n         response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n         break;\n       }\n       case LISTSTATUS: {\n         String filter \u003d params.get(FilterParam.NAME, FilterParam.class);\n         FSOperations.FSListStatus command \u003d new FSOperations.FSListStatus(\n           path, filter);\n-        Map json \u003d fsExecute(user, doAs, command);\n+        Map json \u003d fsExecute(user, command);\n         AUDIT_LOG.info(\"[{}] filter [{}]\", path,\n                        (filter !\u003d null) ? filter : \"-\");\n         response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n         break;\n       }\n       case GETHOMEDIRECTORY: {\n         enforceRootPath(op.value(), path);\n         FSOperations.FSHomeDir command \u003d new FSOperations.FSHomeDir();\n-        JSONObject json \u003d fsExecute(user, doAs, command);\n+        JSONObject json \u003d fsExecute(user, command);\n         AUDIT_LOG.info(\"\");\n         response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n         break;\n       }\n       case INSTRUMENTATION: {\n         enforceRootPath(op.value(), path);\n         Groups groups \u003d HttpFSServerWebApp.get().get(Groups.class);\n-        List\u003cString\u003e userGroups \u003d groups.getGroups(user.getName());\n+        List\u003cString\u003e userGroups \u003d groups.getGroups(user.getShortUserName());\n         if (!userGroups.contains(HttpFSServerWebApp.get().getAdminGroup())) {\n           throw new AccessControlException(\n             \"User not in HttpFSServer admin group\");\n         }\n         Instrumentation instrumentation \u003d\n           HttpFSServerWebApp.get().get(Instrumentation.class);\n         Map snapshot \u003d instrumentation.getSnapshot();\n         response \u003d Response.ok(snapshot).build();\n         break;\n       }\n       case GETCONTENTSUMMARY: {\n         FSOperations.FSContentSummary command \u003d\n           new FSOperations.FSContentSummary(path);\n-        Map json \u003d fsExecute(user, doAs, command);\n+        Map json \u003d fsExecute(user, command);\n         AUDIT_LOG.info(\"[{}]\", path);\n         response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n         break;\n       }\n       case GETFILECHECKSUM: {\n         FSOperations.FSFileChecksum command \u003d\n           new FSOperations.FSFileChecksum(path);\n-        Map json \u003d fsExecute(user, doAs, command);\n+        Map json \u003d fsExecute(user, command);\n         AUDIT_LOG.info(\"[{}]\", path);\n         response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n         break;\n       }\n       case GETFILEBLOCKLOCATIONS: {\n         response \u003d Response.status(Response.Status.BAD_REQUEST).build();\n         break;\n       }\n       case GETACLSTATUS: {\n         FSOperations.FSAclStatus command \u003d\n                 new FSOperations.FSAclStatus(path);\n-        Map json \u003d fsExecute(user, doAs, command);\n+        Map json \u003d fsExecute(user, command);\n         AUDIT_LOG.info(\"ACL status for [{}]\", path);\n         response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n         break;\n       }\n       case GETXATTRS: {\n         List\u003cString\u003e xattrNames \u003d params.getValues(XAttrNameParam.NAME, \n             XAttrNameParam.class);\n         XAttrCodec encoding \u003d params.get(XAttrEncodingParam.NAME, \n             XAttrEncodingParam.class);\n         FSOperations.FSGetXAttrs command \u003d new FSOperations.FSGetXAttrs(path, \n             xattrNames, encoding);\n         @SuppressWarnings(\"rawtypes\")\n-        Map json \u003d fsExecute(user, doAs, command);\n+        Map json \u003d fsExecute(user, command);\n         AUDIT_LOG.info(\"XAttrs for [{}]\", path);\n         response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n         break;\n       }\n       case LISTXATTRS: {\n         FSOperations.FSListXAttrs command \u003d new FSOperations.FSListXAttrs(path);\n         @SuppressWarnings(\"rawtypes\")\n-        Map json \u003d fsExecute(user, doAs, command);\n+        Map json \u003d fsExecute(user, command);\n         AUDIT_LOG.info(\"XAttr names for [{}]\", path);\n         response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n         break;\n       }\n       default: {\n         throw new IOException(\n           MessageFormat.format(\"Invalid HTTP GET operation [{0}]\",\n                                op.value()));\n       }\n     }\n     return response;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Response get(@PathParam(\"path\") String path,\n                      @QueryParam(OperationParam.NAME) OperationParam op,\n                      @Context Parameters params)\n    throws IOException, FileSystemAccessException {\n    UserGroupInformation user \u003d HttpUserGroupInformation.get();\n    Response response;\n    path \u003d makeAbsolute(path);\n    MDC.put(HttpFSFileSystem.OP_PARAM, op.value().name());\n    switch (op.value()) {\n      case OPEN: {\n        //Invoking the command directly using an unmanaged FileSystem that is\n        // released by the FileSystemReleaseFilter\n        FSOperations.FSOpen command \u003d new FSOperations.FSOpen(path);\n        FileSystem fs \u003d createFileSystem(user);\n        InputStream is \u003d command.execute(fs);\n        Long offset \u003d params.get(OffsetParam.NAME, OffsetParam.class);\n        Long len \u003d params.get(LenParam.NAME, LenParam.class);\n        AUDIT_LOG.info(\"[{}] offset [{}] len [{}]\",\n                       new Object[]{path, offset, len});\n        InputStreamEntity entity \u003d new InputStreamEntity(is, offset, len);\n        response \u003d\n          Response.ok(entity).type(MediaType.APPLICATION_OCTET_STREAM).build();\n        break;\n      }\n      case GETFILESTATUS: {\n        FSOperations.FSFileStatus command \u003d\n          new FSOperations.FSFileStatus(path);\n        Map json \u003d fsExecute(user, command);\n        AUDIT_LOG.info(\"[{}]\", path);\n        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n        break;\n      }\n      case LISTSTATUS: {\n        String filter \u003d params.get(FilterParam.NAME, FilterParam.class);\n        FSOperations.FSListStatus command \u003d new FSOperations.FSListStatus(\n          path, filter);\n        Map json \u003d fsExecute(user, command);\n        AUDIT_LOG.info(\"[{}] filter [{}]\", path,\n                       (filter !\u003d null) ? filter : \"-\");\n        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n        break;\n      }\n      case GETHOMEDIRECTORY: {\n        enforceRootPath(op.value(), path);\n        FSOperations.FSHomeDir command \u003d new FSOperations.FSHomeDir();\n        JSONObject json \u003d fsExecute(user, command);\n        AUDIT_LOG.info(\"\");\n        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n        break;\n      }\n      case INSTRUMENTATION: {\n        enforceRootPath(op.value(), path);\n        Groups groups \u003d HttpFSServerWebApp.get().get(Groups.class);\n        List\u003cString\u003e userGroups \u003d groups.getGroups(user.getShortUserName());\n        if (!userGroups.contains(HttpFSServerWebApp.get().getAdminGroup())) {\n          throw new AccessControlException(\n            \"User not in HttpFSServer admin group\");\n        }\n        Instrumentation instrumentation \u003d\n          HttpFSServerWebApp.get().get(Instrumentation.class);\n        Map snapshot \u003d instrumentation.getSnapshot();\n        response \u003d Response.ok(snapshot).build();\n        break;\n      }\n      case GETCONTENTSUMMARY: {\n        FSOperations.FSContentSummary command \u003d\n          new FSOperations.FSContentSummary(path);\n        Map json \u003d fsExecute(user, command);\n        AUDIT_LOG.info(\"[{}]\", path);\n        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n        break;\n      }\n      case GETFILECHECKSUM: {\n        FSOperations.FSFileChecksum command \u003d\n          new FSOperations.FSFileChecksum(path);\n        Map json \u003d fsExecute(user, command);\n        AUDIT_LOG.info(\"[{}]\", path);\n        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n        break;\n      }\n      case GETFILEBLOCKLOCATIONS: {\n        response \u003d Response.status(Response.Status.BAD_REQUEST).build();\n        break;\n      }\n      case GETACLSTATUS: {\n        FSOperations.FSAclStatus command \u003d\n                new FSOperations.FSAclStatus(path);\n        Map json \u003d fsExecute(user, command);\n        AUDIT_LOG.info(\"ACL status for [{}]\", path);\n        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n        break;\n      }\n      case GETXATTRS: {\n        List\u003cString\u003e xattrNames \u003d params.getValues(XAttrNameParam.NAME, \n            XAttrNameParam.class);\n        XAttrCodec encoding \u003d params.get(XAttrEncodingParam.NAME, \n            XAttrEncodingParam.class);\n        FSOperations.FSGetXAttrs command \u003d new FSOperations.FSGetXAttrs(path, \n            xattrNames, encoding);\n        @SuppressWarnings(\"rawtypes\")\n        Map json \u003d fsExecute(user, command);\n        AUDIT_LOG.info(\"XAttrs for [{}]\", path);\n        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n        break;\n      }\n      case LISTXATTRS: {\n        FSOperations.FSListXAttrs command \u003d new FSOperations.FSListXAttrs(path);\n        @SuppressWarnings(\"rawtypes\")\n        Map json \u003d fsExecute(user, command);\n        AUDIT_LOG.info(\"XAttr names for [{}]\", path);\n        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n        break;\n      }\n      default: {\n        throw new IOException(\n          MessageFormat.format(\"Invalid HTTP GET operation [{0}]\",\n                               op.value()));\n      }\n    }\n    return response;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs-httpfs/src/main/java/org/apache/hadoop/fs/http/server/HttpFSServer.java",
          "extendedDetails": {
            "oldValue": "[user-Principal(annotations-@Context), path-String(annotations-@PathParam(\"path\")), op-OperationParam(annotations-@QueryParam(OperationParam.NAME)), params-Parameters(annotations-@Context)]",
            "newValue": "[path-String(annotations-@PathParam(\"path\")), op-OperationParam(annotations-@QueryParam(OperationParam.NAME)), params-Parameters(annotations-@Context)]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-6849. Replace HttpFS custom proxyuser handling with common implementation. (tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1617831 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "13/08/14 1:27 PM",
          "commitName": "065d9ec5d93e37b4bbd6fd27cb411dc58b0fb686",
          "commitAuthor": "Alejandro Abdelnur",
          "commitDateOld": "24/06/14 8:59 AM",
          "commitNameOld": "46162a213f60f915df76c60b0412f45a021e1e7e",
          "commitAuthorOld": "Alejandro Abdelnur",
          "daysBetweenCommits": 50.19,
          "commitsBetweenForRepo": 363,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,122 +1,121 @@\n-  public Response get(@Context Principal user,\n-                      @PathParam(\"path\") String path,\n+  public Response get(@PathParam(\"path\") String path,\n                       @QueryParam(OperationParam.NAME) OperationParam op,\n                       @Context Parameters params)\n     throws IOException, FileSystemAccessException {\n+    UserGroupInformation user \u003d HttpUserGroupInformation.get();\n     Response response;\n     path \u003d makeAbsolute(path);\n     MDC.put(HttpFSFileSystem.OP_PARAM, op.value().name());\n-    String doAs \u003d params.get(DoAsParam.NAME, DoAsParam.class);\n     switch (op.value()) {\n       case OPEN: {\n         //Invoking the command directly using an unmanaged FileSystem that is\n         // released by the FileSystemReleaseFilter\n         FSOperations.FSOpen command \u003d new FSOperations.FSOpen(path);\n-        FileSystem fs \u003d createFileSystem(user, doAs);\n+        FileSystem fs \u003d createFileSystem(user);\n         InputStream is \u003d command.execute(fs);\n         Long offset \u003d params.get(OffsetParam.NAME, OffsetParam.class);\n         Long len \u003d params.get(LenParam.NAME, LenParam.class);\n         AUDIT_LOG.info(\"[{}] offset [{}] len [{}]\",\n                        new Object[]{path, offset, len});\n         InputStreamEntity entity \u003d new InputStreamEntity(is, offset, len);\n         response \u003d\n           Response.ok(entity).type(MediaType.APPLICATION_OCTET_STREAM).build();\n         break;\n       }\n       case GETFILESTATUS: {\n         FSOperations.FSFileStatus command \u003d\n           new FSOperations.FSFileStatus(path);\n-        Map json \u003d fsExecute(user, doAs, command);\n+        Map json \u003d fsExecute(user, command);\n         AUDIT_LOG.info(\"[{}]\", path);\n         response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n         break;\n       }\n       case LISTSTATUS: {\n         String filter \u003d params.get(FilterParam.NAME, FilterParam.class);\n         FSOperations.FSListStatus command \u003d new FSOperations.FSListStatus(\n           path, filter);\n-        Map json \u003d fsExecute(user, doAs, command);\n+        Map json \u003d fsExecute(user, command);\n         AUDIT_LOG.info(\"[{}] filter [{}]\", path,\n                        (filter !\u003d null) ? filter : \"-\");\n         response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n         break;\n       }\n       case GETHOMEDIRECTORY: {\n         enforceRootPath(op.value(), path);\n         FSOperations.FSHomeDir command \u003d new FSOperations.FSHomeDir();\n-        JSONObject json \u003d fsExecute(user, doAs, command);\n+        JSONObject json \u003d fsExecute(user, command);\n         AUDIT_LOG.info(\"\");\n         response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n         break;\n       }\n       case INSTRUMENTATION: {\n         enforceRootPath(op.value(), path);\n         Groups groups \u003d HttpFSServerWebApp.get().get(Groups.class);\n-        List\u003cString\u003e userGroups \u003d groups.getGroups(user.getName());\n+        List\u003cString\u003e userGroups \u003d groups.getGroups(user.getShortUserName());\n         if (!userGroups.contains(HttpFSServerWebApp.get().getAdminGroup())) {\n           throw new AccessControlException(\n             \"User not in HttpFSServer admin group\");\n         }\n         Instrumentation instrumentation \u003d\n           HttpFSServerWebApp.get().get(Instrumentation.class);\n         Map snapshot \u003d instrumentation.getSnapshot();\n         response \u003d Response.ok(snapshot).build();\n         break;\n       }\n       case GETCONTENTSUMMARY: {\n         FSOperations.FSContentSummary command \u003d\n           new FSOperations.FSContentSummary(path);\n-        Map json \u003d fsExecute(user, doAs, command);\n+        Map json \u003d fsExecute(user, command);\n         AUDIT_LOG.info(\"[{}]\", path);\n         response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n         break;\n       }\n       case GETFILECHECKSUM: {\n         FSOperations.FSFileChecksum command \u003d\n           new FSOperations.FSFileChecksum(path);\n-        Map json \u003d fsExecute(user, doAs, command);\n+        Map json \u003d fsExecute(user, command);\n         AUDIT_LOG.info(\"[{}]\", path);\n         response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n         break;\n       }\n       case GETFILEBLOCKLOCATIONS: {\n         response \u003d Response.status(Response.Status.BAD_REQUEST).build();\n         break;\n       }\n       case GETACLSTATUS: {\n         FSOperations.FSAclStatus command \u003d\n                 new FSOperations.FSAclStatus(path);\n-        Map json \u003d fsExecute(user, doAs, command);\n+        Map json \u003d fsExecute(user, command);\n         AUDIT_LOG.info(\"ACL status for [{}]\", path);\n         response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n         break;\n       }\n       case GETXATTRS: {\n         List\u003cString\u003e xattrNames \u003d params.getValues(XAttrNameParam.NAME, \n             XAttrNameParam.class);\n         XAttrCodec encoding \u003d params.get(XAttrEncodingParam.NAME, \n             XAttrEncodingParam.class);\n         FSOperations.FSGetXAttrs command \u003d new FSOperations.FSGetXAttrs(path, \n             xattrNames, encoding);\n         @SuppressWarnings(\"rawtypes\")\n-        Map json \u003d fsExecute(user, doAs, command);\n+        Map json \u003d fsExecute(user, command);\n         AUDIT_LOG.info(\"XAttrs for [{}]\", path);\n         response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n         break;\n       }\n       case LISTXATTRS: {\n         FSOperations.FSListXAttrs command \u003d new FSOperations.FSListXAttrs(path);\n         @SuppressWarnings(\"rawtypes\")\n-        Map json \u003d fsExecute(user, doAs, command);\n+        Map json \u003d fsExecute(user, command);\n         AUDIT_LOG.info(\"XAttr names for [{}]\", path);\n         response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n         break;\n       }\n       default: {\n         throw new IOException(\n           MessageFormat.format(\"Invalid HTTP GET operation [{0}]\",\n                                op.value()));\n       }\n     }\n     return response;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Response get(@PathParam(\"path\") String path,\n                      @QueryParam(OperationParam.NAME) OperationParam op,\n                      @Context Parameters params)\n    throws IOException, FileSystemAccessException {\n    UserGroupInformation user \u003d HttpUserGroupInformation.get();\n    Response response;\n    path \u003d makeAbsolute(path);\n    MDC.put(HttpFSFileSystem.OP_PARAM, op.value().name());\n    switch (op.value()) {\n      case OPEN: {\n        //Invoking the command directly using an unmanaged FileSystem that is\n        // released by the FileSystemReleaseFilter\n        FSOperations.FSOpen command \u003d new FSOperations.FSOpen(path);\n        FileSystem fs \u003d createFileSystem(user);\n        InputStream is \u003d command.execute(fs);\n        Long offset \u003d params.get(OffsetParam.NAME, OffsetParam.class);\n        Long len \u003d params.get(LenParam.NAME, LenParam.class);\n        AUDIT_LOG.info(\"[{}] offset [{}] len [{}]\",\n                       new Object[]{path, offset, len});\n        InputStreamEntity entity \u003d new InputStreamEntity(is, offset, len);\n        response \u003d\n          Response.ok(entity).type(MediaType.APPLICATION_OCTET_STREAM).build();\n        break;\n      }\n      case GETFILESTATUS: {\n        FSOperations.FSFileStatus command \u003d\n          new FSOperations.FSFileStatus(path);\n        Map json \u003d fsExecute(user, command);\n        AUDIT_LOG.info(\"[{}]\", path);\n        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n        break;\n      }\n      case LISTSTATUS: {\n        String filter \u003d params.get(FilterParam.NAME, FilterParam.class);\n        FSOperations.FSListStatus command \u003d new FSOperations.FSListStatus(\n          path, filter);\n        Map json \u003d fsExecute(user, command);\n        AUDIT_LOG.info(\"[{}] filter [{}]\", path,\n                       (filter !\u003d null) ? filter : \"-\");\n        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n        break;\n      }\n      case GETHOMEDIRECTORY: {\n        enforceRootPath(op.value(), path);\n        FSOperations.FSHomeDir command \u003d new FSOperations.FSHomeDir();\n        JSONObject json \u003d fsExecute(user, command);\n        AUDIT_LOG.info(\"\");\n        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n        break;\n      }\n      case INSTRUMENTATION: {\n        enforceRootPath(op.value(), path);\n        Groups groups \u003d HttpFSServerWebApp.get().get(Groups.class);\n        List\u003cString\u003e userGroups \u003d groups.getGroups(user.getShortUserName());\n        if (!userGroups.contains(HttpFSServerWebApp.get().getAdminGroup())) {\n          throw new AccessControlException(\n            \"User not in HttpFSServer admin group\");\n        }\n        Instrumentation instrumentation \u003d\n          HttpFSServerWebApp.get().get(Instrumentation.class);\n        Map snapshot \u003d instrumentation.getSnapshot();\n        response \u003d Response.ok(snapshot).build();\n        break;\n      }\n      case GETCONTENTSUMMARY: {\n        FSOperations.FSContentSummary command \u003d\n          new FSOperations.FSContentSummary(path);\n        Map json \u003d fsExecute(user, command);\n        AUDIT_LOG.info(\"[{}]\", path);\n        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n        break;\n      }\n      case GETFILECHECKSUM: {\n        FSOperations.FSFileChecksum command \u003d\n          new FSOperations.FSFileChecksum(path);\n        Map json \u003d fsExecute(user, command);\n        AUDIT_LOG.info(\"[{}]\", path);\n        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n        break;\n      }\n      case GETFILEBLOCKLOCATIONS: {\n        response \u003d Response.status(Response.Status.BAD_REQUEST).build();\n        break;\n      }\n      case GETACLSTATUS: {\n        FSOperations.FSAclStatus command \u003d\n                new FSOperations.FSAclStatus(path);\n        Map json \u003d fsExecute(user, command);\n        AUDIT_LOG.info(\"ACL status for [{}]\", path);\n        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n        break;\n      }\n      case GETXATTRS: {\n        List\u003cString\u003e xattrNames \u003d params.getValues(XAttrNameParam.NAME, \n            XAttrNameParam.class);\n        XAttrCodec encoding \u003d params.get(XAttrEncodingParam.NAME, \n            XAttrEncodingParam.class);\n        FSOperations.FSGetXAttrs command \u003d new FSOperations.FSGetXAttrs(path, \n            xattrNames, encoding);\n        @SuppressWarnings(\"rawtypes\")\n        Map json \u003d fsExecute(user, command);\n        AUDIT_LOG.info(\"XAttrs for [{}]\", path);\n        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n        break;\n      }\n      case LISTXATTRS: {\n        FSOperations.FSListXAttrs command \u003d new FSOperations.FSListXAttrs(path);\n        @SuppressWarnings(\"rawtypes\")\n        Map json \u003d fsExecute(user, command);\n        AUDIT_LOG.info(\"XAttr names for [{}]\", path);\n        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n        break;\n      }\n      default: {\n        throw new IOException(\n          MessageFormat.format(\"Invalid HTTP GET operation [{0}]\",\n                               op.value()));\n      }\n    }\n    return response;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs-httpfs/src/main/java/org/apache/hadoop/fs/http/server/HttpFSServer.java",
          "extendedDetails": {}
        }
      ]
    },
    "46162a213f60f915df76c60b0412f45a021e1e7e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6430. HTTPFS - Implement XAttr support. (Yi Liu via tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1605118 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/06/14 8:59 AM",
      "commitName": "46162a213f60f915df76c60b0412f45a021e1e7e",
      "commitAuthor": "Alejandro Abdelnur",
      "commitDateOld": "11/06/14 3:35 PM",
      "commitNameOld": "8bfbec8cfb7fe7c7affef98b17c1a07b81fe27f0",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 12.73,
      "commitsBetweenForRepo": 90,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,101 +1,122 @@\n   public Response get(@Context Principal user,\n                       @PathParam(\"path\") String path,\n                       @QueryParam(OperationParam.NAME) OperationParam op,\n                       @Context Parameters params)\n     throws IOException, FileSystemAccessException {\n     Response response;\n     path \u003d makeAbsolute(path);\n     MDC.put(HttpFSFileSystem.OP_PARAM, op.value().name());\n     String doAs \u003d params.get(DoAsParam.NAME, DoAsParam.class);\n     switch (op.value()) {\n       case OPEN: {\n         //Invoking the command directly using an unmanaged FileSystem that is\n         // released by the FileSystemReleaseFilter\n         FSOperations.FSOpen command \u003d new FSOperations.FSOpen(path);\n         FileSystem fs \u003d createFileSystem(user, doAs);\n         InputStream is \u003d command.execute(fs);\n         Long offset \u003d params.get(OffsetParam.NAME, OffsetParam.class);\n         Long len \u003d params.get(LenParam.NAME, LenParam.class);\n         AUDIT_LOG.info(\"[{}] offset [{}] len [{}]\",\n                        new Object[]{path, offset, len});\n         InputStreamEntity entity \u003d new InputStreamEntity(is, offset, len);\n         response \u003d\n           Response.ok(entity).type(MediaType.APPLICATION_OCTET_STREAM).build();\n         break;\n       }\n       case GETFILESTATUS: {\n         FSOperations.FSFileStatus command \u003d\n           new FSOperations.FSFileStatus(path);\n         Map json \u003d fsExecute(user, doAs, command);\n         AUDIT_LOG.info(\"[{}]\", path);\n         response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n         break;\n       }\n       case LISTSTATUS: {\n         String filter \u003d params.get(FilterParam.NAME, FilterParam.class);\n         FSOperations.FSListStatus command \u003d new FSOperations.FSListStatus(\n           path, filter);\n         Map json \u003d fsExecute(user, doAs, command);\n         AUDIT_LOG.info(\"[{}] filter [{}]\", path,\n                        (filter !\u003d null) ? filter : \"-\");\n         response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n         break;\n       }\n       case GETHOMEDIRECTORY: {\n         enforceRootPath(op.value(), path);\n         FSOperations.FSHomeDir command \u003d new FSOperations.FSHomeDir();\n         JSONObject json \u003d fsExecute(user, doAs, command);\n         AUDIT_LOG.info(\"\");\n         response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n         break;\n       }\n       case INSTRUMENTATION: {\n         enforceRootPath(op.value(), path);\n         Groups groups \u003d HttpFSServerWebApp.get().get(Groups.class);\n         List\u003cString\u003e userGroups \u003d groups.getGroups(user.getName());\n         if (!userGroups.contains(HttpFSServerWebApp.get().getAdminGroup())) {\n           throw new AccessControlException(\n             \"User not in HttpFSServer admin group\");\n         }\n         Instrumentation instrumentation \u003d\n           HttpFSServerWebApp.get().get(Instrumentation.class);\n         Map snapshot \u003d instrumentation.getSnapshot();\n         response \u003d Response.ok(snapshot).build();\n         break;\n       }\n       case GETCONTENTSUMMARY: {\n         FSOperations.FSContentSummary command \u003d\n           new FSOperations.FSContentSummary(path);\n         Map json \u003d fsExecute(user, doAs, command);\n         AUDIT_LOG.info(\"[{}]\", path);\n         response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n         break;\n       }\n       case GETFILECHECKSUM: {\n         FSOperations.FSFileChecksum command \u003d\n           new FSOperations.FSFileChecksum(path);\n         Map json \u003d fsExecute(user, doAs, command);\n         AUDIT_LOG.info(\"[{}]\", path);\n         response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n         break;\n       }\n       case GETFILEBLOCKLOCATIONS: {\n         response \u003d Response.status(Response.Status.BAD_REQUEST).build();\n         break;\n       }\n       case GETACLSTATUS: {\n         FSOperations.FSAclStatus command \u003d\n                 new FSOperations.FSAclStatus(path);\n         Map json \u003d fsExecute(user, doAs, command);\n         AUDIT_LOG.info(\"ACL status for [{}]\", path);\n         response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n         break;\n       }\n+      case GETXATTRS: {\n+        List\u003cString\u003e xattrNames \u003d params.getValues(XAttrNameParam.NAME, \n+            XAttrNameParam.class);\n+        XAttrCodec encoding \u003d params.get(XAttrEncodingParam.NAME, \n+            XAttrEncodingParam.class);\n+        FSOperations.FSGetXAttrs command \u003d new FSOperations.FSGetXAttrs(path, \n+            xattrNames, encoding);\n+        @SuppressWarnings(\"rawtypes\")\n+        Map json \u003d fsExecute(user, doAs, command);\n+        AUDIT_LOG.info(\"XAttrs for [{}]\", path);\n+        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n+        break;\n+      }\n+      case LISTXATTRS: {\n+        FSOperations.FSListXAttrs command \u003d new FSOperations.FSListXAttrs(path);\n+        @SuppressWarnings(\"rawtypes\")\n+        Map json \u003d fsExecute(user, doAs, command);\n+        AUDIT_LOG.info(\"XAttr names for [{}]\", path);\n+        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n+        break;\n+      }\n       default: {\n         throw new IOException(\n           MessageFormat.format(\"Invalid HTTP GET operation [{0}]\",\n                                op.value()));\n       }\n     }\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Response get(@Context Principal user,\n                      @PathParam(\"path\") String path,\n                      @QueryParam(OperationParam.NAME) OperationParam op,\n                      @Context Parameters params)\n    throws IOException, FileSystemAccessException {\n    Response response;\n    path \u003d makeAbsolute(path);\n    MDC.put(HttpFSFileSystem.OP_PARAM, op.value().name());\n    String doAs \u003d params.get(DoAsParam.NAME, DoAsParam.class);\n    switch (op.value()) {\n      case OPEN: {\n        //Invoking the command directly using an unmanaged FileSystem that is\n        // released by the FileSystemReleaseFilter\n        FSOperations.FSOpen command \u003d new FSOperations.FSOpen(path);\n        FileSystem fs \u003d createFileSystem(user, doAs);\n        InputStream is \u003d command.execute(fs);\n        Long offset \u003d params.get(OffsetParam.NAME, OffsetParam.class);\n        Long len \u003d params.get(LenParam.NAME, LenParam.class);\n        AUDIT_LOG.info(\"[{}] offset [{}] len [{}]\",\n                       new Object[]{path, offset, len});\n        InputStreamEntity entity \u003d new InputStreamEntity(is, offset, len);\n        response \u003d\n          Response.ok(entity).type(MediaType.APPLICATION_OCTET_STREAM).build();\n        break;\n      }\n      case GETFILESTATUS: {\n        FSOperations.FSFileStatus command \u003d\n          new FSOperations.FSFileStatus(path);\n        Map json \u003d fsExecute(user, doAs, command);\n        AUDIT_LOG.info(\"[{}]\", path);\n        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n        break;\n      }\n      case LISTSTATUS: {\n        String filter \u003d params.get(FilterParam.NAME, FilterParam.class);\n        FSOperations.FSListStatus command \u003d new FSOperations.FSListStatus(\n          path, filter);\n        Map json \u003d fsExecute(user, doAs, command);\n        AUDIT_LOG.info(\"[{}] filter [{}]\", path,\n                       (filter !\u003d null) ? filter : \"-\");\n        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n        break;\n      }\n      case GETHOMEDIRECTORY: {\n        enforceRootPath(op.value(), path);\n        FSOperations.FSHomeDir command \u003d new FSOperations.FSHomeDir();\n        JSONObject json \u003d fsExecute(user, doAs, command);\n        AUDIT_LOG.info(\"\");\n        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n        break;\n      }\n      case INSTRUMENTATION: {\n        enforceRootPath(op.value(), path);\n        Groups groups \u003d HttpFSServerWebApp.get().get(Groups.class);\n        List\u003cString\u003e userGroups \u003d groups.getGroups(user.getName());\n        if (!userGroups.contains(HttpFSServerWebApp.get().getAdminGroup())) {\n          throw new AccessControlException(\n            \"User not in HttpFSServer admin group\");\n        }\n        Instrumentation instrumentation \u003d\n          HttpFSServerWebApp.get().get(Instrumentation.class);\n        Map snapshot \u003d instrumentation.getSnapshot();\n        response \u003d Response.ok(snapshot).build();\n        break;\n      }\n      case GETCONTENTSUMMARY: {\n        FSOperations.FSContentSummary command \u003d\n          new FSOperations.FSContentSummary(path);\n        Map json \u003d fsExecute(user, doAs, command);\n        AUDIT_LOG.info(\"[{}]\", path);\n        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n        break;\n      }\n      case GETFILECHECKSUM: {\n        FSOperations.FSFileChecksum command \u003d\n          new FSOperations.FSFileChecksum(path);\n        Map json \u003d fsExecute(user, doAs, command);\n        AUDIT_LOG.info(\"[{}]\", path);\n        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n        break;\n      }\n      case GETFILEBLOCKLOCATIONS: {\n        response \u003d Response.status(Response.Status.BAD_REQUEST).build();\n        break;\n      }\n      case GETACLSTATUS: {\n        FSOperations.FSAclStatus command \u003d\n                new FSOperations.FSAclStatus(path);\n        Map json \u003d fsExecute(user, doAs, command);\n        AUDIT_LOG.info(\"ACL status for [{}]\", path);\n        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n        break;\n      }\n      case GETXATTRS: {\n        List\u003cString\u003e xattrNames \u003d params.getValues(XAttrNameParam.NAME, \n            XAttrNameParam.class);\n        XAttrCodec encoding \u003d params.get(XAttrEncodingParam.NAME, \n            XAttrEncodingParam.class);\n        FSOperations.FSGetXAttrs command \u003d new FSOperations.FSGetXAttrs(path, \n            xattrNames, encoding);\n        @SuppressWarnings(\"rawtypes\")\n        Map json \u003d fsExecute(user, doAs, command);\n        AUDIT_LOG.info(\"XAttrs for [{}]\", path);\n        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n        break;\n      }\n      case LISTXATTRS: {\n        FSOperations.FSListXAttrs command \u003d new FSOperations.FSListXAttrs(path);\n        @SuppressWarnings(\"rawtypes\")\n        Map json \u003d fsExecute(user, doAs, command);\n        AUDIT_LOG.info(\"XAttr names for [{}]\", path);\n        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n        break;\n      }\n      default: {\n        throw new IOException(\n          MessageFormat.format(\"Invalid HTTP GET operation [{0}]\",\n                               op.value()));\n      }\n    }\n    return response;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-httpfs/src/main/java/org/apache/hadoop/fs/http/server/HttpFSServer.java",
      "extendedDetails": {}
    },
    "8bfbec8cfb7fe7c7affef98b17c1a07b81fe27f0": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6379. HTTPFS - Implement ACLs support. (yoderme via tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1602040 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/06/14 3:35 PM",
      "commitName": "8bfbec8cfb7fe7c7affef98b17c1a07b81fe27f0",
      "commitAuthor": "Alejandro Abdelnur",
      "commitDateOld": "29/05/13 12:54 PM",
      "commitNameOld": "5b1b197d39f6e65d6de63ecf5e9f6d7f5a13d8a1",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 378.11,
      "commitsBetweenForRepo": 2514,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,93 +1,101 @@\n   public Response get(@Context Principal user,\n                       @PathParam(\"path\") String path,\n                       @QueryParam(OperationParam.NAME) OperationParam op,\n                       @Context Parameters params)\n     throws IOException, FileSystemAccessException {\n     Response response;\n     path \u003d makeAbsolute(path);\n     MDC.put(HttpFSFileSystem.OP_PARAM, op.value().name());\n     String doAs \u003d params.get(DoAsParam.NAME, DoAsParam.class);\n     switch (op.value()) {\n       case OPEN: {\n         //Invoking the command directly using an unmanaged FileSystem that is\n         // released by the FileSystemReleaseFilter\n         FSOperations.FSOpen command \u003d new FSOperations.FSOpen(path);\n         FileSystem fs \u003d createFileSystem(user, doAs);\n         InputStream is \u003d command.execute(fs);\n         Long offset \u003d params.get(OffsetParam.NAME, OffsetParam.class);\n         Long len \u003d params.get(LenParam.NAME, LenParam.class);\n         AUDIT_LOG.info(\"[{}] offset [{}] len [{}]\",\n                        new Object[]{path, offset, len});\n         InputStreamEntity entity \u003d new InputStreamEntity(is, offset, len);\n         response \u003d\n           Response.ok(entity).type(MediaType.APPLICATION_OCTET_STREAM).build();\n         break;\n       }\n       case GETFILESTATUS: {\n         FSOperations.FSFileStatus command \u003d\n           new FSOperations.FSFileStatus(path);\n         Map json \u003d fsExecute(user, doAs, command);\n         AUDIT_LOG.info(\"[{}]\", path);\n         response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n         break;\n       }\n       case LISTSTATUS: {\n         String filter \u003d params.get(FilterParam.NAME, FilterParam.class);\n         FSOperations.FSListStatus command \u003d new FSOperations.FSListStatus(\n           path, filter);\n         Map json \u003d fsExecute(user, doAs, command);\n         AUDIT_LOG.info(\"[{}] filter [{}]\", path,\n                        (filter !\u003d null) ? filter : \"-\");\n         response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n         break;\n       }\n       case GETHOMEDIRECTORY: {\n         enforceRootPath(op.value(), path);\n         FSOperations.FSHomeDir command \u003d new FSOperations.FSHomeDir();\n         JSONObject json \u003d fsExecute(user, doAs, command);\n         AUDIT_LOG.info(\"\");\n         response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n         break;\n       }\n       case INSTRUMENTATION: {\n         enforceRootPath(op.value(), path);\n         Groups groups \u003d HttpFSServerWebApp.get().get(Groups.class);\n         List\u003cString\u003e userGroups \u003d groups.getGroups(user.getName());\n         if (!userGroups.contains(HttpFSServerWebApp.get().getAdminGroup())) {\n           throw new AccessControlException(\n             \"User not in HttpFSServer admin group\");\n         }\n         Instrumentation instrumentation \u003d\n           HttpFSServerWebApp.get().get(Instrumentation.class);\n         Map snapshot \u003d instrumentation.getSnapshot();\n         response \u003d Response.ok(snapshot).build();\n         break;\n       }\n       case GETCONTENTSUMMARY: {\n         FSOperations.FSContentSummary command \u003d\n           new FSOperations.FSContentSummary(path);\n         Map json \u003d fsExecute(user, doAs, command);\n         AUDIT_LOG.info(\"[{}]\", path);\n         response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n         break;\n       }\n       case GETFILECHECKSUM: {\n         FSOperations.FSFileChecksum command \u003d\n           new FSOperations.FSFileChecksum(path);\n         Map json \u003d fsExecute(user, doAs, command);\n         AUDIT_LOG.info(\"[{}]\", path);\n         response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n         break;\n       }\n       case GETFILEBLOCKLOCATIONS: {\n         response \u003d Response.status(Response.Status.BAD_REQUEST).build();\n         break;\n       }\n+      case GETACLSTATUS: {\n+        FSOperations.FSAclStatus command \u003d\n+                new FSOperations.FSAclStatus(path);\n+        Map json \u003d fsExecute(user, doAs, command);\n+        AUDIT_LOG.info(\"ACL status for [{}]\", path);\n+        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n+        break;\n+      }\n       default: {\n         throw new IOException(\n           MessageFormat.format(\"Invalid HTTP GET operation [{0}]\",\n                                op.value()));\n       }\n     }\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Response get(@Context Principal user,\n                      @PathParam(\"path\") String path,\n                      @QueryParam(OperationParam.NAME) OperationParam op,\n                      @Context Parameters params)\n    throws IOException, FileSystemAccessException {\n    Response response;\n    path \u003d makeAbsolute(path);\n    MDC.put(HttpFSFileSystem.OP_PARAM, op.value().name());\n    String doAs \u003d params.get(DoAsParam.NAME, DoAsParam.class);\n    switch (op.value()) {\n      case OPEN: {\n        //Invoking the command directly using an unmanaged FileSystem that is\n        // released by the FileSystemReleaseFilter\n        FSOperations.FSOpen command \u003d new FSOperations.FSOpen(path);\n        FileSystem fs \u003d createFileSystem(user, doAs);\n        InputStream is \u003d command.execute(fs);\n        Long offset \u003d params.get(OffsetParam.NAME, OffsetParam.class);\n        Long len \u003d params.get(LenParam.NAME, LenParam.class);\n        AUDIT_LOG.info(\"[{}] offset [{}] len [{}]\",\n                       new Object[]{path, offset, len});\n        InputStreamEntity entity \u003d new InputStreamEntity(is, offset, len);\n        response \u003d\n          Response.ok(entity).type(MediaType.APPLICATION_OCTET_STREAM).build();\n        break;\n      }\n      case GETFILESTATUS: {\n        FSOperations.FSFileStatus command \u003d\n          new FSOperations.FSFileStatus(path);\n        Map json \u003d fsExecute(user, doAs, command);\n        AUDIT_LOG.info(\"[{}]\", path);\n        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n        break;\n      }\n      case LISTSTATUS: {\n        String filter \u003d params.get(FilterParam.NAME, FilterParam.class);\n        FSOperations.FSListStatus command \u003d new FSOperations.FSListStatus(\n          path, filter);\n        Map json \u003d fsExecute(user, doAs, command);\n        AUDIT_LOG.info(\"[{}] filter [{}]\", path,\n                       (filter !\u003d null) ? filter : \"-\");\n        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n        break;\n      }\n      case GETHOMEDIRECTORY: {\n        enforceRootPath(op.value(), path);\n        FSOperations.FSHomeDir command \u003d new FSOperations.FSHomeDir();\n        JSONObject json \u003d fsExecute(user, doAs, command);\n        AUDIT_LOG.info(\"\");\n        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n        break;\n      }\n      case INSTRUMENTATION: {\n        enforceRootPath(op.value(), path);\n        Groups groups \u003d HttpFSServerWebApp.get().get(Groups.class);\n        List\u003cString\u003e userGroups \u003d groups.getGroups(user.getName());\n        if (!userGroups.contains(HttpFSServerWebApp.get().getAdminGroup())) {\n          throw new AccessControlException(\n            \"User not in HttpFSServer admin group\");\n        }\n        Instrumentation instrumentation \u003d\n          HttpFSServerWebApp.get().get(Instrumentation.class);\n        Map snapshot \u003d instrumentation.getSnapshot();\n        response \u003d Response.ok(snapshot).build();\n        break;\n      }\n      case GETCONTENTSUMMARY: {\n        FSOperations.FSContentSummary command \u003d\n          new FSOperations.FSContentSummary(path);\n        Map json \u003d fsExecute(user, doAs, command);\n        AUDIT_LOG.info(\"[{}]\", path);\n        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n        break;\n      }\n      case GETFILECHECKSUM: {\n        FSOperations.FSFileChecksum command \u003d\n          new FSOperations.FSFileChecksum(path);\n        Map json \u003d fsExecute(user, doAs, command);\n        AUDIT_LOG.info(\"[{}]\", path);\n        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n        break;\n      }\n      case GETFILEBLOCKLOCATIONS: {\n        response \u003d Response.status(Response.Status.BAD_REQUEST).build();\n        break;\n      }\n      case GETACLSTATUS: {\n        FSOperations.FSAclStatus command \u003d\n                new FSOperations.FSAclStatus(path);\n        Map json \u003d fsExecute(user, doAs, command);\n        AUDIT_LOG.info(\"ACL status for [{}]\", path);\n        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n        break;\n      }\n      default: {\n        throw new IOException(\n          MessageFormat.format(\"Invalid HTTP GET operation [{0}]\",\n                               op.value()));\n      }\n    }\n    return response;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-httpfs/src/main/java/org/apache/hadoop/fs/http/server/HttpFSServer.java",
      "extendedDetails": {}
    },
    "d263653ae22217439d1740c936d1c78e1644d73e": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-3481. Refactor HttpFS handling of JAX-RS query string parameters (tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1354599 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/06/12 9:06 AM",
      "commitName": "d263653ae22217439d1740c936d1c78e1644d73e",
      "commitAuthor": "Alejandro Abdelnur",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-3481. Refactor HttpFS handling of JAX-RS query string parameters (tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1354599 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "27/06/12 9:06 AM",
          "commitName": "d263653ae22217439d1740c936d1c78e1644d73e",
          "commitAuthor": "Alejandro Abdelnur",
          "commitDateOld": "24/05/12 9:51 AM",
          "commitNameOld": "e937068c0bc68fc56e5c75ccc6b91fd164acf30d",
          "commitAuthorOld": "Alejandro Abdelnur",
          "daysBetweenCommits": 33.97,
          "commitsBetweenForRepo": 136,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,102 +1,93 @@\n   public Response get(@Context Principal user,\n-                      @PathParam(\"path\") @DefaultValue(\"\") FsPathParam path,\n-                      @QueryParam(GetOpParam.NAME) GetOpParam op,\n-                      @QueryParam(OffsetParam.NAME) @DefaultValue(OffsetParam.DEFAULT) OffsetParam offset,\n-                      @QueryParam(LenParam.NAME) @DefaultValue(LenParam.DEFAULT) LenParam len,\n-                      @QueryParam(FilterParam.NAME) @DefaultValue(FilterParam.DEFAULT) FilterParam filter,\n-                      @QueryParam(DoAsParam.NAME) @DefaultValue(DoAsParam.DEFAULT) DoAsParam doAs,\n-\n-                      //these params are only for createHandle operation acceptance purposes\n-                      @QueryParam(OverwriteParam.NAME) @DefaultValue(OverwriteParam.DEFAULT) OverwriteParam override,\n-                      @QueryParam(BlockSizeParam.NAME) @DefaultValue(BlockSizeParam.DEFAULT) BlockSizeParam blockSize,\n-                      @QueryParam(PermissionParam.NAME) @DefaultValue(PermissionParam.DEFAULT)\n-                      PermissionParam permission,\n-                      @QueryParam(ReplicationParam.NAME) @DefaultValue(ReplicationParam.DEFAULT)\n-                      ReplicationParam replication\n-  )\n+                      @PathParam(\"path\") String path,\n+                      @QueryParam(OperationParam.NAME) OperationParam op,\n+                      @Context Parameters params)\n     throws IOException, FileSystemAccessException {\n-    Response response \u003d null;\n-    if (op \u003d\u003d null) {\n-      throw new UnsupportedOperationException(MessageFormat.format(\"Missing [{0}] parameter\", GetOpParam.NAME));\n-    } else {\n-      path.makeAbsolute();\n-      MDC.put(HttpFSFileSystem.OP_PARAM, op.value().name());\n-      switch (op.value()) {\n-        case OPEN: {\n-          //Invoking the command directly using an unmanaged FileSystem that is released by the\n-          //FileSystemReleaseFilter\n-          FSOperations.FSOpen command \u003d new FSOperations.FSOpen(path.value());\n-          FileSystem fs \u003d createFileSystem(user, doAs.value());\n-          InputStream is \u003d command.execute(fs);\n-          AUDIT_LOG.info(\"[{}] offset [{}] len [{}]\", new Object[]{path, offset, len});\n-          InputStreamEntity entity \u003d new InputStreamEntity(is, offset.value(), len.value());\n-          response \u003d Response.ok(entity).type(MediaType.APPLICATION_OCTET_STREAM).build();\n-          break;\n-        }\n-        case GETFILESTATUS: {\n-          FSOperations.FSFileStatus command \u003d new FSOperations.FSFileStatus(path.value());\n-          Map json \u003d fsExecute(user, doAs.value(), command);\n-          AUDIT_LOG.info(\"[{}]\", path);\n-          response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n-          break;\n-        }\n-        case LISTSTATUS: {\n-          FSOperations.FSListStatus command \u003d new FSOperations.FSListStatus(path.value(), filter.value());\n-          Map json \u003d fsExecute(user, doAs.value(), command);\n-          if (filter.value() \u003d\u003d null) {\n-            AUDIT_LOG.info(\"[{}]\", path);\n-          } else {\n-            AUDIT_LOG.info(\"[{}] filter [{}]\", path, filter.value());\n-          }\n-          response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n-          break;\n-        }\n-        case GETHOMEDIRECTORY: {\n-          FSOperations.FSHomeDir command \u003d new FSOperations.FSHomeDir();\n-          JSONObject json \u003d fsExecute(user, doAs.value(), command);\n-          AUDIT_LOG.info(\"\");\n-          response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n-          break;\n-        }\n-        case INSTRUMENTATION: {\n-          if (!path.value().equals(\"/\")) {\n-            throw new UnsupportedOperationException(\n-              MessageFormat.format(\"Invalid path for {0}\u003d{1}, must be \u0027/\u0027\",\n-                                   GetOpParam.NAME, HttpFSFileSystem.GetOpValues.INSTRUMENTATION));\n-          }\n-          Groups groups \u003d HttpFSServerWebApp.get().get(Groups.class);\n-          List\u003cString\u003e userGroups \u003d groups.getGroups(user.getName());\n-          if (!userGroups.contains(HttpFSServerWebApp.get().getAdminGroup())) {\n-            throw new AccessControlException(\"User not in HttpFSServer admin group\");\n-          }\n-          Instrumentation instrumentation \u003d HttpFSServerWebApp.get().get(Instrumentation.class);\n-          Map snapshot \u003d instrumentation.getSnapshot();\n-          response \u003d Response.ok(snapshot).build();\n-          break;\n-        }\n-        case GETCONTENTSUMMARY: {\n-          FSOperations.FSContentSummary command \u003d new FSOperations.FSContentSummary(path.value());\n-          Map json \u003d fsExecute(user, doAs.value(), command);\n-          AUDIT_LOG.info(\"[{}]\", path);\n-          response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n-          break;\n-        }\n-        case GETFILECHECKSUM: {\n-          FSOperations.FSFileChecksum command \u003d new FSOperations.FSFileChecksum(path.value());\n-          Map json \u003d fsExecute(user, doAs.value(), command);\n-          AUDIT_LOG.info(\"[{}]\", path);\n-          response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n-          break;\n-        }\n-        case GETDELEGATIONTOKEN: {\n-          response \u003d Response.status(Response.Status.BAD_REQUEST).build();\n-          break;\n-        }\n-        case GETFILEBLOCKLOCATIONS: {\n-          response \u003d Response.status(Response.Status.BAD_REQUEST).build();\n-          break;\n-        }\n+    Response response;\n+    path \u003d makeAbsolute(path);\n+    MDC.put(HttpFSFileSystem.OP_PARAM, op.value().name());\n+    String doAs \u003d params.get(DoAsParam.NAME, DoAsParam.class);\n+    switch (op.value()) {\n+      case OPEN: {\n+        //Invoking the command directly using an unmanaged FileSystem that is\n+        // released by the FileSystemReleaseFilter\n+        FSOperations.FSOpen command \u003d new FSOperations.FSOpen(path);\n+        FileSystem fs \u003d createFileSystem(user, doAs);\n+        InputStream is \u003d command.execute(fs);\n+        Long offset \u003d params.get(OffsetParam.NAME, OffsetParam.class);\n+        Long len \u003d params.get(LenParam.NAME, LenParam.class);\n+        AUDIT_LOG.info(\"[{}] offset [{}] len [{}]\",\n+                       new Object[]{path, offset, len});\n+        InputStreamEntity entity \u003d new InputStreamEntity(is, offset, len);\n+        response \u003d\n+          Response.ok(entity).type(MediaType.APPLICATION_OCTET_STREAM).build();\n+        break;\n       }\n-      return response;\n+      case GETFILESTATUS: {\n+        FSOperations.FSFileStatus command \u003d\n+          new FSOperations.FSFileStatus(path);\n+        Map json \u003d fsExecute(user, doAs, command);\n+        AUDIT_LOG.info(\"[{}]\", path);\n+        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n+        break;\n+      }\n+      case LISTSTATUS: {\n+        String filter \u003d params.get(FilterParam.NAME, FilterParam.class);\n+        FSOperations.FSListStatus command \u003d new FSOperations.FSListStatus(\n+          path, filter);\n+        Map json \u003d fsExecute(user, doAs, command);\n+        AUDIT_LOG.info(\"[{}] filter [{}]\", path,\n+                       (filter !\u003d null) ? filter : \"-\");\n+        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n+        break;\n+      }\n+      case GETHOMEDIRECTORY: {\n+        enforceRootPath(op.value(), path);\n+        FSOperations.FSHomeDir command \u003d new FSOperations.FSHomeDir();\n+        JSONObject json \u003d fsExecute(user, doAs, command);\n+        AUDIT_LOG.info(\"\");\n+        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n+        break;\n+      }\n+      case INSTRUMENTATION: {\n+        enforceRootPath(op.value(), path);\n+        Groups groups \u003d HttpFSServerWebApp.get().get(Groups.class);\n+        List\u003cString\u003e userGroups \u003d groups.getGroups(user.getName());\n+        if (!userGroups.contains(HttpFSServerWebApp.get().getAdminGroup())) {\n+          throw new AccessControlException(\n+            \"User not in HttpFSServer admin group\");\n+        }\n+        Instrumentation instrumentation \u003d\n+          HttpFSServerWebApp.get().get(Instrumentation.class);\n+        Map snapshot \u003d instrumentation.getSnapshot();\n+        response \u003d Response.ok(snapshot).build();\n+        break;\n+      }\n+      case GETCONTENTSUMMARY: {\n+        FSOperations.FSContentSummary command \u003d\n+          new FSOperations.FSContentSummary(path);\n+        Map json \u003d fsExecute(user, doAs, command);\n+        AUDIT_LOG.info(\"[{}]\", path);\n+        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n+        break;\n+      }\n+      case GETFILECHECKSUM: {\n+        FSOperations.FSFileChecksum command \u003d\n+          new FSOperations.FSFileChecksum(path);\n+        Map json \u003d fsExecute(user, doAs, command);\n+        AUDIT_LOG.info(\"[{}]\", path);\n+        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n+        break;\n+      }\n+      case GETFILEBLOCKLOCATIONS: {\n+        response \u003d Response.status(Response.Status.BAD_REQUEST).build();\n+        break;\n+      }\n+      default: {\n+        throw new IOException(\n+          MessageFormat.format(\"Invalid HTTP GET operation [{0}]\",\n+                               op.value()));\n+      }\n     }\n+    return response;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Response get(@Context Principal user,\n                      @PathParam(\"path\") String path,\n                      @QueryParam(OperationParam.NAME) OperationParam op,\n                      @Context Parameters params)\n    throws IOException, FileSystemAccessException {\n    Response response;\n    path \u003d makeAbsolute(path);\n    MDC.put(HttpFSFileSystem.OP_PARAM, op.value().name());\n    String doAs \u003d params.get(DoAsParam.NAME, DoAsParam.class);\n    switch (op.value()) {\n      case OPEN: {\n        //Invoking the command directly using an unmanaged FileSystem that is\n        // released by the FileSystemReleaseFilter\n        FSOperations.FSOpen command \u003d new FSOperations.FSOpen(path);\n        FileSystem fs \u003d createFileSystem(user, doAs);\n        InputStream is \u003d command.execute(fs);\n        Long offset \u003d params.get(OffsetParam.NAME, OffsetParam.class);\n        Long len \u003d params.get(LenParam.NAME, LenParam.class);\n        AUDIT_LOG.info(\"[{}] offset [{}] len [{}]\",\n                       new Object[]{path, offset, len});\n        InputStreamEntity entity \u003d new InputStreamEntity(is, offset, len);\n        response \u003d\n          Response.ok(entity).type(MediaType.APPLICATION_OCTET_STREAM).build();\n        break;\n      }\n      case GETFILESTATUS: {\n        FSOperations.FSFileStatus command \u003d\n          new FSOperations.FSFileStatus(path);\n        Map json \u003d fsExecute(user, doAs, command);\n        AUDIT_LOG.info(\"[{}]\", path);\n        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n        break;\n      }\n      case LISTSTATUS: {\n        String filter \u003d params.get(FilterParam.NAME, FilterParam.class);\n        FSOperations.FSListStatus command \u003d new FSOperations.FSListStatus(\n          path, filter);\n        Map json \u003d fsExecute(user, doAs, command);\n        AUDIT_LOG.info(\"[{}] filter [{}]\", path,\n                       (filter !\u003d null) ? filter : \"-\");\n        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n        break;\n      }\n      case GETHOMEDIRECTORY: {\n        enforceRootPath(op.value(), path);\n        FSOperations.FSHomeDir command \u003d new FSOperations.FSHomeDir();\n        JSONObject json \u003d fsExecute(user, doAs, command);\n        AUDIT_LOG.info(\"\");\n        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n        break;\n      }\n      case INSTRUMENTATION: {\n        enforceRootPath(op.value(), path);\n        Groups groups \u003d HttpFSServerWebApp.get().get(Groups.class);\n        List\u003cString\u003e userGroups \u003d groups.getGroups(user.getName());\n        if (!userGroups.contains(HttpFSServerWebApp.get().getAdminGroup())) {\n          throw new AccessControlException(\n            \"User not in HttpFSServer admin group\");\n        }\n        Instrumentation instrumentation \u003d\n          HttpFSServerWebApp.get().get(Instrumentation.class);\n        Map snapshot \u003d instrumentation.getSnapshot();\n        response \u003d Response.ok(snapshot).build();\n        break;\n      }\n      case GETCONTENTSUMMARY: {\n        FSOperations.FSContentSummary command \u003d\n          new FSOperations.FSContentSummary(path);\n        Map json \u003d fsExecute(user, doAs, command);\n        AUDIT_LOG.info(\"[{}]\", path);\n        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n        break;\n      }\n      case GETFILECHECKSUM: {\n        FSOperations.FSFileChecksum command \u003d\n          new FSOperations.FSFileChecksum(path);\n        Map json \u003d fsExecute(user, doAs, command);\n        AUDIT_LOG.info(\"[{}]\", path);\n        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n        break;\n      }\n      case GETFILEBLOCKLOCATIONS: {\n        response \u003d Response.status(Response.Status.BAD_REQUEST).build();\n        break;\n      }\n      default: {\n        throw new IOException(\n          MessageFormat.format(\"Invalid HTTP GET operation [{0}]\",\n                               op.value()));\n      }\n    }\n    return response;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs-httpfs/src/main/java/org/apache/hadoop/fs/http/server/HttpFSServer.java",
          "extendedDetails": {
            "oldValue": "[user-Principal(annotations-@Context), path-FsPathParam(annotations-@PathParam(\"path\")-@DefaultValue(\"\")), op-GetOpParam(annotations-@QueryParam(GetOpParam.NAME)), offset-OffsetParam(annotations-@QueryParam(OffsetParam.NAME)-@DefaultValue(OffsetParam.DEFAULT)), len-LenParam(annotations-@QueryParam(LenParam.NAME)-@DefaultValue(LenParam.DEFAULT)), filter-FilterParam(annotations-@QueryParam(FilterParam.NAME)-@DefaultValue(FilterParam.DEFAULT)), doAs-DoAsParam(annotations-@QueryParam(DoAsParam.NAME)-@DefaultValue(DoAsParam.DEFAULT)), override-OverwriteParam(annotations-@QueryParam(OverwriteParam.NAME)-@DefaultValue(OverwriteParam.DEFAULT)), blockSize-BlockSizeParam(annotations-@QueryParam(BlockSizeParam.NAME)-@DefaultValue(BlockSizeParam.DEFAULT)), permission-PermissionParam(annotations-@QueryParam(PermissionParam.NAME)-@DefaultValue(PermissionParam.DEFAULT)), replication-ReplicationParam(annotations-@QueryParam(ReplicationParam.NAME)-@DefaultValue(ReplicationParam.DEFAULT))]",
            "newValue": "[user-Principal(annotations-@Context), path-String(annotations-@PathParam(\"path\")), op-OperationParam(annotations-@QueryParam(OperationParam.NAME)), params-Parameters(annotations-@Context)]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-3481. Refactor HttpFS handling of JAX-RS query string parameters (tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1354599 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "27/06/12 9:06 AM",
          "commitName": "d263653ae22217439d1740c936d1c78e1644d73e",
          "commitAuthor": "Alejandro Abdelnur",
          "commitDateOld": "24/05/12 9:51 AM",
          "commitNameOld": "e937068c0bc68fc56e5c75ccc6b91fd164acf30d",
          "commitAuthorOld": "Alejandro Abdelnur",
          "daysBetweenCommits": 33.97,
          "commitsBetweenForRepo": 136,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,102 +1,93 @@\n   public Response get(@Context Principal user,\n-                      @PathParam(\"path\") @DefaultValue(\"\") FsPathParam path,\n-                      @QueryParam(GetOpParam.NAME) GetOpParam op,\n-                      @QueryParam(OffsetParam.NAME) @DefaultValue(OffsetParam.DEFAULT) OffsetParam offset,\n-                      @QueryParam(LenParam.NAME) @DefaultValue(LenParam.DEFAULT) LenParam len,\n-                      @QueryParam(FilterParam.NAME) @DefaultValue(FilterParam.DEFAULT) FilterParam filter,\n-                      @QueryParam(DoAsParam.NAME) @DefaultValue(DoAsParam.DEFAULT) DoAsParam doAs,\n-\n-                      //these params are only for createHandle operation acceptance purposes\n-                      @QueryParam(OverwriteParam.NAME) @DefaultValue(OverwriteParam.DEFAULT) OverwriteParam override,\n-                      @QueryParam(BlockSizeParam.NAME) @DefaultValue(BlockSizeParam.DEFAULT) BlockSizeParam blockSize,\n-                      @QueryParam(PermissionParam.NAME) @DefaultValue(PermissionParam.DEFAULT)\n-                      PermissionParam permission,\n-                      @QueryParam(ReplicationParam.NAME) @DefaultValue(ReplicationParam.DEFAULT)\n-                      ReplicationParam replication\n-  )\n+                      @PathParam(\"path\") String path,\n+                      @QueryParam(OperationParam.NAME) OperationParam op,\n+                      @Context Parameters params)\n     throws IOException, FileSystemAccessException {\n-    Response response \u003d null;\n-    if (op \u003d\u003d null) {\n-      throw new UnsupportedOperationException(MessageFormat.format(\"Missing [{0}] parameter\", GetOpParam.NAME));\n-    } else {\n-      path.makeAbsolute();\n-      MDC.put(HttpFSFileSystem.OP_PARAM, op.value().name());\n-      switch (op.value()) {\n-        case OPEN: {\n-          //Invoking the command directly using an unmanaged FileSystem that is released by the\n-          //FileSystemReleaseFilter\n-          FSOperations.FSOpen command \u003d new FSOperations.FSOpen(path.value());\n-          FileSystem fs \u003d createFileSystem(user, doAs.value());\n-          InputStream is \u003d command.execute(fs);\n-          AUDIT_LOG.info(\"[{}] offset [{}] len [{}]\", new Object[]{path, offset, len});\n-          InputStreamEntity entity \u003d new InputStreamEntity(is, offset.value(), len.value());\n-          response \u003d Response.ok(entity).type(MediaType.APPLICATION_OCTET_STREAM).build();\n-          break;\n-        }\n-        case GETFILESTATUS: {\n-          FSOperations.FSFileStatus command \u003d new FSOperations.FSFileStatus(path.value());\n-          Map json \u003d fsExecute(user, doAs.value(), command);\n-          AUDIT_LOG.info(\"[{}]\", path);\n-          response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n-          break;\n-        }\n-        case LISTSTATUS: {\n-          FSOperations.FSListStatus command \u003d new FSOperations.FSListStatus(path.value(), filter.value());\n-          Map json \u003d fsExecute(user, doAs.value(), command);\n-          if (filter.value() \u003d\u003d null) {\n-            AUDIT_LOG.info(\"[{}]\", path);\n-          } else {\n-            AUDIT_LOG.info(\"[{}] filter [{}]\", path, filter.value());\n-          }\n-          response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n-          break;\n-        }\n-        case GETHOMEDIRECTORY: {\n-          FSOperations.FSHomeDir command \u003d new FSOperations.FSHomeDir();\n-          JSONObject json \u003d fsExecute(user, doAs.value(), command);\n-          AUDIT_LOG.info(\"\");\n-          response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n-          break;\n-        }\n-        case INSTRUMENTATION: {\n-          if (!path.value().equals(\"/\")) {\n-            throw new UnsupportedOperationException(\n-              MessageFormat.format(\"Invalid path for {0}\u003d{1}, must be \u0027/\u0027\",\n-                                   GetOpParam.NAME, HttpFSFileSystem.GetOpValues.INSTRUMENTATION));\n-          }\n-          Groups groups \u003d HttpFSServerWebApp.get().get(Groups.class);\n-          List\u003cString\u003e userGroups \u003d groups.getGroups(user.getName());\n-          if (!userGroups.contains(HttpFSServerWebApp.get().getAdminGroup())) {\n-            throw new AccessControlException(\"User not in HttpFSServer admin group\");\n-          }\n-          Instrumentation instrumentation \u003d HttpFSServerWebApp.get().get(Instrumentation.class);\n-          Map snapshot \u003d instrumentation.getSnapshot();\n-          response \u003d Response.ok(snapshot).build();\n-          break;\n-        }\n-        case GETCONTENTSUMMARY: {\n-          FSOperations.FSContentSummary command \u003d new FSOperations.FSContentSummary(path.value());\n-          Map json \u003d fsExecute(user, doAs.value(), command);\n-          AUDIT_LOG.info(\"[{}]\", path);\n-          response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n-          break;\n-        }\n-        case GETFILECHECKSUM: {\n-          FSOperations.FSFileChecksum command \u003d new FSOperations.FSFileChecksum(path.value());\n-          Map json \u003d fsExecute(user, doAs.value(), command);\n-          AUDIT_LOG.info(\"[{}]\", path);\n-          response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n-          break;\n-        }\n-        case GETDELEGATIONTOKEN: {\n-          response \u003d Response.status(Response.Status.BAD_REQUEST).build();\n-          break;\n-        }\n-        case GETFILEBLOCKLOCATIONS: {\n-          response \u003d Response.status(Response.Status.BAD_REQUEST).build();\n-          break;\n-        }\n+    Response response;\n+    path \u003d makeAbsolute(path);\n+    MDC.put(HttpFSFileSystem.OP_PARAM, op.value().name());\n+    String doAs \u003d params.get(DoAsParam.NAME, DoAsParam.class);\n+    switch (op.value()) {\n+      case OPEN: {\n+        //Invoking the command directly using an unmanaged FileSystem that is\n+        // released by the FileSystemReleaseFilter\n+        FSOperations.FSOpen command \u003d new FSOperations.FSOpen(path);\n+        FileSystem fs \u003d createFileSystem(user, doAs);\n+        InputStream is \u003d command.execute(fs);\n+        Long offset \u003d params.get(OffsetParam.NAME, OffsetParam.class);\n+        Long len \u003d params.get(LenParam.NAME, LenParam.class);\n+        AUDIT_LOG.info(\"[{}] offset [{}] len [{}]\",\n+                       new Object[]{path, offset, len});\n+        InputStreamEntity entity \u003d new InputStreamEntity(is, offset, len);\n+        response \u003d\n+          Response.ok(entity).type(MediaType.APPLICATION_OCTET_STREAM).build();\n+        break;\n       }\n-      return response;\n+      case GETFILESTATUS: {\n+        FSOperations.FSFileStatus command \u003d\n+          new FSOperations.FSFileStatus(path);\n+        Map json \u003d fsExecute(user, doAs, command);\n+        AUDIT_LOG.info(\"[{}]\", path);\n+        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n+        break;\n+      }\n+      case LISTSTATUS: {\n+        String filter \u003d params.get(FilterParam.NAME, FilterParam.class);\n+        FSOperations.FSListStatus command \u003d new FSOperations.FSListStatus(\n+          path, filter);\n+        Map json \u003d fsExecute(user, doAs, command);\n+        AUDIT_LOG.info(\"[{}] filter [{}]\", path,\n+                       (filter !\u003d null) ? filter : \"-\");\n+        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n+        break;\n+      }\n+      case GETHOMEDIRECTORY: {\n+        enforceRootPath(op.value(), path);\n+        FSOperations.FSHomeDir command \u003d new FSOperations.FSHomeDir();\n+        JSONObject json \u003d fsExecute(user, doAs, command);\n+        AUDIT_LOG.info(\"\");\n+        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n+        break;\n+      }\n+      case INSTRUMENTATION: {\n+        enforceRootPath(op.value(), path);\n+        Groups groups \u003d HttpFSServerWebApp.get().get(Groups.class);\n+        List\u003cString\u003e userGroups \u003d groups.getGroups(user.getName());\n+        if (!userGroups.contains(HttpFSServerWebApp.get().getAdminGroup())) {\n+          throw new AccessControlException(\n+            \"User not in HttpFSServer admin group\");\n+        }\n+        Instrumentation instrumentation \u003d\n+          HttpFSServerWebApp.get().get(Instrumentation.class);\n+        Map snapshot \u003d instrumentation.getSnapshot();\n+        response \u003d Response.ok(snapshot).build();\n+        break;\n+      }\n+      case GETCONTENTSUMMARY: {\n+        FSOperations.FSContentSummary command \u003d\n+          new FSOperations.FSContentSummary(path);\n+        Map json \u003d fsExecute(user, doAs, command);\n+        AUDIT_LOG.info(\"[{}]\", path);\n+        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n+        break;\n+      }\n+      case GETFILECHECKSUM: {\n+        FSOperations.FSFileChecksum command \u003d\n+          new FSOperations.FSFileChecksum(path);\n+        Map json \u003d fsExecute(user, doAs, command);\n+        AUDIT_LOG.info(\"[{}]\", path);\n+        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n+        break;\n+      }\n+      case GETFILEBLOCKLOCATIONS: {\n+        response \u003d Response.status(Response.Status.BAD_REQUEST).build();\n+        break;\n+      }\n+      default: {\n+        throw new IOException(\n+          MessageFormat.format(\"Invalid HTTP GET operation [{0}]\",\n+                               op.value()));\n+      }\n     }\n+    return response;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Response get(@Context Principal user,\n                      @PathParam(\"path\") String path,\n                      @QueryParam(OperationParam.NAME) OperationParam op,\n                      @Context Parameters params)\n    throws IOException, FileSystemAccessException {\n    Response response;\n    path \u003d makeAbsolute(path);\n    MDC.put(HttpFSFileSystem.OP_PARAM, op.value().name());\n    String doAs \u003d params.get(DoAsParam.NAME, DoAsParam.class);\n    switch (op.value()) {\n      case OPEN: {\n        //Invoking the command directly using an unmanaged FileSystem that is\n        // released by the FileSystemReleaseFilter\n        FSOperations.FSOpen command \u003d new FSOperations.FSOpen(path);\n        FileSystem fs \u003d createFileSystem(user, doAs);\n        InputStream is \u003d command.execute(fs);\n        Long offset \u003d params.get(OffsetParam.NAME, OffsetParam.class);\n        Long len \u003d params.get(LenParam.NAME, LenParam.class);\n        AUDIT_LOG.info(\"[{}] offset [{}] len [{}]\",\n                       new Object[]{path, offset, len});\n        InputStreamEntity entity \u003d new InputStreamEntity(is, offset, len);\n        response \u003d\n          Response.ok(entity).type(MediaType.APPLICATION_OCTET_STREAM).build();\n        break;\n      }\n      case GETFILESTATUS: {\n        FSOperations.FSFileStatus command \u003d\n          new FSOperations.FSFileStatus(path);\n        Map json \u003d fsExecute(user, doAs, command);\n        AUDIT_LOG.info(\"[{}]\", path);\n        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n        break;\n      }\n      case LISTSTATUS: {\n        String filter \u003d params.get(FilterParam.NAME, FilterParam.class);\n        FSOperations.FSListStatus command \u003d new FSOperations.FSListStatus(\n          path, filter);\n        Map json \u003d fsExecute(user, doAs, command);\n        AUDIT_LOG.info(\"[{}] filter [{}]\", path,\n                       (filter !\u003d null) ? filter : \"-\");\n        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n        break;\n      }\n      case GETHOMEDIRECTORY: {\n        enforceRootPath(op.value(), path);\n        FSOperations.FSHomeDir command \u003d new FSOperations.FSHomeDir();\n        JSONObject json \u003d fsExecute(user, doAs, command);\n        AUDIT_LOG.info(\"\");\n        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n        break;\n      }\n      case INSTRUMENTATION: {\n        enforceRootPath(op.value(), path);\n        Groups groups \u003d HttpFSServerWebApp.get().get(Groups.class);\n        List\u003cString\u003e userGroups \u003d groups.getGroups(user.getName());\n        if (!userGroups.contains(HttpFSServerWebApp.get().getAdminGroup())) {\n          throw new AccessControlException(\n            \"User not in HttpFSServer admin group\");\n        }\n        Instrumentation instrumentation \u003d\n          HttpFSServerWebApp.get().get(Instrumentation.class);\n        Map snapshot \u003d instrumentation.getSnapshot();\n        response \u003d Response.ok(snapshot).build();\n        break;\n      }\n      case GETCONTENTSUMMARY: {\n        FSOperations.FSContentSummary command \u003d\n          new FSOperations.FSContentSummary(path);\n        Map json \u003d fsExecute(user, doAs, command);\n        AUDIT_LOG.info(\"[{}]\", path);\n        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n        break;\n      }\n      case GETFILECHECKSUM: {\n        FSOperations.FSFileChecksum command \u003d\n          new FSOperations.FSFileChecksum(path);\n        Map json \u003d fsExecute(user, doAs, command);\n        AUDIT_LOG.info(\"[{}]\", path);\n        response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n        break;\n      }\n      case GETFILEBLOCKLOCATIONS: {\n        response \u003d Response.status(Response.Status.BAD_REQUEST).build();\n        break;\n      }\n      default: {\n        throw new IOException(\n          MessageFormat.format(\"Invalid HTTP GET operation [{0}]\",\n                               op.value()));\n      }\n    }\n    return response;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs-httpfs/src/main/java/org/apache/hadoop/fs/http/server/HttpFSServer.java",
          "extendedDetails": {}
        }
      ]
    },
    "f4711ef3ab4bb9676303d0aff79ff3d004f239ff": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3314. HttpFS operation for getHomeDirectory is incorrect. (tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1329715 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/04/12 6:46 AM",
      "commitName": "f4711ef3ab4bb9676303d0aff79ff3d004f239ff",
      "commitAuthor": "Alejandro Abdelnur",
      "commitDateOld": "18/04/12 11:51 AM",
      "commitNameOld": "8bda086d046b12e8efed834f39a775e710ca0962",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 5.79,
      "commitsBetweenForRepo": 32,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,102 +1,102 @@\n   public Response get(@Context Principal user,\n                       @PathParam(\"path\") @DefaultValue(\"\") FsPathParam path,\n                       @QueryParam(GetOpParam.NAME) GetOpParam op,\n                       @QueryParam(OffsetParam.NAME) @DefaultValue(OffsetParam.DEFAULT) OffsetParam offset,\n                       @QueryParam(LenParam.NAME) @DefaultValue(LenParam.DEFAULT) LenParam len,\n                       @QueryParam(FilterParam.NAME) @DefaultValue(FilterParam.DEFAULT) FilterParam filter,\n                       @QueryParam(DoAsParam.NAME) @DefaultValue(DoAsParam.DEFAULT) DoAsParam doAs,\n \n                       //these params are only for createHandle operation acceptance purposes\n                       @QueryParam(OverwriteParam.NAME) @DefaultValue(OverwriteParam.DEFAULT) OverwriteParam override,\n                       @QueryParam(BlockSizeParam.NAME) @DefaultValue(BlockSizeParam.DEFAULT) BlockSizeParam blockSize,\n                       @QueryParam(PermissionParam.NAME) @DefaultValue(PermissionParam.DEFAULT)\n                       PermissionParam permission,\n                       @QueryParam(ReplicationParam.NAME) @DefaultValue(ReplicationParam.DEFAULT)\n                       ReplicationParam replication\n   )\n     throws IOException, FileSystemAccessException {\n     Response response \u003d null;\n     if (op \u003d\u003d null) {\n       throw new UnsupportedOperationException(MessageFormat.format(\"Missing [{0}] parameter\", GetOpParam.NAME));\n     } else {\n       path.makeAbsolute();\n       MDC.put(HttpFSFileSystem.OP_PARAM, op.value().name());\n       switch (op.value()) {\n         case OPEN: {\n           //Invoking the command directly using an unmanaged FileSystem that is released by the\n           //FileSystemReleaseFilter\n           FSOperations.FSOpen command \u003d new FSOperations.FSOpen(path.value());\n           FileSystem fs \u003d createFileSystem(user, doAs.value());\n           InputStream is \u003d command.execute(fs);\n           AUDIT_LOG.info(\"[{}] offset [{}] len [{}]\", new Object[]{path, offset, len});\n           InputStreamEntity entity \u003d new InputStreamEntity(is, offset.value(), len.value());\n           response \u003d Response.ok(entity).type(MediaType.APPLICATION_OCTET_STREAM).build();\n           break;\n         }\n         case GETFILESTATUS: {\n           FSOperations.FSFileStatus command \u003d new FSOperations.FSFileStatus(path.value());\n           Map json \u003d fsExecute(user, doAs.value(), command);\n           AUDIT_LOG.info(\"[{}]\", path);\n           response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n           break;\n         }\n         case LISTSTATUS: {\n           FSOperations.FSListStatus command \u003d new FSOperations.FSListStatus(path.value(), filter.value());\n           Map json \u003d fsExecute(user, doAs.value(), command);\n           if (filter.value() \u003d\u003d null) {\n             AUDIT_LOG.info(\"[{}]\", path);\n           } else {\n             AUDIT_LOG.info(\"[{}] filter [{}]\", path, filter.value());\n           }\n           response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n           break;\n         }\n-        case GETHOMEDIR: {\n+        case GETHOMEDIRECTORY: {\n           FSOperations.FSHomeDir command \u003d new FSOperations.FSHomeDir();\n           JSONObject json \u003d fsExecute(user, doAs.value(), command);\n           AUDIT_LOG.info(\"\");\n           response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n           break;\n         }\n         case INSTRUMENTATION: {\n           if (!path.value().equals(\"/\")) {\n             throw new UnsupportedOperationException(\n               MessageFormat.format(\"Invalid path for {0}\u003d{1}, must be \u0027/\u0027\",\n                                    GetOpParam.NAME, HttpFSFileSystem.GetOpValues.INSTRUMENTATION));\n           }\n           Groups groups \u003d HttpFSServerWebApp.get().get(Groups.class);\n           List\u003cString\u003e userGroups \u003d groups.getGroups(user.getName());\n           if (!userGroups.contains(HttpFSServerWebApp.get().getAdminGroup())) {\n             throw new AccessControlException(\"User not in HttpFSServer admin group\");\n           }\n           Instrumentation instrumentation \u003d HttpFSServerWebApp.get().get(Instrumentation.class);\n           Map snapshot \u003d instrumentation.getSnapshot();\n           response \u003d Response.ok(snapshot).build();\n           break;\n         }\n         case GETCONTENTSUMMARY: {\n           FSOperations.FSContentSummary command \u003d new FSOperations.FSContentSummary(path.value());\n           Map json \u003d fsExecute(user, doAs.value(), command);\n           AUDIT_LOG.info(\"[{}]\", path);\n           response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n           break;\n         }\n         case GETFILECHECKSUM: {\n           FSOperations.FSFileChecksum command \u003d new FSOperations.FSFileChecksum(path.value());\n           Map json \u003d fsExecute(user, doAs.value(), command);\n           AUDIT_LOG.info(\"[{}]\", path);\n           response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n           break;\n         }\n         case GETDELEGATIONTOKEN: {\n           response \u003d Response.status(Response.Status.BAD_REQUEST).build();\n           break;\n         }\n         case GETFILEBLOCKLOCATIONS: {\n           response \u003d Response.status(Response.Status.BAD_REQUEST).build();\n           break;\n         }\n       }\n       return response;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Response get(@Context Principal user,\n                      @PathParam(\"path\") @DefaultValue(\"\") FsPathParam path,\n                      @QueryParam(GetOpParam.NAME) GetOpParam op,\n                      @QueryParam(OffsetParam.NAME) @DefaultValue(OffsetParam.DEFAULT) OffsetParam offset,\n                      @QueryParam(LenParam.NAME) @DefaultValue(LenParam.DEFAULT) LenParam len,\n                      @QueryParam(FilterParam.NAME) @DefaultValue(FilterParam.DEFAULT) FilterParam filter,\n                      @QueryParam(DoAsParam.NAME) @DefaultValue(DoAsParam.DEFAULT) DoAsParam doAs,\n\n                      //these params are only for createHandle operation acceptance purposes\n                      @QueryParam(OverwriteParam.NAME) @DefaultValue(OverwriteParam.DEFAULT) OverwriteParam override,\n                      @QueryParam(BlockSizeParam.NAME) @DefaultValue(BlockSizeParam.DEFAULT) BlockSizeParam blockSize,\n                      @QueryParam(PermissionParam.NAME) @DefaultValue(PermissionParam.DEFAULT)\n                      PermissionParam permission,\n                      @QueryParam(ReplicationParam.NAME) @DefaultValue(ReplicationParam.DEFAULT)\n                      ReplicationParam replication\n  )\n    throws IOException, FileSystemAccessException {\n    Response response \u003d null;\n    if (op \u003d\u003d null) {\n      throw new UnsupportedOperationException(MessageFormat.format(\"Missing [{0}] parameter\", GetOpParam.NAME));\n    } else {\n      path.makeAbsolute();\n      MDC.put(HttpFSFileSystem.OP_PARAM, op.value().name());\n      switch (op.value()) {\n        case OPEN: {\n          //Invoking the command directly using an unmanaged FileSystem that is released by the\n          //FileSystemReleaseFilter\n          FSOperations.FSOpen command \u003d new FSOperations.FSOpen(path.value());\n          FileSystem fs \u003d createFileSystem(user, doAs.value());\n          InputStream is \u003d command.execute(fs);\n          AUDIT_LOG.info(\"[{}] offset [{}] len [{}]\", new Object[]{path, offset, len});\n          InputStreamEntity entity \u003d new InputStreamEntity(is, offset.value(), len.value());\n          response \u003d Response.ok(entity).type(MediaType.APPLICATION_OCTET_STREAM).build();\n          break;\n        }\n        case GETFILESTATUS: {\n          FSOperations.FSFileStatus command \u003d new FSOperations.FSFileStatus(path.value());\n          Map json \u003d fsExecute(user, doAs.value(), command);\n          AUDIT_LOG.info(\"[{}]\", path);\n          response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n          break;\n        }\n        case LISTSTATUS: {\n          FSOperations.FSListStatus command \u003d new FSOperations.FSListStatus(path.value(), filter.value());\n          Map json \u003d fsExecute(user, doAs.value(), command);\n          if (filter.value() \u003d\u003d null) {\n            AUDIT_LOG.info(\"[{}]\", path);\n          } else {\n            AUDIT_LOG.info(\"[{}] filter [{}]\", path, filter.value());\n          }\n          response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n          break;\n        }\n        case GETHOMEDIRECTORY: {\n          FSOperations.FSHomeDir command \u003d new FSOperations.FSHomeDir();\n          JSONObject json \u003d fsExecute(user, doAs.value(), command);\n          AUDIT_LOG.info(\"\");\n          response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n          break;\n        }\n        case INSTRUMENTATION: {\n          if (!path.value().equals(\"/\")) {\n            throw new UnsupportedOperationException(\n              MessageFormat.format(\"Invalid path for {0}\u003d{1}, must be \u0027/\u0027\",\n                                   GetOpParam.NAME, HttpFSFileSystem.GetOpValues.INSTRUMENTATION));\n          }\n          Groups groups \u003d HttpFSServerWebApp.get().get(Groups.class);\n          List\u003cString\u003e userGroups \u003d groups.getGroups(user.getName());\n          if (!userGroups.contains(HttpFSServerWebApp.get().getAdminGroup())) {\n            throw new AccessControlException(\"User not in HttpFSServer admin group\");\n          }\n          Instrumentation instrumentation \u003d HttpFSServerWebApp.get().get(Instrumentation.class);\n          Map snapshot \u003d instrumentation.getSnapshot();\n          response \u003d Response.ok(snapshot).build();\n          break;\n        }\n        case GETCONTENTSUMMARY: {\n          FSOperations.FSContentSummary command \u003d new FSOperations.FSContentSummary(path.value());\n          Map json \u003d fsExecute(user, doAs.value(), command);\n          AUDIT_LOG.info(\"[{}]\", path);\n          response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n          break;\n        }\n        case GETFILECHECKSUM: {\n          FSOperations.FSFileChecksum command \u003d new FSOperations.FSFileChecksum(path.value());\n          Map json \u003d fsExecute(user, doAs.value(), command);\n          AUDIT_LOG.info(\"[{}]\", path);\n          response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n          break;\n        }\n        case GETDELEGATIONTOKEN: {\n          response \u003d Response.status(Response.Status.BAD_REQUEST).build();\n          break;\n        }\n        case GETFILEBLOCKLOCATIONS: {\n          response \u003d Response.status(Response.Status.BAD_REQUEST).build();\n          break;\n        }\n      }\n      return response;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-httpfs/src/main/java/org/apache/hadoop/fs/http/server/HttpFSServer.java",
      "extendedDetails": {}
    },
    "3334306512b5dc932814fded31a89ba1ee97cd9f": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-2178. Contributing Hoop to HDFS, replacement for HDFS proxy with read/write capabilities. (tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1212060 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/12/11 11:25 AM",
      "commitName": "3334306512b5dc932814fded31a89ba1ee97cd9f",
      "commitAuthor": "Alejandro Abdelnur",
      "diff": "@@ -0,0 +1,102 @@\n+  public Response get(@Context Principal user,\n+                      @PathParam(\"path\") @DefaultValue(\"\") FsPathParam path,\n+                      @QueryParam(GetOpParam.NAME) GetOpParam op,\n+                      @QueryParam(OffsetParam.NAME) @DefaultValue(OffsetParam.DEFAULT) OffsetParam offset,\n+                      @QueryParam(LenParam.NAME) @DefaultValue(LenParam.DEFAULT) LenParam len,\n+                      @QueryParam(FilterParam.NAME) @DefaultValue(FilterParam.DEFAULT) FilterParam filter,\n+                      @QueryParam(DoAsParam.NAME) @DefaultValue(DoAsParam.DEFAULT) DoAsParam doAs,\n+\n+                      //these params are only for createHandle operation acceptance purposes\n+                      @QueryParam(OverwriteParam.NAME) @DefaultValue(OverwriteParam.DEFAULT) OverwriteParam override,\n+                      @QueryParam(BlockSizeParam.NAME) @DefaultValue(BlockSizeParam.DEFAULT) BlockSizeParam blockSize,\n+                      @QueryParam(PermissionParam.NAME) @DefaultValue(PermissionParam.DEFAULT)\n+                      PermissionParam permission,\n+                      @QueryParam(ReplicationParam.NAME) @DefaultValue(ReplicationParam.DEFAULT)\n+                      ReplicationParam replication\n+  )\n+    throws IOException, FileSystemAccessException {\n+    Response response \u003d null;\n+    if (op \u003d\u003d null) {\n+      throw new UnsupportedOperationException(MessageFormat.format(\"Missing [{0}] parameter\", GetOpParam.NAME));\n+    } else {\n+      path.makeAbsolute();\n+      MDC.put(HttpFSFileSystem.OP_PARAM, op.value().name());\n+      switch (op.value()) {\n+        case OPEN: {\n+          //Invoking the command directly using an unmanaged FileSystem that is released by the\n+          //FileSystemReleaseFilter\n+          FSOperations.FSOpen command \u003d new FSOperations.FSOpen(path.value());\n+          FileSystem fs \u003d createFileSystem(user, doAs.value());\n+          InputStream is \u003d command.execute(fs);\n+          AUDIT_LOG.info(\"[{}] offset [{}] len [{}]\", new Object[]{path, offset, len});\n+          InputStreamEntity entity \u003d new InputStreamEntity(is, offset.value(), len.value());\n+          response \u003d Response.ok(entity).type(MediaType.APPLICATION_OCTET_STREAM).build();\n+          break;\n+        }\n+        case GETFILESTATUS: {\n+          FSOperations.FSFileStatus command \u003d new FSOperations.FSFileStatus(path.value());\n+          Map json \u003d fsExecute(user, doAs.value(), command);\n+          AUDIT_LOG.info(\"[{}]\", path);\n+          response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n+          break;\n+        }\n+        case LISTSTATUS: {\n+          FSOperations.FSListStatus command \u003d new FSOperations.FSListStatus(path.value(), filter.value());\n+          Map json \u003d fsExecute(user, doAs.value(), command);\n+          if (filter.value() \u003d\u003d null) {\n+            AUDIT_LOG.info(\"[{}]\", path);\n+          } else {\n+            AUDIT_LOG.info(\"[{}] filter [{}]\", path, filter.value());\n+          }\n+          response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n+          break;\n+        }\n+        case GETHOMEDIR: {\n+          FSOperations.FSHomeDir command \u003d new FSOperations.FSHomeDir();\n+          JSONObject json \u003d fsExecute(user, doAs.value(), command);\n+          AUDIT_LOG.info(\"\");\n+          response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n+          break;\n+        }\n+        case INSTRUMENTATION: {\n+          if (!path.value().equals(\"/\")) {\n+            throw new UnsupportedOperationException(\n+              MessageFormat.format(\"Invalid path for {0}\u003d{1}, must be \u0027/\u0027\",\n+                                   GetOpParam.NAME, HttpFSFileSystem.GetOpValues.INSTRUMENTATION));\n+          }\n+          Groups groups \u003d HttpFSServerWebApp.get().get(Groups.class);\n+          List\u003cString\u003e userGroups \u003d groups.getGroups(user.getName());\n+          if (!userGroups.contains(HttpFSServerWebApp.get().getAdminGroup())) {\n+            throw new AccessControlException(\"User not in HttpFSServer admin group\");\n+          }\n+          Instrumentation instrumentation \u003d HttpFSServerWebApp.get().get(Instrumentation.class);\n+          Map snapshot \u003d instrumentation.getSnapshot();\n+          response \u003d Response.ok(snapshot).build();\n+          break;\n+        }\n+        case GETCONTENTSUMMARY: {\n+          FSOperations.FSContentSummary command \u003d new FSOperations.FSContentSummary(path.value());\n+          Map json \u003d fsExecute(user, doAs.value(), command);\n+          AUDIT_LOG.info(\"[{}]\", path);\n+          response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n+          break;\n+        }\n+        case GETFILECHECKSUM: {\n+          FSOperations.FSFileChecksum command \u003d new FSOperations.FSFileChecksum(path.value());\n+          Map json \u003d fsExecute(user, doAs.value(), command);\n+          AUDIT_LOG.info(\"[{}]\", path);\n+          response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n+          break;\n+        }\n+        case GETDELEGATIONTOKEN: {\n+          response \u003d Response.status(Response.Status.BAD_REQUEST).build();\n+          break;\n+        }\n+        case GETFILEBLOCKLOCATIONS: {\n+          response \u003d Response.status(Response.Status.BAD_REQUEST).build();\n+          break;\n+        }\n+      }\n+      return response;\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public Response get(@Context Principal user,\n                      @PathParam(\"path\") @DefaultValue(\"\") FsPathParam path,\n                      @QueryParam(GetOpParam.NAME) GetOpParam op,\n                      @QueryParam(OffsetParam.NAME) @DefaultValue(OffsetParam.DEFAULT) OffsetParam offset,\n                      @QueryParam(LenParam.NAME) @DefaultValue(LenParam.DEFAULT) LenParam len,\n                      @QueryParam(FilterParam.NAME) @DefaultValue(FilterParam.DEFAULT) FilterParam filter,\n                      @QueryParam(DoAsParam.NAME) @DefaultValue(DoAsParam.DEFAULT) DoAsParam doAs,\n\n                      //these params are only for createHandle operation acceptance purposes\n                      @QueryParam(OverwriteParam.NAME) @DefaultValue(OverwriteParam.DEFAULT) OverwriteParam override,\n                      @QueryParam(BlockSizeParam.NAME) @DefaultValue(BlockSizeParam.DEFAULT) BlockSizeParam blockSize,\n                      @QueryParam(PermissionParam.NAME) @DefaultValue(PermissionParam.DEFAULT)\n                      PermissionParam permission,\n                      @QueryParam(ReplicationParam.NAME) @DefaultValue(ReplicationParam.DEFAULT)\n                      ReplicationParam replication\n  )\n    throws IOException, FileSystemAccessException {\n    Response response \u003d null;\n    if (op \u003d\u003d null) {\n      throw new UnsupportedOperationException(MessageFormat.format(\"Missing [{0}] parameter\", GetOpParam.NAME));\n    } else {\n      path.makeAbsolute();\n      MDC.put(HttpFSFileSystem.OP_PARAM, op.value().name());\n      switch (op.value()) {\n        case OPEN: {\n          //Invoking the command directly using an unmanaged FileSystem that is released by the\n          //FileSystemReleaseFilter\n          FSOperations.FSOpen command \u003d new FSOperations.FSOpen(path.value());\n          FileSystem fs \u003d createFileSystem(user, doAs.value());\n          InputStream is \u003d command.execute(fs);\n          AUDIT_LOG.info(\"[{}] offset [{}] len [{}]\", new Object[]{path, offset, len});\n          InputStreamEntity entity \u003d new InputStreamEntity(is, offset.value(), len.value());\n          response \u003d Response.ok(entity).type(MediaType.APPLICATION_OCTET_STREAM).build();\n          break;\n        }\n        case GETFILESTATUS: {\n          FSOperations.FSFileStatus command \u003d new FSOperations.FSFileStatus(path.value());\n          Map json \u003d fsExecute(user, doAs.value(), command);\n          AUDIT_LOG.info(\"[{}]\", path);\n          response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n          break;\n        }\n        case LISTSTATUS: {\n          FSOperations.FSListStatus command \u003d new FSOperations.FSListStatus(path.value(), filter.value());\n          Map json \u003d fsExecute(user, doAs.value(), command);\n          if (filter.value() \u003d\u003d null) {\n            AUDIT_LOG.info(\"[{}]\", path);\n          } else {\n            AUDIT_LOG.info(\"[{}] filter [{}]\", path, filter.value());\n          }\n          response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n          break;\n        }\n        case GETHOMEDIR: {\n          FSOperations.FSHomeDir command \u003d new FSOperations.FSHomeDir();\n          JSONObject json \u003d fsExecute(user, doAs.value(), command);\n          AUDIT_LOG.info(\"\");\n          response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n          break;\n        }\n        case INSTRUMENTATION: {\n          if (!path.value().equals(\"/\")) {\n            throw new UnsupportedOperationException(\n              MessageFormat.format(\"Invalid path for {0}\u003d{1}, must be \u0027/\u0027\",\n                                   GetOpParam.NAME, HttpFSFileSystem.GetOpValues.INSTRUMENTATION));\n          }\n          Groups groups \u003d HttpFSServerWebApp.get().get(Groups.class);\n          List\u003cString\u003e userGroups \u003d groups.getGroups(user.getName());\n          if (!userGroups.contains(HttpFSServerWebApp.get().getAdminGroup())) {\n            throw new AccessControlException(\"User not in HttpFSServer admin group\");\n          }\n          Instrumentation instrumentation \u003d HttpFSServerWebApp.get().get(Instrumentation.class);\n          Map snapshot \u003d instrumentation.getSnapshot();\n          response \u003d Response.ok(snapshot).build();\n          break;\n        }\n        case GETCONTENTSUMMARY: {\n          FSOperations.FSContentSummary command \u003d new FSOperations.FSContentSummary(path.value());\n          Map json \u003d fsExecute(user, doAs.value(), command);\n          AUDIT_LOG.info(\"[{}]\", path);\n          response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n          break;\n        }\n        case GETFILECHECKSUM: {\n          FSOperations.FSFileChecksum command \u003d new FSOperations.FSFileChecksum(path.value());\n          Map json \u003d fsExecute(user, doAs.value(), command);\n          AUDIT_LOG.info(\"[{}]\", path);\n          response \u003d Response.ok(json).type(MediaType.APPLICATION_JSON).build();\n          break;\n        }\n        case GETDELEGATIONTOKEN: {\n          response \u003d Response.status(Response.Status.BAD_REQUEST).build();\n          break;\n        }\n        case GETFILEBLOCKLOCATIONS: {\n          response \u003d Response.status(Response.Status.BAD_REQUEST).build();\n          break;\n        }\n      }\n      return response;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-httpfs/src/main/java/org/apache/hadoop/fs/http/server/HttpFSServer.java"
    }
  }
}