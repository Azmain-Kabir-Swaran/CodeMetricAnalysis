{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "DFSStripedOutputStream.java",
  "functionName": "writeChunk",
  "functionId": "writeChunk___bytes-byte[]__offset-int__len-int__checksum-byte[]__ckoff-int__cklen-int",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/DFSStripedOutputStream.java",
  "functionStartLine": 547,
  "functionEndLine": 601,
  "numCommitsSeen": 38,
  "timeTaken": 1572,
  "changeHistory": [
    "df622cf4a32ee172ded6c4b3b97a1e49befc4f10",
    "e30ce01ddce1cfd1e9d49c4784eb4a6bc87e36ca",
    "a8b4d0ff283a0af1075aaa94904d4c6e63a9a3dd"
  ],
  "changeHistoryShort": {
    "df622cf4a32ee172ded6c4b3b97a1e49befc4f10": "Ybodychange",
    "e30ce01ddce1cfd1e9d49c4784eb4a6bc87e36ca": "Ybodychange",
    "a8b4d0ff283a0af1075aaa94904d4c6e63a9a3dd": "Ybodychange"
  },
  "changeHistoryDetails": {
    "df622cf4a32ee172ded6c4b3b97a1e49befc4f10": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12999. When reach the end of the block group, it may not need to flush all the data packets(flushAllInternals) twice. Contributed by lufei and Fei Hui.\n",
      "commitDate": "24/12/19 9:37 PM",
      "commitName": "df622cf4a32ee172ded6c4b3b97a1e49befc4f10",
      "commitAuthor": "Ayush Saxena",
      "commitDateOld": "05/03/19 5:56 AM",
      "commitNameOld": "f940ab242da80a22bae95509d5c282d7e2f7ecdb",
      "commitAuthorOld": "Vinayakumar B",
      "daysBetweenCommits": 294.65,
      "commitsBetweenForRepo": 1993,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,55 +1,55 @@\n   protected synchronized void writeChunk(byte[] bytes, int offset, int len,\n       byte[] checksum, int ckoff, int cklen) throws IOException {\n     final int index \u003d getCurrentIndex();\n     final int pos \u003d cellBuffers.addTo(index, bytes, offset, len);\n     final boolean cellFull \u003d pos \u003d\u003d cellSize;\n \n     if (currentBlockGroup \u003d\u003d null || shouldEndBlockGroup()) {\n       // the incoming data should belong to a new block. Allocate a new block.\n       allocateNewBlock();\n     }\n \n     currentBlockGroup.setNumBytes(currentBlockGroup.getNumBytes() + len);\n     // note: the current streamer can be refreshed after allocating a new block\n     final StripedDataStreamer current \u003d getCurrentStreamer();\n     if (current.isHealthy()) {\n       try {\n         super.writeChunk(bytes, offset, len, checksum, ckoff, cklen);\n       } catch(Exception e) {\n         handleCurrentStreamerFailure(\"offset\u003d\" + offset + \", length\u003d\" + len, e);\n       }\n     }\n \n     // Two extra steps are needed when a striping cell is full:\n     // 1. Forward the current index pointer\n     // 2. Generate parity packets if a full stripe of data cells are present\n     if (cellFull) {\n       int next \u003d index + 1;\n       //When all data cells in a stripe are ready, we need to encode\n       //them and generate some parity cells. These cells will be\n       //converted to packets and put to their DataStreamer\u0027s queue.\n       if (next \u003d\u003d numDataBlocks) {\n         cellBuffers.flipDataBuffers();\n         writeParityCells();\n         next \u003d 0;\n \n         // if this is the end of the block group, end each internal block\n         if (shouldEndBlockGroup()) {\n           flushAllInternals();\n-          checkStreamerFailures();\n+          checkStreamerFailures(false);\n           for (int i \u003d 0; i \u003c numAllBlocks; i++) {\n             final StripedDataStreamer s \u003d setCurrentStreamer(i);\n             if (s.isHealthy()) {\n               try {\n                 endBlock();\n               } catch (IOException ignored) {}\n             }\n           }\n         } else {\n           // check failure state for all the streamers. Bump GS if necessary\n-          checkStreamerFailures();\n+          checkStreamerFailures(true);\n         }\n       }\n       setCurrentStreamer(next);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void writeChunk(byte[] bytes, int offset, int len,\n      byte[] checksum, int ckoff, int cklen) throws IOException {\n    final int index \u003d getCurrentIndex();\n    final int pos \u003d cellBuffers.addTo(index, bytes, offset, len);\n    final boolean cellFull \u003d pos \u003d\u003d cellSize;\n\n    if (currentBlockGroup \u003d\u003d null || shouldEndBlockGroup()) {\n      // the incoming data should belong to a new block. Allocate a new block.\n      allocateNewBlock();\n    }\n\n    currentBlockGroup.setNumBytes(currentBlockGroup.getNumBytes() + len);\n    // note: the current streamer can be refreshed after allocating a new block\n    final StripedDataStreamer current \u003d getCurrentStreamer();\n    if (current.isHealthy()) {\n      try {\n        super.writeChunk(bytes, offset, len, checksum, ckoff, cklen);\n      } catch(Exception e) {\n        handleCurrentStreamerFailure(\"offset\u003d\" + offset + \", length\u003d\" + len, e);\n      }\n    }\n\n    // Two extra steps are needed when a striping cell is full:\n    // 1. Forward the current index pointer\n    // 2. Generate parity packets if a full stripe of data cells are present\n    if (cellFull) {\n      int next \u003d index + 1;\n      //When all data cells in a stripe are ready, we need to encode\n      //them and generate some parity cells. These cells will be\n      //converted to packets and put to their DataStreamer\u0027s queue.\n      if (next \u003d\u003d numDataBlocks) {\n        cellBuffers.flipDataBuffers();\n        writeParityCells();\n        next \u003d 0;\n\n        // if this is the end of the block group, end each internal block\n        if (shouldEndBlockGroup()) {\n          flushAllInternals();\n          checkStreamerFailures(false);\n          for (int i \u003d 0; i \u003c numAllBlocks; i++) {\n            final StripedDataStreamer s \u003d setCurrentStreamer(i);\n            if (s.isHealthy()) {\n              try {\n                endBlock();\n              } catch (IOException ignored) {}\n            }\n          }\n        } else {\n          // check failure state for all the streamers. Bump GS if necessary\n          checkStreamerFailures(true);\n        }\n      }\n      setCurrentStreamer(next);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/DFSStripedOutputStream.java",
      "extendedDetails": {}
    },
    "e30ce01ddce1cfd1e9d49c4784eb4a6bc87e36ca": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9494. Parallel optimization of DFSStripedOutputStream#flushAllInternals. Contributed by Gao Rui.\n",
      "commitDate": "01/02/16 1:02 PM",
      "commitName": "e30ce01ddce1cfd1e9d49c4784eb4a6bc87e36ca",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "18/12/15 3:57 PM",
      "commitNameOld": "61ab0440f7eaff0f631cbae0378403912f88d7ad",
      "commitAuthorOld": "Zhe Zhang",
      "daysBetweenCommits": 44.88,
      "commitsBetweenForRepo": 252,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,55 +1,55 @@\n   protected synchronized void writeChunk(byte[] bytes, int offset, int len,\n       byte[] checksum, int ckoff, int cklen) throws IOException {\n     final int index \u003d getCurrentIndex();\n     final int pos \u003d cellBuffers.addTo(index, bytes, offset, len);\n     final boolean cellFull \u003d pos \u003d\u003d cellSize;\n \n     if (currentBlockGroup \u003d\u003d null || shouldEndBlockGroup()) {\n       // the incoming data should belong to a new block. Allocate a new block.\n       allocateNewBlock();\n     }\n \n     currentBlockGroup.setNumBytes(currentBlockGroup.getNumBytes() + len);\n     // note: the current streamer can be refreshed after allocating a new block\n     final StripedDataStreamer current \u003d getCurrentStreamer();\n     if (current.isHealthy()) {\n       try {\n         super.writeChunk(bytes, offset, len, checksum, ckoff, cklen);\n       } catch(Exception e) {\n-        handleStreamerFailure(\"offset\u003d\" + offset + \", length\u003d\" + len, e);\n+        handleCurrentStreamerFailure(\"offset\u003d\" + offset + \", length\u003d\" + len, e);\n       }\n     }\n \n     // Two extra steps are needed when a striping cell is full:\n     // 1. Forward the current index pointer\n     // 2. Generate parity packets if a full stripe of data cells are present\n     if (cellFull) {\n       int next \u003d index + 1;\n       //When all data cells in a stripe are ready, we need to encode\n       //them and generate some parity cells. These cells will be\n       //converted to packets and put to their DataStreamer\u0027s queue.\n       if (next \u003d\u003d numDataBlocks) {\n         cellBuffers.flipDataBuffers();\n         writeParityCells();\n         next \u003d 0;\n \n         // if this is the end of the block group, end each internal block\n         if (shouldEndBlockGroup()) {\n           flushAllInternals();\n           checkStreamerFailures();\n           for (int i \u003d 0; i \u003c numAllBlocks; i++) {\n             final StripedDataStreamer s \u003d setCurrentStreamer(i);\n             if (s.isHealthy()) {\n               try {\n                 endBlock();\n               } catch (IOException ignored) {}\n             }\n           }\n         } else {\n           // check failure state for all the streamers. Bump GS if necessary\n           checkStreamerFailures();\n         }\n       }\n       setCurrentStreamer(next);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void writeChunk(byte[] bytes, int offset, int len,\n      byte[] checksum, int ckoff, int cklen) throws IOException {\n    final int index \u003d getCurrentIndex();\n    final int pos \u003d cellBuffers.addTo(index, bytes, offset, len);\n    final boolean cellFull \u003d pos \u003d\u003d cellSize;\n\n    if (currentBlockGroup \u003d\u003d null || shouldEndBlockGroup()) {\n      // the incoming data should belong to a new block. Allocate a new block.\n      allocateNewBlock();\n    }\n\n    currentBlockGroup.setNumBytes(currentBlockGroup.getNumBytes() + len);\n    // note: the current streamer can be refreshed after allocating a new block\n    final StripedDataStreamer current \u003d getCurrentStreamer();\n    if (current.isHealthy()) {\n      try {\n        super.writeChunk(bytes, offset, len, checksum, ckoff, cklen);\n      } catch(Exception e) {\n        handleCurrentStreamerFailure(\"offset\u003d\" + offset + \", length\u003d\" + len, e);\n      }\n    }\n\n    // Two extra steps are needed when a striping cell is full:\n    // 1. Forward the current index pointer\n    // 2. Generate parity packets if a full stripe of data cells are present\n    if (cellFull) {\n      int next \u003d index + 1;\n      //When all data cells in a stripe are ready, we need to encode\n      //them and generate some parity cells. These cells will be\n      //converted to packets and put to their DataStreamer\u0027s queue.\n      if (next \u003d\u003d numDataBlocks) {\n        cellBuffers.flipDataBuffers();\n        writeParityCells();\n        next \u003d 0;\n\n        // if this is the end of the block group, end each internal block\n        if (shouldEndBlockGroup()) {\n          flushAllInternals();\n          checkStreamerFailures();\n          for (int i \u003d 0; i \u003c numAllBlocks; i++) {\n            final StripedDataStreamer s \u003d setCurrentStreamer(i);\n            if (s.isHealthy()) {\n              try {\n                endBlock();\n              } catch (IOException ignored) {}\n            }\n          }\n        } else {\n          // check failure state for all the streamers. Bump GS if necessary\n          checkStreamerFailures();\n        }\n      }\n      setCurrentStreamer(next);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/DFSStripedOutputStream.java",
      "extendedDetails": {}
    },
    "a8b4d0ff283a0af1075aaa94904d4c6e63a9a3dd": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9180. Update excluded DataNodes in DFSStripedOutputStream based on failures in data streamers. Contributed by Jing Zhao.\n",
      "commitDate": "06/10/15 10:56 AM",
      "commitName": "a8b4d0ff283a0af1075aaa94904d4c6e63a9a3dd",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "03/10/15 11:38 AM",
      "commitNameOld": "7136e8c5582dc4061b566cb9f11a0d6a6d08bb93",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 2.97,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,51 +1,55 @@\n   protected synchronized void writeChunk(byte[] bytes, int offset, int len,\n       byte[] checksum, int ckoff, int cklen) throws IOException {\n     final int index \u003d getCurrentIndex();\n-    final StripedDataStreamer current \u003d getCurrentStreamer();\n     final int pos \u003d cellBuffers.addTo(index, bytes, offset, len);\n     final boolean cellFull \u003d pos \u003d\u003d cellSize;\n \n     if (currentBlockGroup \u003d\u003d null || shouldEndBlockGroup()) {\n       // the incoming data should belong to a new block. Allocate a new block.\n       allocateNewBlock();\n     }\n \n     currentBlockGroup.setNumBytes(currentBlockGroup.getNumBytes() + len);\n+    // note: the current streamer can be refreshed after allocating a new block\n+    final StripedDataStreamer current \u003d getCurrentStreamer();\n     if (current.isHealthy()) {\n       try {\n         super.writeChunk(bytes, offset, len, checksum, ckoff, cklen);\n       } catch(Exception e) {\n         handleStreamerFailure(\"offset\u003d\" + offset + \", length\u003d\" + len, e);\n       }\n     }\n \n     // Two extra steps are needed when a striping cell is full:\n     // 1. Forward the current index pointer\n     // 2. Generate parity packets if a full stripe of data cells are present\n     if (cellFull) {\n       int next \u003d index + 1;\n       //When all data cells in a stripe are ready, we need to encode\n       //them and generate some parity cells. These cells will be\n       //converted to packets and put to their DataStreamer\u0027s queue.\n       if (next \u003d\u003d numDataBlocks) {\n         cellBuffers.flipDataBuffers();\n         writeParityCells();\n         next \u003d 0;\n-        // check failure state for all the streamers. Bump GS if necessary\n-        checkStreamerFailures();\n \n         // if this is the end of the block group, end each internal block\n         if (shouldEndBlockGroup()) {\n+          flushAllInternals();\n+          checkStreamerFailures();\n           for (int i \u003d 0; i \u003c numAllBlocks; i++) {\n             final StripedDataStreamer s \u003d setCurrentStreamer(i);\n             if (s.isHealthy()) {\n               try {\n                 endBlock();\n               } catch (IOException ignored) {}\n             }\n           }\n+        } else {\n+          // check failure state for all the streamers. Bump GS if necessary\n+          checkStreamerFailures();\n         }\n       }\n       setCurrentStreamer(next);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void writeChunk(byte[] bytes, int offset, int len,\n      byte[] checksum, int ckoff, int cklen) throws IOException {\n    final int index \u003d getCurrentIndex();\n    final int pos \u003d cellBuffers.addTo(index, bytes, offset, len);\n    final boolean cellFull \u003d pos \u003d\u003d cellSize;\n\n    if (currentBlockGroup \u003d\u003d null || shouldEndBlockGroup()) {\n      // the incoming data should belong to a new block. Allocate a new block.\n      allocateNewBlock();\n    }\n\n    currentBlockGroup.setNumBytes(currentBlockGroup.getNumBytes() + len);\n    // note: the current streamer can be refreshed after allocating a new block\n    final StripedDataStreamer current \u003d getCurrentStreamer();\n    if (current.isHealthy()) {\n      try {\n        super.writeChunk(bytes, offset, len, checksum, ckoff, cklen);\n      } catch(Exception e) {\n        handleStreamerFailure(\"offset\u003d\" + offset + \", length\u003d\" + len, e);\n      }\n    }\n\n    // Two extra steps are needed when a striping cell is full:\n    // 1. Forward the current index pointer\n    // 2. Generate parity packets if a full stripe of data cells are present\n    if (cellFull) {\n      int next \u003d index + 1;\n      //When all data cells in a stripe are ready, we need to encode\n      //them and generate some parity cells. These cells will be\n      //converted to packets and put to their DataStreamer\u0027s queue.\n      if (next \u003d\u003d numDataBlocks) {\n        cellBuffers.flipDataBuffers();\n        writeParityCells();\n        next \u003d 0;\n\n        // if this is the end of the block group, end each internal block\n        if (shouldEndBlockGroup()) {\n          flushAllInternals();\n          checkStreamerFailures();\n          for (int i \u003d 0; i \u003c numAllBlocks; i++) {\n            final StripedDataStreamer s \u003d setCurrentStreamer(i);\n            if (s.isHealthy()) {\n              try {\n                endBlock();\n              } catch (IOException ignored) {}\n            }\n          }\n        } else {\n          // check failure state for all the streamers. Bump GS if necessary\n          checkStreamerFailures();\n        }\n      }\n      setCurrentStreamer(next);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/DFSStripedOutputStream.java",
      "extendedDetails": {}
    }
  }
}