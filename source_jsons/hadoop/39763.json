{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "UsersManager.java",
  "functionName": "getComputedResourceLimitForActiveUsers",
  "functionId": "getComputedResourceLimitForActiveUsers___userName-String__clusterResource-Resource__nodePartition-String__schedulingMode-SchedulingMode",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/UsersManager.java",
  "functionStartLine": 491,
  "functionEndLine": 530,
  "numCommitsSeen": 13,
  "timeTaken": 3733,
  "changeHistory": [
    "2064ca015d1584263aac0cc20c60b925a3aff612",
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635",
    "67f239c42f676237290d18ddbbc9aec369267692",
    "ca13b224b2feb9c44de861da9cbba8dd2a12cb35",
    "5fb723bb77722d41df6959eee23e1b0cfeb5584e"
  ],
  "changeHistoryShort": {
    "2064ca015d1584263aac0cc20c60b925a3aff612": "Ybodychange",
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635": "Ybodychange",
    "67f239c42f676237290d18ddbbc9aec369267692": "Ybodychange",
    "ca13b224b2feb9c44de861da9cbba8dd2a12cb35": "Ybodychange",
    "5fb723bb77722d41df6959eee23e1b0cfeb5584e": "Yintroduced"
  },
  "changeHistoryDetails": {
    "2064ca015d1584263aac0cc20c60b925a3aff612": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9349.  Changed logging to use slf4j api.\n            Contributed by Prabhu Joseph\n",
      "commitDate": "15/03/19 4:20 PM",
      "commitName": "2064ca015d1584263aac0cc20c60b925a3aff612",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "07/03/19 1:47 PM",
      "commitNameOld": "39b4a37e02e929a698fcf9e32f1f71bb6b977635",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 8.06,
      "commitsBetweenForRepo": 69,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,40 @@\n   public Resource getComputedResourceLimitForActiveUsers(String userName,\n       Resource clusterResource, String nodePartition,\n       SchedulingMode schedulingMode) {\n \n     Map\u003cSchedulingMode, Resource\u003e userLimitPerSchedulingMode;\n \n     writeLock.lock();\n     try {\n       userLimitPerSchedulingMode \u003d\n           preComputedActiveUserLimit.get(nodePartition);\n       if (isRecomputeNeeded(schedulingMode, nodePartition, true)) {\n         // recompute\n         userLimitPerSchedulingMode \u003d reComputeUserLimits(userName,\n             nodePartition, clusterResource, schedulingMode, true);\n \n         // update user count to cache so that we can avoid recompute if no major\n         // changes.\n         setLocalVersionOfUsersState(nodePartition, schedulingMode, true);\n       }\n     } finally {\n       writeLock.unlock();\n     }\n \n     Resource userLimitResource \u003d userLimitPerSchedulingMode.get(schedulingMode);\n     User user \u003d getUser(userName);\n     float weight \u003d (user \u003d\u003d null) ? 1.0f : user.getWeight();\n     Resource userSpecificUserLimit \u003d\n         Resources.multiplyAndNormalizeDown(resourceCalculator,\n             userLimitResource, weight, lQueue.getMinimumAllocation());\n \n     if (user !\u003d null) {\n       user.setUserResourceLimit(userSpecificUserLimit);\n     }\n \n-    if (LOG.isDebugEnabled()) {\n-      LOG.debug(\"userLimit is fetched. userLimit\u003d\" + userLimitResource\n-          + \", userSpecificUserLimit\u003d\" + userSpecificUserLimit\n-          + \", schedulingMode\u003d\" + schedulingMode\n-          + \", partition\u003d\" + nodePartition);\n-    }\n+    LOG.debug(\"userLimit is fetched. userLimit\u003d{}, userSpecificUserLimit\u003d{},\"\n+        + \" schedulingMode\u003d{}, partition\u003d{}\", userLimitResource,\n+        userSpecificUserLimit, schedulingMode, nodePartition);\n+\n     return userSpecificUserLimit;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Resource getComputedResourceLimitForActiveUsers(String userName,\n      Resource clusterResource, String nodePartition,\n      SchedulingMode schedulingMode) {\n\n    Map\u003cSchedulingMode, Resource\u003e userLimitPerSchedulingMode;\n\n    writeLock.lock();\n    try {\n      userLimitPerSchedulingMode \u003d\n          preComputedActiveUserLimit.get(nodePartition);\n      if (isRecomputeNeeded(schedulingMode, nodePartition, true)) {\n        // recompute\n        userLimitPerSchedulingMode \u003d reComputeUserLimits(userName,\n            nodePartition, clusterResource, schedulingMode, true);\n\n        // update user count to cache so that we can avoid recompute if no major\n        // changes.\n        setLocalVersionOfUsersState(nodePartition, schedulingMode, true);\n      }\n    } finally {\n      writeLock.unlock();\n    }\n\n    Resource userLimitResource \u003d userLimitPerSchedulingMode.get(schedulingMode);\n    User user \u003d getUser(userName);\n    float weight \u003d (user \u003d\u003d null) ? 1.0f : user.getWeight();\n    Resource userSpecificUserLimit \u003d\n        Resources.multiplyAndNormalizeDown(resourceCalculator,\n            userLimitResource, weight, lQueue.getMinimumAllocation());\n\n    if (user !\u003d null) {\n      user.setUserResourceLimit(userSpecificUserLimit);\n    }\n\n    LOG.debug(\"userLimit is fetched. userLimit\u003d{}, userSpecificUserLimit\u003d{},\"\n        + \" schedulingMode\u003d{}, partition\u003d{}\", userLimitResource,\n        userSpecificUserLimit, schedulingMode, nodePartition);\n\n    return userSpecificUserLimit;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/UsersManager.java",
      "extendedDetails": {}
    },
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9341.  Fixed enentrant lock usage in YARN project.\n            Contributed by Prabhu Joseph\n",
      "commitDate": "07/03/19 1:47 PM",
      "commitName": "39b4a37e02e929a698fcf9e32f1f71bb6b977635",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "04/03/19 9:10 PM",
      "commitNameOld": "e40e2d6ad5cbe782c3a067229270738b501ed27e",
      "commitAuthorOld": "Prabhu Joseph",
      "daysBetweenCommits": 2.69,
      "commitsBetweenForRepo": 39,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,42 @@\n   public Resource getComputedResourceLimitForActiveUsers(String userName,\n       Resource clusterResource, String nodePartition,\n       SchedulingMode schedulingMode) {\n \n     Map\u003cSchedulingMode, Resource\u003e userLimitPerSchedulingMode;\n \n+    writeLock.lock();\n     try {\n-      writeLock.lock();\n       userLimitPerSchedulingMode \u003d\n           preComputedActiveUserLimit.get(nodePartition);\n       if (isRecomputeNeeded(schedulingMode, nodePartition, true)) {\n         // recompute\n         userLimitPerSchedulingMode \u003d reComputeUserLimits(userName,\n             nodePartition, clusterResource, schedulingMode, true);\n \n         // update user count to cache so that we can avoid recompute if no major\n         // changes.\n         setLocalVersionOfUsersState(nodePartition, schedulingMode, true);\n       }\n     } finally {\n       writeLock.unlock();\n     }\n \n     Resource userLimitResource \u003d userLimitPerSchedulingMode.get(schedulingMode);\n     User user \u003d getUser(userName);\n     float weight \u003d (user \u003d\u003d null) ? 1.0f : user.getWeight();\n     Resource userSpecificUserLimit \u003d\n         Resources.multiplyAndNormalizeDown(resourceCalculator,\n             userLimitResource, weight, lQueue.getMinimumAllocation());\n \n     if (user !\u003d null) {\n       user.setUserResourceLimit(userSpecificUserLimit);\n     }\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"userLimit is fetched. userLimit\u003d\" + userLimitResource\n           + \", userSpecificUserLimit\u003d\" + userSpecificUserLimit\n           + \", schedulingMode\u003d\" + schedulingMode\n           + \", partition\u003d\" + nodePartition);\n     }\n     return userSpecificUserLimit;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Resource getComputedResourceLimitForActiveUsers(String userName,\n      Resource clusterResource, String nodePartition,\n      SchedulingMode schedulingMode) {\n\n    Map\u003cSchedulingMode, Resource\u003e userLimitPerSchedulingMode;\n\n    writeLock.lock();\n    try {\n      userLimitPerSchedulingMode \u003d\n          preComputedActiveUserLimit.get(nodePartition);\n      if (isRecomputeNeeded(schedulingMode, nodePartition, true)) {\n        // recompute\n        userLimitPerSchedulingMode \u003d reComputeUserLimits(userName,\n            nodePartition, clusterResource, schedulingMode, true);\n\n        // update user count to cache so that we can avoid recompute if no major\n        // changes.\n        setLocalVersionOfUsersState(nodePartition, schedulingMode, true);\n      }\n    } finally {\n      writeLock.unlock();\n    }\n\n    Resource userLimitResource \u003d userLimitPerSchedulingMode.get(schedulingMode);\n    User user \u003d getUser(userName);\n    float weight \u003d (user \u003d\u003d null) ? 1.0f : user.getWeight();\n    Resource userSpecificUserLimit \u003d\n        Resources.multiplyAndNormalizeDown(resourceCalculator,\n            userLimitResource, weight, lQueue.getMinimumAllocation());\n\n    if (user !\u003d null) {\n      user.setUserResourceLimit(userSpecificUserLimit);\n    }\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"userLimit is fetched. userLimit\u003d\" + userLimitResource\n          + \", userSpecificUserLimit\u003d\" + userSpecificUserLimit\n          + \", schedulingMode\u003d\" + schedulingMode\n          + \", partition\u003d\" + nodePartition);\n    }\n    return userSpecificUserLimit;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/UsersManager.java",
      "extendedDetails": {}
    },
    "67f239c42f676237290d18ddbbc9aec369267692": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8025. UsersManangers#getComputedResourceLimitForActiveUsers throws NPE due to preComputedActiveUserLimit is empty. Contributed by Tao Yang.\n",
      "commitDate": "06/05/18 8:33 PM",
      "commitName": "67f239c42f676237290d18ddbbc9aec369267692",
      "commitAuthor": "Weiwei Yang",
      "commitDateOld": "07/12/17 6:56 PM",
      "commitNameOld": "d52627a7cbddfd981db973e223aefffde1ebf82d",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 150.03,
      "commitsBetweenForRepo": 1574,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,42 @@\n   public Resource getComputedResourceLimitForActiveUsers(String userName,\n       Resource clusterResource, String nodePartition,\n       SchedulingMode schedulingMode) {\n \n-    Map\u003cSchedulingMode, Resource\u003e userLimitPerSchedulingMode \u003d preComputedActiveUserLimit\n-        .get(nodePartition);\n+    Map\u003cSchedulingMode, Resource\u003e userLimitPerSchedulingMode;\n \n     try {\n       writeLock.lock();\n+      userLimitPerSchedulingMode \u003d\n+          preComputedActiveUserLimit.get(nodePartition);\n       if (isRecomputeNeeded(schedulingMode, nodePartition, true)) {\n         // recompute\n         userLimitPerSchedulingMode \u003d reComputeUserLimits(userName,\n             nodePartition, clusterResource, schedulingMode, true);\n \n         // update user count to cache so that we can avoid recompute if no major\n         // changes.\n         setLocalVersionOfUsersState(nodePartition, schedulingMode, true);\n       }\n     } finally {\n       writeLock.unlock();\n     }\n \n     Resource userLimitResource \u003d userLimitPerSchedulingMode.get(schedulingMode);\n     User user \u003d getUser(userName);\n     float weight \u003d (user \u003d\u003d null) ? 1.0f : user.getWeight();\n     Resource userSpecificUserLimit \u003d\n         Resources.multiplyAndNormalizeDown(resourceCalculator,\n             userLimitResource, weight, lQueue.getMinimumAllocation());\n \n     if (user !\u003d null) {\n       user.setUserResourceLimit(userSpecificUserLimit);\n     }\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"userLimit is fetched. userLimit\u003d\" + userLimitResource\n           + \", userSpecificUserLimit\u003d\" + userSpecificUserLimit\n           + \", schedulingMode\u003d\" + schedulingMode\n           + \", partition\u003d\" + nodePartition);\n     }\n     return userSpecificUserLimit;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Resource getComputedResourceLimitForActiveUsers(String userName,\n      Resource clusterResource, String nodePartition,\n      SchedulingMode schedulingMode) {\n\n    Map\u003cSchedulingMode, Resource\u003e userLimitPerSchedulingMode;\n\n    try {\n      writeLock.lock();\n      userLimitPerSchedulingMode \u003d\n          preComputedActiveUserLimit.get(nodePartition);\n      if (isRecomputeNeeded(schedulingMode, nodePartition, true)) {\n        // recompute\n        userLimitPerSchedulingMode \u003d reComputeUserLimits(userName,\n            nodePartition, clusterResource, schedulingMode, true);\n\n        // update user count to cache so that we can avoid recompute if no major\n        // changes.\n        setLocalVersionOfUsersState(nodePartition, schedulingMode, true);\n      }\n    } finally {\n      writeLock.unlock();\n    }\n\n    Resource userLimitResource \u003d userLimitPerSchedulingMode.get(schedulingMode);\n    User user \u003d getUser(userName);\n    float weight \u003d (user \u003d\u003d null) ? 1.0f : user.getWeight();\n    Resource userSpecificUserLimit \u003d\n        Resources.multiplyAndNormalizeDown(resourceCalculator,\n            userLimitResource, weight, lQueue.getMinimumAllocation());\n\n    if (user !\u003d null) {\n      user.setUserResourceLimit(userSpecificUserLimit);\n    }\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"userLimit is fetched. userLimit\u003d\" + userLimitResource\n          + \", userSpecificUserLimit\u003d\" + userSpecificUserLimit\n          + \", schedulingMode\u003d\" + schedulingMode\n          + \", partition\u003d\" + nodePartition);\n    }\n    return userSpecificUserLimit;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/UsersManager.java",
      "extendedDetails": {}
    },
    "ca13b224b2feb9c44de861da9cbba8dd2a12cb35": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5892. Support user-specific minimum user limit percentage in Capacity Scheduler. Contributed by Eric Payne.\n",
      "commitDate": "22/06/17 11:50 PM",
      "commitName": "ca13b224b2feb9c44de861da9cbba8dd2a12cb35",
      "commitAuthor": "Sunil G",
      "commitDateOld": "22/05/17 2:26 PM",
      "commitNameOld": "c583ab02c730be0a63d974039a78f2dc67dc2db6",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 31.39,
      "commitsBetweenForRepo": 156,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,30 +1,41 @@\n   public Resource getComputedResourceLimitForActiveUsers(String userName,\n       Resource clusterResource, String nodePartition,\n       SchedulingMode schedulingMode) {\n \n     Map\u003cSchedulingMode, Resource\u003e userLimitPerSchedulingMode \u003d preComputedActiveUserLimit\n         .get(nodePartition);\n \n     try {\n       writeLock.lock();\n       if (isRecomputeNeeded(schedulingMode, nodePartition, true)) {\n         // recompute\n         userLimitPerSchedulingMode \u003d reComputeUserLimits(userName,\n             nodePartition, clusterResource, schedulingMode, true);\n \n         // update user count to cache so that we can avoid recompute if no major\n         // changes.\n         setLocalVersionOfUsersState(nodePartition, schedulingMode, true);\n       }\n     } finally {\n       writeLock.unlock();\n     }\n \n-    if (LOG.isDebugEnabled()) {\n-      LOG.debug(\"userLimit is fetched. userLimit \u003d \"\n-          + userLimitPerSchedulingMode.get(schedulingMode) + \", schedulingMode\u003d\"\n-          + schedulingMode + \", partition\u003d\" + nodePartition);\n+    Resource userLimitResource \u003d userLimitPerSchedulingMode.get(schedulingMode);\n+    User user \u003d getUser(userName);\n+    float weight \u003d (user \u003d\u003d null) ? 1.0f : user.getWeight();\n+    Resource userSpecificUserLimit \u003d\n+        Resources.multiplyAndNormalizeDown(resourceCalculator,\n+            userLimitResource, weight, lQueue.getMinimumAllocation());\n+\n+    if (user !\u003d null) {\n+      user.setUserResourceLimit(userSpecificUserLimit);\n     }\n \n-    return userLimitPerSchedulingMode.get(schedulingMode);\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(\"userLimit is fetched. userLimit\u003d\" + userLimitResource\n+          + \", userSpecificUserLimit\u003d\" + userSpecificUserLimit\n+          + \", schedulingMode\u003d\" + schedulingMode\n+          + \", partition\u003d\" + nodePartition);\n+    }\n+    return userSpecificUserLimit;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Resource getComputedResourceLimitForActiveUsers(String userName,\n      Resource clusterResource, String nodePartition,\n      SchedulingMode schedulingMode) {\n\n    Map\u003cSchedulingMode, Resource\u003e userLimitPerSchedulingMode \u003d preComputedActiveUserLimit\n        .get(nodePartition);\n\n    try {\n      writeLock.lock();\n      if (isRecomputeNeeded(schedulingMode, nodePartition, true)) {\n        // recompute\n        userLimitPerSchedulingMode \u003d reComputeUserLimits(userName,\n            nodePartition, clusterResource, schedulingMode, true);\n\n        // update user count to cache so that we can avoid recompute if no major\n        // changes.\n        setLocalVersionOfUsersState(nodePartition, schedulingMode, true);\n      }\n    } finally {\n      writeLock.unlock();\n    }\n\n    Resource userLimitResource \u003d userLimitPerSchedulingMode.get(schedulingMode);\n    User user \u003d getUser(userName);\n    float weight \u003d (user \u003d\u003d null) ? 1.0f : user.getWeight();\n    Resource userSpecificUserLimit \u003d\n        Resources.multiplyAndNormalizeDown(resourceCalculator,\n            userLimitResource, weight, lQueue.getMinimumAllocation());\n\n    if (user !\u003d null) {\n      user.setUserResourceLimit(userSpecificUserLimit);\n    }\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"userLimit is fetched. userLimit\u003d\" + userLimitResource\n          + \", userSpecificUserLimit\u003d\" + userSpecificUserLimit\n          + \", schedulingMode\u003d\" + schedulingMode\n          + \", partition\u003d\" + nodePartition);\n    }\n    return userSpecificUserLimit;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/UsersManager.java",
      "extendedDetails": {}
    },
    "5fb723bb77722d41df6959eee23e1b0cfeb5584e": {
      "type": "Yintroduced",
      "commitMessage": "YARN-5889. Improve and refactor user-limit calculation in Capacity Scheduler. (Sunil G via wangda)\n",
      "commitDate": "09/02/17 10:23 AM",
      "commitName": "5fb723bb77722d41df6959eee23e1b0cfeb5584e",
      "commitAuthor": "Wangda Tan",
      "diff": "@@ -0,0 +1,30 @@\n+  public Resource getComputedResourceLimitForActiveUsers(String userName,\n+      Resource clusterResource, String nodePartition,\n+      SchedulingMode schedulingMode) {\n+\n+    Map\u003cSchedulingMode, Resource\u003e userLimitPerSchedulingMode \u003d preComputedActiveUserLimit\n+        .get(nodePartition);\n+\n+    try {\n+      writeLock.lock();\n+      if (isRecomputeNeeded(schedulingMode, nodePartition, true)) {\n+        // recompute\n+        userLimitPerSchedulingMode \u003d reComputeUserLimits(userName,\n+            nodePartition, clusterResource, schedulingMode, true);\n+\n+        // update user count to cache so that we can avoid recompute if no major\n+        // changes.\n+        setLocalVersionOfUsersState(nodePartition, schedulingMode, true);\n+      }\n+    } finally {\n+      writeLock.unlock();\n+    }\n+\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(\"userLimit is fetched. userLimit \u003d \"\n+          + userLimitPerSchedulingMode.get(schedulingMode) + \", schedulingMode\u003d\"\n+          + schedulingMode + \", partition\u003d\" + nodePartition);\n+    }\n+\n+    return userLimitPerSchedulingMode.get(schedulingMode);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public Resource getComputedResourceLimitForActiveUsers(String userName,\n      Resource clusterResource, String nodePartition,\n      SchedulingMode schedulingMode) {\n\n    Map\u003cSchedulingMode, Resource\u003e userLimitPerSchedulingMode \u003d preComputedActiveUserLimit\n        .get(nodePartition);\n\n    try {\n      writeLock.lock();\n      if (isRecomputeNeeded(schedulingMode, nodePartition, true)) {\n        // recompute\n        userLimitPerSchedulingMode \u003d reComputeUserLimits(userName,\n            nodePartition, clusterResource, schedulingMode, true);\n\n        // update user count to cache so that we can avoid recompute if no major\n        // changes.\n        setLocalVersionOfUsersState(nodePartition, schedulingMode, true);\n      }\n    } finally {\n      writeLock.unlock();\n    }\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"userLimit is fetched. userLimit \u003d \"\n          + userLimitPerSchedulingMode.get(schedulingMode) + \", schedulingMode\u003d\"\n          + schedulingMode + \", partition\u003d\" + nodePartition);\n    }\n\n    return userLimitPerSchedulingMode.get(schedulingMode);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/UsersManager.java"
    }
  }
}