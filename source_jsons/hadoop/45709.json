{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "LogAggregationIndexedFileController.java",
  "functionName": "readAggregatedLogs",
  "functionId": "readAggregatedLogs___logRequest-ContainerLogsRequest__os-OutputStream",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/filecontroller/ifile/LogAggregationIndexedFileController.java",
  "functionStartLine": 492,
  "functionEndLine": 612,
  "numCommitsSeen": 18,
  "timeTaken": 3570,
  "changeHistory": [
    "2b39ad26984d641bad57db2cfcc0b7515ef95f46",
    "583f4594314b3db25b57b1e46ea8026eab21f932",
    "e718ac597f2225cb4946e1ac4b3986c336645643",
    "4d53ef7eefb14661d824924e503a910de1ae997f",
    "d4c98579e36df7eeb788352d7b76cd2c7448c511",
    "280080fad01304c85a9ede4d4f7b707eb36c0155",
    "3fddabc2fe4fbdb8ef3f9ce7558955c4f0794dcc"
  ],
  "changeHistoryShort": {
    "2b39ad26984d641bad57db2cfcc0b7515ef95f46": "Ybodychange",
    "583f4594314b3db25b57b1e46ea8026eab21f932": "Ybodychange",
    "e718ac597f2225cb4946e1ac4b3986c336645643": "Ybodychange",
    "4d53ef7eefb14661d824924e503a910de1ae997f": "Ybodychange",
    "d4c98579e36df7eeb788352d7b76cd2c7448c511": "Ybodychange",
    "280080fad01304c85a9ede4d4f7b707eb36c0155": "Ybodychange",
    "3fddabc2fe4fbdb8ef3f9ce7558955c4f0794dcc": "Yintroduced"
  },
  "changeHistoryDetails": {
    "2b39ad26984d641bad57db2cfcc0b7515ef95f46": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8584. Several typos in Log Aggregation related classes. Contributed by Szilard Nemeth.\n",
      "commitDate": "30/07/18 10:55 AM",
      "commitName": "2b39ad26984d641bad57db2cfcc0b7515ef95f46",
      "commitAuthor": "bibinchundatt",
      "commitDateOld": "12/06/18 8:35 AM",
      "commitNameOld": "652bcbb3e4950758e61ce123ecc1798ae2b60a7f",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 48.1,
      "commitsBetweenForRepo": 294,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,121 +1,121 @@\n   public boolean readAggregatedLogs(ContainerLogsRequest logRequest,\n       OutputStream os) throws IOException {\n     boolean findLogs \u003d false;\n     boolean createPrintStream \u003d (os \u003d\u003d null);\n     ApplicationId appId \u003d logRequest.getAppId();\n     String nodeId \u003d logRequest.getNodeId();\n     String nodeIdStr \u003d (nodeId \u003d\u003d null || nodeId.isEmpty()) ? null\n         : LogAggregationUtils.getNodeString(nodeId);\n     List\u003cString\u003e logTypes \u003d new ArrayList\u003c\u003e();\n     if (logRequest.getLogTypes() !\u003d null \u0026\u0026 !logRequest\n         .getLogTypes().isEmpty()) {\n       logTypes.addAll(logRequest.getLogTypes());\n     }\n     String containerIdStr \u003d logRequest.getContainerId();\n     boolean getAllContainers \u003d (containerIdStr \u003d\u003d null\n         || containerIdStr.isEmpty());\n     long size \u003d logRequest.getBytes();\n     RemoteIterator\u003cFileStatus\u003e nodeFiles \u003d LogAggregationUtils\n         .getRemoteNodeFileDir(conf, appId, logRequest.getAppOwner(),\n         this.remoteRootLogDir, this.remoteRootLogDirSuffix);\n     if (!nodeFiles.hasNext()) {\n-      throw new IOException(\"There is no available log fils for \"\n+      throw new IOException(\"There is no available log file for \"\n           + \"application:\" + appId);\n     }\n     List\u003cFileStatus\u003e allFiles \u003d getAllNodeFiles(nodeFiles, appId);\n     if (allFiles.isEmpty()) {\n-      throw new IOException(\"There is no available log fils for \"\n+      throw new IOException(\"There is no available log file for \"\n           + \"application:\" + appId);\n     }\n     Map\u003cString, Long\u003e checkSumFiles \u003d parseCheckSumFiles(allFiles);\n     List\u003cFileStatus\u003e fileToRead \u003d getNodeLogFileToRead(\n         allFiles, nodeIdStr, appId);\n     byte[] buf \u003d new byte[65535];\n     for (FileStatus thisNodeFile : fileToRead) {\n       String nodeName \u003d thisNodeFile.getPath().getName();\n       Long checkSumIndex \u003d checkSumFiles.get(nodeName);\n       long endIndex \u003d -1;\n       if (checkSumIndex !\u003d null) {\n         endIndex \u003d checkSumIndex.longValue();\n       }\n       IndexedLogsMeta indexedLogsMeta \u003d null;\n       try {\n         indexedLogsMeta \u003d loadIndexedLogsMeta(thisNodeFile.getPath(),\n             endIndex, appId);\n       } catch (Exception ex) {\n         // DO NOTHING\n         LOG.warn(\"Can not load log meta from the log file:\"\n             + thisNodeFile.getPath() + \"\\n\" + ex.getMessage());\n         continue;\n       }\n       if (indexedLogsMeta \u003d\u003d null) {\n         continue;\n       }\n       String compressAlgo \u003d indexedLogsMeta.getCompressName();\n       List\u003cIndexedFileLogMeta\u003e candidates \u003d new ArrayList\u003c\u003e();\n       for (IndexedPerAggregationLogMeta logMeta\n           : indexedLogsMeta.getLogMetas()) {\n         for (Entry\u003cString, List\u003cIndexedFileLogMeta\u003e\u003e meta\n             : logMeta.getLogMetas().entrySet()) {\n           for (IndexedFileLogMeta log : meta.getValue()) {\n             if (!getAllContainers \u0026\u0026 !log.getContainerId()\n                 .equals(containerIdStr)) {\n               continue;\n             }\n             if (logTypes !\u003d null \u0026\u0026 !logTypes.isEmpty() \u0026\u0026\n                 !logTypes.contains(log.getFileName())) {\n               continue;\n             }\n             candidates.add(log);\n           }\n         }\n       }\n       if (candidates.isEmpty()) {\n         continue;\n       }\n \n       Algorithm compressName \u003d Compression.getCompressionAlgorithmByName(\n           compressAlgo);\n       Decompressor decompressor \u003d compressName.getDecompressor();\n       FileContext fileContext \u003d FileContext.getFileContext(\n           thisNodeFile.getPath().toUri(), conf);\n       FSDataInputStream fsin \u003d fileContext.open(thisNodeFile.getPath());\n       String currentContainer \u003d \"\";\n       for (IndexedFileLogMeta candidate : candidates) {\n         if (!candidate.getContainerId().equals(currentContainer)) {\n           if (createPrintStream) {\n             closePrintStream(os);\n             os \u003d LogToolUtils.createPrintStream(\n                 logRequest.getOutputLocalDir(),\n                 thisNodeFile.getPath().getName(),\n                 candidate.getContainerId());\n             currentContainer \u003d candidate.getContainerId();\n           }\n         }\n         InputStream in \u003d null;\n         try {\n           in \u003d compressName.createDecompressionStream(\n               new BoundedRangeFileInputStream(fsin,\n                   candidate.getStartIndex(),\n                   candidate.getFileCompressedSize()),\n               decompressor, getFSInputBufferSize(conf));\n           LogToolUtils.outputContainerLog(candidate.getContainerId(),\n               nodeName, candidate.getFileName(), candidate.getFileSize(), size,\n-              Times.format(candidate.getLastModificatedTime()),\n+              Times.format(candidate.getLastModifiedTime()),\n               in, os, buf, ContainerLogAggregationType.AGGREGATED);\n           byte[] b \u003d aggregatedLogSuffix(candidate.getFileName())\n               .getBytes(Charset.forName(\"UTF-8\"));\n           os.write(b, 0, b.length);\n           findLogs \u003d true;\n         } catch (IOException e) {\n           System.err.println(e.getMessage());\n           compressName.returnDecompressor(decompressor);\n           continue;\n         } finally {\n           os.flush();\n           IOUtils.cleanupWithLogger(LOG, in);\n         }\n       }\n     }\n     return findLogs;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean readAggregatedLogs(ContainerLogsRequest logRequest,\n      OutputStream os) throws IOException {\n    boolean findLogs \u003d false;\n    boolean createPrintStream \u003d (os \u003d\u003d null);\n    ApplicationId appId \u003d logRequest.getAppId();\n    String nodeId \u003d logRequest.getNodeId();\n    String nodeIdStr \u003d (nodeId \u003d\u003d null || nodeId.isEmpty()) ? null\n        : LogAggregationUtils.getNodeString(nodeId);\n    List\u003cString\u003e logTypes \u003d new ArrayList\u003c\u003e();\n    if (logRequest.getLogTypes() !\u003d null \u0026\u0026 !logRequest\n        .getLogTypes().isEmpty()) {\n      logTypes.addAll(logRequest.getLogTypes());\n    }\n    String containerIdStr \u003d logRequest.getContainerId();\n    boolean getAllContainers \u003d (containerIdStr \u003d\u003d null\n        || containerIdStr.isEmpty());\n    long size \u003d logRequest.getBytes();\n    RemoteIterator\u003cFileStatus\u003e nodeFiles \u003d LogAggregationUtils\n        .getRemoteNodeFileDir(conf, appId, logRequest.getAppOwner(),\n        this.remoteRootLogDir, this.remoteRootLogDirSuffix);\n    if (!nodeFiles.hasNext()) {\n      throw new IOException(\"There is no available log file for \"\n          + \"application:\" + appId);\n    }\n    List\u003cFileStatus\u003e allFiles \u003d getAllNodeFiles(nodeFiles, appId);\n    if (allFiles.isEmpty()) {\n      throw new IOException(\"There is no available log file for \"\n          + \"application:\" + appId);\n    }\n    Map\u003cString, Long\u003e checkSumFiles \u003d parseCheckSumFiles(allFiles);\n    List\u003cFileStatus\u003e fileToRead \u003d getNodeLogFileToRead(\n        allFiles, nodeIdStr, appId);\n    byte[] buf \u003d new byte[65535];\n    for (FileStatus thisNodeFile : fileToRead) {\n      String nodeName \u003d thisNodeFile.getPath().getName();\n      Long checkSumIndex \u003d checkSumFiles.get(nodeName);\n      long endIndex \u003d -1;\n      if (checkSumIndex !\u003d null) {\n        endIndex \u003d checkSumIndex.longValue();\n      }\n      IndexedLogsMeta indexedLogsMeta \u003d null;\n      try {\n        indexedLogsMeta \u003d loadIndexedLogsMeta(thisNodeFile.getPath(),\n            endIndex, appId);\n      } catch (Exception ex) {\n        // DO NOTHING\n        LOG.warn(\"Can not load log meta from the log file:\"\n            + thisNodeFile.getPath() + \"\\n\" + ex.getMessage());\n        continue;\n      }\n      if (indexedLogsMeta \u003d\u003d null) {\n        continue;\n      }\n      String compressAlgo \u003d indexedLogsMeta.getCompressName();\n      List\u003cIndexedFileLogMeta\u003e candidates \u003d new ArrayList\u003c\u003e();\n      for (IndexedPerAggregationLogMeta logMeta\n          : indexedLogsMeta.getLogMetas()) {\n        for (Entry\u003cString, List\u003cIndexedFileLogMeta\u003e\u003e meta\n            : logMeta.getLogMetas().entrySet()) {\n          for (IndexedFileLogMeta log : meta.getValue()) {\n            if (!getAllContainers \u0026\u0026 !log.getContainerId()\n                .equals(containerIdStr)) {\n              continue;\n            }\n            if (logTypes !\u003d null \u0026\u0026 !logTypes.isEmpty() \u0026\u0026\n                !logTypes.contains(log.getFileName())) {\n              continue;\n            }\n            candidates.add(log);\n          }\n        }\n      }\n      if (candidates.isEmpty()) {\n        continue;\n      }\n\n      Algorithm compressName \u003d Compression.getCompressionAlgorithmByName(\n          compressAlgo);\n      Decompressor decompressor \u003d compressName.getDecompressor();\n      FileContext fileContext \u003d FileContext.getFileContext(\n          thisNodeFile.getPath().toUri(), conf);\n      FSDataInputStream fsin \u003d fileContext.open(thisNodeFile.getPath());\n      String currentContainer \u003d \"\";\n      for (IndexedFileLogMeta candidate : candidates) {\n        if (!candidate.getContainerId().equals(currentContainer)) {\n          if (createPrintStream) {\n            closePrintStream(os);\n            os \u003d LogToolUtils.createPrintStream(\n                logRequest.getOutputLocalDir(),\n                thisNodeFile.getPath().getName(),\n                candidate.getContainerId());\n            currentContainer \u003d candidate.getContainerId();\n          }\n        }\n        InputStream in \u003d null;\n        try {\n          in \u003d compressName.createDecompressionStream(\n              new BoundedRangeFileInputStream(fsin,\n                  candidate.getStartIndex(),\n                  candidate.getFileCompressedSize()),\n              decompressor, getFSInputBufferSize(conf));\n          LogToolUtils.outputContainerLog(candidate.getContainerId(),\n              nodeName, candidate.getFileName(), candidate.getFileSize(), size,\n              Times.format(candidate.getLastModifiedTime()),\n              in, os, buf, ContainerLogAggregationType.AGGREGATED);\n          byte[] b \u003d aggregatedLogSuffix(candidate.getFileName())\n              .getBytes(Charset.forName(\"UTF-8\"));\n          os.write(b, 0, b.length);\n          findLogs \u003d true;\n        } catch (IOException e) {\n          System.err.println(e.getMessage());\n          compressName.returnDecompressor(decompressor);\n          continue;\n        } finally {\n          os.flush();\n          IOUtils.cleanupWithLogger(LOG, in);\n        }\n      }\n    }\n    return findLogs;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/filecontroller/ifile/LogAggregationIndexedFileController.java",
      "extendedDetails": {}
    },
    "583f4594314b3db25b57b1e46ea8026eab21f932": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7891. LogAggregationIndexedFileController should support read from HAR file. (Xuan Gong via wangda)\n\nChange-Id: I16e081f21c5f80160564c49cc49d103bd8eb7e16\n",
      "commitDate": "07/03/18 3:46 PM",
      "commitName": "583f4594314b3db25b57b1e46ea8026eab21f932",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "07/03/18 3:46 PM",
      "commitNameOld": "e718ac597f2225cb4946e1ac4b3986c336645643",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,116 +1,121 @@\n   public boolean readAggregatedLogs(ContainerLogsRequest logRequest,\n       OutputStream os) throws IOException {\n     boolean findLogs \u003d false;\n     boolean createPrintStream \u003d (os \u003d\u003d null);\n     ApplicationId appId \u003d logRequest.getAppId();\n     String nodeId \u003d logRequest.getNodeId();\n     String nodeIdStr \u003d (nodeId \u003d\u003d null || nodeId.isEmpty()) ? null\n         : LogAggregationUtils.getNodeString(nodeId);\n     List\u003cString\u003e logTypes \u003d new ArrayList\u003c\u003e();\n     if (logRequest.getLogTypes() !\u003d null \u0026\u0026 !logRequest\n         .getLogTypes().isEmpty()) {\n       logTypes.addAll(logRequest.getLogTypes());\n     }\n     String containerIdStr \u003d logRequest.getContainerId();\n     boolean getAllContainers \u003d (containerIdStr \u003d\u003d null\n         || containerIdStr.isEmpty());\n     long size \u003d logRequest.getBytes();\n-    List\u003cFileStatus\u003e nodeFiles \u003d LogAggregationUtils\n-        .getRemoteNodeFileList(conf, appId, logRequest.getAppOwner(),\n+    RemoteIterator\u003cFileStatus\u003e nodeFiles \u003d LogAggregationUtils\n+        .getRemoteNodeFileDir(conf, appId, logRequest.getAppOwner(),\n         this.remoteRootLogDir, this.remoteRootLogDirSuffix);\n-    if (nodeFiles.isEmpty()) {\n+    if (!nodeFiles.hasNext()) {\n       throw new IOException(\"There is no available log fils for \"\n           + \"application:\" + appId);\n     }\n-    Map\u003cString, Long\u003e checkSumFiles \u003d parseCheckSumFiles(nodeFiles);\n+    List\u003cFileStatus\u003e allFiles \u003d getAllNodeFiles(nodeFiles, appId);\n+    if (allFiles.isEmpty()) {\n+      throw new IOException(\"There is no available log fils for \"\n+          + \"application:\" + appId);\n+    }\n+    Map\u003cString, Long\u003e checkSumFiles \u003d parseCheckSumFiles(allFiles);\n     List\u003cFileStatus\u003e fileToRead \u003d getNodeLogFileToRead(\n-        nodeFiles, nodeIdStr, appId);\n+        allFiles, nodeIdStr, appId);\n     byte[] buf \u003d new byte[65535];\n     for (FileStatus thisNodeFile : fileToRead) {\n       String nodeName \u003d thisNodeFile.getPath().getName();\n       Long checkSumIndex \u003d checkSumFiles.get(nodeName);\n       long endIndex \u003d -1;\n       if (checkSumIndex !\u003d null) {\n         endIndex \u003d checkSumIndex.longValue();\n       }\n       IndexedLogsMeta indexedLogsMeta \u003d null;\n       try {\n         indexedLogsMeta \u003d loadIndexedLogsMeta(thisNodeFile.getPath(),\n             endIndex, appId);\n       } catch (Exception ex) {\n         // DO NOTHING\n         LOG.warn(\"Can not load log meta from the log file:\"\n             + thisNodeFile.getPath() + \"\\n\" + ex.getMessage());\n         continue;\n       }\n       if (indexedLogsMeta \u003d\u003d null) {\n         continue;\n       }\n       String compressAlgo \u003d indexedLogsMeta.getCompressName();\n       List\u003cIndexedFileLogMeta\u003e candidates \u003d new ArrayList\u003c\u003e();\n       for (IndexedPerAggregationLogMeta logMeta\n           : indexedLogsMeta.getLogMetas()) {\n         for (Entry\u003cString, List\u003cIndexedFileLogMeta\u003e\u003e meta\n             : logMeta.getLogMetas().entrySet()) {\n           for (IndexedFileLogMeta log : meta.getValue()) {\n             if (!getAllContainers \u0026\u0026 !log.getContainerId()\n                 .equals(containerIdStr)) {\n               continue;\n             }\n             if (logTypes !\u003d null \u0026\u0026 !logTypes.isEmpty() \u0026\u0026\n                 !logTypes.contains(log.getFileName())) {\n               continue;\n             }\n             candidates.add(log);\n           }\n         }\n       }\n       if (candidates.isEmpty()) {\n         continue;\n       }\n \n       Algorithm compressName \u003d Compression.getCompressionAlgorithmByName(\n           compressAlgo);\n       Decompressor decompressor \u003d compressName.getDecompressor();\n       FileContext fileContext \u003d FileContext.getFileContext(\n           thisNodeFile.getPath().toUri(), conf);\n       FSDataInputStream fsin \u003d fileContext.open(thisNodeFile.getPath());\n       String currentContainer \u003d \"\";\n       for (IndexedFileLogMeta candidate : candidates) {\n         if (!candidate.getContainerId().equals(currentContainer)) {\n           if (createPrintStream) {\n             closePrintStream(os);\n             os \u003d LogToolUtils.createPrintStream(\n                 logRequest.getOutputLocalDir(),\n                 thisNodeFile.getPath().getName(),\n                 candidate.getContainerId());\n             currentContainer \u003d candidate.getContainerId();\n           }\n         }\n         InputStream in \u003d null;\n         try {\n           in \u003d compressName.createDecompressionStream(\n               new BoundedRangeFileInputStream(fsin,\n                   candidate.getStartIndex(),\n                   candidate.getFileCompressedSize()),\n               decompressor, getFSInputBufferSize(conf));\n           LogToolUtils.outputContainerLog(candidate.getContainerId(),\n               nodeName, candidate.getFileName(), candidate.getFileSize(), size,\n               Times.format(candidate.getLastModificatedTime()),\n               in, os, buf, ContainerLogAggregationType.AGGREGATED);\n           byte[] b \u003d aggregatedLogSuffix(candidate.getFileName())\n               .getBytes(Charset.forName(\"UTF-8\"));\n           os.write(b, 0, b.length);\n           findLogs \u003d true;\n         } catch (IOException e) {\n           System.err.println(e.getMessage());\n           compressName.returnDecompressor(decompressor);\n           continue;\n         } finally {\n           os.flush();\n           IOUtils.cleanupWithLogger(LOG, in);\n         }\n       }\n     }\n     return findLogs;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean readAggregatedLogs(ContainerLogsRequest logRequest,\n      OutputStream os) throws IOException {\n    boolean findLogs \u003d false;\n    boolean createPrintStream \u003d (os \u003d\u003d null);\n    ApplicationId appId \u003d logRequest.getAppId();\n    String nodeId \u003d logRequest.getNodeId();\n    String nodeIdStr \u003d (nodeId \u003d\u003d null || nodeId.isEmpty()) ? null\n        : LogAggregationUtils.getNodeString(nodeId);\n    List\u003cString\u003e logTypes \u003d new ArrayList\u003c\u003e();\n    if (logRequest.getLogTypes() !\u003d null \u0026\u0026 !logRequest\n        .getLogTypes().isEmpty()) {\n      logTypes.addAll(logRequest.getLogTypes());\n    }\n    String containerIdStr \u003d logRequest.getContainerId();\n    boolean getAllContainers \u003d (containerIdStr \u003d\u003d null\n        || containerIdStr.isEmpty());\n    long size \u003d logRequest.getBytes();\n    RemoteIterator\u003cFileStatus\u003e nodeFiles \u003d LogAggregationUtils\n        .getRemoteNodeFileDir(conf, appId, logRequest.getAppOwner(),\n        this.remoteRootLogDir, this.remoteRootLogDirSuffix);\n    if (!nodeFiles.hasNext()) {\n      throw new IOException(\"There is no available log fils for \"\n          + \"application:\" + appId);\n    }\n    List\u003cFileStatus\u003e allFiles \u003d getAllNodeFiles(nodeFiles, appId);\n    if (allFiles.isEmpty()) {\n      throw new IOException(\"There is no available log fils for \"\n          + \"application:\" + appId);\n    }\n    Map\u003cString, Long\u003e checkSumFiles \u003d parseCheckSumFiles(allFiles);\n    List\u003cFileStatus\u003e fileToRead \u003d getNodeLogFileToRead(\n        allFiles, nodeIdStr, appId);\n    byte[] buf \u003d new byte[65535];\n    for (FileStatus thisNodeFile : fileToRead) {\n      String nodeName \u003d thisNodeFile.getPath().getName();\n      Long checkSumIndex \u003d checkSumFiles.get(nodeName);\n      long endIndex \u003d -1;\n      if (checkSumIndex !\u003d null) {\n        endIndex \u003d checkSumIndex.longValue();\n      }\n      IndexedLogsMeta indexedLogsMeta \u003d null;\n      try {\n        indexedLogsMeta \u003d loadIndexedLogsMeta(thisNodeFile.getPath(),\n            endIndex, appId);\n      } catch (Exception ex) {\n        // DO NOTHING\n        LOG.warn(\"Can not load log meta from the log file:\"\n            + thisNodeFile.getPath() + \"\\n\" + ex.getMessage());\n        continue;\n      }\n      if (indexedLogsMeta \u003d\u003d null) {\n        continue;\n      }\n      String compressAlgo \u003d indexedLogsMeta.getCompressName();\n      List\u003cIndexedFileLogMeta\u003e candidates \u003d new ArrayList\u003c\u003e();\n      for (IndexedPerAggregationLogMeta logMeta\n          : indexedLogsMeta.getLogMetas()) {\n        for (Entry\u003cString, List\u003cIndexedFileLogMeta\u003e\u003e meta\n            : logMeta.getLogMetas().entrySet()) {\n          for (IndexedFileLogMeta log : meta.getValue()) {\n            if (!getAllContainers \u0026\u0026 !log.getContainerId()\n                .equals(containerIdStr)) {\n              continue;\n            }\n            if (logTypes !\u003d null \u0026\u0026 !logTypes.isEmpty() \u0026\u0026\n                !logTypes.contains(log.getFileName())) {\n              continue;\n            }\n            candidates.add(log);\n          }\n        }\n      }\n      if (candidates.isEmpty()) {\n        continue;\n      }\n\n      Algorithm compressName \u003d Compression.getCompressionAlgorithmByName(\n          compressAlgo);\n      Decompressor decompressor \u003d compressName.getDecompressor();\n      FileContext fileContext \u003d FileContext.getFileContext(\n          thisNodeFile.getPath().toUri(), conf);\n      FSDataInputStream fsin \u003d fileContext.open(thisNodeFile.getPath());\n      String currentContainer \u003d \"\";\n      for (IndexedFileLogMeta candidate : candidates) {\n        if (!candidate.getContainerId().equals(currentContainer)) {\n          if (createPrintStream) {\n            closePrintStream(os);\n            os \u003d LogToolUtils.createPrintStream(\n                logRequest.getOutputLocalDir(),\n                thisNodeFile.getPath().getName(),\n                candidate.getContainerId());\n            currentContainer \u003d candidate.getContainerId();\n          }\n        }\n        InputStream in \u003d null;\n        try {\n          in \u003d compressName.createDecompressionStream(\n              new BoundedRangeFileInputStream(fsin,\n                  candidate.getStartIndex(),\n                  candidate.getFileCompressedSize()),\n              decompressor, getFSInputBufferSize(conf));\n          LogToolUtils.outputContainerLog(candidate.getContainerId(),\n              nodeName, candidate.getFileName(), candidate.getFileSize(), size,\n              Times.format(candidate.getLastModificatedTime()),\n              in, os, buf, ContainerLogAggregationType.AGGREGATED);\n          byte[] b \u003d aggregatedLogSuffix(candidate.getFileName())\n              .getBytes(Charset.forName(\"UTF-8\"));\n          os.write(b, 0, b.length);\n          findLogs \u003d true;\n        } catch (IOException e) {\n          System.err.println(e.getMessage());\n          compressName.returnDecompressor(decompressor);\n          continue;\n        } finally {\n          os.flush();\n          IOUtils.cleanupWithLogger(LOG, in);\n        }\n      }\n    }\n    return findLogs;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/filecontroller/ifile/LogAggregationIndexedFileController.java",
      "extendedDetails": {}
    },
    "e718ac597f2225cb4946e1ac4b3986c336645643": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"YARN-7891. LogAggregationIndexedFileController should support read from HAR file. (Xuan Gong via wangda)\"\n\nThis reverts commit 4d53ef7eefb14661d824924e503a910de1ae997f.\n",
      "commitDate": "07/03/18 3:46 PM",
      "commitName": "e718ac597f2225cb4946e1ac4b3986c336645643",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "07/03/18 11:30 AM",
      "commitNameOld": "4d53ef7eefb14661d824924e503a910de1ae997f",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 0.18,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,121 +1,116 @@\n   public boolean readAggregatedLogs(ContainerLogsRequest logRequest,\n       OutputStream os) throws IOException {\n     boolean findLogs \u003d false;\n     boolean createPrintStream \u003d (os \u003d\u003d null);\n     ApplicationId appId \u003d logRequest.getAppId();\n     String nodeId \u003d logRequest.getNodeId();\n     String nodeIdStr \u003d (nodeId \u003d\u003d null || nodeId.isEmpty()) ? null\n         : LogAggregationUtils.getNodeString(nodeId);\n     List\u003cString\u003e logTypes \u003d new ArrayList\u003c\u003e();\n     if (logRequest.getLogTypes() !\u003d null \u0026\u0026 !logRequest\n         .getLogTypes().isEmpty()) {\n       logTypes.addAll(logRequest.getLogTypes());\n     }\n     String containerIdStr \u003d logRequest.getContainerId();\n     boolean getAllContainers \u003d (containerIdStr \u003d\u003d null\n         || containerIdStr.isEmpty());\n     long size \u003d logRequest.getBytes();\n-    RemoteIterator\u003cFileStatus\u003e nodeFiles \u003d LogAggregationUtils\n-        .getRemoteNodeFileDir(conf, appId, logRequest.getAppOwner(),\n+    List\u003cFileStatus\u003e nodeFiles \u003d LogAggregationUtils\n+        .getRemoteNodeFileList(conf, appId, logRequest.getAppOwner(),\n         this.remoteRootLogDir, this.remoteRootLogDirSuffix);\n-    if (!nodeFiles.hasNext()) {\n+    if (nodeFiles.isEmpty()) {\n       throw new IOException(\"There is no available log fils for \"\n           + \"application:\" + appId);\n     }\n-    List\u003cFileStatus\u003e allFiles \u003d getAllNodeFiles(nodeFiles, appId);\n-    if (allFiles.isEmpty()) {\n-      throw new IOException(\"There is no available log fils for \"\n-          + \"application:\" + appId);\n-    }\n-    Map\u003cString, Long\u003e checkSumFiles \u003d parseCheckSumFiles(allFiles);\n+    Map\u003cString, Long\u003e checkSumFiles \u003d parseCheckSumFiles(nodeFiles);\n     List\u003cFileStatus\u003e fileToRead \u003d getNodeLogFileToRead(\n-        allFiles, nodeIdStr, appId);\n+        nodeFiles, nodeIdStr, appId);\n     byte[] buf \u003d new byte[65535];\n     for (FileStatus thisNodeFile : fileToRead) {\n       String nodeName \u003d thisNodeFile.getPath().getName();\n       Long checkSumIndex \u003d checkSumFiles.get(nodeName);\n       long endIndex \u003d -1;\n       if (checkSumIndex !\u003d null) {\n         endIndex \u003d checkSumIndex.longValue();\n       }\n       IndexedLogsMeta indexedLogsMeta \u003d null;\n       try {\n         indexedLogsMeta \u003d loadIndexedLogsMeta(thisNodeFile.getPath(),\n             endIndex, appId);\n       } catch (Exception ex) {\n         // DO NOTHING\n         LOG.warn(\"Can not load log meta from the log file:\"\n             + thisNodeFile.getPath() + \"\\n\" + ex.getMessage());\n         continue;\n       }\n       if (indexedLogsMeta \u003d\u003d null) {\n         continue;\n       }\n       String compressAlgo \u003d indexedLogsMeta.getCompressName();\n       List\u003cIndexedFileLogMeta\u003e candidates \u003d new ArrayList\u003c\u003e();\n       for (IndexedPerAggregationLogMeta logMeta\n           : indexedLogsMeta.getLogMetas()) {\n         for (Entry\u003cString, List\u003cIndexedFileLogMeta\u003e\u003e meta\n             : logMeta.getLogMetas().entrySet()) {\n           for (IndexedFileLogMeta log : meta.getValue()) {\n             if (!getAllContainers \u0026\u0026 !log.getContainerId()\n                 .equals(containerIdStr)) {\n               continue;\n             }\n             if (logTypes !\u003d null \u0026\u0026 !logTypes.isEmpty() \u0026\u0026\n                 !logTypes.contains(log.getFileName())) {\n               continue;\n             }\n             candidates.add(log);\n           }\n         }\n       }\n       if (candidates.isEmpty()) {\n         continue;\n       }\n \n       Algorithm compressName \u003d Compression.getCompressionAlgorithmByName(\n           compressAlgo);\n       Decompressor decompressor \u003d compressName.getDecompressor();\n       FileContext fileContext \u003d FileContext.getFileContext(\n           thisNodeFile.getPath().toUri(), conf);\n       FSDataInputStream fsin \u003d fileContext.open(thisNodeFile.getPath());\n       String currentContainer \u003d \"\";\n       for (IndexedFileLogMeta candidate : candidates) {\n         if (!candidate.getContainerId().equals(currentContainer)) {\n           if (createPrintStream) {\n             closePrintStream(os);\n             os \u003d LogToolUtils.createPrintStream(\n                 logRequest.getOutputLocalDir(),\n                 thisNodeFile.getPath().getName(),\n                 candidate.getContainerId());\n             currentContainer \u003d candidate.getContainerId();\n           }\n         }\n         InputStream in \u003d null;\n         try {\n           in \u003d compressName.createDecompressionStream(\n               new BoundedRangeFileInputStream(fsin,\n                   candidate.getStartIndex(),\n                   candidate.getFileCompressedSize()),\n               decompressor, getFSInputBufferSize(conf));\n           LogToolUtils.outputContainerLog(candidate.getContainerId(),\n               nodeName, candidate.getFileName(), candidate.getFileSize(), size,\n               Times.format(candidate.getLastModificatedTime()),\n               in, os, buf, ContainerLogAggregationType.AGGREGATED);\n           byte[] b \u003d aggregatedLogSuffix(candidate.getFileName())\n               .getBytes(Charset.forName(\"UTF-8\"));\n           os.write(b, 0, b.length);\n           findLogs \u003d true;\n         } catch (IOException e) {\n           System.err.println(e.getMessage());\n           compressName.returnDecompressor(decompressor);\n           continue;\n         } finally {\n           os.flush();\n           IOUtils.cleanupWithLogger(LOG, in);\n         }\n       }\n     }\n     return findLogs;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean readAggregatedLogs(ContainerLogsRequest logRequest,\n      OutputStream os) throws IOException {\n    boolean findLogs \u003d false;\n    boolean createPrintStream \u003d (os \u003d\u003d null);\n    ApplicationId appId \u003d logRequest.getAppId();\n    String nodeId \u003d logRequest.getNodeId();\n    String nodeIdStr \u003d (nodeId \u003d\u003d null || nodeId.isEmpty()) ? null\n        : LogAggregationUtils.getNodeString(nodeId);\n    List\u003cString\u003e logTypes \u003d new ArrayList\u003c\u003e();\n    if (logRequest.getLogTypes() !\u003d null \u0026\u0026 !logRequest\n        .getLogTypes().isEmpty()) {\n      logTypes.addAll(logRequest.getLogTypes());\n    }\n    String containerIdStr \u003d logRequest.getContainerId();\n    boolean getAllContainers \u003d (containerIdStr \u003d\u003d null\n        || containerIdStr.isEmpty());\n    long size \u003d logRequest.getBytes();\n    List\u003cFileStatus\u003e nodeFiles \u003d LogAggregationUtils\n        .getRemoteNodeFileList(conf, appId, logRequest.getAppOwner(),\n        this.remoteRootLogDir, this.remoteRootLogDirSuffix);\n    if (nodeFiles.isEmpty()) {\n      throw new IOException(\"There is no available log fils for \"\n          + \"application:\" + appId);\n    }\n    Map\u003cString, Long\u003e checkSumFiles \u003d parseCheckSumFiles(nodeFiles);\n    List\u003cFileStatus\u003e fileToRead \u003d getNodeLogFileToRead(\n        nodeFiles, nodeIdStr, appId);\n    byte[] buf \u003d new byte[65535];\n    for (FileStatus thisNodeFile : fileToRead) {\n      String nodeName \u003d thisNodeFile.getPath().getName();\n      Long checkSumIndex \u003d checkSumFiles.get(nodeName);\n      long endIndex \u003d -1;\n      if (checkSumIndex !\u003d null) {\n        endIndex \u003d checkSumIndex.longValue();\n      }\n      IndexedLogsMeta indexedLogsMeta \u003d null;\n      try {\n        indexedLogsMeta \u003d loadIndexedLogsMeta(thisNodeFile.getPath(),\n            endIndex, appId);\n      } catch (Exception ex) {\n        // DO NOTHING\n        LOG.warn(\"Can not load log meta from the log file:\"\n            + thisNodeFile.getPath() + \"\\n\" + ex.getMessage());\n        continue;\n      }\n      if (indexedLogsMeta \u003d\u003d null) {\n        continue;\n      }\n      String compressAlgo \u003d indexedLogsMeta.getCompressName();\n      List\u003cIndexedFileLogMeta\u003e candidates \u003d new ArrayList\u003c\u003e();\n      for (IndexedPerAggregationLogMeta logMeta\n          : indexedLogsMeta.getLogMetas()) {\n        for (Entry\u003cString, List\u003cIndexedFileLogMeta\u003e\u003e meta\n            : logMeta.getLogMetas().entrySet()) {\n          for (IndexedFileLogMeta log : meta.getValue()) {\n            if (!getAllContainers \u0026\u0026 !log.getContainerId()\n                .equals(containerIdStr)) {\n              continue;\n            }\n            if (logTypes !\u003d null \u0026\u0026 !logTypes.isEmpty() \u0026\u0026\n                !logTypes.contains(log.getFileName())) {\n              continue;\n            }\n            candidates.add(log);\n          }\n        }\n      }\n      if (candidates.isEmpty()) {\n        continue;\n      }\n\n      Algorithm compressName \u003d Compression.getCompressionAlgorithmByName(\n          compressAlgo);\n      Decompressor decompressor \u003d compressName.getDecompressor();\n      FileContext fileContext \u003d FileContext.getFileContext(\n          thisNodeFile.getPath().toUri(), conf);\n      FSDataInputStream fsin \u003d fileContext.open(thisNodeFile.getPath());\n      String currentContainer \u003d \"\";\n      for (IndexedFileLogMeta candidate : candidates) {\n        if (!candidate.getContainerId().equals(currentContainer)) {\n          if (createPrintStream) {\n            closePrintStream(os);\n            os \u003d LogToolUtils.createPrintStream(\n                logRequest.getOutputLocalDir(),\n                thisNodeFile.getPath().getName(),\n                candidate.getContainerId());\n            currentContainer \u003d candidate.getContainerId();\n          }\n        }\n        InputStream in \u003d null;\n        try {\n          in \u003d compressName.createDecompressionStream(\n              new BoundedRangeFileInputStream(fsin,\n                  candidate.getStartIndex(),\n                  candidate.getFileCompressedSize()),\n              decompressor, getFSInputBufferSize(conf));\n          LogToolUtils.outputContainerLog(candidate.getContainerId(),\n              nodeName, candidate.getFileName(), candidate.getFileSize(), size,\n              Times.format(candidate.getLastModificatedTime()),\n              in, os, buf, ContainerLogAggregationType.AGGREGATED);\n          byte[] b \u003d aggregatedLogSuffix(candidate.getFileName())\n              .getBytes(Charset.forName(\"UTF-8\"));\n          os.write(b, 0, b.length);\n          findLogs \u003d true;\n        } catch (IOException e) {\n          System.err.println(e.getMessage());\n          compressName.returnDecompressor(decompressor);\n          continue;\n        } finally {\n          os.flush();\n          IOUtils.cleanupWithLogger(LOG, in);\n        }\n      }\n    }\n    return findLogs;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/filecontroller/ifile/LogAggregationIndexedFileController.java",
      "extendedDetails": {}
    },
    "4d53ef7eefb14661d824924e503a910de1ae997f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7891. LogAggregationIndexedFileController should support read from HAR file. (Xuan Gong via wangda)\n\nChange-Id: Ie16e34039d57df50128c73b37516ad0bc7c9590e\n",
      "commitDate": "07/03/18 11:30 AM",
      "commitName": "4d53ef7eefb14661d824924e503a910de1ae997f",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "11/02/18 6:28 PM",
      "commitNameOld": "d4c98579e36df7eeb788352d7b76cd2c7448c511",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 23.71,
      "commitsBetweenForRepo": 154,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,116 +1,121 @@\n   public boolean readAggregatedLogs(ContainerLogsRequest logRequest,\n       OutputStream os) throws IOException {\n     boolean findLogs \u003d false;\n     boolean createPrintStream \u003d (os \u003d\u003d null);\n     ApplicationId appId \u003d logRequest.getAppId();\n     String nodeId \u003d logRequest.getNodeId();\n     String nodeIdStr \u003d (nodeId \u003d\u003d null || nodeId.isEmpty()) ? null\n         : LogAggregationUtils.getNodeString(nodeId);\n     List\u003cString\u003e logTypes \u003d new ArrayList\u003c\u003e();\n     if (logRequest.getLogTypes() !\u003d null \u0026\u0026 !logRequest\n         .getLogTypes().isEmpty()) {\n       logTypes.addAll(logRequest.getLogTypes());\n     }\n     String containerIdStr \u003d logRequest.getContainerId();\n     boolean getAllContainers \u003d (containerIdStr \u003d\u003d null\n         || containerIdStr.isEmpty());\n     long size \u003d logRequest.getBytes();\n-    List\u003cFileStatus\u003e nodeFiles \u003d LogAggregationUtils\n-        .getRemoteNodeFileList(conf, appId, logRequest.getAppOwner(),\n+    RemoteIterator\u003cFileStatus\u003e nodeFiles \u003d LogAggregationUtils\n+        .getRemoteNodeFileDir(conf, appId, logRequest.getAppOwner(),\n         this.remoteRootLogDir, this.remoteRootLogDirSuffix);\n-    if (nodeFiles.isEmpty()) {\n+    if (!nodeFiles.hasNext()) {\n       throw new IOException(\"There is no available log fils for \"\n           + \"application:\" + appId);\n     }\n-    Map\u003cString, Long\u003e checkSumFiles \u003d parseCheckSumFiles(nodeFiles);\n+    List\u003cFileStatus\u003e allFiles \u003d getAllNodeFiles(nodeFiles, appId);\n+    if (allFiles.isEmpty()) {\n+      throw new IOException(\"There is no available log fils for \"\n+          + \"application:\" + appId);\n+    }\n+    Map\u003cString, Long\u003e checkSumFiles \u003d parseCheckSumFiles(allFiles);\n     List\u003cFileStatus\u003e fileToRead \u003d getNodeLogFileToRead(\n-        nodeFiles, nodeIdStr, appId);\n+        allFiles, nodeIdStr, appId);\n     byte[] buf \u003d new byte[65535];\n     for (FileStatus thisNodeFile : fileToRead) {\n       String nodeName \u003d thisNodeFile.getPath().getName();\n       Long checkSumIndex \u003d checkSumFiles.get(nodeName);\n       long endIndex \u003d -1;\n       if (checkSumIndex !\u003d null) {\n         endIndex \u003d checkSumIndex.longValue();\n       }\n       IndexedLogsMeta indexedLogsMeta \u003d null;\n       try {\n         indexedLogsMeta \u003d loadIndexedLogsMeta(thisNodeFile.getPath(),\n             endIndex, appId);\n       } catch (Exception ex) {\n         // DO NOTHING\n         LOG.warn(\"Can not load log meta from the log file:\"\n             + thisNodeFile.getPath() + \"\\n\" + ex.getMessage());\n         continue;\n       }\n       if (indexedLogsMeta \u003d\u003d null) {\n         continue;\n       }\n       String compressAlgo \u003d indexedLogsMeta.getCompressName();\n       List\u003cIndexedFileLogMeta\u003e candidates \u003d new ArrayList\u003c\u003e();\n       for (IndexedPerAggregationLogMeta logMeta\n           : indexedLogsMeta.getLogMetas()) {\n         for (Entry\u003cString, List\u003cIndexedFileLogMeta\u003e\u003e meta\n             : logMeta.getLogMetas().entrySet()) {\n           for (IndexedFileLogMeta log : meta.getValue()) {\n             if (!getAllContainers \u0026\u0026 !log.getContainerId()\n                 .equals(containerIdStr)) {\n               continue;\n             }\n             if (logTypes !\u003d null \u0026\u0026 !logTypes.isEmpty() \u0026\u0026\n                 !logTypes.contains(log.getFileName())) {\n               continue;\n             }\n             candidates.add(log);\n           }\n         }\n       }\n       if (candidates.isEmpty()) {\n         continue;\n       }\n \n       Algorithm compressName \u003d Compression.getCompressionAlgorithmByName(\n           compressAlgo);\n       Decompressor decompressor \u003d compressName.getDecompressor();\n       FileContext fileContext \u003d FileContext.getFileContext(\n           thisNodeFile.getPath().toUri(), conf);\n       FSDataInputStream fsin \u003d fileContext.open(thisNodeFile.getPath());\n       String currentContainer \u003d \"\";\n       for (IndexedFileLogMeta candidate : candidates) {\n         if (!candidate.getContainerId().equals(currentContainer)) {\n           if (createPrintStream) {\n             closePrintStream(os);\n             os \u003d LogToolUtils.createPrintStream(\n                 logRequest.getOutputLocalDir(),\n                 thisNodeFile.getPath().getName(),\n                 candidate.getContainerId());\n             currentContainer \u003d candidate.getContainerId();\n           }\n         }\n         InputStream in \u003d null;\n         try {\n           in \u003d compressName.createDecompressionStream(\n               new BoundedRangeFileInputStream(fsin,\n                   candidate.getStartIndex(),\n                   candidate.getFileCompressedSize()),\n               decompressor, getFSInputBufferSize(conf));\n           LogToolUtils.outputContainerLog(candidate.getContainerId(),\n               nodeName, candidate.getFileName(), candidate.getFileSize(), size,\n               Times.format(candidate.getLastModificatedTime()),\n               in, os, buf, ContainerLogAggregationType.AGGREGATED);\n           byte[] b \u003d aggregatedLogSuffix(candidate.getFileName())\n               .getBytes(Charset.forName(\"UTF-8\"));\n           os.write(b, 0, b.length);\n           findLogs \u003d true;\n         } catch (IOException e) {\n           System.err.println(e.getMessage());\n           compressName.returnDecompressor(decompressor);\n           continue;\n         } finally {\n           os.flush();\n           IOUtils.cleanupWithLogger(LOG, in);\n         }\n       }\n     }\n     return findLogs;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean readAggregatedLogs(ContainerLogsRequest logRequest,\n      OutputStream os) throws IOException {\n    boolean findLogs \u003d false;\n    boolean createPrintStream \u003d (os \u003d\u003d null);\n    ApplicationId appId \u003d logRequest.getAppId();\n    String nodeId \u003d logRequest.getNodeId();\n    String nodeIdStr \u003d (nodeId \u003d\u003d null || nodeId.isEmpty()) ? null\n        : LogAggregationUtils.getNodeString(nodeId);\n    List\u003cString\u003e logTypes \u003d new ArrayList\u003c\u003e();\n    if (logRequest.getLogTypes() !\u003d null \u0026\u0026 !logRequest\n        .getLogTypes().isEmpty()) {\n      logTypes.addAll(logRequest.getLogTypes());\n    }\n    String containerIdStr \u003d logRequest.getContainerId();\n    boolean getAllContainers \u003d (containerIdStr \u003d\u003d null\n        || containerIdStr.isEmpty());\n    long size \u003d logRequest.getBytes();\n    RemoteIterator\u003cFileStatus\u003e nodeFiles \u003d LogAggregationUtils\n        .getRemoteNodeFileDir(conf, appId, logRequest.getAppOwner(),\n        this.remoteRootLogDir, this.remoteRootLogDirSuffix);\n    if (!nodeFiles.hasNext()) {\n      throw new IOException(\"There is no available log fils for \"\n          + \"application:\" + appId);\n    }\n    List\u003cFileStatus\u003e allFiles \u003d getAllNodeFiles(nodeFiles, appId);\n    if (allFiles.isEmpty()) {\n      throw new IOException(\"There is no available log fils for \"\n          + \"application:\" + appId);\n    }\n    Map\u003cString, Long\u003e checkSumFiles \u003d parseCheckSumFiles(allFiles);\n    List\u003cFileStatus\u003e fileToRead \u003d getNodeLogFileToRead(\n        allFiles, nodeIdStr, appId);\n    byte[] buf \u003d new byte[65535];\n    for (FileStatus thisNodeFile : fileToRead) {\n      String nodeName \u003d thisNodeFile.getPath().getName();\n      Long checkSumIndex \u003d checkSumFiles.get(nodeName);\n      long endIndex \u003d -1;\n      if (checkSumIndex !\u003d null) {\n        endIndex \u003d checkSumIndex.longValue();\n      }\n      IndexedLogsMeta indexedLogsMeta \u003d null;\n      try {\n        indexedLogsMeta \u003d loadIndexedLogsMeta(thisNodeFile.getPath(),\n            endIndex, appId);\n      } catch (Exception ex) {\n        // DO NOTHING\n        LOG.warn(\"Can not load log meta from the log file:\"\n            + thisNodeFile.getPath() + \"\\n\" + ex.getMessage());\n        continue;\n      }\n      if (indexedLogsMeta \u003d\u003d null) {\n        continue;\n      }\n      String compressAlgo \u003d indexedLogsMeta.getCompressName();\n      List\u003cIndexedFileLogMeta\u003e candidates \u003d new ArrayList\u003c\u003e();\n      for (IndexedPerAggregationLogMeta logMeta\n          : indexedLogsMeta.getLogMetas()) {\n        for (Entry\u003cString, List\u003cIndexedFileLogMeta\u003e\u003e meta\n            : logMeta.getLogMetas().entrySet()) {\n          for (IndexedFileLogMeta log : meta.getValue()) {\n            if (!getAllContainers \u0026\u0026 !log.getContainerId()\n                .equals(containerIdStr)) {\n              continue;\n            }\n            if (logTypes !\u003d null \u0026\u0026 !logTypes.isEmpty() \u0026\u0026\n                !logTypes.contains(log.getFileName())) {\n              continue;\n            }\n            candidates.add(log);\n          }\n        }\n      }\n      if (candidates.isEmpty()) {\n        continue;\n      }\n\n      Algorithm compressName \u003d Compression.getCompressionAlgorithmByName(\n          compressAlgo);\n      Decompressor decompressor \u003d compressName.getDecompressor();\n      FileContext fileContext \u003d FileContext.getFileContext(\n          thisNodeFile.getPath().toUri(), conf);\n      FSDataInputStream fsin \u003d fileContext.open(thisNodeFile.getPath());\n      String currentContainer \u003d \"\";\n      for (IndexedFileLogMeta candidate : candidates) {\n        if (!candidate.getContainerId().equals(currentContainer)) {\n          if (createPrintStream) {\n            closePrintStream(os);\n            os \u003d LogToolUtils.createPrintStream(\n                logRequest.getOutputLocalDir(),\n                thisNodeFile.getPath().getName(),\n                candidate.getContainerId());\n            currentContainer \u003d candidate.getContainerId();\n          }\n        }\n        InputStream in \u003d null;\n        try {\n          in \u003d compressName.createDecompressionStream(\n              new BoundedRangeFileInputStream(fsin,\n                  candidate.getStartIndex(),\n                  candidate.getFileCompressedSize()),\n              decompressor, getFSInputBufferSize(conf));\n          LogToolUtils.outputContainerLog(candidate.getContainerId(),\n              nodeName, candidate.getFileName(), candidate.getFileSize(), size,\n              Times.format(candidate.getLastModificatedTime()),\n              in, os, buf, ContainerLogAggregationType.AGGREGATED);\n          byte[] b \u003d aggregatedLogSuffix(candidate.getFileName())\n              .getBytes(Charset.forName(\"UTF-8\"));\n          os.write(b, 0, b.length);\n          findLogs \u003d true;\n        } catch (IOException e) {\n          System.err.println(e.getMessage());\n          compressName.returnDecompressor(decompressor);\n          continue;\n        } finally {\n          os.flush();\n          IOUtils.cleanupWithLogger(LOG, in);\n        }\n      }\n    }\n    return findLogs;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/filecontroller/ifile/LogAggregationIndexedFileController.java",
      "extendedDetails": {}
    },
    "d4c98579e36df7eeb788352d7b76cd2c7448c511": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7697. NM goes down with OOM due to leak in log-aggregation. (Xuan Gong via wangda)\n\nChange-Id: Ie4fc7979d834e25f37a033c314f3efceeb8f4a9e\n",
      "commitDate": "11/02/18 6:28 PM",
      "commitName": "d4c98579e36df7eeb788352d7b76cd2c7448c511",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "02/10/17 3:30 PM",
      "commitNameOld": "280080fad01304c85a9ede4d4f7b707eb36c0155",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 132.17,
      "commitsBetweenForRepo": 906,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,116 +1,116 @@\n   public boolean readAggregatedLogs(ContainerLogsRequest logRequest,\n       OutputStream os) throws IOException {\n     boolean findLogs \u003d false;\n     boolean createPrintStream \u003d (os \u003d\u003d null);\n     ApplicationId appId \u003d logRequest.getAppId();\n     String nodeId \u003d logRequest.getNodeId();\n     String nodeIdStr \u003d (nodeId \u003d\u003d null || nodeId.isEmpty()) ? null\n         : LogAggregationUtils.getNodeString(nodeId);\n     List\u003cString\u003e logTypes \u003d new ArrayList\u003c\u003e();\n     if (logRequest.getLogTypes() !\u003d null \u0026\u0026 !logRequest\n         .getLogTypes().isEmpty()) {\n       logTypes.addAll(logRequest.getLogTypes());\n     }\n     String containerIdStr \u003d logRequest.getContainerId();\n     boolean getAllContainers \u003d (containerIdStr \u003d\u003d null\n         || containerIdStr.isEmpty());\n     long size \u003d logRequest.getBytes();\n     List\u003cFileStatus\u003e nodeFiles \u003d LogAggregationUtils\n         .getRemoteNodeFileList(conf, appId, logRequest.getAppOwner(),\n         this.remoteRootLogDir, this.remoteRootLogDirSuffix);\n     if (nodeFiles.isEmpty()) {\n       throw new IOException(\"There is no available log fils for \"\n           + \"application:\" + appId);\n     }\n     Map\u003cString, Long\u003e checkSumFiles \u003d parseCheckSumFiles(nodeFiles);\n     List\u003cFileStatus\u003e fileToRead \u003d getNodeLogFileToRead(\n         nodeFiles, nodeIdStr, appId);\n     byte[] buf \u003d new byte[65535];\n     for (FileStatus thisNodeFile : fileToRead) {\n       String nodeName \u003d thisNodeFile.getPath().getName();\n       Long checkSumIndex \u003d checkSumFiles.get(nodeName);\n       long endIndex \u003d -1;\n       if (checkSumIndex !\u003d null) {\n         endIndex \u003d checkSumIndex.longValue();\n       }\n       IndexedLogsMeta indexedLogsMeta \u003d null;\n       try {\n         indexedLogsMeta \u003d loadIndexedLogsMeta(thisNodeFile.getPath(),\n-            endIndex);\n+            endIndex, appId);\n       } catch (Exception ex) {\n         // DO NOTHING\n         LOG.warn(\"Can not load log meta from the log file:\"\n-            + thisNodeFile.getPath());\n+            + thisNodeFile.getPath() + \"\\n\" + ex.getMessage());\n         continue;\n       }\n       if (indexedLogsMeta \u003d\u003d null) {\n         continue;\n       }\n       String compressAlgo \u003d indexedLogsMeta.getCompressName();\n       List\u003cIndexedFileLogMeta\u003e candidates \u003d new ArrayList\u003c\u003e();\n       for (IndexedPerAggregationLogMeta logMeta\n           : indexedLogsMeta.getLogMetas()) {\n         for (Entry\u003cString, List\u003cIndexedFileLogMeta\u003e\u003e meta\n             : logMeta.getLogMetas().entrySet()) {\n           for (IndexedFileLogMeta log : meta.getValue()) {\n             if (!getAllContainers \u0026\u0026 !log.getContainerId()\n                 .equals(containerIdStr)) {\n               continue;\n             }\n             if (logTypes !\u003d null \u0026\u0026 !logTypes.isEmpty() \u0026\u0026\n                 !logTypes.contains(log.getFileName())) {\n               continue;\n             }\n             candidates.add(log);\n           }\n         }\n       }\n       if (candidates.isEmpty()) {\n         continue;\n       }\n \n       Algorithm compressName \u003d Compression.getCompressionAlgorithmByName(\n           compressAlgo);\n       Decompressor decompressor \u003d compressName.getDecompressor();\n       FileContext fileContext \u003d FileContext.getFileContext(\n           thisNodeFile.getPath().toUri(), conf);\n       FSDataInputStream fsin \u003d fileContext.open(thisNodeFile.getPath());\n       String currentContainer \u003d \"\";\n       for (IndexedFileLogMeta candidate : candidates) {\n         if (!candidate.getContainerId().equals(currentContainer)) {\n           if (createPrintStream) {\n             closePrintStream(os);\n             os \u003d LogToolUtils.createPrintStream(\n                 logRequest.getOutputLocalDir(),\n                 thisNodeFile.getPath().getName(),\n                 candidate.getContainerId());\n             currentContainer \u003d candidate.getContainerId();\n           }\n         }\n         InputStream in \u003d null;\n         try {\n           in \u003d compressName.createDecompressionStream(\n               new BoundedRangeFileInputStream(fsin,\n                   candidate.getStartIndex(),\n                   candidate.getFileCompressedSize()),\n               decompressor, getFSInputBufferSize(conf));\n           LogToolUtils.outputContainerLog(candidate.getContainerId(),\n               nodeName, candidate.getFileName(), candidate.getFileSize(), size,\n               Times.format(candidate.getLastModificatedTime()),\n               in, os, buf, ContainerLogAggregationType.AGGREGATED);\n           byte[] b \u003d aggregatedLogSuffix(candidate.getFileName())\n               .getBytes(Charset.forName(\"UTF-8\"));\n           os.write(b, 0, b.length);\n           findLogs \u003d true;\n         } catch (IOException e) {\n           System.err.println(e.getMessage());\n           compressName.returnDecompressor(decompressor);\n           continue;\n         } finally {\n           os.flush();\n           IOUtils.cleanupWithLogger(LOG, in);\n         }\n       }\n     }\n     return findLogs;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean readAggregatedLogs(ContainerLogsRequest logRequest,\n      OutputStream os) throws IOException {\n    boolean findLogs \u003d false;\n    boolean createPrintStream \u003d (os \u003d\u003d null);\n    ApplicationId appId \u003d logRequest.getAppId();\n    String nodeId \u003d logRequest.getNodeId();\n    String nodeIdStr \u003d (nodeId \u003d\u003d null || nodeId.isEmpty()) ? null\n        : LogAggregationUtils.getNodeString(nodeId);\n    List\u003cString\u003e logTypes \u003d new ArrayList\u003c\u003e();\n    if (logRequest.getLogTypes() !\u003d null \u0026\u0026 !logRequest\n        .getLogTypes().isEmpty()) {\n      logTypes.addAll(logRequest.getLogTypes());\n    }\n    String containerIdStr \u003d logRequest.getContainerId();\n    boolean getAllContainers \u003d (containerIdStr \u003d\u003d null\n        || containerIdStr.isEmpty());\n    long size \u003d logRequest.getBytes();\n    List\u003cFileStatus\u003e nodeFiles \u003d LogAggregationUtils\n        .getRemoteNodeFileList(conf, appId, logRequest.getAppOwner(),\n        this.remoteRootLogDir, this.remoteRootLogDirSuffix);\n    if (nodeFiles.isEmpty()) {\n      throw new IOException(\"There is no available log fils for \"\n          + \"application:\" + appId);\n    }\n    Map\u003cString, Long\u003e checkSumFiles \u003d parseCheckSumFiles(nodeFiles);\n    List\u003cFileStatus\u003e fileToRead \u003d getNodeLogFileToRead(\n        nodeFiles, nodeIdStr, appId);\n    byte[] buf \u003d new byte[65535];\n    for (FileStatus thisNodeFile : fileToRead) {\n      String nodeName \u003d thisNodeFile.getPath().getName();\n      Long checkSumIndex \u003d checkSumFiles.get(nodeName);\n      long endIndex \u003d -1;\n      if (checkSumIndex !\u003d null) {\n        endIndex \u003d checkSumIndex.longValue();\n      }\n      IndexedLogsMeta indexedLogsMeta \u003d null;\n      try {\n        indexedLogsMeta \u003d loadIndexedLogsMeta(thisNodeFile.getPath(),\n            endIndex, appId);\n      } catch (Exception ex) {\n        // DO NOTHING\n        LOG.warn(\"Can not load log meta from the log file:\"\n            + thisNodeFile.getPath() + \"\\n\" + ex.getMessage());\n        continue;\n      }\n      if (indexedLogsMeta \u003d\u003d null) {\n        continue;\n      }\n      String compressAlgo \u003d indexedLogsMeta.getCompressName();\n      List\u003cIndexedFileLogMeta\u003e candidates \u003d new ArrayList\u003c\u003e();\n      for (IndexedPerAggregationLogMeta logMeta\n          : indexedLogsMeta.getLogMetas()) {\n        for (Entry\u003cString, List\u003cIndexedFileLogMeta\u003e\u003e meta\n            : logMeta.getLogMetas().entrySet()) {\n          for (IndexedFileLogMeta log : meta.getValue()) {\n            if (!getAllContainers \u0026\u0026 !log.getContainerId()\n                .equals(containerIdStr)) {\n              continue;\n            }\n            if (logTypes !\u003d null \u0026\u0026 !logTypes.isEmpty() \u0026\u0026\n                !logTypes.contains(log.getFileName())) {\n              continue;\n            }\n            candidates.add(log);\n          }\n        }\n      }\n      if (candidates.isEmpty()) {\n        continue;\n      }\n\n      Algorithm compressName \u003d Compression.getCompressionAlgorithmByName(\n          compressAlgo);\n      Decompressor decompressor \u003d compressName.getDecompressor();\n      FileContext fileContext \u003d FileContext.getFileContext(\n          thisNodeFile.getPath().toUri(), conf);\n      FSDataInputStream fsin \u003d fileContext.open(thisNodeFile.getPath());\n      String currentContainer \u003d \"\";\n      for (IndexedFileLogMeta candidate : candidates) {\n        if (!candidate.getContainerId().equals(currentContainer)) {\n          if (createPrintStream) {\n            closePrintStream(os);\n            os \u003d LogToolUtils.createPrintStream(\n                logRequest.getOutputLocalDir(),\n                thisNodeFile.getPath().getName(),\n                candidate.getContainerId());\n            currentContainer \u003d candidate.getContainerId();\n          }\n        }\n        InputStream in \u003d null;\n        try {\n          in \u003d compressName.createDecompressionStream(\n              new BoundedRangeFileInputStream(fsin,\n                  candidate.getStartIndex(),\n                  candidate.getFileCompressedSize()),\n              decompressor, getFSInputBufferSize(conf));\n          LogToolUtils.outputContainerLog(candidate.getContainerId(),\n              nodeName, candidate.getFileName(), candidate.getFileSize(), size,\n              Times.format(candidate.getLastModificatedTime()),\n              in, os, buf, ContainerLogAggregationType.AGGREGATED);\n          byte[] b \u003d aggregatedLogSuffix(candidate.getFileName())\n              .getBytes(Charset.forName(\"UTF-8\"));\n          os.write(b, 0, b.length);\n          findLogs \u003d true;\n        } catch (IOException e) {\n          System.err.println(e.getMessage());\n          compressName.returnDecompressor(decompressor);\n          continue;\n        } finally {\n          os.flush();\n          IOUtils.cleanupWithLogger(LOG, in);\n        }\n      }\n    }\n    return findLogs;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/filecontroller/ifile/LogAggregationIndexedFileController.java",
      "extendedDetails": {}
    },
    "280080fad01304c85a9ede4d4f7b707eb36c0155": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7259. Add size-based rolling policy to LogAggregationIndexedFileController. (xgong via wangda)\n\nChange-Id: Ifaf82c0aee6b73b9b6ebf103aa72e131e3942f31\n",
      "commitDate": "02/10/17 3:30 PM",
      "commitName": "280080fad01304c85a9ede4d4f7b707eb36c0155",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "13/09/17 10:16 PM",
      "commitNameOld": "c92c1d521eadfd8a4cd8205cc6aee74816f353f4",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 18.72,
      "commitsBetweenForRepo": 136,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,118 +1,116 @@\n   public boolean readAggregatedLogs(ContainerLogsRequest logRequest,\n       OutputStream os) throws IOException {\n     boolean findLogs \u003d false;\n     boolean createPrintStream \u003d (os \u003d\u003d null);\n     ApplicationId appId \u003d logRequest.getAppId();\n     String nodeId \u003d logRequest.getNodeId();\n     String nodeIdStr \u003d (nodeId \u003d\u003d null || nodeId.isEmpty()) ? null\n         : LogAggregationUtils.getNodeString(nodeId);\n     List\u003cString\u003e logTypes \u003d new ArrayList\u003c\u003e();\n     if (logRequest.getLogTypes() !\u003d null \u0026\u0026 !logRequest\n         .getLogTypes().isEmpty()) {\n       logTypes.addAll(logRequest.getLogTypes());\n     }\n     String containerIdStr \u003d logRequest.getContainerId();\n     boolean getAllContainers \u003d (containerIdStr \u003d\u003d null\n         || containerIdStr.isEmpty());\n     long size \u003d logRequest.getBytes();\n     List\u003cFileStatus\u003e nodeFiles \u003d LogAggregationUtils\n         .getRemoteNodeFileList(conf, appId, logRequest.getAppOwner(),\n         this.remoteRootLogDir, this.remoteRootLogDirSuffix);\n     if (nodeFiles.isEmpty()) {\n       throw new IOException(\"There is no available log fils for \"\n           + \"application:\" + appId);\n     }\n-    Map\u003cString, FileStatus\u003e checkSumFiles \u003d filterFiles(\n-        nodeFiles, CHECK_SUM_FILE_SUFFIX);\n+    Map\u003cString, Long\u003e checkSumFiles \u003d parseCheckSumFiles(nodeFiles);\n     List\u003cFileStatus\u003e fileToRead \u003d getNodeLogFileToRead(\n         nodeFiles, nodeIdStr, appId);\n     byte[] buf \u003d new byte[65535];\n     for (FileStatus thisNodeFile : fileToRead) {\n       String nodeName \u003d thisNodeFile.getPath().getName();\n-      FileStatus checkSum \u003d getAllChecksumFiles(checkSumFiles,\n-          thisNodeFile.getPath().getName());\n+      Long checkSumIndex \u003d checkSumFiles.get(nodeName);\n       long endIndex \u003d -1;\n-      if (checkSum !\u003d null) {\n-        endIndex \u003d loadIndexedLogsCheckSum(checkSum.getPath());\n+      if (checkSumIndex !\u003d null) {\n+        endIndex \u003d checkSumIndex.longValue();\n       }\n       IndexedLogsMeta indexedLogsMeta \u003d null;\n       try {\n         indexedLogsMeta \u003d loadIndexedLogsMeta(thisNodeFile.getPath(),\n             endIndex);\n       } catch (Exception ex) {\n         // DO NOTHING\n         LOG.warn(\"Can not load log meta from the log file:\"\n             + thisNodeFile.getPath());\n         continue;\n       }\n       if (indexedLogsMeta \u003d\u003d null) {\n         continue;\n       }\n       String compressAlgo \u003d indexedLogsMeta.getCompressName();\n       List\u003cIndexedFileLogMeta\u003e candidates \u003d new ArrayList\u003c\u003e();\n       for (IndexedPerAggregationLogMeta logMeta\n           : indexedLogsMeta.getLogMetas()) {\n         for (Entry\u003cString, List\u003cIndexedFileLogMeta\u003e\u003e meta\n             : logMeta.getLogMetas().entrySet()) {\n           for (IndexedFileLogMeta log : meta.getValue()) {\n             if (!getAllContainers \u0026\u0026 !log.getContainerId()\n                 .equals(containerIdStr)) {\n               continue;\n             }\n             if (logTypes !\u003d null \u0026\u0026 !logTypes.isEmpty() \u0026\u0026\n                 !logTypes.contains(log.getFileName())) {\n               continue;\n             }\n             candidates.add(log);\n           }\n         }\n       }\n       if (candidates.isEmpty()) {\n         continue;\n       }\n \n       Algorithm compressName \u003d Compression.getCompressionAlgorithmByName(\n           compressAlgo);\n       Decompressor decompressor \u003d compressName.getDecompressor();\n       FileContext fileContext \u003d FileContext.getFileContext(\n           thisNodeFile.getPath().toUri(), conf);\n       FSDataInputStream fsin \u003d fileContext.open(thisNodeFile.getPath());\n       String currentContainer \u003d \"\";\n       for (IndexedFileLogMeta candidate : candidates) {\n         if (!candidate.getContainerId().equals(currentContainer)) {\n           if (createPrintStream) {\n             closePrintStream(os);\n             os \u003d LogToolUtils.createPrintStream(\n                 logRequest.getOutputLocalDir(),\n                 thisNodeFile.getPath().getName(),\n                 candidate.getContainerId());\n             currentContainer \u003d candidate.getContainerId();\n           }\n         }\n         InputStream in \u003d null;\n         try {\n           in \u003d compressName.createDecompressionStream(\n               new BoundedRangeFileInputStream(fsin,\n                   candidate.getStartIndex(),\n                   candidate.getFileCompressedSize()),\n               decompressor, getFSInputBufferSize(conf));\n           LogToolUtils.outputContainerLog(candidate.getContainerId(),\n               nodeName, candidate.getFileName(), candidate.getFileSize(), size,\n               Times.format(candidate.getLastModificatedTime()),\n               in, os, buf, ContainerLogAggregationType.AGGREGATED);\n           byte[] b \u003d aggregatedLogSuffix(candidate.getFileName())\n               .getBytes(Charset.forName(\"UTF-8\"));\n           os.write(b, 0, b.length);\n           findLogs \u003d true;\n         } catch (IOException e) {\n           System.err.println(e.getMessage());\n           compressName.returnDecompressor(decompressor);\n           continue;\n         } finally {\n           os.flush();\n           IOUtils.cleanupWithLogger(LOG, in);\n         }\n       }\n     }\n     return findLogs;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean readAggregatedLogs(ContainerLogsRequest logRequest,\n      OutputStream os) throws IOException {\n    boolean findLogs \u003d false;\n    boolean createPrintStream \u003d (os \u003d\u003d null);\n    ApplicationId appId \u003d logRequest.getAppId();\n    String nodeId \u003d logRequest.getNodeId();\n    String nodeIdStr \u003d (nodeId \u003d\u003d null || nodeId.isEmpty()) ? null\n        : LogAggregationUtils.getNodeString(nodeId);\n    List\u003cString\u003e logTypes \u003d new ArrayList\u003c\u003e();\n    if (logRequest.getLogTypes() !\u003d null \u0026\u0026 !logRequest\n        .getLogTypes().isEmpty()) {\n      logTypes.addAll(logRequest.getLogTypes());\n    }\n    String containerIdStr \u003d logRequest.getContainerId();\n    boolean getAllContainers \u003d (containerIdStr \u003d\u003d null\n        || containerIdStr.isEmpty());\n    long size \u003d logRequest.getBytes();\n    List\u003cFileStatus\u003e nodeFiles \u003d LogAggregationUtils\n        .getRemoteNodeFileList(conf, appId, logRequest.getAppOwner(),\n        this.remoteRootLogDir, this.remoteRootLogDirSuffix);\n    if (nodeFiles.isEmpty()) {\n      throw new IOException(\"There is no available log fils for \"\n          + \"application:\" + appId);\n    }\n    Map\u003cString, Long\u003e checkSumFiles \u003d parseCheckSumFiles(nodeFiles);\n    List\u003cFileStatus\u003e fileToRead \u003d getNodeLogFileToRead(\n        nodeFiles, nodeIdStr, appId);\n    byte[] buf \u003d new byte[65535];\n    for (FileStatus thisNodeFile : fileToRead) {\n      String nodeName \u003d thisNodeFile.getPath().getName();\n      Long checkSumIndex \u003d checkSumFiles.get(nodeName);\n      long endIndex \u003d -1;\n      if (checkSumIndex !\u003d null) {\n        endIndex \u003d checkSumIndex.longValue();\n      }\n      IndexedLogsMeta indexedLogsMeta \u003d null;\n      try {\n        indexedLogsMeta \u003d loadIndexedLogsMeta(thisNodeFile.getPath(),\n            endIndex);\n      } catch (Exception ex) {\n        // DO NOTHING\n        LOG.warn(\"Can not load log meta from the log file:\"\n            + thisNodeFile.getPath());\n        continue;\n      }\n      if (indexedLogsMeta \u003d\u003d null) {\n        continue;\n      }\n      String compressAlgo \u003d indexedLogsMeta.getCompressName();\n      List\u003cIndexedFileLogMeta\u003e candidates \u003d new ArrayList\u003c\u003e();\n      for (IndexedPerAggregationLogMeta logMeta\n          : indexedLogsMeta.getLogMetas()) {\n        for (Entry\u003cString, List\u003cIndexedFileLogMeta\u003e\u003e meta\n            : logMeta.getLogMetas().entrySet()) {\n          for (IndexedFileLogMeta log : meta.getValue()) {\n            if (!getAllContainers \u0026\u0026 !log.getContainerId()\n                .equals(containerIdStr)) {\n              continue;\n            }\n            if (logTypes !\u003d null \u0026\u0026 !logTypes.isEmpty() \u0026\u0026\n                !logTypes.contains(log.getFileName())) {\n              continue;\n            }\n            candidates.add(log);\n          }\n        }\n      }\n      if (candidates.isEmpty()) {\n        continue;\n      }\n\n      Algorithm compressName \u003d Compression.getCompressionAlgorithmByName(\n          compressAlgo);\n      Decompressor decompressor \u003d compressName.getDecompressor();\n      FileContext fileContext \u003d FileContext.getFileContext(\n          thisNodeFile.getPath().toUri(), conf);\n      FSDataInputStream fsin \u003d fileContext.open(thisNodeFile.getPath());\n      String currentContainer \u003d \"\";\n      for (IndexedFileLogMeta candidate : candidates) {\n        if (!candidate.getContainerId().equals(currentContainer)) {\n          if (createPrintStream) {\n            closePrintStream(os);\n            os \u003d LogToolUtils.createPrintStream(\n                logRequest.getOutputLocalDir(),\n                thisNodeFile.getPath().getName(),\n                candidate.getContainerId());\n            currentContainer \u003d candidate.getContainerId();\n          }\n        }\n        InputStream in \u003d null;\n        try {\n          in \u003d compressName.createDecompressionStream(\n              new BoundedRangeFileInputStream(fsin,\n                  candidate.getStartIndex(),\n                  candidate.getFileCompressedSize()),\n              decompressor, getFSInputBufferSize(conf));\n          LogToolUtils.outputContainerLog(candidate.getContainerId(),\n              nodeName, candidate.getFileName(), candidate.getFileSize(), size,\n              Times.format(candidate.getLastModificatedTime()),\n              in, os, buf, ContainerLogAggregationType.AGGREGATED);\n          byte[] b \u003d aggregatedLogSuffix(candidate.getFileName())\n              .getBytes(Charset.forName(\"UTF-8\"));\n          os.write(b, 0, b.length);\n          findLogs \u003d true;\n        } catch (IOException e) {\n          System.err.println(e.getMessage());\n          compressName.returnDecompressor(decompressor);\n          continue;\n        } finally {\n          os.flush();\n          IOUtils.cleanupWithLogger(LOG, in);\n        }\n      }\n    }\n    return findLogs;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/filecontroller/ifile/LogAggregationIndexedFileController.java",
      "extendedDetails": {}
    },
    "3fddabc2fe4fbdb8ef3f9ce7558955c4f0794dcc": {
      "type": "Yintroduced",
      "commitMessage": "YARN-7072. Add a new log aggregation file format controller. Contributed by Xuan Gong.\n",
      "commitDate": "08/09/17 3:16 PM",
      "commitName": "3fddabc2fe4fbdb8ef3f9ce7558955c4f0794dcc",
      "commitAuthor": "Junping Du",
      "diff": "@@ -0,0 +1,118 @@\n+  public boolean readAggregatedLogs(ContainerLogsRequest logRequest,\n+      OutputStream os) throws IOException {\n+    boolean findLogs \u003d false;\n+    boolean createPrintStream \u003d (os \u003d\u003d null);\n+    ApplicationId appId \u003d logRequest.getAppId();\n+    String nodeId \u003d logRequest.getNodeId();\n+    String nodeIdStr \u003d (nodeId \u003d\u003d null || nodeId.isEmpty()) ? null\n+        : LogAggregationUtils.getNodeString(nodeId);\n+    List\u003cString\u003e logTypes \u003d new ArrayList\u003c\u003e();\n+    if (logRequest.getLogTypes() !\u003d null \u0026\u0026 !logRequest\n+        .getLogTypes().isEmpty()) {\n+      logTypes.addAll(logRequest.getLogTypes());\n+    }\n+    String containerIdStr \u003d logRequest.getContainerId();\n+    boolean getAllContainers \u003d (containerIdStr \u003d\u003d null\n+        || containerIdStr.isEmpty());\n+    long size \u003d logRequest.getBytes();\n+    List\u003cFileStatus\u003e nodeFiles \u003d LogAggregationUtils\n+        .getRemoteNodeFileList(conf, appId, logRequest.getAppOwner(),\n+        this.remoteRootLogDir, this.remoteRootLogDirSuffix);\n+    if (nodeFiles.isEmpty()) {\n+      throw new IOException(\"There is no available log fils for \"\n+          + \"application:\" + appId);\n+    }\n+    Map\u003cString, FileStatus\u003e checkSumFiles \u003d filterFiles(\n+        nodeFiles, CHECK_SUM_FILE_SUFFIX);\n+    List\u003cFileStatus\u003e fileToRead \u003d getNodeLogFileToRead(\n+        nodeFiles, nodeIdStr, appId);\n+    byte[] buf \u003d new byte[65535];\n+    for (FileStatus thisNodeFile : fileToRead) {\n+      String nodeName \u003d thisNodeFile.getPath().getName();\n+      FileStatus checkSum \u003d getAllChecksumFiles(checkSumFiles,\n+          thisNodeFile.getPath().getName());\n+      long endIndex \u003d -1;\n+      if (checkSum !\u003d null) {\n+        endIndex \u003d loadIndexedLogsCheckSum(checkSum.getPath());\n+      }\n+      IndexedLogsMeta indexedLogsMeta \u003d null;\n+      try {\n+        indexedLogsMeta \u003d loadIndexedLogsMeta(thisNodeFile.getPath(),\n+            endIndex);\n+      } catch (Exception ex) {\n+        // DO NOTHING\n+        LOG.warn(\"Can not load log meta from the log file:\"\n+            + thisNodeFile.getPath());\n+        continue;\n+      }\n+      if (indexedLogsMeta \u003d\u003d null) {\n+        continue;\n+      }\n+      String compressAlgo \u003d indexedLogsMeta.getCompressName();\n+      List\u003cIndexedFileLogMeta\u003e candidates \u003d new ArrayList\u003c\u003e();\n+      for (IndexedPerAggregationLogMeta logMeta\n+          : indexedLogsMeta.getLogMetas()) {\n+        for (Entry\u003cString, List\u003cIndexedFileLogMeta\u003e\u003e meta\n+            : logMeta.getLogMetas().entrySet()) {\n+          for (IndexedFileLogMeta log : meta.getValue()) {\n+            if (!getAllContainers \u0026\u0026 !log.getContainerId()\n+                .equals(containerIdStr)) {\n+              continue;\n+            }\n+            if (logTypes !\u003d null \u0026\u0026 !logTypes.isEmpty() \u0026\u0026\n+                !logTypes.contains(log.getFileName())) {\n+              continue;\n+            }\n+            candidates.add(log);\n+          }\n+        }\n+      }\n+      if (candidates.isEmpty()) {\n+        continue;\n+      }\n+\n+      Algorithm compressName \u003d Compression.getCompressionAlgorithmByName(\n+          compressAlgo);\n+      Decompressor decompressor \u003d compressName.getDecompressor();\n+      FileContext fileContext \u003d FileContext.getFileContext(\n+          thisNodeFile.getPath().toUri(), conf);\n+      FSDataInputStream fsin \u003d fileContext.open(thisNodeFile.getPath());\n+      String currentContainer \u003d \"\";\n+      for (IndexedFileLogMeta candidate : candidates) {\n+        if (!candidate.getContainerId().equals(currentContainer)) {\n+          if (createPrintStream) {\n+            closePrintStream(os);\n+            os \u003d LogToolUtils.createPrintStream(\n+                logRequest.getOutputLocalDir(),\n+                thisNodeFile.getPath().getName(),\n+                candidate.getContainerId());\n+            currentContainer \u003d candidate.getContainerId();\n+          }\n+        }\n+        InputStream in \u003d null;\n+        try {\n+          in \u003d compressName.createDecompressionStream(\n+              new BoundedRangeFileInputStream(fsin,\n+                  candidate.getStartIndex(),\n+                  candidate.getFileCompressedSize()),\n+              decompressor, getFSInputBufferSize(conf));\n+          LogToolUtils.outputContainerLog(candidate.getContainerId(),\n+              nodeName, candidate.getFileName(), candidate.getFileSize(), size,\n+              Times.format(candidate.getLastModificatedTime()),\n+              in, os, buf, ContainerLogAggregationType.AGGREGATED);\n+          byte[] b \u003d aggregatedLogSuffix(candidate.getFileName())\n+              .getBytes(Charset.forName(\"UTF-8\"));\n+          os.write(b, 0, b.length);\n+          findLogs \u003d true;\n+        } catch (IOException e) {\n+          System.err.println(e.getMessage());\n+          compressName.returnDecompressor(decompressor);\n+          continue;\n+        } finally {\n+          os.flush();\n+          IOUtils.cleanupWithLogger(LOG, in);\n+        }\n+      }\n+    }\n+    return findLogs;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean readAggregatedLogs(ContainerLogsRequest logRequest,\n      OutputStream os) throws IOException {\n    boolean findLogs \u003d false;\n    boolean createPrintStream \u003d (os \u003d\u003d null);\n    ApplicationId appId \u003d logRequest.getAppId();\n    String nodeId \u003d logRequest.getNodeId();\n    String nodeIdStr \u003d (nodeId \u003d\u003d null || nodeId.isEmpty()) ? null\n        : LogAggregationUtils.getNodeString(nodeId);\n    List\u003cString\u003e logTypes \u003d new ArrayList\u003c\u003e();\n    if (logRequest.getLogTypes() !\u003d null \u0026\u0026 !logRequest\n        .getLogTypes().isEmpty()) {\n      logTypes.addAll(logRequest.getLogTypes());\n    }\n    String containerIdStr \u003d logRequest.getContainerId();\n    boolean getAllContainers \u003d (containerIdStr \u003d\u003d null\n        || containerIdStr.isEmpty());\n    long size \u003d logRequest.getBytes();\n    List\u003cFileStatus\u003e nodeFiles \u003d LogAggregationUtils\n        .getRemoteNodeFileList(conf, appId, logRequest.getAppOwner(),\n        this.remoteRootLogDir, this.remoteRootLogDirSuffix);\n    if (nodeFiles.isEmpty()) {\n      throw new IOException(\"There is no available log fils for \"\n          + \"application:\" + appId);\n    }\n    Map\u003cString, FileStatus\u003e checkSumFiles \u003d filterFiles(\n        nodeFiles, CHECK_SUM_FILE_SUFFIX);\n    List\u003cFileStatus\u003e fileToRead \u003d getNodeLogFileToRead(\n        nodeFiles, nodeIdStr, appId);\n    byte[] buf \u003d new byte[65535];\n    for (FileStatus thisNodeFile : fileToRead) {\n      String nodeName \u003d thisNodeFile.getPath().getName();\n      FileStatus checkSum \u003d getAllChecksumFiles(checkSumFiles,\n          thisNodeFile.getPath().getName());\n      long endIndex \u003d -1;\n      if (checkSum !\u003d null) {\n        endIndex \u003d loadIndexedLogsCheckSum(checkSum.getPath());\n      }\n      IndexedLogsMeta indexedLogsMeta \u003d null;\n      try {\n        indexedLogsMeta \u003d loadIndexedLogsMeta(thisNodeFile.getPath(),\n            endIndex);\n      } catch (Exception ex) {\n        // DO NOTHING\n        LOG.warn(\"Can not load log meta from the log file:\"\n            + thisNodeFile.getPath());\n        continue;\n      }\n      if (indexedLogsMeta \u003d\u003d null) {\n        continue;\n      }\n      String compressAlgo \u003d indexedLogsMeta.getCompressName();\n      List\u003cIndexedFileLogMeta\u003e candidates \u003d new ArrayList\u003c\u003e();\n      for (IndexedPerAggregationLogMeta logMeta\n          : indexedLogsMeta.getLogMetas()) {\n        for (Entry\u003cString, List\u003cIndexedFileLogMeta\u003e\u003e meta\n            : logMeta.getLogMetas().entrySet()) {\n          for (IndexedFileLogMeta log : meta.getValue()) {\n            if (!getAllContainers \u0026\u0026 !log.getContainerId()\n                .equals(containerIdStr)) {\n              continue;\n            }\n            if (logTypes !\u003d null \u0026\u0026 !logTypes.isEmpty() \u0026\u0026\n                !logTypes.contains(log.getFileName())) {\n              continue;\n            }\n            candidates.add(log);\n          }\n        }\n      }\n      if (candidates.isEmpty()) {\n        continue;\n      }\n\n      Algorithm compressName \u003d Compression.getCompressionAlgorithmByName(\n          compressAlgo);\n      Decompressor decompressor \u003d compressName.getDecompressor();\n      FileContext fileContext \u003d FileContext.getFileContext(\n          thisNodeFile.getPath().toUri(), conf);\n      FSDataInputStream fsin \u003d fileContext.open(thisNodeFile.getPath());\n      String currentContainer \u003d \"\";\n      for (IndexedFileLogMeta candidate : candidates) {\n        if (!candidate.getContainerId().equals(currentContainer)) {\n          if (createPrintStream) {\n            closePrintStream(os);\n            os \u003d LogToolUtils.createPrintStream(\n                logRequest.getOutputLocalDir(),\n                thisNodeFile.getPath().getName(),\n                candidate.getContainerId());\n            currentContainer \u003d candidate.getContainerId();\n          }\n        }\n        InputStream in \u003d null;\n        try {\n          in \u003d compressName.createDecompressionStream(\n              new BoundedRangeFileInputStream(fsin,\n                  candidate.getStartIndex(),\n                  candidate.getFileCompressedSize()),\n              decompressor, getFSInputBufferSize(conf));\n          LogToolUtils.outputContainerLog(candidate.getContainerId(),\n              nodeName, candidate.getFileName(), candidate.getFileSize(), size,\n              Times.format(candidate.getLastModificatedTime()),\n              in, os, buf, ContainerLogAggregationType.AGGREGATED);\n          byte[] b \u003d aggregatedLogSuffix(candidate.getFileName())\n              .getBytes(Charset.forName(\"UTF-8\"));\n          os.write(b, 0, b.length);\n          findLogs \u003d true;\n        } catch (IOException e) {\n          System.err.println(e.getMessage());\n          compressName.returnDecompressor(decompressor);\n          continue;\n        } finally {\n          os.flush();\n          IOUtils.cleanupWithLogger(LOG, in);\n        }\n      }\n    }\n    return findLogs;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/filecontroller/ifile/LogAggregationIndexedFileController.java"
    }
  }
}