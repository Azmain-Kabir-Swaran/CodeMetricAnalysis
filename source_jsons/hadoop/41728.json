{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "AbstractYarnScheduler.java",
  "functionName": "moveAllApps",
  "functionId": "moveAllApps___sourceQueue-String__destQueue-String",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/AbstractYarnScheduler.java",
  "functionStartLine": 797,
  "functionEndLine": 818,
  "numCommitsSeen": 115,
  "timeTaken": 5244,
  "changeHistory": [
    "2f752830ba74c90ccce818d687572db9afded25b",
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635",
    "e40e2d6ad5cbe782c3a067229270738b501ed27e",
    "563480dccd0136d82730f4228f1df44449ed5822",
    "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f",
    "7360cec692be5dcc3377ae5082fe22870caac96b"
  ],
  "changeHistoryShort": {
    "2f752830ba74c90ccce818d687572db9afded25b": "Ybodychange",
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635": "Ybodychange",
    "e40e2d6ad5cbe782c3a067229270738b501ed27e": "Ybodychange",
    "563480dccd0136d82730f4228f1df44449ed5822": "Ybodychange",
    "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f": "Ymultichange(Ymodifierchange,Ybodychange)",
    "7360cec692be5dcc3377ae5082fe22870caac96b": "Yintroduced"
  },
  "changeHistoryDetails": {
    "2f752830ba74c90ccce818d687572db9afded25b": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9214. Add AbstractYarnScheduler#getValidQueues method to remove duplication. Contributed by Wanqiang Ji.\n",
      "commitDate": "01/04/19 8:05 PM",
      "commitName": "2f752830ba74c90ccce818d687572db9afded25b",
      "commitAuthor": "Yufei Gu",
      "commitDateOld": "15/03/19 4:20 PM",
      "commitNameOld": "2064ca015d1584263aac0cc20c60b925a3aff612",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 17.16,
      "commitsBetweenForRepo": 111,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,22 @@\n   public void moveAllApps(String sourceQueue, String destQueue)\n       throws YarnException {\n     writeLock.lock();\n     try {\n       // check if destination queue is a valid leaf queue\n       try {\n         getQueueInfo(destQueue, false, false);\n       } catch (IOException e) {\n         LOG.warn(e.toString());\n         throw new YarnException(e);\n       }\n-      // check if source queue is a valid\n-      List\u003cApplicationAttemptId\u003e apps \u003d getAppsInQueue(sourceQueue);\n-      if (apps \u003d\u003d null) {\n-        String errMsg \u003d\n-            \"The specified Queue: \" + sourceQueue + \" doesn\u0027t exist\";\n-        LOG.warn(errMsg);\n-        throw new YarnException(errMsg);\n-      }\n+\n       // generate move events for each pending/running app\n-      for (ApplicationAttemptId appAttemptId : apps) {\n+      for (ApplicationAttemptId appAttemptId : getAppsFromQueue(sourceQueue)) {\n         this.rmContext.getDispatcher().getEventHandler()\n             .handle(new RMAppManagerEvent(appAttemptId.getApplicationId(),\n                 destQueue, RMAppManagerEventType.APP_MOVE));\n       }\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void moveAllApps(String sourceQueue, String destQueue)\n      throws YarnException {\n    writeLock.lock();\n    try {\n      // check if destination queue is a valid leaf queue\n      try {\n        getQueueInfo(destQueue, false, false);\n      } catch (IOException e) {\n        LOG.warn(e.toString());\n        throw new YarnException(e);\n      }\n\n      // generate move events for each pending/running app\n      for (ApplicationAttemptId appAttemptId : getAppsFromQueue(sourceQueue)) {\n        this.rmContext.getDispatcher().getEventHandler()\n            .handle(new RMAppManagerEvent(appAttemptId.getApplicationId(),\n                destQueue, RMAppManagerEventType.APP_MOVE));\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/AbstractYarnScheduler.java",
      "extendedDetails": {}
    },
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9341.  Fixed enentrant lock usage in YARN project.\n            Contributed by Prabhu Joseph\n",
      "commitDate": "07/03/19 1:47 PM",
      "commitName": "39b4a37e02e929a698fcf9e32f1f71bb6b977635",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "04/03/19 9:10 PM",
      "commitNameOld": "e40e2d6ad5cbe782c3a067229270738b501ed27e",
      "commitAuthorOld": "Prabhu Joseph",
      "daysBetweenCommits": 2.69,
      "commitsBetweenForRepo": 39,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,29 @@\n   public void moveAllApps(String sourceQueue, String destQueue)\n       throws YarnException {\n+    writeLock.lock();\n     try {\n-      writeLock.lock();\n       // check if destination queue is a valid leaf queue\n       try {\n         getQueueInfo(destQueue, false, false);\n       } catch (IOException e) {\n         LOG.warn(e.toString());\n         throw new YarnException(e);\n       }\n       // check if source queue is a valid\n       List\u003cApplicationAttemptId\u003e apps \u003d getAppsInQueue(sourceQueue);\n       if (apps \u003d\u003d null) {\n         String errMsg \u003d\n             \"The specified Queue: \" + sourceQueue + \" doesn\u0027t exist\";\n         LOG.warn(errMsg);\n         throw new YarnException(errMsg);\n       }\n       // generate move events for each pending/running app\n       for (ApplicationAttemptId appAttemptId : apps) {\n         this.rmContext.getDispatcher().getEventHandler()\n             .handle(new RMAppManagerEvent(appAttemptId.getApplicationId(),\n                 destQueue, RMAppManagerEventType.APP_MOVE));\n       }\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void moveAllApps(String sourceQueue, String destQueue)\n      throws YarnException {\n    writeLock.lock();\n    try {\n      // check if destination queue is a valid leaf queue\n      try {\n        getQueueInfo(destQueue, false, false);\n      } catch (IOException e) {\n        LOG.warn(e.toString());\n        throw new YarnException(e);\n      }\n      // check if source queue is a valid\n      List\u003cApplicationAttemptId\u003e apps \u003d getAppsInQueue(sourceQueue);\n      if (apps \u003d\u003d null) {\n        String errMsg \u003d\n            \"The specified Queue: \" + sourceQueue + \" doesn\u0027t exist\";\n        LOG.warn(errMsg);\n        throw new YarnException(errMsg);\n      }\n      // generate move events for each pending/running app\n      for (ApplicationAttemptId appAttemptId : apps) {\n        this.rmContext.getDispatcher().getEventHandler()\n            .handle(new RMAppManagerEvent(appAttemptId.getApplicationId(),\n                destQueue, RMAppManagerEventType.APP_MOVE));\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/AbstractYarnScheduler.java",
      "extendedDetails": {}
    },
    "e40e2d6ad5cbe782c3a067229270738b501ed27e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7243. Moving logging APIs over to slf4j in hadoop-yarn-server-resourcemanager.\n\nSigned-off-by: Akira Ajisaka \u003caajisaka@apache.org\u003e\n",
      "commitDate": "04/03/19 9:10 PM",
      "commitName": "e40e2d6ad5cbe782c3a067229270738b501ed27e",
      "commitAuthor": "Prabhu Joseph",
      "commitDateOld": "14/01/19 7:59 PM",
      "commitNameOld": "614af50625a8495812dce8da59db0e1aef40b1c0",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 49.05,
      "commitsBetweenForRepo": 404,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,29 @@\n   public void moveAllApps(String sourceQueue, String destQueue)\n       throws YarnException {\n     try {\n       writeLock.lock();\n       // check if destination queue is a valid leaf queue\n       try {\n         getQueueInfo(destQueue, false, false);\n       } catch (IOException e) {\n-        LOG.warn(e);\n+        LOG.warn(e.toString());\n         throw new YarnException(e);\n       }\n       // check if source queue is a valid\n       List\u003cApplicationAttemptId\u003e apps \u003d getAppsInQueue(sourceQueue);\n       if (apps \u003d\u003d null) {\n         String errMsg \u003d\n             \"The specified Queue: \" + sourceQueue + \" doesn\u0027t exist\";\n         LOG.warn(errMsg);\n         throw new YarnException(errMsg);\n       }\n       // generate move events for each pending/running app\n       for (ApplicationAttemptId appAttemptId : apps) {\n         this.rmContext.getDispatcher().getEventHandler()\n             .handle(new RMAppManagerEvent(appAttemptId.getApplicationId(),\n                 destQueue, RMAppManagerEventType.APP_MOVE));\n       }\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void moveAllApps(String sourceQueue, String destQueue)\n      throws YarnException {\n    try {\n      writeLock.lock();\n      // check if destination queue is a valid leaf queue\n      try {\n        getQueueInfo(destQueue, false, false);\n      } catch (IOException e) {\n        LOG.warn(e.toString());\n        throw new YarnException(e);\n      }\n      // check if source queue is a valid\n      List\u003cApplicationAttemptId\u003e apps \u003d getAppsInQueue(sourceQueue);\n      if (apps \u003d\u003d null) {\n        String errMsg \u003d\n            \"The specified Queue: \" + sourceQueue + \" doesn\u0027t exist\";\n        LOG.warn(errMsg);\n        throw new YarnException(errMsg);\n      }\n      // generate move events for each pending/running app\n      for (ApplicationAttemptId appAttemptId : apps) {\n        this.rmContext.getDispatcher().getEventHandler()\n            .handle(new RMAppManagerEvent(appAttemptId.getApplicationId(),\n                destQueue, RMAppManagerEventType.APP_MOVE));\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/AbstractYarnScheduler.java",
      "extendedDetails": {}
    },
    "563480dccd0136d82730f4228f1df44449ed5822": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5932. Retrospect moveApplicationToQueue in align with YARN-5611. Contributed by Sunil G.\n",
      "commitDate": "06/12/16 9:09 PM",
      "commitName": "563480dccd0136d82730f4228f1df44449ed5822",
      "commitAuthor": "Rohith Sharma K S",
      "commitDateOld": "29/11/16 9:40 AM",
      "commitNameOld": "25f9872be63423ada6a18481eaad2888e731fdac",
      "commitAuthorOld": "Daniel Templeton",
      "daysBetweenCommits": 7.48,
      "commitsBetweenForRepo": 56,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,29 @@\n   public void moveAllApps(String sourceQueue, String destQueue)\n       throws YarnException {\n     try {\n       writeLock.lock();\n       // check if destination queue is a valid leaf queue\n       try {\n         getQueueInfo(destQueue, false, false);\n       } catch (IOException e) {\n         LOG.warn(e);\n         throw new YarnException(e);\n       }\n       // check if source queue is a valid\n       List\u003cApplicationAttemptId\u003e apps \u003d getAppsInQueue(sourceQueue);\n       if (apps \u003d\u003d null) {\n         String errMsg \u003d\n             \"The specified Queue: \" + sourceQueue + \" doesn\u0027t exist\";\n         LOG.warn(errMsg);\n         throw new YarnException(errMsg);\n       }\n       // generate move events for each pending/running app\n-      for (ApplicationAttemptId app : apps) {\n-        SettableFuture\u003cObject\u003e future \u003d SettableFuture.create();\n-        this.rmContext.getDispatcher().getEventHandler().handle(\n-            new RMAppMoveEvent(app.getApplicationId(), destQueue, future));\n+      for (ApplicationAttemptId appAttemptId : apps) {\n+        this.rmContext.getDispatcher().getEventHandler()\n+            .handle(new RMAppManagerEvent(appAttemptId.getApplicationId(),\n+                destQueue, RMAppManagerEventType.APP_MOVE));\n       }\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void moveAllApps(String sourceQueue, String destQueue)\n      throws YarnException {\n    try {\n      writeLock.lock();\n      // check if destination queue is a valid leaf queue\n      try {\n        getQueueInfo(destQueue, false, false);\n      } catch (IOException e) {\n        LOG.warn(e);\n        throw new YarnException(e);\n      }\n      // check if source queue is a valid\n      List\u003cApplicationAttemptId\u003e apps \u003d getAppsInQueue(sourceQueue);\n      if (apps \u003d\u003d null) {\n        String errMsg \u003d\n            \"The specified Queue: \" + sourceQueue + \" doesn\u0027t exist\";\n        LOG.warn(errMsg);\n        throw new YarnException(errMsg);\n      }\n      // generate move events for each pending/running app\n      for (ApplicationAttemptId appAttemptId : apps) {\n        this.rmContext.getDispatcher().getEventHandler()\n            .handle(new RMAppManagerEvent(appAttemptId.getApplicationId(),\n                destQueue, RMAppManagerEventType.APP_MOVE));\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/AbstractYarnScheduler.java",
      "extendedDetails": {}
    },
    "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f": {
      "type": "Ymultichange(Ymodifierchange,Ybodychange)",
      "commitMessage": "YARN-3139. Improve locks in AbstractYarnScheduler/CapacityScheduler/FairScheduler. Contributed by Wangda Tan\n",
      "commitDate": "04/10/16 5:23 PM",
      "commitName": "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f",
      "commitAuthor": "Jian He",
      "subchanges": [
        {
          "type": "Ymodifierchange",
          "commitMessage": "YARN-3139. Improve locks in AbstractYarnScheduler/CapacityScheduler/FairScheduler. Contributed by Wangda Tan\n",
          "commitDate": "04/10/16 5:23 PM",
          "commitName": "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f",
          "commitAuthor": "Jian He",
          "commitDateOld": "30/08/16 3:52 PM",
          "commitNameOld": "d6d9cff21b7b6141ed88359652cf22e8973c0661",
          "commitAuthorOld": "Arun Suresh",
          "daysBetweenCommits": 35.06,
          "commitsBetweenForRepo": 195,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,25 +1,29 @@\n-  public synchronized void moveAllApps(String sourceQueue, String destQueue)\n+  public void moveAllApps(String sourceQueue, String destQueue)\n       throws YarnException {\n-    // check if destination queue is a valid leaf queue\n     try {\n-      getQueueInfo(destQueue, false, false);\n-    } catch (IOException e) {\n-      LOG.warn(e);\n-      throw new YarnException(e);\n-    }\n-    // check if source queue is a valid\n-    List\u003cApplicationAttemptId\u003e apps \u003d getAppsInQueue(sourceQueue);\n-    if (apps \u003d\u003d null) {\n-      String errMsg \u003d \"The specified Queue: \" + sourceQueue + \" doesn\u0027t exist\";\n-      LOG.warn(errMsg);\n-      throw new YarnException(errMsg);\n-    }\n-    // generate move events for each pending/running app\n-    for (ApplicationAttemptId app : apps) {\n-      SettableFuture\u003cObject\u003e future \u003d SettableFuture.create();\n-      this.rmContext\n-          .getDispatcher()\n-          .getEventHandler()\n-          .handle(new RMAppMoveEvent(app.getApplicationId(), destQueue, future));\n+      writeLock.lock();\n+      // check if destination queue is a valid leaf queue\n+      try {\n+        getQueueInfo(destQueue, false, false);\n+      } catch (IOException e) {\n+        LOG.warn(e);\n+        throw new YarnException(e);\n+      }\n+      // check if source queue is a valid\n+      List\u003cApplicationAttemptId\u003e apps \u003d getAppsInQueue(sourceQueue);\n+      if (apps \u003d\u003d null) {\n+        String errMsg \u003d\n+            \"The specified Queue: \" + sourceQueue + \" doesn\u0027t exist\";\n+        LOG.warn(errMsg);\n+        throw new YarnException(errMsg);\n+      }\n+      // generate move events for each pending/running app\n+      for (ApplicationAttemptId app : apps) {\n+        SettableFuture\u003cObject\u003e future \u003d SettableFuture.create();\n+        this.rmContext.getDispatcher().getEventHandler().handle(\n+            new RMAppMoveEvent(app.getApplicationId(), destQueue, future));\n+      }\n+    } finally {\n+      writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void moveAllApps(String sourceQueue, String destQueue)\n      throws YarnException {\n    try {\n      writeLock.lock();\n      // check if destination queue is a valid leaf queue\n      try {\n        getQueueInfo(destQueue, false, false);\n      } catch (IOException e) {\n        LOG.warn(e);\n        throw new YarnException(e);\n      }\n      // check if source queue is a valid\n      List\u003cApplicationAttemptId\u003e apps \u003d getAppsInQueue(sourceQueue);\n      if (apps \u003d\u003d null) {\n        String errMsg \u003d\n            \"The specified Queue: \" + sourceQueue + \" doesn\u0027t exist\";\n        LOG.warn(errMsg);\n        throw new YarnException(errMsg);\n      }\n      // generate move events for each pending/running app\n      for (ApplicationAttemptId app : apps) {\n        SettableFuture\u003cObject\u003e future \u003d SettableFuture.create();\n        this.rmContext.getDispatcher().getEventHandler().handle(\n            new RMAppMoveEvent(app.getApplicationId(), destQueue, future));\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/AbstractYarnScheduler.java",
          "extendedDetails": {
            "oldValue": "[public, synchronized]",
            "newValue": "[public]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-3139. Improve locks in AbstractYarnScheduler/CapacityScheduler/FairScheduler. Contributed by Wangda Tan\n",
          "commitDate": "04/10/16 5:23 PM",
          "commitName": "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f",
          "commitAuthor": "Jian He",
          "commitDateOld": "30/08/16 3:52 PM",
          "commitNameOld": "d6d9cff21b7b6141ed88359652cf22e8973c0661",
          "commitAuthorOld": "Arun Suresh",
          "daysBetweenCommits": 35.06,
          "commitsBetweenForRepo": 195,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,25 +1,29 @@\n-  public synchronized void moveAllApps(String sourceQueue, String destQueue)\n+  public void moveAllApps(String sourceQueue, String destQueue)\n       throws YarnException {\n-    // check if destination queue is a valid leaf queue\n     try {\n-      getQueueInfo(destQueue, false, false);\n-    } catch (IOException e) {\n-      LOG.warn(e);\n-      throw new YarnException(e);\n-    }\n-    // check if source queue is a valid\n-    List\u003cApplicationAttemptId\u003e apps \u003d getAppsInQueue(sourceQueue);\n-    if (apps \u003d\u003d null) {\n-      String errMsg \u003d \"The specified Queue: \" + sourceQueue + \" doesn\u0027t exist\";\n-      LOG.warn(errMsg);\n-      throw new YarnException(errMsg);\n-    }\n-    // generate move events for each pending/running app\n-    for (ApplicationAttemptId app : apps) {\n-      SettableFuture\u003cObject\u003e future \u003d SettableFuture.create();\n-      this.rmContext\n-          .getDispatcher()\n-          .getEventHandler()\n-          .handle(new RMAppMoveEvent(app.getApplicationId(), destQueue, future));\n+      writeLock.lock();\n+      // check if destination queue is a valid leaf queue\n+      try {\n+        getQueueInfo(destQueue, false, false);\n+      } catch (IOException e) {\n+        LOG.warn(e);\n+        throw new YarnException(e);\n+      }\n+      // check if source queue is a valid\n+      List\u003cApplicationAttemptId\u003e apps \u003d getAppsInQueue(sourceQueue);\n+      if (apps \u003d\u003d null) {\n+        String errMsg \u003d\n+            \"The specified Queue: \" + sourceQueue + \" doesn\u0027t exist\";\n+        LOG.warn(errMsg);\n+        throw new YarnException(errMsg);\n+      }\n+      // generate move events for each pending/running app\n+      for (ApplicationAttemptId app : apps) {\n+        SettableFuture\u003cObject\u003e future \u003d SettableFuture.create();\n+        this.rmContext.getDispatcher().getEventHandler().handle(\n+            new RMAppMoveEvent(app.getApplicationId(), destQueue, future));\n+      }\n+    } finally {\n+      writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void moveAllApps(String sourceQueue, String destQueue)\n      throws YarnException {\n    try {\n      writeLock.lock();\n      // check if destination queue is a valid leaf queue\n      try {\n        getQueueInfo(destQueue, false, false);\n      } catch (IOException e) {\n        LOG.warn(e);\n        throw new YarnException(e);\n      }\n      // check if source queue is a valid\n      List\u003cApplicationAttemptId\u003e apps \u003d getAppsInQueue(sourceQueue);\n      if (apps \u003d\u003d null) {\n        String errMsg \u003d\n            \"The specified Queue: \" + sourceQueue + \" doesn\u0027t exist\";\n        LOG.warn(errMsg);\n        throw new YarnException(errMsg);\n      }\n      // generate move events for each pending/running app\n      for (ApplicationAttemptId app : apps) {\n        SettableFuture\u003cObject\u003e future \u003d SettableFuture.create();\n        this.rmContext.getDispatcher().getEventHandler().handle(\n            new RMAppMoveEvent(app.getApplicationId(), destQueue, future));\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/AbstractYarnScheduler.java",
          "extendedDetails": {}
        }
      ]
    },
    "7360cec692be5dcc3377ae5082fe22870caac96b": {
      "type": "Yintroduced",
      "commitMessage": "YARN-2378. Added support for moving applications across queues in CapacityScheduler. Contributed by Subramaniam Venkatraman Krishnan\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1618106 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/08/14 11:00 PM",
      "commitName": "7360cec692be5dcc3377ae5082fe22870caac96b",
      "commitAuthor": "Jian He",
      "diff": "@@ -0,0 +1,25 @@\n+  public synchronized void moveAllApps(String sourceQueue, String destQueue)\n+      throws YarnException {\n+    // check if destination queue is a valid leaf queue\n+    try {\n+      getQueueInfo(destQueue, false, false);\n+    } catch (IOException e) {\n+      LOG.warn(e);\n+      throw new YarnException(e);\n+    }\n+    // check if source queue is a valid\n+    List\u003cApplicationAttemptId\u003e apps \u003d getAppsInQueue(sourceQueue);\n+    if (apps \u003d\u003d null) {\n+      String errMsg \u003d \"The specified Queue: \" + sourceQueue + \" doesn\u0027t exist\";\n+      LOG.warn(errMsg);\n+      throw new YarnException(errMsg);\n+    }\n+    // generate move events for each pending/running app\n+    for (ApplicationAttemptId app : apps) {\n+      SettableFuture\u003cObject\u003e future \u003d SettableFuture.create();\n+      this.rmContext\n+          .getDispatcher()\n+          .getEventHandler()\n+          .handle(new RMAppMoveEvent(app.getApplicationId(), destQueue, future));\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void moveAllApps(String sourceQueue, String destQueue)\n      throws YarnException {\n    // check if destination queue is a valid leaf queue\n    try {\n      getQueueInfo(destQueue, false, false);\n    } catch (IOException e) {\n      LOG.warn(e);\n      throw new YarnException(e);\n    }\n    // check if source queue is a valid\n    List\u003cApplicationAttemptId\u003e apps \u003d getAppsInQueue(sourceQueue);\n    if (apps \u003d\u003d null) {\n      String errMsg \u003d \"The specified Queue: \" + sourceQueue + \" doesn\u0027t exist\";\n      LOG.warn(errMsg);\n      throw new YarnException(errMsg);\n    }\n    // generate move events for each pending/running app\n    for (ApplicationAttemptId app : apps) {\n      SettableFuture\u003cObject\u003e future \u003d SettableFuture.create();\n      this.rmContext\n          .getDispatcher()\n          .getEventHandler()\n          .handle(new RMAppMoveEvent(app.getApplicationId(), destQueue, future));\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/AbstractYarnScheduler.java"
    }
  }
}