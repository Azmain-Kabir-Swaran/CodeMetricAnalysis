{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "StripedBlockChecksumReconstructor.java",
  "functionName": "checksumWithTargetOutput",
  "functionId": "checksumWithTargetOutput___outputData-byte[]__toReconstructLen-int",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/erasurecode/StripedBlockChecksumReconstructor.java",
  "functionStartLine": 135,
  "functionEndLine": 184,
  "numCommitsSeen": 15,
  "timeTaken": 3410,
  "changeHistory": [
    "7c9cdad6d04c98db5a83e2108219bf6e6c903daf",
    "46e18c8da76ea8d91a16e59ba1154c30f37cb9fd",
    "287effff9327450240d65e27e31bed2649a7a100",
    "e6cb07520f935efde3e881de8f84ee7f6e0a746f"
  ],
  "changeHistoryShort": {
    "7c9cdad6d04c98db5a83e2108219bf6e6c903daf": "Ymultichange(Yparameterchange,Ybodychange)",
    "46e18c8da76ea8d91a16e59ba1154c30f37cb9fd": "Ybodychange",
    "287effff9327450240d65e27e31bed2649a7a100": "Ybodychange",
    "e6cb07520f935efde3e881de8f84ee7f6e0a746f": "Yintroduced"
  },
  "changeHistoryDetails": {
    "7c9cdad6d04c98db5a83e2108219bf6e6c903daf": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-13056. Expose file-level composite CRCs in HDFS which are comparable across different instances/layouts. Contributed by Dennis Huo.\n",
      "commitDate": "10/04/18 9:31 PM",
      "commitName": "7c9cdad6d04c98db5a83e2108219bf6e6c903daf",
      "commitAuthor": "Xiao Chen",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-13056. Expose file-level composite CRCs in HDFS which are comparable across different instances/layouts. Contributed by Dennis Huo.\n",
          "commitDate": "10/04/18 9:31 PM",
          "commitName": "7c9cdad6d04c98db5a83e2108219bf6e6c903daf",
          "commitAuthor": "Xiao Chen",
          "commitDateOld": "13/12/17 2:56 PM",
          "commitNameOld": "46e18c8da76ea8d91a16e59ba1154c30f37cb9fd",
          "commitAuthorOld": "Chen Liang",
          "daysBetweenCommits": 118.23,
          "commitsBetweenForRepo": 858,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,50 +1,50 @@\n-  private long checksumWithTargetOutput(byte[] outputData, int toReconstructLen,\n-      MessageDigest digester) throws IOException {\n+  private long checksumWithTargetOutput(byte[] outputData, int toReconstructLen)\n+      throws IOException {\n     long checksumDataLength \u003d 0;\n     // Calculate partial block checksum. There are two cases.\n     // case-1) length of data bytes which is fraction of bytesPerCRC\n     // case-2) length of data bytes which is less than bytesPerCRC\n     if (requestedLen \u003c\u003d toReconstructLen) {\n       int remainingLen \u003d Math.toIntExact(requestedLen);\n       outputData \u003d Arrays.copyOf(targetBuffer.array(), remainingLen);\n \n       int partialLength \u003d remainingLen % getChecksum().getBytesPerChecksum();\n \n       int checksumRemaining \u003d (remainingLen\n           / getChecksum().getBytesPerChecksum())\n           * getChecksum().getChecksumSize();\n \n       int dataOffset \u003d 0;\n \n       // case-1) length of data bytes which is fraction of bytesPerCRC\n       if (checksumRemaining \u003e 0) {\n         remainingLen \u003d remainingLen - partialLength;\n         checksumBuf \u003d new byte[checksumRemaining];\n         getChecksum().calculateChunkedSums(outputData, dataOffset,\n             remainingLen, checksumBuf, 0);\n-        digester.update(checksumBuf, 0, checksumBuf.length);\n+        updateDigester(checksumBuf, getChecksum().getBytesPerChecksum());\n         checksumDataLength \u003d checksumBuf.length;\n         dataOffset \u003d remainingLen;\n       }\n \n       // case-2) length of data bytes which is less than bytesPerCRC\n       if (partialLength \u003e 0) {\n         byte[] partialCrc \u003d new byte[getChecksum().getChecksumSize()];\n         getChecksum().reset();\n         getChecksum().update(outputData, dataOffset, partialLength);\n         getChecksum().writeValue(partialCrc, 0, true);\n-        digester.update(partialCrc);\n+        updateDigester(partialCrc, partialLength);\n         checksumDataLength +\u003d partialCrc.length;\n       }\n \n       clearBuffers();\n       // calculated checksum for the requested length, return checksum length.\n       return checksumDataLength;\n     }\n     getChecksum().calculateChunkedSums(outputData, 0,\n         outputData.length, checksumBuf, 0);\n \n     // updates digest using the checksum array of bytes\n-    digester.update(checksumBuf, 0, checksumBuf.length);\n+    updateDigester(checksumBuf, getChecksum().getBytesPerChecksum());\n     return checksumBuf.length;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private long checksumWithTargetOutput(byte[] outputData, int toReconstructLen)\n      throws IOException {\n    long checksumDataLength \u003d 0;\n    // Calculate partial block checksum. There are two cases.\n    // case-1) length of data bytes which is fraction of bytesPerCRC\n    // case-2) length of data bytes which is less than bytesPerCRC\n    if (requestedLen \u003c\u003d toReconstructLen) {\n      int remainingLen \u003d Math.toIntExact(requestedLen);\n      outputData \u003d Arrays.copyOf(targetBuffer.array(), remainingLen);\n\n      int partialLength \u003d remainingLen % getChecksum().getBytesPerChecksum();\n\n      int checksumRemaining \u003d (remainingLen\n          / getChecksum().getBytesPerChecksum())\n          * getChecksum().getChecksumSize();\n\n      int dataOffset \u003d 0;\n\n      // case-1) length of data bytes which is fraction of bytesPerCRC\n      if (checksumRemaining \u003e 0) {\n        remainingLen \u003d remainingLen - partialLength;\n        checksumBuf \u003d new byte[checksumRemaining];\n        getChecksum().calculateChunkedSums(outputData, dataOffset,\n            remainingLen, checksumBuf, 0);\n        updateDigester(checksumBuf, getChecksum().getBytesPerChecksum());\n        checksumDataLength \u003d checksumBuf.length;\n        dataOffset \u003d remainingLen;\n      }\n\n      // case-2) length of data bytes which is less than bytesPerCRC\n      if (partialLength \u003e 0) {\n        byte[] partialCrc \u003d new byte[getChecksum().getChecksumSize()];\n        getChecksum().reset();\n        getChecksum().update(outputData, dataOffset, partialLength);\n        getChecksum().writeValue(partialCrc, 0, true);\n        updateDigester(partialCrc, partialLength);\n        checksumDataLength +\u003d partialCrc.length;\n      }\n\n      clearBuffers();\n      // calculated checksum for the requested length, return checksum length.\n      return checksumDataLength;\n    }\n    getChecksum().calculateChunkedSums(outputData, 0,\n        outputData.length, checksumBuf, 0);\n\n    // updates digest using the checksum array of bytes\n    updateDigester(checksumBuf, getChecksum().getBytesPerChecksum());\n    return checksumBuf.length;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/erasurecode/StripedBlockChecksumReconstructor.java",
          "extendedDetails": {
            "oldValue": "[outputData-byte[], toReconstructLen-int, digester-MessageDigest]",
            "newValue": "[outputData-byte[], toReconstructLen-int]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-13056. Expose file-level composite CRCs in HDFS which are comparable across different instances/layouts. Contributed by Dennis Huo.\n",
          "commitDate": "10/04/18 9:31 PM",
          "commitName": "7c9cdad6d04c98db5a83e2108219bf6e6c903daf",
          "commitAuthor": "Xiao Chen",
          "commitDateOld": "13/12/17 2:56 PM",
          "commitNameOld": "46e18c8da76ea8d91a16e59ba1154c30f37cb9fd",
          "commitAuthorOld": "Chen Liang",
          "daysBetweenCommits": 118.23,
          "commitsBetweenForRepo": 858,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,50 +1,50 @@\n-  private long checksumWithTargetOutput(byte[] outputData, int toReconstructLen,\n-      MessageDigest digester) throws IOException {\n+  private long checksumWithTargetOutput(byte[] outputData, int toReconstructLen)\n+      throws IOException {\n     long checksumDataLength \u003d 0;\n     // Calculate partial block checksum. There are two cases.\n     // case-1) length of data bytes which is fraction of bytesPerCRC\n     // case-2) length of data bytes which is less than bytesPerCRC\n     if (requestedLen \u003c\u003d toReconstructLen) {\n       int remainingLen \u003d Math.toIntExact(requestedLen);\n       outputData \u003d Arrays.copyOf(targetBuffer.array(), remainingLen);\n \n       int partialLength \u003d remainingLen % getChecksum().getBytesPerChecksum();\n \n       int checksumRemaining \u003d (remainingLen\n           / getChecksum().getBytesPerChecksum())\n           * getChecksum().getChecksumSize();\n \n       int dataOffset \u003d 0;\n \n       // case-1) length of data bytes which is fraction of bytesPerCRC\n       if (checksumRemaining \u003e 0) {\n         remainingLen \u003d remainingLen - partialLength;\n         checksumBuf \u003d new byte[checksumRemaining];\n         getChecksum().calculateChunkedSums(outputData, dataOffset,\n             remainingLen, checksumBuf, 0);\n-        digester.update(checksumBuf, 0, checksumBuf.length);\n+        updateDigester(checksumBuf, getChecksum().getBytesPerChecksum());\n         checksumDataLength \u003d checksumBuf.length;\n         dataOffset \u003d remainingLen;\n       }\n \n       // case-2) length of data bytes which is less than bytesPerCRC\n       if (partialLength \u003e 0) {\n         byte[] partialCrc \u003d new byte[getChecksum().getChecksumSize()];\n         getChecksum().reset();\n         getChecksum().update(outputData, dataOffset, partialLength);\n         getChecksum().writeValue(partialCrc, 0, true);\n-        digester.update(partialCrc);\n+        updateDigester(partialCrc, partialLength);\n         checksumDataLength +\u003d partialCrc.length;\n       }\n \n       clearBuffers();\n       // calculated checksum for the requested length, return checksum length.\n       return checksumDataLength;\n     }\n     getChecksum().calculateChunkedSums(outputData, 0,\n         outputData.length, checksumBuf, 0);\n \n     // updates digest using the checksum array of bytes\n-    digester.update(checksumBuf, 0, checksumBuf.length);\n+    updateDigester(checksumBuf, getChecksum().getBytesPerChecksum());\n     return checksumBuf.length;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private long checksumWithTargetOutput(byte[] outputData, int toReconstructLen)\n      throws IOException {\n    long checksumDataLength \u003d 0;\n    // Calculate partial block checksum. There are two cases.\n    // case-1) length of data bytes which is fraction of bytesPerCRC\n    // case-2) length of data bytes which is less than bytesPerCRC\n    if (requestedLen \u003c\u003d toReconstructLen) {\n      int remainingLen \u003d Math.toIntExact(requestedLen);\n      outputData \u003d Arrays.copyOf(targetBuffer.array(), remainingLen);\n\n      int partialLength \u003d remainingLen % getChecksum().getBytesPerChecksum();\n\n      int checksumRemaining \u003d (remainingLen\n          / getChecksum().getBytesPerChecksum())\n          * getChecksum().getChecksumSize();\n\n      int dataOffset \u003d 0;\n\n      // case-1) length of data bytes which is fraction of bytesPerCRC\n      if (checksumRemaining \u003e 0) {\n        remainingLen \u003d remainingLen - partialLength;\n        checksumBuf \u003d new byte[checksumRemaining];\n        getChecksum().calculateChunkedSums(outputData, dataOffset,\n            remainingLen, checksumBuf, 0);\n        updateDigester(checksumBuf, getChecksum().getBytesPerChecksum());\n        checksumDataLength \u003d checksumBuf.length;\n        dataOffset \u003d remainingLen;\n      }\n\n      // case-2) length of data bytes which is less than bytesPerCRC\n      if (partialLength \u003e 0) {\n        byte[] partialCrc \u003d new byte[getChecksum().getChecksumSize()];\n        getChecksum().reset();\n        getChecksum().update(outputData, dataOffset, partialLength);\n        getChecksum().writeValue(partialCrc, 0, true);\n        updateDigester(partialCrc, partialLength);\n        checksumDataLength +\u003d partialCrc.length;\n      }\n\n      clearBuffers();\n      // calculated checksum for the requested length, return checksum length.\n      return checksumDataLength;\n    }\n    getChecksum().calculateChunkedSums(outputData, 0,\n        outputData.length, checksumBuf, 0);\n\n    // updates digest using the checksum array of bytes\n    updateDigester(checksumBuf, getChecksum().getBytesPerChecksum());\n    return checksumBuf.length;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/erasurecode/StripedBlockChecksumReconstructor.java",
          "extendedDetails": {}
        }
      ]
    },
    "46e18c8da76ea8d91a16e59ba1154c30f37cb9fd": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14914. Change to a safely casting long to int. Contributed by Ajay Kumar.\n",
      "commitDate": "13/12/17 2:56 PM",
      "commitName": "46e18c8da76ea8d91a16e59ba1154c30f37cb9fd",
      "commitAuthor": "Chen Liang",
      "commitDateOld": "16/10/17 7:44 PM",
      "commitNameOld": "31ebccc96238136560f4210bdf6766fe18e0650c",
      "commitAuthorOld": "Lei Xu",
      "daysBetweenCommits": 57.84,
      "commitsBetweenForRepo": 429,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,50 +1,50 @@\n   private long checksumWithTargetOutput(byte[] outputData, int toReconstructLen,\n       MessageDigest digester) throws IOException {\n     long checksumDataLength \u003d 0;\n     // Calculate partial block checksum. There are two cases.\n     // case-1) length of data bytes which is fraction of bytesPerCRC\n     // case-2) length of data bytes which is less than bytesPerCRC\n     if (requestedLen \u003c\u003d toReconstructLen) {\n-      int remainingLen \u003d (int) requestedLen;\n+      int remainingLen \u003d Math.toIntExact(requestedLen);\n       outputData \u003d Arrays.copyOf(targetBuffer.array(), remainingLen);\n \n       int partialLength \u003d remainingLen % getChecksum().getBytesPerChecksum();\n \n       int checksumRemaining \u003d (remainingLen\n           / getChecksum().getBytesPerChecksum())\n           * getChecksum().getChecksumSize();\n \n       int dataOffset \u003d 0;\n \n       // case-1) length of data bytes which is fraction of bytesPerCRC\n       if (checksumRemaining \u003e 0) {\n         remainingLen \u003d remainingLen - partialLength;\n         checksumBuf \u003d new byte[checksumRemaining];\n         getChecksum().calculateChunkedSums(outputData, dataOffset,\n             remainingLen, checksumBuf, 0);\n         digester.update(checksumBuf, 0, checksumBuf.length);\n         checksumDataLength \u003d checksumBuf.length;\n         dataOffset \u003d remainingLen;\n       }\n \n       // case-2) length of data bytes which is less than bytesPerCRC\n       if (partialLength \u003e 0) {\n         byte[] partialCrc \u003d new byte[getChecksum().getChecksumSize()];\n         getChecksum().reset();\n         getChecksum().update(outputData, dataOffset, partialLength);\n         getChecksum().writeValue(partialCrc, 0, true);\n         digester.update(partialCrc);\n         checksumDataLength +\u003d partialCrc.length;\n       }\n \n       clearBuffers();\n       // calculated checksum for the requested length, return checksum length.\n       return checksumDataLength;\n     }\n     getChecksum().calculateChunkedSums(outputData, 0,\n         outputData.length, checksumBuf, 0);\n \n     // updates digest using the checksum array of bytes\n     digester.update(checksumBuf, 0, checksumBuf.length);\n     return checksumBuf.length;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private long checksumWithTargetOutput(byte[] outputData, int toReconstructLen,\n      MessageDigest digester) throws IOException {\n    long checksumDataLength \u003d 0;\n    // Calculate partial block checksum. There are two cases.\n    // case-1) length of data bytes which is fraction of bytesPerCRC\n    // case-2) length of data bytes which is less than bytesPerCRC\n    if (requestedLen \u003c\u003d toReconstructLen) {\n      int remainingLen \u003d Math.toIntExact(requestedLen);\n      outputData \u003d Arrays.copyOf(targetBuffer.array(), remainingLen);\n\n      int partialLength \u003d remainingLen % getChecksum().getBytesPerChecksum();\n\n      int checksumRemaining \u003d (remainingLen\n          / getChecksum().getBytesPerChecksum())\n          * getChecksum().getChecksumSize();\n\n      int dataOffset \u003d 0;\n\n      // case-1) length of data bytes which is fraction of bytesPerCRC\n      if (checksumRemaining \u003e 0) {\n        remainingLen \u003d remainingLen - partialLength;\n        checksumBuf \u003d new byte[checksumRemaining];\n        getChecksum().calculateChunkedSums(outputData, dataOffset,\n            remainingLen, checksumBuf, 0);\n        digester.update(checksumBuf, 0, checksumBuf.length);\n        checksumDataLength \u003d checksumBuf.length;\n        dataOffset \u003d remainingLen;\n      }\n\n      // case-2) length of data bytes which is less than bytesPerCRC\n      if (partialLength \u003e 0) {\n        byte[] partialCrc \u003d new byte[getChecksum().getChecksumSize()];\n        getChecksum().reset();\n        getChecksum().update(outputData, dataOffset, partialLength);\n        getChecksum().writeValue(partialCrc, 0, true);\n        digester.update(partialCrc);\n        checksumDataLength +\u003d partialCrc.length;\n      }\n\n      clearBuffers();\n      // calculated checksum for the requested length, return checksum length.\n      return checksumDataLength;\n    }\n    getChecksum().calculateChunkedSums(outputData, 0,\n        outputData.length, checksumBuf, 0);\n\n    // updates digest using the checksum array of bytes\n    digester.update(checksumBuf, 0, checksumBuf.length);\n    return checksumBuf.length;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/erasurecode/StripedBlockChecksumReconstructor.java",
      "extendedDetails": {}
    },
    "287effff9327450240d65e27e31bed2649a7a100": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10935. TestFileChecksum fails in some cases. Contributed by Sammi Chen\n",
      "commitDate": "25/10/16 8:40 PM",
      "commitName": "287effff9327450240d65e27e31bed2649a7a100",
      "commitAuthor": "Kai Zheng",
      "commitDateOld": "12/08/16 10:52 PM",
      "commitNameOld": "b5af9be72c72734d668f817c99d889031922a951",
      "commitAuthorOld": "Kai Zheng",
      "daysBetweenCommits": 73.91,
      "commitsBetweenForRepo": 489,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,49 +1,50 @@\n   private long checksumWithTargetOutput(byte[] outputData, int toReconstructLen,\n       MessageDigest digester) throws IOException {\n     long checksumDataLength \u003d 0;\n     // Calculate partial block checksum. There are two cases.\n     // case-1) length of data bytes which is fraction of bytesPerCRC\n     // case-2) length of data bytes which is less than bytesPerCRC\n     if (requestedLen \u003c\u003d toReconstructLen) {\n       int remainingLen \u003d (int) requestedLen;\n       outputData \u003d Arrays.copyOf(targetBuffer.array(), remainingLen);\n \n       int partialLength \u003d remainingLen % getChecksum().getBytesPerChecksum();\n \n       int checksumRemaining \u003d (remainingLen\n           / getChecksum().getBytesPerChecksum())\n           * getChecksum().getChecksumSize();\n \n       int dataOffset \u003d 0;\n \n       // case-1) length of data bytes which is fraction of bytesPerCRC\n       if (checksumRemaining \u003e 0) {\n         remainingLen \u003d remainingLen - partialLength;\n         checksumBuf \u003d new byte[checksumRemaining];\n         getChecksum().calculateChunkedSums(outputData, dataOffset,\n             remainingLen, checksumBuf, 0);\n         digester.update(checksumBuf, 0, checksumBuf.length);\n         checksumDataLength \u003d checksumBuf.length;\n         dataOffset \u003d remainingLen;\n       }\n \n       // case-2) length of data bytes which is less than bytesPerCRC\n       if (partialLength \u003e 0) {\n         byte[] partialCrc \u003d new byte[getChecksum().getChecksumSize()];\n+        getChecksum().reset();\n         getChecksum().update(outputData, dataOffset, partialLength);\n         getChecksum().writeValue(partialCrc, 0, true);\n         digester.update(partialCrc);\n         checksumDataLength +\u003d partialCrc.length;\n       }\n \n       clearBuffers();\n       // calculated checksum for the requested length, return checksum length.\n       return checksumDataLength;\n     }\n     getChecksum().calculateChunkedSums(outputData, 0,\n         outputData.length, checksumBuf, 0);\n \n     // updates digest using the checksum array of bytes\n     digester.update(checksumBuf, 0, checksumBuf.length);\n     return checksumBuf.length;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private long checksumWithTargetOutput(byte[] outputData, int toReconstructLen,\n      MessageDigest digester) throws IOException {\n    long checksumDataLength \u003d 0;\n    // Calculate partial block checksum. There are two cases.\n    // case-1) length of data bytes which is fraction of bytesPerCRC\n    // case-2) length of data bytes which is less than bytesPerCRC\n    if (requestedLen \u003c\u003d toReconstructLen) {\n      int remainingLen \u003d (int) requestedLen;\n      outputData \u003d Arrays.copyOf(targetBuffer.array(), remainingLen);\n\n      int partialLength \u003d remainingLen % getChecksum().getBytesPerChecksum();\n\n      int checksumRemaining \u003d (remainingLen\n          / getChecksum().getBytesPerChecksum())\n          * getChecksum().getChecksumSize();\n\n      int dataOffset \u003d 0;\n\n      // case-1) length of data bytes which is fraction of bytesPerCRC\n      if (checksumRemaining \u003e 0) {\n        remainingLen \u003d remainingLen - partialLength;\n        checksumBuf \u003d new byte[checksumRemaining];\n        getChecksum().calculateChunkedSums(outputData, dataOffset,\n            remainingLen, checksumBuf, 0);\n        digester.update(checksumBuf, 0, checksumBuf.length);\n        checksumDataLength \u003d checksumBuf.length;\n        dataOffset \u003d remainingLen;\n      }\n\n      // case-2) length of data bytes which is less than bytesPerCRC\n      if (partialLength \u003e 0) {\n        byte[] partialCrc \u003d new byte[getChecksum().getChecksumSize()];\n        getChecksum().reset();\n        getChecksum().update(outputData, dataOffset, partialLength);\n        getChecksum().writeValue(partialCrc, 0, true);\n        digester.update(partialCrc);\n        checksumDataLength +\u003d partialCrc.length;\n      }\n\n      clearBuffers();\n      // calculated checksum for the requested length, return checksum length.\n      return checksumDataLength;\n    }\n    getChecksum().calculateChunkedSums(outputData, 0,\n        outputData.length, checksumBuf, 0);\n\n    // updates digest using the checksum array of bytes\n    digester.update(checksumBuf, 0, checksumBuf.length);\n    return checksumBuf.length;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/erasurecode/StripedBlockChecksumReconstructor.java",
      "extendedDetails": {}
    },
    "e6cb07520f935efde3e881de8f84ee7f6e0a746f": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-10460. Recompute block checksum for a particular range less than file size on the fly by reconstructing missed block. Contributed by Rakesh R\n",
      "commitDate": "24/06/16 2:39 AM",
      "commitName": "e6cb07520f935efde3e881de8f84ee7f6e0a746f",
      "commitAuthor": "Kai Zheng",
      "diff": "@@ -0,0 +1,49 @@\n+  private long checksumWithTargetOutput(byte[] outputData, int toReconstructLen,\n+      MessageDigest digester) throws IOException {\n+    long checksumDataLength \u003d 0;\n+    // Calculate partial block checksum. There are two cases.\n+    // case-1) length of data bytes which is fraction of bytesPerCRC\n+    // case-2) length of data bytes which is less than bytesPerCRC\n+    if (requestedLen \u003c\u003d toReconstructLen) {\n+      int remainingLen \u003d (int) requestedLen;\n+      outputData \u003d Arrays.copyOf(targetBuffer.array(), remainingLen);\n+\n+      int partialLength \u003d remainingLen % getChecksum().getBytesPerChecksum();\n+\n+      int checksumRemaining \u003d (remainingLen\n+          / getChecksum().getBytesPerChecksum())\n+          * getChecksum().getChecksumSize();\n+\n+      int dataOffset \u003d 0;\n+\n+      // case-1) length of data bytes which is fraction of bytesPerCRC\n+      if (checksumRemaining \u003e 0) {\n+        remainingLen \u003d remainingLen - partialLength;\n+        checksumBuf \u003d new byte[checksumRemaining];\n+        getChecksum().calculateChunkedSums(outputData, dataOffset,\n+            remainingLen, checksumBuf, 0);\n+        digester.update(checksumBuf, 0, checksumBuf.length);\n+        checksumDataLength \u003d checksumBuf.length;\n+        dataOffset \u003d remainingLen;\n+      }\n+\n+      // case-2) length of data bytes which is less than bytesPerCRC\n+      if (partialLength \u003e 0) {\n+        byte[] partialCrc \u003d new byte[getChecksum().getChecksumSize()];\n+        getChecksum().update(outputData, dataOffset, partialLength);\n+        getChecksum().writeValue(partialCrc, 0, true);\n+        digester.update(partialCrc);\n+        checksumDataLength +\u003d partialCrc.length;\n+      }\n+\n+      clearBuffers();\n+      // calculated checksum for the requested length, return checksum length.\n+      return checksumDataLength;\n+    }\n+    getChecksum().calculateChunkedSums(outputData, 0,\n+        outputData.length, checksumBuf, 0);\n+\n+    // updates digest using the checksum array of bytes\n+    digester.update(checksumBuf, 0, checksumBuf.length);\n+    return checksumBuf.length;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private long checksumWithTargetOutput(byte[] outputData, int toReconstructLen,\n      MessageDigest digester) throws IOException {\n    long checksumDataLength \u003d 0;\n    // Calculate partial block checksum. There are two cases.\n    // case-1) length of data bytes which is fraction of bytesPerCRC\n    // case-2) length of data bytes which is less than bytesPerCRC\n    if (requestedLen \u003c\u003d toReconstructLen) {\n      int remainingLen \u003d (int) requestedLen;\n      outputData \u003d Arrays.copyOf(targetBuffer.array(), remainingLen);\n\n      int partialLength \u003d remainingLen % getChecksum().getBytesPerChecksum();\n\n      int checksumRemaining \u003d (remainingLen\n          / getChecksum().getBytesPerChecksum())\n          * getChecksum().getChecksumSize();\n\n      int dataOffset \u003d 0;\n\n      // case-1) length of data bytes which is fraction of bytesPerCRC\n      if (checksumRemaining \u003e 0) {\n        remainingLen \u003d remainingLen - partialLength;\n        checksumBuf \u003d new byte[checksumRemaining];\n        getChecksum().calculateChunkedSums(outputData, dataOffset,\n            remainingLen, checksumBuf, 0);\n        digester.update(checksumBuf, 0, checksumBuf.length);\n        checksumDataLength \u003d checksumBuf.length;\n        dataOffset \u003d remainingLen;\n      }\n\n      // case-2) length of data bytes which is less than bytesPerCRC\n      if (partialLength \u003e 0) {\n        byte[] partialCrc \u003d new byte[getChecksum().getChecksumSize()];\n        getChecksum().update(outputData, dataOffset, partialLength);\n        getChecksum().writeValue(partialCrc, 0, true);\n        digester.update(partialCrc);\n        checksumDataLength +\u003d partialCrc.length;\n      }\n\n      clearBuffers();\n      // calculated checksum for the requested length, return checksum length.\n      return checksumDataLength;\n    }\n    getChecksum().calculateChunkedSums(outputData, 0,\n        outputData.length, checksumBuf, 0);\n\n    // updates digest using the checksum array of bytes\n    digester.update(checksumBuf, 0, checksumBuf.length);\n    return checksumBuf.length;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/erasurecode/StripedBlockChecksumReconstructor.java"
    }
  }
}