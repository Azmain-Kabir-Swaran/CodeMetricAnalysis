{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "SwiftRestClient.java",
  "functionName": "perform",
  "functionId": "perform___reason-String__uri-URI__processor-HttpRequestProcessor__M,R__",
  "sourceFilePath": "hadoop-tools/hadoop-openstack/src/main/java/org/apache/hadoop/fs/swift/http/SwiftRestClient.java",
  "functionStartLine": 1384,
  "functionEndLine": 1446,
  "numCommitsSeen": 10,
  "timeTaken": 2486,
  "changeHistory": [
    "62579b69a0a294ba1ea14cf76c650b640f89f331",
    "3caca924bc72fe4a0e5b1ea89adb098cc1eb7874"
  ],
  "changeHistoryShort": {
    "62579b69a0a294ba1ea14cf76c650b640f89f331": "Ymultichange(Yparameterchange,Ybodychange)",
    "3caca924bc72fe4a0e5b1ea89adb098cc1eb7874": "Yintroduced"
  },
  "changeHistoryDetails": {
    "62579b69a0a294ba1ea14cf76c650b640f89f331": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HADOOP-11614. Remove httpclient dependency from hadoop-openstack. Contributed by Akira Ajisaka, Brahma Reddy Battula, and Steve Loughran.\n",
      "commitDate": "27/04/17 12:57 AM",
      "commitName": "62579b69a0a294ba1ea14cf76c650b640f89f331",
      "commitAuthor": "Akira Ajisaka",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-11614. Remove httpclient dependency from hadoop-openstack. Contributed by Akira Ajisaka, Brahma Reddy Battula, and Steve Loughran.\n",
          "commitDate": "27/04/17 12:57 AM",
          "commitName": "62579b69a0a294ba1ea14cf76c650b640f89f331",
          "commitAuthor": "Akira Ajisaka",
          "commitDateOld": "01/10/15 9:25 AM",
          "commitNameOld": "ecbfd68974691cc9103ae477d10c15c7f21b6dea",
          "commitAuthorOld": "Akira Ajisaka",
          "daysBetweenCommits": 573.65,
          "commitsBetweenForRepo": 3812,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,56 +1,63 @@\n-  private \u003cM extends HttpMethod, R\u003e R perform(String reason,\n-                                              URI uri,\n-                                              HttpMethodProcessor\u003cM, R\u003e processor)\n+  private \u003cM extends HttpRequestBase, R\u003e R perform(String reason, URI uri,\n+      HttpRequestProcessor\u003cM, R\u003e processor)\n       throws IOException, SwiftBadRequestException, SwiftInternalStateException,\n             SwiftInvalidResponseException, FileNotFoundException {\n     checkNotNull(uri);\n     checkNotNull(processor);\n \n-    final M method \u003d processor.createMethod(uri.toString());\n-\n+    final M req \u003d processor.createRequest(uri.toString());\n+    req.addHeader(HEADER_USER_AGENT, SWIFT_USER_AGENT);\n     //retry policy\n-    HttpMethodParams methodParams \u003d method.getParams();\n-    methodParams.setParameter(HttpMethodParams.RETRY_HANDLER,\n-            new DefaultHttpMethodRetryHandler(\n-                    retryCount, false));\n-    methodParams.setIntParameter(HttpConnectionParams.CONNECTION_TIMEOUT,\n-                                 connectTimeout);\n-    methodParams.setSoTimeout(socketTimeout);\n-    method.addRequestHeader(HEADER_USER_AGENT, SWIFT_USER_AGENT);\n+    HttpClientBuilder clientBuilder \u003d HttpClientBuilder.create();\n+    clientBuilder.setRetryHandler(\n+        new DefaultHttpRequestRetryHandler(retryCount, false));\n+    RequestConfig.Builder requestConfigBuilder \u003d\n+        RequestConfig.custom().setConnectTimeout(connectTimeout);\n+    if (proxyHost !\u003d null) {\n+      requestConfigBuilder.setProxy(new HttpHost(proxyHost, proxyPort));\n+    }\n+    clientBuilder.setDefaultRequestConfig(requestConfigBuilder.build());\n+    clientBuilder.setDefaultSocketConfig(\n+        SocketConfig.custom().setSoTimeout(socketTimeout).build());\n     Duration duration \u003d new Duration();\n     boolean success \u003d false;\n+    HttpResponse resp;\n     try {\n+      // client should not be closed in this method because\n+      // the connection can be used later\n+      CloseableHttpClient client \u003d clientBuilder.build();\n       int statusCode \u003d 0;\n       try {\n-        statusCode \u003d exec(method);\n+        resp \u003d exec(client, req);\n+        statusCode \u003d checkNotNull(resp.getStatusLine().getStatusCode());\n       } catch (IOException e) {\n         //rethrow with extra diagnostics and wiki links\n-        throw ExceptionDiags.wrapException(uri.toString(), method.getName(), e);\n+        throw ExceptionDiags.wrapException(uri.toString(), req.getMethod(), e);\n       }\n \n       //look at the response and see if it was valid or not.\n       //Valid is more than a simple 200; even 404 \"not found\" is considered\n       //valid -which it is for many methods.\n \n       //validate the allowed status code for this operation\n       int[] allowedStatusCodes \u003d processor.getAllowedStatusCodes();\n       boolean validResponse \u003d isStatusCodeExpected(statusCode,\n-              allowedStatusCodes);\n+          allowedStatusCodes);\n \n       if (!validResponse) {\n-        IOException ioe \u003d buildException(uri, method, statusCode);\n+        IOException ioe \u003d buildException(uri, req, resp, statusCode);\n         throw ioe;\n       }\n \n-      R r \u003d processor.extractResult(method);\n+      R r \u003d processor.extractResult(req, resp);\n       success \u003d true;\n       return r;\n     } catch (IOException e) {\n       //release the connection -always\n-      method.releaseConnection();\n+      req.releaseConnection();\n       throw e;\n     } finally {\n       duration.finished();\n-      durationStats.add(method.getName()+\" \" + reason, duration, success);\n+      durationStats.add(req.getMethod() + \" \" + reason, duration, success);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private \u003cM extends HttpRequestBase, R\u003e R perform(String reason, URI uri,\n      HttpRequestProcessor\u003cM, R\u003e processor)\n      throws IOException, SwiftBadRequestException, SwiftInternalStateException,\n            SwiftInvalidResponseException, FileNotFoundException {\n    checkNotNull(uri);\n    checkNotNull(processor);\n\n    final M req \u003d processor.createRequest(uri.toString());\n    req.addHeader(HEADER_USER_AGENT, SWIFT_USER_AGENT);\n    //retry policy\n    HttpClientBuilder clientBuilder \u003d HttpClientBuilder.create();\n    clientBuilder.setRetryHandler(\n        new DefaultHttpRequestRetryHandler(retryCount, false));\n    RequestConfig.Builder requestConfigBuilder \u003d\n        RequestConfig.custom().setConnectTimeout(connectTimeout);\n    if (proxyHost !\u003d null) {\n      requestConfigBuilder.setProxy(new HttpHost(proxyHost, proxyPort));\n    }\n    clientBuilder.setDefaultRequestConfig(requestConfigBuilder.build());\n    clientBuilder.setDefaultSocketConfig(\n        SocketConfig.custom().setSoTimeout(socketTimeout).build());\n    Duration duration \u003d new Duration();\n    boolean success \u003d false;\n    HttpResponse resp;\n    try {\n      // client should not be closed in this method because\n      // the connection can be used later\n      CloseableHttpClient client \u003d clientBuilder.build();\n      int statusCode \u003d 0;\n      try {\n        resp \u003d exec(client, req);\n        statusCode \u003d checkNotNull(resp.getStatusLine().getStatusCode());\n      } catch (IOException e) {\n        //rethrow with extra diagnostics and wiki links\n        throw ExceptionDiags.wrapException(uri.toString(), req.getMethod(), e);\n      }\n\n      //look at the response and see if it was valid or not.\n      //Valid is more than a simple 200; even 404 \"not found\" is considered\n      //valid -which it is for many methods.\n\n      //validate the allowed status code for this operation\n      int[] allowedStatusCodes \u003d processor.getAllowedStatusCodes();\n      boolean validResponse \u003d isStatusCodeExpected(statusCode,\n          allowedStatusCodes);\n\n      if (!validResponse) {\n        IOException ioe \u003d buildException(uri, req, resp, statusCode);\n        throw ioe;\n      }\n\n      R r \u003d processor.extractResult(req, resp);\n      success \u003d true;\n      return r;\n    } catch (IOException e) {\n      //release the connection -always\n      req.releaseConnection();\n      throw e;\n    } finally {\n      duration.finished();\n      durationStats.add(req.getMethod() + \" \" + reason, duration, success);\n    }\n  }",
          "path": "hadoop-tools/hadoop-openstack/src/main/java/org/apache/hadoop/fs/swift/http/SwiftRestClient.java",
          "extendedDetails": {
            "oldValue": "[reason-String, uri-URI, processor-HttpMethodProcessor\u003cM,R\u003e]",
            "newValue": "[reason-String, uri-URI, processor-HttpRequestProcessor\u003cM,R\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-11614. Remove httpclient dependency from hadoop-openstack. Contributed by Akira Ajisaka, Brahma Reddy Battula, and Steve Loughran.\n",
          "commitDate": "27/04/17 12:57 AM",
          "commitName": "62579b69a0a294ba1ea14cf76c650b640f89f331",
          "commitAuthor": "Akira Ajisaka",
          "commitDateOld": "01/10/15 9:25 AM",
          "commitNameOld": "ecbfd68974691cc9103ae477d10c15c7f21b6dea",
          "commitAuthorOld": "Akira Ajisaka",
          "daysBetweenCommits": 573.65,
          "commitsBetweenForRepo": 3812,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,56 +1,63 @@\n-  private \u003cM extends HttpMethod, R\u003e R perform(String reason,\n-                                              URI uri,\n-                                              HttpMethodProcessor\u003cM, R\u003e processor)\n+  private \u003cM extends HttpRequestBase, R\u003e R perform(String reason, URI uri,\n+      HttpRequestProcessor\u003cM, R\u003e processor)\n       throws IOException, SwiftBadRequestException, SwiftInternalStateException,\n             SwiftInvalidResponseException, FileNotFoundException {\n     checkNotNull(uri);\n     checkNotNull(processor);\n \n-    final M method \u003d processor.createMethod(uri.toString());\n-\n+    final M req \u003d processor.createRequest(uri.toString());\n+    req.addHeader(HEADER_USER_AGENT, SWIFT_USER_AGENT);\n     //retry policy\n-    HttpMethodParams methodParams \u003d method.getParams();\n-    methodParams.setParameter(HttpMethodParams.RETRY_HANDLER,\n-            new DefaultHttpMethodRetryHandler(\n-                    retryCount, false));\n-    methodParams.setIntParameter(HttpConnectionParams.CONNECTION_TIMEOUT,\n-                                 connectTimeout);\n-    methodParams.setSoTimeout(socketTimeout);\n-    method.addRequestHeader(HEADER_USER_AGENT, SWIFT_USER_AGENT);\n+    HttpClientBuilder clientBuilder \u003d HttpClientBuilder.create();\n+    clientBuilder.setRetryHandler(\n+        new DefaultHttpRequestRetryHandler(retryCount, false));\n+    RequestConfig.Builder requestConfigBuilder \u003d\n+        RequestConfig.custom().setConnectTimeout(connectTimeout);\n+    if (proxyHost !\u003d null) {\n+      requestConfigBuilder.setProxy(new HttpHost(proxyHost, proxyPort));\n+    }\n+    clientBuilder.setDefaultRequestConfig(requestConfigBuilder.build());\n+    clientBuilder.setDefaultSocketConfig(\n+        SocketConfig.custom().setSoTimeout(socketTimeout).build());\n     Duration duration \u003d new Duration();\n     boolean success \u003d false;\n+    HttpResponse resp;\n     try {\n+      // client should not be closed in this method because\n+      // the connection can be used later\n+      CloseableHttpClient client \u003d clientBuilder.build();\n       int statusCode \u003d 0;\n       try {\n-        statusCode \u003d exec(method);\n+        resp \u003d exec(client, req);\n+        statusCode \u003d checkNotNull(resp.getStatusLine().getStatusCode());\n       } catch (IOException e) {\n         //rethrow with extra diagnostics and wiki links\n-        throw ExceptionDiags.wrapException(uri.toString(), method.getName(), e);\n+        throw ExceptionDiags.wrapException(uri.toString(), req.getMethod(), e);\n       }\n \n       //look at the response and see if it was valid or not.\n       //Valid is more than a simple 200; even 404 \"not found\" is considered\n       //valid -which it is for many methods.\n \n       //validate the allowed status code for this operation\n       int[] allowedStatusCodes \u003d processor.getAllowedStatusCodes();\n       boolean validResponse \u003d isStatusCodeExpected(statusCode,\n-              allowedStatusCodes);\n+          allowedStatusCodes);\n \n       if (!validResponse) {\n-        IOException ioe \u003d buildException(uri, method, statusCode);\n+        IOException ioe \u003d buildException(uri, req, resp, statusCode);\n         throw ioe;\n       }\n \n-      R r \u003d processor.extractResult(method);\n+      R r \u003d processor.extractResult(req, resp);\n       success \u003d true;\n       return r;\n     } catch (IOException e) {\n       //release the connection -always\n-      method.releaseConnection();\n+      req.releaseConnection();\n       throw e;\n     } finally {\n       duration.finished();\n-      durationStats.add(method.getName()+\" \" + reason, duration, success);\n+      durationStats.add(req.getMethod() + \" \" + reason, duration, success);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private \u003cM extends HttpRequestBase, R\u003e R perform(String reason, URI uri,\n      HttpRequestProcessor\u003cM, R\u003e processor)\n      throws IOException, SwiftBadRequestException, SwiftInternalStateException,\n            SwiftInvalidResponseException, FileNotFoundException {\n    checkNotNull(uri);\n    checkNotNull(processor);\n\n    final M req \u003d processor.createRequest(uri.toString());\n    req.addHeader(HEADER_USER_AGENT, SWIFT_USER_AGENT);\n    //retry policy\n    HttpClientBuilder clientBuilder \u003d HttpClientBuilder.create();\n    clientBuilder.setRetryHandler(\n        new DefaultHttpRequestRetryHandler(retryCount, false));\n    RequestConfig.Builder requestConfigBuilder \u003d\n        RequestConfig.custom().setConnectTimeout(connectTimeout);\n    if (proxyHost !\u003d null) {\n      requestConfigBuilder.setProxy(new HttpHost(proxyHost, proxyPort));\n    }\n    clientBuilder.setDefaultRequestConfig(requestConfigBuilder.build());\n    clientBuilder.setDefaultSocketConfig(\n        SocketConfig.custom().setSoTimeout(socketTimeout).build());\n    Duration duration \u003d new Duration();\n    boolean success \u003d false;\n    HttpResponse resp;\n    try {\n      // client should not be closed in this method because\n      // the connection can be used later\n      CloseableHttpClient client \u003d clientBuilder.build();\n      int statusCode \u003d 0;\n      try {\n        resp \u003d exec(client, req);\n        statusCode \u003d checkNotNull(resp.getStatusLine().getStatusCode());\n      } catch (IOException e) {\n        //rethrow with extra diagnostics and wiki links\n        throw ExceptionDiags.wrapException(uri.toString(), req.getMethod(), e);\n      }\n\n      //look at the response and see if it was valid or not.\n      //Valid is more than a simple 200; even 404 \"not found\" is considered\n      //valid -which it is for many methods.\n\n      //validate the allowed status code for this operation\n      int[] allowedStatusCodes \u003d processor.getAllowedStatusCodes();\n      boolean validResponse \u003d isStatusCodeExpected(statusCode,\n          allowedStatusCodes);\n\n      if (!validResponse) {\n        IOException ioe \u003d buildException(uri, req, resp, statusCode);\n        throw ioe;\n      }\n\n      R r \u003d processor.extractResult(req, resp);\n      success \u003d true;\n      return r;\n    } catch (IOException e) {\n      //release the connection -always\n      req.releaseConnection();\n      throw e;\n    } finally {\n      duration.finished();\n      durationStats.add(req.getMethod() + \" \" + reason, duration, success);\n    }\n  }",
          "path": "hadoop-tools/hadoop-openstack/src/main/java/org/apache/hadoop/fs/swift/http/SwiftRestClient.java",
          "extendedDetails": {}
        }
      ]
    },
    "3caca924bc72fe4a0e5b1ea89adb098cc1eb7874": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-8545. Filesystem Implementation for OpenStack Swift\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1526854 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/09/13 4:32 AM",
      "commitName": "3caca924bc72fe4a0e5b1ea89adb098cc1eb7874",
      "commitAuthor": "Steve Loughran",
      "diff": "@@ -0,0 +1,56 @@\n+  private \u003cM extends HttpMethod, R\u003e R perform(String reason,\n+                                              URI uri,\n+                                              HttpMethodProcessor\u003cM, R\u003e processor)\n+      throws IOException, SwiftBadRequestException, SwiftInternalStateException,\n+            SwiftInvalidResponseException, FileNotFoundException {\n+    checkNotNull(uri);\n+    checkNotNull(processor);\n+\n+    final M method \u003d processor.createMethod(uri.toString());\n+\n+    //retry policy\n+    HttpMethodParams methodParams \u003d method.getParams();\n+    methodParams.setParameter(HttpMethodParams.RETRY_HANDLER,\n+            new DefaultHttpMethodRetryHandler(\n+                    retryCount, false));\n+    methodParams.setIntParameter(HttpConnectionParams.CONNECTION_TIMEOUT,\n+                                 connectTimeout);\n+    methodParams.setSoTimeout(socketTimeout);\n+    method.addRequestHeader(HEADER_USER_AGENT, SWIFT_USER_AGENT);\n+    Duration duration \u003d new Duration();\n+    boolean success \u003d false;\n+    try {\n+      int statusCode \u003d 0;\n+      try {\n+        statusCode \u003d exec(method);\n+      } catch (IOException e) {\n+        //rethrow with extra diagnostics and wiki links\n+        throw ExceptionDiags.wrapException(uri.toString(), method.getName(), e);\n+      }\n+\n+      //look at the response and see if it was valid or not.\n+      //Valid is more than a simple 200; even 404 \"not found\" is considered\n+      //valid -which it is for many methods.\n+\n+      //validate the allowed status code for this operation\n+      int[] allowedStatusCodes \u003d processor.getAllowedStatusCodes();\n+      boolean validResponse \u003d isStatusCodeExpected(statusCode,\n+              allowedStatusCodes);\n+\n+      if (!validResponse) {\n+        IOException ioe \u003d buildException(uri, method, statusCode);\n+        throw ioe;\n+      }\n+\n+      R r \u003d processor.extractResult(method);\n+      success \u003d true;\n+      return r;\n+    } catch (IOException e) {\n+      //release the connection -always\n+      method.releaseConnection();\n+      throw e;\n+    } finally {\n+      duration.finished();\n+      durationStats.add(method.getName()+\" \" + reason, duration, success);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private \u003cM extends HttpMethod, R\u003e R perform(String reason,\n                                              URI uri,\n                                              HttpMethodProcessor\u003cM, R\u003e processor)\n      throws IOException, SwiftBadRequestException, SwiftInternalStateException,\n            SwiftInvalidResponseException, FileNotFoundException {\n    checkNotNull(uri);\n    checkNotNull(processor);\n\n    final M method \u003d processor.createMethod(uri.toString());\n\n    //retry policy\n    HttpMethodParams methodParams \u003d method.getParams();\n    methodParams.setParameter(HttpMethodParams.RETRY_HANDLER,\n            new DefaultHttpMethodRetryHandler(\n                    retryCount, false));\n    methodParams.setIntParameter(HttpConnectionParams.CONNECTION_TIMEOUT,\n                                 connectTimeout);\n    methodParams.setSoTimeout(socketTimeout);\n    method.addRequestHeader(HEADER_USER_AGENT, SWIFT_USER_AGENT);\n    Duration duration \u003d new Duration();\n    boolean success \u003d false;\n    try {\n      int statusCode \u003d 0;\n      try {\n        statusCode \u003d exec(method);\n      } catch (IOException e) {\n        //rethrow with extra diagnostics and wiki links\n        throw ExceptionDiags.wrapException(uri.toString(), method.getName(), e);\n      }\n\n      //look at the response and see if it was valid or not.\n      //Valid is more than a simple 200; even 404 \"not found\" is considered\n      //valid -which it is for many methods.\n\n      //validate the allowed status code for this operation\n      int[] allowedStatusCodes \u003d processor.getAllowedStatusCodes();\n      boolean validResponse \u003d isStatusCodeExpected(statusCode,\n              allowedStatusCodes);\n\n      if (!validResponse) {\n        IOException ioe \u003d buildException(uri, method, statusCode);\n        throw ioe;\n      }\n\n      R r \u003d processor.extractResult(method);\n      success \u003d true;\n      return r;\n    } catch (IOException e) {\n      //release the connection -always\n      method.releaseConnection();\n      throw e;\n    } finally {\n      duration.finished();\n      durationStats.add(method.getName()+\" \" + reason, duration, success);\n    }\n  }",
      "path": "hadoop-tools/hadoop-openstack/src/main/java/org/apache/hadoop/fs/swift/http/SwiftRestClient.java"
    }
  }
}