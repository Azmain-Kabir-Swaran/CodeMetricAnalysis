{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ReencryptionUpdater.java",
  "functionName": "processTaskEntries",
  "functionId": "processTaskEntries___zoneNodePath-String(modifiers-final)__task-ReencryptionTask(modifiers-final)",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ReencryptionUpdater.java",
  "functionStartLine": 292,
  "functionEndLine": 357,
  "numCommitsSeen": 5,
  "timeTaken": 2193,
  "changeHistory": [
    "248d9b6fff648cdb02581d458556b6f7c090ef1a",
    "1000a2af04b24c123a3b08168f36b4e90420cab7"
  ],
  "changeHistoryShort": {
    "248d9b6fff648cdb02581d458556b6f7c090ef1a": "Ybodychange",
    "1000a2af04b24c123a3b08168f36b4e90420cab7": "Yintroduced"
  },
  "changeHistoryDetails": {
    "248d9b6fff648cdb02581d458556b6f7c090ef1a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12518. Re-encryption should handle task cancellation and progress better.\n",
      "commitDate": "20/10/17 4:25 PM",
      "commitName": "248d9b6fff648cdb02581d458556b6f7c090ef1a",
      "commitAuthor": "Xiao Chen",
      "commitDateOld": "03/09/17 7:50 PM",
      "commitNameOld": "633c1ea4554cae6cd684f60848497817d4ed3d82",
      "commitAuthorOld": "Xiao Chen",
      "daysBetweenCommits": 46.86,
      "commitsBetweenForRepo": 417,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,65 +1,66 @@\n   private void processTaskEntries(final String zoneNodePath,\n       final ReencryptionTask task) throws IOException, InterruptedException {\n     assert dir.hasWriteLock();\n     if (!task.batch.isEmpty() \u0026\u0026 task.numFailures \u003d\u003d 0) {\n       LOG.debug(\n           \"Updating file xattrs for re-encrypting zone {},\" + \" starting at {}\",\n           zoneNodePath, task.batch.getFirstFilePath());\n+      final int batchSize \u003d task.batch.size();\n       for (Iterator\u003cFileEdekInfo\u003e it \u003d task.batch.getBatch().iterator();\n            it.hasNext();) {\n         FileEdekInfo entry \u003d it.next();\n         // resolve the inode again, and skip if it\u0027s doesn\u0027t exist\n         LOG.trace(\"Updating {} for re-encryption.\", entry.getInodeId());\n         final INode inode \u003d dir.getInode(entry.getInodeId());\n         if (inode \u003d\u003d null) {\n           LOG.debug(\"INode {} doesn\u0027t exist, skipping re-encrypt.\",\n               entry.getInodeId());\n           // also remove from batch so later it\u0027s not saved.\n           it.remove();\n           continue;\n         }\n \n         // Cautiously check file encryption info, and only update if we\u0027re sure\n         // it\u0027s still using the same edek.\n         Preconditions.checkNotNull(entry.edek);\n         final FileEncryptionInfo fei \u003d FSDirEncryptionZoneOp\n             .getFileEncryptionInfo(dir, INodesInPath.fromINode(inode));\n         if (!fei.getKeyName().equals(entry.edek.getEncryptionKeyName())) {\n           LOG.debug(\"Inode {} EZ key changed, skipping re-encryption.\",\n               entry.getInodeId());\n           it.remove();\n           continue;\n         }\n         if (fei.getEzKeyVersionName()\n             .equals(entry.edek.getEncryptionKeyVersionName())) {\n           LOG.debug(\n               \"Inode {} EZ key version unchanged, skipping re-encryption.\",\n               entry.getInodeId());\n           it.remove();\n           continue;\n         }\n         if (!Arrays.equals(fei.getEncryptedDataEncryptionKey(),\n             entry.existingEdek.getEncryptedKeyVersion().getMaterial())) {\n           LOG.debug(\"Inode {} existing edek changed, skipping re-encryption\",\n               entry.getInodeId());\n           it.remove();\n           continue;\n         }\n         FileEncryptionInfo newFei \u003d new FileEncryptionInfo(fei.getCipherSuite(),\n             fei.getCryptoProtocolVersion(),\n             entry.edek.getEncryptedKeyVersion().getMaterial(),\n             entry.edek.getEncryptedKeyIv(), fei.getKeyName(),\n             entry.edek.getEncryptionKeyVersionName());\n         final INodesInPath iip \u003d INodesInPath.fromINode(inode);\n         FSDirEncryptionZoneOp\n             .setFileEncryptionInfo(dir, iip, newFei, XAttrSetFlag.REPLACE);\n         task.lastFile \u003d iip.getPath();\n         ++task.numFilesUpdated;\n       }\n \n       LOG.info(\"Updated xattrs on {}({}) files in zone {} for re-encryption,\"\n-              + \" starting:{}.\", task.numFilesUpdated, task.batch.size(),\n+              + \" starting:{}.\", task.numFilesUpdated, batchSize,\n           zoneNodePath, task.batch.getFirstFilePath());\n     }\n     task.processed \u003d true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void processTaskEntries(final String zoneNodePath,\n      final ReencryptionTask task) throws IOException, InterruptedException {\n    assert dir.hasWriteLock();\n    if (!task.batch.isEmpty() \u0026\u0026 task.numFailures \u003d\u003d 0) {\n      LOG.debug(\n          \"Updating file xattrs for re-encrypting zone {},\" + \" starting at {}\",\n          zoneNodePath, task.batch.getFirstFilePath());\n      final int batchSize \u003d task.batch.size();\n      for (Iterator\u003cFileEdekInfo\u003e it \u003d task.batch.getBatch().iterator();\n           it.hasNext();) {\n        FileEdekInfo entry \u003d it.next();\n        // resolve the inode again, and skip if it\u0027s doesn\u0027t exist\n        LOG.trace(\"Updating {} for re-encryption.\", entry.getInodeId());\n        final INode inode \u003d dir.getInode(entry.getInodeId());\n        if (inode \u003d\u003d null) {\n          LOG.debug(\"INode {} doesn\u0027t exist, skipping re-encrypt.\",\n              entry.getInodeId());\n          // also remove from batch so later it\u0027s not saved.\n          it.remove();\n          continue;\n        }\n\n        // Cautiously check file encryption info, and only update if we\u0027re sure\n        // it\u0027s still using the same edek.\n        Preconditions.checkNotNull(entry.edek);\n        final FileEncryptionInfo fei \u003d FSDirEncryptionZoneOp\n            .getFileEncryptionInfo(dir, INodesInPath.fromINode(inode));\n        if (!fei.getKeyName().equals(entry.edek.getEncryptionKeyName())) {\n          LOG.debug(\"Inode {} EZ key changed, skipping re-encryption.\",\n              entry.getInodeId());\n          it.remove();\n          continue;\n        }\n        if (fei.getEzKeyVersionName()\n            .equals(entry.edek.getEncryptionKeyVersionName())) {\n          LOG.debug(\n              \"Inode {} EZ key version unchanged, skipping re-encryption.\",\n              entry.getInodeId());\n          it.remove();\n          continue;\n        }\n        if (!Arrays.equals(fei.getEncryptedDataEncryptionKey(),\n            entry.existingEdek.getEncryptedKeyVersion().getMaterial())) {\n          LOG.debug(\"Inode {} existing edek changed, skipping re-encryption\",\n              entry.getInodeId());\n          it.remove();\n          continue;\n        }\n        FileEncryptionInfo newFei \u003d new FileEncryptionInfo(fei.getCipherSuite(),\n            fei.getCryptoProtocolVersion(),\n            entry.edek.getEncryptedKeyVersion().getMaterial(),\n            entry.edek.getEncryptedKeyIv(), fei.getKeyName(),\n            entry.edek.getEncryptionKeyVersionName());\n        final INodesInPath iip \u003d INodesInPath.fromINode(inode);\n        FSDirEncryptionZoneOp\n            .setFileEncryptionInfo(dir, iip, newFei, XAttrSetFlag.REPLACE);\n        task.lastFile \u003d iip.getPath();\n        ++task.numFilesUpdated;\n      }\n\n      LOG.info(\"Updated xattrs on {}({}) files in zone {} for re-encryption,\"\n              + \" starting:{}.\", task.numFilesUpdated, batchSize,\n          zoneNodePath, task.batch.getFirstFilePath());\n    }\n    task.processed \u003d true;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ReencryptionUpdater.java",
      "extendedDetails": {}
    },
    "1000a2af04b24c123a3b08168f36b4e90420cab7": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-10899. Add functionality to re-encrypt EDEKs.\n",
      "commitDate": "23/08/17 5:06 PM",
      "commitName": "1000a2af04b24c123a3b08168f36b4e90420cab7",
      "commitAuthor": "Xiao Chen",
      "diff": "@@ -0,0 +1,65 @@\n+  private void processTaskEntries(final String zoneNodePath,\n+      final ReencryptionTask task) throws IOException, InterruptedException {\n+    assert dir.hasWriteLock();\n+    if (!task.batch.isEmpty() \u0026\u0026 task.numFailures \u003d\u003d 0) {\n+      LOG.debug(\n+          \"Updating file xattrs for re-encrypting zone {},\" + \" starting at {}\",\n+          zoneNodePath, task.batch.getFirstFilePath());\n+      for (Iterator\u003cFileEdekInfo\u003e it \u003d task.batch.getBatch().iterator();\n+           it.hasNext();) {\n+        FileEdekInfo entry \u003d it.next();\n+        // resolve the inode again, and skip if it\u0027s doesn\u0027t exist\n+        LOG.trace(\"Updating {} for re-encryption.\", entry.getInodeId());\n+        final INode inode \u003d dir.getInode(entry.getInodeId());\n+        if (inode \u003d\u003d null) {\n+          LOG.debug(\"INode {} doesn\u0027t exist, skipping re-encrypt.\",\n+              entry.getInodeId());\n+          // also remove from batch so later it\u0027s not saved.\n+          it.remove();\n+          continue;\n+        }\n+\n+        // Cautiously check file encryption info, and only update if we\u0027re sure\n+        // it\u0027s still using the same edek.\n+        Preconditions.checkNotNull(entry.edek);\n+        final FileEncryptionInfo fei \u003d FSDirEncryptionZoneOp\n+            .getFileEncryptionInfo(dir, INodesInPath.fromINode(inode));\n+        if (!fei.getKeyName().equals(entry.edek.getEncryptionKeyName())) {\n+          LOG.debug(\"Inode {} EZ key changed, skipping re-encryption.\",\n+              entry.getInodeId());\n+          it.remove();\n+          continue;\n+        }\n+        if (fei.getEzKeyVersionName()\n+            .equals(entry.edek.getEncryptionKeyVersionName())) {\n+          LOG.debug(\n+              \"Inode {} EZ key version unchanged, skipping re-encryption.\",\n+              entry.getInodeId());\n+          it.remove();\n+          continue;\n+        }\n+        if (!Arrays.equals(fei.getEncryptedDataEncryptionKey(),\n+            entry.existingEdek.getEncryptedKeyVersion().getMaterial())) {\n+          LOG.debug(\"Inode {} existing edek changed, skipping re-encryption\",\n+              entry.getInodeId());\n+          it.remove();\n+          continue;\n+        }\n+        FileEncryptionInfo newFei \u003d new FileEncryptionInfo(fei.getCipherSuite(),\n+            fei.getCryptoProtocolVersion(),\n+            entry.edek.getEncryptedKeyVersion().getMaterial(),\n+            entry.edek.getEncryptedKeyIv(), fei.getKeyName(),\n+            entry.edek.getEncryptionKeyVersionName());\n+        final INodesInPath iip \u003d INodesInPath.fromINode(inode);\n+        FSDirEncryptionZoneOp\n+            .setFileEncryptionInfo(dir, iip, newFei, XAttrSetFlag.REPLACE);\n+        task.lastFile \u003d iip.getPath();\n+        ++task.numFilesUpdated;\n+      }\n+\n+      LOG.info(\"Updated xattrs on {}({}) files in zone {} for re-encryption,\"\n+              + \" starting:{}.\", task.numFilesUpdated, task.batch.size(),\n+          zoneNodePath, task.batch.getFirstFilePath());\n+    }\n+    task.processed \u003d true;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void processTaskEntries(final String zoneNodePath,\n      final ReencryptionTask task) throws IOException, InterruptedException {\n    assert dir.hasWriteLock();\n    if (!task.batch.isEmpty() \u0026\u0026 task.numFailures \u003d\u003d 0) {\n      LOG.debug(\n          \"Updating file xattrs for re-encrypting zone {},\" + \" starting at {}\",\n          zoneNodePath, task.batch.getFirstFilePath());\n      for (Iterator\u003cFileEdekInfo\u003e it \u003d task.batch.getBatch().iterator();\n           it.hasNext();) {\n        FileEdekInfo entry \u003d it.next();\n        // resolve the inode again, and skip if it\u0027s doesn\u0027t exist\n        LOG.trace(\"Updating {} for re-encryption.\", entry.getInodeId());\n        final INode inode \u003d dir.getInode(entry.getInodeId());\n        if (inode \u003d\u003d null) {\n          LOG.debug(\"INode {} doesn\u0027t exist, skipping re-encrypt.\",\n              entry.getInodeId());\n          // also remove from batch so later it\u0027s not saved.\n          it.remove();\n          continue;\n        }\n\n        // Cautiously check file encryption info, and only update if we\u0027re sure\n        // it\u0027s still using the same edek.\n        Preconditions.checkNotNull(entry.edek);\n        final FileEncryptionInfo fei \u003d FSDirEncryptionZoneOp\n            .getFileEncryptionInfo(dir, INodesInPath.fromINode(inode));\n        if (!fei.getKeyName().equals(entry.edek.getEncryptionKeyName())) {\n          LOG.debug(\"Inode {} EZ key changed, skipping re-encryption.\",\n              entry.getInodeId());\n          it.remove();\n          continue;\n        }\n        if (fei.getEzKeyVersionName()\n            .equals(entry.edek.getEncryptionKeyVersionName())) {\n          LOG.debug(\n              \"Inode {} EZ key version unchanged, skipping re-encryption.\",\n              entry.getInodeId());\n          it.remove();\n          continue;\n        }\n        if (!Arrays.equals(fei.getEncryptedDataEncryptionKey(),\n            entry.existingEdek.getEncryptedKeyVersion().getMaterial())) {\n          LOG.debug(\"Inode {} existing edek changed, skipping re-encryption\",\n              entry.getInodeId());\n          it.remove();\n          continue;\n        }\n        FileEncryptionInfo newFei \u003d new FileEncryptionInfo(fei.getCipherSuite(),\n            fei.getCryptoProtocolVersion(),\n            entry.edek.getEncryptedKeyVersion().getMaterial(),\n            entry.edek.getEncryptedKeyIv(), fei.getKeyName(),\n            entry.edek.getEncryptionKeyVersionName());\n        final INodesInPath iip \u003d INodesInPath.fromINode(inode);\n        FSDirEncryptionZoneOp\n            .setFileEncryptionInfo(dir, iip, newFei, XAttrSetFlag.REPLACE);\n        task.lastFile \u003d iip.getPath();\n        ++task.numFilesUpdated;\n      }\n\n      LOG.info(\"Updated xattrs on {}({}) files in zone {} for re-encryption,\"\n              + \" starting:{}.\", task.numFilesUpdated, task.batch.size(),\n          zoneNodePath, task.batch.getFirstFilePath());\n    }\n    task.processed \u003d true;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ReencryptionUpdater.java"
    }
  }
}