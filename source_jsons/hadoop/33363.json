{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ContainersMonitorImpl.java",
  "functionName": "checkLimit",
  "functionId": "checkLimit___containerId-ContainerId__pId-String__pTree-ResourceCalculatorProcessTree__ptInfo-ProcessTreeInfo__currentVmemUsage-long__currentPmemUsage-long",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/monitor/ContainersMonitorImpl.java",
  "functionStartLine": 691,
  "functionEndLine": 767,
  "numCommitsSeen": 66,
  "timeTaken": 3501,
  "changeHistory": [
    "221089760910743eae58eb2cbd5ac86c4ee96a17",
    "f76e3c3db789dd6866fa0fef8e014cbfe8c8f80d",
    "62d83ca5360cf803ecf6780caf192462d0092009",
    "d9964799544eefcf424fcc178d987525f5356cdf",
    "b82049b4f0065b76c3eb590d57eb5bf0ebc2f204",
    "9449519a2503c55d9eac8fd7519df28aa0760059"
  ],
  "changeHistoryShort": {
    "221089760910743eae58eb2cbd5ac86c4ee96a17": "Ybodychange",
    "f76e3c3db789dd6866fa0fef8e014cbfe8c8f80d": "Ybodychange",
    "62d83ca5360cf803ecf6780caf192462d0092009": "Ybodychange",
    "d9964799544eefcf424fcc178d987525f5356cdf": "Ybodychange",
    "b82049b4f0065b76c3eb590d57eb5bf0ebc2f204": "Ybodychange",
    "9449519a2503c55d9eac8fd7519df28aa0760059": "Yintroduced"
  },
  "changeHistoryDetails": {
    "221089760910743eae58eb2cbd5ac86c4ee96a17": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9592. Use Logger format in ContainersMonitorImpl. Contributed by Inigo Goiri.\n",
      "commitDate": "31/05/19 5:35 PM",
      "commitName": "221089760910743eae58eb2cbd5ac86c4ee96a17",
      "commitAuthor": "Giovanni Matteo Fumarola",
      "commitDateOld": "15/03/19 4:20 PM",
      "commitNameOld": "2064ca015d1584263aac0cc20c60b925a3aff612",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 77.05,
      "commitsBetweenForRepo": 469,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,77 +1,77 @@\n     private void checkLimit(ContainerId containerId, String pId,\n                             ResourceCalculatorProcessTree pTree,\n                             ProcessTreeInfo ptInfo,\n                             long currentVmemUsage,\n                             long currentPmemUsage) {\n       if (strictMemoryEnforcement \u0026\u0026 !elasticMemoryEnforcement) {\n         // When cgroup-based strict memory enforcement is used alone without\n         // elastic memory control, the oom-kill would take care of it.\n         // However, when elastic memory control is also enabled, the oom killer\n         // would be disabled at the root yarn container cgroup level (all child\n         // cgroups would inherit that setting). Hence, we fall back to the\n         // polling-based mechanism.\n         return;\n       }\n       boolean isMemoryOverLimit \u003d false;\n       String msg \u003d \"\";\n       int containerExitStatus \u003d ContainerExitStatus.INVALID;\n \n       long vmemLimit \u003d ptInfo.getVmemLimit();\n       long pmemLimit \u003d ptInfo.getPmemLimit();\n       // as processes begin with an age 1, we want to see if there\n       // are processes more than 1 iteration old.\n       long curMemUsageOfAgedProcesses \u003d pTree.getVirtualMemorySize(1);\n       long curRssMemUsageOfAgedProcesses \u003d pTree.getRssMemorySize(1);\n       if (isVmemCheckEnabled()\n           \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n           currentVmemUsage, curMemUsageOfAgedProcesses, vmemLimit)) {\n         // The current usage (age\u003d0) is always higher than the aged usage. We\n         // do not show the aged size in the message, base the delta on the\n         // current usage\n         long delta \u003d currentVmemUsage - vmemLimit;\n         // Container (the root process) is still alive and overflowing\n         // memory.\n         // Dump the process-tree and then clean it up.\n         msg \u003d formatErrorMessage(\"virtual\",\n             formatUsageString(currentVmemUsage, vmemLimit,\n                 currentPmemUsage, pmemLimit),\n             pId, containerId, pTree, delta);\n         isMemoryOverLimit \u003d true;\n         containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_VMEM;\n       } else if (isPmemCheckEnabled()\n           \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n           currentPmemUsage, curRssMemUsageOfAgedProcesses,\n           pmemLimit)) {\n         // The current usage (age\u003d0) is always higher than the aged usage. We\n         // do not show the aged size in the message, base the delta on the\n         // current usage\n         long delta \u003d currentPmemUsage - pmemLimit;\n         // Container (the root process) is still alive and overflowing\n         // memory.\n         // Dump the process-tree and then clean it up.\n         msg \u003d formatErrorMessage(\"physical\",\n             formatUsageString(currentVmemUsage, vmemLimit,\n                 currentPmemUsage, pmemLimit),\n             pId, containerId, pTree, delta);\n         isMemoryOverLimit \u003d true;\n         containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_PMEM;\n       }\n \n       if (isMemoryOverLimit) {\n         // Virtual or physical memory over limit. Fail the container and\n         // remove\n         // the corresponding process tree\n         LOG.warn(msg);\n         // warn if not a leader\n         if (!pTree.checkPidPgrpidForMatch()) {\n-          LOG.error(\"Killed container process with PID \" + pId\n-                  + \" but it is not a process group leader.\");\n+          LOG.error(\"Killed container process with PID {} \"\n+              + \"but it is not a process group leader.\", pId);\n         }\n         // kill the container\n         eventDispatcher.getEventHandler().handle(\n                 new ContainerKillEvent(containerId,\n                       containerExitStatus, msg));\n         trackingContainers.remove(containerId);\n-        LOG.info(\"Removed ProcessTree with root \" + pId);\n+        LOG.info(\"Removed ProcessTree with root {}\", pId);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void checkLimit(ContainerId containerId, String pId,\n                            ResourceCalculatorProcessTree pTree,\n                            ProcessTreeInfo ptInfo,\n                            long currentVmemUsage,\n                            long currentPmemUsage) {\n      if (strictMemoryEnforcement \u0026\u0026 !elasticMemoryEnforcement) {\n        // When cgroup-based strict memory enforcement is used alone without\n        // elastic memory control, the oom-kill would take care of it.\n        // However, when elastic memory control is also enabled, the oom killer\n        // would be disabled at the root yarn container cgroup level (all child\n        // cgroups would inherit that setting). Hence, we fall back to the\n        // polling-based mechanism.\n        return;\n      }\n      boolean isMemoryOverLimit \u003d false;\n      String msg \u003d \"\";\n      int containerExitStatus \u003d ContainerExitStatus.INVALID;\n\n      long vmemLimit \u003d ptInfo.getVmemLimit();\n      long pmemLimit \u003d ptInfo.getPmemLimit();\n      // as processes begin with an age 1, we want to see if there\n      // are processes more than 1 iteration old.\n      long curMemUsageOfAgedProcesses \u003d pTree.getVirtualMemorySize(1);\n      long curRssMemUsageOfAgedProcesses \u003d pTree.getRssMemorySize(1);\n      if (isVmemCheckEnabled()\n          \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n          currentVmemUsage, curMemUsageOfAgedProcesses, vmemLimit)) {\n        // The current usage (age\u003d0) is always higher than the aged usage. We\n        // do not show the aged size in the message, base the delta on the\n        // current usage\n        long delta \u003d currentVmemUsage - vmemLimit;\n        // Container (the root process) is still alive and overflowing\n        // memory.\n        // Dump the process-tree and then clean it up.\n        msg \u003d formatErrorMessage(\"virtual\",\n            formatUsageString(currentVmemUsage, vmemLimit,\n                currentPmemUsage, pmemLimit),\n            pId, containerId, pTree, delta);\n        isMemoryOverLimit \u003d true;\n        containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_VMEM;\n      } else if (isPmemCheckEnabled()\n          \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n          currentPmemUsage, curRssMemUsageOfAgedProcesses,\n          pmemLimit)) {\n        // The current usage (age\u003d0) is always higher than the aged usage. We\n        // do not show the aged size in the message, base the delta on the\n        // current usage\n        long delta \u003d currentPmemUsage - pmemLimit;\n        // Container (the root process) is still alive and overflowing\n        // memory.\n        // Dump the process-tree and then clean it up.\n        msg \u003d formatErrorMessage(\"physical\",\n            formatUsageString(currentVmemUsage, vmemLimit,\n                currentPmemUsage, pmemLimit),\n            pId, containerId, pTree, delta);\n        isMemoryOverLimit \u003d true;\n        containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_PMEM;\n      }\n\n      if (isMemoryOverLimit) {\n        // Virtual or physical memory over limit. Fail the container and\n        // remove\n        // the corresponding process tree\n        LOG.warn(msg);\n        // warn if not a leader\n        if (!pTree.checkPidPgrpidForMatch()) {\n          LOG.error(\"Killed container process with PID {} \"\n              + \"but it is not a process group leader.\", pId);\n        }\n        // kill the container\n        eventDispatcher.getEventHandler().handle(\n                new ContainerKillEvent(containerId,\n                      containerExitStatus, msg));\n        trackingContainers.remove(containerId);\n        LOG.info(\"Removed ProcessTree with root {}\", pId);\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/monitor/ContainersMonitorImpl.java",
      "extendedDetails": {}
    },
    "f76e3c3db789dd6866fa0fef8e014cbfe8c8f80d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8930. CGroup-based strict container memory enforcement does not work with CGroupElasticMemoryController (haibochen via rkanter)\n",
      "commitDate": "25/10/18 11:09 AM",
      "commitName": "f76e3c3db789dd6866fa0fef8e014cbfe8c8f80d",
      "commitAuthor": "Robert Kanter",
      "commitDateOld": "24/10/18 7:58 AM",
      "commitNameOld": "766b78ee074df29d5acd2ba2face5712dd20437f",
      "commitAuthorOld": "Haibo Chen",
      "daysBetweenCommits": 1.13,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,91 +1,77 @@\n     private void checkLimit(ContainerId containerId, String pId,\n                             ResourceCalculatorProcessTree pTree,\n                             ProcessTreeInfo ptInfo,\n                             long currentVmemUsage,\n                             long currentPmemUsage) {\n-      Optional\u003cBoolean\u003e isMemoryOverLimit \u003d Optional.empty();\n+      if (strictMemoryEnforcement \u0026\u0026 !elasticMemoryEnforcement) {\n+        // When cgroup-based strict memory enforcement is used alone without\n+        // elastic memory control, the oom-kill would take care of it.\n+        // However, when elastic memory control is also enabled, the oom killer\n+        // would be disabled at the root yarn container cgroup level (all child\n+        // cgroups would inherit that setting). Hence, we fall back to the\n+        // polling-based mechanism.\n+        return;\n+      }\n+      boolean isMemoryOverLimit \u003d false;\n       String msg \u003d \"\";\n       int containerExitStatus \u003d ContainerExitStatus.INVALID;\n \n-      if (strictMemoryEnforcement \u0026\u0026 elasticMemoryEnforcement) {\n-        // Both elastic memory control and strict memory control are enabled\n-        // through cgroups. A container will be frozen by the elastic memory\n-        // control mechanism if it exceeds its request, so we check for this\n-        // here and kill it. Otherwise, the container will not be killed if\n-        // the node never exceeds its limit and the procfs-based\n-        // memory accounting is different from the cgroup-based accounting.\n-\n-        MemoryResourceHandler handler \u003d\n-            ResourceHandlerModule.getMemoryResourceHandler();\n-        if (handler !\u003d null) {\n-          isMemoryOverLimit \u003d handler.isUnderOOM(containerId);\n-          containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_PMEM;\n-          msg \u003d containerId + \" is under oom because it exceeded its\" +\n-              \" physical memory limit\";\n-        }\n-      } else if (strictMemoryEnforcement || elasticMemoryEnforcement) {\n-        // if cgroup-based memory control is enabled\n-        isMemoryOverLimit \u003d Optional.of(false);\n+      long vmemLimit \u003d ptInfo.getVmemLimit();\n+      long pmemLimit \u003d ptInfo.getPmemLimit();\n+      // as processes begin with an age 1, we want to see if there\n+      // are processes more than 1 iteration old.\n+      long curMemUsageOfAgedProcesses \u003d pTree.getVirtualMemorySize(1);\n+      long curRssMemUsageOfAgedProcesses \u003d pTree.getRssMemorySize(1);\n+      if (isVmemCheckEnabled()\n+          \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n+          currentVmemUsage, curMemUsageOfAgedProcesses, vmemLimit)) {\n+        // The current usage (age\u003d0) is always higher than the aged usage. We\n+        // do not show the aged size in the message, base the delta on the\n+        // current usage\n+        long delta \u003d currentVmemUsage - vmemLimit;\n+        // Container (the root process) is still alive and overflowing\n+        // memory.\n+        // Dump the process-tree and then clean it up.\n+        msg \u003d formatErrorMessage(\"virtual\",\n+            formatUsageString(currentVmemUsage, vmemLimit,\n+                currentPmemUsage, pmemLimit),\n+            pId, containerId, pTree, delta);\n+        isMemoryOverLimit \u003d true;\n+        containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_VMEM;\n+      } else if (isPmemCheckEnabled()\n+          \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n+          currentPmemUsage, curRssMemUsageOfAgedProcesses,\n+          pmemLimit)) {\n+        // The current usage (age\u003d0) is always higher than the aged usage. We\n+        // do not show the aged size in the message, base the delta on the\n+        // current usage\n+        long delta \u003d currentPmemUsage - pmemLimit;\n+        // Container (the root process) is still alive and overflowing\n+        // memory.\n+        // Dump the process-tree and then clean it up.\n+        msg \u003d formatErrorMessage(\"physical\",\n+            formatUsageString(currentVmemUsage, vmemLimit,\n+                currentPmemUsage, pmemLimit),\n+            pId, containerId, pTree, delta);\n+        isMemoryOverLimit \u003d true;\n+        containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_PMEM;\n       }\n \n-      if (!isMemoryOverLimit.isPresent()) {\n-        long vmemLimit \u003d ptInfo.getVmemLimit();\n-        long pmemLimit \u003d ptInfo.getPmemLimit();\n-        // as processes begin with an age 1, we want to see if there\n-        // are processes more than 1 iteration old.\n-        long curMemUsageOfAgedProcesses \u003d pTree.getVirtualMemorySize(1);\n-        long curRssMemUsageOfAgedProcesses \u003d pTree.getRssMemorySize(1);\n-        if (isVmemCheckEnabled()\n-            \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n-            currentVmemUsage, curMemUsageOfAgedProcesses, vmemLimit)) {\n-          // The current usage (age\u003d0) is always higher than the aged usage. We\n-          // do not show the aged size in the message, base the delta on the\n-          // current usage\n-          long delta \u003d currentVmemUsage - vmemLimit;\n-          // Container (the root process) is still alive and overflowing\n-          // memory.\n-          // Dump the process-tree and then clean it up.\n-          msg \u003d formatErrorMessage(\"virtual\",\n-              formatUsageString(currentVmemUsage, vmemLimit,\n-                  currentPmemUsage, pmemLimit),\n-              pId, containerId, pTree, delta);\n-          isMemoryOverLimit \u003d Optional.of(true);\n-          containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_VMEM;\n-        } else if (isPmemCheckEnabled()\n-            \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n-            currentPmemUsage, curRssMemUsageOfAgedProcesses,\n-            pmemLimit)) {\n-          // The current usage (age\u003d0) is always higher than the aged usage. We\n-          // do not show the aged size in the message, base the delta on the\n-          // current usage\n-          long delta \u003d currentPmemUsage - pmemLimit;\n-          // Container (the root process) is still alive and overflowing\n-          // memory.\n-          // Dump the process-tree and then clean it up.\n-          msg \u003d formatErrorMessage(\"physical\",\n-              formatUsageString(currentVmemUsage, vmemLimit,\n-                  currentPmemUsage, pmemLimit),\n-              pId, containerId, pTree, delta);\n-          isMemoryOverLimit \u003d Optional.of(true);\n-          containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_PMEM;\n-        }\n-      }\n-\n-      if (isMemoryOverLimit.isPresent() \u0026\u0026 isMemoryOverLimit.get()) {\n+      if (isMemoryOverLimit) {\n         // Virtual or physical memory over limit. Fail the container and\n         // remove\n         // the corresponding process tree\n         LOG.warn(msg);\n         // warn if not a leader\n         if (!pTree.checkPidPgrpidForMatch()) {\n           LOG.error(\"Killed container process with PID \" + pId\n                   + \" but it is not a process group leader.\");\n         }\n         // kill the container\n         eventDispatcher.getEventHandler().handle(\n                 new ContainerKillEvent(containerId,\n                       containerExitStatus, msg));\n         trackingContainers.remove(containerId);\n         LOG.info(\"Removed ProcessTree with root \" + pId);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void checkLimit(ContainerId containerId, String pId,\n                            ResourceCalculatorProcessTree pTree,\n                            ProcessTreeInfo ptInfo,\n                            long currentVmemUsage,\n                            long currentPmemUsage) {\n      if (strictMemoryEnforcement \u0026\u0026 !elasticMemoryEnforcement) {\n        // When cgroup-based strict memory enforcement is used alone without\n        // elastic memory control, the oom-kill would take care of it.\n        // However, when elastic memory control is also enabled, the oom killer\n        // would be disabled at the root yarn container cgroup level (all child\n        // cgroups would inherit that setting). Hence, we fall back to the\n        // polling-based mechanism.\n        return;\n      }\n      boolean isMemoryOverLimit \u003d false;\n      String msg \u003d \"\";\n      int containerExitStatus \u003d ContainerExitStatus.INVALID;\n\n      long vmemLimit \u003d ptInfo.getVmemLimit();\n      long pmemLimit \u003d ptInfo.getPmemLimit();\n      // as processes begin with an age 1, we want to see if there\n      // are processes more than 1 iteration old.\n      long curMemUsageOfAgedProcesses \u003d pTree.getVirtualMemorySize(1);\n      long curRssMemUsageOfAgedProcesses \u003d pTree.getRssMemorySize(1);\n      if (isVmemCheckEnabled()\n          \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n          currentVmemUsage, curMemUsageOfAgedProcesses, vmemLimit)) {\n        // The current usage (age\u003d0) is always higher than the aged usage. We\n        // do not show the aged size in the message, base the delta on the\n        // current usage\n        long delta \u003d currentVmemUsage - vmemLimit;\n        // Container (the root process) is still alive and overflowing\n        // memory.\n        // Dump the process-tree and then clean it up.\n        msg \u003d formatErrorMessage(\"virtual\",\n            formatUsageString(currentVmemUsage, vmemLimit,\n                currentPmemUsage, pmemLimit),\n            pId, containerId, pTree, delta);\n        isMemoryOverLimit \u003d true;\n        containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_VMEM;\n      } else if (isPmemCheckEnabled()\n          \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n          currentPmemUsage, curRssMemUsageOfAgedProcesses,\n          pmemLimit)) {\n        // The current usage (age\u003d0) is always higher than the aged usage. We\n        // do not show the aged size in the message, base the delta on the\n        // current usage\n        long delta \u003d currentPmemUsage - pmemLimit;\n        // Container (the root process) is still alive and overflowing\n        // memory.\n        // Dump the process-tree and then clean it up.\n        msg \u003d formatErrorMessage(\"physical\",\n            formatUsageString(currentVmemUsage, vmemLimit,\n                currentPmemUsage, pmemLimit),\n            pId, containerId, pTree, delta);\n        isMemoryOverLimit \u003d true;\n        containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_PMEM;\n      }\n\n      if (isMemoryOverLimit) {\n        // Virtual or physical memory over limit. Fail the container and\n        // remove\n        // the corresponding process tree\n        LOG.warn(msg);\n        // warn if not a leader\n        if (!pTree.checkPidPgrpidForMatch()) {\n          LOG.error(\"Killed container process with PID \" + pId\n                  + \" but it is not a process group leader.\");\n        }\n        // kill the container\n        eventDispatcher.getEventHandler().handle(\n                new ContainerKillEvent(containerId,\n                      containerExitStatus, msg));\n        trackingContainers.remove(containerId);\n        LOG.info(\"Removed ProcessTree with root \" + pId);\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/monitor/ContainersMonitorImpl.java",
      "extendedDetails": {}
    },
    "62d83ca5360cf803ecf6780caf192462d0092009": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8461. Support strict memory control on individual container with elastic control memory mechanism. Contributed by Haibo Chen.\n",
      "commitDate": "26/06/18 3:21 PM",
      "commitName": "62d83ca5360cf803ecf6780caf192462d0092009",
      "commitAuthor": "Miklos Szegedi",
      "commitDateOld": "23/05/18 4:35 PM",
      "commitNameOld": "d9964799544eefcf424fcc178d987525f5356cdf",
      "commitAuthorOld": "Haibo Chen",
      "daysBetweenCommits": 33.95,
      "commitsBetweenForRepo": 224,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,71 +1,91 @@\n     private void checkLimit(ContainerId containerId, String pId,\n                             ResourceCalculatorProcessTree pTree,\n                             ProcessTreeInfo ptInfo,\n                             long currentVmemUsage,\n                             long currentPmemUsage) {\n-      if (elasticMemoryEnforcement || strictMemoryEnforcement) {\n-        // We enforce the overall memory usage instead of individual containers\n-        return;\n-      }\n-      boolean isMemoryOverLimit \u003d false;\n-      long vmemLimit \u003d ptInfo.getVmemLimit();\n-      long pmemLimit \u003d ptInfo.getPmemLimit();\n-      // as processes begin with an age 1, we want to see if there\n-      // are processes more than 1 iteration old.\n-      long curMemUsageOfAgedProcesses \u003d pTree.getVirtualMemorySize(1);\n-      long curRssMemUsageOfAgedProcesses \u003d pTree.getRssMemorySize(1);\n+      Optional\u003cBoolean\u003e isMemoryOverLimit \u003d Optional.empty();\n       String msg \u003d \"\";\n       int containerExitStatus \u003d ContainerExitStatus.INVALID;\n-      if (isVmemCheckEnabled()\n-              \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n-              currentVmemUsage, curMemUsageOfAgedProcesses, vmemLimit)) {\n-        // The current usage (age\u003d0) is always higher than the aged usage. We\n-        // do not show the aged size in the message, base the delta on the\n-        // current usage\n-        long delta \u003d currentVmemUsage - vmemLimit;\n-        // Container (the root process) is still alive and overflowing\n-        // memory.\n-        // Dump the process-tree and then clean it up.\n-        msg \u003d formatErrorMessage(\"virtual\",\n-                formatUsageString(currentVmemUsage, vmemLimit,\n-                  currentPmemUsage, pmemLimit),\n-                pId, containerId, pTree, delta);\n-        isMemoryOverLimit \u003d true;\n-        containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_VMEM;\n-      } else if (isPmemCheckEnabled()\n-              \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n-              currentPmemUsage, curRssMemUsageOfAgedProcesses,\n-              pmemLimit)) {\n-        // The current usage (age\u003d0) is always higher than the aged usage. We\n-        // do not show the aged size in the message, base the delta on the\n-        // current usage\n-        long delta \u003d currentPmemUsage - pmemLimit;\n-        // Container (the root process) is still alive and overflowing\n-        // memory.\n-        // Dump the process-tree and then clean it up.\n-        msg \u003d formatErrorMessage(\"physical\",\n-                formatUsageString(currentVmemUsage, vmemLimit,\n-                  currentPmemUsage, pmemLimit),\n-                pId, containerId, pTree, delta);\n-        isMemoryOverLimit \u003d true;\n-        containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_PMEM;\n+\n+      if (strictMemoryEnforcement \u0026\u0026 elasticMemoryEnforcement) {\n+        // Both elastic memory control and strict memory control are enabled\n+        // through cgroups. A container will be frozen by the elastic memory\n+        // control mechanism if it exceeds its request, so we check for this\n+        // here and kill it. Otherwise, the container will not be killed if\n+        // the node never exceeds its limit and the procfs-based\n+        // memory accounting is different from the cgroup-based accounting.\n+\n+        MemoryResourceHandler handler \u003d\n+            ResourceHandlerModule.getMemoryResourceHandler();\n+        if (handler !\u003d null) {\n+          isMemoryOverLimit \u003d handler.isUnderOOM(containerId);\n+          containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_PMEM;\n+          msg \u003d containerId + \" is under oom because it exceeded its\" +\n+              \" physical memory limit\";\n+        }\n+      } else if (strictMemoryEnforcement || elasticMemoryEnforcement) {\n+        // if cgroup-based memory control is enabled\n+        isMemoryOverLimit \u003d Optional.of(false);\n       }\n \n-      if (isMemoryOverLimit) {\n+      if (!isMemoryOverLimit.isPresent()) {\n+        long vmemLimit \u003d ptInfo.getVmemLimit();\n+        long pmemLimit \u003d ptInfo.getPmemLimit();\n+        // as processes begin with an age 1, we want to see if there\n+        // are processes more than 1 iteration old.\n+        long curMemUsageOfAgedProcesses \u003d pTree.getVirtualMemorySize(1);\n+        long curRssMemUsageOfAgedProcesses \u003d pTree.getRssMemorySize(1);\n+        if (isVmemCheckEnabled()\n+            \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n+            currentVmemUsage, curMemUsageOfAgedProcesses, vmemLimit)) {\n+          // The current usage (age\u003d0) is always higher than the aged usage. We\n+          // do not show the aged size in the message, base the delta on the\n+          // current usage\n+          long delta \u003d currentVmemUsage - vmemLimit;\n+          // Container (the root process) is still alive and overflowing\n+          // memory.\n+          // Dump the process-tree and then clean it up.\n+          msg \u003d formatErrorMessage(\"virtual\",\n+              formatUsageString(currentVmemUsage, vmemLimit,\n+                  currentPmemUsage, pmemLimit),\n+              pId, containerId, pTree, delta);\n+          isMemoryOverLimit \u003d Optional.of(true);\n+          containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_VMEM;\n+        } else if (isPmemCheckEnabled()\n+            \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n+            currentPmemUsage, curRssMemUsageOfAgedProcesses,\n+            pmemLimit)) {\n+          // The current usage (age\u003d0) is always higher than the aged usage. We\n+          // do not show the aged size in the message, base the delta on the\n+          // current usage\n+          long delta \u003d currentPmemUsage - pmemLimit;\n+          // Container (the root process) is still alive and overflowing\n+          // memory.\n+          // Dump the process-tree and then clean it up.\n+          msg \u003d formatErrorMessage(\"physical\",\n+              formatUsageString(currentVmemUsage, vmemLimit,\n+                  currentPmemUsage, pmemLimit),\n+              pId, containerId, pTree, delta);\n+          isMemoryOverLimit \u003d Optional.of(true);\n+          containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_PMEM;\n+        }\n+      }\n+\n+      if (isMemoryOverLimit.isPresent() \u0026\u0026 isMemoryOverLimit.get()) {\n         // Virtual or physical memory over limit. Fail the container and\n         // remove\n         // the corresponding process tree\n         LOG.warn(msg);\n         // warn if not a leader\n         if (!pTree.checkPidPgrpidForMatch()) {\n           LOG.error(\"Killed container process with PID \" + pId\n                   + \" but it is not a process group leader.\");\n         }\n         // kill the container\n         eventDispatcher.getEventHandler().handle(\n                 new ContainerKillEvent(containerId,\n                       containerExitStatus, msg));\n         trackingContainers.remove(containerId);\n         LOG.info(\"Removed ProcessTree with root \" + pId);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void checkLimit(ContainerId containerId, String pId,\n                            ResourceCalculatorProcessTree pTree,\n                            ProcessTreeInfo ptInfo,\n                            long currentVmemUsage,\n                            long currentPmemUsage) {\n      Optional\u003cBoolean\u003e isMemoryOverLimit \u003d Optional.empty();\n      String msg \u003d \"\";\n      int containerExitStatus \u003d ContainerExitStatus.INVALID;\n\n      if (strictMemoryEnforcement \u0026\u0026 elasticMemoryEnforcement) {\n        // Both elastic memory control and strict memory control are enabled\n        // through cgroups. A container will be frozen by the elastic memory\n        // control mechanism if it exceeds its request, so we check for this\n        // here and kill it. Otherwise, the container will not be killed if\n        // the node never exceeds its limit and the procfs-based\n        // memory accounting is different from the cgroup-based accounting.\n\n        MemoryResourceHandler handler \u003d\n            ResourceHandlerModule.getMemoryResourceHandler();\n        if (handler !\u003d null) {\n          isMemoryOverLimit \u003d handler.isUnderOOM(containerId);\n          containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_PMEM;\n          msg \u003d containerId + \" is under oom because it exceeded its\" +\n              \" physical memory limit\";\n        }\n      } else if (strictMemoryEnforcement || elasticMemoryEnforcement) {\n        // if cgroup-based memory control is enabled\n        isMemoryOverLimit \u003d Optional.of(false);\n      }\n\n      if (!isMemoryOverLimit.isPresent()) {\n        long vmemLimit \u003d ptInfo.getVmemLimit();\n        long pmemLimit \u003d ptInfo.getPmemLimit();\n        // as processes begin with an age 1, we want to see if there\n        // are processes more than 1 iteration old.\n        long curMemUsageOfAgedProcesses \u003d pTree.getVirtualMemorySize(1);\n        long curRssMemUsageOfAgedProcesses \u003d pTree.getRssMemorySize(1);\n        if (isVmemCheckEnabled()\n            \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n            currentVmemUsage, curMemUsageOfAgedProcesses, vmemLimit)) {\n          // The current usage (age\u003d0) is always higher than the aged usage. We\n          // do not show the aged size in the message, base the delta on the\n          // current usage\n          long delta \u003d currentVmemUsage - vmemLimit;\n          // Container (the root process) is still alive and overflowing\n          // memory.\n          // Dump the process-tree and then clean it up.\n          msg \u003d formatErrorMessage(\"virtual\",\n              formatUsageString(currentVmemUsage, vmemLimit,\n                  currentPmemUsage, pmemLimit),\n              pId, containerId, pTree, delta);\n          isMemoryOverLimit \u003d Optional.of(true);\n          containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_VMEM;\n        } else if (isPmemCheckEnabled()\n            \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n            currentPmemUsage, curRssMemUsageOfAgedProcesses,\n            pmemLimit)) {\n          // The current usage (age\u003d0) is always higher than the aged usage. We\n          // do not show the aged size in the message, base the delta on the\n          // current usage\n          long delta \u003d currentPmemUsage - pmemLimit;\n          // Container (the root process) is still alive and overflowing\n          // memory.\n          // Dump the process-tree and then clean it up.\n          msg \u003d formatErrorMessage(\"physical\",\n              formatUsageString(currentVmemUsage, vmemLimit,\n                  currentPmemUsage, pmemLimit),\n              pId, containerId, pTree, delta);\n          isMemoryOverLimit \u003d Optional.of(true);\n          containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_PMEM;\n        }\n      }\n\n      if (isMemoryOverLimit.isPresent() \u0026\u0026 isMemoryOverLimit.get()) {\n        // Virtual or physical memory over limit. Fail the container and\n        // remove\n        // the corresponding process tree\n        LOG.warn(msg);\n        // warn if not a leader\n        if (!pTree.checkPidPgrpidForMatch()) {\n          LOG.error(\"Killed container process with PID \" + pId\n                  + \" but it is not a process group leader.\");\n        }\n        // kill the container\n        eventDispatcher.getEventHandler().handle(\n                new ContainerKillEvent(containerId,\n                      containerExitStatus, msg));\n        trackingContainers.remove(containerId);\n        LOG.info(\"Removed ProcessTree with root \" + pId);\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/monitor/ContainersMonitorImpl.java",
      "extendedDetails": {}
    },
    "d9964799544eefcf424fcc178d987525f5356cdf": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4599. Set OOM control for memory cgroups. (Miklos Szegedi via Haibo Chen)\n",
      "commitDate": "23/05/18 4:35 PM",
      "commitName": "d9964799544eefcf424fcc178d987525f5356cdf",
      "commitAuthor": "Haibo Chen",
      "commitDateOld": "28/03/18 9:05 AM",
      "commitNameOld": "cdee0a4f840868d8b8acac15e62da2ab337618c7",
      "commitAuthorOld": "Miklos Szegedi",
      "daysBetweenCommits": 56.31,
      "commitsBetweenForRepo": 913,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,67 +1,71 @@\n     private void checkLimit(ContainerId containerId, String pId,\n                             ResourceCalculatorProcessTree pTree,\n                             ProcessTreeInfo ptInfo,\n                             long currentVmemUsage,\n                             long currentPmemUsage) {\n+      if (elasticMemoryEnforcement || strictMemoryEnforcement) {\n+        // We enforce the overall memory usage instead of individual containers\n+        return;\n+      }\n       boolean isMemoryOverLimit \u003d false;\n       long vmemLimit \u003d ptInfo.getVmemLimit();\n       long pmemLimit \u003d ptInfo.getPmemLimit();\n       // as processes begin with an age 1, we want to see if there\n       // are processes more than 1 iteration old.\n       long curMemUsageOfAgedProcesses \u003d pTree.getVirtualMemorySize(1);\n       long curRssMemUsageOfAgedProcesses \u003d pTree.getRssMemorySize(1);\n       String msg \u003d \"\";\n       int containerExitStatus \u003d ContainerExitStatus.INVALID;\n       if (isVmemCheckEnabled()\n               \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n               currentVmemUsage, curMemUsageOfAgedProcesses, vmemLimit)) {\n         // The current usage (age\u003d0) is always higher than the aged usage. We\n         // do not show the aged size in the message, base the delta on the\n         // current usage\n         long delta \u003d currentVmemUsage - vmemLimit;\n         // Container (the root process) is still alive and overflowing\n         // memory.\n         // Dump the process-tree and then clean it up.\n         msg \u003d formatErrorMessage(\"virtual\",\n                 formatUsageString(currentVmemUsage, vmemLimit,\n                   currentPmemUsage, pmemLimit),\n                 pId, containerId, pTree, delta);\n         isMemoryOverLimit \u003d true;\n         containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_VMEM;\n       } else if (isPmemCheckEnabled()\n               \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n               currentPmemUsage, curRssMemUsageOfAgedProcesses,\n               pmemLimit)) {\n         // The current usage (age\u003d0) is always higher than the aged usage. We\n         // do not show the aged size in the message, base the delta on the\n         // current usage\n         long delta \u003d currentPmemUsage - pmemLimit;\n         // Container (the root process) is still alive and overflowing\n         // memory.\n         // Dump the process-tree and then clean it up.\n         msg \u003d formatErrorMessage(\"physical\",\n                 formatUsageString(currentVmemUsage, vmemLimit,\n                   currentPmemUsage, pmemLimit),\n                 pId, containerId, pTree, delta);\n         isMemoryOverLimit \u003d true;\n         containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_PMEM;\n       }\n \n       if (isMemoryOverLimit) {\n         // Virtual or physical memory over limit. Fail the container and\n         // remove\n         // the corresponding process tree\n         LOG.warn(msg);\n         // warn if not a leader\n         if (!pTree.checkPidPgrpidForMatch()) {\n           LOG.error(\"Killed container process with PID \" + pId\n                   + \" but it is not a process group leader.\");\n         }\n         // kill the container\n         eventDispatcher.getEventHandler().handle(\n                 new ContainerKillEvent(containerId,\n                       containerExitStatus, msg));\n         trackingContainers.remove(containerId);\n         LOG.info(\"Removed ProcessTree with root \" + pId);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void checkLimit(ContainerId containerId, String pId,\n                            ResourceCalculatorProcessTree pTree,\n                            ProcessTreeInfo ptInfo,\n                            long currentVmemUsage,\n                            long currentPmemUsage) {\n      if (elasticMemoryEnforcement || strictMemoryEnforcement) {\n        // We enforce the overall memory usage instead of individual containers\n        return;\n      }\n      boolean isMemoryOverLimit \u003d false;\n      long vmemLimit \u003d ptInfo.getVmemLimit();\n      long pmemLimit \u003d ptInfo.getPmemLimit();\n      // as processes begin with an age 1, we want to see if there\n      // are processes more than 1 iteration old.\n      long curMemUsageOfAgedProcesses \u003d pTree.getVirtualMemorySize(1);\n      long curRssMemUsageOfAgedProcesses \u003d pTree.getRssMemorySize(1);\n      String msg \u003d \"\";\n      int containerExitStatus \u003d ContainerExitStatus.INVALID;\n      if (isVmemCheckEnabled()\n              \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n              currentVmemUsage, curMemUsageOfAgedProcesses, vmemLimit)) {\n        // The current usage (age\u003d0) is always higher than the aged usage. We\n        // do not show the aged size in the message, base the delta on the\n        // current usage\n        long delta \u003d currentVmemUsage - vmemLimit;\n        // Container (the root process) is still alive and overflowing\n        // memory.\n        // Dump the process-tree and then clean it up.\n        msg \u003d formatErrorMessage(\"virtual\",\n                formatUsageString(currentVmemUsage, vmemLimit,\n                  currentPmemUsage, pmemLimit),\n                pId, containerId, pTree, delta);\n        isMemoryOverLimit \u003d true;\n        containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_VMEM;\n      } else if (isPmemCheckEnabled()\n              \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n              currentPmemUsage, curRssMemUsageOfAgedProcesses,\n              pmemLimit)) {\n        // The current usage (age\u003d0) is always higher than the aged usage. We\n        // do not show the aged size in the message, base the delta on the\n        // current usage\n        long delta \u003d currentPmemUsage - pmemLimit;\n        // Container (the root process) is still alive and overflowing\n        // memory.\n        // Dump the process-tree and then clean it up.\n        msg \u003d formatErrorMessage(\"physical\",\n                formatUsageString(currentVmemUsage, vmemLimit,\n                  currentPmemUsage, pmemLimit),\n                pId, containerId, pTree, delta);\n        isMemoryOverLimit \u003d true;\n        containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_PMEM;\n      }\n\n      if (isMemoryOverLimit) {\n        // Virtual or physical memory over limit. Fail the container and\n        // remove\n        // the corresponding process tree\n        LOG.warn(msg);\n        // warn if not a leader\n        if (!pTree.checkPidPgrpidForMatch()) {\n          LOG.error(\"Killed container process with PID \" + pId\n                  + \" but it is not a process group leader.\");\n        }\n        // kill the container\n        eventDispatcher.getEventHandler().handle(\n                new ContainerKillEvent(containerId,\n                      containerExitStatus, msg));\n        trackingContainers.remove(containerId);\n        LOG.info(\"Removed ProcessTree with root \" + pId);\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/monitor/ContainersMonitorImpl.java",
      "extendedDetails": {}
    },
    "b82049b4f0065b76c3eb590d57eb5bf0ebc2f204": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7580. ContainersMonitorImpl logged message lacks detail when exceeding memory limits. Contributed by Wilfred Spiegelenburg.\n",
      "commitDate": "29/12/17 12:49 PM",
      "commitName": "b82049b4f0065b76c3eb590d57eb5bf0ebc2f204",
      "commitAuthor": "Miklos Szegedi",
      "commitDateOld": "12/12/17 10:56 AM",
      "commitNameOld": "06f0eb2dce2a7a098f7844682ea6c232d0ddb0be",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 17.08,
      "commitsBetweenForRepo": 105,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,59 +1,67 @@\n     private void checkLimit(ContainerId containerId, String pId,\n                             ResourceCalculatorProcessTree pTree,\n                             ProcessTreeInfo ptInfo,\n                             long currentVmemUsage,\n                             long currentPmemUsage) {\n       boolean isMemoryOverLimit \u003d false;\n       long vmemLimit \u003d ptInfo.getVmemLimit();\n       long pmemLimit \u003d ptInfo.getPmemLimit();\n       // as processes begin with an age 1, we want to see if there\n       // are processes more than 1 iteration old.\n       long curMemUsageOfAgedProcesses \u003d pTree.getVirtualMemorySize(1);\n       long curRssMemUsageOfAgedProcesses \u003d pTree.getRssMemorySize(1);\n       String msg \u003d \"\";\n       int containerExitStatus \u003d ContainerExitStatus.INVALID;\n       if (isVmemCheckEnabled()\n               \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n               currentVmemUsage, curMemUsageOfAgedProcesses, vmemLimit)) {\n+        // The current usage (age\u003d0) is always higher than the aged usage. We\n+        // do not show the aged size in the message, base the delta on the\n+        // current usage\n+        long delta \u003d currentVmemUsage - vmemLimit;\n         // Container (the root process) is still alive and overflowing\n         // memory.\n         // Dump the process-tree and then clean it up.\n         msg \u003d formatErrorMessage(\"virtual\",\n                 formatUsageString(currentVmemUsage, vmemLimit,\n                   currentPmemUsage, pmemLimit),\n-                pId, containerId, pTree);\n+                pId, containerId, pTree, delta);\n         isMemoryOverLimit \u003d true;\n         containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_VMEM;\n       } else if (isPmemCheckEnabled()\n               \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n               currentPmemUsage, curRssMemUsageOfAgedProcesses,\n               pmemLimit)) {\n+        // The current usage (age\u003d0) is always higher than the aged usage. We\n+        // do not show the aged size in the message, base the delta on the\n+        // current usage\n+        long delta \u003d currentPmemUsage - pmemLimit;\n         // Container (the root process) is still alive and overflowing\n         // memory.\n         // Dump the process-tree and then clean it up.\n         msg \u003d formatErrorMessage(\"physical\",\n                 formatUsageString(currentVmemUsage, vmemLimit,\n                   currentPmemUsage, pmemLimit),\n-                pId, containerId, pTree);\n+                pId, containerId, pTree, delta);\n         isMemoryOverLimit \u003d true;\n         containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_PMEM;\n       }\n \n       if (isMemoryOverLimit) {\n         // Virtual or physical memory over limit. Fail the container and\n         // remove\n         // the corresponding process tree\n         LOG.warn(msg);\n         // warn if not a leader\n         if (!pTree.checkPidPgrpidForMatch()) {\n           LOG.error(\"Killed container process with PID \" + pId\n                   + \" but it is not a process group leader.\");\n         }\n         // kill the container\n         eventDispatcher.getEventHandler().handle(\n                 new ContainerKillEvent(containerId,\n                       containerExitStatus, msg));\n         trackingContainers.remove(containerId);\n         LOG.info(\"Removed ProcessTree with root \" + pId);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void checkLimit(ContainerId containerId, String pId,\n                            ResourceCalculatorProcessTree pTree,\n                            ProcessTreeInfo ptInfo,\n                            long currentVmemUsage,\n                            long currentPmemUsage) {\n      boolean isMemoryOverLimit \u003d false;\n      long vmemLimit \u003d ptInfo.getVmemLimit();\n      long pmemLimit \u003d ptInfo.getPmemLimit();\n      // as processes begin with an age 1, we want to see if there\n      // are processes more than 1 iteration old.\n      long curMemUsageOfAgedProcesses \u003d pTree.getVirtualMemorySize(1);\n      long curRssMemUsageOfAgedProcesses \u003d pTree.getRssMemorySize(1);\n      String msg \u003d \"\";\n      int containerExitStatus \u003d ContainerExitStatus.INVALID;\n      if (isVmemCheckEnabled()\n              \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n              currentVmemUsage, curMemUsageOfAgedProcesses, vmemLimit)) {\n        // The current usage (age\u003d0) is always higher than the aged usage. We\n        // do not show the aged size in the message, base the delta on the\n        // current usage\n        long delta \u003d currentVmemUsage - vmemLimit;\n        // Container (the root process) is still alive and overflowing\n        // memory.\n        // Dump the process-tree and then clean it up.\n        msg \u003d formatErrorMessage(\"virtual\",\n                formatUsageString(currentVmemUsage, vmemLimit,\n                  currentPmemUsage, pmemLimit),\n                pId, containerId, pTree, delta);\n        isMemoryOverLimit \u003d true;\n        containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_VMEM;\n      } else if (isPmemCheckEnabled()\n              \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n              currentPmemUsage, curRssMemUsageOfAgedProcesses,\n              pmemLimit)) {\n        // The current usage (age\u003d0) is always higher than the aged usage. We\n        // do not show the aged size in the message, base the delta on the\n        // current usage\n        long delta \u003d currentPmemUsage - pmemLimit;\n        // Container (the root process) is still alive and overflowing\n        // memory.\n        // Dump the process-tree and then clean it up.\n        msg \u003d formatErrorMessage(\"physical\",\n                formatUsageString(currentVmemUsage, vmemLimit,\n                  currentPmemUsage, pmemLimit),\n                pId, containerId, pTree, delta);\n        isMemoryOverLimit \u003d true;\n        containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_PMEM;\n      }\n\n      if (isMemoryOverLimit) {\n        // Virtual or physical memory over limit. Fail the container and\n        // remove\n        // the corresponding process tree\n        LOG.warn(msg);\n        // warn if not a leader\n        if (!pTree.checkPidPgrpidForMatch()) {\n          LOG.error(\"Killed container process with PID \" + pId\n                  + \" but it is not a process group leader.\");\n        }\n        // kill the container\n        eventDispatcher.getEventHandler().handle(\n                new ContainerKillEvent(containerId,\n                      containerExitStatus, msg));\n        trackingContainers.remove(containerId);\n        LOG.info(\"Removed ProcessTree with root \" + pId);\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/monitor/ContainersMonitorImpl.java",
      "extendedDetails": {}
    },
    "9449519a2503c55d9eac8fd7519df28aa0760059": {
      "type": "Yintroduced",
      "commitMessage": "YARN-5776. Checkstyle: MonitoringThread.Run method length is too long (miklos.szegedi@cloudera.com via rkanter)\n",
      "commitDate": "27/10/16 2:36 PM",
      "commitName": "9449519a2503c55d9eac8fd7519df28aa0760059",
      "commitAuthor": "Robert Kanter",
      "diff": "@@ -0,0 +1,59 @@\n+    private void checkLimit(ContainerId containerId, String pId,\n+                            ResourceCalculatorProcessTree pTree,\n+                            ProcessTreeInfo ptInfo,\n+                            long currentVmemUsage,\n+                            long currentPmemUsage) {\n+      boolean isMemoryOverLimit \u003d false;\n+      long vmemLimit \u003d ptInfo.getVmemLimit();\n+      long pmemLimit \u003d ptInfo.getPmemLimit();\n+      // as processes begin with an age 1, we want to see if there\n+      // are processes more than 1 iteration old.\n+      long curMemUsageOfAgedProcesses \u003d pTree.getVirtualMemorySize(1);\n+      long curRssMemUsageOfAgedProcesses \u003d pTree.getRssMemorySize(1);\n+      String msg \u003d \"\";\n+      int containerExitStatus \u003d ContainerExitStatus.INVALID;\n+      if (isVmemCheckEnabled()\n+              \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n+              currentVmemUsage, curMemUsageOfAgedProcesses, vmemLimit)) {\n+        // Container (the root process) is still alive and overflowing\n+        // memory.\n+        // Dump the process-tree and then clean it up.\n+        msg \u003d formatErrorMessage(\"virtual\",\n+                formatUsageString(currentVmemUsage, vmemLimit,\n+                  currentPmemUsage, pmemLimit),\n+                pId, containerId, pTree);\n+        isMemoryOverLimit \u003d true;\n+        containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_VMEM;\n+      } else if (isPmemCheckEnabled()\n+              \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n+              currentPmemUsage, curRssMemUsageOfAgedProcesses,\n+              pmemLimit)) {\n+        // Container (the root process) is still alive and overflowing\n+        // memory.\n+        // Dump the process-tree and then clean it up.\n+        msg \u003d formatErrorMessage(\"physical\",\n+                formatUsageString(currentVmemUsage, vmemLimit,\n+                  currentPmemUsage, pmemLimit),\n+                pId, containerId, pTree);\n+        isMemoryOverLimit \u003d true;\n+        containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_PMEM;\n+      }\n+\n+      if (isMemoryOverLimit) {\n+        // Virtual or physical memory over limit. Fail the container and\n+        // remove\n+        // the corresponding process tree\n+        LOG.warn(msg);\n+        // warn if not a leader\n+        if (!pTree.checkPidPgrpidForMatch()) {\n+          LOG.error(\"Killed container process with PID \" + pId\n+                  + \" but it is not a process group leader.\");\n+        }\n+        // kill the container\n+        eventDispatcher.getEventHandler().handle(\n+                new ContainerKillEvent(containerId,\n+                      containerExitStatus, msg));\n+        trackingContainers.remove(containerId);\n+        LOG.info(\"Removed ProcessTree with root \" + pId);\n+      }\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    private void checkLimit(ContainerId containerId, String pId,\n                            ResourceCalculatorProcessTree pTree,\n                            ProcessTreeInfo ptInfo,\n                            long currentVmemUsage,\n                            long currentPmemUsage) {\n      boolean isMemoryOverLimit \u003d false;\n      long vmemLimit \u003d ptInfo.getVmemLimit();\n      long pmemLimit \u003d ptInfo.getPmemLimit();\n      // as processes begin with an age 1, we want to see if there\n      // are processes more than 1 iteration old.\n      long curMemUsageOfAgedProcesses \u003d pTree.getVirtualMemorySize(1);\n      long curRssMemUsageOfAgedProcesses \u003d pTree.getRssMemorySize(1);\n      String msg \u003d \"\";\n      int containerExitStatus \u003d ContainerExitStatus.INVALID;\n      if (isVmemCheckEnabled()\n              \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n              currentVmemUsage, curMemUsageOfAgedProcesses, vmemLimit)) {\n        // Container (the root process) is still alive and overflowing\n        // memory.\n        // Dump the process-tree and then clean it up.\n        msg \u003d formatErrorMessage(\"virtual\",\n                formatUsageString(currentVmemUsage, vmemLimit,\n                  currentPmemUsage, pmemLimit),\n                pId, containerId, pTree);\n        isMemoryOverLimit \u003d true;\n        containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_VMEM;\n      } else if (isPmemCheckEnabled()\n              \u0026\u0026 isProcessTreeOverLimit(containerId.toString(),\n              currentPmemUsage, curRssMemUsageOfAgedProcesses,\n              pmemLimit)) {\n        // Container (the root process) is still alive and overflowing\n        // memory.\n        // Dump the process-tree and then clean it up.\n        msg \u003d formatErrorMessage(\"physical\",\n                formatUsageString(currentVmemUsage, vmemLimit,\n                  currentPmemUsage, pmemLimit),\n                pId, containerId, pTree);\n        isMemoryOverLimit \u003d true;\n        containerExitStatus \u003d ContainerExitStatus.KILLED_EXCEEDED_PMEM;\n      }\n\n      if (isMemoryOverLimit) {\n        // Virtual or physical memory over limit. Fail the container and\n        // remove\n        // the corresponding process tree\n        LOG.warn(msg);\n        // warn if not a leader\n        if (!pTree.checkPidPgrpidForMatch()) {\n          LOG.error(\"Killed container process with PID \" + pId\n                  + \" but it is not a process group leader.\");\n        }\n        // kill the container\n        eventDispatcher.getEventHandler().handle(\n                new ContainerKillEvent(containerId,\n                      containerExitStatus, msg));\n        trackingContainers.remove(containerId);\n        LOG.info(\"Removed ProcessTree with root \" + pId);\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/monitor/ContainersMonitorImpl.java"
    }
  }
}