{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FSDirWriteFileOp.java",
  "functionName": "abandonBlock",
  "functionId": "abandonBlock___fsd-FSDirectory__pc-FSPermissionChecker__b-ExtendedBlock__fileId-long__src-String__holder-String",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
  "functionStartLine": 117,
  "functionEndLine": 140,
  "numCommitsSeen": 65,
  "timeTaken": 3964,
  "changeHistory": [
    "a2a5d7b5bca715835d92816e7b267b59f7270708",
    "869393643de23dcb010cc33091c8eb398de0fd6c",
    "03dea65e0b17ca2f9460bb6110f6ab3a321b8bf2",
    "067ec8c2b14fb0929dc348b763383838e06ff8a5",
    "bc99aaffe7b0ed13b1efc37b6a32cdbd344c2d75",
    "d62b63d297bff12d93de560dd50ddd48743b851d",
    "e5afac5896a1a88e152746598527d91f73cbb724"
  ],
  "changeHistoryShort": {
    "a2a5d7b5bca715835d92816e7b267b59f7270708": "Ybodychange",
    "869393643de23dcb010cc33091c8eb398de0fd6c": "Ybodychange",
    "03dea65e0b17ca2f9460bb6110f6ab3a321b8bf2": "Ybodychange",
    "067ec8c2b14fb0929dc348b763383838e06ff8a5": "Ybodychange",
    "bc99aaffe7b0ed13b1efc37b6a32cdbd344c2d75": "Ybodychange",
    "d62b63d297bff12d93de560dd50ddd48743b851d": "Ybodychange",
    "e5afac5896a1a88e152746598527d91f73cbb724": "Yintroduced"
  },
  "changeHistoryDetails": {
    "a2a5d7b5bca715835d92816e7b267b59f7270708": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10759. Change fsimage bool isStriped from boolean to an enum. Contributed by Ewan Higgs.\n",
      "commitDate": "18/01/17 1:31 PM",
      "commitName": "a2a5d7b5bca715835d92816e7b267b59f7270708",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "24/10/16 3:14 PM",
      "commitNameOld": "9d175853b0170683ad5f21d9bcdeaac49fe89e04",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 85.97,
      "commitsBetweenForRepo": 568,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,24 +1,24 @@\n   static void abandonBlock(\n       FSDirectory fsd, FSPermissionChecker pc, ExtendedBlock b, long fileId,\n       String src, String holder) throws IOException {\n     final INodesInPath iip \u003d fsd.resolvePath(pc, src, fileId);\n     src \u003d iip.getPath();\n     FSNamesystem fsn \u003d fsd.getFSNamesystem();\n     final INodeFile file \u003d fsn.checkLease(iip, holder, fileId);\n     Preconditions.checkState(file.isUnderConstruction());\n-    if (file.isStriped()) {\n+    if (file.getBlockType() \u003d\u003d BlockType.STRIPED) {\n       return; // do not abandon block for striped file\n     }\n \n     Block localBlock \u003d ExtendedBlock.getLocalBlock(b);\n     fsd.writeLock();\n     try {\n       // Remove the block from the pending creates list\n       if (!unprotectedRemoveBlock(fsd, src, iip, file, localBlock)) {\n         return;\n       }\n     } finally {\n       fsd.writeUnlock();\n     }\n     persistBlocks(fsd, src, file, false);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static void abandonBlock(\n      FSDirectory fsd, FSPermissionChecker pc, ExtendedBlock b, long fileId,\n      String src, String holder) throws IOException {\n    final INodesInPath iip \u003d fsd.resolvePath(pc, src, fileId);\n    src \u003d iip.getPath();\n    FSNamesystem fsn \u003d fsd.getFSNamesystem();\n    final INodeFile file \u003d fsn.checkLease(iip, holder, fileId);\n    Preconditions.checkState(file.isUnderConstruction());\n    if (file.getBlockType() \u003d\u003d BlockType.STRIPED) {\n      return; // do not abandon block for striped file\n    }\n\n    Block localBlock \u003d ExtendedBlock.getLocalBlock(b);\n    fsd.writeLock();\n    try {\n      // Remove the block from the pending creates list\n      if (!unprotectedRemoveBlock(fsd, src, iip, file, localBlock)) {\n        return;\n      }\n    } finally {\n      fsd.writeUnlock();\n    }\n    persistBlocks(fsd, src, file, false);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
      "extendedDetails": {}
    },
    "869393643de23dcb010cc33091c8eb398de0fd6c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10745. Directly resolve paths into INodesInPath. Contributed by Daryn Sharp.\n",
      "commitDate": "17/08/16 1:53 PM",
      "commitName": "869393643de23dcb010cc33091c8eb398de0fd6c",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "15/08/16 2:45 PM",
      "commitNameOld": "03dea65e0b17ca2f9460bb6110f6ab3a321b8bf2",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 1.96,
      "commitsBetweenForRepo": 23,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,39 +1,24 @@\n   static void abandonBlock(\n       FSDirectory fsd, FSPermissionChecker pc, ExtendedBlock b, long fileId,\n       String src, String holder) throws IOException {\n-    src \u003d fsd.resolvePath(pc, src);\n-\n-    final INode inode;\n-    final INodesInPath iip;\n-    if (fileId \u003d\u003d HdfsConstants.GRANDFATHER_INODE_ID) {\n-      // Older clients may not have given us an inode ID to work with.\n-      // In this case, we have to try to resolve the path and hope it\n-      // hasn\u0027t changed or been deleted since the file was opened for write.\n-      iip \u003d fsd.getINodesInPath(src, true);\n-      inode \u003d iip.getLastINode();\n-    } else {\n-      inode \u003d fsd.getInode(fileId);\n-      iip \u003d INodesInPath.fromINode(inode);\n-      if (inode !\u003d null) {\n-        src \u003d iip.getPath();\n-      }\n-    }\n+    final INodesInPath iip \u003d fsd.resolvePath(pc, src, fileId);\n+    src \u003d iip.getPath();\n     FSNamesystem fsn \u003d fsd.getFSNamesystem();\n-    final INodeFile file \u003d fsn.checkLease(src, holder, inode, fileId);\n+    final INodeFile file \u003d fsn.checkLease(iip, holder, fileId);\n     Preconditions.checkState(file.isUnderConstruction());\n     if (file.isStriped()) {\n       return; // do not abandon block for striped file\n     }\n \n     Block localBlock \u003d ExtendedBlock.getLocalBlock(b);\n     fsd.writeLock();\n     try {\n       // Remove the block from the pending creates list\n       if (!unprotectedRemoveBlock(fsd, src, iip, file, localBlock)) {\n         return;\n       }\n     } finally {\n       fsd.writeUnlock();\n     }\n     persistBlocks(fsd, src, file, false);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static void abandonBlock(\n      FSDirectory fsd, FSPermissionChecker pc, ExtendedBlock b, long fileId,\n      String src, String holder) throws IOException {\n    final INodesInPath iip \u003d fsd.resolvePath(pc, src, fileId);\n    src \u003d iip.getPath();\n    FSNamesystem fsn \u003d fsd.getFSNamesystem();\n    final INodeFile file \u003d fsn.checkLease(iip, holder, fileId);\n    Preconditions.checkState(file.isUnderConstruction());\n    if (file.isStriped()) {\n      return; // do not abandon block for striped file\n    }\n\n    Block localBlock \u003d ExtendedBlock.getLocalBlock(b);\n    fsd.writeLock();\n    try {\n      // Remove the block from the pending creates list\n      if (!unprotectedRemoveBlock(fsd, src, iip, file, localBlock)) {\n        return;\n      }\n    } finally {\n      fsd.writeUnlock();\n    }\n    persistBlocks(fsd, src, file, false);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
      "extendedDetails": {}
    },
    "03dea65e0b17ca2f9460bb6110f6ab3a321b8bf2": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10744. Internally optimize path component resolution. Contributed by Daryn Sharp.\n",
      "commitDate": "15/08/16 2:45 PM",
      "commitName": "03dea65e0b17ca2f9460bb6110f6ab3a321b8bf2",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "04/08/16 7:07 AM",
      "commitNameOld": "6ae39199dac6ac7be6802b31452552c76da16e24",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 11.32,
      "commitsBetweenForRepo": 73,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,39 @@\n   static void abandonBlock(\n       FSDirectory fsd, FSPermissionChecker pc, ExtendedBlock b, long fileId,\n       String src, String holder) throws IOException {\n-    byte[][] pathComponents \u003d FSDirectory.getPathComponentsForReservedPath(src);\n-    src \u003d fsd.resolvePath(pc, src, pathComponents);\n+    src \u003d fsd.resolvePath(pc, src);\n \n     final INode inode;\n     final INodesInPath iip;\n     if (fileId \u003d\u003d HdfsConstants.GRANDFATHER_INODE_ID) {\n       // Older clients may not have given us an inode ID to work with.\n       // In this case, we have to try to resolve the path and hope it\n       // hasn\u0027t changed or been deleted since the file was opened for write.\n       iip \u003d fsd.getINodesInPath(src, true);\n       inode \u003d iip.getLastINode();\n     } else {\n       inode \u003d fsd.getInode(fileId);\n       iip \u003d INodesInPath.fromINode(inode);\n       if (inode !\u003d null) {\n         src \u003d iip.getPath();\n       }\n     }\n     FSNamesystem fsn \u003d fsd.getFSNamesystem();\n     final INodeFile file \u003d fsn.checkLease(src, holder, inode, fileId);\n     Preconditions.checkState(file.isUnderConstruction());\n     if (file.isStriped()) {\n       return; // do not abandon block for striped file\n     }\n \n     Block localBlock \u003d ExtendedBlock.getLocalBlock(b);\n     fsd.writeLock();\n     try {\n       // Remove the block from the pending creates list\n       if (!unprotectedRemoveBlock(fsd, src, iip, file, localBlock)) {\n         return;\n       }\n     } finally {\n       fsd.writeUnlock();\n     }\n     persistBlocks(fsd, src, file, false);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static void abandonBlock(\n      FSDirectory fsd, FSPermissionChecker pc, ExtendedBlock b, long fileId,\n      String src, String holder) throws IOException {\n    src \u003d fsd.resolvePath(pc, src);\n\n    final INode inode;\n    final INodesInPath iip;\n    if (fileId \u003d\u003d HdfsConstants.GRANDFATHER_INODE_ID) {\n      // Older clients may not have given us an inode ID to work with.\n      // In this case, we have to try to resolve the path and hope it\n      // hasn\u0027t changed or been deleted since the file was opened for write.\n      iip \u003d fsd.getINodesInPath(src, true);\n      inode \u003d iip.getLastINode();\n    } else {\n      inode \u003d fsd.getInode(fileId);\n      iip \u003d INodesInPath.fromINode(inode);\n      if (inode !\u003d null) {\n        src \u003d iip.getPath();\n      }\n    }\n    FSNamesystem fsn \u003d fsd.getFSNamesystem();\n    final INodeFile file \u003d fsn.checkLease(src, holder, inode, fileId);\n    Preconditions.checkState(file.isUnderConstruction());\n    if (file.isStriped()) {\n      return; // do not abandon block for striped file\n    }\n\n    Block localBlock \u003d ExtendedBlock.getLocalBlock(b);\n    fsd.writeLock();\n    try {\n      // Remove the block from the pending creates list\n      if (!unprotectedRemoveBlock(fsd, src, iip, file, localBlock)) {\n        return;\n      }\n    } finally {\n      fsd.writeUnlock();\n    }\n    persistBlocks(fsd, src, file, false);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
      "extendedDetails": {}
    },
    "067ec8c2b14fb0929dc348b763383838e06ff8a5": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8838. Erasure Coding: Tolerate datanode failures in DFSStripedOutputStream when the data length is small. Contributed by Tsz Wo Nicholas Sze.\n",
      "commitDate": "26/08/15 6:11 PM",
      "commitName": "067ec8c2b14fb0929dc348b763383838e06ff8a5",
      "commitAuthor": "Walter Su",
      "commitDateOld": "24/08/15 12:59 PM",
      "commitNameOld": "6b6a63bbbda920315d3d24b61ed3344a78a981b6",
      "commitAuthorOld": "",
      "daysBetweenCommits": 2.22,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,37 +1,40 @@\n   static void abandonBlock(\n       FSDirectory fsd, FSPermissionChecker pc, ExtendedBlock b, long fileId,\n       String src, String holder) throws IOException {\n     byte[][] pathComponents \u003d FSDirectory.getPathComponentsForReservedPath(src);\n     src \u003d fsd.resolvePath(pc, src, pathComponents);\n \n     final INode inode;\n     final INodesInPath iip;\n     if (fileId \u003d\u003d HdfsConstants.GRANDFATHER_INODE_ID) {\n       // Older clients may not have given us an inode ID to work with.\n       // In this case, we have to try to resolve the path and hope it\n       // hasn\u0027t changed or been deleted since the file was opened for write.\n       iip \u003d fsd.getINodesInPath(src, true);\n       inode \u003d iip.getLastINode();\n     } else {\n       inode \u003d fsd.getInode(fileId);\n       iip \u003d INodesInPath.fromINode(inode);\n       if (inode !\u003d null) {\n         src \u003d iip.getPath();\n       }\n     }\n     FSNamesystem fsn \u003d fsd.getFSNamesystem();\n     final INodeFile file \u003d fsn.checkLease(src, holder, inode, fileId);\n     Preconditions.checkState(file.isUnderConstruction());\n+    if (file.isStriped()) {\n+      return; // do not abandon block for striped file\n+    }\n \n     Block localBlock \u003d ExtendedBlock.getLocalBlock(b);\n     fsd.writeLock();\n     try {\n       // Remove the block from the pending creates list\n       if (!unprotectedRemoveBlock(fsd, src, iip, file, localBlock)) {\n         return;\n       }\n     } finally {\n       fsd.writeUnlock();\n     }\n     persistBlocks(fsd, src, file, false);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static void abandonBlock(\n      FSDirectory fsd, FSPermissionChecker pc, ExtendedBlock b, long fileId,\n      String src, String holder) throws IOException {\n    byte[][] pathComponents \u003d FSDirectory.getPathComponentsForReservedPath(src);\n    src \u003d fsd.resolvePath(pc, src, pathComponents);\n\n    final INode inode;\n    final INodesInPath iip;\n    if (fileId \u003d\u003d HdfsConstants.GRANDFATHER_INODE_ID) {\n      // Older clients may not have given us an inode ID to work with.\n      // In this case, we have to try to resolve the path and hope it\n      // hasn\u0027t changed or been deleted since the file was opened for write.\n      iip \u003d fsd.getINodesInPath(src, true);\n      inode \u003d iip.getLastINode();\n    } else {\n      inode \u003d fsd.getInode(fileId);\n      iip \u003d INodesInPath.fromINode(inode);\n      if (inode !\u003d null) {\n        src \u003d iip.getPath();\n      }\n    }\n    FSNamesystem fsn \u003d fsd.getFSNamesystem();\n    final INodeFile file \u003d fsn.checkLease(src, holder, inode, fileId);\n    Preconditions.checkState(file.isUnderConstruction());\n    if (file.isStriped()) {\n      return; // do not abandon block for striped file\n    }\n\n    Block localBlock \u003d ExtendedBlock.getLocalBlock(b);\n    fsd.writeLock();\n    try {\n      // Remove the block from the pending creates list\n      if (!unprotectedRemoveBlock(fsd, src, iip, file, localBlock)) {\n        return;\n      }\n    } finally {\n      fsd.writeUnlock();\n    }\n    persistBlocks(fsd, src, file, false);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
      "extendedDetails": {}
    },
    "bc99aaffe7b0ed13b1efc37b6a32cdbd344c2d75": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HDFS-8652. Track BlockInfo instead of Block in CorruptReplicasMap. Contributed by Jing Zhao.\"\n\nThis reverts commit d62b63d297bff12d93de560dd50ddd48743b851d.\n",
      "commitDate": "07/07/15 10:13 AM",
      "commitName": "bc99aaffe7b0ed13b1efc37b6a32cdbd344c2d75",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "06/07/15 3:54 PM",
      "commitNameOld": "d62b63d297bff12d93de560dd50ddd48743b851d",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 0.76,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,39 +1,37 @@\n   static void abandonBlock(\n       FSDirectory fsd, FSPermissionChecker pc, ExtendedBlock b, long fileId,\n       String src, String holder) throws IOException {\n     byte[][] pathComponents \u003d FSDirectory.getPathComponentsForReservedPath(src);\n     src \u003d fsd.resolvePath(pc, src, pathComponents);\n \n     final INode inode;\n     final INodesInPath iip;\n     if (fileId \u003d\u003d HdfsConstants.GRANDFATHER_INODE_ID) {\n       // Older clients may not have given us an inode ID to work with.\n       // In this case, we have to try to resolve the path and hope it\n       // hasn\u0027t changed or been deleted since the file was opened for write.\n       iip \u003d fsd.getINodesInPath(src, true);\n       inode \u003d iip.getLastINode();\n     } else {\n       inode \u003d fsd.getInode(fileId);\n       iip \u003d INodesInPath.fromINode(inode);\n       if (inode !\u003d null) {\n         src \u003d iip.getPath();\n       }\n     }\n     FSNamesystem fsn \u003d fsd.getFSNamesystem();\n     final INodeFile file \u003d fsn.checkLease(src, holder, inode, fileId);\n     Preconditions.checkState(file.isUnderConstruction());\n \n     Block localBlock \u003d ExtendedBlock.getLocalBlock(b);\n     fsd.writeLock();\n     try {\n       // Remove the block from the pending creates list\n-      BlockInfo storedBlock \u003d fsd.getBlockManager().getStoredBlock(localBlock);\n-      if (storedBlock !\u003d null \u0026\u0026\n-          !unprotectedRemoveBlock(fsd, src, iip, file, storedBlock)) {\n+      if (!unprotectedRemoveBlock(fsd, src, iip, file, localBlock)) {\n         return;\n       }\n     } finally {\n       fsd.writeUnlock();\n     }\n     persistBlocks(fsd, src, file, false);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static void abandonBlock(\n      FSDirectory fsd, FSPermissionChecker pc, ExtendedBlock b, long fileId,\n      String src, String holder) throws IOException {\n    byte[][] pathComponents \u003d FSDirectory.getPathComponentsForReservedPath(src);\n    src \u003d fsd.resolvePath(pc, src, pathComponents);\n\n    final INode inode;\n    final INodesInPath iip;\n    if (fileId \u003d\u003d HdfsConstants.GRANDFATHER_INODE_ID) {\n      // Older clients may not have given us an inode ID to work with.\n      // In this case, we have to try to resolve the path and hope it\n      // hasn\u0027t changed or been deleted since the file was opened for write.\n      iip \u003d fsd.getINodesInPath(src, true);\n      inode \u003d iip.getLastINode();\n    } else {\n      inode \u003d fsd.getInode(fileId);\n      iip \u003d INodesInPath.fromINode(inode);\n      if (inode !\u003d null) {\n        src \u003d iip.getPath();\n      }\n    }\n    FSNamesystem fsn \u003d fsd.getFSNamesystem();\n    final INodeFile file \u003d fsn.checkLease(src, holder, inode, fileId);\n    Preconditions.checkState(file.isUnderConstruction());\n\n    Block localBlock \u003d ExtendedBlock.getLocalBlock(b);\n    fsd.writeLock();\n    try {\n      // Remove the block from the pending creates list\n      if (!unprotectedRemoveBlock(fsd, src, iip, file, localBlock)) {\n        return;\n      }\n    } finally {\n      fsd.writeUnlock();\n    }\n    persistBlocks(fsd, src, file, false);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
      "extendedDetails": {}
    },
    "d62b63d297bff12d93de560dd50ddd48743b851d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8652. Track BlockInfo instead of Block in CorruptReplicasMap. Contributed by Jing Zhao.\n",
      "commitDate": "06/07/15 3:54 PM",
      "commitName": "d62b63d297bff12d93de560dd50ddd48743b851d",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "12/06/15 11:38 AM",
      "commitNameOld": "c17439c2ddd921b63b1635e6f1cba634b8da8557",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 24.18,
      "commitsBetweenForRepo": 153,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,37 +1,39 @@\n   static void abandonBlock(\n       FSDirectory fsd, FSPermissionChecker pc, ExtendedBlock b, long fileId,\n       String src, String holder) throws IOException {\n     byte[][] pathComponents \u003d FSDirectory.getPathComponentsForReservedPath(src);\n     src \u003d fsd.resolvePath(pc, src, pathComponents);\n \n     final INode inode;\n     final INodesInPath iip;\n     if (fileId \u003d\u003d HdfsConstants.GRANDFATHER_INODE_ID) {\n       // Older clients may not have given us an inode ID to work with.\n       // In this case, we have to try to resolve the path and hope it\n       // hasn\u0027t changed or been deleted since the file was opened for write.\n       iip \u003d fsd.getINodesInPath(src, true);\n       inode \u003d iip.getLastINode();\n     } else {\n       inode \u003d fsd.getInode(fileId);\n       iip \u003d INodesInPath.fromINode(inode);\n       if (inode !\u003d null) {\n         src \u003d iip.getPath();\n       }\n     }\n     FSNamesystem fsn \u003d fsd.getFSNamesystem();\n     final INodeFile file \u003d fsn.checkLease(src, holder, inode, fileId);\n     Preconditions.checkState(file.isUnderConstruction());\n \n     Block localBlock \u003d ExtendedBlock.getLocalBlock(b);\n     fsd.writeLock();\n     try {\n       // Remove the block from the pending creates list\n-      if (!unprotectedRemoveBlock(fsd, src, iip, file, localBlock)) {\n+      BlockInfo storedBlock \u003d fsd.getBlockManager().getStoredBlock(localBlock);\n+      if (storedBlock !\u003d null \u0026\u0026\n+          !unprotectedRemoveBlock(fsd, src, iip, file, storedBlock)) {\n         return;\n       }\n     } finally {\n       fsd.writeUnlock();\n     }\n     persistBlocks(fsd, src, file, false);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static void abandonBlock(\n      FSDirectory fsd, FSPermissionChecker pc, ExtendedBlock b, long fileId,\n      String src, String holder) throws IOException {\n    byte[][] pathComponents \u003d FSDirectory.getPathComponentsForReservedPath(src);\n    src \u003d fsd.resolvePath(pc, src, pathComponents);\n\n    final INode inode;\n    final INodesInPath iip;\n    if (fileId \u003d\u003d HdfsConstants.GRANDFATHER_INODE_ID) {\n      // Older clients may not have given us an inode ID to work with.\n      // In this case, we have to try to resolve the path and hope it\n      // hasn\u0027t changed or been deleted since the file was opened for write.\n      iip \u003d fsd.getINodesInPath(src, true);\n      inode \u003d iip.getLastINode();\n    } else {\n      inode \u003d fsd.getInode(fileId);\n      iip \u003d INodesInPath.fromINode(inode);\n      if (inode !\u003d null) {\n        src \u003d iip.getPath();\n      }\n    }\n    FSNamesystem fsn \u003d fsd.getFSNamesystem();\n    final INodeFile file \u003d fsn.checkLease(src, holder, inode, fileId);\n    Preconditions.checkState(file.isUnderConstruction());\n\n    Block localBlock \u003d ExtendedBlock.getLocalBlock(b);\n    fsd.writeLock();\n    try {\n      // Remove the block from the pending creates list\n      BlockInfo storedBlock \u003d fsd.getBlockManager().getStoredBlock(localBlock);\n      if (storedBlock !\u003d null \u0026\u0026\n          !unprotectedRemoveBlock(fsd, src, iip, file, storedBlock)) {\n        return;\n      }\n    } finally {\n      fsd.writeUnlock();\n    }\n    persistBlocks(fsd, src, file, false);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
      "extendedDetails": {}
    },
    "e5afac5896a1a88e152746598527d91f73cbb724": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-8394. Move getAdditionalBlock() and related functionalities into a separate class. Contributed by Haohui Mai.\n",
      "commitDate": "15/05/15 7:09 PM",
      "commitName": "e5afac5896a1a88e152746598527d91f73cbb724",
      "commitAuthor": "Haohui Mai",
      "diff": "@@ -0,0 +1,37 @@\n+  static void abandonBlock(\n+      FSDirectory fsd, FSPermissionChecker pc, ExtendedBlock b, long fileId,\n+      String src, String holder) throws IOException {\n+    byte[][] pathComponents \u003d FSDirectory.getPathComponentsForReservedPath(src);\n+    src \u003d fsd.resolvePath(pc, src, pathComponents);\n+\n+    final INode inode;\n+    final INodesInPath iip;\n+    if (fileId \u003d\u003d HdfsConstants.GRANDFATHER_INODE_ID) {\n+      // Older clients may not have given us an inode ID to work with.\n+      // In this case, we have to try to resolve the path and hope it\n+      // hasn\u0027t changed or been deleted since the file was opened for write.\n+      iip \u003d fsd.getINodesInPath(src, true);\n+      inode \u003d iip.getLastINode();\n+    } else {\n+      inode \u003d fsd.getInode(fileId);\n+      iip \u003d INodesInPath.fromINode(inode);\n+      if (inode !\u003d null) {\n+        src \u003d iip.getPath();\n+      }\n+    }\n+    FSNamesystem fsn \u003d fsd.getFSNamesystem();\n+    final INodeFile file \u003d fsn.checkLease(src, holder, inode, fileId);\n+    Preconditions.checkState(file.isUnderConstruction());\n+\n+    Block localBlock \u003d ExtendedBlock.getLocalBlock(b);\n+    fsd.writeLock();\n+    try {\n+      // Remove the block from the pending creates list\n+      if (!unprotectedRemoveBlock(fsd, src, iip, file, localBlock)) {\n+        return;\n+      }\n+    } finally {\n+      fsd.writeUnlock();\n+    }\n+    persistBlocks(fsd, src, file, false);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  static void abandonBlock(\n      FSDirectory fsd, FSPermissionChecker pc, ExtendedBlock b, long fileId,\n      String src, String holder) throws IOException {\n    byte[][] pathComponents \u003d FSDirectory.getPathComponentsForReservedPath(src);\n    src \u003d fsd.resolvePath(pc, src, pathComponents);\n\n    final INode inode;\n    final INodesInPath iip;\n    if (fileId \u003d\u003d HdfsConstants.GRANDFATHER_INODE_ID) {\n      // Older clients may not have given us an inode ID to work with.\n      // In this case, we have to try to resolve the path and hope it\n      // hasn\u0027t changed or been deleted since the file was opened for write.\n      iip \u003d fsd.getINodesInPath(src, true);\n      inode \u003d iip.getLastINode();\n    } else {\n      inode \u003d fsd.getInode(fileId);\n      iip \u003d INodesInPath.fromINode(inode);\n      if (inode !\u003d null) {\n        src \u003d iip.getPath();\n      }\n    }\n    FSNamesystem fsn \u003d fsd.getFSNamesystem();\n    final INodeFile file \u003d fsn.checkLease(src, holder, inode, fileId);\n    Preconditions.checkState(file.isUnderConstruction());\n\n    Block localBlock \u003d ExtendedBlock.getLocalBlock(b);\n    fsd.writeLock();\n    try {\n      // Remove the block from the pending creates list\n      if (!unprotectedRemoveBlock(fsd, src, iip, file, localBlock)) {\n        return;\n      }\n    } finally {\n      fsd.writeUnlock();\n    }\n    persistBlocks(fsd, src, file, false);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java"
    }
  }
}