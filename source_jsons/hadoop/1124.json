{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "DfsClientShmManager.java",
  "functionName": "allocSlot",
  "functionId": "allocSlot___peer-DomainPeer__usedPeer-MutableBoolean__clientName-String__blockId-ExtendedBlockId",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/shortcircuit/DfsClientShmManager.java",
  "functionStartLine": 224,
  "functionEndLine": 278,
  "numCommitsSeen": 15,
  "timeTaken": 3057,
  "changeHistory": [
    "39285e6a1978ea5e53bdc1b0aef62421382124a8",
    "6ee0539ede78b640f01c5eac18ded161182a7835",
    "d5a9a3daa0224249221ffa7b8bd5751ab2feca56",
    "490bb5ebd6c6d6f9c08fcad167f976687fc3aa42",
    "e85a3fecc68b48a3dc9af5daa466a24f3b39545b",
    "f93d99990a9a02ce693cd74466c2e5f127c1f560",
    "95e0f616b96371824e653e761f3188c06615fe35",
    "dd049a2f6097da189ccce2f5890a2b9bc77fa73f"
  ],
  "changeHistoryShort": {
    "39285e6a1978ea5e53bdc1b0aef62421382124a8": "Ybodychange",
    "6ee0539ede78b640f01c5eac18ded161182a7835": "Ybodychange",
    "d5a9a3daa0224249221ffa7b8bd5751ab2feca56": "Ybodychange",
    "490bb5ebd6c6d6f9c08fcad167f976687fc3aa42": "Yfilerename",
    "e85a3fecc68b48a3dc9af5daa466a24f3b39545b": "Ybodychange",
    "f93d99990a9a02ce693cd74466c2e5f127c1f560": "Yfilerename",
    "95e0f616b96371824e653e761f3188c06615fe35": "Ybodychange",
    "dd049a2f6097da189ccce2f5890a2b9bc77fa73f": "Yintroduced"
  },
  "changeHistoryDetails": {
    "39285e6a1978ea5e53bdc1b0aef62421382124a8": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8971. Remove guards when calling LOG.debug() and LOG.trace() in client package. Contributed by Mingliang Liu.\n",
      "commitDate": "29/09/15 5:52 PM",
      "commitName": "39285e6a1978ea5e53bdc1b0aef62421382124a8",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "29/09/15 5:51 PM",
      "commitNameOld": "6ee0539ede78b640f01c5eac18ded161182a7835",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,63 +1,55 @@\n     Slot allocSlot(DomainPeer peer, MutableBoolean usedPeer,\n         String clientName, ExtendedBlockId blockId) throws IOException {\n       while (true) {\n         if (closed) {\n-          if (LOG.isTraceEnabled()) {\n-            LOG.trace(this + \": the DfsClientShmManager has been closed.\");\n-          }\n+          LOG.trace(\"{}: the DfsClientShmManager has been closed.\", this);\n           return null;\n         }\n         if (disabled) {\n-          if (LOG.isTraceEnabled()) {\n-            LOG.trace(this + \": shared memory segment access is disabled.\");\n-          }\n+          LOG.trace(\"{}: shared memory segment access is disabled.\", this);\n           return null;\n         }\n         // Try to use an existing slot.\n         Slot slot \u003d allocSlotFromExistingShm(blockId);\n         if (slot !\u003d null) {\n           return slot;\n         }\n         // There are no free slots.  If someone is loading more slots, wait\n         // for that to finish.\n         if (loading) {\n-          if (LOG.isTraceEnabled()) {\n-            LOG.trace(this + \": waiting for loading to finish...\");\n-          }\n+          LOG.trace(\"{}: waiting for loading to finish...\", this);\n           finishedLoading.awaitUninterruptibly();\n         } else {\n           // Otherwise, load the slot ourselves.\n           loading \u003d true;\n           lock.unlock();\n           DfsClientShm shm;\n           try {\n             shm \u003d requestNewShm(clientName, peer);\n             if (shm \u003d\u003d null) continue;\n             // See #{DfsClientShmManager#domainSocketWatcher} for details\n             // about why we do this before retaking the manager lock.\n             domainSocketWatcher.add(peer.getDomainSocket(), shm);\n             // The DomainPeer is now our responsibility, and should not be\n             // closed by the caller.\n             usedPeer.setValue(true);\n           } finally {\n             lock.lock();\n             loading \u003d false;\n             finishedLoading.signalAll();\n           }\n           if (shm.isDisconnected()) {\n             // If the peer closed immediately after the shared memory segment\n             // was created, the DomainSocketWatcher callback might already have\n             // fired and marked the shm as disconnected.  In this case, we\n             // obviously don\u0027t want to add the SharedMemorySegment to our list\n             // of valid not-full segments.\n-            if (LOG.isDebugEnabled()) {\n-              LOG.debug(this + \": the UNIX domain socket associated with \" +\n-                  \"this short-circuit memory closed before we could make \" +\n-                  \"use of the shm.\");\n-            }\n+            LOG.debug(\"{}: the UNIX domain socket associated with this \"\n+                + \"short-circuit memory closed before we could make use of \"\n+                + \"the shm.\", this);\n           } else {\n             notFull.put(shm.getShmId(), shm);\n           }\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    Slot allocSlot(DomainPeer peer, MutableBoolean usedPeer,\n        String clientName, ExtendedBlockId blockId) throws IOException {\n      while (true) {\n        if (closed) {\n          LOG.trace(\"{}: the DfsClientShmManager has been closed.\", this);\n          return null;\n        }\n        if (disabled) {\n          LOG.trace(\"{}: shared memory segment access is disabled.\", this);\n          return null;\n        }\n        // Try to use an existing slot.\n        Slot slot \u003d allocSlotFromExistingShm(blockId);\n        if (slot !\u003d null) {\n          return slot;\n        }\n        // There are no free slots.  If someone is loading more slots, wait\n        // for that to finish.\n        if (loading) {\n          LOG.trace(\"{}: waiting for loading to finish...\", this);\n          finishedLoading.awaitUninterruptibly();\n        } else {\n          // Otherwise, load the slot ourselves.\n          loading \u003d true;\n          lock.unlock();\n          DfsClientShm shm;\n          try {\n            shm \u003d requestNewShm(clientName, peer);\n            if (shm \u003d\u003d null) continue;\n            // See #{DfsClientShmManager#domainSocketWatcher} for details\n            // about why we do this before retaking the manager lock.\n            domainSocketWatcher.add(peer.getDomainSocket(), shm);\n            // The DomainPeer is now our responsibility, and should not be\n            // closed by the caller.\n            usedPeer.setValue(true);\n          } finally {\n            lock.lock();\n            loading \u003d false;\n            finishedLoading.signalAll();\n          }\n          if (shm.isDisconnected()) {\n            // If the peer closed immediately after the shared memory segment\n            // was created, the DomainSocketWatcher callback might already have\n            // fired and marked the shm as disconnected.  In this case, we\n            // obviously don\u0027t want to add the SharedMemorySegment to our list\n            // of valid not-full segments.\n            LOG.debug(\"{}: the UNIX domain socket associated with this \"\n                + \"short-circuit memory closed before we could make use of \"\n                + \"the shm.\", this);\n          } else {\n            notFull.put(shm.getShmId(), shm);\n          }\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/shortcircuit/DfsClientShmManager.java",
      "extendedDetails": {}
    },
    "6ee0539ede78b640f01c5eac18ded161182a7835": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HDFS-9170. Move libhdfs / fuse-dfs / libwebhdfs to hdfs-client. Contributed by Haohui Mai.\"\n\nThis reverts commit d5a9a3daa0224249221ffa7b8bd5751ab2feca56.\n",
      "commitDate": "29/09/15 5:51 PM",
      "commitName": "6ee0539ede78b640f01c5eac18ded161182a7835",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "29/09/15 5:48 PM",
      "commitNameOld": "d5a9a3daa0224249221ffa7b8bd5751ab2feca56",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,55 +1,63 @@\n     Slot allocSlot(DomainPeer peer, MutableBoolean usedPeer,\n         String clientName, ExtendedBlockId blockId) throws IOException {\n       while (true) {\n         if (closed) {\n-          LOG.trace(\"{}: the DfsClientShmManager has been closed.\", this);\n+          if (LOG.isTraceEnabled()) {\n+            LOG.trace(this + \": the DfsClientShmManager has been closed.\");\n+          }\n           return null;\n         }\n         if (disabled) {\n-          LOG.trace(\"{}: shared memory segment access is disabled.\", this);\n+          if (LOG.isTraceEnabled()) {\n+            LOG.trace(this + \": shared memory segment access is disabled.\");\n+          }\n           return null;\n         }\n         // Try to use an existing slot.\n         Slot slot \u003d allocSlotFromExistingShm(blockId);\n         if (slot !\u003d null) {\n           return slot;\n         }\n         // There are no free slots.  If someone is loading more slots, wait\n         // for that to finish.\n         if (loading) {\n-          LOG.trace(\"{}: waiting for loading to finish...\", this);\n+          if (LOG.isTraceEnabled()) {\n+            LOG.trace(this + \": waiting for loading to finish...\");\n+          }\n           finishedLoading.awaitUninterruptibly();\n         } else {\n           // Otherwise, load the slot ourselves.\n           loading \u003d true;\n           lock.unlock();\n           DfsClientShm shm;\n           try {\n             shm \u003d requestNewShm(clientName, peer);\n             if (shm \u003d\u003d null) continue;\n             // See #{DfsClientShmManager#domainSocketWatcher} for details\n             // about why we do this before retaking the manager lock.\n             domainSocketWatcher.add(peer.getDomainSocket(), shm);\n             // The DomainPeer is now our responsibility, and should not be\n             // closed by the caller.\n             usedPeer.setValue(true);\n           } finally {\n             lock.lock();\n             loading \u003d false;\n             finishedLoading.signalAll();\n           }\n           if (shm.isDisconnected()) {\n             // If the peer closed immediately after the shared memory segment\n             // was created, the DomainSocketWatcher callback might already have\n             // fired and marked the shm as disconnected.  In this case, we\n             // obviously don\u0027t want to add the SharedMemorySegment to our list\n             // of valid not-full segments.\n-            LOG.debug(\"{}: the UNIX domain socket associated with this \"\n-                + \"short-circuit memory closed before we could make use of \"\n-                + \"the shm.\", this);\n+            if (LOG.isDebugEnabled()) {\n+              LOG.debug(this + \": the UNIX domain socket associated with \" +\n+                  \"this short-circuit memory closed before we could make \" +\n+                  \"use of the shm.\");\n+            }\n           } else {\n             notFull.put(shm.getShmId(), shm);\n           }\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    Slot allocSlot(DomainPeer peer, MutableBoolean usedPeer,\n        String clientName, ExtendedBlockId blockId) throws IOException {\n      while (true) {\n        if (closed) {\n          if (LOG.isTraceEnabled()) {\n            LOG.trace(this + \": the DfsClientShmManager has been closed.\");\n          }\n          return null;\n        }\n        if (disabled) {\n          if (LOG.isTraceEnabled()) {\n            LOG.trace(this + \": shared memory segment access is disabled.\");\n          }\n          return null;\n        }\n        // Try to use an existing slot.\n        Slot slot \u003d allocSlotFromExistingShm(blockId);\n        if (slot !\u003d null) {\n          return slot;\n        }\n        // There are no free slots.  If someone is loading more slots, wait\n        // for that to finish.\n        if (loading) {\n          if (LOG.isTraceEnabled()) {\n            LOG.trace(this + \": waiting for loading to finish...\");\n          }\n          finishedLoading.awaitUninterruptibly();\n        } else {\n          // Otherwise, load the slot ourselves.\n          loading \u003d true;\n          lock.unlock();\n          DfsClientShm shm;\n          try {\n            shm \u003d requestNewShm(clientName, peer);\n            if (shm \u003d\u003d null) continue;\n            // See #{DfsClientShmManager#domainSocketWatcher} for details\n            // about why we do this before retaking the manager lock.\n            domainSocketWatcher.add(peer.getDomainSocket(), shm);\n            // The DomainPeer is now our responsibility, and should not be\n            // closed by the caller.\n            usedPeer.setValue(true);\n          } finally {\n            lock.lock();\n            loading \u003d false;\n            finishedLoading.signalAll();\n          }\n          if (shm.isDisconnected()) {\n            // If the peer closed immediately after the shared memory segment\n            // was created, the DomainSocketWatcher callback might already have\n            // fired and marked the shm as disconnected.  In this case, we\n            // obviously don\u0027t want to add the SharedMemorySegment to our list\n            // of valid not-full segments.\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(this + \": the UNIX domain socket associated with \" +\n                  \"this short-circuit memory closed before we could make \" +\n                  \"use of the shm.\");\n            }\n          } else {\n            notFull.put(shm.getShmId(), shm);\n          }\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/shortcircuit/DfsClientShmManager.java",
      "extendedDetails": {}
    },
    "d5a9a3daa0224249221ffa7b8bd5751ab2feca56": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9170. Move libhdfs / fuse-dfs / libwebhdfs to hdfs-client. Contributed by Haohui Mai.\n",
      "commitDate": "29/09/15 5:48 PM",
      "commitName": "d5a9a3daa0224249221ffa7b8bd5751ab2feca56",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "22/08/15 1:31 PM",
      "commitNameOld": "490bb5ebd6c6d6f9c08fcad167f976687fc3aa42",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 38.18,
      "commitsBetweenForRepo": 247,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,63 +1,55 @@\n     Slot allocSlot(DomainPeer peer, MutableBoolean usedPeer,\n         String clientName, ExtendedBlockId blockId) throws IOException {\n       while (true) {\n         if (closed) {\n-          if (LOG.isTraceEnabled()) {\n-            LOG.trace(this + \": the DfsClientShmManager has been closed.\");\n-          }\n+          LOG.trace(\"{}: the DfsClientShmManager has been closed.\", this);\n           return null;\n         }\n         if (disabled) {\n-          if (LOG.isTraceEnabled()) {\n-            LOG.trace(this + \": shared memory segment access is disabled.\");\n-          }\n+          LOG.trace(\"{}: shared memory segment access is disabled.\", this);\n           return null;\n         }\n         // Try to use an existing slot.\n         Slot slot \u003d allocSlotFromExistingShm(blockId);\n         if (slot !\u003d null) {\n           return slot;\n         }\n         // There are no free slots.  If someone is loading more slots, wait\n         // for that to finish.\n         if (loading) {\n-          if (LOG.isTraceEnabled()) {\n-            LOG.trace(this + \": waiting for loading to finish...\");\n-          }\n+          LOG.trace(\"{}: waiting for loading to finish...\", this);\n           finishedLoading.awaitUninterruptibly();\n         } else {\n           // Otherwise, load the slot ourselves.\n           loading \u003d true;\n           lock.unlock();\n           DfsClientShm shm;\n           try {\n             shm \u003d requestNewShm(clientName, peer);\n             if (shm \u003d\u003d null) continue;\n             // See #{DfsClientShmManager#domainSocketWatcher} for details\n             // about why we do this before retaking the manager lock.\n             domainSocketWatcher.add(peer.getDomainSocket(), shm);\n             // The DomainPeer is now our responsibility, and should not be\n             // closed by the caller.\n             usedPeer.setValue(true);\n           } finally {\n             lock.lock();\n             loading \u003d false;\n             finishedLoading.signalAll();\n           }\n           if (shm.isDisconnected()) {\n             // If the peer closed immediately after the shared memory segment\n             // was created, the DomainSocketWatcher callback might already have\n             // fired and marked the shm as disconnected.  In this case, we\n             // obviously don\u0027t want to add the SharedMemorySegment to our list\n             // of valid not-full segments.\n-            if (LOG.isDebugEnabled()) {\n-              LOG.debug(this + \": the UNIX domain socket associated with \" +\n-                  \"this short-circuit memory closed before we could make \" +\n-                  \"use of the shm.\");\n-            }\n+            LOG.debug(\"{}: the UNIX domain socket associated with this \"\n+                + \"short-circuit memory closed before we could make use of \"\n+                + \"the shm.\", this);\n           } else {\n             notFull.put(shm.getShmId(), shm);\n           }\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    Slot allocSlot(DomainPeer peer, MutableBoolean usedPeer,\n        String clientName, ExtendedBlockId blockId) throws IOException {\n      while (true) {\n        if (closed) {\n          LOG.trace(\"{}: the DfsClientShmManager has been closed.\", this);\n          return null;\n        }\n        if (disabled) {\n          LOG.trace(\"{}: shared memory segment access is disabled.\", this);\n          return null;\n        }\n        // Try to use an existing slot.\n        Slot slot \u003d allocSlotFromExistingShm(blockId);\n        if (slot !\u003d null) {\n          return slot;\n        }\n        // There are no free slots.  If someone is loading more slots, wait\n        // for that to finish.\n        if (loading) {\n          LOG.trace(\"{}: waiting for loading to finish...\", this);\n          finishedLoading.awaitUninterruptibly();\n        } else {\n          // Otherwise, load the slot ourselves.\n          loading \u003d true;\n          lock.unlock();\n          DfsClientShm shm;\n          try {\n            shm \u003d requestNewShm(clientName, peer);\n            if (shm \u003d\u003d null) continue;\n            // See #{DfsClientShmManager#domainSocketWatcher} for details\n            // about why we do this before retaking the manager lock.\n            domainSocketWatcher.add(peer.getDomainSocket(), shm);\n            // The DomainPeer is now our responsibility, and should not be\n            // closed by the caller.\n            usedPeer.setValue(true);\n          } finally {\n            lock.lock();\n            loading \u003d false;\n            finishedLoading.signalAll();\n          }\n          if (shm.isDisconnected()) {\n            // If the peer closed immediately after the shared memory segment\n            // was created, the DomainSocketWatcher callback might already have\n            // fired and marked the shm as disconnected.  In this case, we\n            // obviously don\u0027t want to add the SharedMemorySegment to our list\n            // of valid not-full segments.\n            LOG.debug(\"{}: the UNIX domain socket associated with this \"\n                + \"short-circuit memory closed before we could make use of \"\n                + \"the shm.\", this);\n          } else {\n            notFull.put(shm.getShmId(), shm);\n          }\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/shortcircuit/DfsClientShmManager.java",
      "extendedDetails": {}
    },
    "490bb5ebd6c6d6f9c08fcad167f976687fc3aa42": {
      "type": "Yfilerename",
      "commitMessage": "HDFS-8934. Move ShortCircuitShm to hdfs-client. Contributed by Mingliang Liu.\n",
      "commitDate": "22/08/15 1:31 PM",
      "commitName": "490bb5ebd6c6d6f9c08fcad167f976687fc3aa42",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "22/08/15 12:39 AM",
      "commitNameOld": "61bf9cae6f3882c6e9a9222f59457b9be91e3018",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 0.54,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    Slot allocSlot(DomainPeer peer, MutableBoolean usedPeer,\n        String clientName, ExtendedBlockId blockId) throws IOException {\n      while (true) {\n        if (closed) {\n          if (LOG.isTraceEnabled()) {\n            LOG.trace(this + \": the DfsClientShmManager has been closed.\");\n          }\n          return null;\n        }\n        if (disabled) {\n          if (LOG.isTraceEnabled()) {\n            LOG.trace(this + \": shared memory segment access is disabled.\");\n          }\n          return null;\n        }\n        // Try to use an existing slot.\n        Slot slot \u003d allocSlotFromExistingShm(blockId);\n        if (slot !\u003d null) {\n          return slot;\n        }\n        // There are no free slots.  If someone is loading more slots, wait\n        // for that to finish.\n        if (loading) {\n          if (LOG.isTraceEnabled()) {\n            LOG.trace(this + \": waiting for loading to finish...\");\n          }\n          finishedLoading.awaitUninterruptibly();\n        } else {\n          // Otherwise, load the slot ourselves.\n          loading \u003d true;\n          lock.unlock();\n          DfsClientShm shm;\n          try {\n            shm \u003d requestNewShm(clientName, peer);\n            if (shm \u003d\u003d null) continue;\n            // See #{DfsClientShmManager#domainSocketWatcher} for details\n            // about why we do this before retaking the manager lock.\n            domainSocketWatcher.add(peer.getDomainSocket(), shm);\n            // The DomainPeer is now our responsibility, and should not be\n            // closed by the caller.\n            usedPeer.setValue(true);\n          } finally {\n            lock.lock();\n            loading \u003d false;\n            finishedLoading.signalAll();\n          }\n          if (shm.isDisconnected()) {\n            // If the peer closed immediately after the shared memory segment\n            // was created, the DomainSocketWatcher callback might already have\n            // fired and marked the shm as disconnected.  In this case, we\n            // obviously don\u0027t want to add the SharedMemorySegment to our list\n            // of valid not-full segments.\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(this + \": the UNIX domain socket associated with \" +\n                  \"this short-circuit memory closed before we could make \" +\n                  \"use of the shm.\");\n            }\n          } else {\n            notFull.put(shm.getShmId(), shm);\n          }\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/shortcircuit/DfsClientShmManager.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/shortcircuit/DfsClientShmManager.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/shortcircuit/DfsClientShmManager.java"
      }
    },
    "e85a3fecc68b48a3dc9af5daa466a24f3b39545b": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6750. The DataNode should use its shared memory segment to mark short-circuit replicas that have been unlinked as stale (cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1613537 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/07/14 4:56 PM",
      "commitName": "e85a3fecc68b48a3dc9af5daa466a24f3b39545b",
      "commitAuthor": "Colin McCabe",
      "commitDateOld": "01/04/14 10:09 PM",
      "commitNameOld": "f93d99990a9a02ce693cd74466c2e5f127c1f560",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 114.78,
      "commitsBetweenForRepo": 722,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,63 +1,63 @@\n     Slot allocSlot(DomainPeer peer, MutableBoolean usedPeer,\n         String clientName, ExtendedBlockId blockId) throws IOException {\n       while (true) {\n         if (closed) {\n           if (LOG.isTraceEnabled()) {\n             LOG.trace(this + \": the DfsClientShmManager has been closed.\");\n           }\n           return null;\n         }\n         if (disabled) {\n           if (LOG.isTraceEnabled()) {\n             LOG.trace(this + \": shared memory segment access is disabled.\");\n           }\n           return null;\n         }\n         // Try to use an existing slot.\n         Slot slot \u003d allocSlotFromExistingShm(blockId);\n         if (slot !\u003d null) {\n           return slot;\n         }\n         // There are no free slots.  If someone is loading more slots, wait\n         // for that to finish.\n         if (loading) {\n           if (LOG.isTraceEnabled()) {\n             LOG.trace(this + \": waiting for loading to finish...\");\n           }\n           finishedLoading.awaitUninterruptibly();\n         } else {\n           // Otherwise, load the slot ourselves.\n           loading \u003d true;\n           lock.unlock();\n           DfsClientShm shm;\n           try {\n             shm \u003d requestNewShm(clientName, peer);\n             if (shm \u003d\u003d null) continue;\n             // See #{DfsClientShmManager#domainSocketWatcher} for details\n             // about why we do this before retaking the manager lock.\n             domainSocketWatcher.add(peer.getDomainSocket(), shm);\n             // The DomainPeer is now our responsibility, and should not be\n             // closed by the caller.\n             usedPeer.setValue(true);\n           } finally {\n             lock.lock();\n             loading \u003d false;\n             finishedLoading.signalAll();\n           }\n-          if (shm.isStale()) {\n+          if (shm.isDisconnected()) {\n             // If the peer closed immediately after the shared memory segment\n             // was created, the DomainSocketWatcher callback might already have\n-            // fired and marked the shm as stale.  In this case, we obviously\n-            // don\u0027t want to add the SharedMemorySegment to our list of valid\n-            // not-full segments.\n+            // fired and marked the shm as disconnected.  In this case, we\n+            // obviously don\u0027t want to add the SharedMemorySegment to our list\n+            // of valid not-full segments.\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(this + \": the UNIX domain socket associated with \" +\n                   \"this short-circuit memory closed before we could make \" +\n                   \"use of the shm.\");\n             }\n           } else {\n             notFull.put(shm.getShmId(), shm);\n           }\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    Slot allocSlot(DomainPeer peer, MutableBoolean usedPeer,\n        String clientName, ExtendedBlockId blockId) throws IOException {\n      while (true) {\n        if (closed) {\n          if (LOG.isTraceEnabled()) {\n            LOG.trace(this + \": the DfsClientShmManager has been closed.\");\n          }\n          return null;\n        }\n        if (disabled) {\n          if (LOG.isTraceEnabled()) {\n            LOG.trace(this + \": shared memory segment access is disabled.\");\n          }\n          return null;\n        }\n        // Try to use an existing slot.\n        Slot slot \u003d allocSlotFromExistingShm(blockId);\n        if (slot !\u003d null) {\n          return slot;\n        }\n        // There are no free slots.  If someone is loading more slots, wait\n        // for that to finish.\n        if (loading) {\n          if (LOG.isTraceEnabled()) {\n            LOG.trace(this + \": waiting for loading to finish...\");\n          }\n          finishedLoading.awaitUninterruptibly();\n        } else {\n          // Otherwise, load the slot ourselves.\n          loading \u003d true;\n          lock.unlock();\n          DfsClientShm shm;\n          try {\n            shm \u003d requestNewShm(clientName, peer);\n            if (shm \u003d\u003d null) continue;\n            // See #{DfsClientShmManager#domainSocketWatcher} for details\n            // about why we do this before retaking the manager lock.\n            domainSocketWatcher.add(peer.getDomainSocket(), shm);\n            // The DomainPeer is now our responsibility, and should not be\n            // closed by the caller.\n            usedPeer.setValue(true);\n          } finally {\n            lock.lock();\n            loading \u003d false;\n            finishedLoading.signalAll();\n          }\n          if (shm.isDisconnected()) {\n            // If the peer closed immediately after the shared memory segment\n            // was created, the DomainSocketWatcher callback might already have\n            // fired and marked the shm as disconnected.  In this case, we\n            // obviously don\u0027t want to add the SharedMemorySegment to our list\n            // of valid not-full segments.\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(this + \": the UNIX domain socket associated with \" +\n                  \"this short-circuit memory closed before we could make \" +\n                  \"use of the shm.\");\n            }\n          } else {\n            notFull.put(shm.getShmId(), shm);\n          }\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/shortcircuit/DfsClientShmManager.java",
      "extendedDetails": {}
    },
    "f93d99990a9a02ce693cd74466c2e5f127c1f560": {
      "type": "Yfilerename",
      "commitMessage": "HDFS-6167. Relocate the non-public API classes in the hdfs.client package.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1583878 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "01/04/14 10:09 PM",
      "commitName": "f93d99990a9a02ce693cd74466c2e5f127c1f560",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "01/04/14 6:00 PM",
      "commitNameOld": "5c7cb51775bd3d4a6e3e1bd501b3a8d747733fe3",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 0.17,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    Slot allocSlot(DomainPeer peer, MutableBoolean usedPeer,\n        String clientName, ExtendedBlockId blockId) throws IOException {\n      while (true) {\n        if (closed) {\n          if (LOG.isTraceEnabled()) {\n            LOG.trace(this + \": the DfsClientShmManager has been closed.\");\n          }\n          return null;\n        }\n        if (disabled) {\n          if (LOG.isTraceEnabled()) {\n            LOG.trace(this + \": shared memory segment access is disabled.\");\n          }\n          return null;\n        }\n        // Try to use an existing slot.\n        Slot slot \u003d allocSlotFromExistingShm(blockId);\n        if (slot !\u003d null) {\n          return slot;\n        }\n        // There are no free slots.  If someone is loading more slots, wait\n        // for that to finish.\n        if (loading) {\n          if (LOG.isTraceEnabled()) {\n            LOG.trace(this + \": waiting for loading to finish...\");\n          }\n          finishedLoading.awaitUninterruptibly();\n        } else {\n          // Otherwise, load the slot ourselves.\n          loading \u003d true;\n          lock.unlock();\n          DfsClientShm shm;\n          try {\n            shm \u003d requestNewShm(clientName, peer);\n            if (shm \u003d\u003d null) continue;\n            // See #{DfsClientShmManager#domainSocketWatcher} for details\n            // about why we do this before retaking the manager lock.\n            domainSocketWatcher.add(peer.getDomainSocket(), shm);\n            // The DomainPeer is now our responsibility, and should not be\n            // closed by the caller.\n            usedPeer.setValue(true);\n          } finally {\n            lock.lock();\n            loading \u003d false;\n            finishedLoading.signalAll();\n          }\n          if (shm.isStale()) {\n            // If the peer closed immediately after the shared memory segment\n            // was created, the DomainSocketWatcher callback might already have\n            // fired and marked the shm as stale.  In this case, we obviously\n            // don\u0027t want to add the SharedMemorySegment to our list of valid\n            // not-full segments.\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(this + \": the UNIX domain socket associated with \" +\n                  \"this short-circuit memory closed before we could make \" +\n                  \"use of the shm.\");\n            }\n          } else {\n            notFull.put(shm.getShmId(), shm);\n          }\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/shortcircuit/DfsClientShmManager.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/client/DfsClientShmManager.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/shortcircuit/DfsClientShmManager.java"
      }
    },
    "95e0f616b96371824e653e761f3188c06615fe35": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6057. DomainSocketWatcher.watcherThread should be marked as a daemon thread (cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1574787 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "05/03/14 11:57 PM",
      "commitName": "95e0f616b96371824e653e761f3188c06615fe35",
      "commitAuthor": "Colin McCabe",
      "commitDateOld": "02/03/14 7:58 PM",
      "commitNameOld": "dd049a2f6097da189ccce2f5890a2b9bc77fa73f",
      "commitAuthorOld": "Colin McCabe",
      "daysBetweenCommits": 3.17,
      "commitsBetweenForRepo": 37,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,57 +1,63 @@\n     Slot allocSlot(DomainPeer peer, MutableBoolean usedPeer,\n         String clientName, ExtendedBlockId blockId) throws IOException {\n       while (true) {\n+        if (closed) {\n+          if (LOG.isTraceEnabled()) {\n+            LOG.trace(this + \": the DfsClientShmManager has been closed.\");\n+          }\n+          return null;\n+        }\n         if (disabled) {\n           if (LOG.isTraceEnabled()) {\n             LOG.trace(this + \": shared memory segment access is disabled.\");\n           }\n           return null;\n         }\n         // Try to use an existing slot.\n         Slot slot \u003d allocSlotFromExistingShm(blockId);\n         if (slot !\u003d null) {\n           return slot;\n         }\n         // There are no free slots.  If someone is loading more slots, wait\n         // for that to finish.\n         if (loading) {\n           if (LOG.isTraceEnabled()) {\n             LOG.trace(this + \": waiting for loading to finish...\");\n           }\n           finishedLoading.awaitUninterruptibly();\n         } else {\n           // Otherwise, load the slot ourselves.\n           loading \u003d true;\n           lock.unlock();\n           DfsClientShm shm;\n           try {\n             shm \u003d requestNewShm(clientName, peer);\n             if (shm \u003d\u003d null) continue;\n             // See #{DfsClientShmManager#domainSocketWatcher} for details\n             // about why we do this before retaking the manager lock.\n             domainSocketWatcher.add(peer.getDomainSocket(), shm);\n             // The DomainPeer is now our responsibility, and should not be\n             // closed by the caller.\n             usedPeer.setValue(true);\n           } finally {\n             lock.lock();\n             loading \u003d false;\n             finishedLoading.signalAll();\n           }\n           if (shm.isStale()) {\n             // If the peer closed immediately after the shared memory segment\n             // was created, the DomainSocketWatcher callback might already have\n             // fired and marked the shm as stale.  In this case, we obviously\n             // don\u0027t want to add the SharedMemorySegment to our list of valid\n             // not-full segments.\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(this + \": the UNIX domain socket associated with \" +\n                   \"this short-circuit memory closed before we could make \" +\n                   \"use of the shm.\");\n             }\n           } else {\n             notFull.put(shm.getShmId(), shm);\n           }\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    Slot allocSlot(DomainPeer peer, MutableBoolean usedPeer,\n        String clientName, ExtendedBlockId blockId) throws IOException {\n      while (true) {\n        if (closed) {\n          if (LOG.isTraceEnabled()) {\n            LOG.trace(this + \": the DfsClientShmManager has been closed.\");\n          }\n          return null;\n        }\n        if (disabled) {\n          if (LOG.isTraceEnabled()) {\n            LOG.trace(this + \": shared memory segment access is disabled.\");\n          }\n          return null;\n        }\n        // Try to use an existing slot.\n        Slot slot \u003d allocSlotFromExistingShm(blockId);\n        if (slot !\u003d null) {\n          return slot;\n        }\n        // There are no free slots.  If someone is loading more slots, wait\n        // for that to finish.\n        if (loading) {\n          if (LOG.isTraceEnabled()) {\n            LOG.trace(this + \": waiting for loading to finish...\");\n          }\n          finishedLoading.awaitUninterruptibly();\n        } else {\n          // Otherwise, load the slot ourselves.\n          loading \u003d true;\n          lock.unlock();\n          DfsClientShm shm;\n          try {\n            shm \u003d requestNewShm(clientName, peer);\n            if (shm \u003d\u003d null) continue;\n            // See #{DfsClientShmManager#domainSocketWatcher} for details\n            // about why we do this before retaking the manager lock.\n            domainSocketWatcher.add(peer.getDomainSocket(), shm);\n            // The DomainPeer is now our responsibility, and should not be\n            // closed by the caller.\n            usedPeer.setValue(true);\n          } finally {\n            lock.lock();\n            loading \u003d false;\n            finishedLoading.signalAll();\n          }\n          if (shm.isStale()) {\n            // If the peer closed immediately after the shared memory segment\n            // was created, the DomainSocketWatcher callback might already have\n            // fired and marked the shm as stale.  In this case, we obviously\n            // don\u0027t want to add the SharedMemorySegment to our list of valid\n            // not-full segments.\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(this + \": the UNIX domain socket associated with \" +\n                  \"this short-circuit memory closed before we could make \" +\n                  \"use of the shm.\");\n            }\n          } else {\n            notFull.put(shm.getShmId(), shm);\n          }\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/client/DfsClientShmManager.java",
      "extendedDetails": {}
    },
    "dd049a2f6097da189ccce2f5890a2b9bc77fa73f": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-5950. The DFSClient and DataNode should use shared memory segments to communicate short-circuit information (cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1573433 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/03/14 7:58 PM",
      "commitName": "dd049a2f6097da189ccce2f5890a2b9bc77fa73f",
      "commitAuthor": "Colin McCabe",
      "diff": "@@ -0,0 +1,57 @@\n+    Slot allocSlot(DomainPeer peer, MutableBoolean usedPeer,\n+        String clientName, ExtendedBlockId blockId) throws IOException {\n+      while (true) {\n+        if (disabled) {\n+          if (LOG.isTraceEnabled()) {\n+            LOG.trace(this + \": shared memory segment access is disabled.\");\n+          }\n+          return null;\n+        }\n+        // Try to use an existing slot.\n+        Slot slot \u003d allocSlotFromExistingShm(blockId);\n+        if (slot !\u003d null) {\n+          return slot;\n+        }\n+        // There are no free slots.  If someone is loading more slots, wait\n+        // for that to finish.\n+        if (loading) {\n+          if (LOG.isTraceEnabled()) {\n+            LOG.trace(this + \": waiting for loading to finish...\");\n+          }\n+          finishedLoading.awaitUninterruptibly();\n+        } else {\n+          // Otherwise, load the slot ourselves.\n+          loading \u003d true;\n+          lock.unlock();\n+          DfsClientShm shm;\n+          try {\n+            shm \u003d requestNewShm(clientName, peer);\n+            if (shm \u003d\u003d null) continue;\n+            // See #{DfsClientShmManager#domainSocketWatcher} for details\n+            // about why we do this before retaking the manager lock.\n+            domainSocketWatcher.add(peer.getDomainSocket(), shm);\n+            // The DomainPeer is now our responsibility, and should not be\n+            // closed by the caller.\n+            usedPeer.setValue(true);\n+          } finally {\n+            lock.lock();\n+            loading \u003d false;\n+            finishedLoading.signalAll();\n+          }\n+          if (shm.isStale()) {\n+            // If the peer closed immediately after the shared memory segment\n+            // was created, the DomainSocketWatcher callback might already have\n+            // fired and marked the shm as stale.  In this case, we obviously\n+            // don\u0027t want to add the SharedMemorySegment to our list of valid\n+            // not-full segments.\n+            if (LOG.isDebugEnabled()) {\n+              LOG.debug(this + \": the UNIX domain socket associated with \" +\n+                  \"this short-circuit memory closed before we could make \" +\n+                  \"use of the shm.\");\n+            }\n+          } else {\n+            notFull.put(shm.getShmId(), shm);\n+          }\n+        }\n+      }\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    Slot allocSlot(DomainPeer peer, MutableBoolean usedPeer,\n        String clientName, ExtendedBlockId blockId) throws IOException {\n      while (true) {\n        if (disabled) {\n          if (LOG.isTraceEnabled()) {\n            LOG.trace(this + \": shared memory segment access is disabled.\");\n          }\n          return null;\n        }\n        // Try to use an existing slot.\n        Slot slot \u003d allocSlotFromExistingShm(blockId);\n        if (slot !\u003d null) {\n          return slot;\n        }\n        // There are no free slots.  If someone is loading more slots, wait\n        // for that to finish.\n        if (loading) {\n          if (LOG.isTraceEnabled()) {\n            LOG.trace(this + \": waiting for loading to finish...\");\n          }\n          finishedLoading.awaitUninterruptibly();\n        } else {\n          // Otherwise, load the slot ourselves.\n          loading \u003d true;\n          lock.unlock();\n          DfsClientShm shm;\n          try {\n            shm \u003d requestNewShm(clientName, peer);\n            if (shm \u003d\u003d null) continue;\n            // See #{DfsClientShmManager#domainSocketWatcher} for details\n            // about why we do this before retaking the manager lock.\n            domainSocketWatcher.add(peer.getDomainSocket(), shm);\n            // The DomainPeer is now our responsibility, and should not be\n            // closed by the caller.\n            usedPeer.setValue(true);\n          } finally {\n            lock.lock();\n            loading \u003d false;\n            finishedLoading.signalAll();\n          }\n          if (shm.isStale()) {\n            // If the peer closed immediately after the shared memory segment\n            // was created, the DomainSocketWatcher callback might already have\n            // fired and marked the shm as stale.  In this case, we obviously\n            // don\u0027t want to add the SharedMemorySegment to our list of valid\n            // not-full segments.\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(this + \": the UNIX domain socket associated with \" +\n                  \"this short-circuit memory closed before we could make \" +\n                  \"use of the shm.\");\n            }\n          } else {\n            notFull.put(shm.getShmId(), shm);\n          }\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/client/DfsClientShmManager.java"
    }
  }
}