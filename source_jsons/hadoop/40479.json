{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "SingleConstraintAppPlacementAllocator.java",
  "functionName": "validateAndSetSchedulingRequest",
  "functionId": "validateAndSetSchedulingRequest___newSchedulingRequest-SchedulingRequest",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/placement/SingleConstraintAppPlacementAllocator.java",
  "functionStartLine": 221,
  "functionEndLine": 251,
  "numCommitsSeen": 17,
  "timeTaken": 6319,
  "changeHistory": [
    "1ac01444a24faee6f74f2e83d9521eb4e0be651b",
    "6468071f137e6d918a7b4799ad54558fa26b25ce",
    "7853ec8d2fb8731b7f7c28fd87491a0a2d47967e",
    "a08921ca6cb1dad98935808c8f474b654f861263",
    "1054b48c27f3158110bd0512afecded36eecb8ad",
    "644afe5fd800ac4f2b873a99f9b3868c3a8c5c40",
    "28fe7f331837b36e78fa34ed990993677dddeaee",
    "38af23796971193fa529c3d08ffde8fcd6e607b6"
  ],
  "changeHistoryShort": {
    "1ac01444a24faee6f74f2e83d9521eb4e0be651b": "Ybodychange",
    "6468071f137e6d918a7b4799ad54558fa26b25ce": "Ybodychange",
    "7853ec8d2fb8731b7f7c28fd87491a0a2d47967e": "Ybodychange",
    "a08921ca6cb1dad98935808c8f474b654f861263": "Ybodychange",
    "1054b48c27f3158110bd0512afecded36eecb8ad": "Ybodychange",
    "644afe5fd800ac4f2b873a99f9b3868c3a8c5c40": "Ybodychange",
    "28fe7f331837b36e78fa34ed990993677dddeaee": "Ybodychange",
    "38af23796971193fa529c3d08ffde8fcd6e607b6": "Yintroduced"
  },
  "changeHistoryDetails": {
    "1ac01444a24faee6f74f2e83d9521eb4e0be651b": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8015. Support all types of placement constraint support for Capacity Scheduler. Contributed by Weiwei Yang.\n",
      "commitDate": "22/08/18 9:35 PM",
      "commitName": "1ac01444a24faee6f74f2e83d9521eb4e0be651b",
      "commitAuthor": "Sunil G",
      "commitDateOld": "21/08/18 4:00 AM",
      "commitNameOld": "54d0bf8935e35aad0f4d67df358ceb970cfcd713",
      "commitAuthorOld": "Weiwei Yang",
      "daysBetweenCommits": 1.73,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,149 +1,31 @@\n   private void validateAndSetSchedulingRequest(SchedulingRequest\n       newSchedulingRequest)\n       throws SchedulerInvalidResoureRequestException {\n     // Check sizing exists\n     if (newSchedulingRequest.getResourceSizing() \u003d\u003d null\n         || newSchedulingRequest.getResourceSizing().getResources() \u003d\u003d null) {\n       throwExceptionWithMetaInfo(\n           \"No ResourceSizing found in the scheduling request, please double \"\n               + \"check\");\n     }\n \n     // Check execution type \u003d\u003d GUARANTEED\n     if (newSchedulingRequest.getExecutionType() !\u003d null\n         \u0026\u0026 newSchedulingRequest.getExecutionType().getExecutionType()\n         !\u003d ExecutionType.GUARANTEED) {\n       throwExceptionWithMetaInfo(\n           \"Only GUARANTEED execution type is supported.\");\n     }\n \n-    // Node partition\n-    String nodePartition \u003d null;\n-    // Target allocation tags\n-    Set\u003cString\u003e targetAllocationTags \u003d null;\n-\n-    PlacementConstraint constraint \u003d\n-        newSchedulingRequest.getPlacementConstraint();\n-\n-    if (constraint !\u003d null) {\n-      // We only accept SingleConstraint\n-      PlacementConstraint.AbstractConstraint ac \u003d constraint\n-          .getConstraintExpr();\n-      if (!(ac instanceof PlacementConstraint.SingleConstraint)) {\n-        throwExceptionWithMetaInfo(\"Only accepts \"\n-            + PlacementConstraint.SingleConstraint.class.getName()\n-                + \" as constraint-expression. Rejecting the new added \"\n-            + \"constraint-expression.class\u003d\" + ac.getClass().getName());\n-      }\n-\n-      PlacementConstraint.SingleConstraint singleConstraint \u003d\n-          (PlacementConstraint.SingleConstraint) ac;\n-\n-      // Make sure it is an anti-affinity request (actually this implementation\n-      // should be able to support both affinity / anti-affinity without much\n-      // effort. Considering potential test effort required. Limit to\n-      // anti-affinity to intra-app and scope is node.\n-      if (!singleConstraint.getScope().equals(PlacementConstraints.NODE)) {\n-        throwExceptionWithMetaInfo(\n-            \"Only support scope\u003d\" + PlacementConstraints.NODE\n-                + \"now. PlacementConstraint\u003d\" + singleConstraint);\n-      }\n-\n-      if (singleConstraint.getMinCardinality() !\u003d 0\n-          || singleConstraint.getMaxCardinality() !\u003d 0) {\n-        throwExceptionWithMetaInfo(\n-            \"Only support anti-affinity, which is: minCardinality\u003d0, \"\n-                + \"maxCardinality\u003d1\");\n-      }\n-\n-      Set\u003cPlacementConstraint.TargetExpression\u003e targetExpressionSet \u003d\n-          singleConstraint.getTargetExpressions();\n-      if (targetExpressionSet \u003d\u003d null || targetExpressionSet.isEmpty()) {\n-        throwExceptionWithMetaInfo(\n-            \"TargetExpression should not be null or empty\");\n-      }\n-\n-      for (PlacementConstraint.TargetExpression targetExpression :\n-          targetExpressionSet) {\n-        // Handle node partition\n-        if (targetExpression.getTargetType().equals(\n-            PlacementConstraint.TargetExpression.TargetType.NODE_ATTRIBUTE)) {\n-          // For node attribute target, we only support Partition now. And once\n-          // YARN-3409 is merged, we will support node attribute.\n-          if (!targetExpression.getTargetKey().equals(NODE_PARTITION)) {\n-            throwExceptionWithMetaInfo(\"When TargetType\u003d\"\n-                + PlacementConstraint.TargetExpression.TargetType.NODE_ATTRIBUTE\n-                + \" only \" + NODE_PARTITION + \" is accepted as TargetKey.\");\n-          }\n-\n-          if (nodePartition !\u003d null) {\n-            // This means we have duplicated node partition entry\n-            // inside placement constraint, which might be set by mistake.\n-            throwExceptionWithMetaInfo(\n-                \"Only one node partition targetExpression is allowed\");\n-          }\n-\n-          Set\u003cString\u003e values \u003d targetExpression.getTargetValues();\n-          if (values \u003d\u003d null || values.isEmpty()) {\n-            nodePartition \u003d RMNodeLabelsManager.NO_LABEL;\n-            continue;\n-          }\n-\n-          if (values.size() \u003e 1) {\n-            throwExceptionWithMetaInfo(\"Inside one targetExpression, we only \"\n-                + \"support affinity to at most one node partition now\");\n-          }\n-\n-          nodePartition \u003d values.iterator().next();\n-        } else if (targetExpression.getTargetType().equals(\n-            PlacementConstraint.TargetExpression.TargetType.ALLOCATION_TAG)) {\n-          // Handle allocation tags\n-          if (targetAllocationTags !\u003d null) {\n-            // This means we have duplicated AllocationTag expressions entries\n-            // inside placement constraint, which might be set by mistake.\n-            throwExceptionWithMetaInfo(\n-                \"Only one AllocationTag targetExpression is allowed\");\n-          }\n-\n-          if (targetExpression.getTargetValues() \u003d\u003d null ||\n-              targetExpression.getTargetValues().isEmpty()) {\n-            throwExceptionWithMetaInfo(\"Failed to find allocation tags from \"\n-                + \"TargetExpressions or couldn\u0027t find self-app target.\");\n-          }\n-\n-          targetAllocationTags \u003d new HashSet\u003c\u003e(\n-              targetExpression.getTargetValues());\n-        }\n-      }\n-\n-      if (targetAllocationTags \u003d\u003d null) {\n-        // That means we don\u0027t have ALLOCATION_TAG specified\n-        throwExceptionWithMetaInfo(\n-            \"Couldn\u0027t find target expression with type \u003d\u003d ALLOCATION_TAG,\"\n-                + \" it is required to include one and only one target\"\n-                + \" expression with type \u003d\u003d ALLOCATION_TAG\");\n-      }\n-    }\n-\n-    // If this scheduling request doesn\u0027t contain a placement constraint,\n-    // we set allocation tags an empty set.\n-    if (targetAllocationTags \u003d\u003d null) {\n-      targetAllocationTags \u003d ImmutableSet.of();\n-    }\n-\n-    if (nodePartition \u003d\u003d null) {\n-      nodePartition \u003d RMNodeLabelsManager.NO_LABEL;\n-    }\n-\n-    // Validation is done. set local results:\n-    this.targetNodePartition \u003d nodePartition;\n-    this.targetAllocationTags \u003d targetAllocationTags;\n-\n+    this.targetNodePartition \u003d validateAndGetTargetNodePartition(\n+        newSchedulingRequest.getPlacementConstraint());\n     this.schedulingRequest \u003d new SchedulingRequestPBImpl(\n         ((SchedulingRequestPBImpl) newSchedulingRequest).getProto());\n \n-    LOG.info(\"Successfully added SchedulingRequest to app\u003d\" + appSchedulingInfo\n-        .getApplicationAttemptId() + \" targetAllocationTags\u003d[\" + StringUtils\n-        .join(\",\", targetAllocationTags) + \"]. nodePartition\u003d\"\n-        + targetNodePartition);\n+\n+    LOG.info(\"Successfully added SchedulingRequest to app\u003d\"\n+        + appSchedulingInfo.getApplicationAttemptId()\n+        + \" placementConstraint\u003d[\"\n+        + schedulingRequest.getPlacementConstraint()\n+        + \"]. nodePartition\u003d\" + targetNodePartition);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void validateAndSetSchedulingRequest(SchedulingRequest\n      newSchedulingRequest)\n      throws SchedulerInvalidResoureRequestException {\n    // Check sizing exists\n    if (newSchedulingRequest.getResourceSizing() \u003d\u003d null\n        || newSchedulingRequest.getResourceSizing().getResources() \u003d\u003d null) {\n      throwExceptionWithMetaInfo(\n          \"No ResourceSizing found in the scheduling request, please double \"\n              + \"check\");\n    }\n\n    // Check execution type \u003d\u003d GUARANTEED\n    if (newSchedulingRequest.getExecutionType() !\u003d null\n        \u0026\u0026 newSchedulingRequest.getExecutionType().getExecutionType()\n        !\u003d ExecutionType.GUARANTEED) {\n      throwExceptionWithMetaInfo(\n          \"Only GUARANTEED execution type is supported.\");\n    }\n\n    this.targetNodePartition \u003d validateAndGetTargetNodePartition(\n        newSchedulingRequest.getPlacementConstraint());\n    this.schedulingRequest \u003d new SchedulingRequestPBImpl(\n        ((SchedulingRequestPBImpl) newSchedulingRequest).getProto());\n\n\n    LOG.info(\"Successfully added SchedulingRequest to app\u003d\"\n        + appSchedulingInfo.getApplicationAttemptId()\n        + \" placementConstraint\u003d[\"\n        + schedulingRequest.getPlacementConstraint()\n        + \"]. nodePartition\u003d\" + targetNodePartition);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/placement/SingleConstraintAppPlacementAllocator.java",
      "extendedDetails": {}
    },
    "6468071f137e6d918a7b4799ad54558fa26b25ce": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8367. Fix NPE in SingleConstraintAppPlacementAllocator when placement constraint in SchedulingRequest is null. Contributed by Weiwei Yang.\n",
      "commitDate": "31/05/18 5:46 AM",
      "commitName": "6468071f137e6d918a7b4799ad54558fa26b25ce",
      "commitAuthor": "Weiwei Yang",
      "commitDateOld": "04/04/18 10:51 AM",
      "commitNameOld": "7853ec8d2fb8731b7f7c28fd87491a0a2d47967e",
      "commitAuthorOld": "Konstantinos Karanasos",
      "daysBetweenCommits": 56.79,
      "commitsBetweenForRepo": 930,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,141 +1,149 @@\n   private void validateAndSetSchedulingRequest(SchedulingRequest\n       newSchedulingRequest)\n       throws SchedulerInvalidResoureRequestException {\n     // Check sizing exists\n     if (newSchedulingRequest.getResourceSizing() \u003d\u003d null\n         || newSchedulingRequest.getResourceSizing().getResources() \u003d\u003d null) {\n       throwExceptionWithMetaInfo(\n           \"No ResourceSizing found in the scheduling request, please double \"\n               + \"check\");\n     }\n \n     // Check execution type \u003d\u003d GUARANTEED\n     if (newSchedulingRequest.getExecutionType() !\u003d null\n         \u0026\u0026 newSchedulingRequest.getExecutionType().getExecutionType()\n         !\u003d ExecutionType.GUARANTEED) {\n       throwExceptionWithMetaInfo(\n           \"Only GUARANTEED execution type is supported.\");\n     }\n \n-    PlacementConstraint constraint \u003d\n-        newSchedulingRequest.getPlacementConstraint();\n-\n-    // We only accept SingleConstraint\n-    PlacementConstraint.AbstractConstraint ac \u003d constraint.getConstraintExpr();\n-    if (!(ac instanceof PlacementConstraint.SingleConstraint)) {\n-      throwExceptionWithMetaInfo(\n-          \"Only accepts \" + PlacementConstraint.SingleConstraint.class.getName()\n-              + \" as constraint-expression. Rejecting the new added \"\n-              + \"constraint-expression.class\u003d\" + ac.getClass().getName());\n-    }\n-\n-    PlacementConstraint.SingleConstraint singleConstraint \u003d\n-        (PlacementConstraint.SingleConstraint) ac;\n-\n-    // Make sure it is an anti-affinity request (actually this implementation\n-    // should be able to support both affinity / anti-affinity without much\n-    // effort. Considering potential test effort required. Limit to\n-    // anti-affinity to intra-app and scope is node.\n-    if (!singleConstraint.getScope().equals(PlacementConstraints.NODE)) {\n-      throwExceptionWithMetaInfo(\n-          \"Only support scope\u003d\" + PlacementConstraints.NODE\n-              + \"now. PlacementConstraint\u003d\" + singleConstraint);\n-    }\n-\n-    if (singleConstraint.getMinCardinality() !\u003d 0\n-        || singleConstraint.getMaxCardinality() !\u003d 0) {\n-      throwExceptionWithMetaInfo(\n-          \"Only support anti-affinity, which is: minCardinality\u003d0, \"\n-              + \"maxCardinality\u003d1\");\n-    }\n-\n-    Set\u003cPlacementConstraint.TargetExpression\u003e targetExpressionSet \u003d\n-        singleConstraint.getTargetExpressions();\n-    if (targetExpressionSet \u003d\u003d null || targetExpressionSet.isEmpty()) {\n-      throwExceptionWithMetaInfo(\n-          \"TargetExpression should not be null or empty\");\n-    }\n-\n-    // Set node partition\n+    // Node partition\n     String nodePartition \u003d null;\n-\n     // Target allocation tags\n     Set\u003cString\u003e targetAllocationTags \u003d null;\n \n-    for (PlacementConstraint.TargetExpression targetExpression : targetExpressionSet) {\n-      // Handle node partition\n-      if (targetExpression.getTargetType().equals(\n-          PlacementConstraint.TargetExpression.TargetType.NODE_ATTRIBUTE)) {\n-        // For node attribute target, we only support Partition now. And once\n-        // YARN-3409 is merged, we will support node attribute.\n-        if (!targetExpression.getTargetKey().equals(NODE_PARTITION)) {\n-          throwExceptionWithMetaInfo(\"When TargetType\u003d\"\n-              + PlacementConstraint.TargetExpression.TargetType.NODE_ATTRIBUTE\n-              + \" only \" + NODE_PARTITION + \" is accepted as TargetKey.\");\n-        }\n+    PlacementConstraint constraint \u003d\n+        newSchedulingRequest.getPlacementConstraint();\n \n-        if (nodePartition !\u003d null) {\n-          // This means we have duplicated node partition entry inside placement\n-          // constraint, which might be set by mistake.\n-          throwExceptionWithMetaInfo(\n-              \"Only one node partition targetExpression is allowed\");\n-        }\n+    if (constraint !\u003d null) {\n+      // We only accept SingleConstraint\n+      PlacementConstraint.AbstractConstraint ac \u003d constraint\n+          .getConstraintExpr();\n+      if (!(ac instanceof PlacementConstraint.SingleConstraint)) {\n+        throwExceptionWithMetaInfo(\"Only accepts \"\n+            + PlacementConstraint.SingleConstraint.class.getName()\n+                + \" as constraint-expression. Rejecting the new added \"\n+            + \"constraint-expression.class\u003d\" + ac.getClass().getName());\n+      }\n \n-        Set\u003cString\u003e values \u003d targetExpression.getTargetValues();\n-        if (values \u003d\u003d null || values.isEmpty()) {\n-          nodePartition \u003d RMNodeLabelsManager.NO_LABEL;\n-          continue;\n-        }\n+      PlacementConstraint.SingleConstraint singleConstraint \u003d\n+          (PlacementConstraint.SingleConstraint) ac;\n \n-        if (values.size() \u003e 1) {\n-          throwExceptionWithMetaInfo(\"Inside one targetExpression, we only \"\n-              + \"support affinity to at most one node partition now\");\n-        }\n+      // Make sure it is an anti-affinity request (actually this implementation\n+      // should be able to support both affinity / anti-affinity without much\n+      // effort. Considering potential test effort required. Limit to\n+      // anti-affinity to intra-app and scope is node.\n+      if (!singleConstraint.getScope().equals(PlacementConstraints.NODE)) {\n+        throwExceptionWithMetaInfo(\n+            \"Only support scope\u003d\" + PlacementConstraints.NODE\n+                + \"now. PlacementConstraint\u003d\" + singleConstraint);\n+      }\n \n-        nodePartition \u003d values.iterator().next();\n-      } else if (targetExpression.getTargetType().equals(\n-          PlacementConstraint.TargetExpression.TargetType.ALLOCATION_TAG)) {\n-        // Handle allocation tags\n-        if (targetAllocationTags !\u003d null) {\n-          // This means we have duplicated AllocationTag expressions entries\n-          // inside placement constraint, which might be set by mistake.\n-          throwExceptionWithMetaInfo(\n-              \"Only one AllocationTag targetExpression is allowed\");\n-        }\n+      if (singleConstraint.getMinCardinality() !\u003d 0\n+          || singleConstraint.getMaxCardinality() !\u003d 0) {\n+        throwExceptionWithMetaInfo(\n+            \"Only support anti-affinity, which is: minCardinality\u003d0, \"\n+                + \"maxCardinality\u003d1\");\n+      }\n \n-        if (targetExpression.getTargetValues() \u003d\u003d null || targetExpression\n-            .getTargetValues().isEmpty()) {\n-          throwExceptionWithMetaInfo(\"Failed to find allocation tags from \"\n-              + \"TargetExpressions or couldn\u0027t find self-app target.\");\n-        }\n+      Set\u003cPlacementConstraint.TargetExpression\u003e targetExpressionSet \u003d\n+          singleConstraint.getTargetExpressions();\n+      if (targetExpressionSet \u003d\u003d null || targetExpressionSet.isEmpty()) {\n+        throwExceptionWithMetaInfo(\n+            \"TargetExpression should not be null or empty\");\n+      }\n \n-        targetAllocationTags \u003d new HashSet\u003c\u003e(\n-            targetExpression.getTargetValues());\n+      for (PlacementConstraint.TargetExpression targetExpression :\n+          targetExpressionSet) {\n+        // Handle node partition\n+        if (targetExpression.getTargetType().equals(\n+            PlacementConstraint.TargetExpression.TargetType.NODE_ATTRIBUTE)) {\n+          // For node attribute target, we only support Partition now. And once\n+          // YARN-3409 is merged, we will support node attribute.\n+          if (!targetExpression.getTargetKey().equals(NODE_PARTITION)) {\n+            throwExceptionWithMetaInfo(\"When TargetType\u003d\"\n+                + PlacementConstraint.TargetExpression.TargetType.NODE_ATTRIBUTE\n+                + \" only \" + NODE_PARTITION + \" is accepted as TargetKey.\");\n+          }\n+\n+          if (nodePartition !\u003d null) {\n+            // This means we have duplicated node partition entry\n+            // inside placement constraint, which might be set by mistake.\n+            throwExceptionWithMetaInfo(\n+                \"Only one node partition targetExpression is allowed\");\n+          }\n+\n+          Set\u003cString\u003e values \u003d targetExpression.getTargetValues();\n+          if (values \u003d\u003d null || values.isEmpty()) {\n+            nodePartition \u003d RMNodeLabelsManager.NO_LABEL;\n+            continue;\n+          }\n+\n+          if (values.size() \u003e 1) {\n+            throwExceptionWithMetaInfo(\"Inside one targetExpression, we only \"\n+                + \"support affinity to at most one node partition now\");\n+          }\n+\n+          nodePartition \u003d values.iterator().next();\n+        } else if (targetExpression.getTargetType().equals(\n+            PlacementConstraint.TargetExpression.TargetType.ALLOCATION_TAG)) {\n+          // Handle allocation tags\n+          if (targetAllocationTags !\u003d null) {\n+            // This means we have duplicated AllocationTag expressions entries\n+            // inside placement constraint, which might be set by mistake.\n+            throwExceptionWithMetaInfo(\n+                \"Only one AllocationTag targetExpression is allowed\");\n+          }\n+\n+          if (targetExpression.getTargetValues() \u003d\u003d null ||\n+              targetExpression.getTargetValues().isEmpty()) {\n+            throwExceptionWithMetaInfo(\"Failed to find allocation tags from \"\n+                + \"TargetExpressions or couldn\u0027t find self-app target.\");\n+          }\n+\n+          targetAllocationTags \u003d new HashSet\u003c\u003e(\n+              targetExpression.getTargetValues());\n+        }\n+      }\n+\n+      if (targetAllocationTags \u003d\u003d null) {\n+        // That means we don\u0027t have ALLOCATION_TAG specified\n+        throwExceptionWithMetaInfo(\n+            \"Couldn\u0027t find target expression with type \u003d\u003d ALLOCATION_TAG,\"\n+                + \" it is required to include one and only one target\"\n+                + \" expression with type \u003d\u003d ALLOCATION_TAG\");\n       }\n     }\n \n+    // If this scheduling request doesn\u0027t contain a placement constraint,\n+    // we set allocation tags an empty set.\n     if (targetAllocationTags \u003d\u003d null) {\n-      // That means we don\u0027t have ALLOCATION_TAG specified\n-      throwExceptionWithMetaInfo(\n-          \"Couldn\u0027t find target expression with type \u003d\u003d ALLOCATION_TAG, it is \"\n-              + \"required to include one and only one target expression with \"\n-              + \"type \u003d\u003d ALLOCATION_TAG\");\n-\n+      targetAllocationTags \u003d ImmutableSet.of();\n     }\n \n     if (nodePartition \u003d\u003d null) {\n       nodePartition \u003d RMNodeLabelsManager.NO_LABEL;\n     }\n \n     // Validation is done. set local results:\n     this.targetNodePartition \u003d nodePartition;\n     this.targetAllocationTags \u003d targetAllocationTags;\n \n     this.schedulingRequest \u003d new SchedulingRequestPBImpl(\n         ((SchedulingRequestPBImpl) newSchedulingRequest).getProto());\n \n     LOG.info(\"Successfully added SchedulingRequest to app\u003d\" + appSchedulingInfo\n         .getApplicationAttemptId() + \" targetAllocationTags\u003d[\" + StringUtils\n         .join(\",\", targetAllocationTags) + \"]. nodePartition\u003d\"\n         + targetNodePartition);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void validateAndSetSchedulingRequest(SchedulingRequest\n      newSchedulingRequest)\n      throws SchedulerInvalidResoureRequestException {\n    // Check sizing exists\n    if (newSchedulingRequest.getResourceSizing() \u003d\u003d null\n        || newSchedulingRequest.getResourceSizing().getResources() \u003d\u003d null) {\n      throwExceptionWithMetaInfo(\n          \"No ResourceSizing found in the scheduling request, please double \"\n              + \"check\");\n    }\n\n    // Check execution type \u003d\u003d GUARANTEED\n    if (newSchedulingRequest.getExecutionType() !\u003d null\n        \u0026\u0026 newSchedulingRequest.getExecutionType().getExecutionType()\n        !\u003d ExecutionType.GUARANTEED) {\n      throwExceptionWithMetaInfo(\n          \"Only GUARANTEED execution type is supported.\");\n    }\n\n    // Node partition\n    String nodePartition \u003d null;\n    // Target allocation tags\n    Set\u003cString\u003e targetAllocationTags \u003d null;\n\n    PlacementConstraint constraint \u003d\n        newSchedulingRequest.getPlacementConstraint();\n\n    if (constraint !\u003d null) {\n      // We only accept SingleConstraint\n      PlacementConstraint.AbstractConstraint ac \u003d constraint\n          .getConstraintExpr();\n      if (!(ac instanceof PlacementConstraint.SingleConstraint)) {\n        throwExceptionWithMetaInfo(\"Only accepts \"\n            + PlacementConstraint.SingleConstraint.class.getName()\n                + \" as constraint-expression. Rejecting the new added \"\n            + \"constraint-expression.class\u003d\" + ac.getClass().getName());\n      }\n\n      PlacementConstraint.SingleConstraint singleConstraint \u003d\n          (PlacementConstraint.SingleConstraint) ac;\n\n      // Make sure it is an anti-affinity request (actually this implementation\n      // should be able to support both affinity / anti-affinity without much\n      // effort. Considering potential test effort required. Limit to\n      // anti-affinity to intra-app and scope is node.\n      if (!singleConstraint.getScope().equals(PlacementConstraints.NODE)) {\n        throwExceptionWithMetaInfo(\n            \"Only support scope\u003d\" + PlacementConstraints.NODE\n                + \"now. PlacementConstraint\u003d\" + singleConstraint);\n      }\n\n      if (singleConstraint.getMinCardinality() !\u003d 0\n          || singleConstraint.getMaxCardinality() !\u003d 0) {\n        throwExceptionWithMetaInfo(\n            \"Only support anti-affinity, which is: minCardinality\u003d0, \"\n                + \"maxCardinality\u003d1\");\n      }\n\n      Set\u003cPlacementConstraint.TargetExpression\u003e targetExpressionSet \u003d\n          singleConstraint.getTargetExpressions();\n      if (targetExpressionSet \u003d\u003d null || targetExpressionSet.isEmpty()) {\n        throwExceptionWithMetaInfo(\n            \"TargetExpression should not be null or empty\");\n      }\n\n      for (PlacementConstraint.TargetExpression targetExpression :\n          targetExpressionSet) {\n        // Handle node partition\n        if (targetExpression.getTargetType().equals(\n            PlacementConstraint.TargetExpression.TargetType.NODE_ATTRIBUTE)) {\n          // For node attribute target, we only support Partition now. And once\n          // YARN-3409 is merged, we will support node attribute.\n          if (!targetExpression.getTargetKey().equals(NODE_PARTITION)) {\n            throwExceptionWithMetaInfo(\"When TargetType\u003d\"\n                + PlacementConstraint.TargetExpression.TargetType.NODE_ATTRIBUTE\n                + \" only \" + NODE_PARTITION + \" is accepted as TargetKey.\");\n          }\n\n          if (nodePartition !\u003d null) {\n            // This means we have duplicated node partition entry\n            // inside placement constraint, which might be set by mistake.\n            throwExceptionWithMetaInfo(\n                \"Only one node partition targetExpression is allowed\");\n          }\n\n          Set\u003cString\u003e values \u003d targetExpression.getTargetValues();\n          if (values \u003d\u003d null || values.isEmpty()) {\n            nodePartition \u003d RMNodeLabelsManager.NO_LABEL;\n            continue;\n          }\n\n          if (values.size() \u003e 1) {\n            throwExceptionWithMetaInfo(\"Inside one targetExpression, we only \"\n                + \"support affinity to at most one node partition now\");\n          }\n\n          nodePartition \u003d values.iterator().next();\n        } else if (targetExpression.getTargetType().equals(\n            PlacementConstraint.TargetExpression.TargetType.ALLOCATION_TAG)) {\n          // Handle allocation tags\n          if (targetAllocationTags !\u003d null) {\n            // This means we have duplicated AllocationTag expressions entries\n            // inside placement constraint, which might be set by mistake.\n            throwExceptionWithMetaInfo(\n                \"Only one AllocationTag targetExpression is allowed\");\n          }\n\n          if (targetExpression.getTargetValues() \u003d\u003d null ||\n              targetExpression.getTargetValues().isEmpty()) {\n            throwExceptionWithMetaInfo(\"Failed to find allocation tags from \"\n                + \"TargetExpressions or couldn\u0027t find self-app target.\");\n          }\n\n          targetAllocationTags \u003d new HashSet\u003c\u003e(\n              targetExpression.getTargetValues());\n        }\n      }\n\n      if (targetAllocationTags \u003d\u003d null) {\n        // That means we don\u0027t have ALLOCATION_TAG specified\n        throwExceptionWithMetaInfo(\n            \"Couldn\u0027t find target expression with type \u003d\u003d ALLOCATION_TAG,\"\n                + \" it is required to include one and only one target\"\n                + \" expression with type \u003d\u003d ALLOCATION_TAG\");\n      }\n    }\n\n    // If this scheduling request doesn\u0027t contain a placement constraint,\n    // we set allocation tags an empty set.\n    if (targetAllocationTags \u003d\u003d null) {\n      targetAllocationTags \u003d ImmutableSet.of();\n    }\n\n    if (nodePartition \u003d\u003d null) {\n      nodePartition \u003d RMNodeLabelsManager.NO_LABEL;\n    }\n\n    // Validation is done. set local results:\n    this.targetNodePartition \u003d nodePartition;\n    this.targetAllocationTags \u003d targetAllocationTags;\n\n    this.schedulingRequest \u003d new SchedulingRequestPBImpl(\n        ((SchedulingRequestPBImpl) newSchedulingRequest).getProto());\n\n    LOG.info(\"Successfully added SchedulingRequest to app\u003d\" + appSchedulingInfo\n        .getApplicationAttemptId() + \" targetAllocationTags\u003d[\" + StringUtils\n        .join(\",\", targetAllocationTags) + \"]. nodePartition\u003d\"\n        + targetNodePartition);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/placement/SingleConstraintAppPlacementAllocator.java",
      "extendedDetails": {}
    },
    "7853ec8d2fb8731b7f7c28fd87491a0a2d47967e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8013. Support application tags when defining application namespaces for placement constraints. Contributed by Weiwei Yang.\n",
      "commitDate": "04/04/18 10:51 AM",
      "commitName": "7853ec8d2fb8731b7f7c28fd87491a0a2d47967e",
      "commitAuthor": "Konstantinos Karanasos",
      "commitDateOld": "19/03/18 11:04 AM",
      "commitNameOld": "a08921ca6cb1dad98935808c8f474b654f861263",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 15.99,
      "commitsBetweenForRepo": 226,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,160 +1,141 @@\n   private void validateAndSetSchedulingRequest(SchedulingRequest\n       newSchedulingRequest)\n       throws SchedulerInvalidResoureRequestException {\n     // Check sizing exists\n     if (newSchedulingRequest.getResourceSizing() \u003d\u003d null\n         || newSchedulingRequest.getResourceSizing().getResources() \u003d\u003d null) {\n       throwExceptionWithMetaInfo(\n           \"No ResourceSizing found in the scheduling request, please double \"\n               + \"check\");\n     }\n \n     // Check execution type \u003d\u003d GUARANTEED\n     if (newSchedulingRequest.getExecutionType() !\u003d null\n         \u0026\u0026 newSchedulingRequest.getExecutionType().getExecutionType()\n         !\u003d ExecutionType.GUARANTEED) {\n       throwExceptionWithMetaInfo(\n           \"Only GUARANTEED execution type is supported.\");\n     }\n \n     PlacementConstraint constraint \u003d\n         newSchedulingRequest.getPlacementConstraint();\n \n     // We only accept SingleConstraint\n     PlacementConstraint.AbstractConstraint ac \u003d constraint.getConstraintExpr();\n     if (!(ac instanceof PlacementConstraint.SingleConstraint)) {\n       throwExceptionWithMetaInfo(\n           \"Only accepts \" + PlacementConstraint.SingleConstraint.class.getName()\n               + \" as constraint-expression. Rejecting the new added \"\n               + \"constraint-expression.class\u003d\" + ac.getClass().getName());\n     }\n \n     PlacementConstraint.SingleConstraint singleConstraint \u003d\n         (PlacementConstraint.SingleConstraint) ac;\n \n     // Make sure it is an anti-affinity request (actually this implementation\n     // should be able to support both affinity / anti-affinity without much\n     // effort. Considering potential test effort required. Limit to\n     // anti-affinity to intra-app and scope is node.\n     if (!singleConstraint.getScope().equals(PlacementConstraints.NODE)) {\n       throwExceptionWithMetaInfo(\n           \"Only support scope\u003d\" + PlacementConstraints.NODE\n               + \"now. PlacementConstraint\u003d\" + singleConstraint);\n     }\n \n     if (singleConstraint.getMinCardinality() !\u003d 0\n         || singleConstraint.getMaxCardinality() !\u003d 0) {\n       throwExceptionWithMetaInfo(\n           \"Only support anti-affinity, which is: minCardinality\u003d0, \"\n               + \"maxCardinality\u003d1\");\n     }\n \n     Set\u003cPlacementConstraint.TargetExpression\u003e targetExpressionSet \u003d\n         singleConstraint.getTargetExpressions();\n     if (targetExpressionSet \u003d\u003d null || targetExpressionSet.isEmpty()) {\n       throwExceptionWithMetaInfo(\n           \"TargetExpression should not be null or empty\");\n     }\n \n     // Set node partition\n     String nodePartition \u003d null;\n \n     // Target allocation tags\n     Set\u003cString\u003e targetAllocationTags \u003d null;\n \n     for (PlacementConstraint.TargetExpression targetExpression : targetExpressionSet) {\n       // Handle node partition\n       if (targetExpression.getTargetType().equals(\n           PlacementConstraint.TargetExpression.TargetType.NODE_ATTRIBUTE)) {\n         // For node attribute target, we only support Partition now. And once\n         // YARN-3409 is merged, we will support node attribute.\n         if (!targetExpression.getTargetKey().equals(NODE_PARTITION)) {\n           throwExceptionWithMetaInfo(\"When TargetType\u003d\"\n               + PlacementConstraint.TargetExpression.TargetType.NODE_ATTRIBUTE\n               + \" only \" + NODE_PARTITION + \" is accepted as TargetKey.\");\n         }\n \n         if (nodePartition !\u003d null) {\n           // This means we have duplicated node partition entry inside placement\n           // constraint, which might be set by mistake.\n           throwExceptionWithMetaInfo(\n               \"Only one node partition targetExpression is allowed\");\n         }\n \n         Set\u003cString\u003e values \u003d targetExpression.getTargetValues();\n         if (values \u003d\u003d null || values.isEmpty()) {\n           nodePartition \u003d RMNodeLabelsManager.NO_LABEL;\n           continue;\n         }\n \n         if (values.size() \u003e 1) {\n           throwExceptionWithMetaInfo(\"Inside one targetExpression, we only \"\n               + \"support affinity to at most one node partition now\");\n         }\n \n         nodePartition \u003d values.iterator().next();\n       } else if (targetExpression.getTargetType().equals(\n           PlacementConstraint.TargetExpression.TargetType.ALLOCATION_TAG)) {\n         // Handle allocation tags\n         if (targetAllocationTags !\u003d null) {\n           // This means we have duplicated AllocationTag expressions entries\n           // inside placement constraint, which might be set by mistake.\n           throwExceptionWithMetaInfo(\n               \"Only one AllocationTag targetExpression is allowed\");\n         }\n \n         if (targetExpression.getTargetValues() \u003d\u003d null || targetExpression\n             .getTargetValues().isEmpty()) {\n           throwExceptionWithMetaInfo(\"Failed to find allocation tags from \"\n               + \"TargetExpressions or couldn\u0027t find self-app target.\");\n         }\n \n         targetAllocationTags \u003d new HashSet\u003c\u003e(\n             targetExpression.getTargetValues());\n-\n-        try {\n-          AllocationTagNamespace tagNS \u003d\n-              AllocationTagNamespace.parse(targetExpression.getTargetKey());\n-          if (AllocationTagNamespaceType.APP_LABEL\n-              .equals(tagNS.getNamespaceType())) {\n-            throwExceptionWithMetaInfo(\n-                \"As of now, allocation tag namespace [\"\n-                    + AllocationTagNamespaceType.APP_LABEL.toString()\n-                    + \"] is not supported. Please make changes to placement \"\n-                    + \"constraints accordingly. If this is null, it will be \"\n-                    + \"set to \"\n-                    + AllocationTagNamespaceType.SELF.toString()\n-                    + \" by default.\");\n-          }\n-        } catch (InvalidAllocationTagsQueryException e) {\n-          throwExceptionWithMetaInfo(\n-              \"Invalid allocation tag namespace, message: \" + e.getMessage());\n-        }\n       }\n     }\n \n     if (targetAllocationTags \u003d\u003d null) {\n       // That means we don\u0027t have ALLOCATION_TAG specified\n       throwExceptionWithMetaInfo(\n           \"Couldn\u0027t find target expression with type \u003d\u003d ALLOCATION_TAG, it is \"\n               + \"required to include one and only one target expression with \"\n               + \"type \u003d\u003d ALLOCATION_TAG\");\n \n     }\n \n     if (nodePartition \u003d\u003d null) {\n       nodePartition \u003d RMNodeLabelsManager.NO_LABEL;\n     }\n \n     // Validation is done. set local results:\n     this.targetNodePartition \u003d nodePartition;\n     this.targetAllocationTags \u003d targetAllocationTags;\n \n     this.schedulingRequest \u003d new SchedulingRequestPBImpl(\n         ((SchedulingRequestPBImpl) newSchedulingRequest).getProto());\n \n     LOG.info(\"Successfully added SchedulingRequest to app\u003d\" + appSchedulingInfo\n         .getApplicationAttemptId() + \" targetAllocationTags\u003d[\" + StringUtils\n         .join(\",\", targetAllocationTags) + \"]. nodePartition\u003d\"\n         + targetNodePartition);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void validateAndSetSchedulingRequest(SchedulingRequest\n      newSchedulingRequest)\n      throws SchedulerInvalidResoureRequestException {\n    // Check sizing exists\n    if (newSchedulingRequest.getResourceSizing() \u003d\u003d null\n        || newSchedulingRequest.getResourceSizing().getResources() \u003d\u003d null) {\n      throwExceptionWithMetaInfo(\n          \"No ResourceSizing found in the scheduling request, please double \"\n              + \"check\");\n    }\n\n    // Check execution type \u003d\u003d GUARANTEED\n    if (newSchedulingRequest.getExecutionType() !\u003d null\n        \u0026\u0026 newSchedulingRequest.getExecutionType().getExecutionType()\n        !\u003d ExecutionType.GUARANTEED) {\n      throwExceptionWithMetaInfo(\n          \"Only GUARANTEED execution type is supported.\");\n    }\n\n    PlacementConstraint constraint \u003d\n        newSchedulingRequest.getPlacementConstraint();\n\n    // We only accept SingleConstraint\n    PlacementConstraint.AbstractConstraint ac \u003d constraint.getConstraintExpr();\n    if (!(ac instanceof PlacementConstraint.SingleConstraint)) {\n      throwExceptionWithMetaInfo(\n          \"Only accepts \" + PlacementConstraint.SingleConstraint.class.getName()\n              + \" as constraint-expression. Rejecting the new added \"\n              + \"constraint-expression.class\u003d\" + ac.getClass().getName());\n    }\n\n    PlacementConstraint.SingleConstraint singleConstraint \u003d\n        (PlacementConstraint.SingleConstraint) ac;\n\n    // Make sure it is an anti-affinity request (actually this implementation\n    // should be able to support both affinity / anti-affinity without much\n    // effort. Considering potential test effort required. Limit to\n    // anti-affinity to intra-app and scope is node.\n    if (!singleConstraint.getScope().equals(PlacementConstraints.NODE)) {\n      throwExceptionWithMetaInfo(\n          \"Only support scope\u003d\" + PlacementConstraints.NODE\n              + \"now. PlacementConstraint\u003d\" + singleConstraint);\n    }\n\n    if (singleConstraint.getMinCardinality() !\u003d 0\n        || singleConstraint.getMaxCardinality() !\u003d 0) {\n      throwExceptionWithMetaInfo(\n          \"Only support anti-affinity, which is: minCardinality\u003d0, \"\n              + \"maxCardinality\u003d1\");\n    }\n\n    Set\u003cPlacementConstraint.TargetExpression\u003e targetExpressionSet \u003d\n        singleConstraint.getTargetExpressions();\n    if (targetExpressionSet \u003d\u003d null || targetExpressionSet.isEmpty()) {\n      throwExceptionWithMetaInfo(\n          \"TargetExpression should not be null or empty\");\n    }\n\n    // Set node partition\n    String nodePartition \u003d null;\n\n    // Target allocation tags\n    Set\u003cString\u003e targetAllocationTags \u003d null;\n\n    for (PlacementConstraint.TargetExpression targetExpression : targetExpressionSet) {\n      // Handle node partition\n      if (targetExpression.getTargetType().equals(\n          PlacementConstraint.TargetExpression.TargetType.NODE_ATTRIBUTE)) {\n        // For node attribute target, we only support Partition now. And once\n        // YARN-3409 is merged, we will support node attribute.\n        if (!targetExpression.getTargetKey().equals(NODE_PARTITION)) {\n          throwExceptionWithMetaInfo(\"When TargetType\u003d\"\n              + PlacementConstraint.TargetExpression.TargetType.NODE_ATTRIBUTE\n              + \" only \" + NODE_PARTITION + \" is accepted as TargetKey.\");\n        }\n\n        if (nodePartition !\u003d null) {\n          // This means we have duplicated node partition entry inside placement\n          // constraint, which might be set by mistake.\n          throwExceptionWithMetaInfo(\n              \"Only one node partition targetExpression is allowed\");\n        }\n\n        Set\u003cString\u003e values \u003d targetExpression.getTargetValues();\n        if (values \u003d\u003d null || values.isEmpty()) {\n          nodePartition \u003d RMNodeLabelsManager.NO_LABEL;\n          continue;\n        }\n\n        if (values.size() \u003e 1) {\n          throwExceptionWithMetaInfo(\"Inside one targetExpression, we only \"\n              + \"support affinity to at most one node partition now\");\n        }\n\n        nodePartition \u003d values.iterator().next();\n      } else if (targetExpression.getTargetType().equals(\n          PlacementConstraint.TargetExpression.TargetType.ALLOCATION_TAG)) {\n        // Handle allocation tags\n        if (targetAllocationTags !\u003d null) {\n          // This means we have duplicated AllocationTag expressions entries\n          // inside placement constraint, which might be set by mistake.\n          throwExceptionWithMetaInfo(\n              \"Only one AllocationTag targetExpression is allowed\");\n        }\n\n        if (targetExpression.getTargetValues() \u003d\u003d null || targetExpression\n            .getTargetValues().isEmpty()) {\n          throwExceptionWithMetaInfo(\"Failed to find allocation tags from \"\n              + \"TargetExpressions or couldn\u0027t find self-app target.\");\n        }\n\n        targetAllocationTags \u003d new HashSet\u003c\u003e(\n            targetExpression.getTargetValues());\n      }\n    }\n\n    if (targetAllocationTags \u003d\u003d null) {\n      // That means we don\u0027t have ALLOCATION_TAG specified\n      throwExceptionWithMetaInfo(\n          \"Couldn\u0027t find target expression with type \u003d\u003d ALLOCATION_TAG, it is \"\n              + \"required to include one and only one target expression with \"\n              + \"type \u003d\u003d ALLOCATION_TAG\");\n\n    }\n\n    if (nodePartition \u003d\u003d null) {\n      nodePartition \u003d RMNodeLabelsManager.NO_LABEL;\n    }\n\n    // Validation is done. set local results:\n    this.targetNodePartition \u003d nodePartition;\n    this.targetAllocationTags \u003d targetAllocationTags;\n\n    this.schedulingRequest \u003d new SchedulingRequestPBImpl(\n        ((SchedulingRequestPBImpl) newSchedulingRequest).getProto());\n\n    LOG.info(\"Successfully added SchedulingRequest to app\u003d\" + appSchedulingInfo\n        .getApplicationAttemptId() + \" targetAllocationTags\u003d[\" + StringUtils\n        .join(\",\", targetAllocationTags) + \"]. nodePartition\u003d\"\n        + targetNodePartition);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/placement/SingleConstraintAppPlacementAllocator.java",
      "extendedDetails": {}
    },
    "a08921ca6cb1dad98935808c8f474b654f861263": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8002. Support NOT_SELF and ALL namespace types for allocation tag. (Weiwei Yang via wangda)\n\nChange-Id: I63b4e4192a95bf7ded98c54e46a2871c72869700\n",
      "commitDate": "19/03/18 11:04 AM",
      "commitName": "a08921ca6cb1dad98935808c8f474b654f861263",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "05/03/18 11:24 AM",
      "commitNameOld": "1054b48c27f3158110bd0512afecded36eecb8ad",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 13.94,
      "commitsBetweenForRepo": 103,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,160 +1,160 @@\n   private void validateAndSetSchedulingRequest(SchedulingRequest\n       newSchedulingRequest)\n       throws SchedulerInvalidResoureRequestException {\n     // Check sizing exists\n     if (newSchedulingRequest.getResourceSizing() \u003d\u003d null\n         || newSchedulingRequest.getResourceSizing().getResources() \u003d\u003d null) {\n       throwExceptionWithMetaInfo(\n           \"No ResourceSizing found in the scheduling request, please double \"\n               + \"check\");\n     }\n \n     // Check execution type \u003d\u003d GUARANTEED\n     if (newSchedulingRequest.getExecutionType() !\u003d null\n         \u0026\u0026 newSchedulingRequest.getExecutionType().getExecutionType()\n         !\u003d ExecutionType.GUARANTEED) {\n       throwExceptionWithMetaInfo(\n           \"Only GUARANTEED execution type is supported.\");\n     }\n \n     PlacementConstraint constraint \u003d\n         newSchedulingRequest.getPlacementConstraint();\n \n     // We only accept SingleConstraint\n     PlacementConstraint.AbstractConstraint ac \u003d constraint.getConstraintExpr();\n     if (!(ac instanceof PlacementConstraint.SingleConstraint)) {\n       throwExceptionWithMetaInfo(\n           \"Only accepts \" + PlacementConstraint.SingleConstraint.class.getName()\n               + \" as constraint-expression. Rejecting the new added \"\n               + \"constraint-expression.class\u003d\" + ac.getClass().getName());\n     }\n \n     PlacementConstraint.SingleConstraint singleConstraint \u003d\n         (PlacementConstraint.SingleConstraint) ac;\n \n     // Make sure it is an anti-affinity request (actually this implementation\n     // should be able to support both affinity / anti-affinity without much\n     // effort. Considering potential test effort required. Limit to\n     // anti-affinity to intra-app and scope is node.\n     if (!singleConstraint.getScope().equals(PlacementConstraints.NODE)) {\n       throwExceptionWithMetaInfo(\n           \"Only support scope\u003d\" + PlacementConstraints.NODE\n               + \"now. PlacementConstraint\u003d\" + singleConstraint);\n     }\n \n     if (singleConstraint.getMinCardinality() !\u003d 0\n         || singleConstraint.getMaxCardinality() !\u003d 0) {\n       throwExceptionWithMetaInfo(\n           \"Only support anti-affinity, which is: minCardinality\u003d0, \"\n               + \"maxCardinality\u003d1\");\n     }\n \n     Set\u003cPlacementConstraint.TargetExpression\u003e targetExpressionSet \u003d\n         singleConstraint.getTargetExpressions();\n     if (targetExpressionSet \u003d\u003d null || targetExpressionSet.isEmpty()) {\n       throwExceptionWithMetaInfo(\n           \"TargetExpression should not be null or empty\");\n     }\n \n     // Set node partition\n     String nodePartition \u003d null;\n \n     // Target allocation tags\n     Set\u003cString\u003e targetAllocationTags \u003d null;\n \n     for (PlacementConstraint.TargetExpression targetExpression : targetExpressionSet) {\n       // Handle node partition\n       if (targetExpression.getTargetType().equals(\n           PlacementConstraint.TargetExpression.TargetType.NODE_ATTRIBUTE)) {\n         // For node attribute target, we only support Partition now. And once\n         // YARN-3409 is merged, we will support node attribute.\n         if (!targetExpression.getTargetKey().equals(NODE_PARTITION)) {\n           throwExceptionWithMetaInfo(\"When TargetType\u003d\"\n               + PlacementConstraint.TargetExpression.TargetType.NODE_ATTRIBUTE\n               + \" only \" + NODE_PARTITION + \" is accepted as TargetKey.\");\n         }\n \n         if (nodePartition !\u003d null) {\n           // This means we have duplicated node partition entry inside placement\n           // constraint, which might be set by mistake.\n           throwExceptionWithMetaInfo(\n               \"Only one node partition targetExpression is allowed\");\n         }\n \n         Set\u003cString\u003e values \u003d targetExpression.getTargetValues();\n         if (values \u003d\u003d null || values.isEmpty()) {\n           nodePartition \u003d RMNodeLabelsManager.NO_LABEL;\n           continue;\n         }\n \n         if (values.size() \u003e 1) {\n           throwExceptionWithMetaInfo(\"Inside one targetExpression, we only \"\n               + \"support affinity to at most one node partition now\");\n         }\n \n         nodePartition \u003d values.iterator().next();\n       } else if (targetExpression.getTargetType().equals(\n           PlacementConstraint.TargetExpression.TargetType.ALLOCATION_TAG)) {\n         // Handle allocation tags\n         if (targetAllocationTags !\u003d null) {\n           // This means we have duplicated AllocationTag expressions entries\n           // inside placement constraint, which might be set by mistake.\n           throwExceptionWithMetaInfo(\n               \"Only one AllocationTag targetExpression is allowed\");\n         }\n \n         if (targetExpression.getTargetValues() \u003d\u003d null || targetExpression\n             .getTargetValues().isEmpty()) {\n           throwExceptionWithMetaInfo(\"Failed to find allocation tags from \"\n               + \"TargetExpressions or couldn\u0027t find self-app target.\");\n         }\n \n         targetAllocationTags \u003d new HashSet\u003c\u003e(\n             targetExpression.getTargetValues());\n \n         try {\n           AllocationTagNamespace tagNS \u003d\n               AllocationTagNamespace.parse(targetExpression.getTargetKey());\n-          if (!AllocationTagNamespaceType.SELF\n+          if (AllocationTagNamespaceType.APP_LABEL\n               .equals(tagNS.getNamespaceType())) {\n             throwExceptionWithMetaInfo(\n-                \"As of now, the only accepted target key for targetKey of \"\n-                    + \"allocation_tag target expression is: [\"\n-                    + AllocationTagNamespaceType.SELF.toString()\n-                    + \"]. Please make changes to placement constraints \"\n-                    + \"accordingly. If this is null, it will be set to \"\n+                \"As of now, allocation tag namespace [\"\n+                    + AllocationTagNamespaceType.APP_LABEL.toString()\n+                    + \"] is not supported. Please make changes to placement \"\n+                    + \"constraints accordingly. If this is null, it will be \"\n+                    + \"set to \"\n                     + AllocationTagNamespaceType.SELF.toString()\n                     + \" by default.\");\n           }\n-        } catch (InvalidAllocationTagException e) {\n+        } catch (InvalidAllocationTagsQueryException e) {\n           throwExceptionWithMetaInfo(\n               \"Invalid allocation tag namespace, message: \" + e.getMessage());\n         }\n       }\n     }\n \n     if (targetAllocationTags \u003d\u003d null) {\n       // That means we don\u0027t have ALLOCATION_TAG specified\n       throwExceptionWithMetaInfo(\n           \"Couldn\u0027t find target expression with type \u003d\u003d ALLOCATION_TAG, it is \"\n               + \"required to include one and only one target expression with \"\n               + \"type \u003d\u003d ALLOCATION_TAG\");\n \n     }\n \n     if (nodePartition \u003d\u003d null) {\n       nodePartition \u003d RMNodeLabelsManager.NO_LABEL;\n     }\n \n     // Validation is done. set local results:\n     this.targetNodePartition \u003d nodePartition;\n     this.targetAllocationTags \u003d targetAllocationTags;\n \n     this.schedulingRequest \u003d new SchedulingRequestPBImpl(\n         ((SchedulingRequestPBImpl) newSchedulingRequest).getProto());\n \n     LOG.info(\"Successfully added SchedulingRequest to app\u003d\" + appSchedulingInfo\n         .getApplicationAttemptId() + \" targetAllocationTags\u003d[\" + StringUtils\n         .join(\",\", targetAllocationTags) + \"]. nodePartition\u003d\"\n         + targetNodePartition);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void validateAndSetSchedulingRequest(SchedulingRequest\n      newSchedulingRequest)\n      throws SchedulerInvalidResoureRequestException {\n    // Check sizing exists\n    if (newSchedulingRequest.getResourceSizing() \u003d\u003d null\n        || newSchedulingRequest.getResourceSizing().getResources() \u003d\u003d null) {\n      throwExceptionWithMetaInfo(\n          \"No ResourceSizing found in the scheduling request, please double \"\n              + \"check\");\n    }\n\n    // Check execution type \u003d\u003d GUARANTEED\n    if (newSchedulingRequest.getExecutionType() !\u003d null\n        \u0026\u0026 newSchedulingRequest.getExecutionType().getExecutionType()\n        !\u003d ExecutionType.GUARANTEED) {\n      throwExceptionWithMetaInfo(\n          \"Only GUARANTEED execution type is supported.\");\n    }\n\n    PlacementConstraint constraint \u003d\n        newSchedulingRequest.getPlacementConstraint();\n\n    // We only accept SingleConstraint\n    PlacementConstraint.AbstractConstraint ac \u003d constraint.getConstraintExpr();\n    if (!(ac instanceof PlacementConstraint.SingleConstraint)) {\n      throwExceptionWithMetaInfo(\n          \"Only accepts \" + PlacementConstraint.SingleConstraint.class.getName()\n              + \" as constraint-expression. Rejecting the new added \"\n              + \"constraint-expression.class\u003d\" + ac.getClass().getName());\n    }\n\n    PlacementConstraint.SingleConstraint singleConstraint \u003d\n        (PlacementConstraint.SingleConstraint) ac;\n\n    // Make sure it is an anti-affinity request (actually this implementation\n    // should be able to support both affinity / anti-affinity without much\n    // effort. Considering potential test effort required. Limit to\n    // anti-affinity to intra-app and scope is node.\n    if (!singleConstraint.getScope().equals(PlacementConstraints.NODE)) {\n      throwExceptionWithMetaInfo(\n          \"Only support scope\u003d\" + PlacementConstraints.NODE\n              + \"now. PlacementConstraint\u003d\" + singleConstraint);\n    }\n\n    if (singleConstraint.getMinCardinality() !\u003d 0\n        || singleConstraint.getMaxCardinality() !\u003d 0) {\n      throwExceptionWithMetaInfo(\n          \"Only support anti-affinity, which is: minCardinality\u003d0, \"\n              + \"maxCardinality\u003d1\");\n    }\n\n    Set\u003cPlacementConstraint.TargetExpression\u003e targetExpressionSet \u003d\n        singleConstraint.getTargetExpressions();\n    if (targetExpressionSet \u003d\u003d null || targetExpressionSet.isEmpty()) {\n      throwExceptionWithMetaInfo(\n          \"TargetExpression should not be null or empty\");\n    }\n\n    // Set node partition\n    String nodePartition \u003d null;\n\n    // Target allocation tags\n    Set\u003cString\u003e targetAllocationTags \u003d null;\n\n    for (PlacementConstraint.TargetExpression targetExpression : targetExpressionSet) {\n      // Handle node partition\n      if (targetExpression.getTargetType().equals(\n          PlacementConstraint.TargetExpression.TargetType.NODE_ATTRIBUTE)) {\n        // For node attribute target, we only support Partition now. And once\n        // YARN-3409 is merged, we will support node attribute.\n        if (!targetExpression.getTargetKey().equals(NODE_PARTITION)) {\n          throwExceptionWithMetaInfo(\"When TargetType\u003d\"\n              + PlacementConstraint.TargetExpression.TargetType.NODE_ATTRIBUTE\n              + \" only \" + NODE_PARTITION + \" is accepted as TargetKey.\");\n        }\n\n        if (nodePartition !\u003d null) {\n          // This means we have duplicated node partition entry inside placement\n          // constraint, which might be set by mistake.\n          throwExceptionWithMetaInfo(\n              \"Only one node partition targetExpression is allowed\");\n        }\n\n        Set\u003cString\u003e values \u003d targetExpression.getTargetValues();\n        if (values \u003d\u003d null || values.isEmpty()) {\n          nodePartition \u003d RMNodeLabelsManager.NO_LABEL;\n          continue;\n        }\n\n        if (values.size() \u003e 1) {\n          throwExceptionWithMetaInfo(\"Inside one targetExpression, we only \"\n              + \"support affinity to at most one node partition now\");\n        }\n\n        nodePartition \u003d values.iterator().next();\n      } else if (targetExpression.getTargetType().equals(\n          PlacementConstraint.TargetExpression.TargetType.ALLOCATION_TAG)) {\n        // Handle allocation tags\n        if (targetAllocationTags !\u003d null) {\n          // This means we have duplicated AllocationTag expressions entries\n          // inside placement constraint, which might be set by mistake.\n          throwExceptionWithMetaInfo(\n              \"Only one AllocationTag targetExpression is allowed\");\n        }\n\n        if (targetExpression.getTargetValues() \u003d\u003d null || targetExpression\n            .getTargetValues().isEmpty()) {\n          throwExceptionWithMetaInfo(\"Failed to find allocation tags from \"\n              + \"TargetExpressions or couldn\u0027t find self-app target.\");\n        }\n\n        targetAllocationTags \u003d new HashSet\u003c\u003e(\n            targetExpression.getTargetValues());\n\n        try {\n          AllocationTagNamespace tagNS \u003d\n              AllocationTagNamespace.parse(targetExpression.getTargetKey());\n          if (AllocationTagNamespaceType.APP_LABEL\n              .equals(tagNS.getNamespaceType())) {\n            throwExceptionWithMetaInfo(\n                \"As of now, allocation tag namespace [\"\n                    + AllocationTagNamespaceType.APP_LABEL.toString()\n                    + \"] is not supported. Please make changes to placement \"\n                    + \"constraints accordingly. If this is null, it will be \"\n                    + \"set to \"\n                    + AllocationTagNamespaceType.SELF.toString()\n                    + \" by default.\");\n          }\n        } catch (InvalidAllocationTagsQueryException e) {\n          throwExceptionWithMetaInfo(\n              \"Invalid allocation tag namespace, message: \" + e.getMessage());\n        }\n      }\n    }\n\n    if (targetAllocationTags \u003d\u003d null) {\n      // That means we don\u0027t have ALLOCATION_TAG specified\n      throwExceptionWithMetaInfo(\n          \"Couldn\u0027t find target expression with type \u003d\u003d ALLOCATION_TAG, it is \"\n              + \"required to include one and only one target expression with \"\n              + \"type \u003d\u003d ALLOCATION_TAG\");\n\n    }\n\n    if (nodePartition \u003d\u003d null) {\n      nodePartition \u003d RMNodeLabelsManager.NO_LABEL;\n    }\n\n    // Validation is done. set local results:\n    this.targetNodePartition \u003d nodePartition;\n    this.targetAllocationTags \u003d targetAllocationTags;\n\n    this.schedulingRequest \u003d new SchedulingRequestPBImpl(\n        ((SchedulingRequestPBImpl) newSchedulingRequest).getProto());\n\n    LOG.info(\"Successfully added SchedulingRequest to app\u003d\" + appSchedulingInfo\n        .getApplicationAttemptId() + \" targetAllocationTags\u003d[\" + StringUtils\n        .join(\",\", targetAllocationTags) + \"]. nodePartition\u003d\"\n        + targetNodePartition);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/placement/SingleConstraintAppPlacementAllocator.java",
      "extendedDetails": {}
    },
    "1054b48c27f3158110bd0512afecded36eecb8ad": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7972. Support inter-app placement constraints for allocation tags by application ID. (Weiwei Yang via asuresh)\n",
      "commitDate": "05/03/18 11:24 AM",
      "commitName": "1054b48c27f3158110bd0512afecded36eecb8ad",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "18/02/18 5:19 AM",
      "commitNameOld": "4d4dde5112e9ee6b37cbdea17104c5a4c6870bd5",
      "commitAuthorOld": "fang zhenyi",
      "daysBetweenCommits": 15.25,
      "commitsBetweenForRepo": 96,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,151 +1,160 @@\n-  private void validateAndSetSchedulingRequest(SchedulingRequest newSchedulingRequest)\n+  private void validateAndSetSchedulingRequest(SchedulingRequest\n+      newSchedulingRequest)\n       throws SchedulerInvalidResoureRequestException {\n     // Check sizing exists\n     if (newSchedulingRequest.getResourceSizing() \u003d\u003d null\n         || newSchedulingRequest.getResourceSizing().getResources() \u003d\u003d null) {\n       throwExceptionWithMetaInfo(\n           \"No ResourceSizing found in the scheduling request, please double \"\n               + \"check\");\n     }\n \n     // Check execution type \u003d\u003d GUARANTEED\n     if (newSchedulingRequest.getExecutionType() !\u003d null\n         \u0026\u0026 newSchedulingRequest.getExecutionType().getExecutionType()\n         !\u003d ExecutionType.GUARANTEED) {\n       throwExceptionWithMetaInfo(\n           \"Only GUARANTEED execution type is supported.\");\n     }\n \n     PlacementConstraint constraint \u003d\n         newSchedulingRequest.getPlacementConstraint();\n \n     // We only accept SingleConstraint\n     PlacementConstraint.AbstractConstraint ac \u003d constraint.getConstraintExpr();\n     if (!(ac instanceof PlacementConstraint.SingleConstraint)) {\n       throwExceptionWithMetaInfo(\n           \"Only accepts \" + PlacementConstraint.SingleConstraint.class.getName()\n               + \" as constraint-expression. Rejecting the new added \"\n               + \"constraint-expression.class\u003d\" + ac.getClass().getName());\n     }\n \n     PlacementConstraint.SingleConstraint singleConstraint \u003d\n         (PlacementConstraint.SingleConstraint) ac;\n \n     // Make sure it is an anti-affinity request (actually this implementation\n     // should be able to support both affinity / anti-affinity without much\n     // effort. Considering potential test effort required. Limit to\n     // anti-affinity to intra-app and scope is node.\n     if (!singleConstraint.getScope().equals(PlacementConstraints.NODE)) {\n       throwExceptionWithMetaInfo(\n           \"Only support scope\u003d\" + PlacementConstraints.NODE\n               + \"now. PlacementConstraint\u003d\" + singleConstraint);\n     }\n \n     if (singleConstraint.getMinCardinality() !\u003d 0\n         || singleConstraint.getMaxCardinality() !\u003d 0) {\n       throwExceptionWithMetaInfo(\n           \"Only support anti-affinity, which is: minCardinality\u003d0, \"\n               + \"maxCardinality\u003d1\");\n     }\n \n     Set\u003cPlacementConstraint.TargetExpression\u003e targetExpressionSet \u003d\n         singleConstraint.getTargetExpressions();\n     if (targetExpressionSet \u003d\u003d null || targetExpressionSet.isEmpty()) {\n       throwExceptionWithMetaInfo(\n           \"TargetExpression should not be null or empty\");\n     }\n \n     // Set node partition\n     String nodePartition \u003d null;\n \n     // Target allocation tags\n     Set\u003cString\u003e targetAllocationTags \u003d null;\n \n     for (PlacementConstraint.TargetExpression targetExpression : targetExpressionSet) {\n       // Handle node partition\n       if (targetExpression.getTargetType().equals(\n           PlacementConstraint.TargetExpression.TargetType.NODE_ATTRIBUTE)) {\n         // For node attribute target, we only support Partition now. And once\n         // YARN-3409 is merged, we will support node attribute.\n         if (!targetExpression.getTargetKey().equals(NODE_PARTITION)) {\n           throwExceptionWithMetaInfo(\"When TargetType\u003d\"\n               + PlacementConstraint.TargetExpression.TargetType.NODE_ATTRIBUTE\n               + \" only \" + NODE_PARTITION + \" is accepted as TargetKey.\");\n         }\n \n         if (nodePartition !\u003d null) {\n           // This means we have duplicated node partition entry inside placement\n           // constraint, which might be set by mistake.\n           throwExceptionWithMetaInfo(\n               \"Only one node partition targetExpression is allowed\");\n         }\n \n         Set\u003cString\u003e values \u003d targetExpression.getTargetValues();\n         if (values \u003d\u003d null || values.isEmpty()) {\n           nodePartition \u003d RMNodeLabelsManager.NO_LABEL;\n           continue;\n         }\n \n         if (values.size() \u003e 1) {\n           throwExceptionWithMetaInfo(\"Inside one targetExpression, we only \"\n               + \"support affinity to at most one node partition now\");\n         }\n \n         nodePartition \u003d values.iterator().next();\n       } else if (targetExpression.getTargetType().equals(\n           PlacementConstraint.TargetExpression.TargetType.ALLOCATION_TAG)) {\n         // Handle allocation tags\n         if (targetAllocationTags !\u003d null) {\n           // This means we have duplicated AllocationTag expressions entries\n           // inside placement constraint, which might be set by mistake.\n           throwExceptionWithMetaInfo(\n               \"Only one AllocationTag targetExpression is allowed\");\n         }\n \n         if (targetExpression.getTargetValues() \u003d\u003d null || targetExpression\n             .getTargetValues().isEmpty()) {\n           throwExceptionWithMetaInfo(\"Failed to find allocation tags from \"\n               + \"TargetExpressions or couldn\u0027t find self-app target.\");\n         }\n \n         targetAllocationTags \u003d new HashSet\u003c\u003e(\n             targetExpression.getTargetValues());\n \n-        if (targetExpression.getTargetKey() !\u003d null \u0026\u0026 !targetExpression\n-            .getTargetKey().equals(APPLICATION_LABEL_INTRA_APPLICATION)) {\n+        try {\n+          AllocationTagNamespace tagNS \u003d\n+              AllocationTagNamespace.parse(targetExpression.getTargetKey());\n+          if (!AllocationTagNamespaceType.SELF\n+              .equals(tagNS.getNamespaceType())) {\n+            throwExceptionWithMetaInfo(\n+                \"As of now, the only accepted target key for targetKey of \"\n+                    + \"allocation_tag target expression is: [\"\n+                    + AllocationTagNamespaceType.SELF.toString()\n+                    + \"]. Please make changes to placement constraints \"\n+                    + \"accordingly. If this is null, it will be set to \"\n+                    + AllocationTagNamespaceType.SELF.toString()\n+                    + \" by default.\");\n+          }\n+        } catch (InvalidAllocationTagException e) {\n           throwExceptionWithMetaInfo(\n-              \"As of now, the only accepted target key for targetKey of \"\n-                  + \"allocation_tag target expression is: [\"\n-                  + APPLICATION_LABEL_INTRA_APPLICATION\n-                  + \"]. Please make changes to placement constraints \"\n-                  + \"accordingly. If this is null, it will be set to \"\n-                  + APPLICATION_LABEL_INTRA_APPLICATION + \" by default.\");\n+              \"Invalid allocation tag namespace, message: \" + e.getMessage());\n         }\n       }\n     }\n \n     if (targetAllocationTags \u003d\u003d null) {\n       // That means we don\u0027t have ALLOCATION_TAG specified\n       throwExceptionWithMetaInfo(\n           \"Couldn\u0027t find target expression with type \u003d\u003d ALLOCATION_TAG, it is \"\n               + \"required to include one and only one target expression with \"\n               + \"type \u003d\u003d ALLOCATION_TAG\");\n \n     }\n \n     if (nodePartition \u003d\u003d null) {\n       nodePartition \u003d RMNodeLabelsManager.NO_LABEL;\n     }\n \n     // Validation is done. set local results:\n     this.targetNodePartition \u003d nodePartition;\n     this.targetAllocationTags \u003d targetAllocationTags;\n \n     this.schedulingRequest \u003d new SchedulingRequestPBImpl(\n         ((SchedulingRequestPBImpl) newSchedulingRequest).getProto());\n \n     LOG.info(\"Successfully added SchedulingRequest to app\u003d\" + appSchedulingInfo\n         .getApplicationAttemptId() + \" targetAllocationTags\u003d[\" + StringUtils\n         .join(\",\", targetAllocationTags) + \"]. nodePartition\u003d\"\n         + targetNodePartition);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void validateAndSetSchedulingRequest(SchedulingRequest\n      newSchedulingRequest)\n      throws SchedulerInvalidResoureRequestException {\n    // Check sizing exists\n    if (newSchedulingRequest.getResourceSizing() \u003d\u003d null\n        || newSchedulingRequest.getResourceSizing().getResources() \u003d\u003d null) {\n      throwExceptionWithMetaInfo(\n          \"No ResourceSizing found in the scheduling request, please double \"\n              + \"check\");\n    }\n\n    // Check execution type \u003d\u003d GUARANTEED\n    if (newSchedulingRequest.getExecutionType() !\u003d null\n        \u0026\u0026 newSchedulingRequest.getExecutionType().getExecutionType()\n        !\u003d ExecutionType.GUARANTEED) {\n      throwExceptionWithMetaInfo(\n          \"Only GUARANTEED execution type is supported.\");\n    }\n\n    PlacementConstraint constraint \u003d\n        newSchedulingRequest.getPlacementConstraint();\n\n    // We only accept SingleConstraint\n    PlacementConstraint.AbstractConstraint ac \u003d constraint.getConstraintExpr();\n    if (!(ac instanceof PlacementConstraint.SingleConstraint)) {\n      throwExceptionWithMetaInfo(\n          \"Only accepts \" + PlacementConstraint.SingleConstraint.class.getName()\n              + \" as constraint-expression. Rejecting the new added \"\n              + \"constraint-expression.class\u003d\" + ac.getClass().getName());\n    }\n\n    PlacementConstraint.SingleConstraint singleConstraint \u003d\n        (PlacementConstraint.SingleConstraint) ac;\n\n    // Make sure it is an anti-affinity request (actually this implementation\n    // should be able to support both affinity / anti-affinity without much\n    // effort. Considering potential test effort required. Limit to\n    // anti-affinity to intra-app and scope is node.\n    if (!singleConstraint.getScope().equals(PlacementConstraints.NODE)) {\n      throwExceptionWithMetaInfo(\n          \"Only support scope\u003d\" + PlacementConstraints.NODE\n              + \"now. PlacementConstraint\u003d\" + singleConstraint);\n    }\n\n    if (singleConstraint.getMinCardinality() !\u003d 0\n        || singleConstraint.getMaxCardinality() !\u003d 0) {\n      throwExceptionWithMetaInfo(\n          \"Only support anti-affinity, which is: minCardinality\u003d0, \"\n              + \"maxCardinality\u003d1\");\n    }\n\n    Set\u003cPlacementConstraint.TargetExpression\u003e targetExpressionSet \u003d\n        singleConstraint.getTargetExpressions();\n    if (targetExpressionSet \u003d\u003d null || targetExpressionSet.isEmpty()) {\n      throwExceptionWithMetaInfo(\n          \"TargetExpression should not be null or empty\");\n    }\n\n    // Set node partition\n    String nodePartition \u003d null;\n\n    // Target allocation tags\n    Set\u003cString\u003e targetAllocationTags \u003d null;\n\n    for (PlacementConstraint.TargetExpression targetExpression : targetExpressionSet) {\n      // Handle node partition\n      if (targetExpression.getTargetType().equals(\n          PlacementConstraint.TargetExpression.TargetType.NODE_ATTRIBUTE)) {\n        // For node attribute target, we only support Partition now. And once\n        // YARN-3409 is merged, we will support node attribute.\n        if (!targetExpression.getTargetKey().equals(NODE_PARTITION)) {\n          throwExceptionWithMetaInfo(\"When TargetType\u003d\"\n              + PlacementConstraint.TargetExpression.TargetType.NODE_ATTRIBUTE\n              + \" only \" + NODE_PARTITION + \" is accepted as TargetKey.\");\n        }\n\n        if (nodePartition !\u003d null) {\n          // This means we have duplicated node partition entry inside placement\n          // constraint, which might be set by mistake.\n          throwExceptionWithMetaInfo(\n              \"Only one node partition targetExpression is allowed\");\n        }\n\n        Set\u003cString\u003e values \u003d targetExpression.getTargetValues();\n        if (values \u003d\u003d null || values.isEmpty()) {\n          nodePartition \u003d RMNodeLabelsManager.NO_LABEL;\n          continue;\n        }\n\n        if (values.size() \u003e 1) {\n          throwExceptionWithMetaInfo(\"Inside one targetExpression, we only \"\n              + \"support affinity to at most one node partition now\");\n        }\n\n        nodePartition \u003d values.iterator().next();\n      } else if (targetExpression.getTargetType().equals(\n          PlacementConstraint.TargetExpression.TargetType.ALLOCATION_TAG)) {\n        // Handle allocation tags\n        if (targetAllocationTags !\u003d null) {\n          // This means we have duplicated AllocationTag expressions entries\n          // inside placement constraint, which might be set by mistake.\n          throwExceptionWithMetaInfo(\n              \"Only one AllocationTag targetExpression is allowed\");\n        }\n\n        if (targetExpression.getTargetValues() \u003d\u003d null || targetExpression\n            .getTargetValues().isEmpty()) {\n          throwExceptionWithMetaInfo(\"Failed to find allocation tags from \"\n              + \"TargetExpressions or couldn\u0027t find self-app target.\");\n        }\n\n        targetAllocationTags \u003d new HashSet\u003c\u003e(\n            targetExpression.getTargetValues());\n\n        try {\n          AllocationTagNamespace tagNS \u003d\n              AllocationTagNamespace.parse(targetExpression.getTargetKey());\n          if (!AllocationTagNamespaceType.SELF\n              .equals(tagNS.getNamespaceType())) {\n            throwExceptionWithMetaInfo(\n                \"As of now, the only accepted target key for targetKey of \"\n                    + \"allocation_tag target expression is: [\"\n                    + AllocationTagNamespaceType.SELF.toString()\n                    + \"]. Please make changes to placement constraints \"\n                    + \"accordingly. If this is null, it will be set to \"\n                    + AllocationTagNamespaceType.SELF.toString()\n                    + \" by default.\");\n          }\n        } catch (InvalidAllocationTagException e) {\n          throwExceptionWithMetaInfo(\n              \"Invalid allocation tag namespace, message: \" + e.getMessage());\n        }\n      }\n    }\n\n    if (targetAllocationTags \u003d\u003d null) {\n      // That means we don\u0027t have ALLOCATION_TAG specified\n      throwExceptionWithMetaInfo(\n          \"Couldn\u0027t find target expression with type \u003d\u003d ALLOCATION_TAG, it is \"\n              + \"required to include one and only one target expression with \"\n              + \"type \u003d\u003d ALLOCATION_TAG\");\n\n    }\n\n    if (nodePartition \u003d\u003d null) {\n      nodePartition \u003d RMNodeLabelsManager.NO_LABEL;\n    }\n\n    // Validation is done. set local results:\n    this.targetNodePartition \u003d nodePartition;\n    this.targetAllocationTags \u003d targetAllocationTags;\n\n    this.schedulingRequest \u003d new SchedulingRequestPBImpl(\n        ((SchedulingRequestPBImpl) newSchedulingRequest).getProto());\n\n    LOG.info(\"Successfully added SchedulingRequest to app\u003d\" + appSchedulingInfo\n        .getApplicationAttemptId() + \" targetAllocationTags\u003d[\" + StringUtils\n        .join(\",\", targetAllocationTags) + \"]. nodePartition\u003d\"\n        + targetNodePartition);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/placement/SingleConstraintAppPlacementAllocator.java",
      "extendedDetails": {}
    },
    "644afe5fd800ac4f2b873a99f9b3868c3a8c5c40": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7807. Assume intra-app anti-affinity as default for scheduling request inside AppPlacementAllocator. (Wangda Tan via asuresh)\n",
      "commitDate": "31/01/18 1:30 AM",
      "commitName": "644afe5fd800ac4f2b873a99f9b3868c3a8c5c40",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "31/01/18 1:30 AM",
      "commitNameOld": "8bf7c444368f48f63f8011cf155f551c6b51ee21",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,150 +1,151 @@\n   private void validateAndSetSchedulingRequest(SchedulingRequest newSchedulingRequest)\n       throws SchedulerInvalidResoureRequestException {\n     // Check sizing exists\n     if (newSchedulingRequest.getResourceSizing() \u003d\u003d null\n         || newSchedulingRequest.getResourceSizing().getResources() \u003d\u003d null) {\n       throwExceptionWithMetaInfo(\n           \"No ResourceSizing found in the scheduling request, please double \"\n               + \"check\");\n     }\n \n     // Check execution type \u003d\u003d GUARANTEED\n     if (newSchedulingRequest.getExecutionType() !\u003d null\n         \u0026\u0026 newSchedulingRequest.getExecutionType().getExecutionType()\n         !\u003d ExecutionType.GUARANTEED) {\n       throwExceptionWithMetaInfo(\n           \"Only GUARANTEED execution type is supported.\");\n     }\n \n     PlacementConstraint constraint \u003d\n         newSchedulingRequest.getPlacementConstraint();\n \n     // We only accept SingleConstraint\n     PlacementConstraint.AbstractConstraint ac \u003d constraint.getConstraintExpr();\n     if (!(ac instanceof PlacementConstraint.SingleConstraint)) {\n       throwExceptionWithMetaInfo(\n           \"Only accepts \" + PlacementConstraint.SingleConstraint.class.getName()\n               + \" as constraint-expression. Rejecting the new added \"\n               + \"constraint-expression.class\u003d\" + ac.getClass().getName());\n     }\n \n     PlacementConstraint.SingleConstraint singleConstraint \u003d\n         (PlacementConstraint.SingleConstraint) ac;\n \n     // Make sure it is an anti-affinity request (actually this implementation\n     // should be able to support both affinity / anti-affinity without much\n     // effort. Considering potential test effort required. Limit to\n     // anti-affinity to intra-app and scope is node.\n     if (!singleConstraint.getScope().equals(PlacementConstraints.NODE)) {\n       throwExceptionWithMetaInfo(\n           \"Only support scope\u003d\" + PlacementConstraints.NODE\n               + \"now. PlacementConstraint\u003d\" + singleConstraint);\n     }\n \n     if (singleConstraint.getMinCardinality() !\u003d 0\n         || singleConstraint.getMaxCardinality() !\u003d 0) {\n       throwExceptionWithMetaInfo(\n           \"Only support anti-affinity, which is: minCardinality\u003d0, \"\n               + \"maxCardinality\u003d1\");\n     }\n \n     Set\u003cPlacementConstraint.TargetExpression\u003e targetExpressionSet \u003d\n         singleConstraint.getTargetExpressions();\n     if (targetExpressionSet \u003d\u003d null || targetExpressionSet.isEmpty()) {\n       throwExceptionWithMetaInfo(\n           \"TargetExpression should not be null or empty\");\n     }\n \n     // Set node partition\n     String nodePartition \u003d null;\n \n     // Target allocation tags\n     Set\u003cString\u003e targetAllocationTags \u003d null;\n \n     for (PlacementConstraint.TargetExpression targetExpression : targetExpressionSet) {\n       // Handle node partition\n       if (targetExpression.getTargetType().equals(\n           PlacementConstraint.TargetExpression.TargetType.NODE_ATTRIBUTE)) {\n         // For node attribute target, we only support Partition now. And once\n         // YARN-3409 is merged, we will support node attribute.\n         if (!targetExpression.getTargetKey().equals(NODE_PARTITION)) {\n           throwExceptionWithMetaInfo(\"When TargetType\u003d\"\n               + PlacementConstraint.TargetExpression.TargetType.NODE_ATTRIBUTE\n               + \" only \" + NODE_PARTITION + \" is accepted as TargetKey.\");\n         }\n \n         if (nodePartition !\u003d null) {\n           // This means we have duplicated node partition entry inside placement\n           // constraint, which might be set by mistake.\n           throwExceptionWithMetaInfo(\n               \"Only one node partition targetExpression is allowed\");\n         }\n \n         Set\u003cString\u003e values \u003d targetExpression.getTargetValues();\n         if (values \u003d\u003d null || values.isEmpty()) {\n           nodePartition \u003d RMNodeLabelsManager.NO_LABEL;\n           continue;\n         }\n \n         if (values.size() \u003e 1) {\n           throwExceptionWithMetaInfo(\"Inside one targetExpression, we only \"\n               + \"support affinity to at most one node partition now\");\n         }\n \n         nodePartition \u003d values.iterator().next();\n       } else if (targetExpression.getTargetType().equals(\n           PlacementConstraint.TargetExpression.TargetType.ALLOCATION_TAG)) {\n         // Handle allocation tags\n         if (targetAllocationTags !\u003d null) {\n           // This means we have duplicated AllocationTag expressions entries\n           // inside placement constraint, which might be set by mistake.\n           throwExceptionWithMetaInfo(\n               \"Only one AllocationTag targetExpression is allowed\");\n         }\n \n         if (targetExpression.getTargetValues() \u003d\u003d null || targetExpression\n             .getTargetValues().isEmpty()) {\n           throwExceptionWithMetaInfo(\"Failed to find allocation tags from \"\n               + \"TargetExpressions or couldn\u0027t find self-app target.\");\n         }\n \n         targetAllocationTags \u003d new HashSet\u003c\u003e(\n             targetExpression.getTargetValues());\n \n-        if (targetExpression.getTargetKey() \u003d\u003d null || !targetExpression\n+        if (targetExpression.getTargetKey() !\u003d null \u0026\u0026 !targetExpression\n             .getTargetKey().equals(APPLICATION_LABEL_INTRA_APPLICATION)) {\n           throwExceptionWithMetaInfo(\n               \"As of now, the only accepted target key for targetKey of \"\n                   + \"allocation_tag target expression is: [\"\n                   + APPLICATION_LABEL_INTRA_APPLICATION\n                   + \"]. Please make changes to placement constraints \"\n-                  + \"accordingly.\");\n+                  + \"accordingly. If this is null, it will be set to \"\n+                  + APPLICATION_LABEL_INTRA_APPLICATION + \" by default.\");\n         }\n       }\n     }\n \n     if (targetAllocationTags \u003d\u003d null) {\n       // That means we don\u0027t have ALLOCATION_TAG specified\n       throwExceptionWithMetaInfo(\n           \"Couldn\u0027t find target expression with type \u003d\u003d ALLOCATION_TAG, it is \"\n               + \"required to include one and only one target expression with \"\n               + \"type \u003d\u003d ALLOCATION_TAG\");\n \n     }\n \n     if (nodePartition \u003d\u003d null) {\n       nodePartition \u003d RMNodeLabelsManager.NO_LABEL;\n     }\n \n     // Validation is done. set local results:\n     this.targetNodePartition \u003d nodePartition;\n     this.targetAllocationTags \u003d targetAllocationTags;\n \n     this.schedulingRequest \u003d new SchedulingRequestPBImpl(\n         ((SchedulingRequestPBImpl) newSchedulingRequest).getProto());\n \n     LOG.info(\"Successfully added SchedulingRequest to app\u003d\" + appSchedulingInfo\n         .getApplicationAttemptId() + \" targetAllocationTags\u003d[\" + StringUtils\n         .join(\",\", targetAllocationTags) + \"]. nodePartition\u003d\"\n         + targetNodePartition);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void validateAndSetSchedulingRequest(SchedulingRequest newSchedulingRequest)\n      throws SchedulerInvalidResoureRequestException {\n    // Check sizing exists\n    if (newSchedulingRequest.getResourceSizing() \u003d\u003d null\n        || newSchedulingRequest.getResourceSizing().getResources() \u003d\u003d null) {\n      throwExceptionWithMetaInfo(\n          \"No ResourceSizing found in the scheduling request, please double \"\n              + \"check\");\n    }\n\n    // Check execution type \u003d\u003d GUARANTEED\n    if (newSchedulingRequest.getExecutionType() !\u003d null\n        \u0026\u0026 newSchedulingRequest.getExecutionType().getExecutionType()\n        !\u003d ExecutionType.GUARANTEED) {\n      throwExceptionWithMetaInfo(\n          \"Only GUARANTEED execution type is supported.\");\n    }\n\n    PlacementConstraint constraint \u003d\n        newSchedulingRequest.getPlacementConstraint();\n\n    // We only accept SingleConstraint\n    PlacementConstraint.AbstractConstraint ac \u003d constraint.getConstraintExpr();\n    if (!(ac instanceof PlacementConstraint.SingleConstraint)) {\n      throwExceptionWithMetaInfo(\n          \"Only accepts \" + PlacementConstraint.SingleConstraint.class.getName()\n              + \" as constraint-expression. Rejecting the new added \"\n              + \"constraint-expression.class\u003d\" + ac.getClass().getName());\n    }\n\n    PlacementConstraint.SingleConstraint singleConstraint \u003d\n        (PlacementConstraint.SingleConstraint) ac;\n\n    // Make sure it is an anti-affinity request (actually this implementation\n    // should be able to support both affinity / anti-affinity without much\n    // effort. Considering potential test effort required. Limit to\n    // anti-affinity to intra-app and scope is node.\n    if (!singleConstraint.getScope().equals(PlacementConstraints.NODE)) {\n      throwExceptionWithMetaInfo(\n          \"Only support scope\u003d\" + PlacementConstraints.NODE\n              + \"now. PlacementConstraint\u003d\" + singleConstraint);\n    }\n\n    if (singleConstraint.getMinCardinality() !\u003d 0\n        || singleConstraint.getMaxCardinality() !\u003d 0) {\n      throwExceptionWithMetaInfo(\n          \"Only support anti-affinity, which is: minCardinality\u003d0, \"\n              + \"maxCardinality\u003d1\");\n    }\n\n    Set\u003cPlacementConstraint.TargetExpression\u003e targetExpressionSet \u003d\n        singleConstraint.getTargetExpressions();\n    if (targetExpressionSet \u003d\u003d null || targetExpressionSet.isEmpty()) {\n      throwExceptionWithMetaInfo(\n          \"TargetExpression should not be null or empty\");\n    }\n\n    // Set node partition\n    String nodePartition \u003d null;\n\n    // Target allocation tags\n    Set\u003cString\u003e targetAllocationTags \u003d null;\n\n    for (PlacementConstraint.TargetExpression targetExpression : targetExpressionSet) {\n      // Handle node partition\n      if (targetExpression.getTargetType().equals(\n          PlacementConstraint.TargetExpression.TargetType.NODE_ATTRIBUTE)) {\n        // For node attribute target, we only support Partition now. And once\n        // YARN-3409 is merged, we will support node attribute.\n        if (!targetExpression.getTargetKey().equals(NODE_PARTITION)) {\n          throwExceptionWithMetaInfo(\"When TargetType\u003d\"\n              + PlacementConstraint.TargetExpression.TargetType.NODE_ATTRIBUTE\n              + \" only \" + NODE_PARTITION + \" is accepted as TargetKey.\");\n        }\n\n        if (nodePartition !\u003d null) {\n          // This means we have duplicated node partition entry inside placement\n          // constraint, which might be set by mistake.\n          throwExceptionWithMetaInfo(\n              \"Only one node partition targetExpression is allowed\");\n        }\n\n        Set\u003cString\u003e values \u003d targetExpression.getTargetValues();\n        if (values \u003d\u003d null || values.isEmpty()) {\n          nodePartition \u003d RMNodeLabelsManager.NO_LABEL;\n          continue;\n        }\n\n        if (values.size() \u003e 1) {\n          throwExceptionWithMetaInfo(\"Inside one targetExpression, we only \"\n              + \"support affinity to at most one node partition now\");\n        }\n\n        nodePartition \u003d values.iterator().next();\n      } else if (targetExpression.getTargetType().equals(\n          PlacementConstraint.TargetExpression.TargetType.ALLOCATION_TAG)) {\n        // Handle allocation tags\n        if (targetAllocationTags !\u003d null) {\n          // This means we have duplicated AllocationTag expressions entries\n          // inside placement constraint, which might be set by mistake.\n          throwExceptionWithMetaInfo(\n              \"Only one AllocationTag targetExpression is allowed\");\n        }\n\n        if (targetExpression.getTargetValues() \u003d\u003d null || targetExpression\n            .getTargetValues().isEmpty()) {\n          throwExceptionWithMetaInfo(\"Failed to find allocation tags from \"\n              + \"TargetExpressions or couldn\u0027t find self-app target.\");\n        }\n\n        targetAllocationTags \u003d new HashSet\u003c\u003e(\n            targetExpression.getTargetValues());\n\n        if (targetExpression.getTargetKey() !\u003d null \u0026\u0026 !targetExpression\n            .getTargetKey().equals(APPLICATION_LABEL_INTRA_APPLICATION)) {\n          throwExceptionWithMetaInfo(\n              \"As of now, the only accepted target key for targetKey of \"\n                  + \"allocation_tag target expression is: [\"\n                  + APPLICATION_LABEL_INTRA_APPLICATION\n                  + \"]. Please make changes to placement constraints \"\n                  + \"accordingly. If this is null, it will be set to \"\n                  + APPLICATION_LABEL_INTRA_APPLICATION + \" by default.\");\n        }\n      }\n    }\n\n    if (targetAllocationTags \u003d\u003d null) {\n      // That means we don\u0027t have ALLOCATION_TAG specified\n      throwExceptionWithMetaInfo(\n          \"Couldn\u0027t find target expression with type \u003d\u003d ALLOCATION_TAG, it is \"\n              + \"required to include one and only one target expression with \"\n              + \"type \u003d\u003d ALLOCATION_TAG\");\n\n    }\n\n    if (nodePartition \u003d\u003d null) {\n      nodePartition \u003d RMNodeLabelsManager.NO_LABEL;\n    }\n\n    // Validation is done. set local results:\n    this.targetNodePartition \u003d nodePartition;\n    this.targetAllocationTags \u003d targetAllocationTags;\n\n    this.schedulingRequest \u003d new SchedulingRequestPBImpl(\n        ((SchedulingRequestPBImpl) newSchedulingRequest).getProto());\n\n    LOG.info(\"Successfully added SchedulingRequest to app\u003d\" + appSchedulingInfo\n        .getApplicationAttemptId() + \" targetAllocationTags\u003d[\" + StringUtils\n        .join(\",\", targetAllocationTags) + \"]. nodePartition\u003d\"\n        + targetNodePartition);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/placement/SingleConstraintAppPlacementAllocator.java",
      "extendedDetails": {}
    },
    "28fe7f331837b36e78fa34ed990993677dddeaee": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7774. Miscellaneous fixes to the PlacementProcessor. (asuresh)\n",
      "commitDate": "31/01/18 1:30 AM",
      "commitName": "28fe7f331837b36e78fa34ed990993677dddeaee",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "31/01/18 1:30 AM",
      "commitNameOld": "38af23796971193fa529c3d08ffde8fcd6e607b6",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,150 +1,150 @@\n   private void validateAndSetSchedulingRequest(SchedulingRequest newSchedulingRequest)\n       throws SchedulerInvalidResoureRequestException {\n     // Check sizing exists\n     if (newSchedulingRequest.getResourceSizing() \u003d\u003d null\n         || newSchedulingRequest.getResourceSizing().getResources() \u003d\u003d null) {\n       throwExceptionWithMetaInfo(\n           \"No ResourceSizing found in the scheduling request, please double \"\n               + \"check\");\n     }\n \n     // Check execution type \u003d\u003d GUARANTEED\n     if (newSchedulingRequest.getExecutionType() !\u003d null\n         \u0026\u0026 newSchedulingRequest.getExecutionType().getExecutionType()\n         !\u003d ExecutionType.GUARANTEED) {\n       throwExceptionWithMetaInfo(\n           \"Only GUARANTEED execution type is supported.\");\n     }\n \n     PlacementConstraint constraint \u003d\n         newSchedulingRequest.getPlacementConstraint();\n \n     // We only accept SingleConstraint\n     PlacementConstraint.AbstractConstraint ac \u003d constraint.getConstraintExpr();\n     if (!(ac instanceof PlacementConstraint.SingleConstraint)) {\n       throwExceptionWithMetaInfo(\n           \"Only accepts \" + PlacementConstraint.SingleConstraint.class.getName()\n               + \" as constraint-expression. Rejecting the new added \"\n               + \"constraint-expression.class\u003d\" + ac.getClass().getName());\n     }\n \n     PlacementConstraint.SingleConstraint singleConstraint \u003d\n         (PlacementConstraint.SingleConstraint) ac;\n \n     // Make sure it is an anti-affinity request (actually this implementation\n     // should be able to support both affinity / anti-affinity without much\n     // effort. Considering potential test effort required. Limit to\n     // anti-affinity to intra-app and scope is node.\n     if (!singleConstraint.getScope().equals(PlacementConstraints.NODE)) {\n       throwExceptionWithMetaInfo(\n           \"Only support scope\u003d\" + PlacementConstraints.NODE\n               + \"now. PlacementConstraint\u003d\" + singleConstraint);\n     }\n \n     if (singleConstraint.getMinCardinality() !\u003d 0\n-        || singleConstraint.getMaxCardinality() !\u003d 1) {\n+        || singleConstraint.getMaxCardinality() !\u003d 0) {\n       throwExceptionWithMetaInfo(\n           \"Only support anti-affinity, which is: minCardinality\u003d0, \"\n               + \"maxCardinality\u003d1\");\n     }\n \n     Set\u003cPlacementConstraint.TargetExpression\u003e targetExpressionSet \u003d\n         singleConstraint.getTargetExpressions();\n     if (targetExpressionSet \u003d\u003d null || targetExpressionSet.isEmpty()) {\n       throwExceptionWithMetaInfo(\n           \"TargetExpression should not be null or empty\");\n     }\n \n     // Set node partition\n     String nodePartition \u003d null;\n \n     // Target allocation tags\n     Set\u003cString\u003e targetAllocationTags \u003d null;\n \n     for (PlacementConstraint.TargetExpression targetExpression : targetExpressionSet) {\n       // Handle node partition\n       if (targetExpression.getTargetType().equals(\n           PlacementConstraint.TargetExpression.TargetType.NODE_ATTRIBUTE)) {\n         // For node attribute target, we only support Partition now. And once\n         // YARN-3409 is merged, we will support node attribute.\n         if (!targetExpression.getTargetKey().equals(NODE_PARTITION)) {\n           throwExceptionWithMetaInfo(\"When TargetType\u003d\"\n               + PlacementConstraint.TargetExpression.TargetType.NODE_ATTRIBUTE\n               + \" only \" + NODE_PARTITION + \" is accepted as TargetKey.\");\n         }\n \n         if (nodePartition !\u003d null) {\n           // This means we have duplicated node partition entry inside placement\n           // constraint, which might be set by mistake.\n           throwExceptionWithMetaInfo(\n               \"Only one node partition targetExpression is allowed\");\n         }\n \n         Set\u003cString\u003e values \u003d targetExpression.getTargetValues();\n         if (values \u003d\u003d null || values.isEmpty()) {\n           nodePartition \u003d RMNodeLabelsManager.NO_LABEL;\n           continue;\n         }\n \n         if (values.size() \u003e 1) {\n           throwExceptionWithMetaInfo(\"Inside one targetExpression, we only \"\n               + \"support affinity to at most one node partition now\");\n         }\n \n         nodePartition \u003d values.iterator().next();\n       } else if (targetExpression.getTargetType().equals(\n           PlacementConstraint.TargetExpression.TargetType.ALLOCATION_TAG)) {\n         // Handle allocation tags\n         if (targetAllocationTags !\u003d null) {\n           // This means we have duplicated AllocationTag expressions entries\n           // inside placement constraint, which might be set by mistake.\n           throwExceptionWithMetaInfo(\n               \"Only one AllocationTag targetExpression is allowed\");\n         }\n \n         if (targetExpression.getTargetValues() \u003d\u003d null || targetExpression\n             .getTargetValues().isEmpty()) {\n           throwExceptionWithMetaInfo(\"Failed to find allocation tags from \"\n               + \"TargetExpressions or couldn\u0027t find self-app target.\");\n         }\n \n         targetAllocationTags \u003d new HashSet\u003c\u003e(\n             targetExpression.getTargetValues());\n \n         if (targetExpression.getTargetKey() \u003d\u003d null || !targetExpression\n             .getTargetKey().equals(APPLICATION_LABEL_INTRA_APPLICATION)) {\n           throwExceptionWithMetaInfo(\n               \"As of now, the only accepted target key for targetKey of \"\n                   + \"allocation_tag target expression is: [\"\n                   + APPLICATION_LABEL_INTRA_APPLICATION\n                   + \"]. Please make changes to placement constraints \"\n                   + \"accordingly.\");\n         }\n       }\n     }\n \n     if (targetAllocationTags \u003d\u003d null) {\n       // That means we don\u0027t have ALLOCATION_TAG specified\n       throwExceptionWithMetaInfo(\n           \"Couldn\u0027t find target expression with type \u003d\u003d ALLOCATION_TAG, it is \"\n               + \"required to include one and only one target expression with \"\n               + \"type \u003d\u003d ALLOCATION_TAG\");\n \n     }\n \n     if (nodePartition \u003d\u003d null) {\n       nodePartition \u003d RMNodeLabelsManager.NO_LABEL;\n     }\n \n     // Validation is done. set local results:\n     this.targetNodePartition \u003d nodePartition;\n     this.targetAllocationTags \u003d targetAllocationTags;\n \n     this.schedulingRequest \u003d new SchedulingRequestPBImpl(\n         ((SchedulingRequestPBImpl) newSchedulingRequest).getProto());\n \n     LOG.info(\"Successfully added SchedulingRequest to app\u003d\" + appSchedulingInfo\n         .getApplicationAttemptId() + \" targetAllocationTags\u003d[\" + StringUtils\n         .join(\",\", targetAllocationTags) + \"]. nodePartition\u003d\"\n         + targetNodePartition);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void validateAndSetSchedulingRequest(SchedulingRequest newSchedulingRequest)\n      throws SchedulerInvalidResoureRequestException {\n    // Check sizing exists\n    if (newSchedulingRequest.getResourceSizing() \u003d\u003d null\n        || newSchedulingRequest.getResourceSizing().getResources() \u003d\u003d null) {\n      throwExceptionWithMetaInfo(\n          \"No ResourceSizing found in the scheduling request, please double \"\n              + \"check\");\n    }\n\n    // Check execution type \u003d\u003d GUARANTEED\n    if (newSchedulingRequest.getExecutionType() !\u003d null\n        \u0026\u0026 newSchedulingRequest.getExecutionType().getExecutionType()\n        !\u003d ExecutionType.GUARANTEED) {\n      throwExceptionWithMetaInfo(\n          \"Only GUARANTEED execution type is supported.\");\n    }\n\n    PlacementConstraint constraint \u003d\n        newSchedulingRequest.getPlacementConstraint();\n\n    // We only accept SingleConstraint\n    PlacementConstraint.AbstractConstraint ac \u003d constraint.getConstraintExpr();\n    if (!(ac instanceof PlacementConstraint.SingleConstraint)) {\n      throwExceptionWithMetaInfo(\n          \"Only accepts \" + PlacementConstraint.SingleConstraint.class.getName()\n              + \" as constraint-expression. Rejecting the new added \"\n              + \"constraint-expression.class\u003d\" + ac.getClass().getName());\n    }\n\n    PlacementConstraint.SingleConstraint singleConstraint \u003d\n        (PlacementConstraint.SingleConstraint) ac;\n\n    // Make sure it is an anti-affinity request (actually this implementation\n    // should be able to support both affinity / anti-affinity without much\n    // effort. Considering potential test effort required. Limit to\n    // anti-affinity to intra-app and scope is node.\n    if (!singleConstraint.getScope().equals(PlacementConstraints.NODE)) {\n      throwExceptionWithMetaInfo(\n          \"Only support scope\u003d\" + PlacementConstraints.NODE\n              + \"now. PlacementConstraint\u003d\" + singleConstraint);\n    }\n\n    if (singleConstraint.getMinCardinality() !\u003d 0\n        || singleConstraint.getMaxCardinality() !\u003d 0) {\n      throwExceptionWithMetaInfo(\n          \"Only support anti-affinity, which is: minCardinality\u003d0, \"\n              + \"maxCardinality\u003d1\");\n    }\n\n    Set\u003cPlacementConstraint.TargetExpression\u003e targetExpressionSet \u003d\n        singleConstraint.getTargetExpressions();\n    if (targetExpressionSet \u003d\u003d null || targetExpressionSet.isEmpty()) {\n      throwExceptionWithMetaInfo(\n          \"TargetExpression should not be null or empty\");\n    }\n\n    // Set node partition\n    String nodePartition \u003d null;\n\n    // Target allocation tags\n    Set\u003cString\u003e targetAllocationTags \u003d null;\n\n    for (PlacementConstraint.TargetExpression targetExpression : targetExpressionSet) {\n      // Handle node partition\n      if (targetExpression.getTargetType().equals(\n          PlacementConstraint.TargetExpression.TargetType.NODE_ATTRIBUTE)) {\n        // For node attribute target, we only support Partition now. And once\n        // YARN-3409 is merged, we will support node attribute.\n        if (!targetExpression.getTargetKey().equals(NODE_PARTITION)) {\n          throwExceptionWithMetaInfo(\"When TargetType\u003d\"\n              + PlacementConstraint.TargetExpression.TargetType.NODE_ATTRIBUTE\n              + \" only \" + NODE_PARTITION + \" is accepted as TargetKey.\");\n        }\n\n        if (nodePartition !\u003d null) {\n          // This means we have duplicated node partition entry inside placement\n          // constraint, which might be set by mistake.\n          throwExceptionWithMetaInfo(\n              \"Only one node partition targetExpression is allowed\");\n        }\n\n        Set\u003cString\u003e values \u003d targetExpression.getTargetValues();\n        if (values \u003d\u003d null || values.isEmpty()) {\n          nodePartition \u003d RMNodeLabelsManager.NO_LABEL;\n          continue;\n        }\n\n        if (values.size() \u003e 1) {\n          throwExceptionWithMetaInfo(\"Inside one targetExpression, we only \"\n              + \"support affinity to at most one node partition now\");\n        }\n\n        nodePartition \u003d values.iterator().next();\n      } else if (targetExpression.getTargetType().equals(\n          PlacementConstraint.TargetExpression.TargetType.ALLOCATION_TAG)) {\n        // Handle allocation tags\n        if (targetAllocationTags !\u003d null) {\n          // This means we have duplicated AllocationTag expressions entries\n          // inside placement constraint, which might be set by mistake.\n          throwExceptionWithMetaInfo(\n              \"Only one AllocationTag targetExpression is allowed\");\n        }\n\n        if (targetExpression.getTargetValues() \u003d\u003d null || targetExpression\n            .getTargetValues().isEmpty()) {\n          throwExceptionWithMetaInfo(\"Failed to find allocation tags from \"\n              + \"TargetExpressions or couldn\u0027t find self-app target.\");\n        }\n\n        targetAllocationTags \u003d new HashSet\u003c\u003e(\n            targetExpression.getTargetValues());\n\n        if (targetExpression.getTargetKey() \u003d\u003d null || !targetExpression\n            .getTargetKey().equals(APPLICATION_LABEL_INTRA_APPLICATION)) {\n          throwExceptionWithMetaInfo(\n              \"As of now, the only accepted target key for targetKey of \"\n                  + \"allocation_tag target expression is: [\"\n                  + APPLICATION_LABEL_INTRA_APPLICATION\n                  + \"]. Please make changes to placement constraints \"\n                  + \"accordingly.\");\n        }\n      }\n    }\n\n    if (targetAllocationTags \u003d\u003d null) {\n      // That means we don\u0027t have ALLOCATION_TAG specified\n      throwExceptionWithMetaInfo(\n          \"Couldn\u0027t find target expression with type \u003d\u003d ALLOCATION_TAG, it is \"\n              + \"required to include one and only one target expression with \"\n              + \"type \u003d\u003d ALLOCATION_TAG\");\n\n    }\n\n    if (nodePartition \u003d\u003d null) {\n      nodePartition \u003d RMNodeLabelsManager.NO_LABEL;\n    }\n\n    // Validation is done. set local results:\n    this.targetNodePartition \u003d nodePartition;\n    this.targetAllocationTags \u003d targetAllocationTags;\n\n    this.schedulingRequest \u003d new SchedulingRequestPBImpl(\n        ((SchedulingRequestPBImpl) newSchedulingRequest).getProto());\n\n    LOG.info(\"Successfully added SchedulingRequest to app\u003d\" + appSchedulingInfo\n        .getApplicationAttemptId() + \" targetAllocationTags\u003d[\" + StringUtils\n        .join(\",\", targetAllocationTags) + \"]. nodePartition\u003d\"\n        + targetNodePartition);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/placement/SingleConstraintAppPlacementAllocator.java",
      "extendedDetails": {}
    },
    "38af23796971193fa529c3d08ffde8fcd6e607b6": {
      "type": "Yintroduced",
      "commitMessage": "YARN-6599. Support anti-affinity constraint via AppPlacementAllocator. (Wangda Tan via asuresh)\n",
      "commitDate": "31/01/18 1:30 AM",
      "commitName": "38af23796971193fa529c3d08ffde8fcd6e607b6",
      "commitAuthor": "Arun Suresh",
      "diff": "@@ -0,0 +1,150 @@\n+  private void validateAndSetSchedulingRequest(SchedulingRequest newSchedulingRequest)\n+      throws SchedulerInvalidResoureRequestException {\n+    // Check sizing exists\n+    if (newSchedulingRequest.getResourceSizing() \u003d\u003d null\n+        || newSchedulingRequest.getResourceSizing().getResources() \u003d\u003d null) {\n+      throwExceptionWithMetaInfo(\n+          \"No ResourceSizing found in the scheduling request, please double \"\n+              + \"check\");\n+    }\n+\n+    // Check execution type \u003d\u003d GUARANTEED\n+    if (newSchedulingRequest.getExecutionType() !\u003d null\n+        \u0026\u0026 newSchedulingRequest.getExecutionType().getExecutionType()\n+        !\u003d ExecutionType.GUARANTEED) {\n+      throwExceptionWithMetaInfo(\n+          \"Only GUARANTEED execution type is supported.\");\n+    }\n+\n+    PlacementConstraint constraint \u003d\n+        newSchedulingRequest.getPlacementConstraint();\n+\n+    // We only accept SingleConstraint\n+    PlacementConstraint.AbstractConstraint ac \u003d constraint.getConstraintExpr();\n+    if (!(ac instanceof PlacementConstraint.SingleConstraint)) {\n+      throwExceptionWithMetaInfo(\n+          \"Only accepts \" + PlacementConstraint.SingleConstraint.class.getName()\n+              + \" as constraint-expression. Rejecting the new added \"\n+              + \"constraint-expression.class\u003d\" + ac.getClass().getName());\n+    }\n+\n+    PlacementConstraint.SingleConstraint singleConstraint \u003d\n+        (PlacementConstraint.SingleConstraint) ac;\n+\n+    // Make sure it is an anti-affinity request (actually this implementation\n+    // should be able to support both affinity / anti-affinity without much\n+    // effort. Considering potential test effort required. Limit to\n+    // anti-affinity to intra-app and scope is node.\n+    if (!singleConstraint.getScope().equals(PlacementConstraints.NODE)) {\n+      throwExceptionWithMetaInfo(\n+          \"Only support scope\u003d\" + PlacementConstraints.NODE\n+              + \"now. PlacementConstraint\u003d\" + singleConstraint);\n+    }\n+\n+    if (singleConstraint.getMinCardinality() !\u003d 0\n+        || singleConstraint.getMaxCardinality() !\u003d 1) {\n+      throwExceptionWithMetaInfo(\n+          \"Only support anti-affinity, which is: minCardinality\u003d0, \"\n+              + \"maxCardinality\u003d1\");\n+    }\n+\n+    Set\u003cPlacementConstraint.TargetExpression\u003e targetExpressionSet \u003d\n+        singleConstraint.getTargetExpressions();\n+    if (targetExpressionSet \u003d\u003d null || targetExpressionSet.isEmpty()) {\n+      throwExceptionWithMetaInfo(\n+          \"TargetExpression should not be null or empty\");\n+    }\n+\n+    // Set node partition\n+    String nodePartition \u003d null;\n+\n+    // Target allocation tags\n+    Set\u003cString\u003e targetAllocationTags \u003d null;\n+\n+    for (PlacementConstraint.TargetExpression targetExpression : targetExpressionSet) {\n+      // Handle node partition\n+      if (targetExpression.getTargetType().equals(\n+          PlacementConstraint.TargetExpression.TargetType.NODE_ATTRIBUTE)) {\n+        // For node attribute target, we only support Partition now. And once\n+        // YARN-3409 is merged, we will support node attribute.\n+        if (!targetExpression.getTargetKey().equals(NODE_PARTITION)) {\n+          throwExceptionWithMetaInfo(\"When TargetType\u003d\"\n+              + PlacementConstraint.TargetExpression.TargetType.NODE_ATTRIBUTE\n+              + \" only \" + NODE_PARTITION + \" is accepted as TargetKey.\");\n+        }\n+\n+        if (nodePartition !\u003d null) {\n+          // This means we have duplicated node partition entry inside placement\n+          // constraint, which might be set by mistake.\n+          throwExceptionWithMetaInfo(\n+              \"Only one node partition targetExpression is allowed\");\n+        }\n+\n+        Set\u003cString\u003e values \u003d targetExpression.getTargetValues();\n+        if (values \u003d\u003d null || values.isEmpty()) {\n+          nodePartition \u003d RMNodeLabelsManager.NO_LABEL;\n+          continue;\n+        }\n+\n+        if (values.size() \u003e 1) {\n+          throwExceptionWithMetaInfo(\"Inside one targetExpression, we only \"\n+              + \"support affinity to at most one node partition now\");\n+        }\n+\n+        nodePartition \u003d values.iterator().next();\n+      } else if (targetExpression.getTargetType().equals(\n+          PlacementConstraint.TargetExpression.TargetType.ALLOCATION_TAG)) {\n+        // Handle allocation tags\n+        if (targetAllocationTags !\u003d null) {\n+          // This means we have duplicated AllocationTag expressions entries\n+          // inside placement constraint, which might be set by mistake.\n+          throwExceptionWithMetaInfo(\n+              \"Only one AllocationTag targetExpression is allowed\");\n+        }\n+\n+        if (targetExpression.getTargetValues() \u003d\u003d null || targetExpression\n+            .getTargetValues().isEmpty()) {\n+          throwExceptionWithMetaInfo(\"Failed to find allocation tags from \"\n+              + \"TargetExpressions or couldn\u0027t find self-app target.\");\n+        }\n+\n+        targetAllocationTags \u003d new HashSet\u003c\u003e(\n+            targetExpression.getTargetValues());\n+\n+        if (targetExpression.getTargetKey() \u003d\u003d null || !targetExpression\n+            .getTargetKey().equals(APPLICATION_LABEL_INTRA_APPLICATION)) {\n+          throwExceptionWithMetaInfo(\n+              \"As of now, the only accepted target key for targetKey of \"\n+                  + \"allocation_tag target expression is: [\"\n+                  + APPLICATION_LABEL_INTRA_APPLICATION\n+                  + \"]. Please make changes to placement constraints \"\n+                  + \"accordingly.\");\n+        }\n+      }\n+    }\n+\n+    if (targetAllocationTags \u003d\u003d null) {\n+      // That means we don\u0027t have ALLOCATION_TAG specified\n+      throwExceptionWithMetaInfo(\n+          \"Couldn\u0027t find target expression with type \u003d\u003d ALLOCATION_TAG, it is \"\n+              + \"required to include one and only one target expression with \"\n+              + \"type \u003d\u003d ALLOCATION_TAG\");\n+\n+    }\n+\n+    if (nodePartition \u003d\u003d null) {\n+      nodePartition \u003d RMNodeLabelsManager.NO_LABEL;\n+    }\n+\n+    // Validation is done. set local results:\n+    this.targetNodePartition \u003d nodePartition;\n+    this.targetAllocationTags \u003d targetAllocationTags;\n+\n+    this.schedulingRequest \u003d new SchedulingRequestPBImpl(\n+        ((SchedulingRequestPBImpl) newSchedulingRequest).getProto());\n+\n+    LOG.info(\"Successfully added SchedulingRequest to app\u003d\" + appSchedulingInfo\n+        .getApplicationAttemptId() + \" targetAllocationTags\u003d[\" + StringUtils\n+        .join(\",\", targetAllocationTags) + \"]. nodePartition\u003d\"\n+        + targetNodePartition);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void validateAndSetSchedulingRequest(SchedulingRequest newSchedulingRequest)\n      throws SchedulerInvalidResoureRequestException {\n    // Check sizing exists\n    if (newSchedulingRequest.getResourceSizing() \u003d\u003d null\n        || newSchedulingRequest.getResourceSizing().getResources() \u003d\u003d null) {\n      throwExceptionWithMetaInfo(\n          \"No ResourceSizing found in the scheduling request, please double \"\n              + \"check\");\n    }\n\n    // Check execution type \u003d\u003d GUARANTEED\n    if (newSchedulingRequest.getExecutionType() !\u003d null\n        \u0026\u0026 newSchedulingRequest.getExecutionType().getExecutionType()\n        !\u003d ExecutionType.GUARANTEED) {\n      throwExceptionWithMetaInfo(\n          \"Only GUARANTEED execution type is supported.\");\n    }\n\n    PlacementConstraint constraint \u003d\n        newSchedulingRequest.getPlacementConstraint();\n\n    // We only accept SingleConstraint\n    PlacementConstraint.AbstractConstraint ac \u003d constraint.getConstraintExpr();\n    if (!(ac instanceof PlacementConstraint.SingleConstraint)) {\n      throwExceptionWithMetaInfo(\n          \"Only accepts \" + PlacementConstraint.SingleConstraint.class.getName()\n              + \" as constraint-expression. Rejecting the new added \"\n              + \"constraint-expression.class\u003d\" + ac.getClass().getName());\n    }\n\n    PlacementConstraint.SingleConstraint singleConstraint \u003d\n        (PlacementConstraint.SingleConstraint) ac;\n\n    // Make sure it is an anti-affinity request (actually this implementation\n    // should be able to support both affinity / anti-affinity without much\n    // effort. Considering potential test effort required. Limit to\n    // anti-affinity to intra-app and scope is node.\n    if (!singleConstraint.getScope().equals(PlacementConstraints.NODE)) {\n      throwExceptionWithMetaInfo(\n          \"Only support scope\u003d\" + PlacementConstraints.NODE\n              + \"now. PlacementConstraint\u003d\" + singleConstraint);\n    }\n\n    if (singleConstraint.getMinCardinality() !\u003d 0\n        || singleConstraint.getMaxCardinality() !\u003d 1) {\n      throwExceptionWithMetaInfo(\n          \"Only support anti-affinity, which is: minCardinality\u003d0, \"\n              + \"maxCardinality\u003d1\");\n    }\n\n    Set\u003cPlacementConstraint.TargetExpression\u003e targetExpressionSet \u003d\n        singleConstraint.getTargetExpressions();\n    if (targetExpressionSet \u003d\u003d null || targetExpressionSet.isEmpty()) {\n      throwExceptionWithMetaInfo(\n          \"TargetExpression should not be null or empty\");\n    }\n\n    // Set node partition\n    String nodePartition \u003d null;\n\n    // Target allocation tags\n    Set\u003cString\u003e targetAllocationTags \u003d null;\n\n    for (PlacementConstraint.TargetExpression targetExpression : targetExpressionSet) {\n      // Handle node partition\n      if (targetExpression.getTargetType().equals(\n          PlacementConstraint.TargetExpression.TargetType.NODE_ATTRIBUTE)) {\n        // For node attribute target, we only support Partition now. And once\n        // YARN-3409 is merged, we will support node attribute.\n        if (!targetExpression.getTargetKey().equals(NODE_PARTITION)) {\n          throwExceptionWithMetaInfo(\"When TargetType\u003d\"\n              + PlacementConstraint.TargetExpression.TargetType.NODE_ATTRIBUTE\n              + \" only \" + NODE_PARTITION + \" is accepted as TargetKey.\");\n        }\n\n        if (nodePartition !\u003d null) {\n          // This means we have duplicated node partition entry inside placement\n          // constraint, which might be set by mistake.\n          throwExceptionWithMetaInfo(\n              \"Only one node partition targetExpression is allowed\");\n        }\n\n        Set\u003cString\u003e values \u003d targetExpression.getTargetValues();\n        if (values \u003d\u003d null || values.isEmpty()) {\n          nodePartition \u003d RMNodeLabelsManager.NO_LABEL;\n          continue;\n        }\n\n        if (values.size() \u003e 1) {\n          throwExceptionWithMetaInfo(\"Inside one targetExpression, we only \"\n              + \"support affinity to at most one node partition now\");\n        }\n\n        nodePartition \u003d values.iterator().next();\n      } else if (targetExpression.getTargetType().equals(\n          PlacementConstraint.TargetExpression.TargetType.ALLOCATION_TAG)) {\n        // Handle allocation tags\n        if (targetAllocationTags !\u003d null) {\n          // This means we have duplicated AllocationTag expressions entries\n          // inside placement constraint, which might be set by mistake.\n          throwExceptionWithMetaInfo(\n              \"Only one AllocationTag targetExpression is allowed\");\n        }\n\n        if (targetExpression.getTargetValues() \u003d\u003d null || targetExpression\n            .getTargetValues().isEmpty()) {\n          throwExceptionWithMetaInfo(\"Failed to find allocation tags from \"\n              + \"TargetExpressions or couldn\u0027t find self-app target.\");\n        }\n\n        targetAllocationTags \u003d new HashSet\u003c\u003e(\n            targetExpression.getTargetValues());\n\n        if (targetExpression.getTargetKey() \u003d\u003d null || !targetExpression\n            .getTargetKey().equals(APPLICATION_LABEL_INTRA_APPLICATION)) {\n          throwExceptionWithMetaInfo(\n              \"As of now, the only accepted target key for targetKey of \"\n                  + \"allocation_tag target expression is: [\"\n                  + APPLICATION_LABEL_INTRA_APPLICATION\n                  + \"]. Please make changes to placement constraints \"\n                  + \"accordingly.\");\n        }\n      }\n    }\n\n    if (targetAllocationTags \u003d\u003d null) {\n      // That means we don\u0027t have ALLOCATION_TAG specified\n      throwExceptionWithMetaInfo(\n          \"Couldn\u0027t find target expression with type \u003d\u003d ALLOCATION_TAG, it is \"\n              + \"required to include one and only one target expression with \"\n              + \"type \u003d\u003d ALLOCATION_TAG\");\n\n    }\n\n    if (nodePartition \u003d\u003d null) {\n      nodePartition \u003d RMNodeLabelsManager.NO_LABEL;\n    }\n\n    // Validation is done. set local results:\n    this.targetNodePartition \u003d nodePartition;\n    this.targetAllocationTags \u003d targetAllocationTags;\n\n    this.schedulingRequest \u003d new SchedulingRequestPBImpl(\n        ((SchedulingRequestPBImpl) newSchedulingRequest).getProto());\n\n    LOG.info(\"Successfully added SchedulingRequest to app\u003d\" + appSchedulingInfo\n        .getApplicationAttemptId() + \" targetAllocationTags\u003d[\" + StringUtils\n        .join(\",\", targetAllocationTags) + \"]. nodePartition\u003d\"\n        + targetNodePartition);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/placement/SingleConstraintAppPlacementAllocator.java"
    }
  }
}