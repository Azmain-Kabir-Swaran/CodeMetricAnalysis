{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FSNamesystemLock.java",
  "functionName": "readUnlock",
  "functionId": "readUnlock___opName-String__lockReportInfoSupplier-Supplier__String__",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystemLock.java",
  "functionStartLine": 170,
  "functionEndLine": 228,
  "numCommitsSeen": 43,
  "timeTaken": 6751,
  "changeHistory": [
    "1824aee9da4056de0fb638906b2172e486bbebe7",
    "d353b30baf6da5b70685cf837cf7095636f345e1",
    "bfb8f28cc995241e7387ceba8e14791b8c121956",
    "feb2664ac4b246ca87fc4997a941190f00026dff",
    "ad49098eb324e238d97db68d7239ed2c4d84afa0",
    "ff0b99eafeda035ebe0dc82cfe689808047a8893",
    "434c5ea75dc3d87513e49290ac9999148ff5163c"
  ],
  "changeHistoryShort": {
    "1824aee9da4056de0fb638906b2172e486bbebe7": "Ymultichange(Yparameterchange,Ybodychange)",
    "d353b30baf6da5b70685cf837cf7095636f345e1": "Ybodychange",
    "bfb8f28cc995241e7387ceba8e14791b8c121956": "Ybodychange",
    "feb2664ac4b246ca87fc4997a941190f00026dff": "Ybodychange",
    "ad49098eb324e238d97db68d7239ed2c4d84afa0": "Ybodychange",
    "ff0b99eafeda035ebe0dc82cfe689808047a8893": "Ymultichange(Yparameterchange,Ybodychange)",
    "434c5ea75dc3d87513e49290ac9999148ff5163c": "Yintroduced"
  },
  "changeHistoryDetails": {
    "1824aee9da4056de0fb638906b2172e486bbebe7": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-15217 Add more information to longest write/read lock held log\n\n",
      "commitDate": "18/04/20 1:52 PM",
      "commitName": "1824aee9da4056de0fb638906b2172e486bbebe7",
      "commitAuthor": "Toshihiro Suzuki",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-15217 Add more information to longest write/read lock held log\n\n",
          "commitDate": "18/04/20 1:52 PM",
          "commitName": "1824aee9da4056de0fb638906b2172e486bbebe7",
          "commitAuthor": "Toshihiro Suzuki",
          "commitDateOld": "24/03/20 2:50 PM",
          "commitNameOld": "d353b30baf6da5b70685cf837cf7095636f345e1",
          "commitAuthorOld": "Toshihiro Suzuki",
          "daysBetweenCommits": 24.96,
          "commitsBetweenForRepo": 83,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,45 +1,59 @@\n-  public void readUnlock(String opName) {\n+  public void readUnlock(String opName,\n+      Supplier\u003cString\u003e lockReportInfoSupplier) {\n     final boolean needReport \u003d coarseLock.getReadHoldCount() \u003d\u003d 1;\n     final long readLockIntervalNanos \u003d\n         timer.monotonicNowNanos() - readLockHeldTimeStampNanos.get();\n     final long currentTimeMs \u003d timer.now();\n     coarseLock.readLock().unlock();\n \n     if (needReport) {\n       addMetric(opName, readLockIntervalNanos, false);\n       readLockHeldTimeStampNanos.remove();\n     }\n     final long readLockIntervalMs \u003d\n         TimeUnit.NANOSECONDS.toMillis(readLockIntervalNanos);\n     if (needReport \u0026\u0026 readLockIntervalMs \u003e\u003d this.readLockReportingThresholdMs) {\n-      LockHeldInfo localLockHeldInfo;\n-      do {\n-        localLockHeldInfo \u003d longestReadLockHeldInfo.get();\n-      } while (localLockHeldInfo.getIntervalMs() - readLockIntervalMs \u003c 0 \u0026\u0026\n-          !longestReadLockHeldInfo.compareAndSet(localLockHeldInfo,\n+      String lockReportInfo \u003d null;\n+      boolean done \u003d false;\n+      while (!done) {\n+        LockHeldInfo localLockHeldInfo \u003d longestReadLockHeldInfo.get();\n+        if (localLockHeldInfo.getIntervalMs() \u003c\u003d readLockIntervalMs) {\n+          if (lockReportInfo \u003d\u003d null) {\n+            lockReportInfo \u003d lockReportInfoSupplier !\u003d null ? \" (\" +\n+                lockReportInfoSupplier.get() + \")\" : \"\";\n+          }\n+          if (longestReadLockHeldInfo.compareAndSet(localLockHeldInfo,\n               new LockHeldInfo(currentTimeMs, readLockIntervalMs,\n-                  StringUtils.getStackTrace(Thread.currentThread()))));\n+              StringUtils.getStackTrace(Thread.currentThread()), opName,\n+              lockReportInfo))) {\n+            done \u003d true;\n+          }\n+        } else {\n+          done \u003d true;\n+        }\n+      }\n \n       long localTimeStampOfLastReadLockReport;\n       long nowMs;\n       do {\n         nowMs \u003d timer.monotonicNow();\n         localTimeStampOfLastReadLockReport \u003d\n             timeStampOfLastReadLockReportMs.get();\n         if (nowMs - localTimeStampOfLastReadLockReport \u003c\n             lockSuppressWarningIntervalMs) {\n           numReadLockWarningsSuppressed.incrementAndGet();\n           return;\n         }\n       } while (!timeStampOfLastReadLockReportMs.compareAndSet(\n           localTimeStampOfLastReadLockReport, nowMs));\n       int numSuppressedWarnings \u003d numReadLockWarningsSuppressed.getAndSet(0);\n       LockHeldInfo lockHeldInfo \u003d\n-          longestReadLockHeldInfo.getAndSet(new LockHeldInfo(0, 0, null));\n+          longestReadLockHeldInfo.getAndSet(new LockHeldInfo());\n       FSNamesystem.LOG.info(\n           \"\\tNumber of suppressed read-lock reports: {}\"\n-              + \"\\n\\tLongest read-lock held at {} for {}ms via {}\",\n+              + \"\\n\\tLongest read-lock held at {} for {}ms by {}{} via {}\",\n           numSuppressedWarnings, Time.formatTime(lockHeldInfo.getStartTimeMs()),\n-          lockHeldInfo.getIntervalMs(), lockHeldInfo.getStackTrace());\n+          lockHeldInfo.getIntervalMs(), lockHeldInfo.getOpName(),\n+          lockHeldInfo.getLockReportInfo(), lockHeldInfo.getStackTrace());\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void readUnlock(String opName,\n      Supplier\u003cString\u003e lockReportInfoSupplier) {\n    final boolean needReport \u003d coarseLock.getReadHoldCount() \u003d\u003d 1;\n    final long readLockIntervalNanos \u003d\n        timer.monotonicNowNanos() - readLockHeldTimeStampNanos.get();\n    final long currentTimeMs \u003d timer.now();\n    coarseLock.readLock().unlock();\n\n    if (needReport) {\n      addMetric(opName, readLockIntervalNanos, false);\n      readLockHeldTimeStampNanos.remove();\n    }\n    final long readLockIntervalMs \u003d\n        TimeUnit.NANOSECONDS.toMillis(readLockIntervalNanos);\n    if (needReport \u0026\u0026 readLockIntervalMs \u003e\u003d this.readLockReportingThresholdMs) {\n      String lockReportInfo \u003d null;\n      boolean done \u003d false;\n      while (!done) {\n        LockHeldInfo localLockHeldInfo \u003d longestReadLockHeldInfo.get();\n        if (localLockHeldInfo.getIntervalMs() \u003c\u003d readLockIntervalMs) {\n          if (lockReportInfo \u003d\u003d null) {\n            lockReportInfo \u003d lockReportInfoSupplier !\u003d null ? \" (\" +\n                lockReportInfoSupplier.get() + \")\" : \"\";\n          }\n          if (longestReadLockHeldInfo.compareAndSet(localLockHeldInfo,\n              new LockHeldInfo(currentTimeMs, readLockIntervalMs,\n              StringUtils.getStackTrace(Thread.currentThread()), opName,\n              lockReportInfo))) {\n            done \u003d true;\n          }\n        } else {\n          done \u003d true;\n        }\n      }\n\n      long localTimeStampOfLastReadLockReport;\n      long nowMs;\n      do {\n        nowMs \u003d timer.monotonicNow();\n        localTimeStampOfLastReadLockReport \u003d\n            timeStampOfLastReadLockReportMs.get();\n        if (nowMs - localTimeStampOfLastReadLockReport \u003c\n            lockSuppressWarningIntervalMs) {\n          numReadLockWarningsSuppressed.incrementAndGet();\n          return;\n        }\n      } while (!timeStampOfLastReadLockReportMs.compareAndSet(\n          localTimeStampOfLastReadLockReport, nowMs));\n      int numSuppressedWarnings \u003d numReadLockWarningsSuppressed.getAndSet(0);\n      LockHeldInfo lockHeldInfo \u003d\n          longestReadLockHeldInfo.getAndSet(new LockHeldInfo());\n      FSNamesystem.LOG.info(\n          \"\\tNumber of suppressed read-lock reports: {}\"\n              + \"\\n\\tLongest read-lock held at {} for {}ms by {}{} via {}\",\n          numSuppressedWarnings, Time.formatTime(lockHeldInfo.getStartTimeMs()),\n          lockHeldInfo.getIntervalMs(), lockHeldInfo.getOpName(),\n          lockHeldInfo.getLockReportInfo(), lockHeldInfo.getStackTrace());\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystemLock.java",
          "extendedDetails": {
            "oldValue": "[opName-String]",
            "newValue": "[opName-String, lockReportInfoSupplier-Supplier\u003cString\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-15217 Add more information to longest write/read lock held log\n\n",
          "commitDate": "18/04/20 1:52 PM",
          "commitName": "1824aee9da4056de0fb638906b2172e486bbebe7",
          "commitAuthor": "Toshihiro Suzuki",
          "commitDateOld": "24/03/20 2:50 PM",
          "commitNameOld": "d353b30baf6da5b70685cf837cf7095636f345e1",
          "commitAuthorOld": "Toshihiro Suzuki",
          "daysBetweenCommits": 24.96,
          "commitsBetweenForRepo": 83,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,45 +1,59 @@\n-  public void readUnlock(String opName) {\n+  public void readUnlock(String opName,\n+      Supplier\u003cString\u003e lockReportInfoSupplier) {\n     final boolean needReport \u003d coarseLock.getReadHoldCount() \u003d\u003d 1;\n     final long readLockIntervalNanos \u003d\n         timer.monotonicNowNanos() - readLockHeldTimeStampNanos.get();\n     final long currentTimeMs \u003d timer.now();\n     coarseLock.readLock().unlock();\n \n     if (needReport) {\n       addMetric(opName, readLockIntervalNanos, false);\n       readLockHeldTimeStampNanos.remove();\n     }\n     final long readLockIntervalMs \u003d\n         TimeUnit.NANOSECONDS.toMillis(readLockIntervalNanos);\n     if (needReport \u0026\u0026 readLockIntervalMs \u003e\u003d this.readLockReportingThresholdMs) {\n-      LockHeldInfo localLockHeldInfo;\n-      do {\n-        localLockHeldInfo \u003d longestReadLockHeldInfo.get();\n-      } while (localLockHeldInfo.getIntervalMs() - readLockIntervalMs \u003c 0 \u0026\u0026\n-          !longestReadLockHeldInfo.compareAndSet(localLockHeldInfo,\n+      String lockReportInfo \u003d null;\n+      boolean done \u003d false;\n+      while (!done) {\n+        LockHeldInfo localLockHeldInfo \u003d longestReadLockHeldInfo.get();\n+        if (localLockHeldInfo.getIntervalMs() \u003c\u003d readLockIntervalMs) {\n+          if (lockReportInfo \u003d\u003d null) {\n+            lockReportInfo \u003d lockReportInfoSupplier !\u003d null ? \" (\" +\n+                lockReportInfoSupplier.get() + \")\" : \"\";\n+          }\n+          if (longestReadLockHeldInfo.compareAndSet(localLockHeldInfo,\n               new LockHeldInfo(currentTimeMs, readLockIntervalMs,\n-                  StringUtils.getStackTrace(Thread.currentThread()))));\n+              StringUtils.getStackTrace(Thread.currentThread()), opName,\n+              lockReportInfo))) {\n+            done \u003d true;\n+          }\n+        } else {\n+          done \u003d true;\n+        }\n+      }\n \n       long localTimeStampOfLastReadLockReport;\n       long nowMs;\n       do {\n         nowMs \u003d timer.monotonicNow();\n         localTimeStampOfLastReadLockReport \u003d\n             timeStampOfLastReadLockReportMs.get();\n         if (nowMs - localTimeStampOfLastReadLockReport \u003c\n             lockSuppressWarningIntervalMs) {\n           numReadLockWarningsSuppressed.incrementAndGet();\n           return;\n         }\n       } while (!timeStampOfLastReadLockReportMs.compareAndSet(\n           localTimeStampOfLastReadLockReport, nowMs));\n       int numSuppressedWarnings \u003d numReadLockWarningsSuppressed.getAndSet(0);\n       LockHeldInfo lockHeldInfo \u003d\n-          longestReadLockHeldInfo.getAndSet(new LockHeldInfo(0, 0, null));\n+          longestReadLockHeldInfo.getAndSet(new LockHeldInfo());\n       FSNamesystem.LOG.info(\n           \"\\tNumber of suppressed read-lock reports: {}\"\n-              + \"\\n\\tLongest read-lock held at {} for {}ms via {}\",\n+              + \"\\n\\tLongest read-lock held at {} for {}ms by {}{} via {}\",\n           numSuppressedWarnings, Time.formatTime(lockHeldInfo.getStartTimeMs()),\n-          lockHeldInfo.getIntervalMs(), lockHeldInfo.getStackTrace());\n+          lockHeldInfo.getIntervalMs(), lockHeldInfo.getOpName(),\n+          lockHeldInfo.getLockReportInfo(), lockHeldInfo.getStackTrace());\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void readUnlock(String opName,\n      Supplier\u003cString\u003e lockReportInfoSupplier) {\n    final boolean needReport \u003d coarseLock.getReadHoldCount() \u003d\u003d 1;\n    final long readLockIntervalNanos \u003d\n        timer.monotonicNowNanos() - readLockHeldTimeStampNanos.get();\n    final long currentTimeMs \u003d timer.now();\n    coarseLock.readLock().unlock();\n\n    if (needReport) {\n      addMetric(opName, readLockIntervalNanos, false);\n      readLockHeldTimeStampNanos.remove();\n    }\n    final long readLockIntervalMs \u003d\n        TimeUnit.NANOSECONDS.toMillis(readLockIntervalNanos);\n    if (needReport \u0026\u0026 readLockIntervalMs \u003e\u003d this.readLockReportingThresholdMs) {\n      String lockReportInfo \u003d null;\n      boolean done \u003d false;\n      while (!done) {\n        LockHeldInfo localLockHeldInfo \u003d longestReadLockHeldInfo.get();\n        if (localLockHeldInfo.getIntervalMs() \u003c\u003d readLockIntervalMs) {\n          if (lockReportInfo \u003d\u003d null) {\n            lockReportInfo \u003d lockReportInfoSupplier !\u003d null ? \" (\" +\n                lockReportInfoSupplier.get() + \")\" : \"\";\n          }\n          if (longestReadLockHeldInfo.compareAndSet(localLockHeldInfo,\n              new LockHeldInfo(currentTimeMs, readLockIntervalMs,\n              StringUtils.getStackTrace(Thread.currentThread()), opName,\n              lockReportInfo))) {\n            done \u003d true;\n          }\n        } else {\n          done \u003d true;\n        }\n      }\n\n      long localTimeStampOfLastReadLockReport;\n      long nowMs;\n      do {\n        nowMs \u003d timer.monotonicNow();\n        localTimeStampOfLastReadLockReport \u003d\n            timeStampOfLastReadLockReportMs.get();\n        if (nowMs - localTimeStampOfLastReadLockReport \u003c\n            lockSuppressWarningIntervalMs) {\n          numReadLockWarningsSuppressed.incrementAndGet();\n          return;\n        }\n      } while (!timeStampOfLastReadLockReportMs.compareAndSet(\n          localTimeStampOfLastReadLockReport, nowMs));\n      int numSuppressedWarnings \u003d numReadLockWarningsSuppressed.getAndSet(0);\n      LockHeldInfo lockHeldInfo \u003d\n          longestReadLockHeldInfo.getAndSet(new LockHeldInfo());\n      FSNamesystem.LOG.info(\n          \"\\tNumber of suppressed read-lock reports: {}\"\n              + \"\\n\\tLongest read-lock held at {} for {}ms by {}{} via {}\",\n          numSuppressedWarnings, Time.formatTime(lockHeldInfo.getStartTimeMs()),\n          lockHeldInfo.getIntervalMs(), lockHeldInfo.getOpName(),\n          lockHeldInfo.getLockReportInfo(), lockHeldInfo.getStackTrace());\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystemLock.java",
          "extendedDetails": {}
        }
      ]
    },
    "d353b30baf6da5b70685cf837cf7095636f345e1": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-15215. The Timestamp for longest write/read lock held log is wrong\n\n",
      "commitDate": "24/03/20 2:50 PM",
      "commitName": "d353b30baf6da5b70685cf837cf7095636f345e1",
      "commitAuthor": "Toshihiro Suzuki",
      "commitDateOld": "05/11/19 9:19 AM",
      "commitNameOld": "bfb8f28cc995241e7387ceba8e14791b8c121956",
      "commitAuthorOld": "Inigo Goiri",
      "daysBetweenCommits": 140.19,
      "commitsBetweenForRepo": 484,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,45 @@\n   public void readUnlock(String opName) {\n     final boolean needReport \u003d coarseLock.getReadHoldCount() \u003d\u003d 1;\n-    final long currentTimeStampNanos \u003d timer.monotonicNowNanos();\n     final long readLockIntervalNanos \u003d\n-        currentTimeStampNanos - readLockHeldTimeStampNanos.get();\n+        timer.monotonicNowNanos() - readLockHeldTimeStampNanos.get();\n+    final long currentTimeMs \u003d timer.now();\n     coarseLock.readLock().unlock();\n \n     if (needReport) {\n       addMetric(opName, readLockIntervalNanos, false);\n       readLockHeldTimeStampNanos.remove();\n     }\n     final long readLockIntervalMs \u003d\n         TimeUnit.NANOSECONDS.toMillis(readLockIntervalNanos);\n-    final long currentTimeMs \u003d\n-        TimeUnit.NANOSECONDS.toMillis(currentTimeStampNanos);\n     if (needReport \u0026\u0026 readLockIntervalMs \u003e\u003d this.readLockReportingThresholdMs) {\n       LockHeldInfo localLockHeldInfo;\n       do {\n         localLockHeldInfo \u003d longestReadLockHeldInfo.get();\n       } while (localLockHeldInfo.getIntervalMs() - readLockIntervalMs \u003c 0 \u0026\u0026\n           !longestReadLockHeldInfo.compareAndSet(localLockHeldInfo,\n               new LockHeldInfo(currentTimeMs, readLockIntervalMs,\n                   StringUtils.getStackTrace(Thread.currentThread()))));\n \n       long localTimeStampOfLastReadLockReport;\n       long nowMs;\n       do {\n         nowMs \u003d timer.monotonicNow();\n         localTimeStampOfLastReadLockReport \u003d\n             timeStampOfLastReadLockReportMs.get();\n         if (nowMs - localTimeStampOfLastReadLockReport \u003c\n             lockSuppressWarningIntervalMs) {\n           numReadLockWarningsSuppressed.incrementAndGet();\n           return;\n         }\n       } while (!timeStampOfLastReadLockReportMs.compareAndSet(\n           localTimeStampOfLastReadLockReport, nowMs));\n       int numSuppressedWarnings \u003d numReadLockWarningsSuppressed.getAndSet(0);\n       LockHeldInfo lockHeldInfo \u003d\n           longestReadLockHeldInfo.getAndSet(new LockHeldInfo(0, 0, null));\n       FSNamesystem.LOG.info(\n           \"\\tNumber of suppressed read-lock reports: {}\"\n               + \"\\n\\tLongest read-lock held at {} for {}ms via {}\",\n           numSuppressedWarnings, Time.formatTime(lockHeldInfo.getStartTimeMs()),\n           lockHeldInfo.getIntervalMs(), lockHeldInfo.getStackTrace());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void readUnlock(String opName) {\n    final boolean needReport \u003d coarseLock.getReadHoldCount() \u003d\u003d 1;\n    final long readLockIntervalNanos \u003d\n        timer.monotonicNowNanos() - readLockHeldTimeStampNanos.get();\n    final long currentTimeMs \u003d timer.now();\n    coarseLock.readLock().unlock();\n\n    if (needReport) {\n      addMetric(opName, readLockIntervalNanos, false);\n      readLockHeldTimeStampNanos.remove();\n    }\n    final long readLockIntervalMs \u003d\n        TimeUnit.NANOSECONDS.toMillis(readLockIntervalNanos);\n    if (needReport \u0026\u0026 readLockIntervalMs \u003e\u003d this.readLockReportingThresholdMs) {\n      LockHeldInfo localLockHeldInfo;\n      do {\n        localLockHeldInfo \u003d longestReadLockHeldInfo.get();\n      } while (localLockHeldInfo.getIntervalMs() - readLockIntervalMs \u003c 0 \u0026\u0026\n          !longestReadLockHeldInfo.compareAndSet(localLockHeldInfo,\n              new LockHeldInfo(currentTimeMs, readLockIntervalMs,\n                  StringUtils.getStackTrace(Thread.currentThread()))));\n\n      long localTimeStampOfLastReadLockReport;\n      long nowMs;\n      do {\n        nowMs \u003d timer.monotonicNow();\n        localTimeStampOfLastReadLockReport \u003d\n            timeStampOfLastReadLockReportMs.get();\n        if (nowMs - localTimeStampOfLastReadLockReport \u003c\n            lockSuppressWarningIntervalMs) {\n          numReadLockWarningsSuppressed.incrementAndGet();\n          return;\n        }\n      } while (!timeStampOfLastReadLockReportMs.compareAndSet(\n          localTimeStampOfLastReadLockReport, nowMs));\n      int numSuppressedWarnings \u003d numReadLockWarningsSuppressed.getAndSet(0);\n      LockHeldInfo lockHeldInfo \u003d\n          longestReadLockHeldInfo.getAndSet(new LockHeldInfo(0, 0, null));\n      FSNamesystem.LOG.info(\n          \"\\tNumber of suppressed read-lock reports: {}\"\n              + \"\\n\\tLongest read-lock held at {} for {}ms via {}\",\n          numSuppressedWarnings, Time.formatTime(lockHeldInfo.getStartTimeMs()),\n          lockHeldInfo.getIntervalMs(), lockHeldInfo.getStackTrace());\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystemLock.java",
      "extendedDetails": {}
    },
    "bfb8f28cc995241e7387ceba8e14791b8c121956": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14775. Add Timestamp for longest FSN write/read lock held log. Contributed by Chen Zhang.\n",
      "commitDate": "05/11/19 9:19 AM",
      "commitName": "bfb8f28cc995241e7387ceba8e14791b8c121956",
      "commitAuthor": "Inigo Goiri",
      "commitDateOld": "23/05/19 10:28 AM",
      "commitNameOld": "f96a2df38d889f29314c57f4d94227b2e419a11f",
      "commitAuthorOld": "Christopher Gregorian",
      "daysBetweenCommits": 165.99,
      "commitsBetweenForRepo": 1297,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,44 +1,47 @@\n   public void readUnlock(String opName) {\n     final boolean needReport \u003d coarseLock.getReadHoldCount() \u003d\u003d 1;\n+    final long currentTimeStampNanos \u003d timer.monotonicNowNanos();\n     final long readLockIntervalNanos \u003d\n-        timer.monotonicNowNanos() - readLockHeldTimeStampNanos.get();\n+        currentTimeStampNanos - readLockHeldTimeStampNanos.get();\n     coarseLock.readLock().unlock();\n \n     if (needReport) {\n       addMetric(opName, readLockIntervalNanos, false);\n       readLockHeldTimeStampNanos.remove();\n     }\n     final long readLockIntervalMs \u003d\n         TimeUnit.NANOSECONDS.toMillis(readLockIntervalNanos);\n+    final long currentTimeMs \u003d\n+        TimeUnit.NANOSECONDS.toMillis(currentTimeStampNanos);\n     if (needReport \u0026\u0026 readLockIntervalMs \u003e\u003d this.readLockReportingThresholdMs) {\n-      ReadLockHeldInfo localLockHeldInfo;\n+      LockHeldInfo localLockHeldInfo;\n       do {\n         localLockHeldInfo \u003d longestReadLockHeldInfo.get();\n       } while (localLockHeldInfo.getIntervalMs() - readLockIntervalMs \u003c 0 \u0026\u0026\n           !longestReadLockHeldInfo.compareAndSet(localLockHeldInfo,\n-              new ReadLockHeldInfo(readLockIntervalMs,\n+              new LockHeldInfo(currentTimeMs, readLockIntervalMs,\n                   StringUtils.getStackTrace(Thread.currentThread()))));\n \n       long localTimeStampOfLastReadLockReport;\n       long nowMs;\n       do {\n         nowMs \u003d timer.monotonicNow();\n         localTimeStampOfLastReadLockReport \u003d\n             timeStampOfLastReadLockReportMs.get();\n         if (nowMs - localTimeStampOfLastReadLockReport \u003c\n             lockSuppressWarningIntervalMs) {\n           numReadLockWarningsSuppressed.incrementAndGet();\n           return;\n         }\n       } while (!timeStampOfLastReadLockReportMs.compareAndSet(\n           localTimeStampOfLastReadLockReport, nowMs));\n       int numSuppressedWarnings \u003d numReadLockWarningsSuppressed.getAndSet(0);\n-      ReadLockHeldInfo lockHeldInfo \u003d longestReadLockHeldInfo\n-          .getAndSet(new ReadLockHeldInfo(0, null));\n+      LockHeldInfo lockHeldInfo \u003d\n+          longestReadLockHeldInfo.getAndSet(new LockHeldInfo(0, 0, null));\n       FSNamesystem.LOG.info(\n-          \"\\tNumber of suppressed read-lock reports: {}\" +\n-          \"\\n\\tLongest read-lock held interval: {}ms via {}\",\n-          numSuppressedWarnings, lockHeldInfo.getIntervalMs(),\n-          lockHeldInfo.getStackTrace());\n+          \"\\tNumber of suppressed read-lock reports: {}\"\n+              + \"\\n\\tLongest read-lock held at {} for {}ms via {}\",\n+          numSuppressedWarnings, Time.formatTime(lockHeldInfo.getStartTimeMs()),\n+          lockHeldInfo.getIntervalMs(), lockHeldInfo.getStackTrace());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void readUnlock(String opName) {\n    final boolean needReport \u003d coarseLock.getReadHoldCount() \u003d\u003d 1;\n    final long currentTimeStampNanos \u003d timer.monotonicNowNanos();\n    final long readLockIntervalNanos \u003d\n        currentTimeStampNanos - readLockHeldTimeStampNanos.get();\n    coarseLock.readLock().unlock();\n\n    if (needReport) {\n      addMetric(opName, readLockIntervalNanos, false);\n      readLockHeldTimeStampNanos.remove();\n    }\n    final long readLockIntervalMs \u003d\n        TimeUnit.NANOSECONDS.toMillis(readLockIntervalNanos);\n    final long currentTimeMs \u003d\n        TimeUnit.NANOSECONDS.toMillis(currentTimeStampNanos);\n    if (needReport \u0026\u0026 readLockIntervalMs \u003e\u003d this.readLockReportingThresholdMs) {\n      LockHeldInfo localLockHeldInfo;\n      do {\n        localLockHeldInfo \u003d longestReadLockHeldInfo.get();\n      } while (localLockHeldInfo.getIntervalMs() - readLockIntervalMs \u003c 0 \u0026\u0026\n          !longestReadLockHeldInfo.compareAndSet(localLockHeldInfo,\n              new LockHeldInfo(currentTimeMs, readLockIntervalMs,\n                  StringUtils.getStackTrace(Thread.currentThread()))));\n\n      long localTimeStampOfLastReadLockReport;\n      long nowMs;\n      do {\n        nowMs \u003d timer.monotonicNow();\n        localTimeStampOfLastReadLockReport \u003d\n            timeStampOfLastReadLockReportMs.get();\n        if (nowMs - localTimeStampOfLastReadLockReport \u003c\n            lockSuppressWarningIntervalMs) {\n          numReadLockWarningsSuppressed.incrementAndGet();\n          return;\n        }\n      } while (!timeStampOfLastReadLockReportMs.compareAndSet(\n          localTimeStampOfLastReadLockReport, nowMs));\n      int numSuppressedWarnings \u003d numReadLockWarningsSuppressed.getAndSet(0);\n      LockHeldInfo lockHeldInfo \u003d\n          longestReadLockHeldInfo.getAndSet(new LockHeldInfo(0, 0, null));\n      FSNamesystem.LOG.info(\n          \"\\tNumber of suppressed read-lock reports: {}\"\n              + \"\\n\\tLongest read-lock held at {} for {}ms via {}\",\n          numSuppressedWarnings, Time.formatTime(lockHeldInfo.getStartTimeMs()),\n          lockHeldInfo.getIntervalMs(), lockHeldInfo.getStackTrace());\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystemLock.java",
      "extendedDetails": {}
    },
    "feb2664ac4b246ca87fc4997a941190f00026dff": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13946. Log longest FSN write/read lock held stack trace.\n",
      "commitDate": "22/12/18 7:09 AM",
      "commitName": "feb2664ac4b246ca87fc4997a941190f00026dff",
      "commitAuthor": "Yiqun Lin",
      "commitDateOld": "19/09/18 1:22 PM",
      "commitNameOld": "a30b4f9e71cf53f79c38878d6cbe5bbe79bcb277",
      "commitAuthorOld": "Chen Liang",
      "daysBetweenCommits": 93.78,
      "commitsBetweenForRepo": 720,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,43 +1,44 @@\n   public void readUnlock(String opName) {\n     final boolean needReport \u003d coarseLock.getReadHoldCount() \u003d\u003d 1;\n     final long readLockIntervalNanos \u003d\n         timer.monotonicNowNanos() - readLockHeldTimeStampNanos.get();\n     coarseLock.readLock().unlock();\n \n     if (needReport) {\n       addMetric(opName, readLockIntervalNanos, false);\n       readLockHeldTimeStampNanos.remove();\n     }\n     final long readLockIntervalMs \u003d\n         TimeUnit.NANOSECONDS.toMillis(readLockIntervalNanos);\n     if (needReport \u0026\u0026 readLockIntervalMs \u003e\u003d this.readLockReportingThresholdMs) {\n-      long localLongestReadLock;\n+      ReadLockHeldInfo localLockHeldInfo;\n       do {\n-        localLongestReadLock \u003d longestReadLockHeldIntervalMs.get();\n-      } while (localLongestReadLock - readLockIntervalMs \u003c 0 \u0026\u0026\n-          !longestReadLockHeldIntervalMs.compareAndSet(localLongestReadLock,\n-              readLockIntervalMs));\n+        localLockHeldInfo \u003d longestReadLockHeldInfo.get();\n+      } while (localLockHeldInfo.getIntervalMs() - readLockIntervalMs \u003c 0 \u0026\u0026\n+          !longestReadLockHeldInfo.compareAndSet(localLockHeldInfo,\n+              new ReadLockHeldInfo(readLockIntervalMs,\n+                  StringUtils.getStackTrace(Thread.currentThread()))));\n \n       long localTimeStampOfLastReadLockReport;\n       long nowMs;\n       do {\n         nowMs \u003d timer.monotonicNow();\n         localTimeStampOfLastReadLockReport \u003d\n             timeStampOfLastReadLockReportMs.get();\n         if (nowMs - localTimeStampOfLastReadLockReport \u003c\n             lockSuppressWarningIntervalMs) {\n           numReadLockWarningsSuppressed.incrementAndGet();\n           return;\n         }\n       } while (!timeStampOfLastReadLockReportMs.compareAndSet(\n           localTimeStampOfLastReadLockReport, nowMs));\n       int numSuppressedWarnings \u003d numReadLockWarningsSuppressed.getAndSet(0);\n-      long longestLockHeldIntervalMs \u003d\n-          longestReadLockHeldIntervalMs.getAndSet(0);\n-      FSNamesystem.LOG.info(\"FSNamesystem read lock held for \" +\n-          readLockIntervalMs + \" ms via\\n\" +\n-          StringUtils.getStackTrace(Thread.currentThread()) +\n-          \"\\tNumber of suppressed read-lock reports: \" + numSuppressedWarnings +\n-          \"\\n\\tLongest read-lock held interval: \" + longestLockHeldIntervalMs);\n+      ReadLockHeldInfo lockHeldInfo \u003d longestReadLockHeldInfo\n+          .getAndSet(new ReadLockHeldInfo(0, null));\n+      FSNamesystem.LOG.info(\n+          \"\\tNumber of suppressed read-lock reports: {}\" +\n+          \"\\n\\tLongest read-lock held interval: {}ms via {}\",\n+          numSuppressedWarnings, lockHeldInfo.getIntervalMs(),\n+          lockHeldInfo.getStackTrace());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void readUnlock(String opName) {\n    final boolean needReport \u003d coarseLock.getReadHoldCount() \u003d\u003d 1;\n    final long readLockIntervalNanos \u003d\n        timer.monotonicNowNanos() - readLockHeldTimeStampNanos.get();\n    coarseLock.readLock().unlock();\n\n    if (needReport) {\n      addMetric(opName, readLockIntervalNanos, false);\n      readLockHeldTimeStampNanos.remove();\n    }\n    final long readLockIntervalMs \u003d\n        TimeUnit.NANOSECONDS.toMillis(readLockIntervalNanos);\n    if (needReport \u0026\u0026 readLockIntervalMs \u003e\u003d this.readLockReportingThresholdMs) {\n      ReadLockHeldInfo localLockHeldInfo;\n      do {\n        localLockHeldInfo \u003d longestReadLockHeldInfo.get();\n      } while (localLockHeldInfo.getIntervalMs() - readLockIntervalMs \u003c 0 \u0026\u0026\n          !longestReadLockHeldInfo.compareAndSet(localLockHeldInfo,\n              new ReadLockHeldInfo(readLockIntervalMs,\n                  StringUtils.getStackTrace(Thread.currentThread()))));\n\n      long localTimeStampOfLastReadLockReport;\n      long nowMs;\n      do {\n        nowMs \u003d timer.monotonicNow();\n        localTimeStampOfLastReadLockReport \u003d\n            timeStampOfLastReadLockReportMs.get();\n        if (nowMs - localTimeStampOfLastReadLockReport \u003c\n            lockSuppressWarningIntervalMs) {\n          numReadLockWarningsSuppressed.incrementAndGet();\n          return;\n        }\n      } while (!timeStampOfLastReadLockReportMs.compareAndSet(\n          localTimeStampOfLastReadLockReport, nowMs));\n      int numSuppressedWarnings \u003d numReadLockWarningsSuppressed.getAndSet(0);\n      ReadLockHeldInfo lockHeldInfo \u003d longestReadLockHeldInfo\n          .getAndSet(new ReadLockHeldInfo(0, null));\n      FSNamesystem.LOG.info(\n          \"\\tNumber of suppressed read-lock reports: {}\" +\n          \"\\n\\tLongest read-lock held interval: {}ms via {}\",\n          numSuppressedWarnings, lockHeldInfo.getIntervalMs(),\n          lockHeldInfo.getStackTrace());\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystemLock.java",
      "extendedDetails": {}
    },
    "ad49098eb324e238d97db68d7239ed2c4d84afa0": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11615. FSNamesystemLock metrics can be inaccurate due to millisecond precision. Contributed by Erik Krogen.\n",
      "commitDate": "17/04/17 4:22 PM",
      "commitName": "ad49098eb324e238d97db68d7239ed2c4d84afa0",
      "commitAuthor": "Zhe Zhang",
      "commitDateOld": "14/11/16 11:05 AM",
      "commitNameOld": "ff0b99eafeda035ebe0dc82cfe689808047a8893",
      "commitAuthorOld": "Zhe Zhang",
      "daysBetweenCommits": 154.18,
      "commitsBetweenForRepo": 832,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,43 @@\n   public void readUnlock(String opName) {\n     final boolean needReport \u003d coarseLock.getReadHoldCount() \u003d\u003d 1;\n-    final long readLockInterval \u003d\n-        timer.monotonicNow() - readLockHeldTimeStamp.get();\n+    final long readLockIntervalNanos \u003d\n+        timer.monotonicNowNanos() - readLockHeldTimeStampNanos.get();\n     coarseLock.readLock().unlock();\n \n     if (needReport) {\n-      addMetric(opName, readLockInterval, false);\n-      readLockHeldTimeStamp.remove();\n+      addMetric(opName, readLockIntervalNanos, false);\n+      readLockHeldTimeStampNanos.remove();\n     }\n-    if (needReport \u0026\u0026 readLockInterval \u003e\u003d this.readLockReportingThreshold) {\n+    final long readLockIntervalMs \u003d\n+        TimeUnit.NANOSECONDS.toMillis(readLockIntervalNanos);\n+    if (needReport \u0026\u0026 readLockIntervalMs \u003e\u003d this.readLockReportingThresholdMs) {\n       long localLongestReadLock;\n       do {\n-        localLongestReadLock \u003d longestReadLockHeldInterval.get();\n-      } while (localLongestReadLock - readLockInterval \u003c 0 \u0026\u0026\n-          !longestReadLockHeldInterval.compareAndSet(localLongestReadLock,\n-              readLockInterval));\n+        localLongestReadLock \u003d longestReadLockHeldIntervalMs.get();\n+      } while (localLongestReadLock - readLockIntervalMs \u003c 0 \u0026\u0026\n+          !longestReadLockHeldIntervalMs.compareAndSet(localLongestReadLock,\n+              readLockIntervalMs));\n \n       long localTimeStampOfLastReadLockReport;\n-      long now;\n+      long nowMs;\n       do {\n-        now \u003d timer.monotonicNow();\n+        nowMs \u003d timer.monotonicNow();\n         localTimeStampOfLastReadLockReport \u003d\n-            timeStampOfLastReadLockReport.get();\n-        if (now - localTimeStampOfLastReadLockReport \u003c\n-            lockSuppressWarningInterval) {\n+            timeStampOfLastReadLockReportMs.get();\n+        if (nowMs - localTimeStampOfLastReadLockReport \u003c\n+            lockSuppressWarningIntervalMs) {\n           numReadLockWarningsSuppressed.incrementAndGet();\n           return;\n         }\n-      } while (!timeStampOfLastReadLockReport.compareAndSet(\n-          localTimeStampOfLastReadLockReport, now));\n+      } while (!timeStampOfLastReadLockReportMs.compareAndSet(\n+          localTimeStampOfLastReadLockReport, nowMs));\n       int numSuppressedWarnings \u003d numReadLockWarningsSuppressed.getAndSet(0);\n-      long longestLockHeldInterval \u003d longestReadLockHeldInterval.getAndSet(0);\n+      long longestLockHeldIntervalMs \u003d\n+          longestReadLockHeldIntervalMs.getAndSet(0);\n       FSNamesystem.LOG.info(\"FSNamesystem read lock held for \" +\n-          readLockInterval + \" ms via\\n\" +\n+          readLockIntervalMs + \" ms via\\n\" +\n           StringUtils.getStackTrace(Thread.currentThread()) +\n           \"\\tNumber of suppressed read-lock reports: \" + numSuppressedWarnings +\n-          \"\\n\\tLongest read-lock held interval: \" + longestLockHeldInterval);\n+          \"\\n\\tLongest read-lock held interval: \" + longestLockHeldIntervalMs);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void readUnlock(String opName) {\n    final boolean needReport \u003d coarseLock.getReadHoldCount() \u003d\u003d 1;\n    final long readLockIntervalNanos \u003d\n        timer.monotonicNowNanos() - readLockHeldTimeStampNanos.get();\n    coarseLock.readLock().unlock();\n\n    if (needReport) {\n      addMetric(opName, readLockIntervalNanos, false);\n      readLockHeldTimeStampNanos.remove();\n    }\n    final long readLockIntervalMs \u003d\n        TimeUnit.NANOSECONDS.toMillis(readLockIntervalNanos);\n    if (needReport \u0026\u0026 readLockIntervalMs \u003e\u003d this.readLockReportingThresholdMs) {\n      long localLongestReadLock;\n      do {\n        localLongestReadLock \u003d longestReadLockHeldIntervalMs.get();\n      } while (localLongestReadLock - readLockIntervalMs \u003c 0 \u0026\u0026\n          !longestReadLockHeldIntervalMs.compareAndSet(localLongestReadLock,\n              readLockIntervalMs));\n\n      long localTimeStampOfLastReadLockReport;\n      long nowMs;\n      do {\n        nowMs \u003d timer.monotonicNow();\n        localTimeStampOfLastReadLockReport \u003d\n            timeStampOfLastReadLockReportMs.get();\n        if (nowMs - localTimeStampOfLastReadLockReport \u003c\n            lockSuppressWarningIntervalMs) {\n          numReadLockWarningsSuppressed.incrementAndGet();\n          return;\n        }\n      } while (!timeStampOfLastReadLockReportMs.compareAndSet(\n          localTimeStampOfLastReadLockReport, nowMs));\n      int numSuppressedWarnings \u003d numReadLockWarningsSuppressed.getAndSet(0);\n      long longestLockHeldIntervalMs \u003d\n          longestReadLockHeldIntervalMs.getAndSet(0);\n      FSNamesystem.LOG.info(\"FSNamesystem read lock held for \" +\n          readLockIntervalMs + \" ms via\\n\" +\n          StringUtils.getStackTrace(Thread.currentThread()) +\n          \"\\tNumber of suppressed read-lock reports: \" + numSuppressedWarnings +\n          \"\\n\\tLongest read-lock held interval: \" + longestLockHeldIntervalMs);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystemLock.java",
      "extendedDetails": {}
    },
    "ff0b99eafeda035ebe0dc82cfe689808047a8893": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-10872. Add MutableRate metrics for FSNamesystemLock operations. Contributed by Erik Krogen.\n",
      "commitDate": "14/11/16 11:05 AM",
      "commitName": "ff0b99eafeda035ebe0dc82cfe689808047a8893",
      "commitAuthor": "Zhe Zhang",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-10872. Add MutableRate metrics for FSNamesystemLock operations. Contributed by Erik Krogen.\n",
          "commitDate": "14/11/16 11:05 AM",
          "commitName": "ff0b99eafeda035ebe0dc82cfe689808047a8893",
          "commitAuthor": "Zhe Zhang",
          "commitDateOld": "30/09/16 1:16 PM",
          "commitNameOld": "434c5ea75dc3d87513e49290ac9999148ff5163c",
          "commitAuthorOld": "Zhe Zhang",
          "daysBetweenCommits": 44.95,
          "commitsBetweenForRepo": 391,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,39 +1,40 @@\n-  public void readUnlock() {\n+  public void readUnlock(String opName) {\n     final boolean needReport \u003d coarseLock.getReadHoldCount() \u003d\u003d 1;\n     final long readLockInterval \u003d\n         timer.monotonicNow() - readLockHeldTimeStamp.get();\n     coarseLock.readLock().unlock();\n \n     if (needReport) {\n+      addMetric(opName, readLockInterval, false);\n       readLockHeldTimeStamp.remove();\n     }\n     if (needReport \u0026\u0026 readLockInterval \u003e\u003d this.readLockReportingThreshold) {\n       long localLongestReadLock;\n       do {\n         localLongestReadLock \u003d longestReadLockHeldInterval.get();\n       } while (localLongestReadLock - readLockInterval \u003c 0 \u0026\u0026\n           !longestReadLockHeldInterval.compareAndSet(localLongestReadLock,\n               readLockInterval));\n \n       long localTimeStampOfLastReadLockReport;\n       long now;\n       do {\n         now \u003d timer.monotonicNow();\n         localTimeStampOfLastReadLockReport \u003d\n             timeStampOfLastReadLockReport.get();\n         if (now - localTimeStampOfLastReadLockReport \u003c\n             lockSuppressWarningInterval) {\n           numReadLockWarningsSuppressed.incrementAndGet();\n           return;\n         }\n       } while (!timeStampOfLastReadLockReport.compareAndSet(\n           localTimeStampOfLastReadLockReport, now));\n       int numSuppressedWarnings \u003d numReadLockWarningsSuppressed.getAndSet(0);\n       long longestLockHeldInterval \u003d longestReadLockHeldInterval.getAndSet(0);\n       FSNamesystem.LOG.info(\"FSNamesystem read lock held for \" +\n           readLockInterval + \" ms via\\n\" +\n           StringUtils.getStackTrace(Thread.currentThread()) +\n           \"\\tNumber of suppressed read-lock reports: \" + numSuppressedWarnings +\n           \"\\n\\tLongest read-lock held interval: \" + longestLockHeldInterval);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void readUnlock(String opName) {\n    final boolean needReport \u003d coarseLock.getReadHoldCount() \u003d\u003d 1;\n    final long readLockInterval \u003d\n        timer.monotonicNow() - readLockHeldTimeStamp.get();\n    coarseLock.readLock().unlock();\n\n    if (needReport) {\n      addMetric(opName, readLockInterval, false);\n      readLockHeldTimeStamp.remove();\n    }\n    if (needReport \u0026\u0026 readLockInterval \u003e\u003d this.readLockReportingThreshold) {\n      long localLongestReadLock;\n      do {\n        localLongestReadLock \u003d longestReadLockHeldInterval.get();\n      } while (localLongestReadLock - readLockInterval \u003c 0 \u0026\u0026\n          !longestReadLockHeldInterval.compareAndSet(localLongestReadLock,\n              readLockInterval));\n\n      long localTimeStampOfLastReadLockReport;\n      long now;\n      do {\n        now \u003d timer.monotonicNow();\n        localTimeStampOfLastReadLockReport \u003d\n            timeStampOfLastReadLockReport.get();\n        if (now - localTimeStampOfLastReadLockReport \u003c\n            lockSuppressWarningInterval) {\n          numReadLockWarningsSuppressed.incrementAndGet();\n          return;\n        }\n      } while (!timeStampOfLastReadLockReport.compareAndSet(\n          localTimeStampOfLastReadLockReport, now));\n      int numSuppressedWarnings \u003d numReadLockWarningsSuppressed.getAndSet(0);\n      long longestLockHeldInterval \u003d longestReadLockHeldInterval.getAndSet(0);\n      FSNamesystem.LOG.info(\"FSNamesystem read lock held for \" +\n          readLockInterval + \" ms via\\n\" +\n          StringUtils.getStackTrace(Thread.currentThread()) +\n          \"\\tNumber of suppressed read-lock reports: \" + numSuppressedWarnings +\n          \"\\n\\tLongest read-lock held interval: \" + longestLockHeldInterval);\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystemLock.java",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[opName-String]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-10872. Add MutableRate metrics for FSNamesystemLock operations. Contributed by Erik Krogen.\n",
          "commitDate": "14/11/16 11:05 AM",
          "commitName": "ff0b99eafeda035ebe0dc82cfe689808047a8893",
          "commitAuthor": "Zhe Zhang",
          "commitDateOld": "30/09/16 1:16 PM",
          "commitNameOld": "434c5ea75dc3d87513e49290ac9999148ff5163c",
          "commitAuthorOld": "Zhe Zhang",
          "daysBetweenCommits": 44.95,
          "commitsBetweenForRepo": 391,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,39 +1,40 @@\n-  public void readUnlock() {\n+  public void readUnlock(String opName) {\n     final boolean needReport \u003d coarseLock.getReadHoldCount() \u003d\u003d 1;\n     final long readLockInterval \u003d\n         timer.monotonicNow() - readLockHeldTimeStamp.get();\n     coarseLock.readLock().unlock();\n \n     if (needReport) {\n+      addMetric(opName, readLockInterval, false);\n       readLockHeldTimeStamp.remove();\n     }\n     if (needReport \u0026\u0026 readLockInterval \u003e\u003d this.readLockReportingThreshold) {\n       long localLongestReadLock;\n       do {\n         localLongestReadLock \u003d longestReadLockHeldInterval.get();\n       } while (localLongestReadLock - readLockInterval \u003c 0 \u0026\u0026\n           !longestReadLockHeldInterval.compareAndSet(localLongestReadLock,\n               readLockInterval));\n \n       long localTimeStampOfLastReadLockReport;\n       long now;\n       do {\n         now \u003d timer.monotonicNow();\n         localTimeStampOfLastReadLockReport \u003d\n             timeStampOfLastReadLockReport.get();\n         if (now - localTimeStampOfLastReadLockReport \u003c\n             lockSuppressWarningInterval) {\n           numReadLockWarningsSuppressed.incrementAndGet();\n           return;\n         }\n       } while (!timeStampOfLastReadLockReport.compareAndSet(\n           localTimeStampOfLastReadLockReport, now));\n       int numSuppressedWarnings \u003d numReadLockWarningsSuppressed.getAndSet(0);\n       long longestLockHeldInterval \u003d longestReadLockHeldInterval.getAndSet(0);\n       FSNamesystem.LOG.info(\"FSNamesystem read lock held for \" +\n           readLockInterval + \" ms via\\n\" +\n           StringUtils.getStackTrace(Thread.currentThread()) +\n           \"\\tNumber of suppressed read-lock reports: \" + numSuppressedWarnings +\n           \"\\n\\tLongest read-lock held interval: \" + longestLockHeldInterval);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void readUnlock(String opName) {\n    final boolean needReport \u003d coarseLock.getReadHoldCount() \u003d\u003d 1;\n    final long readLockInterval \u003d\n        timer.monotonicNow() - readLockHeldTimeStamp.get();\n    coarseLock.readLock().unlock();\n\n    if (needReport) {\n      addMetric(opName, readLockInterval, false);\n      readLockHeldTimeStamp.remove();\n    }\n    if (needReport \u0026\u0026 readLockInterval \u003e\u003d this.readLockReportingThreshold) {\n      long localLongestReadLock;\n      do {\n        localLongestReadLock \u003d longestReadLockHeldInterval.get();\n      } while (localLongestReadLock - readLockInterval \u003c 0 \u0026\u0026\n          !longestReadLockHeldInterval.compareAndSet(localLongestReadLock,\n              readLockInterval));\n\n      long localTimeStampOfLastReadLockReport;\n      long now;\n      do {\n        now \u003d timer.monotonicNow();\n        localTimeStampOfLastReadLockReport \u003d\n            timeStampOfLastReadLockReport.get();\n        if (now - localTimeStampOfLastReadLockReport \u003c\n            lockSuppressWarningInterval) {\n          numReadLockWarningsSuppressed.incrementAndGet();\n          return;\n        }\n      } while (!timeStampOfLastReadLockReport.compareAndSet(\n          localTimeStampOfLastReadLockReport, now));\n      int numSuppressedWarnings \u003d numReadLockWarningsSuppressed.getAndSet(0);\n      long longestLockHeldInterval \u003d longestReadLockHeldInterval.getAndSet(0);\n      FSNamesystem.LOG.info(\"FSNamesystem read lock held for \" +\n          readLockInterval + \" ms via\\n\" +\n          StringUtils.getStackTrace(Thread.currentThread()) +\n          \"\\tNumber of suppressed read-lock reports: \" + numSuppressedWarnings +\n          \"\\n\\tLongest read-lock held interval: \" + longestLockHeldInterval);\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystemLock.java",
          "extendedDetails": {}
        }
      ]
    },
    "434c5ea75dc3d87513e49290ac9999148ff5163c": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-10896. Move lock logging logic from FSNamesystem into FSNamesystemLock. Contributed by Erik Krogen.\n",
      "commitDate": "30/09/16 1:16 PM",
      "commitName": "434c5ea75dc3d87513e49290ac9999148ff5163c",
      "commitAuthor": "Zhe Zhang",
      "diff": "@@ -0,0 +1,39 @@\n+  public void readUnlock() {\n+    final boolean needReport \u003d coarseLock.getReadHoldCount() \u003d\u003d 1;\n+    final long readLockInterval \u003d\n+        timer.monotonicNow() - readLockHeldTimeStamp.get();\n+    coarseLock.readLock().unlock();\n+\n+    if (needReport) {\n+      readLockHeldTimeStamp.remove();\n+    }\n+    if (needReport \u0026\u0026 readLockInterval \u003e\u003d this.readLockReportingThreshold) {\n+      long localLongestReadLock;\n+      do {\n+        localLongestReadLock \u003d longestReadLockHeldInterval.get();\n+      } while (localLongestReadLock - readLockInterval \u003c 0 \u0026\u0026\n+          !longestReadLockHeldInterval.compareAndSet(localLongestReadLock,\n+              readLockInterval));\n+\n+      long localTimeStampOfLastReadLockReport;\n+      long now;\n+      do {\n+        now \u003d timer.monotonicNow();\n+        localTimeStampOfLastReadLockReport \u003d\n+            timeStampOfLastReadLockReport.get();\n+        if (now - localTimeStampOfLastReadLockReport \u003c\n+            lockSuppressWarningInterval) {\n+          numReadLockWarningsSuppressed.incrementAndGet();\n+          return;\n+        }\n+      } while (!timeStampOfLastReadLockReport.compareAndSet(\n+          localTimeStampOfLastReadLockReport, now));\n+      int numSuppressedWarnings \u003d numReadLockWarningsSuppressed.getAndSet(0);\n+      long longestLockHeldInterval \u003d longestReadLockHeldInterval.getAndSet(0);\n+      FSNamesystem.LOG.info(\"FSNamesystem read lock held for \" +\n+          readLockInterval + \" ms via\\n\" +\n+          StringUtils.getStackTrace(Thread.currentThread()) +\n+          \"\\tNumber of suppressed read-lock reports: \" + numSuppressedWarnings +\n+          \"\\n\\tLongest read-lock held interval: \" + longestLockHeldInterval);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void readUnlock() {\n    final boolean needReport \u003d coarseLock.getReadHoldCount() \u003d\u003d 1;\n    final long readLockInterval \u003d\n        timer.monotonicNow() - readLockHeldTimeStamp.get();\n    coarseLock.readLock().unlock();\n\n    if (needReport) {\n      readLockHeldTimeStamp.remove();\n    }\n    if (needReport \u0026\u0026 readLockInterval \u003e\u003d this.readLockReportingThreshold) {\n      long localLongestReadLock;\n      do {\n        localLongestReadLock \u003d longestReadLockHeldInterval.get();\n      } while (localLongestReadLock - readLockInterval \u003c 0 \u0026\u0026\n          !longestReadLockHeldInterval.compareAndSet(localLongestReadLock,\n              readLockInterval));\n\n      long localTimeStampOfLastReadLockReport;\n      long now;\n      do {\n        now \u003d timer.monotonicNow();\n        localTimeStampOfLastReadLockReport \u003d\n            timeStampOfLastReadLockReport.get();\n        if (now - localTimeStampOfLastReadLockReport \u003c\n            lockSuppressWarningInterval) {\n          numReadLockWarningsSuppressed.incrementAndGet();\n          return;\n        }\n      } while (!timeStampOfLastReadLockReport.compareAndSet(\n          localTimeStampOfLastReadLockReport, now));\n      int numSuppressedWarnings \u003d numReadLockWarningsSuppressed.getAndSet(0);\n      long longestLockHeldInterval \u003d longestReadLockHeldInterval.getAndSet(0);\n      FSNamesystem.LOG.info(\"FSNamesystem read lock held for \" +\n          readLockInterval + \" ms via\\n\" +\n          StringUtils.getStackTrace(Thread.currentThread()) +\n          \"\\tNumber of suppressed read-lock reports: \" + numSuppressedWarnings +\n          \"\\n\\tLongest read-lock held interval: \" + longestLockHeldInterval);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystemLock.java"
    }
  }
}