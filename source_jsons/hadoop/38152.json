{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "CapacitySchedulerPreemptionUtils.java",
  "functionName": "tryPreemptContainerAndDeductResToObtain",
  "functionId": "tryPreemptContainerAndDeductResToObtain___rc-ResourceCalculator__context-CapacitySchedulerPreemptionContext__resourceToObtainByPartitions-Map__String,Resource____rmContainer-RMContainer__clusterResource-Resource__preemptMap-Map__ApplicationAttemptId,Set__RMContainer______curCandidates-Map__ApplicationAttemptId,Set__RMContainer______totalPreemptionAllowed-Resource__conservativeDRF-boolean",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/CapacitySchedulerPreemptionUtils.java",
  "functionStartLine": 150,
  "functionEndLine": 228,
  "numCommitsSeen": 51,
  "timeTaken": 10284,
  "changeHistory": [
    "291194302cc1a875d6d94ea93cf1184a3f1fc2cc",
    "8d5509c68156faaa6641f4e747fc9ff80adccf88",
    "e81596d06d226f1cfa44b2390ce3095ed4dee621",
    "c583ab02c730be0a63d974039a78f2dc67dc2db6",
    "90dd3a8148468ac37a3f2173ad8d45e38bfcb0c9",
    "bb62e0592566b2fcae7136b30972aad2d3ac55b0",
    "60e4116bf1d00afed91010e57357fe54057e4e39",
    "ae14e5d07f1b6702a5160637438028bb03d9387e",
    "fa7a43529d529f0006c8033c2003f15b9b93f103",
    "7e8c9beb4156dcaeb3a11e60aaa06d2370626913",
    "d497f6ea2be559aa31ed76f37ae949dbfabe2a51"
  ],
  "changeHistoryShort": {
    "291194302cc1a875d6d94ea93cf1184a3f1fc2cc": "Ymultichange(Yparameterchange,Ybodychange)",
    "8d5509c68156faaa6641f4e747fc9ff80adccf88": "Ymultichange(Yparameterchange,Ybodychange)",
    "e81596d06d226f1cfa44b2390ce3095ed4dee621": "Ybodychange",
    "c583ab02c730be0a63d974039a78f2dc67dc2db6": "Ybodychange",
    "90dd3a8148468ac37a3f2173ad8d45e38bfcb0c9": "Ymultichange(Ymovefromfile,Ymodifierchange,Ybodychange,Yparameterchange)",
    "bb62e0592566b2fcae7136b30972aad2d3ac55b0": "Ybodychange",
    "60e4116bf1d00afed91010e57357fe54057e4e39": "Ymultichange(Ymovefromfile,Ybodychange,Yparameterchange)",
    "ae14e5d07f1b6702a5160637438028bb03d9387e": "Ybodychange",
    "fa7a43529d529f0006c8033c2003f15b9b93f103": "Ybodychange",
    "7e8c9beb4156dcaeb3a11e60aaa06d2370626913": "Ybodychange",
    "d497f6ea2be559aa31ed76f37ae949dbfabe2a51": "Yintroduced"
  },
  "changeHistoryDetails": {
    "291194302cc1a875d6d94ea93cf1184a3f1fc2cc": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-8379. Improve balancing resources in already satisfied queues by using Capacity Scheduler preemption. Contributed by Zian Chen.\n",
      "commitDate": "28/06/18 10:23 AM",
      "commitName": "291194302cc1a875d6d94ea93cf1184a3f1fc2cc",
      "commitAuthor": "Sunil G",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-8379. Improve balancing resources in already satisfied queues by using Capacity Scheduler preemption. Contributed by Zian Chen.\n",
          "commitDate": "28/06/18 10:23 AM",
          "commitName": "291194302cc1a875d6d94ea93cf1184a3f1fc2cc",
          "commitAuthor": "Sunil G",
          "commitDateOld": "29/05/18 9:27 AM",
          "commitNameOld": "17aa40f669f197d43387d67dc00040d14cd00948",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 30.04,
          "commitsBetweenForRepo": 207,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,78 +1,79 @@\n   public static boolean tryPreemptContainerAndDeductResToObtain(\n       ResourceCalculator rc, CapacitySchedulerPreemptionContext context,\n       Map\u003cString, Resource\u003e resourceToObtainByPartitions,\n       RMContainer rmContainer, Resource clusterResource,\n       Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e preemptMap,\n+      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e curCandidates,\n       Resource totalPreemptionAllowed, boolean conservativeDRF) {\n     ApplicationAttemptId attemptId \u003d rmContainer.getApplicationAttemptId();\n \n     // We will not account resource of a container twice or more\n     if (preemptMapContains(preemptMap, attemptId, rmContainer)) {\n       return false;\n     }\n \n     String nodePartition \u003d getPartitionByNodeId(context,\n         rmContainer.getAllocatedNode());\n     Resource toObtainByPartition \u003d resourceToObtainByPartitions\n         .get(nodePartition);\n     if (null \u003d\u003d toObtainByPartition) {\n       return false;\n     }\n \n     // If a toObtain resource type \u003d\u003d 0, set it to -1 to avoid 0 resource\n     // type affect following doPreemption check: isAnyMajorResourceZero\n     for (ResourceInformation ri : toObtainByPartition.getResources()) {\n       if (ri.getValue() \u003d\u003d 0) {\n         ri.setValue(-1);\n       }\n     }\n \n     if (rc.isAnyMajorResourceAboveZero(toObtainByPartition) \u0026\u0026 Resources.fitsIn(\n         rc, rmContainer.getAllocatedResource(), totalPreemptionAllowed)) {\n       boolean doPreempt;\n \n       // How much resource left after preemption happen.\n       Resource toObtainAfterPreemption \u003d Resources.subtract(toObtainByPartition,\n           rmContainer.getAllocatedResource());\n \n       if (conservativeDRF) {\n         doPreempt \u003d !rc.isAnyMajorResourceZeroOrNegative(toObtainByPartition);\n       } else {\n         // When we want to do more aggressive preemption, we will do preemption\n         // only if:\n         // - The preempt of the container makes positive contribution to the\n         //   to-obtain resource. Positive contribution means any positive\n         //   resource type decreases.\n         //\n         //   This is example of positive contribution:\n         //     * before: \u003c30, 10, 5\u003e, after \u003c20, 10, -10\u003e\n         //   But this not positive contribution:\n         //     * before: \u003c30, 10, 0\u003e, after \u003c30, 10, -15\u003e\n         doPreempt \u003d Resources.lessThan(rc, clusterResource,\n             Resources\n                 .componentwiseMax(toObtainAfterPreemption, Resources.none()),\n             Resources.componentwiseMax(toObtainByPartition, Resources.none()));\n       }\n \n       if (!doPreempt) {\n         return false;\n       }\n \n       Resources.subtractFrom(toObtainByPartition,\n           rmContainer.getAllocatedResource());\n       Resources.subtractFrom(totalPreemptionAllowed,\n           rmContainer.getAllocatedResource());\n \n       // When we have no more resource need to obtain, remove from map.\n       if (Resources.lessThanOrEqual(rc, clusterResource, toObtainByPartition,\n           Resources.none())) {\n         resourceToObtainByPartitions.remove(nodePartition);\n       }\n \n       // Add to preemptMap\n-      addToPreemptMap(preemptMap, attemptId, rmContainer);\n+      addToPreemptMap(preemptMap, curCandidates, attemptId, rmContainer);\n       return true;\n     }\n \n     return false;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static boolean tryPreemptContainerAndDeductResToObtain(\n      ResourceCalculator rc, CapacitySchedulerPreemptionContext context,\n      Map\u003cString, Resource\u003e resourceToObtainByPartitions,\n      RMContainer rmContainer, Resource clusterResource,\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e preemptMap,\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e curCandidates,\n      Resource totalPreemptionAllowed, boolean conservativeDRF) {\n    ApplicationAttemptId attemptId \u003d rmContainer.getApplicationAttemptId();\n\n    // We will not account resource of a container twice or more\n    if (preemptMapContains(preemptMap, attemptId, rmContainer)) {\n      return false;\n    }\n\n    String nodePartition \u003d getPartitionByNodeId(context,\n        rmContainer.getAllocatedNode());\n    Resource toObtainByPartition \u003d resourceToObtainByPartitions\n        .get(nodePartition);\n    if (null \u003d\u003d toObtainByPartition) {\n      return false;\n    }\n\n    // If a toObtain resource type \u003d\u003d 0, set it to -1 to avoid 0 resource\n    // type affect following doPreemption check: isAnyMajorResourceZero\n    for (ResourceInformation ri : toObtainByPartition.getResources()) {\n      if (ri.getValue() \u003d\u003d 0) {\n        ri.setValue(-1);\n      }\n    }\n\n    if (rc.isAnyMajorResourceAboveZero(toObtainByPartition) \u0026\u0026 Resources.fitsIn(\n        rc, rmContainer.getAllocatedResource(), totalPreemptionAllowed)) {\n      boolean doPreempt;\n\n      // How much resource left after preemption happen.\n      Resource toObtainAfterPreemption \u003d Resources.subtract(toObtainByPartition,\n          rmContainer.getAllocatedResource());\n\n      if (conservativeDRF) {\n        doPreempt \u003d !rc.isAnyMajorResourceZeroOrNegative(toObtainByPartition);\n      } else {\n        // When we want to do more aggressive preemption, we will do preemption\n        // only if:\n        // - The preempt of the container makes positive contribution to the\n        //   to-obtain resource. Positive contribution means any positive\n        //   resource type decreases.\n        //\n        //   This is example of positive contribution:\n        //     * before: \u003c30, 10, 5\u003e, after \u003c20, 10, -10\u003e\n        //   But this not positive contribution:\n        //     * before: \u003c30, 10, 0\u003e, after \u003c30, 10, -15\u003e\n        doPreempt \u003d Resources.lessThan(rc, clusterResource,\n            Resources\n                .componentwiseMax(toObtainAfterPreemption, Resources.none()),\n            Resources.componentwiseMax(toObtainByPartition, Resources.none()));\n      }\n\n      if (!doPreempt) {\n        return false;\n      }\n\n      Resources.subtractFrom(toObtainByPartition,\n          rmContainer.getAllocatedResource());\n      Resources.subtractFrom(totalPreemptionAllowed,\n          rmContainer.getAllocatedResource());\n\n      // When we have no more resource need to obtain, remove from map.\n      if (Resources.lessThanOrEqual(rc, clusterResource, toObtainByPartition,\n          Resources.none())) {\n        resourceToObtainByPartitions.remove(nodePartition);\n      }\n\n      // Add to preemptMap\n      addToPreemptMap(preemptMap, curCandidates, attemptId, rmContainer);\n      return true;\n    }\n\n    return false;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/CapacitySchedulerPreemptionUtils.java",
          "extendedDetails": {
            "oldValue": "[rc-ResourceCalculator, context-CapacitySchedulerPreemptionContext, resourceToObtainByPartitions-Map\u003cString,Resource\u003e, rmContainer-RMContainer, clusterResource-Resource, preemptMap-Map\u003cApplicationAttemptId,Set\u003cRMContainer\u003e\u003e, totalPreemptionAllowed-Resource, conservativeDRF-boolean]",
            "newValue": "[rc-ResourceCalculator, context-CapacitySchedulerPreemptionContext, resourceToObtainByPartitions-Map\u003cString,Resource\u003e, rmContainer-RMContainer, clusterResource-Resource, preemptMap-Map\u003cApplicationAttemptId,Set\u003cRMContainer\u003e\u003e, curCandidates-Map\u003cApplicationAttemptId,Set\u003cRMContainer\u003e\u003e, totalPreemptionAllowed-Resource, conservativeDRF-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-8379. Improve balancing resources in already satisfied queues by using Capacity Scheduler preemption. Contributed by Zian Chen.\n",
          "commitDate": "28/06/18 10:23 AM",
          "commitName": "291194302cc1a875d6d94ea93cf1184a3f1fc2cc",
          "commitAuthor": "Sunil G",
          "commitDateOld": "29/05/18 9:27 AM",
          "commitNameOld": "17aa40f669f197d43387d67dc00040d14cd00948",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 30.04,
          "commitsBetweenForRepo": 207,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,78 +1,79 @@\n   public static boolean tryPreemptContainerAndDeductResToObtain(\n       ResourceCalculator rc, CapacitySchedulerPreemptionContext context,\n       Map\u003cString, Resource\u003e resourceToObtainByPartitions,\n       RMContainer rmContainer, Resource clusterResource,\n       Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e preemptMap,\n+      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e curCandidates,\n       Resource totalPreemptionAllowed, boolean conservativeDRF) {\n     ApplicationAttemptId attemptId \u003d rmContainer.getApplicationAttemptId();\n \n     // We will not account resource of a container twice or more\n     if (preemptMapContains(preemptMap, attemptId, rmContainer)) {\n       return false;\n     }\n \n     String nodePartition \u003d getPartitionByNodeId(context,\n         rmContainer.getAllocatedNode());\n     Resource toObtainByPartition \u003d resourceToObtainByPartitions\n         .get(nodePartition);\n     if (null \u003d\u003d toObtainByPartition) {\n       return false;\n     }\n \n     // If a toObtain resource type \u003d\u003d 0, set it to -1 to avoid 0 resource\n     // type affect following doPreemption check: isAnyMajorResourceZero\n     for (ResourceInformation ri : toObtainByPartition.getResources()) {\n       if (ri.getValue() \u003d\u003d 0) {\n         ri.setValue(-1);\n       }\n     }\n \n     if (rc.isAnyMajorResourceAboveZero(toObtainByPartition) \u0026\u0026 Resources.fitsIn(\n         rc, rmContainer.getAllocatedResource(), totalPreemptionAllowed)) {\n       boolean doPreempt;\n \n       // How much resource left after preemption happen.\n       Resource toObtainAfterPreemption \u003d Resources.subtract(toObtainByPartition,\n           rmContainer.getAllocatedResource());\n \n       if (conservativeDRF) {\n         doPreempt \u003d !rc.isAnyMajorResourceZeroOrNegative(toObtainByPartition);\n       } else {\n         // When we want to do more aggressive preemption, we will do preemption\n         // only if:\n         // - The preempt of the container makes positive contribution to the\n         //   to-obtain resource. Positive contribution means any positive\n         //   resource type decreases.\n         //\n         //   This is example of positive contribution:\n         //     * before: \u003c30, 10, 5\u003e, after \u003c20, 10, -10\u003e\n         //   But this not positive contribution:\n         //     * before: \u003c30, 10, 0\u003e, after \u003c30, 10, -15\u003e\n         doPreempt \u003d Resources.lessThan(rc, clusterResource,\n             Resources\n                 .componentwiseMax(toObtainAfterPreemption, Resources.none()),\n             Resources.componentwiseMax(toObtainByPartition, Resources.none()));\n       }\n \n       if (!doPreempt) {\n         return false;\n       }\n \n       Resources.subtractFrom(toObtainByPartition,\n           rmContainer.getAllocatedResource());\n       Resources.subtractFrom(totalPreemptionAllowed,\n           rmContainer.getAllocatedResource());\n \n       // When we have no more resource need to obtain, remove from map.\n       if (Resources.lessThanOrEqual(rc, clusterResource, toObtainByPartition,\n           Resources.none())) {\n         resourceToObtainByPartitions.remove(nodePartition);\n       }\n \n       // Add to preemptMap\n-      addToPreemptMap(preemptMap, attemptId, rmContainer);\n+      addToPreemptMap(preemptMap, curCandidates, attemptId, rmContainer);\n       return true;\n     }\n \n     return false;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static boolean tryPreemptContainerAndDeductResToObtain(\n      ResourceCalculator rc, CapacitySchedulerPreemptionContext context,\n      Map\u003cString, Resource\u003e resourceToObtainByPartitions,\n      RMContainer rmContainer, Resource clusterResource,\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e preemptMap,\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e curCandidates,\n      Resource totalPreemptionAllowed, boolean conservativeDRF) {\n    ApplicationAttemptId attemptId \u003d rmContainer.getApplicationAttemptId();\n\n    // We will not account resource of a container twice or more\n    if (preemptMapContains(preemptMap, attemptId, rmContainer)) {\n      return false;\n    }\n\n    String nodePartition \u003d getPartitionByNodeId(context,\n        rmContainer.getAllocatedNode());\n    Resource toObtainByPartition \u003d resourceToObtainByPartitions\n        .get(nodePartition);\n    if (null \u003d\u003d toObtainByPartition) {\n      return false;\n    }\n\n    // If a toObtain resource type \u003d\u003d 0, set it to -1 to avoid 0 resource\n    // type affect following doPreemption check: isAnyMajorResourceZero\n    for (ResourceInformation ri : toObtainByPartition.getResources()) {\n      if (ri.getValue() \u003d\u003d 0) {\n        ri.setValue(-1);\n      }\n    }\n\n    if (rc.isAnyMajorResourceAboveZero(toObtainByPartition) \u0026\u0026 Resources.fitsIn(\n        rc, rmContainer.getAllocatedResource(), totalPreemptionAllowed)) {\n      boolean doPreempt;\n\n      // How much resource left after preemption happen.\n      Resource toObtainAfterPreemption \u003d Resources.subtract(toObtainByPartition,\n          rmContainer.getAllocatedResource());\n\n      if (conservativeDRF) {\n        doPreempt \u003d !rc.isAnyMajorResourceZeroOrNegative(toObtainByPartition);\n      } else {\n        // When we want to do more aggressive preemption, we will do preemption\n        // only if:\n        // - The preempt of the container makes positive contribution to the\n        //   to-obtain resource. Positive contribution means any positive\n        //   resource type decreases.\n        //\n        //   This is example of positive contribution:\n        //     * before: \u003c30, 10, 5\u003e, after \u003c20, 10, -10\u003e\n        //   But this not positive contribution:\n        //     * before: \u003c30, 10, 0\u003e, after \u003c30, 10, -15\u003e\n        doPreempt \u003d Resources.lessThan(rc, clusterResource,\n            Resources\n                .componentwiseMax(toObtainAfterPreemption, Resources.none()),\n            Resources.componentwiseMax(toObtainByPartition, Resources.none()));\n      }\n\n      if (!doPreempt) {\n        return false;\n      }\n\n      Resources.subtractFrom(toObtainByPartition,\n          rmContainer.getAllocatedResource());\n      Resources.subtractFrom(totalPreemptionAllowed,\n          rmContainer.getAllocatedResource());\n\n      // When we have no more resource need to obtain, remove from map.\n      if (Resources.lessThanOrEqual(rc, clusterResource, toObtainByPartition,\n          Resources.none())) {\n        resourceToObtainByPartitions.remove(nodePartition);\n      }\n\n      // Add to preemptMap\n      addToPreemptMap(preemptMap, curCandidates, attemptId, rmContainer);\n      return true;\n    }\n\n    return false;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/CapacitySchedulerPreemptionUtils.java",
          "extendedDetails": {}
        }
      ]
    },
    "8d5509c68156faaa6641f4e747fc9ff80adccf88": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-8292: Fix the dominant resource preemption cannot happen when some of the resource vector becomes negative. Contributed by Wangda Tan.\n",
      "commitDate": "25/05/18 9:06 AM",
      "commitName": "8d5509c68156faaa6641f4e747fc9ff80adccf88",
      "commitAuthor": "Eric E Payne",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-8292: Fix the dominant resource preemption cannot happen when some of the resource vector becomes negative. Contributed by Wangda Tan.\n",
          "commitDate": "25/05/18 9:06 AM",
          "commitName": "8d5509c68156faaa6641f4e747fc9ff80adccf88",
          "commitAuthor": "Eric E Payne",
          "commitDateOld": "17/09/17 9:20 PM",
          "commitNameOld": "e81596d06d226f1cfa44b2390ce3095ed4dee621",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 249.49,
          "commitsBetweenForRepo": 2369,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,42 +1,78 @@\n   public static boolean tryPreemptContainerAndDeductResToObtain(\n       ResourceCalculator rc, CapacitySchedulerPreemptionContext context,\n       Map\u003cString, Resource\u003e resourceToObtainByPartitions,\n       RMContainer rmContainer, Resource clusterResource,\n       Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e preemptMap,\n-      Resource totalPreemptionAllowed) {\n+      Resource totalPreemptionAllowed, boolean conservativeDRF) {\n     ApplicationAttemptId attemptId \u003d rmContainer.getApplicationAttemptId();\n \n     // We will not account resource of a container twice or more\n     if (preemptMapContains(preemptMap, attemptId, rmContainer)) {\n       return false;\n     }\n \n     String nodePartition \u003d getPartitionByNodeId(context,\n         rmContainer.getAllocatedNode());\n     Resource toObtainByPartition \u003d resourceToObtainByPartitions\n         .get(nodePartition);\n+    if (null \u003d\u003d toObtainByPartition) {\n+      return false;\n+    }\n \n-    if (null !\u003d toObtainByPartition\n-        \u0026\u0026 Resources.greaterThan(rc, clusterResource, toObtainByPartition,\n-            Resources.none())\n-        \u0026\u0026 Resources.fitsIn(rc, rmContainer.getAllocatedResource(),\n-            totalPreemptionAllowed)\n-        \u0026\u0026 !Resources.isAnyMajorResourceZero(rc, toObtainByPartition)) {\n+    // If a toObtain resource type \u003d\u003d 0, set it to -1 to avoid 0 resource\n+    // type affect following doPreemption check: isAnyMajorResourceZero\n+    for (ResourceInformation ri : toObtainByPartition.getResources()) {\n+      if (ri.getValue() \u003d\u003d 0) {\n+        ri.setValue(-1);\n+      }\n+    }\n+\n+    if (rc.isAnyMajorResourceAboveZero(toObtainByPartition) \u0026\u0026 Resources.fitsIn(\n+        rc, rmContainer.getAllocatedResource(), totalPreemptionAllowed)) {\n+      boolean doPreempt;\n+\n+      // How much resource left after preemption happen.\n+      Resource toObtainAfterPreemption \u003d Resources.subtract(toObtainByPartition,\n+          rmContainer.getAllocatedResource());\n+\n+      if (conservativeDRF) {\n+        doPreempt \u003d !rc.isAnyMajorResourceZeroOrNegative(toObtainByPartition);\n+      } else {\n+        // When we want to do more aggressive preemption, we will do preemption\n+        // only if:\n+        // - The preempt of the container makes positive contribution to the\n+        //   to-obtain resource. Positive contribution means any positive\n+        //   resource type decreases.\n+        //\n+        //   This is example of positive contribution:\n+        //     * before: \u003c30, 10, 5\u003e, after \u003c20, 10, -10\u003e\n+        //   But this not positive contribution:\n+        //     * before: \u003c30, 10, 0\u003e, after \u003c30, 10, -15\u003e\n+        doPreempt \u003d Resources.lessThan(rc, clusterResource,\n+            Resources\n+                .componentwiseMax(toObtainAfterPreemption, Resources.none()),\n+            Resources.componentwiseMax(toObtainByPartition, Resources.none()));\n+      }\n+\n+      if (!doPreempt) {\n+        return false;\n+      }\n+\n       Resources.subtractFrom(toObtainByPartition,\n           rmContainer.getAllocatedResource());\n       Resources.subtractFrom(totalPreemptionAllowed,\n           rmContainer.getAllocatedResource());\n \n       // When we have no more resource need to obtain, remove from map.\n       if (Resources.lessThanOrEqual(rc, clusterResource, toObtainByPartition,\n           Resources.none())) {\n         resourceToObtainByPartitions.remove(nodePartition);\n       }\n \n       // Add to preemptMap\n       addToPreemptMap(preemptMap, attemptId, rmContainer);\n       return true;\n     }\n \n     return false;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static boolean tryPreemptContainerAndDeductResToObtain(\n      ResourceCalculator rc, CapacitySchedulerPreemptionContext context,\n      Map\u003cString, Resource\u003e resourceToObtainByPartitions,\n      RMContainer rmContainer, Resource clusterResource,\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e preemptMap,\n      Resource totalPreemptionAllowed, boolean conservativeDRF) {\n    ApplicationAttemptId attemptId \u003d rmContainer.getApplicationAttemptId();\n\n    // We will not account resource of a container twice or more\n    if (preemptMapContains(preemptMap, attemptId, rmContainer)) {\n      return false;\n    }\n\n    String nodePartition \u003d getPartitionByNodeId(context,\n        rmContainer.getAllocatedNode());\n    Resource toObtainByPartition \u003d resourceToObtainByPartitions\n        .get(nodePartition);\n    if (null \u003d\u003d toObtainByPartition) {\n      return false;\n    }\n\n    // If a toObtain resource type \u003d\u003d 0, set it to -1 to avoid 0 resource\n    // type affect following doPreemption check: isAnyMajorResourceZero\n    for (ResourceInformation ri : toObtainByPartition.getResources()) {\n      if (ri.getValue() \u003d\u003d 0) {\n        ri.setValue(-1);\n      }\n    }\n\n    if (rc.isAnyMajorResourceAboveZero(toObtainByPartition) \u0026\u0026 Resources.fitsIn(\n        rc, rmContainer.getAllocatedResource(), totalPreemptionAllowed)) {\n      boolean doPreempt;\n\n      // How much resource left after preemption happen.\n      Resource toObtainAfterPreemption \u003d Resources.subtract(toObtainByPartition,\n          rmContainer.getAllocatedResource());\n\n      if (conservativeDRF) {\n        doPreempt \u003d !rc.isAnyMajorResourceZeroOrNegative(toObtainByPartition);\n      } else {\n        // When we want to do more aggressive preemption, we will do preemption\n        // only if:\n        // - The preempt of the container makes positive contribution to the\n        //   to-obtain resource. Positive contribution means any positive\n        //   resource type decreases.\n        //\n        //   This is example of positive contribution:\n        //     * before: \u003c30, 10, 5\u003e, after \u003c20, 10, -10\u003e\n        //   But this not positive contribution:\n        //     * before: \u003c30, 10, 0\u003e, after \u003c30, 10, -15\u003e\n        doPreempt \u003d Resources.lessThan(rc, clusterResource,\n            Resources\n                .componentwiseMax(toObtainAfterPreemption, Resources.none()),\n            Resources.componentwiseMax(toObtainByPartition, Resources.none()));\n      }\n\n      if (!doPreempt) {\n        return false;\n      }\n\n      Resources.subtractFrom(toObtainByPartition,\n          rmContainer.getAllocatedResource());\n      Resources.subtractFrom(totalPreemptionAllowed,\n          rmContainer.getAllocatedResource());\n\n      // When we have no more resource need to obtain, remove from map.\n      if (Resources.lessThanOrEqual(rc, clusterResource, toObtainByPartition,\n          Resources.none())) {\n        resourceToObtainByPartitions.remove(nodePartition);\n      }\n\n      // Add to preemptMap\n      addToPreemptMap(preemptMap, attemptId, rmContainer);\n      return true;\n    }\n\n    return false;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/CapacitySchedulerPreemptionUtils.java",
          "extendedDetails": {
            "oldValue": "[rc-ResourceCalculator, context-CapacitySchedulerPreemptionContext, resourceToObtainByPartitions-Map\u003cString,Resource\u003e, rmContainer-RMContainer, clusterResource-Resource, preemptMap-Map\u003cApplicationAttemptId,Set\u003cRMContainer\u003e\u003e, totalPreemptionAllowed-Resource]",
            "newValue": "[rc-ResourceCalculator, context-CapacitySchedulerPreemptionContext, resourceToObtainByPartitions-Map\u003cString,Resource\u003e, rmContainer-RMContainer, clusterResource-Resource, preemptMap-Map\u003cApplicationAttemptId,Set\u003cRMContainer\u003e\u003e, totalPreemptionAllowed-Resource, conservativeDRF-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-8292: Fix the dominant resource preemption cannot happen when some of the resource vector becomes negative. Contributed by Wangda Tan.\n",
          "commitDate": "25/05/18 9:06 AM",
          "commitName": "8d5509c68156faaa6641f4e747fc9ff80adccf88",
          "commitAuthor": "Eric E Payne",
          "commitDateOld": "17/09/17 9:20 PM",
          "commitNameOld": "e81596d06d226f1cfa44b2390ce3095ed4dee621",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 249.49,
          "commitsBetweenForRepo": 2369,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,42 +1,78 @@\n   public static boolean tryPreemptContainerAndDeductResToObtain(\n       ResourceCalculator rc, CapacitySchedulerPreemptionContext context,\n       Map\u003cString, Resource\u003e resourceToObtainByPartitions,\n       RMContainer rmContainer, Resource clusterResource,\n       Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e preemptMap,\n-      Resource totalPreemptionAllowed) {\n+      Resource totalPreemptionAllowed, boolean conservativeDRF) {\n     ApplicationAttemptId attemptId \u003d rmContainer.getApplicationAttemptId();\n \n     // We will not account resource of a container twice or more\n     if (preemptMapContains(preemptMap, attemptId, rmContainer)) {\n       return false;\n     }\n \n     String nodePartition \u003d getPartitionByNodeId(context,\n         rmContainer.getAllocatedNode());\n     Resource toObtainByPartition \u003d resourceToObtainByPartitions\n         .get(nodePartition);\n+    if (null \u003d\u003d toObtainByPartition) {\n+      return false;\n+    }\n \n-    if (null !\u003d toObtainByPartition\n-        \u0026\u0026 Resources.greaterThan(rc, clusterResource, toObtainByPartition,\n-            Resources.none())\n-        \u0026\u0026 Resources.fitsIn(rc, rmContainer.getAllocatedResource(),\n-            totalPreemptionAllowed)\n-        \u0026\u0026 !Resources.isAnyMajorResourceZero(rc, toObtainByPartition)) {\n+    // If a toObtain resource type \u003d\u003d 0, set it to -1 to avoid 0 resource\n+    // type affect following doPreemption check: isAnyMajorResourceZero\n+    for (ResourceInformation ri : toObtainByPartition.getResources()) {\n+      if (ri.getValue() \u003d\u003d 0) {\n+        ri.setValue(-1);\n+      }\n+    }\n+\n+    if (rc.isAnyMajorResourceAboveZero(toObtainByPartition) \u0026\u0026 Resources.fitsIn(\n+        rc, rmContainer.getAllocatedResource(), totalPreemptionAllowed)) {\n+      boolean doPreempt;\n+\n+      // How much resource left after preemption happen.\n+      Resource toObtainAfterPreemption \u003d Resources.subtract(toObtainByPartition,\n+          rmContainer.getAllocatedResource());\n+\n+      if (conservativeDRF) {\n+        doPreempt \u003d !rc.isAnyMajorResourceZeroOrNegative(toObtainByPartition);\n+      } else {\n+        // When we want to do more aggressive preemption, we will do preemption\n+        // only if:\n+        // - The preempt of the container makes positive contribution to the\n+        //   to-obtain resource. Positive contribution means any positive\n+        //   resource type decreases.\n+        //\n+        //   This is example of positive contribution:\n+        //     * before: \u003c30, 10, 5\u003e, after \u003c20, 10, -10\u003e\n+        //   But this not positive contribution:\n+        //     * before: \u003c30, 10, 0\u003e, after \u003c30, 10, -15\u003e\n+        doPreempt \u003d Resources.lessThan(rc, clusterResource,\n+            Resources\n+                .componentwiseMax(toObtainAfterPreemption, Resources.none()),\n+            Resources.componentwiseMax(toObtainByPartition, Resources.none()));\n+      }\n+\n+      if (!doPreempt) {\n+        return false;\n+      }\n+\n       Resources.subtractFrom(toObtainByPartition,\n           rmContainer.getAllocatedResource());\n       Resources.subtractFrom(totalPreemptionAllowed,\n           rmContainer.getAllocatedResource());\n \n       // When we have no more resource need to obtain, remove from map.\n       if (Resources.lessThanOrEqual(rc, clusterResource, toObtainByPartition,\n           Resources.none())) {\n         resourceToObtainByPartitions.remove(nodePartition);\n       }\n \n       // Add to preemptMap\n       addToPreemptMap(preemptMap, attemptId, rmContainer);\n       return true;\n     }\n \n     return false;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static boolean tryPreemptContainerAndDeductResToObtain(\n      ResourceCalculator rc, CapacitySchedulerPreemptionContext context,\n      Map\u003cString, Resource\u003e resourceToObtainByPartitions,\n      RMContainer rmContainer, Resource clusterResource,\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e preemptMap,\n      Resource totalPreemptionAllowed, boolean conservativeDRF) {\n    ApplicationAttemptId attemptId \u003d rmContainer.getApplicationAttemptId();\n\n    // We will not account resource of a container twice or more\n    if (preemptMapContains(preemptMap, attemptId, rmContainer)) {\n      return false;\n    }\n\n    String nodePartition \u003d getPartitionByNodeId(context,\n        rmContainer.getAllocatedNode());\n    Resource toObtainByPartition \u003d resourceToObtainByPartitions\n        .get(nodePartition);\n    if (null \u003d\u003d toObtainByPartition) {\n      return false;\n    }\n\n    // If a toObtain resource type \u003d\u003d 0, set it to -1 to avoid 0 resource\n    // type affect following doPreemption check: isAnyMajorResourceZero\n    for (ResourceInformation ri : toObtainByPartition.getResources()) {\n      if (ri.getValue() \u003d\u003d 0) {\n        ri.setValue(-1);\n      }\n    }\n\n    if (rc.isAnyMajorResourceAboveZero(toObtainByPartition) \u0026\u0026 Resources.fitsIn(\n        rc, rmContainer.getAllocatedResource(), totalPreemptionAllowed)) {\n      boolean doPreempt;\n\n      // How much resource left after preemption happen.\n      Resource toObtainAfterPreemption \u003d Resources.subtract(toObtainByPartition,\n          rmContainer.getAllocatedResource());\n\n      if (conservativeDRF) {\n        doPreempt \u003d !rc.isAnyMajorResourceZeroOrNegative(toObtainByPartition);\n      } else {\n        // When we want to do more aggressive preemption, we will do preemption\n        // only if:\n        // - The preempt of the container makes positive contribution to the\n        //   to-obtain resource. Positive contribution means any positive\n        //   resource type decreases.\n        //\n        //   This is example of positive contribution:\n        //     * before: \u003c30, 10, 5\u003e, after \u003c20, 10, -10\u003e\n        //   But this not positive contribution:\n        //     * before: \u003c30, 10, 0\u003e, after \u003c30, 10, -15\u003e\n        doPreempt \u003d Resources.lessThan(rc, clusterResource,\n            Resources\n                .componentwiseMax(toObtainAfterPreemption, Resources.none()),\n            Resources.componentwiseMax(toObtainByPartition, Resources.none()));\n      }\n\n      if (!doPreempt) {\n        return false;\n      }\n\n      Resources.subtractFrom(toObtainByPartition,\n          rmContainer.getAllocatedResource());\n      Resources.subtractFrom(totalPreemptionAllowed,\n          rmContainer.getAllocatedResource());\n\n      // When we have no more resource need to obtain, remove from map.\n      if (Resources.lessThanOrEqual(rc, clusterResource, toObtainByPartition,\n          Resources.none())) {\n        resourceToObtainByPartitions.remove(nodePartition);\n      }\n\n      // Add to preemptMap\n      addToPreemptMap(preemptMap, attemptId, rmContainer);\n      return true;\n    }\n\n    return false;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/CapacitySchedulerPreemptionUtils.java",
          "extendedDetails": {}
        }
      ]
    },
    "e81596d06d226f1cfa44b2390ce3095ed4dee621": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7172. ResourceCalculator.fitsIn() should not take a cluster resource parameter. (Sen Zhao via wangda)\n\nChange-Id: Icc3670c9381ce7591ca69ec12da5aa52d3612d34\n",
      "commitDate": "17/09/17 9:20 PM",
      "commitName": "e81596d06d226f1cfa44b2390ce3095ed4dee621",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "22/05/17 2:26 PM",
      "commitNameOld": "c583ab02c730be0a63d974039a78f2dc67dc2db6",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 118.29,
      "commitsBetweenForRepo": 821,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,42 @@\n   public static boolean tryPreemptContainerAndDeductResToObtain(\n       ResourceCalculator rc, CapacitySchedulerPreemptionContext context,\n       Map\u003cString, Resource\u003e resourceToObtainByPartitions,\n       RMContainer rmContainer, Resource clusterResource,\n       Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e preemptMap,\n       Resource totalPreemptionAllowed) {\n     ApplicationAttemptId attemptId \u003d rmContainer.getApplicationAttemptId();\n \n     // We will not account resource of a container twice or more\n     if (preemptMapContains(preemptMap, attemptId, rmContainer)) {\n       return false;\n     }\n \n     String nodePartition \u003d getPartitionByNodeId(context,\n         rmContainer.getAllocatedNode());\n     Resource toObtainByPartition \u003d resourceToObtainByPartitions\n         .get(nodePartition);\n \n     if (null !\u003d toObtainByPartition\n         \u0026\u0026 Resources.greaterThan(rc, clusterResource, toObtainByPartition,\n             Resources.none())\n-        \u0026\u0026 Resources.fitsIn(rc, clusterResource,\n-            rmContainer.getAllocatedResource(), totalPreemptionAllowed)\n+        \u0026\u0026 Resources.fitsIn(rc, rmContainer.getAllocatedResource(),\n+            totalPreemptionAllowed)\n         \u0026\u0026 !Resources.isAnyMajorResourceZero(rc, toObtainByPartition)) {\n       Resources.subtractFrom(toObtainByPartition,\n           rmContainer.getAllocatedResource());\n       Resources.subtractFrom(totalPreemptionAllowed,\n           rmContainer.getAllocatedResource());\n \n       // When we have no more resource need to obtain, remove from map.\n       if (Resources.lessThanOrEqual(rc, clusterResource, toObtainByPartition,\n           Resources.none())) {\n         resourceToObtainByPartitions.remove(nodePartition);\n       }\n \n       // Add to preemptMap\n       addToPreemptMap(preemptMap, attemptId, rmContainer);\n       return true;\n     }\n \n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static boolean tryPreemptContainerAndDeductResToObtain(\n      ResourceCalculator rc, CapacitySchedulerPreemptionContext context,\n      Map\u003cString, Resource\u003e resourceToObtainByPartitions,\n      RMContainer rmContainer, Resource clusterResource,\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e preemptMap,\n      Resource totalPreemptionAllowed) {\n    ApplicationAttemptId attemptId \u003d rmContainer.getApplicationAttemptId();\n\n    // We will not account resource of a container twice or more\n    if (preemptMapContains(preemptMap, attemptId, rmContainer)) {\n      return false;\n    }\n\n    String nodePartition \u003d getPartitionByNodeId(context,\n        rmContainer.getAllocatedNode());\n    Resource toObtainByPartition \u003d resourceToObtainByPartitions\n        .get(nodePartition);\n\n    if (null !\u003d toObtainByPartition\n        \u0026\u0026 Resources.greaterThan(rc, clusterResource, toObtainByPartition,\n            Resources.none())\n        \u0026\u0026 Resources.fitsIn(rc, rmContainer.getAllocatedResource(),\n            totalPreemptionAllowed)\n        \u0026\u0026 !Resources.isAnyMajorResourceZero(rc, toObtainByPartition)) {\n      Resources.subtractFrom(toObtainByPartition,\n          rmContainer.getAllocatedResource());\n      Resources.subtractFrom(totalPreemptionAllowed,\n          rmContainer.getAllocatedResource());\n\n      // When we have no more resource need to obtain, remove from map.\n      if (Resources.lessThanOrEqual(rc, clusterResource, toObtainByPartition,\n          Resources.none())) {\n        resourceToObtainByPartitions.remove(nodePartition);\n      }\n\n      // Add to preemptMap\n      addToPreemptMap(preemptMap, attemptId, rmContainer);\n      return true;\n    }\n\n    return false;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/CapacitySchedulerPreemptionUtils.java",
      "extendedDetails": {}
    },
    "c583ab02c730be0a63d974039a78f2dc67dc2db6": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2113. Add cross-user preemption within CapacityScheduler\u0027s leaf-queue. (Sunil G via wangda)\n\nChange-Id: I9b19f69788068be05b3295247cdd7b972f8a573c\n",
      "commitDate": "22/05/17 2:26 PM",
      "commitName": "c583ab02c730be0a63d974039a78f2dc67dc2db6",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "31/10/16 3:18 PM",
      "commitNameOld": "90dd3a8148468ac37a3f2173ad8d45e38bfcb0c9",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 202.96,
      "commitsBetweenForRepo": 1155,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,42 @@\n   public static boolean tryPreemptContainerAndDeductResToObtain(\n       ResourceCalculator rc, CapacitySchedulerPreemptionContext context,\n       Map\u003cString, Resource\u003e resourceToObtainByPartitions,\n       RMContainer rmContainer, Resource clusterResource,\n       Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e preemptMap,\n       Resource totalPreemptionAllowed) {\n     ApplicationAttemptId attemptId \u003d rmContainer.getApplicationAttemptId();\n \n     // We will not account resource of a container twice or more\n     if (preemptMapContains(preemptMap, attemptId, rmContainer)) {\n       return false;\n     }\n \n     String nodePartition \u003d getPartitionByNodeId(context,\n         rmContainer.getAllocatedNode());\n     Resource toObtainByPartition \u003d resourceToObtainByPartitions\n         .get(nodePartition);\n \n     if (null !\u003d toObtainByPartition\n         \u0026\u0026 Resources.greaterThan(rc, clusterResource, toObtainByPartition,\n             Resources.none())\n         \u0026\u0026 Resources.fitsIn(rc, clusterResource,\n-            rmContainer.getAllocatedResource(), totalPreemptionAllowed)) {\n+            rmContainer.getAllocatedResource(), totalPreemptionAllowed)\n+        \u0026\u0026 !Resources.isAnyMajorResourceZero(rc, toObtainByPartition)) {\n       Resources.subtractFrom(toObtainByPartition,\n           rmContainer.getAllocatedResource());\n       Resources.subtractFrom(totalPreemptionAllowed,\n           rmContainer.getAllocatedResource());\n \n       // When we have no more resource need to obtain, remove from map.\n       if (Resources.lessThanOrEqual(rc, clusterResource, toObtainByPartition,\n           Resources.none())) {\n         resourceToObtainByPartitions.remove(nodePartition);\n       }\n \n       // Add to preemptMap\n       addToPreemptMap(preemptMap, attemptId, rmContainer);\n       return true;\n     }\n \n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static boolean tryPreemptContainerAndDeductResToObtain(\n      ResourceCalculator rc, CapacitySchedulerPreemptionContext context,\n      Map\u003cString, Resource\u003e resourceToObtainByPartitions,\n      RMContainer rmContainer, Resource clusterResource,\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e preemptMap,\n      Resource totalPreemptionAllowed) {\n    ApplicationAttemptId attemptId \u003d rmContainer.getApplicationAttemptId();\n\n    // We will not account resource of a container twice or more\n    if (preemptMapContains(preemptMap, attemptId, rmContainer)) {\n      return false;\n    }\n\n    String nodePartition \u003d getPartitionByNodeId(context,\n        rmContainer.getAllocatedNode());\n    Resource toObtainByPartition \u003d resourceToObtainByPartitions\n        .get(nodePartition);\n\n    if (null !\u003d toObtainByPartition\n        \u0026\u0026 Resources.greaterThan(rc, clusterResource, toObtainByPartition,\n            Resources.none())\n        \u0026\u0026 Resources.fitsIn(rc, clusterResource,\n            rmContainer.getAllocatedResource(), totalPreemptionAllowed)\n        \u0026\u0026 !Resources.isAnyMajorResourceZero(rc, toObtainByPartition)) {\n      Resources.subtractFrom(toObtainByPartition,\n          rmContainer.getAllocatedResource());\n      Resources.subtractFrom(totalPreemptionAllowed,\n          rmContainer.getAllocatedResource());\n\n      // When we have no more resource need to obtain, remove from map.\n      if (Resources.lessThanOrEqual(rc, clusterResource, toObtainByPartition,\n          Resources.none())) {\n        resourceToObtainByPartitions.remove(nodePartition);\n      }\n\n      // Add to preemptMap\n      addToPreemptMap(preemptMap, attemptId, rmContainer);\n      return true;\n    }\n\n    return false;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/CapacitySchedulerPreemptionUtils.java",
      "extendedDetails": {}
    },
    "90dd3a8148468ac37a3f2173ad8d45e38bfcb0c9": {
      "type": "Ymultichange(Ymovefromfile,Ymodifierchange,Ybodychange,Yparameterchange)",
      "commitMessage": "YARN-2009. CapacityScheduler: Add intra-queue preemption for app priority support. (Sunil G via wangda)\n",
      "commitDate": "31/10/16 3:18 PM",
      "commitName": "90dd3a8148468ac37a3f2173ad8d45e38bfcb0c9",
      "commitAuthor": "Wangda Tan",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "YARN-2009. CapacityScheduler: Add intra-queue preemption for app priority support. (Sunil G via wangda)\n",
          "commitDate": "31/10/16 3:18 PM",
          "commitName": "90dd3a8148468ac37a3f2173ad8d45e38bfcb0c9",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "31/10/16 2:47 PM",
          "commitNameOld": "773c60bd7bd00651dc3016799b424b9bd2233eb3",
          "commitAuthorOld": "Daniel Templeton",
          "daysBetweenCommits": 0.02,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,42 +1,41 @@\n-  private boolean tryPreemptContainerAndDeductResToObtain(\n+  public static boolean tryPreemptContainerAndDeductResToObtain(\n+      ResourceCalculator rc, CapacitySchedulerPreemptionContext context,\n       Map\u003cString, Resource\u003e resourceToObtainByPartitions,\n       RMContainer rmContainer, Resource clusterResource,\n       Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e preemptMap,\n       Resource totalPreemptionAllowed) {\n     ApplicationAttemptId attemptId \u003d rmContainer.getApplicationAttemptId();\n \n     // We will not account resource of a container twice or more\n     if (preemptMapContains(preemptMap, attemptId, rmContainer)) {\n       return false;\n     }\n \n-    String nodePartition \u003d getPartitionByNodeId(rmContainer.getAllocatedNode());\n-    Resource toObtainByPartition \u003d\n-        resourceToObtainByPartitions.get(nodePartition);\n+    String nodePartition \u003d getPartitionByNodeId(context,\n+        rmContainer.getAllocatedNode());\n+    Resource toObtainByPartition \u003d resourceToObtainByPartitions\n+        .get(nodePartition);\n \n-    if (null !\u003d toObtainByPartition \u0026\u0026 Resources.greaterThan(rc,\n-        clusterResource, toObtainByPartition, Resources.none()) \u0026\u0026 Resources\n-        .fitsIn(rc, clusterResource, rmContainer.getAllocatedResource(),\n-            totalPreemptionAllowed)) {\n+    if (null !\u003d toObtainByPartition\n+        \u0026\u0026 Resources.greaterThan(rc, clusterResource, toObtainByPartition,\n+            Resources.none())\n+        \u0026\u0026 Resources.fitsIn(rc, clusterResource,\n+            rmContainer.getAllocatedResource(), totalPreemptionAllowed)) {\n       Resources.subtractFrom(toObtainByPartition,\n           rmContainer.getAllocatedResource());\n       Resources.subtractFrom(totalPreemptionAllowed,\n           rmContainer.getAllocatedResource());\n \n       // When we have no more resource need to obtain, remove from map.\n       if (Resources.lessThanOrEqual(rc, clusterResource, toObtainByPartition,\n           Resources.none())) {\n         resourceToObtainByPartitions.remove(nodePartition);\n       }\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(this.getClass().getName() + \" Marked container\u003d\" + rmContainer\n-            .getContainerId() + \" from partition\u003d\" + nodePartition + \" queue\u003d\"\n-            + rmContainer.getQueueName() + \" to be preemption candidates\");\n-      }\n+\n       // Add to preemptMap\n       addToPreemptMap(preemptMap, attemptId, rmContainer);\n       return true;\n     }\n \n     return false;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static boolean tryPreemptContainerAndDeductResToObtain(\n      ResourceCalculator rc, CapacitySchedulerPreemptionContext context,\n      Map\u003cString, Resource\u003e resourceToObtainByPartitions,\n      RMContainer rmContainer, Resource clusterResource,\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e preemptMap,\n      Resource totalPreemptionAllowed) {\n    ApplicationAttemptId attemptId \u003d rmContainer.getApplicationAttemptId();\n\n    // We will not account resource of a container twice or more\n    if (preemptMapContains(preemptMap, attemptId, rmContainer)) {\n      return false;\n    }\n\n    String nodePartition \u003d getPartitionByNodeId(context,\n        rmContainer.getAllocatedNode());\n    Resource toObtainByPartition \u003d resourceToObtainByPartitions\n        .get(nodePartition);\n\n    if (null !\u003d toObtainByPartition\n        \u0026\u0026 Resources.greaterThan(rc, clusterResource, toObtainByPartition,\n            Resources.none())\n        \u0026\u0026 Resources.fitsIn(rc, clusterResource,\n            rmContainer.getAllocatedResource(), totalPreemptionAllowed)) {\n      Resources.subtractFrom(toObtainByPartition,\n          rmContainer.getAllocatedResource());\n      Resources.subtractFrom(totalPreemptionAllowed,\n          rmContainer.getAllocatedResource());\n\n      // When we have no more resource need to obtain, remove from map.\n      if (Resources.lessThanOrEqual(rc, clusterResource, toObtainByPartition,\n          Resources.none())) {\n        resourceToObtainByPartitions.remove(nodePartition);\n      }\n\n      // Add to preemptMap\n      addToPreemptMap(preemptMap, attemptId, rmContainer);\n      return true;\n    }\n\n    return false;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/CapacitySchedulerPreemptionUtils.java",
          "extendedDetails": {
            "oldPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/FifoCandidatesSelector.java",
            "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/CapacitySchedulerPreemptionUtils.java",
            "oldMethodName": "tryPreemptContainerAndDeductResToObtain",
            "newMethodName": "tryPreemptContainerAndDeductResToObtain"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "YARN-2009. CapacityScheduler: Add intra-queue preemption for app priority support. (Sunil G via wangda)\n",
          "commitDate": "31/10/16 3:18 PM",
          "commitName": "90dd3a8148468ac37a3f2173ad8d45e38bfcb0c9",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "31/10/16 2:47 PM",
          "commitNameOld": "773c60bd7bd00651dc3016799b424b9bd2233eb3",
          "commitAuthorOld": "Daniel Templeton",
          "daysBetweenCommits": 0.02,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,42 +1,41 @@\n-  private boolean tryPreemptContainerAndDeductResToObtain(\n+  public static boolean tryPreemptContainerAndDeductResToObtain(\n+      ResourceCalculator rc, CapacitySchedulerPreemptionContext context,\n       Map\u003cString, Resource\u003e resourceToObtainByPartitions,\n       RMContainer rmContainer, Resource clusterResource,\n       Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e preemptMap,\n       Resource totalPreemptionAllowed) {\n     ApplicationAttemptId attemptId \u003d rmContainer.getApplicationAttemptId();\n \n     // We will not account resource of a container twice or more\n     if (preemptMapContains(preemptMap, attemptId, rmContainer)) {\n       return false;\n     }\n \n-    String nodePartition \u003d getPartitionByNodeId(rmContainer.getAllocatedNode());\n-    Resource toObtainByPartition \u003d\n-        resourceToObtainByPartitions.get(nodePartition);\n+    String nodePartition \u003d getPartitionByNodeId(context,\n+        rmContainer.getAllocatedNode());\n+    Resource toObtainByPartition \u003d resourceToObtainByPartitions\n+        .get(nodePartition);\n \n-    if (null !\u003d toObtainByPartition \u0026\u0026 Resources.greaterThan(rc,\n-        clusterResource, toObtainByPartition, Resources.none()) \u0026\u0026 Resources\n-        .fitsIn(rc, clusterResource, rmContainer.getAllocatedResource(),\n-            totalPreemptionAllowed)) {\n+    if (null !\u003d toObtainByPartition\n+        \u0026\u0026 Resources.greaterThan(rc, clusterResource, toObtainByPartition,\n+            Resources.none())\n+        \u0026\u0026 Resources.fitsIn(rc, clusterResource,\n+            rmContainer.getAllocatedResource(), totalPreemptionAllowed)) {\n       Resources.subtractFrom(toObtainByPartition,\n           rmContainer.getAllocatedResource());\n       Resources.subtractFrom(totalPreemptionAllowed,\n           rmContainer.getAllocatedResource());\n \n       // When we have no more resource need to obtain, remove from map.\n       if (Resources.lessThanOrEqual(rc, clusterResource, toObtainByPartition,\n           Resources.none())) {\n         resourceToObtainByPartitions.remove(nodePartition);\n       }\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(this.getClass().getName() + \" Marked container\u003d\" + rmContainer\n-            .getContainerId() + \" from partition\u003d\" + nodePartition + \" queue\u003d\"\n-            + rmContainer.getQueueName() + \" to be preemption candidates\");\n-      }\n+\n       // Add to preemptMap\n       addToPreemptMap(preemptMap, attemptId, rmContainer);\n       return true;\n     }\n \n     return false;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static boolean tryPreemptContainerAndDeductResToObtain(\n      ResourceCalculator rc, CapacitySchedulerPreemptionContext context,\n      Map\u003cString, Resource\u003e resourceToObtainByPartitions,\n      RMContainer rmContainer, Resource clusterResource,\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e preemptMap,\n      Resource totalPreemptionAllowed) {\n    ApplicationAttemptId attemptId \u003d rmContainer.getApplicationAttemptId();\n\n    // We will not account resource of a container twice or more\n    if (preemptMapContains(preemptMap, attemptId, rmContainer)) {\n      return false;\n    }\n\n    String nodePartition \u003d getPartitionByNodeId(context,\n        rmContainer.getAllocatedNode());\n    Resource toObtainByPartition \u003d resourceToObtainByPartitions\n        .get(nodePartition);\n\n    if (null !\u003d toObtainByPartition\n        \u0026\u0026 Resources.greaterThan(rc, clusterResource, toObtainByPartition,\n            Resources.none())\n        \u0026\u0026 Resources.fitsIn(rc, clusterResource,\n            rmContainer.getAllocatedResource(), totalPreemptionAllowed)) {\n      Resources.subtractFrom(toObtainByPartition,\n          rmContainer.getAllocatedResource());\n      Resources.subtractFrom(totalPreemptionAllowed,\n          rmContainer.getAllocatedResource());\n\n      // When we have no more resource need to obtain, remove from map.\n      if (Resources.lessThanOrEqual(rc, clusterResource, toObtainByPartition,\n          Resources.none())) {\n        resourceToObtainByPartitions.remove(nodePartition);\n      }\n\n      // Add to preemptMap\n      addToPreemptMap(preemptMap, attemptId, rmContainer);\n      return true;\n    }\n\n    return false;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/CapacitySchedulerPreemptionUtils.java",
          "extendedDetails": {
            "oldValue": "[private]",
            "newValue": "[public, static]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-2009. CapacityScheduler: Add intra-queue preemption for app priority support. (Sunil G via wangda)\n",
          "commitDate": "31/10/16 3:18 PM",
          "commitName": "90dd3a8148468ac37a3f2173ad8d45e38bfcb0c9",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "31/10/16 2:47 PM",
          "commitNameOld": "773c60bd7bd00651dc3016799b424b9bd2233eb3",
          "commitAuthorOld": "Daniel Templeton",
          "daysBetweenCommits": 0.02,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,42 +1,41 @@\n-  private boolean tryPreemptContainerAndDeductResToObtain(\n+  public static boolean tryPreemptContainerAndDeductResToObtain(\n+      ResourceCalculator rc, CapacitySchedulerPreemptionContext context,\n       Map\u003cString, Resource\u003e resourceToObtainByPartitions,\n       RMContainer rmContainer, Resource clusterResource,\n       Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e preemptMap,\n       Resource totalPreemptionAllowed) {\n     ApplicationAttemptId attemptId \u003d rmContainer.getApplicationAttemptId();\n \n     // We will not account resource of a container twice or more\n     if (preemptMapContains(preemptMap, attemptId, rmContainer)) {\n       return false;\n     }\n \n-    String nodePartition \u003d getPartitionByNodeId(rmContainer.getAllocatedNode());\n-    Resource toObtainByPartition \u003d\n-        resourceToObtainByPartitions.get(nodePartition);\n+    String nodePartition \u003d getPartitionByNodeId(context,\n+        rmContainer.getAllocatedNode());\n+    Resource toObtainByPartition \u003d resourceToObtainByPartitions\n+        .get(nodePartition);\n \n-    if (null !\u003d toObtainByPartition \u0026\u0026 Resources.greaterThan(rc,\n-        clusterResource, toObtainByPartition, Resources.none()) \u0026\u0026 Resources\n-        .fitsIn(rc, clusterResource, rmContainer.getAllocatedResource(),\n-            totalPreemptionAllowed)) {\n+    if (null !\u003d toObtainByPartition\n+        \u0026\u0026 Resources.greaterThan(rc, clusterResource, toObtainByPartition,\n+            Resources.none())\n+        \u0026\u0026 Resources.fitsIn(rc, clusterResource,\n+            rmContainer.getAllocatedResource(), totalPreemptionAllowed)) {\n       Resources.subtractFrom(toObtainByPartition,\n           rmContainer.getAllocatedResource());\n       Resources.subtractFrom(totalPreemptionAllowed,\n           rmContainer.getAllocatedResource());\n \n       // When we have no more resource need to obtain, remove from map.\n       if (Resources.lessThanOrEqual(rc, clusterResource, toObtainByPartition,\n           Resources.none())) {\n         resourceToObtainByPartitions.remove(nodePartition);\n       }\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(this.getClass().getName() + \" Marked container\u003d\" + rmContainer\n-            .getContainerId() + \" from partition\u003d\" + nodePartition + \" queue\u003d\"\n-            + rmContainer.getQueueName() + \" to be preemption candidates\");\n-      }\n+\n       // Add to preemptMap\n       addToPreemptMap(preemptMap, attemptId, rmContainer);\n       return true;\n     }\n \n     return false;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static boolean tryPreemptContainerAndDeductResToObtain(\n      ResourceCalculator rc, CapacitySchedulerPreemptionContext context,\n      Map\u003cString, Resource\u003e resourceToObtainByPartitions,\n      RMContainer rmContainer, Resource clusterResource,\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e preemptMap,\n      Resource totalPreemptionAllowed) {\n    ApplicationAttemptId attemptId \u003d rmContainer.getApplicationAttemptId();\n\n    // We will not account resource of a container twice or more\n    if (preemptMapContains(preemptMap, attemptId, rmContainer)) {\n      return false;\n    }\n\n    String nodePartition \u003d getPartitionByNodeId(context,\n        rmContainer.getAllocatedNode());\n    Resource toObtainByPartition \u003d resourceToObtainByPartitions\n        .get(nodePartition);\n\n    if (null !\u003d toObtainByPartition\n        \u0026\u0026 Resources.greaterThan(rc, clusterResource, toObtainByPartition,\n            Resources.none())\n        \u0026\u0026 Resources.fitsIn(rc, clusterResource,\n            rmContainer.getAllocatedResource(), totalPreemptionAllowed)) {\n      Resources.subtractFrom(toObtainByPartition,\n          rmContainer.getAllocatedResource());\n      Resources.subtractFrom(totalPreemptionAllowed,\n          rmContainer.getAllocatedResource());\n\n      // When we have no more resource need to obtain, remove from map.\n      if (Resources.lessThanOrEqual(rc, clusterResource, toObtainByPartition,\n          Resources.none())) {\n        resourceToObtainByPartitions.remove(nodePartition);\n      }\n\n      // Add to preemptMap\n      addToPreemptMap(preemptMap, attemptId, rmContainer);\n      return true;\n    }\n\n    return false;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/CapacitySchedulerPreemptionUtils.java",
          "extendedDetails": {}
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-2009. CapacityScheduler: Add intra-queue preemption for app priority support. (Sunil G via wangda)\n",
          "commitDate": "31/10/16 3:18 PM",
          "commitName": "90dd3a8148468ac37a3f2173ad8d45e38bfcb0c9",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "31/10/16 2:47 PM",
          "commitNameOld": "773c60bd7bd00651dc3016799b424b9bd2233eb3",
          "commitAuthorOld": "Daniel Templeton",
          "daysBetweenCommits": 0.02,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,42 +1,41 @@\n-  private boolean tryPreemptContainerAndDeductResToObtain(\n+  public static boolean tryPreemptContainerAndDeductResToObtain(\n+      ResourceCalculator rc, CapacitySchedulerPreemptionContext context,\n       Map\u003cString, Resource\u003e resourceToObtainByPartitions,\n       RMContainer rmContainer, Resource clusterResource,\n       Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e preemptMap,\n       Resource totalPreemptionAllowed) {\n     ApplicationAttemptId attemptId \u003d rmContainer.getApplicationAttemptId();\n \n     // We will not account resource of a container twice or more\n     if (preemptMapContains(preemptMap, attemptId, rmContainer)) {\n       return false;\n     }\n \n-    String nodePartition \u003d getPartitionByNodeId(rmContainer.getAllocatedNode());\n-    Resource toObtainByPartition \u003d\n-        resourceToObtainByPartitions.get(nodePartition);\n+    String nodePartition \u003d getPartitionByNodeId(context,\n+        rmContainer.getAllocatedNode());\n+    Resource toObtainByPartition \u003d resourceToObtainByPartitions\n+        .get(nodePartition);\n \n-    if (null !\u003d toObtainByPartition \u0026\u0026 Resources.greaterThan(rc,\n-        clusterResource, toObtainByPartition, Resources.none()) \u0026\u0026 Resources\n-        .fitsIn(rc, clusterResource, rmContainer.getAllocatedResource(),\n-            totalPreemptionAllowed)) {\n+    if (null !\u003d toObtainByPartition\n+        \u0026\u0026 Resources.greaterThan(rc, clusterResource, toObtainByPartition,\n+            Resources.none())\n+        \u0026\u0026 Resources.fitsIn(rc, clusterResource,\n+            rmContainer.getAllocatedResource(), totalPreemptionAllowed)) {\n       Resources.subtractFrom(toObtainByPartition,\n           rmContainer.getAllocatedResource());\n       Resources.subtractFrom(totalPreemptionAllowed,\n           rmContainer.getAllocatedResource());\n \n       // When we have no more resource need to obtain, remove from map.\n       if (Resources.lessThanOrEqual(rc, clusterResource, toObtainByPartition,\n           Resources.none())) {\n         resourceToObtainByPartitions.remove(nodePartition);\n       }\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(this.getClass().getName() + \" Marked container\u003d\" + rmContainer\n-            .getContainerId() + \" from partition\u003d\" + nodePartition + \" queue\u003d\"\n-            + rmContainer.getQueueName() + \" to be preemption candidates\");\n-      }\n+\n       // Add to preemptMap\n       addToPreemptMap(preemptMap, attemptId, rmContainer);\n       return true;\n     }\n \n     return false;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static boolean tryPreemptContainerAndDeductResToObtain(\n      ResourceCalculator rc, CapacitySchedulerPreemptionContext context,\n      Map\u003cString, Resource\u003e resourceToObtainByPartitions,\n      RMContainer rmContainer, Resource clusterResource,\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e preemptMap,\n      Resource totalPreemptionAllowed) {\n    ApplicationAttemptId attemptId \u003d rmContainer.getApplicationAttemptId();\n\n    // We will not account resource of a container twice or more\n    if (preemptMapContains(preemptMap, attemptId, rmContainer)) {\n      return false;\n    }\n\n    String nodePartition \u003d getPartitionByNodeId(context,\n        rmContainer.getAllocatedNode());\n    Resource toObtainByPartition \u003d resourceToObtainByPartitions\n        .get(nodePartition);\n\n    if (null !\u003d toObtainByPartition\n        \u0026\u0026 Resources.greaterThan(rc, clusterResource, toObtainByPartition,\n            Resources.none())\n        \u0026\u0026 Resources.fitsIn(rc, clusterResource,\n            rmContainer.getAllocatedResource(), totalPreemptionAllowed)) {\n      Resources.subtractFrom(toObtainByPartition,\n          rmContainer.getAllocatedResource());\n      Resources.subtractFrom(totalPreemptionAllowed,\n          rmContainer.getAllocatedResource());\n\n      // When we have no more resource need to obtain, remove from map.\n      if (Resources.lessThanOrEqual(rc, clusterResource, toObtainByPartition,\n          Resources.none())) {\n        resourceToObtainByPartitions.remove(nodePartition);\n      }\n\n      // Add to preemptMap\n      addToPreemptMap(preemptMap, attemptId, rmContainer);\n      return true;\n    }\n\n    return false;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/CapacitySchedulerPreemptionUtils.java",
          "extendedDetails": {
            "oldValue": "[resourceToObtainByPartitions-Map\u003cString,Resource\u003e, rmContainer-RMContainer, clusterResource-Resource, preemptMap-Map\u003cApplicationAttemptId,Set\u003cRMContainer\u003e\u003e, totalPreemptionAllowed-Resource]",
            "newValue": "[rc-ResourceCalculator, context-CapacitySchedulerPreemptionContext, resourceToObtainByPartitions-Map\u003cString,Resource\u003e, rmContainer-RMContainer, clusterResource-Resource, preemptMap-Map\u003cApplicationAttemptId,Set\u003cRMContainer\u003e\u003e, totalPreemptionAllowed-Resource]"
          }
        }
      ]
    },
    "bb62e0592566b2fcae7136b30972aad2d3ac55b0": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4390. Do surgical preemption based on reserved container in CapacityScheduler. Contributed by Wangda Tan\n",
      "commitDate": "05/05/16 12:56 PM",
      "commitName": "bb62e0592566b2fcae7136b30972aad2d3ac55b0",
      "commitAuthor": "Jian He",
      "commitDateOld": "30/03/16 12:43 PM",
      "commitNameOld": "60e4116bf1d00afed91010e57357fe54057e4e39",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 36.01,
      "commitsBetweenForRepo": 225,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,42 @@\n   private boolean tryPreemptContainerAndDeductResToObtain(\n       Map\u003cString, Resource\u003e resourceToObtainByPartitions,\n       RMContainer rmContainer, Resource clusterResource,\n       Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e preemptMap,\n       Resource totalPreemptionAllowed) {\n     ApplicationAttemptId attemptId \u003d rmContainer.getApplicationAttemptId();\n \n     // We will not account resource of a container twice or more\n     if (preemptMapContains(preemptMap, attemptId, rmContainer)) {\n       return false;\n     }\n \n     String nodePartition \u003d getPartitionByNodeId(rmContainer.getAllocatedNode());\n     Resource toObtainByPartition \u003d\n         resourceToObtainByPartitions.get(nodePartition);\n \n     if (null !\u003d toObtainByPartition \u0026\u0026 Resources.greaterThan(rc,\n         clusterResource, toObtainByPartition, Resources.none()) \u0026\u0026 Resources\n         .fitsIn(rc, clusterResource, rmContainer.getAllocatedResource(),\n             totalPreemptionAllowed)) {\n       Resources.subtractFrom(toObtainByPartition,\n           rmContainer.getAllocatedResource());\n       Resources.subtractFrom(totalPreemptionAllowed,\n           rmContainer.getAllocatedResource());\n \n       // When we have no more resource need to obtain, remove from map.\n       if (Resources.lessThanOrEqual(rc, clusterResource, toObtainByPartition,\n           Resources.none())) {\n         resourceToObtainByPartitions.remove(nodePartition);\n       }\n       if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"Marked container\u003d\" + rmContainer.getContainerId()\n-            + \" in partition\u003d\" + nodePartition\n-            + \" to be preemption candidates\");\n+        LOG.debug(this.getClass().getName() + \" Marked container\u003d\" + rmContainer\n+            .getContainerId() + \" from partition\u003d\" + nodePartition + \" queue\u003d\"\n+            + rmContainer.getQueueName() + \" to be preemption candidates\");\n       }\n       // Add to preemptMap\n       addToPreemptMap(preemptMap, attemptId, rmContainer);\n       return true;\n     }\n \n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean tryPreemptContainerAndDeductResToObtain(\n      Map\u003cString, Resource\u003e resourceToObtainByPartitions,\n      RMContainer rmContainer, Resource clusterResource,\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e preemptMap,\n      Resource totalPreemptionAllowed) {\n    ApplicationAttemptId attemptId \u003d rmContainer.getApplicationAttemptId();\n\n    // We will not account resource of a container twice or more\n    if (preemptMapContains(preemptMap, attemptId, rmContainer)) {\n      return false;\n    }\n\n    String nodePartition \u003d getPartitionByNodeId(rmContainer.getAllocatedNode());\n    Resource toObtainByPartition \u003d\n        resourceToObtainByPartitions.get(nodePartition);\n\n    if (null !\u003d toObtainByPartition \u0026\u0026 Resources.greaterThan(rc,\n        clusterResource, toObtainByPartition, Resources.none()) \u0026\u0026 Resources\n        .fitsIn(rc, clusterResource, rmContainer.getAllocatedResource(),\n            totalPreemptionAllowed)) {\n      Resources.subtractFrom(toObtainByPartition,\n          rmContainer.getAllocatedResource());\n      Resources.subtractFrom(totalPreemptionAllowed,\n          rmContainer.getAllocatedResource());\n\n      // When we have no more resource need to obtain, remove from map.\n      if (Resources.lessThanOrEqual(rc, clusterResource, toObtainByPartition,\n          Resources.none())) {\n        resourceToObtainByPartitions.remove(nodePartition);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(this.getClass().getName() + \" Marked container\u003d\" + rmContainer\n            .getContainerId() + \" from partition\u003d\" + nodePartition + \" queue\u003d\"\n            + rmContainer.getQueueName() + \" to be preemption candidates\");\n      }\n      // Add to preemptMap\n      addToPreemptMap(preemptMap, attemptId, rmContainer);\n      return true;\n    }\n\n    return false;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/FifoCandidatesSelector.java",
      "extendedDetails": {}
    },
    "60e4116bf1d00afed91010e57357fe54057e4e39": {
      "type": "Ymultichange(Ymovefromfile,Ybodychange,Yparameterchange)",
      "commitMessage": "YARN-4822. Refactor existing Preemption Policy of CS for easier adding new approach to select preemption candidates. Contributed by Wangda Tan\n",
      "commitDate": "30/03/16 12:43 PM",
      "commitName": "60e4116bf1d00afed91010e57357fe54057e4e39",
      "commitAuthor": "Jian He",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "YARN-4822. Refactor existing Preemption Policy of CS for easier adding new approach to select preemption candidates. Contributed by Wangda Tan\n",
          "commitDate": "30/03/16 12:43 PM",
          "commitName": "60e4116bf1d00afed91010e57357fe54057e4e39",
          "commitAuthor": "Jian He",
          "commitDateOld": "29/03/16 11:22 PM",
          "commitNameOld": "09d63d5a192b5d6b172f94ff6c94da348fd49ea6",
          "commitAuthorOld": "Vinayakumar B",
          "daysBetweenCommits": 0.56,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,36 +1,42 @@\n   private boolean tryPreemptContainerAndDeductResToObtain(\n       Map\u003cString, Resource\u003e resourceToObtainByPartitions,\n       RMContainer rmContainer, Resource clusterResource,\n-      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e preemptMap) {\n+      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e preemptMap,\n+      Resource totalPreemptionAllowed) {\n     ApplicationAttemptId attemptId \u003d rmContainer.getApplicationAttemptId();\n \n     // We will not account resource of a container twice or more\n     if (preemptMapContains(preemptMap, attemptId, rmContainer)) {\n       return false;\n     }\n \n-    String nodePartition \u003d getPartitionByRMContainer(rmContainer);\n+    String nodePartition \u003d getPartitionByNodeId(rmContainer.getAllocatedNode());\n     Resource toObtainByPartition \u003d\n         resourceToObtainByPartitions.get(nodePartition);\n \n-    if (null !\u003d toObtainByPartition\n-        \u0026\u0026 Resources.greaterThan(rc, clusterResource, toObtainByPartition,\n-            Resources.none())) {\n+    if (null !\u003d toObtainByPartition \u0026\u0026 Resources.greaterThan(rc,\n+        clusterResource, toObtainByPartition, Resources.none()) \u0026\u0026 Resources\n+        .fitsIn(rc, clusterResource, rmContainer.getAllocatedResource(),\n+            totalPreemptionAllowed)) {\n       Resources.subtractFrom(toObtainByPartition,\n           rmContainer.getAllocatedResource());\n+      Resources.subtractFrom(totalPreemptionAllowed,\n+          rmContainer.getAllocatedResource());\n+\n       // When we have no more resource need to obtain, remove from map.\n       if (Resources.lessThanOrEqual(rc, clusterResource, toObtainByPartition,\n           Resources.none())) {\n         resourceToObtainByPartitions.remove(nodePartition);\n       }\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Marked container\u003d\" + rmContainer.getContainerId()\n-            + \" in partition\u003d\" + nodePartition + \" will be preempted\");\n+            + \" in partition\u003d\" + nodePartition\n+            + \" to be preemption candidates\");\n       }\n       // Add to preemptMap\n       addToPreemptMap(preemptMap, attemptId, rmContainer);\n       return true;\n     }\n \n     return false;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private boolean tryPreemptContainerAndDeductResToObtain(\n      Map\u003cString, Resource\u003e resourceToObtainByPartitions,\n      RMContainer rmContainer, Resource clusterResource,\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e preemptMap,\n      Resource totalPreemptionAllowed) {\n    ApplicationAttemptId attemptId \u003d rmContainer.getApplicationAttemptId();\n\n    // We will not account resource of a container twice or more\n    if (preemptMapContains(preemptMap, attemptId, rmContainer)) {\n      return false;\n    }\n\n    String nodePartition \u003d getPartitionByNodeId(rmContainer.getAllocatedNode());\n    Resource toObtainByPartition \u003d\n        resourceToObtainByPartitions.get(nodePartition);\n\n    if (null !\u003d toObtainByPartition \u0026\u0026 Resources.greaterThan(rc,\n        clusterResource, toObtainByPartition, Resources.none()) \u0026\u0026 Resources\n        .fitsIn(rc, clusterResource, rmContainer.getAllocatedResource(),\n            totalPreemptionAllowed)) {\n      Resources.subtractFrom(toObtainByPartition,\n          rmContainer.getAllocatedResource());\n      Resources.subtractFrom(totalPreemptionAllowed,\n          rmContainer.getAllocatedResource());\n\n      // When we have no more resource need to obtain, remove from map.\n      if (Resources.lessThanOrEqual(rc, clusterResource, toObtainByPartition,\n          Resources.none())) {\n        resourceToObtainByPartitions.remove(nodePartition);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Marked container\u003d\" + rmContainer.getContainerId()\n            + \" in partition\u003d\" + nodePartition\n            + \" to be preemption candidates\");\n      }\n      // Add to preemptMap\n      addToPreemptMap(preemptMap, attemptId, rmContainer);\n      return true;\n    }\n\n    return false;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/FifoCandidatesSelector.java",
          "extendedDetails": {
            "oldPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java",
            "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/FifoCandidatesSelector.java",
            "oldMethodName": "tryPreemptContainerAndDeductResToObtain",
            "newMethodName": "tryPreemptContainerAndDeductResToObtain"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-4822. Refactor existing Preemption Policy of CS for easier adding new approach to select preemption candidates. Contributed by Wangda Tan\n",
          "commitDate": "30/03/16 12:43 PM",
          "commitName": "60e4116bf1d00afed91010e57357fe54057e4e39",
          "commitAuthor": "Jian He",
          "commitDateOld": "29/03/16 11:22 PM",
          "commitNameOld": "09d63d5a192b5d6b172f94ff6c94da348fd49ea6",
          "commitAuthorOld": "Vinayakumar B",
          "daysBetweenCommits": 0.56,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,36 +1,42 @@\n   private boolean tryPreemptContainerAndDeductResToObtain(\n       Map\u003cString, Resource\u003e resourceToObtainByPartitions,\n       RMContainer rmContainer, Resource clusterResource,\n-      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e preemptMap) {\n+      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e preemptMap,\n+      Resource totalPreemptionAllowed) {\n     ApplicationAttemptId attemptId \u003d rmContainer.getApplicationAttemptId();\n \n     // We will not account resource of a container twice or more\n     if (preemptMapContains(preemptMap, attemptId, rmContainer)) {\n       return false;\n     }\n \n-    String nodePartition \u003d getPartitionByRMContainer(rmContainer);\n+    String nodePartition \u003d getPartitionByNodeId(rmContainer.getAllocatedNode());\n     Resource toObtainByPartition \u003d\n         resourceToObtainByPartitions.get(nodePartition);\n \n-    if (null !\u003d toObtainByPartition\n-        \u0026\u0026 Resources.greaterThan(rc, clusterResource, toObtainByPartition,\n-            Resources.none())) {\n+    if (null !\u003d toObtainByPartition \u0026\u0026 Resources.greaterThan(rc,\n+        clusterResource, toObtainByPartition, Resources.none()) \u0026\u0026 Resources\n+        .fitsIn(rc, clusterResource, rmContainer.getAllocatedResource(),\n+            totalPreemptionAllowed)) {\n       Resources.subtractFrom(toObtainByPartition,\n           rmContainer.getAllocatedResource());\n+      Resources.subtractFrom(totalPreemptionAllowed,\n+          rmContainer.getAllocatedResource());\n+\n       // When we have no more resource need to obtain, remove from map.\n       if (Resources.lessThanOrEqual(rc, clusterResource, toObtainByPartition,\n           Resources.none())) {\n         resourceToObtainByPartitions.remove(nodePartition);\n       }\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Marked container\u003d\" + rmContainer.getContainerId()\n-            + \" in partition\u003d\" + nodePartition + \" will be preempted\");\n+            + \" in partition\u003d\" + nodePartition\n+            + \" to be preemption candidates\");\n       }\n       // Add to preemptMap\n       addToPreemptMap(preemptMap, attemptId, rmContainer);\n       return true;\n     }\n \n     return false;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private boolean tryPreemptContainerAndDeductResToObtain(\n      Map\u003cString, Resource\u003e resourceToObtainByPartitions,\n      RMContainer rmContainer, Resource clusterResource,\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e preemptMap,\n      Resource totalPreemptionAllowed) {\n    ApplicationAttemptId attemptId \u003d rmContainer.getApplicationAttemptId();\n\n    // We will not account resource of a container twice or more\n    if (preemptMapContains(preemptMap, attemptId, rmContainer)) {\n      return false;\n    }\n\n    String nodePartition \u003d getPartitionByNodeId(rmContainer.getAllocatedNode());\n    Resource toObtainByPartition \u003d\n        resourceToObtainByPartitions.get(nodePartition);\n\n    if (null !\u003d toObtainByPartition \u0026\u0026 Resources.greaterThan(rc,\n        clusterResource, toObtainByPartition, Resources.none()) \u0026\u0026 Resources\n        .fitsIn(rc, clusterResource, rmContainer.getAllocatedResource(),\n            totalPreemptionAllowed)) {\n      Resources.subtractFrom(toObtainByPartition,\n          rmContainer.getAllocatedResource());\n      Resources.subtractFrom(totalPreemptionAllowed,\n          rmContainer.getAllocatedResource());\n\n      // When we have no more resource need to obtain, remove from map.\n      if (Resources.lessThanOrEqual(rc, clusterResource, toObtainByPartition,\n          Resources.none())) {\n        resourceToObtainByPartitions.remove(nodePartition);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Marked container\u003d\" + rmContainer.getContainerId()\n            + \" in partition\u003d\" + nodePartition\n            + \" to be preemption candidates\");\n      }\n      // Add to preemptMap\n      addToPreemptMap(preemptMap, attemptId, rmContainer);\n      return true;\n    }\n\n    return false;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/FifoCandidatesSelector.java",
          "extendedDetails": {}
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-4822. Refactor existing Preemption Policy of CS for easier adding new approach to select preemption candidates. Contributed by Wangda Tan\n",
          "commitDate": "30/03/16 12:43 PM",
          "commitName": "60e4116bf1d00afed91010e57357fe54057e4e39",
          "commitAuthor": "Jian He",
          "commitDateOld": "29/03/16 11:22 PM",
          "commitNameOld": "09d63d5a192b5d6b172f94ff6c94da348fd49ea6",
          "commitAuthorOld": "Vinayakumar B",
          "daysBetweenCommits": 0.56,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,36 +1,42 @@\n   private boolean tryPreemptContainerAndDeductResToObtain(\n       Map\u003cString, Resource\u003e resourceToObtainByPartitions,\n       RMContainer rmContainer, Resource clusterResource,\n-      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e preemptMap) {\n+      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e preemptMap,\n+      Resource totalPreemptionAllowed) {\n     ApplicationAttemptId attemptId \u003d rmContainer.getApplicationAttemptId();\n \n     // We will not account resource of a container twice or more\n     if (preemptMapContains(preemptMap, attemptId, rmContainer)) {\n       return false;\n     }\n \n-    String nodePartition \u003d getPartitionByRMContainer(rmContainer);\n+    String nodePartition \u003d getPartitionByNodeId(rmContainer.getAllocatedNode());\n     Resource toObtainByPartition \u003d\n         resourceToObtainByPartitions.get(nodePartition);\n \n-    if (null !\u003d toObtainByPartition\n-        \u0026\u0026 Resources.greaterThan(rc, clusterResource, toObtainByPartition,\n-            Resources.none())) {\n+    if (null !\u003d toObtainByPartition \u0026\u0026 Resources.greaterThan(rc,\n+        clusterResource, toObtainByPartition, Resources.none()) \u0026\u0026 Resources\n+        .fitsIn(rc, clusterResource, rmContainer.getAllocatedResource(),\n+            totalPreemptionAllowed)) {\n       Resources.subtractFrom(toObtainByPartition,\n           rmContainer.getAllocatedResource());\n+      Resources.subtractFrom(totalPreemptionAllowed,\n+          rmContainer.getAllocatedResource());\n+\n       // When we have no more resource need to obtain, remove from map.\n       if (Resources.lessThanOrEqual(rc, clusterResource, toObtainByPartition,\n           Resources.none())) {\n         resourceToObtainByPartitions.remove(nodePartition);\n       }\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Marked container\u003d\" + rmContainer.getContainerId()\n-            + \" in partition\u003d\" + nodePartition + \" will be preempted\");\n+            + \" in partition\u003d\" + nodePartition\n+            + \" to be preemption candidates\");\n       }\n       // Add to preemptMap\n       addToPreemptMap(preemptMap, attemptId, rmContainer);\n       return true;\n     }\n \n     return false;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private boolean tryPreemptContainerAndDeductResToObtain(\n      Map\u003cString, Resource\u003e resourceToObtainByPartitions,\n      RMContainer rmContainer, Resource clusterResource,\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e preemptMap,\n      Resource totalPreemptionAllowed) {\n    ApplicationAttemptId attemptId \u003d rmContainer.getApplicationAttemptId();\n\n    // We will not account resource of a container twice or more\n    if (preemptMapContains(preemptMap, attemptId, rmContainer)) {\n      return false;\n    }\n\n    String nodePartition \u003d getPartitionByNodeId(rmContainer.getAllocatedNode());\n    Resource toObtainByPartition \u003d\n        resourceToObtainByPartitions.get(nodePartition);\n\n    if (null !\u003d toObtainByPartition \u0026\u0026 Resources.greaterThan(rc,\n        clusterResource, toObtainByPartition, Resources.none()) \u0026\u0026 Resources\n        .fitsIn(rc, clusterResource, rmContainer.getAllocatedResource(),\n            totalPreemptionAllowed)) {\n      Resources.subtractFrom(toObtainByPartition,\n          rmContainer.getAllocatedResource());\n      Resources.subtractFrom(totalPreemptionAllowed,\n          rmContainer.getAllocatedResource());\n\n      // When we have no more resource need to obtain, remove from map.\n      if (Resources.lessThanOrEqual(rc, clusterResource, toObtainByPartition,\n          Resources.none())) {\n        resourceToObtainByPartitions.remove(nodePartition);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Marked container\u003d\" + rmContainer.getContainerId()\n            + \" in partition\u003d\" + nodePartition\n            + \" to be preemption candidates\");\n      }\n      // Add to preemptMap\n      addToPreemptMap(preemptMap, attemptId, rmContainer);\n      return true;\n    }\n\n    return false;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/FifoCandidatesSelector.java",
          "extendedDetails": {
            "oldValue": "[resourceToObtainByPartitions-Map\u003cString,Resource\u003e, rmContainer-RMContainer, clusterResource-Resource, preemptMap-Map\u003cApplicationAttemptId,Set\u003cRMContainer\u003e\u003e]",
            "newValue": "[resourceToObtainByPartitions-Map\u003cString,Resource\u003e, rmContainer-RMContainer, clusterResource-Resource, preemptMap-Map\u003cApplicationAttemptId,Set\u003cRMContainer\u003e\u003e, totalPreemptionAllowed-Resource]"
          }
        }
      ]
    },
    "ae14e5d07f1b6702a5160637438028bb03d9387e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4108. CapacityScheduler: Improve preemption to only kill containers that would satisfy the incoming request. (Wangda Tan)\n\n(cherry picked from commit 7e8c9beb4156dcaeb3a11e60aaa06d2370626913)\n",
      "commitDate": "16/03/16 5:02 PM",
      "commitName": "ae14e5d07f1b6702a5160637438028bb03d9387e",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "16/03/16 5:02 PM",
      "commitNameOld": "fa7a43529d529f0006c8033c2003f15b9b93f103",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,36 +1,36 @@\n   private boolean tryPreemptContainerAndDeductResToObtain(\n       Map\u003cString, Resource\u003e resourceToObtainByPartitions,\n       RMContainer rmContainer, Resource clusterResource,\n       Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e preemptMap) {\n     ApplicationAttemptId attemptId \u003d rmContainer.getApplicationAttemptId();\n \n     // We will not account resource of a container twice or more\n     if (preemptMapContains(preemptMap, attemptId, rmContainer)) {\n       return false;\n     }\n \n-    String nodePartition \u003d getPartitionByNodeId(rmContainer.getAllocatedNode());\n+    String nodePartition \u003d getPartitionByRMContainer(rmContainer);\n     Resource toObtainByPartition \u003d\n         resourceToObtainByPartitions.get(nodePartition);\n \n     if (null !\u003d toObtainByPartition\n         \u0026\u0026 Resources.greaterThan(rc, clusterResource, toObtainByPartition,\n             Resources.none())) {\n       Resources.subtractFrom(toObtainByPartition,\n           rmContainer.getAllocatedResource());\n       // When we have no more resource need to obtain, remove from map.\n       if (Resources.lessThanOrEqual(rc, clusterResource, toObtainByPartition,\n           Resources.none())) {\n         resourceToObtainByPartitions.remove(nodePartition);\n       }\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Marked container\u003d\" + rmContainer.getContainerId()\n             + \" in partition\u003d\" + nodePartition + \" will be preempted\");\n       }\n       // Add to preemptMap\n       addToPreemptMap(preemptMap, attemptId, rmContainer);\n       return true;\n     }\n \n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean tryPreemptContainerAndDeductResToObtain(\n      Map\u003cString, Resource\u003e resourceToObtainByPartitions,\n      RMContainer rmContainer, Resource clusterResource,\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e preemptMap) {\n    ApplicationAttemptId attemptId \u003d rmContainer.getApplicationAttemptId();\n\n    // We will not account resource of a container twice or more\n    if (preemptMapContains(preemptMap, attemptId, rmContainer)) {\n      return false;\n    }\n\n    String nodePartition \u003d getPartitionByRMContainer(rmContainer);\n    Resource toObtainByPartition \u003d\n        resourceToObtainByPartitions.get(nodePartition);\n\n    if (null !\u003d toObtainByPartition\n        \u0026\u0026 Resources.greaterThan(rc, clusterResource, toObtainByPartition,\n            Resources.none())) {\n      Resources.subtractFrom(toObtainByPartition,\n          rmContainer.getAllocatedResource());\n      // When we have no more resource need to obtain, remove from map.\n      if (Resources.lessThanOrEqual(rc, clusterResource, toObtainByPartition,\n          Resources.none())) {\n        resourceToObtainByPartitions.remove(nodePartition);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Marked container\u003d\" + rmContainer.getContainerId()\n            + \" in partition\u003d\" + nodePartition + \" will be preempted\");\n      }\n      // Add to preemptMap\n      addToPreemptMap(preemptMap, attemptId, rmContainer);\n      return true;\n    }\n\n    return false;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java",
      "extendedDetails": {}
    },
    "fa7a43529d529f0006c8033c2003f15b9b93f103": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"CapacityScheduler: Improve preemption to only kill containers that would satisfy the incoming request. (Wangda Tan)\"\n\nThis reverts commit 7e8c9beb4156dcaeb3a11e60aaa06d2370626913.\n",
      "commitDate": "16/03/16 5:02 PM",
      "commitName": "fa7a43529d529f0006c8033c2003f15b9b93f103",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "16/03/16 4:59 PM",
      "commitNameOld": "7e8c9beb4156dcaeb3a11e60aaa06d2370626913",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,36 +1,36 @@\n   private boolean tryPreemptContainerAndDeductResToObtain(\n       Map\u003cString, Resource\u003e resourceToObtainByPartitions,\n       RMContainer rmContainer, Resource clusterResource,\n       Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e preemptMap) {\n     ApplicationAttemptId attemptId \u003d rmContainer.getApplicationAttemptId();\n \n     // We will not account resource of a container twice or more\n     if (preemptMapContains(preemptMap, attemptId, rmContainer)) {\n       return false;\n     }\n \n-    String nodePartition \u003d getPartitionByRMContainer(rmContainer);\n+    String nodePartition \u003d getPartitionByNodeId(rmContainer.getAllocatedNode());\n     Resource toObtainByPartition \u003d\n         resourceToObtainByPartitions.get(nodePartition);\n \n     if (null !\u003d toObtainByPartition\n         \u0026\u0026 Resources.greaterThan(rc, clusterResource, toObtainByPartition,\n             Resources.none())) {\n       Resources.subtractFrom(toObtainByPartition,\n           rmContainer.getAllocatedResource());\n       // When we have no more resource need to obtain, remove from map.\n       if (Resources.lessThanOrEqual(rc, clusterResource, toObtainByPartition,\n           Resources.none())) {\n         resourceToObtainByPartitions.remove(nodePartition);\n       }\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Marked container\u003d\" + rmContainer.getContainerId()\n             + \" in partition\u003d\" + nodePartition + \" will be preempted\");\n       }\n       // Add to preemptMap\n       addToPreemptMap(preemptMap, attemptId, rmContainer);\n       return true;\n     }\n \n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean tryPreemptContainerAndDeductResToObtain(\n      Map\u003cString, Resource\u003e resourceToObtainByPartitions,\n      RMContainer rmContainer, Resource clusterResource,\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e preemptMap) {\n    ApplicationAttemptId attemptId \u003d rmContainer.getApplicationAttemptId();\n\n    // We will not account resource of a container twice or more\n    if (preemptMapContains(preemptMap, attemptId, rmContainer)) {\n      return false;\n    }\n\n    String nodePartition \u003d getPartitionByNodeId(rmContainer.getAllocatedNode());\n    Resource toObtainByPartition \u003d\n        resourceToObtainByPartitions.get(nodePartition);\n\n    if (null !\u003d toObtainByPartition\n        \u0026\u0026 Resources.greaterThan(rc, clusterResource, toObtainByPartition,\n            Resources.none())) {\n      Resources.subtractFrom(toObtainByPartition,\n          rmContainer.getAllocatedResource());\n      // When we have no more resource need to obtain, remove from map.\n      if (Resources.lessThanOrEqual(rc, clusterResource, toObtainByPartition,\n          Resources.none())) {\n        resourceToObtainByPartitions.remove(nodePartition);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Marked container\u003d\" + rmContainer.getContainerId()\n            + \" in partition\u003d\" + nodePartition + \" will be preempted\");\n      }\n      // Add to preemptMap\n      addToPreemptMap(preemptMap, attemptId, rmContainer);\n      return true;\n    }\n\n    return false;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java",
      "extendedDetails": {}
    },
    "7e8c9beb4156dcaeb3a11e60aaa06d2370626913": {
      "type": "Ybodychange",
      "commitMessage": "CapacityScheduler: Improve preemption to only kill containers that would satisfy the incoming request. (Wangda Tan)\n",
      "commitDate": "16/03/16 4:59 PM",
      "commitName": "7e8c9beb4156dcaeb3a11e60aaa06d2370626913",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "18/01/16 5:30 PM",
      "commitNameOld": "a44ce3f14fd940601f984fbf7980aa6fdc8f23b7",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 57.94,
      "commitsBetweenForRepo": 394,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,36 +1,36 @@\n   private boolean tryPreemptContainerAndDeductResToObtain(\n       Map\u003cString, Resource\u003e resourceToObtainByPartitions,\n       RMContainer rmContainer, Resource clusterResource,\n       Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e preemptMap) {\n     ApplicationAttemptId attemptId \u003d rmContainer.getApplicationAttemptId();\n \n     // We will not account resource of a container twice or more\n     if (preemptMapContains(preemptMap, attemptId, rmContainer)) {\n       return false;\n     }\n \n-    String nodePartition \u003d getPartitionByNodeId(rmContainer.getAllocatedNode());\n+    String nodePartition \u003d getPartitionByRMContainer(rmContainer);\n     Resource toObtainByPartition \u003d\n         resourceToObtainByPartitions.get(nodePartition);\n \n     if (null !\u003d toObtainByPartition\n         \u0026\u0026 Resources.greaterThan(rc, clusterResource, toObtainByPartition,\n             Resources.none())) {\n       Resources.subtractFrom(toObtainByPartition,\n           rmContainer.getAllocatedResource());\n       // When we have no more resource need to obtain, remove from map.\n       if (Resources.lessThanOrEqual(rc, clusterResource, toObtainByPartition,\n           Resources.none())) {\n         resourceToObtainByPartitions.remove(nodePartition);\n       }\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Marked container\u003d\" + rmContainer.getContainerId()\n             + \" in partition\u003d\" + nodePartition + \" will be preempted\");\n       }\n       // Add to preemptMap\n       addToPreemptMap(preemptMap, attemptId, rmContainer);\n       return true;\n     }\n \n     return false;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean tryPreemptContainerAndDeductResToObtain(\n      Map\u003cString, Resource\u003e resourceToObtainByPartitions,\n      RMContainer rmContainer, Resource clusterResource,\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e preemptMap) {\n    ApplicationAttemptId attemptId \u003d rmContainer.getApplicationAttemptId();\n\n    // We will not account resource of a container twice or more\n    if (preemptMapContains(preemptMap, attemptId, rmContainer)) {\n      return false;\n    }\n\n    String nodePartition \u003d getPartitionByRMContainer(rmContainer);\n    Resource toObtainByPartition \u003d\n        resourceToObtainByPartitions.get(nodePartition);\n\n    if (null !\u003d toObtainByPartition\n        \u0026\u0026 Resources.greaterThan(rc, clusterResource, toObtainByPartition,\n            Resources.none())) {\n      Resources.subtractFrom(toObtainByPartition,\n          rmContainer.getAllocatedResource());\n      // When we have no more resource need to obtain, remove from map.\n      if (Resources.lessThanOrEqual(rc, clusterResource, toObtainByPartition,\n          Resources.none())) {\n        resourceToObtainByPartitions.remove(nodePartition);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Marked container\u003d\" + rmContainer.getContainerId()\n            + \" in partition\u003d\" + nodePartition + \" will be preempted\");\n      }\n      // Add to preemptMap\n      addToPreemptMap(preemptMap, attemptId, rmContainer);\n      return true;\n    }\n\n    return false;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java",
      "extendedDetails": {}
    },
    "d497f6ea2be559aa31ed76f37ae949dbfabe2a51": {
      "type": "Yintroduced",
      "commitMessage": "YARN-2498. Respect labels in preemption policy of capacity scheduler for inter-queue preemption. Contributed by Wangda Tan\n",
      "commitDate": "24/04/15 5:03 PM",
      "commitName": "d497f6ea2be559aa31ed76f37ae949dbfabe2a51",
      "commitAuthor": "Jian He",
      "diff": "@@ -0,0 +1,36 @@\n+  private boolean tryPreemptContainerAndDeductResToObtain(\n+      Map\u003cString, Resource\u003e resourceToObtainByPartitions,\n+      RMContainer rmContainer, Resource clusterResource,\n+      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e preemptMap) {\n+    ApplicationAttemptId attemptId \u003d rmContainer.getApplicationAttemptId();\n+\n+    // We will not account resource of a container twice or more\n+    if (preemptMapContains(preemptMap, attemptId, rmContainer)) {\n+      return false;\n+    }\n+\n+    String nodePartition \u003d getPartitionByNodeId(rmContainer.getAllocatedNode());\n+    Resource toObtainByPartition \u003d\n+        resourceToObtainByPartitions.get(nodePartition);\n+\n+    if (null !\u003d toObtainByPartition\n+        \u0026\u0026 Resources.greaterThan(rc, clusterResource, toObtainByPartition,\n+            Resources.none())) {\n+      Resources.subtractFrom(toObtainByPartition,\n+          rmContainer.getAllocatedResource());\n+      // When we have no more resource need to obtain, remove from map.\n+      if (Resources.lessThanOrEqual(rc, clusterResource, toObtainByPartition,\n+          Resources.none())) {\n+        resourceToObtainByPartitions.remove(nodePartition);\n+      }\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Marked container\u003d\" + rmContainer.getContainerId()\n+            + \" in partition\u003d\" + nodePartition + \" will be preempted\");\n+      }\n+      // Add to preemptMap\n+      addToPreemptMap(preemptMap, attemptId, rmContainer);\n+      return true;\n+    }\n+\n+    return false;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean tryPreemptContainerAndDeductResToObtain(\n      Map\u003cString, Resource\u003e resourceToObtainByPartitions,\n      RMContainer rmContainer, Resource clusterResource,\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e preemptMap) {\n    ApplicationAttemptId attemptId \u003d rmContainer.getApplicationAttemptId();\n\n    // We will not account resource of a container twice or more\n    if (preemptMapContains(preemptMap, attemptId, rmContainer)) {\n      return false;\n    }\n\n    String nodePartition \u003d getPartitionByNodeId(rmContainer.getAllocatedNode());\n    Resource toObtainByPartition \u003d\n        resourceToObtainByPartitions.get(nodePartition);\n\n    if (null !\u003d toObtainByPartition\n        \u0026\u0026 Resources.greaterThan(rc, clusterResource, toObtainByPartition,\n            Resources.none())) {\n      Resources.subtractFrom(toObtainByPartition,\n          rmContainer.getAllocatedResource());\n      // When we have no more resource need to obtain, remove from map.\n      if (Resources.lessThanOrEqual(rc, clusterResource, toObtainByPartition,\n          Resources.none())) {\n        resourceToObtainByPartitions.remove(nodePartition);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Marked container\u003d\" + rmContainer.getContainerId()\n            + \" in partition\u003d\" + nodePartition + \" will be preempted\");\n      }\n      // Add to preemptMap\n      addToPreemptMap(preemptMap, attemptId, rmContainer);\n      return true;\n    }\n\n    return false;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java"
    }
  }
}