{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "QuorumCall.java",
  "functionName": "waitFor",
  "functionId": "waitFor___minResponses-int__minSuccesses-int__maxExceptions-int__millis-int__operationName-String",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/qjournal/client/QuorumCall.java",
  "functionStartLine": 165,
  "functionEndLine": 221,
  "numCommitsSeen": 10,
  "timeTaken": 2663,
  "changeHistory": [
    "90894c7262df0243e795b675f3ac9f7b322ccd11",
    "8a0fa0f7e88c45a98c6f266d6349cb426dd06495",
    "81192e4e415d359ca832eff50d6f64c3da7acb73",
    "3ccd905d8a0fe5e3a206ac955b689a6f02b25e67",
    "8a8c9c18d37f0c8b219264796c0df4bcae6f4e38",
    "74d4573a23db5586c6e47ff2277aa7c35237da34"
  ],
  "changeHistoryShort": {
    "90894c7262df0243e795b675f3ac9f7b322ccd11": "Ybodychange",
    "8a0fa0f7e88c45a98c6f266d6349cb426dd06495": "Ybodychange",
    "81192e4e415d359ca832eff50d6f64c3da7acb73": "Ybodychange",
    "3ccd905d8a0fe5e3a206ac955b689a6f02b25e67": "Ybodychange",
    "8a8c9c18d37f0c8b219264796c0df4bcae6f4e38": "Ymultichange(Yparameterchange,Ybodychange)",
    "74d4573a23db5586c6e47ff2277aa7c35237da34": "Yintroduced"
  },
  "changeHistoryDetails": {
    "90894c7262df0243e795b675f3ac9f7b322ccd11": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12323. NameNode terminates after full GC thinking QJM unresponsive if full GC is much longer than timeout. Contributed by Erik Krogen.",
      "commitDate": "15/09/17 1:56 PM",
      "commitName": "90894c7262df0243e795b675f3ac9f7b322ccd11",
      "commitAuthor": "Erik Krogen",
      "commitDateOld": "18/01/17 12:46 PM",
      "commitNameOld": "8a0fa0f7e88c45a98c6f266d6349cb426dd06495",
      "commitAuthorOld": "Vinitha Reddy Gankidi",
      "daysBetweenCommits": 240.01,
      "commitsBetweenForRepo": 1499,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,55 +1,57 @@\n   public synchronized void waitFor(\n       int minResponses, int minSuccesses, int maxExceptions,\n       int millis, String operationName)\n       throws InterruptedException, TimeoutException {\n-    long st \u003d Time.monotonicNow();\n+    long st \u003d timer.monotonicNow();\n     long nextLogTime \u003d st + (long)(millis * WAIT_PROGRESS_INFO_THRESHOLD);\n     long et \u003d st + millis;\n     while (true) {\n       restartQuorumStopWatch();\n       checkAssertionErrors();\n       if (minResponses \u003e 0 \u0026\u0026 countResponses() \u003e\u003d minResponses) return;\n       if (minSuccesses \u003e 0 \u0026\u0026 countSuccesses() \u003e\u003d minSuccesses) return;\n       if (maxExceptions \u003e\u003d 0 \u0026\u0026 countExceptions() \u003e maxExceptions) return;\n-      long now \u003d Time.monotonicNow();\n+      long now \u003d timer.monotonicNow();\n       \n       if (now \u003e nextLogTime) {\n         long waited \u003d now - st;\n         String msg \u003d String.format(\n             \"Waited %s ms (timeout\u003d%s ms) for a response for %s\",\n             waited, millis, operationName);\n         if (!successes.isEmpty()) {\n           msg +\u003d \". Succeeded so far: [\" + Joiner.on(\",\").join(successes.keySet()) + \"]\";\n         }\n         if (!exceptions.isEmpty()) {\n           msg +\u003d \". Exceptions so far: [\" + getExceptionMapString() + \"]\";\n         }\n         if (successes.isEmpty() \u0026\u0026 exceptions.isEmpty()) {\n           msg +\u003d \". No responses yet.\";\n         }\n         if (waited \u003e millis * WAIT_PROGRESS_WARN_THRESHOLD) {\n           QuorumJournalManager.LOG.warn(msg);\n         } else {\n           QuorumJournalManager.LOG.info(msg);\n         }\n         nextLogTime \u003d now + WAIT_PROGRESS_INTERVAL_MILLIS;\n       }\n       long rem \u003d et - now;\n       if (rem \u003c\u003d 0) {\n         // Increase timeout if a full GC occurred after restarting stopWatch\n-        if (shouldIncreaseQuorumTimeout(0, millis)) {\n-          et \u003d et + millis;\n+        long timeoutIncrease \u003d getQuorumTimeoutIncreaseMillis(0, millis);\n+        if (timeoutIncrease \u003e 0) {\n+          et +\u003d timeoutIncrease;\n         } else {\n           throw new TimeoutException();\n         }\n       }\n       restartQuorumStopWatch();\n       rem \u003d Math.min(rem, nextLogTime - now);\n       rem \u003d Math.max(rem, 1);\n       wait(rem);\n       // Increase timeout if a full GC occurred after restarting stopWatch\n-      if (shouldIncreaseQuorumTimeout(-rem, millis)) {\n-        et \u003d et + millis;\n+      long timeoutIncrease \u003d getQuorumTimeoutIncreaseMillis(-rem, millis);\n+      if (timeoutIncrease \u003e 0) {\n+        et +\u003d timeoutIncrease;\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void waitFor(\n      int minResponses, int minSuccesses, int maxExceptions,\n      int millis, String operationName)\n      throws InterruptedException, TimeoutException {\n    long st \u003d timer.monotonicNow();\n    long nextLogTime \u003d st + (long)(millis * WAIT_PROGRESS_INFO_THRESHOLD);\n    long et \u003d st + millis;\n    while (true) {\n      restartQuorumStopWatch();\n      checkAssertionErrors();\n      if (minResponses \u003e 0 \u0026\u0026 countResponses() \u003e\u003d minResponses) return;\n      if (minSuccesses \u003e 0 \u0026\u0026 countSuccesses() \u003e\u003d minSuccesses) return;\n      if (maxExceptions \u003e\u003d 0 \u0026\u0026 countExceptions() \u003e maxExceptions) return;\n      long now \u003d timer.monotonicNow();\n      \n      if (now \u003e nextLogTime) {\n        long waited \u003d now - st;\n        String msg \u003d String.format(\n            \"Waited %s ms (timeout\u003d%s ms) for a response for %s\",\n            waited, millis, operationName);\n        if (!successes.isEmpty()) {\n          msg +\u003d \". Succeeded so far: [\" + Joiner.on(\",\").join(successes.keySet()) + \"]\";\n        }\n        if (!exceptions.isEmpty()) {\n          msg +\u003d \". Exceptions so far: [\" + getExceptionMapString() + \"]\";\n        }\n        if (successes.isEmpty() \u0026\u0026 exceptions.isEmpty()) {\n          msg +\u003d \". No responses yet.\";\n        }\n        if (waited \u003e millis * WAIT_PROGRESS_WARN_THRESHOLD) {\n          QuorumJournalManager.LOG.warn(msg);\n        } else {\n          QuorumJournalManager.LOG.info(msg);\n        }\n        nextLogTime \u003d now + WAIT_PROGRESS_INTERVAL_MILLIS;\n      }\n      long rem \u003d et - now;\n      if (rem \u003c\u003d 0) {\n        // Increase timeout if a full GC occurred after restarting stopWatch\n        long timeoutIncrease \u003d getQuorumTimeoutIncreaseMillis(0, millis);\n        if (timeoutIncrease \u003e 0) {\n          et +\u003d timeoutIncrease;\n        } else {\n          throw new TimeoutException();\n        }\n      }\n      restartQuorumStopWatch();\n      rem \u003d Math.min(rem, nextLogTime - now);\n      rem \u003d Math.max(rem, 1);\n      wait(rem);\n      // Increase timeout if a full GC occurred after restarting stopWatch\n      long timeoutIncrease \u003d getQuorumTimeoutIncreaseMillis(-rem, millis);\n      if (timeoutIncrease \u003e 0) {\n        et +\u003d timeoutIncrease;\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/qjournal/client/QuorumCall.java",
      "extendedDetails": {}
    },
    "8a0fa0f7e88c45a98c6f266d6349cb426dd06495": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10733. NameNode terminated after full GC thinking QJM is unresponsive. Contributed by Vinitha Gankidi.",
      "commitDate": "18/01/17 12:46 PM",
      "commitName": "8a0fa0f7e88c45a98c6f266d6349cb426dd06495",
      "commitAuthor": "Vinitha Reddy Gankidi",
      "commitDateOld": "27/03/13 11:42 AM",
      "commitNameOld": "81192e4e415d359ca832eff50d6f64c3da7acb73",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 1393.09,
      "commitsBetweenForRepo": 10229,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,44 +1,55 @@\n   public synchronized void waitFor(\n       int minResponses, int minSuccesses, int maxExceptions,\n       int millis, String operationName)\n       throws InterruptedException, TimeoutException {\n     long st \u003d Time.monotonicNow();\n     long nextLogTime \u003d st + (long)(millis * WAIT_PROGRESS_INFO_THRESHOLD);\n     long et \u003d st + millis;\n     while (true) {\n+      restartQuorumStopWatch();\n       checkAssertionErrors();\n       if (minResponses \u003e 0 \u0026\u0026 countResponses() \u003e\u003d minResponses) return;\n       if (minSuccesses \u003e 0 \u0026\u0026 countSuccesses() \u003e\u003d minSuccesses) return;\n       if (maxExceptions \u003e\u003d 0 \u0026\u0026 countExceptions() \u003e maxExceptions) return;\n       long now \u003d Time.monotonicNow();\n       \n       if (now \u003e nextLogTime) {\n         long waited \u003d now - st;\n         String msg \u003d String.format(\n             \"Waited %s ms (timeout\u003d%s ms) for a response for %s\",\n             waited, millis, operationName);\n         if (!successes.isEmpty()) {\n           msg +\u003d \". Succeeded so far: [\" + Joiner.on(\",\").join(successes.keySet()) + \"]\";\n         }\n         if (!exceptions.isEmpty()) {\n           msg +\u003d \". Exceptions so far: [\" + getExceptionMapString() + \"]\";\n         }\n         if (successes.isEmpty() \u0026\u0026 exceptions.isEmpty()) {\n           msg +\u003d \". No responses yet.\";\n         }\n         if (waited \u003e millis * WAIT_PROGRESS_WARN_THRESHOLD) {\n           QuorumJournalManager.LOG.warn(msg);\n         } else {\n           QuorumJournalManager.LOG.info(msg);\n         }\n         nextLogTime \u003d now + WAIT_PROGRESS_INTERVAL_MILLIS;\n       }\n       long rem \u003d et - now;\n       if (rem \u003c\u003d 0) {\n-        throw new TimeoutException();\n+        // Increase timeout if a full GC occurred after restarting stopWatch\n+        if (shouldIncreaseQuorumTimeout(0, millis)) {\n+          et \u003d et + millis;\n+        } else {\n+          throw new TimeoutException();\n+        }\n       }\n+      restartQuorumStopWatch();\n       rem \u003d Math.min(rem, nextLogTime - now);\n       rem \u003d Math.max(rem, 1);\n       wait(rem);\n+      // Increase timeout if a full GC occurred after restarting stopWatch\n+      if (shouldIncreaseQuorumTimeout(-rem, millis)) {\n+        et \u003d et + millis;\n+      }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void waitFor(\n      int minResponses, int minSuccesses, int maxExceptions,\n      int millis, String operationName)\n      throws InterruptedException, TimeoutException {\n    long st \u003d Time.monotonicNow();\n    long nextLogTime \u003d st + (long)(millis * WAIT_PROGRESS_INFO_THRESHOLD);\n    long et \u003d st + millis;\n    while (true) {\n      restartQuorumStopWatch();\n      checkAssertionErrors();\n      if (minResponses \u003e 0 \u0026\u0026 countResponses() \u003e\u003d minResponses) return;\n      if (minSuccesses \u003e 0 \u0026\u0026 countSuccesses() \u003e\u003d minSuccesses) return;\n      if (maxExceptions \u003e\u003d 0 \u0026\u0026 countExceptions() \u003e maxExceptions) return;\n      long now \u003d Time.monotonicNow();\n      \n      if (now \u003e nextLogTime) {\n        long waited \u003d now - st;\n        String msg \u003d String.format(\n            \"Waited %s ms (timeout\u003d%s ms) for a response for %s\",\n            waited, millis, operationName);\n        if (!successes.isEmpty()) {\n          msg +\u003d \". Succeeded so far: [\" + Joiner.on(\",\").join(successes.keySet()) + \"]\";\n        }\n        if (!exceptions.isEmpty()) {\n          msg +\u003d \". Exceptions so far: [\" + getExceptionMapString() + \"]\";\n        }\n        if (successes.isEmpty() \u0026\u0026 exceptions.isEmpty()) {\n          msg +\u003d \". No responses yet.\";\n        }\n        if (waited \u003e millis * WAIT_PROGRESS_WARN_THRESHOLD) {\n          QuorumJournalManager.LOG.warn(msg);\n        } else {\n          QuorumJournalManager.LOG.info(msg);\n        }\n        nextLogTime \u003d now + WAIT_PROGRESS_INTERVAL_MILLIS;\n      }\n      long rem \u003d et - now;\n      if (rem \u003c\u003d 0) {\n        // Increase timeout if a full GC occurred after restarting stopWatch\n        if (shouldIncreaseQuorumTimeout(0, millis)) {\n          et \u003d et + millis;\n        } else {\n          throw new TimeoutException();\n        }\n      }\n      restartQuorumStopWatch();\n      rem \u003d Math.min(rem, nextLogTime - now);\n      rem \u003d Math.max(rem, 1);\n      wait(rem);\n      // Increase timeout if a full GC occurred after restarting stopWatch\n      if (shouldIncreaseQuorumTimeout(-rem, millis)) {\n        et \u003d et + millis;\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/qjournal/client/QuorumCall.java",
      "extendedDetails": {}
    },
    "81192e4e415d359ca832eff50d6f64c3da7acb73": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4621. Additional logging to help diagnose slow QJM syncs. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1461777 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/03/13 11:42 AM",
      "commitName": "81192e4e415d359ca832eff50d6f64c3da7acb73",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "19/09/12 11:57 AM",
      "commitNameOld": "3ccd905d8a0fe5e3a206ac955b689a6f02b25e67",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 188.99,
      "commitsBetweenForRepo": 911,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,44 @@\n   public synchronized void waitFor(\n       int minResponses, int minSuccesses, int maxExceptions,\n       int millis, String operationName)\n       throws InterruptedException, TimeoutException {\n     long st \u003d Time.monotonicNow();\n     long nextLogTime \u003d st + (long)(millis * WAIT_PROGRESS_INFO_THRESHOLD);\n     long et \u003d st + millis;\n     while (true) {\n       checkAssertionErrors();\n       if (minResponses \u003e 0 \u0026\u0026 countResponses() \u003e\u003d minResponses) return;\n       if (minSuccesses \u003e 0 \u0026\u0026 countSuccesses() \u003e\u003d minSuccesses) return;\n       if (maxExceptions \u003e\u003d 0 \u0026\u0026 countExceptions() \u003e maxExceptions) return;\n       long now \u003d Time.monotonicNow();\n       \n       if (now \u003e nextLogTime) {\n         long waited \u003d now - st;\n         String msg \u003d String.format(\n             \"Waited %s ms (timeout\u003d%s ms) for a response for %s\",\n             waited, millis, operationName);\n+        if (!successes.isEmpty()) {\n+          msg +\u003d \". Succeeded so far: [\" + Joiner.on(\",\").join(successes.keySet()) + \"]\";\n+        }\n+        if (!exceptions.isEmpty()) {\n+          msg +\u003d \". Exceptions so far: [\" + getExceptionMapString() + \"]\";\n+        }\n+        if (successes.isEmpty() \u0026\u0026 exceptions.isEmpty()) {\n+          msg +\u003d \". No responses yet.\";\n+        }\n         if (waited \u003e millis * WAIT_PROGRESS_WARN_THRESHOLD) {\n           QuorumJournalManager.LOG.warn(msg);\n         } else {\n           QuorumJournalManager.LOG.info(msg);\n         }\n         nextLogTime \u003d now + WAIT_PROGRESS_INTERVAL_MILLIS;\n       }\n       long rem \u003d et - now;\n       if (rem \u003c\u003d 0) {\n         throw new TimeoutException();\n       }\n       rem \u003d Math.min(rem, nextLogTime - now);\n       rem \u003d Math.max(rem, 1);\n       wait(rem);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void waitFor(\n      int minResponses, int minSuccesses, int maxExceptions,\n      int millis, String operationName)\n      throws InterruptedException, TimeoutException {\n    long st \u003d Time.monotonicNow();\n    long nextLogTime \u003d st + (long)(millis * WAIT_PROGRESS_INFO_THRESHOLD);\n    long et \u003d st + millis;\n    while (true) {\n      checkAssertionErrors();\n      if (minResponses \u003e 0 \u0026\u0026 countResponses() \u003e\u003d minResponses) return;\n      if (minSuccesses \u003e 0 \u0026\u0026 countSuccesses() \u003e\u003d minSuccesses) return;\n      if (maxExceptions \u003e\u003d 0 \u0026\u0026 countExceptions() \u003e maxExceptions) return;\n      long now \u003d Time.monotonicNow();\n      \n      if (now \u003e nextLogTime) {\n        long waited \u003d now - st;\n        String msg \u003d String.format(\n            \"Waited %s ms (timeout\u003d%s ms) for a response for %s\",\n            waited, millis, operationName);\n        if (!successes.isEmpty()) {\n          msg +\u003d \". Succeeded so far: [\" + Joiner.on(\",\").join(successes.keySet()) + \"]\";\n        }\n        if (!exceptions.isEmpty()) {\n          msg +\u003d \". Exceptions so far: [\" + getExceptionMapString() + \"]\";\n        }\n        if (successes.isEmpty() \u0026\u0026 exceptions.isEmpty()) {\n          msg +\u003d \". No responses yet.\";\n        }\n        if (waited \u003e millis * WAIT_PROGRESS_WARN_THRESHOLD) {\n          QuorumJournalManager.LOG.warn(msg);\n        } else {\n          QuorumJournalManager.LOG.info(msg);\n        }\n        nextLogTime \u003d now + WAIT_PROGRESS_INTERVAL_MILLIS;\n      }\n      long rem \u003d et - now;\n      if (rem \u003c\u003d 0) {\n        throw new TimeoutException();\n      }\n      rem \u003d Math.min(rem, nextLogTime - now);\n      rem \u003d Math.max(rem, 1);\n      wait(rem);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/qjournal/client/QuorumCall.java",
      "extendedDetails": {}
    },
    "3ccd905d8a0fe5e3a206ac955b689a6f02b25e67": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3955. QJM: Make acceptRecovery() atomic. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-3077@1387706 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/09/12 11:57 AM",
      "commitName": "3ccd905d8a0fe5e3a206ac955b689a6f02b25e67",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "10/09/12 11:31 PM",
      "commitNameOld": "8a8c9c18d37f0c8b219264796c0df4bcae6f4e38",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 8.52,
      "commitsBetweenForRepo": 41,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,35 @@\n   public synchronized void waitFor(\n       int minResponses, int minSuccesses, int maxExceptions,\n       int millis, String operationName)\n       throws InterruptedException, TimeoutException {\n     long st \u003d Time.monotonicNow();\n     long nextLogTime \u003d st + (long)(millis * WAIT_PROGRESS_INFO_THRESHOLD);\n     long et \u003d st + millis;\n     while (true) {\n+      checkAssertionErrors();\n       if (minResponses \u003e 0 \u0026\u0026 countResponses() \u003e\u003d minResponses) return;\n       if (minSuccesses \u003e 0 \u0026\u0026 countSuccesses() \u003e\u003d minSuccesses) return;\n       if (maxExceptions \u003e\u003d 0 \u0026\u0026 countExceptions() \u003e maxExceptions) return;\n       long now \u003d Time.monotonicNow();\n       \n       if (now \u003e nextLogTime) {\n         long waited \u003d now - st;\n         String msg \u003d String.format(\n             \"Waited %s ms (timeout\u003d%s ms) for a response for %s\",\n             waited, millis, operationName);\n         if (waited \u003e millis * WAIT_PROGRESS_WARN_THRESHOLD) {\n           QuorumJournalManager.LOG.warn(msg);\n         } else {\n           QuorumJournalManager.LOG.info(msg);\n         }\n         nextLogTime \u003d now + WAIT_PROGRESS_INTERVAL_MILLIS;\n       }\n       long rem \u003d et - now;\n       if (rem \u003c\u003d 0) {\n         throw new TimeoutException();\n       }\n       rem \u003d Math.min(rem, nextLogTime - now);\n       rem \u003d Math.max(rem, 1);\n       wait(rem);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void waitFor(\n      int minResponses, int minSuccesses, int maxExceptions,\n      int millis, String operationName)\n      throws InterruptedException, TimeoutException {\n    long st \u003d Time.monotonicNow();\n    long nextLogTime \u003d st + (long)(millis * WAIT_PROGRESS_INFO_THRESHOLD);\n    long et \u003d st + millis;\n    while (true) {\n      checkAssertionErrors();\n      if (minResponses \u003e 0 \u0026\u0026 countResponses() \u003e\u003d minResponses) return;\n      if (minSuccesses \u003e 0 \u0026\u0026 countSuccesses() \u003e\u003d minSuccesses) return;\n      if (maxExceptions \u003e\u003d 0 \u0026\u0026 countExceptions() \u003e maxExceptions) return;\n      long now \u003d Time.monotonicNow();\n      \n      if (now \u003e nextLogTime) {\n        long waited \u003d now - st;\n        String msg \u003d String.format(\n            \"Waited %s ms (timeout\u003d%s ms) for a response for %s\",\n            waited, millis, operationName);\n        if (waited \u003e millis * WAIT_PROGRESS_WARN_THRESHOLD) {\n          QuorumJournalManager.LOG.warn(msg);\n        } else {\n          QuorumJournalManager.LOG.info(msg);\n        }\n        nextLogTime \u003d now + WAIT_PROGRESS_INTERVAL_MILLIS;\n      }\n      long rem \u003d et - now;\n      if (rem \u003c\u003d 0) {\n        throw new TimeoutException();\n      }\n      rem \u003d Math.min(rem, nextLogTime - now);\n      rem \u003d Math.max(rem, 1);\n      wait(rem);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/qjournal/client/QuorumCall.java",
      "extendedDetails": {}
    },
    "8a8c9c18d37f0c8b219264796c0df4bcae6f4e38": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-3906. QJM: quorum timeout on failover with large log segment. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-3077@1383251 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/09/12 11:31 PM",
      "commitName": "8a8c9c18d37f0c8b219264796c0df4bcae6f4e38",
      "commitAuthor": "Todd Lipcon",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-3906. QJM: quorum timeout on failover with large log segment. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-3077@1383251 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "10/09/12 11:31 PM",
          "commitName": "8a8c9c18d37f0c8b219264796c0df4bcae6f4e38",
          "commitAuthor": "Todd Lipcon",
          "commitDateOld": "19/07/12 5:25 PM",
          "commitNameOld": "74d4573a23db5586c6e47ff2277aa7c35237da34",
          "commitAuthorOld": "Todd Lipcon",
          "daysBetweenCommits": 53.25,
          "commitsBetweenForRepo": 316,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,16 +1,34 @@\n   public synchronized void waitFor(\n       int minResponses, int minSuccesses, int maxExceptions,\n-      int millis)\n+      int millis, String operationName)\n       throws InterruptedException, TimeoutException {\n-    long et \u003d Time.monotonicNow() + millis;\n+    long st \u003d Time.monotonicNow();\n+    long nextLogTime \u003d st + (long)(millis * WAIT_PROGRESS_INFO_THRESHOLD);\n+    long et \u003d st + millis;\n     while (true) {\n       if (minResponses \u003e 0 \u0026\u0026 countResponses() \u003e\u003d minResponses) return;\n       if (minSuccesses \u003e 0 \u0026\u0026 countSuccesses() \u003e\u003d minSuccesses) return;\n       if (maxExceptions \u003e\u003d 0 \u0026\u0026 countExceptions() \u003e maxExceptions) return;\n-      long rem \u003d et - Time.monotonicNow();\n+      long now \u003d Time.monotonicNow();\n+      \n+      if (now \u003e nextLogTime) {\n+        long waited \u003d now - st;\n+        String msg \u003d String.format(\n+            \"Waited %s ms (timeout\u003d%s ms) for a response for %s\",\n+            waited, millis, operationName);\n+        if (waited \u003e millis * WAIT_PROGRESS_WARN_THRESHOLD) {\n+          QuorumJournalManager.LOG.warn(msg);\n+        } else {\n+          QuorumJournalManager.LOG.info(msg);\n+        }\n+        nextLogTime \u003d now + WAIT_PROGRESS_INTERVAL_MILLIS;\n+      }\n+      long rem \u003d et - now;\n       if (rem \u003c\u003d 0) {\n         throw new TimeoutException();\n       }\n+      rem \u003d Math.min(rem, nextLogTime - now);\n+      rem \u003d Math.max(rem, 1);\n       wait(rem);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public synchronized void waitFor(\n      int minResponses, int minSuccesses, int maxExceptions,\n      int millis, String operationName)\n      throws InterruptedException, TimeoutException {\n    long st \u003d Time.monotonicNow();\n    long nextLogTime \u003d st + (long)(millis * WAIT_PROGRESS_INFO_THRESHOLD);\n    long et \u003d st + millis;\n    while (true) {\n      if (minResponses \u003e 0 \u0026\u0026 countResponses() \u003e\u003d minResponses) return;\n      if (minSuccesses \u003e 0 \u0026\u0026 countSuccesses() \u003e\u003d minSuccesses) return;\n      if (maxExceptions \u003e\u003d 0 \u0026\u0026 countExceptions() \u003e maxExceptions) return;\n      long now \u003d Time.monotonicNow();\n      \n      if (now \u003e nextLogTime) {\n        long waited \u003d now - st;\n        String msg \u003d String.format(\n            \"Waited %s ms (timeout\u003d%s ms) for a response for %s\",\n            waited, millis, operationName);\n        if (waited \u003e millis * WAIT_PROGRESS_WARN_THRESHOLD) {\n          QuorumJournalManager.LOG.warn(msg);\n        } else {\n          QuorumJournalManager.LOG.info(msg);\n        }\n        nextLogTime \u003d now + WAIT_PROGRESS_INTERVAL_MILLIS;\n      }\n      long rem \u003d et - now;\n      if (rem \u003c\u003d 0) {\n        throw new TimeoutException();\n      }\n      rem \u003d Math.min(rem, nextLogTime - now);\n      rem \u003d Math.max(rem, 1);\n      wait(rem);\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/qjournal/client/QuorumCall.java",
          "extendedDetails": {
            "oldValue": "[minResponses-int, minSuccesses-int, maxExceptions-int, millis-int]",
            "newValue": "[minResponses-int, minSuccesses-int, maxExceptions-int, millis-int, operationName-String]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-3906. QJM: quorum timeout on failover with large log segment. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-3077@1383251 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "10/09/12 11:31 PM",
          "commitName": "8a8c9c18d37f0c8b219264796c0df4bcae6f4e38",
          "commitAuthor": "Todd Lipcon",
          "commitDateOld": "19/07/12 5:25 PM",
          "commitNameOld": "74d4573a23db5586c6e47ff2277aa7c35237da34",
          "commitAuthorOld": "Todd Lipcon",
          "daysBetweenCommits": 53.25,
          "commitsBetweenForRepo": 316,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,16 +1,34 @@\n   public synchronized void waitFor(\n       int minResponses, int minSuccesses, int maxExceptions,\n-      int millis)\n+      int millis, String operationName)\n       throws InterruptedException, TimeoutException {\n-    long et \u003d Time.monotonicNow() + millis;\n+    long st \u003d Time.monotonicNow();\n+    long nextLogTime \u003d st + (long)(millis * WAIT_PROGRESS_INFO_THRESHOLD);\n+    long et \u003d st + millis;\n     while (true) {\n       if (minResponses \u003e 0 \u0026\u0026 countResponses() \u003e\u003d minResponses) return;\n       if (minSuccesses \u003e 0 \u0026\u0026 countSuccesses() \u003e\u003d minSuccesses) return;\n       if (maxExceptions \u003e\u003d 0 \u0026\u0026 countExceptions() \u003e maxExceptions) return;\n-      long rem \u003d et - Time.monotonicNow();\n+      long now \u003d Time.monotonicNow();\n+      \n+      if (now \u003e nextLogTime) {\n+        long waited \u003d now - st;\n+        String msg \u003d String.format(\n+            \"Waited %s ms (timeout\u003d%s ms) for a response for %s\",\n+            waited, millis, operationName);\n+        if (waited \u003e millis * WAIT_PROGRESS_WARN_THRESHOLD) {\n+          QuorumJournalManager.LOG.warn(msg);\n+        } else {\n+          QuorumJournalManager.LOG.info(msg);\n+        }\n+        nextLogTime \u003d now + WAIT_PROGRESS_INTERVAL_MILLIS;\n+      }\n+      long rem \u003d et - now;\n       if (rem \u003c\u003d 0) {\n         throw new TimeoutException();\n       }\n+      rem \u003d Math.min(rem, nextLogTime - now);\n+      rem \u003d Math.max(rem, 1);\n       wait(rem);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public synchronized void waitFor(\n      int minResponses, int minSuccesses, int maxExceptions,\n      int millis, String operationName)\n      throws InterruptedException, TimeoutException {\n    long st \u003d Time.monotonicNow();\n    long nextLogTime \u003d st + (long)(millis * WAIT_PROGRESS_INFO_THRESHOLD);\n    long et \u003d st + millis;\n    while (true) {\n      if (minResponses \u003e 0 \u0026\u0026 countResponses() \u003e\u003d minResponses) return;\n      if (minSuccesses \u003e 0 \u0026\u0026 countSuccesses() \u003e\u003d minSuccesses) return;\n      if (maxExceptions \u003e\u003d 0 \u0026\u0026 countExceptions() \u003e maxExceptions) return;\n      long now \u003d Time.monotonicNow();\n      \n      if (now \u003e nextLogTime) {\n        long waited \u003d now - st;\n        String msg \u003d String.format(\n            \"Waited %s ms (timeout\u003d%s ms) for a response for %s\",\n            waited, millis, operationName);\n        if (waited \u003e millis * WAIT_PROGRESS_WARN_THRESHOLD) {\n          QuorumJournalManager.LOG.warn(msg);\n        } else {\n          QuorumJournalManager.LOG.info(msg);\n        }\n        nextLogTime \u003d now + WAIT_PROGRESS_INTERVAL_MILLIS;\n      }\n      long rem \u003d et - now;\n      if (rem \u003c\u003d 0) {\n        throw new TimeoutException();\n      }\n      rem \u003d Math.min(rem, nextLogTime - now);\n      rem \u003d Math.max(rem, 1);\n      wait(rem);\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/qjournal/client/QuorumCall.java",
          "extendedDetails": {}
        }
      ]
    },
    "74d4573a23db5586c6e47ff2277aa7c35237da34": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-3077. Quorum-based protocol for reading and writing edit logs. Contributed by Todd Lipcon based on initial work from Brandon Li and Hari Mankude.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-3077@1363596 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/07/12 5:25 PM",
      "commitName": "74d4573a23db5586c6e47ff2277aa7c35237da34",
      "commitAuthor": "Todd Lipcon",
      "diff": "@@ -0,0 +1,16 @@\n+  public synchronized void waitFor(\n+      int minResponses, int minSuccesses, int maxExceptions,\n+      int millis)\n+      throws InterruptedException, TimeoutException {\n+    long et \u003d Time.monotonicNow() + millis;\n+    while (true) {\n+      if (minResponses \u003e 0 \u0026\u0026 countResponses() \u003e\u003d minResponses) return;\n+      if (minSuccesses \u003e 0 \u0026\u0026 countSuccesses() \u003e\u003d minSuccesses) return;\n+      if (maxExceptions \u003e\u003d 0 \u0026\u0026 countExceptions() \u003e maxExceptions) return;\n+      long rem \u003d et - Time.monotonicNow();\n+      if (rem \u003c\u003d 0) {\n+        throw new TimeoutException();\n+      }\n+      wait(rem);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void waitFor(\n      int minResponses, int minSuccesses, int maxExceptions,\n      int millis)\n      throws InterruptedException, TimeoutException {\n    long et \u003d Time.monotonicNow() + millis;\n    while (true) {\n      if (minResponses \u003e 0 \u0026\u0026 countResponses() \u003e\u003d minResponses) return;\n      if (minSuccesses \u003e 0 \u0026\u0026 countSuccesses() \u003e\u003d minSuccesses) return;\n      if (maxExceptions \u003e\u003d 0 \u0026\u0026 countExceptions() \u003e maxExceptions) return;\n      long rem \u003d et - Time.monotonicNow();\n      if (rem \u003c\u003d 0) {\n        throw new TimeoutException();\n      }\n      wait(rem);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/qjournal/client/QuorumCall.java"
    }
  }
}