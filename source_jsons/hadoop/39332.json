{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "CapacityScheduler.java",
  "functionName": "updateApplicationPriority",
  "functionId": "updateApplicationPriority___newPriority-Priority__applicationId-ApplicationId__future-SettableFuture__Object____user-UserGroupInformation",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
  "functionStartLine": 2711,
  "functionEndLine": 2761,
  "numCommitsSeen": 518,
  "timeTaken": 10079,
  "changeHistory": [
    "8ef46595da6aefe4458aa7181670c3d9b13e7ec6",
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635",
    "287d3d6804a869723ae36605a3c2d2b3eae3941e",
    "a926f895c11cd69cf2117c3b970304f3f1f53d92",
    "bcc15c6290b3912a054323695a6a931b0de163bd",
    "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f",
    "8676a118a12165ae5a8b80a2a4596c133471ebc1",
    "a9aafad12b1d2f67e55e09a6fa261d61789c9d7e",
    "b469ac531af1bdda01a04ae0b8d39218ca292163",
    "57c7ae1affb2e1821fbdc3f47738d7e6fd83c7c1",
    "fa1d84ae2739a1e76f58b9c96d1378f9453cc0d2"
  ],
  "changeHistoryShort": {
    "8ef46595da6aefe4458aa7181670c3d9b13e7ec6": "Ybodychange",
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635": "Ybodychange",
    "287d3d6804a869723ae36605a3c2d2b3eae3941e": "Ymultichange(Yparameterchange,Ybodychange)",
    "a926f895c11cd69cf2117c3b970304f3f1f53d92": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
    "bcc15c6290b3912a054323695a6a931b0de163bd": "Ybodychange",
    "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f": "Ybodychange",
    "8676a118a12165ae5a8b80a2a4596c133471ebc1": "Ybodychange",
    "a9aafad12b1d2f67e55e09a6fa261d61789c9d7e": "Ybodychange",
    "b469ac531af1bdda01a04ae0b8d39218ca292163": "Ybodychange",
    "57c7ae1affb2e1821fbdc3f47738d7e6fd83c7c1": "Ymultichange(Ymodifierchange,Ybodychange)",
    "fa1d84ae2739a1e76f58b9c96d1378f9453cc0d2": "Yintroduced"
  },
  "changeHistoryDetails": {
    "8ef46595da6aefe4458aa7181670c3d9b13e7ec6": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9438. launchTime not written to state store for running applications\n",
      "commitDate": "27/08/19 3:53 PM",
      "commitName": "8ef46595da6aefe4458aa7181670c3d9b13e7ec6",
      "commitAuthor": "Jonathan Hung",
      "commitDateOld": "28/06/19 8:24 AM",
      "commitNameOld": "cbae2413201bc470b5f16421ea69d1cd9edb64a8",
      "commitAuthorOld": "Weiwei Yang",
      "daysBetweenCommits": 60.31,
      "commitsBetweenForRepo": 494,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,50 +1,51 @@\n   public Priority updateApplicationPriority(Priority newPriority,\n       ApplicationId applicationId, SettableFuture\u003cObject\u003e future,\n       UserGroupInformation user)\n       throws YarnException {\n     writeLock.lock();\n     try {\n       Priority appPriority \u003d null;\n       SchedulerApplication\u003cFiCaSchedulerApp\u003e application \u003d applications\n           .get(applicationId);\n \n       if (application \u003d\u003d null) {\n         throw new YarnException(\"Application \u0027\" + applicationId\n             + \"\u0027 is not present, hence could not change priority.\");\n       }\n \n       RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n \n       appPriority \u003d checkAndGetApplicationPriority(newPriority, user,\n           rmApp.getQueue(), applicationId);\n \n       if (application.getPriority().equals(appPriority)) {\n         future.set(null);\n         return appPriority;\n       }\n \n       // Update new priority in Submission Context to update to StateStore.\n       rmApp.getApplicationSubmissionContext().setPriority(appPriority);\n \n       // Update to state store\n       ApplicationStateData appState \u003d ApplicationStateData.newInstance(\n           rmApp.getSubmitTime(), rmApp.getStartTime(),\n           rmApp.getApplicationSubmissionContext(), rmApp.getUser(),\n           rmApp.getCallerContext());\n       appState.setApplicationTimeouts(rmApp.getApplicationTimeouts());\n+      appState.setLaunchTime(rmApp.getLaunchTime());\n       rmContext.getStateStore().updateApplicationStateSynchronously(appState,\n           false, future);\n \n       // As we use iterator over a TreeSet for OrderingPolicy, once we change\n       // priority then reinsert back to make order correct.\n       LeafQueue queue \u003d (LeafQueue) getQueue(rmApp.getQueue());\n       queue.updateApplicationPriority(application, appPriority);\n \n       LOG.info(\"Priority \u0027\" + appPriority + \"\u0027 is updated in queue :\"\n           + rmApp.getQueue() + \" for application: \" + applicationId\n           + \" for the user: \" + rmApp.getUser());\n       return appPriority;\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Priority updateApplicationPriority(Priority newPriority,\n      ApplicationId applicationId, SettableFuture\u003cObject\u003e future,\n      UserGroupInformation user)\n      throws YarnException {\n    writeLock.lock();\n    try {\n      Priority appPriority \u003d null;\n      SchedulerApplication\u003cFiCaSchedulerApp\u003e application \u003d applications\n          .get(applicationId);\n\n      if (application \u003d\u003d null) {\n        throw new YarnException(\"Application \u0027\" + applicationId\n            + \"\u0027 is not present, hence could not change priority.\");\n      }\n\n      RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n\n      appPriority \u003d checkAndGetApplicationPriority(newPriority, user,\n          rmApp.getQueue(), applicationId);\n\n      if (application.getPriority().equals(appPriority)) {\n        future.set(null);\n        return appPriority;\n      }\n\n      // Update new priority in Submission Context to update to StateStore.\n      rmApp.getApplicationSubmissionContext().setPriority(appPriority);\n\n      // Update to state store\n      ApplicationStateData appState \u003d ApplicationStateData.newInstance(\n          rmApp.getSubmitTime(), rmApp.getStartTime(),\n          rmApp.getApplicationSubmissionContext(), rmApp.getUser(),\n          rmApp.getCallerContext());\n      appState.setApplicationTimeouts(rmApp.getApplicationTimeouts());\n      appState.setLaunchTime(rmApp.getLaunchTime());\n      rmContext.getStateStore().updateApplicationStateSynchronously(appState,\n          false, future);\n\n      // As we use iterator over a TreeSet for OrderingPolicy, once we change\n      // priority then reinsert back to make order correct.\n      LeafQueue queue \u003d (LeafQueue) getQueue(rmApp.getQueue());\n      queue.updateApplicationPriority(application, appPriority);\n\n      LOG.info(\"Priority \u0027\" + appPriority + \"\u0027 is updated in queue :\"\n          + rmApp.getQueue() + \" for application: \" + applicationId\n          + \" for the user: \" + rmApp.getUser());\n      return appPriority;\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9341.  Fixed enentrant lock usage in YARN project.\n            Contributed by Prabhu Joseph\n",
      "commitDate": "07/03/19 1:47 PM",
      "commitName": "39b4a37e02e929a698fcf9e32f1f71bb6b977635",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "04/03/19 9:10 PM",
      "commitNameOld": "e40e2d6ad5cbe782c3a067229270738b501ed27e",
      "commitAuthorOld": "Prabhu Joseph",
      "daysBetweenCommits": 2.69,
      "commitsBetweenForRepo": 39,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,50 +1,50 @@\n   public Priority updateApplicationPriority(Priority newPriority,\n       ApplicationId applicationId, SettableFuture\u003cObject\u003e future,\n       UserGroupInformation user)\n       throws YarnException {\n+    writeLock.lock();\n     try {\n-      writeLock.lock();\n       Priority appPriority \u003d null;\n       SchedulerApplication\u003cFiCaSchedulerApp\u003e application \u003d applications\n           .get(applicationId);\n \n       if (application \u003d\u003d null) {\n         throw new YarnException(\"Application \u0027\" + applicationId\n             + \"\u0027 is not present, hence could not change priority.\");\n       }\n \n       RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n \n       appPriority \u003d checkAndGetApplicationPriority(newPriority, user,\n           rmApp.getQueue(), applicationId);\n \n       if (application.getPriority().equals(appPriority)) {\n         future.set(null);\n         return appPriority;\n       }\n \n       // Update new priority in Submission Context to update to StateStore.\n       rmApp.getApplicationSubmissionContext().setPriority(appPriority);\n \n       // Update to state store\n       ApplicationStateData appState \u003d ApplicationStateData.newInstance(\n           rmApp.getSubmitTime(), rmApp.getStartTime(),\n           rmApp.getApplicationSubmissionContext(), rmApp.getUser(),\n           rmApp.getCallerContext());\n       appState.setApplicationTimeouts(rmApp.getApplicationTimeouts());\n       rmContext.getStateStore().updateApplicationStateSynchronously(appState,\n           false, future);\n \n       // As we use iterator over a TreeSet for OrderingPolicy, once we change\n       // priority then reinsert back to make order correct.\n       LeafQueue queue \u003d (LeafQueue) getQueue(rmApp.getQueue());\n       queue.updateApplicationPriority(application, appPriority);\n \n       LOG.info(\"Priority \u0027\" + appPriority + \"\u0027 is updated in queue :\"\n           + rmApp.getQueue() + \" for application: \" + applicationId\n           + \" for the user: \" + rmApp.getUser());\n       return appPriority;\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Priority updateApplicationPriority(Priority newPriority,\n      ApplicationId applicationId, SettableFuture\u003cObject\u003e future,\n      UserGroupInformation user)\n      throws YarnException {\n    writeLock.lock();\n    try {\n      Priority appPriority \u003d null;\n      SchedulerApplication\u003cFiCaSchedulerApp\u003e application \u003d applications\n          .get(applicationId);\n\n      if (application \u003d\u003d null) {\n        throw new YarnException(\"Application \u0027\" + applicationId\n            + \"\u0027 is not present, hence could not change priority.\");\n      }\n\n      RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n\n      appPriority \u003d checkAndGetApplicationPriority(newPriority, user,\n          rmApp.getQueue(), applicationId);\n\n      if (application.getPriority().equals(appPriority)) {\n        future.set(null);\n        return appPriority;\n      }\n\n      // Update new priority in Submission Context to update to StateStore.\n      rmApp.getApplicationSubmissionContext().setPriority(appPriority);\n\n      // Update to state store\n      ApplicationStateData appState \u003d ApplicationStateData.newInstance(\n          rmApp.getSubmitTime(), rmApp.getStartTime(),\n          rmApp.getApplicationSubmissionContext(), rmApp.getUser(),\n          rmApp.getCallerContext());\n      appState.setApplicationTimeouts(rmApp.getApplicationTimeouts());\n      rmContext.getStateStore().updateApplicationStateSynchronously(appState,\n          false, future);\n\n      // As we use iterator over a TreeSet for OrderingPolicy, once we change\n      // priority then reinsert back to make order correct.\n      LeafQueue queue \u003d (LeafQueue) getQueue(rmApp.getQueue());\n      queue.updateApplicationPriority(application, appPriority);\n\n      LOG.info(\"Priority \u0027\" + appPriority + \"\u0027 is updated in queue :\"\n          + rmApp.getQueue() + \" for application: \" + applicationId\n          + \" for the user: \" + rmApp.getUser());\n      return appPriority;\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "287d3d6804a869723ae36605a3c2d2b3eae3941e": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-3955. Support for application priority ACLs in queues of CapacityScheduler. (Sunil G via wangda)\n",
      "commitDate": "09/01/17 8:40 AM",
      "commitName": "287d3d6804a869723ae36605a3c2d2b3eae3941e",
      "commitAuthor": "Wangda Tan",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-3955. Support for application priority ACLs in queues of CapacityScheduler. (Sunil G via wangda)\n",
          "commitDate": "09/01/17 8:40 AM",
          "commitName": "287d3d6804a869723ae36605a3c2d2b3eae3941e",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "05/01/17 10:31 AM",
          "commitNameOld": "0a55bd841ec0f2eb89a0383f4c589526e8b138d4",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 3.92,
          "commitsBetweenForRepo": 17,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,44 +1,50 @@\n   public Priority updateApplicationPriority(Priority newPriority,\n-      ApplicationId applicationId, SettableFuture\u003cObject\u003e future)\n+      ApplicationId applicationId, SettableFuture\u003cObject\u003e future,\n+      UserGroupInformation user)\n       throws YarnException {\n-    Priority appPriority \u003d null;\n-    SchedulerApplication\u003cFiCaSchedulerApp\u003e application \u003d applications\n-        .get(applicationId);\n+    try {\n+      writeLock.lock();\n+      Priority appPriority \u003d null;\n+      SchedulerApplication\u003cFiCaSchedulerApp\u003e application \u003d applications\n+          .get(applicationId);\n \n-    if (application \u003d\u003d null) {\n-      throw new YarnException(\"Application \u0027\" + applicationId\n-          + \"\u0027 is not present, hence could not change priority.\");\n-    }\n+      if (application \u003d\u003d null) {\n+        throw new YarnException(\"Application \u0027\" + applicationId\n+            + \"\u0027 is not present, hence could not change priority.\");\n+      }\n \n-    RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n+      RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n \n-    appPriority \u003d checkAndGetApplicationPriority(newPriority, rmApp.getUser(),\n-        rmApp.getQueue(), applicationId);\n+      appPriority \u003d checkAndGetApplicationPriority(newPriority, user,\n+          rmApp.getQueue(), applicationId);\n \n-    if (application.getPriority().equals(appPriority)) {\n-      future.set(null);\n+      if (application.getPriority().equals(appPriority)) {\n+        future.set(null);\n+        return appPriority;\n+      }\n+\n+      // Update new priority in Submission Context to update to StateStore.\n+      rmApp.getApplicationSubmissionContext().setPriority(appPriority);\n+\n+      // Update to state store\n+      ApplicationStateData appState \u003d ApplicationStateData.newInstance(\n+          rmApp.getSubmitTime(), rmApp.getStartTime(),\n+          rmApp.getApplicationSubmissionContext(), rmApp.getUser(),\n+          rmApp.getCallerContext());\n+      appState.setApplicationTimeouts(rmApp.getApplicationTimeouts());\n+      rmContext.getStateStore().updateApplicationStateSynchronously(appState,\n+          false, future);\n+\n+      // As we use iterator over a TreeSet for OrderingPolicy, once we change\n+      // priority then reinsert back to make order correct.\n+      LeafQueue queue \u003d (LeafQueue) getQueue(rmApp.getQueue());\n+      queue.updateApplicationPriority(application, appPriority);\n+\n+      LOG.info(\"Priority \u0027\" + appPriority + \"\u0027 is updated in queue :\"\n+          + rmApp.getQueue() + \" for application: \" + applicationId\n+          + \" for the user: \" + rmApp.getUser());\n       return appPriority;\n+    } finally {\n+      writeLock.unlock();\n     }\n-\n-    // Update new priority in Submission Context to update to StateStore.\n-    rmApp.getApplicationSubmissionContext().setPriority(appPriority);\n-\n-    // Update to state store\n-    ApplicationStateData appState \u003d ApplicationStateData.newInstance(\n-        rmApp.getSubmitTime(), rmApp.getStartTime(),\n-        rmApp.getApplicationSubmissionContext(), rmApp.getUser(),\n-        rmApp.getCallerContext());\n-    appState.setApplicationTimeouts(rmApp.getApplicationTimeouts());\n-    rmContext.getStateStore().updateApplicationStateSynchronously(appState,\n-        false, future);\n-\n-    // As we use iterator over a TreeSet for OrderingPolicy, once we change\n-    // priority then reinsert back to make order correct.\n-    LeafQueue queue \u003d (LeafQueue) getQueue(rmApp.getQueue());\n-    queue.updateApplicationPriority(application, appPriority);\n-\n-    LOG.info(\"Priority \u0027\" + appPriority + \"\u0027 is updated in queue :\"\n-        + rmApp.getQueue() + \" for application: \" + applicationId\n-        + \" for the user: \" + rmApp.getUser());\n-    return appPriority;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Priority updateApplicationPriority(Priority newPriority,\n      ApplicationId applicationId, SettableFuture\u003cObject\u003e future,\n      UserGroupInformation user)\n      throws YarnException {\n    try {\n      writeLock.lock();\n      Priority appPriority \u003d null;\n      SchedulerApplication\u003cFiCaSchedulerApp\u003e application \u003d applications\n          .get(applicationId);\n\n      if (application \u003d\u003d null) {\n        throw new YarnException(\"Application \u0027\" + applicationId\n            + \"\u0027 is not present, hence could not change priority.\");\n      }\n\n      RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n\n      appPriority \u003d checkAndGetApplicationPriority(newPriority, user,\n          rmApp.getQueue(), applicationId);\n\n      if (application.getPriority().equals(appPriority)) {\n        future.set(null);\n        return appPriority;\n      }\n\n      // Update new priority in Submission Context to update to StateStore.\n      rmApp.getApplicationSubmissionContext().setPriority(appPriority);\n\n      // Update to state store\n      ApplicationStateData appState \u003d ApplicationStateData.newInstance(\n          rmApp.getSubmitTime(), rmApp.getStartTime(),\n          rmApp.getApplicationSubmissionContext(), rmApp.getUser(),\n          rmApp.getCallerContext());\n      appState.setApplicationTimeouts(rmApp.getApplicationTimeouts());\n      rmContext.getStateStore().updateApplicationStateSynchronously(appState,\n          false, future);\n\n      // As we use iterator over a TreeSet for OrderingPolicy, once we change\n      // priority then reinsert back to make order correct.\n      LeafQueue queue \u003d (LeafQueue) getQueue(rmApp.getQueue());\n      queue.updateApplicationPriority(application, appPriority);\n\n      LOG.info(\"Priority \u0027\" + appPriority + \"\u0027 is updated in queue :\"\n          + rmApp.getQueue() + \" for application: \" + applicationId\n          + \" for the user: \" + rmApp.getUser());\n      return appPriority;\n    } finally {\n      writeLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
          "extendedDetails": {
            "oldValue": "[newPriority-Priority, applicationId-ApplicationId, future-SettableFuture\u003cObject\u003e]",
            "newValue": "[newPriority-Priority, applicationId-ApplicationId, future-SettableFuture\u003cObject\u003e, user-UserGroupInformation]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-3955. Support for application priority ACLs in queues of CapacityScheduler. (Sunil G via wangda)\n",
          "commitDate": "09/01/17 8:40 AM",
          "commitName": "287d3d6804a869723ae36605a3c2d2b3eae3941e",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "05/01/17 10:31 AM",
          "commitNameOld": "0a55bd841ec0f2eb89a0383f4c589526e8b138d4",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 3.92,
          "commitsBetweenForRepo": 17,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,44 +1,50 @@\n   public Priority updateApplicationPriority(Priority newPriority,\n-      ApplicationId applicationId, SettableFuture\u003cObject\u003e future)\n+      ApplicationId applicationId, SettableFuture\u003cObject\u003e future,\n+      UserGroupInformation user)\n       throws YarnException {\n-    Priority appPriority \u003d null;\n-    SchedulerApplication\u003cFiCaSchedulerApp\u003e application \u003d applications\n-        .get(applicationId);\n+    try {\n+      writeLock.lock();\n+      Priority appPriority \u003d null;\n+      SchedulerApplication\u003cFiCaSchedulerApp\u003e application \u003d applications\n+          .get(applicationId);\n \n-    if (application \u003d\u003d null) {\n-      throw new YarnException(\"Application \u0027\" + applicationId\n-          + \"\u0027 is not present, hence could not change priority.\");\n-    }\n+      if (application \u003d\u003d null) {\n+        throw new YarnException(\"Application \u0027\" + applicationId\n+            + \"\u0027 is not present, hence could not change priority.\");\n+      }\n \n-    RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n+      RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n \n-    appPriority \u003d checkAndGetApplicationPriority(newPriority, rmApp.getUser(),\n-        rmApp.getQueue(), applicationId);\n+      appPriority \u003d checkAndGetApplicationPriority(newPriority, user,\n+          rmApp.getQueue(), applicationId);\n \n-    if (application.getPriority().equals(appPriority)) {\n-      future.set(null);\n+      if (application.getPriority().equals(appPriority)) {\n+        future.set(null);\n+        return appPriority;\n+      }\n+\n+      // Update new priority in Submission Context to update to StateStore.\n+      rmApp.getApplicationSubmissionContext().setPriority(appPriority);\n+\n+      // Update to state store\n+      ApplicationStateData appState \u003d ApplicationStateData.newInstance(\n+          rmApp.getSubmitTime(), rmApp.getStartTime(),\n+          rmApp.getApplicationSubmissionContext(), rmApp.getUser(),\n+          rmApp.getCallerContext());\n+      appState.setApplicationTimeouts(rmApp.getApplicationTimeouts());\n+      rmContext.getStateStore().updateApplicationStateSynchronously(appState,\n+          false, future);\n+\n+      // As we use iterator over a TreeSet for OrderingPolicy, once we change\n+      // priority then reinsert back to make order correct.\n+      LeafQueue queue \u003d (LeafQueue) getQueue(rmApp.getQueue());\n+      queue.updateApplicationPriority(application, appPriority);\n+\n+      LOG.info(\"Priority \u0027\" + appPriority + \"\u0027 is updated in queue :\"\n+          + rmApp.getQueue() + \" for application: \" + applicationId\n+          + \" for the user: \" + rmApp.getUser());\n       return appPriority;\n+    } finally {\n+      writeLock.unlock();\n     }\n-\n-    // Update new priority in Submission Context to update to StateStore.\n-    rmApp.getApplicationSubmissionContext().setPriority(appPriority);\n-\n-    // Update to state store\n-    ApplicationStateData appState \u003d ApplicationStateData.newInstance(\n-        rmApp.getSubmitTime(), rmApp.getStartTime(),\n-        rmApp.getApplicationSubmissionContext(), rmApp.getUser(),\n-        rmApp.getCallerContext());\n-    appState.setApplicationTimeouts(rmApp.getApplicationTimeouts());\n-    rmContext.getStateStore().updateApplicationStateSynchronously(appState,\n-        false, future);\n-\n-    // As we use iterator over a TreeSet for OrderingPolicy, once we change\n-    // priority then reinsert back to make order correct.\n-    LeafQueue queue \u003d (LeafQueue) getQueue(rmApp.getQueue());\n-    queue.updateApplicationPriority(application, appPriority);\n-\n-    LOG.info(\"Priority \u0027\" + appPriority + \"\u0027 is updated in queue :\"\n-        + rmApp.getQueue() + \" for application: \" + applicationId\n-        + \" for the user: \" + rmApp.getUser());\n-    return appPriority;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Priority updateApplicationPriority(Priority newPriority,\n      ApplicationId applicationId, SettableFuture\u003cObject\u003e future,\n      UserGroupInformation user)\n      throws YarnException {\n    try {\n      writeLock.lock();\n      Priority appPriority \u003d null;\n      SchedulerApplication\u003cFiCaSchedulerApp\u003e application \u003d applications\n          .get(applicationId);\n\n      if (application \u003d\u003d null) {\n        throw new YarnException(\"Application \u0027\" + applicationId\n            + \"\u0027 is not present, hence could not change priority.\");\n      }\n\n      RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n\n      appPriority \u003d checkAndGetApplicationPriority(newPriority, user,\n          rmApp.getQueue(), applicationId);\n\n      if (application.getPriority().equals(appPriority)) {\n        future.set(null);\n        return appPriority;\n      }\n\n      // Update new priority in Submission Context to update to StateStore.\n      rmApp.getApplicationSubmissionContext().setPriority(appPriority);\n\n      // Update to state store\n      ApplicationStateData appState \u003d ApplicationStateData.newInstance(\n          rmApp.getSubmitTime(), rmApp.getStartTime(),\n          rmApp.getApplicationSubmissionContext(), rmApp.getUser(),\n          rmApp.getCallerContext());\n      appState.setApplicationTimeouts(rmApp.getApplicationTimeouts());\n      rmContext.getStateStore().updateApplicationStateSynchronously(appState,\n          false, future);\n\n      // As we use iterator over a TreeSet for OrderingPolicy, once we change\n      // priority then reinsert back to make order correct.\n      LeafQueue queue \u003d (LeafQueue) getQueue(rmApp.getQueue());\n      queue.updateApplicationPriority(application, appPriority);\n\n      LOG.info(\"Priority \u0027\" + appPriority + \"\u0027 is updated in queue :\"\n          + rmApp.getQueue() + \" for application: \" + applicationId\n          + \" for the user: \" + rmApp.getUser());\n      return appPriority;\n    } finally {\n      writeLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
          "extendedDetails": {}
        }
      ]
    },
    "a926f895c11cd69cf2117c3b970304f3f1f53d92": {
      "type": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
      "commitMessage": "YARN-5865. Retrospect updateApplicationPriority api to handle state store exception in align with YARN-5611. Contributed by Sunil G.\n",
      "commitDate": "22/11/16 1:19 AM",
      "commitName": "a926f895c11cd69cf2117c3b970304f3f1f53d92",
      "commitAuthor": "Rohith Sharma K S",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-5865. Retrospect updateApplicationPriority api to handle state store exception in align with YARN-5611. Contributed by Sunil G.\n",
          "commitDate": "22/11/16 1:19 AM",
          "commitName": "a926f895c11cd69cf2117c3b970304f3f1f53d92",
          "commitAuthor": "Rohith Sharma K S",
          "commitDateOld": "11/11/16 7:18 AM",
          "commitNameOld": "503e73e849cbdd1194cc0d16b4969c60929aca11",
          "commitAuthorOld": "Naganarasimha",
          "daysBetweenCommits": 10.75,
          "commitsBetweenForRepo": 55,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,45 +1,44 @@\n-  public void updateApplicationPriority(Priority newPriority,\n-      ApplicationId applicationId) throws YarnException {\n+  public Priority updateApplicationPriority(Priority newPriority,\n+      ApplicationId applicationId, SettableFuture\u003cObject\u003e future)\n+      throws YarnException {\n     Priority appPriority \u003d null;\n     SchedulerApplication\u003cFiCaSchedulerApp\u003e application \u003d applications\n         .get(applicationId);\n \n     if (application \u003d\u003d null) {\n       throw new YarnException(\"Application \u0027\" + applicationId\n           + \"\u0027 is not present, hence could not change priority.\");\n     }\n \n     RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n+\n     appPriority \u003d checkAndGetApplicationPriority(newPriority, rmApp.getUser(),\n         rmApp.getQueue(), applicationId);\n \n     if (application.getPriority().equals(appPriority)) {\n-      return;\n+      future.set(null);\n+      return appPriority;\n     }\n \n-    // Update new priority in Submission Context to keep track in HA\n+    // Update new priority in Submission Context to update to StateStore.\n     rmApp.getApplicationSubmissionContext().setPriority(appPriority);\n \n     // Update to state store\n-    ApplicationStateData appState \u003d\n-        ApplicationStateData.newInstance(rmApp.getSubmitTime(),\n-            rmApp.getStartTime(), rmApp.getApplicationSubmissionContext(),\n-            rmApp.getUser(), rmApp.getCallerContext());\n+    ApplicationStateData appState \u003d ApplicationStateData.newInstance(\n+        rmApp.getSubmitTime(), rmApp.getStartTime(),\n+        rmApp.getApplicationSubmissionContext(), rmApp.getUser(),\n+        rmApp.getCallerContext());\n     appState.setApplicationTimeouts(rmApp.getApplicationTimeouts());\n     rmContext.getStateStore().updateApplicationStateSynchronously(appState,\n-        false, null);\n+        false, future);\n \n     // As we use iterator over a TreeSet for OrderingPolicy, once we change\n     // priority then reinsert back to make order correct.\n     LeafQueue queue \u003d (LeafQueue) getQueue(rmApp.getQueue());\n-\n     queue.updateApplicationPriority(application, appPriority);\n \n-    // Update the changed application state to timeline server\n-    rmContext.getSystemMetricsPublisher().appUpdated(rmApp,\n-        System.currentTimeMillis());\n-\n     LOG.info(\"Priority \u0027\" + appPriority + \"\u0027 is updated in queue :\"\n         + rmApp.getQueue() + \" for application: \" + applicationId\n         + \" for the user: \" + rmApp.getUser());\n+    return appPriority;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Priority updateApplicationPriority(Priority newPriority,\n      ApplicationId applicationId, SettableFuture\u003cObject\u003e future)\n      throws YarnException {\n    Priority appPriority \u003d null;\n    SchedulerApplication\u003cFiCaSchedulerApp\u003e application \u003d applications\n        .get(applicationId);\n\n    if (application \u003d\u003d null) {\n      throw new YarnException(\"Application \u0027\" + applicationId\n          + \"\u0027 is not present, hence could not change priority.\");\n    }\n\n    RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n\n    appPriority \u003d checkAndGetApplicationPriority(newPriority, rmApp.getUser(),\n        rmApp.getQueue(), applicationId);\n\n    if (application.getPriority().equals(appPriority)) {\n      future.set(null);\n      return appPriority;\n    }\n\n    // Update new priority in Submission Context to update to StateStore.\n    rmApp.getApplicationSubmissionContext().setPriority(appPriority);\n\n    // Update to state store\n    ApplicationStateData appState \u003d ApplicationStateData.newInstance(\n        rmApp.getSubmitTime(), rmApp.getStartTime(),\n        rmApp.getApplicationSubmissionContext(), rmApp.getUser(),\n        rmApp.getCallerContext());\n    appState.setApplicationTimeouts(rmApp.getApplicationTimeouts());\n    rmContext.getStateStore().updateApplicationStateSynchronously(appState,\n        false, future);\n\n    // As we use iterator over a TreeSet for OrderingPolicy, once we change\n    // priority then reinsert back to make order correct.\n    LeafQueue queue \u003d (LeafQueue) getQueue(rmApp.getQueue());\n    queue.updateApplicationPriority(application, appPriority);\n\n    LOG.info(\"Priority \u0027\" + appPriority + \"\u0027 is updated in queue :\"\n        + rmApp.getQueue() + \" for application: \" + applicationId\n        + \" for the user: \" + rmApp.getUser());\n    return appPriority;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
          "extendedDetails": {
            "oldValue": "[newPriority-Priority, applicationId-ApplicationId]",
            "newValue": "[newPriority-Priority, applicationId-ApplicationId, future-SettableFuture\u003cObject\u003e]"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "YARN-5865. Retrospect updateApplicationPriority api to handle state store exception in align with YARN-5611. Contributed by Sunil G.\n",
          "commitDate": "22/11/16 1:19 AM",
          "commitName": "a926f895c11cd69cf2117c3b970304f3f1f53d92",
          "commitAuthor": "Rohith Sharma K S",
          "commitDateOld": "11/11/16 7:18 AM",
          "commitNameOld": "503e73e849cbdd1194cc0d16b4969c60929aca11",
          "commitAuthorOld": "Naganarasimha",
          "daysBetweenCommits": 10.75,
          "commitsBetweenForRepo": 55,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,45 +1,44 @@\n-  public void updateApplicationPriority(Priority newPriority,\n-      ApplicationId applicationId) throws YarnException {\n+  public Priority updateApplicationPriority(Priority newPriority,\n+      ApplicationId applicationId, SettableFuture\u003cObject\u003e future)\n+      throws YarnException {\n     Priority appPriority \u003d null;\n     SchedulerApplication\u003cFiCaSchedulerApp\u003e application \u003d applications\n         .get(applicationId);\n \n     if (application \u003d\u003d null) {\n       throw new YarnException(\"Application \u0027\" + applicationId\n           + \"\u0027 is not present, hence could not change priority.\");\n     }\n \n     RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n+\n     appPriority \u003d checkAndGetApplicationPriority(newPriority, rmApp.getUser(),\n         rmApp.getQueue(), applicationId);\n \n     if (application.getPriority().equals(appPriority)) {\n-      return;\n+      future.set(null);\n+      return appPriority;\n     }\n \n-    // Update new priority in Submission Context to keep track in HA\n+    // Update new priority in Submission Context to update to StateStore.\n     rmApp.getApplicationSubmissionContext().setPriority(appPriority);\n \n     // Update to state store\n-    ApplicationStateData appState \u003d\n-        ApplicationStateData.newInstance(rmApp.getSubmitTime(),\n-            rmApp.getStartTime(), rmApp.getApplicationSubmissionContext(),\n-            rmApp.getUser(), rmApp.getCallerContext());\n+    ApplicationStateData appState \u003d ApplicationStateData.newInstance(\n+        rmApp.getSubmitTime(), rmApp.getStartTime(),\n+        rmApp.getApplicationSubmissionContext(), rmApp.getUser(),\n+        rmApp.getCallerContext());\n     appState.setApplicationTimeouts(rmApp.getApplicationTimeouts());\n     rmContext.getStateStore().updateApplicationStateSynchronously(appState,\n-        false, null);\n+        false, future);\n \n     // As we use iterator over a TreeSet for OrderingPolicy, once we change\n     // priority then reinsert back to make order correct.\n     LeafQueue queue \u003d (LeafQueue) getQueue(rmApp.getQueue());\n-\n     queue.updateApplicationPriority(application, appPriority);\n \n-    // Update the changed application state to timeline server\n-    rmContext.getSystemMetricsPublisher().appUpdated(rmApp,\n-        System.currentTimeMillis());\n-\n     LOG.info(\"Priority \u0027\" + appPriority + \"\u0027 is updated in queue :\"\n         + rmApp.getQueue() + \" for application: \" + applicationId\n         + \" for the user: \" + rmApp.getUser());\n+    return appPriority;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Priority updateApplicationPriority(Priority newPriority,\n      ApplicationId applicationId, SettableFuture\u003cObject\u003e future)\n      throws YarnException {\n    Priority appPriority \u003d null;\n    SchedulerApplication\u003cFiCaSchedulerApp\u003e application \u003d applications\n        .get(applicationId);\n\n    if (application \u003d\u003d null) {\n      throw new YarnException(\"Application \u0027\" + applicationId\n          + \"\u0027 is not present, hence could not change priority.\");\n    }\n\n    RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n\n    appPriority \u003d checkAndGetApplicationPriority(newPriority, rmApp.getUser(),\n        rmApp.getQueue(), applicationId);\n\n    if (application.getPriority().equals(appPriority)) {\n      future.set(null);\n      return appPriority;\n    }\n\n    // Update new priority in Submission Context to update to StateStore.\n    rmApp.getApplicationSubmissionContext().setPriority(appPriority);\n\n    // Update to state store\n    ApplicationStateData appState \u003d ApplicationStateData.newInstance(\n        rmApp.getSubmitTime(), rmApp.getStartTime(),\n        rmApp.getApplicationSubmissionContext(), rmApp.getUser(),\n        rmApp.getCallerContext());\n    appState.setApplicationTimeouts(rmApp.getApplicationTimeouts());\n    rmContext.getStateStore().updateApplicationStateSynchronously(appState,\n        false, future);\n\n    // As we use iterator over a TreeSet for OrderingPolicy, once we change\n    // priority then reinsert back to make order correct.\n    LeafQueue queue \u003d (LeafQueue) getQueue(rmApp.getQueue());\n    queue.updateApplicationPriority(application, appPriority);\n\n    LOG.info(\"Priority \u0027\" + appPriority + \"\u0027 is updated in queue :\"\n        + rmApp.getQueue() + \" for application: \" + applicationId\n        + \" for the user: \" + rmApp.getUser());\n    return appPriority;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
          "extendedDetails": {
            "oldValue": "void",
            "newValue": "Priority"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-5865. Retrospect updateApplicationPriority api to handle state store exception in align with YARN-5611. Contributed by Sunil G.\n",
          "commitDate": "22/11/16 1:19 AM",
          "commitName": "a926f895c11cd69cf2117c3b970304f3f1f53d92",
          "commitAuthor": "Rohith Sharma K S",
          "commitDateOld": "11/11/16 7:18 AM",
          "commitNameOld": "503e73e849cbdd1194cc0d16b4969c60929aca11",
          "commitAuthorOld": "Naganarasimha",
          "daysBetweenCommits": 10.75,
          "commitsBetweenForRepo": 55,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,45 +1,44 @@\n-  public void updateApplicationPriority(Priority newPriority,\n-      ApplicationId applicationId) throws YarnException {\n+  public Priority updateApplicationPriority(Priority newPriority,\n+      ApplicationId applicationId, SettableFuture\u003cObject\u003e future)\n+      throws YarnException {\n     Priority appPriority \u003d null;\n     SchedulerApplication\u003cFiCaSchedulerApp\u003e application \u003d applications\n         .get(applicationId);\n \n     if (application \u003d\u003d null) {\n       throw new YarnException(\"Application \u0027\" + applicationId\n           + \"\u0027 is not present, hence could not change priority.\");\n     }\n \n     RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n+\n     appPriority \u003d checkAndGetApplicationPriority(newPriority, rmApp.getUser(),\n         rmApp.getQueue(), applicationId);\n \n     if (application.getPriority().equals(appPriority)) {\n-      return;\n+      future.set(null);\n+      return appPriority;\n     }\n \n-    // Update new priority in Submission Context to keep track in HA\n+    // Update new priority in Submission Context to update to StateStore.\n     rmApp.getApplicationSubmissionContext().setPriority(appPriority);\n \n     // Update to state store\n-    ApplicationStateData appState \u003d\n-        ApplicationStateData.newInstance(rmApp.getSubmitTime(),\n-            rmApp.getStartTime(), rmApp.getApplicationSubmissionContext(),\n-            rmApp.getUser(), rmApp.getCallerContext());\n+    ApplicationStateData appState \u003d ApplicationStateData.newInstance(\n+        rmApp.getSubmitTime(), rmApp.getStartTime(),\n+        rmApp.getApplicationSubmissionContext(), rmApp.getUser(),\n+        rmApp.getCallerContext());\n     appState.setApplicationTimeouts(rmApp.getApplicationTimeouts());\n     rmContext.getStateStore().updateApplicationStateSynchronously(appState,\n-        false, null);\n+        false, future);\n \n     // As we use iterator over a TreeSet for OrderingPolicy, once we change\n     // priority then reinsert back to make order correct.\n     LeafQueue queue \u003d (LeafQueue) getQueue(rmApp.getQueue());\n-\n     queue.updateApplicationPriority(application, appPriority);\n \n-    // Update the changed application state to timeline server\n-    rmContext.getSystemMetricsPublisher().appUpdated(rmApp,\n-        System.currentTimeMillis());\n-\n     LOG.info(\"Priority \u0027\" + appPriority + \"\u0027 is updated in queue :\"\n         + rmApp.getQueue() + \" for application: \" + applicationId\n         + \" for the user: \" + rmApp.getUser());\n+    return appPriority;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Priority updateApplicationPriority(Priority newPriority,\n      ApplicationId applicationId, SettableFuture\u003cObject\u003e future)\n      throws YarnException {\n    Priority appPriority \u003d null;\n    SchedulerApplication\u003cFiCaSchedulerApp\u003e application \u003d applications\n        .get(applicationId);\n\n    if (application \u003d\u003d null) {\n      throw new YarnException(\"Application \u0027\" + applicationId\n          + \"\u0027 is not present, hence could not change priority.\");\n    }\n\n    RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n\n    appPriority \u003d checkAndGetApplicationPriority(newPriority, rmApp.getUser(),\n        rmApp.getQueue(), applicationId);\n\n    if (application.getPriority().equals(appPriority)) {\n      future.set(null);\n      return appPriority;\n    }\n\n    // Update new priority in Submission Context to update to StateStore.\n    rmApp.getApplicationSubmissionContext().setPriority(appPriority);\n\n    // Update to state store\n    ApplicationStateData appState \u003d ApplicationStateData.newInstance(\n        rmApp.getSubmitTime(), rmApp.getStartTime(),\n        rmApp.getApplicationSubmissionContext(), rmApp.getUser(),\n        rmApp.getCallerContext());\n    appState.setApplicationTimeouts(rmApp.getApplicationTimeouts());\n    rmContext.getStateStore().updateApplicationStateSynchronously(appState,\n        false, future);\n\n    // As we use iterator over a TreeSet for OrderingPolicy, once we change\n    // priority then reinsert back to make order correct.\n    LeafQueue queue \u003d (LeafQueue) getQueue(rmApp.getQueue());\n    queue.updateApplicationPriority(application, appPriority);\n\n    LOG.info(\"Priority \u0027\" + appPriority + \"\u0027 is updated in queue :\"\n        + rmApp.getQueue() + \" for application: \" + applicationId\n        + \" for the user: \" + rmApp.getUser());\n    return appPriority;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
          "extendedDetails": {}
        }
      ]
    },
    "bcc15c6290b3912a054323695a6a931b0de163bd": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5611. Provide an API to update lifetime of an application. Contributed by Rohith Sharma K S\n",
      "commitDate": "09/11/16 4:08 PM",
      "commitName": "bcc15c6290b3912a054323695a6a931b0de163bd",
      "commitAuthor": "Jian He",
      "commitDateOld": "07/11/16 10:14 AM",
      "commitNameOld": "de3b4aac561258ad242a3c5ed1c919428893fd4c",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 2.25,
      "commitsBetweenForRepo": 22,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,44 +1,45 @@\n   public void updateApplicationPriority(Priority newPriority,\n       ApplicationId applicationId) throws YarnException {\n     Priority appPriority \u003d null;\n     SchedulerApplication\u003cFiCaSchedulerApp\u003e application \u003d applications\n         .get(applicationId);\n \n     if (application \u003d\u003d null) {\n       throw new YarnException(\"Application \u0027\" + applicationId\n           + \"\u0027 is not present, hence could not change priority.\");\n     }\n \n     RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n     appPriority \u003d checkAndGetApplicationPriority(newPriority, rmApp.getUser(),\n         rmApp.getQueue(), applicationId);\n \n     if (application.getPriority().equals(appPriority)) {\n       return;\n     }\n \n     // Update new priority in Submission Context to keep track in HA\n     rmApp.getApplicationSubmissionContext().setPriority(appPriority);\n \n     // Update to state store\n     ApplicationStateData appState \u003d\n         ApplicationStateData.newInstance(rmApp.getSubmitTime(),\n             rmApp.getStartTime(), rmApp.getApplicationSubmissionContext(),\n             rmApp.getUser(), rmApp.getCallerContext());\n+    appState.setApplicationTimeouts(rmApp.getApplicationTimeouts());\n     rmContext.getStateStore().updateApplicationStateSynchronously(appState,\n-        false);\n+        false, null);\n \n     // As we use iterator over a TreeSet for OrderingPolicy, once we change\n     // priority then reinsert back to make order correct.\n     LeafQueue queue \u003d (LeafQueue) getQueue(rmApp.getQueue());\n \n     queue.updateApplicationPriority(application, appPriority);\n \n     // Update the changed application state to timeline server\n     rmContext.getSystemMetricsPublisher().appUpdated(rmApp,\n         System.currentTimeMillis());\n \n     LOG.info(\"Priority \u0027\" + appPriority + \"\u0027 is updated in queue :\"\n         + rmApp.getQueue() + \" for application: \" + applicationId\n         + \" for the user: \" + rmApp.getUser());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void updateApplicationPriority(Priority newPriority,\n      ApplicationId applicationId) throws YarnException {\n    Priority appPriority \u003d null;\n    SchedulerApplication\u003cFiCaSchedulerApp\u003e application \u003d applications\n        .get(applicationId);\n\n    if (application \u003d\u003d null) {\n      throw new YarnException(\"Application \u0027\" + applicationId\n          + \"\u0027 is not present, hence could not change priority.\");\n    }\n\n    RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n    appPriority \u003d checkAndGetApplicationPriority(newPriority, rmApp.getUser(),\n        rmApp.getQueue(), applicationId);\n\n    if (application.getPriority().equals(appPriority)) {\n      return;\n    }\n\n    // Update new priority in Submission Context to keep track in HA\n    rmApp.getApplicationSubmissionContext().setPriority(appPriority);\n\n    // Update to state store\n    ApplicationStateData appState \u003d\n        ApplicationStateData.newInstance(rmApp.getSubmitTime(),\n            rmApp.getStartTime(), rmApp.getApplicationSubmissionContext(),\n            rmApp.getUser(), rmApp.getCallerContext());\n    appState.setApplicationTimeouts(rmApp.getApplicationTimeouts());\n    rmContext.getStateStore().updateApplicationStateSynchronously(appState,\n        false, null);\n\n    // As we use iterator over a TreeSet for OrderingPolicy, once we change\n    // priority then reinsert back to make order correct.\n    LeafQueue queue \u003d (LeafQueue) getQueue(rmApp.getQueue());\n\n    queue.updateApplicationPriority(application, appPriority);\n\n    // Update the changed application state to timeline server\n    rmContext.getSystemMetricsPublisher().appUpdated(rmApp,\n        System.currentTimeMillis());\n\n    LOG.info(\"Priority \u0027\" + appPriority + \"\u0027 is updated in queue :\"\n        + rmApp.getQueue() + \" for application: \" + applicationId\n        + \" for the user: \" + rmApp.getUser());\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3139. Improve locks in AbstractYarnScheduler/CapacityScheduler/FairScheduler. Contributed by Wangda Tan\n",
      "commitDate": "04/10/16 5:23 PM",
      "commitName": "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f",
      "commitAuthor": "Jian He",
      "commitDateOld": "30/08/16 3:52 PM",
      "commitNameOld": "d6d9cff21b7b6141ed88359652cf22e8973c0661",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 35.06,
      "commitsBetweenForRepo": 195,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,44 @@\n   public void updateApplicationPriority(Priority newPriority,\n       ApplicationId applicationId) throws YarnException {\n     Priority appPriority \u003d null;\n     SchedulerApplication\u003cFiCaSchedulerApp\u003e application \u003d applications\n         .get(applicationId);\n \n     if (application \u003d\u003d null) {\n       throw new YarnException(\"Application \u0027\" + applicationId\n           + \"\u0027 is not present, hence could not change priority.\");\n     }\n \n     RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n     appPriority \u003d checkAndGetApplicationPriority(newPriority, rmApp.getUser(),\n         rmApp.getQueue(), applicationId);\n \n     if (application.getPriority().equals(appPriority)) {\n       return;\n     }\n \n     // Update new priority in Submission Context to keep track in HA\n     rmApp.getApplicationSubmissionContext().setPriority(appPriority);\n \n     // Update to state store\n     ApplicationStateData appState \u003d\n         ApplicationStateData.newInstance(rmApp.getSubmitTime(),\n             rmApp.getStartTime(), rmApp.getApplicationSubmissionContext(),\n             rmApp.getUser(), rmApp.getCallerContext());\n     rmContext.getStateStore().updateApplicationStateSynchronously(appState,\n         false);\n \n     // As we use iterator over a TreeSet for OrderingPolicy, once we change\n     // priority then reinsert back to make order correct.\n     LeafQueue queue \u003d (LeafQueue) getQueue(rmApp.getQueue());\n-    synchronized (queue) {\n-      queue.getOrderingPolicy().removeSchedulableEntity(\n-          application.getCurrentAppAttempt());\n \n-      // Update new priority in SchedulerApplication\n-      application.setPriority(appPriority);\n-\n-      queue.getOrderingPolicy().addSchedulableEntity(\n-          application.getCurrentAppAttempt());\n-    }\n+    queue.updateApplicationPriority(application, appPriority);\n \n     // Update the changed application state to timeline server\n     rmContext.getSystemMetricsPublisher().appUpdated(rmApp,\n         System.currentTimeMillis());\n \n     LOG.info(\"Priority \u0027\" + appPriority + \"\u0027 is updated in queue :\"\n         + rmApp.getQueue() + \" for application: \" + applicationId\n         + \" for the user: \" + rmApp.getUser());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void updateApplicationPriority(Priority newPriority,\n      ApplicationId applicationId) throws YarnException {\n    Priority appPriority \u003d null;\n    SchedulerApplication\u003cFiCaSchedulerApp\u003e application \u003d applications\n        .get(applicationId);\n\n    if (application \u003d\u003d null) {\n      throw new YarnException(\"Application \u0027\" + applicationId\n          + \"\u0027 is not present, hence could not change priority.\");\n    }\n\n    RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n    appPriority \u003d checkAndGetApplicationPriority(newPriority, rmApp.getUser(),\n        rmApp.getQueue(), applicationId);\n\n    if (application.getPriority().equals(appPriority)) {\n      return;\n    }\n\n    // Update new priority in Submission Context to keep track in HA\n    rmApp.getApplicationSubmissionContext().setPriority(appPriority);\n\n    // Update to state store\n    ApplicationStateData appState \u003d\n        ApplicationStateData.newInstance(rmApp.getSubmitTime(),\n            rmApp.getStartTime(), rmApp.getApplicationSubmissionContext(),\n            rmApp.getUser(), rmApp.getCallerContext());\n    rmContext.getStateStore().updateApplicationStateSynchronously(appState,\n        false);\n\n    // As we use iterator over a TreeSet for OrderingPolicy, once we change\n    // priority then reinsert back to make order correct.\n    LeafQueue queue \u003d (LeafQueue) getQueue(rmApp.getQueue());\n\n    queue.updateApplicationPriority(application, appPriority);\n\n    // Update the changed application state to timeline server\n    rmContext.getSystemMetricsPublisher().appUpdated(rmApp,\n        System.currentTimeMillis());\n\n    LOG.info(\"Priority \u0027\" + appPriority + \"\u0027 is updated in queue :\"\n        + rmApp.getQueue() + \" for application: \" + applicationId\n        + \" for the user: \" + rmApp.getUser());\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "8676a118a12165ae5a8b80a2a4596c133471ebc1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4349. Support CallerContext in YARN. Contributed by Wangda Tan\n",
      "commitDate": "23/11/15 5:19 PM",
      "commitName": "8676a118a12165ae5a8b80a2a4596c133471ebc1",
      "commitAuthor": "Jian He",
      "commitDateOld": "23/11/15 12:30 PM",
      "commitNameOld": "d36b6e045f317c94e97cb41a163aa974d161a404",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 0.2,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,51 +1,52 @@\n   public void updateApplicationPriority(Priority newPriority,\n       ApplicationId applicationId) throws YarnException {\n     Priority appPriority \u003d null;\n     SchedulerApplication\u003cFiCaSchedulerApp\u003e application \u003d applications\n         .get(applicationId);\n \n     if (application \u003d\u003d null) {\n       throw new YarnException(\"Application \u0027\" + applicationId\n           + \"\u0027 is not present, hence could not change priority.\");\n     }\n \n     RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n     appPriority \u003d checkAndGetApplicationPriority(newPriority, rmApp.getUser(),\n         rmApp.getQueue(), applicationId);\n \n     if (application.getPriority().equals(appPriority)) {\n       return;\n     }\n \n     // Update new priority in Submission Context to keep track in HA\n     rmApp.getApplicationSubmissionContext().setPriority(appPriority);\n \n     // Update to state store\n-    ApplicationStateData appState \u003d ApplicationStateData.newInstance(\n-        rmApp.getSubmitTime(), rmApp.getStartTime(),\n-        rmApp.getApplicationSubmissionContext(), rmApp.getUser());\n+    ApplicationStateData appState \u003d\n+        ApplicationStateData.newInstance(rmApp.getSubmitTime(),\n+            rmApp.getStartTime(), rmApp.getApplicationSubmissionContext(),\n+            rmApp.getUser(), rmApp.getCallerContext());\n     rmContext.getStateStore().updateApplicationStateSynchronously(appState,\n         false);\n \n     // As we use iterator over a TreeSet for OrderingPolicy, once we change\n     // priority then reinsert back to make order correct.\n     LeafQueue queue \u003d (LeafQueue) getQueue(rmApp.getQueue());\n     synchronized (queue) {\n       queue.getOrderingPolicy().removeSchedulableEntity(\n           application.getCurrentAppAttempt());\n \n       // Update new priority in SchedulerApplication\n       application.setPriority(appPriority);\n \n       queue.getOrderingPolicy().addSchedulableEntity(\n           application.getCurrentAppAttempt());\n     }\n \n     // Update the changed application state to timeline server\n     rmContext.getSystemMetricsPublisher().appUpdated(rmApp,\n         System.currentTimeMillis());\n \n     LOG.info(\"Priority \u0027\" + appPriority + \"\u0027 is updated in queue :\"\n         + rmApp.getQueue() + \" for application: \" + applicationId\n         + \" for the user: \" + rmApp.getUser());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void updateApplicationPriority(Priority newPriority,\n      ApplicationId applicationId) throws YarnException {\n    Priority appPriority \u003d null;\n    SchedulerApplication\u003cFiCaSchedulerApp\u003e application \u003d applications\n        .get(applicationId);\n\n    if (application \u003d\u003d null) {\n      throw new YarnException(\"Application \u0027\" + applicationId\n          + \"\u0027 is not present, hence could not change priority.\");\n    }\n\n    RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n    appPriority \u003d checkAndGetApplicationPriority(newPriority, rmApp.getUser(),\n        rmApp.getQueue(), applicationId);\n\n    if (application.getPriority().equals(appPriority)) {\n      return;\n    }\n\n    // Update new priority in Submission Context to keep track in HA\n    rmApp.getApplicationSubmissionContext().setPriority(appPriority);\n\n    // Update to state store\n    ApplicationStateData appState \u003d\n        ApplicationStateData.newInstance(rmApp.getSubmitTime(),\n            rmApp.getStartTime(), rmApp.getApplicationSubmissionContext(),\n            rmApp.getUser(), rmApp.getCallerContext());\n    rmContext.getStateStore().updateApplicationStateSynchronously(appState,\n        false);\n\n    // As we use iterator over a TreeSet for OrderingPolicy, once we change\n    // priority then reinsert back to make order correct.\n    LeafQueue queue \u003d (LeafQueue) getQueue(rmApp.getQueue());\n    synchronized (queue) {\n      queue.getOrderingPolicy().removeSchedulableEntity(\n          application.getCurrentAppAttempt());\n\n      // Update new priority in SchedulerApplication\n      application.setPriority(appPriority);\n\n      queue.getOrderingPolicy().addSchedulableEntity(\n          application.getCurrentAppAttempt());\n    }\n\n    // Update the changed application state to timeline server\n    rmContext.getSystemMetricsPublisher().appUpdated(rmApp,\n        System.currentTimeMillis());\n\n    LOG.info(\"Priority \u0027\" + appPriority + \"\u0027 is updated in queue :\"\n        + rmApp.getQueue() + \" for application: \" + applicationId\n        + \" for the user: \" + rmApp.getUser());\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "a9aafad12b1d2f67e55e09a6fa261d61789c9d7e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4044. Running applications information changes such as movequeue is not published to TimeLine server. (Sunil G via rohithsharmaks)\n",
      "commitDate": "23/09/15 11:43 PM",
      "commitName": "a9aafad12b1d2f67e55e09a6fa261d61789c9d7e",
      "commitAuthor": "Rohith Sharma K S",
      "commitDateOld": "23/09/15 1:29 PM",
      "commitNameOld": "89cab1ba5f0671f8ef30dbe7432079c18362b434",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 0.43,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,51 @@\n   public void updateApplicationPriority(Priority newPriority,\n       ApplicationId applicationId) throws YarnException {\n     Priority appPriority \u003d null;\n     SchedulerApplication\u003cFiCaSchedulerApp\u003e application \u003d applications\n         .get(applicationId);\n \n     if (application \u003d\u003d null) {\n       throw new YarnException(\"Application \u0027\" + applicationId\n           + \"\u0027 is not present, hence could not change priority.\");\n     }\n \n     RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n     appPriority \u003d checkAndGetApplicationPriority(newPriority, rmApp.getUser(),\n         rmApp.getQueue(), applicationId);\n \n     if (application.getPriority().equals(appPriority)) {\n       return;\n     }\n \n     // Update new priority in Submission Context to keep track in HA\n     rmApp.getApplicationSubmissionContext().setPriority(appPriority);\n \n     // Update to state store\n     ApplicationStateData appState \u003d ApplicationStateData.newInstance(\n         rmApp.getSubmitTime(), rmApp.getStartTime(),\n         rmApp.getApplicationSubmissionContext(), rmApp.getUser());\n     rmContext.getStateStore().updateApplicationStateSynchronously(appState,\n         false);\n \n     // As we use iterator over a TreeSet for OrderingPolicy, once we change\n     // priority then reinsert back to make order correct.\n     LeafQueue queue \u003d (LeafQueue) getQueue(rmApp.getQueue());\n     synchronized (queue) {\n       queue.getOrderingPolicy().removeSchedulableEntity(\n           application.getCurrentAppAttempt());\n \n       // Update new priority in SchedulerApplication\n       application.setPriority(appPriority);\n \n       queue.getOrderingPolicy().addSchedulableEntity(\n           application.getCurrentAppAttempt());\n     }\n \n+    // Update the changed application state to timeline server\n+    rmContext.getSystemMetricsPublisher().appUpdated(rmApp,\n+        System.currentTimeMillis());\n+\n     LOG.info(\"Priority \u0027\" + appPriority + \"\u0027 is updated in queue :\"\n         + rmApp.getQueue() + \" for application: \" + applicationId\n         + \" for the user: \" + rmApp.getUser());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void updateApplicationPriority(Priority newPriority,\n      ApplicationId applicationId) throws YarnException {\n    Priority appPriority \u003d null;\n    SchedulerApplication\u003cFiCaSchedulerApp\u003e application \u003d applications\n        .get(applicationId);\n\n    if (application \u003d\u003d null) {\n      throw new YarnException(\"Application \u0027\" + applicationId\n          + \"\u0027 is not present, hence could not change priority.\");\n    }\n\n    RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n    appPriority \u003d checkAndGetApplicationPriority(newPriority, rmApp.getUser(),\n        rmApp.getQueue(), applicationId);\n\n    if (application.getPriority().equals(appPriority)) {\n      return;\n    }\n\n    // Update new priority in Submission Context to keep track in HA\n    rmApp.getApplicationSubmissionContext().setPriority(appPriority);\n\n    // Update to state store\n    ApplicationStateData appState \u003d ApplicationStateData.newInstance(\n        rmApp.getSubmitTime(), rmApp.getStartTime(),\n        rmApp.getApplicationSubmissionContext(), rmApp.getUser());\n    rmContext.getStateStore().updateApplicationStateSynchronously(appState,\n        false);\n\n    // As we use iterator over a TreeSet for OrderingPolicy, once we change\n    // priority then reinsert back to make order correct.\n    LeafQueue queue \u003d (LeafQueue) getQueue(rmApp.getQueue());\n    synchronized (queue) {\n      queue.getOrderingPolicy().removeSchedulableEntity(\n          application.getCurrentAppAttempt());\n\n      // Update new priority in SchedulerApplication\n      application.setPriority(appPriority);\n\n      queue.getOrderingPolicy().addSchedulableEntity(\n          application.getCurrentAppAttempt());\n    }\n\n    // Update the changed application state to timeline server\n    rmContext.getSystemMetricsPublisher().appUpdated(rmApp,\n        System.currentTimeMillis());\n\n    LOG.info(\"Priority \u0027\" + appPriority + \"\u0027 is updated in queue :\"\n        + rmApp.getQueue() + \" for application: \" + applicationId\n        + \" for the user: \" + rmApp.getUser());\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "b469ac531af1bdda01a04ae0b8d39218ca292163": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3970. Add REST api support for Application Priority. Contributed by Naganarasimha G R.\n",
      "commitDate": "03/09/15 4:10 AM",
      "commitName": "b469ac531af1bdda01a04ae0b8d39218ca292163",
      "commitAuthor": "Varun Vasudev",
      "commitDateOld": "01/09/15 1:49 AM",
      "commitNameOld": "bf669b6d9f8ba165e30b8823218d625a49958925",
      "commitAuthorOld": "Varun Vasudev",
      "daysBetweenCommits": 2.1,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,47 @@\n   public void updateApplicationPriority(Priority newPriority,\n       ApplicationId applicationId) throws YarnException {\n     Priority appPriority \u003d null;\n     SchedulerApplication\u003cFiCaSchedulerApp\u003e application \u003d applications\n         .get(applicationId);\n \n     if (application \u003d\u003d null) {\n       throw new YarnException(\"Application \u0027\" + applicationId\n           + \"\u0027 is not present, hence could not change priority.\");\n     }\n \n-    if (application.getPriority().equals(newPriority)) {\n-      return;\n-    }\n-\n     RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n     appPriority \u003d checkAndGetApplicationPriority(newPriority, rmApp.getUser(),\n         rmApp.getQueue(), applicationId);\n \n+    if (application.getPriority().equals(appPriority)) {\n+      return;\n+    }\n+\n     // Update new priority in Submission Context to keep track in HA\n     rmApp.getApplicationSubmissionContext().setPriority(appPriority);\n \n     // Update to state store\n     ApplicationStateData appState \u003d ApplicationStateData.newInstance(\n         rmApp.getSubmitTime(), rmApp.getStartTime(),\n         rmApp.getApplicationSubmissionContext(), rmApp.getUser());\n     rmContext.getStateStore().updateApplicationStateSynchronously(appState,\n         false);\n \n     // As we use iterator over a TreeSet for OrderingPolicy, once we change\n     // priority then reinsert back to make order correct.\n     LeafQueue queue \u003d (LeafQueue) getQueue(rmApp.getQueue());\n     synchronized (queue) {\n       queue.getOrderingPolicy().removeSchedulableEntity(\n           application.getCurrentAppAttempt());\n \n       // Update new priority in SchedulerApplication\n       application.setPriority(appPriority);\n \n       queue.getOrderingPolicy().addSchedulableEntity(\n           application.getCurrentAppAttempt());\n     }\n \n     LOG.info(\"Priority \u0027\" + appPriority + \"\u0027 is updated in queue :\"\n-        + rmApp.getQueue() + \"for application:\" + applicationId\n-        + \"for the user: \" + rmApp.getUser());\n+        + rmApp.getQueue() + \" for application: \" + applicationId\n+        + \" for the user: \" + rmApp.getUser());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void updateApplicationPriority(Priority newPriority,\n      ApplicationId applicationId) throws YarnException {\n    Priority appPriority \u003d null;\n    SchedulerApplication\u003cFiCaSchedulerApp\u003e application \u003d applications\n        .get(applicationId);\n\n    if (application \u003d\u003d null) {\n      throw new YarnException(\"Application \u0027\" + applicationId\n          + \"\u0027 is not present, hence could not change priority.\");\n    }\n\n    RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n    appPriority \u003d checkAndGetApplicationPriority(newPriority, rmApp.getUser(),\n        rmApp.getQueue(), applicationId);\n\n    if (application.getPriority().equals(appPriority)) {\n      return;\n    }\n\n    // Update new priority in Submission Context to keep track in HA\n    rmApp.getApplicationSubmissionContext().setPriority(appPriority);\n\n    // Update to state store\n    ApplicationStateData appState \u003d ApplicationStateData.newInstance(\n        rmApp.getSubmitTime(), rmApp.getStartTime(),\n        rmApp.getApplicationSubmissionContext(), rmApp.getUser());\n    rmContext.getStateStore().updateApplicationStateSynchronously(appState,\n        false);\n\n    // As we use iterator over a TreeSet for OrderingPolicy, once we change\n    // priority then reinsert back to make order correct.\n    LeafQueue queue \u003d (LeafQueue) getQueue(rmApp.getQueue());\n    synchronized (queue) {\n      queue.getOrderingPolicy().removeSchedulableEntity(\n          application.getCurrentAppAttempt());\n\n      // Update new priority in SchedulerApplication\n      application.setPriority(appPriority);\n\n      queue.getOrderingPolicy().addSchedulableEntity(\n          application.getCurrentAppAttempt());\n    }\n\n    LOG.info(\"Priority \u0027\" + appPriority + \"\u0027 is updated in queue :\"\n        + rmApp.getQueue() + \" for application: \" + applicationId\n        + \" for the user: \" + rmApp.getUser());\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "57c7ae1affb2e1821fbdc3f47738d7e6fd83c7c1": {
      "type": "Ymultichange(Ymodifierchange,Ybodychange)",
      "commitMessage": "YARN-4014. Support user cli interface in for Application Priority. Contributed by Rohith Sharma K S\n",
      "commitDate": "24/08/15 8:36 PM",
      "commitName": "57c7ae1affb2e1821fbdc3f47738d7e6fd83c7c1",
      "commitAuthor": "Jian He",
      "subchanges": [
        {
          "type": "Ymodifierchange",
          "commitMessage": "YARN-4014. Support user cli interface in for Application Priority. Contributed by Rohith Sharma K S\n",
          "commitDate": "24/08/15 8:36 PM",
          "commitName": "57c7ae1affb2e1821fbdc3f47738d7e6fd83c7c1",
          "commitAuthor": "Jian He",
          "commitDateOld": "10/08/15 8:51 PM",
          "commitNameOld": "fa1d84ae2739a1e76f58b9c96d1378f9453cc0d2",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 13.99,
          "commitsBetweenForRepo": 83,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,46 +1,47 @@\n-  public synchronized void updateApplicationPriority(Priority newPriority,\n+  public void updateApplicationPriority(Priority newPriority,\n       ApplicationId applicationId) throws YarnException {\n     Priority appPriority \u003d null;\n     SchedulerApplication\u003cFiCaSchedulerApp\u003e application \u003d applications\n         .get(applicationId);\n \n     if (application \u003d\u003d null) {\n       throw new YarnException(\"Application \u0027\" + applicationId\n           + \"\u0027 is not present, hence could not change priority.\");\n     }\n \n     if (application.getPriority().equals(newPriority)) {\n       return;\n     }\n \n     RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n     appPriority \u003d checkAndGetApplicationPriority(newPriority, rmApp.getUser(),\n         rmApp.getQueue(), applicationId);\n \n     // Update new priority in Submission Context to keep track in HA\n     rmApp.getApplicationSubmissionContext().setPriority(appPriority);\n \n     // Update to state store\n     ApplicationStateData appState \u003d ApplicationStateData.newInstance(\n         rmApp.getSubmitTime(), rmApp.getStartTime(),\n         rmApp.getApplicationSubmissionContext(), rmApp.getUser());\n-    rmContext.getStateStore().updateApplicationStateSynchronously(appState);\n+    rmContext.getStateStore().updateApplicationStateSynchronously(appState,\n+        false);\n \n     // As we use iterator over a TreeSet for OrderingPolicy, once we change\n     // priority then reinsert back to make order correct.\n     LeafQueue queue \u003d (LeafQueue) getQueue(rmApp.getQueue());\n     synchronized (queue) {\n       queue.getOrderingPolicy().removeSchedulableEntity(\n           application.getCurrentAppAttempt());\n \n       // Update new priority in SchedulerApplication\n       application.setPriority(appPriority);\n \n       queue.getOrderingPolicy().addSchedulableEntity(\n           application.getCurrentAppAttempt());\n     }\n \n     LOG.info(\"Priority \u0027\" + appPriority + \"\u0027 is updated in queue :\"\n         + rmApp.getQueue() + \"for application:\" + applicationId\n         + \"for the user: \" + rmApp.getUser());\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void updateApplicationPriority(Priority newPriority,\n      ApplicationId applicationId) throws YarnException {\n    Priority appPriority \u003d null;\n    SchedulerApplication\u003cFiCaSchedulerApp\u003e application \u003d applications\n        .get(applicationId);\n\n    if (application \u003d\u003d null) {\n      throw new YarnException(\"Application \u0027\" + applicationId\n          + \"\u0027 is not present, hence could not change priority.\");\n    }\n\n    if (application.getPriority().equals(newPriority)) {\n      return;\n    }\n\n    RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n    appPriority \u003d checkAndGetApplicationPriority(newPriority, rmApp.getUser(),\n        rmApp.getQueue(), applicationId);\n\n    // Update new priority in Submission Context to keep track in HA\n    rmApp.getApplicationSubmissionContext().setPriority(appPriority);\n\n    // Update to state store\n    ApplicationStateData appState \u003d ApplicationStateData.newInstance(\n        rmApp.getSubmitTime(), rmApp.getStartTime(),\n        rmApp.getApplicationSubmissionContext(), rmApp.getUser());\n    rmContext.getStateStore().updateApplicationStateSynchronously(appState,\n        false);\n\n    // As we use iterator over a TreeSet for OrderingPolicy, once we change\n    // priority then reinsert back to make order correct.\n    LeafQueue queue \u003d (LeafQueue) getQueue(rmApp.getQueue());\n    synchronized (queue) {\n      queue.getOrderingPolicy().removeSchedulableEntity(\n          application.getCurrentAppAttempt());\n\n      // Update new priority in SchedulerApplication\n      application.setPriority(appPriority);\n\n      queue.getOrderingPolicy().addSchedulableEntity(\n          application.getCurrentAppAttempt());\n    }\n\n    LOG.info(\"Priority \u0027\" + appPriority + \"\u0027 is updated in queue :\"\n        + rmApp.getQueue() + \"for application:\" + applicationId\n        + \"for the user: \" + rmApp.getUser());\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
          "extendedDetails": {
            "oldValue": "[public, synchronized]",
            "newValue": "[public]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-4014. Support user cli interface in for Application Priority. Contributed by Rohith Sharma K S\n",
          "commitDate": "24/08/15 8:36 PM",
          "commitName": "57c7ae1affb2e1821fbdc3f47738d7e6fd83c7c1",
          "commitAuthor": "Jian He",
          "commitDateOld": "10/08/15 8:51 PM",
          "commitNameOld": "fa1d84ae2739a1e76f58b9c96d1378f9453cc0d2",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 13.99,
          "commitsBetweenForRepo": 83,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,46 +1,47 @@\n-  public synchronized void updateApplicationPriority(Priority newPriority,\n+  public void updateApplicationPriority(Priority newPriority,\n       ApplicationId applicationId) throws YarnException {\n     Priority appPriority \u003d null;\n     SchedulerApplication\u003cFiCaSchedulerApp\u003e application \u003d applications\n         .get(applicationId);\n \n     if (application \u003d\u003d null) {\n       throw new YarnException(\"Application \u0027\" + applicationId\n           + \"\u0027 is not present, hence could not change priority.\");\n     }\n \n     if (application.getPriority().equals(newPriority)) {\n       return;\n     }\n \n     RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n     appPriority \u003d checkAndGetApplicationPriority(newPriority, rmApp.getUser(),\n         rmApp.getQueue(), applicationId);\n \n     // Update new priority in Submission Context to keep track in HA\n     rmApp.getApplicationSubmissionContext().setPriority(appPriority);\n \n     // Update to state store\n     ApplicationStateData appState \u003d ApplicationStateData.newInstance(\n         rmApp.getSubmitTime(), rmApp.getStartTime(),\n         rmApp.getApplicationSubmissionContext(), rmApp.getUser());\n-    rmContext.getStateStore().updateApplicationStateSynchronously(appState);\n+    rmContext.getStateStore().updateApplicationStateSynchronously(appState,\n+        false);\n \n     // As we use iterator over a TreeSet for OrderingPolicy, once we change\n     // priority then reinsert back to make order correct.\n     LeafQueue queue \u003d (LeafQueue) getQueue(rmApp.getQueue());\n     synchronized (queue) {\n       queue.getOrderingPolicy().removeSchedulableEntity(\n           application.getCurrentAppAttempt());\n \n       // Update new priority in SchedulerApplication\n       application.setPriority(appPriority);\n \n       queue.getOrderingPolicy().addSchedulableEntity(\n           application.getCurrentAppAttempt());\n     }\n \n     LOG.info(\"Priority \u0027\" + appPriority + \"\u0027 is updated in queue :\"\n         + rmApp.getQueue() + \"for application:\" + applicationId\n         + \"for the user: \" + rmApp.getUser());\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void updateApplicationPriority(Priority newPriority,\n      ApplicationId applicationId) throws YarnException {\n    Priority appPriority \u003d null;\n    SchedulerApplication\u003cFiCaSchedulerApp\u003e application \u003d applications\n        .get(applicationId);\n\n    if (application \u003d\u003d null) {\n      throw new YarnException(\"Application \u0027\" + applicationId\n          + \"\u0027 is not present, hence could not change priority.\");\n    }\n\n    if (application.getPriority().equals(newPriority)) {\n      return;\n    }\n\n    RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n    appPriority \u003d checkAndGetApplicationPriority(newPriority, rmApp.getUser(),\n        rmApp.getQueue(), applicationId);\n\n    // Update new priority in Submission Context to keep track in HA\n    rmApp.getApplicationSubmissionContext().setPriority(appPriority);\n\n    // Update to state store\n    ApplicationStateData appState \u003d ApplicationStateData.newInstance(\n        rmApp.getSubmitTime(), rmApp.getStartTime(),\n        rmApp.getApplicationSubmissionContext(), rmApp.getUser());\n    rmContext.getStateStore().updateApplicationStateSynchronously(appState,\n        false);\n\n    // As we use iterator over a TreeSet for OrderingPolicy, once we change\n    // priority then reinsert back to make order correct.\n    LeafQueue queue \u003d (LeafQueue) getQueue(rmApp.getQueue());\n    synchronized (queue) {\n      queue.getOrderingPolicy().removeSchedulableEntity(\n          application.getCurrentAppAttempt());\n\n      // Update new priority in SchedulerApplication\n      application.setPriority(appPriority);\n\n      queue.getOrderingPolicy().addSchedulableEntity(\n          application.getCurrentAppAttempt());\n    }\n\n    LOG.info(\"Priority \u0027\" + appPriority + \"\u0027 is updated in queue :\"\n        + rmApp.getQueue() + \"for application:\" + applicationId\n        + \"for the user: \" + rmApp.getUser());\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
          "extendedDetails": {}
        }
      ]
    },
    "fa1d84ae2739a1e76f58b9c96d1378f9453cc0d2": {
      "type": "Yintroduced",
      "commitMessage": "YARN-3887. Support changing Application priority during runtime. Contributed by Sunil G\n",
      "commitDate": "10/08/15 8:51 PM",
      "commitName": "fa1d84ae2739a1e76f58b9c96d1378f9453cc0d2",
      "commitAuthor": "Jian He",
      "diff": "@@ -0,0 +1,46 @@\n+  public synchronized void updateApplicationPriority(Priority newPriority,\n+      ApplicationId applicationId) throws YarnException {\n+    Priority appPriority \u003d null;\n+    SchedulerApplication\u003cFiCaSchedulerApp\u003e application \u003d applications\n+        .get(applicationId);\n+\n+    if (application \u003d\u003d null) {\n+      throw new YarnException(\"Application \u0027\" + applicationId\n+          + \"\u0027 is not present, hence could not change priority.\");\n+    }\n+\n+    if (application.getPriority().equals(newPriority)) {\n+      return;\n+    }\n+\n+    RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n+    appPriority \u003d checkAndGetApplicationPriority(newPriority, rmApp.getUser(),\n+        rmApp.getQueue(), applicationId);\n+\n+    // Update new priority in Submission Context to keep track in HA\n+    rmApp.getApplicationSubmissionContext().setPriority(appPriority);\n+\n+    // Update to state store\n+    ApplicationStateData appState \u003d ApplicationStateData.newInstance(\n+        rmApp.getSubmitTime(), rmApp.getStartTime(),\n+        rmApp.getApplicationSubmissionContext(), rmApp.getUser());\n+    rmContext.getStateStore().updateApplicationStateSynchronously(appState);\n+\n+    // As we use iterator over a TreeSet for OrderingPolicy, once we change\n+    // priority then reinsert back to make order correct.\n+    LeafQueue queue \u003d (LeafQueue) getQueue(rmApp.getQueue());\n+    synchronized (queue) {\n+      queue.getOrderingPolicy().removeSchedulableEntity(\n+          application.getCurrentAppAttempt());\n+\n+      // Update new priority in SchedulerApplication\n+      application.setPriority(appPriority);\n+\n+      queue.getOrderingPolicy().addSchedulableEntity(\n+          application.getCurrentAppAttempt());\n+    }\n+\n+    LOG.info(\"Priority \u0027\" + appPriority + \"\u0027 is updated in queue :\"\n+        + rmApp.getQueue() + \"for application:\" + applicationId\n+        + \"for the user: \" + rmApp.getUser());\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void updateApplicationPriority(Priority newPriority,\n      ApplicationId applicationId) throws YarnException {\n    Priority appPriority \u003d null;\n    SchedulerApplication\u003cFiCaSchedulerApp\u003e application \u003d applications\n        .get(applicationId);\n\n    if (application \u003d\u003d null) {\n      throw new YarnException(\"Application \u0027\" + applicationId\n          + \"\u0027 is not present, hence could not change priority.\");\n    }\n\n    if (application.getPriority().equals(newPriority)) {\n      return;\n    }\n\n    RMApp rmApp \u003d rmContext.getRMApps().get(applicationId);\n    appPriority \u003d checkAndGetApplicationPriority(newPriority, rmApp.getUser(),\n        rmApp.getQueue(), applicationId);\n\n    // Update new priority in Submission Context to keep track in HA\n    rmApp.getApplicationSubmissionContext().setPriority(appPriority);\n\n    // Update to state store\n    ApplicationStateData appState \u003d ApplicationStateData.newInstance(\n        rmApp.getSubmitTime(), rmApp.getStartTime(),\n        rmApp.getApplicationSubmissionContext(), rmApp.getUser());\n    rmContext.getStateStore().updateApplicationStateSynchronously(appState);\n\n    // As we use iterator over a TreeSet for OrderingPolicy, once we change\n    // priority then reinsert back to make order correct.\n    LeafQueue queue \u003d (LeafQueue) getQueue(rmApp.getQueue());\n    synchronized (queue) {\n      queue.getOrderingPolicy().removeSchedulableEntity(\n          application.getCurrentAppAttempt());\n\n      // Update new priority in SchedulerApplication\n      application.setPriority(appPriority);\n\n      queue.getOrderingPolicy().addSchedulableEntity(\n          application.getCurrentAppAttempt());\n    }\n\n    LOG.info(\"Priority \u0027\" + appPriority + \"\u0027 is updated in queue :\"\n        + rmApp.getQueue() + \"for application:\" + applicationId\n        + \"for the user: \" + rmApp.getUser());\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java"
    }
  }
}