{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "DynamoDBMetadataStore.java",
  "functionName": "deleteSubtree",
  "functionId": "deleteSubtree___path-Path__operationState-BulkOperationState(modifiers-final)",
  "sourceFilePath": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
  "functionStartLine": 625,
  "functionEndLine": 644,
  "numCommitsSeen": 133,
  "timeTaken": 6817,
  "changeHistory": [
    "511df1e837b19ccb9271520589452d82d50ac69d",
    "c58e11bf521d746842ce16724211a2a0339d7b61",
    "b15ef7dc3d91c6d50fa515158104fba29f43e6b0",
    "e02eb24e0a9139418120027b694492e0738df20a",
    "f9cc9e162175444efe9d5b07ecb9a795f750ca3c",
    "de8b6ca5ef8614de6d6277b7617e27c788b0555c",
    "621b43e254afaff708cd6fc4698b29628f6abc33"
  ],
  "changeHistoryShort": {
    "511df1e837b19ccb9271520589452d82d50ac69d": "Ymultichange(Yparameterchange,Ybodychange)",
    "c58e11bf521d746842ce16724211a2a0339d7b61": "Ymultichange(Yparameterchange,Ybodychange)",
    "b15ef7dc3d91c6d50fa515158104fba29f43e6b0": "Ybodychange",
    "e02eb24e0a9139418120027b694492e0738df20a": "Ybodychange",
    "f9cc9e162175444efe9d5b07ecb9a795f750ca3c": "Ymultichange(Yparameterchange,Ybodychange)",
    "de8b6ca5ef8614de6d6277b7617e27c788b0555c": "Ybodychange",
    "621b43e254afaff708cd6fc4698b29628f6abc33": "Yintroduced"
  },
  "changeHistoryDetails": {
    "511df1e837b19ccb9271520589452d82d50ac69d": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HADOOP-16430. S3AFilesystem.delete to incrementally update s3guard with deletions\n\nContributed by Steve Loughran.\n\nThis overlaps the scanning for directory entries with batched calls to S3 DELETE and updates of the S3Guard tables.\nIt also uses S3Guard to list the files to delete, so find newly created files even when S3 listings are not use consistent.\n\nFor path which the client considers S3Guard to be authoritative, we also do a recursive LIST of the store and delete files; this is to find unindexed files and do guarantee that the delete(path, true) call really does delete everything underneath.\n\nChange-Id: Ice2f6e940c506e0b3a78fa534a99721b1698708e\n",
      "commitDate": "05/09/19 6:25 AM",
      "commitName": "511df1e837b19ccb9271520589452d82d50ac69d",
      "commitAuthor": "Steve Loughran",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-16430. S3AFilesystem.delete to incrementally update s3guard with deletions\n\nContributed by Steve Loughran.\n\nThis overlaps the scanning for directory entries with batched calls to S3 DELETE and updates of the S3Guard tables.\nIt also uses S3Guard to list the files to delete, so find newly created files even when S3 listings are not use consistent.\n\nFor path which the client considers S3Guard to be authoritative, we also do a recursive LIST of the store and delete files; this is to find unindexed files and do guarantee that the delete(path, true) call really does delete everything underneath.\n\nChange-Id: Ice2f6e940c506e0b3a78fa534a99721b1698708e\n",
          "commitDate": "05/09/19 6:25 AM",
          "commitName": "511df1e837b19ccb9271520589452d82d50ac69d",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "27/08/19 4:17 PM",
          "commitNameOld": "6f068cf53faef564ea6b63a0f4591feb8119cc5e",
          "commitAuthorOld": "HUAN-PING SU",
          "daysBetweenCommits": 8.59,
          "commitsBetweenForRepo": 78,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,37 +1,20 @@\n-  public void deleteSubtree(Path path)\n+  public void deleteSubtree(Path path,\n+      final BulkOperationState operationState)\n       throws IOException {\n     checkPath(path);\n     LOG.debug(\"Deleting subtree from table {} in region {}: {}\",\n         tableName, region, path);\n \n     final PathMetadata meta \u003d get(path);\n     if (meta \u003d\u003d null) {\n       LOG.debug(\"Subtree path {} does not exist; this will be a no-op\", path);\n       return;\n     }\n     if (meta.isDeleted()) {\n       LOG.debug(\"Subtree path {} is deleted; this will be a no-op\", path);\n       return;\n     }\n-\n-    try(AncestorState state \u003d new AncestorState(this,\n-        BulkOperationState.OperationType.Delete, path)) {\n-      // Execute via the bounded threadpool.\n-      final List\u003cCompletableFuture\u003cVoid\u003e\u003e futures \u003d new ArrayList\u003c\u003e();\n-      for (DescendantsIterator desc \u003d new DescendantsIterator(this, meta);\n-          desc.hasNext();) {\n-        final Path pathToDelete \u003d desc.next().getPath();\n-        futures.add(submit(executor, () -\u003e {\n-          innerDelete(pathToDelete, true, state);\n-          return null;\n-        }));\n-        if (futures.size() \u003e S3GUARD_DDB_SUBMITTED_TASK_LIMIT) {\n-          // first batch done; block for completion.\n-          waitForCompletion(futures);\n-          futures.clear();\n-        }\n-      }\n-      // now wait for the final set.\n-      waitForCompletion(futures);\n-    }\n+    deleteEntries(new InternalIterators.PathFromRemoteStatusIterator(\n+        new DescendantsIterator(this, meta)),\n+        operationState);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void deleteSubtree(Path path,\n      final BulkOperationState operationState)\n      throws IOException {\n    checkPath(path);\n    LOG.debug(\"Deleting subtree from table {} in region {}: {}\",\n        tableName, region, path);\n\n    final PathMetadata meta \u003d get(path);\n    if (meta \u003d\u003d null) {\n      LOG.debug(\"Subtree path {} does not exist; this will be a no-op\", path);\n      return;\n    }\n    if (meta.isDeleted()) {\n      LOG.debug(\"Subtree path {} is deleted; this will be a no-op\", path);\n      return;\n    }\n    deleteEntries(new InternalIterators.PathFromRemoteStatusIterator(\n        new DescendantsIterator(this, meta)),\n        operationState);\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
          "extendedDetails": {
            "oldValue": "[path-Path]",
            "newValue": "[path-Path, operationState-BulkOperationState(modifiers-final)]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-16430. S3AFilesystem.delete to incrementally update s3guard with deletions\n\nContributed by Steve Loughran.\n\nThis overlaps the scanning for directory entries with batched calls to S3 DELETE and updates of the S3Guard tables.\nIt also uses S3Guard to list the files to delete, so find newly created files even when S3 listings are not use consistent.\n\nFor path which the client considers S3Guard to be authoritative, we also do a recursive LIST of the store and delete files; this is to find unindexed files and do guarantee that the delete(path, true) call really does delete everything underneath.\n\nChange-Id: Ice2f6e940c506e0b3a78fa534a99721b1698708e\n",
          "commitDate": "05/09/19 6:25 AM",
          "commitName": "511df1e837b19ccb9271520589452d82d50ac69d",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "27/08/19 4:17 PM",
          "commitNameOld": "6f068cf53faef564ea6b63a0f4591feb8119cc5e",
          "commitAuthorOld": "HUAN-PING SU",
          "daysBetweenCommits": 8.59,
          "commitsBetweenForRepo": 78,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,37 +1,20 @@\n-  public void deleteSubtree(Path path)\n+  public void deleteSubtree(Path path,\n+      final BulkOperationState operationState)\n       throws IOException {\n     checkPath(path);\n     LOG.debug(\"Deleting subtree from table {} in region {}: {}\",\n         tableName, region, path);\n \n     final PathMetadata meta \u003d get(path);\n     if (meta \u003d\u003d null) {\n       LOG.debug(\"Subtree path {} does not exist; this will be a no-op\", path);\n       return;\n     }\n     if (meta.isDeleted()) {\n       LOG.debug(\"Subtree path {} is deleted; this will be a no-op\", path);\n       return;\n     }\n-\n-    try(AncestorState state \u003d new AncestorState(this,\n-        BulkOperationState.OperationType.Delete, path)) {\n-      // Execute via the bounded threadpool.\n-      final List\u003cCompletableFuture\u003cVoid\u003e\u003e futures \u003d new ArrayList\u003c\u003e();\n-      for (DescendantsIterator desc \u003d new DescendantsIterator(this, meta);\n-          desc.hasNext();) {\n-        final Path pathToDelete \u003d desc.next().getPath();\n-        futures.add(submit(executor, () -\u003e {\n-          innerDelete(pathToDelete, true, state);\n-          return null;\n-        }));\n-        if (futures.size() \u003e S3GUARD_DDB_SUBMITTED_TASK_LIMIT) {\n-          // first batch done; block for completion.\n-          waitForCompletion(futures);\n-          futures.clear();\n-        }\n-      }\n-      // now wait for the final set.\n-      waitForCompletion(futures);\n-    }\n+    deleteEntries(new InternalIterators.PathFromRemoteStatusIterator(\n+        new DescendantsIterator(this, meta)),\n+        operationState);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void deleteSubtree(Path path,\n      final BulkOperationState operationState)\n      throws IOException {\n    checkPath(path);\n    LOG.debug(\"Deleting subtree from table {} in region {}: {}\",\n        tableName, region, path);\n\n    final PathMetadata meta \u003d get(path);\n    if (meta \u003d\u003d null) {\n      LOG.debug(\"Subtree path {} does not exist; this will be a no-op\", path);\n      return;\n    }\n    if (meta.isDeleted()) {\n      LOG.debug(\"Subtree path {} is deleted; this will be a no-op\", path);\n      return;\n    }\n    deleteEntries(new InternalIterators.PathFromRemoteStatusIterator(\n        new DescendantsIterator(this, meta)),\n        operationState);\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
          "extendedDetails": {}
        }
      ]
    },
    "c58e11bf521d746842ce16724211a2a0339d7b61": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HADOOP-16383. Pass ITtlTimeProvider instance in initialize method in MetadataStore interface.  Contributed by Gabor Bota. (#1009) \n\n\r\n",
      "commitDate": "17/07/19 7:24 AM",
      "commitName": "c58e11bf521d746842ce16724211a2a0339d7b61",
      "commitAuthor": "Gabor Bota",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-16383. Pass ITtlTimeProvider instance in initialize method in MetadataStore interface.  Contributed by Gabor Bota. (#1009) \n\n\r\n",
          "commitDate": "17/07/19 7:24 AM",
          "commitName": "c58e11bf521d746842ce16724211a2a0339d7b61",
          "commitAuthor": "Gabor Bota",
          "commitDateOld": "12/07/19 5:02 AM",
          "commitNameOld": "b15ef7dc3d91c6d50fa515158104fba29f43e6b0",
          "commitAuthorOld": "Steve Loughran",
          "daysBetweenCommits": 5.1,
          "commitsBetweenForRepo": 35,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,37 +1,37 @@\n-  public void deleteSubtree(Path path, ITtlTimeProvider ttlTimeProvider)\n+  public void deleteSubtree(Path path)\n       throws IOException {\n     checkPath(path);\n     LOG.debug(\"Deleting subtree from table {} in region {}: {}\",\n         tableName, region, path);\n \n     final PathMetadata meta \u003d get(path);\n     if (meta \u003d\u003d null) {\n       LOG.debug(\"Subtree path {} does not exist; this will be a no-op\", path);\n       return;\n     }\n     if (meta.isDeleted()) {\n       LOG.debug(\"Subtree path {} is deleted; this will be a no-op\", path);\n       return;\n     }\n \n     try(AncestorState state \u003d new AncestorState(this,\n         BulkOperationState.OperationType.Delete, path)) {\n       // Execute via the bounded threadpool.\n       final List\u003cCompletableFuture\u003cVoid\u003e\u003e futures \u003d new ArrayList\u003c\u003e();\n       for (DescendantsIterator desc \u003d new DescendantsIterator(this, meta);\n           desc.hasNext();) {\n         final Path pathToDelete \u003d desc.next().getPath();\n         futures.add(submit(executor, () -\u003e {\n-          innerDelete(pathToDelete, true, ttlTimeProvider, state);\n+          innerDelete(pathToDelete, true, state);\n           return null;\n         }));\n         if (futures.size() \u003e S3GUARD_DDB_SUBMITTED_TASK_LIMIT) {\n           // first batch done; block for completion.\n           waitForCompletion(futures);\n           futures.clear();\n         }\n       }\n       // now wait for the final set.\n       waitForCompletion(futures);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void deleteSubtree(Path path)\n      throws IOException {\n    checkPath(path);\n    LOG.debug(\"Deleting subtree from table {} in region {}: {}\",\n        tableName, region, path);\n\n    final PathMetadata meta \u003d get(path);\n    if (meta \u003d\u003d null) {\n      LOG.debug(\"Subtree path {} does not exist; this will be a no-op\", path);\n      return;\n    }\n    if (meta.isDeleted()) {\n      LOG.debug(\"Subtree path {} is deleted; this will be a no-op\", path);\n      return;\n    }\n\n    try(AncestorState state \u003d new AncestorState(this,\n        BulkOperationState.OperationType.Delete, path)) {\n      // Execute via the bounded threadpool.\n      final List\u003cCompletableFuture\u003cVoid\u003e\u003e futures \u003d new ArrayList\u003c\u003e();\n      for (DescendantsIterator desc \u003d new DescendantsIterator(this, meta);\n          desc.hasNext();) {\n        final Path pathToDelete \u003d desc.next().getPath();\n        futures.add(submit(executor, () -\u003e {\n          innerDelete(pathToDelete, true, state);\n          return null;\n        }));\n        if (futures.size() \u003e S3GUARD_DDB_SUBMITTED_TASK_LIMIT) {\n          // first batch done; block for completion.\n          waitForCompletion(futures);\n          futures.clear();\n        }\n      }\n      // now wait for the final set.\n      waitForCompletion(futures);\n    }\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
          "extendedDetails": {
            "oldValue": "[path-Path, ttlTimeProvider-ITtlTimeProvider]",
            "newValue": "[path-Path]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-16383. Pass ITtlTimeProvider instance in initialize method in MetadataStore interface.  Contributed by Gabor Bota. (#1009) \n\n\r\n",
          "commitDate": "17/07/19 7:24 AM",
          "commitName": "c58e11bf521d746842ce16724211a2a0339d7b61",
          "commitAuthor": "Gabor Bota",
          "commitDateOld": "12/07/19 5:02 AM",
          "commitNameOld": "b15ef7dc3d91c6d50fa515158104fba29f43e6b0",
          "commitAuthorOld": "Steve Loughran",
          "daysBetweenCommits": 5.1,
          "commitsBetweenForRepo": 35,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,37 +1,37 @@\n-  public void deleteSubtree(Path path, ITtlTimeProvider ttlTimeProvider)\n+  public void deleteSubtree(Path path)\n       throws IOException {\n     checkPath(path);\n     LOG.debug(\"Deleting subtree from table {} in region {}: {}\",\n         tableName, region, path);\n \n     final PathMetadata meta \u003d get(path);\n     if (meta \u003d\u003d null) {\n       LOG.debug(\"Subtree path {} does not exist; this will be a no-op\", path);\n       return;\n     }\n     if (meta.isDeleted()) {\n       LOG.debug(\"Subtree path {} is deleted; this will be a no-op\", path);\n       return;\n     }\n \n     try(AncestorState state \u003d new AncestorState(this,\n         BulkOperationState.OperationType.Delete, path)) {\n       // Execute via the bounded threadpool.\n       final List\u003cCompletableFuture\u003cVoid\u003e\u003e futures \u003d new ArrayList\u003c\u003e();\n       for (DescendantsIterator desc \u003d new DescendantsIterator(this, meta);\n           desc.hasNext();) {\n         final Path pathToDelete \u003d desc.next().getPath();\n         futures.add(submit(executor, () -\u003e {\n-          innerDelete(pathToDelete, true, ttlTimeProvider, state);\n+          innerDelete(pathToDelete, true, state);\n           return null;\n         }));\n         if (futures.size() \u003e S3GUARD_DDB_SUBMITTED_TASK_LIMIT) {\n           // first batch done; block for completion.\n           waitForCompletion(futures);\n           futures.clear();\n         }\n       }\n       // now wait for the final set.\n       waitForCompletion(futures);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void deleteSubtree(Path path)\n      throws IOException {\n    checkPath(path);\n    LOG.debug(\"Deleting subtree from table {} in region {}: {}\",\n        tableName, region, path);\n\n    final PathMetadata meta \u003d get(path);\n    if (meta \u003d\u003d null) {\n      LOG.debug(\"Subtree path {} does not exist; this will be a no-op\", path);\n      return;\n    }\n    if (meta.isDeleted()) {\n      LOG.debug(\"Subtree path {} is deleted; this will be a no-op\", path);\n      return;\n    }\n\n    try(AncestorState state \u003d new AncestorState(this,\n        BulkOperationState.OperationType.Delete, path)) {\n      // Execute via the bounded threadpool.\n      final List\u003cCompletableFuture\u003cVoid\u003e\u003e futures \u003d new ArrayList\u003c\u003e();\n      for (DescendantsIterator desc \u003d new DescendantsIterator(this, meta);\n          desc.hasNext();) {\n        final Path pathToDelete \u003d desc.next().getPath();\n        futures.add(submit(executor, () -\u003e {\n          innerDelete(pathToDelete, true, state);\n          return null;\n        }));\n        if (futures.size() \u003e S3GUARD_DDB_SUBMITTED_TASK_LIMIT) {\n          // first batch done; block for completion.\n          waitForCompletion(futures);\n          futures.clear();\n        }\n      }\n      // now wait for the final set.\n      waitForCompletion(futures);\n    }\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
          "extendedDetails": {}
        }
      ]
    },
    "b15ef7dc3d91c6d50fa515158104fba29f43e6b0": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16384: S3A: Avoid inconsistencies between DDB and S3.\n\nContributed by Steve Loughran\n\nContains\n\n- HADOOP-16397. Hadoop S3Guard Prune command to support a -tombstone option.\n- HADOOP-16406. ITestDynamoDBMetadataStore.testProvisionTable times out intermittently\n\nThis patch doesn\u0027t fix the underlying problem but it\n\n* changes some tests to clean up better\n* does a lot more in logging operations in against DDB, if enabled\n* adds an entry point to dump the state of the metastore and s3 tables (precursor to fsck)\n* adds a purge entry point to help clean up after a test run has got a store into a mess\n* s3guard prune command adds -tombstone option to only clear tombstones\n\nThe outcome is that tests should pass consistently and if problems occur we have better diagnostics.\n\nChange-Id: I3eca3f5529d7f6fec398c0ff0472919f08f054eb\n",
      "commitDate": "12/07/19 5:02 AM",
      "commitName": "b15ef7dc3d91c6d50fa515158104fba29f43e6b0",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "08/07/19 10:27 AM",
      "commitNameOld": "de6b7bc67ace7744adb0320ee7de79cf28259d2d",
      "commitAuthorOld": "Sean Mackrory",
      "daysBetweenCommits": 3.77,
      "commitsBetweenForRepo": 38,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,30 +1,37 @@\n   public void deleteSubtree(Path path, ITtlTimeProvider ttlTimeProvider)\n       throws IOException {\n     checkPath(path);\n     LOG.debug(\"Deleting subtree from table {} in region {}: {}\",\n         tableName, region, path);\n \n     final PathMetadata meta \u003d get(path);\n-    if (meta \u003d\u003d null || meta.isDeleted()) {\n+    if (meta \u003d\u003d null) {\n       LOG.debug(\"Subtree path {} does not exist; this will be a no-op\", path);\n       return;\n     }\n-\n-    // Execute via the bounded threadpool.\n-    final List\u003cCompletableFuture\u003cVoid\u003e\u003e futures \u003d new ArrayList\u003c\u003e();\n-    for (DescendantsIterator desc \u003d new DescendantsIterator(this, meta);\n-         desc.hasNext();) {\n-      final Path pathToDelete \u003d desc.next().getPath();\n-      futures.add(submit(executor, () -\u003e {\n-        innerDelete(pathToDelete, true, ttlTimeProvider);\n-        return null;\n-      }));\n-      if (futures.size() \u003e S3GUARD_DDB_SUBMITTED_TASK_LIMIT) {\n-        // first batch done; block for completion.\n-        waitForCompletion(futures);\n-        futures.clear();\n-      }\n+    if (meta.isDeleted()) {\n+      LOG.debug(\"Subtree path {} is deleted; this will be a no-op\", path);\n+      return;\n     }\n-    // now wait for the final set.\n-    waitForCompletion(futures);\n+\n+    try(AncestorState state \u003d new AncestorState(this,\n+        BulkOperationState.OperationType.Delete, path)) {\n+      // Execute via the bounded threadpool.\n+      final List\u003cCompletableFuture\u003cVoid\u003e\u003e futures \u003d new ArrayList\u003c\u003e();\n+      for (DescendantsIterator desc \u003d new DescendantsIterator(this, meta);\n+          desc.hasNext();) {\n+        final Path pathToDelete \u003d desc.next().getPath();\n+        futures.add(submit(executor, () -\u003e {\n+          innerDelete(pathToDelete, true, ttlTimeProvider, state);\n+          return null;\n+        }));\n+        if (futures.size() \u003e S3GUARD_DDB_SUBMITTED_TASK_LIMIT) {\n+          // first batch done; block for completion.\n+          waitForCompletion(futures);\n+          futures.clear();\n+        }\n+      }\n+      // now wait for the final set.\n+      waitForCompletion(futures);\n+    }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void deleteSubtree(Path path, ITtlTimeProvider ttlTimeProvider)\n      throws IOException {\n    checkPath(path);\n    LOG.debug(\"Deleting subtree from table {} in region {}: {}\",\n        tableName, region, path);\n\n    final PathMetadata meta \u003d get(path);\n    if (meta \u003d\u003d null) {\n      LOG.debug(\"Subtree path {} does not exist; this will be a no-op\", path);\n      return;\n    }\n    if (meta.isDeleted()) {\n      LOG.debug(\"Subtree path {} is deleted; this will be a no-op\", path);\n      return;\n    }\n\n    try(AncestorState state \u003d new AncestorState(this,\n        BulkOperationState.OperationType.Delete, path)) {\n      // Execute via the bounded threadpool.\n      final List\u003cCompletableFuture\u003cVoid\u003e\u003e futures \u003d new ArrayList\u003c\u003e();\n      for (DescendantsIterator desc \u003d new DescendantsIterator(this, meta);\n          desc.hasNext();) {\n        final Path pathToDelete \u003d desc.next().getPath();\n        futures.add(submit(executor, () -\u003e {\n          innerDelete(pathToDelete, true, ttlTimeProvider, state);\n          return null;\n        }));\n        if (futures.size() \u003e S3GUARD_DDB_SUBMITTED_TASK_LIMIT) {\n          // first batch done; block for completion.\n          waitForCompletion(futures);\n          futures.clear();\n        }\n      }\n      // now wait for the final set.\n      waitForCompletion(futures);\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
      "extendedDetails": {}
    },
    "e02eb24e0a9139418120027b694492e0738df20a": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15183. S3Guard store becomes inconsistent after partial failure of rename.\n\nContributed by Steve Loughran.\n\nChange-Id: I825b0bc36be960475d2d259b1cdab45ae1bb78eb\n",
      "commitDate": "20/06/19 1:56 AM",
      "commitName": "e02eb24e0a9139418120027b694492e0738df20a",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "16/06/19 9:05 AM",
      "commitNameOld": "f9cc9e162175444efe9d5b07ecb9a795f750ca3c",
      "commitAuthorOld": "Gabor Bota",
      "daysBetweenCommits": 3.7,
      "commitsBetweenForRepo": 44,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,17 +1,30 @@\n   public void deleteSubtree(Path path, ITtlTimeProvider ttlTimeProvider)\n       throws IOException {\n     checkPath(path);\n     LOG.debug(\"Deleting subtree from table {} in region {}: {}\",\n         tableName, region, path);\n \n     final PathMetadata meta \u003d get(path);\n     if (meta \u003d\u003d null || meta.isDeleted()) {\n       LOG.debug(\"Subtree path {} does not exist; this will be a no-op\", path);\n       return;\n     }\n \n+    // Execute via the bounded threadpool.\n+    final List\u003cCompletableFuture\u003cVoid\u003e\u003e futures \u003d new ArrayList\u003c\u003e();\n     for (DescendantsIterator desc \u003d new DescendantsIterator(this, meta);\n          desc.hasNext();) {\n-      innerDelete(desc.next().getPath(), true, ttlTimeProvider);\n+      final Path pathToDelete \u003d desc.next().getPath();\n+      futures.add(submit(executor, () -\u003e {\n+        innerDelete(pathToDelete, true, ttlTimeProvider);\n+        return null;\n+      }));\n+      if (futures.size() \u003e S3GUARD_DDB_SUBMITTED_TASK_LIMIT) {\n+        // first batch done; block for completion.\n+        waitForCompletion(futures);\n+        futures.clear();\n+      }\n     }\n+    // now wait for the final set.\n+    waitForCompletion(futures);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void deleteSubtree(Path path, ITtlTimeProvider ttlTimeProvider)\n      throws IOException {\n    checkPath(path);\n    LOG.debug(\"Deleting subtree from table {} in region {}: {}\",\n        tableName, region, path);\n\n    final PathMetadata meta \u003d get(path);\n    if (meta \u003d\u003d null || meta.isDeleted()) {\n      LOG.debug(\"Subtree path {} does not exist; this will be a no-op\", path);\n      return;\n    }\n\n    // Execute via the bounded threadpool.\n    final List\u003cCompletableFuture\u003cVoid\u003e\u003e futures \u003d new ArrayList\u003c\u003e();\n    for (DescendantsIterator desc \u003d new DescendantsIterator(this, meta);\n         desc.hasNext();) {\n      final Path pathToDelete \u003d desc.next().getPath();\n      futures.add(submit(executor, () -\u003e {\n        innerDelete(pathToDelete, true, ttlTimeProvider);\n        return null;\n      }));\n      if (futures.size() \u003e S3GUARD_DDB_SUBMITTED_TASK_LIMIT) {\n        // first batch done; block for completion.\n        waitForCompletion(futures);\n        futures.clear();\n      }\n    }\n    // now wait for the final set.\n    waitForCompletion(futures);\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
      "extendedDetails": {}
    },
    "f9cc9e162175444efe9d5b07ecb9a795f750ca3c": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HADOOP-16279. S3Guard: Implement time-based (TTL) expiry for entries (and tombstones).\n\nContributed by Gabor Bota.\n\nChange-Id: I73a2d2861901dedfe7a0e783b310fbb95e7c1af9\n",
      "commitDate": "16/06/19 9:05 AM",
      "commitName": "f9cc9e162175444efe9d5b07ecb9a795f750ca3c",
      "commitAuthor": "Gabor Bota",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-16279. S3Guard: Implement time-based (TTL) expiry for entries (and tombstones).\n\nContributed by Gabor Bota.\n\nChange-Id: I73a2d2861901dedfe7a0e783b310fbb95e7c1af9\n",
          "commitDate": "16/06/19 9:05 AM",
          "commitName": "f9cc9e162175444efe9d5b07ecb9a795f750ca3c",
          "commitAuthor": "Gabor Bota",
          "commitDateOld": "07/06/19 10:26 AM",
          "commitNameOld": "4e38dafde4dce8cd8c368783a291e830f06e1def",
          "commitAuthorOld": "Steve Loughran",
          "daysBetweenCommits": 8.94,
          "commitsBetweenForRepo": 50,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,16 +1,17 @@\n-  public void deleteSubtree(Path path) throws IOException {\n+  public void deleteSubtree(Path path, ITtlTimeProvider ttlTimeProvider)\n+      throws IOException {\n     checkPath(path);\n     LOG.debug(\"Deleting subtree from table {} in region {}: {}\",\n         tableName, region, path);\n \n     final PathMetadata meta \u003d get(path);\n     if (meta \u003d\u003d null || meta.isDeleted()) {\n       LOG.debug(\"Subtree path {} does not exist; this will be a no-op\", path);\n       return;\n     }\n \n     for (DescendantsIterator desc \u003d new DescendantsIterator(this, meta);\n          desc.hasNext();) {\n-      innerDelete(desc.next().getPath(), true);\n+      innerDelete(desc.next().getPath(), true, ttlTimeProvider);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void deleteSubtree(Path path, ITtlTimeProvider ttlTimeProvider)\n      throws IOException {\n    checkPath(path);\n    LOG.debug(\"Deleting subtree from table {} in region {}: {}\",\n        tableName, region, path);\n\n    final PathMetadata meta \u003d get(path);\n    if (meta \u003d\u003d null || meta.isDeleted()) {\n      LOG.debug(\"Subtree path {} does not exist; this will be a no-op\", path);\n      return;\n    }\n\n    for (DescendantsIterator desc \u003d new DescendantsIterator(this, meta);\n         desc.hasNext();) {\n      innerDelete(desc.next().getPath(), true, ttlTimeProvider);\n    }\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
          "extendedDetails": {
            "oldValue": "[path-Path]",
            "newValue": "[path-Path, ttlTimeProvider-ITtlTimeProvider]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-16279. S3Guard: Implement time-based (TTL) expiry for entries (and tombstones).\n\nContributed by Gabor Bota.\n\nChange-Id: I73a2d2861901dedfe7a0e783b310fbb95e7c1af9\n",
          "commitDate": "16/06/19 9:05 AM",
          "commitName": "f9cc9e162175444efe9d5b07ecb9a795f750ca3c",
          "commitAuthor": "Gabor Bota",
          "commitDateOld": "07/06/19 10:26 AM",
          "commitNameOld": "4e38dafde4dce8cd8c368783a291e830f06e1def",
          "commitAuthorOld": "Steve Loughran",
          "daysBetweenCommits": 8.94,
          "commitsBetweenForRepo": 50,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,16 +1,17 @@\n-  public void deleteSubtree(Path path) throws IOException {\n+  public void deleteSubtree(Path path, ITtlTimeProvider ttlTimeProvider)\n+      throws IOException {\n     checkPath(path);\n     LOG.debug(\"Deleting subtree from table {} in region {}: {}\",\n         tableName, region, path);\n \n     final PathMetadata meta \u003d get(path);\n     if (meta \u003d\u003d null || meta.isDeleted()) {\n       LOG.debug(\"Subtree path {} does not exist; this will be a no-op\", path);\n       return;\n     }\n \n     for (DescendantsIterator desc \u003d new DescendantsIterator(this, meta);\n          desc.hasNext();) {\n-      innerDelete(desc.next().getPath(), true);\n+      innerDelete(desc.next().getPath(), true, ttlTimeProvider);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void deleteSubtree(Path path, ITtlTimeProvider ttlTimeProvider)\n      throws IOException {\n    checkPath(path);\n    LOG.debug(\"Deleting subtree from table {} in region {}: {}\",\n        tableName, region, path);\n\n    final PathMetadata meta \u003d get(path);\n    if (meta \u003d\u003d null || meta.isDeleted()) {\n      LOG.debug(\"Subtree path {} does not exist; this will be a no-op\", path);\n      return;\n    }\n\n    for (DescendantsIterator desc \u003d new DescendantsIterator(this, meta);\n         desc.hasNext();) {\n      innerDelete(desc.next().getPath(), true, ttlTimeProvider);\n    }\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
          "extendedDetails": {}
        }
      ]
    },
    "de8b6ca5ef8614de6d6277b7617e27c788b0555c": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13786 Add S3A committer for zero-rename commits to S3 endpoints.\nContributed by Steve Loughran and Ryan Blue.\n",
      "commitDate": "22/11/17 7:28 AM",
      "commitName": "de8b6ca5ef8614de6d6277b7617e27c788b0555c",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "25/09/17 3:59 PM",
      "commitNameOld": "47011d7dd300b0c74bb6cfe25b918c479d718f4f",
      "commitAuthorOld": "Aaron Fabbri",
      "daysBetweenCommits": 57.69,
      "commitsBetweenForRepo": 477,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,16 +1,16 @@\n   public void deleteSubtree(Path path) throws IOException {\n-    path \u003d checkPath(path);\n+    checkPath(path);\n     LOG.debug(\"Deleting subtree from table {} in region {}: {}\",\n         tableName, region, path);\n \n     final PathMetadata meta \u003d get(path);\n     if (meta \u003d\u003d null || meta.isDeleted()) {\n       LOG.debug(\"Subtree path {} does not exist; this will be a no-op\", path);\n       return;\n     }\n \n     for (DescendantsIterator desc \u003d new DescendantsIterator(this, meta);\n          desc.hasNext();) {\n       innerDelete(desc.next().getPath(), true);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void deleteSubtree(Path path) throws IOException {\n    checkPath(path);\n    LOG.debug(\"Deleting subtree from table {} in region {}: {}\",\n        tableName, region, path);\n\n    final PathMetadata meta \u003d get(path);\n    if (meta \u003d\u003d null || meta.isDeleted()) {\n      LOG.debug(\"Subtree path {} does not exist; this will be a no-op\", path);\n      return;\n    }\n\n    for (DescendantsIterator desc \u003d new DescendantsIterator(this, meta);\n         desc.hasNext();) {\n      innerDelete(desc.next().getPath(), true);\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
      "extendedDetails": {}
    },
    "621b43e254afaff708cd6fc4698b29628f6abc33": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-13345 HS3Guard: Improved Consistency for S3A.\nContributed by: Chris Nauroth, Aaron Fabbri, Mingliang Liu, Lei (Eddy) Xu,\nSean Mackrory, Steve Loughran and others.\n",
      "commitDate": "01/09/17 6:13 AM",
      "commitName": "621b43e254afaff708cd6fc4698b29628f6abc33",
      "commitAuthor": "Steve Loughran",
      "diff": "@@ -0,0 +1,16 @@\n+  public void deleteSubtree(Path path) throws IOException {\n+    path \u003d checkPath(path);\n+    LOG.debug(\"Deleting subtree from table {} in region {}: {}\",\n+        tableName, region, path);\n+\n+    final PathMetadata meta \u003d get(path);\n+    if (meta \u003d\u003d null || meta.isDeleted()) {\n+      LOG.debug(\"Subtree path {} does not exist; this will be a no-op\", path);\n+      return;\n+    }\n+\n+    for (DescendantsIterator desc \u003d new DescendantsIterator(this, meta);\n+         desc.hasNext();) {\n+      innerDelete(desc.next().getPath(), true);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void deleteSubtree(Path path) throws IOException {\n    path \u003d checkPath(path);\n    LOG.debug(\"Deleting subtree from table {} in region {}: {}\",\n        tableName, region, path);\n\n    final PathMetadata meta \u003d get(path);\n    if (meta \u003d\u003d null || meta.isDeleted()) {\n      LOG.debug(\"Subtree path {} does not exist; this will be a no-op\", path);\n      return;\n    }\n\n    for (DescendantsIterator desc \u003d new DescendantsIterator(this, meta);\n         desc.hasNext();) {\n      innerDelete(desc.next().getPath(), true);\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java"
    }
  }
}