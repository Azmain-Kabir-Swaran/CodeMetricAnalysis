{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "OfflineImageReconstructor.java",
  "functionName": "loadNodeChildrenHelper",
  "functionId": "loadNodeChildrenHelper___parent-Node__expected-String__terminators-String[]",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/offlineImageViewer/OfflineImageReconstructor.java",
  "functionStartLine": 361,
  "functionEndLine": 407,
  "numCommitsSeen": 15,
  "timeTaken": 1805,
  "changeHistory": [
    "2d9e791a9073de9f65fef5407efd3a42894bc97f",
    "700b0e4019cf483f7532609711812150b8c44742"
  ],
  "changeHistoryShort": {
    "2d9e791a9073de9f65fef5407efd3a42894bc97f": "Ybodychange",
    "700b0e4019cf483f7532609711812150b8c44742": "Yintroduced"
  },
  "changeHistoryDetails": {
    "2d9e791a9073de9f65fef5407efd3a42894bc97f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12828. OIV ReverseXML Processor fails with escaped characters\n\nSigned-off-by: Akira Ajisaka \u003caajisaka@apache.org\u003e\n",
      "commitDate": "17/04/18 10:38 PM",
      "commitName": "2d9e791a9073de9f65fef5407efd3a42894bc97f",
      "commitAuthor": "Erik Krogen",
      "commitDateOld": "03/11/17 12:05 PM",
      "commitNameOld": "299d38295d61e3ad154814b680558969449d50fe",
      "commitAuthorOld": "Xiao Chen",
      "daysBetweenCommits": 165.44,
      "commitsBetweenForRepo": 1225,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,47 @@\n   private void loadNodeChildrenHelper(Node parent, String expected,\n                                 String terminators[]) throws IOException {\n     XMLEvent ev \u003d null;\n     while (true) {\n       try {\n         ev \u003d events.peek();\n         switch (ev.getEventType()) {\n         case XMLEvent.END_ELEMENT:\n           if (terminators.length !\u003d 0) {\n             return;\n           }\n           events.nextEvent();\n           return;\n         case XMLEvent.START_ELEMENT:\n           String key \u003d ev.asStartElement().getName().getLocalPart();\n           for (String terminator : terminators) {\n             if (terminator.equals(key)) {\n               return;\n             }\n           }\n           events.nextEvent();\n           Node node \u003d new Node();\n           parent.addChild(key, node);\n           loadNodeChildrenHelper(node, expected, new String[0]);\n           break;\n         case XMLEvent.CHARACTERS:\n           String val \u003d XMLUtils.\n-              unmangleXmlString(ev.asCharacters().getData(), true);\n-          parent.setVal(val);\n+              unmangleXmlString(ev.asCharacters().getData(), false);\n+          parent.setVal(parent.getVal() + val);\n           events.nextEvent();\n           break;\n         case XMLEvent.ATTRIBUTE:\n           throw new IOException(\"Unexpected XML event \" + ev);\n         default:\n           // Ignore other event types like comment, etc.\n           if (LOG.isTraceEnabled()) {\n             LOG.trace(\"Skipping XMLEvent \" + ev);\n           }\n           events.nextEvent();\n           break;\n         }\n       } catch (XMLStreamException e) {\n         throw new IOException(\"Expecting \" + expected +\n             \", but got XMLStreamException\", e);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void loadNodeChildrenHelper(Node parent, String expected,\n                                String terminators[]) throws IOException {\n    XMLEvent ev \u003d null;\n    while (true) {\n      try {\n        ev \u003d events.peek();\n        switch (ev.getEventType()) {\n        case XMLEvent.END_ELEMENT:\n          if (terminators.length !\u003d 0) {\n            return;\n          }\n          events.nextEvent();\n          return;\n        case XMLEvent.START_ELEMENT:\n          String key \u003d ev.asStartElement().getName().getLocalPart();\n          for (String terminator : terminators) {\n            if (terminator.equals(key)) {\n              return;\n            }\n          }\n          events.nextEvent();\n          Node node \u003d new Node();\n          parent.addChild(key, node);\n          loadNodeChildrenHelper(node, expected, new String[0]);\n          break;\n        case XMLEvent.CHARACTERS:\n          String val \u003d XMLUtils.\n              unmangleXmlString(ev.asCharacters().getData(), false);\n          parent.setVal(parent.getVal() + val);\n          events.nextEvent();\n          break;\n        case XMLEvent.ATTRIBUTE:\n          throw new IOException(\"Unexpected XML event \" + ev);\n        default:\n          // Ignore other event types like comment, etc.\n          if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Skipping XMLEvent \" + ev);\n          }\n          events.nextEvent();\n          break;\n        }\n      } catch (XMLStreamException e) {\n        throw new IOException(\"Expecting \" + expected +\n            \", but got XMLStreamException\", e);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/offlineImageViewer/OfflineImageReconstructor.java",
      "extendedDetails": {}
    },
    "700b0e4019cf483f7532609711812150b8c44742": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-9835. OIV: add ReverseXML processor which reconstructs an fsimage from an XML file (cmccabe)\n",
      "commitDate": "02/03/16 5:56 PM",
      "commitName": "700b0e4019cf483f7532609711812150b8c44742",
      "commitAuthor": "Colin Patrick Mccabe",
      "diff": "@@ -0,0 +1,47 @@\n+  private void loadNodeChildrenHelper(Node parent, String expected,\n+                                String terminators[]) throws IOException {\n+    XMLEvent ev \u003d null;\n+    while (true) {\n+      try {\n+        ev \u003d events.peek();\n+        switch (ev.getEventType()) {\n+        case XMLEvent.END_ELEMENT:\n+          if (terminators.length !\u003d 0) {\n+            return;\n+          }\n+          events.nextEvent();\n+          return;\n+        case XMLEvent.START_ELEMENT:\n+          String key \u003d ev.asStartElement().getName().getLocalPart();\n+          for (String terminator : terminators) {\n+            if (terminator.equals(key)) {\n+              return;\n+            }\n+          }\n+          events.nextEvent();\n+          Node node \u003d new Node();\n+          parent.addChild(key, node);\n+          loadNodeChildrenHelper(node, expected, new String[0]);\n+          break;\n+        case XMLEvent.CHARACTERS:\n+          String val \u003d XMLUtils.\n+              unmangleXmlString(ev.asCharacters().getData(), true);\n+          parent.setVal(val);\n+          events.nextEvent();\n+          break;\n+        case XMLEvent.ATTRIBUTE:\n+          throw new IOException(\"Unexpected XML event \" + ev);\n+        default:\n+          // Ignore other event types like comment, etc.\n+          if (LOG.isTraceEnabled()) {\n+            LOG.trace(\"Skipping XMLEvent \" + ev);\n+          }\n+          events.nextEvent();\n+          break;\n+        }\n+      } catch (XMLStreamException e) {\n+        throw new IOException(\"Expecting \" + expected +\n+            \", but got XMLStreamException\", e);\n+      }\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void loadNodeChildrenHelper(Node parent, String expected,\n                                String terminators[]) throws IOException {\n    XMLEvent ev \u003d null;\n    while (true) {\n      try {\n        ev \u003d events.peek();\n        switch (ev.getEventType()) {\n        case XMLEvent.END_ELEMENT:\n          if (terminators.length !\u003d 0) {\n            return;\n          }\n          events.nextEvent();\n          return;\n        case XMLEvent.START_ELEMENT:\n          String key \u003d ev.asStartElement().getName().getLocalPart();\n          for (String terminator : terminators) {\n            if (terminator.equals(key)) {\n              return;\n            }\n          }\n          events.nextEvent();\n          Node node \u003d new Node();\n          parent.addChild(key, node);\n          loadNodeChildrenHelper(node, expected, new String[0]);\n          break;\n        case XMLEvent.CHARACTERS:\n          String val \u003d XMLUtils.\n              unmangleXmlString(ev.asCharacters().getData(), true);\n          parent.setVal(val);\n          events.nextEvent();\n          break;\n        case XMLEvent.ATTRIBUTE:\n          throw new IOException(\"Unexpected XML event \" + ev);\n        default:\n          // Ignore other event types like comment, etc.\n          if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Skipping XMLEvent \" + ev);\n          }\n          events.nextEvent();\n          break;\n        }\n      } catch (XMLStreamException e) {\n        throw new IOException(\"Expecting \" + expected +\n            \", but got XMLStreamException\", e);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/offlineImageViewer/OfflineImageReconstructor.java"
    }
  }
}