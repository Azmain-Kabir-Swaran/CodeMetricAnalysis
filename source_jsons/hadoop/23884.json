{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "CompletedJob.java",
  "functionName": "constructTaskAttemptCompletionEvents",
  "functionId": "constructTaskAttemptCompletionEvents",
  "sourceFilePath": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-hs/src/main/java/org/apache/hadoop/mapreduce/v2/hs/CompletedJob.java",
  "functionStartLine": 252,
  "functionEndLine": 329,
  "numCommitsSeen": 40,
  "timeTaken": 7970,
  "changeHistory": [
    "76e309ead01f02b32335330cd920536f907fb71f",
    "1195f844a9a74de6709ba7d8aaf70c21f27cd2b3",
    "7475e836dc2bdd29142eaf210262fba354b745ed",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517"
  ],
  "changeHistoryShort": {
    "76e309ead01f02b32335330cd920536f907fb71f": "Ybodychange",
    "1195f844a9a74de6709ba7d8aaf70c21f27cd2b3": "Ybodychange",
    "7475e836dc2bdd29142eaf210262fba354b745ed": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": "Yintroduced"
  },
  "changeHistoryDetails": {
    "76e309ead01f02b32335330cd920536f907fb71f": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-6253. Update use of Iterator to Iterable. Contributed by Ray\nChiang.\n",
      "commitDate": "12/02/15 12:15 AM",
      "commitName": "76e309ead01f02b32335330cd920536f907fb71f",
      "commitAuthor": "Devaraj K",
      "commitDateOld": "25/11/14 1:02 PM",
      "commitNameOld": "78f7cdbfd6e2b9fac51c369c748ae93d12ef065a",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 78.47,
      "commitsBetweenForRepo": 546,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,78 +1,78 @@\n   private void constructTaskAttemptCompletionEvents() {\n     loadAllTasks();\n     completionEvents \u003d new LinkedList\u003cTaskAttemptCompletionEvent\u003e();\n     List\u003cTaskAttempt\u003e allTaskAttempts \u003d new LinkedList\u003cTaskAttempt\u003e();\n     int numMapAttempts \u003d 0;\n-    for (TaskId taskId : tasks.keySet()) {\n-      Task task \u003d tasks.get(taskId);\n-      for (TaskAttemptId taskAttemptId : task.getAttempts().keySet()) {\n-        TaskAttempt taskAttempt \u003d task.getAttempts().get(taskAttemptId);\n+    for (Map.Entry\u003cTaskId,Task\u003e taskEntry : tasks.entrySet()) {\n+      Task task \u003d taskEntry.getValue();\n+      for (Map.Entry\u003cTaskAttemptId,TaskAttempt\u003e taskAttemptEntry : task.getAttempts().entrySet()) {\n+        TaskAttempt taskAttempt \u003d taskAttemptEntry.getValue();\n         allTaskAttempts.add(taskAttempt);\n         if (task.getType() \u003d\u003d TaskType.MAP) {\n           ++numMapAttempts;\n         }\n       }\n     }\n     Collections.sort(allTaskAttempts, new Comparator\u003cTaskAttempt\u003e() {\n \n       @Override\n       public int compare(TaskAttempt o1, TaskAttempt o2) {\n         if (o1.getFinishTime() \u003d\u003d 0 || o2.getFinishTime() \u003d\u003d 0) {\n           if (o1.getFinishTime() \u003d\u003d 0 \u0026\u0026 o2.getFinishTime() \u003d\u003d 0) {\n             if (o1.getLaunchTime() \u003d\u003d 0 || o2.getLaunchTime() \u003d\u003d 0) {\n               if (o1.getLaunchTime() \u003d\u003d 0 \u0026\u0026 o2.getLaunchTime() \u003d\u003d 0) {\n                 return 0;\n               } else {\n                 long res \u003d o1.getLaunchTime() - o2.getLaunchTime();\n                 return res \u003e 0 ? -1 : 1;\n               }\n             } else {\n               return (int) (o1.getLaunchTime() - o2.getLaunchTime());\n             }\n           } else {\n             long res \u003d o1.getFinishTime() - o2.getFinishTime();\n             return res \u003e 0 ? -1 : 1;\n           }\n         } else {\n           return (int) (o1.getFinishTime() - o2.getFinishTime());\n         }\n       }\n     });\n \n     mapCompletionEvents \u003d\n         new ArrayList\u003cTaskAttemptCompletionEvent\u003e(numMapAttempts);\n     int eventId \u003d 0;\n     for (TaskAttempt taskAttempt : allTaskAttempts) {\n \n       TaskAttemptCompletionEvent tace \u003d\n           Records.newRecord(TaskAttemptCompletionEvent.class);\n \n       int attemptRunTime \u003d -1;\n       if (taskAttempt.getLaunchTime() !\u003d 0 \u0026\u0026 taskAttempt.getFinishTime() !\u003d 0) {\n         attemptRunTime \u003d\n             (int) (taskAttempt.getFinishTime() - taskAttempt.getLaunchTime());\n       }\n       // Default to KILLED\n       TaskAttemptCompletionEventStatus taceStatus \u003d\n           TaskAttemptCompletionEventStatus.KILLED;\n       String taStateString \u003d taskAttempt.getState().toString();\n       try {\n         taceStatus \u003d TaskAttemptCompletionEventStatus.valueOf(taStateString);\n       } catch (Exception e) {\n         LOG.warn(\"Cannot constuct TACEStatus from TaskAtemptState: [\"\n             + taStateString + \"] for taskAttemptId: [\" + taskAttempt.getID()\n             + \"]. Defaulting to KILLED\");\n       }\n \n       tace.setAttemptId(taskAttempt.getID());\n       tace.setAttemptRunTime(attemptRunTime);\n       tace.setEventId(eventId++);\n       tace.setMapOutputServerAddress(taskAttempt\n           .getAssignedContainerMgrAddress());\n       tace.setStatus(taceStatus);\n       completionEvents.add(tace);\n       if (taskAttempt.getID().getTaskId().getTaskType() \u003d\u003d TaskType.MAP) {\n         mapCompletionEvents.add(tace);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void constructTaskAttemptCompletionEvents() {\n    loadAllTasks();\n    completionEvents \u003d new LinkedList\u003cTaskAttemptCompletionEvent\u003e();\n    List\u003cTaskAttempt\u003e allTaskAttempts \u003d new LinkedList\u003cTaskAttempt\u003e();\n    int numMapAttempts \u003d 0;\n    for (Map.Entry\u003cTaskId,Task\u003e taskEntry : tasks.entrySet()) {\n      Task task \u003d taskEntry.getValue();\n      for (Map.Entry\u003cTaskAttemptId,TaskAttempt\u003e taskAttemptEntry : task.getAttempts().entrySet()) {\n        TaskAttempt taskAttempt \u003d taskAttemptEntry.getValue();\n        allTaskAttempts.add(taskAttempt);\n        if (task.getType() \u003d\u003d TaskType.MAP) {\n          ++numMapAttempts;\n        }\n      }\n    }\n    Collections.sort(allTaskAttempts, new Comparator\u003cTaskAttempt\u003e() {\n\n      @Override\n      public int compare(TaskAttempt o1, TaskAttempt o2) {\n        if (o1.getFinishTime() \u003d\u003d 0 || o2.getFinishTime() \u003d\u003d 0) {\n          if (o1.getFinishTime() \u003d\u003d 0 \u0026\u0026 o2.getFinishTime() \u003d\u003d 0) {\n            if (o1.getLaunchTime() \u003d\u003d 0 || o2.getLaunchTime() \u003d\u003d 0) {\n              if (o1.getLaunchTime() \u003d\u003d 0 \u0026\u0026 o2.getLaunchTime() \u003d\u003d 0) {\n                return 0;\n              } else {\n                long res \u003d o1.getLaunchTime() - o2.getLaunchTime();\n                return res \u003e 0 ? -1 : 1;\n              }\n            } else {\n              return (int) (o1.getLaunchTime() - o2.getLaunchTime());\n            }\n          } else {\n            long res \u003d o1.getFinishTime() - o2.getFinishTime();\n            return res \u003e 0 ? -1 : 1;\n          }\n        } else {\n          return (int) (o1.getFinishTime() - o2.getFinishTime());\n        }\n      }\n    });\n\n    mapCompletionEvents \u003d\n        new ArrayList\u003cTaskAttemptCompletionEvent\u003e(numMapAttempts);\n    int eventId \u003d 0;\n    for (TaskAttempt taskAttempt : allTaskAttempts) {\n\n      TaskAttemptCompletionEvent tace \u003d\n          Records.newRecord(TaskAttemptCompletionEvent.class);\n\n      int attemptRunTime \u003d -1;\n      if (taskAttempt.getLaunchTime() !\u003d 0 \u0026\u0026 taskAttempt.getFinishTime() !\u003d 0) {\n        attemptRunTime \u003d\n            (int) (taskAttempt.getFinishTime() - taskAttempt.getLaunchTime());\n      }\n      // Default to KILLED\n      TaskAttemptCompletionEventStatus taceStatus \u003d\n          TaskAttemptCompletionEventStatus.KILLED;\n      String taStateString \u003d taskAttempt.getState().toString();\n      try {\n        taceStatus \u003d TaskAttemptCompletionEventStatus.valueOf(taStateString);\n      } catch (Exception e) {\n        LOG.warn(\"Cannot constuct TACEStatus from TaskAtemptState: [\"\n            + taStateString + \"] for taskAttemptId: [\" + taskAttempt.getID()\n            + \"]. Defaulting to KILLED\");\n      }\n\n      tace.setAttemptId(taskAttempt.getID());\n      tace.setAttemptRunTime(attemptRunTime);\n      tace.setEventId(eventId++);\n      tace.setMapOutputServerAddress(taskAttempt\n          .getAssignedContainerMgrAddress());\n      tace.setStatus(taceStatus);\n      completionEvents.add(tace);\n      if (taskAttempt.getID().getTaskId().getTaskType() \u003d\u003d TaskType.MAP) {\n        mapCompletionEvents.add(tace);\n      }\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-hs/src/main/java/org/apache/hadoop/mapreduce/v2/hs/CompletedJob.java",
      "extendedDetails": {}
    },
    "1195f844a9a74de6709ba7d8aaf70c21f27cd2b3": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-4733. Reducer can fail to make progress during shuffle if too many reducers complete consecutively. Contributed by Jason Lowe via.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1400264 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/10/12 1:18 PM",
      "commitName": "1195f844a9a74de6709ba7d8aaf70c21f27cd2b3",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "17/04/12 6:59 PM",
      "commitNameOld": "7d04a96027ad75877b41b7cd8f67455dd13159d7",
      "commitAuthorOld": "Siddharth Seth",
      "daysBetweenCommits": 184.76,
      "commitsBetweenForRepo": 1068,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,69 +1,78 @@\n   private void constructTaskAttemptCompletionEvents() {\n     loadAllTasks();\n     completionEvents \u003d new LinkedList\u003cTaskAttemptCompletionEvent\u003e();\n     List\u003cTaskAttempt\u003e allTaskAttempts \u003d new LinkedList\u003cTaskAttempt\u003e();\n+    int numMapAttempts \u003d 0;\n     for (TaskId taskId : tasks.keySet()) {\n       Task task \u003d tasks.get(taskId);\n       for (TaskAttemptId taskAttemptId : task.getAttempts().keySet()) {\n         TaskAttempt taskAttempt \u003d task.getAttempts().get(taskAttemptId);\n         allTaskAttempts.add(taskAttempt);\n+        if (task.getType() \u003d\u003d TaskType.MAP) {\n+          ++numMapAttempts;\n+        }\n       }\n     }\n     Collections.sort(allTaskAttempts, new Comparator\u003cTaskAttempt\u003e() {\n \n       @Override\n       public int compare(TaskAttempt o1, TaskAttempt o2) {\n         if (o1.getFinishTime() \u003d\u003d 0 || o2.getFinishTime() \u003d\u003d 0) {\n           if (o1.getFinishTime() \u003d\u003d 0 \u0026\u0026 o2.getFinishTime() \u003d\u003d 0) {\n             if (o1.getLaunchTime() \u003d\u003d 0 || o2.getLaunchTime() \u003d\u003d 0) {\n               if (o1.getLaunchTime() \u003d\u003d 0 \u0026\u0026 o2.getLaunchTime() \u003d\u003d 0) {\n                 return 0;\n               } else {\n                 long res \u003d o1.getLaunchTime() - o2.getLaunchTime();\n                 return res \u003e 0 ? -1 : 1;\n               }\n             } else {\n               return (int) (o1.getLaunchTime() - o2.getLaunchTime());\n             }\n           } else {\n             long res \u003d o1.getFinishTime() - o2.getFinishTime();\n             return res \u003e 0 ? -1 : 1;\n           }\n         } else {\n           return (int) (o1.getFinishTime() - o2.getFinishTime());\n         }\n       }\n     });\n \n+    mapCompletionEvents \u003d\n+        new ArrayList\u003cTaskAttemptCompletionEvent\u003e(numMapAttempts);\n     int eventId \u003d 0;\n     for (TaskAttempt taskAttempt : allTaskAttempts) {\n \n       TaskAttemptCompletionEvent tace \u003d\n           Records.newRecord(TaskAttemptCompletionEvent.class);\n \n       int attemptRunTime \u003d -1;\n       if (taskAttempt.getLaunchTime() !\u003d 0 \u0026\u0026 taskAttempt.getFinishTime() !\u003d 0) {\n         attemptRunTime \u003d\n             (int) (taskAttempt.getFinishTime() - taskAttempt.getLaunchTime());\n       }\n       // Default to KILLED\n       TaskAttemptCompletionEventStatus taceStatus \u003d\n           TaskAttemptCompletionEventStatus.KILLED;\n       String taStateString \u003d taskAttempt.getState().toString();\n       try {\n         taceStatus \u003d TaskAttemptCompletionEventStatus.valueOf(taStateString);\n       } catch (Exception e) {\n         LOG.warn(\"Cannot constuct TACEStatus from TaskAtemptState: [\"\n             + taStateString + \"] for taskAttemptId: [\" + taskAttempt.getID()\n             + \"]. Defaulting to KILLED\");\n       }\n \n       tace.setAttemptId(taskAttempt.getID());\n       tace.setAttemptRunTime(attemptRunTime);\n       tace.setEventId(eventId++);\n       tace.setMapOutputServerAddress(taskAttempt\n           .getAssignedContainerMgrAddress());\n       tace.setStatus(taceStatus);\n       completionEvents.add(tace);\n+      if (taskAttempt.getID().getTaskId().getTaskType() \u003d\u003d TaskType.MAP) {\n+        mapCompletionEvents.add(tace);\n+      }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void constructTaskAttemptCompletionEvents() {\n    loadAllTasks();\n    completionEvents \u003d new LinkedList\u003cTaskAttemptCompletionEvent\u003e();\n    List\u003cTaskAttempt\u003e allTaskAttempts \u003d new LinkedList\u003cTaskAttempt\u003e();\n    int numMapAttempts \u003d 0;\n    for (TaskId taskId : tasks.keySet()) {\n      Task task \u003d tasks.get(taskId);\n      for (TaskAttemptId taskAttemptId : task.getAttempts().keySet()) {\n        TaskAttempt taskAttempt \u003d task.getAttempts().get(taskAttemptId);\n        allTaskAttempts.add(taskAttempt);\n        if (task.getType() \u003d\u003d TaskType.MAP) {\n          ++numMapAttempts;\n        }\n      }\n    }\n    Collections.sort(allTaskAttempts, new Comparator\u003cTaskAttempt\u003e() {\n\n      @Override\n      public int compare(TaskAttempt o1, TaskAttempt o2) {\n        if (o1.getFinishTime() \u003d\u003d 0 || o2.getFinishTime() \u003d\u003d 0) {\n          if (o1.getFinishTime() \u003d\u003d 0 \u0026\u0026 o2.getFinishTime() \u003d\u003d 0) {\n            if (o1.getLaunchTime() \u003d\u003d 0 || o2.getLaunchTime() \u003d\u003d 0) {\n              if (o1.getLaunchTime() \u003d\u003d 0 \u0026\u0026 o2.getLaunchTime() \u003d\u003d 0) {\n                return 0;\n              } else {\n                long res \u003d o1.getLaunchTime() - o2.getLaunchTime();\n                return res \u003e 0 ? -1 : 1;\n              }\n            } else {\n              return (int) (o1.getLaunchTime() - o2.getLaunchTime());\n            }\n          } else {\n            long res \u003d o1.getFinishTime() - o2.getFinishTime();\n            return res \u003e 0 ? -1 : 1;\n          }\n        } else {\n          return (int) (o1.getFinishTime() - o2.getFinishTime());\n        }\n      }\n    });\n\n    mapCompletionEvents \u003d\n        new ArrayList\u003cTaskAttemptCompletionEvent\u003e(numMapAttempts);\n    int eventId \u003d 0;\n    for (TaskAttempt taskAttempt : allTaskAttempts) {\n\n      TaskAttemptCompletionEvent tace \u003d\n          Records.newRecord(TaskAttemptCompletionEvent.class);\n\n      int attemptRunTime \u003d -1;\n      if (taskAttempt.getLaunchTime() !\u003d 0 \u0026\u0026 taskAttempt.getFinishTime() !\u003d 0) {\n        attemptRunTime \u003d\n            (int) (taskAttempt.getFinishTime() - taskAttempt.getLaunchTime());\n      }\n      // Default to KILLED\n      TaskAttemptCompletionEventStatus taceStatus \u003d\n          TaskAttemptCompletionEventStatus.KILLED;\n      String taStateString \u003d taskAttempt.getState().toString();\n      try {\n        taceStatus \u003d TaskAttemptCompletionEventStatus.valueOf(taStateString);\n      } catch (Exception e) {\n        LOG.warn(\"Cannot constuct TACEStatus from TaskAtemptState: [\"\n            + taStateString + \"] for taskAttemptId: [\" + taskAttempt.getID()\n            + \"]. Defaulting to KILLED\");\n      }\n\n      tace.setAttemptId(taskAttempt.getID());\n      tace.setAttemptRunTime(attemptRunTime);\n      tace.setEventId(eventId++);\n      tace.setMapOutputServerAddress(taskAttempt\n          .getAssignedContainerMgrAddress());\n      tace.setStatus(taceStatus);\n      completionEvents.add(tace);\n      if (taskAttempt.getID().getTaskId().getTaskType() \u003d\u003d TaskType.MAP) {\n        mapCompletionEvents.add(tace);\n      }\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-hs/src/main/java/org/apache/hadoop/mapreduce/v2/hs/CompletedJob.java",
      "extendedDetails": {}
    },
    "7475e836dc2bdd29142eaf210262fba354b745ed": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3901. Modified JobHistory records in YARN to lazily load job and task reports so as to improve UI response times. Contributed by Siddarth Seth.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1294417 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/02/12 4:32 PM",
      "commitName": "7475e836dc2bdd29142eaf210262fba354b745ed",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "24/02/12 2:30 PM",
      "commitNameOld": "582b97c3e75d3e7535a6cdf32a53582e89380490",
      "commitAuthorOld": "Thomas Graves",
      "daysBetweenCommits": 3.08,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,68 +1,69 @@\n   private void constructTaskAttemptCompletionEvents() {\n+    loadAllTasks();\n     completionEvents \u003d new LinkedList\u003cTaskAttemptCompletionEvent\u003e();\n     List\u003cTaskAttempt\u003e allTaskAttempts \u003d new LinkedList\u003cTaskAttempt\u003e();\n     for (TaskId taskId : tasks.keySet()) {\n       Task task \u003d tasks.get(taskId);\n       for (TaskAttemptId taskAttemptId : task.getAttempts().keySet()) {\n         TaskAttempt taskAttempt \u003d task.getAttempts().get(taskAttemptId);\n         allTaskAttempts.add(taskAttempt);\n       }\n     }\n     Collections.sort(allTaskAttempts, new Comparator\u003cTaskAttempt\u003e() {\n \n       @Override\n       public int compare(TaskAttempt o1, TaskAttempt o2) {\n         if (o1.getFinishTime() \u003d\u003d 0 || o2.getFinishTime() \u003d\u003d 0) {\n           if (o1.getFinishTime() \u003d\u003d 0 \u0026\u0026 o2.getFinishTime() \u003d\u003d 0) {\n             if (o1.getLaunchTime() \u003d\u003d 0 || o2.getLaunchTime() \u003d\u003d 0) {\n               if (o1.getLaunchTime() \u003d\u003d 0 \u0026\u0026 o2.getLaunchTime() \u003d\u003d 0) {\n                 return 0;\n               } else {\n                 long res \u003d o1.getLaunchTime() - o2.getLaunchTime();\n                 return res \u003e 0 ? -1 : 1;\n               }\n             } else {\n               return (int) (o1.getLaunchTime() - o2.getLaunchTime());\n             }\n           } else {\n             long res \u003d o1.getFinishTime() - o2.getFinishTime();\n             return res \u003e 0 ? -1 : 1;\n           }\n         } else {\n           return (int) (o1.getFinishTime() - o2.getFinishTime());\n         }\n       }\n     });\n \n     int eventId \u003d 0;\n     for (TaskAttempt taskAttempt : allTaskAttempts) {\n \n-      TaskAttemptCompletionEvent tace \u003d RecordFactoryProvider.getRecordFactory(\n-          null).newRecordInstance(TaskAttemptCompletionEvent.class);\n+      TaskAttemptCompletionEvent tace \u003d\n+          Records.newRecord(TaskAttemptCompletionEvent.class);\n \n       int attemptRunTime \u003d -1;\n       if (taskAttempt.getLaunchTime() !\u003d 0 \u0026\u0026 taskAttempt.getFinishTime() !\u003d 0) {\n         attemptRunTime \u003d\n             (int) (taskAttempt.getFinishTime() - taskAttempt.getLaunchTime());\n       }\n       // Default to KILLED\n       TaskAttemptCompletionEventStatus taceStatus \u003d\n           TaskAttemptCompletionEventStatus.KILLED;\n       String taStateString \u003d taskAttempt.getState().toString();\n       try {\n         taceStatus \u003d TaskAttemptCompletionEventStatus.valueOf(taStateString);\n       } catch (Exception e) {\n         LOG.warn(\"Cannot constuct TACEStatus from TaskAtemptState: [\"\n             + taStateString + \"] for taskAttemptId: [\" + taskAttempt.getID()\n             + \"]. Defaulting to KILLED\");\n       }\n \n       tace.setAttemptId(taskAttempt.getID());\n       tace.setAttemptRunTime(attemptRunTime);\n       tace.setEventId(eventId++);\n       tace.setMapOutputServerAddress(taskAttempt\n           .getAssignedContainerMgrAddress());\n       tace.setStatus(taceStatus);\n       completionEvents.add(tace);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void constructTaskAttemptCompletionEvents() {\n    loadAllTasks();\n    completionEvents \u003d new LinkedList\u003cTaskAttemptCompletionEvent\u003e();\n    List\u003cTaskAttempt\u003e allTaskAttempts \u003d new LinkedList\u003cTaskAttempt\u003e();\n    for (TaskId taskId : tasks.keySet()) {\n      Task task \u003d tasks.get(taskId);\n      for (TaskAttemptId taskAttemptId : task.getAttempts().keySet()) {\n        TaskAttempt taskAttempt \u003d task.getAttempts().get(taskAttemptId);\n        allTaskAttempts.add(taskAttempt);\n      }\n    }\n    Collections.sort(allTaskAttempts, new Comparator\u003cTaskAttempt\u003e() {\n\n      @Override\n      public int compare(TaskAttempt o1, TaskAttempt o2) {\n        if (o1.getFinishTime() \u003d\u003d 0 || o2.getFinishTime() \u003d\u003d 0) {\n          if (o1.getFinishTime() \u003d\u003d 0 \u0026\u0026 o2.getFinishTime() \u003d\u003d 0) {\n            if (o1.getLaunchTime() \u003d\u003d 0 || o2.getLaunchTime() \u003d\u003d 0) {\n              if (o1.getLaunchTime() \u003d\u003d 0 \u0026\u0026 o2.getLaunchTime() \u003d\u003d 0) {\n                return 0;\n              } else {\n                long res \u003d o1.getLaunchTime() - o2.getLaunchTime();\n                return res \u003e 0 ? -1 : 1;\n              }\n            } else {\n              return (int) (o1.getLaunchTime() - o2.getLaunchTime());\n            }\n          } else {\n            long res \u003d o1.getFinishTime() - o2.getFinishTime();\n            return res \u003e 0 ? -1 : 1;\n          }\n        } else {\n          return (int) (o1.getFinishTime() - o2.getFinishTime());\n        }\n      }\n    });\n\n    int eventId \u003d 0;\n    for (TaskAttempt taskAttempt : allTaskAttempts) {\n\n      TaskAttemptCompletionEvent tace \u003d\n          Records.newRecord(TaskAttemptCompletionEvent.class);\n\n      int attemptRunTime \u003d -1;\n      if (taskAttempt.getLaunchTime() !\u003d 0 \u0026\u0026 taskAttempt.getFinishTime() !\u003d 0) {\n        attemptRunTime \u003d\n            (int) (taskAttempt.getFinishTime() - taskAttempt.getLaunchTime());\n      }\n      // Default to KILLED\n      TaskAttemptCompletionEventStatus taceStatus \u003d\n          TaskAttemptCompletionEventStatus.KILLED;\n      String taStateString \u003d taskAttempt.getState().toString();\n      try {\n        taceStatus \u003d TaskAttemptCompletionEventStatus.valueOf(taStateString);\n      } catch (Exception e) {\n        LOG.warn(\"Cannot constuct TACEStatus from TaskAtemptState: [\"\n            + taStateString + \"] for taskAttemptId: [\" + taskAttempt.getID()\n            + \"]. Defaulting to KILLED\");\n      }\n\n      tace.setAttemptId(taskAttempt.getID());\n      tace.setAttemptRunTime(attemptRunTime);\n      tace.setEventId(eventId++);\n      tace.setMapOutputServerAddress(taskAttempt\n          .getAssignedContainerMgrAddress());\n      tace.setStatus(taceStatus);\n      completionEvents.add(tace);\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-hs/src/main/java/org/apache/hadoop/mapreduce/v2/hs/CompletedJob.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private void constructTaskAttemptCompletionEvents() {\n    completionEvents \u003d new LinkedList\u003cTaskAttemptCompletionEvent\u003e();\n    List\u003cTaskAttempt\u003e allTaskAttempts \u003d new LinkedList\u003cTaskAttempt\u003e();\n    for (TaskId taskId : tasks.keySet()) {\n      Task task \u003d tasks.get(taskId);\n      for (TaskAttemptId taskAttemptId : task.getAttempts().keySet()) {\n        TaskAttempt taskAttempt \u003d task.getAttempts().get(taskAttemptId);\n        allTaskAttempts.add(taskAttempt);\n      }\n    }\n    Collections.sort(allTaskAttempts, new Comparator\u003cTaskAttempt\u003e() {\n\n      @Override\n      public int compare(TaskAttempt o1, TaskAttempt o2) {\n        if (o1.getFinishTime() \u003d\u003d 0 || o2.getFinishTime() \u003d\u003d 0) {\n          if (o1.getFinishTime() \u003d\u003d 0 \u0026\u0026 o2.getFinishTime() \u003d\u003d 0) {\n            if (o1.getLaunchTime() \u003d\u003d 0 || o2.getLaunchTime() \u003d\u003d 0) {\n              if (o1.getLaunchTime() \u003d\u003d 0 \u0026\u0026 o2.getLaunchTime() \u003d\u003d 0) {\n                return 0;\n              } else {\n                long res \u003d o1.getLaunchTime() - o2.getLaunchTime();\n                return res \u003e 0 ? -1 : 1;\n              }\n            } else {\n              return (int) (o1.getLaunchTime() - o2.getLaunchTime());\n            }\n          } else {\n            long res \u003d o1.getFinishTime() - o2.getFinishTime();\n            return res \u003e 0 ? -1 : 1;\n          }\n        } else {\n          return (int) (o1.getFinishTime() - o2.getFinishTime());\n        }\n      }\n    });\n\n    int eventId \u003d 0;\n    for (TaskAttempt taskAttempt : allTaskAttempts) {\n\n      TaskAttemptCompletionEvent tace \u003d RecordFactoryProvider.getRecordFactory(\n          null).newRecordInstance(TaskAttemptCompletionEvent.class);\n\n      int attemptRunTime \u003d -1;\n      if (taskAttempt.getLaunchTime() !\u003d 0 \u0026\u0026 taskAttempt.getFinishTime() !\u003d 0) {\n        attemptRunTime \u003d (int) (taskAttempt.getFinishTime() - taskAttempt\n            .getLaunchTime());\n      }\n      // Default to KILLED\n      TaskAttemptCompletionEventStatus taceStatus \u003d TaskAttemptCompletionEventStatus.KILLED;\n      String taStateString \u003d taskAttempt.getState().toString();\n      try {\n        taceStatus \u003d TaskAttemptCompletionEventStatus.valueOf(taStateString);\n      } catch (Exception e) {\n        LOG.warn(\"Cannot constuct TACEStatus from TaskAtemptState: [\"\n            + taStateString + \"] for taskAttemptId: [\" + taskAttempt.getID()\n            + \"]. Defaulting to KILLED\");\n      }\n\n      tace.setAttemptId(taskAttempt.getID());\n      tace.setAttemptRunTime(attemptRunTime);\n      tace.setEventId(eventId++);\n      tace.setMapOutputServerAddress(taskAttempt\n          .getAssignedContainerMgrAddress());\n      tace.setStatus(taceStatus);\n      completionEvents.add(tace);\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-hs/src/main/java/org/apache/hadoop/mapreduce/v2/hs/CompletedJob.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce/hadoop-mr-client/hadoop-mapreduce-client-hs/src/main/java/org/apache/hadoop/mapreduce/v2/hs/CompletedJob.java",
        "newPath": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-hs/src/main/java/org/apache/hadoop/mapreduce/v2/hs/CompletedJob.java"
      }
    },
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-279. MapReduce 2.0. Merging MR-279 branch into trunk. Contributed by Arun C Murthy, Christopher Douglas, Devaraj Das, Greg Roelofs, Jeffrey Naisbitt, Josh Wills, Jonathan Eagles, Krishna Ramachandran, Luke Lu, Mahadev Konar, Robert Evans, Sharad Agarwal, Siddharth Seth, Thomas Graves, and Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159166 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/08/11 4:07 AM",
      "commitName": "dbecbe5dfe50f834fc3b8401709079e9470cc517",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,67 @@\n+  private void constructTaskAttemptCompletionEvents() {\n+    completionEvents \u003d new LinkedList\u003cTaskAttemptCompletionEvent\u003e();\n+    List\u003cTaskAttempt\u003e allTaskAttempts \u003d new LinkedList\u003cTaskAttempt\u003e();\n+    for (TaskId taskId : tasks.keySet()) {\n+      Task task \u003d tasks.get(taskId);\n+      for (TaskAttemptId taskAttemptId : task.getAttempts().keySet()) {\n+        TaskAttempt taskAttempt \u003d task.getAttempts().get(taskAttemptId);\n+        allTaskAttempts.add(taskAttempt);\n+      }\n+    }\n+    Collections.sort(allTaskAttempts, new Comparator\u003cTaskAttempt\u003e() {\n+\n+      @Override\n+      public int compare(TaskAttempt o1, TaskAttempt o2) {\n+        if (o1.getFinishTime() \u003d\u003d 0 || o2.getFinishTime() \u003d\u003d 0) {\n+          if (o1.getFinishTime() \u003d\u003d 0 \u0026\u0026 o2.getFinishTime() \u003d\u003d 0) {\n+            if (o1.getLaunchTime() \u003d\u003d 0 || o2.getLaunchTime() \u003d\u003d 0) {\n+              if (o1.getLaunchTime() \u003d\u003d 0 \u0026\u0026 o2.getLaunchTime() \u003d\u003d 0) {\n+                return 0;\n+              } else {\n+                long res \u003d o1.getLaunchTime() - o2.getLaunchTime();\n+                return res \u003e 0 ? -1 : 1;\n+              }\n+            } else {\n+              return (int) (o1.getLaunchTime() - o2.getLaunchTime());\n+            }\n+          } else {\n+            long res \u003d o1.getFinishTime() - o2.getFinishTime();\n+            return res \u003e 0 ? -1 : 1;\n+          }\n+        } else {\n+          return (int) (o1.getFinishTime() - o2.getFinishTime());\n+        }\n+      }\n+    });\n+\n+    int eventId \u003d 0;\n+    for (TaskAttempt taskAttempt : allTaskAttempts) {\n+\n+      TaskAttemptCompletionEvent tace \u003d RecordFactoryProvider.getRecordFactory(\n+          null).newRecordInstance(TaskAttemptCompletionEvent.class);\n+\n+      int attemptRunTime \u003d -1;\n+      if (taskAttempt.getLaunchTime() !\u003d 0 \u0026\u0026 taskAttempt.getFinishTime() !\u003d 0) {\n+        attemptRunTime \u003d (int) (taskAttempt.getFinishTime() - taskAttempt\n+            .getLaunchTime());\n+      }\n+      // Default to KILLED\n+      TaskAttemptCompletionEventStatus taceStatus \u003d TaskAttemptCompletionEventStatus.KILLED;\n+      String taStateString \u003d taskAttempt.getState().toString();\n+      try {\n+        taceStatus \u003d TaskAttemptCompletionEventStatus.valueOf(taStateString);\n+      } catch (Exception e) {\n+        LOG.warn(\"Cannot constuct TACEStatus from TaskAtemptState: [\"\n+            + taStateString + \"] for taskAttemptId: [\" + taskAttempt.getID()\n+            + \"]. Defaulting to KILLED\");\n+      }\n+\n+      tace.setAttemptId(taskAttempt.getID());\n+      tace.setAttemptRunTime(attemptRunTime);\n+      tace.setEventId(eventId++);\n+      tace.setMapOutputServerAddress(taskAttempt\n+          .getAssignedContainerMgrAddress());\n+      tace.setStatus(taceStatus);\n+      completionEvents.add(tace);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void constructTaskAttemptCompletionEvents() {\n    completionEvents \u003d new LinkedList\u003cTaskAttemptCompletionEvent\u003e();\n    List\u003cTaskAttempt\u003e allTaskAttempts \u003d new LinkedList\u003cTaskAttempt\u003e();\n    for (TaskId taskId : tasks.keySet()) {\n      Task task \u003d tasks.get(taskId);\n      for (TaskAttemptId taskAttemptId : task.getAttempts().keySet()) {\n        TaskAttempt taskAttempt \u003d task.getAttempts().get(taskAttemptId);\n        allTaskAttempts.add(taskAttempt);\n      }\n    }\n    Collections.sort(allTaskAttempts, new Comparator\u003cTaskAttempt\u003e() {\n\n      @Override\n      public int compare(TaskAttempt o1, TaskAttempt o2) {\n        if (o1.getFinishTime() \u003d\u003d 0 || o2.getFinishTime() \u003d\u003d 0) {\n          if (o1.getFinishTime() \u003d\u003d 0 \u0026\u0026 o2.getFinishTime() \u003d\u003d 0) {\n            if (o1.getLaunchTime() \u003d\u003d 0 || o2.getLaunchTime() \u003d\u003d 0) {\n              if (o1.getLaunchTime() \u003d\u003d 0 \u0026\u0026 o2.getLaunchTime() \u003d\u003d 0) {\n                return 0;\n              } else {\n                long res \u003d o1.getLaunchTime() - o2.getLaunchTime();\n                return res \u003e 0 ? -1 : 1;\n              }\n            } else {\n              return (int) (o1.getLaunchTime() - o2.getLaunchTime());\n            }\n          } else {\n            long res \u003d o1.getFinishTime() - o2.getFinishTime();\n            return res \u003e 0 ? -1 : 1;\n          }\n        } else {\n          return (int) (o1.getFinishTime() - o2.getFinishTime());\n        }\n      }\n    });\n\n    int eventId \u003d 0;\n    for (TaskAttempt taskAttempt : allTaskAttempts) {\n\n      TaskAttemptCompletionEvent tace \u003d RecordFactoryProvider.getRecordFactory(\n          null).newRecordInstance(TaskAttemptCompletionEvent.class);\n\n      int attemptRunTime \u003d -1;\n      if (taskAttempt.getLaunchTime() !\u003d 0 \u0026\u0026 taskAttempt.getFinishTime() !\u003d 0) {\n        attemptRunTime \u003d (int) (taskAttempt.getFinishTime() - taskAttempt\n            .getLaunchTime());\n      }\n      // Default to KILLED\n      TaskAttemptCompletionEventStatus taceStatus \u003d TaskAttemptCompletionEventStatus.KILLED;\n      String taStateString \u003d taskAttempt.getState().toString();\n      try {\n        taceStatus \u003d TaskAttemptCompletionEventStatus.valueOf(taStateString);\n      } catch (Exception e) {\n        LOG.warn(\"Cannot constuct TACEStatus from TaskAtemptState: [\"\n            + taStateString + \"] for taskAttemptId: [\" + taskAttempt.getID()\n            + \"]. Defaulting to KILLED\");\n      }\n\n      tace.setAttemptId(taskAttempt.getID());\n      tace.setAttemptRunTime(attemptRunTime);\n      tace.setEventId(eventId++);\n      tace.setMapOutputServerAddress(taskAttempt\n          .getAssignedContainerMgrAddress());\n      tace.setStatus(taceStatus);\n      completionEvents.add(tace);\n    }\n  }",
      "path": "hadoop-mapreduce/hadoop-mr-client/hadoop-mapreduce-client-hs/src/main/java/org/apache/hadoop/mapreduce/v2/hs/CompletedJob.java"
    }
  }
}