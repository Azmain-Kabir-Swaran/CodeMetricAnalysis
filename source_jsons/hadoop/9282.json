{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FSNamesystem.java",
  "functionName": "listCorruptFileBlocksWithSnapshot",
  "functionId": "listCorruptFileBlocksWithSnapshot___path-String__snapshottableDirs-List__String____cookieTab-String[]",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
  "functionStartLine": 6750,
  "functionEndLine": 6785,
  "numCommitsSeen": 873,
  "timeTaken": 15788,
  "changeHistory": [
    "693169ef34f856a27dc09d90a45fb4ec5b66ed2c",
    "9d175853b0170683ad5f21d9bcdeaac49fe89e04",
    "97913f430cbe3f82ac866ae6ab8f42754102f6c0"
  ],
  "changeHistoryShort": {
    "693169ef34f856a27dc09d90a45fb4ec5b66ed2c": "Ybodychange",
    "9d175853b0170683ad5f21d9bcdeaac49fe89e04": "Ybodychange",
    "97913f430cbe3f82ac866ae6ab8f42754102f6c0": "Yintroduced"
  },
  "changeHistoryDetails": {
    "693169ef34f856a27dc09d90a45fb4ec5b66ed2c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12882. Support full open(PathHandle) contract in HDFS\n",
      "commitDate": "11/12/17 8:14 PM",
      "commitName": "693169ef34f856a27dc09d90a45fb4ec5b66ed2c",
      "commitAuthor": "Chris Douglas",
      "commitDateOld": "01/12/17 10:34 PM",
      "commitNameOld": "42307e3c3abbfe0b83d9a2581deba327435b910f",
      "commitAuthorOld": "Chris Douglas",
      "daysBetweenCommits": 9.9,
      "commitsBetweenForRepo": 58,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,36 +1,36 @@\n   List\u003cString\u003e listCorruptFileBlocksWithSnapshot(String path,\n       List\u003cString\u003e snapshottableDirs, String[] cookieTab) throws IOException {\n     final Collection\u003cCorruptFileBlockInfo\u003e corruptFileBlocks \u003d\n         listCorruptFileBlocks(path, cookieTab);\n     List\u003cString\u003e list \u003d new ArrayList\u003cString\u003e();\n \n     // Precalculate snapshottableFeature list\n     List\u003cDirectorySnapshottableFeature\u003e lsf \u003d new ArrayList\u003c\u003e();\n     if (snapshottableDirs !\u003d null) {\n       for (String snap : snapshottableDirs) {\n         final INode isnap \u003d getFSDirectory().getINode(snap, DirOp.READ_LINK);\n         final DirectorySnapshottableFeature sf \u003d\n             isnap.asDirectory().getDirectorySnapshottableFeature();\n         if (sf \u003d\u003d null) {\n           throw new SnapshotException(\n               \"Directory is not a snapshottable directory: \" + snap);\n         }\n         lsf.add(sf);\n       }\n     }\n \n     for (CorruptFileBlockInfo c : corruptFileBlocks) {\n-      if (getFileInfo(c.path, true) !\u003d null) {\n+      if (getFileInfo(c.path, true, false, false) !\u003d null) {\n         list.add(c.toString());\n       }\n       final Collection\u003cString\u003e snaps \u003d FSDirSnapshotOp\n           .getSnapshotFiles(getFSDirectory(), lsf, c.path);\n       if (snaps !\u003d null) {\n         for (String snap : snaps) {\n           // follow the syntax of CorruptFileBlockInfo#toString()\n           list.add(c.block.getBlockName() + \"\\t\" + snap);\n         }\n       }\n     }\n     return list;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  List\u003cString\u003e listCorruptFileBlocksWithSnapshot(String path,\n      List\u003cString\u003e snapshottableDirs, String[] cookieTab) throws IOException {\n    final Collection\u003cCorruptFileBlockInfo\u003e corruptFileBlocks \u003d\n        listCorruptFileBlocks(path, cookieTab);\n    List\u003cString\u003e list \u003d new ArrayList\u003cString\u003e();\n\n    // Precalculate snapshottableFeature list\n    List\u003cDirectorySnapshottableFeature\u003e lsf \u003d new ArrayList\u003c\u003e();\n    if (snapshottableDirs !\u003d null) {\n      for (String snap : snapshottableDirs) {\n        final INode isnap \u003d getFSDirectory().getINode(snap, DirOp.READ_LINK);\n        final DirectorySnapshottableFeature sf \u003d\n            isnap.asDirectory().getDirectorySnapshottableFeature();\n        if (sf \u003d\u003d null) {\n          throw new SnapshotException(\n              \"Directory is not a snapshottable directory: \" + snap);\n        }\n        lsf.add(sf);\n      }\n    }\n\n    for (CorruptFileBlockInfo c : corruptFileBlocks) {\n      if (getFileInfo(c.path, true, false, false) !\u003d null) {\n        list.add(c.toString());\n      }\n      final Collection\u003cString\u003e snaps \u003d FSDirSnapshotOp\n          .getSnapshotFiles(getFSDirectory(), lsf, c.path);\n      if (snaps !\u003d null) {\n        for (String snap : snaps) {\n          // follow the syntax of CorruptFileBlockInfo#toString()\n          list.add(c.block.getBlockName() + \"\\t\" + snap);\n        }\n      }\n    }\n    return list;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "9d175853b0170683ad5f21d9bcdeaac49fe89e04": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10997. Reduce number of path resolving methods. Contributed by Daryn Sharp.\n",
      "commitDate": "24/10/16 3:14 PM",
      "commitName": "9d175853b0170683ad5f21d9bcdeaac49fe89e04",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "17/10/16 5:45 PM",
      "commitNameOld": "b61fb267b92b2736920b4bd0c673d31e7632ebb9",
      "commitAuthorOld": "Ming Ma",
      "daysBetweenCommits": 6.9,
      "commitsBetweenForRepo": 44,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,36 +1,36 @@\n   List\u003cString\u003e listCorruptFileBlocksWithSnapshot(String path,\n       List\u003cString\u003e snapshottableDirs, String[] cookieTab) throws IOException {\n     final Collection\u003cCorruptFileBlockInfo\u003e corruptFileBlocks \u003d\n         listCorruptFileBlocks(path, cookieTab);\n     List\u003cString\u003e list \u003d new ArrayList\u003cString\u003e();\n \n     // Precalculate snapshottableFeature list\n     List\u003cDirectorySnapshottableFeature\u003e lsf \u003d new ArrayList\u003c\u003e();\n     if (snapshottableDirs !\u003d null) {\n       for (String snap : snapshottableDirs) {\n-        final INode isnap \u003d getFSDirectory().getINode(snap, false);\n+        final INode isnap \u003d getFSDirectory().getINode(snap, DirOp.READ_LINK);\n         final DirectorySnapshottableFeature sf \u003d\n             isnap.asDirectory().getDirectorySnapshottableFeature();\n         if (sf \u003d\u003d null) {\n           throw new SnapshotException(\n               \"Directory is not a snapshottable directory: \" + snap);\n         }\n         lsf.add(sf);\n       }\n     }\n \n     for (CorruptFileBlockInfo c : corruptFileBlocks) {\n       if (getFileInfo(c.path, true) !\u003d null) {\n         list.add(c.toString());\n       }\n       final Collection\u003cString\u003e snaps \u003d FSDirSnapshotOp\n           .getSnapshotFiles(getFSDirectory(), lsf, c.path);\n       if (snaps !\u003d null) {\n         for (String snap : snaps) {\n           // follow the syntax of CorruptFileBlockInfo#toString()\n           list.add(c.block.getBlockName() + \"\\t\" + snap);\n         }\n       }\n     }\n     return list;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  List\u003cString\u003e listCorruptFileBlocksWithSnapshot(String path,\n      List\u003cString\u003e snapshottableDirs, String[] cookieTab) throws IOException {\n    final Collection\u003cCorruptFileBlockInfo\u003e corruptFileBlocks \u003d\n        listCorruptFileBlocks(path, cookieTab);\n    List\u003cString\u003e list \u003d new ArrayList\u003cString\u003e();\n\n    // Precalculate snapshottableFeature list\n    List\u003cDirectorySnapshottableFeature\u003e lsf \u003d new ArrayList\u003c\u003e();\n    if (snapshottableDirs !\u003d null) {\n      for (String snap : snapshottableDirs) {\n        final INode isnap \u003d getFSDirectory().getINode(snap, DirOp.READ_LINK);\n        final DirectorySnapshottableFeature sf \u003d\n            isnap.asDirectory().getDirectorySnapshottableFeature();\n        if (sf \u003d\u003d null) {\n          throw new SnapshotException(\n              \"Directory is not a snapshottable directory: \" + snap);\n        }\n        lsf.add(sf);\n      }\n    }\n\n    for (CorruptFileBlockInfo c : corruptFileBlocks) {\n      if (getFileInfo(c.path, true) !\u003d null) {\n        list.add(c.toString());\n      }\n      final Collection\u003cString\u003e snaps \u003d FSDirSnapshotOp\n          .getSnapshotFiles(getFSDirectory(), lsf, c.path);\n      if (snaps !\u003d null) {\n        for (String snap : snaps) {\n          // follow the syntax of CorruptFileBlockInfo#toString()\n          list.add(c.block.getBlockName() + \"\\t\" + snap);\n        }\n      }\n    }\n    return list;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "97913f430cbe3f82ac866ae6ab8f42754102f6c0": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-9231. fsck doesn\u0027t list correct file path when Bad Replicas/Blocks are in a snapshot. (Xiao Chen via Yongjun Zhang)\n",
      "commitDate": "27/10/15 11:31 PM",
      "commitName": "97913f430cbe3f82ac866ae6ab8f42754102f6c0",
      "commitAuthor": "Yongjun Zhang",
      "diff": "@@ -0,0 +1,36 @@\n+  List\u003cString\u003e listCorruptFileBlocksWithSnapshot(String path,\n+      List\u003cString\u003e snapshottableDirs, String[] cookieTab) throws IOException {\n+    final Collection\u003cCorruptFileBlockInfo\u003e corruptFileBlocks \u003d\n+        listCorruptFileBlocks(path, cookieTab);\n+    List\u003cString\u003e list \u003d new ArrayList\u003cString\u003e();\n+\n+    // Precalculate snapshottableFeature list\n+    List\u003cDirectorySnapshottableFeature\u003e lsf \u003d new ArrayList\u003c\u003e();\n+    if (snapshottableDirs !\u003d null) {\n+      for (String snap : snapshottableDirs) {\n+        final INode isnap \u003d getFSDirectory().getINode(snap, false);\n+        final DirectorySnapshottableFeature sf \u003d\n+            isnap.asDirectory().getDirectorySnapshottableFeature();\n+        if (sf \u003d\u003d null) {\n+          throw new SnapshotException(\n+              \"Directory is not a snapshottable directory: \" + snap);\n+        }\n+        lsf.add(sf);\n+      }\n+    }\n+\n+    for (CorruptFileBlockInfo c : corruptFileBlocks) {\n+      if (getFileInfo(c.path, true) !\u003d null) {\n+        list.add(c.toString());\n+      }\n+      final Collection\u003cString\u003e snaps \u003d FSDirSnapshotOp\n+          .getSnapshotFiles(getFSDirectory(), lsf, c.path);\n+      if (snaps !\u003d null) {\n+        for (String snap : snaps) {\n+          // follow the syntax of CorruptFileBlockInfo#toString()\n+          list.add(c.block.getBlockName() + \"\\t\" + snap);\n+        }\n+      }\n+    }\n+    return list;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  List\u003cString\u003e listCorruptFileBlocksWithSnapshot(String path,\n      List\u003cString\u003e snapshottableDirs, String[] cookieTab) throws IOException {\n    final Collection\u003cCorruptFileBlockInfo\u003e corruptFileBlocks \u003d\n        listCorruptFileBlocks(path, cookieTab);\n    List\u003cString\u003e list \u003d new ArrayList\u003cString\u003e();\n\n    // Precalculate snapshottableFeature list\n    List\u003cDirectorySnapshottableFeature\u003e lsf \u003d new ArrayList\u003c\u003e();\n    if (snapshottableDirs !\u003d null) {\n      for (String snap : snapshottableDirs) {\n        final INode isnap \u003d getFSDirectory().getINode(snap, false);\n        final DirectorySnapshottableFeature sf \u003d\n            isnap.asDirectory().getDirectorySnapshottableFeature();\n        if (sf \u003d\u003d null) {\n          throw new SnapshotException(\n              \"Directory is not a snapshottable directory: \" + snap);\n        }\n        lsf.add(sf);\n      }\n    }\n\n    for (CorruptFileBlockInfo c : corruptFileBlocks) {\n      if (getFileInfo(c.path, true) !\u003d null) {\n        list.add(c.toString());\n      }\n      final Collection\u003cString\u003e snaps \u003d FSDirSnapshotOp\n          .getSnapshotFiles(getFSDirectory(), lsf, c.path);\n      if (snaps !\u003d null) {\n        for (String snap : snaps) {\n          // follow the syntax of CorruptFileBlockInfo#toString()\n          list.add(c.block.getBlockName() + \"\\t\" + snap);\n        }\n      }\n    }\n    return list;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java"
    }
  }
}