{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "JobResourceUploader.java",
  "functionName": "useSharedCache",
  "functionId": "useSharedCache___sourceFile-URI__resourceName-String__statCache-Map__URI,FileStatus____conf-Configuration__honorFragment-boolean",
  "sourceFilePath": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapreduce/JobResourceUploader.java",
  "functionStartLine": 712,
  "functionEndLine": 781,
  "numCommitsSeen": 17,
  "timeTaken": 1240,
  "changeHistory": [
    "e46d5bb962b0c942f993afc505b165b1cd96e51b"
  ],
  "changeHistoryShort": {
    "e46d5bb962b0c942f993afc505b165b1cd96e51b": "Yintroduced"
  },
  "changeHistoryDetails": {
    "e46d5bb962b0c942f993afc505b165b1cd96e51b": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-5951. Add support for the YARN Shared Cache.\n",
      "commitDate": "12/10/17 10:59 AM",
      "commitName": "e46d5bb962b0c942f993afc505b165b1cd96e51b",
      "commitAuthor": "Chris Trezzo",
      "diff": "@@ -0,0 +1,70 @@\n+  private URI useSharedCache(URI sourceFile, String resourceName,\n+      Map\u003cURI, FileStatus\u003e statCache, Configuration conf, boolean honorFragment)\n+      throws IOException {\n+    if (scClient \u003d\u003d null) {\n+      return null;\n+    }\n+    Path filePath \u003d new Path(sourceFile);\n+    if (getFileStatus(statCache, conf, filePath).isDirectory()) {\n+      LOG.warn(\"Shared cache does not support directories\"\n+          + \" (see YARN-6097).\" + \" Will not upload \" + filePath\n+          + \" to the shared cache.\");\n+      return null;\n+    }\n+\n+    String rn \u003d resourceName;\n+    if (honorFragment) {\n+      if (sourceFile.getFragment() !\u003d null) {\n+        rn \u003d sourceFile.getFragment();\n+      }\n+    }\n+\n+    // If for whatever reason, we can\u0027t even calculate checksum for\n+    // a resource, something is really wrong with the file system;\n+    // even non-SCM approach won\u0027t work. Let us just throw the exception.\n+    String checksum \u003d scClient.getFileChecksum(filePath);\n+    URL url \u003d null;\n+    try {\n+      url \u003d scClient.use(this.appId, checksum);\n+    } catch (YarnException e) {\n+      LOG.warn(\"Error trying to contact the shared cache manager,\"\n+          + \" disabling the SCMClient for the rest of this job submission\", e);\n+      /*\n+       * If we fail to contact the SCM, we do not use it for the rest of this\n+       * JobResourceUploader\u0027s life. This prevents us from having to timeout\n+       * each time we try to upload a file while the SCM is unavailable. Instead\n+       * we timeout/error the first time and quickly revert to the default\n+       * behavior without the shared cache. We do this by stopping the shared\n+       * cache client and setting it to null.\n+       */\n+      stopSharedCache();\n+    }\n+\n+    if (url !\u003d null) {\n+      // Because we deal with URI\u0027s in mapreduce, we need to convert the URL to\n+      // a URI and add a fragment if necessary.\n+      URI uri \u003d null;\n+      try {\n+        String name \u003d new Path(url.getFile()).getName();\n+        if (rn !\u003d null \u0026\u0026 !name.equals(rn)) {\n+          // A name was specified that is different then the URL in the shared\n+          // cache. Therefore, we need to set the fragment portion of the URI to\n+          // preserve the user\u0027s desired name. We assume that there is no\n+          // existing fragment in the URL since the shared cache manager does\n+          // not use fragments.\n+          uri \u003d new URI(url.getScheme(), url.getUserInfo(), url.getHost(),\n+              url.getPort(), url.getFile(), null, rn);\n+        } else {\n+          uri \u003d new URI(url.getScheme(), url.getUserInfo(), url.getHost(),\n+              url.getPort(), url.getFile(), null, null);\n+        }\n+        return uri;\n+      } catch (URISyntaxException e) {\n+        LOG.warn(\"Error trying to convert URL received from shared cache to\"\n+            + \" a URI: \" + url.toString());\n+        return null;\n+      }\n+    } else {\n+      return null;\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private URI useSharedCache(URI sourceFile, String resourceName,\n      Map\u003cURI, FileStatus\u003e statCache, Configuration conf, boolean honorFragment)\n      throws IOException {\n    if (scClient \u003d\u003d null) {\n      return null;\n    }\n    Path filePath \u003d new Path(sourceFile);\n    if (getFileStatus(statCache, conf, filePath).isDirectory()) {\n      LOG.warn(\"Shared cache does not support directories\"\n          + \" (see YARN-6097).\" + \" Will not upload \" + filePath\n          + \" to the shared cache.\");\n      return null;\n    }\n\n    String rn \u003d resourceName;\n    if (honorFragment) {\n      if (sourceFile.getFragment() !\u003d null) {\n        rn \u003d sourceFile.getFragment();\n      }\n    }\n\n    // If for whatever reason, we can\u0027t even calculate checksum for\n    // a resource, something is really wrong with the file system;\n    // even non-SCM approach won\u0027t work. Let us just throw the exception.\n    String checksum \u003d scClient.getFileChecksum(filePath);\n    URL url \u003d null;\n    try {\n      url \u003d scClient.use(this.appId, checksum);\n    } catch (YarnException e) {\n      LOG.warn(\"Error trying to contact the shared cache manager,\"\n          + \" disabling the SCMClient for the rest of this job submission\", e);\n      /*\n       * If we fail to contact the SCM, we do not use it for the rest of this\n       * JobResourceUploader\u0027s life. This prevents us from having to timeout\n       * each time we try to upload a file while the SCM is unavailable. Instead\n       * we timeout/error the first time and quickly revert to the default\n       * behavior without the shared cache. We do this by stopping the shared\n       * cache client and setting it to null.\n       */\n      stopSharedCache();\n    }\n\n    if (url !\u003d null) {\n      // Because we deal with URI\u0027s in mapreduce, we need to convert the URL to\n      // a URI and add a fragment if necessary.\n      URI uri \u003d null;\n      try {\n        String name \u003d new Path(url.getFile()).getName();\n        if (rn !\u003d null \u0026\u0026 !name.equals(rn)) {\n          // A name was specified that is different then the URL in the shared\n          // cache. Therefore, we need to set the fragment portion of the URI to\n          // preserve the user\u0027s desired name. We assume that there is no\n          // existing fragment in the URL since the shared cache manager does\n          // not use fragments.\n          uri \u003d new URI(url.getScheme(), url.getUserInfo(), url.getHost(),\n              url.getPort(), url.getFile(), null, rn);\n        } else {\n          uri \u003d new URI(url.getScheme(), url.getUserInfo(), url.getHost(),\n              url.getPort(), url.getFile(), null, null);\n        }\n        return uri;\n      } catch (URISyntaxException e) {\n        LOG.warn(\"Error trying to convert URL received from shared cache to\"\n            + \" a URI: \" + url.toString());\n        return null;\n      }\n    } else {\n      return null;\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapreduce/JobResourceUploader.java"
    }
  }
}