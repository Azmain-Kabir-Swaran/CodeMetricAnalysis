{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "RetryInvocationHandler.java",
  "functionName": "invoke",
  "functionId": "invoke___proxy-Object__method-Method__args-Object[]",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/retry/RetryInvocationHandler.java",
  "functionStartLine": 352,
  "functionEndLine": 367,
  "numCommitsSeen": 45,
  "timeTaken": 4670,
  "changeHistory": [
    "d328e667067743f723e332d92154da8e84e65742",
    "35f255b03b1bb5c94063ec1818af1d253ceee991",
    "5360da8bd9f720384860f411bee081aef13b4bd4",
    "83f2f78c118a7e52aba5104bd97b0acedc96be7b",
    "a9a8297cad4122961b34265c0a31d87134a4a028",
    "d8f390d015510950ccf78174af8891cd613d4438",
    "6144e0137bb51bd04b46ea5ce42c59c2d4f7657d",
    "030fcfa99c345ad57625486eeabedebf2fd4411f",
    "b2ffbd879620ad7650e046b9c797ae81118b452f",
    "cf03bdc3fc9471a5976a27b10f626baba64dbfbf",
    "335f61a72fe0275f46c697ec82ae10ff97231b38",
    "ad61eec0727d55ffcd4fca6f207a4919801bf18b",
    "a6ef93307eda6ff5c8bed5cfd72bb06b037644ce",
    "3be4036abebb46d2f8c76b6929c201844fcbcb65",
    "f4512282505206564d0bcef952be9d9d820621cc",
    "8724ceb2359af66c800043e665c17a2a30981c7d",
    "7ec67c5118e8d13e2cb0ab09d04f0609b645a676",
    "cdc8146bd46ae8bf3395498c529513730d446824",
    "a626fa04f983623b1e2c00189df6f0b83b806b5f",
    "a63e12c4c8b6d637eb6ab04f84de183e8d34bb00",
    "1b4c990b61fa4527e6dd4e8bb7e10f1c11ad280f",
    "9cf3e0805f5967d1ed792c32728ab826fb7c927b",
    "9818091a66b9c8e337de9d4e18655cf4b157056b",
    "d9690b092294db5d6644af5f1a713788f792b55c",
    "14569ab482c2bb79cae31bf12a1e6c8d5f0d6064",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52",
    "637cdaefc294814febb27cbef2f35026053114c7",
    "1191be630ff05c9f1a540b952a8e34665f7fc181",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
    "7efb9640be26aabe3878310e82248a1b6b767a9a",
    "5128a9a453d64bfe1ed978cf9ffed27985eeef36"
  ],
  "changeHistoryShort": {
    "d328e667067743f723e332d92154da8e84e65742": "Ybodychange",
    "35f255b03b1bb5c94063ec1818af1d253ceee991": "Ybodychange",
    "5360da8bd9f720384860f411bee081aef13b4bd4": "Ybodychange",
    "83f2f78c118a7e52aba5104bd97b0acedc96be7b": "Ybodychange",
    "a9a8297cad4122961b34265c0a31d87134a4a028": "Ybodychange",
    "d8f390d015510950ccf78174af8891cd613d4438": "Ybodychange",
    "6144e0137bb51bd04b46ea5ce42c59c2d4f7657d": "Ybodychange",
    "030fcfa99c345ad57625486eeabedebf2fd4411f": "Ybodychange",
    "b2ffbd879620ad7650e046b9c797ae81118b452f": "Ybodychange",
    "cf03bdc3fc9471a5976a27b10f626baba64dbfbf": "Ybodychange",
    "335f61a72fe0275f46c697ec82ae10ff97231b38": "Ybodychange",
    "ad61eec0727d55ffcd4fca6f207a4919801bf18b": "Ybodychange",
    "a6ef93307eda6ff5c8bed5cfd72bb06b037644ce": "Ybodychange",
    "3be4036abebb46d2f8c76b6929c201844fcbcb65": "Ybodychange",
    "f4512282505206564d0bcef952be9d9d820621cc": "Ybodychange",
    "8724ceb2359af66c800043e665c17a2a30981c7d": "Ybodychange",
    "7ec67c5118e8d13e2cb0ab09d04f0609b645a676": "Ybodychange",
    "cdc8146bd46ae8bf3395498c529513730d446824": "Ybodychange",
    "a626fa04f983623b1e2c00189df6f0b83b806b5f": "Ybodychange",
    "a63e12c4c8b6d637eb6ab04f84de183e8d34bb00": "Ybodychange",
    "1b4c990b61fa4527e6dd4e8bb7e10f1c11ad280f": "Ybodychange",
    "9cf3e0805f5967d1ed792c32728ab826fb7c927b": "Ybodychange",
    "9818091a66b9c8e337de9d4e18655cf4b157056b": "Ybodychange",
    "d9690b092294db5d6644af5f1a713788f792b55c": "Ybodychange",
    "14569ab482c2bb79cae31bf12a1e6c8d5f0d6064": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52": "Yfilerename",
    "637cdaefc294814febb27cbef2f35026053114c7": "Ybodychange",
    "1191be630ff05c9f1a540b952a8e34665f7fc181": "Ybodychange",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yfilerename",
    "7efb9640be26aabe3878310e82248a1b6b767a9a": "Ybodychange",
    "5128a9a453d64bfe1ed978cf9ffed27985eeef36": "Yintroduced"
  },
  "changeHistoryDetails": {
    "d328e667067743f723e332d92154da8e84e65742": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13227. AsyncCallHandler should use an event driven architecture to handle async calls.\n",
      "commitDate": "25/06/16 12:45 AM",
      "commitName": "d328e667067743f723e332d92154da8e84e65742",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "commitDateOld": "10/06/16 10:38 AM",
      "commitNameOld": "0bbb4ddd793063c87927035969884a34f60f2076",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 14.59,
      "commitsBetweenForRepo": 130,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,17 +1,16 @@\n   public Object invoke(Object proxy, Method method, Object[] args)\n       throws Throwable {\n     final boolean isRpc \u003d isRpcInvocation(proxyDescriptor.getProxy());\n     final int callId \u003d isRpc? Client.nextCallId(): RpcConstants.INVALID_CALL_ID;\n-    final Counters counters \u003d new Counters();\n \n-    final Call call \u003d newCall(method, args, isRpc, callId, counters);\n+    final Call call \u003d newCall(method, args, isRpc, callId);\n     while (true) {\n       final CallReturn c \u003d call.invokeOnce();\n       final CallReturn.State state \u003d c.getState();\n       if (state \u003d\u003d CallReturn.State.ASYNC_INVOKED) {\n         return null; // return null for async calls\n       } else if (c.getState() !\u003d CallReturn.State.RETRY) {\n         return c.getReturnValue();\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Object invoke(Object proxy, Method method, Object[] args)\n      throws Throwable {\n    final boolean isRpc \u003d isRpcInvocation(proxyDescriptor.getProxy());\n    final int callId \u003d isRpc? Client.nextCallId(): RpcConstants.INVALID_CALL_ID;\n\n    final Call call \u003d newCall(method, args, isRpc, callId);\n    while (true) {\n      final CallReturn c \u003d call.invokeOnce();\n      final CallReturn.State state \u003d c.getState();\n      if (state \u003d\u003d CallReturn.State.ASYNC_INVOKED) {\n        return null; // return null for async calls\n      } else if (c.getState() !\u003d CallReturn.State.RETRY) {\n        return c.getReturnValue();\n      }\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/retry/RetryInvocationHandler.java",
      "extendedDetails": {}
    },
    "35f255b03b1bb5c94063ec1818af1d253ceee991": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"Revert \"HADOOP-13226 Support async call retry and failover.\"\"\n\nThis reverts commit 5360da8bd9f720384860f411bee081aef13b4bd4.\n",
      "commitDate": "06/06/16 1:31 AM",
      "commitName": "35f255b03b1bb5c94063ec1818af1d253ceee991",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "commitDateOld": "03/06/16 6:09 PM",
      "commitNameOld": "5360da8bd9f720384860f411bee081aef13b4bd4",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 2.31,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,6 +1,17 @@\n   public Object invoke(Object proxy, Method method, Object[] args)\n       throws Throwable {\n     final boolean isRpc \u003d isRpcInvocation(proxyDescriptor.getProxy());\n     final int callId \u003d isRpc? Client.nextCallId(): RpcConstants.INVALID_CALL_ID;\n-    return invoke(method, args, isRpc, callId, new Counters());\n+    final Counters counters \u003d new Counters();\n+\n+    final Call call \u003d newCall(method, args, isRpc, callId, counters);\n+    while (true) {\n+      final CallReturn c \u003d call.invokeOnce();\n+      final CallReturn.State state \u003d c.getState();\n+      if (state \u003d\u003d CallReturn.State.ASYNC_INVOKED) {\n+        return null; // return null for async calls\n+      } else if (c.getState() !\u003d CallReturn.State.RETRY) {\n+        return c.getReturnValue();\n+      }\n+    }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Object invoke(Object proxy, Method method, Object[] args)\n      throws Throwable {\n    final boolean isRpc \u003d isRpcInvocation(proxyDescriptor.getProxy());\n    final int callId \u003d isRpc? Client.nextCallId(): RpcConstants.INVALID_CALL_ID;\n    final Counters counters \u003d new Counters();\n\n    final Call call \u003d newCall(method, args, isRpc, callId, counters);\n    while (true) {\n      final CallReturn c \u003d call.invokeOnce();\n      final CallReturn.State state \u003d c.getState();\n      if (state \u003d\u003d CallReturn.State.ASYNC_INVOKED) {\n        return null; // return null for async calls\n      } else if (c.getState() !\u003d CallReturn.State.RETRY) {\n        return c.getReturnValue();\n      }\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/retry/RetryInvocationHandler.java",
      "extendedDetails": {}
    },
    "5360da8bd9f720384860f411bee081aef13b4bd4": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HADOOP-13226 Support async call retry and failover.\"\n\nThis reverts commit 83f2f78c118a7e52aba5104bd97b0acedc96be7b.\n",
      "commitDate": "03/06/16 6:09 PM",
      "commitName": "5360da8bd9f720384860f411bee081aef13b4bd4",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "31/05/16 4:30 PM",
      "commitNameOld": "83f2f78c118a7e52aba5104bd97b0acedc96be7b",
      "commitAuthorOld": "Tsz-Wo Nicholas Sze",
      "daysBetweenCommits": 3.07,
      "commitsBetweenForRepo": 27,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,17 +1,6 @@\n   public Object invoke(Object proxy, Method method, Object[] args)\n       throws Throwable {\n     final boolean isRpc \u003d isRpcInvocation(proxyDescriptor.getProxy());\n     final int callId \u003d isRpc? Client.nextCallId(): RpcConstants.INVALID_CALL_ID;\n-    final Counters counters \u003d new Counters();\n-\n-    final Call call \u003d newCall(method, args, isRpc, callId, counters);\n-    while (true) {\n-      final CallReturn c \u003d call.invokeOnce();\n-      final CallReturn.State state \u003d c.getState();\n-      if (state \u003d\u003d CallReturn.State.ASYNC_INVOKED) {\n-        return null; // return null for async calls\n-      } else if (c.getState() !\u003d CallReturn.State.RETRY) {\n-        return c.getReturnValue();\n-      }\n-    }\n+    return invoke(method, args, isRpc, callId, new Counters());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Object invoke(Object proxy, Method method, Object[] args)\n      throws Throwable {\n    final boolean isRpc \u003d isRpcInvocation(proxyDescriptor.getProxy());\n    final int callId \u003d isRpc? Client.nextCallId(): RpcConstants.INVALID_CALL_ID;\n    return invoke(method, args, isRpc, callId, new Counters());\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/retry/RetryInvocationHandler.java",
      "extendedDetails": {}
    },
    "83f2f78c118a7e52aba5104bd97b0acedc96be7b": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13226 Support async call retry and failover.\n",
      "commitDate": "31/05/16 4:30 PM",
      "commitName": "83f2f78c118a7e52aba5104bd97b0acedc96be7b",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "commitDateOld": "16/05/16 3:23 PM",
      "commitNameOld": "a9a8297cad4122961b34265c0a31d87134a4a028",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 15.05,
      "commitsBetweenForRepo": 112,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,6 +1,17 @@\n   public Object invoke(Object proxy, Method method, Object[] args)\n       throws Throwable {\n     final boolean isRpc \u003d isRpcInvocation(proxyDescriptor.getProxy());\n     final int callId \u003d isRpc? Client.nextCallId(): RpcConstants.INVALID_CALL_ID;\n-    return invoke(method, args, isRpc, callId, new Counters());\n+    final Counters counters \u003d new Counters();\n+\n+    final Call call \u003d newCall(method, args, isRpc, callId, counters);\n+    while (true) {\n+      final CallReturn c \u003d call.invokeOnce();\n+      final CallReturn.State state \u003d c.getState();\n+      if (state \u003d\u003d CallReturn.State.ASYNC_INVOKED) {\n+        return null; // return null for async calls\n+      } else if (c.getState() !\u003d CallReturn.State.RETRY) {\n+        return c.getReturnValue();\n+      }\n+    }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Object invoke(Object proxy, Method method, Object[] args)\n      throws Throwable {\n    final boolean isRpc \u003d isRpcInvocation(proxyDescriptor.getProxy());\n    final int callId \u003d isRpc? Client.nextCallId(): RpcConstants.INVALID_CALL_ID;\n    final Counters counters \u003d new Counters();\n\n    final Call call \u003d newCall(method, args, isRpc, callId, counters);\n    while (true) {\n      final CallReturn c \u003d call.invokeOnce();\n      final CallReturn.State state \u003d c.getState();\n      if (state \u003d\u003d CallReturn.State.ASYNC_INVOKED) {\n        return null; // return null for async calls\n      } else if (c.getState() !\u003d CallReturn.State.RETRY) {\n        return c.getReturnValue();\n      }\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/retry/RetryInvocationHandler.java",
      "extendedDetails": {}
    },
    "a9a8297cad4122961b34265c0a31d87134a4a028": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13146. Refactor RetryInvocationHandler. Contributed by Tsz Wo Nicholas Sze.\n",
      "commitDate": "16/05/16 3:23 PM",
      "commitName": "a9a8297cad4122961b34265c0a31d87134a4a028",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "29/02/16 4:24 PM",
      "commitNameOld": "d8f390d015510950ccf78174af8891cd613d4438",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 76.92,
      "commitsBetweenForRepo": 456,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,104 +1,6 @@\n   public Object invoke(Object proxy, Method method, Object[] args)\n-    throws Throwable {\n-    RetryPolicy policy \u003d methodNameToPolicyMap.get(method.getName());\n-    if (policy \u003d\u003d null) {\n-      policy \u003d defaultPolicy;\n-    }\n-    \n-    // The number of times this method invocation has been failed over.\n-    int invocationFailoverCount \u003d 0;\n-    final boolean isRpc \u003d isRpcInvocation(currentProxy.proxy);\n+      throws Throwable {\n+    final boolean isRpc \u003d isRpcInvocation(proxyDescriptor.getProxy());\n     final int callId \u003d isRpc? Client.nextCallId(): RpcConstants.INVALID_CALL_ID;\n-    int retries \u003d 0;\n-    while (true) {\n-      // The number of times this invocation handler has ever been failed over,\n-      // before this method invocation attempt. Used to prevent concurrent\n-      // failed method invocations from triggering multiple failover attempts.\n-      long invocationAttemptFailoverCount;\n-      synchronized (proxyProvider) {\n-        invocationAttemptFailoverCount \u003d proxyProviderFailoverCount;\n-      }\n-\n-      if (isRpc) {\n-        Client.setCallIdAndRetryCount(callId, retries);\n-      }\n-      try {\n-        Object ret \u003d invokeMethod(method, args);\n-        hasMadeASuccessfulCall \u003d true;\n-        return ret;\n-      } catch (Exception ex) {\n-        if (Thread.currentThread().isInterrupted()) {\n-          // If interrupted, do not retry.\n-          throw ex;\n-        }\n-        boolean isIdempotentOrAtMostOnce \u003d proxyProvider.getInterface()\n-            .getMethod(method.getName(), method.getParameterTypes())\n-            .isAnnotationPresent(Idempotent.class);\n-        if (!isIdempotentOrAtMostOnce) {\n-          isIdempotentOrAtMostOnce \u003d proxyProvider.getInterface()\n-              .getMethod(method.getName(), method.getParameterTypes())\n-              .isAnnotationPresent(AtMostOnce.class);\n-        }\n-        List\u003cRetryAction\u003e actions \u003d extractActions(policy, ex, retries++,\n-                invocationFailoverCount, isIdempotentOrAtMostOnce);\n-        RetryAction failAction \u003d getFailAction(actions);\n-        if (failAction !\u003d null) {\n-          // fail.\n-          if (failAction.reason !\u003d null) {\n-            LOG.warn(\"Exception while invoking \" + currentProxy.proxy.getClass()\n-                + \".\" + method.getName() + \" over \" + currentProxy.proxyInfo\n-                + \". Not retrying because \" + failAction.reason, ex);\n-          }\n-          throw ex;\n-        } else { // retry or failover\n-          // avoid logging the failover if this is the first call on this\n-          // proxy object, and we successfully achieve the failover without\n-          // any flip-flopping\n-          boolean worthLogging \u003d \n-            !(invocationFailoverCount \u003d\u003d 0 \u0026\u0026 !hasMadeASuccessfulCall);\n-          worthLogging |\u003d LOG.isDebugEnabled();\n-          RetryAction failOverAction \u003d getFailOverAction(actions);\n-          long delay \u003d getDelayMillis(actions);\n-\n-          if (worthLogging) {\n-            String msg \u003d \"Exception while invoking \" + method.getName()\n-                + \" of class \" + currentProxy.proxy.getClass().getSimpleName()\n-                + \" over \" + currentProxy.proxyInfo;\n-\n-            if (invocationFailoverCount \u003e 0) {\n-              msg +\u003d \" after \" + invocationFailoverCount + \" fail over attempts\"; \n-            }\n-\n-            if (failOverAction !\u003d null) {\n-              // failover\n-              msg +\u003d \". Trying to fail over \" + formatSleepMessage(delay);\n-            } else {\n-              // retry\n-              msg +\u003d \". Retrying \" + formatSleepMessage(delay);\n-            }\n-            LOG.info(msg, ex);\n-          }\n-\n-          if (delay \u003e 0) {\n-            Thread.sleep(delay);\n-          }\n-\n-          if (failOverAction !\u003d null) {\n-            // Make sure that concurrent failed method invocations only cause a\n-            // single actual fail over.\n-            synchronized (proxyProvider) {\n-              if (invocationAttemptFailoverCount \u003d\u003d proxyProviderFailoverCount) {\n-                proxyProvider.performFailover(currentProxy.proxy);\n-                proxyProviderFailoverCount++;\n-              } else {\n-                LOG.warn(\"A failover has occurred since the start of this method\"\n-                    + \" invocation attempt.\");\n-              }\n-              currentProxy \u003d proxyProvider.getProxy();\n-            }\n-            invocationFailoverCount++;\n-          }\n-        }\n-      }\n-    }\n+    return invoke(method, args, isRpc, callId, new Counters());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Object invoke(Object proxy, Method method, Object[] args)\n      throws Throwable {\n    final boolean isRpc \u003d isRpcInvocation(proxyDescriptor.getProxy());\n    final int callId \u003d isRpc? Client.nextCallId(): RpcConstants.INVALID_CALL_ID;\n    return invoke(method, args, isRpc, callId, new Counters());\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/retry/RetryInvocationHandler.java",
      "extendedDetails": {}
    },
    "d8f390d015510950ccf78174af8891cd613d4438": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-12622. Improve the loggings in RetryPolicies and RetryInvocationHandler. Contributed by Junping Du\n",
      "commitDate": "29/02/16 4:24 PM",
      "commitName": "d8f390d015510950ccf78174af8891cd613d4438",
      "commitAuthor": "Jian He",
      "commitDateOld": "19/10/15 8:52 AM",
      "commitNameOld": "6144e0137bb51bd04b46ea5ce42c59c2d4f7657d",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 133.36,
      "commitsBetweenForRepo": 910,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,102 +1,104 @@\n   public Object invoke(Object proxy, Method method, Object[] args)\n     throws Throwable {\n     RetryPolicy policy \u003d methodNameToPolicyMap.get(method.getName());\n     if (policy \u003d\u003d null) {\n       policy \u003d defaultPolicy;\n     }\n     \n     // The number of times this method invocation has been failed over.\n     int invocationFailoverCount \u003d 0;\n     final boolean isRpc \u003d isRpcInvocation(currentProxy.proxy);\n     final int callId \u003d isRpc? Client.nextCallId(): RpcConstants.INVALID_CALL_ID;\n     int retries \u003d 0;\n     while (true) {\n       // The number of times this invocation handler has ever been failed over,\n       // before this method invocation attempt. Used to prevent concurrent\n       // failed method invocations from triggering multiple failover attempts.\n       long invocationAttemptFailoverCount;\n       synchronized (proxyProvider) {\n         invocationAttemptFailoverCount \u003d proxyProviderFailoverCount;\n       }\n \n       if (isRpc) {\n         Client.setCallIdAndRetryCount(callId, retries);\n       }\n       try {\n         Object ret \u003d invokeMethod(method, args);\n         hasMadeASuccessfulCall \u003d true;\n         return ret;\n       } catch (Exception ex) {\n         if (Thread.currentThread().isInterrupted()) {\n           // If interrupted, do not retry.\n           throw ex;\n         }\n         boolean isIdempotentOrAtMostOnce \u003d proxyProvider.getInterface()\n             .getMethod(method.getName(), method.getParameterTypes())\n             .isAnnotationPresent(Idempotent.class);\n         if (!isIdempotentOrAtMostOnce) {\n           isIdempotentOrAtMostOnce \u003d proxyProvider.getInterface()\n               .getMethod(method.getName(), method.getParameterTypes())\n               .isAnnotationPresent(AtMostOnce.class);\n         }\n         List\u003cRetryAction\u003e actions \u003d extractActions(policy, ex, retries++,\n                 invocationFailoverCount, isIdempotentOrAtMostOnce);\n         RetryAction failAction \u003d getFailAction(actions);\n         if (failAction !\u003d null) {\n+          // fail.\n           if (failAction.reason !\u003d null) {\n             LOG.warn(\"Exception while invoking \" + currentProxy.proxy.getClass()\n                 + \".\" + method.getName() + \" over \" + currentProxy.proxyInfo\n                 + \". Not retrying because \" + failAction.reason, ex);\n           }\n           throw ex;\n         } else { // retry or failover\n           // avoid logging the failover if this is the first call on this\n           // proxy object, and we successfully achieve the failover without\n           // any flip-flopping\n           boolean worthLogging \u003d \n             !(invocationFailoverCount \u003d\u003d 0 \u0026\u0026 !hasMadeASuccessfulCall);\n           worthLogging |\u003d LOG.isDebugEnabled();\n           RetryAction failOverAction \u003d getFailOverAction(actions);\n           long delay \u003d getDelayMillis(actions);\n-          if (failOverAction !\u003d null \u0026\u0026 worthLogging) {\n+\n+          if (worthLogging) {\n             String msg \u003d \"Exception while invoking \" + method.getName()\n                 + \" of class \" + currentProxy.proxy.getClass().getSimpleName()\n                 + \" over \" + currentProxy.proxyInfo;\n \n             if (invocationFailoverCount \u003e 0) {\n               msg +\u003d \" after \" + invocationFailoverCount + \" fail over attempts\"; \n             }\n-            msg +\u003d \". Trying to fail over \" + formatSleepMessage(delay);\n-            LOG.info(msg, ex);\n-          } else {\n-            if(LOG.isDebugEnabled()) {\n-              LOG.debug(\"Exception while invoking \" + method.getName()\n-                  + \" of class \" + currentProxy.proxy.getClass().getSimpleName()\n-                  + \" over \" + currentProxy.proxyInfo + \". Retrying \"\n-                  + formatSleepMessage(delay), ex);\n+\n+            if (failOverAction !\u003d null) {\n+              // failover\n+              msg +\u003d \". Trying to fail over \" + formatSleepMessage(delay);\n+            } else {\n+              // retry\n+              msg +\u003d \". Retrying \" + formatSleepMessage(delay);\n             }\n+            LOG.info(msg, ex);\n           }\n \n           if (delay \u003e 0) {\n             Thread.sleep(delay);\n           }\n-          \n+\n           if (failOverAction !\u003d null) {\n             // Make sure that concurrent failed method invocations only cause a\n             // single actual fail over.\n             synchronized (proxyProvider) {\n               if (invocationAttemptFailoverCount \u003d\u003d proxyProviderFailoverCount) {\n                 proxyProvider.performFailover(currentProxy.proxy);\n                 proxyProviderFailoverCount++;\n               } else {\n                 LOG.warn(\"A failover has occurred since the start of this method\"\n                     + \" invocation attempt.\");\n               }\n               currentProxy \u003d proxyProvider.getProxy();\n             }\n             invocationFailoverCount++;\n           }\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Object invoke(Object proxy, Method method, Object[] args)\n    throws Throwable {\n    RetryPolicy policy \u003d methodNameToPolicyMap.get(method.getName());\n    if (policy \u003d\u003d null) {\n      policy \u003d defaultPolicy;\n    }\n    \n    // The number of times this method invocation has been failed over.\n    int invocationFailoverCount \u003d 0;\n    final boolean isRpc \u003d isRpcInvocation(currentProxy.proxy);\n    final int callId \u003d isRpc? Client.nextCallId(): RpcConstants.INVALID_CALL_ID;\n    int retries \u003d 0;\n    while (true) {\n      // The number of times this invocation handler has ever been failed over,\n      // before this method invocation attempt. Used to prevent concurrent\n      // failed method invocations from triggering multiple failover attempts.\n      long invocationAttemptFailoverCount;\n      synchronized (proxyProvider) {\n        invocationAttemptFailoverCount \u003d proxyProviderFailoverCount;\n      }\n\n      if (isRpc) {\n        Client.setCallIdAndRetryCount(callId, retries);\n      }\n      try {\n        Object ret \u003d invokeMethod(method, args);\n        hasMadeASuccessfulCall \u003d true;\n        return ret;\n      } catch (Exception ex) {\n        if (Thread.currentThread().isInterrupted()) {\n          // If interrupted, do not retry.\n          throw ex;\n        }\n        boolean isIdempotentOrAtMostOnce \u003d proxyProvider.getInterface()\n            .getMethod(method.getName(), method.getParameterTypes())\n            .isAnnotationPresent(Idempotent.class);\n        if (!isIdempotentOrAtMostOnce) {\n          isIdempotentOrAtMostOnce \u003d proxyProvider.getInterface()\n              .getMethod(method.getName(), method.getParameterTypes())\n              .isAnnotationPresent(AtMostOnce.class);\n        }\n        List\u003cRetryAction\u003e actions \u003d extractActions(policy, ex, retries++,\n                invocationFailoverCount, isIdempotentOrAtMostOnce);\n        RetryAction failAction \u003d getFailAction(actions);\n        if (failAction !\u003d null) {\n          // fail.\n          if (failAction.reason !\u003d null) {\n            LOG.warn(\"Exception while invoking \" + currentProxy.proxy.getClass()\n                + \".\" + method.getName() + \" over \" + currentProxy.proxyInfo\n                + \". Not retrying because \" + failAction.reason, ex);\n          }\n          throw ex;\n        } else { // retry or failover\n          // avoid logging the failover if this is the first call on this\n          // proxy object, and we successfully achieve the failover without\n          // any flip-flopping\n          boolean worthLogging \u003d \n            !(invocationFailoverCount \u003d\u003d 0 \u0026\u0026 !hasMadeASuccessfulCall);\n          worthLogging |\u003d LOG.isDebugEnabled();\n          RetryAction failOverAction \u003d getFailOverAction(actions);\n          long delay \u003d getDelayMillis(actions);\n\n          if (worthLogging) {\n            String msg \u003d \"Exception while invoking \" + method.getName()\n                + \" of class \" + currentProxy.proxy.getClass().getSimpleName()\n                + \" over \" + currentProxy.proxyInfo;\n\n            if (invocationFailoverCount \u003e 0) {\n              msg +\u003d \" after \" + invocationFailoverCount + \" fail over attempts\"; \n            }\n\n            if (failOverAction !\u003d null) {\n              // failover\n              msg +\u003d \". Trying to fail over \" + formatSleepMessage(delay);\n            } else {\n              // retry\n              msg +\u003d \". Retrying \" + formatSleepMessage(delay);\n            }\n            LOG.info(msg, ex);\n          }\n\n          if (delay \u003e 0) {\n            Thread.sleep(delay);\n          }\n\n          if (failOverAction !\u003d null) {\n            // Make sure that concurrent failed method invocations only cause a\n            // single actual fail over.\n            synchronized (proxyProvider) {\n              if (invocationAttemptFailoverCount \u003d\u003d proxyProviderFailoverCount) {\n                proxyProvider.performFailover(currentProxy.proxy);\n                proxyProviderFailoverCount++;\n              } else {\n                LOG.warn(\"A failover has occurred since the start of this method\"\n                    + \" invocation attempt.\");\n              }\n              currentProxy \u003d proxyProvider.getProxy();\n            }\n            invocationFailoverCount++;\n          }\n        }\n      }\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/retry/RetryInvocationHandler.java",
      "extendedDetails": {}
    },
    "6144e0137bb51bd04b46ea5ce42c59c2d4f7657d": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-12464. Interrupted client may try to fail-over and retry. Contributed by Kihwal Lee.\n",
      "commitDate": "19/10/15 8:52 AM",
      "commitName": "6144e0137bb51bd04b46ea5ce42c59c2d4f7657d",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "27/07/15 11:02 PM",
      "commitNameOld": "030fcfa99c345ad57625486eeabedebf2fd4411f",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 83.41,
      "commitsBetweenForRepo": 542,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,98 +1,102 @@\n   public Object invoke(Object proxy, Method method, Object[] args)\n     throws Throwable {\n     RetryPolicy policy \u003d methodNameToPolicyMap.get(method.getName());\n     if (policy \u003d\u003d null) {\n       policy \u003d defaultPolicy;\n     }\n     \n     // The number of times this method invocation has been failed over.\n     int invocationFailoverCount \u003d 0;\n     final boolean isRpc \u003d isRpcInvocation(currentProxy.proxy);\n     final int callId \u003d isRpc? Client.nextCallId(): RpcConstants.INVALID_CALL_ID;\n     int retries \u003d 0;\n     while (true) {\n       // The number of times this invocation handler has ever been failed over,\n       // before this method invocation attempt. Used to prevent concurrent\n       // failed method invocations from triggering multiple failover attempts.\n       long invocationAttemptFailoverCount;\n       synchronized (proxyProvider) {\n         invocationAttemptFailoverCount \u003d proxyProviderFailoverCount;\n       }\n \n       if (isRpc) {\n         Client.setCallIdAndRetryCount(callId, retries);\n       }\n       try {\n         Object ret \u003d invokeMethod(method, args);\n         hasMadeASuccessfulCall \u003d true;\n         return ret;\n       } catch (Exception ex) {\n+        if (Thread.currentThread().isInterrupted()) {\n+          // If interrupted, do not retry.\n+          throw ex;\n+        }\n         boolean isIdempotentOrAtMostOnce \u003d proxyProvider.getInterface()\n             .getMethod(method.getName(), method.getParameterTypes())\n             .isAnnotationPresent(Idempotent.class);\n         if (!isIdempotentOrAtMostOnce) {\n           isIdempotentOrAtMostOnce \u003d proxyProvider.getInterface()\n               .getMethod(method.getName(), method.getParameterTypes())\n               .isAnnotationPresent(AtMostOnce.class);\n         }\n         List\u003cRetryAction\u003e actions \u003d extractActions(policy, ex, retries++,\n                 invocationFailoverCount, isIdempotentOrAtMostOnce);\n         RetryAction failAction \u003d getFailAction(actions);\n         if (failAction !\u003d null) {\n           if (failAction.reason !\u003d null) {\n             LOG.warn(\"Exception while invoking \" + currentProxy.proxy.getClass()\n                 + \".\" + method.getName() + \" over \" + currentProxy.proxyInfo\n                 + \". Not retrying because \" + failAction.reason, ex);\n           }\n           throw ex;\n         } else { // retry or failover\n           // avoid logging the failover if this is the first call on this\n           // proxy object, and we successfully achieve the failover without\n           // any flip-flopping\n           boolean worthLogging \u003d \n             !(invocationFailoverCount \u003d\u003d 0 \u0026\u0026 !hasMadeASuccessfulCall);\n           worthLogging |\u003d LOG.isDebugEnabled();\n           RetryAction failOverAction \u003d getFailOverAction(actions);\n           long delay \u003d getDelayMillis(actions);\n           if (failOverAction !\u003d null \u0026\u0026 worthLogging) {\n             String msg \u003d \"Exception while invoking \" + method.getName()\n                 + \" of class \" + currentProxy.proxy.getClass().getSimpleName()\n                 + \" over \" + currentProxy.proxyInfo;\n \n             if (invocationFailoverCount \u003e 0) {\n               msg +\u003d \" after \" + invocationFailoverCount + \" fail over attempts\"; \n             }\n             msg +\u003d \". Trying to fail over \" + formatSleepMessage(delay);\n             LOG.info(msg, ex);\n           } else {\n             if(LOG.isDebugEnabled()) {\n               LOG.debug(\"Exception while invoking \" + method.getName()\n                   + \" of class \" + currentProxy.proxy.getClass().getSimpleName()\n                   + \" over \" + currentProxy.proxyInfo + \". Retrying \"\n                   + formatSleepMessage(delay), ex);\n             }\n           }\n \n           if (delay \u003e 0) {\n             Thread.sleep(delay);\n           }\n           \n           if (failOverAction !\u003d null) {\n             // Make sure that concurrent failed method invocations only cause a\n             // single actual fail over.\n             synchronized (proxyProvider) {\n               if (invocationAttemptFailoverCount \u003d\u003d proxyProviderFailoverCount) {\n                 proxyProvider.performFailover(currentProxy.proxy);\n                 proxyProviderFailoverCount++;\n               } else {\n                 LOG.warn(\"A failover has occurred since the start of this method\"\n                     + \" invocation attempt.\");\n               }\n               currentProxy \u003d proxyProvider.getProxy();\n             }\n             invocationFailoverCount++;\n           }\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Object invoke(Object proxy, Method method, Object[] args)\n    throws Throwable {\n    RetryPolicy policy \u003d methodNameToPolicyMap.get(method.getName());\n    if (policy \u003d\u003d null) {\n      policy \u003d defaultPolicy;\n    }\n    \n    // The number of times this method invocation has been failed over.\n    int invocationFailoverCount \u003d 0;\n    final boolean isRpc \u003d isRpcInvocation(currentProxy.proxy);\n    final int callId \u003d isRpc? Client.nextCallId(): RpcConstants.INVALID_CALL_ID;\n    int retries \u003d 0;\n    while (true) {\n      // The number of times this invocation handler has ever been failed over,\n      // before this method invocation attempt. Used to prevent concurrent\n      // failed method invocations from triggering multiple failover attempts.\n      long invocationAttemptFailoverCount;\n      synchronized (proxyProvider) {\n        invocationAttemptFailoverCount \u003d proxyProviderFailoverCount;\n      }\n\n      if (isRpc) {\n        Client.setCallIdAndRetryCount(callId, retries);\n      }\n      try {\n        Object ret \u003d invokeMethod(method, args);\n        hasMadeASuccessfulCall \u003d true;\n        return ret;\n      } catch (Exception ex) {\n        if (Thread.currentThread().isInterrupted()) {\n          // If interrupted, do not retry.\n          throw ex;\n        }\n        boolean isIdempotentOrAtMostOnce \u003d proxyProvider.getInterface()\n            .getMethod(method.getName(), method.getParameterTypes())\n            .isAnnotationPresent(Idempotent.class);\n        if (!isIdempotentOrAtMostOnce) {\n          isIdempotentOrAtMostOnce \u003d proxyProvider.getInterface()\n              .getMethod(method.getName(), method.getParameterTypes())\n              .isAnnotationPresent(AtMostOnce.class);\n        }\n        List\u003cRetryAction\u003e actions \u003d extractActions(policy, ex, retries++,\n                invocationFailoverCount, isIdempotentOrAtMostOnce);\n        RetryAction failAction \u003d getFailAction(actions);\n        if (failAction !\u003d null) {\n          if (failAction.reason !\u003d null) {\n            LOG.warn(\"Exception while invoking \" + currentProxy.proxy.getClass()\n                + \".\" + method.getName() + \" over \" + currentProxy.proxyInfo\n                + \". Not retrying because \" + failAction.reason, ex);\n          }\n          throw ex;\n        } else { // retry or failover\n          // avoid logging the failover if this is the first call on this\n          // proxy object, and we successfully achieve the failover without\n          // any flip-flopping\n          boolean worthLogging \u003d \n            !(invocationFailoverCount \u003d\u003d 0 \u0026\u0026 !hasMadeASuccessfulCall);\n          worthLogging |\u003d LOG.isDebugEnabled();\n          RetryAction failOverAction \u003d getFailOverAction(actions);\n          long delay \u003d getDelayMillis(actions);\n          if (failOverAction !\u003d null \u0026\u0026 worthLogging) {\n            String msg \u003d \"Exception while invoking \" + method.getName()\n                + \" of class \" + currentProxy.proxy.getClass().getSimpleName()\n                + \" over \" + currentProxy.proxyInfo;\n\n            if (invocationFailoverCount \u003e 0) {\n              msg +\u003d \" after \" + invocationFailoverCount + \" fail over attempts\"; \n            }\n            msg +\u003d \". Trying to fail over \" + formatSleepMessage(delay);\n            LOG.info(msg, ex);\n          } else {\n            if(LOG.isDebugEnabled()) {\n              LOG.debug(\"Exception while invoking \" + method.getName()\n                  + \" of class \" + currentProxy.proxy.getClass().getSimpleName()\n                  + \" over \" + currentProxy.proxyInfo + \". Retrying \"\n                  + formatSleepMessage(delay), ex);\n            }\n          }\n\n          if (delay \u003e 0) {\n            Thread.sleep(delay);\n          }\n          \n          if (failOverAction !\u003d null) {\n            // Make sure that concurrent failed method invocations only cause a\n            // single actual fail over.\n            synchronized (proxyProvider) {\n              if (invocationAttemptFailoverCount \u003d\u003d proxyProviderFailoverCount) {\n                proxyProvider.performFailover(currentProxy.proxy);\n                proxyProviderFailoverCount++;\n              } else {\n                LOG.warn(\"A failover has occurred since the start of this method\"\n                    + \" invocation attempt.\");\n              }\n              currentProxy \u003d proxyProvider.getProxy();\n            }\n            invocationFailoverCount++;\n          }\n        }\n      }\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/retry/RetryInvocationHandler.java",
      "extendedDetails": {}
    },
    "030fcfa99c345ad57625486eeabedebf2fd4411f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7858. Improve HA Namenode Failover detection on the client. (asuresh)\n",
      "commitDate": "27/07/15 11:02 PM",
      "commitName": "030fcfa99c345ad57625486eeabedebf2fd4411f",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "16/06/14 10:51 AM",
      "commitNameOld": "b2ffbd879620ad7650e046b9c797ae81118b452f",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 406.51,
      "commitsBetweenForRepo": 3450,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,96 +1,98 @@\n   public Object invoke(Object proxy, Method method, Object[] args)\n     throws Throwable {\n     RetryPolicy policy \u003d methodNameToPolicyMap.get(method.getName());\n     if (policy \u003d\u003d null) {\n       policy \u003d defaultPolicy;\n     }\n     \n     // The number of times this method invocation has been failed over.\n     int invocationFailoverCount \u003d 0;\n     final boolean isRpc \u003d isRpcInvocation(currentProxy.proxy);\n     final int callId \u003d isRpc? Client.nextCallId(): RpcConstants.INVALID_CALL_ID;\n     int retries \u003d 0;\n     while (true) {\n       // The number of times this invocation handler has ever been failed over,\n       // before this method invocation attempt. Used to prevent concurrent\n       // failed method invocations from triggering multiple failover attempts.\n       long invocationAttemptFailoverCount;\n       synchronized (proxyProvider) {\n         invocationAttemptFailoverCount \u003d proxyProviderFailoverCount;\n       }\n \n       if (isRpc) {\n         Client.setCallIdAndRetryCount(callId, retries);\n       }\n       try {\n         Object ret \u003d invokeMethod(method, args);\n         hasMadeASuccessfulCall \u003d true;\n         return ret;\n-      } catch (Exception e) {\n+      } catch (Exception ex) {\n         boolean isIdempotentOrAtMostOnce \u003d proxyProvider.getInterface()\n             .getMethod(method.getName(), method.getParameterTypes())\n             .isAnnotationPresent(Idempotent.class);\n         if (!isIdempotentOrAtMostOnce) {\n           isIdempotentOrAtMostOnce \u003d proxyProvider.getInterface()\n               .getMethod(method.getName(), method.getParameterTypes())\n               .isAnnotationPresent(AtMostOnce.class);\n         }\n-        RetryAction action \u003d policy.shouldRetry(e, retries++,\n-            invocationFailoverCount, isIdempotentOrAtMostOnce);\n-        if (action.action \u003d\u003d RetryAction.RetryDecision.FAIL) {\n-          if (action.reason !\u003d null) {\n+        List\u003cRetryAction\u003e actions \u003d extractActions(policy, ex, retries++,\n+                invocationFailoverCount, isIdempotentOrAtMostOnce);\n+        RetryAction failAction \u003d getFailAction(actions);\n+        if (failAction !\u003d null) {\n+          if (failAction.reason !\u003d null) {\n             LOG.warn(\"Exception while invoking \" + currentProxy.proxy.getClass()\n                 + \".\" + method.getName() + \" over \" + currentProxy.proxyInfo\n-                + \". Not retrying because \" + action.reason, e);\n+                + \". Not retrying because \" + failAction.reason, ex);\n           }\n-          throw e;\n+          throw ex;\n         } else { // retry or failover\n           // avoid logging the failover if this is the first call on this\n           // proxy object, and we successfully achieve the failover without\n           // any flip-flopping\n           boolean worthLogging \u003d \n             !(invocationFailoverCount \u003d\u003d 0 \u0026\u0026 !hasMadeASuccessfulCall);\n           worthLogging |\u003d LOG.isDebugEnabled();\n-          if (action.action \u003d\u003d RetryAction.RetryDecision.FAILOVER_AND_RETRY \u0026\u0026\n-              worthLogging) {\n+          RetryAction failOverAction \u003d getFailOverAction(actions);\n+          long delay \u003d getDelayMillis(actions);\n+          if (failOverAction !\u003d null \u0026\u0026 worthLogging) {\n             String msg \u003d \"Exception while invoking \" + method.getName()\n                 + \" of class \" + currentProxy.proxy.getClass().getSimpleName()\n                 + \" over \" + currentProxy.proxyInfo;\n \n             if (invocationFailoverCount \u003e 0) {\n               msg +\u003d \" after \" + invocationFailoverCount + \" fail over attempts\"; \n             }\n-            msg +\u003d \". Trying to fail over \" + formatSleepMessage(action.delayMillis);\n-            LOG.info(msg, e);\n+            msg +\u003d \". Trying to fail over \" + formatSleepMessage(delay);\n+            LOG.info(msg, ex);\n           } else {\n             if(LOG.isDebugEnabled()) {\n               LOG.debug(\"Exception while invoking \" + method.getName()\n                   + \" of class \" + currentProxy.proxy.getClass().getSimpleName()\n                   + \" over \" + currentProxy.proxyInfo + \". Retrying \"\n-                  + formatSleepMessage(action.delayMillis), e);\n+                  + formatSleepMessage(delay), ex);\n             }\n           }\n-          \n-          if (action.delayMillis \u003e 0) {\n-            Thread.sleep(action.delayMillis);\n+\n+          if (delay \u003e 0) {\n+            Thread.sleep(delay);\n           }\n           \n-          if (action.action \u003d\u003d RetryAction.RetryDecision.FAILOVER_AND_RETRY) {\n+          if (failOverAction !\u003d null) {\n             // Make sure that concurrent failed method invocations only cause a\n             // single actual fail over.\n             synchronized (proxyProvider) {\n               if (invocationAttemptFailoverCount \u003d\u003d proxyProviderFailoverCount) {\n                 proxyProvider.performFailover(currentProxy.proxy);\n                 proxyProviderFailoverCount++;\n               } else {\n                 LOG.warn(\"A failover has occurred since the start of this method\"\n                     + \" invocation attempt.\");\n               }\n               currentProxy \u003d proxyProvider.getProxy();\n             }\n             invocationFailoverCount++;\n           }\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Object invoke(Object proxy, Method method, Object[] args)\n    throws Throwable {\n    RetryPolicy policy \u003d methodNameToPolicyMap.get(method.getName());\n    if (policy \u003d\u003d null) {\n      policy \u003d defaultPolicy;\n    }\n    \n    // The number of times this method invocation has been failed over.\n    int invocationFailoverCount \u003d 0;\n    final boolean isRpc \u003d isRpcInvocation(currentProxy.proxy);\n    final int callId \u003d isRpc? Client.nextCallId(): RpcConstants.INVALID_CALL_ID;\n    int retries \u003d 0;\n    while (true) {\n      // The number of times this invocation handler has ever been failed over,\n      // before this method invocation attempt. Used to prevent concurrent\n      // failed method invocations from triggering multiple failover attempts.\n      long invocationAttemptFailoverCount;\n      synchronized (proxyProvider) {\n        invocationAttemptFailoverCount \u003d proxyProviderFailoverCount;\n      }\n\n      if (isRpc) {\n        Client.setCallIdAndRetryCount(callId, retries);\n      }\n      try {\n        Object ret \u003d invokeMethod(method, args);\n        hasMadeASuccessfulCall \u003d true;\n        return ret;\n      } catch (Exception ex) {\n        boolean isIdempotentOrAtMostOnce \u003d proxyProvider.getInterface()\n            .getMethod(method.getName(), method.getParameterTypes())\n            .isAnnotationPresent(Idempotent.class);\n        if (!isIdempotentOrAtMostOnce) {\n          isIdempotentOrAtMostOnce \u003d proxyProvider.getInterface()\n              .getMethod(method.getName(), method.getParameterTypes())\n              .isAnnotationPresent(AtMostOnce.class);\n        }\n        List\u003cRetryAction\u003e actions \u003d extractActions(policy, ex, retries++,\n                invocationFailoverCount, isIdempotentOrAtMostOnce);\n        RetryAction failAction \u003d getFailAction(actions);\n        if (failAction !\u003d null) {\n          if (failAction.reason !\u003d null) {\n            LOG.warn(\"Exception while invoking \" + currentProxy.proxy.getClass()\n                + \".\" + method.getName() + \" over \" + currentProxy.proxyInfo\n                + \". Not retrying because \" + failAction.reason, ex);\n          }\n          throw ex;\n        } else { // retry or failover\n          // avoid logging the failover if this is the first call on this\n          // proxy object, and we successfully achieve the failover without\n          // any flip-flopping\n          boolean worthLogging \u003d \n            !(invocationFailoverCount \u003d\u003d 0 \u0026\u0026 !hasMadeASuccessfulCall);\n          worthLogging |\u003d LOG.isDebugEnabled();\n          RetryAction failOverAction \u003d getFailOverAction(actions);\n          long delay \u003d getDelayMillis(actions);\n          if (failOverAction !\u003d null \u0026\u0026 worthLogging) {\n            String msg \u003d \"Exception while invoking \" + method.getName()\n                + \" of class \" + currentProxy.proxy.getClass().getSimpleName()\n                + \" over \" + currentProxy.proxyInfo;\n\n            if (invocationFailoverCount \u003e 0) {\n              msg +\u003d \" after \" + invocationFailoverCount + \" fail over attempts\"; \n            }\n            msg +\u003d \". Trying to fail over \" + formatSleepMessage(delay);\n            LOG.info(msg, ex);\n          } else {\n            if(LOG.isDebugEnabled()) {\n              LOG.debug(\"Exception while invoking \" + method.getName()\n                  + \" of class \" + currentProxy.proxy.getClass().getSimpleName()\n                  + \" over \" + currentProxy.proxyInfo + \". Retrying \"\n                  + formatSleepMessage(delay), ex);\n            }\n          }\n\n          if (delay \u003e 0) {\n            Thread.sleep(delay);\n          }\n          \n          if (failOverAction !\u003d null) {\n            // Make sure that concurrent failed method invocations only cause a\n            // single actual fail over.\n            synchronized (proxyProvider) {\n              if (invocationAttemptFailoverCount \u003d\u003d proxyProviderFailoverCount) {\n                proxyProvider.performFailover(currentProxy.proxy);\n                proxyProviderFailoverCount++;\n              } else {\n                LOG.warn(\"A failover has occurred since the start of this method\"\n                    + \" invocation attempt.\");\n              }\n              currentProxy \u003d proxyProvider.getProxy();\n            }\n            invocationFailoverCount++;\n          }\n        }\n      }\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/retry/RetryInvocationHandler.java",
      "extendedDetails": {}
    },
    "b2ffbd879620ad7650e046b9c797ae81118b452f": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10657. Have RetryInvocationHandler log failover attempt at INFO level. Contributed by Ming Ma.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1602941 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/06/14 10:51 AM",
      "commitName": "b2ffbd879620ad7650e046b9c797ae81118b452f",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "02/06/14 2:33 PM",
      "commitNameOld": "cf03bdc3fc9471a5976a27b10f626baba64dbfbf",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 13.85,
      "commitsBetweenForRepo": 72,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,98 +1,96 @@\n   public Object invoke(Object proxy, Method method, Object[] args)\n     throws Throwable {\n     RetryPolicy policy \u003d methodNameToPolicyMap.get(method.getName());\n     if (policy \u003d\u003d null) {\n       policy \u003d defaultPolicy;\n     }\n     \n     // The number of times this method invocation has been failed over.\n     int invocationFailoverCount \u003d 0;\n     final boolean isRpc \u003d isRpcInvocation(currentProxy.proxy);\n     final int callId \u003d isRpc? Client.nextCallId(): RpcConstants.INVALID_CALL_ID;\n     int retries \u003d 0;\n     while (true) {\n       // The number of times this invocation handler has ever been failed over,\n       // before this method invocation attempt. Used to prevent concurrent\n       // failed method invocations from triggering multiple failover attempts.\n       long invocationAttemptFailoverCount;\n       synchronized (proxyProvider) {\n         invocationAttemptFailoverCount \u003d proxyProviderFailoverCount;\n       }\n \n       if (isRpc) {\n         Client.setCallIdAndRetryCount(callId, retries);\n       }\n       try {\n         Object ret \u003d invokeMethod(method, args);\n         hasMadeASuccessfulCall \u003d true;\n         return ret;\n       } catch (Exception e) {\n         boolean isIdempotentOrAtMostOnce \u003d proxyProvider.getInterface()\n             .getMethod(method.getName(), method.getParameterTypes())\n             .isAnnotationPresent(Idempotent.class);\n         if (!isIdempotentOrAtMostOnce) {\n           isIdempotentOrAtMostOnce \u003d proxyProvider.getInterface()\n               .getMethod(method.getName(), method.getParameterTypes())\n               .isAnnotationPresent(AtMostOnce.class);\n         }\n         RetryAction action \u003d policy.shouldRetry(e, retries++,\n             invocationFailoverCount, isIdempotentOrAtMostOnce);\n         if (action.action \u003d\u003d RetryAction.RetryDecision.FAIL) {\n           if (action.reason !\u003d null) {\n             LOG.warn(\"Exception while invoking \" + currentProxy.proxy.getClass()\n                 + \".\" + method.getName() + \" over \" + currentProxy.proxyInfo\n                 + \". Not retrying because \" + action.reason, e);\n           }\n           throw e;\n         } else { // retry or failover\n           // avoid logging the failover if this is the first call on this\n           // proxy object, and we successfully achieve the failover without\n           // any flip-flopping\n           boolean worthLogging \u003d \n             !(invocationFailoverCount \u003d\u003d 0 \u0026\u0026 !hasMadeASuccessfulCall);\n           worthLogging |\u003d LOG.isDebugEnabled();\n           if (action.action \u003d\u003d RetryAction.RetryDecision.FAILOVER_AND_RETRY \u0026\u0026\n               worthLogging) {\n             String msg \u003d \"Exception while invoking \" + method.getName()\n                 + \" of class \" + currentProxy.proxy.getClass().getSimpleName()\n                 + \" over \" + currentProxy.proxyInfo;\n \n             if (invocationFailoverCount \u003e 0) {\n               msg +\u003d \" after \" + invocationFailoverCount + \" fail over attempts\"; \n             }\n             msg +\u003d \". Trying to fail over \" + formatSleepMessage(action.delayMillis);\n-            if (LOG.isDebugEnabled()) {\n-              LOG.debug(msg, e);\n-            }\n+            LOG.info(msg, e);\n           } else {\n             if(LOG.isDebugEnabled()) {\n               LOG.debug(\"Exception while invoking \" + method.getName()\n                   + \" of class \" + currentProxy.proxy.getClass().getSimpleName()\n                   + \" over \" + currentProxy.proxyInfo + \". Retrying \"\n                   + formatSleepMessage(action.delayMillis), e);\n             }\n           }\n           \n           if (action.delayMillis \u003e 0) {\n             Thread.sleep(action.delayMillis);\n           }\n           \n           if (action.action \u003d\u003d RetryAction.RetryDecision.FAILOVER_AND_RETRY) {\n             // Make sure that concurrent failed method invocations only cause a\n             // single actual fail over.\n             synchronized (proxyProvider) {\n               if (invocationAttemptFailoverCount \u003d\u003d proxyProviderFailoverCount) {\n                 proxyProvider.performFailover(currentProxy.proxy);\n                 proxyProviderFailoverCount++;\n               } else {\n                 LOG.warn(\"A failover has occurred since the start of this method\"\n                     + \" invocation attempt.\");\n               }\n               currentProxy \u003d proxyProvider.getProxy();\n             }\n             invocationFailoverCount++;\n           }\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Object invoke(Object proxy, Method method, Object[] args)\n    throws Throwable {\n    RetryPolicy policy \u003d methodNameToPolicyMap.get(method.getName());\n    if (policy \u003d\u003d null) {\n      policy \u003d defaultPolicy;\n    }\n    \n    // The number of times this method invocation has been failed over.\n    int invocationFailoverCount \u003d 0;\n    final boolean isRpc \u003d isRpcInvocation(currentProxy.proxy);\n    final int callId \u003d isRpc? Client.nextCallId(): RpcConstants.INVALID_CALL_ID;\n    int retries \u003d 0;\n    while (true) {\n      // The number of times this invocation handler has ever been failed over,\n      // before this method invocation attempt. Used to prevent concurrent\n      // failed method invocations from triggering multiple failover attempts.\n      long invocationAttemptFailoverCount;\n      synchronized (proxyProvider) {\n        invocationAttemptFailoverCount \u003d proxyProviderFailoverCount;\n      }\n\n      if (isRpc) {\n        Client.setCallIdAndRetryCount(callId, retries);\n      }\n      try {\n        Object ret \u003d invokeMethod(method, args);\n        hasMadeASuccessfulCall \u003d true;\n        return ret;\n      } catch (Exception e) {\n        boolean isIdempotentOrAtMostOnce \u003d proxyProvider.getInterface()\n            .getMethod(method.getName(), method.getParameterTypes())\n            .isAnnotationPresent(Idempotent.class);\n        if (!isIdempotentOrAtMostOnce) {\n          isIdempotentOrAtMostOnce \u003d proxyProvider.getInterface()\n              .getMethod(method.getName(), method.getParameterTypes())\n              .isAnnotationPresent(AtMostOnce.class);\n        }\n        RetryAction action \u003d policy.shouldRetry(e, retries++,\n            invocationFailoverCount, isIdempotentOrAtMostOnce);\n        if (action.action \u003d\u003d RetryAction.RetryDecision.FAIL) {\n          if (action.reason !\u003d null) {\n            LOG.warn(\"Exception while invoking \" + currentProxy.proxy.getClass()\n                + \".\" + method.getName() + \" over \" + currentProxy.proxyInfo\n                + \". Not retrying because \" + action.reason, e);\n          }\n          throw e;\n        } else { // retry or failover\n          // avoid logging the failover if this is the first call on this\n          // proxy object, and we successfully achieve the failover without\n          // any flip-flopping\n          boolean worthLogging \u003d \n            !(invocationFailoverCount \u003d\u003d 0 \u0026\u0026 !hasMadeASuccessfulCall);\n          worthLogging |\u003d LOG.isDebugEnabled();\n          if (action.action \u003d\u003d RetryAction.RetryDecision.FAILOVER_AND_RETRY \u0026\u0026\n              worthLogging) {\n            String msg \u003d \"Exception while invoking \" + method.getName()\n                + \" of class \" + currentProxy.proxy.getClass().getSimpleName()\n                + \" over \" + currentProxy.proxyInfo;\n\n            if (invocationFailoverCount \u003e 0) {\n              msg +\u003d \" after \" + invocationFailoverCount + \" fail over attempts\"; \n            }\n            msg +\u003d \". Trying to fail over \" + formatSleepMessage(action.delayMillis);\n            LOG.info(msg, e);\n          } else {\n            if(LOG.isDebugEnabled()) {\n              LOG.debug(\"Exception while invoking \" + method.getName()\n                  + \" of class \" + currentProxy.proxy.getClass().getSimpleName()\n                  + \" over \" + currentProxy.proxyInfo + \". Retrying \"\n                  + formatSleepMessage(action.delayMillis), e);\n            }\n          }\n          \n          if (action.delayMillis \u003e 0) {\n            Thread.sleep(action.delayMillis);\n          }\n          \n          if (action.action \u003d\u003d RetryAction.RetryDecision.FAILOVER_AND_RETRY) {\n            // Make sure that concurrent failed method invocations only cause a\n            // single actual fail over.\n            synchronized (proxyProvider) {\n              if (invocationAttemptFailoverCount \u003d\u003d proxyProviderFailoverCount) {\n                proxyProvider.performFailover(currentProxy.proxy);\n                proxyProviderFailoverCount++;\n              } else {\n                LOG.warn(\"A failover has occurred since the start of this method\"\n                    + \" invocation attempt.\");\n              }\n              currentProxy \u003d proxyProvider.getProxy();\n            }\n            invocationFailoverCount++;\n          }\n        }\n      }\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/retry/RetryInvocationHandler.java",
      "extendedDetails": {}
    },
    "cf03bdc3fc9471a5976a27b10f626baba64dbfbf": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10630. Possible race condition in RetryInvocationHandler. Contributed by Jing Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1599366 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/06/14 2:33 PM",
      "commitName": "cf03bdc3fc9471a5976a27b10f626baba64dbfbf",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "13/05/14 9:24 AM",
      "commitNameOld": "335f61a72fe0275f46c697ec82ae10ff97231b38",
      "commitAuthorOld": "Jonathan Turner Eagles",
      "daysBetweenCommits": 20.21,
      "commitsBetweenForRepo": 124,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,98 +1,98 @@\n   public Object invoke(Object proxy, Method method, Object[] args)\n     throws Throwable {\n     RetryPolicy policy \u003d methodNameToPolicyMap.get(method.getName());\n     if (policy \u003d\u003d null) {\n       policy \u003d defaultPolicy;\n     }\n     \n     // The number of times this method invocation has been failed over.\n     int invocationFailoverCount \u003d 0;\n     final boolean isRpc \u003d isRpcInvocation(currentProxy.proxy);\n     final int callId \u003d isRpc? Client.nextCallId(): RpcConstants.INVALID_CALL_ID;\n     int retries \u003d 0;\n     while (true) {\n       // The number of times this invocation handler has ever been failed over,\n       // before this method invocation attempt. Used to prevent concurrent\n       // failed method invocations from triggering multiple failover attempts.\n       long invocationAttemptFailoverCount;\n       synchronized (proxyProvider) {\n         invocationAttemptFailoverCount \u003d proxyProviderFailoverCount;\n       }\n \n       if (isRpc) {\n         Client.setCallIdAndRetryCount(callId, retries);\n       }\n       try {\n         Object ret \u003d invokeMethod(method, args);\n         hasMadeASuccessfulCall \u003d true;\n         return ret;\n       } catch (Exception e) {\n         boolean isIdempotentOrAtMostOnce \u003d proxyProvider.getInterface()\n             .getMethod(method.getName(), method.getParameterTypes())\n             .isAnnotationPresent(Idempotent.class);\n         if (!isIdempotentOrAtMostOnce) {\n           isIdempotentOrAtMostOnce \u003d proxyProvider.getInterface()\n               .getMethod(method.getName(), method.getParameterTypes())\n               .isAnnotationPresent(AtMostOnce.class);\n         }\n         RetryAction action \u003d policy.shouldRetry(e, retries++,\n             invocationFailoverCount, isIdempotentOrAtMostOnce);\n         if (action.action \u003d\u003d RetryAction.RetryDecision.FAIL) {\n           if (action.reason !\u003d null) {\n             LOG.warn(\"Exception while invoking \" + currentProxy.proxy.getClass()\n                 + \".\" + method.getName() + \" over \" + currentProxy.proxyInfo\n                 + \". Not retrying because \" + action.reason, e);\n           }\n           throw e;\n         } else { // retry or failover\n           // avoid logging the failover if this is the first call on this\n           // proxy object, and we successfully achieve the failover without\n           // any flip-flopping\n           boolean worthLogging \u003d \n             !(invocationFailoverCount \u003d\u003d 0 \u0026\u0026 !hasMadeASuccessfulCall);\n           worthLogging |\u003d LOG.isDebugEnabled();\n           if (action.action \u003d\u003d RetryAction.RetryDecision.FAILOVER_AND_RETRY \u0026\u0026\n               worthLogging) {\n             String msg \u003d \"Exception while invoking \" + method.getName()\n                 + \" of class \" + currentProxy.proxy.getClass().getSimpleName()\n                 + \" over \" + currentProxy.proxyInfo;\n \n             if (invocationFailoverCount \u003e 0) {\n               msg +\u003d \" after \" + invocationFailoverCount + \" fail over attempts\"; \n             }\n             msg +\u003d \". Trying to fail over \" + formatSleepMessage(action.delayMillis);\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(msg, e);\n             }\n           } else {\n             if(LOG.isDebugEnabled()) {\n               LOG.debug(\"Exception while invoking \" + method.getName()\n                   + \" of class \" + currentProxy.proxy.getClass().getSimpleName()\n                   + \" over \" + currentProxy.proxyInfo + \". Retrying \"\n                   + formatSleepMessage(action.delayMillis), e);\n             }\n           }\n           \n           if (action.delayMillis \u003e 0) {\n             Thread.sleep(action.delayMillis);\n           }\n           \n           if (action.action \u003d\u003d RetryAction.RetryDecision.FAILOVER_AND_RETRY) {\n             // Make sure that concurrent failed method invocations only cause a\n             // single actual fail over.\n             synchronized (proxyProvider) {\n               if (invocationAttemptFailoverCount \u003d\u003d proxyProviderFailoverCount) {\n                 proxyProvider.performFailover(currentProxy.proxy);\n                 proxyProviderFailoverCount++;\n-                currentProxy \u003d proxyProvider.getProxy();\n               } else {\n                 LOG.warn(\"A failover has occurred since the start of this method\"\n                     + \" invocation attempt.\");\n               }\n+              currentProxy \u003d proxyProvider.getProxy();\n             }\n             invocationFailoverCount++;\n           }\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Object invoke(Object proxy, Method method, Object[] args)\n    throws Throwable {\n    RetryPolicy policy \u003d methodNameToPolicyMap.get(method.getName());\n    if (policy \u003d\u003d null) {\n      policy \u003d defaultPolicy;\n    }\n    \n    // The number of times this method invocation has been failed over.\n    int invocationFailoverCount \u003d 0;\n    final boolean isRpc \u003d isRpcInvocation(currentProxy.proxy);\n    final int callId \u003d isRpc? Client.nextCallId(): RpcConstants.INVALID_CALL_ID;\n    int retries \u003d 0;\n    while (true) {\n      // The number of times this invocation handler has ever been failed over,\n      // before this method invocation attempt. Used to prevent concurrent\n      // failed method invocations from triggering multiple failover attempts.\n      long invocationAttemptFailoverCount;\n      synchronized (proxyProvider) {\n        invocationAttemptFailoverCount \u003d proxyProviderFailoverCount;\n      }\n\n      if (isRpc) {\n        Client.setCallIdAndRetryCount(callId, retries);\n      }\n      try {\n        Object ret \u003d invokeMethod(method, args);\n        hasMadeASuccessfulCall \u003d true;\n        return ret;\n      } catch (Exception e) {\n        boolean isIdempotentOrAtMostOnce \u003d proxyProvider.getInterface()\n            .getMethod(method.getName(), method.getParameterTypes())\n            .isAnnotationPresent(Idempotent.class);\n        if (!isIdempotentOrAtMostOnce) {\n          isIdempotentOrAtMostOnce \u003d proxyProvider.getInterface()\n              .getMethod(method.getName(), method.getParameterTypes())\n              .isAnnotationPresent(AtMostOnce.class);\n        }\n        RetryAction action \u003d policy.shouldRetry(e, retries++,\n            invocationFailoverCount, isIdempotentOrAtMostOnce);\n        if (action.action \u003d\u003d RetryAction.RetryDecision.FAIL) {\n          if (action.reason !\u003d null) {\n            LOG.warn(\"Exception while invoking \" + currentProxy.proxy.getClass()\n                + \".\" + method.getName() + \" over \" + currentProxy.proxyInfo\n                + \". Not retrying because \" + action.reason, e);\n          }\n          throw e;\n        } else { // retry or failover\n          // avoid logging the failover if this is the first call on this\n          // proxy object, and we successfully achieve the failover without\n          // any flip-flopping\n          boolean worthLogging \u003d \n            !(invocationFailoverCount \u003d\u003d 0 \u0026\u0026 !hasMadeASuccessfulCall);\n          worthLogging |\u003d LOG.isDebugEnabled();\n          if (action.action \u003d\u003d RetryAction.RetryDecision.FAILOVER_AND_RETRY \u0026\u0026\n              worthLogging) {\n            String msg \u003d \"Exception while invoking \" + method.getName()\n                + \" of class \" + currentProxy.proxy.getClass().getSimpleName()\n                + \" over \" + currentProxy.proxyInfo;\n\n            if (invocationFailoverCount \u003e 0) {\n              msg +\u003d \" after \" + invocationFailoverCount + \" fail over attempts\"; \n            }\n            msg +\u003d \". Trying to fail over \" + formatSleepMessage(action.delayMillis);\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(msg, e);\n            }\n          } else {\n            if(LOG.isDebugEnabled()) {\n              LOG.debug(\"Exception while invoking \" + method.getName()\n                  + \" of class \" + currentProxy.proxy.getClass().getSimpleName()\n                  + \" over \" + currentProxy.proxyInfo + \". Retrying \"\n                  + formatSleepMessage(action.delayMillis), e);\n            }\n          }\n          \n          if (action.delayMillis \u003e 0) {\n            Thread.sleep(action.delayMillis);\n          }\n          \n          if (action.action \u003d\u003d RetryAction.RetryDecision.FAILOVER_AND_RETRY) {\n            // Make sure that concurrent failed method invocations only cause a\n            // single actual fail over.\n            synchronized (proxyProvider) {\n              if (invocationAttemptFailoverCount \u003d\u003d proxyProviderFailoverCount) {\n                proxyProvider.performFailover(currentProxy.proxy);\n                proxyProviderFailoverCount++;\n              } else {\n                LOG.warn(\"A failover has occurred since the start of this method\"\n                    + \" invocation attempt.\");\n              }\n              currentProxy \u003d proxyProvider.getProxy();\n            }\n            invocationFailoverCount++;\n          }\n        }\n      }\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/retry/RetryInvocationHandler.java",
      "extendedDetails": {}
    },
    "335f61a72fe0275f46c697ec82ae10ff97231b38": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10585. Retry polices ignore interrupted exceptions (Daryn Sharp via jeagles)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1594267 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "13/05/14 9:24 AM",
      "commitName": "335f61a72fe0275f46c697ec82ae10ff97231b38",
      "commitAuthor": "Jonathan Turner Eagles",
      "commitDateOld": "05/03/14 3:09 PM",
      "commitNameOld": "ad61eec0727d55ffcd4fca6f207a4919801bf18b",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 68.72,
      "commitsBetweenForRepo": 442,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,98 +1,98 @@\n   public Object invoke(Object proxy, Method method, Object[] args)\n     throws Throwable {\n     RetryPolicy policy \u003d methodNameToPolicyMap.get(method.getName());\n     if (policy \u003d\u003d null) {\n       policy \u003d defaultPolicy;\n     }\n     \n     // The number of times this method invocation has been failed over.\n     int invocationFailoverCount \u003d 0;\n     final boolean isRpc \u003d isRpcInvocation(currentProxy.proxy);\n     final int callId \u003d isRpc? Client.nextCallId(): RpcConstants.INVALID_CALL_ID;\n     int retries \u003d 0;\n     while (true) {\n       // The number of times this invocation handler has ever been failed over,\n       // before this method invocation attempt. Used to prevent concurrent\n       // failed method invocations from triggering multiple failover attempts.\n       long invocationAttemptFailoverCount;\n       synchronized (proxyProvider) {\n         invocationAttemptFailoverCount \u003d proxyProviderFailoverCount;\n       }\n \n       if (isRpc) {\n         Client.setCallIdAndRetryCount(callId, retries);\n       }\n       try {\n         Object ret \u003d invokeMethod(method, args);\n         hasMadeASuccessfulCall \u003d true;\n         return ret;\n       } catch (Exception e) {\n         boolean isIdempotentOrAtMostOnce \u003d proxyProvider.getInterface()\n             .getMethod(method.getName(), method.getParameterTypes())\n             .isAnnotationPresent(Idempotent.class);\n         if (!isIdempotentOrAtMostOnce) {\n           isIdempotentOrAtMostOnce \u003d proxyProvider.getInterface()\n               .getMethod(method.getName(), method.getParameterTypes())\n               .isAnnotationPresent(AtMostOnce.class);\n         }\n         RetryAction action \u003d policy.shouldRetry(e, retries++,\n             invocationFailoverCount, isIdempotentOrAtMostOnce);\n         if (action.action \u003d\u003d RetryAction.RetryDecision.FAIL) {\n           if (action.reason !\u003d null) {\n             LOG.warn(\"Exception while invoking \" + currentProxy.proxy.getClass()\n                 + \".\" + method.getName() + \" over \" + currentProxy.proxyInfo\n                 + \". Not retrying because \" + action.reason, e);\n           }\n           throw e;\n         } else { // retry or failover\n           // avoid logging the failover if this is the first call on this\n           // proxy object, and we successfully achieve the failover without\n           // any flip-flopping\n           boolean worthLogging \u003d \n             !(invocationFailoverCount \u003d\u003d 0 \u0026\u0026 !hasMadeASuccessfulCall);\n           worthLogging |\u003d LOG.isDebugEnabled();\n           if (action.action \u003d\u003d RetryAction.RetryDecision.FAILOVER_AND_RETRY \u0026\u0026\n               worthLogging) {\n             String msg \u003d \"Exception while invoking \" + method.getName()\n                 + \" of class \" + currentProxy.proxy.getClass().getSimpleName()\n                 + \" over \" + currentProxy.proxyInfo;\n \n             if (invocationFailoverCount \u003e 0) {\n               msg +\u003d \" after \" + invocationFailoverCount + \" fail over attempts\"; \n             }\n             msg +\u003d \". Trying to fail over \" + formatSleepMessage(action.delayMillis);\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(msg, e);\n             }\n           } else {\n             if(LOG.isDebugEnabled()) {\n               LOG.debug(\"Exception while invoking \" + method.getName()\n                   + \" of class \" + currentProxy.proxy.getClass().getSimpleName()\n                   + \" over \" + currentProxy.proxyInfo + \". Retrying \"\n                   + formatSleepMessage(action.delayMillis), e);\n             }\n           }\n           \n           if (action.delayMillis \u003e 0) {\n-            ThreadUtil.sleepAtLeastIgnoreInterrupts(action.delayMillis);\n+            Thread.sleep(action.delayMillis);\n           }\n           \n           if (action.action \u003d\u003d RetryAction.RetryDecision.FAILOVER_AND_RETRY) {\n             // Make sure that concurrent failed method invocations only cause a\n             // single actual fail over.\n             synchronized (proxyProvider) {\n               if (invocationAttemptFailoverCount \u003d\u003d proxyProviderFailoverCount) {\n                 proxyProvider.performFailover(currentProxy.proxy);\n                 proxyProviderFailoverCount++;\n                 currentProxy \u003d proxyProvider.getProxy();\n               } else {\n                 LOG.warn(\"A failover has occurred since the start of this method\"\n                     + \" invocation attempt.\");\n               }\n             }\n             invocationFailoverCount++;\n           }\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Object invoke(Object proxy, Method method, Object[] args)\n    throws Throwable {\n    RetryPolicy policy \u003d methodNameToPolicyMap.get(method.getName());\n    if (policy \u003d\u003d null) {\n      policy \u003d defaultPolicy;\n    }\n    \n    // The number of times this method invocation has been failed over.\n    int invocationFailoverCount \u003d 0;\n    final boolean isRpc \u003d isRpcInvocation(currentProxy.proxy);\n    final int callId \u003d isRpc? Client.nextCallId(): RpcConstants.INVALID_CALL_ID;\n    int retries \u003d 0;\n    while (true) {\n      // The number of times this invocation handler has ever been failed over,\n      // before this method invocation attempt. Used to prevent concurrent\n      // failed method invocations from triggering multiple failover attempts.\n      long invocationAttemptFailoverCount;\n      synchronized (proxyProvider) {\n        invocationAttemptFailoverCount \u003d proxyProviderFailoverCount;\n      }\n\n      if (isRpc) {\n        Client.setCallIdAndRetryCount(callId, retries);\n      }\n      try {\n        Object ret \u003d invokeMethod(method, args);\n        hasMadeASuccessfulCall \u003d true;\n        return ret;\n      } catch (Exception e) {\n        boolean isIdempotentOrAtMostOnce \u003d proxyProvider.getInterface()\n            .getMethod(method.getName(), method.getParameterTypes())\n            .isAnnotationPresent(Idempotent.class);\n        if (!isIdempotentOrAtMostOnce) {\n          isIdempotentOrAtMostOnce \u003d proxyProvider.getInterface()\n              .getMethod(method.getName(), method.getParameterTypes())\n              .isAnnotationPresent(AtMostOnce.class);\n        }\n        RetryAction action \u003d policy.shouldRetry(e, retries++,\n            invocationFailoverCount, isIdempotentOrAtMostOnce);\n        if (action.action \u003d\u003d RetryAction.RetryDecision.FAIL) {\n          if (action.reason !\u003d null) {\n            LOG.warn(\"Exception while invoking \" + currentProxy.proxy.getClass()\n                + \".\" + method.getName() + \" over \" + currentProxy.proxyInfo\n                + \". Not retrying because \" + action.reason, e);\n          }\n          throw e;\n        } else { // retry or failover\n          // avoid logging the failover if this is the first call on this\n          // proxy object, and we successfully achieve the failover without\n          // any flip-flopping\n          boolean worthLogging \u003d \n            !(invocationFailoverCount \u003d\u003d 0 \u0026\u0026 !hasMadeASuccessfulCall);\n          worthLogging |\u003d LOG.isDebugEnabled();\n          if (action.action \u003d\u003d RetryAction.RetryDecision.FAILOVER_AND_RETRY \u0026\u0026\n              worthLogging) {\n            String msg \u003d \"Exception while invoking \" + method.getName()\n                + \" of class \" + currentProxy.proxy.getClass().getSimpleName()\n                + \" over \" + currentProxy.proxyInfo;\n\n            if (invocationFailoverCount \u003e 0) {\n              msg +\u003d \" after \" + invocationFailoverCount + \" fail over attempts\"; \n            }\n            msg +\u003d \". Trying to fail over \" + formatSleepMessage(action.delayMillis);\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(msg, e);\n            }\n          } else {\n            if(LOG.isDebugEnabled()) {\n              LOG.debug(\"Exception while invoking \" + method.getName()\n                  + \" of class \" + currentProxy.proxy.getClass().getSimpleName()\n                  + \" over \" + currentProxy.proxyInfo + \". Retrying \"\n                  + formatSleepMessage(action.delayMillis), e);\n            }\n          }\n          \n          if (action.delayMillis \u003e 0) {\n            Thread.sleep(action.delayMillis);\n          }\n          \n          if (action.action \u003d\u003d RetryAction.RetryDecision.FAILOVER_AND_RETRY) {\n            // Make sure that concurrent failed method invocations only cause a\n            // single actual fail over.\n            synchronized (proxyProvider) {\n              if (invocationAttemptFailoverCount \u003d\u003d proxyProviderFailoverCount) {\n                proxyProvider.performFailover(currentProxy.proxy);\n                proxyProviderFailoverCount++;\n                currentProxy \u003d proxyProvider.getProxy();\n              } else {\n                LOG.warn(\"A failover has occurred since the start of this method\"\n                    + \" invocation attempt.\");\n              }\n            }\n            invocationFailoverCount++;\n          }\n        }\n      }\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/retry/RetryInvocationHandler.java",
      "extendedDetails": {}
    },
    "ad61eec0727d55ffcd4fca6f207a4919801bf18b": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10386. Log proxy hostname in various exceptions being thrown in a HA setup. Contributed by Haohui Mai.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1574716 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "05/03/14 3:09 PM",
      "commitName": "ad61eec0727d55ffcd4fca6f207a4919801bf18b",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "06/09/13 10:17 AM",
      "commitNameOld": "36d0b822ef46fcacdb773abbdd3e81386eb4d63c",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 180.24,
      "commitsBetweenForRepo": 1250,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,95 +1,98 @@\n   public Object invoke(Object proxy, Method method, Object[] args)\n     throws Throwable {\n     RetryPolicy policy \u003d methodNameToPolicyMap.get(method.getName());\n     if (policy \u003d\u003d null) {\n       policy \u003d defaultPolicy;\n     }\n     \n     // The number of times this method invocation has been failed over.\n     int invocationFailoverCount \u003d 0;\n-    final boolean isRpc \u003d isRpcInvocation(currentProxy);\n+    final boolean isRpc \u003d isRpcInvocation(currentProxy.proxy);\n     final int callId \u003d isRpc? Client.nextCallId(): RpcConstants.INVALID_CALL_ID;\n     int retries \u003d 0;\n     while (true) {\n       // The number of times this invocation handler has ever been failed over,\n       // before this method invocation attempt. Used to prevent concurrent\n       // failed method invocations from triggering multiple failover attempts.\n       long invocationAttemptFailoverCount;\n       synchronized (proxyProvider) {\n         invocationAttemptFailoverCount \u003d proxyProviderFailoverCount;\n       }\n \n       if (isRpc) {\n         Client.setCallIdAndRetryCount(callId, retries);\n       }\n       try {\n         Object ret \u003d invokeMethod(method, args);\n         hasMadeASuccessfulCall \u003d true;\n         return ret;\n       } catch (Exception e) {\n         boolean isIdempotentOrAtMostOnce \u003d proxyProvider.getInterface()\n             .getMethod(method.getName(), method.getParameterTypes())\n             .isAnnotationPresent(Idempotent.class);\n         if (!isIdempotentOrAtMostOnce) {\n           isIdempotentOrAtMostOnce \u003d proxyProvider.getInterface()\n               .getMethod(method.getName(), method.getParameterTypes())\n               .isAnnotationPresent(AtMostOnce.class);\n         }\n         RetryAction action \u003d policy.shouldRetry(e, retries++,\n             invocationFailoverCount, isIdempotentOrAtMostOnce);\n         if (action.action \u003d\u003d RetryAction.RetryDecision.FAIL) {\n           if (action.reason !\u003d null) {\n-            LOG.warn(\"Exception while invoking \" + \n-                currentProxy.getClass() + \".\" + method.getName() +\n-                \". Not retrying because \" + action.reason, e);\n+            LOG.warn(\"Exception while invoking \" + currentProxy.proxy.getClass()\n+                + \".\" + method.getName() + \" over \" + currentProxy.proxyInfo\n+                + \". Not retrying because \" + action.reason, e);\n           }\n           throw e;\n         } else { // retry or failover\n           // avoid logging the failover if this is the first call on this\n           // proxy object, and we successfully achieve the failover without\n           // any flip-flopping\n           boolean worthLogging \u003d \n             !(invocationFailoverCount \u003d\u003d 0 \u0026\u0026 !hasMadeASuccessfulCall);\n           worthLogging |\u003d LOG.isDebugEnabled();\n           if (action.action \u003d\u003d RetryAction.RetryDecision.FAILOVER_AND_RETRY \u0026\u0026\n               worthLogging) {\n             String msg \u003d \"Exception while invoking \" + method.getName()\n-              + \" of class \" + currentProxy.getClass().getSimpleName();\n+                + \" of class \" + currentProxy.proxy.getClass().getSimpleName()\n+                + \" over \" + currentProxy.proxyInfo;\n+\n             if (invocationFailoverCount \u003e 0) {\n               msg +\u003d \" after \" + invocationFailoverCount + \" fail over attempts\"; \n             }\n             msg +\u003d \". Trying to fail over \" + formatSleepMessage(action.delayMillis);\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(msg, e);\n             }\n           } else {\n             if(LOG.isDebugEnabled()) {\n               LOG.debug(\"Exception while invoking \" + method.getName()\n-                  + \" of class \" + currentProxy.getClass().getSimpleName() +\n-                  \". Retrying \" + formatSleepMessage(action.delayMillis), e);\n+                  + \" of class \" + currentProxy.proxy.getClass().getSimpleName()\n+                  + \" over \" + currentProxy.proxyInfo + \". Retrying \"\n+                  + formatSleepMessage(action.delayMillis), e);\n             }\n           }\n           \n           if (action.delayMillis \u003e 0) {\n             ThreadUtil.sleepAtLeastIgnoreInterrupts(action.delayMillis);\n           }\n           \n           if (action.action \u003d\u003d RetryAction.RetryDecision.FAILOVER_AND_RETRY) {\n             // Make sure that concurrent failed method invocations only cause a\n             // single actual fail over.\n             synchronized (proxyProvider) {\n               if (invocationAttemptFailoverCount \u003d\u003d proxyProviderFailoverCount) {\n-                proxyProvider.performFailover(currentProxy);\n+                proxyProvider.performFailover(currentProxy.proxy);\n                 proxyProviderFailoverCount++;\n                 currentProxy \u003d proxyProvider.getProxy();\n               } else {\n                 LOG.warn(\"A failover has occurred since the start of this method\"\n                     + \" invocation attempt.\");\n               }\n             }\n             invocationFailoverCount++;\n           }\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Object invoke(Object proxy, Method method, Object[] args)\n    throws Throwable {\n    RetryPolicy policy \u003d methodNameToPolicyMap.get(method.getName());\n    if (policy \u003d\u003d null) {\n      policy \u003d defaultPolicy;\n    }\n    \n    // The number of times this method invocation has been failed over.\n    int invocationFailoverCount \u003d 0;\n    final boolean isRpc \u003d isRpcInvocation(currentProxy.proxy);\n    final int callId \u003d isRpc? Client.nextCallId(): RpcConstants.INVALID_CALL_ID;\n    int retries \u003d 0;\n    while (true) {\n      // The number of times this invocation handler has ever been failed over,\n      // before this method invocation attempt. Used to prevent concurrent\n      // failed method invocations from triggering multiple failover attempts.\n      long invocationAttemptFailoverCount;\n      synchronized (proxyProvider) {\n        invocationAttemptFailoverCount \u003d proxyProviderFailoverCount;\n      }\n\n      if (isRpc) {\n        Client.setCallIdAndRetryCount(callId, retries);\n      }\n      try {\n        Object ret \u003d invokeMethod(method, args);\n        hasMadeASuccessfulCall \u003d true;\n        return ret;\n      } catch (Exception e) {\n        boolean isIdempotentOrAtMostOnce \u003d proxyProvider.getInterface()\n            .getMethod(method.getName(), method.getParameterTypes())\n            .isAnnotationPresent(Idempotent.class);\n        if (!isIdempotentOrAtMostOnce) {\n          isIdempotentOrAtMostOnce \u003d proxyProvider.getInterface()\n              .getMethod(method.getName(), method.getParameterTypes())\n              .isAnnotationPresent(AtMostOnce.class);\n        }\n        RetryAction action \u003d policy.shouldRetry(e, retries++,\n            invocationFailoverCount, isIdempotentOrAtMostOnce);\n        if (action.action \u003d\u003d RetryAction.RetryDecision.FAIL) {\n          if (action.reason !\u003d null) {\n            LOG.warn(\"Exception while invoking \" + currentProxy.proxy.getClass()\n                + \".\" + method.getName() + \" over \" + currentProxy.proxyInfo\n                + \". Not retrying because \" + action.reason, e);\n          }\n          throw e;\n        } else { // retry or failover\n          // avoid logging the failover if this is the first call on this\n          // proxy object, and we successfully achieve the failover without\n          // any flip-flopping\n          boolean worthLogging \u003d \n            !(invocationFailoverCount \u003d\u003d 0 \u0026\u0026 !hasMadeASuccessfulCall);\n          worthLogging |\u003d LOG.isDebugEnabled();\n          if (action.action \u003d\u003d RetryAction.RetryDecision.FAILOVER_AND_RETRY \u0026\u0026\n              worthLogging) {\n            String msg \u003d \"Exception while invoking \" + method.getName()\n                + \" of class \" + currentProxy.proxy.getClass().getSimpleName()\n                + \" over \" + currentProxy.proxyInfo;\n\n            if (invocationFailoverCount \u003e 0) {\n              msg +\u003d \" after \" + invocationFailoverCount + \" fail over attempts\"; \n            }\n            msg +\u003d \". Trying to fail over \" + formatSleepMessage(action.delayMillis);\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(msg, e);\n            }\n          } else {\n            if(LOG.isDebugEnabled()) {\n              LOG.debug(\"Exception while invoking \" + method.getName()\n                  + \" of class \" + currentProxy.proxy.getClass().getSimpleName()\n                  + \" over \" + currentProxy.proxyInfo + \". Retrying \"\n                  + formatSleepMessage(action.delayMillis), e);\n            }\n          }\n          \n          if (action.delayMillis \u003e 0) {\n            ThreadUtil.sleepAtLeastIgnoreInterrupts(action.delayMillis);\n          }\n          \n          if (action.action \u003d\u003d RetryAction.RetryDecision.FAILOVER_AND_RETRY) {\n            // Make sure that concurrent failed method invocations only cause a\n            // single actual fail over.\n            synchronized (proxyProvider) {\n              if (invocationAttemptFailoverCount \u003d\u003d proxyProviderFailoverCount) {\n                proxyProvider.performFailover(currentProxy.proxy);\n                proxyProviderFailoverCount++;\n                currentProxy \u003d proxyProvider.getProxy();\n              } else {\n                LOG.warn(\"A failover has occurred since the start of this method\"\n                    + \" invocation attempt.\");\n              }\n            }\n            invocationFailoverCount++;\n          }\n        }\n      }\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/retry/RetryInvocationHandler.java",
      "extendedDetails": {}
    },
    "a6ef93307eda6ff5c8bed5cfd72bb06b037644ce": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9886. Turn warning message in RetryInvocationHandler to debug. Contributed by Arpit Gupta\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1516034 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "20/08/13 4:44 PM",
      "commitName": "a6ef93307eda6ff5c8bed5cfd72bb06b037644ce",
      "commitAuthor": "Arpit Gupta",
      "commitDateOld": "31/07/13 7:20 PM",
      "commitNameOld": "134557da47f956347e870b6208e44ffe8cfdd06d",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 19.89,
      "commitsBetweenForRepo": 123,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,97 +1,95 @@\n   public Object invoke(Object proxy, Method method, Object[] args)\n     throws Throwable {\n     RetryPolicy policy \u003d methodNameToPolicyMap.get(method.getName());\n     if (policy \u003d\u003d null) {\n       policy \u003d defaultPolicy;\n     }\n     \n     // The number of times this method invocation has been failed over.\n     int invocationFailoverCount \u003d 0;\n     final boolean isRpc \u003d isRpcInvocation(currentProxy);\n     final int callId \u003d isRpc? Client.nextCallId(): RpcConstants.INVALID_CALL_ID;\n     int retries \u003d 0;\n     while (true) {\n       // The number of times this invocation handler has ever been failed over,\n       // before this method invocation attempt. Used to prevent concurrent\n       // failed method invocations from triggering multiple failover attempts.\n       long invocationAttemptFailoverCount;\n       synchronized (proxyProvider) {\n         invocationAttemptFailoverCount \u003d proxyProviderFailoverCount;\n       }\n \n       if (isRpc) {\n         Client.setCallIdAndRetryCount(callId, retries);\n       }\n       try {\n         Object ret \u003d invokeMethod(method, args);\n         hasMadeASuccessfulCall \u003d true;\n         return ret;\n       } catch (Exception e) {\n         boolean isIdempotentOrAtMostOnce \u003d proxyProvider.getInterface()\n             .getMethod(method.getName(), method.getParameterTypes())\n             .isAnnotationPresent(Idempotent.class);\n         if (!isIdempotentOrAtMostOnce) {\n           isIdempotentOrAtMostOnce \u003d proxyProvider.getInterface()\n               .getMethod(method.getName(), method.getParameterTypes())\n               .isAnnotationPresent(AtMostOnce.class);\n         }\n         RetryAction action \u003d policy.shouldRetry(e, retries++,\n             invocationFailoverCount, isIdempotentOrAtMostOnce);\n         if (action.action \u003d\u003d RetryAction.RetryDecision.FAIL) {\n           if (action.reason !\u003d null) {\n             LOG.warn(\"Exception while invoking \" + \n                 currentProxy.getClass() + \".\" + method.getName() +\n                 \". Not retrying because \" + action.reason, e);\n           }\n           throw e;\n         } else { // retry or failover\n           // avoid logging the failover if this is the first call on this\n           // proxy object, and we successfully achieve the failover without\n           // any flip-flopping\n           boolean worthLogging \u003d \n             !(invocationFailoverCount \u003d\u003d 0 \u0026\u0026 !hasMadeASuccessfulCall);\n           worthLogging |\u003d LOG.isDebugEnabled();\n           if (action.action \u003d\u003d RetryAction.RetryDecision.FAILOVER_AND_RETRY \u0026\u0026\n               worthLogging) {\n             String msg \u003d \"Exception while invoking \" + method.getName()\n               + \" of class \" + currentProxy.getClass().getSimpleName();\n             if (invocationFailoverCount \u003e 0) {\n               msg +\u003d \" after \" + invocationFailoverCount + \" fail over attempts\"; \n             }\n             msg +\u003d \". Trying to fail over \" + formatSleepMessage(action.delayMillis);\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(msg, e);\n-            } else {\n-              LOG.warn(msg);\n             }\n           } else {\n             if(LOG.isDebugEnabled()) {\n               LOG.debug(\"Exception while invoking \" + method.getName()\n                   + \" of class \" + currentProxy.getClass().getSimpleName() +\n                   \". Retrying \" + formatSleepMessage(action.delayMillis), e);\n             }\n           }\n           \n           if (action.delayMillis \u003e 0) {\n             ThreadUtil.sleepAtLeastIgnoreInterrupts(action.delayMillis);\n           }\n           \n           if (action.action \u003d\u003d RetryAction.RetryDecision.FAILOVER_AND_RETRY) {\n             // Make sure that concurrent failed method invocations only cause a\n             // single actual fail over.\n             synchronized (proxyProvider) {\n               if (invocationAttemptFailoverCount \u003d\u003d proxyProviderFailoverCount) {\n                 proxyProvider.performFailover(currentProxy);\n                 proxyProviderFailoverCount++;\n                 currentProxy \u003d proxyProvider.getProxy();\n               } else {\n                 LOG.warn(\"A failover has occurred since the start of this method\"\n                     + \" invocation attempt.\");\n               }\n             }\n             invocationFailoverCount++;\n           }\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Object invoke(Object proxy, Method method, Object[] args)\n    throws Throwable {\n    RetryPolicy policy \u003d methodNameToPolicyMap.get(method.getName());\n    if (policy \u003d\u003d null) {\n      policy \u003d defaultPolicy;\n    }\n    \n    // The number of times this method invocation has been failed over.\n    int invocationFailoverCount \u003d 0;\n    final boolean isRpc \u003d isRpcInvocation(currentProxy);\n    final int callId \u003d isRpc? Client.nextCallId(): RpcConstants.INVALID_CALL_ID;\n    int retries \u003d 0;\n    while (true) {\n      // The number of times this invocation handler has ever been failed over,\n      // before this method invocation attempt. Used to prevent concurrent\n      // failed method invocations from triggering multiple failover attempts.\n      long invocationAttemptFailoverCount;\n      synchronized (proxyProvider) {\n        invocationAttemptFailoverCount \u003d proxyProviderFailoverCount;\n      }\n\n      if (isRpc) {\n        Client.setCallIdAndRetryCount(callId, retries);\n      }\n      try {\n        Object ret \u003d invokeMethod(method, args);\n        hasMadeASuccessfulCall \u003d true;\n        return ret;\n      } catch (Exception e) {\n        boolean isIdempotentOrAtMostOnce \u003d proxyProvider.getInterface()\n            .getMethod(method.getName(), method.getParameterTypes())\n            .isAnnotationPresent(Idempotent.class);\n        if (!isIdempotentOrAtMostOnce) {\n          isIdempotentOrAtMostOnce \u003d proxyProvider.getInterface()\n              .getMethod(method.getName(), method.getParameterTypes())\n              .isAnnotationPresent(AtMostOnce.class);\n        }\n        RetryAction action \u003d policy.shouldRetry(e, retries++,\n            invocationFailoverCount, isIdempotentOrAtMostOnce);\n        if (action.action \u003d\u003d RetryAction.RetryDecision.FAIL) {\n          if (action.reason !\u003d null) {\n            LOG.warn(\"Exception while invoking \" + \n                currentProxy.getClass() + \".\" + method.getName() +\n                \". Not retrying because \" + action.reason, e);\n          }\n          throw e;\n        } else { // retry or failover\n          // avoid logging the failover if this is the first call on this\n          // proxy object, and we successfully achieve the failover without\n          // any flip-flopping\n          boolean worthLogging \u003d \n            !(invocationFailoverCount \u003d\u003d 0 \u0026\u0026 !hasMadeASuccessfulCall);\n          worthLogging |\u003d LOG.isDebugEnabled();\n          if (action.action \u003d\u003d RetryAction.RetryDecision.FAILOVER_AND_RETRY \u0026\u0026\n              worthLogging) {\n            String msg \u003d \"Exception while invoking \" + method.getName()\n              + \" of class \" + currentProxy.getClass().getSimpleName();\n            if (invocationFailoverCount \u003e 0) {\n              msg +\u003d \" after \" + invocationFailoverCount + \" fail over attempts\"; \n            }\n            msg +\u003d \". Trying to fail over \" + formatSleepMessage(action.delayMillis);\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(msg, e);\n            }\n          } else {\n            if(LOG.isDebugEnabled()) {\n              LOG.debug(\"Exception while invoking \" + method.getName()\n                  + \" of class \" + currentProxy.getClass().getSimpleName() +\n                  \". Retrying \" + formatSleepMessage(action.delayMillis), e);\n            }\n          }\n          \n          if (action.delayMillis \u003e 0) {\n            ThreadUtil.sleepAtLeastIgnoreInterrupts(action.delayMillis);\n          }\n          \n          if (action.action \u003d\u003d RetryAction.RetryDecision.FAILOVER_AND_RETRY) {\n            // Make sure that concurrent failed method invocations only cause a\n            // single actual fail over.\n            synchronized (proxyProvider) {\n              if (invocationAttemptFailoverCount \u003d\u003d proxyProviderFailoverCount) {\n                proxyProvider.performFailover(currentProxy);\n                proxyProviderFailoverCount++;\n                currentProxy \u003d proxyProvider.getProxy();\n              } else {\n                LOG.warn(\"A failover has occurred since the start of this method\"\n                    + \" invocation attempt.\");\n              }\n            }\n            invocationFailoverCount++;\n          }\n        }\n      }\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/retry/RetryInvocationHandler.java",
      "extendedDetails": {}
    },
    "3be4036abebb46d2f8c76b6929c201844fcbcb65": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9792. Retry the methods that are tagged @AtMostOnce along with @Idempotent. Contributed by Suresh Srinivas.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1508312 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/07/13 11:19 PM",
      "commitName": "3be4036abebb46d2f8c76b6929c201844fcbcb65",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "29/07/13 10:22 PM",
      "commitNameOld": "f4512282505206564d0bcef952be9d9d820621cc",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,92 +1,97 @@\n   public Object invoke(Object proxy, Method method, Object[] args)\n     throws Throwable {\n     RetryPolicy policy \u003d methodNameToPolicyMap.get(method.getName());\n     if (policy \u003d\u003d null) {\n       policy \u003d defaultPolicy;\n     }\n     \n     // The number of times this method invocation has been failed over.\n     int invocationFailoverCount \u003d 0;\n     final boolean isRpc \u003d isRpcInvocation(currentProxy);\n     final int callId \u003d isRpc? Client.nextCallId(): RpcConstants.INVALID_CALL_ID;\n     int retries \u003d 0;\n     while (true) {\n       // The number of times this invocation handler has ever been failed over,\n       // before this method invocation attempt. Used to prevent concurrent\n       // failed method invocations from triggering multiple failover attempts.\n       long invocationAttemptFailoverCount;\n       synchronized (proxyProvider) {\n         invocationAttemptFailoverCount \u003d proxyProviderFailoverCount;\n       }\n \n       if (isRpc) {\n         Client.setCallIdAndRetryCount(callId, retries);\n       }\n       try {\n         Object ret \u003d invokeMethod(method, args);\n         hasMadeASuccessfulCall \u003d true;\n         return ret;\n       } catch (Exception e) {\n-        boolean isMethodIdempotent \u003d proxyProvider.getInterface()\n+        boolean isIdempotentOrAtMostOnce \u003d proxyProvider.getInterface()\n             .getMethod(method.getName(), method.getParameterTypes())\n             .isAnnotationPresent(Idempotent.class);\n+        if (!isIdempotentOrAtMostOnce) {\n+          isIdempotentOrAtMostOnce \u003d proxyProvider.getInterface()\n+              .getMethod(method.getName(), method.getParameterTypes())\n+              .isAnnotationPresent(AtMostOnce.class);\n+        }\n         RetryAction action \u003d policy.shouldRetry(e, retries++,\n-            invocationFailoverCount, isMethodIdempotent);\n+            invocationFailoverCount, isIdempotentOrAtMostOnce);\n         if (action.action \u003d\u003d RetryAction.RetryDecision.FAIL) {\n           if (action.reason !\u003d null) {\n             LOG.warn(\"Exception while invoking \" + \n                 currentProxy.getClass() + \".\" + method.getName() +\n                 \". Not retrying because \" + action.reason, e);\n           }\n           throw e;\n         } else { // retry or failover\n           // avoid logging the failover if this is the first call on this\n           // proxy object, and we successfully achieve the failover without\n           // any flip-flopping\n           boolean worthLogging \u003d \n             !(invocationFailoverCount \u003d\u003d 0 \u0026\u0026 !hasMadeASuccessfulCall);\n           worthLogging |\u003d LOG.isDebugEnabled();\n           if (action.action \u003d\u003d RetryAction.RetryDecision.FAILOVER_AND_RETRY \u0026\u0026\n               worthLogging) {\n             String msg \u003d \"Exception while invoking \" + method.getName()\n               + \" of class \" + currentProxy.getClass().getSimpleName();\n             if (invocationFailoverCount \u003e 0) {\n               msg +\u003d \" after \" + invocationFailoverCount + \" fail over attempts\"; \n             }\n             msg +\u003d \". Trying to fail over \" + formatSleepMessage(action.delayMillis);\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(msg, e);\n             } else {\n               LOG.warn(msg);\n             }\n           } else {\n             if(LOG.isDebugEnabled()) {\n               LOG.debug(\"Exception while invoking \" + method.getName()\n                   + \" of class \" + currentProxy.getClass().getSimpleName() +\n                   \". Retrying \" + formatSleepMessage(action.delayMillis), e);\n             }\n           }\n           \n           if (action.delayMillis \u003e 0) {\n             ThreadUtil.sleepAtLeastIgnoreInterrupts(action.delayMillis);\n           }\n           \n           if (action.action \u003d\u003d RetryAction.RetryDecision.FAILOVER_AND_RETRY) {\n             // Make sure that concurrent failed method invocations only cause a\n             // single actual fail over.\n             synchronized (proxyProvider) {\n               if (invocationAttemptFailoverCount \u003d\u003d proxyProviderFailoverCount) {\n                 proxyProvider.performFailover(currentProxy);\n                 proxyProviderFailoverCount++;\n                 currentProxy \u003d proxyProvider.getProxy();\n               } else {\n                 LOG.warn(\"A failover has occurred since the start of this method\"\n                     + \" invocation attempt.\");\n               }\n             }\n             invocationFailoverCount++;\n           }\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Object invoke(Object proxy, Method method, Object[] args)\n    throws Throwable {\n    RetryPolicy policy \u003d methodNameToPolicyMap.get(method.getName());\n    if (policy \u003d\u003d null) {\n      policy \u003d defaultPolicy;\n    }\n    \n    // The number of times this method invocation has been failed over.\n    int invocationFailoverCount \u003d 0;\n    final boolean isRpc \u003d isRpcInvocation(currentProxy);\n    final int callId \u003d isRpc? Client.nextCallId(): RpcConstants.INVALID_CALL_ID;\n    int retries \u003d 0;\n    while (true) {\n      // The number of times this invocation handler has ever been failed over,\n      // before this method invocation attempt. Used to prevent concurrent\n      // failed method invocations from triggering multiple failover attempts.\n      long invocationAttemptFailoverCount;\n      synchronized (proxyProvider) {\n        invocationAttemptFailoverCount \u003d proxyProviderFailoverCount;\n      }\n\n      if (isRpc) {\n        Client.setCallIdAndRetryCount(callId, retries);\n      }\n      try {\n        Object ret \u003d invokeMethod(method, args);\n        hasMadeASuccessfulCall \u003d true;\n        return ret;\n      } catch (Exception e) {\n        boolean isIdempotentOrAtMostOnce \u003d proxyProvider.getInterface()\n            .getMethod(method.getName(), method.getParameterTypes())\n            .isAnnotationPresent(Idempotent.class);\n        if (!isIdempotentOrAtMostOnce) {\n          isIdempotentOrAtMostOnce \u003d proxyProvider.getInterface()\n              .getMethod(method.getName(), method.getParameterTypes())\n              .isAnnotationPresent(AtMostOnce.class);\n        }\n        RetryAction action \u003d policy.shouldRetry(e, retries++,\n            invocationFailoverCount, isIdempotentOrAtMostOnce);\n        if (action.action \u003d\u003d RetryAction.RetryDecision.FAIL) {\n          if (action.reason !\u003d null) {\n            LOG.warn(\"Exception while invoking \" + \n                currentProxy.getClass() + \".\" + method.getName() +\n                \". Not retrying because \" + action.reason, e);\n          }\n          throw e;\n        } else { // retry or failover\n          // avoid logging the failover if this is the first call on this\n          // proxy object, and we successfully achieve the failover without\n          // any flip-flopping\n          boolean worthLogging \u003d \n            !(invocationFailoverCount \u003d\u003d 0 \u0026\u0026 !hasMadeASuccessfulCall);\n          worthLogging |\u003d LOG.isDebugEnabled();\n          if (action.action \u003d\u003d RetryAction.RetryDecision.FAILOVER_AND_RETRY \u0026\u0026\n              worthLogging) {\n            String msg \u003d \"Exception while invoking \" + method.getName()\n              + \" of class \" + currentProxy.getClass().getSimpleName();\n            if (invocationFailoverCount \u003e 0) {\n              msg +\u003d \" after \" + invocationFailoverCount + \" fail over attempts\"; \n            }\n            msg +\u003d \". Trying to fail over \" + formatSleepMessage(action.delayMillis);\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(msg, e);\n            } else {\n              LOG.warn(msg);\n            }\n          } else {\n            if(LOG.isDebugEnabled()) {\n              LOG.debug(\"Exception while invoking \" + method.getName()\n                  + \" of class \" + currentProxy.getClass().getSimpleName() +\n                  \". Retrying \" + formatSleepMessage(action.delayMillis), e);\n            }\n          }\n          \n          if (action.delayMillis \u003e 0) {\n            ThreadUtil.sleepAtLeastIgnoreInterrupts(action.delayMillis);\n          }\n          \n          if (action.action \u003d\u003d RetryAction.RetryDecision.FAILOVER_AND_RETRY) {\n            // Make sure that concurrent failed method invocations only cause a\n            // single actual fail over.\n            synchronized (proxyProvider) {\n              if (invocationAttemptFailoverCount \u003d\u003d proxyProviderFailoverCount) {\n                proxyProvider.performFailover(currentProxy);\n                proxyProviderFailoverCount++;\n                currentProxy \u003d proxyProvider.getProxy();\n              } else {\n                LOG.warn(\"A failover has occurred since the start of this method\"\n                    + \" invocation attempt.\");\n              }\n            }\n            invocationFailoverCount++;\n          }\n        }\n      }\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/retry/RetryInvocationHandler.java",
      "extendedDetails": {}
    },
    "f4512282505206564d0bcef952be9d9d820621cc": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9786. RetryInvocationHandler#isRpcInvocation should support ProtocolTranslator. Contributed by Suresh Srinivas and Jing Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1508304 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/07/13 10:22 PM",
      "commitName": "f4512282505206564d0bcef952be9d9d820621cc",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "18/07/13 4:44 PM",
      "commitNameOld": "8724ceb2359af66c800043e665c17a2a30981c7d",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 11.24,
      "commitsBetweenForRepo": 71,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,92 +1,92 @@\n   public Object invoke(Object proxy, Method method, Object[] args)\n     throws Throwable {\n     RetryPolicy policy \u003d methodNameToPolicyMap.get(method.getName());\n     if (policy \u003d\u003d null) {\n       policy \u003d defaultPolicy;\n     }\n     \n     // The number of times this method invocation has been failed over.\n     int invocationFailoverCount \u003d 0;\n-    final boolean isRpc \u003d isRpcInvocation();\n+    final boolean isRpc \u003d isRpcInvocation(currentProxy);\n     final int callId \u003d isRpc? Client.nextCallId(): RpcConstants.INVALID_CALL_ID;\n     int retries \u003d 0;\n     while (true) {\n       // The number of times this invocation handler has ever been failed over,\n       // before this method invocation attempt. Used to prevent concurrent\n       // failed method invocations from triggering multiple failover attempts.\n       long invocationAttemptFailoverCount;\n       synchronized (proxyProvider) {\n         invocationAttemptFailoverCount \u003d proxyProviderFailoverCount;\n       }\n \n       if (isRpc) {\n         Client.setCallIdAndRetryCount(callId, retries);\n       }\n       try {\n         Object ret \u003d invokeMethod(method, args);\n         hasMadeASuccessfulCall \u003d true;\n         return ret;\n       } catch (Exception e) {\n         boolean isMethodIdempotent \u003d proxyProvider.getInterface()\n             .getMethod(method.getName(), method.getParameterTypes())\n             .isAnnotationPresent(Idempotent.class);\n         RetryAction action \u003d policy.shouldRetry(e, retries++,\n             invocationFailoverCount, isMethodIdempotent);\n         if (action.action \u003d\u003d RetryAction.RetryDecision.FAIL) {\n           if (action.reason !\u003d null) {\n             LOG.warn(\"Exception while invoking \" + \n                 currentProxy.getClass() + \".\" + method.getName() +\n                 \". Not retrying because \" + action.reason, e);\n           }\n           throw e;\n         } else { // retry or failover\n           // avoid logging the failover if this is the first call on this\n           // proxy object, and we successfully achieve the failover without\n           // any flip-flopping\n           boolean worthLogging \u003d \n             !(invocationFailoverCount \u003d\u003d 0 \u0026\u0026 !hasMadeASuccessfulCall);\n           worthLogging |\u003d LOG.isDebugEnabled();\n           if (action.action \u003d\u003d RetryAction.RetryDecision.FAILOVER_AND_RETRY \u0026\u0026\n               worthLogging) {\n             String msg \u003d \"Exception while invoking \" + method.getName()\n               + \" of class \" + currentProxy.getClass().getSimpleName();\n             if (invocationFailoverCount \u003e 0) {\n               msg +\u003d \" after \" + invocationFailoverCount + \" fail over attempts\"; \n             }\n             msg +\u003d \". Trying to fail over \" + formatSleepMessage(action.delayMillis);\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(msg, e);\n             } else {\n               LOG.warn(msg);\n             }\n           } else {\n             if(LOG.isDebugEnabled()) {\n               LOG.debug(\"Exception while invoking \" + method.getName()\n                   + \" of class \" + currentProxy.getClass().getSimpleName() +\n                   \". Retrying \" + formatSleepMessage(action.delayMillis), e);\n             }\n           }\n           \n           if (action.delayMillis \u003e 0) {\n             ThreadUtil.sleepAtLeastIgnoreInterrupts(action.delayMillis);\n           }\n           \n           if (action.action \u003d\u003d RetryAction.RetryDecision.FAILOVER_AND_RETRY) {\n             // Make sure that concurrent failed method invocations only cause a\n             // single actual fail over.\n             synchronized (proxyProvider) {\n               if (invocationAttemptFailoverCount \u003d\u003d proxyProviderFailoverCount) {\n                 proxyProvider.performFailover(currentProxy);\n                 proxyProviderFailoverCount++;\n                 currentProxy \u003d proxyProvider.getProxy();\n               } else {\n                 LOG.warn(\"A failover has occurred since the start of this method\"\n                     + \" invocation attempt.\");\n               }\n             }\n             invocationFailoverCount++;\n           }\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Object invoke(Object proxy, Method method, Object[] args)\n    throws Throwable {\n    RetryPolicy policy \u003d methodNameToPolicyMap.get(method.getName());\n    if (policy \u003d\u003d null) {\n      policy \u003d defaultPolicy;\n    }\n    \n    // The number of times this method invocation has been failed over.\n    int invocationFailoverCount \u003d 0;\n    final boolean isRpc \u003d isRpcInvocation(currentProxy);\n    final int callId \u003d isRpc? Client.nextCallId(): RpcConstants.INVALID_CALL_ID;\n    int retries \u003d 0;\n    while (true) {\n      // The number of times this invocation handler has ever been failed over,\n      // before this method invocation attempt. Used to prevent concurrent\n      // failed method invocations from triggering multiple failover attempts.\n      long invocationAttemptFailoverCount;\n      synchronized (proxyProvider) {\n        invocationAttemptFailoverCount \u003d proxyProviderFailoverCount;\n      }\n\n      if (isRpc) {\n        Client.setCallIdAndRetryCount(callId, retries);\n      }\n      try {\n        Object ret \u003d invokeMethod(method, args);\n        hasMadeASuccessfulCall \u003d true;\n        return ret;\n      } catch (Exception e) {\n        boolean isMethodIdempotent \u003d proxyProvider.getInterface()\n            .getMethod(method.getName(), method.getParameterTypes())\n            .isAnnotationPresent(Idempotent.class);\n        RetryAction action \u003d policy.shouldRetry(e, retries++,\n            invocationFailoverCount, isMethodIdempotent);\n        if (action.action \u003d\u003d RetryAction.RetryDecision.FAIL) {\n          if (action.reason !\u003d null) {\n            LOG.warn(\"Exception while invoking \" + \n                currentProxy.getClass() + \".\" + method.getName() +\n                \". Not retrying because \" + action.reason, e);\n          }\n          throw e;\n        } else { // retry or failover\n          // avoid logging the failover if this is the first call on this\n          // proxy object, and we successfully achieve the failover without\n          // any flip-flopping\n          boolean worthLogging \u003d \n            !(invocationFailoverCount \u003d\u003d 0 \u0026\u0026 !hasMadeASuccessfulCall);\n          worthLogging |\u003d LOG.isDebugEnabled();\n          if (action.action \u003d\u003d RetryAction.RetryDecision.FAILOVER_AND_RETRY \u0026\u0026\n              worthLogging) {\n            String msg \u003d \"Exception while invoking \" + method.getName()\n              + \" of class \" + currentProxy.getClass().getSimpleName();\n            if (invocationFailoverCount \u003e 0) {\n              msg +\u003d \" after \" + invocationFailoverCount + \" fail over attempts\"; \n            }\n            msg +\u003d \". Trying to fail over \" + formatSleepMessage(action.delayMillis);\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(msg, e);\n            } else {\n              LOG.warn(msg);\n            }\n          } else {\n            if(LOG.isDebugEnabled()) {\n              LOG.debug(\"Exception while invoking \" + method.getName()\n                  + \" of class \" + currentProxy.getClass().getSimpleName() +\n                  \". Retrying \" + formatSleepMessage(action.delayMillis), e);\n            }\n          }\n          \n          if (action.delayMillis \u003e 0) {\n            ThreadUtil.sleepAtLeastIgnoreInterrupts(action.delayMillis);\n          }\n          \n          if (action.action \u003d\u003d RetryAction.RetryDecision.FAILOVER_AND_RETRY) {\n            // Make sure that concurrent failed method invocations only cause a\n            // single actual fail over.\n            synchronized (proxyProvider) {\n              if (invocationAttemptFailoverCount \u003d\u003d proxyProviderFailoverCount) {\n                proxyProvider.performFailover(currentProxy);\n                proxyProviderFailoverCount++;\n                currentProxy \u003d proxyProvider.getProxy();\n              } else {\n                LOG.warn(\"A failover has occurred since the start of this method\"\n                    + \" invocation attempt.\");\n              }\n            }\n            invocationFailoverCount++;\n          }\n        }\n      }\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/retry/RetryInvocationHandler.java",
      "extendedDetails": {}
    },
    "8724ceb2359af66c800043e665c17a2a30981c7d": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9717. Add retry attempt count to the RPC requests. Contributed by Jing Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1504725 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/07/13 4:44 PM",
      "commitName": "8724ceb2359af66c800043e665c17a2a30981c7d",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "17/07/13 9:42 PM",
      "commitNameOld": "7ec67c5118e8d13e2cb0ab09d04f0609b645a676",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 0.79,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,92 +1,92 @@\n   public Object invoke(Object proxy, Method method, Object[] args)\n     throws Throwable {\n     RetryPolicy policy \u003d methodNameToPolicyMap.get(method.getName());\n     if (policy \u003d\u003d null) {\n       policy \u003d defaultPolicy;\n     }\n     \n     // The number of times this method invocation has been failed over.\n     int invocationFailoverCount \u003d 0;\n     final boolean isRpc \u003d isRpcInvocation();\n     final int callId \u003d isRpc? Client.nextCallId(): RpcConstants.INVALID_CALL_ID;\n     int retries \u003d 0;\n     while (true) {\n       // The number of times this invocation handler has ever been failed over,\n       // before this method invocation attempt. Used to prevent concurrent\n       // failed method invocations from triggering multiple failover attempts.\n       long invocationAttemptFailoverCount;\n       synchronized (proxyProvider) {\n         invocationAttemptFailoverCount \u003d proxyProviderFailoverCount;\n       }\n \n       if (isRpc) {\n-        Client.setCallId(callId);\n+        Client.setCallIdAndRetryCount(callId, retries);\n       }\n       try {\n         Object ret \u003d invokeMethod(method, args);\n         hasMadeASuccessfulCall \u003d true;\n         return ret;\n       } catch (Exception e) {\n         boolean isMethodIdempotent \u003d proxyProvider.getInterface()\n             .getMethod(method.getName(), method.getParameterTypes())\n             .isAnnotationPresent(Idempotent.class);\n-        RetryAction action \u003d policy.shouldRetry(e, retries++, invocationFailoverCount,\n-            isMethodIdempotent);\n+        RetryAction action \u003d policy.shouldRetry(e, retries++,\n+            invocationFailoverCount, isMethodIdempotent);\n         if (action.action \u003d\u003d RetryAction.RetryDecision.FAIL) {\n           if (action.reason !\u003d null) {\n             LOG.warn(\"Exception while invoking \" + \n                 currentProxy.getClass() + \".\" + method.getName() +\n                 \". Not retrying because \" + action.reason, e);\n           }\n           throw e;\n         } else { // retry or failover\n           // avoid logging the failover if this is the first call on this\n           // proxy object, and we successfully achieve the failover without\n           // any flip-flopping\n           boolean worthLogging \u003d \n             !(invocationFailoverCount \u003d\u003d 0 \u0026\u0026 !hasMadeASuccessfulCall);\n           worthLogging |\u003d LOG.isDebugEnabled();\n           if (action.action \u003d\u003d RetryAction.RetryDecision.FAILOVER_AND_RETRY \u0026\u0026\n               worthLogging) {\n             String msg \u003d \"Exception while invoking \" + method.getName()\n               + \" of class \" + currentProxy.getClass().getSimpleName();\n             if (invocationFailoverCount \u003e 0) {\n               msg +\u003d \" after \" + invocationFailoverCount + \" fail over attempts\"; \n             }\n             msg +\u003d \". Trying to fail over \" + formatSleepMessage(action.delayMillis);\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(msg, e);\n             } else {\n               LOG.warn(msg);\n             }\n           } else {\n             if(LOG.isDebugEnabled()) {\n               LOG.debug(\"Exception while invoking \" + method.getName()\n                   + \" of class \" + currentProxy.getClass().getSimpleName() +\n                   \". Retrying \" + formatSleepMessage(action.delayMillis), e);\n             }\n           }\n           \n           if (action.delayMillis \u003e 0) {\n             ThreadUtil.sleepAtLeastIgnoreInterrupts(action.delayMillis);\n           }\n           \n           if (action.action \u003d\u003d RetryAction.RetryDecision.FAILOVER_AND_RETRY) {\n             // Make sure that concurrent failed method invocations only cause a\n             // single actual fail over.\n             synchronized (proxyProvider) {\n               if (invocationAttemptFailoverCount \u003d\u003d proxyProviderFailoverCount) {\n                 proxyProvider.performFailover(currentProxy);\n                 proxyProviderFailoverCount++;\n                 currentProxy \u003d proxyProvider.getProxy();\n               } else {\n                 LOG.warn(\"A failover has occurred since the start of this method\"\n                     + \" invocation attempt.\");\n               }\n             }\n             invocationFailoverCount++;\n           }\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Object invoke(Object proxy, Method method, Object[] args)\n    throws Throwable {\n    RetryPolicy policy \u003d methodNameToPolicyMap.get(method.getName());\n    if (policy \u003d\u003d null) {\n      policy \u003d defaultPolicy;\n    }\n    \n    // The number of times this method invocation has been failed over.\n    int invocationFailoverCount \u003d 0;\n    final boolean isRpc \u003d isRpcInvocation();\n    final int callId \u003d isRpc? Client.nextCallId(): RpcConstants.INVALID_CALL_ID;\n    int retries \u003d 0;\n    while (true) {\n      // The number of times this invocation handler has ever been failed over,\n      // before this method invocation attempt. Used to prevent concurrent\n      // failed method invocations from triggering multiple failover attempts.\n      long invocationAttemptFailoverCount;\n      synchronized (proxyProvider) {\n        invocationAttemptFailoverCount \u003d proxyProviderFailoverCount;\n      }\n\n      if (isRpc) {\n        Client.setCallIdAndRetryCount(callId, retries);\n      }\n      try {\n        Object ret \u003d invokeMethod(method, args);\n        hasMadeASuccessfulCall \u003d true;\n        return ret;\n      } catch (Exception e) {\n        boolean isMethodIdempotent \u003d proxyProvider.getInterface()\n            .getMethod(method.getName(), method.getParameterTypes())\n            .isAnnotationPresent(Idempotent.class);\n        RetryAction action \u003d policy.shouldRetry(e, retries++,\n            invocationFailoverCount, isMethodIdempotent);\n        if (action.action \u003d\u003d RetryAction.RetryDecision.FAIL) {\n          if (action.reason !\u003d null) {\n            LOG.warn(\"Exception while invoking \" + \n                currentProxy.getClass() + \".\" + method.getName() +\n                \". Not retrying because \" + action.reason, e);\n          }\n          throw e;\n        } else { // retry or failover\n          // avoid logging the failover if this is the first call on this\n          // proxy object, and we successfully achieve the failover without\n          // any flip-flopping\n          boolean worthLogging \u003d \n            !(invocationFailoverCount \u003d\u003d 0 \u0026\u0026 !hasMadeASuccessfulCall);\n          worthLogging |\u003d LOG.isDebugEnabled();\n          if (action.action \u003d\u003d RetryAction.RetryDecision.FAILOVER_AND_RETRY \u0026\u0026\n              worthLogging) {\n            String msg \u003d \"Exception while invoking \" + method.getName()\n              + \" of class \" + currentProxy.getClass().getSimpleName();\n            if (invocationFailoverCount \u003e 0) {\n              msg +\u003d \" after \" + invocationFailoverCount + \" fail over attempts\"; \n            }\n            msg +\u003d \". Trying to fail over \" + formatSleepMessage(action.delayMillis);\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(msg, e);\n            } else {\n              LOG.warn(msg);\n            }\n          } else {\n            if(LOG.isDebugEnabled()) {\n              LOG.debug(\"Exception while invoking \" + method.getName()\n                  + \" of class \" + currentProxy.getClass().getSimpleName() +\n                  \". Retrying \" + formatSleepMessage(action.delayMillis), e);\n            }\n          }\n          \n          if (action.delayMillis \u003e 0) {\n            ThreadUtil.sleepAtLeastIgnoreInterrupts(action.delayMillis);\n          }\n          \n          if (action.action \u003d\u003d RetryAction.RetryDecision.FAILOVER_AND_RETRY) {\n            // Make sure that concurrent failed method invocations only cause a\n            // single actual fail over.\n            synchronized (proxyProvider) {\n              if (invocationAttemptFailoverCount \u003d\u003d proxyProviderFailoverCount) {\n                proxyProvider.performFailover(currentProxy);\n                proxyProviderFailoverCount++;\n                currentProxy \u003d proxyProvider.getProxy();\n              } else {\n                LOG.warn(\"A failover has occurred since the start of this method\"\n                    + \" invocation attempt.\");\n              }\n            }\n            invocationFailoverCount++;\n          }\n        }\n      }\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/retry/RetryInvocationHandler.java",
      "extendedDetails": {}
    },
    "7ec67c5118e8d13e2cb0ab09d04f0609b645a676": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9716. Rpc retries should use the same call ID as the original call.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1504362 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/07/13 9:42 PM",
      "commitName": "7ec67c5118e8d13e2cb0ab09d04f0609b645a676",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "11/06/12 10:27 PM",
      "commitNameOld": "45fafc2b8fc1aab0a082600b0d50ad693491ea70",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 400.97,
      "commitsBetweenForRepo": 2296,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,86 +1,92 @@\n   public Object invoke(Object proxy, Method method, Object[] args)\n     throws Throwable {\n     RetryPolicy policy \u003d methodNameToPolicyMap.get(method.getName());\n     if (policy \u003d\u003d null) {\n       policy \u003d defaultPolicy;\n     }\n     \n     // The number of times this method invocation has been failed over.\n     int invocationFailoverCount \u003d 0;\n+    final boolean isRpc \u003d isRpcInvocation();\n+    final int callId \u003d isRpc? Client.nextCallId(): RpcConstants.INVALID_CALL_ID;\n     int retries \u003d 0;\n     while (true) {\n       // The number of times this invocation handler has ever been failed over,\n       // before this method invocation attempt. Used to prevent concurrent\n       // failed method invocations from triggering multiple failover attempts.\n       long invocationAttemptFailoverCount;\n       synchronized (proxyProvider) {\n         invocationAttemptFailoverCount \u003d proxyProviderFailoverCount;\n       }\n+\n+      if (isRpc) {\n+        Client.setCallId(callId);\n+      }\n       try {\n         Object ret \u003d invokeMethod(method, args);\n         hasMadeASuccessfulCall \u003d true;\n         return ret;\n       } catch (Exception e) {\n         boolean isMethodIdempotent \u003d proxyProvider.getInterface()\n             .getMethod(method.getName(), method.getParameterTypes())\n             .isAnnotationPresent(Idempotent.class);\n         RetryAction action \u003d policy.shouldRetry(e, retries++, invocationFailoverCount,\n             isMethodIdempotent);\n         if (action.action \u003d\u003d RetryAction.RetryDecision.FAIL) {\n           if (action.reason !\u003d null) {\n             LOG.warn(\"Exception while invoking \" + \n                 currentProxy.getClass() + \".\" + method.getName() +\n                 \". Not retrying because \" + action.reason, e);\n           }\n           throw e;\n         } else { // retry or failover\n           // avoid logging the failover if this is the first call on this\n           // proxy object, and we successfully achieve the failover without\n           // any flip-flopping\n           boolean worthLogging \u003d \n             !(invocationFailoverCount \u003d\u003d 0 \u0026\u0026 !hasMadeASuccessfulCall);\n           worthLogging |\u003d LOG.isDebugEnabled();\n           if (action.action \u003d\u003d RetryAction.RetryDecision.FAILOVER_AND_RETRY \u0026\u0026\n               worthLogging) {\n             String msg \u003d \"Exception while invoking \" + method.getName()\n               + \" of class \" + currentProxy.getClass().getSimpleName();\n             if (invocationFailoverCount \u003e 0) {\n               msg +\u003d \" after \" + invocationFailoverCount + \" fail over attempts\"; \n             }\n             msg +\u003d \". Trying to fail over \" + formatSleepMessage(action.delayMillis);\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(msg, e);\n             } else {\n               LOG.warn(msg);\n             }\n           } else {\n             if(LOG.isDebugEnabled()) {\n               LOG.debug(\"Exception while invoking \" + method.getName()\n                   + \" of class \" + currentProxy.getClass().getSimpleName() +\n                   \". Retrying \" + formatSleepMessage(action.delayMillis), e);\n             }\n           }\n           \n           if (action.delayMillis \u003e 0) {\n             ThreadUtil.sleepAtLeastIgnoreInterrupts(action.delayMillis);\n           }\n           \n           if (action.action \u003d\u003d RetryAction.RetryDecision.FAILOVER_AND_RETRY) {\n             // Make sure that concurrent failed method invocations only cause a\n             // single actual fail over.\n             synchronized (proxyProvider) {\n               if (invocationAttemptFailoverCount \u003d\u003d proxyProviderFailoverCount) {\n                 proxyProvider.performFailover(currentProxy);\n                 proxyProviderFailoverCount++;\n                 currentProxy \u003d proxyProvider.getProxy();\n               } else {\n                 LOG.warn(\"A failover has occurred since the start of this method\"\n                     + \" invocation attempt.\");\n               }\n             }\n             invocationFailoverCount++;\n           }\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Object invoke(Object proxy, Method method, Object[] args)\n    throws Throwable {\n    RetryPolicy policy \u003d methodNameToPolicyMap.get(method.getName());\n    if (policy \u003d\u003d null) {\n      policy \u003d defaultPolicy;\n    }\n    \n    // The number of times this method invocation has been failed over.\n    int invocationFailoverCount \u003d 0;\n    final boolean isRpc \u003d isRpcInvocation();\n    final int callId \u003d isRpc? Client.nextCallId(): RpcConstants.INVALID_CALL_ID;\n    int retries \u003d 0;\n    while (true) {\n      // The number of times this invocation handler has ever been failed over,\n      // before this method invocation attempt. Used to prevent concurrent\n      // failed method invocations from triggering multiple failover attempts.\n      long invocationAttemptFailoverCount;\n      synchronized (proxyProvider) {\n        invocationAttemptFailoverCount \u003d proxyProviderFailoverCount;\n      }\n\n      if (isRpc) {\n        Client.setCallId(callId);\n      }\n      try {\n        Object ret \u003d invokeMethod(method, args);\n        hasMadeASuccessfulCall \u003d true;\n        return ret;\n      } catch (Exception e) {\n        boolean isMethodIdempotent \u003d proxyProvider.getInterface()\n            .getMethod(method.getName(), method.getParameterTypes())\n            .isAnnotationPresent(Idempotent.class);\n        RetryAction action \u003d policy.shouldRetry(e, retries++, invocationFailoverCount,\n            isMethodIdempotent);\n        if (action.action \u003d\u003d RetryAction.RetryDecision.FAIL) {\n          if (action.reason !\u003d null) {\n            LOG.warn(\"Exception while invoking \" + \n                currentProxy.getClass() + \".\" + method.getName() +\n                \". Not retrying because \" + action.reason, e);\n          }\n          throw e;\n        } else { // retry or failover\n          // avoid logging the failover if this is the first call on this\n          // proxy object, and we successfully achieve the failover without\n          // any flip-flopping\n          boolean worthLogging \u003d \n            !(invocationFailoverCount \u003d\u003d 0 \u0026\u0026 !hasMadeASuccessfulCall);\n          worthLogging |\u003d LOG.isDebugEnabled();\n          if (action.action \u003d\u003d RetryAction.RetryDecision.FAILOVER_AND_RETRY \u0026\u0026\n              worthLogging) {\n            String msg \u003d \"Exception while invoking \" + method.getName()\n              + \" of class \" + currentProxy.getClass().getSimpleName();\n            if (invocationFailoverCount \u003e 0) {\n              msg +\u003d \" after \" + invocationFailoverCount + \" fail over attempts\"; \n            }\n            msg +\u003d \". Trying to fail over \" + formatSleepMessage(action.delayMillis);\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(msg, e);\n            } else {\n              LOG.warn(msg);\n            }\n          } else {\n            if(LOG.isDebugEnabled()) {\n              LOG.debug(\"Exception while invoking \" + method.getName()\n                  + \" of class \" + currentProxy.getClass().getSimpleName() +\n                  \". Retrying \" + formatSleepMessage(action.delayMillis), e);\n            }\n          }\n          \n          if (action.delayMillis \u003e 0) {\n            ThreadUtil.sleepAtLeastIgnoreInterrupts(action.delayMillis);\n          }\n          \n          if (action.action \u003d\u003d RetryAction.RetryDecision.FAILOVER_AND_RETRY) {\n            // Make sure that concurrent failed method invocations only cause a\n            // single actual fail over.\n            synchronized (proxyProvider) {\n              if (invocationAttemptFailoverCount \u003d\u003d proxyProviderFailoverCount) {\n                proxyProvider.performFailover(currentProxy);\n                proxyProviderFailoverCount++;\n                currentProxy \u003d proxyProvider.getProxy();\n              } else {\n                LOG.warn(\"A failover has occurred since the start of this method\"\n                    + \" invocation attempt.\");\n              }\n            }\n            invocationFailoverCount++;\n          }\n        }\n      }\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/retry/RetryInvocationHandler.java",
      "extendedDetails": {}
    },
    "cdc8146bd46ae8bf3395498c529513730d446824": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-8068. void methods can swallow exceptions when going through failover path. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1244628 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "15/02/12 10:20 AM",
      "commitName": "cdc8146bd46ae8bf3395498c529513730d446824",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "10/02/12 10:17 AM",
      "commitNameOld": "a626fa04f983623b1e2c00189df6f0b83b806b5f",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 5.0,
      "commitsBetweenForRepo": 24,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,86 +1,86 @@\n   public Object invoke(Object proxy, Method method, Object[] args)\n     throws Throwable {\n     RetryPolicy policy \u003d methodNameToPolicyMap.get(method.getName());\n     if (policy \u003d\u003d null) {\n       policy \u003d defaultPolicy;\n     }\n     \n     // The number of times this method invocation has been failed over.\n     int invocationFailoverCount \u003d 0;\n     int retries \u003d 0;\n     while (true) {\n       // The number of times this invocation handler has ever been failed over,\n       // before this method invocation attempt. Used to prevent concurrent\n       // failed method invocations from triggering multiple failover attempts.\n       long invocationAttemptFailoverCount;\n       synchronized (proxyProvider) {\n         invocationAttemptFailoverCount \u003d proxyProviderFailoverCount;\n       }\n       try {\n         Object ret \u003d invokeMethod(method, args);\n         hasMadeASuccessfulCall \u003d true;\n         return ret;\n       } catch (Exception e) {\n         boolean isMethodIdempotent \u003d proxyProvider.getInterface()\n             .getMethod(method.getName(), method.getParameterTypes())\n             .isAnnotationPresent(Idempotent.class);\n         RetryAction action \u003d policy.shouldRetry(e, retries++, invocationFailoverCount,\n             isMethodIdempotent);\n         if (action.action \u003d\u003d RetryAction.RetryDecision.FAIL) {\n-          LOG.warn(\"Exception while invoking \" + method.getName()\n-                   + \" of \" + currentProxy.getClass() + \". Not retrying.\", e);\n-          if (!method.getReturnType().equals(Void.TYPE)) {\n-            throw e; // non-void methods can\u0027t fail without an exception\n+          if (action.reason !\u003d null) {\n+            LOG.warn(\"Exception while invoking \" + \n+                currentProxy.getClass() + \".\" + method.getName() +\n+                \". Not retrying because \" + action.reason, e);\n           }\n-          return null;\n+          throw e;\n         } else { // retry or failover\n           // avoid logging the failover if this is the first call on this\n           // proxy object, and we successfully achieve the failover without\n           // any flip-flopping\n           boolean worthLogging \u003d \n             !(invocationFailoverCount \u003d\u003d 0 \u0026\u0026 !hasMadeASuccessfulCall);\n           worthLogging |\u003d LOG.isDebugEnabled();\n           if (action.action \u003d\u003d RetryAction.RetryDecision.FAILOVER_AND_RETRY \u0026\u0026\n               worthLogging) {\n             String msg \u003d \"Exception while invoking \" + method.getName()\n               + \" of class \" + currentProxy.getClass().getSimpleName();\n             if (invocationFailoverCount \u003e 0) {\n               msg +\u003d \" after \" + invocationFailoverCount + \" fail over attempts\"; \n             }\n             msg +\u003d \". Trying to fail over \" + formatSleepMessage(action.delayMillis);\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(msg, e);\n             } else {\n               LOG.warn(msg);\n             }\n           } else {\n             if(LOG.isDebugEnabled()) {\n               LOG.debug(\"Exception while invoking \" + method.getName()\n                   + \" of class \" + currentProxy.getClass().getSimpleName() +\n                   \". Retrying \" + formatSleepMessage(action.delayMillis), e);\n             }\n           }\n           \n           if (action.delayMillis \u003e 0) {\n             ThreadUtil.sleepAtLeastIgnoreInterrupts(action.delayMillis);\n           }\n           \n           if (action.action \u003d\u003d RetryAction.RetryDecision.FAILOVER_AND_RETRY) {\n             // Make sure that concurrent failed method invocations only cause a\n             // single actual fail over.\n             synchronized (proxyProvider) {\n               if (invocationAttemptFailoverCount \u003d\u003d proxyProviderFailoverCount) {\n                 proxyProvider.performFailover(currentProxy);\n                 proxyProviderFailoverCount++;\n                 currentProxy \u003d proxyProvider.getProxy();\n               } else {\n                 LOG.warn(\"A failover has occurred since the start of this method\"\n                     + \" invocation attempt.\");\n               }\n             }\n             invocationFailoverCount++;\n           }\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Object invoke(Object proxy, Method method, Object[] args)\n    throws Throwable {\n    RetryPolicy policy \u003d methodNameToPolicyMap.get(method.getName());\n    if (policy \u003d\u003d null) {\n      policy \u003d defaultPolicy;\n    }\n    \n    // The number of times this method invocation has been failed over.\n    int invocationFailoverCount \u003d 0;\n    int retries \u003d 0;\n    while (true) {\n      // The number of times this invocation handler has ever been failed over,\n      // before this method invocation attempt. Used to prevent concurrent\n      // failed method invocations from triggering multiple failover attempts.\n      long invocationAttemptFailoverCount;\n      synchronized (proxyProvider) {\n        invocationAttemptFailoverCount \u003d proxyProviderFailoverCount;\n      }\n      try {\n        Object ret \u003d invokeMethod(method, args);\n        hasMadeASuccessfulCall \u003d true;\n        return ret;\n      } catch (Exception e) {\n        boolean isMethodIdempotent \u003d proxyProvider.getInterface()\n            .getMethod(method.getName(), method.getParameterTypes())\n            .isAnnotationPresent(Idempotent.class);\n        RetryAction action \u003d policy.shouldRetry(e, retries++, invocationFailoverCount,\n            isMethodIdempotent);\n        if (action.action \u003d\u003d RetryAction.RetryDecision.FAIL) {\n          if (action.reason !\u003d null) {\n            LOG.warn(\"Exception while invoking \" + \n                currentProxy.getClass() + \".\" + method.getName() +\n                \". Not retrying because \" + action.reason, e);\n          }\n          throw e;\n        } else { // retry or failover\n          // avoid logging the failover if this is the first call on this\n          // proxy object, and we successfully achieve the failover without\n          // any flip-flopping\n          boolean worthLogging \u003d \n            !(invocationFailoverCount \u003d\u003d 0 \u0026\u0026 !hasMadeASuccessfulCall);\n          worthLogging |\u003d LOG.isDebugEnabled();\n          if (action.action \u003d\u003d RetryAction.RetryDecision.FAILOVER_AND_RETRY \u0026\u0026\n              worthLogging) {\n            String msg \u003d \"Exception while invoking \" + method.getName()\n              + \" of class \" + currentProxy.getClass().getSimpleName();\n            if (invocationFailoverCount \u003e 0) {\n              msg +\u003d \" after \" + invocationFailoverCount + \" fail over attempts\"; \n            }\n            msg +\u003d \". Trying to fail over \" + formatSleepMessage(action.delayMillis);\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(msg, e);\n            } else {\n              LOG.warn(msg);\n            }\n          } else {\n            if(LOG.isDebugEnabled()) {\n              LOG.debug(\"Exception while invoking \" + method.getName()\n                  + \" of class \" + currentProxy.getClass().getSimpleName() +\n                  \". Retrying \" + formatSleepMessage(action.delayMillis), e);\n            }\n          }\n          \n          if (action.delayMillis \u003e 0) {\n            ThreadUtil.sleepAtLeastIgnoreInterrupts(action.delayMillis);\n          }\n          \n          if (action.action \u003d\u003d RetryAction.RetryDecision.FAILOVER_AND_RETRY) {\n            // Make sure that concurrent failed method invocations only cause a\n            // single actual fail over.\n            synchronized (proxyProvider) {\n              if (invocationAttemptFailoverCount \u003d\u003d proxyProviderFailoverCount) {\n                proxyProvider.performFailover(currentProxy);\n                proxyProviderFailoverCount++;\n                currentProxy \u003d proxyProvider.getProxy();\n              } else {\n                LOG.warn(\"A failover has occurred since the start of this method\"\n                    + \" invocation attempt.\");\n              }\n            }\n            invocationFailoverCount++;\n          }\n        }\n      }\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/retry/RetryInvocationHandler.java",
      "extendedDetails": {}
    },
    "a626fa04f983623b1e2c00189df6f0b83b806b5f": {
      "type": "Ybodychange",
      "commitMessage": "Revert HDFS-2922 via svn merge -c -1242572\n\nThe patch broke a lot of unit tests in the nightly build. Will recommit after it is fixed.\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1242874 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/02/12 10:17 AM",
      "commitName": "a626fa04f983623b1e2c00189df6f0b83b806b5f",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "09/02/12 2:33 PM",
      "commitNameOld": "a63e12c4c8b6d637eb6ab04f84de183e8d34bb00",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 0.82,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,84 +1,86 @@\n   public Object invoke(Object proxy, Method method, Object[] args)\n     throws Throwable {\n     RetryPolicy policy \u003d methodNameToPolicyMap.get(method.getName());\n     if (policy \u003d\u003d null) {\n       policy \u003d defaultPolicy;\n     }\n     \n     // The number of times this method invocation has been failed over.\n     int invocationFailoverCount \u003d 0;\n     int retries \u003d 0;\n     while (true) {\n       // The number of times this invocation handler has ever been failed over,\n       // before this method invocation attempt. Used to prevent concurrent\n       // failed method invocations from triggering multiple failover attempts.\n       long invocationAttemptFailoverCount;\n       synchronized (proxyProvider) {\n         invocationAttemptFailoverCount \u003d proxyProviderFailoverCount;\n       }\n       try {\n         Object ret \u003d invokeMethod(method, args);\n         hasMadeASuccessfulCall \u003d true;\n         return ret;\n       } catch (Exception e) {\n         boolean isMethodIdempotent \u003d proxyProvider.getInterface()\n             .getMethod(method.getName(), method.getParameterTypes())\n             .isAnnotationPresent(Idempotent.class);\n         RetryAction action \u003d policy.shouldRetry(e, retries++, invocationFailoverCount,\n             isMethodIdempotent);\n         if (action.action \u003d\u003d RetryAction.RetryDecision.FAIL) {\n           LOG.warn(\"Exception while invoking \" + method.getName()\n                    + \" of \" + currentProxy.getClass() + \". Not retrying.\", e);\n           if (!method.getReturnType().equals(Void.TYPE)) {\n             throw e; // non-void methods can\u0027t fail without an exception\n           }\n           return null;\n         } else { // retry or failover\n           // avoid logging the failover if this is the first call on this\n           // proxy object, and we successfully achieve the failover without\n           // any flip-flopping\n           boolean worthLogging \u003d \n             !(invocationFailoverCount \u003d\u003d 0 \u0026\u0026 !hasMadeASuccessfulCall);\n           worthLogging |\u003d LOG.isDebugEnabled();\n           if (action.action \u003d\u003d RetryAction.RetryDecision.FAILOVER_AND_RETRY \u0026\u0026\n               worthLogging) {\n             String msg \u003d \"Exception while invoking \" + method.getName()\n               + \" of class \" + currentProxy.getClass().getSimpleName();\n             if (invocationFailoverCount \u003e 0) {\n               msg +\u003d \" after \" + invocationFailoverCount + \" fail over attempts\"; \n             }\n             msg +\u003d \". Trying to fail over \" + formatSleepMessage(action.delayMillis);\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(msg, e);\n+            } else {\n+              LOG.warn(msg);\n             }\n           } else {\n             if(LOG.isDebugEnabled()) {\n               LOG.debug(\"Exception while invoking \" + method.getName()\n                   + \" of class \" + currentProxy.getClass().getSimpleName() +\n                   \". Retrying \" + formatSleepMessage(action.delayMillis), e);\n             }\n           }\n           \n           if (action.delayMillis \u003e 0) {\n             ThreadUtil.sleepAtLeastIgnoreInterrupts(action.delayMillis);\n           }\n           \n           if (action.action \u003d\u003d RetryAction.RetryDecision.FAILOVER_AND_RETRY) {\n             // Make sure that concurrent failed method invocations only cause a\n             // single actual fail over.\n             synchronized (proxyProvider) {\n               if (invocationAttemptFailoverCount \u003d\u003d proxyProviderFailoverCount) {\n                 proxyProvider.performFailover(currentProxy);\n                 proxyProviderFailoverCount++;\n                 currentProxy \u003d proxyProvider.getProxy();\n               } else {\n                 LOG.warn(\"A failover has occurred since the start of this method\"\n                     + \" invocation attempt.\");\n               }\n             }\n             invocationFailoverCount++;\n           }\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Object invoke(Object proxy, Method method, Object[] args)\n    throws Throwable {\n    RetryPolicy policy \u003d methodNameToPolicyMap.get(method.getName());\n    if (policy \u003d\u003d null) {\n      policy \u003d defaultPolicy;\n    }\n    \n    // The number of times this method invocation has been failed over.\n    int invocationFailoverCount \u003d 0;\n    int retries \u003d 0;\n    while (true) {\n      // The number of times this invocation handler has ever been failed over,\n      // before this method invocation attempt. Used to prevent concurrent\n      // failed method invocations from triggering multiple failover attempts.\n      long invocationAttemptFailoverCount;\n      synchronized (proxyProvider) {\n        invocationAttemptFailoverCount \u003d proxyProviderFailoverCount;\n      }\n      try {\n        Object ret \u003d invokeMethod(method, args);\n        hasMadeASuccessfulCall \u003d true;\n        return ret;\n      } catch (Exception e) {\n        boolean isMethodIdempotent \u003d proxyProvider.getInterface()\n            .getMethod(method.getName(), method.getParameterTypes())\n            .isAnnotationPresent(Idempotent.class);\n        RetryAction action \u003d policy.shouldRetry(e, retries++, invocationFailoverCount,\n            isMethodIdempotent);\n        if (action.action \u003d\u003d RetryAction.RetryDecision.FAIL) {\n          LOG.warn(\"Exception while invoking \" + method.getName()\n                   + \" of \" + currentProxy.getClass() + \". Not retrying.\", e);\n          if (!method.getReturnType().equals(Void.TYPE)) {\n            throw e; // non-void methods can\u0027t fail without an exception\n          }\n          return null;\n        } else { // retry or failover\n          // avoid logging the failover if this is the first call on this\n          // proxy object, and we successfully achieve the failover without\n          // any flip-flopping\n          boolean worthLogging \u003d \n            !(invocationFailoverCount \u003d\u003d 0 \u0026\u0026 !hasMadeASuccessfulCall);\n          worthLogging |\u003d LOG.isDebugEnabled();\n          if (action.action \u003d\u003d RetryAction.RetryDecision.FAILOVER_AND_RETRY \u0026\u0026\n              worthLogging) {\n            String msg \u003d \"Exception while invoking \" + method.getName()\n              + \" of class \" + currentProxy.getClass().getSimpleName();\n            if (invocationFailoverCount \u003e 0) {\n              msg +\u003d \" after \" + invocationFailoverCount + \" fail over attempts\"; \n            }\n            msg +\u003d \". Trying to fail over \" + formatSleepMessage(action.delayMillis);\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(msg, e);\n            } else {\n              LOG.warn(msg);\n            }\n          } else {\n            if(LOG.isDebugEnabled()) {\n              LOG.debug(\"Exception while invoking \" + method.getName()\n                  + \" of class \" + currentProxy.getClass().getSimpleName() +\n                  \". Retrying \" + formatSleepMessage(action.delayMillis), e);\n            }\n          }\n          \n          if (action.delayMillis \u003e 0) {\n            ThreadUtil.sleepAtLeastIgnoreInterrupts(action.delayMillis);\n          }\n          \n          if (action.action \u003d\u003d RetryAction.RetryDecision.FAILOVER_AND_RETRY) {\n            // Make sure that concurrent failed method invocations only cause a\n            // single actual fail over.\n            synchronized (proxyProvider) {\n              if (invocationAttemptFailoverCount \u003d\u003d proxyProviderFailoverCount) {\n                proxyProvider.performFailover(currentProxy);\n                proxyProviderFailoverCount++;\n                currentProxy \u003d proxyProvider.getProxy();\n              } else {\n                LOG.warn(\"A failover has occurred since the start of this method\"\n                    + \" invocation attempt.\");\n              }\n            }\n            invocationFailoverCount++;\n          }\n        }\n      }\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/retry/RetryInvocationHandler.java",
      "extendedDetails": {}
    },
    "a63e12c4c8b6d637eb6ab04f84de183e8d34bb00": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2922. HA: close out operation categories. Contributed by Eli Collins\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1242572 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/02/12 2:33 PM",
      "commitName": "a63e12c4c8b6d637eb6ab04f84de183e8d34bb00",
      "commitAuthor": "Eli Collins",
      "commitDateOld": "09/02/12 10:25 AM",
      "commitNameOld": "1b4c990b61fa4527e6dd4e8bb7e10f1c11ad280f",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 0.17,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,86 +1,84 @@\n   public Object invoke(Object proxy, Method method, Object[] args)\n     throws Throwable {\n     RetryPolicy policy \u003d methodNameToPolicyMap.get(method.getName());\n     if (policy \u003d\u003d null) {\n       policy \u003d defaultPolicy;\n     }\n     \n     // The number of times this method invocation has been failed over.\n     int invocationFailoverCount \u003d 0;\n     int retries \u003d 0;\n     while (true) {\n       // The number of times this invocation handler has ever been failed over,\n       // before this method invocation attempt. Used to prevent concurrent\n       // failed method invocations from triggering multiple failover attempts.\n       long invocationAttemptFailoverCount;\n       synchronized (proxyProvider) {\n         invocationAttemptFailoverCount \u003d proxyProviderFailoverCount;\n       }\n       try {\n         Object ret \u003d invokeMethod(method, args);\n         hasMadeASuccessfulCall \u003d true;\n         return ret;\n       } catch (Exception e) {\n         boolean isMethodIdempotent \u003d proxyProvider.getInterface()\n             .getMethod(method.getName(), method.getParameterTypes())\n             .isAnnotationPresent(Idempotent.class);\n         RetryAction action \u003d policy.shouldRetry(e, retries++, invocationFailoverCount,\n             isMethodIdempotent);\n         if (action.action \u003d\u003d RetryAction.RetryDecision.FAIL) {\n           LOG.warn(\"Exception while invoking \" + method.getName()\n                    + \" of \" + currentProxy.getClass() + \". Not retrying.\", e);\n           if (!method.getReturnType().equals(Void.TYPE)) {\n             throw e; // non-void methods can\u0027t fail without an exception\n           }\n           return null;\n         } else { // retry or failover\n           // avoid logging the failover if this is the first call on this\n           // proxy object, and we successfully achieve the failover without\n           // any flip-flopping\n           boolean worthLogging \u003d \n             !(invocationFailoverCount \u003d\u003d 0 \u0026\u0026 !hasMadeASuccessfulCall);\n           worthLogging |\u003d LOG.isDebugEnabled();\n           if (action.action \u003d\u003d RetryAction.RetryDecision.FAILOVER_AND_RETRY \u0026\u0026\n               worthLogging) {\n             String msg \u003d \"Exception while invoking \" + method.getName()\n               + \" of class \" + currentProxy.getClass().getSimpleName();\n             if (invocationFailoverCount \u003e 0) {\n               msg +\u003d \" after \" + invocationFailoverCount + \" fail over attempts\"; \n             }\n             msg +\u003d \". Trying to fail over \" + formatSleepMessage(action.delayMillis);\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(msg, e);\n-            } else {\n-              LOG.warn(msg);\n             }\n           } else {\n             if(LOG.isDebugEnabled()) {\n               LOG.debug(\"Exception while invoking \" + method.getName()\n                   + \" of class \" + currentProxy.getClass().getSimpleName() +\n                   \". Retrying \" + formatSleepMessage(action.delayMillis), e);\n             }\n           }\n           \n           if (action.delayMillis \u003e 0) {\n             ThreadUtil.sleepAtLeastIgnoreInterrupts(action.delayMillis);\n           }\n           \n           if (action.action \u003d\u003d RetryAction.RetryDecision.FAILOVER_AND_RETRY) {\n             // Make sure that concurrent failed method invocations only cause a\n             // single actual fail over.\n             synchronized (proxyProvider) {\n               if (invocationAttemptFailoverCount \u003d\u003d proxyProviderFailoverCount) {\n                 proxyProvider.performFailover(currentProxy);\n                 proxyProviderFailoverCount++;\n                 currentProxy \u003d proxyProvider.getProxy();\n               } else {\n                 LOG.warn(\"A failover has occurred since the start of this method\"\n                     + \" invocation attempt.\");\n               }\n             }\n             invocationFailoverCount++;\n           }\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Object invoke(Object proxy, Method method, Object[] args)\n    throws Throwable {\n    RetryPolicy policy \u003d methodNameToPolicyMap.get(method.getName());\n    if (policy \u003d\u003d null) {\n      policy \u003d defaultPolicy;\n    }\n    \n    // The number of times this method invocation has been failed over.\n    int invocationFailoverCount \u003d 0;\n    int retries \u003d 0;\n    while (true) {\n      // The number of times this invocation handler has ever been failed over,\n      // before this method invocation attempt. Used to prevent concurrent\n      // failed method invocations from triggering multiple failover attempts.\n      long invocationAttemptFailoverCount;\n      synchronized (proxyProvider) {\n        invocationAttemptFailoverCount \u003d proxyProviderFailoverCount;\n      }\n      try {\n        Object ret \u003d invokeMethod(method, args);\n        hasMadeASuccessfulCall \u003d true;\n        return ret;\n      } catch (Exception e) {\n        boolean isMethodIdempotent \u003d proxyProvider.getInterface()\n            .getMethod(method.getName(), method.getParameterTypes())\n            .isAnnotationPresent(Idempotent.class);\n        RetryAction action \u003d policy.shouldRetry(e, retries++, invocationFailoverCount,\n            isMethodIdempotent);\n        if (action.action \u003d\u003d RetryAction.RetryDecision.FAIL) {\n          LOG.warn(\"Exception while invoking \" + method.getName()\n                   + \" of \" + currentProxy.getClass() + \". Not retrying.\", e);\n          if (!method.getReturnType().equals(Void.TYPE)) {\n            throw e; // non-void methods can\u0027t fail without an exception\n          }\n          return null;\n        } else { // retry or failover\n          // avoid logging the failover if this is the first call on this\n          // proxy object, and we successfully achieve the failover without\n          // any flip-flopping\n          boolean worthLogging \u003d \n            !(invocationFailoverCount \u003d\u003d 0 \u0026\u0026 !hasMadeASuccessfulCall);\n          worthLogging |\u003d LOG.isDebugEnabled();\n          if (action.action \u003d\u003d RetryAction.RetryDecision.FAILOVER_AND_RETRY \u0026\u0026\n              worthLogging) {\n            String msg \u003d \"Exception while invoking \" + method.getName()\n              + \" of class \" + currentProxy.getClass().getSimpleName();\n            if (invocationFailoverCount \u003e 0) {\n              msg +\u003d \" after \" + invocationFailoverCount + \" fail over attempts\"; \n            }\n            msg +\u003d \". Trying to fail over \" + formatSleepMessage(action.delayMillis);\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(msg, e);\n            }\n          } else {\n            if(LOG.isDebugEnabled()) {\n              LOG.debug(\"Exception while invoking \" + method.getName()\n                  + \" of class \" + currentProxy.getClass().getSimpleName() +\n                  \". Retrying \" + formatSleepMessage(action.delayMillis), e);\n            }\n          }\n          \n          if (action.delayMillis \u003e 0) {\n            ThreadUtil.sleepAtLeastIgnoreInterrupts(action.delayMillis);\n          }\n          \n          if (action.action \u003d\u003d RetryAction.RetryDecision.FAILOVER_AND_RETRY) {\n            // Make sure that concurrent failed method invocations only cause a\n            // single actual fail over.\n            synchronized (proxyProvider) {\n              if (invocationAttemptFailoverCount \u003d\u003d proxyProviderFailoverCount) {\n                proxyProvider.performFailover(currentProxy);\n                proxyProviderFailoverCount++;\n                currentProxy \u003d proxyProvider.getProxy();\n              } else {\n                LOG.warn(\"A failover has occurred since the start of this method\"\n                    + \" invocation attempt.\");\n              }\n            }\n            invocationFailoverCount++;\n          }\n        }\n      }\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/retry/RetryInvocationHandler.java",
      "extendedDetails": {}
    },
    "1b4c990b61fa4527e6dd4e8bb7e10f1c11ad280f": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-8041. Log a warning when a failover is first attempted. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1242441 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/02/12 10:25 AM",
      "commitName": "1b4c990b61fa4527e6dd4e8bb7e10f1c11ad280f",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "03/02/12 7:10 PM",
      "commitNameOld": "ec6961b39c6e05a1ed0016e815c2e17c052d2462",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 5.64,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,76 +1,86 @@\n   public Object invoke(Object proxy, Method method, Object[] args)\n     throws Throwable {\n     RetryPolicy policy \u003d methodNameToPolicyMap.get(method.getName());\n     if (policy \u003d\u003d null) {\n       policy \u003d defaultPolicy;\n     }\n     \n     // The number of times this method invocation has been failed over.\n     int invocationFailoverCount \u003d 0;\n     int retries \u003d 0;\n     while (true) {\n       // The number of times this invocation handler has ever been failed over,\n       // before this method invocation attempt. Used to prevent concurrent\n       // failed method invocations from triggering multiple failover attempts.\n       long invocationAttemptFailoverCount;\n       synchronized (proxyProvider) {\n         invocationAttemptFailoverCount \u003d proxyProviderFailoverCount;\n       }\n       try {\n-        return invokeMethod(method, args);\n+        Object ret \u003d invokeMethod(method, args);\n+        hasMadeASuccessfulCall \u003d true;\n+        return ret;\n       } catch (Exception e) {\n         boolean isMethodIdempotent \u003d proxyProvider.getInterface()\n             .getMethod(method.getName(), method.getParameterTypes())\n             .isAnnotationPresent(Idempotent.class);\n         RetryAction action \u003d policy.shouldRetry(e, retries++, invocationFailoverCount,\n             isMethodIdempotent);\n         if (action.action \u003d\u003d RetryAction.RetryDecision.FAIL) {\n           LOG.warn(\"Exception while invoking \" + method.getName()\n                    + \" of \" + currentProxy.getClass() + \". Not retrying.\", e);\n           if (!method.getReturnType().equals(Void.TYPE)) {\n             throw e; // non-void methods can\u0027t fail without an exception\n           }\n           return null;\n         } else { // retry or failover\n-\n-          if (action.action \u003d\u003d RetryAction.RetryDecision.FAILOVER_AND_RETRY) {\n+          // avoid logging the failover if this is the first call on this\n+          // proxy object, and we successfully achieve the failover without\n+          // any flip-flopping\n+          boolean worthLogging \u003d \n+            !(invocationFailoverCount \u003d\u003d 0 \u0026\u0026 !hasMadeASuccessfulCall);\n+          worthLogging |\u003d LOG.isDebugEnabled();\n+          if (action.action \u003d\u003d RetryAction.RetryDecision.FAILOVER_AND_RETRY \u0026\u0026\n+              worthLogging) {\n             String msg \u003d \"Exception while invoking \" + method.getName()\n-              + \" of \" + currentProxy.getClass()\n-              + \" after \" + invocationFailoverCount + \" fail over attempts.\"\n-              + \" Trying to fail over \" + formatSleepMessage(action.delayMillis);\n+              + \" of class \" + currentProxy.getClass().getSimpleName();\n+            if (invocationFailoverCount \u003e 0) {\n+              msg +\u003d \" after \" + invocationFailoverCount + \" fail over attempts\"; \n+            }\n+            msg +\u003d \". Trying to fail over \" + formatSleepMessage(action.delayMillis);\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(msg, e);\n             } else {\n               LOG.warn(msg);\n             }\n           } else {\n             if(LOG.isDebugEnabled()) {\n               LOG.debug(\"Exception while invoking \" + method.getName()\n-                  + \" of \" + currentProxy.getClass() + \". Retrying \" +\n-                  formatSleepMessage(action.delayMillis), e);\n+                  + \" of class \" + currentProxy.getClass().getSimpleName() +\n+                  \". Retrying \" + formatSleepMessage(action.delayMillis), e);\n             }\n           }\n           \n           if (action.delayMillis \u003e 0) {\n             ThreadUtil.sleepAtLeastIgnoreInterrupts(action.delayMillis);\n           }\n           \n           if (action.action \u003d\u003d RetryAction.RetryDecision.FAILOVER_AND_RETRY) {\n             // Make sure that concurrent failed method invocations only cause a\n             // single actual fail over.\n             synchronized (proxyProvider) {\n               if (invocationAttemptFailoverCount \u003d\u003d proxyProviderFailoverCount) {\n                 proxyProvider.performFailover(currentProxy);\n                 proxyProviderFailoverCount++;\n                 currentProxy \u003d proxyProvider.getProxy();\n               } else {\n                 LOG.warn(\"A failover has occurred since the start of this method\"\n                     + \" invocation attempt.\");\n               }\n             }\n             invocationFailoverCount++;\n           }\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Object invoke(Object proxy, Method method, Object[] args)\n    throws Throwable {\n    RetryPolicy policy \u003d methodNameToPolicyMap.get(method.getName());\n    if (policy \u003d\u003d null) {\n      policy \u003d defaultPolicy;\n    }\n    \n    // The number of times this method invocation has been failed over.\n    int invocationFailoverCount \u003d 0;\n    int retries \u003d 0;\n    while (true) {\n      // The number of times this invocation handler has ever been failed over,\n      // before this method invocation attempt. Used to prevent concurrent\n      // failed method invocations from triggering multiple failover attempts.\n      long invocationAttemptFailoverCount;\n      synchronized (proxyProvider) {\n        invocationAttemptFailoverCount \u003d proxyProviderFailoverCount;\n      }\n      try {\n        Object ret \u003d invokeMethod(method, args);\n        hasMadeASuccessfulCall \u003d true;\n        return ret;\n      } catch (Exception e) {\n        boolean isMethodIdempotent \u003d proxyProvider.getInterface()\n            .getMethod(method.getName(), method.getParameterTypes())\n            .isAnnotationPresent(Idempotent.class);\n        RetryAction action \u003d policy.shouldRetry(e, retries++, invocationFailoverCount,\n            isMethodIdempotent);\n        if (action.action \u003d\u003d RetryAction.RetryDecision.FAIL) {\n          LOG.warn(\"Exception while invoking \" + method.getName()\n                   + \" of \" + currentProxy.getClass() + \". Not retrying.\", e);\n          if (!method.getReturnType().equals(Void.TYPE)) {\n            throw e; // non-void methods can\u0027t fail without an exception\n          }\n          return null;\n        } else { // retry or failover\n          // avoid logging the failover if this is the first call on this\n          // proxy object, and we successfully achieve the failover without\n          // any flip-flopping\n          boolean worthLogging \u003d \n            !(invocationFailoverCount \u003d\u003d 0 \u0026\u0026 !hasMadeASuccessfulCall);\n          worthLogging |\u003d LOG.isDebugEnabled();\n          if (action.action \u003d\u003d RetryAction.RetryDecision.FAILOVER_AND_RETRY \u0026\u0026\n              worthLogging) {\n            String msg \u003d \"Exception while invoking \" + method.getName()\n              + \" of class \" + currentProxy.getClass().getSimpleName();\n            if (invocationFailoverCount \u003e 0) {\n              msg +\u003d \" after \" + invocationFailoverCount + \" fail over attempts\"; \n            }\n            msg +\u003d \". Trying to fail over \" + formatSleepMessage(action.delayMillis);\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(msg, e);\n            } else {\n              LOG.warn(msg);\n            }\n          } else {\n            if(LOG.isDebugEnabled()) {\n              LOG.debug(\"Exception while invoking \" + method.getName()\n                  + \" of class \" + currentProxy.getClass().getSimpleName() +\n                  \". Retrying \" + formatSleepMessage(action.delayMillis), e);\n            }\n          }\n          \n          if (action.delayMillis \u003e 0) {\n            ThreadUtil.sleepAtLeastIgnoreInterrupts(action.delayMillis);\n          }\n          \n          if (action.action \u003d\u003d RetryAction.RetryDecision.FAILOVER_AND_RETRY) {\n            // Make sure that concurrent failed method invocations only cause a\n            // single actual fail over.\n            synchronized (proxyProvider) {\n              if (invocationAttemptFailoverCount \u003d\u003d proxyProviderFailoverCount) {\n                proxyProvider.performFailover(currentProxy);\n                proxyProviderFailoverCount++;\n                currentProxy \u003d proxyProvider.getProxy();\n              } else {\n                LOG.warn(\"A failover has occurred since the start of this method\"\n                    + \" invocation attempt.\");\n              }\n            }\n            invocationFailoverCount++;\n          }\n        }\n      }\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/retry/RetryInvocationHandler.java",
      "extendedDetails": {}
    },
    "9cf3e0805f5967d1ed792c32728ab826fb7c927b": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-7922. Improve some logging for client IPC failovers and StandbyExceptions. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1214082 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "13/12/11 11:51 PM",
      "commitName": "9cf3e0805f5967d1ed792c32728ab826fb7c927b",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "13/12/11 11:24 PM",
      "commitNameOld": "9818091a66b9c8e337de9d4e18655cf4b157056b",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,66 +1,76 @@\n   public Object invoke(Object proxy, Method method, Object[] args)\n     throws Throwable {\n     RetryPolicy policy \u003d methodNameToPolicyMap.get(method.getName());\n     if (policy \u003d\u003d null) {\n       policy \u003d defaultPolicy;\n     }\n     \n     // The number of times this method invocation has been failed over.\n     int invocationFailoverCount \u003d 0;\n     int retries \u003d 0;\n     while (true) {\n       // The number of times this invocation handler has ever been failed over,\n       // before this method invocation attempt. Used to prevent concurrent\n       // failed method invocations from triggering multiple failover attempts.\n       long invocationAttemptFailoverCount;\n       synchronized (proxyProvider) {\n         invocationAttemptFailoverCount \u003d proxyProviderFailoverCount;\n       }\n       try {\n         return invokeMethod(method, args);\n       } catch (Exception e) {\n         boolean isMethodIdempotent \u003d proxyProvider.getInterface()\n             .getMethod(method.getName(), method.getParameterTypes())\n             .isAnnotationPresent(Idempotent.class);\n         RetryAction action \u003d policy.shouldRetry(e, retries++, invocationFailoverCount,\n             isMethodIdempotent);\n         if (action.action \u003d\u003d RetryAction.RetryDecision.FAIL) {\n           LOG.warn(\"Exception while invoking \" + method.getName()\n                    + \" of \" + currentProxy.getClass() + \". Not retrying.\", e);\n           if (!method.getReturnType().equals(Void.TYPE)) {\n             throw e; // non-void methods can\u0027t fail without an exception\n           }\n           return null;\n         } else { // retry or failover\n+\n+          if (action.action \u003d\u003d RetryAction.RetryDecision.FAILOVER_AND_RETRY) {\n+            String msg \u003d \"Exception while invoking \" + method.getName()\n+              + \" of \" + currentProxy.getClass()\n+              + \" after \" + invocationFailoverCount + \" fail over attempts.\"\n+              + \" Trying to fail over \" + formatSleepMessage(action.delayMillis);\n+            if (LOG.isDebugEnabled()) {\n+              LOG.debug(msg, e);\n+            } else {\n+              LOG.warn(msg);\n+            }\n+          } else {\n+            if(LOG.isDebugEnabled()) {\n+              LOG.debug(\"Exception while invoking \" + method.getName()\n+                  + \" of \" + currentProxy.getClass() + \". Retrying \" +\n+                  formatSleepMessage(action.delayMillis), e);\n+            }\n+          }\n           \n           if (action.delayMillis \u003e 0) {\n             ThreadUtil.sleepAtLeastIgnoreInterrupts(action.delayMillis);\n           }\n           \n           if (action.action \u003d\u003d RetryAction.RetryDecision.FAILOVER_AND_RETRY) {\n-            LOG.warn(\"Exception while invoking \" + method.getName()\n-                + \" of \" + currentProxy.getClass()\n-                + \" after \" + invocationFailoverCount + \" fail over attempts.\"\n-                + \" Trying to fail over.\", e);\n             // Make sure that concurrent failed method invocations only cause a\n             // single actual fail over.\n             synchronized (proxyProvider) {\n               if (invocationAttemptFailoverCount \u003d\u003d proxyProviderFailoverCount) {\n                 proxyProvider.performFailover(currentProxy);\n                 proxyProviderFailoverCount++;\n                 currentProxy \u003d proxyProvider.getProxy();\n               } else {\n                 LOG.warn(\"A failover has occurred since the start of this method\"\n                     + \" invocation attempt.\");\n               }\n             }\n             invocationFailoverCount++;\n           }\n         }\n-        if(LOG.isDebugEnabled()) {\n-          LOG.debug(\"Exception while invoking \" + method.getName()\n-              + \" of \" + currentProxy.getClass() + \". Retrying.\", e);\n-        }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Object invoke(Object proxy, Method method, Object[] args)\n    throws Throwable {\n    RetryPolicy policy \u003d methodNameToPolicyMap.get(method.getName());\n    if (policy \u003d\u003d null) {\n      policy \u003d defaultPolicy;\n    }\n    \n    // The number of times this method invocation has been failed over.\n    int invocationFailoverCount \u003d 0;\n    int retries \u003d 0;\n    while (true) {\n      // The number of times this invocation handler has ever been failed over,\n      // before this method invocation attempt. Used to prevent concurrent\n      // failed method invocations from triggering multiple failover attempts.\n      long invocationAttemptFailoverCount;\n      synchronized (proxyProvider) {\n        invocationAttemptFailoverCount \u003d proxyProviderFailoverCount;\n      }\n      try {\n        return invokeMethod(method, args);\n      } catch (Exception e) {\n        boolean isMethodIdempotent \u003d proxyProvider.getInterface()\n            .getMethod(method.getName(), method.getParameterTypes())\n            .isAnnotationPresent(Idempotent.class);\n        RetryAction action \u003d policy.shouldRetry(e, retries++, invocationFailoverCount,\n            isMethodIdempotent);\n        if (action.action \u003d\u003d RetryAction.RetryDecision.FAIL) {\n          LOG.warn(\"Exception while invoking \" + method.getName()\n                   + \" of \" + currentProxy.getClass() + \". Not retrying.\", e);\n          if (!method.getReturnType().equals(Void.TYPE)) {\n            throw e; // non-void methods can\u0027t fail without an exception\n          }\n          return null;\n        } else { // retry or failover\n\n          if (action.action \u003d\u003d RetryAction.RetryDecision.FAILOVER_AND_RETRY) {\n            String msg \u003d \"Exception while invoking \" + method.getName()\n              + \" of \" + currentProxy.getClass()\n              + \" after \" + invocationFailoverCount + \" fail over attempts.\"\n              + \" Trying to fail over \" + formatSleepMessage(action.delayMillis);\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(msg, e);\n            } else {\n              LOG.warn(msg);\n            }\n          } else {\n            if(LOG.isDebugEnabled()) {\n              LOG.debug(\"Exception while invoking \" + method.getName()\n                  + \" of \" + currentProxy.getClass() + \". Retrying \" +\n                  formatSleepMessage(action.delayMillis), e);\n            }\n          }\n          \n          if (action.delayMillis \u003e 0) {\n            ThreadUtil.sleepAtLeastIgnoreInterrupts(action.delayMillis);\n          }\n          \n          if (action.action \u003d\u003d RetryAction.RetryDecision.FAILOVER_AND_RETRY) {\n            // Make sure that concurrent failed method invocations only cause a\n            // single actual fail over.\n            synchronized (proxyProvider) {\n              if (invocationAttemptFailoverCount \u003d\u003d proxyProviderFailoverCount) {\n                proxyProvider.performFailover(currentProxy);\n                proxyProviderFailoverCount++;\n                currentProxy \u003d proxyProvider.getProxy();\n              } else {\n                LOG.warn(\"A failover has occurred since the start of this method\"\n                    + \" invocation attempt.\");\n              }\n            }\n            invocationFailoverCount++;\n          }\n        }\n      }\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/retry/RetryInvocationHandler.java",
      "extendedDetails": {}
    },
    "9818091a66b9c8e337de9d4e18655cf4b157056b": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-7896. HA: if both NNs are in Standby mode, client needs to try failing back and forth several times with sleeps. Contributed by Aaron T. Myers\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1214076 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "13/12/11 11:24 PM",
      "commitName": "9818091a66b9c8e337de9d4e18655cf4b157056b",
      "commitAuthor": "Aaron Myers",
      "commitDateOld": "07/12/11 5:21 PM",
      "commitNameOld": "d9690b092294db5d6644af5f1a713788f792b55c",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 6.25,
      "commitsBetweenForRepo": 43,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,59 +1,66 @@\n   public Object invoke(Object proxy, Method method, Object[] args)\n     throws Throwable {\n     RetryPolicy policy \u003d methodNameToPolicyMap.get(method.getName());\n     if (policy \u003d\u003d null) {\n       policy \u003d defaultPolicy;\n     }\n     \n     // The number of times this method invocation has been failed over.\n     int invocationFailoverCount \u003d 0;\n     int retries \u003d 0;\n     while (true) {\n       // The number of times this invocation handler has ever been failed over,\n       // before this method invocation attempt. Used to prevent concurrent\n       // failed method invocations from triggering multiple failover attempts.\n       long invocationAttemptFailoverCount;\n       synchronized (proxyProvider) {\n         invocationAttemptFailoverCount \u003d proxyProviderFailoverCount;\n       }\n       try {\n         return invokeMethod(method, args);\n       } catch (Exception e) {\n         boolean isMethodIdempotent \u003d proxyProvider.getInterface()\n             .getMethod(method.getName(), method.getParameterTypes())\n             .isAnnotationPresent(Idempotent.class);\n         RetryAction action \u003d policy.shouldRetry(e, retries++, invocationFailoverCount,\n             isMethodIdempotent);\n-        if (action \u003d\u003d RetryAction.FAIL) {\n+        if (action.action \u003d\u003d RetryAction.RetryDecision.FAIL) {\n           LOG.warn(\"Exception while invoking \" + method.getName()\n                    + \" of \" + currentProxy.getClass() + \". Not retrying.\", e);\n           if (!method.getReturnType().equals(Void.TYPE)) {\n             throw e; // non-void methods can\u0027t fail without an exception\n           }\n           return null;\n-        } else if (action \u003d\u003d RetryAction.FAILOVER_AND_RETRY) {\n-          LOG.warn(\"Exception while invoking \" + method.getName()\n-              + \" of \" + currentProxy.getClass()\n-              + \" after \" + invocationFailoverCount + \" fail over attempts.\"\n-              + \" Trying to fail over.\", e);\n-          // Make sure that concurrent failed method invocations only cause a\n-          // single actual fail over.\n-          synchronized (proxyProvider) {\n-            if (invocationAttemptFailoverCount \u003d\u003d proxyProviderFailoverCount) {\n-              proxyProvider.performFailover(currentProxy);\n-              proxyProviderFailoverCount++;\n-              currentProxy \u003d proxyProvider.getProxy();\n-            } else {\n-              LOG.warn(\"A failover has occurred since the start of this method\"\n-                  + \" invocation attempt.\");\n-            }\n+        } else { // retry or failover\n+          \n+          if (action.delayMillis \u003e 0) {\n+            ThreadUtil.sleepAtLeastIgnoreInterrupts(action.delayMillis);\n           }\n-          invocationFailoverCount++;\n+          \n+          if (action.action \u003d\u003d RetryAction.RetryDecision.FAILOVER_AND_RETRY) {\n+            LOG.warn(\"Exception while invoking \" + method.getName()\n+                + \" of \" + currentProxy.getClass()\n+                + \" after \" + invocationFailoverCount + \" fail over attempts.\"\n+                + \" Trying to fail over.\", e);\n+            // Make sure that concurrent failed method invocations only cause a\n+            // single actual fail over.\n+            synchronized (proxyProvider) {\n+              if (invocationAttemptFailoverCount \u003d\u003d proxyProviderFailoverCount) {\n+                proxyProvider.performFailover(currentProxy);\n+                proxyProviderFailoverCount++;\n+                currentProxy \u003d proxyProvider.getProxy();\n+              } else {\n+                LOG.warn(\"A failover has occurred since the start of this method\"\n+                    + \" invocation attempt.\");\n+              }\n+            }\n+            invocationFailoverCount++;\n+          }\n         }\n         if(LOG.isDebugEnabled()) {\n           LOG.debug(\"Exception while invoking \" + method.getName()\n               + \" of \" + currentProxy.getClass() + \". Retrying.\", e);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Object invoke(Object proxy, Method method, Object[] args)\n    throws Throwable {\n    RetryPolicy policy \u003d methodNameToPolicyMap.get(method.getName());\n    if (policy \u003d\u003d null) {\n      policy \u003d defaultPolicy;\n    }\n    \n    // The number of times this method invocation has been failed over.\n    int invocationFailoverCount \u003d 0;\n    int retries \u003d 0;\n    while (true) {\n      // The number of times this invocation handler has ever been failed over,\n      // before this method invocation attempt. Used to prevent concurrent\n      // failed method invocations from triggering multiple failover attempts.\n      long invocationAttemptFailoverCount;\n      synchronized (proxyProvider) {\n        invocationAttemptFailoverCount \u003d proxyProviderFailoverCount;\n      }\n      try {\n        return invokeMethod(method, args);\n      } catch (Exception e) {\n        boolean isMethodIdempotent \u003d proxyProvider.getInterface()\n            .getMethod(method.getName(), method.getParameterTypes())\n            .isAnnotationPresent(Idempotent.class);\n        RetryAction action \u003d policy.shouldRetry(e, retries++, invocationFailoverCount,\n            isMethodIdempotent);\n        if (action.action \u003d\u003d RetryAction.RetryDecision.FAIL) {\n          LOG.warn(\"Exception while invoking \" + method.getName()\n                   + \" of \" + currentProxy.getClass() + \". Not retrying.\", e);\n          if (!method.getReturnType().equals(Void.TYPE)) {\n            throw e; // non-void methods can\u0027t fail without an exception\n          }\n          return null;\n        } else { // retry or failover\n          \n          if (action.delayMillis \u003e 0) {\n            ThreadUtil.sleepAtLeastIgnoreInterrupts(action.delayMillis);\n          }\n          \n          if (action.action \u003d\u003d RetryAction.RetryDecision.FAILOVER_AND_RETRY) {\n            LOG.warn(\"Exception while invoking \" + method.getName()\n                + \" of \" + currentProxy.getClass()\n                + \" after \" + invocationFailoverCount + \" fail over attempts.\"\n                + \" Trying to fail over.\", e);\n            // Make sure that concurrent failed method invocations only cause a\n            // single actual fail over.\n            synchronized (proxyProvider) {\n              if (invocationAttemptFailoverCount \u003d\u003d proxyProviderFailoverCount) {\n                proxyProvider.performFailover(currentProxy);\n                proxyProviderFailoverCount++;\n                currentProxy \u003d proxyProvider.getProxy();\n              } else {\n                LOG.warn(\"A failover has occurred since the start of this method\"\n                    + \" invocation attempt.\");\n              }\n            }\n            invocationFailoverCount++;\n          }\n        }\n        if(LOG.isDebugEnabled()) {\n          LOG.debug(\"Exception while invoking \" + method.getName()\n              + \" of \" + currentProxy.getClass() + \". Retrying.\", e);\n        }\n      }\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/retry/RetryInvocationHandler.java",
      "extendedDetails": {}
    },
    "d9690b092294db5d6644af5f1a713788f792b55c": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-7888. TestFailoverProxy fails intermittently on trunk. Contributed by Jason Lowe.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1211728 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/12/11 5:21 PM",
      "commitName": "d9690b092294db5d6644af5f1a713788f792b55c",
      "commitAuthor": "Aaron Myers",
      "commitDateOld": "05/10/11 6:01 PM",
      "commitNameOld": "14569ab482c2bb79cae31bf12a1e6c8d5f0d6064",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 63.01,
      "commitsBetweenForRepo": 434,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,62 +1,59 @@\n   public Object invoke(Object proxy, Method method, Object[] args)\n     throws Throwable {\n     RetryPolicy policy \u003d methodNameToPolicyMap.get(method.getName());\n     if (policy \u003d\u003d null) {\n       policy \u003d defaultPolicy;\n     }\n     \n     // The number of times this method invocation has been failed over.\n     int invocationFailoverCount \u003d 0;\n     int retries \u003d 0;\n     while (true) {\n       // The number of times this invocation handler has ever been failed over,\n       // before this method invocation attempt. Used to prevent concurrent\n       // failed method invocations from triggering multiple failover attempts.\n       long invocationAttemptFailoverCount;\n       synchronized (proxyProvider) {\n         invocationAttemptFailoverCount \u003d proxyProviderFailoverCount;\n       }\n       try {\n         return invokeMethod(method, args);\n       } catch (Exception e) {\n         boolean isMethodIdempotent \u003d proxyProvider.getInterface()\n             .getMethod(method.getName(), method.getParameterTypes())\n             .isAnnotationPresent(Idempotent.class);\n         RetryAction action \u003d policy.shouldRetry(e, retries++, invocationFailoverCount,\n             isMethodIdempotent);\n         if (action \u003d\u003d RetryAction.FAIL) {\n           LOG.warn(\"Exception while invoking \" + method.getName()\n                    + \" of \" + currentProxy.getClass() + \". Not retrying.\", e);\n           if (!method.getReturnType().equals(Void.TYPE)) {\n             throw e; // non-void methods can\u0027t fail without an exception\n           }\n           return null;\n         } else if (action \u003d\u003d RetryAction.FAILOVER_AND_RETRY) {\n           LOG.warn(\"Exception while invoking \" + method.getName()\n               + \" of \" + currentProxy.getClass()\n               + \" after \" + invocationFailoverCount + \" fail over attempts.\"\n               + \" Trying to fail over.\", e);\n           // Make sure that concurrent failed method invocations only cause a\n           // single actual fail over.\n           synchronized (proxyProvider) {\n             if (invocationAttemptFailoverCount \u003d\u003d proxyProviderFailoverCount) {\n               proxyProvider.performFailover(currentProxy);\n               proxyProviderFailoverCount++;\n+              currentProxy \u003d proxyProvider.getProxy();\n             } else {\n               LOG.warn(\"A failover has occurred since the start of this method\"\n                   + \" invocation attempt.\");\n             }\n           }\n-          // The call to getProxy() could technically only be made in the event\n-          // performFailover() is called, but it needs to be out here for the\n-          // purpose of testing.\n-          currentProxy \u003d proxyProvider.getProxy();\n           invocationFailoverCount++;\n         }\n         if(LOG.isDebugEnabled()) {\n           LOG.debug(\"Exception while invoking \" + method.getName()\n               + \" of \" + currentProxy.getClass() + \". Retrying.\", e);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Object invoke(Object proxy, Method method, Object[] args)\n    throws Throwable {\n    RetryPolicy policy \u003d methodNameToPolicyMap.get(method.getName());\n    if (policy \u003d\u003d null) {\n      policy \u003d defaultPolicy;\n    }\n    \n    // The number of times this method invocation has been failed over.\n    int invocationFailoverCount \u003d 0;\n    int retries \u003d 0;\n    while (true) {\n      // The number of times this invocation handler has ever been failed over,\n      // before this method invocation attempt. Used to prevent concurrent\n      // failed method invocations from triggering multiple failover attempts.\n      long invocationAttemptFailoverCount;\n      synchronized (proxyProvider) {\n        invocationAttemptFailoverCount \u003d proxyProviderFailoverCount;\n      }\n      try {\n        return invokeMethod(method, args);\n      } catch (Exception e) {\n        boolean isMethodIdempotent \u003d proxyProvider.getInterface()\n            .getMethod(method.getName(), method.getParameterTypes())\n            .isAnnotationPresent(Idempotent.class);\n        RetryAction action \u003d policy.shouldRetry(e, retries++, invocationFailoverCount,\n            isMethodIdempotent);\n        if (action \u003d\u003d RetryAction.FAIL) {\n          LOG.warn(\"Exception while invoking \" + method.getName()\n                   + \" of \" + currentProxy.getClass() + \". Not retrying.\", e);\n          if (!method.getReturnType().equals(Void.TYPE)) {\n            throw e; // non-void methods can\u0027t fail without an exception\n          }\n          return null;\n        } else if (action \u003d\u003d RetryAction.FAILOVER_AND_RETRY) {\n          LOG.warn(\"Exception while invoking \" + method.getName()\n              + \" of \" + currentProxy.getClass()\n              + \" after \" + invocationFailoverCount + \" fail over attempts.\"\n              + \" Trying to fail over.\", e);\n          // Make sure that concurrent failed method invocations only cause a\n          // single actual fail over.\n          synchronized (proxyProvider) {\n            if (invocationAttemptFailoverCount \u003d\u003d proxyProviderFailoverCount) {\n              proxyProvider.performFailover(currentProxy);\n              proxyProviderFailoverCount++;\n              currentProxy \u003d proxyProvider.getProxy();\n            } else {\n              LOG.warn(\"A failover has occurred since the start of this method\"\n                  + \" invocation attempt.\");\n            }\n          }\n          invocationFailoverCount++;\n        }\n        if(LOG.isDebugEnabled()) {\n          LOG.debug(\"Exception while invoking \" + method.getName()\n              + \" of \" + currentProxy.getClass() + \". Retrying.\", e);\n        }\n      }\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/retry/RetryInvocationHandler.java",
      "extendedDetails": {}
    },
    "14569ab482c2bb79cae31bf12a1e6c8d5f0d6064": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-7717. Move handling of concurrent client fail-overs to RetryInvocationHandler (atm)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1179483 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "05/10/11 6:01 PM",
      "commitName": "14569ab482c2bb79cae31bf12a1e6c8d5f0d6064",
      "commitAuthor": "Aaron Myers",
      "commitDateOld": "15/09/11 11:45 AM",
      "commitNameOld": "e66d697a66a18041a669ba5f71310b091ed56358",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 20.26,
      "commitsBetweenForRepo": 145,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,62 @@\n   public Object invoke(Object proxy, Method method, Object[] args)\n     throws Throwable {\n     RetryPolicy policy \u003d methodNameToPolicyMap.get(method.getName());\n     if (policy \u003d\u003d null) {\n       policy \u003d defaultPolicy;\n     }\n     \n-    int failovers \u003d 0;\n+    // The number of times this method invocation has been failed over.\n+    int invocationFailoverCount \u003d 0;\n     int retries \u003d 0;\n     while (true) {\n+      // The number of times this invocation handler has ever been failed over,\n+      // before this method invocation attempt. Used to prevent concurrent\n+      // failed method invocations from triggering multiple failover attempts.\n+      long invocationAttemptFailoverCount;\n+      synchronized (proxyProvider) {\n+        invocationAttemptFailoverCount \u003d proxyProviderFailoverCount;\n+      }\n       try {\n         return invokeMethod(method, args);\n       } catch (Exception e) {\n         boolean isMethodIdempotent \u003d proxyProvider.getInterface()\n             .getMethod(method.getName(), method.getParameterTypes())\n             .isAnnotationPresent(Idempotent.class);\n-        RetryAction action \u003d policy.shouldRetry(e, retries++, failovers,\n+        RetryAction action \u003d policy.shouldRetry(e, retries++, invocationFailoverCount,\n             isMethodIdempotent);\n         if (action \u003d\u003d RetryAction.FAIL) {\n           LOG.warn(\"Exception while invoking \" + method.getName()\n                    + \" of \" + currentProxy.getClass() + \". Not retrying.\", e);\n           if (!method.getReturnType().equals(Void.TYPE)) {\n             throw e; // non-void methods can\u0027t fail without an exception\n           }\n           return null;\n         } else if (action \u003d\u003d RetryAction.FAILOVER_AND_RETRY) {\n           LOG.warn(\"Exception while invoking \" + method.getName()\n               + \" of \" + currentProxy.getClass()\n-              + \". Trying to fail over.\", e);\n-          failovers++;\n-          proxyProvider.performFailover(currentProxy);\n+              + \" after \" + invocationFailoverCount + \" fail over attempts.\"\n+              + \" Trying to fail over.\", e);\n+          // Make sure that concurrent failed method invocations only cause a\n+          // single actual fail over.\n+          synchronized (proxyProvider) {\n+            if (invocationAttemptFailoverCount \u003d\u003d proxyProviderFailoverCount) {\n+              proxyProvider.performFailover(currentProxy);\n+              proxyProviderFailoverCount++;\n+            } else {\n+              LOG.warn(\"A failover has occurred since the start of this method\"\n+                  + \" invocation attempt.\");\n+            }\n+          }\n+          // The call to getProxy() could technically only be made in the event\n+          // performFailover() is called, but it needs to be out here for the\n+          // purpose of testing.\n           currentProxy \u003d proxyProvider.getProxy();\n+          invocationFailoverCount++;\n         }\n         if(LOG.isDebugEnabled()) {\n           LOG.debug(\"Exception while invoking \" + method.getName()\n               + \" of \" + currentProxy.getClass() + \". Retrying.\", e);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Object invoke(Object proxy, Method method, Object[] args)\n    throws Throwable {\n    RetryPolicy policy \u003d methodNameToPolicyMap.get(method.getName());\n    if (policy \u003d\u003d null) {\n      policy \u003d defaultPolicy;\n    }\n    \n    // The number of times this method invocation has been failed over.\n    int invocationFailoverCount \u003d 0;\n    int retries \u003d 0;\n    while (true) {\n      // The number of times this invocation handler has ever been failed over,\n      // before this method invocation attempt. Used to prevent concurrent\n      // failed method invocations from triggering multiple failover attempts.\n      long invocationAttemptFailoverCount;\n      synchronized (proxyProvider) {\n        invocationAttemptFailoverCount \u003d proxyProviderFailoverCount;\n      }\n      try {\n        return invokeMethod(method, args);\n      } catch (Exception e) {\n        boolean isMethodIdempotent \u003d proxyProvider.getInterface()\n            .getMethod(method.getName(), method.getParameterTypes())\n            .isAnnotationPresent(Idempotent.class);\n        RetryAction action \u003d policy.shouldRetry(e, retries++, invocationFailoverCount,\n            isMethodIdempotent);\n        if (action \u003d\u003d RetryAction.FAIL) {\n          LOG.warn(\"Exception while invoking \" + method.getName()\n                   + \" of \" + currentProxy.getClass() + \". Not retrying.\", e);\n          if (!method.getReturnType().equals(Void.TYPE)) {\n            throw e; // non-void methods can\u0027t fail without an exception\n          }\n          return null;\n        } else if (action \u003d\u003d RetryAction.FAILOVER_AND_RETRY) {\n          LOG.warn(\"Exception while invoking \" + method.getName()\n              + \" of \" + currentProxy.getClass()\n              + \" after \" + invocationFailoverCount + \" fail over attempts.\"\n              + \" Trying to fail over.\", e);\n          // Make sure that concurrent failed method invocations only cause a\n          // single actual fail over.\n          synchronized (proxyProvider) {\n            if (invocationAttemptFailoverCount \u003d\u003d proxyProviderFailoverCount) {\n              proxyProvider.performFailover(currentProxy);\n              proxyProviderFailoverCount++;\n            } else {\n              LOG.warn(\"A failover has occurred since the start of this method\"\n                  + \" invocation attempt.\");\n            }\n          }\n          // The call to getProxy() could technically only be made in the event\n          // performFailover() is called, but it needs to be out here for the\n          // purpose of testing.\n          currentProxy \u003d proxyProvider.getProxy();\n          invocationFailoverCount++;\n        }\n        if(LOG.isDebugEnabled()) {\n          LOG.debug(\"Exception while invoking \" + method.getName()\n              + \" of \" + currentProxy.getClass() + \". Retrying.\", e);\n        }\n      }\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/retry/RetryInvocationHandler.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public Object invoke(Object proxy, Method method, Object[] args)\n    throws Throwable {\n    RetryPolicy policy \u003d methodNameToPolicyMap.get(method.getName());\n    if (policy \u003d\u003d null) {\n      policy \u003d defaultPolicy;\n    }\n    \n    int failovers \u003d 0;\n    int retries \u003d 0;\n    while (true) {\n      try {\n        return invokeMethod(method, args);\n      } catch (Exception e) {\n        boolean isMethodIdempotent \u003d proxyProvider.getInterface()\n            .getMethod(method.getName(), method.getParameterTypes())\n            .isAnnotationPresent(Idempotent.class);\n        RetryAction action \u003d policy.shouldRetry(e, retries++, failovers,\n            isMethodIdempotent);\n        if (action \u003d\u003d RetryAction.FAIL) {\n          LOG.warn(\"Exception while invoking \" + method.getName()\n                   + \" of \" + currentProxy.getClass() + \". Not retrying.\", e);\n          if (!method.getReturnType().equals(Void.TYPE)) {\n            throw e; // non-void methods can\u0027t fail without an exception\n          }\n          return null;\n        } else if (action \u003d\u003d RetryAction.FAILOVER_AND_RETRY) {\n          LOG.warn(\"Exception while invoking \" + method.getName()\n              + \" of \" + currentProxy.getClass()\n              + \". Trying to fail over.\", e);\n          failovers++;\n          proxyProvider.performFailover(currentProxy);\n          currentProxy \u003d proxyProvider.getProxy();\n        }\n        if(LOG.isDebugEnabled()) {\n          LOG.debug(\"Exception while invoking \" + method.getName()\n              + \" of \" + currentProxy.getClass() + \". Retrying.\", e);\n        }\n      }\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/retry/RetryInvocationHandler.java",
      "extendedDetails": {
        "oldPath": "hadoop-common/src/main/java/org/apache/hadoop/io/retry/RetryInvocationHandler.java",
        "newPath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/retry/RetryInvocationHandler.java"
      }
    },
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-6671. Use maven for hadoop common builds. Contributed by Alejandro Abdelnur.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1153184 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/08/11 9:37 AM",
      "commitName": "0f6dfeeacbab65a31a33927a4eb84871d371fe52",
      "commitAuthor": "Thomas White",
      "commitDateOld": "01/08/11 3:53 PM",
      "commitNameOld": "9bac807cedbcff34e1a144fb475eff267e5ed86d",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.74,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public Object invoke(Object proxy, Method method, Object[] args)\n    throws Throwable {\n    RetryPolicy policy \u003d methodNameToPolicyMap.get(method.getName());\n    if (policy \u003d\u003d null) {\n      policy \u003d defaultPolicy;\n    }\n    \n    int failovers \u003d 0;\n    int retries \u003d 0;\n    while (true) {\n      try {\n        return invokeMethod(method, args);\n      } catch (Exception e) {\n        boolean isMethodIdempotent \u003d proxyProvider.getInterface()\n            .getMethod(method.getName(), method.getParameterTypes())\n            .isAnnotationPresent(Idempotent.class);\n        RetryAction action \u003d policy.shouldRetry(e, retries++, failovers,\n            isMethodIdempotent);\n        if (action \u003d\u003d RetryAction.FAIL) {\n          LOG.warn(\"Exception while invoking \" + method.getName()\n                   + \" of \" + currentProxy.getClass() + \". Not retrying.\", e);\n          if (!method.getReturnType().equals(Void.TYPE)) {\n            throw e; // non-void methods can\u0027t fail without an exception\n          }\n          return null;\n        } else if (action \u003d\u003d RetryAction.FAILOVER_AND_RETRY) {\n          LOG.warn(\"Exception while invoking \" + method.getName()\n              + \" of \" + currentProxy.getClass()\n              + \". Trying to fail over.\", e);\n          failovers++;\n          proxyProvider.performFailover(currentProxy);\n          currentProxy \u003d proxyProvider.getProxy();\n        }\n        if(LOG.isDebugEnabled()) {\n          LOG.debug(\"Exception while invoking \" + method.getName()\n              + \" of \" + currentProxy.getClass() + \". Retrying.\", e);\n        }\n      }\n    }\n  }",
      "path": "hadoop-common/src/main/java/org/apache/hadoop/io/retry/RetryInvocationHandler.java",
      "extendedDetails": {
        "oldPath": "common/src/java/org/apache/hadoop/io/retry/RetryInvocationHandler.java",
        "newPath": "hadoop-common/src/main/java/org/apache/hadoop/io/retry/RetryInvocationHandler.java"
      }
    },
    "637cdaefc294814febb27cbef2f35026053114c7": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-7380. Add client failover functionality to o.a.h.io.(ipc|retry). Contributed by Aaron T. Myers\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1144043 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/07/11 2:16 PM",
      "commitName": "637cdaefc294814febb27cbef2f35026053114c7",
      "commitAuthor": "Eli Collins",
      "commitDateOld": "23/06/11 4:55 PM",
      "commitNameOld": "1191be630ff05c9f1a540b952a8e34665f7fc181",
      "commitAuthorOld": "Tanping Wang",
      "daysBetweenCommits": 13.89,
      "commitsBetweenForRepo": 41,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,40 @@\n   public Object invoke(Object proxy, Method method, Object[] args)\n     throws Throwable {\n     RetryPolicy policy \u003d methodNameToPolicyMap.get(method.getName());\n     if (policy \u003d\u003d null) {\n       policy \u003d defaultPolicy;\n     }\n     \n+    int failovers \u003d 0;\n     int retries \u003d 0;\n     while (true) {\n       try {\n         return invokeMethod(method, args);\n       } catch (Exception e) {\n-        if (!policy.shouldRetry(e, retries++)) {\n-          LOG.info(\"Exception while invoking \" + method.getName()\n-                   + \" of \" + implementation.getClass() + \". Not retrying.\"\n-                   , e);\n+        boolean isMethodIdempotent \u003d proxyProvider.getInterface()\n+            .getMethod(method.getName(), method.getParameterTypes())\n+            .isAnnotationPresent(Idempotent.class);\n+        RetryAction action \u003d policy.shouldRetry(e, retries++, failovers,\n+            isMethodIdempotent);\n+        if (action \u003d\u003d RetryAction.FAIL) {\n+          LOG.warn(\"Exception while invoking \" + method.getName()\n+                   + \" of \" + currentProxy.getClass() + \". Not retrying.\", e);\n           if (!method.getReturnType().equals(Void.TYPE)) {\n             throw e; // non-void methods can\u0027t fail without an exception\n           }\n           return null;\n+        } else if (action \u003d\u003d RetryAction.FAILOVER_AND_RETRY) {\n+          LOG.warn(\"Exception while invoking \" + method.getName()\n+              + \" of \" + currentProxy.getClass()\n+              + \". Trying to fail over.\", e);\n+          failovers++;\n+          proxyProvider.performFailover(currentProxy);\n+          currentProxy \u003d proxyProvider.getProxy();\n         }\n         if(LOG.isDebugEnabled()) {\n           LOG.debug(\"Exception while invoking \" + method.getName()\n-              + \" of \" + implementation.getClass() + \". Retrying.\"\n-              , e);\n+              + \" of \" + currentProxy.getClass() + \". Retrying.\", e);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Object invoke(Object proxy, Method method, Object[] args)\n    throws Throwable {\n    RetryPolicy policy \u003d methodNameToPolicyMap.get(method.getName());\n    if (policy \u003d\u003d null) {\n      policy \u003d defaultPolicy;\n    }\n    \n    int failovers \u003d 0;\n    int retries \u003d 0;\n    while (true) {\n      try {\n        return invokeMethod(method, args);\n      } catch (Exception e) {\n        boolean isMethodIdempotent \u003d proxyProvider.getInterface()\n            .getMethod(method.getName(), method.getParameterTypes())\n            .isAnnotationPresent(Idempotent.class);\n        RetryAction action \u003d policy.shouldRetry(e, retries++, failovers,\n            isMethodIdempotent);\n        if (action \u003d\u003d RetryAction.FAIL) {\n          LOG.warn(\"Exception while invoking \" + method.getName()\n                   + \" of \" + currentProxy.getClass() + \". Not retrying.\", e);\n          if (!method.getReturnType().equals(Void.TYPE)) {\n            throw e; // non-void methods can\u0027t fail without an exception\n          }\n          return null;\n        } else if (action \u003d\u003d RetryAction.FAILOVER_AND_RETRY) {\n          LOG.warn(\"Exception while invoking \" + method.getName()\n              + \" of \" + currentProxy.getClass()\n              + \". Trying to fail over.\", e);\n          failovers++;\n          proxyProvider.performFailover(currentProxy);\n          currentProxy \u003d proxyProvider.getProxy();\n        }\n        if(LOG.isDebugEnabled()) {\n          LOG.debug(\"Exception while invoking \" + method.getName()\n              + \" of \" + currentProxy.getClass() + \". Retrying.\", e);\n        }\n      }\n    }\n  }",
      "path": "common/src/java/org/apache/hadoop/io/retry/RetryInvocationHandler.java",
      "extendedDetails": {}
    },
    "1191be630ff05c9f1a540b952a8e34665f7fc181": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-7385 Remove StringUtils.stringifyException(ie) in logger functions.  Contributed by Bharath Mundlapudi.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1139123 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/06/11 4:55 PM",
      "commitName": "1191be630ff05c9f1a540b952a8e34665f7fc181",
      "commitAuthor": "Tanping Wang",
      "commitDateOld": "12/06/11 3:00 PM",
      "commitNameOld": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 11.08,
      "commitsBetweenForRepo": 37,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,29 @@\n   public Object invoke(Object proxy, Method method, Object[] args)\n     throws Throwable {\n     RetryPolicy policy \u003d methodNameToPolicyMap.get(method.getName());\n     if (policy \u003d\u003d null) {\n       policy \u003d defaultPolicy;\n     }\n     \n     int retries \u003d 0;\n     while (true) {\n       try {\n         return invokeMethod(method, args);\n       } catch (Exception e) {\n         if (!policy.shouldRetry(e, retries++)) {\n           LOG.info(\"Exception while invoking \" + method.getName()\n                    + \" of \" + implementation.getClass() + \". Not retrying.\"\n-                   + StringUtils.stringifyException(e));\n+                   , e);\n           if (!method.getReturnType().equals(Void.TYPE)) {\n             throw e; // non-void methods can\u0027t fail without an exception\n           }\n           return null;\n         }\n         if(LOG.isDebugEnabled()) {\n           LOG.debug(\"Exception while invoking \" + method.getName()\n               + \" of \" + implementation.getClass() + \". Retrying.\"\n-              + StringUtils.stringifyException(e));\n+              , e);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Object invoke(Object proxy, Method method, Object[] args)\n    throws Throwable {\n    RetryPolicy policy \u003d methodNameToPolicyMap.get(method.getName());\n    if (policy \u003d\u003d null) {\n      policy \u003d defaultPolicy;\n    }\n    \n    int retries \u003d 0;\n    while (true) {\n      try {\n        return invokeMethod(method, args);\n      } catch (Exception e) {\n        if (!policy.shouldRetry(e, retries++)) {\n          LOG.info(\"Exception while invoking \" + method.getName()\n                   + \" of \" + implementation.getClass() + \". Not retrying.\"\n                   , e);\n          if (!method.getReturnType().equals(Void.TYPE)) {\n            throw e; // non-void methods can\u0027t fail without an exception\n          }\n          return null;\n        }\n        if(LOG.isDebugEnabled()) {\n          LOG.debug(\"Exception while invoking \" + method.getName()\n              + \" of \" + implementation.getClass() + \". Retrying.\"\n              , e);\n        }\n      }\n    }\n  }",
      "path": "common/src/java/org/apache/hadoop/io/retry/RetryInvocationHandler.java",
      "extendedDetails": {}
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "11/06/11 9:13 PM",
      "commitNameOld": "a285fb5effe9ba3be4ec5f942afaf5ddd1186151",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 0.74,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public Object invoke(Object proxy, Method method, Object[] args)\n    throws Throwable {\n    RetryPolicy policy \u003d methodNameToPolicyMap.get(method.getName());\n    if (policy \u003d\u003d null) {\n      policy \u003d defaultPolicy;\n    }\n    \n    int retries \u003d 0;\n    while (true) {\n      try {\n        return invokeMethod(method, args);\n      } catch (Exception e) {\n        if (!policy.shouldRetry(e, retries++)) {\n          LOG.info(\"Exception while invoking \" + method.getName()\n                   + \" of \" + implementation.getClass() + \". Not retrying.\"\n                   + StringUtils.stringifyException(e));\n          if (!method.getReturnType().equals(Void.TYPE)) {\n            throw e; // non-void methods can\u0027t fail without an exception\n          }\n          return null;\n        }\n        if(LOG.isDebugEnabled()) {\n          LOG.debug(\"Exception while invoking \" + method.getName()\n              + \" of \" + implementation.getClass() + \". Retrying.\"\n              + StringUtils.stringifyException(e));\n        }\n      }\n    }\n  }",
      "path": "common/src/java/org/apache/hadoop/io/retry/RetryInvocationHandler.java",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/hadoop/io/retry/RetryInvocationHandler.java",
        "newPath": "common/src/java/org/apache/hadoop/io/retry/RetryInvocationHandler.java"
      }
    },
    "7efb9640be26aabe3878310e82248a1b6b767a9a": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-6884. Add LOG.isDebugEnabled() guard for each LOG.debug(..).  Contributed by Erik Steffl\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@990460 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "28/08/10 3:44 PM",
      "commitName": "7efb9640be26aabe3878310e82248a1b6b767a9a",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "18/05/09 9:20 PM",
      "commitNameOld": "5128a9a453d64bfe1ed978cf9ffed27985eeef36",
      "commitAuthorOld": "Owen O\u0027Malley",
      "daysBetweenCommits": 466.77,
      "commitsBetweenForRepo": 441,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,27 +1,29 @@\n   public Object invoke(Object proxy, Method method, Object[] args)\n     throws Throwable {\n     RetryPolicy policy \u003d methodNameToPolicyMap.get(method.getName());\n     if (policy \u003d\u003d null) {\n       policy \u003d defaultPolicy;\n     }\n     \n     int retries \u003d 0;\n     while (true) {\n       try {\n         return invokeMethod(method, args);\n       } catch (Exception e) {\n         if (!policy.shouldRetry(e, retries++)) {\n           LOG.info(\"Exception while invoking \" + method.getName()\n                    + \" of \" + implementation.getClass() + \". Not retrying.\"\n                    + StringUtils.stringifyException(e));\n           if (!method.getReturnType().equals(Void.TYPE)) {\n             throw e; // non-void methods can\u0027t fail without an exception\n           }\n           return null;\n         }\n-        LOG.debug(\"Exception while invoking \" + method.getName()\n-                 + \" of \" + implementation.getClass() + \". Retrying.\"\n-                 + StringUtils.stringifyException(e));\n+        if(LOG.isDebugEnabled()) {\n+          LOG.debug(\"Exception while invoking \" + method.getName()\n+              + \" of \" + implementation.getClass() + \". Retrying.\"\n+              + StringUtils.stringifyException(e));\n+        }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Object invoke(Object proxy, Method method, Object[] args)\n    throws Throwable {\n    RetryPolicy policy \u003d methodNameToPolicyMap.get(method.getName());\n    if (policy \u003d\u003d null) {\n      policy \u003d defaultPolicy;\n    }\n    \n    int retries \u003d 0;\n    while (true) {\n      try {\n        return invokeMethod(method, args);\n      } catch (Exception e) {\n        if (!policy.shouldRetry(e, retries++)) {\n          LOG.info(\"Exception while invoking \" + method.getName()\n                   + \" of \" + implementation.getClass() + \". Not retrying.\"\n                   + StringUtils.stringifyException(e));\n          if (!method.getReturnType().equals(Void.TYPE)) {\n            throw e; // non-void methods can\u0027t fail without an exception\n          }\n          return null;\n        }\n        if(LOG.isDebugEnabled()) {\n          LOG.debug(\"Exception while invoking \" + method.getName()\n              + \" of \" + implementation.getClass() + \". Retrying.\"\n              + StringUtils.stringifyException(e));\n        }\n      }\n    }\n  }",
      "path": "src/java/org/apache/hadoop/io/retry/RetryInvocationHandler.java",
      "extendedDetails": {}
    },
    "5128a9a453d64bfe1ed978cf9ffed27985eeef36": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-4687 Moving src directories on branch\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/core/branches/HADOOP-4687/core@776174 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/05/09 9:20 PM",
      "commitName": "5128a9a453d64bfe1ed978cf9ffed27985eeef36",
      "commitAuthor": "Owen O\u0027Malley",
      "diff": "@@ -0,0 +1,27 @@\n+  public Object invoke(Object proxy, Method method, Object[] args)\n+    throws Throwable {\n+    RetryPolicy policy \u003d methodNameToPolicyMap.get(method.getName());\n+    if (policy \u003d\u003d null) {\n+      policy \u003d defaultPolicy;\n+    }\n+    \n+    int retries \u003d 0;\n+    while (true) {\n+      try {\n+        return invokeMethod(method, args);\n+      } catch (Exception e) {\n+        if (!policy.shouldRetry(e, retries++)) {\n+          LOG.info(\"Exception while invoking \" + method.getName()\n+                   + \" of \" + implementation.getClass() + \". Not retrying.\"\n+                   + StringUtils.stringifyException(e));\n+          if (!method.getReturnType().equals(Void.TYPE)) {\n+            throw e; // non-void methods can\u0027t fail without an exception\n+          }\n+          return null;\n+        }\n+        LOG.debug(\"Exception while invoking \" + method.getName()\n+                 + \" of \" + implementation.getClass() + \". Retrying.\"\n+                 + StringUtils.stringifyException(e));\n+      }\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public Object invoke(Object proxy, Method method, Object[] args)\n    throws Throwable {\n    RetryPolicy policy \u003d methodNameToPolicyMap.get(method.getName());\n    if (policy \u003d\u003d null) {\n      policy \u003d defaultPolicy;\n    }\n    \n    int retries \u003d 0;\n    while (true) {\n      try {\n        return invokeMethod(method, args);\n      } catch (Exception e) {\n        if (!policy.shouldRetry(e, retries++)) {\n          LOG.info(\"Exception while invoking \" + method.getName()\n                   + \" of \" + implementation.getClass() + \". Not retrying.\"\n                   + StringUtils.stringifyException(e));\n          if (!method.getReturnType().equals(Void.TYPE)) {\n            throw e; // non-void methods can\u0027t fail without an exception\n          }\n          return null;\n        }\n        LOG.debug(\"Exception while invoking \" + method.getName()\n                 + \" of \" + implementation.getClass() + \". Retrying.\"\n                 + StringUtils.stringifyException(e));\n      }\n    }\n  }",
      "path": "src/java/org/apache/hadoop/io/retry/RetryInvocationHandler.java"
    }
  }
}