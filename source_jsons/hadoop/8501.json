{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FSImage.java",
  "functionName": "doRollback",
  "functionId": "doRollback___fsns-FSNamesystem",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
  "functionStartLine": 518,
  "functionEndLine": 569,
  "numCommitsSeen": 182,
  "timeTaken": 7577,
  "changeHistory": [
    "6ae2a0d048e133b43249c248a75a4d77d9abb80d",
    "56205ca7d7f3b2a7e55f48b9cf444326e1d2b1a7",
    "00067895a01c66d53715b50bbcb3605efd6425f2",
    "edb6dc5f303093c2604cd07b0c0dacf12dbce5de",
    "bfd227bf09c6b99c9d24d9df26fdaa502e9409a5",
    "6c0ccb5989c2053f5a1ebab0dd9fdb7b4019fda8",
    "06e84a1bca19bd01568a3095e33944d4d6387fd3",
    "8ae98a9d1ca4725e28783370517cb3a3ecda7324",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "d86f3183d93714ba078416af4f609d26376eadb0",
    "28e6a4e44a3e920dcaf858f9a74a6358226b3a63",
    "ffbe9e5972bf3eee9037e2602c1330e0dc744646",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc"
  ],
  "changeHistoryShort": {
    "6ae2a0d048e133b43249c248a75a4d77d9abb80d": "Ybodychange",
    "56205ca7d7f3b2a7e55f48b9cf444326e1d2b1a7": "Ybodychange",
    "00067895a01c66d53715b50bbcb3605efd6425f2": "Ybodychange",
    "edb6dc5f303093c2604cd07b0c0dacf12dbce5de": "Ymultichange(Yparameterchange,Ymodifierchange,Ybodychange)",
    "bfd227bf09c6b99c9d24d9df26fdaa502e9409a5": "Ybodychange",
    "6c0ccb5989c2053f5a1ebab0dd9fdb7b4019fda8": "Ybodychange",
    "06e84a1bca19bd01568a3095e33944d4d6387fd3": "Ybodychange",
    "8ae98a9d1ca4725e28783370517cb3a3ecda7324": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "d86f3183d93714ba078416af4f609d26376eadb0": "Yfilerename",
    "28e6a4e44a3e920dcaf858f9a74a6358226b3a63": "Ybodychange",
    "ffbe9e5972bf3eee9037e2602c1330e0dc744646": "Ybodychange",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yintroduced"
  },
  "changeHistoryDetails": {
    "6ae2a0d048e133b43249c248a75a4d77d9abb80d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8249. Separate HdfsConstants into the client and the server side class. Contributed by Haohui Mai.\n",
      "commitDate": "02/05/15 10:03 AM",
      "commitName": "6ae2a0d048e133b43249c248a75a4d77d9abb80d",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "14/04/15 3:05 PM",
      "commitNameOld": "fddd55279d0bdd08b3b40aba6fe2ded1d2e0d846",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 17.79,
      "commitsBetweenForRepo": 154,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,52 @@\n   void doRollback(FSNamesystem fsns) throws IOException {\n     // Rollback is allowed only if there is \n     // a previous fs states in at least one of the storage directories.\n     // Directories that don\u0027t have previous state do not rollback\n     boolean canRollback \u003d false;\n     FSImage prevState \u003d new FSImage(conf);\n     try {\n-      prevState.getStorage().layoutVersion \u003d HdfsConstants.NAMENODE_LAYOUT_VERSION;\n+      prevState.getStorage().layoutVersion \u003d HdfsServerConstants.NAMENODE_LAYOUT_VERSION;\n       for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(false); it.hasNext();) {\n         StorageDirectory sd \u003d it.next();\n         if (!NNUpgradeUtil.canRollBack(sd, storage, prevState.getStorage(),\n-            HdfsConstants.NAMENODE_LAYOUT_VERSION)) {\n+            HdfsServerConstants.NAMENODE_LAYOUT_VERSION)) {\n           continue;\n         }\n         LOG.info(\"Can perform rollback for \" + sd);\n         canRollback \u003d true;\n       }\n       \n       if (fsns.isHaEnabled()) {\n         // If HA is enabled, check if the shared log can be rolled back as well.\n         editLog.initJournalsForWrite();\n         boolean canRollBackSharedEditLog \u003d editLog.canRollBackSharedLog(\n-            prevState.getStorage(), HdfsConstants.NAMENODE_LAYOUT_VERSION);\n+            prevState.getStorage(), HdfsServerConstants.NAMENODE_LAYOUT_VERSION);\n         if (canRollBackSharedEditLog) {\n           LOG.info(\"Can perform rollback for shared edit log.\");\n           canRollback \u003d true;\n         }\n       }\n       \n       if (!canRollback)\n         throw new IOException(\"Cannot rollback. None of the storage \"\n             + \"directories contain previous fs state.\");\n   \n       // Now that we know all directories are going to be consistent\n       // Do rollback for each directory containing previous state\n       for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(false); it.hasNext();) {\n         StorageDirectory sd \u003d it.next();\n         LOG.info(\"Rolling back storage directory \" + sd.getRoot()\n                  + \".\\n   new LV \u003d \" + prevState.getStorage().getLayoutVersion()\n                  + \"; new CTime \u003d \" + prevState.getStorage().getCTime());\n         NNUpgradeUtil.doRollBack(sd);\n       }\n       if (fsns.isHaEnabled()) {\n         // If HA is enabled, try to roll back the shared log as well.\n         editLog.doRollback();\n       }\n       \n       isUpgradeFinalized \u003d true;\n     } finally {\n       prevState.close();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void doRollback(FSNamesystem fsns) throws IOException {\n    // Rollback is allowed only if there is \n    // a previous fs states in at least one of the storage directories.\n    // Directories that don\u0027t have previous state do not rollback\n    boolean canRollback \u003d false;\n    FSImage prevState \u003d new FSImage(conf);\n    try {\n      prevState.getStorage().layoutVersion \u003d HdfsServerConstants.NAMENODE_LAYOUT_VERSION;\n      for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(false); it.hasNext();) {\n        StorageDirectory sd \u003d it.next();\n        if (!NNUpgradeUtil.canRollBack(sd, storage, prevState.getStorage(),\n            HdfsServerConstants.NAMENODE_LAYOUT_VERSION)) {\n          continue;\n        }\n        LOG.info(\"Can perform rollback for \" + sd);\n        canRollback \u003d true;\n      }\n      \n      if (fsns.isHaEnabled()) {\n        // If HA is enabled, check if the shared log can be rolled back as well.\n        editLog.initJournalsForWrite();\n        boolean canRollBackSharedEditLog \u003d editLog.canRollBackSharedLog(\n            prevState.getStorage(), HdfsServerConstants.NAMENODE_LAYOUT_VERSION);\n        if (canRollBackSharedEditLog) {\n          LOG.info(\"Can perform rollback for shared edit log.\");\n          canRollback \u003d true;\n        }\n      }\n      \n      if (!canRollback)\n        throw new IOException(\"Cannot rollback. None of the storage \"\n            + \"directories contain previous fs state.\");\n  \n      // Now that we know all directories are going to be consistent\n      // Do rollback for each directory containing previous state\n      for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(false); it.hasNext();) {\n        StorageDirectory sd \u003d it.next();\n        LOG.info(\"Rolling back storage directory \" + sd.getRoot()\n                 + \".\\n   new LV \u003d \" + prevState.getStorage().getLayoutVersion()\n                 + \"; new CTime \u003d \" + prevState.getStorage().getCTime());\n        NNUpgradeUtil.doRollBack(sd);\n      }\n      if (fsns.isHaEnabled()) {\n        // If HA is enabled, try to roll back the shared log as well.\n        editLog.doRollback();\n      }\n      \n      isUpgradeFinalized \u003d true;\n    } finally {\n      prevState.close();\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {}
    },
    "56205ca7d7f3b2a7e55f48b9cf444326e1d2b1a7": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5840. Follow-up to HDFS-5138 to improve error handling during partial upgrade failures. Contributed by Aaron T. Myers, Suresh Srinivas, and Jing Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1581260 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/03/14 11:48 PM",
      "commitName": "56205ca7d7f3b2a7e55f48b9cf444326e1d2b1a7",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "24/03/14 4:32 PM",
      "commitNameOld": "c2ef7e239eb0e81cf8a3e971378e9e696202de67",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 0.3,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,52 @@\n   void doRollback(FSNamesystem fsns) throws IOException {\n     // Rollback is allowed only if there is \n     // a previous fs states in at least one of the storage directories.\n     // Directories that don\u0027t have previous state do not rollback\n     boolean canRollback \u003d false;\n     FSImage prevState \u003d new FSImage(conf);\n     try {\n       prevState.getStorage().layoutVersion \u003d HdfsConstants.NAMENODE_LAYOUT_VERSION;\n       for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(false); it.hasNext();) {\n         StorageDirectory sd \u003d it.next();\n         if (!NNUpgradeUtil.canRollBack(sd, storage, prevState.getStorage(),\n             HdfsConstants.NAMENODE_LAYOUT_VERSION)) {\n           continue;\n         }\n+        LOG.info(\"Can perform rollback for \" + sd);\n         canRollback \u003d true;\n       }\n       \n       if (fsns.isHaEnabled()) {\n         // If HA is enabled, check if the shared log can be rolled back as well.\n         editLog.initJournalsForWrite();\n-        canRollback |\u003d editLog.canRollBackSharedLog(prevState.getStorage(),\n-            HdfsConstants.NAMENODE_LAYOUT_VERSION);\n+        boolean canRollBackSharedEditLog \u003d editLog.canRollBackSharedLog(\n+            prevState.getStorage(), HdfsConstants.NAMENODE_LAYOUT_VERSION);\n+        if (canRollBackSharedEditLog) {\n+          LOG.info(\"Can perform rollback for shared edit log.\");\n+          canRollback \u003d true;\n+        }\n       }\n       \n       if (!canRollback)\n         throw new IOException(\"Cannot rollback. None of the storage \"\n             + \"directories contain previous fs state.\");\n   \n       // Now that we know all directories are going to be consistent\n       // Do rollback for each directory containing previous state\n       for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(false); it.hasNext();) {\n         StorageDirectory sd \u003d it.next();\n         LOG.info(\"Rolling back storage directory \" + sd.getRoot()\n                  + \".\\n   new LV \u003d \" + prevState.getStorage().getLayoutVersion()\n                  + \"; new CTime \u003d \" + prevState.getStorage().getCTime());\n         NNUpgradeUtil.doRollBack(sd);\n       }\n       if (fsns.isHaEnabled()) {\n         // If HA is enabled, try to roll back the shared log as well.\n         editLog.doRollback();\n       }\n       \n       isUpgradeFinalized \u003d true;\n     } finally {\n       prevState.close();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void doRollback(FSNamesystem fsns) throws IOException {\n    // Rollback is allowed only if there is \n    // a previous fs states in at least one of the storage directories.\n    // Directories that don\u0027t have previous state do not rollback\n    boolean canRollback \u003d false;\n    FSImage prevState \u003d new FSImage(conf);\n    try {\n      prevState.getStorage().layoutVersion \u003d HdfsConstants.NAMENODE_LAYOUT_VERSION;\n      for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(false); it.hasNext();) {\n        StorageDirectory sd \u003d it.next();\n        if (!NNUpgradeUtil.canRollBack(sd, storage, prevState.getStorage(),\n            HdfsConstants.NAMENODE_LAYOUT_VERSION)) {\n          continue;\n        }\n        LOG.info(\"Can perform rollback for \" + sd);\n        canRollback \u003d true;\n      }\n      \n      if (fsns.isHaEnabled()) {\n        // If HA is enabled, check if the shared log can be rolled back as well.\n        editLog.initJournalsForWrite();\n        boolean canRollBackSharedEditLog \u003d editLog.canRollBackSharedLog(\n            prevState.getStorage(), HdfsConstants.NAMENODE_LAYOUT_VERSION);\n        if (canRollBackSharedEditLog) {\n          LOG.info(\"Can perform rollback for shared edit log.\");\n          canRollback \u003d true;\n        }\n      }\n      \n      if (!canRollback)\n        throw new IOException(\"Cannot rollback. None of the storage \"\n            + \"directories contain previous fs state.\");\n  \n      // Now that we know all directories are going to be consistent\n      // Do rollback for each directory containing previous state\n      for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(false); it.hasNext();) {\n        StorageDirectory sd \u003d it.next();\n        LOG.info(\"Rolling back storage directory \" + sd.getRoot()\n                 + \".\\n   new LV \u003d \" + prevState.getStorage().getLayoutVersion()\n                 + \"; new CTime \u003d \" + prevState.getStorage().getCTime());\n        NNUpgradeUtil.doRollBack(sd);\n      }\n      if (fsns.isHaEnabled()) {\n        // If HA is enabled, try to roll back the shared log as well.\n        editLog.doRollback();\n      }\n      \n      isUpgradeFinalized \u003d true;\n    } finally {\n      prevState.close();\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {}
    },
    "00067895a01c66d53715b50bbcb3605efd6425f2": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5754. Split LayoutVerion into NameNodeLayoutVersion and DataNodeLayoutVersion. Contributed by Brandon Li\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-5535@1563041 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/01/14 7:21 PM",
      "commitName": "00067895a01c66d53715b50bbcb3605efd6425f2",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "26/01/14 8:34 AM",
      "commitNameOld": "a9110e178837bdcd236e528875daa3651e13dacc",
      "commitAuthorOld": "",
      "daysBetweenCommits": 4.45,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,47 @@\n   void doRollback(FSNamesystem fsns) throws IOException {\n     // Rollback is allowed only if there is \n     // a previous fs states in at least one of the storage directories.\n     // Directories that don\u0027t have previous state do not rollback\n     boolean canRollback \u003d false;\n     FSImage prevState \u003d new FSImage(conf);\n     try {\n-      prevState.getStorage().layoutVersion \u003d HdfsConstants.LAYOUT_VERSION;\n+      prevState.getStorage().layoutVersion \u003d HdfsConstants.NAMENODE_LAYOUT_VERSION;\n       for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(false); it.hasNext();) {\n         StorageDirectory sd \u003d it.next();\n         if (!NNUpgradeUtil.canRollBack(sd, storage, prevState.getStorage(),\n-            HdfsConstants.LAYOUT_VERSION)) {\n+            HdfsConstants.NAMENODE_LAYOUT_VERSION)) {\n           continue;\n         }\n         canRollback \u003d true;\n       }\n       \n       if (fsns.isHaEnabled()) {\n         // If HA is enabled, check if the shared log can be rolled back as well.\n         editLog.initJournalsForWrite();\n         canRollback |\u003d editLog.canRollBackSharedLog(prevState.getStorage(),\n-            HdfsConstants.LAYOUT_VERSION);\n+            HdfsConstants.NAMENODE_LAYOUT_VERSION);\n       }\n       \n       if (!canRollback)\n         throw new IOException(\"Cannot rollback. None of the storage \"\n             + \"directories contain previous fs state.\");\n   \n       // Now that we know all directories are going to be consistent\n       // Do rollback for each directory containing previous state\n       for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(false); it.hasNext();) {\n         StorageDirectory sd \u003d it.next();\n         LOG.info(\"Rolling back storage directory \" + sd.getRoot()\n                  + \".\\n   new LV \u003d \" + prevState.getStorage().getLayoutVersion()\n                  + \"; new CTime \u003d \" + prevState.getStorage().getCTime());\n         NNUpgradeUtil.doRollBack(sd);\n       }\n       if (fsns.isHaEnabled()) {\n         // If HA is enabled, try to roll back the shared log as well.\n         editLog.doRollback();\n       }\n       \n       isUpgradeFinalized \u003d true;\n     } finally {\n       prevState.close();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void doRollback(FSNamesystem fsns) throws IOException {\n    // Rollback is allowed only if there is \n    // a previous fs states in at least one of the storage directories.\n    // Directories that don\u0027t have previous state do not rollback\n    boolean canRollback \u003d false;\n    FSImage prevState \u003d new FSImage(conf);\n    try {\n      prevState.getStorage().layoutVersion \u003d HdfsConstants.NAMENODE_LAYOUT_VERSION;\n      for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(false); it.hasNext();) {\n        StorageDirectory sd \u003d it.next();\n        if (!NNUpgradeUtil.canRollBack(sd, storage, prevState.getStorage(),\n            HdfsConstants.NAMENODE_LAYOUT_VERSION)) {\n          continue;\n        }\n        canRollback \u003d true;\n      }\n      \n      if (fsns.isHaEnabled()) {\n        // If HA is enabled, check if the shared log can be rolled back as well.\n        editLog.initJournalsForWrite();\n        canRollback |\u003d editLog.canRollBackSharedLog(prevState.getStorage(),\n            HdfsConstants.NAMENODE_LAYOUT_VERSION);\n      }\n      \n      if (!canRollback)\n        throw new IOException(\"Cannot rollback. None of the storage \"\n            + \"directories contain previous fs state.\");\n  \n      // Now that we know all directories are going to be consistent\n      // Do rollback for each directory containing previous state\n      for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(false); it.hasNext();) {\n        StorageDirectory sd \u003d it.next();\n        LOG.info(\"Rolling back storage directory \" + sd.getRoot()\n                 + \".\\n   new LV \u003d \" + prevState.getStorage().getLayoutVersion()\n                 + \"; new CTime \u003d \" + prevState.getStorage().getCTime());\n        NNUpgradeUtil.doRollBack(sd);\n      }\n      if (fsns.isHaEnabled()) {\n        // If HA is enabled, try to roll back the shared log as well.\n        editLog.doRollback();\n      }\n      \n      isUpgradeFinalized \u003d true;\n    } finally {\n      prevState.close();\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {}
    },
    "edb6dc5f303093c2604cd07b0c0dacf12dbce5de": {
      "type": "Ymultichange(Yparameterchange,Ymodifierchange,Ybodychange)",
      "commitMessage": "HDFS-5138. Support HDFS upgrade in HA. Contributed by Aaron T. Myers.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1561381 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/01/14 12:01 PM",
      "commitName": "edb6dc5f303093c2604cd07b0c0dacf12dbce5de",
      "commitAuthor": "Todd Lipcon",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-5138. Support HDFS upgrade in HA. Contributed by Aaron T. Myers.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1561381 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "25/01/14 12:01 PM",
          "commitName": "edb6dc5f303093c2604cd07b0c0dacf12dbce5de",
          "commitAuthor": "Todd Lipcon",
          "commitDateOld": "07/01/14 12:52 PM",
          "commitNameOld": "70cff9e2f0c8f78c1dc54a064182971bb2106795",
          "commitAuthorOld": "Jing Zhao",
          "daysBetweenCommits": 17.96,
          "commitsBetweenForRepo": 91,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,65 +1,47 @@\n-  private void doRollback() throws IOException {\n+  void doRollback(FSNamesystem fsns) throws IOException {\n     // Rollback is allowed only if there is \n     // a previous fs states in at least one of the storage directories.\n     // Directories that don\u0027t have previous state do not rollback\n     boolean canRollback \u003d false;\n     FSImage prevState \u003d new FSImage(conf);\n     try {\n       prevState.getStorage().layoutVersion \u003d HdfsConstants.LAYOUT_VERSION;\n-      for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n+      for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(false); it.hasNext();) {\n         StorageDirectory sd \u003d it.next();\n-        File prevDir \u003d sd.getPreviousDir();\n-        if (!prevDir.exists()) {  // use current directory then\n-          LOG.info(\"Storage directory \" + sd.getRoot()\n-            + \" does not contain previous fs state.\");\n-          // read and verify consistency with other directories\n-          storage.readProperties(sd);\n+        if (!NNUpgradeUtil.canRollBack(sd, storage, prevState.getStorage(),\n+            HdfsConstants.LAYOUT_VERSION)) {\n           continue;\n         }\n-\n-        // read and verify consistency of the prev dir\n-        prevState.getStorage().readPreviousVersionProperties(sd);\n-\n-        if (prevState.getLayoutVersion() !\u003d HdfsConstants.LAYOUT_VERSION) {\n-          throw new IOException(\n-            \"Cannot rollback to storage version \" +\n-                prevState.getLayoutVersion() +\n-                \" using this version of the NameNode, which uses storage version \" +\n-                HdfsConstants.LAYOUT_VERSION + \". \" +\n-              \"Please use the previous version of HDFS to perform the rollback.\");\n-        }\n         canRollback \u003d true;\n       }\n+      \n+      if (fsns.isHaEnabled()) {\n+        // If HA is enabled, check if the shared log can be rolled back as well.\n+        editLog.initJournalsForWrite();\n+        canRollback |\u003d editLog.canRollBackSharedLog(prevState.getStorage(),\n+            HdfsConstants.LAYOUT_VERSION);\n+      }\n+      \n       if (!canRollback)\n         throw new IOException(\"Cannot rollback. None of the storage \"\n             + \"directories contain previous fs state.\");\n-\n+  \n       // Now that we know all directories are going to be consistent\n       // Do rollback for each directory containing previous state\n-      for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n+      for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(false); it.hasNext();) {\n         StorageDirectory sd \u003d it.next();\n-        File prevDir \u003d sd.getPreviousDir();\n-        if (!prevDir.exists())\n-          continue;\n-\n         LOG.info(\"Rolling back storage directory \" + sd.getRoot()\n-          + \".\\n   new LV \u003d \" + prevState.getStorage().getLayoutVersion()\n-          + \"; new CTime \u003d \" + prevState.getStorage().getCTime());\n-        File tmpDir \u003d sd.getRemovedTmp();\n-        assert !tmpDir.exists() : \"removed.tmp directory must not exist.\";\n-        // rename current to tmp\n-        File curDir \u003d sd.getCurrentDir();\n-        assert curDir.exists() : \"Current directory must exist.\";\n-        NNStorage.rename(curDir, tmpDir);\n-        // rename previous to current\n-        NNStorage.rename(prevDir, curDir);\n-\n-        // delete tmp dir\n-        NNStorage.deleteDir(tmpDir);\n-        LOG.info(\"Rollback of \" + sd.getRoot()+ \" is complete.\");\n+                 + \".\\n   new LV \u003d \" + prevState.getStorage().getLayoutVersion()\n+                 + \"; new CTime \u003d \" + prevState.getStorage().getCTime());\n+        NNUpgradeUtil.doRollBack(sd);\n       }\n+      if (fsns.isHaEnabled()) {\n+        // If HA is enabled, try to roll back the shared log as well.\n+        editLog.doRollback();\n+      }\n+      \n       isUpgradeFinalized \u003d true;\n     } finally {\n       prevState.close();\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  void doRollback(FSNamesystem fsns) throws IOException {\n    // Rollback is allowed only if there is \n    // a previous fs states in at least one of the storage directories.\n    // Directories that don\u0027t have previous state do not rollback\n    boolean canRollback \u003d false;\n    FSImage prevState \u003d new FSImage(conf);\n    try {\n      prevState.getStorage().layoutVersion \u003d HdfsConstants.LAYOUT_VERSION;\n      for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(false); it.hasNext();) {\n        StorageDirectory sd \u003d it.next();\n        if (!NNUpgradeUtil.canRollBack(sd, storage, prevState.getStorage(),\n            HdfsConstants.LAYOUT_VERSION)) {\n          continue;\n        }\n        canRollback \u003d true;\n      }\n      \n      if (fsns.isHaEnabled()) {\n        // If HA is enabled, check if the shared log can be rolled back as well.\n        editLog.initJournalsForWrite();\n        canRollback |\u003d editLog.canRollBackSharedLog(prevState.getStorage(),\n            HdfsConstants.LAYOUT_VERSION);\n      }\n      \n      if (!canRollback)\n        throw new IOException(\"Cannot rollback. None of the storage \"\n            + \"directories contain previous fs state.\");\n  \n      // Now that we know all directories are going to be consistent\n      // Do rollback for each directory containing previous state\n      for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(false); it.hasNext();) {\n        StorageDirectory sd \u003d it.next();\n        LOG.info(\"Rolling back storage directory \" + sd.getRoot()\n                 + \".\\n   new LV \u003d \" + prevState.getStorage().getLayoutVersion()\n                 + \"; new CTime \u003d \" + prevState.getStorage().getCTime());\n        NNUpgradeUtil.doRollBack(sd);\n      }\n      if (fsns.isHaEnabled()) {\n        // If HA is enabled, try to roll back the shared log as well.\n        editLog.doRollback();\n      }\n      \n      isUpgradeFinalized \u003d true;\n    } finally {\n      prevState.close();\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[fsns-FSNamesystem]"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "HDFS-5138. Support HDFS upgrade in HA. Contributed by Aaron T. Myers.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1561381 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "25/01/14 12:01 PM",
          "commitName": "edb6dc5f303093c2604cd07b0c0dacf12dbce5de",
          "commitAuthor": "Todd Lipcon",
          "commitDateOld": "07/01/14 12:52 PM",
          "commitNameOld": "70cff9e2f0c8f78c1dc54a064182971bb2106795",
          "commitAuthorOld": "Jing Zhao",
          "daysBetweenCommits": 17.96,
          "commitsBetweenForRepo": 91,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,65 +1,47 @@\n-  private void doRollback() throws IOException {\n+  void doRollback(FSNamesystem fsns) throws IOException {\n     // Rollback is allowed only if there is \n     // a previous fs states in at least one of the storage directories.\n     // Directories that don\u0027t have previous state do not rollback\n     boolean canRollback \u003d false;\n     FSImage prevState \u003d new FSImage(conf);\n     try {\n       prevState.getStorage().layoutVersion \u003d HdfsConstants.LAYOUT_VERSION;\n-      for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n+      for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(false); it.hasNext();) {\n         StorageDirectory sd \u003d it.next();\n-        File prevDir \u003d sd.getPreviousDir();\n-        if (!prevDir.exists()) {  // use current directory then\n-          LOG.info(\"Storage directory \" + sd.getRoot()\n-            + \" does not contain previous fs state.\");\n-          // read and verify consistency with other directories\n-          storage.readProperties(sd);\n+        if (!NNUpgradeUtil.canRollBack(sd, storage, prevState.getStorage(),\n+            HdfsConstants.LAYOUT_VERSION)) {\n           continue;\n         }\n-\n-        // read and verify consistency of the prev dir\n-        prevState.getStorage().readPreviousVersionProperties(sd);\n-\n-        if (prevState.getLayoutVersion() !\u003d HdfsConstants.LAYOUT_VERSION) {\n-          throw new IOException(\n-            \"Cannot rollback to storage version \" +\n-                prevState.getLayoutVersion() +\n-                \" using this version of the NameNode, which uses storage version \" +\n-                HdfsConstants.LAYOUT_VERSION + \". \" +\n-              \"Please use the previous version of HDFS to perform the rollback.\");\n-        }\n         canRollback \u003d true;\n       }\n+      \n+      if (fsns.isHaEnabled()) {\n+        // If HA is enabled, check if the shared log can be rolled back as well.\n+        editLog.initJournalsForWrite();\n+        canRollback |\u003d editLog.canRollBackSharedLog(prevState.getStorage(),\n+            HdfsConstants.LAYOUT_VERSION);\n+      }\n+      \n       if (!canRollback)\n         throw new IOException(\"Cannot rollback. None of the storage \"\n             + \"directories contain previous fs state.\");\n-\n+  \n       // Now that we know all directories are going to be consistent\n       // Do rollback for each directory containing previous state\n-      for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n+      for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(false); it.hasNext();) {\n         StorageDirectory sd \u003d it.next();\n-        File prevDir \u003d sd.getPreviousDir();\n-        if (!prevDir.exists())\n-          continue;\n-\n         LOG.info(\"Rolling back storage directory \" + sd.getRoot()\n-          + \".\\n   new LV \u003d \" + prevState.getStorage().getLayoutVersion()\n-          + \"; new CTime \u003d \" + prevState.getStorage().getCTime());\n-        File tmpDir \u003d sd.getRemovedTmp();\n-        assert !tmpDir.exists() : \"removed.tmp directory must not exist.\";\n-        // rename current to tmp\n-        File curDir \u003d sd.getCurrentDir();\n-        assert curDir.exists() : \"Current directory must exist.\";\n-        NNStorage.rename(curDir, tmpDir);\n-        // rename previous to current\n-        NNStorage.rename(prevDir, curDir);\n-\n-        // delete tmp dir\n-        NNStorage.deleteDir(tmpDir);\n-        LOG.info(\"Rollback of \" + sd.getRoot()+ \" is complete.\");\n+                 + \".\\n   new LV \u003d \" + prevState.getStorage().getLayoutVersion()\n+                 + \"; new CTime \u003d \" + prevState.getStorage().getCTime());\n+        NNUpgradeUtil.doRollBack(sd);\n       }\n+      if (fsns.isHaEnabled()) {\n+        // If HA is enabled, try to roll back the shared log as well.\n+        editLog.doRollback();\n+      }\n+      \n       isUpgradeFinalized \u003d true;\n     } finally {\n       prevState.close();\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  void doRollback(FSNamesystem fsns) throws IOException {\n    // Rollback is allowed only if there is \n    // a previous fs states in at least one of the storage directories.\n    // Directories that don\u0027t have previous state do not rollback\n    boolean canRollback \u003d false;\n    FSImage prevState \u003d new FSImage(conf);\n    try {\n      prevState.getStorage().layoutVersion \u003d HdfsConstants.LAYOUT_VERSION;\n      for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(false); it.hasNext();) {\n        StorageDirectory sd \u003d it.next();\n        if (!NNUpgradeUtil.canRollBack(sd, storage, prevState.getStorage(),\n            HdfsConstants.LAYOUT_VERSION)) {\n          continue;\n        }\n        canRollback \u003d true;\n      }\n      \n      if (fsns.isHaEnabled()) {\n        // If HA is enabled, check if the shared log can be rolled back as well.\n        editLog.initJournalsForWrite();\n        canRollback |\u003d editLog.canRollBackSharedLog(prevState.getStorage(),\n            HdfsConstants.LAYOUT_VERSION);\n      }\n      \n      if (!canRollback)\n        throw new IOException(\"Cannot rollback. None of the storage \"\n            + \"directories contain previous fs state.\");\n  \n      // Now that we know all directories are going to be consistent\n      // Do rollback for each directory containing previous state\n      for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(false); it.hasNext();) {\n        StorageDirectory sd \u003d it.next();\n        LOG.info(\"Rolling back storage directory \" + sd.getRoot()\n                 + \".\\n   new LV \u003d \" + prevState.getStorage().getLayoutVersion()\n                 + \"; new CTime \u003d \" + prevState.getStorage().getCTime());\n        NNUpgradeUtil.doRollBack(sd);\n      }\n      if (fsns.isHaEnabled()) {\n        // If HA is enabled, try to roll back the shared log as well.\n        editLog.doRollback();\n      }\n      \n      isUpgradeFinalized \u003d true;\n    } finally {\n      prevState.close();\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
          "extendedDetails": {
            "oldValue": "[private]",
            "newValue": "[]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-5138. Support HDFS upgrade in HA. Contributed by Aaron T. Myers.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1561381 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "25/01/14 12:01 PM",
          "commitName": "edb6dc5f303093c2604cd07b0c0dacf12dbce5de",
          "commitAuthor": "Todd Lipcon",
          "commitDateOld": "07/01/14 12:52 PM",
          "commitNameOld": "70cff9e2f0c8f78c1dc54a064182971bb2106795",
          "commitAuthorOld": "Jing Zhao",
          "daysBetweenCommits": 17.96,
          "commitsBetweenForRepo": 91,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,65 +1,47 @@\n-  private void doRollback() throws IOException {\n+  void doRollback(FSNamesystem fsns) throws IOException {\n     // Rollback is allowed only if there is \n     // a previous fs states in at least one of the storage directories.\n     // Directories that don\u0027t have previous state do not rollback\n     boolean canRollback \u003d false;\n     FSImage prevState \u003d new FSImage(conf);\n     try {\n       prevState.getStorage().layoutVersion \u003d HdfsConstants.LAYOUT_VERSION;\n-      for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n+      for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(false); it.hasNext();) {\n         StorageDirectory sd \u003d it.next();\n-        File prevDir \u003d sd.getPreviousDir();\n-        if (!prevDir.exists()) {  // use current directory then\n-          LOG.info(\"Storage directory \" + sd.getRoot()\n-            + \" does not contain previous fs state.\");\n-          // read and verify consistency with other directories\n-          storage.readProperties(sd);\n+        if (!NNUpgradeUtil.canRollBack(sd, storage, prevState.getStorage(),\n+            HdfsConstants.LAYOUT_VERSION)) {\n           continue;\n         }\n-\n-        // read and verify consistency of the prev dir\n-        prevState.getStorage().readPreviousVersionProperties(sd);\n-\n-        if (prevState.getLayoutVersion() !\u003d HdfsConstants.LAYOUT_VERSION) {\n-          throw new IOException(\n-            \"Cannot rollback to storage version \" +\n-                prevState.getLayoutVersion() +\n-                \" using this version of the NameNode, which uses storage version \" +\n-                HdfsConstants.LAYOUT_VERSION + \". \" +\n-              \"Please use the previous version of HDFS to perform the rollback.\");\n-        }\n         canRollback \u003d true;\n       }\n+      \n+      if (fsns.isHaEnabled()) {\n+        // If HA is enabled, check if the shared log can be rolled back as well.\n+        editLog.initJournalsForWrite();\n+        canRollback |\u003d editLog.canRollBackSharedLog(prevState.getStorage(),\n+            HdfsConstants.LAYOUT_VERSION);\n+      }\n+      \n       if (!canRollback)\n         throw new IOException(\"Cannot rollback. None of the storage \"\n             + \"directories contain previous fs state.\");\n-\n+  \n       // Now that we know all directories are going to be consistent\n       // Do rollback for each directory containing previous state\n-      for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n+      for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(false); it.hasNext();) {\n         StorageDirectory sd \u003d it.next();\n-        File prevDir \u003d sd.getPreviousDir();\n-        if (!prevDir.exists())\n-          continue;\n-\n         LOG.info(\"Rolling back storage directory \" + sd.getRoot()\n-          + \".\\n   new LV \u003d \" + prevState.getStorage().getLayoutVersion()\n-          + \"; new CTime \u003d \" + prevState.getStorage().getCTime());\n-        File tmpDir \u003d sd.getRemovedTmp();\n-        assert !tmpDir.exists() : \"removed.tmp directory must not exist.\";\n-        // rename current to tmp\n-        File curDir \u003d sd.getCurrentDir();\n-        assert curDir.exists() : \"Current directory must exist.\";\n-        NNStorage.rename(curDir, tmpDir);\n-        // rename previous to current\n-        NNStorage.rename(prevDir, curDir);\n-\n-        // delete tmp dir\n-        NNStorage.deleteDir(tmpDir);\n-        LOG.info(\"Rollback of \" + sd.getRoot()+ \" is complete.\");\n+                 + \".\\n   new LV \u003d \" + prevState.getStorage().getLayoutVersion()\n+                 + \"; new CTime \u003d \" + prevState.getStorage().getCTime());\n+        NNUpgradeUtil.doRollBack(sd);\n       }\n+      if (fsns.isHaEnabled()) {\n+        // If HA is enabled, try to roll back the shared log as well.\n+        editLog.doRollback();\n+      }\n+      \n       isUpgradeFinalized \u003d true;\n     } finally {\n       prevState.close();\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  void doRollback(FSNamesystem fsns) throws IOException {\n    // Rollback is allowed only if there is \n    // a previous fs states in at least one of the storage directories.\n    // Directories that don\u0027t have previous state do not rollback\n    boolean canRollback \u003d false;\n    FSImage prevState \u003d new FSImage(conf);\n    try {\n      prevState.getStorage().layoutVersion \u003d HdfsConstants.LAYOUT_VERSION;\n      for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(false); it.hasNext();) {\n        StorageDirectory sd \u003d it.next();\n        if (!NNUpgradeUtil.canRollBack(sd, storage, prevState.getStorage(),\n            HdfsConstants.LAYOUT_VERSION)) {\n          continue;\n        }\n        canRollback \u003d true;\n      }\n      \n      if (fsns.isHaEnabled()) {\n        // If HA is enabled, check if the shared log can be rolled back as well.\n        editLog.initJournalsForWrite();\n        canRollback |\u003d editLog.canRollBackSharedLog(prevState.getStorage(),\n            HdfsConstants.LAYOUT_VERSION);\n      }\n      \n      if (!canRollback)\n        throw new IOException(\"Cannot rollback. None of the storage \"\n            + \"directories contain previous fs state.\");\n  \n      // Now that we know all directories are going to be consistent\n      // Do rollback for each directory containing previous state\n      for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(false); it.hasNext();) {\n        StorageDirectory sd \u003d it.next();\n        LOG.info(\"Rolling back storage directory \" + sd.getRoot()\n                 + \".\\n   new LV \u003d \" + prevState.getStorage().getLayoutVersion()\n                 + \"; new CTime \u003d \" + prevState.getStorage().getCTime());\n        NNUpgradeUtil.doRollBack(sd);\n      }\n      if (fsns.isHaEnabled()) {\n        // If HA is enabled, try to roll back the shared log as well.\n        editLog.doRollback();\n      }\n      \n      isUpgradeFinalized \u003d true;\n    } finally {\n      prevState.close();\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
          "extendedDetails": {}
        }
      ]
    },
    "bfd227bf09c6b99c9d24d9df26fdaa502e9409a5": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5719. FSImage#doRollback() should close prevState before return. Contributed by Ted Yu\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1556057 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "06/01/14 2:58 PM",
      "commitName": "bfd227bf09c6b99c9d24d9df26fdaa502e9409a5",
      "commitAuthor": "Brandon Li",
      "commitDateOld": "26/11/13 10:33 AM",
      "commitNameOld": "82ff2d3f2e569879500d851f4d67dfa2d02b5c9b",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 41.18,
      "commitsBetweenForRepo": 189,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,61 +1,65 @@\n   private void doRollback() throws IOException {\n     // Rollback is allowed only if there is \n     // a previous fs states in at least one of the storage directories.\n     // Directories that don\u0027t have previous state do not rollback\n     boolean canRollback \u003d false;\n     FSImage prevState \u003d new FSImage(conf);\n-    prevState.getStorage().layoutVersion \u003d HdfsConstants.LAYOUT_VERSION;\n-    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n-      StorageDirectory sd \u003d it.next();\n-      File prevDir \u003d sd.getPreviousDir();\n-      if (!prevDir.exists()) {  // use current directory then\n-        LOG.info(\"Storage directory \" + sd.getRoot()\n-                 + \" does not contain previous fs state.\");\n-        // read and verify consistency with other directories\n-        storage.readProperties(sd);\n-        continue;\n+    try {\n+      prevState.getStorage().layoutVersion \u003d HdfsConstants.LAYOUT_VERSION;\n+      for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n+        StorageDirectory sd \u003d it.next();\n+        File prevDir \u003d sd.getPreviousDir();\n+        if (!prevDir.exists()) {  // use current directory then\n+          LOG.info(\"Storage directory \" + sd.getRoot()\n+            + \" does not contain previous fs state.\");\n+          // read and verify consistency with other directories\n+          storage.readProperties(sd);\n+          continue;\n+        }\n+\n+        // read and verify consistency of the prev dir\n+        prevState.getStorage().readPreviousVersionProperties(sd);\n+\n+        if (prevState.getLayoutVersion() !\u003d HdfsConstants.LAYOUT_VERSION) {\n+          throw new IOException(\n+            \"Cannot rollback to storage version \" +\n+                prevState.getLayoutVersion() +\n+                \" using this version of the NameNode, which uses storage version \" +\n+                HdfsConstants.LAYOUT_VERSION + \". \" +\n+              \"Please use the previous version of HDFS to perform the rollback.\");\n+        }\n+        canRollback \u003d true;\n       }\n+      if (!canRollback)\n+        throw new IOException(\"Cannot rollback. None of the storage \"\n+            + \"directories contain previous fs state.\");\n \n-      // read and verify consistency of the prev dir\n-      prevState.getStorage().readPreviousVersionProperties(sd);\n+      // Now that we know all directories are going to be consistent\n+      // Do rollback for each directory containing previous state\n+      for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n+        StorageDirectory sd \u003d it.next();\n+        File prevDir \u003d sd.getPreviousDir();\n+        if (!prevDir.exists())\n+          continue;\n \n-      if (prevState.getLayoutVersion() !\u003d HdfsConstants.LAYOUT_VERSION) {\n-        throw new IOException(\n-          \"Cannot rollback to storage version \" +\n-          prevState.getLayoutVersion() +\n-          \" using this version of the NameNode, which uses storage version \" +\n-          HdfsConstants.LAYOUT_VERSION + \". \" +\n-          \"Please use the previous version of HDFS to perform the rollback.\");\n+        LOG.info(\"Rolling back storage directory \" + sd.getRoot()\n+          + \".\\n   new LV \u003d \" + prevState.getStorage().getLayoutVersion()\n+          + \"; new CTime \u003d \" + prevState.getStorage().getCTime());\n+        File tmpDir \u003d sd.getRemovedTmp();\n+        assert !tmpDir.exists() : \"removed.tmp directory must not exist.\";\n+        // rename current to tmp\n+        File curDir \u003d sd.getCurrentDir();\n+        assert curDir.exists() : \"Current directory must exist.\";\n+        NNStorage.rename(curDir, tmpDir);\n+        // rename previous to current\n+        NNStorage.rename(prevDir, curDir);\n+\n+        // delete tmp dir\n+        NNStorage.deleteDir(tmpDir);\n+        LOG.info(\"Rollback of \" + sd.getRoot()+ \" is complete.\");\n       }\n-      canRollback \u003d true;\n+      isUpgradeFinalized \u003d true;\n+    } finally {\n+      prevState.close();\n     }\n-    if (!canRollback)\n-      throw new IOException(\"Cannot rollback. None of the storage \"\n-                            + \"directories contain previous fs state.\");\n-\n-    // Now that we know all directories are going to be consistent\n-    // Do rollback for each directory containing previous state\n-    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n-      StorageDirectory sd \u003d it.next();\n-      File prevDir \u003d sd.getPreviousDir();\n-      if (!prevDir.exists())\n-        continue;\n-\n-      LOG.info(\"Rolling back storage directory \" + sd.getRoot()\n-               + \".\\n   new LV \u003d \" + prevState.getStorage().getLayoutVersion()\n-               + \"; new CTime \u003d \" + prevState.getStorage().getCTime());\n-      File tmpDir \u003d sd.getRemovedTmp();\n-      assert !tmpDir.exists() : \"removed.tmp directory must not exist.\";\n-      // rename current to tmp\n-      File curDir \u003d sd.getCurrentDir();\n-      assert curDir.exists() : \"Current directory must exist.\";\n-      NNStorage.rename(curDir, tmpDir);\n-      // rename previous to current\n-      NNStorage.rename(prevDir, curDir);\n-\n-      // delete tmp dir\n-      NNStorage.deleteDir(tmpDir);\n-      LOG.info(\"Rollback of \" + sd.getRoot()+ \" is complete.\");\n-    }\n-    isUpgradeFinalized \u003d true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void doRollback() throws IOException {\n    // Rollback is allowed only if there is \n    // a previous fs states in at least one of the storage directories.\n    // Directories that don\u0027t have previous state do not rollback\n    boolean canRollback \u003d false;\n    FSImage prevState \u003d new FSImage(conf);\n    try {\n      prevState.getStorage().layoutVersion \u003d HdfsConstants.LAYOUT_VERSION;\n      for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n        StorageDirectory sd \u003d it.next();\n        File prevDir \u003d sd.getPreviousDir();\n        if (!prevDir.exists()) {  // use current directory then\n          LOG.info(\"Storage directory \" + sd.getRoot()\n            + \" does not contain previous fs state.\");\n          // read and verify consistency with other directories\n          storage.readProperties(sd);\n          continue;\n        }\n\n        // read and verify consistency of the prev dir\n        prevState.getStorage().readPreviousVersionProperties(sd);\n\n        if (prevState.getLayoutVersion() !\u003d HdfsConstants.LAYOUT_VERSION) {\n          throw new IOException(\n            \"Cannot rollback to storage version \" +\n                prevState.getLayoutVersion() +\n                \" using this version of the NameNode, which uses storage version \" +\n                HdfsConstants.LAYOUT_VERSION + \". \" +\n              \"Please use the previous version of HDFS to perform the rollback.\");\n        }\n        canRollback \u003d true;\n      }\n      if (!canRollback)\n        throw new IOException(\"Cannot rollback. None of the storage \"\n            + \"directories contain previous fs state.\");\n\n      // Now that we know all directories are going to be consistent\n      // Do rollback for each directory containing previous state\n      for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n        StorageDirectory sd \u003d it.next();\n        File prevDir \u003d sd.getPreviousDir();\n        if (!prevDir.exists())\n          continue;\n\n        LOG.info(\"Rolling back storage directory \" + sd.getRoot()\n          + \".\\n   new LV \u003d \" + prevState.getStorage().getLayoutVersion()\n          + \"; new CTime \u003d \" + prevState.getStorage().getCTime());\n        File tmpDir \u003d sd.getRemovedTmp();\n        assert !tmpDir.exists() : \"removed.tmp directory must not exist.\";\n        // rename current to tmp\n        File curDir \u003d sd.getCurrentDir();\n        assert curDir.exists() : \"Current directory must exist.\";\n        NNStorage.rename(curDir, tmpDir);\n        // rename previous to current\n        NNStorage.rename(prevDir, curDir);\n\n        // delete tmp dir\n        NNStorage.deleteDir(tmpDir);\n        LOG.info(\"Rollback of \" + sd.getRoot()+ \" is complete.\");\n      }\n      isUpgradeFinalized \u003d true;\n    } finally {\n      prevState.close();\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {}
    },
    "6c0ccb5989c2053f5a1ebab0dd9fdb7b4019fda8": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2686. Remove DistributedUpgrade related code. Contributed by Suresh Srinivas\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1375800 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/08/12 2:18 PM",
      "commitName": "6c0ccb5989c2053f5a1ebab0dd9fdb7b4019fda8",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "09/08/12 3:13 PM",
      "commitNameOld": "9d0f8792a9a1d3d2b24adfc2c213247a099e7ad1",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 11.96,
      "commitsBetweenForRepo": 66,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,63 +1,61 @@\n   private void doRollback() throws IOException {\n     // Rollback is allowed only if there is \n     // a previous fs states in at least one of the storage directories.\n     // Directories that don\u0027t have previous state do not rollback\n     boolean canRollback \u003d false;\n     FSImage prevState \u003d new FSImage(conf);\n     prevState.getStorage().layoutVersion \u003d HdfsConstants.LAYOUT_VERSION;\n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       File prevDir \u003d sd.getPreviousDir();\n       if (!prevDir.exists()) {  // use current directory then\n         LOG.info(\"Storage directory \" + sd.getRoot()\n                  + \" does not contain previous fs state.\");\n         // read and verify consistency with other directories\n         storage.readProperties(sd);\n         continue;\n       }\n \n       // read and verify consistency of the prev dir\n       prevState.getStorage().readPreviousVersionProperties(sd);\n \n       if (prevState.getLayoutVersion() !\u003d HdfsConstants.LAYOUT_VERSION) {\n         throw new IOException(\n           \"Cannot rollback to storage version \" +\n           prevState.getLayoutVersion() +\n           \" using this version of the NameNode, which uses storage version \" +\n           HdfsConstants.LAYOUT_VERSION + \". \" +\n           \"Please use the previous version of HDFS to perform the rollback.\");\n       }\n       canRollback \u003d true;\n     }\n     if (!canRollback)\n       throw new IOException(\"Cannot rollback. None of the storage \"\n                             + \"directories contain previous fs state.\");\n \n     // Now that we know all directories are going to be consistent\n     // Do rollback for each directory containing previous state\n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       File prevDir \u003d sd.getPreviousDir();\n       if (!prevDir.exists())\n         continue;\n \n       LOG.info(\"Rolling back storage directory \" + sd.getRoot()\n                + \".\\n   new LV \u003d \" + prevState.getStorage().getLayoutVersion()\n                + \"; new CTime \u003d \" + prevState.getStorage().getCTime());\n       File tmpDir \u003d sd.getRemovedTmp();\n       assert !tmpDir.exists() : \"removed.tmp directory must not exist.\";\n       // rename current to tmp\n       File curDir \u003d sd.getCurrentDir();\n       assert curDir.exists() : \"Current directory must exist.\";\n       NNStorage.rename(curDir, tmpDir);\n       // rename previous to current\n       NNStorage.rename(prevDir, curDir);\n \n       // delete tmp dir\n       NNStorage.deleteDir(tmpDir);\n       LOG.info(\"Rollback of \" + sd.getRoot()+ \" is complete.\");\n     }\n     isUpgradeFinalized \u003d true;\n-    // check whether name-node can start in regular mode\n-    storage.verifyDistributedUpgradeProgress(StartupOption.REGULAR);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void doRollback() throws IOException {\n    // Rollback is allowed only if there is \n    // a previous fs states in at least one of the storage directories.\n    // Directories that don\u0027t have previous state do not rollback\n    boolean canRollback \u003d false;\n    FSImage prevState \u003d new FSImage(conf);\n    prevState.getStorage().layoutVersion \u003d HdfsConstants.LAYOUT_VERSION;\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      File prevDir \u003d sd.getPreviousDir();\n      if (!prevDir.exists()) {  // use current directory then\n        LOG.info(\"Storage directory \" + sd.getRoot()\n                 + \" does not contain previous fs state.\");\n        // read and verify consistency with other directories\n        storage.readProperties(sd);\n        continue;\n      }\n\n      // read and verify consistency of the prev dir\n      prevState.getStorage().readPreviousVersionProperties(sd);\n\n      if (prevState.getLayoutVersion() !\u003d HdfsConstants.LAYOUT_VERSION) {\n        throw new IOException(\n          \"Cannot rollback to storage version \" +\n          prevState.getLayoutVersion() +\n          \" using this version of the NameNode, which uses storage version \" +\n          HdfsConstants.LAYOUT_VERSION + \". \" +\n          \"Please use the previous version of HDFS to perform the rollback.\");\n      }\n      canRollback \u003d true;\n    }\n    if (!canRollback)\n      throw new IOException(\"Cannot rollback. None of the storage \"\n                            + \"directories contain previous fs state.\");\n\n    // Now that we know all directories are going to be consistent\n    // Do rollback for each directory containing previous state\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      File prevDir \u003d sd.getPreviousDir();\n      if (!prevDir.exists())\n        continue;\n\n      LOG.info(\"Rolling back storage directory \" + sd.getRoot()\n               + \".\\n   new LV \u003d \" + prevState.getStorage().getLayoutVersion()\n               + \"; new CTime \u003d \" + prevState.getStorage().getCTime());\n      File tmpDir \u003d sd.getRemovedTmp();\n      assert !tmpDir.exists() : \"removed.tmp directory must not exist.\";\n      // rename current to tmp\n      File curDir \u003d sd.getCurrentDir();\n      assert curDir.exists() : \"Current directory must exist.\";\n      NNStorage.rename(curDir, tmpDir);\n      // rename previous to current\n      NNStorage.rename(prevDir, curDir);\n\n      // delete tmp dir\n      NNStorage.deleteDir(tmpDir);\n      LOG.info(\"Rollback of \" + sd.getRoot()+ \" is complete.\");\n    }\n    isUpgradeFinalized \u003d true;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {}
    },
    "06e84a1bca19bd01568a3095e33944d4d6387fd3": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2223. Untangle depencencies between NN components. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1166466 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/09/11 4:23 PM",
      "commitName": "06e84a1bca19bd01568a3095e33944d4d6387fd3",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "06/09/11 1:27 PM",
      "commitNameOld": "bdc3720d5b67a1c8fc2dfb29be16e4155c0e7f15",
      "commitAuthorOld": "Jitendra Nath Pandey",
      "daysBetweenCommits": 1.12,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,63 +1,63 @@\n   private void doRollback() throws IOException {\n     // Rollback is allowed only if there is \n     // a previous fs states in at least one of the storage directories.\n     // Directories that don\u0027t have previous state do not rollback\n     boolean canRollback \u003d false;\n-    FSImage prevState \u003d new FSImage(conf, getFSNamesystem());\n+    FSImage prevState \u003d new FSImage(conf);\n     prevState.getStorage().layoutVersion \u003d HdfsConstants.LAYOUT_VERSION;\n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       File prevDir \u003d sd.getPreviousDir();\n       if (!prevDir.exists()) {  // use current directory then\n         LOG.info(\"Storage directory \" + sd.getRoot()\n                  + \" does not contain previous fs state.\");\n         // read and verify consistency with other directories\n         storage.readProperties(sd);\n         continue;\n       }\n \n       // read and verify consistency of the prev dir\n       prevState.getStorage().readPreviousVersionProperties(sd);\n \n       if (prevState.getLayoutVersion() !\u003d HdfsConstants.LAYOUT_VERSION) {\n         throw new IOException(\n           \"Cannot rollback to storage version \" +\n           prevState.getLayoutVersion() +\n           \" using this version of the NameNode, which uses storage version \" +\n           HdfsConstants.LAYOUT_VERSION + \". \" +\n           \"Please use the previous version of HDFS to perform the rollback.\");\n       }\n       canRollback \u003d true;\n     }\n     if (!canRollback)\n       throw new IOException(\"Cannot rollback. None of the storage \"\n                             + \"directories contain previous fs state.\");\n \n     // Now that we know all directories are going to be consistent\n     // Do rollback for each directory containing previous state\n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       File prevDir \u003d sd.getPreviousDir();\n       if (!prevDir.exists())\n         continue;\n \n       LOG.info(\"Rolling back storage directory \" + sd.getRoot()\n                + \".\\n   new LV \u003d \" + prevState.getStorage().getLayoutVersion()\n                + \"; new CTime \u003d \" + prevState.getStorage().getCTime());\n       File tmpDir \u003d sd.getRemovedTmp();\n       assert !tmpDir.exists() : \"removed.tmp directory must not exist.\";\n       // rename current to tmp\n       File curDir \u003d sd.getCurrentDir();\n       assert curDir.exists() : \"Current directory must exist.\";\n       NNStorage.rename(curDir, tmpDir);\n       // rename previous to current\n       NNStorage.rename(prevDir, curDir);\n \n       // delete tmp dir\n       NNStorage.deleteDir(tmpDir);\n       LOG.info(\"Rollback of \" + sd.getRoot()+ \" is complete.\");\n     }\n     isUpgradeFinalized \u003d true;\n     // check whether name-node can start in regular mode\n     storage.verifyDistributedUpgradeProgress(StartupOption.REGULAR);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void doRollback() throws IOException {\n    // Rollback is allowed only if there is \n    // a previous fs states in at least one of the storage directories.\n    // Directories that don\u0027t have previous state do not rollback\n    boolean canRollback \u003d false;\n    FSImage prevState \u003d new FSImage(conf);\n    prevState.getStorage().layoutVersion \u003d HdfsConstants.LAYOUT_VERSION;\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      File prevDir \u003d sd.getPreviousDir();\n      if (!prevDir.exists()) {  // use current directory then\n        LOG.info(\"Storage directory \" + sd.getRoot()\n                 + \" does not contain previous fs state.\");\n        // read and verify consistency with other directories\n        storage.readProperties(sd);\n        continue;\n      }\n\n      // read and verify consistency of the prev dir\n      prevState.getStorage().readPreviousVersionProperties(sd);\n\n      if (prevState.getLayoutVersion() !\u003d HdfsConstants.LAYOUT_VERSION) {\n        throw new IOException(\n          \"Cannot rollback to storage version \" +\n          prevState.getLayoutVersion() +\n          \" using this version of the NameNode, which uses storage version \" +\n          HdfsConstants.LAYOUT_VERSION + \". \" +\n          \"Please use the previous version of HDFS to perform the rollback.\");\n      }\n      canRollback \u003d true;\n    }\n    if (!canRollback)\n      throw new IOException(\"Cannot rollback. None of the storage \"\n                            + \"directories contain previous fs state.\");\n\n    // Now that we know all directories are going to be consistent\n    // Do rollback for each directory containing previous state\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      File prevDir \u003d sd.getPreviousDir();\n      if (!prevDir.exists())\n        continue;\n\n      LOG.info(\"Rolling back storage directory \" + sd.getRoot()\n               + \".\\n   new LV \u003d \" + prevState.getStorage().getLayoutVersion()\n               + \"; new CTime \u003d \" + prevState.getStorage().getCTime());\n      File tmpDir \u003d sd.getRemovedTmp();\n      assert !tmpDir.exists() : \"removed.tmp directory must not exist.\";\n      // rename current to tmp\n      File curDir \u003d sd.getCurrentDir();\n      assert curDir.exists() : \"Current directory must exist.\";\n      NNStorage.rename(curDir, tmpDir);\n      // rename previous to current\n      NNStorage.rename(prevDir, curDir);\n\n      // delete tmp dir\n      NNStorage.deleteDir(tmpDir);\n      LOG.info(\"Rollback of \" + sd.getRoot()+ \" is complete.\");\n    }\n    isUpgradeFinalized \u003d true;\n    // check whether name-node can start in regular mode\n    storage.verifyDistributedUpgradeProgress(StartupOption.REGULAR);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {}
    },
    "8ae98a9d1ca4725e28783370517cb3a3ecda7324": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-1620. Rename HdfsConstants -\u003e HdfsServerConstants, FSConstants -\u003e HdfsConstants. (Harsh J Chouraria via atm)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1165096 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/09/11 12:30 PM",
      "commitName": "8ae98a9d1ca4725e28783370517cb3a3ecda7324",
      "commitAuthor": "Aaron Myers",
      "commitDateOld": "24/08/11 5:14 PM",
      "commitNameOld": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 10.8,
      "commitsBetweenForRepo": 53,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,63 +1,63 @@\n   private void doRollback() throws IOException {\n     // Rollback is allowed only if there is \n     // a previous fs states in at least one of the storage directories.\n     // Directories that don\u0027t have previous state do not rollback\n     boolean canRollback \u003d false;\n     FSImage prevState \u003d new FSImage(conf, getFSNamesystem());\n-    prevState.getStorage().layoutVersion \u003d FSConstants.LAYOUT_VERSION;\n+    prevState.getStorage().layoutVersion \u003d HdfsConstants.LAYOUT_VERSION;\n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       File prevDir \u003d sd.getPreviousDir();\n       if (!prevDir.exists()) {  // use current directory then\n         LOG.info(\"Storage directory \" + sd.getRoot()\n                  + \" does not contain previous fs state.\");\n         // read and verify consistency with other directories\n         storage.readProperties(sd);\n         continue;\n       }\n \n       // read and verify consistency of the prev dir\n       prevState.getStorage().readPreviousVersionProperties(sd);\n \n-      if (prevState.getLayoutVersion() !\u003d FSConstants.LAYOUT_VERSION) {\n+      if (prevState.getLayoutVersion() !\u003d HdfsConstants.LAYOUT_VERSION) {\n         throw new IOException(\n           \"Cannot rollback to storage version \" +\n           prevState.getLayoutVersion() +\n           \" using this version of the NameNode, which uses storage version \" +\n-          FSConstants.LAYOUT_VERSION + \". \" +\n+          HdfsConstants.LAYOUT_VERSION + \". \" +\n           \"Please use the previous version of HDFS to perform the rollback.\");\n       }\n       canRollback \u003d true;\n     }\n     if (!canRollback)\n       throw new IOException(\"Cannot rollback. None of the storage \"\n                             + \"directories contain previous fs state.\");\n \n     // Now that we know all directories are going to be consistent\n     // Do rollback for each directory containing previous state\n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       File prevDir \u003d sd.getPreviousDir();\n       if (!prevDir.exists())\n         continue;\n \n       LOG.info(\"Rolling back storage directory \" + sd.getRoot()\n                + \".\\n   new LV \u003d \" + prevState.getStorage().getLayoutVersion()\n                + \"; new CTime \u003d \" + prevState.getStorage().getCTime());\n       File tmpDir \u003d sd.getRemovedTmp();\n       assert !tmpDir.exists() : \"removed.tmp directory must not exist.\";\n       // rename current to tmp\n       File curDir \u003d sd.getCurrentDir();\n       assert curDir.exists() : \"Current directory must exist.\";\n       NNStorage.rename(curDir, tmpDir);\n       // rename previous to current\n       NNStorage.rename(prevDir, curDir);\n \n       // delete tmp dir\n       NNStorage.deleteDir(tmpDir);\n       LOG.info(\"Rollback of \" + sd.getRoot()+ \" is complete.\");\n     }\n     isUpgradeFinalized \u003d true;\n     // check whether name-node can start in regular mode\n     storage.verifyDistributedUpgradeProgress(StartupOption.REGULAR);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void doRollback() throws IOException {\n    // Rollback is allowed only if there is \n    // a previous fs states in at least one of the storage directories.\n    // Directories that don\u0027t have previous state do not rollback\n    boolean canRollback \u003d false;\n    FSImage prevState \u003d new FSImage(conf, getFSNamesystem());\n    prevState.getStorage().layoutVersion \u003d HdfsConstants.LAYOUT_VERSION;\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      File prevDir \u003d sd.getPreviousDir();\n      if (!prevDir.exists()) {  // use current directory then\n        LOG.info(\"Storage directory \" + sd.getRoot()\n                 + \" does not contain previous fs state.\");\n        // read and verify consistency with other directories\n        storage.readProperties(sd);\n        continue;\n      }\n\n      // read and verify consistency of the prev dir\n      prevState.getStorage().readPreviousVersionProperties(sd);\n\n      if (prevState.getLayoutVersion() !\u003d HdfsConstants.LAYOUT_VERSION) {\n        throw new IOException(\n          \"Cannot rollback to storage version \" +\n          prevState.getLayoutVersion() +\n          \" using this version of the NameNode, which uses storage version \" +\n          HdfsConstants.LAYOUT_VERSION + \". \" +\n          \"Please use the previous version of HDFS to perform the rollback.\");\n      }\n      canRollback \u003d true;\n    }\n    if (!canRollback)\n      throw new IOException(\"Cannot rollback. None of the storage \"\n                            + \"directories contain previous fs state.\");\n\n    // Now that we know all directories are going to be consistent\n    // Do rollback for each directory containing previous state\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      File prevDir \u003d sd.getPreviousDir();\n      if (!prevDir.exists())\n        continue;\n\n      LOG.info(\"Rolling back storage directory \" + sd.getRoot()\n               + \".\\n   new LV \u003d \" + prevState.getStorage().getLayoutVersion()\n               + \"; new CTime \u003d \" + prevState.getStorage().getCTime());\n      File tmpDir \u003d sd.getRemovedTmp();\n      assert !tmpDir.exists() : \"removed.tmp directory must not exist.\";\n      // rename current to tmp\n      File curDir \u003d sd.getCurrentDir();\n      assert curDir.exists() : \"Current directory must exist.\";\n      NNStorage.rename(curDir, tmpDir);\n      // rename previous to current\n      NNStorage.rename(prevDir, curDir);\n\n      // delete tmp dir\n      NNStorage.deleteDir(tmpDir);\n      LOG.info(\"Rollback of \" + sd.getRoot()+ \" is complete.\");\n    }\n    isUpgradeFinalized \u003d true;\n    // check whether name-node can start in regular mode\n    storage.verifyDistributedUpgradeProgress(StartupOption.REGULAR);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private void doRollback() throws IOException {\n    // Rollback is allowed only if there is \n    // a previous fs states in at least one of the storage directories.\n    // Directories that don\u0027t have previous state do not rollback\n    boolean canRollback \u003d false;\n    FSImage prevState \u003d new FSImage(conf, getFSNamesystem());\n    prevState.getStorage().layoutVersion \u003d FSConstants.LAYOUT_VERSION;\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      File prevDir \u003d sd.getPreviousDir();\n      if (!prevDir.exists()) {  // use current directory then\n        LOG.info(\"Storage directory \" + sd.getRoot()\n                 + \" does not contain previous fs state.\");\n        // read and verify consistency with other directories\n        storage.readProperties(sd);\n        continue;\n      }\n\n      // read and verify consistency of the prev dir\n      prevState.getStorage().readPreviousVersionProperties(sd);\n\n      if (prevState.getLayoutVersion() !\u003d FSConstants.LAYOUT_VERSION) {\n        throw new IOException(\n          \"Cannot rollback to storage version \" +\n          prevState.getLayoutVersion() +\n          \" using this version of the NameNode, which uses storage version \" +\n          FSConstants.LAYOUT_VERSION + \". \" +\n          \"Please use the previous version of HDFS to perform the rollback.\");\n      }\n      canRollback \u003d true;\n    }\n    if (!canRollback)\n      throw new IOException(\"Cannot rollback. None of the storage \"\n                            + \"directories contain previous fs state.\");\n\n    // Now that we know all directories are going to be consistent\n    // Do rollback for each directory containing previous state\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      File prevDir \u003d sd.getPreviousDir();\n      if (!prevDir.exists())\n        continue;\n\n      LOG.info(\"Rolling back storage directory \" + sd.getRoot()\n               + \".\\n   new LV \u003d \" + prevState.getStorage().getLayoutVersion()\n               + \"; new CTime \u003d \" + prevState.getStorage().getCTime());\n      File tmpDir \u003d sd.getRemovedTmp();\n      assert !tmpDir.exists() : \"removed.tmp directory must not exist.\";\n      // rename current to tmp\n      File curDir \u003d sd.getCurrentDir();\n      assert curDir.exists() : \"Current directory must exist.\";\n      NNStorage.rename(curDir, tmpDir);\n      // rename previous to current\n      NNStorage.rename(prevDir, curDir);\n\n      // delete tmp dir\n      NNStorage.deleteDir(tmpDir);\n      LOG.info(\"Rollback of \" + sd.getRoot()+ \" is complete.\");\n    }\n    isUpgradeFinalized \u003d true;\n    // check whether name-node can start in regular mode\n    storage.verifyDistributedUpgradeProgress(StartupOption.REGULAR);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java"
      }
    },
    "d86f3183d93714ba078416af4f609d26376eadb0": {
      "type": "Yfilerename",
      "commitMessage": "HDFS-2096. Mavenization of hadoop-hdfs. Contributed by Alejandro Abdelnur.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159702 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/08/11 10:36 AM",
      "commitName": "d86f3183d93714ba078416af4f609d26376eadb0",
      "commitAuthor": "Thomas White",
      "commitDateOld": "19/08/11 10:26 AM",
      "commitNameOld": "6ee5a73e0e91a2ef27753a32c576835e951d8119",
      "commitAuthorOld": "Thomas White",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private void doRollback() throws IOException {\n    // Rollback is allowed only if there is \n    // a previous fs states in at least one of the storage directories.\n    // Directories that don\u0027t have previous state do not rollback\n    boolean canRollback \u003d false;\n    FSImage prevState \u003d new FSImage(conf, getFSNamesystem());\n    prevState.getStorage().layoutVersion \u003d FSConstants.LAYOUT_VERSION;\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      File prevDir \u003d sd.getPreviousDir();\n      if (!prevDir.exists()) {  // use current directory then\n        LOG.info(\"Storage directory \" + sd.getRoot()\n                 + \" does not contain previous fs state.\");\n        // read and verify consistency with other directories\n        storage.readProperties(sd);\n        continue;\n      }\n\n      // read and verify consistency of the prev dir\n      prevState.getStorage().readPreviousVersionProperties(sd);\n\n      if (prevState.getLayoutVersion() !\u003d FSConstants.LAYOUT_VERSION) {\n        throw new IOException(\n          \"Cannot rollback to storage version \" +\n          prevState.getLayoutVersion() +\n          \" using this version of the NameNode, which uses storage version \" +\n          FSConstants.LAYOUT_VERSION + \". \" +\n          \"Please use the previous version of HDFS to perform the rollback.\");\n      }\n      canRollback \u003d true;\n    }\n    if (!canRollback)\n      throw new IOException(\"Cannot rollback. None of the storage \"\n                            + \"directories contain previous fs state.\");\n\n    // Now that we know all directories are going to be consistent\n    // Do rollback for each directory containing previous state\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      File prevDir \u003d sd.getPreviousDir();\n      if (!prevDir.exists())\n        continue;\n\n      LOG.info(\"Rolling back storage directory \" + sd.getRoot()\n               + \".\\n   new LV \u003d \" + prevState.getStorage().getLayoutVersion()\n               + \"; new CTime \u003d \" + prevState.getStorage().getCTime());\n      File tmpDir \u003d sd.getRemovedTmp();\n      assert !tmpDir.exists() : \"removed.tmp directory must not exist.\";\n      // rename current to tmp\n      File curDir \u003d sd.getCurrentDir();\n      assert curDir.exists() : \"Current directory must exist.\";\n      NNStorage.rename(curDir, tmpDir);\n      // rename previous to current\n      NNStorage.rename(prevDir, curDir);\n\n      // delete tmp dir\n      NNStorage.deleteDir(tmpDir);\n      LOG.info(\"Rollback of \" + sd.getRoot()+ \" is complete.\");\n    }\n    isUpgradeFinalized \u003d true;\n    // check whether name-node can start in regular mode\n    storage.verifyDistributedUpgradeProgress(StartupOption.REGULAR);\n  }",
      "path": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {
        "oldPath": "hdfs/src/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
        "newPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java"
      }
    },
    "28e6a4e44a3e920dcaf858f9a74a6358226b3a63": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-1073. Redesign the NameNode\u0027s storage layout for image checkpoints and edit logs to introduce transaction IDs and be more robust. Contributed by Todd Lipcon and Ivan Kelly.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1152295 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/07/11 9:28 AM",
      "commitName": "28e6a4e44a3e920dcaf858f9a74a6358226b3a63",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "27/07/11 8:19 PM",
      "commitNameOld": "ffbe9e5972bf3eee9037e2602c1330e0dc744646",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 1.55,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,63 +1,63 @@\n   private void doRollback() throws IOException {\n     // Rollback is allowed only if there is \n     // a previous fs states in at least one of the storage directories.\n     // Directories that don\u0027t have previous state do not rollback\n     boolean canRollback \u003d false;\n-    FSImage prevState \u003d new FSImage(getFSNamesystem());\n+    FSImage prevState \u003d new FSImage(conf, getFSNamesystem());\n     prevState.getStorage().layoutVersion \u003d FSConstants.LAYOUT_VERSION;\n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       File prevDir \u003d sd.getPreviousDir();\n       if (!prevDir.exists()) {  // use current directory then\n         LOG.info(\"Storage directory \" + sd.getRoot()\n                  + \" does not contain previous fs state.\");\n         // read and verify consistency with other directories\n         storage.readProperties(sd);\n         continue;\n       }\n \n       // read and verify consistency of the prev dir\n       prevState.getStorage().readPreviousVersionProperties(sd);\n \n       if (prevState.getLayoutVersion() !\u003d FSConstants.LAYOUT_VERSION) {\n         throw new IOException(\n           \"Cannot rollback to storage version \" +\n           prevState.getLayoutVersion() +\n           \" using this version of the NameNode, which uses storage version \" +\n           FSConstants.LAYOUT_VERSION + \". \" +\n           \"Please use the previous version of HDFS to perform the rollback.\");\n       }\n       canRollback \u003d true;\n     }\n     if (!canRollback)\n       throw new IOException(\"Cannot rollback. None of the storage \"\n                             + \"directories contain previous fs state.\");\n \n     // Now that we know all directories are going to be consistent\n     // Do rollback for each directory containing previous state\n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       File prevDir \u003d sd.getPreviousDir();\n       if (!prevDir.exists())\n         continue;\n \n       LOG.info(\"Rolling back storage directory \" + sd.getRoot()\n                + \".\\n   new LV \u003d \" + prevState.getStorage().getLayoutVersion()\n                + \"; new CTime \u003d \" + prevState.getStorage().getCTime());\n       File tmpDir \u003d sd.getRemovedTmp();\n       assert !tmpDir.exists() : \"removed.tmp directory must not exist.\";\n       // rename current to tmp\n       File curDir \u003d sd.getCurrentDir();\n       assert curDir.exists() : \"Current directory must exist.\";\n       NNStorage.rename(curDir, tmpDir);\n       // rename previous to current\n       NNStorage.rename(prevDir, curDir);\n \n       // delete tmp dir\n       NNStorage.deleteDir(tmpDir);\n       LOG.info(\"Rollback of \" + sd.getRoot()+ \" is complete.\");\n     }\n     isUpgradeFinalized \u003d true;\n     // check whether name-node can start in regular mode\n     storage.verifyDistributedUpgradeProgress(StartupOption.REGULAR);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void doRollback() throws IOException {\n    // Rollback is allowed only if there is \n    // a previous fs states in at least one of the storage directories.\n    // Directories that don\u0027t have previous state do not rollback\n    boolean canRollback \u003d false;\n    FSImage prevState \u003d new FSImage(conf, getFSNamesystem());\n    prevState.getStorage().layoutVersion \u003d FSConstants.LAYOUT_VERSION;\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      File prevDir \u003d sd.getPreviousDir();\n      if (!prevDir.exists()) {  // use current directory then\n        LOG.info(\"Storage directory \" + sd.getRoot()\n                 + \" does not contain previous fs state.\");\n        // read and verify consistency with other directories\n        storage.readProperties(sd);\n        continue;\n      }\n\n      // read and verify consistency of the prev dir\n      prevState.getStorage().readPreviousVersionProperties(sd);\n\n      if (prevState.getLayoutVersion() !\u003d FSConstants.LAYOUT_VERSION) {\n        throw new IOException(\n          \"Cannot rollback to storage version \" +\n          prevState.getLayoutVersion() +\n          \" using this version of the NameNode, which uses storage version \" +\n          FSConstants.LAYOUT_VERSION + \". \" +\n          \"Please use the previous version of HDFS to perform the rollback.\");\n      }\n      canRollback \u003d true;\n    }\n    if (!canRollback)\n      throw new IOException(\"Cannot rollback. None of the storage \"\n                            + \"directories contain previous fs state.\");\n\n    // Now that we know all directories are going to be consistent\n    // Do rollback for each directory containing previous state\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      File prevDir \u003d sd.getPreviousDir();\n      if (!prevDir.exists())\n        continue;\n\n      LOG.info(\"Rolling back storage directory \" + sd.getRoot()\n               + \".\\n   new LV \u003d \" + prevState.getStorage().getLayoutVersion()\n               + \"; new CTime \u003d \" + prevState.getStorage().getCTime());\n      File tmpDir \u003d sd.getRemovedTmp();\n      assert !tmpDir.exists() : \"removed.tmp directory must not exist.\";\n      // rename current to tmp\n      File curDir \u003d sd.getCurrentDir();\n      assert curDir.exists() : \"Current directory must exist.\";\n      NNStorage.rename(curDir, tmpDir);\n      // rename previous to current\n      NNStorage.rename(prevDir, curDir);\n\n      // delete tmp dir\n      NNStorage.deleteDir(tmpDir);\n      LOG.info(\"Rollback of \" + sd.getRoot()+ \" is complete.\");\n    }\n    isUpgradeFinalized \u003d true;\n    // check whether name-node can start in regular mode\n    storage.verifyDistributedUpgradeProgress(StartupOption.REGULAR);\n  }",
      "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {}
    },
    "ffbe9e5972bf3eee9037e2602c1330e0dc744646": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2195. Refactor StorageDirectory to not be an non-static inner class. Contributed by Todd Lipcon\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1151707 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/07/11 8:19 PM",
      "commitName": "ffbe9e5972bf3eee9037e2602c1330e0dc744646",
      "commitAuthor": "Eli Collins",
      "commitDateOld": "27/07/11 4:28 PM",
      "commitNameOld": "6f1ef980ded061dd75d3368b0fc2fbbed14eea9f",
      "commitAuthorOld": "Konstantin Shvachko",
      "daysBetweenCommits": 0.16,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,63 +1,63 @@\n   private void doRollback() throws IOException {\n     // Rollback is allowed only if there is \n     // a previous fs states in at least one of the storage directories.\n     // Directories that don\u0027t have previous state do not rollback\n     boolean canRollback \u003d false;\n     FSImage prevState \u003d new FSImage(getFSNamesystem());\n     prevState.getStorage().layoutVersion \u003d FSConstants.LAYOUT_VERSION;\n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       File prevDir \u003d sd.getPreviousDir();\n       if (!prevDir.exists()) {  // use current directory then\n         LOG.info(\"Storage directory \" + sd.getRoot()\n                  + \" does not contain previous fs state.\");\n-        sd.read(); // read and verify consistency with other directories\n+        // read and verify consistency with other directories\n+        storage.readProperties(sd);\n         continue;\n       }\n-      StorageDirectory sdPrev \n-        \u003d prevState.getStorage().new StorageDirectory(sd.getRoot());\n \n       // read and verify consistency of the prev dir\n-      sdPrev.read(sdPrev.getPreviousVersionFile());\n+      prevState.getStorage().readPreviousVersionProperties(sd);\n+\n       if (prevState.getLayoutVersion() !\u003d FSConstants.LAYOUT_VERSION) {\n         throw new IOException(\n           \"Cannot rollback to storage version \" +\n           prevState.getLayoutVersion() +\n           \" using this version of the NameNode, which uses storage version \" +\n           FSConstants.LAYOUT_VERSION + \". \" +\n           \"Please use the previous version of HDFS to perform the rollback.\");\n       }\n       canRollback \u003d true;\n     }\n     if (!canRollback)\n       throw new IOException(\"Cannot rollback. None of the storage \"\n                             + \"directories contain previous fs state.\");\n \n     // Now that we know all directories are going to be consistent\n     // Do rollback for each directory containing previous state\n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       File prevDir \u003d sd.getPreviousDir();\n       if (!prevDir.exists())\n         continue;\n \n       LOG.info(\"Rolling back storage directory \" + sd.getRoot()\n                + \".\\n   new LV \u003d \" + prevState.getStorage().getLayoutVersion()\n                + \"; new CTime \u003d \" + prevState.getStorage().getCTime());\n       File tmpDir \u003d sd.getRemovedTmp();\n       assert !tmpDir.exists() : \"removed.tmp directory must not exist.\";\n       // rename current to tmp\n       File curDir \u003d sd.getCurrentDir();\n       assert curDir.exists() : \"Current directory must exist.\";\n       NNStorage.rename(curDir, tmpDir);\n       // rename previous to current\n       NNStorage.rename(prevDir, curDir);\n \n       // delete tmp dir\n       NNStorage.deleteDir(tmpDir);\n       LOG.info(\"Rollback of \" + sd.getRoot()+ \" is complete.\");\n     }\n     isUpgradeFinalized \u003d true;\n     // check whether name-node can start in regular mode\n     storage.verifyDistributedUpgradeProgress(StartupOption.REGULAR);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void doRollback() throws IOException {\n    // Rollback is allowed only if there is \n    // a previous fs states in at least one of the storage directories.\n    // Directories that don\u0027t have previous state do not rollback\n    boolean canRollback \u003d false;\n    FSImage prevState \u003d new FSImage(getFSNamesystem());\n    prevState.getStorage().layoutVersion \u003d FSConstants.LAYOUT_VERSION;\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      File prevDir \u003d sd.getPreviousDir();\n      if (!prevDir.exists()) {  // use current directory then\n        LOG.info(\"Storage directory \" + sd.getRoot()\n                 + \" does not contain previous fs state.\");\n        // read and verify consistency with other directories\n        storage.readProperties(sd);\n        continue;\n      }\n\n      // read and verify consistency of the prev dir\n      prevState.getStorage().readPreviousVersionProperties(sd);\n\n      if (prevState.getLayoutVersion() !\u003d FSConstants.LAYOUT_VERSION) {\n        throw new IOException(\n          \"Cannot rollback to storage version \" +\n          prevState.getLayoutVersion() +\n          \" using this version of the NameNode, which uses storage version \" +\n          FSConstants.LAYOUT_VERSION + \". \" +\n          \"Please use the previous version of HDFS to perform the rollback.\");\n      }\n      canRollback \u003d true;\n    }\n    if (!canRollback)\n      throw new IOException(\"Cannot rollback. None of the storage \"\n                            + \"directories contain previous fs state.\");\n\n    // Now that we know all directories are going to be consistent\n    // Do rollback for each directory containing previous state\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      File prevDir \u003d sd.getPreviousDir();\n      if (!prevDir.exists())\n        continue;\n\n      LOG.info(\"Rolling back storage directory \" + sd.getRoot()\n               + \".\\n   new LV \u003d \" + prevState.getStorage().getLayoutVersion()\n               + \"; new CTime \u003d \" + prevState.getStorage().getCTime());\n      File tmpDir \u003d sd.getRemovedTmp();\n      assert !tmpDir.exists() : \"removed.tmp directory must not exist.\";\n      // rename current to tmp\n      File curDir \u003d sd.getCurrentDir();\n      assert curDir.exists() : \"Current directory must exist.\";\n      NNStorage.rename(curDir, tmpDir);\n      // rename previous to current\n      NNStorage.rename(prevDir, curDir);\n\n      // delete tmp dir\n      NNStorage.deleteDir(tmpDir);\n      LOG.info(\"Rollback of \" + sd.getRoot()+ \" is complete.\");\n    }\n    isUpgradeFinalized \u003d true;\n    // check whether name-node can start in regular mode\n    storage.verifyDistributedUpgradeProgress(StartupOption.REGULAR);\n  }",
      "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {}
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "diff": "@@ -0,0 +1,63 @@\n+  private void doRollback() throws IOException {\n+    // Rollback is allowed only if there is \n+    // a previous fs states in at least one of the storage directories.\n+    // Directories that don\u0027t have previous state do not rollback\n+    boolean canRollback \u003d false;\n+    FSImage prevState \u003d new FSImage(getFSNamesystem());\n+    prevState.getStorage().layoutVersion \u003d FSConstants.LAYOUT_VERSION;\n+    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n+      StorageDirectory sd \u003d it.next();\n+      File prevDir \u003d sd.getPreviousDir();\n+      if (!prevDir.exists()) {  // use current directory then\n+        LOG.info(\"Storage directory \" + sd.getRoot()\n+                 + \" does not contain previous fs state.\");\n+        sd.read(); // read and verify consistency with other directories\n+        continue;\n+      }\n+      StorageDirectory sdPrev \n+        \u003d prevState.getStorage().new StorageDirectory(sd.getRoot());\n+\n+      // read and verify consistency of the prev dir\n+      sdPrev.read(sdPrev.getPreviousVersionFile());\n+      if (prevState.getLayoutVersion() !\u003d FSConstants.LAYOUT_VERSION) {\n+        throw new IOException(\n+          \"Cannot rollback to storage version \" +\n+          prevState.getLayoutVersion() +\n+          \" using this version of the NameNode, which uses storage version \" +\n+          FSConstants.LAYOUT_VERSION + \". \" +\n+          \"Please use the previous version of HDFS to perform the rollback.\");\n+      }\n+      canRollback \u003d true;\n+    }\n+    if (!canRollback)\n+      throw new IOException(\"Cannot rollback. None of the storage \"\n+                            + \"directories contain previous fs state.\");\n+\n+    // Now that we know all directories are going to be consistent\n+    // Do rollback for each directory containing previous state\n+    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n+      StorageDirectory sd \u003d it.next();\n+      File prevDir \u003d sd.getPreviousDir();\n+      if (!prevDir.exists())\n+        continue;\n+\n+      LOG.info(\"Rolling back storage directory \" + sd.getRoot()\n+               + \".\\n   new LV \u003d \" + prevState.getStorage().getLayoutVersion()\n+               + \"; new CTime \u003d \" + prevState.getStorage().getCTime());\n+      File tmpDir \u003d sd.getRemovedTmp();\n+      assert !tmpDir.exists() : \"removed.tmp directory must not exist.\";\n+      // rename current to tmp\n+      File curDir \u003d sd.getCurrentDir();\n+      assert curDir.exists() : \"Current directory must exist.\";\n+      NNStorage.rename(curDir, tmpDir);\n+      // rename previous to current\n+      NNStorage.rename(prevDir, curDir);\n+\n+      // delete tmp dir\n+      NNStorage.deleteDir(tmpDir);\n+      LOG.info(\"Rollback of \" + sd.getRoot()+ \" is complete.\");\n+    }\n+    isUpgradeFinalized \u003d true;\n+    // check whether name-node can start in regular mode\n+    storage.verifyDistributedUpgradeProgress(StartupOption.REGULAR);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void doRollback() throws IOException {\n    // Rollback is allowed only if there is \n    // a previous fs states in at least one of the storage directories.\n    // Directories that don\u0027t have previous state do not rollback\n    boolean canRollback \u003d false;\n    FSImage prevState \u003d new FSImage(getFSNamesystem());\n    prevState.getStorage().layoutVersion \u003d FSConstants.LAYOUT_VERSION;\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      File prevDir \u003d sd.getPreviousDir();\n      if (!prevDir.exists()) {  // use current directory then\n        LOG.info(\"Storage directory \" + sd.getRoot()\n                 + \" does not contain previous fs state.\");\n        sd.read(); // read and verify consistency with other directories\n        continue;\n      }\n      StorageDirectory sdPrev \n        \u003d prevState.getStorage().new StorageDirectory(sd.getRoot());\n\n      // read and verify consistency of the prev dir\n      sdPrev.read(sdPrev.getPreviousVersionFile());\n      if (prevState.getLayoutVersion() !\u003d FSConstants.LAYOUT_VERSION) {\n        throw new IOException(\n          \"Cannot rollback to storage version \" +\n          prevState.getLayoutVersion() +\n          \" using this version of the NameNode, which uses storage version \" +\n          FSConstants.LAYOUT_VERSION + \". \" +\n          \"Please use the previous version of HDFS to perform the rollback.\");\n      }\n      canRollback \u003d true;\n    }\n    if (!canRollback)\n      throw new IOException(\"Cannot rollback. None of the storage \"\n                            + \"directories contain previous fs state.\");\n\n    // Now that we know all directories are going to be consistent\n    // Do rollback for each directory containing previous state\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      File prevDir \u003d sd.getPreviousDir();\n      if (!prevDir.exists())\n        continue;\n\n      LOG.info(\"Rolling back storage directory \" + sd.getRoot()\n               + \".\\n   new LV \u003d \" + prevState.getStorage().getLayoutVersion()\n               + \"; new CTime \u003d \" + prevState.getStorage().getCTime());\n      File tmpDir \u003d sd.getRemovedTmp();\n      assert !tmpDir.exists() : \"removed.tmp directory must not exist.\";\n      // rename current to tmp\n      File curDir \u003d sd.getCurrentDir();\n      assert curDir.exists() : \"Current directory must exist.\";\n      NNStorage.rename(curDir, tmpDir);\n      // rename previous to current\n      NNStorage.rename(prevDir, curDir);\n\n      // delete tmp dir\n      NNStorage.deleteDir(tmpDir);\n      LOG.info(\"Rollback of \" + sd.getRoot()+ \" is complete.\");\n    }\n    isUpgradeFinalized \u003d true;\n    // check whether name-node can start in regular mode\n    storage.verifyDistributedUpgradeProgress(StartupOption.REGULAR);\n  }",
      "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java"
    }
  }
}