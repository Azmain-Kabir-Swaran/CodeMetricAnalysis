{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "AMLauncher.java",
  "functionName": "setupTokens",
  "functionId": "setupTokens___container-ContainerLaunchContext__containerID-ContainerId",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/amlauncher/AMLauncher.java",
  "functionStartLine": 213,
  "functionEndLine": 272,
  "numCommitsSeen": 85,
  "timeTaken": 12022,
  "changeHistory": [
    "c2288ac45b748b4119442c46147ccc324926c340",
    "a3cf40e532d17b176663bb99248ed159aae6a9ed",
    "89e5c44f9e891a3579384c3fa3766937cd4970f1",
    "47f35a30bb4d99349593e9d6e1c9e76e71341c40",
    "d67c9bdb4db2b075484a779802ecf3296bad5cd4",
    "d6e3164d4a18271299c63377326ca56e8a980830",
    "f8204e241d9271497defd4d42646fb89c61cefe3",
    "eeb4acd955802e2a84ea94cecf2e2341b83d5efb",
    "817a6543465a3228cdb28a2eeb8e4f96a2d0f9e6",
    "ae8f07d47b92f54be404b84f608948de4cde7987",
    "32bc200d54928d39acdc837c2c77b4c443fb46be",
    "5d1b453b8591d87ffb564857015c26c99fb7437c",
    "7d0c43d7cff6d250613a04fea9449f139988e901",
    "1a119f87b4f0a78d56e1bb998b1cbc081484fbd1",
    "74231f027607ff1a6fe7d72fad28108826963cf3",
    "be256a181985737ade3f8231b472a2438659c3b2",
    "27e8c86999bc6a972a99216060b11ef35b7de858",
    "e4c55e17fea55e2fcbef182bb2b0c4b22686f38c",
    "07573640147bb4cf3568078acae7b245e9299cf7",
    "6a2f2551fd13f6d3c932cc9b592e2a23b616a7f5",
    "f79ae9141422dc4b2211ad3ca60bb79c3d266cb3",
    "c074cfd6f0ec695d85a73cddba1404c9db79342e",
    "e1fdf62123625e4ba399af02f8aad500637d29d1",
    "aa60da6c2ec049cc70897afee6c368cb70493773",
    "32d511065a2612d37591f09e53eed8ec1488587d",
    "fe7711df98b9dd16259f6534e8461a29f24caadc",
    "670fa24b48acb407c22fbfdde87ae3123dcbf449",
    "db8ac0ec3cbec046f9cf32644c16fd2a51dd85a2",
    "8aabd3d4e67cad8dc7e46f5339981135badc7421",
    "13e4562924a6cb3d16c262e0f595b2ffbf9e0546",
    "b549c107825581b15fd14494099a943ff3213c6f",
    "88b82a0f6687ce103817fbb460fd30d870f717a0",
    "fafe8cd28e726566509c679e19d7da622f29f90d",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517"
  ],
  "changeHistoryShort": {
    "c2288ac45b748b4119442c46147ccc324926c340": "Ybodychange",
    "a3cf40e532d17b176663bb99248ed159aae6a9ed": "Ybodychange",
    "89e5c44f9e891a3579384c3fa3766937cd4970f1": "Ybodychange",
    "47f35a30bb4d99349593e9d6e1c9e76e71341c40": "Ybodychange",
    "d67c9bdb4db2b075484a779802ecf3296bad5cd4": "Ybodychange",
    "d6e3164d4a18271299c63377326ca56e8a980830": "Ybodychange",
    "f8204e241d9271497defd4d42646fb89c61cefe3": "Ymultichange(Ymodifierchange,Ybodychange)",
    "eeb4acd955802e2a84ea94cecf2e2341b83d5efb": "Ybodychange",
    "817a6543465a3228cdb28a2eeb8e4f96a2d0f9e6": "Ybodychange",
    "ae8f07d47b92f54be404b84f608948de4cde7987": "Ybodychange",
    "32bc200d54928d39acdc837c2c77b4c443fb46be": "Ybodychange",
    "5d1b453b8591d87ffb564857015c26c99fb7437c": "Ymultichange(Yrename,Ybodychange)",
    "7d0c43d7cff6d250613a04fea9449f139988e901": "Ybodychange",
    "1a119f87b4f0a78d56e1bb998b1cbc081484fbd1": "Ybodychange",
    "74231f027607ff1a6fe7d72fad28108826963cf3": "Ybodychange",
    "be256a181985737ade3f8231b472a2438659c3b2": "Ybodychange",
    "27e8c86999bc6a972a99216060b11ef35b7de858": "Ybodychange",
    "e4c55e17fea55e2fcbef182bb2b0c4b22686f38c": "Ymultichange(Yparameterchange,Ybodychange)",
    "07573640147bb4cf3568078acae7b245e9299cf7": "Ybodychange",
    "6a2f2551fd13f6d3c932cc9b592e2a23b616a7f5": "Ybodychange",
    "f79ae9141422dc4b2211ad3ca60bb79c3d266cb3": "Ybodychange",
    "c074cfd6f0ec695d85a73cddba1404c9db79342e": "Ybodychange",
    "e1fdf62123625e4ba399af02f8aad500637d29d1": "Yfilerename",
    "aa60da6c2ec049cc70897afee6c368cb70493773": "Ybodychange",
    "32d511065a2612d37591f09e53eed8ec1488587d": "Ybodychange",
    "fe7711df98b9dd16259f6534e8461a29f24caadc": "Ybodychange",
    "670fa24b48acb407c22fbfdde87ae3123dcbf449": "Ybodychange",
    "db8ac0ec3cbec046f9cf32644c16fd2a51dd85a2": "Ybodychange",
    "8aabd3d4e67cad8dc7e46f5339981135badc7421": "Ybodychange",
    "13e4562924a6cb3d16c262e0f595b2ffbf9e0546": "Ybodychange",
    "b549c107825581b15fd14494099a943ff3213c6f": "Ybodychange",
    "88b82a0f6687ce103817fbb460fd30d870f717a0": "Ymultichange(Yrename,Yparameterchange,Yreturntypechange,Ybodychange)",
    "fafe8cd28e726566509c679e19d7da622f29f90d": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": "Yintroduced"
  },
  "changeHistoryDetails": {
    "c2288ac45b748b4119442c46147ccc324926c340": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8448. AM HTTPS Support for AM communication with RMWeb proxy. (Contributed by Robert Kanter)\n",
      "commitDate": "16/10/18 1:36 PM",
      "commitName": "c2288ac45b748b4119442c46147ccc324926c340",
      "commitAuthor": "Haibo Chen",
      "commitDateOld": "20/04/18 11:22 AM",
      "commitNameOld": "766544c0b008da9e78bcea6285b2c478653df75a",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 179.09,
      "commitsBetweenForRepo": 1945,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,60 @@\n   protected void setupTokens(\n       ContainerLaunchContext container, ContainerId containerID)\n       throws IOException {\n     Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n     environment.put(ApplicationConstants.APPLICATION_WEB_PROXY_BASE_ENV,\n         application.getWebProxyBase());\n     // Set AppSubmitTime to be consumable by the AM.\n     ApplicationId applicationId \u003d\n         application.getAppAttemptId().getApplicationId();\n     environment.put(\n         ApplicationConstants.APP_SUBMIT_TIME_ENV,\n         String.valueOf(rmContext.getRMApps()\n             .get(applicationId)\n             .getSubmitTime()));\n \n     Credentials credentials \u003d new Credentials();\n     DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n     ByteBuffer tokens \u003d container.getTokens();\n     if (tokens !\u003d null) {\n       // TODO: Don\u0027t do this kind of checks everywhere.\n       dibb.reset(tokens);\n       credentials.readTokenStorageStream(dibb);\n       tokens.rewind();\n     }\n \n     // Add AMRMToken\n     Token\u003cAMRMTokenIdentifier\u003e amrmToken \u003d createAndSetAMRMToken();\n     if (amrmToken !\u003d null) {\n       credentials.addToken(amrmToken.getService(), amrmToken);\n     }\n+\n+    // Setup Keystore and Truststore\n+    String httpsPolicy \u003d conf.get(YarnConfiguration.RM_APPLICATION_HTTPS_POLICY,\n+        YarnConfiguration.DEFAULT_RM_APPLICATION_HTTPS_POLICY);\n+    if (httpsPolicy.equals(\"LENIENT\") || httpsPolicy.equals(\"STRICT\")) {\n+      ProxyCA proxyCA \u003d rmContext.getProxyCAManager().getProxyCA();\n+      try {\n+        String kPass \u003d proxyCA.generateKeyStorePassword();\n+        byte[] keyStore \u003d proxyCA.createChildKeyStore(applicationId, kPass);\n+        credentials.addSecretKey(\n+            AMSecretKeys.YARN_APPLICATION_AM_KEYSTORE, keyStore);\n+        credentials.addSecretKey(\n+            AMSecretKeys.YARN_APPLICATION_AM_KEYSTORE_PASSWORD,\n+            kPass.getBytes(StandardCharsets.UTF_8));\n+        String tPass \u003d proxyCA.generateKeyStorePassword();\n+        byte[] trustStore \u003d proxyCA.getChildTrustStore(tPass);\n+        credentials.addSecretKey(\n+            AMSecretKeys.YARN_APPLICATION_AM_TRUSTSTORE, trustStore);\n+        credentials.addSecretKey(\n+            AMSecretKeys.YARN_APPLICATION_AM_TRUSTSTORE_PASSWORD,\n+            tPass.getBytes(StandardCharsets.UTF_8));\n+      } catch (Exception e) {\n+        throw new IOException(e);\n+      }\n+    }\n+\n     DataOutputBuffer dob \u003d new DataOutputBuffer();\n     credentials.writeTokenStorageToStream(dob);\n     container.setTokens(ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void setupTokens(\n      ContainerLaunchContext container, ContainerId containerID)\n      throws IOException {\n    Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n    environment.put(ApplicationConstants.APPLICATION_WEB_PROXY_BASE_ENV,\n        application.getWebProxyBase());\n    // Set AppSubmitTime to be consumable by the AM.\n    ApplicationId applicationId \u003d\n        application.getAppAttemptId().getApplicationId();\n    environment.put(\n        ApplicationConstants.APP_SUBMIT_TIME_ENV,\n        String.valueOf(rmContext.getRMApps()\n            .get(applicationId)\n            .getSubmitTime()));\n\n    Credentials credentials \u003d new Credentials();\n    DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n    ByteBuffer tokens \u003d container.getTokens();\n    if (tokens !\u003d null) {\n      // TODO: Don\u0027t do this kind of checks everywhere.\n      dibb.reset(tokens);\n      credentials.readTokenStorageStream(dibb);\n      tokens.rewind();\n    }\n\n    // Add AMRMToken\n    Token\u003cAMRMTokenIdentifier\u003e amrmToken \u003d createAndSetAMRMToken();\n    if (amrmToken !\u003d null) {\n      credentials.addToken(amrmToken.getService(), amrmToken);\n    }\n\n    // Setup Keystore and Truststore\n    String httpsPolicy \u003d conf.get(YarnConfiguration.RM_APPLICATION_HTTPS_POLICY,\n        YarnConfiguration.DEFAULT_RM_APPLICATION_HTTPS_POLICY);\n    if (httpsPolicy.equals(\"LENIENT\") || httpsPolicy.equals(\"STRICT\")) {\n      ProxyCA proxyCA \u003d rmContext.getProxyCAManager().getProxyCA();\n      try {\n        String kPass \u003d proxyCA.generateKeyStorePassword();\n        byte[] keyStore \u003d proxyCA.createChildKeyStore(applicationId, kPass);\n        credentials.addSecretKey(\n            AMSecretKeys.YARN_APPLICATION_AM_KEYSTORE, keyStore);\n        credentials.addSecretKey(\n            AMSecretKeys.YARN_APPLICATION_AM_KEYSTORE_PASSWORD,\n            kPass.getBytes(StandardCharsets.UTF_8));\n        String tPass \u003d proxyCA.generateKeyStorePassword();\n        byte[] trustStore \u003d proxyCA.getChildTrustStore(tPass);\n        credentials.addSecretKey(\n            AMSecretKeys.YARN_APPLICATION_AM_TRUSTSTORE, trustStore);\n        credentials.addSecretKey(\n            AMSecretKeys.YARN_APPLICATION_AM_TRUSTSTORE_PASSWORD,\n            tPass.getBytes(StandardCharsets.UTF_8));\n      } catch (Exception e) {\n        throw new IOException(e);\n      }\n    }\n\n    DataOutputBuffer dob \u003d new DataOutputBuffer();\n    credentials.writeTokenStorageToStream(dob);\n    container.setTokens(ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/amlauncher/AMLauncher.java",
      "extendedDetails": {}
    },
    "a3cf40e532d17b176663bb99248ed159aae6a9ed": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3461. Consolidate flow name/version/run defaults. (Sangjin Lee via Varun Saxena)\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "a3cf40e532d17b176663bb99248ed159aae6a9ed",
      "commitAuthor": "Varun Saxena",
      "commitDateOld": "10/07/16 8:45 AM",
      "commitNameOld": "89e5c44f9e891a3579384c3fa3766937cd4970f1",
      "commitAuthorOld": "Li Lu",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 22,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,43 +1,34 @@\n   protected void setupTokens(\n       ContainerLaunchContext container, ContainerId containerID)\n       throws IOException {\n     Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n     environment.put(ApplicationConstants.APPLICATION_WEB_PROXY_BASE_ENV,\n         application.getWebProxyBase());\n     // Set AppSubmitTime to be consumable by the AM.\n     ApplicationId applicationId \u003d\n         application.getAppAttemptId().getApplicationId();\n     environment.put(\n         ApplicationConstants.APP_SUBMIT_TIME_ENV,\n         String.valueOf(rmContext.getRMApps()\n             .get(applicationId)\n             .getSubmitTime()));\n \n-    if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n-      // Set flow context info\n-      for (String tag :\n-          rmContext.getRMApps().get(applicationId).getApplicationTags()) {\n-        setFlowTags(environment, TimelineUtils.FLOW_NAME_TAG_PREFIX, tag);\n-        setFlowTags(environment, TimelineUtils.FLOW_VERSION_TAG_PREFIX, tag);\n-        setFlowTags(environment, TimelineUtils.FLOW_RUN_ID_TAG_PREFIX, tag);\n-      }\n-    }\n     Credentials credentials \u003d new Credentials();\n     DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n     ByteBuffer tokens \u003d container.getTokens();\n     if (tokens !\u003d null) {\n       // TODO: Don\u0027t do this kind of checks everywhere.\n       dibb.reset(tokens);\n       credentials.readTokenStorageStream(dibb);\n       tokens.rewind();\n     }\n \n     // Add AMRMToken\n     Token\u003cAMRMTokenIdentifier\u003e amrmToken \u003d createAndSetAMRMToken();\n     if (amrmToken !\u003d null) {\n       credentials.addToken(amrmToken.getService(), amrmToken);\n     }\n     DataOutputBuffer dob \u003d new DataOutputBuffer();\n     credentials.writeTokenStorageToStream(dob);\n     container.setTokens(ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void setupTokens(\n      ContainerLaunchContext container, ContainerId containerID)\n      throws IOException {\n    Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n    environment.put(ApplicationConstants.APPLICATION_WEB_PROXY_BASE_ENV,\n        application.getWebProxyBase());\n    // Set AppSubmitTime to be consumable by the AM.\n    ApplicationId applicationId \u003d\n        application.getAppAttemptId().getApplicationId();\n    environment.put(\n        ApplicationConstants.APP_SUBMIT_TIME_ENV,\n        String.valueOf(rmContext.getRMApps()\n            .get(applicationId)\n            .getSubmitTime()));\n\n    Credentials credentials \u003d new Credentials();\n    DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n    ByteBuffer tokens \u003d container.getTokens();\n    if (tokens !\u003d null) {\n      // TODO: Don\u0027t do this kind of checks everywhere.\n      dibb.reset(tokens);\n      credentials.readTokenStorageStream(dibb);\n      tokens.rewind();\n    }\n\n    // Add AMRMToken\n    Token\u003cAMRMTokenIdentifier\u003e amrmToken \u003d createAndSetAMRMToken();\n    if (amrmToken !\u003d null) {\n      credentials.addToken(amrmToken.getService(), amrmToken);\n    }\n    DataOutputBuffer dob \u003d new DataOutputBuffer();\n    credentials.writeTokenStorageToStream(dob);\n    container.setTokens(ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/amlauncher/AMLauncher.java",
      "extendedDetails": {}
    },
    "89e5c44f9e891a3579384c3fa3766937cd4970f1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4356. Ensure the timeline service v.2 is disabled cleanly and has no\nimpact when it\u0027s turned off. Contributed by Sangjin Lee.\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "89e5c44f9e891a3579384c3fa3766937cd4970f1",
      "commitAuthor": "Li Lu",
      "commitDateOld": "10/07/16 8:45 AM",
      "commitNameOld": "47f35a30bb4d99349593e9d6e1c9e76e71341c40",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 51,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,43 @@\n   protected void setupTokens(\n       ContainerLaunchContext container, ContainerId containerID)\n       throws IOException {\n     Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n     environment.put(ApplicationConstants.APPLICATION_WEB_PROXY_BASE_ENV,\n         application.getWebProxyBase());\n     // Set AppSubmitTime to be consumable by the AM.\n     ApplicationId applicationId \u003d\n         application.getAppAttemptId().getApplicationId();\n     environment.put(\n         ApplicationConstants.APP_SUBMIT_TIME_ENV,\n         String.valueOf(rmContext.getRMApps()\n             .get(applicationId)\n             .getSubmitTime()));\n \n-    // Set flow context info\n-    for (String tag :\n-        rmContext.getRMApps().get(applicationId).getApplicationTags()) {\n-      setFlowTags(environment, TimelineUtils.FLOW_NAME_TAG_PREFIX, tag);\n-      setFlowTags(environment, TimelineUtils.FLOW_VERSION_TAG_PREFIX, tag);\n-      setFlowTags(environment, TimelineUtils.FLOW_RUN_ID_TAG_PREFIX, tag);\n+    if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n+      // Set flow context info\n+      for (String tag :\n+          rmContext.getRMApps().get(applicationId).getApplicationTags()) {\n+        setFlowTags(environment, TimelineUtils.FLOW_NAME_TAG_PREFIX, tag);\n+        setFlowTags(environment, TimelineUtils.FLOW_VERSION_TAG_PREFIX, tag);\n+        setFlowTags(environment, TimelineUtils.FLOW_RUN_ID_TAG_PREFIX, tag);\n+      }\n     }\n     Credentials credentials \u003d new Credentials();\n     DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n     ByteBuffer tokens \u003d container.getTokens();\n     if (tokens !\u003d null) {\n       // TODO: Don\u0027t do this kind of checks everywhere.\n       dibb.reset(tokens);\n       credentials.readTokenStorageStream(dibb);\n       tokens.rewind();\n     }\n \n     // Add AMRMToken\n     Token\u003cAMRMTokenIdentifier\u003e amrmToken \u003d createAndSetAMRMToken();\n     if (amrmToken !\u003d null) {\n       credentials.addToken(amrmToken.getService(), amrmToken);\n     }\n     DataOutputBuffer dob \u003d new DataOutputBuffer();\n     credentials.writeTokenStorageToStream(dob);\n     container.setTokens(ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void setupTokens(\n      ContainerLaunchContext container, ContainerId containerID)\n      throws IOException {\n    Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n    environment.put(ApplicationConstants.APPLICATION_WEB_PROXY_BASE_ENV,\n        application.getWebProxyBase());\n    // Set AppSubmitTime to be consumable by the AM.\n    ApplicationId applicationId \u003d\n        application.getAppAttemptId().getApplicationId();\n    environment.put(\n        ApplicationConstants.APP_SUBMIT_TIME_ENV,\n        String.valueOf(rmContext.getRMApps()\n            .get(applicationId)\n            .getSubmitTime()));\n\n    if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n      // Set flow context info\n      for (String tag :\n          rmContext.getRMApps().get(applicationId).getApplicationTags()) {\n        setFlowTags(environment, TimelineUtils.FLOW_NAME_TAG_PREFIX, tag);\n        setFlowTags(environment, TimelineUtils.FLOW_VERSION_TAG_PREFIX, tag);\n        setFlowTags(environment, TimelineUtils.FLOW_RUN_ID_TAG_PREFIX, tag);\n      }\n    }\n    Credentials credentials \u003d new Credentials();\n    DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n    ByteBuffer tokens \u003d container.getTokens();\n    if (tokens !\u003d null) {\n      // TODO: Don\u0027t do this kind of checks everywhere.\n      dibb.reset(tokens);\n      credentials.readTokenStorageStream(dibb);\n      tokens.rewind();\n    }\n\n    // Add AMRMToken\n    Token\u003cAMRMTokenIdentifier\u003e amrmToken \u003d createAndSetAMRMToken();\n    if (amrmToken !\u003d null) {\n      credentials.addToken(amrmToken.getService(), amrmToken);\n    }\n    DataOutputBuffer dob \u003d new DataOutputBuffer();\n    credentials.writeTokenStorageToStream(dob);\n    container.setTokens(ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/amlauncher/AMLauncher.java",
      "extendedDetails": {}
    },
    "47f35a30bb4d99349593e9d6e1c9e76e71341c40": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3391. Clearly define flow ID/ flow run / flow version in API and storage. Contributed by Zhijie Shen\n\n(cherry picked from commit 68c6232f8423e55b4d152ef3d1d66aeb2d6a555e)\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "47f35a30bb4d99349593e9d6e1c9e76e71341c40",
      "commitAuthor": "Junping Du",
      "commitDateOld": "10/07/16 8:45 AM",
      "commitNameOld": "d67c9bdb4db2b075484a779802ecf3296bad5cd4",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,41 @@\n   protected void setupTokens(\n       ContainerLaunchContext container, ContainerId containerID)\n       throws IOException {\n     Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n     environment.put(ApplicationConstants.APPLICATION_WEB_PROXY_BASE_ENV,\n         application.getWebProxyBase());\n     // Set AppSubmitTime to be consumable by the AM.\n     ApplicationId applicationId \u003d\n         application.getAppAttemptId().getApplicationId();\n     environment.put(\n         ApplicationConstants.APP_SUBMIT_TIME_ENV,\n         String.valueOf(rmContext.getRMApps()\n             .get(applicationId)\n             .getSubmitTime()));\n \n     // Set flow context info\n     for (String tag :\n         rmContext.getRMApps().get(applicationId).getApplicationTags()) {\n-      if (tag.startsWith(TimelineUtils.FLOW_ID_TAG_PREFIX  + \":\") ||\n-          tag.startsWith(TimelineUtils.FLOW_ID_TAG_PREFIX.toLowerCase() + \":\")) {\n-        String value \u003d tag.substring(\n-            TimelineUtils.FLOW_ID_TAG_PREFIX.length() + 1);\n-        if (!value.isEmpty()) {\n-          environment.put(TimelineUtils.FLOW_ID_TAG_PREFIX, value);\n-        }\n-      }\n-      if (tag.startsWith(TimelineUtils.FLOW_RUN_ID_TAG_PREFIX  + \":\") ||\n-          tag.startsWith(TimelineUtils.FLOW_RUN_ID_TAG_PREFIX.toLowerCase() + \":\")) {\n-        String value \u003d tag.substring(\n-            TimelineUtils.FLOW_RUN_ID_TAG_PREFIX.length() + 1);\n-        if (!value.isEmpty()) {\n-          environment.put(TimelineUtils.FLOW_RUN_ID_TAG_PREFIX, value);\n-        }\n-      }\n+      setFlowTags(environment, TimelineUtils.FLOW_NAME_TAG_PREFIX, tag);\n+      setFlowTags(environment, TimelineUtils.FLOW_VERSION_TAG_PREFIX, tag);\n+      setFlowTags(environment, TimelineUtils.FLOW_RUN_ID_TAG_PREFIX, tag);\n     }\n     Credentials credentials \u003d new Credentials();\n     DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n     ByteBuffer tokens \u003d container.getTokens();\n     if (tokens !\u003d null) {\n       // TODO: Don\u0027t do this kind of checks everywhere.\n       dibb.reset(tokens);\n       credentials.readTokenStorageStream(dibb);\n       tokens.rewind();\n     }\n \n     // Add AMRMToken\n     Token\u003cAMRMTokenIdentifier\u003e amrmToken \u003d createAndSetAMRMToken();\n     if (amrmToken !\u003d null) {\n       credentials.addToken(amrmToken.getService(), amrmToken);\n     }\n     DataOutputBuffer dob \u003d new DataOutputBuffer();\n     credentials.writeTokenStorageToStream(dob);\n     container.setTokens(ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void setupTokens(\n      ContainerLaunchContext container, ContainerId containerID)\n      throws IOException {\n    Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n    environment.put(ApplicationConstants.APPLICATION_WEB_PROXY_BASE_ENV,\n        application.getWebProxyBase());\n    // Set AppSubmitTime to be consumable by the AM.\n    ApplicationId applicationId \u003d\n        application.getAppAttemptId().getApplicationId();\n    environment.put(\n        ApplicationConstants.APP_SUBMIT_TIME_ENV,\n        String.valueOf(rmContext.getRMApps()\n            .get(applicationId)\n            .getSubmitTime()));\n\n    // Set flow context info\n    for (String tag :\n        rmContext.getRMApps().get(applicationId).getApplicationTags()) {\n      setFlowTags(environment, TimelineUtils.FLOW_NAME_TAG_PREFIX, tag);\n      setFlowTags(environment, TimelineUtils.FLOW_VERSION_TAG_PREFIX, tag);\n      setFlowTags(environment, TimelineUtils.FLOW_RUN_ID_TAG_PREFIX, tag);\n    }\n    Credentials credentials \u003d new Credentials();\n    DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n    ByteBuffer tokens \u003d container.getTokens();\n    if (tokens !\u003d null) {\n      // TODO: Don\u0027t do this kind of checks everywhere.\n      dibb.reset(tokens);\n      credentials.readTokenStorageStream(dibb);\n      tokens.rewind();\n    }\n\n    // Add AMRMToken\n    Token\u003cAMRMTokenIdentifier\u003e amrmToken \u003d createAndSetAMRMToken();\n    if (amrmToken !\u003d null) {\n      credentials.addToken(amrmToken.getService(), amrmToken);\n    }\n    DataOutputBuffer dob \u003d new DataOutputBuffer();\n    credentials.writeTokenStorageToStream(dob);\n    container.setTokens(ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/amlauncher/AMLauncher.java",
      "extendedDetails": {}
    },
    "d67c9bdb4db2b075484a779802ecf3296bad5cd4": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3040. Make putEntities operation be aware of the app\u0027s context. Contributed by Zhijie Shen\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "d67c9bdb4db2b075484a779802ecf3296bad5cd4",
      "commitAuthor": "Junping Du",
      "commitDateOld": "12/05/16 2:47 AM",
      "commitNameOld": "b7ac85259c7d20c33bef9c9cb40b8aabcab70755",
      "commitAuthorOld": "Rohith Sharma K S",
      "daysBetweenCommits": 59.25,
      "commitsBetweenForRepo": 418,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,54 @@\n   protected void setupTokens(\n       ContainerLaunchContext container, ContainerId containerID)\n       throws IOException {\n     Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n     environment.put(ApplicationConstants.APPLICATION_WEB_PROXY_BASE_ENV,\n         application.getWebProxyBase());\n     // Set AppSubmitTime to be consumable by the AM.\n     ApplicationId applicationId \u003d\n         application.getAppAttemptId().getApplicationId();\n     environment.put(\n         ApplicationConstants.APP_SUBMIT_TIME_ENV,\n         String.valueOf(rmContext.getRMApps()\n             .get(applicationId)\n             .getSubmitTime()));\n \n+    // Set flow context info\n+    for (String tag :\n+        rmContext.getRMApps().get(applicationId).getApplicationTags()) {\n+      if (tag.startsWith(TimelineUtils.FLOW_ID_TAG_PREFIX  + \":\") ||\n+          tag.startsWith(TimelineUtils.FLOW_ID_TAG_PREFIX.toLowerCase() + \":\")) {\n+        String value \u003d tag.substring(\n+            TimelineUtils.FLOW_ID_TAG_PREFIX.length() + 1);\n+        if (!value.isEmpty()) {\n+          environment.put(TimelineUtils.FLOW_ID_TAG_PREFIX, value);\n+        }\n+      }\n+      if (tag.startsWith(TimelineUtils.FLOW_RUN_ID_TAG_PREFIX  + \":\") ||\n+          tag.startsWith(TimelineUtils.FLOW_RUN_ID_TAG_PREFIX.toLowerCase() + \":\")) {\n+        String value \u003d tag.substring(\n+            TimelineUtils.FLOW_RUN_ID_TAG_PREFIX.length() + 1);\n+        if (!value.isEmpty()) {\n+          environment.put(TimelineUtils.FLOW_RUN_ID_TAG_PREFIX, value);\n+        }\n+      }\n+    }\n     Credentials credentials \u003d new Credentials();\n     DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n     ByteBuffer tokens \u003d container.getTokens();\n     if (tokens !\u003d null) {\n       // TODO: Don\u0027t do this kind of checks everywhere.\n       dibb.reset(tokens);\n       credentials.readTokenStorageStream(dibb);\n       tokens.rewind();\n     }\n \n     // Add AMRMToken\n     Token\u003cAMRMTokenIdentifier\u003e amrmToken \u003d createAndSetAMRMToken();\n     if (amrmToken !\u003d null) {\n       credentials.addToken(amrmToken.getService(), amrmToken);\n     }\n     DataOutputBuffer dob \u003d new DataOutputBuffer();\n     credentials.writeTokenStorageToStream(dob);\n     container.setTokens(ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void setupTokens(\n      ContainerLaunchContext container, ContainerId containerID)\n      throws IOException {\n    Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n    environment.put(ApplicationConstants.APPLICATION_WEB_PROXY_BASE_ENV,\n        application.getWebProxyBase());\n    // Set AppSubmitTime to be consumable by the AM.\n    ApplicationId applicationId \u003d\n        application.getAppAttemptId().getApplicationId();\n    environment.put(\n        ApplicationConstants.APP_SUBMIT_TIME_ENV,\n        String.valueOf(rmContext.getRMApps()\n            .get(applicationId)\n            .getSubmitTime()));\n\n    // Set flow context info\n    for (String tag :\n        rmContext.getRMApps().get(applicationId).getApplicationTags()) {\n      if (tag.startsWith(TimelineUtils.FLOW_ID_TAG_PREFIX  + \":\") ||\n          tag.startsWith(TimelineUtils.FLOW_ID_TAG_PREFIX.toLowerCase() + \":\")) {\n        String value \u003d tag.substring(\n            TimelineUtils.FLOW_ID_TAG_PREFIX.length() + 1);\n        if (!value.isEmpty()) {\n          environment.put(TimelineUtils.FLOW_ID_TAG_PREFIX, value);\n        }\n      }\n      if (tag.startsWith(TimelineUtils.FLOW_RUN_ID_TAG_PREFIX  + \":\") ||\n          tag.startsWith(TimelineUtils.FLOW_RUN_ID_TAG_PREFIX.toLowerCase() + \":\")) {\n        String value \u003d tag.substring(\n            TimelineUtils.FLOW_RUN_ID_TAG_PREFIX.length() + 1);\n        if (!value.isEmpty()) {\n          environment.put(TimelineUtils.FLOW_RUN_ID_TAG_PREFIX, value);\n        }\n      }\n    }\n    Credentials credentials \u003d new Credentials();\n    DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n    ByteBuffer tokens \u003d container.getTokens();\n    if (tokens !\u003d null) {\n      // TODO: Don\u0027t do this kind of checks everywhere.\n      dibb.reset(tokens);\n      credentials.readTokenStorageStream(dibb);\n      tokens.rewind();\n    }\n\n    // Add AMRMToken\n    Token\u003cAMRMTokenIdentifier\u003e amrmToken \u003d createAndSetAMRMToken();\n    if (amrmToken !\u003d null) {\n      credentials.addToken(amrmToken.getService(), amrmToken);\n    }\n    DataOutputBuffer dob \u003d new DataOutputBuffer();\n    credentials.writeTokenStorageToStream(dob);\n    container.setTokens(ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/amlauncher/AMLauncher.java",
      "extendedDetails": {}
    },
    "d6e3164d4a18271299c63377326ca56e8a980830": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2355. MAX_APP_ATTEMPTS_ENV may no longer be a useful env var for a container (Darrell Taylor via aw)\n",
      "commitDate": "27/05/15 4:40 PM",
      "commitName": "d6e3164d4a18271299c63377326ca56e8a980830",
      "commitAuthor": "Allen Wittenauer",
      "commitDateOld": "01/05/15 6:18 PM",
      "commitNameOld": "f8204e241d9271497defd4d42646fb89c61cefe3",
      "commitAuthorOld": "Gera Shegalov",
      "daysBetweenCommits": 25.93,
      "commitsBetweenForRepo": 282,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,37 +1,34 @@\n   protected void setupTokens(\n       ContainerLaunchContext container, ContainerId containerID)\n       throws IOException {\n     Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n     environment.put(ApplicationConstants.APPLICATION_WEB_PROXY_BASE_ENV,\n         application.getWebProxyBase());\n-    // Set AppSubmitTime and MaxAppAttempts to be consumable by the AM.\n+    // Set AppSubmitTime to be consumable by the AM.\n     ApplicationId applicationId \u003d\n         application.getAppAttemptId().getApplicationId();\n     environment.put(\n         ApplicationConstants.APP_SUBMIT_TIME_ENV,\n         String.valueOf(rmContext.getRMApps()\n             .get(applicationId)\n             .getSubmitTime()));\n-    environment.put(ApplicationConstants.MAX_APP_ATTEMPTS_ENV,\n-        String.valueOf(rmContext.getRMApps().get(\n-            applicationId).getMaxAppAttempts()));\n \n     Credentials credentials \u003d new Credentials();\n     DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n     ByteBuffer tokens \u003d container.getTokens();\n     if (tokens !\u003d null) {\n       // TODO: Don\u0027t do this kind of checks everywhere.\n       dibb.reset(tokens);\n       credentials.readTokenStorageStream(dibb);\n       tokens.rewind();\n     }\n \n     // Add AMRMToken\n     Token\u003cAMRMTokenIdentifier\u003e amrmToken \u003d createAndSetAMRMToken();\n     if (amrmToken !\u003d null) {\n       credentials.addToken(amrmToken.getService(), amrmToken);\n     }\n     DataOutputBuffer dob \u003d new DataOutputBuffer();\n     credentials.writeTokenStorageToStream(dob);\n     container.setTokens(ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void setupTokens(\n      ContainerLaunchContext container, ContainerId containerID)\n      throws IOException {\n    Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n    environment.put(ApplicationConstants.APPLICATION_WEB_PROXY_BASE_ENV,\n        application.getWebProxyBase());\n    // Set AppSubmitTime to be consumable by the AM.\n    ApplicationId applicationId \u003d\n        application.getAppAttemptId().getApplicationId();\n    environment.put(\n        ApplicationConstants.APP_SUBMIT_TIME_ENV,\n        String.valueOf(rmContext.getRMApps()\n            .get(applicationId)\n            .getSubmitTime()));\n\n    Credentials credentials \u003d new Credentials();\n    DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n    ByteBuffer tokens \u003d container.getTokens();\n    if (tokens !\u003d null) {\n      // TODO: Don\u0027t do this kind of checks everywhere.\n      dibb.reset(tokens);\n      credentials.readTokenStorageStream(dibb);\n      tokens.rewind();\n    }\n\n    // Add AMRMToken\n    Token\u003cAMRMTokenIdentifier\u003e amrmToken \u003d createAndSetAMRMToken();\n    if (amrmToken !\u003d null) {\n      credentials.addToken(amrmToken.getService(), amrmToken);\n    }\n    DataOutputBuffer dob \u003d new DataOutputBuffer();\n    credentials.writeTokenStorageToStream(dob);\n    container.setTokens(ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/amlauncher/AMLauncher.java",
      "extendedDetails": {}
    },
    "f8204e241d9271497defd4d42646fb89c61cefe3": {
      "type": "Ymultichange(Ymodifierchange,Ybodychange)",
      "commitMessage": "YARN-2893. AMLaucher: sporadic job failures due to EOFException in readTokenStorageStream. (Zhihai Xu via gera)\n",
      "commitDate": "01/05/15 6:18 PM",
      "commitName": "f8204e241d9271497defd4d42646fb89c61cefe3",
      "commitAuthor": "Gera Shegalov",
      "subchanges": [
        {
          "type": "Ymodifierchange",
          "commitMessage": "YARN-2893. AMLaucher: sporadic job failures due to EOFException in readTokenStorageStream. (Zhihai Xu via gera)\n",
          "commitDate": "01/05/15 6:18 PM",
          "commitName": "f8204e241d9271497defd4d42646fb89c61cefe3",
          "commitAuthor": "Gera Shegalov",
          "commitDateOld": "08/08/14 2:38 PM",
          "commitNameOld": "eeb4acd955802e2a84ea94cecf2e2341b83d5efb",
          "commitAuthorOld": "Xuan Gong",
          "daysBetweenCommits": 266.15,
          "commitsBetweenForRepo": 2297,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,35 +1,37 @@\n-  private void setupTokens(\n+  protected void setupTokens(\n       ContainerLaunchContext container, ContainerId containerID)\n       throws IOException {\n     Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n     environment.put(ApplicationConstants.APPLICATION_WEB_PROXY_BASE_ENV,\n         application.getWebProxyBase());\n     // Set AppSubmitTime and MaxAppAttempts to be consumable by the AM.\n     ApplicationId applicationId \u003d\n         application.getAppAttemptId().getApplicationId();\n     environment.put(\n         ApplicationConstants.APP_SUBMIT_TIME_ENV,\n         String.valueOf(rmContext.getRMApps()\n             .get(applicationId)\n             .getSubmitTime()));\n     environment.put(ApplicationConstants.MAX_APP_ATTEMPTS_ENV,\n         String.valueOf(rmContext.getRMApps().get(\n             applicationId).getMaxAppAttempts()));\n \n     Credentials credentials \u003d new Credentials();\n     DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n-    if (container.getTokens() !\u003d null) {\n+    ByteBuffer tokens \u003d container.getTokens();\n+    if (tokens !\u003d null) {\n       // TODO: Don\u0027t do this kind of checks everywhere.\n-      dibb.reset(container.getTokens());\n+      dibb.reset(tokens);\n       credentials.readTokenStorageStream(dibb);\n+      tokens.rewind();\n     }\n \n     // Add AMRMToken\n     Token\u003cAMRMTokenIdentifier\u003e amrmToken \u003d createAndSetAMRMToken();\n     if (amrmToken !\u003d null) {\n       credentials.addToken(amrmToken.getService(), amrmToken);\n     }\n     DataOutputBuffer dob \u003d new DataOutputBuffer();\n     credentials.writeTokenStorageToStream(dob);\n     container.setTokens(ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected void setupTokens(\n      ContainerLaunchContext container, ContainerId containerID)\n      throws IOException {\n    Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n    environment.put(ApplicationConstants.APPLICATION_WEB_PROXY_BASE_ENV,\n        application.getWebProxyBase());\n    // Set AppSubmitTime and MaxAppAttempts to be consumable by the AM.\n    ApplicationId applicationId \u003d\n        application.getAppAttemptId().getApplicationId();\n    environment.put(\n        ApplicationConstants.APP_SUBMIT_TIME_ENV,\n        String.valueOf(rmContext.getRMApps()\n            .get(applicationId)\n            .getSubmitTime()));\n    environment.put(ApplicationConstants.MAX_APP_ATTEMPTS_ENV,\n        String.valueOf(rmContext.getRMApps().get(\n            applicationId).getMaxAppAttempts()));\n\n    Credentials credentials \u003d new Credentials();\n    DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n    ByteBuffer tokens \u003d container.getTokens();\n    if (tokens !\u003d null) {\n      // TODO: Don\u0027t do this kind of checks everywhere.\n      dibb.reset(tokens);\n      credentials.readTokenStorageStream(dibb);\n      tokens.rewind();\n    }\n\n    // Add AMRMToken\n    Token\u003cAMRMTokenIdentifier\u003e amrmToken \u003d createAndSetAMRMToken();\n    if (amrmToken !\u003d null) {\n      credentials.addToken(amrmToken.getService(), amrmToken);\n    }\n    DataOutputBuffer dob \u003d new DataOutputBuffer();\n    credentials.writeTokenStorageToStream(dob);\n    container.setTokens(ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/amlauncher/AMLauncher.java",
          "extendedDetails": {
            "oldValue": "[private]",
            "newValue": "[protected]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-2893. AMLaucher: sporadic job failures due to EOFException in readTokenStorageStream. (Zhihai Xu via gera)\n",
          "commitDate": "01/05/15 6:18 PM",
          "commitName": "f8204e241d9271497defd4d42646fb89c61cefe3",
          "commitAuthor": "Gera Shegalov",
          "commitDateOld": "08/08/14 2:38 PM",
          "commitNameOld": "eeb4acd955802e2a84ea94cecf2e2341b83d5efb",
          "commitAuthorOld": "Xuan Gong",
          "daysBetweenCommits": 266.15,
          "commitsBetweenForRepo": 2297,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,35 +1,37 @@\n-  private void setupTokens(\n+  protected void setupTokens(\n       ContainerLaunchContext container, ContainerId containerID)\n       throws IOException {\n     Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n     environment.put(ApplicationConstants.APPLICATION_WEB_PROXY_BASE_ENV,\n         application.getWebProxyBase());\n     // Set AppSubmitTime and MaxAppAttempts to be consumable by the AM.\n     ApplicationId applicationId \u003d\n         application.getAppAttemptId().getApplicationId();\n     environment.put(\n         ApplicationConstants.APP_SUBMIT_TIME_ENV,\n         String.valueOf(rmContext.getRMApps()\n             .get(applicationId)\n             .getSubmitTime()));\n     environment.put(ApplicationConstants.MAX_APP_ATTEMPTS_ENV,\n         String.valueOf(rmContext.getRMApps().get(\n             applicationId).getMaxAppAttempts()));\n \n     Credentials credentials \u003d new Credentials();\n     DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n-    if (container.getTokens() !\u003d null) {\n+    ByteBuffer tokens \u003d container.getTokens();\n+    if (tokens !\u003d null) {\n       // TODO: Don\u0027t do this kind of checks everywhere.\n-      dibb.reset(container.getTokens());\n+      dibb.reset(tokens);\n       credentials.readTokenStorageStream(dibb);\n+      tokens.rewind();\n     }\n \n     // Add AMRMToken\n     Token\u003cAMRMTokenIdentifier\u003e amrmToken \u003d createAndSetAMRMToken();\n     if (amrmToken !\u003d null) {\n       credentials.addToken(amrmToken.getService(), amrmToken);\n     }\n     DataOutputBuffer dob \u003d new DataOutputBuffer();\n     credentials.writeTokenStorageToStream(dob);\n     container.setTokens(ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected void setupTokens(\n      ContainerLaunchContext container, ContainerId containerID)\n      throws IOException {\n    Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n    environment.put(ApplicationConstants.APPLICATION_WEB_PROXY_BASE_ENV,\n        application.getWebProxyBase());\n    // Set AppSubmitTime and MaxAppAttempts to be consumable by the AM.\n    ApplicationId applicationId \u003d\n        application.getAppAttemptId().getApplicationId();\n    environment.put(\n        ApplicationConstants.APP_SUBMIT_TIME_ENV,\n        String.valueOf(rmContext.getRMApps()\n            .get(applicationId)\n            .getSubmitTime()));\n    environment.put(ApplicationConstants.MAX_APP_ATTEMPTS_ENV,\n        String.valueOf(rmContext.getRMApps().get(\n            applicationId).getMaxAppAttempts()));\n\n    Credentials credentials \u003d new Credentials();\n    DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n    ByteBuffer tokens \u003d container.getTokens();\n    if (tokens !\u003d null) {\n      // TODO: Don\u0027t do this kind of checks everywhere.\n      dibb.reset(tokens);\n      credentials.readTokenStorageStream(dibb);\n      tokens.rewind();\n    }\n\n    // Add AMRMToken\n    Token\u003cAMRMTokenIdentifier\u003e amrmToken \u003d createAndSetAMRMToken();\n    if (amrmToken !\u003d null) {\n      credentials.addToken(amrmToken.getService(), amrmToken);\n    }\n    DataOutputBuffer dob \u003d new DataOutputBuffer();\n    credentials.writeTokenStorageToStream(dob);\n    container.setTokens(ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/amlauncher/AMLauncher.java",
          "extendedDetails": {}
        }
      ]
    },
    "eeb4acd955802e2a84ea94cecf2e2341b83d5efb": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2212: ApplicationMaster needs to find a way to update the AMRMToken periodically. Contributed by Xuan Gong\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1616892 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/08/14 2:38 PM",
      "commitName": "eeb4acd955802e2a84ea94cecf2e2341b83d5efb",
      "commitAuthor": "Xuan Gong",
      "commitDateOld": "29/07/13 4:17 PM",
      "commitNameOld": "817a6543465a3228cdb28a2eeb8e4f96a2d0f9e6",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 374.93,
      "commitsBetweenForRepo": 2521,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,35 @@\n   private void setupTokens(\n       ContainerLaunchContext container, ContainerId containerID)\n       throws IOException {\n     Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n     environment.put(ApplicationConstants.APPLICATION_WEB_PROXY_BASE_ENV,\n         application.getWebProxyBase());\n     // Set AppSubmitTime and MaxAppAttempts to be consumable by the AM.\n     ApplicationId applicationId \u003d\n         application.getAppAttemptId().getApplicationId();\n     environment.put(\n         ApplicationConstants.APP_SUBMIT_TIME_ENV,\n         String.valueOf(rmContext.getRMApps()\n             .get(applicationId)\n             .getSubmitTime()));\n     environment.put(ApplicationConstants.MAX_APP_ATTEMPTS_ENV,\n         String.valueOf(rmContext.getRMApps().get(\n             applicationId).getMaxAppAttempts()));\n \n     Credentials credentials \u003d new Credentials();\n     DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n     if (container.getTokens() !\u003d null) {\n       // TODO: Don\u0027t do this kind of checks everywhere.\n       dibb.reset(container.getTokens());\n       credentials.readTokenStorageStream(dibb);\n     }\n \n     // Add AMRMToken\n-    Token\u003cAMRMTokenIdentifier\u003e amrmToken \u003d getAMRMToken();\n+    Token\u003cAMRMTokenIdentifier\u003e amrmToken \u003d createAndSetAMRMToken();\n     if (amrmToken !\u003d null) {\n       credentials.addToken(amrmToken.getService(), amrmToken);\n     }\n     DataOutputBuffer dob \u003d new DataOutputBuffer();\n     credentials.writeTokenStorageToStream(dob);\n     container.setTokens(ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void setupTokens(\n      ContainerLaunchContext container, ContainerId containerID)\n      throws IOException {\n    Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n    environment.put(ApplicationConstants.APPLICATION_WEB_PROXY_BASE_ENV,\n        application.getWebProxyBase());\n    // Set AppSubmitTime and MaxAppAttempts to be consumable by the AM.\n    ApplicationId applicationId \u003d\n        application.getAppAttemptId().getApplicationId();\n    environment.put(\n        ApplicationConstants.APP_SUBMIT_TIME_ENV,\n        String.valueOf(rmContext.getRMApps()\n            .get(applicationId)\n            .getSubmitTime()));\n    environment.put(ApplicationConstants.MAX_APP_ATTEMPTS_ENV,\n        String.valueOf(rmContext.getRMApps().get(\n            applicationId).getMaxAppAttempts()));\n\n    Credentials credentials \u003d new Credentials();\n    DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n    if (container.getTokens() !\u003d null) {\n      // TODO: Don\u0027t do this kind of checks everywhere.\n      dibb.reset(container.getTokens());\n      credentials.readTokenStorageStream(dibb);\n    }\n\n    // Add AMRMToken\n    Token\u003cAMRMTokenIdentifier\u003e amrmToken \u003d createAndSetAMRMToken();\n    if (amrmToken !\u003d null) {\n      credentials.addToken(amrmToken.getService(), amrmToken);\n    }\n    DataOutputBuffer dob \u003d new DataOutputBuffer();\n    credentials.writeTokenStorageToStream(dob);\n    container.setTokens(ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/amlauncher/AMLauncher.java",
      "extendedDetails": {}
    },
    "817a6543465a3228cdb28a2eeb8e4f96a2d0f9e6": {
      "type": "Ybodychange",
      "commitMessage": "YARN-945. Removed setting of AMRMToken\u0027s service from ResourceManager and changed client libraries do it all the time and correctly. Contributed by Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1508232 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/07/13 4:17 PM",
      "commitName": "817a6543465a3228cdb28a2eeb8e4f96a2d0f9e6",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "27/07/13 11:50 AM",
      "commitNameOld": "ae8f07d47b92f54be404b84f608948de4cde7987",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 2.19,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,35 @@\n   private void setupTokens(\n       ContainerLaunchContext container, ContainerId containerID)\n       throws IOException {\n     Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n     environment.put(ApplicationConstants.APPLICATION_WEB_PROXY_BASE_ENV,\n         application.getWebProxyBase());\n     // Set AppSubmitTime and MaxAppAttempts to be consumable by the AM.\n     ApplicationId applicationId \u003d\n         application.getAppAttemptId().getApplicationId();\n     environment.put(\n         ApplicationConstants.APP_SUBMIT_TIME_ENV,\n         String.valueOf(rmContext.getRMApps()\n             .get(applicationId)\n             .getSubmitTime()));\n     environment.put(ApplicationConstants.MAX_APP_ATTEMPTS_ENV,\n         String.valueOf(rmContext.getRMApps().get(\n             applicationId).getMaxAppAttempts()));\n \n     Credentials credentials \u003d new Credentials();\n     DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n     if (container.getTokens() !\u003d null) {\n       // TODO: Don\u0027t do this kind of checks everywhere.\n       dibb.reset(container.getTokens());\n       credentials.readTokenStorageStream(dibb);\n     }\n \n     // Add AMRMToken\n-    Token\u003cAMRMTokenIdentifier\u003e amrmToken \u003d application.getAMRMToken();\n+    Token\u003cAMRMTokenIdentifier\u003e amrmToken \u003d getAMRMToken();\n     if (amrmToken !\u003d null) {\n       credentials.addToken(amrmToken.getService(), amrmToken);\n     }\n     DataOutputBuffer dob \u003d new DataOutputBuffer();\n     credentials.writeTokenStorageToStream(dob);\n     container.setTokens(ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void setupTokens(\n      ContainerLaunchContext container, ContainerId containerID)\n      throws IOException {\n    Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n    environment.put(ApplicationConstants.APPLICATION_WEB_PROXY_BASE_ENV,\n        application.getWebProxyBase());\n    // Set AppSubmitTime and MaxAppAttempts to be consumable by the AM.\n    ApplicationId applicationId \u003d\n        application.getAppAttemptId().getApplicationId();\n    environment.put(\n        ApplicationConstants.APP_SUBMIT_TIME_ENV,\n        String.valueOf(rmContext.getRMApps()\n            .get(applicationId)\n            .getSubmitTime()));\n    environment.put(ApplicationConstants.MAX_APP_ATTEMPTS_ENV,\n        String.valueOf(rmContext.getRMApps().get(\n            applicationId).getMaxAppAttempts()));\n\n    Credentials credentials \u003d new Credentials();\n    DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n    if (container.getTokens() !\u003d null) {\n      // TODO: Don\u0027t do this kind of checks everywhere.\n      dibb.reset(container.getTokens());\n      credentials.readTokenStorageStream(dibb);\n    }\n\n    // Add AMRMToken\n    Token\u003cAMRMTokenIdentifier\u003e amrmToken \u003d getAMRMToken();\n    if (amrmToken !\u003d null) {\n      credentials.addToken(amrmToken.getService(), amrmToken);\n    }\n    DataOutputBuffer dob \u003d new DataOutputBuffer();\n    credentials.writeTokenStorageToStream(dob);\n    container.setTokens(ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/amlauncher/AMLauncher.java",
      "extendedDetails": {}
    },
    "ae8f07d47b92f54be404b84f608948de4cde7987": {
      "type": "Ybodychange",
      "commitMessage": "YARN-960. Fixed ResourceManager to propagate client-submitted credentials irrespective of security. Contributed by Daryn Sharp.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1507700 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/07/13 11:50 AM",
      "commitName": "ae8f07d47b92f54be404b84f608948de4cde7987",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "23/07/13 8:41 PM",
      "commitNameOld": "3ca3137179ef093e42cde06587c9ea785b10f32c",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 3.63,
      "commitsBetweenForRepo": 31,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,35 @@\n   private void setupTokens(\n       ContainerLaunchContext container, ContainerId containerID)\n       throws IOException {\n     Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n     environment.put(ApplicationConstants.APPLICATION_WEB_PROXY_BASE_ENV,\n         application.getWebProxyBase());\n     // Set AppSubmitTime and MaxAppAttempts to be consumable by the AM.\n     ApplicationId applicationId \u003d\n         application.getAppAttemptId().getApplicationId();\n     environment.put(\n         ApplicationConstants.APP_SUBMIT_TIME_ENV,\n         String.valueOf(rmContext.getRMApps()\n             .get(applicationId)\n             .getSubmitTime()));\n     environment.put(ApplicationConstants.MAX_APP_ATTEMPTS_ENV,\n         String.valueOf(rmContext.getRMApps().get(\n             applicationId).getMaxAppAttempts()));\n \n     Credentials credentials \u003d new Credentials();\n-    \n-    if (UserGroupInformation.isSecurityEnabled()) {\n-      // TODO: Security enabled/disabled info should come from RM.\n-\n-      DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n-      if (container.getTokens() !\u003d null) {\n-        // TODO: Don\u0027t do this kind of checks everywhere.\n-        dibb.reset(container.getTokens());\n-        credentials.readTokenStorageStream(dibb);\n-      }\n+    DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n+    if (container.getTokens() !\u003d null) {\n+      // TODO: Don\u0027t do this kind of checks everywhere.\n+      dibb.reset(container.getTokens());\n+      credentials.readTokenStorageStream(dibb);\n     }\n \n     // Add AMRMToken\n     Token\u003cAMRMTokenIdentifier\u003e amrmToken \u003d application.getAMRMToken();\n     if (amrmToken !\u003d null) {\n       credentials.addToken(amrmToken.getService(), amrmToken);\n     }\n     DataOutputBuffer dob \u003d new DataOutputBuffer();\n     credentials.writeTokenStorageToStream(dob);\n     container.setTokens(ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void setupTokens(\n      ContainerLaunchContext container, ContainerId containerID)\n      throws IOException {\n    Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n    environment.put(ApplicationConstants.APPLICATION_WEB_PROXY_BASE_ENV,\n        application.getWebProxyBase());\n    // Set AppSubmitTime and MaxAppAttempts to be consumable by the AM.\n    ApplicationId applicationId \u003d\n        application.getAppAttemptId().getApplicationId();\n    environment.put(\n        ApplicationConstants.APP_SUBMIT_TIME_ENV,\n        String.valueOf(rmContext.getRMApps()\n            .get(applicationId)\n            .getSubmitTime()));\n    environment.put(ApplicationConstants.MAX_APP_ATTEMPTS_ENV,\n        String.valueOf(rmContext.getRMApps().get(\n            applicationId).getMaxAppAttempts()));\n\n    Credentials credentials \u003d new Credentials();\n    DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n    if (container.getTokens() !\u003d null) {\n      // TODO: Don\u0027t do this kind of checks everywhere.\n      dibb.reset(container.getTokens());\n      credentials.readTokenStorageStream(dibb);\n    }\n\n    // Add AMRMToken\n    Token\u003cAMRMTokenIdentifier\u003e amrmToken \u003d application.getAMRMToken();\n    if (amrmToken !\u003d null) {\n      credentials.addToken(amrmToken.getService(), amrmToken);\n    }\n    DataOutputBuffer dob \u003d new DataOutputBuffer();\n    credentials.writeTokenStorageToStream(dob);\n    container.setTokens(ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/amlauncher/AMLauncher.java",
      "extendedDetails": {}
    },
    "32bc200d54928d39acdc837c2c77b4c443fb46be": {
      "type": "Ybodychange",
      "commitMessage": "YARN-701. Use application tokens irrespective of secure or non-secure mode. Contributed by Vinod K V.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1504604 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/07/13 12:03 PM",
      "commitName": "32bc200d54928d39acdc837c2c77b4c443fb46be",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "18/06/13 4:19 PM",
      "commitNameOld": "243bcd367ff3130d74676280233041f88aca62a5",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 29.82,
      "commitsBetweenForRepo": 148,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,40 @@\n   private void setupTokens(\n       ContainerLaunchContext container, ContainerId containerID)\n       throws IOException {\n     Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n     environment.put(ApplicationConstants.APPLICATION_WEB_PROXY_BASE_ENV,\n         application.getWebProxyBase());\n     // Set AppSubmitTime and MaxAppAttempts to be consumable by the AM.\n     ApplicationId applicationId \u003d\n         application.getAppAttemptId().getApplicationId();\n     environment.put(\n         ApplicationConstants.APP_SUBMIT_TIME_ENV,\n         String.valueOf(rmContext.getRMApps()\n             .get(applicationId)\n             .getSubmitTime()));\n     environment.put(ApplicationConstants.MAX_APP_ATTEMPTS_ENV,\n         String.valueOf(rmContext.getRMApps().get(\n             applicationId).getMaxAppAttempts()));\n- \n+\n+    Credentials credentials \u003d new Credentials();\n+    \n     if (UserGroupInformation.isSecurityEnabled()) {\n       // TODO: Security enabled/disabled info should come from RM.\n \n-      Credentials credentials \u003d new Credentials();\n-\n       DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n       if (container.getTokens() !\u003d null) {\n         // TODO: Don\u0027t do this kind of checks everywhere.\n         dibb.reset(container.getTokens());\n         credentials.readTokenStorageStream(dibb);\n       }\n-\n-      // Add application token\n-      Token\u003cAMRMTokenIdentifier\u003e amrmToken \u003d\n-          application.getAMRMToken();\n-      if(amrmToken !\u003d null) {\n-        credentials.addToken(amrmToken.getService(), amrmToken);\n-      }\n-      DataOutputBuffer dob \u003d new DataOutputBuffer();\n-      credentials.writeTokenStorageToStream(dob);\n-      container.setTokens(ByteBuffer.wrap(dob.getData(), 0,\n-        dob.getLength()));\n     }\n+\n+    // Add AMRMToken\n+    Token\u003cAMRMTokenIdentifier\u003e amrmToken \u003d application.getAMRMToken();\n+    if (amrmToken !\u003d null) {\n+      credentials.addToken(amrmToken.getService(), amrmToken);\n+    }\n+    DataOutputBuffer dob \u003d new DataOutputBuffer();\n+    credentials.writeTokenStorageToStream(dob);\n+    container.setTokens(ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void setupTokens(\n      ContainerLaunchContext container, ContainerId containerID)\n      throws IOException {\n    Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n    environment.put(ApplicationConstants.APPLICATION_WEB_PROXY_BASE_ENV,\n        application.getWebProxyBase());\n    // Set AppSubmitTime and MaxAppAttempts to be consumable by the AM.\n    ApplicationId applicationId \u003d\n        application.getAppAttemptId().getApplicationId();\n    environment.put(\n        ApplicationConstants.APP_SUBMIT_TIME_ENV,\n        String.valueOf(rmContext.getRMApps()\n            .get(applicationId)\n            .getSubmitTime()));\n    environment.put(ApplicationConstants.MAX_APP_ATTEMPTS_ENV,\n        String.valueOf(rmContext.getRMApps().get(\n            applicationId).getMaxAppAttempts()));\n\n    Credentials credentials \u003d new Credentials();\n    \n    if (UserGroupInformation.isSecurityEnabled()) {\n      // TODO: Security enabled/disabled info should come from RM.\n\n      DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n      if (container.getTokens() !\u003d null) {\n        // TODO: Don\u0027t do this kind of checks everywhere.\n        dibb.reset(container.getTokens());\n        credentials.readTokenStorageStream(dibb);\n      }\n    }\n\n    // Add AMRMToken\n    Token\u003cAMRMTokenIdentifier\u003e amrmToken \u003d application.getAMRMToken();\n    if (amrmToken !\u003d null) {\n      credentials.addToken(amrmToken.getService(), amrmToken);\n    }\n    DataOutputBuffer dob \u003d new DataOutputBuffer();\n    credentials.writeTokenStorageToStream(dob);\n    container.setTokens(ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/amlauncher/AMLauncher.java",
      "extendedDetails": {}
    },
    "5d1b453b8591d87ffb564857015c26c99fb7437c": {
      "type": "Ymultichange(Yrename,Ybodychange)",
      "commitMessage": "YARN-610. ClientToken is no longer set in the environment of the Containers. Contributed by Omkar Vinit Joshi.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1493968 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/06/13 4:13 PM",
      "commitName": "5d1b453b8591d87ffb564857015c26c99fb7437c",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "YARN-610. ClientToken is no longer set in the environment of the Containers. Contributed by Omkar Vinit Joshi.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1493968 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "17/06/13 4:13 PM",
          "commitName": "5d1b453b8591d87ffb564857015c26c99fb7437c",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "17/06/13 12:11 PM",
          "commitNameOld": "7d0c43d7cff6d250613a04fea9449f139988e901",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 0.17,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,51 +1,42 @@\n-  private void setupTokensAndEnv(\n+  private void setupTokens(\n       ContainerLaunchContext container, ContainerId containerID)\n       throws IOException {\n     Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n     environment.put(ApplicationConstants.APPLICATION_WEB_PROXY_BASE_ENV,\n         application.getWebProxyBase());\n     // Set AppSubmitTime and MaxAppAttempts to be consumable by the AM.\n     ApplicationId applicationId \u003d\n         application.getAppAttemptId().getApplicationId();\n     environment.put(\n         ApplicationConstants.APP_SUBMIT_TIME_ENV,\n         String.valueOf(rmContext.getRMApps()\n             .get(applicationId)\n             .getSubmitTime()));\n     environment.put(ApplicationConstants.MAX_APP_ATTEMPTS_ENV,\n         String.valueOf(rmContext.getRMApps().get(\n             applicationId).getMaxAppAttempts()));\n  \n     if (UserGroupInformation.isSecurityEnabled()) {\n       // TODO: Security enabled/disabled info should come from RM.\n \n       Credentials credentials \u003d new Credentials();\n \n       DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n       if (container.getTokens() !\u003d null) {\n         // TODO: Don\u0027t do this kind of checks everywhere.\n         dibb.reset(container.getTokens());\n         credentials.readTokenStorageStream(dibb);\n       }\n \n       // Add application token\n       Token\u003cAMRMTokenIdentifier\u003e amrmToken \u003d\n           application.getAMRMToken();\n       if(amrmToken !\u003d null) {\n         credentials.addToken(amrmToken.getService(), amrmToken);\n       }\n       DataOutputBuffer dob \u003d new DataOutputBuffer();\n       credentials.writeTokenStorageToStream(dob);\n       container.setTokens(ByteBuffer.wrap(dob.getData(), 0,\n         dob.getLength()));\n-\n-      SecretKey clientSecretKey \u003d\n-          this.rmContext.getClientToAMTokenSecretManager().getMasterKey(\n-            application.getAppAttemptId());\n-      String encoded \u003d\n-          Base64.encodeBase64URLSafeString(clientSecretKey.getEncoded());\n-      environment.put(\n-          ApplicationConstants.APPLICATION_CLIENT_SECRET_ENV_NAME, \n-          encoded);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void setupTokens(\n      ContainerLaunchContext container, ContainerId containerID)\n      throws IOException {\n    Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n    environment.put(ApplicationConstants.APPLICATION_WEB_PROXY_BASE_ENV,\n        application.getWebProxyBase());\n    // Set AppSubmitTime and MaxAppAttempts to be consumable by the AM.\n    ApplicationId applicationId \u003d\n        application.getAppAttemptId().getApplicationId();\n    environment.put(\n        ApplicationConstants.APP_SUBMIT_TIME_ENV,\n        String.valueOf(rmContext.getRMApps()\n            .get(applicationId)\n            .getSubmitTime()));\n    environment.put(ApplicationConstants.MAX_APP_ATTEMPTS_ENV,\n        String.valueOf(rmContext.getRMApps().get(\n            applicationId).getMaxAppAttempts()));\n \n    if (UserGroupInformation.isSecurityEnabled()) {\n      // TODO: Security enabled/disabled info should come from RM.\n\n      Credentials credentials \u003d new Credentials();\n\n      DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n      if (container.getTokens() !\u003d null) {\n        // TODO: Don\u0027t do this kind of checks everywhere.\n        dibb.reset(container.getTokens());\n        credentials.readTokenStorageStream(dibb);\n      }\n\n      // Add application token\n      Token\u003cAMRMTokenIdentifier\u003e amrmToken \u003d\n          application.getAMRMToken();\n      if(amrmToken !\u003d null) {\n        credentials.addToken(amrmToken.getService(), amrmToken);\n      }\n      DataOutputBuffer dob \u003d new DataOutputBuffer();\n      credentials.writeTokenStorageToStream(dob);\n      container.setTokens(ByteBuffer.wrap(dob.getData(), 0,\n        dob.getLength()));\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/amlauncher/AMLauncher.java",
          "extendedDetails": {
            "oldValue": "setupTokensAndEnv",
            "newValue": "setupTokens"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-610. ClientToken is no longer set in the environment of the Containers. Contributed by Omkar Vinit Joshi.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1493968 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "17/06/13 4:13 PM",
          "commitName": "5d1b453b8591d87ffb564857015c26c99fb7437c",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "17/06/13 12:11 PM",
          "commitNameOld": "7d0c43d7cff6d250613a04fea9449f139988e901",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 0.17,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,51 +1,42 @@\n-  private void setupTokensAndEnv(\n+  private void setupTokens(\n       ContainerLaunchContext container, ContainerId containerID)\n       throws IOException {\n     Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n     environment.put(ApplicationConstants.APPLICATION_WEB_PROXY_BASE_ENV,\n         application.getWebProxyBase());\n     // Set AppSubmitTime and MaxAppAttempts to be consumable by the AM.\n     ApplicationId applicationId \u003d\n         application.getAppAttemptId().getApplicationId();\n     environment.put(\n         ApplicationConstants.APP_SUBMIT_TIME_ENV,\n         String.valueOf(rmContext.getRMApps()\n             .get(applicationId)\n             .getSubmitTime()));\n     environment.put(ApplicationConstants.MAX_APP_ATTEMPTS_ENV,\n         String.valueOf(rmContext.getRMApps().get(\n             applicationId).getMaxAppAttempts()));\n  \n     if (UserGroupInformation.isSecurityEnabled()) {\n       // TODO: Security enabled/disabled info should come from RM.\n \n       Credentials credentials \u003d new Credentials();\n \n       DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n       if (container.getTokens() !\u003d null) {\n         // TODO: Don\u0027t do this kind of checks everywhere.\n         dibb.reset(container.getTokens());\n         credentials.readTokenStorageStream(dibb);\n       }\n \n       // Add application token\n       Token\u003cAMRMTokenIdentifier\u003e amrmToken \u003d\n           application.getAMRMToken();\n       if(amrmToken !\u003d null) {\n         credentials.addToken(amrmToken.getService(), amrmToken);\n       }\n       DataOutputBuffer dob \u003d new DataOutputBuffer();\n       credentials.writeTokenStorageToStream(dob);\n       container.setTokens(ByteBuffer.wrap(dob.getData(), 0,\n         dob.getLength()));\n-\n-      SecretKey clientSecretKey \u003d\n-          this.rmContext.getClientToAMTokenSecretManager().getMasterKey(\n-            application.getAppAttemptId());\n-      String encoded \u003d\n-          Base64.encodeBase64URLSafeString(clientSecretKey.getEncoded());\n-      environment.put(\n-          ApplicationConstants.APPLICATION_CLIENT_SECRET_ENV_NAME, \n-          encoded);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void setupTokens(\n      ContainerLaunchContext container, ContainerId containerID)\n      throws IOException {\n    Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n    environment.put(ApplicationConstants.APPLICATION_WEB_PROXY_BASE_ENV,\n        application.getWebProxyBase());\n    // Set AppSubmitTime and MaxAppAttempts to be consumable by the AM.\n    ApplicationId applicationId \u003d\n        application.getAppAttemptId().getApplicationId();\n    environment.put(\n        ApplicationConstants.APP_SUBMIT_TIME_ENV,\n        String.valueOf(rmContext.getRMApps()\n            .get(applicationId)\n            .getSubmitTime()));\n    environment.put(ApplicationConstants.MAX_APP_ATTEMPTS_ENV,\n        String.valueOf(rmContext.getRMApps().get(\n            applicationId).getMaxAppAttempts()));\n \n    if (UserGroupInformation.isSecurityEnabled()) {\n      // TODO: Security enabled/disabled info should come from RM.\n\n      Credentials credentials \u003d new Credentials();\n\n      DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n      if (container.getTokens() !\u003d null) {\n        // TODO: Don\u0027t do this kind of checks everywhere.\n        dibb.reset(container.getTokens());\n        credentials.readTokenStorageStream(dibb);\n      }\n\n      // Add application token\n      Token\u003cAMRMTokenIdentifier\u003e amrmToken \u003d\n          application.getAMRMToken();\n      if(amrmToken !\u003d null) {\n        credentials.addToken(amrmToken.getService(), amrmToken);\n      }\n      DataOutputBuffer dob \u003d new DataOutputBuffer();\n      credentials.writeTokenStorageToStream(dob);\n      container.setTokens(ByteBuffer.wrap(dob.getData(), 0,\n        dob.getLength()));\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/amlauncher/AMLauncher.java",
          "extendedDetails": {}
        }
      ]
    },
    "7d0c43d7cff6d250613a04fea9449f139988e901": {
      "type": "Ybodychange",
      "commitMessage": "YARN-822. Renamed ApplicationToken to be AMRMToken, and similarly the corresponding TokenSelector and SecretManager. Contributed by Omkar Vinit Joshi.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1493889 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/06/13 12:11 PM",
      "commitName": "7d0c43d7cff6d250613a04fea9449f139988e901",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "16/06/13 7:27 PM",
      "commitNameOld": "77e134d13fb87cd098f2e9c23212affe0a7be1be",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.7,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,51 +1,51 @@\n   private void setupTokensAndEnv(\n       ContainerLaunchContext container, ContainerId containerID)\n       throws IOException {\n     Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n     environment.put(ApplicationConstants.APPLICATION_WEB_PROXY_BASE_ENV,\n         application.getWebProxyBase());\n     // Set AppSubmitTime and MaxAppAttempts to be consumable by the AM.\n     ApplicationId applicationId \u003d\n         application.getAppAttemptId().getApplicationId();\n     environment.put(\n         ApplicationConstants.APP_SUBMIT_TIME_ENV,\n         String.valueOf(rmContext.getRMApps()\n             .get(applicationId)\n             .getSubmitTime()));\n     environment.put(ApplicationConstants.MAX_APP_ATTEMPTS_ENV,\n         String.valueOf(rmContext.getRMApps().get(\n             applicationId).getMaxAppAttempts()));\n  \n     if (UserGroupInformation.isSecurityEnabled()) {\n       // TODO: Security enabled/disabled info should come from RM.\n \n       Credentials credentials \u003d new Credentials();\n \n       DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n       if (container.getTokens() !\u003d null) {\n         // TODO: Don\u0027t do this kind of checks everywhere.\n         dibb.reset(container.getTokens());\n         credentials.readTokenStorageStream(dibb);\n       }\n \n       // Add application token\n-      Token\u003cApplicationTokenIdentifier\u003e applicationToken \u003d\n-          application.getApplicationToken();\n-      if(applicationToken !\u003d null) {\n-        credentials.addToken(applicationToken.getService(), applicationToken);\n+      Token\u003cAMRMTokenIdentifier\u003e amrmToken \u003d\n+          application.getAMRMToken();\n+      if(amrmToken !\u003d null) {\n+        credentials.addToken(amrmToken.getService(), amrmToken);\n       }\n       DataOutputBuffer dob \u003d new DataOutputBuffer();\n       credentials.writeTokenStorageToStream(dob);\n       container.setTokens(ByteBuffer.wrap(dob.getData(), 0,\n         dob.getLength()));\n \n       SecretKey clientSecretKey \u003d\n           this.rmContext.getClientToAMTokenSecretManager().getMasterKey(\n             application.getAppAttemptId());\n       String encoded \u003d\n           Base64.encodeBase64URLSafeString(clientSecretKey.getEncoded());\n       environment.put(\n           ApplicationConstants.APPLICATION_CLIENT_SECRET_ENV_NAME, \n           encoded);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void setupTokensAndEnv(\n      ContainerLaunchContext container, ContainerId containerID)\n      throws IOException {\n    Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n    environment.put(ApplicationConstants.APPLICATION_WEB_PROXY_BASE_ENV,\n        application.getWebProxyBase());\n    // Set AppSubmitTime and MaxAppAttempts to be consumable by the AM.\n    ApplicationId applicationId \u003d\n        application.getAppAttemptId().getApplicationId();\n    environment.put(\n        ApplicationConstants.APP_SUBMIT_TIME_ENV,\n        String.valueOf(rmContext.getRMApps()\n            .get(applicationId)\n            .getSubmitTime()));\n    environment.put(ApplicationConstants.MAX_APP_ATTEMPTS_ENV,\n        String.valueOf(rmContext.getRMApps().get(\n            applicationId).getMaxAppAttempts()));\n \n    if (UserGroupInformation.isSecurityEnabled()) {\n      // TODO: Security enabled/disabled info should come from RM.\n\n      Credentials credentials \u003d new Credentials();\n\n      DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n      if (container.getTokens() !\u003d null) {\n        // TODO: Don\u0027t do this kind of checks everywhere.\n        dibb.reset(container.getTokens());\n        credentials.readTokenStorageStream(dibb);\n      }\n\n      // Add application token\n      Token\u003cAMRMTokenIdentifier\u003e amrmToken \u003d\n          application.getAMRMToken();\n      if(amrmToken !\u003d null) {\n        credentials.addToken(amrmToken.getService(), amrmToken);\n      }\n      DataOutputBuffer dob \u003d new DataOutputBuffer();\n      credentials.writeTokenStorageToStream(dob);\n      container.setTokens(ByteBuffer.wrap(dob.getData(), 0,\n        dob.getLength()));\n\n      SecretKey clientSecretKey \u003d\n          this.rmContext.getClientToAMTokenSecretManager().getMasterKey(\n            application.getAppAttemptId());\n      String encoded \u003d\n          Base64.encodeBase64URLSafeString(clientSecretKey.getEncoded());\n      environment.put(\n          ApplicationConstants.APPLICATION_CLIENT_SECRET_ENV_NAME, \n          encoded);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/amlauncher/AMLauncher.java",
      "extendedDetails": {}
    },
    "1a119f87b4f0a78d56e1bb998b1cbc081484fbd1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-615. Rename ContainerLaunchContext.containerTokens to tokens. Contributed by Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1482199 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "13/05/13 9:11 PM",
      "commitName": "1a119f87b4f0a78d56e1bb998b1cbc081484fbd1",
      "commitAuthor": "Siddharth Seth",
      "commitDateOld": "07/05/13 11:20 PM",
      "commitNameOld": "74231f027607ff1a6fe7d72fad28108826963cf3",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 5.91,
      "commitsBetweenForRepo": 39,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,51 +1,51 @@\n   private void setupTokensAndEnv(\n       ContainerLaunchContext container, ContainerId containerID)\n       throws IOException {\n     Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n     environment.put(ApplicationConstants.APPLICATION_WEB_PROXY_BASE_ENV,\n         application.getWebProxyBase());\n     // Set AppSubmitTime and MaxAppAttempts to be consumable by the AM.\n     ApplicationId applicationId \u003d\n         application.getAppAttemptId().getApplicationId();\n     environment.put(\n         ApplicationConstants.APP_SUBMIT_TIME_ENV,\n         String.valueOf(rmContext.getRMApps()\n             .get(applicationId)\n             .getSubmitTime()));\n     environment.put(ApplicationConstants.MAX_APP_ATTEMPTS_ENV,\n         String.valueOf(rmContext.getRMApps().get(\n             applicationId).getMaxAppAttempts()));\n  \n     if (UserGroupInformation.isSecurityEnabled()) {\n       // TODO: Security enabled/disabled info should come from RM.\n \n       Credentials credentials \u003d new Credentials();\n \n       DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n-      if (container.getContainerTokens() !\u003d null) {\n+      if (container.getTokens() !\u003d null) {\n         // TODO: Don\u0027t do this kind of checks everywhere.\n-        dibb.reset(container.getContainerTokens());\n+        dibb.reset(container.getTokens());\n         credentials.readTokenStorageStream(dibb);\n       }\n \n       // Add application token\n       Token\u003cApplicationTokenIdentifier\u003e applicationToken \u003d\n           application.getApplicationToken();\n       if(applicationToken !\u003d null) {\n         credentials.addToken(applicationToken.getService(), applicationToken);\n       }\n       DataOutputBuffer dob \u003d new DataOutputBuffer();\n       credentials.writeTokenStorageToStream(dob);\n-      container.setContainerTokens(ByteBuffer.wrap(dob.getData(), 0,\n+      container.setTokens(ByteBuffer.wrap(dob.getData(), 0,\n         dob.getLength()));\n \n       SecretKey clientSecretKey \u003d\n           this.rmContext.getClientToAMTokenSecretManager().getMasterKey(\n             application.getAppAttemptId());\n       String encoded \u003d\n           Base64.encodeBase64URLSafeString(clientSecretKey.getEncoded());\n       environment.put(\n           ApplicationConstants.APPLICATION_CLIENT_SECRET_ENV_NAME, \n           encoded);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void setupTokensAndEnv(\n      ContainerLaunchContext container, ContainerId containerID)\n      throws IOException {\n    Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n    environment.put(ApplicationConstants.APPLICATION_WEB_PROXY_BASE_ENV,\n        application.getWebProxyBase());\n    // Set AppSubmitTime and MaxAppAttempts to be consumable by the AM.\n    ApplicationId applicationId \u003d\n        application.getAppAttemptId().getApplicationId();\n    environment.put(\n        ApplicationConstants.APP_SUBMIT_TIME_ENV,\n        String.valueOf(rmContext.getRMApps()\n            .get(applicationId)\n            .getSubmitTime()));\n    environment.put(ApplicationConstants.MAX_APP_ATTEMPTS_ENV,\n        String.valueOf(rmContext.getRMApps().get(\n            applicationId).getMaxAppAttempts()));\n \n    if (UserGroupInformation.isSecurityEnabled()) {\n      // TODO: Security enabled/disabled info should come from RM.\n\n      Credentials credentials \u003d new Credentials();\n\n      DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n      if (container.getTokens() !\u003d null) {\n        // TODO: Don\u0027t do this kind of checks everywhere.\n        dibb.reset(container.getTokens());\n        credentials.readTokenStorageStream(dibb);\n      }\n\n      // Add application token\n      Token\u003cApplicationTokenIdentifier\u003e applicationToken \u003d\n          application.getApplicationToken();\n      if(applicationToken !\u003d null) {\n        credentials.addToken(applicationToken.getService(), applicationToken);\n      }\n      DataOutputBuffer dob \u003d new DataOutputBuffer();\n      credentials.writeTokenStorageToStream(dob);\n      container.setTokens(ByteBuffer.wrap(dob.getData(), 0,\n        dob.getLength()));\n\n      SecretKey clientSecretKey \u003d\n          this.rmContext.getClientToAMTokenSecretManager().getMasterKey(\n            application.getAppAttemptId());\n      String encoded \u003d\n          Base64.encodeBase64URLSafeString(clientSecretKey.getEncoded());\n      environment.put(\n          ApplicationConstants.APPLICATION_CLIENT_SECRET_ENV_NAME, \n          encoded);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/amlauncher/AMLauncher.java",
      "extendedDetails": {}
    },
    "74231f027607ff1a6fe7d72fad28108826963cf3": {
      "type": "Ybodychange",
      "commitMessage": "YARN-582. Changed ResourceManager to recover Application token and client tokens for app attempt so that RM can be restarted while preserving current applications. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1480168 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/05/13 11:20 PM",
      "commitName": "74231f027607ff1a6fe7d72fad28108826963cf3",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "06/05/13 12:04 PM",
      "commitNameOld": "92b7165a71656468f17ce8b760ce11e648932f0e",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 1.47,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,60 +1,51 @@\n   private void setupTokensAndEnv(\n       ContainerLaunchContext container, ContainerId containerID)\n       throws IOException {\n     Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n     environment.put(ApplicationConstants.APPLICATION_WEB_PROXY_BASE_ENV,\n         application.getWebProxyBase());\n     // Set AppSubmitTime and MaxAppAttempts to be consumable by the AM.\n     ApplicationId applicationId \u003d\n         application.getAppAttemptId().getApplicationId();\n     environment.put(\n         ApplicationConstants.APP_SUBMIT_TIME_ENV,\n         String.valueOf(rmContext.getRMApps()\n             .get(applicationId)\n             .getSubmitTime()));\n     environment.put(ApplicationConstants.MAX_APP_ATTEMPTS_ENV,\n         String.valueOf(rmContext.getRMApps().get(\n             applicationId).getMaxAppAttempts()));\n  \n     if (UserGroupInformation.isSecurityEnabled()) {\n       // TODO: Security enabled/disabled info should come from RM.\n \n       Credentials credentials \u003d new Credentials();\n \n       DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n       if (container.getContainerTokens() !\u003d null) {\n         // TODO: Don\u0027t do this kind of checks everywhere.\n         dibb.reset(container.getContainerTokens());\n         credentials.readTokenStorageStream(dibb);\n       }\n \n-      ApplicationTokenIdentifier id \u003d new ApplicationTokenIdentifier(\n-          application.getAppAttemptId());\n-      Token\u003cApplicationTokenIdentifier\u003e appMasterToken \u003d\n-          new Token\u003cApplicationTokenIdentifier\u003e(id,\n-              this.rmContext.getApplicationTokenSecretManager());\n-      InetSocketAddress serviceAddr \u003d conf.getSocketAddr(\n-          YarnConfiguration.RM_SCHEDULER_ADDRESS,\n-          YarnConfiguration.DEFAULT_RM_SCHEDULER_ADDRESS,\n-          YarnConfiguration.DEFAULT_RM_SCHEDULER_PORT);\n-      // normally the client should set the service after acquiring the token,\n-      // but this token is directly provided to the AMs\n-      SecurityUtil.setTokenService(appMasterToken, serviceAddr);\n-\n-      // Add the ApplicationMaster token\n-      credentials.addToken(appMasterToken.getService(), appMasterToken);\n+      // Add application token\n+      Token\u003cApplicationTokenIdentifier\u003e applicationToken \u003d\n+          application.getApplicationToken();\n+      if(applicationToken !\u003d null) {\n+        credentials.addToken(applicationToken.getService(), applicationToken);\n+      }\n       DataOutputBuffer dob \u003d new DataOutputBuffer();\n       credentials.writeTokenStorageToStream(dob);\n-      container.setContainerTokens(\n-          ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n+      container.setContainerTokens(ByteBuffer.wrap(dob.getData(), 0,\n+        dob.getLength()));\n \n       SecretKey clientSecretKey \u003d\n           this.rmContext.getClientToAMTokenSecretManager().getMasterKey(\n             application.getAppAttemptId());\n       String encoded \u003d\n           Base64.encodeBase64URLSafeString(clientSecretKey.getEncoded());\n       environment.put(\n           ApplicationConstants.APPLICATION_CLIENT_SECRET_ENV_NAME, \n           encoded);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void setupTokensAndEnv(\n      ContainerLaunchContext container, ContainerId containerID)\n      throws IOException {\n    Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n    environment.put(ApplicationConstants.APPLICATION_WEB_PROXY_BASE_ENV,\n        application.getWebProxyBase());\n    // Set AppSubmitTime and MaxAppAttempts to be consumable by the AM.\n    ApplicationId applicationId \u003d\n        application.getAppAttemptId().getApplicationId();\n    environment.put(\n        ApplicationConstants.APP_SUBMIT_TIME_ENV,\n        String.valueOf(rmContext.getRMApps()\n            .get(applicationId)\n            .getSubmitTime()));\n    environment.put(ApplicationConstants.MAX_APP_ATTEMPTS_ENV,\n        String.valueOf(rmContext.getRMApps().get(\n            applicationId).getMaxAppAttempts()));\n \n    if (UserGroupInformation.isSecurityEnabled()) {\n      // TODO: Security enabled/disabled info should come from RM.\n\n      Credentials credentials \u003d new Credentials();\n\n      DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n      if (container.getContainerTokens() !\u003d null) {\n        // TODO: Don\u0027t do this kind of checks everywhere.\n        dibb.reset(container.getContainerTokens());\n        credentials.readTokenStorageStream(dibb);\n      }\n\n      // Add application token\n      Token\u003cApplicationTokenIdentifier\u003e applicationToken \u003d\n          application.getApplicationToken();\n      if(applicationToken !\u003d null) {\n        credentials.addToken(applicationToken.getService(), applicationToken);\n      }\n      DataOutputBuffer dob \u003d new DataOutputBuffer();\n      credentials.writeTokenStorageToStream(dob);\n      container.setContainerTokens(ByteBuffer.wrap(dob.getData(), 0,\n        dob.getLength()));\n\n      SecretKey clientSecretKey \u003d\n          this.rmContext.getClientToAMTokenSecretManager().getMasterKey(\n            application.getAppAttemptId());\n      String encoded \u003d\n          Base64.encodeBase64URLSafeString(clientSecretKey.getEncoded());\n      environment.put(\n          ApplicationConstants.APPLICATION_CLIENT_SECRET_ENV_NAME, \n          encoded);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/amlauncher/AMLauncher.java",
      "extendedDetails": {}
    },
    "be256a181985737ade3f8231b472a2438659c3b2": {
      "type": "Ybodychange",
      "commitMessage": "YARN-579. Stop setting the Application Token in the AppMaster env, in favour of the copy present in the container token field. Contributed by Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1471814 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/04/13 7:46 PM",
      "commitName": "be256a181985737ade3f8231b472a2438659c3b2",
      "commitAuthor": "Siddharth Seth",
      "commitDateOld": "23/04/13 2:39 PM",
      "commitNameOld": "27e8c86999bc6a972a99216060b11ef35b7de858",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 1.21,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,65 +1,60 @@\n   private void setupTokensAndEnv(\n       ContainerLaunchContext container, ContainerId containerID)\n       throws IOException {\n     Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n     environment.put(ApplicationConstants.APPLICATION_WEB_PROXY_BASE_ENV,\n         application.getWebProxyBase());\n     // Set AppSubmitTime and MaxAppAttempts to be consumable by the AM.\n     ApplicationId applicationId \u003d\n         application.getAppAttemptId().getApplicationId();\n     environment.put(\n         ApplicationConstants.APP_SUBMIT_TIME_ENV,\n         String.valueOf(rmContext.getRMApps()\n             .get(applicationId)\n             .getSubmitTime()));\n     environment.put(ApplicationConstants.MAX_APP_ATTEMPTS_ENV,\n         String.valueOf(rmContext.getRMApps().get(\n             applicationId).getMaxAppAttempts()));\n  \n     if (UserGroupInformation.isSecurityEnabled()) {\n       // TODO: Security enabled/disabled info should come from RM.\n \n       Credentials credentials \u003d new Credentials();\n \n       DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n       if (container.getContainerTokens() !\u003d null) {\n         // TODO: Don\u0027t do this kind of checks everywhere.\n         dibb.reset(container.getContainerTokens());\n         credentials.readTokenStorageStream(dibb);\n       }\n \n       ApplicationTokenIdentifier id \u003d new ApplicationTokenIdentifier(\n           application.getAppAttemptId());\n-      Token\u003cApplicationTokenIdentifier\u003e token \u003d\n+      Token\u003cApplicationTokenIdentifier\u003e appMasterToken \u003d\n           new Token\u003cApplicationTokenIdentifier\u003e(id,\n               this.rmContext.getApplicationTokenSecretManager());\n       InetSocketAddress serviceAddr \u003d conf.getSocketAddr(\n           YarnConfiguration.RM_SCHEDULER_ADDRESS,\n           YarnConfiguration.DEFAULT_RM_SCHEDULER_ADDRESS,\n           YarnConfiguration.DEFAULT_RM_SCHEDULER_PORT);\n       // normally the client should set the service after acquiring the token,\n-      // but this token is directly provided to the tasks\n-      SecurityUtil.setTokenService(token, serviceAddr);\n-      String appMasterTokenEncoded \u003d token.encodeToUrlString();\n-      LOG.debug(\"Putting appMaster token in env : \" + token);\n-      environment.put(\n-          ApplicationConstants.APPLICATION_MASTER_TOKEN_ENV_NAME,\n-          appMasterTokenEncoded);\n+      // but this token is directly provided to the AMs\n+      SecurityUtil.setTokenService(appMasterToken, serviceAddr);\n \n-      // Add the RM token\n-      credentials.addToken(token.getService(), token);\n+      // Add the ApplicationMaster token\n+      credentials.addToken(appMasterToken.getService(), appMasterToken);\n       DataOutputBuffer dob \u003d new DataOutputBuffer();\n       credentials.writeTokenStorageToStream(dob);\n       container.setContainerTokens(\n           ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n \n       SecretKey clientSecretKey \u003d\n           this.rmContext.getClientToAMTokenSecretManager().getMasterKey(\n             application.getAppAttemptId());\n       String encoded \u003d\n           Base64.encodeBase64URLSafeString(clientSecretKey.getEncoded());\n       environment.put(\n           ApplicationConstants.APPLICATION_CLIENT_SECRET_ENV_NAME, \n           encoded);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void setupTokensAndEnv(\n      ContainerLaunchContext container, ContainerId containerID)\n      throws IOException {\n    Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n    environment.put(ApplicationConstants.APPLICATION_WEB_PROXY_BASE_ENV,\n        application.getWebProxyBase());\n    // Set AppSubmitTime and MaxAppAttempts to be consumable by the AM.\n    ApplicationId applicationId \u003d\n        application.getAppAttemptId().getApplicationId();\n    environment.put(\n        ApplicationConstants.APP_SUBMIT_TIME_ENV,\n        String.valueOf(rmContext.getRMApps()\n            .get(applicationId)\n            .getSubmitTime()));\n    environment.put(ApplicationConstants.MAX_APP_ATTEMPTS_ENV,\n        String.valueOf(rmContext.getRMApps().get(\n            applicationId).getMaxAppAttempts()));\n \n    if (UserGroupInformation.isSecurityEnabled()) {\n      // TODO: Security enabled/disabled info should come from RM.\n\n      Credentials credentials \u003d new Credentials();\n\n      DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n      if (container.getContainerTokens() !\u003d null) {\n        // TODO: Don\u0027t do this kind of checks everywhere.\n        dibb.reset(container.getContainerTokens());\n        credentials.readTokenStorageStream(dibb);\n      }\n\n      ApplicationTokenIdentifier id \u003d new ApplicationTokenIdentifier(\n          application.getAppAttemptId());\n      Token\u003cApplicationTokenIdentifier\u003e appMasterToken \u003d\n          new Token\u003cApplicationTokenIdentifier\u003e(id,\n              this.rmContext.getApplicationTokenSecretManager());\n      InetSocketAddress serviceAddr \u003d conf.getSocketAddr(\n          YarnConfiguration.RM_SCHEDULER_ADDRESS,\n          YarnConfiguration.DEFAULT_RM_SCHEDULER_ADDRESS,\n          YarnConfiguration.DEFAULT_RM_SCHEDULER_PORT);\n      // normally the client should set the service after acquiring the token,\n      // but this token is directly provided to the AMs\n      SecurityUtil.setTokenService(appMasterToken, serviceAddr);\n\n      // Add the ApplicationMaster token\n      credentials.addToken(appMasterToken.getService(), appMasterToken);\n      DataOutputBuffer dob \u003d new DataOutputBuffer();\n      credentials.writeTokenStorageToStream(dob);\n      container.setContainerTokens(\n          ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n\n      SecretKey clientSecretKey \u003d\n          this.rmContext.getClientToAMTokenSecretManager().getMasterKey(\n            application.getAppAttemptId());\n      String encoded \u003d\n          Base64.encodeBase64URLSafeString(clientSecretKey.getEncoded());\n      environment.put(\n          ApplicationConstants.APPLICATION_CLIENT_SECRET_ENV_NAME, \n          encoded);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/amlauncher/AMLauncher.java",
      "extendedDetails": {}
    },
    "27e8c86999bc6a972a99216060b11ef35b7de858": {
      "type": "Ybodychange",
      "commitMessage": "YARN-561. Modified NodeManager to set key information into the environment of every container that it launches. Contributed by Xuan Gong.\nMAPREDUCE-5175. Updated MR App to not set envs that will be set by NMs anyways after YARN-561. Contributed by Xuan Gong.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1471156 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/04/13 2:39 PM",
      "commitName": "27e8c86999bc6a972a99216060b11ef35b7de858",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "11/04/13 12:28 PM",
      "commitNameOld": "e4c55e17fea55e2fcbef182bb2b0c4b22686f38c",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 12.09,
      "commitsBetweenForRepo": 57,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,75 +1,65 @@\n   private void setupTokensAndEnv(\n       ContainerLaunchContext container, ContainerId containerID)\n       throws IOException {\n     Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n     environment.put(ApplicationConstants.APPLICATION_WEB_PROXY_BASE_ENV,\n         application.getWebProxyBase());\n-    // Set the AppAttemptId, containerId, NMHTTPAdress, AppSubmitTime to be\n-    // consumable by the AM.\n-    environment.put(ApplicationConstants.AM_CONTAINER_ID_ENV,\n-        containerID.toString());\n-    environment.put(ApplicationConstants.NM_HOST_ENV, masterContainer\n-        .getNodeId().getHost());\n-    environment.put(ApplicationConstants.NM_PORT_ENV,\n-        String.valueOf(masterContainer.getNodeId().getPort()));\n-    String parts[] \u003d\n-        masterContainer.getNodeHttpAddress().split(\":\");\n-    environment.put(ApplicationConstants.NM_HTTP_PORT_ENV, parts[1]);\n+    // Set AppSubmitTime and MaxAppAttempts to be consumable by the AM.\n     ApplicationId applicationId \u003d\n         application.getAppAttemptId().getApplicationId();\n     environment.put(\n         ApplicationConstants.APP_SUBMIT_TIME_ENV,\n         String.valueOf(rmContext.getRMApps()\n             .get(applicationId)\n             .getSubmitTime()));\n     environment.put(ApplicationConstants.MAX_APP_ATTEMPTS_ENV,\n         String.valueOf(rmContext.getRMApps().get(\n             applicationId).getMaxAppAttempts()));\n  \n     if (UserGroupInformation.isSecurityEnabled()) {\n       // TODO: Security enabled/disabled info should come from RM.\n \n       Credentials credentials \u003d new Credentials();\n \n       DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n       if (container.getContainerTokens() !\u003d null) {\n         // TODO: Don\u0027t do this kind of checks everywhere.\n         dibb.reset(container.getContainerTokens());\n         credentials.readTokenStorageStream(dibb);\n       }\n \n       ApplicationTokenIdentifier id \u003d new ApplicationTokenIdentifier(\n           application.getAppAttemptId());\n       Token\u003cApplicationTokenIdentifier\u003e token \u003d\n           new Token\u003cApplicationTokenIdentifier\u003e(id,\n               this.rmContext.getApplicationTokenSecretManager());\n       InetSocketAddress serviceAddr \u003d conf.getSocketAddr(\n           YarnConfiguration.RM_SCHEDULER_ADDRESS,\n           YarnConfiguration.DEFAULT_RM_SCHEDULER_ADDRESS,\n           YarnConfiguration.DEFAULT_RM_SCHEDULER_PORT);\n       // normally the client should set the service after acquiring the token,\n       // but this token is directly provided to the tasks\n       SecurityUtil.setTokenService(token, serviceAddr);\n       String appMasterTokenEncoded \u003d token.encodeToUrlString();\n       LOG.debug(\"Putting appMaster token in env : \" + token);\n       environment.put(\n           ApplicationConstants.APPLICATION_MASTER_TOKEN_ENV_NAME,\n           appMasterTokenEncoded);\n \n       // Add the RM token\n       credentials.addToken(token.getService(), token);\n       DataOutputBuffer dob \u003d new DataOutputBuffer();\n       credentials.writeTokenStorageToStream(dob);\n       container.setContainerTokens(\n           ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n \n       SecretKey clientSecretKey \u003d\n           this.rmContext.getClientToAMTokenSecretManager().getMasterKey(\n             application.getAppAttemptId());\n       String encoded \u003d\n           Base64.encodeBase64URLSafeString(clientSecretKey.getEncoded());\n       environment.put(\n           ApplicationConstants.APPLICATION_CLIENT_SECRET_ENV_NAME, \n           encoded);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void setupTokensAndEnv(\n      ContainerLaunchContext container, ContainerId containerID)\n      throws IOException {\n    Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n    environment.put(ApplicationConstants.APPLICATION_WEB_PROXY_BASE_ENV,\n        application.getWebProxyBase());\n    // Set AppSubmitTime and MaxAppAttempts to be consumable by the AM.\n    ApplicationId applicationId \u003d\n        application.getAppAttemptId().getApplicationId();\n    environment.put(\n        ApplicationConstants.APP_SUBMIT_TIME_ENV,\n        String.valueOf(rmContext.getRMApps()\n            .get(applicationId)\n            .getSubmitTime()));\n    environment.put(ApplicationConstants.MAX_APP_ATTEMPTS_ENV,\n        String.valueOf(rmContext.getRMApps().get(\n            applicationId).getMaxAppAttempts()));\n \n    if (UserGroupInformation.isSecurityEnabled()) {\n      // TODO: Security enabled/disabled info should come from RM.\n\n      Credentials credentials \u003d new Credentials();\n\n      DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n      if (container.getContainerTokens() !\u003d null) {\n        // TODO: Don\u0027t do this kind of checks everywhere.\n        dibb.reset(container.getContainerTokens());\n        credentials.readTokenStorageStream(dibb);\n      }\n\n      ApplicationTokenIdentifier id \u003d new ApplicationTokenIdentifier(\n          application.getAppAttemptId());\n      Token\u003cApplicationTokenIdentifier\u003e token \u003d\n          new Token\u003cApplicationTokenIdentifier\u003e(id,\n              this.rmContext.getApplicationTokenSecretManager());\n      InetSocketAddress serviceAddr \u003d conf.getSocketAddr(\n          YarnConfiguration.RM_SCHEDULER_ADDRESS,\n          YarnConfiguration.DEFAULT_RM_SCHEDULER_ADDRESS,\n          YarnConfiguration.DEFAULT_RM_SCHEDULER_PORT);\n      // normally the client should set the service after acquiring the token,\n      // but this token is directly provided to the tasks\n      SecurityUtil.setTokenService(token, serviceAddr);\n      String appMasterTokenEncoded \u003d token.encodeToUrlString();\n      LOG.debug(\"Putting appMaster token in env : \" + token);\n      environment.put(\n          ApplicationConstants.APPLICATION_MASTER_TOKEN_ENV_NAME,\n          appMasterTokenEncoded);\n\n      // Add the RM token\n      credentials.addToken(token.getService(), token);\n      DataOutputBuffer dob \u003d new DataOutputBuffer();\n      credentials.writeTokenStorageToStream(dob);\n      container.setContainerTokens(\n          ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n\n      SecretKey clientSecretKey \u003d\n          this.rmContext.getClientToAMTokenSecretManager().getMasterKey(\n            application.getAppAttemptId());\n      String encoded \u003d\n          Base64.encodeBase64URLSafeString(clientSecretKey.getEncoded());\n      environment.put(\n          ApplicationConstants.APPLICATION_CLIENT_SECRET_ENV_NAME, \n          encoded);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/amlauncher/AMLauncher.java",
      "extendedDetails": {}
    },
    "e4c55e17fea55e2fcbef182bb2b0c4b22686f38c": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-486. Changed NM\u0027s startContainer API to accept Container record given by RM as a direct parameter instead of as part of the ContainerLaunchContext record. Contributed by Xuan Gong.\nMAPREDUCE-5139. Update MR AM to use the modified startContainer API after YARN-486. Contributed by Xuan Gong.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1467063 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/04/13 12:28 PM",
      "commitName": "e4c55e17fea55e2fcbef182bb2b0c4b22686f38c",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-486. Changed NM\u0027s startContainer API to accept Container record given by RM as a direct parameter instead of as part of the ContainerLaunchContext record. Contributed by Xuan Gong.\nMAPREDUCE-5139. Update MR AM to use the modified startContainer API after YARN-486. Contributed by Xuan Gong.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1467063 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "11/04/13 12:28 PM",
          "commitName": "e4c55e17fea55e2fcbef182bb2b0c4b22686f38c",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "25/03/13 2:11 PM",
          "commitNameOld": "07573640147bb4cf3568078acae7b245e9299cf7",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 16.93,
          "commitsBetweenForRepo": 96,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,76 +1,75 @@\n   private void setupTokensAndEnv(\n-      ContainerLaunchContext container)\n+      ContainerLaunchContext container, ContainerId containerID)\n       throws IOException {\n     Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n-\n     environment.put(ApplicationConstants.APPLICATION_WEB_PROXY_BASE_ENV,\n         application.getWebProxyBase());\n     // Set the AppAttemptId, containerId, NMHTTPAdress, AppSubmitTime to be\n     // consumable by the AM.\n-    environment.put(ApplicationConstants.AM_CONTAINER_ID_ENV, container\n-        .getContainerId().toString());\n-    environment.put(ApplicationConstants.NM_HOST_ENV, application\n-        .getMasterContainer().getNodeId().getHost());\n+    environment.put(ApplicationConstants.AM_CONTAINER_ID_ENV,\n+        containerID.toString());\n+    environment.put(ApplicationConstants.NM_HOST_ENV, masterContainer\n+        .getNodeId().getHost());\n     environment.put(ApplicationConstants.NM_PORT_ENV,\n-        String.valueOf(application.getMasterContainer().getNodeId().getPort()));\n+        String.valueOf(masterContainer.getNodeId().getPort()));\n     String parts[] \u003d\n-        application.getMasterContainer().getNodeHttpAddress().split(\":\");\n+        masterContainer.getNodeHttpAddress().split(\":\");\n     environment.put(ApplicationConstants.NM_HTTP_PORT_ENV, parts[1]);\n     ApplicationId applicationId \u003d\n         application.getAppAttemptId().getApplicationId();\n     environment.put(\n         ApplicationConstants.APP_SUBMIT_TIME_ENV,\n         String.valueOf(rmContext.getRMApps()\n             .get(applicationId)\n             .getSubmitTime()));\n     environment.put(ApplicationConstants.MAX_APP_ATTEMPTS_ENV,\n         String.valueOf(rmContext.getRMApps().get(\n             applicationId).getMaxAppAttempts()));\n  \n     if (UserGroupInformation.isSecurityEnabled()) {\n       // TODO: Security enabled/disabled info should come from RM.\n \n       Credentials credentials \u003d new Credentials();\n \n       DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n       if (container.getContainerTokens() !\u003d null) {\n         // TODO: Don\u0027t do this kind of checks everywhere.\n         dibb.reset(container.getContainerTokens());\n         credentials.readTokenStorageStream(dibb);\n       }\n \n       ApplicationTokenIdentifier id \u003d new ApplicationTokenIdentifier(\n           application.getAppAttemptId());\n       Token\u003cApplicationTokenIdentifier\u003e token \u003d\n           new Token\u003cApplicationTokenIdentifier\u003e(id,\n               this.rmContext.getApplicationTokenSecretManager());\n       InetSocketAddress serviceAddr \u003d conf.getSocketAddr(\n           YarnConfiguration.RM_SCHEDULER_ADDRESS,\n           YarnConfiguration.DEFAULT_RM_SCHEDULER_ADDRESS,\n           YarnConfiguration.DEFAULT_RM_SCHEDULER_PORT);\n       // normally the client should set the service after acquiring the token,\n       // but this token is directly provided to the tasks\n       SecurityUtil.setTokenService(token, serviceAddr);\n       String appMasterTokenEncoded \u003d token.encodeToUrlString();\n       LOG.debug(\"Putting appMaster token in env : \" + token);\n       environment.put(\n           ApplicationConstants.APPLICATION_MASTER_TOKEN_ENV_NAME,\n           appMasterTokenEncoded);\n \n       // Add the RM token\n       credentials.addToken(token.getService(), token);\n       DataOutputBuffer dob \u003d new DataOutputBuffer();\n       credentials.writeTokenStorageToStream(dob);\n       container.setContainerTokens(\n           ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n \n       SecretKey clientSecretKey \u003d\n           this.rmContext.getClientToAMTokenSecretManager().getMasterKey(\n             application.getAppAttemptId());\n       String encoded \u003d\n           Base64.encodeBase64URLSafeString(clientSecretKey.getEncoded());\n       environment.put(\n           ApplicationConstants.APPLICATION_CLIENT_SECRET_ENV_NAME, \n           encoded);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void setupTokensAndEnv(\n      ContainerLaunchContext container, ContainerId containerID)\n      throws IOException {\n    Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n    environment.put(ApplicationConstants.APPLICATION_WEB_PROXY_BASE_ENV,\n        application.getWebProxyBase());\n    // Set the AppAttemptId, containerId, NMHTTPAdress, AppSubmitTime to be\n    // consumable by the AM.\n    environment.put(ApplicationConstants.AM_CONTAINER_ID_ENV,\n        containerID.toString());\n    environment.put(ApplicationConstants.NM_HOST_ENV, masterContainer\n        .getNodeId().getHost());\n    environment.put(ApplicationConstants.NM_PORT_ENV,\n        String.valueOf(masterContainer.getNodeId().getPort()));\n    String parts[] \u003d\n        masterContainer.getNodeHttpAddress().split(\":\");\n    environment.put(ApplicationConstants.NM_HTTP_PORT_ENV, parts[1]);\n    ApplicationId applicationId \u003d\n        application.getAppAttemptId().getApplicationId();\n    environment.put(\n        ApplicationConstants.APP_SUBMIT_TIME_ENV,\n        String.valueOf(rmContext.getRMApps()\n            .get(applicationId)\n            .getSubmitTime()));\n    environment.put(ApplicationConstants.MAX_APP_ATTEMPTS_ENV,\n        String.valueOf(rmContext.getRMApps().get(\n            applicationId).getMaxAppAttempts()));\n \n    if (UserGroupInformation.isSecurityEnabled()) {\n      // TODO: Security enabled/disabled info should come from RM.\n\n      Credentials credentials \u003d new Credentials();\n\n      DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n      if (container.getContainerTokens() !\u003d null) {\n        // TODO: Don\u0027t do this kind of checks everywhere.\n        dibb.reset(container.getContainerTokens());\n        credentials.readTokenStorageStream(dibb);\n      }\n\n      ApplicationTokenIdentifier id \u003d new ApplicationTokenIdentifier(\n          application.getAppAttemptId());\n      Token\u003cApplicationTokenIdentifier\u003e token \u003d\n          new Token\u003cApplicationTokenIdentifier\u003e(id,\n              this.rmContext.getApplicationTokenSecretManager());\n      InetSocketAddress serviceAddr \u003d conf.getSocketAddr(\n          YarnConfiguration.RM_SCHEDULER_ADDRESS,\n          YarnConfiguration.DEFAULT_RM_SCHEDULER_ADDRESS,\n          YarnConfiguration.DEFAULT_RM_SCHEDULER_PORT);\n      // normally the client should set the service after acquiring the token,\n      // but this token is directly provided to the tasks\n      SecurityUtil.setTokenService(token, serviceAddr);\n      String appMasterTokenEncoded \u003d token.encodeToUrlString();\n      LOG.debug(\"Putting appMaster token in env : \" + token);\n      environment.put(\n          ApplicationConstants.APPLICATION_MASTER_TOKEN_ENV_NAME,\n          appMasterTokenEncoded);\n\n      // Add the RM token\n      credentials.addToken(token.getService(), token);\n      DataOutputBuffer dob \u003d new DataOutputBuffer();\n      credentials.writeTokenStorageToStream(dob);\n      container.setContainerTokens(\n          ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n\n      SecretKey clientSecretKey \u003d\n          this.rmContext.getClientToAMTokenSecretManager().getMasterKey(\n            application.getAppAttemptId());\n      String encoded \u003d\n          Base64.encodeBase64URLSafeString(clientSecretKey.getEncoded());\n      environment.put(\n          ApplicationConstants.APPLICATION_CLIENT_SECRET_ENV_NAME, \n          encoded);\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/amlauncher/AMLauncher.java",
          "extendedDetails": {
            "oldValue": "[container-ContainerLaunchContext]",
            "newValue": "[container-ContainerLaunchContext, containerID-ContainerId]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-486. Changed NM\u0027s startContainer API to accept Container record given by RM as a direct parameter instead of as part of the ContainerLaunchContext record. Contributed by Xuan Gong.\nMAPREDUCE-5139. Update MR AM to use the modified startContainer API after YARN-486. Contributed by Xuan Gong.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1467063 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "11/04/13 12:28 PM",
          "commitName": "e4c55e17fea55e2fcbef182bb2b0c4b22686f38c",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "25/03/13 2:11 PM",
          "commitNameOld": "07573640147bb4cf3568078acae7b245e9299cf7",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 16.93,
          "commitsBetweenForRepo": 96,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,76 +1,75 @@\n   private void setupTokensAndEnv(\n-      ContainerLaunchContext container)\n+      ContainerLaunchContext container, ContainerId containerID)\n       throws IOException {\n     Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n-\n     environment.put(ApplicationConstants.APPLICATION_WEB_PROXY_BASE_ENV,\n         application.getWebProxyBase());\n     // Set the AppAttemptId, containerId, NMHTTPAdress, AppSubmitTime to be\n     // consumable by the AM.\n-    environment.put(ApplicationConstants.AM_CONTAINER_ID_ENV, container\n-        .getContainerId().toString());\n-    environment.put(ApplicationConstants.NM_HOST_ENV, application\n-        .getMasterContainer().getNodeId().getHost());\n+    environment.put(ApplicationConstants.AM_CONTAINER_ID_ENV,\n+        containerID.toString());\n+    environment.put(ApplicationConstants.NM_HOST_ENV, masterContainer\n+        .getNodeId().getHost());\n     environment.put(ApplicationConstants.NM_PORT_ENV,\n-        String.valueOf(application.getMasterContainer().getNodeId().getPort()));\n+        String.valueOf(masterContainer.getNodeId().getPort()));\n     String parts[] \u003d\n-        application.getMasterContainer().getNodeHttpAddress().split(\":\");\n+        masterContainer.getNodeHttpAddress().split(\":\");\n     environment.put(ApplicationConstants.NM_HTTP_PORT_ENV, parts[1]);\n     ApplicationId applicationId \u003d\n         application.getAppAttemptId().getApplicationId();\n     environment.put(\n         ApplicationConstants.APP_SUBMIT_TIME_ENV,\n         String.valueOf(rmContext.getRMApps()\n             .get(applicationId)\n             .getSubmitTime()));\n     environment.put(ApplicationConstants.MAX_APP_ATTEMPTS_ENV,\n         String.valueOf(rmContext.getRMApps().get(\n             applicationId).getMaxAppAttempts()));\n  \n     if (UserGroupInformation.isSecurityEnabled()) {\n       // TODO: Security enabled/disabled info should come from RM.\n \n       Credentials credentials \u003d new Credentials();\n \n       DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n       if (container.getContainerTokens() !\u003d null) {\n         // TODO: Don\u0027t do this kind of checks everywhere.\n         dibb.reset(container.getContainerTokens());\n         credentials.readTokenStorageStream(dibb);\n       }\n \n       ApplicationTokenIdentifier id \u003d new ApplicationTokenIdentifier(\n           application.getAppAttemptId());\n       Token\u003cApplicationTokenIdentifier\u003e token \u003d\n           new Token\u003cApplicationTokenIdentifier\u003e(id,\n               this.rmContext.getApplicationTokenSecretManager());\n       InetSocketAddress serviceAddr \u003d conf.getSocketAddr(\n           YarnConfiguration.RM_SCHEDULER_ADDRESS,\n           YarnConfiguration.DEFAULT_RM_SCHEDULER_ADDRESS,\n           YarnConfiguration.DEFAULT_RM_SCHEDULER_PORT);\n       // normally the client should set the service after acquiring the token,\n       // but this token is directly provided to the tasks\n       SecurityUtil.setTokenService(token, serviceAddr);\n       String appMasterTokenEncoded \u003d token.encodeToUrlString();\n       LOG.debug(\"Putting appMaster token in env : \" + token);\n       environment.put(\n           ApplicationConstants.APPLICATION_MASTER_TOKEN_ENV_NAME,\n           appMasterTokenEncoded);\n \n       // Add the RM token\n       credentials.addToken(token.getService(), token);\n       DataOutputBuffer dob \u003d new DataOutputBuffer();\n       credentials.writeTokenStorageToStream(dob);\n       container.setContainerTokens(\n           ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n \n       SecretKey clientSecretKey \u003d\n           this.rmContext.getClientToAMTokenSecretManager().getMasterKey(\n             application.getAppAttemptId());\n       String encoded \u003d\n           Base64.encodeBase64URLSafeString(clientSecretKey.getEncoded());\n       environment.put(\n           ApplicationConstants.APPLICATION_CLIENT_SECRET_ENV_NAME, \n           encoded);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void setupTokensAndEnv(\n      ContainerLaunchContext container, ContainerId containerID)\n      throws IOException {\n    Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n    environment.put(ApplicationConstants.APPLICATION_WEB_PROXY_BASE_ENV,\n        application.getWebProxyBase());\n    // Set the AppAttemptId, containerId, NMHTTPAdress, AppSubmitTime to be\n    // consumable by the AM.\n    environment.put(ApplicationConstants.AM_CONTAINER_ID_ENV,\n        containerID.toString());\n    environment.put(ApplicationConstants.NM_HOST_ENV, masterContainer\n        .getNodeId().getHost());\n    environment.put(ApplicationConstants.NM_PORT_ENV,\n        String.valueOf(masterContainer.getNodeId().getPort()));\n    String parts[] \u003d\n        masterContainer.getNodeHttpAddress().split(\":\");\n    environment.put(ApplicationConstants.NM_HTTP_PORT_ENV, parts[1]);\n    ApplicationId applicationId \u003d\n        application.getAppAttemptId().getApplicationId();\n    environment.put(\n        ApplicationConstants.APP_SUBMIT_TIME_ENV,\n        String.valueOf(rmContext.getRMApps()\n            .get(applicationId)\n            .getSubmitTime()));\n    environment.put(ApplicationConstants.MAX_APP_ATTEMPTS_ENV,\n        String.valueOf(rmContext.getRMApps().get(\n            applicationId).getMaxAppAttempts()));\n \n    if (UserGroupInformation.isSecurityEnabled()) {\n      // TODO: Security enabled/disabled info should come from RM.\n\n      Credentials credentials \u003d new Credentials();\n\n      DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n      if (container.getContainerTokens() !\u003d null) {\n        // TODO: Don\u0027t do this kind of checks everywhere.\n        dibb.reset(container.getContainerTokens());\n        credentials.readTokenStorageStream(dibb);\n      }\n\n      ApplicationTokenIdentifier id \u003d new ApplicationTokenIdentifier(\n          application.getAppAttemptId());\n      Token\u003cApplicationTokenIdentifier\u003e token \u003d\n          new Token\u003cApplicationTokenIdentifier\u003e(id,\n              this.rmContext.getApplicationTokenSecretManager());\n      InetSocketAddress serviceAddr \u003d conf.getSocketAddr(\n          YarnConfiguration.RM_SCHEDULER_ADDRESS,\n          YarnConfiguration.DEFAULT_RM_SCHEDULER_ADDRESS,\n          YarnConfiguration.DEFAULT_RM_SCHEDULER_PORT);\n      // normally the client should set the service after acquiring the token,\n      // but this token is directly provided to the tasks\n      SecurityUtil.setTokenService(token, serviceAddr);\n      String appMasterTokenEncoded \u003d token.encodeToUrlString();\n      LOG.debug(\"Putting appMaster token in env : \" + token);\n      environment.put(\n          ApplicationConstants.APPLICATION_MASTER_TOKEN_ENV_NAME,\n          appMasterTokenEncoded);\n\n      // Add the RM token\n      credentials.addToken(token.getService(), token);\n      DataOutputBuffer dob \u003d new DataOutputBuffer();\n      credentials.writeTokenStorageToStream(dob);\n      container.setContainerTokens(\n          ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n\n      SecretKey clientSecretKey \u003d\n          this.rmContext.getClientToAMTokenSecretManager().getMasterKey(\n            application.getAppAttemptId());\n      String encoded \u003d\n          Base64.encodeBase64URLSafeString(clientSecretKey.getEncoded());\n      environment.put(\n          ApplicationConstants.APPLICATION_CLIENT_SECRET_ENV_NAME, \n          encoded);\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/amlauncher/AMLauncher.java",
          "extendedDetails": {}
        }
      ]
    },
    "07573640147bb4cf3568078acae7b245e9299cf7": {
      "type": "Ybodychange",
      "commitMessage": "YARN-378. Fix RM to make the AM max attempts/retries to be configurable per application by clients. Contributed by Zhijie Shen.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1460895 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/03/13 2:11 PM",
      "commitName": "07573640147bb4cf3568078acae7b245e9299cf7",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "15/01/13 10:33 AM",
      "commitNameOld": "6a2f2551fd13f6d3c932cc9b592e2a23b616a7f5",
      "commitAuthorOld": "Siddharth Seth",
      "daysBetweenCommits": 69.11,
      "commitsBetweenForRepo": 308,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,73 +1,76 @@\n   private void setupTokensAndEnv(\n       ContainerLaunchContext container)\n       throws IOException {\n     Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n \n     environment.put(ApplicationConstants.APPLICATION_WEB_PROXY_BASE_ENV,\n         application.getWebProxyBase());\n     // Set the AppAttemptId, containerId, NMHTTPAdress, AppSubmitTime to be\n     // consumable by the AM.\n     environment.put(ApplicationConstants.AM_CONTAINER_ID_ENV, container\n         .getContainerId().toString());\n     environment.put(ApplicationConstants.NM_HOST_ENV, application\n         .getMasterContainer().getNodeId().getHost());\n     environment.put(ApplicationConstants.NM_PORT_ENV,\n         String.valueOf(application.getMasterContainer().getNodeId().getPort()));\n     String parts[] \u003d\n         application.getMasterContainer().getNodeHttpAddress().split(\":\");\n     environment.put(ApplicationConstants.NM_HTTP_PORT_ENV, parts[1]);\n     ApplicationId applicationId \u003d\n         application.getAppAttemptId().getApplicationId();\n     environment.put(\n         ApplicationConstants.APP_SUBMIT_TIME_ENV,\n         String.valueOf(rmContext.getRMApps()\n             .get(applicationId)\n             .getSubmitTime()));\n+    environment.put(ApplicationConstants.MAX_APP_ATTEMPTS_ENV,\n+        String.valueOf(rmContext.getRMApps().get(\n+            applicationId).getMaxAppAttempts()));\n  \n     if (UserGroupInformation.isSecurityEnabled()) {\n       // TODO: Security enabled/disabled info should come from RM.\n \n       Credentials credentials \u003d new Credentials();\n \n       DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n       if (container.getContainerTokens() !\u003d null) {\n         // TODO: Don\u0027t do this kind of checks everywhere.\n         dibb.reset(container.getContainerTokens());\n         credentials.readTokenStorageStream(dibb);\n       }\n \n       ApplicationTokenIdentifier id \u003d new ApplicationTokenIdentifier(\n           application.getAppAttemptId());\n       Token\u003cApplicationTokenIdentifier\u003e token \u003d\n           new Token\u003cApplicationTokenIdentifier\u003e(id,\n               this.rmContext.getApplicationTokenSecretManager());\n       InetSocketAddress serviceAddr \u003d conf.getSocketAddr(\n           YarnConfiguration.RM_SCHEDULER_ADDRESS,\n           YarnConfiguration.DEFAULT_RM_SCHEDULER_ADDRESS,\n           YarnConfiguration.DEFAULT_RM_SCHEDULER_PORT);\n       // normally the client should set the service after acquiring the token,\n       // but this token is directly provided to the tasks\n       SecurityUtil.setTokenService(token, serviceAddr);\n       String appMasterTokenEncoded \u003d token.encodeToUrlString();\n       LOG.debug(\"Putting appMaster token in env : \" + token);\n       environment.put(\n           ApplicationConstants.APPLICATION_MASTER_TOKEN_ENV_NAME,\n           appMasterTokenEncoded);\n \n       // Add the RM token\n       credentials.addToken(token.getService(), token);\n       DataOutputBuffer dob \u003d new DataOutputBuffer();\n       credentials.writeTokenStorageToStream(dob);\n       container.setContainerTokens(\n           ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n \n       SecretKey clientSecretKey \u003d\n           this.rmContext.getClientToAMTokenSecretManager().getMasterKey(\n             application.getAppAttemptId());\n       String encoded \u003d\n           Base64.encodeBase64URLSafeString(clientSecretKey.getEncoded());\n       environment.put(\n           ApplicationConstants.APPLICATION_CLIENT_SECRET_ENV_NAME, \n           encoded);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void setupTokensAndEnv(\n      ContainerLaunchContext container)\n      throws IOException {\n    Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n\n    environment.put(ApplicationConstants.APPLICATION_WEB_PROXY_BASE_ENV,\n        application.getWebProxyBase());\n    // Set the AppAttemptId, containerId, NMHTTPAdress, AppSubmitTime to be\n    // consumable by the AM.\n    environment.put(ApplicationConstants.AM_CONTAINER_ID_ENV, container\n        .getContainerId().toString());\n    environment.put(ApplicationConstants.NM_HOST_ENV, application\n        .getMasterContainer().getNodeId().getHost());\n    environment.put(ApplicationConstants.NM_PORT_ENV,\n        String.valueOf(application.getMasterContainer().getNodeId().getPort()));\n    String parts[] \u003d\n        application.getMasterContainer().getNodeHttpAddress().split(\":\");\n    environment.put(ApplicationConstants.NM_HTTP_PORT_ENV, parts[1]);\n    ApplicationId applicationId \u003d\n        application.getAppAttemptId().getApplicationId();\n    environment.put(\n        ApplicationConstants.APP_SUBMIT_TIME_ENV,\n        String.valueOf(rmContext.getRMApps()\n            .get(applicationId)\n            .getSubmitTime()));\n    environment.put(ApplicationConstants.MAX_APP_ATTEMPTS_ENV,\n        String.valueOf(rmContext.getRMApps().get(\n            applicationId).getMaxAppAttempts()));\n \n    if (UserGroupInformation.isSecurityEnabled()) {\n      // TODO: Security enabled/disabled info should come from RM.\n\n      Credentials credentials \u003d new Credentials();\n\n      DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n      if (container.getContainerTokens() !\u003d null) {\n        // TODO: Don\u0027t do this kind of checks everywhere.\n        dibb.reset(container.getContainerTokens());\n        credentials.readTokenStorageStream(dibb);\n      }\n\n      ApplicationTokenIdentifier id \u003d new ApplicationTokenIdentifier(\n          application.getAppAttemptId());\n      Token\u003cApplicationTokenIdentifier\u003e token \u003d\n          new Token\u003cApplicationTokenIdentifier\u003e(id,\n              this.rmContext.getApplicationTokenSecretManager());\n      InetSocketAddress serviceAddr \u003d conf.getSocketAddr(\n          YarnConfiguration.RM_SCHEDULER_ADDRESS,\n          YarnConfiguration.DEFAULT_RM_SCHEDULER_ADDRESS,\n          YarnConfiguration.DEFAULT_RM_SCHEDULER_PORT);\n      // normally the client should set the service after acquiring the token,\n      // but this token is directly provided to the tasks\n      SecurityUtil.setTokenService(token, serviceAddr);\n      String appMasterTokenEncoded \u003d token.encodeToUrlString();\n      LOG.debug(\"Putting appMaster token in env : \" + token);\n      environment.put(\n          ApplicationConstants.APPLICATION_MASTER_TOKEN_ENV_NAME,\n          appMasterTokenEncoded);\n\n      // Add the RM token\n      credentials.addToken(token.getService(), token);\n      DataOutputBuffer dob \u003d new DataOutputBuffer();\n      credentials.writeTokenStorageToStream(dob);\n      container.setContainerTokens(\n          ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n\n      SecretKey clientSecretKey \u003d\n          this.rmContext.getClientToAMTokenSecretManager().getMasterKey(\n            application.getAppAttemptId());\n      String encoded \u003d\n          Base64.encodeBase64URLSafeString(clientSecretKey.getEncoded());\n      environment.put(\n          ApplicationConstants.APPLICATION_CLIENT_SECRET_ENV_NAME, \n          encoded);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/amlauncher/AMLauncher.java",
      "extendedDetails": {}
    },
    "6a2f2551fd13f6d3c932cc9b592e2a23b616a7f5": {
      "type": "Ybodychange",
      "commitMessage": "YARN-135. Client tokens should be per app-attempt, and should be unregistered on App-finish. Contributed by Vinod Kumar Vavilapalli\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1433570 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "15/01/13 10:33 AM",
      "commitName": "6a2f2551fd13f6d3c932cc9b592e2a23b616a7f5",
      "commitAuthor": "Siddharth Seth",
      "commitDateOld": "19/10/12 1:37 PM",
      "commitNameOld": "f79ae9141422dc4b2211ad3ca60bb79c3d266cb3",
      "commitAuthorOld": "Siddharth Seth",
      "daysBetweenCommits": 87.91,
      "commitsBetweenForRepo": 405,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,73 +1,73 @@\n   private void setupTokensAndEnv(\n       ContainerLaunchContext container)\n       throws IOException {\n     Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n \n     environment.put(ApplicationConstants.APPLICATION_WEB_PROXY_BASE_ENV,\n         application.getWebProxyBase());\n     // Set the AppAttemptId, containerId, NMHTTPAdress, AppSubmitTime to be\n     // consumable by the AM.\n     environment.put(ApplicationConstants.AM_CONTAINER_ID_ENV, container\n         .getContainerId().toString());\n     environment.put(ApplicationConstants.NM_HOST_ENV, application\n         .getMasterContainer().getNodeId().getHost());\n     environment.put(ApplicationConstants.NM_PORT_ENV,\n         String.valueOf(application.getMasterContainer().getNodeId().getPort()));\n     String parts[] \u003d\n         application.getMasterContainer().getNodeHttpAddress().split(\":\");\n     environment.put(ApplicationConstants.NM_HTTP_PORT_ENV, parts[1]);\n     ApplicationId applicationId \u003d\n         application.getAppAttemptId().getApplicationId();\n     environment.put(\n         ApplicationConstants.APP_SUBMIT_TIME_ENV,\n         String.valueOf(rmContext.getRMApps()\n             .get(applicationId)\n             .getSubmitTime()));\n  \n     if (UserGroupInformation.isSecurityEnabled()) {\n       // TODO: Security enabled/disabled info should come from RM.\n \n       Credentials credentials \u003d new Credentials();\n \n       DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n       if (container.getContainerTokens() !\u003d null) {\n         // TODO: Don\u0027t do this kind of checks everywhere.\n         dibb.reset(container.getContainerTokens());\n         credentials.readTokenStorageStream(dibb);\n       }\n \n       ApplicationTokenIdentifier id \u003d new ApplicationTokenIdentifier(\n           application.getAppAttemptId());\n       Token\u003cApplicationTokenIdentifier\u003e token \u003d\n           new Token\u003cApplicationTokenIdentifier\u003e(id,\n               this.rmContext.getApplicationTokenSecretManager());\n       InetSocketAddress serviceAddr \u003d conf.getSocketAddr(\n           YarnConfiguration.RM_SCHEDULER_ADDRESS,\n           YarnConfiguration.DEFAULT_RM_SCHEDULER_ADDRESS,\n           YarnConfiguration.DEFAULT_RM_SCHEDULER_PORT);\n       // normally the client should set the service after acquiring the token,\n       // but this token is directly provided to the tasks\n       SecurityUtil.setTokenService(token, serviceAddr);\n       String appMasterTokenEncoded \u003d token.encodeToUrlString();\n       LOG.debug(\"Putting appMaster token in env : \" + token);\n       environment.put(\n           ApplicationConstants.APPLICATION_MASTER_TOKEN_ENV_NAME,\n           appMasterTokenEncoded);\n \n       // Add the RM token\n       credentials.addToken(token.getService(), token);\n       DataOutputBuffer dob \u003d new DataOutputBuffer();\n       credentials.writeTokenStorageToStream(dob);\n       container.setContainerTokens(\n           ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n \n       SecretKey clientSecretKey \u003d\n           this.rmContext.getClientToAMTokenSecretManager().getMasterKey(\n-            applicationId);\n+            application.getAppAttemptId());\n       String encoded \u003d\n           Base64.encodeBase64URLSafeString(clientSecretKey.getEncoded());\n       environment.put(\n           ApplicationConstants.APPLICATION_CLIENT_SECRET_ENV_NAME, \n           encoded);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void setupTokensAndEnv(\n      ContainerLaunchContext container)\n      throws IOException {\n    Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n\n    environment.put(ApplicationConstants.APPLICATION_WEB_PROXY_BASE_ENV,\n        application.getWebProxyBase());\n    // Set the AppAttemptId, containerId, NMHTTPAdress, AppSubmitTime to be\n    // consumable by the AM.\n    environment.put(ApplicationConstants.AM_CONTAINER_ID_ENV, container\n        .getContainerId().toString());\n    environment.put(ApplicationConstants.NM_HOST_ENV, application\n        .getMasterContainer().getNodeId().getHost());\n    environment.put(ApplicationConstants.NM_PORT_ENV,\n        String.valueOf(application.getMasterContainer().getNodeId().getPort()));\n    String parts[] \u003d\n        application.getMasterContainer().getNodeHttpAddress().split(\":\");\n    environment.put(ApplicationConstants.NM_HTTP_PORT_ENV, parts[1]);\n    ApplicationId applicationId \u003d\n        application.getAppAttemptId().getApplicationId();\n    environment.put(\n        ApplicationConstants.APP_SUBMIT_TIME_ENV,\n        String.valueOf(rmContext.getRMApps()\n            .get(applicationId)\n            .getSubmitTime()));\n \n    if (UserGroupInformation.isSecurityEnabled()) {\n      // TODO: Security enabled/disabled info should come from RM.\n\n      Credentials credentials \u003d new Credentials();\n\n      DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n      if (container.getContainerTokens() !\u003d null) {\n        // TODO: Don\u0027t do this kind of checks everywhere.\n        dibb.reset(container.getContainerTokens());\n        credentials.readTokenStorageStream(dibb);\n      }\n\n      ApplicationTokenIdentifier id \u003d new ApplicationTokenIdentifier(\n          application.getAppAttemptId());\n      Token\u003cApplicationTokenIdentifier\u003e token \u003d\n          new Token\u003cApplicationTokenIdentifier\u003e(id,\n              this.rmContext.getApplicationTokenSecretManager());\n      InetSocketAddress serviceAddr \u003d conf.getSocketAddr(\n          YarnConfiguration.RM_SCHEDULER_ADDRESS,\n          YarnConfiguration.DEFAULT_RM_SCHEDULER_ADDRESS,\n          YarnConfiguration.DEFAULT_RM_SCHEDULER_PORT);\n      // normally the client should set the service after acquiring the token,\n      // but this token is directly provided to the tasks\n      SecurityUtil.setTokenService(token, serviceAddr);\n      String appMasterTokenEncoded \u003d token.encodeToUrlString();\n      LOG.debug(\"Putting appMaster token in env : \" + token);\n      environment.put(\n          ApplicationConstants.APPLICATION_MASTER_TOKEN_ENV_NAME,\n          appMasterTokenEncoded);\n\n      // Add the RM token\n      credentials.addToken(token.getService(), token);\n      DataOutputBuffer dob \u003d new DataOutputBuffer();\n      credentials.writeTokenStorageToStream(dob);\n      container.setContainerTokens(\n          ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n\n      SecretKey clientSecretKey \u003d\n          this.rmContext.getClientToAMTokenSecretManager().getMasterKey(\n            application.getAppAttemptId());\n      String encoded \u003d\n          Base64.encodeBase64URLSafeString(clientSecretKey.getEncoded());\n      environment.put(\n          ApplicationConstants.APPLICATION_CLIENT_SECRET_ENV_NAME, \n          encoded);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/amlauncher/AMLauncher.java",
      "extendedDetails": {}
    },
    "f79ae9141422dc4b2211ad3ca60bb79c3d266cb3": {
      "type": "Ybodychange",
      "commitMessage": "YARN-136. Make ClientToAMTokenSecretManager part of RMContext (Contributed by Vinod Kumar Vavilapalli)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1400278 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/10/12 1:37 PM",
      "commitName": "f79ae9141422dc4b2211ad3ca60bb79c3d266cb3",
      "commitAuthor": "Siddharth Seth",
      "commitDateOld": "08/10/12 6:56 PM",
      "commitNameOld": "c074cfd6f0ec695d85a73cddba1404c9db79342e",
      "commitAuthorOld": "Siddharth Seth",
      "daysBetweenCommits": 10.78,
      "commitsBetweenForRepo": 71,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,72 +1,73 @@\n   private void setupTokensAndEnv(\n       ContainerLaunchContext container)\n       throws IOException {\n     Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n \n     environment.put(ApplicationConstants.APPLICATION_WEB_PROXY_BASE_ENV,\n         application.getWebProxyBase());\n     // Set the AppAttemptId, containerId, NMHTTPAdress, AppSubmitTime to be\n     // consumable by the AM.\n     environment.put(ApplicationConstants.AM_CONTAINER_ID_ENV, container\n         .getContainerId().toString());\n     environment.put(ApplicationConstants.NM_HOST_ENV, application\n         .getMasterContainer().getNodeId().getHost());\n     environment.put(ApplicationConstants.NM_PORT_ENV,\n         String.valueOf(application.getMasterContainer().getNodeId().getPort()));\n     String parts[] \u003d\n         application.getMasterContainer().getNodeHttpAddress().split(\":\");\n     environment.put(ApplicationConstants.NM_HTTP_PORT_ENV, parts[1]);\n     ApplicationId applicationId \u003d\n         application.getAppAttemptId().getApplicationId();\n     environment.put(\n         ApplicationConstants.APP_SUBMIT_TIME_ENV,\n         String.valueOf(rmContext.getRMApps()\n             .get(applicationId)\n             .getSubmitTime()));\n  \n     if (UserGroupInformation.isSecurityEnabled()) {\n       // TODO: Security enabled/disabled info should come from RM.\n \n       Credentials credentials \u003d new Credentials();\n \n       DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n       if (container.getContainerTokens() !\u003d null) {\n         // TODO: Don\u0027t do this kind of checks everywhere.\n         dibb.reset(container.getContainerTokens());\n         credentials.readTokenStorageStream(dibb);\n       }\n \n       ApplicationTokenIdentifier id \u003d new ApplicationTokenIdentifier(\n           application.getAppAttemptId());\n       Token\u003cApplicationTokenIdentifier\u003e token \u003d\n           new Token\u003cApplicationTokenIdentifier\u003e(id,\n               this.rmContext.getApplicationTokenSecretManager());\n       InetSocketAddress serviceAddr \u003d conf.getSocketAddr(\n           YarnConfiguration.RM_SCHEDULER_ADDRESS,\n           YarnConfiguration.DEFAULT_RM_SCHEDULER_ADDRESS,\n           YarnConfiguration.DEFAULT_RM_SCHEDULER_PORT);\n       // normally the client should set the service after acquiring the token,\n       // but this token is directly provided to the tasks\n       SecurityUtil.setTokenService(token, serviceAddr);\n       String appMasterTokenEncoded \u003d token.encodeToUrlString();\n       LOG.debug(\"Putting appMaster token in env : \" + token);\n       environment.put(\n           ApplicationConstants.APPLICATION_MASTER_TOKEN_ENV_NAME,\n           appMasterTokenEncoded);\n \n       // Add the RM token\n       credentials.addToken(token.getService(), token);\n       DataOutputBuffer dob \u003d new DataOutputBuffer();\n       credentials.writeTokenStorageToStream(dob);\n       container.setContainerTokens(\n           ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n \n       SecretKey clientSecretKey \u003d\n-          this.clientToAMSecretManager.getMasterKey(applicationId);\n+          this.rmContext.getClientToAMTokenSecretManager().getMasterKey(\n+            applicationId);\n       String encoded \u003d\n           Base64.encodeBase64URLSafeString(clientSecretKey.getEncoded());\n       environment.put(\n           ApplicationConstants.APPLICATION_CLIENT_SECRET_ENV_NAME, \n           encoded);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void setupTokensAndEnv(\n      ContainerLaunchContext container)\n      throws IOException {\n    Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n\n    environment.put(ApplicationConstants.APPLICATION_WEB_PROXY_BASE_ENV,\n        application.getWebProxyBase());\n    // Set the AppAttemptId, containerId, NMHTTPAdress, AppSubmitTime to be\n    // consumable by the AM.\n    environment.put(ApplicationConstants.AM_CONTAINER_ID_ENV, container\n        .getContainerId().toString());\n    environment.put(ApplicationConstants.NM_HOST_ENV, application\n        .getMasterContainer().getNodeId().getHost());\n    environment.put(ApplicationConstants.NM_PORT_ENV,\n        String.valueOf(application.getMasterContainer().getNodeId().getPort()));\n    String parts[] \u003d\n        application.getMasterContainer().getNodeHttpAddress().split(\":\");\n    environment.put(ApplicationConstants.NM_HTTP_PORT_ENV, parts[1]);\n    ApplicationId applicationId \u003d\n        application.getAppAttemptId().getApplicationId();\n    environment.put(\n        ApplicationConstants.APP_SUBMIT_TIME_ENV,\n        String.valueOf(rmContext.getRMApps()\n            .get(applicationId)\n            .getSubmitTime()));\n \n    if (UserGroupInformation.isSecurityEnabled()) {\n      // TODO: Security enabled/disabled info should come from RM.\n\n      Credentials credentials \u003d new Credentials();\n\n      DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n      if (container.getContainerTokens() !\u003d null) {\n        // TODO: Don\u0027t do this kind of checks everywhere.\n        dibb.reset(container.getContainerTokens());\n        credentials.readTokenStorageStream(dibb);\n      }\n\n      ApplicationTokenIdentifier id \u003d new ApplicationTokenIdentifier(\n          application.getAppAttemptId());\n      Token\u003cApplicationTokenIdentifier\u003e token \u003d\n          new Token\u003cApplicationTokenIdentifier\u003e(id,\n              this.rmContext.getApplicationTokenSecretManager());\n      InetSocketAddress serviceAddr \u003d conf.getSocketAddr(\n          YarnConfiguration.RM_SCHEDULER_ADDRESS,\n          YarnConfiguration.DEFAULT_RM_SCHEDULER_ADDRESS,\n          YarnConfiguration.DEFAULT_RM_SCHEDULER_PORT);\n      // normally the client should set the service after acquiring the token,\n      // but this token is directly provided to the tasks\n      SecurityUtil.setTokenService(token, serviceAddr);\n      String appMasterTokenEncoded \u003d token.encodeToUrlString();\n      LOG.debug(\"Putting appMaster token in env : \" + token);\n      environment.put(\n          ApplicationConstants.APPLICATION_MASTER_TOKEN_ENV_NAME,\n          appMasterTokenEncoded);\n\n      // Add the RM token\n      credentials.addToken(token.getService(), token);\n      DataOutputBuffer dob \u003d new DataOutputBuffer();\n      credentials.writeTokenStorageToStream(dob);\n      container.setContainerTokens(\n          ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n\n      SecretKey clientSecretKey \u003d\n          this.rmContext.getClientToAMTokenSecretManager().getMasterKey(\n            applicationId);\n      String encoded \u003d\n          Base64.encodeBase64URLSafeString(clientSecretKey.getEncoded());\n      environment.put(\n          ApplicationConstants.APPLICATION_CLIENT_SECRET_ENV_NAME, \n          encoded);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/amlauncher/AMLauncher.java",
      "extendedDetails": {}
    },
    "c074cfd6f0ec695d85a73cddba1404c9db79342e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-134. Fixes ClientToAMSecretManager creates keys without checking for validity of the appID. (Contributed by Vinod Kumar Vavilapalli)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1395841 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/10/12 6:56 PM",
      "commitName": "c074cfd6f0ec695d85a73cddba1404c9db79342e",
      "commitAuthor": "Siddharth Seth",
      "commitDateOld": "07/08/12 10:22 PM",
      "commitNameOld": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 61.86,
      "commitsBetweenForRepo": 350,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,72 +1,72 @@\n   private void setupTokensAndEnv(\n       ContainerLaunchContext container)\n       throws IOException {\n     Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n \n     environment.put(ApplicationConstants.APPLICATION_WEB_PROXY_BASE_ENV,\n         application.getWebProxyBase());\n     // Set the AppAttemptId, containerId, NMHTTPAdress, AppSubmitTime to be\n     // consumable by the AM.\n     environment.put(ApplicationConstants.AM_CONTAINER_ID_ENV, container\n         .getContainerId().toString());\n     environment.put(ApplicationConstants.NM_HOST_ENV, application\n         .getMasterContainer().getNodeId().getHost());\n     environment.put(ApplicationConstants.NM_PORT_ENV,\n         String.valueOf(application.getMasterContainer().getNodeId().getPort()));\n     String parts[] \u003d\n         application.getMasterContainer().getNodeHttpAddress().split(\":\");\n     environment.put(ApplicationConstants.NM_HTTP_PORT_ENV, parts[1]);\n+    ApplicationId applicationId \u003d\n+        application.getAppAttemptId().getApplicationId();\n     environment.put(\n         ApplicationConstants.APP_SUBMIT_TIME_ENV,\n         String.valueOf(rmContext.getRMApps()\n-            .get(application.getAppAttemptId().getApplicationId())\n+            .get(applicationId)\n             .getSubmitTime()));\n  \n     if (UserGroupInformation.isSecurityEnabled()) {\n       // TODO: Security enabled/disabled info should come from RM.\n \n       Credentials credentials \u003d new Credentials();\n \n       DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n       if (container.getContainerTokens() !\u003d null) {\n         // TODO: Don\u0027t do this kind of checks everywhere.\n         dibb.reset(container.getContainerTokens());\n         credentials.readTokenStorageStream(dibb);\n       }\n \n       ApplicationTokenIdentifier id \u003d new ApplicationTokenIdentifier(\n           application.getAppAttemptId());\n       Token\u003cApplicationTokenIdentifier\u003e token \u003d\n           new Token\u003cApplicationTokenIdentifier\u003e(id,\n               this.rmContext.getApplicationTokenSecretManager());\n       InetSocketAddress serviceAddr \u003d conf.getSocketAddr(\n           YarnConfiguration.RM_SCHEDULER_ADDRESS,\n           YarnConfiguration.DEFAULT_RM_SCHEDULER_ADDRESS,\n           YarnConfiguration.DEFAULT_RM_SCHEDULER_PORT);\n       // normally the client should set the service after acquiring the token,\n       // but this token is directly provided to the tasks\n       SecurityUtil.setTokenService(token, serviceAddr);\n       String appMasterTokenEncoded \u003d token.encodeToUrlString();\n       LOG.debug(\"Putting appMaster token in env : \" + token);\n       environment.put(\n           ApplicationConstants.APPLICATION_MASTER_TOKEN_ENV_NAME,\n           appMasterTokenEncoded);\n \n       // Add the RM token\n       credentials.addToken(token.getService(), token);\n       DataOutputBuffer dob \u003d new DataOutputBuffer();\n       credentials.writeTokenStorageToStream(dob);\n       container.setContainerTokens(\n           ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n \n-      ClientTokenIdentifier identifier \u003d new ClientTokenIdentifier(\n-          application.getAppAttemptId().getApplicationId());\n       SecretKey clientSecretKey \u003d\n-          this.clientToAMSecretManager.getMasterKey(identifier);\n+          this.clientToAMSecretManager.getMasterKey(applicationId);\n       String encoded \u003d\n           Base64.encodeBase64URLSafeString(clientSecretKey.getEncoded());\n       environment.put(\n           ApplicationConstants.APPLICATION_CLIENT_SECRET_ENV_NAME, \n           encoded);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void setupTokensAndEnv(\n      ContainerLaunchContext container)\n      throws IOException {\n    Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n\n    environment.put(ApplicationConstants.APPLICATION_WEB_PROXY_BASE_ENV,\n        application.getWebProxyBase());\n    // Set the AppAttemptId, containerId, NMHTTPAdress, AppSubmitTime to be\n    // consumable by the AM.\n    environment.put(ApplicationConstants.AM_CONTAINER_ID_ENV, container\n        .getContainerId().toString());\n    environment.put(ApplicationConstants.NM_HOST_ENV, application\n        .getMasterContainer().getNodeId().getHost());\n    environment.put(ApplicationConstants.NM_PORT_ENV,\n        String.valueOf(application.getMasterContainer().getNodeId().getPort()));\n    String parts[] \u003d\n        application.getMasterContainer().getNodeHttpAddress().split(\":\");\n    environment.put(ApplicationConstants.NM_HTTP_PORT_ENV, parts[1]);\n    ApplicationId applicationId \u003d\n        application.getAppAttemptId().getApplicationId();\n    environment.put(\n        ApplicationConstants.APP_SUBMIT_TIME_ENV,\n        String.valueOf(rmContext.getRMApps()\n            .get(applicationId)\n            .getSubmitTime()));\n \n    if (UserGroupInformation.isSecurityEnabled()) {\n      // TODO: Security enabled/disabled info should come from RM.\n\n      Credentials credentials \u003d new Credentials();\n\n      DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n      if (container.getContainerTokens() !\u003d null) {\n        // TODO: Don\u0027t do this kind of checks everywhere.\n        dibb.reset(container.getContainerTokens());\n        credentials.readTokenStorageStream(dibb);\n      }\n\n      ApplicationTokenIdentifier id \u003d new ApplicationTokenIdentifier(\n          application.getAppAttemptId());\n      Token\u003cApplicationTokenIdentifier\u003e token \u003d\n          new Token\u003cApplicationTokenIdentifier\u003e(id,\n              this.rmContext.getApplicationTokenSecretManager());\n      InetSocketAddress serviceAddr \u003d conf.getSocketAddr(\n          YarnConfiguration.RM_SCHEDULER_ADDRESS,\n          YarnConfiguration.DEFAULT_RM_SCHEDULER_ADDRESS,\n          YarnConfiguration.DEFAULT_RM_SCHEDULER_PORT);\n      // normally the client should set the service after acquiring the token,\n      // but this token is directly provided to the tasks\n      SecurityUtil.setTokenService(token, serviceAddr);\n      String appMasterTokenEncoded \u003d token.encodeToUrlString();\n      LOG.debug(\"Putting appMaster token in env : \" + token);\n      environment.put(\n          ApplicationConstants.APPLICATION_MASTER_TOKEN_ENV_NAME,\n          appMasterTokenEncoded);\n\n      // Add the RM token\n      credentials.addToken(token.getService(), token);\n      DataOutputBuffer dob \u003d new DataOutputBuffer();\n      credentials.writeTokenStorageToStream(dob);\n      container.setContainerTokens(\n          ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n\n      SecretKey clientSecretKey \u003d\n          this.clientToAMSecretManager.getMasterKey(applicationId);\n      String encoded \u003d\n          Base64.encodeBase64URLSafeString(clientSecretKey.getEncoded());\n      environment.put(\n          ApplicationConstants.APPLICATION_CLIENT_SECRET_ENV_NAME, \n          encoded);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/amlauncher/AMLauncher.java",
      "extendedDetails": {}
    },
    "e1fdf62123625e4ba399af02f8aad500637d29d1": {
      "type": "Yfilerename",
      "commitMessage": "YARN-1. Promote YARN to be a sub-project of Apache Hadoop.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1370666 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/08/12 10:22 PM",
      "commitName": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "07/08/12 7:53 PM",
      "commitNameOld": "34554d1e11ee1d5b564d7d9ed3e6d55931d72749",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private void setupTokensAndEnv(\n      ContainerLaunchContext container)\n      throws IOException {\n    Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n\n    environment.put(ApplicationConstants.APPLICATION_WEB_PROXY_BASE_ENV,\n        application.getWebProxyBase());\n    // Set the AppAttemptId, containerId, NMHTTPAdress, AppSubmitTime to be\n    // consumable by the AM.\n    environment.put(ApplicationConstants.AM_CONTAINER_ID_ENV, container\n        .getContainerId().toString());\n    environment.put(ApplicationConstants.NM_HOST_ENV, application\n        .getMasterContainer().getNodeId().getHost());\n    environment.put(ApplicationConstants.NM_PORT_ENV,\n        String.valueOf(application.getMasterContainer().getNodeId().getPort()));\n    String parts[] \u003d\n        application.getMasterContainer().getNodeHttpAddress().split(\":\");\n    environment.put(ApplicationConstants.NM_HTTP_PORT_ENV, parts[1]);\n    environment.put(\n        ApplicationConstants.APP_SUBMIT_TIME_ENV,\n        String.valueOf(rmContext.getRMApps()\n            .get(application.getAppAttemptId().getApplicationId())\n            .getSubmitTime()));\n \n    if (UserGroupInformation.isSecurityEnabled()) {\n      // TODO: Security enabled/disabled info should come from RM.\n\n      Credentials credentials \u003d new Credentials();\n\n      DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n      if (container.getContainerTokens() !\u003d null) {\n        // TODO: Don\u0027t do this kind of checks everywhere.\n        dibb.reset(container.getContainerTokens());\n        credentials.readTokenStorageStream(dibb);\n      }\n\n      ApplicationTokenIdentifier id \u003d new ApplicationTokenIdentifier(\n          application.getAppAttemptId());\n      Token\u003cApplicationTokenIdentifier\u003e token \u003d\n          new Token\u003cApplicationTokenIdentifier\u003e(id,\n              this.rmContext.getApplicationTokenSecretManager());\n      InetSocketAddress serviceAddr \u003d conf.getSocketAddr(\n          YarnConfiguration.RM_SCHEDULER_ADDRESS,\n          YarnConfiguration.DEFAULT_RM_SCHEDULER_ADDRESS,\n          YarnConfiguration.DEFAULT_RM_SCHEDULER_PORT);\n      // normally the client should set the service after acquiring the token,\n      // but this token is directly provided to the tasks\n      SecurityUtil.setTokenService(token, serviceAddr);\n      String appMasterTokenEncoded \u003d token.encodeToUrlString();\n      LOG.debug(\"Putting appMaster token in env : \" + token);\n      environment.put(\n          ApplicationConstants.APPLICATION_MASTER_TOKEN_ENV_NAME,\n          appMasterTokenEncoded);\n\n      // Add the RM token\n      credentials.addToken(token.getService(), token);\n      DataOutputBuffer dob \u003d new DataOutputBuffer();\n      credentials.writeTokenStorageToStream(dob);\n      container.setContainerTokens(\n          ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n\n      ClientTokenIdentifier identifier \u003d new ClientTokenIdentifier(\n          application.getAppAttemptId().getApplicationId());\n      SecretKey clientSecretKey \u003d\n          this.clientToAMSecretManager.getMasterKey(identifier);\n      String encoded \u003d\n          Base64.encodeBase64URLSafeString(clientSecretKey.getEncoded());\n      environment.put(\n          ApplicationConstants.APPLICATION_CLIENT_SECRET_ENV_NAME, \n          encoded);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/amlauncher/AMLauncher.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/amlauncher/AMLauncher.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/amlauncher/AMLauncher.java"
      }
    },
    "aa60da6c2ec049cc70897afee6c368cb70493773": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-4162. Correctly set token service (Daryn Sharp via bobby)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1335567 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/05/12 8:07 AM",
      "commitName": "aa60da6c2ec049cc70897afee6c368cb70493773",
      "commitAuthor": "Robert Joseph Evans",
      "commitDateOld": "18/04/12 11:46 AM",
      "commitNameOld": "32d511065a2612d37591f09e53eed8ec1488587d",
      "commitAuthorOld": "Robert Joseph Evans",
      "daysBetweenCommits": 19.85,
      "commitsBetweenForRepo": 122,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,74 +1,72 @@\n   private void setupTokensAndEnv(\n       ContainerLaunchContext container)\n       throws IOException {\n     Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n \n     environment.put(ApplicationConstants.APPLICATION_WEB_PROXY_BASE_ENV,\n         application.getWebProxyBase());\n     // Set the AppAttemptId, containerId, NMHTTPAdress, AppSubmitTime to be\n     // consumable by the AM.\n     environment.put(ApplicationConstants.AM_CONTAINER_ID_ENV, container\n         .getContainerId().toString());\n     environment.put(ApplicationConstants.NM_HOST_ENV, application\n         .getMasterContainer().getNodeId().getHost());\n     environment.put(ApplicationConstants.NM_PORT_ENV,\n         String.valueOf(application.getMasterContainer().getNodeId().getPort()));\n     String parts[] \u003d\n         application.getMasterContainer().getNodeHttpAddress().split(\":\");\n     environment.put(ApplicationConstants.NM_HTTP_PORT_ENV, parts[1]);\n     environment.put(\n         ApplicationConstants.APP_SUBMIT_TIME_ENV,\n         String.valueOf(rmContext.getRMApps()\n             .get(application.getAppAttemptId().getApplicationId())\n             .getSubmitTime()));\n  \n     if (UserGroupInformation.isSecurityEnabled()) {\n       // TODO: Security enabled/disabled info should come from RM.\n \n       Credentials credentials \u003d new Credentials();\n \n       DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n       if (container.getContainerTokens() !\u003d null) {\n         // TODO: Don\u0027t do this kind of checks everywhere.\n         dibb.reset(container.getContainerTokens());\n         credentials.readTokenStorageStream(dibb);\n       }\n \n       ApplicationTokenIdentifier id \u003d new ApplicationTokenIdentifier(\n           application.getAppAttemptId());\n       Token\u003cApplicationTokenIdentifier\u003e token \u003d\n           new Token\u003cApplicationTokenIdentifier\u003e(id,\n               this.rmContext.getApplicationTokenSecretManager());\n-      InetSocketAddress unresolvedAddr \u003d conf.getSocketAddr(\n+      InetSocketAddress serviceAddr \u003d conf.getSocketAddr(\n           YarnConfiguration.RM_SCHEDULER_ADDRESS,\n           YarnConfiguration.DEFAULT_RM_SCHEDULER_ADDRESS,\n           YarnConfiguration.DEFAULT_RM_SCHEDULER_PORT);\n-      String resolvedAddr \u003d\n-          unresolvedAddr.getAddress().getHostAddress() + \":\"\n-              + unresolvedAddr.getPort();\n-      token.setService(new Text(resolvedAddr));\n+      // normally the client should set the service after acquiring the token,\n+      // but this token is directly provided to the tasks\n+      SecurityUtil.setTokenService(token, serviceAddr);\n       String appMasterTokenEncoded \u003d token.encodeToUrlString();\n-      LOG.debug(\"Putting appMaster token in env : \" + appMasterTokenEncoded);\n+      LOG.debug(\"Putting appMaster token in env : \" + token);\n       environment.put(\n           ApplicationConstants.APPLICATION_MASTER_TOKEN_ENV_NAME,\n           appMasterTokenEncoded);\n \n       // Add the RM token\n-      credentials.addToken(new Text(resolvedAddr), token);\n+      credentials.addToken(token.getService(), token);\n       DataOutputBuffer dob \u003d new DataOutputBuffer();\n       credentials.writeTokenStorageToStream(dob);\n       container.setContainerTokens(\n           ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n \n       ClientTokenIdentifier identifier \u003d new ClientTokenIdentifier(\n           application.getAppAttemptId().getApplicationId());\n       SecretKey clientSecretKey \u003d\n           this.clientToAMSecretManager.getMasterKey(identifier);\n       String encoded \u003d\n           Base64.encodeBase64URLSafeString(clientSecretKey.getEncoded());\n-      LOG.debug(\"The encoded client secret-key to be put in env : \" + encoded);\n       environment.put(\n           ApplicationConstants.APPLICATION_CLIENT_SECRET_ENV_NAME, \n           encoded);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void setupTokensAndEnv(\n      ContainerLaunchContext container)\n      throws IOException {\n    Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n\n    environment.put(ApplicationConstants.APPLICATION_WEB_PROXY_BASE_ENV,\n        application.getWebProxyBase());\n    // Set the AppAttemptId, containerId, NMHTTPAdress, AppSubmitTime to be\n    // consumable by the AM.\n    environment.put(ApplicationConstants.AM_CONTAINER_ID_ENV, container\n        .getContainerId().toString());\n    environment.put(ApplicationConstants.NM_HOST_ENV, application\n        .getMasterContainer().getNodeId().getHost());\n    environment.put(ApplicationConstants.NM_PORT_ENV,\n        String.valueOf(application.getMasterContainer().getNodeId().getPort()));\n    String parts[] \u003d\n        application.getMasterContainer().getNodeHttpAddress().split(\":\");\n    environment.put(ApplicationConstants.NM_HTTP_PORT_ENV, parts[1]);\n    environment.put(\n        ApplicationConstants.APP_SUBMIT_TIME_ENV,\n        String.valueOf(rmContext.getRMApps()\n            .get(application.getAppAttemptId().getApplicationId())\n            .getSubmitTime()));\n \n    if (UserGroupInformation.isSecurityEnabled()) {\n      // TODO: Security enabled/disabled info should come from RM.\n\n      Credentials credentials \u003d new Credentials();\n\n      DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n      if (container.getContainerTokens() !\u003d null) {\n        // TODO: Don\u0027t do this kind of checks everywhere.\n        dibb.reset(container.getContainerTokens());\n        credentials.readTokenStorageStream(dibb);\n      }\n\n      ApplicationTokenIdentifier id \u003d new ApplicationTokenIdentifier(\n          application.getAppAttemptId());\n      Token\u003cApplicationTokenIdentifier\u003e token \u003d\n          new Token\u003cApplicationTokenIdentifier\u003e(id,\n              this.rmContext.getApplicationTokenSecretManager());\n      InetSocketAddress serviceAddr \u003d conf.getSocketAddr(\n          YarnConfiguration.RM_SCHEDULER_ADDRESS,\n          YarnConfiguration.DEFAULT_RM_SCHEDULER_ADDRESS,\n          YarnConfiguration.DEFAULT_RM_SCHEDULER_PORT);\n      // normally the client should set the service after acquiring the token,\n      // but this token is directly provided to the tasks\n      SecurityUtil.setTokenService(token, serviceAddr);\n      String appMasterTokenEncoded \u003d token.encodeToUrlString();\n      LOG.debug(\"Putting appMaster token in env : \" + token);\n      environment.put(\n          ApplicationConstants.APPLICATION_MASTER_TOKEN_ENV_NAME,\n          appMasterTokenEncoded);\n\n      // Add the RM token\n      credentials.addToken(token.getService(), token);\n      DataOutputBuffer dob \u003d new DataOutputBuffer();\n      credentials.writeTokenStorageToStream(dob);\n      container.setContainerTokens(\n          ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n\n      ClientTokenIdentifier identifier \u003d new ClientTokenIdentifier(\n          application.getAppAttemptId().getApplicationId());\n      SecretKey clientSecretKey \u003d\n          this.clientToAMSecretManager.getMasterKey(identifier);\n      String encoded \u003d\n          Base64.encodeBase64URLSafeString(clientSecretKey.getEncoded());\n      environment.put(\n          ApplicationConstants.APPLICATION_CLIENT_SECRET_ENV_NAME, \n          encoded);\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/amlauncher/AMLauncher.java",
      "extendedDetails": {}
    },
    "32d511065a2612d37591f09e53eed8ec1488587d": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-4161. create sockets consistently (Daryn Sharp via bobby)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1327621 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/04/12 11:46 AM",
      "commitName": "32d511065a2612d37591f09e53eed8ec1488587d",
      "commitAuthor": "Robert Joseph Evans",
      "commitDateOld": "17/04/12 11:48 AM",
      "commitNameOld": "fe7711df98b9dd16259f6534e8461a29f24caadc",
      "commitAuthorOld": "Siddharth Seth",
      "daysBetweenCommits": 1.0,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,75 +1,74 @@\n   private void setupTokensAndEnv(\n       ContainerLaunchContext container)\n       throws IOException {\n     Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n \n     environment.put(ApplicationConstants.APPLICATION_WEB_PROXY_BASE_ENV,\n         application.getWebProxyBase());\n     // Set the AppAttemptId, containerId, NMHTTPAdress, AppSubmitTime to be\n     // consumable by the AM.\n     environment.put(ApplicationConstants.AM_CONTAINER_ID_ENV, container\n         .getContainerId().toString());\n     environment.put(ApplicationConstants.NM_HOST_ENV, application\n         .getMasterContainer().getNodeId().getHost());\n     environment.put(ApplicationConstants.NM_PORT_ENV,\n         String.valueOf(application.getMasterContainer().getNodeId().getPort()));\n     String parts[] \u003d\n         application.getMasterContainer().getNodeHttpAddress().split(\":\");\n     environment.put(ApplicationConstants.NM_HTTP_PORT_ENV, parts[1]);\n     environment.put(\n         ApplicationConstants.APP_SUBMIT_TIME_ENV,\n         String.valueOf(rmContext.getRMApps()\n             .get(application.getAppAttemptId().getApplicationId())\n             .getSubmitTime()));\n  \n     if (UserGroupInformation.isSecurityEnabled()) {\n       // TODO: Security enabled/disabled info should come from RM.\n \n       Credentials credentials \u003d new Credentials();\n \n       DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n       if (container.getContainerTokens() !\u003d null) {\n         // TODO: Don\u0027t do this kind of checks everywhere.\n         dibb.reset(container.getContainerTokens());\n         credentials.readTokenStorageStream(dibb);\n       }\n \n       ApplicationTokenIdentifier id \u003d new ApplicationTokenIdentifier(\n           application.getAppAttemptId());\n       Token\u003cApplicationTokenIdentifier\u003e token \u003d\n           new Token\u003cApplicationTokenIdentifier\u003e(id,\n               this.rmContext.getApplicationTokenSecretManager());\n-      String schedulerAddressStr \u003d\n-          this.conf.get(YarnConfiguration.RM_SCHEDULER_ADDRESS,\n-              YarnConfiguration.DEFAULT_RM_SCHEDULER_ADDRESS);\n-      InetSocketAddress unresolvedAddr \u003d\n-          NetUtils.createSocketAddr(schedulerAddressStr);\n+      InetSocketAddress unresolvedAddr \u003d conf.getSocketAddr(\n+          YarnConfiguration.RM_SCHEDULER_ADDRESS,\n+          YarnConfiguration.DEFAULT_RM_SCHEDULER_ADDRESS,\n+          YarnConfiguration.DEFAULT_RM_SCHEDULER_PORT);\n       String resolvedAddr \u003d\n           unresolvedAddr.getAddress().getHostAddress() + \":\"\n               + unresolvedAddr.getPort();\n       token.setService(new Text(resolvedAddr));\n       String appMasterTokenEncoded \u003d token.encodeToUrlString();\n       LOG.debug(\"Putting appMaster token in env : \" + appMasterTokenEncoded);\n       environment.put(\n           ApplicationConstants.APPLICATION_MASTER_TOKEN_ENV_NAME,\n           appMasterTokenEncoded);\n \n       // Add the RM token\n       credentials.addToken(new Text(resolvedAddr), token);\n       DataOutputBuffer dob \u003d new DataOutputBuffer();\n       credentials.writeTokenStorageToStream(dob);\n       container.setContainerTokens(\n           ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n \n       ClientTokenIdentifier identifier \u003d new ClientTokenIdentifier(\n           application.getAppAttemptId().getApplicationId());\n       SecretKey clientSecretKey \u003d\n           this.clientToAMSecretManager.getMasterKey(identifier);\n       String encoded \u003d\n           Base64.encodeBase64URLSafeString(clientSecretKey.getEncoded());\n       LOG.debug(\"The encoded client secret-key to be put in env : \" + encoded);\n       environment.put(\n           ApplicationConstants.APPLICATION_CLIENT_SECRET_ENV_NAME, \n           encoded);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void setupTokensAndEnv(\n      ContainerLaunchContext container)\n      throws IOException {\n    Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n\n    environment.put(ApplicationConstants.APPLICATION_WEB_PROXY_BASE_ENV,\n        application.getWebProxyBase());\n    // Set the AppAttemptId, containerId, NMHTTPAdress, AppSubmitTime to be\n    // consumable by the AM.\n    environment.put(ApplicationConstants.AM_CONTAINER_ID_ENV, container\n        .getContainerId().toString());\n    environment.put(ApplicationConstants.NM_HOST_ENV, application\n        .getMasterContainer().getNodeId().getHost());\n    environment.put(ApplicationConstants.NM_PORT_ENV,\n        String.valueOf(application.getMasterContainer().getNodeId().getPort()));\n    String parts[] \u003d\n        application.getMasterContainer().getNodeHttpAddress().split(\":\");\n    environment.put(ApplicationConstants.NM_HTTP_PORT_ENV, parts[1]);\n    environment.put(\n        ApplicationConstants.APP_SUBMIT_TIME_ENV,\n        String.valueOf(rmContext.getRMApps()\n            .get(application.getAppAttemptId().getApplicationId())\n            .getSubmitTime()));\n \n    if (UserGroupInformation.isSecurityEnabled()) {\n      // TODO: Security enabled/disabled info should come from RM.\n\n      Credentials credentials \u003d new Credentials();\n\n      DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n      if (container.getContainerTokens() !\u003d null) {\n        // TODO: Don\u0027t do this kind of checks everywhere.\n        dibb.reset(container.getContainerTokens());\n        credentials.readTokenStorageStream(dibb);\n      }\n\n      ApplicationTokenIdentifier id \u003d new ApplicationTokenIdentifier(\n          application.getAppAttemptId());\n      Token\u003cApplicationTokenIdentifier\u003e token \u003d\n          new Token\u003cApplicationTokenIdentifier\u003e(id,\n              this.rmContext.getApplicationTokenSecretManager());\n      InetSocketAddress unresolvedAddr \u003d conf.getSocketAddr(\n          YarnConfiguration.RM_SCHEDULER_ADDRESS,\n          YarnConfiguration.DEFAULT_RM_SCHEDULER_ADDRESS,\n          YarnConfiguration.DEFAULT_RM_SCHEDULER_PORT);\n      String resolvedAddr \u003d\n          unresolvedAddr.getAddress().getHostAddress() + \":\"\n              + unresolvedAddr.getPort();\n      token.setService(new Text(resolvedAddr));\n      String appMasterTokenEncoded \u003d token.encodeToUrlString();\n      LOG.debug(\"Putting appMaster token in env : \" + appMasterTokenEncoded);\n      environment.put(\n          ApplicationConstants.APPLICATION_MASTER_TOKEN_ENV_NAME,\n          appMasterTokenEncoded);\n\n      // Add the RM token\n      credentials.addToken(new Text(resolvedAddr), token);\n      DataOutputBuffer dob \u003d new DataOutputBuffer();\n      credentials.writeTokenStorageToStream(dob);\n      container.setContainerTokens(\n          ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n\n      ClientTokenIdentifier identifier \u003d new ClientTokenIdentifier(\n          application.getAppAttemptId().getApplicationId());\n      SecretKey clientSecretKey \u003d\n          this.clientToAMSecretManager.getMasterKey(identifier);\n      String encoded \u003d\n          Base64.encodeBase64URLSafeString(clientSecretKey.getEncoded());\n      LOG.debug(\"The encoded client secret-key to be put in env : \" + encoded);\n      environment.put(\n          ApplicationConstants.APPLICATION_CLIENT_SECRET_ENV_NAME, \n          encoded);\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/amlauncher/AMLauncher.java",
      "extendedDetails": {}
    },
    "fe7711df98b9dd16259f6534e8461a29f24caadc": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3942. Randomize master key generation for ApplicationTokenSecretManager and roll it every so often. (Contributed by Vinod Kumar Vavilapalli)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1327220 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/04/12 11:48 AM",
      "commitName": "fe7711df98b9dd16259f6534e8461a29f24caadc",
      "commitAuthor": "Siddharth Seth",
      "commitDateOld": "29/10/11 2:35 AM",
      "commitNameOld": "7f4dc277572df6ba25fa961073b99a5bdb086c00",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 171.38,
      "commitsBetweenForRepo": 1194,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,75 +1,75 @@\n   private void setupTokensAndEnv(\n       ContainerLaunchContext container)\n       throws IOException {\n     Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n \n     environment.put(ApplicationConstants.APPLICATION_WEB_PROXY_BASE_ENV,\n         application.getWebProxyBase());\n     // Set the AppAttemptId, containerId, NMHTTPAdress, AppSubmitTime to be\n     // consumable by the AM.\n     environment.put(ApplicationConstants.AM_CONTAINER_ID_ENV, container\n         .getContainerId().toString());\n     environment.put(ApplicationConstants.NM_HOST_ENV, application\n         .getMasterContainer().getNodeId().getHost());\n     environment.put(ApplicationConstants.NM_PORT_ENV,\n         String.valueOf(application.getMasterContainer().getNodeId().getPort()));\n     String parts[] \u003d\n         application.getMasterContainer().getNodeHttpAddress().split(\":\");\n     environment.put(ApplicationConstants.NM_HTTP_PORT_ENV, parts[1]);\n     environment.put(\n         ApplicationConstants.APP_SUBMIT_TIME_ENV,\n         String.valueOf(rmContext.getRMApps()\n             .get(application.getAppAttemptId().getApplicationId())\n             .getSubmitTime()));\n  \n     if (UserGroupInformation.isSecurityEnabled()) {\n       // TODO: Security enabled/disabled info should come from RM.\n \n       Credentials credentials \u003d new Credentials();\n \n       DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n       if (container.getContainerTokens() !\u003d null) {\n         // TODO: Don\u0027t do this kind of checks everywhere.\n         dibb.reset(container.getContainerTokens());\n         credentials.readTokenStorageStream(dibb);\n       }\n \n       ApplicationTokenIdentifier id \u003d new ApplicationTokenIdentifier(\n           application.getAppAttemptId());\n       Token\u003cApplicationTokenIdentifier\u003e token \u003d\n           new Token\u003cApplicationTokenIdentifier\u003e(id,\n-              this.applicationTokenSecretManager);\n+              this.rmContext.getApplicationTokenSecretManager());\n       String schedulerAddressStr \u003d\n           this.conf.get(YarnConfiguration.RM_SCHEDULER_ADDRESS,\n               YarnConfiguration.DEFAULT_RM_SCHEDULER_ADDRESS);\n       InetSocketAddress unresolvedAddr \u003d\n           NetUtils.createSocketAddr(schedulerAddressStr);\n       String resolvedAddr \u003d\n           unresolvedAddr.getAddress().getHostAddress() + \":\"\n               + unresolvedAddr.getPort();\n       token.setService(new Text(resolvedAddr));\n       String appMasterTokenEncoded \u003d token.encodeToUrlString();\n       LOG.debug(\"Putting appMaster token in env : \" + appMasterTokenEncoded);\n       environment.put(\n           ApplicationConstants.APPLICATION_MASTER_TOKEN_ENV_NAME,\n           appMasterTokenEncoded);\n \n       // Add the RM token\n       credentials.addToken(new Text(resolvedAddr), token);\n       DataOutputBuffer dob \u003d new DataOutputBuffer();\n       credentials.writeTokenStorageToStream(dob);\n       container.setContainerTokens(\n           ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n \n       ClientTokenIdentifier identifier \u003d new ClientTokenIdentifier(\n           application.getAppAttemptId().getApplicationId());\n       SecretKey clientSecretKey \u003d\n           this.clientToAMSecretManager.getMasterKey(identifier);\n       String encoded \u003d\n           Base64.encodeBase64URLSafeString(clientSecretKey.getEncoded());\n       LOG.debug(\"The encoded client secret-key to be put in env : \" + encoded);\n       environment.put(\n           ApplicationConstants.APPLICATION_CLIENT_SECRET_ENV_NAME, \n           encoded);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void setupTokensAndEnv(\n      ContainerLaunchContext container)\n      throws IOException {\n    Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n\n    environment.put(ApplicationConstants.APPLICATION_WEB_PROXY_BASE_ENV,\n        application.getWebProxyBase());\n    // Set the AppAttemptId, containerId, NMHTTPAdress, AppSubmitTime to be\n    // consumable by the AM.\n    environment.put(ApplicationConstants.AM_CONTAINER_ID_ENV, container\n        .getContainerId().toString());\n    environment.put(ApplicationConstants.NM_HOST_ENV, application\n        .getMasterContainer().getNodeId().getHost());\n    environment.put(ApplicationConstants.NM_PORT_ENV,\n        String.valueOf(application.getMasterContainer().getNodeId().getPort()));\n    String parts[] \u003d\n        application.getMasterContainer().getNodeHttpAddress().split(\":\");\n    environment.put(ApplicationConstants.NM_HTTP_PORT_ENV, parts[1]);\n    environment.put(\n        ApplicationConstants.APP_SUBMIT_TIME_ENV,\n        String.valueOf(rmContext.getRMApps()\n            .get(application.getAppAttemptId().getApplicationId())\n            .getSubmitTime()));\n \n    if (UserGroupInformation.isSecurityEnabled()) {\n      // TODO: Security enabled/disabled info should come from RM.\n\n      Credentials credentials \u003d new Credentials();\n\n      DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n      if (container.getContainerTokens() !\u003d null) {\n        // TODO: Don\u0027t do this kind of checks everywhere.\n        dibb.reset(container.getContainerTokens());\n        credentials.readTokenStorageStream(dibb);\n      }\n\n      ApplicationTokenIdentifier id \u003d new ApplicationTokenIdentifier(\n          application.getAppAttemptId());\n      Token\u003cApplicationTokenIdentifier\u003e token \u003d\n          new Token\u003cApplicationTokenIdentifier\u003e(id,\n              this.rmContext.getApplicationTokenSecretManager());\n      String schedulerAddressStr \u003d\n          this.conf.get(YarnConfiguration.RM_SCHEDULER_ADDRESS,\n              YarnConfiguration.DEFAULT_RM_SCHEDULER_ADDRESS);\n      InetSocketAddress unresolvedAddr \u003d\n          NetUtils.createSocketAddr(schedulerAddressStr);\n      String resolvedAddr \u003d\n          unresolvedAddr.getAddress().getHostAddress() + \":\"\n              + unresolvedAddr.getPort();\n      token.setService(new Text(resolvedAddr));\n      String appMasterTokenEncoded \u003d token.encodeToUrlString();\n      LOG.debug(\"Putting appMaster token in env : \" + appMasterTokenEncoded);\n      environment.put(\n          ApplicationConstants.APPLICATION_MASTER_TOKEN_ENV_NAME,\n          appMasterTokenEncoded);\n\n      // Add the RM token\n      credentials.addToken(new Text(resolvedAddr), token);\n      DataOutputBuffer dob \u003d new DataOutputBuffer();\n      credentials.writeTokenStorageToStream(dob);\n      container.setContainerTokens(\n          ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n\n      ClientTokenIdentifier identifier \u003d new ClientTokenIdentifier(\n          application.getAppAttemptId().getApplicationId());\n      SecretKey clientSecretKey \u003d\n          this.clientToAMSecretManager.getMasterKey(identifier);\n      String encoded \u003d\n          Base64.encodeBase64URLSafeString(clientSecretKey.getEncoded());\n      LOG.debug(\"The encoded client secret-key to be put in env : \" + encoded);\n      environment.put(\n          ApplicationConstants.APPLICATION_CLIENT_SECRET_ENV_NAME, \n          encoded);\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/amlauncher/AMLauncher.java",
      "extendedDetails": {}
    },
    "670fa24b48acb407c22fbfdde87ae3123dcbf449": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2989. Modified JobHistory to link to task and AM logs from the JobHistoryServer. Contributed by Siddharth Seth.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1190174 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/10/11 11:45 PM",
      "commitName": "670fa24b48acb407c22fbfdde87ae3123dcbf449",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "26/10/11 11:24 PM",
      "commitNameOld": "db8ac0ec3cbec046f9cf32644c16fd2a51dd85a2",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 1.01,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,70 +1,75 @@\n   private void setupTokensAndEnv(\n       ContainerLaunchContext container)\n       throws IOException {\n     Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n \n     environment.put(ApplicationConstants.APPLICATION_WEB_PROXY_BASE_ENV,\n         application.getWebProxyBase());\n     // Set the AppAttemptId, containerId, NMHTTPAdress, AppSubmitTime to be\n     // consumable by the AM.\n     environment.put(ApplicationConstants.AM_CONTAINER_ID_ENV, container\n         .getContainerId().toString());\n-    environment.put(ApplicationConstants.NM_HTTP_ADDRESS_ENV, application\n-        .getMasterContainer().getNodeHttpAddress());\n+    environment.put(ApplicationConstants.NM_HOST_ENV, application\n+        .getMasterContainer().getNodeId().getHost());\n+    environment.put(ApplicationConstants.NM_PORT_ENV,\n+        String.valueOf(application.getMasterContainer().getNodeId().getPort()));\n+    String parts[] \u003d\n+        application.getMasterContainer().getNodeHttpAddress().split(\":\");\n+    environment.put(ApplicationConstants.NM_HTTP_PORT_ENV, parts[1]);\n     environment.put(\n         ApplicationConstants.APP_SUBMIT_TIME_ENV,\n         String.valueOf(rmContext.getRMApps()\n             .get(application.getAppAttemptId().getApplicationId())\n             .getSubmitTime()));\n  \n     if (UserGroupInformation.isSecurityEnabled()) {\n       // TODO: Security enabled/disabled info should come from RM.\n \n       Credentials credentials \u003d new Credentials();\n \n       DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n       if (container.getContainerTokens() !\u003d null) {\n         // TODO: Don\u0027t do this kind of checks everywhere.\n         dibb.reset(container.getContainerTokens());\n         credentials.readTokenStorageStream(dibb);\n       }\n \n       ApplicationTokenIdentifier id \u003d new ApplicationTokenIdentifier(\n           application.getAppAttemptId());\n       Token\u003cApplicationTokenIdentifier\u003e token \u003d\n           new Token\u003cApplicationTokenIdentifier\u003e(id,\n               this.applicationTokenSecretManager);\n       String schedulerAddressStr \u003d\n           this.conf.get(YarnConfiguration.RM_SCHEDULER_ADDRESS,\n               YarnConfiguration.DEFAULT_RM_SCHEDULER_ADDRESS);\n       InetSocketAddress unresolvedAddr \u003d\n           NetUtils.createSocketAddr(schedulerAddressStr);\n       String resolvedAddr \u003d\n           unresolvedAddr.getAddress().getHostAddress() + \":\"\n               + unresolvedAddr.getPort();\n       token.setService(new Text(resolvedAddr));\n       String appMasterTokenEncoded \u003d token.encodeToUrlString();\n       LOG.debug(\"Putting appMaster token in env : \" + appMasterTokenEncoded);\n       environment.put(\n           ApplicationConstants.APPLICATION_MASTER_TOKEN_ENV_NAME,\n           appMasterTokenEncoded);\n \n       // Add the RM token\n       credentials.addToken(new Text(resolvedAddr), token);\n       DataOutputBuffer dob \u003d new DataOutputBuffer();\n       credentials.writeTokenStorageToStream(dob);\n       container.setContainerTokens(\n           ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n \n       ClientTokenIdentifier identifier \u003d new ClientTokenIdentifier(\n           application.getAppAttemptId().getApplicationId());\n       SecretKey clientSecretKey \u003d\n           this.clientToAMSecretManager.getMasterKey(identifier);\n       String encoded \u003d\n           Base64.encodeBase64URLSafeString(clientSecretKey.getEncoded());\n       LOG.debug(\"The encoded client secret-key to be put in env : \" + encoded);\n       environment.put(\n           ApplicationConstants.APPLICATION_CLIENT_SECRET_ENV_NAME, \n           encoded);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void setupTokensAndEnv(\n      ContainerLaunchContext container)\n      throws IOException {\n    Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n\n    environment.put(ApplicationConstants.APPLICATION_WEB_PROXY_BASE_ENV,\n        application.getWebProxyBase());\n    // Set the AppAttemptId, containerId, NMHTTPAdress, AppSubmitTime to be\n    // consumable by the AM.\n    environment.put(ApplicationConstants.AM_CONTAINER_ID_ENV, container\n        .getContainerId().toString());\n    environment.put(ApplicationConstants.NM_HOST_ENV, application\n        .getMasterContainer().getNodeId().getHost());\n    environment.put(ApplicationConstants.NM_PORT_ENV,\n        String.valueOf(application.getMasterContainer().getNodeId().getPort()));\n    String parts[] \u003d\n        application.getMasterContainer().getNodeHttpAddress().split(\":\");\n    environment.put(ApplicationConstants.NM_HTTP_PORT_ENV, parts[1]);\n    environment.put(\n        ApplicationConstants.APP_SUBMIT_TIME_ENV,\n        String.valueOf(rmContext.getRMApps()\n            .get(application.getAppAttemptId().getApplicationId())\n            .getSubmitTime()));\n \n    if (UserGroupInformation.isSecurityEnabled()) {\n      // TODO: Security enabled/disabled info should come from RM.\n\n      Credentials credentials \u003d new Credentials();\n\n      DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n      if (container.getContainerTokens() !\u003d null) {\n        // TODO: Don\u0027t do this kind of checks everywhere.\n        dibb.reset(container.getContainerTokens());\n        credentials.readTokenStorageStream(dibb);\n      }\n\n      ApplicationTokenIdentifier id \u003d new ApplicationTokenIdentifier(\n          application.getAppAttemptId());\n      Token\u003cApplicationTokenIdentifier\u003e token \u003d\n          new Token\u003cApplicationTokenIdentifier\u003e(id,\n              this.applicationTokenSecretManager);\n      String schedulerAddressStr \u003d\n          this.conf.get(YarnConfiguration.RM_SCHEDULER_ADDRESS,\n              YarnConfiguration.DEFAULT_RM_SCHEDULER_ADDRESS);\n      InetSocketAddress unresolvedAddr \u003d\n          NetUtils.createSocketAddr(schedulerAddressStr);\n      String resolvedAddr \u003d\n          unresolvedAddr.getAddress().getHostAddress() + \":\"\n              + unresolvedAddr.getPort();\n      token.setService(new Text(resolvedAddr));\n      String appMasterTokenEncoded \u003d token.encodeToUrlString();\n      LOG.debug(\"Putting appMaster token in env : \" + appMasterTokenEncoded);\n      environment.put(\n          ApplicationConstants.APPLICATION_MASTER_TOKEN_ENV_NAME,\n          appMasterTokenEncoded);\n\n      // Add the RM token\n      credentials.addToken(new Text(resolvedAddr), token);\n      DataOutputBuffer dob \u003d new DataOutputBuffer();\n      credentials.writeTokenStorageToStream(dob);\n      container.setContainerTokens(\n          ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n\n      ClientTokenIdentifier identifier \u003d new ClientTokenIdentifier(\n          application.getAppAttemptId().getApplicationId());\n      SecretKey clientSecretKey \u003d\n          this.clientToAMSecretManager.getMasterKey(identifier);\n      String encoded \u003d\n          Base64.encodeBase64URLSafeString(clientSecretKey.getEncoded());\n      LOG.debug(\"The encoded client secret-key to be put in env : \" + encoded);\n      environment.put(\n          ApplicationConstants.APPLICATION_CLIENT_SECRET_ENV_NAME, \n          encoded);\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/amlauncher/AMLauncher.java",
      "extendedDetails": {}
    },
    "db8ac0ec3cbec046f9cf32644c16fd2a51dd85a2": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3257. Added authorization checks for the protocol between ResourceManager and ApplicatoinMaster. Contributed by Vinod K V. \n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1189630 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "26/10/11 11:24 PM",
      "commitName": "db8ac0ec3cbec046f9cf32644c16fd2a51dd85a2",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "25/10/11 11:29 PM",
      "commitNameOld": "8aabd3d4e67cad8dc7e46f5339981135badc7421",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 1.0,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,70 +1,70 @@\n   private void setupTokensAndEnv(\n       ContainerLaunchContext container)\n       throws IOException {\n     Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n \n     environment.put(ApplicationConstants.APPLICATION_WEB_PROXY_BASE_ENV,\n         application.getWebProxyBase());\n     // Set the AppAttemptId, containerId, NMHTTPAdress, AppSubmitTime to be\n     // consumable by the AM.\n     environment.put(ApplicationConstants.AM_CONTAINER_ID_ENV, container\n         .getContainerId().toString());\n     environment.put(ApplicationConstants.NM_HTTP_ADDRESS_ENV, application\n         .getMasterContainer().getNodeHttpAddress());\n     environment.put(\n         ApplicationConstants.APP_SUBMIT_TIME_ENV,\n         String.valueOf(rmContext.getRMApps()\n             .get(application.getAppAttemptId().getApplicationId())\n             .getSubmitTime()));\n  \n     if (UserGroupInformation.isSecurityEnabled()) {\n       // TODO: Security enabled/disabled info should come from RM.\n \n       Credentials credentials \u003d new Credentials();\n \n       DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n       if (container.getContainerTokens() !\u003d null) {\n         // TODO: Don\u0027t do this kind of checks everywhere.\n         dibb.reset(container.getContainerTokens());\n         credentials.readTokenStorageStream(dibb);\n       }\n \n       ApplicationTokenIdentifier id \u003d new ApplicationTokenIdentifier(\n-          application.getAppAttemptId().getApplicationId());\n+          application.getAppAttemptId());\n       Token\u003cApplicationTokenIdentifier\u003e token \u003d\n           new Token\u003cApplicationTokenIdentifier\u003e(id,\n               this.applicationTokenSecretManager);\n       String schedulerAddressStr \u003d\n           this.conf.get(YarnConfiguration.RM_SCHEDULER_ADDRESS,\n               YarnConfiguration.DEFAULT_RM_SCHEDULER_ADDRESS);\n       InetSocketAddress unresolvedAddr \u003d\n           NetUtils.createSocketAddr(schedulerAddressStr);\n       String resolvedAddr \u003d\n           unresolvedAddr.getAddress().getHostAddress() + \":\"\n               + unresolvedAddr.getPort();\n       token.setService(new Text(resolvedAddr));\n       String appMasterTokenEncoded \u003d token.encodeToUrlString();\n       LOG.debug(\"Putting appMaster token in env : \" + appMasterTokenEncoded);\n       environment.put(\n           ApplicationConstants.APPLICATION_MASTER_TOKEN_ENV_NAME,\n           appMasterTokenEncoded);\n \n       // Add the RM token\n       credentials.addToken(new Text(resolvedAddr), token);\n       DataOutputBuffer dob \u003d new DataOutputBuffer();\n       credentials.writeTokenStorageToStream(dob);\n       container.setContainerTokens(\n           ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n \n-      ApplicationTokenIdentifier identifier \u003d new ApplicationTokenIdentifier(\n+      ClientTokenIdentifier identifier \u003d new ClientTokenIdentifier(\n           application.getAppAttemptId().getApplicationId());\n       SecretKey clientSecretKey \u003d\n           this.clientToAMSecretManager.getMasterKey(identifier);\n       String encoded \u003d\n           Base64.encodeBase64URLSafeString(clientSecretKey.getEncoded());\n       LOG.debug(\"The encoded client secret-key to be put in env : \" + encoded);\n       environment.put(\n           ApplicationConstants.APPLICATION_CLIENT_SECRET_ENV_NAME, \n           encoded);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void setupTokensAndEnv(\n      ContainerLaunchContext container)\n      throws IOException {\n    Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n\n    environment.put(ApplicationConstants.APPLICATION_WEB_PROXY_BASE_ENV,\n        application.getWebProxyBase());\n    // Set the AppAttemptId, containerId, NMHTTPAdress, AppSubmitTime to be\n    // consumable by the AM.\n    environment.put(ApplicationConstants.AM_CONTAINER_ID_ENV, container\n        .getContainerId().toString());\n    environment.put(ApplicationConstants.NM_HTTP_ADDRESS_ENV, application\n        .getMasterContainer().getNodeHttpAddress());\n    environment.put(\n        ApplicationConstants.APP_SUBMIT_TIME_ENV,\n        String.valueOf(rmContext.getRMApps()\n            .get(application.getAppAttemptId().getApplicationId())\n            .getSubmitTime()));\n \n    if (UserGroupInformation.isSecurityEnabled()) {\n      // TODO: Security enabled/disabled info should come from RM.\n\n      Credentials credentials \u003d new Credentials();\n\n      DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n      if (container.getContainerTokens() !\u003d null) {\n        // TODO: Don\u0027t do this kind of checks everywhere.\n        dibb.reset(container.getContainerTokens());\n        credentials.readTokenStorageStream(dibb);\n      }\n\n      ApplicationTokenIdentifier id \u003d new ApplicationTokenIdentifier(\n          application.getAppAttemptId());\n      Token\u003cApplicationTokenIdentifier\u003e token \u003d\n          new Token\u003cApplicationTokenIdentifier\u003e(id,\n              this.applicationTokenSecretManager);\n      String schedulerAddressStr \u003d\n          this.conf.get(YarnConfiguration.RM_SCHEDULER_ADDRESS,\n              YarnConfiguration.DEFAULT_RM_SCHEDULER_ADDRESS);\n      InetSocketAddress unresolvedAddr \u003d\n          NetUtils.createSocketAddr(schedulerAddressStr);\n      String resolvedAddr \u003d\n          unresolvedAddr.getAddress().getHostAddress() + \":\"\n              + unresolvedAddr.getPort();\n      token.setService(new Text(resolvedAddr));\n      String appMasterTokenEncoded \u003d token.encodeToUrlString();\n      LOG.debug(\"Putting appMaster token in env : \" + appMasterTokenEncoded);\n      environment.put(\n          ApplicationConstants.APPLICATION_MASTER_TOKEN_ENV_NAME,\n          appMasterTokenEncoded);\n\n      // Add the RM token\n      credentials.addToken(new Text(resolvedAddr), token);\n      DataOutputBuffer dob \u003d new DataOutputBuffer();\n      credentials.writeTokenStorageToStream(dob);\n      container.setContainerTokens(\n          ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n\n      ClientTokenIdentifier identifier \u003d new ClientTokenIdentifier(\n          application.getAppAttemptId().getApplicationId());\n      SecretKey clientSecretKey \u003d\n          this.clientToAMSecretManager.getMasterKey(identifier);\n      String encoded \u003d\n          Base64.encodeBase64URLSafeString(clientSecretKey.getEncoded());\n      LOG.debug(\"The encoded client secret-key to be put in env : \" + encoded);\n      environment.put(\n          ApplicationConstants.APPLICATION_CLIENT_SECRET_ENV_NAME, \n          encoded);\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/amlauncher/AMLauncher.java",
      "extendedDetails": {}
    },
    "8aabd3d4e67cad8dc7e46f5339981135badc7421": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2858. Added a WebApp Proxy for applications. Contributed by Robert Evans.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1189036 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/10/11 11:29 PM",
      "commitName": "8aabd3d4e67cad8dc7e46f5339981135badc7421",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "25/10/11 7:53 PM",
      "commitNameOld": "29c6c3ed328965a73fe7b68eb29cb30794beef38",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.15,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,68 +1,70 @@\n   private void setupTokensAndEnv(\n       ContainerLaunchContext container)\n       throws IOException {\n     Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n \n+    environment.put(ApplicationConstants.APPLICATION_WEB_PROXY_BASE_ENV,\n+        application.getWebProxyBase());\n     // Set the AppAttemptId, containerId, NMHTTPAdress, AppSubmitTime to be\n     // consumable by the AM.\n     environment.put(ApplicationConstants.AM_CONTAINER_ID_ENV, container\n         .getContainerId().toString());\n     environment.put(ApplicationConstants.NM_HTTP_ADDRESS_ENV, application\n         .getMasterContainer().getNodeHttpAddress());\n     environment.put(\n         ApplicationConstants.APP_SUBMIT_TIME_ENV,\n         String.valueOf(rmContext.getRMApps()\n             .get(application.getAppAttemptId().getApplicationId())\n             .getSubmitTime()));\n  \n     if (UserGroupInformation.isSecurityEnabled()) {\n       // TODO: Security enabled/disabled info should come from RM.\n \n       Credentials credentials \u003d new Credentials();\n \n       DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n       if (container.getContainerTokens() !\u003d null) {\n         // TODO: Don\u0027t do this kind of checks everywhere.\n         dibb.reset(container.getContainerTokens());\n         credentials.readTokenStorageStream(dibb);\n       }\n \n       ApplicationTokenIdentifier id \u003d new ApplicationTokenIdentifier(\n           application.getAppAttemptId().getApplicationId());\n       Token\u003cApplicationTokenIdentifier\u003e token \u003d\n           new Token\u003cApplicationTokenIdentifier\u003e(id,\n               this.applicationTokenSecretManager);\n       String schedulerAddressStr \u003d\n           this.conf.get(YarnConfiguration.RM_SCHEDULER_ADDRESS,\n               YarnConfiguration.DEFAULT_RM_SCHEDULER_ADDRESS);\n       InetSocketAddress unresolvedAddr \u003d\n           NetUtils.createSocketAddr(schedulerAddressStr);\n       String resolvedAddr \u003d\n           unresolvedAddr.getAddress().getHostAddress() + \":\"\n               + unresolvedAddr.getPort();\n       token.setService(new Text(resolvedAddr));\n       String appMasterTokenEncoded \u003d token.encodeToUrlString();\n       LOG.debug(\"Putting appMaster token in env : \" + appMasterTokenEncoded);\n       environment.put(\n           ApplicationConstants.APPLICATION_MASTER_TOKEN_ENV_NAME,\n           appMasterTokenEncoded);\n \n       // Add the RM token\n       credentials.addToken(new Text(resolvedAddr), token);\n       DataOutputBuffer dob \u003d new DataOutputBuffer();\n       credentials.writeTokenStorageToStream(dob);\n       container.setContainerTokens(\n           ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n \n       ApplicationTokenIdentifier identifier \u003d new ApplicationTokenIdentifier(\n           application.getAppAttemptId().getApplicationId());\n       SecretKey clientSecretKey \u003d\n           this.clientToAMSecretManager.getMasterKey(identifier);\n       String encoded \u003d\n           Base64.encodeBase64URLSafeString(clientSecretKey.getEncoded());\n       LOG.debug(\"The encoded client secret-key to be put in env : \" + encoded);\n       environment.put(\n           ApplicationConstants.APPLICATION_CLIENT_SECRET_ENV_NAME, \n           encoded);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void setupTokensAndEnv(\n      ContainerLaunchContext container)\n      throws IOException {\n    Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n\n    environment.put(ApplicationConstants.APPLICATION_WEB_PROXY_BASE_ENV,\n        application.getWebProxyBase());\n    // Set the AppAttemptId, containerId, NMHTTPAdress, AppSubmitTime to be\n    // consumable by the AM.\n    environment.put(ApplicationConstants.AM_CONTAINER_ID_ENV, container\n        .getContainerId().toString());\n    environment.put(ApplicationConstants.NM_HTTP_ADDRESS_ENV, application\n        .getMasterContainer().getNodeHttpAddress());\n    environment.put(\n        ApplicationConstants.APP_SUBMIT_TIME_ENV,\n        String.valueOf(rmContext.getRMApps()\n            .get(application.getAppAttemptId().getApplicationId())\n            .getSubmitTime()));\n \n    if (UserGroupInformation.isSecurityEnabled()) {\n      // TODO: Security enabled/disabled info should come from RM.\n\n      Credentials credentials \u003d new Credentials();\n\n      DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n      if (container.getContainerTokens() !\u003d null) {\n        // TODO: Don\u0027t do this kind of checks everywhere.\n        dibb.reset(container.getContainerTokens());\n        credentials.readTokenStorageStream(dibb);\n      }\n\n      ApplicationTokenIdentifier id \u003d new ApplicationTokenIdentifier(\n          application.getAppAttemptId().getApplicationId());\n      Token\u003cApplicationTokenIdentifier\u003e token \u003d\n          new Token\u003cApplicationTokenIdentifier\u003e(id,\n              this.applicationTokenSecretManager);\n      String schedulerAddressStr \u003d\n          this.conf.get(YarnConfiguration.RM_SCHEDULER_ADDRESS,\n              YarnConfiguration.DEFAULT_RM_SCHEDULER_ADDRESS);\n      InetSocketAddress unresolvedAddr \u003d\n          NetUtils.createSocketAddr(schedulerAddressStr);\n      String resolvedAddr \u003d\n          unresolvedAddr.getAddress().getHostAddress() + \":\"\n              + unresolvedAddr.getPort();\n      token.setService(new Text(resolvedAddr));\n      String appMasterTokenEncoded \u003d token.encodeToUrlString();\n      LOG.debug(\"Putting appMaster token in env : \" + appMasterTokenEncoded);\n      environment.put(\n          ApplicationConstants.APPLICATION_MASTER_TOKEN_ENV_NAME,\n          appMasterTokenEncoded);\n\n      // Add the RM token\n      credentials.addToken(new Text(resolvedAddr), token);\n      DataOutputBuffer dob \u003d new DataOutputBuffer();\n      credentials.writeTokenStorageToStream(dob);\n      container.setContainerTokens(\n          ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n\n      ApplicationTokenIdentifier identifier \u003d new ApplicationTokenIdentifier(\n          application.getAppAttemptId().getApplicationId());\n      SecretKey clientSecretKey \u003d\n          this.clientToAMSecretManager.getMasterKey(identifier);\n      String encoded \u003d\n          Base64.encodeBase64URLSafeString(clientSecretKey.getEncoded());\n      LOG.debug(\"The encoded client secret-key to be put in env : \" + encoded);\n      environment.put(\n          ApplicationConstants.APPLICATION_CLIENT_SECRET_ENV_NAME, \n          encoded);\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/amlauncher/AMLauncher.java",
      "extendedDetails": {}
    },
    "13e4562924a6cb3d16c262e0f595b2ffbf9e0546": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3144. Augmented JobHistory with the information needed for serving aggregated logs. Contributed by Siddharth Seth.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1185976 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/10/11 10:21 PM",
      "commitName": "13e4562924a6cb3d16c262e0f595b2ffbf9e0546",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "05/10/11 4:43 AM",
      "commitNameOld": "66137cf17cb4abccd6065819d97edc63c6510477",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 13.73,
      "commitsBetweenForRepo": 107,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,60 +1,69 @@\n   private void setupTokensAndEnv(\n       ContainerLaunchContext container)\n       throws IOException {\n     Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n \n-    // Set the AppAttemptId to be consumable by the AM.\n-    environment.put(ApplicationConstants.APPLICATION_ATTEMPT_ID_ENV,\n-        application.getAppAttemptId().toString());\n+    // Set the AppAttemptId, containerId, NMHTTPAdress, AppSubmitTime to be\n+    // consumable by the AM.\n+    environment.put(ApplicationConstants.AM_CONTAINER_ID_ENV, container\n+        .getContainerId().toString());\n+    environment.put(ApplicationConstants.NM_HTTP_ADDRESS_ENV, application\n+        .getMasterContainer().getNodeHttpAddress());\n+    environment.put(\n+        ApplicationConstants.APP_SUBMIT_TIME_ENV,\n+        String.valueOf(rmContext.getRMApps()\n+            .get(application.getAppAttemptId().getApplicationId())\n+            .getSubmitTime()));\n+    \n \n     if (UserGroupInformation.isSecurityEnabled()) {\n       // TODO: Security enabled/disabled info should come from RM.\n \n       Credentials credentials \u003d new Credentials();\n \n       DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n       if (container.getContainerTokens() !\u003d null) {\n         // TODO: Don\u0027t do this kind of checks everywhere.\n         dibb.reset(container.getContainerTokens());\n         credentials.readTokenStorageStream(dibb);\n       }\n \n       ApplicationTokenIdentifier id \u003d new ApplicationTokenIdentifier(\n           application.getAppAttemptId().getApplicationId());\n       Token\u003cApplicationTokenIdentifier\u003e token \u003d\n           new Token\u003cApplicationTokenIdentifier\u003e(id,\n               this.applicationTokenSecretManager);\n       String schedulerAddressStr \u003d\n           this.conf.get(YarnConfiguration.RM_SCHEDULER_ADDRESS,\n               YarnConfiguration.DEFAULT_RM_SCHEDULER_ADDRESS);\n       InetSocketAddress unresolvedAddr \u003d\n           NetUtils.createSocketAddr(schedulerAddressStr);\n       String resolvedAddr \u003d\n           unresolvedAddr.getAddress().getHostAddress() + \":\"\n               + unresolvedAddr.getPort();\n       token.setService(new Text(resolvedAddr));\n       String appMasterTokenEncoded \u003d token.encodeToUrlString();\n       LOG.debug(\"Putting appMaster token in env : \" + appMasterTokenEncoded);\n       environment.put(\n           ApplicationConstants.APPLICATION_MASTER_TOKEN_ENV_NAME,\n           appMasterTokenEncoded);\n \n       // Add the RM token\n       credentials.addToken(new Text(resolvedAddr), token);\n       DataOutputBuffer dob \u003d new DataOutputBuffer();\n       credentials.writeTokenStorageToStream(dob);\n       container.setContainerTokens(\n           ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n \n       ApplicationTokenIdentifier identifier \u003d new ApplicationTokenIdentifier(\n           application.getAppAttemptId().getApplicationId());\n       SecretKey clientSecretKey \u003d\n           this.clientToAMSecretManager.getMasterKey(identifier);\n       String encoded \u003d\n           Base64.encodeBase64URLSafeString(clientSecretKey.getEncoded());\n       LOG.debug(\"The encoded client secret-key to be put in env : \" + encoded);\n       environment.put(\n           ApplicationConstants.APPLICATION_CLIENT_SECRET_ENV_NAME, \n           encoded);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void setupTokensAndEnv(\n      ContainerLaunchContext container)\n      throws IOException {\n    Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n\n    // Set the AppAttemptId, containerId, NMHTTPAdress, AppSubmitTime to be\n    // consumable by the AM.\n    environment.put(ApplicationConstants.AM_CONTAINER_ID_ENV, container\n        .getContainerId().toString());\n    environment.put(ApplicationConstants.NM_HTTP_ADDRESS_ENV, application\n        .getMasterContainer().getNodeHttpAddress());\n    environment.put(\n        ApplicationConstants.APP_SUBMIT_TIME_ENV,\n        String.valueOf(rmContext.getRMApps()\n            .get(application.getAppAttemptId().getApplicationId())\n            .getSubmitTime()));\n    \n\n    if (UserGroupInformation.isSecurityEnabled()) {\n      // TODO: Security enabled/disabled info should come from RM.\n\n      Credentials credentials \u003d new Credentials();\n\n      DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n      if (container.getContainerTokens() !\u003d null) {\n        // TODO: Don\u0027t do this kind of checks everywhere.\n        dibb.reset(container.getContainerTokens());\n        credentials.readTokenStorageStream(dibb);\n      }\n\n      ApplicationTokenIdentifier id \u003d new ApplicationTokenIdentifier(\n          application.getAppAttemptId().getApplicationId());\n      Token\u003cApplicationTokenIdentifier\u003e token \u003d\n          new Token\u003cApplicationTokenIdentifier\u003e(id,\n              this.applicationTokenSecretManager);\n      String schedulerAddressStr \u003d\n          this.conf.get(YarnConfiguration.RM_SCHEDULER_ADDRESS,\n              YarnConfiguration.DEFAULT_RM_SCHEDULER_ADDRESS);\n      InetSocketAddress unresolvedAddr \u003d\n          NetUtils.createSocketAddr(schedulerAddressStr);\n      String resolvedAddr \u003d\n          unresolvedAddr.getAddress().getHostAddress() + \":\"\n              + unresolvedAddr.getPort();\n      token.setService(new Text(resolvedAddr));\n      String appMasterTokenEncoded \u003d token.encodeToUrlString();\n      LOG.debug(\"Putting appMaster token in env : \" + appMasterTokenEncoded);\n      environment.put(\n          ApplicationConstants.APPLICATION_MASTER_TOKEN_ENV_NAME,\n          appMasterTokenEncoded);\n\n      // Add the RM token\n      credentials.addToken(new Text(resolvedAddr), token);\n      DataOutputBuffer dob \u003d new DataOutputBuffer();\n      credentials.writeTokenStorageToStream(dob);\n      container.setContainerTokens(\n          ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n\n      ApplicationTokenIdentifier identifier \u003d new ApplicationTokenIdentifier(\n          application.getAppAttemptId().getApplicationId());\n      SecretKey clientSecretKey \u003d\n          this.clientToAMSecretManager.getMasterKey(identifier);\n      String encoded \u003d\n          Base64.encodeBase64URLSafeString(clientSecretKey.getEncoded());\n      LOG.debug(\"The encoded client secret-key to be put in env : \" + encoded);\n      environment.put(\n          ApplicationConstants.APPLICATION_CLIENT_SECRET_ENV_NAME, \n          encoded);\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/amlauncher/AMLauncher.java",
      "extendedDetails": {}
    },
    "b549c107825581b15fd14494099a943ff3213c6f": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3055. Simplified ApplicationAttemptId passing to ApplicationMaster via environment variable. (vinodkv)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1174785 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/09/11 7:07 AM",
      "commitName": "b549c107825581b15fd14494099a943ff3213c6f",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "14/09/11 12:26 AM",
      "commitNameOld": "88b82a0f6687ce103817fbb460fd30d870f717a0",
      "commitAuthorOld": "Mahadev Konar",
      "daysBetweenCommits": 9.28,
      "commitsBetweenForRepo": 62,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,55 +1,60 @@\n   private void setupTokensAndEnv(\n       ContainerLaunchContext container)\n       throws IOException {\n     Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n+\n+    // Set the AppAttemptId to be consumable by the AM.\n+    environment.put(ApplicationConstants.APPLICATION_ATTEMPT_ID_ENV,\n+        application.getAppAttemptId().toString());\n+\n     if (UserGroupInformation.isSecurityEnabled()) {\n       // TODO: Security enabled/disabled info should come from RM.\n \n       Credentials credentials \u003d new Credentials();\n \n       DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n       if (container.getContainerTokens() !\u003d null) {\n         // TODO: Don\u0027t do this kind of checks everywhere.\n         dibb.reset(container.getContainerTokens());\n         credentials.readTokenStorageStream(dibb);\n       }\n \n       ApplicationTokenIdentifier id \u003d new ApplicationTokenIdentifier(\n           application.getAppAttemptId().getApplicationId());\n       Token\u003cApplicationTokenIdentifier\u003e token \u003d\n           new Token\u003cApplicationTokenIdentifier\u003e(id,\n               this.applicationTokenSecretManager);\n       String schedulerAddressStr \u003d\n           this.conf.get(YarnConfiguration.RM_SCHEDULER_ADDRESS,\n               YarnConfiguration.DEFAULT_RM_SCHEDULER_ADDRESS);\n       InetSocketAddress unresolvedAddr \u003d\n           NetUtils.createSocketAddr(schedulerAddressStr);\n       String resolvedAddr \u003d\n           unresolvedAddr.getAddress().getHostAddress() + \":\"\n               + unresolvedAddr.getPort();\n       token.setService(new Text(resolvedAddr));\n       String appMasterTokenEncoded \u003d token.encodeToUrlString();\n       LOG.debug(\"Putting appMaster token in env : \" + appMasterTokenEncoded);\n       environment.put(\n           ApplicationConstants.APPLICATION_MASTER_TOKEN_ENV_NAME,\n           appMasterTokenEncoded);\n \n       // Add the RM token\n       credentials.addToken(new Text(resolvedAddr), token);\n       DataOutputBuffer dob \u003d new DataOutputBuffer();\n       credentials.writeTokenStorageToStream(dob);\n       container.setContainerTokens(\n           ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n \n       ApplicationTokenIdentifier identifier \u003d new ApplicationTokenIdentifier(\n           application.getAppAttemptId().getApplicationId());\n       SecretKey clientSecretKey \u003d\n           this.clientToAMSecretManager.getMasterKey(identifier);\n       String encoded \u003d\n           Base64.encodeBase64URLSafeString(clientSecretKey.getEncoded());\n       LOG.debug(\"The encoded client secret-key to be put in env : \" + encoded);\n       environment.put(\n           ApplicationConstants.APPLICATION_CLIENT_SECRET_ENV_NAME, \n           encoded);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void setupTokensAndEnv(\n      ContainerLaunchContext container)\n      throws IOException {\n    Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n\n    // Set the AppAttemptId to be consumable by the AM.\n    environment.put(ApplicationConstants.APPLICATION_ATTEMPT_ID_ENV,\n        application.getAppAttemptId().toString());\n\n    if (UserGroupInformation.isSecurityEnabled()) {\n      // TODO: Security enabled/disabled info should come from RM.\n\n      Credentials credentials \u003d new Credentials();\n\n      DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n      if (container.getContainerTokens() !\u003d null) {\n        // TODO: Don\u0027t do this kind of checks everywhere.\n        dibb.reset(container.getContainerTokens());\n        credentials.readTokenStorageStream(dibb);\n      }\n\n      ApplicationTokenIdentifier id \u003d new ApplicationTokenIdentifier(\n          application.getAppAttemptId().getApplicationId());\n      Token\u003cApplicationTokenIdentifier\u003e token \u003d\n          new Token\u003cApplicationTokenIdentifier\u003e(id,\n              this.applicationTokenSecretManager);\n      String schedulerAddressStr \u003d\n          this.conf.get(YarnConfiguration.RM_SCHEDULER_ADDRESS,\n              YarnConfiguration.DEFAULT_RM_SCHEDULER_ADDRESS);\n      InetSocketAddress unresolvedAddr \u003d\n          NetUtils.createSocketAddr(schedulerAddressStr);\n      String resolvedAddr \u003d\n          unresolvedAddr.getAddress().getHostAddress() + \":\"\n              + unresolvedAddr.getPort();\n      token.setService(new Text(resolvedAddr));\n      String appMasterTokenEncoded \u003d token.encodeToUrlString();\n      LOG.debug(\"Putting appMaster token in env : \" + appMasterTokenEncoded);\n      environment.put(\n          ApplicationConstants.APPLICATION_MASTER_TOKEN_ENV_NAME,\n          appMasterTokenEncoded);\n\n      // Add the RM token\n      credentials.addToken(new Text(resolvedAddr), token);\n      DataOutputBuffer dob \u003d new DataOutputBuffer();\n      credentials.writeTokenStorageToStream(dob);\n      container.setContainerTokens(\n          ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n\n      ApplicationTokenIdentifier identifier \u003d new ApplicationTokenIdentifier(\n          application.getAppAttemptId().getApplicationId());\n      SecretKey clientSecretKey \u003d\n          this.clientToAMSecretManager.getMasterKey(identifier);\n      String encoded \u003d\n          Base64.encodeBase64URLSafeString(clientSecretKey.getEncoded());\n      LOG.debug(\"The encoded client secret-key to be put in env : \" + encoded);\n      environment.put(\n          ApplicationConstants.APPLICATION_CLIENT_SECRET_ENV_NAME, \n          encoded);\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/amlauncher/AMLauncher.java",
      "extendedDetails": {}
    },
    "88b82a0f6687ce103817fbb460fd30d870f717a0": {
      "type": "Ymultichange(Yrename,Yparameterchange,Yreturntypechange,Ybodychange)",
      "commitMessage": "MAPREDUCE-2899. Replace major parts of ApplicationSubmissionContext with a ContainerLaunchContext (Arun Murthy via mahadev)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1170459 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/09/11 12:26 AM",
      "commitName": "88b82a0f6687ce103817fbb460fd30d870f717a0",
      "commitAuthor": "Mahadev Konar",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "MAPREDUCE-2899. Replace major parts of ApplicationSubmissionContext with a ContainerLaunchContext (Arun Murthy via mahadev)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1170459 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "14/09/11 12:26 AM",
          "commitName": "88b82a0f6687ce103817fbb460fd30d870f717a0",
          "commitAuthor": "Mahadev Konar",
          "commitDateOld": "12/09/11 5:05 PM",
          "commitNameOld": "6165875dc6bf67d72fc3ce1d96dfc80ba312d4a1",
          "commitAuthorOld": "Arun Murthy",
          "daysBetweenCommits": 1.31,
          "commitsBetweenForRepo": 10,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,53 +1,55 @@\n-  private Map\u003cString, String\u003e setupTokensInEnv(\n-      ApplicationSubmissionContext asc)\n+  private void setupTokensAndEnv(\n+      ContainerLaunchContext container)\n       throws IOException {\n-    Map\u003cString, String\u003e env \u003d\n-      new HashMap\u003cString, String\u003e();\n+    Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n     if (UserGroupInformation.isSecurityEnabled()) {\n       // TODO: Security enabled/disabled info should come from RM.\n \n       Credentials credentials \u003d new Credentials();\n \n       DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n-      if (asc.getFsTokensTodo() !\u003d null) {\n+      if (container.getContainerTokens() !\u003d null) {\n         // TODO: Don\u0027t do this kind of checks everywhere.\n-        dibb.reset(asc.getFsTokensTodo());\n+        dibb.reset(container.getContainerTokens());\n         credentials.readTokenStorageStream(dibb);\n       }\n \n       ApplicationTokenIdentifier id \u003d new ApplicationTokenIdentifier(\n           application.getAppAttemptId().getApplicationId());\n       Token\u003cApplicationTokenIdentifier\u003e token \u003d\n           new Token\u003cApplicationTokenIdentifier\u003e(id,\n               this.applicationTokenSecretManager);\n       String schedulerAddressStr \u003d\n           this.conf.get(YarnConfiguration.RM_SCHEDULER_ADDRESS,\n               YarnConfiguration.DEFAULT_RM_SCHEDULER_ADDRESS);\n       InetSocketAddress unresolvedAddr \u003d\n           NetUtils.createSocketAddr(schedulerAddressStr);\n       String resolvedAddr \u003d\n           unresolvedAddr.getAddress().getHostAddress() + \":\"\n               + unresolvedAddr.getPort();\n       token.setService(new Text(resolvedAddr));\n       String appMasterTokenEncoded \u003d token.encodeToUrlString();\n       LOG.debug(\"Putting appMaster token in env : \" + appMasterTokenEncoded);\n-      env.put(ApplicationConstants.APPLICATION_MASTER_TOKEN_ENV_NAME,\n+      environment.put(\n+          ApplicationConstants.APPLICATION_MASTER_TOKEN_ENV_NAME,\n           appMasterTokenEncoded);\n \n       // Add the RM token\n       credentials.addToken(new Text(resolvedAddr), token);\n       DataOutputBuffer dob \u003d new DataOutputBuffer();\n       credentials.writeTokenStorageToStream(dob);\n-      asc.setFsTokensTodo(ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n+      container.setContainerTokens(\n+          ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n \n       ApplicationTokenIdentifier identifier \u003d new ApplicationTokenIdentifier(\n           application.getAppAttemptId().getApplicationId());\n       SecretKey clientSecretKey \u003d\n           this.clientToAMSecretManager.getMasterKey(identifier);\n       String encoded \u003d\n           Base64.encodeBase64URLSafeString(clientSecretKey.getEncoded());\n       LOG.debug(\"The encoded client secret-key to be put in env : \" + encoded);\n-      env.put(ApplicationConstants.APPLICATION_CLIENT_SECRET_ENV_NAME, encoded);\n+      environment.put(\n+          ApplicationConstants.APPLICATION_CLIENT_SECRET_ENV_NAME, \n+          encoded);\n     }\n-    return env;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void setupTokensAndEnv(\n      ContainerLaunchContext container)\n      throws IOException {\n    Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n    if (UserGroupInformation.isSecurityEnabled()) {\n      // TODO: Security enabled/disabled info should come from RM.\n\n      Credentials credentials \u003d new Credentials();\n\n      DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n      if (container.getContainerTokens() !\u003d null) {\n        // TODO: Don\u0027t do this kind of checks everywhere.\n        dibb.reset(container.getContainerTokens());\n        credentials.readTokenStorageStream(dibb);\n      }\n\n      ApplicationTokenIdentifier id \u003d new ApplicationTokenIdentifier(\n          application.getAppAttemptId().getApplicationId());\n      Token\u003cApplicationTokenIdentifier\u003e token \u003d\n          new Token\u003cApplicationTokenIdentifier\u003e(id,\n              this.applicationTokenSecretManager);\n      String schedulerAddressStr \u003d\n          this.conf.get(YarnConfiguration.RM_SCHEDULER_ADDRESS,\n              YarnConfiguration.DEFAULT_RM_SCHEDULER_ADDRESS);\n      InetSocketAddress unresolvedAddr \u003d\n          NetUtils.createSocketAddr(schedulerAddressStr);\n      String resolvedAddr \u003d\n          unresolvedAddr.getAddress().getHostAddress() + \":\"\n              + unresolvedAddr.getPort();\n      token.setService(new Text(resolvedAddr));\n      String appMasterTokenEncoded \u003d token.encodeToUrlString();\n      LOG.debug(\"Putting appMaster token in env : \" + appMasterTokenEncoded);\n      environment.put(\n          ApplicationConstants.APPLICATION_MASTER_TOKEN_ENV_NAME,\n          appMasterTokenEncoded);\n\n      // Add the RM token\n      credentials.addToken(new Text(resolvedAddr), token);\n      DataOutputBuffer dob \u003d new DataOutputBuffer();\n      credentials.writeTokenStorageToStream(dob);\n      container.setContainerTokens(\n          ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n\n      ApplicationTokenIdentifier identifier \u003d new ApplicationTokenIdentifier(\n          application.getAppAttemptId().getApplicationId());\n      SecretKey clientSecretKey \u003d\n          this.clientToAMSecretManager.getMasterKey(identifier);\n      String encoded \u003d\n          Base64.encodeBase64URLSafeString(clientSecretKey.getEncoded());\n      LOG.debug(\"The encoded client secret-key to be put in env : \" + encoded);\n      environment.put(\n          ApplicationConstants.APPLICATION_CLIENT_SECRET_ENV_NAME, \n          encoded);\n    }\n  }",
          "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/amlauncher/AMLauncher.java",
          "extendedDetails": {
            "oldValue": "setupTokensInEnv",
            "newValue": "setupTokensAndEnv"
          }
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "MAPREDUCE-2899. Replace major parts of ApplicationSubmissionContext with a ContainerLaunchContext (Arun Murthy via mahadev)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1170459 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "14/09/11 12:26 AM",
          "commitName": "88b82a0f6687ce103817fbb460fd30d870f717a0",
          "commitAuthor": "Mahadev Konar",
          "commitDateOld": "12/09/11 5:05 PM",
          "commitNameOld": "6165875dc6bf67d72fc3ce1d96dfc80ba312d4a1",
          "commitAuthorOld": "Arun Murthy",
          "daysBetweenCommits": 1.31,
          "commitsBetweenForRepo": 10,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,53 +1,55 @@\n-  private Map\u003cString, String\u003e setupTokensInEnv(\n-      ApplicationSubmissionContext asc)\n+  private void setupTokensAndEnv(\n+      ContainerLaunchContext container)\n       throws IOException {\n-    Map\u003cString, String\u003e env \u003d\n-      new HashMap\u003cString, String\u003e();\n+    Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n     if (UserGroupInformation.isSecurityEnabled()) {\n       // TODO: Security enabled/disabled info should come from RM.\n \n       Credentials credentials \u003d new Credentials();\n \n       DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n-      if (asc.getFsTokensTodo() !\u003d null) {\n+      if (container.getContainerTokens() !\u003d null) {\n         // TODO: Don\u0027t do this kind of checks everywhere.\n-        dibb.reset(asc.getFsTokensTodo());\n+        dibb.reset(container.getContainerTokens());\n         credentials.readTokenStorageStream(dibb);\n       }\n \n       ApplicationTokenIdentifier id \u003d new ApplicationTokenIdentifier(\n           application.getAppAttemptId().getApplicationId());\n       Token\u003cApplicationTokenIdentifier\u003e token \u003d\n           new Token\u003cApplicationTokenIdentifier\u003e(id,\n               this.applicationTokenSecretManager);\n       String schedulerAddressStr \u003d\n           this.conf.get(YarnConfiguration.RM_SCHEDULER_ADDRESS,\n               YarnConfiguration.DEFAULT_RM_SCHEDULER_ADDRESS);\n       InetSocketAddress unresolvedAddr \u003d\n           NetUtils.createSocketAddr(schedulerAddressStr);\n       String resolvedAddr \u003d\n           unresolvedAddr.getAddress().getHostAddress() + \":\"\n               + unresolvedAddr.getPort();\n       token.setService(new Text(resolvedAddr));\n       String appMasterTokenEncoded \u003d token.encodeToUrlString();\n       LOG.debug(\"Putting appMaster token in env : \" + appMasterTokenEncoded);\n-      env.put(ApplicationConstants.APPLICATION_MASTER_TOKEN_ENV_NAME,\n+      environment.put(\n+          ApplicationConstants.APPLICATION_MASTER_TOKEN_ENV_NAME,\n           appMasterTokenEncoded);\n \n       // Add the RM token\n       credentials.addToken(new Text(resolvedAddr), token);\n       DataOutputBuffer dob \u003d new DataOutputBuffer();\n       credentials.writeTokenStorageToStream(dob);\n-      asc.setFsTokensTodo(ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n+      container.setContainerTokens(\n+          ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n \n       ApplicationTokenIdentifier identifier \u003d new ApplicationTokenIdentifier(\n           application.getAppAttemptId().getApplicationId());\n       SecretKey clientSecretKey \u003d\n           this.clientToAMSecretManager.getMasterKey(identifier);\n       String encoded \u003d\n           Base64.encodeBase64URLSafeString(clientSecretKey.getEncoded());\n       LOG.debug(\"The encoded client secret-key to be put in env : \" + encoded);\n-      env.put(ApplicationConstants.APPLICATION_CLIENT_SECRET_ENV_NAME, encoded);\n+      environment.put(\n+          ApplicationConstants.APPLICATION_CLIENT_SECRET_ENV_NAME, \n+          encoded);\n     }\n-    return env;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void setupTokensAndEnv(\n      ContainerLaunchContext container)\n      throws IOException {\n    Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n    if (UserGroupInformation.isSecurityEnabled()) {\n      // TODO: Security enabled/disabled info should come from RM.\n\n      Credentials credentials \u003d new Credentials();\n\n      DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n      if (container.getContainerTokens() !\u003d null) {\n        // TODO: Don\u0027t do this kind of checks everywhere.\n        dibb.reset(container.getContainerTokens());\n        credentials.readTokenStorageStream(dibb);\n      }\n\n      ApplicationTokenIdentifier id \u003d new ApplicationTokenIdentifier(\n          application.getAppAttemptId().getApplicationId());\n      Token\u003cApplicationTokenIdentifier\u003e token \u003d\n          new Token\u003cApplicationTokenIdentifier\u003e(id,\n              this.applicationTokenSecretManager);\n      String schedulerAddressStr \u003d\n          this.conf.get(YarnConfiguration.RM_SCHEDULER_ADDRESS,\n              YarnConfiguration.DEFAULT_RM_SCHEDULER_ADDRESS);\n      InetSocketAddress unresolvedAddr \u003d\n          NetUtils.createSocketAddr(schedulerAddressStr);\n      String resolvedAddr \u003d\n          unresolvedAddr.getAddress().getHostAddress() + \":\"\n              + unresolvedAddr.getPort();\n      token.setService(new Text(resolvedAddr));\n      String appMasterTokenEncoded \u003d token.encodeToUrlString();\n      LOG.debug(\"Putting appMaster token in env : \" + appMasterTokenEncoded);\n      environment.put(\n          ApplicationConstants.APPLICATION_MASTER_TOKEN_ENV_NAME,\n          appMasterTokenEncoded);\n\n      // Add the RM token\n      credentials.addToken(new Text(resolvedAddr), token);\n      DataOutputBuffer dob \u003d new DataOutputBuffer();\n      credentials.writeTokenStorageToStream(dob);\n      container.setContainerTokens(\n          ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n\n      ApplicationTokenIdentifier identifier \u003d new ApplicationTokenIdentifier(\n          application.getAppAttemptId().getApplicationId());\n      SecretKey clientSecretKey \u003d\n          this.clientToAMSecretManager.getMasterKey(identifier);\n      String encoded \u003d\n          Base64.encodeBase64URLSafeString(clientSecretKey.getEncoded());\n      LOG.debug(\"The encoded client secret-key to be put in env : \" + encoded);\n      environment.put(\n          ApplicationConstants.APPLICATION_CLIENT_SECRET_ENV_NAME, \n          encoded);\n    }\n  }",
          "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/amlauncher/AMLauncher.java",
          "extendedDetails": {
            "oldValue": "[asc-ApplicationSubmissionContext]",
            "newValue": "[container-ContainerLaunchContext]"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "MAPREDUCE-2899. Replace major parts of ApplicationSubmissionContext with a ContainerLaunchContext (Arun Murthy via mahadev)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1170459 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "14/09/11 12:26 AM",
          "commitName": "88b82a0f6687ce103817fbb460fd30d870f717a0",
          "commitAuthor": "Mahadev Konar",
          "commitDateOld": "12/09/11 5:05 PM",
          "commitNameOld": "6165875dc6bf67d72fc3ce1d96dfc80ba312d4a1",
          "commitAuthorOld": "Arun Murthy",
          "daysBetweenCommits": 1.31,
          "commitsBetweenForRepo": 10,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,53 +1,55 @@\n-  private Map\u003cString, String\u003e setupTokensInEnv(\n-      ApplicationSubmissionContext asc)\n+  private void setupTokensAndEnv(\n+      ContainerLaunchContext container)\n       throws IOException {\n-    Map\u003cString, String\u003e env \u003d\n-      new HashMap\u003cString, String\u003e();\n+    Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n     if (UserGroupInformation.isSecurityEnabled()) {\n       // TODO: Security enabled/disabled info should come from RM.\n \n       Credentials credentials \u003d new Credentials();\n \n       DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n-      if (asc.getFsTokensTodo() !\u003d null) {\n+      if (container.getContainerTokens() !\u003d null) {\n         // TODO: Don\u0027t do this kind of checks everywhere.\n-        dibb.reset(asc.getFsTokensTodo());\n+        dibb.reset(container.getContainerTokens());\n         credentials.readTokenStorageStream(dibb);\n       }\n \n       ApplicationTokenIdentifier id \u003d new ApplicationTokenIdentifier(\n           application.getAppAttemptId().getApplicationId());\n       Token\u003cApplicationTokenIdentifier\u003e token \u003d\n           new Token\u003cApplicationTokenIdentifier\u003e(id,\n               this.applicationTokenSecretManager);\n       String schedulerAddressStr \u003d\n           this.conf.get(YarnConfiguration.RM_SCHEDULER_ADDRESS,\n               YarnConfiguration.DEFAULT_RM_SCHEDULER_ADDRESS);\n       InetSocketAddress unresolvedAddr \u003d\n           NetUtils.createSocketAddr(schedulerAddressStr);\n       String resolvedAddr \u003d\n           unresolvedAddr.getAddress().getHostAddress() + \":\"\n               + unresolvedAddr.getPort();\n       token.setService(new Text(resolvedAddr));\n       String appMasterTokenEncoded \u003d token.encodeToUrlString();\n       LOG.debug(\"Putting appMaster token in env : \" + appMasterTokenEncoded);\n-      env.put(ApplicationConstants.APPLICATION_MASTER_TOKEN_ENV_NAME,\n+      environment.put(\n+          ApplicationConstants.APPLICATION_MASTER_TOKEN_ENV_NAME,\n           appMasterTokenEncoded);\n \n       // Add the RM token\n       credentials.addToken(new Text(resolvedAddr), token);\n       DataOutputBuffer dob \u003d new DataOutputBuffer();\n       credentials.writeTokenStorageToStream(dob);\n-      asc.setFsTokensTodo(ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n+      container.setContainerTokens(\n+          ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n \n       ApplicationTokenIdentifier identifier \u003d new ApplicationTokenIdentifier(\n           application.getAppAttemptId().getApplicationId());\n       SecretKey clientSecretKey \u003d\n           this.clientToAMSecretManager.getMasterKey(identifier);\n       String encoded \u003d\n           Base64.encodeBase64URLSafeString(clientSecretKey.getEncoded());\n       LOG.debug(\"The encoded client secret-key to be put in env : \" + encoded);\n-      env.put(ApplicationConstants.APPLICATION_CLIENT_SECRET_ENV_NAME, encoded);\n+      environment.put(\n+          ApplicationConstants.APPLICATION_CLIENT_SECRET_ENV_NAME, \n+          encoded);\n     }\n-    return env;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void setupTokensAndEnv(\n      ContainerLaunchContext container)\n      throws IOException {\n    Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n    if (UserGroupInformation.isSecurityEnabled()) {\n      // TODO: Security enabled/disabled info should come from RM.\n\n      Credentials credentials \u003d new Credentials();\n\n      DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n      if (container.getContainerTokens() !\u003d null) {\n        // TODO: Don\u0027t do this kind of checks everywhere.\n        dibb.reset(container.getContainerTokens());\n        credentials.readTokenStorageStream(dibb);\n      }\n\n      ApplicationTokenIdentifier id \u003d new ApplicationTokenIdentifier(\n          application.getAppAttemptId().getApplicationId());\n      Token\u003cApplicationTokenIdentifier\u003e token \u003d\n          new Token\u003cApplicationTokenIdentifier\u003e(id,\n              this.applicationTokenSecretManager);\n      String schedulerAddressStr \u003d\n          this.conf.get(YarnConfiguration.RM_SCHEDULER_ADDRESS,\n              YarnConfiguration.DEFAULT_RM_SCHEDULER_ADDRESS);\n      InetSocketAddress unresolvedAddr \u003d\n          NetUtils.createSocketAddr(schedulerAddressStr);\n      String resolvedAddr \u003d\n          unresolvedAddr.getAddress().getHostAddress() + \":\"\n              + unresolvedAddr.getPort();\n      token.setService(new Text(resolvedAddr));\n      String appMasterTokenEncoded \u003d token.encodeToUrlString();\n      LOG.debug(\"Putting appMaster token in env : \" + appMasterTokenEncoded);\n      environment.put(\n          ApplicationConstants.APPLICATION_MASTER_TOKEN_ENV_NAME,\n          appMasterTokenEncoded);\n\n      // Add the RM token\n      credentials.addToken(new Text(resolvedAddr), token);\n      DataOutputBuffer dob \u003d new DataOutputBuffer();\n      credentials.writeTokenStorageToStream(dob);\n      container.setContainerTokens(\n          ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n\n      ApplicationTokenIdentifier identifier \u003d new ApplicationTokenIdentifier(\n          application.getAppAttemptId().getApplicationId());\n      SecretKey clientSecretKey \u003d\n          this.clientToAMSecretManager.getMasterKey(identifier);\n      String encoded \u003d\n          Base64.encodeBase64URLSafeString(clientSecretKey.getEncoded());\n      LOG.debug(\"The encoded client secret-key to be put in env : \" + encoded);\n      environment.put(\n          ApplicationConstants.APPLICATION_CLIENT_SECRET_ENV_NAME, \n          encoded);\n    }\n  }",
          "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/amlauncher/AMLauncher.java",
          "extendedDetails": {
            "oldValue": "Map\u003cString,String\u003e",
            "newValue": "void"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "MAPREDUCE-2899. Replace major parts of ApplicationSubmissionContext with a ContainerLaunchContext (Arun Murthy via mahadev)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1170459 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "14/09/11 12:26 AM",
          "commitName": "88b82a0f6687ce103817fbb460fd30d870f717a0",
          "commitAuthor": "Mahadev Konar",
          "commitDateOld": "12/09/11 5:05 PM",
          "commitNameOld": "6165875dc6bf67d72fc3ce1d96dfc80ba312d4a1",
          "commitAuthorOld": "Arun Murthy",
          "daysBetweenCommits": 1.31,
          "commitsBetweenForRepo": 10,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,53 +1,55 @@\n-  private Map\u003cString, String\u003e setupTokensInEnv(\n-      ApplicationSubmissionContext asc)\n+  private void setupTokensAndEnv(\n+      ContainerLaunchContext container)\n       throws IOException {\n-    Map\u003cString, String\u003e env \u003d\n-      new HashMap\u003cString, String\u003e();\n+    Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n     if (UserGroupInformation.isSecurityEnabled()) {\n       // TODO: Security enabled/disabled info should come from RM.\n \n       Credentials credentials \u003d new Credentials();\n \n       DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n-      if (asc.getFsTokensTodo() !\u003d null) {\n+      if (container.getContainerTokens() !\u003d null) {\n         // TODO: Don\u0027t do this kind of checks everywhere.\n-        dibb.reset(asc.getFsTokensTodo());\n+        dibb.reset(container.getContainerTokens());\n         credentials.readTokenStorageStream(dibb);\n       }\n \n       ApplicationTokenIdentifier id \u003d new ApplicationTokenIdentifier(\n           application.getAppAttemptId().getApplicationId());\n       Token\u003cApplicationTokenIdentifier\u003e token \u003d\n           new Token\u003cApplicationTokenIdentifier\u003e(id,\n               this.applicationTokenSecretManager);\n       String schedulerAddressStr \u003d\n           this.conf.get(YarnConfiguration.RM_SCHEDULER_ADDRESS,\n               YarnConfiguration.DEFAULT_RM_SCHEDULER_ADDRESS);\n       InetSocketAddress unresolvedAddr \u003d\n           NetUtils.createSocketAddr(schedulerAddressStr);\n       String resolvedAddr \u003d\n           unresolvedAddr.getAddress().getHostAddress() + \":\"\n               + unresolvedAddr.getPort();\n       token.setService(new Text(resolvedAddr));\n       String appMasterTokenEncoded \u003d token.encodeToUrlString();\n       LOG.debug(\"Putting appMaster token in env : \" + appMasterTokenEncoded);\n-      env.put(ApplicationConstants.APPLICATION_MASTER_TOKEN_ENV_NAME,\n+      environment.put(\n+          ApplicationConstants.APPLICATION_MASTER_TOKEN_ENV_NAME,\n           appMasterTokenEncoded);\n \n       // Add the RM token\n       credentials.addToken(new Text(resolvedAddr), token);\n       DataOutputBuffer dob \u003d new DataOutputBuffer();\n       credentials.writeTokenStorageToStream(dob);\n-      asc.setFsTokensTodo(ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n+      container.setContainerTokens(\n+          ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n \n       ApplicationTokenIdentifier identifier \u003d new ApplicationTokenIdentifier(\n           application.getAppAttemptId().getApplicationId());\n       SecretKey clientSecretKey \u003d\n           this.clientToAMSecretManager.getMasterKey(identifier);\n       String encoded \u003d\n           Base64.encodeBase64URLSafeString(clientSecretKey.getEncoded());\n       LOG.debug(\"The encoded client secret-key to be put in env : \" + encoded);\n-      env.put(ApplicationConstants.APPLICATION_CLIENT_SECRET_ENV_NAME, encoded);\n+      environment.put(\n+          ApplicationConstants.APPLICATION_CLIENT_SECRET_ENV_NAME, \n+          encoded);\n     }\n-    return env;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void setupTokensAndEnv(\n      ContainerLaunchContext container)\n      throws IOException {\n    Map\u003cString, String\u003e environment \u003d container.getEnvironment();\n    if (UserGroupInformation.isSecurityEnabled()) {\n      // TODO: Security enabled/disabled info should come from RM.\n\n      Credentials credentials \u003d new Credentials();\n\n      DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n      if (container.getContainerTokens() !\u003d null) {\n        // TODO: Don\u0027t do this kind of checks everywhere.\n        dibb.reset(container.getContainerTokens());\n        credentials.readTokenStorageStream(dibb);\n      }\n\n      ApplicationTokenIdentifier id \u003d new ApplicationTokenIdentifier(\n          application.getAppAttemptId().getApplicationId());\n      Token\u003cApplicationTokenIdentifier\u003e token \u003d\n          new Token\u003cApplicationTokenIdentifier\u003e(id,\n              this.applicationTokenSecretManager);\n      String schedulerAddressStr \u003d\n          this.conf.get(YarnConfiguration.RM_SCHEDULER_ADDRESS,\n              YarnConfiguration.DEFAULT_RM_SCHEDULER_ADDRESS);\n      InetSocketAddress unresolvedAddr \u003d\n          NetUtils.createSocketAddr(schedulerAddressStr);\n      String resolvedAddr \u003d\n          unresolvedAddr.getAddress().getHostAddress() + \":\"\n              + unresolvedAddr.getPort();\n      token.setService(new Text(resolvedAddr));\n      String appMasterTokenEncoded \u003d token.encodeToUrlString();\n      LOG.debug(\"Putting appMaster token in env : \" + appMasterTokenEncoded);\n      environment.put(\n          ApplicationConstants.APPLICATION_MASTER_TOKEN_ENV_NAME,\n          appMasterTokenEncoded);\n\n      // Add the RM token\n      credentials.addToken(new Text(resolvedAddr), token);\n      DataOutputBuffer dob \u003d new DataOutputBuffer();\n      credentials.writeTokenStorageToStream(dob);\n      container.setContainerTokens(\n          ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n\n      ApplicationTokenIdentifier identifier \u003d new ApplicationTokenIdentifier(\n          application.getAppAttemptId().getApplicationId());\n      SecretKey clientSecretKey \u003d\n          this.clientToAMSecretManager.getMasterKey(identifier);\n      String encoded \u003d\n          Base64.encodeBase64URLSafeString(clientSecretKey.getEncoded());\n      LOG.debug(\"The encoded client secret-key to be put in env : \" + encoded);\n      environment.put(\n          ApplicationConstants.APPLICATION_CLIENT_SECRET_ENV_NAME, \n          encoded);\n    }\n  }",
          "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/amlauncher/AMLauncher.java",
          "extendedDetails": {}
        }
      ]
    },
    "fafe8cd28e726566509c679e19d7da622f29f90d": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2864. Normalize configuration variable names for YARN. Contributed by Robert Evans.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1166955 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/09/11 6:44 PM",
      "commitName": "fafe8cd28e726566509c679e19d7da622f29f90d",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:14 PM",
      "commitNameOld": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 15.06,
      "commitsBetweenForRepo": 86,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,53 @@\n   private Map\u003cString, String\u003e setupTokensInEnv(\n       ApplicationSubmissionContext asc)\n       throws IOException {\n     Map\u003cString, String\u003e env \u003d\n       new HashMap\u003cString, String\u003e();\n     if (UserGroupInformation.isSecurityEnabled()) {\n       // TODO: Security enabled/disabled info should come from RM.\n \n       Credentials credentials \u003d new Credentials();\n \n       DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n       if (asc.getFsTokensTodo() !\u003d null) {\n         // TODO: Don\u0027t do this kind of checks everywhere.\n         dibb.reset(asc.getFsTokensTodo());\n         credentials.readTokenStorageStream(dibb);\n       }\n \n       ApplicationTokenIdentifier id \u003d new ApplicationTokenIdentifier(\n           application.getAppAttemptId().getApplicationId());\n       Token\u003cApplicationTokenIdentifier\u003e token \u003d\n           new Token\u003cApplicationTokenIdentifier\u003e(id,\n               this.applicationTokenSecretManager);\n       String schedulerAddressStr \u003d\n-          this.conf.get(YarnConfiguration.SCHEDULER_ADDRESS,\n-              YarnConfiguration.DEFAULT_SCHEDULER_BIND_ADDRESS);\n+          this.conf.get(YarnConfiguration.RM_SCHEDULER_ADDRESS,\n+              YarnConfiguration.DEFAULT_RM_SCHEDULER_ADDRESS);\n       InetSocketAddress unresolvedAddr \u003d\n           NetUtils.createSocketAddr(schedulerAddressStr);\n       String resolvedAddr \u003d\n           unresolvedAddr.getAddress().getHostAddress() + \":\"\n               + unresolvedAddr.getPort();\n       token.setService(new Text(resolvedAddr));\n       String appMasterTokenEncoded \u003d token.encodeToUrlString();\n       LOG.debug(\"Putting appMaster token in env : \" + appMasterTokenEncoded);\n       env.put(ApplicationConstants.APPLICATION_MASTER_TOKEN_ENV_NAME,\n           appMasterTokenEncoded);\n \n       // Add the RM token\n       credentials.addToken(new Text(resolvedAddr), token);\n       DataOutputBuffer dob \u003d new DataOutputBuffer();\n       credentials.writeTokenStorageToStream(dob);\n       asc.setFsTokensTodo(ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n \n       ApplicationTokenIdentifier identifier \u003d new ApplicationTokenIdentifier(\n           application.getAppAttemptId().getApplicationId());\n       SecretKey clientSecretKey \u003d\n           this.clientToAMSecretManager.getMasterKey(identifier);\n       String encoded \u003d\n           Base64.encodeBase64URLSafeString(clientSecretKey.getEncoded());\n       LOG.debug(\"The encoded client secret-key to be put in env : \" + encoded);\n       env.put(ApplicationConstants.APPLICATION_CLIENT_SECRET_ENV_NAME, encoded);\n     }\n     return env;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Map\u003cString, String\u003e setupTokensInEnv(\n      ApplicationSubmissionContext asc)\n      throws IOException {\n    Map\u003cString, String\u003e env \u003d\n      new HashMap\u003cString, String\u003e();\n    if (UserGroupInformation.isSecurityEnabled()) {\n      // TODO: Security enabled/disabled info should come from RM.\n\n      Credentials credentials \u003d new Credentials();\n\n      DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n      if (asc.getFsTokensTodo() !\u003d null) {\n        // TODO: Don\u0027t do this kind of checks everywhere.\n        dibb.reset(asc.getFsTokensTodo());\n        credentials.readTokenStorageStream(dibb);\n      }\n\n      ApplicationTokenIdentifier id \u003d new ApplicationTokenIdentifier(\n          application.getAppAttemptId().getApplicationId());\n      Token\u003cApplicationTokenIdentifier\u003e token \u003d\n          new Token\u003cApplicationTokenIdentifier\u003e(id,\n              this.applicationTokenSecretManager);\n      String schedulerAddressStr \u003d\n          this.conf.get(YarnConfiguration.RM_SCHEDULER_ADDRESS,\n              YarnConfiguration.DEFAULT_RM_SCHEDULER_ADDRESS);\n      InetSocketAddress unresolvedAddr \u003d\n          NetUtils.createSocketAddr(schedulerAddressStr);\n      String resolvedAddr \u003d\n          unresolvedAddr.getAddress().getHostAddress() + \":\"\n              + unresolvedAddr.getPort();\n      token.setService(new Text(resolvedAddr));\n      String appMasterTokenEncoded \u003d token.encodeToUrlString();\n      LOG.debug(\"Putting appMaster token in env : \" + appMasterTokenEncoded);\n      env.put(ApplicationConstants.APPLICATION_MASTER_TOKEN_ENV_NAME,\n          appMasterTokenEncoded);\n\n      // Add the RM token\n      credentials.addToken(new Text(resolvedAddr), token);\n      DataOutputBuffer dob \u003d new DataOutputBuffer();\n      credentials.writeTokenStorageToStream(dob);\n      asc.setFsTokensTodo(ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n\n      ApplicationTokenIdentifier identifier \u003d new ApplicationTokenIdentifier(\n          application.getAppAttemptId().getApplicationId());\n      SecretKey clientSecretKey \u003d\n          this.clientToAMSecretManager.getMasterKey(identifier);\n      String encoded \u003d\n          Base64.encodeBase64URLSafeString(clientSecretKey.getEncoded());\n      LOG.debug(\"The encoded client secret-key to be put in env : \" + encoded);\n      env.put(ApplicationConstants.APPLICATION_CLIENT_SECRET_ENV_NAME, encoded);\n    }\n    return env;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/amlauncher/AMLauncher.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private Map\u003cString, String\u003e setupTokensInEnv(\n      ApplicationSubmissionContext asc)\n      throws IOException {\n    Map\u003cString, String\u003e env \u003d\n      new HashMap\u003cString, String\u003e();\n    if (UserGroupInformation.isSecurityEnabled()) {\n      // TODO: Security enabled/disabled info should come from RM.\n\n      Credentials credentials \u003d new Credentials();\n\n      DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n      if (asc.getFsTokensTodo() !\u003d null) {\n        // TODO: Don\u0027t do this kind of checks everywhere.\n        dibb.reset(asc.getFsTokensTodo());\n        credentials.readTokenStorageStream(dibb);\n      }\n\n      ApplicationTokenIdentifier id \u003d new ApplicationTokenIdentifier(\n          application.getAppAttemptId().getApplicationId());\n      Token\u003cApplicationTokenIdentifier\u003e token \u003d\n          new Token\u003cApplicationTokenIdentifier\u003e(id,\n              this.applicationTokenSecretManager);\n      String schedulerAddressStr \u003d\n          this.conf.get(YarnConfiguration.SCHEDULER_ADDRESS,\n              YarnConfiguration.DEFAULT_SCHEDULER_BIND_ADDRESS);\n      InetSocketAddress unresolvedAddr \u003d\n          NetUtils.createSocketAddr(schedulerAddressStr);\n      String resolvedAddr \u003d\n          unresolvedAddr.getAddress().getHostAddress() + \":\"\n              + unresolvedAddr.getPort();\n      token.setService(new Text(resolvedAddr));\n      String appMasterTokenEncoded \u003d token.encodeToUrlString();\n      LOG.debug(\"Putting appMaster token in env : \" + appMasterTokenEncoded);\n      env.put(ApplicationConstants.APPLICATION_MASTER_TOKEN_ENV_NAME,\n          appMasterTokenEncoded);\n\n      // Add the RM token\n      credentials.addToken(new Text(resolvedAddr), token);\n      DataOutputBuffer dob \u003d new DataOutputBuffer();\n      credentials.writeTokenStorageToStream(dob);\n      asc.setFsTokensTodo(ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n\n      ApplicationTokenIdentifier identifier \u003d new ApplicationTokenIdentifier(\n          application.getAppAttemptId().getApplicationId());\n      SecretKey clientSecretKey \u003d\n          this.clientToAMSecretManager.getMasterKey(identifier);\n      String encoded \u003d\n          Base64.encodeBase64URLSafeString(clientSecretKey.getEncoded());\n      LOG.debug(\"The encoded client secret-key to be put in env : \" + encoded);\n      env.put(ApplicationConstants.APPLICATION_CLIENT_SECRET_ENV_NAME, encoded);\n    }\n    return env;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/amlauncher/AMLauncher.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/amlauncher/AMLauncher.java",
        "newPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/amlauncher/AMLauncher.java"
      }
    },
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-279. MapReduce 2.0. Merging MR-279 branch into trunk. Contributed by Arun C Murthy, Christopher Douglas, Devaraj Das, Greg Roelofs, Jeffrey Naisbitt, Josh Wills, Jonathan Eagles, Krishna Ramachandran, Luke Lu, Mahadev Konar, Robert Evans, Sharad Agarwal, Siddharth Seth, Thomas Graves, and Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159166 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/08/11 4:07 AM",
      "commitName": "dbecbe5dfe50f834fc3b8401709079e9470cc517",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,53 @@\n+  private Map\u003cString, String\u003e setupTokensInEnv(\n+      ApplicationSubmissionContext asc)\n+      throws IOException {\n+    Map\u003cString, String\u003e env \u003d\n+      new HashMap\u003cString, String\u003e();\n+    if (UserGroupInformation.isSecurityEnabled()) {\n+      // TODO: Security enabled/disabled info should come from RM.\n+\n+      Credentials credentials \u003d new Credentials();\n+\n+      DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n+      if (asc.getFsTokensTodo() !\u003d null) {\n+        // TODO: Don\u0027t do this kind of checks everywhere.\n+        dibb.reset(asc.getFsTokensTodo());\n+        credentials.readTokenStorageStream(dibb);\n+      }\n+\n+      ApplicationTokenIdentifier id \u003d new ApplicationTokenIdentifier(\n+          application.getAppAttemptId().getApplicationId());\n+      Token\u003cApplicationTokenIdentifier\u003e token \u003d\n+          new Token\u003cApplicationTokenIdentifier\u003e(id,\n+              this.applicationTokenSecretManager);\n+      String schedulerAddressStr \u003d\n+          this.conf.get(YarnConfiguration.SCHEDULER_ADDRESS,\n+              YarnConfiguration.DEFAULT_SCHEDULER_BIND_ADDRESS);\n+      InetSocketAddress unresolvedAddr \u003d\n+          NetUtils.createSocketAddr(schedulerAddressStr);\n+      String resolvedAddr \u003d\n+          unresolvedAddr.getAddress().getHostAddress() + \":\"\n+              + unresolvedAddr.getPort();\n+      token.setService(new Text(resolvedAddr));\n+      String appMasterTokenEncoded \u003d token.encodeToUrlString();\n+      LOG.debug(\"Putting appMaster token in env : \" + appMasterTokenEncoded);\n+      env.put(ApplicationConstants.APPLICATION_MASTER_TOKEN_ENV_NAME,\n+          appMasterTokenEncoded);\n+\n+      // Add the RM token\n+      credentials.addToken(new Text(resolvedAddr), token);\n+      DataOutputBuffer dob \u003d new DataOutputBuffer();\n+      credentials.writeTokenStorageToStream(dob);\n+      asc.setFsTokensTodo(ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n+\n+      ApplicationTokenIdentifier identifier \u003d new ApplicationTokenIdentifier(\n+          application.getAppAttemptId().getApplicationId());\n+      SecretKey clientSecretKey \u003d\n+          this.clientToAMSecretManager.getMasterKey(identifier);\n+      String encoded \u003d\n+          Base64.encodeBase64URLSafeString(clientSecretKey.getEncoded());\n+      LOG.debug(\"The encoded client secret-key to be put in env : \" + encoded);\n+      env.put(ApplicationConstants.APPLICATION_CLIENT_SECRET_ENV_NAME, encoded);\n+    }\n+    return env;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private Map\u003cString, String\u003e setupTokensInEnv(\n      ApplicationSubmissionContext asc)\n      throws IOException {\n    Map\u003cString, String\u003e env \u003d\n      new HashMap\u003cString, String\u003e();\n    if (UserGroupInformation.isSecurityEnabled()) {\n      // TODO: Security enabled/disabled info should come from RM.\n\n      Credentials credentials \u003d new Credentials();\n\n      DataInputByteBuffer dibb \u003d new DataInputByteBuffer();\n      if (asc.getFsTokensTodo() !\u003d null) {\n        // TODO: Don\u0027t do this kind of checks everywhere.\n        dibb.reset(asc.getFsTokensTodo());\n        credentials.readTokenStorageStream(dibb);\n      }\n\n      ApplicationTokenIdentifier id \u003d new ApplicationTokenIdentifier(\n          application.getAppAttemptId().getApplicationId());\n      Token\u003cApplicationTokenIdentifier\u003e token \u003d\n          new Token\u003cApplicationTokenIdentifier\u003e(id,\n              this.applicationTokenSecretManager);\n      String schedulerAddressStr \u003d\n          this.conf.get(YarnConfiguration.SCHEDULER_ADDRESS,\n              YarnConfiguration.DEFAULT_SCHEDULER_BIND_ADDRESS);\n      InetSocketAddress unresolvedAddr \u003d\n          NetUtils.createSocketAddr(schedulerAddressStr);\n      String resolvedAddr \u003d\n          unresolvedAddr.getAddress().getHostAddress() + \":\"\n              + unresolvedAddr.getPort();\n      token.setService(new Text(resolvedAddr));\n      String appMasterTokenEncoded \u003d token.encodeToUrlString();\n      LOG.debug(\"Putting appMaster token in env : \" + appMasterTokenEncoded);\n      env.put(ApplicationConstants.APPLICATION_MASTER_TOKEN_ENV_NAME,\n          appMasterTokenEncoded);\n\n      // Add the RM token\n      credentials.addToken(new Text(resolvedAddr), token);\n      DataOutputBuffer dob \u003d new DataOutputBuffer();\n      credentials.writeTokenStorageToStream(dob);\n      asc.setFsTokensTodo(ByteBuffer.wrap(dob.getData(), 0, dob.getLength()));\n\n      ApplicationTokenIdentifier identifier \u003d new ApplicationTokenIdentifier(\n          application.getAppAttemptId().getApplicationId());\n      SecretKey clientSecretKey \u003d\n          this.clientToAMSecretManager.getMasterKey(identifier);\n      String encoded \u003d\n          Base64.encodeBase64URLSafeString(clientSecretKey.getEncoded());\n      LOG.debug(\"The encoded client secret-key to be put in env : \" + encoded);\n      env.put(ApplicationConstants.APPLICATION_CLIENT_SECRET_ENV_NAME, encoded);\n    }\n    return env;\n  }",
      "path": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/amlauncher/AMLauncher.java"
    }
  }
}