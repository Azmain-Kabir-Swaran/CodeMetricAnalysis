{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "GuaranteedOrZeroCapacityOverTimePolicy.java",
  "functionName": "computeQueueManagementChanges",
  "functionId": "computeQueueManagementChanges",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/queuemanagement/GuaranteedOrZeroCapacityOverTimePolicy.java",
  "functionStartLine": 358,
  "functionEndLine": 471,
  "numCommitsSeen": 7,
  "timeTaken": 3618,
  "changeHistory": [
    "cdb2107066a2d8557270888c0a9a75f29a6853bf",
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635",
    "344c335a920e6f32a35ebace0a118a9dc4a22fb7",
    "821b0de4c59156d4a65112de03ba3e7e1c88e309",
    "b38643c9a8dd2c53024ae830b9565a550d0ec39c"
  ],
  "changeHistoryShort": {
    "cdb2107066a2d8557270888c0a9a75f29a6853bf": "Ybodychange",
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635": "Ybodychange",
    "344c335a920e6f32a35ebace0a118a9dc4a22fb7": "Ybodychange",
    "821b0de4c59156d4a65112de03ba3e7e1c88e309": "Ybodychange",
    "b38643c9a8dd2c53024ae830b9565a550d0ec39c": "Yintroduced"
  },
  "changeHistoryDetails": {
    "cdb2107066a2d8557270888c0a9a75f29a6853bf": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9879. Allow multiple leaf queues with the same name in CapacityScheduler. Contributed by Gergely Pollak.\n",
      "commitDate": "25/03/20 4:20 AM",
      "commitName": "cdb2107066a2d8557270888c0a9a75f29a6853bf",
      "commitAuthor": "Sunil G",
      "commitDateOld": "18/03/19 10:57 AM",
      "commitNameOld": "5f6e22516668ff94a76737ad5e2cdcb2ff9f6dfd",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 372.72,
      "commitsBetweenForRepo": 2179,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,114 +1,114 @@\n   public List\u003cQueueManagementChange\u003e computeQueueManagementChanges()\n       throws SchedulerDynamicEditException {\n \n     //TODO : Add support for node labels on leaf queue template configurations\n     //synch/add missing leaf queue(s) if any to state\n     updateLeafQueueState();\n \n     readLock.lock();\n     try {\n       List\u003cQueueManagementChange\u003e queueManagementChanges \u003d new ArrayList\u003c\u003e();\n       List\u003cFiCaSchedulerApp\u003e pendingApps \u003d getSortedPendingApplications();\n \n       //Map of LeafQueue-\u003eQueueCapacities - keep adding the computed\n       // entitlements to this map and finally\n       // build the leaf queue configuration Template for all identified leaf\n       // queues\n       Map\u003cString, QueueCapacities\u003e leafQueueEntitlements \u003d new HashMap\u003c\u003e();\n       for (String nodeLabel : leafQueueTemplateNodeLabels) {\n         // check if any leaf queues need to be deactivated based on pending\n         // applications\n         float parentAbsoluteCapacity \u003d\n             managedParentQueue.getQueueCapacities().getAbsoluteCapacity(\n                 nodeLabel);\n         float leafQueueTemplateAbsoluteCapacity \u003d\n             leafQueueTemplateCapacities.getAbsoluteCapacity(nodeLabel);\n         Map\u003cString, QueueCapacities\u003e deactivatedLeafQueues \u003d\n             deactivateLeafQueuesIfInActive(managedParentQueue, nodeLabel,\n                 leafQueueEntitlements);\n \n         if (LOG.isDebugEnabled()) {\n           if ( deactivatedLeafQueues.size() \u003e 0) {\n               LOG.debug(\"Parent queue \u003d {},  \" +\n                    \", nodeLabel \u003d {}, deactivated leaf queues \u003d [{}] \",\n-                  managedParentQueue.getQueueName(), nodeLabel,\n+                  managedParentQueue.getQueuePath(), nodeLabel,\n                   deactivatedLeafQueues.size() \u003e 25 ? deactivatedLeafQueues\n                       .size() : deactivatedLeafQueues);\n \n           }\n         }\n \n         float deactivatedCapacity \u003d getTotalDeactivatedCapacity(\n             deactivatedLeafQueues, nodeLabel);\n \n         float sumOfChildQueueActivatedCapacity \u003d parentQueueState.\n             getAbsoluteActivatedChildQueueCapacity(nodeLabel);\n \n         //Check if we need to activate anything at all?\n         float availableCapacity \u003d\n             parentAbsoluteCapacity - sumOfChildQueueActivatedCapacity\n                 + deactivatedCapacity + EPSILON;\n \n         if (LOG.isDebugEnabled()) {\n-          LOG.debug(\"Parent queue \u003d \" + managedParentQueue.getQueueName()\n+          LOG.debug(\"Parent queue \u003d \" + managedParentQueue.getQueuePath()\n               + \", nodeLabel \u003d \" + nodeLabel + \", absCapacity \u003d \"\n               + parentAbsoluteCapacity + \", leafQueueAbsoluteCapacity \u003d \"\n               + leafQueueTemplateAbsoluteCapacity + \", deactivatedCapacity \u003d \"\n               + deactivatedCapacity + \" , absChildActivatedCapacity \u003d \"\n               + sumOfChildQueueActivatedCapacity + \", availableCapacity \u003d \"\n               + availableCapacity);\n         }\n \n         if (availableCapacity \u003e\u003d leafQueueTemplateAbsoluteCapacity) {\n           //sort applications across leaf queues by submit time\n           if (pendingApps.size() \u003e 0) {\n             int maxLeafQueuesTobeActivated \u003d getMaxLeavesToBeActivated(\n                 availableCapacity, leafQueueTemplateAbsoluteCapacity,\n                 pendingApps.size());\n \n             if (LOG.isDebugEnabled()) {\n-              LOG.debug(\"Parent queue \u003d \" + managedParentQueue.getQueueName()\n+              LOG.debug(\"Parent queue \u003d \" + managedParentQueue.getQueuePath()\n                   +  \" : Found \" + maxLeafQueuesTobeActivated + \" leaf queues\"\n                   + \" to be activated with \" + pendingApps.size() + \" apps \");\n             }\n \n             LinkedHashSet\u003cString\u003e leafQueuesToBeActivated \u003d getSortedLeafQueues(\n                 nodeLabel, pendingApps, maxLeafQueuesTobeActivated,\n                 deactivatedLeafQueues.keySet());\n \n             //Compute entitlement changes for the identified leaf queues\n             // which is appended to the List of computedEntitlements\n             updateLeafQueueCapacitiesByLabel(nodeLabel, leafQueuesToBeActivated,\n                 leafQueueEntitlements);\n \n             if (LOG.isDebugEnabled()) {\n               if (leafQueuesToBeActivated.size() \u003e 0) {\n                 LOG.debug(\"Activated leaf queues : [{}]\",\n                     leafQueuesToBeActivated.size() \u003c 25 ?\n                     leafQueuesToBeActivated : leafQueuesToBeActivated.size());\n               }\n             }\n           }\n         }\n       }\n \n       //Populate new entitlements\n \n       for (final Iterator\u003cMap.Entry\u003cString, QueueCapacities\u003e\u003e iterator \u003d\n            leafQueueEntitlements.entrySet().iterator(); iterator.hasNext(); ) {\n         Map.Entry\u003cString, QueueCapacities\u003e queueCapacities \u003d iterator.next();\n         String leafQueueName \u003d queueCapacities.getKey();\n         AutoCreatedLeafQueue leafQueue \u003d\n             (AutoCreatedLeafQueue) scheduler.getCapacitySchedulerQueueManager()\n                 .getQueue(leafQueueName);\n         AutoCreatedLeafQueueConfig newTemplate \u003d buildTemplate(\n             queueCapacities.getValue());\n         queueManagementChanges.add(\n             new QueueManagementChange.UpdateQueue(leafQueue, newTemplate));\n \n       }\n       return queueManagementChanges;\n     } finally {\n       readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public List\u003cQueueManagementChange\u003e computeQueueManagementChanges()\n      throws SchedulerDynamicEditException {\n\n    //TODO : Add support for node labels on leaf queue template configurations\n    //synch/add missing leaf queue(s) if any to state\n    updateLeafQueueState();\n\n    readLock.lock();\n    try {\n      List\u003cQueueManagementChange\u003e queueManagementChanges \u003d new ArrayList\u003c\u003e();\n      List\u003cFiCaSchedulerApp\u003e pendingApps \u003d getSortedPendingApplications();\n\n      //Map of LeafQueue-\u003eQueueCapacities - keep adding the computed\n      // entitlements to this map and finally\n      // build the leaf queue configuration Template for all identified leaf\n      // queues\n      Map\u003cString, QueueCapacities\u003e leafQueueEntitlements \u003d new HashMap\u003c\u003e();\n      for (String nodeLabel : leafQueueTemplateNodeLabels) {\n        // check if any leaf queues need to be deactivated based on pending\n        // applications\n        float parentAbsoluteCapacity \u003d\n            managedParentQueue.getQueueCapacities().getAbsoluteCapacity(\n                nodeLabel);\n        float leafQueueTemplateAbsoluteCapacity \u003d\n            leafQueueTemplateCapacities.getAbsoluteCapacity(nodeLabel);\n        Map\u003cString, QueueCapacities\u003e deactivatedLeafQueues \u003d\n            deactivateLeafQueuesIfInActive(managedParentQueue, nodeLabel,\n                leafQueueEntitlements);\n\n        if (LOG.isDebugEnabled()) {\n          if ( deactivatedLeafQueues.size() \u003e 0) {\n              LOG.debug(\"Parent queue \u003d {},  \" +\n                   \", nodeLabel \u003d {}, deactivated leaf queues \u003d [{}] \",\n                  managedParentQueue.getQueuePath(), nodeLabel,\n                  deactivatedLeafQueues.size() \u003e 25 ? deactivatedLeafQueues\n                      .size() : deactivatedLeafQueues);\n\n          }\n        }\n\n        float deactivatedCapacity \u003d getTotalDeactivatedCapacity(\n            deactivatedLeafQueues, nodeLabel);\n\n        float sumOfChildQueueActivatedCapacity \u003d parentQueueState.\n            getAbsoluteActivatedChildQueueCapacity(nodeLabel);\n\n        //Check if we need to activate anything at all?\n        float availableCapacity \u003d\n            parentAbsoluteCapacity - sumOfChildQueueActivatedCapacity\n                + deactivatedCapacity + EPSILON;\n\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Parent queue \u003d \" + managedParentQueue.getQueuePath()\n              + \", nodeLabel \u003d \" + nodeLabel + \", absCapacity \u003d \"\n              + parentAbsoluteCapacity + \", leafQueueAbsoluteCapacity \u003d \"\n              + leafQueueTemplateAbsoluteCapacity + \", deactivatedCapacity \u003d \"\n              + deactivatedCapacity + \" , absChildActivatedCapacity \u003d \"\n              + sumOfChildQueueActivatedCapacity + \", availableCapacity \u003d \"\n              + availableCapacity);\n        }\n\n        if (availableCapacity \u003e\u003d leafQueueTemplateAbsoluteCapacity) {\n          //sort applications across leaf queues by submit time\n          if (pendingApps.size() \u003e 0) {\n            int maxLeafQueuesTobeActivated \u003d getMaxLeavesToBeActivated(\n                availableCapacity, leafQueueTemplateAbsoluteCapacity,\n                pendingApps.size());\n\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Parent queue \u003d \" + managedParentQueue.getQueuePath()\n                  +  \" : Found \" + maxLeafQueuesTobeActivated + \" leaf queues\"\n                  + \" to be activated with \" + pendingApps.size() + \" apps \");\n            }\n\n            LinkedHashSet\u003cString\u003e leafQueuesToBeActivated \u003d getSortedLeafQueues(\n                nodeLabel, pendingApps, maxLeafQueuesTobeActivated,\n                deactivatedLeafQueues.keySet());\n\n            //Compute entitlement changes for the identified leaf queues\n            // which is appended to the List of computedEntitlements\n            updateLeafQueueCapacitiesByLabel(nodeLabel, leafQueuesToBeActivated,\n                leafQueueEntitlements);\n\n            if (LOG.isDebugEnabled()) {\n              if (leafQueuesToBeActivated.size() \u003e 0) {\n                LOG.debug(\"Activated leaf queues : [{}]\",\n                    leafQueuesToBeActivated.size() \u003c 25 ?\n                    leafQueuesToBeActivated : leafQueuesToBeActivated.size());\n              }\n            }\n          }\n        }\n      }\n\n      //Populate new entitlements\n\n      for (final Iterator\u003cMap.Entry\u003cString, QueueCapacities\u003e\u003e iterator \u003d\n           leafQueueEntitlements.entrySet().iterator(); iterator.hasNext(); ) {\n        Map.Entry\u003cString, QueueCapacities\u003e queueCapacities \u003d iterator.next();\n        String leafQueueName \u003d queueCapacities.getKey();\n        AutoCreatedLeafQueue leafQueue \u003d\n            (AutoCreatedLeafQueue) scheduler.getCapacitySchedulerQueueManager()\n                .getQueue(leafQueueName);\n        AutoCreatedLeafQueueConfig newTemplate \u003d buildTemplate(\n            queueCapacities.getValue());\n        queueManagementChanges.add(\n            new QueueManagementChange.UpdateQueue(leafQueue, newTemplate));\n\n      }\n      return queueManagementChanges;\n    } finally {\n      readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/queuemanagement/GuaranteedOrZeroCapacityOverTimePolicy.java",
      "extendedDetails": {}
    },
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9341.  Fixed enentrant lock usage in YARN project.\n            Contributed by Prabhu Joseph\n",
      "commitDate": "07/03/19 1:47 PM",
      "commitName": "39b4a37e02e929a698fcf9e32f1f71bb6b977635",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "09/08/18 11:04 AM",
      "commitNameOld": "344c335a920e6f32a35ebace0a118a9dc4a22fb7",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 210.16,
      "commitsBetweenForRepo": 1721,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,114 +1,114 @@\n   public List\u003cQueueManagementChange\u003e computeQueueManagementChanges()\n       throws SchedulerDynamicEditException {\n \n     //TODO : Add support for node labels on leaf queue template configurations\n     //synch/add missing leaf queue(s) if any to state\n     updateLeafQueueState();\n \n+    readLock.lock();\n     try {\n-      readLock.lock();\n       List\u003cQueueManagementChange\u003e queueManagementChanges \u003d new ArrayList\u003c\u003e();\n       List\u003cFiCaSchedulerApp\u003e pendingApps \u003d getSortedPendingApplications();\n \n       //Map of LeafQueue-\u003eQueueCapacities - keep adding the computed\n       // entitlements to this map and finally\n       // build the leaf queue configuration Template for all identified leaf\n       // queues\n       Map\u003cString, QueueCapacities\u003e leafQueueEntitlements \u003d new HashMap\u003c\u003e();\n       for (String nodeLabel : leafQueueTemplateNodeLabels) {\n         // check if any leaf queues need to be deactivated based on pending\n         // applications\n         float parentAbsoluteCapacity \u003d\n             managedParentQueue.getQueueCapacities().getAbsoluteCapacity(\n                 nodeLabel);\n         float leafQueueTemplateAbsoluteCapacity \u003d\n             leafQueueTemplateCapacities.getAbsoluteCapacity(nodeLabel);\n         Map\u003cString, QueueCapacities\u003e deactivatedLeafQueues \u003d\n             deactivateLeafQueuesIfInActive(managedParentQueue, nodeLabel,\n                 leafQueueEntitlements);\n \n         if (LOG.isDebugEnabled()) {\n           if ( deactivatedLeafQueues.size() \u003e 0) {\n               LOG.debug(\"Parent queue \u003d {},  \" +\n                    \", nodeLabel \u003d {}, deactivated leaf queues \u003d [{}] \",\n                   managedParentQueue.getQueueName(), nodeLabel,\n                   deactivatedLeafQueues.size() \u003e 25 ? deactivatedLeafQueues\n                       .size() : deactivatedLeafQueues);\n \n           }\n         }\n \n         float deactivatedCapacity \u003d getTotalDeactivatedCapacity(\n             deactivatedLeafQueues, nodeLabel);\n \n         float sumOfChildQueueActivatedCapacity \u003d parentQueueState.\n             getAbsoluteActivatedChildQueueCapacity(nodeLabel);\n \n         //Check if we need to activate anything at all?\n         float availableCapacity \u003d\n             parentAbsoluteCapacity - sumOfChildQueueActivatedCapacity\n                 + deactivatedCapacity + EPSILON;\n \n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Parent queue \u003d \" + managedParentQueue.getQueueName()\n               + \", nodeLabel \u003d \" + nodeLabel + \", absCapacity \u003d \"\n               + parentAbsoluteCapacity + \", leafQueueAbsoluteCapacity \u003d \"\n               + leafQueueTemplateAbsoluteCapacity + \", deactivatedCapacity \u003d \"\n               + deactivatedCapacity + \" , absChildActivatedCapacity \u003d \"\n               + sumOfChildQueueActivatedCapacity + \", availableCapacity \u003d \"\n               + availableCapacity);\n         }\n \n         if (availableCapacity \u003e\u003d leafQueueTemplateAbsoluteCapacity) {\n           //sort applications across leaf queues by submit time\n           if (pendingApps.size() \u003e 0) {\n             int maxLeafQueuesTobeActivated \u003d getMaxLeavesToBeActivated(\n                 availableCapacity, leafQueueTemplateAbsoluteCapacity,\n                 pendingApps.size());\n \n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"Parent queue \u003d \" + managedParentQueue.getQueueName()\n                   +  \" : Found \" + maxLeafQueuesTobeActivated + \" leaf queues\"\n                   + \" to be activated with \" + pendingApps.size() + \" apps \");\n             }\n \n             LinkedHashSet\u003cString\u003e leafQueuesToBeActivated \u003d getSortedLeafQueues(\n                 nodeLabel, pendingApps, maxLeafQueuesTobeActivated,\n                 deactivatedLeafQueues.keySet());\n \n             //Compute entitlement changes for the identified leaf queues\n             // which is appended to the List of computedEntitlements\n             updateLeafQueueCapacitiesByLabel(nodeLabel, leafQueuesToBeActivated,\n                 leafQueueEntitlements);\n \n             if (LOG.isDebugEnabled()) {\n               if (leafQueuesToBeActivated.size() \u003e 0) {\n                 LOG.debug(\"Activated leaf queues : [{}]\",\n                     leafQueuesToBeActivated.size() \u003c 25 ?\n                     leafQueuesToBeActivated : leafQueuesToBeActivated.size());\n               }\n             }\n           }\n         }\n       }\n \n       //Populate new entitlements\n \n       for (final Iterator\u003cMap.Entry\u003cString, QueueCapacities\u003e\u003e iterator \u003d\n            leafQueueEntitlements.entrySet().iterator(); iterator.hasNext(); ) {\n         Map.Entry\u003cString, QueueCapacities\u003e queueCapacities \u003d iterator.next();\n         String leafQueueName \u003d queueCapacities.getKey();\n         AutoCreatedLeafQueue leafQueue \u003d\n             (AutoCreatedLeafQueue) scheduler.getCapacitySchedulerQueueManager()\n                 .getQueue(leafQueueName);\n         AutoCreatedLeafQueueConfig newTemplate \u003d buildTemplate(\n             queueCapacities.getValue());\n         queueManagementChanges.add(\n             new QueueManagementChange.UpdateQueue(leafQueue, newTemplate));\n \n       }\n       return queueManagementChanges;\n     } finally {\n       readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public List\u003cQueueManagementChange\u003e computeQueueManagementChanges()\n      throws SchedulerDynamicEditException {\n\n    //TODO : Add support for node labels on leaf queue template configurations\n    //synch/add missing leaf queue(s) if any to state\n    updateLeafQueueState();\n\n    readLock.lock();\n    try {\n      List\u003cQueueManagementChange\u003e queueManagementChanges \u003d new ArrayList\u003c\u003e();\n      List\u003cFiCaSchedulerApp\u003e pendingApps \u003d getSortedPendingApplications();\n\n      //Map of LeafQueue-\u003eQueueCapacities - keep adding the computed\n      // entitlements to this map and finally\n      // build the leaf queue configuration Template for all identified leaf\n      // queues\n      Map\u003cString, QueueCapacities\u003e leafQueueEntitlements \u003d new HashMap\u003c\u003e();\n      for (String nodeLabel : leafQueueTemplateNodeLabels) {\n        // check if any leaf queues need to be deactivated based on pending\n        // applications\n        float parentAbsoluteCapacity \u003d\n            managedParentQueue.getQueueCapacities().getAbsoluteCapacity(\n                nodeLabel);\n        float leafQueueTemplateAbsoluteCapacity \u003d\n            leafQueueTemplateCapacities.getAbsoluteCapacity(nodeLabel);\n        Map\u003cString, QueueCapacities\u003e deactivatedLeafQueues \u003d\n            deactivateLeafQueuesIfInActive(managedParentQueue, nodeLabel,\n                leafQueueEntitlements);\n\n        if (LOG.isDebugEnabled()) {\n          if ( deactivatedLeafQueues.size() \u003e 0) {\n              LOG.debug(\"Parent queue \u003d {},  \" +\n                   \", nodeLabel \u003d {}, deactivated leaf queues \u003d [{}] \",\n                  managedParentQueue.getQueueName(), nodeLabel,\n                  deactivatedLeafQueues.size() \u003e 25 ? deactivatedLeafQueues\n                      .size() : deactivatedLeafQueues);\n\n          }\n        }\n\n        float deactivatedCapacity \u003d getTotalDeactivatedCapacity(\n            deactivatedLeafQueues, nodeLabel);\n\n        float sumOfChildQueueActivatedCapacity \u003d parentQueueState.\n            getAbsoluteActivatedChildQueueCapacity(nodeLabel);\n\n        //Check if we need to activate anything at all?\n        float availableCapacity \u003d\n            parentAbsoluteCapacity - sumOfChildQueueActivatedCapacity\n                + deactivatedCapacity + EPSILON;\n\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Parent queue \u003d \" + managedParentQueue.getQueueName()\n              + \", nodeLabel \u003d \" + nodeLabel + \", absCapacity \u003d \"\n              + parentAbsoluteCapacity + \", leafQueueAbsoluteCapacity \u003d \"\n              + leafQueueTemplateAbsoluteCapacity + \", deactivatedCapacity \u003d \"\n              + deactivatedCapacity + \" , absChildActivatedCapacity \u003d \"\n              + sumOfChildQueueActivatedCapacity + \", availableCapacity \u003d \"\n              + availableCapacity);\n        }\n\n        if (availableCapacity \u003e\u003d leafQueueTemplateAbsoluteCapacity) {\n          //sort applications across leaf queues by submit time\n          if (pendingApps.size() \u003e 0) {\n            int maxLeafQueuesTobeActivated \u003d getMaxLeavesToBeActivated(\n                availableCapacity, leafQueueTemplateAbsoluteCapacity,\n                pendingApps.size());\n\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Parent queue \u003d \" + managedParentQueue.getQueueName()\n                  +  \" : Found \" + maxLeafQueuesTobeActivated + \" leaf queues\"\n                  + \" to be activated with \" + pendingApps.size() + \" apps \");\n            }\n\n            LinkedHashSet\u003cString\u003e leafQueuesToBeActivated \u003d getSortedLeafQueues(\n                nodeLabel, pendingApps, maxLeafQueuesTobeActivated,\n                deactivatedLeafQueues.keySet());\n\n            //Compute entitlement changes for the identified leaf queues\n            // which is appended to the List of computedEntitlements\n            updateLeafQueueCapacitiesByLabel(nodeLabel, leafQueuesToBeActivated,\n                leafQueueEntitlements);\n\n            if (LOG.isDebugEnabled()) {\n              if (leafQueuesToBeActivated.size() \u003e 0) {\n                LOG.debug(\"Activated leaf queues : [{}]\",\n                    leafQueuesToBeActivated.size() \u003c 25 ?\n                    leafQueuesToBeActivated : leafQueuesToBeActivated.size());\n              }\n            }\n          }\n        }\n      }\n\n      //Populate new entitlements\n\n      for (final Iterator\u003cMap.Entry\u003cString, QueueCapacities\u003e\u003e iterator \u003d\n           leafQueueEntitlements.entrySet().iterator(); iterator.hasNext(); ) {\n        Map.Entry\u003cString, QueueCapacities\u003e queueCapacities \u003d iterator.next();\n        String leafQueueName \u003d queueCapacities.getKey();\n        AutoCreatedLeafQueue leafQueue \u003d\n            (AutoCreatedLeafQueue) scheduler.getCapacitySchedulerQueueManager()\n                .getQueue(leafQueueName);\n        AutoCreatedLeafQueueConfig newTemplate \u003d buildTemplate(\n            queueCapacities.getValue());\n        queueManagementChanges.add(\n            new QueueManagementChange.UpdateQueue(leafQueue, newTemplate));\n\n      }\n      return queueManagementChanges;\n    } finally {\n      readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/queuemanagement/GuaranteedOrZeroCapacityOverTimePolicy.java",
      "extendedDetails": {}
    },
    "344c335a920e6f32a35ebace0a118a9dc4a22fb7": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8588. Logging improvements for better debuggability. (Suma Shivaprasad via wangda)\n\nChange-Id: I66aa4b0ec031ae5ce0fae558e2f8cbcbbfebc442\n",
      "commitDate": "09/08/18 11:04 AM",
      "commitName": "344c335a920e6f32a35ebace0a118a9dc4a22fb7",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "09/04/18 8:47 AM",
      "commitNameOld": "821b0de4c59156d4a65112de03ba3e7e1c88e309",
      "commitAuthorOld": "Sunil G",
      "daysBetweenCommits": 122.09,
      "commitsBetweenForRepo": 1381,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,101 +1,114 @@\n   public List\u003cQueueManagementChange\u003e computeQueueManagementChanges()\n       throws SchedulerDynamicEditException {\n \n     //TODO : Add support for node labels on leaf queue template configurations\n     //synch/add missing leaf queue(s) if any to state\n     updateLeafQueueState();\n \n     try {\n       readLock.lock();\n       List\u003cQueueManagementChange\u003e queueManagementChanges \u003d new ArrayList\u003c\u003e();\n       List\u003cFiCaSchedulerApp\u003e pendingApps \u003d getSortedPendingApplications();\n \n       //Map of LeafQueue-\u003eQueueCapacities - keep adding the computed\n       // entitlements to this map and finally\n       // build the leaf queue configuration Template for all identified leaf\n       // queues\n       Map\u003cString, QueueCapacities\u003e leafQueueEntitlements \u003d new HashMap\u003c\u003e();\n       for (String nodeLabel : leafQueueTemplateNodeLabels) {\n         // check if any leaf queues need to be deactivated based on pending\n         // applications\n         float parentAbsoluteCapacity \u003d\n             managedParentQueue.getQueueCapacities().getAbsoluteCapacity(\n                 nodeLabel);\n         float leafQueueTemplateAbsoluteCapacity \u003d\n             leafQueueTemplateCapacities.getAbsoluteCapacity(nodeLabel);\n         Map\u003cString, QueueCapacities\u003e deactivatedLeafQueues \u003d\n             deactivateLeafQueuesIfInActive(managedParentQueue, nodeLabel,\n                 leafQueueEntitlements);\n \n+        if (LOG.isDebugEnabled()) {\n+          if ( deactivatedLeafQueues.size() \u003e 0) {\n+              LOG.debug(\"Parent queue \u003d {},  \" +\n+                   \", nodeLabel \u003d {}, deactivated leaf queues \u003d [{}] \",\n+                  managedParentQueue.getQueueName(), nodeLabel,\n+                  deactivatedLeafQueues.size() \u003e 25 ? deactivatedLeafQueues\n+                      .size() : deactivatedLeafQueues);\n+\n+          }\n+        }\n+\n         float deactivatedCapacity \u003d getTotalDeactivatedCapacity(\n             deactivatedLeafQueues, nodeLabel);\n \n         float sumOfChildQueueActivatedCapacity \u003d parentQueueState.\n             getAbsoluteActivatedChildQueueCapacity(nodeLabel);\n \n         //Check if we need to activate anything at all?\n         float availableCapacity \u003d\n             parentAbsoluteCapacity - sumOfChildQueueActivatedCapacity\n                 + deactivatedCapacity + EPSILON;\n \n         if (LOG.isDebugEnabled()) {\n-          LOG.debug(\"Parent queue : \" + managedParentQueue.getQueueName()\n+          LOG.debug(\"Parent queue \u003d \" + managedParentQueue.getQueueName()\n               + \", nodeLabel \u003d \" + nodeLabel + \", absCapacity \u003d \"\n               + parentAbsoluteCapacity + \", leafQueueAbsoluteCapacity \u003d \"\n               + leafQueueTemplateAbsoluteCapacity + \", deactivatedCapacity \u003d \"\n               + deactivatedCapacity + \" , absChildActivatedCapacity \u003d \"\n               + sumOfChildQueueActivatedCapacity + \", availableCapacity \u003d \"\n               + availableCapacity);\n         }\n \n         if (availableCapacity \u003e\u003d leafQueueTemplateAbsoluteCapacity) {\n           //sort applications across leaf queues by submit time\n           if (pendingApps.size() \u003e 0) {\n             int maxLeafQueuesTobeActivated \u003d getMaxLeavesToBeActivated(\n                 availableCapacity, leafQueueTemplateAbsoluteCapacity,\n                 pendingApps.size());\n \n             if (LOG.isDebugEnabled()) {\n-              LOG.debug(\"Found \" + maxLeafQueuesTobeActivated + \" leaf queues\"\n+              LOG.debug(\"Parent queue \u003d \" + managedParentQueue.getQueueName()\n+                  +  \" : Found \" + maxLeafQueuesTobeActivated + \" leaf queues\"\n                   + \" to be activated with \" + pendingApps.size() + \" apps \");\n             }\n \n             LinkedHashSet\u003cString\u003e leafQueuesToBeActivated \u003d getSortedLeafQueues(\n                 nodeLabel, pendingApps, maxLeafQueuesTobeActivated,\n                 deactivatedLeafQueues.keySet());\n \n             //Compute entitlement changes for the identified leaf queues\n             // which is appended to the List of computedEntitlements\n             updateLeafQueueCapacitiesByLabel(nodeLabel, leafQueuesToBeActivated,\n                 leafQueueEntitlements);\n \n             if (LOG.isDebugEnabled()) {\n               if (leafQueuesToBeActivated.size() \u003e 0) {\n-                LOG.debug(\"Activated leaf queues : [\" + leafQueuesToBeActivated\n-                    + \"]\");\n+                LOG.debug(\"Activated leaf queues : [{}]\",\n+                    leafQueuesToBeActivated.size() \u003c 25 ?\n+                    leafQueuesToBeActivated : leafQueuesToBeActivated.size());\n               }\n             }\n           }\n         }\n       }\n \n       //Populate new entitlements\n \n       for (final Iterator\u003cMap.Entry\u003cString, QueueCapacities\u003e\u003e iterator \u003d\n            leafQueueEntitlements.entrySet().iterator(); iterator.hasNext(); ) {\n         Map.Entry\u003cString, QueueCapacities\u003e queueCapacities \u003d iterator.next();\n         String leafQueueName \u003d queueCapacities.getKey();\n         AutoCreatedLeafQueue leafQueue \u003d\n             (AutoCreatedLeafQueue) scheduler.getCapacitySchedulerQueueManager()\n                 .getQueue(leafQueueName);\n         AutoCreatedLeafQueueConfig newTemplate \u003d buildTemplate(\n             queueCapacities.getValue());\n         queueManagementChanges.add(\n             new QueueManagementChange.UpdateQueue(leafQueue, newTemplate));\n \n       }\n       return queueManagementChanges;\n     } finally {\n       readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public List\u003cQueueManagementChange\u003e computeQueueManagementChanges()\n      throws SchedulerDynamicEditException {\n\n    //TODO : Add support for node labels on leaf queue template configurations\n    //synch/add missing leaf queue(s) if any to state\n    updateLeafQueueState();\n\n    try {\n      readLock.lock();\n      List\u003cQueueManagementChange\u003e queueManagementChanges \u003d new ArrayList\u003c\u003e();\n      List\u003cFiCaSchedulerApp\u003e pendingApps \u003d getSortedPendingApplications();\n\n      //Map of LeafQueue-\u003eQueueCapacities - keep adding the computed\n      // entitlements to this map and finally\n      // build the leaf queue configuration Template for all identified leaf\n      // queues\n      Map\u003cString, QueueCapacities\u003e leafQueueEntitlements \u003d new HashMap\u003c\u003e();\n      for (String nodeLabel : leafQueueTemplateNodeLabels) {\n        // check if any leaf queues need to be deactivated based on pending\n        // applications\n        float parentAbsoluteCapacity \u003d\n            managedParentQueue.getQueueCapacities().getAbsoluteCapacity(\n                nodeLabel);\n        float leafQueueTemplateAbsoluteCapacity \u003d\n            leafQueueTemplateCapacities.getAbsoluteCapacity(nodeLabel);\n        Map\u003cString, QueueCapacities\u003e deactivatedLeafQueues \u003d\n            deactivateLeafQueuesIfInActive(managedParentQueue, nodeLabel,\n                leafQueueEntitlements);\n\n        if (LOG.isDebugEnabled()) {\n          if ( deactivatedLeafQueues.size() \u003e 0) {\n              LOG.debug(\"Parent queue \u003d {},  \" +\n                   \", nodeLabel \u003d {}, deactivated leaf queues \u003d [{}] \",\n                  managedParentQueue.getQueueName(), nodeLabel,\n                  deactivatedLeafQueues.size() \u003e 25 ? deactivatedLeafQueues\n                      .size() : deactivatedLeafQueues);\n\n          }\n        }\n\n        float deactivatedCapacity \u003d getTotalDeactivatedCapacity(\n            deactivatedLeafQueues, nodeLabel);\n\n        float sumOfChildQueueActivatedCapacity \u003d parentQueueState.\n            getAbsoluteActivatedChildQueueCapacity(nodeLabel);\n\n        //Check if we need to activate anything at all?\n        float availableCapacity \u003d\n            parentAbsoluteCapacity - sumOfChildQueueActivatedCapacity\n                + deactivatedCapacity + EPSILON;\n\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Parent queue \u003d \" + managedParentQueue.getQueueName()\n              + \", nodeLabel \u003d \" + nodeLabel + \", absCapacity \u003d \"\n              + parentAbsoluteCapacity + \", leafQueueAbsoluteCapacity \u003d \"\n              + leafQueueTemplateAbsoluteCapacity + \", deactivatedCapacity \u003d \"\n              + deactivatedCapacity + \" , absChildActivatedCapacity \u003d \"\n              + sumOfChildQueueActivatedCapacity + \", availableCapacity \u003d \"\n              + availableCapacity);\n        }\n\n        if (availableCapacity \u003e\u003d leafQueueTemplateAbsoluteCapacity) {\n          //sort applications across leaf queues by submit time\n          if (pendingApps.size() \u003e 0) {\n            int maxLeafQueuesTobeActivated \u003d getMaxLeavesToBeActivated(\n                availableCapacity, leafQueueTemplateAbsoluteCapacity,\n                pendingApps.size());\n\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Parent queue \u003d \" + managedParentQueue.getQueueName()\n                  +  \" : Found \" + maxLeafQueuesTobeActivated + \" leaf queues\"\n                  + \" to be activated with \" + pendingApps.size() + \" apps \");\n            }\n\n            LinkedHashSet\u003cString\u003e leafQueuesToBeActivated \u003d getSortedLeafQueues(\n                nodeLabel, pendingApps, maxLeafQueuesTobeActivated,\n                deactivatedLeafQueues.keySet());\n\n            //Compute entitlement changes for the identified leaf queues\n            // which is appended to the List of computedEntitlements\n            updateLeafQueueCapacitiesByLabel(nodeLabel, leafQueuesToBeActivated,\n                leafQueueEntitlements);\n\n            if (LOG.isDebugEnabled()) {\n              if (leafQueuesToBeActivated.size() \u003e 0) {\n                LOG.debug(\"Activated leaf queues : [{}]\",\n                    leafQueuesToBeActivated.size() \u003c 25 ?\n                    leafQueuesToBeActivated : leafQueuesToBeActivated.size());\n              }\n            }\n          }\n        }\n      }\n\n      //Populate new entitlements\n\n      for (final Iterator\u003cMap.Entry\u003cString, QueueCapacities\u003e\u003e iterator \u003d\n           leafQueueEntitlements.entrySet().iterator(); iterator.hasNext(); ) {\n        Map.Entry\u003cString, QueueCapacities\u003e queueCapacities \u003d iterator.next();\n        String leafQueueName \u003d queueCapacities.getKey();\n        AutoCreatedLeafQueue leafQueue \u003d\n            (AutoCreatedLeafQueue) scheduler.getCapacitySchedulerQueueManager()\n                .getQueue(leafQueueName);\n        AutoCreatedLeafQueueConfig newTemplate \u003d buildTemplate(\n            queueCapacities.getValue());\n        queueManagementChanges.add(\n            new QueueManagementChange.UpdateQueue(leafQueue, newTemplate));\n\n      }\n      return queueManagementChanges;\n    } finally {\n      readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/queuemanagement/GuaranteedOrZeroCapacityOverTimePolicy.java",
      "extendedDetails": {}
    },
    "821b0de4c59156d4a65112de03ba3e7e1c88e309": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7574. Add support for Node Labels on Auto Created Leaf Queue Template. Contributed by Suma Shivaprasad.\n",
      "commitDate": "09/04/18 8:47 AM",
      "commitName": "821b0de4c59156d4a65112de03ba3e7e1c88e309",
      "commitAuthor": "Sunil G",
      "commitDateOld": "08/12/17 3:10 PM",
      "commitNameOld": "b38643c9a8dd2c53024ae830b9565a550d0ec39c",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 121.69,
      "commitsBetweenForRepo": 859,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,79 +1,101 @@\n   public List\u003cQueueManagementChange\u003e computeQueueManagementChanges()\n       throws SchedulerDynamicEditException {\n \n     //TODO : Add support for node labels on leaf queue template configurations\n     //synch/add missing leaf queue(s) if any to state\n     updateLeafQueueState();\n \n     try {\n       readLock.lock();\n       List\u003cQueueManagementChange\u003e queueManagementChanges \u003d new ArrayList\u003c\u003e();\n+      List\u003cFiCaSchedulerApp\u003e pendingApps \u003d getSortedPendingApplications();\n \n-      // check if any leaf queues need to be deactivated based on pending\n-      // applications and\n-      float parentAbsoluteCapacity \u003d\n-          managedParentQueue.getQueueCapacities().getAbsoluteCapacity();\n+      //Map of LeafQueue-\u003eQueueCapacities - keep adding the computed\n+      // entitlements to this map and finally\n+      // build the leaf queue configuration Template for all identified leaf\n+      // queues\n+      Map\u003cString, QueueCapacities\u003e leafQueueEntitlements \u003d new HashMap\u003c\u003e();\n+      for (String nodeLabel : leafQueueTemplateNodeLabels) {\n+        // check if any leaf queues need to be deactivated based on pending\n+        // applications\n+        float parentAbsoluteCapacity \u003d\n+            managedParentQueue.getQueueCapacities().getAbsoluteCapacity(\n+                nodeLabel);\n+        float leafQueueTemplateAbsoluteCapacity \u003d\n+            leafQueueTemplateCapacities.getAbsoluteCapacity(nodeLabel);\n+        Map\u003cString, QueueCapacities\u003e deactivatedLeafQueues \u003d\n+            deactivateLeafQueuesIfInActive(managedParentQueue, nodeLabel,\n+                leafQueueEntitlements);\n \n-      float leafQueueTemplateAbsoluteCapacity \u003d\n-          leafQueueTemplateCapacities.getAbsoluteCapacity();\n-      Map\u003cString, QueueCapacities\u003e deactivatedLeafQueues \u003d\n-          deactivateLeafQueuesIfInActive(managedParentQueue, queueManagementChanges);\n+        float deactivatedCapacity \u003d getTotalDeactivatedCapacity(\n+            deactivatedLeafQueues, nodeLabel);\n \n-      float deactivatedCapacity \u003d getTotalDeactivatedCapacity(\n-          deactivatedLeafQueues);\n+        float sumOfChildQueueActivatedCapacity \u003d parentQueueState.\n+            getAbsoluteActivatedChildQueueCapacity(nodeLabel);\n \n-      float sumOfChildQueueActivatedCapacity \u003d parentQueueState.\n-          getAbsoluteActivatedChildQueueCapacity();\n+        //Check if we need to activate anything at all?\n+        float availableCapacity \u003d\n+            parentAbsoluteCapacity - sumOfChildQueueActivatedCapacity\n+                + deactivatedCapacity + EPSILON;\n \n-      //Check if we need to activate anything at all?\n-      float availableCapacity \u003d getAvailableCapacity(parentAbsoluteCapacity,\n-          deactivatedCapacity, sumOfChildQueueActivatedCapacity);\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"Parent queue : \" + managedParentQueue.getQueueName()\n+              + \", nodeLabel \u003d \" + nodeLabel + \", absCapacity \u003d \"\n+              + parentAbsoluteCapacity + \", leafQueueAbsoluteCapacity \u003d \"\n+              + leafQueueTemplateAbsoluteCapacity + \", deactivatedCapacity \u003d \"\n+              + deactivatedCapacity + \" , absChildActivatedCapacity \u003d \"\n+              + sumOfChildQueueActivatedCapacity + \", availableCapacity \u003d \"\n+              + availableCapacity);\n+        }\n \n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\n-            \"Parent queue : \" + managedParentQueue.getQueueName() + \" absCapacity \u003d \"\n-                + parentAbsoluteCapacity + \", leafQueueAbsoluteCapacity \u003d \"\n-                + leafQueueTemplateAbsoluteCapacity + \", deactivatedCapacity \u003d \"\n-                + deactivatedCapacity + \" , absChildActivatedCapacity \u003d \"\n-                + sumOfChildQueueActivatedCapacity + \", availableCapacity \u003d \"\n-                + availableCapacity);\n-      }\n+        if (availableCapacity \u003e\u003d leafQueueTemplateAbsoluteCapacity) {\n+          //sort applications across leaf queues by submit time\n+          if (pendingApps.size() \u003e 0) {\n+            int maxLeafQueuesTobeActivated \u003d getMaxLeavesToBeActivated(\n+                availableCapacity, leafQueueTemplateAbsoluteCapacity,\n+                pendingApps.size());\n \n-      if (availableCapacity \u003e\u003d leafQueueTemplateAbsoluteCapacity) {\n-        //sort applications across leaf queues by submit time\n-        List\u003cFiCaSchedulerApp\u003e pendingApps \u003d getSortedPendingApplications();\n+            if (LOG.isDebugEnabled()) {\n+              LOG.debug(\"Found \" + maxLeafQueuesTobeActivated + \" leaf queues\"\n+                  + \" to be activated with \" + pendingApps.size() + \" apps \");\n+            }\n \n-        if (pendingApps.size() \u003e 0) {\n-          int maxLeafQueuesTobeActivated \u003d getMaxLeavesToBeActivated(\n-              availableCapacity, leafQueueTemplateAbsoluteCapacity,\n-              pendingApps.size());\n+            LinkedHashSet\u003cString\u003e leafQueuesToBeActivated \u003d getSortedLeafQueues(\n+                nodeLabel, pendingApps, maxLeafQueuesTobeActivated,\n+                deactivatedLeafQueues.keySet());\n \n-          if (LOG.isDebugEnabled()) {\n-            LOG.debug(\"Found \" + maxLeafQueuesTobeActivated\n-                + \" leaf queues to be activated with \" + pendingApps.size()\n-                + \" apps \");\n-          }\n+            //Compute entitlement changes for the identified leaf queues\n+            // which is appended to the List of computedEntitlements\n+            updateLeafQueueCapacitiesByLabel(nodeLabel, leafQueuesToBeActivated,\n+                leafQueueEntitlements);\n \n-          LinkedHashSet\u003cString\u003e leafQueuesToBeActivated \u003d getSortedLeafQueues(\n-              pendingApps, maxLeafQueuesTobeActivated,\n-              deactivatedLeafQueues.keySet());\n-\n-          //Compute entitlement changes for the identified leaf queues\n-          // which is appended to the List of queueManagementChanges\n-          computeQueueManagementChanges(leafQueuesToBeActivated,\n-              queueManagementChanges, availableCapacity,\n-              leafQueueTemplateAbsoluteCapacity);\n-\n-          if (LOG.isDebugEnabled()) {\n-            if (leafQueuesToBeActivated.size() \u003e 0) {\n-              LOG.debug(\n-                  \"Activated leaf queues : [\" + leafQueuesToBeActivated + \"]\");\n+            if (LOG.isDebugEnabled()) {\n+              if (leafQueuesToBeActivated.size() \u003e 0) {\n+                LOG.debug(\"Activated leaf queues : [\" + leafQueuesToBeActivated\n+                    + \"]\");\n+              }\n             }\n           }\n         }\n       }\n+\n+      //Populate new entitlements\n+\n+      for (final Iterator\u003cMap.Entry\u003cString, QueueCapacities\u003e\u003e iterator \u003d\n+           leafQueueEntitlements.entrySet().iterator(); iterator.hasNext(); ) {\n+        Map.Entry\u003cString, QueueCapacities\u003e queueCapacities \u003d iterator.next();\n+        String leafQueueName \u003d queueCapacities.getKey();\n+        AutoCreatedLeafQueue leafQueue \u003d\n+            (AutoCreatedLeafQueue) scheduler.getCapacitySchedulerQueueManager()\n+                .getQueue(leafQueueName);\n+        AutoCreatedLeafQueueConfig newTemplate \u003d buildTemplate(\n+            queueCapacities.getValue());\n+        queueManagementChanges.add(\n+            new QueueManagementChange.UpdateQueue(leafQueue, newTemplate));\n+\n+      }\n       return queueManagementChanges;\n     } finally {\n       readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public List\u003cQueueManagementChange\u003e computeQueueManagementChanges()\n      throws SchedulerDynamicEditException {\n\n    //TODO : Add support for node labels on leaf queue template configurations\n    //synch/add missing leaf queue(s) if any to state\n    updateLeafQueueState();\n\n    try {\n      readLock.lock();\n      List\u003cQueueManagementChange\u003e queueManagementChanges \u003d new ArrayList\u003c\u003e();\n      List\u003cFiCaSchedulerApp\u003e pendingApps \u003d getSortedPendingApplications();\n\n      //Map of LeafQueue-\u003eQueueCapacities - keep adding the computed\n      // entitlements to this map and finally\n      // build the leaf queue configuration Template for all identified leaf\n      // queues\n      Map\u003cString, QueueCapacities\u003e leafQueueEntitlements \u003d new HashMap\u003c\u003e();\n      for (String nodeLabel : leafQueueTemplateNodeLabels) {\n        // check if any leaf queues need to be deactivated based on pending\n        // applications\n        float parentAbsoluteCapacity \u003d\n            managedParentQueue.getQueueCapacities().getAbsoluteCapacity(\n                nodeLabel);\n        float leafQueueTemplateAbsoluteCapacity \u003d\n            leafQueueTemplateCapacities.getAbsoluteCapacity(nodeLabel);\n        Map\u003cString, QueueCapacities\u003e deactivatedLeafQueues \u003d\n            deactivateLeafQueuesIfInActive(managedParentQueue, nodeLabel,\n                leafQueueEntitlements);\n\n        float deactivatedCapacity \u003d getTotalDeactivatedCapacity(\n            deactivatedLeafQueues, nodeLabel);\n\n        float sumOfChildQueueActivatedCapacity \u003d parentQueueState.\n            getAbsoluteActivatedChildQueueCapacity(nodeLabel);\n\n        //Check if we need to activate anything at all?\n        float availableCapacity \u003d\n            parentAbsoluteCapacity - sumOfChildQueueActivatedCapacity\n                + deactivatedCapacity + EPSILON;\n\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Parent queue : \" + managedParentQueue.getQueueName()\n              + \", nodeLabel \u003d \" + nodeLabel + \", absCapacity \u003d \"\n              + parentAbsoluteCapacity + \", leafQueueAbsoluteCapacity \u003d \"\n              + leafQueueTemplateAbsoluteCapacity + \", deactivatedCapacity \u003d \"\n              + deactivatedCapacity + \" , absChildActivatedCapacity \u003d \"\n              + sumOfChildQueueActivatedCapacity + \", availableCapacity \u003d \"\n              + availableCapacity);\n        }\n\n        if (availableCapacity \u003e\u003d leafQueueTemplateAbsoluteCapacity) {\n          //sort applications across leaf queues by submit time\n          if (pendingApps.size() \u003e 0) {\n            int maxLeafQueuesTobeActivated \u003d getMaxLeavesToBeActivated(\n                availableCapacity, leafQueueTemplateAbsoluteCapacity,\n                pendingApps.size());\n\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Found \" + maxLeafQueuesTobeActivated + \" leaf queues\"\n                  + \" to be activated with \" + pendingApps.size() + \" apps \");\n            }\n\n            LinkedHashSet\u003cString\u003e leafQueuesToBeActivated \u003d getSortedLeafQueues(\n                nodeLabel, pendingApps, maxLeafQueuesTobeActivated,\n                deactivatedLeafQueues.keySet());\n\n            //Compute entitlement changes for the identified leaf queues\n            // which is appended to the List of computedEntitlements\n            updateLeafQueueCapacitiesByLabel(nodeLabel, leafQueuesToBeActivated,\n                leafQueueEntitlements);\n\n            if (LOG.isDebugEnabled()) {\n              if (leafQueuesToBeActivated.size() \u003e 0) {\n                LOG.debug(\"Activated leaf queues : [\" + leafQueuesToBeActivated\n                    + \"]\");\n              }\n            }\n          }\n        }\n      }\n\n      //Populate new entitlements\n\n      for (final Iterator\u003cMap.Entry\u003cString, QueueCapacities\u003e\u003e iterator \u003d\n           leafQueueEntitlements.entrySet().iterator(); iterator.hasNext(); ) {\n        Map.Entry\u003cString, QueueCapacities\u003e queueCapacities \u003d iterator.next();\n        String leafQueueName \u003d queueCapacities.getKey();\n        AutoCreatedLeafQueue leafQueue \u003d\n            (AutoCreatedLeafQueue) scheduler.getCapacitySchedulerQueueManager()\n                .getQueue(leafQueueName);\n        AutoCreatedLeafQueueConfig newTemplate \u003d buildTemplate(\n            queueCapacities.getValue());\n        queueManagementChanges.add(\n            new QueueManagementChange.UpdateQueue(leafQueue, newTemplate));\n\n      }\n      return queueManagementChanges;\n    } finally {\n      readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/queuemanagement/GuaranteedOrZeroCapacityOverTimePolicy.java",
      "extendedDetails": {}
    },
    "b38643c9a8dd2c53024ae830b9565a550d0ec39c": {
      "type": "Yintroduced",
      "commitMessage": "YARN-7473. Implement Framework and policy for capacity management of auto created queues. (Suma Shivaprasad via wangda)\n\nChange-Id: Icca7805fe12f6f7fb335effff4b121b6f7f6337b\n",
      "commitDate": "08/12/17 3:10 PM",
      "commitName": "b38643c9a8dd2c53024ae830b9565a550d0ec39c",
      "commitAuthor": "Wangda Tan",
      "diff": "@@ -0,0 +1,79 @@\n+  public List\u003cQueueManagementChange\u003e computeQueueManagementChanges()\n+      throws SchedulerDynamicEditException {\n+\n+    //TODO : Add support for node labels on leaf queue template configurations\n+    //synch/add missing leaf queue(s) if any to state\n+    updateLeafQueueState();\n+\n+    try {\n+      readLock.lock();\n+      List\u003cQueueManagementChange\u003e queueManagementChanges \u003d new ArrayList\u003c\u003e();\n+\n+      // check if any leaf queues need to be deactivated based on pending\n+      // applications and\n+      float parentAbsoluteCapacity \u003d\n+          managedParentQueue.getQueueCapacities().getAbsoluteCapacity();\n+\n+      float leafQueueTemplateAbsoluteCapacity \u003d\n+          leafQueueTemplateCapacities.getAbsoluteCapacity();\n+      Map\u003cString, QueueCapacities\u003e deactivatedLeafQueues \u003d\n+          deactivateLeafQueuesIfInActive(managedParentQueue, queueManagementChanges);\n+\n+      float deactivatedCapacity \u003d getTotalDeactivatedCapacity(\n+          deactivatedLeafQueues);\n+\n+      float sumOfChildQueueActivatedCapacity \u003d parentQueueState.\n+          getAbsoluteActivatedChildQueueCapacity();\n+\n+      //Check if we need to activate anything at all?\n+      float availableCapacity \u003d getAvailableCapacity(parentAbsoluteCapacity,\n+          deactivatedCapacity, sumOfChildQueueActivatedCapacity);\n+\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\n+            \"Parent queue : \" + managedParentQueue.getQueueName() + \" absCapacity \u003d \"\n+                + parentAbsoluteCapacity + \", leafQueueAbsoluteCapacity \u003d \"\n+                + leafQueueTemplateAbsoluteCapacity + \", deactivatedCapacity \u003d \"\n+                + deactivatedCapacity + \" , absChildActivatedCapacity \u003d \"\n+                + sumOfChildQueueActivatedCapacity + \", availableCapacity \u003d \"\n+                + availableCapacity);\n+      }\n+\n+      if (availableCapacity \u003e\u003d leafQueueTemplateAbsoluteCapacity) {\n+        //sort applications across leaf queues by submit time\n+        List\u003cFiCaSchedulerApp\u003e pendingApps \u003d getSortedPendingApplications();\n+\n+        if (pendingApps.size() \u003e 0) {\n+          int maxLeafQueuesTobeActivated \u003d getMaxLeavesToBeActivated(\n+              availableCapacity, leafQueueTemplateAbsoluteCapacity,\n+              pendingApps.size());\n+\n+          if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"Found \" + maxLeafQueuesTobeActivated\n+                + \" leaf queues to be activated with \" + pendingApps.size()\n+                + \" apps \");\n+          }\n+\n+          LinkedHashSet\u003cString\u003e leafQueuesToBeActivated \u003d getSortedLeafQueues(\n+              pendingApps, maxLeafQueuesTobeActivated,\n+              deactivatedLeafQueues.keySet());\n+\n+          //Compute entitlement changes for the identified leaf queues\n+          // which is appended to the List of queueManagementChanges\n+          computeQueueManagementChanges(leafQueuesToBeActivated,\n+              queueManagementChanges, availableCapacity,\n+              leafQueueTemplateAbsoluteCapacity);\n+\n+          if (LOG.isDebugEnabled()) {\n+            if (leafQueuesToBeActivated.size() \u003e 0) {\n+              LOG.debug(\n+                  \"Activated leaf queues : [\" + leafQueuesToBeActivated + \"]\");\n+            }\n+          }\n+        }\n+      }\n+      return queueManagementChanges;\n+    } finally {\n+      readLock.unlock();\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public List\u003cQueueManagementChange\u003e computeQueueManagementChanges()\n      throws SchedulerDynamicEditException {\n\n    //TODO : Add support for node labels on leaf queue template configurations\n    //synch/add missing leaf queue(s) if any to state\n    updateLeafQueueState();\n\n    try {\n      readLock.lock();\n      List\u003cQueueManagementChange\u003e queueManagementChanges \u003d new ArrayList\u003c\u003e();\n\n      // check if any leaf queues need to be deactivated based on pending\n      // applications and\n      float parentAbsoluteCapacity \u003d\n          managedParentQueue.getQueueCapacities().getAbsoluteCapacity();\n\n      float leafQueueTemplateAbsoluteCapacity \u003d\n          leafQueueTemplateCapacities.getAbsoluteCapacity();\n      Map\u003cString, QueueCapacities\u003e deactivatedLeafQueues \u003d\n          deactivateLeafQueuesIfInActive(managedParentQueue, queueManagementChanges);\n\n      float deactivatedCapacity \u003d getTotalDeactivatedCapacity(\n          deactivatedLeafQueues);\n\n      float sumOfChildQueueActivatedCapacity \u003d parentQueueState.\n          getAbsoluteActivatedChildQueueCapacity();\n\n      //Check if we need to activate anything at all?\n      float availableCapacity \u003d getAvailableCapacity(parentAbsoluteCapacity,\n          deactivatedCapacity, sumOfChildQueueActivatedCapacity);\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\n            \"Parent queue : \" + managedParentQueue.getQueueName() + \" absCapacity \u003d \"\n                + parentAbsoluteCapacity + \", leafQueueAbsoluteCapacity \u003d \"\n                + leafQueueTemplateAbsoluteCapacity + \", deactivatedCapacity \u003d \"\n                + deactivatedCapacity + \" , absChildActivatedCapacity \u003d \"\n                + sumOfChildQueueActivatedCapacity + \", availableCapacity \u003d \"\n                + availableCapacity);\n      }\n\n      if (availableCapacity \u003e\u003d leafQueueTemplateAbsoluteCapacity) {\n        //sort applications across leaf queues by submit time\n        List\u003cFiCaSchedulerApp\u003e pendingApps \u003d getSortedPendingApplications();\n\n        if (pendingApps.size() \u003e 0) {\n          int maxLeafQueuesTobeActivated \u003d getMaxLeavesToBeActivated(\n              availableCapacity, leafQueueTemplateAbsoluteCapacity,\n              pendingApps.size());\n\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Found \" + maxLeafQueuesTobeActivated\n                + \" leaf queues to be activated with \" + pendingApps.size()\n                + \" apps \");\n          }\n\n          LinkedHashSet\u003cString\u003e leafQueuesToBeActivated \u003d getSortedLeafQueues(\n              pendingApps, maxLeafQueuesTobeActivated,\n              deactivatedLeafQueues.keySet());\n\n          //Compute entitlement changes for the identified leaf queues\n          // which is appended to the List of queueManagementChanges\n          computeQueueManagementChanges(leafQueuesToBeActivated,\n              queueManagementChanges, availableCapacity,\n              leafQueueTemplateAbsoluteCapacity);\n\n          if (LOG.isDebugEnabled()) {\n            if (leafQueuesToBeActivated.size() \u003e 0) {\n              LOG.debug(\n                  \"Activated leaf queues : [\" + leafQueuesToBeActivated + \"]\");\n            }\n          }\n        }\n      }\n      return queueManagementChanges;\n    } finally {\n      readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/queuemanagement/GuaranteedOrZeroCapacityOverTimePolicy.java"
    }
  }
}