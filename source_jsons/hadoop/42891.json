{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "RMAppImpl.java",
  "functionName": "getLogAggregationStatusForAppReport",
  "functionId": "getLogAggregationStatusForAppReport",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java",
  "functionStartLine": 1777,
  "functionEndLine": 1780,
  "numCommitsSeen": 170,
  "timeTaken": 4937,
  "changeHistory": [
    "4456ea67b949553b85e101e866b4b3f4b335f1f0",
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635",
    "cd014d57aa8b896da02b5bcadafbd404bca2bc12",
    "15ccd967ee3e7046a50522089f67ba01f36ec76a",
    "1db355a875c3ecc40a244045c6812e00c8d36ef1"
  ],
  "changeHistoryShort": {
    "4456ea67b949553b85e101e866b4b3f4b335f1f0": "Ybodychange",
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635": "Ybodychange",
    "cd014d57aa8b896da02b5bcadafbd404bca2bc12": "Ybodychange",
    "15ccd967ee3e7046a50522089f67ba01f36ec76a": "Ybodychange",
    "1db355a875c3ecc40a244045c6812e00c8d36ef1": "Yintroduced"
  },
  "changeHistoryDetails": {
    "4456ea67b949553b85e101e866b4b3f4b335f1f0": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8586. Extract log aggregation related fields and methods from RMAppImpl. Contributed by Peter Bacsko\n",
      "commitDate": "16/08/19 2:36 AM",
      "commitName": "4456ea67b949553b85e101e866b4b3f4b335f1f0",
      "commitAuthor": "Szilard Nemeth",
      "commitDateOld": "11/06/19 10:41 AM",
      "commitNameOld": "60c95e9b6a899e37ecdc8bce7bb6d9ed0dc7a6be",
      "commitAuthorOld": "bibinchundatt",
      "daysBetweenCommits": 65.66,
      "commitsBetweenForRepo": 585,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,73 +1,4 @@\n   public LogAggregationStatus getLogAggregationStatusForAppReport() {\n-    this.readLock.lock();\n-    try {\n-      if (! logAggregationEnabled) {\n-        return LogAggregationStatus.DISABLED;\n-      }\n-      if (isLogAggregationFinished()) {\n-        return this.logAggregationStatusForAppReport;\n-      }\n-      Map\u003cNodeId, LogAggregationReport\u003e reports \u003d\n-          getLogAggregationReportsForApp();\n-      if (reports.size() \u003d\u003d 0) {\n-        return this.logAggregationStatusForAppReport;\n-      }\n-      int logNotStartCount \u003d 0;\n-      int logCompletedCount \u003d 0;\n-      int logTimeOutCount \u003d 0;\n-      int logFailedCount \u003d 0;\n-      int logRunningWithFailure \u003d 0;\n-      for (Entry\u003cNodeId, LogAggregationReport\u003e report : reports.entrySet()) {\n-        switch (report.getValue().getLogAggregationStatus()) {\n-          case NOT_START:\n-            logNotStartCount++;\n-            break;\n-          case RUNNING_WITH_FAILURE:\n-            logRunningWithFailure ++;\n-            break;\n-          case SUCCEEDED:\n-            logCompletedCount++;\n-            break;\n-          case FAILED:\n-            logFailedCount++;\n-            logCompletedCount++;\n-            break;\n-          case TIME_OUT:\n-            logTimeOutCount++;\n-            logCompletedCount++;\n-            break;\n-          default:\n-            break;\n-        }\n-      }\n-      if (logNotStartCount \u003d\u003d reports.size()) {\n-        return LogAggregationStatus.NOT_START;\n-      } else if (logCompletedCount \u003d\u003d reports.size()) {\n-        // We should satisfy two condition in order to return SUCCEEDED or FAILED\n-        // 1) make sure the application is in final state\n-        // 2) logs status from all NMs are SUCCEEDED/FAILED/TIMEOUT\n-        // The SUCCEEDED/FAILED status is the final status which means\n-        // the log aggregation is finished. And the log aggregation status will\n-        // not be updated anymore.\n-        if (logFailedCount \u003e 0 \u0026\u0026 isAppInFinalState(this)) {\n-          this.logAggregationStatusForAppReport \u003d\n-              LogAggregationStatus.FAILED;\n-          return LogAggregationStatus.FAILED;\n-        } else if (logTimeOutCount \u003e 0) {\n-          this.logAggregationStatusForAppReport \u003d\n-              LogAggregationStatus.TIME_OUT;\n-          return LogAggregationStatus.TIME_OUT;\n-        }\n-        if (isAppInFinalState(this)) {\n-          this.logAggregationStatusForAppReport \u003d\n-              LogAggregationStatus.SUCCEEDED;\n-          return LogAggregationStatus.SUCCEEDED;\n-        }\n-      } else if (logRunningWithFailure \u003e 0) {\n-        return LogAggregationStatus.RUNNING_WITH_FAILURE;\n-      }\n-      return LogAggregationStatus.RUNNING;\n-    } finally {\n-      this.readLock.unlock();\n-    }\n+    return logAggregation\n+        .getLogAggregationStatusForAppReport(this);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public LogAggregationStatus getLogAggregationStatusForAppReport() {\n    return logAggregation\n        .getLogAggregationStatusForAppReport(this);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java",
      "extendedDetails": {}
    },
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9341.  Fixed enentrant lock usage in YARN project.\n            Contributed by Prabhu Joseph\n",
      "commitDate": "07/03/19 1:47 PM",
      "commitName": "39b4a37e02e929a698fcf9e32f1f71bb6b977635",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "04/03/19 9:10 PM",
      "commitNameOld": "e40e2d6ad5cbe782c3a067229270738b501ed27e",
      "commitAuthorOld": "Prabhu Joseph",
      "daysBetweenCommits": 2.69,
      "commitsBetweenForRepo": 39,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,73 +1,73 @@\n   public LogAggregationStatus getLogAggregationStatusForAppReport() {\n+    this.readLock.lock();\n     try {\n-      this.readLock.lock();\n       if (! logAggregationEnabled) {\n         return LogAggregationStatus.DISABLED;\n       }\n       if (isLogAggregationFinished()) {\n         return this.logAggregationStatusForAppReport;\n       }\n       Map\u003cNodeId, LogAggregationReport\u003e reports \u003d\n           getLogAggregationReportsForApp();\n       if (reports.size() \u003d\u003d 0) {\n         return this.logAggregationStatusForAppReport;\n       }\n       int logNotStartCount \u003d 0;\n       int logCompletedCount \u003d 0;\n       int logTimeOutCount \u003d 0;\n       int logFailedCount \u003d 0;\n       int logRunningWithFailure \u003d 0;\n       for (Entry\u003cNodeId, LogAggregationReport\u003e report : reports.entrySet()) {\n         switch (report.getValue().getLogAggregationStatus()) {\n           case NOT_START:\n             logNotStartCount++;\n             break;\n           case RUNNING_WITH_FAILURE:\n             logRunningWithFailure ++;\n             break;\n           case SUCCEEDED:\n             logCompletedCount++;\n             break;\n           case FAILED:\n             logFailedCount++;\n             logCompletedCount++;\n             break;\n           case TIME_OUT:\n             logTimeOutCount++;\n             logCompletedCount++;\n             break;\n           default:\n             break;\n         }\n       }\n       if (logNotStartCount \u003d\u003d reports.size()) {\n         return LogAggregationStatus.NOT_START;\n       } else if (logCompletedCount \u003d\u003d reports.size()) {\n         // We should satisfy two condition in order to return SUCCEEDED or FAILED\n         // 1) make sure the application is in final state\n         // 2) logs status from all NMs are SUCCEEDED/FAILED/TIMEOUT\n         // The SUCCEEDED/FAILED status is the final status which means\n         // the log aggregation is finished. And the log aggregation status will\n         // not be updated anymore.\n         if (logFailedCount \u003e 0 \u0026\u0026 isAppInFinalState(this)) {\n           this.logAggregationStatusForAppReport \u003d\n               LogAggregationStatus.FAILED;\n           return LogAggregationStatus.FAILED;\n         } else if (logTimeOutCount \u003e 0) {\n           this.logAggregationStatusForAppReport \u003d\n               LogAggregationStatus.TIME_OUT;\n           return LogAggregationStatus.TIME_OUT;\n         }\n         if (isAppInFinalState(this)) {\n           this.logAggregationStatusForAppReport \u003d\n               LogAggregationStatus.SUCCEEDED;\n           return LogAggregationStatus.SUCCEEDED;\n         }\n       } else if (logRunningWithFailure \u003e 0) {\n         return LogAggregationStatus.RUNNING_WITH_FAILURE;\n       }\n       return LogAggregationStatus.RUNNING;\n     } finally {\n       this.readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public LogAggregationStatus getLogAggregationStatusForAppReport() {\n    this.readLock.lock();\n    try {\n      if (! logAggregationEnabled) {\n        return LogAggregationStatus.DISABLED;\n      }\n      if (isLogAggregationFinished()) {\n        return this.logAggregationStatusForAppReport;\n      }\n      Map\u003cNodeId, LogAggregationReport\u003e reports \u003d\n          getLogAggregationReportsForApp();\n      if (reports.size() \u003d\u003d 0) {\n        return this.logAggregationStatusForAppReport;\n      }\n      int logNotStartCount \u003d 0;\n      int logCompletedCount \u003d 0;\n      int logTimeOutCount \u003d 0;\n      int logFailedCount \u003d 0;\n      int logRunningWithFailure \u003d 0;\n      for (Entry\u003cNodeId, LogAggregationReport\u003e report : reports.entrySet()) {\n        switch (report.getValue().getLogAggregationStatus()) {\n          case NOT_START:\n            logNotStartCount++;\n            break;\n          case RUNNING_WITH_FAILURE:\n            logRunningWithFailure ++;\n            break;\n          case SUCCEEDED:\n            logCompletedCount++;\n            break;\n          case FAILED:\n            logFailedCount++;\n            logCompletedCount++;\n            break;\n          case TIME_OUT:\n            logTimeOutCount++;\n            logCompletedCount++;\n            break;\n          default:\n            break;\n        }\n      }\n      if (logNotStartCount \u003d\u003d reports.size()) {\n        return LogAggregationStatus.NOT_START;\n      } else if (logCompletedCount \u003d\u003d reports.size()) {\n        // We should satisfy two condition in order to return SUCCEEDED or FAILED\n        // 1) make sure the application is in final state\n        // 2) logs status from all NMs are SUCCEEDED/FAILED/TIMEOUT\n        // The SUCCEEDED/FAILED status is the final status which means\n        // the log aggregation is finished. And the log aggregation status will\n        // not be updated anymore.\n        if (logFailedCount \u003e 0 \u0026\u0026 isAppInFinalState(this)) {\n          this.logAggregationStatusForAppReport \u003d\n              LogAggregationStatus.FAILED;\n          return LogAggregationStatus.FAILED;\n        } else if (logTimeOutCount \u003e 0) {\n          this.logAggregationStatusForAppReport \u003d\n              LogAggregationStatus.TIME_OUT;\n          return LogAggregationStatus.TIME_OUT;\n        }\n        if (isAppInFinalState(this)) {\n          this.logAggregationStatusForAppReport \u003d\n              LogAggregationStatus.SUCCEEDED;\n          return LogAggregationStatus.SUCCEEDED;\n        }\n      } else if (logRunningWithFailure \u003e 0) {\n        return LogAggregationStatus.RUNNING_WITH_FAILURE;\n      }\n      return LogAggregationStatus.RUNNING;\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java",
      "extendedDetails": {}
    },
    "cd014d57aa8b896da02b5bcadafbd404bca2bc12": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6339. Improve performance for createAndGetApplicationReport. (Yunjiong Zhao via wangda)\n",
      "commitDate": "27/03/17 1:29 PM",
      "commitName": "cd014d57aa8b896da02b5bcadafbd404bca2bc12",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "28/02/17 1:23 PM",
      "commitNameOld": "235203dffda1482fb38762fde544c4dd9c3e1fa8",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 26.96,
      "commitsBetweenForRepo": 161,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,67 +1,73 @@\n   public LogAggregationStatus getLogAggregationStatusForAppReport() {\n     try {\n       this.readLock.lock();\n       if (! logAggregationEnabled) {\n         return LogAggregationStatus.DISABLED;\n       }\n       if (isLogAggregationFinished()) {\n         return this.logAggregationStatusForAppReport;\n       }\n       Map\u003cNodeId, LogAggregationReport\u003e reports \u003d\n           getLogAggregationReportsForApp();\n       if (reports.size() \u003d\u003d 0) {\n         return this.logAggregationStatusForAppReport;\n       }\n       int logNotStartCount \u003d 0;\n       int logCompletedCount \u003d 0;\n       int logTimeOutCount \u003d 0;\n       int logFailedCount \u003d 0;\n       int logRunningWithFailure \u003d 0;\n       for (Entry\u003cNodeId, LogAggregationReport\u003e report : reports.entrySet()) {\n         switch (report.getValue().getLogAggregationStatus()) {\n           case NOT_START:\n             logNotStartCount++;\n             break;\n           case RUNNING_WITH_FAILURE:\n             logRunningWithFailure ++;\n             break;\n           case SUCCEEDED:\n             logCompletedCount++;\n             break;\n           case FAILED:\n             logFailedCount++;\n             logCompletedCount++;\n             break;\n           case TIME_OUT:\n             logTimeOutCount++;\n             logCompletedCount++;\n             break;\n           default:\n             break;\n         }\n       }\n       if (logNotStartCount \u003d\u003d reports.size()) {\n         return LogAggregationStatus.NOT_START;\n       } else if (logCompletedCount \u003d\u003d reports.size()) {\n         // We should satisfy two condition in order to return SUCCEEDED or FAILED\n         // 1) make sure the application is in final state\n         // 2) logs status from all NMs are SUCCEEDED/FAILED/TIMEOUT\n         // The SUCCEEDED/FAILED status is the final status which means\n         // the log aggregation is finished. And the log aggregation status will\n         // not be updated anymore.\n         if (logFailedCount \u003e 0 \u0026\u0026 isAppInFinalState(this)) {\n+          this.logAggregationStatusForAppReport \u003d\n+              LogAggregationStatus.FAILED;\n           return LogAggregationStatus.FAILED;\n         } else if (logTimeOutCount \u003e 0) {\n+          this.logAggregationStatusForAppReport \u003d\n+              LogAggregationStatus.TIME_OUT;\n           return LogAggregationStatus.TIME_OUT;\n         }\n         if (isAppInFinalState(this)) {\n+          this.logAggregationStatusForAppReport \u003d\n+              LogAggregationStatus.SUCCEEDED;\n           return LogAggregationStatus.SUCCEEDED;\n         }\n       } else if (logRunningWithFailure \u003e 0) {\n         return LogAggregationStatus.RUNNING_WITH_FAILURE;\n       }\n       return LogAggregationStatus.RUNNING;\n     } finally {\n       this.readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public LogAggregationStatus getLogAggregationStatusForAppReport() {\n    try {\n      this.readLock.lock();\n      if (! logAggregationEnabled) {\n        return LogAggregationStatus.DISABLED;\n      }\n      if (isLogAggregationFinished()) {\n        return this.logAggregationStatusForAppReport;\n      }\n      Map\u003cNodeId, LogAggregationReport\u003e reports \u003d\n          getLogAggregationReportsForApp();\n      if (reports.size() \u003d\u003d 0) {\n        return this.logAggregationStatusForAppReport;\n      }\n      int logNotStartCount \u003d 0;\n      int logCompletedCount \u003d 0;\n      int logTimeOutCount \u003d 0;\n      int logFailedCount \u003d 0;\n      int logRunningWithFailure \u003d 0;\n      for (Entry\u003cNodeId, LogAggregationReport\u003e report : reports.entrySet()) {\n        switch (report.getValue().getLogAggregationStatus()) {\n          case NOT_START:\n            logNotStartCount++;\n            break;\n          case RUNNING_WITH_FAILURE:\n            logRunningWithFailure ++;\n            break;\n          case SUCCEEDED:\n            logCompletedCount++;\n            break;\n          case FAILED:\n            logFailedCount++;\n            logCompletedCount++;\n            break;\n          case TIME_OUT:\n            logTimeOutCount++;\n            logCompletedCount++;\n            break;\n          default:\n            break;\n        }\n      }\n      if (logNotStartCount \u003d\u003d reports.size()) {\n        return LogAggregationStatus.NOT_START;\n      } else if (logCompletedCount \u003d\u003d reports.size()) {\n        // We should satisfy two condition in order to return SUCCEEDED or FAILED\n        // 1) make sure the application is in final state\n        // 2) logs status from all NMs are SUCCEEDED/FAILED/TIMEOUT\n        // The SUCCEEDED/FAILED status is the final status which means\n        // the log aggregation is finished. And the log aggregation status will\n        // not be updated anymore.\n        if (logFailedCount \u003e 0 \u0026\u0026 isAppInFinalState(this)) {\n          this.logAggregationStatusForAppReport \u003d\n              LogAggregationStatus.FAILED;\n          return LogAggregationStatus.FAILED;\n        } else if (logTimeOutCount \u003e 0) {\n          this.logAggregationStatusForAppReport \u003d\n              LogAggregationStatus.TIME_OUT;\n          return LogAggregationStatus.TIME_OUT;\n        }\n        if (isAppInFinalState(this)) {\n          this.logAggregationStatusForAppReport \u003d\n              LogAggregationStatus.SUCCEEDED;\n          return LogAggregationStatus.SUCCEEDED;\n        }\n      } else if (logRunningWithFailure \u003e 0) {\n        return LogAggregationStatus.RUNNING_WITH_FAILURE;\n      }\n      return LogAggregationStatus.RUNNING;\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java",
      "extendedDetails": {}
    },
    "15ccd967ee3e7046a50522089f67ba01f36ec76a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3505. Node\u0027s Log Aggregation Report with SUCCEED should not cached in RMApps. Contributed by Xuan Gong.\n",
      "commitDate": "14/05/15 10:58 AM",
      "commitName": "15ccd967ee3e7046a50522089f67ba01f36ec76a",
      "commitAuthor": "Junping Du",
      "commitDateOld": "24/04/15 12:13 PM",
      "commitNameOld": "d03dcb9635dbd79a45d229d1cab5fd28e5e49f49",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 19.95,
      "commitsBetweenForRepo": 253,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,67 @@\n   public LogAggregationStatus getLogAggregationStatusForAppReport() {\n-    if (!logAggregationEnabled) {\n-      return LogAggregationStatus.DISABLED;\n-    }\n-    if (this.logAggregationStatusForAppReport \u003d\u003d LogAggregationStatus.FAILED\n-        || this.logAggregationStatusForAppReport \u003d\u003d LogAggregationStatus.SUCCEEDED) {\n-      return this.logAggregationStatusForAppReport;\n-    }\n     try {\n       this.readLock.lock();\n+      if (! logAggregationEnabled) {\n+        return LogAggregationStatus.DISABLED;\n+      }\n+      if (isLogAggregationFinished()) {\n+        return this.logAggregationStatusForAppReport;\n+      }\n       Map\u003cNodeId, LogAggregationReport\u003e reports \u003d\n           getLogAggregationReportsForApp();\n       if (reports.size() \u003d\u003d 0) {\n-        return null;\n+        return this.logAggregationStatusForAppReport;\n       }\n       int logNotStartCount \u003d 0;\n       int logCompletedCount \u003d 0;\n       int logTimeOutCount \u003d 0;\n       int logFailedCount \u003d 0;\n+      int logRunningWithFailure \u003d 0;\n       for (Entry\u003cNodeId, LogAggregationReport\u003e report : reports.entrySet()) {\n         switch (report.getValue().getLogAggregationStatus()) {\n           case NOT_START:\n             logNotStartCount++;\n             break;\n+          case RUNNING_WITH_FAILURE:\n+            logRunningWithFailure ++;\n+            break;\n           case SUCCEEDED:\n             logCompletedCount++;\n             break;\n           case FAILED:\n             logFailedCount++;\n             logCompletedCount++;\n             break;\n           case TIME_OUT:\n             logTimeOutCount++;\n             logCompletedCount++;\n             break;\n           default:\n             break;\n         }\n       }\n       if (logNotStartCount \u003d\u003d reports.size()) {\n         return LogAggregationStatus.NOT_START;\n       } else if (logCompletedCount \u003d\u003d reports.size()) {\n         // We should satisfy two condition in order to return SUCCEEDED or FAILED\n         // 1) make sure the application is in final state\n         // 2) logs status from all NMs are SUCCEEDED/FAILED/TIMEOUT\n         // The SUCCEEDED/FAILED status is the final status which means\n         // the log aggregation is finished. And the log aggregation status will\n         // not be updated anymore.\n         if (logFailedCount \u003e 0 \u0026\u0026 isAppInFinalState(this)) {\n-          this.logAggregationStatusForAppReport \u003d LogAggregationStatus.FAILED;\n           return LogAggregationStatus.FAILED;\n         } else if (logTimeOutCount \u003e 0) {\n           return LogAggregationStatus.TIME_OUT;\n         }\n         if (isAppInFinalState(this)) {\n-          this.logAggregationStatusForAppReport \u003d LogAggregationStatus.SUCCEEDED;\n           return LogAggregationStatus.SUCCEEDED;\n         }\n+      } else if (logRunningWithFailure \u003e 0) {\n+        return LogAggregationStatus.RUNNING_WITH_FAILURE;\n       }\n       return LogAggregationStatus.RUNNING;\n     } finally {\n       this.readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public LogAggregationStatus getLogAggregationStatusForAppReport() {\n    try {\n      this.readLock.lock();\n      if (! logAggregationEnabled) {\n        return LogAggregationStatus.DISABLED;\n      }\n      if (isLogAggregationFinished()) {\n        return this.logAggregationStatusForAppReport;\n      }\n      Map\u003cNodeId, LogAggregationReport\u003e reports \u003d\n          getLogAggregationReportsForApp();\n      if (reports.size() \u003d\u003d 0) {\n        return this.logAggregationStatusForAppReport;\n      }\n      int logNotStartCount \u003d 0;\n      int logCompletedCount \u003d 0;\n      int logTimeOutCount \u003d 0;\n      int logFailedCount \u003d 0;\n      int logRunningWithFailure \u003d 0;\n      for (Entry\u003cNodeId, LogAggregationReport\u003e report : reports.entrySet()) {\n        switch (report.getValue().getLogAggregationStatus()) {\n          case NOT_START:\n            logNotStartCount++;\n            break;\n          case RUNNING_WITH_FAILURE:\n            logRunningWithFailure ++;\n            break;\n          case SUCCEEDED:\n            logCompletedCount++;\n            break;\n          case FAILED:\n            logFailedCount++;\n            logCompletedCount++;\n            break;\n          case TIME_OUT:\n            logTimeOutCount++;\n            logCompletedCount++;\n            break;\n          default:\n            break;\n        }\n      }\n      if (logNotStartCount \u003d\u003d reports.size()) {\n        return LogAggregationStatus.NOT_START;\n      } else if (logCompletedCount \u003d\u003d reports.size()) {\n        // We should satisfy two condition in order to return SUCCEEDED or FAILED\n        // 1) make sure the application is in final state\n        // 2) logs status from all NMs are SUCCEEDED/FAILED/TIMEOUT\n        // The SUCCEEDED/FAILED status is the final status which means\n        // the log aggregation is finished. And the log aggregation status will\n        // not be updated anymore.\n        if (logFailedCount \u003e 0 \u0026\u0026 isAppInFinalState(this)) {\n          return LogAggregationStatus.FAILED;\n        } else if (logTimeOutCount \u003e 0) {\n          return LogAggregationStatus.TIME_OUT;\n        }\n        if (isAppInFinalState(this)) {\n          return LogAggregationStatus.SUCCEEDED;\n        }\n      } else if (logRunningWithFailure \u003e 0) {\n        return LogAggregationStatus.RUNNING_WITH_FAILURE;\n      }\n      return LogAggregationStatus.RUNNING;\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java",
      "extendedDetails": {}
    },
    "1db355a875c3ecc40a244045c6812e00c8d36ef1": {
      "type": "Yintroduced",
      "commitMessage": "YARN-1402. Update related Web UI and CLI with exposing client API to check log aggregation status. Contributed by Xuan Gong.\n",
      "commitDate": "17/04/15 1:18 PM",
      "commitName": "1db355a875c3ecc40a244045c6812e00c8d36ef1",
      "commitAuthor": "Junping Du",
      "diff": "@@ -0,0 +1,64 @@\n+  public LogAggregationStatus getLogAggregationStatusForAppReport() {\n+    if (!logAggregationEnabled) {\n+      return LogAggregationStatus.DISABLED;\n+    }\n+    if (this.logAggregationStatusForAppReport \u003d\u003d LogAggregationStatus.FAILED\n+        || this.logAggregationStatusForAppReport \u003d\u003d LogAggregationStatus.SUCCEEDED) {\n+      return this.logAggregationStatusForAppReport;\n+    }\n+    try {\n+      this.readLock.lock();\n+      Map\u003cNodeId, LogAggregationReport\u003e reports \u003d\n+          getLogAggregationReportsForApp();\n+      if (reports.size() \u003d\u003d 0) {\n+        return null;\n+      }\n+      int logNotStartCount \u003d 0;\n+      int logCompletedCount \u003d 0;\n+      int logTimeOutCount \u003d 0;\n+      int logFailedCount \u003d 0;\n+      for (Entry\u003cNodeId, LogAggregationReport\u003e report : reports.entrySet()) {\n+        switch (report.getValue().getLogAggregationStatus()) {\n+          case NOT_START:\n+            logNotStartCount++;\n+            break;\n+          case SUCCEEDED:\n+            logCompletedCount++;\n+            break;\n+          case FAILED:\n+            logFailedCount++;\n+            logCompletedCount++;\n+            break;\n+          case TIME_OUT:\n+            logTimeOutCount++;\n+            logCompletedCount++;\n+            break;\n+          default:\n+            break;\n+        }\n+      }\n+      if (logNotStartCount \u003d\u003d reports.size()) {\n+        return LogAggregationStatus.NOT_START;\n+      } else if (logCompletedCount \u003d\u003d reports.size()) {\n+        // We should satisfy two condition in order to return SUCCEEDED or FAILED\n+        // 1) make sure the application is in final state\n+        // 2) logs status from all NMs are SUCCEEDED/FAILED/TIMEOUT\n+        // The SUCCEEDED/FAILED status is the final status which means\n+        // the log aggregation is finished. And the log aggregation status will\n+        // not be updated anymore.\n+        if (logFailedCount \u003e 0 \u0026\u0026 isAppInFinalState(this)) {\n+          this.logAggregationStatusForAppReport \u003d LogAggregationStatus.FAILED;\n+          return LogAggregationStatus.FAILED;\n+        } else if (logTimeOutCount \u003e 0) {\n+          return LogAggregationStatus.TIME_OUT;\n+        }\n+        if (isAppInFinalState(this)) {\n+          this.logAggregationStatusForAppReport \u003d LogAggregationStatus.SUCCEEDED;\n+          return LogAggregationStatus.SUCCEEDED;\n+        }\n+      }\n+      return LogAggregationStatus.RUNNING;\n+    } finally {\n+      this.readLock.unlock();\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public LogAggregationStatus getLogAggregationStatusForAppReport() {\n    if (!logAggregationEnabled) {\n      return LogAggregationStatus.DISABLED;\n    }\n    if (this.logAggregationStatusForAppReport \u003d\u003d LogAggregationStatus.FAILED\n        || this.logAggregationStatusForAppReport \u003d\u003d LogAggregationStatus.SUCCEEDED) {\n      return this.logAggregationStatusForAppReport;\n    }\n    try {\n      this.readLock.lock();\n      Map\u003cNodeId, LogAggregationReport\u003e reports \u003d\n          getLogAggregationReportsForApp();\n      if (reports.size() \u003d\u003d 0) {\n        return null;\n      }\n      int logNotStartCount \u003d 0;\n      int logCompletedCount \u003d 0;\n      int logTimeOutCount \u003d 0;\n      int logFailedCount \u003d 0;\n      for (Entry\u003cNodeId, LogAggregationReport\u003e report : reports.entrySet()) {\n        switch (report.getValue().getLogAggregationStatus()) {\n          case NOT_START:\n            logNotStartCount++;\n            break;\n          case SUCCEEDED:\n            logCompletedCount++;\n            break;\n          case FAILED:\n            logFailedCount++;\n            logCompletedCount++;\n            break;\n          case TIME_OUT:\n            logTimeOutCount++;\n            logCompletedCount++;\n            break;\n          default:\n            break;\n        }\n      }\n      if (logNotStartCount \u003d\u003d reports.size()) {\n        return LogAggregationStatus.NOT_START;\n      } else if (logCompletedCount \u003d\u003d reports.size()) {\n        // We should satisfy two condition in order to return SUCCEEDED or FAILED\n        // 1) make sure the application is in final state\n        // 2) logs status from all NMs are SUCCEEDED/FAILED/TIMEOUT\n        // The SUCCEEDED/FAILED status is the final status which means\n        // the log aggregation is finished. And the log aggregation status will\n        // not be updated anymore.\n        if (logFailedCount \u003e 0 \u0026\u0026 isAppInFinalState(this)) {\n          this.logAggregationStatusForAppReport \u003d LogAggregationStatus.FAILED;\n          return LogAggregationStatus.FAILED;\n        } else if (logTimeOutCount \u003e 0) {\n          return LogAggregationStatus.TIME_OUT;\n        }\n        if (isAppInFinalState(this)) {\n          this.logAggregationStatusForAppReport \u003d LogAggregationStatus.SUCCEEDED;\n          return LogAggregationStatus.SUCCEEDED;\n        }\n      }\n      return LogAggregationStatus.RUNNING;\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java"
    }
  }
}