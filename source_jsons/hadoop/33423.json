{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "DefaultLinuxContainerRuntime.java",
  "functionName": "launchContainer",
  "functionId": "launchContainer___ctx-ContainerRuntimeContext",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/runtime/DefaultLinuxContainerRuntime.java",
  "functionStartLine": 108,
  "functionEndLine": 162,
  "numCommitsSeen": 23,
  "timeTaken": 2770,
  "changeHistory": [
    "c2288ac45b748b4119442c46147ccc324926c340",
    "502914ca32ac02b19116fd681eb8301b92fccbb3",
    "e5e1851d803bf8d8b96fec1b5c0058014e9329d0",
    "9d4d30243b0fc9630da51a2c17b543ef671d035c",
    "059caf99891943d9587cac19b48e82efbed06b2d",
    "3e6fce91a471b4a5099de109582e7c6417e8a822"
  ],
  "changeHistoryShort": {
    "c2288ac45b748b4119442c46147ccc324926c340": "Ybodychange",
    "502914ca32ac02b19116fd681eb8301b92fccbb3": "Ybodychange",
    "e5e1851d803bf8d8b96fec1b5c0058014e9329d0": "Ybodychange",
    "9d4d30243b0fc9630da51a2c17b543ef671d035c": "Ybodychange",
    "059caf99891943d9587cac19b48e82efbed06b2d": "Ybodychange",
    "3e6fce91a471b4a5099de109582e7c6417e8a822": "Yintroduced"
  },
  "changeHistoryDetails": {
    "c2288ac45b748b4119442c46147ccc324926c340": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8448. AM HTTPS Support for AM communication with RMWeb proxy. (Contributed by Robert Kanter)\n",
      "commitDate": "16/10/18 1:36 PM",
      "commitName": "c2288ac45b748b4119442c46147ccc324926c340",
      "commitAuthor": "Haibo Chen",
      "commitDateOld": "27/09/18 12:31 PM",
      "commitNameOld": "b237a0dd44ab285941983648d7ef26b99b30d624",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 19.05,
      "commitsBetweenForRepo": 190,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,55 @@\n   public void launchContainer(ContainerRuntimeContext ctx)\n       throws ContainerExecutionException {\n     PrivilegedOperation launchOp \u003d new PrivilegedOperation(\n         PrivilegedOperation.OperationType.LAUNCH_CONTAINER);\n \n     //All of these arguments are expected to be available in the runtime context\n     launchOp.appendArgs(ctx.getExecutionAttribute(RUN_AS_USER),\n         ctx.getExecutionAttribute(USER),\n         Integer.toString(PrivilegedOperation.\n             RunAsUserCommand.LAUNCH_CONTAINER.getValue()),\n         ctx.getExecutionAttribute(APPID),\n         ctx.getExecutionAttribute(CONTAINER_ID_STR),\n         ctx.getExecutionAttribute(CONTAINER_WORK_DIR).toString(),\n         ctx.getExecutionAttribute(NM_PRIVATE_CONTAINER_SCRIPT_PATH).toUri()\n             .getPath(),\n-        ctx.getExecutionAttribute(NM_PRIVATE_TOKENS_PATH).toUri().getPath(),\n-        ctx.getExecutionAttribute(PID_FILE_PATH).toString(),\n+        ctx.getExecutionAttribute(NM_PRIVATE_TOKENS_PATH).toUri().getPath());\n+    Path keystorePath \u003d ctx.getExecutionAttribute(NM_PRIVATE_KEYSTORE_PATH);\n+    Path truststorePath \u003d ctx.getExecutionAttribute(NM_PRIVATE_TRUSTSTORE_PATH);\n+    if (keystorePath !\u003d null \u0026\u0026 truststorePath !\u003d null) {\n+      launchOp.appendArgs(\"--https\",\n+          keystorePath.toUri().getPath(),\n+          truststorePath.toUri().getPath());\n+    } else {\n+      launchOp.appendArgs(\"--http\");\n+    }\n+    launchOp.appendArgs(ctx.getExecutionAttribute(PID_FILE_PATH).toString(),\n         StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n             ctx.getExecutionAttribute(LOCAL_DIRS)),\n         StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n             ctx.getExecutionAttribute(LOG_DIRS)),\n         ctx.getExecutionAttribute(RESOURCES_OPTIONS));\n \n     String tcCommandFile \u003d ctx.getExecutionAttribute(TC_COMMAND_FILE);\n \n     if (tcCommandFile !\u003d null) {\n       launchOp.appendArgs(tcCommandFile);\n     }\n \n     // Some failures here are acceptable. Let the calling executor decide.\n     launchOp.disableFailureLogging();\n \n     //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n     //we can\u0027t do better here thanks to type-erasure\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e prefixCommands \u003d (List\u003cString\u003e) ctx.getExecutionAttribute(\n         CONTAINER_LAUNCH_PREFIX_COMMANDS);\n \n     try {\n       privilegedOperationExecutor.executePrivilegedOperation(prefixCommands,\n             launchOp, null, null, false, false);\n     } catch (PrivilegedOperationException e) {\n       throw new ContainerExecutionException(\"Launch container failed\", e\n           .getExitCode(), e.getOutput(), e.getErrorOutput());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void launchContainer(ContainerRuntimeContext ctx)\n      throws ContainerExecutionException {\n    PrivilegedOperation launchOp \u003d new PrivilegedOperation(\n        PrivilegedOperation.OperationType.LAUNCH_CONTAINER);\n\n    //All of these arguments are expected to be available in the runtime context\n    launchOp.appendArgs(ctx.getExecutionAttribute(RUN_AS_USER),\n        ctx.getExecutionAttribute(USER),\n        Integer.toString(PrivilegedOperation.\n            RunAsUserCommand.LAUNCH_CONTAINER.getValue()),\n        ctx.getExecutionAttribute(APPID),\n        ctx.getExecutionAttribute(CONTAINER_ID_STR),\n        ctx.getExecutionAttribute(CONTAINER_WORK_DIR).toString(),\n        ctx.getExecutionAttribute(NM_PRIVATE_CONTAINER_SCRIPT_PATH).toUri()\n            .getPath(),\n        ctx.getExecutionAttribute(NM_PRIVATE_TOKENS_PATH).toUri().getPath());\n    Path keystorePath \u003d ctx.getExecutionAttribute(NM_PRIVATE_KEYSTORE_PATH);\n    Path truststorePath \u003d ctx.getExecutionAttribute(NM_PRIVATE_TRUSTSTORE_PATH);\n    if (keystorePath !\u003d null \u0026\u0026 truststorePath !\u003d null) {\n      launchOp.appendArgs(\"--https\",\n          keystorePath.toUri().getPath(),\n          truststorePath.toUri().getPath());\n    } else {\n      launchOp.appendArgs(\"--http\");\n    }\n    launchOp.appendArgs(ctx.getExecutionAttribute(PID_FILE_PATH).toString(),\n        StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n            ctx.getExecutionAttribute(LOCAL_DIRS)),\n        StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n            ctx.getExecutionAttribute(LOG_DIRS)),\n        ctx.getExecutionAttribute(RESOURCES_OPTIONS));\n\n    String tcCommandFile \u003d ctx.getExecutionAttribute(TC_COMMAND_FILE);\n\n    if (tcCommandFile !\u003d null) {\n      launchOp.appendArgs(tcCommandFile);\n    }\n\n    // Some failures here are acceptable. Let the calling executor decide.\n    launchOp.disableFailureLogging();\n\n    //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n    //we can\u0027t do better here thanks to type-erasure\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e prefixCommands \u003d (List\u003cString\u003e) ctx.getExecutionAttribute(\n        CONTAINER_LAUNCH_PREFIX_COMMANDS);\n\n    try {\n      privilegedOperationExecutor.executePrivilegedOperation(prefixCommands,\n            launchOp, null, null, false, false);\n    } catch (PrivilegedOperationException e) {\n      throw new ContainerExecutionException(\"Launch container failed\", e\n          .getExitCode(), e.getOutput(), e.getErrorOutput());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/runtime/DefaultLinuxContainerRuntime.java",
      "extendedDetails": {}
    },
    "502914ca32ac02b19116fd681eb8301b92fccbb3": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7818. Remove privileged operation warnings during container launch for the ContainerRuntimes. Contributed by Shane Kumpf\n",
      "commitDate": "04/05/18 8:53 AM",
      "commitName": "502914ca32ac02b19116fd681eb8301b92fccbb3",
      "commitAuthor": "Billie Rinaldi",
      "commitDateOld": "10/04/18 4:25 PM",
      "commitNameOld": "c467f311d0c7155c09052d93fac12045af925583",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 23.69,
      "commitsBetweenForRepo": 674,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,45 +1,46 @@\n   public void launchContainer(ContainerRuntimeContext ctx)\n       throws ContainerExecutionException {\n     PrivilegedOperation launchOp \u003d new PrivilegedOperation(\n         PrivilegedOperation.OperationType.LAUNCH_CONTAINER);\n \n     //All of these arguments are expected to be available in the runtime context\n     launchOp.appendArgs(ctx.getExecutionAttribute(RUN_AS_USER),\n         ctx.getExecutionAttribute(USER),\n         Integer.toString(PrivilegedOperation.\n             RunAsUserCommand.LAUNCH_CONTAINER.getValue()),\n         ctx.getExecutionAttribute(APPID),\n         ctx.getExecutionAttribute(CONTAINER_ID_STR),\n         ctx.getExecutionAttribute(CONTAINER_WORK_DIR).toString(),\n         ctx.getExecutionAttribute(NM_PRIVATE_CONTAINER_SCRIPT_PATH).toUri()\n             .getPath(),\n         ctx.getExecutionAttribute(NM_PRIVATE_TOKENS_PATH).toUri().getPath(),\n         ctx.getExecutionAttribute(PID_FILE_PATH).toString(),\n         StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n             ctx.getExecutionAttribute(LOCAL_DIRS)),\n         StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n             ctx.getExecutionAttribute(LOG_DIRS)),\n         ctx.getExecutionAttribute(RESOURCES_OPTIONS));\n \n     String tcCommandFile \u003d ctx.getExecutionAttribute(TC_COMMAND_FILE);\n \n     if (tcCommandFile !\u003d null) {\n       launchOp.appendArgs(tcCommandFile);\n     }\n \n+    // Some failures here are acceptable. Let the calling executor decide.\n+    launchOp.disableFailureLogging();\n+\n     //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n     //we can\u0027t do better here thanks to type-erasure\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e prefixCommands \u003d (List\u003cString\u003e) ctx.getExecutionAttribute(\n         CONTAINER_LAUNCH_PREFIX_COMMANDS);\n \n     try {\n       privilegedOperationExecutor.executePrivilegedOperation(prefixCommands,\n             launchOp, null, null, false, false);\n     } catch (PrivilegedOperationException e) {\n-      LOG.warn(\"Launch container failed. Exception: \", e);\n-\n       throw new ContainerExecutionException(\"Launch container failed\", e\n           .getExitCode(), e.getOutput(), e.getErrorOutput());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void launchContainer(ContainerRuntimeContext ctx)\n      throws ContainerExecutionException {\n    PrivilegedOperation launchOp \u003d new PrivilegedOperation(\n        PrivilegedOperation.OperationType.LAUNCH_CONTAINER);\n\n    //All of these arguments are expected to be available in the runtime context\n    launchOp.appendArgs(ctx.getExecutionAttribute(RUN_AS_USER),\n        ctx.getExecutionAttribute(USER),\n        Integer.toString(PrivilegedOperation.\n            RunAsUserCommand.LAUNCH_CONTAINER.getValue()),\n        ctx.getExecutionAttribute(APPID),\n        ctx.getExecutionAttribute(CONTAINER_ID_STR),\n        ctx.getExecutionAttribute(CONTAINER_WORK_DIR).toString(),\n        ctx.getExecutionAttribute(NM_PRIVATE_CONTAINER_SCRIPT_PATH).toUri()\n            .getPath(),\n        ctx.getExecutionAttribute(NM_PRIVATE_TOKENS_PATH).toUri().getPath(),\n        ctx.getExecutionAttribute(PID_FILE_PATH).toString(),\n        StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n            ctx.getExecutionAttribute(LOCAL_DIRS)),\n        StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n            ctx.getExecutionAttribute(LOG_DIRS)),\n        ctx.getExecutionAttribute(RESOURCES_OPTIONS));\n\n    String tcCommandFile \u003d ctx.getExecutionAttribute(TC_COMMAND_FILE);\n\n    if (tcCommandFile !\u003d null) {\n      launchOp.appendArgs(tcCommandFile);\n    }\n\n    // Some failures here are acceptable. Let the calling executor decide.\n    launchOp.disableFailureLogging();\n\n    //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n    //we can\u0027t do better here thanks to type-erasure\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e prefixCommands \u003d (List\u003cString\u003e) ctx.getExecutionAttribute(\n        CONTAINER_LAUNCH_PREFIX_COMMANDS);\n\n    try {\n      privilegedOperationExecutor.executePrivilegedOperation(prefixCommands,\n            launchOp, null, null, false, false);\n    } catch (PrivilegedOperationException e) {\n      throw new ContainerExecutionException(\"Launch container failed\", e\n          .getExitCode(), e.getOutput(), e.getErrorOutput());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/runtime/DefaultLinuxContainerRuntime.java",
      "extendedDetails": {}
    },
    "e5e1851d803bf8d8b96fec1b5c0058014e9329d0": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7034. DefaultLinuxContainerRuntime and DockerLinuxContainerRuntime sends client environment variables to container-executor. Contributed by Miklos Szegedi.\n",
      "commitDate": "21/09/17 2:01 PM",
      "commitName": "e5e1851d803bf8d8b96fec1b5c0058014e9329d0",
      "commitAuthor": "Junping Du",
      "commitDateOld": "22/08/17 1:14 AM",
      "commitNameOld": "d5ff57a08fac983f8b5d201064ce07945f0f216e",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 30.53,
      "commitsBetweenForRepo": 331,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,45 @@\n   public void launchContainer(ContainerRuntimeContext ctx)\n       throws ContainerExecutionException {\n-    Container container \u003d ctx.getContainer();\n     PrivilegedOperation launchOp \u003d new PrivilegedOperation(\n         PrivilegedOperation.OperationType.LAUNCH_CONTAINER);\n \n     //All of these arguments are expected to be available in the runtime context\n     launchOp.appendArgs(ctx.getExecutionAttribute(RUN_AS_USER),\n         ctx.getExecutionAttribute(USER),\n         Integer.toString(PrivilegedOperation.\n             RunAsUserCommand.LAUNCH_CONTAINER.getValue()),\n         ctx.getExecutionAttribute(APPID),\n         ctx.getExecutionAttribute(CONTAINER_ID_STR),\n         ctx.getExecutionAttribute(CONTAINER_WORK_DIR).toString(),\n         ctx.getExecutionAttribute(NM_PRIVATE_CONTAINER_SCRIPT_PATH).toUri()\n             .getPath(),\n         ctx.getExecutionAttribute(NM_PRIVATE_TOKENS_PATH).toUri().getPath(),\n         ctx.getExecutionAttribute(PID_FILE_PATH).toString(),\n         StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n             ctx.getExecutionAttribute(LOCAL_DIRS)),\n         StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n             ctx.getExecutionAttribute(LOG_DIRS)),\n         ctx.getExecutionAttribute(RESOURCES_OPTIONS));\n \n     String tcCommandFile \u003d ctx.getExecutionAttribute(TC_COMMAND_FILE);\n \n     if (tcCommandFile !\u003d null) {\n       launchOp.appendArgs(tcCommandFile);\n     }\n \n     //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n     //we can\u0027t do better here thanks to type-erasure\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e prefixCommands \u003d (List\u003cString\u003e) ctx.getExecutionAttribute(\n         CONTAINER_LAUNCH_PREFIX_COMMANDS);\n \n     try {\n       privilegedOperationExecutor.executePrivilegedOperation(prefixCommands,\n-            launchOp, null, container.getLaunchContext().getEnvironment(),\n-            false, false);\n+            launchOp, null, null, false, false);\n     } catch (PrivilegedOperationException e) {\n       LOG.warn(\"Launch container failed. Exception: \", e);\n \n       throw new ContainerExecutionException(\"Launch container failed\", e\n           .getExitCode(), e.getOutput(), e.getErrorOutput());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void launchContainer(ContainerRuntimeContext ctx)\n      throws ContainerExecutionException {\n    PrivilegedOperation launchOp \u003d new PrivilegedOperation(\n        PrivilegedOperation.OperationType.LAUNCH_CONTAINER);\n\n    //All of these arguments are expected to be available in the runtime context\n    launchOp.appendArgs(ctx.getExecutionAttribute(RUN_AS_USER),\n        ctx.getExecutionAttribute(USER),\n        Integer.toString(PrivilegedOperation.\n            RunAsUserCommand.LAUNCH_CONTAINER.getValue()),\n        ctx.getExecutionAttribute(APPID),\n        ctx.getExecutionAttribute(CONTAINER_ID_STR),\n        ctx.getExecutionAttribute(CONTAINER_WORK_DIR).toString(),\n        ctx.getExecutionAttribute(NM_PRIVATE_CONTAINER_SCRIPT_PATH).toUri()\n            .getPath(),\n        ctx.getExecutionAttribute(NM_PRIVATE_TOKENS_PATH).toUri().getPath(),\n        ctx.getExecutionAttribute(PID_FILE_PATH).toString(),\n        StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n            ctx.getExecutionAttribute(LOCAL_DIRS)),\n        StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n            ctx.getExecutionAttribute(LOG_DIRS)),\n        ctx.getExecutionAttribute(RESOURCES_OPTIONS));\n\n    String tcCommandFile \u003d ctx.getExecutionAttribute(TC_COMMAND_FILE);\n\n    if (tcCommandFile !\u003d null) {\n      launchOp.appendArgs(tcCommandFile);\n    }\n\n    //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n    //we can\u0027t do better here thanks to type-erasure\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e prefixCommands \u003d (List\u003cString\u003e) ctx.getExecutionAttribute(\n        CONTAINER_LAUNCH_PREFIX_COMMANDS);\n\n    try {\n      privilegedOperationExecutor.executePrivilegedOperation(prefixCommands,\n            launchOp, null, null, false, false);\n    } catch (PrivilegedOperationException e) {\n      LOG.warn(\"Launch container failed. Exception: \", e);\n\n      throw new ContainerExecutionException(\"Launch container failed\", e\n          .getExitCode(), e.getOutput(), e.getErrorOutput());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/runtime/DefaultLinuxContainerRuntime.java",
      "extendedDetails": {}
    },
    "9d4d30243b0fc9630da51a2c17b543ef671d035c": {
      "type": "Ybodychange",
      "commitMessage": "Remove parent\u0027s env vars from child processes\n",
      "commitDate": "29/04/16 9:25 AM",
      "commitName": "9d4d30243b0fc9630da51a2c17b543ef671d035c",
      "commitAuthor": "Robert Kanter",
      "commitDateOld": "07/03/16 7:40 AM",
      "commitNameOld": "059caf99891943d9587cac19b48e82efbed06b2d",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 53.03,
      "commitsBetweenForRepo": 320,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,47 @@\n   public void launchContainer(ContainerRuntimeContext ctx)\n       throws ContainerExecutionException {\n     Container container \u003d ctx.getContainer();\n     PrivilegedOperation launchOp \u003d new PrivilegedOperation(\n         PrivilegedOperation.OperationType.LAUNCH_CONTAINER);\n \n     //All of these arguments are expected to be available in the runtime context\n     launchOp.appendArgs(ctx.getExecutionAttribute(RUN_AS_USER),\n         ctx.getExecutionAttribute(USER),\n         Integer.toString(PrivilegedOperation.\n             RunAsUserCommand.LAUNCH_CONTAINER.getValue()),\n         ctx.getExecutionAttribute(APPID),\n         ctx.getExecutionAttribute(CONTAINER_ID_STR),\n         ctx.getExecutionAttribute(CONTAINER_WORK_DIR).toString(),\n         ctx.getExecutionAttribute(NM_PRIVATE_CONTAINER_SCRIPT_PATH).toUri()\n             .getPath(),\n         ctx.getExecutionAttribute(NM_PRIVATE_TOKENS_PATH).toUri().getPath(),\n         ctx.getExecutionAttribute(PID_FILE_PATH).toString(),\n         StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n             ctx.getExecutionAttribute(LOCAL_DIRS)),\n         StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n             ctx.getExecutionAttribute(LOG_DIRS)),\n         ctx.getExecutionAttribute(RESOURCES_OPTIONS));\n \n     String tcCommandFile \u003d ctx.getExecutionAttribute(TC_COMMAND_FILE);\n \n     if (tcCommandFile !\u003d null) {\n       launchOp.appendArgs(tcCommandFile);\n     }\n \n     //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n     //we can\u0027t do better here thanks to type-erasure\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e prefixCommands \u003d (List\u003cString\u003e) ctx.getExecutionAttribute(\n         CONTAINER_LAUNCH_PREFIX_COMMANDS);\n \n     try {\n       privilegedOperationExecutor.executePrivilegedOperation(prefixCommands,\n             launchOp, null, container.getLaunchContext().getEnvironment(),\n-            false);\n+            false, false);\n     } catch (PrivilegedOperationException e) {\n       LOG.warn(\"Launch container failed. Exception: \", e);\n \n       throw new ContainerExecutionException(\"Launch container failed\", e\n           .getExitCode(), e.getOutput(), e.getErrorOutput());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void launchContainer(ContainerRuntimeContext ctx)\n      throws ContainerExecutionException {\n    Container container \u003d ctx.getContainer();\n    PrivilegedOperation launchOp \u003d new PrivilegedOperation(\n        PrivilegedOperation.OperationType.LAUNCH_CONTAINER);\n\n    //All of these arguments are expected to be available in the runtime context\n    launchOp.appendArgs(ctx.getExecutionAttribute(RUN_AS_USER),\n        ctx.getExecutionAttribute(USER),\n        Integer.toString(PrivilegedOperation.\n            RunAsUserCommand.LAUNCH_CONTAINER.getValue()),\n        ctx.getExecutionAttribute(APPID),\n        ctx.getExecutionAttribute(CONTAINER_ID_STR),\n        ctx.getExecutionAttribute(CONTAINER_WORK_DIR).toString(),\n        ctx.getExecutionAttribute(NM_PRIVATE_CONTAINER_SCRIPT_PATH).toUri()\n            .getPath(),\n        ctx.getExecutionAttribute(NM_PRIVATE_TOKENS_PATH).toUri().getPath(),\n        ctx.getExecutionAttribute(PID_FILE_PATH).toString(),\n        StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n            ctx.getExecutionAttribute(LOCAL_DIRS)),\n        StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n            ctx.getExecutionAttribute(LOG_DIRS)),\n        ctx.getExecutionAttribute(RESOURCES_OPTIONS));\n\n    String tcCommandFile \u003d ctx.getExecutionAttribute(TC_COMMAND_FILE);\n\n    if (tcCommandFile !\u003d null) {\n      launchOp.appendArgs(tcCommandFile);\n    }\n\n    //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n    //we can\u0027t do better here thanks to type-erasure\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e prefixCommands \u003d (List\u003cString\u003e) ctx.getExecutionAttribute(\n        CONTAINER_LAUNCH_PREFIX_COMMANDS);\n\n    try {\n      privilegedOperationExecutor.executePrivilegedOperation(prefixCommands,\n            launchOp, null, container.getLaunchContext().getEnvironment(),\n            false, false);\n    } catch (PrivilegedOperationException e) {\n      LOG.warn(\"Launch container failed. Exception: \", e);\n\n      throw new ContainerExecutionException(\"Launch container failed\", e\n          .getExitCode(), e.getOutput(), e.getErrorOutput());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/runtime/DefaultLinuxContainerRuntime.java",
      "extendedDetails": {}
    },
    "059caf99891943d9587cac19b48e82efbed06b2d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4744. Too many signal to container failure in case of LCE. Contributed by Sidharta Seethana\n",
      "commitDate": "07/03/16 7:40 AM",
      "commitName": "059caf99891943d9587cac19b48e82efbed06b2d",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "27/07/15 11:57 AM",
      "commitNameOld": "3e6fce91a471b4a5099de109582e7c6417e8a822",
      "commitAuthorOld": "Varun Vasudev",
      "daysBetweenCommits": 223.86,
      "commitsBetweenForRepo": 1493,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,47 @@\n   public void launchContainer(ContainerRuntimeContext ctx)\n       throws ContainerExecutionException {\n     Container container \u003d ctx.getContainer();\n     PrivilegedOperation launchOp \u003d new PrivilegedOperation(\n-        PrivilegedOperation.OperationType.LAUNCH_CONTAINER, (String) null);\n+        PrivilegedOperation.OperationType.LAUNCH_CONTAINER);\n \n     //All of these arguments are expected to be available in the runtime context\n     launchOp.appendArgs(ctx.getExecutionAttribute(RUN_AS_USER),\n         ctx.getExecutionAttribute(USER),\n         Integer.toString(PrivilegedOperation.\n             RunAsUserCommand.LAUNCH_CONTAINER.getValue()),\n         ctx.getExecutionAttribute(APPID),\n         ctx.getExecutionAttribute(CONTAINER_ID_STR),\n         ctx.getExecutionAttribute(CONTAINER_WORK_DIR).toString(),\n         ctx.getExecutionAttribute(NM_PRIVATE_CONTAINER_SCRIPT_PATH).toUri()\n             .getPath(),\n         ctx.getExecutionAttribute(NM_PRIVATE_TOKENS_PATH).toUri().getPath(),\n         ctx.getExecutionAttribute(PID_FILE_PATH).toString(),\n         StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n             ctx.getExecutionAttribute(LOCAL_DIRS)),\n         StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n             ctx.getExecutionAttribute(LOG_DIRS)),\n         ctx.getExecutionAttribute(RESOURCES_OPTIONS));\n \n     String tcCommandFile \u003d ctx.getExecutionAttribute(TC_COMMAND_FILE);\n \n     if (tcCommandFile !\u003d null) {\n       launchOp.appendArgs(tcCommandFile);\n     }\n \n     //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n     //we can\u0027t do better here thanks to type-erasure\n     @SuppressWarnings(\"unchecked\")\n     List\u003cString\u003e prefixCommands \u003d (List\u003cString\u003e) ctx.getExecutionAttribute(\n         CONTAINER_LAUNCH_PREFIX_COMMANDS);\n \n     try {\n       privilegedOperationExecutor.executePrivilegedOperation(prefixCommands,\n             launchOp, null, container.getLaunchContext().getEnvironment(),\n             false);\n     } catch (PrivilegedOperationException e) {\n       LOG.warn(\"Launch container failed. Exception: \", e);\n \n       throw new ContainerExecutionException(\"Launch container failed\", e\n           .getExitCode(), e.getOutput(), e.getErrorOutput());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void launchContainer(ContainerRuntimeContext ctx)\n      throws ContainerExecutionException {\n    Container container \u003d ctx.getContainer();\n    PrivilegedOperation launchOp \u003d new PrivilegedOperation(\n        PrivilegedOperation.OperationType.LAUNCH_CONTAINER);\n\n    //All of these arguments are expected to be available in the runtime context\n    launchOp.appendArgs(ctx.getExecutionAttribute(RUN_AS_USER),\n        ctx.getExecutionAttribute(USER),\n        Integer.toString(PrivilegedOperation.\n            RunAsUserCommand.LAUNCH_CONTAINER.getValue()),\n        ctx.getExecutionAttribute(APPID),\n        ctx.getExecutionAttribute(CONTAINER_ID_STR),\n        ctx.getExecutionAttribute(CONTAINER_WORK_DIR).toString(),\n        ctx.getExecutionAttribute(NM_PRIVATE_CONTAINER_SCRIPT_PATH).toUri()\n            .getPath(),\n        ctx.getExecutionAttribute(NM_PRIVATE_TOKENS_PATH).toUri().getPath(),\n        ctx.getExecutionAttribute(PID_FILE_PATH).toString(),\n        StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n            ctx.getExecutionAttribute(LOCAL_DIRS)),\n        StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n            ctx.getExecutionAttribute(LOG_DIRS)),\n        ctx.getExecutionAttribute(RESOURCES_OPTIONS));\n\n    String tcCommandFile \u003d ctx.getExecutionAttribute(TC_COMMAND_FILE);\n\n    if (tcCommandFile !\u003d null) {\n      launchOp.appendArgs(tcCommandFile);\n    }\n\n    //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n    //we can\u0027t do better here thanks to type-erasure\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e prefixCommands \u003d (List\u003cString\u003e) ctx.getExecutionAttribute(\n        CONTAINER_LAUNCH_PREFIX_COMMANDS);\n\n    try {\n      privilegedOperationExecutor.executePrivilegedOperation(prefixCommands,\n            launchOp, null, container.getLaunchContext().getEnvironment(),\n            false);\n    } catch (PrivilegedOperationException e) {\n      LOG.warn(\"Launch container failed. Exception: \", e);\n\n      throw new ContainerExecutionException(\"Launch container failed\", e\n          .getExitCode(), e.getOutput(), e.getErrorOutput());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/runtime/DefaultLinuxContainerRuntime.java",
      "extendedDetails": {}
    },
    "3e6fce91a471b4a5099de109582e7c6417e8a822": {
      "type": "Yintroduced",
      "commitMessage": "YARN-3853. Add docker container runtime support to LinuxContainterExecutor. Contributed by Sidharta Seethana.\n",
      "commitDate": "27/07/15 11:57 AM",
      "commitName": "3e6fce91a471b4a5099de109582e7c6417e8a822",
      "commitAuthor": "Varun Vasudev",
      "diff": "@@ -0,0 +1,47 @@\n+  public void launchContainer(ContainerRuntimeContext ctx)\n+      throws ContainerExecutionException {\n+    Container container \u003d ctx.getContainer();\n+    PrivilegedOperation launchOp \u003d new PrivilegedOperation(\n+        PrivilegedOperation.OperationType.LAUNCH_CONTAINER, (String) null);\n+\n+    //All of these arguments are expected to be available in the runtime context\n+    launchOp.appendArgs(ctx.getExecutionAttribute(RUN_AS_USER),\n+        ctx.getExecutionAttribute(USER),\n+        Integer.toString(PrivilegedOperation.\n+            RunAsUserCommand.LAUNCH_CONTAINER.getValue()),\n+        ctx.getExecutionAttribute(APPID),\n+        ctx.getExecutionAttribute(CONTAINER_ID_STR),\n+        ctx.getExecutionAttribute(CONTAINER_WORK_DIR).toString(),\n+        ctx.getExecutionAttribute(NM_PRIVATE_CONTAINER_SCRIPT_PATH).toUri()\n+            .getPath(),\n+        ctx.getExecutionAttribute(NM_PRIVATE_TOKENS_PATH).toUri().getPath(),\n+        ctx.getExecutionAttribute(PID_FILE_PATH).toString(),\n+        StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n+            ctx.getExecutionAttribute(LOCAL_DIRS)),\n+        StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n+            ctx.getExecutionAttribute(LOG_DIRS)),\n+        ctx.getExecutionAttribute(RESOURCES_OPTIONS));\n+\n+    String tcCommandFile \u003d ctx.getExecutionAttribute(TC_COMMAND_FILE);\n+\n+    if (tcCommandFile !\u003d null) {\n+      launchOp.appendArgs(tcCommandFile);\n+    }\n+\n+    //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n+    //we can\u0027t do better here thanks to type-erasure\n+    @SuppressWarnings(\"unchecked\")\n+    List\u003cString\u003e prefixCommands \u003d (List\u003cString\u003e) ctx.getExecutionAttribute(\n+        CONTAINER_LAUNCH_PREFIX_COMMANDS);\n+\n+    try {\n+      privilegedOperationExecutor.executePrivilegedOperation(prefixCommands,\n+            launchOp, null, container.getLaunchContext().getEnvironment(),\n+            false);\n+    } catch (PrivilegedOperationException e) {\n+      LOG.warn(\"Launch container failed. Exception: \", e);\n+\n+      throw new ContainerExecutionException(\"Launch container failed\", e\n+          .getExitCode(), e.getOutput(), e.getErrorOutput());\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void launchContainer(ContainerRuntimeContext ctx)\n      throws ContainerExecutionException {\n    Container container \u003d ctx.getContainer();\n    PrivilegedOperation launchOp \u003d new PrivilegedOperation(\n        PrivilegedOperation.OperationType.LAUNCH_CONTAINER, (String) null);\n\n    //All of these arguments are expected to be available in the runtime context\n    launchOp.appendArgs(ctx.getExecutionAttribute(RUN_AS_USER),\n        ctx.getExecutionAttribute(USER),\n        Integer.toString(PrivilegedOperation.\n            RunAsUserCommand.LAUNCH_CONTAINER.getValue()),\n        ctx.getExecutionAttribute(APPID),\n        ctx.getExecutionAttribute(CONTAINER_ID_STR),\n        ctx.getExecutionAttribute(CONTAINER_WORK_DIR).toString(),\n        ctx.getExecutionAttribute(NM_PRIVATE_CONTAINER_SCRIPT_PATH).toUri()\n            .getPath(),\n        ctx.getExecutionAttribute(NM_PRIVATE_TOKENS_PATH).toUri().getPath(),\n        ctx.getExecutionAttribute(PID_FILE_PATH).toString(),\n        StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n            ctx.getExecutionAttribute(LOCAL_DIRS)),\n        StringUtils.join(PrivilegedOperation.LINUX_FILE_PATH_SEPARATOR,\n            ctx.getExecutionAttribute(LOG_DIRS)),\n        ctx.getExecutionAttribute(RESOURCES_OPTIONS));\n\n    String tcCommandFile \u003d ctx.getExecutionAttribute(TC_COMMAND_FILE);\n\n    if (tcCommandFile !\u003d null) {\n      launchOp.appendArgs(tcCommandFile);\n    }\n\n    //List\u003cString\u003e -\u003e stored as List -\u003e fetched/converted to List\u003cString\u003e\n    //we can\u0027t do better here thanks to type-erasure\n    @SuppressWarnings(\"unchecked\")\n    List\u003cString\u003e prefixCommands \u003d (List\u003cString\u003e) ctx.getExecutionAttribute(\n        CONTAINER_LAUNCH_PREFIX_COMMANDS);\n\n    try {\n      privilegedOperationExecutor.executePrivilegedOperation(prefixCommands,\n            launchOp, null, container.getLaunchContext().getEnvironment(),\n            false);\n    } catch (PrivilegedOperationException e) {\n      LOG.warn(\"Launch container failed. Exception: \", e);\n\n      throw new ContainerExecutionException(\"Launch container failed\", e\n          .getExitCode(), e.getOutput(), e.getErrorOutput());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/runtime/DefaultLinuxContainerRuntime.java"
    }
  }
}