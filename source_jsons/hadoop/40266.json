{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "RegularContainerAllocator.java",
  "functionName": "preCheckForNodeCandidateSet",
  "functionId": "preCheckForNodeCandidateSet___clusterResource-Resource__node-FiCaSchedulerNode__schedulingMode-SchedulingMode__resourceLimits-ResourceLimits__schedulerKey-SchedulerRequestKey",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/allocator/RegularContainerAllocator.java",
  "functionStartLine": 101,
  "functionEndLine": 234,
  "numCommitsSeen": 119,
  "timeTaken": 12789,
  "changeHistory": [
    "8c0759d02a9a530cfdd25e0a8f410cd74a8ac4c8",
    "12b7059ddc8d8f67dd7131565f03a0e09cb92ca7",
    "2064ca015d1584263aac0cc20c60b925a3aff612",
    "9c3fc3ef2865164aa5f121793ac914cfeb21a181",
    "2a0fa50f9d718d51036ccdf30c7d998362fe423b",
    "38af23796971193fa529c3d08ffde8fcd6e607b6",
    "ac4d2b1081d8836a21bc70e77f4e6cd2071a9949",
    "2977bc6a141041ef7579efc416e93fc55e0c2a1a",
    "1bbd023275db535ab80fcb60e022151e9679d468",
    "de3b4aac561258ad242a3c5ed1c919428893fd4c",
    "e0d131f055ee126052ad4d0f7b0d192e6c730188",
    "5aace38b748ba71aaadd2c4d64eba8dc1f816828",
    "620325e81696fca140195b74929ed9eda2d5eb16",
    "6cb0af3c39a5d49cb2f7911ee21363a9542ca2d7",
    "89cab1ba5f0671f8ef30dbe7432079c18362b434",
    "ba2313d6145a1234777938a747187373f4cd58d9"
  ],
  "changeHistoryShort": {
    "8c0759d02a9a530cfdd25e0a8f410cd74a8ac4c8": "Ybodychange",
    "12b7059ddc8d8f67dd7131565f03a0e09cb92ca7": "Ybodychange",
    "2064ca015d1584263aac0cc20c60b925a3aff612": "Ybodychange",
    "9c3fc3ef2865164aa5f121793ac914cfeb21a181": "Ymultichange(Yparameterchange,Ybodychange)",
    "2a0fa50f9d718d51036ccdf30c7d998362fe423b": "Ybodychange",
    "38af23796971193fa529c3d08ffde8fcd6e607b6": "Ybodychange",
    "ac4d2b1081d8836a21bc70e77f4e6cd2071a9949": "Ymultichange(Yrename,Yparameterchange,Ybodychange)",
    "2977bc6a141041ef7579efc416e93fc55e0c2a1a": "Ybodychange",
    "1bbd023275db535ab80fcb60e022151e9679d468": "Ybodychange",
    "de3b4aac561258ad242a3c5ed1c919428893fd4c": "Ymultichange(Yrename,Yparameterchange,Ybodychange)",
    "e0d131f055ee126052ad4d0f7b0d192e6c730188": "Ybodychange",
    "5aace38b748ba71aaadd2c4d64eba8dc1f816828": "Ymultichange(Yparameterchange,Ybodychange)",
    "620325e81696fca140195b74929ed9eda2d5eb16": "Ybodychange",
    "6cb0af3c39a5d49cb2f7911ee21363a9542ca2d7": "Ybodychange",
    "89cab1ba5f0671f8ef30dbe7432079c18362b434": "Ybodychange",
    "ba2313d6145a1234777938a747187373f4cd58d9": "Yintroduced"
  },
  "changeHistoryDetails": {
    "8c0759d02a9a530cfdd25e0a8f410cd74a8ac4c8": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9664. Improve response of scheduler/app activities for better understanding. Contributed by Tao Yang.\n",
      "commitDate": "29/08/19 3:14 AM",
      "commitName": "8c0759d02a9a530cfdd25e0a8f410cd74a8ac4c8",
      "commitAuthor": "Weiwei Yang",
      "commitDateOld": "06/06/19 6:59 AM",
      "commitNameOld": "09763925025a3709e6098186348e1afd80cb9f71",
      "commitAuthorOld": "Weiwei Yang",
      "daysBetweenCommits": 83.84,
      "commitsBetweenForRepo": 744,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,123 +1,134 @@\n   private ContainerAllocation preCheckForNodeCandidateSet(\n       Resource clusterResource, FiCaSchedulerNode node,\n       SchedulingMode schedulingMode, ResourceLimits resourceLimits,\n       SchedulerRequestKey schedulerKey) {\n     PendingAsk offswitchPendingAsk \u003d application.getPendingAsk(schedulerKey,\n         ResourceRequest.ANY);\n \n     if (offswitchPendingAsk.getCount() \u003c\u003d 0) {\n       ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n           activitiesManager, node, application, schedulerKey,\n-          ActivityDiagnosticConstant.PRIORITY_SKIPPED_BECAUSE_NULL_ANY_REQUEST);\n+          ActivityDiagnosticConstant.REQUEST_DO_NOT_NEED_RESOURCE,\n+          ActivityLevel.REQUEST);\n       return ContainerAllocation.PRIORITY_SKIPPED;\n     }\n \n     // Required resource\n     Resource required \u003d offswitchPendingAsk.getPerAllocationResource();\n \n     // Do we need containers at this \u0027priority\u0027?\n     if (application.getOutstandingAsksCount(schedulerKey) \u003c\u003d 0) {\n       ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n           activitiesManager, node, application, schedulerKey,\n-          ActivityDiagnosticConstant.APPLICATION_PRIORITY_DO_NOT_NEED_RESOURCE);\n+          ActivityDiagnosticConstant.REQUEST_DO_NOT_NEED_RESOURCE,\n+          ActivityLevel.REQUEST);\n       return ContainerAllocation.PRIORITY_SKIPPED;\n     }\n \n     // AM container allocation doesn\u0027t support non-exclusive allocation to\n     // avoid painful of preempt an AM container\n     if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n       if (application.isWaitingForAMContainer()) {\n         LOG.debug(\"Skip allocating AM container to app_attempt\u003d{},\"\n             + \" don\u0027t allow to allocate AM container in non-exclusive mode\",\n             application.getApplicationAttemptId());\n         application.updateAppSkipNodeDiagnostics(\n             \"Skipping assigning to Node in Ignore Exclusivity mode. \");\n         ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n             activitiesManager, node, application, schedulerKey,\n-            ActivityDiagnosticConstant.SKIP_IN_IGNORE_EXCLUSIVITY_MODE);\n+            ActivityDiagnosticConstant.\n+                REQUEST_SKIPPED_IN_IGNORE_EXCLUSIVITY_MODE,\n+            ActivityLevel.REQUEST);\n         return ContainerAllocation.APP_SKIPPED;\n       }\n     }\n \n     // Is the nodePartition of pending request matches the node\u0027s partition\n     // If not match, jump to next priority.\n     Optional\u003cDiagnosticsCollector\u003e dcOpt \u003d activitiesManager \u003d\u003d null ?\n         Optional.empty() :\n         activitiesManager.getOptionalDiagnosticsCollector();\n     if (!appInfo.precheckNode(schedulerKey, node, schedulingMode, dcOpt)) {\n       ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n           activitiesManager, node, application, schedulerKey,\n           ActivityDiagnosticConstant.\n               NODE_DO_NOT_MATCH_PARTITION_OR_PLACEMENT_CONSTRAINTS\n-              + ActivitiesManager.getDiagnostics(dcOpt));\n+              + ActivitiesManager.getDiagnostics(dcOpt),\n+          ActivityLevel.NODE);\n       return ContainerAllocation.PRIORITY_SKIPPED;\n     }\n \n     if (!application.getCSLeafQueue().getReservationContinueLooking()) {\n       if (!shouldAllocOrReserveNewContainer(schedulerKey, required)) {\n         LOG.debug(\"doesn\u0027t need containers based on reservation algo!\");\n         ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n             activitiesManager, node, application, schedulerKey,\n-            ActivityDiagnosticConstant.DO_NOT_NEED_ALLOCATIONATTEMPTINFOS);\n+            ActivityDiagnosticConstant.REQUEST_SKIPPED_BECAUSE_OF_RESERVATION,\n+            ActivityLevel.REQUEST);\n         return ContainerAllocation.PRIORITY_SKIPPED;\n       }\n     }\n \n     if (!checkHeadroom(clusterResource, resourceLimits, required,\n         node.getPartition())) {\n       LOG.debug(\"cannot allocate required resource\u003d{} because of headroom\",\n           required);\n-      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n+      ActivitiesLogger.APP.recordAppActivityWithoutAllocation(\n           activitiesManager, node, application, schedulerKey,\n-          ActivityDiagnosticConstant.QUEUE_SKIPPED_HEADROOM);\n+          ActivityDiagnosticConstant.QUEUE_DO_NOT_HAVE_ENOUGH_HEADROOM,\n+          ActivityState.REJECTED,\n+          ActivityLevel.REQUEST);\n       return ContainerAllocation.QUEUE_SKIPPED;\n     }\n \n     // Increase missed-non-partitioned-resource-request-opportunity.\n     // This is to make sure non-partitioned-resource-request will prefer\n     // to be allocated to non-partitioned nodes\n     int missedNonPartitionedRequestSchedulingOpportunity \u003d 0;\n     AppPlacementAllocator appPlacementAllocator \u003d\n         appInfo.getAppPlacementAllocator(schedulerKey);\n     if (null \u003d\u003d appPlacementAllocator){\n       // This is possible when #pending resource decreased by a different\n       // thread.\n       ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n           activitiesManager, node, application, schedulerKey,\n-          ActivityDiagnosticConstant.PRIORITY_SKIPPED_BECAUSE_NULL_ANY_REQUEST);\n+          ActivityDiagnosticConstant.REQUEST_SKIPPED_BECAUSE_NULL_ANY_REQUEST,\n+          ActivityLevel.REQUEST);\n       return ContainerAllocation.PRIORITY_SKIPPED;\n     }\n     String requestPartition \u003d\n         appPlacementAllocator.getPrimaryRequestedNodePartition();\n \n     // Only do this when request associated with given scheduler key accepts\n     // NO_LABEL under RESPECT_EXCLUSIVITY mode\n     if (StringUtils.equals(RMNodeLabelsManager.NO_LABEL, requestPartition)) {\n       missedNonPartitionedRequestSchedulingOpportunity \u003d\n           application.addMissedNonPartitionedRequestSchedulingOpportunity(\n               schedulerKey);\n     }\n \n     if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n       // Before doing allocation, we need to check scheduling opportunity to\n       // make sure : non-partitioned resource request should be scheduled to\n       // non-partitioned partition first.\n       if (missedNonPartitionedRequestSchedulingOpportunity \u003c rmContext\n           .getScheduler().getNumClusterNodes()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Skip app_attempt\u003d\" + application.getApplicationAttemptId()\n               + \" priority\u003d\" + schedulerKey.getPriority()\n               + \" because missed-non-partitioned-resource-request\"\n               + \" opportunity under required:\" + \" Now\u003d\"\n               + missedNonPartitionedRequestSchedulingOpportunity + \" required\u003d\"\n               + rmContext.getScheduler().getNumClusterNodes());\n         }\n         ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n             activitiesManager, node, application, schedulerKey,\n-            ActivityDiagnosticConstant.NON_PARTITIONED_PARTITION_FIRST);\n+            ActivityDiagnosticConstant.\n+                REQUEST_SKIPPED_BECAUSE_NON_PARTITIONED_PARTITION_FIRST,\n+            ActivityLevel.REQUEST);\n         return ContainerAllocation.APP_SKIPPED;\n       }\n     }\n \n     return null;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private ContainerAllocation preCheckForNodeCandidateSet(\n      Resource clusterResource, FiCaSchedulerNode node,\n      SchedulingMode schedulingMode, ResourceLimits resourceLimits,\n      SchedulerRequestKey schedulerKey) {\n    PendingAsk offswitchPendingAsk \u003d application.getPendingAsk(schedulerKey,\n        ResourceRequest.ANY);\n\n    if (offswitchPendingAsk.getCount() \u003c\u003d 0) {\n      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n          activitiesManager, node, application, schedulerKey,\n          ActivityDiagnosticConstant.REQUEST_DO_NOT_NEED_RESOURCE,\n          ActivityLevel.REQUEST);\n      return ContainerAllocation.PRIORITY_SKIPPED;\n    }\n\n    // Required resource\n    Resource required \u003d offswitchPendingAsk.getPerAllocationResource();\n\n    // Do we need containers at this \u0027priority\u0027?\n    if (application.getOutstandingAsksCount(schedulerKey) \u003c\u003d 0) {\n      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n          activitiesManager, node, application, schedulerKey,\n          ActivityDiagnosticConstant.REQUEST_DO_NOT_NEED_RESOURCE,\n          ActivityLevel.REQUEST);\n      return ContainerAllocation.PRIORITY_SKIPPED;\n    }\n\n    // AM container allocation doesn\u0027t support non-exclusive allocation to\n    // avoid painful of preempt an AM container\n    if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n      if (application.isWaitingForAMContainer()) {\n        LOG.debug(\"Skip allocating AM container to app_attempt\u003d{},\"\n            + \" don\u0027t allow to allocate AM container in non-exclusive mode\",\n            application.getApplicationAttemptId());\n        application.updateAppSkipNodeDiagnostics(\n            \"Skipping assigning to Node in Ignore Exclusivity mode. \");\n        ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n            activitiesManager, node, application, schedulerKey,\n            ActivityDiagnosticConstant.\n                REQUEST_SKIPPED_IN_IGNORE_EXCLUSIVITY_MODE,\n            ActivityLevel.REQUEST);\n        return ContainerAllocation.APP_SKIPPED;\n      }\n    }\n\n    // Is the nodePartition of pending request matches the node\u0027s partition\n    // If not match, jump to next priority.\n    Optional\u003cDiagnosticsCollector\u003e dcOpt \u003d activitiesManager \u003d\u003d null ?\n        Optional.empty() :\n        activitiesManager.getOptionalDiagnosticsCollector();\n    if (!appInfo.precheckNode(schedulerKey, node, schedulingMode, dcOpt)) {\n      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n          activitiesManager, node, application, schedulerKey,\n          ActivityDiagnosticConstant.\n              NODE_DO_NOT_MATCH_PARTITION_OR_PLACEMENT_CONSTRAINTS\n              + ActivitiesManager.getDiagnostics(dcOpt),\n          ActivityLevel.NODE);\n      return ContainerAllocation.PRIORITY_SKIPPED;\n    }\n\n    if (!application.getCSLeafQueue().getReservationContinueLooking()) {\n      if (!shouldAllocOrReserveNewContainer(schedulerKey, required)) {\n        LOG.debug(\"doesn\u0027t need containers based on reservation algo!\");\n        ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n            activitiesManager, node, application, schedulerKey,\n            ActivityDiagnosticConstant.REQUEST_SKIPPED_BECAUSE_OF_RESERVATION,\n            ActivityLevel.REQUEST);\n        return ContainerAllocation.PRIORITY_SKIPPED;\n      }\n    }\n\n    if (!checkHeadroom(clusterResource, resourceLimits, required,\n        node.getPartition())) {\n      LOG.debug(\"cannot allocate required resource\u003d{} because of headroom\",\n          required);\n      ActivitiesLogger.APP.recordAppActivityWithoutAllocation(\n          activitiesManager, node, application, schedulerKey,\n          ActivityDiagnosticConstant.QUEUE_DO_NOT_HAVE_ENOUGH_HEADROOM,\n          ActivityState.REJECTED,\n          ActivityLevel.REQUEST);\n      return ContainerAllocation.QUEUE_SKIPPED;\n    }\n\n    // Increase missed-non-partitioned-resource-request-opportunity.\n    // This is to make sure non-partitioned-resource-request will prefer\n    // to be allocated to non-partitioned nodes\n    int missedNonPartitionedRequestSchedulingOpportunity \u003d 0;\n    AppPlacementAllocator appPlacementAllocator \u003d\n        appInfo.getAppPlacementAllocator(schedulerKey);\n    if (null \u003d\u003d appPlacementAllocator){\n      // This is possible when #pending resource decreased by a different\n      // thread.\n      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n          activitiesManager, node, application, schedulerKey,\n          ActivityDiagnosticConstant.REQUEST_SKIPPED_BECAUSE_NULL_ANY_REQUEST,\n          ActivityLevel.REQUEST);\n      return ContainerAllocation.PRIORITY_SKIPPED;\n    }\n    String requestPartition \u003d\n        appPlacementAllocator.getPrimaryRequestedNodePartition();\n\n    // Only do this when request associated with given scheduler key accepts\n    // NO_LABEL under RESPECT_EXCLUSIVITY mode\n    if (StringUtils.equals(RMNodeLabelsManager.NO_LABEL, requestPartition)) {\n      missedNonPartitionedRequestSchedulingOpportunity \u003d\n          application.addMissedNonPartitionedRequestSchedulingOpportunity(\n              schedulerKey);\n    }\n\n    if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n      // Before doing allocation, we need to check scheduling opportunity to\n      // make sure : non-partitioned resource request should be scheduled to\n      // non-partitioned partition first.\n      if (missedNonPartitionedRequestSchedulingOpportunity \u003c rmContext\n          .getScheduler().getNumClusterNodes()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Skip app_attempt\u003d\" + application.getApplicationAttemptId()\n              + \" priority\u003d\" + schedulerKey.getPriority()\n              + \" because missed-non-partitioned-resource-request\"\n              + \" opportunity under required:\" + \" Now\u003d\"\n              + missedNonPartitionedRequestSchedulingOpportunity + \" required\u003d\"\n              + rmContext.getScheduler().getNumClusterNodes());\n        }\n        ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n            activitiesManager, node, application, schedulerKey,\n            ActivityDiagnosticConstant.\n                REQUEST_SKIPPED_BECAUSE_NON_PARTITIONED_PARTITION_FIRST,\n            ActivityLevel.REQUEST);\n        return ContainerAllocation.APP_SKIPPED;\n      }\n    }\n\n    return null;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/allocator/RegularContainerAllocator.java",
      "extendedDetails": {}
    },
    "12b7059ddc8d8f67dd7131565f03a0e09cb92ca7": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9440. Improve diagnostics for scheduler and app activities. Contributed by Tao Yang.\n",
      "commitDate": "06/05/19 5:00 AM",
      "commitName": "12b7059ddc8d8f67dd7131565f03a0e09cb92ca7",
      "commitAuthor": "Weiwei Yang",
      "commitDateOld": "15/03/19 4:20 PM",
      "commitNameOld": "2064ca015d1584263aac0cc20c60b925a3aff612",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 51.53,
      "commitsBetweenForRepo": 314,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,121 +1,123 @@\n   private ContainerAllocation preCheckForNodeCandidateSet(\n       Resource clusterResource, FiCaSchedulerNode node,\n       SchedulingMode schedulingMode, ResourceLimits resourceLimits,\n       SchedulerRequestKey schedulerKey) {\n-    Priority priority \u003d schedulerKey.getPriority();\n-\n     PendingAsk offswitchPendingAsk \u003d application.getPendingAsk(schedulerKey,\n         ResourceRequest.ANY);\n \n     if (offswitchPendingAsk.getCount() \u003c\u003d 0) {\n       ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n-          activitiesManager, node, application, priority,\n+          activitiesManager, node, application, schedulerKey,\n           ActivityDiagnosticConstant.PRIORITY_SKIPPED_BECAUSE_NULL_ANY_REQUEST);\n       return ContainerAllocation.PRIORITY_SKIPPED;\n     }\n \n     // Required resource\n     Resource required \u003d offswitchPendingAsk.getPerAllocationResource();\n \n     // Do we need containers at this \u0027priority\u0027?\n     if (application.getOutstandingAsksCount(schedulerKey) \u003c\u003d 0) {\n       ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n-          activitiesManager, node, application, priority,\n+          activitiesManager, node, application, schedulerKey,\n           ActivityDiagnosticConstant.APPLICATION_PRIORITY_DO_NOT_NEED_RESOURCE);\n       return ContainerAllocation.PRIORITY_SKIPPED;\n     }\n \n     // AM container allocation doesn\u0027t support non-exclusive allocation to\n     // avoid painful of preempt an AM container\n     if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n       if (application.isWaitingForAMContainer()) {\n         LOG.debug(\"Skip allocating AM container to app_attempt\u003d{},\"\n             + \" don\u0027t allow to allocate AM container in non-exclusive mode\",\n             application.getApplicationAttemptId());\n         application.updateAppSkipNodeDiagnostics(\n             \"Skipping assigning to Node in Ignore Exclusivity mode. \");\n         ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n-            activitiesManager, node, application, priority,\n+            activitiesManager, node, application, schedulerKey,\n             ActivityDiagnosticConstant.SKIP_IN_IGNORE_EXCLUSIVITY_MODE);\n         return ContainerAllocation.APP_SKIPPED;\n       }\n     }\n \n     // Is the nodePartition of pending request matches the node\u0027s partition\n     // If not match, jump to next priority.\n-    if (!appInfo.precheckNode(schedulerKey, node, schedulingMode)) {\n+    Optional\u003cDiagnosticsCollector\u003e dcOpt \u003d activitiesManager \u003d\u003d null ?\n+        Optional.empty() :\n+        activitiesManager.getOptionalDiagnosticsCollector();\n+    if (!appInfo.precheckNode(schedulerKey, node, schedulingMode, dcOpt)) {\n       ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n-          activitiesManager, node, application, priority,\n+          activitiesManager, node, application, schedulerKey,\n           ActivityDiagnosticConstant.\n-              PRIORITY_SKIPPED_BECAUSE_NODE_PARTITION_DOES_NOT_MATCH_REQUEST);\n+              NODE_DO_NOT_MATCH_PARTITION_OR_PLACEMENT_CONSTRAINTS\n+              + ActivitiesManager.getDiagnostics(dcOpt));\n       return ContainerAllocation.PRIORITY_SKIPPED;\n     }\n \n     if (!application.getCSLeafQueue().getReservationContinueLooking()) {\n       if (!shouldAllocOrReserveNewContainer(schedulerKey, required)) {\n         LOG.debug(\"doesn\u0027t need containers based on reservation algo!\");\n         ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n-            activitiesManager, node, application, priority,\n+            activitiesManager, node, application, schedulerKey,\n             ActivityDiagnosticConstant.DO_NOT_NEED_ALLOCATIONATTEMPTINFOS);\n         return ContainerAllocation.PRIORITY_SKIPPED;\n       }\n     }\n \n     if (!checkHeadroom(clusterResource, resourceLimits, required,\n         node.getPartition())) {\n       LOG.debug(\"cannot allocate required resource\u003d{} because of headroom\",\n           required);\n       ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n-          activitiesManager, node, application, priority,\n+          activitiesManager, node, application, schedulerKey,\n           ActivityDiagnosticConstant.QUEUE_SKIPPED_HEADROOM);\n       return ContainerAllocation.QUEUE_SKIPPED;\n     }\n \n     // Increase missed-non-partitioned-resource-request-opportunity.\n     // This is to make sure non-partitioned-resource-request will prefer\n     // to be allocated to non-partitioned nodes\n     int missedNonPartitionedRequestSchedulingOpportunity \u003d 0;\n     AppPlacementAllocator appPlacementAllocator \u003d\n         appInfo.getAppPlacementAllocator(schedulerKey);\n     if (null \u003d\u003d appPlacementAllocator){\n       // This is possible when #pending resource decreased by a different\n       // thread.\n       ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n-          activitiesManager, node, application, priority,\n+          activitiesManager, node, application, schedulerKey,\n           ActivityDiagnosticConstant.PRIORITY_SKIPPED_BECAUSE_NULL_ANY_REQUEST);\n       return ContainerAllocation.PRIORITY_SKIPPED;\n     }\n     String requestPartition \u003d\n         appPlacementAllocator.getPrimaryRequestedNodePartition();\n \n     // Only do this when request associated with given scheduler key accepts\n     // NO_LABEL under RESPECT_EXCLUSIVITY mode\n     if (StringUtils.equals(RMNodeLabelsManager.NO_LABEL, requestPartition)) {\n       missedNonPartitionedRequestSchedulingOpportunity \u003d\n           application.addMissedNonPartitionedRequestSchedulingOpportunity(\n               schedulerKey);\n     }\n \n     if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n       // Before doing allocation, we need to check scheduling opportunity to\n       // make sure : non-partitioned resource request should be scheduled to\n       // non-partitioned partition first.\n       if (missedNonPartitionedRequestSchedulingOpportunity \u003c rmContext\n           .getScheduler().getNumClusterNodes()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Skip app_attempt\u003d\" + application.getApplicationAttemptId()\n               + \" priority\u003d\" + schedulerKey.getPriority()\n               + \" because missed-non-partitioned-resource-request\"\n               + \" opportunity under required:\" + \" Now\u003d\"\n               + missedNonPartitionedRequestSchedulingOpportunity + \" required\u003d\"\n               + rmContext.getScheduler().getNumClusterNodes());\n         }\n         ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n-            activitiesManager, node, application, priority,\n+            activitiesManager, node, application, schedulerKey,\n             ActivityDiagnosticConstant.NON_PARTITIONED_PARTITION_FIRST);\n         return ContainerAllocation.APP_SKIPPED;\n       }\n     }\n \n     return null;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private ContainerAllocation preCheckForNodeCandidateSet(\n      Resource clusterResource, FiCaSchedulerNode node,\n      SchedulingMode schedulingMode, ResourceLimits resourceLimits,\n      SchedulerRequestKey schedulerKey) {\n    PendingAsk offswitchPendingAsk \u003d application.getPendingAsk(schedulerKey,\n        ResourceRequest.ANY);\n\n    if (offswitchPendingAsk.getCount() \u003c\u003d 0) {\n      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n          activitiesManager, node, application, schedulerKey,\n          ActivityDiagnosticConstant.PRIORITY_SKIPPED_BECAUSE_NULL_ANY_REQUEST);\n      return ContainerAllocation.PRIORITY_SKIPPED;\n    }\n\n    // Required resource\n    Resource required \u003d offswitchPendingAsk.getPerAllocationResource();\n\n    // Do we need containers at this \u0027priority\u0027?\n    if (application.getOutstandingAsksCount(schedulerKey) \u003c\u003d 0) {\n      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n          activitiesManager, node, application, schedulerKey,\n          ActivityDiagnosticConstant.APPLICATION_PRIORITY_DO_NOT_NEED_RESOURCE);\n      return ContainerAllocation.PRIORITY_SKIPPED;\n    }\n\n    // AM container allocation doesn\u0027t support non-exclusive allocation to\n    // avoid painful of preempt an AM container\n    if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n      if (application.isWaitingForAMContainer()) {\n        LOG.debug(\"Skip allocating AM container to app_attempt\u003d{},\"\n            + \" don\u0027t allow to allocate AM container in non-exclusive mode\",\n            application.getApplicationAttemptId());\n        application.updateAppSkipNodeDiagnostics(\n            \"Skipping assigning to Node in Ignore Exclusivity mode. \");\n        ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n            activitiesManager, node, application, schedulerKey,\n            ActivityDiagnosticConstant.SKIP_IN_IGNORE_EXCLUSIVITY_MODE);\n        return ContainerAllocation.APP_SKIPPED;\n      }\n    }\n\n    // Is the nodePartition of pending request matches the node\u0027s partition\n    // If not match, jump to next priority.\n    Optional\u003cDiagnosticsCollector\u003e dcOpt \u003d activitiesManager \u003d\u003d null ?\n        Optional.empty() :\n        activitiesManager.getOptionalDiagnosticsCollector();\n    if (!appInfo.precheckNode(schedulerKey, node, schedulingMode, dcOpt)) {\n      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n          activitiesManager, node, application, schedulerKey,\n          ActivityDiagnosticConstant.\n              NODE_DO_NOT_MATCH_PARTITION_OR_PLACEMENT_CONSTRAINTS\n              + ActivitiesManager.getDiagnostics(dcOpt));\n      return ContainerAllocation.PRIORITY_SKIPPED;\n    }\n\n    if (!application.getCSLeafQueue().getReservationContinueLooking()) {\n      if (!shouldAllocOrReserveNewContainer(schedulerKey, required)) {\n        LOG.debug(\"doesn\u0027t need containers based on reservation algo!\");\n        ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n            activitiesManager, node, application, schedulerKey,\n            ActivityDiagnosticConstant.DO_NOT_NEED_ALLOCATIONATTEMPTINFOS);\n        return ContainerAllocation.PRIORITY_SKIPPED;\n      }\n    }\n\n    if (!checkHeadroom(clusterResource, resourceLimits, required,\n        node.getPartition())) {\n      LOG.debug(\"cannot allocate required resource\u003d{} because of headroom\",\n          required);\n      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n          activitiesManager, node, application, schedulerKey,\n          ActivityDiagnosticConstant.QUEUE_SKIPPED_HEADROOM);\n      return ContainerAllocation.QUEUE_SKIPPED;\n    }\n\n    // Increase missed-non-partitioned-resource-request-opportunity.\n    // This is to make sure non-partitioned-resource-request will prefer\n    // to be allocated to non-partitioned nodes\n    int missedNonPartitionedRequestSchedulingOpportunity \u003d 0;\n    AppPlacementAllocator appPlacementAllocator \u003d\n        appInfo.getAppPlacementAllocator(schedulerKey);\n    if (null \u003d\u003d appPlacementAllocator){\n      // This is possible when #pending resource decreased by a different\n      // thread.\n      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n          activitiesManager, node, application, schedulerKey,\n          ActivityDiagnosticConstant.PRIORITY_SKIPPED_BECAUSE_NULL_ANY_REQUEST);\n      return ContainerAllocation.PRIORITY_SKIPPED;\n    }\n    String requestPartition \u003d\n        appPlacementAllocator.getPrimaryRequestedNodePartition();\n\n    // Only do this when request associated with given scheduler key accepts\n    // NO_LABEL under RESPECT_EXCLUSIVITY mode\n    if (StringUtils.equals(RMNodeLabelsManager.NO_LABEL, requestPartition)) {\n      missedNonPartitionedRequestSchedulingOpportunity \u003d\n          application.addMissedNonPartitionedRequestSchedulingOpportunity(\n              schedulerKey);\n    }\n\n    if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n      // Before doing allocation, we need to check scheduling opportunity to\n      // make sure : non-partitioned resource request should be scheduled to\n      // non-partitioned partition first.\n      if (missedNonPartitionedRequestSchedulingOpportunity \u003c rmContext\n          .getScheduler().getNumClusterNodes()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Skip app_attempt\u003d\" + application.getApplicationAttemptId()\n              + \" priority\u003d\" + schedulerKey.getPriority()\n              + \" because missed-non-partitioned-resource-request\"\n              + \" opportunity under required:\" + \" Now\u003d\"\n              + missedNonPartitionedRequestSchedulingOpportunity + \" required\u003d\"\n              + rmContext.getScheduler().getNumClusterNodes());\n        }\n        ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n            activitiesManager, node, application, schedulerKey,\n            ActivityDiagnosticConstant.NON_PARTITIONED_PARTITION_FIRST);\n        return ContainerAllocation.APP_SKIPPED;\n      }\n    }\n\n    return null;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/allocator/RegularContainerAllocator.java",
      "extendedDetails": {}
    },
    "2064ca015d1584263aac0cc20c60b925a3aff612": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9349.  Changed logging to use slf4j api.\n            Contributed by Prabhu Joseph\n",
      "commitDate": "15/03/19 4:20 PM",
      "commitName": "2064ca015d1584263aac0cc20c60b925a3aff612",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "04/03/19 9:10 PM",
      "commitNameOld": "e40e2d6ad5cbe782c3a067229270738b501ed27e",
      "commitAuthorOld": "Prabhu Joseph",
      "daysBetweenCommits": 10.76,
      "commitsBetweenForRepo": 108,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,127 +1,121 @@\n   private ContainerAllocation preCheckForNodeCandidateSet(\n       Resource clusterResource, FiCaSchedulerNode node,\n       SchedulingMode schedulingMode, ResourceLimits resourceLimits,\n       SchedulerRequestKey schedulerKey) {\n     Priority priority \u003d schedulerKey.getPriority();\n \n     PendingAsk offswitchPendingAsk \u003d application.getPendingAsk(schedulerKey,\n         ResourceRequest.ANY);\n \n     if (offswitchPendingAsk.getCount() \u003c\u003d 0) {\n       ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n           activitiesManager, node, application, priority,\n           ActivityDiagnosticConstant.PRIORITY_SKIPPED_BECAUSE_NULL_ANY_REQUEST);\n       return ContainerAllocation.PRIORITY_SKIPPED;\n     }\n \n     // Required resource\n     Resource required \u003d offswitchPendingAsk.getPerAllocationResource();\n \n     // Do we need containers at this \u0027priority\u0027?\n     if (application.getOutstandingAsksCount(schedulerKey) \u003c\u003d 0) {\n       ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n           activitiesManager, node, application, priority,\n           ActivityDiagnosticConstant.APPLICATION_PRIORITY_DO_NOT_NEED_RESOURCE);\n       return ContainerAllocation.PRIORITY_SKIPPED;\n     }\n \n     // AM container allocation doesn\u0027t support non-exclusive allocation to\n     // avoid painful of preempt an AM container\n     if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n       if (application.isWaitingForAMContainer()) {\n-        if (LOG.isDebugEnabled()) {\n-          LOG.debug(\"Skip allocating AM container to app_attempt\u003d\"\n-              + application.getApplicationAttemptId()\n-              + \", don\u0027t allow to allocate AM container in non-exclusive mode\");\n-        }\n+        LOG.debug(\"Skip allocating AM container to app_attempt\u003d{},\"\n+            + \" don\u0027t allow to allocate AM container in non-exclusive mode\",\n+            application.getApplicationAttemptId());\n         application.updateAppSkipNodeDiagnostics(\n             \"Skipping assigning to Node in Ignore Exclusivity mode. \");\n         ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n             activitiesManager, node, application, priority,\n             ActivityDiagnosticConstant.SKIP_IN_IGNORE_EXCLUSIVITY_MODE);\n         return ContainerAllocation.APP_SKIPPED;\n       }\n     }\n \n     // Is the nodePartition of pending request matches the node\u0027s partition\n     // If not match, jump to next priority.\n     if (!appInfo.precheckNode(schedulerKey, node, schedulingMode)) {\n       ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n           activitiesManager, node, application, priority,\n           ActivityDiagnosticConstant.\n               PRIORITY_SKIPPED_BECAUSE_NODE_PARTITION_DOES_NOT_MATCH_REQUEST);\n       return ContainerAllocation.PRIORITY_SKIPPED;\n     }\n \n     if (!application.getCSLeafQueue().getReservationContinueLooking()) {\n       if (!shouldAllocOrReserveNewContainer(schedulerKey, required)) {\n-        if (LOG.isDebugEnabled()) {\n-          LOG.debug(\"doesn\u0027t need containers based on reservation algo!\");\n-        }\n+        LOG.debug(\"doesn\u0027t need containers based on reservation algo!\");\n         ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n             activitiesManager, node, application, priority,\n             ActivityDiagnosticConstant.DO_NOT_NEED_ALLOCATIONATTEMPTINFOS);\n         return ContainerAllocation.PRIORITY_SKIPPED;\n       }\n     }\n \n     if (!checkHeadroom(clusterResource, resourceLimits, required,\n         node.getPartition())) {\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"cannot allocate required resource\u003d\" + required\n-            + \" because of headroom\");\n-      }\n+      LOG.debug(\"cannot allocate required resource\u003d{} because of headroom\",\n+          required);\n       ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n           activitiesManager, node, application, priority,\n           ActivityDiagnosticConstant.QUEUE_SKIPPED_HEADROOM);\n       return ContainerAllocation.QUEUE_SKIPPED;\n     }\n \n     // Increase missed-non-partitioned-resource-request-opportunity.\n     // This is to make sure non-partitioned-resource-request will prefer\n     // to be allocated to non-partitioned nodes\n     int missedNonPartitionedRequestSchedulingOpportunity \u003d 0;\n     AppPlacementAllocator appPlacementAllocator \u003d\n         appInfo.getAppPlacementAllocator(schedulerKey);\n     if (null \u003d\u003d appPlacementAllocator){\n       // This is possible when #pending resource decreased by a different\n       // thread.\n       ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n           activitiesManager, node, application, priority,\n           ActivityDiagnosticConstant.PRIORITY_SKIPPED_BECAUSE_NULL_ANY_REQUEST);\n       return ContainerAllocation.PRIORITY_SKIPPED;\n     }\n     String requestPartition \u003d\n         appPlacementAllocator.getPrimaryRequestedNodePartition();\n \n     // Only do this when request associated with given scheduler key accepts\n     // NO_LABEL under RESPECT_EXCLUSIVITY mode\n     if (StringUtils.equals(RMNodeLabelsManager.NO_LABEL, requestPartition)) {\n       missedNonPartitionedRequestSchedulingOpportunity \u003d\n           application.addMissedNonPartitionedRequestSchedulingOpportunity(\n               schedulerKey);\n     }\n \n     if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n       // Before doing allocation, we need to check scheduling opportunity to\n       // make sure : non-partitioned resource request should be scheduled to\n       // non-partitioned partition first.\n       if (missedNonPartitionedRequestSchedulingOpportunity \u003c rmContext\n           .getScheduler().getNumClusterNodes()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Skip app_attempt\u003d\" + application.getApplicationAttemptId()\n               + \" priority\u003d\" + schedulerKey.getPriority()\n               + \" because missed-non-partitioned-resource-request\"\n               + \" opportunity under required:\" + \" Now\u003d\"\n               + missedNonPartitionedRequestSchedulingOpportunity + \" required\u003d\"\n               + rmContext.getScheduler().getNumClusterNodes());\n         }\n         ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n             activitiesManager, node, application, priority,\n             ActivityDiagnosticConstant.NON_PARTITIONED_PARTITION_FIRST);\n         return ContainerAllocation.APP_SKIPPED;\n       }\n     }\n \n     return null;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private ContainerAllocation preCheckForNodeCandidateSet(\n      Resource clusterResource, FiCaSchedulerNode node,\n      SchedulingMode schedulingMode, ResourceLimits resourceLimits,\n      SchedulerRequestKey schedulerKey) {\n    Priority priority \u003d schedulerKey.getPriority();\n\n    PendingAsk offswitchPendingAsk \u003d application.getPendingAsk(schedulerKey,\n        ResourceRequest.ANY);\n\n    if (offswitchPendingAsk.getCount() \u003c\u003d 0) {\n      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n          activitiesManager, node, application, priority,\n          ActivityDiagnosticConstant.PRIORITY_SKIPPED_BECAUSE_NULL_ANY_REQUEST);\n      return ContainerAllocation.PRIORITY_SKIPPED;\n    }\n\n    // Required resource\n    Resource required \u003d offswitchPendingAsk.getPerAllocationResource();\n\n    // Do we need containers at this \u0027priority\u0027?\n    if (application.getOutstandingAsksCount(schedulerKey) \u003c\u003d 0) {\n      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n          activitiesManager, node, application, priority,\n          ActivityDiagnosticConstant.APPLICATION_PRIORITY_DO_NOT_NEED_RESOURCE);\n      return ContainerAllocation.PRIORITY_SKIPPED;\n    }\n\n    // AM container allocation doesn\u0027t support non-exclusive allocation to\n    // avoid painful of preempt an AM container\n    if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n      if (application.isWaitingForAMContainer()) {\n        LOG.debug(\"Skip allocating AM container to app_attempt\u003d{},\"\n            + \" don\u0027t allow to allocate AM container in non-exclusive mode\",\n            application.getApplicationAttemptId());\n        application.updateAppSkipNodeDiagnostics(\n            \"Skipping assigning to Node in Ignore Exclusivity mode. \");\n        ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n            activitiesManager, node, application, priority,\n            ActivityDiagnosticConstant.SKIP_IN_IGNORE_EXCLUSIVITY_MODE);\n        return ContainerAllocation.APP_SKIPPED;\n      }\n    }\n\n    // Is the nodePartition of pending request matches the node\u0027s partition\n    // If not match, jump to next priority.\n    if (!appInfo.precheckNode(schedulerKey, node, schedulingMode)) {\n      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n          activitiesManager, node, application, priority,\n          ActivityDiagnosticConstant.\n              PRIORITY_SKIPPED_BECAUSE_NODE_PARTITION_DOES_NOT_MATCH_REQUEST);\n      return ContainerAllocation.PRIORITY_SKIPPED;\n    }\n\n    if (!application.getCSLeafQueue().getReservationContinueLooking()) {\n      if (!shouldAllocOrReserveNewContainer(schedulerKey, required)) {\n        LOG.debug(\"doesn\u0027t need containers based on reservation algo!\");\n        ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n            activitiesManager, node, application, priority,\n            ActivityDiagnosticConstant.DO_NOT_NEED_ALLOCATIONATTEMPTINFOS);\n        return ContainerAllocation.PRIORITY_SKIPPED;\n      }\n    }\n\n    if (!checkHeadroom(clusterResource, resourceLimits, required,\n        node.getPartition())) {\n      LOG.debug(\"cannot allocate required resource\u003d{} because of headroom\",\n          required);\n      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n          activitiesManager, node, application, priority,\n          ActivityDiagnosticConstant.QUEUE_SKIPPED_HEADROOM);\n      return ContainerAllocation.QUEUE_SKIPPED;\n    }\n\n    // Increase missed-non-partitioned-resource-request-opportunity.\n    // This is to make sure non-partitioned-resource-request will prefer\n    // to be allocated to non-partitioned nodes\n    int missedNonPartitionedRequestSchedulingOpportunity \u003d 0;\n    AppPlacementAllocator appPlacementAllocator \u003d\n        appInfo.getAppPlacementAllocator(schedulerKey);\n    if (null \u003d\u003d appPlacementAllocator){\n      // This is possible when #pending resource decreased by a different\n      // thread.\n      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n          activitiesManager, node, application, priority,\n          ActivityDiagnosticConstant.PRIORITY_SKIPPED_BECAUSE_NULL_ANY_REQUEST);\n      return ContainerAllocation.PRIORITY_SKIPPED;\n    }\n    String requestPartition \u003d\n        appPlacementAllocator.getPrimaryRequestedNodePartition();\n\n    // Only do this when request associated with given scheduler key accepts\n    // NO_LABEL under RESPECT_EXCLUSIVITY mode\n    if (StringUtils.equals(RMNodeLabelsManager.NO_LABEL, requestPartition)) {\n      missedNonPartitionedRequestSchedulingOpportunity \u003d\n          application.addMissedNonPartitionedRequestSchedulingOpportunity(\n              schedulerKey);\n    }\n\n    if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n      // Before doing allocation, we need to check scheduling opportunity to\n      // make sure : non-partitioned resource request should be scheduled to\n      // non-partitioned partition first.\n      if (missedNonPartitionedRequestSchedulingOpportunity \u003c rmContext\n          .getScheduler().getNumClusterNodes()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Skip app_attempt\u003d\" + application.getApplicationAttemptId()\n              + \" priority\u003d\" + schedulerKey.getPriority()\n              + \" because missed-non-partitioned-resource-request\"\n              + \" opportunity under required:\" + \" Now\u003d\"\n              + missedNonPartitionedRequestSchedulingOpportunity + \" required\u003d\"\n              + rmContext.getScheduler().getNumClusterNodes());\n        }\n        ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n            activitiesManager, node, application, priority,\n            ActivityDiagnosticConstant.NON_PARTITIONED_PARTITION_FIRST);\n        return ContainerAllocation.APP_SKIPPED;\n      }\n    }\n\n    return null;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/allocator/RegularContainerAllocator.java",
      "extendedDetails": {}
    },
    "9c3fc3ef2865164aa5f121793ac914cfeb21a181": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-7494. Add muti-node lookup mechanism and pluggable nodes sorting policies to optimize placement decision. Contributed by Sunil Govindan.\n",
      "commitDate": "21/08/18 7:42 AM",
      "commitName": "9c3fc3ef2865164aa5f121793ac914cfeb21a181",
      "commitAuthor": "Weiwei Yang",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-7494. Add muti-node lookup mechanism and pluggable nodes sorting policies to optimize placement decision. Contributed by Sunil Govindan.\n",
          "commitDate": "21/08/18 7:42 AM",
          "commitName": "9c3fc3ef2865164aa5f121793ac914cfeb21a181",
          "commitAuthor": "Weiwei Yang",
          "commitDateOld": "20/07/18 10:46 AM",
          "commitNameOld": "8a6bb8409c2dc695c0ffc70df0528d7f8bd5d795",
          "commitAuthorOld": "Haibo Chen",
          "daysBetweenCommits": 31.87,
          "commitsBetweenForRepo": 275,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,128 +1,127 @@\n   private ContainerAllocation preCheckForNodeCandidateSet(\n-      Resource clusterResource, CandidateNodeSet\u003cFiCaSchedulerNode\u003e candidates,\n+      Resource clusterResource, FiCaSchedulerNode node,\n       SchedulingMode schedulingMode, ResourceLimits resourceLimits,\n       SchedulerRequestKey schedulerKey) {\n     Priority priority \u003d schedulerKey.getPriority();\n-    FiCaSchedulerNode node \u003d CandidateNodeSetUtils.getSingleNode(candidates);\n \n     PendingAsk offswitchPendingAsk \u003d application.getPendingAsk(schedulerKey,\n         ResourceRequest.ANY);\n \n     if (offswitchPendingAsk.getCount() \u003c\u003d 0) {\n       ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n           activitiesManager, node, application, priority,\n           ActivityDiagnosticConstant.PRIORITY_SKIPPED_BECAUSE_NULL_ANY_REQUEST);\n       return ContainerAllocation.PRIORITY_SKIPPED;\n     }\n \n     // Required resource\n     Resource required \u003d offswitchPendingAsk.getPerAllocationResource();\n \n     // Do we need containers at this \u0027priority\u0027?\n     if (application.getOutstandingAsksCount(schedulerKey) \u003c\u003d 0) {\n       ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n           activitiesManager, node, application, priority,\n           ActivityDiagnosticConstant.APPLICATION_PRIORITY_DO_NOT_NEED_RESOURCE);\n       return ContainerAllocation.PRIORITY_SKIPPED;\n     }\n \n     // AM container allocation doesn\u0027t support non-exclusive allocation to\n     // avoid painful of preempt an AM container\n     if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n       if (application.isWaitingForAMContainer()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Skip allocating AM container to app_attempt\u003d\"\n               + application.getApplicationAttemptId()\n               + \", don\u0027t allow to allocate AM container in non-exclusive mode\");\n         }\n         application.updateAppSkipNodeDiagnostics(\n             \"Skipping assigning to Node in Ignore Exclusivity mode. \");\n         ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n             activitiesManager, node, application, priority,\n             ActivityDiagnosticConstant.SKIP_IN_IGNORE_EXCLUSIVITY_MODE);\n         return ContainerAllocation.APP_SKIPPED;\n       }\n     }\n \n     // Is the nodePartition of pending request matches the node\u0027s partition\n     // If not match, jump to next priority.\n     if (!appInfo.precheckNode(schedulerKey, node, schedulingMode)) {\n       ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n           activitiesManager, node, application, priority,\n           ActivityDiagnosticConstant.\n               PRIORITY_SKIPPED_BECAUSE_NODE_PARTITION_DOES_NOT_MATCH_REQUEST);\n       return ContainerAllocation.PRIORITY_SKIPPED;\n     }\n \n     if (!application.getCSLeafQueue().getReservationContinueLooking()) {\n       if (!shouldAllocOrReserveNewContainer(schedulerKey, required)) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"doesn\u0027t need containers based on reservation algo!\");\n         }\n         ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n             activitiesManager, node, application, priority,\n             ActivityDiagnosticConstant.DO_NOT_NEED_ALLOCATIONATTEMPTINFOS);\n         return ContainerAllocation.PRIORITY_SKIPPED;\n       }\n     }\n \n     if (!checkHeadroom(clusterResource, resourceLimits, required,\n-        candidates.getPartition())) {\n+        node.getPartition())) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"cannot allocate required resource\u003d\" + required\n             + \" because of headroom\");\n       }\n       ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n           activitiesManager, node, application, priority,\n           ActivityDiagnosticConstant.QUEUE_SKIPPED_HEADROOM);\n       return ContainerAllocation.QUEUE_SKIPPED;\n     }\n \n     // Increase missed-non-partitioned-resource-request-opportunity.\n     // This is to make sure non-partitioned-resource-request will prefer\n     // to be allocated to non-partitioned nodes\n     int missedNonPartitionedRequestSchedulingOpportunity \u003d 0;\n     AppPlacementAllocator appPlacementAllocator \u003d\n         appInfo.getAppPlacementAllocator(schedulerKey);\n     if (null \u003d\u003d appPlacementAllocator){\n       // This is possible when #pending resource decreased by a different\n       // thread.\n       ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n           activitiesManager, node, application, priority,\n           ActivityDiagnosticConstant.PRIORITY_SKIPPED_BECAUSE_NULL_ANY_REQUEST);\n       return ContainerAllocation.PRIORITY_SKIPPED;\n     }\n     String requestPartition \u003d\n         appPlacementAllocator.getPrimaryRequestedNodePartition();\n \n     // Only do this when request associated with given scheduler key accepts\n     // NO_LABEL under RESPECT_EXCLUSIVITY mode\n     if (StringUtils.equals(RMNodeLabelsManager.NO_LABEL, requestPartition)) {\n       missedNonPartitionedRequestSchedulingOpportunity \u003d\n           application.addMissedNonPartitionedRequestSchedulingOpportunity(\n               schedulerKey);\n     }\n \n     if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n       // Before doing allocation, we need to check scheduling opportunity to\n       // make sure : non-partitioned resource request should be scheduled to\n       // non-partitioned partition first.\n       if (missedNonPartitionedRequestSchedulingOpportunity \u003c rmContext\n           .getScheduler().getNumClusterNodes()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Skip app_attempt\u003d\" + application.getApplicationAttemptId()\n               + \" priority\u003d\" + schedulerKey.getPriority()\n               + \" because missed-non-partitioned-resource-request\"\n               + \" opportunity under required:\" + \" Now\u003d\"\n               + missedNonPartitionedRequestSchedulingOpportunity + \" required\u003d\"\n               + rmContext.getScheduler().getNumClusterNodes());\n         }\n         ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n             activitiesManager, node, application, priority,\n             ActivityDiagnosticConstant.NON_PARTITIONED_PARTITION_FIRST);\n         return ContainerAllocation.APP_SKIPPED;\n       }\n     }\n \n     return null;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private ContainerAllocation preCheckForNodeCandidateSet(\n      Resource clusterResource, FiCaSchedulerNode node,\n      SchedulingMode schedulingMode, ResourceLimits resourceLimits,\n      SchedulerRequestKey schedulerKey) {\n    Priority priority \u003d schedulerKey.getPriority();\n\n    PendingAsk offswitchPendingAsk \u003d application.getPendingAsk(schedulerKey,\n        ResourceRequest.ANY);\n\n    if (offswitchPendingAsk.getCount() \u003c\u003d 0) {\n      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n          activitiesManager, node, application, priority,\n          ActivityDiagnosticConstant.PRIORITY_SKIPPED_BECAUSE_NULL_ANY_REQUEST);\n      return ContainerAllocation.PRIORITY_SKIPPED;\n    }\n\n    // Required resource\n    Resource required \u003d offswitchPendingAsk.getPerAllocationResource();\n\n    // Do we need containers at this \u0027priority\u0027?\n    if (application.getOutstandingAsksCount(schedulerKey) \u003c\u003d 0) {\n      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n          activitiesManager, node, application, priority,\n          ActivityDiagnosticConstant.APPLICATION_PRIORITY_DO_NOT_NEED_RESOURCE);\n      return ContainerAllocation.PRIORITY_SKIPPED;\n    }\n\n    // AM container allocation doesn\u0027t support non-exclusive allocation to\n    // avoid painful of preempt an AM container\n    if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n      if (application.isWaitingForAMContainer()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Skip allocating AM container to app_attempt\u003d\"\n              + application.getApplicationAttemptId()\n              + \", don\u0027t allow to allocate AM container in non-exclusive mode\");\n        }\n        application.updateAppSkipNodeDiagnostics(\n            \"Skipping assigning to Node in Ignore Exclusivity mode. \");\n        ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n            activitiesManager, node, application, priority,\n            ActivityDiagnosticConstant.SKIP_IN_IGNORE_EXCLUSIVITY_MODE);\n        return ContainerAllocation.APP_SKIPPED;\n      }\n    }\n\n    // Is the nodePartition of pending request matches the node\u0027s partition\n    // If not match, jump to next priority.\n    if (!appInfo.precheckNode(schedulerKey, node, schedulingMode)) {\n      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n          activitiesManager, node, application, priority,\n          ActivityDiagnosticConstant.\n              PRIORITY_SKIPPED_BECAUSE_NODE_PARTITION_DOES_NOT_MATCH_REQUEST);\n      return ContainerAllocation.PRIORITY_SKIPPED;\n    }\n\n    if (!application.getCSLeafQueue().getReservationContinueLooking()) {\n      if (!shouldAllocOrReserveNewContainer(schedulerKey, required)) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"doesn\u0027t need containers based on reservation algo!\");\n        }\n        ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n            activitiesManager, node, application, priority,\n            ActivityDiagnosticConstant.DO_NOT_NEED_ALLOCATIONATTEMPTINFOS);\n        return ContainerAllocation.PRIORITY_SKIPPED;\n      }\n    }\n\n    if (!checkHeadroom(clusterResource, resourceLimits, required,\n        node.getPartition())) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"cannot allocate required resource\u003d\" + required\n            + \" because of headroom\");\n      }\n      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n          activitiesManager, node, application, priority,\n          ActivityDiagnosticConstant.QUEUE_SKIPPED_HEADROOM);\n      return ContainerAllocation.QUEUE_SKIPPED;\n    }\n\n    // Increase missed-non-partitioned-resource-request-opportunity.\n    // This is to make sure non-partitioned-resource-request will prefer\n    // to be allocated to non-partitioned nodes\n    int missedNonPartitionedRequestSchedulingOpportunity \u003d 0;\n    AppPlacementAllocator appPlacementAllocator \u003d\n        appInfo.getAppPlacementAllocator(schedulerKey);\n    if (null \u003d\u003d appPlacementAllocator){\n      // This is possible when #pending resource decreased by a different\n      // thread.\n      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n          activitiesManager, node, application, priority,\n          ActivityDiagnosticConstant.PRIORITY_SKIPPED_BECAUSE_NULL_ANY_REQUEST);\n      return ContainerAllocation.PRIORITY_SKIPPED;\n    }\n    String requestPartition \u003d\n        appPlacementAllocator.getPrimaryRequestedNodePartition();\n\n    // Only do this when request associated with given scheduler key accepts\n    // NO_LABEL under RESPECT_EXCLUSIVITY mode\n    if (StringUtils.equals(RMNodeLabelsManager.NO_LABEL, requestPartition)) {\n      missedNonPartitionedRequestSchedulingOpportunity \u003d\n          application.addMissedNonPartitionedRequestSchedulingOpportunity(\n              schedulerKey);\n    }\n\n    if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n      // Before doing allocation, we need to check scheduling opportunity to\n      // make sure : non-partitioned resource request should be scheduled to\n      // non-partitioned partition first.\n      if (missedNonPartitionedRequestSchedulingOpportunity \u003c rmContext\n          .getScheduler().getNumClusterNodes()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Skip app_attempt\u003d\" + application.getApplicationAttemptId()\n              + \" priority\u003d\" + schedulerKey.getPriority()\n              + \" because missed-non-partitioned-resource-request\"\n              + \" opportunity under required:\" + \" Now\u003d\"\n              + missedNonPartitionedRequestSchedulingOpportunity + \" required\u003d\"\n              + rmContext.getScheduler().getNumClusterNodes());\n        }\n        ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n            activitiesManager, node, application, priority,\n            ActivityDiagnosticConstant.NON_PARTITIONED_PARTITION_FIRST);\n        return ContainerAllocation.APP_SKIPPED;\n      }\n    }\n\n    return null;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/allocator/RegularContainerAllocator.java",
          "extendedDetails": {
            "oldValue": "[clusterResource-Resource, candidates-CandidateNodeSet\u003cFiCaSchedulerNode\u003e, schedulingMode-SchedulingMode, resourceLimits-ResourceLimits, schedulerKey-SchedulerRequestKey]",
            "newValue": "[clusterResource-Resource, node-FiCaSchedulerNode, schedulingMode-SchedulingMode, resourceLimits-ResourceLimits, schedulerKey-SchedulerRequestKey]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-7494. Add muti-node lookup mechanism and pluggable nodes sorting policies to optimize placement decision. Contributed by Sunil Govindan.\n",
          "commitDate": "21/08/18 7:42 AM",
          "commitName": "9c3fc3ef2865164aa5f121793ac914cfeb21a181",
          "commitAuthor": "Weiwei Yang",
          "commitDateOld": "20/07/18 10:46 AM",
          "commitNameOld": "8a6bb8409c2dc695c0ffc70df0528d7f8bd5d795",
          "commitAuthorOld": "Haibo Chen",
          "daysBetweenCommits": 31.87,
          "commitsBetweenForRepo": 275,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,128 +1,127 @@\n   private ContainerAllocation preCheckForNodeCandidateSet(\n-      Resource clusterResource, CandidateNodeSet\u003cFiCaSchedulerNode\u003e candidates,\n+      Resource clusterResource, FiCaSchedulerNode node,\n       SchedulingMode schedulingMode, ResourceLimits resourceLimits,\n       SchedulerRequestKey schedulerKey) {\n     Priority priority \u003d schedulerKey.getPriority();\n-    FiCaSchedulerNode node \u003d CandidateNodeSetUtils.getSingleNode(candidates);\n \n     PendingAsk offswitchPendingAsk \u003d application.getPendingAsk(schedulerKey,\n         ResourceRequest.ANY);\n \n     if (offswitchPendingAsk.getCount() \u003c\u003d 0) {\n       ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n           activitiesManager, node, application, priority,\n           ActivityDiagnosticConstant.PRIORITY_SKIPPED_BECAUSE_NULL_ANY_REQUEST);\n       return ContainerAllocation.PRIORITY_SKIPPED;\n     }\n \n     // Required resource\n     Resource required \u003d offswitchPendingAsk.getPerAllocationResource();\n \n     // Do we need containers at this \u0027priority\u0027?\n     if (application.getOutstandingAsksCount(schedulerKey) \u003c\u003d 0) {\n       ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n           activitiesManager, node, application, priority,\n           ActivityDiagnosticConstant.APPLICATION_PRIORITY_DO_NOT_NEED_RESOURCE);\n       return ContainerAllocation.PRIORITY_SKIPPED;\n     }\n \n     // AM container allocation doesn\u0027t support non-exclusive allocation to\n     // avoid painful of preempt an AM container\n     if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n       if (application.isWaitingForAMContainer()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Skip allocating AM container to app_attempt\u003d\"\n               + application.getApplicationAttemptId()\n               + \", don\u0027t allow to allocate AM container in non-exclusive mode\");\n         }\n         application.updateAppSkipNodeDiagnostics(\n             \"Skipping assigning to Node in Ignore Exclusivity mode. \");\n         ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n             activitiesManager, node, application, priority,\n             ActivityDiagnosticConstant.SKIP_IN_IGNORE_EXCLUSIVITY_MODE);\n         return ContainerAllocation.APP_SKIPPED;\n       }\n     }\n \n     // Is the nodePartition of pending request matches the node\u0027s partition\n     // If not match, jump to next priority.\n     if (!appInfo.precheckNode(schedulerKey, node, schedulingMode)) {\n       ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n           activitiesManager, node, application, priority,\n           ActivityDiagnosticConstant.\n               PRIORITY_SKIPPED_BECAUSE_NODE_PARTITION_DOES_NOT_MATCH_REQUEST);\n       return ContainerAllocation.PRIORITY_SKIPPED;\n     }\n \n     if (!application.getCSLeafQueue().getReservationContinueLooking()) {\n       if (!shouldAllocOrReserveNewContainer(schedulerKey, required)) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"doesn\u0027t need containers based on reservation algo!\");\n         }\n         ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n             activitiesManager, node, application, priority,\n             ActivityDiagnosticConstant.DO_NOT_NEED_ALLOCATIONATTEMPTINFOS);\n         return ContainerAllocation.PRIORITY_SKIPPED;\n       }\n     }\n \n     if (!checkHeadroom(clusterResource, resourceLimits, required,\n-        candidates.getPartition())) {\n+        node.getPartition())) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"cannot allocate required resource\u003d\" + required\n             + \" because of headroom\");\n       }\n       ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n           activitiesManager, node, application, priority,\n           ActivityDiagnosticConstant.QUEUE_SKIPPED_HEADROOM);\n       return ContainerAllocation.QUEUE_SKIPPED;\n     }\n \n     // Increase missed-non-partitioned-resource-request-opportunity.\n     // This is to make sure non-partitioned-resource-request will prefer\n     // to be allocated to non-partitioned nodes\n     int missedNonPartitionedRequestSchedulingOpportunity \u003d 0;\n     AppPlacementAllocator appPlacementAllocator \u003d\n         appInfo.getAppPlacementAllocator(schedulerKey);\n     if (null \u003d\u003d appPlacementAllocator){\n       // This is possible when #pending resource decreased by a different\n       // thread.\n       ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n           activitiesManager, node, application, priority,\n           ActivityDiagnosticConstant.PRIORITY_SKIPPED_BECAUSE_NULL_ANY_REQUEST);\n       return ContainerAllocation.PRIORITY_SKIPPED;\n     }\n     String requestPartition \u003d\n         appPlacementAllocator.getPrimaryRequestedNodePartition();\n \n     // Only do this when request associated with given scheduler key accepts\n     // NO_LABEL under RESPECT_EXCLUSIVITY mode\n     if (StringUtils.equals(RMNodeLabelsManager.NO_LABEL, requestPartition)) {\n       missedNonPartitionedRequestSchedulingOpportunity \u003d\n           application.addMissedNonPartitionedRequestSchedulingOpportunity(\n               schedulerKey);\n     }\n \n     if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n       // Before doing allocation, we need to check scheduling opportunity to\n       // make sure : non-partitioned resource request should be scheduled to\n       // non-partitioned partition first.\n       if (missedNonPartitionedRequestSchedulingOpportunity \u003c rmContext\n           .getScheduler().getNumClusterNodes()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Skip app_attempt\u003d\" + application.getApplicationAttemptId()\n               + \" priority\u003d\" + schedulerKey.getPriority()\n               + \" because missed-non-partitioned-resource-request\"\n               + \" opportunity under required:\" + \" Now\u003d\"\n               + missedNonPartitionedRequestSchedulingOpportunity + \" required\u003d\"\n               + rmContext.getScheduler().getNumClusterNodes());\n         }\n         ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n             activitiesManager, node, application, priority,\n             ActivityDiagnosticConstant.NON_PARTITIONED_PARTITION_FIRST);\n         return ContainerAllocation.APP_SKIPPED;\n       }\n     }\n \n     return null;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private ContainerAllocation preCheckForNodeCandidateSet(\n      Resource clusterResource, FiCaSchedulerNode node,\n      SchedulingMode schedulingMode, ResourceLimits resourceLimits,\n      SchedulerRequestKey schedulerKey) {\n    Priority priority \u003d schedulerKey.getPriority();\n\n    PendingAsk offswitchPendingAsk \u003d application.getPendingAsk(schedulerKey,\n        ResourceRequest.ANY);\n\n    if (offswitchPendingAsk.getCount() \u003c\u003d 0) {\n      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n          activitiesManager, node, application, priority,\n          ActivityDiagnosticConstant.PRIORITY_SKIPPED_BECAUSE_NULL_ANY_REQUEST);\n      return ContainerAllocation.PRIORITY_SKIPPED;\n    }\n\n    // Required resource\n    Resource required \u003d offswitchPendingAsk.getPerAllocationResource();\n\n    // Do we need containers at this \u0027priority\u0027?\n    if (application.getOutstandingAsksCount(schedulerKey) \u003c\u003d 0) {\n      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n          activitiesManager, node, application, priority,\n          ActivityDiagnosticConstant.APPLICATION_PRIORITY_DO_NOT_NEED_RESOURCE);\n      return ContainerAllocation.PRIORITY_SKIPPED;\n    }\n\n    // AM container allocation doesn\u0027t support non-exclusive allocation to\n    // avoid painful of preempt an AM container\n    if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n      if (application.isWaitingForAMContainer()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Skip allocating AM container to app_attempt\u003d\"\n              + application.getApplicationAttemptId()\n              + \", don\u0027t allow to allocate AM container in non-exclusive mode\");\n        }\n        application.updateAppSkipNodeDiagnostics(\n            \"Skipping assigning to Node in Ignore Exclusivity mode. \");\n        ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n            activitiesManager, node, application, priority,\n            ActivityDiagnosticConstant.SKIP_IN_IGNORE_EXCLUSIVITY_MODE);\n        return ContainerAllocation.APP_SKIPPED;\n      }\n    }\n\n    // Is the nodePartition of pending request matches the node\u0027s partition\n    // If not match, jump to next priority.\n    if (!appInfo.precheckNode(schedulerKey, node, schedulingMode)) {\n      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n          activitiesManager, node, application, priority,\n          ActivityDiagnosticConstant.\n              PRIORITY_SKIPPED_BECAUSE_NODE_PARTITION_DOES_NOT_MATCH_REQUEST);\n      return ContainerAllocation.PRIORITY_SKIPPED;\n    }\n\n    if (!application.getCSLeafQueue().getReservationContinueLooking()) {\n      if (!shouldAllocOrReserveNewContainer(schedulerKey, required)) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"doesn\u0027t need containers based on reservation algo!\");\n        }\n        ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n            activitiesManager, node, application, priority,\n            ActivityDiagnosticConstant.DO_NOT_NEED_ALLOCATIONATTEMPTINFOS);\n        return ContainerAllocation.PRIORITY_SKIPPED;\n      }\n    }\n\n    if (!checkHeadroom(clusterResource, resourceLimits, required,\n        node.getPartition())) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"cannot allocate required resource\u003d\" + required\n            + \" because of headroom\");\n      }\n      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n          activitiesManager, node, application, priority,\n          ActivityDiagnosticConstant.QUEUE_SKIPPED_HEADROOM);\n      return ContainerAllocation.QUEUE_SKIPPED;\n    }\n\n    // Increase missed-non-partitioned-resource-request-opportunity.\n    // This is to make sure non-partitioned-resource-request will prefer\n    // to be allocated to non-partitioned nodes\n    int missedNonPartitionedRequestSchedulingOpportunity \u003d 0;\n    AppPlacementAllocator appPlacementAllocator \u003d\n        appInfo.getAppPlacementAllocator(schedulerKey);\n    if (null \u003d\u003d appPlacementAllocator){\n      // This is possible when #pending resource decreased by a different\n      // thread.\n      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n          activitiesManager, node, application, priority,\n          ActivityDiagnosticConstant.PRIORITY_SKIPPED_BECAUSE_NULL_ANY_REQUEST);\n      return ContainerAllocation.PRIORITY_SKIPPED;\n    }\n    String requestPartition \u003d\n        appPlacementAllocator.getPrimaryRequestedNodePartition();\n\n    // Only do this when request associated with given scheduler key accepts\n    // NO_LABEL under RESPECT_EXCLUSIVITY mode\n    if (StringUtils.equals(RMNodeLabelsManager.NO_LABEL, requestPartition)) {\n      missedNonPartitionedRequestSchedulingOpportunity \u003d\n          application.addMissedNonPartitionedRequestSchedulingOpportunity(\n              schedulerKey);\n    }\n\n    if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n      // Before doing allocation, we need to check scheduling opportunity to\n      // make sure : non-partitioned resource request should be scheduled to\n      // non-partitioned partition first.\n      if (missedNonPartitionedRequestSchedulingOpportunity \u003c rmContext\n          .getScheduler().getNumClusterNodes()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Skip app_attempt\u003d\" + application.getApplicationAttemptId()\n              + \" priority\u003d\" + schedulerKey.getPriority()\n              + \" because missed-non-partitioned-resource-request\"\n              + \" opportunity under required:\" + \" Now\u003d\"\n              + missedNonPartitionedRequestSchedulingOpportunity + \" required\u003d\"\n              + rmContext.getScheduler().getNumClusterNodes());\n        }\n        ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n            activitiesManager, node, application, priority,\n            ActivityDiagnosticConstant.NON_PARTITIONED_PARTITION_FIRST);\n        return ContainerAllocation.APP_SKIPPED;\n      }\n    }\n\n    return null;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/allocator/RegularContainerAllocator.java",
          "extendedDetails": {}
        }
      ]
    },
    "2a0fa50f9d718d51036ccdf30c7d998362fe423b": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8193. YARN RM hangs abruptly (stops allocating resources) when running successive applications. (Zian Chen via wangda)\n\nChange-Id: Ia83dd2499ee9000b9e09ae5a932f21a13c0ddee6\n",
      "commitDate": "26/04/18 1:54 PM",
      "commitName": "2a0fa50f9d718d51036ccdf30c7d998362fe423b",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "31/01/18 1:30 AM",
      "commitNameOld": "38af23796971193fa529c3d08ffde8fcd6e607b6",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 85.48,
      "commitsBetweenForRepo": 1196,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,117 +1,128 @@\n   private ContainerAllocation preCheckForNodeCandidateSet(\n       Resource clusterResource, CandidateNodeSet\u003cFiCaSchedulerNode\u003e candidates,\n       SchedulingMode schedulingMode, ResourceLimits resourceLimits,\n       SchedulerRequestKey schedulerKey) {\n     Priority priority \u003d schedulerKey.getPriority();\n     FiCaSchedulerNode node \u003d CandidateNodeSetUtils.getSingleNode(candidates);\n \n     PendingAsk offswitchPendingAsk \u003d application.getPendingAsk(schedulerKey,\n         ResourceRequest.ANY);\n \n     if (offswitchPendingAsk.getCount() \u003c\u003d 0) {\n       ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n           activitiesManager, node, application, priority,\n           ActivityDiagnosticConstant.PRIORITY_SKIPPED_BECAUSE_NULL_ANY_REQUEST);\n       return ContainerAllocation.PRIORITY_SKIPPED;\n     }\n \n     // Required resource\n     Resource required \u003d offswitchPendingAsk.getPerAllocationResource();\n \n     // Do we need containers at this \u0027priority\u0027?\n     if (application.getOutstandingAsksCount(schedulerKey) \u003c\u003d 0) {\n       ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n           activitiesManager, node, application, priority,\n           ActivityDiagnosticConstant.APPLICATION_PRIORITY_DO_NOT_NEED_RESOURCE);\n       return ContainerAllocation.PRIORITY_SKIPPED;\n     }\n \n     // AM container allocation doesn\u0027t support non-exclusive allocation to\n     // avoid painful of preempt an AM container\n     if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n       if (application.isWaitingForAMContainer()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Skip allocating AM container to app_attempt\u003d\"\n               + application.getApplicationAttemptId()\n               + \", don\u0027t allow to allocate AM container in non-exclusive mode\");\n         }\n         application.updateAppSkipNodeDiagnostics(\n             \"Skipping assigning to Node in Ignore Exclusivity mode. \");\n         ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n             activitiesManager, node, application, priority,\n             ActivityDiagnosticConstant.SKIP_IN_IGNORE_EXCLUSIVITY_MODE);\n         return ContainerAllocation.APP_SKIPPED;\n       }\n     }\n \n     // Is the nodePartition of pending request matches the node\u0027s partition\n     // If not match, jump to next priority.\n     if (!appInfo.precheckNode(schedulerKey, node, schedulingMode)) {\n       ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n           activitiesManager, node, application, priority,\n           ActivityDiagnosticConstant.\n               PRIORITY_SKIPPED_BECAUSE_NODE_PARTITION_DOES_NOT_MATCH_REQUEST);\n       return ContainerAllocation.PRIORITY_SKIPPED;\n     }\n \n     if (!application.getCSLeafQueue().getReservationContinueLooking()) {\n       if (!shouldAllocOrReserveNewContainer(schedulerKey, required)) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"doesn\u0027t need containers based on reservation algo!\");\n         }\n         ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n             activitiesManager, node, application, priority,\n             ActivityDiagnosticConstant.DO_NOT_NEED_ALLOCATIONATTEMPTINFOS);\n         return ContainerAllocation.PRIORITY_SKIPPED;\n       }\n     }\n \n     if (!checkHeadroom(clusterResource, resourceLimits, required,\n         candidates.getPartition())) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"cannot allocate required resource\u003d\" + required\n             + \" because of headroom\");\n       }\n       ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n           activitiesManager, node, application, priority,\n           ActivityDiagnosticConstant.QUEUE_SKIPPED_HEADROOM);\n       return ContainerAllocation.QUEUE_SKIPPED;\n     }\n \n     // Increase missed-non-partitioned-resource-request-opportunity.\n     // This is to make sure non-partitioned-resource-request will prefer\n     // to be allocated to non-partitioned nodes\n     int missedNonPartitionedRequestSchedulingOpportunity \u003d 0;\n+    AppPlacementAllocator appPlacementAllocator \u003d\n+        appInfo.getAppPlacementAllocator(schedulerKey);\n+    if (null \u003d\u003d appPlacementAllocator){\n+      // This is possible when #pending resource decreased by a different\n+      // thread.\n+      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n+          activitiesManager, node, application, priority,\n+          ActivityDiagnosticConstant.PRIORITY_SKIPPED_BECAUSE_NULL_ANY_REQUEST);\n+      return ContainerAllocation.PRIORITY_SKIPPED;\n+    }\n+    String requestPartition \u003d\n+        appPlacementAllocator.getPrimaryRequestedNodePartition();\n+\n     // Only do this when request associated with given scheduler key accepts\n     // NO_LABEL under RESPECT_EXCLUSIVITY mode\n-    if (StringUtils.equals(RMNodeLabelsManager.NO_LABEL,\n-        appInfo.getAppPlacementAllocator(schedulerKey)\n-            .getPrimaryRequestedNodePartition())) {\n+    if (StringUtils.equals(RMNodeLabelsManager.NO_LABEL, requestPartition)) {\n       missedNonPartitionedRequestSchedulingOpportunity \u003d\n           application.addMissedNonPartitionedRequestSchedulingOpportunity(\n               schedulerKey);\n     }\n \n     if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n       // Before doing allocation, we need to check scheduling opportunity to\n       // make sure : non-partitioned resource request should be scheduled to\n       // non-partitioned partition first.\n       if (missedNonPartitionedRequestSchedulingOpportunity \u003c rmContext\n           .getScheduler().getNumClusterNodes()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Skip app_attempt\u003d\" + application.getApplicationAttemptId()\n               + \" priority\u003d\" + schedulerKey.getPriority()\n               + \" because missed-non-partitioned-resource-request\"\n               + \" opportunity under required:\" + \" Now\u003d\"\n               + missedNonPartitionedRequestSchedulingOpportunity + \" required\u003d\"\n               + rmContext.getScheduler().getNumClusterNodes());\n         }\n         ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n             activitiesManager, node, application, priority,\n             ActivityDiagnosticConstant.NON_PARTITIONED_PARTITION_FIRST);\n         return ContainerAllocation.APP_SKIPPED;\n       }\n     }\n \n     return null;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private ContainerAllocation preCheckForNodeCandidateSet(\n      Resource clusterResource, CandidateNodeSet\u003cFiCaSchedulerNode\u003e candidates,\n      SchedulingMode schedulingMode, ResourceLimits resourceLimits,\n      SchedulerRequestKey schedulerKey) {\n    Priority priority \u003d schedulerKey.getPriority();\n    FiCaSchedulerNode node \u003d CandidateNodeSetUtils.getSingleNode(candidates);\n\n    PendingAsk offswitchPendingAsk \u003d application.getPendingAsk(schedulerKey,\n        ResourceRequest.ANY);\n\n    if (offswitchPendingAsk.getCount() \u003c\u003d 0) {\n      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n          activitiesManager, node, application, priority,\n          ActivityDiagnosticConstant.PRIORITY_SKIPPED_BECAUSE_NULL_ANY_REQUEST);\n      return ContainerAllocation.PRIORITY_SKIPPED;\n    }\n\n    // Required resource\n    Resource required \u003d offswitchPendingAsk.getPerAllocationResource();\n\n    // Do we need containers at this \u0027priority\u0027?\n    if (application.getOutstandingAsksCount(schedulerKey) \u003c\u003d 0) {\n      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n          activitiesManager, node, application, priority,\n          ActivityDiagnosticConstant.APPLICATION_PRIORITY_DO_NOT_NEED_RESOURCE);\n      return ContainerAllocation.PRIORITY_SKIPPED;\n    }\n\n    // AM container allocation doesn\u0027t support non-exclusive allocation to\n    // avoid painful of preempt an AM container\n    if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n      if (application.isWaitingForAMContainer()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Skip allocating AM container to app_attempt\u003d\"\n              + application.getApplicationAttemptId()\n              + \", don\u0027t allow to allocate AM container in non-exclusive mode\");\n        }\n        application.updateAppSkipNodeDiagnostics(\n            \"Skipping assigning to Node in Ignore Exclusivity mode. \");\n        ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n            activitiesManager, node, application, priority,\n            ActivityDiagnosticConstant.SKIP_IN_IGNORE_EXCLUSIVITY_MODE);\n        return ContainerAllocation.APP_SKIPPED;\n      }\n    }\n\n    // Is the nodePartition of pending request matches the node\u0027s partition\n    // If not match, jump to next priority.\n    if (!appInfo.precheckNode(schedulerKey, node, schedulingMode)) {\n      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n          activitiesManager, node, application, priority,\n          ActivityDiagnosticConstant.\n              PRIORITY_SKIPPED_BECAUSE_NODE_PARTITION_DOES_NOT_MATCH_REQUEST);\n      return ContainerAllocation.PRIORITY_SKIPPED;\n    }\n\n    if (!application.getCSLeafQueue().getReservationContinueLooking()) {\n      if (!shouldAllocOrReserveNewContainer(schedulerKey, required)) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"doesn\u0027t need containers based on reservation algo!\");\n        }\n        ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n            activitiesManager, node, application, priority,\n            ActivityDiagnosticConstant.DO_NOT_NEED_ALLOCATIONATTEMPTINFOS);\n        return ContainerAllocation.PRIORITY_SKIPPED;\n      }\n    }\n\n    if (!checkHeadroom(clusterResource, resourceLimits, required,\n        candidates.getPartition())) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"cannot allocate required resource\u003d\" + required\n            + \" because of headroom\");\n      }\n      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n          activitiesManager, node, application, priority,\n          ActivityDiagnosticConstant.QUEUE_SKIPPED_HEADROOM);\n      return ContainerAllocation.QUEUE_SKIPPED;\n    }\n\n    // Increase missed-non-partitioned-resource-request-opportunity.\n    // This is to make sure non-partitioned-resource-request will prefer\n    // to be allocated to non-partitioned nodes\n    int missedNonPartitionedRequestSchedulingOpportunity \u003d 0;\n    AppPlacementAllocator appPlacementAllocator \u003d\n        appInfo.getAppPlacementAllocator(schedulerKey);\n    if (null \u003d\u003d appPlacementAllocator){\n      // This is possible when #pending resource decreased by a different\n      // thread.\n      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n          activitiesManager, node, application, priority,\n          ActivityDiagnosticConstant.PRIORITY_SKIPPED_BECAUSE_NULL_ANY_REQUEST);\n      return ContainerAllocation.PRIORITY_SKIPPED;\n    }\n    String requestPartition \u003d\n        appPlacementAllocator.getPrimaryRequestedNodePartition();\n\n    // Only do this when request associated with given scheduler key accepts\n    // NO_LABEL under RESPECT_EXCLUSIVITY mode\n    if (StringUtils.equals(RMNodeLabelsManager.NO_LABEL, requestPartition)) {\n      missedNonPartitionedRequestSchedulingOpportunity \u003d\n          application.addMissedNonPartitionedRequestSchedulingOpportunity(\n              schedulerKey);\n    }\n\n    if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n      // Before doing allocation, we need to check scheduling opportunity to\n      // make sure : non-partitioned resource request should be scheduled to\n      // non-partitioned partition first.\n      if (missedNonPartitionedRequestSchedulingOpportunity \u003c rmContext\n          .getScheduler().getNumClusterNodes()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Skip app_attempt\u003d\" + application.getApplicationAttemptId()\n              + \" priority\u003d\" + schedulerKey.getPriority()\n              + \" because missed-non-partitioned-resource-request\"\n              + \" opportunity under required:\" + \" Now\u003d\"\n              + missedNonPartitionedRequestSchedulingOpportunity + \" required\u003d\"\n              + rmContext.getScheduler().getNumClusterNodes());\n        }\n        ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n            activitiesManager, node, application, priority,\n            ActivityDiagnosticConstant.NON_PARTITIONED_PARTITION_FIRST);\n        return ContainerAllocation.APP_SKIPPED;\n      }\n    }\n\n    return null;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/allocator/RegularContainerAllocator.java",
      "extendedDetails": {}
    },
    "38af23796971193fa529c3d08ffde8fcd6e607b6": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6599. Support anti-affinity constraint via AppPlacementAllocator. (Wangda Tan via asuresh)\n",
      "commitDate": "31/01/18 1:30 AM",
      "commitName": "38af23796971193fa529c3d08ffde8fcd6e607b6",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "05/12/17 9:20 AM",
      "commitNameOld": "a957f1c60e1308d1d70a1803381994f59949c5f8",
      "commitAuthorOld": "Sunil G",
      "daysBetweenCommits": 56.67,
      "commitsBetweenForRepo": 333,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,118 +1,117 @@\n   private ContainerAllocation preCheckForNodeCandidateSet(\n       Resource clusterResource, CandidateNodeSet\u003cFiCaSchedulerNode\u003e candidates,\n       SchedulingMode schedulingMode, ResourceLimits resourceLimits,\n       SchedulerRequestKey schedulerKey) {\n     Priority priority \u003d schedulerKey.getPriority();\n     FiCaSchedulerNode node \u003d CandidateNodeSetUtils.getSingleNode(candidates);\n \n     PendingAsk offswitchPendingAsk \u003d application.getPendingAsk(schedulerKey,\n         ResourceRequest.ANY);\n \n     if (offswitchPendingAsk.getCount() \u003c\u003d 0) {\n       ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n           activitiesManager, node, application, priority,\n           ActivityDiagnosticConstant.PRIORITY_SKIPPED_BECAUSE_NULL_ANY_REQUEST);\n       return ContainerAllocation.PRIORITY_SKIPPED;\n     }\n \n     // Required resource\n     Resource required \u003d offswitchPendingAsk.getPerAllocationResource();\n \n     // Do we need containers at this \u0027priority\u0027?\n     if (application.getOutstandingAsksCount(schedulerKey) \u003c\u003d 0) {\n       ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n           activitiesManager, node, application, priority,\n           ActivityDiagnosticConstant.APPLICATION_PRIORITY_DO_NOT_NEED_RESOURCE);\n       return ContainerAllocation.PRIORITY_SKIPPED;\n     }\n \n     // AM container allocation doesn\u0027t support non-exclusive allocation to\n     // avoid painful of preempt an AM container\n     if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n       if (application.isWaitingForAMContainer()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Skip allocating AM container to app_attempt\u003d\"\n               + application.getApplicationAttemptId()\n               + \", don\u0027t allow to allocate AM container in non-exclusive mode\");\n         }\n         application.updateAppSkipNodeDiagnostics(\n             \"Skipping assigning to Node in Ignore Exclusivity mode. \");\n         ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n             activitiesManager, node, application, priority,\n             ActivityDiagnosticConstant.SKIP_IN_IGNORE_EXCLUSIVITY_MODE);\n         return ContainerAllocation.APP_SKIPPED;\n       }\n     }\n \n     // Is the nodePartition of pending request matches the node\u0027s partition\n     // If not match, jump to next priority.\n-    if (!appInfo.acceptNodePartition(schedulerKey, node.getPartition(),\n-        schedulingMode)) {\n+    if (!appInfo.precheckNode(schedulerKey, node, schedulingMode)) {\n       ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n           activitiesManager, node, application, priority,\n           ActivityDiagnosticConstant.\n               PRIORITY_SKIPPED_BECAUSE_NODE_PARTITION_DOES_NOT_MATCH_REQUEST);\n       return ContainerAllocation.PRIORITY_SKIPPED;\n     }\n \n     if (!application.getCSLeafQueue().getReservationContinueLooking()) {\n       if (!shouldAllocOrReserveNewContainer(schedulerKey, required)) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"doesn\u0027t need containers based on reservation algo!\");\n         }\n         ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n             activitiesManager, node, application, priority,\n             ActivityDiagnosticConstant.DO_NOT_NEED_ALLOCATIONATTEMPTINFOS);\n         return ContainerAllocation.PRIORITY_SKIPPED;\n       }\n     }\n \n     if (!checkHeadroom(clusterResource, resourceLimits, required,\n         candidates.getPartition())) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"cannot allocate required resource\u003d\" + required\n             + \" because of headroom\");\n       }\n       ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n           activitiesManager, node, application, priority,\n           ActivityDiagnosticConstant.QUEUE_SKIPPED_HEADROOM);\n       return ContainerAllocation.QUEUE_SKIPPED;\n     }\n \n     // Increase missed-non-partitioned-resource-request-opportunity.\n     // This is to make sure non-partitioned-resource-request will prefer\n     // to be allocated to non-partitioned nodes\n     int missedNonPartitionedRequestSchedulingOpportunity \u003d 0;\n     // Only do this when request associated with given scheduler key accepts\n     // NO_LABEL under RESPECT_EXCLUSIVITY mode\n     if (StringUtils.equals(RMNodeLabelsManager.NO_LABEL,\n         appInfo.getAppPlacementAllocator(schedulerKey)\n             .getPrimaryRequestedNodePartition())) {\n       missedNonPartitionedRequestSchedulingOpportunity \u003d\n           application.addMissedNonPartitionedRequestSchedulingOpportunity(\n               schedulerKey);\n     }\n \n     if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n       // Before doing allocation, we need to check scheduling opportunity to\n       // make sure : non-partitioned resource request should be scheduled to\n       // non-partitioned partition first.\n       if (missedNonPartitionedRequestSchedulingOpportunity \u003c rmContext\n           .getScheduler().getNumClusterNodes()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Skip app_attempt\u003d\" + application.getApplicationAttemptId()\n               + \" priority\u003d\" + schedulerKey.getPriority()\n               + \" because missed-non-partitioned-resource-request\"\n               + \" opportunity under required:\" + \" Now\u003d\"\n               + missedNonPartitionedRequestSchedulingOpportunity + \" required\u003d\"\n               + rmContext.getScheduler().getNumClusterNodes());\n         }\n         ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n             activitiesManager, node, application, priority,\n             ActivityDiagnosticConstant.NON_PARTITIONED_PARTITION_FIRST);\n         return ContainerAllocation.APP_SKIPPED;\n       }\n     }\n \n     return null;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private ContainerAllocation preCheckForNodeCandidateSet(\n      Resource clusterResource, CandidateNodeSet\u003cFiCaSchedulerNode\u003e candidates,\n      SchedulingMode schedulingMode, ResourceLimits resourceLimits,\n      SchedulerRequestKey schedulerKey) {\n    Priority priority \u003d schedulerKey.getPriority();\n    FiCaSchedulerNode node \u003d CandidateNodeSetUtils.getSingleNode(candidates);\n\n    PendingAsk offswitchPendingAsk \u003d application.getPendingAsk(schedulerKey,\n        ResourceRequest.ANY);\n\n    if (offswitchPendingAsk.getCount() \u003c\u003d 0) {\n      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n          activitiesManager, node, application, priority,\n          ActivityDiagnosticConstant.PRIORITY_SKIPPED_BECAUSE_NULL_ANY_REQUEST);\n      return ContainerAllocation.PRIORITY_SKIPPED;\n    }\n\n    // Required resource\n    Resource required \u003d offswitchPendingAsk.getPerAllocationResource();\n\n    // Do we need containers at this \u0027priority\u0027?\n    if (application.getOutstandingAsksCount(schedulerKey) \u003c\u003d 0) {\n      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n          activitiesManager, node, application, priority,\n          ActivityDiagnosticConstant.APPLICATION_PRIORITY_DO_NOT_NEED_RESOURCE);\n      return ContainerAllocation.PRIORITY_SKIPPED;\n    }\n\n    // AM container allocation doesn\u0027t support non-exclusive allocation to\n    // avoid painful of preempt an AM container\n    if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n      if (application.isWaitingForAMContainer()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Skip allocating AM container to app_attempt\u003d\"\n              + application.getApplicationAttemptId()\n              + \", don\u0027t allow to allocate AM container in non-exclusive mode\");\n        }\n        application.updateAppSkipNodeDiagnostics(\n            \"Skipping assigning to Node in Ignore Exclusivity mode. \");\n        ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n            activitiesManager, node, application, priority,\n            ActivityDiagnosticConstant.SKIP_IN_IGNORE_EXCLUSIVITY_MODE);\n        return ContainerAllocation.APP_SKIPPED;\n      }\n    }\n\n    // Is the nodePartition of pending request matches the node\u0027s partition\n    // If not match, jump to next priority.\n    if (!appInfo.precheckNode(schedulerKey, node, schedulingMode)) {\n      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n          activitiesManager, node, application, priority,\n          ActivityDiagnosticConstant.\n              PRIORITY_SKIPPED_BECAUSE_NODE_PARTITION_DOES_NOT_MATCH_REQUEST);\n      return ContainerAllocation.PRIORITY_SKIPPED;\n    }\n\n    if (!application.getCSLeafQueue().getReservationContinueLooking()) {\n      if (!shouldAllocOrReserveNewContainer(schedulerKey, required)) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"doesn\u0027t need containers based on reservation algo!\");\n        }\n        ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n            activitiesManager, node, application, priority,\n            ActivityDiagnosticConstant.DO_NOT_NEED_ALLOCATIONATTEMPTINFOS);\n        return ContainerAllocation.PRIORITY_SKIPPED;\n      }\n    }\n\n    if (!checkHeadroom(clusterResource, resourceLimits, required,\n        candidates.getPartition())) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"cannot allocate required resource\u003d\" + required\n            + \" because of headroom\");\n      }\n      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n          activitiesManager, node, application, priority,\n          ActivityDiagnosticConstant.QUEUE_SKIPPED_HEADROOM);\n      return ContainerAllocation.QUEUE_SKIPPED;\n    }\n\n    // Increase missed-non-partitioned-resource-request-opportunity.\n    // This is to make sure non-partitioned-resource-request will prefer\n    // to be allocated to non-partitioned nodes\n    int missedNonPartitionedRequestSchedulingOpportunity \u003d 0;\n    // Only do this when request associated with given scheduler key accepts\n    // NO_LABEL under RESPECT_EXCLUSIVITY mode\n    if (StringUtils.equals(RMNodeLabelsManager.NO_LABEL,\n        appInfo.getAppPlacementAllocator(schedulerKey)\n            .getPrimaryRequestedNodePartition())) {\n      missedNonPartitionedRequestSchedulingOpportunity \u003d\n          application.addMissedNonPartitionedRequestSchedulingOpportunity(\n              schedulerKey);\n    }\n\n    if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n      // Before doing allocation, we need to check scheduling opportunity to\n      // make sure : non-partitioned resource request should be scheduled to\n      // non-partitioned partition first.\n      if (missedNonPartitionedRequestSchedulingOpportunity \u003c rmContext\n          .getScheduler().getNumClusterNodes()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Skip app_attempt\u003d\" + application.getApplicationAttemptId()\n              + \" priority\u003d\" + schedulerKey.getPriority()\n              + \" because missed-non-partitioned-resource-request\"\n              + \" opportunity under required:\" + \" Now\u003d\"\n              + missedNonPartitionedRequestSchedulingOpportunity + \" required\u003d\"\n              + rmContext.getScheduler().getNumClusterNodes());\n        }\n        ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n            activitiesManager, node, application, priority,\n            ActivityDiagnosticConstant.NON_PARTITIONED_PARTITION_FIRST);\n        return ContainerAllocation.APP_SKIPPED;\n      }\n    }\n\n    return null;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/allocator/RegularContainerAllocator.java",
      "extendedDetails": {}
    },
    "ac4d2b1081d8836a21bc70e77f4e6cd2071a9949": {
      "type": "Ymultichange(Yrename,Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-7437. Rename PlacementSet and SchedulingPlacementSet. (Wangda Tan via kkaranasos)\n",
      "commitDate": "09/11/17 1:01 PM",
      "commitName": "ac4d2b1081d8836a21bc70e77f4e6cd2071a9949",
      "commitAuthor": "Konstantinos Karanasos",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "YARN-7437. Rename PlacementSet and SchedulingPlacementSet. (Wangda Tan via kkaranasos)\n",
          "commitDate": "09/11/17 1:01 PM",
          "commitName": "ac4d2b1081d8836a21bc70e77f4e6cd2071a9949",
          "commitAuthor": "Konstantinos Karanasos",
          "commitDateOld": "17/09/17 9:20 PM",
          "commitNameOld": "e81596d06d226f1cfa44b2390ce3095ed4dee621",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 52.69,
          "commitsBetweenForRepo": 485,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,117 +1,118 @@\n-  private ContainerAllocation preCheckForPlacementSet(Resource clusterResource,\n-      PlacementSet\u003cFiCaSchedulerNode\u003e ps, SchedulingMode schedulingMode,\n-      ResourceLimits resourceLimits, SchedulerRequestKey schedulerKey) {\n+  private ContainerAllocation preCheckForNodeCandidateSet(\n+      Resource clusterResource, CandidateNodeSet\u003cFiCaSchedulerNode\u003e candidates,\n+      SchedulingMode schedulingMode, ResourceLimits resourceLimits,\n+      SchedulerRequestKey schedulerKey) {\n     Priority priority \u003d schedulerKey.getPriority();\n-    FiCaSchedulerNode node \u003d PlacementSetUtils.getSingleNode(ps);\n+    FiCaSchedulerNode node \u003d CandidateNodeSetUtils.getSingleNode(candidates);\n \n     PendingAsk offswitchPendingAsk \u003d application.getPendingAsk(schedulerKey,\n         ResourceRequest.ANY);\n \n     if (offswitchPendingAsk.getCount() \u003c\u003d 0) {\n       ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n           activitiesManager, node, application, priority,\n           ActivityDiagnosticConstant.PRIORITY_SKIPPED_BECAUSE_NULL_ANY_REQUEST);\n       return ContainerAllocation.PRIORITY_SKIPPED;\n     }\n \n     // Required resource\n     Resource required \u003d offswitchPendingAsk.getPerAllocationResource();\n \n     // Do we need containers at this \u0027priority\u0027?\n     if (application.getOutstandingAsksCount(schedulerKey) \u003c\u003d 0) {\n       ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n           activitiesManager, node, application, priority,\n           ActivityDiagnosticConstant.APPLICATION_PRIORITY_DO_NOT_NEED_RESOURCE);\n       return ContainerAllocation.PRIORITY_SKIPPED;\n     }\n \n     // AM container allocation doesn\u0027t support non-exclusive allocation to\n     // avoid painful of preempt an AM container\n     if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n       if (application.isWaitingForAMContainer()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Skip allocating AM container to app_attempt\u003d\"\n               + application.getApplicationAttemptId()\n               + \", don\u0027t allow to allocate AM container in non-exclusive mode\");\n         }\n         application.updateAppSkipNodeDiagnostics(\n             \"Skipping assigning to Node in Ignore Exclusivity mode. \");\n         ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n             activitiesManager, node, application, priority,\n             ActivityDiagnosticConstant.SKIP_IN_IGNORE_EXCLUSIVITY_MODE);\n         return ContainerAllocation.APP_SKIPPED;\n       }\n     }\n \n     // Is the nodePartition of pending request matches the node\u0027s partition\n     // If not match, jump to next priority.\n     if (!appInfo.acceptNodePartition(schedulerKey, node.getPartition(),\n         schedulingMode)) {\n       ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n           activitiesManager, node, application, priority,\n           ActivityDiagnosticConstant.\n               PRIORITY_SKIPPED_BECAUSE_NODE_PARTITION_DOES_NOT_MATCH_REQUEST);\n       return ContainerAllocation.PRIORITY_SKIPPED;\n     }\n \n     if (!application.getCSLeafQueue().getReservationContinueLooking()) {\n       if (!shouldAllocOrReserveNewContainer(schedulerKey, required)) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"doesn\u0027t need containers based on reservation algo!\");\n         }\n         ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n             activitiesManager, node, application, priority,\n             ActivityDiagnosticConstant.DO_NOT_NEED_ALLOCATIONATTEMPTINFOS);\n         return ContainerAllocation.PRIORITY_SKIPPED;\n       }\n     }\n \n     if (!checkHeadroom(clusterResource, resourceLimits, required,\n-        ps.getPartition())) {\n+        candidates.getPartition())) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"cannot allocate required resource\u003d\" + required\n             + \" because of headroom\");\n       }\n       ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n           activitiesManager, node, application, priority,\n           ActivityDiagnosticConstant.QUEUE_SKIPPED_HEADROOM);\n       return ContainerAllocation.QUEUE_SKIPPED;\n     }\n \n     // Increase missed-non-partitioned-resource-request-opportunity.\n     // This is to make sure non-partitioned-resource-request will prefer\n     // to be allocated to non-partitioned nodes\n     int missedNonPartitionedRequestSchedulingOpportunity \u003d 0;\n     // Only do this when request associated with given scheduler key accepts\n     // NO_LABEL under RESPECT_EXCLUSIVITY mode\n     if (StringUtils.equals(RMNodeLabelsManager.NO_LABEL,\n-        appInfo.getSchedulingPlacementSet(schedulerKey)\n+        appInfo.getAppPlacementAllocator(schedulerKey)\n             .getPrimaryRequestedNodePartition())) {\n       missedNonPartitionedRequestSchedulingOpportunity \u003d\n           application.addMissedNonPartitionedRequestSchedulingOpportunity(\n               schedulerKey);\n     }\n \n     if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n       // Before doing allocation, we need to check scheduling opportunity to\n       // make sure : non-partitioned resource request should be scheduled to\n       // non-partitioned partition first.\n       if (missedNonPartitionedRequestSchedulingOpportunity \u003c rmContext\n           .getScheduler().getNumClusterNodes()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Skip app_attempt\u003d\" + application.getApplicationAttemptId()\n               + \" priority\u003d\" + schedulerKey.getPriority()\n               + \" because missed-non-partitioned-resource-request\"\n               + \" opportunity under required:\" + \" Now\u003d\"\n               + missedNonPartitionedRequestSchedulingOpportunity + \" required\u003d\"\n               + rmContext.getScheduler().getNumClusterNodes());\n         }\n         ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n             activitiesManager, node, application, priority,\n             ActivityDiagnosticConstant.NON_PARTITIONED_PARTITION_FIRST);\n         return ContainerAllocation.APP_SKIPPED;\n       }\n     }\n \n     return null;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private ContainerAllocation preCheckForNodeCandidateSet(\n      Resource clusterResource, CandidateNodeSet\u003cFiCaSchedulerNode\u003e candidates,\n      SchedulingMode schedulingMode, ResourceLimits resourceLimits,\n      SchedulerRequestKey schedulerKey) {\n    Priority priority \u003d schedulerKey.getPriority();\n    FiCaSchedulerNode node \u003d CandidateNodeSetUtils.getSingleNode(candidates);\n\n    PendingAsk offswitchPendingAsk \u003d application.getPendingAsk(schedulerKey,\n        ResourceRequest.ANY);\n\n    if (offswitchPendingAsk.getCount() \u003c\u003d 0) {\n      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n          activitiesManager, node, application, priority,\n          ActivityDiagnosticConstant.PRIORITY_SKIPPED_BECAUSE_NULL_ANY_REQUEST);\n      return ContainerAllocation.PRIORITY_SKIPPED;\n    }\n\n    // Required resource\n    Resource required \u003d offswitchPendingAsk.getPerAllocationResource();\n\n    // Do we need containers at this \u0027priority\u0027?\n    if (application.getOutstandingAsksCount(schedulerKey) \u003c\u003d 0) {\n      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n          activitiesManager, node, application, priority,\n          ActivityDiagnosticConstant.APPLICATION_PRIORITY_DO_NOT_NEED_RESOURCE);\n      return ContainerAllocation.PRIORITY_SKIPPED;\n    }\n\n    // AM container allocation doesn\u0027t support non-exclusive allocation to\n    // avoid painful of preempt an AM container\n    if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n      if (application.isWaitingForAMContainer()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Skip allocating AM container to app_attempt\u003d\"\n              + application.getApplicationAttemptId()\n              + \", don\u0027t allow to allocate AM container in non-exclusive mode\");\n        }\n        application.updateAppSkipNodeDiagnostics(\n            \"Skipping assigning to Node in Ignore Exclusivity mode. \");\n        ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n            activitiesManager, node, application, priority,\n            ActivityDiagnosticConstant.SKIP_IN_IGNORE_EXCLUSIVITY_MODE);\n        return ContainerAllocation.APP_SKIPPED;\n      }\n    }\n\n    // Is the nodePartition of pending request matches the node\u0027s partition\n    // If not match, jump to next priority.\n    if (!appInfo.acceptNodePartition(schedulerKey, node.getPartition(),\n        schedulingMode)) {\n      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n          activitiesManager, node, application, priority,\n          ActivityDiagnosticConstant.\n              PRIORITY_SKIPPED_BECAUSE_NODE_PARTITION_DOES_NOT_MATCH_REQUEST);\n      return ContainerAllocation.PRIORITY_SKIPPED;\n    }\n\n    if (!application.getCSLeafQueue().getReservationContinueLooking()) {\n      if (!shouldAllocOrReserveNewContainer(schedulerKey, required)) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"doesn\u0027t need containers based on reservation algo!\");\n        }\n        ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n            activitiesManager, node, application, priority,\n            ActivityDiagnosticConstant.DO_NOT_NEED_ALLOCATIONATTEMPTINFOS);\n        return ContainerAllocation.PRIORITY_SKIPPED;\n      }\n    }\n\n    if (!checkHeadroom(clusterResource, resourceLimits, required,\n        candidates.getPartition())) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"cannot allocate required resource\u003d\" + required\n            + \" because of headroom\");\n      }\n      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n          activitiesManager, node, application, priority,\n          ActivityDiagnosticConstant.QUEUE_SKIPPED_HEADROOM);\n      return ContainerAllocation.QUEUE_SKIPPED;\n    }\n\n    // Increase missed-non-partitioned-resource-request-opportunity.\n    // This is to make sure non-partitioned-resource-request will prefer\n    // to be allocated to non-partitioned nodes\n    int missedNonPartitionedRequestSchedulingOpportunity \u003d 0;\n    // Only do this when request associated with given scheduler key accepts\n    // NO_LABEL under RESPECT_EXCLUSIVITY mode\n    if (StringUtils.equals(RMNodeLabelsManager.NO_LABEL,\n        appInfo.getAppPlacementAllocator(schedulerKey)\n            .getPrimaryRequestedNodePartition())) {\n      missedNonPartitionedRequestSchedulingOpportunity \u003d\n          application.addMissedNonPartitionedRequestSchedulingOpportunity(\n              schedulerKey);\n    }\n\n    if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n      // Before doing allocation, we need to check scheduling opportunity to\n      // make sure : non-partitioned resource request should be scheduled to\n      // non-partitioned partition first.\n      if (missedNonPartitionedRequestSchedulingOpportunity \u003c rmContext\n          .getScheduler().getNumClusterNodes()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Skip app_attempt\u003d\" + application.getApplicationAttemptId()\n              + \" priority\u003d\" + schedulerKey.getPriority()\n              + \" because missed-non-partitioned-resource-request\"\n              + \" opportunity under required:\" + \" Now\u003d\"\n              + missedNonPartitionedRequestSchedulingOpportunity + \" required\u003d\"\n              + rmContext.getScheduler().getNumClusterNodes());\n        }\n        ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n            activitiesManager, node, application, priority,\n            ActivityDiagnosticConstant.NON_PARTITIONED_PARTITION_FIRST);\n        return ContainerAllocation.APP_SKIPPED;\n      }\n    }\n\n    return null;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/allocator/RegularContainerAllocator.java",
          "extendedDetails": {
            "oldValue": "preCheckForPlacementSet",
            "newValue": "preCheckForNodeCandidateSet"
          }
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-7437. Rename PlacementSet and SchedulingPlacementSet. (Wangda Tan via kkaranasos)\n",
          "commitDate": "09/11/17 1:01 PM",
          "commitName": "ac4d2b1081d8836a21bc70e77f4e6cd2071a9949",
          "commitAuthor": "Konstantinos Karanasos",
          "commitDateOld": "17/09/17 9:20 PM",
          "commitNameOld": "e81596d06d226f1cfa44b2390ce3095ed4dee621",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 52.69,
          "commitsBetweenForRepo": 485,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,117 +1,118 @@\n-  private ContainerAllocation preCheckForPlacementSet(Resource clusterResource,\n-      PlacementSet\u003cFiCaSchedulerNode\u003e ps, SchedulingMode schedulingMode,\n-      ResourceLimits resourceLimits, SchedulerRequestKey schedulerKey) {\n+  private ContainerAllocation preCheckForNodeCandidateSet(\n+      Resource clusterResource, CandidateNodeSet\u003cFiCaSchedulerNode\u003e candidates,\n+      SchedulingMode schedulingMode, ResourceLimits resourceLimits,\n+      SchedulerRequestKey schedulerKey) {\n     Priority priority \u003d schedulerKey.getPriority();\n-    FiCaSchedulerNode node \u003d PlacementSetUtils.getSingleNode(ps);\n+    FiCaSchedulerNode node \u003d CandidateNodeSetUtils.getSingleNode(candidates);\n \n     PendingAsk offswitchPendingAsk \u003d application.getPendingAsk(schedulerKey,\n         ResourceRequest.ANY);\n \n     if (offswitchPendingAsk.getCount() \u003c\u003d 0) {\n       ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n           activitiesManager, node, application, priority,\n           ActivityDiagnosticConstant.PRIORITY_SKIPPED_BECAUSE_NULL_ANY_REQUEST);\n       return ContainerAllocation.PRIORITY_SKIPPED;\n     }\n \n     // Required resource\n     Resource required \u003d offswitchPendingAsk.getPerAllocationResource();\n \n     // Do we need containers at this \u0027priority\u0027?\n     if (application.getOutstandingAsksCount(schedulerKey) \u003c\u003d 0) {\n       ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n           activitiesManager, node, application, priority,\n           ActivityDiagnosticConstant.APPLICATION_PRIORITY_DO_NOT_NEED_RESOURCE);\n       return ContainerAllocation.PRIORITY_SKIPPED;\n     }\n \n     // AM container allocation doesn\u0027t support non-exclusive allocation to\n     // avoid painful of preempt an AM container\n     if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n       if (application.isWaitingForAMContainer()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Skip allocating AM container to app_attempt\u003d\"\n               + application.getApplicationAttemptId()\n               + \", don\u0027t allow to allocate AM container in non-exclusive mode\");\n         }\n         application.updateAppSkipNodeDiagnostics(\n             \"Skipping assigning to Node in Ignore Exclusivity mode. \");\n         ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n             activitiesManager, node, application, priority,\n             ActivityDiagnosticConstant.SKIP_IN_IGNORE_EXCLUSIVITY_MODE);\n         return ContainerAllocation.APP_SKIPPED;\n       }\n     }\n \n     // Is the nodePartition of pending request matches the node\u0027s partition\n     // If not match, jump to next priority.\n     if (!appInfo.acceptNodePartition(schedulerKey, node.getPartition(),\n         schedulingMode)) {\n       ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n           activitiesManager, node, application, priority,\n           ActivityDiagnosticConstant.\n               PRIORITY_SKIPPED_BECAUSE_NODE_PARTITION_DOES_NOT_MATCH_REQUEST);\n       return ContainerAllocation.PRIORITY_SKIPPED;\n     }\n \n     if (!application.getCSLeafQueue().getReservationContinueLooking()) {\n       if (!shouldAllocOrReserveNewContainer(schedulerKey, required)) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"doesn\u0027t need containers based on reservation algo!\");\n         }\n         ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n             activitiesManager, node, application, priority,\n             ActivityDiagnosticConstant.DO_NOT_NEED_ALLOCATIONATTEMPTINFOS);\n         return ContainerAllocation.PRIORITY_SKIPPED;\n       }\n     }\n \n     if (!checkHeadroom(clusterResource, resourceLimits, required,\n-        ps.getPartition())) {\n+        candidates.getPartition())) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"cannot allocate required resource\u003d\" + required\n             + \" because of headroom\");\n       }\n       ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n           activitiesManager, node, application, priority,\n           ActivityDiagnosticConstant.QUEUE_SKIPPED_HEADROOM);\n       return ContainerAllocation.QUEUE_SKIPPED;\n     }\n \n     // Increase missed-non-partitioned-resource-request-opportunity.\n     // This is to make sure non-partitioned-resource-request will prefer\n     // to be allocated to non-partitioned nodes\n     int missedNonPartitionedRequestSchedulingOpportunity \u003d 0;\n     // Only do this when request associated with given scheduler key accepts\n     // NO_LABEL under RESPECT_EXCLUSIVITY mode\n     if (StringUtils.equals(RMNodeLabelsManager.NO_LABEL,\n-        appInfo.getSchedulingPlacementSet(schedulerKey)\n+        appInfo.getAppPlacementAllocator(schedulerKey)\n             .getPrimaryRequestedNodePartition())) {\n       missedNonPartitionedRequestSchedulingOpportunity \u003d\n           application.addMissedNonPartitionedRequestSchedulingOpportunity(\n               schedulerKey);\n     }\n \n     if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n       // Before doing allocation, we need to check scheduling opportunity to\n       // make sure : non-partitioned resource request should be scheduled to\n       // non-partitioned partition first.\n       if (missedNonPartitionedRequestSchedulingOpportunity \u003c rmContext\n           .getScheduler().getNumClusterNodes()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Skip app_attempt\u003d\" + application.getApplicationAttemptId()\n               + \" priority\u003d\" + schedulerKey.getPriority()\n               + \" because missed-non-partitioned-resource-request\"\n               + \" opportunity under required:\" + \" Now\u003d\"\n               + missedNonPartitionedRequestSchedulingOpportunity + \" required\u003d\"\n               + rmContext.getScheduler().getNumClusterNodes());\n         }\n         ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n             activitiesManager, node, application, priority,\n             ActivityDiagnosticConstant.NON_PARTITIONED_PARTITION_FIRST);\n         return ContainerAllocation.APP_SKIPPED;\n       }\n     }\n \n     return null;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private ContainerAllocation preCheckForNodeCandidateSet(\n      Resource clusterResource, CandidateNodeSet\u003cFiCaSchedulerNode\u003e candidates,\n      SchedulingMode schedulingMode, ResourceLimits resourceLimits,\n      SchedulerRequestKey schedulerKey) {\n    Priority priority \u003d schedulerKey.getPriority();\n    FiCaSchedulerNode node \u003d CandidateNodeSetUtils.getSingleNode(candidates);\n\n    PendingAsk offswitchPendingAsk \u003d application.getPendingAsk(schedulerKey,\n        ResourceRequest.ANY);\n\n    if (offswitchPendingAsk.getCount() \u003c\u003d 0) {\n      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n          activitiesManager, node, application, priority,\n          ActivityDiagnosticConstant.PRIORITY_SKIPPED_BECAUSE_NULL_ANY_REQUEST);\n      return ContainerAllocation.PRIORITY_SKIPPED;\n    }\n\n    // Required resource\n    Resource required \u003d offswitchPendingAsk.getPerAllocationResource();\n\n    // Do we need containers at this \u0027priority\u0027?\n    if (application.getOutstandingAsksCount(schedulerKey) \u003c\u003d 0) {\n      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n          activitiesManager, node, application, priority,\n          ActivityDiagnosticConstant.APPLICATION_PRIORITY_DO_NOT_NEED_RESOURCE);\n      return ContainerAllocation.PRIORITY_SKIPPED;\n    }\n\n    // AM container allocation doesn\u0027t support non-exclusive allocation to\n    // avoid painful of preempt an AM container\n    if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n      if (application.isWaitingForAMContainer()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Skip allocating AM container to app_attempt\u003d\"\n              + application.getApplicationAttemptId()\n              + \", don\u0027t allow to allocate AM container in non-exclusive mode\");\n        }\n        application.updateAppSkipNodeDiagnostics(\n            \"Skipping assigning to Node in Ignore Exclusivity mode. \");\n        ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n            activitiesManager, node, application, priority,\n            ActivityDiagnosticConstant.SKIP_IN_IGNORE_EXCLUSIVITY_MODE);\n        return ContainerAllocation.APP_SKIPPED;\n      }\n    }\n\n    // Is the nodePartition of pending request matches the node\u0027s partition\n    // If not match, jump to next priority.\n    if (!appInfo.acceptNodePartition(schedulerKey, node.getPartition(),\n        schedulingMode)) {\n      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n          activitiesManager, node, application, priority,\n          ActivityDiagnosticConstant.\n              PRIORITY_SKIPPED_BECAUSE_NODE_PARTITION_DOES_NOT_MATCH_REQUEST);\n      return ContainerAllocation.PRIORITY_SKIPPED;\n    }\n\n    if (!application.getCSLeafQueue().getReservationContinueLooking()) {\n      if (!shouldAllocOrReserveNewContainer(schedulerKey, required)) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"doesn\u0027t need containers based on reservation algo!\");\n        }\n        ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n            activitiesManager, node, application, priority,\n            ActivityDiagnosticConstant.DO_NOT_NEED_ALLOCATIONATTEMPTINFOS);\n        return ContainerAllocation.PRIORITY_SKIPPED;\n      }\n    }\n\n    if (!checkHeadroom(clusterResource, resourceLimits, required,\n        candidates.getPartition())) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"cannot allocate required resource\u003d\" + required\n            + \" because of headroom\");\n      }\n      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n          activitiesManager, node, application, priority,\n          ActivityDiagnosticConstant.QUEUE_SKIPPED_HEADROOM);\n      return ContainerAllocation.QUEUE_SKIPPED;\n    }\n\n    // Increase missed-non-partitioned-resource-request-opportunity.\n    // This is to make sure non-partitioned-resource-request will prefer\n    // to be allocated to non-partitioned nodes\n    int missedNonPartitionedRequestSchedulingOpportunity \u003d 0;\n    // Only do this when request associated with given scheduler key accepts\n    // NO_LABEL under RESPECT_EXCLUSIVITY mode\n    if (StringUtils.equals(RMNodeLabelsManager.NO_LABEL,\n        appInfo.getAppPlacementAllocator(schedulerKey)\n            .getPrimaryRequestedNodePartition())) {\n      missedNonPartitionedRequestSchedulingOpportunity \u003d\n          application.addMissedNonPartitionedRequestSchedulingOpportunity(\n              schedulerKey);\n    }\n\n    if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n      // Before doing allocation, we need to check scheduling opportunity to\n      // make sure : non-partitioned resource request should be scheduled to\n      // non-partitioned partition first.\n      if (missedNonPartitionedRequestSchedulingOpportunity \u003c rmContext\n          .getScheduler().getNumClusterNodes()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Skip app_attempt\u003d\" + application.getApplicationAttemptId()\n              + \" priority\u003d\" + schedulerKey.getPriority()\n              + \" because missed-non-partitioned-resource-request\"\n              + \" opportunity under required:\" + \" Now\u003d\"\n              + missedNonPartitionedRequestSchedulingOpportunity + \" required\u003d\"\n              + rmContext.getScheduler().getNumClusterNodes());\n        }\n        ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n            activitiesManager, node, application, priority,\n            ActivityDiagnosticConstant.NON_PARTITIONED_PARTITION_FIRST);\n        return ContainerAllocation.APP_SKIPPED;\n      }\n    }\n\n    return null;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/allocator/RegularContainerAllocator.java",
          "extendedDetails": {
            "oldValue": "[clusterResource-Resource, ps-PlacementSet\u003cFiCaSchedulerNode\u003e, schedulingMode-SchedulingMode, resourceLimits-ResourceLimits, schedulerKey-SchedulerRequestKey]",
            "newValue": "[clusterResource-Resource, candidates-CandidateNodeSet\u003cFiCaSchedulerNode\u003e, schedulingMode-SchedulingMode, resourceLimits-ResourceLimits, schedulerKey-SchedulerRequestKey]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-7437. Rename PlacementSet and SchedulingPlacementSet. (Wangda Tan via kkaranasos)\n",
          "commitDate": "09/11/17 1:01 PM",
          "commitName": "ac4d2b1081d8836a21bc70e77f4e6cd2071a9949",
          "commitAuthor": "Konstantinos Karanasos",
          "commitDateOld": "17/09/17 9:20 PM",
          "commitNameOld": "e81596d06d226f1cfa44b2390ce3095ed4dee621",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 52.69,
          "commitsBetweenForRepo": 485,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,117 +1,118 @@\n-  private ContainerAllocation preCheckForPlacementSet(Resource clusterResource,\n-      PlacementSet\u003cFiCaSchedulerNode\u003e ps, SchedulingMode schedulingMode,\n-      ResourceLimits resourceLimits, SchedulerRequestKey schedulerKey) {\n+  private ContainerAllocation preCheckForNodeCandidateSet(\n+      Resource clusterResource, CandidateNodeSet\u003cFiCaSchedulerNode\u003e candidates,\n+      SchedulingMode schedulingMode, ResourceLimits resourceLimits,\n+      SchedulerRequestKey schedulerKey) {\n     Priority priority \u003d schedulerKey.getPriority();\n-    FiCaSchedulerNode node \u003d PlacementSetUtils.getSingleNode(ps);\n+    FiCaSchedulerNode node \u003d CandidateNodeSetUtils.getSingleNode(candidates);\n \n     PendingAsk offswitchPendingAsk \u003d application.getPendingAsk(schedulerKey,\n         ResourceRequest.ANY);\n \n     if (offswitchPendingAsk.getCount() \u003c\u003d 0) {\n       ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n           activitiesManager, node, application, priority,\n           ActivityDiagnosticConstant.PRIORITY_SKIPPED_BECAUSE_NULL_ANY_REQUEST);\n       return ContainerAllocation.PRIORITY_SKIPPED;\n     }\n \n     // Required resource\n     Resource required \u003d offswitchPendingAsk.getPerAllocationResource();\n \n     // Do we need containers at this \u0027priority\u0027?\n     if (application.getOutstandingAsksCount(schedulerKey) \u003c\u003d 0) {\n       ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n           activitiesManager, node, application, priority,\n           ActivityDiagnosticConstant.APPLICATION_PRIORITY_DO_NOT_NEED_RESOURCE);\n       return ContainerAllocation.PRIORITY_SKIPPED;\n     }\n \n     // AM container allocation doesn\u0027t support non-exclusive allocation to\n     // avoid painful of preempt an AM container\n     if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n       if (application.isWaitingForAMContainer()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Skip allocating AM container to app_attempt\u003d\"\n               + application.getApplicationAttemptId()\n               + \", don\u0027t allow to allocate AM container in non-exclusive mode\");\n         }\n         application.updateAppSkipNodeDiagnostics(\n             \"Skipping assigning to Node in Ignore Exclusivity mode. \");\n         ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n             activitiesManager, node, application, priority,\n             ActivityDiagnosticConstant.SKIP_IN_IGNORE_EXCLUSIVITY_MODE);\n         return ContainerAllocation.APP_SKIPPED;\n       }\n     }\n \n     // Is the nodePartition of pending request matches the node\u0027s partition\n     // If not match, jump to next priority.\n     if (!appInfo.acceptNodePartition(schedulerKey, node.getPartition(),\n         schedulingMode)) {\n       ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n           activitiesManager, node, application, priority,\n           ActivityDiagnosticConstant.\n               PRIORITY_SKIPPED_BECAUSE_NODE_PARTITION_DOES_NOT_MATCH_REQUEST);\n       return ContainerAllocation.PRIORITY_SKIPPED;\n     }\n \n     if (!application.getCSLeafQueue().getReservationContinueLooking()) {\n       if (!shouldAllocOrReserveNewContainer(schedulerKey, required)) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"doesn\u0027t need containers based on reservation algo!\");\n         }\n         ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n             activitiesManager, node, application, priority,\n             ActivityDiagnosticConstant.DO_NOT_NEED_ALLOCATIONATTEMPTINFOS);\n         return ContainerAllocation.PRIORITY_SKIPPED;\n       }\n     }\n \n     if (!checkHeadroom(clusterResource, resourceLimits, required,\n-        ps.getPartition())) {\n+        candidates.getPartition())) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"cannot allocate required resource\u003d\" + required\n             + \" because of headroom\");\n       }\n       ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n           activitiesManager, node, application, priority,\n           ActivityDiagnosticConstant.QUEUE_SKIPPED_HEADROOM);\n       return ContainerAllocation.QUEUE_SKIPPED;\n     }\n \n     // Increase missed-non-partitioned-resource-request-opportunity.\n     // This is to make sure non-partitioned-resource-request will prefer\n     // to be allocated to non-partitioned nodes\n     int missedNonPartitionedRequestSchedulingOpportunity \u003d 0;\n     // Only do this when request associated with given scheduler key accepts\n     // NO_LABEL under RESPECT_EXCLUSIVITY mode\n     if (StringUtils.equals(RMNodeLabelsManager.NO_LABEL,\n-        appInfo.getSchedulingPlacementSet(schedulerKey)\n+        appInfo.getAppPlacementAllocator(schedulerKey)\n             .getPrimaryRequestedNodePartition())) {\n       missedNonPartitionedRequestSchedulingOpportunity \u003d\n           application.addMissedNonPartitionedRequestSchedulingOpportunity(\n               schedulerKey);\n     }\n \n     if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n       // Before doing allocation, we need to check scheduling opportunity to\n       // make sure : non-partitioned resource request should be scheduled to\n       // non-partitioned partition first.\n       if (missedNonPartitionedRequestSchedulingOpportunity \u003c rmContext\n           .getScheduler().getNumClusterNodes()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Skip app_attempt\u003d\" + application.getApplicationAttemptId()\n               + \" priority\u003d\" + schedulerKey.getPriority()\n               + \" because missed-non-partitioned-resource-request\"\n               + \" opportunity under required:\" + \" Now\u003d\"\n               + missedNonPartitionedRequestSchedulingOpportunity + \" required\u003d\"\n               + rmContext.getScheduler().getNumClusterNodes());\n         }\n         ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n             activitiesManager, node, application, priority,\n             ActivityDiagnosticConstant.NON_PARTITIONED_PARTITION_FIRST);\n         return ContainerAllocation.APP_SKIPPED;\n       }\n     }\n \n     return null;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private ContainerAllocation preCheckForNodeCandidateSet(\n      Resource clusterResource, CandidateNodeSet\u003cFiCaSchedulerNode\u003e candidates,\n      SchedulingMode schedulingMode, ResourceLimits resourceLimits,\n      SchedulerRequestKey schedulerKey) {\n    Priority priority \u003d schedulerKey.getPriority();\n    FiCaSchedulerNode node \u003d CandidateNodeSetUtils.getSingleNode(candidates);\n\n    PendingAsk offswitchPendingAsk \u003d application.getPendingAsk(schedulerKey,\n        ResourceRequest.ANY);\n\n    if (offswitchPendingAsk.getCount() \u003c\u003d 0) {\n      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n          activitiesManager, node, application, priority,\n          ActivityDiagnosticConstant.PRIORITY_SKIPPED_BECAUSE_NULL_ANY_REQUEST);\n      return ContainerAllocation.PRIORITY_SKIPPED;\n    }\n\n    // Required resource\n    Resource required \u003d offswitchPendingAsk.getPerAllocationResource();\n\n    // Do we need containers at this \u0027priority\u0027?\n    if (application.getOutstandingAsksCount(schedulerKey) \u003c\u003d 0) {\n      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n          activitiesManager, node, application, priority,\n          ActivityDiagnosticConstant.APPLICATION_PRIORITY_DO_NOT_NEED_RESOURCE);\n      return ContainerAllocation.PRIORITY_SKIPPED;\n    }\n\n    // AM container allocation doesn\u0027t support non-exclusive allocation to\n    // avoid painful of preempt an AM container\n    if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n      if (application.isWaitingForAMContainer()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Skip allocating AM container to app_attempt\u003d\"\n              + application.getApplicationAttemptId()\n              + \", don\u0027t allow to allocate AM container in non-exclusive mode\");\n        }\n        application.updateAppSkipNodeDiagnostics(\n            \"Skipping assigning to Node in Ignore Exclusivity mode. \");\n        ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n            activitiesManager, node, application, priority,\n            ActivityDiagnosticConstant.SKIP_IN_IGNORE_EXCLUSIVITY_MODE);\n        return ContainerAllocation.APP_SKIPPED;\n      }\n    }\n\n    // Is the nodePartition of pending request matches the node\u0027s partition\n    // If not match, jump to next priority.\n    if (!appInfo.acceptNodePartition(schedulerKey, node.getPartition(),\n        schedulingMode)) {\n      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n          activitiesManager, node, application, priority,\n          ActivityDiagnosticConstant.\n              PRIORITY_SKIPPED_BECAUSE_NODE_PARTITION_DOES_NOT_MATCH_REQUEST);\n      return ContainerAllocation.PRIORITY_SKIPPED;\n    }\n\n    if (!application.getCSLeafQueue().getReservationContinueLooking()) {\n      if (!shouldAllocOrReserveNewContainer(schedulerKey, required)) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"doesn\u0027t need containers based on reservation algo!\");\n        }\n        ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n            activitiesManager, node, application, priority,\n            ActivityDiagnosticConstant.DO_NOT_NEED_ALLOCATIONATTEMPTINFOS);\n        return ContainerAllocation.PRIORITY_SKIPPED;\n      }\n    }\n\n    if (!checkHeadroom(clusterResource, resourceLimits, required,\n        candidates.getPartition())) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"cannot allocate required resource\u003d\" + required\n            + \" because of headroom\");\n      }\n      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n          activitiesManager, node, application, priority,\n          ActivityDiagnosticConstant.QUEUE_SKIPPED_HEADROOM);\n      return ContainerAllocation.QUEUE_SKIPPED;\n    }\n\n    // Increase missed-non-partitioned-resource-request-opportunity.\n    // This is to make sure non-partitioned-resource-request will prefer\n    // to be allocated to non-partitioned nodes\n    int missedNonPartitionedRequestSchedulingOpportunity \u003d 0;\n    // Only do this when request associated with given scheduler key accepts\n    // NO_LABEL under RESPECT_EXCLUSIVITY mode\n    if (StringUtils.equals(RMNodeLabelsManager.NO_LABEL,\n        appInfo.getAppPlacementAllocator(schedulerKey)\n            .getPrimaryRequestedNodePartition())) {\n      missedNonPartitionedRequestSchedulingOpportunity \u003d\n          application.addMissedNonPartitionedRequestSchedulingOpportunity(\n              schedulerKey);\n    }\n\n    if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n      // Before doing allocation, we need to check scheduling opportunity to\n      // make sure : non-partitioned resource request should be scheduled to\n      // non-partitioned partition first.\n      if (missedNonPartitionedRequestSchedulingOpportunity \u003c rmContext\n          .getScheduler().getNumClusterNodes()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Skip app_attempt\u003d\" + application.getApplicationAttemptId()\n              + \" priority\u003d\" + schedulerKey.getPriority()\n              + \" because missed-non-partitioned-resource-request\"\n              + \" opportunity under required:\" + \" Now\u003d\"\n              + missedNonPartitionedRequestSchedulingOpportunity + \" required\u003d\"\n              + rmContext.getScheduler().getNumClusterNodes());\n        }\n        ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n            activitiesManager, node, application, priority,\n            ActivityDiagnosticConstant.NON_PARTITIONED_PARTITION_FIRST);\n        return ContainerAllocation.APP_SKIPPED;\n      }\n    }\n\n    return null;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/allocator/RegularContainerAllocator.java",
          "extendedDetails": {}
        }
      ]
    },
    "2977bc6a141041ef7579efc416e93fc55e0c2a1a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6040. Introduce api independent PendingAsk to replace usage of ResourceRequest within Scheduler classes. (Wangda Tan via asuresh)\n",
      "commitDate": "06/01/17 9:59 AM",
      "commitName": "2977bc6a141041ef7579efc416e93fc55e0c2a1a",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "05/01/17 10:31 AM",
      "commitNameOld": "0a55bd841ec0f2eb89a0383f4c589526e8b138d4",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 0.98,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,115 +1,117 @@\n   private ContainerAllocation preCheckForPlacementSet(Resource clusterResource,\n       PlacementSet\u003cFiCaSchedulerNode\u003e ps, SchedulingMode schedulingMode,\n       ResourceLimits resourceLimits, SchedulerRequestKey schedulerKey) {\n     Priority priority \u003d schedulerKey.getPriority();\n     FiCaSchedulerNode node \u003d PlacementSetUtils.getSingleNode(ps);\n \n-    ResourceRequest anyRequest \u003d\n-        application.getResourceRequest(schedulerKey, ResourceRequest.ANY);\n-    if (null \u003d\u003d anyRequest) {\n+    PendingAsk offswitchPendingAsk \u003d application.getPendingAsk(schedulerKey,\n+        ResourceRequest.ANY);\n+\n+    if (offswitchPendingAsk.getCount() \u003c\u003d 0) {\n       ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n           activitiesManager, node, application, priority,\n           ActivityDiagnosticConstant.PRIORITY_SKIPPED_BECAUSE_NULL_ANY_REQUEST);\n       return ContainerAllocation.PRIORITY_SKIPPED;\n     }\n \n     // Required resource\n-    Resource required \u003d anyRequest.getCapability();\n+    Resource required \u003d offswitchPendingAsk.getPerAllocationResource();\n \n     // Do we need containers at this \u0027priority\u0027?\n-    if (application.getTotalRequiredResources(schedulerKey) \u003c\u003d 0) {\n+    if (application.getOutstandingAsksCount(schedulerKey) \u003c\u003d 0) {\n       ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n           activitiesManager, node, application, priority,\n           ActivityDiagnosticConstant.APPLICATION_PRIORITY_DO_NOT_NEED_RESOURCE);\n       return ContainerAllocation.PRIORITY_SKIPPED;\n     }\n \n     // AM container allocation doesn\u0027t support non-exclusive allocation to\n     // avoid painful of preempt an AM container\n     if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n       if (application.isWaitingForAMContainer()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Skip allocating AM container to app_attempt\u003d\"\n               + application.getApplicationAttemptId()\n               + \", don\u0027t allow to allocate AM container in non-exclusive mode\");\n         }\n         application.updateAppSkipNodeDiagnostics(\n             \"Skipping assigning to Node in Ignore Exclusivity mode. \");\n         ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n             activitiesManager, node, application, priority,\n             ActivityDiagnosticConstant.SKIP_IN_IGNORE_EXCLUSIVITY_MODE);\n         return ContainerAllocation.APP_SKIPPED;\n       }\n     }\n \n-    // Is the node-label-expression of this offswitch resource request\n-    // matches the node\u0027s label?\n+    // Is the nodePartition of pending request matches the node\u0027s partition\n     // If not match, jump to next priority.\n-    if (!SchedulerUtils.checkResourceRequestMatchingNodePartition(\n-        anyRequest.getNodeLabelExpression(), ps.getPartition(),\n+    if (!appInfo.acceptNodePartition(schedulerKey, node.getPartition(),\n         schedulingMode)) {\n       ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n           activitiesManager, node, application, priority,\n           ActivityDiagnosticConstant.\n               PRIORITY_SKIPPED_BECAUSE_NODE_PARTITION_DOES_NOT_MATCH_REQUEST);\n       return ContainerAllocation.PRIORITY_SKIPPED;\n     }\n \n     if (!application.getCSLeafQueue().getReservationContinueLooking()) {\n       if (!shouldAllocOrReserveNewContainer(schedulerKey, required)) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"doesn\u0027t need containers based on reservation algo!\");\n         }\n         ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n             activitiesManager, node, application, priority,\n             ActivityDiagnosticConstant.DO_NOT_NEED_ALLOCATIONATTEMPTINFOS);\n         return ContainerAllocation.PRIORITY_SKIPPED;\n       }\n     }\n \n     if (!checkHeadroom(clusterResource, resourceLimits, required,\n         ps.getPartition())) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"cannot allocate required resource\u003d\" + required\n             + \" because of headroom\");\n       }\n       ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n           activitiesManager, node, application, priority,\n           ActivityDiagnosticConstant.QUEUE_SKIPPED_HEADROOM);\n       return ContainerAllocation.QUEUE_SKIPPED;\n     }\n \n     // Increase missed-non-partitioned-resource-request-opportunity.\n     // This is to make sure non-partitioned-resource-request will prefer\n     // to be allocated to non-partitioned nodes\n     int missedNonPartitionedRequestSchedulingOpportunity \u003d 0;\n-    if (anyRequest.getNodeLabelExpression()\n-        .equals(RMNodeLabelsManager.NO_LABEL)) {\n+    // Only do this when request associated with given scheduler key accepts\n+    // NO_LABEL under RESPECT_EXCLUSIVITY mode\n+    if (StringUtils.equals(RMNodeLabelsManager.NO_LABEL,\n+        appInfo.getSchedulingPlacementSet(schedulerKey)\n+            .getPrimaryRequestedNodePartition())) {\n       missedNonPartitionedRequestSchedulingOpportunity \u003d\n           application.addMissedNonPartitionedRequestSchedulingOpportunity(\n               schedulerKey);\n     }\n \n     if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n       // Before doing allocation, we need to check scheduling opportunity to\n       // make sure : non-partitioned resource request should be scheduled to\n       // non-partitioned partition first.\n       if (missedNonPartitionedRequestSchedulingOpportunity \u003c rmContext\n           .getScheduler().getNumClusterNodes()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Skip app_attempt\u003d\" + application.getApplicationAttemptId()\n               + \" priority\u003d\" + schedulerKey.getPriority()\n               + \" because missed-non-partitioned-resource-request\"\n               + \" opportunity under required:\" + \" Now\u003d\"\n               + missedNonPartitionedRequestSchedulingOpportunity + \" required\u003d\"\n               + rmContext.getScheduler().getNumClusterNodes());\n         }\n         ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n             activitiesManager, node, application, priority,\n             ActivityDiagnosticConstant.NON_PARTITIONED_PARTITION_FIRST);\n         return ContainerAllocation.APP_SKIPPED;\n       }\n     }\n \n     return null;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private ContainerAllocation preCheckForPlacementSet(Resource clusterResource,\n      PlacementSet\u003cFiCaSchedulerNode\u003e ps, SchedulingMode schedulingMode,\n      ResourceLimits resourceLimits, SchedulerRequestKey schedulerKey) {\n    Priority priority \u003d schedulerKey.getPriority();\n    FiCaSchedulerNode node \u003d PlacementSetUtils.getSingleNode(ps);\n\n    PendingAsk offswitchPendingAsk \u003d application.getPendingAsk(schedulerKey,\n        ResourceRequest.ANY);\n\n    if (offswitchPendingAsk.getCount() \u003c\u003d 0) {\n      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n          activitiesManager, node, application, priority,\n          ActivityDiagnosticConstant.PRIORITY_SKIPPED_BECAUSE_NULL_ANY_REQUEST);\n      return ContainerAllocation.PRIORITY_SKIPPED;\n    }\n\n    // Required resource\n    Resource required \u003d offswitchPendingAsk.getPerAllocationResource();\n\n    // Do we need containers at this \u0027priority\u0027?\n    if (application.getOutstandingAsksCount(schedulerKey) \u003c\u003d 0) {\n      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n          activitiesManager, node, application, priority,\n          ActivityDiagnosticConstant.APPLICATION_PRIORITY_DO_NOT_NEED_RESOURCE);\n      return ContainerAllocation.PRIORITY_SKIPPED;\n    }\n\n    // AM container allocation doesn\u0027t support non-exclusive allocation to\n    // avoid painful of preempt an AM container\n    if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n      if (application.isWaitingForAMContainer()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Skip allocating AM container to app_attempt\u003d\"\n              + application.getApplicationAttemptId()\n              + \", don\u0027t allow to allocate AM container in non-exclusive mode\");\n        }\n        application.updateAppSkipNodeDiagnostics(\n            \"Skipping assigning to Node in Ignore Exclusivity mode. \");\n        ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n            activitiesManager, node, application, priority,\n            ActivityDiagnosticConstant.SKIP_IN_IGNORE_EXCLUSIVITY_MODE);\n        return ContainerAllocation.APP_SKIPPED;\n      }\n    }\n\n    // Is the nodePartition of pending request matches the node\u0027s partition\n    // If not match, jump to next priority.\n    if (!appInfo.acceptNodePartition(schedulerKey, node.getPartition(),\n        schedulingMode)) {\n      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n          activitiesManager, node, application, priority,\n          ActivityDiagnosticConstant.\n              PRIORITY_SKIPPED_BECAUSE_NODE_PARTITION_DOES_NOT_MATCH_REQUEST);\n      return ContainerAllocation.PRIORITY_SKIPPED;\n    }\n\n    if (!application.getCSLeafQueue().getReservationContinueLooking()) {\n      if (!shouldAllocOrReserveNewContainer(schedulerKey, required)) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"doesn\u0027t need containers based on reservation algo!\");\n        }\n        ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n            activitiesManager, node, application, priority,\n            ActivityDiagnosticConstant.DO_NOT_NEED_ALLOCATIONATTEMPTINFOS);\n        return ContainerAllocation.PRIORITY_SKIPPED;\n      }\n    }\n\n    if (!checkHeadroom(clusterResource, resourceLimits, required,\n        ps.getPartition())) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"cannot allocate required resource\u003d\" + required\n            + \" because of headroom\");\n      }\n      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n          activitiesManager, node, application, priority,\n          ActivityDiagnosticConstant.QUEUE_SKIPPED_HEADROOM);\n      return ContainerAllocation.QUEUE_SKIPPED;\n    }\n\n    // Increase missed-non-partitioned-resource-request-opportunity.\n    // This is to make sure non-partitioned-resource-request will prefer\n    // to be allocated to non-partitioned nodes\n    int missedNonPartitionedRequestSchedulingOpportunity \u003d 0;\n    // Only do this when request associated with given scheduler key accepts\n    // NO_LABEL under RESPECT_EXCLUSIVITY mode\n    if (StringUtils.equals(RMNodeLabelsManager.NO_LABEL,\n        appInfo.getSchedulingPlacementSet(schedulerKey)\n            .getPrimaryRequestedNodePartition())) {\n      missedNonPartitionedRequestSchedulingOpportunity \u003d\n          application.addMissedNonPartitionedRequestSchedulingOpportunity(\n              schedulerKey);\n    }\n\n    if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n      // Before doing allocation, we need to check scheduling opportunity to\n      // make sure : non-partitioned resource request should be scheduled to\n      // non-partitioned partition first.\n      if (missedNonPartitionedRequestSchedulingOpportunity \u003c rmContext\n          .getScheduler().getNumClusterNodes()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Skip app_attempt\u003d\" + application.getApplicationAttemptId()\n              + \" priority\u003d\" + schedulerKey.getPriority()\n              + \" because missed-non-partitioned-resource-request\"\n              + \" opportunity under required:\" + \" Now\u003d\"\n              + missedNonPartitionedRequestSchedulingOpportunity + \" required\u003d\"\n              + rmContext.getScheduler().getNumClusterNodes());\n        }\n        ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n            activitiesManager, node, application, priority,\n            ActivityDiagnosticConstant.NON_PARTITIONED_PARTITION_FIRST);\n        return ContainerAllocation.APP_SKIPPED;\n      }\n    }\n\n    return null;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/allocator/RegularContainerAllocator.java",
      "extendedDetails": {}
    },
    "1bbd023275db535ab80fcb60e022151e9679d468": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5962. Spelling errors in logging and exceptions for resource manager code (gsohn via rkanter)\n",
      "commitDate": "27/12/16 1:35 PM",
      "commitName": "1bbd023275db535ab80fcb60e022151e9679d468",
      "commitAuthor": "Robert Kanter",
      "commitDateOld": "27/12/16 12:40 PM",
      "commitNameOld": "ac1e5d4f77e3b9df8dcacb0b1f72eecc27931eb8",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,115 +1,115 @@\n   private ContainerAllocation preCheckForPlacementSet(Resource clusterResource,\n       PlacementSet\u003cFiCaSchedulerNode\u003e ps, SchedulingMode schedulingMode,\n       ResourceLimits resourceLimits, SchedulerRequestKey schedulerKey) {\n     Priority priority \u003d schedulerKey.getPriority();\n     FiCaSchedulerNode node \u003d PlacementSetUtils.getSingleNode(ps);\n \n     ResourceRequest anyRequest \u003d\n         application.getResourceRequest(schedulerKey, ResourceRequest.ANY);\n     if (null \u003d\u003d anyRequest) {\n       ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n           activitiesManager, node, application, priority,\n           ActivityDiagnosticConstant.PRIORITY_SKIPPED_BECAUSE_NULL_ANY_REQUEST);\n       return ContainerAllocation.PRIORITY_SKIPPED;\n     }\n \n     // Required resource\n     Resource required \u003d anyRequest.getCapability();\n \n     // Do we need containers at this \u0027priority\u0027?\n     if (application.getTotalRequiredResources(schedulerKey) \u003c\u003d 0) {\n       ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n           activitiesManager, node, application, priority,\n           ActivityDiagnosticConstant.APPLICATION_PRIORITY_DO_NOT_NEED_RESOURCE);\n       return ContainerAllocation.PRIORITY_SKIPPED;\n     }\n \n     // AM container allocation doesn\u0027t support non-exclusive allocation to\n     // avoid painful of preempt an AM container\n     if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n       if (application.isWaitingForAMContainer()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Skip allocating AM container to app_attempt\u003d\"\n               + application.getApplicationAttemptId()\n               + \", don\u0027t allow to allocate AM container in non-exclusive mode\");\n         }\n         application.updateAppSkipNodeDiagnostics(\n             \"Skipping assigning to Node in Ignore Exclusivity mode. \");\n         ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n             activitiesManager, node, application, priority,\n             ActivityDiagnosticConstant.SKIP_IN_IGNORE_EXCLUSIVITY_MODE);\n         return ContainerAllocation.APP_SKIPPED;\n       }\n     }\n \n     // Is the node-label-expression of this offswitch resource request\n     // matches the node\u0027s label?\n     // If not match, jump to next priority.\n     if (!SchedulerUtils.checkResourceRequestMatchingNodePartition(\n         anyRequest.getNodeLabelExpression(), ps.getPartition(),\n         schedulingMode)) {\n       ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n           activitiesManager, node, application, priority,\n           ActivityDiagnosticConstant.\n               PRIORITY_SKIPPED_BECAUSE_NODE_PARTITION_DOES_NOT_MATCH_REQUEST);\n       return ContainerAllocation.PRIORITY_SKIPPED;\n     }\n \n     if (!application.getCSLeafQueue().getReservationContinueLooking()) {\n       if (!shouldAllocOrReserveNewContainer(schedulerKey, required)) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"doesn\u0027t need containers based on reservation algo!\");\n         }\n         ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n             activitiesManager, node, application, priority,\n             ActivityDiagnosticConstant.DO_NOT_NEED_ALLOCATIONATTEMPTINFOS);\n         return ContainerAllocation.PRIORITY_SKIPPED;\n       }\n     }\n \n     if (!checkHeadroom(clusterResource, resourceLimits, required,\n         ps.getPartition())) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"cannot allocate required resource\u003d\" + required\n             + \" because of headroom\");\n       }\n       ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n           activitiesManager, node, application, priority,\n           ActivityDiagnosticConstant.QUEUE_SKIPPED_HEADROOM);\n       return ContainerAllocation.QUEUE_SKIPPED;\n     }\n \n     // Increase missed-non-partitioned-resource-request-opportunity.\n     // This is to make sure non-partitioned-resource-request will prefer\n     // to be allocated to non-partitioned nodes\n     int missedNonPartitionedRequestSchedulingOpportunity \u003d 0;\n     if (anyRequest.getNodeLabelExpression()\n         .equals(RMNodeLabelsManager.NO_LABEL)) {\n       missedNonPartitionedRequestSchedulingOpportunity \u003d\n           application.addMissedNonPartitionedRequestSchedulingOpportunity(\n               schedulerKey);\n     }\n \n     if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n       // Before doing allocation, we need to check scheduling opportunity to\n       // make sure : non-partitioned resource request should be scheduled to\n       // non-partitioned partition first.\n       if (missedNonPartitionedRequestSchedulingOpportunity \u003c rmContext\n           .getScheduler().getNumClusterNodes()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Skip app_attempt\u003d\" + application.getApplicationAttemptId()\n               + \" priority\u003d\" + schedulerKey.getPriority()\n               + \" because missed-non-partitioned-resource-request\"\n-              + \" opportunity under requred:\" + \" Now\u003d\"\n+              + \" opportunity under required:\" + \" Now\u003d\"\n               + missedNonPartitionedRequestSchedulingOpportunity + \" required\u003d\"\n               + rmContext.getScheduler().getNumClusterNodes());\n         }\n         ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n             activitiesManager, node, application, priority,\n             ActivityDiagnosticConstant.NON_PARTITIONED_PARTITION_FIRST);\n         return ContainerAllocation.APP_SKIPPED;\n       }\n     }\n \n     return null;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private ContainerAllocation preCheckForPlacementSet(Resource clusterResource,\n      PlacementSet\u003cFiCaSchedulerNode\u003e ps, SchedulingMode schedulingMode,\n      ResourceLimits resourceLimits, SchedulerRequestKey schedulerKey) {\n    Priority priority \u003d schedulerKey.getPriority();\n    FiCaSchedulerNode node \u003d PlacementSetUtils.getSingleNode(ps);\n\n    ResourceRequest anyRequest \u003d\n        application.getResourceRequest(schedulerKey, ResourceRequest.ANY);\n    if (null \u003d\u003d anyRequest) {\n      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n          activitiesManager, node, application, priority,\n          ActivityDiagnosticConstant.PRIORITY_SKIPPED_BECAUSE_NULL_ANY_REQUEST);\n      return ContainerAllocation.PRIORITY_SKIPPED;\n    }\n\n    // Required resource\n    Resource required \u003d anyRequest.getCapability();\n\n    // Do we need containers at this \u0027priority\u0027?\n    if (application.getTotalRequiredResources(schedulerKey) \u003c\u003d 0) {\n      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n          activitiesManager, node, application, priority,\n          ActivityDiagnosticConstant.APPLICATION_PRIORITY_DO_NOT_NEED_RESOURCE);\n      return ContainerAllocation.PRIORITY_SKIPPED;\n    }\n\n    // AM container allocation doesn\u0027t support non-exclusive allocation to\n    // avoid painful of preempt an AM container\n    if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n      if (application.isWaitingForAMContainer()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Skip allocating AM container to app_attempt\u003d\"\n              + application.getApplicationAttemptId()\n              + \", don\u0027t allow to allocate AM container in non-exclusive mode\");\n        }\n        application.updateAppSkipNodeDiagnostics(\n            \"Skipping assigning to Node in Ignore Exclusivity mode. \");\n        ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n            activitiesManager, node, application, priority,\n            ActivityDiagnosticConstant.SKIP_IN_IGNORE_EXCLUSIVITY_MODE);\n        return ContainerAllocation.APP_SKIPPED;\n      }\n    }\n\n    // Is the node-label-expression of this offswitch resource request\n    // matches the node\u0027s label?\n    // If not match, jump to next priority.\n    if (!SchedulerUtils.checkResourceRequestMatchingNodePartition(\n        anyRequest.getNodeLabelExpression(), ps.getPartition(),\n        schedulingMode)) {\n      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n          activitiesManager, node, application, priority,\n          ActivityDiagnosticConstant.\n              PRIORITY_SKIPPED_BECAUSE_NODE_PARTITION_DOES_NOT_MATCH_REQUEST);\n      return ContainerAllocation.PRIORITY_SKIPPED;\n    }\n\n    if (!application.getCSLeafQueue().getReservationContinueLooking()) {\n      if (!shouldAllocOrReserveNewContainer(schedulerKey, required)) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"doesn\u0027t need containers based on reservation algo!\");\n        }\n        ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n            activitiesManager, node, application, priority,\n            ActivityDiagnosticConstant.DO_NOT_NEED_ALLOCATIONATTEMPTINFOS);\n        return ContainerAllocation.PRIORITY_SKIPPED;\n      }\n    }\n\n    if (!checkHeadroom(clusterResource, resourceLimits, required,\n        ps.getPartition())) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"cannot allocate required resource\u003d\" + required\n            + \" because of headroom\");\n      }\n      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n          activitiesManager, node, application, priority,\n          ActivityDiagnosticConstant.QUEUE_SKIPPED_HEADROOM);\n      return ContainerAllocation.QUEUE_SKIPPED;\n    }\n\n    // Increase missed-non-partitioned-resource-request-opportunity.\n    // This is to make sure non-partitioned-resource-request will prefer\n    // to be allocated to non-partitioned nodes\n    int missedNonPartitionedRequestSchedulingOpportunity \u003d 0;\n    if (anyRequest.getNodeLabelExpression()\n        .equals(RMNodeLabelsManager.NO_LABEL)) {\n      missedNonPartitionedRequestSchedulingOpportunity \u003d\n          application.addMissedNonPartitionedRequestSchedulingOpportunity(\n              schedulerKey);\n    }\n\n    if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n      // Before doing allocation, we need to check scheduling opportunity to\n      // make sure : non-partitioned resource request should be scheduled to\n      // non-partitioned partition first.\n      if (missedNonPartitionedRequestSchedulingOpportunity \u003c rmContext\n          .getScheduler().getNumClusterNodes()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Skip app_attempt\u003d\" + application.getApplicationAttemptId()\n              + \" priority\u003d\" + schedulerKey.getPriority()\n              + \" because missed-non-partitioned-resource-request\"\n              + \" opportunity under required:\" + \" Now\u003d\"\n              + missedNonPartitionedRequestSchedulingOpportunity + \" required\u003d\"\n              + rmContext.getScheduler().getNumClusterNodes());\n        }\n        ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n            activitiesManager, node, application, priority,\n            ActivityDiagnosticConstant.NON_PARTITIONED_PARTITION_FIRST);\n        return ContainerAllocation.APP_SKIPPED;\n      }\n    }\n\n    return null;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/allocator/RegularContainerAllocator.java",
      "extendedDetails": {}
    },
    "de3b4aac561258ad242a3c5ed1c919428893fd4c": {
      "type": "Ymultichange(Yrename,Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-5716. Add global scheduler interface definition and update CapacityScheduler to use it. Contributed by Wangda Tan\n",
      "commitDate": "07/11/16 10:14 AM",
      "commitName": "de3b4aac561258ad242a3c5ed1c919428893fd4c",
      "commitAuthor": "Jian He",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "YARN-5716. Add global scheduler interface definition and update CapacityScheduler to use it. Contributed by Wangda Tan\n",
          "commitDate": "07/11/16 10:14 AM",
          "commitName": "de3b4aac561258ad242a3c5ed1c919428893fd4c",
          "commitAuthor": "Jian He",
          "commitDateOld": "19/09/16 2:08 AM",
          "commitNameOld": "b8a30f2f170ffbd590e7366c3c944ab4919e40df",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 49.38,
          "commitsBetweenForRepo": 429,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,125 +1,115 @@\n-  private ContainerAllocation preCheckForNewContainer(Resource clusterResource,\n-      FiCaSchedulerNode node, SchedulingMode schedulingMode,\n+  private ContainerAllocation preCheckForPlacementSet(Resource clusterResource,\n+      PlacementSet\u003cFiCaSchedulerNode\u003e ps, SchedulingMode schedulingMode,\n       ResourceLimits resourceLimits, SchedulerRequestKey schedulerKey) {\n     Priority priority \u003d schedulerKey.getPriority();\n-\n-    if (SchedulerAppUtils.isPlaceBlacklisted(application, node, LOG)) {\n-      application.updateAppSkipNodeDiagnostics(\n-          CSAMContainerLaunchDiagnosticsConstants.SKIP_AM_ALLOCATION_IN_BLACK_LISTED_NODE);\n-      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n-          activitiesManager, node, application, priority,\n-          ActivityDiagnosticConstant.SKIP_BLACK_LISTED_NODE);\n-      return ContainerAllocation.APP_SKIPPED;\n-    }\n+    FiCaSchedulerNode node \u003d PlacementSetUtils.getSingleNode(ps);\n \n     ResourceRequest anyRequest \u003d\n         application.getResourceRequest(schedulerKey, ResourceRequest.ANY);\n     if (null \u003d\u003d anyRequest) {\n       ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n           activitiesManager, node, application, priority,\n           ActivityDiagnosticConstant.PRIORITY_SKIPPED_BECAUSE_NULL_ANY_REQUEST);\n       return ContainerAllocation.PRIORITY_SKIPPED;\n     }\n \n     // Required resource\n     Resource required \u003d anyRequest.getCapability();\n \n     // Do we need containers at this \u0027priority\u0027?\n     if (application.getTotalRequiredResources(schedulerKey) \u003c\u003d 0) {\n       ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n           activitiesManager, node, application, priority,\n           ActivityDiagnosticConstant.APPLICATION_PRIORITY_DO_NOT_NEED_RESOURCE);\n       return ContainerAllocation.PRIORITY_SKIPPED;\n     }\n \n     // AM container allocation doesn\u0027t support non-exclusive allocation to\n     // avoid painful of preempt an AM container\n     if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n       if (application.isWaitingForAMContainer()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Skip allocating AM container to app_attempt\u003d\"\n               + application.getApplicationAttemptId()\n               + \", don\u0027t allow to allocate AM container in non-exclusive mode\");\n         }\n         application.updateAppSkipNodeDiagnostics(\n             \"Skipping assigning to Node in Ignore Exclusivity mode. \");\n         ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n             activitiesManager, node, application, priority,\n             ActivityDiagnosticConstant.SKIP_IN_IGNORE_EXCLUSIVITY_MODE);\n         return ContainerAllocation.APP_SKIPPED;\n       }\n     }\n \n     // Is the node-label-expression of this offswitch resource request\n     // matches the node\u0027s label?\n     // If not match, jump to next priority.\n     if (!SchedulerUtils.checkResourceRequestMatchingNodePartition(\n-        anyRequest.getNodeLabelExpression(), node.getPartition(),\n+        anyRequest.getNodeLabelExpression(), ps.getPartition(),\n         schedulingMode)) {\n       ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n           activitiesManager, node, application, priority,\n           ActivityDiagnosticConstant.\n               PRIORITY_SKIPPED_BECAUSE_NODE_PARTITION_DOES_NOT_MATCH_REQUEST);\n       return ContainerAllocation.PRIORITY_SKIPPED;\n     }\n \n     if (!application.getCSLeafQueue().getReservationContinueLooking()) {\n       if (!shouldAllocOrReserveNewContainer(schedulerKey, required)) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"doesn\u0027t need containers based on reservation algo!\");\n         }\n         ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n             activitiesManager, node, application, priority,\n             ActivityDiagnosticConstant.DO_NOT_NEED_ALLOCATIONATTEMPTINFOS);\n         return ContainerAllocation.PRIORITY_SKIPPED;\n       }\n     }\n \n-    if (!checkHeadroom(clusterResource, resourceLimits, required, node)) {\n+    if (!checkHeadroom(clusterResource, resourceLimits, required,\n+        ps.getPartition())) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"cannot allocate required resource\u003d\" + required\n             + \" because of headroom\");\n       }\n       ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n           activitiesManager, node, application, priority,\n           ActivityDiagnosticConstant.QUEUE_SKIPPED_HEADROOM);\n       return ContainerAllocation.QUEUE_SKIPPED;\n     }\n \n-    // Inform the application it is about to get a scheduling opportunity\n-    application.addSchedulingOpportunity(schedulerKey);\n-\n     // Increase missed-non-partitioned-resource-request-opportunity.\n     // This is to make sure non-partitioned-resource-request will prefer\n     // to be allocated to non-partitioned nodes\n     int missedNonPartitionedRequestSchedulingOpportunity \u003d 0;\n     if (anyRequest.getNodeLabelExpression()\n         .equals(RMNodeLabelsManager.NO_LABEL)) {\n       missedNonPartitionedRequestSchedulingOpportunity \u003d\n           application.addMissedNonPartitionedRequestSchedulingOpportunity(\n               schedulerKey);\n     }\n \n     if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n       // Before doing allocation, we need to check scheduling opportunity to\n       // make sure : non-partitioned resource request should be scheduled to\n       // non-partitioned partition first.\n       if (missedNonPartitionedRequestSchedulingOpportunity \u003c rmContext\n           .getScheduler().getNumClusterNodes()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Skip app_attempt\u003d\" + application.getApplicationAttemptId()\n               + \" priority\u003d\" + schedulerKey.getPriority()\n               + \" because missed-non-partitioned-resource-request\"\n               + \" opportunity under requred:\" + \" Now\u003d\"\n               + missedNonPartitionedRequestSchedulingOpportunity + \" required\u003d\"\n               + rmContext.getScheduler().getNumClusterNodes());\n         }\n         ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n             activitiesManager, node, application, priority,\n             ActivityDiagnosticConstant.NON_PARTITIONED_PARTITION_FIRST);\n         return ContainerAllocation.APP_SKIPPED;\n       }\n     }\n-    \n+\n     return null;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private ContainerAllocation preCheckForPlacementSet(Resource clusterResource,\n      PlacementSet\u003cFiCaSchedulerNode\u003e ps, SchedulingMode schedulingMode,\n      ResourceLimits resourceLimits, SchedulerRequestKey schedulerKey) {\n    Priority priority \u003d schedulerKey.getPriority();\n    FiCaSchedulerNode node \u003d PlacementSetUtils.getSingleNode(ps);\n\n    ResourceRequest anyRequest \u003d\n        application.getResourceRequest(schedulerKey, ResourceRequest.ANY);\n    if (null \u003d\u003d anyRequest) {\n      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n          activitiesManager, node, application, priority,\n          ActivityDiagnosticConstant.PRIORITY_SKIPPED_BECAUSE_NULL_ANY_REQUEST);\n      return ContainerAllocation.PRIORITY_SKIPPED;\n    }\n\n    // Required resource\n    Resource required \u003d anyRequest.getCapability();\n\n    // Do we need containers at this \u0027priority\u0027?\n    if (application.getTotalRequiredResources(schedulerKey) \u003c\u003d 0) {\n      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n          activitiesManager, node, application, priority,\n          ActivityDiagnosticConstant.APPLICATION_PRIORITY_DO_NOT_NEED_RESOURCE);\n      return ContainerAllocation.PRIORITY_SKIPPED;\n    }\n\n    // AM container allocation doesn\u0027t support non-exclusive allocation to\n    // avoid painful of preempt an AM container\n    if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n      if (application.isWaitingForAMContainer()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Skip allocating AM container to app_attempt\u003d\"\n              + application.getApplicationAttemptId()\n              + \", don\u0027t allow to allocate AM container in non-exclusive mode\");\n        }\n        application.updateAppSkipNodeDiagnostics(\n            \"Skipping assigning to Node in Ignore Exclusivity mode. \");\n        ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n            activitiesManager, node, application, priority,\n            ActivityDiagnosticConstant.SKIP_IN_IGNORE_EXCLUSIVITY_MODE);\n        return ContainerAllocation.APP_SKIPPED;\n      }\n    }\n\n    // Is the node-label-expression of this offswitch resource request\n    // matches the node\u0027s label?\n    // If not match, jump to next priority.\n    if (!SchedulerUtils.checkResourceRequestMatchingNodePartition(\n        anyRequest.getNodeLabelExpression(), ps.getPartition(),\n        schedulingMode)) {\n      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n          activitiesManager, node, application, priority,\n          ActivityDiagnosticConstant.\n              PRIORITY_SKIPPED_BECAUSE_NODE_PARTITION_DOES_NOT_MATCH_REQUEST);\n      return ContainerAllocation.PRIORITY_SKIPPED;\n    }\n\n    if (!application.getCSLeafQueue().getReservationContinueLooking()) {\n      if (!shouldAllocOrReserveNewContainer(schedulerKey, required)) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"doesn\u0027t need containers based on reservation algo!\");\n        }\n        ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n            activitiesManager, node, application, priority,\n            ActivityDiagnosticConstant.DO_NOT_NEED_ALLOCATIONATTEMPTINFOS);\n        return ContainerAllocation.PRIORITY_SKIPPED;\n      }\n    }\n\n    if (!checkHeadroom(clusterResource, resourceLimits, required,\n        ps.getPartition())) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"cannot allocate required resource\u003d\" + required\n            + \" because of headroom\");\n      }\n      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n          activitiesManager, node, application, priority,\n          ActivityDiagnosticConstant.QUEUE_SKIPPED_HEADROOM);\n      return ContainerAllocation.QUEUE_SKIPPED;\n    }\n\n    // Increase missed-non-partitioned-resource-request-opportunity.\n    // This is to make sure non-partitioned-resource-request will prefer\n    // to be allocated to non-partitioned nodes\n    int missedNonPartitionedRequestSchedulingOpportunity \u003d 0;\n    if (anyRequest.getNodeLabelExpression()\n        .equals(RMNodeLabelsManager.NO_LABEL)) {\n      missedNonPartitionedRequestSchedulingOpportunity \u003d\n          application.addMissedNonPartitionedRequestSchedulingOpportunity(\n              schedulerKey);\n    }\n\n    if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n      // Before doing allocation, we need to check scheduling opportunity to\n      // make sure : non-partitioned resource request should be scheduled to\n      // non-partitioned partition first.\n      if (missedNonPartitionedRequestSchedulingOpportunity \u003c rmContext\n          .getScheduler().getNumClusterNodes()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Skip app_attempt\u003d\" + application.getApplicationAttemptId()\n              + \" priority\u003d\" + schedulerKey.getPriority()\n              + \" because missed-non-partitioned-resource-request\"\n              + \" opportunity under requred:\" + \" Now\u003d\"\n              + missedNonPartitionedRequestSchedulingOpportunity + \" required\u003d\"\n              + rmContext.getScheduler().getNumClusterNodes());\n        }\n        ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n            activitiesManager, node, application, priority,\n            ActivityDiagnosticConstant.NON_PARTITIONED_PARTITION_FIRST);\n        return ContainerAllocation.APP_SKIPPED;\n      }\n    }\n\n    return null;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/allocator/RegularContainerAllocator.java",
          "extendedDetails": {
            "oldValue": "preCheckForNewContainer",
            "newValue": "preCheckForPlacementSet"
          }
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-5716. Add global scheduler interface definition and update CapacityScheduler to use it. Contributed by Wangda Tan\n",
          "commitDate": "07/11/16 10:14 AM",
          "commitName": "de3b4aac561258ad242a3c5ed1c919428893fd4c",
          "commitAuthor": "Jian He",
          "commitDateOld": "19/09/16 2:08 AM",
          "commitNameOld": "b8a30f2f170ffbd590e7366c3c944ab4919e40df",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 49.38,
          "commitsBetweenForRepo": 429,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,125 +1,115 @@\n-  private ContainerAllocation preCheckForNewContainer(Resource clusterResource,\n-      FiCaSchedulerNode node, SchedulingMode schedulingMode,\n+  private ContainerAllocation preCheckForPlacementSet(Resource clusterResource,\n+      PlacementSet\u003cFiCaSchedulerNode\u003e ps, SchedulingMode schedulingMode,\n       ResourceLimits resourceLimits, SchedulerRequestKey schedulerKey) {\n     Priority priority \u003d schedulerKey.getPriority();\n-\n-    if (SchedulerAppUtils.isPlaceBlacklisted(application, node, LOG)) {\n-      application.updateAppSkipNodeDiagnostics(\n-          CSAMContainerLaunchDiagnosticsConstants.SKIP_AM_ALLOCATION_IN_BLACK_LISTED_NODE);\n-      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n-          activitiesManager, node, application, priority,\n-          ActivityDiagnosticConstant.SKIP_BLACK_LISTED_NODE);\n-      return ContainerAllocation.APP_SKIPPED;\n-    }\n+    FiCaSchedulerNode node \u003d PlacementSetUtils.getSingleNode(ps);\n \n     ResourceRequest anyRequest \u003d\n         application.getResourceRequest(schedulerKey, ResourceRequest.ANY);\n     if (null \u003d\u003d anyRequest) {\n       ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n           activitiesManager, node, application, priority,\n           ActivityDiagnosticConstant.PRIORITY_SKIPPED_BECAUSE_NULL_ANY_REQUEST);\n       return ContainerAllocation.PRIORITY_SKIPPED;\n     }\n \n     // Required resource\n     Resource required \u003d anyRequest.getCapability();\n \n     // Do we need containers at this \u0027priority\u0027?\n     if (application.getTotalRequiredResources(schedulerKey) \u003c\u003d 0) {\n       ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n           activitiesManager, node, application, priority,\n           ActivityDiagnosticConstant.APPLICATION_PRIORITY_DO_NOT_NEED_RESOURCE);\n       return ContainerAllocation.PRIORITY_SKIPPED;\n     }\n \n     // AM container allocation doesn\u0027t support non-exclusive allocation to\n     // avoid painful of preempt an AM container\n     if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n       if (application.isWaitingForAMContainer()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Skip allocating AM container to app_attempt\u003d\"\n               + application.getApplicationAttemptId()\n               + \", don\u0027t allow to allocate AM container in non-exclusive mode\");\n         }\n         application.updateAppSkipNodeDiagnostics(\n             \"Skipping assigning to Node in Ignore Exclusivity mode. \");\n         ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n             activitiesManager, node, application, priority,\n             ActivityDiagnosticConstant.SKIP_IN_IGNORE_EXCLUSIVITY_MODE);\n         return ContainerAllocation.APP_SKIPPED;\n       }\n     }\n \n     // Is the node-label-expression of this offswitch resource request\n     // matches the node\u0027s label?\n     // If not match, jump to next priority.\n     if (!SchedulerUtils.checkResourceRequestMatchingNodePartition(\n-        anyRequest.getNodeLabelExpression(), node.getPartition(),\n+        anyRequest.getNodeLabelExpression(), ps.getPartition(),\n         schedulingMode)) {\n       ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n           activitiesManager, node, application, priority,\n           ActivityDiagnosticConstant.\n               PRIORITY_SKIPPED_BECAUSE_NODE_PARTITION_DOES_NOT_MATCH_REQUEST);\n       return ContainerAllocation.PRIORITY_SKIPPED;\n     }\n \n     if (!application.getCSLeafQueue().getReservationContinueLooking()) {\n       if (!shouldAllocOrReserveNewContainer(schedulerKey, required)) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"doesn\u0027t need containers based on reservation algo!\");\n         }\n         ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n             activitiesManager, node, application, priority,\n             ActivityDiagnosticConstant.DO_NOT_NEED_ALLOCATIONATTEMPTINFOS);\n         return ContainerAllocation.PRIORITY_SKIPPED;\n       }\n     }\n \n-    if (!checkHeadroom(clusterResource, resourceLimits, required, node)) {\n+    if (!checkHeadroom(clusterResource, resourceLimits, required,\n+        ps.getPartition())) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"cannot allocate required resource\u003d\" + required\n             + \" because of headroom\");\n       }\n       ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n           activitiesManager, node, application, priority,\n           ActivityDiagnosticConstant.QUEUE_SKIPPED_HEADROOM);\n       return ContainerAllocation.QUEUE_SKIPPED;\n     }\n \n-    // Inform the application it is about to get a scheduling opportunity\n-    application.addSchedulingOpportunity(schedulerKey);\n-\n     // Increase missed-non-partitioned-resource-request-opportunity.\n     // This is to make sure non-partitioned-resource-request will prefer\n     // to be allocated to non-partitioned nodes\n     int missedNonPartitionedRequestSchedulingOpportunity \u003d 0;\n     if (anyRequest.getNodeLabelExpression()\n         .equals(RMNodeLabelsManager.NO_LABEL)) {\n       missedNonPartitionedRequestSchedulingOpportunity \u003d\n           application.addMissedNonPartitionedRequestSchedulingOpportunity(\n               schedulerKey);\n     }\n \n     if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n       // Before doing allocation, we need to check scheduling opportunity to\n       // make sure : non-partitioned resource request should be scheduled to\n       // non-partitioned partition first.\n       if (missedNonPartitionedRequestSchedulingOpportunity \u003c rmContext\n           .getScheduler().getNumClusterNodes()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Skip app_attempt\u003d\" + application.getApplicationAttemptId()\n               + \" priority\u003d\" + schedulerKey.getPriority()\n               + \" because missed-non-partitioned-resource-request\"\n               + \" opportunity under requred:\" + \" Now\u003d\"\n               + missedNonPartitionedRequestSchedulingOpportunity + \" required\u003d\"\n               + rmContext.getScheduler().getNumClusterNodes());\n         }\n         ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n             activitiesManager, node, application, priority,\n             ActivityDiagnosticConstant.NON_PARTITIONED_PARTITION_FIRST);\n         return ContainerAllocation.APP_SKIPPED;\n       }\n     }\n-    \n+\n     return null;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private ContainerAllocation preCheckForPlacementSet(Resource clusterResource,\n      PlacementSet\u003cFiCaSchedulerNode\u003e ps, SchedulingMode schedulingMode,\n      ResourceLimits resourceLimits, SchedulerRequestKey schedulerKey) {\n    Priority priority \u003d schedulerKey.getPriority();\n    FiCaSchedulerNode node \u003d PlacementSetUtils.getSingleNode(ps);\n\n    ResourceRequest anyRequest \u003d\n        application.getResourceRequest(schedulerKey, ResourceRequest.ANY);\n    if (null \u003d\u003d anyRequest) {\n      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n          activitiesManager, node, application, priority,\n          ActivityDiagnosticConstant.PRIORITY_SKIPPED_BECAUSE_NULL_ANY_REQUEST);\n      return ContainerAllocation.PRIORITY_SKIPPED;\n    }\n\n    // Required resource\n    Resource required \u003d anyRequest.getCapability();\n\n    // Do we need containers at this \u0027priority\u0027?\n    if (application.getTotalRequiredResources(schedulerKey) \u003c\u003d 0) {\n      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n          activitiesManager, node, application, priority,\n          ActivityDiagnosticConstant.APPLICATION_PRIORITY_DO_NOT_NEED_RESOURCE);\n      return ContainerAllocation.PRIORITY_SKIPPED;\n    }\n\n    // AM container allocation doesn\u0027t support non-exclusive allocation to\n    // avoid painful of preempt an AM container\n    if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n      if (application.isWaitingForAMContainer()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Skip allocating AM container to app_attempt\u003d\"\n              + application.getApplicationAttemptId()\n              + \", don\u0027t allow to allocate AM container in non-exclusive mode\");\n        }\n        application.updateAppSkipNodeDiagnostics(\n            \"Skipping assigning to Node in Ignore Exclusivity mode. \");\n        ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n            activitiesManager, node, application, priority,\n            ActivityDiagnosticConstant.SKIP_IN_IGNORE_EXCLUSIVITY_MODE);\n        return ContainerAllocation.APP_SKIPPED;\n      }\n    }\n\n    // Is the node-label-expression of this offswitch resource request\n    // matches the node\u0027s label?\n    // If not match, jump to next priority.\n    if (!SchedulerUtils.checkResourceRequestMatchingNodePartition(\n        anyRequest.getNodeLabelExpression(), ps.getPartition(),\n        schedulingMode)) {\n      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n          activitiesManager, node, application, priority,\n          ActivityDiagnosticConstant.\n              PRIORITY_SKIPPED_BECAUSE_NODE_PARTITION_DOES_NOT_MATCH_REQUEST);\n      return ContainerAllocation.PRIORITY_SKIPPED;\n    }\n\n    if (!application.getCSLeafQueue().getReservationContinueLooking()) {\n      if (!shouldAllocOrReserveNewContainer(schedulerKey, required)) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"doesn\u0027t need containers based on reservation algo!\");\n        }\n        ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n            activitiesManager, node, application, priority,\n            ActivityDiagnosticConstant.DO_NOT_NEED_ALLOCATIONATTEMPTINFOS);\n        return ContainerAllocation.PRIORITY_SKIPPED;\n      }\n    }\n\n    if (!checkHeadroom(clusterResource, resourceLimits, required,\n        ps.getPartition())) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"cannot allocate required resource\u003d\" + required\n            + \" because of headroom\");\n      }\n      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n          activitiesManager, node, application, priority,\n          ActivityDiagnosticConstant.QUEUE_SKIPPED_HEADROOM);\n      return ContainerAllocation.QUEUE_SKIPPED;\n    }\n\n    // Increase missed-non-partitioned-resource-request-opportunity.\n    // This is to make sure non-partitioned-resource-request will prefer\n    // to be allocated to non-partitioned nodes\n    int missedNonPartitionedRequestSchedulingOpportunity \u003d 0;\n    if (anyRequest.getNodeLabelExpression()\n        .equals(RMNodeLabelsManager.NO_LABEL)) {\n      missedNonPartitionedRequestSchedulingOpportunity \u003d\n          application.addMissedNonPartitionedRequestSchedulingOpportunity(\n              schedulerKey);\n    }\n\n    if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n      // Before doing allocation, we need to check scheduling opportunity to\n      // make sure : non-partitioned resource request should be scheduled to\n      // non-partitioned partition first.\n      if (missedNonPartitionedRequestSchedulingOpportunity \u003c rmContext\n          .getScheduler().getNumClusterNodes()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Skip app_attempt\u003d\" + application.getApplicationAttemptId()\n              + \" priority\u003d\" + schedulerKey.getPriority()\n              + \" because missed-non-partitioned-resource-request\"\n              + \" opportunity under requred:\" + \" Now\u003d\"\n              + missedNonPartitionedRequestSchedulingOpportunity + \" required\u003d\"\n              + rmContext.getScheduler().getNumClusterNodes());\n        }\n        ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n            activitiesManager, node, application, priority,\n            ActivityDiagnosticConstant.NON_PARTITIONED_PARTITION_FIRST);\n        return ContainerAllocation.APP_SKIPPED;\n      }\n    }\n\n    return null;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/allocator/RegularContainerAllocator.java",
          "extendedDetails": {
            "oldValue": "[clusterResource-Resource, node-FiCaSchedulerNode, schedulingMode-SchedulingMode, resourceLimits-ResourceLimits, schedulerKey-SchedulerRequestKey]",
            "newValue": "[clusterResource-Resource, ps-PlacementSet\u003cFiCaSchedulerNode\u003e, schedulingMode-SchedulingMode, resourceLimits-ResourceLimits, schedulerKey-SchedulerRequestKey]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-5716. Add global scheduler interface definition and update CapacityScheduler to use it. Contributed by Wangda Tan\n",
          "commitDate": "07/11/16 10:14 AM",
          "commitName": "de3b4aac561258ad242a3c5ed1c919428893fd4c",
          "commitAuthor": "Jian He",
          "commitDateOld": "19/09/16 2:08 AM",
          "commitNameOld": "b8a30f2f170ffbd590e7366c3c944ab4919e40df",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 49.38,
          "commitsBetweenForRepo": 429,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,125 +1,115 @@\n-  private ContainerAllocation preCheckForNewContainer(Resource clusterResource,\n-      FiCaSchedulerNode node, SchedulingMode schedulingMode,\n+  private ContainerAllocation preCheckForPlacementSet(Resource clusterResource,\n+      PlacementSet\u003cFiCaSchedulerNode\u003e ps, SchedulingMode schedulingMode,\n       ResourceLimits resourceLimits, SchedulerRequestKey schedulerKey) {\n     Priority priority \u003d schedulerKey.getPriority();\n-\n-    if (SchedulerAppUtils.isPlaceBlacklisted(application, node, LOG)) {\n-      application.updateAppSkipNodeDiagnostics(\n-          CSAMContainerLaunchDiagnosticsConstants.SKIP_AM_ALLOCATION_IN_BLACK_LISTED_NODE);\n-      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n-          activitiesManager, node, application, priority,\n-          ActivityDiagnosticConstant.SKIP_BLACK_LISTED_NODE);\n-      return ContainerAllocation.APP_SKIPPED;\n-    }\n+    FiCaSchedulerNode node \u003d PlacementSetUtils.getSingleNode(ps);\n \n     ResourceRequest anyRequest \u003d\n         application.getResourceRequest(schedulerKey, ResourceRequest.ANY);\n     if (null \u003d\u003d anyRequest) {\n       ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n           activitiesManager, node, application, priority,\n           ActivityDiagnosticConstant.PRIORITY_SKIPPED_BECAUSE_NULL_ANY_REQUEST);\n       return ContainerAllocation.PRIORITY_SKIPPED;\n     }\n \n     // Required resource\n     Resource required \u003d anyRequest.getCapability();\n \n     // Do we need containers at this \u0027priority\u0027?\n     if (application.getTotalRequiredResources(schedulerKey) \u003c\u003d 0) {\n       ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n           activitiesManager, node, application, priority,\n           ActivityDiagnosticConstant.APPLICATION_PRIORITY_DO_NOT_NEED_RESOURCE);\n       return ContainerAllocation.PRIORITY_SKIPPED;\n     }\n \n     // AM container allocation doesn\u0027t support non-exclusive allocation to\n     // avoid painful of preempt an AM container\n     if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n       if (application.isWaitingForAMContainer()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Skip allocating AM container to app_attempt\u003d\"\n               + application.getApplicationAttemptId()\n               + \", don\u0027t allow to allocate AM container in non-exclusive mode\");\n         }\n         application.updateAppSkipNodeDiagnostics(\n             \"Skipping assigning to Node in Ignore Exclusivity mode. \");\n         ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n             activitiesManager, node, application, priority,\n             ActivityDiagnosticConstant.SKIP_IN_IGNORE_EXCLUSIVITY_MODE);\n         return ContainerAllocation.APP_SKIPPED;\n       }\n     }\n \n     // Is the node-label-expression of this offswitch resource request\n     // matches the node\u0027s label?\n     // If not match, jump to next priority.\n     if (!SchedulerUtils.checkResourceRequestMatchingNodePartition(\n-        anyRequest.getNodeLabelExpression(), node.getPartition(),\n+        anyRequest.getNodeLabelExpression(), ps.getPartition(),\n         schedulingMode)) {\n       ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n           activitiesManager, node, application, priority,\n           ActivityDiagnosticConstant.\n               PRIORITY_SKIPPED_BECAUSE_NODE_PARTITION_DOES_NOT_MATCH_REQUEST);\n       return ContainerAllocation.PRIORITY_SKIPPED;\n     }\n \n     if (!application.getCSLeafQueue().getReservationContinueLooking()) {\n       if (!shouldAllocOrReserveNewContainer(schedulerKey, required)) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"doesn\u0027t need containers based on reservation algo!\");\n         }\n         ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n             activitiesManager, node, application, priority,\n             ActivityDiagnosticConstant.DO_NOT_NEED_ALLOCATIONATTEMPTINFOS);\n         return ContainerAllocation.PRIORITY_SKIPPED;\n       }\n     }\n \n-    if (!checkHeadroom(clusterResource, resourceLimits, required, node)) {\n+    if (!checkHeadroom(clusterResource, resourceLimits, required,\n+        ps.getPartition())) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"cannot allocate required resource\u003d\" + required\n             + \" because of headroom\");\n       }\n       ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n           activitiesManager, node, application, priority,\n           ActivityDiagnosticConstant.QUEUE_SKIPPED_HEADROOM);\n       return ContainerAllocation.QUEUE_SKIPPED;\n     }\n \n-    // Inform the application it is about to get a scheduling opportunity\n-    application.addSchedulingOpportunity(schedulerKey);\n-\n     // Increase missed-non-partitioned-resource-request-opportunity.\n     // This is to make sure non-partitioned-resource-request will prefer\n     // to be allocated to non-partitioned nodes\n     int missedNonPartitionedRequestSchedulingOpportunity \u003d 0;\n     if (anyRequest.getNodeLabelExpression()\n         .equals(RMNodeLabelsManager.NO_LABEL)) {\n       missedNonPartitionedRequestSchedulingOpportunity \u003d\n           application.addMissedNonPartitionedRequestSchedulingOpportunity(\n               schedulerKey);\n     }\n \n     if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n       // Before doing allocation, we need to check scheduling opportunity to\n       // make sure : non-partitioned resource request should be scheduled to\n       // non-partitioned partition first.\n       if (missedNonPartitionedRequestSchedulingOpportunity \u003c rmContext\n           .getScheduler().getNumClusterNodes()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Skip app_attempt\u003d\" + application.getApplicationAttemptId()\n               + \" priority\u003d\" + schedulerKey.getPriority()\n               + \" because missed-non-partitioned-resource-request\"\n               + \" opportunity under requred:\" + \" Now\u003d\"\n               + missedNonPartitionedRequestSchedulingOpportunity + \" required\u003d\"\n               + rmContext.getScheduler().getNumClusterNodes());\n         }\n         ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n             activitiesManager, node, application, priority,\n             ActivityDiagnosticConstant.NON_PARTITIONED_PARTITION_FIRST);\n         return ContainerAllocation.APP_SKIPPED;\n       }\n     }\n-    \n+\n     return null;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private ContainerAllocation preCheckForPlacementSet(Resource clusterResource,\n      PlacementSet\u003cFiCaSchedulerNode\u003e ps, SchedulingMode schedulingMode,\n      ResourceLimits resourceLimits, SchedulerRequestKey schedulerKey) {\n    Priority priority \u003d schedulerKey.getPriority();\n    FiCaSchedulerNode node \u003d PlacementSetUtils.getSingleNode(ps);\n\n    ResourceRequest anyRequest \u003d\n        application.getResourceRequest(schedulerKey, ResourceRequest.ANY);\n    if (null \u003d\u003d anyRequest) {\n      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n          activitiesManager, node, application, priority,\n          ActivityDiagnosticConstant.PRIORITY_SKIPPED_BECAUSE_NULL_ANY_REQUEST);\n      return ContainerAllocation.PRIORITY_SKIPPED;\n    }\n\n    // Required resource\n    Resource required \u003d anyRequest.getCapability();\n\n    // Do we need containers at this \u0027priority\u0027?\n    if (application.getTotalRequiredResources(schedulerKey) \u003c\u003d 0) {\n      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n          activitiesManager, node, application, priority,\n          ActivityDiagnosticConstant.APPLICATION_PRIORITY_DO_NOT_NEED_RESOURCE);\n      return ContainerAllocation.PRIORITY_SKIPPED;\n    }\n\n    // AM container allocation doesn\u0027t support non-exclusive allocation to\n    // avoid painful of preempt an AM container\n    if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n      if (application.isWaitingForAMContainer()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Skip allocating AM container to app_attempt\u003d\"\n              + application.getApplicationAttemptId()\n              + \", don\u0027t allow to allocate AM container in non-exclusive mode\");\n        }\n        application.updateAppSkipNodeDiagnostics(\n            \"Skipping assigning to Node in Ignore Exclusivity mode. \");\n        ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n            activitiesManager, node, application, priority,\n            ActivityDiagnosticConstant.SKIP_IN_IGNORE_EXCLUSIVITY_MODE);\n        return ContainerAllocation.APP_SKIPPED;\n      }\n    }\n\n    // Is the node-label-expression of this offswitch resource request\n    // matches the node\u0027s label?\n    // If not match, jump to next priority.\n    if (!SchedulerUtils.checkResourceRequestMatchingNodePartition(\n        anyRequest.getNodeLabelExpression(), ps.getPartition(),\n        schedulingMode)) {\n      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n          activitiesManager, node, application, priority,\n          ActivityDiagnosticConstant.\n              PRIORITY_SKIPPED_BECAUSE_NODE_PARTITION_DOES_NOT_MATCH_REQUEST);\n      return ContainerAllocation.PRIORITY_SKIPPED;\n    }\n\n    if (!application.getCSLeafQueue().getReservationContinueLooking()) {\n      if (!shouldAllocOrReserveNewContainer(schedulerKey, required)) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"doesn\u0027t need containers based on reservation algo!\");\n        }\n        ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n            activitiesManager, node, application, priority,\n            ActivityDiagnosticConstant.DO_NOT_NEED_ALLOCATIONATTEMPTINFOS);\n        return ContainerAllocation.PRIORITY_SKIPPED;\n      }\n    }\n\n    if (!checkHeadroom(clusterResource, resourceLimits, required,\n        ps.getPartition())) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"cannot allocate required resource\u003d\" + required\n            + \" because of headroom\");\n      }\n      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n          activitiesManager, node, application, priority,\n          ActivityDiagnosticConstant.QUEUE_SKIPPED_HEADROOM);\n      return ContainerAllocation.QUEUE_SKIPPED;\n    }\n\n    // Increase missed-non-partitioned-resource-request-opportunity.\n    // This is to make sure non-partitioned-resource-request will prefer\n    // to be allocated to non-partitioned nodes\n    int missedNonPartitionedRequestSchedulingOpportunity \u003d 0;\n    if (anyRequest.getNodeLabelExpression()\n        .equals(RMNodeLabelsManager.NO_LABEL)) {\n      missedNonPartitionedRequestSchedulingOpportunity \u003d\n          application.addMissedNonPartitionedRequestSchedulingOpportunity(\n              schedulerKey);\n    }\n\n    if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n      // Before doing allocation, we need to check scheduling opportunity to\n      // make sure : non-partitioned resource request should be scheduled to\n      // non-partitioned partition first.\n      if (missedNonPartitionedRequestSchedulingOpportunity \u003c rmContext\n          .getScheduler().getNumClusterNodes()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Skip app_attempt\u003d\" + application.getApplicationAttemptId()\n              + \" priority\u003d\" + schedulerKey.getPriority()\n              + \" because missed-non-partitioned-resource-request\"\n              + \" opportunity under requred:\" + \" Now\u003d\"\n              + missedNonPartitionedRequestSchedulingOpportunity + \" required\u003d\"\n              + rmContext.getScheduler().getNumClusterNodes());\n        }\n        ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n            activitiesManager, node, application, priority,\n            ActivityDiagnosticConstant.NON_PARTITIONED_PARTITION_FIRST);\n        return ContainerAllocation.APP_SKIPPED;\n      }\n    }\n\n    return null;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/allocator/RegularContainerAllocator.java",
          "extendedDetails": {}
        }
      ]
    },
    "e0d131f055ee126052ad4d0f7b0d192e6c730188": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4091. Add REST API to retrieve scheduler activity. (Chen Ge and Sunil G via wangda)\n",
      "commitDate": "05/08/16 10:27 AM",
      "commitName": "e0d131f055ee126052ad4d0f7b0d192e6c730188",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "26/07/16 6:14 PM",
      "commitNameOld": "49969b16cdba0f251b9f8bf3d8df9906e38b5c61",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 9.68,
      "commitsBetweenForRepo": 77,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,99 +1,125 @@\n   private ContainerAllocation preCheckForNewContainer(Resource clusterResource,\n       FiCaSchedulerNode node, SchedulingMode schedulingMode,\n       ResourceLimits resourceLimits, SchedulerRequestKey schedulerKey) {\n+    Priority priority \u003d schedulerKey.getPriority();\n+\n     if (SchedulerAppUtils.isPlaceBlacklisted(application, node, LOG)) {\n       application.updateAppSkipNodeDiagnostics(\n           CSAMContainerLaunchDiagnosticsConstants.SKIP_AM_ALLOCATION_IN_BLACK_LISTED_NODE);\n+      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n+          activitiesManager, node, application, priority,\n+          ActivityDiagnosticConstant.SKIP_BLACK_LISTED_NODE);\n       return ContainerAllocation.APP_SKIPPED;\n     }\n \n     ResourceRequest anyRequest \u003d\n         application.getResourceRequest(schedulerKey, ResourceRequest.ANY);\n     if (null \u003d\u003d anyRequest) {\n+      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n+          activitiesManager, node, application, priority,\n+          ActivityDiagnosticConstant.PRIORITY_SKIPPED_BECAUSE_NULL_ANY_REQUEST);\n       return ContainerAllocation.PRIORITY_SKIPPED;\n     }\n \n     // Required resource\n     Resource required \u003d anyRequest.getCapability();\n \n     // Do we need containers at this \u0027priority\u0027?\n     if (application.getTotalRequiredResources(schedulerKey) \u003c\u003d 0) {\n+      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n+          activitiesManager, node, application, priority,\n+          ActivityDiagnosticConstant.APPLICATION_PRIORITY_DO_NOT_NEED_RESOURCE);\n       return ContainerAllocation.PRIORITY_SKIPPED;\n     }\n \n     // AM container allocation doesn\u0027t support non-exclusive allocation to\n     // avoid painful of preempt an AM container\n     if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n       if (application.isWaitingForAMContainer()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Skip allocating AM container to app_attempt\u003d\"\n               + application.getApplicationAttemptId()\n               + \", don\u0027t allow to allocate AM container in non-exclusive mode\");\n         }\n         application.updateAppSkipNodeDiagnostics(\n             \"Skipping assigning to Node in Ignore Exclusivity mode. \");\n+        ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n+            activitiesManager, node, application, priority,\n+            ActivityDiagnosticConstant.SKIP_IN_IGNORE_EXCLUSIVITY_MODE);\n         return ContainerAllocation.APP_SKIPPED;\n       }\n     }\n \n     // Is the node-label-expression of this offswitch resource request\n     // matches the node\u0027s label?\n     // If not match, jump to next priority.\n     if (!SchedulerUtils.checkResourceRequestMatchingNodePartition(\n         anyRequest.getNodeLabelExpression(), node.getPartition(),\n         schedulingMode)) {\n+      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n+          activitiesManager, node, application, priority,\n+          ActivityDiagnosticConstant.\n+              PRIORITY_SKIPPED_BECAUSE_NODE_PARTITION_DOES_NOT_MATCH_REQUEST);\n       return ContainerAllocation.PRIORITY_SKIPPED;\n     }\n \n     if (!application.getCSLeafQueue().getReservationContinueLooking()) {\n       if (!shouldAllocOrReserveNewContainer(schedulerKey, required)) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"doesn\u0027t need containers based on reservation algo!\");\n         }\n+        ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n+            activitiesManager, node, application, priority,\n+            ActivityDiagnosticConstant.DO_NOT_NEED_ALLOCATIONATTEMPTINFOS);\n         return ContainerAllocation.PRIORITY_SKIPPED;\n       }\n     }\n \n     if (!checkHeadroom(clusterResource, resourceLimits, required, node)) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"cannot allocate required resource\u003d\" + required\n             + \" because of headroom\");\n       }\n+      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n+          activitiesManager, node, application, priority,\n+          ActivityDiagnosticConstant.QUEUE_SKIPPED_HEADROOM);\n       return ContainerAllocation.QUEUE_SKIPPED;\n     }\n \n     // Inform the application it is about to get a scheduling opportunity\n     application.addSchedulingOpportunity(schedulerKey);\n \n     // Increase missed-non-partitioned-resource-request-opportunity.\n     // This is to make sure non-partitioned-resource-request will prefer\n     // to be allocated to non-partitioned nodes\n     int missedNonPartitionedRequestSchedulingOpportunity \u003d 0;\n     if (anyRequest.getNodeLabelExpression()\n         .equals(RMNodeLabelsManager.NO_LABEL)) {\n       missedNonPartitionedRequestSchedulingOpportunity \u003d\n           application.addMissedNonPartitionedRequestSchedulingOpportunity(\n               schedulerKey);\n     }\n \n     if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n       // Before doing allocation, we need to check scheduling opportunity to\n       // make sure : non-partitioned resource request should be scheduled to\n       // non-partitioned partition first.\n       if (missedNonPartitionedRequestSchedulingOpportunity \u003c rmContext\n           .getScheduler().getNumClusterNodes()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Skip app_attempt\u003d\" + application.getApplicationAttemptId()\n               + \" priority\u003d\" + schedulerKey.getPriority()\n               + \" because missed-non-partitioned-resource-request\"\n               + \" opportunity under requred:\" + \" Now\u003d\"\n               + missedNonPartitionedRequestSchedulingOpportunity + \" required\u003d\"\n               + rmContext.getScheduler().getNumClusterNodes());\n         }\n-\n+        ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n+            activitiesManager, node, application, priority,\n+            ActivityDiagnosticConstant.NON_PARTITIONED_PARTITION_FIRST);\n         return ContainerAllocation.APP_SKIPPED;\n       }\n     }\n     \n     return null;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private ContainerAllocation preCheckForNewContainer(Resource clusterResource,\n      FiCaSchedulerNode node, SchedulingMode schedulingMode,\n      ResourceLimits resourceLimits, SchedulerRequestKey schedulerKey) {\n    Priority priority \u003d schedulerKey.getPriority();\n\n    if (SchedulerAppUtils.isPlaceBlacklisted(application, node, LOG)) {\n      application.updateAppSkipNodeDiagnostics(\n          CSAMContainerLaunchDiagnosticsConstants.SKIP_AM_ALLOCATION_IN_BLACK_LISTED_NODE);\n      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n          activitiesManager, node, application, priority,\n          ActivityDiagnosticConstant.SKIP_BLACK_LISTED_NODE);\n      return ContainerAllocation.APP_SKIPPED;\n    }\n\n    ResourceRequest anyRequest \u003d\n        application.getResourceRequest(schedulerKey, ResourceRequest.ANY);\n    if (null \u003d\u003d anyRequest) {\n      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n          activitiesManager, node, application, priority,\n          ActivityDiagnosticConstant.PRIORITY_SKIPPED_BECAUSE_NULL_ANY_REQUEST);\n      return ContainerAllocation.PRIORITY_SKIPPED;\n    }\n\n    // Required resource\n    Resource required \u003d anyRequest.getCapability();\n\n    // Do we need containers at this \u0027priority\u0027?\n    if (application.getTotalRequiredResources(schedulerKey) \u003c\u003d 0) {\n      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n          activitiesManager, node, application, priority,\n          ActivityDiagnosticConstant.APPLICATION_PRIORITY_DO_NOT_NEED_RESOURCE);\n      return ContainerAllocation.PRIORITY_SKIPPED;\n    }\n\n    // AM container allocation doesn\u0027t support non-exclusive allocation to\n    // avoid painful of preempt an AM container\n    if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n      if (application.isWaitingForAMContainer()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Skip allocating AM container to app_attempt\u003d\"\n              + application.getApplicationAttemptId()\n              + \", don\u0027t allow to allocate AM container in non-exclusive mode\");\n        }\n        application.updateAppSkipNodeDiagnostics(\n            \"Skipping assigning to Node in Ignore Exclusivity mode. \");\n        ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n            activitiesManager, node, application, priority,\n            ActivityDiagnosticConstant.SKIP_IN_IGNORE_EXCLUSIVITY_MODE);\n        return ContainerAllocation.APP_SKIPPED;\n      }\n    }\n\n    // Is the node-label-expression of this offswitch resource request\n    // matches the node\u0027s label?\n    // If not match, jump to next priority.\n    if (!SchedulerUtils.checkResourceRequestMatchingNodePartition(\n        anyRequest.getNodeLabelExpression(), node.getPartition(),\n        schedulingMode)) {\n      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n          activitiesManager, node, application, priority,\n          ActivityDiagnosticConstant.\n              PRIORITY_SKIPPED_BECAUSE_NODE_PARTITION_DOES_NOT_MATCH_REQUEST);\n      return ContainerAllocation.PRIORITY_SKIPPED;\n    }\n\n    if (!application.getCSLeafQueue().getReservationContinueLooking()) {\n      if (!shouldAllocOrReserveNewContainer(schedulerKey, required)) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"doesn\u0027t need containers based on reservation algo!\");\n        }\n        ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n            activitiesManager, node, application, priority,\n            ActivityDiagnosticConstant.DO_NOT_NEED_ALLOCATIONATTEMPTINFOS);\n        return ContainerAllocation.PRIORITY_SKIPPED;\n      }\n    }\n\n    if (!checkHeadroom(clusterResource, resourceLimits, required, node)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"cannot allocate required resource\u003d\" + required\n            + \" because of headroom\");\n      }\n      ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n          activitiesManager, node, application, priority,\n          ActivityDiagnosticConstant.QUEUE_SKIPPED_HEADROOM);\n      return ContainerAllocation.QUEUE_SKIPPED;\n    }\n\n    // Inform the application it is about to get a scheduling opportunity\n    application.addSchedulingOpportunity(schedulerKey);\n\n    // Increase missed-non-partitioned-resource-request-opportunity.\n    // This is to make sure non-partitioned-resource-request will prefer\n    // to be allocated to non-partitioned nodes\n    int missedNonPartitionedRequestSchedulingOpportunity \u003d 0;\n    if (anyRequest.getNodeLabelExpression()\n        .equals(RMNodeLabelsManager.NO_LABEL)) {\n      missedNonPartitionedRequestSchedulingOpportunity \u003d\n          application.addMissedNonPartitionedRequestSchedulingOpportunity(\n              schedulerKey);\n    }\n\n    if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n      // Before doing allocation, we need to check scheduling opportunity to\n      // make sure : non-partitioned resource request should be scheduled to\n      // non-partitioned partition first.\n      if (missedNonPartitionedRequestSchedulingOpportunity \u003c rmContext\n          .getScheduler().getNumClusterNodes()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Skip app_attempt\u003d\" + application.getApplicationAttemptId()\n              + \" priority\u003d\" + schedulerKey.getPriority()\n              + \" because missed-non-partitioned-resource-request\"\n              + \" opportunity under requred:\" + \" Now\u003d\"\n              + missedNonPartitionedRequestSchedulingOpportunity + \" required\u003d\"\n              + rmContext.getScheduler().getNumClusterNodes());\n        }\n        ActivitiesLogger.APP.recordSkippedAppActivityWithoutAllocation(\n            activitiesManager, node, application, priority,\n            ActivityDiagnosticConstant.NON_PARTITIONED_PARTITION_FIRST);\n        return ContainerAllocation.APP_SKIPPED;\n      }\n    }\n    \n    return null;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/allocator/RegularContainerAllocator.java",
      "extendedDetails": {}
    },
    "5aace38b748ba71aaadd2c4d64eba8dc1f816828": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-5392. Replace use of Priority in the Scheduling infrastructure with an opaque ShedulerRequestKey. (asuresh and subru)\n",
      "commitDate": "26/07/16 2:54 PM",
      "commitName": "5aace38b748ba71aaadd2c4d64eba8dc1f816828",
      "commitAuthor": "Arun Suresh",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-5392. Replace use of Priority in the Scheduling infrastructure with an opaque ShedulerRequestKey. (asuresh and subru)\n",
          "commitDate": "26/07/16 2:54 PM",
          "commitName": "5aace38b748ba71aaadd2c4d64eba8dc1f816828",
          "commitAuthor": "Arun Suresh",
          "commitDateOld": "07/06/16 3:06 PM",
          "commitNameOld": "620325e81696fca140195b74929ed9eda2d5eb16",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 48.99,
          "commitsBetweenForRepo": 441,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,99 +1,99 @@\n   private ContainerAllocation preCheckForNewContainer(Resource clusterResource,\n       FiCaSchedulerNode node, SchedulingMode schedulingMode,\n-      ResourceLimits resourceLimits, Priority priority) {\n+      ResourceLimits resourceLimits, SchedulerRequestKey schedulerKey) {\n     if (SchedulerAppUtils.isPlaceBlacklisted(application, node, LOG)) {\n       application.updateAppSkipNodeDiagnostics(\n           CSAMContainerLaunchDiagnosticsConstants.SKIP_AM_ALLOCATION_IN_BLACK_LISTED_NODE);\n       return ContainerAllocation.APP_SKIPPED;\n     }\n \n     ResourceRequest anyRequest \u003d\n-        application.getResourceRequest(priority, ResourceRequest.ANY);\n+        application.getResourceRequest(schedulerKey, ResourceRequest.ANY);\n     if (null \u003d\u003d anyRequest) {\n       return ContainerAllocation.PRIORITY_SKIPPED;\n     }\n \n     // Required resource\n     Resource required \u003d anyRequest.getCapability();\n \n     // Do we need containers at this \u0027priority\u0027?\n-    if (application.getTotalRequiredResources(priority) \u003c\u003d 0) {\n+    if (application.getTotalRequiredResources(schedulerKey) \u003c\u003d 0) {\n       return ContainerAllocation.PRIORITY_SKIPPED;\n     }\n \n     // AM container allocation doesn\u0027t support non-exclusive allocation to\n     // avoid painful of preempt an AM container\n     if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n       if (application.isWaitingForAMContainer()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Skip allocating AM container to app_attempt\u003d\"\n               + application.getApplicationAttemptId()\n               + \", don\u0027t allow to allocate AM container in non-exclusive mode\");\n         }\n         application.updateAppSkipNodeDiagnostics(\n             \"Skipping assigning to Node in Ignore Exclusivity mode. \");\n         return ContainerAllocation.APP_SKIPPED;\n       }\n     }\n \n     // Is the node-label-expression of this offswitch resource request\n     // matches the node\u0027s label?\n     // If not match, jump to next priority.\n     if (!SchedulerUtils.checkResourceRequestMatchingNodePartition(\n         anyRequest.getNodeLabelExpression(), node.getPartition(),\n         schedulingMode)) {\n       return ContainerAllocation.PRIORITY_SKIPPED;\n     }\n \n     if (!application.getCSLeafQueue().getReservationContinueLooking()) {\n-      if (!shouldAllocOrReserveNewContainer(priority, required)) {\n+      if (!shouldAllocOrReserveNewContainer(schedulerKey, required)) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"doesn\u0027t need containers based on reservation algo!\");\n         }\n         return ContainerAllocation.PRIORITY_SKIPPED;\n       }\n     }\n \n     if (!checkHeadroom(clusterResource, resourceLimits, required, node)) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"cannot allocate required resource\u003d\" + required\n             + \" because of headroom\");\n       }\n       return ContainerAllocation.QUEUE_SKIPPED;\n     }\n \n     // Inform the application it is about to get a scheduling opportunity\n-    application.addSchedulingOpportunity(priority);\n+    application.addSchedulingOpportunity(schedulerKey);\n \n     // Increase missed-non-partitioned-resource-request-opportunity.\n     // This is to make sure non-partitioned-resource-request will prefer\n     // to be allocated to non-partitioned nodes\n     int missedNonPartitionedRequestSchedulingOpportunity \u003d 0;\n     if (anyRequest.getNodeLabelExpression()\n         .equals(RMNodeLabelsManager.NO_LABEL)) {\n       missedNonPartitionedRequestSchedulingOpportunity \u003d\n-          application\n-              .addMissedNonPartitionedRequestSchedulingOpportunity(priority);\n+          application.addMissedNonPartitionedRequestSchedulingOpportunity(\n+              schedulerKey);\n     }\n \n     if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n       // Before doing allocation, we need to check scheduling opportunity to\n       // make sure : non-partitioned resource request should be scheduled to\n       // non-partitioned partition first.\n       if (missedNonPartitionedRequestSchedulingOpportunity \u003c rmContext\n           .getScheduler().getNumClusterNodes()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Skip app_attempt\u003d\" + application.getApplicationAttemptId()\n-              + \" priority\u003d\" + priority\n+              + \" priority\u003d\" + schedulerKey.getPriority()\n               + \" because missed-non-partitioned-resource-request\"\n               + \" opportunity under requred:\" + \" Now\u003d\"\n               + missedNonPartitionedRequestSchedulingOpportunity + \" required\u003d\"\n               + rmContext.getScheduler().getNumClusterNodes());\n         }\n \n         return ContainerAllocation.APP_SKIPPED;\n       }\n     }\n     \n     return null;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private ContainerAllocation preCheckForNewContainer(Resource clusterResource,\n      FiCaSchedulerNode node, SchedulingMode schedulingMode,\n      ResourceLimits resourceLimits, SchedulerRequestKey schedulerKey) {\n    if (SchedulerAppUtils.isPlaceBlacklisted(application, node, LOG)) {\n      application.updateAppSkipNodeDiagnostics(\n          CSAMContainerLaunchDiagnosticsConstants.SKIP_AM_ALLOCATION_IN_BLACK_LISTED_NODE);\n      return ContainerAllocation.APP_SKIPPED;\n    }\n\n    ResourceRequest anyRequest \u003d\n        application.getResourceRequest(schedulerKey, ResourceRequest.ANY);\n    if (null \u003d\u003d anyRequest) {\n      return ContainerAllocation.PRIORITY_SKIPPED;\n    }\n\n    // Required resource\n    Resource required \u003d anyRequest.getCapability();\n\n    // Do we need containers at this \u0027priority\u0027?\n    if (application.getTotalRequiredResources(schedulerKey) \u003c\u003d 0) {\n      return ContainerAllocation.PRIORITY_SKIPPED;\n    }\n\n    // AM container allocation doesn\u0027t support non-exclusive allocation to\n    // avoid painful of preempt an AM container\n    if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n      if (application.isWaitingForAMContainer()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Skip allocating AM container to app_attempt\u003d\"\n              + application.getApplicationAttemptId()\n              + \", don\u0027t allow to allocate AM container in non-exclusive mode\");\n        }\n        application.updateAppSkipNodeDiagnostics(\n            \"Skipping assigning to Node in Ignore Exclusivity mode. \");\n        return ContainerAllocation.APP_SKIPPED;\n      }\n    }\n\n    // Is the node-label-expression of this offswitch resource request\n    // matches the node\u0027s label?\n    // If not match, jump to next priority.\n    if (!SchedulerUtils.checkResourceRequestMatchingNodePartition(\n        anyRequest.getNodeLabelExpression(), node.getPartition(),\n        schedulingMode)) {\n      return ContainerAllocation.PRIORITY_SKIPPED;\n    }\n\n    if (!application.getCSLeafQueue().getReservationContinueLooking()) {\n      if (!shouldAllocOrReserveNewContainer(schedulerKey, required)) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"doesn\u0027t need containers based on reservation algo!\");\n        }\n        return ContainerAllocation.PRIORITY_SKIPPED;\n      }\n    }\n\n    if (!checkHeadroom(clusterResource, resourceLimits, required, node)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"cannot allocate required resource\u003d\" + required\n            + \" because of headroom\");\n      }\n      return ContainerAllocation.QUEUE_SKIPPED;\n    }\n\n    // Inform the application it is about to get a scheduling opportunity\n    application.addSchedulingOpportunity(schedulerKey);\n\n    // Increase missed-non-partitioned-resource-request-opportunity.\n    // This is to make sure non-partitioned-resource-request will prefer\n    // to be allocated to non-partitioned nodes\n    int missedNonPartitionedRequestSchedulingOpportunity \u003d 0;\n    if (anyRequest.getNodeLabelExpression()\n        .equals(RMNodeLabelsManager.NO_LABEL)) {\n      missedNonPartitionedRequestSchedulingOpportunity \u003d\n          application.addMissedNonPartitionedRequestSchedulingOpportunity(\n              schedulerKey);\n    }\n\n    if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n      // Before doing allocation, we need to check scheduling opportunity to\n      // make sure : non-partitioned resource request should be scheduled to\n      // non-partitioned partition first.\n      if (missedNonPartitionedRequestSchedulingOpportunity \u003c rmContext\n          .getScheduler().getNumClusterNodes()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Skip app_attempt\u003d\" + application.getApplicationAttemptId()\n              + \" priority\u003d\" + schedulerKey.getPriority()\n              + \" because missed-non-partitioned-resource-request\"\n              + \" opportunity under requred:\" + \" Now\u003d\"\n              + missedNonPartitionedRequestSchedulingOpportunity + \" required\u003d\"\n              + rmContext.getScheduler().getNumClusterNodes());\n        }\n\n        return ContainerAllocation.APP_SKIPPED;\n      }\n    }\n    \n    return null;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/allocator/RegularContainerAllocator.java",
          "extendedDetails": {
            "oldValue": "[clusterResource-Resource, node-FiCaSchedulerNode, schedulingMode-SchedulingMode, resourceLimits-ResourceLimits, priority-Priority]",
            "newValue": "[clusterResource-Resource, node-FiCaSchedulerNode, schedulingMode-SchedulingMode, resourceLimits-ResourceLimits, schedulerKey-SchedulerRequestKey]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-5392. Replace use of Priority in the Scheduling infrastructure with an opaque ShedulerRequestKey. (asuresh and subru)\n",
          "commitDate": "26/07/16 2:54 PM",
          "commitName": "5aace38b748ba71aaadd2c4d64eba8dc1f816828",
          "commitAuthor": "Arun Suresh",
          "commitDateOld": "07/06/16 3:06 PM",
          "commitNameOld": "620325e81696fca140195b74929ed9eda2d5eb16",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 48.99,
          "commitsBetweenForRepo": 441,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,99 +1,99 @@\n   private ContainerAllocation preCheckForNewContainer(Resource clusterResource,\n       FiCaSchedulerNode node, SchedulingMode schedulingMode,\n-      ResourceLimits resourceLimits, Priority priority) {\n+      ResourceLimits resourceLimits, SchedulerRequestKey schedulerKey) {\n     if (SchedulerAppUtils.isPlaceBlacklisted(application, node, LOG)) {\n       application.updateAppSkipNodeDiagnostics(\n           CSAMContainerLaunchDiagnosticsConstants.SKIP_AM_ALLOCATION_IN_BLACK_LISTED_NODE);\n       return ContainerAllocation.APP_SKIPPED;\n     }\n \n     ResourceRequest anyRequest \u003d\n-        application.getResourceRequest(priority, ResourceRequest.ANY);\n+        application.getResourceRequest(schedulerKey, ResourceRequest.ANY);\n     if (null \u003d\u003d anyRequest) {\n       return ContainerAllocation.PRIORITY_SKIPPED;\n     }\n \n     // Required resource\n     Resource required \u003d anyRequest.getCapability();\n \n     // Do we need containers at this \u0027priority\u0027?\n-    if (application.getTotalRequiredResources(priority) \u003c\u003d 0) {\n+    if (application.getTotalRequiredResources(schedulerKey) \u003c\u003d 0) {\n       return ContainerAllocation.PRIORITY_SKIPPED;\n     }\n \n     // AM container allocation doesn\u0027t support non-exclusive allocation to\n     // avoid painful of preempt an AM container\n     if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n       if (application.isWaitingForAMContainer()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Skip allocating AM container to app_attempt\u003d\"\n               + application.getApplicationAttemptId()\n               + \", don\u0027t allow to allocate AM container in non-exclusive mode\");\n         }\n         application.updateAppSkipNodeDiagnostics(\n             \"Skipping assigning to Node in Ignore Exclusivity mode. \");\n         return ContainerAllocation.APP_SKIPPED;\n       }\n     }\n \n     // Is the node-label-expression of this offswitch resource request\n     // matches the node\u0027s label?\n     // If not match, jump to next priority.\n     if (!SchedulerUtils.checkResourceRequestMatchingNodePartition(\n         anyRequest.getNodeLabelExpression(), node.getPartition(),\n         schedulingMode)) {\n       return ContainerAllocation.PRIORITY_SKIPPED;\n     }\n \n     if (!application.getCSLeafQueue().getReservationContinueLooking()) {\n-      if (!shouldAllocOrReserveNewContainer(priority, required)) {\n+      if (!shouldAllocOrReserveNewContainer(schedulerKey, required)) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"doesn\u0027t need containers based on reservation algo!\");\n         }\n         return ContainerAllocation.PRIORITY_SKIPPED;\n       }\n     }\n \n     if (!checkHeadroom(clusterResource, resourceLimits, required, node)) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"cannot allocate required resource\u003d\" + required\n             + \" because of headroom\");\n       }\n       return ContainerAllocation.QUEUE_SKIPPED;\n     }\n \n     // Inform the application it is about to get a scheduling opportunity\n-    application.addSchedulingOpportunity(priority);\n+    application.addSchedulingOpportunity(schedulerKey);\n \n     // Increase missed-non-partitioned-resource-request-opportunity.\n     // This is to make sure non-partitioned-resource-request will prefer\n     // to be allocated to non-partitioned nodes\n     int missedNonPartitionedRequestSchedulingOpportunity \u003d 0;\n     if (anyRequest.getNodeLabelExpression()\n         .equals(RMNodeLabelsManager.NO_LABEL)) {\n       missedNonPartitionedRequestSchedulingOpportunity \u003d\n-          application\n-              .addMissedNonPartitionedRequestSchedulingOpportunity(priority);\n+          application.addMissedNonPartitionedRequestSchedulingOpportunity(\n+              schedulerKey);\n     }\n \n     if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n       // Before doing allocation, we need to check scheduling opportunity to\n       // make sure : non-partitioned resource request should be scheduled to\n       // non-partitioned partition first.\n       if (missedNonPartitionedRequestSchedulingOpportunity \u003c rmContext\n           .getScheduler().getNumClusterNodes()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Skip app_attempt\u003d\" + application.getApplicationAttemptId()\n-              + \" priority\u003d\" + priority\n+              + \" priority\u003d\" + schedulerKey.getPriority()\n               + \" because missed-non-partitioned-resource-request\"\n               + \" opportunity under requred:\" + \" Now\u003d\"\n               + missedNonPartitionedRequestSchedulingOpportunity + \" required\u003d\"\n               + rmContext.getScheduler().getNumClusterNodes());\n         }\n \n         return ContainerAllocation.APP_SKIPPED;\n       }\n     }\n     \n     return null;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private ContainerAllocation preCheckForNewContainer(Resource clusterResource,\n      FiCaSchedulerNode node, SchedulingMode schedulingMode,\n      ResourceLimits resourceLimits, SchedulerRequestKey schedulerKey) {\n    if (SchedulerAppUtils.isPlaceBlacklisted(application, node, LOG)) {\n      application.updateAppSkipNodeDiagnostics(\n          CSAMContainerLaunchDiagnosticsConstants.SKIP_AM_ALLOCATION_IN_BLACK_LISTED_NODE);\n      return ContainerAllocation.APP_SKIPPED;\n    }\n\n    ResourceRequest anyRequest \u003d\n        application.getResourceRequest(schedulerKey, ResourceRequest.ANY);\n    if (null \u003d\u003d anyRequest) {\n      return ContainerAllocation.PRIORITY_SKIPPED;\n    }\n\n    // Required resource\n    Resource required \u003d anyRequest.getCapability();\n\n    // Do we need containers at this \u0027priority\u0027?\n    if (application.getTotalRequiredResources(schedulerKey) \u003c\u003d 0) {\n      return ContainerAllocation.PRIORITY_SKIPPED;\n    }\n\n    // AM container allocation doesn\u0027t support non-exclusive allocation to\n    // avoid painful of preempt an AM container\n    if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n      if (application.isWaitingForAMContainer()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Skip allocating AM container to app_attempt\u003d\"\n              + application.getApplicationAttemptId()\n              + \", don\u0027t allow to allocate AM container in non-exclusive mode\");\n        }\n        application.updateAppSkipNodeDiagnostics(\n            \"Skipping assigning to Node in Ignore Exclusivity mode. \");\n        return ContainerAllocation.APP_SKIPPED;\n      }\n    }\n\n    // Is the node-label-expression of this offswitch resource request\n    // matches the node\u0027s label?\n    // If not match, jump to next priority.\n    if (!SchedulerUtils.checkResourceRequestMatchingNodePartition(\n        anyRequest.getNodeLabelExpression(), node.getPartition(),\n        schedulingMode)) {\n      return ContainerAllocation.PRIORITY_SKIPPED;\n    }\n\n    if (!application.getCSLeafQueue().getReservationContinueLooking()) {\n      if (!shouldAllocOrReserveNewContainer(schedulerKey, required)) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"doesn\u0027t need containers based on reservation algo!\");\n        }\n        return ContainerAllocation.PRIORITY_SKIPPED;\n      }\n    }\n\n    if (!checkHeadroom(clusterResource, resourceLimits, required, node)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"cannot allocate required resource\u003d\" + required\n            + \" because of headroom\");\n      }\n      return ContainerAllocation.QUEUE_SKIPPED;\n    }\n\n    // Inform the application it is about to get a scheduling opportunity\n    application.addSchedulingOpportunity(schedulerKey);\n\n    // Increase missed-non-partitioned-resource-request-opportunity.\n    // This is to make sure non-partitioned-resource-request will prefer\n    // to be allocated to non-partitioned nodes\n    int missedNonPartitionedRequestSchedulingOpportunity \u003d 0;\n    if (anyRequest.getNodeLabelExpression()\n        .equals(RMNodeLabelsManager.NO_LABEL)) {\n      missedNonPartitionedRequestSchedulingOpportunity \u003d\n          application.addMissedNonPartitionedRequestSchedulingOpportunity(\n              schedulerKey);\n    }\n\n    if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n      // Before doing allocation, we need to check scheduling opportunity to\n      // make sure : non-partitioned resource request should be scheduled to\n      // non-partitioned partition first.\n      if (missedNonPartitionedRequestSchedulingOpportunity \u003c rmContext\n          .getScheduler().getNumClusterNodes()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Skip app_attempt\u003d\" + application.getApplicationAttemptId()\n              + \" priority\u003d\" + schedulerKey.getPriority()\n              + \" because missed-non-partitioned-resource-request\"\n              + \" opportunity under requred:\" + \" Now\u003d\"\n              + missedNonPartitionedRequestSchedulingOpportunity + \" required\u003d\"\n              + rmContext.getScheduler().getNumClusterNodes());\n        }\n\n        return ContainerAllocation.APP_SKIPPED;\n      }\n    }\n    \n    return null;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/allocator/RegularContainerAllocator.java",
          "extendedDetails": {}
        }
      ]
    },
    "620325e81696fca140195b74929ed9eda2d5eb16": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4837. User facing aspects of \u0027AM blacklisting\u0027 feature need fixing. (vinodkv via wangda)\n",
      "commitDate": "07/06/16 3:06 PM",
      "commitName": "620325e81696fca140195b74929ed9eda2d5eb16",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "29/05/16 8:54 AM",
      "commitNameOld": "42f90ab885d9693fcc1e52f9637f7de4111110ae",
      "commitAuthorOld": "Varun Vasudev",
      "daysBetweenCommits": 9.26,
      "commitsBetweenForRepo": 57,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,99 +1,99 @@\n   private ContainerAllocation preCheckForNewContainer(Resource clusterResource,\n       FiCaSchedulerNode node, SchedulingMode schedulingMode,\n       ResourceLimits resourceLimits, Priority priority) {\n-    if (SchedulerAppUtils.isBlacklisted(application, node, LOG)) {\n+    if (SchedulerAppUtils.isPlaceBlacklisted(application, node, LOG)) {\n       application.updateAppSkipNodeDiagnostics(\n           CSAMContainerLaunchDiagnosticsConstants.SKIP_AM_ALLOCATION_IN_BLACK_LISTED_NODE);\n       return ContainerAllocation.APP_SKIPPED;\n     }\n \n     ResourceRequest anyRequest \u003d\n         application.getResourceRequest(priority, ResourceRequest.ANY);\n     if (null \u003d\u003d anyRequest) {\n       return ContainerAllocation.PRIORITY_SKIPPED;\n     }\n \n     // Required resource\n     Resource required \u003d anyRequest.getCapability();\n \n     // Do we need containers at this \u0027priority\u0027?\n     if (application.getTotalRequiredResources(priority) \u003c\u003d 0) {\n       return ContainerAllocation.PRIORITY_SKIPPED;\n     }\n \n     // AM container allocation doesn\u0027t support non-exclusive allocation to\n     // avoid painful of preempt an AM container\n     if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n       if (application.isWaitingForAMContainer()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Skip allocating AM container to app_attempt\u003d\"\n               + application.getApplicationAttemptId()\n               + \", don\u0027t allow to allocate AM container in non-exclusive mode\");\n         }\n         application.updateAppSkipNodeDiagnostics(\n             \"Skipping assigning to Node in Ignore Exclusivity mode. \");\n         return ContainerAllocation.APP_SKIPPED;\n       }\n     }\n \n     // Is the node-label-expression of this offswitch resource request\n     // matches the node\u0027s label?\n     // If not match, jump to next priority.\n     if (!SchedulerUtils.checkResourceRequestMatchingNodePartition(\n         anyRequest.getNodeLabelExpression(), node.getPartition(),\n         schedulingMode)) {\n       return ContainerAllocation.PRIORITY_SKIPPED;\n     }\n \n     if (!application.getCSLeafQueue().getReservationContinueLooking()) {\n       if (!shouldAllocOrReserveNewContainer(priority, required)) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"doesn\u0027t need containers based on reservation algo!\");\n         }\n         return ContainerAllocation.PRIORITY_SKIPPED;\n       }\n     }\n \n     if (!checkHeadroom(clusterResource, resourceLimits, required, node)) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"cannot allocate required resource\u003d\" + required\n             + \" because of headroom\");\n       }\n       return ContainerAllocation.QUEUE_SKIPPED;\n     }\n \n     // Inform the application it is about to get a scheduling opportunity\n     application.addSchedulingOpportunity(priority);\n \n     // Increase missed-non-partitioned-resource-request-opportunity.\n     // This is to make sure non-partitioned-resource-request will prefer\n     // to be allocated to non-partitioned nodes\n     int missedNonPartitionedRequestSchedulingOpportunity \u003d 0;\n     if (anyRequest.getNodeLabelExpression()\n         .equals(RMNodeLabelsManager.NO_LABEL)) {\n       missedNonPartitionedRequestSchedulingOpportunity \u003d\n           application\n               .addMissedNonPartitionedRequestSchedulingOpportunity(priority);\n     }\n \n     if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n       // Before doing allocation, we need to check scheduling opportunity to\n       // make sure : non-partitioned resource request should be scheduled to\n       // non-partitioned partition first.\n       if (missedNonPartitionedRequestSchedulingOpportunity \u003c rmContext\n           .getScheduler().getNumClusterNodes()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Skip app_attempt\u003d\" + application.getApplicationAttemptId()\n               + \" priority\u003d\" + priority\n               + \" because missed-non-partitioned-resource-request\"\n               + \" opportunity under requred:\" + \" Now\u003d\"\n               + missedNonPartitionedRequestSchedulingOpportunity + \" required\u003d\"\n               + rmContext.getScheduler().getNumClusterNodes());\n         }\n \n         return ContainerAllocation.APP_SKIPPED;\n       }\n     }\n     \n     return null;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private ContainerAllocation preCheckForNewContainer(Resource clusterResource,\n      FiCaSchedulerNode node, SchedulingMode schedulingMode,\n      ResourceLimits resourceLimits, Priority priority) {\n    if (SchedulerAppUtils.isPlaceBlacklisted(application, node, LOG)) {\n      application.updateAppSkipNodeDiagnostics(\n          CSAMContainerLaunchDiagnosticsConstants.SKIP_AM_ALLOCATION_IN_BLACK_LISTED_NODE);\n      return ContainerAllocation.APP_SKIPPED;\n    }\n\n    ResourceRequest anyRequest \u003d\n        application.getResourceRequest(priority, ResourceRequest.ANY);\n    if (null \u003d\u003d anyRequest) {\n      return ContainerAllocation.PRIORITY_SKIPPED;\n    }\n\n    // Required resource\n    Resource required \u003d anyRequest.getCapability();\n\n    // Do we need containers at this \u0027priority\u0027?\n    if (application.getTotalRequiredResources(priority) \u003c\u003d 0) {\n      return ContainerAllocation.PRIORITY_SKIPPED;\n    }\n\n    // AM container allocation doesn\u0027t support non-exclusive allocation to\n    // avoid painful of preempt an AM container\n    if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n      if (application.isWaitingForAMContainer()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Skip allocating AM container to app_attempt\u003d\"\n              + application.getApplicationAttemptId()\n              + \", don\u0027t allow to allocate AM container in non-exclusive mode\");\n        }\n        application.updateAppSkipNodeDiagnostics(\n            \"Skipping assigning to Node in Ignore Exclusivity mode. \");\n        return ContainerAllocation.APP_SKIPPED;\n      }\n    }\n\n    // Is the node-label-expression of this offswitch resource request\n    // matches the node\u0027s label?\n    // If not match, jump to next priority.\n    if (!SchedulerUtils.checkResourceRequestMatchingNodePartition(\n        anyRequest.getNodeLabelExpression(), node.getPartition(),\n        schedulingMode)) {\n      return ContainerAllocation.PRIORITY_SKIPPED;\n    }\n\n    if (!application.getCSLeafQueue().getReservationContinueLooking()) {\n      if (!shouldAllocOrReserveNewContainer(priority, required)) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"doesn\u0027t need containers based on reservation algo!\");\n        }\n        return ContainerAllocation.PRIORITY_SKIPPED;\n      }\n    }\n\n    if (!checkHeadroom(clusterResource, resourceLimits, required, node)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"cannot allocate required resource\u003d\" + required\n            + \" because of headroom\");\n      }\n      return ContainerAllocation.QUEUE_SKIPPED;\n    }\n\n    // Inform the application it is about to get a scheduling opportunity\n    application.addSchedulingOpportunity(priority);\n\n    // Increase missed-non-partitioned-resource-request-opportunity.\n    // This is to make sure non-partitioned-resource-request will prefer\n    // to be allocated to non-partitioned nodes\n    int missedNonPartitionedRequestSchedulingOpportunity \u003d 0;\n    if (anyRequest.getNodeLabelExpression()\n        .equals(RMNodeLabelsManager.NO_LABEL)) {\n      missedNonPartitionedRequestSchedulingOpportunity \u003d\n          application\n              .addMissedNonPartitionedRequestSchedulingOpportunity(priority);\n    }\n\n    if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n      // Before doing allocation, we need to check scheduling opportunity to\n      // make sure : non-partitioned resource request should be scheduled to\n      // non-partitioned partition first.\n      if (missedNonPartitionedRequestSchedulingOpportunity \u003c rmContext\n          .getScheduler().getNumClusterNodes()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Skip app_attempt\u003d\" + application.getApplicationAttemptId()\n              + \" priority\u003d\" + priority\n              + \" because missed-non-partitioned-resource-request\"\n              + \" opportunity under requred:\" + \" Now\u003d\"\n              + missedNonPartitionedRequestSchedulingOpportunity + \" required\u003d\"\n              + rmContext.getScheduler().getNumClusterNodes());\n        }\n\n        return ContainerAllocation.APP_SKIPPED;\n      }\n    }\n    \n    return null;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/allocator/RegularContainerAllocator.java",
      "extendedDetails": {}
    },
    "6cb0af3c39a5d49cb2f7911ee21363a9542ca2d7": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3946. Update exact reason as to why a submitted app is in ACCEPTED state to app\u0027s diagnostic message. (Naganarasimha G R via wangda)\n",
      "commitDate": "14/12/15 10:52 AM",
      "commitName": "6cb0af3c39a5d49cb2f7911ee21363a9542ca2d7",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "12/11/15 11:09 AM",
      "commitNameOld": "796638d9bc86235b9f3e5d1a3a9a25bbf5c04d1c",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 31.99,
      "commitsBetweenForRepo": 189,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,99 +1,99 @@\n   private ContainerAllocation preCheckForNewContainer(Resource clusterResource,\n       FiCaSchedulerNode node, SchedulingMode schedulingMode,\n       ResourceLimits resourceLimits, Priority priority) {\n     if (SchedulerAppUtils.isBlacklisted(application, node, LOG)) {\n+      application.updateAppSkipNodeDiagnostics(\n+          CSAMContainerLaunchDiagnosticsConstants.SKIP_AM_ALLOCATION_IN_BLACK_LISTED_NODE);\n       return ContainerAllocation.APP_SKIPPED;\n     }\n \n     ResourceRequest anyRequest \u003d\n         application.getResourceRequest(priority, ResourceRequest.ANY);\n     if (null \u003d\u003d anyRequest) {\n       return ContainerAllocation.PRIORITY_SKIPPED;\n     }\n \n     // Required resource\n     Resource required \u003d anyRequest.getCapability();\n \n     // Do we need containers at this \u0027priority\u0027?\n     if (application.getTotalRequiredResources(priority) \u003c\u003d 0) {\n       return ContainerAllocation.PRIORITY_SKIPPED;\n     }\n \n     // AM container allocation doesn\u0027t support non-exclusive allocation to\n     // avoid painful of preempt an AM container\n     if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n-      RMAppAttempt rmAppAttempt \u003d\n-          rmContext.getRMApps().get(application.getApplicationId())\n-              .getCurrentAppAttempt();\n-      if (rmAppAttempt.getSubmissionContext().getUnmanagedAM() \u003d\u003d false\n-          \u0026\u0026 null \u003d\u003d rmAppAttempt.getMasterContainer()) {\n+      if (application.isWaitingForAMContainer()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Skip allocating AM container to app_attempt\u003d\"\n               + application.getApplicationAttemptId()\n               + \", don\u0027t allow to allocate AM container in non-exclusive mode\");\n         }\n+        application.updateAppSkipNodeDiagnostics(\n+            \"Skipping assigning to Node in Ignore Exclusivity mode. \");\n         return ContainerAllocation.APP_SKIPPED;\n       }\n     }\n \n     // Is the node-label-expression of this offswitch resource request\n     // matches the node\u0027s label?\n     // If not match, jump to next priority.\n     if (!SchedulerUtils.checkResourceRequestMatchingNodePartition(\n         anyRequest.getNodeLabelExpression(), node.getPartition(),\n         schedulingMode)) {\n       return ContainerAllocation.PRIORITY_SKIPPED;\n     }\n \n     if (!application.getCSLeafQueue().getReservationContinueLooking()) {\n       if (!shouldAllocOrReserveNewContainer(priority, required)) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"doesn\u0027t need containers based on reservation algo!\");\n         }\n         return ContainerAllocation.PRIORITY_SKIPPED;\n       }\n     }\n \n     if (!checkHeadroom(clusterResource, resourceLimits, required, node)) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"cannot allocate required resource\u003d\" + required\n             + \" because of headroom\");\n       }\n       return ContainerAllocation.QUEUE_SKIPPED;\n     }\n \n     // Inform the application it is about to get a scheduling opportunity\n     application.addSchedulingOpportunity(priority);\n \n     // Increase missed-non-partitioned-resource-request-opportunity.\n     // This is to make sure non-partitioned-resource-request will prefer\n     // to be allocated to non-partitioned nodes\n     int missedNonPartitionedRequestSchedulingOpportunity \u003d 0;\n     if (anyRequest.getNodeLabelExpression()\n         .equals(RMNodeLabelsManager.NO_LABEL)) {\n       missedNonPartitionedRequestSchedulingOpportunity \u003d\n           application\n               .addMissedNonPartitionedRequestSchedulingOpportunity(priority);\n     }\n \n     if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n       // Before doing allocation, we need to check scheduling opportunity to\n       // make sure : non-partitioned resource request should be scheduled to\n       // non-partitioned partition first.\n       if (missedNonPartitionedRequestSchedulingOpportunity \u003c rmContext\n           .getScheduler().getNumClusterNodes()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Skip app_attempt\u003d\" + application.getApplicationAttemptId()\n               + \" priority\u003d\" + priority\n               + \" because missed-non-partitioned-resource-request\"\n               + \" opportunity under requred:\" + \" Now\u003d\"\n               + missedNonPartitionedRequestSchedulingOpportunity + \" required\u003d\"\n               + rmContext.getScheduler().getNumClusterNodes());\n         }\n \n         return ContainerAllocation.APP_SKIPPED;\n       }\n     }\n     \n     return null;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private ContainerAllocation preCheckForNewContainer(Resource clusterResource,\n      FiCaSchedulerNode node, SchedulingMode schedulingMode,\n      ResourceLimits resourceLimits, Priority priority) {\n    if (SchedulerAppUtils.isBlacklisted(application, node, LOG)) {\n      application.updateAppSkipNodeDiagnostics(\n          CSAMContainerLaunchDiagnosticsConstants.SKIP_AM_ALLOCATION_IN_BLACK_LISTED_NODE);\n      return ContainerAllocation.APP_SKIPPED;\n    }\n\n    ResourceRequest anyRequest \u003d\n        application.getResourceRequest(priority, ResourceRequest.ANY);\n    if (null \u003d\u003d anyRequest) {\n      return ContainerAllocation.PRIORITY_SKIPPED;\n    }\n\n    // Required resource\n    Resource required \u003d anyRequest.getCapability();\n\n    // Do we need containers at this \u0027priority\u0027?\n    if (application.getTotalRequiredResources(priority) \u003c\u003d 0) {\n      return ContainerAllocation.PRIORITY_SKIPPED;\n    }\n\n    // AM container allocation doesn\u0027t support non-exclusive allocation to\n    // avoid painful of preempt an AM container\n    if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n      if (application.isWaitingForAMContainer()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Skip allocating AM container to app_attempt\u003d\"\n              + application.getApplicationAttemptId()\n              + \", don\u0027t allow to allocate AM container in non-exclusive mode\");\n        }\n        application.updateAppSkipNodeDiagnostics(\n            \"Skipping assigning to Node in Ignore Exclusivity mode. \");\n        return ContainerAllocation.APP_SKIPPED;\n      }\n    }\n\n    // Is the node-label-expression of this offswitch resource request\n    // matches the node\u0027s label?\n    // If not match, jump to next priority.\n    if (!SchedulerUtils.checkResourceRequestMatchingNodePartition(\n        anyRequest.getNodeLabelExpression(), node.getPartition(),\n        schedulingMode)) {\n      return ContainerAllocation.PRIORITY_SKIPPED;\n    }\n\n    if (!application.getCSLeafQueue().getReservationContinueLooking()) {\n      if (!shouldAllocOrReserveNewContainer(priority, required)) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"doesn\u0027t need containers based on reservation algo!\");\n        }\n        return ContainerAllocation.PRIORITY_SKIPPED;\n      }\n    }\n\n    if (!checkHeadroom(clusterResource, resourceLimits, required, node)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"cannot allocate required resource\u003d\" + required\n            + \" because of headroom\");\n      }\n      return ContainerAllocation.QUEUE_SKIPPED;\n    }\n\n    // Inform the application it is about to get a scheduling opportunity\n    application.addSchedulingOpportunity(priority);\n\n    // Increase missed-non-partitioned-resource-request-opportunity.\n    // This is to make sure non-partitioned-resource-request will prefer\n    // to be allocated to non-partitioned nodes\n    int missedNonPartitionedRequestSchedulingOpportunity \u003d 0;\n    if (anyRequest.getNodeLabelExpression()\n        .equals(RMNodeLabelsManager.NO_LABEL)) {\n      missedNonPartitionedRequestSchedulingOpportunity \u003d\n          application\n              .addMissedNonPartitionedRequestSchedulingOpportunity(priority);\n    }\n\n    if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n      // Before doing allocation, we need to check scheduling opportunity to\n      // make sure : non-partitioned resource request should be scheduled to\n      // non-partitioned partition first.\n      if (missedNonPartitionedRequestSchedulingOpportunity \u003c rmContext\n          .getScheduler().getNumClusterNodes()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Skip app_attempt\u003d\" + application.getApplicationAttemptId()\n              + \" priority\u003d\" + priority\n              + \" because missed-non-partitioned-resource-request\"\n              + \" opportunity under requred:\" + \" Now\u003d\"\n              + missedNonPartitionedRequestSchedulingOpportunity + \" required\u003d\"\n              + rmContext.getScheduler().getNumClusterNodes());\n        }\n\n        return ContainerAllocation.APP_SKIPPED;\n      }\n    }\n    \n    return null;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/allocator/RegularContainerAllocator.java",
      "extendedDetails": {}
    },
    "89cab1ba5f0671f8ef30dbe7432079c18362b434": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1651. CapacityScheduler side changes to support container resize. Contributed by Wangda Tan\n",
      "commitDate": "23/09/15 1:29 PM",
      "commitName": "89cab1ba5f0671f8ef30dbe7432079c18362b434",
      "commitAuthor": "Jian He",
      "commitDateOld": "12/08/15 3:07 PM",
      "commitNameOld": "e5003be907acef87c2770e3f2914953f62017b0e",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 41.93,
      "commitsBetweenForRepo": 260,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,98 +1,99 @@\n   private ContainerAllocation preCheckForNewContainer(Resource clusterResource,\n       FiCaSchedulerNode node, SchedulingMode schedulingMode,\n       ResourceLimits resourceLimits, Priority priority) {\n     if (SchedulerAppUtils.isBlacklisted(application, node, LOG)) {\n       return ContainerAllocation.APP_SKIPPED;\n     }\n \n     ResourceRequest anyRequest \u003d\n         application.getResourceRequest(priority, ResourceRequest.ANY);\n     if (null \u003d\u003d anyRequest) {\n       return ContainerAllocation.PRIORITY_SKIPPED;\n     }\n \n     // Required resource\n     Resource required \u003d anyRequest.getCapability();\n \n     // Do we need containers at this \u0027priority\u0027?\n     if (application.getTotalRequiredResources(priority) \u003c\u003d 0) {\n       return ContainerAllocation.PRIORITY_SKIPPED;\n     }\n \n     // AM container allocation doesn\u0027t support non-exclusive allocation to\n     // avoid painful of preempt an AM container\n     if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n       RMAppAttempt rmAppAttempt \u003d\n           rmContext.getRMApps().get(application.getApplicationId())\n               .getCurrentAppAttempt();\n       if (rmAppAttempt.getSubmissionContext().getUnmanagedAM() \u003d\u003d false\n           \u0026\u0026 null \u003d\u003d rmAppAttempt.getMasterContainer()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Skip allocating AM container to app_attempt\u003d\"\n               + application.getApplicationAttemptId()\n               + \", don\u0027t allow to allocate AM container in non-exclusive mode\");\n         }\n         return ContainerAllocation.APP_SKIPPED;\n       }\n     }\n \n     // Is the node-label-expression of this offswitch resource request\n     // matches the node\u0027s label?\n     // If not match, jump to next priority.\n-    if (!SchedulerUtils.checkResourceRequestMatchingNodePartition(anyRequest,\n-        node.getPartition(), schedulingMode)) {\n+    if (!SchedulerUtils.checkResourceRequestMatchingNodePartition(\n+        anyRequest.getNodeLabelExpression(), node.getPartition(),\n+        schedulingMode)) {\n       return ContainerAllocation.PRIORITY_SKIPPED;\n     }\n \n     if (!application.getCSLeafQueue().getReservationContinueLooking()) {\n       if (!shouldAllocOrReserveNewContainer(priority, required)) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"doesn\u0027t need containers based on reservation algo!\");\n         }\n         return ContainerAllocation.PRIORITY_SKIPPED;\n       }\n     }\n \n     if (!checkHeadroom(clusterResource, resourceLimits, required, node)) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"cannot allocate required resource\u003d\" + required\n             + \" because of headroom\");\n       }\n       return ContainerAllocation.QUEUE_SKIPPED;\n     }\n \n     // Inform the application it is about to get a scheduling opportunity\n     application.addSchedulingOpportunity(priority);\n \n     // Increase missed-non-partitioned-resource-request-opportunity.\n     // This is to make sure non-partitioned-resource-request will prefer\n     // to be allocated to non-partitioned nodes\n     int missedNonPartitionedRequestSchedulingOpportunity \u003d 0;\n     if (anyRequest.getNodeLabelExpression()\n         .equals(RMNodeLabelsManager.NO_LABEL)) {\n       missedNonPartitionedRequestSchedulingOpportunity \u003d\n           application\n               .addMissedNonPartitionedRequestSchedulingOpportunity(priority);\n     }\n \n     if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n       // Before doing allocation, we need to check scheduling opportunity to\n       // make sure : non-partitioned resource request should be scheduled to\n       // non-partitioned partition first.\n       if (missedNonPartitionedRequestSchedulingOpportunity \u003c rmContext\n           .getScheduler().getNumClusterNodes()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Skip app_attempt\u003d\" + application.getApplicationAttemptId()\n               + \" priority\u003d\" + priority\n               + \" because missed-non-partitioned-resource-request\"\n               + \" opportunity under requred:\" + \" Now\u003d\"\n               + missedNonPartitionedRequestSchedulingOpportunity + \" required\u003d\"\n               + rmContext.getScheduler().getNumClusterNodes());\n         }\n \n         return ContainerAllocation.APP_SKIPPED;\n       }\n     }\n     \n     return null;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private ContainerAllocation preCheckForNewContainer(Resource clusterResource,\n      FiCaSchedulerNode node, SchedulingMode schedulingMode,\n      ResourceLimits resourceLimits, Priority priority) {\n    if (SchedulerAppUtils.isBlacklisted(application, node, LOG)) {\n      return ContainerAllocation.APP_SKIPPED;\n    }\n\n    ResourceRequest anyRequest \u003d\n        application.getResourceRequest(priority, ResourceRequest.ANY);\n    if (null \u003d\u003d anyRequest) {\n      return ContainerAllocation.PRIORITY_SKIPPED;\n    }\n\n    // Required resource\n    Resource required \u003d anyRequest.getCapability();\n\n    // Do we need containers at this \u0027priority\u0027?\n    if (application.getTotalRequiredResources(priority) \u003c\u003d 0) {\n      return ContainerAllocation.PRIORITY_SKIPPED;\n    }\n\n    // AM container allocation doesn\u0027t support non-exclusive allocation to\n    // avoid painful of preempt an AM container\n    if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n      RMAppAttempt rmAppAttempt \u003d\n          rmContext.getRMApps().get(application.getApplicationId())\n              .getCurrentAppAttempt();\n      if (rmAppAttempt.getSubmissionContext().getUnmanagedAM() \u003d\u003d false\n          \u0026\u0026 null \u003d\u003d rmAppAttempt.getMasterContainer()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Skip allocating AM container to app_attempt\u003d\"\n              + application.getApplicationAttemptId()\n              + \", don\u0027t allow to allocate AM container in non-exclusive mode\");\n        }\n        return ContainerAllocation.APP_SKIPPED;\n      }\n    }\n\n    // Is the node-label-expression of this offswitch resource request\n    // matches the node\u0027s label?\n    // If not match, jump to next priority.\n    if (!SchedulerUtils.checkResourceRequestMatchingNodePartition(\n        anyRequest.getNodeLabelExpression(), node.getPartition(),\n        schedulingMode)) {\n      return ContainerAllocation.PRIORITY_SKIPPED;\n    }\n\n    if (!application.getCSLeafQueue().getReservationContinueLooking()) {\n      if (!shouldAllocOrReserveNewContainer(priority, required)) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"doesn\u0027t need containers based on reservation algo!\");\n        }\n        return ContainerAllocation.PRIORITY_SKIPPED;\n      }\n    }\n\n    if (!checkHeadroom(clusterResource, resourceLimits, required, node)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"cannot allocate required resource\u003d\" + required\n            + \" because of headroom\");\n      }\n      return ContainerAllocation.QUEUE_SKIPPED;\n    }\n\n    // Inform the application it is about to get a scheduling opportunity\n    application.addSchedulingOpportunity(priority);\n\n    // Increase missed-non-partitioned-resource-request-opportunity.\n    // This is to make sure non-partitioned-resource-request will prefer\n    // to be allocated to non-partitioned nodes\n    int missedNonPartitionedRequestSchedulingOpportunity \u003d 0;\n    if (anyRequest.getNodeLabelExpression()\n        .equals(RMNodeLabelsManager.NO_LABEL)) {\n      missedNonPartitionedRequestSchedulingOpportunity \u003d\n          application\n              .addMissedNonPartitionedRequestSchedulingOpportunity(priority);\n    }\n\n    if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n      // Before doing allocation, we need to check scheduling opportunity to\n      // make sure : non-partitioned resource request should be scheduled to\n      // non-partitioned partition first.\n      if (missedNonPartitionedRequestSchedulingOpportunity \u003c rmContext\n          .getScheduler().getNumClusterNodes()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Skip app_attempt\u003d\" + application.getApplicationAttemptId()\n              + \" priority\u003d\" + priority\n              + \" because missed-non-partitioned-resource-request\"\n              + \" opportunity under requred:\" + \" Now\u003d\"\n              + missedNonPartitionedRequestSchedulingOpportunity + \" required\u003d\"\n              + rmContext.getScheduler().getNumClusterNodes());\n        }\n\n        return ContainerAllocation.APP_SKIPPED;\n      }\n    }\n    \n    return null;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/allocator/RegularContainerAllocator.java",
      "extendedDetails": {}
    },
    "ba2313d6145a1234777938a747187373f4cd58d9": {
      "type": "Yintroduced",
      "commitMessage": "YARN-3983. Refactored CapacityScheduleri#FiCaSchedulerApp to easier extend container allocation logic. Contributed by Wangda Tan\n",
      "commitDate": "05/08/15 1:47 PM",
      "commitName": "ba2313d6145a1234777938a747187373f4cd58d9",
      "commitAuthor": "Jian He",
      "diff": "@@ -0,0 +1,98 @@\n+  private ContainerAllocation preCheckForNewContainer(Resource clusterResource,\n+      FiCaSchedulerNode node, SchedulingMode schedulingMode,\n+      ResourceLimits resourceLimits, Priority priority) {\n+    if (SchedulerAppUtils.isBlacklisted(application, node, LOG)) {\n+      return ContainerAllocation.APP_SKIPPED;\n+    }\n+\n+    ResourceRequest anyRequest \u003d\n+        application.getResourceRequest(priority, ResourceRequest.ANY);\n+    if (null \u003d\u003d anyRequest) {\n+      return ContainerAllocation.PRIORITY_SKIPPED;\n+    }\n+\n+    // Required resource\n+    Resource required \u003d anyRequest.getCapability();\n+\n+    // Do we need containers at this \u0027priority\u0027?\n+    if (application.getTotalRequiredResources(priority) \u003c\u003d 0) {\n+      return ContainerAllocation.PRIORITY_SKIPPED;\n+    }\n+\n+    // AM container allocation doesn\u0027t support non-exclusive allocation to\n+    // avoid painful of preempt an AM container\n+    if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n+      RMAppAttempt rmAppAttempt \u003d\n+          rmContext.getRMApps().get(application.getApplicationId())\n+              .getCurrentAppAttempt();\n+      if (rmAppAttempt.getSubmissionContext().getUnmanagedAM() \u003d\u003d false\n+          \u0026\u0026 null \u003d\u003d rmAppAttempt.getMasterContainer()) {\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"Skip allocating AM container to app_attempt\u003d\"\n+              + application.getApplicationAttemptId()\n+              + \", don\u0027t allow to allocate AM container in non-exclusive mode\");\n+        }\n+        return ContainerAllocation.APP_SKIPPED;\n+      }\n+    }\n+\n+    // Is the node-label-expression of this offswitch resource request\n+    // matches the node\u0027s label?\n+    // If not match, jump to next priority.\n+    if (!SchedulerUtils.checkResourceRequestMatchingNodePartition(anyRequest,\n+        node.getPartition(), schedulingMode)) {\n+      return ContainerAllocation.PRIORITY_SKIPPED;\n+    }\n+\n+    if (!application.getCSLeafQueue().getReservationContinueLooking()) {\n+      if (!shouldAllocOrReserveNewContainer(priority, required)) {\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"doesn\u0027t need containers based on reservation algo!\");\n+        }\n+        return ContainerAllocation.PRIORITY_SKIPPED;\n+      }\n+    }\n+\n+    if (!checkHeadroom(clusterResource, resourceLimits, required, node)) {\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"cannot allocate required resource\u003d\" + required\n+            + \" because of headroom\");\n+      }\n+      return ContainerAllocation.QUEUE_SKIPPED;\n+    }\n+\n+    // Inform the application it is about to get a scheduling opportunity\n+    application.addSchedulingOpportunity(priority);\n+\n+    // Increase missed-non-partitioned-resource-request-opportunity.\n+    // This is to make sure non-partitioned-resource-request will prefer\n+    // to be allocated to non-partitioned nodes\n+    int missedNonPartitionedRequestSchedulingOpportunity \u003d 0;\n+    if (anyRequest.getNodeLabelExpression()\n+        .equals(RMNodeLabelsManager.NO_LABEL)) {\n+      missedNonPartitionedRequestSchedulingOpportunity \u003d\n+          application\n+              .addMissedNonPartitionedRequestSchedulingOpportunity(priority);\n+    }\n+\n+    if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n+      // Before doing allocation, we need to check scheduling opportunity to\n+      // make sure : non-partitioned resource request should be scheduled to\n+      // non-partitioned partition first.\n+      if (missedNonPartitionedRequestSchedulingOpportunity \u003c rmContext\n+          .getScheduler().getNumClusterNodes()) {\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"Skip app_attempt\u003d\" + application.getApplicationAttemptId()\n+              + \" priority\u003d\" + priority\n+              + \" because missed-non-partitioned-resource-request\"\n+              + \" opportunity under requred:\" + \" Now\u003d\"\n+              + missedNonPartitionedRequestSchedulingOpportunity + \" required\u003d\"\n+              + rmContext.getScheduler().getNumClusterNodes());\n+        }\n+\n+        return ContainerAllocation.APP_SKIPPED;\n+      }\n+    }\n+    \n+    return null;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private ContainerAllocation preCheckForNewContainer(Resource clusterResource,\n      FiCaSchedulerNode node, SchedulingMode schedulingMode,\n      ResourceLimits resourceLimits, Priority priority) {\n    if (SchedulerAppUtils.isBlacklisted(application, node, LOG)) {\n      return ContainerAllocation.APP_SKIPPED;\n    }\n\n    ResourceRequest anyRequest \u003d\n        application.getResourceRequest(priority, ResourceRequest.ANY);\n    if (null \u003d\u003d anyRequest) {\n      return ContainerAllocation.PRIORITY_SKIPPED;\n    }\n\n    // Required resource\n    Resource required \u003d anyRequest.getCapability();\n\n    // Do we need containers at this \u0027priority\u0027?\n    if (application.getTotalRequiredResources(priority) \u003c\u003d 0) {\n      return ContainerAllocation.PRIORITY_SKIPPED;\n    }\n\n    // AM container allocation doesn\u0027t support non-exclusive allocation to\n    // avoid painful of preempt an AM container\n    if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n      RMAppAttempt rmAppAttempt \u003d\n          rmContext.getRMApps().get(application.getApplicationId())\n              .getCurrentAppAttempt();\n      if (rmAppAttempt.getSubmissionContext().getUnmanagedAM() \u003d\u003d false\n          \u0026\u0026 null \u003d\u003d rmAppAttempt.getMasterContainer()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Skip allocating AM container to app_attempt\u003d\"\n              + application.getApplicationAttemptId()\n              + \", don\u0027t allow to allocate AM container in non-exclusive mode\");\n        }\n        return ContainerAllocation.APP_SKIPPED;\n      }\n    }\n\n    // Is the node-label-expression of this offswitch resource request\n    // matches the node\u0027s label?\n    // If not match, jump to next priority.\n    if (!SchedulerUtils.checkResourceRequestMatchingNodePartition(anyRequest,\n        node.getPartition(), schedulingMode)) {\n      return ContainerAllocation.PRIORITY_SKIPPED;\n    }\n\n    if (!application.getCSLeafQueue().getReservationContinueLooking()) {\n      if (!shouldAllocOrReserveNewContainer(priority, required)) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"doesn\u0027t need containers based on reservation algo!\");\n        }\n        return ContainerAllocation.PRIORITY_SKIPPED;\n      }\n    }\n\n    if (!checkHeadroom(clusterResource, resourceLimits, required, node)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"cannot allocate required resource\u003d\" + required\n            + \" because of headroom\");\n      }\n      return ContainerAllocation.QUEUE_SKIPPED;\n    }\n\n    // Inform the application it is about to get a scheduling opportunity\n    application.addSchedulingOpportunity(priority);\n\n    // Increase missed-non-partitioned-resource-request-opportunity.\n    // This is to make sure non-partitioned-resource-request will prefer\n    // to be allocated to non-partitioned nodes\n    int missedNonPartitionedRequestSchedulingOpportunity \u003d 0;\n    if (anyRequest.getNodeLabelExpression()\n        .equals(RMNodeLabelsManager.NO_LABEL)) {\n      missedNonPartitionedRequestSchedulingOpportunity \u003d\n          application\n              .addMissedNonPartitionedRequestSchedulingOpportunity(priority);\n    }\n\n    if (schedulingMode \u003d\u003d SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n      // Before doing allocation, we need to check scheduling opportunity to\n      // make sure : non-partitioned resource request should be scheduled to\n      // non-partitioned partition first.\n      if (missedNonPartitionedRequestSchedulingOpportunity \u003c rmContext\n          .getScheduler().getNumClusterNodes()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Skip app_attempt\u003d\" + application.getApplicationAttemptId()\n              + \" priority\u003d\" + priority\n              + \" because missed-non-partitioned-resource-request\"\n              + \" opportunity under requred:\" + \" Now\u003d\"\n              + missedNonPartitionedRequestSchedulingOpportunity + \" required\u003d\"\n              + rmContext.getScheduler().getNumClusterNodes());\n        }\n\n        return ContainerAllocation.APP_SKIPPED;\n      }\n    }\n    \n    return null;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/allocator/RegularContainerAllocator.java"
    }
  }
}