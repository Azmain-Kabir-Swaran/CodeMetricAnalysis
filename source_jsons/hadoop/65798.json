{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "DynamoDBMetadataStore.java",
  "functionName": "innerDelete",
  "functionId": "innerDelete___path-Path(modifiers-final)__tombstone-boolean(modifiers-final)__ancestorState-AncestorState(modifiers-final)",
  "sourceFilePath": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
  "functionStartLine": 576,
  "functionEndLine": 621,
  "numCommitsSeen": 131,
  "timeTaken": 7420,
  "changeHistory": [
    "7b219778e05a50e33cca75d727e62783322b7f80",
    "c58e11bf521d746842ce16724211a2a0339d7b61",
    "b15ef7dc3d91c6d50fa515158104fba29f43e6b0",
    "e02eb24e0a9139418120027b694492e0738df20a",
    "f9cc9e162175444efe9d5b07ecb9a795f750ca3c",
    "d7c0a08a1c077752918a8cf1b4f1900ce2721899",
    "d7232857d8d1e10cdac171acdc931187e45fd6be",
    "de8b6ca5ef8614de6d6277b7617e27c788b0555c",
    "621b43e254afaff708cd6fc4698b29628f6abc33"
  ],
  "changeHistoryShort": {
    "7b219778e05a50e33cca75d727e62783322b7f80": "Ybodychange",
    "c58e11bf521d746842ce16724211a2a0339d7b61": "Yparameterchange",
    "b15ef7dc3d91c6d50fa515158104fba29f43e6b0": "Ymultichange(Yparameterchange,Ybodychange,Yparametermetachange)",
    "e02eb24e0a9139418120027b694492e0738df20a": "Ybodychange",
    "f9cc9e162175444efe9d5b07ecb9a795f750ca3c": "Ymultichange(Yparameterchange,Ybodychange)",
    "d7c0a08a1c077752918a8cf1b4f1900ce2721899": "Ybodychange",
    "d7232857d8d1e10cdac171acdc931187e45fd6be": "Ybodychange",
    "de8b6ca5ef8614de6d6277b7617e27c788b0555c": "Ymultichange(Ybodychange,Yparametermetachange)",
    "621b43e254afaff708cd6fc4698b29628f6abc33": "Yintroduced"
  },
  "changeHistoryDetails": {
    "7b219778e05a50e33cca75d727e62783322b7f80": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16433. S3Guard: Filter expired entries and tombstones when listing with MetadataStore.listChildren().\n\nContributed by Gabor Bota.\n\nThis pulls the tracking of the lastUpdated timestamp of metadata entries up from the DDB metastore into all s3guard stores, and then uses this to filter out expired tombstones from listings.\n\nChange-Id: I80f121236b49c75a024116f65a3ef29d3580b462\n",
      "commitDate": "24/07/19 10:11 AM",
      "commitName": "7b219778e05a50e33cca75d727e62783322b7f80",
      "commitAuthor": "Gabor Bota",
      "commitDateOld": "17/07/19 7:24 AM",
      "commitNameOld": "c58e11bf521d746842ce16724211a2a0339d7b61",
      "commitAuthorOld": "Gabor Bota",
      "daysBetweenCommits": 7.12,
      "commitsBetweenForRepo": 47,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,46 @@\n   private void innerDelete(final Path path,\n       final boolean tombstone,\n       final AncestorState ancestorState)\n       throws IOException {\n     checkPath(path);\n     LOG.debug(\"Deleting from table {} in region {}: {}\",\n         tableName, region, path);\n \n     // deleting nonexistent item consumes 1 write capacity; skip it\n     if (path.isRoot()) {\n       LOG.debug(\"Skip deleting root directory as it does not exist in table\");\n       return;\n     }\n     // the policy on whether repeating delete operations is based\n     // on that of S3A itself\n     boolean idempotent \u003d S3AFileSystem.DELETE_CONSIDERED_IDEMPOTENT;\n     if (tombstone) {\n       Preconditions.checkArgument(ttlTimeProvider !\u003d null, \"ttlTimeProvider \"\n           + \"must not be null\");\n-      final PathMetadata pmTombstone \u003d PathMetadata.tombstone(path);\n-      // update the last updated field of record when putting a tombstone\n-      pmTombstone.setLastUpdated(ttlTimeProvider.getNow());\n+      final PathMetadata pmTombstone \u003d PathMetadata.tombstone(path,\n+          ttlTimeProvider.getNow());\n       Item item \u003d PathMetadataDynamoDBTranslation.pathMetadataToItem(\n           new DDBPathMetadata(pmTombstone));\n       writeOp.retry(\n           \"Put tombstone\",\n           path.toString(),\n           idempotent,\n           () -\u003e {\n             logPut(ancestorState, item);\n             recordsWritten(1);\n             table.putItem(item);\n           });\n     } else {\n       PrimaryKey key \u003d pathToKey(path);\n       writeOp.retry(\n           \"Delete key\",\n           path.toString(),\n           idempotent,\n           () -\u003e {\n             // record the attempt so even on retry the counter goes up.\n             logDelete(ancestorState, key);\n             recordsDeleted(1);\n             table.deleteItem(key);\n           });\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void innerDelete(final Path path,\n      final boolean tombstone,\n      final AncestorState ancestorState)\n      throws IOException {\n    checkPath(path);\n    LOG.debug(\"Deleting from table {} in region {}: {}\",\n        tableName, region, path);\n\n    // deleting nonexistent item consumes 1 write capacity; skip it\n    if (path.isRoot()) {\n      LOG.debug(\"Skip deleting root directory as it does not exist in table\");\n      return;\n    }\n    // the policy on whether repeating delete operations is based\n    // on that of S3A itself\n    boolean idempotent \u003d S3AFileSystem.DELETE_CONSIDERED_IDEMPOTENT;\n    if (tombstone) {\n      Preconditions.checkArgument(ttlTimeProvider !\u003d null, \"ttlTimeProvider \"\n          + \"must not be null\");\n      final PathMetadata pmTombstone \u003d PathMetadata.tombstone(path,\n          ttlTimeProvider.getNow());\n      Item item \u003d PathMetadataDynamoDBTranslation.pathMetadataToItem(\n          new DDBPathMetadata(pmTombstone));\n      writeOp.retry(\n          \"Put tombstone\",\n          path.toString(),\n          idempotent,\n          () -\u003e {\n            logPut(ancestorState, item);\n            recordsWritten(1);\n            table.putItem(item);\n          });\n    } else {\n      PrimaryKey key \u003d pathToKey(path);\n      writeOp.retry(\n          \"Delete key\",\n          path.toString(),\n          idempotent,\n          () -\u003e {\n            // record the attempt so even on retry the counter goes up.\n            logDelete(ancestorState, key);\n            recordsDeleted(1);\n            table.deleteItem(key);\n          });\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
      "extendedDetails": {}
    },
    "c58e11bf521d746842ce16724211a2a0339d7b61": {
      "type": "Yparameterchange",
      "commitMessage": "HADOOP-16383. Pass ITtlTimeProvider instance in initialize method in MetadataStore interface.  Contributed by Gabor Bota. (#1009) \n\n\r\n",
      "commitDate": "17/07/19 7:24 AM",
      "commitName": "c58e11bf521d746842ce16724211a2a0339d7b61",
      "commitAuthor": "Gabor Bota",
      "commitDateOld": "12/07/19 5:02 AM",
      "commitNameOld": "b15ef7dc3d91c6d50fa515158104fba29f43e6b0",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 5.1,
      "commitsBetweenForRepo": 35,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,48 +1,47 @@\n   private void innerDelete(final Path path,\n       final boolean tombstone,\n-      final ITtlTimeProvider ttlTimeProvider,\n       final AncestorState ancestorState)\n       throws IOException {\n     checkPath(path);\n     LOG.debug(\"Deleting from table {} in region {}: {}\",\n         tableName, region, path);\n \n     // deleting nonexistent item consumes 1 write capacity; skip it\n     if (path.isRoot()) {\n       LOG.debug(\"Skip deleting root directory as it does not exist in table\");\n       return;\n     }\n     // the policy on whether repeating delete operations is based\n     // on that of S3A itself\n     boolean idempotent \u003d S3AFileSystem.DELETE_CONSIDERED_IDEMPOTENT;\n     if (tombstone) {\n       Preconditions.checkArgument(ttlTimeProvider !\u003d null, \"ttlTimeProvider \"\n           + \"must not be null\");\n       final PathMetadata pmTombstone \u003d PathMetadata.tombstone(path);\n       // update the last updated field of record when putting a tombstone\n       pmTombstone.setLastUpdated(ttlTimeProvider.getNow());\n       Item item \u003d PathMetadataDynamoDBTranslation.pathMetadataToItem(\n           new DDBPathMetadata(pmTombstone));\n       writeOp.retry(\n           \"Put tombstone\",\n           path.toString(),\n           idempotent,\n           () -\u003e {\n             logPut(ancestorState, item);\n             recordsWritten(1);\n             table.putItem(item);\n           });\n     } else {\n       PrimaryKey key \u003d pathToKey(path);\n       writeOp.retry(\n           \"Delete key\",\n           path.toString(),\n           idempotent,\n           () -\u003e {\n             // record the attempt so even on retry the counter goes up.\n             logDelete(ancestorState, key);\n             recordsDeleted(1);\n             table.deleteItem(key);\n           });\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void innerDelete(final Path path,\n      final boolean tombstone,\n      final AncestorState ancestorState)\n      throws IOException {\n    checkPath(path);\n    LOG.debug(\"Deleting from table {} in region {}: {}\",\n        tableName, region, path);\n\n    // deleting nonexistent item consumes 1 write capacity; skip it\n    if (path.isRoot()) {\n      LOG.debug(\"Skip deleting root directory as it does not exist in table\");\n      return;\n    }\n    // the policy on whether repeating delete operations is based\n    // on that of S3A itself\n    boolean idempotent \u003d S3AFileSystem.DELETE_CONSIDERED_IDEMPOTENT;\n    if (tombstone) {\n      Preconditions.checkArgument(ttlTimeProvider !\u003d null, \"ttlTimeProvider \"\n          + \"must not be null\");\n      final PathMetadata pmTombstone \u003d PathMetadata.tombstone(path);\n      // update the last updated field of record when putting a tombstone\n      pmTombstone.setLastUpdated(ttlTimeProvider.getNow());\n      Item item \u003d PathMetadataDynamoDBTranslation.pathMetadataToItem(\n          new DDBPathMetadata(pmTombstone));\n      writeOp.retry(\n          \"Put tombstone\",\n          path.toString(),\n          idempotent,\n          () -\u003e {\n            logPut(ancestorState, item);\n            recordsWritten(1);\n            table.putItem(item);\n          });\n    } else {\n      PrimaryKey key \u003d pathToKey(path);\n      writeOp.retry(\n          \"Delete key\",\n          path.toString(),\n          idempotent,\n          () -\u003e {\n            // record the attempt so even on retry the counter goes up.\n            logDelete(ancestorState, key);\n            recordsDeleted(1);\n            table.deleteItem(key);\n          });\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
      "extendedDetails": {
        "oldValue": "[path-Path(modifiers-final), tombstone-boolean(modifiers-final), ttlTimeProvider-ITtlTimeProvider(modifiers-final), ancestorState-AncestorState(modifiers-final)]",
        "newValue": "[path-Path(modifiers-final), tombstone-boolean(modifiers-final), ancestorState-AncestorState(modifiers-final)]"
      }
    },
    "b15ef7dc3d91c6d50fa515158104fba29f43e6b0": {
      "type": "Ymultichange(Yparameterchange,Ybodychange,Yparametermetachange)",
      "commitMessage": "HADOOP-16384: S3A: Avoid inconsistencies between DDB and S3.\n\nContributed by Steve Loughran\n\nContains\n\n- HADOOP-16397. Hadoop S3Guard Prune command to support a -tombstone option.\n- HADOOP-16406. ITestDynamoDBMetadataStore.testProvisionTable times out intermittently\n\nThis patch doesn\u0027t fix the underlying problem but it\n\n* changes some tests to clean up better\n* does a lot more in logging operations in against DDB, if enabled\n* adds an entry point to dump the state of the metastore and s3 tables (precursor to fsck)\n* adds a purge entry point to help clean up after a test run has got a store into a mess\n* s3guard prune command adds -tombstone option to only clear tombstones\n\nThe outcome is that tests should pass consistently and if problems occur we have better diagnostics.\n\nChange-Id: I3eca3f5529d7f6fec398c0ff0472919f08f054eb\n",
      "commitDate": "12/07/19 5:02 AM",
      "commitName": "b15ef7dc3d91c6d50fa515158104fba29f43e6b0",
      "commitAuthor": "Steve Loughran",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-16384: S3A: Avoid inconsistencies between DDB and S3.\n\nContributed by Steve Loughran\n\nContains\n\n- HADOOP-16397. Hadoop S3Guard Prune command to support a -tombstone option.\n- HADOOP-16406. ITestDynamoDBMetadataStore.testProvisionTable times out intermittently\n\nThis patch doesn\u0027t fix the underlying problem but it\n\n* changes some tests to clean up better\n* does a lot more in logging operations in against DDB, if enabled\n* adds an entry point to dump the state of the metastore and s3 tables (precursor to fsck)\n* adds a purge entry point to help clean up after a test run has got a store into a mess\n* s3guard prune command adds -tombstone option to only clear tombstones\n\nThe outcome is that tests should pass consistently and if problems occur we have better diagnostics.\n\nChange-Id: I3eca3f5529d7f6fec398c0ff0472919f08f054eb\n",
          "commitDate": "12/07/19 5:02 AM",
          "commitName": "b15ef7dc3d91c6d50fa515158104fba29f43e6b0",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "08/07/19 10:27 AM",
          "commitNameOld": "de6b7bc67ace7744adb0320ee7de79cf28259d2d",
          "commitAuthorOld": "Sean Mackrory",
          "daysBetweenCommits": 3.77,
          "commitsBetweenForRepo": 38,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,46 +1,48 @@\n-  private void innerDelete(final Path path, boolean tombstone,\n-      ITtlTimeProvider ttlTimeProvider)\n+  private void innerDelete(final Path path,\n+      final boolean tombstone,\n+      final ITtlTimeProvider ttlTimeProvider,\n+      final AncestorState ancestorState)\n       throws IOException {\n     checkPath(path);\n     LOG.debug(\"Deleting from table {} in region {}: {}\",\n         tableName, region, path);\n \n     // deleting nonexistent item consumes 1 write capacity; skip it\n     if (path.isRoot()) {\n       LOG.debug(\"Skip deleting root directory as it does not exist in table\");\n       return;\n     }\n     // the policy on whether repeating delete operations is based\n     // on that of S3A itself\n     boolean idempotent \u003d S3AFileSystem.DELETE_CONSIDERED_IDEMPOTENT;\n     if (tombstone) {\n       Preconditions.checkArgument(ttlTimeProvider !\u003d null, \"ttlTimeProvider \"\n           + \"must not be null\");\n       final PathMetadata pmTombstone \u003d PathMetadata.tombstone(path);\n       // update the last updated field of record when putting a tombstone\n       pmTombstone.setLastUpdated(ttlTimeProvider.getNow());\n       Item item \u003d PathMetadataDynamoDBTranslation.pathMetadataToItem(\n           new DDBPathMetadata(pmTombstone));\n       writeOp.retry(\n           \"Put tombstone\",\n           path.toString(),\n           idempotent,\n           () -\u003e {\n-            LOG.debug(\"Adding tombstone to {}\", path);\n+            logPut(ancestorState, item);\n             recordsWritten(1);\n             table.putItem(item);\n           });\n     } else {\n       PrimaryKey key \u003d pathToKey(path);\n       writeOp.retry(\n           \"Delete key\",\n           path.toString(),\n           idempotent,\n           () -\u003e {\n             // record the attempt so even on retry the counter goes up.\n-            LOG.debug(\"Delete key {}\", path);\n+            logDelete(ancestorState, key);\n             recordsDeleted(1);\n             table.deleteItem(key);\n           });\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void innerDelete(final Path path,\n      final boolean tombstone,\n      final ITtlTimeProvider ttlTimeProvider,\n      final AncestorState ancestorState)\n      throws IOException {\n    checkPath(path);\n    LOG.debug(\"Deleting from table {} in region {}: {}\",\n        tableName, region, path);\n\n    // deleting nonexistent item consumes 1 write capacity; skip it\n    if (path.isRoot()) {\n      LOG.debug(\"Skip deleting root directory as it does not exist in table\");\n      return;\n    }\n    // the policy on whether repeating delete operations is based\n    // on that of S3A itself\n    boolean idempotent \u003d S3AFileSystem.DELETE_CONSIDERED_IDEMPOTENT;\n    if (tombstone) {\n      Preconditions.checkArgument(ttlTimeProvider !\u003d null, \"ttlTimeProvider \"\n          + \"must not be null\");\n      final PathMetadata pmTombstone \u003d PathMetadata.tombstone(path);\n      // update the last updated field of record when putting a tombstone\n      pmTombstone.setLastUpdated(ttlTimeProvider.getNow());\n      Item item \u003d PathMetadataDynamoDBTranslation.pathMetadataToItem(\n          new DDBPathMetadata(pmTombstone));\n      writeOp.retry(\n          \"Put tombstone\",\n          path.toString(),\n          idempotent,\n          () -\u003e {\n            logPut(ancestorState, item);\n            recordsWritten(1);\n            table.putItem(item);\n          });\n    } else {\n      PrimaryKey key \u003d pathToKey(path);\n      writeOp.retry(\n          \"Delete key\",\n          path.toString(),\n          idempotent,\n          () -\u003e {\n            // record the attempt so even on retry the counter goes up.\n            logDelete(ancestorState, key);\n            recordsDeleted(1);\n            table.deleteItem(key);\n          });\n    }\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
          "extendedDetails": {
            "oldValue": "[path-Path(modifiers-final), tombstone-boolean, ttlTimeProvider-ITtlTimeProvider]",
            "newValue": "[path-Path(modifiers-final), tombstone-boolean(modifiers-final), ttlTimeProvider-ITtlTimeProvider(modifiers-final), ancestorState-AncestorState(modifiers-final)]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-16384: S3A: Avoid inconsistencies between DDB and S3.\n\nContributed by Steve Loughran\n\nContains\n\n- HADOOP-16397. Hadoop S3Guard Prune command to support a -tombstone option.\n- HADOOP-16406. ITestDynamoDBMetadataStore.testProvisionTable times out intermittently\n\nThis patch doesn\u0027t fix the underlying problem but it\n\n* changes some tests to clean up better\n* does a lot more in logging operations in against DDB, if enabled\n* adds an entry point to dump the state of the metastore and s3 tables (precursor to fsck)\n* adds a purge entry point to help clean up after a test run has got a store into a mess\n* s3guard prune command adds -tombstone option to only clear tombstones\n\nThe outcome is that tests should pass consistently and if problems occur we have better diagnostics.\n\nChange-Id: I3eca3f5529d7f6fec398c0ff0472919f08f054eb\n",
          "commitDate": "12/07/19 5:02 AM",
          "commitName": "b15ef7dc3d91c6d50fa515158104fba29f43e6b0",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "08/07/19 10:27 AM",
          "commitNameOld": "de6b7bc67ace7744adb0320ee7de79cf28259d2d",
          "commitAuthorOld": "Sean Mackrory",
          "daysBetweenCommits": 3.77,
          "commitsBetweenForRepo": 38,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,46 +1,48 @@\n-  private void innerDelete(final Path path, boolean tombstone,\n-      ITtlTimeProvider ttlTimeProvider)\n+  private void innerDelete(final Path path,\n+      final boolean tombstone,\n+      final ITtlTimeProvider ttlTimeProvider,\n+      final AncestorState ancestorState)\n       throws IOException {\n     checkPath(path);\n     LOG.debug(\"Deleting from table {} in region {}: {}\",\n         tableName, region, path);\n \n     // deleting nonexistent item consumes 1 write capacity; skip it\n     if (path.isRoot()) {\n       LOG.debug(\"Skip deleting root directory as it does not exist in table\");\n       return;\n     }\n     // the policy on whether repeating delete operations is based\n     // on that of S3A itself\n     boolean idempotent \u003d S3AFileSystem.DELETE_CONSIDERED_IDEMPOTENT;\n     if (tombstone) {\n       Preconditions.checkArgument(ttlTimeProvider !\u003d null, \"ttlTimeProvider \"\n           + \"must not be null\");\n       final PathMetadata pmTombstone \u003d PathMetadata.tombstone(path);\n       // update the last updated field of record when putting a tombstone\n       pmTombstone.setLastUpdated(ttlTimeProvider.getNow());\n       Item item \u003d PathMetadataDynamoDBTranslation.pathMetadataToItem(\n           new DDBPathMetadata(pmTombstone));\n       writeOp.retry(\n           \"Put tombstone\",\n           path.toString(),\n           idempotent,\n           () -\u003e {\n-            LOG.debug(\"Adding tombstone to {}\", path);\n+            logPut(ancestorState, item);\n             recordsWritten(1);\n             table.putItem(item);\n           });\n     } else {\n       PrimaryKey key \u003d pathToKey(path);\n       writeOp.retry(\n           \"Delete key\",\n           path.toString(),\n           idempotent,\n           () -\u003e {\n             // record the attempt so even on retry the counter goes up.\n-            LOG.debug(\"Delete key {}\", path);\n+            logDelete(ancestorState, key);\n             recordsDeleted(1);\n             table.deleteItem(key);\n           });\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void innerDelete(final Path path,\n      final boolean tombstone,\n      final ITtlTimeProvider ttlTimeProvider,\n      final AncestorState ancestorState)\n      throws IOException {\n    checkPath(path);\n    LOG.debug(\"Deleting from table {} in region {}: {}\",\n        tableName, region, path);\n\n    // deleting nonexistent item consumes 1 write capacity; skip it\n    if (path.isRoot()) {\n      LOG.debug(\"Skip deleting root directory as it does not exist in table\");\n      return;\n    }\n    // the policy on whether repeating delete operations is based\n    // on that of S3A itself\n    boolean idempotent \u003d S3AFileSystem.DELETE_CONSIDERED_IDEMPOTENT;\n    if (tombstone) {\n      Preconditions.checkArgument(ttlTimeProvider !\u003d null, \"ttlTimeProvider \"\n          + \"must not be null\");\n      final PathMetadata pmTombstone \u003d PathMetadata.tombstone(path);\n      // update the last updated field of record when putting a tombstone\n      pmTombstone.setLastUpdated(ttlTimeProvider.getNow());\n      Item item \u003d PathMetadataDynamoDBTranslation.pathMetadataToItem(\n          new DDBPathMetadata(pmTombstone));\n      writeOp.retry(\n          \"Put tombstone\",\n          path.toString(),\n          idempotent,\n          () -\u003e {\n            logPut(ancestorState, item);\n            recordsWritten(1);\n            table.putItem(item);\n          });\n    } else {\n      PrimaryKey key \u003d pathToKey(path);\n      writeOp.retry(\n          \"Delete key\",\n          path.toString(),\n          idempotent,\n          () -\u003e {\n            // record the attempt so even on retry the counter goes up.\n            logDelete(ancestorState, key);\n            recordsDeleted(1);\n            table.deleteItem(key);\n          });\n    }\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
          "extendedDetails": {}
        },
        {
          "type": "Yparametermetachange",
          "commitMessage": "HADOOP-16384: S3A: Avoid inconsistencies between DDB and S3.\n\nContributed by Steve Loughran\n\nContains\n\n- HADOOP-16397. Hadoop S3Guard Prune command to support a -tombstone option.\n- HADOOP-16406. ITestDynamoDBMetadataStore.testProvisionTable times out intermittently\n\nThis patch doesn\u0027t fix the underlying problem but it\n\n* changes some tests to clean up better\n* does a lot more in logging operations in against DDB, if enabled\n* adds an entry point to dump the state of the metastore and s3 tables (precursor to fsck)\n* adds a purge entry point to help clean up after a test run has got a store into a mess\n* s3guard prune command adds -tombstone option to only clear tombstones\n\nThe outcome is that tests should pass consistently and if problems occur we have better diagnostics.\n\nChange-Id: I3eca3f5529d7f6fec398c0ff0472919f08f054eb\n",
          "commitDate": "12/07/19 5:02 AM",
          "commitName": "b15ef7dc3d91c6d50fa515158104fba29f43e6b0",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "08/07/19 10:27 AM",
          "commitNameOld": "de6b7bc67ace7744adb0320ee7de79cf28259d2d",
          "commitAuthorOld": "Sean Mackrory",
          "daysBetweenCommits": 3.77,
          "commitsBetweenForRepo": 38,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,46 +1,48 @@\n-  private void innerDelete(final Path path, boolean tombstone,\n-      ITtlTimeProvider ttlTimeProvider)\n+  private void innerDelete(final Path path,\n+      final boolean tombstone,\n+      final ITtlTimeProvider ttlTimeProvider,\n+      final AncestorState ancestorState)\n       throws IOException {\n     checkPath(path);\n     LOG.debug(\"Deleting from table {} in region {}: {}\",\n         tableName, region, path);\n \n     // deleting nonexistent item consumes 1 write capacity; skip it\n     if (path.isRoot()) {\n       LOG.debug(\"Skip deleting root directory as it does not exist in table\");\n       return;\n     }\n     // the policy on whether repeating delete operations is based\n     // on that of S3A itself\n     boolean idempotent \u003d S3AFileSystem.DELETE_CONSIDERED_IDEMPOTENT;\n     if (tombstone) {\n       Preconditions.checkArgument(ttlTimeProvider !\u003d null, \"ttlTimeProvider \"\n           + \"must not be null\");\n       final PathMetadata pmTombstone \u003d PathMetadata.tombstone(path);\n       // update the last updated field of record when putting a tombstone\n       pmTombstone.setLastUpdated(ttlTimeProvider.getNow());\n       Item item \u003d PathMetadataDynamoDBTranslation.pathMetadataToItem(\n           new DDBPathMetadata(pmTombstone));\n       writeOp.retry(\n           \"Put tombstone\",\n           path.toString(),\n           idempotent,\n           () -\u003e {\n-            LOG.debug(\"Adding tombstone to {}\", path);\n+            logPut(ancestorState, item);\n             recordsWritten(1);\n             table.putItem(item);\n           });\n     } else {\n       PrimaryKey key \u003d pathToKey(path);\n       writeOp.retry(\n           \"Delete key\",\n           path.toString(),\n           idempotent,\n           () -\u003e {\n             // record the attempt so even on retry the counter goes up.\n-            LOG.debug(\"Delete key {}\", path);\n+            logDelete(ancestorState, key);\n             recordsDeleted(1);\n             table.deleteItem(key);\n           });\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void innerDelete(final Path path,\n      final boolean tombstone,\n      final ITtlTimeProvider ttlTimeProvider,\n      final AncestorState ancestorState)\n      throws IOException {\n    checkPath(path);\n    LOG.debug(\"Deleting from table {} in region {}: {}\",\n        tableName, region, path);\n\n    // deleting nonexistent item consumes 1 write capacity; skip it\n    if (path.isRoot()) {\n      LOG.debug(\"Skip deleting root directory as it does not exist in table\");\n      return;\n    }\n    // the policy on whether repeating delete operations is based\n    // on that of S3A itself\n    boolean idempotent \u003d S3AFileSystem.DELETE_CONSIDERED_IDEMPOTENT;\n    if (tombstone) {\n      Preconditions.checkArgument(ttlTimeProvider !\u003d null, \"ttlTimeProvider \"\n          + \"must not be null\");\n      final PathMetadata pmTombstone \u003d PathMetadata.tombstone(path);\n      // update the last updated field of record when putting a tombstone\n      pmTombstone.setLastUpdated(ttlTimeProvider.getNow());\n      Item item \u003d PathMetadataDynamoDBTranslation.pathMetadataToItem(\n          new DDBPathMetadata(pmTombstone));\n      writeOp.retry(\n          \"Put tombstone\",\n          path.toString(),\n          idempotent,\n          () -\u003e {\n            logPut(ancestorState, item);\n            recordsWritten(1);\n            table.putItem(item);\n          });\n    } else {\n      PrimaryKey key \u003d pathToKey(path);\n      writeOp.retry(\n          \"Delete key\",\n          path.toString(),\n          idempotent,\n          () -\u003e {\n            // record the attempt so even on retry the counter goes up.\n            logDelete(ancestorState, key);\n            recordsDeleted(1);\n            table.deleteItem(key);\n          });\n    }\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
          "extendedDetails": {
            "oldValue": "[path-Path(modifiers-final), tombstone-boolean, ttlTimeProvider-ITtlTimeProvider]",
            "newValue": "[path-Path(modifiers-final), tombstone-boolean(modifiers-final), ttlTimeProvider-ITtlTimeProvider(modifiers-final), ancestorState-AncestorState(modifiers-final)]"
          }
        }
      ]
    },
    "e02eb24e0a9139418120027b694492e0738df20a": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15183. S3Guard store becomes inconsistent after partial failure of rename.\n\nContributed by Steve Loughran.\n\nChange-Id: I825b0bc36be960475d2d259b1cdab45ae1bb78eb\n",
      "commitDate": "20/06/19 1:56 AM",
      "commitName": "e02eb24e0a9139418120027b694492e0738df20a",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "16/06/19 9:05 AM",
      "commitNameOld": "f9cc9e162175444efe9d5b07ecb9a795f750ca3c",
      "commitAuthorOld": "Gabor Bota",
      "daysBetweenCommits": 3.7,
      "commitsBetweenForRepo": 44,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,37 +1,46 @@\n   private void innerDelete(final Path path, boolean tombstone,\n       ITtlTimeProvider ttlTimeProvider)\n       throws IOException {\n     checkPath(path);\n     LOG.debug(\"Deleting from table {} in region {}: {}\",\n         tableName, region, path);\n \n     // deleting nonexistent item consumes 1 write capacity; skip it\n     if (path.isRoot()) {\n       LOG.debug(\"Skip deleting root directory as it does not exist in table\");\n       return;\n     }\n     // the policy on whether repeating delete operations is based\n     // on that of S3A itself\n     boolean idempotent \u003d S3AFileSystem.DELETE_CONSIDERED_IDEMPOTENT;\n     if (tombstone) {\n       Preconditions.checkArgument(ttlTimeProvider !\u003d null, \"ttlTimeProvider \"\n           + \"must not be null\");\n       final PathMetadata pmTombstone \u003d PathMetadata.tombstone(path);\n       // update the last updated field of record when putting a tombstone\n       pmTombstone.setLastUpdated(ttlTimeProvider.getNow());\n       Item item \u003d PathMetadataDynamoDBTranslation.pathMetadataToItem(\n           new DDBPathMetadata(pmTombstone));\n       writeOp.retry(\n           \"Put tombstone\",\n           path.toString(),\n           idempotent,\n-          () -\u003e table.putItem(item));\n+          () -\u003e {\n+            LOG.debug(\"Adding tombstone to {}\", path);\n+            recordsWritten(1);\n+            table.putItem(item);\n+          });\n     } else {\n       PrimaryKey key \u003d pathToKey(path);\n       writeOp.retry(\n           \"Delete key\",\n           path.toString(),\n           idempotent,\n-          () -\u003e table.deleteItem(key));\n+          () -\u003e {\n+            // record the attempt so even on retry the counter goes up.\n+            LOG.debug(\"Delete key {}\", path);\n+            recordsDeleted(1);\n+            table.deleteItem(key);\n+          });\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void innerDelete(final Path path, boolean tombstone,\n      ITtlTimeProvider ttlTimeProvider)\n      throws IOException {\n    checkPath(path);\n    LOG.debug(\"Deleting from table {} in region {}: {}\",\n        tableName, region, path);\n\n    // deleting nonexistent item consumes 1 write capacity; skip it\n    if (path.isRoot()) {\n      LOG.debug(\"Skip deleting root directory as it does not exist in table\");\n      return;\n    }\n    // the policy on whether repeating delete operations is based\n    // on that of S3A itself\n    boolean idempotent \u003d S3AFileSystem.DELETE_CONSIDERED_IDEMPOTENT;\n    if (tombstone) {\n      Preconditions.checkArgument(ttlTimeProvider !\u003d null, \"ttlTimeProvider \"\n          + \"must not be null\");\n      final PathMetadata pmTombstone \u003d PathMetadata.tombstone(path);\n      // update the last updated field of record when putting a tombstone\n      pmTombstone.setLastUpdated(ttlTimeProvider.getNow());\n      Item item \u003d PathMetadataDynamoDBTranslation.pathMetadataToItem(\n          new DDBPathMetadata(pmTombstone));\n      writeOp.retry(\n          \"Put tombstone\",\n          path.toString(),\n          idempotent,\n          () -\u003e {\n            LOG.debug(\"Adding tombstone to {}\", path);\n            recordsWritten(1);\n            table.putItem(item);\n          });\n    } else {\n      PrimaryKey key \u003d pathToKey(path);\n      writeOp.retry(\n          \"Delete key\",\n          path.toString(),\n          idempotent,\n          () -\u003e {\n            // record the attempt so even on retry the counter goes up.\n            LOG.debug(\"Delete key {}\", path);\n            recordsDeleted(1);\n            table.deleteItem(key);\n          });\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
      "extendedDetails": {}
    },
    "f9cc9e162175444efe9d5b07ecb9a795f750ca3c": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HADOOP-16279. S3Guard: Implement time-based (TTL) expiry for entries (and tombstones).\n\nContributed by Gabor Bota.\n\nChange-Id: I73a2d2861901dedfe7a0e783b310fbb95e7c1af9\n",
      "commitDate": "16/06/19 9:05 AM",
      "commitName": "f9cc9e162175444efe9d5b07ecb9a795f750ca3c",
      "commitAuthor": "Gabor Bota",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-16279. S3Guard: Implement time-based (TTL) expiry for entries (and tombstones).\n\nContributed by Gabor Bota.\n\nChange-Id: I73a2d2861901dedfe7a0e783b310fbb95e7c1af9\n",
          "commitDate": "16/06/19 9:05 AM",
          "commitName": "f9cc9e162175444efe9d5b07ecb9a795f750ca3c",
          "commitAuthor": "Gabor Bota",
          "commitDateOld": "07/06/19 10:26 AM",
          "commitNameOld": "4e38dafde4dce8cd8c368783a291e830f06e1def",
          "commitAuthorOld": "Steve Loughran",
          "daysBetweenCommits": 8.94,
          "commitsBetweenForRepo": 50,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,31 +1,37 @@\n-  private void innerDelete(final Path path, boolean tombstone)\n+  private void innerDelete(final Path path, boolean tombstone,\n+      ITtlTimeProvider ttlTimeProvider)\n       throws IOException {\n     checkPath(path);\n     LOG.debug(\"Deleting from table {} in region {}: {}\",\n         tableName, region, path);\n \n     // deleting nonexistent item consumes 1 write capacity; skip it\n     if (path.isRoot()) {\n       LOG.debug(\"Skip deleting root directory as it does not exist in table\");\n       return;\n     }\n     // the policy on whether repeating delete operations is based\n     // on that of S3A itself\n     boolean idempotent \u003d S3AFileSystem.DELETE_CONSIDERED_IDEMPOTENT;\n     if (tombstone) {\n+      Preconditions.checkArgument(ttlTimeProvider !\u003d null, \"ttlTimeProvider \"\n+          + \"must not be null\");\n+      final PathMetadata pmTombstone \u003d PathMetadata.tombstone(path);\n+      // update the last updated field of record when putting a tombstone\n+      pmTombstone.setLastUpdated(ttlTimeProvider.getNow());\n       Item item \u003d PathMetadataDynamoDBTranslation.pathMetadataToItem(\n-          new DDBPathMetadata(PathMetadata.tombstone(path)));\n+          new DDBPathMetadata(pmTombstone));\n       writeOp.retry(\n           \"Put tombstone\",\n           path.toString(),\n           idempotent,\n           () -\u003e table.putItem(item));\n     } else {\n       PrimaryKey key \u003d pathToKey(path);\n       writeOp.retry(\n           \"Delete key\",\n           path.toString(),\n           idempotent,\n           () -\u003e table.deleteItem(key));\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void innerDelete(final Path path, boolean tombstone,\n      ITtlTimeProvider ttlTimeProvider)\n      throws IOException {\n    checkPath(path);\n    LOG.debug(\"Deleting from table {} in region {}: {}\",\n        tableName, region, path);\n\n    // deleting nonexistent item consumes 1 write capacity; skip it\n    if (path.isRoot()) {\n      LOG.debug(\"Skip deleting root directory as it does not exist in table\");\n      return;\n    }\n    // the policy on whether repeating delete operations is based\n    // on that of S3A itself\n    boolean idempotent \u003d S3AFileSystem.DELETE_CONSIDERED_IDEMPOTENT;\n    if (tombstone) {\n      Preconditions.checkArgument(ttlTimeProvider !\u003d null, \"ttlTimeProvider \"\n          + \"must not be null\");\n      final PathMetadata pmTombstone \u003d PathMetadata.tombstone(path);\n      // update the last updated field of record when putting a tombstone\n      pmTombstone.setLastUpdated(ttlTimeProvider.getNow());\n      Item item \u003d PathMetadataDynamoDBTranslation.pathMetadataToItem(\n          new DDBPathMetadata(pmTombstone));\n      writeOp.retry(\n          \"Put tombstone\",\n          path.toString(),\n          idempotent,\n          () -\u003e table.putItem(item));\n    } else {\n      PrimaryKey key \u003d pathToKey(path);\n      writeOp.retry(\n          \"Delete key\",\n          path.toString(),\n          idempotent,\n          () -\u003e table.deleteItem(key));\n    }\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
          "extendedDetails": {
            "oldValue": "[path-Path(modifiers-final), tombstone-boolean]",
            "newValue": "[path-Path(modifiers-final), tombstone-boolean, ttlTimeProvider-ITtlTimeProvider]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-16279. S3Guard: Implement time-based (TTL) expiry for entries (and tombstones).\n\nContributed by Gabor Bota.\n\nChange-Id: I73a2d2861901dedfe7a0e783b310fbb95e7c1af9\n",
          "commitDate": "16/06/19 9:05 AM",
          "commitName": "f9cc9e162175444efe9d5b07ecb9a795f750ca3c",
          "commitAuthor": "Gabor Bota",
          "commitDateOld": "07/06/19 10:26 AM",
          "commitNameOld": "4e38dafde4dce8cd8c368783a291e830f06e1def",
          "commitAuthorOld": "Steve Loughran",
          "daysBetweenCommits": 8.94,
          "commitsBetweenForRepo": 50,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,31 +1,37 @@\n-  private void innerDelete(final Path path, boolean tombstone)\n+  private void innerDelete(final Path path, boolean tombstone,\n+      ITtlTimeProvider ttlTimeProvider)\n       throws IOException {\n     checkPath(path);\n     LOG.debug(\"Deleting from table {} in region {}: {}\",\n         tableName, region, path);\n \n     // deleting nonexistent item consumes 1 write capacity; skip it\n     if (path.isRoot()) {\n       LOG.debug(\"Skip deleting root directory as it does not exist in table\");\n       return;\n     }\n     // the policy on whether repeating delete operations is based\n     // on that of S3A itself\n     boolean idempotent \u003d S3AFileSystem.DELETE_CONSIDERED_IDEMPOTENT;\n     if (tombstone) {\n+      Preconditions.checkArgument(ttlTimeProvider !\u003d null, \"ttlTimeProvider \"\n+          + \"must not be null\");\n+      final PathMetadata pmTombstone \u003d PathMetadata.tombstone(path);\n+      // update the last updated field of record when putting a tombstone\n+      pmTombstone.setLastUpdated(ttlTimeProvider.getNow());\n       Item item \u003d PathMetadataDynamoDBTranslation.pathMetadataToItem(\n-          new DDBPathMetadata(PathMetadata.tombstone(path)));\n+          new DDBPathMetadata(pmTombstone));\n       writeOp.retry(\n           \"Put tombstone\",\n           path.toString(),\n           idempotent,\n           () -\u003e table.putItem(item));\n     } else {\n       PrimaryKey key \u003d pathToKey(path);\n       writeOp.retry(\n           \"Delete key\",\n           path.toString(),\n           idempotent,\n           () -\u003e table.deleteItem(key));\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void innerDelete(final Path path, boolean tombstone,\n      ITtlTimeProvider ttlTimeProvider)\n      throws IOException {\n    checkPath(path);\n    LOG.debug(\"Deleting from table {} in region {}: {}\",\n        tableName, region, path);\n\n    // deleting nonexistent item consumes 1 write capacity; skip it\n    if (path.isRoot()) {\n      LOG.debug(\"Skip deleting root directory as it does not exist in table\");\n      return;\n    }\n    // the policy on whether repeating delete operations is based\n    // on that of S3A itself\n    boolean idempotent \u003d S3AFileSystem.DELETE_CONSIDERED_IDEMPOTENT;\n    if (tombstone) {\n      Preconditions.checkArgument(ttlTimeProvider !\u003d null, \"ttlTimeProvider \"\n          + \"must not be null\");\n      final PathMetadata pmTombstone \u003d PathMetadata.tombstone(path);\n      // update the last updated field of record when putting a tombstone\n      pmTombstone.setLastUpdated(ttlTimeProvider.getNow());\n      Item item \u003d PathMetadataDynamoDBTranslation.pathMetadataToItem(\n          new DDBPathMetadata(pmTombstone));\n      writeOp.retry(\n          \"Put tombstone\",\n          path.toString(),\n          idempotent,\n          () -\u003e table.putItem(item));\n    } else {\n      PrimaryKey key \u003d pathToKey(path);\n      writeOp.retry(\n          \"Delete key\",\n          path.toString(),\n          idempotent,\n          () -\u003e table.deleteItem(key));\n    }\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
          "extendedDetails": {}
        }
      ]
    },
    "d7c0a08a1c077752918a8cf1b4f1900ce2721899": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15426 Make S3guard client resilient to DDB throttle events and network failures (Contributed by Steve Loughran)\n",
      "commitDate": "12/09/18 9:04 PM",
      "commitName": "d7c0a08a1c077752918a8cf1b4f1900ce2721899",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "12/09/18 4:36 PM",
      "commitNameOld": "d32a8d5d582725eb724b78f27310ad1efd33ed2a",
      "commitAuthorOld": "Aaron Fabbri",
      "daysBetweenCommits": 0.19,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,25 +1,31 @@\n   private void innerDelete(final Path path, boolean tombstone)\n       throws IOException {\n     checkPath(path);\n     LOG.debug(\"Deleting from table {} in region {}: {}\",\n         tableName, region, path);\n \n     // deleting nonexistent item consumes 1 write capacity; skip it\n     if (path.isRoot()) {\n       LOG.debug(\"Skip deleting root directory as it does not exist in table\");\n       return;\n     }\n     // the policy on whether repeating delete operations is based\n     // on that of S3A itself\n     boolean idempotent \u003d S3AFileSystem.DELETE_CONSIDERED_IDEMPOTENT;\n     if (tombstone) {\n       Item item \u003d PathMetadataDynamoDBTranslation.pathMetadataToItem(\n           new DDBPathMetadata(PathMetadata.tombstone(path)));\n-      invoker.retry(\"Put tombstone\", path.toString(), idempotent,\n+      writeOp.retry(\n+          \"Put tombstone\",\n+          path.toString(),\n+          idempotent,\n           () -\u003e table.putItem(item));\n     } else {\n       PrimaryKey key \u003d pathToKey(path);\n-      invoker.retry(\"Delete key\", path.toString(), idempotent,\n+      writeOp.retry(\n+          \"Delete key\",\n+          path.toString(),\n+          idempotent,\n           () -\u003e table.deleteItem(key));\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void innerDelete(final Path path, boolean tombstone)\n      throws IOException {\n    checkPath(path);\n    LOG.debug(\"Deleting from table {} in region {}: {}\",\n        tableName, region, path);\n\n    // deleting nonexistent item consumes 1 write capacity; skip it\n    if (path.isRoot()) {\n      LOG.debug(\"Skip deleting root directory as it does not exist in table\");\n      return;\n    }\n    // the policy on whether repeating delete operations is based\n    // on that of S3A itself\n    boolean idempotent \u003d S3AFileSystem.DELETE_CONSIDERED_IDEMPOTENT;\n    if (tombstone) {\n      Item item \u003d PathMetadataDynamoDBTranslation.pathMetadataToItem(\n          new DDBPathMetadata(PathMetadata.tombstone(path)));\n      writeOp.retry(\n          \"Put tombstone\",\n          path.toString(),\n          idempotent,\n          () -\u003e table.putItem(item));\n    } else {\n      PrimaryKey key \u003d pathToKey(path);\n      writeOp.retry(\n          \"Delete key\",\n          path.toString(),\n          idempotent,\n          () -\u003e table.deleteItem(key));\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
      "extendedDetails": {}
    },
    "d7232857d8d1e10cdac171acdc931187e45fd6be": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14154 Persist isAuthoritative bit in DynamoDBMetaStore (Contributed by Gabor Bota)\n",
      "commitDate": "17/08/18 10:15 AM",
      "commitName": "d7232857d8d1e10cdac171acdc931187e45fd6be",
      "commitAuthor": "Aaron Fabbri",
      "commitDateOld": "08/08/18 10:57 PM",
      "commitNameOld": "da9a39eed138210de29b59b90c449b28da1c04f9",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 8.47,
      "commitsBetweenForRepo": 126,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,25 +1,25 @@\n   private void innerDelete(final Path path, boolean tombstone)\n       throws IOException {\n     checkPath(path);\n     LOG.debug(\"Deleting from table {} in region {}: {}\",\n         tableName, region, path);\n \n     // deleting nonexistent item consumes 1 write capacity; skip it\n     if (path.isRoot()) {\n       LOG.debug(\"Skip deleting root directory as it does not exist in table\");\n       return;\n     }\n     // the policy on whether repeating delete operations is based\n     // on that of S3A itself\n     boolean idempotent \u003d S3AFileSystem.DELETE_CONSIDERED_IDEMPOTENT;\n     if (tombstone) {\n       Item item \u003d PathMetadataDynamoDBTranslation.pathMetadataToItem(\n-          PathMetadata.tombstone(path));\n+          new DDBPathMetadata(PathMetadata.tombstone(path)));\n       invoker.retry(\"Put tombstone\", path.toString(), idempotent,\n           () -\u003e table.putItem(item));\n     } else {\n       PrimaryKey key \u003d pathToKey(path);\n       invoker.retry(\"Delete key\", path.toString(), idempotent,\n           () -\u003e table.deleteItem(key));\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void innerDelete(final Path path, boolean tombstone)\n      throws IOException {\n    checkPath(path);\n    LOG.debug(\"Deleting from table {} in region {}: {}\",\n        tableName, region, path);\n\n    // deleting nonexistent item consumes 1 write capacity; skip it\n    if (path.isRoot()) {\n      LOG.debug(\"Skip deleting root directory as it does not exist in table\");\n      return;\n    }\n    // the policy on whether repeating delete operations is based\n    // on that of S3A itself\n    boolean idempotent \u003d S3AFileSystem.DELETE_CONSIDERED_IDEMPOTENT;\n    if (tombstone) {\n      Item item \u003d PathMetadataDynamoDBTranslation.pathMetadataToItem(\n          new DDBPathMetadata(PathMetadata.tombstone(path)));\n      invoker.retry(\"Put tombstone\", path.toString(), idempotent,\n          () -\u003e table.putItem(item));\n    } else {\n      PrimaryKey key \u003d pathToKey(path);\n      invoker.retry(\"Delete key\", path.toString(), idempotent,\n          () -\u003e table.deleteItem(key));\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
      "extendedDetails": {}
    },
    "de8b6ca5ef8614de6d6277b7617e27c788b0555c": {
      "type": "Ymultichange(Ybodychange,Yparametermetachange)",
      "commitMessage": "HADOOP-13786 Add S3A committer for zero-rename commits to S3 endpoints.\nContributed by Steve Loughran and Ryan Blue.\n",
      "commitDate": "22/11/17 7:28 AM",
      "commitName": "de8b6ca5ef8614de6d6277b7617e27c788b0555c",
      "commitAuthor": "Steve Loughran",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-13786 Add S3A committer for zero-rename commits to S3 endpoints.\nContributed by Steve Loughran and Ryan Blue.\n",
          "commitDate": "22/11/17 7:28 AM",
          "commitName": "de8b6ca5ef8614de6d6277b7617e27c788b0555c",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "25/09/17 3:59 PM",
          "commitNameOld": "47011d7dd300b0c74bb6cfe25b918c479d718f4f",
          "commitAuthorOld": "Aaron Fabbri",
          "daysBetweenCommits": 57.69,
          "commitsBetweenForRepo": 477,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,24 +1,25 @@\n-  private void innerDelete(Path path, boolean tombstone)\n+  private void innerDelete(final Path path, boolean tombstone)\n       throws IOException {\n-    path \u003d checkPath(path);\n+    checkPath(path);\n     LOG.debug(\"Deleting from table {} in region {}: {}\",\n         tableName, region, path);\n \n     // deleting nonexistent item consumes 1 write capacity; skip it\n     if (path.isRoot()) {\n       LOG.debug(\"Skip deleting root directory as it does not exist in table\");\n       return;\n     }\n-\n-    try {\n-      if (tombstone) {\n-        Item item \u003d PathMetadataDynamoDBTranslation.pathMetadataToItem(\n-            PathMetadata.tombstone(path));\n-        table.putItem(item);\n-      } else {\n-        table.deleteItem(pathToKey(path));\n-      }\n-    } catch (AmazonClientException e) {\n-      throw translateException(\"delete\", path, e);\n+    // the policy on whether repeating delete operations is based\n+    // on that of S3A itself\n+    boolean idempotent \u003d S3AFileSystem.DELETE_CONSIDERED_IDEMPOTENT;\n+    if (tombstone) {\n+      Item item \u003d PathMetadataDynamoDBTranslation.pathMetadataToItem(\n+          PathMetadata.tombstone(path));\n+      invoker.retry(\"Put tombstone\", path.toString(), idempotent,\n+          () -\u003e table.putItem(item));\n+    } else {\n+      PrimaryKey key \u003d pathToKey(path);\n+      invoker.retry(\"Delete key\", path.toString(), idempotent,\n+          () -\u003e table.deleteItem(key));\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void innerDelete(final Path path, boolean tombstone)\n      throws IOException {\n    checkPath(path);\n    LOG.debug(\"Deleting from table {} in region {}: {}\",\n        tableName, region, path);\n\n    // deleting nonexistent item consumes 1 write capacity; skip it\n    if (path.isRoot()) {\n      LOG.debug(\"Skip deleting root directory as it does not exist in table\");\n      return;\n    }\n    // the policy on whether repeating delete operations is based\n    // on that of S3A itself\n    boolean idempotent \u003d S3AFileSystem.DELETE_CONSIDERED_IDEMPOTENT;\n    if (tombstone) {\n      Item item \u003d PathMetadataDynamoDBTranslation.pathMetadataToItem(\n          PathMetadata.tombstone(path));\n      invoker.retry(\"Put tombstone\", path.toString(), idempotent,\n          () -\u003e table.putItem(item));\n    } else {\n      PrimaryKey key \u003d pathToKey(path);\n      invoker.retry(\"Delete key\", path.toString(), idempotent,\n          () -\u003e table.deleteItem(key));\n    }\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
          "extendedDetails": {}
        },
        {
          "type": "Yparametermetachange",
          "commitMessage": "HADOOP-13786 Add S3A committer for zero-rename commits to S3 endpoints.\nContributed by Steve Loughran and Ryan Blue.\n",
          "commitDate": "22/11/17 7:28 AM",
          "commitName": "de8b6ca5ef8614de6d6277b7617e27c788b0555c",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "25/09/17 3:59 PM",
          "commitNameOld": "47011d7dd300b0c74bb6cfe25b918c479d718f4f",
          "commitAuthorOld": "Aaron Fabbri",
          "daysBetweenCommits": 57.69,
          "commitsBetweenForRepo": 477,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,24 +1,25 @@\n-  private void innerDelete(Path path, boolean tombstone)\n+  private void innerDelete(final Path path, boolean tombstone)\n       throws IOException {\n-    path \u003d checkPath(path);\n+    checkPath(path);\n     LOG.debug(\"Deleting from table {} in region {}: {}\",\n         tableName, region, path);\n \n     // deleting nonexistent item consumes 1 write capacity; skip it\n     if (path.isRoot()) {\n       LOG.debug(\"Skip deleting root directory as it does not exist in table\");\n       return;\n     }\n-\n-    try {\n-      if (tombstone) {\n-        Item item \u003d PathMetadataDynamoDBTranslation.pathMetadataToItem(\n-            PathMetadata.tombstone(path));\n-        table.putItem(item);\n-      } else {\n-        table.deleteItem(pathToKey(path));\n-      }\n-    } catch (AmazonClientException e) {\n-      throw translateException(\"delete\", path, e);\n+    // the policy on whether repeating delete operations is based\n+    // on that of S3A itself\n+    boolean idempotent \u003d S3AFileSystem.DELETE_CONSIDERED_IDEMPOTENT;\n+    if (tombstone) {\n+      Item item \u003d PathMetadataDynamoDBTranslation.pathMetadataToItem(\n+          PathMetadata.tombstone(path));\n+      invoker.retry(\"Put tombstone\", path.toString(), idempotent,\n+          () -\u003e table.putItem(item));\n+    } else {\n+      PrimaryKey key \u003d pathToKey(path);\n+      invoker.retry(\"Delete key\", path.toString(), idempotent,\n+          () -\u003e table.deleteItem(key));\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void innerDelete(final Path path, boolean tombstone)\n      throws IOException {\n    checkPath(path);\n    LOG.debug(\"Deleting from table {} in region {}: {}\",\n        tableName, region, path);\n\n    // deleting nonexistent item consumes 1 write capacity; skip it\n    if (path.isRoot()) {\n      LOG.debug(\"Skip deleting root directory as it does not exist in table\");\n      return;\n    }\n    // the policy on whether repeating delete operations is based\n    // on that of S3A itself\n    boolean idempotent \u003d S3AFileSystem.DELETE_CONSIDERED_IDEMPOTENT;\n    if (tombstone) {\n      Item item \u003d PathMetadataDynamoDBTranslation.pathMetadataToItem(\n          PathMetadata.tombstone(path));\n      invoker.retry(\"Put tombstone\", path.toString(), idempotent,\n          () -\u003e table.putItem(item));\n    } else {\n      PrimaryKey key \u003d pathToKey(path);\n      invoker.retry(\"Delete key\", path.toString(), idempotent,\n          () -\u003e table.deleteItem(key));\n    }\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
          "extendedDetails": {
            "oldValue": "[path-Path, tombstone-boolean]",
            "newValue": "[path-Path(modifiers-final), tombstone-boolean]"
          }
        }
      ]
    },
    "621b43e254afaff708cd6fc4698b29628f6abc33": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-13345 HS3Guard: Improved Consistency for S3A.\nContributed by: Chris Nauroth, Aaron Fabbri, Mingliang Liu, Lei (Eddy) Xu,\nSean Mackrory, Steve Loughran and others.\n",
      "commitDate": "01/09/17 6:13 AM",
      "commitName": "621b43e254afaff708cd6fc4698b29628f6abc33",
      "commitAuthor": "Steve Loughran",
      "diff": "@@ -0,0 +1,24 @@\n+  private void innerDelete(Path path, boolean tombstone)\n+      throws IOException {\n+    path \u003d checkPath(path);\n+    LOG.debug(\"Deleting from table {} in region {}: {}\",\n+        tableName, region, path);\n+\n+    // deleting nonexistent item consumes 1 write capacity; skip it\n+    if (path.isRoot()) {\n+      LOG.debug(\"Skip deleting root directory as it does not exist in table\");\n+      return;\n+    }\n+\n+    try {\n+      if (tombstone) {\n+        Item item \u003d PathMetadataDynamoDBTranslation.pathMetadataToItem(\n+            PathMetadata.tombstone(path));\n+        table.putItem(item);\n+      } else {\n+        table.deleteItem(pathToKey(path));\n+      }\n+    } catch (AmazonClientException e) {\n+      throw translateException(\"delete\", path, e);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void innerDelete(Path path, boolean tombstone)\n      throws IOException {\n    path \u003d checkPath(path);\n    LOG.debug(\"Deleting from table {} in region {}: {}\",\n        tableName, region, path);\n\n    // deleting nonexistent item consumes 1 write capacity; skip it\n    if (path.isRoot()) {\n      LOG.debug(\"Skip deleting root directory as it does not exist in table\");\n      return;\n    }\n\n    try {\n      if (tombstone) {\n        Item item \u003d PathMetadataDynamoDBTranslation.pathMetadataToItem(\n            PathMetadata.tombstone(path));\n        table.putItem(item);\n      } else {\n        table.deleteItem(pathToKey(path));\n      }\n    } catch (AmazonClientException e) {\n      throw translateException(\"delete\", path, e);\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java"
    }
  }
}