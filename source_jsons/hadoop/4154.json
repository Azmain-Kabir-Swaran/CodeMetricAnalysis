{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ByteArrayManager.java",
  "functionName": "newByteArray",
  "functionId": "newByteArray___arrayLength-int(modifiers-final)",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/util/ByteArrayManager.java",
  "functionStartLine": 349,
  "functionEndLine": 381,
  "numCommitsSeen": 8,
  "timeTaken": 2423,
  "changeHistory": [
    "9614dea71a9700741388956044c5e6fde1754e28",
    "39285e6a1978ea5e53bdc1b0aef62421382124a8",
    "6ee0539ede78b640f01c5eac18ded161182a7835",
    "d5a9a3daa0224249221ffa7b8bd5751ab2feca56",
    "3aac4758b007a56e3d66998d457b2156effca528",
    "394ba94c5d2801fbc5d95c7872eeeede28eed1eb",
    "36ccf097a95eae0761de7b657752e4808a86c094"
  ],
  "changeHistoryShort": {
    "9614dea71a9700741388956044c5e6fde1754e28": "Ybodychange",
    "39285e6a1978ea5e53bdc1b0aef62421382124a8": "Ybodychange",
    "6ee0539ede78b640f01c5eac18ded161182a7835": "Ybodychange",
    "d5a9a3daa0224249221ffa7b8bd5751ab2feca56": "Ybodychange",
    "3aac4758b007a56e3d66998d457b2156effca528": "Ymultichange(Yfilerename,Ybodychange)",
    "394ba94c5d2801fbc5d95c7872eeeede28eed1eb": "Ybodychange",
    "36ccf097a95eae0761de7b657752e4808a86c094": "Yintroduced"
  },
  "changeHistoryDetails": {
    "9614dea71a9700741388956044c5e6fde1754e28": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9398. Make ByteArraryManager log message in one-line format.  Contributed by Mingliang Liu\n",
      "commitDate": "07/11/15 6:21 AM",
      "commitName": "9614dea71a9700741388956044c5e6fde1754e28",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "commitDateOld": "29/09/15 5:52 PM",
      "commitNameOld": "39285e6a1978ea5e53bdc1b0aef62421382124a8",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 38.56,
      "commitsBetweenForRepo": 320,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,25 +1,33 @@\n     public byte[] newByteArray(final int arrayLength)\n         throws InterruptedException {\n       Preconditions.checkArgument(arrayLength \u003e\u003d 0);\n-      LOG.debug(\"allocate({})\", arrayLength);\n+      if (LOG.isDebugEnabled()) {\n+        DEBUG_MESSAGE.get().append(\"allocate(\").append(arrayLength).append(\")\");\n+      }\n \n       final byte[] array;\n       if (arrayLength \u003d\u003d 0) {\n         array \u003d EMPTY_BYTE_ARRAY;\n       } else {\n         final int powerOfTwo \u003d arrayLength \u003c\u003d MIN_ARRAY_LENGTH?\n             MIN_ARRAY_LENGTH: leastPowerOfTwo(arrayLength);\n         final long count \u003d counters.get(powerOfTwo, true).increment();\n         final boolean aboveThreshold \u003d count \u003e conf.countThreshold;\n         // create a new manager only if the count is above threshold.\n         final FixedLengthManager manager \u003d\n             managers.get(powerOfTwo, aboveThreshold);\n \n-        LOG.debug(\": count\u003d{}, {}Threshold\", count,\n-            aboveThreshold ? \"above\" : \"below\");\n+        if (LOG.isDebugEnabled()) {\n+          DEBUG_MESSAGE.get().append(\": count\u003d\").append(count)\n+              .append(aboveThreshold? \", aboveThreshold\": \", belowThreshold\");\n+        }\n         array \u003d manager !\u003d null? manager.allocate(): new byte[powerOfTwo];\n       }\n \n-      LOG.debug(\", return byte[{}]\", array.length);\n+      if (LOG.isDebugEnabled()) {\n+        DEBUG_MESSAGE.get().append(\", return byte[\")\n+            .append(array.length).append(\"]\");\n+        logDebugMessage();\n+      }\n       return array;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public byte[] newByteArray(final int arrayLength)\n        throws InterruptedException {\n      Preconditions.checkArgument(arrayLength \u003e\u003d 0);\n      if (LOG.isDebugEnabled()) {\n        DEBUG_MESSAGE.get().append(\"allocate(\").append(arrayLength).append(\")\");\n      }\n\n      final byte[] array;\n      if (arrayLength \u003d\u003d 0) {\n        array \u003d EMPTY_BYTE_ARRAY;\n      } else {\n        final int powerOfTwo \u003d arrayLength \u003c\u003d MIN_ARRAY_LENGTH?\n            MIN_ARRAY_LENGTH: leastPowerOfTwo(arrayLength);\n        final long count \u003d counters.get(powerOfTwo, true).increment();\n        final boolean aboveThreshold \u003d count \u003e conf.countThreshold;\n        // create a new manager only if the count is above threshold.\n        final FixedLengthManager manager \u003d\n            managers.get(powerOfTwo, aboveThreshold);\n\n        if (LOG.isDebugEnabled()) {\n          DEBUG_MESSAGE.get().append(\": count\u003d\").append(count)\n              .append(aboveThreshold? \", aboveThreshold\": \", belowThreshold\");\n        }\n        array \u003d manager !\u003d null? manager.allocate(): new byte[powerOfTwo];\n      }\n\n      if (LOG.isDebugEnabled()) {\n        DEBUG_MESSAGE.get().append(\", return byte[\")\n            .append(array.length).append(\"]\");\n        logDebugMessage();\n      }\n      return array;\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/util/ByteArrayManager.java",
      "extendedDetails": {}
    },
    "39285e6a1978ea5e53bdc1b0aef62421382124a8": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8971. Remove guards when calling LOG.debug() and LOG.trace() in client package. Contributed by Mingliang Liu.\n",
      "commitDate": "29/09/15 5:52 PM",
      "commitName": "39285e6a1978ea5e53bdc1b0aef62421382124a8",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "29/09/15 5:51 PM",
      "commitNameOld": "6ee0539ede78b640f01c5eac18ded161182a7835",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,33 +1,25 @@\n     public byte[] newByteArray(final int arrayLength)\n         throws InterruptedException {\n       Preconditions.checkArgument(arrayLength \u003e\u003d 0);\n-      if (LOG.isDebugEnabled()) {\n-        DEBUG_MESSAGE.get().append(\"allocate(\").append(arrayLength).append(\")\");\n-      }\n+      LOG.debug(\"allocate({})\", arrayLength);\n \n       final byte[] array;\n       if (arrayLength \u003d\u003d 0) {\n         array \u003d EMPTY_BYTE_ARRAY;\n       } else {\n         final int powerOfTwo \u003d arrayLength \u003c\u003d MIN_ARRAY_LENGTH?\n             MIN_ARRAY_LENGTH: leastPowerOfTwo(arrayLength);\n         final long count \u003d counters.get(powerOfTwo, true).increment();\n         final boolean aboveThreshold \u003d count \u003e conf.countThreshold;\n         // create a new manager only if the count is above threshold.\n         final FixedLengthManager manager \u003d\n             managers.get(powerOfTwo, aboveThreshold);\n \n-        if (LOG.isDebugEnabled()) {\n-          DEBUG_MESSAGE.get().append(\": count\u003d\").append(count)\n-              .append(aboveThreshold? \", aboveThreshold\": \", belowThreshold\");\n-        }\n+        LOG.debug(\": count\u003d{}, {}Threshold\", count,\n+            aboveThreshold ? \"above\" : \"below\");\n         array \u003d manager !\u003d null? manager.allocate(): new byte[powerOfTwo];\n       }\n \n-      if (LOG.isDebugEnabled()) {\n-        DEBUG_MESSAGE.get().append(\", return byte[\")\n-            .append(array.length).append(\"]\");\n-        logDebugMessage();\n-      }\n+      LOG.debug(\", return byte[{}]\", array.length);\n       return array;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public byte[] newByteArray(final int arrayLength)\n        throws InterruptedException {\n      Preconditions.checkArgument(arrayLength \u003e\u003d 0);\n      LOG.debug(\"allocate({})\", arrayLength);\n\n      final byte[] array;\n      if (arrayLength \u003d\u003d 0) {\n        array \u003d EMPTY_BYTE_ARRAY;\n      } else {\n        final int powerOfTwo \u003d arrayLength \u003c\u003d MIN_ARRAY_LENGTH?\n            MIN_ARRAY_LENGTH: leastPowerOfTwo(arrayLength);\n        final long count \u003d counters.get(powerOfTwo, true).increment();\n        final boolean aboveThreshold \u003d count \u003e conf.countThreshold;\n        // create a new manager only if the count is above threshold.\n        final FixedLengthManager manager \u003d\n            managers.get(powerOfTwo, aboveThreshold);\n\n        LOG.debug(\": count\u003d{}, {}Threshold\", count,\n            aboveThreshold ? \"above\" : \"below\");\n        array \u003d manager !\u003d null? manager.allocate(): new byte[powerOfTwo];\n      }\n\n      LOG.debug(\", return byte[{}]\", array.length);\n      return array;\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/util/ByteArrayManager.java",
      "extendedDetails": {}
    },
    "6ee0539ede78b640f01c5eac18ded161182a7835": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HDFS-9170. Move libhdfs / fuse-dfs / libwebhdfs to hdfs-client. Contributed by Haohui Mai.\"\n\nThis reverts commit d5a9a3daa0224249221ffa7b8bd5751ab2feca56.\n",
      "commitDate": "29/09/15 5:51 PM",
      "commitName": "6ee0539ede78b640f01c5eac18ded161182a7835",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "29/09/15 5:48 PM",
      "commitNameOld": "d5a9a3daa0224249221ffa7b8bd5751ab2feca56",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,25 +1,33 @@\n     public byte[] newByteArray(final int arrayLength)\n         throws InterruptedException {\n       Preconditions.checkArgument(arrayLength \u003e\u003d 0);\n-      LOG.debug(\"allocate({})\", arrayLength);\n+      if (LOG.isDebugEnabled()) {\n+        DEBUG_MESSAGE.get().append(\"allocate(\").append(arrayLength).append(\")\");\n+      }\n \n       final byte[] array;\n       if (arrayLength \u003d\u003d 0) {\n         array \u003d EMPTY_BYTE_ARRAY;\n       } else {\n         final int powerOfTwo \u003d arrayLength \u003c\u003d MIN_ARRAY_LENGTH?\n             MIN_ARRAY_LENGTH: leastPowerOfTwo(arrayLength);\n         final long count \u003d counters.get(powerOfTwo, true).increment();\n         final boolean aboveThreshold \u003d count \u003e conf.countThreshold;\n         // create a new manager only if the count is above threshold.\n         final FixedLengthManager manager \u003d\n             managers.get(powerOfTwo, aboveThreshold);\n \n-        LOG.debug(\": count\u003d{}, {}Threshold\", count,\n-            aboveThreshold ? \"above\" : \"below\");\n+        if (LOG.isDebugEnabled()) {\n+          DEBUG_MESSAGE.get().append(\": count\u003d\").append(count)\n+              .append(aboveThreshold? \", aboveThreshold\": \", belowThreshold\");\n+        }\n         array \u003d manager !\u003d null? manager.allocate(): new byte[powerOfTwo];\n       }\n \n-      LOG.debug(\", return byte[{}]\", array.length);\n+      if (LOG.isDebugEnabled()) {\n+        DEBUG_MESSAGE.get().append(\", return byte[\")\n+            .append(array.length).append(\"]\");\n+        logDebugMessage();\n+      }\n       return array;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public byte[] newByteArray(final int arrayLength)\n        throws InterruptedException {\n      Preconditions.checkArgument(arrayLength \u003e\u003d 0);\n      if (LOG.isDebugEnabled()) {\n        DEBUG_MESSAGE.get().append(\"allocate(\").append(arrayLength).append(\")\");\n      }\n\n      final byte[] array;\n      if (arrayLength \u003d\u003d 0) {\n        array \u003d EMPTY_BYTE_ARRAY;\n      } else {\n        final int powerOfTwo \u003d arrayLength \u003c\u003d MIN_ARRAY_LENGTH?\n            MIN_ARRAY_LENGTH: leastPowerOfTwo(arrayLength);\n        final long count \u003d counters.get(powerOfTwo, true).increment();\n        final boolean aboveThreshold \u003d count \u003e conf.countThreshold;\n        // create a new manager only if the count is above threshold.\n        final FixedLengthManager manager \u003d\n            managers.get(powerOfTwo, aboveThreshold);\n\n        if (LOG.isDebugEnabled()) {\n          DEBUG_MESSAGE.get().append(\": count\u003d\").append(count)\n              .append(aboveThreshold? \", aboveThreshold\": \", belowThreshold\");\n        }\n        array \u003d manager !\u003d null? manager.allocate(): new byte[powerOfTwo];\n      }\n\n      if (LOG.isDebugEnabled()) {\n        DEBUG_MESSAGE.get().append(\", return byte[\")\n            .append(array.length).append(\"]\");\n        logDebugMessage();\n      }\n      return array;\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/util/ByteArrayManager.java",
      "extendedDetails": {}
    },
    "d5a9a3daa0224249221ffa7b8bd5751ab2feca56": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9170. Move libhdfs / fuse-dfs / libwebhdfs to hdfs-client. Contributed by Haohui Mai.\n",
      "commitDate": "29/09/15 5:48 PM",
      "commitName": "d5a9a3daa0224249221ffa7b8bd5751ab2feca56",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "19/08/15 11:28 AM",
      "commitNameOld": "3aac4758b007a56e3d66998d457b2156effca528",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 41.26,
      "commitsBetweenForRepo": 265,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,33 +1,25 @@\n     public byte[] newByteArray(final int arrayLength)\n         throws InterruptedException {\n       Preconditions.checkArgument(arrayLength \u003e\u003d 0);\n-      if (LOG.isDebugEnabled()) {\n-        DEBUG_MESSAGE.get().append(\"allocate(\").append(arrayLength).append(\")\");\n-      }\n+      LOG.debug(\"allocate({})\", arrayLength);\n \n       final byte[] array;\n       if (arrayLength \u003d\u003d 0) {\n         array \u003d EMPTY_BYTE_ARRAY;\n       } else {\n         final int powerOfTwo \u003d arrayLength \u003c\u003d MIN_ARRAY_LENGTH?\n             MIN_ARRAY_LENGTH: leastPowerOfTwo(arrayLength);\n         final long count \u003d counters.get(powerOfTwo, true).increment();\n         final boolean aboveThreshold \u003d count \u003e conf.countThreshold;\n         // create a new manager only if the count is above threshold.\n         final FixedLengthManager manager \u003d\n             managers.get(powerOfTwo, aboveThreshold);\n \n-        if (LOG.isDebugEnabled()) {\n-          DEBUG_MESSAGE.get().append(\": count\u003d\").append(count)\n-              .append(aboveThreshold? \", aboveThreshold\": \", belowThreshold\");\n-        }\n+        LOG.debug(\": count\u003d{}, {}Threshold\", count,\n+            aboveThreshold ? \"above\" : \"below\");\n         array \u003d manager !\u003d null? manager.allocate(): new byte[powerOfTwo];\n       }\n \n-      if (LOG.isDebugEnabled()) {\n-        DEBUG_MESSAGE.get().append(\", return byte[\")\n-            .append(array.length).append(\"]\");\n-        logDebugMessage();\n-      }\n+      LOG.debug(\", return byte[{}]\", array.length);\n       return array;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public byte[] newByteArray(final int arrayLength)\n        throws InterruptedException {\n      Preconditions.checkArgument(arrayLength \u003e\u003d 0);\n      LOG.debug(\"allocate({})\", arrayLength);\n\n      final byte[] array;\n      if (arrayLength \u003d\u003d 0) {\n        array \u003d EMPTY_BYTE_ARRAY;\n      } else {\n        final int powerOfTwo \u003d arrayLength \u003c\u003d MIN_ARRAY_LENGTH?\n            MIN_ARRAY_LENGTH: leastPowerOfTwo(arrayLength);\n        final long count \u003d counters.get(powerOfTwo, true).increment();\n        final boolean aboveThreshold \u003d count \u003e conf.countThreshold;\n        // create a new manager only if the count is above threshold.\n        final FixedLengthManager manager \u003d\n            managers.get(powerOfTwo, aboveThreshold);\n\n        LOG.debug(\": count\u003d{}, {}Threshold\", count,\n            aboveThreshold ? \"above\" : \"below\");\n        array \u003d manager !\u003d null? manager.allocate(): new byte[powerOfTwo];\n      }\n\n      LOG.debug(\", return byte[{}]\", array.length);\n      return array;\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/util/ByteArrayManager.java",
      "extendedDetails": {}
    },
    "3aac4758b007a56e3d66998d457b2156effca528": {
      "type": "Ymultichange(Yfilerename,Ybodychange)",
      "commitMessage": "HDFS-8803. Move DfsClientConf to hdfs-client. Contributed by Mingliang Liu.\n",
      "commitDate": "19/08/15 11:28 AM",
      "commitName": "3aac4758b007a56e3d66998d457b2156effca528",
      "commitAuthor": "Haohui Mai",
      "subchanges": [
        {
          "type": "Yfilerename",
          "commitMessage": "HDFS-8803. Move DfsClientConf to hdfs-client. Contributed by Mingliang Liu.\n",
          "commitDate": "19/08/15 11:28 AM",
          "commitName": "3aac4758b007a56e3d66998d457b2156effca528",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "19/08/15 10:36 AM",
          "commitNameOld": "f61120d964a609ae5eabeb5c4d6c9afe0a15cad8",
          "commitAuthorOld": "Jing Zhao",
          "daysBetweenCommits": 0.04,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,30 +1,33 @@\n-    public byte[] newByteArray(final int arrayLength) throws InterruptedException {\n+    public byte[] newByteArray(final int arrayLength)\n+        throws InterruptedException {\n       Preconditions.checkArgument(arrayLength \u003e\u003d 0);\n       if (LOG.isDebugEnabled()) {\n-        debugMessage.get().append(\"allocate(\").append(arrayLength).append(\")\");\n+        DEBUG_MESSAGE.get().append(\"allocate(\").append(arrayLength).append(\")\");\n       }\n-  \n+\n       final byte[] array;\n       if (arrayLength \u003d\u003d 0) {\n         array \u003d EMPTY_BYTE_ARRAY;\n       } else {\n         final int powerOfTwo \u003d arrayLength \u003c\u003d MIN_ARRAY_LENGTH?\n             MIN_ARRAY_LENGTH: leastPowerOfTwo(arrayLength);\n         final long count \u003d counters.get(powerOfTwo, true).increment();\n         final boolean aboveThreshold \u003d count \u003e conf.countThreshold;\n         // create a new manager only if the count is above threshold.\n-        final FixedLengthManager manager \u003d managers.get(powerOfTwo, aboveThreshold);\n-  \n+        final FixedLengthManager manager \u003d\n+            managers.get(powerOfTwo, aboveThreshold);\n+\n         if (LOG.isDebugEnabled()) {\n-          debugMessage.get().append(\": count\u003d\").append(count)\n+          DEBUG_MESSAGE.get().append(\": count\u003d\").append(count)\n               .append(aboveThreshold? \", aboveThreshold\": \", belowThreshold\");\n         }\n         array \u003d manager !\u003d null? manager.allocate(): new byte[powerOfTwo];\n       }\n-  \n+\n       if (LOG.isDebugEnabled()) {\n-        debugMessage.get().append(\", return byte[\").append(array.length).append(\"]\");\n+        DEBUG_MESSAGE.get().append(\", return byte[\")\n+            .append(array.length).append(\"]\");\n         logDebugMessage();\n       }\n       return array;\n     }\n\\ No newline at end of file\n",
          "actualSource": "    public byte[] newByteArray(final int arrayLength)\n        throws InterruptedException {\n      Preconditions.checkArgument(arrayLength \u003e\u003d 0);\n      if (LOG.isDebugEnabled()) {\n        DEBUG_MESSAGE.get().append(\"allocate(\").append(arrayLength).append(\")\");\n      }\n\n      final byte[] array;\n      if (arrayLength \u003d\u003d 0) {\n        array \u003d EMPTY_BYTE_ARRAY;\n      } else {\n        final int powerOfTwo \u003d arrayLength \u003c\u003d MIN_ARRAY_LENGTH?\n            MIN_ARRAY_LENGTH: leastPowerOfTwo(arrayLength);\n        final long count \u003d counters.get(powerOfTwo, true).increment();\n        final boolean aboveThreshold \u003d count \u003e conf.countThreshold;\n        // create a new manager only if the count is above threshold.\n        final FixedLengthManager manager \u003d\n            managers.get(powerOfTwo, aboveThreshold);\n\n        if (LOG.isDebugEnabled()) {\n          DEBUG_MESSAGE.get().append(\": count\u003d\").append(count)\n              .append(aboveThreshold? \", aboveThreshold\": \", belowThreshold\");\n        }\n        array \u003d manager !\u003d null? manager.allocate(): new byte[powerOfTwo];\n      }\n\n      if (LOG.isDebugEnabled()) {\n        DEBUG_MESSAGE.get().append(\", return byte[\")\n            .append(array.length).append(\"]\");\n        logDebugMessage();\n      }\n      return array;\n    }",
          "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/util/ByteArrayManager.java",
          "extendedDetails": {
            "oldPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/util/ByteArrayManager.java",
            "newPath": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/util/ByteArrayManager.java"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-8803. Move DfsClientConf to hdfs-client. Contributed by Mingliang Liu.\n",
          "commitDate": "19/08/15 11:28 AM",
          "commitName": "3aac4758b007a56e3d66998d457b2156effca528",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "19/08/15 10:36 AM",
          "commitNameOld": "f61120d964a609ae5eabeb5c4d6c9afe0a15cad8",
          "commitAuthorOld": "Jing Zhao",
          "daysBetweenCommits": 0.04,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,30 +1,33 @@\n-    public byte[] newByteArray(final int arrayLength) throws InterruptedException {\n+    public byte[] newByteArray(final int arrayLength)\n+        throws InterruptedException {\n       Preconditions.checkArgument(arrayLength \u003e\u003d 0);\n       if (LOG.isDebugEnabled()) {\n-        debugMessage.get().append(\"allocate(\").append(arrayLength).append(\")\");\n+        DEBUG_MESSAGE.get().append(\"allocate(\").append(arrayLength).append(\")\");\n       }\n-  \n+\n       final byte[] array;\n       if (arrayLength \u003d\u003d 0) {\n         array \u003d EMPTY_BYTE_ARRAY;\n       } else {\n         final int powerOfTwo \u003d arrayLength \u003c\u003d MIN_ARRAY_LENGTH?\n             MIN_ARRAY_LENGTH: leastPowerOfTwo(arrayLength);\n         final long count \u003d counters.get(powerOfTwo, true).increment();\n         final boolean aboveThreshold \u003d count \u003e conf.countThreshold;\n         // create a new manager only if the count is above threshold.\n-        final FixedLengthManager manager \u003d managers.get(powerOfTwo, aboveThreshold);\n-  \n+        final FixedLengthManager manager \u003d\n+            managers.get(powerOfTwo, aboveThreshold);\n+\n         if (LOG.isDebugEnabled()) {\n-          debugMessage.get().append(\": count\u003d\").append(count)\n+          DEBUG_MESSAGE.get().append(\": count\u003d\").append(count)\n               .append(aboveThreshold? \", aboveThreshold\": \", belowThreshold\");\n         }\n         array \u003d manager !\u003d null? manager.allocate(): new byte[powerOfTwo];\n       }\n-  \n+\n       if (LOG.isDebugEnabled()) {\n-        debugMessage.get().append(\", return byte[\").append(array.length).append(\"]\");\n+        DEBUG_MESSAGE.get().append(\", return byte[\")\n+            .append(array.length).append(\"]\");\n         logDebugMessage();\n       }\n       return array;\n     }\n\\ No newline at end of file\n",
          "actualSource": "    public byte[] newByteArray(final int arrayLength)\n        throws InterruptedException {\n      Preconditions.checkArgument(arrayLength \u003e\u003d 0);\n      if (LOG.isDebugEnabled()) {\n        DEBUG_MESSAGE.get().append(\"allocate(\").append(arrayLength).append(\")\");\n      }\n\n      final byte[] array;\n      if (arrayLength \u003d\u003d 0) {\n        array \u003d EMPTY_BYTE_ARRAY;\n      } else {\n        final int powerOfTwo \u003d arrayLength \u003c\u003d MIN_ARRAY_LENGTH?\n            MIN_ARRAY_LENGTH: leastPowerOfTwo(arrayLength);\n        final long count \u003d counters.get(powerOfTwo, true).increment();\n        final boolean aboveThreshold \u003d count \u003e conf.countThreshold;\n        // create a new manager only if the count is above threshold.\n        final FixedLengthManager manager \u003d\n            managers.get(powerOfTwo, aboveThreshold);\n\n        if (LOG.isDebugEnabled()) {\n          DEBUG_MESSAGE.get().append(\": count\u003d\").append(count)\n              .append(aboveThreshold? \", aboveThreshold\": \", belowThreshold\");\n        }\n        array \u003d manager !\u003d null? manager.allocate(): new byte[powerOfTwo];\n      }\n\n      if (LOG.isDebugEnabled()) {\n        DEBUG_MESSAGE.get().append(\", return byte[\")\n            .append(array.length).append(\"]\");\n        logDebugMessage();\n      }\n      return array;\n    }",
          "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/util/ByteArrayManager.java",
          "extendedDetails": {}
        }
      ]
    },
    "394ba94c5d2801fbc5d95c7872eeeede28eed1eb": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7358. Clients may get stuck waiting when using ByteArrayManager.\n",
      "commitDate": "13/11/14 12:28 PM",
      "commitName": "394ba94c5d2801fbc5d95c7872eeeede28eed1eb",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "commitDateOld": "01/11/14 11:22 AM",
      "commitNameOld": "36ccf097a95eae0761de7b657752e4808a86c094",
      "commitAuthorOld": "Tsz-Wo Nicholas Sze",
      "daysBetweenCommits": 12.09,
      "commitsBetweenForRepo": 129,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,28 +1,30 @@\n     public byte[] newByteArray(final int arrayLength) throws InterruptedException {\n+      Preconditions.checkArgument(arrayLength \u003e\u003d 0);\n       if (LOG.isDebugEnabled()) {\n         debugMessage.get().append(\"allocate(\").append(arrayLength).append(\")\");\n       }\n   \n       final byte[] array;\n       if (arrayLength \u003d\u003d 0) {\n         array \u003d EMPTY_BYTE_ARRAY;\n       } else {\n         final int powerOfTwo \u003d arrayLength \u003c\u003d MIN_ARRAY_LENGTH?\n             MIN_ARRAY_LENGTH: leastPowerOfTwo(arrayLength);\n         final long count \u003d counters.get(powerOfTwo, true).increment();\n         final boolean aboveThreshold \u003d count \u003e conf.countThreshold;\n         // create a new manager only if the count is above threshold.\n         final FixedLengthManager manager \u003d managers.get(powerOfTwo, aboveThreshold);\n   \n         if (LOG.isDebugEnabled()) {\n           debugMessage.get().append(\": count\u003d\").append(count)\n               .append(aboveThreshold? \", aboveThreshold\": \", belowThreshold\");\n         }\n         array \u003d manager !\u003d null? manager.allocate(): new byte[powerOfTwo];\n       }\n   \n       if (LOG.isDebugEnabled()) {\n+        debugMessage.get().append(\", return byte[\").append(array.length).append(\"]\");\n         logDebugMessage();\n       }\n       return array;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public byte[] newByteArray(final int arrayLength) throws InterruptedException {\n      Preconditions.checkArgument(arrayLength \u003e\u003d 0);\n      if (LOG.isDebugEnabled()) {\n        debugMessage.get().append(\"allocate(\").append(arrayLength).append(\")\");\n      }\n  \n      final byte[] array;\n      if (arrayLength \u003d\u003d 0) {\n        array \u003d EMPTY_BYTE_ARRAY;\n      } else {\n        final int powerOfTwo \u003d arrayLength \u003c\u003d MIN_ARRAY_LENGTH?\n            MIN_ARRAY_LENGTH: leastPowerOfTwo(arrayLength);\n        final long count \u003d counters.get(powerOfTwo, true).increment();\n        final boolean aboveThreshold \u003d count \u003e conf.countThreshold;\n        // create a new manager only if the count is above threshold.\n        final FixedLengthManager manager \u003d managers.get(powerOfTwo, aboveThreshold);\n  \n        if (LOG.isDebugEnabled()) {\n          debugMessage.get().append(\": count\u003d\").append(count)\n              .append(aboveThreshold? \", aboveThreshold\": \", belowThreshold\");\n        }\n        array \u003d manager !\u003d null? manager.allocate(): new byte[powerOfTwo];\n      }\n  \n      if (LOG.isDebugEnabled()) {\n        debugMessage.get().append(\", return byte[\").append(array.length).append(\"]\");\n        logDebugMessage();\n      }\n      return array;\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/util/ByteArrayManager.java",
      "extendedDetails": {}
    },
    "36ccf097a95eae0761de7b657752e4808a86c094": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-7276. Limit the number of byte arrays used by DFSOutputStream and provide a mechanism for recycling arrays.\n",
      "commitDate": "01/11/14 11:22 AM",
      "commitName": "36ccf097a95eae0761de7b657752e4808a86c094",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "diff": "@@ -0,0 +1,28 @@\n+    public byte[] newByteArray(final int arrayLength) throws InterruptedException {\n+      if (LOG.isDebugEnabled()) {\n+        debugMessage.get().append(\"allocate(\").append(arrayLength).append(\")\");\n+      }\n+  \n+      final byte[] array;\n+      if (arrayLength \u003d\u003d 0) {\n+        array \u003d EMPTY_BYTE_ARRAY;\n+      } else {\n+        final int powerOfTwo \u003d arrayLength \u003c\u003d MIN_ARRAY_LENGTH?\n+            MIN_ARRAY_LENGTH: leastPowerOfTwo(arrayLength);\n+        final long count \u003d counters.get(powerOfTwo, true).increment();\n+        final boolean aboveThreshold \u003d count \u003e conf.countThreshold;\n+        // create a new manager only if the count is above threshold.\n+        final FixedLengthManager manager \u003d managers.get(powerOfTwo, aboveThreshold);\n+  \n+        if (LOG.isDebugEnabled()) {\n+          debugMessage.get().append(\": count\u003d\").append(count)\n+              .append(aboveThreshold? \", aboveThreshold\": \", belowThreshold\");\n+        }\n+        array \u003d manager !\u003d null? manager.allocate(): new byte[powerOfTwo];\n+      }\n+  \n+      if (LOG.isDebugEnabled()) {\n+        logDebugMessage();\n+      }\n+      return array;\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    public byte[] newByteArray(final int arrayLength) throws InterruptedException {\n      if (LOG.isDebugEnabled()) {\n        debugMessage.get().append(\"allocate(\").append(arrayLength).append(\")\");\n      }\n  \n      final byte[] array;\n      if (arrayLength \u003d\u003d 0) {\n        array \u003d EMPTY_BYTE_ARRAY;\n      } else {\n        final int powerOfTwo \u003d arrayLength \u003c\u003d MIN_ARRAY_LENGTH?\n            MIN_ARRAY_LENGTH: leastPowerOfTwo(arrayLength);\n        final long count \u003d counters.get(powerOfTwo, true).increment();\n        final boolean aboveThreshold \u003d count \u003e conf.countThreshold;\n        // create a new manager only if the count is above threshold.\n        final FixedLengthManager manager \u003d managers.get(powerOfTwo, aboveThreshold);\n  \n        if (LOG.isDebugEnabled()) {\n          debugMessage.get().append(\": count\u003d\").append(count)\n              .append(aboveThreshold? \", aboveThreshold\": \", belowThreshold\");\n        }\n        array \u003d manager !\u003d null? manager.allocate(): new byte[powerOfTwo];\n      }\n  \n      if (LOG.isDebugEnabled()) {\n        logDebugMessage();\n      }\n      return array;\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/util/ByteArrayManager.java"
    }
  }
}