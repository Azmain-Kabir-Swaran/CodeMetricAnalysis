{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ProportionalCapacityPreemptionPolicy.java",
  "functionName": "init",
  "functionId": "init___config-Configuration__context-RMContext__sched-ResourceScheduler",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java",
  "functionStartLine": 158,
  "functionEndLine": 172,
  "numCommitsSeen": 99,
  "timeTaken": 6856,
  "changeHistory": [
    "e6ec02001fc4eed9eb51c8653d8f931135e49eda",
    "218588be773123404af4fd26eed5c9e3625feaa7",
    "0b7afc060c2024a882bd1934d0f722bfca731742",
    "cf0d0844d6ae25d537391edb9b65fca05d1848e6",
    "c583ab02c730be0a63d974039a78f2dc67dc2db6",
    "ce832059db077fa95922198b066a737ed4f609fe",
    "90dd3a8148468ac37a3f2173ad8d45e38bfcb0c9",
    "bb62e0592566b2fcae7136b30972aad2d3ac55b0",
    "60e4116bf1d00afed91010e57357fe54057e4e39",
    "0e4b06690ff51fbde3ab26f68fde8aeb32af69af",
    "d497f6ea2be559aa31ed76f37ae949dbfabe2a51",
    "0a2d3e717d9c42090a32ff177991a222a1e34132",
    "85f0efb68f9d1d9ee3466e3939c4fc2f985ccf61"
  ],
  "changeHistoryShort": {
    "e6ec02001fc4eed9eb51c8653d8f931135e49eda": "Ybodychange",
    "218588be773123404af4fd26eed5c9e3625feaa7": "Yparameterchange",
    "0b7afc060c2024a882bd1934d0f722bfca731742": "Ybodychange",
    "cf0d0844d6ae25d537391edb9b65fca05d1848e6": "Ybodychange",
    "c583ab02c730be0a63d974039a78f2dc67dc2db6": "Ybodychange",
    "ce832059db077fa95922198b066a737ed4f609fe": "Ybodychange",
    "90dd3a8148468ac37a3f2173ad8d45e38bfcb0c9": "Ybodychange",
    "bb62e0592566b2fcae7136b30972aad2d3ac55b0": "Ybodychange",
    "60e4116bf1d00afed91010e57357fe54057e4e39": "Ybodychange",
    "0e4b06690ff51fbde3ab26f68fde8aeb32af69af": "Ymultichange(Yparameterchange,Ybodychange)",
    "d497f6ea2be559aa31ed76f37ae949dbfabe2a51": "Ybodychange",
    "0a2d3e717d9c42090a32ff177991a222a1e34132": "Ybodychange",
    "85f0efb68f9d1d9ee3466e3939c4fc2f985ccf61": "Yintroduced"
  },
  "changeHistoryDetails": {
    "e6ec02001fc4eed9eb51c8653d8f931135e49eda": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7370: Preemption properties should be refreshable. Contrubted by Gergely Nov√°k.\n",
      "commitDate": "02/11/17 10:37 AM",
      "commitName": "e6ec02001fc4eed9eb51c8653d8f931135e49eda",
      "commitAuthor": "Eric Payne",
      "commitDateOld": "11/08/17 2:04 PM",
      "commitNameOld": "218588be773123404af4fd26eed5c9e3625feaa7",
      "commitAuthorOld": "Daniel Templeton",
      "daysBetweenCommits": 82.86,
      "commitsBetweenForRepo": 688,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,98 +1,15 @@\n   public void init(Configuration config, RMContext context,\n       ResourceScheduler sched) {\n     LOG.info(\"Preemption monitor:\" + this.getClass().getCanonicalName());\n     assert null \u003d\u003d scheduler : \"Unexpected duplicate call to init\";\n     if (!(sched instanceof CapacityScheduler)) {\n       throw new YarnRuntimeException(\"Class \" +\n           sched.getClass().getCanonicalName() + \" not instance of \" +\n           CapacityScheduler.class.getCanonicalName());\n     }\n     rmContext \u003d context;\n     scheduler \u003d (CapacityScheduler) sched;\n-    CapacitySchedulerConfiguration csConfig \u003d scheduler.getConfiguration();\n-\n-    maxIgnoredOverCapacity \u003d csConfig.getDouble(\n-        CapacitySchedulerConfiguration.PREEMPTION_MAX_IGNORED_OVER_CAPACITY,\n-        CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_MAX_IGNORED_OVER_CAPACITY);\n-\n-    naturalTerminationFactor \u003d csConfig.getDouble(\n-        CapacitySchedulerConfiguration.PREEMPTION_NATURAL_TERMINATION_FACTOR,\n-        CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_NATURAL_TERMINATION_FACTOR);\n-\n-    maxWaitTime \u003d csConfig.getLong(\n-        CapacitySchedulerConfiguration.PREEMPTION_WAIT_TIME_BEFORE_KILL,\n-        CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_WAIT_TIME_BEFORE_KILL);\n-\n-    monitoringInterval \u003d csConfig.getLong(\n-        CapacitySchedulerConfiguration.PREEMPTION_MONITORING_INTERVAL,\n-        CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_MONITORING_INTERVAL);\n-\n-    percentageClusterPreemptionAllowed \u003d csConfig.getFloat(\n-        CapacitySchedulerConfiguration.TOTAL_PREEMPTION_PER_ROUND,\n-        CapacitySchedulerConfiguration.DEFAULT_TOTAL_PREEMPTION_PER_ROUND);\n-\n-    observeOnly \u003d csConfig.getBoolean(\n-        CapacitySchedulerConfiguration.PREEMPTION_OBSERVE_ONLY,\n-        CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_OBSERVE_ONLY);\n-\n-    lazyPreempionEnabled \u003d csConfig.getBoolean(\n-        CapacitySchedulerConfiguration.LAZY_PREEMPTION_ENALBED,\n-        CapacitySchedulerConfiguration.DEFAULT_LAZY_PREEMPTION_ENABLED);\n-\n-    maxAllowableLimitForIntraQueuePreemption \u003d csConfig.getFloat(\n-        CapacitySchedulerConfiguration.\n-        INTRAQUEUE_PREEMPTION_MAX_ALLOWABLE_LIMIT,\n-        CapacitySchedulerConfiguration.\n-        DEFAULT_INTRAQUEUE_PREEMPTION_MAX_ALLOWABLE_LIMIT);\n-\n-    minimumThresholdForIntraQueuePreemption \u003d csConfig.getFloat(\n-        CapacitySchedulerConfiguration.\n-        INTRAQUEUE_PREEMPTION_MINIMUM_THRESHOLD,\n-        CapacitySchedulerConfiguration.\n-        DEFAULT_INTRAQUEUE_PREEMPTION_MINIMUM_THRESHOLD);\n-\n-    intraQueuePreemptionOrderPolicy \u003d IntraQueuePreemptionOrderPolicy\n-        .valueOf(csConfig\n-            .get(\n-                CapacitySchedulerConfiguration.INTRAQUEUE_PREEMPTION_ORDER_POLICY,\n-                CapacitySchedulerConfiguration.DEFAULT_INTRAQUEUE_PREEMPTION_ORDER_POLICY)\n-            .toUpperCase());\n-\n     rc \u003d scheduler.getResourceCalculator();\n     nlm \u003d scheduler.getRMContext().getNodeLabelManager();\n-\n-    // Do we need white queue-priority preemption policy?\n-    boolean isQueuePriorityPreemptionEnabled \u003d\n-        csConfig.getPUOrderingPolicyUnderUtilizedPreemptionEnabled();\n-    if (isQueuePriorityPreemptionEnabled) {\n-      candidatesSelectionPolicies.add(\n-          new QueuePriorityContainerCandidateSelector(this));\n-    }\n-\n-    // Do we need to specially consider reserved containers?\n-    boolean selectCandidatesForResevedContainers \u003d csConfig.getBoolean(\n-        CapacitySchedulerConfiguration.\n-        PREEMPTION_SELECT_CANDIDATES_FOR_RESERVED_CONTAINERS,\n-        CapacitySchedulerConfiguration.\n-        DEFAULT_PREEMPTION_SELECT_CANDIDATES_FOR_RESERVED_CONTAINERS);\n-    if (selectCandidatesForResevedContainers) {\n-      candidatesSelectionPolicies\n-          .add(new ReservedContainerCandidatesSelector(this));\n-    }\n-\n-    boolean additionalPreemptionBasedOnReservedResource \u003d csConfig.getBoolean(\n-        CapacitySchedulerConfiguration.ADDITIONAL_RESOURCE_BALANCE_BASED_ON_RESERVED_CONTAINERS,\n-        CapacitySchedulerConfiguration.DEFAULT_ADDITIONAL_RESOURCE_BALANCE_BASED_ON_RESERVED_CONTAINERS);\n-\n-    // initialize candidates preemption selection policies\n-    candidatesSelectionPolicies.add(new FifoCandidatesSelector(this,\n-        additionalPreemptionBasedOnReservedResource));\n-\n-    // Do we need to specially consider intra queue\n-    boolean isIntraQueuePreemptionEnabled \u003d csConfig.getBoolean(\n-        CapacitySchedulerConfiguration.INTRAQUEUE_PREEMPTION_ENABLED,\n-        CapacitySchedulerConfiguration.DEFAULT_INTRAQUEUE_PREEMPTION_ENABLED);\n-    if (isIntraQueuePreemptionEnabled) {\n-      candidatesSelectionPolicies.add(new IntraQueueCandidatesSelector(this));\n-    }\n+    updateConfigIfNeeded();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void init(Configuration config, RMContext context,\n      ResourceScheduler sched) {\n    LOG.info(\"Preemption monitor:\" + this.getClass().getCanonicalName());\n    assert null \u003d\u003d scheduler : \"Unexpected duplicate call to init\";\n    if (!(sched instanceof CapacityScheduler)) {\n      throw new YarnRuntimeException(\"Class \" +\n          sched.getClass().getCanonicalName() + \" not instance of \" +\n          CapacityScheduler.class.getCanonicalName());\n    }\n    rmContext \u003d context;\n    scheduler \u003d (CapacityScheduler) sched;\n    rc \u003d scheduler.getResourceCalculator();\n    nlm \u003d scheduler.getRMContext().getNodeLabelManager();\n    updateConfigIfNeeded();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java",
      "extendedDetails": {}
    },
    "218588be773123404af4fd26eed5c9e3625feaa7": {
      "type": "Yparameterchange",
      "commitMessage": "YARN-6952. Enable scheduling monitor in FS (Contributed by Yufei Gu via Daniel Templeton)\n",
      "commitDate": "11/08/17 2:04 PM",
      "commitName": "218588be773123404af4fd26eed5c9e3625feaa7",
      "commitAuthor": "Daniel Templeton",
      "commitDateOld": "17/07/17 11:19 PM",
      "commitNameOld": "0b7afc060c2024a882bd1934d0f722bfca731742",
      "commitAuthorOld": "Sunil G",
      "daysBetweenCommits": 24.61,
      "commitsBetweenForRepo": 204,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,98 +1,98 @@\n   public void init(Configuration config, RMContext context,\n-      PreemptableResourceScheduler sched) {\n+      ResourceScheduler sched) {\n     LOG.info(\"Preemption monitor:\" + this.getClass().getCanonicalName());\n     assert null \u003d\u003d scheduler : \"Unexpected duplicate call to init\";\n     if (!(sched instanceof CapacityScheduler)) {\n       throw new YarnRuntimeException(\"Class \" +\n           sched.getClass().getCanonicalName() + \" not instance of \" +\n           CapacityScheduler.class.getCanonicalName());\n     }\n     rmContext \u003d context;\n     scheduler \u003d (CapacityScheduler) sched;\n     CapacitySchedulerConfiguration csConfig \u003d scheduler.getConfiguration();\n \n     maxIgnoredOverCapacity \u003d csConfig.getDouble(\n         CapacitySchedulerConfiguration.PREEMPTION_MAX_IGNORED_OVER_CAPACITY,\n         CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_MAX_IGNORED_OVER_CAPACITY);\n \n     naturalTerminationFactor \u003d csConfig.getDouble(\n         CapacitySchedulerConfiguration.PREEMPTION_NATURAL_TERMINATION_FACTOR,\n         CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_NATURAL_TERMINATION_FACTOR);\n \n     maxWaitTime \u003d csConfig.getLong(\n         CapacitySchedulerConfiguration.PREEMPTION_WAIT_TIME_BEFORE_KILL,\n         CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_WAIT_TIME_BEFORE_KILL);\n \n     monitoringInterval \u003d csConfig.getLong(\n         CapacitySchedulerConfiguration.PREEMPTION_MONITORING_INTERVAL,\n         CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_MONITORING_INTERVAL);\n \n     percentageClusterPreemptionAllowed \u003d csConfig.getFloat(\n         CapacitySchedulerConfiguration.TOTAL_PREEMPTION_PER_ROUND,\n         CapacitySchedulerConfiguration.DEFAULT_TOTAL_PREEMPTION_PER_ROUND);\n \n     observeOnly \u003d csConfig.getBoolean(\n         CapacitySchedulerConfiguration.PREEMPTION_OBSERVE_ONLY,\n         CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_OBSERVE_ONLY);\n \n     lazyPreempionEnabled \u003d csConfig.getBoolean(\n         CapacitySchedulerConfiguration.LAZY_PREEMPTION_ENALBED,\n         CapacitySchedulerConfiguration.DEFAULT_LAZY_PREEMPTION_ENABLED);\n \n     maxAllowableLimitForIntraQueuePreemption \u003d csConfig.getFloat(\n         CapacitySchedulerConfiguration.\n         INTRAQUEUE_PREEMPTION_MAX_ALLOWABLE_LIMIT,\n         CapacitySchedulerConfiguration.\n         DEFAULT_INTRAQUEUE_PREEMPTION_MAX_ALLOWABLE_LIMIT);\n \n     minimumThresholdForIntraQueuePreemption \u003d csConfig.getFloat(\n         CapacitySchedulerConfiguration.\n         INTRAQUEUE_PREEMPTION_MINIMUM_THRESHOLD,\n         CapacitySchedulerConfiguration.\n         DEFAULT_INTRAQUEUE_PREEMPTION_MINIMUM_THRESHOLD);\n \n     intraQueuePreemptionOrderPolicy \u003d IntraQueuePreemptionOrderPolicy\n         .valueOf(csConfig\n             .get(\n                 CapacitySchedulerConfiguration.INTRAQUEUE_PREEMPTION_ORDER_POLICY,\n                 CapacitySchedulerConfiguration.DEFAULT_INTRAQUEUE_PREEMPTION_ORDER_POLICY)\n             .toUpperCase());\n \n     rc \u003d scheduler.getResourceCalculator();\n     nlm \u003d scheduler.getRMContext().getNodeLabelManager();\n \n     // Do we need white queue-priority preemption policy?\n     boolean isQueuePriorityPreemptionEnabled \u003d\n         csConfig.getPUOrderingPolicyUnderUtilizedPreemptionEnabled();\n     if (isQueuePriorityPreemptionEnabled) {\n       candidatesSelectionPolicies.add(\n           new QueuePriorityContainerCandidateSelector(this));\n     }\n \n     // Do we need to specially consider reserved containers?\n     boolean selectCandidatesForResevedContainers \u003d csConfig.getBoolean(\n         CapacitySchedulerConfiguration.\n         PREEMPTION_SELECT_CANDIDATES_FOR_RESERVED_CONTAINERS,\n         CapacitySchedulerConfiguration.\n         DEFAULT_PREEMPTION_SELECT_CANDIDATES_FOR_RESERVED_CONTAINERS);\n     if (selectCandidatesForResevedContainers) {\n       candidatesSelectionPolicies\n           .add(new ReservedContainerCandidatesSelector(this));\n     }\n \n     boolean additionalPreemptionBasedOnReservedResource \u003d csConfig.getBoolean(\n         CapacitySchedulerConfiguration.ADDITIONAL_RESOURCE_BALANCE_BASED_ON_RESERVED_CONTAINERS,\n         CapacitySchedulerConfiguration.DEFAULT_ADDITIONAL_RESOURCE_BALANCE_BASED_ON_RESERVED_CONTAINERS);\n \n     // initialize candidates preemption selection policies\n     candidatesSelectionPolicies.add(new FifoCandidatesSelector(this,\n         additionalPreemptionBasedOnReservedResource));\n \n     // Do we need to specially consider intra queue\n     boolean isIntraQueuePreemptionEnabled \u003d csConfig.getBoolean(\n         CapacitySchedulerConfiguration.INTRAQUEUE_PREEMPTION_ENABLED,\n         CapacitySchedulerConfiguration.DEFAULT_INTRAQUEUE_PREEMPTION_ENABLED);\n     if (isIntraQueuePreemptionEnabled) {\n       candidatesSelectionPolicies.add(new IntraQueueCandidatesSelector(this));\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void init(Configuration config, RMContext context,\n      ResourceScheduler sched) {\n    LOG.info(\"Preemption monitor:\" + this.getClass().getCanonicalName());\n    assert null \u003d\u003d scheduler : \"Unexpected duplicate call to init\";\n    if (!(sched instanceof CapacityScheduler)) {\n      throw new YarnRuntimeException(\"Class \" +\n          sched.getClass().getCanonicalName() + \" not instance of \" +\n          CapacityScheduler.class.getCanonicalName());\n    }\n    rmContext \u003d context;\n    scheduler \u003d (CapacityScheduler) sched;\n    CapacitySchedulerConfiguration csConfig \u003d scheduler.getConfiguration();\n\n    maxIgnoredOverCapacity \u003d csConfig.getDouble(\n        CapacitySchedulerConfiguration.PREEMPTION_MAX_IGNORED_OVER_CAPACITY,\n        CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_MAX_IGNORED_OVER_CAPACITY);\n\n    naturalTerminationFactor \u003d csConfig.getDouble(\n        CapacitySchedulerConfiguration.PREEMPTION_NATURAL_TERMINATION_FACTOR,\n        CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_NATURAL_TERMINATION_FACTOR);\n\n    maxWaitTime \u003d csConfig.getLong(\n        CapacitySchedulerConfiguration.PREEMPTION_WAIT_TIME_BEFORE_KILL,\n        CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_WAIT_TIME_BEFORE_KILL);\n\n    monitoringInterval \u003d csConfig.getLong(\n        CapacitySchedulerConfiguration.PREEMPTION_MONITORING_INTERVAL,\n        CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_MONITORING_INTERVAL);\n\n    percentageClusterPreemptionAllowed \u003d csConfig.getFloat(\n        CapacitySchedulerConfiguration.TOTAL_PREEMPTION_PER_ROUND,\n        CapacitySchedulerConfiguration.DEFAULT_TOTAL_PREEMPTION_PER_ROUND);\n\n    observeOnly \u003d csConfig.getBoolean(\n        CapacitySchedulerConfiguration.PREEMPTION_OBSERVE_ONLY,\n        CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_OBSERVE_ONLY);\n\n    lazyPreempionEnabled \u003d csConfig.getBoolean(\n        CapacitySchedulerConfiguration.LAZY_PREEMPTION_ENALBED,\n        CapacitySchedulerConfiguration.DEFAULT_LAZY_PREEMPTION_ENABLED);\n\n    maxAllowableLimitForIntraQueuePreemption \u003d csConfig.getFloat(\n        CapacitySchedulerConfiguration.\n        INTRAQUEUE_PREEMPTION_MAX_ALLOWABLE_LIMIT,\n        CapacitySchedulerConfiguration.\n        DEFAULT_INTRAQUEUE_PREEMPTION_MAX_ALLOWABLE_LIMIT);\n\n    minimumThresholdForIntraQueuePreemption \u003d csConfig.getFloat(\n        CapacitySchedulerConfiguration.\n        INTRAQUEUE_PREEMPTION_MINIMUM_THRESHOLD,\n        CapacitySchedulerConfiguration.\n        DEFAULT_INTRAQUEUE_PREEMPTION_MINIMUM_THRESHOLD);\n\n    intraQueuePreemptionOrderPolicy \u003d IntraQueuePreemptionOrderPolicy\n        .valueOf(csConfig\n            .get(\n                CapacitySchedulerConfiguration.INTRAQUEUE_PREEMPTION_ORDER_POLICY,\n                CapacitySchedulerConfiguration.DEFAULT_INTRAQUEUE_PREEMPTION_ORDER_POLICY)\n            .toUpperCase());\n\n    rc \u003d scheduler.getResourceCalculator();\n    nlm \u003d scheduler.getRMContext().getNodeLabelManager();\n\n    // Do we need white queue-priority preemption policy?\n    boolean isQueuePriorityPreemptionEnabled \u003d\n        csConfig.getPUOrderingPolicyUnderUtilizedPreemptionEnabled();\n    if (isQueuePriorityPreemptionEnabled) {\n      candidatesSelectionPolicies.add(\n          new QueuePriorityContainerCandidateSelector(this));\n    }\n\n    // Do we need to specially consider reserved containers?\n    boolean selectCandidatesForResevedContainers \u003d csConfig.getBoolean(\n        CapacitySchedulerConfiguration.\n        PREEMPTION_SELECT_CANDIDATES_FOR_RESERVED_CONTAINERS,\n        CapacitySchedulerConfiguration.\n        DEFAULT_PREEMPTION_SELECT_CANDIDATES_FOR_RESERVED_CONTAINERS);\n    if (selectCandidatesForResevedContainers) {\n      candidatesSelectionPolicies\n          .add(new ReservedContainerCandidatesSelector(this));\n    }\n\n    boolean additionalPreemptionBasedOnReservedResource \u003d csConfig.getBoolean(\n        CapacitySchedulerConfiguration.ADDITIONAL_RESOURCE_BALANCE_BASED_ON_RESERVED_CONTAINERS,\n        CapacitySchedulerConfiguration.DEFAULT_ADDITIONAL_RESOURCE_BALANCE_BASED_ON_RESERVED_CONTAINERS);\n\n    // initialize candidates preemption selection policies\n    candidatesSelectionPolicies.add(new FifoCandidatesSelector(this,\n        additionalPreemptionBasedOnReservedResource));\n\n    // Do we need to specially consider intra queue\n    boolean isIntraQueuePreemptionEnabled \u003d csConfig.getBoolean(\n        CapacitySchedulerConfiguration.INTRAQUEUE_PREEMPTION_ENABLED,\n        CapacitySchedulerConfiguration.DEFAULT_INTRAQUEUE_PREEMPTION_ENABLED);\n    if (isIntraQueuePreemptionEnabled) {\n      candidatesSelectionPolicies.add(new IntraQueueCandidatesSelector(this));\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java",
      "extendedDetails": {
        "oldValue": "[config-Configuration, context-RMContext, sched-PreemptableResourceScheduler]",
        "newValue": "[config-Configuration, context-RMContext, sched-ResourceScheduler]"
      }
    },
    "0b7afc060c2024a882bd1934d0f722bfca731742": {
      "type": "Ybodychange",
      "commitMessage": "Addendum patch for YARN-5731\n",
      "commitDate": "17/07/17 11:19 PM",
      "commitName": "0b7afc060c2024a882bd1934d0f722bfca731742",
      "commitAuthor": "Sunil G",
      "commitDateOld": "13/07/17 4:18 AM",
      "commitNameOld": "cf0d0844d6ae25d537391edb9b65fca05d1848e6",
      "commitAuthorOld": "Sunil G",
      "daysBetweenCommits": 4.79,
      "commitsBetweenForRepo": 27,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,113 +1,98 @@\n   public void init(Configuration config, RMContext context,\n       PreemptableResourceScheduler sched) {\n     LOG.info(\"Preemption monitor:\" + this.getClass().getCanonicalName());\n     assert null \u003d\u003d scheduler : \"Unexpected duplicate call to init\";\n     if (!(sched instanceof CapacityScheduler)) {\n       throw new YarnRuntimeException(\"Class \" +\n           sched.getClass().getCanonicalName() + \" not instance of \" +\n           CapacityScheduler.class.getCanonicalName());\n     }\n     rmContext \u003d context;\n     scheduler \u003d (CapacityScheduler) sched;\n     CapacitySchedulerConfiguration csConfig \u003d scheduler.getConfiguration();\n \n     maxIgnoredOverCapacity \u003d csConfig.getDouble(\n         CapacitySchedulerConfiguration.PREEMPTION_MAX_IGNORED_OVER_CAPACITY,\n         CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_MAX_IGNORED_OVER_CAPACITY);\n \n     naturalTerminationFactor \u003d csConfig.getDouble(\n         CapacitySchedulerConfiguration.PREEMPTION_NATURAL_TERMINATION_FACTOR,\n         CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_NATURAL_TERMINATION_FACTOR);\n \n     maxWaitTime \u003d csConfig.getLong(\n         CapacitySchedulerConfiguration.PREEMPTION_WAIT_TIME_BEFORE_KILL,\n         CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_WAIT_TIME_BEFORE_KILL);\n \n     monitoringInterval \u003d csConfig.getLong(\n         CapacitySchedulerConfiguration.PREEMPTION_MONITORING_INTERVAL,\n         CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_MONITORING_INTERVAL);\n \n     percentageClusterPreemptionAllowed \u003d csConfig.getFloat(\n         CapacitySchedulerConfiguration.TOTAL_PREEMPTION_PER_ROUND,\n         CapacitySchedulerConfiguration.DEFAULT_TOTAL_PREEMPTION_PER_ROUND);\n \n     observeOnly \u003d csConfig.getBoolean(\n         CapacitySchedulerConfiguration.PREEMPTION_OBSERVE_ONLY,\n         CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_OBSERVE_ONLY);\n \n     lazyPreempionEnabled \u003d csConfig.getBoolean(\n         CapacitySchedulerConfiguration.LAZY_PREEMPTION_ENALBED,\n         CapacitySchedulerConfiguration.DEFAULT_LAZY_PREEMPTION_ENABLED);\n \n     maxAllowableLimitForIntraQueuePreemption \u003d csConfig.getFloat(\n         CapacitySchedulerConfiguration.\n         INTRAQUEUE_PREEMPTION_MAX_ALLOWABLE_LIMIT,\n         CapacitySchedulerConfiguration.\n         DEFAULT_INTRAQUEUE_PREEMPTION_MAX_ALLOWABLE_LIMIT);\n \n     minimumThresholdForIntraQueuePreemption \u003d csConfig.getFloat(\n         CapacitySchedulerConfiguration.\n         INTRAQUEUE_PREEMPTION_MINIMUM_THRESHOLD,\n         CapacitySchedulerConfiguration.\n         DEFAULT_INTRAQUEUE_PREEMPTION_MINIMUM_THRESHOLD);\n \n     intraQueuePreemptionOrderPolicy \u003d IntraQueuePreemptionOrderPolicy\n         .valueOf(csConfig\n             .get(\n                 CapacitySchedulerConfiguration.INTRAQUEUE_PREEMPTION_ORDER_POLICY,\n                 CapacitySchedulerConfiguration.DEFAULT_INTRAQUEUE_PREEMPTION_ORDER_POLICY)\n             .toUpperCase());\n \n     rc \u003d scheduler.getResourceCalculator();\n     nlm \u003d scheduler.getRMContext().getNodeLabelManager();\n \n     // Do we need white queue-priority preemption policy?\n     boolean isQueuePriorityPreemptionEnabled \u003d\n         csConfig.getPUOrderingPolicyUnderUtilizedPreemptionEnabled();\n     if (isQueuePriorityPreemptionEnabled) {\n       candidatesSelectionPolicies.add(\n           new QueuePriorityContainerCandidateSelector(this));\n     }\n \n     // Do we need to specially consider reserved containers?\n     boolean selectCandidatesForResevedContainers \u003d csConfig.getBoolean(\n         CapacitySchedulerConfiguration.\n         PREEMPTION_SELECT_CANDIDATES_FOR_RESERVED_CONTAINERS,\n         CapacitySchedulerConfiguration.\n         DEFAULT_PREEMPTION_SELECT_CANDIDATES_FOR_RESERVED_CONTAINERS);\n     if (selectCandidatesForResevedContainers) {\n       candidatesSelectionPolicies\n           .add(new ReservedContainerCandidatesSelector(this));\n     }\n \n+    boolean additionalPreemptionBasedOnReservedResource \u003d csConfig.getBoolean(\n+        CapacitySchedulerConfiguration.ADDITIONAL_RESOURCE_BALANCE_BASED_ON_RESERVED_CONTAINERS,\n+        CapacitySchedulerConfiguration.DEFAULT_ADDITIONAL_RESOURCE_BALANCE_BASED_ON_RESERVED_CONTAINERS);\n+\n     // initialize candidates preemption selection policies\n-    // When select candidates for reserved containers is enabled, exclude reserved\n-    // resource in fifo policy (less aggressive). Otherwise include reserved\n-    // resource.\n-    //\n-    // Why doing this? In YARN-4390, we added preemption-based-on-reserved-container\n-    // Support. To reduce unnecessary preemption for large containers. We will\n-    // not include reserved resources while calculating ideal-allocation in\n-    // FifoCandidatesSelector.\n-    //\n-    // Changes in YARN-4390 will significantly reduce number of containers preempted\n-    // When cluster has heterogeneous container requests. (Please check test\n-    // report: https://issues.apache.org/jira/secure/attachment/12796197/YARN-4390-test-results.pdf\n-    //\n-    // However, on the other hand, in some corner cases, especially for\n-    // fragmented cluster. It could lead to preemption cannot kick in in some\n-    // cases. Please see YARN-5731.\n-    //\n-    // So to solve the problem, we will include reserved when surgical preemption\n-    // for reserved container, which reverts behavior when YARN-4390 is disabled.\n     candidatesSelectionPolicies.add(new FifoCandidatesSelector(this,\n-        !selectCandidatesForResevedContainers));\n+        additionalPreemptionBasedOnReservedResource));\n \n     // Do we need to specially consider intra queue\n     boolean isIntraQueuePreemptionEnabled \u003d csConfig.getBoolean(\n         CapacitySchedulerConfiguration.INTRAQUEUE_PREEMPTION_ENABLED,\n         CapacitySchedulerConfiguration.DEFAULT_INTRAQUEUE_PREEMPTION_ENABLED);\n     if (isIntraQueuePreemptionEnabled) {\n       candidatesSelectionPolicies.add(new IntraQueueCandidatesSelector(this));\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void init(Configuration config, RMContext context,\n      PreemptableResourceScheduler sched) {\n    LOG.info(\"Preemption monitor:\" + this.getClass().getCanonicalName());\n    assert null \u003d\u003d scheduler : \"Unexpected duplicate call to init\";\n    if (!(sched instanceof CapacityScheduler)) {\n      throw new YarnRuntimeException(\"Class \" +\n          sched.getClass().getCanonicalName() + \" not instance of \" +\n          CapacityScheduler.class.getCanonicalName());\n    }\n    rmContext \u003d context;\n    scheduler \u003d (CapacityScheduler) sched;\n    CapacitySchedulerConfiguration csConfig \u003d scheduler.getConfiguration();\n\n    maxIgnoredOverCapacity \u003d csConfig.getDouble(\n        CapacitySchedulerConfiguration.PREEMPTION_MAX_IGNORED_OVER_CAPACITY,\n        CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_MAX_IGNORED_OVER_CAPACITY);\n\n    naturalTerminationFactor \u003d csConfig.getDouble(\n        CapacitySchedulerConfiguration.PREEMPTION_NATURAL_TERMINATION_FACTOR,\n        CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_NATURAL_TERMINATION_FACTOR);\n\n    maxWaitTime \u003d csConfig.getLong(\n        CapacitySchedulerConfiguration.PREEMPTION_WAIT_TIME_BEFORE_KILL,\n        CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_WAIT_TIME_BEFORE_KILL);\n\n    monitoringInterval \u003d csConfig.getLong(\n        CapacitySchedulerConfiguration.PREEMPTION_MONITORING_INTERVAL,\n        CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_MONITORING_INTERVAL);\n\n    percentageClusterPreemptionAllowed \u003d csConfig.getFloat(\n        CapacitySchedulerConfiguration.TOTAL_PREEMPTION_PER_ROUND,\n        CapacitySchedulerConfiguration.DEFAULT_TOTAL_PREEMPTION_PER_ROUND);\n\n    observeOnly \u003d csConfig.getBoolean(\n        CapacitySchedulerConfiguration.PREEMPTION_OBSERVE_ONLY,\n        CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_OBSERVE_ONLY);\n\n    lazyPreempionEnabled \u003d csConfig.getBoolean(\n        CapacitySchedulerConfiguration.LAZY_PREEMPTION_ENALBED,\n        CapacitySchedulerConfiguration.DEFAULT_LAZY_PREEMPTION_ENABLED);\n\n    maxAllowableLimitForIntraQueuePreemption \u003d csConfig.getFloat(\n        CapacitySchedulerConfiguration.\n        INTRAQUEUE_PREEMPTION_MAX_ALLOWABLE_LIMIT,\n        CapacitySchedulerConfiguration.\n        DEFAULT_INTRAQUEUE_PREEMPTION_MAX_ALLOWABLE_LIMIT);\n\n    minimumThresholdForIntraQueuePreemption \u003d csConfig.getFloat(\n        CapacitySchedulerConfiguration.\n        INTRAQUEUE_PREEMPTION_MINIMUM_THRESHOLD,\n        CapacitySchedulerConfiguration.\n        DEFAULT_INTRAQUEUE_PREEMPTION_MINIMUM_THRESHOLD);\n\n    intraQueuePreemptionOrderPolicy \u003d IntraQueuePreemptionOrderPolicy\n        .valueOf(csConfig\n            .get(\n                CapacitySchedulerConfiguration.INTRAQUEUE_PREEMPTION_ORDER_POLICY,\n                CapacitySchedulerConfiguration.DEFAULT_INTRAQUEUE_PREEMPTION_ORDER_POLICY)\n            .toUpperCase());\n\n    rc \u003d scheduler.getResourceCalculator();\n    nlm \u003d scheduler.getRMContext().getNodeLabelManager();\n\n    // Do we need white queue-priority preemption policy?\n    boolean isQueuePriorityPreemptionEnabled \u003d\n        csConfig.getPUOrderingPolicyUnderUtilizedPreemptionEnabled();\n    if (isQueuePriorityPreemptionEnabled) {\n      candidatesSelectionPolicies.add(\n          new QueuePriorityContainerCandidateSelector(this));\n    }\n\n    // Do we need to specially consider reserved containers?\n    boolean selectCandidatesForResevedContainers \u003d csConfig.getBoolean(\n        CapacitySchedulerConfiguration.\n        PREEMPTION_SELECT_CANDIDATES_FOR_RESERVED_CONTAINERS,\n        CapacitySchedulerConfiguration.\n        DEFAULT_PREEMPTION_SELECT_CANDIDATES_FOR_RESERVED_CONTAINERS);\n    if (selectCandidatesForResevedContainers) {\n      candidatesSelectionPolicies\n          .add(new ReservedContainerCandidatesSelector(this));\n    }\n\n    boolean additionalPreemptionBasedOnReservedResource \u003d csConfig.getBoolean(\n        CapacitySchedulerConfiguration.ADDITIONAL_RESOURCE_BALANCE_BASED_ON_RESERVED_CONTAINERS,\n        CapacitySchedulerConfiguration.DEFAULT_ADDITIONAL_RESOURCE_BALANCE_BASED_ON_RESERVED_CONTAINERS);\n\n    // initialize candidates preemption selection policies\n    candidatesSelectionPolicies.add(new FifoCandidatesSelector(this,\n        additionalPreemptionBasedOnReservedResource));\n\n    // Do we need to specially consider intra queue\n    boolean isIntraQueuePreemptionEnabled \u003d csConfig.getBoolean(\n        CapacitySchedulerConfiguration.INTRAQUEUE_PREEMPTION_ENABLED,\n        CapacitySchedulerConfiguration.DEFAULT_INTRAQUEUE_PREEMPTION_ENABLED);\n    if (isIntraQueuePreemptionEnabled) {\n      candidatesSelectionPolicies.add(new IntraQueueCandidatesSelector(this));\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java",
      "extendedDetails": {}
    },
    "cf0d0844d6ae25d537391edb9b65fca05d1848e6": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5731. Preemption calculation is not accurate when reserved containers are present in queue. Contributed by Wangda Tan.\n",
      "commitDate": "13/07/17 4:18 AM",
      "commitName": "cf0d0844d6ae25d537391edb9b65fca05d1848e6",
      "commitAuthor": "Sunil G",
      "commitDateOld": "22/05/17 2:26 PM",
      "commitNameOld": "c583ab02c730be0a63d974039a78f2dc67dc2db6",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 51.58,
      "commitsBetweenForRepo": 243,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,93 +1,113 @@\n   public void init(Configuration config, RMContext context,\n       PreemptableResourceScheduler sched) {\n     LOG.info(\"Preemption monitor:\" + this.getClass().getCanonicalName());\n     assert null \u003d\u003d scheduler : \"Unexpected duplicate call to init\";\n     if (!(sched instanceof CapacityScheduler)) {\n       throw new YarnRuntimeException(\"Class \" +\n           sched.getClass().getCanonicalName() + \" not instance of \" +\n           CapacityScheduler.class.getCanonicalName());\n     }\n     rmContext \u003d context;\n     scheduler \u003d (CapacityScheduler) sched;\n     CapacitySchedulerConfiguration csConfig \u003d scheduler.getConfiguration();\n \n     maxIgnoredOverCapacity \u003d csConfig.getDouble(\n         CapacitySchedulerConfiguration.PREEMPTION_MAX_IGNORED_OVER_CAPACITY,\n         CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_MAX_IGNORED_OVER_CAPACITY);\n \n     naturalTerminationFactor \u003d csConfig.getDouble(\n         CapacitySchedulerConfiguration.PREEMPTION_NATURAL_TERMINATION_FACTOR,\n         CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_NATURAL_TERMINATION_FACTOR);\n \n     maxWaitTime \u003d csConfig.getLong(\n         CapacitySchedulerConfiguration.PREEMPTION_WAIT_TIME_BEFORE_KILL,\n         CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_WAIT_TIME_BEFORE_KILL);\n \n     monitoringInterval \u003d csConfig.getLong(\n         CapacitySchedulerConfiguration.PREEMPTION_MONITORING_INTERVAL,\n         CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_MONITORING_INTERVAL);\n \n     percentageClusterPreemptionAllowed \u003d csConfig.getFloat(\n         CapacitySchedulerConfiguration.TOTAL_PREEMPTION_PER_ROUND,\n         CapacitySchedulerConfiguration.DEFAULT_TOTAL_PREEMPTION_PER_ROUND);\n \n     observeOnly \u003d csConfig.getBoolean(\n         CapacitySchedulerConfiguration.PREEMPTION_OBSERVE_ONLY,\n         CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_OBSERVE_ONLY);\n \n     lazyPreempionEnabled \u003d csConfig.getBoolean(\n         CapacitySchedulerConfiguration.LAZY_PREEMPTION_ENALBED,\n         CapacitySchedulerConfiguration.DEFAULT_LAZY_PREEMPTION_ENABLED);\n \n     maxAllowableLimitForIntraQueuePreemption \u003d csConfig.getFloat(\n         CapacitySchedulerConfiguration.\n         INTRAQUEUE_PREEMPTION_MAX_ALLOWABLE_LIMIT,\n         CapacitySchedulerConfiguration.\n         DEFAULT_INTRAQUEUE_PREEMPTION_MAX_ALLOWABLE_LIMIT);\n \n     minimumThresholdForIntraQueuePreemption \u003d csConfig.getFloat(\n         CapacitySchedulerConfiguration.\n         INTRAQUEUE_PREEMPTION_MINIMUM_THRESHOLD,\n         CapacitySchedulerConfiguration.\n         DEFAULT_INTRAQUEUE_PREEMPTION_MINIMUM_THRESHOLD);\n \n     intraQueuePreemptionOrderPolicy \u003d IntraQueuePreemptionOrderPolicy\n         .valueOf(csConfig\n             .get(\n                 CapacitySchedulerConfiguration.INTRAQUEUE_PREEMPTION_ORDER_POLICY,\n                 CapacitySchedulerConfiguration.DEFAULT_INTRAQUEUE_PREEMPTION_ORDER_POLICY)\n             .toUpperCase());\n \n     rc \u003d scheduler.getResourceCalculator();\n     nlm \u003d scheduler.getRMContext().getNodeLabelManager();\n \n     // Do we need white queue-priority preemption policy?\n     boolean isQueuePriorityPreemptionEnabled \u003d\n         csConfig.getPUOrderingPolicyUnderUtilizedPreemptionEnabled();\n     if (isQueuePriorityPreemptionEnabled) {\n       candidatesSelectionPolicies.add(\n           new QueuePriorityContainerCandidateSelector(this));\n     }\n \n     // Do we need to specially consider reserved containers?\n     boolean selectCandidatesForResevedContainers \u003d csConfig.getBoolean(\n         CapacitySchedulerConfiguration.\n         PREEMPTION_SELECT_CANDIDATES_FOR_RESERVED_CONTAINERS,\n         CapacitySchedulerConfiguration.\n         DEFAULT_PREEMPTION_SELECT_CANDIDATES_FOR_RESERVED_CONTAINERS);\n     if (selectCandidatesForResevedContainers) {\n       candidatesSelectionPolicies\n           .add(new ReservedContainerCandidatesSelector(this));\n     }\n \n     // initialize candidates preemption selection policies\n-    candidatesSelectionPolicies.add(new FifoCandidatesSelector(this));\n+    // When select candidates for reserved containers is enabled, exclude reserved\n+    // resource in fifo policy (less aggressive). Otherwise include reserved\n+    // resource.\n+    //\n+    // Why doing this? In YARN-4390, we added preemption-based-on-reserved-container\n+    // Support. To reduce unnecessary preemption for large containers. We will\n+    // not include reserved resources while calculating ideal-allocation in\n+    // FifoCandidatesSelector.\n+    //\n+    // Changes in YARN-4390 will significantly reduce number of containers preempted\n+    // When cluster has heterogeneous container requests. (Please check test\n+    // report: https://issues.apache.org/jira/secure/attachment/12796197/YARN-4390-test-results.pdf\n+    //\n+    // However, on the other hand, in some corner cases, especially for\n+    // fragmented cluster. It could lead to preemption cannot kick in in some\n+    // cases. Please see YARN-5731.\n+    //\n+    // So to solve the problem, we will include reserved when surgical preemption\n+    // for reserved container, which reverts behavior when YARN-4390 is disabled.\n+    candidatesSelectionPolicies.add(new FifoCandidatesSelector(this,\n+        !selectCandidatesForResevedContainers));\n \n     // Do we need to specially consider intra queue\n     boolean isIntraQueuePreemptionEnabled \u003d csConfig.getBoolean(\n         CapacitySchedulerConfiguration.INTRAQUEUE_PREEMPTION_ENABLED,\n         CapacitySchedulerConfiguration.DEFAULT_INTRAQUEUE_PREEMPTION_ENABLED);\n     if (isIntraQueuePreemptionEnabled) {\n       candidatesSelectionPolicies.add(new IntraQueueCandidatesSelector(this));\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void init(Configuration config, RMContext context,\n      PreemptableResourceScheduler sched) {\n    LOG.info(\"Preemption monitor:\" + this.getClass().getCanonicalName());\n    assert null \u003d\u003d scheduler : \"Unexpected duplicate call to init\";\n    if (!(sched instanceof CapacityScheduler)) {\n      throw new YarnRuntimeException(\"Class \" +\n          sched.getClass().getCanonicalName() + \" not instance of \" +\n          CapacityScheduler.class.getCanonicalName());\n    }\n    rmContext \u003d context;\n    scheduler \u003d (CapacityScheduler) sched;\n    CapacitySchedulerConfiguration csConfig \u003d scheduler.getConfiguration();\n\n    maxIgnoredOverCapacity \u003d csConfig.getDouble(\n        CapacitySchedulerConfiguration.PREEMPTION_MAX_IGNORED_OVER_CAPACITY,\n        CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_MAX_IGNORED_OVER_CAPACITY);\n\n    naturalTerminationFactor \u003d csConfig.getDouble(\n        CapacitySchedulerConfiguration.PREEMPTION_NATURAL_TERMINATION_FACTOR,\n        CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_NATURAL_TERMINATION_FACTOR);\n\n    maxWaitTime \u003d csConfig.getLong(\n        CapacitySchedulerConfiguration.PREEMPTION_WAIT_TIME_BEFORE_KILL,\n        CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_WAIT_TIME_BEFORE_KILL);\n\n    monitoringInterval \u003d csConfig.getLong(\n        CapacitySchedulerConfiguration.PREEMPTION_MONITORING_INTERVAL,\n        CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_MONITORING_INTERVAL);\n\n    percentageClusterPreemptionAllowed \u003d csConfig.getFloat(\n        CapacitySchedulerConfiguration.TOTAL_PREEMPTION_PER_ROUND,\n        CapacitySchedulerConfiguration.DEFAULT_TOTAL_PREEMPTION_PER_ROUND);\n\n    observeOnly \u003d csConfig.getBoolean(\n        CapacitySchedulerConfiguration.PREEMPTION_OBSERVE_ONLY,\n        CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_OBSERVE_ONLY);\n\n    lazyPreempionEnabled \u003d csConfig.getBoolean(\n        CapacitySchedulerConfiguration.LAZY_PREEMPTION_ENALBED,\n        CapacitySchedulerConfiguration.DEFAULT_LAZY_PREEMPTION_ENABLED);\n\n    maxAllowableLimitForIntraQueuePreemption \u003d csConfig.getFloat(\n        CapacitySchedulerConfiguration.\n        INTRAQUEUE_PREEMPTION_MAX_ALLOWABLE_LIMIT,\n        CapacitySchedulerConfiguration.\n        DEFAULT_INTRAQUEUE_PREEMPTION_MAX_ALLOWABLE_LIMIT);\n\n    minimumThresholdForIntraQueuePreemption \u003d csConfig.getFloat(\n        CapacitySchedulerConfiguration.\n        INTRAQUEUE_PREEMPTION_MINIMUM_THRESHOLD,\n        CapacitySchedulerConfiguration.\n        DEFAULT_INTRAQUEUE_PREEMPTION_MINIMUM_THRESHOLD);\n\n    intraQueuePreemptionOrderPolicy \u003d IntraQueuePreemptionOrderPolicy\n        .valueOf(csConfig\n            .get(\n                CapacitySchedulerConfiguration.INTRAQUEUE_PREEMPTION_ORDER_POLICY,\n                CapacitySchedulerConfiguration.DEFAULT_INTRAQUEUE_PREEMPTION_ORDER_POLICY)\n            .toUpperCase());\n\n    rc \u003d scheduler.getResourceCalculator();\n    nlm \u003d scheduler.getRMContext().getNodeLabelManager();\n\n    // Do we need white queue-priority preemption policy?\n    boolean isQueuePriorityPreemptionEnabled \u003d\n        csConfig.getPUOrderingPolicyUnderUtilizedPreemptionEnabled();\n    if (isQueuePriorityPreemptionEnabled) {\n      candidatesSelectionPolicies.add(\n          new QueuePriorityContainerCandidateSelector(this));\n    }\n\n    // Do we need to specially consider reserved containers?\n    boolean selectCandidatesForResevedContainers \u003d csConfig.getBoolean(\n        CapacitySchedulerConfiguration.\n        PREEMPTION_SELECT_CANDIDATES_FOR_RESERVED_CONTAINERS,\n        CapacitySchedulerConfiguration.\n        DEFAULT_PREEMPTION_SELECT_CANDIDATES_FOR_RESERVED_CONTAINERS);\n    if (selectCandidatesForResevedContainers) {\n      candidatesSelectionPolicies\n          .add(new ReservedContainerCandidatesSelector(this));\n    }\n\n    // initialize candidates preemption selection policies\n    // When select candidates for reserved containers is enabled, exclude reserved\n    // resource in fifo policy (less aggressive). Otherwise include reserved\n    // resource.\n    //\n    // Why doing this? In YARN-4390, we added preemption-based-on-reserved-container\n    // Support. To reduce unnecessary preemption for large containers. We will\n    // not include reserved resources while calculating ideal-allocation in\n    // FifoCandidatesSelector.\n    //\n    // Changes in YARN-4390 will significantly reduce number of containers preempted\n    // When cluster has heterogeneous container requests. (Please check test\n    // report: https://issues.apache.org/jira/secure/attachment/12796197/YARN-4390-test-results.pdf\n    //\n    // However, on the other hand, in some corner cases, especially for\n    // fragmented cluster. It could lead to preemption cannot kick in in some\n    // cases. Please see YARN-5731.\n    //\n    // So to solve the problem, we will include reserved when surgical preemption\n    // for reserved container, which reverts behavior when YARN-4390 is disabled.\n    candidatesSelectionPolicies.add(new FifoCandidatesSelector(this,\n        !selectCandidatesForResevedContainers));\n\n    // Do we need to specially consider intra queue\n    boolean isIntraQueuePreemptionEnabled \u003d csConfig.getBoolean(\n        CapacitySchedulerConfiguration.INTRAQUEUE_PREEMPTION_ENABLED,\n        CapacitySchedulerConfiguration.DEFAULT_INTRAQUEUE_PREEMPTION_ENABLED);\n    if (isIntraQueuePreemptionEnabled) {\n      candidatesSelectionPolicies.add(new IntraQueueCandidatesSelector(this));\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java",
      "extendedDetails": {}
    },
    "c583ab02c730be0a63d974039a78f2dc67dc2db6": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2113. Add cross-user preemption within CapacityScheduler\u0027s leaf-queue. (Sunil G via wangda)\n\nChange-Id: I9b19f69788068be05b3295247cdd7b972f8a573c\n",
      "commitDate": "22/05/17 2:26 PM",
      "commitName": "c583ab02c730be0a63d974039a78f2dc67dc2db6",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "01/05/17 7:45 AM",
      "commitNameOld": "30fc5801966feb7f9bdd7d79db75acc595102913",
      "commitAuthorOld": "Naganarasimha",
      "daysBetweenCommits": 21.28,
      "commitsBetweenForRepo": 116,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,86 +1,93 @@\n   public void init(Configuration config, RMContext context,\n       PreemptableResourceScheduler sched) {\n     LOG.info(\"Preemption monitor:\" + this.getClass().getCanonicalName());\n     assert null \u003d\u003d scheduler : \"Unexpected duplicate call to init\";\n     if (!(sched instanceof CapacityScheduler)) {\n       throw new YarnRuntimeException(\"Class \" +\n           sched.getClass().getCanonicalName() + \" not instance of \" +\n           CapacityScheduler.class.getCanonicalName());\n     }\n     rmContext \u003d context;\n     scheduler \u003d (CapacityScheduler) sched;\n     CapacitySchedulerConfiguration csConfig \u003d scheduler.getConfiguration();\n \n     maxIgnoredOverCapacity \u003d csConfig.getDouble(\n         CapacitySchedulerConfiguration.PREEMPTION_MAX_IGNORED_OVER_CAPACITY,\n         CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_MAX_IGNORED_OVER_CAPACITY);\n \n     naturalTerminationFactor \u003d csConfig.getDouble(\n         CapacitySchedulerConfiguration.PREEMPTION_NATURAL_TERMINATION_FACTOR,\n         CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_NATURAL_TERMINATION_FACTOR);\n \n     maxWaitTime \u003d csConfig.getLong(\n         CapacitySchedulerConfiguration.PREEMPTION_WAIT_TIME_BEFORE_KILL,\n         CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_WAIT_TIME_BEFORE_KILL);\n \n     monitoringInterval \u003d csConfig.getLong(\n         CapacitySchedulerConfiguration.PREEMPTION_MONITORING_INTERVAL,\n         CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_MONITORING_INTERVAL);\n \n     percentageClusterPreemptionAllowed \u003d csConfig.getFloat(\n         CapacitySchedulerConfiguration.TOTAL_PREEMPTION_PER_ROUND,\n         CapacitySchedulerConfiguration.DEFAULT_TOTAL_PREEMPTION_PER_ROUND);\n \n     observeOnly \u003d csConfig.getBoolean(\n         CapacitySchedulerConfiguration.PREEMPTION_OBSERVE_ONLY,\n         CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_OBSERVE_ONLY);\n \n     lazyPreempionEnabled \u003d csConfig.getBoolean(\n         CapacitySchedulerConfiguration.LAZY_PREEMPTION_ENALBED,\n         CapacitySchedulerConfiguration.DEFAULT_LAZY_PREEMPTION_ENABLED);\n \n     maxAllowableLimitForIntraQueuePreemption \u003d csConfig.getFloat(\n         CapacitySchedulerConfiguration.\n         INTRAQUEUE_PREEMPTION_MAX_ALLOWABLE_LIMIT,\n         CapacitySchedulerConfiguration.\n         DEFAULT_INTRAQUEUE_PREEMPTION_MAX_ALLOWABLE_LIMIT);\n \n     minimumThresholdForIntraQueuePreemption \u003d csConfig.getFloat(\n         CapacitySchedulerConfiguration.\n         INTRAQUEUE_PREEMPTION_MINIMUM_THRESHOLD,\n         CapacitySchedulerConfiguration.\n         DEFAULT_INTRAQUEUE_PREEMPTION_MINIMUM_THRESHOLD);\n \n+    intraQueuePreemptionOrderPolicy \u003d IntraQueuePreemptionOrderPolicy\n+        .valueOf(csConfig\n+            .get(\n+                CapacitySchedulerConfiguration.INTRAQUEUE_PREEMPTION_ORDER_POLICY,\n+                CapacitySchedulerConfiguration.DEFAULT_INTRAQUEUE_PREEMPTION_ORDER_POLICY)\n+            .toUpperCase());\n+\n     rc \u003d scheduler.getResourceCalculator();\n     nlm \u003d scheduler.getRMContext().getNodeLabelManager();\n \n     // Do we need white queue-priority preemption policy?\n     boolean isQueuePriorityPreemptionEnabled \u003d\n         csConfig.getPUOrderingPolicyUnderUtilizedPreemptionEnabled();\n     if (isQueuePriorityPreemptionEnabled) {\n       candidatesSelectionPolicies.add(\n           new QueuePriorityContainerCandidateSelector(this));\n     }\n \n     // Do we need to specially consider reserved containers?\n     boolean selectCandidatesForResevedContainers \u003d csConfig.getBoolean(\n         CapacitySchedulerConfiguration.\n         PREEMPTION_SELECT_CANDIDATES_FOR_RESERVED_CONTAINERS,\n         CapacitySchedulerConfiguration.\n         DEFAULT_PREEMPTION_SELECT_CANDIDATES_FOR_RESERVED_CONTAINERS);\n     if (selectCandidatesForResevedContainers) {\n       candidatesSelectionPolicies\n           .add(new ReservedContainerCandidatesSelector(this));\n     }\n \n     // initialize candidates preemption selection policies\n     candidatesSelectionPolicies.add(new FifoCandidatesSelector(this));\n \n     // Do we need to specially consider intra queue\n     boolean isIntraQueuePreemptionEnabled \u003d csConfig.getBoolean(\n         CapacitySchedulerConfiguration.INTRAQUEUE_PREEMPTION_ENABLED,\n         CapacitySchedulerConfiguration.DEFAULT_INTRAQUEUE_PREEMPTION_ENABLED);\n     if (isIntraQueuePreemptionEnabled) {\n       candidatesSelectionPolicies.add(new IntraQueueCandidatesSelector(this));\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void init(Configuration config, RMContext context,\n      PreemptableResourceScheduler sched) {\n    LOG.info(\"Preemption monitor:\" + this.getClass().getCanonicalName());\n    assert null \u003d\u003d scheduler : \"Unexpected duplicate call to init\";\n    if (!(sched instanceof CapacityScheduler)) {\n      throw new YarnRuntimeException(\"Class \" +\n          sched.getClass().getCanonicalName() + \" not instance of \" +\n          CapacityScheduler.class.getCanonicalName());\n    }\n    rmContext \u003d context;\n    scheduler \u003d (CapacityScheduler) sched;\n    CapacitySchedulerConfiguration csConfig \u003d scheduler.getConfiguration();\n\n    maxIgnoredOverCapacity \u003d csConfig.getDouble(\n        CapacitySchedulerConfiguration.PREEMPTION_MAX_IGNORED_OVER_CAPACITY,\n        CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_MAX_IGNORED_OVER_CAPACITY);\n\n    naturalTerminationFactor \u003d csConfig.getDouble(\n        CapacitySchedulerConfiguration.PREEMPTION_NATURAL_TERMINATION_FACTOR,\n        CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_NATURAL_TERMINATION_FACTOR);\n\n    maxWaitTime \u003d csConfig.getLong(\n        CapacitySchedulerConfiguration.PREEMPTION_WAIT_TIME_BEFORE_KILL,\n        CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_WAIT_TIME_BEFORE_KILL);\n\n    monitoringInterval \u003d csConfig.getLong(\n        CapacitySchedulerConfiguration.PREEMPTION_MONITORING_INTERVAL,\n        CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_MONITORING_INTERVAL);\n\n    percentageClusterPreemptionAllowed \u003d csConfig.getFloat(\n        CapacitySchedulerConfiguration.TOTAL_PREEMPTION_PER_ROUND,\n        CapacitySchedulerConfiguration.DEFAULT_TOTAL_PREEMPTION_PER_ROUND);\n\n    observeOnly \u003d csConfig.getBoolean(\n        CapacitySchedulerConfiguration.PREEMPTION_OBSERVE_ONLY,\n        CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_OBSERVE_ONLY);\n\n    lazyPreempionEnabled \u003d csConfig.getBoolean(\n        CapacitySchedulerConfiguration.LAZY_PREEMPTION_ENALBED,\n        CapacitySchedulerConfiguration.DEFAULT_LAZY_PREEMPTION_ENABLED);\n\n    maxAllowableLimitForIntraQueuePreemption \u003d csConfig.getFloat(\n        CapacitySchedulerConfiguration.\n        INTRAQUEUE_PREEMPTION_MAX_ALLOWABLE_LIMIT,\n        CapacitySchedulerConfiguration.\n        DEFAULT_INTRAQUEUE_PREEMPTION_MAX_ALLOWABLE_LIMIT);\n\n    minimumThresholdForIntraQueuePreemption \u003d csConfig.getFloat(\n        CapacitySchedulerConfiguration.\n        INTRAQUEUE_PREEMPTION_MINIMUM_THRESHOLD,\n        CapacitySchedulerConfiguration.\n        DEFAULT_INTRAQUEUE_PREEMPTION_MINIMUM_THRESHOLD);\n\n    intraQueuePreemptionOrderPolicy \u003d IntraQueuePreemptionOrderPolicy\n        .valueOf(csConfig\n            .get(\n                CapacitySchedulerConfiguration.INTRAQUEUE_PREEMPTION_ORDER_POLICY,\n                CapacitySchedulerConfiguration.DEFAULT_INTRAQUEUE_PREEMPTION_ORDER_POLICY)\n            .toUpperCase());\n\n    rc \u003d scheduler.getResourceCalculator();\n    nlm \u003d scheduler.getRMContext().getNodeLabelManager();\n\n    // Do we need white queue-priority preemption policy?\n    boolean isQueuePriorityPreemptionEnabled \u003d\n        csConfig.getPUOrderingPolicyUnderUtilizedPreemptionEnabled();\n    if (isQueuePriorityPreemptionEnabled) {\n      candidatesSelectionPolicies.add(\n          new QueuePriorityContainerCandidateSelector(this));\n    }\n\n    // Do we need to specially consider reserved containers?\n    boolean selectCandidatesForResevedContainers \u003d csConfig.getBoolean(\n        CapacitySchedulerConfiguration.\n        PREEMPTION_SELECT_CANDIDATES_FOR_RESERVED_CONTAINERS,\n        CapacitySchedulerConfiguration.\n        DEFAULT_PREEMPTION_SELECT_CANDIDATES_FOR_RESERVED_CONTAINERS);\n    if (selectCandidatesForResevedContainers) {\n      candidatesSelectionPolicies\n          .add(new ReservedContainerCandidatesSelector(this));\n    }\n\n    // initialize candidates preemption selection policies\n    candidatesSelectionPolicies.add(new FifoCandidatesSelector(this));\n\n    // Do we need to specially consider intra queue\n    boolean isIntraQueuePreemptionEnabled \u003d csConfig.getBoolean(\n        CapacitySchedulerConfiguration.INTRAQUEUE_PREEMPTION_ENABLED,\n        CapacitySchedulerConfiguration.DEFAULT_INTRAQUEUE_PREEMPTION_ENABLED);\n    if (isIntraQueuePreemptionEnabled) {\n      candidatesSelectionPolicies.add(new IntraQueueCandidatesSelector(this));\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java",
      "extendedDetails": {}
    },
    "ce832059db077fa95922198b066a737ed4f609fe": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5864. Capacity Scheduler - Queue Priorities. (wangda)\n",
      "commitDate": "23/01/17 10:52 AM",
      "commitName": "ce832059db077fa95922198b066a737ed4f609fe",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "11/11/16 3:16 PM",
      "commitNameOld": "fad9609d13e76e9e3a4e01c96f698bb60b03807e",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 72.82,
      "commitsBetweenForRepo": 374,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,78 +1,86 @@\n   public void init(Configuration config, RMContext context,\n       PreemptableResourceScheduler sched) {\n     LOG.info(\"Preemption monitor:\" + this.getClass().getCanonicalName());\n     assert null \u003d\u003d scheduler : \"Unexpected duplicate call to init\";\n     if (!(sched instanceof CapacityScheduler)) {\n       throw new YarnRuntimeException(\"Class \" +\n           sched.getClass().getCanonicalName() + \" not instance of \" +\n           CapacityScheduler.class.getCanonicalName());\n     }\n     rmContext \u003d context;\n     scheduler \u003d (CapacityScheduler) sched;\n     CapacitySchedulerConfiguration csConfig \u003d scheduler.getConfiguration();\n \n     maxIgnoredOverCapacity \u003d csConfig.getDouble(\n         CapacitySchedulerConfiguration.PREEMPTION_MAX_IGNORED_OVER_CAPACITY,\n         CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_MAX_IGNORED_OVER_CAPACITY);\n \n     naturalTerminationFactor \u003d csConfig.getDouble(\n         CapacitySchedulerConfiguration.PREEMPTION_NATURAL_TERMINATION_FACTOR,\n         CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_NATURAL_TERMINATION_FACTOR);\n \n     maxWaitTime \u003d csConfig.getLong(\n         CapacitySchedulerConfiguration.PREEMPTION_WAIT_TIME_BEFORE_KILL,\n         CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_WAIT_TIME_BEFORE_KILL);\n \n     monitoringInterval \u003d csConfig.getLong(\n         CapacitySchedulerConfiguration.PREEMPTION_MONITORING_INTERVAL,\n         CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_MONITORING_INTERVAL);\n \n     percentageClusterPreemptionAllowed \u003d csConfig.getFloat(\n         CapacitySchedulerConfiguration.TOTAL_PREEMPTION_PER_ROUND,\n         CapacitySchedulerConfiguration.DEFAULT_TOTAL_PREEMPTION_PER_ROUND);\n \n     observeOnly \u003d csConfig.getBoolean(\n         CapacitySchedulerConfiguration.PREEMPTION_OBSERVE_ONLY,\n         CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_OBSERVE_ONLY);\n \n     lazyPreempionEnabled \u003d csConfig.getBoolean(\n         CapacitySchedulerConfiguration.LAZY_PREEMPTION_ENALBED,\n         CapacitySchedulerConfiguration.DEFAULT_LAZY_PREEMPTION_ENABLED);\n \n     maxAllowableLimitForIntraQueuePreemption \u003d csConfig.getFloat(\n         CapacitySchedulerConfiguration.\n         INTRAQUEUE_PREEMPTION_MAX_ALLOWABLE_LIMIT,\n         CapacitySchedulerConfiguration.\n         DEFAULT_INTRAQUEUE_PREEMPTION_MAX_ALLOWABLE_LIMIT);\n \n     minimumThresholdForIntraQueuePreemption \u003d csConfig.getFloat(\n         CapacitySchedulerConfiguration.\n         INTRAQUEUE_PREEMPTION_MINIMUM_THRESHOLD,\n         CapacitySchedulerConfiguration.\n         DEFAULT_INTRAQUEUE_PREEMPTION_MINIMUM_THRESHOLD);\n \n     rc \u003d scheduler.getResourceCalculator();\n     nlm \u003d scheduler.getRMContext().getNodeLabelManager();\n \n+    // Do we need white queue-priority preemption policy?\n+    boolean isQueuePriorityPreemptionEnabled \u003d\n+        csConfig.getPUOrderingPolicyUnderUtilizedPreemptionEnabled();\n+    if (isQueuePriorityPreemptionEnabled) {\n+      candidatesSelectionPolicies.add(\n+          new QueuePriorityContainerCandidateSelector(this));\n+    }\n+\n     // Do we need to specially consider reserved containers?\n     boolean selectCandidatesForResevedContainers \u003d csConfig.getBoolean(\n         CapacitySchedulerConfiguration.\n         PREEMPTION_SELECT_CANDIDATES_FOR_RESERVED_CONTAINERS,\n         CapacitySchedulerConfiguration.\n         DEFAULT_PREEMPTION_SELECT_CANDIDATES_FOR_RESERVED_CONTAINERS);\n     if (selectCandidatesForResevedContainers) {\n       candidatesSelectionPolicies\n           .add(new ReservedContainerCandidatesSelector(this));\n     }\n \n     // initialize candidates preemption selection policies\n     candidatesSelectionPolicies.add(new FifoCandidatesSelector(this));\n \n     // Do we need to specially consider intra queue\n     boolean isIntraQueuePreemptionEnabled \u003d csConfig.getBoolean(\n         CapacitySchedulerConfiguration.INTRAQUEUE_PREEMPTION_ENABLED,\n         CapacitySchedulerConfiguration.DEFAULT_INTRAQUEUE_PREEMPTION_ENABLED);\n     if (isIntraQueuePreemptionEnabled) {\n       candidatesSelectionPolicies.add(new IntraQueueCandidatesSelector(this));\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void init(Configuration config, RMContext context,\n      PreemptableResourceScheduler sched) {\n    LOG.info(\"Preemption monitor:\" + this.getClass().getCanonicalName());\n    assert null \u003d\u003d scheduler : \"Unexpected duplicate call to init\";\n    if (!(sched instanceof CapacityScheduler)) {\n      throw new YarnRuntimeException(\"Class \" +\n          sched.getClass().getCanonicalName() + \" not instance of \" +\n          CapacityScheduler.class.getCanonicalName());\n    }\n    rmContext \u003d context;\n    scheduler \u003d (CapacityScheduler) sched;\n    CapacitySchedulerConfiguration csConfig \u003d scheduler.getConfiguration();\n\n    maxIgnoredOverCapacity \u003d csConfig.getDouble(\n        CapacitySchedulerConfiguration.PREEMPTION_MAX_IGNORED_OVER_CAPACITY,\n        CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_MAX_IGNORED_OVER_CAPACITY);\n\n    naturalTerminationFactor \u003d csConfig.getDouble(\n        CapacitySchedulerConfiguration.PREEMPTION_NATURAL_TERMINATION_FACTOR,\n        CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_NATURAL_TERMINATION_FACTOR);\n\n    maxWaitTime \u003d csConfig.getLong(\n        CapacitySchedulerConfiguration.PREEMPTION_WAIT_TIME_BEFORE_KILL,\n        CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_WAIT_TIME_BEFORE_KILL);\n\n    monitoringInterval \u003d csConfig.getLong(\n        CapacitySchedulerConfiguration.PREEMPTION_MONITORING_INTERVAL,\n        CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_MONITORING_INTERVAL);\n\n    percentageClusterPreemptionAllowed \u003d csConfig.getFloat(\n        CapacitySchedulerConfiguration.TOTAL_PREEMPTION_PER_ROUND,\n        CapacitySchedulerConfiguration.DEFAULT_TOTAL_PREEMPTION_PER_ROUND);\n\n    observeOnly \u003d csConfig.getBoolean(\n        CapacitySchedulerConfiguration.PREEMPTION_OBSERVE_ONLY,\n        CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_OBSERVE_ONLY);\n\n    lazyPreempionEnabled \u003d csConfig.getBoolean(\n        CapacitySchedulerConfiguration.LAZY_PREEMPTION_ENALBED,\n        CapacitySchedulerConfiguration.DEFAULT_LAZY_PREEMPTION_ENABLED);\n\n    maxAllowableLimitForIntraQueuePreemption \u003d csConfig.getFloat(\n        CapacitySchedulerConfiguration.\n        INTRAQUEUE_PREEMPTION_MAX_ALLOWABLE_LIMIT,\n        CapacitySchedulerConfiguration.\n        DEFAULT_INTRAQUEUE_PREEMPTION_MAX_ALLOWABLE_LIMIT);\n\n    minimumThresholdForIntraQueuePreemption \u003d csConfig.getFloat(\n        CapacitySchedulerConfiguration.\n        INTRAQUEUE_PREEMPTION_MINIMUM_THRESHOLD,\n        CapacitySchedulerConfiguration.\n        DEFAULT_INTRAQUEUE_PREEMPTION_MINIMUM_THRESHOLD);\n\n    rc \u003d scheduler.getResourceCalculator();\n    nlm \u003d scheduler.getRMContext().getNodeLabelManager();\n\n    // Do we need white queue-priority preemption policy?\n    boolean isQueuePriorityPreemptionEnabled \u003d\n        csConfig.getPUOrderingPolicyUnderUtilizedPreemptionEnabled();\n    if (isQueuePriorityPreemptionEnabled) {\n      candidatesSelectionPolicies.add(\n          new QueuePriorityContainerCandidateSelector(this));\n    }\n\n    // Do we need to specially consider reserved containers?\n    boolean selectCandidatesForResevedContainers \u003d csConfig.getBoolean(\n        CapacitySchedulerConfiguration.\n        PREEMPTION_SELECT_CANDIDATES_FOR_RESERVED_CONTAINERS,\n        CapacitySchedulerConfiguration.\n        DEFAULT_PREEMPTION_SELECT_CANDIDATES_FOR_RESERVED_CONTAINERS);\n    if (selectCandidatesForResevedContainers) {\n      candidatesSelectionPolicies\n          .add(new ReservedContainerCandidatesSelector(this));\n    }\n\n    // initialize candidates preemption selection policies\n    candidatesSelectionPolicies.add(new FifoCandidatesSelector(this));\n\n    // Do we need to specially consider intra queue\n    boolean isIntraQueuePreemptionEnabled \u003d csConfig.getBoolean(\n        CapacitySchedulerConfiguration.INTRAQUEUE_PREEMPTION_ENABLED,\n        CapacitySchedulerConfiguration.DEFAULT_INTRAQUEUE_PREEMPTION_ENABLED);\n    if (isIntraQueuePreemptionEnabled) {\n      candidatesSelectionPolicies.add(new IntraQueueCandidatesSelector(this));\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java",
      "extendedDetails": {}
    },
    "90dd3a8148468ac37a3f2173ad8d45e38bfcb0c9": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2009. CapacityScheduler: Add intra-queue preemption for app priority support. (Sunil G via wangda)\n",
      "commitDate": "31/10/16 3:18 PM",
      "commitName": "90dd3a8148468ac37a3f2173ad8d45e38bfcb0c9",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "05/05/16 12:56 PM",
      "commitNameOld": "bb62e0592566b2fcae7136b30972aad2d3ac55b0",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 179.1,
      "commitsBetweenForRepo": 1369,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,57 +1,78 @@\n   public void init(Configuration config, RMContext context,\n       PreemptableResourceScheduler sched) {\n     LOG.info(\"Preemption monitor:\" + this.getClass().getCanonicalName());\n     assert null \u003d\u003d scheduler : \"Unexpected duplicate call to init\";\n     if (!(sched instanceof CapacityScheduler)) {\n       throw new YarnRuntimeException(\"Class \" +\n           sched.getClass().getCanonicalName() + \" not instance of \" +\n           CapacityScheduler.class.getCanonicalName());\n     }\n     rmContext \u003d context;\n     scheduler \u003d (CapacityScheduler) sched;\n     CapacitySchedulerConfiguration csConfig \u003d scheduler.getConfiguration();\n \n     maxIgnoredOverCapacity \u003d csConfig.getDouble(\n         CapacitySchedulerConfiguration.PREEMPTION_MAX_IGNORED_OVER_CAPACITY,\n         CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_MAX_IGNORED_OVER_CAPACITY);\n \n     naturalTerminationFactor \u003d csConfig.getDouble(\n         CapacitySchedulerConfiguration.PREEMPTION_NATURAL_TERMINATION_FACTOR,\n         CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_NATURAL_TERMINATION_FACTOR);\n \n     maxWaitTime \u003d csConfig.getLong(\n         CapacitySchedulerConfiguration.PREEMPTION_WAIT_TIME_BEFORE_KILL,\n         CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_WAIT_TIME_BEFORE_KILL);\n \n     monitoringInterval \u003d csConfig.getLong(\n         CapacitySchedulerConfiguration.PREEMPTION_MONITORING_INTERVAL,\n         CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_MONITORING_INTERVAL);\n \n     percentageClusterPreemptionAllowed \u003d csConfig.getFloat(\n         CapacitySchedulerConfiguration.TOTAL_PREEMPTION_PER_ROUND,\n         CapacitySchedulerConfiguration.DEFAULT_TOTAL_PREEMPTION_PER_ROUND);\n \n     observeOnly \u003d csConfig.getBoolean(\n         CapacitySchedulerConfiguration.PREEMPTION_OBSERVE_ONLY,\n         CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_OBSERVE_ONLY);\n \n     lazyPreempionEnabled \u003d csConfig.getBoolean(\n         CapacitySchedulerConfiguration.LAZY_PREEMPTION_ENALBED,\n         CapacitySchedulerConfiguration.DEFAULT_LAZY_PREEMPTION_ENABLED);\n \n+    maxAllowableLimitForIntraQueuePreemption \u003d csConfig.getFloat(\n+        CapacitySchedulerConfiguration.\n+        INTRAQUEUE_PREEMPTION_MAX_ALLOWABLE_LIMIT,\n+        CapacitySchedulerConfiguration.\n+        DEFAULT_INTRAQUEUE_PREEMPTION_MAX_ALLOWABLE_LIMIT);\n+\n+    minimumThresholdForIntraQueuePreemption \u003d csConfig.getFloat(\n+        CapacitySchedulerConfiguration.\n+        INTRAQUEUE_PREEMPTION_MINIMUM_THRESHOLD,\n+        CapacitySchedulerConfiguration.\n+        DEFAULT_INTRAQUEUE_PREEMPTION_MINIMUM_THRESHOLD);\n+\n     rc \u003d scheduler.getResourceCalculator();\n     nlm \u003d scheduler.getRMContext().getNodeLabelManager();\n \n     // Do we need to specially consider reserved containers?\n     boolean selectCandidatesForResevedContainers \u003d csConfig.getBoolean(\n-        CapacitySchedulerConfiguration.PREEMPTION_SELECT_CANDIDATES_FOR_RESERVED_CONTAINERS,\n-        CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_SELECT_CANDIDATES_FOR_RESERVED_CONTAINERS);\n+        CapacitySchedulerConfiguration.\n+        PREEMPTION_SELECT_CANDIDATES_FOR_RESERVED_CONTAINERS,\n+        CapacitySchedulerConfiguration.\n+        DEFAULT_PREEMPTION_SELECT_CANDIDATES_FOR_RESERVED_CONTAINERS);\n     if (selectCandidatesForResevedContainers) {\n-      candidatesSelectionPolicies.add(\n-          new ReservedContainerCandidatesSelector(this));\n+      candidatesSelectionPolicies\n+          .add(new ReservedContainerCandidatesSelector(this));\n     }\n \n     // initialize candidates preemption selection policies\n-    candidatesSelectionPolicies.add(\n-        new FifoCandidatesSelector(this));\n+    candidatesSelectionPolicies.add(new FifoCandidatesSelector(this));\n+\n+    // Do we need to specially consider intra queue\n+    boolean isIntraQueuePreemptionEnabled \u003d csConfig.getBoolean(\n+        CapacitySchedulerConfiguration.INTRAQUEUE_PREEMPTION_ENABLED,\n+        CapacitySchedulerConfiguration.DEFAULT_INTRAQUEUE_PREEMPTION_ENABLED);\n+    if (isIntraQueuePreemptionEnabled) {\n+      candidatesSelectionPolicies.add(new IntraQueueCandidatesSelector(this));\n+    }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void init(Configuration config, RMContext context,\n      PreemptableResourceScheduler sched) {\n    LOG.info(\"Preemption monitor:\" + this.getClass().getCanonicalName());\n    assert null \u003d\u003d scheduler : \"Unexpected duplicate call to init\";\n    if (!(sched instanceof CapacityScheduler)) {\n      throw new YarnRuntimeException(\"Class \" +\n          sched.getClass().getCanonicalName() + \" not instance of \" +\n          CapacityScheduler.class.getCanonicalName());\n    }\n    rmContext \u003d context;\n    scheduler \u003d (CapacityScheduler) sched;\n    CapacitySchedulerConfiguration csConfig \u003d scheduler.getConfiguration();\n\n    maxIgnoredOverCapacity \u003d csConfig.getDouble(\n        CapacitySchedulerConfiguration.PREEMPTION_MAX_IGNORED_OVER_CAPACITY,\n        CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_MAX_IGNORED_OVER_CAPACITY);\n\n    naturalTerminationFactor \u003d csConfig.getDouble(\n        CapacitySchedulerConfiguration.PREEMPTION_NATURAL_TERMINATION_FACTOR,\n        CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_NATURAL_TERMINATION_FACTOR);\n\n    maxWaitTime \u003d csConfig.getLong(\n        CapacitySchedulerConfiguration.PREEMPTION_WAIT_TIME_BEFORE_KILL,\n        CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_WAIT_TIME_BEFORE_KILL);\n\n    monitoringInterval \u003d csConfig.getLong(\n        CapacitySchedulerConfiguration.PREEMPTION_MONITORING_INTERVAL,\n        CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_MONITORING_INTERVAL);\n\n    percentageClusterPreemptionAllowed \u003d csConfig.getFloat(\n        CapacitySchedulerConfiguration.TOTAL_PREEMPTION_PER_ROUND,\n        CapacitySchedulerConfiguration.DEFAULT_TOTAL_PREEMPTION_PER_ROUND);\n\n    observeOnly \u003d csConfig.getBoolean(\n        CapacitySchedulerConfiguration.PREEMPTION_OBSERVE_ONLY,\n        CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_OBSERVE_ONLY);\n\n    lazyPreempionEnabled \u003d csConfig.getBoolean(\n        CapacitySchedulerConfiguration.LAZY_PREEMPTION_ENALBED,\n        CapacitySchedulerConfiguration.DEFAULT_LAZY_PREEMPTION_ENABLED);\n\n    maxAllowableLimitForIntraQueuePreemption \u003d csConfig.getFloat(\n        CapacitySchedulerConfiguration.\n        INTRAQUEUE_PREEMPTION_MAX_ALLOWABLE_LIMIT,\n        CapacitySchedulerConfiguration.\n        DEFAULT_INTRAQUEUE_PREEMPTION_MAX_ALLOWABLE_LIMIT);\n\n    minimumThresholdForIntraQueuePreemption \u003d csConfig.getFloat(\n        CapacitySchedulerConfiguration.\n        INTRAQUEUE_PREEMPTION_MINIMUM_THRESHOLD,\n        CapacitySchedulerConfiguration.\n        DEFAULT_INTRAQUEUE_PREEMPTION_MINIMUM_THRESHOLD);\n\n    rc \u003d scheduler.getResourceCalculator();\n    nlm \u003d scheduler.getRMContext().getNodeLabelManager();\n\n    // Do we need to specially consider reserved containers?\n    boolean selectCandidatesForResevedContainers \u003d csConfig.getBoolean(\n        CapacitySchedulerConfiguration.\n        PREEMPTION_SELECT_CANDIDATES_FOR_RESERVED_CONTAINERS,\n        CapacitySchedulerConfiguration.\n        DEFAULT_PREEMPTION_SELECT_CANDIDATES_FOR_RESERVED_CONTAINERS);\n    if (selectCandidatesForResevedContainers) {\n      candidatesSelectionPolicies\n          .add(new ReservedContainerCandidatesSelector(this));\n    }\n\n    // initialize candidates preemption selection policies\n    candidatesSelectionPolicies.add(new FifoCandidatesSelector(this));\n\n    // Do we need to specially consider intra queue\n    boolean isIntraQueuePreemptionEnabled \u003d csConfig.getBoolean(\n        CapacitySchedulerConfiguration.INTRAQUEUE_PREEMPTION_ENABLED,\n        CapacitySchedulerConfiguration.DEFAULT_INTRAQUEUE_PREEMPTION_ENABLED);\n    if (isIntraQueuePreemptionEnabled) {\n      candidatesSelectionPolicies.add(new IntraQueueCandidatesSelector(this));\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java",
      "extendedDetails": {}
    },
    "bb62e0592566b2fcae7136b30972aad2d3ac55b0": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4390. Do surgical preemption based on reserved container in CapacityScheduler. Contributed by Wangda Tan\n",
      "commitDate": "05/05/16 12:56 PM",
      "commitName": "bb62e0592566b2fcae7136b30972aad2d3ac55b0",
      "commitAuthor": "Jian He",
      "commitDateOld": "22/04/16 11:40 AM",
      "commitNameOld": "7cb3a3da96e59fc9b6528644dae5fb0ac1e44eac",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 13.05,
      "commitsBetweenForRepo": 72,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,48 +1,57 @@\n   public void init(Configuration config, RMContext context,\n       PreemptableResourceScheduler sched) {\n     LOG.info(\"Preemption monitor:\" + this.getClass().getCanonicalName());\n     assert null \u003d\u003d scheduler : \"Unexpected duplicate call to init\";\n     if (!(sched instanceof CapacityScheduler)) {\n       throw new YarnRuntimeException(\"Class \" +\n           sched.getClass().getCanonicalName() + \" not instance of \" +\n           CapacityScheduler.class.getCanonicalName());\n     }\n     rmContext \u003d context;\n     scheduler \u003d (CapacityScheduler) sched;\n     CapacitySchedulerConfiguration csConfig \u003d scheduler.getConfiguration();\n \n     maxIgnoredOverCapacity \u003d csConfig.getDouble(\n         CapacitySchedulerConfiguration.PREEMPTION_MAX_IGNORED_OVER_CAPACITY,\n         CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_MAX_IGNORED_OVER_CAPACITY);\n \n     naturalTerminationFactor \u003d csConfig.getDouble(\n         CapacitySchedulerConfiguration.PREEMPTION_NATURAL_TERMINATION_FACTOR,\n         CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_NATURAL_TERMINATION_FACTOR);\n \n     maxWaitTime \u003d csConfig.getLong(\n         CapacitySchedulerConfiguration.PREEMPTION_WAIT_TIME_BEFORE_KILL,\n         CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_WAIT_TIME_BEFORE_KILL);\n \n     monitoringInterval \u003d csConfig.getLong(\n         CapacitySchedulerConfiguration.PREEMPTION_MONITORING_INTERVAL,\n         CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_MONITORING_INTERVAL);\n \n     percentageClusterPreemptionAllowed \u003d csConfig.getFloat(\n         CapacitySchedulerConfiguration.TOTAL_PREEMPTION_PER_ROUND,\n         CapacitySchedulerConfiguration.DEFAULT_TOTAL_PREEMPTION_PER_ROUND);\n \n     observeOnly \u003d csConfig.getBoolean(\n         CapacitySchedulerConfiguration.PREEMPTION_OBSERVE_ONLY,\n         CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_OBSERVE_ONLY);\n \n     lazyPreempionEnabled \u003d csConfig.getBoolean(\n         CapacitySchedulerConfiguration.LAZY_PREEMPTION_ENALBED,\n         CapacitySchedulerConfiguration.DEFAULT_LAZY_PREEMPTION_ENABLED);\n \n     rc \u003d scheduler.getResourceCalculator();\n     nlm \u003d scheduler.getRMContext().getNodeLabelManager();\n \n+    // Do we need to specially consider reserved containers?\n+    boolean selectCandidatesForResevedContainers \u003d csConfig.getBoolean(\n+        CapacitySchedulerConfiguration.PREEMPTION_SELECT_CANDIDATES_FOR_RESERVED_CONTAINERS,\n+        CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_SELECT_CANDIDATES_FOR_RESERVED_CONTAINERS);\n+    if (selectCandidatesForResevedContainers) {\n+      candidatesSelectionPolicies.add(\n+          new ReservedContainerCandidatesSelector(this));\n+    }\n+\n     // initialize candidates preemption selection policies\n     candidatesSelectionPolicies.add(\n         new FifoCandidatesSelector(this));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void init(Configuration config, RMContext context,\n      PreemptableResourceScheduler sched) {\n    LOG.info(\"Preemption monitor:\" + this.getClass().getCanonicalName());\n    assert null \u003d\u003d scheduler : \"Unexpected duplicate call to init\";\n    if (!(sched instanceof CapacityScheduler)) {\n      throw new YarnRuntimeException(\"Class \" +\n          sched.getClass().getCanonicalName() + \" not instance of \" +\n          CapacityScheduler.class.getCanonicalName());\n    }\n    rmContext \u003d context;\n    scheduler \u003d (CapacityScheduler) sched;\n    CapacitySchedulerConfiguration csConfig \u003d scheduler.getConfiguration();\n\n    maxIgnoredOverCapacity \u003d csConfig.getDouble(\n        CapacitySchedulerConfiguration.PREEMPTION_MAX_IGNORED_OVER_CAPACITY,\n        CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_MAX_IGNORED_OVER_CAPACITY);\n\n    naturalTerminationFactor \u003d csConfig.getDouble(\n        CapacitySchedulerConfiguration.PREEMPTION_NATURAL_TERMINATION_FACTOR,\n        CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_NATURAL_TERMINATION_FACTOR);\n\n    maxWaitTime \u003d csConfig.getLong(\n        CapacitySchedulerConfiguration.PREEMPTION_WAIT_TIME_BEFORE_KILL,\n        CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_WAIT_TIME_BEFORE_KILL);\n\n    monitoringInterval \u003d csConfig.getLong(\n        CapacitySchedulerConfiguration.PREEMPTION_MONITORING_INTERVAL,\n        CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_MONITORING_INTERVAL);\n\n    percentageClusterPreemptionAllowed \u003d csConfig.getFloat(\n        CapacitySchedulerConfiguration.TOTAL_PREEMPTION_PER_ROUND,\n        CapacitySchedulerConfiguration.DEFAULT_TOTAL_PREEMPTION_PER_ROUND);\n\n    observeOnly \u003d csConfig.getBoolean(\n        CapacitySchedulerConfiguration.PREEMPTION_OBSERVE_ONLY,\n        CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_OBSERVE_ONLY);\n\n    lazyPreempionEnabled \u003d csConfig.getBoolean(\n        CapacitySchedulerConfiguration.LAZY_PREEMPTION_ENALBED,\n        CapacitySchedulerConfiguration.DEFAULT_LAZY_PREEMPTION_ENABLED);\n\n    rc \u003d scheduler.getResourceCalculator();\n    nlm \u003d scheduler.getRMContext().getNodeLabelManager();\n\n    // Do we need to specially consider reserved containers?\n    boolean selectCandidatesForResevedContainers \u003d csConfig.getBoolean(\n        CapacitySchedulerConfiguration.PREEMPTION_SELECT_CANDIDATES_FOR_RESERVED_CONTAINERS,\n        CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_SELECT_CANDIDATES_FOR_RESERVED_CONTAINERS);\n    if (selectCandidatesForResevedContainers) {\n      candidatesSelectionPolicies.add(\n          new ReservedContainerCandidatesSelector(this));\n    }\n\n    // initialize candidates preemption selection policies\n    candidatesSelectionPolicies.add(\n        new FifoCandidatesSelector(this));\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java",
      "extendedDetails": {}
    },
    "60e4116bf1d00afed91010e57357fe54057e4e39": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4822. Refactor existing Preemption Policy of CS for easier adding new approach to select preemption candidates. Contributed by Wangda Tan\n",
      "commitDate": "30/03/16 12:43 PM",
      "commitName": "60e4116bf1d00afed91010e57357fe54057e4e39",
      "commitAuthor": "Jian He",
      "commitDateOld": "16/03/16 5:02 PM",
      "commitNameOld": "ae14e5d07f1b6702a5160637438028bb03d9387e",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 13.82,
      "commitsBetweenForRepo": 69,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,22 +1,48 @@\n   public void init(Configuration config, RMContext context,\n       PreemptableResourceScheduler sched) {\n     LOG.info(\"Preemption monitor:\" + this.getClass().getCanonicalName());\n     assert null \u003d\u003d scheduler : \"Unexpected duplicate call to init\";\n     if (!(sched instanceof CapacityScheduler)) {\n       throw new YarnRuntimeException(\"Class \" +\n           sched.getClass().getCanonicalName() + \" not instance of \" +\n           CapacityScheduler.class.getCanonicalName());\n     }\n     rmContext \u003d context;\n     scheduler \u003d (CapacityScheduler) sched;\n-    maxIgnoredOverCapacity \u003d config.getDouble(MAX_IGNORED_OVER_CAPACITY, 0.1);\n-    naturalTerminationFactor \u003d\n-      config.getDouble(NATURAL_TERMINATION_FACTOR, 0.2);\n-    maxWaitTime \u003d config.getLong(WAIT_TIME_BEFORE_KILL, 15000);\n-    monitoringInterval \u003d config.getLong(MONITORING_INTERVAL, 3000);\n-    percentageClusterPreemptionAllowed \u003d\n-      config.getFloat(TOTAL_PREEMPTION_PER_ROUND, (float) 0.1);\n-    observeOnly \u003d config.getBoolean(OBSERVE_ONLY, false);\n+    CapacitySchedulerConfiguration csConfig \u003d scheduler.getConfiguration();\n+\n+    maxIgnoredOverCapacity \u003d csConfig.getDouble(\n+        CapacitySchedulerConfiguration.PREEMPTION_MAX_IGNORED_OVER_CAPACITY,\n+        CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_MAX_IGNORED_OVER_CAPACITY);\n+\n+    naturalTerminationFactor \u003d csConfig.getDouble(\n+        CapacitySchedulerConfiguration.PREEMPTION_NATURAL_TERMINATION_FACTOR,\n+        CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_NATURAL_TERMINATION_FACTOR);\n+\n+    maxWaitTime \u003d csConfig.getLong(\n+        CapacitySchedulerConfiguration.PREEMPTION_WAIT_TIME_BEFORE_KILL,\n+        CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_WAIT_TIME_BEFORE_KILL);\n+\n+    monitoringInterval \u003d csConfig.getLong(\n+        CapacitySchedulerConfiguration.PREEMPTION_MONITORING_INTERVAL,\n+        CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_MONITORING_INTERVAL);\n+\n+    percentageClusterPreemptionAllowed \u003d csConfig.getFloat(\n+        CapacitySchedulerConfiguration.TOTAL_PREEMPTION_PER_ROUND,\n+        CapacitySchedulerConfiguration.DEFAULT_TOTAL_PREEMPTION_PER_ROUND);\n+\n+    observeOnly \u003d csConfig.getBoolean(\n+        CapacitySchedulerConfiguration.PREEMPTION_OBSERVE_ONLY,\n+        CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_OBSERVE_ONLY);\n+\n+    lazyPreempionEnabled \u003d csConfig.getBoolean(\n+        CapacitySchedulerConfiguration.LAZY_PREEMPTION_ENALBED,\n+        CapacitySchedulerConfiguration.DEFAULT_LAZY_PREEMPTION_ENABLED);\n+\n     rc \u003d scheduler.getResourceCalculator();\n     nlm \u003d scheduler.getRMContext().getNodeLabelManager();\n+\n+    // initialize candidates preemption selection policies\n+    candidatesSelectionPolicies.add(\n+        new FifoCandidatesSelector(this));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void init(Configuration config, RMContext context,\n      PreemptableResourceScheduler sched) {\n    LOG.info(\"Preemption monitor:\" + this.getClass().getCanonicalName());\n    assert null \u003d\u003d scheduler : \"Unexpected duplicate call to init\";\n    if (!(sched instanceof CapacityScheduler)) {\n      throw new YarnRuntimeException(\"Class \" +\n          sched.getClass().getCanonicalName() + \" not instance of \" +\n          CapacityScheduler.class.getCanonicalName());\n    }\n    rmContext \u003d context;\n    scheduler \u003d (CapacityScheduler) sched;\n    CapacitySchedulerConfiguration csConfig \u003d scheduler.getConfiguration();\n\n    maxIgnoredOverCapacity \u003d csConfig.getDouble(\n        CapacitySchedulerConfiguration.PREEMPTION_MAX_IGNORED_OVER_CAPACITY,\n        CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_MAX_IGNORED_OVER_CAPACITY);\n\n    naturalTerminationFactor \u003d csConfig.getDouble(\n        CapacitySchedulerConfiguration.PREEMPTION_NATURAL_TERMINATION_FACTOR,\n        CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_NATURAL_TERMINATION_FACTOR);\n\n    maxWaitTime \u003d csConfig.getLong(\n        CapacitySchedulerConfiguration.PREEMPTION_WAIT_TIME_BEFORE_KILL,\n        CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_WAIT_TIME_BEFORE_KILL);\n\n    monitoringInterval \u003d csConfig.getLong(\n        CapacitySchedulerConfiguration.PREEMPTION_MONITORING_INTERVAL,\n        CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_MONITORING_INTERVAL);\n\n    percentageClusterPreemptionAllowed \u003d csConfig.getFloat(\n        CapacitySchedulerConfiguration.TOTAL_PREEMPTION_PER_ROUND,\n        CapacitySchedulerConfiguration.DEFAULT_TOTAL_PREEMPTION_PER_ROUND);\n\n    observeOnly \u003d csConfig.getBoolean(\n        CapacitySchedulerConfiguration.PREEMPTION_OBSERVE_ONLY,\n        CapacitySchedulerConfiguration.DEFAULT_PREEMPTION_OBSERVE_ONLY);\n\n    lazyPreempionEnabled \u003d csConfig.getBoolean(\n        CapacitySchedulerConfiguration.LAZY_PREEMPTION_ENALBED,\n        CapacitySchedulerConfiguration.DEFAULT_LAZY_PREEMPTION_ENABLED);\n\n    rc \u003d scheduler.getResourceCalculator();\n    nlm \u003d scheduler.getRMContext().getNodeLabelManager();\n\n    // initialize candidates preemption selection policies\n    candidatesSelectionPolicies.add(\n        new FifoCandidatesSelector(this));\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java",
      "extendedDetails": {}
    },
    "0e4b06690ff51fbde3ab26f68fde8aeb32af69af": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-3508. Prevent processing preemption events on the main RM dispatcher. (Varun Saxena via wangda)\n",
      "commitDate": "01/07/15 5:32 PM",
      "commitName": "0e4b06690ff51fbde3ab26f68fde8aeb32af69af",
      "commitAuthor": "Wangda Tan",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-3508. Prevent processing preemption events on the main RM dispatcher. (Varun Saxena via wangda)\n",
          "commitDate": "01/07/15 5:32 PM",
          "commitName": "0e4b06690ff51fbde3ab26f68fde8aeb32af69af",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "24/04/15 5:03 PM",
          "commitNameOld": "d497f6ea2be559aa31ed76f37ae949dbfabe2a51",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 68.02,
          "commitsBetweenForRepo": 597,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,23 +1,22 @@\n-  public void init(Configuration config,\n-      EventHandler\u003cContainerPreemptEvent\u003e disp,\n+  public void init(Configuration config, RMContext context,\n       PreemptableResourceScheduler sched) {\n     LOG.info(\"Preemption monitor:\" + this.getClass().getCanonicalName());\n     assert null \u003d\u003d scheduler : \"Unexpected duplicate call to init\";\n     if (!(sched instanceof CapacityScheduler)) {\n       throw new YarnRuntimeException(\"Class \" +\n           sched.getClass().getCanonicalName() + \" not instance of \" +\n           CapacityScheduler.class.getCanonicalName());\n     }\n-    dispatcher \u003d disp;\n+    rmContext \u003d context;\n     scheduler \u003d (CapacityScheduler) sched;\n     maxIgnoredOverCapacity \u003d config.getDouble(MAX_IGNORED_OVER_CAPACITY, 0.1);\n     naturalTerminationFactor \u003d\n       config.getDouble(NATURAL_TERMINATION_FACTOR, 0.2);\n     maxWaitTime \u003d config.getLong(WAIT_TIME_BEFORE_KILL, 15000);\n     monitoringInterval \u003d config.getLong(MONITORING_INTERVAL, 3000);\n     percentageClusterPreemptionAllowed \u003d\n       config.getFloat(TOTAL_PREEMPTION_PER_ROUND, (float) 0.1);\n     observeOnly \u003d config.getBoolean(OBSERVE_ONLY, false);\n     rc \u003d scheduler.getResourceCalculator();\n     nlm \u003d scheduler.getRMContext().getNodeLabelManager();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void init(Configuration config, RMContext context,\n      PreemptableResourceScheduler sched) {\n    LOG.info(\"Preemption monitor:\" + this.getClass().getCanonicalName());\n    assert null \u003d\u003d scheduler : \"Unexpected duplicate call to init\";\n    if (!(sched instanceof CapacityScheduler)) {\n      throw new YarnRuntimeException(\"Class \" +\n          sched.getClass().getCanonicalName() + \" not instance of \" +\n          CapacityScheduler.class.getCanonicalName());\n    }\n    rmContext \u003d context;\n    scheduler \u003d (CapacityScheduler) sched;\n    maxIgnoredOverCapacity \u003d config.getDouble(MAX_IGNORED_OVER_CAPACITY, 0.1);\n    naturalTerminationFactor \u003d\n      config.getDouble(NATURAL_TERMINATION_FACTOR, 0.2);\n    maxWaitTime \u003d config.getLong(WAIT_TIME_BEFORE_KILL, 15000);\n    monitoringInterval \u003d config.getLong(MONITORING_INTERVAL, 3000);\n    percentageClusterPreemptionAllowed \u003d\n      config.getFloat(TOTAL_PREEMPTION_PER_ROUND, (float) 0.1);\n    observeOnly \u003d config.getBoolean(OBSERVE_ONLY, false);\n    rc \u003d scheduler.getResourceCalculator();\n    nlm \u003d scheduler.getRMContext().getNodeLabelManager();\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java",
          "extendedDetails": {
            "oldValue": "[config-Configuration, disp-EventHandler\u003cContainerPreemptEvent\u003e, sched-PreemptableResourceScheduler]",
            "newValue": "[config-Configuration, context-RMContext, sched-PreemptableResourceScheduler]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-3508. Prevent processing preemption events on the main RM dispatcher. (Varun Saxena via wangda)\n",
          "commitDate": "01/07/15 5:32 PM",
          "commitName": "0e4b06690ff51fbde3ab26f68fde8aeb32af69af",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "24/04/15 5:03 PM",
          "commitNameOld": "d497f6ea2be559aa31ed76f37ae949dbfabe2a51",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 68.02,
          "commitsBetweenForRepo": 597,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,23 +1,22 @@\n-  public void init(Configuration config,\n-      EventHandler\u003cContainerPreemptEvent\u003e disp,\n+  public void init(Configuration config, RMContext context,\n       PreemptableResourceScheduler sched) {\n     LOG.info(\"Preemption monitor:\" + this.getClass().getCanonicalName());\n     assert null \u003d\u003d scheduler : \"Unexpected duplicate call to init\";\n     if (!(sched instanceof CapacityScheduler)) {\n       throw new YarnRuntimeException(\"Class \" +\n           sched.getClass().getCanonicalName() + \" not instance of \" +\n           CapacityScheduler.class.getCanonicalName());\n     }\n-    dispatcher \u003d disp;\n+    rmContext \u003d context;\n     scheduler \u003d (CapacityScheduler) sched;\n     maxIgnoredOverCapacity \u003d config.getDouble(MAX_IGNORED_OVER_CAPACITY, 0.1);\n     naturalTerminationFactor \u003d\n       config.getDouble(NATURAL_TERMINATION_FACTOR, 0.2);\n     maxWaitTime \u003d config.getLong(WAIT_TIME_BEFORE_KILL, 15000);\n     monitoringInterval \u003d config.getLong(MONITORING_INTERVAL, 3000);\n     percentageClusterPreemptionAllowed \u003d\n       config.getFloat(TOTAL_PREEMPTION_PER_ROUND, (float) 0.1);\n     observeOnly \u003d config.getBoolean(OBSERVE_ONLY, false);\n     rc \u003d scheduler.getResourceCalculator();\n     nlm \u003d scheduler.getRMContext().getNodeLabelManager();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void init(Configuration config, RMContext context,\n      PreemptableResourceScheduler sched) {\n    LOG.info(\"Preemption monitor:\" + this.getClass().getCanonicalName());\n    assert null \u003d\u003d scheduler : \"Unexpected duplicate call to init\";\n    if (!(sched instanceof CapacityScheduler)) {\n      throw new YarnRuntimeException(\"Class \" +\n          sched.getClass().getCanonicalName() + \" not instance of \" +\n          CapacityScheduler.class.getCanonicalName());\n    }\n    rmContext \u003d context;\n    scheduler \u003d (CapacityScheduler) sched;\n    maxIgnoredOverCapacity \u003d config.getDouble(MAX_IGNORED_OVER_CAPACITY, 0.1);\n    naturalTerminationFactor \u003d\n      config.getDouble(NATURAL_TERMINATION_FACTOR, 0.2);\n    maxWaitTime \u003d config.getLong(WAIT_TIME_BEFORE_KILL, 15000);\n    monitoringInterval \u003d config.getLong(MONITORING_INTERVAL, 3000);\n    percentageClusterPreemptionAllowed \u003d\n      config.getFloat(TOTAL_PREEMPTION_PER_ROUND, (float) 0.1);\n    observeOnly \u003d config.getBoolean(OBSERVE_ONLY, false);\n    rc \u003d scheduler.getResourceCalculator();\n    nlm \u003d scheduler.getRMContext().getNodeLabelManager();\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java",
          "extendedDetails": {}
        }
      ]
    },
    "d497f6ea2be559aa31ed76f37ae949dbfabe2a51": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2498. Respect labels in preemption policy of capacity scheduler for inter-queue preemption. Contributed by Wangda Tan\n",
      "commitDate": "24/04/15 5:03 PM",
      "commitName": "d497f6ea2be559aa31ed76f37ae949dbfabe2a51",
      "commitAuthor": "Jian He",
      "commitDateOld": "20/04/15 5:12 PM",
      "commitNameOld": "44872b76fcc0ddfbc7b0a4e54eef50fe8708e0f5",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 3.99,
      "commitsBetweenForRepo": 60,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,23 +1,23 @@\n   public void init(Configuration config,\n       EventHandler\u003cContainerPreemptEvent\u003e disp,\n       PreemptableResourceScheduler sched) {\n     LOG.info(\"Preemption monitor:\" + this.getClass().getCanonicalName());\n     assert null \u003d\u003d scheduler : \"Unexpected duplicate call to init\";\n     if (!(sched instanceof CapacityScheduler)) {\n       throw new YarnRuntimeException(\"Class \" +\n           sched.getClass().getCanonicalName() + \" not instance of \" +\n           CapacityScheduler.class.getCanonicalName());\n     }\n     dispatcher \u003d disp;\n     scheduler \u003d (CapacityScheduler) sched;\n     maxIgnoredOverCapacity \u003d config.getDouble(MAX_IGNORED_OVER_CAPACITY, 0.1);\n     naturalTerminationFactor \u003d\n       config.getDouble(NATURAL_TERMINATION_FACTOR, 0.2);\n     maxWaitTime \u003d config.getLong(WAIT_TIME_BEFORE_KILL, 15000);\n     monitoringInterval \u003d config.getLong(MONITORING_INTERVAL, 3000);\n     percentageClusterPreemptionAllowed \u003d\n       config.getFloat(TOTAL_PREEMPTION_PER_ROUND, (float) 0.1);\n     observeOnly \u003d config.getBoolean(OBSERVE_ONLY, false);\n     rc \u003d scheduler.getResourceCalculator();\n-    labels \u003d null;\n+    nlm \u003d scheduler.getRMContext().getNodeLabelManager();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void init(Configuration config,\n      EventHandler\u003cContainerPreemptEvent\u003e disp,\n      PreemptableResourceScheduler sched) {\n    LOG.info(\"Preemption monitor:\" + this.getClass().getCanonicalName());\n    assert null \u003d\u003d scheduler : \"Unexpected duplicate call to init\";\n    if (!(sched instanceof CapacityScheduler)) {\n      throw new YarnRuntimeException(\"Class \" +\n          sched.getClass().getCanonicalName() + \" not instance of \" +\n          CapacityScheduler.class.getCanonicalName());\n    }\n    dispatcher \u003d disp;\n    scheduler \u003d (CapacityScheduler) sched;\n    maxIgnoredOverCapacity \u003d config.getDouble(MAX_IGNORED_OVER_CAPACITY, 0.1);\n    naturalTerminationFactor \u003d\n      config.getDouble(NATURAL_TERMINATION_FACTOR, 0.2);\n    maxWaitTime \u003d config.getLong(WAIT_TIME_BEFORE_KILL, 15000);\n    monitoringInterval \u003d config.getLong(MONITORING_INTERVAL, 3000);\n    percentageClusterPreemptionAllowed \u003d\n      config.getFloat(TOTAL_PREEMPTION_PER_ROUND, (float) 0.1);\n    observeOnly \u003d config.getBoolean(OBSERVE_ONLY, false);\n    rc \u003d scheduler.getResourceCalculator();\n    nlm \u003d scheduler.getRMContext().getNodeLabelManager();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java",
      "extendedDetails": {}
    },
    "0a2d3e717d9c42090a32ff177991a222a1e34132": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2933. Capacity Scheduler preemption policy should only consider capacity without labels temporarily. Contributed by Mayank Bansal\n",
      "commitDate": "19/01/15 4:48 PM",
      "commitName": "0a2d3e717d9c42090a32ff177991a222a1e34132",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "05/12/14 1:06 PM",
      "commitNameOld": "4b130821995a3cfe20c71e38e0f63294085c0491",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 45.15,
      "commitsBetweenForRepo": 253,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,22 +1,23 @@\n   public void init(Configuration config,\n       EventHandler\u003cContainerPreemptEvent\u003e disp,\n       PreemptableResourceScheduler sched) {\n     LOG.info(\"Preemption monitor:\" + this.getClass().getCanonicalName());\n     assert null \u003d\u003d scheduler : \"Unexpected duplicate call to init\";\n     if (!(sched instanceof CapacityScheduler)) {\n       throw new YarnRuntimeException(\"Class \" +\n           sched.getClass().getCanonicalName() + \" not instance of \" +\n           CapacityScheduler.class.getCanonicalName());\n     }\n     dispatcher \u003d disp;\n     scheduler \u003d (CapacityScheduler) sched;\n     maxIgnoredOverCapacity \u003d config.getDouble(MAX_IGNORED_OVER_CAPACITY, 0.1);\n     naturalTerminationFactor \u003d\n       config.getDouble(NATURAL_TERMINATION_FACTOR, 0.2);\n     maxWaitTime \u003d config.getLong(WAIT_TIME_BEFORE_KILL, 15000);\n     monitoringInterval \u003d config.getLong(MONITORING_INTERVAL, 3000);\n     percentageClusterPreemptionAllowed \u003d\n       config.getFloat(TOTAL_PREEMPTION_PER_ROUND, (float) 0.1);\n     observeOnly \u003d config.getBoolean(OBSERVE_ONLY, false);\n     rc \u003d scheduler.getResourceCalculator();\n+    labels \u003d null;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void init(Configuration config,\n      EventHandler\u003cContainerPreemptEvent\u003e disp,\n      PreemptableResourceScheduler sched) {\n    LOG.info(\"Preemption monitor:\" + this.getClass().getCanonicalName());\n    assert null \u003d\u003d scheduler : \"Unexpected duplicate call to init\";\n    if (!(sched instanceof CapacityScheduler)) {\n      throw new YarnRuntimeException(\"Class \" +\n          sched.getClass().getCanonicalName() + \" not instance of \" +\n          CapacityScheduler.class.getCanonicalName());\n    }\n    dispatcher \u003d disp;\n    scheduler \u003d (CapacityScheduler) sched;\n    maxIgnoredOverCapacity \u003d config.getDouble(MAX_IGNORED_OVER_CAPACITY, 0.1);\n    naturalTerminationFactor \u003d\n      config.getDouble(NATURAL_TERMINATION_FACTOR, 0.2);\n    maxWaitTime \u003d config.getLong(WAIT_TIME_BEFORE_KILL, 15000);\n    monitoringInterval \u003d config.getLong(MONITORING_INTERVAL, 3000);\n    percentageClusterPreemptionAllowed \u003d\n      config.getFloat(TOTAL_PREEMPTION_PER_ROUND, (float) 0.1);\n    observeOnly \u003d config.getBoolean(OBSERVE_ONLY, false);\n    rc \u003d scheduler.getResourceCalculator();\n    labels \u003d null;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java",
      "extendedDetails": {}
    },
    "85f0efb68f9d1d9ee3466e3939c4fc2f985ccf61": {
      "type": "Yintroduced",
      "commitMessage": "YARN-569. Add support for requesting and enforcing preemption requests via\na capacity monitor. Contributed by Carlo Curino, Chris Douglas\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1502083 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/07/13 6:20 PM",
      "commitName": "85f0efb68f9d1d9ee3466e3939c4fc2f985ccf61",
      "commitAuthor": "Christopher Douglas",
      "diff": "@@ -0,0 +1,22 @@\n+  public void init(Configuration config,\n+      EventHandler\u003cContainerPreemptEvent\u003e disp,\n+      PreemptableResourceScheduler sched) {\n+    LOG.info(\"Preemption monitor:\" + this.getClass().getCanonicalName());\n+    assert null \u003d\u003d scheduler : \"Unexpected duplicate call to init\";\n+    if (!(sched instanceof CapacityScheduler)) {\n+      throw new YarnRuntimeException(\"Class \" +\n+          sched.getClass().getCanonicalName() + \" not instance of \" +\n+          CapacityScheduler.class.getCanonicalName());\n+    }\n+    dispatcher \u003d disp;\n+    scheduler \u003d (CapacityScheduler) sched;\n+    maxIgnoredOverCapacity \u003d config.getDouble(MAX_IGNORED_OVER_CAPACITY, 0.1);\n+    naturalTerminationFactor \u003d\n+      config.getDouble(NATURAL_TERMINATION_FACTOR, 0.2);\n+    maxWaitTime \u003d config.getLong(WAIT_TIME_BEFORE_KILL, 15000);\n+    monitoringInterval \u003d config.getLong(MONITORING_INTERVAL, 3000);\n+    percentageClusterPreemptionAllowed \u003d\n+      config.getFloat(TOTAL_PREEMPTION_PER_ROUND, (float) 0.1);\n+    observeOnly \u003d config.getBoolean(OBSERVE_ONLY, false);\n+    rc \u003d scheduler.getResourceCalculator();\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void init(Configuration config,\n      EventHandler\u003cContainerPreemptEvent\u003e disp,\n      PreemptableResourceScheduler sched) {\n    LOG.info(\"Preemption monitor:\" + this.getClass().getCanonicalName());\n    assert null \u003d\u003d scheduler : \"Unexpected duplicate call to init\";\n    if (!(sched instanceof CapacityScheduler)) {\n      throw new YarnRuntimeException(\"Class \" +\n          sched.getClass().getCanonicalName() + \" not instance of \" +\n          CapacityScheduler.class.getCanonicalName());\n    }\n    dispatcher \u003d disp;\n    scheduler \u003d (CapacityScheduler) sched;\n    maxIgnoredOverCapacity \u003d config.getDouble(MAX_IGNORED_OVER_CAPACITY, 0.1);\n    naturalTerminationFactor \u003d\n      config.getDouble(NATURAL_TERMINATION_FACTOR, 0.2);\n    maxWaitTime \u003d config.getLong(WAIT_TIME_BEFORE_KILL, 15000);\n    monitoringInterval \u003d config.getLong(MONITORING_INTERVAL, 3000);\n    percentageClusterPreemptionAllowed \u003d\n      config.getFloat(TOTAL_PREEMPTION_PER_ROUND, (float) 0.1);\n    observeOnly \u003d config.getBoolean(OBSERVE_ONLY, false);\n    rc \u003d scheduler.getResourceCalculator();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java"
    }
  }
}