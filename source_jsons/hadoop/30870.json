{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "CosmosDBDocumentStoreWriter.java",
  "functionName": "upsertDocument",
  "functionId": "upsertDocument___collectionType-CollectionType(modifiers-final)__timelineDoc-TimelineDoc(modifiers-final)",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice-documentstore/src/main/java/org/apache/hadoop/yarn/server/timelineservice/documentstore/writer/cosmosdb/CosmosDBDocumentStoreWriter.java",
  "functionStartLine": 187,
  "functionEndLine": 224,
  "numCommitsSeen": 3,
  "timeTaken": 1041,
  "changeHistory": [
    "ccaa99c9235e0c6922e56f93254583eca49a12e1",
    "f235a942d5b7cab86f0cb4f5ba285f07cd939a40"
  ],
  "changeHistoryShort": {
    "ccaa99c9235e0c6922e56f93254583eca49a12e1": "Ybodychange",
    "f235a942d5b7cab86f0cb4f5ba285f07cd939a40": "Yintroduced"
  },
  "changeHistoryDetails": {
    "ccaa99c9235e0c6922e56f93254583eca49a12e1": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16381. The JSON License is included in binary tarball via azure-documentdb:1.16.2. Contributed by Sushil Ks.\n",
      "commitDate": "10/07/19 9:49 PM",
      "commitName": "ccaa99c9235e0c6922e56f93254583eca49a12e1",
      "commitAuthor": "Akira Ajisaka",
      "commitDateOld": "12/04/19 6:28 PM",
      "commitNameOld": "1943db557124439f9f41c18a618455ccf4c3e6cc",
      "commitAuthorOld": "Gabor Bota",
      "daysBetweenCommits": 89.14,
      "commitsBetweenForRepo": 592,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,31 +1,38 @@\n   private void upsertDocument(final  CollectionType collectionType,\n       final TimelineDoc timelineDoc) {\n     final String collectionLink \u003d String.format(COLLECTION_LINK, databaseName,\n         collectionType.getCollectionName());\n     RequestOptions requestOptions  \u003d new RequestOptions();\n     AccessCondition accessCondition \u003d new AccessCondition();\n     StringBuilder eTagStrBuilder \u003d new StringBuilder();\n \n-    TimelineDoc updatedTimelineDoc \u003d applyUpdatesOnPrevDoc(collectionType,\n+    final TimelineDoc updatedTimelineDoc \u003d applyUpdatesOnPrevDoc(collectionType,\n         timelineDoc, eTagStrBuilder);\n \n     accessCondition.setCondition(eTagStrBuilder.toString());\n     accessCondition.setType(AccessConditionType.IfMatch);\n     requestOptions.setAccessCondition(accessCondition);\n \n-    try {\n-      client.upsertDocument(collectionLink, updatedTimelineDoc,\n-          requestOptions, true);\n+    ResourceResponse\u003cDocument\u003e resourceResponse \u003d\n+        client.upsertDocument(collectionLink, updatedTimelineDoc,\n+            requestOptions, true)\n+            .subscribeOn(schedulerForBlockingWork)\n+            .doOnError(throwable -\u003e\n+                LOG.error(\"Error while upserting Collection : {} \" +\n+                    \"with Doc Id : {} under Database : {}\",\n+                collectionType.getCollectionName(),\n+                updatedTimelineDoc.getId(), databaseName, throwable))\n+            .toBlocking()\n+            .single();\n+\n+    if (resourceResponse.getStatusCode() \u003d\u003d 409) {\n+      LOG.warn(\"There was a conflict while upserting, hence retrying...\",\n+          resourceResponse);\n+      upsertDocument(collectionType, updatedTimelineDoc);\n+    } else if (resourceResponse.getStatusCode() \u003e\u003d 200 \u0026\u0026 resourceResponse\n+        .getStatusCode() \u003c 300) {\n       LOG.debug(\"Successfully wrote doc with id : {} and type : {} under \" +\n           \"Database : {}\", timelineDoc.getId(), timelineDoc.getType(),\n           databaseName);\n-    } catch (DocumentClientException e) {\n-      if (e.getStatusCode() \u003d\u003d 409) {\n-        LOG.warn(\"There was a conflict while upserting, hence retrying...\", e);\n-        upsertDocument(collectionType, updatedTimelineDoc);\n-      }\n-      LOG.error(\"Error while upserting Collection : {} with Doc Id : {} under\" +\n-          \" Database : {}\", collectionType.getCollectionName(),\n-          updatedTimelineDoc.getId(), databaseName, e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void upsertDocument(final  CollectionType collectionType,\n      final TimelineDoc timelineDoc) {\n    final String collectionLink \u003d String.format(COLLECTION_LINK, databaseName,\n        collectionType.getCollectionName());\n    RequestOptions requestOptions  \u003d new RequestOptions();\n    AccessCondition accessCondition \u003d new AccessCondition();\n    StringBuilder eTagStrBuilder \u003d new StringBuilder();\n\n    final TimelineDoc updatedTimelineDoc \u003d applyUpdatesOnPrevDoc(collectionType,\n        timelineDoc, eTagStrBuilder);\n\n    accessCondition.setCondition(eTagStrBuilder.toString());\n    accessCondition.setType(AccessConditionType.IfMatch);\n    requestOptions.setAccessCondition(accessCondition);\n\n    ResourceResponse\u003cDocument\u003e resourceResponse \u003d\n        client.upsertDocument(collectionLink, updatedTimelineDoc,\n            requestOptions, true)\n            .subscribeOn(schedulerForBlockingWork)\n            .doOnError(throwable -\u003e\n                LOG.error(\"Error while upserting Collection : {} \" +\n                    \"with Doc Id : {} under Database : {}\",\n                collectionType.getCollectionName(),\n                updatedTimelineDoc.getId(), databaseName, throwable))\n            .toBlocking()\n            .single();\n\n    if (resourceResponse.getStatusCode() \u003d\u003d 409) {\n      LOG.warn(\"There was a conflict while upserting, hence retrying...\",\n          resourceResponse);\n      upsertDocument(collectionType, updatedTimelineDoc);\n    } else if (resourceResponse.getStatusCode() \u003e\u003d 200 \u0026\u0026 resourceResponse\n        .getStatusCode() \u003c 300) {\n      LOG.debug(\"Successfully wrote doc with id : {} and type : {} under \" +\n          \"Database : {}\", timelineDoc.getId(), timelineDoc.getType(),\n          databaseName);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice-documentstore/src/main/java/org/apache/hadoop/yarn/server/timelineservice/documentstore/writer/cosmosdb/CosmosDBDocumentStoreWriter.java",
      "extendedDetails": {}
    },
    "f235a942d5b7cab86f0cb4f5ba285f07cd939a40": {
      "type": "Yintroduced",
      "commitMessage": "YARN-9016 DocumentStore as a backend for ATSv2. Contributed by Sushil Ks.\n",
      "commitDate": "13/03/19 4:45 PM",
      "commitName": "f235a942d5b7cab86f0cb4f5ba285f07cd939a40",
      "commitAuthor": "Vrushali C",
      "diff": "@@ -0,0 +1,31 @@\n+  private void upsertDocument(final  CollectionType collectionType,\n+      final TimelineDoc timelineDoc) {\n+    final String collectionLink \u003d String.format(COLLECTION_LINK, databaseName,\n+        collectionType.getCollectionName());\n+    RequestOptions requestOptions  \u003d new RequestOptions();\n+    AccessCondition accessCondition \u003d new AccessCondition();\n+    StringBuilder eTagStrBuilder \u003d new StringBuilder();\n+\n+    TimelineDoc updatedTimelineDoc \u003d applyUpdatesOnPrevDoc(collectionType,\n+        timelineDoc, eTagStrBuilder);\n+\n+    accessCondition.setCondition(eTagStrBuilder.toString());\n+    accessCondition.setType(AccessConditionType.IfMatch);\n+    requestOptions.setAccessCondition(accessCondition);\n+\n+    try {\n+      client.upsertDocument(collectionLink, updatedTimelineDoc,\n+          requestOptions, true);\n+      LOG.debug(\"Successfully wrote doc with id : {} and type : {} under \" +\n+          \"Database : {}\", timelineDoc.getId(), timelineDoc.getType(),\n+          databaseName);\n+    } catch (DocumentClientException e) {\n+      if (e.getStatusCode() \u003d\u003d 409) {\n+        LOG.warn(\"There was a conflict while upserting, hence retrying...\", e);\n+        upsertDocument(collectionType, updatedTimelineDoc);\n+      }\n+      LOG.error(\"Error while upserting Collection : {} with Doc Id : {} under\" +\n+          \" Database : {}\", collectionType.getCollectionName(),\n+          updatedTimelineDoc.getId(), databaseName, e);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void upsertDocument(final  CollectionType collectionType,\n      final TimelineDoc timelineDoc) {\n    final String collectionLink \u003d String.format(COLLECTION_LINK, databaseName,\n        collectionType.getCollectionName());\n    RequestOptions requestOptions  \u003d new RequestOptions();\n    AccessCondition accessCondition \u003d new AccessCondition();\n    StringBuilder eTagStrBuilder \u003d new StringBuilder();\n\n    TimelineDoc updatedTimelineDoc \u003d applyUpdatesOnPrevDoc(collectionType,\n        timelineDoc, eTagStrBuilder);\n\n    accessCondition.setCondition(eTagStrBuilder.toString());\n    accessCondition.setType(AccessConditionType.IfMatch);\n    requestOptions.setAccessCondition(accessCondition);\n\n    try {\n      client.upsertDocument(collectionLink, updatedTimelineDoc,\n          requestOptions, true);\n      LOG.debug(\"Successfully wrote doc with id : {} and type : {} under \" +\n          \"Database : {}\", timelineDoc.getId(), timelineDoc.getType(),\n          databaseName);\n    } catch (DocumentClientException e) {\n      if (e.getStatusCode() \u003d\u003d 409) {\n        LOG.warn(\"There was a conflict while upserting, hence retrying...\", e);\n        upsertDocument(collectionType, updatedTimelineDoc);\n      }\n      LOG.error(\"Error while upserting Collection : {} with Doc Id : {} under\" +\n          \" Database : {}\", collectionType.getCollectionName(),\n          updatedTimelineDoc.getId(), databaseName, e);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice-documentstore/src/main/java/org/apache/hadoop/yarn/server/timelineservice/documentstore/writer/cosmosdb/CosmosDBDocumentStoreWriter.java"
    }
  }
}