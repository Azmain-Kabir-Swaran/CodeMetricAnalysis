{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "AbfsClientThrottlingAnalyzer.java",
  "functionName": "analyzeMetricsAndUpdateSleepDuration",
  "functionId": "analyzeMetricsAndUpdateSleepDuration___metrics-AbfsOperationMetrics__sleepDuration-int",
  "sourceFilePath": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/services/AbfsClientThrottlingAnalyzer.java",
  "functionStartLine": 134,
  "functionEndLine": 214,
  "numCommitsSeen": 1,
  "timeTaken": 571,
  "changeHistory": [
    "97f06b3fc70ad509e601076c015bc244daa1243f"
  ],
  "changeHistoryShort": {
    "97f06b3fc70ad509e601076c015bc244daa1243f": "Yintroduced"
  },
  "changeHistoryDetails": {
    "97f06b3fc70ad509e601076c015bc244daa1243f": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-15703. ABFS - Implement client-side throttling.\nContributed by Sneha Varma and Thomas Marquardt.\n",
      "commitDate": "17/09/18 12:54 PM",
      "commitName": "97f06b3fc70ad509e601076c015bc244daa1243f",
      "commitAuthor": "Thomas Marquardt",
      "diff": "@@ -0,0 +1,81 @@\n+  private int analyzeMetricsAndUpdateSleepDuration(AbfsOperationMetrics metrics,\n+                                                   int sleepDuration) {\n+    final double percentageConversionFactor \u003d 100;\n+    double bytesFailed \u003d metrics.bytesFailed.get();\n+    double bytesSuccessful \u003d metrics.bytesSuccessful.get();\n+    double operationsFailed \u003d metrics.operationsFailed.get();\n+    double operationsSuccessful \u003d metrics.operationsSuccessful.get();\n+    double errorPercentage \u003d (bytesFailed \u003c\u003d 0)\n+        ? 0\n+        : (percentageConversionFactor\n+        * bytesFailed\n+        / (bytesFailed + bytesSuccessful));\n+    long periodMs \u003d metrics.endTime - metrics.startTime;\n+\n+    double newSleepDuration;\n+\n+    if (errorPercentage \u003c MIN_ACCEPTABLE_ERROR_PERCENTAGE) {\n+      ++consecutiveNoErrorCount;\n+      // Decrease sleepDuration in order to increase throughput.\n+      double reductionFactor \u003d\n+          (consecutiveNoErrorCount * analysisPeriodMs\n+              \u003e\u003d RAPID_SLEEP_DECREASE_TRANSITION_PERIOD_MS)\n+              ? RAPID_SLEEP_DECREASE_FACTOR\n+              : SLEEP_DECREASE_FACTOR;\n+\n+      newSleepDuration \u003d sleepDuration * reductionFactor;\n+    } else if (errorPercentage \u003c MAX_EQUILIBRIUM_ERROR_PERCENTAGE) {\n+      // Do not modify sleepDuration in order to stabilize throughput.\n+      newSleepDuration \u003d sleepDuration;\n+    } else {\n+      // Increase sleepDuration in order to minimize error rate.\n+      consecutiveNoErrorCount \u003d 0;\n+\n+      // Increase sleep duration in order to reduce throughput and error rate.\n+      // First, calculate target throughput: bytesSuccessful / periodMs.\n+      // Next, calculate time required to send *all* data (assuming next period\n+      // is similar to previous) at the target throughput: (bytesSuccessful\n+      // + bytesFailed) * periodMs / bytesSuccessful. Next, subtract periodMs to\n+      // get the total additional delay needed.\n+      double additionalDelayNeeded \u003d 5 * analysisPeriodMs;\n+      if (bytesSuccessful \u003e 0) {\n+        additionalDelayNeeded \u003d (bytesSuccessful + bytesFailed)\n+            * periodMs\n+            / bytesSuccessful\n+            - periodMs;\n+      }\n+\n+      // amortize the additional delay needed across the estimated number of\n+      // requests during the next period\n+      newSleepDuration \u003d additionalDelayNeeded\n+          / (operationsFailed + operationsSuccessful);\n+\n+      final double maxSleepDuration \u003d analysisPeriodMs;\n+      final double minSleepDuration \u003d sleepDuration * SLEEP_INCREASE_FACTOR;\n+\n+      // Add 1 ms to avoid rounding down and to decrease proximity to the server\n+      // side ingress/egress limit.  Ensure that the new sleep duration is\n+      // larger than the current one to more quickly reduce the number of\n+      // errors.  Don\u0027t allow the sleep duration to grow unbounded, after a\n+      // certain point throttling won\u0027t help, for example, if there are far too\n+      // many tasks/containers/nodes no amount of throttling will help.\n+      newSleepDuration \u003d Math.max(newSleepDuration, minSleepDuration) + 1;\n+      newSleepDuration \u003d Math.min(newSleepDuration, maxSleepDuration);\n+    }\n+\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(String.format(\n+          \"%5.5s, %10d, %10d, %10d, %10d, %6.2f, %5d, %5d, %5d\",\n+          name,\n+          (int) bytesFailed,\n+          (int) bytesSuccessful,\n+          (int) operationsFailed,\n+          (int) operationsSuccessful,\n+          errorPercentage,\n+          periodMs,\n+          (int) sleepDuration,\n+          (int) newSleepDuration));\n+    }\n+\n+    return (int) newSleepDuration;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private int analyzeMetricsAndUpdateSleepDuration(AbfsOperationMetrics metrics,\n                                                   int sleepDuration) {\n    final double percentageConversionFactor \u003d 100;\n    double bytesFailed \u003d metrics.bytesFailed.get();\n    double bytesSuccessful \u003d metrics.bytesSuccessful.get();\n    double operationsFailed \u003d metrics.operationsFailed.get();\n    double operationsSuccessful \u003d metrics.operationsSuccessful.get();\n    double errorPercentage \u003d (bytesFailed \u003c\u003d 0)\n        ? 0\n        : (percentageConversionFactor\n        * bytesFailed\n        / (bytesFailed + bytesSuccessful));\n    long periodMs \u003d metrics.endTime - metrics.startTime;\n\n    double newSleepDuration;\n\n    if (errorPercentage \u003c MIN_ACCEPTABLE_ERROR_PERCENTAGE) {\n      ++consecutiveNoErrorCount;\n      // Decrease sleepDuration in order to increase throughput.\n      double reductionFactor \u003d\n          (consecutiveNoErrorCount * analysisPeriodMs\n              \u003e\u003d RAPID_SLEEP_DECREASE_TRANSITION_PERIOD_MS)\n              ? RAPID_SLEEP_DECREASE_FACTOR\n              : SLEEP_DECREASE_FACTOR;\n\n      newSleepDuration \u003d sleepDuration * reductionFactor;\n    } else if (errorPercentage \u003c MAX_EQUILIBRIUM_ERROR_PERCENTAGE) {\n      // Do not modify sleepDuration in order to stabilize throughput.\n      newSleepDuration \u003d sleepDuration;\n    } else {\n      // Increase sleepDuration in order to minimize error rate.\n      consecutiveNoErrorCount \u003d 0;\n\n      // Increase sleep duration in order to reduce throughput and error rate.\n      // First, calculate target throughput: bytesSuccessful / periodMs.\n      // Next, calculate time required to send *all* data (assuming next period\n      // is similar to previous) at the target throughput: (bytesSuccessful\n      // + bytesFailed) * periodMs / bytesSuccessful. Next, subtract periodMs to\n      // get the total additional delay needed.\n      double additionalDelayNeeded \u003d 5 * analysisPeriodMs;\n      if (bytesSuccessful \u003e 0) {\n        additionalDelayNeeded \u003d (bytesSuccessful + bytesFailed)\n            * periodMs\n            / bytesSuccessful\n            - periodMs;\n      }\n\n      // amortize the additional delay needed across the estimated number of\n      // requests during the next period\n      newSleepDuration \u003d additionalDelayNeeded\n          / (operationsFailed + operationsSuccessful);\n\n      final double maxSleepDuration \u003d analysisPeriodMs;\n      final double minSleepDuration \u003d sleepDuration * SLEEP_INCREASE_FACTOR;\n\n      // Add 1 ms to avoid rounding down and to decrease proximity to the server\n      // side ingress/egress limit.  Ensure that the new sleep duration is\n      // larger than the current one to more quickly reduce the number of\n      // errors.  Don\u0027t allow the sleep duration to grow unbounded, after a\n      // certain point throttling won\u0027t help, for example, if there are far too\n      // many tasks/containers/nodes no amount of throttling will help.\n      newSleepDuration \u003d Math.max(newSleepDuration, minSleepDuration) + 1;\n      newSleepDuration \u003d Math.min(newSleepDuration, maxSleepDuration);\n    }\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(String.format(\n          \"%5.5s, %10d, %10d, %10d, %10d, %6.2f, %5d, %5d, %5d\",\n          name,\n          (int) bytesFailed,\n          (int) bytesSuccessful,\n          (int) operationsFailed,\n          (int) operationsSuccessful,\n          errorPercentage,\n          periodMs,\n          (int) sleepDuration,\n          (int) newSleepDuration));\n    }\n\n    return (int) newSleepDuration;\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/services/AbfsClientThrottlingAnalyzer.java"
    }
  }
}