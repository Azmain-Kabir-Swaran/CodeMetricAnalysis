{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "PlanningAlgorithm.java",
  "functionName": "allocateUser",
  "functionId": "allocateUser___reservationId-ReservationId__user-String__plan-Plan__contract-ReservationDefinition__oldReservation-ReservationAllocation",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/planning/PlanningAlgorithm.java",
  "functionStartLine": 56,
  "functionEndLine": 113,
  "numCommitsSeen": 8,
  "timeTaken": 1949,
  "changeHistory": [
    "e6e614e380ed1d746973b50f666a9c40d272073e",
    "742632e346604fd2b263bd42367165638fcf2416",
    "2798723a5443d04455b9d79c48d61f435ab52267",
    "156f24ead00436faad5d4aeef327a546392cd265"
  ],
  "changeHistoryShort": {
    "e6e614e380ed1d746973b50f666a9c40d272073e": "Ybodychange",
    "742632e346604fd2b263bd42367165638fcf2416": "Ybodychange",
    "2798723a5443d04455b9d79c48d61f435ab52267": "Ybodychange",
    "156f24ead00436faad5d4aeef327a546392cd265": "Yintroduced"
  },
  "changeHistoryDetails": {
    "e6e614e380ed1d746973b50f666a9c40d272073e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5329. Placement Agent enhancements required to support recurring reservations in ReservationSystem. (Carlo Curino via Subru).\n",
      "commitDate": "04/10/17 7:28 PM",
      "commitName": "e6e614e380ed1d746973b50f666a9c40d272073e",
      "commitAuthor": "Subru Krishnan",
      "commitDateOld": "06/09/17 4:46 PM",
      "commitNameOld": "b6e7d1369690eaf50ce9ea7968f91a72ecb74de0",
      "commitAuthorOld": "Subru Krishnan",
      "daysBetweenCommits": 28.11,
      "commitsBetweenForRepo": 262,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,58 @@\n   protected boolean allocateUser(ReservationId reservationId, String user,\n       Plan plan, ReservationDefinition contract,\n       ReservationAllocation oldReservation) throws PlanningException,\n       ContractValidationException {\n \n     // Adjust the ResourceDefinition to account for system \"imperfections\"\n     // (e.g., scheduling delays for large containers).\n     ReservationDefinition adjustedContract \u003d adjustContract(plan, contract);\n \n     // Compute the job allocation\n     RLESparseResourceAllocation allocation \u003d\n-        computeJobAllocation(plan, reservationId, adjustedContract, user);\n+            computeJobAllocation(plan, reservationId, adjustedContract, user);\n+\n+    long period \u003d Long.parseLong(contract.getRecurrenceExpression());\n+\n+    // Make allocation periodic if request is periodic\n+    if (contract.getRecurrenceExpression() !\u003d null) {\n+      if (period \u003e 0) {\n+        allocation \u003d\n+            new PeriodicRLESparseResourceAllocation(allocation, period);\n+      }\n+    }\n \n     // If no job allocation was found, fail\n     if (allocation \u003d\u003d null) {\n       throw new PlanningException(\n-          \"The planning algorithm could not find a valid allocation\"\n-              + \" for your request\");\n+              \"The planning algorithm could not find a valid allocation\"\n+                      + \" for your request\");\n     }\n \n     // Translate the allocation to a map (with zero paddings)\n     long step \u003d plan.getStep();\n+\n     long jobArrival \u003d stepRoundUp(adjustedContract.getArrival(), step);\n     long jobDeadline \u003d stepRoundUp(adjustedContract.getDeadline(), step);\n+\n     Map\u003cReservationInterval, Resource\u003e mapAllocations \u003d\n-        allocationsToPaddedMap(allocation, jobArrival, jobDeadline);\n+        allocationsToPaddedMap(allocation, jobArrival, jobDeadline, period);\n \n     // Create the reservation\n     ReservationAllocation capReservation \u003d\n         new InMemoryReservationAllocation(reservationId, // ID\n             adjustedContract, // Contract\n             user, // User name\n             plan.getQueueName(), // Queue name\n-            findEarliestTime(mapAllocations), // Earliest start time\n-            findLatestTime(mapAllocations), // Latest end time\n+            adjustedContract.getArrival(), adjustedContract.getDeadline(),\n             mapAllocations, // Allocations\n             plan.getResourceCalculator(), // Resource calculator\n             plan.getMinimumAllocation()); // Minimum allocation\n \n     // Add (or update) the reservation allocation\n     if (oldReservation !\u003d null) {\n       return plan.updateReservation(capReservation);\n     } else {\n       return plan.addReservation(capReservation, false);\n     }\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected boolean allocateUser(ReservationId reservationId, String user,\n      Plan plan, ReservationDefinition contract,\n      ReservationAllocation oldReservation) throws PlanningException,\n      ContractValidationException {\n\n    // Adjust the ResourceDefinition to account for system \"imperfections\"\n    // (e.g., scheduling delays for large containers).\n    ReservationDefinition adjustedContract \u003d adjustContract(plan, contract);\n\n    // Compute the job allocation\n    RLESparseResourceAllocation allocation \u003d\n            computeJobAllocation(plan, reservationId, adjustedContract, user);\n\n    long period \u003d Long.parseLong(contract.getRecurrenceExpression());\n\n    // Make allocation periodic if request is periodic\n    if (contract.getRecurrenceExpression() !\u003d null) {\n      if (period \u003e 0) {\n        allocation \u003d\n            new PeriodicRLESparseResourceAllocation(allocation, period);\n      }\n    }\n\n    // If no job allocation was found, fail\n    if (allocation \u003d\u003d null) {\n      throw new PlanningException(\n              \"The planning algorithm could not find a valid allocation\"\n                      + \" for your request\");\n    }\n\n    // Translate the allocation to a map (with zero paddings)\n    long step \u003d plan.getStep();\n\n    long jobArrival \u003d stepRoundUp(adjustedContract.getArrival(), step);\n    long jobDeadline \u003d stepRoundUp(adjustedContract.getDeadline(), step);\n\n    Map\u003cReservationInterval, Resource\u003e mapAllocations \u003d\n        allocationsToPaddedMap(allocation, jobArrival, jobDeadline, period);\n\n    // Create the reservation\n    ReservationAllocation capReservation \u003d\n        new InMemoryReservationAllocation(reservationId, // ID\n            adjustedContract, // Contract\n            user, // User name\n            plan.getQueueName(), // Queue name\n            adjustedContract.getArrival(), adjustedContract.getDeadline(),\n            mapAllocations, // Allocations\n            plan.getResourceCalculator(), // Resource calculator\n            plan.getMinimumAllocation()); // Minimum allocation\n\n    // Add (or update) the reservation allocation\n    if (oldReservation !\u003d null) {\n      return plan.updateReservation(capReservation);\n    } else {\n      return plan.addReservation(capReservation, false);\n    }\n\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/planning/PlanningAlgorithm.java",
      "extendedDetails": {}
    },
    "742632e346604fd2b263bd42367165638fcf2416": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4358. Reservation System: Improve relationship between SharingPolicy and ReservationAgent. (Carlo Curino via asuresh)\n",
      "commitDate": "05/12/15 9:26 PM",
      "commitName": "742632e346604fd2b263bd42367165638fcf2416",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "22/10/15 6:51 AM",
      "commitNameOld": "2798723a5443d04455b9d79c48d61f435ab52267",
      "commitAuthorOld": "Anubhav Dhoot",
      "daysBetweenCommits": 44.65,
      "commitsBetweenForRepo": 336,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,47 @@\n   protected boolean allocateUser(ReservationId reservationId, String user,\n       Plan plan, ReservationDefinition contract,\n       ReservationAllocation oldReservation) throws PlanningException,\n       ContractValidationException {\n \n     // Adjust the ResourceDefinition to account for system \"imperfections\"\n     // (e.g., scheduling delays for large containers).\n     ReservationDefinition adjustedContract \u003d adjustContract(plan, contract);\n \n     // Compute the job allocation\n     RLESparseResourceAllocation allocation \u003d\n-        computeJobAllocation(plan, reservationId, adjustedContract);\n+        computeJobAllocation(plan, reservationId, adjustedContract, user);\n \n     // If no job allocation was found, fail\n     if (allocation \u003d\u003d null) {\n       throw new PlanningException(\n           \"The planning algorithm could not find a valid allocation\"\n               + \" for your request\");\n     }\n \n     // Translate the allocation to a map (with zero paddings)\n     long step \u003d plan.getStep();\n     long jobArrival \u003d stepRoundUp(adjustedContract.getArrival(), step);\n     long jobDeadline \u003d stepRoundUp(adjustedContract.getDeadline(), step);\n     Map\u003cReservationInterval, Resource\u003e mapAllocations \u003d\n         allocationsToPaddedMap(allocation, jobArrival, jobDeadline);\n \n     // Create the reservation\n     ReservationAllocation capReservation \u003d\n         new InMemoryReservationAllocation(reservationId, // ID\n             adjustedContract, // Contract\n             user, // User name\n             plan.getQueueName(), // Queue name\n-            findEarliestTime(mapAllocations.keySet()), // Earliest start time\n-            findLatestTime(mapAllocations.keySet()), // Latest end time\n+            findEarliestTime(mapAllocations), // Earliest start time\n+            findLatestTime(mapAllocations), // Latest end time\n             mapAllocations, // Allocations\n             plan.getResourceCalculator(), // Resource calculator\n             plan.getMinimumAllocation()); // Minimum allocation\n \n     // Add (or update) the reservation allocation\n     if (oldReservation !\u003d null) {\n       return plan.updateReservation(capReservation);\n     } else {\n       return plan.addReservation(capReservation, false);\n     }\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected boolean allocateUser(ReservationId reservationId, String user,\n      Plan plan, ReservationDefinition contract,\n      ReservationAllocation oldReservation) throws PlanningException,\n      ContractValidationException {\n\n    // Adjust the ResourceDefinition to account for system \"imperfections\"\n    // (e.g., scheduling delays for large containers).\n    ReservationDefinition adjustedContract \u003d adjustContract(plan, contract);\n\n    // Compute the job allocation\n    RLESparseResourceAllocation allocation \u003d\n        computeJobAllocation(plan, reservationId, adjustedContract, user);\n\n    // If no job allocation was found, fail\n    if (allocation \u003d\u003d null) {\n      throw new PlanningException(\n          \"The planning algorithm could not find a valid allocation\"\n              + \" for your request\");\n    }\n\n    // Translate the allocation to a map (with zero paddings)\n    long step \u003d plan.getStep();\n    long jobArrival \u003d stepRoundUp(adjustedContract.getArrival(), step);\n    long jobDeadline \u003d stepRoundUp(adjustedContract.getDeadline(), step);\n    Map\u003cReservationInterval, Resource\u003e mapAllocations \u003d\n        allocationsToPaddedMap(allocation, jobArrival, jobDeadline);\n\n    // Create the reservation\n    ReservationAllocation capReservation \u003d\n        new InMemoryReservationAllocation(reservationId, // ID\n            adjustedContract, // Contract\n            user, // User name\n            plan.getQueueName(), // Queue name\n            findEarliestTime(mapAllocations), // Earliest start time\n            findLatestTime(mapAllocations), // Latest end time\n            mapAllocations, // Allocations\n            plan.getResourceCalculator(), // Resource calculator\n            plan.getMinimumAllocation()); // Minimum allocation\n\n    // Add (or update) the reservation allocation\n    if (oldReservation !\u003d null) {\n      return plan.updateReservation(capReservation);\n    } else {\n      return plan.addReservation(capReservation, false);\n    }\n\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/planning/PlanningAlgorithm.java",
      "extendedDetails": {}
    },
    "2798723a5443d04455b9d79c48d61f435ab52267": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3739. Add reservation system recovery to RM recovery process. Contributed by  Subru Krishnan.\n",
      "commitDate": "22/10/15 6:51 AM",
      "commitName": "2798723a5443d04455b9d79c48d61f435ab52267",
      "commitAuthor": "Anubhav Dhoot",
      "commitDateOld": "25/07/15 7:39 AM",
      "commitNameOld": "156f24ead00436faad5d4aeef327a546392cd265",
      "commitAuthorOld": "ccurino",
      "daysBetweenCommits": 88.97,
      "commitsBetweenForRepo": 579,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,47 @@\n   protected boolean allocateUser(ReservationId reservationId, String user,\n       Plan plan, ReservationDefinition contract,\n       ReservationAllocation oldReservation) throws PlanningException,\n       ContractValidationException {\n \n     // Adjust the ResourceDefinition to account for system \"imperfections\"\n     // (e.g., scheduling delays for large containers).\n     ReservationDefinition adjustedContract \u003d adjustContract(plan, contract);\n \n     // Compute the job allocation\n     RLESparseResourceAllocation allocation \u003d\n         computeJobAllocation(plan, reservationId, adjustedContract);\n \n     // If no job allocation was found, fail\n     if (allocation \u003d\u003d null) {\n       throw new PlanningException(\n           \"The planning algorithm could not find a valid allocation\"\n               + \" for your request\");\n     }\n \n     // Translate the allocation to a map (with zero paddings)\n     long step \u003d plan.getStep();\n     long jobArrival \u003d stepRoundUp(adjustedContract.getArrival(), step);\n     long jobDeadline \u003d stepRoundUp(adjustedContract.getDeadline(), step);\n     Map\u003cReservationInterval, Resource\u003e mapAllocations \u003d\n         allocationsToPaddedMap(allocation, jobArrival, jobDeadline);\n \n     // Create the reservation\n     ReservationAllocation capReservation \u003d\n         new InMemoryReservationAllocation(reservationId, // ID\n             adjustedContract, // Contract\n             user, // User name\n             plan.getQueueName(), // Queue name\n             findEarliestTime(mapAllocations.keySet()), // Earliest start time\n             findLatestTime(mapAllocations.keySet()), // Latest end time\n             mapAllocations, // Allocations\n             plan.getResourceCalculator(), // Resource calculator\n             plan.getMinimumAllocation()); // Minimum allocation\n \n     // Add (or update) the reservation allocation\n     if (oldReservation !\u003d null) {\n       return plan.updateReservation(capReservation);\n     } else {\n-      return plan.addReservation(capReservation);\n+      return plan.addReservation(capReservation, false);\n     }\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected boolean allocateUser(ReservationId reservationId, String user,\n      Plan plan, ReservationDefinition contract,\n      ReservationAllocation oldReservation) throws PlanningException,\n      ContractValidationException {\n\n    // Adjust the ResourceDefinition to account for system \"imperfections\"\n    // (e.g., scheduling delays for large containers).\n    ReservationDefinition adjustedContract \u003d adjustContract(plan, contract);\n\n    // Compute the job allocation\n    RLESparseResourceAllocation allocation \u003d\n        computeJobAllocation(plan, reservationId, adjustedContract);\n\n    // If no job allocation was found, fail\n    if (allocation \u003d\u003d null) {\n      throw new PlanningException(\n          \"The planning algorithm could not find a valid allocation\"\n              + \" for your request\");\n    }\n\n    // Translate the allocation to a map (with zero paddings)\n    long step \u003d plan.getStep();\n    long jobArrival \u003d stepRoundUp(adjustedContract.getArrival(), step);\n    long jobDeadline \u003d stepRoundUp(adjustedContract.getDeadline(), step);\n    Map\u003cReservationInterval, Resource\u003e mapAllocations \u003d\n        allocationsToPaddedMap(allocation, jobArrival, jobDeadline);\n\n    // Create the reservation\n    ReservationAllocation capReservation \u003d\n        new InMemoryReservationAllocation(reservationId, // ID\n            adjustedContract, // Contract\n            user, // User name\n            plan.getQueueName(), // Queue name\n            findEarliestTime(mapAllocations.keySet()), // Earliest start time\n            findLatestTime(mapAllocations.keySet()), // Latest end time\n            mapAllocations, // Allocations\n            plan.getResourceCalculator(), // Resource calculator\n            plan.getMinimumAllocation()); // Minimum allocation\n\n    // Add (or update) the reservation allocation\n    if (oldReservation !\u003d null) {\n      return plan.updateReservation(capReservation);\n    } else {\n      return plan.addReservation(capReservation, false);\n    }\n\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/planning/PlanningAlgorithm.java",
      "extendedDetails": {}
    },
    "156f24ead00436faad5d4aeef327a546392cd265": {
      "type": "Yintroduced",
      "commitMessage": "YARN-3656. LowCost: A Cost-Based Placement Agent for YARN Reservations. (Jonathan Yaniv and Ishai Menache via curino)\n",
      "commitDate": "25/07/15 7:39 AM",
      "commitName": "156f24ead00436faad5d4aeef327a546392cd265",
      "commitAuthor": "ccurino",
      "diff": "@@ -0,0 +1,47 @@\n+  protected boolean allocateUser(ReservationId reservationId, String user,\n+      Plan plan, ReservationDefinition contract,\n+      ReservationAllocation oldReservation) throws PlanningException,\n+      ContractValidationException {\n+\n+    // Adjust the ResourceDefinition to account for system \"imperfections\"\n+    // (e.g., scheduling delays for large containers).\n+    ReservationDefinition adjustedContract \u003d adjustContract(plan, contract);\n+\n+    // Compute the job allocation\n+    RLESparseResourceAllocation allocation \u003d\n+        computeJobAllocation(plan, reservationId, adjustedContract);\n+\n+    // If no job allocation was found, fail\n+    if (allocation \u003d\u003d null) {\n+      throw new PlanningException(\n+          \"The planning algorithm could not find a valid allocation\"\n+              + \" for your request\");\n+    }\n+\n+    // Translate the allocation to a map (with zero paddings)\n+    long step \u003d plan.getStep();\n+    long jobArrival \u003d stepRoundUp(adjustedContract.getArrival(), step);\n+    long jobDeadline \u003d stepRoundUp(adjustedContract.getDeadline(), step);\n+    Map\u003cReservationInterval, Resource\u003e mapAllocations \u003d\n+        allocationsToPaddedMap(allocation, jobArrival, jobDeadline);\n+\n+    // Create the reservation\n+    ReservationAllocation capReservation \u003d\n+        new InMemoryReservationAllocation(reservationId, // ID\n+            adjustedContract, // Contract\n+            user, // User name\n+            plan.getQueueName(), // Queue name\n+            findEarliestTime(mapAllocations.keySet()), // Earliest start time\n+            findLatestTime(mapAllocations.keySet()), // Latest end time\n+            mapAllocations, // Allocations\n+            plan.getResourceCalculator(), // Resource calculator\n+            plan.getMinimumAllocation()); // Minimum allocation\n+\n+    // Add (or update) the reservation allocation\n+    if (oldReservation !\u003d null) {\n+      return plan.updateReservation(capReservation);\n+    } else {\n+      return plan.addReservation(capReservation);\n+    }\n+\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  protected boolean allocateUser(ReservationId reservationId, String user,\n      Plan plan, ReservationDefinition contract,\n      ReservationAllocation oldReservation) throws PlanningException,\n      ContractValidationException {\n\n    // Adjust the ResourceDefinition to account for system \"imperfections\"\n    // (e.g., scheduling delays for large containers).\n    ReservationDefinition adjustedContract \u003d adjustContract(plan, contract);\n\n    // Compute the job allocation\n    RLESparseResourceAllocation allocation \u003d\n        computeJobAllocation(plan, reservationId, adjustedContract);\n\n    // If no job allocation was found, fail\n    if (allocation \u003d\u003d null) {\n      throw new PlanningException(\n          \"The planning algorithm could not find a valid allocation\"\n              + \" for your request\");\n    }\n\n    // Translate the allocation to a map (with zero paddings)\n    long step \u003d plan.getStep();\n    long jobArrival \u003d stepRoundUp(adjustedContract.getArrival(), step);\n    long jobDeadline \u003d stepRoundUp(adjustedContract.getDeadline(), step);\n    Map\u003cReservationInterval, Resource\u003e mapAllocations \u003d\n        allocationsToPaddedMap(allocation, jobArrival, jobDeadline);\n\n    // Create the reservation\n    ReservationAllocation capReservation \u003d\n        new InMemoryReservationAllocation(reservationId, // ID\n            adjustedContract, // Contract\n            user, // User name\n            plan.getQueueName(), // Queue name\n            findEarliestTime(mapAllocations.keySet()), // Earliest start time\n            findLatestTime(mapAllocations.keySet()), // Latest end time\n            mapAllocations, // Allocations\n            plan.getResourceCalculator(), // Resource calculator\n            plan.getMinimumAllocation()); // Minimum allocation\n\n    // Add (or update) the reservation allocation\n    if (oldReservation !\u003d null) {\n      return plan.updateReservation(capReservation);\n    } else {\n      return plan.addReservation(capReservation);\n    }\n\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/planning/PlanningAlgorithm.java"
    }
  }
}