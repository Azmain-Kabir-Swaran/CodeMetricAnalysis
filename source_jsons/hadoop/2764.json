{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "AbstractNNFailoverProxyProvider.java",
  "functionName": "getProxyAddresses",
  "functionId": "getProxyAddresses___uri-URI__addressKey-String",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/AbstractNNFailoverProxyProvider.java",
  "functionStartLine": 170,
  "functionEndLine": 201,
  "numCommitsSeen": 12,
  "timeTaken": 2761,
  "changeHistory": [
    "7b5b783f66f32012c00bef7593851392dd8cf2d5",
    "f7a27cdee4e6829ebea4ea965e549a27acbf4310",
    "652b257478f723a9e119e5e9181f3c7450ac92b5",
    "25b63e8da8e84252072bcd09ee5557c48e07a745",
    "a4121c71c29d13866a605d9c0d013e5de9c147c3"
  ],
  "changeHistoryShort": {
    "7b5b783f66f32012c00bef7593851392dd8cf2d5": "Ybodychange",
    "f7a27cdee4e6829ebea4ea965e549a27acbf4310": "Ybodychange",
    "652b257478f723a9e119e5e9181f3c7450ac92b5": "Ybodychange",
    "25b63e8da8e84252072bcd09ee5557c48e07a745": "Ybodychange",
    "a4121c71c29d13866a605d9c0d013e5de9c147c3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "7b5b783f66f32012c00bef7593851392dd8cf2d5": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14327. Using FQDN instead of IP to access servers with DNS resolving. Contributed by Fengnan Li.\n",
      "commitDate": "03/04/19 4:11 PM",
      "commitName": "7b5b783f66f32012c00bef7593851392dd8cf2d5",
      "commitAuthor": "Inigo Goiri",
      "commitDateOld": "23/02/19 9:35 AM",
      "commitNameOld": "f7a27cdee4e6829ebea4ea965e549a27acbf4310",
      "commitAuthorOld": "Yongjun Zhang",
      "daysBetweenCommits": 39.23,
      "commitsBetweenForRepo": 331,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,32 +1,32 @@\n   protected List\u003cNNProxyInfo\u003cT\u003e\u003e getProxyAddresses(URI uri, String addressKey) {\n     final List\u003cNNProxyInfo\u003cT\u003e\u003e proxies \u003d new ArrayList\u003cNNProxyInfo\u003cT\u003e\u003e();\n     Map\u003cString, Map\u003cString, InetSocketAddress\u003e\u003e map \u003d\n         DFSUtilClient.getAddresses(conf, null, addressKey);\n     Map\u003cString, InetSocketAddress\u003e addressesInNN \u003d map.get(uri.getHost());\n \n     if (addressesInNN \u003d\u003d null || addressesInNN.size() \u003d\u003d 0) {\n       throw new RuntimeException(\"Could not find any configured addresses \" +\n           \"for URI \" + uri);\n     }\n \n     Collection\u003cInetSocketAddress\u003e addressesOfNns \u003d addressesInNN.values();\n     try {\n-      addressesOfNns \u003d getResolvedAddressesIfNecessary(addressesOfNns, uri);\n+      addressesOfNns \u003d getResolvedHostsIfNecessary(addressesOfNns, uri);\n     } catch (IOException e) {\n       throw new RuntimeException(e);\n     }\n     for (InetSocketAddress address : addressesOfNns) {\n       proxies.add(new NNProxyInfo\u003cT\u003e(address));\n     }\n     // Randomize the list to prevent all clients pointing to the same one\n     boolean randomized \u003d getRandomOrder(conf, uri);\n     if (randomized) {\n       Collections.shuffle(proxies);\n     }\n \n     // The client may have a delegation token set for the logical\n     // URI of the cluster. Clone this token to apply to each of the\n     // underlying IPC addresses so that the IPC code can find it.\n     HAUtilClient.cloneDelegationTokenForLogicalUri(ugi, uri, addressesOfNns);\n     return proxies;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected List\u003cNNProxyInfo\u003cT\u003e\u003e getProxyAddresses(URI uri, String addressKey) {\n    final List\u003cNNProxyInfo\u003cT\u003e\u003e proxies \u003d new ArrayList\u003cNNProxyInfo\u003cT\u003e\u003e();\n    Map\u003cString, Map\u003cString, InetSocketAddress\u003e\u003e map \u003d\n        DFSUtilClient.getAddresses(conf, null, addressKey);\n    Map\u003cString, InetSocketAddress\u003e addressesInNN \u003d map.get(uri.getHost());\n\n    if (addressesInNN \u003d\u003d null || addressesInNN.size() \u003d\u003d 0) {\n      throw new RuntimeException(\"Could not find any configured addresses \" +\n          \"for URI \" + uri);\n    }\n\n    Collection\u003cInetSocketAddress\u003e addressesOfNns \u003d addressesInNN.values();\n    try {\n      addressesOfNns \u003d getResolvedHostsIfNecessary(addressesOfNns, uri);\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n    for (InetSocketAddress address : addressesOfNns) {\n      proxies.add(new NNProxyInfo\u003cT\u003e(address));\n    }\n    // Randomize the list to prevent all clients pointing to the same one\n    boolean randomized \u003d getRandomOrder(conf, uri);\n    if (randomized) {\n      Collections.shuffle(proxies);\n    }\n\n    // The client may have a delegation token set for the logical\n    // URI of the cluster. Clone this token to apply to each of the\n    // underlying IPC addresses so that the IPC code can find it.\n    HAUtilClient.cloneDelegationTokenForLogicalUri(ugi, uri, addressesOfNns);\n    return proxies;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/AbstractNNFailoverProxyProvider.java",
      "extendedDetails": {}
    },
    "f7a27cdee4e6829ebea4ea965e549a27acbf4310": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14118. Support using DNS to resolve nameservices to IP addresses. Contributed by Fengnan Li.\n",
      "commitDate": "23/02/19 9:35 AM",
      "commitName": "f7a27cdee4e6829ebea4ea965e549a27acbf4310",
      "commitAuthor": "Yongjun Zhang",
      "commitDateOld": "24/12/18 9:34 AM",
      "commitNameOld": "652b257478f723a9e119e5e9181f3c7450ac92b5",
      "commitAuthorOld": "Chen Liang",
      "daysBetweenCommits": 61.0,
      "commitsBetweenForRepo": 413,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,27 +1,32 @@\n   protected List\u003cNNProxyInfo\u003cT\u003e\u003e getProxyAddresses(URI uri, String addressKey) {\n     final List\u003cNNProxyInfo\u003cT\u003e\u003e proxies \u003d new ArrayList\u003cNNProxyInfo\u003cT\u003e\u003e();\n     Map\u003cString, Map\u003cString, InetSocketAddress\u003e\u003e map \u003d\n         DFSUtilClient.getAddresses(conf, null, addressKey);\n     Map\u003cString, InetSocketAddress\u003e addressesInNN \u003d map.get(uri.getHost());\n \n     if (addressesInNN \u003d\u003d null || addressesInNN.size() \u003d\u003d 0) {\n       throw new RuntimeException(\"Could not find any configured addresses \" +\n           \"for URI \" + uri);\n     }\n \n     Collection\u003cInetSocketAddress\u003e addressesOfNns \u003d addressesInNN.values();\n+    try {\n+      addressesOfNns \u003d getResolvedAddressesIfNecessary(addressesOfNns, uri);\n+    } catch (IOException e) {\n+      throw new RuntimeException(e);\n+    }\n     for (InetSocketAddress address : addressesOfNns) {\n       proxies.add(new NNProxyInfo\u003cT\u003e(address));\n     }\n     // Randomize the list to prevent all clients pointing to the same one\n     boolean randomized \u003d getRandomOrder(conf, uri);\n     if (randomized) {\n       Collections.shuffle(proxies);\n     }\n \n     // The client may have a delegation token set for the logical\n     // URI of the cluster. Clone this token to apply to each of the\n     // underlying IPC addresses so that the IPC code can find it.\n     HAUtilClient.cloneDelegationTokenForLogicalUri(ugi, uri, addressesOfNns);\n     return proxies;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected List\u003cNNProxyInfo\u003cT\u003e\u003e getProxyAddresses(URI uri, String addressKey) {\n    final List\u003cNNProxyInfo\u003cT\u003e\u003e proxies \u003d new ArrayList\u003cNNProxyInfo\u003cT\u003e\u003e();\n    Map\u003cString, Map\u003cString, InetSocketAddress\u003e\u003e map \u003d\n        DFSUtilClient.getAddresses(conf, null, addressKey);\n    Map\u003cString, InetSocketAddress\u003e addressesInNN \u003d map.get(uri.getHost());\n\n    if (addressesInNN \u003d\u003d null || addressesInNN.size() \u003d\u003d 0) {\n      throw new RuntimeException(\"Could not find any configured addresses \" +\n          \"for URI \" + uri);\n    }\n\n    Collection\u003cInetSocketAddress\u003e addressesOfNns \u003d addressesInNN.values();\n    try {\n      addressesOfNns \u003d getResolvedAddressesIfNecessary(addressesOfNns, uri);\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n    for (InetSocketAddress address : addressesOfNns) {\n      proxies.add(new NNProxyInfo\u003cT\u003e(address));\n    }\n    // Randomize the list to prevent all clients pointing to the same one\n    boolean randomized \u003d getRandomOrder(conf, uri);\n    if (randomized) {\n      Collections.shuffle(proxies);\n    }\n\n    // The client may have a delegation token set for the logical\n    // URI of the cluster. Clone this token to apply to each of the\n    // underlying IPC addresses so that the IPC code can find it.\n    HAUtilClient.cloneDelegationTokenForLogicalUri(ugi, uri, addressesOfNns);\n    return proxies;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/AbstractNNFailoverProxyProvider.java",
      "extendedDetails": {}
    },
    "652b257478f723a9e119e5e9181f3c7450ac92b5": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14035. NN status discovery does not leverage delegation token. Contributed by Chen Liang.\n",
      "commitDate": "24/12/18 9:34 AM",
      "commitName": "652b257478f723a9e119e5e9181f3c7450ac92b5",
      "commitAuthor": "Chen Liang",
      "commitDateOld": "24/12/18 9:34 AM",
      "commitNameOld": "25b63e8da8e84252072bcd09ee5557c48e07a745",
      "commitAuthorOld": "Erik Krogen",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,27 +1,27 @@\n   protected List\u003cNNProxyInfo\u003cT\u003e\u003e getProxyAddresses(URI uri, String addressKey) {\n     final List\u003cNNProxyInfo\u003cT\u003e\u003e proxies \u003d new ArrayList\u003cNNProxyInfo\u003cT\u003e\u003e();\n     Map\u003cString, Map\u003cString, InetSocketAddress\u003e\u003e map \u003d\n         DFSUtilClient.getAddresses(conf, null, addressKey);\n     Map\u003cString, InetSocketAddress\u003e addressesInNN \u003d map.get(uri.getHost());\n \n     if (addressesInNN \u003d\u003d null || addressesInNN.size() \u003d\u003d 0) {\n       throw new RuntimeException(\"Could not find any configured addresses \" +\n           \"for URI \" + uri);\n     }\n \n     Collection\u003cInetSocketAddress\u003e addressesOfNns \u003d addressesInNN.values();\n     for (InetSocketAddress address : addressesOfNns) {\n-      proxies.add(new NNProxyInfo\u003cT\u003e(address, conf));\n+      proxies.add(new NNProxyInfo\u003cT\u003e(address));\n     }\n     // Randomize the list to prevent all clients pointing to the same one\n     boolean randomized \u003d getRandomOrder(conf, uri);\n     if (randomized) {\n       Collections.shuffle(proxies);\n     }\n \n     // The client may have a delegation token set for the logical\n     // URI of the cluster. Clone this token to apply to each of the\n     // underlying IPC addresses so that the IPC code can find it.\n     HAUtilClient.cloneDelegationTokenForLogicalUri(ugi, uri, addressesOfNns);\n     return proxies;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected List\u003cNNProxyInfo\u003cT\u003e\u003e getProxyAddresses(URI uri, String addressKey) {\n    final List\u003cNNProxyInfo\u003cT\u003e\u003e proxies \u003d new ArrayList\u003cNNProxyInfo\u003cT\u003e\u003e();\n    Map\u003cString, Map\u003cString, InetSocketAddress\u003e\u003e map \u003d\n        DFSUtilClient.getAddresses(conf, null, addressKey);\n    Map\u003cString, InetSocketAddress\u003e addressesInNN \u003d map.get(uri.getHost());\n\n    if (addressesInNN \u003d\u003d null || addressesInNN.size() \u003d\u003d 0) {\n      throw new RuntimeException(\"Could not find any configured addresses \" +\n          \"for URI \" + uri);\n    }\n\n    Collection\u003cInetSocketAddress\u003e addressesOfNns \u003d addressesInNN.values();\n    for (InetSocketAddress address : addressesOfNns) {\n      proxies.add(new NNProxyInfo\u003cT\u003e(address));\n    }\n    // Randomize the list to prevent all clients pointing to the same one\n    boolean randomized \u003d getRandomOrder(conf, uri);\n    if (randomized) {\n      Collections.shuffle(proxies);\n    }\n\n    // The client may have a delegation token set for the logical\n    // URI of the cluster. Clone this token to apply to each of the\n    // underlying IPC addresses so that the IPC code can find it.\n    HAUtilClient.cloneDelegationTokenForLogicalUri(ugi, uri, addressesOfNns);\n    return proxies;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/AbstractNNFailoverProxyProvider.java",
      "extendedDetails": {}
    },
    "25b63e8da8e84252072bcd09ee5557c48e07a745": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13749. [SBN read] Use getServiceStatus to discover observer namenodes. Contributed by Chao Sun.\n",
      "commitDate": "24/12/18 9:34 AM",
      "commitName": "25b63e8da8e84252072bcd09ee5557c48e07a745",
      "commitAuthor": "Erik Krogen",
      "commitDateOld": "24/12/18 9:34 AM",
      "commitNameOld": "aa42fb0db78454e5cadc2df7b6fdaa8d913ae847",
      "commitAuthorOld": "Erik Krogen",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,27 +1,27 @@\n   protected List\u003cNNProxyInfo\u003cT\u003e\u003e getProxyAddresses(URI uri, String addressKey) {\n     final List\u003cNNProxyInfo\u003cT\u003e\u003e proxies \u003d new ArrayList\u003cNNProxyInfo\u003cT\u003e\u003e();\n     Map\u003cString, Map\u003cString, InetSocketAddress\u003e\u003e map \u003d\n         DFSUtilClient.getAddresses(conf, null, addressKey);\n     Map\u003cString, InetSocketAddress\u003e addressesInNN \u003d map.get(uri.getHost());\n \n     if (addressesInNN \u003d\u003d null || addressesInNN.size() \u003d\u003d 0) {\n       throw new RuntimeException(\"Could not find any configured addresses \" +\n           \"for URI \" + uri);\n     }\n \n     Collection\u003cInetSocketAddress\u003e addressesOfNns \u003d addressesInNN.values();\n     for (InetSocketAddress address : addressesOfNns) {\n-      proxies.add(new NNProxyInfo\u003cT\u003e(address));\n+      proxies.add(new NNProxyInfo\u003cT\u003e(address, conf));\n     }\n     // Randomize the list to prevent all clients pointing to the same one\n     boolean randomized \u003d getRandomOrder(conf, uri);\n     if (randomized) {\n       Collections.shuffle(proxies);\n     }\n \n     // The client may have a delegation token set for the logical\n     // URI of the cluster. Clone this token to apply to each of the\n     // underlying IPC addresses so that the IPC code can find it.\n     HAUtilClient.cloneDelegationTokenForLogicalUri(ugi, uri, addressesOfNns);\n     return proxies;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected List\u003cNNProxyInfo\u003cT\u003e\u003e getProxyAddresses(URI uri, String addressKey) {\n    final List\u003cNNProxyInfo\u003cT\u003e\u003e proxies \u003d new ArrayList\u003cNNProxyInfo\u003cT\u003e\u003e();\n    Map\u003cString, Map\u003cString, InetSocketAddress\u003e\u003e map \u003d\n        DFSUtilClient.getAddresses(conf, null, addressKey);\n    Map\u003cString, InetSocketAddress\u003e addressesInNN \u003d map.get(uri.getHost());\n\n    if (addressesInNN \u003d\u003d null || addressesInNN.size() \u003d\u003d 0) {\n      throw new RuntimeException(\"Could not find any configured addresses \" +\n          \"for URI \" + uri);\n    }\n\n    Collection\u003cInetSocketAddress\u003e addressesOfNns \u003d addressesInNN.values();\n    for (InetSocketAddress address : addressesOfNns) {\n      proxies.add(new NNProxyInfo\u003cT\u003e(address, conf));\n    }\n    // Randomize the list to prevent all clients pointing to the same one\n    boolean randomized \u003d getRandomOrder(conf, uri);\n    if (randomized) {\n      Collections.shuffle(proxies);\n    }\n\n    // The client may have a delegation token set for the logical\n    // URI of the cluster. Clone this token to apply to each of the\n    // underlying IPC addresses so that the IPC code can find it.\n    HAUtilClient.cloneDelegationTokenForLogicalUri(ugi, uri, addressesOfNns);\n    return proxies;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/AbstractNNFailoverProxyProvider.java",
      "extendedDetails": {}
    },
    "a4121c71c29d13866a605d9c0d013e5de9c147c3": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-13848. Refactor NameNode failover proxy providers. Contributed by Konstantin Shvachko.",
      "commitDate": "24/08/18 6:27 PM",
      "commitName": "a4121c71c29d13866a605d9c0d013e5de9c147c3",
      "commitAuthor": "Konstantin V Shvachko",
      "diff": "@@ -0,0 +1,27 @@\n+  protected List\u003cNNProxyInfo\u003cT\u003e\u003e getProxyAddresses(URI uri, String addressKey) {\n+    final List\u003cNNProxyInfo\u003cT\u003e\u003e proxies \u003d new ArrayList\u003cNNProxyInfo\u003cT\u003e\u003e();\n+    Map\u003cString, Map\u003cString, InetSocketAddress\u003e\u003e map \u003d\n+        DFSUtilClient.getAddresses(conf, null, addressKey);\n+    Map\u003cString, InetSocketAddress\u003e addressesInNN \u003d map.get(uri.getHost());\n+\n+    if (addressesInNN \u003d\u003d null || addressesInNN.size() \u003d\u003d 0) {\n+      throw new RuntimeException(\"Could not find any configured addresses \" +\n+          \"for URI \" + uri);\n+    }\n+\n+    Collection\u003cInetSocketAddress\u003e addressesOfNns \u003d addressesInNN.values();\n+    for (InetSocketAddress address : addressesOfNns) {\n+      proxies.add(new NNProxyInfo\u003cT\u003e(address));\n+    }\n+    // Randomize the list to prevent all clients pointing to the same one\n+    boolean randomized \u003d getRandomOrder(conf, uri);\n+    if (randomized) {\n+      Collections.shuffle(proxies);\n+    }\n+\n+    // The client may have a delegation token set for the logical\n+    // URI of the cluster. Clone this token to apply to each of the\n+    // underlying IPC addresses so that the IPC code can find it.\n+    HAUtilClient.cloneDelegationTokenForLogicalUri(ugi, uri, addressesOfNns);\n+    return proxies;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  protected List\u003cNNProxyInfo\u003cT\u003e\u003e getProxyAddresses(URI uri, String addressKey) {\n    final List\u003cNNProxyInfo\u003cT\u003e\u003e proxies \u003d new ArrayList\u003cNNProxyInfo\u003cT\u003e\u003e();\n    Map\u003cString, Map\u003cString, InetSocketAddress\u003e\u003e map \u003d\n        DFSUtilClient.getAddresses(conf, null, addressKey);\n    Map\u003cString, InetSocketAddress\u003e addressesInNN \u003d map.get(uri.getHost());\n\n    if (addressesInNN \u003d\u003d null || addressesInNN.size() \u003d\u003d 0) {\n      throw new RuntimeException(\"Could not find any configured addresses \" +\n          \"for URI \" + uri);\n    }\n\n    Collection\u003cInetSocketAddress\u003e addressesOfNns \u003d addressesInNN.values();\n    for (InetSocketAddress address : addressesOfNns) {\n      proxies.add(new NNProxyInfo\u003cT\u003e(address));\n    }\n    // Randomize the list to prevent all clients pointing to the same one\n    boolean randomized \u003d getRandomOrder(conf, uri);\n    if (randomized) {\n      Collections.shuffle(proxies);\n    }\n\n    // The client may have a delegation token set for the logical\n    // URI of the cluster. Clone this token to apply to each of the\n    // underlying IPC addresses so that the IPC code can find it.\n    HAUtilClient.cloneDelegationTokenForLogicalUri(ugi, uri, addressesOfNns);\n    return proxies;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/AbstractNNFailoverProxyProvider.java"
    }
  }
}