{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ApplicationMaster.java",
  "functionName": "finish",
  "functionId": "finish",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
  "functionStartLine": 994,
  "functionEndLine": 1064,
  "numCommitsSeen": 113,
  "timeTaken": 5945,
  "changeHistory": [
    "eed8415dc18fa7415ebd105350bd0532b3b1b6bb",
    "1ef0a1db1d6a412b2a26782329a8325635866d0a",
    "d09058b2fd18803d12f0835fdf78aef5e0b99c90",
    "4fa1afdb883dab8786d2fb5c72a195dd2e87d711",
    "89e5c44f9e891a3579384c3fa3766937cd4970f1",
    "d45ff878c4cb8b359abb17ecf09d24b6f862874c",
    "48c931331cc43970e31866732f9ac82ee806ee03",
    "aa4a192feb8939353254d058c5f81bddbd0335c0",
    "c298a9a845f89317eb9efad332e6657c56736a4d",
    "52bbe0f11bc8e97df78a1ab9b63f4eff65fd7a76",
    "6182e7592d7255792ae6a04a5551296d755f6a37",
    "aa0c489a28dbbe8fae0be6a48edb122537784b1d",
    "be3edccf0acf55e710b0ec8ab8ce8418da74c615",
    "42c3cd3d137ba1de1c0573c0bb655fa380ed9412",
    "b503b6a07d7210c94657131dcd97239012ecb313",
    "a83fb61ac07c0468cbc7a38526e92683883dd932",
    "3492f5eff1a22aba0d09d72a9dfd3353525c072e",
    "9c4f86879cad6d6e19255d4ae8f28b61328bd10b",
    "28bac402953a4337deedf0472611f5775c7a74c9"
  ],
  "changeHistoryShort": {
    "eed8415dc18fa7415ebd105350bd0532b3b1b6bb": "Ybodychange",
    "1ef0a1db1d6a412b2a26782329a8325635866d0a": "Ybodychange",
    "d09058b2fd18803d12f0835fdf78aef5e0b99c90": "Ybodychange",
    "4fa1afdb883dab8786d2fb5c72a195dd2e87d711": "Ybodychange",
    "89e5c44f9e891a3579384c3fa3766937cd4970f1": "Ybodychange",
    "d45ff878c4cb8b359abb17ecf09d24b6f862874c": "Ybodychange",
    "48c931331cc43970e31866732f9ac82ee806ee03": "Ybodychange",
    "aa4a192feb8939353254d058c5f81bddbd0335c0": "Ybodychange",
    "c298a9a845f89317eb9efad332e6657c56736a4d": "Ybodychange",
    "52bbe0f11bc8e97df78a1ab9b63f4eff65fd7a76": "Ybodychange",
    "6182e7592d7255792ae6a04a5551296d755f6a37": "Ymultichange(Yreturntypechange,Ybodychange)",
    "aa0c489a28dbbe8fae0be6a48edb122537784b1d": "Ymultichange(Ymodifierchange,Ybodychange)",
    "be3edccf0acf55e710b0ec8ab8ce8418da74c615": "Ybodychange",
    "42c3cd3d137ba1de1c0573c0bb655fa380ed9412": "Ybodychange",
    "b503b6a07d7210c94657131dcd97239012ecb313": "Ybodychange",
    "a83fb61ac07c0468cbc7a38526e92683883dd932": "Ybodychange",
    "3492f5eff1a22aba0d09d72a9dfd3353525c072e": "Ybodychange",
    "9c4f86879cad6d6e19255d4ae8f28b61328bd10b": "Ybodychange",
    "28bac402953a4337deedf0472611f5775c7a74c9": "Yintroduced"
  },
  "changeHistoryDetails": {
    "eed8415dc18fa7415ebd105350bd0532b3b1b6bb": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8535. Fix DistributedShell unit tests. Contributed by Abhishek Modi.\n",
      "commitDate": "02/09/18 1:05 AM",
      "commitName": "eed8415dc18fa7415ebd105350bd0532b3b1b6bb",
      "commitAuthor": "bibinchundatt",
      "commitDateOld": "01/06/18 2:49 PM",
      "commitNameOld": "8956e5b8db3059e0872e49f59adc6affc76e2274",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 92.43,
      "commitsBetweenForRepo": 648,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,71 +1,71 @@\n   protected boolean finish() {\n     // wait for completion.\n     while (!done\n         \u0026\u0026 (numCompletedContainers.get() !\u003d numTotalContainers)) {\n       try {\n         Thread.sleep(200);\n       } catch (InterruptedException ex) {}\n     }\n \n     if (timelineServiceV1Enabled) {\n       publishApplicationAttemptEvent(timelineClient, appAttemptID.toString(),\n           DSEvent.DS_APP_ATTEMPT_END, domainId, appSubmitterUgi);\n     }\n \n     if (timelineServiceV2Enabled) {\n       publishApplicationAttemptEventOnTimelineServiceV2(\n           DSEvent.DS_APP_ATTEMPT_END);\n     }\n \n     // Join all launched threads\n     // needed for when we time out\n     // and we need to release containers\n     for (Thread launchThread : launchThreads) {\n       try {\n         launchThread.join(10000);\n       } catch (InterruptedException e) {\n         LOG.info(\"Exception thrown in thread join: \" + e.getMessage());\n         e.printStackTrace();\n       }\n     }\n \n     // When the application completes, it should stop all running containers\n     LOG.info(\"Application completed. Stopping running containers\");\n     nmClientAsync.stop();\n \n     // When the application completes, it should send a finish application\n     // signal to the RM\n-    LOG.info(\"Application completed. Signalling finish to RM\");\n+    LOG.info(\"Application completed. Signalling finished to RM\");\n \n     FinalApplicationStatus appStatus;\n     boolean success \u003d true;\n     String message \u003d null;\n     if (numCompletedContainers.get() - numFailedContainers.get()\n         \u003e\u003d numTotalContainers) {\n       appStatus \u003d FinalApplicationStatus.SUCCEEDED;\n     } else {\n       appStatus \u003d FinalApplicationStatus.FAILED;\n       message \u003d String.format(\"Application Failure: desired \u003d %d, \" +\n               \"completed \u003d %d, allocated \u003d %d, failed \u003d %d, \" +\n               \"diagnostics \u003d %s\", numRequestedContainers.get(),\n           numCompletedContainers.get(), numAllocatedContainers.get(),\n           numFailedContainers.get(), diagnostics);\n       success \u003d false;\n     }\n     try {\n       amRMClient.unregisterApplicationMaster(appStatus, message, null);\n     } catch (YarnException | IOException ex) {\n       LOG.error(\"Failed to unregister application\", ex);\n     }\n     amRMClient.stop();\n \n     // Stop Timeline Client\n     if(timelineServiceV1Enabled) {\n       timelineClient.stop();\n     }\n     if (timelineServiceV2Enabled) {\n       timelineV2Client.stop();\n     }\n \n     return success;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected boolean finish() {\n    // wait for completion.\n    while (!done\n        \u0026\u0026 (numCompletedContainers.get() !\u003d numTotalContainers)) {\n      try {\n        Thread.sleep(200);\n      } catch (InterruptedException ex) {}\n    }\n\n    if (timelineServiceV1Enabled) {\n      publishApplicationAttemptEvent(timelineClient, appAttemptID.toString(),\n          DSEvent.DS_APP_ATTEMPT_END, domainId, appSubmitterUgi);\n    }\n\n    if (timelineServiceV2Enabled) {\n      publishApplicationAttemptEventOnTimelineServiceV2(\n          DSEvent.DS_APP_ATTEMPT_END);\n    }\n\n    // Join all launched threads\n    // needed for when we time out\n    // and we need to release containers\n    for (Thread launchThread : launchThreads) {\n      try {\n        launchThread.join(10000);\n      } catch (InterruptedException e) {\n        LOG.info(\"Exception thrown in thread join: \" + e.getMessage());\n        e.printStackTrace();\n      }\n    }\n\n    // When the application completes, it should stop all running containers\n    LOG.info(\"Application completed. Stopping running containers\");\n    nmClientAsync.stop();\n\n    // When the application completes, it should send a finish application\n    // signal to the RM\n    LOG.info(\"Application completed. Signalling finished to RM\");\n\n    FinalApplicationStatus appStatus;\n    boolean success \u003d true;\n    String message \u003d null;\n    if (numCompletedContainers.get() - numFailedContainers.get()\n        \u003e\u003d numTotalContainers) {\n      appStatus \u003d FinalApplicationStatus.SUCCEEDED;\n    } else {\n      appStatus \u003d FinalApplicationStatus.FAILED;\n      message \u003d String.format(\"Application Failure: desired \u003d %d, \" +\n              \"completed \u003d %d, allocated \u003d %d, failed \u003d %d, \" +\n              \"diagnostics \u003d %s\", numRequestedContainers.get(),\n          numCompletedContainers.get(), numAllocatedContainers.get(),\n          numFailedContainers.get(), diagnostics);\n      success \u003d false;\n    }\n    try {\n      amRMClient.unregisterApplicationMaster(appStatus, message, null);\n    } catch (YarnException | IOException ex) {\n      LOG.error(\"Failed to unregister application\", ex);\n    }\n    amRMClient.stop();\n\n    // Stop Timeline Client\n    if(timelineServiceV1Enabled) {\n      timelineClient.stop();\n    }\n    if (timelineServiceV2Enabled) {\n      timelineV2Client.stop();\n    }\n\n    return success;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "1ef0a1db1d6a412b2a26782329a8325635866d0a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7894. Improve ATS response for DShell DS_CONTAINER when container launch fails. Contributed by Chandni Singh\n",
      "commitDate": "08/05/18 1:49 PM",
      "commitName": "1ef0a1db1d6a412b2a26782329a8325635866d0a",
      "commitAuthor": "Billie Rinaldi",
      "commitDateOld": "01/05/18 7:27 AM",
      "commitNameOld": "4e1382aca4cf23ca229bdd24e0f143c22449b329",
      "commitAuthorOld": "Billie Rinaldi",
      "daysBetweenCommits": 7.27,
      "commitsBetweenForRepo": 45,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,74 +1,71 @@\n   protected boolean finish() {\n     // wait for completion.\n     while (!done\n         \u0026\u0026 (numCompletedContainers.get() !\u003d numTotalContainers)) {\n       try {\n         Thread.sleep(200);\n       } catch (InterruptedException ex) {}\n     }\n \n     if (timelineServiceV1Enabled) {\n       publishApplicationAttemptEvent(timelineClient, appAttemptID.toString(),\n           DSEvent.DS_APP_ATTEMPT_END, domainId, appSubmitterUgi);\n     }\n \n     if (timelineServiceV2Enabled) {\n       publishApplicationAttemptEventOnTimelineServiceV2(\n           DSEvent.DS_APP_ATTEMPT_END);\n     }\n \n     // Join all launched threads\n     // needed for when we time out\n     // and we need to release containers\n     for (Thread launchThread : launchThreads) {\n       try {\n         launchThread.join(10000);\n       } catch (InterruptedException e) {\n         LOG.info(\"Exception thrown in thread join: \" + e.getMessage());\n         e.printStackTrace();\n       }\n     }\n \n     // When the application completes, it should stop all running containers\n     LOG.info(\"Application completed. Stopping running containers\");\n     nmClientAsync.stop();\n \n     // When the application completes, it should send a finish application\n     // signal to the RM\n     LOG.info(\"Application completed. Signalling finish to RM\");\n \n     FinalApplicationStatus appStatus;\n-    String appMessage \u003d null;\n     boolean success \u003d true;\n+    String message \u003d null;\n     if (numCompletedContainers.get() - numFailedContainers.get()\n         \u003e\u003d numTotalContainers) {\n       appStatus \u003d FinalApplicationStatus.SUCCEEDED;\n     } else {\n       appStatus \u003d FinalApplicationStatus.FAILED;\n-      appMessage \u003d \"Diagnostics.\" + \", total\u003d\" + numTotalContainers\n-          + \", completed\u003d\" + numCompletedContainers.get() + \", allocated\u003d\"\n-          + numAllocatedContainers.get() + \", failed\u003d\"\n-          + numFailedContainers.get();\n-      LOG.info(appMessage);\n+      message \u003d String.format(\"Application Failure: desired \u003d %d, \" +\n+              \"completed \u003d %d, allocated \u003d %d, failed \u003d %d, \" +\n+              \"diagnostics \u003d %s\", numRequestedContainers.get(),\n+          numCompletedContainers.get(), numAllocatedContainers.get(),\n+          numFailedContainers.get(), diagnostics);\n       success \u003d false;\n     }\n     try {\n-      amRMClient.unregisterApplicationMaster(appStatus, appMessage, null);\n-    } catch (YarnException ex) {\n+      amRMClient.unregisterApplicationMaster(appStatus, message, null);\n+    } catch (YarnException | IOException ex) {\n       LOG.error(\"Failed to unregister application\", ex);\n-    } catch (IOException e) {\n-      LOG.error(\"Failed to unregister application\", e);\n     }\n-    \n     amRMClient.stop();\n \n     // Stop Timeline Client\n     if(timelineServiceV1Enabled) {\n       timelineClient.stop();\n     }\n     if (timelineServiceV2Enabled) {\n       timelineV2Client.stop();\n     }\n \n     return success;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected boolean finish() {\n    // wait for completion.\n    while (!done\n        \u0026\u0026 (numCompletedContainers.get() !\u003d numTotalContainers)) {\n      try {\n        Thread.sleep(200);\n      } catch (InterruptedException ex) {}\n    }\n\n    if (timelineServiceV1Enabled) {\n      publishApplicationAttemptEvent(timelineClient, appAttemptID.toString(),\n          DSEvent.DS_APP_ATTEMPT_END, domainId, appSubmitterUgi);\n    }\n\n    if (timelineServiceV2Enabled) {\n      publishApplicationAttemptEventOnTimelineServiceV2(\n          DSEvent.DS_APP_ATTEMPT_END);\n    }\n\n    // Join all launched threads\n    // needed for when we time out\n    // and we need to release containers\n    for (Thread launchThread : launchThreads) {\n      try {\n        launchThread.join(10000);\n      } catch (InterruptedException e) {\n        LOG.info(\"Exception thrown in thread join: \" + e.getMessage());\n        e.printStackTrace();\n      }\n    }\n\n    // When the application completes, it should stop all running containers\n    LOG.info(\"Application completed. Stopping running containers\");\n    nmClientAsync.stop();\n\n    // When the application completes, it should send a finish application\n    // signal to the RM\n    LOG.info(\"Application completed. Signalling finish to RM\");\n\n    FinalApplicationStatus appStatus;\n    boolean success \u003d true;\n    String message \u003d null;\n    if (numCompletedContainers.get() - numFailedContainers.get()\n        \u003e\u003d numTotalContainers) {\n      appStatus \u003d FinalApplicationStatus.SUCCEEDED;\n    } else {\n      appStatus \u003d FinalApplicationStatus.FAILED;\n      message \u003d String.format(\"Application Failure: desired \u003d %d, \" +\n              \"completed \u003d %d, allocated \u003d %d, failed \u003d %d, \" +\n              \"diagnostics \u003d %s\", numRequestedContainers.get(),\n          numCompletedContainers.get(), numAllocatedContainers.get(),\n          numFailedContainers.get(), diagnostics);\n      success \u003d false;\n    }\n    try {\n      amRMClient.unregisterApplicationMaster(appStatus, message, null);\n    } catch (YarnException | IOException ex) {\n      LOG.error(\"Failed to unregister application\", ex);\n    }\n    amRMClient.stop();\n\n    // Stop Timeline Client\n    if(timelineServiceV1Enabled) {\n      timelineClient.stop();\n    }\n    if (timelineServiceV2Enabled) {\n      timelineV2Client.stop();\n    }\n\n    return success;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "d09058b2fd18803d12f0835fdf78aef5e0b99c90": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6736. Consider writing to both ats v1 \u0026 v2 from RM for smoother upgrades. Contributed by Aaron Gresch.\n",
      "commitDate": "15/01/18 6:28 PM",
      "commitName": "d09058b2fd18803d12f0835fdf78aef5e0b99c90",
      "commitAuthor": "Rohith Sharma K S",
      "commitDateOld": "09/01/18 3:09 AM",
      "commitNameOld": "783a01eb4a155044a54a30a636b86b3ab2b33044",
      "commitAuthorOld": "Sunil G",
      "daysBetweenCommits": 6.64,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,71 +1,74 @@\n   protected boolean finish() {\n     // wait for completion.\n     while (!done\n         \u0026\u0026 (numCompletedContainers.get() !\u003d numTotalContainers)) {\n       try {\n         Thread.sleep(200);\n       } catch (InterruptedException ex) {}\n     }\n \n+    if (timelineServiceV1Enabled) {\n+      publishApplicationAttemptEvent(timelineClient, appAttemptID.toString(),\n+          DSEvent.DS_APP_ATTEMPT_END, domainId, appSubmitterUgi);\n+    }\n+\n     if (timelineServiceV2Enabled) {\n       publishApplicationAttemptEventOnTimelineServiceV2(\n           DSEvent.DS_APP_ATTEMPT_END);\n-    } else if (timelineServiceV1Enabled) {\n-      publishApplicationAttemptEvent(timelineClient, appAttemptID.toString(),\n-          DSEvent.DS_APP_ATTEMPT_END, domainId, appSubmitterUgi);\n     }\n \n     // Join all launched threads\n     // needed for when we time out\n     // and we need to release containers\n     for (Thread launchThread : launchThreads) {\n       try {\n         launchThread.join(10000);\n       } catch (InterruptedException e) {\n         LOG.info(\"Exception thrown in thread join: \" + e.getMessage());\n         e.printStackTrace();\n       }\n     }\n \n     // When the application completes, it should stop all running containers\n     LOG.info(\"Application completed. Stopping running containers\");\n     nmClientAsync.stop();\n \n     // When the application completes, it should send a finish application\n     // signal to the RM\n     LOG.info(\"Application completed. Signalling finish to RM\");\n \n     FinalApplicationStatus appStatus;\n     String appMessage \u003d null;\n     boolean success \u003d true;\n     if (numCompletedContainers.get() - numFailedContainers.get()\n         \u003e\u003d numTotalContainers) {\n       appStatus \u003d FinalApplicationStatus.SUCCEEDED;\n     } else {\n       appStatus \u003d FinalApplicationStatus.FAILED;\n       appMessage \u003d \"Diagnostics.\" + \", total\u003d\" + numTotalContainers\n           + \", completed\u003d\" + numCompletedContainers.get() + \", allocated\u003d\"\n           + numAllocatedContainers.get() + \", failed\u003d\"\n           + numFailedContainers.get();\n       LOG.info(appMessage);\n       success \u003d false;\n     }\n     try {\n       amRMClient.unregisterApplicationMaster(appStatus, appMessage, null);\n     } catch (YarnException ex) {\n       LOG.error(\"Failed to unregister application\", ex);\n     } catch (IOException e) {\n       LOG.error(\"Failed to unregister application\", e);\n     }\n     \n     amRMClient.stop();\n \n     // Stop Timeline Client\n     if(timelineServiceV1Enabled) {\n       timelineClient.stop();\n-    } else if (timelineServiceV2Enabled) {\n+    }\n+    if (timelineServiceV2Enabled) {\n       timelineV2Client.stop();\n     }\n \n     return success;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected boolean finish() {\n    // wait for completion.\n    while (!done\n        \u0026\u0026 (numCompletedContainers.get() !\u003d numTotalContainers)) {\n      try {\n        Thread.sleep(200);\n      } catch (InterruptedException ex) {}\n    }\n\n    if (timelineServiceV1Enabled) {\n      publishApplicationAttemptEvent(timelineClient, appAttemptID.toString(),\n          DSEvent.DS_APP_ATTEMPT_END, domainId, appSubmitterUgi);\n    }\n\n    if (timelineServiceV2Enabled) {\n      publishApplicationAttemptEventOnTimelineServiceV2(\n          DSEvent.DS_APP_ATTEMPT_END);\n    }\n\n    // Join all launched threads\n    // needed for when we time out\n    // and we need to release containers\n    for (Thread launchThread : launchThreads) {\n      try {\n        launchThread.join(10000);\n      } catch (InterruptedException e) {\n        LOG.info(\"Exception thrown in thread join: \" + e.getMessage());\n        e.printStackTrace();\n      }\n    }\n\n    // When the application completes, it should stop all running containers\n    LOG.info(\"Application completed. Stopping running containers\");\n    nmClientAsync.stop();\n\n    // When the application completes, it should send a finish application\n    // signal to the RM\n    LOG.info(\"Application completed. Signalling finish to RM\");\n\n    FinalApplicationStatus appStatus;\n    String appMessage \u003d null;\n    boolean success \u003d true;\n    if (numCompletedContainers.get() - numFailedContainers.get()\n        \u003e\u003d numTotalContainers) {\n      appStatus \u003d FinalApplicationStatus.SUCCEEDED;\n    } else {\n      appStatus \u003d FinalApplicationStatus.FAILED;\n      appMessage \u003d \"Diagnostics.\" + \", total\u003d\" + numTotalContainers\n          + \", completed\u003d\" + numCompletedContainers.get() + \", allocated\u003d\"\n          + numAllocatedContainers.get() + \", failed\u003d\"\n          + numFailedContainers.get();\n      LOG.info(appMessage);\n      success \u003d false;\n    }\n    try {\n      amRMClient.unregisterApplicationMaster(appStatus, appMessage, null);\n    } catch (YarnException ex) {\n      LOG.error(\"Failed to unregister application\", ex);\n    } catch (IOException e) {\n      LOG.error(\"Failed to unregister application\", e);\n    }\n    \n    amRMClient.stop();\n\n    // Stop Timeline Client\n    if(timelineServiceV1Enabled) {\n      timelineClient.stop();\n    }\n    if (timelineServiceV2Enabled) {\n      timelineV2Client.stop();\n    }\n\n    return success;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "4fa1afdb883dab8786d2fb5c72a195dd2e87d711": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4675. Reorganize TimelineClient and TimelineClientImpl into separate classes for ATSv1.x and ATSv2. Contributed by Naganarasimha G R.\n",
      "commitDate": "16/02/17 11:41 AM",
      "commitName": "4fa1afdb883dab8786d2fb5c72a195dd2e87d711",
      "commitAuthor": "Sangjin Lee",
      "commitDateOld": "06/01/17 2:26 PM",
      "commitNameOld": "71a4acf74bc9ca34f0e57835c9d6e3efbe7c0567",
      "commitAuthorOld": "Daniel Templeton",
      "daysBetweenCommits": 40.89,
      "commitsBetweenForRepo": 204,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,71 +1,71 @@\n   protected boolean finish() {\n     // wait for completion.\n     while (!done\n         \u0026\u0026 (numCompletedContainers.get() !\u003d numTotalContainers)) {\n       try {\n         Thread.sleep(200);\n       } catch (InterruptedException ex) {}\n     }\n \n-    if (timelineClient !\u003d null) {\n-      if (timelineServiceV2) {\n-        publishApplicationAttemptEventOnTimelineServiceV2(\n-            DSEvent.DS_APP_ATTEMPT_END);\n-      } else {\n-        publishApplicationAttemptEvent(timelineClient, appAttemptID.toString(),\n-            DSEvent.DS_APP_ATTEMPT_END, domainId, appSubmitterUgi);\n-      }\n+    if (timelineServiceV2Enabled) {\n+      publishApplicationAttemptEventOnTimelineServiceV2(\n+          DSEvent.DS_APP_ATTEMPT_END);\n+    } else if (timelineServiceV1Enabled) {\n+      publishApplicationAttemptEvent(timelineClient, appAttemptID.toString(),\n+          DSEvent.DS_APP_ATTEMPT_END, domainId, appSubmitterUgi);\n     }\n \n     // Join all launched threads\n     // needed for when we time out\n     // and we need to release containers\n     for (Thread launchThread : launchThreads) {\n       try {\n         launchThread.join(10000);\n       } catch (InterruptedException e) {\n         LOG.info(\"Exception thrown in thread join: \" + e.getMessage());\n         e.printStackTrace();\n       }\n     }\n \n     // When the application completes, it should stop all running containers\n     LOG.info(\"Application completed. Stopping running containers\");\n     nmClientAsync.stop();\n \n     // When the application completes, it should send a finish application\n     // signal to the RM\n     LOG.info(\"Application completed. Signalling finish to RM\");\n \n     FinalApplicationStatus appStatus;\n     String appMessage \u003d null;\n     boolean success \u003d true;\n     if (numCompletedContainers.get() - numFailedContainers.get()\n         \u003e\u003d numTotalContainers) {\n       appStatus \u003d FinalApplicationStatus.SUCCEEDED;\n     } else {\n       appStatus \u003d FinalApplicationStatus.FAILED;\n       appMessage \u003d \"Diagnostics.\" + \", total\u003d\" + numTotalContainers\n           + \", completed\u003d\" + numCompletedContainers.get() + \", allocated\u003d\"\n           + numAllocatedContainers.get() + \", failed\u003d\"\n           + numFailedContainers.get();\n       LOG.info(appMessage);\n       success \u003d false;\n     }\n     try {\n       amRMClient.unregisterApplicationMaster(appStatus, appMessage, null);\n     } catch (YarnException ex) {\n       LOG.error(\"Failed to unregister application\", ex);\n     } catch (IOException e) {\n       LOG.error(\"Failed to unregister application\", e);\n     }\n     \n     amRMClient.stop();\n \n     // Stop Timeline Client\n-    if(timelineClient !\u003d null) {\n+    if(timelineServiceV1Enabled) {\n       timelineClient.stop();\n+    } else if (timelineServiceV2Enabled) {\n+      timelineV2Client.stop();\n     }\n \n     return success;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected boolean finish() {\n    // wait for completion.\n    while (!done\n        \u0026\u0026 (numCompletedContainers.get() !\u003d numTotalContainers)) {\n      try {\n        Thread.sleep(200);\n      } catch (InterruptedException ex) {}\n    }\n\n    if (timelineServiceV2Enabled) {\n      publishApplicationAttemptEventOnTimelineServiceV2(\n          DSEvent.DS_APP_ATTEMPT_END);\n    } else if (timelineServiceV1Enabled) {\n      publishApplicationAttemptEvent(timelineClient, appAttemptID.toString(),\n          DSEvent.DS_APP_ATTEMPT_END, domainId, appSubmitterUgi);\n    }\n\n    // Join all launched threads\n    // needed for when we time out\n    // and we need to release containers\n    for (Thread launchThread : launchThreads) {\n      try {\n        launchThread.join(10000);\n      } catch (InterruptedException e) {\n        LOG.info(\"Exception thrown in thread join: \" + e.getMessage());\n        e.printStackTrace();\n      }\n    }\n\n    // When the application completes, it should stop all running containers\n    LOG.info(\"Application completed. Stopping running containers\");\n    nmClientAsync.stop();\n\n    // When the application completes, it should send a finish application\n    // signal to the RM\n    LOG.info(\"Application completed. Signalling finish to RM\");\n\n    FinalApplicationStatus appStatus;\n    String appMessage \u003d null;\n    boolean success \u003d true;\n    if (numCompletedContainers.get() - numFailedContainers.get()\n        \u003e\u003d numTotalContainers) {\n      appStatus \u003d FinalApplicationStatus.SUCCEEDED;\n    } else {\n      appStatus \u003d FinalApplicationStatus.FAILED;\n      appMessage \u003d \"Diagnostics.\" + \", total\u003d\" + numTotalContainers\n          + \", completed\u003d\" + numCompletedContainers.get() + \", allocated\u003d\"\n          + numAllocatedContainers.get() + \", failed\u003d\"\n          + numFailedContainers.get();\n      LOG.info(appMessage);\n      success \u003d false;\n    }\n    try {\n      amRMClient.unregisterApplicationMaster(appStatus, appMessage, null);\n    } catch (YarnException ex) {\n      LOG.error(\"Failed to unregister application\", ex);\n    } catch (IOException e) {\n      LOG.error(\"Failed to unregister application\", e);\n    }\n    \n    amRMClient.stop();\n\n    // Stop Timeline Client\n    if(timelineServiceV1Enabled) {\n      timelineClient.stop();\n    } else if (timelineServiceV2Enabled) {\n      timelineV2Client.stop();\n    }\n\n    return success;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "89e5c44f9e891a3579384c3fa3766937cd4970f1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4356. Ensure the timeline service v.2 is disabled cleanly and has no\nimpact when it\u0027s turned off. Contributed by Sangjin Lee.\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "89e5c44f9e891a3579384c3fa3766937cd4970f1",
      "commitAuthor": "Li Lu",
      "commitDateOld": "10/07/16 8:45 AM",
      "commitNameOld": "5712b8f9fd1859fe046b482889239bd164ed7dab",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 52,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,72 +1,71 @@\n   protected boolean finish() {\n     // wait for completion.\n     while (!done\n         \u0026\u0026 (numCompletedContainers.get() !\u003d numTotalContainers)) {\n       try {\n         Thread.sleep(200);\n       } catch (InterruptedException ex) {}\n     }\n \n     if (timelineClient !\u003d null) {\n-      if (newTimelineService) {\n-        publishApplicationAttemptEventOnNewTimelineService(timelineClient,\n-          appAttemptID.toString(), DSEvent.DS_APP_ATTEMPT_END, domainId,\n-          appSubmitterUgi);\n+      if (timelineServiceV2) {\n+        publishApplicationAttemptEventOnTimelineServiceV2(\n+            DSEvent.DS_APP_ATTEMPT_END);\n       } else {\n         publishApplicationAttemptEvent(timelineClient, appAttemptID.toString(),\n           DSEvent.DS_APP_ATTEMPT_END, domainId, appSubmitterUgi);\n       }\n     }\n \n     // Join all launched threads\n     // needed for when we time out\n     // and we need to release containers\n     for (Thread launchThread : launchThreads) {\n       try {\n         launchThread.join(10000);\n       } catch (InterruptedException e) {\n         LOG.info(\"Exception thrown in thread join: \" + e.getMessage());\n         e.printStackTrace();\n       }\n     }\n \n     // When the application completes, it should stop all running containers\n     LOG.info(\"Application completed. Stopping running containers\");\n     nmClientAsync.stop();\n \n     // When the application completes, it should send a finish application\n     // signal to the RM\n     LOG.info(\"Application completed. Signalling finish to RM\");\n \n     FinalApplicationStatus appStatus;\n     String appMessage \u003d null;\n     boolean success \u003d true;\n     if (numCompletedContainers.get() - numFailedContainers.get()\n         \u003e\u003d numTotalContainers) {\n       appStatus \u003d FinalApplicationStatus.SUCCEEDED;\n     } else {\n       appStatus \u003d FinalApplicationStatus.FAILED;\n       appMessage \u003d \"Diagnostics.\" + \", total\u003d\" + numTotalContainers\n           + \", completed\u003d\" + numCompletedContainers.get() + \", allocated\u003d\"\n           + numAllocatedContainers.get() + \", failed\u003d\"\n           + numFailedContainers.get();\n       LOG.info(appMessage);\n       success \u003d false;\n     }\n     try {\n       amRMClient.unregisterApplicationMaster(appStatus, appMessage, null);\n     } catch (YarnException ex) {\n       LOG.error(\"Failed to unregister application\", ex);\n     } catch (IOException e) {\n       LOG.error(\"Failed to unregister application\", e);\n     }\n     \n     amRMClient.stop();\n \n     // Stop Timeline Client\n     if(timelineClient !\u003d null) {\n       timelineClient.stop();\n     }\n \n     return success;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected boolean finish() {\n    // wait for completion.\n    while (!done\n        \u0026\u0026 (numCompletedContainers.get() !\u003d numTotalContainers)) {\n      try {\n        Thread.sleep(200);\n      } catch (InterruptedException ex) {}\n    }\n\n    if (timelineClient !\u003d null) {\n      if (timelineServiceV2) {\n        publishApplicationAttemptEventOnTimelineServiceV2(\n            DSEvent.DS_APP_ATTEMPT_END);\n      } else {\n        publishApplicationAttemptEvent(timelineClient, appAttemptID.toString(),\n          DSEvent.DS_APP_ATTEMPT_END, domainId, appSubmitterUgi);\n      }\n    }\n\n    // Join all launched threads\n    // needed for when we time out\n    // and we need to release containers\n    for (Thread launchThread : launchThreads) {\n      try {\n        launchThread.join(10000);\n      } catch (InterruptedException e) {\n        LOG.info(\"Exception thrown in thread join: \" + e.getMessage());\n        e.printStackTrace();\n      }\n    }\n\n    // When the application completes, it should stop all running containers\n    LOG.info(\"Application completed. Stopping running containers\");\n    nmClientAsync.stop();\n\n    // When the application completes, it should send a finish application\n    // signal to the RM\n    LOG.info(\"Application completed. Signalling finish to RM\");\n\n    FinalApplicationStatus appStatus;\n    String appMessage \u003d null;\n    boolean success \u003d true;\n    if (numCompletedContainers.get() - numFailedContainers.get()\n        \u003e\u003d numTotalContainers) {\n      appStatus \u003d FinalApplicationStatus.SUCCEEDED;\n    } else {\n      appStatus \u003d FinalApplicationStatus.FAILED;\n      appMessage \u003d \"Diagnostics.\" + \", total\u003d\" + numTotalContainers\n          + \", completed\u003d\" + numCompletedContainers.get() + \", allocated\u003d\"\n          + numAllocatedContainers.get() + \", failed\u003d\"\n          + numFailedContainers.get();\n      LOG.info(appMessage);\n      success \u003d false;\n    }\n    try {\n      amRMClient.unregisterApplicationMaster(appStatus, appMessage, null);\n    } catch (YarnException ex) {\n      LOG.error(\"Failed to unregister application\", ex);\n    } catch (IOException e) {\n      LOG.error(\"Failed to unregister application\", e);\n    }\n    \n    amRMClient.stop();\n\n    // Stop Timeline Client\n    if(timelineClient !\u003d null) {\n      timelineClient.stop();\n    }\n\n    return success;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "d45ff878c4cb8b359abb17ecf09d24b6f862874c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3125. Made the distributed shell use timeline service next gen and add an integration test for it. Contributed by Junping Du and Li Lu.\n\n(cherry picked from commit bf08f7f0ed4900ce52f98137297dd1a47ba2a536)\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "d45ff878c4cb8b359abb17ecf09d24b6f862874c",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "09/07/16 5:09 AM",
      "commitNameOld": "9bdb5bebea1183ec2f697ee3e55392df4fe697bb",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 1.15,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,66 +1,72 @@\n   protected boolean finish() {\n     // wait for completion.\n     while (!done\n         \u0026\u0026 (numCompletedContainers.get() !\u003d numTotalContainers)) {\n       try {\n         Thread.sleep(200);\n       } catch (InterruptedException ex) {}\n     }\n \n-    if(timelineClient !\u003d null) {\n-      publishApplicationAttemptEvent(timelineClient, appAttemptID.toString(),\n+    if (timelineClient !\u003d null) {\n+      if (newTimelineService) {\n+        publishApplicationAttemptEventOnNewTimelineService(timelineClient,\n+          appAttemptID.toString(), DSEvent.DS_APP_ATTEMPT_END, domainId,\n+          appSubmitterUgi);\n+      } else {\n+        publishApplicationAttemptEvent(timelineClient, appAttemptID.toString(),\n           DSEvent.DS_APP_ATTEMPT_END, domainId, appSubmitterUgi);\n+      }\n     }\n \n     // Join all launched threads\n     // needed for when we time out\n     // and we need to release containers\n     for (Thread launchThread : launchThreads) {\n       try {\n         launchThread.join(10000);\n       } catch (InterruptedException e) {\n         LOG.info(\"Exception thrown in thread join: \" + e.getMessage());\n         e.printStackTrace();\n       }\n     }\n \n     // When the application completes, it should stop all running containers\n     LOG.info(\"Application completed. Stopping running containers\");\n     nmClientAsync.stop();\n \n     // When the application completes, it should send a finish application\n     // signal to the RM\n     LOG.info(\"Application completed. Signalling finish to RM\");\n \n     FinalApplicationStatus appStatus;\n     String appMessage \u003d null;\n     boolean success \u003d true;\n     if (numCompletedContainers.get() - numFailedContainers.get()\n         \u003e\u003d numTotalContainers) {\n       appStatus \u003d FinalApplicationStatus.SUCCEEDED;\n     } else {\n       appStatus \u003d FinalApplicationStatus.FAILED;\n       appMessage \u003d \"Diagnostics.\" + \", total\u003d\" + numTotalContainers\n           + \", completed\u003d\" + numCompletedContainers.get() + \", allocated\u003d\"\n           + numAllocatedContainers.get() + \", failed\u003d\"\n           + numFailedContainers.get();\n       LOG.info(appMessage);\n       success \u003d false;\n     }\n     try {\n       amRMClient.unregisterApplicationMaster(appStatus, appMessage, null);\n     } catch (YarnException ex) {\n       LOG.error(\"Failed to unregister application\", ex);\n     } catch (IOException e) {\n       LOG.error(\"Failed to unregister application\", e);\n     }\n     \n     amRMClient.stop();\n \n     // Stop Timeline Client\n     if(timelineClient !\u003d null) {\n       timelineClient.stop();\n     }\n \n     return success;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected boolean finish() {\n    // wait for completion.\n    while (!done\n        \u0026\u0026 (numCompletedContainers.get() !\u003d numTotalContainers)) {\n      try {\n        Thread.sleep(200);\n      } catch (InterruptedException ex) {}\n    }\n\n    if (timelineClient !\u003d null) {\n      if (newTimelineService) {\n        publishApplicationAttemptEventOnNewTimelineService(timelineClient,\n          appAttemptID.toString(), DSEvent.DS_APP_ATTEMPT_END, domainId,\n          appSubmitterUgi);\n      } else {\n        publishApplicationAttemptEvent(timelineClient, appAttemptID.toString(),\n          DSEvent.DS_APP_ATTEMPT_END, domainId, appSubmitterUgi);\n      }\n    }\n\n    // Join all launched threads\n    // needed for when we time out\n    // and we need to release containers\n    for (Thread launchThread : launchThreads) {\n      try {\n        launchThread.join(10000);\n      } catch (InterruptedException e) {\n        LOG.info(\"Exception thrown in thread join: \" + e.getMessage());\n        e.printStackTrace();\n      }\n    }\n\n    // When the application completes, it should stop all running containers\n    LOG.info(\"Application completed. Stopping running containers\");\n    nmClientAsync.stop();\n\n    // When the application completes, it should send a finish application\n    // signal to the RM\n    LOG.info(\"Application completed. Signalling finish to RM\");\n\n    FinalApplicationStatus appStatus;\n    String appMessage \u003d null;\n    boolean success \u003d true;\n    if (numCompletedContainers.get() - numFailedContainers.get()\n        \u003e\u003d numTotalContainers) {\n      appStatus \u003d FinalApplicationStatus.SUCCEEDED;\n    } else {\n      appStatus \u003d FinalApplicationStatus.FAILED;\n      appMessage \u003d \"Diagnostics.\" + \", total\u003d\" + numTotalContainers\n          + \", completed\u003d\" + numCompletedContainers.get() + \", allocated\u003d\"\n          + numAllocatedContainers.get() + \", failed\u003d\"\n          + numFailedContainers.get();\n      LOG.info(appMessage);\n      success \u003d false;\n    }\n    try {\n      amRMClient.unregisterApplicationMaster(appStatus, appMessage, null);\n    } catch (YarnException ex) {\n      LOG.error(\"Failed to unregister application\", ex);\n    } catch (IOException e) {\n      LOG.error(\"Failed to unregister application\", e);\n    }\n    \n    amRMClient.stop();\n\n    // Stop Timeline Client\n    if(timelineClient !\u003d null) {\n      timelineClient.stop();\n    }\n\n    return success;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "48c931331cc43970e31866732f9ac82ee806ee03": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5131. Distributed shell AM fails when extra container arrives during finishing. Contributed by Wangda Tan.\n",
      "commitDate": "25/05/16 6:18 AM",
      "commitName": "48c931331cc43970e31866732f9ac82ee806ee03",
      "commitAuthor": "Junping Du",
      "commitDateOld": "29/04/16 3:39 AM",
      "commitNameOld": "0f25a1bb52bc56661fd020a6ba82df99f8c6ef1f",
      "commitAuthorOld": "Varun Vasudev",
      "daysBetweenCommits": 26.11,
      "commitsBetweenForRepo": 175,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,66 +1,66 @@\n   protected boolean finish() {\n     // wait for completion.\n     while (!done\n         \u0026\u0026 (numCompletedContainers.get() !\u003d numTotalContainers)) {\n       try {\n         Thread.sleep(200);\n       } catch (InterruptedException ex) {}\n     }\n \n     if(timelineClient !\u003d null) {\n       publishApplicationAttemptEvent(timelineClient, appAttemptID.toString(),\n           DSEvent.DS_APP_ATTEMPT_END, domainId, appSubmitterUgi);\n     }\n \n     // Join all launched threads\n     // needed for when we time out\n     // and we need to release containers\n     for (Thread launchThread : launchThreads) {\n       try {\n         launchThread.join(10000);\n       } catch (InterruptedException e) {\n         LOG.info(\"Exception thrown in thread join: \" + e.getMessage());\n         e.printStackTrace();\n       }\n     }\n \n     // When the application completes, it should stop all running containers\n     LOG.info(\"Application completed. Stopping running containers\");\n     nmClientAsync.stop();\n \n     // When the application completes, it should send a finish application\n     // signal to the RM\n     LOG.info(\"Application completed. Signalling finish to RM\");\n \n     FinalApplicationStatus appStatus;\n     String appMessage \u003d null;\n     boolean success \u003d true;\n-    if (numFailedContainers.get() \u003d\u003d 0 \u0026\u0026 \n-        numCompletedContainers.get() \u003d\u003d numTotalContainers) {\n+    if (numCompletedContainers.get() - numFailedContainers.get()\n+        \u003e\u003d numTotalContainers) {\n       appStatus \u003d FinalApplicationStatus.SUCCEEDED;\n     } else {\n       appStatus \u003d FinalApplicationStatus.FAILED;\n       appMessage \u003d \"Diagnostics.\" + \", total\u003d\" + numTotalContainers\n           + \", completed\u003d\" + numCompletedContainers.get() + \", allocated\u003d\"\n           + numAllocatedContainers.get() + \", failed\u003d\"\n           + numFailedContainers.get();\n       LOG.info(appMessage);\n       success \u003d false;\n     }\n     try {\n       amRMClient.unregisterApplicationMaster(appStatus, appMessage, null);\n     } catch (YarnException ex) {\n       LOG.error(\"Failed to unregister application\", ex);\n     } catch (IOException e) {\n       LOG.error(\"Failed to unregister application\", e);\n     }\n     \n     amRMClient.stop();\n \n     // Stop Timeline Client\n     if(timelineClient !\u003d null) {\n       timelineClient.stop();\n     }\n \n     return success;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected boolean finish() {\n    // wait for completion.\n    while (!done\n        \u0026\u0026 (numCompletedContainers.get() !\u003d numTotalContainers)) {\n      try {\n        Thread.sleep(200);\n      } catch (InterruptedException ex) {}\n    }\n\n    if(timelineClient !\u003d null) {\n      publishApplicationAttemptEvent(timelineClient, appAttemptID.toString(),\n          DSEvent.DS_APP_ATTEMPT_END, domainId, appSubmitterUgi);\n    }\n\n    // Join all launched threads\n    // needed for when we time out\n    // and we need to release containers\n    for (Thread launchThread : launchThreads) {\n      try {\n        launchThread.join(10000);\n      } catch (InterruptedException e) {\n        LOG.info(\"Exception thrown in thread join: \" + e.getMessage());\n        e.printStackTrace();\n      }\n    }\n\n    // When the application completes, it should stop all running containers\n    LOG.info(\"Application completed. Stopping running containers\");\n    nmClientAsync.stop();\n\n    // When the application completes, it should send a finish application\n    // signal to the RM\n    LOG.info(\"Application completed. Signalling finish to RM\");\n\n    FinalApplicationStatus appStatus;\n    String appMessage \u003d null;\n    boolean success \u003d true;\n    if (numCompletedContainers.get() - numFailedContainers.get()\n        \u003e\u003d numTotalContainers) {\n      appStatus \u003d FinalApplicationStatus.SUCCEEDED;\n    } else {\n      appStatus \u003d FinalApplicationStatus.FAILED;\n      appMessage \u003d \"Diagnostics.\" + \", total\u003d\" + numTotalContainers\n          + \", completed\u003d\" + numCompletedContainers.get() + \", allocated\u003d\"\n          + numAllocatedContainers.get() + \", failed\u003d\"\n          + numFailedContainers.get();\n      LOG.info(appMessage);\n      success \u003d false;\n    }\n    try {\n      amRMClient.unregisterApplicationMaster(appStatus, appMessage, null);\n    } catch (YarnException ex) {\n      LOG.error(\"Failed to unregister application\", ex);\n    } catch (IOException e) {\n      LOG.error(\"Failed to unregister application\", e);\n    }\n    \n    amRMClient.stop();\n\n    // Stop Timeline Client\n    if(timelineClient !\u003d null) {\n      timelineClient.stop();\n    }\n\n    return success;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "aa4a192feb8939353254d058c5f81bddbd0335c0": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3522. Fixed DistributedShell to instantiate TimeLineClient as the correct user. Contributed by Zhijie Shen\n",
      "commitDate": "23/04/15 11:07 AM",
      "commitName": "aa4a192feb8939353254d058c5f81bddbd0335c0",
      "commitAuthor": "Jian He",
      "commitDateOld": "23/12/14 8:04 PM",
      "commitNameOld": "d468c9aaf15e977f12e6214b47996412c907e069",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 120.59,
      "commitsBetweenForRepo": 969,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,61 +1,66 @@\n   protected boolean finish() {\n     // wait for completion.\n     while (!done\n         \u0026\u0026 (numCompletedContainers.get() !\u003d numTotalContainers)) {\n       try {\n         Thread.sleep(200);\n       } catch (InterruptedException ex) {}\n     }\n \n+    if(timelineClient !\u003d null) {\n+      publishApplicationAttemptEvent(timelineClient, appAttemptID.toString(),\n+          DSEvent.DS_APP_ATTEMPT_END, domainId, appSubmitterUgi);\n+    }\n+\n     // Join all launched threads\n     // needed for when we time out\n     // and we need to release containers\n     for (Thread launchThread : launchThreads) {\n       try {\n         launchThread.join(10000);\n       } catch (InterruptedException e) {\n         LOG.info(\"Exception thrown in thread join: \" + e.getMessage());\n         e.printStackTrace();\n       }\n     }\n \n     // When the application completes, it should stop all running containers\n     LOG.info(\"Application completed. Stopping running containers\");\n     nmClientAsync.stop();\n \n     // When the application completes, it should send a finish application\n     // signal to the RM\n     LOG.info(\"Application completed. Signalling finish to RM\");\n \n     FinalApplicationStatus appStatus;\n     String appMessage \u003d null;\n     boolean success \u003d true;\n     if (numFailedContainers.get() \u003d\u003d 0 \u0026\u0026 \n         numCompletedContainers.get() \u003d\u003d numTotalContainers) {\n       appStatus \u003d FinalApplicationStatus.SUCCEEDED;\n     } else {\n       appStatus \u003d FinalApplicationStatus.FAILED;\n       appMessage \u003d \"Diagnostics.\" + \", total\u003d\" + numTotalContainers\n           + \", completed\u003d\" + numCompletedContainers.get() + \", allocated\u003d\"\n           + numAllocatedContainers.get() + \", failed\u003d\"\n           + numFailedContainers.get();\n       LOG.info(appMessage);\n       success \u003d false;\n     }\n     try {\n       amRMClient.unregisterApplicationMaster(appStatus, appMessage, null);\n     } catch (YarnException ex) {\n       LOG.error(\"Failed to unregister application\", ex);\n     } catch (IOException e) {\n       LOG.error(\"Failed to unregister application\", e);\n     }\n     \n     amRMClient.stop();\n \n     // Stop Timeline Client\n     if(timelineClient !\u003d null) {\n       timelineClient.stop();\n     }\n \n     return success;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected boolean finish() {\n    // wait for completion.\n    while (!done\n        \u0026\u0026 (numCompletedContainers.get() !\u003d numTotalContainers)) {\n      try {\n        Thread.sleep(200);\n      } catch (InterruptedException ex) {}\n    }\n\n    if(timelineClient !\u003d null) {\n      publishApplicationAttemptEvent(timelineClient, appAttemptID.toString(),\n          DSEvent.DS_APP_ATTEMPT_END, domainId, appSubmitterUgi);\n    }\n\n    // Join all launched threads\n    // needed for when we time out\n    // and we need to release containers\n    for (Thread launchThread : launchThreads) {\n      try {\n        launchThread.join(10000);\n      } catch (InterruptedException e) {\n        LOG.info(\"Exception thrown in thread join: \" + e.getMessage());\n        e.printStackTrace();\n      }\n    }\n\n    // When the application completes, it should stop all running containers\n    LOG.info(\"Application completed. Stopping running containers\");\n    nmClientAsync.stop();\n\n    // When the application completes, it should send a finish application\n    // signal to the RM\n    LOG.info(\"Application completed. Signalling finish to RM\");\n\n    FinalApplicationStatus appStatus;\n    String appMessage \u003d null;\n    boolean success \u003d true;\n    if (numFailedContainers.get() \u003d\u003d 0 \u0026\u0026 \n        numCompletedContainers.get() \u003d\u003d numTotalContainers) {\n      appStatus \u003d FinalApplicationStatus.SUCCEEDED;\n    } else {\n      appStatus \u003d FinalApplicationStatus.FAILED;\n      appMessage \u003d \"Diagnostics.\" + \", total\u003d\" + numTotalContainers\n          + \", completed\u003d\" + numCompletedContainers.get() + \", allocated\u003d\"\n          + numAllocatedContainers.get() + \", failed\u003d\"\n          + numFailedContainers.get();\n      LOG.info(appMessage);\n      success \u003d false;\n    }\n    try {\n      amRMClient.unregisterApplicationMaster(appStatus, appMessage, null);\n    } catch (YarnException ex) {\n      LOG.error(\"Failed to unregister application\", ex);\n    } catch (IOException e) {\n      LOG.error(\"Failed to unregister application\", e);\n    }\n    \n    amRMClient.stop();\n\n    // Stop Timeline Client\n    if(timelineClient !\u003d null) {\n      timelineClient.stop();\n    }\n\n    return success;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "c298a9a845f89317eb9efad332e6657c56736a4d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2375. Allow enabling/disabling timeline server per framework. (Mit Desai via jeagles)\n",
      "commitDate": "20/11/14 9:34 PM",
      "commitName": "c298a9a845f89317eb9efad332e6657c56736a4d",
      "commitAuthor": "Jonathan Eagles",
      "commitDateOld": "29/10/14 12:12 PM",
      "commitNameOld": "a8c120222047280234c3411ce1c1c9b17f08c851",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 22.43,
      "commitsBetweenForRepo": 218,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,56 +1,61 @@\n   protected boolean finish() {\n     // wait for completion.\n     while (!done\n         \u0026\u0026 (numCompletedContainers.get() !\u003d numTotalContainers)) {\n       try {\n         Thread.sleep(200);\n       } catch (InterruptedException ex) {}\n     }\n \n     // Join all launched threads\n     // needed for when we time out\n     // and we need to release containers\n     for (Thread launchThread : launchThreads) {\n       try {\n         launchThread.join(10000);\n       } catch (InterruptedException e) {\n         LOG.info(\"Exception thrown in thread join: \" + e.getMessage());\n         e.printStackTrace();\n       }\n     }\n \n     // When the application completes, it should stop all running containers\n     LOG.info(\"Application completed. Stopping running containers\");\n     nmClientAsync.stop();\n \n     // When the application completes, it should send a finish application\n     // signal to the RM\n     LOG.info(\"Application completed. Signalling finish to RM\");\n \n     FinalApplicationStatus appStatus;\n     String appMessage \u003d null;\n     boolean success \u003d true;\n     if (numFailedContainers.get() \u003d\u003d 0 \u0026\u0026 \n         numCompletedContainers.get() \u003d\u003d numTotalContainers) {\n       appStatus \u003d FinalApplicationStatus.SUCCEEDED;\n     } else {\n       appStatus \u003d FinalApplicationStatus.FAILED;\n       appMessage \u003d \"Diagnostics.\" + \", total\u003d\" + numTotalContainers\n           + \", completed\u003d\" + numCompletedContainers.get() + \", allocated\u003d\"\n           + numAllocatedContainers.get() + \", failed\u003d\"\n           + numFailedContainers.get();\n       LOG.info(appMessage);\n       success \u003d false;\n     }\n     try {\n       amRMClient.unregisterApplicationMaster(appStatus, appMessage, null);\n     } catch (YarnException ex) {\n       LOG.error(\"Failed to unregister application\", ex);\n     } catch (IOException e) {\n       LOG.error(\"Failed to unregister application\", e);\n     }\n     \n     amRMClient.stop();\n \n+    // Stop Timeline Client\n+    if(timelineClient !\u003d null) {\n+      timelineClient.stop();\n+    }\n+\n     return success;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected boolean finish() {\n    // wait for completion.\n    while (!done\n        \u0026\u0026 (numCompletedContainers.get() !\u003d numTotalContainers)) {\n      try {\n        Thread.sleep(200);\n      } catch (InterruptedException ex) {}\n    }\n\n    // Join all launched threads\n    // needed for when we time out\n    // and we need to release containers\n    for (Thread launchThread : launchThreads) {\n      try {\n        launchThread.join(10000);\n      } catch (InterruptedException e) {\n        LOG.info(\"Exception thrown in thread join: \" + e.getMessage());\n        e.printStackTrace();\n      }\n    }\n\n    // When the application completes, it should stop all running containers\n    LOG.info(\"Application completed. Stopping running containers\");\n    nmClientAsync.stop();\n\n    // When the application completes, it should send a finish application\n    // signal to the RM\n    LOG.info(\"Application completed. Signalling finish to RM\");\n\n    FinalApplicationStatus appStatus;\n    String appMessage \u003d null;\n    boolean success \u003d true;\n    if (numFailedContainers.get() \u003d\u003d 0 \u0026\u0026 \n        numCompletedContainers.get() \u003d\u003d numTotalContainers) {\n      appStatus \u003d FinalApplicationStatus.SUCCEEDED;\n    } else {\n      appStatus \u003d FinalApplicationStatus.FAILED;\n      appMessage \u003d \"Diagnostics.\" + \", total\u003d\" + numTotalContainers\n          + \", completed\u003d\" + numCompletedContainers.get() + \", allocated\u003d\"\n          + numAllocatedContainers.get() + \", failed\u003d\"\n          + numFailedContainers.get();\n      LOG.info(appMessage);\n      success \u003d false;\n    }\n    try {\n      amRMClient.unregisterApplicationMaster(appStatus, appMessage, null);\n    } catch (YarnException ex) {\n      LOG.error(\"Failed to unregister application\", ex);\n    } catch (IOException e) {\n      LOG.error(\"Failed to unregister application\", e);\n    }\n    \n    amRMClient.stop();\n\n    // Stop Timeline Client\n    if(timelineClient !\u003d null) {\n      timelineClient.stop();\n    }\n\n    return success;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "52bbe0f11bc8e97df78a1ab9b63f4eff65fd7a76": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2630. Prevented previous AM container status from being acquired by the current restarted AM. Contributed by Jian He.\n",
      "commitDate": "01/10/14 3:38 PM",
      "commitName": "52bbe0f11bc8e97df78a1ab9b63f4eff65fd7a76",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "29/08/14 11:16 AM",
      "commitNameOld": "3de66011c2e80d7c458a67f80042af986fcc677d",
      "commitAuthorOld": "Hitesh Shah",
      "daysBetweenCommits": 33.18,
      "commitsBetweenForRepo": 373,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,55 +1,56 @@\n   protected boolean finish() {\n     // wait for completion.\n     while (!done\n         \u0026\u0026 (numCompletedContainers.get() !\u003d numTotalContainers)) {\n       try {\n         Thread.sleep(200);\n       } catch (InterruptedException ex) {}\n     }\n \n     // Join all launched threads\n     // needed for when we time out\n     // and we need to release containers\n     for (Thread launchThread : launchThreads) {\n       try {\n         launchThread.join(10000);\n       } catch (InterruptedException e) {\n         LOG.info(\"Exception thrown in thread join: \" + e.getMessage());\n         e.printStackTrace();\n       }\n     }\n \n     // When the application completes, it should stop all running containers\n     LOG.info(\"Application completed. Stopping running containers\");\n     nmClientAsync.stop();\n \n     // When the application completes, it should send a finish application\n     // signal to the RM\n     LOG.info(\"Application completed. Signalling finish to RM\");\n \n     FinalApplicationStatus appStatus;\n     String appMessage \u003d null;\n     boolean success \u003d true;\n     if (numFailedContainers.get() \u003d\u003d 0 \u0026\u0026 \n         numCompletedContainers.get() \u003d\u003d numTotalContainers) {\n       appStatus \u003d FinalApplicationStatus.SUCCEEDED;\n     } else {\n       appStatus \u003d FinalApplicationStatus.FAILED;\n       appMessage \u003d \"Diagnostics.\" + \", total\u003d\" + numTotalContainers\n           + \", completed\u003d\" + numCompletedContainers.get() + \", allocated\u003d\"\n           + numAllocatedContainers.get() + \", failed\u003d\"\n           + numFailedContainers.get();\n+      LOG.info(appMessage);\n       success \u003d false;\n     }\n     try {\n       amRMClient.unregisterApplicationMaster(appStatus, appMessage, null);\n     } catch (YarnException ex) {\n       LOG.error(\"Failed to unregister application\", ex);\n     } catch (IOException e) {\n       LOG.error(\"Failed to unregister application\", e);\n     }\n     \n     amRMClient.stop();\n \n     return success;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected boolean finish() {\n    // wait for completion.\n    while (!done\n        \u0026\u0026 (numCompletedContainers.get() !\u003d numTotalContainers)) {\n      try {\n        Thread.sleep(200);\n      } catch (InterruptedException ex) {}\n    }\n\n    // Join all launched threads\n    // needed for when we time out\n    // and we need to release containers\n    for (Thread launchThread : launchThreads) {\n      try {\n        launchThread.join(10000);\n      } catch (InterruptedException e) {\n        LOG.info(\"Exception thrown in thread join: \" + e.getMessage());\n        e.printStackTrace();\n      }\n    }\n\n    // When the application completes, it should stop all running containers\n    LOG.info(\"Application completed. Stopping running containers\");\n    nmClientAsync.stop();\n\n    // When the application completes, it should send a finish application\n    // signal to the RM\n    LOG.info(\"Application completed. Signalling finish to RM\");\n\n    FinalApplicationStatus appStatus;\n    String appMessage \u003d null;\n    boolean success \u003d true;\n    if (numFailedContainers.get() \u003d\u003d 0 \u0026\u0026 \n        numCompletedContainers.get() \u003d\u003d numTotalContainers) {\n      appStatus \u003d FinalApplicationStatus.SUCCEEDED;\n    } else {\n      appStatus \u003d FinalApplicationStatus.FAILED;\n      appMessage \u003d \"Diagnostics.\" + \", total\u003d\" + numTotalContainers\n          + \", completed\u003d\" + numCompletedContainers.get() + \", allocated\u003d\"\n          + numAllocatedContainers.get() + \", failed\u003d\"\n          + numFailedContainers.get();\n      LOG.info(appMessage);\n      success \u003d false;\n    }\n    try {\n      amRMClient.unregisterApplicationMaster(appStatus, appMessage, null);\n    } catch (YarnException ex) {\n      LOG.error(\"Failed to unregister application\", ex);\n    } catch (IOException e) {\n      LOG.error(\"Failed to unregister application\", e);\n    }\n    \n    amRMClient.stop();\n\n    return success;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "6182e7592d7255792ae6a04a5551296d755f6a37": {
      "type": "Ymultichange(Yreturntypechange,Ybodychange)",
      "commitMessage": "YARN-1661. Fixed DS ApplicationMaster to write the correct exit log. Contributed by Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1565394 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "06/02/14 10:56 AM",
      "commitName": "6182e7592d7255792ae6a04a5551296d755f6a37",
      "commitAuthor": "Zhijie Shen",
      "subchanges": [
        {
          "type": "Yreturntypechange",
          "commitMessage": "YARN-1661. Fixed DS ApplicationMaster to write the correct exit log. Contributed by Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1565394 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "06/02/14 10:56 AM",
          "commitName": "6182e7592d7255792ae6a04a5551296d755f6a37",
          "commitAuthor": "Zhijie Shen",
          "commitDateOld": "10/01/14 11:42 PM",
          "commitNameOld": "aa0c489a28dbbe8fae0be6a48edb122537784b1d",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 26.47,
          "commitsBetweenForRepo": 166,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,53 +1,55 @@\n-  protected void finish() {\n+  protected boolean finish() {\n     // wait for completion.\n     while (!done\n         \u0026\u0026 (numCompletedContainers.get() !\u003d numTotalContainers)) {\n       try {\n         Thread.sleep(200);\n       } catch (InterruptedException ex) {}\n     }\n \n     // Join all launched threads\n     // needed for when we time out\n     // and we need to release containers\n     for (Thread launchThread : launchThreads) {\n       try {\n         launchThread.join(10000);\n       } catch (InterruptedException e) {\n         LOG.info(\"Exception thrown in thread join: \" + e.getMessage());\n         e.printStackTrace();\n       }\n     }\n \n     // When the application completes, it should stop all running containers\n     LOG.info(\"Application completed. Stopping running containers\");\n     nmClientAsync.stop();\n \n     // When the application completes, it should send a finish application\n     // signal to the RM\n     LOG.info(\"Application completed. Signalling finish to RM\");\n \n     FinalApplicationStatus appStatus;\n     String appMessage \u003d null;\n-    success \u003d true;\n+    boolean success \u003d true;\n     if (numFailedContainers.get() \u003d\u003d 0 \u0026\u0026 \n         numCompletedContainers.get() \u003d\u003d numTotalContainers) {\n       appStatus \u003d FinalApplicationStatus.SUCCEEDED;\n     } else {\n       appStatus \u003d FinalApplicationStatus.FAILED;\n       appMessage \u003d \"Diagnostics.\" + \", total\u003d\" + numTotalContainers\n           + \", completed\u003d\" + numCompletedContainers.get() + \", allocated\u003d\"\n           + numAllocatedContainers.get() + \", failed\u003d\"\n           + numFailedContainers.get();\n       success \u003d false;\n     }\n     try {\n       amRMClient.unregisterApplicationMaster(appStatus, appMessage, null);\n     } catch (YarnException ex) {\n       LOG.error(\"Failed to unregister application\", ex);\n     } catch (IOException e) {\n       LOG.error(\"Failed to unregister application\", e);\n     }\n     \n     amRMClient.stop();\n+\n+    return success;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected boolean finish() {\n    // wait for completion.\n    while (!done\n        \u0026\u0026 (numCompletedContainers.get() !\u003d numTotalContainers)) {\n      try {\n        Thread.sleep(200);\n      } catch (InterruptedException ex) {}\n    }\n\n    // Join all launched threads\n    // needed for when we time out\n    // and we need to release containers\n    for (Thread launchThread : launchThreads) {\n      try {\n        launchThread.join(10000);\n      } catch (InterruptedException e) {\n        LOG.info(\"Exception thrown in thread join: \" + e.getMessage());\n        e.printStackTrace();\n      }\n    }\n\n    // When the application completes, it should stop all running containers\n    LOG.info(\"Application completed. Stopping running containers\");\n    nmClientAsync.stop();\n\n    // When the application completes, it should send a finish application\n    // signal to the RM\n    LOG.info(\"Application completed. Signalling finish to RM\");\n\n    FinalApplicationStatus appStatus;\n    String appMessage \u003d null;\n    boolean success \u003d true;\n    if (numFailedContainers.get() \u003d\u003d 0 \u0026\u0026 \n        numCompletedContainers.get() \u003d\u003d numTotalContainers) {\n      appStatus \u003d FinalApplicationStatus.SUCCEEDED;\n    } else {\n      appStatus \u003d FinalApplicationStatus.FAILED;\n      appMessage \u003d \"Diagnostics.\" + \", total\u003d\" + numTotalContainers\n          + \", completed\u003d\" + numCompletedContainers.get() + \", allocated\u003d\"\n          + numAllocatedContainers.get() + \", failed\u003d\"\n          + numFailedContainers.get();\n      success \u003d false;\n    }\n    try {\n      amRMClient.unregisterApplicationMaster(appStatus, appMessage, null);\n    } catch (YarnException ex) {\n      LOG.error(\"Failed to unregister application\", ex);\n    } catch (IOException e) {\n      LOG.error(\"Failed to unregister application\", e);\n    }\n    \n    amRMClient.stop();\n\n    return success;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
          "extendedDetails": {
            "oldValue": "void",
            "newValue": "boolean"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-1661. Fixed DS ApplicationMaster to write the correct exit log. Contributed by Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1565394 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "06/02/14 10:56 AM",
          "commitName": "6182e7592d7255792ae6a04a5551296d755f6a37",
          "commitAuthor": "Zhijie Shen",
          "commitDateOld": "10/01/14 11:42 PM",
          "commitNameOld": "aa0c489a28dbbe8fae0be6a48edb122537784b1d",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 26.47,
          "commitsBetweenForRepo": 166,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,53 +1,55 @@\n-  protected void finish() {\n+  protected boolean finish() {\n     // wait for completion.\n     while (!done\n         \u0026\u0026 (numCompletedContainers.get() !\u003d numTotalContainers)) {\n       try {\n         Thread.sleep(200);\n       } catch (InterruptedException ex) {}\n     }\n \n     // Join all launched threads\n     // needed for when we time out\n     // and we need to release containers\n     for (Thread launchThread : launchThreads) {\n       try {\n         launchThread.join(10000);\n       } catch (InterruptedException e) {\n         LOG.info(\"Exception thrown in thread join: \" + e.getMessage());\n         e.printStackTrace();\n       }\n     }\n \n     // When the application completes, it should stop all running containers\n     LOG.info(\"Application completed. Stopping running containers\");\n     nmClientAsync.stop();\n \n     // When the application completes, it should send a finish application\n     // signal to the RM\n     LOG.info(\"Application completed. Signalling finish to RM\");\n \n     FinalApplicationStatus appStatus;\n     String appMessage \u003d null;\n-    success \u003d true;\n+    boolean success \u003d true;\n     if (numFailedContainers.get() \u003d\u003d 0 \u0026\u0026 \n         numCompletedContainers.get() \u003d\u003d numTotalContainers) {\n       appStatus \u003d FinalApplicationStatus.SUCCEEDED;\n     } else {\n       appStatus \u003d FinalApplicationStatus.FAILED;\n       appMessage \u003d \"Diagnostics.\" + \", total\u003d\" + numTotalContainers\n           + \", completed\u003d\" + numCompletedContainers.get() + \", allocated\u003d\"\n           + numAllocatedContainers.get() + \", failed\u003d\"\n           + numFailedContainers.get();\n       success \u003d false;\n     }\n     try {\n       amRMClient.unregisterApplicationMaster(appStatus, appMessage, null);\n     } catch (YarnException ex) {\n       LOG.error(\"Failed to unregister application\", ex);\n     } catch (IOException e) {\n       LOG.error(\"Failed to unregister application\", e);\n     }\n     \n     amRMClient.stop();\n+\n+    return success;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected boolean finish() {\n    // wait for completion.\n    while (!done\n        \u0026\u0026 (numCompletedContainers.get() !\u003d numTotalContainers)) {\n      try {\n        Thread.sleep(200);\n      } catch (InterruptedException ex) {}\n    }\n\n    // Join all launched threads\n    // needed for when we time out\n    // and we need to release containers\n    for (Thread launchThread : launchThreads) {\n      try {\n        launchThread.join(10000);\n      } catch (InterruptedException e) {\n        LOG.info(\"Exception thrown in thread join: \" + e.getMessage());\n        e.printStackTrace();\n      }\n    }\n\n    // When the application completes, it should stop all running containers\n    LOG.info(\"Application completed. Stopping running containers\");\n    nmClientAsync.stop();\n\n    // When the application completes, it should send a finish application\n    // signal to the RM\n    LOG.info(\"Application completed. Signalling finish to RM\");\n\n    FinalApplicationStatus appStatus;\n    String appMessage \u003d null;\n    boolean success \u003d true;\n    if (numFailedContainers.get() \u003d\u003d 0 \u0026\u0026 \n        numCompletedContainers.get() \u003d\u003d numTotalContainers) {\n      appStatus \u003d FinalApplicationStatus.SUCCEEDED;\n    } else {\n      appStatus \u003d FinalApplicationStatus.FAILED;\n      appMessage \u003d \"Diagnostics.\" + \", total\u003d\" + numTotalContainers\n          + \", completed\u003d\" + numCompletedContainers.get() + \", allocated\u003d\"\n          + numAllocatedContainers.get() + \", failed\u003d\"\n          + numFailedContainers.get();\n      success \u003d false;\n    }\n    try {\n      amRMClient.unregisterApplicationMaster(appStatus, appMessage, null);\n    } catch (YarnException ex) {\n      LOG.error(\"Failed to unregister application\", ex);\n    } catch (IOException e) {\n      LOG.error(\"Failed to unregister application\", e);\n    }\n    \n    amRMClient.stop();\n\n    return success;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
          "extendedDetails": {}
        }
      ]
    },
    "aa0c489a28dbbe8fae0be6a48edb122537784b1d": {
      "type": "Ymultichange(Ymodifierchange,Ybodychange)",
      "commitMessage": "YARN-1566. Changed Distributed Shell to retain containers across application attempts. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1557322 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/01/14 11:42 PM",
      "commitName": "aa0c489a28dbbe8fae0be6a48edb122537784b1d",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "subchanges": [
        {
          "type": "Ymodifierchange",
          "commitMessage": "YARN-1566. Changed Distributed Shell to retain containers across application attempts. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1557322 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "10/01/14 11:42 PM",
          "commitName": "aa0c489a28dbbe8fae0be6a48edb122537784b1d",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "13/12/13 6:00 PM",
          "commitNameOld": "d63cfdbf1a5389acb27e8cd61f4c14d8eaedb26f",
          "commitAuthorOld": "Zhijie Shen",
          "daysBetweenCommits": 28.24,
          "commitsBetweenForRepo": 121,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,45 +1,53 @@\n-  private void finish() {\n+  protected void finish() {\n+    // wait for completion.\n+    while (!done\n+        \u0026\u0026 (numCompletedContainers.get() !\u003d numTotalContainers)) {\n+      try {\n+        Thread.sleep(200);\n+      } catch (InterruptedException ex) {}\n+    }\n+\n     // Join all launched threads\n     // needed for when we time out\n     // and we need to release containers\n     for (Thread launchThread : launchThreads) {\n       try {\n         launchThread.join(10000);\n       } catch (InterruptedException e) {\n         LOG.info(\"Exception thrown in thread join: \" + e.getMessage());\n         e.printStackTrace();\n       }\n     }\n \n     // When the application completes, it should stop all running containers\n     LOG.info(\"Application completed. Stopping running containers\");\n     nmClientAsync.stop();\n \n     // When the application completes, it should send a finish application\n     // signal to the RM\n     LOG.info(\"Application completed. Signalling finish to RM\");\n \n     FinalApplicationStatus appStatus;\n     String appMessage \u003d null;\n     success \u003d true;\n     if (numFailedContainers.get() \u003d\u003d 0 \u0026\u0026 \n         numCompletedContainers.get() \u003d\u003d numTotalContainers) {\n       appStatus \u003d FinalApplicationStatus.SUCCEEDED;\n     } else {\n       appStatus \u003d FinalApplicationStatus.FAILED;\n       appMessage \u003d \"Diagnostics.\" + \", total\u003d\" + numTotalContainers\n           + \", completed\u003d\" + numCompletedContainers.get() + \", allocated\u003d\"\n           + numAllocatedContainers.get() + \", failed\u003d\"\n           + numFailedContainers.get();\n       success \u003d false;\n     }\n     try {\n       amRMClient.unregisterApplicationMaster(appStatus, appMessage, null);\n     } catch (YarnException ex) {\n       LOG.error(\"Failed to unregister application\", ex);\n     } catch (IOException e) {\n       LOG.error(\"Failed to unregister application\", e);\n     }\n     \n     amRMClient.stop();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected void finish() {\n    // wait for completion.\n    while (!done\n        \u0026\u0026 (numCompletedContainers.get() !\u003d numTotalContainers)) {\n      try {\n        Thread.sleep(200);\n      } catch (InterruptedException ex) {}\n    }\n\n    // Join all launched threads\n    // needed for when we time out\n    // and we need to release containers\n    for (Thread launchThread : launchThreads) {\n      try {\n        launchThread.join(10000);\n      } catch (InterruptedException e) {\n        LOG.info(\"Exception thrown in thread join: \" + e.getMessage());\n        e.printStackTrace();\n      }\n    }\n\n    // When the application completes, it should stop all running containers\n    LOG.info(\"Application completed. Stopping running containers\");\n    nmClientAsync.stop();\n\n    // When the application completes, it should send a finish application\n    // signal to the RM\n    LOG.info(\"Application completed. Signalling finish to RM\");\n\n    FinalApplicationStatus appStatus;\n    String appMessage \u003d null;\n    success \u003d true;\n    if (numFailedContainers.get() \u003d\u003d 0 \u0026\u0026 \n        numCompletedContainers.get() \u003d\u003d numTotalContainers) {\n      appStatus \u003d FinalApplicationStatus.SUCCEEDED;\n    } else {\n      appStatus \u003d FinalApplicationStatus.FAILED;\n      appMessage \u003d \"Diagnostics.\" + \", total\u003d\" + numTotalContainers\n          + \", completed\u003d\" + numCompletedContainers.get() + \", allocated\u003d\"\n          + numAllocatedContainers.get() + \", failed\u003d\"\n          + numFailedContainers.get();\n      success \u003d false;\n    }\n    try {\n      amRMClient.unregisterApplicationMaster(appStatus, appMessage, null);\n    } catch (YarnException ex) {\n      LOG.error(\"Failed to unregister application\", ex);\n    } catch (IOException e) {\n      LOG.error(\"Failed to unregister application\", e);\n    }\n    \n    amRMClient.stop();\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
          "extendedDetails": {
            "oldValue": "[private]",
            "newValue": "[protected]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-1566. Changed Distributed Shell to retain containers across application attempts. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1557322 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "10/01/14 11:42 PM",
          "commitName": "aa0c489a28dbbe8fae0be6a48edb122537784b1d",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "13/12/13 6:00 PM",
          "commitNameOld": "d63cfdbf1a5389acb27e8cd61f4c14d8eaedb26f",
          "commitAuthorOld": "Zhijie Shen",
          "daysBetweenCommits": 28.24,
          "commitsBetweenForRepo": 121,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,45 +1,53 @@\n-  private void finish() {\n+  protected void finish() {\n+    // wait for completion.\n+    while (!done\n+        \u0026\u0026 (numCompletedContainers.get() !\u003d numTotalContainers)) {\n+      try {\n+        Thread.sleep(200);\n+      } catch (InterruptedException ex) {}\n+    }\n+\n     // Join all launched threads\n     // needed for when we time out\n     // and we need to release containers\n     for (Thread launchThread : launchThreads) {\n       try {\n         launchThread.join(10000);\n       } catch (InterruptedException e) {\n         LOG.info(\"Exception thrown in thread join: \" + e.getMessage());\n         e.printStackTrace();\n       }\n     }\n \n     // When the application completes, it should stop all running containers\n     LOG.info(\"Application completed. Stopping running containers\");\n     nmClientAsync.stop();\n \n     // When the application completes, it should send a finish application\n     // signal to the RM\n     LOG.info(\"Application completed. Signalling finish to RM\");\n \n     FinalApplicationStatus appStatus;\n     String appMessage \u003d null;\n     success \u003d true;\n     if (numFailedContainers.get() \u003d\u003d 0 \u0026\u0026 \n         numCompletedContainers.get() \u003d\u003d numTotalContainers) {\n       appStatus \u003d FinalApplicationStatus.SUCCEEDED;\n     } else {\n       appStatus \u003d FinalApplicationStatus.FAILED;\n       appMessage \u003d \"Diagnostics.\" + \", total\u003d\" + numTotalContainers\n           + \", completed\u003d\" + numCompletedContainers.get() + \", allocated\u003d\"\n           + numAllocatedContainers.get() + \", failed\u003d\"\n           + numFailedContainers.get();\n       success \u003d false;\n     }\n     try {\n       amRMClient.unregisterApplicationMaster(appStatus, appMessage, null);\n     } catch (YarnException ex) {\n       LOG.error(\"Failed to unregister application\", ex);\n     } catch (IOException e) {\n       LOG.error(\"Failed to unregister application\", e);\n     }\n     \n     amRMClient.stop();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected void finish() {\n    // wait for completion.\n    while (!done\n        \u0026\u0026 (numCompletedContainers.get() !\u003d numTotalContainers)) {\n      try {\n        Thread.sleep(200);\n      } catch (InterruptedException ex) {}\n    }\n\n    // Join all launched threads\n    // needed for when we time out\n    // and we need to release containers\n    for (Thread launchThread : launchThreads) {\n      try {\n        launchThread.join(10000);\n      } catch (InterruptedException e) {\n        LOG.info(\"Exception thrown in thread join: \" + e.getMessage());\n        e.printStackTrace();\n      }\n    }\n\n    // When the application completes, it should stop all running containers\n    LOG.info(\"Application completed. Stopping running containers\");\n    nmClientAsync.stop();\n\n    // When the application completes, it should send a finish application\n    // signal to the RM\n    LOG.info(\"Application completed. Signalling finish to RM\");\n\n    FinalApplicationStatus appStatus;\n    String appMessage \u003d null;\n    success \u003d true;\n    if (numFailedContainers.get() \u003d\u003d 0 \u0026\u0026 \n        numCompletedContainers.get() \u003d\u003d numTotalContainers) {\n      appStatus \u003d FinalApplicationStatus.SUCCEEDED;\n    } else {\n      appStatus \u003d FinalApplicationStatus.FAILED;\n      appMessage \u003d \"Diagnostics.\" + \", total\u003d\" + numTotalContainers\n          + \", completed\u003d\" + numCompletedContainers.get() + \", allocated\u003d\"\n          + numAllocatedContainers.get() + \", failed\u003d\"\n          + numFailedContainers.get();\n      success \u003d false;\n    }\n    try {\n      amRMClient.unregisterApplicationMaster(appStatus, appMessage, null);\n    } catch (YarnException ex) {\n      LOG.error(\"Failed to unregister application\", ex);\n    } catch (IOException e) {\n      LOG.error(\"Failed to unregister application\", e);\n    }\n    \n    amRMClient.stop();\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
          "extendedDetails": {}
        }
      ]
    },
    "be3edccf0acf55e710b0ec8ab8ce8418da74c615": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1273. Fixed Distributed-shell to account for containers that failed to start. Contributed by Hitesh Shah.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1529389 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/10/13 11:08 PM",
      "commitName": "be3edccf0acf55e710b0ec8ab8ce8418da74c615",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "04/10/13 6:43 PM",
      "commitNameOld": "fc23fd312174f36508eb40f3084e262e23a68e1b",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 0.18,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,45 @@\n   private void finish() {\n     // Join all launched threads\n     // needed for when we time out\n     // and we need to release containers\n     for (Thread launchThread : launchThreads) {\n       try {\n         launchThread.join(10000);\n       } catch (InterruptedException e) {\n         LOG.info(\"Exception thrown in thread join: \" + e.getMessage());\n         e.printStackTrace();\n       }\n     }\n \n     // When the application completes, it should stop all running containers\n     LOG.info(\"Application completed. Stopping running containers\");\n     nmClientAsync.stop();\n \n     // When the application completes, it should send a finish application\n     // signal to the RM\n     LOG.info(\"Application completed. Signalling finish to RM\");\n \n     FinalApplicationStatus appStatus;\n     String appMessage \u003d null;\n     success \u003d true;\n     if (numFailedContainers.get() \u003d\u003d 0 \u0026\u0026 \n         numCompletedContainers.get() \u003d\u003d numTotalContainers) {\n       appStatus \u003d FinalApplicationStatus.SUCCEEDED;\n     } else {\n       appStatus \u003d FinalApplicationStatus.FAILED;\n       appMessage \u003d \"Diagnostics.\" + \", total\u003d\" + numTotalContainers\n           + \", completed\u003d\" + numCompletedContainers.get() + \", allocated\u003d\"\n           + numAllocatedContainers.get() + \", failed\u003d\"\n           + numFailedContainers.get();\n       success \u003d false;\n     }\n     try {\n       amRMClient.unregisterApplicationMaster(appStatus, appMessage, null);\n     } catch (YarnException ex) {\n       LOG.error(\"Failed to unregister application\", ex);\n     } catch (IOException e) {\n       LOG.error(\"Failed to unregister application\", e);\n     }\n     \n-    done \u003d true;\n     amRMClient.stop();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void finish() {\n    // Join all launched threads\n    // needed for when we time out\n    // and we need to release containers\n    for (Thread launchThread : launchThreads) {\n      try {\n        launchThread.join(10000);\n      } catch (InterruptedException e) {\n        LOG.info(\"Exception thrown in thread join: \" + e.getMessage());\n        e.printStackTrace();\n      }\n    }\n\n    // When the application completes, it should stop all running containers\n    LOG.info(\"Application completed. Stopping running containers\");\n    nmClientAsync.stop();\n\n    // When the application completes, it should send a finish application\n    // signal to the RM\n    LOG.info(\"Application completed. Signalling finish to RM\");\n\n    FinalApplicationStatus appStatus;\n    String appMessage \u003d null;\n    success \u003d true;\n    if (numFailedContainers.get() \u003d\u003d 0 \u0026\u0026 \n        numCompletedContainers.get() \u003d\u003d numTotalContainers) {\n      appStatus \u003d FinalApplicationStatus.SUCCEEDED;\n    } else {\n      appStatus \u003d FinalApplicationStatus.FAILED;\n      appMessage \u003d \"Diagnostics.\" + \", total\u003d\" + numTotalContainers\n          + \", completed\u003d\" + numCompletedContainers.get() + \", allocated\u003d\"\n          + numAllocatedContainers.get() + \", failed\u003d\"\n          + numFailedContainers.get();\n      success \u003d false;\n    }\n    try {\n      amRMClient.unregisterApplicationMaster(appStatus, appMessage, null);\n    } catch (YarnException ex) {\n      LOG.error(\"Failed to unregister application\", ex);\n    } catch (IOException e) {\n      LOG.error(\"Failed to unregister application\", e);\n    }\n    \n    amRMClient.stop();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "42c3cd3d137ba1de1c0573c0bb655fa380ed9412": {
      "type": "Ybodychange",
      "commitMessage": "YARN-49. Improve distributed shell application to work on a secure cluster. Contributed by Vinod Kumar Vavilapalli.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1526330 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/09/13 4:39 PM",
      "commitName": "42c3cd3d137ba1de1c0573c0bb655fa380ed9412",
      "commitAuthor": "Hitesh Shah",
      "commitDateOld": "24/07/13 3:13 PM",
      "commitNameOld": "9c453d4432a6ce75afab2087017781e614cc320f",
      "commitAuthorOld": "Bikas Saha",
      "daysBetweenCommits": 63.06,
      "commitsBetweenForRepo": 352,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,46 @@\n   private void finish() {\n     // Join all launched threads\n     // needed for when we time out\n     // and we need to release containers\n     for (Thread launchThread : launchThreads) {\n       try {\n         launchThread.join(10000);\n       } catch (InterruptedException e) {\n         LOG.info(\"Exception thrown in thread join: \" + e.getMessage());\n         e.printStackTrace();\n       }\n     }\n \n     // When the application completes, it should stop all running containers\n     LOG.info(\"Application completed. Stopping running containers\");\n     nmClientAsync.stop();\n \n     // When the application completes, it should send a finish application\n     // signal to the RM\n     LOG.info(\"Application completed. Signalling finish to RM\");\n \n     FinalApplicationStatus appStatus;\n     String appMessage \u003d null;\n     success \u003d true;\n     if (numFailedContainers.get() \u003d\u003d 0 \u0026\u0026 \n         numCompletedContainers.get() \u003d\u003d numTotalContainers) {\n       appStatus \u003d FinalApplicationStatus.SUCCEEDED;\n     } else {\n       appStatus \u003d FinalApplicationStatus.FAILED;\n       appMessage \u003d \"Diagnostics.\" + \", total\u003d\" + numTotalContainers\n           + \", completed\u003d\" + numCompletedContainers.get() + \", allocated\u003d\"\n           + numAllocatedContainers.get() + \", failed\u003d\"\n           + numFailedContainers.get();\n       success \u003d false;\n     }\n     try {\n-      resourceManager.unregisterApplicationMaster(appStatus, appMessage, null);\n+      amRMClient.unregisterApplicationMaster(appStatus, appMessage, null);\n     } catch (YarnException ex) {\n       LOG.error(\"Failed to unregister application\", ex);\n     } catch (IOException e) {\n       LOG.error(\"Failed to unregister application\", e);\n     }\n     \n     done \u003d true;\n-    resourceManager.stop();\n+    amRMClient.stop();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void finish() {\n    // Join all launched threads\n    // needed for when we time out\n    // and we need to release containers\n    for (Thread launchThread : launchThreads) {\n      try {\n        launchThread.join(10000);\n      } catch (InterruptedException e) {\n        LOG.info(\"Exception thrown in thread join: \" + e.getMessage());\n        e.printStackTrace();\n      }\n    }\n\n    // When the application completes, it should stop all running containers\n    LOG.info(\"Application completed. Stopping running containers\");\n    nmClientAsync.stop();\n\n    // When the application completes, it should send a finish application\n    // signal to the RM\n    LOG.info(\"Application completed. Signalling finish to RM\");\n\n    FinalApplicationStatus appStatus;\n    String appMessage \u003d null;\n    success \u003d true;\n    if (numFailedContainers.get() \u003d\u003d 0 \u0026\u0026 \n        numCompletedContainers.get() \u003d\u003d numTotalContainers) {\n      appStatus \u003d FinalApplicationStatus.SUCCEEDED;\n    } else {\n      appStatus \u003d FinalApplicationStatus.FAILED;\n      appMessage \u003d \"Diagnostics.\" + \", total\u003d\" + numTotalContainers\n          + \", completed\u003d\" + numCompletedContainers.get() + \", allocated\u003d\"\n          + numAllocatedContainers.get() + \", failed\u003d\"\n          + numFailedContainers.get();\n      success \u003d false;\n    }\n    try {\n      amRMClient.unregisterApplicationMaster(appStatus, appMessage, null);\n    } catch (YarnException ex) {\n      LOG.error(\"Failed to unregister application\", ex);\n    } catch (IOException e) {\n      LOG.error(\"Failed to unregister application\", e);\n    }\n    \n    done \u003d true;\n    amRMClient.stop();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "b503b6a07d7210c94657131dcd97239012ecb313": {
      "type": "Ybodychange",
      "commitMessage": "YARN-639. Modified Distributed Shell application to start using the new NMClient library. Contributed by Zhijie Shen.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1493280 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/06/13 4:18 PM",
      "commitName": "b503b6a07d7210c94657131dcd97239012ecb313",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "14/06/13 9:10 AM",
      "commitNameOld": "fdc9412a810564c79fbebf5eb730cb1018a95c6c",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 0.3,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,46 @@\n   private void finish() {\n     // Join all launched threads\n     // needed for when we time out\n     // and we need to release containers\n     for (Thread launchThread : launchThreads) {\n       try {\n         launchThread.join(10000);\n       } catch (InterruptedException e) {\n         LOG.info(\"Exception thrown in thread join: \" + e.getMessage());\n         e.printStackTrace();\n       }\n     }\n \n+    // When the application completes, it should stop all running containers\n+    LOG.info(\"Application completed. Stopping running containers\");\n+    nmClientAsync.stop();\n+\n     // When the application completes, it should send a finish application\n     // signal to the RM\n     LOG.info(\"Application completed. Signalling finish to RM\");\n \n     FinalApplicationStatus appStatus;\n     String appMessage \u003d null;\n     success \u003d true;\n     if (numFailedContainers.get() \u003d\u003d 0 \u0026\u0026 \n         numCompletedContainers.get() \u003d\u003d numTotalContainers) {\n       appStatus \u003d FinalApplicationStatus.SUCCEEDED;\n     } else {\n       appStatus \u003d FinalApplicationStatus.FAILED;\n       appMessage \u003d \"Diagnostics.\" + \", total\u003d\" + numTotalContainers\n           + \", completed\u003d\" + numCompletedContainers.get() + \", allocated\u003d\"\n           + numAllocatedContainers.get() + \", failed\u003d\"\n           + numFailedContainers.get();\n       success \u003d false;\n     }\n     try {\n       resourceManager.unregisterApplicationMaster(appStatus, appMessage, null);\n     } catch (YarnException ex) {\n       LOG.error(\"Failed to unregister application\", ex);\n     } catch (IOException e) {\n       LOG.error(\"Failed to unregister application\", e);\n     }\n     \n     done \u003d true;\n     resourceManager.stop();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void finish() {\n    // Join all launched threads\n    // needed for when we time out\n    // and we need to release containers\n    for (Thread launchThread : launchThreads) {\n      try {\n        launchThread.join(10000);\n      } catch (InterruptedException e) {\n        LOG.info(\"Exception thrown in thread join: \" + e.getMessage());\n        e.printStackTrace();\n      }\n    }\n\n    // When the application completes, it should stop all running containers\n    LOG.info(\"Application completed. Stopping running containers\");\n    nmClientAsync.stop();\n\n    // When the application completes, it should send a finish application\n    // signal to the RM\n    LOG.info(\"Application completed. Signalling finish to RM\");\n\n    FinalApplicationStatus appStatus;\n    String appMessage \u003d null;\n    success \u003d true;\n    if (numFailedContainers.get() \u003d\u003d 0 \u0026\u0026 \n        numCompletedContainers.get() \u003d\u003d numTotalContainers) {\n      appStatus \u003d FinalApplicationStatus.SUCCEEDED;\n    } else {\n      appStatus \u003d FinalApplicationStatus.FAILED;\n      appMessage \u003d \"Diagnostics.\" + \", total\u003d\" + numTotalContainers\n          + \", completed\u003d\" + numCompletedContainers.get() + \", allocated\u003d\"\n          + numAllocatedContainers.get() + \", failed\u003d\"\n          + numFailedContainers.get();\n      success \u003d false;\n    }\n    try {\n      resourceManager.unregisterApplicationMaster(appStatus, appMessage, null);\n    } catch (YarnException ex) {\n      LOG.error(\"Failed to unregister application\", ex);\n    } catch (IOException e) {\n      LOG.error(\"Failed to unregister application\", e);\n    }\n    \n    done \u003d true;\n    resourceManager.stop();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "a83fb61ac07c0468cbc7a38526e92683883dd932": {
      "type": "Ybodychange",
      "commitMessage": "YARN-635. Renamed YarnRemoteException to YarnException. Contributed by Siddharth Seth.\nMAPREDUCE-5301. Updated MR code to work with YARN-635 changes of renaming YarnRemoteException to YarnException. Contributed by Siddharth Seth\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1489283 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/06/13 9:05 PM",
      "commitName": "a83fb61ac07c0468cbc7a38526e92683883dd932",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "01/06/13 1:23 AM",
      "commitNameOld": "3492f5eff1a22aba0d09d72a9dfd3353525c072e",
      "commitAuthorOld": "Bikas Saha",
      "daysBetweenCommits": 2.82,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,42 @@\n   private void finish() {\n     // Join all launched threads\n     // needed for when we time out\n     // and we need to release containers\n     for (Thread launchThread : launchThreads) {\n       try {\n         launchThread.join(10000);\n       } catch (InterruptedException e) {\n         LOG.info(\"Exception thrown in thread join: \" + e.getMessage());\n         e.printStackTrace();\n       }\n     }\n \n     // When the application completes, it should send a finish application\n     // signal to the RM\n     LOG.info(\"Application completed. Signalling finish to RM\");\n \n     FinalApplicationStatus appStatus;\n     String appMessage \u003d null;\n     success \u003d true;\n     if (numFailedContainers.get() \u003d\u003d 0 \u0026\u0026 \n         numCompletedContainers.get() \u003d\u003d numTotalContainers) {\n       appStatus \u003d FinalApplicationStatus.SUCCEEDED;\n     } else {\n       appStatus \u003d FinalApplicationStatus.FAILED;\n       appMessage \u003d \"Diagnostics.\" + \", total\u003d\" + numTotalContainers\n           + \", completed\u003d\" + numCompletedContainers.get() + \", allocated\u003d\"\n           + numAllocatedContainers.get() + \", failed\u003d\"\n           + numFailedContainers.get();\n       success \u003d false;\n     }\n     try {\n       resourceManager.unregisterApplicationMaster(appStatus, appMessage, null);\n-    } catch (YarnRemoteException ex) {\n+    } catch (YarnException ex) {\n       LOG.error(\"Failed to unregister application\", ex);\n     } catch (IOException e) {\n       LOG.error(\"Failed to unregister application\", e);\n     }\n     \n     done \u003d true;\n     resourceManager.stop();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void finish() {\n    // Join all launched threads\n    // needed for when we time out\n    // and we need to release containers\n    for (Thread launchThread : launchThreads) {\n      try {\n        launchThread.join(10000);\n      } catch (InterruptedException e) {\n        LOG.info(\"Exception thrown in thread join: \" + e.getMessage());\n        e.printStackTrace();\n      }\n    }\n\n    // When the application completes, it should send a finish application\n    // signal to the RM\n    LOG.info(\"Application completed. Signalling finish to RM\");\n\n    FinalApplicationStatus appStatus;\n    String appMessage \u003d null;\n    success \u003d true;\n    if (numFailedContainers.get() \u003d\u003d 0 \u0026\u0026 \n        numCompletedContainers.get() \u003d\u003d numTotalContainers) {\n      appStatus \u003d FinalApplicationStatus.SUCCEEDED;\n    } else {\n      appStatus \u003d FinalApplicationStatus.FAILED;\n      appMessage \u003d \"Diagnostics.\" + \", total\u003d\" + numTotalContainers\n          + \", completed\u003d\" + numCompletedContainers.get() + \", allocated\u003d\"\n          + numAllocatedContainers.get() + \", failed\u003d\"\n          + numFailedContainers.get();\n      success \u003d false;\n    }\n    try {\n      resourceManager.unregisterApplicationMaster(appStatus, appMessage, null);\n    } catch (YarnException ex) {\n      LOG.error(\"Failed to unregister application\", ex);\n    } catch (IOException e) {\n      LOG.error(\"Failed to unregister application\", e);\n    }\n    \n    done \u003d true;\n    resourceManager.stop();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "3492f5eff1a22aba0d09d72a9dfd3353525c072e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-660. Improve AMRMClient with matching requests (bikas)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1488485 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "01/06/13 1:23 AM",
      "commitName": "3492f5eff1a22aba0d09d72a9dfd3353525c072e",
      "commitAuthor": "Bikas Saha",
      "commitDateOld": "30/05/13 9:13 PM",
      "commitNameOld": "2692675fc3b5046d2ec88542c30203c87e135b70",
      "commitAuthorOld": "Siddharth Seth",
      "daysBetweenCommits": 1.17,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,42 @@\n   private void finish() {\n     // Join all launched threads\n     // needed for when we time out\n     // and we need to release containers\n     for (Thread launchThread : launchThreads) {\n       try {\n         launchThread.join(10000);\n       } catch (InterruptedException e) {\n         LOG.info(\"Exception thrown in thread join: \" + e.getMessage());\n         e.printStackTrace();\n       }\n     }\n \n     // When the application completes, it should send a finish application\n     // signal to the RM\n     LOG.info(\"Application completed. Signalling finish to RM\");\n \n     FinalApplicationStatus appStatus;\n     String appMessage \u003d null;\n     success \u003d true;\n-    if (numFailedContainers.get() \u003d\u003d 0) {\n+    if (numFailedContainers.get() \u003d\u003d 0 \u0026\u0026 \n+        numCompletedContainers.get() \u003d\u003d numTotalContainers) {\n       appStatus \u003d FinalApplicationStatus.SUCCEEDED;\n     } else {\n       appStatus \u003d FinalApplicationStatus.FAILED;\n       appMessage \u003d \"Diagnostics.\" + \", total\u003d\" + numTotalContainers\n           + \", completed\u003d\" + numCompletedContainers.get() + \", allocated\u003d\"\n           + numAllocatedContainers.get() + \", failed\u003d\"\n           + numFailedContainers.get();\n       success \u003d false;\n     }\n     try {\n       resourceManager.unregisterApplicationMaster(appStatus, appMessage, null);\n     } catch (YarnRemoteException ex) {\n       LOG.error(\"Failed to unregister application\", ex);\n     } catch (IOException e) {\n       LOG.error(\"Failed to unregister application\", e);\n     }\n     \n     done \u003d true;\n     resourceManager.stop();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void finish() {\n    // Join all launched threads\n    // needed for when we time out\n    // and we need to release containers\n    for (Thread launchThread : launchThreads) {\n      try {\n        launchThread.join(10000);\n      } catch (InterruptedException e) {\n        LOG.info(\"Exception thrown in thread join: \" + e.getMessage());\n        e.printStackTrace();\n      }\n    }\n\n    // When the application completes, it should send a finish application\n    // signal to the RM\n    LOG.info(\"Application completed. Signalling finish to RM\");\n\n    FinalApplicationStatus appStatus;\n    String appMessage \u003d null;\n    success \u003d true;\n    if (numFailedContainers.get() \u003d\u003d 0 \u0026\u0026 \n        numCompletedContainers.get() \u003d\u003d numTotalContainers) {\n      appStatus \u003d FinalApplicationStatus.SUCCEEDED;\n    } else {\n      appStatus \u003d FinalApplicationStatus.FAILED;\n      appMessage \u003d \"Diagnostics.\" + \", total\u003d\" + numTotalContainers\n          + \", completed\u003d\" + numCompletedContainers.get() + \", allocated\u003d\"\n          + numAllocatedContainers.get() + \", failed\u003d\"\n          + numFailedContainers.get();\n      success \u003d false;\n    }\n    try {\n      resourceManager.unregisterApplicationMaster(appStatus, appMessage, null);\n    } catch (YarnRemoteException ex) {\n      LOG.error(\"Failed to unregister application\", ex);\n    } catch (IOException e) {\n      LOG.error(\"Failed to unregister application\", e);\n    }\n    \n    done \u003d true;\n    resourceManager.stop();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "9c4f86879cad6d6e19255d4ae8f28b61328bd10b": {
      "type": "Ybodychange",
      "commitMessage": "YARN-630. Changed AMRMProtocol api to throw IOException and YarnRemoteException. Contributed by Xuan Gong.\nMAPREDUCE-5226. Handling YarnRemoteException separately from IOException in MR App\u0027s use of AMRMProtocol after YARN-630. Contributed by Xuan Gong.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1480529 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/05/13 10:32 PM",
      "commitName": "9c4f86879cad6d6e19255d4ae8f28b61328bd10b",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "06/05/13 5:42 PM",
      "commitNameOld": "9eb53b9c841233538a51e4e854b261536c0b85d4",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 2.2,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,39 +1,41 @@\n   private void finish() {\n     // Join all launched threads\n     // needed for when we time out\n     // and we need to release containers\n     for (Thread launchThread : launchThreads) {\n       try {\n         launchThread.join(10000);\n       } catch (InterruptedException e) {\n         LOG.info(\"Exception thrown in thread join: \" + e.getMessage());\n         e.printStackTrace();\n       }\n     }\n \n     // When the application completes, it should send a finish application\n     // signal to the RM\n     LOG.info(\"Application completed. Signalling finish to RM\");\n \n     FinalApplicationStatus appStatus;\n     String appMessage \u003d null;\n     success \u003d true;\n     if (numFailedContainers.get() \u003d\u003d 0) {\n       appStatus \u003d FinalApplicationStatus.SUCCEEDED;\n     } else {\n       appStatus \u003d FinalApplicationStatus.FAILED;\n       appMessage \u003d \"Diagnostics.\" + \", total\u003d\" + numTotalContainers\n           + \", completed\u003d\" + numCompletedContainers.get() + \", allocated\u003d\"\n           + numAllocatedContainers.get() + \", failed\u003d\"\n           + numFailedContainers.get();\n       success \u003d false;\n     }\n     try {\n       resourceManager.unregisterApplicationMaster(appStatus, appMessage, null);\n     } catch (YarnRemoteException ex) {\n       LOG.error(\"Failed to unregister application\", ex);\n+    } catch (IOException e) {\n+      LOG.error(\"Failed to unregister application\", e);\n     }\n     \n     done \u003d true;\n     resourceManager.stop();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void finish() {\n    // Join all launched threads\n    // needed for when we time out\n    // and we need to release containers\n    for (Thread launchThread : launchThreads) {\n      try {\n        launchThread.join(10000);\n      } catch (InterruptedException e) {\n        LOG.info(\"Exception thrown in thread join: \" + e.getMessage());\n        e.printStackTrace();\n      }\n    }\n\n    // When the application completes, it should send a finish application\n    // signal to the RM\n    LOG.info(\"Application completed. Signalling finish to RM\");\n\n    FinalApplicationStatus appStatus;\n    String appMessage \u003d null;\n    success \u003d true;\n    if (numFailedContainers.get() \u003d\u003d 0) {\n      appStatus \u003d FinalApplicationStatus.SUCCEEDED;\n    } else {\n      appStatus \u003d FinalApplicationStatus.FAILED;\n      appMessage \u003d \"Diagnostics.\" + \", total\u003d\" + numTotalContainers\n          + \", completed\u003d\" + numCompletedContainers.get() + \", allocated\u003d\"\n          + numAllocatedContainers.get() + \", failed\u003d\"\n          + numFailedContainers.get();\n      success \u003d false;\n    }\n    try {\n      resourceManager.unregisterApplicationMaster(appStatus, appMessage, null);\n    } catch (YarnRemoteException ex) {\n      LOG.error(\"Failed to unregister application\", ex);\n    } catch (IOException e) {\n      LOG.error(\"Failed to unregister application\", e);\n    }\n    \n    done \u003d true;\n    resourceManager.stop();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java",
      "extendedDetails": {}
    },
    "28bac402953a4337deedf0472611f5775c7a74c9": {
      "type": "Yintroduced",
      "commitMessage": "YARN-417. Create AMRMClient wrapper that provides asynchronous callbacks. (Sandy Ryza via bikas)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1459555 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/03/13 3:26 PM",
      "commitName": "28bac402953a4337deedf0472611f5775c7a74c9",
      "commitAuthor": "Bikas Saha",
      "diff": "@@ -0,0 +1,39 @@\n+  private void finish() {\n+    // Join all launched threads\n+    // needed for when we time out\n+    // and we need to release containers\n+    for (Thread launchThread : launchThreads) {\n+      try {\n+        launchThread.join(10000);\n+      } catch (InterruptedException e) {\n+        LOG.info(\"Exception thrown in thread join: \" + e.getMessage());\n+        e.printStackTrace();\n+      }\n+    }\n+\n+    // When the application completes, it should send a finish application\n+    // signal to the RM\n+    LOG.info(\"Application completed. Signalling finish to RM\");\n+\n+    FinalApplicationStatus appStatus;\n+    String appMessage \u003d null;\n+    success \u003d true;\n+    if (numFailedContainers.get() \u003d\u003d 0) {\n+      appStatus \u003d FinalApplicationStatus.SUCCEEDED;\n+    } else {\n+      appStatus \u003d FinalApplicationStatus.FAILED;\n+      appMessage \u003d \"Diagnostics.\" + \", total\u003d\" + numTotalContainers\n+          + \", completed\u003d\" + numCompletedContainers.get() + \", allocated\u003d\"\n+          + numAllocatedContainers.get() + \", failed\u003d\"\n+          + numFailedContainers.get();\n+      success \u003d false;\n+    }\n+    try {\n+      resourceManager.unregisterApplicationMaster(appStatus, appMessage, null);\n+    } catch (YarnRemoteException ex) {\n+      LOG.error(\"Failed to unregister application\", ex);\n+    }\n+    \n+    done \u003d true;\n+    resourceManager.stop();\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void finish() {\n    // Join all launched threads\n    // needed for when we time out\n    // and we need to release containers\n    for (Thread launchThread : launchThreads) {\n      try {\n        launchThread.join(10000);\n      } catch (InterruptedException e) {\n        LOG.info(\"Exception thrown in thread join: \" + e.getMessage());\n        e.printStackTrace();\n      }\n    }\n\n    // When the application completes, it should send a finish application\n    // signal to the RM\n    LOG.info(\"Application completed. Signalling finish to RM\");\n\n    FinalApplicationStatus appStatus;\n    String appMessage \u003d null;\n    success \u003d true;\n    if (numFailedContainers.get() \u003d\u003d 0) {\n      appStatus \u003d FinalApplicationStatus.SUCCEEDED;\n    } else {\n      appStatus \u003d FinalApplicationStatus.FAILED;\n      appMessage \u003d \"Diagnostics.\" + \", total\u003d\" + numTotalContainers\n          + \", completed\u003d\" + numCompletedContainers.get() + \", allocated\u003d\"\n          + numAllocatedContainers.get() + \", failed\u003d\"\n          + numFailedContainers.get();\n      success \u003d false;\n    }\n    try {\n      resourceManager.unregisterApplicationMaster(appStatus, appMessage, null);\n    } catch (YarnRemoteException ex) {\n      LOG.error(\"Failed to unregister application\", ex);\n    }\n    \n    done \u003d true;\n    resourceManager.stop();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/ApplicationMaster.java"
    }
  }
}