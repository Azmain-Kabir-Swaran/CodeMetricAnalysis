{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "CommonNodeLabelsManager.java",
  "functionName": "internalUpdateLabelsOnNodes",
  "functionId": "internalUpdateLabelsOnNodes___nodeToLabels-Map__NodeId,Set__String______op-NodeLabelUpdateOperation",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/nodelabels/CommonNodeLabelsManager.java",
  "functionStartLine": 563,
  "functionEndLine": 668,
  "numCommitsSeen": 42,
  "timeTaken": 1921,
  "changeHistory": [
    "db9304788187c700647c4d84caeb3b5ad6d868d8",
    "db1b674b50ddecf2774f4092d677c412722bdcb1",
    "5bd984691b3e3df5d8aac910295138996e7a5839",
    "a2604062681230442eefae79815db5d77ccc4c2e"
  ],
  "changeHistoryShort": {
    "db9304788187c700647c4d84caeb3b5ad6d868d8": "Ybodychange",
    "db1b674b50ddecf2774f4092d677c412722bdcb1": "Ybodychange",
    "5bd984691b3e3df5d8aac910295138996e7a5839": "Ybodychange",
    "a2604062681230442eefae79815db5d77ccc4c2e": "Yintroduced"
  },
  "changeHistoryDetails": {
    "db9304788187c700647c4d84caeb3b5ad6d868d8": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3964. Support NodeLabelsProvider at Resource Manager side.\nContributed by Dian Fu.\n",
      "commitDate": "10/10/15 10:51 PM",
      "commitName": "db9304788187c700647c4d84caeb3b5ad6d868d8",
      "commitAuthor": "Devaraj K",
      "commitDateOld": "13/09/15 6:25 AM",
      "commitNameOld": "7269906254afe59ea464ed674d8218f82eeaec26",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 27.68,
      "commitsBetweenForRepo": 210,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,102 +1,106 @@\n   protected void internalUpdateLabelsOnNodes(\n       Map\u003cNodeId, Set\u003cString\u003e\u003e nodeToLabels, NodeLabelUpdateOperation op)\n       throws IOException {\n     // do update labels from nodes\n     Map\u003cNodeId, Set\u003cString\u003e\u003e newNMToLabels \u003d\n         new HashMap\u003cNodeId, Set\u003cString\u003e\u003e();\n     Set\u003cString\u003e oldLabels;\n     for (Entry\u003cNodeId, Set\u003cString\u003e\u003e entry : nodeToLabels.entrySet()) {\n       NodeId nodeId \u003d entry.getKey();\n       Set\u003cString\u003e labels \u003d entry.getValue();\n       \n       createHostIfNonExisted(nodeId.getHost());\n       if (nodeId.getPort() \u003d\u003d WILDCARD_PORT) {\n         Host host \u003d nodeCollections.get(nodeId.getHost());\n         switch (op) {\n         case REMOVE:\n           removeNodeFromLabels(nodeId, labels);\n           host.labels.removeAll(labels);\n           for (Node node : host.nms.values()) {\n             if (node.labels !\u003d null) {\n               node.labels.removeAll(labels);\n             }\n             removeNodeFromLabels(node.nodeId, labels);\n           }\n           break;\n         case ADD:\n           addNodeToLabels(nodeId, labels);\n           host.labels.addAll(labels);\n           for (Node node : host.nms.values()) {\n             if (node.labels !\u003d null) {\n               node.labels.addAll(labels);\n             }\n             addNodeToLabels(node.nodeId, labels);\n           }\n           break;\n         case REPLACE:\n           replaceNodeForLabels(nodeId, host.labels, labels);\n           host.labels.clear();\n           host.labels.addAll(labels);\n           for (Node node : host.nms.values()) {\n             replaceNodeForLabels(node.nodeId, node.labels, labels);\n             node.labels \u003d null;\n           }\n           break;\n         default:\n           break;\n         }\n         newNMToLabels.put(nodeId, host.labels);\n       } else {\n         if (EnumSet.of(NodeLabelUpdateOperation.ADD,\n             NodeLabelUpdateOperation.REPLACE).contains(op)) {\n           // Add and replace\n           createNodeIfNonExisted(nodeId);\n           Node nm \u003d getNMInNodeSet(nodeId);\n           switch (op) {\n           case ADD:\n             addNodeToLabels(nodeId, labels);\n             if (nm.labels \u003d\u003d null) { \n               nm.labels \u003d new HashSet\u003cString\u003e();\n             }\n             nm.labels.addAll(labels);\n             break;\n           case REPLACE:\n             oldLabels \u003d getLabelsByNode(nodeId);\n             replaceNodeForLabels(nodeId, oldLabels, labels);\n             if (nm.labels \u003d\u003d null) { \n               nm.labels \u003d new HashSet\u003cString\u003e();\n             }\n             nm.labels.clear();\n             nm.labels.addAll(labels);\n             break;\n           default:\n             break;\n           }\n           newNMToLabels.put(nodeId, nm.labels);\n         } else {\n           // remove\n           removeNodeFromLabels(nodeId, labels);\n           Node nm \u003d getNMInNodeSet(nodeId);\n           if (nm.labels !\u003d null) {\n             nm.labels.removeAll(labels);\n             newNMToLabels.put(nodeId, nm.labels);\n           }\n         }\n       }\n     }\n     \n-    if (null !\u003d dispatcher \u0026\u0026 !isDistributedNodeLabelConfiguration) {\n-      // In case of DistributedNodeLabelConfiguration, no need to save the the\n+    if (null !\u003d dispatcher \u0026\u0026 isCentralizedNodeLabelConfiguration) {\n+      // In case of DistributedNodeLabelConfiguration or\n+      // DelegatedCentralizedNodeLabelConfiguration, no need to save the the\n       // NodeLabels Mapping to the back-end store, as on RM restart/failover\n       // NodeLabels are collected from NM through Register/Heartbeat again\n+      // in case of DistributedNodeLabelConfiguration and collected from\n+      // RMNodeLabelsMappingProvider in case of\n+      // DelegatedCentralizedNodeLabelConfiguration\n       dispatcher.getEventHandler().handle(\n           new UpdateNodeToLabelsMappingsEvent(newNMToLabels));\n     }\n \n     // shows node-\u003elabels we added\n     LOG.info(op.name() + \" labels on nodes:\");\n     for (Entry\u003cNodeId, Set\u003cString\u003e\u003e entry : newNMToLabels.entrySet()) {\n       LOG.info(\"  NM\u003d\" + entry.getKey() + \", labels\u003d[\"\n           + StringUtils.join(entry.getValue().iterator(), \",\") + \"]\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void internalUpdateLabelsOnNodes(\n      Map\u003cNodeId, Set\u003cString\u003e\u003e nodeToLabels, NodeLabelUpdateOperation op)\n      throws IOException {\n    // do update labels from nodes\n    Map\u003cNodeId, Set\u003cString\u003e\u003e newNMToLabels \u003d\n        new HashMap\u003cNodeId, Set\u003cString\u003e\u003e();\n    Set\u003cString\u003e oldLabels;\n    for (Entry\u003cNodeId, Set\u003cString\u003e\u003e entry : nodeToLabels.entrySet()) {\n      NodeId nodeId \u003d entry.getKey();\n      Set\u003cString\u003e labels \u003d entry.getValue();\n      \n      createHostIfNonExisted(nodeId.getHost());\n      if (nodeId.getPort() \u003d\u003d WILDCARD_PORT) {\n        Host host \u003d nodeCollections.get(nodeId.getHost());\n        switch (op) {\n        case REMOVE:\n          removeNodeFromLabels(nodeId, labels);\n          host.labels.removeAll(labels);\n          for (Node node : host.nms.values()) {\n            if (node.labels !\u003d null) {\n              node.labels.removeAll(labels);\n            }\n            removeNodeFromLabels(node.nodeId, labels);\n          }\n          break;\n        case ADD:\n          addNodeToLabels(nodeId, labels);\n          host.labels.addAll(labels);\n          for (Node node : host.nms.values()) {\n            if (node.labels !\u003d null) {\n              node.labels.addAll(labels);\n            }\n            addNodeToLabels(node.nodeId, labels);\n          }\n          break;\n        case REPLACE:\n          replaceNodeForLabels(nodeId, host.labels, labels);\n          host.labels.clear();\n          host.labels.addAll(labels);\n          for (Node node : host.nms.values()) {\n            replaceNodeForLabels(node.nodeId, node.labels, labels);\n            node.labels \u003d null;\n          }\n          break;\n        default:\n          break;\n        }\n        newNMToLabels.put(nodeId, host.labels);\n      } else {\n        if (EnumSet.of(NodeLabelUpdateOperation.ADD,\n            NodeLabelUpdateOperation.REPLACE).contains(op)) {\n          // Add and replace\n          createNodeIfNonExisted(nodeId);\n          Node nm \u003d getNMInNodeSet(nodeId);\n          switch (op) {\n          case ADD:\n            addNodeToLabels(nodeId, labels);\n            if (nm.labels \u003d\u003d null) { \n              nm.labels \u003d new HashSet\u003cString\u003e();\n            }\n            nm.labels.addAll(labels);\n            break;\n          case REPLACE:\n            oldLabels \u003d getLabelsByNode(nodeId);\n            replaceNodeForLabels(nodeId, oldLabels, labels);\n            if (nm.labels \u003d\u003d null) { \n              nm.labels \u003d new HashSet\u003cString\u003e();\n            }\n            nm.labels.clear();\n            nm.labels.addAll(labels);\n            break;\n          default:\n            break;\n          }\n          newNMToLabels.put(nodeId, nm.labels);\n        } else {\n          // remove\n          removeNodeFromLabels(nodeId, labels);\n          Node nm \u003d getNMInNodeSet(nodeId);\n          if (nm.labels !\u003d null) {\n            nm.labels.removeAll(labels);\n            newNMToLabels.put(nodeId, nm.labels);\n          }\n        }\n      }\n    }\n    \n    if (null !\u003d dispatcher \u0026\u0026 isCentralizedNodeLabelConfiguration) {\n      // In case of DistributedNodeLabelConfiguration or\n      // DelegatedCentralizedNodeLabelConfiguration, no need to save the the\n      // NodeLabels Mapping to the back-end store, as on RM restart/failover\n      // NodeLabels are collected from NM through Register/Heartbeat again\n      // in case of DistributedNodeLabelConfiguration and collected from\n      // RMNodeLabelsMappingProvider in case of\n      // DelegatedCentralizedNodeLabelConfiguration\n      dispatcher.getEventHandler().handle(\n          new UpdateNodeToLabelsMappingsEvent(newNMToLabels));\n    }\n\n    // shows node-\u003elabels we added\n    LOG.info(op.name() + \" labels on nodes:\");\n    for (Entry\u003cNodeId, Set\u003cString\u003e\u003e entry : newNMToLabels.entrySet()) {\n      LOG.info(\"  NM\u003d\" + entry.getKey() + \", labels\u003d[\"\n          + StringUtils.join(entry.getValue().iterator(), \",\") + \"]\");\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/nodelabels/CommonNodeLabelsManager.java",
      "extendedDetails": {}
    },
    "db1b674b50ddecf2774f4092d677c412722bdcb1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2740. Fix NodeLabelsManager to properly handle node label modifications when distributed node label configuration enabled. (Naganarasimha G R via wangda)\n",
      "commitDate": "27/04/15 4:24 PM",
      "commitName": "db1b674b50ddecf2774f4092d677c412722bdcb1",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "23/04/15 11:19 AM",
      "commitNameOld": "f5fe35e297ed4a00a1ba93d090207ef67cebcc9d",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 4.21,
      "commitsBetweenForRepo": 44,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,99 +1,102 @@\n   protected void internalUpdateLabelsOnNodes(\n       Map\u003cNodeId, Set\u003cString\u003e\u003e nodeToLabels, NodeLabelUpdateOperation op)\n       throws IOException {\n     // do update labels from nodes\n     Map\u003cNodeId, Set\u003cString\u003e\u003e newNMToLabels \u003d\n         new HashMap\u003cNodeId, Set\u003cString\u003e\u003e();\n     Set\u003cString\u003e oldLabels;\n     for (Entry\u003cNodeId, Set\u003cString\u003e\u003e entry : nodeToLabels.entrySet()) {\n       NodeId nodeId \u003d entry.getKey();\n       Set\u003cString\u003e labels \u003d entry.getValue();\n       \n       createHostIfNonExisted(nodeId.getHost());\n       if (nodeId.getPort() \u003d\u003d WILDCARD_PORT) {\n         Host host \u003d nodeCollections.get(nodeId.getHost());\n         switch (op) {\n         case REMOVE:\n           removeNodeFromLabels(nodeId, labels);\n           host.labels.removeAll(labels);\n           for (Node node : host.nms.values()) {\n             if (node.labels !\u003d null) {\n               node.labels.removeAll(labels);\n             }\n             removeNodeFromLabels(node.nodeId, labels);\n           }\n           break;\n         case ADD:\n           addNodeToLabels(nodeId, labels);\n           host.labels.addAll(labels);\n           for (Node node : host.nms.values()) {\n             if (node.labels !\u003d null) {\n               node.labels.addAll(labels);\n             }\n             addNodeToLabels(node.nodeId, labels);\n           }\n           break;\n         case REPLACE:\n           replaceNodeForLabels(nodeId, host.labels, labels);\n           host.labels.clear();\n           host.labels.addAll(labels);\n           for (Node node : host.nms.values()) {\n             replaceNodeForLabels(node.nodeId, node.labels, labels);\n             node.labels \u003d null;\n           }\n           break;\n         default:\n           break;\n         }\n         newNMToLabels.put(nodeId, host.labels);\n       } else {\n         if (EnumSet.of(NodeLabelUpdateOperation.ADD,\n             NodeLabelUpdateOperation.REPLACE).contains(op)) {\n           // Add and replace\n           createNodeIfNonExisted(nodeId);\n           Node nm \u003d getNMInNodeSet(nodeId);\n           switch (op) {\n           case ADD:\n             addNodeToLabels(nodeId, labels);\n             if (nm.labels \u003d\u003d null) { \n               nm.labels \u003d new HashSet\u003cString\u003e();\n             }\n             nm.labels.addAll(labels);\n             break;\n           case REPLACE:\n             oldLabels \u003d getLabelsByNode(nodeId);\n             replaceNodeForLabels(nodeId, oldLabels, labels);\n             if (nm.labels \u003d\u003d null) { \n               nm.labels \u003d new HashSet\u003cString\u003e();\n             }\n             nm.labels.clear();\n             nm.labels.addAll(labels);\n             break;\n           default:\n             break;\n           }\n           newNMToLabels.put(nodeId, nm.labels);\n         } else {\n           // remove\n           removeNodeFromLabels(nodeId, labels);\n           Node nm \u003d getNMInNodeSet(nodeId);\n           if (nm.labels !\u003d null) {\n             nm.labels.removeAll(labels);\n             newNMToLabels.put(nodeId, nm.labels);\n           }\n         }\n       }\n     }\n     \n-    if (null !\u003d dispatcher) {\n+    if (null !\u003d dispatcher \u0026\u0026 !isDistributedNodeLabelConfiguration) {\n+      // In case of DistributedNodeLabelConfiguration, no need to save the the\n+      // NodeLabels Mapping to the back-end store, as on RM restart/failover\n+      // NodeLabels are collected from NM through Register/Heartbeat again\n       dispatcher.getEventHandler().handle(\n           new UpdateNodeToLabelsMappingsEvent(newNMToLabels));\n     }\n \n     // shows node-\u003elabels we added\n     LOG.info(op.name() + \" labels on nodes:\");\n     for (Entry\u003cNodeId, Set\u003cString\u003e\u003e entry : newNMToLabels.entrySet()) {\n       LOG.info(\"  NM\u003d\" + entry.getKey() + \", labels\u003d[\"\n           + StringUtils.join(entry.getValue().iterator(), \",\") + \"]\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void internalUpdateLabelsOnNodes(\n      Map\u003cNodeId, Set\u003cString\u003e\u003e nodeToLabels, NodeLabelUpdateOperation op)\n      throws IOException {\n    // do update labels from nodes\n    Map\u003cNodeId, Set\u003cString\u003e\u003e newNMToLabels \u003d\n        new HashMap\u003cNodeId, Set\u003cString\u003e\u003e();\n    Set\u003cString\u003e oldLabels;\n    for (Entry\u003cNodeId, Set\u003cString\u003e\u003e entry : nodeToLabels.entrySet()) {\n      NodeId nodeId \u003d entry.getKey();\n      Set\u003cString\u003e labels \u003d entry.getValue();\n      \n      createHostIfNonExisted(nodeId.getHost());\n      if (nodeId.getPort() \u003d\u003d WILDCARD_PORT) {\n        Host host \u003d nodeCollections.get(nodeId.getHost());\n        switch (op) {\n        case REMOVE:\n          removeNodeFromLabels(nodeId, labels);\n          host.labels.removeAll(labels);\n          for (Node node : host.nms.values()) {\n            if (node.labels !\u003d null) {\n              node.labels.removeAll(labels);\n            }\n            removeNodeFromLabels(node.nodeId, labels);\n          }\n          break;\n        case ADD:\n          addNodeToLabels(nodeId, labels);\n          host.labels.addAll(labels);\n          for (Node node : host.nms.values()) {\n            if (node.labels !\u003d null) {\n              node.labels.addAll(labels);\n            }\n            addNodeToLabels(node.nodeId, labels);\n          }\n          break;\n        case REPLACE:\n          replaceNodeForLabels(nodeId, host.labels, labels);\n          host.labels.clear();\n          host.labels.addAll(labels);\n          for (Node node : host.nms.values()) {\n            replaceNodeForLabels(node.nodeId, node.labels, labels);\n            node.labels \u003d null;\n          }\n          break;\n        default:\n          break;\n        }\n        newNMToLabels.put(nodeId, host.labels);\n      } else {\n        if (EnumSet.of(NodeLabelUpdateOperation.ADD,\n            NodeLabelUpdateOperation.REPLACE).contains(op)) {\n          // Add and replace\n          createNodeIfNonExisted(nodeId);\n          Node nm \u003d getNMInNodeSet(nodeId);\n          switch (op) {\n          case ADD:\n            addNodeToLabels(nodeId, labels);\n            if (nm.labels \u003d\u003d null) { \n              nm.labels \u003d new HashSet\u003cString\u003e();\n            }\n            nm.labels.addAll(labels);\n            break;\n          case REPLACE:\n            oldLabels \u003d getLabelsByNode(nodeId);\n            replaceNodeForLabels(nodeId, oldLabels, labels);\n            if (nm.labels \u003d\u003d null) { \n              nm.labels \u003d new HashSet\u003cString\u003e();\n            }\n            nm.labels.clear();\n            nm.labels.addAll(labels);\n            break;\n          default:\n            break;\n          }\n          newNMToLabels.put(nodeId, nm.labels);\n        } else {\n          // remove\n          removeNodeFromLabels(nodeId, labels);\n          Node nm \u003d getNMInNodeSet(nodeId);\n          if (nm.labels !\u003d null) {\n            nm.labels.removeAll(labels);\n            newNMToLabels.put(nodeId, nm.labels);\n          }\n        }\n      }\n    }\n    \n    if (null !\u003d dispatcher \u0026\u0026 !isDistributedNodeLabelConfiguration) {\n      // In case of DistributedNodeLabelConfiguration, no need to save the the\n      // NodeLabels Mapping to the back-end store, as on RM restart/failover\n      // NodeLabels are collected from NM through Register/Heartbeat again\n      dispatcher.getEventHandler().handle(\n          new UpdateNodeToLabelsMappingsEvent(newNMToLabels));\n    }\n\n    // shows node-\u003elabels we added\n    LOG.info(op.name() + \" labels on nodes:\");\n    for (Entry\u003cNodeId, Set\u003cString\u003e\u003e entry : newNMToLabels.entrySet()) {\n      LOG.info(\"  NM\u003d\" + entry.getKey() + \", labels\u003d[\"\n          + StringUtils.join(entry.getValue().iterator(), \",\") + \"]\");\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/nodelabels/CommonNodeLabelsManager.java",
      "extendedDetails": {}
    },
    "5bd984691b3e3df5d8aac910295138996e7a5839": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3075. NodeLabelsManager implementation to retrieve label to node mapping (Varun Saxena via wangda)\n",
      "commitDate": "03/02/15 12:52 PM",
      "commitName": "5bd984691b3e3df5d8aac910295138996e7a5839",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "23/01/15 3:37 AM",
      "commitNameOld": "24aa462673d392fed859f8088acf9679ae62a129",
      "commitAuthorOld": "Tsuyoshi Ozawa",
      "daysBetweenCommits": 11.39,
      "commitsBetweenForRepo": 81,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,85 +1,99 @@\n   protected void internalUpdateLabelsOnNodes(\n       Map\u003cNodeId, Set\u003cString\u003e\u003e nodeToLabels, NodeLabelUpdateOperation op)\n       throws IOException {\n     // do update labels from nodes\n     Map\u003cNodeId, Set\u003cString\u003e\u003e newNMToLabels \u003d\n         new HashMap\u003cNodeId, Set\u003cString\u003e\u003e();\n+    Set\u003cString\u003e oldLabels;\n     for (Entry\u003cNodeId, Set\u003cString\u003e\u003e entry : nodeToLabels.entrySet()) {\n       NodeId nodeId \u003d entry.getKey();\n       Set\u003cString\u003e labels \u003d entry.getValue();\n       \n       createHostIfNonExisted(nodeId.getHost());\n       if (nodeId.getPort() \u003d\u003d WILDCARD_PORT) {\n         Host host \u003d nodeCollections.get(nodeId.getHost());\n         switch (op) {\n-        case REMOVE: \n+        case REMOVE:\n+          removeNodeFromLabels(nodeId, labels);\n           host.labels.removeAll(labels);\n           for (Node node : host.nms.values()) {\n             if (node.labels !\u003d null) {\n               node.labels.removeAll(labels);\n             }\n+            removeNodeFromLabels(node.nodeId, labels);\n           }\n           break;\n         case ADD:\n+          addNodeToLabels(nodeId, labels);\n           host.labels.addAll(labels);\n           for (Node node : host.nms.values()) {\n             if (node.labels !\u003d null) {\n               node.labels.addAll(labels);\n             }\n+            addNodeToLabels(node.nodeId, labels);\n           }\n           break;\n         case REPLACE:\n+          replaceNodeForLabels(nodeId, host.labels, labels);\n           host.labels.clear();\n           host.labels.addAll(labels);\n           for (Node node : host.nms.values()) {\n+            replaceNodeForLabels(node.nodeId, node.labels, labels);\n             node.labels \u003d null;\n           }\n           break;\n         default:\n           break;\n         }\n         newNMToLabels.put(nodeId, host.labels);\n       } else {\n         if (EnumSet.of(NodeLabelUpdateOperation.ADD,\n             NodeLabelUpdateOperation.REPLACE).contains(op)) {\n           // Add and replace\n           createNodeIfNonExisted(nodeId);\n           Node nm \u003d getNMInNodeSet(nodeId);\n-          if (nm.labels \u003d\u003d null) {\n-            nm.labels \u003d new HashSet\u003cString\u003e();\n-          }\n           switch (op) {\n           case ADD:\n+            addNodeToLabels(nodeId, labels);\n+            if (nm.labels \u003d\u003d null) { \n+              nm.labels \u003d new HashSet\u003cString\u003e();\n+            }\n             nm.labels.addAll(labels);\n             break;\n           case REPLACE:\n+            oldLabels \u003d getLabelsByNode(nodeId);\n+            replaceNodeForLabels(nodeId, oldLabels, labels);\n+            if (nm.labels \u003d\u003d null) { \n+              nm.labels \u003d new HashSet\u003cString\u003e();\n+            }\n             nm.labels.clear();\n             nm.labels.addAll(labels);\n             break;\n           default:\n             break;\n           }\n           newNMToLabels.put(nodeId, nm.labels);\n         } else {\n           // remove\n+          removeNodeFromLabels(nodeId, labels);\n           Node nm \u003d getNMInNodeSet(nodeId);\n           if (nm.labels !\u003d null) {\n             nm.labels.removeAll(labels);\n             newNMToLabels.put(nodeId, nm.labels);\n           }\n         }\n       }\n     }\n     \n     if (null !\u003d dispatcher) {\n       dispatcher.getEventHandler().handle(\n           new UpdateNodeToLabelsMappingsEvent(newNMToLabels));\n     }\n \n     // shows node-\u003elabels we added\n     LOG.info(op.name() + \" labels on nodes:\");\n     for (Entry\u003cNodeId, Set\u003cString\u003e\u003e entry : newNMToLabels.entrySet()) {\n       LOG.info(\"  NM\u003d\" + entry.getKey() + \", labels\u003d[\"\n           + StringUtils.join(entry.getValue().iterator(), \",\") + \"]\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void internalUpdateLabelsOnNodes(\n      Map\u003cNodeId, Set\u003cString\u003e\u003e nodeToLabels, NodeLabelUpdateOperation op)\n      throws IOException {\n    // do update labels from nodes\n    Map\u003cNodeId, Set\u003cString\u003e\u003e newNMToLabels \u003d\n        new HashMap\u003cNodeId, Set\u003cString\u003e\u003e();\n    Set\u003cString\u003e oldLabels;\n    for (Entry\u003cNodeId, Set\u003cString\u003e\u003e entry : nodeToLabels.entrySet()) {\n      NodeId nodeId \u003d entry.getKey();\n      Set\u003cString\u003e labels \u003d entry.getValue();\n      \n      createHostIfNonExisted(nodeId.getHost());\n      if (nodeId.getPort() \u003d\u003d WILDCARD_PORT) {\n        Host host \u003d nodeCollections.get(nodeId.getHost());\n        switch (op) {\n        case REMOVE:\n          removeNodeFromLabels(nodeId, labels);\n          host.labels.removeAll(labels);\n          for (Node node : host.nms.values()) {\n            if (node.labels !\u003d null) {\n              node.labels.removeAll(labels);\n            }\n            removeNodeFromLabels(node.nodeId, labels);\n          }\n          break;\n        case ADD:\n          addNodeToLabels(nodeId, labels);\n          host.labels.addAll(labels);\n          for (Node node : host.nms.values()) {\n            if (node.labels !\u003d null) {\n              node.labels.addAll(labels);\n            }\n            addNodeToLabels(node.nodeId, labels);\n          }\n          break;\n        case REPLACE:\n          replaceNodeForLabels(nodeId, host.labels, labels);\n          host.labels.clear();\n          host.labels.addAll(labels);\n          for (Node node : host.nms.values()) {\n            replaceNodeForLabels(node.nodeId, node.labels, labels);\n            node.labels \u003d null;\n          }\n          break;\n        default:\n          break;\n        }\n        newNMToLabels.put(nodeId, host.labels);\n      } else {\n        if (EnumSet.of(NodeLabelUpdateOperation.ADD,\n            NodeLabelUpdateOperation.REPLACE).contains(op)) {\n          // Add and replace\n          createNodeIfNonExisted(nodeId);\n          Node nm \u003d getNMInNodeSet(nodeId);\n          switch (op) {\n          case ADD:\n            addNodeToLabels(nodeId, labels);\n            if (nm.labels \u003d\u003d null) { \n              nm.labels \u003d new HashSet\u003cString\u003e();\n            }\n            nm.labels.addAll(labels);\n            break;\n          case REPLACE:\n            oldLabels \u003d getLabelsByNode(nodeId);\n            replaceNodeForLabels(nodeId, oldLabels, labels);\n            if (nm.labels \u003d\u003d null) { \n              nm.labels \u003d new HashSet\u003cString\u003e();\n            }\n            nm.labels.clear();\n            nm.labels.addAll(labels);\n            break;\n          default:\n            break;\n          }\n          newNMToLabels.put(nodeId, nm.labels);\n        } else {\n          // remove\n          removeNodeFromLabels(nodeId, labels);\n          Node nm \u003d getNMInNodeSet(nodeId);\n          if (nm.labels !\u003d null) {\n            nm.labels.removeAll(labels);\n            newNMToLabels.put(nodeId, nm.labels);\n          }\n        }\n      }\n    }\n    \n    if (null !\u003d dispatcher) {\n      dispatcher.getEventHandler().handle(\n          new UpdateNodeToLabelsMappingsEvent(newNMToLabels));\n    }\n\n    // shows node-\u003elabels we added\n    LOG.info(op.name() + \" labels on nodes:\");\n    for (Entry\u003cNodeId, Set\u003cString\u003e\u003e entry : newNMToLabels.entrySet()) {\n      LOG.info(\"  NM\u003d\" + entry.getKey() + \", labels\u003d[\"\n          + StringUtils.join(entry.getValue().iterator(), \",\") + \"]\");\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/nodelabels/CommonNodeLabelsManager.java",
      "extendedDetails": {}
    },
    "a2604062681230442eefae79815db5d77ccc4c2e": {
      "type": "Yintroduced",
      "commitMessage": "YARN-3014. Replaces labels on a host should update all NM\u0027s labels on that host. Contributed by Wangda Tan\n",
      "commitDate": "09/01/15 5:49 PM",
      "commitName": "a2604062681230442eefae79815db5d77ccc4c2e",
      "commitAuthor": "Jian He",
      "diff": "@@ -0,0 +1,85 @@\n+  protected void internalUpdateLabelsOnNodes(\n+      Map\u003cNodeId, Set\u003cString\u003e\u003e nodeToLabels, NodeLabelUpdateOperation op)\n+      throws IOException {\n+    // do update labels from nodes\n+    Map\u003cNodeId, Set\u003cString\u003e\u003e newNMToLabels \u003d\n+        new HashMap\u003cNodeId, Set\u003cString\u003e\u003e();\n+    for (Entry\u003cNodeId, Set\u003cString\u003e\u003e entry : nodeToLabels.entrySet()) {\n+      NodeId nodeId \u003d entry.getKey();\n+      Set\u003cString\u003e labels \u003d entry.getValue();\n+      \n+      createHostIfNonExisted(nodeId.getHost());\n+      if (nodeId.getPort() \u003d\u003d WILDCARD_PORT) {\n+        Host host \u003d nodeCollections.get(nodeId.getHost());\n+        switch (op) {\n+        case REMOVE: \n+          host.labels.removeAll(labels);\n+          for (Node node : host.nms.values()) {\n+            if (node.labels !\u003d null) {\n+              node.labels.removeAll(labels);\n+            }\n+          }\n+          break;\n+        case ADD:\n+          host.labels.addAll(labels);\n+          for (Node node : host.nms.values()) {\n+            if (node.labels !\u003d null) {\n+              node.labels.addAll(labels);\n+            }\n+          }\n+          break;\n+        case REPLACE:\n+          host.labels.clear();\n+          host.labels.addAll(labels);\n+          for (Node node : host.nms.values()) {\n+            node.labels \u003d null;\n+          }\n+          break;\n+        default:\n+          break;\n+        }\n+        newNMToLabels.put(nodeId, host.labels);\n+      } else {\n+        if (EnumSet.of(NodeLabelUpdateOperation.ADD,\n+            NodeLabelUpdateOperation.REPLACE).contains(op)) {\n+          // Add and replace\n+          createNodeIfNonExisted(nodeId);\n+          Node nm \u003d getNMInNodeSet(nodeId);\n+          if (nm.labels \u003d\u003d null) {\n+            nm.labels \u003d new HashSet\u003cString\u003e();\n+          }\n+          switch (op) {\n+          case ADD:\n+            nm.labels.addAll(labels);\n+            break;\n+          case REPLACE:\n+            nm.labels.clear();\n+            nm.labels.addAll(labels);\n+            break;\n+          default:\n+            break;\n+          }\n+          newNMToLabels.put(nodeId, nm.labels);\n+        } else {\n+          // remove\n+          Node nm \u003d getNMInNodeSet(nodeId);\n+          if (nm.labels !\u003d null) {\n+            nm.labels.removeAll(labels);\n+            newNMToLabels.put(nodeId, nm.labels);\n+          }\n+        }\n+      }\n+    }\n+    \n+    if (null !\u003d dispatcher) {\n+      dispatcher.getEventHandler().handle(\n+          new UpdateNodeToLabelsMappingsEvent(newNMToLabels));\n+    }\n+\n+    // shows node-\u003elabels we added\n+    LOG.info(op.name() + \" labels on nodes:\");\n+    for (Entry\u003cNodeId, Set\u003cString\u003e\u003e entry : newNMToLabels.entrySet()) {\n+      LOG.info(\"  NM\u003d\" + entry.getKey() + \", labels\u003d[\"\n+          + StringUtils.join(entry.getValue().iterator(), \",\") + \"]\");\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  protected void internalUpdateLabelsOnNodes(\n      Map\u003cNodeId, Set\u003cString\u003e\u003e nodeToLabels, NodeLabelUpdateOperation op)\n      throws IOException {\n    // do update labels from nodes\n    Map\u003cNodeId, Set\u003cString\u003e\u003e newNMToLabels \u003d\n        new HashMap\u003cNodeId, Set\u003cString\u003e\u003e();\n    for (Entry\u003cNodeId, Set\u003cString\u003e\u003e entry : nodeToLabels.entrySet()) {\n      NodeId nodeId \u003d entry.getKey();\n      Set\u003cString\u003e labels \u003d entry.getValue();\n      \n      createHostIfNonExisted(nodeId.getHost());\n      if (nodeId.getPort() \u003d\u003d WILDCARD_PORT) {\n        Host host \u003d nodeCollections.get(nodeId.getHost());\n        switch (op) {\n        case REMOVE: \n          host.labels.removeAll(labels);\n          for (Node node : host.nms.values()) {\n            if (node.labels !\u003d null) {\n              node.labels.removeAll(labels);\n            }\n          }\n          break;\n        case ADD:\n          host.labels.addAll(labels);\n          for (Node node : host.nms.values()) {\n            if (node.labels !\u003d null) {\n              node.labels.addAll(labels);\n            }\n          }\n          break;\n        case REPLACE:\n          host.labels.clear();\n          host.labels.addAll(labels);\n          for (Node node : host.nms.values()) {\n            node.labels \u003d null;\n          }\n          break;\n        default:\n          break;\n        }\n        newNMToLabels.put(nodeId, host.labels);\n      } else {\n        if (EnumSet.of(NodeLabelUpdateOperation.ADD,\n            NodeLabelUpdateOperation.REPLACE).contains(op)) {\n          // Add and replace\n          createNodeIfNonExisted(nodeId);\n          Node nm \u003d getNMInNodeSet(nodeId);\n          if (nm.labels \u003d\u003d null) {\n            nm.labels \u003d new HashSet\u003cString\u003e();\n          }\n          switch (op) {\n          case ADD:\n            nm.labels.addAll(labels);\n            break;\n          case REPLACE:\n            nm.labels.clear();\n            nm.labels.addAll(labels);\n            break;\n          default:\n            break;\n          }\n          newNMToLabels.put(nodeId, nm.labels);\n        } else {\n          // remove\n          Node nm \u003d getNMInNodeSet(nodeId);\n          if (nm.labels !\u003d null) {\n            nm.labels.removeAll(labels);\n            newNMToLabels.put(nodeId, nm.labels);\n          }\n        }\n      }\n    }\n    \n    if (null !\u003d dispatcher) {\n      dispatcher.getEventHandler().handle(\n          new UpdateNodeToLabelsMappingsEvent(newNMToLabels));\n    }\n\n    // shows node-\u003elabels we added\n    LOG.info(op.name() + \" labels on nodes:\");\n    for (Entry\u003cNodeId, Set\u003cString\u003e\u003e entry : newNMToLabels.entrySet()) {\n      LOG.info(\"  NM\u003d\" + entry.getKey() + \", labels\u003d[\"\n          + StringUtils.join(entry.getValue().iterator(), \",\") + \"]\");\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/nodelabels/CommonNodeLabelsManager.java"
    }
  }
}