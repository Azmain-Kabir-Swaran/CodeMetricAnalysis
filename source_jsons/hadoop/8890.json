{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "AclStorage.java",
  "functionName": "updateINodeAcl",
  "functionId": "updateINodeAcl___inode-INode__newAcl-List__AclEntry____snapshotId-int",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/AclStorage.java",
  "functionStartLine": 270,
  "functionEndLine": 304,
  "numCommitsSeen": 17,
  "timeTaken": 2644,
  "changeHistory": [
    "ad10cbd91bcf80e63d5f98868f9258c0119db2a9",
    "11be7334c4e04b1b3fe12d86f4646cc83c068b05",
    "fc14360b0340a33c0e1eb34967d4dcd772533418",
    "c89c516b95f45e04af55d9030043a42e2d07b02b",
    "14f1f76bf609704d36a1699c05fa85750cefe917",
    "5300294fbe9e235ce42253d6bcd69d8154d8f198"
  ],
  "changeHistoryShort": {
    "ad10cbd91bcf80e63d5f98868f9258c0119db2a9": "Ybodychange",
    "11be7334c4e04b1b3fe12d86f4646cc83c068b05": "Ybodychange",
    "fc14360b0340a33c0e1eb34967d4dcd772533418": "Ybodychange",
    "c89c516b95f45e04af55d9030043a42e2d07b02b": "Ybodychange",
    "14f1f76bf609704d36a1699c05fa85750cefe917": "Ymultichange(Yparameterchange,Ybodychange)",
    "5300294fbe9e235ce42253d6bcd69d8154d8f198": "Yintroduced"
  },
  "changeHistoryDetails": {
    "ad10cbd91bcf80e63d5f98868f9258c0119db2a9": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13357. Improve AclException message \"Invalid ACL: only directories may have a default ACL.\". Contributed by Gabor Bota.\n",
      "commitDate": "29/03/18 7:08 AM",
      "commitName": "ad10cbd91bcf80e63d5f98868f9258c0119db2a9",
      "commitAuthor": "Wei-Chiu Chuang",
      "commitDateOld": "06/09/16 11:02 AM",
      "commitNameOld": "f0d5382ff3e31a47d13e4cb6c3a244cca82b17ce",
      "commitAuthorOld": "Chris Nauroth",
      "daysBetweenCommits": 568.84,
      "commitsBetweenForRepo": 3847,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,35 @@\n   public static void updateINodeAcl(INode inode, List\u003cAclEntry\u003e newAcl,\n       int snapshotId) throws AclException, QuotaExceededException {\n     assert newAcl.size() \u003e\u003d 3;\n     FsPermission perm \u003d inode.getFsPermission();\n     final FsPermission newPerm;\n     if (!AclUtil.isMinimalAcl(newAcl)) {\n       // This is an extended ACL.  Split entries into access vs. default.\n       ScopedAclEntries scoped \u003d new ScopedAclEntries(newAcl);\n       List\u003cAclEntry\u003e accessEntries \u003d scoped.getAccessEntries();\n       List\u003cAclEntry\u003e defaultEntries \u003d scoped.getDefaultEntries();\n \n       // Only directories may have a default ACL.\n       if (!defaultEntries.isEmpty() \u0026\u0026 !inode.isDirectory()) {\n         throw new AclException(\n-          \"Invalid ACL: only directories may have a default ACL.\");\n+          \"Invalid ACL: only directories may have a default ACL. \"\n+            + \"Path: \" + inode.getFullPathName());\n       }\n \n       // Attach entries to the feature.\n       if (inode.getAclFeature() !\u003d null) {\n         inode.removeAclFeature(snapshotId);\n       }\n       inode.addAclFeature(createAclFeature(accessEntries, defaultEntries),\n         snapshotId);\n       newPerm \u003d createFsPermissionForExtendedAcl(accessEntries, perm);\n     } else {\n       // This is a minimal ACL.  Remove the ACL feature if it previously had one.\n       if (inode.getAclFeature() !\u003d null) {\n         inode.removeAclFeature(snapshotId);\n       }\n       newPerm \u003d createFsPermissionForMinimalAcl(newAcl, perm);\n     }\n \n     inode.setPermission(newPerm, snapshotId);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void updateINodeAcl(INode inode, List\u003cAclEntry\u003e newAcl,\n      int snapshotId) throws AclException, QuotaExceededException {\n    assert newAcl.size() \u003e\u003d 3;\n    FsPermission perm \u003d inode.getFsPermission();\n    final FsPermission newPerm;\n    if (!AclUtil.isMinimalAcl(newAcl)) {\n      // This is an extended ACL.  Split entries into access vs. default.\n      ScopedAclEntries scoped \u003d new ScopedAclEntries(newAcl);\n      List\u003cAclEntry\u003e accessEntries \u003d scoped.getAccessEntries();\n      List\u003cAclEntry\u003e defaultEntries \u003d scoped.getDefaultEntries();\n\n      // Only directories may have a default ACL.\n      if (!defaultEntries.isEmpty() \u0026\u0026 !inode.isDirectory()) {\n        throw new AclException(\n          \"Invalid ACL: only directories may have a default ACL. \"\n            + \"Path: \" + inode.getFullPathName());\n      }\n\n      // Attach entries to the feature.\n      if (inode.getAclFeature() !\u003d null) {\n        inode.removeAclFeature(snapshotId);\n      }\n      inode.addAclFeature(createAclFeature(accessEntries, defaultEntries),\n        snapshotId);\n      newPerm \u003d createFsPermissionForExtendedAcl(accessEntries, perm);\n    } else {\n      // This is a minimal ACL.  Remove the ACL feature if it previously had one.\n      if (inode.getAclFeature() !\u003d null) {\n        inode.removeAclFeature(snapshotId);\n      }\n      newPerm \u003d createFsPermissionForMinimalAcl(newAcl, perm);\n    }\n\n    inode.setPermission(newPerm, snapshotId);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/AclStorage.java",
      "extendedDetails": {}
    },
    "11be7334c4e04b1b3fe12d86f4646cc83c068b05": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-5809. Enhance distcp to support preserving HDFS ACLs. Contributed by Chris Nauroth.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1595283 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/05/14 11:25 AM",
      "commitName": "11be7334c4e04b1b3fe12d86f4646cc83c068b05",
      "commitAuthor": "Chris Nauroth",
      "commitDateOld": "26/02/14 8:22 AM",
      "commitNameOld": "7be2c002b350594e9bfbd256c8abc2cad42d49ea",
      "commitAuthorOld": "Chris Nauroth",
      "daysBetweenCommits": 79.09,
      "commitsBetweenForRepo": 557,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,34 @@\n   public static void updateINodeAcl(INode inode, List\u003cAclEntry\u003e newAcl,\n       int snapshotId) throws AclException, QuotaExceededException {\n     assert newAcl.size() \u003e\u003d 3;\n     FsPermission perm \u003d inode.getFsPermission();\n     final FsPermission newPerm;\n-    if (!isMinimalAcl(newAcl)) {\n+    if (!AclUtil.isMinimalAcl(newAcl)) {\n       // This is an extended ACL.  Split entries into access vs. default.\n       ScopedAclEntries scoped \u003d new ScopedAclEntries(newAcl);\n       List\u003cAclEntry\u003e accessEntries \u003d scoped.getAccessEntries();\n       List\u003cAclEntry\u003e defaultEntries \u003d scoped.getDefaultEntries();\n \n       // Only directories may have a default ACL.\n       if (!defaultEntries.isEmpty() \u0026\u0026 !inode.isDirectory()) {\n         throw new AclException(\n           \"Invalid ACL: only directories may have a default ACL.\");\n       }\n \n       // Attach entries to the feature.\n       if (inode.getAclFeature() !\u003d null) {\n         inode.removeAclFeature(snapshotId);\n       }\n       inode.addAclFeature(createAclFeature(accessEntries, defaultEntries),\n         snapshotId);\n       newPerm \u003d createFsPermissionForExtendedAcl(accessEntries, perm);\n     } else {\n       // This is a minimal ACL.  Remove the ACL feature if it previously had one.\n       if (inode.getAclFeature() !\u003d null) {\n         inode.removeAclFeature(snapshotId);\n       }\n       newPerm \u003d createFsPermissionForMinimalAcl(newAcl, perm);\n     }\n \n     inode.setPermission(newPerm, snapshotId);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void updateINodeAcl(INode inode, List\u003cAclEntry\u003e newAcl,\n      int snapshotId) throws AclException, QuotaExceededException {\n    assert newAcl.size() \u003e\u003d 3;\n    FsPermission perm \u003d inode.getFsPermission();\n    final FsPermission newPerm;\n    if (!AclUtil.isMinimalAcl(newAcl)) {\n      // This is an extended ACL.  Split entries into access vs. default.\n      ScopedAclEntries scoped \u003d new ScopedAclEntries(newAcl);\n      List\u003cAclEntry\u003e accessEntries \u003d scoped.getAccessEntries();\n      List\u003cAclEntry\u003e defaultEntries \u003d scoped.getDefaultEntries();\n\n      // Only directories may have a default ACL.\n      if (!defaultEntries.isEmpty() \u0026\u0026 !inode.isDirectory()) {\n        throw new AclException(\n          \"Invalid ACL: only directories may have a default ACL.\");\n      }\n\n      // Attach entries to the feature.\n      if (inode.getAclFeature() !\u003d null) {\n        inode.removeAclFeature(snapshotId);\n      }\n      inode.addAclFeature(createAclFeature(accessEntries, defaultEntries),\n        snapshotId);\n      newPerm \u003d createFsPermissionForExtendedAcl(accessEntries, perm);\n    } else {\n      // This is a minimal ACL.  Remove the ACL feature if it previously had one.\n      if (inode.getAclFeature() !\u003d null) {\n        inode.removeAclFeature(snapshotId);\n      }\n      newPerm \u003d createFsPermissionForMinimalAcl(newAcl, perm);\n    }\n\n    inode.setPermission(newPerm, snapshotId);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/AclStorage.java",
      "extendedDetails": {}
    },
    "fc14360b0340a33c0e1eb34967d4dcd772533418": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5923. Do not persist the ACL bit in the FsPermission. Contributed by Haohui Mai.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4685@1567784 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/02/14 2:54 PM",
      "commitName": "fc14360b0340a33c0e1eb34967d4dcd772533418",
      "commitAuthor": "Chris Nauroth",
      "commitDateOld": "07/02/14 3:11 PM",
      "commitNameOld": "c89c516b95f45e04af55d9030043a42e2d07b02b",
      "commitAuthorOld": "Chris Nauroth",
      "daysBetweenCommits": 4.99,
      "commitsBetweenForRepo": 23,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,34 @@\n   public static void updateINodeAcl(INode inode, List\u003cAclEntry\u003e newAcl,\n       int snapshotId) throws AclException, QuotaExceededException {\n     assert newAcl.size() \u003e\u003d 3;\n     FsPermission perm \u003d inode.getFsPermission();\n     final FsPermission newPerm;\n     if (!isMinimalAcl(newAcl)) {\n       // This is an extended ACL.  Split entries into access vs. default.\n       ScopedAclEntries scoped \u003d new ScopedAclEntries(newAcl);\n       List\u003cAclEntry\u003e accessEntries \u003d scoped.getAccessEntries();\n       List\u003cAclEntry\u003e defaultEntries \u003d scoped.getDefaultEntries();\n \n       // Only directories may have a default ACL.\n       if (!defaultEntries.isEmpty() \u0026\u0026 !inode.isDirectory()) {\n         throw new AclException(\n           \"Invalid ACL: only directories may have a default ACL.\");\n       }\n \n       // Attach entries to the feature.\n-      if (perm.getAclBit()) {\n+      if (inode.getAclFeature() !\u003d null) {\n         inode.removeAclFeature(snapshotId);\n       }\n       inode.addAclFeature(createAclFeature(accessEntries, defaultEntries),\n         snapshotId);\n       newPerm \u003d createFsPermissionForExtendedAcl(accessEntries, perm);\n     } else {\n       // This is a minimal ACL.  Remove the ACL feature if it previously had one.\n-      if (perm.getAclBit()) {\n+      if (inode.getAclFeature() !\u003d null) {\n         inode.removeAclFeature(snapshotId);\n       }\n       newPerm \u003d createFsPermissionForMinimalAcl(newAcl, perm);\n     }\n \n     inode.setPermission(newPerm, snapshotId);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void updateINodeAcl(INode inode, List\u003cAclEntry\u003e newAcl,\n      int snapshotId) throws AclException, QuotaExceededException {\n    assert newAcl.size() \u003e\u003d 3;\n    FsPermission perm \u003d inode.getFsPermission();\n    final FsPermission newPerm;\n    if (!isMinimalAcl(newAcl)) {\n      // This is an extended ACL.  Split entries into access vs. default.\n      ScopedAclEntries scoped \u003d new ScopedAclEntries(newAcl);\n      List\u003cAclEntry\u003e accessEntries \u003d scoped.getAccessEntries();\n      List\u003cAclEntry\u003e defaultEntries \u003d scoped.getDefaultEntries();\n\n      // Only directories may have a default ACL.\n      if (!defaultEntries.isEmpty() \u0026\u0026 !inode.isDirectory()) {\n        throw new AclException(\n          \"Invalid ACL: only directories may have a default ACL.\");\n      }\n\n      // Attach entries to the feature.\n      if (inode.getAclFeature() !\u003d null) {\n        inode.removeAclFeature(snapshotId);\n      }\n      inode.addAclFeature(createAclFeature(accessEntries, defaultEntries),\n        snapshotId);\n      newPerm \u003d createFsPermissionForExtendedAcl(accessEntries, perm);\n    } else {\n      // This is a minimal ACL.  Remove the ACL feature if it previously had one.\n      if (inode.getAclFeature() !\u003d null) {\n        inode.removeAclFeature(snapshotId);\n      }\n      newPerm \u003d createFsPermissionForMinimalAcl(newAcl, perm);\n    }\n\n    inode.setPermission(newPerm, snapshotId);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/AclStorage.java",
      "extendedDetails": {}
    },
    "c89c516b95f45e04af55d9030043a42e2d07b02b": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5616. NameNode: implement default ACL handling. Contributed by Chris Nauroth.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4685@1565845 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/02/14 3:11 PM",
      "commitName": "c89c516b95f45e04af55d9030043a42e2d07b02b",
      "commitAuthor": "Chris Nauroth",
      "commitDateOld": "31/01/14 2:21 PM",
      "commitNameOld": "14f1f76bf609704d36a1699c05fa85750cefe917",
      "commitAuthorOld": "Chris Nauroth",
      "daysBetweenCommits": 7.03,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,34 @@\n   public static void updateINodeAcl(INode inode, List\u003cAclEntry\u003e newAcl,\n       int snapshotId) throws AclException, QuotaExceededException {\n     assert newAcl.size() \u003e\u003d 3;\n     FsPermission perm \u003d inode.getFsPermission();\n     final FsPermission newPerm;\n-    if (newAcl.size() \u003e 3) {\n+    if (!isMinimalAcl(newAcl)) {\n       // This is an extended ACL.  Split entries into access vs. default.\n       ScopedAclEntries scoped \u003d new ScopedAclEntries(newAcl);\n       List\u003cAclEntry\u003e accessEntries \u003d scoped.getAccessEntries();\n       List\u003cAclEntry\u003e defaultEntries \u003d scoped.getDefaultEntries();\n \n       // Only directories may have a default ACL.\n       if (!defaultEntries.isEmpty() \u0026\u0026 !inode.isDirectory()) {\n         throw new AclException(\n           \"Invalid ACL: only directories may have a default ACL.\");\n       }\n \n-      // Pre-allocate list size for the explicit entries stored in the feature,\n-      // which is all entries minus the 3 entries implicitly stored in the\n-      // permission bits.\n-      List\u003cAclEntry\u003e featureEntries \u003d Lists.newArrayListWithCapacity(\n-        (accessEntries.size() - 3) + defaultEntries.size());\n-\n-      // Calculate new permission bits.  For a correctly sorted ACL, the first\n-      // entry is the owner and the last 2 entries are the mask and other entries\n-      // respectively.  Also preserve sticky bit and toggle ACL bit on.\n-      newPerm \u003d new FsPermission(accessEntries.get(0).getPermission(),\n-        accessEntries.get(accessEntries.size() - 2).getPermission(),\n-        accessEntries.get(accessEntries.size() - 1).getPermission(),\n-        perm.getStickyBit(), true);\n-\n-      // For the access ACL, the feature only needs to hold the named user and\n-      // group entries.  For a correctly sorted ACL, these will be in a\n-      // predictable range.\n-      if (accessEntries.size() \u003e 3) {\n-        featureEntries.addAll(\n-          accessEntries.subList(1, accessEntries.size() - 2));\n-      }\n-\n-      // Add all default entries to the feature.\n-      featureEntries.addAll(defaultEntries);\n-\n       // Attach entries to the feature.\n       if (perm.getAclBit()) {\n         inode.removeAclFeature(snapshotId);\n       }\n-      inode.addAclFeature(new AclFeature(featureEntries), snapshotId);\n+      inode.addAclFeature(createAclFeature(accessEntries, defaultEntries),\n+        snapshotId);\n+      newPerm \u003d createFsPermissionForExtendedAcl(accessEntries, perm);\n     } else {\n       // This is a minimal ACL.  Remove the ACL feature if it previously had one.\n       if (perm.getAclBit()) {\n         inode.removeAclFeature(snapshotId);\n       }\n-\n-      // Calculate new permission bits.  For a correctly sorted ACL, the owner,\n-      // group and other permissions are in order.  Also preserve sticky bit and\n-      // toggle ACL bit off.\n-      newPerm \u003d new FsPermission(newAcl.get(0).getPermission(),\n-        newAcl.get(1).getPermission(),\n-        newAcl.get(2).getPermission(),\n-        perm.getStickyBit(), false);\n+      newPerm \u003d createFsPermissionForMinimalAcl(newAcl, perm);\n     }\n \n     inode.setPermission(newPerm, snapshotId);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void updateINodeAcl(INode inode, List\u003cAclEntry\u003e newAcl,\n      int snapshotId) throws AclException, QuotaExceededException {\n    assert newAcl.size() \u003e\u003d 3;\n    FsPermission perm \u003d inode.getFsPermission();\n    final FsPermission newPerm;\n    if (!isMinimalAcl(newAcl)) {\n      // This is an extended ACL.  Split entries into access vs. default.\n      ScopedAclEntries scoped \u003d new ScopedAclEntries(newAcl);\n      List\u003cAclEntry\u003e accessEntries \u003d scoped.getAccessEntries();\n      List\u003cAclEntry\u003e defaultEntries \u003d scoped.getDefaultEntries();\n\n      // Only directories may have a default ACL.\n      if (!defaultEntries.isEmpty() \u0026\u0026 !inode.isDirectory()) {\n        throw new AclException(\n          \"Invalid ACL: only directories may have a default ACL.\");\n      }\n\n      // Attach entries to the feature.\n      if (perm.getAclBit()) {\n        inode.removeAclFeature(snapshotId);\n      }\n      inode.addAclFeature(createAclFeature(accessEntries, defaultEntries),\n        snapshotId);\n      newPerm \u003d createFsPermissionForExtendedAcl(accessEntries, perm);\n    } else {\n      // This is a minimal ACL.  Remove the ACL feature if it previously had one.\n      if (perm.getAclBit()) {\n        inode.removeAclFeature(snapshotId);\n      }\n      newPerm \u003d createFsPermissionForMinimalAcl(newAcl, perm);\n    }\n\n    inode.setPermission(newPerm, snapshotId);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/AclStorage.java",
      "extendedDetails": {}
    },
    "14f1f76bf609704d36a1699c05fa85750cefe917": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-5614. NameNode: implement handling of ACLs in combination with snapshots. Contributed by Chris Nauroth.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4685@1563304 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "31/01/14 2:21 PM",
      "commitName": "14f1f76bf609704d36a1699c05fa85750cefe917",
      "commitAuthor": "Chris Nauroth",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-5614. NameNode: implement handling of ACLs in combination with snapshots. Contributed by Chris Nauroth.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4685@1563304 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "31/01/14 2:21 PM",
          "commitName": "14f1f76bf609704d36a1699c05fa85750cefe917",
          "commitAuthor": "Chris Nauroth",
          "commitDateOld": "31/01/14 10:33 AM",
          "commitNameOld": "c654c2e8b9af0a26deeb5a755710fd9ebe8cbf6d",
          "commitAuthorOld": "Chris Nauroth",
          "daysBetweenCommits": 0.16,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,67 +1,64 @@\n-  public static void updateINodeAcl(INodeWithAdditionalFields inode,\n-      List\u003cAclEntry\u003e newAcl, int snapshotId) throws AclException,\n-      QuotaExceededException {\n+  public static void updateINodeAcl(INode inode, List\u003cAclEntry\u003e newAcl,\n+      int snapshotId) throws AclException, QuotaExceededException {\n     assert newAcl.size() \u003e\u003d 3;\n-    FsPermission perm \u003d inode.getPermissionStatus(snapshotId).getPermission();\n+    FsPermission perm \u003d inode.getFsPermission();\n     final FsPermission newPerm;\n     if (newAcl.size() \u003e 3) {\n       // This is an extended ACL.  Split entries into access vs. default.\n       ScopedAclEntries scoped \u003d new ScopedAclEntries(newAcl);\n       List\u003cAclEntry\u003e accessEntries \u003d scoped.getAccessEntries();\n       List\u003cAclEntry\u003e defaultEntries \u003d scoped.getDefaultEntries();\n \n       // Only directories may have a default ACL.\n       if (!defaultEntries.isEmpty() \u0026\u0026 !inode.isDirectory()) {\n         throw new AclException(\n           \"Invalid ACL: only directories may have a default ACL.\");\n       }\n \n       // Pre-allocate list size for the explicit entries stored in the feature,\n       // which is all entries minus the 3 entries implicitly stored in the\n       // permission bits.\n       List\u003cAclEntry\u003e featureEntries \u003d Lists.newArrayListWithCapacity(\n         (accessEntries.size() - 3) + defaultEntries.size());\n \n       // Calculate new permission bits.  For a correctly sorted ACL, the first\n       // entry is the owner and the last 2 entries are the mask and other entries\n       // respectively.  Also preserve sticky bit and toggle ACL bit on.\n       newPerm \u003d new FsPermission(accessEntries.get(0).getPermission(),\n         accessEntries.get(accessEntries.size() - 2).getPermission(),\n         accessEntries.get(accessEntries.size() - 1).getPermission(),\n         perm.getStickyBit(), true);\n \n       // For the access ACL, the feature only needs to hold the named user and\n       // group entries.  For a correctly sorted ACL, these will be in a\n       // predictable range.\n       if (accessEntries.size() \u003e 3) {\n         featureEntries.addAll(\n           accessEntries.subList(1, accessEntries.size() - 2));\n       }\n \n       // Add all default entries to the feature.\n       featureEntries.addAll(defaultEntries);\n \n-      // Attach entries to the feature, creating a new feature if needed.\n-      AclFeature aclFeature \u003d inode.getAclFeature();\n-      if (aclFeature \u003d\u003d null) {\n-        aclFeature \u003d new AclFeature();\n-        inode.addAclFeature(aclFeature);\n+      // Attach entries to the feature.\n+      if (perm.getAclBit()) {\n+        inode.removeAclFeature(snapshotId);\n       }\n-      aclFeature.setEntries(featureEntries);\n+      inode.addAclFeature(new AclFeature(featureEntries), snapshotId);\n     } else {\n       // This is a minimal ACL.  Remove the ACL feature if it previously had one.\n       if (perm.getAclBit()) {\n-        inode.removeAclFeature();\n+        inode.removeAclFeature(snapshotId);\n       }\n \n       // Calculate new permission bits.  For a correctly sorted ACL, the owner,\n       // group and other permissions are in order.  Also preserve sticky bit and\n       // toggle ACL bit off.\n       newPerm \u003d new FsPermission(newAcl.get(0).getPermission(),\n         newAcl.get(1).getPermission(),\n         newAcl.get(2).getPermission(),\n         perm.getStickyBit(), false);\n     }\n \n     inode.setPermission(newPerm, snapshotId);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static void updateINodeAcl(INode inode, List\u003cAclEntry\u003e newAcl,\n      int snapshotId) throws AclException, QuotaExceededException {\n    assert newAcl.size() \u003e\u003d 3;\n    FsPermission perm \u003d inode.getFsPermission();\n    final FsPermission newPerm;\n    if (newAcl.size() \u003e 3) {\n      // This is an extended ACL.  Split entries into access vs. default.\n      ScopedAclEntries scoped \u003d new ScopedAclEntries(newAcl);\n      List\u003cAclEntry\u003e accessEntries \u003d scoped.getAccessEntries();\n      List\u003cAclEntry\u003e defaultEntries \u003d scoped.getDefaultEntries();\n\n      // Only directories may have a default ACL.\n      if (!defaultEntries.isEmpty() \u0026\u0026 !inode.isDirectory()) {\n        throw new AclException(\n          \"Invalid ACL: only directories may have a default ACL.\");\n      }\n\n      // Pre-allocate list size for the explicit entries stored in the feature,\n      // which is all entries minus the 3 entries implicitly stored in the\n      // permission bits.\n      List\u003cAclEntry\u003e featureEntries \u003d Lists.newArrayListWithCapacity(\n        (accessEntries.size() - 3) + defaultEntries.size());\n\n      // Calculate new permission bits.  For a correctly sorted ACL, the first\n      // entry is the owner and the last 2 entries are the mask and other entries\n      // respectively.  Also preserve sticky bit and toggle ACL bit on.\n      newPerm \u003d new FsPermission(accessEntries.get(0).getPermission(),\n        accessEntries.get(accessEntries.size() - 2).getPermission(),\n        accessEntries.get(accessEntries.size() - 1).getPermission(),\n        perm.getStickyBit(), true);\n\n      // For the access ACL, the feature only needs to hold the named user and\n      // group entries.  For a correctly sorted ACL, these will be in a\n      // predictable range.\n      if (accessEntries.size() \u003e 3) {\n        featureEntries.addAll(\n          accessEntries.subList(1, accessEntries.size() - 2));\n      }\n\n      // Add all default entries to the feature.\n      featureEntries.addAll(defaultEntries);\n\n      // Attach entries to the feature.\n      if (perm.getAclBit()) {\n        inode.removeAclFeature(snapshotId);\n      }\n      inode.addAclFeature(new AclFeature(featureEntries), snapshotId);\n    } else {\n      // This is a minimal ACL.  Remove the ACL feature if it previously had one.\n      if (perm.getAclBit()) {\n        inode.removeAclFeature(snapshotId);\n      }\n\n      // Calculate new permission bits.  For a correctly sorted ACL, the owner,\n      // group and other permissions are in order.  Also preserve sticky bit and\n      // toggle ACL bit off.\n      newPerm \u003d new FsPermission(newAcl.get(0).getPermission(),\n        newAcl.get(1).getPermission(),\n        newAcl.get(2).getPermission(),\n        perm.getStickyBit(), false);\n    }\n\n    inode.setPermission(newPerm, snapshotId);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/AclStorage.java",
          "extendedDetails": {
            "oldValue": "[inode-INodeWithAdditionalFields, newAcl-List\u003cAclEntry\u003e, snapshotId-int]",
            "newValue": "[inode-INode, newAcl-List\u003cAclEntry\u003e, snapshotId-int]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-5614. NameNode: implement handling of ACLs in combination with snapshots. Contributed by Chris Nauroth.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4685@1563304 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "31/01/14 2:21 PM",
          "commitName": "14f1f76bf609704d36a1699c05fa85750cefe917",
          "commitAuthor": "Chris Nauroth",
          "commitDateOld": "31/01/14 10:33 AM",
          "commitNameOld": "c654c2e8b9af0a26deeb5a755710fd9ebe8cbf6d",
          "commitAuthorOld": "Chris Nauroth",
          "daysBetweenCommits": 0.16,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,67 +1,64 @@\n-  public static void updateINodeAcl(INodeWithAdditionalFields inode,\n-      List\u003cAclEntry\u003e newAcl, int snapshotId) throws AclException,\n-      QuotaExceededException {\n+  public static void updateINodeAcl(INode inode, List\u003cAclEntry\u003e newAcl,\n+      int snapshotId) throws AclException, QuotaExceededException {\n     assert newAcl.size() \u003e\u003d 3;\n-    FsPermission perm \u003d inode.getPermissionStatus(snapshotId).getPermission();\n+    FsPermission perm \u003d inode.getFsPermission();\n     final FsPermission newPerm;\n     if (newAcl.size() \u003e 3) {\n       // This is an extended ACL.  Split entries into access vs. default.\n       ScopedAclEntries scoped \u003d new ScopedAclEntries(newAcl);\n       List\u003cAclEntry\u003e accessEntries \u003d scoped.getAccessEntries();\n       List\u003cAclEntry\u003e defaultEntries \u003d scoped.getDefaultEntries();\n \n       // Only directories may have a default ACL.\n       if (!defaultEntries.isEmpty() \u0026\u0026 !inode.isDirectory()) {\n         throw new AclException(\n           \"Invalid ACL: only directories may have a default ACL.\");\n       }\n \n       // Pre-allocate list size for the explicit entries stored in the feature,\n       // which is all entries minus the 3 entries implicitly stored in the\n       // permission bits.\n       List\u003cAclEntry\u003e featureEntries \u003d Lists.newArrayListWithCapacity(\n         (accessEntries.size() - 3) + defaultEntries.size());\n \n       // Calculate new permission bits.  For a correctly sorted ACL, the first\n       // entry is the owner and the last 2 entries are the mask and other entries\n       // respectively.  Also preserve sticky bit and toggle ACL bit on.\n       newPerm \u003d new FsPermission(accessEntries.get(0).getPermission(),\n         accessEntries.get(accessEntries.size() - 2).getPermission(),\n         accessEntries.get(accessEntries.size() - 1).getPermission(),\n         perm.getStickyBit(), true);\n \n       // For the access ACL, the feature only needs to hold the named user and\n       // group entries.  For a correctly sorted ACL, these will be in a\n       // predictable range.\n       if (accessEntries.size() \u003e 3) {\n         featureEntries.addAll(\n           accessEntries.subList(1, accessEntries.size() - 2));\n       }\n \n       // Add all default entries to the feature.\n       featureEntries.addAll(defaultEntries);\n \n-      // Attach entries to the feature, creating a new feature if needed.\n-      AclFeature aclFeature \u003d inode.getAclFeature();\n-      if (aclFeature \u003d\u003d null) {\n-        aclFeature \u003d new AclFeature();\n-        inode.addAclFeature(aclFeature);\n+      // Attach entries to the feature.\n+      if (perm.getAclBit()) {\n+        inode.removeAclFeature(snapshotId);\n       }\n-      aclFeature.setEntries(featureEntries);\n+      inode.addAclFeature(new AclFeature(featureEntries), snapshotId);\n     } else {\n       // This is a minimal ACL.  Remove the ACL feature if it previously had one.\n       if (perm.getAclBit()) {\n-        inode.removeAclFeature();\n+        inode.removeAclFeature(snapshotId);\n       }\n \n       // Calculate new permission bits.  For a correctly sorted ACL, the owner,\n       // group and other permissions are in order.  Also preserve sticky bit and\n       // toggle ACL bit off.\n       newPerm \u003d new FsPermission(newAcl.get(0).getPermission(),\n         newAcl.get(1).getPermission(),\n         newAcl.get(2).getPermission(),\n         perm.getStickyBit(), false);\n     }\n \n     inode.setPermission(newPerm, snapshotId);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static void updateINodeAcl(INode inode, List\u003cAclEntry\u003e newAcl,\n      int snapshotId) throws AclException, QuotaExceededException {\n    assert newAcl.size() \u003e\u003d 3;\n    FsPermission perm \u003d inode.getFsPermission();\n    final FsPermission newPerm;\n    if (newAcl.size() \u003e 3) {\n      // This is an extended ACL.  Split entries into access vs. default.\n      ScopedAclEntries scoped \u003d new ScopedAclEntries(newAcl);\n      List\u003cAclEntry\u003e accessEntries \u003d scoped.getAccessEntries();\n      List\u003cAclEntry\u003e defaultEntries \u003d scoped.getDefaultEntries();\n\n      // Only directories may have a default ACL.\n      if (!defaultEntries.isEmpty() \u0026\u0026 !inode.isDirectory()) {\n        throw new AclException(\n          \"Invalid ACL: only directories may have a default ACL.\");\n      }\n\n      // Pre-allocate list size for the explicit entries stored in the feature,\n      // which is all entries minus the 3 entries implicitly stored in the\n      // permission bits.\n      List\u003cAclEntry\u003e featureEntries \u003d Lists.newArrayListWithCapacity(\n        (accessEntries.size() - 3) + defaultEntries.size());\n\n      // Calculate new permission bits.  For a correctly sorted ACL, the first\n      // entry is the owner and the last 2 entries are the mask and other entries\n      // respectively.  Also preserve sticky bit and toggle ACL bit on.\n      newPerm \u003d new FsPermission(accessEntries.get(0).getPermission(),\n        accessEntries.get(accessEntries.size() - 2).getPermission(),\n        accessEntries.get(accessEntries.size() - 1).getPermission(),\n        perm.getStickyBit(), true);\n\n      // For the access ACL, the feature only needs to hold the named user and\n      // group entries.  For a correctly sorted ACL, these will be in a\n      // predictable range.\n      if (accessEntries.size() \u003e 3) {\n        featureEntries.addAll(\n          accessEntries.subList(1, accessEntries.size() - 2));\n      }\n\n      // Add all default entries to the feature.\n      featureEntries.addAll(defaultEntries);\n\n      // Attach entries to the feature.\n      if (perm.getAclBit()) {\n        inode.removeAclFeature(snapshotId);\n      }\n      inode.addAclFeature(new AclFeature(featureEntries), snapshotId);\n    } else {\n      // This is a minimal ACL.  Remove the ACL feature if it previously had one.\n      if (perm.getAclBit()) {\n        inode.removeAclFeature(snapshotId);\n      }\n\n      // Calculate new permission bits.  For a correctly sorted ACL, the owner,\n      // group and other permissions are in order.  Also preserve sticky bit and\n      // toggle ACL bit off.\n      newPerm \u003d new FsPermission(newAcl.get(0).getPermission(),\n        newAcl.get(1).getPermission(),\n        newAcl.get(2).getPermission(),\n        perm.getStickyBit(), false);\n    }\n\n    inode.setPermission(newPerm, snapshotId);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/AclStorage.java",
          "extendedDetails": {}
        }
      ]
    },
    "5300294fbe9e235ce42253d6bcd69d8154d8f198": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-5758. NameNode: complete implementation of inode modifications for ACLs. Contributed by Chris Nauroth.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4685@1559267 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/01/14 2:05 PM",
      "commitName": "5300294fbe9e235ce42253d6bcd69d8154d8f198",
      "commitAuthor": "Haohui Mai",
      "diff": "@@ -0,0 +1,67 @@\n+  public static void updateINodeAcl(INodeWithAdditionalFields inode,\n+      List\u003cAclEntry\u003e newAcl, int snapshotId) throws AclException,\n+      QuotaExceededException {\n+    assert newAcl.size() \u003e\u003d 3;\n+    FsPermission perm \u003d inode.getPermissionStatus(snapshotId).getPermission();\n+    final FsPermission newPerm;\n+    if (newAcl.size() \u003e 3) {\n+      // This is an extended ACL.  Split entries into access vs. default.\n+      ScopedAclEntries scoped \u003d new ScopedAclEntries(newAcl);\n+      List\u003cAclEntry\u003e accessEntries \u003d scoped.getAccessEntries();\n+      List\u003cAclEntry\u003e defaultEntries \u003d scoped.getDefaultEntries();\n+\n+      // Only directories may have a default ACL.\n+      if (!defaultEntries.isEmpty() \u0026\u0026 !inode.isDirectory()) {\n+        throw new AclException(\n+          \"Invalid ACL: only directories may have a default ACL.\");\n+      }\n+\n+      // Pre-allocate list size for the explicit entries stored in the feature,\n+      // which is all entries minus the 3 entries implicitly stored in the\n+      // permission bits.\n+      List\u003cAclEntry\u003e featureEntries \u003d Lists.newArrayListWithCapacity(\n+        (accessEntries.size() - 3) + defaultEntries.size());\n+\n+      // Calculate new permission bits.  For a correctly sorted ACL, the first\n+      // entry is the owner and the last 2 entries are the mask and other entries\n+      // respectively.  Also preserve sticky bit and toggle ACL bit on.\n+      newPerm \u003d new FsPermission(accessEntries.get(0).getPermission(),\n+        accessEntries.get(accessEntries.size() - 2).getPermission(),\n+        accessEntries.get(accessEntries.size() - 1).getPermission(),\n+        perm.getStickyBit(), true);\n+\n+      // For the access ACL, the feature only needs to hold the named user and\n+      // group entries.  For a correctly sorted ACL, these will be in a\n+      // predictable range.\n+      if (accessEntries.size() \u003e 3) {\n+        featureEntries.addAll(\n+          accessEntries.subList(1, accessEntries.size() - 2));\n+      }\n+\n+      // Add all default entries to the feature.\n+      featureEntries.addAll(defaultEntries);\n+\n+      // Attach entries to the feature, creating a new feature if needed.\n+      AclFeature aclFeature \u003d inode.getAclFeature();\n+      if (aclFeature \u003d\u003d null) {\n+        aclFeature \u003d new AclFeature();\n+        inode.addAclFeature(aclFeature);\n+      }\n+      aclFeature.setEntries(featureEntries);\n+    } else {\n+      // This is a minimal ACL.  Remove the ACL feature if it previously had one.\n+      if (perm.getAclBit()) {\n+        inode.removeAclFeature();\n+      }\n+\n+      // Calculate new permission bits.  For a correctly sorted ACL, the owner,\n+      // group and other permissions are in order.  Also preserve sticky bit and\n+      // toggle ACL bit off.\n+      newPerm \u003d new FsPermission(newAcl.get(0).getPermission(),\n+        newAcl.get(1).getPermission(),\n+        newAcl.get(2).getPermission(),\n+        perm.getStickyBit(), false);\n+    }\n+\n+    inode.setPermission(newPerm, snapshotId);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public static void updateINodeAcl(INodeWithAdditionalFields inode,\n      List\u003cAclEntry\u003e newAcl, int snapshotId) throws AclException,\n      QuotaExceededException {\n    assert newAcl.size() \u003e\u003d 3;\n    FsPermission perm \u003d inode.getPermissionStatus(snapshotId).getPermission();\n    final FsPermission newPerm;\n    if (newAcl.size() \u003e 3) {\n      // This is an extended ACL.  Split entries into access vs. default.\n      ScopedAclEntries scoped \u003d new ScopedAclEntries(newAcl);\n      List\u003cAclEntry\u003e accessEntries \u003d scoped.getAccessEntries();\n      List\u003cAclEntry\u003e defaultEntries \u003d scoped.getDefaultEntries();\n\n      // Only directories may have a default ACL.\n      if (!defaultEntries.isEmpty() \u0026\u0026 !inode.isDirectory()) {\n        throw new AclException(\n          \"Invalid ACL: only directories may have a default ACL.\");\n      }\n\n      // Pre-allocate list size for the explicit entries stored in the feature,\n      // which is all entries minus the 3 entries implicitly stored in the\n      // permission bits.\n      List\u003cAclEntry\u003e featureEntries \u003d Lists.newArrayListWithCapacity(\n        (accessEntries.size() - 3) + defaultEntries.size());\n\n      // Calculate new permission bits.  For a correctly sorted ACL, the first\n      // entry is the owner and the last 2 entries are the mask and other entries\n      // respectively.  Also preserve sticky bit and toggle ACL bit on.\n      newPerm \u003d new FsPermission(accessEntries.get(0).getPermission(),\n        accessEntries.get(accessEntries.size() - 2).getPermission(),\n        accessEntries.get(accessEntries.size() - 1).getPermission(),\n        perm.getStickyBit(), true);\n\n      // For the access ACL, the feature only needs to hold the named user and\n      // group entries.  For a correctly sorted ACL, these will be in a\n      // predictable range.\n      if (accessEntries.size() \u003e 3) {\n        featureEntries.addAll(\n          accessEntries.subList(1, accessEntries.size() - 2));\n      }\n\n      // Add all default entries to the feature.\n      featureEntries.addAll(defaultEntries);\n\n      // Attach entries to the feature, creating a new feature if needed.\n      AclFeature aclFeature \u003d inode.getAclFeature();\n      if (aclFeature \u003d\u003d null) {\n        aclFeature \u003d new AclFeature();\n        inode.addAclFeature(aclFeature);\n      }\n      aclFeature.setEntries(featureEntries);\n    } else {\n      // This is a minimal ACL.  Remove the ACL feature if it previously had one.\n      if (perm.getAclBit()) {\n        inode.removeAclFeature();\n      }\n\n      // Calculate new permission bits.  For a correctly sorted ACL, the owner,\n      // group and other permissions are in order.  Also preserve sticky bit and\n      // toggle ACL bit off.\n      newPerm \u003d new FsPermission(newAcl.get(0).getPermission(),\n        newAcl.get(1).getPermission(),\n        newAcl.get(2).getPermission(),\n        perm.getStickyBit(), false);\n    }\n\n    inode.setPermission(newPerm, snapshotId);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/AclStorage.java"
    }
  }
}