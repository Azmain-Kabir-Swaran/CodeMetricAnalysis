{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "INodeDirectory.java",
  "functionName": "computeDirectoryContentSummary",
  "functionId": "computeDirectoryContentSummary___summary-ContentSummaryComputationContext__snapshotId-int",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/INodeDirectory.java",
  "functionStartLine": 708,
  "functionEndLine": 746,
  "numCommitsSeen": 241,
  "timeTaken": 7139,
  "changeHistory": [
    "f413ee33df301659c4ca9024380c2354983dcc84",
    "a1f12bb543778ddc243205eaa962e99da4d8f135",
    "a29fe100b3c671954b759add5923a2b44af9e6a4",
    "3f4275310203de4ccfb15337f3c503e25408a265",
    "4014ce5990bff9b0ecb3d38a633d40eaf6cf07a7",
    "3d0708bdb0a75af3d87bbac9f6c4ffbcabab98ca",
    "28051e415591b8e33dbe954f65230ede23b11683",
    "70cff9e2f0c8f78c1dc54a064182971bb2106795",
    "82ff2d3f2e569879500d851f4d67dfa2d02b5c9b"
  ],
  "changeHistoryShort": {
    "f413ee33df301659c4ca9024380c2354983dcc84": "Ymultichange(Yexceptionschange,Ybodychange)",
    "a1f12bb543778ddc243205eaa962e99da4d8f135": "Ymultichange(Yexceptionschange,Ybodychange)",
    "a29fe100b3c671954b759add5923a2b44af9e6a4": "Ymultichange(Yexceptionschange,Ybodychange)",
    "3f4275310203de4ccfb15337f3c503e25408a265": "Ybodychange",
    "4014ce5990bff9b0ecb3d38a633d40eaf6cf07a7": "Ybodychange",
    "3d0708bdb0a75af3d87bbac9f6c4ffbcabab98ca": "Ybodychange",
    "28051e415591b8e33dbe954f65230ede23b11683": "Ymultichange(Yparameterchange,Ymodifierchange,Ybodychange)",
    "70cff9e2f0c8f78c1dc54a064182971bb2106795": "Ybodychange",
    "82ff2d3f2e569879500d851f4d67dfa2d02b5c9b": "Yintroduced"
  },
  "changeHistoryDetails": {
    "f413ee33df301659c4ca9024380c2354983dcc84": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "HDFS-12130. Optimizing permission check for getContentSummary.  Contributed by  Chen Liang\n",
      "commitDate": "14/07/17 2:35 PM",
      "commitName": "f413ee33df301659c4ca9024380c2354983dcc84",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "HDFS-12130. Optimizing permission check for getContentSummary.  Contributed by  Chen Liang\n",
          "commitDate": "14/07/17 2:35 PM",
          "commitName": "f413ee33df301659c4ca9024380c2354983dcc84",
          "commitAuthor": "Tsz-Wo Nicholas Sze",
          "commitDateOld": "14/07/17 2:34 PM",
          "commitNameOld": "a1f12bb543778ddc243205eaa962e99da4d8f135",
          "commitAuthorOld": "Tsz-Wo Nicholas Sze",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,36 +1,39 @@\n   protected ContentSummaryComputationContext computeDirectoryContentSummary(\n-      ContentSummaryComputationContext summary, int snapshotId) {\n+      ContentSummaryComputationContext summary, int snapshotId)\n+      throws AccessControlException{\n+    // throws exception if failing the permission check\n+    summary.checkPermission(this, snapshotId, FsAction.READ_EXECUTE);\n     ReadOnlyList\u003cINode\u003e childrenList \u003d getChildrenList(snapshotId);\n     // Explicit traversing is done to enable repositioning after relinquishing\n     // and reacquiring locks.\n     for (int i \u003d 0;  i \u003c childrenList.size(); i++) {\n       INode child \u003d childrenList.get(i);\n       byte[] childName \u003d child.getLocalNameBytes();\n \n       long lastYieldCount \u003d summary.getYieldCount();\n       child.computeContentSummary(snapshotId, summary);\n \n       // Check whether the computation was paused in the subtree.\n       // The counts may be off, but traversing the rest of children\n       // should be made safe.\n       if (lastYieldCount \u003d\u003d summary.getYieldCount()) {\n         continue;\n       }\n       // The locks were released and reacquired. Check parent first.\n       if (!isRoot() \u0026\u0026 getParent() \u003d\u003d null) {\n         // Stop further counting and return whatever we have so far.\n         break;\n       }\n       // Obtain the children list again since it may have been modified.\n       childrenList \u003d getChildrenList(snapshotId);\n       // Reposition in case the children list is changed. Decrement by 1\n       // since it will be incremented when loops.\n       i \u003d nextChild(childrenList, childName) - 1;\n     }\n \n     // Increment the directory count for this directory.\n     summary.getCounts().addContent(Content.DIRECTORY, 1);\n     // Relinquish and reacquire locks if necessary.\n     summary.yield();\n     return summary;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected ContentSummaryComputationContext computeDirectoryContentSummary(\n      ContentSummaryComputationContext summary, int snapshotId)\n      throws AccessControlException{\n    // throws exception if failing the permission check\n    summary.checkPermission(this, snapshotId, FsAction.READ_EXECUTE);\n    ReadOnlyList\u003cINode\u003e childrenList \u003d getChildrenList(snapshotId);\n    // Explicit traversing is done to enable repositioning after relinquishing\n    // and reacquiring locks.\n    for (int i \u003d 0;  i \u003c childrenList.size(); i++) {\n      INode child \u003d childrenList.get(i);\n      byte[] childName \u003d child.getLocalNameBytes();\n\n      long lastYieldCount \u003d summary.getYieldCount();\n      child.computeContentSummary(snapshotId, summary);\n\n      // Check whether the computation was paused in the subtree.\n      // The counts may be off, but traversing the rest of children\n      // should be made safe.\n      if (lastYieldCount \u003d\u003d summary.getYieldCount()) {\n        continue;\n      }\n      // The locks were released and reacquired. Check parent first.\n      if (!isRoot() \u0026\u0026 getParent() \u003d\u003d null) {\n        // Stop further counting and return whatever we have so far.\n        break;\n      }\n      // Obtain the children list again since it may have been modified.\n      childrenList \u003d getChildrenList(snapshotId);\n      // Reposition in case the children list is changed. Decrement by 1\n      // since it will be incremented when loops.\n      i \u003d nextChild(childrenList, childName) - 1;\n    }\n\n    // Increment the directory count for this directory.\n    summary.getCounts().addContent(Content.DIRECTORY, 1);\n    // Relinquish and reacquire locks if necessary.\n    summary.yield();\n    return summary;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/INodeDirectory.java",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[AccessControlException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-12130. Optimizing permission check for getContentSummary.  Contributed by  Chen Liang\n",
          "commitDate": "14/07/17 2:35 PM",
          "commitName": "f413ee33df301659c4ca9024380c2354983dcc84",
          "commitAuthor": "Tsz-Wo Nicholas Sze",
          "commitDateOld": "14/07/17 2:34 PM",
          "commitNameOld": "a1f12bb543778ddc243205eaa962e99da4d8f135",
          "commitAuthorOld": "Tsz-Wo Nicholas Sze",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,36 +1,39 @@\n   protected ContentSummaryComputationContext computeDirectoryContentSummary(\n-      ContentSummaryComputationContext summary, int snapshotId) {\n+      ContentSummaryComputationContext summary, int snapshotId)\n+      throws AccessControlException{\n+    // throws exception if failing the permission check\n+    summary.checkPermission(this, snapshotId, FsAction.READ_EXECUTE);\n     ReadOnlyList\u003cINode\u003e childrenList \u003d getChildrenList(snapshotId);\n     // Explicit traversing is done to enable repositioning after relinquishing\n     // and reacquiring locks.\n     for (int i \u003d 0;  i \u003c childrenList.size(); i++) {\n       INode child \u003d childrenList.get(i);\n       byte[] childName \u003d child.getLocalNameBytes();\n \n       long lastYieldCount \u003d summary.getYieldCount();\n       child.computeContentSummary(snapshotId, summary);\n \n       // Check whether the computation was paused in the subtree.\n       // The counts may be off, but traversing the rest of children\n       // should be made safe.\n       if (lastYieldCount \u003d\u003d summary.getYieldCount()) {\n         continue;\n       }\n       // The locks were released and reacquired. Check parent first.\n       if (!isRoot() \u0026\u0026 getParent() \u003d\u003d null) {\n         // Stop further counting and return whatever we have so far.\n         break;\n       }\n       // Obtain the children list again since it may have been modified.\n       childrenList \u003d getChildrenList(snapshotId);\n       // Reposition in case the children list is changed. Decrement by 1\n       // since it will be incremented when loops.\n       i \u003d nextChild(childrenList, childName) - 1;\n     }\n \n     // Increment the directory count for this directory.\n     summary.getCounts().addContent(Content.DIRECTORY, 1);\n     // Relinquish and reacquire locks if necessary.\n     summary.yield();\n     return summary;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected ContentSummaryComputationContext computeDirectoryContentSummary(\n      ContentSummaryComputationContext summary, int snapshotId)\n      throws AccessControlException{\n    // throws exception if failing the permission check\n    summary.checkPermission(this, snapshotId, FsAction.READ_EXECUTE);\n    ReadOnlyList\u003cINode\u003e childrenList \u003d getChildrenList(snapshotId);\n    // Explicit traversing is done to enable repositioning after relinquishing\n    // and reacquiring locks.\n    for (int i \u003d 0;  i \u003c childrenList.size(); i++) {\n      INode child \u003d childrenList.get(i);\n      byte[] childName \u003d child.getLocalNameBytes();\n\n      long lastYieldCount \u003d summary.getYieldCount();\n      child.computeContentSummary(snapshotId, summary);\n\n      // Check whether the computation was paused in the subtree.\n      // The counts may be off, but traversing the rest of children\n      // should be made safe.\n      if (lastYieldCount \u003d\u003d summary.getYieldCount()) {\n        continue;\n      }\n      // The locks were released and reacquired. Check parent first.\n      if (!isRoot() \u0026\u0026 getParent() \u003d\u003d null) {\n        // Stop further counting and return whatever we have so far.\n        break;\n      }\n      // Obtain the children list again since it may have been modified.\n      childrenList \u003d getChildrenList(snapshotId);\n      // Reposition in case the children list is changed. Decrement by 1\n      // since it will be incremented when loops.\n      i \u003d nextChild(childrenList, childName) - 1;\n    }\n\n    // Increment the directory count for this directory.\n    summary.getCounts().addContent(Content.DIRECTORY, 1);\n    // Relinquish and reacquire locks if necessary.\n    summary.yield();\n    return summary;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/INodeDirectory.java",
          "extendedDetails": {}
        }
      ]
    },
    "a1f12bb543778ddc243205eaa962e99da4d8f135": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "Revert \"HDFS-12130. Optimizing permission check for getContentSummary.\" to fix commit message.\n\nThis reverts commit a29fe100b3c671954b759add5923a2b44af9e6a4.\n",
      "commitDate": "14/07/17 2:34 PM",
      "commitName": "a1f12bb543778ddc243205eaa962e99da4d8f135",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "Revert \"HDFS-12130. Optimizing permission check for getContentSummary.\" to fix commit message.\n\nThis reverts commit a29fe100b3c671954b759add5923a2b44af9e6a4.\n",
          "commitDate": "14/07/17 2:34 PM",
          "commitName": "a1f12bb543778ddc243205eaa962e99da4d8f135",
          "commitAuthor": "Tsz-Wo Nicholas Sze",
          "commitDateOld": "14/07/17 1:36 PM",
          "commitNameOld": "a29fe100b3c671954b759add5923a2b44af9e6a4",
          "commitAuthorOld": "Tsz-Wo Nicholas Sze",
          "daysBetweenCommits": 0.04,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,39 +1,36 @@\n   protected ContentSummaryComputationContext computeDirectoryContentSummary(\n-      ContentSummaryComputationContext summary, int snapshotId)\n-      throws AccessControlException{\n-    // throws exception if failing the permission check\n-    summary.checkPermission(this, snapshotId, FsAction.READ_EXECUTE);\n+      ContentSummaryComputationContext summary, int snapshotId) {\n     ReadOnlyList\u003cINode\u003e childrenList \u003d getChildrenList(snapshotId);\n     // Explicit traversing is done to enable repositioning after relinquishing\n     // and reacquiring locks.\n     for (int i \u003d 0;  i \u003c childrenList.size(); i++) {\n       INode child \u003d childrenList.get(i);\n       byte[] childName \u003d child.getLocalNameBytes();\n \n       long lastYieldCount \u003d summary.getYieldCount();\n       child.computeContentSummary(snapshotId, summary);\n \n       // Check whether the computation was paused in the subtree.\n       // The counts may be off, but traversing the rest of children\n       // should be made safe.\n       if (lastYieldCount \u003d\u003d summary.getYieldCount()) {\n         continue;\n       }\n       // The locks were released and reacquired. Check parent first.\n       if (!isRoot() \u0026\u0026 getParent() \u003d\u003d null) {\n         // Stop further counting and return whatever we have so far.\n         break;\n       }\n       // Obtain the children list again since it may have been modified.\n       childrenList \u003d getChildrenList(snapshotId);\n       // Reposition in case the children list is changed. Decrement by 1\n       // since it will be incremented when loops.\n       i \u003d nextChild(childrenList, childName) - 1;\n     }\n \n     // Increment the directory count for this directory.\n     summary.getCounts().addContent(Content.DIRECTORY, 1);\n     // Relinquish and reacquire locks if necessary.\n     summary.yield();\n     return summary;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected ContentSummaryComputationContext computeDirectoryContentSummary(\n      ContentSummaryComputationContext summary, int snapshotId) {\n    ReadOnlyList\u003cINode\u003e childrenList \u003d getChildrenList(snapshotId);\n    // Explicit traversing is done to enable repositioning after relinquishing\n    // and reacquiring locks.\n    for (int i \u003d 0;  i \u003c childrenList.size(); i++) {\n      INode child \u003d childrenList.get(i);\n      byte[] childName \u003d child.getLocalNameBytes();\n\n      long lastYieldCount \u003d summary.getYieldCount();\n      child.computeContentSummary(snapshotId, summary);\n\n      // Check whether the computation was paused in the subtree.\n      // The counts may be off, but traversing the rest of children\n      // should be made safe.\n      if (lastYieldCount \u003d\u003d summary.getYieldCount()) {\n        continue;\n      }\n      // The locks were released and reacquired. Check parent first.\n      if (!isRoot() \u0026\u0026 getParent() \u003d\u003d null) {\n        // Stop further counting and return whatever we have so far.\n        break;\n      }\n      // Obtain the children list again since it may have been modified.\n      childrenList \u003d getChildrenList(snapshotId);\n      // Reposition in case the children list is changed. Decrement by 1\n      // since it will be incremented when loops.\n      i \u003d nextChild(childrenList, childName) - 1;\n    }\n\n    // Increment the directory count for this directory.\n    summary.getCounts().addContent(Content.DIRECTORY, 1);\n    // Relinquish and reacquire locks if necessary.\n    summary.yield();\n    return summary;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/INodeDirectory.java",
          "extendedDetails": {
            "oldValue": "[AccessControlException]",
            "newValue": "[]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "Revert \"HDFS-12130. Optimizing permission check for getContentSummary.\" to fix commit message.\n\nThis reverts commit a29fe100b3c671954b759add5923a2b44af9e6a4.\n",
          "commitDate": "14/07/17 2:34 PM",
          "commitName": "a1f12bb543778ddc243205eaa962e99da4d8f135",
          "commitAuthor": "Tsz-Wo Nicholas Sze",
          "commitDateOld": "14/07/17 1:36 PM",
          "commitNameOld": "a29fe100b3c671954b759add5923a2b44af9e6a4",
          "commitAuthorOld": "Tsz-Wo Nicholas Sze",
          "daysBetweenCommits": 0.04,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,39 +1,36 @@\n   protected ContentSummaryComputationContext computeDirectoryContentSummary(\n-      ContentSummaryComputationContext summary, int snapshotId)\n-      throws AccessControlException{\n-    // throws exception if failing the permission check\n-    summary.checkPermission(this, snapshotId, FsAction.READ_EXECUTE);\n+      ContentSummaryComputationContext summary, int snapshotId) {\n     ReadOnlyList\u003cINode\u003e childrenList \u003d getChildrenList(snapshotId);\n     // Explicit traversing is done to enable repositioning after relinquishing\n     // and reacquiring locks.\n     for (int i \u003d 0;  i \u003c childrenList.size(); i++) {\n       INode child \u003d childrenList.get(i);\n       byte[] childName \u003d child.getLocalNameBytes();\n \n       long lastYieldCount \u003d summary.getYieldCount();\n       child.computeContentSummary(snapshotId, summary);\n \n       // Check whether the computation was paused in the subtree.\n       // The counts may be off, but traversing the rest of children\n       // should be made safe.\n       if (lastYieldCount \u003d\u003d summary.getYieldCount()) {\n         continue;\n       }\n       // The locks were released and reacquired. Check parent first.\n       if (!isRoot() \u0026\u0026 getParent() \u003d\u003d null) {\n         // Stop further counting and return whatever we have so far.\n         break;\n       }\n       // Obtain the children list again since it may have been modified.\n       childrenList \u003d getChildrenList(snapshotId);\n       // Reposition in case the children list is changed. Decrement by 1\n       // since it will be incremented when loops.\n       i \u003d nextChild(childrenList, childName) - 1;\n     }\n \n     // Increment the directory count for this directory.\n     summary.getCounts().addContent(Content.DIRECTORY, 1);\n     // Relinquish and reacquire locks if necessary.\n     summary.yield();\n     return summary;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected ContentSummaryComputationContext computeDirectoryContentSummary(\n      ContentSummaryComputationContext summary, int snapshotId) {\n    ReadOnlyList\u003cINode\u003e childrenList \u003d getChildrenList(snapshotId);\n    // Explicit traversing is done to enable repositioning after relinquishing\n    // and reacquiring locks.\n    for (int i \u003d 0;  i \u003c childrenList.size(); i++) {\n      INode child \u003d childrenList.get(i);\n      byte[] childName \u003d child.getLocalNameBytes();\n\n      long lastYieldCount \u003d summary.getYieldCount();\n      child.computeContentSummary(snapshotId, summary);\n\n      // Check whether the computation was paused in the subtree.\n      // The counts may be off, but traversing the rest of children\n      // should be made safe.\n      if (lastYieldCount \u003d\u003d summary.getYieldCount()) {\n        continue;\n      }\n      // The locks were released and reacquired. Check parent first.\n      if (!isRoot() \u0026\u0026 getParent() \u003d\u003d null) {\n        // Stop further counting and return whatever we have so far.\n        break;\n      }\n      // Obtain the children list again since it may have been modified.\n      childrenList \u003d getChildrenList(snapshotId);\n      // Reposition in case the children list is changed. Decrement by 1\n      // since it will be incremented when loops.\n      i \u003d nextChild(childrenList, childName) - 1;\n    }\n\n    // Increment the directory count for this directory.\n    summary.getCounts().addContent(Content.DIRECTORY, 1);\n    // Relinquish and reacquire locks if necessary.\n    summary.yield();\n    return summary;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/INodeDirectory.java",
          "extendedDetails": {}
        }
      ]
    },
    "a29fe100b3c671954b759add5923a2b44af9e6a4": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "HDFS-12130. Optimizing permission check for getContentSummary.\n",
      "commitDate": "14/07/17 1:36 PM",
      "commitName": "a29fe100b3c671954b759add5923a2b44af9e6a4",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "HDFS-12130. Optimizing permission check for getContentSummary.\n",
          "commitDate": "14/07/17 1:36 PM",
          "commitName": "a29fe100b3c671954b759add5923a2b44af9e6a4",
          "commitAuthor": "Tsz-Wo Nicholas Sze",
          "commitDateOld": "30/06/17 10:28 AM",
          "commitNameOld": "bcba844d1144cc334e2babbc34c9d42eac1c203a",
          "commitAuthorOld": "Wei-Chiu Chuang",
          "daysBetweenCommits": 14.13,
          "commitsBetweenForRepo": 54,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,36 +1,39 @@\n   protected ContentSummaryComputationContext computeDirectoryContentSummary(\n-      ContentSummaryComputationContext summary, int snapshotId) {\n+      ContentSummaryComputationContext summary, int snapshotId)\n+      throws AccessControlException{\n+    // throws exception if failing the permission check\n+    summary.checkPermission(this, snapshotId, FsAction.READ_EXECUTE);\n     ReadOnlyList\u003cINode\u003e childrenList \u003d getChildrenList(snapshotId);\n     // Explicit traversing is done to enable repositioning after relinquishing\n     // and reacquiring locks.\n     for (int i \u003d 0;  i \u003c childrenList.size(); i++) {\n       INode child \u003d childrenList.get(i);\n       byte[] childName \u003d child.getLocalNameBytes();\n \n       long lastYieldCount \u003d summary.getYieldCount();\n       child.computeContentSummary(snapshotId, summary);\n \n       // Check whether the computation was paused in the subtree.\n       // The counts may be off, but traversing the rest of children\n       // should be made safe.\n       if (lastYieldCount \u003d\u003d summary.getYieldCount()) {\n         continue;\n       }\n       // The locks were released and reacquired. Check parent first.\n       if (!isRoot() \u0026\u0026 getParent() \u003d\u003d null) {\n         // Stop further counting and return whatever we have so far.\n         break;\n       }\n       // Obtain the children list again since it may have been modified.\n       childrenList \u003d getChildrenList(snapshotId);\n       // Reposition in case the children list is changed. Decrement by 1\n       // since it will be incremented when loops.\n       i \u003d nextChild(childrenList, childName) - 1;\n     }\n \n     // Increment the directory count for this directory.\n     summary.getCounts().addContent(Content.DIRECTORY, 1);\n     // Relinquish and reacquire locks if necessary.\n     summary.yield();\n     return summary;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected ContentSummaryComputationContext computeDirectoryContentSummary(\n      ContentSummaryComputationContext summary, int snapshotId)\n      throws AccessControlException{\n    // throws exception if failing the permission check\n    summary.checkPermission(this, snapshotId, FsAction.READ_EXECUTE);\n    ReadOnlyList\u003cINode\u003e childrenList \u003d getChildrenList(snapshotId);\n    // Explicit traversing is done to enable repositioning after relinquishing\n    // and reacquiring locks.\n    for (int i \u003d 0;  i \u003c childrenList.size(); i++) {\n      INode child \u003d childrenList.get(i);\n      byte[] childName \u003d child.getLocalNameBytes();\n\n      long lastYieldCount \u003d summary.getYieldCount();\n      child.computeContentSummary(snapshotId, summary);\n\n      // Check whether the computation was paused in the subtree.\n      // The counts may be off, but traversing the rest of children\n      // should be made safe.\n      if (lastYieldCount \u003d\u003d summary.getYieldCount()) {\n        continue;\n      }\n      // The locks were released and reacquired. Check parent first.\n      if (!isRoot() \u0026\u0026 getParent() \u003d\u003d null) {\n        // Stop further counting and return whatever we have so far.\n        break;\n      }\n      // Obtain the children list again since it may have been modified.\n      childrenList \u003d getChildrenList(snapshotId);\n      // Reposition in case the children list is changed. Decrement by 1\n      // since it will be incremented when loops.\n      i \u003d nextChild(childrenList, childName) - 1;\n    }\n\n    // Increment the directory count for this directory.\n    summary.getCounts().addContent(Content.DIRECTORY, 1);\n    // Relinquish and reacquire locks if necessary.\n    summary.yield();\n    return summary;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/INodeDirectory.java",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[AccessControlException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-12130. Optimizing permission check for getContentSummary.\n",
          "commitDate": "14/07/17 1:36 PM",
          "commitName": "a29fe100b3c671954b759add5923a2b44af9e6a4",
          "commitAuthor": "Tsz-Wo Nicholas Sze",
          "commitDateOld": "30/06/17 10:28 AM",
          "commitNameOld": "bcba844d1144cc334e2babbc34c9d42eac1c203a",
          "commitAuthorOld": "Wei-Chiu Chuang",
          "daysBetweenCommits": 14.13,
          "commitsBetweenForRepo": 54,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,36 +1,39 @@\n   protected ContentSummaryComputationContext computeDirectoryContentSummary(\n-      ContentSummaryComputationContext summary, int snapshotId) {\n+      ContentSummaryComputationContext summary, int snapshotId)\n+      throws AccessControlException{\n+    // throws exception if failing the permission check\n+    summary.checkPermission(this, snapshotId, FsAction.READ_EXECUTE);\n     ReadOnlyList\u003cINode\u003e childrenList \u003d getChildrenList(snapshotId);\n     // Explicit traversing is done to enable repositioning after relinquishing\n     // and reacquiring locks.\n     for (int i \u003d 0;  i \u003c childrenList.size(); i++) {\n       INode child \u003d childrenList.get(i);\n       byte[] childName \u003d child.getLocalNameBytes();\n \n       long lastYieldCount \u003d summary.getYieldCount();\n       child.computeContentSummary(snapshotId, summary);\n \n       // Check whether the computation was paused in the subtree.\n       // The counts may be off, but traversing the rest of children\n       // should be made safe.\n       if (lastYieldCount \u003d\u003d summary.getYieldCount()) {\n         continue;\n       }\n       // The locks were released and reacquired. Check parent first.\n       if (!isRoot() \u0026\u0026 getParent() \u003d\u003d null) {\n         // Stop further counting and return whatever we have so far.\n         break;\n       }\n       // Obtain the children list again since it may have been modified.\n       childrenList \u003d getChildrenList(snapshotId);\n       // Reposition in case the children list is changed. Decrement by 1\n       // since it will be incremented when loops.\n       i \u003d nextChild(childrenList, childName) - 1;\n     }\n \n     // Increment the directory count for this directory.\n     summary.getCounts().addContent(Content.DIRECTORY, 1);\n     // Relinquish and reacquire locks if necessary.\n     summary.yield();\n     return summary;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected ContentSummaryComputationContext computeDirectoryContentSummary(\n      ContentSummaryComputationContext summary, int snapshotId)\n      throws AccessControlException{\n    // throws exception if failing the permission check\n    summary.checkPermission(this, snapshotId, FsAction.READ_EXECUTE);\n    ReadOnlyList\u003cINode\u003e childrenList \u003d getChildrenList(snapshotId);\n    // Explicit traversing is done to enable repositioning after relinquishing\n    // and reacquiring locks.\n    for (int i \u003d 0;  i \u003c childrenList.size(); i++) {\n      INode child \u003d childrenList.get(i);\n      byte[] childName \u003d child.getLocalNameBytes();\n\n      long lastYieldCount \u003d summary.getYieldCount();\n      child.computeContentSummary(snapshotId, summary);\n\n      // Check whether the computation was paused in the subtree.\n      // The counts may be off, but traversing the rest of children\n      // should be made safe.\n      if (lastYieldCount \u003d\u003d summary.getYieldCount()) {\n        continue;\n      }\n      // The locks were released and reacquired. Check parent first.\n      if (!isRoot() \u0026\u0026 getParent() \u003d\u003d null) {\n        // Stop further counting and return whatever we have so far.\n        break;\n      }\n      // Obtain the children list again since it may have been modified.\n      childrenList \u003d getChildrenList(snapshotId);\n      // Reposition in case the children list is changed. Decrement by 1\n      // since it will be incremented when loops.\n      i \u003d nextChild(childrenList, childName) - 1;\n    }\n\n    // Increment the directory count for this directory.\n    summary.getCounts().addContent(Content.DIRECTORY, 1);\n    // Relinquish and reacquire locks if necessary.\n    summary.yield();\n    return summary;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/INodeDirectory.java",
          "extendedDetails": {}
        }
      ]
    },
    "3f4275310203de4ccfb15337f3c503e25408a265": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9063. Correctly handle snapshot path for getContentSummary. Contributed by Jing Zhao.\n",
      "commitDate": "18/09/15 9:26 AM",
      "commitName": "3f4275310203de4ccfb15337f3c503e25408a265",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "09/09/15 11:38 AM",
      "commitNameOld": "4014ce5990bff9b0ecb3d38a633d40eaf6cf07a7",
      "commitAuthorOld": "Vinayakumar B",
      "daysBetweenCommits": 8.91,
      "commitsBetweenForRepo": 66,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,36 +1,36 @@\n   protected ContentSummaryComputationContext computeDirectoryContentSummary(\n       ContentSummaryComputationContext summary, int snapshotId) {\n     ReadOnlyList\u003cINode\u003e childrenList \u003d getChildrenList(snapshotId);\n     // Explicit traversing is done to enable repositioning after relinquishing\n     // and reacquiring locks.\n     for (int i \u003d 0;  i \u003c childrenList.size(); i++) {\n       INode child \u003d childrenList.get(i);\n       byte[] childName \u003d child.getLocalNameBytes();\n \n       long lastYieldCount \u003d summary.getYieldCount();\n-      child.computeContentSummary(summary);\n+      child.computeContentSummary(snapshotId, summary);\n \n       // Check whether the computation was paused in the subtree.\n       // The counts may be off, but traversing the rest of children\n       // should be made safe.\n       if (lastYieldCount \u003d\u003d summary.getYieldCount()) {\n         continue;\n       }\n       // The locks were released and reacquired. Check parent first.\n       if (!isRoot() \u0026\u0026 getParent() \u003d\u003d null) {\n         // Stop further counting and return whatever we have so far.\n         break;\n       }\n       // Obtain the children list again since it may have been modified.\n       childrenList \u003d getChildrenList(snapshotId);\n       // Reposition in case the children list is changed. Decrement by 1\n       // since it will be incremented when loops.\n       i \u003d nextChild(childrenList, childName) - 1;\n     }\n \n     // Increment the directory count for this directory.\n     summary.getCounts().addContent(Content.DIRECTORY, 1);\n     // Relinquish and reacquire locks if necessary.\n     summary.yield();\n     return summary;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected ContentSummaryComputationContext computeDirectoryContentSummary(\n      ContentSummaryComputationContext summary, int snapshotId) {\n    ReadOnlyList\u003cINode\u003e childrenList \u003d getChildrenList(snapshotId);\n    // Explicit traversing is done to enable repositioning after relinquishing\n    // and reacquiring locks.\n    for (int i \u003d 0;  i \u003c childrenList.size(); i++) {\n      INode child \u003d childrenList.get(i);\n      byte[] childName \u003d child.getLocalNameBytes();\n\n      long lastYieldCount \u003d summary.getYieldCount();\n      child.computeContentSummary(snapshotId, summary);\n\n      // Check whether the computation was paused in the subtree.\n      // The counts may be off, but traversing the rest of children\n      // should be made safe.\n      if (lastYieldCount \u003d\u003d summary.getYieldCount()) {\n        continue;\n      }\n      // The locks were released and reacquired. Check parent first.\n      if (!isRoot() \u0026\u0026 getParent() \u003d\u003d null) {\n        // Stop further counting and return whatever we have so far.\n        break;\n      }\n      // Obtain the children list again since it may have been modified.\n      childrenList \u003d getChildrenList(snapshotId);\n      // Reposition in case the children list is changed. Decrement by 1\n      // since it will be incremented when loops.\n      i \u003d nextChild(childrenList, childName) - 1;\n    }\n\n    // Increment the directory count for this directory.\n    summary.getCounts().addContent(Content.DIRECTORY, 1);\n    // Relinquish and reacquire locks if necessary.\n    summary.yield();\n    return summary;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/INodeDirectory.java",
      "extendedDetails": {}
    },
    "4014ce5990bff9b0ecb3d38a633d40eaf6cf07a7": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8581. ContentSummary on / skips further counts on yielding lock (contributed by J.Andreina)\n",
      "commitDate": "09/09/15 11:38 AM",
      "commitName": "4014ce5990bff9b0ecb3d38a633d40eaf6cf07a7",
      "commitAuthor": "Vinayakumar B",
      "commitDateOld": "25/08/15 1:16 AM",
      "commitNameOld": "eee0d4563c62647cfaaed6605ee713aaf69add78",
      "commitAuthorOld": "yliu",
      "daysBetweenCommits": 15.43,
      "commitsBetweenForRepo": 83,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,36 +1,36 @@\n   protected ContentSummaryComputationContext computeDirectoryContentSummary(\n       ContentSummaryComputationContext summary, int snapshotId) {\n     ReadOnlyList\u003cINode\u003e childrenList \u003d getChildrenList(snapshotId);\n     // Explicit traversing is done to enable repositioning after relinquishing\n     // and reacquiring locks.\n     for (int i \u003d 0;  i \u003c childrenList.size(); i++) {\n       INode child \u003d childrenList.get(i);\n       byte[] childName \u003d child.getLocalNameBytes();\n \n       long lastYieldCount \u003d summary.getYieldCount();\n       child.computeContentSummary(summary);\n \n       // Check whether the computation was paused in the subtree.\n       // The counts may be off, but traversing the rest of children\n       // should be made safe.\n       if (lastYieldCount \u003d\u003d summary.getYieldCount()) {\n         continue;\n       }\n       // The locks were released and reacquired. Check parent first.\n-      if (getParent() \u003d\u003d null) {\n+      if (!isRoot() \u0026\u0026 getParent() \u003d\u003d null) {\n         // Stop further counting and return whatever we have so far.\n         break;\n       }\n       // Obtain the children list again since it may have been modified.\n       childrenList \u003d getChildrenList(snapshotId);\n       // Reposition in case the children list is changed. Decrement by 1\n       // since it will be incremented when loops.\n       i \u003d nextChild(childrenList, childName) - 1;\n     }\n \n     // Increment the directory count for this directory.\n     summary.getCounts().addContent(Content.DIRECTORY, 1);\n     // Relinquish and reacquire locks if necessary.\n     summary.yield();\n     return summary;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected ContentSummaryComputationContext computeDirectoryContentSummary(\n      ContentSummaryComputationContext summary, int snapshotId) {\n    ReadOnlyList\u003cINode\u003e childrenList \u003d getChildrenList(snapshotId);\n    // Explicit traversing is done to enable repositioning after relinquishing\n    // and reacquiring locks.\n    for (int i \u003d 0;  i \u003c childrenList.size(); i++) {\n      INode child \u003d childrenList.get(i);\n      byte[] childName \u003d child.getLocalNameBytes();\n\n      long lastYieldCount \u003d summary.getYieldCount();\n      child.computeContentSummary(summary);\n\n      // Check whether the computation was paused in the subtree.\n      // The counts may be off, but traversing the rest of children\n      // should be made safe.\n      if (lastYieldCount \u003d\u003d summary.getYieldCount()) {\n        continue;\n      }\n      // The locks were released and reacquired. Check parent first.\n      if (!isRoot() \u0026\u0026 getParent() \u003d\u003d null) {\n        // Stop further counting and return whatever we have so far.\n        break;\n      }\n      // Obtain the children list again since it may have been modified.\n      childrenList \u003d getChildrenList(snapshotId);\n      // Reposition in case the children list is changed. Decrement by 1\n      // since it will be incremented when loops.\n      i \u003d nextChild(childrenList, childName) - 1;\n    }\n\n    // Increment the directory count for this directory.\n    summary.getCounts().addContent(Content.DIRECTORY, 1);\n    // Relinquish and reacquire locks if necessary.\n    summary.yield();\n    return summary;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/INodeDirectory.java",
      "extendedDetails": {}
    },
    "3d0708bdb0a75af3d87bbac9f6c4ffbcabab98ca": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7824. GetContentSummary API and its namenode implementation for Storage Type Quota/Usage. (Contributed by Xiaoyu Yao)\n",
      "commitDate": "26/03/15 10:24 AM",
      "commitName": "3d0708bdb0a75af3d87bbac9f6c4ffbcabab98ca",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "21/02/15 3:38 PM",
      "commitNameOld": "8b465b4b8caed31ca9daeaae108f9a868a30a455",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 32.74,
      "commitsBetweenForRepo": 286,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,36 +1,36 @@\n   protected ContentSummaryComputationContext computeDirectoryContentSummary(\n       ContentSummaryComputationContext summary, int snapshotId) {\n     ReadOnlyList\u003cINode\u003e childrenList \u003d getChildrenList(snapshotId);\n     // Explicit traversing is done to enable repositioning after relinquishing\n     // and reacquiring locks.\n     for (int i \u003d 0;  i \u003c childrenList.size(); i++) {\n       INode child \u003d childrenList.get(i);\n       byte[] childName \u003d child.getLocalNameBytes();\n \n       long lastYieldCount \u003d summary.getYieldCount();\n       child.computeContentSummary(summary);\n \n       // Check whether the computation was paused in the subtree.\n       // The counts may be off, but traversing the rest of children\n       // should be made safe.\n       if (lastYieldCount \u003d\u003d summary.getYieldCount()) {\n         continue;\n       }\n       // The locks were released and reacquired. Check parent first.\n       if (getParent() \u003d\u003d null) {\n         // Stop further counting and return whatever we have so far.\n         break;\n       }\n       // Obtain the children list again since it may have been modified.\n       childrenList \u003d getChildrenList(snapshotId);\n       // Reposition in case the children list is changed. Decrement by 1\n       // since it will be incremented when loops.\n       i \u003d nextChild(childrenList, childName) - 1;\n     }\n \n     // Increment the directory count for this directory.\n-    summary.getCounts().add(Content.DIRECTORY, 1);\n+    summary.getCounts().addContent(Content.DIRECTORY, 1);\n     // Relinquish and reacquire locks if necessary.\n     summary.yield();\n     return summary;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected ContentSummaryComputationContext computeDirectoryContentSummary(\n      ContentSummaryComputationContext summary, int snapshotId) {\n    ReadOnlyList\u003cINode\u003e childrenList \u003d getChildrenList(snapshotId);\n    // Explicit traversing is done to enable repositioning after relinquishing\n    // and reacquiring locks.\n    for (int i \u003d 0;  i \u003c childrenList.size(); i++) {\n      INode child \u003d childrenList.get(i);\n      byte[] childName \u003d child.getLocalNameBytes();\n\n      long lastYieldCount \u003d summary.getYieldCount();\n      child.computeContentSummary(summary);\n\n      // Check whether the computation was paused in the subtree.\n      // The counts may be off, but traversing the rest of children\n      // should be made safe.\n      if (lastYieldCount \u003d\u003d summary.getYieldCount()) {\n        continue;\n      }\n      // The locks were released and reacquired. Check parent first.\n      if (getParent() \u003d\u003d null) {\n        // Stop further counting and return whatever we have so far.\n        break;\n      }\n      // Obtain the children list again since it may have been modified.\n      childrenList \u003d getChildrenList(snapshotId);\n      // Reposition in case the children list is changed. Decrement by 1\n      // since it will be incremented when loops.\n      i \u003d nextChild(childrenList, childName) - 1;\n    }\n\n    // Increment the directory count for this directory.\n    summary.getCounts().addContent(Content.DIRECTORY, 1);\n    // Relinquish and reacquire locks if necessary.\n    summary.yield();\n    return summary;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/INodeDirectory.java",
      "extendedDetails": {}
    },
    "28051e415591b8e33dbe954f65230ede23b11683": {
      "type": "Ymultichange(Yparameterchange,Ymodifierchange,Ybodychange)",
      "commitMessage": "HADOOP-6857. FsShell should report raw disk usage including replication factor. Contributed by Byron Wong.\n",
      "commitDate": "25/10/14 12:31 PM",
      "commitName": "28051e415591b8e33dbe954f65230ede23b11683",
      "commitAuthor": "Byron Wong",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-6857. FsShell should report raw disk usage including replication factor. Contributed by Byron Wong.\n",
          "commitDate": "25/10/14 12:31 PM",
          "commitName": "28051e415591b8e33dbe954f65230ede23b11683",
          "commitAuthor": "Byron Wong",
          "commitDateOld": "24/09/14 10:05 AM",
          "commitNameOld": "073bbd805c6680f47bbfcc6e8efd708ad729bca4",
          "commitAuthorOld": "Jing Zhao",
          "daysBetweenCommits": 31.1,
          "commitsBetweenForRepo": 295,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,36 +1,36 @@\n-  ContentSummaryComputationContext computeDirectoryContentSummary(\n-      ContentSummaryComputationContext summary) {\n-    ReadOnlyList\u003cINode\u003e childrenList \u003d getChildrenList(Snapshot.CURRENT_STATE_ID);\n+  protected ContentSummaryComputationContext computeDirectoryContentSummary(\n+      ContentSummaryComputationContext summary, int snapshotId) {\n+    ReadOnlyList\u003cINode\u003e childrenList \u003d getChildrenList(snapshotId);\n     // Explicit traversing is done to enable repositioning after relinquishing\n     // and reacquiring locks.\n     for (int i \u003d 0;  i \u003c childrenList.size(); i++) {\n       INode child \u003d childrenList.get(i);\n       byte[] childName \u003d child.getLocalNameBytes();\n \n       long lastYieldCount \u003d summary.getYieldCount();\n       child.computeContentSummary(summary);\n \n       // Check whether the computation was paused in the subtree.\n       // The counts may be off, but traversing the rest of children\n       // should be made safe.\n       if (lastYieldCount \u003d\u003d summary.getYieldCount()) {\n         continue;\n       }\n       // The locks were released and reacquired. Check parent first.\n       if (getParent() \u003d\u003d null) {\n         // Stop further counting and return whatever we have so far.\n         break;\n       }\n       // Obtain the children list again since it may have been modified.\n-      childrenList \u003d getChildrenList(Snapshot.CURRENT_STATE_ID);\n+      childrenList \u003d getChildrenList(snapshotId);\n       // Reposition in case the children list is changed. Decrement by 1\n       // since it will be incremented when loops.\n       i \u003d nextChild(childrenList, childName) - 1;\n     }\n \n     // Increment the directory count for this directory.\n     summary.getCounts().add(Content.DIRECTORY, 1);\n     // Relinquish and reacquire locks if necessary.\n     summary.yield();\n     return summary;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected ContentSummaryComputationContext computeDirectoryContentSummary(\n      ContentSummaryComputationContext summary, int snapshotId) {\n    ReadOnlyList\u003cINode\u003e childrenList \u003d getChildrenList(snapshotId);\n    // Explicit traversing is done to enable repositioning after relinquishing\n    // and reacquiring locks.\n    for (int i \u003d 0;  i \u003c childrenList.size(); i++) {\n      INode child \u003d childrenList.get(i);\n      byte[] childName \u003d child.getLocalNameBytes();\n\n      long lastYieldCount \u003d summary.getYieldCount();\n      child.computeContentSummary(summary);\n\n      // Check whether the computation was paused in the subtree.\n      // The counts may be off, but traversing the rest of children\n      // should be made safe.\n      if (lastYieldCount \u003d\u003d summary.getYieldCount()) {\n        continue;\n      }\n      // The locks were released and reacquired. Check parent first.\n      if (getParent() \u003d\u003d null) {\n        // Stop further counting and return whatever we have so far.\n        break;\n      }\n      // Obtain the children list again since it may have been modified.\n      childrenList \u003d getChildrenList(snapshotId);\n      // Reposition in case the children list is changed. Decrement by 1\n      // since it will be incremented when loops.\n      i \u003d nextChild(childrenList, childName) - 1;\n    }\n\n    // Increment the directory count for this directory.\n    summary.getCounts().add(Content.DIRECTORY, 1);\n    // Relinquish and reacquire locks if necessary.\n    summary.yield();\n    return summary;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/INodeDirectory.java",
          "extendedDetails": {
            "oldValue": "[summary-ContentSummaryComputationContext]",
            "newValue": "[summary-ContentSummaryComputationContext, snapshotId-int]"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "HADOOP-6857. FsShell should report raw disk usage including replication factor. Contributed by Byron Wong.\n",
          "commitDate": "25/10/14 12:31 PM",
          "commitName": "28051e415591b8e33dbe954f65230ede23b11683",
          "commitAuthor": "Byron Wong",
          "commitDateOld": "24/09/14 10:05 AM",
          "commitNameOld": "073bbd805c6680f47bbfcc6e8efd708ad729bca4",
          "commitAuthorOld": "Jing Zhao",
          "daysBetweenCommits": 31.1,
          "commitsBetweenForRepo": 295,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,36 +1,36 @@\n-  ContentSummaryComputationContext computeDirectoryContentSummary(\n-      ContentSummaryComputationContext summary) {\n-    ReadOnlyList\u003cINode\u003e childrenList \u003d getChildrenList(Snapshot.CURRENT_STATE_ID);\n+  protected ContentSummaryComputationContext computeDirectoryContentSummary(\n+      ContentSummaryComputationContext summary, int snapshotId) {\n+    ReadOnlyList\u003cINode\u003e childrenList \u003d getChildrenList(snapshotId);\n     // Explicit traversing is done to enable repositioning after relinquishing\n     // and reacquiring locks.\n     for (int i \u003d 0;  i \u003c childrenList.size(); i++) {\n       INode child \u003d childrenList.get(i);\n       byte[] childName \u003d child.getLocalNameBytes();\n \n       long lastYieldCount \u003d summary.getYieldCount();\n       child.computeContentSummary(summary);\n \n       // Check whether the computation was paused in the subtree.\n       // The counts may be off, but traversing the rest of children\n       // should be made safe.\n       if (lastYieldCount \u003d\u003d summary.getYieldCount()) {\n         continue;\n       }\n       // The locks were released and reacquired. Check parent first.\n       if (getParent() \u003d\u003d null) {\n         // Stop further counting and return whatever we have so far.\n         break;\n       }\n       // Obtain the children list again since it may have been modified.\n-      childrenList \u003d getChildrenList(Snapshot.CURRENT_STATE_ID);\n+      childrenList \u003d getChildrenList(snapshotId);\n       // Reposition in case the children list is changed. Decrement by 1\n       // since it will be incremented when loops.\n       i \u003d nextChild(childrenList, childName) - 1;\n     }\n \n     // Increment the directory count for this directory.\n     summary.getCounts().add(Content.DIRECTORY, 1);\n     // Relinquish and reacquire locks if necessary.\n     summary.yield();\n     return summary;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected ContentSummaryComputationContext computeDirectoryContentSummary(\n      ContentSummaryComputationContext summary, int snapshotId) {\n    ReadOnlyList\u003cINode\u003e childrenList \u003d getChildrenList(snapshotId);\n    // Explicit traversing is done to enable repositioning after relinquishing\n    // and reacquiring locks.\n    for (int i \u003d 0;  i \u003c childrenList.size(); i++) {\n      INode child \u003d childrenList.get(i);\n      byte[] childName \u003d child.getLocalNameBytes();\n\n      long lastYieldCount \u003d summary.getYieldCount();\n      child.computeContentSummary(summary);\n\n      // Check whether the computation was paused in the subtree.\n      // The counts may be off, but traversing the rest of children\n      // should be made safe.\n      if (lastYieldCount \u003d\u003d summary.getYieldCount()) {\n        continue;\n      }\n      // The locks were released and reacquired. Check parent first.\n      if (getParent() \u003d\u003d null) {\n        // Stop further counting and return whatever we have so far.\n        break;\n      }\n      // Obtain the children list again since it may have been modified.\n      childrenList \u003d getChildrenList(snapshotId);\n      // Reposition in case the children list is changed. Decrement by 1\n      // since it will be incremented when loops.\n      i \u003d nextChild(childrenList, childName) - 1;\n    }\n\n    // Increment the directory count for this directory.\n    summary.getCounts().add(Content.DIRECTORY, 1);\n    // Relinquish and reacquire locks if necessary.\n    summary.yield();\n    return summary;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/INodeDirectory.java",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[protected]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-6857. FsShell should report raw disk usage including replication factor. Contributed by Byron Wong.\n",
          "commitDate": "25/10/14 12:31 PM",
          "commitName": "28051e415591b8e33dbe954f65230ede23b11683",
          "commitAuthor": "Byron Wong",
          "commitDateOld": "24/09/14 10:05 AM",
          "commitNameOld": "073bbd805c6680f47bbfcc6e8efd708ad729bca4",
          "commitAuthorOld": "Jing Zhao",
          "daysBetweenCommits": 31.1,
          "commitsBetweenForRepo": 295,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,36 +1,36 @@\n-  ContentSummaryComputationContext computeDirectoryContentSummary(\n-      ContentSummaryComputationContext summary) {\n-    ReadOnlyList\u003cINode\u003e childrenList \u003d getChildrenList(Snapshot.CURRENT_STATE_ID);\n+  protected ContentSummaryComputationContext computeDirectoryContentSummary(\n+      ContentSummaryComputationContext summary, int snapshotId) {\n+    ReadOnlyList\u003cINode\u003e childrenList \u003d getChildrenList(snapshotId);\n     // Explicit traversing is done to enable repositioning after relinquishing\n     // and reacquiring locks.\n     for (int i \u003d 0;  i \u003c childrenList.size(); i++) {\n       INode child \u003d childrenList.get(i);\n       byte[] childName \u003d child.getLocalNameBytes();\n \n       long lastYieldCount \u003d summary.getYieldCount();\n       child.computeContentSummary(summary);\n \n       // Check whether the computation was paused in the subtree.\n       // The counts may be off, but traversing the rest of children\n       // should be made safe.\n       if (lastYieldCount \u003d\u003d summary.getYieldCount()) {\n         continue;\n       }\n       // The locks were released and reacquired. Check parent first.\n       if (getParent() \u003d\u003d null) {\n         // Stop further counting and return whatever we have so far.\n         break;\n       }\n       // Obtain the children list again since it may have been modified.\n-      childrenList \u003d getChildrenList(Snapshot.CURRENT_STATE_ID);\n+      childrenList \u003d getChildrenList(snapshotId);\n       // Reposition in case the children list is changed. Decrement by 1\n       // since it will be incremented when loops.\n       i \u003d nextChild(childrenList, childName) - 1;\n     }\n \n     // Increment the directory count for this directory.\n     summary.getCounts().add(Content.DIRECTORY, 1);\n     // Relinquish and reacquire locks if necessary.\n     summary.yield();\n     return summary;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected ContentSummaryComputationContext computeDirectoryContentSummary(\n      ContentSummaryComputationContext summary, int snapshotId) {\n    ReadOnlyList\u003cINode\u003e childrenList \u003d getChildrenList(snapshotId);\n    // Explicit traversing is done to enable repositioning after relinquishing\n    // and reacquiring locks.\n    for (int i \u003d 0;  i \u003c childrenList.size(); i++) {\n      INode child \u003d childrenList.get(i);\n      byte[] childName \u003d child.getLocalNameBytes();\n\n      long lastYieldCount \u003d summary.getYieldCount();\n      child.computeContentSummary(summary);\n\n      // Check whether the computation was paused in the subtree.\n      // The counts may be off, but traversing the rest of children\n      // should be made safe.\n      if (lastYieldCount \u003d\u003d summary.getYieldCount()) {\n        continue;\n      }\n      // The locks were released and reacquired. Check parent first.\n      if (getParent() \u003d\u003d null) {\n        // Stop further counting and return whatever we have so far.\n        break;\n      }\n      // Obtain the children list again since it may have been modified.\n      childrenList \u003d getChildrenList(snapshotId);\n      // Reposition in case the children list is changed. Decrement by 1\n      // since it will be incremented when loops.\n      i \u003d nextChild(childrenList, childName) - 1;\n    }\n\n    // Increment the directory count for this directory.\n    summary.getCounts().add(Content.DIRECTORY, 1);\n    // Relinquish and reacquire locks if necessary.\n    summary.yield();\n    return summary;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/INodeDirectory.java",
          "extendedDetails": {}
        }
      ]
    },
    "70cff9e2f0c8f78c1dc54a064182971bb2106795": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5715. Use Snapshot ID to indicate the corresponding Snapshot for a FileDiff/DirectoryDiff. Contributed by Jing Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1556353 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/01/14 12:52 PM",
      "commitName": "70cff9e2f0c8f78c1dc54a064182971bb2106795",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "14/12/13 2:13 AM",
      "commitNameOld": "44a6560b5da3f79d2299579a36e7a2a60a91f823",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 24.44,
      "commitsBetweenForRepo": 98,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,36 +1,36 @@\n   ContentSummaryComputationContext computeDirectoryContentSummary(\n       ContentSummaryComputationContext summary) {\n-    ReadOnlyList\u003cINode\u003e childrenList \u003d getChildrenList(null);\n+    ReadOnlyList\u003cINode\u003e childrenList \u003d getChildrenList(Snapshot.CURRENT_STATE_ID);\n     // Explicit traversing is done to enable repositioning after relinquishing\n     // and reacquiring locks.\n     for (int i \u003d 0;  i \u003c childrenList.size(); i++) {\n       INode child \u003d childrenList.get(i);\n       byte[] childName \u003d child.getLocalNameBytes();\n \n       long lastYieldCount \u003d summary.getYieldCount();\n       child.computeContentSummary(summary);\n \n       // Check whether the computation was paused in the subtree.\n       // The counts may be off, but traversing the rest of children\n       // should be made safe.\n       if (lastYieldCount \u003d\u003d summary.getYieldCount()) {\n         continue;\n       }\n       // The locks were released and reacquired. Check parent first.\n       if (getParent() \u003d\u003d null) {\n         // Stop further counting and return whatever we have so far.\n         break;\n       }\n       // Obtain the children list again since it may have been modified.\n-      childrenList \u003d getChildrenList(null);\n+      childrenList \u003d getChildrenList(Snapshot.CURRENT_STATE_ID);\n       // Reposition in case the children list is changed. Decrement by 1\n       // since it will be incremented when loops.\n       i \u003d nextChild(childrenList, childName) - 1;\n     }\n \n     // Increment the directory count for this directory.\n     summary.getCounts().add(Content.DIRECTORY, 1);\n     // Relinquish and reacquire locks if necessary.\n     summary.yield();\n     return summary;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  ContentSummaryComputationContext computeDirectoryContentSummary(\n      ContentSummaryComputationContext summary) {\n    ReadOnlyList\u003cINode\u003e childrenList \u003d getChildrenList(Snapshot.CURRENT_STATE_ID);\n    // Explicit traversing is done to enable repositioning after relinquishing\n    // and reacquiring locks.\n    for (int i \u003d 0;  i \u003c childrenList.size(); i++) {\n      INode child \u003d childrenList.get(i);\n      byte[] childName \u003d child.getLocalNameBytes();\n\n      long lastYieldCount \u003d summary.getYieldCount();\n      child.computeContentSummary(summary);\n\n      // Check whether the computation was paused in the subtree.\n      // The counts may be off, but traversing the rest of children\n      // should be made safe.\n      if (lastYieldCount \u003d\u003d summary.getYieldCount()) {\n        continue;\n      }\n      // The locks were released and reacquired. Check parent first.\n      if (getParent() \u003d\u003d null) {\n        // Stop further counting and return whatever we have so far.\n        break;\n      }\n      // Obtain the children list again since it may have been modified.\n      childrenList \u003d getChildrenList(Snapshot.CURRENT_STATE_ID);\n      // Reposition in case the children list is changed. Decrement by 1\n      // since it will be incremented when loops.\n      i \u003d nextChild(childrenList, childName) - 1;\n    }\n\n    // Increment the directory count for this directory.\n    summary.getCounts().add(Content.DIRECTORY, 1);\n    // Relinquish and reacquire locks if necessary.\n    summary.yield();\n    return summary;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/INodeDirectory.java",
      "extendedDetails": {}
    },
    "82ff2d3f2e569879500d851f4d67dfa2d02b5c9b": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-5286. Flatten INodeDirectory hierarchy: Replace INodeDirectoryWithQuota with DirectoryWithQuotaFeature.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1545768 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "26/11/13 10:33 AM",
      "commitName": "82ff2d3f2e569879500d851f4d67dfa2d02b5c9b",
      "commitAuthor": "Tsz-wo Sze",
      "diff": "@@ -0,0 +1,40 @@\n+  ContentSummaryComputationContext computeDirectoryContentSummary(\n+      ContentSummaryComputationContext summary) {\n+    ReadOnlyList\u003cINode\u003e childrenList \u003d getChildrenList(null);\n+    // Explicit traversing is done to enable repositioning after relinquishing\n+    // and reacquiring locks.\n+    for (int i \u003d 0;  i \u003c childrenList.size(); i++) {\n+      INode child \u003d childrenList.get(i);\n+      byte[] childName \u003d child.getLocalNameBytes();\n+\n+      long lastYieldCount \u003d summary.getYieldCount();\n+      child.computeContentSummary(summary);\n+\n+      // Check whether the computation was paused in the subtree.\n+      // The counts may be off, but traversing the rest of children\n+      // should be made safe.\n+      if (lastYieldCount \u003d\u003d summary.getYieldCount()) {\n+        continue;\n+      }\n+\n+      // The locks were released and reacquired. Check parent first.\n+      if (getParent() \u003d\u003d null) {\n+        // Stop further counting and return whatever we have so far.\n+        break;\n+      }\n+\n+      // Obtain the children list again since it may have been modified.\n+      childrenList \u003d getChildrenList(null);\n+      // Reposition in case the children list is changed. Decrement by 1\n+      // since it will be incremented when loops.\n+      i \u003d nextChild(childrenList, childName) - 1;\n+    }\n+\n+    // Increment the directory count for this directory.\n+    summary.getCounts().add(Content.DIRECTORY, 1);\n+\n+    // Relinquish and reacquire locks if necessary.\n+    summary.yield();\n+\n+    return summary;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  ContentSummaryComputationContext computeDirectoryContentSummary(\n      ContentSummaryComputationContext summary) {\n    ReadOnlyList\u003cINode\u003e childrenList \u003d getChildrenList(null);\n    // Explicit traversing is done to enable repositioning after relinquishing\n    // and reacquiring locks.\n    for (int i \u003d 0;  i \u003c childrenList.size(); i++) {\n      INode child \u003d childrenList.get(i);\n      byte[] childName \u003d child.getLocalNameBytes();\n\n      long lastYieldCount \u003d summary.getYieldCount();\n      child.computeContentSummary(summary);\n\n      // Check whether the computation was paused in the subtree.\n      // The counts may be off, but traversing the rest of children\n      // should be made safe.\n      if (lastYieldCount \u003d\u003d summary.getYieldCount()) {\n        continue;\n      }\n\n      // The locks were released and reacquired. Check parent first.\n      if (getParent() \u003d\u003d null) {\n        // Stop further counting and return whatever we have so far.\n        break;\n      }\n\n      // Obtain the children list again since it may have been modified.\n      childrenList \u003d getChildrenList(null);\n      // Reposition in case the children list is changed. Decrement by 1\n      // since it will be incremented when loops.\n      i \u003d nextChild(childrenList, childName) - 1;\n    }\n\n    // Increment the directory count for this directory.\n    summary.getCounts().add(Content.DIRECTORY, 1);\n\n    // Relinquish and reacquire locks if necessary.\n    summary.yield();\n\n    return summary;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/INodeDirectory.java"
    }
  }
}