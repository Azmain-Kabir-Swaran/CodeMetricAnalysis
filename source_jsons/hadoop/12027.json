{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FsDatasetImpl.java",
  "functionName": "initReplicaRecoveryImpl",
  "functionId": "initReplicaRecoveryImpl___bpid-String__map-ReplicaMap__block-Block__recoveryId-long",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
  "functionStartLine": 2686,
  "functionEndLine": 2757,
  "numCommitsSeen": 197,
  "timeTaken": 5054,
  "changeHistory": [
    "8c2c8128328d465ec9699d0573bef69019742512",
    "1411612aa4e70c704b941723217ed4efd8a0125b",
    "86c9862bec0248d671e657aa56094a2919b8ac14",
    "f6b1a818124cc42688c4c5acaf537d96cf00e43b"
  ],
  "changeHistoryShort": {
    "8c2c8128328d465ec9699d0573bef69019742512": "Ybodychange",
    "1411612aa4e70c704b941723217ed4efd8a0125b": "Ybodychange",
    "86c9862bec0248d671e657aa56094a2919b8ac14": "Ybodychange",
    "f6b1a818124cc42688c4c5acaf537d96cf00e43b": "Yintroduced"
  },
  "changeHistoryDetails": {
    "8c2c8128328d465ec9699d0573bef69019742512": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11472. Fix inconsistent replica size after a data pipeline failure. Contributed by Erik Krogen and Wei-Chiu Chuang.",
      "commitDate": "20/07/17 2:47 PM",
      "commitName": "8c2c8128328d465ec9699d0573bef69019742512",
      "commitAuthor": "Konstantin V Shvachko",
      "commitDateOld": "14/07/17 1:41 PM",
      "commitNameOld": "8d86a93915ee00318289535d9c78e48b75c8359d",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 6.05,
      "commitsBetweenForRepo": 30,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,72 +1,72 @@\n   static ReplicaRecoveryInfo initReplicaRecoveryImpl(String bpid, ReplicaMap map,\n       Block block, long recoveryId)\n           throws IOException, MustStopExistingWriter {\n     final ReplicaInfo replica \u003d map.get(bpid, block.getBlockId());\n     LOG.info(\"initReplicaRecovery: \" + block + \", recoveryId\u003d\" + recoveryId\n         + \", replica\u003d\" + replica);\n \n     //check replica\n     if (replica \u003d\u003d null) {\n       return null;\n     }\n \n     //stop writer if there is any\n     if (replica.getState() \u003d\u003d ReplicaState.TEMPORARY ||\n         replica.getState() \u003d\u003d ReplicaState.RBW) {\n       final ReplicaInPipeline rip \u003d (ReplicaInPipeline)replica;\n       if (!rip.attemptToSetWriter(null, Thread.currentThread())) {\n         throw new MustStopExistingWriter(rip);\n       }\n \n       //check replica bytes on disk.\n       if (replica.getBytesOnDisk() \u003c replica.getVisibleLength()) {\n-        throw new IOException(\"THIS IS NOT SUPPOSED TO HAPPEN:\"\n-            + \" getBytesOnDisk() \u003c getVisibleLength(), rip\u003d\" + replica);\n+        throw new IOException(\"getBytesOnDisk() \u003c getVisibleLength(), rip\u003d\"\n+            + replica);\n       }\n \n       //check the replica\u0027s files\n       checkReplicaFiles(replica);\n     }\n \n     //check generation stamp\n     if (replica.getGenerationStamp() \u003c block.getGenerationStamp()) {\n       throw new IOException(\n           \"replica.getGenerationStamp() \u003c block.getGenerationStamp(), block\u003d\"\n           + block + \", replica\u003d\" + replica);\n     }\n \n     //check recovery id\n     if (replica.getGenerationStamp() \u003e\u003d recoveryId) {\n       throw new IOException(\"THIS IS NOT SUPPOSED TO HAPPEN:\"\n           + \" replica.getGenerationStamp() \u003e\u003d recoveryId \u003d \" + recoveryId\n           + \", block\u003d\" + block + \", replica\u003d\" + replica);\n     }\n \n     //check RUR\n     final ReplicaInfo rur;\n     if (replica.getState() \u003d\u003d ReplicaState.RUR) {\n       rur \u003d replica;\n       if (rur.getRecoveryID() \u003e\u003d recoveryId) {\n         throw new RecoveryInProgressException(\n             \"rur.getRecoveryID() \u003e\u003d recoveryId \u003d \" + recoveryId\n             + \", block\u003d\" + block + \", rur\u003d\" + rur);\n       }\n       final long oldRecoveryID \u003d rur.getRecoveryID();\n       rur.setRecoveryID(recoveryId);\n       LOG.info(\"initReplicaRecovery: update recovery id for \" + block\n           + \" from \" + oldRecoveryID + \" to \" + recoveryId);\n     }\n     else {\n       rur \u003d new ReplicaBuilder(ReplicaState.RUR)\n           .from(replica).setRecoveryId(recoveryId).build();\n       map.add(bpid, rur);\n       LOG.info(\"initReplicaRecovery: changing replica state for \"\n           + block + \" from \" + replica.getState()\n           + \" to \" + rur.getState());\n       if (replica.getState() \u003d\u003d ReplicaState.TEMPORARY || replica\n           .getState() \u003d\u003d ReplicaState.RBW) {\n         ((ReplicaInPipeline) replica).releaseAllBytesReserved();\n       }\n     }\n     return rur.createInfo();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static ReplicaRecoveryInfo initReplicaRecoveryImpl(String bpid, ReplicaMap map,\n      Block block, long recoveryId)\n          throws IOException, MustStopExistingWriter {\n    final ReplicaInfo replica \u003d map.get(bpid, block.getBlockId());\n    LOG.info(\"initReplicaRecovery: \" + block + \", recoveryId\u003d\" + recoveryId\n        + \", replica\u003d\" + replica);\n\n    //check replica\n    if (replica \u003d\u003d null) {\n      return null;\n    }\n\n    //stop writer if there is any\n    if (replica.getState() \u003d\u003d ReplicaState.TEMPORARY ||\n        replica.getState() \u003d\u003d ReplicaState.RBW) {\n      final ReplicaInPipeline rip \u003d (ReplicaInPipeline)replica;\n      if (!rip.attemptToSetWriter(null, Thread.currentThread())) {\n        throw new MustStopExistingWriter(rip);\n      }\n\n      //check replica bytes on disk.\n      if (replica.getBytesOnDisk() \u003c replica.getVisibleLength()) {\n        throw new IOException(\"getBytesOnDisk() \u003c getVisibleLength(), rip\u003d\"\n            + replica);\n      }\n\n      //check the replica\u0027s files\n      checkReplicaFiles(replica);\n    }\n\n    //check generation stamp\n    if (replica.getGenerationStamp() \u003c block.getGenerationStamp()) {\n      throw new IOException(\n          \"replica.getGenerationStamp() \u003c block.getGenerationStamp(), block\u003d\"\n          + block + \", replica\u003d\" + replica);\n    }\n\n    //check recovery id\n    if (replica.getGenerationStamp() \u003e\u003d recoveryId) {\n      throw new IOException(\"THIS IS NOT SUPPOSED TO HAPPEN:\"\n          + \" replica.getGenerationStamp() \u003e\u003d recoveryId \u003d \" + recoveryId\n          + \", block\u003d\" + block + \", replica\u003d\" + replica);\n    }\n\n    //check RUR\n    final ReplicaInfo rur;\n    if (replica.getState() \u003d\u003d ReplicaState.RUR) {\n      rur \u003d replica;\n      if (rur.getRecoveryID() \u003e\u003d recoveryId) {\n        throw new RecoveryInProgressException(\n            \"rur.getRecoveryID() \u003e\u003d recoveryId \u003d \" + recoveryId\n            + \", block\u003d\" + block + \", rur\u003d\" + rur);\n      }\n      final long oldRecoveryID \u003d rur.getRecoveryID();\n      rur.setRecoveryID(recoveryId);\n      LOG.info(\"initReplicaRecovery: update recovery id for \" + block\n          + \" from \" + oldRecoveryID + \" to \" + recoveryId);\n    }\n    else {\n      rur \u003d new ReplicaBuilder(ReplicaState.RUR)\n          .from(replica).setRecoveryId(recoveryId).build();\n      map.add(bpid, rur);\n      LOG.info(\"initReplicaRecovery: changing replica state for \"\n          + block + \" from \" + replica.getState()\n          + \" to \" + rur.getState());\n      if (replica.getState() \u003d\u003d ReplicaState.TEMPORARY || replica\n          .getState() \u003d\u003d ReplicaState.RBW) {\n        ((ReplicaInPipeline) replica).releaseAllBytesReserved();\n      }\n    }\n    return rur.createInfo();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
      "extendedDetails": {}
    },
    "1411612aa4e70c704b941723217ed4efd8a0125b": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11674. reserveSpaceForReplicas is not released if append request failed due to mirror down and replica recovered (Contributed by Vinayakumar B)\n",
      "commitDate": "11/05/17 7:08 PM",
      "commitName": "1411612aa4e70c704b941723217ed4efd8a0125b",
      "commitAuthor": "Vinayakumar B",
      "commitDateOld": "05/05/17 12:01 PM",
      "commitNameOld": "a3954ccab148bddc290cb96528e63ff19799bcc9",
      "commitAuthorOld": "Chris Douglas",
      "daysBetweenCommits": 6.3,
      "commitsBetweenForRepo": 41,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,68 +1,72 @@\n   static ReplicaRecoveryInfo initReplicaRecoveryImpl(String bpid, ReplicaMap map,\n       Block block, long recoveryId)\n           throws IOException, MustStopExistingWriter {\n     final ReplicaInfo replica \u003d map.get(bpid, block.getBlockId());\n     LOG.info(\"initReplicaRecovery: \" + block + \", recoveryId\u003d\" + recoveryId\n         + \", replica\u003d\" + replica);\n \n     //check replica\n     if (replica \u003d\u003d null) {\n       return null;\n     }\n \n     //stop writer if there is any\n     if (replica.getState() \u003d\u003d ReplicaState.TEMPORARY ||\n         replica.getState() \u003d\u003d ReplicaState.RBW) {\n       final ReplicaInPipeline rip \u003d (ReplicaInPipeline)replica;\n       if (!rip.attemptToSetWriter(null, Thread.currentThread())) {\n         throw new MustStopExistingWriter(rip);\n       }\n \n       //check replica bytes on disk.\n       if (replica.getBytesOnDisk() \u003c replica.getVisibleLength()) {\n         throw new IOException(\"THIS IS NOT SUPPOSED TO HAPPEN:\"\n             + \" getBytesOnDisk() \u003c getVisibleLength(), rip\u003d\" + replica);\n       }\n \n       //check the replica\u0027s files\n       checkReplicaFiles(replica);\n     }\n \n     //check generation stamp\n     if (replica.getGenerationStamp() \u003c block.getGenerationStamp()) {\n       throw new IOException(\n           \"replica.getGenerationStamp() \u003c block.getGenerationStamp(), block\u003d\"\n           + block + \", replica\u003d\" + replica);\n     }\n \n     //check recovery id\n     if (replica.getGenerationStamp() \u003e\u003d recoveryId) {\n       throw new IOException(\"THIS IS NOT SUPPOSED TO HAPPEN:\"\n           + \" replica.getGenerationStamp() \u003e\u003d recoveryId \u003d \" + recoveryId\n           + \", block\u003d\" + block + \", replica\u003d\" + replica);\n     }\n \n     //check RUR\n     final ReplicaInfo rur;\n     if (replica.getState() \u003d\u003d ReplicaState.RUR) {\n       rur \u003d replica;\n       if (rur.getRecoveryID() \u003e\u003d recoveryId) {\n         throw new RecoveryInProgressException(\n             \"rur.getRecoveryID() \u003e\u003d recoveryId \u003d \" + recoveryId\n             + \", block\u003d\" + block + \", rur\u003d\" + rur);\n       }\n       final long oldRecoveryID \u003d rur.getRecoveryID();\n       rur.setRecoveryID(recoveryId);\n       LOG.info(\"initReplicaRecovery: update recovery id for \" + block\n           + \" from \" + oldRecoveryID + \" to \" + recoveryId);\n     }\n     else {\n       rur \u003d new ReplicaBuilder(ReplicaState.RUR)\n           .from(replica).setRecoveryId(recoveryId).build();\n       map.add(bpid, rur);\n       LOG.info(\"initReplicaRecovery: changing replica state for \"\n           + block + \" from \" + replica.getState()\n           + \" to \" + rur.getState());\n+      if (replica.getState() \u003d\u003d ReplicaState.TEMPORARY || replica\n+          .getState() \u003d\u003d ReplicaState.RBW) {\n+        ((ReplicaInPipeline) replica).releaseAllBytesReserved();\n+      }\n     }\n     return rur.createInfo();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static ReplicaRecoveryInfo initReplicaRecoveryImpl(String bpid, ReplicaMap map,\n      Block block, long recoveryId)\n          throws IOException, MustStopExistingWriter {\n    final ReplicaInfo replica \u003d map.get(bpid, block.getBlockId());\n    LOG.info(\"initReplicaRecovery: \" + block + \", recoveryId\u003d\" + recoveryId\n        + \", replica\u003d\" + replica);\n\n    //check replica\n    if (replica \u003d\u003d null) {\n      return null;\n    }\n\n    //stop writer if there is any\n    if (replica.getState() \u003d\u003d ReplicaState.TEMPORARY ||\n        replica.getState() \u003d\u003d ReplicaState.RBW) {\n      final ReplicaInPipeline rip \u003d (ReplicaInPipeline)replica;\n      if (!rip.attemptToSetWriter(null, Thread.currentThread())) {\n        throw new MustStopExistingWriter(rip);\n      }\n\n      //check replica bytes on disk.\n      if (replica.getBytesOnDisk() \u003c replica.getVisibleLength()) {\n        throw new IOException(\"THIS IS NOT SUPPOSED TO HAPPEN:\"\n            + \" getBytesOnDisk() \u003c getVisibleLength(), rip\u003d\" + replica);\n      }\n\n      //check the replica\u0027s files\n      checkReplicaFiles(replica);\n    }\n\n    //check generation stamp\n    if (replica.getGenerationStamp() \u003c block.getGenerationStamp()) {\n      throw new IOException(\n          \"replica.getGenerationStamp() \u003c block.getGenerationStamp(), block\u003d\"\n          + block + \", replica\u003d\" + replica);\n    }\n\n    //check recovery id\n    if (replica.getGenerationStamp() \u003e\u003d recoveryId) {\n      throw new IOException(\"THIS IS NOT SUPPOSED TO HAPPEN:\"\n          + \" replica.getGenerationStamp() \u003e\u003d recoveryId \u003d \" + recoveryId\n          + \", block\u003d\" + block + \", replica\u003d\" + replica);\n    }\n\n    //check RUR\n    final ReplicaInfo rur;\n    if (replica.getState() \u003d\u003d ReplicaState.RUR) {\n      rur \u003d replica;\n      if (rur.getRecoveryID() \u003e\u003d recoveryId) {\n        throw new RecoveryInProgressException(\n            \"rur.getRecoveryID() \u003e\u003d recoveryId \u003d \" + recoveryId\n            + \", block\u003d\" + block + \", rur\u003d\" + rur);\n      }\n      final long oldRecoveryID \u003d rur.getRecoveryID();\n      rur.setRecoveryID(recoveryId);\n      LOG.info(\"initReplicaRecovery: update recovery id for \" + block\n          + \" from \" + oldRecoveryID + \" to \" + recoveryId);\n    }\n    else {\n      rur \u003d new ReplicaBuilder(ReplicaState.RUR)\n          .from(replica).setRecoveryId(recoveryId).build();\n      map.add(bpid, rur);\n      LOG.info(\"initReplicaRecovery: changing replica state for \"\n          + block + \" from \" + replica.getState()\n          + \" to \" + rur.getState());\n      if (replica.getState() \u003d\u003d ReplicaState.TEMPORARY || replica\n          .getState() \u003d\u003d ReplicaState.RBW) {\n        ((ReplicaInPipeline) replica).releaseAllBytesReserved();\n      }\n    }\n    return rur.createInfo();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
      "extendedDetails": {}
    },
    "86c9862bec0248d671e657aa56094a2919b8ac14": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10636. Modify ReplicaInfo to remove the assumption that replica metadata and data are stored in java.io.File. (Virajith Jalaparti via lei)\n",
      "commitDate": "13/09/16 12:54 PM",
      "commitName": "86c9862bec0248d671e657aa56094a2919b8ac14",
      "commitAuthor": "Lei Xu",
      "commitDateOld": "10/09/16 6:22 PM",
      "commitNameOld": "a99bf26a0899bcc4307c3a242c8414eaef555aa7",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 2.77,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,66 +1,68 @@\n   static ReplicaRecoveryInfo initReplicaRecoveryImpl(String bpid, ReplicaMap map,\n       Block block, long recoveryId)\n           throws IOException, MustStopExistingWriter {\n     final ReplicaInfo replica \u003d map.get(bpid, block.getBlockId());\n     LOG.info(\"initReplicaRecovery: \" + block + \", recoveryId\u003d\" + recoveryId\n         + \", replica\u003d\" + replica);\n \n     //check replica\n     if (replica \u003d\u003d null) {\n       return null;\n     }\n \n     //stop writer if there is any\n-    if (replica instanceof ReplicaInPipeline) {\n+    if (replica.getState() \u003d\u003d ReplicaState.TEMPORARY ||\n+        replica.getState() \u003d\u003d ReplicaState.RBW) {\n       final ReplicaInPipeline rip \u003d (ReplicaInPipeline)replica;\n       if (!rip.attemptToSetWriter(null, Thread.currentThread())) {\n         throw new MustStopExistingWriter(rip);\n       }\n \n       //check replica bytes on disk.\n-      if (rip.getBytesOnDisk() \u003c rip.getVisibleLength()) {\n+      if (replica.getBytesOnDisk() \u003c replica.getVisibleLength()) {\n         throw new IOException(\"THIS IS NOT SUPPOSED TO HAPPEN:\"\n-            + \" getBytesOnDisk() \u003c getVisibleLength(), rip\u003d\" + rip);\n+            + \" getBytesOnDisk() \u003c getVisibleLength(), rip\u003d\" + replica);\n       }\n \n       //check the replica\u0027s files\n-      checkReplicaFiles(rip);\n+      checkReplicaFiles(replica);\n     }\n \n     //check generation stamp\n     if (replica.getGenerationStamp() \u003c block.getGenerationStamp()) {\n       throw new IOException(\n           \"replica.getGenerationStamp() \u003c block.getGenerationStamp(), block\u003d\"\n           + block + \", replica\u003d\" + replica);\n     }\n \n     //check recovery id\n     if (replica.getGenerationStamp() \u003e\u003d recoveryId) {\n       throw new IOException(\"THIS IS NOT SUPPOSED TO HAPPEN:\"\n           + \" replica.getGenerationStamp() \u003e\u003d recoveryId \u003d \" + recoveryId\n           + \", block\u003d\" + block + \", replica\u003d\" + replica);\n     }\n \n     //check RUR\n-    final ReplicaUnderRecovery rur;\n+    final ReplicaInfo rur;\n     if (replica.getState() \u003d\u003d ReplicaState.RUR) {\n-      rur \u003d (ReplicaUnderRecovery)replica;\n+      rur \u003d replica;\n       if (rur.getRecoveryID() \u003e\u003d recoveryId) {\n         throw new RecoveryInProgressException(\n             \"rur.getRecoveryID() \u003e\u003d recoveryId \u003d \" + recoveryId\n             + \", block\u003d\" + block + \", rur\u003d\" + rur);\n       }\n       final long oldRecoveryID \u003d rur.getRecoveryID();\n       rur.setRecoveryID(recoveryId);\n       LOG.info(\"initReplicaRecovery: update recovery id for \" + block\n           + \" from \" + oldRecoveryID + \" to \" + recoveryId);\n     }\n     else {\n-      rur \u003d new ReplicaUnderRecovery(replica, recoveryId);\n+      rur \u003d new ReplicaBuilder(ReplicaState.RUR)\n+          .from(replica).setRecoveryId(recoveryId).build();\n       map.add(bpid, rur);\n       LOG.info(\"initReplicaRecovery: changing replica state for \"\n           + block + \" from \" + replica.getState()\n           + \" to \" + rur.getState());\n     }\n     return rur.createInfo();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static ReplicaRecoveryInfo initReplicaRecoveryImpl(String bpid, ReplicaMap map,\n      Block block, long recoveryId)\n          throws IOException, MustStopExistingWriter {\n    final ReplicaInfo replica \u003d map.get(bpid, block.getBlockId());\n    LOG.info(\"initReplicaRecovery: \" + block + \", recoveryId\u003d\" + recoveryId\n        + \", replica\u003d\" + replica);\n\n    //check replica\n    if (replica \u003d\u003d null) {\n      return null;\n    }\n\n    //stop writer if there is any\n    if (replica.getState() \u003d\u003d ReplicaState.TEMPORARY ||\n        replica.getState() \u003d\u003d ReplicaState.RBW) {\n      final ReplicaInPipeline rip \u003d (ReplicaInPipeline)replica;\n      if (!rip.attemptToSetWriter(null, Thread.currentThread())) {\n        throw new MustStopExistingWriter(rip);\n      }\n\n      //check replica bytes on disk.\n      if (replica.getBytesOnDisk() \u003c replica.getVisibleLength()) {\n        throw new IOException(\"THIS IS NOT SUPPOSED TO HAPPEN:\"\n            + \" getBytesOnDisk() \u003c getVisibleLength(), rip\u003d\" + replica);\n      }\n\n      //check the replica\u0027s files\n      checkReplicaFiles(replica);\n    }\n\n    //check generation stamp\n    if (replica.getGenerationStamp() \u003c block.getGenerationStamp()) {\n      throw new IOException(\n          \"replica.getGenerationStamp() \u003c block.getGenerationStamp(), block\u003d\"\n          + block + \", replica\u003d\" + replica);\n    }\n\n    //check recovery id\n    if (replica.getGenerationStamp() \u003e\u003d recoveryId) {\n      throw new IOException(\"THIS IS NOT SUPPOSED TO HAPPEN:\"\n          + \" replica.getGenerationStamp() \u003e\u003d recoveryId \u003d \" + recoveryId\n          + \", block\u003d\" + block + \", replica\u003d\" + replica);\n    }\n\n    //check RUR\n    final ReplicaInfo rur;\n    if (replica.getState() \u003d\u003d ReplicaState.RUR) {\n      rur \u003d replica;\n      if (rur.getRecoveryID() \u003e\u003d recoveryId) {\n        throw new RecoveryInProgressException(\n            \"rur.getRecoveryID() \u003e\u003d recoveryId \u003d \" + recoveryId\n            + \", block\u003d\" + block + \", rur\u003d\" + rur);\n      }\n      final long oldRecoveryID \u003d rur.getRecoveryID();\n      rur.setRecoveryID(recoveryId);\n      LOG.info(\"initReplicaRecovery: update recovery id for \" + block\n          + \" from \" + oldRecoveryID + \" to \" + recoveryId);\n    }\n    else {\n      rur \u003d new ReplicaBuilder(ReplicaState.RUR)\n          .from(replica).setRecoveryId(recoveryId).build();\n      map.add(bpid, rur);\n      LOG.info(\"initReplicaRecovery: changing replica state for \"\n          + block + \" from \" + replica.getState()\n          + \" to \" + rur.getState());\n    }\n    return rur.createInfo();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
      "extendedDetails": {}
    },
    "f6b1a818124cc42688c4c5acaf537d96cf00e43b": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-8496. Calling stopWriter() with FSDatasetImpl lock held may block other threads (cmccabe)\n",
      "commitDate": "04/04/16 6:02 PM",
      "commitName": "f6b1a818124cc42688c4c5acaf537d96cf00e43b",
      "commitAuthor": "Colin Patrick Mccabe",
      "diff": "@@ -0,0 +1,66 @@\n+  static ReplicaRecoveryInfo initReplicaRecoveryImpl(String bpid, ReplicaMap map,\n+      Block block, long recoveryId)\n+          throws IOException, MustStopExistingWriter {\n+    final ReplicaInfo replica \u003d map.get(bpid, block.getBlockId());\n+    LOG.info(\"initReplicaRecovery: \" + block + \", recoveryId\u003d\" + recoveryId\n+        + \", replica\u003d\" + replica);\n+\n+    //check replica\n+    if (replica \u003d\u003d null) {\n+      return null;\n+    }\n+\n+    //stop writer if there is any\n+    if (replica instanceof ReplicaInPipeline) {\n+      final ReplicaInPipeline rip \u003d (ReplicaInPipeline)replica;\n+      if (!rip.attemptToSetWriter(null, Thread.currentThread())) {\n+        throw new MustStopExistingWriter(rip);\n+      }\n+\n+      //check replica bytes on disk.\n+      if (rip.getBytesOnDisk() \u003c rip.getVisibleLength()) {\n+        throw new IOException(\"THIS IS NOT SUPPOSED TO HAPPEN:\"\n+            + \" getBytesOnDisk() \u003c getVisibleLength(), rip\u003d\" + rip);\n+      }\n+\n+      //check the replica\u0027s files\n+      checkReplicaFiles(rip);\n+    }\n+\n+    //check generation stamp\n+    if (replica.getGenerationStamp() \u003c block.getGenerationStamp()) {\n+      throw new IOException(\n+          \"replica.getGenerationStamp() \u003c block.getGenerationStamp(), block\u003d\"\n+          + block + \", replica\u003d\" + replica);\n+    }\n+\n+    //check recovery id\n+    if (replica.getGenerationStamp() \u003e\u003d recoveryId) {\n+      throw new IOException(\"THIS IS NOT SUPPOSED TO HAPPEN:\"\n+          + \" replica.getGenerationStamp() \u003e\u003d recoveryId \u003d \" + recoveryId\n+          + \", block\u003d\" + block + \", replica\u003d\" + replica);\n+    }\n+\n+    //check RUR\n+    final ReplicaUnderRecovery rur;\n+    if (replica.getState() \u003d\u003d ReplicaState.RUR) {\n+      rur \u003d (ReplicaUnderRecovery)replica;\n+      if (rur.getRecoveryID() \u003e\u003d recoveryId) {\n+        throw new RecoveryInProgressException(\n+            \"rur.getRecoveryID() \u003e\u003d recoveryId \u003d \" + recoveryId\n+            + \", block\u003d\" + block + \", rur\u003d\" + rur);\n+      }\n+      final long oldRecoveryID \u003d rur.getRecoveryID();\n+      rur.setRecoveryID(recoveryId);\n+      LOG.info(\"initReplicaRecovery: update recovery id for \" + block\n+          + \" from \" + oldRecoveryID + \" to \" + recoveryId);\n+    }\n+    else {\n+      rur \u003d new ReplicaUnderRecovery(replica, recoveryId);\n+      map.add(bpid, rur);\n+      LOG.info(\"initReplicaRecovery: changing replica state for \"\n+          + block + \" from \" + replica.getState()\n+          + \" to \" + rur.getState());\n+    }\n+    return rur.createInfo();\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  static ReplicaRecoveryInfo initReplicaRecoveryImpl(String bpid, ReplicaMap map,\n      Block block, long recoveryId)\n          throws IOException, MustStopExistingWriter {\n    final ReplicaInfo replica \u003d map.get(bpid, block.getBlockId());\n    LOG.info(\"initReplicaRecovery: \" + block + \", recoveryId\u003d\" + recoveryId\n        + \", replica\u003d\" + replica);\n\n    //check replica\n    if (replica \u003d\u003d null) {\n      return null;\n    }\n\n    //stop writer if there is any\n    if (replica instanceof ReplicaInPipeline) {\n      final ReplicaInPipeline rip \u003d (ReplicaInPipeline)replica;\n      if (!rip.attemptToSetWriter(null, Thread.currentThread())) {\n        throw new MustStopExistingWriter(rip);\n      }\n\n      //check replica bytes on disk.\n      if (rip.getBytesOnDisk() \u003c rip.getVisibleLength()) {\n        throw new IOException(\"THIS IS NOT SUPPOSED TO HAPPEN:\"\n            + \" getBytesOnDisk() \u003c getVisibleLength(), rip\u003d\" + rip);\n      }\n\n      //check the replica\u0027s files\n      checkReplicaFiles(rip);\n    }\n\n    //check generation stamp\n    if (replica.getGenerationStamp() \u003c block.getGenerationStamp()) {\n      throw new IOException(\n          \"replica.getGenerationStamp() \u003c block.getGenerationStamp(), block\u003d\"\n          + block + \", replica\u003d\" + replica);\n    }\n\n    //check recovery id\n    if (replica.getGenerationStamp() \u003e\u003d recoveryId) {\n      throw new IOException(\"THIS IS NOT SUPPOSED TO HAPPEN:\"\n          + \" replica.getGenerationStamp() \u003e\u003d recoveryId \u003d \" + recoveryId\n          + \", block\u003d\" + block + \", replica\u003d\" + replica);\n    }\n\n    //check RUR\n    final ReplicaUnderRecovery rur;\n    if (replica.getState() \u003d\u003d ReplicaState.RUR) {\n      rur \u003d (ReplicaUnderRecovery)replica;\n      if (rur.getRecoveryID() \u003e\u003d recoveryId) {\n        throw new RecoveryInProgressException(\n            \"rur.getRecoveryID() \u003e\u003d recoveryId \u003d \" + recoveryId\n            + \", block\u003d\" + block + \", rur\u003d\" + rur);\n      }\n      final long oldRecoveryID \u003d rur.getRecoveryID();\n      rur.setRecoveryID(recoveryId);\n      LOG.info(\"initReplicaRecovery: update recovery id for \" + block\n          + \" from \" + oldRecoveryID + \" to \" + recoveryId);\n    }\n    else {\n      rur \u003d new ReplicaUnderRecovery(replica, recoveryId);\n      map.add(bpid, rur);\n      LOG.info(\"initReplicaRecovery: changing replica state for \"\n          + block + \" from \" + replica.getState()\n          + \" to \" + rur.getState());\n    }\n    return rur.createInfo();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java"
    }
  }
}