{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "PBImageTextWriter.java",
  "functionName": "getParentPath",
  "functionId": "getParentPath___inode-long",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/offlineImageViewer/PBImageTextWriter.java",
  "functionStartLine": 451,
  "functionEndLine": 470,
  "numCommitsSeen": 9,
  "timeTaken": 2020,
  "changeHistory": [
    "fb10803dfa67394650072bdea327296f8ad2a744",
    "9d494f0c0eaa05417f3a3e88487d878d1731da36",
    "1e72d98c69bef3526cf0eb617de69e0b6d2fc13c",
    "caf7298e49f646a40023af999f62d61846fde5e2"
  ],
  "changeHistoryShort": {
    "fb10803dfa67394650072bdea327296f8ad2a744": "Ybodychange",
    "9d494f0c0eaa05417f3a3e88487d878d1731da36": "Ybodychange",
    "1e72d98c69bef3526cf0eb617de69e0b6d2fc13c": "Ybodychange",
    "caf7298e49f646a40023af999f62d61846fde5e2": "Yintroduced"
  },
  "changeHistoryDetails": {
    "fb10803dfa67394650072bdea327296f8ad2a744": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13818. Extend OIV to detect FSImage corruption. Contributed by Adam Antal.\n\nSigned-off-by: Wei-Chiu Chuang \u003cweichiu@apache.org\u003e\n",
      "commitDate": "03/12/18 10:34 AM",
      "commitName": "fb10803dfa67394650072bdea327296f8ad2a744",
      "commitAuthor": "Adam Antal",
      "commitDateOld": "26/10/18 4:41 PM",
      "commitNameOld": "4f10d7e23fc0b757a9e94bc448187a6211b90f10",
      "commitAuthorOld": "Anu Engineer",
      "daysBetweenCommits": 37.79,
      "commitsBetweenForRepo": 254,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,30 +1,20 @@\n     public String getParentPath(long inode) throws IOException {\n       if (inode \u003d\u003d INodeId.ROOT_INODE_ID) {\n         return \"/\";\n       }\n-      byte[] bytes \u003d dirChildMap.get(toBytes(inode));\n-      if (bytes \u003d\u003d null) {\n-        // The inode is an INodeReference, which is generated from snapshot.\n-        // For delimited oiv tool, no need to print out metadata in snapshots.\n-        PBImageTextWriter.ignoreSnapshotName(inode);\n-      }\n-      if (bytes.length !\u003d 8) {\n-        throw new IOException(\n-            \"bytes array length error. Actual length is \" + bytes.length);\n-      }\n-      long parent \u003d toLong(bytes);\n+      long parent \u003d getFromDirChildMap(inode);\n       if (!dirPathCache.containsKey(parent)) {\n-        bytes \u003d dirMap.get(toBytes(parent));\n+        byte[] bytes \u003d dirMap.get(toBytes(parent));\n         if (parent !\u003d INodeId.ROOT_INODE_ID \u0026\u0026 bytes \u003d\u003d null) {\n           // The parent is an INodeReference, which is generated from snapshot.\n           // For delimited oiv tool, no need to print out metadata in snapshots.\n-          PBImageTextWriter.ignoreSnapshotName(parent);\n+          throw PBImageTextWriter.createIgnoredSnapshotException(inode);\n         }\n         String parentName \u003d toString(bytes);\n         String parentPath \u003d\n             new Path(getParentPath(parent),\n-                parentName.isEmpty()? \"/\" : parentName).toString();\n+                parentName.isEmpty() ? \"/\" : parentName).toString();\n         dirPathCache.put(parent, parentPath);\n       }\n       return dirPathCache.get(parent);\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public String getParentPath(long inode) throws IOException {\n      if (inode \u003d\u003d INodeId.ROOT_INODE_ID) {\n        return \"/\";\n      }\n      long parent \u003d getFromDirChildMap(inode);\n      if (!dirPathCache.containsKey(parent)) {\n        byte[] bytes \u003d dirMap.get(toBytes(parent));\n        if (parent !\u003d INodeId.ROOT_INODE_ID \u0026\u0026 bytes \u003d\u003d null) {\n          // The parent is an INodeReference, which is generated from snapshot.\n          // For delimited oiv tool, no need to print out metadata in snapshots.\n          throw PBImageTextWriter.createIgnoredSnapshotException(inode);\n        }\n        String parentName \u003d toString(bytes);\n        String parentPath \u003d\n            new Path(getParentPath(parent),\n                parentName.isEmpty() ? \"/\" : parentName).toString();\n        dirPathCache.put(parent, parentPath);\n      }\n      return dirPathCache.get(parent);\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/offlineImageViewer/PBImageTextWriter.java",
      "extendedDetails": {}
    },
    "9d494f0c0eaa05417f3a3e88487d878d1731da36": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9721. Allow Delimited PB OIV tool to run upon fsimage that contains INodeReference. (Xiao Chen via lei)\n",
      "commitDate": "02/02/16 10:42 AM",
      "commitName": "9d494f0c0eaa05417f3a3e88487d878d1731da36",
      "commitAuthor": "Lei Xu",
      "commitDateOld": "07/04/15 2:23 PM",
      "commitNameOld": "1e72d98c69bef3526cf0eb617de69e0b6d2fc13c",
      "commitAuthorOld": "cnauroth",
      "daysBetweenCommits": 300.89,
      "commitsBetweenForRepo": 2355,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,24 +1,30 @@\n     public String getParentPath(long inode) throws IOException {\n       if (inode \u003d\u003d INodeId.ROOT_INODE_ID) {\n         return \"/\";\n       }\n       byte[] bytes \u003d dirChildMap.get(toBytes(inode));\n-      Preconditions.checkState(bytes !\u003d null \u0026\u0026 bytes.length \u003d\u003d 8,\n-          \"Can not find parent directory for inode %s, \"\n-              + \"fsimage might be corrupted\", inode);\n+      if (bytes \u003d\u003d null) {\n+        // The inode is an INodeReference, which is generated from snapshot.\n+        // For delimited oiv tool, no need to print out metadata in snapshots.\n+        PBImageTextWriter.ignoreSnapshotName(inode);\n+      }\n+      if (bytes.length !\u003d 8) {\n+        throw new IOException(\n+            \"bytes array length error. Actual length is \" + bytes.length);\n+      }\n       long parent \u003d toLong(bytes);\n       if (!dirPathCache.containsKey(parent)) {\n         bytes \u003d dirMap.get(toBytes(parent));\n-        if (parent !\u003d INodeId.ROOT_INODE_ID) {\n-          Preconditions.checkState(bytes !\u003d null,\n-              \"Can not find parent directory for inode %s, \"\n-                  + \", the fsimage might be corrupted.\", parent);\n+        if (parent !\u003d INodeId.ROOT_INODE_ID \u0026\u0026 bytes \u003d\u003d null) {\n+          // The parent is an INodeReference, which is generated from snapshot.\n+          // For delimited oiv tool, no need to print out metadata in snapshots.\n+          PBImageTextWriter.ignoreSnapshotName(parent);\n         }\n         String parentName \u003d toString(bytes);\n         String parentPath \u003d\n             new Path(getParentPath(parent),\n                 parentName.isEmpty()? \"/\" : parentName).toString();\n         dirPathCache.put(parent, parentPath);\n       }\n       return dirPathCache.get(parent);\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public String getParentPath(long inode) throws IOException {\n      if (inode \u003d\u003d INodeId.ROOT_INODE_ID) {\n        return \"/\";\n      }\n      byte[] bytes \u003d dirChildMap.get(toBytes(inode));\n      if (bytes \u003d\u003d null) {\n        // The inode is an INodeReference, which is generated from snapshot.\n        // For delimited oiv tool, no need to print out metadata in snapshots.\n        PBImageTextWriter.ignoreSnapshotName(inode);\n      }\n      if (bytes.length !\u003d 8) {\n        throw new IOException(\n            \"bytes array length error. Actual length is \" + bytes.length);\n      }\n      long parent \u003d toLong(bytes);\n      if (!dirPathCache.containsKey(parent)) {\n        bytes \u003d dirMap.get(toBytes(parent));\n        if (parent !\u003d INodeId.ROOT_INODE_ID \u0026\u0026 bytes \u003d\u003d null) {\n          // The parent is an INodeReference, which is generated from snapshot.\n          // For delimited oiv tool, no need to print out metadata in snapshots.\n          PBImageTextWriter.ignoreSnapshotName(parent);\n        }\n        String parentName \u003d toString(bytes);\n        String parentPath \u003d\n            new Path(getParentPath(parent),\n                parentName.isEmpty()? \"/\" : parentName).toString();\n        dirPathCache.put(parent, parentPath);\n      }\n      return dirPathCache.get(parent);\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/offlineImageViewer/PBImageTextWriter.java",
      "extendedDetails": {}
    },
    "1e72d98c69bef3526cf0eb617de69e0b6d2fc13c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8038. PBImageDelimitedTextWriter#getEntry output HDFS path in platform-specific format. Contributed by Xiaoyu Yao.\n",
      "commitDate": "07/04/15 2:23 PM",
      "commitName": "1e72d98c69bef3526cf0eb617de69e0b6d2fc13c",
      "commitAuthor": "cnauroth",
      "commitDateOld": "17/02/15 4:56 AM",
      "commitNameOld": "2f0f756b26ea83e142a5b9379fa75862c2fc6ad5",
      "commitAuthorOld": "Tsuyoshi Ozawa",
      "daysBetweenCommits": 49.35,
      "commitsBetweenForRepo": 427,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,23 +1,24 @@\n     public String getParentPath(long inode) throws IOException {\n       if (inode \u003d\u003d INodeId.ROOT_INODE_ID) {\n         return \"/\";\n       }\n       byte[] bytes \u003d dirChildMap.get(toBytes(inode));\n       Preconditions.checkState(bytes !\u003d null \u0026\u0026 bytes.length \u003d\u003d 8,\n           \"Can not find parent directory for inode %s, \"\n               + \"fsimage might be corrupted\", inode);\n       long parent \u003d toLong(bytes);\n       if (!dirPathCache.containsKey(parent)) {\n         bytes \u003d dirMap.get(toBytes(parent));\n         if (parent !\u003d INodeId.ROOT_INODE_ID) {\n           Preconditions.checkState(bytes !\u003d null,\n               \"Can not find parent directory for inode %s, \"\n                   + \", the fsimage might be corrupted.\", parent);\n         }\n         String parentName \u003d toString(bytes);\n         String parentPath \u003d\n-            new File(getParentPath(parent), parentName).toString();\n+            new Path(getParentPath(parent),\n+                parentName.isEmpty()? \"/\" : parentName).toString();\n         dirPathCache.put(parent, parentPath);\n       }\n       return dirPathCache.get(parent);\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public String getParentPath(long inode) throws IOException {\n      if (inode \u003d\u003d INodeId.ROOT_INODE_ID) {\n        return \"/\";\n      }\n      byte[] bytes \u003d dirChildMap.get(toBytes(inode));\n      Preconditions.checkState(bytes !\u003d null \u0026\u0026 bytes.length \u003d\u003d 8,\n          \"Can not find parent directory for inode %s, \"\n              + \"fsimage might be corrupted\", inode);\n      long parent \u003d toLong(bytes);\n      if (!dirPathCache.containsKey(parent)) {\n        bytes \u003d dirMap.get(toBytes(parent));\n        if (parent !\u003d INodeId.ROOT_INODE_ID) {\n          Preconditions.checkState(bytes !\u003d null,\n              \"Can not find parent directory for inode %s, \"\n                  + \", the fsimage might be corrupted.\", parent);\n        }\n        String parentName \u003d toString(bytes);\n        String parentPath \u003d\n            new Path(getParentPath(parent),\n                parentName.isEmpty()? \"/\" : parentName).toString();\n        dirPathCache.put(parent, parentPath);\n      }\n      return dirPathCache.get(parent);\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/offlineImageViewer/PBImageTextWriter.java",
      "extendedDetails": {}
    },
    "caf7298e49f646a40023af999f62d61846fde5e2": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-6673. Add delimited format support to PB OIV tool. Contributed by Eddy Xu.\n",
      "commitDate": "28/01/15 12:36 PM",
      "commitName": "caf7298e49f646a40023af999f62d61846fde5e2",
      "commitAuthor": "Andrew Wang",
      "diff": "@@ -0,0 +1,23 @@\n+    public String getParentPath(long inode) throws IOException {\n+      if (inode \u003d\u003d INodeId.ROOT_INODE_ID) {\n+        return \"/\";\n+      }\n+      byte[] bytes \u003d dirChildMap.get(toBytes(inode));\n+      Preconditions.checkState(bytes !\u003d null \u0026\u0026 bytes.length \u003d\u003d 8,\n+          \"Can not find parent directory for inode %s, \"\n+              + \"fsimage might be corrupted\", inode);\n+      long parent \u003d toLong(bytes);\n+      if (!dirPathCache.containsKey(parent)) {\n+        bytes \u003d dirMap.get(toBytes(parent));\n+        if (parent !\u003d INodeId.ROOT_INODE_ID) {\n+          Preconditions.checkState(bytes !\u003d null,\n+              \"Can not find parent directory for inode %s, \"\n+                  + \", the fsimage might be corrupted.\", parent);\n+        }\n+        String parentName \u003d toString(bytes);\n+        String parentPath \u003d\n+            new File(getParentPath(parent), parentName).toString();\n+        dirPathCache.put(parent, parentPath);\n+      }\n+      return dirPathCache.get(parent);\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    public String getParentPath(long inode) throws IOException {\n      if (inode \u003d\u003d INodeId.ROOT_INODE_ID) {\n        return \"/\";\n      }\n      byte[] bytes \u003d dirChildMap.get(toBytes(inode));\n      Preconditions.checkState(bytes !\u003d null \u0026\u0026 bytes.length \u003d\u003d 8,\n          \"Can not find parent directory for inode %s, \"\n              + \"fsimage might be corrupted\", inode);\n      long parent \u003d toLong(bytes);\n      if (!dirPathCache.containsKey(parent)) {\n        bytes \u003d dirMap.get(toBytes(parent));\n        if (parent !\u003d INodeId.ROOT_INODE_ID) {\n          Preconditions.checkState(bytes !\u003d null,\n              \"Can not find parent directory for inode %s, \"\n                  + \", the fsimage might be corrupted.\", parent);\n        }\n        String parentName \u003d toString(bytes);\n        String parentPath \u003d\n            new File(getParentPath(parent), parentName).toString();\n        dirPathCache.put(parent, parentPath);\n      }\n      return dirPathCache.get(parent);\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/offlineImageViewer/PBImageTextWriter.java"
    }
  }
}