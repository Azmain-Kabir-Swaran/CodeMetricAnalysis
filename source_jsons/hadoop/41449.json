{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FairScheduler.java",
  "functionName": "update",
  "functionId": "update",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
  "functionStartLine": 355,
  "functionEndLine": 393,
  "numCommitsSeen": 228,
  "timeTaken": 9200,
  "changeHistory": [
    "8ee7080e5da15d8841d5f7bbf72ca033905c9751",
    "bb34ae955496c1aa595dc1186153d605a41f5378",
    "d5b71e4175c13679d451710be150fc461a661263",
    "4db9cc70d0178703fb28f451eb84d97f2bf63af8",
    "2148b83993fd8ce73bcbc7677c57ee5028a59cd4",
    "9b85053583a3560f93062b656061d11b1b9c664f",
    "10468529a9b858bd945e7ecb063c9c1438efa474",
    "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f",
    "20d389ce61eaacb5ddfb329015f50e96ad894f8d",
    "179cab81e0bde1af0cba6131ccccf16ff127358a",
    "1dcaba9a7aa27f7ca4ba693e3abb56ab3c59c8a7",
    "14864e9c7c879c15b5fa2d1776614ec83152918f",
    "4d211d5fde5a4f17f7bf2cc62636167b49a79cbd",
    "82f3454f5ac1f1c457e668e2cee12b4dcc800ee1",
    "6d5f8ebed60e59d772e0dcee0b069f8db95f6ccc",
    "7545d8bf996e5d060d5d613bf769ec52a62d428b",
    "51ccb87031eda6a2b75be098a88f1d89ea82c610",
    "df55edd5dec9c944a6c38f08d6f1f0fdb901c880",
    "ae6f1123f57c09a9cf5eed3e8c4659481417dc21",
    "933a6d2c1ec8d3b373674e3e74eb472863fc464d",
    "e1fdf62123625e4ba399af02f8aad500637d29d1",
    "1ef64e64c05ae5318cd4cb47d03a0494d742fb7c"
  ],
  "changeHistoryShort": {
    "8ee7080e5da15d8841d5f7bbf72ca033905c9751": "Ybodychange",
    "bb34ae955496c1aa595dc1186153d605a41f5378": "Ybodychange",
    "d5b71e4175c13679d451710be150fc461a661263": "Ybodychange",
    "4db9cc70d0178703fb28f451eb84d97f2bf63af8": "Ybodychange",
    "2148b83993fd8ce73bcbc7677c57ee5028a59cd4": "Ymodifierchange",
    "9b85053583a3560f93062b656061d11b1b9c664f": "Ybodychange",
    "10468529a9b858bd945e7ecb063c9c1438efa474": "Ybodychange",
    "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f": "Ymultichange(Ymodifierchange,Ybodychange)",
    "20d389ce61eaacb5ddfb329015f50e96ad894f8d": "Ybodychange",
    "179cab81e0bde1af0cba6131ccccf16ff127358a": "Ybodychange",
    "1dcaba9a7aa27f7ca4ba693e3abb56ab3c59c8a7": "Ybodychange",
    "14864e9c7c879c15b5fa2d1776614ec83152918f": "Ybodychange",
    "4d211d5fde5a4f17f7bf2cc62636167b49a79cbd": "Ybodychange",
    "82f3454f5ac1f1c457e668e2cee12b4dcc800ee1": "Ybodychange",
    "6d5f8ebed60e59d772e0dcee0b069f8db95f6ccc": "Ybodychange",
    "7545d8bf996e5d060d5d613bf769ec52a62d428b": "Ybodychange",
    "51ccb87031eda6a2b75be098a88f1d89ea82c610": "Ybodychange",
    "df55edd5dec9c944a6c38f08d6f1f0fdb901c880": "Ybodychange",
    "ae6f1123f57c09a9cf5eed3e8c4659481417dc21": "Ybodychange",
    "933a6d2c1ec8d3b373674e3e74eb472863fc464d": "Ymultichange(Ymodifierchange,Ybodychange)",
    "e1fdf62123625e4ba399af02f8aad500637d29d1": "Yfilerename",
    "1ef64e64c05ae5318cd4cb47d03a0494d742fb7c": "Yintroduced"
  },
  "changeHistoryDetails": {
    "8ee7080e5da15d8841d5f7bbf72ca033905c9751": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7665. Allow FS scheduler state dump to be turned on/off separately from FS debug log. (Wilfred Spiegelenburg via Haibo Chen)\n",
      "commitDate": "09/01/18 4:45 PM",
      "commitName": "8ee7080e5da15d8841d5f7bbf72ca033905c9751",
      "commitAuthor": "Haibo Chen",
      "commitDateOld": "08/01/18 4:19 PM",
      "commitNameOld": "59ab5da0a0337c49a58bc9b2db9d1a89f4d5b9dd",
      "commitAuthorOld": "Ray Chiang",
      "daysBetweenCommits": 1.02,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,39 +1,39 @@\n   public void update() {\n     // Storing start time for fsOpDurations\n     long start \u003d getClock().getTime();\n     FSQueue rootQueue \u003d queueMgr.getRootQueue();\n \n     // Update demands and fairshares\n     writeLock.lock();\n     try {\n       // Recursively update demands for all queues\n       rootQueue.updateDemand();\n       rootQueue.update(getClusterResource());\n \n       // Update metrics\n       updateRootQueueMetrics();\n     } finally {\n       writeLock.unlock();\n     }\n \n     readLock.lock();\n     try {\n       // Update starvation stats and identify starved applications\n       if (shouldAttemptPreemption()) {\n         for (FSLeafQueue queue : queueMgr.getLeafQueues()) {\n           queue.updateStarvedApps();\n         }\n       }\n \n       // Log debug information\n-      if (LOG.isDebugEnabled()) {\n+      if (STATE_DUMP_LOG.isDebugEnabled()) {\n         if (--updatesToSkipForDebug \u003c 0) {\n           updatesToSkipForDebug \u003d UPDATE_DEBUG_FREQUENCY;\n           dumpSchedulerState();\n         }\n       }\n     } finally {\n       readLock.unlock();\n     }\n     fsOpDurations.addUpdateThreadRunDuration(getClock().getTime() - start);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void update() {\n    // Storing start time for fsOpDurations\n    long start \u003d getClock().getTime();\n    FSQueue rootQueue \u003d queueMgr.getRootQueue();\n\n    // Update demands and fairshares\n    writeLock.lock();\n    try {\n      // Recursively update demands for all queues\n      rootQueue.updateDemand();\n      rootQueue.update(getClusterResource());\n\n      // Update metrics\n      updateRootQueueMetrics();\n    } finally {\n      writeLock.unlock();\n    }\n\n    readLock.lock();\n    try {\n      // Update starvation stats and identify starved applications\n      if (shouldAttemptPreemption()) {\n        for (FSLeafQueue queue : queueMgr.getLeafQueues()) {\n          queue.updateStarvedApps();\n        }\n      }\n\n      // Log debug information\n      if (STATE_DUMP_LOG.isDebugEnabled()) {\n        if (--updatesToSkipForDebug \u003c 0) {\n          updatesToSkipForDebug \u003d UPDATE_DEBUG_FREQUENCY;\n          dumpSchedulerState();\n        }\n      }\n    } finally {\n      readLock.unlock();\n    }\n    fsOpDurations.addUpdateThreadRunDuration(getClock().getTime() - start);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "bb34ae955496c1aa595dc1186153d605a41f5378": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7146. Many RM unit tests failing with FairScheduler (rkanter)\n",
      "commitDate": "13/09/17 3:44 PM",
      "commitName": "bb34ae955496c1aa595dc1186153d605a41f5378",
      "commitAuthor": "Robert Kanter",
      "commitDateOld": "12/09/17 9:19 AM",
      "commitNameOld": "6708ac330147b2d3816a31f2ee83e09c41fe0dd9",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 1.27,
      "commitsBetweenForRepo": 48,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,36 +1,39 @@\n   public void update() {\n+    // Storing start time for fsOpDurations\n+    long start \u003d getClock().getTime();\n     FSQueue rootQueue \u003d queueMgr.getRootQueue();\n \n     // Update demands and fairshares\n     writeLock.lock();\n     try {\n       // Recursively update demands for all queues\n       rootQueue.updateDemand();\n       rootQueue.update(getClusterResource());\n \n       // Update metrics\n       updateRootQueueMetrics();\n     } finally {\n       writeLock.unlock();\n     }\n \n     readLock.lock();\n     try {\n       // Update starvation stats and identify starved applications\n       if (shouldAttemptPreemption()) {\n         for (FSLeafQueue queue : queueMgr.getLeafQueues()) {\n           queue.updateStarvedApps();\n         }\n       }\n \n       // Log debug information\n       if (LOG.isDebugEnabled()) {\n         if (--updatesToSkipForDebug \u003c 0) {\n           updatesToSkipForDebug \u003d UPDATE_DEBUG_FREQUENCY;\n           dumpSchedulerState();\n         }\n       }\n     } finally {\n       readLock.unlock();\n     }\n+    fsOpDurations.addUpdateThreadRunDuration(getClock().getTime() - start);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void update() {\n    // Storing start time for fsOpDurations\n    long start \u003d getClock().getTime();\n    FSQueue rootQueue \u003d queueMgr.getRootQueue();\n\n    // Update demands and fairshares\n    writeLock.lock();\n    try {\n      // Recursively update demands for all queues\n      rootQueue.updateDemand();\n      rootQueue.update(getClusterResource());\n\n      // Update metrics\n      updateRootQueueMetrics();\n    } finally {\n      writeLock.unlock();\n    }\n\n    readLock.lock();\n    try {\n      // Update starvation stats and identify starved applications\n      if (shouldAttemptPreemption()) {\n        for (FSLeafQueue queue : queueMgr.getLeafQueues()) {\n          queue.updateStarvedApps();\n        }\n      }\n\n      // Log debug information\n      if (LOG.isDebugEnabled()) {\n        if (--updatesToSkipForDebug \u003c 0) {\n          updatesToSkipForDebug \u003d UPDATE_DEBUG_FREQUENCY;\n          dumpSchedulerState();\n        }\n      }\n    } finally {\n      readLock.unlock();\n    }\n    fsOpDurations.addUpdateThreadRunDuration(getClock().getTime() - start);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "d5b71e4175c13679d451710be150fc461a661263": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6246. Identifying starved apps does not need the scheduler writelock\n(Contributed by Karthik Kambatla via Daniel Templeton)\n",
      "commitDate": "31/05/17 3:48 PM",
      "commitName": "d5b71e4175c13679d451710be150fc461a661263",
      "commitAuthor": "Daniel Templeton",
      "commitDateOld": "12/04/17 2:21 PM",
      "commitNameOld": "c3375175d616e0380560f89d491b6b9753a8f3e1",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 49.06,
      "commitsBetweenForRepo": 250,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,25 +1,36 @@\n   public void update() {\n+    FSQueue rootQueue \u003d queueMgr.getRootQueue();\n+\n+    // Update demands and fairshares\n+    writeLock.lock();\n     try {\n-      writeLock.lock();\n-\n-      FSQueue rootQueue \u003d queueMgr.getRootQueue();\n-\n       // Recursively update demands for all queues\n       rootQueue.updateDemand();\n-\n-      Resource clusterResource \u003d getClusterResource();\n-      rootQueue.update(clusterResource, shouldAttemptPreemption());\n+      rootQueue.update(getClusterResource());\n \n       // Update metrics\n       updateRootQueueMetrics();\n+    } finally {\n+      writeLock.unlock();\n+    }\n \n+    readLock.lock();\n+    try {\n+      // Update starvation stats and identify starved applications\n+      if (shouldAttemptPreemption()) {\n+        for (FSLeafQueue queue : queueMgr.getLeafQueues()) {\n+          queue.updateStarvedApps();\n+        }\n+      }\n+\n+      // Log debug information\n       if (LOG.isDebugEnabled()) {\n         if (--updatesToSkipForDebug \u003c 0) {\n           updatesToSkipForDebug \u003d UPDATE_DEBUG_FREQUENCY;\n           dumpSchedulerState();\n         }\n       }\n     } finally {\n-      writeLock.unlock();\n+      readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void update() {\n    FSQueue rootQueue \u003d queueMgr.getRootQueue();\n\n    // Update demands and fairshares\n    writeLock.lock();\n    try {\n      // Recursively update demands for all queues\n      rootQueue.updateDemand();\n      rootQueue.update(getClusterResource());\n\n      // Update metrics\n      updateRootQueueMetrics();\n    } finally {\n      writeLock.unlock();\n    }\n\n    readLock.lock();\n    try {\n      // Update starvation stats and identify starved applications\n      if (shouldAttemptPreemption()) {\n        for (FSLeafQueue queue : queueMgr.getLeafQueues()) {\n          queue.updateStarvedApps();\n        }\n      }\n\n      // Log debug information\n      if (LOG.isDebugEnabled()) {\n        if (--updatesToSkipForDebug \u003c 0) {\n          updatesToSkipForDebug \u003d UPDATE_DEBUG_FREQUENCY;\n          dumpSchedulerState();\n        }\n      }\n    } finally {\n      readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "4db9cc70d0178703fb28f451eb84d97f2bf63af8": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6042. Dump scheduler and queue state information into FairScheduler DEBUG log. (Yufei Gu via rchiang)\n",
      "commitDate": "10/03/17 4:13 PM",
      "commitName": "4db9cc70d0178703fb28f451eb84d97f2bf63af8",
      "commitAuthor": "Ray Chiang",
      "commitDateOld": "03/03/17 1:04 PM",
      "commitNameOld": "2148b83993fd8ce73bcbc7677c57ee5028a59cd4",
      "commitAuthorOld": "Ray Chiang",
      "daysBetweenCommits": 7.13,
      "commitsBetweenForRepo": 55,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,30 +1,25 @@\n   public void update() {\n     try {\n       writeLock.lock();\n \n       FSQueue rootQueue \u003d queueMgr.getRootQueue();\n \n       // Recursively update demands for all queues\n       rootQueue.updateDemand();\n \n       Resource clusterResource \u003d getClusterResource();\n       rootQueue.update(clusterResource, shouldAttemptPreemption());\n \n       // Update metrics\n       updateRootQueueMetrics();\n \n       if (LOG.isDebugEnabled()) {\n         if (--updatesToSkipForDebug \u003c 0) {\n           updatesToSkipForDebug \u003d UPDATE_DEBUG_FREQUENCY;\n-          LOG.debug(\"Cluster Capacity: \" + clusterResource +\n-              \"  Allocations: \" + rootMetrics.getAllocatedResources() +\n-              \"  Availability: \" + Resource.newInstance(\n-              rootMetrics.getAvailableMB(),\n-              rootMetrics.getAvailableVirtualCores()) +\n-              \"  Demand: \" + rootQueue.getDemand());\n+          dumpSchedulerState();\n         }\n       }\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void update() {\n    try {\n      writeLock.lock();\n\n      FSQueue rootQueue \u003d queueMgr.getRootQueue();\n\n      // Recursively update demands for all queues\n      rootQueue.updateDemand();\n\n      Resource clusterResource \u003d getClusterResource();\n      rootQueue.update(clusterResource, shouldAttemptPreemption());\n\n      // Update metrics\n      updateRootQueueMetrics();\n\n      if (LOG.isDebugEnabled()) {\n        if (--updatesToSkipForDebug \u003c 0) {\n          updatesToSkipForDebug \u003d UPDATE_DEBUG_FREQUENCY;\n          dumpSchedulerState();\n        }\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "2148b83993fd8ce73bcbc7677c57ee5028a59cd4": {
      "type": "Ymodifierchange",
      "commitMessage": "YARN-6218. Fix TestAMRMClient when using FairScheduler. (Miklos Szegedi via rchiang)\n",
      "commitDate": "03/03/17 1:04 PM",
      "commitName": "2148b83993fd8ce73bcbc7677c57ee5028a59cd4",
      "commitAuthor": "Ray Chiang",
      "commitDateOld": "28/02/17 10:35 AM",
      "commitNameOld": "eac6b4c35c50e555c2f1b5f913bb2c4d839f1ff4",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 3.1,
      "commitsBetweenForRepo": 23,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,30 +1,30 @@\n-  protected void update() {\n+  public void update() {\n     try {\n       writeLock.lock();\n \n       FSQueue rootQueue \u003d queueMgr.getRootQueue();\n \n       // Recursively update demands for all queues\n       rootQueue.updateDemand();\n \n       Resource clusterResource \u003d getClusterResource();\n       rootQueue.update(clusterResource, shouldAttemptPreemption());\n \n       // Update metrics\n       updateRootQueueMetrics();\n \n       if (LOG.isDebugEnabled()) {\n         if (--updatesToSkipForDebug \u003c 0) {\n           updatesToSkipForDebug \u003d UPDATE_DEBUG_FREQUENCY;\n           LOG.debug(\"Cluster Capacity: \" + clusterResource +\n               \"  Allocations: \" + rootMetrics.getAllocatedResources() +\n               \"  Availability: \" + Resource.newInstance(\n               rootMetrics.getAvailableMB(),\n               rootMetrics.getAvailableVirtualCores()) +\n               \"  Demand: \" + rootQueue.getDemand());\n         }\n       }\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void update() {\n    try {\n      writeLock.lock();\n\n      FSQueue rootQueue \u003d queueMgr.getRootQueue();\n\n      // Recursively update demands for all queues\n      rootQueue.updateDemand();\n\n      Resource clusterResource \u003d getClusterResource();\n      rootQueue.update(clusterResource, shouldAttemptPreemption());\n\n      // Update metrics\n      updateRootQueueMetrics();\n\n      if (LOG.isDebugEnabled()) {\n        if (--updatesToSkipForDebug \u003c 0) {\n          updatesToSkipForDebug \u003d UPDATE_DEBUG_FREQUENCY;\n          LOG.debug(\"Cluster Capacity: \" + clusterResource +\n              \"  Allocations: \" + rootMetrics.getAllocatedResources() +\n              \"  Availability: \" + Resource.newInstance(\n              rootMetrics.getAvailableMB(),\n              rootMetrics.getAvailableVirtualCores()) +\n              \"  Demand: \" + rootQueue.getDemand());\n        }\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {
        "oldValue": "[protected]",
        "newValue": "[public]"
      }
    },
    "9b85053583a3560f93062b656061d11b1b9c664f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6112. UpdateCallDuration is calculated only when debug logging is enabled. (Yufei Gu via kasha)\n",
      "commitDate": "09/02/17 1:09 PM",
      "commitName": "9b85053583a3560f93062b656061d11b1b9c664f",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "09/01/17 6:14 PM",
      "commitNameOld": "945db55f2e6521d33d4f90bbb09179b0feba5e7a",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 30.79,
      "commitsBetweenForRepo": 143,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,30 @@\n   protected void update() {\n     try {\n       writeLock.lock();\n-      long start \u003d getClock().getTime();\n \n       FSQueue rootQueue \u003d queueMgr.getRootQueue();\n \n       // Recursively update demands for all queues\n       rootQueue.updateDemand();\n \n       Resource clusterResource \u003d getClusterResource();\n       rootQueue.update(clusterResource, shouldAttemptPreemption());\n \n       // Update metrics\n       updateRootQueueMetrics();\n \n       if (LOG.isDebugEnabled()) {\n         if (--updatesToSkipForDebug \u003c 0) {\n           updatesToSkipForDebug \u003d UPDATE_DEBUG_FREQUENCY;\n           LOG.debug(\"Cluster Capacity: \" + clusterResource +\n               \"  Allocations: \" + rootMetrics.getAllocatedResources() +\n               \"  Availability: \" + Resource.newInstance(\n               rootMetrics.getAvailableMB(),\n               rootMetrics.getAvailableVirtualCores()) +\n               \"  Demand: \" + rootQueue.getDemand());\n         }\n-\n-        long duration \u003d getClock().getTime() - start;\n-        fsOpDurations.addUpdateCallDuration(duration);\n       }\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void update() {\n    try {\n      writeLock.lock();\n\n      FSQueue rootQueue \u003d queueMgr.getRootQueue();\n\n      // Recursively update demands for all queues\n      rootQueue.updateDemand();\n\n      Resource clusterResource \u003d getClusterResource();\n      rootQueue.update(clusterResource, shouldAttemptPreemption());\n\n      // Update metrics\n      updateRootQueueMetrics();\n\n      if (LOG.isDebugEnabled()) {\n        if (--updatesToSkipForDebug \u003c 0) {\n          updatesToSkipForDebug \u003d UPDATE_DEBUG_FREQUENCY;\n          LOG.debug(\"Cluster Capacity: \" + clusterResource +\n              \"  Allocations: \" + rootMetrics.getAllocatedResources() +\n              \"  Availability: \" + Resource.newInstance(\n              rootMetrics.getAvailableMB(),\n              rootMetrics.getAvailableVirtualCores()) +\n              \"  Demand: \" + rootQueue.getDemand());\n        }\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "10468529a9b858bd945e7ecb063c9c1438efa474": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4752. Improved preemption in FairScheduler. (kasha)\n\nContains:\nYARN-5605. Preempt containers (all on one node) to meet the requirement of starved applications\nYARN-5821. Drop left-over preemption-related code and clean up method visibilities in the Schedulable hierarchy\nYARN-5783. Verify identification of starved applications.\nYARN-5819. Verify fairshare and minshare preemption\nYARN-5885. Cleanup YARN-4752 branch for merge\n\nChange-Id: Iee0962377d019dd64dc69a020725d2eaf360858c\n",
      "commitDate": "23/11/16 9:48 PM",
      "commitName": "10468529a9b858bd945e7ecb063c9c1438efa474",
      "commitAuthor": "Daniel Templeton",
      "commitDateOld": "22/11/16 11:16 AM",
      "commitNameOld": "83cc7263af632939dc3b2ee58d8f03f98ed4d96a",
      "commitAuthorOld": "Daniel Templeton",
      "daysBetweenCommits": 1.44,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,34 @@\n   protected void update() {\n     try {\n       writeLock.lock();\n       long start \u003d getClock().getTime();\n-      updateStarvationStats(); // Determine if any queues merit preemption\n \n       FSQueue rootQueue \u003d queueMgr.getRootQueue();\n \n       // Recursively update demands for all queues\n       rootQueue.updateDemand();\n \n       Resource clusterResource \u003d getClusterResource();\n-      rootQueue.setFairShare(clusterResource);\n-      // Recursively compute fair shares for all queues\n-      // and update metrics\n-      rootQueue.recomputeShares();\n+      rootQueue.update(clusterResource, shouldAttemptPreemption());\n+\n+      // Update metrics\n       updateRootQueueMetrics();\n \n       if (LOG.isDebugEnabled()) {\n         if (--updatesToSkipForDebug \u003c 0) {\n           updatesToSkipForDebug \u003d UPDATE_DEBUG_FREQUENCY;\n-          LOG.debug(\"Cluster Capacity: \" + clusterResource + \"  Allocations: \"\n-              + rootMetrics.getAllocatedResources() + \"  Availability: \"\n-              + Resource.newInstance(rootMetrics.getAvailableMB(),\n-              rootMetrics.getAvailableVirtualCores()) + \"  Demand: \" + rootQueue\n-              .getDemand());\n+          LOG.debug(\"Cluster Capacity: \" + clusterResource +\n+              \"  Allocations: \" + rootMetrics.getAllocatedResources() +\n+              \"  Availability: \" + Resource.newInstance(\n+              rootMetrics.getAvailableMB(),\n+              rootMetrics.getAvailableVirtualCores()) +\n+              \"  Demand: \" + rootQueue.getDemand());\n         }\n-      }\n \n-      long duration \u003d getClock().getTime() - start;\n-      fsOpDurations.addUpdateCallDuration(duration);\n+        long duration \u003d getClock().getTime() - start;\n+        fsOpDurations.addUpdateCallDuration(duration);\n+      }\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void update() {\n    try {\n      writeLock.lock();\n      long start \u003d getClock().getTime();\n\n      FSQueue rootQueue \u003d queueMgr.getRootQueue();\n\n      // Recursively update demands for all queues\n      rootQueue.updateDemand();\n\n      Resource clusterResource \u003d getClusterResource();\n      rootQueue.update(clusterResource, shouldAttemptPreemption());\n\n      // Update metrics\n      updateRootQueueMetrics();\n\n      if (LOG.isDebugEnabled()) {\n        if (--updatesToSkipForDebug \u003c 0) {\n          updatesToSkipForDebug \u003d UPDATE_DEBUG_FREQUENCY;\n          LOG.debug(\"Cluster Capacity: \" + clusterResource +\n              \"  Allocations: \" + rootMetrics.getAllocatedResources() +\n              \"  Availability: \" + Resource.newInstance(\n              rootMetrics.getAvailableMB(),\n              rootMetrics.getAvailableVirtualCores()) +\n              \"  Demand: \" + rootQueue.getDemand());\n        }\n\n        long duration \u003d getClock().getTime() - start;\n        fsOpDurations.addUpdateCallDuration(duration);\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f": {
      "type": "Ymultichange(Ymodifierchange,Ybodychange)",
      "commitMessage": "YARN-3139. Improve locks in AbstractYarnScheduler/CapacityScheduler/FairScheduler. Contributed by Wangda Tan\n",
      "commitDate": "04/10/16 5:23 PM",
      "commitName": "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f",
      "commitAuthor": "Jian He",
      "subchanges": [
        {
          "type": "Ymodifierchange",
          "commitMessage": "YARN-3139. Improve locks in AbstractYarnScheduler/CapacityScheduler/FairScheduler. Contributed by Wangda Tan\n",
          "commitDate": "04/10/16 5:23 PM",
          "commitName": "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f",
          "commitAuthor": "Jian He",
          "commitDateOld": "03/10/16 6:03 AM",
          "commitNameOld": "0da54e8848764c71a31473516d23ada582013f8c",
          "commitAuthorOld": "Karthik Kambatla",
          "daysBetweenCommits": 1.47,
          "commitsBetweenForRepo": 14,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,31 +1,35 @@\n-  protected synchronized void update() {\n-    long start \u003d getClock().getTime();\n-    updateStarvationStats(); // Determine if any queues merit preemption\n+  protected void update() {\n+    try {\n+      writeLock.lock();\n+      long start \u003d getClock().getTime();\n+      updateStarvationStats(); // Determine if any queues merit preemption\n \n-    FSQueue rootQueue \u003d queueMgr.getRootQueue();\n+      FSQueue rootQueue \u003d queueMgr.getRootQueue();\n \n-    // Recursively update demands for all queues\n-    rootQueue.updateDemand();\n+      // Recursively update demands for all queues\n+      rootQueue.updateDemand();\n \n-    Resource clusterResource \u003d getClusterResource();\n-    rootQueue.setFairShare(clusterResource);\n-    // Recursively compute fair shares for all queues\n-    // and update metrics\n-    rootQueue.recomputeShares();\n-    updateRootQueueMetrics();\n+      Resource clusterResource \u003d getClusterResource();\n+      rootQueue.setFairShare(clusterResource);\n+      // Recursively compute fair shares for all queues\n+      // and update metrics\n+      rootQueue.recomputeShares();\n+      updateRootQueueMetrics();\n \n-    if (LOG.isDebugEnabled()) {\n-      if (--updatesToSkipForDebug \u003c 0) {\n-        updatesToSkipForDebug \u003d UPDATE_DEBUG_FREQUENCY;\n-        LOG.debug(\"Cluster Capacity: \" + clusterResource +\n-            \"  Allocations: \" + rootMetrics.getAllocatedResources() +\n-            \"  Availability: \" + Resource.newInstance(\n-            rootMetrics.getAvailableMB(),\n-            rootMetrics.getAvailableVirtualCores()) +\n-            \"  Demand: \" + rootQueue.getDemand());\n+      if (LOG.isDebugEnabled()) {\n+        if (--updatesToSkipForDebug \u003c 0) {\n+          updatesToSkipForDebug \u003d UPDATE_DEBUG_FREQUENCY;\n+          LOG.debug(\"Cluster Capacity: \" + clusterResource + \"  Allocations: \"\n+              + rootMetrics.getAllocatedResources() + \"  Availability: \"\n+              + Resource.newInstance(rootMetrics.getAvailableMB(),\n+              rootMetrics.getAvailableVirtualCores()) + \"  Demand: \" + rootQueue\n+              .getDemand());\n+        }\n       }\n-    }\n \n-    long duration \u003d getClock().getTime() - start;\n-    fsOpDurations.addUpdateCallDuration(duration);\n+      long duration \u003d getClock().getTime() - start;\n+      fsOpDurations.addUpdateCallDuration(duration);\n+    } finally {\n+      writeLock.unlock();\n+    }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected void update() {\n    try {\n      writeLock.lock();\n      long start \u003d getClock().getTime();\n      updateStarvationStats(); // Determine if any queues merit preemption\n\n      FSQueue rootQueue \u003d queueMgr.getRootQueue();\n\n      // Recursively update demands for all queues\n      rootQueue.updateDemand();\n\n      Resource clusterResource \u003d getClusterResource();\n      rootQueue.setFairShare(clusterResource);\n      // Recursively compute fair shares for all queues\n      // and update metrics\n      rootQueue.recomputeShares();\n      updateRootQueueMetrics();\n\n      if (LOG.isDebugEnabled()) {\n        if (--updatesToSkipForDebug \u003c 0) {\n          updatesToSkipForDebug \u003d UPDATE_DEBUG_FREQUENCY;\n          LOG.debug(\"Cluster Capacity: \" + clusterResource + \"  Allocations: \"\n              + rootMetrics.getAllocatedResources() + \"  Availability: \"\n              + Resource.newInstance(rootMetrics.getAvailableMB(),\n              rootMetrics.getAvailableVirtualCores()) + \"  Demand: \" + rootQueue\n              .getDemand());\n        }\n      }\n\n      long duration \u003d getClock().getTime() - start;\n      fsOpDurations.addUpdateCallDuration(duration);\n    } finally {\n      writeLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
          "extendedDetails": {
            "oldValue": "[protected, synchronized]",
            "newValue": "[protected]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-3139. Improve locks in AbstractYarnScheduler/CapacityScheduler/FairScheduler. Contributed by Wangda Tan\n",
          "commitDate": "04/10/16 5:23 PM",
          "commitName": "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f",
          "commitAuthor": "Jian He",
          "commitDateOld": "03/10/16 6:03 AM",
          "commitNameOld": "0da54e8848764c71a31473516d23ada582013f8c",
          "commitAuthorOld": "Karthik Kambatla",
          "daysBetweenCommits": 1.47,
          "commitsBetweenForRepo": 14,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,31 +1,35 @@\n-  protected synchronized void update() {\n-    long start \u003d getClock().getTime();\n-    updateStarvationStats(); // Determine if any queues merit preemption\n+  protected void update() {\n+    try {\n+      writeLock.lock();\n+      long start \u003d getClock().getTime();\n+      updateStarvationStats(); // Determine if any queues merit preemption\n \n-    FSQueue rootQueue \u003d queueMgr.getRootQueue();\n+      FSQueue rootQueue \u003d queueMgr.getRootQueue();\n \n-    // Recursively update demands for all queues\n-    rootQueue.updateDemand();\n+      // Recursively update demands for all queues\n+      rootQueue.updateDemand();\n \n-    Resource clusterResource \u003d getClusterResource();\n-    rootQueue.setFairShare(clusterResource);\n-    // Recursively compute fair shares for all queues\n-    // and update metrics\n-    rootQueue.recomputeShares();\n-    updateRootQueueMetrics();\n+      Resource clusterResource \u003d getClusterResource();\n+      rootQueue.setFairShare(clusterResource);\n+      // Recursively compute fair shares for all queues\n+      // and update metrics\n+      rootQueue.recomputeShares();\n+      updateRootQueueMetrics();\n \n-    if (LOG.isDebugEnabled()) {\n-      if (--updatesToSkipForDebug \u003c 0) {\n-        updatesToSkipForDebug \u003d UPDATE_DEBUG_FREQUENCY;\n-        LOG.debug(\"Cluster Capacity: \" + clusterResource +\n-            \"  Allocations: \" + rootMetrics.getAllocatedResources() +\n-            \"  Availability: \" + Resource.newInstance(\n-            rootMetrics.getAvailableMB(),\n-            rootMetrics.getAvailableVirtualCores()) +\n-            \"  Demand: \" + rootQueue.getDemand());\n+      if (LOG.isDebugEnabled()) {\n+        if (--updatesToSkipForDebug \u003c 0) {\n+          updatesToSkipForDebug \u003d UPDATE_DEBUG_FREQUENCY;\n+          LOG.debug(\"Cluster Capacity: \" + clusterResource + \"  Allocations: \"\n+              + rootMetrics.getAllocatedResources() + \"  Availability: \"\n+              + Resource.newInstance(rootMetrics.getAvailableMB(),\n+              rootMetrics.getAvailableVirtualCores()) + \"  Demand: \" + rootQueue\n+              .getDemand());\n+        }\n       }\n-    }\n \n-    long duration \u003d getClock().getTime() - start;\n-    fsOpDurations.addUpdateCallDuration(duration);\n+      long duration \u003d getClock().getTime() - start;\n+      fsOpDurations.addUpdateCallDuration(duration);\n+    } finally {\n+      writeLock.unlock();\n+    }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected void update() {\n    try {\n      writeLock.lock();\n      long start \u003d getClock().getTime();\n      updateStarvationStats(); // Determine if any queues merit preemption\n\n      FSQueue rootQueue \u003d queueMgr.getRootQueue();\n\n      // Recursively update demands for all queues\n      rootQueue.updateDemand();\n\n      Resource clusterResource \u003d getClusterResource();\n      rootQueue.setFairShare(clusterResource);\n      // Recursively compute fair shares for all queues\n      // and update metrics\n      rootQueue.recomputeShares();\n      updateRootQueueMetrics();\n\n      if (LOG.isDebugEnabled()) {\n        if (--updatesToSkipForDebug \u003c 0) {\n          updatesToSkipForDebug \u003d UPDATE_DEBUG_FREQUENCY;\n          LOG.debug(\"Cluster Capacity: \" + clusterResource + \"  Allocations: \"\n              + rootMetrics.getAllocatedResources() + \"  Availability: \"\n              + Resource.newInstance(rootMetrics.getAvailableMB(),\n              rootMetrics.getAvailableVirtualCores()) + \"  Demand: \" + rootQueue\n              .getDemand());\n        }\n      }\n\n      long duration \u003d getClock().getTime() - start;\n      fsOpDurations.addUpdateCallDuration(duration);\n    } finally {\n      writeLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
          "extendedDetails": {}
        }
      ]
    },
    "20d389ce61eaacb5ddfb329015f50e96ad894f8d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4719. Add a helper library to maintain node state and allows common queries. (kasha)\n",
      "commitDate": "14/03/16 2:19 PM",
      "commitName": "20d389ce61eaacb5ddfb329015f50e96ad894f8d",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "06/03/16 7:46 PM",
      "commitNameOld": "e1ccc9622b2f1fbefea1862fa74d1fb56d8eb264",
      "commitAuthorOld": "Zhihai Xu",
      "daysBetweenCommits": 7.73,
      "commitsBetweenForRepo": 44,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,30 +1,31 @@\n   protected synchronized void update() {\n     long start \u003d getClock().getTime();\n     updateStarvationStats(); // Determine if any queues merit preemption\n \n     FSQueue rootQueue \u003d queueMgr.getRootQueue();\n \n     // Recursively update demands for all queues\n     rootQueue.updateDemand();\n \n+    Resource clusterResource \u003d getClusterResource();\n     rootQueue.setFairShare(clusterResource);\n     // Recursively compute fair shares for all queues\n     // and update metrics\n     rootQueue.recomputeShares();\n     updateRootQueueMetrics();\n \n     if (LOG.isDebugEnabled()) {\n       if (--updatesToSkipForDebug \u003c 0) {\n         updatesToSkipForDebug \u003d UPDATE_DEBUG_FREQUENCY;\n         LOG.debug(\"Cluster Capacity: \" + clusterResource +\n             \"  Allocations: \" + rootMetrics.getAllocatedResources() +\n             \"  Availability: \" + Resource.newInstance(\n             rootMetrics.getAvailableMB(),\n             rootMetrics.getAvailableVirtualCores()) +\n             \"  Demand: \" + rootQueue.getDemand());\n       }\n     }\n \n     long duration \u003d getClock().getTime() - start;\n     fsOpDurations.addUpdateCallDuration(duration);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void update() {\n    long start \u003d getClock().getTime();\n    updateStarvationStats(); // Determine if any queues merit preemption\n\n    FSQueue rootQueue \u003d queueMgr.getRootQueue();\n\n    // Recursively update demands for all queues\n    rootQueue.updateDemand();\n\n    Resource clusterResource \u003d getClusterResource();\n    rootQueue.setFairShare(clusterResource);\n    // Recursively compute fair shares for all queues\n    // and update metrics\n    rootQueue.recomputeShares();\n    updateRootQueueMetrics();\n\n    if (LOG.isDebugEnabled()) {\n      if (--updatesToSkipForDebug \u003c 0) {\n        updatesToSkipForDebug \u003d UPDATE_DEBUG_FREQUENCY;\n        LOG.debug(\"Cluster Capacity: \" + clusterResource +\n            \"  Allocations: \" + rootMetrics.getAllocatedResources() +\n            \"  Availability: \" + Resource.newInstance(\n            rootMetrics.getAvailableMB(),\n            rootMetrics.getAvailableVirtualCores()) +\n            \"  Demand: \" + rootQueue.getDemand());\n      }\n    }\n\n    long duration \u003d getClock().getTime() - start;\n    fsOpDurations.addUpdateCallDuration(duration);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "179cab81e0bde1af0cba6131ccccf16ff127358a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2712. TestWorkPreservingRMRestart: Augment FS tests with queue and headroom checks. (Tsuyoshi Ozawa via kasha)\n",
      "commitDate": "30/10/14 12:29 AM",
      "commitName": "179cab81e0bde1af0cba6131ccccf16ff127358a",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "25/09/14 5:42 PM",
      "commitNameOld": "f4357240a6f81065d91d5f443ed8fc8cd2a14a8f",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 34.28,
      "commitsBetweenForRepo": 321,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,30 @@\n   protected synchronized void update() {\n     long start \u003d getClock().getTime();\n     updateStarvationStats(); // Determine if any queues merit preemption\n \n     FSQueue rootQueue \u003d queueMgr.getRootQueue();\n \n     // Recursively update demands for all queues\n     rootQueue.updateDemand();\n \n     rootQueue.setFairShare(clusterResource);\n     // Recursively compute fair shares for all queues\n     // and update metrics\n     rootQueue.recomputeShares();\n+    updateRootQueueMetrics();\n \n     if (LOG.isDebugEnabled()) {\n       if (--updatesToSkipForDebug \u003c 0) {\n         updatesToSkipForDebug \u003d UPDATE_DEBUG_FREQUENCY;\n         LOG.debug(\"Cluster Capacity: \" + clusterResource +\n             \"  Allocations: \" + rootMetrics.getAllocatedResources() +\n             \"  Availability: \" + Resource.newInstance(\n             rootMetrics.getAvailableMB(),\n             rootMetrics.getAvailableVirtualCores()) +\n             \"  Demand: \" + rootQueue.getDemand());\n       }\n     }\n \n     long duration \u003d getClock().getTime() - start;\n     fsOpDurations.addUpdateCallDuration(duration);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void update() {\n    long start \u003d getClock().getTime();\n    updateStarvationStats(); // Determine if any queues merit preemption\n\n    FSQueue rootQueue \u003d queueMgr.getRootQueue();\n\n    // Recursively update demands for all queues\n    rootQueue.updateDemand();\n\n    rootQueue.setFairShare(clusterResource);\n    // Recursively compute fair shares for all queues\n    // and update metrics\n    rootQueue.recomputeShares();\n    updateRootQueueMetrics();\n\n    if (LOG.isDebugEnabled()) {\n      if (--updatesToSkipForDebug \u003c 0) {\n        updatesToSkipForDebug \u003d UPDATE_DEBUG_FREQUENCY;\n        LOG.debug(\"Cluster Capacity: \" + clusterResource +\n            \"  Allocations: \" + rootMetrics.getAllocatedResources() +\n            \"  Availability: \" + Resource.newInstance(\n            rootMetrics.getAvailableMB(),\n            rootMetrics.getAvailableVirtualCores()) +\n            \"  Demand: \" + rootQueue.getDemand());\n      }\n    }\n\n    long duration \u003d getClock().getTime() - start;\n    fsOpDurations.addUpdateCallDuration(duration);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "1dcaba9a7aa27f7ca4ba693e3abb56ab3c59c8a7": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2394. FairScheduler: Configure fairSharePreemptionThreshold per queue. (Wei Yan via kasha)\n",
      "commitDate": "03/09/14 10:27 AM",
      "commitName": "1dcaba9a7aa27f7ca4ba693e3abb56ab3c59c8a7",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "30/08/14 1:17 AM",
      "commitNameOld": "0f34e6f3873aee0f4932740ca790c6dd2a13b5d9",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 4.38,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,29 @@\n   protected synchronized void update() {\n     long start \u003d getClock().getTime();\n-    updatePreemptionVariables(); // Determine if any queues merit preemption\n+    updateStarvationStats(); // Determine if any queues merit preemption\n \n     FSQueue rootQueue \u003d queueMgr.getRootQueue();\n \n     // Recursively update demands for all queues\n     rootQueue.updateDemand();\n \n     rootQueue.setFairShare(clusterResource);\n     // Recursively compute fair shares for all queues\n     // and update metrics\n     rootQueue.recomputeShares();\n \n     if (LOG.isDebugEnabled()) {\n       if (--updatesToSkipForDebug \u003c 0) {\n         updatesToSkipForDebug \u003d UPDATE_DEBUG_FREQUENCY;\n         LOG.debug(\"Cluster Capacity: \" + clusterResource +\n             \"  Allocations: \" + rootMetrics.getAllocatedResources() +\n             \"  Availability: \" + Resource.newInstance(\n             rootMetrics.getAvailableMB(),\n             rootMetrics.getAvailableVirtualCores()) +\n             \"  Demand: \" + rootQueue.getDemand());\n       }\n     }\n \n     long duration \u003d getClock().getTime() - start;\n     fsOpDurations.addUpdateCallDuration(duration);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void update() {\n    long start \u003d getClock().getTime();\n    updateStarvationStats(); // Determine if any queues merit preemption\n\n    FSQueue rootQueue \u003d queueMgr.getRootQueue();\n\n    // Recursively update demands for all queues\n    rootQueue.updateDemand();\n\n    rootQueue.setFairShare(clusterResource);\n    // Recursively compute fair shares for all queues\n    // and update metrics\n    rootQueue.recomputeShares();\n\n    if (LOG.isDebugEnabled()) {\n      if (--updatesToSkipForDebug \u003c 0) {\n        updatesToSkipForDebug \u003d UPDATE_DEBUG_FREQUENCY;\n        LOG.debug(\"Cluster Capacity: \" + clusterResource +\n            \"  Allocations: \" + rootMetrics.getAllocatedResources() +\n            \"  Availability: \" + Resource.newInstance(\n            rootMetrics.getAvailableMB(),\n            rootMetrics.getAvailableVirtualCores()) +\n            \"  Demand: \" + rootQueue.getDemand());\n      }\n    }\n\n    long duration \u003d getClock().getTime() - start;\n    fsOpDurations.addUpdateCallDuration(duration);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "14864e9c7c879c15b5fa2d1776614ec83152918f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2352. FairScheduler: Collect metrics on duration of critical methods that affect performance. (kasha)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1616769 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/08/14 7:17 AM",
      "commitName": "14864e9c7c879c15b5fa2d1776614ec83152918f",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "29/07/14 10:41 AM",
      "commitNameOld": "c0b49ff10728bb70bb60e6cb5973976f0466d247",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 9.86,
      "commitsBetweenForRepo": 74,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,25 +1,29 @@\n   protected synchronized void update() {\n+    long start \u003d getClock().getTime();\n     updatePreemptionVariables(); // Determine if any queues merit preemption\n \n     FSQueue rootQueue \u003d queueMgr.getRootQueue();\n \n     // Recursively update demands for all queues\n     rootQueue.updateDemand();\n \n     rootQueue.setFairShare(clusterResource);\n     // Recursively compute fair shares for all queues\n     // and update metrics\n     rootQueue.recomputeShares();\n \n     if (LOG.isDebugEnabled()) {\n       if (--updatesToSkipForDebug \u003c 0) {\n         updatesToSkipForDebug \u003d UPDATE_DEBUG_FREQUENCY;\n         LOG.debug(\"Cluster Capacity: \" + clusterResource +\n             \"  Allocations: \" + rootMetrics.getAllocatedResources() +\n             \"  Availability: \" + Resource.newInstance(\n             rootMetrics.getAvailableMB(),\n             rootMetrics.getAvailableVirtualCores()) +\n             \"  Demand: \" + rootQueue.getDemand());\n       }\n     }\n+\n+    long duration \u003d getClock().getTime() - start;\n+    fsOpDurations.addUpdateCallDuration(duration);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void update() {\n    long start \u003d getClock().getTime();\n    updatePreemptionVariables(); // Determine if any queues merit preemption\n\n    FSQueue rootQueue \u003d queueMgr.getRootQueue();\n\n    // Recursively update demands for all queues\n    rootQueue.updateDemand();\n\n    rootQueue.setFairShare(clusterResource);\n    // Recursively compute fair shares for all queues\n    // and update metrics\n    rootQueue.recomputeShares();\n\n    if (LOG.isDebugEnabled()) {\n      if (--updatesToSkipForDebug \u003c 0) {\n        updatesToSkipForDebug \u003d UPDATE_DEBUG_FREQUENCY;\n        LOG.debug(\"Cluster Capacity: \" + clusterResource +\n            \"  Allocations: \" + rootMetrics.getAllocatedResources() +\n            \"  Availability: \" + Resource.newInstance(\n            rootMetrics.getAvailableMB(),\n            rootMetrics.getAvailableVirtualCores()) +\n            \"  Demand: \" + rootQueue.getDemand());\n      }\n    }\n\n    long duration \u003d getClock().getTime() - start;\n    fsOpDurations.addUpdateCallDuration(duration);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "4d211d5fde5a4f17f7bf2cc62636167b49a79cbd": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2274. FairScheduler: Add debug information about cluster capacity, availability and reservations. (kasha)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1609942 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/07/14 8:10 AM",
      "commitName": "4d211d5fde5a4f17f7bf2cc62636167b49a79cbd",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "04/07/14 8:16 AM",
      "commitNameOld": "5644f529f33b49e7da8ce6fe4067c6ad5b3f2b2c",
      "commitAuthorOld": "Sanford Ryza",
      "daysBetweenCommits": 8.0,
      "commitsBetweenForRepo": 47,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,13 +1,25 @@\n   protected synchronized void update() {\n     updatePreemptionVariables(); // Determine if any queues merit preemption\n \n     FSQueue rootQueue \u003d queueMgr.getRootQueue();\n \n     // Recursively update demands for all queues\n     rootQueue.updateDemand();\n \n     rootQueue.setFairShare(clusterResource);\n     // Recursively compute fair shares for all queues\n     // and update metrics\n     rootQueue.recomputeShares();\n+\n+    if (LOG.isDebugEnabled()) {\n+      if (--updatesToSkipForDebug \u003c 0) {\n+        updatesToSkipForDebug \u003d UPDATE_DEBUG_FREQUENCY;\n+        LOG.debug(\"Cluster Capacity: \" + clusterResource +\n+            \"  Allocations: \" + rootMetrics.getAllocatedResources() +\n+            \"  Availability: \" + Resource.newInstance(\n+            rootMetrics.getAvailableMB(),\n+            rootMetrics.getAvailableVirtualCores()) +\n+            \"  Demand: \" + rootQueue.getDemand());\n+      }\n+    }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void update() {\n    updatePreemptionVariables(); // Determine if any queues merit preemption\n\n    FSQueue rootQueue \u003d queueMgr.getRootQueue();\n\n    // Recursively update demands for all queues\n    rootQueue.updateDemand();\n\n    rootQueue.setFairShare(clusterResource);\n    // Recursively compute fair shares for all queues\n    // and update metrics\n    rootQueue.recomputeShares();\n\n    if (LOG.isDebugEnabled()) {\n      if (--updatesToSkipForDebug \u003c 0) {\n        updatesToSkipForDebug \u003d UPDATE_DEBUG_FREQUENCY;\n        LOG.debug(\"Cluster Capacity: \" + clusterResource +\n            \"  Allocations: \" + rootMetrics.getAllocatedResources() +\n            \"  Availability: \" + Resource.newInstance(\n            rootMetrics.getAvailableMB(),\n            rootMetrics.getAvailableVirtualCores()) +\n            \"  Demand: \" + rootQueue.getDemand());\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "82f3454f5ac1f1c457e668e2cee12b4dcc800ee1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2017. Merged some of the common scheduler code. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1596753 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/05/14 10:32 PM",
      "commitName": "82f3454f5ac1f1c457e668e2cee12b4dcc800ee1",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "31/03/14 4:40 PM",
      "commitNameOld": "7bd62b8da03642612fae8349e967b9c0aa290843",
      "commitAuthorOld": "Sanford Ryza",
      "daysBetweenCommits": 51.24,
      "commitsBetweenForRepo": 299,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,13 +1,13 @@\n   protected synchronized void update() {\n     updatePreemptionVariables(); // Determine if any queues merit preemption\n \n     FSQueue rootQueue \u003d queueMgr.getRootQueue();\n \n     // Recursively update demands for all queues\n     rootQueue.updateDemand();\n \n-    rootQueue.setFairShare(clusterCapacity);\n+    rootQueue.setFairShare(clusterResource);\n     // Recursively compute fair shares for all queues\n     // and update metrics\n     rootQueue.recomputeShares();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void update() {\n    updatePreemptionVariables(); // Determine if any queues merit preemption\n\n    FSQueue rootQueue \u003d queueMgr.getRootQueue();\n\n    // Recursively update demands for all queues\n    rootQueue.updateDemand();\n\n    rootQueue.setFairShare(clusterResource);\n    // Recursively compute fair shares for all queues\n    // and update metrics\n    rootQueue.recomputeShares();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "6d5f8ebed60e59d772e0dcee0b069f8db95f6ccc": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1403. Separate out configuration loading from QueueManager in the Fair Scheduler (Sandy Ryza)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1548006 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/12/13 7:26 PM",
      "commitName": "6d5f8ebed60e59d772e0dcee0b069f8db95f6ccc",
      "commitAuthor": "Sanford Ryza",
      "commitDateOld": "29/11/13 11:02 AM",
      "commitNameOld": "7545d8bf996e5d060d5d613bf769ec52a62d428b",
      "commitAuthorOld": "Sanford Ryza",
      "daysBetweenCommits": 5.35,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,14 +1,13 @@\n   protected synchronized void update() {\n-    queueMgr.reloadAllocsIfNecessary(); // Relaod alloc file\n     updatePreemptionVariables(); // Determine if any queues merit preemption\n \n     FSQueue rootQueue \u003d queueMgr.getRootQueue();\n \n     // Recursively update demands for all queues\n     rootQueue.updateDemand();\n \n     rootQueue.setFairShare(clusterCapacity);\n     // Recursively compute fair shares for all queues\n     // and update metrics\n     rootQueue.recomputeShares();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void update() {\n    updatePreemptionVariables(); // Determine if any queues merit preemption\n\n    FSQueue rootQueue \u003d queueMgr.getRootQueue();\n\n    // Recursively update demands for all queues\n    rootQueue.updateDemand();\n\n    rootQueue.setFairShare(clusterCapacity);\n    // Recursively compute fair shares for all queues\n    // and update metrics\n    rootQueue.recomputeShares();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "7545d8bf996e5d060d5d613bf769ec52a62d428b": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1241. In Fair Scheduler, maxRunningApps does not work for non-leaf queues. (Sandy Ryza)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1546623 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/11/13 11:02 AM",
      "commitName": "7545d8bf996e5d060d5d613bf769ec52a62d428b",
      "commitAuthor": "Sanford Ryza",
      "commitDateOld": "14/11/13 2:12 PM",
      "commitNameOld": "3858b9018e3c2f4b883b02021679852591b706f7",
      "commitAuthorOld": "Sanford Ryza",
      "daysBetweenCommits": 14.87,
      "commitsBetweenForRepo": 78,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,15 +1,14 @@\n   protected synchronized void update() {\n     queueMgr.reloadAllocsIfNecessary(); // Relaod alloc file\n-    updateRunnability(); // Set job runnability based on user/queue limits\n     updatePreemptionVariables(); // Determine if any queues merit preemption\n \n     FSQueue rootQueue \u003d queueMgr.getRootQueue();\n \n     // Recursively update demands for all queues\n     rootQueue.updateDemand();\n \n     rootQueue.setFairShare(clusterCapacity);\n     // Recursively compute fair shares for all queues\n     // and update metrics\n     rootQueue.recomputeShares();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void update() {\n    queueMgr.reloadAllocsIfNecessary(); // Relaod alloc file\n    updatePreemptionVariables(); // Determine if any queues merit preemption\n\n    FSQueue rootQueue \u003d queueMgr.getRootQueue();\n\n    // Recursively update demands for all queues\n    rootQueue.updateDemand();\n\n    rootQueue.setFairShare(clusterCapacity);\n    // Recursively compute fair shares for all queues\n    // and update metrics\n    rootQueue.recomputeShares();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "51ccb87031eda6a2b75be098a88f1d89ea82c610": {
      "type": "Ybodychange",
      "commitMessage": "YARN-655. Fair scheduler metrics should subtract allocated memory from available memory. (sandyr via tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1480809 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/05/13 3:15 PM",
      "commitName": "51ccb87031eda6a2b75be098a88f1d89ea82c610",
      "commitAuthor": "Alejandro Abdelnur",
      "commitDateOld": "09/05/13 2:52 PM",
      "commitNameOld": "e0562e3d07f29afbf283857293db0699dcb232c9",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,19 +1,15 @@\n   protected synchronized void update() {\n     queueMgr.reloadAllocsIfNecessary(); // Relaod alloc file\n     updateRunnability(); // Set job runnability based on user/queue limits\n     updatePreemptionVariables(); // Determine if any queues merit preemption\n \n     FSQueue rootQueue \u003d queueMgr.getRootQueue();\n \n     // Recursively update demands for all queues\n     rootQueue.updateDemand();\n \n     rootQueue.setFairShare(clusterCapacity);\n     // Recursively compute fair shares for all queues\n     // and update metrics\n     rootQueue.recomputeShares();\n-\n-    // Update recorded capacity of root queue (child queues are updated\n-    // when fair share is calculated).\n-    rootMetrics.setAvailableResourcesToQueue(clusterCapacity);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void update() {\n    queueMgr.reloadAllocsIfNecessary(); // Relaod alloc file\n    updateRunnability(); // Set job runnability based on user/queue limits\n    updatePreemptionVariables(); // Determine if any queues merit preemption\n\n    FSQueue rootQueue \u003d queueMgr.getRootQueue();\n\n    // Recursively update demands for all queues\n    rootQueue.updateDemand();\n\n    rootQueue.setFairShare(clusterCapacity);\n    // Recursively compute fair shares for all queues\n    // and update metrics\n    rootQueue.recomputeShares();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "df55edd5dec9c944a6c38f08d6f1f0fdb901c880": {
      "type": "Ybodychange",
      "commitMessage": "YARN-482. FS: Extend SchedulingMode to intermediate queues. (kkambatl via tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1469506 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/04/13 11:11 AM",
      "commitName": "df55edd5dec9c944a6c38f08d6f1f0fdb901c880",
      "commitAuthor": "Alejandro Abdelnur",
      "commitDateOld": "05/04/13 10:45 AM",
      "commitNameOld": "bc6777dd5bdcbaef09897b506bc6511ae456033d",
      "commitAuthorOld": "Bikas Saha",
      "daysBetweenCommits": 13.02,
      "commitsBetweenForRepo": 63,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,19 +1,19 @@\n   protected synchronized void update() {\n     queueMgr.reloadAllocsIfNecessary(); // Relaod alloc file\n     updateRunnability(); // Set job runnability based on user/queue limits\n     updatePreemptionVariables(); // Determine if any queues merit preemption\n \n     FSQueue rootQueue \u003d queueMgr.getRootQueue();\n \n     // Recursively update demands for all queues\n     rootQueue.updateDemand();\n \n     rootQueue.setFairShare(clusterCapacity);\n     // Recursively compute fair shares for all queues\n     // and update metrics\n-    rootQueue.recomputeFairShares();\n+    rootQueue.recomputeShares();\n \n     // Update recorded capacity of root queue (child queues are updated\n     // when fair share is calculated).\n     rootMetrics.setAvailableResourcesToQueue(clusterCapacity);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void update() {\n    queueMgr.reloadAllocsIfNecessary(); // Relaod alloc file\n    updateRunnability(); // Set job runnability based on user/queue limits\n    updatePreemptionVariables(); // Determine if any queues merit preemption\n\n    FSQueue rootQueue \u003d queueMgr.getRootQueue();\n\n    // Recursively update demands for all queues\n    rootQueue.updateDemand();\n\n    rootQueue.setFairShare(clusterCapacity);\n    // Recursively compute fair shares for all queues\n    // and update metrics\n    rootQueue.recomputeShares();\n\n    // Update recorded capacity of root queue (child queues are updated\n    // when fair share is calculated).\n    rootMetrics.setAvailableResourcesToQueue(clusterCapacity);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "ae6f1123f57c09a9cf5eed3e8c4659481417dc21": {
      "type": "Ybodychange",
      "commitMessage": "YARN-187. Add hierarchical queues to the fair scheduler. Contributed by Sandy Ryza.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1415592 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/11/12 4:03 AM",
      "commitName": "ae6f1123f57c09a9cf5eed3e8c4659481417dc21",
      "commitAuthor": "Thomas White",
      "commitDateOld": "28/11/12 5:56 PM",
      "commitNameOld": "1943fdbec613715f3cdc3ca60cbd273115f28299",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 1.42,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,19 @@\n   protected synchronized void update() {\n     queueMgr.reloadAllocsIfNecessary(); // Relaod alloc file\n     updateRunnability(); // Set job runnability based on user/queue limits\n     updatePreemptionVariables(); // Determine if any queues merit preemption\n \n-    // Update demands of apps and queues\n-    for (FSQueue queue: queueMgr.getQueues()) {\n-      queue.getQueueSchedulable().updateDemand();\n-    }\n+    FSQueue rootQueue \u003d queueMgr.getRootQueue();\n \n-    // Compute fair shares based on updated demands\n-    List\u003cFSQueueSchedulable\u003e queueScheds \u003d getQueueSchedulables();\n-    SchedulingAlgorithms.computeFairShares(\n-        queueScheds, clusterCapacity);\n+    // Recursively update demands for all queues\n+    rootQueue.updateDemand();\n \n-    // Update queue metrics for this queue\n-    for (FSQueueSchedulable sched : queueScheds) {\n-      sched.getMetrics().setAvailableResourcesToQueue(sched.getFairShare());\n-    }\n-\n-    // Use the computed shares to assign shares within each queue\n-    for (FSQueue queue: queueMgr.getQueues()) {\n-      queue.getQueueSchedulable().redistributeShare();\n-    }\n+    rootQueue.setFairShare(clusterCapacity);\n+    // Recursively compute fair shares for all queues\n+    // and update metrics\n+    rootQueue.recomputeFairShares();\n \n     // Update recorded capacity of root queue (child queues are updated\n     // when fair share is calculated).\n     rootMetrics.setAvailableResourcesToQueue(clusterCapacity);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void update() {\n    queueMgr.reloadAllocsIfNecessary(); // Relaod alloc file\n    updateRunnability(); // Set job runnability based on user/queue limits\n    updatePreemptionVariables(); // Determine if any queues merit preemption\n\n    FSQueue rootQueue \u003d queueMgr.getRootQueue();\n\n    // Recursively update demands for all queues\n    rootQueue.updateDemand();\n\n    rootQueue.setFairShare(clusterCapacity);\n    // Recursively compute fair shares for all queues\n    // and update metrics\n    rootQueue.recomputeFairShares();\n\n    // Update recorded capacity of root queue (child queues are updated\n    // when fair share is calculated).\n    rootMetrics.setAvailableResourcesToQueue(clusterCapacity);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {}
    },
    "933a6d2c1ec8d3b373674e3e74eb472863fc464d": {
      "type": "Ymultichange(Ymodifierchange,Ybodychange)",
      "commitMessage": "YARN-183. Clean up fair scheduler code. Contributed by Sandy Ryza.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1407433 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/11/12 4:38 AM",
      "commitName": "933a6d2c1ec8d3b373674e3e74eb472863fc464d",
      "commitAuthor": "Thomas White",
      "subchanges": [
        {
          "type": "Ymodifierchange",
          "commitMessage": "YARN-183. Clean up fair scheduler code. Contributed by Sandy Ryza.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1407433 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "09/11/12 4:38 AM",
          "commitName": "933a6d2c1ec8d3b373674e3e74eb472863fc464d",
          "commitAuthor": "Thomas White",
          "commitDateOld": "26/10/12 1:55 PM",
          "commitNameOld": "b54e794fb059fa68b115c2ca5e58f11a0d7f3985",
          "commitAuthorOld": "Thomas White",
          "daysBetweenCommits": 13.65,
          "commitsBetweenForRepo": 70,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,31 +1,29 @@\n-  protected void update() {\n-    synchronized (this) {\n-      queueMgr.reloadAllocsIfNecessary(); // Relaod alloc file\n-      updateRunnability(); // Set job runnability based on user/queue limits\n-      updatePreemptionVariables(); // Determine if any queues merit preemption\n+  protected synchronized void update() {\n+    queueMgr.reloadAllocsIfNecessary(); // Relaod alloc file\n+    updateRunnability(); // Set job runnability based on user/queue limits\n+    updatePreemptionVariables(); // Determine if any queues merit preemption\n \n-      // Update demands of apps and queues\n-      for (FSQueue queue: queueMgr.getQueues()) {\n-        queue.getQueueSchedulable().updateDemand();\n-      }\n-\n-      // Compute fair shares based on updated demands\n-      List\u003cFSQueueSchedulable\u003e queueScheds \u003d this.getQueueSchedulables();\n-      SchedulingAlgorithms.computeFairShares(\n-          queueScheds, clusterCapacity);\n-\n-      // Update queue metrics for this queue\n-      for (FSQueueSchedulable sched : queueScheds) {\n-        sched.getMetrics().setAvailableResourcesToQueue(sched.getFairShare());\n-      }\n-\n-      // Use the computed shares to assign shares within each queue\n-      for (FSQueue queue: queueMgr.getQueues()) {\n-        queue.getQueueSchedulable().redistributeShare();\n-      }\n-\n-      // Update recorded capacity of root queue (child queues are updated\n-      // when fair share is calculated).\n-      rootMetrics.setAvailableResourcesToQueue(clusterCapacity);\n+    // Update demands of apps and queues\n+    for (FSQueue queue: queueMgr.getQueues()) {\n+      queue.getQueueSchedulable().updateDemand();\n     }\n+\n+    // Compute fair shares based on updated demands\n+    List\u003cFSQueueSchedulable\u003e queueScheds \u003d getQueueSchedulables();\n+    SchedulingAlgorithms.computeFairShares(\n+        queueScheds, clusterCapacity);\n+\n+    // Update queue metrics for this queue\n+    for (FSQueueSchedulable sched : queueScheds) {\n+      sched.getMetrics().setAvailableResourcesToQueue(sched.getFairShare());\n+    }\n+\n+    // Use the computed shares to assign shares within each queue\n+    for (FSQueue queue: queueMgr.getQueues()) {\n+      queue.getQueueSchedulable().redistributeShare();\n+    }\n+\n+    // Update recorded capacity of root queue (child queues are updated\n+    // when fair share is calculated).\n+    rootMetrics.setAvailableResourcesToQueue(clusterCapacity);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected synchronized void update() {\n    queueMgr.reloadAllocsIfNecessary(); // Relaod alloc file\n    updateRunnability(); // Set job runnability based on user/queue limits\n    updatePreemptionVariables(); // Determine if any queues merit preemption\n\n    // Update demands of apps and queues\n    for (FSQueue queue: queueMgr.getQueues()) {\n      queue.getQueueSchedulable().updateDemand();\n    }\n\n    // Compute fair shares based on updated demands\n    List\u003cFSQueueSchedulable\u003e queueScheds \u003d getQueueSchedulables();\n    SchedulingAlgorithms.computeFairShares(\n        queueScheds, clusterCapacity);\n\n    // Update queue metrics for this queue\n    for (FSQueueSchedulable sched : queueScheds) {\n      sched.getMetrics().setAvailableResourcesToQueue(sched.getFairShare());\n    }\n\n    // Use the computed shares to assign shares within each queue\n    for (FSQueue queue: queueMgr.getQueues()) {\n      queue.getQueueSchedulable().redistributeShare();\n    }\n\n    // Update recorded capacity of root queue (child queues are updated\n    // when fair share is calculated).\n    rootMetrics.setAvailableResourcesToQueue(clusterCapacity);\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
          "extendedDetails": {
            "oldValue": "[protected]",
            "newValue": "[protected, synchronized]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-183. Clean up fair scheduler code. Contributed by Sandy Ryza.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1407433 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "09/11/12 4:38 AM",
          "commitName": "933a6d2c1ec8d3b373674e3e74eb472863fc464d",
          "commitAuthor": "Thomas White",
          "commitDateOld": "26/10/12 1:55 PM",
          "commitNameOld": "b54e794fb059fa68b115c2ca5e58f11a0d7f3985",
          "commitAuthorOld": "Thomas White",
          "daysBetweenCommits": 13.65,
          "commitsBetweenForRepo": 70,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,31 +1,29 @@\n-  protected void update() {\n-    synchronized (this) {\n-      queueMgr.reloadAllocsIfNecessary(); // Relaod alloc file\n-      updateRunnability(); // Set job runnability based on user/queue limits\n-      updatePreemptionVariables(); // Determine if any queues merit preemption\n+  protected synchronized void update() {\n+    queueMgr.reloadAllocsIfNecessary(); // Relaod alloc file\n+    updateRunnability(); // Set job runnability based on user/queue limits\n+    updatePreemptionVariables(); // Determine if any queues merit preemption\n \n-      // Update demands of apps and queues\n-      for (FSQueue queue: queueMgr.getQueues()) {\n-        queue.getQueueSchedulable().updateDemand();\n-      }\n-\n-      // Compute fair shares based on updated demands\n-      List\u003cFSQueueSchedulable\u003e queueScheds \u003d this.getQueueSchedulables();\n-      SchedulingAlgorithms.computeFairShares(\n-          queueScheds, clusterCapacity);\n-\n-      // Update queue metrics for this queue\n-      for (FSQueueSchedulable sched : queueScheds) {\n-        sched.getMetrics().setAvailableResourcesToQueue(sched.getFairShare());\n-      }\n-\n-      // Use the computed shares to assign shares within each queue\n-      for (FSQueue queue: queueMgr.getQueues()) {\n-        queue.getQueueSchedulable().redistributeShare();\n-      }\n-\n-      // Update recorded capacity of root queue (child queues are updated\n-      // when fair share is calculated).\n-      rootMetrics.setAvailableResourcesToQueue(clusterCapacity);\n+    // Update demands of apps and queues\n+    for (FSQueue queue: queueMgr.getQueues()) {\n+      queue.getQueueSchedulable().updateDemand();\n     }\n+\n+    // Compute fair shares based on updated demands\n+    List\u003cFSQueueSchedulable\u003e queueScheds \u003d getQueueSchedulables();\n+    SchedulingAlgorithms.computeFairShares(\n+        queueScheds, clusterCapacity);\n+\n+    // Update queue metrics for this queue\n+    for (FSQueueSchedulable sched : queueScheds) {\n+      sched.getMetrics().setAvailableResourcesToQueue(sched.getFairShare());\n+    }\n+\n+    // Use the computed shares to assign shares within each queue\n+    for (FSQueue queue: queueMgr.getQueues()) {\n+      queue.getQueueSchedulable().redistributeShare();\n+    }\n+\n+    // Update recorded capacity of root queue (child queues are updated\n+    // when fair share is calculated).\n+    rootMetrics.setAvailableResourcesToQueue(clusterCapacity);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected synchronized void update() {\n    queueMgr.reloadAllocsIfNecessary(); // Relaod alloc file\n    updateRunnability(); // Set job runnability based on user/queue limits\n    updatePreemptionVariables(); // Determine if any queues merit preemption\n\n    // Update demands of apps and queues\n    for (FSQueue queue: queueMgr.getQueues()) {\n      queue.getQueueSchedulable().updateDemand();\n    }\n\n    // Compute fair shares based on updated demands\n    List\u003cFSQueueSchedulable\u003e queueScheds \u003d getQueueSchedulables();\n    SchedulingAlgorithms.computeFairShares(\n        queueScheds, clusterCapacity);\n\n    // Update queue metrics for this queue\n    for (FSQueueSchedulable sched : queueScheds) {\n      sched.getMetrics().setAvailableResourcesToQueue(sched.getFairShare());\n    }\n\n    // Use the computed shares to assign shares within each queue\n    for (FSQueue queue: queueMgr.getQueues()) {\n      queue.getQueueSchedulable().redistributeShare();\n    }\n\n    // Update recorded capacity of root queue (child queues are updated\n    // when fair share is calculated).\n    rootMetrics.setAvailableResourcesToQueue(clusterCapacity);\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
          "extendedDetails": {}
        }
      ]
    },
    "e1fdf62123625e4ba399af02f8aad500637d29d1": {
      "type": "Yfilerename",
      "commitMessage": "YARN-1. Promote YARN to be a sub-project of Apache Hadoop.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1370666 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/08/12 10:22 PM",
      "commitName": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "07/08/12 7:53 PM",
      "commitNameOld": "34554d1e11ee1d5b564d7d9ed3e6d55931d72749",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  protected void update() {\n    synchronized (this) {\n      queueMgr.reloadAllocsIfNecessary(); // Relaod alloc file\n      updateRunnability(); // Set job runnability based on user/queue limits\n      updatePreemptionVariables(); // Determine if any queues merit preemption\n\n      // Update demands of apps and queues\n      for (FSQueue queue: queueMgr.getQueues()) {\n        queue.getQueueSchedulable().updateDemand();\n      }\n\n      // Compute fair shares based on updated demands\n      List\u003cFSQueueSchedulable\u003e queueScheds \u003d this.getQueueSchedulables();\n      SchedulingAlgorithms.computeFairShares(\n          queueScheds, clusterCapacity);\n\n      // Update queue metrics for this queue\n      for (FSQueueSchedulable sched : queueScheds) {\n        sched.getMetrics().setAvailableResourcesToQueue(sched.getFairShare());\n      }\n\n      // Use the computed shares to assign shares within each queue\n      for (FSQueue queue: queueMgr.getQueues()) {\n        queue.getQueueSchedulable().redistributeShare();\n      }\n\n      // Update recorded capacity of root queue (child queues are updated\n      // when fair share is calculated).\n      rootMetrics.setAvailableResourcesToQueue(clusterCapacity);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java"
      }
    },
    "1ef64e64c05ae5318cd4cb47d03a0494d742fb7c": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-3451. Port Fair Scheduler to MR2 (pwendell via tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1361020 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/07/12 5:43 PM",
      "commitName": "1ef64e64c05ae5318cd4cb47d03a0494d742fb7c",
      "commitAuthor": "Alejandro Abdelnur",
      "diff": "@@ -0,0 +1,31 @@\n+  protected void update() {\n+    synchronized (this) {\n+      queueMgr.reloadAllocsIfNecessary(); // Relaod alloc file\n+      updateRunnability(); // Set job runnability based on user/queue limits\n+      updatePreemptionVariables(); // Determine if any queues merit preemption\n+\n+      // Update demands of apps and queues\n+      for (FSQueue queue: queueMgr.getQueues()) {\n+        queue.getQueueSchedulable().updateDemand();\n+      }\n+\n+      // Compute fair shares based on updated demands\n+      List\u003cFSQueueSchedulable\u003e queueScheds \u003d this.getQueueSchedulables();\n+      SchedulingAlgorithms.computeFairShares(\n+          queueScheds, clusterCapacity);\n+\n+      // Update queue metrics for this queue\n+      for (FSQueueSchedulable sched : queueScheds) {\n+        sched.getMetrics().setAvailableResourcesToQueue(sched.getFairShare());\n+      }\n+\n+      // Use the computed shares to assign shares within each queue\n+      for (FSQueue queue: queueMgr.getQueues()) {\n+        queue.getQueueSchedulable().redistributeShare();\n+      }\n+\n+      // Update recorded capacity of root queue (child queues are updated\n+      // when fair share is calculated).\n+      rootMetrics.setAvailableResourcesToQueue(clusterCapacity);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  protected void update() {\n    synchronized (this) {\n      queueMgr.reloadAllocsIfNecessary(); // Relaod alloc file\n      updateRunnability(); // Set job runnability based on user/queue limits\n      updatePreemptionVariables(); // Determine if any queues merit preemption\n\n      // Update demands of apps and queues\n      for (FSQueue queue: queueMgr.getQueues()) {\n        queue.getQueueSchedulable().updateDemand();\n      }\n\n      // Compute fair shares based on updated demands\n      List\u003cFSQueueSchedulable\u003e queueScheds \u003d this.getQueueSchedulables();\n      SchedulingAlgorithms.computeFairShares(\n          queueScheds, clusterCapacity);\n\n      // Update queue metrics for this queue\n      for (FSQueueSchedulable sched : queueScheds) {\n        sched.getMetrics().setAvailableResourcesToQueue(sched.getFairShare());\n      }\n\n      // Use the computed shares to assign shares within each queue\n      for (FSQueue queue: queueMgr.getQueues()) {\n        queue.getQueueSchedulable().redistributeShare();\n      }\n\n      // Update recorded capacity of root queue (child queues are updated\n      // when fair share is calculated).\n      rootMetrics.setAvailableResourcesToQueue(clusterCapacity);\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/FairScheduler.java"
    }
  }
}