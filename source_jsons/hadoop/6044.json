{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FSEditLog.java",
  "functionName": "logSync",
  "functionId": "logSync___mytxid-long",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSEditLog.java",
  "functionStartLine": 651,
  "functionEndLine": 756,
  "numCommitsSeen": 141,
  "timeTaken": 2931,
  "changeHistory": [
    "60fc2a138827c2c29fa7e9d6844e3b8d43809726",
    "e620530301fd3e62537d4b7bc3d8ed296bda1ffc",
    "2151716832ad14932dd65b1a4e47e64d8d6cd767"
  ],
  "changeHistoryShort": {
    "60fc2a138827c2c29fa7e9d6844e3b8d43809726": "Ybodychange",
    "e620530301fd3e62537d4b7bc3d8ed296bda1ffc": "Ybodychange",
    "2151716832ad14932dd65b1a4e47e64d8d6cd767": "Yintroduced"
  },
  "changeHistoryDetails": {
    "60fc2a138827c2c29fa7e9d6844e3b8d43809726": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12804. Use slf4j instead of log4j in FSEditLog. Contributed by Mukul Kumar Singh.\n",
      "commitDate": "20/11/17 12:49 PM",
      "commitName": "60fc2a138827c2c29fa7e9d6844e3b8d43809726",
      "commitAuthor": "Chen Liang",
      "commitDateOld": "16/10/17 9:51 AM",
      "commitNameOld": "035c6ee587e444550af6420676e4cee049e09869",
      "commitAuthorOld": "Xiao Chen",
      "daysBetweenCommits": 35.17,
      "commitsBetweenForRepo": 318,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,106 +1,106 @@\n   protected void logSync(long mytxid) {\n     long syncStart \u003d 0;\n     boolean sync \u003d false;\n     long editsBatchedInSync \u003d 0;\n     try {\n       EditLogOutputStream logStream \u003d null;\n       synchronized (this) {\n         try {\n           printStatistics(false);\n \n           // if somebody is already syncing, then wait\n           while (mytxid \u003e synctxid \u0026\u0026 isSyncRunning) {\n             try {\n               wait(1000);\n             } catch (InterruptedException ie) {\n             }\n           }\n   \n           //\n           // If this transaction was already flushed, then nothing to do\n           //\n           if (mytxid \u003c\u003d synctxid) {\n             return;\n           }\n \n           // now, this thread will do the sync.  track if other edits were\n           // included in the sync - ie. batched.  if this is the only edit\n           // synced then the batched count is 0\n           editsBatchedInSync \u003d txid - synctxid - 1;\n           syncStart \u003d txid;\n           isSyncRunning \u003d true;\n           sync \u003d true;\n \n           // swap buffers\n           try {\n             if (journalSet.isEmpty()) {\n               throw new IOException(\"No journals available to flush\");\n             }\n             editLogStream.setReadyToFlush();\n           } catch (IOException e) {\n             final String msg \u003d\n                 \"Could not sync enough journals to persistent storage \" +\n                 \"due to \" + e.getMessage() + \". \" +\n                 \"Unsynced transactions: \" + (txid - synctxid);\n-            LOG.fatal(msg, new Exception());\n+            LOG.error(msg, new Exception());\n             synchronized(journalSetLock) {\n-              IOUtils.cleanup(LOG, journalSet);\n+              IOUtils.cleanupWithLogger(LOG, journalSet);\n             }\n             terminate(1, msg);\n           }\n         } finally {\n           // Prevent RuntimeException from blocking other log edit write \n           doneWithAutoSyncScheduling();\n         }\n         //editLogStream may become null,\n         //so store a local variable for flush.\n         logStream \u003d editLogStream;\n       }\n       \n       // do the sync\n       long start \u003d monotonicNow();\n       try {\n         if (logStream !\u003d null) {\n           logStream.flush();\n         }\n       } catch (IOException ex) {\n         synchronized (this) {\n           final String msg \u003d\n               \"Could not sync enough journals to persistent storage. \"\n               + \"Unsynced transactions: \" + (txid - synctxid);\n-          LOG.fatal(msg, new Exception());\n+          LOG.error(msg, new Exception());\n           synchronized(journalSetLock) {\n-            IOUtils.cleanup(LOG, journalSet);\n+            IOUtils.cleanupWithLogger(LOG, journalSet);\n           }\n           terminate(1, msg);\n         }\n       }\n       long elapsed \u003d monotonicNow() - start;\n   \n       if (metrics !\u003d null) { // Metrics non-null only when used inside name node\n         metrics.addSync(elapsed);\n         metrics.incrTransactionsBatchedInSync(editsBatchedInSync);\n         numTransactionsBatchedInSync.addAndGet(editsBatchedInSync);\n       }\n       \n     } finally {\n       // Prevent RuntimeException from blocking other log edit sync \n       synchronized (this) {\n         if (sync) {\n           synctxid \u003d syncStart;\n           for (JournalManager jm : journalSet.getJournalManagers()) {\n             /**\n              * {@link FileJournalManager#lastReadableTxId} is only meaningful\n              * for file-based journals. Therefore the interface is not added to\n              * other types of {@link JournalManager}.\n              */\n             if (jm instanceof FileJournalManager) {\n               ((FileJournalManager)jm).setLastReadableTxId(syncStart);\n             }\n           }\n           isSyncRunning \u003d false;\n         }\n         this.notifyAll();\n      }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void logSync(long mytxid) {\n    long syncStart \u003d 0;\n    boolean sync \u003d false;\n    long editsBatchedInSync \u003d 0;\n    try {\n      EditLogOutputStream logStream \u003d null;\n      synchronized (this) {\n        try {\n          printStatistics(false);\n\n          // if somebody is already syncing, then wait\n          while (mytxid \u003e synctxid \u0026\u0026 isSyncRunning) {\n            try {\n              wait(1000);\n            } catch (InterruptedException ie) {\n            }\n          }\n  \n          //\n          // If this transaction was already flushed, then nothing to do\n          //\n          if (mytxid \u003c\u003d synctxid) {\n            return;\n          }\n\n          // now, this thread will do the sync.  track if other edits were\n          // included in the sync - ie. batched.  if this is the only edit\n          // synced then the batched count is 0\n          editsBatchedInSync \u003d txid - synctxid - 1;\n          syncStart \u003d txid;\n          isSyncRunning \u003d true;\n          sync \u003d true;\n\n          // swap buffers\n          try {\n            if (journalSet.isEmpty()) {\n              throw new IOException(\"No journals available to flush\");\n            }\n            editLogStream.setReadyToFlush();\n          } catch (IOException e) {\n            final String msg \u003d\n                \"Could not sync enough journals to persistent storage \" +\n                \"due to \" + e.getMessage() + \". \" +\n                \"Unsynced transactions: \" + (txid - synctxid);\n            LOG.error(msg, new Exception());\n            synchronized(journalSetLock) {\n              IOUtils.cleanupWithLogger(LOG, journalSet);\n            }\n            terminate(1, msg);\n          }\n        } finally {\n          // Prevent RuntimeException from blocking other log edit write \n          doneWithAutoSyncScheduling();\n        }\n        //editLogStream may become null,\n        //so store a local variable for flush.\n        logStream \u003d editLogStream;\n      }\n      \n      // do the sync\n      long start \u003d monotonicNow();\n      try {\n        if (logStream !\u003d null) {\n          logStream.flush();\n        }\n      } catch (IOException ex) {\n        synchronized (this) {\n          final String msg \u003d\n              \"Could not sync enough journals to persistent storage. \"\n              + \"Unsynced transactions: \" + (txid - synctxid);\n          LOG.error(msg, new Exception());\n          synchronized(journalSetLock) {\n            IOUtils.cleanupWithLogger(LOG, journalSet);\n          }\n          terminate(1, msg);\n        }\n      }\n      long elapsed \u003d monotonicNow() - start;\n  \n      if (metrics !\u003d null) { // Metrics non-null only when used inside name node\n        metrics.addSync(elapsed);\n        metrics.incrTransactionsBatchedInSync(editsBatchedInSync);\n        numTransactionsBatchedInSync.addAndGet(editsBatchedInSync);\n      }\n      \n    } finally {\n      // Prevent RuntimeException from blocking other log edit sync \n      synchronized (this) {\n        if (sync) {\n          synctxid \u003d syncStart;\n          for (JournalManager jm : journalSet.getJournalManagers()) {\n            /**\n             * {@link FileJournalManager#lastReadableTxId} is only meaningful\n             * for file-based journals. Therefore the interface is not added to\n             * other types of {@link JournalManager}.\n             */\n            if (jm instanceof FileJournalManager) {\n              ((FileJournalManager)jm).setLastReadableTxId(syncStart);\n            }\n          }\n          isSyncRunning \u003d false;\n        }\n        this.notifyAll();\n     }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSEditLog.java",
      "extendedDetails": {}
    },
    "e620530301fd3e62537d4b7bc3d8ed296bda1ffc": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10485. Fix findbugs warning in FSEditLog.java. (aajisaka)\n",
      "commitDate": "07/06/16 1:52 AM",
      "commitName": "e620530301fd3e62537d4b7bc3d8ed296bda1ffc",
      "commitAuthor": "Akira Ajisaka",
      "commitDateOld": "29/02/16 3:34 PM",
      "commitNameOld": "2151716832ad14932dd65b1a4e47e64d8d6cd767",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 98.39,
      "commitsBetweenForRepo": 619,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,106 +1,106 @@\n   protected void logSync(long mytxid) {\n     long syncStart \u003d 0;\n     boolean sync \u003d false;\n     long editsBatchedInSync \u003d 0;\n     try {\n       EditLogOutputStream logStream \u003d null;\n       synchronized (this) {\n         try {\n           printStatistics(false);\n \n           // if somebody is already syncing, then wait\n           while (mytxid \u003e synctxid \u0026\u0026 isSyncRunning) {\n             try {\n               wait(1000);\n             } catch (InterruptedException ie) {\n             }\n           }\n   \n           //\n           // If this transaction was already flushed, then nothing to do\n           //\n           if (mytxid \u003c\u003d synctxid) {\n             return;\n           }\n \n           // now, this thread will do the sync.  track if other edits were\n           // included in the sync - ie. batched.  if this is the only edit\n           // synced then the batched count is 0\n           editsBatchedInSync \u003d txid - synctxid - 1;\n           syncStart \u003d txid;\n           isSyncRunning \u003d true;\n           sync \u003d true;\n \n           // swap buffers\n           try {\n             if (journalSet.isEmpty()) {\n               throw new IOException(\"No journals available to flush\");\n             }\n             editLogStream.setReadyToFlush();\n           } catch (IOException e) {\n             final String msg \u003d\n                 \"Could not sync enough journals to persistent storage \" +\n                 \"due to \" + e.getMessage() + \". \" +\n                 \"Unsynced transactions: \" + (txid - synctxid);\n             LOG.fatal(msg, new Exception());\n             synchronized(journalSetLock) {\n               IOUtils.cleanup(LOG, journalSet);\n             }\n             terminate(1, msg);\n           }\n         } finally {\n           // Prevent RuntimeException from blocking other log edit write \n           doneWithAutoSyncScheduling();\n         }\n         //editLogStream may become null,\n         //so store a local variable for flush.\n         logStream \u003d editLogStream;\n       }\n       \n       // do the sync\n       long start \u003d monotonicNow();\n       try {\n         if (logStream !\u003d null) {\n           logStream.flush();\n         }\n       } catch (IOException ex) {\n         synchronized (this) {\n           final String msg \u003d\n               \"Could not sync enough journals to persistent storage. \"\n               + \"Unsynced transactions: \" + (txid - synctxid);\n           LOG.fatal(msg, new Exception());\n           synchronized(journalSetLock) {\n             IOUtils.cleanup(LOG, journalSet);\n           }\n           terminate(1, msg);\n         }\n       }\n       long elapsed \u003d monotonicNow() - start;\n   \n       if (metrics !\u003d null) { // Metrics non-null only when used inside name node\n         metrics.addSync(elapsed);\n         metrics.incrTransactionsBatchedInSync(editsBatchedInSync);\n-        numTransactionsBatchedInSync +\u003d editsBatchedInSync;\n+        numTransactionsBatchedInSync.addAndGet(editsBatchedInSync);\n       }\n       \n     } finally {\n       // Prevent RuntimeException from blocking other log edit sync \n       synchronized (this) {\n         if (sync) {\n           synctxid \u003d syncStart;\n           for (JournalManager jm : journalSet.getJournalManagers()) {\n             /**\n              * {@link FileJournalManager#lastReadableTxId} is only meaningful\n              * for file-based journals. Therefore the interface is not added to\n              * other types of {@link JournalManager}.\n              */\n             if (jm instanceof FileJournalManager) {\n               ((FileJournalManager)jm).setLastReadableTxId(syncStart);\n             }\n           }\n           isSyncRunning \u003d false;\n         }\n         this.notifyAll();\n      }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void logSync(long mytxid) {\n    long syncStart \u003d 0;\n    boolean sync \u003d false;\n    long editsBatchedInSync \u003d 0;\n    try {\n      EditLogOutputStream logStream \u003d null;\n      synchronized (this) {\n        try {\n          printStatistics(false);\n\n          // if somebody is already syncing, then wait\n          while (mytxid \u003e synctxid \u0026\u0026 isSyncRunning) {\n            try {\n              wait(1000);\n            } catch (InterruptedException ie) {\n            }\n          }\n  \n          //\n          // If this transaction was already flushed, then nothing to do\n          //\n          if (mytxid \u003c\u003d synctxid) {\n            return;\n          }\n\n          // now, this thread will do the sync.  track if other edits were\n          // included in the sync - ie. batched.  if this is the only edit\n          // synced then the batched count is 0\n          editsBatchedInSync \u003d txid - synctxid - 1;\n          syncStart \u003d txid;\n          isSyncRunning \u003d true;\n          sync \u003d true;\n\n          // swap buffers\n          try {\n            if (journalSet.isEmpty()) {\n              throw new IOException(\"No journals available to flush\");\n            }\n            editLogStream.setReadyToFlush();\n          } catch (IOException e) {\n            final String msg \u003d\n                \"Could not sync enough journals to persistent storage \" +\n                \"due to \" + e.getMessage() + \". \" +\n                \"Unsynced transactions: \" + (txid - synctxid);\n            LOG.fatal(msg, new Exception());\n            synchronized(journalSetLock) {\n              IOUtils.cleanup(LOG, journalSet);\n            }\n            terminate(1, msg);\n          }\n        } finally {\n          // Prevent RuntimeException from blocking other log edit write \n          doneWithAutoSyncScheduling();\n        }\n        //editLogStream may become null,\n        //so store a local variable for flush.\n        logStream \u003d editLogStream;\n      }\n      \n      // do the sync\n      long start \u003d monotonicNow();\n      try {\n        if (logStream !\u003d null) {\n          logStream.flush();\n        }\n      } catch (IOException ex) {\n        synchronized (this) {\n          final String msg \u003d\n              \"Could not sync enough journals to persistent storage. \"\n              + \"Unsynced transactions: \" + (txid - synctxid);\n          LOG.fatal(msg, new Exception());\n          synchronized(journalSetLock) {\n            IOUtils.cleanup(LOG, journalSet);\n          }\n          terminate(1, msg);\n        }\n      }\n      long elapsed \u003d monotonicNow() - start;\n  \n      if (metrics !\u003d null) { // Metrics non-null only when used inside name node\n        metrics.addSync(elapsed);\n        metrics.incrTransactionsBatchedInSync(editsBatchedInSync);\n        numTransactionsBatchedInSync.addAndGet(editsBatchedInSync);\n      }\n      \n    } finally {\n      // Prevent RuntimeException from blocking other log edit sync \n      synchronized (this) {\n        if (sync) {\n          synctxid \u003d syncStart;\n          for (JournalManager jm : journalSet.getJournalManagers()) {\n            /**\n             * {@link FileJournalManager#lastReadableTxId} is only meaningful\n             * for file-based journals. Therefore the interface is not added to\n             * other types of {@link JournalManager}.\n             */\n            if (jm instanceof FileJournalManager) {\n              ((FileJournalManager)jm).setLastReadableTxId(syncStart);\n            }\n          }\n          isSyncRunning \u003d false;\n        }\n        this.notifyAll();\n     }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSEditLog.java",
      "extendedDetails": {}
    },
    "2151716832ad14932dd65b1a4e47e64d8d6cd767": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-7964. Add support for async edit logging. Contributed by Daryn Sharp.\n",
      "commitDate": "29/02/16 3:34 PM",
      "commitName": "2151716832ad14932dd65b1a4e47e64d8d6cd767",
      "commitAuthor": "Jing Zhao",
      "diff": "@@ -0,0 +1,106 @@\n+  protected void logSync(long mytxid) {\n+    long syncStart \u003d 0;\n+    boolean sync \u003d false;\n+    long editsBatchedInSync \u003d 0;\n+    try {\n+      EditLogOutputStream logStream \u003d null;\n+      synchronized (this) {\n+        try {\n+          printStatistics(false);\n+\n+          // if somebody is already syncing, then wait\n+          while (mytxid \u003e synctxid \u0026\u0026 isSyncRunning) {\n+            try {\n+              wait(1000);\n+            } catch (InterruptedException ie) {\n+            }\n+          }\n+  \n+          //\n+          // If this transaction was already flushed, then nothing to do\n+          //\n+          if (mytxid \u003c\u003d synctxid) {\n+            return;\n+          }\n+\n+          // now, this thread will do the sync.  track if other edits were\n+          // included in the sync - ie. batched.  if this is the only edit\n+          // synced then the batched count is 0\n+          editsBatchedInSync \u003d txid - synctxid - 1;\n+          syncStart \u003d txid;\n+          isSyncRunning \u003d true;\n+          sync \u003d true;\n+\n+          // swap buffers\n+          try {\n+            if (journalSet.isEmpty()) {\n+              throw new IOException(\"No journals available to flush\");\n+            }\n+            editLogStream.setReadyToFlush();\n+          } catch (IOException e) {\n+            final String msg \u003d\n+                \"Could not sync enough journals to persistent storage \" +\n+                \"due to \" + e.getMessage() + \". \" +\n+                \"Unsynced transactions: \" + (txid - synctxid);\n+            LOG.fatal(msg, new Exception());\n+            synchronized(journalSetLock) {\n+              IOUtils.cleanup(LOG, journalSet);\n+            }\n+            terminate(1, msg);\n+          }\n+        } finally {\n+          // Prevent RuntimeException from blocking other log edit write \n+          doneWithAutoSyncScheduling();\n+        }\n+        //editLogStream may become null,\n+        //so store a local variable for flush.\n+        logStream \u003d editLogStream;\n+      }\n+      \n+      // do the sync\n+      long start \u003d monotonicNow();\n+      try {\n+        if (logStream !\u003d null) {\n+          logStream.flush();\n+        }\n+      } catch (IOException ex) {\n+        synchronized (this) {\n+          final String msg \u003d\n+              \"Could not sync enough journals to persistent storage. \"\n+              + \"Unsynced transactions: \" + (txid - synctxid);\n+          LOG.fatal(msg, new Exception());\n+          synchronized(journalSetLock) {\n+            IOUtils.cleanup(LOG, journalSet);\n+          }\n+          terminate(1, msg);\n+        }\n+      }\n+      long elapsed \u003d monotonicNow() - start;\n+  \n+      if (metrics !\u003d null) { // Metrics non-null only when used inside name node\n+        metrics.addSync(elapsed);\n+        metrics.incrTransactionsBatchedInSync(editsBatchedInSync);\n+        numTransactionsBatchedInSync +\u003d editsBatchedInSync;\n+      }\n+      \n+    } finally {\n+      // Prevent RuntimeException from blocking other log edit sync \n+      synchronized (this) {\n+        if (sync) {\n+          synctxid \u003d syncStart;\n+          for (JournalManager jm : journalSet.getJournalManagers()) {\n+            /**\n+             * {@link FileJournalManager#lastReadableTxId} is only meaningful\n+             * for file-based journals. Therefore the interface is not added to\n+             * other types of {@link JournalManager}.\n+             */\n+            if (jm instanceof FileJournalManager) {\n+              ((FileJournalManager)jm).setLastReadableTxId(syncStart);\n+            }\n+          }\n+          isSyncRunning \u003d false;\n+        }\n+        this.notifyAll();\n+     }\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  protected void logSync(long mytxid) {\n    long syncStart \u003d 0;\n    boolean sync \u003d false;\n    long editsBatchedInSync \u003d 0;\n    try {\n      EditLogOutputStream logStream \u003d null;\n      synchronized (this) {\n        try {\n          printStatistics(false);\n\n          // if somebody is already syncing, then wait\n          while (mytxid \u003e synctxid \u0026\u0026 isSyncRunning) {\n            try {\n              wait(1000);\n            } catch (InterruptedException ie) {\n            }\n          }\n  \n          //\n          // If this transaction was already flushed, then nothing to do\n          //\n          if (mytxid \u003c\u003d synctxid) {\n            return;\n          }\n\n          // now, this thread will do the sync.  track if other edits were\n          // included in the sync - ie. batched.  if this is the only edit\n          // synced then the batched count is 0\n          editsBatchedInSync \u003d txid - synctxid - 1;\n          syncStart \u003d txid;\n          isSyncRunning \u003d true;\n          sync \u003d true;\n\n          // swap buffers\n          try {\n            if (journalSet.isEmpty()) {\n              throw new IOException(\"No journals available to flush\");\n            }\n            editLogStream.setReadyToFlush();\n          } catch (IOException e) {\n            final String msg \u003d\n                \"Could not sync enough journals to persistent storage \" +\n                \"due to \" + e.getMessage() + \". \" +\n                \"Unsynced transactions: \" + (txid - synctxid);\n            LOG.fatal(msg, new Exception());\n            synchronized(journalSetLock) {\n              IOUtils.cleanup(LOG, journalSet);\n            }\n            terminate(1, msg);\n          }\n        } finally {\n          // Prevent RuntimeException from blocking other log edit write \n          doneWithAutoSyncScheduling();\n        }\n        //editLogStream may become null,\n        //so store a local variable for flush.\n        logStream \u003d editLogStream;\n      }\n      \n      // do the sync\n      long start \u003d monotonicNow();\n      try {\n        if (logStream !\u003d null) {\n          logStream.flush();\n        }\n      } catch (IOException ex) {\n        synchronized (this) {\n          final String msg \u003d\n              \"Could not sync enough journals to persistent storage. \"\n              + \"Unsynced transactions: \" + (txid - synctxid);\n          LOG.fatal(msg, new Exception());\n          synchronized(journalSetLock) {\n            IOUtils.cleanup(LOG, journalSet);\n          }\n          terminate(1, msg);\n        }\n      }\n      long elapsed \u003d monotonicNow() - start;\n  \n      if (metrics !\u003d null) { // Metrics non-null only when used inside name node\n        metrics.addSync(elapsed);\n        metrics.incrTransactionsBatchedInSync(editsBatchedInSync);\n        numTransactionsBatchedInSync +\u003d editsBatchedInSync;\n      }\n      \n    } finally {\n      // Prevent RuntimeException from blocking other log edit sync \n      synchronized (this) {\n        if (sync) {\n          synctxid \u003d syncStart;\n          for (JournalManager jm : journalSet.getJournalManagers()) {\n            /**\n             * {@link FileJournalManager#lastReadableTxId} is only meaningful\n             * for file-based journals. Therefore the interface is not added to\n             * other types of {@link JournalManager}.\n             */\n            if (jm instanceof FileJournalManager) {\n              ((FileJournalManager)jm).setLastReadableTxId(syncStart);\n            }\n          }\n          isSyncRunning \u003d false;\n        }\n        this.notifyAll();\n     }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSEditLog.java"
    }
  }
}