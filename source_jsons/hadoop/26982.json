{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "CosNInputStream.java",
  "functionName": "reopen",
  "functionId": "reopen___pos-long",
  "sourceFilePath": "hadoop-cloud-storage-project/hadoop-cos/src/main/java/org/apache/hadoop/fs/cosn/CosNInputStream.java",
  "functionStartLine": 144,
  "functionEndLine": 238,
  "numCommitsSeen": 1,
  "timeTaken": 309,
  "changeHistory": [
    "8a9ede5cff816b66afc37e7c9d2b33aee48795d2"
  ],
  "changeHistoryShort": {
    "8a9ede5cff816b66afc37e7c9d2b33aee48795d2": "Yintroduced"
  },
  "changeHistoryDetails": {
    "8a9ede5cff816b66afc37e7c9d2b33aee48795d2": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-15616. Incorporate Tencent Cloud COS File System Implementation. Contributed by Yang Yu.\n",
      "commitDate": "27/09/19 1:53 AM",
      "commitName": "8a9ede5cff816b66afc37e7c9d2b33aee48795d2",
      "commitAuthor": "Sammi Chen",
      "diff": "@@ -0,0 +1,95 @@\n+  private synchronized void reopen(long pos) throws IOException {\n+    long partSize;\n+\n+    if (pos \u003c 0) {\n+      throw new EOFException(FSExceptionMessages.NEGATIVE_SEEK);\n+    } else if (pos \u003e this.fileSize) {\n+      throw new EOFException(FSExceptionMessages.CANNOT_SEEK_PAST_EOF);\n+    } else {\n+      if (pos + this.preReadPartSize \u003e this.fileSize) {\n+        partSize \u003d this.fileSize - pos;\n+      } else {\n+        partSize \u003d this.preReadPartSize;\n+      }\n+    }\n+\n+    this.buffer \u003d null;\n+\n+    boolean isRandomIO \u003d true;\n+    if (pos \u003d\u003d this.nextPos) {\n+      isRandomIO \u003d false;\n+    } else {\n+      while (this.readBufferQueue.size() !\u003d 0) {\n+        if (this.readBufferQueue.element().getStart() !\u003d pos) {\n+          this.readBufferQueue.poll();\n+        } else {\n+          break;\n+        }\n+      }\n+    }\n+\n+    this.nextPos \u003d pos + partSize;\n+\n+    int currentBufferQueueSize \u003d this.readBufferQueue.size();\n+    long lastByteStart;\n+    if (currentBufferQueueSize \u003d\u003d 0) {\n+      lastByteStart \u003d pos - partSize;\n+    } else {\n+      ReadBuffer[] readBuffers \u003d\n+          this.readBufferQueue.toArray(\n+              new ReadBuffer[currentBufferQueueSize]);\n+      lastByteStart \u003d readBuffers[currentBufferQueueSize - 1].getStart();\n+    }\n+\n+    int maxLen \u003d this.maxReadPartNumber - currentBufferQueueSize;\n+    for (int i \u003d 0; i \u003c maxLen \u0026\u0026 i \u003c (currentBufferQueueSize + 1) * 2; i++) {\n+      if (lastByteStart + partSize * (i + 1) \u003e this.fileSize) {\n+        break;\n+      }\n+\n+      long byteStart \u003d lastByteStart + partSize * (i + 1);\n+      long byteEnd \u003d byteStart + partSize - 1;\n+      if (byteEnd \u003e\u003d this.fileSize) {\n+        byteEnd \u003d this.fileSize - 1;\n+      }\n+\n+      ReadBuffer readBuffer \u003d new ReadBuffer(byteStart, byteEnd);\n+      if (readBuffer.getBuffer().length \u003d\u003d 0) {\n+        readBuffer.setStatus(ReadBuffer.SUCCESS);\n+      } else {\n+        this.readAheadExecutorService.execute(\n+            new CosNFileReadTask(\n+                this.conf, this.key, this.store, readBuffer));\n+      }\n+\n+      this.readBufferQueue.add(readBuffer);\n+      if (isRandomIO) {\n+        break;\n+      }\n+    }\n+\n+    ReadBuffer readBuffer \u003d this.readBufferQueue.poll();\n+    if (null !\u003d readBuffer) {\n+      readBuffer.lock();\n+      try {\n+        readBuffer.await(ReadBuffer.INIT);\n+        if (readBuffer.getStatus() \u003d\u003d ReadBuffer.ERROR) {\n+          this.buffer \u003d null;\n+        } else {\n+          this.buffer \u003d readBuffer.getBuffer();\n+        }\n+      } catch (InterruptedException e) {\n+        LOG.warn(\"An interrupted exception occurred \"\n+            + \"when waiting a read buffer.\");\n+      } finally {\n+        readBuffer.unLock();\n+      }\n+    }\n+\n+    if (null \u003d\u003d this.buffer) {\n+      throw new IOException(\"Null IO stream\");\n+    }\n+\n+    this.position \u003d pos;\n+    this.partRemaining \u003d partSize;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void reopen(long pos) throws IOException {\n    long partSize;\n\n    if (pos \u003c 0) {\n      throw new EOFException(FSExceptionMessages.NEGATIVE_SEEK);\n    } else if (pos \u003e this.fileSize) {\n      throw new EOFException(FSExceptionMessages.CANNOT_SEEK_PAST_EOF);\n    } else {\n      if (pos + this.preReadPartSize \u003e this.fileSize) {\n        partSize \u003d this.fileSize - pos;\n      } else {\n        partSize \u003d this.preReadPartSize;\n      }\n    }\n\n    this.buffer \u003d null;\n\n    boolean isRandomIO \u003d true;\n    if (pos \u003d\u003d this.nextPos) {\n      isRandomIO \u003d false;\n    } else {\n      while (this.readBufferQueue.size() !\u003d 0) {\n        if (this.readBufferQueue.element().getStart() !\u003d pos) {\n          this.readBufferQueue.poll();\n        } else {\n          break;\n        }\n      }\n    }\n\n    this.nextPos \u003d pos + partSize;\n\n    int currentBufferQueueSize \u003d this.readBufferQueue.size();\n    long lastByteStart;\n    if (currentBufferQueueSize \u003d\u003d 0) {\n      lastByteStart \u003d pos - partSize;\n    } else {\n      ReadBuffer[] readBuffers \u003d\n          this.readBufferQueue.toArray(\n              new ReadBuffer[currentBufferQueueSize]);\n      lastByteStart \u003d readBuffers[currentBufferQueueSize - 1].getStart();\n    }\n\n    int maxLen \u003d this.maxReadPartNumber - currentBufferQueueSize;\n    for (int i \u003d 0; i \u003c maxLen \u0026\u0026 i \u003c (currentBufferQueueSize + 1) * 2; i++) {\n      if (lastByteStart + partSize * (i + 1) \u003e this.fileSize) {\n        break;\n      }\n\n      long byteStart \u003d lastByteStart + partSize * (i + 1);\n      long byteEnd \u003d byteStart + partSize - 1;\n      if (byteEnd \u003e\u003d this.fileSize) {\n        byteEnd \u003d this.fileSize - 1;\n      }\n\n      ReadBuffer readBuffer \u003d new ReadBuffer(byteStart, byteEnd);\n      if (readBuffer.getBuffer().length \u003d\u003d 0) {\n        readBuffer.setStatus(ReadBuffer.SUCCESS);\n      } else {\n        this.readAheadExecutorService.execute(\n            new CosNFileReadTask(\n                this.conf, this.key, this.store, readBuffer));\n      }\n\n      this.readBufferQueue.add(readBuffer);\n      if (isRandomIO) {\n        break;\n      }\n    }\n\n    ReadBuffer readBuffer \u003d this.readBufferQueue.poll();\n    if (null !\u003d readBuffer) {\n      readBuffer.lock();\n      try {\n        readBuffer.await(ReadBuffer.INIT);\n        if (readBuffer.getStatus() \u003d\u003d ReadBuffer.ERROR) {\n          this.buffer \u003d null;\n        } else {\n          this.buffer \u003d readBuffer.getBuffer();\n        }\n      } catch (InterruptedException e) {\n        LOG.warn(\"An interrupted exception occurred \"\n            + \"when waiting a read buffer.\");\n      } finally {\n        readBuffer.unLock();\n      }\n    }\n\n    if (null \u003d\u003d this.buffer) {\n      throw new IOException(\"Null IO stream\");\n    }\n\n    this.position \u003d pos;\n    this.partRemaining \u003d partSize;\n  }",
      "path": "hadoop-cloud-storage-project/hadoop-cos/src/main/java/org/apache/hadoop/fs/cosn/CosNInputStream.java"
    }
  }
}