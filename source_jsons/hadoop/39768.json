{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "UsersManager.java",
  "functionName": "reComputeUserLimits",
  "functionId": "reComputeUserLimits___userName-String__nodePartition-String__clusterResource-Resource__schedulingMode-SchedulingMode__activeMode-boolean",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/UsersManager.java",
  "functionStartLine": 646,
  "functionEndLine": 674,
  "numCommitsSeen": 13,
  "timeTaken": 2173,
  "changeHistory": [
    "9485c9aee6e9bb935c3e6ae4da81d70b621781de",
    "5fb723bb77722d41df6959eee23e1b0cfeb5584e"
  ],
  "changeHistoryShort": {
    "9485c9aee6e9bb935c3e6ae4da81d70b621781de": "Ybodychange",
    "5fb723bb77722d41df6959eee23e1b0cfeb5584e": "Yintroduced"
  },
  "changeHistoryDetails": {
    "9485c9aee6e9bb935c3e6ae4da81d70b621781de": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4606. CapacityScheduler: applications could get starved because computation of #activeUsers considers pending apps. Contributed by Manikandan R\n",
      "commitDate": "25/07/18 9:22 AM",
      "commitName": "9485c9aee6e9bb935c3e6ae4da81d70b621781de",
      "commitAuthor": "Eric E Payne",
      "commitDateOld": "06/05/18 8:33 PM",
      "commitNameOld": "67f239c42f676237290d18ddbbc9aec369267692",
      "commitAuthorOld": "Weiwei Yang",
      "daysBetweenCommits": 79.53,
      "commitsBetweenForRepo": 580,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,27 +1,29 @@\n   private Map\u003cSchedulingMode, Resource\u003e reComputeUserLimits(String userName,\n       String nodePartition, Resource clusterResource,\n       SchedulingMode schedulingMode, boolean activeMode) {\n \n     // preselect stored map as per active user-limit or all user computation.\n     Map\u003cString, Map\u003cSchedulingMode, Resource\u003e\u003e computedMap \u003d null;\n     computedMap \u003d (activeMode)\n         ? preComputedActiveUserLimit\n         : preComputedAllUserLimit;\n \n     Map\u003cSchedulingMode, Resource\u003e userLimitPerSchedulingMode \u003d computedMap\n         .get(nodePartition);\n \n     if (userLimitPerSchedulingMode \u003d\u003d null) {\n       userLimitPerSchedulingMode \u003d new ConcurrentHashMap\u003c\u003e();\n       computedMap.put(nodePartition, userLimitPerSchedulingMode);\n     }\n \n     // compute user-limit per scheduling mode.\n     Resource computedUserLimit \u003d computeUserLimit(userName, clusterResource,\n         nodePartition, schedulingMode, activeMode);\n \n     // update in local storage\n     userLimitPerSchedulingMode.put(schedulingMode, computedUserLimit);\n \n+    computeNumActiveUsersWithOnlyPendingApps();\n+\n     return userLimitPerSchedulingMode;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Map\u003cSchedulingMode, Resource\u003e reComputeUserLimits(String userName,\n      String nodePartition, Resource clusterResource,\n      SchedulingMode schedulingMode, boolean activeMode) {\n\n    // preselect stored map as per active user-limit or all user computation.\n    Map\u003cString, Map\u003cSchedulingMode, Resource\u003e\u003e computedMap \u003d null;\n    computedMap \u003d (activeMode)\n        ? preComputedActiveUserLimit\n        : preComputedAllUserLimit;\n\n    Map\u003cSchedulingMode, Resource\u003e userLimitPerSchedulingMode \u003d computedMap\n        .get(nodePartition);\n\n    if (userLimitPerSchedulingMode \u003d\u003d null) {\n      userLimitPerSchedulingMode \u003d new ConcurrentHashMap\u003c\u003e();\n      computedMap.put(nodePartition, userLimitPerSchedulingMode);\n    }\n\n    // compute user-limit per scheduling mode.\n    Resource computedUserLimit \u003d computeUserLimit(userName, clusterResource,\n        nodePartition, schedulingMode, activeMode);\n\n    // update in local storage\n    userLimitPerSchedulingMode.put(schedulingMode, computedUserLimit);\n\n    computeNumActiveUsersWithOnlyPendingApps();\n\n    return userLimitPerSchedulingMode;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/UsersManager.java",
      "extendedDetails": {}
    },
    "5fb723bb77722d41df6959eee23e1b0cfeb5584e": {
      "type": "Yintroduced",
      "commitMessage": "YARN-5889. Improve and refactor user-limit calculation in Capacity Scheduler. (Sunil G via wangda)\n",
      "commitDate": "09/02/17 10:23 AM",
      "commitName": "5fb723bb77722d41df6959eee23e1b0cfeb5584e",
      "commitAuthor": "Wangda Tan",
      "diff": "@@ -0,0 +1,27 @@\n+  private Map\u003cSchedulingMode, Resource\u003e reComputeUserLimits(String userName,\n+      String nodePartition, Resource clusterResource,\n+      SchedulingMode schedulingMode, boolean activeMode) {\n+\n+    // preselect stored map as per active user-limit or all user computation.\n+    Map\u003cString, Map\u003cSchedulingMode, Resource\u003e\u003e computedMap \u003d null;\n+    computedMap \u003d (activeMode)\n+        ? preComputedActiveUserLimit\n+        : preComputedAllUserLimit;\n+\n+    Map\u003cSchedulingMode, Resource\u003e userLimitPerSchedulingMode \u003d computedMap\n+        .get(nodePartition);\n+\n+    if (userLimitPerSchedulingMode \u003d\u003d null) {\n+      userLimitPerSchedulingMode \u003d new ConcurrentHashMap\u003c\u003e();\n+      computedMap.put(nodePartition, userLimitPerSchedulingMode);\n+    }\n+\n+    // compute user-limit per scheduling mode.\n+    Resource computedUserLimit \u003d computeUserLimit(userName, clusterResource,\n+        nodePartition, schedulingMode, activeMode);\n+\n+    // update in local storage\n+    userLimitPerSchedulingMode.put(schedulingMode, computedUserLimit);\n+\n+    return userLimitPerSchedulingMode;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private Map\u003cSchedulingMode, Resource\u003e reComputeUserLimits(String userName,\n      String nodePartition, Resource clusterResource,\n      SchedulingMode schedulingMode, boolean activeMode) {\n\n    // preselect stored map as per active user-limit or all user computation.\n    Map\u003cString, Map\u003cSchedulingMode, Resource\u003e\u003e computedMap \u003d null;\n    computedMap \u003d (activeMode)\n        ? preComputedActiveUserLimit\n        : preComputedAllUserLimit;\n\n    Map\u003cSchedulingMode, Resource\u003e userLimitPerSchedulingMode \u003d computedMap\n        .get(nodePartition);\n\n    if (userLimitPerSchedulingMode \u003d\u003d null) {\n      userLimitPerSchedulingMode \u003d new ConcurrentHashMap\u003c\u003e();\n      computedMap.put(nodePartition, userLimitPerSchedulingMode);\n    }\n\n    // compute user-limit per scheduling mode.\n    Resource computedUserLimit \u003d computeUserLimit(userName, clusterResource,\n        nodePartition, schedulingMode, activeMode);\n\n    // update in local storage\n    userLimitPerSchedulingMode.put(schedulingMode, computedUserLimit);\n\n    return userLimitPerSchedulingMode;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/UsersManager.java"
    }
  }
}