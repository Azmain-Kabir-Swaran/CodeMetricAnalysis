{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "SelectTool.java",
  "functionName": "run",
  "functionId": "run___args-String[]__out-PrintStream",
  "sourceFilePath": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/select/SelectTool.java",
  "functionStartLine": 176,
  "functionEndLine": 334,
  "numCommitsSeen": 4,
  "timeTaken": 2791,
  "changeHistory": [
    "49df83899543586bbcaf80f01399ade031cf68b0",
    "e346e3638c595a512cd582739ff51fb64c3b4950",
    "52b2eab575d0b4d8ce7fa57661aaca6b8a123cc2",
    "f365957c6326f88734bc0a5d01cfb7eac713db20"
  ],
  "changeHistoryShort": {
    "49df83899543586bbcaf80f01399ade031cf68b0": "Ybodychange",
    "e346e3638c595a512cd582739ff51fb64c3b4950": "Ybodychange",
    "52b2eab575d0b4d8ce7fa57661aaca6b8a123cc2": "Ybodychange",
    "f365957c6326f88734bc0a5d01cfb7eac713db20": "Yintroduced"
  },
  "changeHistoryDetails": {
    "49df83899543586bbcaf80f01399ade031cf68b0": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16697. Tune/audit S3A authoritative mode.\n\nContains:\n\nHADOOP-16474. S3Guard ProgressiveRenameTracker to mark destination\n              dirirectory as authoritative on success.\nHADOOP-16684. S3guard bucket info to list a bit more about\n              authoritative paths.\nHADOOP-16722. S3GuardTool to support FilterFileSystem.\n\nThis patch improves the marking of newly created/import directory\ntrees in S3Guard DynamoDB tables as authoritative.\n\nSpecific changes:\n\n * Renamed directories are marked as authoritative if the entire\n   operation succeeded (HADOOP-16474).\n * When updating parent table entries as part of any table write,\n   there\u0027s no overwriting of their authoritative flag.\n\ns3guard import changes:\n\n* new -verbose flag to print out what is going on.\n\n* The \"s3guard import\" command lets you declare that a directory tree\nis to be marked as authoritative\n\n  hadoop s3guard import -authoritative -verbose s3a://bucket/path\n\nWhen importing a listing and a file is found, the import tool queries\nthe metastore and only updates the entry if the file is different from\nbefore, where different \u003d\u003d new timestamp, etag, or length. S3Guard can get\ntimestamp differences due to clock skew in PUT operations.\n\nAs the recursive list performed by the import command doesn\u0027t retrieve the\nversionID, the existing entry may in fact be more complete.\nWhen updating an existing due to clock skew the existing version ID\nis propagated to the new entry (note: the etags must match; this is needed\nto deal with inconsistent listings).\n\nThere is a new s3guard command to audit a s3guard bucket/path\u0027s\nauthoritative state:\n\n  hadoop s3guard authoritative -check-config s3a://bucket/path\n\nThis is primarily for testing/auditing.\n\nThe s3guard bucket-info command also provides some more details on the\nauthoritative state of a store (HADOOP-16684).\n\nChange-Id: I58001341c04f6f3597fcb4fcb1581ccefeb77d91\n",
      "commitDate": "10/01/20 3:11 AM",
      "commitName": "49df83899543586bbcaf80f01399ade031cf68b0",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "25/09/19 4:16 AM",
      "commitNameOld": "e346e3638c595a512cd582739ff51fb64c3b4950",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 107.0,
      "commitsBetweenForRepo": 462,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,164 +1,159 @@\n   public int run(String[] args, PrintStream out)\n       throws IOException, ExitUtil.ExitException {\n     final List\u003cString\u003e parsedArgs;\n     try {\n       parsedArgs \u003d parseArgs(args);\n     } catch (CommandFormat.UnknownOptionException e) {\n       errorln(getUsage());\n       throw new ExitUtil.ExitException(EXIT_USAGE, e.getMessage(), e);\n     }\n     if (parsedArgs.size() \u003c 2) {\n       errorln(getUsage());\n       throw new ExitUtil.ExitException(EXIT_USAGE, TOO_FEW_ARGUMENTS);\n     }\n \n     // read mandatory arguments\n     final String file \u003d parsedArgs.get(0);\n     final Path path \u003d new Path(file);\n \n     String expression \u003d parsedArgs.get(1);\n \n     println(out, \"selecting file %s with query %s\",\n         path, expression);\n \n     // and the optional arguments to adjust the configuration.\n     final Optional\u003cString\u003e header \u003d getOptValue(OPT_HEADER);\n     header.ifPresent(h -\u003e println(out, \"Using header option %s\", h));\n \n     Path destPath \u003d getOptValue(OPT_OUTPUT).map(\n         output -\u003e {\n           println(out, \"Saving output to %s\", output);\n           return new Path(output);\n         }).orElse(null);\n     final boolean toConsole \u003d destPath \u003d\u003d null;\n \n     // expected lines are only checked if empty\n     final Optional\u003cInteger\u003e expectedLines \u003d toConsole\n         ? getIntValue(OPT_EXPECTED)\n         : Optional.empty();\n \n     final Optional\u003cInteger\u003e limit \u003d getIntValue(OPT_LIMIT);\n     if (limit.isPresent()) {\n       final int l \u003d limit.get();\n       println(out, \"Using line limit %s\", l);\n       if (expression.toLowerCase(Locale.ENGLISH).contains(\" limit \")) {\n         println(out, \"line limit already specified in SELECT expression\");\n       } else {\n         expression \u003d expression + \" LIMIT \" + l;\n       }\n     }\n \n     // now bind to the filesystem.\n-    FileSystem fs \u003d path.getFileSystem(getConf());\n-    if (!(fs instanceof S3AFileSystem)) {\n-      throw new ExitUtil.ExitException(EXIT_SERVICE_UNAVAILABLE,\n-          WRONG_FILESYSTEM + file + \": got \" + fs);\n-    }\n-    setFilesystem((S3AFileSystem) fs);\n+    FileSystem fs \u003d bindFilesystem(path.getFileSystem(getConf()));\n \n-    if (!getFilesystem().hasPathCapability(path, S3_SELECT_CAPABILITY)) {\n+    if (!fs.hasPathCapability(path, S3_SELECT_CAPABILITY)) {\n       // capability disabled\n       throw new ExitUtil.ExitException(EXIT_SERVICE_UNAVAILABLE,\n           SELECT_IS_DISABLED + \" for \" + file);\n     }\n     linesRead \u003d 0;\n \n     selectDuration \u003d new OperationDuration();\n \n     // open and scan the stream.\n     final FutureDataInputStreamBuilder builder \u003d fs.openFile(path)\n         .must(SELECT_SQL, expression);\n \n     header.ifPresent(h -\u003e builder.must(CSV_INPUT_HEADER, h));\n \n     getOptValue(OPT_COMPRESSION).ifPresent(compression -\u003e\n         builder.must(SELECT_INPUT_COMPRESSION,\n           compression.toUpperCase(Locale.ENGLISH)));\n \n     getOptValue(OPT_INPUTFORMAT).ifPresent(opt -\u003e {\n       if (!\"csv\".equalsIgnoreCase(opt)) {\n         throw invalidArgs(\"Unsupported input format %s\", opt);\n       }\n     });\n     getOptValue(OPT_OUTPUTFORMAT).ifPresent(opt -\u003e {\n       if (!\"csv\".equalsIgnoreCase(opt)) {\n         throw invalidArgs(\"Unsupported output format %s\", opt);\n       }\n     });\n     // turn on SQL error reporting.\n     builder.opt(SELECT_ERRORS_INCLUDE_SQL, true);\n \n     FSDataInputStream stream;\n     try(DurationInfo ignored \u003d\n             new DurationInfo(LOG, \"Selecting stream\")) {\n       stream \u003d FutureIOSupport.awaitFuture(builder.build());\n     } catch (FileNotFoundException e) {\n       // the source file is missing.\n       throw storeNotFound(e);\n     }\n     try {\n       if (toConsole) {\n         // logging to console\n         bytesRead \u003d 0;\n         @SuppressWarnings(\"IOResourceOpenedButNotSafelyClosed\")\n         Scanner scanner \u003d\n             new Scanner(\n                 new BufferedReader(\n                     new InputStreamReader(stream, StandardCharsets.UTF_8)));\n         scanner.useDelimiter(\"\\n\");\n         while (scanner.hasNextLine()) {\n           linesRead++;\n           String l \u003d scanner.nextLine();\n           bytesRead +\u003d l.length() + 1;\n           println(out, \"%s\", l);\n         }\n       } else {\n         // straight dump of whole file; no line counting\n         FileSystem destFS \u003d destPath.getFileSystem(getConf());\n         try(DurationInfo ignored \u003d\n                 new DurationInfo(LOG, \"Copying File\");\n             OutputStream destStream \u003d destFS.createFile(destPath)\n                 .overwrite(true)\n                 .build()) {\n           bytesRead \u003d IOUtils.copy(stream, destStream);\n         }\n       }\n \n       // close the stream.\n       // this will take time if there\u0027s a lot of data remaining\n       try (DurationInfo ignored \u003d\n                new DurationInfo(LOG, \"Closing stream\")) {\n         stream.close();\n       }\n \n       // generate a meaningful result depending on the operation\n       String result \u003d toConsole\n           ? String.format(\"%s lines\", linesRead)\n           : String.format(\"%s bytes\", bytesRead);\n \n       // print some statistics\n       selectDuration.finished();\n       println(out, \"Read %s in time %s\",\n           result, selectDuration.getDurationString());\n \n       println(out, \"Bytes Read: %,d bytes\", bytesRead);\n \n       println(out, \"Bandwidth: %,.1f MiB/s\",\n           bandwidthMBs(bytesRead, selectDuration.value()));\n \n     } finally {\n       cleanupWithLogger(LOG, stream);\n     }\n \n     LOG.debug(\"Statistics {}\", stream);\n \n     expectedLines.ifPresent(l -\u003e {\n       if (l !\u003d linesRead) {\n         throw exitException(EXIT_FAIL,\n             \"Expected %d rows but the operation returned %d\",\n             l, linesRead);\n       }\n     });\n     out.flush();\n     return EXIT_SUCCESS;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int run(String[] args, PrintStream out)\n      throws IOException, ExitUtil.ExitException {\n    final List\u003cString\u003e parsedArgs;\n    try {\n      parsedArgs \u003d parseArgs(args);\n    } catch (CommandFormat.UnknownOptionException e) {\n      errorln(getUsage());\n      throw new ExitUtil.ExitException(EXIT_USAGE, e.getMessage(), e);\n    }\n    if (parsedArgs.size() \u003c 2) {\n      errorln(getUsage());\n      throw new ExitUtil.ExitException(EXIT_USAGE, TOO_FEW_ARGUMENTS);\n    }\n\n    // read mandatory arguments\n    final String file \u003d parsedArgs.get(0);\n    final Path path \u003d new Path(file);\n\n    String expression \u003d parsedArgs.get(1);\n\n    println(out, \"selecting file %s with query %s\",\n        path, expression);\n\n    // and the optional arguments to adjust the configuration.\n    final Optional\u003cString\u003e header \u003d getOptValue(OPT_HEADER);\n    header.ifPresent(h -\u003e println(out, \"Using header option %s\", h));\n\n    Path destPath \u003d getOptValue(OPT_OUTPUT).map(\n        output -\u003e {\n          println(out, \"Saving output to %s\", output);\n          return new Path(output);\n        }).orElse(null);\n    final boolean toConsole \u003d destPath \u003d\u003d null;\n\n    // expected lines are only checked if empty\n    final Optional\u003cInteger\u003e expectedLines \u003d toConsole\n        ? getIntValue(OPT_EXPECTED)\n        : Optional.empty();\n\n    final Optional\u003cInteger\u003e limit \u003d getIntValue(OPT_LIMIT);\n    if (limit.isPresent()) {\n      final int l \u003d limit.get();\n      println(out, \"Using line limit %s\", l);\n      if (expression.toLowerCase(Locale.ENGLISH).contains(\" limit \")) {\n        println(out, \"line limit already specified in SELECT expression\");\n      } else {\n        expression \u003d expression + \" LIMIT \" + l;\n      }\n    }\n\n    // now bind to the filesystem.\n    FileSystem fs \u003d bindFilesystem(path.getFileSystem(getConf()));\n\n    if (!fs.hasPathCapability(path, S3_SELECT_CAPABILITY)) {\n      // capability disabled\n      throw new ExitUtil.ExitException(EXIT_SERVICE_UNAVAILABLE,\n          SELECT_IS_DISABLED + \" for \" + file);\n    }\n    linesRead \u003d 0;\n\n    selectDuration \u003d new OperationDuration();\n\n    // open and scan the stream.\n    final FutureDataInputStreamBuilder builder \u003d fs.openFile(path)\n        .must(SELECT_SQL, expression);\n\n    header.ifPresent(h -\u003e builder.must(CSV_INPUT_HEADER, h));\n\n    getOptValue(OPT_COMPRESSION).ifPresent(compression -\u003e\n        builder.must(SELECT_INPUT_COMPRESSION,\n          compression.toUpperCase(Locale.ENGLISH)));\n\n    getOptValue(OPT_INPUTFORMAT).ifPresent(opt -\u003e {\n      if (!\"csv\".equalsIgnoreCase(opt)) {\n        throw invalidArgs(\"Unsupported input format %s\", opt);\n      }\n    });\n    getOptValue(OPT_OUTPUTFORMAT).ifPresent(opt -\u003e {\n      if (!\"csv\".equalsIgnoreCase(opt)) {\n        throw invalidArgs(\"Unsupported output format %s\", opt);\n      }\n    });\n    // turn on SQL error reporting.\n    builder.opt(SELECT_ERRORS_INCLUDE_SQL, true);\n\n    FSDataInputStream stream;\n    try(DurationInfo ignored \u003d\n            new DurationInfo(LOG, \"Selecting stream\")) {\n      stream \u003d FutureIOSupport.awaitFuture(builder.build());\n    } catch (FileNotFoundException e) {\n      // the source file is missing.\n      throw storeNotFound(e);\n    }\n    try {\n      if (toConsole) {\n        // logging to console\n        bytesRead \u003d 0;\n        @SuppressWarnings(\"IOResourceOpenedButNotSafelyClosed\")\n        Scanner scanner \u003d\n            new Scanner(\n                new BufferedReader(\n                    new InputStreamReader(stream, StandardCharsets.UTF_8)));\n        scanner.useDelimiter(\"\\n\");\n        while (scanner.hasNextLine()) {\n          linesRead++;\n          String l \u003d scanner.nextLine();\n          bytesRead +\u003d l.length() + 1;\n          println(out, \"%s\", l);\n        }\n      } else {\n        // straight dump of whole file; no line counting\n        FileSystem destFS \u003d destPath.getFileSystem(getConf());\n        try(DurationInfo ignored \u003d\n                new DurationInfo(LOG, \"Copying File\");\n            OutputStream destStream \u003d destFS.createFile(destPath)\n                .overwrite(true)\n                .build()) {\n          bytesRead \u003d IOUtils.copy(stream, destStream);\n        }\n      }\n\n      // close the stream.\n      // this will take time if there\u0027s a lot of data remaining\n      try (DurationInfo ignored \u003d\n               new DurationInfo(LOG, \"Closing stream\")) {\n        stream.close();\n      }\n\n      // generate a meaningful result depending on the operation\n      String result \u003d toConsole\n          ? String.format(\"%s lines\", linesRead)\n          : String.format(\"%s bytes\", bytesRead);\n\n      // print some statistics\n      selectDuration.finished();\n      println(out, \"Read %s in time %s\",\n          result, selectDuration.getDurationString());\n\n      println(out, \"Bytes Read: %,d bytes\", bytesRead);\n\n      println(out, \"Bandwidth: %,.1f MiB/s\",\n          bandwidthMBs(bytesRead, selectDuration.value()));\n\n    } finally {\n      cleanupWithLogger(LOG, stream);\n    }\n\n    LOG.debug(\"Statistics {}\", stream);\n\n    expectedLines.ifPresent(l -\u003e {\n      if (l !\u003d linesRead) {\n        throw exitException(EXIT_FAIL,\n            \"Expected %d rows but the operation returned %d\",\n            l, linesRead);\n      }\n    });\n    out.flush();\n    return EXIT_SUCCESS;\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/select/SelectTool.java",
      "extendedDetails": {}
    },
    "e346e3638c595a512cd582739ff51fb64c3b4950": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15691 Add PathCapabilities to FileSystem and FileContext.\n\nContributed by Steve Loughran.\n\nThis complements the StreamCapabilities Interface by allowing applications to probe for a specific path on a specific instance of a FileSystem client\nto offer a specific capability.\n\nThis is intended to allow applications to determine\n\n* Whether a method is implemented before calling it and dealing with UnsupportedOperationException.\n* Whether a specific feature is believed to be available in the remote store.\n\nAs well as a common set of capabilities defined in CommonPathCapabilities,\nfile systems are free to add their own capabilities, prefixed with\n fs. + schema + .\n\nThe plan is to identify and document more capabilities -and for file systems which add new features, for a declaration of the availability of the feature to always be available.\n\nNote\n\n* The remote store is not expected to be checked for the feature;\n  It is more a check of client API and the client\u0027s configuration/knowledge\n  of the state of the remote system.\n* Permissions are not checked.\n\nChange-Id: I80bfebe94f4a8bdad8f3ac055495735b824968f5\n",
      "commitDate": "25/09/19 4:16 AM",
      "commitName": "e346e3638c595a512cd582739ff51fb64c3b4950",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "26/02/19 9:10 AM",
      "commitNameOld": "52b2eab575d0b4d8ce7fa57661aaca6b8a123cc2",
      "commitAuthorOld": "Abhishek Modi",
      "daysBetweenCommits": 210.75,
      "commitsBetweenForRepo": 1645,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,164 +1,164 @@\n   public int run(String[] args, PrintStream out)\n       throws IOException, ExitUtil.ExitException {\n     final List\u003cString\u003e parsedArgs;\n     try {\n       parsedArgs \u003d parseArgs(args);\n     } catch (CommandFormat.UnknownOptionException e) {\n       errorln(getUsage());\n       throw new ExitUtil.ExitException(EXIT_USAGE, e.getMessage(), e);\n     }\n     if (parsedArgs.size() \u003c 2) {\n       errorln(getUsage());\n       throw new ExitUtil.ExitException(EXIT_USAGE, TOO_FEW_ARGUMENTS);\n     }\n \n     // read mandatory arguments\n     final String file \u003d parsedArgs.get(0);\n     final Path path \u003d new Path(file);\n \n     String expression \u003d parsedArgs.get(1);\n \n     println(out, \"selecting file %s with query %s\",\n         path, expression);\n \n     // and the optional arguments to adjust the configuration.\n     final Optional\u003cString\u003e header \u003d getOptValue(OPT_HEADER);\n     header.ifPresent(h -\u003e println(out, \"Using header option %s\", h));\n \n     Path destPath \u003d getOptValue(OPT_OUTPUT).map(\n         output -\u003e {\n           println(out, \"Saving output to %s\", output);\n           return new Path(output);\n         }).orElse(null);\n     final boolean toConsole \u003d destPath \u003d\u003d null;\n \n     // expected lines are only checked if empty\n     final Optional\u003cInteger\u003e expectedLines \u003d toConsole\n         ? getIntValue(OPT_EXPECTED)\n         : Optional.empty();\n \n     final Optional\u003cInteger\u003e limit \u003d getIntValue(OPT_LIMIT);\n     if (limit.isPresent()) {\n       final int l \u003d limit.get();\n       println(out, \"Using line limit %s\", l);\n       if (expression.toLowerCase(Locale.ENGLISH).contains(\" limit \")) {\n         println(out, \"line limit already specified in SELECT expression\");\n       } else {\n         expression \u003d expression + \" LIMIT \" + l;\n       }\n     }\n \n     // now bind to the filesystem.\n     FileSystem fs \u003d path.getFileSystem(getConf());\n     if (!(fs instanceof S3AFileSystem)) {\n       throw new ExitUtil.ExitException(EXIT_SERVICE_UNAVAILABLE,\n           WRONG_FILESYSTEM + file + \": got \" + fs);\n     }\n     setFilesystem((S3AFileSystem) fs);\n \n-    if (!getFilesystem().hasCapability(S3_SELECT_CAPABILITY)) {\n+    if (!getFilesystem().hasPathCapability(path, S3_SELECT_CAPABILITY)) {\n       // capability disabled\n       throw new ExitUtil.ExitException(EXIT_SERVICE_UNAVAILABLE,\n           SELECT_IS_DISABLED + \" for \" + file);\n     }\n     linesRead \u003d 0;\n \n     selectDuration \u003d new OperationDuration();\n \n     // open and scan the stream.\n     final FutureDataInputStreamBuilder builder \u003d fs.openFile(path)\n         .must(SELECT_SQL, expression);\n \n     header.ifPresent(h -\u003e builder.must(CSV_INPUT_HEADER, h));\n \n     getOptValue(OPT_COMPRESSION).ifPresent(compression -\u003e\n         builder.must(SELECT_INPUT_COMPRESSION,\n           compression.toUpperCase(Locale.ENGLISH)));\n \n     getOptValue(OPT_INPUTFORMAT).ifPresent(opt -\u003e {\n       if (!\"csv\".equalsIgnoreCase(opt)) {\n         throw invalidArgs(\"Unsupported input format %s\", opt);\n       }\n     });\n     getOptValue(OPT_OUTPUTFORMAT).ifPresent(opt -\u003e {\n       if (!\"csv\".equalsIgnoreCase(opt)) {\n         throw invalidArgs(\"Unsupported output format %s\", opt);\n       }\n     });\n     // turn on SQL error reporting.\n     builder.opt(SELECT_ERRORS_INCLUDE_SQL, true);\n \n     FSDataInputStream stream;\n     try(DurationInfo ignored \u003d\n             new DurationInfo(LOG, \"Selecting stream\")) {\n       stream \u003d FutureIOSupport.awaitFuture(builder.build());\n     } catch (FileNotFoundException e) {\n       // the source file is missing.\n       throw storeNotFound(e);\n     }\n     try {\n       if (toConsole) {\n         // logging to console\n         bytesRead \u003d 0;\n         @SuppressWarnings(\"IOResourceOpenedButNotSafelyClosed\")\n         Scanner scanner \u003d\n             new Scanner(\n                 new BufferedReader(\n                     new InputStreamReader(stream, StandardCharsets.UTF_8)));\n         scanner.useDelimiter(\"\\n\");\n         while (scanner.hasNextLine()) {\n           linesRead++;\n           String l \u003d scanner.nextLine();\n           bytesRead +\u003d l.length() + 1;\n           println(out, \"%s\", l);\n         }\n       } else {\n         // straight dump of whole file; no line counting\n         FileSystem destFS \u003d destPath.getFileSystem(getConf());\n         try(DurationInfo ignored \u003d\n                 new DurationInfo(LOG, \"Copying File\");\n             OutputStream destStream \u003d destFS.createFile(destPath)\n                 .overwrite(true)\n                 .build()) {\n           bytesRead \u003d IOUtils.copy(stream, destStream);\n         }\n       }\n \n       // close the stream.\n       // this will take time if there\u0027s a lot of data remaining\n       try (DurationInfo ignored \u003d\n                new DurationInfo(LOG, \"Closing stream\")) {\n         stream.close();\n       }\n \n       // generate a meaningful result depending on the operation\n       String result \u003d toConsole\n           ? String.format(\"%s lines\", linesRead)\n           : String.format(\"%s bytes\", bytesRead);\n \n       // print some statistics\n       selectDuration.finished();\n       println(out, \"Read %s in time %s\",\n           result, selectDuration.getDurationString());\n \n       println(out, \"Bytes Read: %,d bytes\", bytesRead);\n \n       println(out, \"Bandwidth: %,.1f MiB/s\",\n           bandwidthMBs(bytesRead, selectDuration.value()));\n \n     } finally {\n       cleanupWithLogger(LOG, stream);\n     }\n \n     LOG.debug(\"Statistics {}\", stream);\n \n     expectedLines.ifPresent(l -\u003e {\n       if (l !\u003d linesRead) {\n         throw exitException(EXIT_FAIL,\n             \"Expected %d rows but the operation returned %d\",\n             l, linesRead);\n       }\n     });\n     out.flush();\n     return EXIT_SUCCESS;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int run(String[] args, PrintStream out)\n      throws IOException, ExitUtil.ExitException {\n    final List\u003cString\u003e parsedArgs;\n    try {\n      parsedArgs \u003d parseArgs(args);\n    } catch (CommandFormat.UnknownOptionException e) {\n      errorln(getUsage());\n      throw new ExitUtil.ExitException(EXIT_USAGE, e.getMessage(), e);\n    }\n    if (parsedArgs.size() \u003c 2) {\n      errorln(getUsage());\n      throw new ExitUtil.ExitException(EXIT_USAGE, TOO_FEW_ARGUMENTS);\n    }\n\n    // read mandatory arguments\n    final String file \u003d parsedArgs.get(0);\n    final Path path \u003d new Path(file);\n\n    String expression \u003d parsedArgs.get(1);\n\n    println(out, \"selecting file %s with query %s\",\n        path, expression);\n\n    // and the optional arguments to adjust the configuration.\n    final Optional\u003cString\u003e header \u003d getOptValue(OPT_HEADER);\n    header.ifPresent(h -\u003e println(out, \"Using header option %s\", h));\n\n    Path destPath \u003d getOptValue(OPT_OUTPUT).map(\n        output -\u003e {\n          println(out, \"Saving output to %s\", output);\n          return new Path(output);\n        }).orElse(null);\n    final boolean toConsole \u003d destPath \u003d\u003d null;\n\n    // expected lines are only checked if empty\n    final Optional\u003cInteger\u003e expectedLines \u003d toConsole\n        ? getIntValue(OPT_EXPECTED)\n        : Optional.empty();\n\n    final Optional\u003cInteger\u003e limit \u003d getIntValue(OPT_LIMIT);\n    if (limit.isPresent()) {\n      final int l \u003d limit.get();\n      println(out, \"Using line limit %s\", l);\n      if (expression.toLowerCase(Locale.ENGLISH).contains(\" limit \")) {\n        println(out, \"line limit already specified in SELECT expression\");\n      } else {\n        expression \u003d expression + \" LIMIT \" + l;\n      }\n    }\n\n    // now bind to the filesystem.\n    FileSystem fs \u003d path.getFileSystem(getConf());\n    if (!(fs instanceof S3AFileSystem)) {\n      throw new ExitUtil.ExitException(EXIT_SERVICE_UNAVAILABLE,\n          WRONG_FILESYSTEM + file + \": got \" + fs);\n    }\n    setFilesystem((S3AFileSystem) fs);\n\n    if (!getFilesystem().hasPathCapability(path, S3_SELECT_CAPABILITY)) {\n      // capability disabled\n      throw new ExitUtil.ExitException(EXIT_SERVICE_UNAVAILABLE,\n          SELECT_IS_DISABLED + \" for \" + file);\n    }\n    linesRead \u003d 0;\n\n    selectDuration \u003d new OperationDuration();\n\n    // open and scan the stream.\n    final FutureDataInputStreamBuilder builder \u003d fs.openFile(path)\n        .must(SELECT_SQL, expression);\n\n    header.ifPresent(h -\u003e builder.must(CSV_INPUT_HEADER, h));\n\n    getOptValue(OPT_COMPRESSION).ifPresent(compression -\u003e\n        builder.must(SELECT_INPUT_COMPRESSION,\n          compression.toUpperCase(Locale.ENGLISH)));\n\n    getOptValue(OPT_INPUTFORMAT).ifPresent(opt -\u003e {\n      if (!\"csv\".equalsIgnoreCase(opt)) {\n        throw invalidArgs(\"Unsupported input format %s\", opt);\n      }\n    });\n    getOptValue(OPT_OUTPUTFORMAT).ifPresent(opt -\u003e {\n      if (!\"csv\".equalsIgnoreCase(opt)) {\n        throw invalidArgs(\"Unsupported output format %s\", opt);\n      }\n    });\n    // turn on SQL error reporting.\n    builder.opt(SELECT_ERRORS_INCLUDE_SQL, true);\n\n    FSDataInputStream stream;\n    try(DurationInfo ignored \u003d\n            new DurationInfo(LOG, \"Selecting stream\")) {\n      stream \u003d FutureIOSupport.awaitFuture(builder.build());\n    } catch (FileNotFoundException e) {\n      // the source file is missing.\n      throw storeNotFound(e);\n    }\n    try {\n      if (toConsole) {\n        // logging to console\n        bytesRead \u003d 0;\n        @SuppressWarnings(\"IOResourceOpenedButNotSafelyClosed\")\n        Scanner scanner \u003d\n            new Scanner(\n                new BufferedReader(\n                    new InputStreamReader(stream, StandardCharsets.UTF_8)));\n        scanner.useDelimiter(\"\\n\");\n        while (scanner.hasNextLine()) {\n          linesRead++;\n          String l \u003d scanner.nextLine();\n          bytesRead +\u003d l.length() + 1;\n          println(out, \"%s\", l);\n        }\n      } else {\n        // straight dump of whole file; no line counting\n        FileSystem destFS \u003d destPath.getFileSystem(getConf());\n        try(DurationInfo ignored \u003d\n                new DurationInfo(LOG, \"Copying File\");\n            OutputStream destStream \u003d destFS.createFile(destPath)\n                .overwrite(true)\n                .build()) {\n          bytesRead \u003d IOUtils.copy(stream, destStream);\n        }\n      }\n\n      // close the stream.\n      // this will take time if there\u0027s a lot of data remaining\n      try (DurationInfo ignored \u003d\n               new DurationInfo(LOG, \"Closing stream\")) {\n        stream.close();\n      }\n\n      // generate a meaningful result depending on the operation\n      String result \u003d toConsole\n          ? String.format(\"%s lines\", linesRead)\n          : String.format(\"%s bytes\", bytesRead);\n\n      // print some statistics\n      selectDuration.finished();\n      println(out, \"Read %s in time %s\",\n          result, selectDuration.getDurationString());\n\n      println(out, \"Bytes Read: %,d bytes\", bytesRead);\n\n      println(out, \"Bandwidth: %,.1f MiB/s\",\n          bandwidthMBs(bytesRead, selectDuration.value()));\n\n    } finally {\n      cleanupWithLogger(LOG, stream);\n    }\n\n    LOG.debug(\"Statistics {}\", stream);\n\n    expectedLines.ifPresent(l -\u003e {\n      if (l !\u003d linesRead) {\n        throw exitException(EXIT_FAIL,\n            \"Expected %d rows but the operation returned %d\",\n            l, linesRead);\n      }\n    });\n    out.flush();\n    return EXIT_SUCCESS;\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/select/SelectTool.java",
      "extendedDetails": {}
    },
    "52b2eab575d0b4d8ce7fa57661aaca6b8a123cc2": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16093. Move DurationInfo from hadoop-aws to hadoop-common org.apache.hadoop.util.\n\nContributed by Abhishek Modi\n",
      "commitDate": "26/02/19 9:10 AM",
      "commitName": "52b2eab575d0b4d8ce7fa57661aaca6b8a123cc2",
      "commitAuthor": "Abhishek Modi",
      "commitDateOld": "05/02/19 3:51 AM",
      "commitNameOld": "f365957c6326f88734bc0a5d01cfb7eac713db20",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 21.22,
      "commitsBetweenForRepo": 184,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,164 +1,164 @@\n   public int run(String[] args, PrintStream out)\n       throws IOException, ExitUtil.ExitException {\n     final List\u003cString\u003e parsedArgs;\n     try {\n       parsedArgs \u003d parseArgs(args);\n     } catch (CommandFormat.UnknownOptionException e) {\n       errorln(getUsage());\n       throw new ExitUtil.ExitException(EXIT_USAGE, e.getMessage(), e);\n     }\n     if (parsedArgs.size() \u003c 2) {\n       errorln(getUsage());\n       throw new ExitUtil.ExitException(EXIT_USAGE, TOO_FEW_ARGUMENTS);\n     }\n \n     // read mandatory arguments\n     final String file \u003d parsedArgs.get(0);\n     final Path path \u003d new Path(file);\n \n     String expression \u003d parsedArgs.get(1);\n \n     println(out, \"selecting file %s with query %s\",\n         path, expression);\n \n     // and the optional arguments to adjust the configuration.\n     final Optional\u003cString\u003e header \u003d getOptValue(OPT_HEADER);\n     header.ifPresent(h -\u003e println(out, \"Using header option %s\", h));\n \n     Path destPath \u003d getOptValue(OPT_OUTPUT).map(\n         output -\u003e {\n           println(out, \"Saving output to %s\", output);\n           return new Path(output);\n         }).orElse(null);\n     final boolean toConsole \u003d destPath \u003d\u003d null;\n \n     // expected lines are only checked if empty\n     final Optional\u003cInteger\u003e expectedLines \u003d toConsole\n         ? getIntValue(OPT_EXPECTED)\n         : Optional.empty();\n \n     final Optional\u003cInteger\u003e limit \u003d getIntValue(OPT_LIMIT);\n     if (limit.isPresent()) {\n       final int l \u003d limit.get();\n       println(out, \"Using line limit %s\", l);\n       if (expression.toLowerCase(Locale.ENGLISH).contains(\" limit \")) {\n         println(out, \"line limit already specified in SELECT expression\");\n       } else {\n         expression \u003d expression + \" LIMIT \" + l;\n       }\n     }\n \n     // now bind to the filesystem.\n     FileSystem fs \u003d path.getFileSystem(getConf());\n     if (!(fs instanceof S3AFileSystem)) {\n       throw new ExitUtil.ExitException(EXIT_SERVICE_UNAVAILABLE,\n           WRONG_FILESYSTEM + file + \": got \" + fs);\n     }\n     setFilesystem((S3AFileSystem) fs);\n \n     if (!getFilesystem().hasCapability(S3_SELECT_CAPABILITY)) {\n       // capability disabled\n       throw new ExitUtil.ExitException(EXIT_SERVICE_UNAVAILABLE,\n           SELECT_IS_DISABLED + \" for \" + file);\n     }\n     linesRead \u003d 0;\n \n-    selectDuration \u003d new Duration();\n+    selectDuration \u003d new OperationDuration();\n \n     // open and scan the stream.\n     final FutureDataInputStreamBuilder builder \u003d fs.openFile(path)\n         .must(SELECT_SQL, expression);\n \n     header.ifPresent(h -\u003e builder.must(CSV_INPUT_HEADER, h));\n \n     getOptValue(OPT_COMPRESSION).ifPresent(compression -\u003e\n         builder.must(SELECT_INPUT_COMPRESSION,\n           compression.toUpperCase(Locale.ENGLISH)));\n \n     getOptValue(OPT_INPUTFORMAT).ifPresent(opt -\u003e {\n       if (!\"csv\".equalsIgnoreCase(opt)) {\n         throw invalidArgs(\"Unsupported input format %s\", opt);\n       }\n     });\n     getOptValue(OPT_OUTPUTFORMAT).ifPresent(opt -\u003e {\n       if (!\"csv\".equalsIgnoreCase(opt)) {\n         throw invalidArgs(\"Unsupported output format %s\", opt);\n       }\n     });\n     // turn on SQL error reporting.\n     builder.opt(SELECT_ERRORS_INCLUDE_SQL, true);\n \n     FSDataInputStream stream;\n     try(DurationInfo ignored \u003d\n             new DurationInfo(LOG, \"Selecting stream\")) {\n       stream \u003d FutureIOSupport.awaitFuture(builder.build());\n     } catch (FileNotFoundException e) {\n       // the source file is missing.\n       throw storeNotFound(e);\n     }\n     try {\n       if (toConsole) {\n         // logging to console\n         bytesRead \u003d 0;\n         @SuppressWarnings(\"IOResourceOpenedButNotSafelyClosed\")\n         Scanner scanner \u003d\n             new Scanner(\n                 new BufferedReader(\n                     new InputStreamReader(stream, StandardCharsets.UTF_8)));\n         scanner.useDelimiter(\"\\n\");\n         while (scanner.hasNextLine()) {\n           linesRead++;\n           String l \u003d scanner.nextLine();\n           bytesRead +\u003d l.length() + 1;\n           println(out, \"%s\", l);\n         }\n       } else {\n         // straight dump of whole file; no line counting\n         FileSystem destFS \u003d destPath.getFileSystem(getConf());\n         try(DurationInfo ignored \u003d\n                 new DurationInfo(LOG, \"Copying File\");\n             OutputStream destStream \u003d destFS.createFile(destPath)\n                 .overwrite(true)\n                 .build()) {\n           bytesRead \u003d IOUtils.copy(stream, destStream);\n         }\n       }\n \n       // close the stream.\n       // this will take time if there\u0027s a lot of data remaining\n       try (DurationInfo ignored \u003d\n                new DurationInfo(LOG, \"Closing stream\")) {\n         stream.close();\n       }\n \n       // generate a meaningful result depending on the operation\n       String result \u003d toConsole\n           ? String.format(\"%s lines\", linesRead)\n           : String.format(\"%s bytes\", bytesRead);\n \n       // print some statistics\n       selectDuration.finished();\n       println(out, \"Read %s in time %s\",\n           result, selectDuration.getDurationString());\n \n       println(out, \"Bytes Read: %,d bytes\", bytesRead);\n \n       println(out, \"Bandwidth: %,.1f MiB/s\",\n           bandwidthMBs(bytesRead, selectDuration.value()));\n \n     } finally {\n       cleanupWithLogger(LOG, stream);\n     }\n \n     LOG.debug(\"Statistics {}\", stream);\n \n     expectedLines.ifPresent(l -\u003e {\n       if (l !\u003d linesRead) {\n         throw exitException(EXIT_FAIL,\n             \"Expected %d rows but the operation returned %d\",\n             l, linesRead);\n       }\n     });\n     out.flush();\n     return EXIT_SUCCESS;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int run(String[] args, PrintStream out)\n      throws IOException, ExitUtil.ExitException {\n    final List\u003cString\u003e parsedArgs;\n    try {\n      parsedArgs \u003d parseArgs(args);\n    } catch (CommandFormat.UnknownOptionException e) {\n      errorln(getUsage());\n      throw new ExitUtil.ExitException(EXIT_USAGE, e.getMessage(), e);\n    }\n    if (parsedArgs.size() \u003c 2) {\n      errorln(getUsage());\n      throw new ExitUtil.ExitException(EXIT_USAGE, TOO_FEW_ARGUMENTS);\n    }\n\n    // read mandatory arguments\n    final String file \u003d parsedArgs.get(0);\n    final Path path \u003d new Path(file);\n\n    String expression \u003d parsedArgs.get(1);\n\n    println(out, \"selecting file %s with query %s\",\n        path, expression);\n\n    // and the optional arguments to adjust the configuration.\n    final Optional\u003cString\u003e header \u003d getOptValue(OPT_HEADER);\n    header.ifPresent(h -\u003e println(out, \"Using header option %s\", h));\n\n    Path destPath \u003d getOptValue(OPT_OUTPUT).map(\n        output -\u003e {\n          println(out, \"Saving output to %s\", output);\n          return new Path(output);\n        }).orElse(null);\n    final boolean toConsole \u003d destPath \u003d\u003d null;\n\n    // expected lines are only checked if empty\n    final Optional\u003cInteger\u003e expectedLines \u003d toConsole\n        ? getIntValue(OPT_EXPECTED)\n        : Optional.empty();\n\n    final Optional\u003cInteger\u003e limit \u003d getIntValue(OPT_LIMIT);\n    if (limit.isPresent()) {\n      final int l \u003d limit.get();\n      println(out, \"Using line limit %s\", l);\n      if (expression.toLowerCase(Locale.ENGLISH).contains(\" limit \")) {\n        println(out, \"line limit already specified in SELECT expression\");\n      } else {\n        expression \u003d expression + \" LIMIT \" + l;\n      }\n    }\n\n    // now bind to the filesystem.\n    FileSystem fs \u003d path.getFileSystem(getConf());\n    if (!(fs instanceof S3AFileSystem)) {\n      throw new ExitUtil.ExitException(EXIT_SERVICE_UNAVAILABLE,\n          WRONG_FILESYSTEM + file + \": got \" + fs);\n    }\n    setFilesystem((S3AFileSystem) fs);\n\n    if (!getFilesystem().hasCapability(S3_SELECT_CAPABILITY)) {\n      // capability disabled\n      throw new ExitUtil.ExitException(EXIT_SERVICE_UNAVAILABLE,\n          SELECT_IS_DISABLED + \" for \" + file);\n    }\n    linesRead \u003d 0;\n\n    selectDuration \u003d new OperationDuration();\n\n    // open and scan the stream.\n    final FutureDataInputStreamBuilder builder \u003d fs.openFile(path)\n        .must(SELECT_SQL, expression);\n\n    header.ifPresent(h -\u003e builder.must(CSV_INPUT_HEADER, h));\n\n    getOptValue(OPT_COMPRESSION).ifPresent(compression -\u003e\n        builder.must(SELECT_INPUT_COMPRESSION,\n          compression.toUpperCase(Locale.ENGLISH)));\n\n    getOptValue(OPT_INPUTFORMAT).ifPresent(opt -\u003e {\n      if (!\"csv\".equalsIgnoreCase(opt)) {\n        throw invalidArgs(\"Unsupported input format %s\", opt);\n      }\n    });\n    getOptValue(OPT_OUTPUTFORMAT).ifPresent(opt -\u003e {\n      if (!\"csv\".equalsIgnoreCase(opt)) {\n        throw invalidArgs(\"Unsupported output format %s\", opt);\n      }\n    });\n    // turn on SQL error reporting.\n    builder.opt(SELECT_ERRORS_INCLUDE_SQL, true);\n\n    FSDataInputStream stream;\n    try(DurationInfo ignored \u003d\n            new DurationInfo(LOG, \"Selecting stream\")) {\n      stream \u003d FutureIOSupport.awaitFuture(builder.build());\n    } catch (FileNotFoundException e) {\n      // the source file is missing.\n      throw storeNotFound(e);\n    }\n    try {\n      if (toConsole) {\n        // logging to console\n        bytesRead \u003d 0;\n        @SuppressWarnings(\"IOResourceOpenedButNotSafelyClosed\")\n        Scanner scanner \u003d\n            new Scanner(\n                new BufferedReader(\n                    new InputStreamReader(stream, StandardCharsets.UTF_8)));\n        scanner.useDelimiter(\"\\n\");\n        while (scanner.hasNextLine()) {\n          linesRead++;\n          String l \u003d scanner.nextLine();\n          bytesRead +\u003d l.length() + 1;\n          println(out, \"%s\", l);\n        }\n      } else {\n        // straight dump of whole file; no line counting\n        FileSystem destFS \u003d destPath.getFileSystem(getConf());\n        try(DurationInfo ignored \u003d\n                new DurationInfo(LOG, \"Copying File\");\n            OutputStream destStream \u003d destFS.createFile(destPath)\n                .overwrite(true)\n                .build()) {\n          bytesRead \u003d IOUtils.copy(stream, destStream);\n        }\n      }\n\n      // close the stream.\n      // this will take time if there\u0027s a lot of data remaining\n      try (DurationInfo ignored \u003d\n               new DurationInfo(LOG, \"Closing stream\")) {\n        stream.close();\n      }\n\n      // generate a meaningful result depending on the operation\n      String result \u003d toConsole\n          ? String.format(\"%s lines\", linesRead)\n          : String.format(\"%s bytes\", bytesRead);\n\n      // print some statistics\n      selectDuration.finished();\n      println(out, \"Read %s in time %s\",\n          result, selectDuration.getDurationString());\n\n      println(out, \"Bytes Read: %,d bytes\", bytesRead);\n\n      println(out, \"Bandwidth: %,.1f MiB/s\",\n          bandwidthMBs(bytesRead, selectDuration.value()));\n\n    } finally {\n      cleanupWithLogger(LOG, stream);\n    }\n\n    LOG.debug(\"Statistics {}\", stream);\n\n    expectedLines.ifPresent(l -\u003e {\n      if (l !\u003d linesRead) {\n        throw exitException(EXIT_FAIL,\n            \"Expected %d rows but the operation returned %d\",\n            l, linesRead);\n      }\n    });\n    out.flush();\n    return EXIT_SUCCESS;\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/select/SelectTool.java",
      "extendedDetails": {}
    },
    "f365957c6326f88734bc0a5d01cfb7eac713db20": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-15229. Add FileSystem builder-based openFile() API to match createFile();\nS3A to implement S3 Select through this API.\n\nThe new openFile() API is asynchronous, and implemented across FileSystem and FileContext.\n\nThe MapReduce V2 inputs are moved to this API, and you can actually set must/may\noptions to pass in.\n\nThis is more useful for setting things like s3a seek policy than for S3 select,\nas the existing input format/record readers can\u0027t handle S3 select output where\nthe stream is shorter than the file length, and splitting plain text is suboptimal.\nFuture work is needed there.\n\nIn the meantime, any/all filesystem connectors are now free to add their own filesystem-specific\nconfiguration parameters which can be set in jobs and used to set filesystem input stream\noptions (seek policy, retry, encryption secrets, etc).\n\nContributed by Steve Loughran\n",
      "commitDate": "05/02/19 3:51 AM",
      "commitName": "f365957c6326f88734bc0a5d01cfb7eac713db20",
      "commitAuthor": "Steve Loughran",
      "diff": "@@ -0,0 +1,164 @@\n+  public int run(String[] args, PrintStream out)\n+      throws IOException, ExitUtil.ExitException {\n+    final List\u003cString\u003e parsedArgs;\n+    try {\n+      parsedArgs \u003d parseArgs(args);\n+    } catch (CommandFormat.UnknownOptionException e) {\n+      errorln(getUsage());\n+      throw new ExitUtil.ExitException(EXIT_USAGE, e.getMessage(), e);\n+    }\n+    if (parsedArgs.size() \u003c 2) {\n+      errorln(getUsage());\n+      throw new ExitUtil.ExitException(EXIT_USAGE, TOO_FEW_ARGUMENTS);\n+    }\n+\n+    // read mandatory arguments\n+    final String file \u003d parsedArgs.get(0);\n+    final Path path \u003d new Path(file);\n+\n+    String expression \u003d parsedArgs.get(1);\n+\n+    println(out, \"selecting file %s with query %s\",\n+        path, expression);\n+\n+    // and the optional arguments to adjust the configuration.\n+    final Optional\u003cString\u003e header \u003d getOptValue(OPT_HEADER);\n+    header.ifPresent(h -\u003e println(out, \"Using header option %s\", h));\n+\n+    Path destPath \u003d getOptValue(OPT_OUTPUT).map(\n+        output -\u003e {\n+          println(out, \"Saving output to %s\", output);\n+          return new Path(output);\n+        }).orElse(null);\n+    final boolean toConsole \u003d destPath \u003d\u003d null;\n+\n+    // expected lines are only checked if empty\n+    final Optional\u003cInteger\u003e expectedLines \u003d toConsole\n+        ? getIntValue(OPT_EXPECTED)\n+        : Optional.empty();\n+\n+    final Optional\u003cInteger\u003e limit \u003d getIntValue(OPT_LIMIT);\n+    if (limit.isPresent()) {\n+      final int l \u003d limit.get();\n+      println(out, \"Using line limit %s\", l);\n+      if (expression.toLowerCase(Locale.ENGLISH).contains(\" limit \")) {\n+        println(out, \"line limit already specified in SELECT expression\");\n+      } else {\n+        expression \u003d expression + \" LIMIT \" + l;\n+      }\n+    }\n+\n+    // now bind to the filesystem.\n+    FileSystem fs \u003d path.getFileSystem(getConf());\n+    if (!(fs instanceof S3AFileSystem)) {\n+      throw new ExitUtil.ExitException(EXIT_SERVICE_UNAVAILABLE,\n+          WRONG_FILESYSTEM + file + \": got \" + fs);\n+    }\n+    setFilesystem((S3AFileSystem) fs);\n+\n+    if (!getFilesystem().hasCapability(S3_SELECT_CAPABILITY)) {\n+      // capability disabled\n+      throw new ExitUtil.ExitException(EXIT_SERVICE_UNAVAILABLE,\n+          SELECT_IS_DISABLED + \" for \" + file);\n+    }\n+    linesRead \u003d 0;\n+\n+    selectDuration \u003d new Duration();\n+\n+    // open and scan the stream.\n+    final FutureDataInputStreamBuilder builder \u003d fs.openFile(path)\n+        .must(SELECT_SQL, expression);\n+\n+    header.ifPresent(h -\u003e builder.must(CSV_INPUT_HEADER, h));\n+\n+    getOptValue(OPT_COMPRESSION).ifPresent(compression -\u003e\n+        builder.must(SELECT_INPUT_COMPRESSION,\n+          compression.toUpperCase(Locale.ENGLISH)));\n+\n+    getOptValue(OPT_INPUTFORMAT).ifPresent(opt -\u003e {\n+      if (!\"csv\".equalsIgnoreCase(opt)) {\n+        throw invalidArgs(\"Unsupported input format %s\", opt);\n+      }\n+    });\n+    getOptValue(OPT_OUTPUTFORMAT).ifPresent(opt -\u003e {\n+      if (!\"csv\".equalsIgnoreCase(opt)) {\n+        throw invalidArgs(\"Unsupported output format %s\", opt);\n+      }\n+    });\n+    // turn on SQL error reporting.\n+    builder.opt(SELECT_ERRORS_INCLUDE_SQL, true);\n+\n+    FSDataInputStream stream;\n+    try(DurationInfo ignored \u003d\n+            new DurationInfo(LOG, \"Selecting stream\")) {\n+      stream \u003d FutureIOSupport.awaitFuture(builder.build());\n+    } catch (FileNotFoundException e) {\n+      // the source file is missing.\n+      throw storeNotFound(e);\n+    }\n+    try {\n+      if (toConsole) {\n+        // logging to console\n+        bytesRead \u003d 0;\n+        @SuppressWarnings(\"IOResourceOpenedButNotSafelyClosed\")\n+        Scanner scanner \u003d\n+            new Scanner(\n+                new BufferedReader(\n+                    new InputStreamReader(stream, StandardCharsets.UTF_8)));\n+        scanner.useDelimiter(\"\\n\");\n+        while (scanner.hasNextLine()) {\n+          linesRead++;\n+          String l \u003d scanner.nextLine();\n+          bytesRead +\u003d l.length() + 1;\n+          println(out, \"%s\", l);\n+        }\n+      } else {\n+        // straight dump of whole file; no line counting\n+        FileSystem destFS \u003d destPath.getFileSystem(getConf());\n+        try(DurationInfo ignored \u003d\n+                new DurationInfo(LOG, \"Copying File\");\n+            OutputStream destStream \u003d destFS.createFile(destPath)\n+                .overwrite(true)\n+                .build()) {\n+          bytesRead \u003d IOUtils.copy(stream, destStream);\n+        }\n+      }\n+\n+      // close the stream.\n+      // this will take time if there\u0027s a lot of data remaining\n+      try (DurationInfo ignored \u003d\n+               new DurationInfo(LOG, \"Closing stream\")) {\n+        stream.close();\n+      }\n+\n+      // generate a meaningful result depending on the operation\n+      String result \u003d toConsole\n+          ? String.format(\"%s lines\", linesRead)\n+          : String.format(\"%s bytes\", bytesRead);\n+\n+      // print some statistics\n+      selectDuration.finished();\n+      println(out, \"Read %s in time %s\",\n+          result, selectDuration.getDurationString());\n+\n+      println(out, \"Bytes Read: %,d bytes\", bytesRead);\n+\n+      println(out, \"Bandwidth: %,.1f MiB/s\",\n+          bandwidthMBs(bytesRead, selectDuration.value()));\n+\n+    } finally {\n+      cleanupWithLogger(LOG, stream);\n+    }\n+\n+    LOG.debug(\"Statistics {}\", stream);\n+\n+    expectedLines.ifPresent(l -\u003e {\n+      if (l !\u003d linesRead) {\n+        throw exitException(EXIT_FAIL,\n+            \"Expected %d rows but the operation returned %d\",\n+            l, linesRead);\n+      }\n+    });\n+    out.flush();\n+    return EXIT_SUCCESS;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public int run(String[] args, PrintStream out)\n      throws IOException, ExitUtil.ExitException {\n    final List\u003cString\u003e parsedArgs;\n    try {\n      parsedArgs \u003d parseArgs(args);\n    } catch (CommandFormat.UnknownOptionException e) {\n      errorln(getUsage());\n      throw new ExitUtil.ExitException(EXIT_USAGE, e.getMessage(), e);\n    }\n    if (parsedArgs.size() \u003c 2) {\n      errorln(getUsage());\n      throw new ExitUtil.ExitException(EXIT_USAGE, TOO_FEW_ARGUMENTS);\n    }\n\n    // read mandatory arguments\n    final String file \u003d parsedArgs.get(0);\n    final Path path \u003d new Path(file);\n\n    String expression \u003d parsedArgs.get(1);\n\n    println(out, \"selecting file %s with query %s\",\n        path, expression);\n\n    // and the optional arguments to adjust the configuration.\n    final Optional\u003cString\u003e header \u003d getOptValue(OPT_HEADER);\n    header.ifPresent(h -\u003e println(out, \"Using header option %s\", h));\n\n    Path destPath \u003d getOptValue(OPT_OUTPUT).map(\n        output -\u003e {\n          println(out, \"Saving output to %s\", output);\n          return new Path(output);\n        }).orElse(null);\n    final boolean toConsole \u003d destPath \u003d\u003d null;\n\n    // expected lines are only checked if empty\n    final Optional\u003cInteger\u003e expectedLines \u003d toConsole\n        ? getIntValue(OPT_EXPECTED)\n        : Optional.empty();\n\n    final Optional\u003cInteger\u003e limit \u003d getIntValue(OPT_LIMIT);\n    if (limit.isPresent()) {\n      final int l \u003d limit.get();\n      println(out, \"Using line limit %s\", l);\n      if (expression.toLowerCase(Locale.ENGLISH).contains(\" limit \")) {\n        println(out, \"line limit already specified in SELECT expression\");\n      } else {\n        expression \u003d expression + \" LIMIT \" + l;\n      }\n    }\n\n    // now bind to the filesystem.\n    FileSystem fs \u003d path.getFileSystem(getConf());\n    if (!(fs instanceof S3AFileSystem)) {\n      throw new ExitUtil.ExitException(EXIT_SERVICE_UNAVAILABLE,\n          WRONG_FILESYSTEM + file + \": got \" + fs);\n    }\n    setFilesystem((S3AFileSystem) fs);\n\n    if (!getFilesystem().hasCapability(S3_SELECT_CAPABILITY)) {\n      // capability disabled\n      throw new ExitUtil.ExitException(EXIT_SERVICE_UNAVAILABLE,\n          SELECT_IS_DISABLED + \" for \" + file);\n    }\n    linesRead \u003d 0;\n\n    selectDuration \u003d new Duration();\n\n    // open and scan the stream.\n    final FutureDataInputStreamBuilder builder \u003d fs.openFile(path)\n        .must(SELECT_SQL, expression);\n\n    header.ifPresent(h -\u003e builder.must(CSV_INPUT_HEADER, h));\n\n    getOptValue(OPT_COMPRESSION).ifPresent(compression -\u003e\n        builder.must(SELECT_INPUT_COMPRESSION,\n          compression.toUpperCase(Locale.ENGLISH)));\n\n    getOptValue(OPT_INPUTFORMAT).ifPresent(opt -\u003e {\n      if (!\"csv\".equalsIgnoreCase(opt)) {\n        throw invalidArgs(\"Unsupported input format %s\", opt);\n      }\n    });\n    getOptValue(OPT_OUTPUTFORMAT).ifPresent(opt -\u003e {\n      if (!\"csv\".equalsIgnoreCase(opt)) {\n        throw invalidArgs(\"Unsupported output format %s\", opt);\n      }\n    });\n    // turn on SQL error reporting.\n    builder.opt(SELECT_ERRORS_INCLUDE_SQL, true);\n\n    FSDataInputStream stream;\n    try(DurationInfo ignored \u003d\n            new DurationInfo(LOG, \"Selecting stream\")) {\n      stream \u003d FutureIOSupport.awaitFuture(builder.build());\n    } catch (FileNotFoundException e) {\n      // the source file is missing.\n      throw storeNotFound(e);\n    }\n    try {\n      if (toConsole) {\n        // logging to console\n        bytesRead \u003d 0;\n        @SuppressWarnings(\"IOResourceOpenedButNotSafelyClosed\")\n        Scanner scanner \u003d\n            new Scanner(\n                new BufferedReader(\n                    new InputStreamReader(stream, StandardCharsets.UTF_8)));\n        scanner.useDelimiter(\"\\n\");\n        while (scanner.hasNextLine()) {\n          linesRead++;\n          String l \u003d scanner.nextLine();\n          bytesRead +\u003d l.length() + 1;\n          println(out, \"%s\", l);\n        }\n      } else {\n        // straight dump of whole file; no line counting\n        FileSystem destFS \u003d destPath.getFileSystem(getConf());\n        try(DurationInfo ignored \u003d\n                new DurationInfo(LOG, \"Copying File\");\n            OutputStream destStream \u003d destFS.createFile(destPath)\n                .overwrite(true)\n                .build()) {\n          bytesRead \u003d IOUtils.copy(stream, destStream);\n        }\n      }\n\n      // close the stream.\n      // this will take time if there\u0027s a lot of data remaining\n      try (DurationInfo ignored \u003d\n               new DurationInfo(LOG, \"Closing stream\")) {\n        stream.close();\n      }\n\n      // generate a meaningful result depending on the operation\n      String result \u003d toConsole\n          ? String.format(\"%s lines\", linesRead)\n          : String.format(\"%s bytes\", bytesRead);\n\n      // print some statistics\n      selectDuration.finished();\n      println(out, \"Read %s in time %s\",\n          result, selectDuration.getDurationString());\n\n      println(out, \"Bytes Read: %,d bytes\", bytesRead);\n\n      println(out, \"Bandwidth: %,.1f MiB/s\",\n          bandwidthMBs(bytesRead, selectDuration.value()));\n\n    } finally {\n      cleanupWithLogger(LOG, stream);\n    }\n\n    LOG.debug(\"Statistics {}\", stream);\n\n    expectedLines.ifPresent(l -\u003e {\n      if (l !\u003d linesRead) {\n        throw exitException(EXIT_FAIL,\n            \"Expected %d rows but the operation returned %d\",\n            l, linesRead);\n      }\n    });\n    out.flush();\n    return EXIT_SUCCESS;\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/select/SelectTool.java"
    }
  }
}