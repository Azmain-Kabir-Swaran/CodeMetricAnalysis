{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "AdHocLogDumper.java",
  "functionName": "dumpLogs",
  "functionId": "dumpLogs___level-String__timePeriod-int",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/util/AdHocLogDumper.java",
  "functionStartLine": 64,
  "functionEndLine": 114,
  "numCommitsSeen": 3,
  "timeTaken": 1124,
  "changeHistory": [
    "bd8d299ded742813cabd4b4e7ce1e33e0d1f9509",
    "d27e9241e8676a0edb2d35453cac5f9495fcd605"
  ],
  "changeHistoryShort": {
    "bd8d299ded742813cabd4b4e7ce1e33e0d1f9509": "Ybodychange",
    "d27e9241e8676a0edb2d35453cac5f9495fcd605": "Yintroduced"
  },
  "changeHistoryDetails": {
    "bd8d299ded742813cabd4b4e7ce1e33e0d1f9509": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7477. Moving logging APIs over to slf4j in hadoop-yarn-common. Contributed by Prabhu Joseph.\n",
      "commitDate": "03/03/19 11:59 PM",
      "commitName": "bd8d299ded742813cabd4b4e7ce1e33e0d1f9509",
      "commitAuthor": "Akira Ajisaka",
      "commitDateOld": "26/05/16 10:14 PM",
      "commitNameOld": "0a544f8a3e52f3467003a731d77380f56343d322",
      "commitAuthorOld": "Rohith Sharma K S",
      "daysBetweenCommits": 1011.11,
      "commitsBetweenForRepo": 7736,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,56 +1,51 @@\n   public void dumpLogs(String level, int timePeriod)\n       throws YarnRuntimeException, IOException {\n-    synchronized (lock) {\n+    synchronized (lock){\n       if (logFlag) {\n         LOG.info(\"Attempt to dump logs when appender is already running\");\n         throw new YarnRuntimeException(\"Appender is already dumping logs\");\n       }\n       Level targetLevel \u003d Level.toLevel(level);\n-      Log log \u003d LogFactory.getLog(name);\n+      Logger logger \u003d LogManager.getLogger(name);\n       appenderLevels.clear();\n-      if (log instanceof Log4JLogger) {\n-        Logger packageLogger \u003d ((Log4JLogger) log).getLogger();\n-        currentLogLevel \u003d packageLogger.getLevel();\n-        Level currentEffectiveLevel \u003d packageLogger.getEffectiveLevel();\n+      currentLogLevel \u003d logger.getLevel();\n+      Level currentEffectiveLevel \u003d logger.getEffectiveLevel();\n \n-        // make sure we can create the appender first\n-        Layout layout \u003d new PatternLayout(\"%d{ISO8601} %p %c: %m%n\");\n-        FileAppender fApp;\n-        File file \u003d\n-            new File(System.getProperty(\"yarn.log.dir\"), targetFilename);\n-        try {\n-          fApp \u003d new FileAppender(layout, file.getAbsolutePath(), false);\n-        } catch (IOException ie) {\n-          LOG\n-            .warn(\n-              \"Error creating file, can\u0027t dump logs to \"\n-                  + file.getAbsolutePath(), ie);\n-          throw ie;\n-        }\n-        fApp.setName(AdHocLogDumper.AD_HOC_DUMPER_APPENDER);\n-        fApp.setThreshold(targetLevel);\n-\n-        // get current threshold of all appenders and set it to the effective\n-        // level\n-        for (Enumeration appenders \u003d Logger.getRootLogger().getAllAppenders(); appenders\n-          .hasMoreElements();) {\n-          Object obj \u003d appenders.nextElement();\n-          if (obj instanceof AppenderSkeleton) {\n-            AppenderSkeleton appender \u003d (AppenderSkeleton) obj;\n-            appenderLevels.put(appender.getName(), appender.getThreshold());\n-            appender.setThreshold(currentEffectiveLevel);\n-          }\n-        }\n-\n-        packageLogger.addAppender(fApp);\n-        LOG.info(\"Dumping adhoc logs for \" + name + \" to \"\n-            + file.getAbsolutePath() + \" for \" + timePeriod + \" milliseconds\");\n-        packageLogger.setLevel(targetLevel);\n-        logFlag \u003d true;\n-\n-        TimerTask restoreLogLevel \u003d new RestoreLogLevel();\n-        Timer restoreLogLevelTimer \u003d new Timer();\n-        restoreLogLevelTimer.schedule(restoreLogLevel, timePeriod);\n+      // make sure we can create the appender first\n+      Layout layout \u003d new PatternLayout(\"%d{ISO8601} %p %c: %m%n\");\n+      FileAppender fApp;\n+      File file \u003d\n+          new File(System.getProperty(\"yarn.log.dir\"), targetFilename);\n+      try {\n+        fApp \u003d new FileAppender(layout, file.getAbsolutePath(), false);\n+      } catch (IOException ie) {\n+        LOG.warn(\"Error creating file, can\u0027t dump logs to \"\n+            + file.getAbsolutePath(), ie);\n+        throw ie;\n       }\n+      fApp.setName(AdHocLogDumper.AD_HOC_DUMPER_APPENDER);\n+      fApp.setThreshold(targetLevel);\n+\n+      // get current threshold of all appenders and set it to the effective\n+      // level\n+      for (Enumeration appenders \u003d Logger.getRootLogger().getAllAppenders();\n+          appenders.hasMoreElements();) {\n+        Object obj \u003d appenders.nextElement();\n+        if (obj instanceof AppenderSkeleton) {\n+          AppenderSkeleton appender \u003d (AppenderSkeleton) obj;\n+          appenderLevels.put(appender.getName(), appender.getThreshold());\n+          appender.setThreshold(currentEffectiveLevel);\n+        }\n+      }\n+\n+      logger.addAppender(fApp);\n+      LOG.info(\"Dumping adhoc logs for \" + name + \" to \"\n+          + file.getAbsolutePath() + \" for \" + timePeriod + \" milliseconds\");\n+      logger.setLevel(targetLevel);\n+      logFlag \u003d true;\n+\n+      TimerTask restoreLogLevel \u003d new RestoreLogLevel();\n+      Timer restoreLogLevelTimer \u003d new Timer();\n+      restoreLogLevelTimer.schedule(restoreLogLevel, timePeriod);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void dumpLogs(String level, int timePeriod)\n      throws YarnRuntimeException, IOException {\n    synchronized (lock){\n      if (logFlag) {\n        LOG.info(\"Attempt to dump logs when appender is already running\");\n        throw new YarnRuntimeException(\"Appender is already dumping logs\");\n      }\n      Level targetLevel \u003d Level.toLevel(level);\n      Logger logger \u003d LogManager.getLogger(name);\n      appenderLevels.clear();\n      currentLogLevel \u003d logger.getLevel();\n      Level currentEffectiveLevel \u003d logger.getEffectiveLevel();\n\n      // make sure we can create the appender first\n      Layout layout \u003d new PatternLayout(\"%d{ISO8601} %p %c: %m%n\");\n      FileAppender fApp;\n      File file \u003d\n          new File(System.getProperty(\"yarn.log.dir\"), targetFilename);\n      try {\n        fApp \u003d new FileAppender(layout, file.getAbsolutePath(), false);\n      } catch (IOException ie) {\n        LOG.warn(\"Error creating file, can\u0027t dump logs to \"\n            + file.getAbsolutePath(), ie);\n        throw ie;\n      }\n      fApp.setName(AdHocLogDumper.AD_HOC_DUMPER_APPENDER);\n      fApp.setThreshold(targetLevel);\n\n      // get current threshold of all appenders and set it to the effective\n      // level\n      for (Enumeration appenders \u003d Logger.getRootLogger().getAllAppenders();\n          appenders.hasMoreElements();) {\n        Object obj \u003d appenders.nextElement();\n        if (obj instanceof AppenderSkeleton) {\n          AppenderSkeleton appender \u003d (AppenderSkeleton) obj;\n          appenderLevels.put(appender.getName(), appender.getThreshold());\n          appender.setThreshold(currentEffectiveLevel);\n        }\n      }\n\n      logger.addAppender(fApp);\n      LOG.info(\"Dumping adhoc logs for \" + name + \" to \"\n          + file.getAbsolutePath() + \" for \" + timePeriod + \" milliseconds\");\n      logger.setLevel(targetLevel);\n      logFlag \u003d true;\n\n      TimerTask restoreLogLevel \u003d new RestoreLogLevel();\n      Timer restoreLogLevelTimer \u003d new Timer();\n      restoreLogLevelTimer.schedule(restoreLogLevel, timePeriod);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/util/AdHocLogDumper.java",
      "extendedDetails": {}
    },
    "d27e9241e8676a0edb2d35453cac5f9495fcd605": {
      "type": "Yintroduced",
      "commitMessage": "YARN-3294. Allow dumping of Capacity Scheduler debug logs via web UI for\na fixed time period. Contributed by Varun Vasudev\n",
      "commitDate": "07/04/15 9:52 AM",
      "commitName": "d27e9241e8676a0edb2d35453cac5f9495fcd605",
      "commitAuthor": "Xuan",
      "diff": "@@ -0,0 +1,56 @@\n+  public void dumpLogs(String level, int timePeriod)\n+      throws YarnRuntimeException, IOException {\n+    synchronized (lock) {\n+      if (logFlag) {\n+        LOG.info(\"Attempt to dump logs when appender is already running\");\n+        throw new YarnRuntimeException(\"Appender is already dumping logs\");\n+      }\n+      Level targetLevel \u003d Level.toLevel(level);\n+      Log log \u003d LogFactory.getLog(name);\n+      appenderLevels.clear();\n+      if (log instanceof Log4JLogger) {\n+        Logger packageLogger \u003d ((Log4JLogger) log).getLogger();\n+        currentLogLevel \u003d packageLogger.getLevel();\n+        Level currentEffectiveLevel \u003d packageLogger.getEffectiveLevel();\n+\n+        // make sure we can create the appender first\n+        Layout layout \u003d new PatternLayout(\"%d{ISO8601} %p %c: %m%n\");\n+        FileAppender fApp;\n+        File file \u003d\n+            new File(System.getProperty(\"yarn.log.dir\"), targetFilename);\n+        try {\n+          fApp \u003d new FileAppender(layout, file.getAbsolutePath(), false);\n+        } catch (IOException ie) {\n+          LOG\n+            .warn(\n+              \"Error creating file, can\u0027t dump logs to \"\n+                  + file.getAbsolutePath(), ie);\n+          throw ie;\n+        }\n+        fApp.setName(AdHocLogDumper.AD_HOC_DUMPER_APPENDER);\n+        fApp.setThreshold(targetLevel);\n+\n+        // get current threshold of all appenders and set it to the effective\n+        // level\n+        for (Enumeration appenders \u003d Logger.getRootLogger().getAllAppenders(); appenders\n+          .hasMoreElements();) {\n+          Object obj \u003d appenders.nextElement();\n+          if (obj instanceof AppenderSkeleton) {\n+            AppenderSkeleton appender \u003d (AppenderSkeleton) obj;\n+            appenderLevels.put(appender.getName(), appender.getThreshold());\n+            appender.setThreshold(currentEffectiveLevel);\n+          }\n+        }\n+\n+        packageLogger.addAppender(fApp);\n+        LOG.info(\"Dumping adhoc logs for \" + name + \" to \"\n+            + file.getAbsolutePath() + \" for \" + timePeriod + \" milliseconds\");\n+        packageLogger.setLevel(targetLevel);\n+        logFlag \u003d true;\n+\n+        TimerTask restoreLogLevel \u003d new RestoreLogLevel();\n+        Timer restoreLogLevelTimer \u003d new Timer();\n+        restoreLogLevelTimer.schedule(restoreLogLevel, timePeriod);\n+      }\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void dumpLogs(String level, int timePeriod)\n      throws YarnRuntimeException, IOException {\n    synchronized (lock) {\n      if (logFlag) {\n        LOG.info(\"Attempt to dump logs when appender is already running\");\n        throw new YarnRuntimeException(\"Appender is already dumping logs\");\n      }\n      Level targetLevel \u003d Level.toLevel(level);\n      Log log \u003d LogFactory.getLog(name);\n      appenderLevels.clear();\n      if (log instanceof Log4JLogger) {\n        Logger packageLogger \u003d ((Log4JLogger) log).getLogger();\n        currentLogLevel \u003d packageLogger.getLevel();\n        Level currentEffectiveLevel \u003d packageLogger.getEffectiveLevel();\n\n        // make sure we can create the appender first\n        Layout layout \u003d new PatternLayout(\"%d{ISO8601} %p %c: %m%n\");\n        FileAppender fApp;\n        File file \u003d\n            new File(System.getProperty(\"yarn.log.dir\"), targetFilename);\n        try {\n          fApp \u003d new FileAppender(layout, file.getAbsolutePath(), false);\n        } catch (IOException ie) {\n          LOG\n            .warn(\n              \"Error creating file, can\u0027t dump logs to \"\n                  + file.getAbsolutePath(), ie);\n          throw ie;\n        }\n        fApp.setName(AdHocLogDumper.AD_HOC_DUMPER_APPENDER);\n        fApp.setThreshold(targetLevel);\n\n        // get current threshold of all appenders and set it to the effective\n        // level\n        for (Enumeration appenders \u003d Logger.getRootLogger().getAllAppenders(); appenders\n          .hasMoreElements();) {\n          Object obj \u003d appenders.nextElement();\n          if (obj instanceof AppenderSkeleton) {\n            AppenderSkeleton appender \u003d (AppenderSkeleton) obj;\n            appenderLevels.put(appender.getName(), appender.getThreshold());\n            appender.setThreshold(currentEffectiveLevel);\n          }\n        }\n\n        packageLogger.addAppender(fApp);\n        LOG.info(\"Dumping adhoc logs for \" + name + \" to \"\n            + file.getAbsolutePath() + \" for \" + timePeriod + \" milliseconds\");\n        packageLogger.setLevel(targetLevel);\n        logFlag \u003d true;\n\n        TimerTask restoreLogLevel \u003d new RestoreLogLevel();\n        Timer restoreLogLevelTimer \u003d new Timer();\n        restoreLogLevelTimer.schedule(restoreLogLevel, timePeriod);\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/util/AdHocLogDumper.java"
    }
  }
}