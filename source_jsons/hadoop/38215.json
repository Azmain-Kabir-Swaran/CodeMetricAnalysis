{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ProportionalCapacityPreemptionPolicy.java",
  "functionName": "cloneQueues",
  "functionId": "cloneQueues___curQueue-CSQueue__partitionResource-Resource__partitionToLookAt-String",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java",
  "functionStartLine": 563,
  "functionEndLine": 635,
  "numCommitsSeen": 77,
  "timeTaken": 9346,
  "changeHistory": [
    "cdb2107066a2d8557270888c0a9a75f29a6853bf",
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635",
    "5e798b1a0ddceeaf54703b94052501867156e979",
    "ce832059db077fa95922198b066a737ed4f609fe",
    "fad9609d13e76e9e3a4e01c96f698bb60b03807e",
    "bb62e0592566b2fcae7136b30972aad2d3ac55b0",
    "60e4116bf1d00afed91010e57357fe54057e4e39",
    "ae14e5d07f1b6702a5160637438028bb03d9387e",
    "fa7a43529d529f0006c8033c2003f15b9b93f103",
    "7e8c9beb4156dcaeb3a11e60aaa06d2370626913",
    "2346fa3141bf28f25a90b6a426a1d3a3982e464f",
    "3540d5fe4b1da942ea80c9e7ca1126b1abb8a68a",
    "1df39c1efc9ed26d3f1a5887c31c38c873e0b784",
    "d497f6ea2be559aa31ed76f37ae949dbfabe2a51",
    "27e8ea820fab8dce59f4db9814e73bd60c1d4ef1",
    "18741adf97f4fda5f8743318b59c440928e51297",
    "4b130821995a3cfe20c71e38e0f63294085c0491",
    "45b42676f9333ed4fa05355ccb4e1f91a9556525",
    "85f0efb68f9d1d9ee3466e3939c4fc2f985ccf61"
  ],
  "changeHistoryShort": {
    "cdb2107066a2d8557270888c0a9a75f29a6853bf": "Ybodychange",
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635": "Ybodychange",
    "5e798b1a0ddceeaf54703b94052501867156e979": "Ybodychange",
    "ce832059db077fa95922198b066a737ed4f609fe": "Ybodychange",
    "fad9609d13e76e9e3a4e01c96f698bb60b03807e": "Ybodychange",
    "bb62e0592566b2fcae7136b30972aad2d3ac55b0": "Ybodychange",
    "60e4116bf1d00afed91010e57357fe54057e4e39": "Ybodychange",
    "ae14e5d07f1b6702a5160637438028bb03d9387e": "Ybodychange",
    "fa7a43529d529f0006c8033c2003f15b9b93f103": "Ybodychange",
    "7e8c9beb4156dcaeb3a11e60aaa06d2370626913": "Ybodychange",
    "2346fa3141bf28f25a90b6a426a1d3a3982e464f": "Ybodychange",
    "3540d5fe4b1da942ea80c9e7ca1126b1abb8a68a": "Ybodychange",
    "1df39c1efc9ed26d3f1a5887c31c38c873e0b784": "Ybodychange",
    "d497f6ea2be559aa31ed76f37ae949dbfabe2a51": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
    "27e8ea820fab8dce59f4db9814e73bd60c1d4ef1": "Ybodychange",
    "18741adf97f4fda5f8743318b59c440928e51297": "Ymultichange(Yparameterchange,Ybodychange)",
    "4b130821995a3cfe20c71e38e0f63294085c0491": "Ymultichange(Yparameterchange,Ybodychange)",
    "45b42676f9333ed4fa05355ccb4e1f91a9556525": "Ybodychange",
    "85f0efb68f9d1d9ee3466e3939c4fc2f985ccf61": "Yintroduced"
  },
  "changeHistoryDetails": {
    "cdb2107066a2d8557270888c0a9a75f29a6853bf": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9879. Allow multiple leaf queues with the same name in CapacityScheduler. Contributed by Gergely Pollak.\n",
      "commitDate": "25/03/20 4:20 AM",
      "commitName": "cdb2107066a2d8557270888c0a9a75f29a6853bf",
      "commitAuthor": "Sunil G",
      "commitDateOld": "15/03/19 4:20 PM",
      "commitNameOld": "2064ca015d1584263aac0cc20c60b925a3aff612",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 375.5,
      "commitsBetweenForRepo": 2190,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,73 +1,73 @@\n   private TempQueuePerPartition cloneQueues(CSQueue curQueue,\n       Resource partitionResource, String partitionToLookAt) {\n     TempQueuePerPartition ret;\n     ReadLock readLock \u003d curQueue.getReadLock();\n     // Acquire a read lock from Parent/LeafQueue.\n     readLock.lock();\n     try {\n-      String queueName \u003d curQueue.getQueueName();\n+      String queuePath \u003d curQueue.getQueuePath();\n       QueueCapacities qc \u003d curQueue.getQueueCapacities();\n       float absCap \u003d qc.getAbsoluteCapacity(partitionToLookAt);\n       float absMaxCap \u003d qc.getAbsoluteMaximumCapacity(partitionToLookAt);\n       boolean preemptionDisabled \u003d curQueue.getPreemptionDisabled();\n \n       QueueResourceQuotas queueResourceQuotas \u003d curQueue\n           .getQueueResourceQuotas();\n       Resource effMinRes \u003d queueResourceQuotas\n           .getEffectiveMinResource(partitionToLookAt);\n       Resource effMaxRes \u003d queueResourceQuotas\n           .getEffectiveMaxResource(partitionToLookAt);\n \n       Resource current \u003d Resources\n           .clone(curQueue.getQueueResourceUsage().getUsed(partitionToLookAt));\n       Resource killable \u003d Resources.none();\n \n       Resource reserved \u003d Resources.clone(\n           curQueue.getQueueResourceUsage().getReserved(partitionToLookAt));\n-      if (null !\u003d preemptableQueues.get(queueName)) {\n-        killable \u003d Resources.clone(preemptableQueues.get(queueName)\n+      if (null !\u003d preemptableQueues.get(queuePath)) {\n+        killable \u003d Resources.clone(preemptableQueues.get(queuePath)\n             .getKillableResource(partitionToLookAt));\n       }\n \n       // when partition is a non-exclusive partition, the actual maxCapacity\n       // could more than specified maxCapacity\n       try {\n         if (!scheduler.getRMContext().getNodeLabelManager()\n             .isExclusiveNodeLabel(partitionToLookAt)) {\n           absMaxCap \u003d 1.0f;\n         }\n       } catch (IOException e) {\n         // This may cause by partition removed when running capacity monitor,\n         // just ignore the error, this will be corrected when doing next check.\n       }\n \n-      ret \u003d new TempQueuePerPartition(queueName, current, preemptionDisabled,\n+      ret \u003d new TempQueuePerPartition(queuePath, current, preemptionDisabled,\n           partitionToLookAt, killable, absCap, absMaxCap, partitionResource,\n           reserved, curQueue, effMinRes, effMaxRes);\n \n       if (curQueue instanceof ParentQueue) {\n         String configuredOrderingPolicy \u003d\n             ((ParentQueue) curQueue).getQueueOrderingPolicy().getConfigName();\n \n         // Recursively add children\n         for (CSQueue c : curQueue.getChildQueues()) {\n           TempQueuePerPartition subq \u003d cloneQueues(c, partitionResource,\n               partitionToLookAt);\n \n           // If we respect priority\n           if (StringUtils.equals(\n               CapacitySchedulerConfiguration.QUEUE_PRIORITY_UTILIZATION_ORDERING_POLICY,\n               configuredOrderingPolicy)) {\n             subq.relativePriority \u003d c.getPriority().getPriority();\n           }\n           ret.addChild(subq);\n           subq.parent \u003d ret;\n         }\n       }\n     } finally {\n       readLock.unlock();\n     }\n \n     addTempQueuePartition(ret);\n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private TempQueuePerPartition cloneQueues(CSQueue curQueue,\n      Resource partitionResource, String partitionToLookAt) {\n    TempQueuePerPartition ret;\n    ReadLock readLock \u003d curQueue.getReadLock();\n    // Acquire a read lock from Parent/LeafQueue.\n    readLock.lock();\n    try {\n      String queuePath \u003d curQueue.getQueuePath();\n      QueueCapacities qc \u003d curQueue.getQueueCapacities();\n      float absCap \u003d qc.getAbsoluteCapacity(partitionToLookAt);\n      float absMaxCap \u003d qc.getAbsoluteMaximumCapacity(partitionToLookAt);\n      boolean preemptionDisabled \u003d curQueue.getPreemptionDisabled();\n\n      QueueResourceQuotas queueResourceQuotas \u003d curQueue\n          .getQueueResourceQuotas();\n      Resource effMinRes \u003d queueResourceQuotas\n          .getEffectiveMinResource(partitionToLookAt);\n      Resource effMaxRes \u003d queueResourceQuotas\n          .getEffectiveMaxResource(partitionToLookAt);\n\n      Resource current \u003d Resources\n          .clone(curQueue.getQueueResourceUsage().getUsed(partitionToLookAt));\n      Resource killable \u003d Resources.none();\n\n      Resource reserved \u003d Resources.clone(\n          curQueue.getQueueResourceUsage().getReserved(partitionToLookAt));\n      if (null !\u003d preemptableQueues.get(queuePath)) {\n        killable \u003d Resources.clone(preemptableQueues.get(queuePath)\n            .getKillableResource(partitionToLookAt));\n      }\n\n      // when partition is a non-exclusive partition, the actual maxCapacity\n      // could more than specified maxCapacity\n      try {\n        if (!scheduler.getRMContext().getNodeLabelManager()\n            .isExclusiveNodeLabel(partitionToLookAt)) {\n          absMaxCap \u003d 1.0f;\n        }\n      } catch (IOException e) {\n        // This may cause by partition removed when running capacity monitor,\n        // just ignore the error, this will be corrected when doing next check.\n      }\n\n      ret \u003d new TempQueuePerPartition(queuePath, current, preemptionDisabled,\n          partitionToLookAt, killable, absCap, absMaxCap, partitionResource,\n          reserved, curQueue, effMinRes, effMaxRes);\n\n      if (curQueue instanceof ParentQueue) {\n        String configuredOrderingPolicy \u003d\n            ((ParentQueue) curQueue).getQueueOrderingPolicy().getConfigName();\n\n        // Recursively add children\n        for (CSQueue c : curQueue.getChildQueues()) {\n          TempQueuePerPartition subq \u003d cloneQueues(c, partitionResource,\n              partitionToLookAt);\n\n          // If we respect priority\n          if (StringUtils.equals(\n              CapacitySchedulerConfiguration.QUEUE_PRIORITY_UTILIZATION_ORDERING_POLICY,\n              configuredOrderingPolicy)) {\n            subq.relativePriority \u003d c.getPriority().getPriority();\n          }\n          ret.addChild(subq);\n          subq.parent \u003d ret;\n        }\n      }\n    } finally {\n      readLock.unlock();\n    }\n\n    addTempQueuePartition(ret);\n    return ret;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java",
      "extendedDetails": {}
    },
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9341.  Fixed enentrant lock usage in YARN project.\n            Contributed by Prabhu Joseph\n",
      "commitDate": "07/03/19 1:47 PM",
      "commitName": "39b4a37e02e929a698fcf9e32f1f71bb6b977635",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "04/03/19 9:10 PM",
      "commitNameOld": "e40e2d6ad5cbe782c3a067229270738b501ed27e",
      "commitAuthorOld": "Prabhu Joseph",
      "daysBetweenCommits": 2.69,
      "commitsBetweenForRepo": 39,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,74 +1,73 @@\n   private TempQueuePerPartition cloneQueues(CSQueue curQueue,\n       Resource partitionResource, String partitionToLookAt) {\n     TempQueuePerPartition ret;\n     ReadLock readLock \u003d curQueue.getReadLock();\n+    // Acquire a read lock from Parent/LeafQueue.\n+    readLock.lock();\n     try {\n-      // Acquire a read lock from Parent/LeafQueue.\n-      readLock.lock();\n-\n       String queueName \u003d curQueue.getQueueName();\n       QueueCapacities qc \u003d curQueue.getQueueCapacities();\n       float absCap \u003d qc.getAbsoluteCapacity(partitionToLookAt);\n       float absMaxCap \u003d qc.getAbsoluteMaximumCapacity(partitionToLookAt);\n       boolean preemptionDisabled \u003d curQueue.getPreemptionDisabled();\n \n       QueueResourceQuotas queueResourceQuotas \u003d curQueue\n           .getQueueResourceQuotas();\n       Resource effMinRes \u003d queueResourceQuotas\n           .getEffectiveMinResource(partitionToLookAt);\n       Resource effMaxRes \u003d queueResourceQuotas\n           .getEffectiveMaxResource(partitionToLookAt);\n \n       Resource current \u003d Resources\n           .clone(curQueue.getQueueResourceUsage().getUsed(partitionToLookAt));\n       Resource killable \u003d Resources.none();\n \n       Resource reserved \u003d Resources.clone(\n           curQueue.getQueueResourceUsage().getReserved(partitionToLookAt));\n       if (null !\u003d preemptableQueues.get(queueName)) {\n         killable \u003d Resources.clone(preemptableQueues.get(queueName)\n             .getKillableResource(partitionToLookAt));\n       }\n \n       // when partition is a non-exclusive partition, the actual maxCapacity\n       // could more than specified maxCapacity\n       try {\n         if (!scheduler.getRMContext().getNodeLabelManager()\n             .isExclusiveNodeLabel(partitionToLookAt)) {\n           absMaxCap \u003d 1.0f;\n         }\n       } catch (IOException e) {\n         // This may cause by partition removed when running capacity monitor,\n         // just ignore the error, this will be corrected when doing next check.\n       }\n \n       ret \u003d new TempQueuePerPartition(queueName, current, preemptionDisabled,\n           partitionToLookAt, killable, absCap, absMaxCap, partitionResource,\n           reserved, curQueue, effMinRes, effMaxRes);\n \n       if (curQueue instanceof ParentQueue) {\n         String configuredOrderingPolicy \u003d\n             ((ParentQueue) curQueue).getQueueOrderingPolicy().getConfigName();\n \n         // Recursively add children\n         for (CSQueue c : curQueue.getChildQueues()) {\n           TempQueuePerPartition subq \u003d cloneQueues(c, partitionResource,\n               partitionToLookAt);\n \n           // If we respect priority\n           if (StringUtils.equals(\n               CapacitySchedulerConfiguration.QUEUE_PRIORITY_UTILIZATION_ORDERING_POLICY,\n               configuredOrderingPolicy)) {\n             subq.relativePriority \u003d c.getPriority().getPriority();\n           }\n           ret.addChild(subq);\n           subq.parent \u003d ret;\n         }\n       }\n     } finally {\n       readLock.unlock();\n     }\n \n     addTempQueuePartition(ret);\n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private TempQueuePerPartition cloneQueues(CSQueue curQueue,\n      Resource partitionResource, String partitionToLookAt) {\n    TempQueuePerPartition ret;\n    ReadLock readLock \u003d curQueue.getReadLock();\n    // Acquire a read lock from Parent/LeafQueue.\n    readLock.lock();\n    try {\n      String queueName \u003d curQueue.getQueueName();\n      QueueCapacities qc \u003d curQueue.getQueueCapacities();\n      float absCap \u003d qc.getAbsoluteCapacity(partitionToLookAt);\n      float absMaxCap \u003d qc.getAbsoluteMaximumCapacity(partitionToLookAt);\n      boolean preemptionDisabled \u003d curQueue.getPreemptionDisabled();\n\n      QueueResourceQuotas queueResourceQuotas \u003d curQueue\n          .getQueueResourceQuotas();\n      Resource effMinRes \u003d queueResourceQuotas\n          .getEffectiveMinResource(partitionToLookAt);\n      Resource effMaxRes \u003d queueResourceQuotas\n          .getEffectiveMaxResource(partitionToLookAt);\n\n      Resource current \u003d Resources\n          .clone(curQueue.getQueueResourceUsage().getUsed(partitionToLookAt));\n      Resource killable \u003d Resources.none();\n\n      Resource reserved \u003d Resources.clone(\n          curQueue.getQueueResourceUsage().getReserved(partitionToLookAt));\n      if (null !\u003d preemptableQueues.get(queueName)) {\n        killable \u003d Resources.clone(preemptableQueues.get(queueName)\n            .getKillableResource(partitionToLookAt));\n      }\n\n      // when partition is a non-exclusive partition, the actual maxCapacity\n      // could more than specified maxCapacity\n      try {\n        if (!scheduler.getRMContext().getNodeLabelManager()\n            .isExclusiveNodeLabel(partitionToLookAt)) {\n          absMaxCap \u003d 1.0f;\n        }\n      } catch (IOException e) {\n        // This may cause by partition removed when running capacity monitor,\n        // just ignore the error, this will be corrected when doing next check.\n      }\n\n      ret \u003d new TempQueuePerPartition(queueName, current, preemptionDisabled,\n          partitionToLookAt, killable, absCap, absMaxCap, partitionResource,\n          reserved, curQueue, effMinRes, effMaxRes);\n\n      if (curQueue instanceof ParentQueue) {\n        String configuredOrderingPolicy \u003d\n            ((ParentQueue) curQueue).getQueueOrderingPolicy().getConfigName();\n\n        // Recursively add children\n        for (CSQueue c : curQueue.getChildQueues()) {\n          TempQueuePerPartition subq \u003d cloneQueues(c, partitionResource,\n              partitionToLookAt);\n\n          // If we respect priority\n          if (StringUtils.equals(\n              CapacitySchedulerConfiguration.QUEUE_PRIORITY_UTILIZATION_ORDERING_POLICY,\n              configuredOrderingPolicy)) {\n            subq.relativePriority \u003d c.getPriority().getPriority();\n          }\n          ret.addChild(subq);\n          subq.parent \u003d ret;\n        }\n      }\n    } finally {\n      readLock.unlock();\n    }\n\n    addTempQueuePartition(ret);\n    return ret;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java",
      "extendedDetails": {}
    },
    "5e798b1a0ddceeaf54703b94052501867156e979": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6471. Support to add min/max resource configuration for a queue. (Sunil G via wangda)\n\nChange-Id: I9213f5297a6841fab5c573e85ee4c4e5f4a0b7ff\n",
      "commitDate": "07/12/17 6:56 PM",
      "commitName": "5e798b1a0ddceeaf54703b94052501867156e979",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "02/11/17 10:37 AM",
      "commitNameOld": "e6ec02001fc4eed9eb51c8653d8f931135e49eda",
      "commitAuthorOld": "Eric Payne",
      "daysBetweenCommits": 35.39,
      "commitsBetweenForRepo": 281,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,67 +1,74 @@\n   private TempQueuePerPartition cloneQueues(CSQueue curQueue,\n       Resource partitionResource, String partitionToLookAt) {\n     TempQueuePerPartition ret;\n     ReadLock readLock \u003d curQueue.getReadLock();\n     try {\n       // Acquire a read lock from Parent/LeafQueue.\n       readLock.lock();\n \n       String queueName \u003d curQueue.getQueueName();\n       QueueCapacities qc \u003d curQueue.getQueueCapacities();\n       float absCap \u003d qc.getAbsoluteCapacity(partitionToLookAt);\n       float absMaxCap \u003d qc.getAbsoluteMaximumCapacity(partitionToLookAt);\n       boolean preemptionDisabled \u003d curQueue.getPreemptionDisabled();\n \n+      QueueResourceQuotas queueResourceQuotas \u003d curQueue\n+          .getQueueResourceQuotas();\n+      Resource effMinRes \u003d queueResourceQuotas\n+          .getEffectiveMinResource(partitionToLookAt);\n+      Resource effMaxRes \u003d queueResourceQuotas\n+          .getEffectiveMaxResource(partitionToLookAt);\n+\n       Resource current \u003d Resources\n           .clone(curQueue.getQueueResourceUsage().getUsed(partitionToLookAt));\n       Resource killable \u003d Resources.none();\n \n       Resource reserved \u003d Resources.clone(\n           curQueue.getQueueResourceUsage().getReserved(partitionToLookAt));\n       if (null !\u003d preemptableQueues.get(queueName)) {\n         killable \u003d Resources.clone(preemptableQueues.get(queueName)\n             .getKillableResource(partitionToLookAt));\n       }\n \n       // when partition is a non-exclusive partition, the actual maxCapacity\n       // could more than specified maxCapacity\n       try {\n         if (!scheduler.getRMContext().getNodeLabelManager()\n             .isExclusiveNodeLabel(partitionToLookAt)) {\n           absMaxCap \u003d 1.0f;\n         }\n       } catch (IOException e) {\n         // This may cause by partition removed when running capacity monitor,\n         // just ignore the error, this will be corrected when doing next check.\n       }\n \n       ret \u003d new TempQueuePerPartition(queueName, current, preemptionDisabled,\n           partitionToLookAt, killable, absCap, absMaxCap, partitionResource,\n-          reserved, curQueue);\n+          reserved, curQueue, effMinRes, effMaxRes);\n \n       if (curQueue instanceof ParentQueue) {\n         String configuredOrderingPolicy \u003d\n             ((ParentQueue) curQueue).getQueueOrderingPolicy().getConfigName();\n \n         // Recursively add children\n         for (CSQueue c : curQueue.getChildQueues()) {\n           TempQueuePerPartition subq \u003d cloneQueues(c, partitionResource,\n               partitionToLookAt);\n \n           // If we respect priority\n           if (StringUtils.equals(\n               CapacitySchedulerConfiguration.QUEUE_PRIORITY_UTILIZATION_ORDERING_POLICY,\n               configuredOrderingPolicy)) {\n             subq.relativePriority \u003d c.getPriority().getPriority();\n           }\n           ret.addChild(subq);\n           subq.parent \u003d ret;\n         }\n       }\n     } finally {\n       readLock.unlock();\n     }\n \n     addTempQueuePartition(ret);\n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private TempQueuePerPartition cloneQueues(CSQueue curQueue,\n      Resource partitionResource, String partitionToLookAt) {\n    TempQueuePerPartition ret;\n    ReadLock readLock \u003d curQueue.getReadLock();\n    try {\n      // Acquire a read lock from Parent/LeafQueue.\n      readLock.lock();\n\n      String queueName \u003d curQueue.getQueueName();\n      QueueCapacities qc \u003d curQueue.getQueueCapacities();\n      float absCap \u003d qc.getAbsoluteCapacity(partitionToLookAt);\n      float absMaxCap \u003d qc.getAbsoluteMaximumCapacity(partitionToLookAt);\n      boolean preemptionDisabled \u003d curQueue.getPreemptionDisabled();\n\n      QueueResourceQuotas queueResourceQuotas \u003d curQueue\n          .getQueueResourceQuotas();\n      Resource effMinRes \u003d queueResourceQuotas\n          .getEffectiveMinResource(partitionToLookAt);\n      Resource effMaxRes \u003d queueResourceQuotas\n          .getEffectiveMaxResource(partitionToLookAt);\n\n      Resource current \u003d Resources\n          .clone(curQueue.getQueueResourceUsage().getUsed(partitionToLookAt));\n      Resource killable \u003d Resources.none();\n\n      Resource reserved \u003d Resources.clone(\n          curQueue.getQueueResourceUsage().getReserved(partitionToLookAt));\n      if (null !\u003d preemptableQueues.get(queueName)) {\n        killable \u003d Resources.clone(preemptableQueues.get(queueName)\n            .getKillableResource(partitionToLookAt));\n      }\n\n      // when partition is a non-exclusive partition, the actual maxCapacity\n      // could more than specified maxCapacity\n      try {\n        if (!scheduler.getRMContext().getNodeLabelManager()\n            .isExclusiveNodeLabel(partitionToLookAt)) {\n          absMaxCap \u003d 1.0f;\n        }\n      } catch (IOException e) {\n        // This may cause by partition removed when running capacity monitor,\n        // just ignore the error, this will be corrected when doing next check.\n      }\n\n      ret \u003d new TempQueuePerPartition(queueName, current, preemptionDisabled,\n          partitionToLookAt, killable, absCap, absMaxCap, partitionResource,\n          reserved, curQueue, effMinRes, effMaxRes);\n\n      if (curQueue instanceof ParentQueue) {\n        String configuredOrderingPolicy \u003d\n            ((ParentQueue) curQueue).getQueueOrderingPolicy().getConfigName();\n\n        // Recursively add children\n        for (CSQueue c : curQueue.getChildQueues()) {\n          TempQueuePerPartition subq \u003d cloneQueues(c, partitionResource,\n              partitionToLookAt);\n\n          // If we respect priority\n          if (StringUtils.equals(\n              CapacitySchedulerConfiguration.QUEUE_PRIORITY_UTILIZATION_ORDERING_POLICY,\n              configuredOrderingPolicy)) {\n            subq.relativePriority \u003d c.getPriority().getPriority();\n          }\n          ret.addChild(subq);\n          subq.parent \u003d ret;\n        }\n      }\n    } finally {\n      readLock.unlock();\n    }\n\n    addTempQueuePartition(ret);\n    return ret;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java",
      "extendedDetails": {}
    },
    "ce832059db077fa95922198b066a737ed4f609fe": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5864. Capacity Scheduler - Queue Priorities. (wangda)\n",
      "commitDate": "23/01/17 10:52 AM",
      "commitName": "ce832059db077fa95922198b066a737ed4f609fe",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "11/11/16 3:16 PM",
      "commitNameOld": "fad9609d13e76e9e3a4e01c96f698bb60b03807e",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 72.82,
      "commitsBetweenForRepo": 374,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,56 +1,67 @@\n   private TempQueuePerPartition cloneQueues(CSQueue curQueue,\n       Resource partitionResource, String partitionToLookAt) {\n     TempQueuePerPartition ret;\n     ReadLock readLock \u003d curQueue.getReadLock();\n     try {\n       // Acquire a read lock from Parent/LeafQueue.\n       readLock.lock();\n \n       String queueName \u003d curQueue.getQueueName();\n       QueueCapacities qc \u003d curQueue.getQueueCapacities();\n       float absCap \u003d qc.getAbsoluteCapacity(partitionToLookAt);\n       float absMaxCap \u003d qc.getAbsoluteMaximumCapacity(partitionToLookAt);\n       boolean preemptionDisabled \u003d curQueue.getPreemptionDisabled();\n \n       Resource current \u003d Resources\n           .clone(curQueue.getQueueResourceUsage().getUsed(partitionToLookAt));\n       Resource killable \u003d Resources.none();\n \n       Resource reserved \u003d Resources.clone(\n           curQueue.getQueueResourceUsage().getReserved(partitionToLookAt));\n       if (null !\u003d preemptableQueues.get(queueName)) {\n         killable \u003d Resources.clone(preemptableQueues.get(queueName)\n             .getKillableResource(partitionToLookAt));\n       }\n \n       // when partition is a non-exclusive partition, the actual maxCapacity\n       // could more than specified maxCapacity\n       try {\n         if (!scheduler.getRMContext().getNodeLabelManager()\n             .isExclusiveNodeLabel(partitionToLookAt)) {\n           absMaxCap \u003d 1.0f;\n         }\n       } catch (IOException e) {\n         // This may cause by partition removed when running capacity monitor,\n         // just ignore the error, this will be corrected when doing next check.\n       }\n \n       ret \u003d new TempQueuePerPartition(queueName, current, preemptionDisabled,\n           partitionToLookAt, killable, absCap, absMaxCap, partitionResource,\n           reserved, curQueue);\n \n       if (curQueue instanceof ParentQueue) {\n+        String configuredOrderingPolicy \u003d\n+            ((ParentQueue) curQueue).getQueueOrderingPolicy().getConfigName();\n+\n         // Recursively add children\n         for (CSQueue c : curQueue.getChildQueues()) {\n           TempQueuePerPartition subq \u003d cloneQueues(c, partitionResource,\n               partitionToLookAt);\n+\n+          // If we respect priority\n+          if (StringUtils.equals(\n+              CapacitySchedulerConfiguration.QUEUE_PRIORITY_UTILIZATION_ORDERING_POLICY,\n+              configuredOrderingPolicy)) {\n+            subq.relativePriority \u003d c.getPriority().getPriority();\n+          }\n           ret.addChild(subq);\n+          subq.parent \u003d ret;\n         }\n       }\n     } finally {\n       readLock.unlock();\n     }\n \n     addTempQueuePartition(ret);\n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private TempQueuePerPartition cloneQueues(CSQueue curQueue,\n      Resource partitionResource, String partitionToLookAt) {\n    TempQueuePerPartition ret;\n    ReadLock readLock \u003d curQueue.getReadLock();\n    try {\n      // Acquire a read lock from Parent/LeafQueue.\n      readLock.lock();\n\n      String queueName \u003d curQueue.getQueueName();\n      QueueCapacities qc \u003d curQueue.getQueueCapacities();\n      float absCap \u003d qc.getAbsoluteCapacity(partitionToLookAt);\n      float absMaxCap \u003d qc.getAbsoluteMaximumCapacity(partitionToLookAt);\n      boolean preemptionDisabled \u003d curQueue.getPreemptionDisabled();\n\n      Resource current \u003d Resources\n          .clone(curQueue.getQueueResourceUsage().getUsed(partitionToLookAt));\n      Resource killable \u003d Resources.none();\n\n      Resource reserved \u003d Resources.clone(\n          curQueue.getQueueResourceUsage().getReserved(partitionToLookAt));\n      if (null !\u003d preemptableQueues.get(queueName)) {\n        killable \u003d Resources.clone(preemptableQueues.get(queueName)\n            .getKillableResource(partitionToLookAt));\n      }\n\n      // when partition is a non-exclusive partition, the actual maxCapacity\n      // could more than specified maxCapacity\n      try {\n        if (!scheduler.getRMContext().getNodeLabelManager()\n            .isExclusiveNodeLabel(partitionToLookAt)) {\n          absMaxCap \u003d 1.0f;\n        }\n      } catch (IOException e) {\n        // This may cause by partition removed when running capacity monitor,\n        // just ignore the error, this will be corrected when doing next check.\n      }\n\n      ret \u003d new TempQueuePerPartition(queueName, current, preemptionDisabled,\n          partitionToLookAt, killable, absCap, absMaxCap, partitionResource,\n          reserved, curQueue);\n\n      if (curQueue instanceof ParentQueue) {\n        String configuredOrderingPolicy \u003d\n            ((ParentQueue) curQueue).getQueueOrderingPolicy().getConfigName();\n\n        // Recursively add children\n        for (CSQueue c : curQueue.getChildQueues()) {\n          TempQueuePerPartition subq \u003d cloneQueues(c, partitionResource,\n              partitionToLookAt);\n\n          // If we respect priority\n          if (StringUtils.equals(\n              CapacitySchedulerConfiguration.QUEUE_PRIORITY_UTILIZATION_ORDERING_POLICY,\n              configuredOrderingPolicy)) {\n            subq.relativePriority \u003d c.getPriority().getPriority();\n          }\n          ret.addChild(subq);\n          subq.parent \u003d ret;\n        }\n      }\n    } finally {\n      readLock.unlock();\n    }\n\n    addTempQueuePartition(ret);\n    return ret;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java",
      "extendedDetails": {}
    },
    "fad9609d13e76e9e3a4e01c96f698bb60b03807e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5825. ProportionalPreemptionalPolicy should use readLock over LeafQueue instead of synchronized block. Contributed by Sunil G\n",
      "commitDate": "11/11/16 3:16 PM",
      "commitName": "fad9609d13e76e9e3a4e01c96f698bb60b03807e",
      "commitAuthor": "Jian He",
      "commitDateOld": "31/10/16 3:18 PM",
      "commitNameOld": "90dd3a8148468ac37a3f2173ad8d45e38bfcb0c9",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 11.04,
      "commitsBetweenForRepo": 127,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,49 +1,56 @@\n   private TempQueuePerPartition cloneQueues(CSQueue curQueue,\n       Resource partitionResource, String partitionToLookAt) {\n     TempQueuePerPartition ret;\n-    synchronized (curQueue) {\n+    ReadLock readLock \u003d curQueue.getReadLock();\n+    try {\n+      // Acquire a read lock from Parent/LeafQueue.\n+      readLock.lock();\n+\n       String queueName \u003d curQueue.getQueueName();\n       QueueCapacities qc \u003d curQueue.getQueueCapacities();\n       float absCap \u003d qc.getAbsoluteCapacity(partitionToLookAt);\n       float absMaxCap \u003d qc.getAbsoluteMaximumCapacity(partitionToLookAt);\n       boolean preemptionDisabled \u003d curQueue.getPreemptionDisabled();\n \n-      Resource current \u003d Resources.clone(\n-          curQueue.getQueueResourceUsage().getUsed(partitionToLookAt));\n+      Resource current \u003d Resources\n+          .clone(curQueue.getQueueResourceUsage().getUsed(partitionToLookAt));\n       Resource killable \u003d Resources.none();\n \n       Resource reserved \u003d Resources.clone(\n           curQueue.getQueueResourceUsage().getReserved(partitionToLookAt));\n       if (null !\u003d preemptableQueues.get(queueName)) {\n         killable \u003d Resources.clone(preemptableQueues.get(queueName)\n             .getKillableResource(partitionToLookAt));\n       }\n \n       // when partition is a non-exclusive partition, the actual maxCapacity\n       // could more than specified maxCapacity\n       try {\n         if (!scheduler.getRMContext().getNodeLabelManager()\n             .isExclusiveNodeLabel(partitionToLookAt)) {\n           absMaxCap \u003d 1.0f;\n         }\n       } catch (IOException e) {\n         // This may cause by partition removed when running capacity monitor,\n         // just ignore the error, this will be corrected when doing next check.\n       }\n \n       ret \u003d new TempQueuePerPartition(queueName, current, preemptionDisabled,\n           partitionToLookAt, killable, absCap, absMaxCap, partitionResource,\n           reserved, curQueue);\n \n       if (curQueue instanceof ParentQueue) {\n         // Recursively add children\n         for (CSQueue c : curQueue.getChildQueues()) {\n           TempQueuePerPartition subq \u003d cloneQueues(c, partitionResource,\n               partitionToLookAt);\n           ret.addChild(subq);\n         }\n       }\n+    } finally {\n+      readLock.unlock();\n     }\n+\n     addTempQueuePartition(ret);\n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private TempQueuePerPartition cloneQueues(CSQueue curQueue,\n      Resource partitionResource, String partitionToLookAt) {\n    TempQueuePerPartition ret;\n    ReadLock readLock \u003d curQueue.getReadLock();\n    try {\n      // Acquire a read lock from Parent/LeafQueue.\n      readLock.lock();\n\n      String queueName \u003d curQueue.getQueueName();\n      QueueCapacities qc \u003d curQueue.getQueueCapacities();\n      float absCap \u003d qc.getAbsoluteCapacity(partitionToLookAt);\n      float absMaxCap \u003d qc.getAbsoluteMaximumCapacity(partitionToLookAt);\n      boolean preemptionDisabled \u003d curQueue.getPreemptionDisabled();\n\n      Resource current \u003d Resources\n          .clone(curQueue.getQueueResourceUsage().getUsed(partitionToLookAt));\n      Resource killable \u003d Resources.none();\n\n      Resource reserved \u003d Resources.clone(\n          curQueue.getQueueResourceUsage().getReserved(partitionToLookAt));\n      if (null !\u003d preemptableQueues.get(queueName)) {\n        killable \u003d Resources.clone(preemptableQueues.get(queueName)\n            .getKillableResource(partitionToLookAt));\n      }\n\n      // when partition is a non-exclusive partition, the actual maxCapacity\n      // could more than specified maxCapacity\n      try {\n        if (!scheduler.getRMContext().getNodeLabelManager()\n            .isExclusiveNodeLabel(partitionToLookAt)) {\n          absMaxCap \u003d 1.0f;\n        }\n      } catch (IOException e) {\n        // This may cause by partition removed when running capacity monitor,\n        // just ignore the error, this will be corrected when doing next check.\n      }\n\n      ret \u003d new TempQueuePerPartition(queueName, current, preemptionDisabled,\n          partitionToLookAt, killable, absCap, absMaxCap, partitionResource,\n          reserved, curQueue);\n\n      if (curQueue instanceof ParentQueue) {\n        // Recursively add children\n        for (CSQueue c : curQueue.getChildQueues()) {\n          TempQueuePerPartition subq \u003d cloneQueues(c, partitionResource,\n              partitionToLookAt);\n          ret.addChild(subq);\n        }\n      }\n    } finally {\n      readLock.unlock();\n    }\n\n    addTempQueuePartition(ret);\n    return ret;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java",
      "extendedDetails": {}
    },
    "bb62e0592566b2fcae7136b30972aad2d3ac55b0": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4390. Do surgical preemption based on reserved container in CapacityScheduler. Contributed by Wangda Tan\n",
      "commitDate": "05/05/16 12:56 PM",
      "commitName": "bb62e0592566b2fcae7136b30972aad2d3ac55b0",
      "commitAuthor": "Jian He",
      "commitDateOld": "22/04/16 11:40 AM",
      "commitNameOld": "7cb3a3da96e59fc9b6528644dae5fb0ac1e44eac",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 13.05,
      "commitsBetweenForRepo": 72,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,77 +1,49 @@\n   private TempQueuePerPartition cloneQueues(CSQueue curQueue,\n       Resource partitionResource, String partitionToLookAt) {\n     TempQueuePerPartition ret;\n     synchronized (curQueue) {\n       String queueName \u003d curQueue.getQueueName();\n       QueueCapacities qc \u003d curQueue.getQueueCapacities();\n       float absCap \u003d qc.getAbsoluteCapacity(partitionToLookAt);\n       float absMaxCap \u003d qc.getAbsoluteMaximumCapacity(partitionToLookAt);\n       boolean preemptionDisabled \u003d curQueue.getPreemptionDisabled();\n \n-      Resource current \u003d curQueue.getQueueResourceUsage().getUsed(\n-          partitionToLookAt);\n-      Resource guaranteed \u003d Resources.multiply(partitionResource, absCap);\n-      Resource maxCapacity \u003d Resources.multiply(partitionResource, absMaxCap);\n+      Resource current \u003d Resources.clone(\n+          curQueue.getQueueResourceUsage().getUsed(partitionToLookAt));\n       Resource killable \u003d Resources.none();\n+\n+      Resource reserved \u003d Resources.clone(\n+          curQueue.getQueueResourceUsage().getReserved(partitionToLookAt));\n       if (null !\u003d preemptableQueues.get(queueName)) {\n-         killable \u003d preemptableQueues.get(queueName)\n-            .getKillableResource(partitionToLookAt);\n+        killable \u003d Resources.clone(preemptableQueues.get(queueName)\n+            .getKillableResource(partitionToLookAt));\n       }\n \n       // when partition is a non-exclusive partition, the actual maxCapacity\n       // could more than specified maxCapacity\n       try {\n         if (!scheduler.getRMContext().getNodeLabelManager()\n             .isExclusiveNodeLabel(partitionToLookAt)) {\n-          maxCapacity \u003d\n-              Resources.max(rc, partitionResource, maxCapacity, current);\n+          absMaxCap \u003d 1.0f;\n         }\n       } catch (IOException e) {\n         // This may cause by partition removed when running capacity monitor,\n         // just ignore the error, this will be corrected when doing next check.\n       }\n \n-      Resource extra \u003d Resource.newInstance(0, 0);\n-      if (Resources.greaterThan(rc, partitionResource, current, guaranteed)) {\n-        extra \u003d Resources.subtract(current, guaranteed);\n-      }\n-      if (curQueue instanceof LeafQueue) {\n-        LeafQueue l \u003d (LeafQueue) curQueue;\n-        Resource pending \u003d\n-              l.getTotalPendingResourcesConsideringUserLimit(\n-                  partitionResource, partitionToLookAt);\n-        ret \u003d new TempQueuePerPartition(queueName, current, pending, guaranteed,\n-            maxCapacity, preemptionDisabled, partitionToLookAt, killable);\n-        if (preemptionDisabled) {\n-          ret.untouchableExtra \u003d extra;\n-        } else {\n-          ret.preemptableExtra \u003d extra;\n-        }\n-        ret.setLeafQueue(l);\n-      } else {\n-        Resource pending \u003d Resource.newInstance(0, 0);\n-        ret \u003d\n-            new TempQueuePerPartition(curQueue.getQueueName(), current, pending,\n-                guaranteed, maxCapacity, false, partitionToLookAt, killable);\n-        Resource childrensPreemptable \u003d Resource.newInstance(0, 0);\n+      ret \u003d new TempQueuePerPartition(queueName, current, preemptionDisabled,\n+          partitionToLookAt, killable, absCap, absMaxCap, partitionResource,\n+          reserved, curQueue);\n+\n+      if (curQueue instanceof ParentQueue) {\n+        // Recursively add children\n         for (CSQueue c : curQueue.getChildQueues()) {\n-          TempQueuePerPartition subq \u003d\n-              cloneQueues(c, partitionResource, partitionToLookAt);\n-          Resources.addTo(childrensPreemptable, subq.preemptableExtra);\n+          TempQueuePerPartition subq \u003d cloneQueues(c, partitionResource,\n+              partitionToLookAt);\n           ret.addChild(subq);\n         }\n-        // untouchableExtra \u003d max(extra - childrenPreemptable, 0)\n-        if (Resources.greaterThanOrEqual(\n-              rc, partitionResource, childrensPreemptable, extra)) {\n-          ret.untouchableExtra \u003d Resource.newInstance(0, 0);\n-        } else {\n-          ret.untouchableExtra \u003d\n-                Resources.subtract(extra, childrensPreemptable);\n-        }\n-        ret.preemptableExtra \u003d Resources.min(\n-            rc, partitionResource, childrensPreemptable, extra);\n       }\n     }\n     addTempQueuePartition(ret);\n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private TempQueuePerPartition cloneQueues(CSQueue curQueue,\n      Resource partitionResource, String partitionToLookAt) {\n    TempQueuePerPartition ret;\n    synchronized (curQueue) {\n      String queueName \u003d curQueue.getQueueName();\n      QueueCapacities qc \u003d curQueue.getQueueCapacities();\n      float absCap \u003d qc.getAbsoluteCapacity(partitionToLookAt);\n      float absMaxCap \u003d qc.getAbsoluteMaximumCapacity(partitionToLookAt);\n      boolean preemptionDisabled \u003d curQueue.getPreemptionDisabled();\n\n      Resource current \u003d Resources.clone(\n          curQueue.getQueueResourceUsage().getUsed(partitionToLookAt));\n      Resource killable \u003d Resources.none();\n\n      Resource reserved \u003d Resources.clone(\n          curQueue.getQueueResourceUsage().getReserved(partitionToLookAt));\n      if (null !\u003d preemptableQueues.get(queueName)) {\n        killable \u003d Resources.clone(preemptableQueues.get(queueName)\n            .getKillableResource(partitionToLookAt));\n      }\n\n      // when partition is a non-exclusive partition, the actual maxCapacity\n      // could more than specified maxCapacity\n      try {\n        if (!scheduler.getRMContext().getNodeLabelManager()\n            .isExclusiveNodeLabel(partitionToLookAt)) {\n          absMaxCap \u003d 1.0f;\n        }\n      } catch (IOException e) {\n        // This may cause by partition removed when running capacity monitor,\n        // just ignore the error, this will be corrected when doing next check.\n      }\n\n      ret \u003d new TempQueuePerPartition(queueName, current, preemptionDisabled,\n          partitionToLookAt, killable, absCap, absMaxCap, partitionResource,\n          reserved, curQueue);\n\n      if (curQueue instanceof ParentQueue) {\n        // Recursively add children\n        for (CSQueue c : curQueue.getChildQueues()) {\n          TempQueuePerPartition subq \u003d cloneQueues(c, partitionResource,\n              partitionToLookAt);\n          ret.addChild(subq);\n        }\n      }\n    }\n    addTempQueuePartition(ret);\n    return ret;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java",
      "extendedDetails": {}
    },
    "60e4116bf1d00afed91010e57357fe54057e4e39": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4822. Refactor existing Preemption Policy of CS for easier adding new approach to select preemption candidates. Contributed by Wangda Tan\n",
      "commitDate": "30/03/16 12:43 PM",
      "commitName": "60e4116bf1d00afed91010e57357fe54057e4e39",
      "commitAuthor": "Jian He",
      "commitDateOld": "16/03/16 5:02 PM",
      "commitNameOld": "ae14e5d07f1b6702a5160637438028bb03d9387e",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 13.82,
      "commitsBetweenForRepo": 69,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,77 +1,77 @@\n   private TempQueuePerPartition cloneQueues(CSQueue curQueue,\n       Resource partitionResource, String partitionToLookAt) {\n     TempQueuePerPartition ret;\n     synchronized (curQueue) {\n       String queueName \u003d curQueue.getQueueName();\n       QueueCapacities qc \u003d curQueue.getQueueCapacities();\n       float absCap \u003d qc.getAbsoluteCapacity(partitionToLookAt);\n       float absMaxCap \u003d qc.getAbsoluteMaximumCapacity(partitionToLookAt);\n       boolean preemptionDisabled \u003d curQueue.getPreemptionDisabled();\n \n       Resource current \u003d curQueue.getQueueResourceUsage().getUsed(\n           partitionToLookAt);\n       Resource guaranteed \u003d Resources.multiply(partitionResource, absCap);\n       Resource maxCapacity \u003d Resources.multiply(partitionResource, absMaxCap);\n       Resource killable \u003d Resources.none();\n-      if (null !\u003d preemptableEntities.get(queueName)) {\n-         killable \u003d preemptableEntities.get(queueName)\n+      if (null !\u003d preemptableQueues.get(queueName)) {\n+         killable \u003d preemptableQueues.get(queueName)\n             .getKillableResource(partitionToLookAt);\n       }\n \n       // when partition is a non-exclusive partition, the actual maxCapacity\n       // could more than specified maxCapacity\n       try {\n         if (!scheduler.getRMContext().getNodeLabelManager()\n             .isExclusiveNodeLabel(partitionToLookAt)) {\n           maxCapacity \u003d\n               Resources.max(rc, partitionResource, maxCapacity, current);\n         }\n       } catch (IOException e) {\n         // This may cause by partition removed when running capacity monitor,\n         // just ignore the error, this will be corrected when doing next check.\n       }\n \n       Resource extra \u003d Resource.newInstance(0, 0);\n       if (Resources.greaterThan(rc, partitionResource, current, guaranteed)) {\n         extra \u003d Resources.subtract(current, guaranteed);\n       }\n       if (curQueue instanceof LeafQueue) {\n         LeafQueue l \u003d (LeafQueue) curQueue;\n         Resource pending \u003d\n               l.getTotalPendingResourcesConsideringUserLimit(\n                   partitionResource, partitionToLookAt);\n         ret \u003d new TempQueuePerPartition(queueName, current, pending, guaranteed,\n             maxCapacity, preemptionDisabled, partitionToLookAt, killable);\n         if (preemptionDisabled) {\n           ret.untouchableExtra \u003d extra;\n         } else {\n           ret.preemptableExtra \u003d extra;\n         }\n         ret.setLeafQueue(l);\n       } else {\n         Resource pending \u003d Resource.newInstance(0, 0);\n         ret \u003d\n             new TempQueuePerPartition(curQueue.getQueueName(), current, pending,\n                 guaranteed, maxCapacity, false, partitionToLookAt, killable);\n         Resource childrensPreemptable \u003d Resource.newInstance(0, 0);\n         for (CSQueue c : curQueue.getChildQueues()) {\n           TempQueuePerPartition subq \u003d\n               cloneQueues(c, partitionResource, partitionToLookAt);\n           Resources.addTo(childrensPreemptable, subq.preemptableExtra);\n           ret.addChild(subq);\n         }\n         // untouchableExtra \u003d max(extra - childrenPreemptable, 0)\n         if (Resources.greaterThanOrEqual(\n               rc, partitionResource, childrensPreemptable, extra)) {\n           ret.untouchableExtra \u003d Resource.newInstance(0, 0);\n         } else {\n           ret.untouchableExtra \u003d\n                 Resources.subtract(extra, childrensPreemptable);\n         }\n         ret.preemptableExtra \u003d Resources.min(\n             rc, partitionResource, childrensPreemptable, extra);\n       }\n     }\n     addTempQueuePartition(ret);\n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private TempQueuePerPartition cloneQueues(CSQueue curQueue,\n      Resource partitionResource, String partitionToLookAt) {\n    TempQueuePerPartition ret;\n    synchronized (curQueue) {\n      String queueName \u003d curQueue.getQueueName();\n      QueueCapacities qc \u003d curQueue.getQueueCapacities();\n      float absCap \u003d qc.getAbsoluteCapacity(partitionToLookAt);\n      float absMaxCap \u003d qc.getAbsoluteMaximumCapacity(partitionToLookAt);\n      boolean preemptionDisabled \u003d curQueue.getPreemptionDisabled();\n\n      Resource current \u003d curQueue.getQueueResourceUsage().getUsed(\n          partitionToLookAt);\n      Resource guaranteed \u003d Resources.multiply(partitionResource, absCap);\n      Resource maxCapacity \u003d Resources.multiply(partitionResource, absMaxCap);\n      Resource killable \u003d Resources.none();\n      if (null !\u003d preemptableQueues.get(queueName)) {\n         killable \u003d preemptableQueues.get(queueName)\n            .getKillableResource(partitionToLookAt);\n      }\n\n      // when partition is a non-exclusive partition, the actual maxCapacity\n      // could more than specified maxCapacity\n      try {\n        if (!scheduler.getRMContext().getNodeLabelManager()\n            .isExclusiveNodeLabel(partitionToLookAt)) {\n          maxCapacity \u003d\n              Resources.max(rc, partitionResource, maxCapacity, current);\n        }\n      } catch (IOException e) {\n        // This may cause by partition removed when running capacity monitor,\n        // just ignore the error, this will be corrected when doing next check.\n      }\n\n      Resource extra \u003d Resource.newInstance(0, 0);\n      if (Resources.greaterThan(rc, partitionResource, current, guaranteed)) {\n        extra \u003d Resources.subtract(current, guaranteed);\n      }\n      if (curQueue instanceof LeafQueue) {\n        LeafQueue l \u003d (LeafQueue) curQueue;\n        Resource pending \u003d\n              l.getTotalPendingResourcesConsideringUserLimit(\n                  partitionResource, partitionToLookAt);\n        ret \u003d new TempQueuePerPartition(queueName, current, pending, guaranteed,\n            maxCapacity, preemptionDisabled, partitionToLookAt, killable);\n        if (preemptionDisabled) {\n          ret.untouchableExtra \u003d extra;\n        } else {\n          ret.preemptableExtra \u003d extra;\n        }\n        ret.setLeafQueue(l);\n      } else {\n        Resource pending \u003d Resource.newInstance(0, 0);\n        ret \u003d\n            new TempQueuePerPartition(curQueue.getQueueName(), current, pending,\n                guaranteed, maxCapacity, false, partitionToLookAt, killable);\n        Resource childrensPreemptable \u003d Resource.newInstance(0, 0);\n        for (CSQueue c : curQueue.getChildQueues()) {\n          TempQueuePerPartition subq \u003d\n              cloneQueues(c, partitionResource, partitionToLookAt);\n          Resources.addTo(childrensPreemptable, subq.preemptableExtra);\n          ret.addChild(subq);\n        }\n        // untouchableExtra \u003d max(extra - childrenPreemptable, 0)\n        if (Resources.greaterThanOrEqual(\n              rc, partitionResource, childrensPreemptable, extra)) {\n          ret.untouchableExtra \u003d Resource.newInstance(0, 0);\n        } else {\n          ret.untouchableExtra \u003d\n                Resources.subtract(extra, childrensPreemptable);\n        }\n        ret.preemptableExtra \u003d Resources.min(\n            rc, partitionResource, childrensPreemptable, extra);\n      }\n    }\n    addTempQueuePartition(ret);\n    return ret;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java",
      "extendedDetails": {}
    },
    "ae14e5d07f1b6702a5160637438028bb03d9387e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4108. CapacityScheduler: Improve preemption to only kill containers that would satisfy the incoming request. (Wangda Tan)\n\n(cherry picked from commit 7e8c9beb4156dcaeb3a11e60aaa06d2370626913)\n",
      "commitDate": "16/03/16 5:02 PM",
      "commitName": "ae14e5d07f1b6702a5160637438028bb03d9387e",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "16/03/16 5:02 PM",
      "commitNameOld": "fa7a43529d529f0006c8033c2003f15b9b93f103",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,72 +1,77 @@\n   private TempQueuePerPartition cloneQueues(CSQueue curQueue,\n       Resource partitionResource, String partitionToLookAt) {\n     TempQueuePerPartition ret;\n     synchronized (curQueue) {\n       String queueName \u003d curQueue.getQueueName();\n       QueueCapacities qc \u003d curQueue.getQueueCapacities();\n       float absCap \u003d qc.getAbsoluteCapacity(partitionToLookAt);\n       float absMaxCap \u003d qc.getAbsoluteMaximumCapacity(partitionToLookAt);\n       boolean preemptionDisabled \u003d curQueue.getPreemptionDisabled();\n \n       Resource current \u003d curQueue.getQueueResourceUsage().getUsed(\n           partitionToLookAt);\n       Resource guaranteed \u003d Resources.multiply(partitionResource, absCap);\n       Resource maxCapacity \u003d Resources.multiply(partitionResource, absMaxCap);\n+      Resource killable \u003d Resources.none();\n+      if (null !\u003d preemptableEntities.get(queueName)) {\n+         killable \u003d preemptableEntities.get(queueName)\n+            .getKillableResource(partitionToLookAt);\n+      }\n \n       // when partition is a non-exclusive partition, the actual maxCapacity\n       // could more than specified maxCapacity\n       try {\n         if (!scheduler.getRMContext().getNodeLabelManager()\n             .isExclusiveNodeLabel(partitionToLookAt)) {\n           maxCapacity \u003d\n               Resources.max(rc, partitionResource, maxCapacity, current);\n         }\n       } catch (IOException e) {\n         // This may cause by partition removed when running capacity monitor,\n         // just ignore the error, this will be corrected when doing next check.\n       }\n \n       Resource extra \u003d Resource.newInstance(0, 0);\n       if (Resources.greaterThan(rc, partitionResource, current, guaranteed)) {\n         extra \u003d Resources.subtract(current, guaranteed);\n       }\n       if (curQueue instanceof LeafQueue) {\n         LeafQueue l \u003d (LeafQueue) curQueue;\n         Resource pending \u003d\n               l.getTotalPendingResourcesConsideringUserLimit(\n                   partitionResource, partitionToLookAt);\n         ret \u003d new TempQueuePerPartition(queueName, current, pending, guaranteed,\n-            maxCapacity, preemptionDisabled, partitionToLookAt);\n+            maxCapacity, preemptionDisabled, partitionToLookAt, killable);\n         if (preemptionDisabled) {\n           ret.untouchableExtra \u003d extra;\n         } else {\n           ret.preemptableExtra \u003d extra;\n         }\n         ret.setLeafQueue(l);\n       } else {\n         Resource pending \u003d Resource.newInstance(0, 0);\n         ret \u003d\n             new TempQueuePerPartition(curQueue.getQueueName(), current, pending,\n-                guaranteed, maxCapacity, false, partitionToLookAt);\n+                guaranteed, maxCapacity, false, partitionToLookAt, killable);\n         Resource childrensPreemptable \u003d Resource.newInstance(0, 0);\n         for (CSQueue c : curQueue.getChildQueues()) {\n           TempQueuePerPartition subq \u003d\n               cloneQueues(c, partitionResource, partitionToLookAt);\n           Resources.addTo(childrensPreemptable, subq.preemptableExtra);\n           ret.addChild(subq);\n         }\n         // untouchableExtra \u003d max(extra - childrenPreemptable, 0)\n         if (Resources.greaterThanOrEqual(\n               rc, partitionResource, childrensPreemptable, extra)) {\n           ret.untouchableExtra \u003d Resource.newInstance(0, 0);\n         } else {\n           ret.untouchableExtra \u003d\n                 Resources.subtract(extra, childrensPreemptable);\n         }\n         ret.preemptableExtra \u003d Resources.min(\n             rc, partitionResource, childrensPreemptable, extra);\n       }\n     }\n     addTempQueuePartition(ret);\n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private TempQueuePerPartition cloneQueues(CSQueue curQueue,\n      Resource partitionResource, String partitionToLookAt) {\n    TempQueuePerPartition ret;\n    synchronized (curQueue) {\n      String queueName \u003d curQueue.getQueueName();\n      QueueCapacities qc \u003d curQueue.getQueueCapacities();\n      float absCap \u003d qc.getAbsoluteCapacity(partitionToLookAt);\n      float absMaxCap \u003d qc.getAbsoluteMaximumCapacity(partitionToLookAt);\n      boolean preemptionDisabled \u003d curQueue.getPreemptionDisabled();\n\n      Resource current \u003d curQueue.getQueueResourceUsage().getUsed(\n          partitionToLookAt);\n      Resource guaranteed \u003d Resources.multiply(partitionResource, absCap);\n      Resource maxCapacity \u003d Resources.multiply(partitionResource, absMaxCap);\n      Resource killable \u003d Resources.none();\n      if (null !\u003d preemptableEntities.get(queueName)) {\n         killable \u003d preemptableEntities.get(queueName)\n            .getKillableResource(partitionToLookAt);\n      }\n\n      // when partition is a non-exclusive partition, the actual maxCapacity\n      // could more than specified maxCapacity\n      try {\n        if (!scheduler.getRMContext().getNodeLabelManager()\n            .isExclusiveNodeLabel(partitionToLookAt)) {\n          maxCapacity \u003d\n              Resources.max(rc, partitionResource, maxCapacity, current);\n        }\n      } catch (IOException e) {\n        // This may cause by partition removed when running capacity monitor,\n        // just ignore the error, this will be corrected when doing next check.\n      }\n\n      Resource extra \u003d Resource.newInstance(0, 0);\n      if (Resources.greaterThan(rc, partitionResource, current, guaranteed)) {\n        extra \u003d Resources.subtract(current, guaranteed);\n      }\n      if (curQueue instanceof LeafQueue) {\n        LeafQueue l \u003d (LeafQueue) curQueue;\n        Resource pending \u003d\n              l.getTotalPendingResourcesConsideringUserLimit(\n                  partitionResource, partitionToLookAt);\n        ret \u003d new TempQueuePerPartition(queueName, current, pending, guaranteed,\n            maxCapacity, preemptionDisabled, partitionToLookAt, killable);\n        if (preemptionDisabled) {\n          ret.untouchableExtra \u003d extra;\n        } else {\n          ret.preemptableExtra \u003d extra;\n        }\n        ret.setLeafQueue(l);\n      } else {\n        Resource pending \u003d Resource.newInstance(0, 0);\n        ret \u003d\n            new TempQueuePerPartition(curQueue.getQueueName(), current, pending,\n                guaranteed, maxCapacity, false, partitionToLookAt, killable);\n        Resource childrensPreemptable \u003d Resource.newInstance(0, 0);\n        for (CSQueue c : curQueue.getChildQueues()) {\n          TempQueuePerPartition subq \u003d\n              cloneQueues(c, partitionResource, partitionToLookAt);\n          Resources.addTo(childrensPreemptable, subq.preemptableExtra);\n          ret.addChild(subq);\n        }\n        // untouchableExtra \u003d max(extra - childrenPreemptable, 0)\n        if (Resources.greaterThanOrEqual(\n              rc, partitionResource, childrensPreemptable, extra)) {\n          ret.untouchableExtra \u003d Resource.newInstance(0, 0);\n        } else {\n          ret.untouchableExtra \u003d\n                Resources.subtract(extra, childrensPreemptable);\n        }\n        ret.preemptableExtra \u003d Resources.min(\n            rc, partitionResource, childrensPreemptable, extra);\n      }\n    }\n    addTempQueuePartition(ret);\n    return ret;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java",
      "extendedDetails": {}
    },
    "fa7a43529d529f0006c8033c2003f15b9b93f103": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"CapacityScheduler: Improve preemption to only kill containers that would satisfy the incoming request. (Wangda Tan)\"\n\nThis reverts commit 7e8c9beb4156dcaeb3a11e60aaa06d2370626913.\n",
      "commitDate": "16/03/16 5:02 PM",
      "commitName": "fa7a43529d529f0006c8033c2003f15b9b93f103",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "16/03/16 4:59 PM",
      "commitNameOld": "7e8c9beb4156dcaeb3a11e60aaa06d2370626913",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,77 +1,72 @@\n   private TempQueuePerPartition cloneQueues(CSQueue curQueue,\n       Resource partitionResource, String partitionToLookAt) {\n     TempQueuePerPartition ret;\n     synchronized (curQueue) {\n       String queueName \u003d curQueue.getQueueName();\n       QueueCapacities qc \u003d curQueue.getQueueCapacities();\n       float absCap \u003d qc.getAbsoluteCapacity(partitionToLookAt);\n       float absMaxCap \u003d qc.getAbsoluteMaximumCapacity(partitionToLookAt);\n       boolean preemptionDisabled \u003d curQueue.getPreemptionDisabled();\n \n       Resource current \u003d curQueue.getQueueResourceUsage().getUsed(\n           partitionToLookAt);\n       Resource guaranteed \u003d Resources.multiply(partitionResource, absCap);\n       Resource maxCapacity \u003d Resources.multiply(partitionResource, absMaxCap);\n-      Resource killable \u003d Resources.none();\n-      if (null !\u003d preemptableEntities.get(queueName)) {\n-         killable \u003d preemptableEntities.get(queueName)\n-            .getKillableResource(partitionToLookAt);\n-      }\n \n       // when partition is a non-exclusive partition, the actual maxCapacity\n       // could more than specified maxCapacity\n       try {\n         if (!scheduler.getRMContext().getNodeLabelManager()\n             .isExclusiveNodeLabel(partitionToLookAt)) {\n           maxCapacity \u003d\n               Resources.max(rc, partitionResource, maxCapacity, current);\n         }\n       } catch (IOException e) {\n         // This may cause by partition removed when running capacity monitor,\n         // just ignore the error, this will be corrected when doing next check.\n       }\n \n       Resource extra \u003d Resource.newInstance(0, 0);\n       if (Resources.greaterThan(rc, partitionResource, current, guaranteed)) {\n         extra \u003d Resources.subtract(current, guaranteed);\n       }\n       if (curQueue instanceof LeafQueue) {\n         LeafQueue l \u003d (LeafQueue) curQueue;\n         Resource pending \u003d\n               l.getTotalPendingResourcesConsideringUserLimit(\n                   partitionResource, partitionToLookAt);\n         ret \u003d new TempQueuePerPartition(queueName, current, pending, guaranteed,\n-            maxCapacity, preemptionDisabled, partitionToLookAt, killable);\n+            maxCapacity, preemptionDisabled, partitionToLookAt);\n         if (preemptionDisabled) {\n           ret.untouchableExtra \u003d extra;\n         } else {\n           ret.preemptableExtra \u003d extra;\n         }\n         ret.setLeafQueue(l);\n       } else {\n         Resource pending \u003d Resource.newInstance(0, 0);\n         ret \u003d\n             new TempQueuePerPartition(curQueue.getQueueName(), current, pending,\n-                guaranteed, maxCapacity, false, partitionToLookAt, killable);\n+                guaranteed, maxCapacity, false, partitionToLookAt);\n         Resource childrensPreemptable \u003d Resource.newInstance(0, 0);\n         for (CSQueue c : curQueue.getChildQueues()) {\n           TempQueuePerPartition subq \u003d\n               cloneQueues(c, partitionResource, partitionToLookAt);\n           Resources.addTo(childrensPreemptable, subq.preemptableExtra);\n           ret.addChild(subq);\n         }\n         // untouchableExtra \u003d max(extra - childrenPreemptable, 0)\n         if (Resources.greaterThanOrEqual(\n               rc, partitionResource, childrensPreemptable, extra)) {\n           ret.untouchableExtra \u003d Resource.newInstance(0, 0);\n         } else {\n           ret.untouchableExtra \u003d\n                 Resources.subtract(extra, childrensPreemptable);\n         }\n         ret.preemptableExtra \u003d Resources.min(\n             rc, partitionResource, childrensPreemptable, extra);\n       }\n     }\n     addTempQueuePartition(ret);\n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private TempQueuePerPartition cloneQueues(CSQueue curQueue,\n      Resource partitionResource, String partitionToLookAt) {\n    TempQueuePerPartition ret;\n    synchronized (curQueue) {\n      String queueName \u003d curQueue.getQueueName();\n      QueueCapacities qc \u003d curQueue.getQueueCapacities();\n      float absCap \u003d qc.getAbsoluteCapacity(partitionToLookAt);\n      float absMaxCap \u003d qc.getAbsoluteMaximumCapacity(partitionToLookAt);\n      boolean preemptionDisabled \u003d curQueue.getPreemptionDisabled();\n\n      Resource current \u003d curQueue.getQueueResourceUsage().getUsed(\n          partitionToLookAt);\n      Resource guaranteed \u003d Resources.multiply(partitionResource, absCap);\n      Resource maxCapacity \u003d Resources.multiply(partitionResource, absMaxCap);\n\n      // when partition is a non-exclusive partition, the actual maxCapacity\n      // could more than specified maxCapacity\n      try {\n        if (!scheduler.getRMContext().getNodeLabelManager()\n            .isExclusiveNodeLabel(partitionToLookAt)) {\n          maxCapacity \u003d\n              Resources.max(rc, partitionResource, maxCapacity, current);\n        }\n      } catch (IOException e) {\n        // This may cause by partition removed when running capacity monitor,\n        // just ignore the error, this will be corrected when doing next check.\n      }\n\n      Resource extra \u003d Resource.newInstance(0, 0);\n      if (Resources.greaterThan(rc, partitionResource, current, guaranteed)) {\n        extra \u003d Resources.subtract(current, guaranteed);\n      }\n      if (curQueue instanceof LeafQueue) {\n        LeafQueue l \u003d (LeafQueue) curQueue;\n        Resource pending \u003d\n              l.getTotalPendingResourcesConsideringUserLimit(\n                  partitionResource, partitionToLookAt);\n        ret \u003d new TempQueuePerPartition(queueName, current, pending, guaranteed,\n            maxCapacity, preemptionDisabled, partitionToLookAt);\n        if (preemptionDisabled) {\n          ret.untouchableExtra \u003d extra;\n        } else {\n          ret.preemptableExtra \u003d extra;\n        }\n        ret.setLeafQueue(l);\n      } else {\n        Resource pending \u003d Resource.newInstance(0, 0);\n        ret \u003d\n            new TempQueuePerPartition(curQueue.getQueueName(), current, pending,\n                guaranteed, maxCapacity, false, partitionToLookAt);\n        Resource childrensPreemptable \u003d Resource.newInstance(0, 0);\n        for (CSQueue c : curQueue.getChildQueues()) {\n          TempQueuePerPartition subq \u003d\n              cloneQueues(c, partitionResource, partitionToLookAt);\n          Resources.addTo(childrensPreemptable, subq.preemptableExtra);\n          ret.addChild(subq);\n        }\n        // untouchableExtra \u003d max(extra - childrenPreemptable, 0)\n        if (Resources.greaterThanOrEqual(\n              rc, partitionResource, childrensPreemptable, extra)) {\n          ret.untouchableExtra \u003d Resource.newInstance(0, 0);\n        } else {\n          ret.untouchableExtra \u003d\n                Resources.subtract(extra, childrensPreemptable);\n        }\n        ret.preemptableExtra \u003d Resources.min(\n            rc, partitionResource, childrensPreemptable, extra);\n      }\n    }\n    addTempQueuePartition(ret);\n    return ret;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java",
      "extendedDetails": {}
    },
    "7e8c9beb4156dcaeb3a11e60aaa06d2370626913": {
      "type": "Ybodychange",
      "commitMessage": "CapacityScheduler: Improve preemption to only kill containers that would satisfy the incoming request. (Wangda Tan)\n",
      "commitDate": "16/03/16 4:59 PM",
      "commitName": "7e8c9beb4156dcaeb3a11e60aaa06d2370626913",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "18/01/16 5:30 PM",
      "commitNameOld": "a44ce3f14fd940601f984fbf7980aa6fdc8f23b7",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 57.94,
      "commitsBetweenForRepo": 394,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,72 +1,77 @@\n   private TempQueuePerPartition cloneQueues(CSQueue curQueue,\n       Resource partitionResource, String partitionToLookAt) {\n     TempQueuePerPartition ret;\n     synchronized (curQueue) {\n       String queueName \u003d curQueue.getQueueName();\n       QueueCapacities qc \u003d curQueue.getQueueCapacities();\n       float absCap \u003d qc.getAbsoluteCapacity(partitionToLookAt);\n       float absMaxCap \u003d qc.getAbsoluteMaximumCapacity(partitionToLookAt);\n       boolean preemptionDisabled \u003d curQueue.getPreemptionDisabled();\n \n       Resource current \u003d curQueue.getQueueResourceUsage().getUsed(\n           partitionToLookAt);\n       Resource guaranteed \u003d Resources.multiply(partitionResource, absCap);\n       Resource maxCapacity \u003d Resources.multiply(partitionResource, absMaxCap);\n+      Resource killable \u003d Resources.none();\n+      if (null !\u003d preemptableEntities.get(queueName)) {\n+         killable \u003d preemptableEntities.get(queueName)\n+            .getKillableResource(partitionToLookAt);\n+      }\n \n       // when partition is a non-exclusive partition, the actual maxCapacity\n       // could more than specified maxCapacity\n       try {\n         if (!scheduler.getRMContext().getNodeLabelManager()\n             .isExclusiveNodeLabel(partitionToLookAt)) {\n           maxCapacity \u003d\n               Resources.max(rc, partitionResource, maxCapacity, current);\n         }\n       } catch (IOException e) {\n         // This may cause by partition removed when running capacity monitor,\n         // just ignore the error, this will be corrected when doing next check.\n       }\n \n       Resource extra \u003d Resource.newInstance(0, 0);\n       if (Resources.greaterThan(rc, partitionResource, current, guaranteed)) {\n         extra \u003d Resources.subtract(current, guaranteed);\n       }\n       if (curQueue instanceof LeafQueue) {\n         LeafQueue l \u003d (LeafQueue) curQueue;\n         Resource pending \u003d\n               l.getTotalPendingResourcesConsideringUserLimit(\n                   partitionResource, partitionToLookAt);\n         ret \u003d new TempQueuePerPartition(queueName, current, pending, guaranteed,\n-            maxCapacity, preemptionDisabled, partitionToLookAt);\n+            maxCapacity, preemptionDisabled, partitionToLookAt, killable);\n         if (preemptionDisabled) {\n           ret.untouchableExtra \u003d extra;\n         } else {\n           ret.preemptableExtra \u003d extra;\n         }\n         ret.setLeafQueue(l);\n       } else {\n         Resource pending \u003d Resource.newInstance(0, 0);\n         ret \u003d\n             new TempQueuePerPartition(curQueue.getQueueName(), current, pending,\n-                guaranteed, maxCapacity, false, partitionToLookAt);\n+                guaranteed, maxCapacity, false, partitionToLookAt, killable);\n         Resource childrensPreemptable \u003d Resource.newInstance(0, 0);\n         for (CSQueue c : curQueue.getChildQueues()) {\n           TempQueuePerPartition subq \u003d\n               cloneQueues(c, partitionResource, partitionToLookAt);\n           Resources.addTo(childrensPreemptable, subq.preemptableExtra);\n           ret.addChild(subq);\n         }\n         // untouchableExtra \u003d max(extra - childrenPreemptable, 0)\n         if (Resources.greaterThanOrEqual(\n               rc, partitionResource, childrensPreemptable, extra)) {\n           ret.untouchableExtra \u003d Resource.newInstance(0, 0);\n         } else {\n           ret.untouchableExtra \u003d\n                 Resources.subtract(extra, childrensPreemptable);\n         }\n         ret.preemptableExtra \u003d Resources.min(\n             rc, partitionResource, childrensPreemptable, extra);\n       }\n     }\n     addTempQueuePartition(ret);\n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private TempQueuePerPartition cloneQueues(CSQueue curQueue,\n      Resource partitionResource, String partitionToLookAt) {\n    TempQueuePerPartition ret;\n    synchronized (curQueue) {\n      String queueName \u003d curQueue.getQueueName();\n      QueueCapacities qc \u003d curQueue.getQueueCapacities();\n      float absCap \u003d qc.getAbsoluteCapacity(partitionToLookAt);\n      float absMaxCap \u003d qc.getAbsoluteMaximumCapacity(partitionToLookAt);\n      boolean preemptionDisabled \u003d curQueue.getPreemptionDisabled();\n\n      Resource current \u003d curQueue.getQueueResourceUsage().getUsed(\n          partitionToLookAt);\n      Resource guaranteed \u003d Resources.multiply(partitionResource, absCap);\n      Resource maxCapacity \u003d Resources.multiply(partitionResource, absMaxCap);\n      Resource killable \u003d Resources.none();\n      if (null !\u003d preemptableEntities.get(queueName)) {\n         killable \u003d preemptableEntities.get(queueName)\n            .getKillableResource(partitionToLookAt);\n      }\n\n      // when partition is a non-exclusive partition, the actual maxCapacity\n      // could more than specified maxCapacity\n      try {\n        if (!scheduler.getRMContext().getNodeLabelManager()\n            .isExclusiveNodeLabel(partitionToLookAt)) {\n          maxCapacity \u003d\n              Resources.max(rc, partitionResource, maxCapacity, current);\n        }\n      } catch (IOException e) {\n        // This may cause by partition removed when running capacity monitor,\n        // just ignore the error, this will be corrected when doing next check.\n      }\n\n      Resource extra \u003d Resource.newInstance(0, 0);\n      if (Resources.greaterThan(rc, partitionResource, current, guaranteed)) {\n        extra \u003d Resources.subtract(current, guaranteed);\n      }\n      if (curQueue instanceof LeafQueue) {\n        LeafQueue l \u003d (LeafQueue) curQueue;\n        Resource pending \u003d\n              l.getTotalPendingResourcesConsideringUserLimit(\n                  partitionResource, partitionToLookAt);\n        ret \u003d new TempQueuePerPartition(queueName, current, pending, guaranteed,\n            maxCapacity, preemptionDisabled, partitionToLookAt, killable);\n        if (preemptionDisabled) {\n          ret.untouchableExtra \u003d extra;\n        } else {\n          ret.preemptableExtra \u003d extra;\n        }\n        ret.setLeafQueue(l);\n      } else {\n        Resource pending \u003d Resource.newInstance(0, 0);\n        ret \u003d\n            new TempQueuePerPartition(curQueue.getQueueName(), current, pending,\n                guaranteed, maxCapacity, false, partitionToLookAt, killable);\n        Resource childrensPreemptable \u003d Resource.newInstance(0, 0);\n        for (CSQueue c : curQueue.getChildQueues()) {\n          TempQueuePerPartition subq \u003d\n              cloneQueues(c, partitionResource, partitionToLookAt);\n          Resources.addTo(childrensPreemptable, subq.preemptableExtra);\n          ret.addChild(subq);\n        }\n        // untouchableExtra \u003d max(extra - childrenPreemptable, 0)\n        if (Resources.greaterThanOrEqual(\n              rc, partitionResource, childrensPreemptable, extra)) {\n          ret.untouchableExtra \u003d Resource.newInstance(0, 0);\n        } else {\n          ret.untouchableExtra \u003d\n                Resources.subtract(extra, childrensPreemptable);\n        }\n        ret.preemptableExtra \u003d Resources.min(\n            rc, partitionResource, childrensPreemptable, extra);\n      }\n    }\n    addTempQueuePartition(ret);\n    return ret;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java",
      "extendedDetails": {}
    },
    "2346fa3141bf28f25a90b6a426a1d3a3982e464f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3769. Consider user limit when calculating total pending resource for preemption policy in Capacity Scheduler. (Eric Payne via wangda)\n",
      "commitDate": "20/11/15 3:55 PM",
      "commitName": "2346fa3141bf28f25a90b6a426a1d3a3982e464f",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "23/07/15 10:07 AM",
      "commitNameOld": "3bba1800513b38a4827f7552f348db87dc47c783",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 120.28,
      "commitsBetweenForRepo": 827,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,71 +1,72 @@\n   private TempQueuePerPartition cloneQueues(CSQueue curQueue,\n       Resource partitionResource, String partitionToLookAt) {\n     TempQueuePerPartition ret;\n     synchronized (curQueue) {\n       String queueName \u003d curQueue.getQueueName();\n       QueueCapacities qc \u003d curQueue.getQueueCapacities();\n       float absCap \u003d qc.getAbsoluteCapacity(partitionToLookAt);\n       float absMaxCap \u003d qc.getAbsoluteMaximumCapacity(partitionToLookAt);\n       boolean preemptionDisabled \u003d curQueue.getPreemptionDisabled();\n \n       Resource current \u003d curQueue.getQueueResourceUsage().getUsed(\n           partitionToLookAt);\n       Resource guaranteed \u003d Resources.multiply(partitionResource, absCap);\n       Resource maxCapacity \u003d Resources.multiply(partitionResource, absMaxCap);\n \n       // when partition is a non-exclusive partition, the actual maxCapacity\n       // could more than specified maxCapacity\n       try {\n         if (!scheduler.getRMContext().getNodeLabelManager()\n             .isExclusiveNodeLabel(partitionToLookAt)) {\n           maxCapacity \u003d\n               Resources.max(rc, partitionResource, maxCapacity, current);\n         }\n       } catch (IOException e) {\n         // This may cause by partition removed when running capacity monitor,\n         // just ignore the error, this will be corrected when doing next check.\n       }\n \n       Resource extra \u003d Resource.newInstance(0, 0);\n       if (Resources.greaterThan(rc, partitionResource, current, guaranteed)) {\n         extra \u003d Resources.subtract(current, guaranteed);\n       }\n       if (curQueue instanceof LeafQueue) {\n         LeafQueue l \u003d (LeafQueue) curQueue;\n         Resource pending \u003d\n-            l.getQueueResourceUsage().getPending(partitionToLookAt);\n+              l.getTotalPendingResourcesConsideringUserLimit(\n+                  partitionResource, partitionToLookAt);\n         ret \u003d new TempQueuePerPartition(queueName, current, pending, guaranteed,\n             maxCapacity, preemptionDisabled, partitionToLookAt);\n         if (preemptionDisabled) {\n           ret.untouchableExtra \u003d extra;\n         } else {\n           ret.preemptableExtra \u003d extra;\n         }\n         ret.setLeafQueue(l);\n       } else {\n         Resource pending \u003d Resource.newInstance(0, 0);\n         ret \u003d\n             new TempQueuePerPartition(curQueue.getQueueName(), current, pending,\n                 guaranteed, maxCapacity, false, partitionToLookAt);\n         Resource childrensPreemptable \u003d Resource.newInstance(0, 0);\n         for (CSQueue c : curQueue.getChildQueues()) {\n           TempQueuePerPartition subq \u003d\n               cloneQueues(c, partitionResource, partitionToLookAt);\n           Resources.addTo(childrensPreemptable, subq.preemptableExtra);\n           ret.addChild(subq);\n         }\n         // untouchableExtra \u003d max(extra - childrenPreemptable, 0)\n         if (Resources.greaterThanOrEqual(\n               rc, partitionResource, childrensPreemptable, extra)) {\n           ret.untouchableExtra \u003d Resource.newInstance(0, 0);\n         } else {\n           ret.untouchableExtra \u003d\n                 Resources.subtract(extra, childrensPreemptable);\n         }\n         ret.preemptableExtra \u003d Resources.min(\n             rc, partitionResource, childrensPreemptable, extra);\n       }\n     }\n     addTempQueuePartition(ret);\n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private TempQueuePerPartition cloneQueues(CSQueue curQueue,\n      Resource partitionResource, String partitionToLookAt) {\n    TempQueuePerPartition ret;\n    synchronized (curQueue) {\n      String queueName \u003d curQueue.getQueueName();\n      QueueCapacities qc \u003d curQueue.getQueueCapacities();\n      float absCap \u003d qc.getAbsoluteCapacity(partitionToLookAt);\n      float absMaxCap \u003d qc.getAbsoluteMaximumCapacity(partitionToLookAt);\n      boolean preemptionDisabled \u003d curQueue.getPreemptionDisabled();\n\n      Resource current \u003d curQueue.getQueueResourceUsage().getUsed(\n          partitionToLookAt);\n      Resource guaranteed \u003d Resources.multiply(partitionResource, absCap);\n      Resource maxCapacity \u003d Resources.multiply(partitionResource, absMaxCap);\n\n      // when partition is a non-exclusive partition, the actual maxCapacity\n      // could more than specified maxCapacity\n      try {\n        if (!scheduler.getRMContext().getNodeLabelManager()\n            .isExclusiveNodeLabel(partitionToLookAt)) {\n          maxCapacity \u003d\n              Resources.max(rc, partitionResource, maxCapacity, current);\n        }\n      } catch (IOException e) {\n        // This may cause by partition removed when running capacity monitor,\n        // just ignore the error, this will be corrected when doing next check.\n      }\n\n      Resource extra \u003d Resource.newInstance(0, 0);\n      if (Resources.greaterThan(rc, partitionResource, current, guaranteed)) {\n        extra \u003d Resources.subtract(current, guaranteed);\n      }\n      if (curQueue instanceof LeafQueue) {\n        LeafQueue l \u003d (LeafQueue) curQueue;\n        Resource pending \u003d\n              l.getTotalPendingResourcesConsideringUserLimit(\n                  partitionResource, partitionToLookAt);\n        ret \u003d new TempQueuePerPartition(queueName, current, pending, guaranteed,\n            maxCapacity, preemptionDisabled, partitionToLookAt);\n        if (preemptionDisabled) {\n          ret.untouchableExtra \u003d extra;\n        } else {\n          ret.preemptableExtra \u003d extra;\n        }\n        ret.setLeafQueue(l);\n      } else {\n        Resource pending \u003d Resource.newInstance(0, 0);\n        ret \u003d\n            new TempQueuePerPartition(curQueue.getQueueName(), current, pending,\n                guaranteed, maxCapacity, false, partitionToLookAt);\n        Resource childrensPreemptable \u003d Resource.newInstance(0, 0);\n        for (CSQueue c : curQueue.getChildQueues()) {\n          TempQueuePerPartition subq \u003d\n              cloneQueues(c, partitionResource, partitionToLookAt);\n          Resources.addTo(childrensPreemptable, subq.preemptableExtra);\n          ret.addChild(subq);\n        }\n        // untouchableExtra \u003d max(extra - childrenPreemptable, 0)\n        if (Resources.greaterThanOrEqual(\n              rc, partitionResource, childrensPreemptable, extra)) {\n          ret.untouchableExtra \u003d Resource.newInstance(0, 0);\n        } else {\n          ret.untouchableExtra \u003d\n                Resources.subtract(extra, childrensPreemptable);\n        }\n        ret.preemptableExtra \u003d Resources.min(\n            rc, partitionResource, childrensPreemptable, extra);\n      }\n    }\n    addTempQueuePartition(ret);\n    return ret;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java",
      "extendedDetails": {}
    },
    "3540d5fe4b1da942ea80c9e7ca1126b1abb8a68a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3885. ProportionalCapacityPreemptionPolicy doesn\u0027t preempt if queue is more than 2 level. (Ajith S via wangda)\n",
      "commitDate": "16/07/15 4:13 PM",
      "commitName": "3540d5fe4b1da942ea80c9e7ca1126b1abb8a68a",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "11/07/15 10:26 AM",
      "commitNameOld": "1df39c1efc9ed26d3f1a5887c31c38c873e0b784",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 5.24,
      "commitsBetweenForRepo": 29,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,69 +1,71 @@\n   private TempQueuePerPartition cloneQueues(CSQueue curQueue,\n       Resource partitionResource, String partitionToLookAt) {\n     TempQueuePerPartition ret;\n     synchronized (curQueue) {\n       String queueName \u003d curQueue.getQueueName();\n       QueueCapacities qc \u003d curQueue.getQueueCapacities();\n       float absCap \u003d qc.getAbsoluteCapacity(partitionToLookAt);\n       float absMaxCap \u003d qc.getAbsoluteMaximumCapacity(partitionToLookAt);\n       boolean preemptionDisabled \u003d curQueue.getPreemptionDisabled();\n \n       Resource current \u003d curQueue.getQueueResourceUsage().getUsed(\n           partitionToLookAt);\n       Resource guaranteed \u003d Resources.multiply(partitionResource, absCap);\n       Resource maxCapacity \u003d Resources.multiply(partitionResource, absMaxCap);\n \n       // when partition is a non-exclusive partition, the actual maxCapacity\n       // could more than specified maxCapacity\n       try {\n         if (!scheduler.getRMContext().getNodeLabelManager()\n             .isExclusiveNodeLabel(partitionToLookAt)) {\n           maxCapacity \u003d\n               Resources.max(rc, partitionResource, maxCapacity, current);\n         }\n       } catch (IOException e) {\n         // This may cause by partition removed when running capacity monitor,\n         // just ignore the error, this will be corrected when doing next check.\n       }\n \n       Resource extra \u003d Resource.newInstance(0, 0);\n       if (Resources.greaterThan(rc, partitionResource, current, guaranteed)) {\n         extra \u003d Resources.subtract(current, guaranteed);\n       }\n       if (curQueue instanceof LeafQueue) {\n         LeafQueue l \u003d (LeafQueue) curQueue;\n         Resource pending \u003d\n             l.getQueueResourceUsage().getPending(partitionToLookAt);\n         ret \u003d new TempQueuePerPartition(queueName, current, pending, guaranteed,\n             maxCapacity, preemptionDisabled, partitionToLookAt);\n         if (preemptionDisabled) {\n           ret.untouchableExtra \u003d extra;\n         } else {\n           ret.preemptableExtra \u003d extra;\n         }\n         ret.setLeafQueue(l);\n       } else {\n         Resource pending \u003d Resource.newInstance(0, 0);\n         ret \u003d\n             new TempQueuePerPartition(curQueue.getQueueName(), current, pending,\n                 guaranteed, maxCapacity, false, partitionToLookAt);\n         Resource childrensPreemptable \u003d Resource.newInstance(0, 0);\n         for (CSQueue c : curQueue.getChildQueues()) {\n           TempQueuePerPartition subq \u003d\n               cloneQueues(c, partitionResource, partitionToLookAt);\n           Resources.addTo(childrensPreemptable, subq.preemptableExtra);\n           ret.addChild(subq);\n         }\n         // untouchableExtra \u003d max(extra - childrenPreemptable, 0)\n         if (Resources.greaterThanOrEqual(\n               rc, partitionResource, childrensPreemptable, extra)) {\n           ret.untouchableExtra \u003d Resource.newInstance(0, 0);\n         } else {\n           ret.untouchableExtra \u003d\n-                Resources.subtractFrom(extra, childrensPreemptable);\n+                Resources.subtract(extra, childrensPreemptable);\n         }\n+        ret.preemptableExtra \u003d Resources.min(\n+            rc, partitionResource, childrensPreemptable, extra);\n       }\n     }\n     addTempQueuePartition(ret);\n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private TempQueuePerPartition cloneQueues(CSQueue curQueue,\n      Resource partitionResource, String partitionToLookAt) {\n    TempQueuePerPartition ret;\n    synchronized (curQueue) {\n      String queueName \u003d curQueue.getQueueName();\n      QueueCapacities qc \u003d curQueue.getQueueCapacities();\n      float absCap \u003d qc.getAbsoluteCapacity(partitionToLookAt);\n      float absMaxCap \u003d qc.getAbsoluteMaximumCapacity(partitionToLookAt);\n      boolean preemptionDisabled \u003d curQueue.getPreemptionDisabled();\n\n      Resource current \u003d curQueue.getQueueResourceUsage().getUsed(\n          partitionToLookAt);\n      Resource guaranteed \u003d Resources.multiply(partitionResource, absCap);\n      Resource maxCapacity \u003d Resources.multiply(partitionResource, absMaxCap);\n\n      // when partition is a non-exclusive partition, the actual maxCapacity\n      // could more than specified maxCapacity\n      try {\n        if (!scheduler.getRMContext().getNodeLabelManager()\n            .isExclusiveNodeLabel(partitionToLookAt)) {\n          maxCapacity \u003d\n              Resources.max(rc, partitionResource, maxCapacity, current);\n        }\n      } catch (IOException e) {\n        // This may cause by partition removed when running capacity monitor,\n        // just ignore the error, this will be corrected when doing next check.\n      }\n\n      Resource extra \u003d Resource.newInstance(0, 0);\n      if (Resources.greaterThan(rc, partitionResource, current, guaranteed)) {\n        extra \u003d Resources.subtract(current, guaranteed);\n      }\n      if (curQueue instanceof LeafQueue) {\n        LeafQueue l \u003d (LeafQueue) curQueue;\n        Resource pending \u003d\n            l.getQueueResourceUsage().getPending(partitionToLookAt);\n        ret \u003d new TempQueuePerPartition(queueName, current, pending, guaranteed,\n            maxCapacity, preemptionDisabled, partitionToLookAt);\n        if (preemptionDisabled) {\n          ret.untouchableExtra \u003d extra;\n        } else {\n          ret.preemptableExtra \u003d extra;\n        }\n        ret.setLeafQueue(l);\n      } else {\n        Resource pending \u003d Resource.newInstance(0, 0);\n        ret \u003d\n            new TempQueuePerPartition(curQueue.getQueueName(), current, pending,\n                guaranteed, maxCapacity, false, partitionToLookAt);\n        Resource childrensPreemptable \u003d Resource.newInstance(0, 0);\n        for (CSQueue c : curQueue.getChildQueues()) {\n          TempQueuePerPartition subq \u003d\n              cloneQueues(c, partitionResource, partitionToLookAt);\n          Resources.addTo(childrensPreemptable, subq.preemptableExtra);\n          ret.addChild(subq);\n        }\n        // untouchableExtra \u003d max(extra - childrenPreemptable, 0)\n        if (Resources.greaterThanOrEqual(\n              rc, partitionResource, childrensPreemptable, extra)) {\n          ret.untouchableExtra \u003d Resource.newInstance(0, 0);\n        } else {\n          ret.untouchableExtra \u003d\n                Resources.subtract(extra, childrensPreemptable);\n        }\n        ret.preemptableExtra \u003d Resources.min(\n            rc, partitionResource, childrensPreemptable, extra);\n      }\n    }\n    addTempQueuePartition(ret);\n    return ret;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java",
      "extendedDetails": {}
    },
    "1df39c1efc9ed26d3f1a5887c31c38c873e0b784": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3849. Too much of preemption activity causing continuos killing of containers across queues. (Sunil G via wangda)\n",
      "commitDate": "11/07/15 10:26 AM",
      "commitName": "1df39c1efc9ed26d3f1a5887c31c38c873e0b784",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "01/07/15 5:32 PM",
      "commitNameOld": "0e4b06690ff51fbde3ab26f68fde8aeb32af69af",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 9.7,
      "commitsBetweenForRepo": 52,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,69 +1,69 @@\n   private TempQueuePerPartition cloneQueues(CSQueue curQueue,\n       Resource partitionResource, String partitionToLookAt) {\n     TempQueuePerPartition ret;\n     synchronized (curQueue) {\n       String queueName \u003d curQueue.getQueueName();\n       QueueCapacities qc \u003d curQueue.getQueueCapacities();\n-      float absUsed \u003d qc.getAbsoluteUsedCapacity(partitionToLookAt);\n       float absCap \u003d qc.getAbsoluteCapacity(partitionToLookAt);\n       float absMaxCap \u003d qc.getAbsoluteMaximumCapacity(partitionToLookAt);\n       boolean preemptionDisabled \u003d curQueue.getPreemptionDisabled();\n \n-      Resource current \u003d Resources.multiply(partitionResource, absUsed);\n+      Resource current \u003d curQueue.getQueueResourceUsage().getUsed(\n+          partitionToLookAt);\n       Resource guaranteed \u003d Resources.multiply(partitionResource, absCap);\n       Resource maxCapacity \u003d Resources.multiply(partitionResource, absMaxCap);\n \n       // when partition is a non-exclusive partition, the actual maxCapacity\n       // could more than specified maxCapacity\n       try {\n         if (!scheduler.getRMContext().getNodeLabelManager()\n             .isExclusiveNodeLabel(partitionToLookAt)) {\n           maxCapacity \u003d\n               Resources.max(rc, partitionResource, maxCapacity, current);\n         }\n       } catch (IOException e) {\n         // This may cause by partition removed when running capacity monitor,\n         // just ignore the error, this will be corrected when doing next check.\n       }\n \n       Resource extra \u003d Resource.newInstance(0, 0);\n       if (Resources.greaterThan(rc, partitionResource, current, guaranteed)) {\n         extra \u003d Resources.subtract(current, guaranteed);\n       }\n       if (curQueue instanceof LeafQueue) {\n         LeafQueue l \u003d (LeafQueue) curQueue;\n         Resource pending \u003d\n             l.getQueueResourceUsage().getPending(partitionToLookAt);\n         ret \u003d new TempQueuePerPartition(queueName, current, pending, guaranteed,\n             maxCapacity, preemptionDisabled, partitionToLookAt);\n         if (preemptionDisabled) {\n           ret.untouchableExtra \u003d extra;\n         } else {\n           ret.preemptableExtra \u003d extra;\n         }\n         ret.setLeafQueue(l);\n       } else {\n         Resource pending \u003d Resource.newInstance(0, 0);\n         ret \u003d\n             new TempQueuePerPartition(curQueue.getQueueName(), current, pending,\n                 guaranteed, maxCapacity, false, partitionToLookAt);\n         Resource childrensPreemptable \u003d Resource.newInstance(0, 0);\n         for (CSQueue c : curQueue.getChildQueues()) {\n           TempQueuePerPartition subq \u003d\n               cloneQueues(c, partitionResource, partitionToLookAt);\n           Resources.addTo(childrensPreemptable, subq.preemptableExtra);\n           ret.addChild(subq);\n         }\n         // untouchableExtra \u003d max(extra - childrenPreemptable, 0)\n         if (Resources.greaterThanOrEqual(\n               rc, partitionResource, childrensPreemptable, extra)) {\n           ret.untouchableExtra \u003d Resource.newInstance(0, 0);\n         } else {\n           ret.untouchableExtra \u003d\n                 Resources.subtractFrom(extra, childrensPreemptable);\n         }\n       }\n     }\n     addTempQueuePartition(ret);\n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private TempQueuePerPartition cloneQueues(CSQueue curQueue,\n      Resource partitionResource, String partitionToLookAt) {\n    TempQueuePerPartition ret;\n    synchronized (curQueue) {\n      String queueName \u003d curQueue.getQueueName();\n      QueueCapacities qc \u003d curQueue.getQueueCapacities();\n      float absCap \u003d qc.getAbsoluteCapacity(partitionToLookAt);\n      float absMaxCap \u003d qc.getAbsoluteMaximumCapacity(partitionToLookAt);\n      boolean preemptionDisabled \u003d curQueue.getPreemptionDisabled();\n\n      Resource current \u003d curQueue.getQueueResourceUsage().getUsed(\n          partitionToLookAt);\n      Resource guaranteed \u003d Resources.multiply(partitionResource, absCap);\n      Resource maxCapacity \u003d Resources.multiply(partitionResource, absMaxCap);\n\n      // when partition is a non-exclusive partition, the actual maxCapacity\n      // could more than specified maxCapacity\n      try {\n        if (!scheduler.getRMContext().getNodeLabelManager()\n            .isExclusiveNodeLabel(partitionToLookAt)) {\n          maxCapacity \u003d\n              Resources.max(rc, partitionResource, maxCapacity, current);\n        }\n      } catch (IOException e) {\n        // This may cause by partition removed when running capacity monitor,\n        // just ignore the error, this will be corrected when doing next check.\n      }\n\n      Resource extra \u003d Resource.newInstance(0, 0);\n      if (Resources.greaterThan(rc, partitionResource, current, guaranteed)) {\n        extra \u003d Resources.subtract(current, guaranteed);\n      }\n      if (curQueue instanceof LeafQueue) {\n        LeafQueue l \u003d (LeafQueue) curQueue;\n        Resource pending \u003d\n            l.getQueueResourceUsage().getPending(partitionToLookAt);\n        ret \u003d new TempQueuePerPartition(queueName, current, pending, guaranteed,\n            maxCapacity, preemptionDisabled, partitionToLookAt);\n        if (preemptionDisabled) {\n          ret.untouchableExtra \u003d extra;\n        } else {\n          ret.preemptableExtra \u003d extra;\n        }\n        ret.setLeafQueue(l);\n      } else {\n        Resource pending \u003d Resource.newInstance(0, 0);\n        ret \u003d\n            new TempQueuePerPartition(curQueue.getQueueName(), current, pending,\n                guaranteed, maxCapacity, false, partitionToLookAt);\n        Resource childrensPreemptable \u003d Resource.newInstance(0, 0);\n        for (CSQueue c : curQueue.getChildQueues()) {\n          TempQueuePerPartition subq \u003d\n              cloneQueues(c, partitionResource, partitionToLookAt);\n          Resources.addTo(childrensPreemptable, subq.preemptableExtra);\n          ret.addChild(subq);\n        }\n        // untouchableExtra \u003d max(extra - childrenPreemptable, 0)\n        if (Resources.greaterThanOrEqual(\n              rc, partitionResource, childrensPreemptable, extra)) {\n          ret.untouchableExtra \u003d Resource.newInstance(0, 0);\n        } else {\n          ret.untouchableExtra \u003d\n                Resources.subtractFrom(extra, childrensPreemptable);\n        }\n      }\n    }\n    addTempQueuePartition(ret);\n    return ret;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java",
      "extendedDetails": {}
    },
    "d497f6ea2be559aa31ed76f37ae949dbfabe2a51": {
      "type": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
      "commitMessage": "YARN-2498. Respect labels in preemption policy of capacity scheduler for inter-queue preemption. Contributed by Wangda Tan\n",
      "commitDate": "24/04/15 5:03 PM",
      "commitName": "d497f6ea2be559aa31ed76f37ae949dbfabe2a51",
      "commitAuthor": "Jian He",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-2498. Respect labels in preemption policy of capacity scheduler for inter-queue preemption. Contributed by Wangda Tan\n",
          "commitDate": "24/04/15 5:03 PM",
          "commitName": "d497f6ea2be559aa31ed76f37ae949dbfabe2a51",
          "commitAuthor": "Jian He",
          "commitDateOld": "20/04/15 5:12 PM",
          "commitNameOld": "44872b76fcc0ddfbc7b0a4e54eef50fe8708e0f5",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 3.99,
          "commitsBetweenForRepo": 60,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,50 +1,69 @@\n-  private TempQueue cloneQueues(CSQueue root, Resource clusterResources) {\n-    TempQueue ret;\n-    synchronized (root) {\n-      String queueName \u003d root.getQueueName();\n-      float absUsed \u003d root.getAbsoluteUsedCapacity();\n-      float absCap \u003d root.getAbsoluteCapacity();\n-      float absMaxCap \u003d root.getAbsoluteMaximumCapacity();\n-      boolean preemptionDisabled \u003d root.getPreemptionDisabled();\n+  private TempQueuePerPartition cloneQueues(CSQueue curQueue,\n+      Resource partitionResource, String partitionToLookAt) {\n+    TempQueuePerPartition ret;\n+    synchronized (curQueue) {\n+      String queueName \u003d curQueue.getQueueName();\n+      QueueCapacities qc \u003d curQueue.getQueueCapacities();\n+      float absUsed \u003d qc.getAbsoluteUsedCapacity(partitionToLookAt);\n+      float absCap \u003d qc.getAbsoluteCapacity(partitionToLookAt);\n+      float absMaxCap \u003d qc.getAbsoluteMaximumCapacity(partitionToLookAt);\n+      boolean preemptionDisabled \u003d curQueue.getPreemptionDisabled();\n \n-      Resource current \u003d Resources.multiply(clusterResources, absUsed);\n-      Resource guaranteed \u003d Resources.multiply(clusterResources, absCap);\n-      Resource maxCapacity \u003d Resources.multiply(clusterResources, absMaxCap);\n+      Resource current \u003d Resources.multiply(partitionResource, absUsed);\n+      Resource guaranteed \u003d Resources.multiply(partitionResource, absCap);\n+      Resource maxCapacity \u003d Resources.multiply(partitionResource, absMaxCap);\n+\n+      // when partition is a non-exclusive partition, the actual maxCapacity\n+      // could more than specified maxCapacity\n+      try {\n+        if (!scheduler.getRMContext().getNodeLabelManager()\n+            .isExclusiveNodeLabel(partitionToLookAt)) {\n+          maxCapacity \u003d\n+              Resources.max(rc, partitionResource, maxCapacity, current);\n+        }\n+      } catch (IOException e) {\n+        // This may cause by partition removed when running capacity monitor,\n+        // just ignore the error, this will be corrected when doing next check.\n+      }\n \n       Resource extra \u003d Resource.newInstance(0, 0);\n-      if (Resources.greaterThan(rc, clusterResources, current, guaranteed)) {\n+      if (Resources.greaterThan(rc, partitionResource, current, guaranteed)) {\n         extra \u003d Resources.subtract(current, guaranteed);\n       }\n-      if (root instanceof LeafQueue) {\n-        LeafQueue l \u003d (LeafQueue) root;\n-        Resource pending \u003d l.getTotalResourcePending();\n-        ret \u003d new TempQueue(queueName, current, pending, guaranteed,\n-            maxCapacity, preemptionDisabled);\n+      if (curQueue instanceof LeafQueue) {\n+        LeafQueue l \u003d (LeafQueue) curQueue;\n+        Resource pending \u003d\n+            l.getQueueResourceUsage().getPending(partitionToLookAt);\n+        ret \u003d new TempQueuePerPartition(queueName, current, pending, guaranteed,\n+            maxCapacity, preemptionDisabled, partitionToLookAt);\n         if (preemptionDisabled) {\n           ret.untouchableExtra \u003d extra;\n         } else {\n           ret.preemptableExtra \u003d extra;\n         }\n         ret.setLeafQueue(l);\n       } else {\n         Resource pending \u003d Resource.newInstance(0, 0);\n-        ret \u003d new TempQueue(root.getQueueName(), current, pending, guaranteed,\n-            maxCapacity, false);\n+        ret \u003d\n+            new TempQueuePerPartition(curQueue.getQueueName(), current, pending,\n+                guaranteed, maxCapacity, false, partitionToLookAt);\n         Resource childrensPreemptable \u003d Resource.newInstance(0, 0);\n-        for (CSQueue c : root.getChildQueues()) {\n-          TempQueue subq \u003d cloneQueues(c, clusterResources);\n+        for (CSQueue c : curQueue.getChildQueues()) {\n+          TempQueuePerPartition subq \u003d\n+              cloneQueues(c, partitionResource, partitionToLookAt);\n           Resources.addTo(childrensPreemptable, subq.preemptableExtra);\n           ret.addChild(subq);\n         }\n         // untouchableExtra \u003d max(extra - childrenPreemptable, 0)\n         if (Resources.greaterThanOrEqual(\n-              rc, clusterResources, childrensPreemptable, extra)) {\n+              rc, partitionResource, childrensPreemptable, extra)) {\n           ret.untouchableExtra \u003d Resource.newInstance(0, 0);\n         } else {\n           ret.untouchableExtra \u003d\n                 Resources.subtractFrom(extra, childrensPreemptable);\n         }\n       }\n     }\n+    addTempQueuePartition(ret);\n     return ret;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private TempQueuePerPartition cloneQueues(CSQueue curQueue,\n      Resource partitionResource, String partitionToLookAt) {\n    TempQueuePerPartition ret;\n    synchronized (curQueue) {\n      String queueName \u003d curQueue.getQueueName();\n      QueueCapacities qc \u003d curQueue.getQueueCapacities();\n      float absUsed \u003d qc.getAbsoluteUsedCapacity(partitionToLookAt);\n      float absCap \u003d qc.getAbsoluteCapacity(partitionToLookAt);\n      float absMaxCap \u003d qc.getAbsoluteMaximumCapacity(partitionToLookAt);\n      boolean preemptionDisabled \u003d curQueue.getPreemptionDisabled();\n\n      Resource current \u003d Resources.multiply(partitionResource, absUsed);\n      Resource guaranteed \u003d Resources.multiply(partitionResource, absCap);\n      Resource maxCapacity \u003d Resources.multiply(partitionResource, absMaxCap);\n\n      // when partition is a non-exclusive partition, the actual maxCapacity\n      // could more than specified maxCapacity\n      try {\n        if (!scheduler.getRMContext().getNodeLabelManager()\n            .isExclusiveNodeLabel(partitionToLookAt)) {\n          maxCapacity \u003d\n              Resources.max(rc, partitionResource, maxCapacity, current);\n        }\n      } catch (IOException e) {\n        // This may cause by partition removed when running capacity monitor,\n        // just ignore the error, this will be corrected when doing next check.\n      }\n\n      Resource extra \u003d Resource.newInstance(0, 0);\n      if (Resources.greaterThan(rc, partitionResource, current, guaranteed)) {\n        extra \u003d Resources.subtract(current, guaranteed);\n      }\n      if (curQueue instanceof LeafQueue) {\n        LeafQueue l \u003d (LeafQueue) curQueue;\n        Resource pending \u003d\n            l.getQueueResourceUsage().getPending(partitionToLookAt);\n        ret \u003d new TempQueuePerPartition(queueName, current, pending, guaranteed,\n            maxCapacity, preemptionDisabled, partitionToLookAt);\n        if (preemptionDisabled) {\n          ret.untouchableExtra \u003d extra;\n        } else {\n          ret.preemptableExtra \u003d extra;\n        }\n        ret.setLeafQueue(l);\n      } else {\n        Resource pending \u003d Resource.newInstance(0, 0);\n        ret \u003d\n            new TempQueuePerPartition(curQueue.getQueueName(), current, pending,\n                guaranteed, maxCapacity, false, partitionToLookAt);\n        Resource childrensPreemptable \u003d Resource.newInstance(0, 0);\n        for (CSQueue c : curQueue.getChildQueues()) {\n          TempQueuePerPartition subq \u003d\n              cloneQueues(c, partitionResource, partitionToLookAt);\n          Resources.addTo(childrensPreemptable, subq.preemptableExtra);\n          ret.addChild(subq);\n        }\n        // untouchableExtra \u003d max(extra - childrenPreemptable, 0)\n        if (Resources.greaterThanOrEqual(\n              rc, partitionResource, childrensPreemptable, extra)) {\n          ret.untouchableExtra \u003d Resource.newInstance(0, 0);\n        } else {\n          ret.untouchableExtra \u003d\n                Resources.subtractFrom(extra, childrensPreemptable);\n        }\n      }\n    }\n    addTempQueuePartition(ret);\n    return ret;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java",
          "extendedDetails": {
            "oldValue": "[root-CSQueue, clusterResources-Resource]",
            "newValue": "[curQueue-CSQueue, partitionResource-Resource, partitionToLookAt-String]"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "YARN-2498. Respect labels in preemption policy of capacity scheduler for inter-queue preemption. Contributed by Wangda Tan\n",
          "commitDate": "24/04/15 5:03 PM",
          "commitName": "d497f6ea2be559aa31ed76f37ae949dbfabe2a51",
          "commitAuthor": "Jian He",
          "commitDateOld": "20/04/15 5:12 PM",
          "commitNameOld": "44872b76fcc0ddfbc7b0a4e54eef50fe8708e0f5",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 3.99,
          "commitsBetweenForRepo": 60,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,50 +1,69 @@\n-  private TempQueue cloneQueues(CSQueue root, Resource clusterResources) {\n-    TempQueue ret;\n-    synchronized (root) {\n-      String queueName \u003d root.getQueueName();\n-      float absUsed \u003d root.getAbsoluteUsedCapacity();\n-      float absCap \u003d root.getAbsoluteCapacity();\n-      float absMaxCap \u003d root.getAbsoluteMaximumCapacity();\n-      boolean preemptionDisabled \u003d root.getPreemptionDisabled();\n+  private TempQueuePerPartition cloneQueues(CSQueue curQueue,\n+      Resource partitionResource, String partitionToLookAt) {\n+    TempQueuePerPartition ret;\n+    synchronized (curQueue) {\n+      String queueName \u003d curQueue.getQueueName();\n+      QueueCapacities qc \u003d curQueue.getQueueCapacities();\n+      float absUsed \u003d qc.getAbsoluteUsedCapacity(partitionToLookAt);\n+      float absCap \u003d qc.getAbsoluteCapacity(partitionToLookAt);\n+      float absMaxCap \u003d qc.getAbsoluteMaximumCapacity(partitionToLookAt);\n+      boolean preemptionDisabled \u003d curQueue.getPreemptionDisabled();\n \n-      Resource current \u003d Resources.multiply(clusterResources, absUsed);\n-      Resource guaranteed \u003d Resources.multiply(clusterResources, absCap);\n-      Resource maxCapacity \u003d Resources.multiply(clusterResources, absMaxCap);\n+      Resource current \u003d Resources.multiply(partitionResource, absUsed);\n+      Resource guaranteed \u003d Resources.multiply(partitionResource, absCap);\n+      Resource maxCapacity \u003d Resources.multiply(partitionResource, absMaxCap);\n+\n+      // when partition is a non-exclusive partition, the actual maxCapacity\n+      // could more than specified maxCapacity\n+      try {\n+        if (!scheduler.getRMContext().getNodeLabelManager()\n+            .isExclusiveNodeLabel(partitionToLookAt)) {\n+          maxCapacity \u003d\n+              Resources.max(rc, partitionResource, maxCapacity, current);\n+        }\n+      } catch (IOException e) {\n+        // This may cause by partition removed when running capacity monitor,\n+        // just ignore the error, this will be corrected when doing next check.\n+      }\n \n       Resource extra \u003d Resource.newInstance(0, 0);\n-      if (Resources.greaterThan(rc, clusterResources, current, guaranteed)) {\n+      if (Resources.greaterThan(rc, partitionResource, current, guaranteed)) {\n         extra \u003d Resources.subtract(current, guaranteed);\n       }\n-      if (root instanceof LeafQueue) {\n-        LeafQueue l \u003d (LeafQueue) root;\n-        Resource pending \u003d l.getTotalResourcePending();\n-        ret \u003d new TempQueue(queueName, current, pending, guaranteed,\n-            maxCapacity, preemptionDisabled);\n+      if (curQueue instanceof LeafQueue) {\n+        LeafQueue l \u003d (LeafQueue) curQueue;\n+        Resource pending \u003d\n+            l.getQueueResourceUsage().getPending(partitionToLookAt);\n+        ret \u003d new TempQueuePerPartition(queueName, current, pending, guaranteed,\n+            maxCapacity, preemptionDisabled, partitionToLookAt);\n         if (preemptionDisabled) {\n           ret.untouchableExtra \u003d extra;\n         } else {\n           ret.preemptableExtra \u003d extra;\n         }\n         ret.setLeafQueue(l);\n       } else {\n         Resource pending \u003d Resource.newInstance(0, 0);\n-        ret \u003d new TempQueue(root.getQueueName(), current, pending, guaranteed,\n-            maxCapacity, false);\n+        ret \u003d\n+            new TempQueuePerPartition(curQueue.getQueueName(), current, pending,\n+                guaranteed, maxCapacity, false, partitionToLookAt);\n         Resource childrensPreemptable \u003d Resource.newInstance(0, 0);\n-        for (CSQueue c : root.getChildQueues()) {\n-          TempQueue subq \u003d cloneQueues(c, clusterResources);\n+        for (CSQueue c : curQueue.getChildQueues()) {\n+          TempQueuePerPartition subq \u003d\n+              cloneQueues(c, partitionResource, partitionToLookAt);\n           Resources.addTo(childrensPreemptable, subq.preemptableExtra);\n           ret.addChild(subq);\n         }\n         // untouchableExtra \u003d max(extra - childrenPreemptable, 0)\n         if (Resources.greaterThanOrEqual(\n-              rc, clusterResources, childrensPreemptable, extra)) {\n+              rc, partitionResource, childrensPreemptable, extra)) {\n           ret.untouchableExtra \u003d Resource.newInstance(0, 0);\n         } else {\n           ret.untouchableExtra \u003d\n                 Resources.subtractFrom(extra, childrensPreemptable);\n         }\n       }\n     }\n+    addTempQueuePartition(ret);\n     return ret;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private TempQueuePerPartition cloneQueues(CSQueue curQueue,\n      Resource partitionResource, String partitionToLookAt) {\n    TempQueuePerPartition ret;\n    synchronized (curQueue) {\n      String queueName \u003d curQueue.getQueueName();\n      QueueCapacities qc \u003d curQueue.getQueueCapacities();\n      float absUsed \u003d qc.getAbsoluteUsedCapacity(partitionToLookAt);\n      float absCap \u003d qc.getAbsoluteCapacity(partitionToLookAt);\n      float absMaxCap \u003d qc.getAbsoluteMaximumCapacity(partitionToLookAt);\n      boolean preemptionDisabled \u003d curQueue.getPreemptionDisabled();\n\n      Resource current \u003d Resources.multiply(partitionResource, absUsed);\n      Resource guaranteed \u003d Resources.multiply(partitionResource, absCap);\n      Resource maxCapacity \u003d Resources.multiply(partitionResource, absMaxCap);\n\n      // when partition is a non-exclusive partition, the actual maxCapacity\n      // could more than specified maxCapacity\n      try {\n        if (!scheduler.getRMContext().getNodeLabelManager()\n            .isExclusiveNodeLabel(partitionToLookAt)) {\n          maxCapacity \u003d\n              Resources.max(rc, partitionResource, maxCapacity, current);\n        }\n      } catch (IOException e) {\n        // This may cause by partition removed when running capacity monitor,\n        // just ignore the error, this will be corrected when doing next check.\n      }\n\n      Resource extra \u003d Resource.newInstance(0, 0);\n      if (Resources.greaterThan(rc, partitionResource, current, guaranteed)) {\n        extra \u003d Resources.subtract(current, guaranteed);\n      }\n      if (curQueue instanceof LeafQueue) {\n        LeafQueue l \u003d (LeafQueue) curQueue;\n        Resource pending \u003d\n            l.getQueueResourceUsage().getPending(partitionToLookAt);\n        ret \u003d new TempQueuePerPartition(queueName, current, pending, guaranteed,\n            maxCapacity, preemptionDisabled, partitionToLookAt);\n        if (preemptionDisabled) {\n          ret.untouchableExtra \u003d extra;\n        } else {\n          ret.preemptableExtra \u003d extra;\n        }\n        ret.setLeafQueue(l);\n      } else {\n        Resource pending \u003d Resource.newInstance(0, 0);\n        ret \u003d\n            new TempQueuePerPartition(curQueue.getQueueName(), current, pending,\n                guaranteed, maxCapacity, false, partitionToLookAt);\n        Resource childrensPreemptable \u003d Resource.newInstance(0, 0);\n        for (CSQueue c : curQueue.getChildQueues()) {\n          TempQueuePerPartition subq \u003d\n              cloneQueues(c, partitionResource, partitionToLookAt);\n          Resources.addTo(childrensPreemptable, subq.preemptableExtra);\n          ret.addChild(subq);\n        }\n        // untouchableExtra \u003d max(extra - childrenPreemptable, 0)\n        if (Resources.greaterThanOrEqual(\n              rc, partitionResource, childrensPreemptable, extra)) {\n          ret.untouchableExtra \u003d Resource.newInstance(0, 0);\n        } else {\n          ret.untouchableExtra \u003d\n                Resources.subtractFrom(extra, childrensPreemptable);\n        }\n      }\n    }\n    addTempQueuePartition(ret);\n    return ret;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java",
          "extendedDetails": {
            "oldValue": "TempQueue",
            "newValue": "TempQueuePerPartition"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-2498. Respect labels in preemption policy of capacity scheduler for inter-queue preemption. Contributed by Wangda Tan\n",
          "commitDate": "24/04/15 5:03 PM",
          "commitName": "d497f6ea2be559aa31ed76f37ae949dbfabe2a51",
          "commitAuthor": "Jian He",
          "commitDateOld": "20/04/15 5:12 PM",
          "commitNameOld": "44872b76fcc0ddfbc7b0a4e54eef50fe8708e0f5",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 3.99,
          "commitsBetweenForRepo": 60,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,50 +1,69 @@\n-  private TempQueue cloneQueues(CSQueue root, Resource clusterResources) {\n-    TempQueue ret;\n-    synchronized (root) {\n-      String queueName \u003d root.getQueueName();\n-      float absUsed \u003d root.getAbsoluteUsedCapacity();\n-      float absCap \u003d root.getAbsoluteCapacity();\n-      float absMaxCap \u003d root.getAbsoluteMaximumCapacity();\n-      boolean preemptionDisabled \u003d root.getPreemptionDisabled();\n+  private TempQueuePerPartition cloneQueues(CSQueue curQueue,\n+      Resource partitionResource, String partitionToLookAt) {\n+    TempQueuePerPartition ret;\n+    synchronized (curQueue) {\n+      String queueName \u003d curQueue.getQueueName();\n+      QueueCapacities qc \u003d curQueue.getQueueCapacities();\n+      float absUsed \u003d qc.getAbsoluteUsedCapacity(partitionToLookAt);\n+      float absCap \u003d qc.getAbsoluteCapacity(partitionToLookAt);\n+      float absMaxCap \u003d qc.getAbsoluteMaximumCapacity(partitionToLookAt);\n+      boolean preemptionDisabled \u003d curQueue.getPreemptionDisabled();\n \n-      Resource current \u003d Resources.multiply(clusterResources, absUsed);\n-      Resource guaranteed \u003d Resources.multiply(clusterResources, absCap);\n-      Resource maxCapacity \u003d Resources.multiply(clusterResources, absMaxCap);\n+      Resource current \u003d Resources.multiply(partitionResource, absUsed);\n+      Resource guaranteed \u003d Resources.multiply(partitionResource, absCap);\n+      Resource maxCapacity \u003d Resources.multiply(partitionResource, absMaxCap);\n+\n+      // when partition is a non-exclusive partition, the actual maxCapacity\n+      // could more than specified maxCapacity\n+      try {\n+        if (!scheduler.getRMContext().getNodeLabelManager()\n+            .isExclusiveNodeLabel(partitionToLookAt)) {\n+          maxCapacity \u003d\n+              Resources.max(rc, partitionResource, maxCapacity, current);\n+        }\n+      } catch (IOException e) {\n+        // This may cause by partition removed when running capacity monitor,\n+        // just ignore the error, this will be corrected when doing next check.\n+      }\n \n       Resource extra \u003d Resource.newInstance(0, 0);\n-      if (Resources.greaterThan(rc, clusterResources, current, guaranteed)) {\n+      if (Resources.greaterThan(rc, partitionResource, current, guaranteed)) {\n         extra \u003d Resources.subtract(current, guaranteed);\n       }\n-      if (root instanceof LeafQueue) {\n-        LeafQueue l \u003d (LeafQueue) root;\n-        Resource pending \u003d l.getTotalResourcePending();\n-        ret \u003d new TempQueue(queueName, current, pending, guaranteed,\n-            maxCapacity, preemptionDisabled);\n+      if (curQueue instanceof LeafQueue) {\n+        LeafQueue l \u003d (LeafQueue) curQueue;\n+        Resource pending \u003d\n+            l.getQueueResourceUsage().getPending(partitionToLookAt);\n+        ret \u003d new TempQueuePerPartition(queueName, current, pending, guaranteed,\n+            maxCapacity, preemptionDisabled, partitionToLookAt);\n         if (preemptionDisabled) {\n           ret.untouchableExtra \u003d extra;\n         } else {\n           ret.preemptableExtra \u003d extra;\n         }\n         ret.setLeafQueue(l);\n       } else {\n         Resource pending \u003d Resource.newInstance(0, 0);\n-        ret \u003d new TempQueue(root.getQueueName(), current, pending, guaranteed,\n-            maxCapacity, false);\n+        ret \u003d\n+            new TempQueuePerPartition(curQueue.getQueueName(), current, pending,\n+                guaranteed, maxCapacity, false, partitionToLookAt);\n         Resource childrensPreemptable \u003d Resource.newInstance(0, 0);\n-        for (CSQueue c : root.getChildQueues()) {\n-          TempQueue subq \u003d cloneQueues(c, clusterResources);\n+        for (CSQueue c : curQueue.getChildQueues()) {\n+          TempQueuePerPartition subq \u003d\n+              cloneQueues(c, partitionResource, partitionToLookAt);\n           Resources.addTo(childrensPreemptable, subq.preemptableExtra);\n           ret.addChild(subq);\n         }\n         // untouchableExtra \u003d max(extra - childrenPreemptable, 0)\n         if (Resources.greaterThanOrEqual(\n-              rc, clusterResources, childrensPreemptable, extra)) {\n+              rc, partitionResource, childrensPreemptable, extra)) {\n           ret.untouchableExtra \u003d Resource.newInstance(0, 0);\n         } else {\n           ret.untouchableExtra \u003d\n                 Resources.subtractFrom(extra, childrensPreemptable);\n         }\n       }\n     }\n+    addTempQueuePartition(ret);\n     return ret;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private TempQueuePerPartition cloneQueues(CSQueue curQueue,\n      Resource partitionResource, String partitionToLookAt) {\n    TempQueuePerPartition ret;\n    synchronized (curQueue) {\n      String queueName \u003d curQueue.getQueueName();\n      QueueCapacities qc \u003d curQueue.getQueueCapacities();\n      float absUsed \u003d qc.getAbsoluteUsedCapacity(partitionToLookAt);\n      float absCap \u003d qc.getAbsoluteCapacity(partitionToLookAt);\n      float absMaxCap \u003d qc.getAbsoluteMaximumCapacity(partitionToLookAt);\n      boolean preemptionDisabled \u003d curQueue.getPreemptionDisabled();\n\n      Resource current \u003d Resources.multiply(partitionResource, absUsed);\n      Resource guaranteed \u003d Resources.multiply(partitionResource, absCap);\n      Resource maxCapacity \u003d Resources.multiply(partitionResource, absMaxCap);\n\n      // when partition is a non-exclusive partition, the actual maxCapacity\n      // could more than specified maxCapacity\n      try {\n        if (!scheduler.getRMContext().getNodeLabelManager()\n            .isExclusiveNodeLabel(partitionToLookAt)) {\n          maxCapacity \u003d\n              Resources.max(rc, partitionResource, maxCapacity, current);\n        }\n      } catch (IOException e) {\n        // This may cause by partition removed when running capacity monitor,\n        // just ignore the error, this will be corrected when doing next check.\n      }\n\n      Resource extra \u003d Resource.newInstance(0, 0);\n      if (Resources.greaterThan(rc, partitionResource, current, guaranteed)) {\n        extra \u003d Resources.subtract(current, guaranteed);\n      }\n      if (curQueue instanceof LeafQueue) {\n        LeafQueue l \u003d (LeafQueue) curQueue;\n        Resource pending \u003d\n            l.getQueueResourceUsage().getPending(partitionToLookAt);\n        ret \u003d new TempQueuePerPartition(queueName, current, pending, guaranteed,\n            maxCapacity, preemptionDisabled, partitionToLookAt);\n        if (preemptionDisabled) {\n          ret.untouchableExtra \u003d extra;\n        } else {\n          ret.preemptableExtra \u003d extra;\n        }\n        ret.setLeafQueue(l);\n      } else {\n        Resource pending \u003d Resource.newInstance(0, 0);\n        ret \u003d\n            new TempQueuePerPartition(curQueue.getQueueName(), current, pending,\n                guaranteed, maxCapacity, false, partitionToLookAt);\n        Resource childrensPreemptable \u003d Resource.newInstance(0, 0);\n        for (CSQueue c : curQueue.getChildQueues()) {\n          TempQueuePerPartition subq \u003d\n              cloneQueues(c, partitionResource, partitionToLookAt);\n          Resources.addTo(childrensPreemptable, subq.preemptableExtra);\n          ret.addChild(subq);\n        }\n        // untouchableExtra \u003d max(extra - childrenPreemptable, 0)\n        if (Resources.greaterThanOrEqual(\n              rc, partitionResource, childrensPreemptable, extra)) {\n          ret.untouchableExtra \u003d Resource.newInstance(0, 0);\n        } else {\n          ret.untouchableExtra \u003d\n                Resources.subtractFrom(extra, childrensPreemptable);\n        }\n      }\n    }\n    addTempQueuePartition(ret);\n    return ret;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java",
          "extendedDetails": {}
        }
      ]
    },
    "27e8ea820fab8dce59f4db9814e73bd60c1d4ef1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3275. CapacityScheduler: Preemption happening on non-preemptable queues. Contributed by Eric Payne\n",
      "commitDate": "06/03/15 2:37 PM",
      "commitName": "27e8ea820fab8dce59f4db9814e73bd60c1d4ef1",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "27/01/15 3:36 PM",
      "commitNameOld": "18741adf97f4fda5f8743318b59c440928e51297",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 37.96,
      "commitsBetweenForRepo": 378,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,49 +1,50 @@\n   private TempQueue cloneQueues(CSQueue root, Resource clusterResources) {\n     TempQueue ret;\n     synchronized (root) {\n       String queueName \u003d root.getQueueName();\n       float absUsed \u003d root.getAbsoluteUsedCapacity();\n       float absCap \u003d root.getAbsoluteCapacity();\n       float absMaxCap \u003d root.getAbsoluteMaximumCapacity();\n+      boolean preemptionDisabled \u003d root.getPreemptionDisabled();\n \n       Resource current \u003d Resources.multiply(clusterResources, absUsed);\n       Resource guaranteed \u003d Resources.multiply(clusterResources, absCap);\n       Resource maxCapacity \u003d Resources.multiply(clusterResources, absMaxCap);\n \n       Resource extra \u003d Resource.newInstance(0, 0);\n       if (Resources.greaterThan(rc, clusterResources, current, guaranteed)) {\n         extra \u003d Resources.subtract(current, guaranteed);\n       }\n       if (root instanceof LeafQueue) {\n         LeafQueue l \u003d (LeafQueue) root;\n         Resource pending \u003d l.getTotalResourcePending();\n         ret \u003d new TempQueue(queueName, current, pending, guaranteed,\n-            maxCapacity);\n-        if (root.getPreemptionDisabled()) {\n+            maxCapacity, preemptionDisabled);\n+        if (preemptionDisabled) {\n           ret.untouchableExtra \u003d extra;\n         } else {\n           ret.preemptableExtra \u003d extra;\n         }\n         ret.setLeafQueue(l);\n       } else {\n         Resource pending \u003d Resource.newInstance(0, 0);\n         ret \u003d new TempQueue(root.getQueueName(), current, pending, guaranteed,\n-            maxCapacity);\n+            maxCapacity, false);\n         Resource childrensPreemptable \u003d Resource.newInstance(0, 0);\n         for (CSQueue c : root.getChildQueues()) {\n           TempQueue subq \u003d cloneQueues(c, clusterResources);\n           Resources.addTo(childrensPreemptable, subq.preemptableExtra);\n           ret.addChild(subq);\n         }\n         // untouchableExtra \u003d max(extra - childrenPreemptable, 0)\n         if (Resources.greaterThanOrEqual(\n               rc, clusterResources, childrensPreemptable, extra)) {\n           ret.untouchableExtra \u003d Resource.newInstance(0, 0);\n         } else {\n           ret.untouchableExtra \u003d\n                 Resources.subtractFrom(extra, childrensPreemptable);\n         }\n       }\n     }\n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private TempQueue cloneQueues(CSQueue root, Resource clusterResources) {\n    TempQueue ret;\n    synchronized (root) {\n      String queueName \u003d root.getQueueName();\n      float absUsed \u003d root.getAbsoluteUsedCapacity();\n      float absCap \u003d root.getAbsoluteCapacity();\n      float absMaxCap \u003d root.getAbsoluteMaximumCapacity();\n      boolean preemptionDisabled \u003d root.getPreemptionDisabled();\n\n      Resource current \u003d Resources.multiply(clusterResources, absUsed);\n      Resource guaranteed \u003d Resources.multiply(clusterResources, absCap);\n      Resource maxCapacity \u003d Resources.multiply(clusterResources, absMaxCap);\n\n      Resource extra \u003d Resource.newInstance(0, 0);\n      if (Resources.greaterThan(rc, clusterResources, current, guaranteed)) {\n        extra \u003d Resources.subtract(current, guaranteed);\n      }\n      if (root instanceof LeafQueue) {\n        LeafQueue l \u003d (LeafQueue) root;\n        Resource pending \u003d l.getTotalResourcePending();\n        ret \u003d new TempQueue(queueName, current, pending, guaranteed,\n            maxCapacity, preemptionDisabled);\n        if (preemptionDisabled) {\n          ret.untouchableExtra \u003d extra;\n        } else {\n          ret.preemptableExtra \u003d extra;\n        }\n        ret.setLeafQueue(l);\n      } else {\n        Resource pending \u003d Resource.newInstance(0, 0);\n        ret \u003d new TempQueue(root.getQueueName(), current, pending, guaranteed,\n            maxCapacity, false);\n        Resource childrensPreemptable \u003d Resource.newInstance(0, 0);\n        for (CSQueue c : root.getChildQueues()) {\n          TempQueue subq \u003d cloneQueues(c, clusterResources);\n          Resources.addTo(childrensPreemptable, subq.preemptableExtra);\n          ret.addChild(subq);\n        }\n        // untouchableExtra \u003d max(extra - childrenPreemptable, 0)\n        if (Resources.greaterThanOrEqual(\n              rc, clusterResources, childrensPreemptable, extra)) {\n          ret.untouchableExtra \u003d Resource.newInstance(0, 0);\n        } else {\n          ret.untouchableExtra \u003d\n                Resources.subtractFrom(extra, childrensPreemptable);\n        }\n      }\n    }\n    return ret;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java",
      "extendedDetails": {}
    },
    "18741adf97f4fda5f8743318b59c440928e51297": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-2932. Add entry for preemptable status (enabled/disabled) to scheduler web UI and queue initialize/refresh logging. (Eric Payne via wangda)\n",
      "commitDate": "27/01/15 3:36 PM",
      "commitName": "18741adf97f4fda5f8743318b59c440928e51297",
      "commitAuthor": "Wangda Tan",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-2932. Add entry for preemptable status (enabled/disabled) to scheduler web UI and queue initialize/refresh logging. (Eric Payne via wangda)\n",
          "commitDate": "27/01/15 3:36 PM",
          "commitName": "18741adf97f4fda5f8743318b59c440928e51297",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "19/01/15 4:48 PM",
          "commitNameOld": "0a2d3e717d9c42090a32ff177991a222a1e34132",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 7.95,
          "commitsBetweenForRepo": 65,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,57 +1,49 @@\n-  private TempQueue cloneQueues(CSQueue root, Resource clusterResources,\n-      boolean parentDisablePreempt) {\n+  private TempQueue cloneQueues(CSQueue root, Resource clusterResources) {\n     TempQueue ret;\n     synchronized (root) {\n       String queueName \u003d root.getQueueName();\n       float absUsed \u003d root.getAbsoluteUsedCapacity();\n       float absCap \u003d root.getAbsoluteCapacity();\n       float absMaxCap \u003d root.getAbsoluteMaximumCapacity();\n \n       Resource current \u003d Resources.multiply(clusterResources, absUsed);\n       Resource guaranteed \u003d Resources.multiply(clusterResources, absCap);\n       Resource maxCapacity \u003d Resources.multiply(clusterResources, absMaxCap);\n \n-      boolean queueDisablePreemption \u003d false;\n-      String queuePropName \u003d BASE_YARN_RM_PREEMPTION + root.getQueuePath()\n-                               + SUFFIX_DISABLE_PREEMPTION;\n-      queueDisablePreemption \u003d scheduler.getConfiguration()\n-                              .getBoolean(queuePropName, parentDisablePreempt);\n-\n       Resource extra \u003d Resource.newInstance(0, 0);\n       if (Resources.greaterThan(rc, clusterResources, current, guaranteed)) {\n         extra \u003d Resources.subtract(current, guaranteed);\n       }\n       if (root instanceof LeafQueue) {\n         LeafQueue l \u003d (LeafQueue) root;\n         Resource pending \u003d l.getTotalResourcePending();\n         ret \u003d new TempQueue(queueName, current, pending, guaranteed,\n             maxCapacity);\n-        if (queueDisablePreemption) {\n+        if (root.getPreemptionDisabled()) {\n           ret.untouchableExtra \u003d extra;\n         } else {\n           ret.preemptableExtra \u003d extra;\n         }\n         ret.setLeafQueue(l);\n       } else {\n         Resource pending \u003d Resource.newInstance(0, 0);\n         ret \u003d new TempQueue(root.getQueueName(), current, pending, guaranteed,\n             maxCapacity);\n         Resource childrensPreemptable \u003d Resource.newInstance(0, 0);\n         for (CSQueue c : root.getChildQueues()) {\n-          TempQueue subq \u003d\n-                cloneQueues(c, clusterResources, queueDisablePreemption);\n+          TempQueue subq \u003d cloneQueues(c, clusterResources);\n           Resources.addTo(childrensPreemptable, subq.preemptableExtra);\n           ret.addChild(subq);\n         }\n         // untouchableExtra \u003d max(extra - childrenPreemptable, 0)\n         if (Resources.greaterThanOrEqual(\n               rc, clusterResources, childrensPreemptable, extra)) {\n           ret.untouchableExtra \u003d Resource.newInstance(0, 0);\n         } else {\n           ret.untouchableExtra \u003d\n                 Resources.subtractFrom(extra, childrensPreemptable);\n         }\n       }\n     }\n     return ret;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private TempQueue cloneQueues(CSQueue root, Resource clusterResources) {\n    TempQueue ret;\n    synchronized (root) {\n      String queueName \u003d root.getQueueName();\n      float absUsed \u003d root.getAbsoluteUsedCapacity();\n      float absCap \u003d root.getAbsoluteCapacity();\n      float absMaxCap \u003d root.getAbsoluteMaximumCapacity();\n\n      Resource current \u003d Resources.multiply(clusterResources, absUsed);\n      Resource guaranteed \u003d Resources.multiply(clusterResources, absCap);\n      Resource maxCapacity \u003d Resources.multiply(clusterResources, absMaxCap);\n\n      Resource extra \u003d Resource.newInstance(0, 0);\n      if (Resources.greaterThan(rc, clusterResources, current, guaranteed)) {\n        extra \u003d Resources.subtract(current, guaranteed);\n      }\n      if (root instanceof LeafQueue) {\n        LeafQueue l \u003d (LeafQueue) root;\n        Resource pending \u003d l.getTotalResourcePending();\n        ret \u003d new TempQueue(queueName, current, pending, guaranteed,\n            maxCapacity);\n        if (root.getPreemptionDisabled()) {\n          ret.untouchableExtra \u003d extra;\n        } else {\n          ret.preemptableExtra \u003d extra;\n        }\n        ret.setLeafQueue(l);\n      } else {\n        Resource pending \u003d Resource.newInstance(0, 0);\n        ret \u003d new TempQueue(root.getQueueName(), current, pending, guaranteed,\n            maxCapacity);\n        Resource childrensPreemptable \u003d Resource.newInstance(0, 0);\n        for (CSQueue c : root.getChildQueues()) {\n          TempQueue subq \u003d cloneQueues(c, clusterResources);\n          Resources.addTo(childrensPreemptable, subq.preemptableExtra);\n          ret.addChild(subq);\n        }\n        // untouchableExtra \u003d max(extra - childrenPreemptable, 0)\n        if (Resources.greaterThanOrEqual(\n              rc, clusterResources, childrensPreemptable, extra)) {\n          ret.untouchableExtra \u003d Resource.newInstance(0, 0);\n        } else {\n          ret.untouchableExtra \u003d\n                Resources.subtractFrom(extra, childrensPreemptable);\n        }\n      }\n    }\n    return ret;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java",
          "extendedDetails": {
            "oldValue": "[root-CSQueue, clusterResources-Resource, parentDisablePreempt-boolean]",
            "newValue": "[root-CSQueue, clusterResources-Resource]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-2932. Add entry for preemptable status (enabled/disabled) to scheduler web UI and queue initialize/refresh logging. (Eric Payne via wangda)\n",
          "commitDate": "27/01/15 3:36 PM",
          "commitName": "18741adf97f4fda5f8743318b59c440928e51297",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "19/01/15 4:48 PM",
          "commitNameOld": "0a2d3e717d9c42090a32ff177991a222a1e34132",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 7.95,
          "commitsBetweenForRepo": 65,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,57 +1,49 @@\n-  private TempQueue cloneQueues(CSQueue root, Resource clusterResources,\n-      boolean parentDisablePreempt) {\n+  private TempQueue cloneQueues(CSQueue root, Resource clusterResources) {\n     TempQueue ret;\n     synchronized (root) {\n       String queueName \u003d root.getQueueName();\n       float absUsed \u003d root.getAbsoluteUsedCapacity();\n       float absCap \u003d root.getAbsoluteCapacity();\n       float absMaxCap \u003d root.getAbsoluteMaximumCapacity();\n \n       Resource current \u003d Resources.multiply(clusterResources, absUsed);\n       Resource guaranteed \u003d Resources.multiply(clusterResources, absCap);\n       Resource maxCapacity \u003d Resources.multiply(clusterResources, absMaxCap);\n \n-      boolean queueDisablePreemption \u003d false;\n-      String queuePropName \u003d BASE_YARN_RM_PREEMPTION + root.getQueuePath()\n-                               + SUFFIX_DISABLE_PREEMPTION;\n-      queueDisablePreemption \u003d scheduler.getConfiguration()\n-                              .getBoolean(queuePropName, parentDisablePreempt);\n-\n       Resource extra \u003d Resource.newInstance(0, 0);\n       if (Resources.greaterThan(rc, clusterResources, current, guaranteed)) {\n         extra \u003d Resources.subtract(current, guaranteed);\n       }\n       if (root instanceof LeafQueue) {\n         LeafQueue l \u003d (LeafQueue) root;\n         Resource pending \u003d l.getTotalResourcePending();\n         ret \u003d new TempQueue(queueName, current, pending, guaranteed,\n             maxCapacity);\n-        if (queueDisablePreemption) {\n+        if (root.getPreemptionDisabled()) {\n           ret.untouchableExtra \u003d extra;\n         } else {\n           ret.preemptableExtra \u003d extra;\n         }\n         ret.setLeafQueue(l);\n       } else {\n         Resource pending \u003d Resource.newInstance(0, 0);\n         ret \u003d new TempQueue(root.getQueueName(), current, pending, guaranteed,\n             maxCapacity);\n         Resource childrensPreemptable \u003d Resource.newInstance(0, 0);\n         for (CSQueue c : root.getChildQueues()) {\n-          TempQueue subq \u003d\n-                cloneQueues(c, clusterResources, queueDisablePreemption);\n+          TempQueue subq \u003d cloneQueues(c, clusterResources);\n           Resources.addTo(childrensPreemptable, subq.preemptableExtra);\n           ret.addChild(subq);\n         }\n         // untouchableExtra \u003d max(extra - childrenPreemptable, 0)\n         if (Resources.greaterThanOrEqual(\n               rc, clusterResources, childrensPreemptable, extra)) {\n           ret.untouchableExtra \u003d Resource.newInstance(0, 0);\n         } else {\n           ret.untouchableExtra \u003d\n                 Resources.subtractFrom(extra, childrensPreemptable);\n         }\n       }\n     }\n     return ret;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private TempQueue cloneQueues(CSQueue root, Resource clusterResources) {\n    TempQueue ret;\n    synchronized (root) {\n      String queueName \u003d root.getQueueName();\n      float absUsed \u003d root.getAbsoluteUsedCapacity();\n      float absCap \u003d root.getAbsoluteCapacity();\n      float absMaxCap \u003d root.getAbsoluteMaximumCapacity();\n\n      Resource current \u003d Resources.multiply(clusterResources, absUsed);\n      Resource guaranteed \u003d Resources.multiply(clusterResources, absCap);\n      Resource maxCapacity \u003d Resources.multiply(clusterResources, absMaxCap);\n\n      Resource extra \u003d Resource.newInstance(0, 0);\n      if (Resources.greaterThan(rc, clusterResources, current, guaranteed)) {\n        extra \u003d Resources.subtract(current, guaranteed);\n      }\n      if (root instanceof LeafQueue) {\n        LeafQueue l \u003d (LeafQueue) root;\n        Resource pending \u003d l.getTotalResourcePending();\n        ret \u003d new TempQueue(queueName, current, pending, guaranteed,\n            maxCapacity);\n        if (root.getPreemptionDisabled()) {\n          ret.untouchableExtra \u003d extra;\n        } else {\n          ret.preemptableExtra \u003d extra;\n        }\n        ret.setLeafQueue(l);\n      } else {\n        Resource pending \u003d Resource.newInstance(0, 0);\n        ret \u003d new TempQueue(root.getQueueName(), current, pending, guaranteed,\n            maxCapacity);\n        Resource childrensPreemptable \u003d Resource.newInstance(0, 0);\n        for (CSQueue c : root.getChildQueues()) {\n          TempQueue subq \u003d cloneQueues(c, clusterResources);\n          Resources.addTo(childrensPreemptable, subq.preemptableExtra);\n          ret.addChild(subq);\n        }\n        // untouchableExtra \u003d max(extra - childrenPreemptable, 0)\n        if (Resources.greaterThanOrEqual(\n              rc, clusterResources, childrensPreemptable, extra)) {\n          ret.untouchableExtra \u003d Resource.newInstance(0, 0);\n        } else {\n          ret.untouchableExtra \u003d\n                Resources.subtractFrom(extra, childrensPreemptable);\n        }\n      }\n    }\n    return ret;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java",
          "extendedDetails": {}
        }
      ]
    },
    "4b130821995a3cfe20c71e38e0f63294085c0491": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-2056. Disable preemption at Queue level. Contributed by Eric Payne\n",
      "commitDate": "05/12/14 1:06 PM",
      "commitName": "4b130821995a3cfe20c71e38e0f63294085c0491",
      "commitAuthor": "Jason Lowe",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-2056. Disable preemption at Queue level. Contributed by Eric Payne\n",
          "commitDate": "05/12/14 1:06 PM",
          "commitName": "4b130821995a3cfe20c71e38e0f63294085c0491",
          "commitAuthor": "Jason Lowe",
          "commitDateOld": "12/09/14 10:33 AM",
          "commitNameOld": "3122daa80261b466e309e88d88d1e2c030525e3f",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 84.15,
          "commitsBetweenForRepo": 775,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,29 +1,57 @@\n-  private TempQueue cloneQueues(CSQueue root, Resource clusterResources) {\n+  private TempQueue cloneQueues(CSQueue root, Resource clusterResources,\n+      boolean parentDisablePreempt) {\n     TempQueue ret;\n     synchronized (root) {\n       String queueName \u003d root.getQueueName();\n       float absUsed \u003d root.getAbsoluteUsedCapacity();\n       float absCap \u003d root.getAbsoluteCapacity();\n       float absMaxCap \u003d root.getAbsoluteMaximumCapacity();\n \n       Resource current \u003d Resources.multiply(clusterResources, absUsed);\n       Resource guaranteed \u003d Resources.multiply(clusterResources, absCap);\n       Resource maxCapacity \u003d Resources.multiply(clusterResources, absMaxCap);\n+\n+      boolean queueDisablePreemption \u003d false;\n+      String queuePropName \u003d BASE_YARN_RM_PREEMPTION + root.getQueuePath()\n+                               + SUFFIX_DISABLE_PREEMPTION;\n+      queueDisablePreemption \u003d scheduler.getConfiguration()\n+                              .getBoolean(queuePropName, parentDisablePreempt);\n+\n+      Resource extra \u003d Resource.newInstance(0, 0);\n+      if (Resources.greaterThan(rc, clusterResources, current, guaranteed)) {\n+        extra \u003d Resources.subtract(current, guaranteed);\n+      }\n       if (root instanceof LeafQueue) {\n         LeafQueue l \u003d (LeafQueue) root;\n         Resource pending \u003d l.getTotalResourcePending();\n         ret \u003d new TempQueue(queueName, current, pending, guaranteed,\n             maxCapacity);\n-\n+        if (queueDisablePreemption) {\n+          ret.untouchableExtra \u003d extra;\n+        } else {\n+          ret.preemptableExtra \u003d extra;\n+        }\n         ret.setLeafQueue(l);\n       } else {\n         Resource pending \u003d Resource.newInstance(0, 0);\n         ret \u003d new TempQueue(root.getQueueName(), current, pending, guaranteed,\n             maxCapacity);\n+        Resource childrensPreemptable \u003d Resource.newInstance(0, 0);\n         for (CSQueue c : root.getChildQueues()) {\n-          ret.addChild(cloneQueues(c, clusterResources));\n+          TempQueue subq \u003d\n+                cloneQueues(c, clusterResources, queueDisablePreemption);\n+          Resources.addTo(childrensPreemptable, subq.preemptableExtra);\n+          ret.addChild(subq);\n+        }\n+        // untouchableExtra \u003d max(extra - childrenPreemptable, 0)\n+        if (Resources.greaterThanOrEqual(\n+              rc, clusterResources, childrensPreemptable, extra)) {\n+          ret.untouchableExtra \u003d Resource.newInstance(0, 0);\n+        } else {\n+          ret.untouchableExtra \u003d\n+                Resources.subtractFrom(extra, childrensPreemptable);\n         }\n       }\n     }\n     return ret;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private TempQueue cloneQueues(CSQueue root, Resource clusterResources,\n      boolean parentDisablePreempt) {\n    TempQueue ret;\n    synchronized (root) {\n      String queueName \u003d root.getQueueName();\n      float absUsed \u003d root.getAbsoluteUsedCapacity();\n      float absCap \u003d root.getAbsoluteCapacity();\n      float absMaxCap \u003d root.getAbsoluteMaximumCapacity();\n\n      Resource current \u003d Resources.multiply(clusterResources, absUsed);\n      Resource guaranteed \u003d Resources.multiply(clusterResources, absCap);\n      Resource maxCapacity \u003d Resources.multiply(clusterResources, absMaxCap);\n\n      boolean queueDisablePreemption \u003d false;\n      String queuePropName \u003d BASE_YARN_RM_PREEMPTION + root.getQueuePath()\n                               + SUFFIX_DISABLE_PREEMPTION;\n      queueDisablePreemption \u003d scheduler.getConfiguration()\n                              .getBoolean(queuePropName, parentDisablePreempt);\n\n      Resource extra \u003d Resource.newInstance(0, 0);\n      if (Resources.greaterThan(rc, clusterResources, current, guaranteed)) {\n        extra \u003d Resources.subtract(current, guaranteed);\n      }\n      if (root instanceof LeafQueue) {\n        LeafQueue l \u003d (LeafQueue) root;\n        Resource pending \u003d l.getTotalResourcePending();\n        ret \u003d new TempQueue(queueName, current, pending, guaranteed,\n            maxCapacity);\n        if (queueDisablePreemption) {\n          ret.untouchableExtra \u003d extra;\n        } else {\n          ret.preemptableExtra \u003d extra;\n        }\n        ret.setLeafQueue(l);\n      } else {\n        Resource pending \u003d Resource.newInstance(0, 0);\n        ret \u003d new TempQueue(root.getQueueName(), current, pending, guaranteed,\n            maxCapacity);\n        Resource childrensPreemptable \u003d Resource.newInstance(0, 0);\n        for (CSQueue c : root.getChildQueues()) {\n          TempQueue subq \u003d\n                cloneQueues(c, clusterResources, queueDisablePreemption);\n          Resources.addTo(childrensPreemptable, subq.preemptableExtra);\n          ret.addChild(subq);\n        }\n        // untouchableExtra \u003d max(extra - childrenPreemptable, 0)\n        if (Resources.greaterThanOrEqual(\n              rc, clusterResources, childrensPreemptable, extra)) {\n          ret.untouchableExtra \u003d Resource.newInstance(0, 0);\n        } else {\n          ret.untouchableExtra \u003d\n                Resources.subtractFrom(extra, childrensPreemptable);\n        }\n      }\n    }\n    return ret;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java",
          "extendedDetails": {
            "oldValue": "[root-CSQueue, clusterResources-Resource]",
            "newValue": "[root-CSQueue, clusterResources-Resource, parentDisablePreempt-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-2056. Disable preemption at Queue level. Contributed by Eric Payne\n",
          "commitDate": "05/12/14 1:06 PM",
          "commitName": "4b130821995a3cfe20c71e38e0f63294085c0491",
          "commitAuthor": "Jason Lowe",
          "commitDateOld": "12/09/14 10:33 AM",
          "commitNameOld": "3122daa80261b466e309e88d88d1e2c030525e3f",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 84.15,
          "commitsBetweenForRepo": 775,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,29 +1,57 @@\n-  private TempQueue cloneQueues(CSQueue root, Resource clusterResources) {\n+  private TempQueue cloneQueues(CSQueue root, Resource clusterResources,\n+      boolean parentDisablePreempt) {\n     TempQueue ret;\n     synchronized (root) {\n       String queueName \u003d root.getQueueName();\n       float absUsed \u003d root.getAbsoluteUsedCapacity();\n       float absCap \u003d root.getAbsoluteCapacity();\n       float absMaxCap \u003d root.getAbsoluteMaximumCapacity();\n \n       Resource current \u003d Resources.multiply(clusterResources, absUsed);\n       Resource guaranteed \u003d Resources.multiply(clusterResources, absCap);\n       Resource maxCapacity \u003d Resources.multiply(clusterResources, absMaxCap);\n+\n+      boolean queueDisablePreemption \u003d false;\n+      String queuePropName \u003d BASE_YARN_RM_PREEMPTION + root.getQueuePath()\n+                               + SUFFIX_DISABLE_PREEMPTION;\n+      queueDisablePreemption \u003d scheduler.getConfiguration()\n+                              .getBoolean(queuePropName, parentDisablePreempt);\n+\n+      Resource extra \u003d Resource.newInstance(0, 0);\n+      if (Resources.greaterThan(rc, clusterResources, current, guaranteed)) {\n+        extra \u003d Resources.subtract(current, guaranteed);\n+      }\n       if (root instanceof LeafQueue) {\n         LeafQueue l \u003d (LeafQueue) root;\n         Resource pending \u003d l.getTotalResourcePending();\n         ret \u003d new TempQueue(queueName, current, pending, guaranteed,\n             maxCapacity);\n-\n+        if (queueDisablePreemption) {\n+          ret.untouchableExtra \u003d extra;\n+        } else {\n+          ret.preemptableExtra \u003d extra;\n+        }\n         ret.setLeafQueue(l);\n       } else {\n         Resource pending \u003d Resource.newInstance(0, 0);\n         ret \u003d new TempQueue(root.getQueueName(), current, pending, guaranteed,\n             maxCapacity);\n+        Resource childrensPreemptable \u003d Resource.newInstance(0, 0);\n         for (CSQueue c : root.getChildQueues()) {\n-          ret.addChild(cloneQueues(c, clusterResources));\n+          TempQueue subq \u003d\n+                cloneQueues(c, clusterResources, queueDisablePreemption);\n+          Resources.addTo(childrensPreemptable, subq.preemptableExtra);\n+          ret.addChild(subq);\n+        }\n+        // untouchableExtra \u003d max(extra - childrenPreemptable, 0)\n+        if (Resources.greaterThanOrEqual(\n+              rc, clusterResources, childrensPreemptable, extra)) {\n+          ret.untouchableExtra \u003d Resource.newInstance(0, 0);\n+        } else {\n+          ret.untouchableExtra \u003d\n+                Resources.subtractFrom(extra, childrensPreemptable);\n         }\n       }\n     }\n     return ret;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private TempQueue cloneQueues(CSQueue root, Resource clusterResources,\n      boolean parentDisablePreempt) {\n    TempQueue ret;\n    synchronized (root) {\n      String queueName \u003d root.getQueueName();\n      float absUsed \u003d root.getAbsoluteUsedCapacity();\n      float absCap \u003d root.getAbsoluteCapacity();\n      float absMaxCap \u003d root.getAbsoluteMaximumCapacity();\n\n      Resource current \u003d Resources.multiply(clusterResources, absUsed);\n      Resource guaranteed \u003d Resources.multiply(clusterResources, absCap);\n      Resource maxCapacity \u003d Resources.multiply(clusterResources, absMaxCap);\n\n      boolean queueDisablePreemption \u003d false;\n      String queuePropName \u003d BASE_YARN_RM_PREEMPTION + root.getQueuePath()\n                               + SUFFIX_DISABLE_PREEMPTION;\n      queueDisablePreemption \u003d scheduler.getConfiguration()\n                              .getBoolean(queuePropName, parentDisablePreempt);\n\n      Resource extra \u003d Resource.newInstance(0, 0);\n      if (Resources.greaterThan(rc, clusterResources, current, guaranteed)) {\n        extra \u003d Resources.subtract(current, guaranteed);\n      }\n      if (root instanceof LeafQueue) {\n        LeafQueue l \u003d (LeafQueue) root;\n        Resource pending \u003d l.getTotalResourcePending();\n        ret \u003d new TempQueue(queueName, current, pending, guaranteed,\n            maxCapacity);\n        if (queueDisablePreemption) {\n          ret.untouchableExtra \u003d extra;\n        } else {\n          ret.preemptableExtra \u003d extra;\n        }\n        ret.setLeafQueue(l);\n      } else {\n        Resource pending \u003d Resource.newInstance(0, 0);\n        ret \u003d new TempQueue(root.getQueueName(), current, pending, guaranteed,\n            maxCapacity);\n        Resource childrensPreemptable \u003d Resource.newInstance(0, 0);\n        for (CSQueue c : root.getChildQueues()) {\n          TempQueue subq \u003d\n                cloneQueues(c, clusterResources, queueDisablePreemption);\n          Resources.addTo(childrensPreemptable, subq.preemptableExtra);\n          ret.addChild(subq);\n        }\n        // untouchableExtra \u003d max(extra - childrenPreemptable, 0)\n        if (Resources.greaterThanOrEqual(\n              rc, clusterResources, childrensPreemptable, extra)) {\n          ret.untouchableExtra \u003d Resource.newInstance(0, 0);\n        } else {\n          ret.untouchableExtra \u003d\n                Resources.subtractFrom(extra, childrensPreemptable);\n        }\n      }\n    }\n    return ret;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java",
          "extendedDetails": {}
        }
      ]
    },
    "45b42676f9333ed4fa05355ccb4e1f91a9556525": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1957. Consider the max capacity of the queue when computing the ideal\ncapacity for preemption. Contributed by Carlo Curino\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1594414 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "13/05/14 4:15 PM",
      "commitName": "45b42676f9333ed4fa05355ccb4e1f91a9556525",
      "commitAuthor": "Christopher Douglas",
      "commitDateOld": "10/07/13 6:20 PM",
      "commitNameOld": "85f0efb68f9d1d9ee3466e3939c4fc2f985ccf61",
      "commitAuthorOld": "Christopher Douglas",
      "daysBetweenCommits": 306.91,
      "commitsBetweenForRepo": 2071,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,22 +1,29 @@\n   private TempQueue cloneQueues(CSQueue root, Resource clusterResources) {\n     TempQueue ret;\n     synchronized (root) {\n-    float absUsed \u003d root.getAbsoluteUsedCapacity();\n+      String queueName \u003d root.getQueueName();\n+      float absUsed \u003d root.getAbsoluteUsedCapacity();\n+      float absCap \u003d root.getAbsoluteCapacity();\n+      float absMaxCap \u003d root.getAbsoluteMaximumCapacity();\n+\n       Resource current \u003d Resources.multiply(clusterResources, absUsed);\n-      Resource guaranteed \u003d\n-        Resources.multiply(clusterResources, root.getAbsoluteCapacity());\n+      Resource guaranteed \u003d Resources.multiply(clusterResources, absCap);\n+      Resource maxCapacity \u003d Resources.multiply(clusterResources, absMaxCap);\n       if (root instanceof LeafQueue) {\n         LeafQueue l \u003d (LeafQueue) root;\n         Resource pending \u003d l.getTotalResourcePending();\n-        ret \u003d new TempQueue(root.getQueueName(), current, pending, guaranteed);\n+        ret \u003d new TempQueue(queueName, current, pending, guaranteed,\n+            maxCapacity);\n+\n         ret.setLeafQueue(l);\n       } else {\n         Resource pending \u003d Resource.newInstance(0, 0);\n-        ret \u003d new TempQueue(root.getQueueName(), current, pending, guaranteed);\n+        ret \u003d new TempQueue(root.getQueueName(), current, pending, guaranteed,\n+            maxCapacity);\n         for (CSQueue c : root.getChildQueues()) {\n           ret.addChild(cloneQueues(c, clusterResources));\n         }\n       }\n     }\n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private TempQueue cloneQueues(CSQueue root, Resource clusterResources) {\n    TempQueue ret;\n    synchronized (root) {\n      String queueName \u003d root.getQueueName();\n      float absUsed \u003d root.getAbsoluteUsedCapacity();\n      float absCap \u003d root.getAbsoluteCapacity();\n      float absMaxCap \u003d root.getAbsoluteMaximumCapacity();\n\n      Resource current \u003d Resources.multiply(clusterResources, absUsed);\n      Resource guaranteed \u003d Resources.multiply(clusterResources, absCap);\n      Resource maxCapacity \u003d Resources.multiply(clusterResources, absMaxCap);\n      if (root instanceof LeafQueue) {\n        LeafQueue l \u003d (LeafQueue) root;\n        Resource pending \u003d l.getTotalResourcePending();\n        ret \u003d new TempQueue(queueName, current, pending, guaranteed,\n            maxCapacity);\n\n        ret.setLeafQueue(l);\n      } else {\n        Resource pending \u003d Resource.newInstance(0, 0);\n        ret \u003d new TempQueue(root.getQueueName(), current, pending, guaranteed,\n            maxCapacity);\n        for (CSQueue c : root.getChildQueues()) {\n          ret.addChild(cloneQueues(c, clusterResources));\n        }\n      }\n    }\n    return ret;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java",
      "extendedDetails": {}
    },
    "85f0efb68f9d1d9ee3466e3939c4fc2f985ccf61": {
      "type": "Yintroduced",
      "commitMessage": "YARN-569. Add support for requesting and enforcing preemption requests via\na capacity monitor. Contributed by Carlo Curino, Chris Douglas\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1502083 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/07/13 6:20 PM",
      "commitName": "85f0efb68f9d1d9ee3466e3939c4fc2f985ccf61",
      "commitAuthor": "Christopher Douglas",
      "diff": "@@ -0,0 +1,22 @@\n+  private TempQueue cloneQueues(CSQueue root, Resource clusterResources) {\n+    TempQueue ret;\n+    synchronized (root) {\n+    float absUsed \u003d root.getAbsoluteUsedCapacity();\n+      Resource current \u003d Resources.multiply(clusterResources, absUsed);\n+      Resource guaranteed \u003d\n+        Resources.multiply(clusterResources, root.getAbsoluteCapacity());\n+      if (root instanceof LeafQueue) {\n+        LeafQueue l \u003d (LeafQueue) root;\n+        Resource pending \u003d l.getTotalResourcePending();\n+        ret \u003d new TempQueue(root.getQueueName(), current, pending, guaranteed);\n+        ret.setLeafQueue(l);\n+      } else {\n+        Resource pending \u003d Resource.newInstance(0, 0);\n+        ret \u003d new TempQueue(root.getQueueName(), current, pending, guaranteed);\n+        for (CSQueue c : root.getChildQueues()) {\n+          ret.addChild(cloneQueues(c, clusterResources));\n+        }\n+      }\n+    }\n+    return ret;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private TempQueue cloneQueues(CSQueue root, Resource clusterResources) {\n    TempQueue ret;\n    synchronized (root) {\n    float absUsed \u003d root.getAbsoluteUsedCapacity();\n      Resource current \u003d Resources.multiply(clusterResources, absUsed);\n      Resource guaranteed \u003d\n        Resources.multiply(clusterResources, root.getAbsoluteCapacity());\n      if (root instanceof LeafQueue) {\n        LeafQueue l \u003d (LeafQueue) root;\n        Resource pending \u003d l.getTotalResourcePending();\n        ret \u003d new TempQueue(root.getQueueName(), current, pending, guaranteed);\n        ret.setLeafQueue(l);\n      } else {\n        Resource pending \u003d Resource.newInstance(0, 0);\n        ret \u003d new TempQueue(root.getQueueName(), current, pending, guaranteed);\n        for (CSQueue c : root.getChildQueues()) {\n          ret.addChild(cloneQueues(c, clusterResources));\n        }\n      }\n    }\n    return ret;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java"
    }
  }
}