{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FileUtil.java",
  "functionName": "createJarWithClassPath",
  "functionId": "createJarWithClassPath___inputClassPath-String__pwd-Path__targetDir-Path__callerEnv-Map__String,String__",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/FileUtil.java",
  "functionStartLine": 1474,
  "functionEndLine": 1559,
  "numCommitsSeen": 87,
  "timeTaken": 5307,
  "changeHistory": [
    "7a3188d054481b9bd563e337901e93476303ce7f",
    "fb8932a727f757b2e9c1c61a18145878d0eb77bd",
    "f8af0e2feb9f45aeaa9711dbf93115ffb1a07e5d",
    "ccaf036662e22da14583942054898c99fa51dae5",
    "0ad48aa2c8f41196743305c711ea19cc48f186da",
    "3b12fd6cfbf4cc91ef8e8616c7aafa9de006cde5",
    "6637e3cf95b3a9be8d6b9cd66bc849a0607e8ed5",
    "40cf0068d8aae2c50c90e0661aaa1170a4c03e42",
    "b87bcbb82dac4f0a0ca7e436998ed0a3d1b4bb21",
    "7c666454170599dc3d901c8b15ac95bca3a3a829",
    "638801cce16fc1dc3259c541dc30a599faaddda1"
  ],
  "changeHistoryShort": {
    "7a3188d054481b9bd563e337901e93476303ce7f": "Ybodychange",
    "fb8932a727f757b2e9c1c61a18145878d0eb77bd": "Ybodychange",
    "f8af0e2feb9f45aeaa9711dbf93115ffb1a07e5d": "Ybodychange",
    "ccaf036662e22da14583942054898c99fa51dae5": "Ybodychange",
    "0ad48aa2c8f41196743305c711ea19cc48f186da": "Ybodychange",
    "3b12fd6cfbf4cc91ef8e8616c7aafa9de006cde5": "Ymultichange(Yparameterchange,Ybodychange)",
    "6637e3cf95b3a9be8d6b9cd66bc849a0607e8ed5": "Ymultichange(Yreturntypechange,Ybodychange)",
    "40cf0068d8aae2c50c90e0661aaa1170a4c03e42": "Ybodychange",
    "b87bcbb82dac4f0a0ca7e436998ed0a3d1b4bb21": "Ybodychange",
    "7c666454170599dc3d901c8b15ac95bca3a3a829": "Ymultichange(Yparameterchange,Ybodychange)",
    "638801cce16fc1dc3259c541dc30a599faaddda1": "Yintroduced"
  },
  "changeHistoryDetails": {
    "7a3188d054481b9bd563e337901e93476303ce7f": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16282. Avoid FileStream to improve performance. Contributed by Ayush Saxena.\n",
      "commitDate": "02/05/19 12:58 PM",
      "commitName": "7a3188d054481b9bd563e337901e93476303ce7f",
      "commitAuthor": "Giovanni Matteo Fumarola",
      "commitDateOld": "11/01/19 10:54 AM",
      "commitNameOld": "fb8932a727f757b2e9c1c61a18145878d0eb77bd",
      "commitAuthorOld": "Giovanni Matteo Fumarola",
      "daysBetweenCommits": 111.04,
      "commitsBetweenForRepo": 826,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,86 +1,86 @@\n   public static String[] createJarWithClassPath(String inputClassPath, Path pwd,\n       Path targetDir,\n       Map\u003cString, String\u003e callerEnv) throws IOException {\n     // Replace environment variables, case-insensitive on Windows\n     @SuppressWarnings(\"unchecked\")\n     Map\u003cString, String\u003e env \u003d Shell.WINDOWS ? new CaseInsensitiveMap(callerEnv) :\n       callerEnv;\n     String[] classPathEntries \u003d inputClassPath.split(File.pathSeparator);\n     for (int i \u003d 0; i \u003c classPathEntries.length; ++i) {\n       classPathEntries[i] \u003d StringUtils.replaceTokens(classPathEntries[i],\n         StringUtils.ENV_VAR_PATTERN, env);\n     }\n     File workingDir \u003d new File(pwd.toString());\n     if (!workingDir.mkdirs()) {\n       // If mkdirs returns false because the working directory already exists,\n       // then this is acceptable.  If it returns false due to some other I/O\n       // error, then this method will fail later with an IOException while saving\n       // the jar.\n       LOG.debug(\"mkdirs false for \" + workingDir + \", execution will continue\");\n     }\n \n     StringBuilder unexpandedWildcardClasspath \u003d new StringBuilder();\n     // Append all entries\n     List\u003cString\u003e classPathEntryList \u003d new ArrayList\u003cString\u003e(\n       classPathEntries.length);\n     for (String classPathEntry: classPathEntries) {\n       if (classPathEntry.length() \u003d\u003d 0) {\n         continue;\n       }\n       if (classPathEntry.endsWith(\"*\")) {\n         // Append all jars that match the wildcard\n         List\u003cPath\u003e jars \u003d getJarsInDirectory(classPathEntry);\n         if (!jars.isEmpty()) {\n           for (Path jar: jars) {\n             classPathEntryList.add(jar.toUri().toURL().toExternalForm());\n           }\n         } else {\n           unexpandedWildcardClasspath.append(File.pathSeparator)\n               .append(classPathEntry);\n         }\n       } else {\n         // Append just this entry\n         File fileCpEntry \u003d null;\n         if(!new Path(classPathEntry).isAbsolute()) {\n           fileCpEntry \u003d new File(targetDir.toString(), classPathEntry);\n         }\n         else {\n           fileCpEntry \u003d new File(classPathEntry);\n         }\n         String classPathEntryUrl \u003d fileCpEntry.toURI().toURL()\n           .toExternalForm();\n \n         // File.toURI only appends trailing \u0027/\u0027 if it can determine that it is a\n         // directory that already exists.  (See JavaDocs.)  If this entry had a\n         // trailing \u0027/\u0027 specified by the caller, then guarantee that the\n         // classpath entry in the manifest has a trailing \u0027/\u0027, and thus refers to\n         // a directory instead of a file.  This can happen if the caller is\n         // creating a classpath jar referencing a directory that hasn\u0027t been\n         // created yet, but will definitely be created before running.\n         if (classPathEntry.endsWith(Path.SEPARATOR) \u0026\u0026\n             !classPathEntryUrl.endsWith(Path.SEPARATOR)) {\n           classPathEntryUrl \u003d classPathEntryUrl + Path.SEPARATOR;\n         }\n         classPathEntryList.add(classPathEntryUrl);\n       }\n     }\n     String jarClassPath \u003d StringUtils.join(\" \", classPathEntryList);\n \n     // Create the manifest\n     Manifest jarManifest \u003d new Manifest();\n     jarManifest.getMainAttributes().putValue(\n         Attributes.Name.MANIFEST_VERSION.toString(), \"1.0\");\n     jarManifest.getMainAttributes().putValue(\n         Attributes.Name.CLASS_PATH.toString(), jarClassPath);\n \n     // Write the manifest to output JAR file\n     File classPathJar \u003d File.createTempFile(\"classpath-\", \".jar\", workingDir);\n-    try (FileOutputStream fos \u003d new FileOutputStream(classPathJar);\n+    try (OutputStream fos \u003d Files.newOutputStream(classPathJar.toPath());\n          BufferedOutputStream bos \u003d new BufferedOutputStream(fos)) {\n       JarOutputStream jos \u003d new JarOutputStream(bos, jarManifest);\n       jos.close();\n     }\n     String[] jarCp \u003d {classPathJar.getCanonicalPath(),\n                         unexpandedWildcardClasspath.toString()};\n     return jarCp;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static String[] createJarWithClassPath(String inputClassPath, Path pwd,\n      Path targetDir,\n      Map\u003cString, String\u003e callerEnv) throws IOException {\n    // Replace environment variables, case-insensitive on Windows\n    @SuppressWarnings(\"unchecked\")\n    Map\u003cString, String\u003e env \u003d Shell.WINDOWS ? new CaseInsensitiveMap(callerEnv) :\n      callerEnv;\n    String[] classPathEntries \u003d inputClassPath.split(File.pathSeparator);\n    for (int i \u003d 0; i \u003c classPathEntries.length; ++i) {\n      classPathEntries[i] \u003d StringUtils.replaceTokens(classPathEntries[i],\n        StringUtils.ENV_VAR_PATTERN, env);\n    }\n    File workingDir \u003d new File(pwd.toString());\n    if (!workingDir.mkdirs()) {\n      // If mkdirs returns false because the working directory already exists,\n      // then this is acceptable.  If it returns false due to some other I/O\n      // error, then this method will fail later with an IOException while saving\n      // the jar.\n      LOG.debug(\"mkdirs false for \" + workingDir + \", execution will continue\");\n    }\n\n    StringBuilder unexpandedWildcardClasspath \u003d new StringBuilder();\n    // Append all entries\n    List\u003cString\u003e classPathEntryList \u003d new ArrayList\u003cString\u003e(\n      classPathEntries.length);\n    for (String classPathEntry: classPathEntries) {\n      if (classPathEntry.length() \u003d\u003d 0) {\n        continue;\n      }\n      if (classPathEntry.endsWith(\"*\")) {\n        // Append all jars that match the wildcard\n        List\u003cPath\u003e jars \u003d getJarsInDirectory(classPathEntry);\n        if (!jars.isEmpty()) {\n          for (Path jar: jars) {\n            classPathEntryList.add(jar.toUri().toURL().toExternalForm());\n          }\n        } else {\n          unexpandedWildcardClasspath.append(File.pathSeparator)\n              .append(classPathEntry);\n        }\n      } else {\n        // Append just this entry\n        File fileCpEntry \u003d null;\n        if(!new Path(classPathEntry).isAbsolute()) {\n          fileCpEntry \u003d new File(targetDir.toString(), classPathEntry);\n        }\n        else {\n          fileCpEntry \u003d new File(classPathEntry);\n        }\n        String classPathEntryUrl \u003d fileCpEntry.toURI().toURL()\n          .toExternalForm();\n\n        // File.toURI only appends trailing \u0027/\u0027 if it can determine that it is a\n        // directory that already exists.  (See JavaDocs.)  If this entry had a\n        // trailing \u0027/\u0027 specified by the caller, then guarantee that the\n        // classpath entry in the manifest has a trailing \u0027/\u0027, and thus refers to\n        // a directory instead of a file.  This can happen if the caller is\n        // creating a classpath jar referencing a directory that hasn\u0027t been\n        // created yet, but will definitely be created before running.\n        if (classPathEntry.endsWith(Path.SEPARATOR) \u0026\u0026\n            !classPathEntryUrl.endsWith(Path.SEPARATOR)) {\n          classPathEntryUrl \u003d classPathEntryUrl + Path.SEPARATOR;\n        }\n        classPathEntryList.add(classPathEntryUrl);\n      }\n    }\n    String jarClassPath \u003d StringUtils.join(\" \", classPathEntryList);\n\n    // Create the manifest\n    Manifest jarManifest \u003d new Manifest();\n    jarManifest.getMainAttributes().putValue(\n        Attributes.Name.MANIFEST_VERSION.toString(), \"1.0\");\n    jarManifest.getMainAttributes().putValue(\n        Attributes.Name.CLASS_PATH.toString(), jarClassPath);\n\n    // Write the manifest to output JAR file\n    File classPathJar \u003d File.createTempFile(\"classpath-\", \".jar\", workingDir);\n    try (OutputStream fos \u003d Files.newOutputStream(classPathJar.toPath());\n         BufferedOutputStream bos \u003d new BufferedOutputStream(fos)) {\n      JarOutputStream jos \u003d new JarOutputStream(bos, jarManifest);\n      jos.close();\n    }\n    String[] jarCp \u003d {classPathJar.getCanonicalPath(),\n                        unexpandedWildcardClasspath.toString()};\n    return jarCp;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/FileUtil.java",
      "extendedDetails": {}
    },
    "fb8932a727f757b2e9c1c61a18145878d0eb77bd": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16029. Consecutive StringBuilder.append can be reused. Contributed by Ayush Saxena.\n",
      "commitDate": "11/01/19 10:54 AM",
      "commitName": "fb8932a727f757b2e9c1c61a18145878d0eb77bd",
      "commitAuthor": "Giovanni Matteo Fumarola",
      "commitDateOld": "27/12/18 10:38 PM",
      "commitNameOld": "57198bc51122a36db8cb4788fcb7b55edc788b3b",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 14.51,
      "commitsBetweenForRepo": 72,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,86 +1,86 @@\n   public static String[] createJarWithClassPath(String inputClassPath, Path pwd,\n       Path targetDir,\n       Map\u003cString, String\u003e callerEnv) throws IOException {\n     // Replace environment variables, case-insensitive on Windows\n     @SuppressWarnings(\"unchecked\")\n     Map\u003cString, String\u003e env \u003d Shell.WINDOWS ? new CaseInsensitiveMap(callerEnv) :\n       callerEnv;\n     String[] classPathEntries \u003d inputClassPath.split(File.pathSeparator);\n     for (int i \u003d 0; i \u003c classPathEntries.length; ++i) {\n       classPathEntries[i] \u003d StringUtils.replaceTokens(classPathEntries[i],\n         StringUtils.ENV_VAR_PATTERN, env);\n     }\n     File workingDir \u003d new File(pwd.toString());\n     if (!workingDir.mkdirs()) {\n       // If mkdirs returns false because the working directory already exists,\n       // then this is acceptable.  If it returns false due to some other I/O\n       // error, then this method will fail later with an IOException while saving\n       // the jar.\n       LOG.debug(\"mkdirs false for \" + workingDir + \", execution will continue\");\n     }\n \n     StringBuilder unexpandedWildcardClasspath \u003d new StringBuilder();\n     // Append all entries\n     List\u003cString\u003e classPathEntryList \u003d new ArrayList\u003cString\u003e(\n       classPathEntries.length);\n     for (String classPathEntry: classPathEntries) {\n       if (classPathEntry.length() \u003d\u003d 0) {\n         continue;\n       }\n       if (classPathEntry.endsWith(\"*\")) {\n         // Append all jars that match the wildcard\n         List\u003cPath\u003e jars \u003d getJarsInDirectory(classPathEntry);\n         if (!jars.isEmpty()) {\n           for (Path jar: jars) {\n             classPathEntryList.add(jar.toUri().toURL().toExternalForm());\n           }\n         } else {\n-          unexpandedWildcardClasspath.append(File.pathSeparator);\n-          unexpandedWildcardClasspath.append(classPathEntry);\n+          unexpandedWildcardClasspath.append(File.pathSeparator)\n+              .append(classPathEntry);\n         }\n       } else {\n         // Append just this entry\n         File fileCpEntry \u003d null;\n         if(!new Path(classPathEntry).isAbsolute()) {\n           fileCpEntry \u003d new File(targetDir.toString(), classPathEntry);\n         }\n         else {\n           fileCpEntry \u003d new File(classPathEntry);\n         }\n         String classPathEntryUrl \u003d fileCpEntry.toURI().toURL()\n           .toExternalForm();\n \n         // File.toURI only appends trailing \u0027/\u0027 if it can determine that it is a\n         // directory that already exists.  (See JavaDocs.)  If this entry had a\n         // trailing \u0027/\u0027 specified by the caller, then guarantee that the\n         // classpath entry in the manifest has a trailing \u0027/\u0027, and thus refers to\n         // a directory instead of a file.  This can happen if the caller is\n         // creating a classpath jar referencing a directory that hasn\u0027t been\n         // created yet, but will definitely be created before running.\n         if (classPathEntry.endsWith(Path.SEPARATOR) \u0026\u0026\n             !classPathEntryUrl.endsWith(Path.SEPARATOR)) {\n           classPathEntryUrl \u003d classPathEntryUrl + Path.SEPARATOR;\n         }\n         classPathEntryList.add(classPathEntryUrl);\n       }\n     }\n     String jarClassPath \u003d StringUtils.join(\" \", classPathEntryList);\n \n     // Create the manifest\n     Manifest jarManifest \u003d new Manifest();\n     jarManifest.getMainAttributes().putValue(\n         Attributes.Name.MANIFEST_VERSION.toString(), \"1.0\");\n     jarManifest.getMainAttributes().putValue(\n         Attributes.Name.CLASS_PATH.toString(), jarClassPath);\n \n     // Write the manifest to output JAR file\n     File classPathJar \u003d File.createTempFile(\"classpath-\", \".jar\", workingDir);\n     try (FileOutputStream fos \u003d new FileOutputStream(classPathJar);\n          BufferedOutputStream bos \u003d new BufferedOutputStream(fos)) {\n       JarOutputStream jos \u003d new JarOutputStream(bos, jarManifest);\n       jos.close();\n     }\n     String[] jarCp \u003d {classPathJar.getCanonicalPath(),\n                         unexpandedWildcardClasspath.toString()};\n     return jarCp;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static String[] createJarWithClassPath(String inputClassPath, Path pwd,\n      Path targetDir,\n      Map\u003cString, String\u003e callerEnv) throws IOException {\n    // Replace environment variables, case-insensitive on Windows\n    @SuppressWarnings(\"unchecked\")\n    Map\u003cString, String\u003e env \u003d Shell.WINDOWS ? new CaseInsensitiveMap(callerEnv) :\n      callerEnv;\n    String[] classPathEntries \u003d inputClassPath.split(File.pathSeparator);\n    for (int i \u003d 0; i \u003c classPathEntries.length; ++i) {\n      classPathEntries[i] \u003d StringUtils.replaceTokens(classPathEntries[i],\n        StringUtils.ENV_VAR_PATTERN, env);\n    }\n    File workingDir \u003d new File(pwd.toString());\n    if (!workingDir.mkdirs()) {\n      // If mkdirs returns false because the working directory already exists,\n      // then this is acceptable.  If it returns false due to some other I/O\n      // error, then this method will fail later with an IOException while saving\n      // the jar.\n      LOG.debug(\"mkdirs false for \" + workingDir + \", execution will continue\");\n    }\n\n    StringBuilder unexpandedWildcardClasspath \u003d new StringBuilder();\n    // Append all entries\n    List\u003cString\u003e classPathEntryList \u003d new ArrayList\u003cString\u003e(\n      classPathEntries.length);\n    for (String classPathEntry: classPathEntries) {\n      if (classPathEntry.length() \u003d\u003d 0) {\n        continue;\n      }\n      if (classPathEntry.endsWith(\"*\")) {\n        // Append all jars that match the wildcard\n        List\u003cPath\u003e jars \u003d getJarsInDirectory(classPathEntry);\n        if (!jars.isEmpty()) {\n          for (Path jar: jars) {\n            classPathEntryList.add(jar.toUri().toURL().toExternalForm());\n          }\n        } else {\n          unexpandedWildcardClasspath.append(File.pathSeparator)\n              .append(classPathEntry);\n        }\n      } else {\n        // Append just this entry\n        File fileCpEntry \u003d null;\n        if(!new Path(classPathEntry).isAbsolute()) {\n          fileCpEntry \u003d new File(targetDir.toString(), classPathEntry);\n        }\n        else {\n          fileCpEntry \u003d new File(classPathEntry);\n        }\n        String classPathEntryUrl \u003d fileCpEntry.toURI().toURL()\n          .toExternalForm();\n\n        // File.toURI only appends trailing \u0027/\u0027 if it can determine that it is a\n        // directory that already exists.  (See JavaDocs.)  If this entry had a\n        // trailing \u0027/\u0027 specified by the caller, then guarantee that the\n        // classpath entry in the manifest has a trailing \u0027/\u0027, and thus refers to\n        // a directory instead of a file.  This can happen if the caller is\n        // creating a classpath jar referencing a directory that hasn\u0027t been\n        // created yet, but will definitely be created before running.\n        if (classPathEntry.endsWith(Path.SEPARATOR) \u0026\u0026\n            !classPathEntryUrl.endsWith(Path.SEPARATOR)) {\n          classPathEntryUrl \u003d classPathEntryUrl + Path.SEPARATOR;\n        }\n        classPathEntryList.add(classPathEntryUrl);\n      }\n    }\n    String jarClassPath \u003d StringUtils.join(\" \", classPathEntryList);\n\n    // Create the manifest\n    Manifest jarManifest \u003d new Manifest();\n    jarManifest.getMainAttributes().putValue(\n        Attributes.Name.MANIFEST_VERSION.toString(), \"1.0\");\n    jarManifest.getMainAttributes().putValue(\n        Attributes.Name.CLASS_PATH.toString(), jarClassPath);\n\n    // Write the manifest to output JAR file\n    File classPathJar \u003d File.createTempFile(\"classpath-\", \".jar\", workingDir);\n    try (FileOutputStream fos \u003d new FileOutputStream(classPathJar);\n         BufferedOutputStream bos \u003d new BufferedOutputStream(fos)) {\n      JarOutputStream jos \u003d new JarOutputStream(bos, jarManifest);\n      jos.close();\n    }\n    String[] jarCp \u003d {classPathJar.getCanonicalPath(),\n                        unexpandedWildcardClasspath.toString()};\n    return jarCp;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/FileUtil.java",
      "extendedDetails": {}
    },
    "f8af0e2feb9f45aeaa9711dbf93115ffb1a07e5d": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15085. Output streams closed with IOUtils suppressing write errors. Contributed by Jim Brennan\n",
      "commitDate": "14/12/17 8:18 AM",
      "commitName": "f8af0e2feb9f45aeaa9711dbf93115ffb1a07e5d",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "11/08/17 9:25 AM",
      "commitNameOld": "4222c971080f2b150713727092c7197df58c88e5",
      "commitAuthorOld": "Allen Wittenauer",
      "daysBetweenCommits": 124.99,
      "commitsBetweenForRepo": 1021,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,91 +1,86 @@\n   public static String[] createJarWithClassPath(String inputClassPath, Path pwd,\n       Path targetDir,\n       Map\u003cString, String\u003e callerEnv) throws IOException {\n     // Replace environment variables, case-insensitive on Windows\n     @SuppressWarnings(\"unchecked\")\n     Map\u003cString, String\u003e env \u003d Shell.WINDOWS ? new CaseInsensitiveMap(callerEnv) :\n       callerEnv;\n     String[] classPathEntries \u003d inputClassPath.split(File.pathSeparator);\n     for (int i \u003d 0; i \u003c classPathEntries.length; ++i) {\n       classPathEntries[i] \u003d StringUtils.replaceTokens(classPathEntries[i],\n         StringUtils.ENV_VAR_PATTERN, env);\n     }\n     File workingDir \u003d new File(pwd.toString());\n     if (!workingDir.mkdirs()) {\n       // If mkdirs returns false because the working directory already exists,\n       // then this is acceptable.  If it returns false due to some other I/O\n       // error, then this method will fail later with an IOException while saving\n       // the jar.\n       LOG.debug(\"mkdirs false for \" + workingDir + \", execution will continue\");\n     }\n \n     StringBuilder unexpandedWildcardClasspath \u003d new StringBuilder();\n     // Append all entries\n     List\u003cString\u003e classPathEntryList \u003d new ArrayList\u003cString\u003e(\n       classPathEntries.length);\n     for (String classPathEntry: classPathEntries) {\n       if (classPathEntry.length() \u003d\u003d 0) {\n         continue;\n       }\n       if (classPathEntry.endsWith(\"*\")) {\n         // Append all jars that match the wildcard\n         List\u003cPath\u003e jars \u003d getJarsInDirectory(classPathEntry);\n         if (!jars.isEmpty()) {\n           for (Path jar: jars) {\n             classPathEntryList.add(jar.toUri().toURL().toExternalForm());\n           }\n         } else {\n           unexpandedWildcardClasspath.append(File.pathSeparator);\n           unexpandedWildcardClasspath.append(classPathEntry);\n         }\n       } else {\n         // Append just this entry\n         File fileCpEntry \u003d null;\n         if(!new Path(classPathEntry).isAbsolute()) {\n           fileCpEntry \u003d new File(targetDir.toString(), classPathEntry);\n         }\n         else {\n           fileCpEntry \u003d new File(classPathEntry);\n         }\n         String classPathEntryUrl \u003d fileCpEntry.toURI().toURL()\n           .toExternalForm();\n \n         // File.toURI only appends trailing \u0027/\u0027 if it can determine that it is a\n         // directory that already exists.  (See JavaDocs.)  If this entry had a\n         // trailing \u0027/\u0027 specified by the caller, then guarantee that the\n         // classpath entry in the manifest has a trailing \u0027/\u0027, and thus refers to\n         // a directory instead of a file.  This can happen if the caller is\n         // creating a classpath jar referencing a directory that hasn\u0027t been\n         // created yet, but will definitely be created before running.\n         if (classPathEntry.endsWith(Path.SEPARATOR) \u0026\u0026\n             !classPathEntryUrl.endsWith(Path.SEPARATOR)) {\n           classPathEntryUrl \u003d classPathEntryUrl + Path.SEPARATOR;\n         }\n         classPathEntryList.add(classPathEntryUrl);\n       }\n     }\n     String jarClassPath \u003d StringUtils.join(\" \", classPathEntryList);\n \n     // Create the manifest\n     Manifest jarManifest \u003d new Manifest();\n     jarManifest.getMainAttributes().putValue(\n         Attributes.Name.MANIFEST_VERSION.toString(), \"1.0\");\n     jarManifest.getMainAttributes().putValue(\n         Attributes.Name.CLASS_PATH.toString(), jarClassPath);\n \n     // Write the manifest to output JAR file\n     File classPathJar \u003d File.createTempFile(\"classpath-\", \".jar\", workingDir);\n-    FileOutputStream fos \u003d null;\n-    BufferedOutputStream bos \u003d null;\n-    JarOutputStream jos \u003d null;\n-    try {\n-      fos \u003d new FileOutputStream(classPathJar);\n-      bos \u003d new BufferedOutputStream(fos);\n-      jos \u003d new JarOutputStream(bos, jarManifest);\n-    } finally {\n-      IOUtils.cleanupWithLogger(LOG, jos, bos, fos);\n+    try (FileOutputStream fos \u003d new FileOutputStream(classPathJar);\n+         BufferedOutputStream bos \u003d new BufferedOutputStream(fos)) {\n+      JarOutputStream jos \u003d new JarOutputStream(bos, jarManifest);\n+      jos.close();\n     }\n     String[] jarCp \u003d {classPathJar.getCanonicalPath(),\n                         unexpandedWildcardClasspath.toString()};\n     return jarCp;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static String[] createJarWithClassPath(String inputClassPath, Path pwd,\n      Path targetDir,\n      Map\u003cString, String\u003e callerEnv) throws IOException {\n    // Replace environment variables, case-insensitive on Windows\n    @SuppressWarnings(\"unchecked\")\n    Map\u003cString, String\u003e env \u003d Shell.WINDOWS ? new CaseInsensitiveMap(callerEnv) :\n      callerEnv;\n    String[] classPathEntries \u003d inputClassPath.split(File.pathSeparator);\n    for (int i \u003d 0; i \u003c classPathEntries.length; ++i) {\n      classPathEntries[i] \u003d StringUtils.replaceTokens(classPathEntries[i],\n        StringUtils.ENV_VAR_PATTERN, env);\n    }\n    File workingDir \u003d new File(pwd.toString());\n    if (!workingDir.mkdirs()) {\n      // If mkdirs returns false because the working directory already exists,\n      // then this is acceptable.  If it returns false due to some other I/O\n      // error, then this method will fail later with an IOException while saving\n      // the jar.\n      LOG.debug(\"mkdirs false for \" + workingDir + \", execution will continue\");\n    }\n\n    StringBuilder unexpandedWildcardClasspath \u003d new StringBuilder();\n    // Append all entries\n    List\u003cString\u003e classPathEntryList \u003d new ArrayList\u003cString\u003e(\n      classPathEntries.length);\n    for (String classPathEntry: classPathEntries) {\n      if (classPathEntry.length() \u003d\u003d 0) {\n        continue;\n      }\n      if (classPathEntry.endsWith(\"*\")) {\n        // Append all jars that match the wildcard\n        List\u003cPath\u003e jars \u003d getJarsInDirectory(classPathEntry);\n        if (!jars.isEmpty()) {\n          for (Path jar: jars) {\n            classPathEntryList.add(jar.toUri().toURL().toExternalForm());\n          }\n        } else {\n          unexpandedWildcardClasspath.append(File.pathSeparator);\n          unexpandedWildcardClasspath.append(classPathEntry);\n        }\n      } else {\n        // Append just this entry\n        File fileCpEntry \u003d null;\n        if(!new Path(classPathEntry).isAbsolute()) {\n          fileCpEntry \u003d new File(targetDir.toString(), classPathEntry);\n        }\n        else {\n          fileCpEntry \u003d new File(classPathEntry);\n        }\n        String classPathEntryUrl \u003d fileCpEntry.toURI().toURL()\n          .toExternalForm();\n\n        // File.toURI only appends trailing \u0027/\u0027 if it can determine that it is a\n        // directory that already exists.  (See JavaDocs.)  If this entry had a\n        // trailing \u0027/\u0027 specified by the caller, then guarantee that the\n        // classpath entry in the manifest has a trailing \u0027/\u0027, and thus refers to\n        // a directory instead of a file.  This can happen if the caller is\n        // creating a classpath jar referencing a directory that hasn\u0027t been\n        // created yet, but will definitely be created before running.\n        if (classPathEntry.endsWith(Path.SEPARATOR) \u0026\u0026\n            !classPathEntryUrl.endsWith(Path.SEPARATOR)) {\n          classPathEntryUrl \u003d classPathEntryUrl + Path.SEPARATOR;\n        }\n        classPathEntryList.add(classPathEntryUrl);\n      }\n    }\n    String jarClassPath \u003d StringUtils.join(\" \", classPathEntryList);\n\n    // Create the manifest\n    Manifest jarManifest \u003d new Manifest();\n    jarManifest.getMainAttributes().putValue(\n        Attributes.Name.MANIFEST_VERSION.toString(), \"1.0\");\n    jarManifest.getMainAttributes().putValue(\n        Attributes.Name.CLASS_PATH.toString(), jarClassPath);\n\n    // Write the manifest to output JAR file\n    File classPathJar \u003d File.createTempFile(\"classpath-\", \".jar\", workingDir);\n    try (FileOutputStream fos \u003d new FileOutputStream(classPathJar);\n         BufferedOutputStream bos \u003d new BufferedOutputStream(fos)) {\n      JarOutputStream jos \u003d new JarOutputStream(bos, jarManifest);\n      jos.close();\n    }\n    String[] jarCp \u003d {classPathJar.getCanonicalPath(),\n                        unexpandedWildcardClasspath.toString()};\n    return jarCp;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/FileUtil.java",
      "extendedDetails": {}
    },
    "ccaf036662e22da14583942054898c99fa51dae5": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14539. Move commons logging APIs over to slf4j in hadoop-common. Contributed by Wenxin He.\n",
      "commitDate": "17/07/17 9:32 PM",
      "commitName": "ccaf036662e22da14583942054898c99fa51dae5",
      "commitAuthor": "Akira Ajisaka",
      "commitDateOld": "22/06/17 6:28 PM",
      "commitNameOld": "092ebdf885468a2bf79cbfb168286b7cddc4a0db",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 25.13,
      "commitsBetweenForRepo": 116,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,91 +1,91 @@\n   public static String[] createJarWithClassPath(String inputClassPath, Path pwd,\n       Path targetDir,\n       Map\u003cString, String\u003e callerEnv) throws IOException {\n     // Replace environment variables, case-insensitive on Windows\n     @SuppressWarnings(\"unchecked\")\n     Map\u003cString, String\u003e env \u003d Shell.WINDOWS ? new CaseInsensitiveMap(callerEnv) :\n       callerEnv;\n     String[] classPathEntries \u003d inputClassPath.split(File.pathSeparator);\n     for (int i \u003d 0; i \u003c classPathEntries.length; ++i) {\n       classPathEntries[i] \u003d StringUtils.replaceTokens(classPathEntries[i],\n         StringUtils.ENV_VAR_PATTERN, env);\n     }\n     File workingDir \u003d new File(pwd.toString());\n     if (!workingDir.mkdirs()) {\n       // If mkdirs returns false because the working directory already exists,\n       // then this is acceptable.  If it returns false due to some other I/O\n       // error, then this method will fail later with an IOException while saving\n       // the jar.\n       LOG.debug(\"mkdirs false for \" + workingDir + \", execution will continue\");\n     }\n \n     StringBuilder unexpandedWildcardClasspath \u003d new StringBuilder();\n     // Append all entries\n     List\u003cString\u003e classPathEntryList \u003d new ArrayList\u003cString\u003e(\n       classPathEntries.length);\n     for (String classPathEntry: classPathEntries) {\n       if (classPathEntry.length() \u003d\u003d 0) {\n         continue;\n       }\n       if (classPathEntry.endsWith(\"*\")) {\n         // Append all jars that match the wildcard\n         List\u003cPath\u003e jars \u003d getJarsInDirectory(classPathEntry);\n         if (!jars.isEmpty()) {\n           for (Path jar: jars) {\n             classPathEntryList.add(jar.toUri().toURL().toExternalForm());\n           }\n         } else {\n           unexpandedWildcardClasspath.append(File.pathSeparator);\n           unexpandedWildcardClasspath.append(classPathEntry);\n         }\n       } else {\n         // Append just this entry\n         File fileCpEntry \u003d null;\n         if(!new Path(classPathEntry).isAbsolute()) {\n           fileCpEntry \u003d new File(targetDir.toString(), classPathEntry);\n         }\n         else {\n           fileCpEntry \u003d new File(classPathEntry);\n         }\n         String classPathEntryUrl \u003d fileCpEntry.toURI().toURL()\n           .toExternalForm();\n \n         // File.toURI only appends trailing \u0027/\u0027 if it can determine that it is a\n         // directory that already exists.  (See JavaDocs.)  If this entry had a\n         // trailing \u0027/\u0027 specified by the caller, then guarantee that the\n         // classpath entry in the manifest has a trailing \u0027/\u0027, and thus refers to\n         // a directory instead of a file.  This can happen if the caller is\n         // creating a classpath jar referencing a directory that hasn\u0027t been\n         // created yet, but will definitely be created before running.\n         if (classPathEntry.endsWith(Path.SEPARATOR) \u0026\u0026\n             !classPathEntryUrl.endsWith(Path.SEPARATOR)) {\n           classPathEntryUrl \u003d classPathEntryUrl + Path.SEPARATOR;\n         }\n         classPathEntryList.add(classPathEntryUrl);\n       }\n     }\n     String jarClassPath \u003d StringUtils.join(\" \", classPathEntryList);\n \n     // Create the manifest\n     Manifest jarManifest \u003d new Manifest();\n     jarManifest.getMainAttributes().putValue(\n         Attributes.Name.MANIFEST_VERSION.toString(), \"1.0\");\n     jarManifest.getMainAttributes().putValue(\n         Attributes.Name.CLASS_PATH.toString(), jarClassPath);\n \n     // Write the manifest to output JAR file\n     File classPathJar \u003d File.createTempFile(\"classpath-\", \".jar\", workingDir);\n     FileOutputStream fos \u003d null;\n     BufferedOutputStream bos \u003d null;\n     JarOutputStream jos \u003d null;\n     try {\n       fos \u003d new FileOutputStream(classPathJar);\n       bos \u003d new BufferedOutputStream(fos);\n       jos \u003d new JarOutputStream(bos, jarManifest);\n     } finally {\n-      IOUtils.cleanup(LOG, jos, bos, fos);\n+      IOUtils.cleanupWithLogger(LOG, jos, bos, fos);\n     }\n     String[] jarCp \u003d {classPathJar.getCanonicalPath(),\n                         unexpandedWildcardClasspath.toString()};\n     return jarCp;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static String[] createJarWithClassPath(String inputClassPath, Path pwd,\n      Path targetDir,\n      Map\u003cString, String\u003e callerEnv) throws IOException {\n    // Replace environment variables, case-insensitive on Windows\n    @SuppressWarnings(\"unchecked\")\n    Map\u003cString, String\u003e env \u003d Shell.WINDOWS ? new CaseInsensitiveMap(callerEnv) :\n      callerEnv;\n    String[] classPathEntries \u003d inputClassPath.split(File.pathSeparator);\n    for (int i \u003d 0; i \u003c classPathEntries.length; ++i) {\n      classPathEntries[i] \u003d StringUtils.replaceTokens(classPathEntries[i],\n        StringUtils.ENV_VAR_PATTERN, env);\n    }\n    File workingDir \u003d new File(pwd.toString());\n    if (!workingDir.mkdirs()) {\n      // If mkdirs returns false because the working directory already exists,\n      // then this is acceptable.  If it returns false due to some other I/O\n      // error, then this method will fail later with an IOException while saving\n      // the jar.\n      LOG.debug(\"mkdirs false for \" + workingDir + \", execution will continue\");\n    }\n\n    StringBuilder unexpandedWildcardClasspath \u003d new StringBuilder();\n    // Append all entries\n    List\u003cString\u003e classPathEntryList \u003d new ArrayList\u003cString\u003e(\n      classPathEntries.length);\n    for (String classPathEntry: classPathEntries) {\n      if (classPathEntry.length() \u003d\u003d 0) {\n        continue;\n      }\n      if (classPathEntry.endsWith(\"*\")) {\n        // Append all jars that match the wildcard\n        List\u003cPath\u003e jars \u003d getJarsInDirectory(classPathEntry);\n        if (!jars.isEmpty()) {\n          for (Path jar: jars) {\n            classPathEntryList.add(jar.toUri().toURL().toExternalForm());\n          }\n        } else {\n          unexpandedWildcardClasspath.append(File.pathSeparator);\n          unexpandedWildcardClasspath.append(classPathEntry);\n        }\n      } else {\n        // Append just this entry\n        File fileCpEntry \u003d null;\n        if(!new Path(classPathEntry).isAbsolute()) {\n          fileCpEntry \u003d new File(targetDir.toString(), classPathEntry);\n        }\n        else {\n          fileCpEntry \u003d new File(classPathEntry);\n        }\n        String classPathEntryUrl \u003d fileCpEntry.toURI().toURL()\n          .toExternalForm();\n\n        // File.toURI only appends trailing \u0027/\u0027 if it can determine that it is a\n        // directory that already exists.  (See JavaDocs.)  If this entry had a\n        // trailing \u0027/\u0027 specified by the caller, then guarantee that the\n        // classpath entry in the manifest has a trailing \u0027/\u0027, and thus refers to\n        // a directory instead of a file.  This can happen if the caller is\n        // creating a classpath jar referencing a directory that hasn\u0027t been\n        // created yet, but will definitely be created before running.\n        if (classPathEntry.endsWith(Path.SEPARATOR) \u0026\u0026\n            !classPathEntryUrl.endsWith(Path.SEPARATOR)) {\n          classPathEntryUrl \u003d classPathEntryUrl + Path.SEPARATOR;\n        }\n        classPathEntryList.add(classPathEntryUrl);\n      }\n    }\n    String jarClassPath \u003d StringUtils.join(\" \", classPathEntryList);\n\n    // Create the manifest\n    Manifest jarManifest \u003d new Manifest();\n    jarManifest.getMainAttributes().putValue(\n        Attributes.Name.MANIFEST_VERSION.toString(), \"1.0\");\n    jarManifest.getMainAttributes().putValue(\n        Attributes.Name.CLASS_PATH.toString(), jarClassPath);\n\n    // Write the manifest to output JAR file\n    File classPathJar \u003d File.createTempFile(\"classpath-\", \".jar\", workingDir);\n    FileOutputStream fos \u003d null;\n    BufferedOutputStream bos \u003d null;\n    JarOutputStream jos \u003d null;\n    try {\n      fos \u003d new FileOutputStream(classPathJar);\n      bos \u003d new BufferedOutputStream(fos);\n      jos \u003d new JarOutputStream(bos, jarManifest);\n    } finally {\n      IOUtils.cleanupWithLogger(LOG, jos, bos, fos);\n    }\n    String[] jarCp \u003d {classPathJar.getCanonicalPath(),\n                        unexpandedWildcardClasspath.toString()};\n    return jarCp;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/FileUtil.java",
      "extendedDetails": {}
    },
    "0ad48aa2c8f41196743305c711ea19cc48f186da": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-12747. support wildcard in libjars argument (sjlee)\n",
      "commitDate": "08/08/16 5:34 PM",
      "commitName": "0ad48aa2c8f41196743305c711ea19cc48f186da",
      "commitAuthor": "Sangjin Lee",
      "commitDateOld": "16/06/16 4:17 AM",
      "commitNameOld": "cc6c265171aace1e57653e777a4a73a747221086",
      "commitAuthorOld": "Vinayakumar B",
      "daysBetweenCommits": 53.55,
      "commitsBetweenForRepo": 488,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,97 +1,91 @@\n   public static String[] createJarWithClassPath(String inputClassPath, Path pwd,\n       Path targetDir,\n       Map\u003cString, String\u003e callerEnv) throws IOException {\n     // Replace environment variables, case-insensitive on Windows\n     @SuppressWarnings(\"unchecked\")\n     Map\u003cString, String\u003e env \u003d Shell.WINDOWS ? new CaseInsensitiveMap(callerEnv) :\n       callerEnv;\n     String[] classPathEntries \u003d inputClassPath.split(File.pathSeparator);\n     for (int i \u003d 0; i \u003c classPathEntries.length; ++i) {\n       classPathEntries[i] \u003d StringUtils.replaceTokens(classPathEntries[i],\n         StringUtils.ENV_VAR_PATTERN, env);\n     }\n     File workingDir \u003d new File(pwd.toString());\n     if (!workingDir.mkdirs()) {\n       // If mkdirs returns false because the working directory already exists,\n       // then this is acceptable.  If it returns false due to some other I/O\n       // error, then this method will fail later with an IOException while saving\n       // the jar.\n       LOG.debug(\"mkdirs false for \" + workingDir + \", execution will continue\");\n     }\n \n     StringBuilder unexpandedWildcardClasspath \u003d new StringBuilder();\n     // Append all entries\n     List\u003cString\u003e classPathEntryList \u003d new ArrayList\u003cString\u003e(\n       classPathEntries.length);\n     for (String classPathEntry: classPathEntries) {\n       if (classPathEntry.length() \u003d\u003d 0) {\n         continue;\n       }\n       if (classPathEntry.endsWith(\"*\")) {\n-        boolean foundWildCardJar \u003d false;\n         // Append all jars that match the wildcard\n-        Path globPath \u003d new Path(classPathEntry).suffix(\"{.jar,.JAR}\");\n-        FileStatus[] wildcardJars \u003d FileContext.getLocalFSFileContext().util()\n-          .globStatus(globPath);\n-        if (wildcardJars !\u003d null) {\n-          for (FileStatus wildcardJar: wildcardJars) {\n-            foundWildCardJar \u003d true;\n-            classPathEntryList.add(wildcardJar.getPath().toUri().toURL()\n-              .toExternalForm());\n+        List\u003cPath\u003e jars \u003d getJarsInDirectory(classPathEntry);\n+        if (!jars.isEmpty()) {\n+          for (Path jar: jars) {\n+            classPathEntryList.add(jar.toUri().toURL().toExternalForm());\n           }\n-        }\n-        if (!foundWildCardJar) {\n+        } else {\n           unexpandedWildcardClasspath.append(File.pathSeparator);\n           unexpandedWildcardClasspath.append(classPathEntry);\n         }\n       } else {\n         // Append just this entry\n         File fileCpEntry \u003d null;\n         if(!new Path(classPathEntry).isAbsolute()) {\n           fileCpEntry \u003d new File(targetDir.toString(), classPathEntry);\n         }\n         else {\n           fileCpEntry \u003d new File(classPathEntry);\n         }\n         String classPathEntryUrl \u003d fileCpEntry.toURI().toURL()\n           .toExternalForm();\n \n         // File.toURI only appends trailing \u0027/\u0027 if it can determine that it is a\n         // directory that already exists.  (See JavaDocs.)  If this entry had a\n         // trailing \u0027/\u0027 specified by the caller, then guarantee that the\n         // classpath entry in the manifest has a trailing \u0027/\u0027, and thus refers to\n         // a directory instead of a file.  This can happen if the caller is\n         // creating a classpath jar referencing a directory that hasn\u0027t been\n         // created yet, but will definitely be created before running.\n         if (classPathEntry.endsWith(Path.SEPARATOR) \u0026\u0026\n             !classPathEntryUrl.endsWith(Path.SEPARATOR)) {\n           classPathEntryUrl \u003d classPathEntryUrl + Path.SEPARATOR;\n         }\n         classPathEntryList.add(classPathEntryUrl);\n       }\n     }\n     String jarClassPath \u003d StringUtils.join(\" \", classPathEntryList);\n \n     // Create the manifest\n     Manifest jarManifest \u003d new Manifest();\n     jarManifest.getMainAttributes().putValue(\n         Attributes.Name.MANIFEST_VERSION.toString(), \"1.0\");\n     jarManifest.getMainAttributes().putValue(\n         Attributes.Name.CLASS_PATH.toString(), jarClassPath);\n \n     // Write the manifest to output JAR file\n     File classPathJar \u003d File.createTempFile(\"classpath-\", \".jar\", workingDir);\n     FileOutputStream fos \u003d null;\n     BufferedOutputStream bos \u003d null;\n     JarOutputStream jos \u003d null;\n     try {\n       fos \u003d new FileOutputStream(classPathJar);\n       bos \u003d new BufferedOutputStream(fos);\n       jos \u003d new JarOutputStream(bos, jarManifest);\n     } finally {\n       IOUtils.cleanup(LOG, jos, bos, fos);\n     }\n     String[] jarCp \u003d {classPathJar.getCanonicalPath(),\n                         unexpandedWildcardClasspath.toString()};\n     return jarCp;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static String[] createJarWithClassPath(String inputClassPath, Path pwd,\n      Path targetDir,\n      Map\u003cString, String\u003e callerEnv) throws IOException {\n    // Replace environment variables, case-insensitive on Windows\n    @SuppressWarnings(\"unchecked\")\n    Map\u003cString, String\u003e env \u003d Shell.WINDOWS ? new CaseInsensitiveMap(callerEnv) :\n      callerEnv;\n    String[] classPathEntries \u003d inputClassPath.split(File.pathSeparator);\n    for (int i \u003d 0; i \u003c classPathEntries.length; ++i) {\n      classPathEntries[i] \u003d StringUtils.replaceTokens(classPathEntries[i],\n        StringUtils.ENV_VAR_PATTERN, env);\n    }\n    File workingDir \u003d new File(pwd.toString());\n    if (!workingDir.mkdirs()) {\n      // If mkdirs returns false because the working directory already exists,\n      // then this is acceptable.  If it returns false due to some other I/O\n      // error, then this method will fail later with an IOException while saving\n      // the jar.\n      LOG.debug(\"mkdirs false for \" + workingDir + \", execution will continue\");\n    }\n\n    StringBuilder unexpandedWildcardClasspath \u003d new StringBuilder();\n    // Append all entries\n    List\u003cString\u003e classPathEntryList \u003d new ArrayList\u003cString\u003e(\n      classPathEntries.length);\n    for (String classPathEntry: classPathEntries) {\n      if (classPathEntry.length() \u003d\u003d 0) {\n        continue;\n      }\n      if (classPathEntry.endsWith(\"*\")) {\n        // Append all jars that match the wildcard\n        List\u003cPath\u003e jars \u003d getJarsInDirectory(classPathEntry);\n        if (!jars.isEmpty()) {\n          for (Path jar: jars) {\n            classPathEntryList.add(jar.toUri().toURL().toExternalForm());\n          }\n        } else {\n          unexpandedWildcardClasspath.append(File.pathSeparator);\n          unexpandedWildcardClasspath.append(classPathEntry);\n        }\n      } else {\n        // Append just this entry\n        File fileCpEntry \u003d null;\n        if(!new Path(classPathEntry).isAbsolute()) {\n          fileCpEntry \u003d new File(targetDir.toString(), classPathEntry);\n        }\n        else {\n          fileCpEntry \u003d new File(classPathEntry);\n        }\n        String classPathEntryUrl \u003d fileCpEntry.toURI().toURL()\n          .toExternalForm();\n\n        // File.toURI only appends trailing \u0027/\u0027 if it can determine that it is a\n        // directory that already exists.  (See JavaDocs.)  If this entry had a\n        // trailing \u0027/\u0027 specified by the caller, then guarantee that the\n        // classpath entry in the manifest has a trailing \u0027/\u0027, and thus refers to\n        // a directory instead of a file.  This can happen if the caller is\n        // creating a classpath jar referencing a directory that hasn\u0027t been\n        // created yet, but will definitely be created before running.\n        if (classPathEntry.endsWith(Path.SEPARATOR) \u0026\u0026\n            !classPathEntryUrl.endsWith(Path.SEPARATOR)) {\n          classPathEntryUrl \u003d classPathEntryUrl + Path.SEPARATOR;\n        }\n        classPathEntryList.add(classPathEntryUrl);\n      }\n    }\n    String jarClassPath \u003d StringUtils.join(\" \", classPathEntryList);\n\n    // Create the manifest\n    Manifest jarManifest \u003d new Manifest();\n    jarManifest.getMainAttributes().putValue(\n        Attributes.Name.MANIFEST_VERSION.toString(), \"1.0\");\n    jarManifest.getMainAttributes().putValue(\n        Attributes.Name.CLASS_PATH.toString(), jarClassPath);\n\n    // Write the manifest to output JAR file\n    File classPathJar \u003d File.createTempFile(\"classpath-\", \".jar\", workingDir);\n    FileOutputStream fos \u003d null;\n    BufferedOutputStream bos \u003d null;\n    JarOutputStream jos \u003d null;\n    try {\n      fos \u003d new FileOutputStream(classPathJar);\n      bos \u003d new BufferedOutputStream(fos);\n      jos \u003d new JarOutputStream(bos, jarManifest);\n    } finally {\n      IOUtils.cleanup(LOG, jos, bos, fos);\n    }\n    String[] jarCp \u003d {classPathJar.getCanonicalPath(),\n                        unexpandedWildcardClasspath.toString()};\n    return jarCp;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/FileUtil.java",
      "extendedDetails": {}
    },
    "3b12fd6cfbf4cc91ef8e8616c7aafa9de006cde5": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-2198. Remove the need to run NodeManager as privileged account for Windows Secure Container Executor. Contributed by Remus Rusanu\n",
      "commitDate": "22/10/14 3:57 PM",
      "commitName": "3b12fd6cfbf4cc91ef8e8616c7aafa9de006cde5",
      "commitAuthor": "Jian He",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-2198. Remove the need to run NodeManager as privileged account for Windows Secure Container Executor. Contributed by Remus Rusanu\n",
          "commitDate": "22/10/14 3:57 PM",
          "commitName": "3b12fd6cfbf4cc91ef8e8616c7aafa9de006cde5",
          "commitAuthor": "Jian He",
          "commitDateOld": "21/10/14 12:33 PM",
          "commitNameOld": "6637e3cf95b3a9be8d6b9cd66bc849a0607e8ed5",
          "commitAuthorOld": "cnauroth",
          "daysBetweenCommits": 1.14,
          "commitsBetweenForRepo": 17,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,96 +1,97 @@\n   public static String[] createJarWithClassPath(String inputClassPath, Path pwd,\n+      Path targetDir,\n       Map\u003cString, String\u003e callerEnv) throws IOException {\n     // Replace environment variables, case-insensitive on Windows\n     @SuppressWarnings(\"unchecked\")\n     Map\u003cString, String\u003e env \u003d Shell.WINDOWS ? new CaseInsensitiveMap(callerEnv) :\n       callerEnv;\n     String[] classPathEntries \u003d inputClassPath.split(File.pathSeparator);\n     for (int i \u003d 0; i \u003c classPathEntries.length; ++i) {\n       classPathEntries[i] \u003d StringUtils.replaceTokens(classPathEntries[i],\n         StringUtils.ENV_VAR_PATTERN, env);\n     }\n     File workingDir \u003d new File(pwd.toString());\n     if (!workingDir.mkdirs()) {\n       // If mkdirs returns false because the working directory already exists,\n       // then this is acceptable.  If it returns false due to some other I/O\n       // error, then this method will fail later with an IOException while saving\n       // the jar.\n       LOG.debug(\"mkdirs false for \" + workingDir + \", execution will continue\");\n     }\n \n     StringBuilder unexpandedWildcardClasspath \u003d new StringBuilder();\n     // Append all entries\n     List\u003cString\u003e classPathEntryList \u003d new ArrayList\u003cString\u003e(\n       classPathEntries.length);\n     for (String classPathEntry: classPathEntries) {\n       if (classPathEntry.length() \u003d\u003d 0) {\n         continue;\n       }\n       if (classPathEntry.endsWith(\"*\")) {\n         boolean foundWildCardJar \u003d false;\n         // Append all jars that match the wildcard\n         Path globPath \u003d new Path(classPathEntry).suffix(\"{.jar,.JAR}\");\n         FileStatus[] wildcardJars \u003d FileContext.getLocalFSFileContext().util()\n           .globStatus(globPath);\n         if (wildcardJars !\u003d null) {\n           for (FileStatus wildcardJar: wildcardJars) {\n             foundWildCardJar \u003d true;\n             classPathEntryList.add(wildcardJar.getPath().toUri().toURL()\n               .toExternalForm());\n           }\n         }\n         if (!foundWildCardJar) {\n           unexpandedWildcardClasspath.append(File.pathSeparator);\n           unexpandedWildcardClasspath.append(classPathEntry);\n         }\n       } else {\n         // Append just this entry\n         File fileCpEntry \u003d null;\n         if(!new Path(classPathEntry).isAbsolute()) {\n-          fileCpEntry \u003d new File(workingDir, classPathEntry);\n+          fileCpEntry \u003d new File(targetDir.toString(), classPathEntry);\n         }\n         else {\n           fileCpEntry \u003d new File(classPathEntry);\n         }\n         String classPathEntryUrl \u003d fileCpEntry.toURI().toURL()\n           .toExternalForm();\n \n         // File.toURI only appends trailing \u0027/\u0027 if it can determine that it is a\n         // directory that already exists.  (See JavaDocs.)  If this entry had a\n         // trailing \u0027/\u0027 specified by the caller, then guarantee that the\n         // classpath entry in the manifest has a trailing \u0027/\u0027, and thus refers to\n         // a directory instead of a file.  This can happen if the caller is\n         // creating a classpath jar referencing a directory that hasn\u0027t been\n         // created yet, but will definitely be created before running.\n         if (classPathEntry.endsWith(Path.SEPARATOR) \u0026\u0026\n             !classPathEntryUrl.endsWith(Path.SEPARATOR)) {\n           classPathEntryUrl \u003d classPathEntryUrl + Path.SEPARATOR;\n         }\n         classPathEntryList.add(classPathEntryUrl);\n       }\n     }\n     String jarClassPath \u003d StringUtils.join(\" \", classPathEntryList);\n \n     // Create the manifest\n     Manifest jarManifest \u003d new Manifest();\n     jarManifest.getMainAttributes().putValue(\n         Attributes.Name.MANIFEST_VERSION.toString(), \"1.0\");\n     jarManifest.getMainAttributes().putValue(\n         Attributes.Name.CLASS_PATH.toString(), jarClassPath);\n \n     // Write the manifest to output JAR file\n     File classPathJar \u003d File.createTempFile(\"classpath-\", \".jar\", workingDir);\n     FileOutputStream fos \u003d null;\n     BufferedOutputStream bos \u003d null;\n     JarOutputStream jos \u003d null;\n     try {\n       fos \u003d new FileOutputStream(classPathJar);\n       bos \u003d new BufferedOutputStream(fos);\n       jos \u003d new JarOutputStream(bos, jarManifest);\n     } finally {\n       IOUtils.cleanup(LOG, jos, bos, fos);\n     }\n     String[] jarCp \u003d {classPathJar.getCanonicalPath(),\n                         unexpandedWildcardClasspath.toString()};\n     return jarCp;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static String[] createJarWithClassPath(String inputClassPath, Path pwd,\n      Path targetDir,\n      Map\u003cString, String\u003e callerEnv) throws IOException {\n    // Replace environment variables, case-insensitive on Windows\n    @SuppressWarnings(\"unchecked\")\n    Map\u003cString, String\u003e env \u003d Shell.WINDOWS ? new CaseInsensitiveMap(callerEnv) :\n      callerEnv;\n    String[] classPathEntries \u003d inputClassPath.split(File.pathSeparator);\n    for (int i \u003d 0; i \u003c classPathEntries.length; ++i) {\n      classPathEntries[i] \u003d StringUtils.replaceTokens(classPathEntries[i],\n        StringUtils.ENV_VAR_PATTERN, env);\n    }\n    File workingDir \u003d new File(pwd.toString());\n    if (!workingDir.mkdirs()) {\n      // If mkdirs returns false because the working directory already exists,\n      // then this is acceptable.  If it returns false due to some other I/O\n      // error, then this method will fail later with an IOException while saving\n      // the jar.\n      LOG.debug(\"mkdirs false for \" + workingDir + \", execution will continue\");\n    }\n\n    StringBuilder unexpandedWildcardClasspath \u003d new StringBuilder();\n    // Append all entries\n    List\u003cString\u003e classPathEntryList \u003d new ArrayList\u003cString\u003e(\n      classPathEntries.length);\n    for (String classPathEntry: classPathEntries) {\n      if (classPathEntry.length() \u003d\u003d 0) {\n        continue;\n      }\n      if (classPathEntry.endsWith(\"*\")) {\n        boolean foundWildCardJar \u003d false;\n        // Append all jars that match the wildcard\n        Path globPath \u003d new Path(classPathEntry).suffix(\"{.jar,.JAR}\");\n        FileStatus[] wildcardJars \u003d FileContext.getLocalFSFileContext().util()\n          .globStatus(globPath);\n        if (wildcardJars !\u003d null) {\n          for (FileStatus wildcardJar: wildcardJars) {\n            foundWildCardJar \u003d true;\n            classPathEntryList.add(wildcardJar.getPath().toUri().toURL()\n              .toExternalForm());\n          }\n        }\n        if (!foundWildCardJar) {\n          unexpandedWildcardClasspath.append(File.pathSeparator);\n          unexpandedWildcardClasspath.append(classPathEntry);\n        }\n      } else {\n        // Append just this entry\n        File fileCpEntry \u003d null;\n        if(!new Path(classPathEntry).isAbsolute()) {\n          fileCpEntry \u003d new File(targetDir.toString(), classPathEntry);\n        }\n        else {\n          fileCpEntry \u003d new File(classPathEntry);\n        }\n        String classPathEntryUrl \u003d fileCpEntry.toURI().toURL()\n          .toExternalForm();\n\n        // File.toURI only appends trailing \u0027/\u0027 if it can determine that it is a\n        // directory that already exists.  (See JavaDocs.)  If this entry had a\n        // trailing \u0027/\u0027 specified by the caller, then guarantee that the\n        // classpath entry in the manifest has a trailing \u0027/\u0027, and thus refers to\n        // a directory instead of a file.  This can happen if the caller is\n        // creating a classpath jar referencing a directory that hasn\u0027t been\n        // created yet, but will definitely be created before running.\n        if (classPathEntry.endsWith(Path.SEPARATOR) \u0026\u0026\n            !classPathEntryUrl.endsWith(Path.SEPARATOR)) {\n          classPathEntryUrl \u003d classPathEntryUrl + Path.SEPARATOR;\n        }\n        classPathEntryList.add(classPathEntryUrl);\n      }\n    }\n    String jarClassPath \u003d StringUtils.join(\" \", classPathEntryList);\n\n    // Create the manifest\n    Manifest jarManifest \u003d new Manifest();\n    jarManifest.getMainAttributes().putValue(\n        Attributes.Name.MANIFEST_VERSION.toString(), \"1.0\");\n    jarManifest.getMainAttributes().putValue(\n        Attributes.Name.CLASS_PATH.toString(), jarClassPath);\n\n    // Write the manifest to output JAR file\n    File classPathJar \u003d File.createTempFile(\"classpath-\", \".jar\", workingDir);\n    FileOutputStream fos \u003d null;\n    BufferedOutputStream bos \u003d null;\n    JarOutputStream jos \u003d null;\n    try {\n      fos \u003d new FileOutputStream(classPathJar);\n      bos \u003d new BufferedOutputStream(fos);\n      jos \u003d new JarOutputStream(bos, jarManifest);\n    } finally {\n      IOUtils.cleanup(LOG, jos, bos, fos);\n    }\n    String[] jarCp \u003d {classPathJar.getCanonicalPath(),\n                        unexpandedWildcardClasspath.toString()};\n    return jarCp;\n  }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/FileUtil.java",
          "extendedDetails": {
            "oldValue": "[inputClassPath-String, pwd-Path, callerEnv-Map\u003cString,String\u003e]",
            "newValue": "[inputClassPath-String, pwd-Path, targetDir-Path, callerEnv-Map\u003cString,String\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-2198. Remove the need to run NodeManager as privileged account for Windows Secure Container Executor. Contributed by Remus Rusanu\n",
          "commitDate": "22/10/14 3:57 PM",
          "commitName": "3b12fd6cfbf4cc91ef8e8616c7aafa9de006cde5",
          "commitAuthor": "Jian He",
          "commitDateOld": "21/10/14 12:33 PM",
          "commitNameOld": "6637e3cf95b3a9be8d6b9cd66bc849a0607e8ed5",
          "commitAuthorOld": "cnauroth",
          "daysBetweenCommits": 1.14,
          "commitsBetweenForRepo": 17,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,96 +1,97 @@\n   public static String[] createJarWithClassPath(String inputClassPath, Path pwd,\n+      Path targetDir,\n       Map\u003cString, String\u003e callerEnv) throws IOException {\n     // Replace environment variables, case-insensitive on Windows\n     @SuppressWarnings(\"unchecked\")\n     Map\u003cString, String\u003e env \u003d Shell.WINDOWS ? new CaseInsensitiveMap(callerEnv) :\n       callerEnv;\n     String[] classPathEntries \u003d inputClassPath.split(File.pathSeparator);\n     for (int i \u003d 0; i \u003c classPathEntries.length; ++i) {\n       classPathEntries[i] \u003d StringUtils.replaceTokens(classPathEntries[i],\n         StringUtils.ENV_VAR_PATTERN, env);\n     }\n     File workingDir \u003d new File(pwd.toString());\n     if (!workingDir.mkdirs()) {\n       // If mkdirs returns false because the working directory already exists,\n       // then this is acceptable.  If it returns false due to some other I/O\n       // error, then this method will fail later with an IOException while saving\n       // the jar.\n       LOG.debug(\"mkdirs false for \" + workingDir + \", execution will continue\");\n     }\n \n     StringBuilder unexpandedWildcardClasspath \u003d new StringBuilder();\n     // Append all entries\n     List\u003cString\u003e classPathEntryList \u003d new ArrayList\u003cString\u003e(\n       classPathEntries.length);\n     for (String classPathEntry: classPathEntries) {\n       if (classPathEntry.length() \u003d\u003d 0) {\n         continue;\n       }\n       if (classPathEntry.endsWith(\"*\")) {\n         boolean foundWildCardJar \u003d false;\n         // Append all jars that match the wildcard\n         Path globPath \u003d new Path(classPathEntry).suffix(\"{.jar,.JAR}\");\n         FileStatus[] wildcardJars \u003d FileContext.getLocalFSFileContext().util()\n           .globStatus(globPath);\n         if (wildcardJars !\u003d null) {\n           for (FileStatus wildcardJar: wildcardJars) {\n             foundWildCardJar \u003d true;\n             classPathEntryList.add(wildcardJar.getPath().toUri().toURL()\n               .toExternalForm());\n           }\n         }\n         if (!foundWildCardJar) {\n           unexpandedWildcardClasspath.append(File.pathSeparator);\n           unexpandedWildcardClasspath.append(classPathEntry);\n         }\n       } else {\n         // Append just this entry\n         File fileCpEntry \u003d null;\n         if(!new Path(classPathEntry).isAbsolute()) {\n-          fileCpEntry \u003d new File(workingDir, classPathEntry);\n+          fileCpEntry \u003d new File(targetDir.toString(), classPathEntry);\n         }\n         else {\n           fileCpEntry \u003d new File(classPathEntry);\n         }\n         String classPathEntryUrl \u003d fileCpEntry.toURI().toURL()\n           .toExternalForm();\n \n         // File.toURI only appends trailing \u0027/\u0027 if it can determine that it is a\n         // directory that already exists.  (See JavaDocs.)  If this entry had a\n         // trailing \u0027/\u0027 specified by the caller, then guarantee that the\n         // classpath entry in the manifest has a trailing \u0027/\u0027, and thus refers to\n         // a directory instead of a file.  This can happen if the caller is\n         // creating a classpath jar referencing a directory that hasn\u0027t been\n         // created yet, but will definitely be created before running.\n         if (classPathEntry.endsWith(Path.SEPARATOR) \u0026\u0026\n             !classPathEntryUrl.endsWith(Path.SEPARATOR)) {\n           classPathEntryUrl \u003d classPathEntryUrl + Path.SEPARATOR;\n         }\n         classPathEntryList.add(classPathEntryUrl);\n       }\n     }\n     String jarClassPath \u003d StringUtils.join(\" \", classPathEntryList);\n \n     // Create the manifest\n     Manifest jarManifest \u003d new Manifest();\n     jarManifest.getMainAttributes().putValue(\n         Attributes.Name.MANIFEST_VERSION.toString(), \"1.0\");\n     jarManifest.getMainAttributes().putValue(\n         Attributes.Name.CLASS_PATH.toString(), jarClassPath);\n \n     // Write the manifest to output JAR file\n     File classPathJar \u003d File.createTempFile(\"classpath-\", \".jar\", workingDir);\n     FileOutputStream fos \u003d null;\n     BufferedOutputStream bos \u003d null;\n     JarOutputStream jos \u003d null;\n     try {\n       fos \u003d new FileOutputStream(classPathJar);\n       bos \u003d new BufferedOutputStream(fos);\n       jos \u003d new JarOutputStream(bos, jarManifest);\n     } finally {\n       IOUtils.cleanup(LOG, jos, bos, fos);\n     }\n     String[] jarCp \u003d {classPathJar.getCanonicalPath(),\n                         unexpandedWildcardClasspath.toString()};\n     return jarCp;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static String[] createJarWithClassPath(String inputClassPath, Path pwd,\n      Path targetDir,\n      Map\u003cString, String\u003e callerEnv) throws IOException {\n    // Replace environment variables, case-insensitive on Windows\n    @SuppressWarnings(\"unchecked\")\n    Map\u003cString, String\u003e env \u003d Shell.WINDOWS ? new CaseInsensitiveMap(callerEnv) :\n      callerEnv;\n    String[] classPathEntries \u003d inputClassPath.split(File.pathSeparator);\n    for (int i \u003d 0; i \u003c classPathEntries.length; ++i) {\n      classPathEntries[i] \u003d StringUtils.replaceTokens(classPathEntries[i],\n        StringUtils.ENV_VAR_PATTERN, env);\n    }\n    File workingDir \u003d new File(pwd.toString());\n    if (!workingDir.mkdirs()) {\n      // If mkdirs returns false because the working directory already exists,\n      // then this is acceptable.  If it returns false due to some other I/O\n      // error, then this method will fail later with an IOException while saving\n      // the jar.\n      LOG.debug(\"mkdirs false for \" + workingDir + \", execution will continue\");\n    }\n\n    StringBuilder unexpandedWildcardClasspath \u003d new StringBuilder();\n    // Append all entries\n    List\u003cString\u003e classPathEntryList \u003d new ArrayList\u003cString\u003e(\n      classPathEntries.length);\n    for (String classPathEntry: classPathEntries) {\n      if (classPathEntry.length() \u003d\u003d 0) {\n        continue;\n      }\n      if (classPathEntry.endsWith(\"*\")) {\n        boolean foundWildCardJar \u003d false;\n        // Append all jars that match the wildcard\n        Path globPath \u003d new Path(classPathEntry).suffix(\"{.jar,.JAR}\");\n        FileStatus[] wildcardJars \u003d FileContext.getLocalFSFileContext().util()\n          .globStatus(globPath);\n        if (wildcardJars !\u003d null) {\n          for (FileStatus wildcardJar: wildcardJars) {\n            foundWildCardJar \u003d true;\n            classPathEntryList.add(wildcardJar.getPath().toUri().toURL()\n              .toExternalForm());\n          }\n        }\n        if (!foundWildCardJar) {\n          unexpandedWildcardClasspath.append(File.pathSeparator);\n          unexpandedWildcardClasspath.append(classPathEntry);\n        }\n      } else {\n        // Append just this entry\n        File fileCpEntry \u003d null;\n        if(!new Path(classPathEntry).isAbsolute()) {\n          fileCpEntry \u003d new File(targetDir.toString(), classPathEntry);\n        }\n        else {\n          fileCpEntry \u003d new File(classPathEntry);\n        }\n        String classPathEntryUrl \u003d fileCpEntry.toURI().toURL()\n          .toExternalForm();\n\n        // File.toURI only appends trailing \u0027/\u0027 if it can determine that it is a\n        // directory that already exists.  (See JavaDocs.)  If this entry had a\n        // trailing \u0027/\u0027 specified by the caller, then guarantee that the\n        // classpath entry in the manifest has a trailing \u0027/\u0027, and thus refers to\n        // a directory instead of a file.  This can happen if the caller is\n        // creating a classpath jar referencing a directory that hasn\u0027t been\n        // created yet, but will definitely be created before running.\n        if (classPathEntry.endsWith(Path.SEPARATOR) \u0026\u0026\n            !classPathEntryUrl.endsWith(Path.SEPARATOR)) {\n          classPathEntryUrl \u003d classPathEntryUrl + Path.SEPARATOR;\n        }\n        classPathEntryList.add(classPathEntryUrl);\n      }\n    }\n    String jarClassPath \u003d StringUtils.join(\" \", classPathEntryList);\n\n    // Create the manifest\n    Manifest jarManifest \u003d new Manifest();\n    jarManifest.getMainAttributes().putValue(\n        Attributes.Name.MANIFEST_VERSION.toString(), \"1.0\");\n    jarManifest.getMainAttributes().putValue(\n        Attributes.Name.CLASS_PATH.toString(), jarClassPath);\n\n    // Write the manifest to output JAR file\n    File classPathJar \u003d File.createTempFile(\"classpath-\", \".jar\", workingDir);\n    FileOutputStream fos \u003d null;\n    BufferedOutputStream bos \u003d null;\n    JarOutputStream jos \u003d null;\n    try {\n      fos \u003d new FileOutputStream(classPathJar);\n      bos \u003d new BufferedOutputStream(fos);\n      jos \u003d new JarOutputStream(bos, jarManifest);\n    } finally {\n      IOUtils.cleanup(LOG, jos, bos, fos);\n    }\n    String[] jarCp \u003d {classPathJar.getCanonicalPath(),\n                        unexpandedWildcardClasspath.toString()};\n    return jarCp;\n  }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/FileUtil.java",
          "extendedDetails": {}
        }
      ]
    },
    "6637e3cf95b3a9be8d6b9cd66bc849a0607e8ed5": {
      "type": "Ymultichange(Yreturntypechange,Ybodychange)",
      "commitMessage": "YARN-2720. Windows: Wildcard classpath variables not expanded against resources contained in archives. Contributed by Craig Welch.\n",
      "commitDate": "21/10/14 12:33 PM",
      "commitName": "6637e3cf95b3a9be8d6b9cd66bc849a0607e8ed5",
      "commitAuthor": "cnauroth",
      "subchanges": [
        {
          "type": "Yreturntypechange",
          "commitMessage": "YARN-2720. Windows: Wildcard classpath variables not expanded against resources contained in archives. Contributed by Craig Welch.\n",
          "commitDate": "21/10/14 12:33 PM",
          "commitName": "6637e3cf95b3a9be8d6b9cd66bc849a0607e8ed5",
          "commitAuthor": "cnauroth",
          "commitDateOld": "08/10/14 3:36 PM",
          "commitNameOld": "a1690519317068d9855174752d22ff45f0e4c962",
          "commitAuthorOld": "Zhijie Shen",
          "daysBetweenCommits": 12.87,
          "commitsBetweenForRepo": 93,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,88 +1,96 @@\n-  public static String createJarWithClassPath(String inputClassPath, Path pwd,\n+  public static String[] createJarWithClassPath(String inputClassPath, Path pwd,\n       Map\u003cString, String\u003e callerEnv) throws IOException {\n     // Replace environment variables, case-insensitive on Windows\n     @SuppressWarnings(\"unchecked\")\n     Map\u003cString, String\u003e env \u003d Shell.WINDOWS ? new CaseInsensitiveMap(callerEnv) :\n       callerEnv;\n     String[] classPathEntries \u003d inputClassPath.split(File.pathSeparator);\n     for (int i \u003d 0; i \u003c classPathEntries.length; ++i) {\n       classPathEntries[i] \u003d StringUtils.replaceTokens(classPathEntries[i],\n         StringUtils.ENV_VAR_PATTERN, env);\n     }\n     File workingDir \u003d new File(pwd.toString());\n     if (!workingDir.mkdirs()) {\n       // If mkdirs returns false because the working directory already exists,\n       // then this is acceptable.  If it returns false due to some other I/O\n       // error, then this method will fail later with an IOException while saving\n       // the jar.\n       LOG.debug(\"mkdirs false for \" + workingDir + \", execution will continue\");\n     }\n \n+    StringBuilder unexpandedWildcardClasspath \u003d new StringBuilder();\n     // Append all entries\n     List\u003cString\u003e classPathEntryList \u003d new ArrayList\u003cString\u003e(\n       classPathEntries.length);\n     for (String classPathEntry: classPathEntries) {\n       if (classPathEntry.length() \u003d\u003d 0) {\n         continue;\n       }\n       if (classPathEntry.endsWith(\"*\")) {\n+        boolean foundWildCardJar \u003d false;\n         // Append all jars that match the wildcard\n         Path globPath \u003d new Path(classPathEntry).suffix(\"{.jar,.JAR}\");\n         FileStatus[] wildcardJars \u003d FileContext.getLocalFSFileContext().util()\n           .globStatus(globPath);\n         if (wildcardJars !\u003d null) {\n           for (FileStatus wildcardJar: wildcardJars) {\n+            foundWildCardJar \u003d true;\n             classPathEntryList.add(wildcardJar.getPath().toUri().toURL()\n               .toExternalForm());\n           }\n         }\n+        if (!foundWildCardJar) {\n+          unexpandedWildcardClasspath.append(File.pathSeparator);\n+          unexpandedWildcardClasspath.append(classPathEntry);\n+        }\n       } else {\n         // Append just this entry\n         File fileCpEntry \u003d null;\n         if(!new Path(classPathEntry).isAbsolute()) {\n           fileCpEntry \u003d new File(workingDir, classPathEntry);\n         }\n         else {\n           fileCpEntry \u003d new File(classPathEntry);\n         }\n         String classPathEntryUrl \u003d fileCpEntry.toURI().toURL()\n           .toExternalForm();\n \n         // File.toURI only appends trailing \u0027/\u0027 if it can determine that it is a\n         // directory that already exists.  (See JavaDocs.)  If this entry had a\n         // trailing \u0027/\u0027 specified by the caller, then guarantee that the\n         // classpath entry in the manifest has a trailing \u0027/\u0027, and thus refers to\n         // a directory instead of a file.  This can happen if the caller is\n         // creating a classpath jar referencing a directory that hasn\u0027t been\n         // created yet, but will definitely be created before running.\n         if (classPathEntry.endsWith(Path.SEPARATOR) \u0026\u0026\n             !classPathEntryUrl.endsWith(Path.SEPARATOR)) {\n           classPathEntryUrl \u003d classPathEntryUrl + Path.SEPARATOR;\n         }\n         classPathEntryList.add(classPathEntryUrl);\n       }\n     }\n     String jarClassPath \u003d StringUtils.join(\" \", classPathEntryList);\n \n     // Create the manifest\n     Manifest jarManifest \u003d new Manifest();\n     jarManifest.getMainAttributes().putValue(\n         Attributes.Name.MANIFEST_VERSION.toString(), \"1.0\");\n     jarManifest.getMainAttributes().putValue(\n         Attributes.Name.CLASS_PATH.toString(), jarClassPath);\n \n     // Write the manifest to output JAR file\n     File classPathJar \u003d File.createTempFile(\"classpath-\", \".jar\", workingDir);\n     FileOutputStream fos \u003d null;\n     BufferedOutputStream bos \u003d null;\n     JarOutputStream jos \u003d null;\n     try {\n       fos \u003d new FileOutputStream(classPathJar);\n       bos \u003d new BufferedOutputStream(fos);\n       jos \u003d new JarOutputStream(bos, jarManifest);\n     } finally {\n       IOUtils.cleanup(LOG, jos, bos, fos);\n     }\n-\n-    return classPathJar.getCanonicalPath();\n+    String[] jarCp \u003d {classPathJar.getCanonicalPath(),\n+                        unexpandedWildcardClasspath.toString()};\n+    return jarCp;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static String[] createJarWithClassPath(String inputClassPath, Path pwd,\n      Map\u003cString, String\u003e callerEnv) throws IOException {\n    // Replace environment variables, case-insensitive on Windows\n    @SuppressWarnings(\"unchecked\")\n    Map\u003cString, String\u003e env \u003d Shell.WINDOWS ? new CaseInsensitiveMap(callerEnv) :\n      callerEnv;\n    String[] classPathEntries \u003d inputClassPath.split(File.pathSeparator);\n    for (int i \u003d 0; i \u003c classPathEntries.length; ++i) {\n      classPathEntries[i] \u003d StringUtils.replaceTokens(classPathEntries[i],\n        StringUtils.ENV_VAR_PATTERN, env);\n    }\n    File workingDir \u003d new File(pwd.toString());\n    if (!workingDir.mkdirs()) {\n      // If mkdirs returns false because the working directory already exists,\n      // then this is acceptable.  If it returns false due to some other I/O\n      // error, then this method will fail later with an IOException while saving\n      // the jar.\n      LOG.debug(\"mkdirs false for \" + workingDir + \", execution will continue\");\n    }\n\n    StringBuilder unexpandedWildcardClasspath \u003d new StringBuilder();\n    // Append all entries\n    List\u003cString\u003e classPathEntryList \u003d new ArrayList\u003cString\u003e(\n      classPathEntries.length);\n    for (String classPathEntry: classPathEntries) {\n      if (classPathEntry.length() \u003d\u003d 0) {\n        continue;\n      }\n      if (classPathEntry.endsWith(\"*\")) {\n        boolean foundWildCardJar \u003d false;\n        // Append all jars that match the wildcard\n        Path globPath \u003d new Path(classPathEntry).suffix(\"{.jar,.JAR}\");\n        FileStatus[] wildcardJars \u003d FileContext.getLocalFSFileContext().util()\n          .globStatus(globPath);\n        if (wildcardJars !\u003d null) {\n          for (FileStatus wildcardJar: wildcardJars) {\n            foundWildCardJar \u003d true;\n            classPathEntryList.add(wildcardJar.getPath().toUri().toURL()\n              .toExternalForm());\n          }\n        }\n        if (!foundWildCardJar) {\n          unexpandedWildcardClasspath.append(File.pathSeparator);\n          unexpandedWildcardClasspath.append(classPathEntry);\n        }\n      } else {\n        // Append just this entry\n        File fileCpEntry \u003d null;\n        if(!new Path(classPathEntry).isAbsolute()) {\n          fileCpEntry \u003d new File(workingDir, classPathEntry);\n        }\n        else {\n          fileCpEntry \u003d new File(classPathEntry);\n        }\n        String classPathEntryUrl \u003d fileCpEntry.toURI().toURL()\n          .toExternalForm();\n\n        // File.toURI only appends trailing \u0027/\u0027 if it can determine that it is a\n        // directory that already exists.  (See JavaDocs.)  If this entry had a\n        // trailing \u0027/\u0027 specified by the caller, then guarantee that the\n        // classpath entry in the manifest has a trailing \u0027/\u0027, and thus refers to\n        // a directory instead of a file.  This can happen if the caller is\n        // creating a classpath jar referencing a directory that hasn\u0027t been\n        // created yet, but will definitely be created before running.\n        if (classPathEntry.endsWith(Path.SEPARATOR) \u0026\u0026\n            !classPathEntryUrl.endsWith(Path.SEPARATOR)) {\n          classPathEntryUrl \u003d classPathEntryUrl + Path.SEPARATOR;\n        }\n        classPathEntryList.add(classPathEntryUrl);\n      }\n    }\n    String jarClassPath \u003d StringUtils.join(\" \", classPathEntryList);\n\n    // Create the manifest\n    Manifest jarManifest \u003d new Manifest();\n    jarManifest.getMainAttributes().putValue(\n        Attributes.Name.MANIFEST_VERSION.toString(), \"1.0\");\n    jarManifest.getMainAttributes().putValue(\n        Attributes.Name.CLASS_PATH.toString(), jarClassPath);\n\n    // Write the manifest to output JAR file\n    File classPathJar \u003d File.createTempFile(\"classpath-\", \".jar\", workingDir);\n    FileOutputStream fos \u003d null;\n    BufferedOutputStream bos \u003d null;\n    JarOutputStream jos \u003d null;\n    try {\n      fos \u003d new FileOutputStream(classPathJar);\n      bos \u003d new BufferedOutputStream(fos);\n      jos \u003d new JarOutputStream(bos, jarManifest);\n    } finally {\n      IOUtils.cleanup(LOG, jos, bos, fos);\n    }\n    String[] jarCp \u003d {classPathJar.getCanonicalPath(),\n                        unexpandedWildcardClasspath.toString()};\n    return jarCp;\n  }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/FileUtil.java",
          "extendedDetails": {
            "oldValue": "String",
            "newValue": "String[]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-2720. Windows: Wildcard classpath variables not expanded against resources contained in archives. Contributed by Craig Welch.\n",
          "commitDate": "21/10/14 12:33 PM",
          "commitName": "6637e3cf95b3a9be8d6b9cd66bc849a0607e8ed5",
          "commitAuthor": "cnauroth",
          "commitDateOld": "08/10/14 3:36 PM",
          "commitNameOld": "a1690519317068d9855174752d22ff45f0e4c962",
          "commitAuthorOld": "Zhijie Shen",
          "daysBetweenCommits": 12.87,
          "commitsBetweenForRepo": 93,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,88 +1,96 @@\n-  public static String createJarWithClassPath(String inputClassPath, Path pwd,\n+  public static String[] createJarWithClassPath(String inputClassPath, Path pwd,\n       Map\u003cString, String\u003e callerEnv) throws IOException {\n     // Replace environment variables, case-insensitive on Windows\n     @SuppressWarnings(\"unchecked\")\n     Map\u003cString, String\u003e env \u003d Shell.WINDOWS ? new CaseInsensitiveMap(callerEnv) :\n       callerEnv;\n     String[] classPathEntries \u003d inputClassPath.split(File.pathSeparator);\n     for (int i \u003d 0; i \u003c classPathEntries.length; ++i) {\n       classPathEntries[i] \u003d StringUtils.replaceTokens(classPathEntries[i],\n         StringUtils.ENV_VAR_PATTERN, env);\n     }\n     File workingDir \u003d new File(pwd.toString());\n     if (!workingDir.mkdirs()) {\n       // If mkdirs returns false because the working directory already exists,\n       // then this is acceptable.  If it returns false due to some other I/O\n       // error, then this method will fail later with an IOException while saving\n       // the jar.\n       LOG.debug(\"mkdirs false for \" + workingDir + \", execution will continue\");\n     }\n \n+    StringBuilder unexpandedWildcardClasspath \u003d new StringBuilder();\n     // Append all entries\n     List\u003cString\u003e classPathEntryList \u003d new ArrayList\u003cString\u003e(\n       classPathEntries.length);\n     for (String classPathEntry: classPathEntries) {\n       if (classPathEntry.length() \u003d\u003d 0) {\n         continue;\n       }\n       if (classPathEntry.endsWith(\"*\")) {\n+        boolean foundWildCardJar \u003d false;\n         // Append all jars that match the wildcard\n         Path globPath \u003d new Path(classPathEntry).suffix(\"{.jar,.JAR}\");\n         FileStatus[] wildcardJars \u003d FileContext.getLocalFSFileContext().util()\n           .globStatus(globPath);\n         if (wildcardJars !\u003d null) {\n           for (FileStatus wildcardJar: wildcardJars) {\n+            foundWildCardJar \u003d true;\n             classPathEntryList.add(wildcardJar.getPath().toUri().toURL()\n               .toExternalForm());\n           }\n         }\n+        if (!foundWildCardJar) {\n+          unexpandedWildcardClasspath.append(File.pathSeparator);\n+          unexpandedWildcardClasspath.append(classPathEntry);\n+        }\n       } else {\n         // Append just this entry\n         File fileCpEntry \u003d null;\n         if(!new Path(classPathEntry).isAbsolute()) {\n           fileCpEntry \u003d new File(workingDir, classPathEntry);\n         }\n         else {\n           fileCpEntry \u003d new File(classPathEntry);\n         }\n         String classPathEntryUrl \u003d fileCpEntry.toURI().toURL()\n           .toExternalForm();\n \n         // File.toURI only appends trailing \u0027/\u0027 if it can determine that it is a\n         // directory that already exists.  (See JavaDocs.)  If this entry had a\n         // trailing \u0027/\u0027 specified by the caller, then guarantee that the\n         // classpath entry in the manifest has a trailing \u0027/\u0027, and thus refers to\n         // a directory instead of a file.  This can happen if the caller is\n         // creating a classpath jar referencing a directory that hasn\u0027t been\n         // created yet, but will definitely be created before running.\n         if (classPathEntry.endsWith(Path.SEPARATOR) \u0026\u0026\n             !classPathEntryUrl.endsWith(Path.SEPARATOR)) {\n           classPathEntryUrl \u003d classPathEntryUrl + Path.SEPARATOR;\n         }\n         classPathEntryList.add(classPathEntryUrl);\n       }\n     }\n     String jarClassPath \u003d StringUtils.join(\" \", classPathEntryList);\n \n     // Create the manifest\n     Manifest jarManifest \u003d new Manifest();\n     jarManifest.getMainAttributes().putValue(\n         Attributes.Name.MANIFEST_VERSION.toString(), \"1.0\");\n     jarManifest.getMainAttributes().putValue(\n         Attributes.Name.CLASS_PATH.toString(), jarClassPath);\n \n     // Write the manifest to output JAR file\n     File classPathJar \u003d File.createTempFile(\"classpath-\", \".jar\", workingDir);\n     FileOutputStream fos \u003d null;\n     BufferedOutputStream bos \u003d null;\n     JarOutputStream jos \u003d null;\n     try {\n       fos \u003d new FileOutputStream(classPathJar);\n       bos \u003d new BufferedOutputStream(fos);\n       jos \u003d new JarOutputStream(bos, jarManifest);\n     } finally {\n       IOUtils.cleanup(LOG, jos, bos, fos);\n     }\n-\n-    return classPathJar.getCanonicalPath();\n+    String[] jarCp \u003d {classPathJar.getCanonicalPath(),\n+                        unexpandedWildcardClasspath.toString()};\n+    return jarCp;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static String[] createJarWithClassPath(String inputClassPath, Path pwd,\n      Map\u003cString, String\u003e callerEnv) throws IOException {\n    // Replace environment variables, case-insensitive on Windows\n    @SuppressWarnings(\"unchecked\")\n    Map\u003cString, String\u003e env \u003d Shell.WINDOWS ? new CaseInsensitiveMap(callerEnv) :\n      callerEnv;\n    String[] classPathEntries \u003d inputClassPath.split(File.pathSeparator);\n    for (int i \u003d 0; i \u003c classPathEntries.length; ++i) {\n      classPathEntries[i] \u003d StringUtils.replaceTokens(classPathEntries[i],\n        StringUtils.ENV_VAR_PATTERN, env);\n    }\n    File workingDir \u003d new File(pwd.toString());\n    if (!workingDir.mkdirs()) {\n      // If mkdirs returns false because the working directory already exists,\n      // then this is acceptable.  If it returns false due to some other I/O\n      // error, then this method will fail later with an IOException while saving\n      // the jar.\n      LOG.debug(\"mkdirs false for \" + workingDir + \", execution will continue\");\n    }\n\n    StringBuilder unexpandedWildcardClasspath \u003d new StringBuilder();\n    // Append all entries\n    List\u003cString\u003e classPathEntryList \u003d new ArrayList\u003cString\u003e(\n      classPathEntries.length);\n    for (String classPathEntry: classPathEntries) {\n      if (classPathEntry.length() \u003d\u003d 0) {\n        continue;\n      }\n      if (classPathEntry.endsWith(\"*\")) {\n        boolean foundWildCardJar \u003d false;\n        // Append all jars that match the wildcard\n        Path globPath \u003d new Path(classPathEntry).suffix(\"{.jar,.JAR}\");\n        FileStatus[] wildcardJars \u003d FileContext.getLocalFSFileContext().util()\n          .globStatus(globPath);\n        if (wildcardJars !\u003d null) {\n          for (FileStatus wildcardJar: wildcardJars) {\n            foundWildCardJar \u003d true;\n            classPathEntryList.add(wildcardJar.getPath().toUri().toURL()\n              .toExternalForm());\n          }\n        }\n        if (!foundWildCardJar) {\n          unexpandedWildcardClasspath.append(File.pathSeparator);\n          unexpandedWildcardClasspath.append(classPathEntry);\n        }\n      } else {\n        // Append just this entry\n        File fileCpEntry \u003d null;\n        if(!new Path(classPathEntry).isAbsolute()) {\n          fileCpEntry \u003d new File(workingDir, classPathEntry);\n        }\n        else {\n          fileCpEntry \u003d new File(classPathEntry);\n        }\n        String classPathEntryUrl \u003d fileCpEntry.toURI().toURL()\n          .toExternalForm();\n\n        // File.toURI only appends trailing \u0027/\u0027 if it can determine that it is a\n        // directory that already exists.  (See JavaDocs.)  If this entry had a\n        // trailing \u0027/\u0027 specified by the caller, then guarantee that the\n        // classpath entry in the manifest has a trailing \u0027/\u0027, and thus refers to\n        // a directory instead of a file.  This can happen if the caller is\n        // creating a classpath jar referencing a directory that hasn\u0027t been\n        // created yet, but will definitely be created before running.\n        if (classPathEntry.endsWith(Path.SEPARATOR) \u0026\u0026\n            !classPathEntryUrl.endsWith(Path.SEPARATOR)) {\n          classPathEntryUrl \u003d classPathEntryUrl + Path.SEPARATOR;\n        }\n        classPathEntryList.add(classPathEntryUrl);\n      }\n    }\n    String jarClassPath \u003d StringUtils.join(\" \", classPathEntryList);\n\n    // Create the manifest\n    Manifest jarManifest \u003d new Manifest();\n    jarManifest.getMainAttributes().putValue(\n        Attributes.Name.MANIFEST_VERSION.toString(), \"1.0\");\n    jarManifest.getMainAttributes().putValue(\n        Attributes.Name.CLASS_PATH.toString(), jarClassPath);\n\n    // Write the manifest to output JAR file\n    File classPathJar \u003d File.createTempFile(\"classpath-\", \".jar\", workingDir);\n    FileOutputStream fos \u003d null;\n    BufferedOutputStream bos \u003d null;\n    JarOutputStream jos \u003d null;\n    try {\n      fos \u003d new FileOutputStream(classPathJar);\n      bos \u003d new BufferedOutputStream(fos);\n      jos \u003d new JarOutputStream(bos, jarManifest);\n    } finally {\n      IOUtils.cleanup(LOG, jos, bos, fos);\n    }\n    String[] jarCp \u003d {classPathJar.getCanonicalPath(),\n                        unexpandedWildcardClasspath.toString()};\n    return jarCp;\n  }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/FileUtil.java",
          "extendedDetails": {}
        }
      ]
    },
    "40cf0068d8aae2c50c90e0661aaa1170a4c03e42": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9924. Addendum patch to address issue with an empty classpath entry on Windows. Contributed by Shanyu Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1520903 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/09/13 12:51 PM",
      "commitName": "40cf0068d8aae2c50c90e0661aaa1170a4c03e42",
      "commitAuthor": "Ivan Mitic",
      "commitDateOld": "03/09/13 6:16 PM",
      "commitNameOld": "b87bcbb82dac4f0a0ca7e436998ed0a3d1b4bb21",
      "commitAuthorOld": "Ivan Mitic",
      "daysBetweenCommits": 4.77,
      "commitsBetweenForRepo": 21,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,85 +1,88 @@\n   public static String createJarWithClassPath(String inputClassPath, Path pwd,\n       Map\u003cString, String\u003e callerEnv) throws IOException {\n     // Replace environment variables, case-insensitive on Windows\n     @SuppressWarnings(\"unchecked\")\n     Map\u003cString, String\u003e env \u003d Shell.WINDOWS ? new CaseInsensitiveMap(callerEnv) :\n       callerEnv;\n     String[] classPathEntries \u003d inputClassPath.split(File.pathSeparator);\n     for (int i \u003d 0; i \u003c classPathEntries.length; ++i) {\n       classPathEntries[i] \u003d StringUtils.replaceTokens(classPathEntries[i],\n         StringUtils.ENV_VAR_PATTERN, env);\n     }\n     File workingDir \u003d new File(pwd.toString());\n     if (!workingDir.mkdirs()) {\n       // If mkdirs returns false because the working directory already exists,\n       // then this is acceptable.  If it returns false due to some other I/O\n       // error, then this method will fail later with an IOException while saving\n       // the jar.\n       LOG.debug(\"mkdirs false for \" + workingDir + \", execution will continue\");\n     }\n \n     // Append all entries\n     List\u003cString\u003e classPathEntryList \u003d new ArrayList\u003cString\u003e(\n       classPathEntries.length);\n     for (String classPathEntry: classPathEntries) {\n+      if (classPathEntry.length() \u003d\u003d 0) {\n+        continue;\n+      }\n       if (classPathEntry.endsWith(\"*\")) {\n         // Append all jars that match the wildcard\n         Path globPath \u003d new Path(classPathEntry).suffix(\"{.jar,.JAR}\");\n         FileStatus[] wildcardJars \u003d FileContext.getLocalFSFileContext().util()\n           .globStatus(globPath);\n         if (wildcardJars !\u003d null) {\n           for (FileStatus wildcardJar: wildcardJars) {\n             classPathEntryList.add(wildcardJar.getPath().toUri().toURL()\n               .toExternalForm());\n           }\n         }\n       } else {\n         // Append just this entry\n         File fileCpEntry \u003d null;\n         if(!new Path(classPathEntry).isAbsolute()) {\n           fileCpEntry \u003d new File(workingDir, classPathEntry);\n         }\n         else {\n           fileCpEntry \u003d new File(classPathEntry);\n         }\n         String classPathEntryUrl \u003d fileCpEntry.toURI().toURL()\n           .toExternalForm();\n \n         // File.toURI only appends trailing \u0027/\u0027 if it can determine that it is a\n         // directory that already exists.  (See JavaDocs.)  If this entry had a\n         // trailing \u0027/\u0027 specified by the caller, then guarantee that the\n         // classpath entry in the manifest has a trailing \u0027/\u0027, and thus refers to\n         // a directory instead of a file.  This can happen if the caller is\n         // creating a classpath jar referencing a directory that hasn\u0027t been\n         // created yet, but will definitely be created before running.\n         if (classPathEntry.endsWith(Path.SEPARATOR) \u0026\u0026\n             !classPathEntryUrl.endsWith(Path.SEPARATOR)) {\n           classPathEntryUrl \u003d classPathEntryUrl + Path.SEPARATOR;\n         }\n         classPathEntryList.add(classPathEntryUrl);\n       }\n     }\n     String jarClassPath \u003d StringUtils.join(\" \", classPathEntryList);\n \n     // Create the manifest\n     Manifest jarManifest \u003d new Manifest();\n     jarManifest.getMainAttributes().putValue(\n         Attributes.Name.MANIFEST_VERSION.toString(), \"1.0\");\n     jarManifest.getMainAttributes().putValue(\n         Attributes.Name.CLASS_PATH.toString(), jarClassPath);\n \n     // Write the manifest to output JAR file\n     File classPathJar \u003d File.createTempFile(\"classpath-\", \".jar\", workingDir);\n     FileOutputStream fos \u003d null;\n     BufferedOutputStream bos \u003d null;\n     JarOutputStream jos \u003d null;\n     try {\n       fos \u003d new FileOutputStream(classPathJar);\n       bos \u003d new BufferedOutputStream(fos);\n       jos \u003d new JarOutputStream(bos, jarManifest);\n     } finally {\n       IOUtils.cleanup(LOG, jos, bos, fos);\n     }\n \n     return classPathJar.getCanonicalPath();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static String createJarWithClassPath(String inputClassPath, Path pwd,\n      Map\u003cString, String\u003e callerEnv) throws IOException {\n    // Replace environment variables, case-insensitive on Windows\n    @SuppressWarnings(\"unchecked\")\n    Map\u003cString, String\u003e env \u003d Shell.WINDOWS ? new CaseInsensitiveMap(callerEnv) :\n      callerEnv;\n    String[] classPathEntries \u003d inputClassPath.split(File.pathSeparator);\n    for (int i \u003d 0; i \u003c classPathEntries.length; ++i) {\n      classPathEntries[i] \u003d StringUtils.replaceTokens(classPathEntries[i],\n        StringUtils.ENV_VAR_PATTERN, env);\n    }\n    File workingDir \u003d new File(pwd.toString());\n    if (!workingDir.mkdirs()) {\n      // If mkdirs returns false because the working directory already exists,\n      // then this is acceptable.  If it returns false due to some other I/O\n      // error, then this method will fail later with an IOException while saving\n      // the jar.\n      LOG.debug(\"mkdirs false for \" + workingDir + \", execution will continue\");\n    }\n\n    // Append all entries\n    List\u003cString\u003e classPathEntryList \u003d new ArrayList\u003cString\u003e(\n      classPathEntries.length);\n    for (String classPathEntry: classPathEntries) {\n      if (classPathEntry.length() \u003d\u003d 0) {\n        continue;\n      }\n      if (classPathEntry.endsWith(\"*\")) {\n        // Append all jars that match the wildcard\n        Path globPath \u003d new Path(classPathEntry).suffix(\"{.jar,.JAR}\");\n        FileStatus[] wildcardJars \u003d FileContext.getLocalFSFileContext().util()\n          .globStatus(globPath);\n        if (wildcardJars !\u003d null) {\n          for (FileStatus wildcardJar: wildcardJars) {\n            classPathEntryList.add(wildcardJar.getPath().toUri().toURL()\n              .toExternalForm());\n          }\n        }\n      } else {\n        // Append just this entry\n        File fileCpEntry \u003d null;\n        if(!new Path(classPathEntry).isAbsolute()) {\n          fileCpEntry \u003d new File(workingDir, classPathEntry);\n        }\n        else {\n          fileCpEntry \u003d new File(classPathEntry);\n        }\n        String classPathEntryUrl \u003d fileCpEntry.toURI().toURL()\n          .toExternalForm();\n\n        // File.toURI only appends trailing \u0027/\u0027 if it can determine that it is a\n        // directory that already exists.  (See JavaDocs.)  If this entry had a\n        // trailing \u0027/\u0027 specified by the caller, then guarantee that the\n        // classpath entry in the manifest has a trailing \u0027/\u0027, and thus refers to\n        // a directory instead of a file.  This can happen if the caller is\n        // creating a classpath jar referencing a directory that hasn\u0027t been\n        // created yet, but will definitely be created before running.\n        if (classPathEntry.endsWith(Path.SEPARATOR) \u0026\u0026\n            !classPathEntryUrl.endsWith(Path.SEPARATOR)) {\n          classPathEntryUrl \u003d classPathEntryUrl + Path.SEPARATOR;\n        }\n        classPathEntryList.add(classPathEntryUrl);\n      }\n    }\n    String jarClassPath \u003d StringUtils.join(\" \", classPathEntryList);\n\n    // Create the manifest\n    Manifest jarManifest \u003d new Manifest();\n    jarManifest.getMainAttributes().putValue(\n        Attributes.Name.MANIFEST_VERSION.toString(), \"1.0\");\n    jarManifest.getMainAttributes().putValue(\n        Attributes.Name.CLASS_PATH.toString(), jarClassPath);\n\n    // Write the manifest to output JAR file\n    File classPathJar \u003d File.createTempFile(\"classpath-\", \".jar\", workingDir);\n    FileOutputStream fos \u003d null;\n    BufferedOutputStream bos \u003d null;\n    JarOutputStream jos \u003d null;\n    try {\n      fos \u003d new FileOutputStream(classPathJar);\n      bos \u003d new BufferedOutputStream(fos);\n      jos \u003d new JarOutputStream(bos, jarManifest);\n    } finally {\n      IOUtils.cleanup(LOG, jos, bos, fos);\n    }\n\n    return classPathJar.getCanonicalPath();\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/FileUtil.java",
      "extendedDetails": {}
    },
    "b87bcbb82dac4f0a0ca7e436998ed0a3d1b4bb21": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9924. FileUtil.createJarWithClassPath() does not generate relative classpath correctly. Contributed by Shanyu Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1519891 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/09/13 6:16 PM",
      "commitName": "b87bcbb82dac4f0a0ca7e436998ed0a3d1b4bb21",
      "commitAuthor": "Ivan Mitic",
      "commitDateOld": "06/08/13 1:35 PM",
      "commitNameOld": "f2942687d44caaaedae98132024f8fc1dc4a884a",
      "commitAuthorOld": "Chris Nauroth",
      "daysBetweenCommits": 28.19,
      "commitsBetweenForRepo": 157,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,78 +1,85 @@\n   public static String createJarWithClassPath(String inputClassPath, Path pwd,\n       Map\u003cString, String\u003e callerEnv) throws IOException {\n     // Replace environment variables, case-insensitive on Windows\n     @SuppressWarnings(\"unchecked\")\n     Map\u003cString, String\u003e env \u003d Shell.WINDOWS ? new CaseInsensitiveMap(callerEnv) :\n       callerEnv;\n     String[] classPathEntries \u003d inputClassPath.split(File.pathSeparator);\n     for (int i \u003d 0; i \u003c classPathEntries.length; ++i) {\n       classPathEntries[i] \u003d StringUtils.replaceTokens(classPathEntries[i],\n         StringUtils.ENV_VAR_PATTERN, env);\n     }\n     File workingDir \u003d new File(pwd.toString());\n     if (!workingDir.mkdirs()) {\n       // If mkdirs returns false because the working directory already exists,\n       // then this is acceptable.  If it returns false due to some other I/O\n       // error, then this method will fail later with an IOException while saving\n       // the jar.\n       LOG.debug(\"mkdirs false for \" + workingDir + \", execution will continue\");\n     }\n \n     // Append all entries\n     List\u003cString\u003e classPathEntryList \u003d new ArrayList\u003cString\u003e(\n       classPathEntries.length);\n     for (String classPathEntry: classPathEntries) {\n       if (classPathEntry.endsWith(\"*\")) {\n         // Append all jars that match the wildcard\n         Path globPath \u003d new Path(classPathEntry).suffix(\"{.jar,.JAR}\");\n         FileStatus[] wildcardJars \u003d FileContext.getLocalFSFileContext().util()\n           .globStatus(globPath);\n         if (wildcardJars !\u003d null) {\n           for (FileStatus wildcardJar: wildcardJars) {\n             classPathEntryList.add(wildcardJar.getPath().toUri().toURL()\n               .toExternalForm());\n           }\n         }\n       } else {\n         // Append just this entry\n-        String classPathEntryUrl \u003d new File(classPathEntry).toURI().toURL()\n+        File fileCpEntry \u003d null;\n+        if(!new Path(classPathEntry).isAbsolute()) {\n+          fileCpEntry \u003d new File(workingDir, classPathEntry);\n+        }\n+        else {\n+          fileCpEntry \u003d new File(classPathEntry);\n+        }\n+        String classPathEntryUrl \u003d fileCpEntry.toURI().toURL()\n           .toExternalForm();\n \n         // File.toURI only appends trailing \u0027/\u0027 if it can determine that it is a\n         // directory that already exists.  (See JavaDocs.)  If this entry had a\n         // trailing \u0027/\u0027 specified by the caller, then guarantee that the\n         // classpath entry in the manifest has a trailing \u0027/\u0027, and thus refers to\n         // a directory instead of a file.  This can happen if the caller is\n         // creating a classpath jar referencing a directory that hasn\u0027t been\n         // created yet, but will definitely be created before running.\n         if (classPathEntry.endsWith(Path.SEPARATOR) \u0026\u0026\n             !classPathEntryUrl.endsWith(Path.SEPARATOR)) {\n           classPathEntryUrl \u003d classPathEntryUrl + Path.SEPARATOR;\n         }\n         classPathEntryList.add(classPathEntryUrl);\n       }\n     }\n     String jarClassPath \u003d StringUtils.join(\" \", classPathEntryList);\n \n     // Create the manifest\n     Manifest jarManifest \u003d new Manifest();\n     jarManifest.getMainAttributes().putValue(\n         Attributes.Name.MANIFEST_VERSION.toString(), \"1.0\");\n     jarManifest.getMainAttributes().putValue(\n         Attributes.Name.CLASS_PATH.toString(), jarClassPath);\n \n     // Write the manifest to output JAR file\n     File classPathJar \u003d File.createTempFile(\"classpath-\", \".jar\", workingDir);\n     FileOutputStream fos \u003d null;\n     BufferedOutputStream bos \u003d null;\n     JarOutputStream jos \u003d null;\n     try {\n       fos \u003d new FileOutputStream(classPathJar);\n       bos \u003d new BufferedOutputStream(fos);\n       jos \u003d new JarOutputStream(bos, jarManifest);\n     } finally {\n       IOUtils.cleanup(LOG, jos, bos, fos);\n     }\n \n     return classPathJar.getCanonicalPath();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static String createJarWithClassPath(String inputClassPath, Path pwd,\n      Map\u003cString, String\u003e callerEnv) throws IOException {\n    // Replace environment variables, case-insensitive on Windows\n    @SuppressWarnings(\"unchecked\")\n    Map\u003cString, String\u003e env \u003d Shell.WINDOWS ? new CaseInsensitiveMap(callerEnv) :\n      callerEnv;\n    String[] classPathEntries \u003d inputClassPath.split(File.pathSeparator);\n    for (int i \u003d 0; i \u003c classPathEntries.length; ++i) {\n      classPathEntries[i] \u003d StringUtils.replaceTokens(classPathEntries[i],\n        StringUtils.ENV_VAR_PATTERN, env);\n    }\n    File workingDir \u003d new File(pwd.toString());\n    if (!workingDir.mkdirs()) {\n      // If mkdirs returns false because the working directory already exists,\n      // then this is acceptable.  If it returns false due to some other I/O\n      // error, then this method will fail later with an IOException while saving\n      // the jar.\n      LOG.debug(\"mkdirs false for \" + workingDir + \", execution will continue\");\n    }\n\n    // Append all entries\n    List\u003cString\u003e classPathEntryList \u003d new ArrayList\u003cString\u003e(\n      classPathEntries.length);\n    for (String classPathEntry: classPathEntries) {\n      if (classPathEntry.endsWith(\"*\")) {\n        // Append all jars that match the wildcard\n        Path globPath \u003d new Path(classPathEntry).suffix(\"{.jar,.JAR}\");\n        FileStatus[] wildcardJars \u003d FileContext.getLocalFSFileContext().util()\n          .globStatus(globPath);\n        if (wildcardJars !\u003d null) {\n          for (FileStatus wildcardJar: wildcardJars) {\n            classPathEntryList.add(wildcardJar.getPath().toUri().toURL()\n              .toExternalForm());\n          }\n        }\n      } else {\n        // Append just this entry\n        File fileCpEntry \u003d null;\n        if(!new Path(classPathEntry).isAbsolute()) {\n          fileCpEntry \u003d new File(workingDir, classPathEntry);\n        }\n        else {\n          fileCpEntry \u003d new File(classPathEntry);\n        }\n        String classPathEntryUrl \u003d fileCpEntry.toURI().toURL()\n          .toExternalForm();\n\n        // File.toURI only appends trailing \u0027/\u0027 if it can determine that it is a\n        // directory that already exists.  (See JavaDocs.)  If this entry had a\n        // trailing \u0027/\u0027 specified by the caller, then guarantee that the\n        // classpath entry in the manifest has a trailing \u0027/\u0027, and thus refers to\n        // a directory instead of a file.  This can happen if the caller is\n        // creating a classpath jar referencing a directory that hasn\u0027t been\n        // created yet, but will definitely be created before running.\n        if (classPathEntry.endsWith(Path.SEPARATOR) \u0026\u0026\n            !classPathEntryUrl.endsWith(Path.SEPARATOR)) {\n          classPathEntryUrl \u003d classPathEntryUrl + Path.SEPARATOR;\n        }\n        classPathEntryList.add(classPathEntryUrl);\n      }\n    }\n    String jarClassPath \u003d StringUtils.join(\" \", classPathEntryList);\n\n    // Create the manifest\n    Manifest jarManifest \u003d new Manifest();\n    jarManifest.getMainAttributes().putValue(\n        Attributes.Name.MANIFEST_VERSION.toString(), \"1.0\");\n    jarManifest.getMainAttributes().putValue(\n        Attributes.Name.CLASS_PATH.toString(), jarClassPath);\n\n    // Write the manifest to output JAR file\n    File classPathJar \u003d File.createTempFile(\"classpath-\", \".jar\", workingDir);\n    FileOutputStream fos \u003d null;\n    BufferedOutputStream bos \u003d null;\n    JarOutputStream jos \u003d null;\n    try {\n      fos \u003d new FileOutputStream(classPathJar);\n      bos \u003d new BufferedOutputStream(fos);\n      jos \u003d new JarOutputStream(bos, jarManifest);\n    } finally {\n      IOUtils.cleanup(LOG, jos, bos, fos);\n    }\n\n    return classPathJar.getCanonicalPath();\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/FileUtil.java",
      "extendedDetails": {}
    },
    "7c666454170599dc3d901c8b15ac95bca3a3a829": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HADOOP-9488. FileUtil#createJarWithClassPath only substitutes environment variables from current process environment/does not support overriding when launching new process (Chris Nauroth via bikas)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1469996 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/04/13 12:23 PM",
      "commitName": "7c666454170599dc3d901c8b15ac95bca3a3a829",
      "commitAuthor": "Bikas Saha",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-9488. FileUtil#createJarWithClassPath only substitutes environment variables from current process environment/does not support overriding when launching new process (Chris Nauroth via bikas)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1469996 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "19/04/13 12:23 PM",
          "commitName": "7c666454170599dc3d901c8b15ac95bca3a3a829",
          "commitAuthor": "Bikas Saha",
          "commitDateOld": "13/04/13 1:22 PM",
          "commitNameOld": "e408d9904b1105b7eebd952cba0d61efe8802b22",
          "commitAuthorOld": "Suresh Srinivas",
          "daysBetweenCommits": 5.96,
          "commitsBetweenForRepo": 25,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,65 +1,78 @@\n-  public static String createJarWithClassPath(String inputClassPath, Path pwd)\n-      throws IOException {\n+  public static String createJarWithClassPath(String inputClassPath, Path pwd,\n+      Map\u003cString, String\u003e callerEnv) throws IOException {\n     // Replace environment variables, case-insensitive on Windows\n     @SuppressWarnings(\"unchecked\")\n-    Map\u003cString, String\u003e env \u003d Shell.WINDOWS ?\n-      new CaseInsensitiveMap(System.getenv()) : System.getenv();\n+    Map\u003cString, String\u003e env \u003d Shell.WINDOWS ? new CaseInsensitiveMap(callerEnv) :\n+      callerEnv;\n     String[] classPathEntries \u003d inputClassPath.split(File.pathSeparator);\n     for (int i \u003d 0; i \u003c classPathEntries.length; ++i) {\n       classPathEntries[i] \u003d StringUtils.replaceTokens(classPathEntries[i],\n         StringUtils.ENV_VAR_PATTERN, env);\n     }\n     File workingDir \u003d new File(pwd.toString());\n     if (!workingDir.mkdirs()) {\n       // If mkdirs returns false because the working directory already exists,\n       // then this is acceptable.  If it returns false due to some other I/O\n       // error, then this method will fail later with an IOException while saving\n       // the jar.\n       LOG.debug(\"mkdirs false for \" + workingDir + \", execution will continue\");\n     }\n \n     // Append all entries\n     List\u003cString\u003e classPathEntryList \u003d new ArrayList\u003cString\u003e(\n       classPathEntries.length);\n     for (String classPathEntry: classPathEntries) {\n       if (classPathEntry.endsWith(\"*\")) {\n         // Append all jars that match the wildcard\n         Path globPath \u003d new Path(classPathEntry).suffix(\"{.jar,.JAR}\");\n         FileStatus[] wildcardJars \u003d FileContext.getLocalFSFileContext().util()\n           .globStatus(globPath);\n         if (wildcardJars !\u003d null) {\n           for (FileStatus wildcardJar: wildcardJars) {\n             classPathEntryList.add(wildcardJar.getPath().toUri().toURL()\n               .toExternalForm());\n           }\n         }\n       } else {\n-        // Append just this jar\n-        classPathEntryList.add(new File(classPathEntry).toURI().toURL()\n-          .toExternalForm());\n+        // Append just this entry\n+        String classPathEntryUrl \u003d new File(classPathEntry).toURI().toURL()\n+          .toExternalForm();\n+\n+        // File.toURI only appends trailing \u0027/\u0027 if it can determine that it is a\n+        // directory that already exists.  (See JavaDocs.)  If this entry had a\n+        // trailing \u0027/\u0027 specified by the caller, then guarantee that the\n+        // classpath entry in the manifest has a trailing \u0027/\u0027, and thus refers to\n+        // a directory instead of a file.  This can happen if the caller is\n+        // creating a classpath jar referencing a directory that hasn\u0027t been\n+        // created yet, but will definitely be created before running.\n+        if (classPathEntry.endsWith(Path.SEPARATOR) \u0026\u0026\n+            !classPathEntryUrl.endsWith(Path.SEPARATOR)) {\n+          classPathEntryUrl \u003d classPathEntryUrl + Path.SEPARATOR;\n+        }\n+        classPathEntryList.add(classPathEntryUrl);\n       }\n     }\n     String jarClassPath \u003d StringUtils.join(\" \", classPathEntryList);\n \n     // Create the manifest\n     Manifest jarManifest \u003d new Manifest();\n     jarManifest.getMainAttributes().putValue(\n         Attributes.Name.MANIFEST_VERSION.toString(), \"1.0\");\n     jarManifest.getMainAttributes().putValue(\n         Attributes.Name.CLASS_PATH.toString(), jarClassPath);\n \n     // Write the manifest to output JAR file\n     File classPathJar \u003d File.createTempFile(\"classpath-\", \".jar\", workingDir);\n     FileOutputStream fos \u003d null;\n     BufferedOutputStream bos \u003d null;\n     JarOutputStream jos \u003d null;\n     try {\n       fos \u003d new FileOutputStream(classPathJar);\n       bos \u003d new BufferedOutputStream(fos);\n       jos \u003d new JarOutputStream(bos, jarManifest);\n     } finally {\n       IOUtils.cleanup(LOG, jos, bos, fos);\n     }\n \n     return classPathJar.getCanonicalPath();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static String createJarWithClassPath(String inputClassPath, Path pwd,\n      Map\u003cString, String\u003e callerEnv) throws IOException {\n    // Replace environment variables, case-insensitive on Windows\n    @SuppressWarnings(\"unchecked\")\n    Map\u003cString, String\u003e env \u003d Shell.WINDOWS ? new CaseInsensitiveMap(callerEnv) :\n      callerEnv;\n    String[] classPathEntries \u003d inputClassPath.split(File.pathSeparator);\n    for (int i \u003d 0; i \u003c classPathEntries.length; ++i) {\n      classPathEntries[i] \u003d StringUtils.replaceTokens(classPathEntries[i],\n        StringUtils.ENV_VAR_PATTERN, env);\n    }\n    File workingDir \u003d new File(pwd.toString());\n    if (!workingDir.mkdirs()) {\n      // If mkdirs returns false because the working directory already exists,\n      // then this is acceptable.  If it returns false due to some other I/O\n      // error, then this method will fail later with an IOException while saving\n      // the jar.\n      LOG.debug(\"mkdirs false for \" + workingDir + \", execution will continue\");\n    }\n\n    // Append all entries\n    List\u003cString\u003e classPathEntryList \u003d new ArrayList\u003cString\u003e(\n      classPathEntries.length);\n    for (String classPathEntry: classPathEntries) {\n      if (classPathEntry.endsWith(\"*\")) {\n        // Append all jars that match the wildcard\n        Path globPath \u003d new Path(classPathEntry).suffix(\"{.jar,.JAR}\");\n        FileStatus[] wildcardJars \u003d FileContext.getLocalFSFileContext().util()\n          .globStatus(globPath);\n        if (wildcardJars !\u003d null) {\n          for (FileStatus wildcardJar: wildcardJars) {\n            classPathEntryList.add(wildcardJar.getPath().toUri().toURL()\n              .toExternalForm());\n          }\n        }\n      } else {\n        // Append just this entry\n        String classPathEntryUrl \u003d new File(classPathEntry).toURI().toURL()\n          .toExternalForm();\n\n        // File.toURI only appends trailing \u0027/\u0027 if it can determine that it is a\n        // directory that already exists.  (See JavaDocs.)  If this entry had a\n        // trailing \u0027/\u0027 specified by the caller, then guarantee that the\n        // classpath entry in the manifest has a trailing \u0027/\u0027, and thus refers to\n        // a directory instead of a file.  This can happen if the caller is\n        // creating a classpath jar referencing a directory that hasn\u0027t been\n        // created yet, but will definitely be created before running.\n        if (classPathEntry.endsWith(Path.SEPARATOR) \u0026\u0026\n            !classPathEntryUrl.endsWith(Path.SEPARATOR)) {\n          classPathEntryUrl \u003d classPathEntryUrl + Path.SEPARATOR;\n        }\n        classPathEntryList.add(classPathEntryUrl);\n      }\n    }\n    String jarClassPath \u003d StringUtils.join(\" \", classPathEntryList);\n\n    // Create the manifest\n    Manifest jarManifest \u003d new Manifest();\n    jarManifest.getMainAttributes().putValue(\n        Attributes.Name.MANIFEST_VERSION.toString(), \"1.0\");\n    jarManifest.getMainAttributes().putValue(\n        Attributes.Name.CLASS_PATH.toString(), jarClassPath);\n\n    // Write the manifest to output JAR file\n    File classPathJar \u003d File.createTempFile(\"classpath-\", \".jar\", workingDir);\n    FileOutputStream fos \u003d null;\n    BufferedOutputStream bos \u003d null;\n    JarOutputStream jos \u003d null;\n    try {\n      fos \u003d new FileOutputStream(classPathJar);\n      bos \u003d new BufferedOutputStream(fos);\n      jos \u003d new JarOutputStream(bos, jarManifest);\n    } finally {\n      IOUtils.cleanup(LOG, jos, bos, fos);\n    }\n\n    return classPathJar.getCanonicalPath();\n  }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/FileUtil.java",
          "extendedDetails": {
            "oldValue": "[inputClassPath-String, pwd-Path]",
            "newValue": "[inputClassPath-String, pwd-Path, callerEnv-Map\u003cString,String\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-9488. FileUtil#createJarWithClassPath only substitutes environment variables from current process environment/does not support overriding when launching new process (Chris Nauroth via bikas)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1469996 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "19/04/13 12:23 PM",
          "commitName": "7c666454170599dc3d901c8b15ac95bca3a3a829",
          "commitAuthor": "Bikas Saha",
          "commitDateOld": "13/04/13 1:22 PM",
          "commitNameOld": "e408d9904b1105b7eebd952cba0d61efe8802b22",
          "commitAuthorOld": "Suresh Srinivas",
          "daysBetweenCommits": 5.96,
          "commitsBetweenForRepo": 25,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,65 +1,78 @@\n-  public static String createJarWithClassPath(String inputClassPath, Path pwd)\n-      throws IOException {\n+  public static String createJarWithClassPath(String inputClassPath, Path pwd,\n+      Map\u003cString, String\u003e callerEnv) throws IOException {\n     // Replace environment variables, case-insensitive on Windows\n     @SuppressWarnings(\"unchecked\")\n-    Map\u003cString, String\u003e env \u003d Shell.WINDOWS ?\n-      new CaseInsensitiveMap(System.getenv()) : System.getenv();\n+    Map\u003cString, String\u003e env \u003d Shell.WINDOWS ? new CaseInsensitiveMap(callerEnv) :\n+      callerEnv;\n     String[] classPathEntries \u003d inputClassPath.split(File.pathSeparator);\n     for (int i \u003d 0; i \u003c classPathEntries.length; ++i) {\n       classPathEntries[i] \u003d StringUtils.replaceTokens(classPathEntries[i],\n         StringUtils.ENV_VAR_PATTERN, env);\n     }\n     File workingDir \u003d new File(pwd.toString());\n     if (!workingDir.mkdirs()) {\n       // If mkdirs returns false because the working directory already exists,\n       // then this is acceptable.  If it returns false due to some other I/O\n       // error, then this method will fail later with an IOException while saving\n       // the jar.\n       LOG.debug(\"mkdirs false for \" + workingDir + \", execution will continue\");\n     }\n \n     // Append all entries\n     List\u003cString\u003e classPathEntryList \u003d new ArrayList\u003cString\u003e(\n       classPathEntries.length);\n     for (String classPathEntry: classPathEntries) {\n       if (classPathEntry.endsWith(\"*\")) {\n         // Append all jars that match the wildcard\n         Path globPath \u003d new Path(classPathEntry).suffix(\"{.jar,.JAR}\");\n         FileStatus[] wildcardJars \u003d FileContext.getLocalFSFileContext().util()\n           .globStatus(globPath);\n         if (wildcardJars !\u003d null) {\n           for (FileStatus wildcardJar: wildcardJars) {\n             classPathEntryList.add(wildcardJar.getPath().toUri().toURL()\n               .toExternalForm());\n           }\n         }\n       } else {\n-        // Append just this jar\n-        classPathEntryList.add(new File(classPathEntry).toURI().toURL()\n-          .toExternalForm());\n+        // Append just this entry\n+        String classPathEntryUrl \u003d new File(classPathEntry).toURI().toURL()\n+          .toExternalForm();\n+\n+        // File.toURI only appends trailing \u0027/\u0027 if it can determine that it is a\n+        // directory that already exists.  (See JavaDocs.)  If this entry had a\n+        // trailing \u0027/\u0027 specified by the caller, then guarantee that the\n+        // classpath entry in the manifest has a trailing \u0027/\u0027, and thus refers to\n+        // a directory instead of a file.  This can happen if the caller is\n+        // creating a classpath jar referencing a directory that hasn\u0027t been\n+        // created yet, but will definitely be created before running.\n+        if (classPathEntry.endsWith(Path.SEPARATOR) \u0026\u0026\n+            !classPathEntryUrl.endsWith(Path.SEPARATOR)) {\n+          classPathEntryUrl \u003d classPathEntryUrl + Path.SEPARATOR;\n+        }\n+        classPathEntryList.add(classPathEntryUrl);\n       }\n     }\n     String jarClassPath \u003d StringUtils.join(\" \", classPathEntryList);\n \n     // Create the manifest\n     Manifest jarManifest \u003d new Manifest();\n     jarManifest.getMainAttributes().putValue(\n         Attributes.Name.MANIFEST_VERSION.toString(), \"1.0\");\n     jarManifest.getMainAttributes().putValue(\n         Attributes.Name.CLASS_PATH.toString(), jarClassPath);\n \n     // Write the manifest to output JAR file\n     File classPathJar \u003d File.createTempFile(\"classpath-\", \".jar\", workingDir);\n     FileOutputStream fos \u003d null;\n     BufferedOutputStream bos \u003d null;\n     JarOutputStream jos \u003d null;\n     try {\n       fos \u003d new FileOutputStream(classPathJar);\n       bos \u003d new BufferedOutputStream(fos);\n       jos \u003d new JarOutputStream(bos, jarManifest);\n     } finally {\n       IOUtils.cleanup(LOG, jos, bos, fos);\n     }\n \n     return classPathJar.getCanonicalPath();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static String createJarWithClassPath(String inputClassPath, Path pwd,\n      Map\u003cString, String\u003e callerEnv) throws IOException {\n    // Replace environment variables, case-insensitive on Windows\n    @SuppressWarnings(\"unchecked\")\n    Map\u003cString, String\u003e env \u003d Shell.WINDOWS ? new CaseInsensitiveMap(callerEnv) :\n      callerEnv;\n    String[] classPathEntries \u003d inputClassPath.split(File.pathSeparator);\n    for (int i \u003d 0; i \u003c classPathEntries.length; ++i) {\n      classPathEntries[i] \u003d StringUtils.replaceTokens(classPathEntries[i],\n        StringUtils.ENV_VAR_PATTERN, env);\n    }\n    File workingDir \u003d new File(pwd.toString());\n    if (!workingDir.mkdirs()) {\n      // If mkdirs returns false because the working directory already exists,\n      // then this is acceptable.  If it returns false due to some other I/O\n      // error, then this method will fail later with an IOException while saving\n      // the jar.\n      LOG.debug(\"mkdirs false for \" + workingDir + \", execution will continue\");\n    }\n\n    // Append all entries\n    List\u003cString\u003e classPathEntryList \u003d new ArrayList\u003cString\u003e(\n      classPathEntries.length);\n    for (String classPathEntry: classPathEntries) {\n      if (classPathEntry.endsWith(\"*\")) {\n        // Append all jars that match the wildcard\n        Path globPath \u003d new Path(classPathEntry).suffix(\"{.jar,.JAR}\");\n        FileStatus[] wildcardJars \u003d FileContext.getLocalFSFileContext().util()\n          .globStatus(globPath);\n        if (wildcardJars !\u003d null) {\n          for (FileStatus wildcardJar: wildcardJars) {\n            classPathEntryList.add(wildcardJar.getPath().toUri().toURL()\n              .toExternalForm());\n          }\n        }\n      } else {\n        // Append just this entry\n        String classPathEntryUrl \u003d new File(classPathEntry).toURI().toURL()\n          .toExternalForm();\n\n        // File.toURI only appends trailing \u0027/\u0027 if it can determine that it is a\n        // directory that already exists.  (See JavaDocs.)  If this entry had a\n        // trailing \u0027/\u0027 specified by the caller, then guarantee that the\n        // classpath entry in the manifest has a trailing \u0027/\u0027, and thus refers to\n        // a directory instead of a file.  This can happen if the caller is\n        // creating a classpath jar referencing a directory that hasn\u0027t been\n        // created yet, but will definitely be created before running.\n        if (classPathEntry.endsWith(Path.SEPARATOR) \u0026\u0026\n            !classPathEntryUrl.endsWith(Path.SEPARATOR)) {\n          classPathEntryUrl \u003d classPathEntryUrl + Path.SEPARATOR;\n        }\n        classPathEntryList.add(classPathEntryUrl);\n      }\n    }\n    String jarClassPath \u003d StringUtils.join(\" \", classPathEntryList);\n\n    // Create the manifest\n    Manifest jarManifest \u003d new Manifest();\n    jarManifest.getMainAttributes().putValue(\n        Attributes.Name.MANIFEST_VERSION.toString(), \"1.0\");\n    jarManifest.getMainAttributes().putValue(\n        Attributes.Name.CLASS_PATH.toString(), jarClassPath);\n\n    // Write the manifest to output JAR file\n    File classPathJar \u003d File.createTempFile(\"classpath-\", \".jar\", workingDir);\n    FileOutputStream fos \u003d null;\n    BufferedOutputStream bos \u003d null;\n    JarOutputStream jos \u003d null;\n    try {\n      fos \u003d new FileOutputStream(classPathJar);\n      bos \u003d new BufferedOutputStream(fos);\n      jos \u003d new JarOutputStream(bos, jarManifest);\n    } finally {\n      IOUtils.cleanup(LOG, jos, bos, fos);\n    }\n\n    return classPathJar.getCanonicalPath();\n  }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/FileUtil.java",
          "extendedDetails": {}
        }
      ]
    },
    "638801cce16fc1dc3259c541dc30a599faaddda1": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-8952. Enhancements to support Hadoop on Windows Server and Windows Azure environments. Contributed by Ivan Mitic, Chuan Liu, Ramya Sunil, Bikas Saha, Kanna Karanam, John Gordon, Brandon Li, Chris Nauroth, David Lao, Sumadhur Reddy Bolli, Arpit Agarwal, Ahmed El Baz, Mike Liddell, Jing Zhao, Thejas Nair, Steve Maine, Ganeshan Iyer, Raja Aluri, Giridharan Kesavan, Ramya Bharathi Nimmagadda.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1453486 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "06/03/13 11:15 AM",
      "commitName": "638801cce16fc1dc3259c541dc30a599faaddda1",
      "commitAuthor": "Suresh Srinivas",
      "diff": "@@ -0,0 +1,65 @@\n+  public static String createJarWithClassPath(String inputClassPath, Path pwd)\n+      throws IOException {\n+    // Replace environment variables, case-insensitive on Windows\n+    @SuppressWarnings(\"unchecked\")\n+    Map\u003cString, String\u003e env \u003d Shell.WINDOWS ?\n+      new CaseInsensitiveMap(System.getenv()) : System.getenv();\n+    String[] classPathEntries \u003d inputClassPath.split(File.pathSeparator);\n+    for (int i \u003d 0; i \u003c classPathEntries.length; ++i) {\n+      classPathEntries[i] \u003d StringUtils.replaceTokens(classPathEntries[i],\n+        StringUtils.ENV_VAR_PATTERN, env);\n+    }\n+    File workingDir \u003d new File(pwd.toString());\n+    if (!workingDir.mkdirs()) {\n+      // If mkdirs returns false because the working directory already exists,\n+      // then this is acceptable.  If it returns false due to some other I/O\n+      // error, then this method will fail later with an IOException while saving\n+      // the jar.\n+      LOG.debug(\"mkdirs false for \" + workingDir + \", execution will continue\");\n+    }\n+\n+    // Append all entries\n+    List\u003cString\u003e classPathEntryList \u003d new ArrayList\u003cString\u003e(\n+      classPathEntries.length);\n+    for (String classPathEntry: classPathEntries) {\n+      if (classPathEntry.endsWith(\"*\")) {\n+        // Append all jars that match the wildcard\n+        Path globPath \u003d new Path(classPathEntry).suffix(\"{.jar,.JAR}\");\n+        FileStatus[] wildcardJars \u003d FileContext.getLocalFSFileContext().util()\n+          .globStatus(globPath);\n+        if (wildcardJars !\u003d null) {\n+          for (FileStatus wildcardJar: wildcardJars) {\n+            classPathEntryList.add(wildcardJar.getPath().toUri().toURL()\n+              .toExternalForm());\n+          }\n+        }\n+      } else {\n+        // Append just this jar\n+        classPathEntryList.add(new File(classPathEntry).toURI().toURL()\n+          .toExternalForm());\n+      }\n+    }\n+    String jarClassPath \u003d StringUtils.join(\" \", classPathEntryList);\n+\n+    // Create the manifest\n+    Manifest jarManifest \u003d new Manifest();\n+    jarManifest.getMainAttributes().putValue(\n+        Attributes.Name.MANIFEST_VERSION.toString(), \"1.0\");\n+    jarManifest.getMainAttributes().putValue(\n+        Attributes.Name.CLASS_PATH.toString(), jarClassPath);\n+\n+    // Write the manifest to output JAR file\n+    File classPathJar \u003d File.createTempFile(\"classpath-\", \".jar\", workingDir);\n+    FileOutputStream fos \u003d null;\n+    BufferedOutputStream bos \u003d null;\n+    JarOutputStream jos \u003d null;\n+    try {\n+      fos \u003d new FileOutputStream(classPathJar);\n+      bos \u003d new BufferedOutputStream(fos);\n+      jos \u003d new JarOutputStream(bos, jarManifest);\n+    } finally {\n+      IOUtils.cleanup(LOG, jos, bos, fos);\n+    }\n+\n+    return classPathJar.getCanonicalPath();\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public static String createJarWithClassPath(String inputClassPath, Path pwd)\n      throws IOException {\n    // Replace environment variables, case-insensitive on Windows\n    @SuppressWarnings(\"unchecked\")\n    Map\u003cString, String\u003e env \u003d Shell.WINDOWS ?\n      new CaseInsensitiveMap(System.getenv()) : System.getenv();\n    String[] classPathEntries \u003d inputClassPath.split(File.pathSeparator);\n    for (int i \u003d 0; i \u003c classPathEntries.length; ++i) {\n      classPathEntries[i] \u003d StringUtils.replaceTokens(classPathEntries[i],\n        StringUtils.ENV_VAR_PATTERN, env);\n    }\n    File workingDir \u003d new File(pwd.toString());\n    if (!workingDir.mkdirs()) {\n      // If mkdirs returns false because the working directory already exists,\n      // then this is acceptable.  If it returns false due to some other I/O\n      // error, then this method will fail later with an IOException while saving\n      // the jar.\n      LOG.debug(\"mkdirs false for \" + workingDir + \", execution will continue\");\n    }\n\n    // Append all entries\n    List\u003cString\u003e classPathEntryList \u003d new ArrayList\u003cString\u003e(\n      classPathEntries.length);\n    for (String classPathEntry: classPathEntries) {\n      if (classPathEntry.endsWith(\"*\")) {\n        // Append all jars that match the wildcard\n        Path globPath \u003d new Path(classPathEntry).suffix(\"{.jar,.JAR}\");\n        FileStatus[] wildcardJars \u003d FileContext.getLocalFSFileContext().util()\n          .globStatus(globPath);\n        if (wildcardJars !\u003d null) {\n          for (FileStatus wildcardJar: wildcardJars) {\n            classPathEntryList.add(wildcardJar.getPath().toUri().toURL()\n              .toExternalForm());\n          }\n        }\n      } else {\n        // Append just this jar\n        classPathEntryList.add(new File(classPathEntry).toURI().toURL()\n          .toExternalForm());\n      }\n    }\n    String jarClassPath \u003d StringUtils.join(\" \", classPathEntryList);\n\n    // Create the manifest\n    Manifest jarManifest \u003d new Manifest();\n    jarManifest.getMainAttributes().putValue(\n        Attributes.Name.MANIFEST_VERSION.toString(), \"1.0\");\n    jarManifest.getMainAttributes().putValue(\n        Attributes.Name.CLASS_PATH.toString(), jarClassPath);\n\n    // Write the manifest to output JAR file\n    File classPathJar \u003d File.createTempFile(\"classpath-\", \".jar\", workingDir);\n    FileOutputStream fos \u003d null;\n    BufferedOutputStream bos \u003d null;\n    JarOutputStream jos \u003d null;\n    try {\n      fos \u003d new FileOutputStream(classPathJar);\n      bos \u003d new BufferedOutputStream(fos);\n      jos \u003d new JarOutputStream(bos, jarManifest);\n    } finally {\n      IOUtils.cleanup(LOG, jos, bos, fos);\n    }\n\n    return classPathJar.getCanonicalPath();\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/FileUtil.java"
    }
  }
}