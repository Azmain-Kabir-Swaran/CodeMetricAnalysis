{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "SaslRpcClient.java",
  "functionName": "createSaslClient",
  "functionId": "createSaslClient___authType-SaslAuth",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/SaslRpcClient.java",
  "functionStartLine": 211,
  "functionEndLine": 263,
  "numCommitsSeen": 30,
  "timeTaken": 1892,
  "changeHistory": [
    "f1875b205e492ef071e7ef78b147efee0e51263d",
    "ff2b2bea9143c6299cad4bb7d1d049e415d2d7f3",
    "f799618828b0ba09b694b07eaab0689d31f4954d",
    "65be21267587f04a2c33af65b951211cc9085b15"
  ],
  "changeHistoryShort": {
    "f1875b205e492ef071e7ef78b147efee0e51263d": "Ybodychange",
    "ff2b2bea9143c6299cad4bb7d1d049e415d2d7f3": "Ybodychange",
    "f799618828b0ba09b694b07eaab0689d31f4954d": "Ybodychange",
    "65be21267587f04a2c33af65b951211cc9085b15": "Yintroduced"
  },
  "changeHistoryDetails": {
    "f1875b205e492ef071e7ef78b147efee0e51263d": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16059. Use SASL Factories Cache to Improve Performance. Contributed by Ayush Saxena.\n",
      "commitDate": "02/05/19 10:52 PM",
      "commitName": "f1875b205e492ef071e7ef78b147efee0e51263d",
      "commitAuthor": "Vinayakumar B",
      "commitDateOld": "10/10/18 9:51 PM",
      "commitNameOld": "7b57f2f71fbaa5af4897309597cca70a95b04edd",
      "commitAuthorOld": "Takanobu Asanuma",
      "daysBetweenCommits": 204.04,
      "commitsBetweenForRepo": 1509,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,53 @@\n   private SaslClient createSaslClient(SaslAuth authType)\n       throws SaslException, IOException {\n     String saslUser \u003d null;\n     // SASL requires the client and server to use the same proto and serverId\n     // if necessary, auth types below will verify they are valid\n     final String saslProtocol \u003d authType.getProtocol();\n     final String saslServerName \u003d authType.getServerId();\n     Map\u003cString, String\u003e saslProperties \u003d\n       saslPropsResolver.getClientProperties(serverAddr.getAddress());  \n     CallbackHandler saslCallback \u003d null;\n     \n     final AuthMethod method \u003d AuthMethod.valueOf(authType.getMethod());\n     switch (method) {\n       case TOKEN: {\n         Token\u003c?\u003e token \u003d getServerToken(authType);\n         if (token \u003d\u003d null) {\n           LOG.debug(\"tokens aren\u0027t supported for this protocol\" +\n               \" or user doesn\u0027t have one\");\n           return null;\n         }\n         saslCallback \u003d new SaslClientCallbackHandler(token);\n         break;\n       }\n       case KERBEROS: {\n         if (ugi.getRealAuthenticationMethod().getAuthMethod() !\u003d\n             AuthMethod.KERBEROS) {\n           LOG.debug(\"client isn\u0027t using kerberos\");\n           return null;\n         }\n         String serverPrincipal \u003d getServerPrincipal(authType);\n         if (serverPrincipal \u003d\u003d null) {\n           LOG.debug(\"protocol doesn\u0027t use kerberos\");\n           return null;\n         }\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"RPC Server\u0027s Kerberos principal name for protocol\u003d\"\n               + protocol.getCanonicalName() + \" is \" + serverPrincipal);\n         }\n         break;\n       }\n       default:\n         throw new IOException(\"Unknown authentication method \" + method);\n     }\n \n     String mechanism \u003d method.getMechanismName();\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Creating SASL \" + mechanism + \"(\" + method + \") \"\n           + \" client to authenticate to service at \" + saslServerName);\n     }\n-    return Sasl.createSaslClient(\n-        new String[] { mechanism }, saslUser, saslProtocol, saslServerName,\n+    return saslFactory.createSaslClient(\n+        new String[] {mechanism}, saslUser, saslProtocol, saslServerName,\n         saslProperties, saslCallback);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private SaslClient createSaslClient(SaslAuth authType)\n      throws SaslException, IOException {\n    String saslUser \u003d null;\n    // SASL requires the client and server to use the same proto and serverId\n    // if necessary, auth types below will verify they are valid\n    final String saslProtocol \u003d authType.getProtocol();\n    final String saslServerName \u003d authType.getServerId();\n    Map\u003cString, String\u003e saslProperties \u003d\n      saslPropsResolver.getClientProperties(serverAddr.getAddress());  \n    CallbackHandler saslCallback \u003d null;\n    \n    final AuthMethod method \u003d AuthMethod.valueOf(authType.getMethod());\n    switch (method) {\n      case TOKEN: {\n        Token\u003c?\u003e token \u003d getServerToken(authType);\n        if (token \u003d\u003d null) {\n          LOG.debug(\"tokens aren\u0027t supported for this protocol\" +\n              \" or user doesn\u0027t have one\");\n          return null;\n        }\n        saslCallback \u003d new SaslClientCallbackHandler(token);\n        break;\n      }\n      case KERBEROS: {\n        if (ugi.getRealAuthenticationMethod().getAuthMethod() !\u003d\n            AuthMethod.KERBEROS) {\n          LOG.debug(\"client isn\u0027t using kerberos\");\n          return null;\n        }\n        String serverPrincipal \u003d getServerPrincipal(authType);\n        if (serverPrincipal \u003d\u003d null) {\n          LOG.debug(\"protocol doesn\u0027t use kerberos\");\n          return null;\n        }\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"RPC Server\u0027s Kerberos principal name for protocol\u003d\"\n              + protocol.getCanonicalName() + \" is \" + serverPrincipal);\n        }\n        break;\n      }\n      default:\n        throw new IOException(\"Unknown authentication method \" + method);\n    }\n\n    String mechanism \u003d method.getMechanismName();\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Creating SASL \" + mechanism + \"(\" + method + \") \"\n          + \" client to authenticate to service at \" + saslServerName);\n    }\n    return saslFactory.createSaslClient(\n        new String[] {mechanism}, saslUser, saslProtocol, saslServerName,\n        saslProperties, saslCallback);\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/SaslRpcClient.java",
      "extendedDetails": {}
    },
    "ff2b2bea9143c6299cad4bb7d1d049e415d2d7f3": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-12385. Include nested stack trace in SaslRpcClient.getServerToken() (stevel)\n",
      "commitDate": "28/10/15 3:25 AM",
      "commitName": "ff2b2bea9143c6299cad4bb7d1d049e415d2d7f3",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "22/10/15 8:19 AM",
      "commitNameOld": "4c0bae240bea9a475e8ee9a0b081bfce6d1cd1e5",
      "commitAuthorOld": "Allen Wittenauer",
      "daysBetweenCommits": 5.8,
      "commitsBetweenForRepo": 67,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,49 +1,53 @@\n   private SaslClient createSaslClient(SaslAuth authType)\n       throws SaslException, IOException {\n     String saslUser \u003d null;\n     // SASL requires the client and server to use the same proto and serverId\n     // if necessary, auth types below will verify they are valid\n     final String saslProtocol \u003d authType.getProtocol();\n     final String saslServerName \u003d authType.getServerId();\n     Map\u003cString, String\u003e saslProperties \u003d\n       saslPropsResolver.getClientProperties(serverAddr.getAddress());  \n     CallbackHandler saslCallback \u003d null;\n     \n     final AuthMethod method \u003d AuthMethod.valueOf(authType.getMethod());\n     switch (method) {\n       case TOKEN: {\n         Token\u003c?\u003e token \u003d getServerToken(authType);\n         if (token \u003d\u003d null) {\n-          return null; // tokens aren\u0027t supported or user doesn\u0027t have one\n+          LOG.debug(\"tokens aren\u0027t supported for this protocol\" +\n+              \" or user doesn\u0027t have one\");\n+          return null;\n         }\n         saslCallback \u003d new SaslClientCallbackHandler(token);\n         break;\n       }\n       case KERBEROS: {\n         if (ugi.getRealAuthenticationMethod().getAuthMethod() !\u003d\n             AuthMethod.KERBEROS) {\n-          return null; // client isn\u0027t using kerberos\n+          LOG.debug(\"client isn\u0027t using kerberos\");\n+          return null;\n         }\n         String serverPrincipal \u003d getServerPrincipal(authType);\n         if (serverPrincipal \u003d\u003d null) {\n-          return null; // protocol doesn\u0027t use kerberos\n+          LOG.debug(\"protocol doesn\u0027t use kerberos\");\n+          return null;\n         }\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"RPC Server\u0027s Kerberos principal name for protocol\u003d\"\n               + protocol.getCanonicalName() + \" is \" + serverPrincipal);\n         }\n         break;\n       }\n       default:\n         throw new IOException(\"Unknown authentication method \" + method);\n     }\n-    \n+\n     String mechanism \u003d method.getMechanismName();\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Creating SASL \" + mechanism + \"(\" + method + \") \"\n           + \" client to authenticate to service at \" + saslServerName);\n     }\n     return Sasl.createSaslClient(\n         new String[] { mechanism }, saslUser, saslProtocol, saslServerName,\n         saslProperties, saslCallback);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private SaslClient createSaslClient(SaslAuth authType)\n      throws SaslException, IOException {\n    String saslUser \u003d null;\n    // SASL requires the client and server to use the same proto and serverId\n    // if necessary, auth types below will verify they are valid\n    final String saslProtocol \u003d authType.getProtocol();\n    final String saslServerName \u003d authType.getServerId();\n    Map\u003cString, String\u003e saslProperties \u003d\n      saslPropsResolver.getClientProperties(serverAddr.getAddress());  \n    CallbackHandler saslCallback \u003d null;\n    \n    final AuthMethod method \u003d AuthMethod.valueOf(authType.getMethod());\n    switch (method) {\n      case TOKEN: {\n        Token\u003c?\u003e token \u003d getServerToken(authType);\n        if (token \u003d\u003d null) {\n          LOG.debug(\"tokens aren\u0027t supported for this protocol\" +\n              \" or user doesn\u0027t have one\");\n          return null;\n        }\n        saslCallback \u003d new SaslClientCallbackHandler(token);\n        break;\n      }\n      case KERBEROS: {\n        if (ugi.getRealAuthenticationMethod().getAuthMethod() !\u003d\n            AuthMethod.KERBEROS) {\n          LOG.debug(\"client isn\u0027t using kerberos\");\n          return null;\n        }\n        String serverPrincipal \u003d getServerPrincipal(authType);\n        if (serverPrincipal \u003d\u003d null) {\n          LOG.debug(\"protocol doesn\u0027t use kerberos\");\n          return null;\n        }\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"RPC Server\u0027s Kerberos principal name for protocol\u003d\"\n              + protocol.getCanonicalName() + \" is \" + serverPrincipal);\n        }\n        break;\n      }\n      default:\n        throw new IOException(\"Unknown authentication method \" + method);\n    }\n\n    String mechanism \u003d method.getMechanismName();\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Creating SASL \" + mechanism + \"(\" + method + \") \"\n          + \" client to authenticate to service at \" + saslServerName);\n    }\n    return Sasl.createSaslClient(\n        new String[] { mechanism }, saslUser, saslProtocol, saslServerName,\n        saslProperties, saslCallback);\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/SaslRpcClient.java",
      "extendedDetails": {}
    },
    "f799618828b0ba09b694b07eaab0689d31f4954d": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10221. Add a plugin to specify SaslProperties for RPC protocol based on connection properties. (Contributed by Benoy Antony and Daryn Sharp)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1579382 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/03/14 1:16 PM",
      "commitName": "f799618828b0ba09b694b07eaab0689d31f4954d",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "21/02/14 5:09 PM",
      "commitNameOld": "e69614d6508c279f34a32160e1fab4aee9f49b2a",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 25.8,
      "commitsBetweenForRepo": 221,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,48 +1,49 @@\n   private SaslClient createSaslClient(SaslAuth authType)\n       throws SaslException, IOException {\n     String saslUser \u003d null;\n     // SASL requires the client and server to use the same proto and serverId\n     // if necessary, auth types below will verify they are valid\n     final String saslProtocol \u003d authType.getProtocol();\n     final String saslServerName \u003d authType.getServerId();\n-    Map\u003cString, String\u003e saslProperties \u003d SaslRpcServer.SASL_PROPS;\n+    Map\u003cString, String\u003e saslProperties \u003d\n+      saslPropsResolver.getClientProperties(serverAddr.getAddress());  \n     CallbackHandler saslCallback \u003d null;\n     \n     final AuthMethod method \u003d AuthMethod.valueOf(authType.getMethod());\n     switch (method) {\n       case TOKEN: {\n         Token\u003c?\u003e token \u003d getServerToken(authType);\n         if (token \u003d\u003d null) {\n           return null; // tokens aren\u0027t supported or user doesn\u0027t have one\n         }\n         saslCallback \u003d new SaslClientCallbackHandler(token);\n         break;\n       }\n       case KERBEROS: {\n         if (ugi.getRealAuthenticationMethod().getAuthMethod() !\u003d\n             AuthMethod.KERBEROS) {\n           return null; // client isn\u0027t using kerberos\n         }\n         String serverPrincipal \u003d getServerPrincipal(authType);\n         if (serverPrincipal \u003d\u003d null) {\n           return null; // protocol doesn\u0027t use kerberos\n         }\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"RPC Server\u0027s Kerberos principal name for protocol\u003d\"\n               + protocol.getCanonicalName() + \" is \" + serverPrincipal);\n         }\n         break;\n       }\n       default:\n         throw new IOException(\"Unknown authentication method \" + method);\n     }\n     \n     String mechanism \u003d method.getMechanismName();\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Creating SASL \" + mechanism + \"(\" + method + \") \"\n           + \" client to authenticate to service at \" + saslServerName);\n     }\n     return Sasl.createSaslClient(\n         new String[] { mechanism }, saslUser, saslProtocol, saslServerName,\n         saslProperties, saslCallback);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private SaslClient createSaslClient(SaslAuth authType)\n      throws SaslException, IOException {\n    String saslUser \u003d null;\n    // SASL requires the client and server to use the same proto and serverId\n    // if necessary, auth types below will verify they are valid\n    final String saslProtocol \u003d authType.getProtocol();\n    final String saslServerName \u003d authType.getServerId();\n    Map\u003cString, String\u003e saslProperties \u003d\n      saslPropsResolver.getClientProperties(serverAddr.getAddress());  \n    CallbackHandler saslCallback \u003d null;\n    \n    final AuthMethod method \u003d AuthMethod.valueOf(authType.getMethod());\n    switch (method) {\n      case TOKEN: {\n        Token\u003c?\u003e token \u003d getServerToken(authType);\n        if (token \u003d\u003d null) {\n          return null; // tokens aren\u0027t supported or user doesn\u0027t have one\n        }\n        saslCallback \u003d new SaslClientCallbackHandler(token);\n        break;\n      }\n      case KERBEROS: {\n        if (ugi.getRealAuthenticationMethod().getAuthMethod() !\u003d\n            AuthMethod.KERBEROS) {\n          return null; // client isn\u0027t using kerberos\n        }\n        String serverPrincipal \u003d getServerPrincipal(authType);\n        if (serverPrincipal \u003d\u003d null) {\n          return null; // protocol doesn\u0027t use kerberos\n        }\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"RPC Server\u0027s Kerberos principal name for protocol\u003d\"\n              + protocol.getCanonicalName() + \" is \" + serverPrincipal);\n        }\n        break;\n      }\n      default:\n        throw new IOException(\"Unknown authentication method \" + method);\n    }\n    \n    String mechanism \u003d method.getMechanismName();\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Creating SASL \" + mechanism + \"(\" + method + \") \"\n          + \" client to authenticate to service at \" + saslServerName);\n    }\n    return Sasl.createSaslClient(\n        new String[] { mechanism }, saslUser, saslProtocol, saslServerName,\n        saslProperties, saslCallback);\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/SaslRpcClient.java",
      "extendedDetails": {}
    },
    "65be21267587f04a2c33af65b951211cc9085b15": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-9698. [RPC v9] Client must honor server\u0027s SASL negotiate response (daryn)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1508086 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/07/13 7:44 AM",
      "commitName": "65be21267587f04a2c33af65b951211cc9085b15",
      "commitAuthor": "Daryn Sharp",
      "diff": "@@ -0,0 +1,48 @@\n+  private SaslClient createSaslClient(SaslAuth authType)\n+      throws SaslException, IOException {\n+    String saslUser \u003d null;\n+    // SASL requires the client and server to use the same proto and serverId\n+    // if necessary, auth types below will verify they are valid\n+    final String saslProtocol \u003d authType.getProtocol();\n+    final String saslServerName \u003d authType.getServerId();\n+    Map\u003cString, String\u003e saslProperties \u003d SaslRpcServer.SASL_PROPS;\n+    CallbackHandler saslCallback \u003d null;\n+    \n+    final AuthMethod method \u003d AuthMethod.valueOf(authType.getMethod());\n+    switch (method) {\n+      case TOKEN: {\n+        Token\u003c?\u003e token \u003d getServerToken(authType);\n+        if (token \u003d\u003d null) {\n+          return null; // tokens aren\u0027t supported or user doesn\u0027t have one\n+        }\n+        saslCallback \u003d new SaslClientCallbackHandler(token);\n+        break;\n+      }\n+      case KERBEROS: {\n+        if (ugi.getRealAuthenticationMethod().getAuthMethod() !\u003d\n+            AuthMethod.KERBEROS) {\n+          return null; // client isn\u0027t using kerberos\n+        }\n+        String serverPrincipal \u003d getServerPrincipal(authType);\n+        if (serverPrincipal \u003d\u003d null) {\n+          return null; // protocol doesn\u0027t use kerberos\n+        }\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"RPC Server\u0027s Kerberos principal name for protocol\u003d\"\n+              + protocol.getCanonicalName() + \" is \" + serverPrincipal);\n+        }\n+        break;\n+      }\n+      default:\n+        throw new IOException(\"Unknown authentication method \" + method);\n+    }\n+    \n+    String mechanism \u003d method.getMechanismName();\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(\"Creating SASL \" + mechanism + \"(\" + method + \") \"\n+          + \" client to authenticate to service at \" + saslServerName);\n+    }\n+    return Sasl.createSaslClient(\n+        new String[] { mechanism }, saslUser, saslProtocol, saslServerName,\n+        saslProperties, saslCallback);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private SaslClient createSaslClient(SaslAuth authType)\n      throws SaslException, IOException {\n    String saslUser \u003d null;\n    // SASL requires the client and server to use the same proto and serverId\n    // if necessary, auth types below will verify they are valid\n    final String saslProtocol \u003d authType.getProtocol();\n    final String saslServerName \u003d authType.getServerId();\n    Map\u003cString, String\u003e saslProperties \u003d SaslRpcServer.SASL_PROPS;\n    CallbackHandler saslCallback \u003d null;\n    \n    final AuthMethod method \u003d AuthMethod.valueOf(authType.getMethod());\n    switch (method) {\n      case TOKEN: {\n        Token\u003c?\u003e token \u003d getServerToken(authType);\n        if (token \u003d\u003d null) {\n          return null; // tokens aren\u0027t supported or user doesn\u0027t have one\n        }\n        saslCallback \u003d new SaslClientCallbackHandler(token);\n        break;\n      }\n      case KERBEROS: {\n        if (ugi.getRealAuthenticationMethod().getAuthMethod() !\u003d\n            AuthMethod.KERBEROS) {\n          return null; // client isn\u0027t using kerberos\n        }\n        String serverPrincipal \u003d getServerPrincipal(authType);\n        if (serverPrincipal \u003d\u003d null) {\n          return null; // protocol doesn\u0027t use kerberos\n        }\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"RPC Server\u0027s Kerberos principal name for protocol\u003d\"\n              + protocol.getCanonicalName() + \" is \" + serverPrincipal);\n        }\n        break;\n      }\n      default:\n        throw new IOException(\"Unknown authentication method \" + method);\n    }\n    \n    String mechanism \u003d method.getMechanismName();\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Creating SASL \" + mechanism + \"(\" + method + \") \"\n          + \" client to authenticate to service at \" + saslServerName);\n    }\n    return Sasl.createSaslClient(\n        new String[] { mechanism }, saslUser, saslProtocol, saslServerName,\n        saslProperties, saslCallback);\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/SaslRpcClient.java"
    }
  }
}