{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "DomainSocketWatcher.java",
  "functionName": "run",
  "functionId": "run",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/net/unix/DomainSocketWatcher.java",
  "functionStartLine": 445,
  "functionEndLine": 543,
  "numCommitsSeen": 15,
  "timeTaken": 2121,
  "changeHistory": [
    "ccaf036662e22da14583942054898c99fa51dae5",
    "246cefa089156a50bf086b8b1e4d4324d66dc58c",
    "a0e0a63209b5eb17dca5cc503be36aa52defeabd",
    "3c5ff0759c4f4e10c97c6d9036add00edb8be2b5",
    "687d83c9e10a4432c8d54c2cd406c7ccb4392187",
    "33500fd304ee1c9a1b5966de1eb1e78b58f0af26",
    "f0d64a078da7e932b9509734f75170e3e525e68c",
    "140246bad816ae7bf06eda193cc624e1e62923e0"
  ],
  "changeHistoryShort": {
    "ccaf036662e22da14583942054898c99fa51dae5": "Ybodychange",
    "246cefa089156a50bf086b8b1e4d4324d66dc58c": "Ybodychange",
    "a0e0a63209b5eb17dca5cc503be36aa52defeabd": "Ybodychange",
    "3c5ff0759c4f4e10c97c6d9036add00edb8be2b5": "Ybodychange",
    "687d83c9e10a4432c8d54c2cd406c7ccb4392187": "Ybodychange",
    "33500fd304ee1c9a1b5966de1eb1e78b58f0af26": "Ybodychange",
    "f0d64a078da7e932b9509734f75170e3e525e68c": "Ybodychange",
    "140246bad816ae7bf06eda193cc624e1e62923e0": "Yintroduced"
  },
  "changeHistoryDetails": {
    "ccaf036662e22da14583942054898c99fa51dae5": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14539. Move commons logging APIs over to slf4j in hadoop-common. Contributed by Wenxin He.\n",
      "commitDate": "17/07/17 9:32 PM",
      "commitName": "ccaf036662e22da14583942054898c99fa51dae5",
      "commitAuthor": "Akira Ajisaka",
      "commitDateOld": "23/03/17 1:34 PM",
      "commitNameOld": "d35e79abc2fee7153a6168e6088f100de59d8c81",
      "commitAuthorOld": "Mingliang Liu",
      "daysBetweenCommits": 116.33,
      "commitsBetweenForRepo": 606,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,99 +1,99 @@\n     public void run() {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(this + \": starting with interruptCheckPeriodMs \u003d \" +\n             interruptCheckPeriodMs);\n       }\n       final TreeMap\u003cInteger, Entry\u003e entries \u003d new TreeMap\u003cInteger, Entry\u003e();\n       FdSet fdSet \u003d new FdSet();\n       addNotificationSocket(entries, fdSet);\n       try {\n         while (true) {\n           lock.lock();\n           try {\n             for (int fd : fdSet.getAndClearReadableFds()) {\n               sendCallbackAndRemove(\"getAndClearReadableFds\", entries, fdSet,\n                   fd);\n             }\n             if (!(toAdd.isEmpty() \u0026\u0026 toRemove.isEmpty())) {\n               // Handle pending additions (before pending removes).\n               for (Iterator\u003cEntry\u003e iter \u003d toAdd.iterator(); iter.hasNext(); ) {\n                 Entry entry \u003d iter.next();\n                 iter.remove();\n                 DomainSocket sock \u003d entry.getDomainSocket();\n                 Entry prevEntry \u003d entries.put(sock.fd, entry);\n                 Preconditions.checkState(prevEntry \u003d\u003d null,\n                     this + \": tried to watch a file descriptor that we \" +\n                     \"were already watching: \" + sock);\n                 if (LOG.isTraceEnabled()) {\n                   LOG.trace(this + \": adding fd \" + sock.fd);\n                 }\n                 fdSet.add(sock.fd);\n               }\n               // Handle pending removals\n               while (true) {\n                 Map.Entry\u003cInteger, DomainSocket\u003e entry \u003d toRemove.firstEntry();\n                 if (entry \u003d\u003d null) break;\n                 sendCallbackAndRemove(\"handlePendingRemovals\",\n                     entries, fdSet, entry.getValue().fd);\n               }\n               processedCond.signalAll();\n             }\n             // Check if the thread should terminate.  Doing this check now is\n             // easier than at the beginning of the loop, since we know toAdd and\n             // toRemove are now empty and processedCond has been notified if it\n             // needed to be.\n             if (closed) {\n               if (LOG.isDebugEnabled()) {\n                 LOG.debug(toString() + \" thread terminating.\");\n               }\n               return;\n             }\n             // Check if someone sent our thread an InterruptedException while we\n             // were waiting in poll().\n             if (Thread.interrupted()) {\n               throw new InterruptedException();\n             }\n           } finally {\n             lock.unlock();\n           }\n           doPoll0(interruptCheckPeriodMs, fdSet);\n         }\n       } catch (InterruptedException e) {\n         LOG.info(toString() + \" terminating on InterruptedException\");\n       } catch (Throwable e) {\n         LOG.error(toString() + \" terminating on exception\", e);\n       } finally {\n         lock.lock();\n         try {\n           kick(); // allow the handler for notificationSockets[0] to read a byte\n           for (Entry entry : entries.values()) {\n             // We do not remove from entries as we iterate, because that can\n             // cause a ConcurrentModificationException.\n             sendCallback(\"close\", entries, fdSet, entry.getDomainSocket().fd);\n           }\n           entries.clear();\n           fdSet.close();\n           closed \u003d true;\n           if (!(toAdd.isEmpty() \u0026\u0026 toRemove.isEmpty())) {\n             // Items in toAdd might not be added to entries, handle it here\n             for (Iterator\u003cEntry\u003e iter \u003d toAdd.iterator(); iter.hasNext();) {\n               Entry entry \u003d iter.next();\n               entry.getDomainSocket().refCount.unreference();\n               entry.getHandler().handle(entry.getDomainSocket());\n-              IOUtils.cleanup(LOG, entry.getDomainSocket());\n+              IOUtils.cleanupWithLogger(LOG, entry.getDomainSocket());\n               iter.remove();\n             }\n             // Items in toRemove might not be really removed, handle it here\n             while (true) {\n               Map.Entry\u003cInteger, DomainSocket\u003e entry \u003d toRemove.firstEntry();\n               if (entry \u003d\u003d null)\n                 break;\n               sendCallback(\"close\", entries, fdSet, entry.getValue().fd);\n             }\n           }\n           processedCond.signalAll();\n         } finally {\n           lock.unlock();\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(this + \": starting with interruptCheckPeriodMs \u003d \" +\n            interruptCheckPeriodMs);\n      }\n      final TreeMap\u003cInteger, Entry\u003e entries \u003d new TreeMap\u003cInteger, Entry\u003e();\n      FdSet fdSet \u003d new FdSet();\n      addNotificationSocket(entries, fdSet);\n      try {\n        while (true) {\n          lock.lock();\n          try {\n            for (int fd : fdSet.getAndClearReadableFds()) {\n              sendCallbackAndRemove(\"getAndClearReadableFds\", entries, fdSet,\n                  fd);\n            }\n            if (!(toAdd.isEmpty() \u0026\u0026 toRemove.isEmpty())) {\n              // Handle pending additions (before pending removes).\n              for (Iterator\u003cEntry\u003e iter \u003d toAdd.iterator(); iter.hasNext(); ) {\n                Entry entry \u003d iter.next();\n                iter.remove();\n                DomainSocket sock \u003d entry.getDomainSocket();\n                Entry prevEntry \u003d entries.put(sock.fd, entry);\n                Preconditions.checkState(prevEntry \u003d\u003d null,\n                    this + \": tried to watch a file descriptor that we \" +\n                    \"were already watching: \" + sock);\n                if (LOG.isTraceEnabled()) {\n                  LOG.trace(this + \": adding fd \" + sock.fd);\n                }\n                fdSet.add(sock.fd);\n              }\n              // Handle pending removals\n              while (true) {\n                Map.Entry\u003cInteger, DomainSocket\u003e entry \u003d toRemove.firstEntry();\n                if (entry \u003d\u003d null) break;\n                sendCallbackAndRemove(\"handlePendingRemovals\",\n                    entries, fdSet, entry.getValue().fd);\n              }\n              processedCond.signalAll();\n            }\n            // Check if the thread should terminate.  Doing this check now is\n            // easier than at the beginning of the loop, since we know toAdd and\n            // toRemove are now empty and processedCond has been notified if it\n            // needed to be.\n            if (closed) {\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(toString() + \" thread terminating.\");\n              }\n              return;\n            }\n            // Check if someone sent our thread an InterruptedException while we\n            // were waiting in poll().\n            if (Thread.interrupted()) {\n              throw new InterruptedException();\n            }\n          } finally {\n            lock.unlock();\n          }\n          doPoll0(interruptCheckPeriodMs, fdSet);\n        }\n      } catch (InterruptedException e) {\n        LOG.info(toString() + \" terminating on InterruptedException\");\n      } catch (Throwable e) {\n        LOG.error(toString() + \" terminating on exception\", e);\n      } finally {\n        lock.lock();\n        try {\n          kick(); // allow the handler for notificationSockets[0] to read a byte\n          for (Entry entry : entries.values()) {\n            // We do not remove from entries as we iterate, because that can\n            // cause a ConcurrentModificationException.\n            sendCallback(\"close\", entries, fdSet, entry.getDomainSocket().fd);\n          }\n          entries.clear();\n          fdSet.close();\n          closed \u003d true;\n          if (!(toAdd.isEmpty() \u0026\u0026 toRemove.isEmpty())) {\n            // Items in toAdd might not be added to entries, handle it here\n            for (Iterator\u003cEntry\u003e iter \u003d toAdd.iterator(); iter.hasNext();) {\n              Entry entry \u003d iter.next();\n              entry.getDomainSocket().refCount.unreference();\n              entry.getHandler().handle(entry.getDomainSocket());\n              IOUtils.cleanupWithLogger(LOG, entry.getDomainSocket());\n              iter.remove();\n            }\n            // Items in toRemove might not be really removed, handle it here\n            while (true) {\n              Map.Entry\u003cInteger, DomainSocket\u003e entry \u003d toRemove.firstEntry();\n              if (entry \u003d\u003d null)\n                break;\n              sendCallback(\"close\", entries, fdSet, entry.getValue().fd);\n            }\n          }\n          processedCond.signalAll();\n        } finally {\n          lock.unlock();\n        }\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/net/unix/DomainSocketWatcher.java",
      "extendedDetails": {}
    },
    "246cefa089156a50bf086b8b1e4d4324d66dc58c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8429. Avoid stuck threads if there is an error in DomainSocketWatcher that stops the thread.  (zhouyingchao via cmccabe)\n",
      "commitDate": "28/05/15 11:52 AM",
      "commitName": "246cefa089156a50bf086b8b1e4d4324d66dc58c",
      "commitAuthor": "Colin Patrick Mccabe",
      "commitDateOld": "23/04/15 7:00 PM",
      "commitNameOld": "a0e0a63209b5eb17dca5cc503be36aa52defeabd",
      "commitAuthorOld": "Colin Patrick Mccabe",
      "daysBetweenCommits": 34.7,
      "commitsBetweenForRepo": 368,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,80 +1,99 @@\n     public void run() {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(this + \": starting with interruptCheckPeriodMs \u003d \" +\n             interruptCheckPeriodMs);\n       }\n       final TreeMap\u003cInteger, Entry\u003e entries \u003d new TreeMap\u003cInteger, Entry\u003e();\n       FdSet fdSet \u003d new FdSet();\n       addNotificationSocket(entries, fdSet);\n       try {\n         while (true) {\n           lock.lock();\n           try {\n             for (int fd : fdSet.getAndClearReadableFds()) {\n               sendCallbackAndRemove(\"getAndClearReadableFds\", entries, fdSet,\n                   fd);\n             }\n             if (!(toAdd.isEmpty() \u0026\u0026 toRemove.isEmpty())) {\n               // Handle pending additions (before pending removes).\n               for (Iterator\u003cEntry\u003e iter \u003d toAdd.iterator(); iter.hasNext(); ) {\n                 Entry entry \u003d iter.next();\n+                iter.remove();\n                 DomainSocket sock \u003d entry.getDomainSocket();\n                 Entry prevEntry \u003d entries.put(sock.fd, entry);\n                 Preconditions.checkState(prevEntry \u003d\u003d null,\n                     this + \": tried to watch a file descriptor that we \" +\n                     \"were already watching: \" + sock);\n                 if (LOG.isTraceEnabled()) {\n                   LOG.trace(this + \": adding fd \" + sock.fd);\n                 }\n                 fdSet.add(sock.fd);\n-                iter.remove();\n               }\n               // Handle pending removals\n               while (true) {\n                 Map.Entry\u003cInteger, DomainSocket\u003e entry \u003d toRemove.firstEntry();\n                 if (entry \u003d\u003d null) break;\n                 sendCallbackAndRemove(\"handlePendingRemovals\",\n                     entries, fdSet, entry.getValue().fd);\n               }\n               processedCond.signalAll();\n             }\n             // Check if the thread should terminate.  Doing this check now is\n             // easier than at the beginning of the loop, since we know toAdd and\n             // toRemove are now empty and processedCond has been notified if it\n             // needed to be.\n             if (closed) {\n               if (LOG.isDebugEnabled()) {\n                 LOG.debug(toString() + \" thread terminating.\");\n               }\n               return;\n             }\n             // Check if someone sent our thread an InterruptedException while we\n             // were waiting in poll().\n             if (Thread.interrupted()) {\n               throw new InterruptedException();\n             }\n           } finally {\n             lock.unlock();\n           }\n           doPoll0(interruptCheckPeriodMs, fdSet);\n         }\n       } catch (InterruptedException e) {\n         LOG.info(toString() + \" terminating on InterruptedException\");\n       } catch (Throwable e) {\n         LOG.error(toString() + \" terminating on exception\", e);\n       } finally {\n         lock.lock();\n         try {\n           kick(); // allow the handler for notificationSockets[0] to read a byte\n           for (Entry entry : entries.values()) {\n             // We do not remove from entries as we iterate, because that can\n             // cause a ConcurrentModificationException.\n             sendCallback(\"close\", entries, fdSet, entry.getDomainSocket().fd);\n           }\n           entries.clear();\n           fdSet.close();\n+          closed \u003d true;\n+          if (!(toAdd.isEmpty() \u0026\u0026 toRemove.isEmpty())) {\n+            // Items in toAdd might not be added to entries, handle it here\n+            for (Iterator\u003cEntry\u003e iter \u003d toAdd.iterator(); iter.hasNext();) {\n+              Entry entry \u003d iter.next();\n+              entry.getDomainSocket().refCount.unreference();\n+              entry.getHandler().handle(entry.getDomainSocket());\n+              IOUtils.cleanup(LOG, entry.getDomainSocket());\n+              iter.remove();\n+            }\n+            // Items in toRemove might not be really removed, handle it here\n+            while (true) {\n+              Map.Entry\u003cInteger, DomainSocket\u003e entry \u003d toRemove.firstEntry();\n+              if (entry \u003d\u003d null)\n+                break;\n+              sendCallback(\"close\", entries, fdSet, entry.getValue().fd);\n+            }\n+          }\n+          processedCond.signalAll();\n         } finally {\n           lock.unlock();\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(this + \": starting with interruptCheckPeriodMs \u003d \" +\n            interruptCheckPeriodMs);\n      }\n      final TreeMap\u003cInteger, Entry\u003e entries \u003d new TreeMap\u003cInteger, Entry\u003e();\n      FdSet fdSet \u003d new FdSet();\n      addNotificationSocket(entries, fdSet);\n      try {\n        while (true) {\n          lock.lock();\n          try {\n            for (int fd : fdSet.getAndClearReadableFds()) {\n              sendCallbackAndRemove(\"getAndClearReadableFds\", entries, fdSet,\n                  fd);\n            }\n            if (!(toAdd.isEmpty() \u0026\u0026 toRemove.isEmpty())) {\n              // Handle pending additions (before pending removes).\n              for (Iterator\u003cEntry\u003e iter \u003d toAdd.iterator(); iter.hasNext(); ) {\n                Entry entry \u003d iter.next();\n                iter.remove();\n                DomainSocket sock \u003d entry.getDomainSocket();\n                Entry prevEntry \u003d entries.put(sock.fd, entry);\n                Preconditions.checkState(prevEntry \u003d\u003d null,\n                    this + \": tried to watch a file descriptor that we \" +\n                    \"were already watching: \" + sock);\n                if (LOG.isTraceEnabled()) {\n                  LOG.trace(this + \": adding fd \" + sock.fd);\n                }\n                fdSet.add(sock.fd);\n              }\n              // Handle pending removals\n              while (true) {\n                Map.Entry\u003cInteger, DomainSocket\u003e entry \u003d toRemove.firstEntry();\n                if (entry \u003d\u003d null) break;\n                sendCallbackAndRemove(\"handlePendingRemovals\",\n                    entries, fdSet, entry.getValue().fd);\n              }\n              processedCond.signalAll();\n            }\n            // Check if the thread should terminate.  Doing this check now is\n            // easier than at the beginning of the loop, since we know toAdd and\n            // toRemove are now empty and processedCond has been notified if it\n            // needed to be.\n            if (closed) {\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(toString() + \" thread terminating.\");\n              }\n              return;\n            }\n            // Check if someone sent our thread an InterruptedException while we\n            // were waiting in poll().\n            if (Thread.interrupted()) {\n              throw new InterruptedException();\n            }\n          } finally {\n            lock.unlock();\n          }\n          doPoll0(interruptCheckPeriodMs, fdSet);\n        }\n      } catch (InterruptedException e) {\n        LOG.info(toString() + \" terminating on InterruptedException\");\n      } catch (Throwable e) {\n        LOG.error(toString() + \" terminating on exception\", e);\n      } finally {\n        lock.lock();\n        try {\n          kick(); // allow the handler for notificationSockets[0] to read a byte\n          for (Entry entry : entries.values()) {\n            // We do not remove from entries as we iterate, because that can\n            // cause a ConcurrentModificationException.\n            sendCallback(\"close\", entries, fdSet, entry.getDomainSocket().fd);\n          }\n          entries.clear();\n          fdSet.close();\n          closed \u003d true;\n          if (!(toAdd.isEmpty() \u0026\u0026 toRemove.isEmpty())) {\n            // Items in toAdd might not be added to entries, handle it here\n            for (Iterator\u003cEntry\u003e iter \u003d toAdd.iterator(); iter.hasNext();) {\n              Entry entry \u003d iter.next();\n              entry.getDomainSocket().refCount.unreference();\n              entry.getHandler().handle(entry.getDomainSocket());\n              IOUtils.cleanup(LOG, entry.getDomainSocket());\n              iter.remove();\n            }\n            // Items in toRemove might not be really removed, handle it here\n            while (true) {\n              Map.Entry\u003cInteger, DomainSocket\u003e entry \u003d toRemove.firstEntry();\n              if (entry \u003d\u003d null)\n                break;\n              sendCallback(\"close\", entries, fdSet, entry.getValue().fd);\n            }\n          }\n          processedCond.signalAll();\n        } finally {\n          lock.unlock();\n        }\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/net/unix/DomainSocketWatcher.java",
      "extendedDetails": {}
    },
    "a0e0a63209b5eb17dca5cc503be36aa52defeabd": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11802. DomainSocketWatcher thread terminates sometimes after there is an I/O error during requestShortCircuitShm (cmccabe)\n",
      "commitDate": "23/04/15 7:00 PM",
      "commitName": "a0e0a63209b5eb17dca5cc503be36aa52defeabd",
      "commitAuthor": "Colin Patrick Mccabe",
      "commitDateOld": "04/03/15 11:05 PM",
      "commitNameOld": "74a4754d1c790b8740a4221f276aa571bc5dbfd5",
      "commitAuthorOld": "Tsuyoshi Ozawa",
      "daysBetweenCommits": 49.79,
      "commitsBetweenForRepo": 430,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,80 +1,80 @@\n     public void run() {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(this + \": starting with interruptCheckPeriodMs \u003d \" +\n             interruptCheckPeriodMs);\n       }\n       final TreeMap\u003cInteger, Entry\u003e entries \u003d new TreeMap\u003cInteger, Entry\u003e();\n       FdSet fdSet \u003d new FdSet();\n       addNotificationSocket(entries, fdSet);\n       try {\n         while (true) {\n           lock.lock();\n           try {\n             for (int fd : fdSet.getAndClearReadableFds()) {\n               sendCallbackAndRemove(\"getAndClearReadableFds\", entries, fdSet,\n                   fd);\n             }\n             if (!(toAdd.isEmpty() \u0026\u0026 toRemove.isEmpty())) {\n               // Handle pending additions (before pending removes).\n               for (Iterator\u003cEntry\u003e iter \u003d toAdd.iterator(); iter.hasNext(); ) {\n                 Entry entry \u003d iter.next();\n                 DomainSocket sock \u003d entry.getDomainSocket();\n                 Entry prevEntry \u003d entries.put(sock.fd, entry);\n                 Preconditions.checkState(prevEntry \u003d\u003d null,\n                     this + \": tried to watch a file descriptor that we \" +\n                     \"were already watching: \" + sock);\n                 if (LOG.isTraceEnabled()) {\n                   LOG.trace(this + \": adding fd \" + sock.fd);\n                 }\n                 fdSet.add(sock.fd);\n                 iter.remove();\n               }\n               // Handle pending removals\n               while (true) {\n                 Map.Entry\u003cInteger, DomainSocket\u003e entry \u003d toRemove.firstEntry();\n                 if (entry \u003d\u003d null) break;\n                 sendCallbackAndRemove(\"handlePendingRemovals\",\n                     entries, fdSet, entry.getValue().fd);\n               }\n               processedCond.signalAll();\n             }\n             // Check if the thread should terminate.  Doing this check now is\n             // easier than at the beginning of the loop, since we know toAdd and\n             // toRemove are now empty and processedCond has been notified if it\n             // needed to be.\n             if (closed) {\n               if (LOG.isDebugEnabled()) {\n                 LOG.debug(toString() + \" thread terminating.\");\n               }\n               return;\n             }\n             // Check if someone sent our thread an InterruptedException while we\n             // were waiting in poll().\n             if (Thread.interrupted()) {\n               throw new InterruptedException();\n             }\n           } finally {\n             lock.unlock();\n           }\n           doPoll0(interruptCheckPeriodMs, fdSet);\n         }\n       } catch (InterruptedException e) {\n         LOG.info(toString() + \" terminating on InterruptedException\");\n-      } catch (IOException e) {\n-        LOG.error(toString() + \" terminating on IOException\", e);\n+      } catch (Throwable e) {\n+        LOG.error(toString() + \" terminating on exception\", e);\n       } finally {\n         lock.lock();\n         try {\n           kick(); // allow the handler for notificationSockets[0] to read a byte\n           for (Entry entry : entries.values()) {\n             // We do not remove from entries as we iterate, because that can\n             // cause a ConcurrentModificationException.\n             sendCallback(\"close\", entries, fdSet, entry.getDomainSocket().fd);\n           }\n           entries.clear();\n           fdSet.close();\n         } finally {\n           lock.unlock();\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(this + \": starting with interruptCheckPeriodMs \u003d \" +\n            interruptCheckPeriodMs);\n      }\n      final TreeMap\u003cInteger, Entry\u003e entries \u003d new TreeMap\u003cInteger, Entry\u003e();\n      FdSet fdSet \u003d new FdSet();\n      addNotificationSocket(entries, fdSet);\n      try {\n        while (true) {\n          lock.lock();\n          try {\n            for (int fd : fdSet.getAndClearReadableFds()) {\n              sendCallbackAndRemove(\"getAndClearReadableFds\", entries, fdSet,\n                  fd);\n            }\n            if (!(toAdd.isEmpty() \u0026\u0026 toRemove.isEmpty())) {\n              // Handle pending additions (before pending removes).\n              for (Iterator\u003cEntry\u003e iter \u003d toAdd.iterator(); iter.hasNext(); ) {\n                Entry entry \u003d iter.next();\n                DomainSocket sock \u003d entry.getDomainSocket();\n                Entry prevEntry \u003d entries.put(sock.fd, entry);\n                Preconditions.checkState(prevEntry \u003d\u003d null,\n                    this + \": tried to watch a file descriptor that we \" +\n                    \"were already watching: \" + sock);\n                if (LOG.isTraceEnabled()) {\n                  LOG.trace(this + \": adding fd \" + sock.fd);\n                }\n                fdSet.add(sock.fd);\n                iter.remove();\n              }\n              // Handle pending removals\n              while (true) {\n                Map.Entry\u003cInteger, DomainSocket\u003e entry \u003d toRemove.firstEntry();\n                if (entry \u003d\u003d null) break;\n                sendCallbackAndRemove(\"handlePendingRemovals\",\n                    entries, fdSet, entry.getValue().fd);\n              }\n              processedCond.signalAll();\n            }\n            // Check if the thread should terminate.  Doing this check now is\n            // easier than at the beginning of the loop, since we know toAdd and\n            // toRemove are now empty and processedCond has been notified if it\n            // needed to be.\n            if (closed) {\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(toString() + \" thread terminating.\");\n              }\n              return;\n            }\n            // Check if someone sent our thread an InterruptedException while we\n            // were waiting in poll().\n            if (Thread.interrupted()) {\n              throw new InterruptedException();\n            }\n          } finally {\n            lock.unlock();\n          }\n          doPoll0(interruptCheckPeriodMs, fdSet);\n        }\n      } catch (InterruptedException e) {\n        LOG.info(toString() + \" terminating on InterruptedException\");\n      } catch (Throwable e) {\n        LOG.error(toString() + \" terminating on exception\", e);\n      } finally {\n        lock.lock();\n        try {\n          kick(); // allow the handler for notificationSockets[0] to read a byte\n          for (Entry entry : entries.values()) {\n            // We do not remove from entries as we iterate, because that can\n            // cause a ConcurrentModificationException.\n            sendCallback(\"close\", entries, fdSet, entry.getDomainSocket().fd);\n          }\n          entries.clear();\n          fdSet.close();\n        } finally {\n          lock.unlock();\n        }\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/net/unix/DomainSocketWatcher.java",
      "extendedDetails": {}
    },
    "3c5ff0759c4f4e10c97c6d9036add00edb8be2b5": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11604. Prevent ConcurrentModificationException while closing domain sockets during shutdown of DomainSocketWatcher thread. Contributed by Chris Nauroth.\n",
      "commitDate": "20/02/15 1:07 PM",
      "commitName": "3c5ff0759c4f4e10c97c6d9036add00edb8be2b5",
      "commitAuthor": "cnauroth",
      "commitDateOld": "01/12/14 11:42 AM",
      "commitNameOld": "86e3993def01223f92b8d1dd35f6c1f8ab6033f5",
      "commitAuthorOld": "Colin Patrick Mccabe",
      "daysBetweenCommits": 81.06,
      "commitsBetweenForRepo": 633,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,77 +1,80 @@\n     public void run() {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(this + \": starting with interruptCheckPeriodMs \u003d \" +\n             interruptCheckPeriodMs);\n       }\n       final TreeMap\u003cInteger, Entry\u003e entries \u003d new TreeMap\u003cInteger, Entry\u003e();\n       FdSet fdSet \u003d new FdSet();\n       addNotificationSocket(entries, fdSet);\n       try {\n         while (true) {\n           lock.lock();\n           try {\n             for (int fd : fdSet.getAndClearReadableFds()) {\n-              sendCallback(\"getAndClearReadableFds\", entries, fdSet, fd);\n+              sendCallbackAndRemove(\"getAndClearReadableFds\", entries, fdSet,\n+                  fd);\n             }\n             if (!(toAdd.isEmpty() \u0026\u0026 toRemove.isEmpty())) {\n               // Handle pending additions (before pending removes).\n               for (Iterator\u003cEntry\u003e iter \u003d toAdd.iterator(); iter.hasNext(); ) {\n                 Entry entry \u003d iter.next();\n                 DomainSocket sock \u003d entry.getDomainSocket();\n                 Entry prevEntry \u003d entries.put(sock.fd, entry);\n                 Preconditions.checkState(prevEntry \u003d\u003d null,\n                     this + \": tried to watch a file descriptor that we \" +\n                     \"were already watching: \" + sock);\n                 if (LOG.isTraceEnabled()) {\n                   LOG.trace(this + \": adding fd \" + sock.fd);\n                 }\n                 fdSet.add(sock.fd);\n                 iter.remove();\n               }\n               // Handle pending removals\n               while (true) {\n                 Map.Entry\u003cInteger, DomainSocket\u003e entry \u003d toRemove.firstEntry();\n                 if (entry \u003d\u003d null) break;\n-                sendCallback(\"handlePendingRemovals\",\n+                sendCallbackAndRemove(\"handlePendingRemovals\",\n                     entries, fdSet, entry.getValue().fd);\n               }\n               processedCond.signalAll();\n             }\n             // Check if the thread should terminate.  Doing this check now is\n             // easier than at the beginning of the loop, since we know toAdd and\n             // toRemove are now empty and processedCond has been notified if it\n             // needed to be.\n             if (closed) {\n               if (LOG.isDebugEnabled()) {\n                 LOG.debug(toString() + \" thread terminating.\");\n               }\n               return;\n             }\n             // Check if someone sent our thread an InterruptedException while we\n             // were waiting in poll().\n             if (Thread.interrupted()) {\n               throw new InterruptedException();\n             }\n           } finally {\n             lock.unlock();\n           }\n           doPoll0(interruptCheckPeriodMs, fdSet);\n         }\n       } catch (InterruptedException e) {\n         LOG.info(toString() + \" terminating on InterruptedException\");\n       } catch (IOException e) {\n         LOG.error(toString() + \" terminating on IOException\", e);\n       } finally {\n         lock.lock();\n         try {\n           kick(); // allow the handler for notificationSockets[0] to read a byte\n           for (Entry entry : entries.values()) {\n+            // We do not remove from entries as we iterate, because that can\n+            // cause a ConcurrentModificationException.\n             sendCallback(\"close\", entries, fdSet, entry.getDomainSocket().fd);\n           }\n           entries.clear();\n           fdSet.close();\n         } finally {\n           lock.unlock();\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(this + \": starting with interruptCheckPeriodMs \u003d \" +\n            interruptCheckPeriodMs);\n      }\n      final TreeMap\u003cInteger, Entry\u003e entries \u003d new TreeMap\u003cInteger, Entry\u003e();\n      FdSet fdSet \u003d new FdSet();\n      addNotificationSocket(entries, fdSet);\n      try {\n        while (true) {\n          lock.lock();\n          try {\n            for (int fd : fdSet.getAndClearReadableFds()) {\n              sendCallbackAndRemove(\"getAndClearReadableFds\", entries, fdSet,\n                  fd);\n            }\n            if (!(toAdd.isEmpty() \u0026\u0026 toRemove.isEmpty())) {\n              // Handle pending additions (before pending removes).\n              for (Iterator\u003cEntry\u003e iter \u003d toAdd.iterator(); iter.hasNext(); ) {\n                Entry entry \u003d iter.next();\n                DomainSocket sock \u003d entry.getDomainSocket();\n                Entry prevEntry \u003d entries.put(sock.fd, entry);\n                Preconditions.checkState(prevEntry \u003d\u003d null,\n                    this + \": tried to watch a file descriptor that we \" +\n                    \"were already watching: \" + sock);\n                if (LOG.isTraceEnabled()) {\n                  LOG.trace(this + \": adding fd \" + sock.fd);\n                }\n                fdSet.add(sock.fd);\n                iter.remove();\n              }\n              // Handle pending removals\n              while (true) {\n                Map.Entry\u003cInteger, DomainSocket\u003e entry \u003d toRemove.firstEntry();\n                if (entry \u003d\u003d null) break;\n                sendCallbackAndRemove(\"handlePendingRemovals\",\n                    entries, fdSet, entry.getValue().fd);\n              }\n              processedCond.signalAll();\n            }\n            // Check if the thread should terminate.  Doing this check now is\n            // easier than at the beginning of the loop, since we know toAdd and\n            // toRemove are now empty and processedCond has been notified if it\n            // needed to be.\n            if (closed) {\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(toString() + \" thread terminating.\");\n              }\n              return;\n            }\n            // Check if someone sent our thread an InterruptedException while we\n            // were waiting in poll().\n            if (Thread.interrupted()) {\n              throw new InterruptedException();\n            }\n          } finally {\n            lock.unlock();\n          }\n          doPoll0(interruptCheckPeriodMs, fdSet);\n        }\n      } catch (InterruptedException e) {\n        LOG.info(toString() + \" terminating on InterruptedException\");\n      } catch (IOException e) {\n        LOG.error(toString() + \" terminating on IOException\", e);\n      } finally {\n        lock.lock();\n        try {\n          kick(); // allow the handler for notificationSockets[0] to read a byte\n          for (Entry entry : entries.values()) {\n            // We do not remove from entries as we iterate, because that can\n            // cause a ConcurrentModificationException.\n            sendCallback(\"close\", entries, fdSet, entry.getDomainSocket().fd);\n          }\n          entries.clear();\n          fdSet.close();\n        } finally {\n          lock.unlock();\n        }\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/net/unix/DomainSocketWatcher.java",
      "extendedDetails": {}
    },
    "687d83c9e10a4432c8d54c2cd406c7ccb4392187": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10404.  Commit correct version of patch (cmccabe)\n",
      "commitDate": "06/10/14 2:44 PM",
      "commitName": "687d83c9e10a4432c8d54c2cd406c7ccb4392187",
      "commitAuthor": "Colin Patrick Mccabe",
      "commitDateOld": "06/10/14 2:40 PM",
      "commitNameOld": "8099de259fb91a29674bf17cb1382c038b707a90",
      "commitAuthorOld": "Colin Patrick Mccabe",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,72 +1,77 @@\n     public void run() {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(this + \": starting with interruptCheckPeriodMs \u003d \" +\n             interruptCheckPeriodMs);\n       }\n       final TreeMap\u003cInteger, Entry\u003e entries \u003d new TreeMap\u003cInteger, Entry\u003e();\n       FdSet fdSet \u003d new FdSet();\n       addNotificationSocket(entries, fdSet);\n       try {\n         while (true) {\n           lock.lock();\n           try {\n             for (int fd : fdSet.getAndClearReadableFds()) {\n               sendCallback(\"getAndClearReadableFds\", entries, fdSet, fd);\n             }\n             if (!(toAdd.isEmpty() \u0026\u0026 toRemove.isEmpty())) {\n               // Handle pending additions (before pending removes).\n               for (Iterator\u003cEntry\u003e iter \u003d toAdd.iterator(); iter.hasNext(); ) {\n                 Entry entry \u003d iter.next();\n                 DomainSocket sock \u003d entry.getDomainSocket();\n                 Entry prevEntry \u003d entries.put(sock.fd, entry);\n                 Preconditions.checkState(prevEntry \u003d\u003d null,\n                     this + \": tried to watch a file descriptor that we \" +\n                     \"were already watching: \" + sock);\n                 if (LOG.isTraceEnabled()) {\n                   LOG.trace(this + \": adding fd \" + sock.fd);\n                 }\n                 fdSet.add(sock.fd);\n                 iter.remove();\n               }\n               // Handle pending removals\n               while (true) {\n                 Map.Entry\u003cInteger, DomainSocket\u003e entry \u003d toRemove.firstEntry();\n                 if (entry \u003d\u003d null) break;\n                 sendCallback(\"handlePendingRemovals\",\n                     entries, fdSet, entry.getValue().fd);\n               }\n               processedCond.signalAll();\n             }\n             // Check if the thread should terminate.  Doing this check now is\n             // easier than at the beginning of the loop, since we know toAdd and\n             // toRemove are now empty and processedCond has been notified if it\n             // needed to be.\n             if (closed) {\n               if (LOG.isDebugEnabled()) {\n                 LOG.debug(toString() + \" thread terminating.\");\n               }\n               return;\n             }\n             // Check if someone sent our thread an InterruptedException while we\n             // were waiting in poll().\n             if (Thread.interrupted()) {\n               throw new InterruptedException();\n             }\n           } finally {\n             lock.unlock();\n           }\n           doPoll0(interruptCheckPeriodMs, fdSet);\n         }\n       } catch (InterruptedException e) {\n         LOG.info(toString() + \" terminating on InterruptedException\");\n       } catch (IOException e) {\n         LOG.error(toString() + \" terminating on IOException\", e);\n       } finally {\n-        kick(); // allow the handler for notificationSockets[0] to read a byte\n-        for (Entry entry : entries.values()) {\n-          sendCallback(\"close\", entries, fdSet, entry.getDomainSocket().fd);\n+        lock.lock();\n+        try {\n+          kick(); // allow the handler for notificationSockets[0] to read a byte\n+          for (Entry entry : entries.values()) {\n+            sendCallback(\"close\", entries, fdSet, entry.getDomainSocket().fd);\n+          }\n+          entries.clear();\n+          fdSet.close();\n+        } finally {\n+          lock.unlock();\n         }\n-        entries.clear();\n-        fdSet.close();\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(this + \": starting with interruptCheckPeriodMs \u003d \" +\n            interruptCheckPeriodMs);\n      }\n      final TreeMap\u003cInteger, Entry\u003e entries \u003d new TreeMap\u003cInteger, Entry\u003e();\n      FdSet fdSet \u003d new FdSet();\n      addNotificationSocket(entries, fdSet);\n      try {\n        while (true) {\n          lock.lock();\n          try {\n            for (int fd : fdSet.getAndClearReadableFds()) {\n              sendCallback(\"getAndClearReadableFds\", entries, fdSet, fd);\n            }\n            if (!(toAdd.isEmpty() \u0026\u0026 toRemove.isEmpty())) {\n              // Handle pending additions (before pending removes).\n              for (Iterator\u003cEntry\u003e iter \u003d toAdd.iterator(); iter.hasNext(); ) {\n                Entry entry \u003d iter.next();\n                DomainSocket sock \u003d entry.getDomainSocket();\n                Entry prevEntry \u003d entries.put(sock.fd, entry);\n                Preconditions.checkState(prevEntry \u003d\u003d null,\n                    this + \": tried to watch a file descriptor that we \" +\n                    \"were already watching: \" + sock);\n                if (LOG.isTraceEnabled()) {\n                  LOG.trace(this + \": adding fd \" + sock.fd);\n                }\n                fdSet.add(sock.fd);\n                iter.remove();\n              }\n              // Handle pending removals\n              while (true) {\n                Map.Entry\u003cInteger, DomainSocket\u003e entry \u003d toRemove.firstEntry();\n                if (entry \u003d\u003d null) break;\n                sendCallback(\"handlePendingRemovals\",\n                    entries, fdSet, entry.getValue().fd);\n              }\n              processedCond.signalAll();\n            }\n            // Check if the thread should terminate.  Doing this check now is\n            // easier than at the beginning of the loop, since we know toAdd and\n            // toRemove are now empty and processedCond has been notified if it\n            // needed to be.\n            if (closed) {\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(toString() + \" thread terminating.\");\n              }\n              return;\n            }\n            // Check if someone sent our thread an InterruptedException while we\n            // were waiting in poll().\n            if (Thread.interrupted()) {\n              throw new InterruptedException();\n            }\n          } finally {\n            lock.unlock();\n          }\n          doPoll0(interruptCheckPeriodMs, fdSet);\n        }\n      } catch (InterruptedException e) {\n        LOG.info(toString() + \" terminating on InterruptedException\");\n      } catch (IOException e) {\n        LOG.error(toString() + \" terminating on IOException\", e);\n      } finally {\n        lock.lock();\n        try {\n          kick(); // allow the handler for notificationSockets[0] to read a byte\n          for (Entry entry : entries.values()) {\n            sendCallback(\"close\", entries, fdSet, entry.getDomainSocket().fd);\n          }\n          entries.clear();\n          fdSet.close();\n        } finally {\n          lock.unlock();\n        }\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/net/unix/DomainSocketWatcher.java",
      "extendedDetails": {}
    },
    "33500fd304ee1c9a1b5966de1eb1e78b58f0af26": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6040. fix DFSClient issue without libhadoop.so and some other ShortCircuitShm cleanups (cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1573883 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/03/14 10:31 PM",
      "commitName": "33500fd304ee1c9a1b5966de1eb1e78b58f0af26",
      "commitAuthor": "Colin McCabe",
      "commitDateOld": "02/03/14 7:58 PM",
      "commitNameOld": "dd049a2f6097da189ccce2f5890a2b9bc77fa73f",
      "commitAuthorOld": "Colin McCabe",
      "daysBetweenCommits": 1.11,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,68 +1,72 @@\n     public void run() {\n-      LOG.info(this + \": starting with interruptCheckPeriodMs \u003d \" +\n-          interruptCheckPeriodMs);\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(this + \": starting with interruptCheckPeriodMs \u003d \" +\n+            interruptCheckPeriodMs);\n+      }\n       final TreeMap\u003cInteger, Entry\u003e entries \u003d new TreeMap\u003cInteger, Entry\u003e();\n       FdSet fdSet \u003d new FdSet();\n       addNotificationSocket(entries, fdSet);\n       try {\n         while (true) {\n           lock.lock();\n           try {\n             for (int fd : fdSet.getAndClearReadableFds()) {\n               sendCallback(\"getAndClearReadableFds\", entries, fdSet, fd);\n             }\n             if (!(toAdd.isEmpty() \u0026\u0026 toRemove.isEmpty())) {\n               // Handle pending additions (before pending removes).\n               for (Iterator\u003cEntry\u003e iter \u003d toAdd.iterator(); iter.hasNext(); ) {\n                 Entry entry \u003d iter.next();\n                 DomainSocket sock \u003d entry.getDomainSocket();\n                 Entry prevEntry \u003d entries.put(sock.fd, entry);\n                 Preconditions.checkState(prevEntry \u003d\u003d null,\n                     this + \": tried to watch a file descriptor that we \" +\n                     \"were already watching: \" + sock);\n                 if (LOG.isTraceEnabled()) {\n                   LOG.trace(this + \": adding fd \" + sock.fd);\n                 }\n                 fdSet.add(sock.fd);\n                 iter.remove();\n               }\n               // Handle pending removals\n               while (true) {\n                 Map.Entry\u003cInteger, DomainSocket\u003e entry \u003d toRemove.firstEntry();\n                 if (entry \u003d\u003d null) break;\n                 sendCallback(\"handlePendingRemovals\",\n                     entries, fdSet, entry.getValue().fd);\n               }\n               processedCond.signalAll();\n             }\n             // Check if the thread should terminate.  Doing this check now is\n             // easier than at the beginning of the loop, since we know toAdd and\n             // toRemove are now empty and processedCond has been notified if it\n             // needed to be.\n             if (closed) {\n-              LOG.info(toString() + \" thread terminating.\");\n+              if (LOG.isDebugEnabled()) {\n+                LOG.debug(toString() + \" thread terminating.\");\n+              }\n               return;\n             }\n             // Check if someone sent our thread an InterruptedException while we\n             // were waiting in poll().\n             if (Thread.interrupted()) {\n               throw new InterruptedException();\n             }\n           } finally {\n             lock.unlock();\n           }\n           doPoll0(interruptCheckPeriodMs, fdSet);\n         }\n       } catch (InterruptedException e) {\n         LOG.info(toString() + \" terminating on InterruptedException\");\n       } catch (IOException e) {\n         LOG.error(toString() + \" terminating on IOException\", e);\n       } finally {\n         kick(); // allow the handler for notificationSockets[0] to read a byte\n         for (Entry entry : entries.values()) {\n           sendCallback(\"close\", entries, fdSet, entry.getDomainSocket().fd);\n         }\n         entries.clear();\n         fdSet.close();\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(this + \": starting with interruptCheckPeriodMs \u003d \" +\n            interruptCheckPeriodMs);\n      }\n      final TreeMap\u003cInteger, Entry\u003e entries \u003d new TreeMap\u003cInteger, Entry\u003e();\n      FdSet fdSet \u003d new FdSet();\n      addNotificationSocket(entries, fdSet);\n      try {\n        while (true) {\n          lock.lock();\n          try {\n            for (int fd : fdSet.getAndClearReadableFds()) {\n              sendCallback(\"getAndClearReadableFds\", entries, fdSet, fd);\n            }\n            if (!(toAdd.isEmpty() \u0026\u0026 toRemove.isEmpty())) {\n              // Handle pending additions (before pending removes).\n              for (Iterator\u003cEntry\u003e iter \u003d toAdd.iterator(); iter.hasNext(); ) {\n                Entry entry \u003d iter.next();\n                DomainSocket sock \u003d entry.getDomainSocket();\n                Entry prevEntry \u003d entries.put(sock.fd, entry);\n                Preconditions.checkState(prevEntry \u003d\u003d null,\n                    this + \": tried to watch a file descriptor that we \" +\n                    \"were already watching: \" + sock);\n                if (LOG.isTraceEnabled()) {\n                  LOG.trace(this + \": adding fd \" + sock.fd);\n                }\n                fdSet.add(sock.fd);\n                iter.remove();\n              }\n              // Handle pending removals\n              while (true) {\n                Map.Entry\u003cInteger, DomainSocket\u003e entry \u003d toRemove.firstEntry();\n                if (entry \u003d\u003d null) break;\n                sendCallback(\"handlePendingRemovals\",\n                    entries, fdSet, entry.getValue().fd);\n              }\n              processedCond.signalAll();\n            }\n            // Check if the thread should terminate.  Doing this check now is\n            // easier than at the beginning of the loop, since we know toAdd and\n            // toRemove are now empty and processedCond has been notified if it\n            // needed to be.\n            if (closed) {\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(toString() + \" thread terminating.\");\n              }\n              return;\n            }\n            // Check if someone sent our thread an InterruptedException while we\n            // were waiting in poll().\n            if (Thread.interrupted()) {\n              throw new InterruptedException();\n            }\n          } finally {\n            lock.unlock();\n          }\n          doPoll0(interruptCheckPeriodMs, fdSet);\n        }\n      } catch (InterruptedException e) {\n        LOG.info(toString() + \" terminating on InterruptedException\");\n      } catch (IOException e) {\n        LOG.error(toString() + \" terminating on IOException\", e);\n      } finally {\n        kick(); // allow the handler for notificationSockets[0] to read a byte\n        for (Entry entry : entries.values()) {\n          sendCallback(\"close\", entries, fdSet, entry.getDomainSocket().fd);\n        }\n        entries.clear();\n        fdSet.close();\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/net/unix/DomainSocketWatcher.java",
      "extendedDetails": {}
    },
    "f0d64a078da7e932b9509734f75170e3e525e68c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5940.  Minor cleanups to ShortCircuitReplica, FsDatasetCache, and DomainSocketWatcher (cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1567835 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/02/14 7:10 PM",
      "commitName": "f0d64a078da7e932b9509734f75170e3e525e68c",
      "commitAuthor": "Colin McCabe",
      "commitDateOld": "31/01/14 6:25 PM",
      "commitNameOld": "140246bad816ae7bf06eda193cc624e1e62923e0",
      "commitAuthorOld": "Colin McCabe",
      "daysBetweenCommits": 12.03,
      "commitsBetweenForRepo": 86,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,67 +1,68 @@\n     public void run() {\n       LOG.info(this + \": starting with interruptCheckPeriodMs \u003d \" +\n           interruptCheckPeriodMs);\n       final TreeMap\u003cInteger, Entry\u003e entries \u003d new TreeMap\u003cInteger, Entry\u003e();\n       FdSet fdSet \u003d new FdSet();\n       addNotificationSocket(entries, fdSet);\n       try {\n         while (true) {\n           lock.lock();\n           try {\n             for (int fd : fdSet.getAndClearReadableFds()) {\n               sendCallback(\"getAndClearReadableFds\", entries, fdSet, fd);\n             }\n             if (!(toAdd.isEmpty() \u0026\u0026 toRemove.isEmpty())) {\n               // Handle pending additions (before pending removes).\n               for (Iterator\u003cEntry\u003e iter \u003d toAdd.iterator(); iter.hasNext(); ) {\n                 Entry entry \u003d iter.next();\n                 DomainSocket sock \u003d entry.getDomainSocket();\n                 Entry prevEntry \u003d entries.put(sock.fd, entry);\n                 Preconditions.checkState(prevEntry \u003d\u003d null,\n                     this + \": tried to watch a file descriptor that we \" +\n                     \"were already watching: \" + sock);\n                 if (LOG.isTraceEnabled()) {\n                   LOG.trace(this + \": adding fd \" + sock.fd);\n                 }\n                 fdSet.add(sock.fd);\n                 iter.remove();\n               }\n               // Handle pending removals\n               while (true) {\n                 Map.Entry\u003cInteger, DomainSocket\u003e entry \u003d toRemove.firstEntry();\n                 if (entry \u003d\u003d null) break;\n                 sendCallback(\"handlePendingRemovals\",\n                     entries, fdSet, entry.getValue().fd);\n               }\n               processedCond.signalAll();\n             }\n             // Check if the thread should terminate.  Doing this check now is\n             // easier than at the beginning of the loop, since we know toAdd and\n             // toRemove are now empty and processedCond has been notified if it\n             // needed to be.\n             if (closed) {\n               LOG.info(toString() + \" thread terminating.\");\n               return;\n             }\n             // Check if someone sent our thread an InterruptedException while we\n             // were waiting in poll().\n             if (Thread.interrupted()) {\n               throw new InterruptedException();\n             }\n           } finally {\n             lock.unlock();\n           }\n           doPoll0(interruptCheckPeriodMs, fdSet);\n         }\n       } catch (InterruptedException e) {\n         LOG.info(toString() + \" terminating on InterruptedException\");\n       } catch (IOException e) {\n         LOG.error(toString() + \" terminating on IOException\", e);\n       } finally {\n+        kick(); // allow the handler for notificationSockets[0] to read a byte\n         for (Entry entry : entries.values()) {\n           sendCallback(\"close\", entries, fdSet, entry.getDomainSocket().fd);\n         }\n         entries.clear();\n         fdSet.close();\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      LOG.info(this + \": starting with interruptCheckPeriodMs \u003d \" +\n          interruptCheckPeriodMs);\n      final TreeMap\u003cInteger, Entry\u003e entries \u003d new TreeMap\u003cInteger, Entry\u003e();\n      FdSet fdSet \u003d new FdSet();\n      addNotificationSocket(entries, fdSet);\n      try {\n        while (true) {\n          lock.lock();\n          try {\n            for (int fd : fdSet.getAndClearReadableFds()) {\n              sendCallback(\"getAndClearReadableFds\", entries, fdSet, fd);\n            }\n            if (!(toAdd.isEmpty() \u0026\u0026 toRemove.isEmpty())) {\n              // Handle pending additions (before pending removes).\n              for (Iterator\u003cEntry\u003e iter \u003d toAdd.iterator(); iter.hasNext(); ) {\n                Entry entry \u003d iter.next();\n                DomainSocket sock \u003d entry.getDomainSocket();\n                Entry prevEntry \u003d entries.put(sock.fd, entry);\n                Preconditions.checkState(prevEntry \u003d\u003d null,\n                    this + \": tried to watch a file descriptor that we \" +\n                    \"were already watching: \" + sock);\n                if (LOG.isTraceEnabled()) {\n                  LOG.trace(this + \": adding fd \" + sock.fd);\n                }\n                fdSet.add(sock.fd);\n                iter.remove();\n              }\n              // Handle pending removals\n              while (true) {\n                Map.Entry\u003cInteger, DomainSocket\u003e entry \u003d toRemove.firstEntry();\n                if (entry \u003d\u003d null) break;\n                sendCallback(\"handlePendingRemovals\",\n                    entries, fdSet, entry.getValue().fd);\n              }\n              processedCond.signalAll();\n            }\n            // Check if the thread should terminate.  Doing this check now is\n            // easier than at the beginning of the loop, since we know toAdd and\n            // toRemove are now empty and processedCond has been notified if it\n            // needed to be.\n            if (closed) {\n              LOG.info(toString() + \" thread terminating.\");\n              return;\n            }\n            // Check if someone sent our thread an InterruptedException while we\n            // were waiting in poll().\n            if (Thread.interrupted()) {\n              throw new InterruptedException();\n            }\n          } finally {\n            lock.unlock();\n          }\n          doPoll0(interruptCheckPeriodMs, fdSet);\n        }\n      } catch (InterruptedException e) {\n        LOG.info(toString() + \" terminating on InterruptedException\");\n      } catch (IOException e) {\n        LOG.error(toString() + \" terminating on IOException\", e);\n      } finally {\n        kick(); // allow the handler for notificationSockets[0] to read a byte\n        for (Entry entry : entries.values()) {\n          sendCallback(\"close\", entries, fdSet, entry.getDomainSocket().fd);\n        }\n        entries.clear();\n        fdSet.close();\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/net/unix/DomainSocketWatcher.java",
      "extendedDetails": {}
    },
    "140246bad816ae7bf06eda193cc624e1e62923e0": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-5746.  Add ShortCircuitSharedMemorySegment (cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1563362 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "31/01/14 6:25 PM",
      "commitName": "140246bad816ae7bf06eda193cc624e1e62923e0",
      "commitAuthor": "Colin McCabe",
      "diff": "@@ -0,0 +1,67 @@\n+    public void run() {\n+      LOG.info(this + \": starting with interruptCheckPeriodMs \u003d \" +\n+          interruptCheckPeriodMs);\n+      final TreeMap\u003cInteger, Entry\u003e entries \u003d new TreeMap\u003cInteger, Entry\u003e();\n+      FdSet fdSet \u003d new FdSet();\n+      addNotificationSocket(entries, fdSet);\n+      try {\n+        while (true) {\n+          lock.lock();\n+          try {\n+            for (int fd : fdSet.getAndClearReadableFds()) {\n+              sendCallback(\"getAndClearReadableFds\", entries, fdSet, fd);\n+            }\n+            if (!(toAdd.isEmpty() \u0026\u0026 toRemove.isEmpty())) {\n+              // Handle pending additions (before pending removes).\n+              for (Iterator\u003cEntry\u003e iter \u003d toAdd.iterator(); iter.hasNext(); ) {\n+                Entry entry \u003d iter.next();\n+                DomainSocket sock \u003d entry.getDomainSocket();\n+                Entry prevEntry \u003d entries.put(sock.fd, entry);\n+                Preconditions.checkState(prevEntry \u003d\u003d null,\n+                    this + \": tried to watch a file descriptor that we \" +\n+                    \"were already watching: \" + sock);\n+                if (LOG.isTraceEnabled()) {\n+                  LOG.trace(this + \": adding fd \" + sock.fd);\n+                }\n+                fdSet.add(sock.fd);\n+                iter.remove();\n+              }\n+              // Handle pending removals\n+              while (true) {\n+                Map.Entry\u003cInteger, DomainSocket\u003e entry \u003d toRemove.firstEntry();\n+                if (entry \u003d\u003d null) break;\n+                sendCallback(\"handlePendingRemovals\",\n+                    entries, fdSet, entry.getValue().fd);\n+              }\n+              processedCond.signalAll();\n+            }\n+            // Check if the thread should terminate.  Doing this check now is\n+            // easier than at the beginning of the loop, since we know toAdd and\n+            // toRemove are now empty and processedCond has been notified if it\n+            // needed to be.\n+            if (closed) {\n+              LOG.info(toString() + \" thread terminating.\");\n+              return;\n+            }\n+            // Check if someone sent our thread an InterruptedException while we\n+            // were waiting in poll().\n+            if (Thread.interrupted()) {\n+              throw new InterruptedException();\n+            }\n+          } finally {\n+            lock.unlock();\n+          }\n+          doPoll0(interruptCheckPeriodMs, fdSet);\n+        }\n+      } catch (InterruptedException e) {\n+        LOG.info(toString() + \" terminating on InterruptedException\");\n+      } catch (IOException e) {\n+        LOG.error(toString() + \" terminating on IOException\", e);\n+      } finally {\n+        for (Entry entry : entries.values()) {\n+          sendCallback(\"close\", entries, fdSet, entry.getDomainSocket().fd);\n+        }\n+        entries.clear();\n+        fdSet.close();\n+      }\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    public void run() {\n      LOG.info(this + \": starting with interruptCheckPeriodMs \u003d \" +\n          interruptCheckPeriodMs);\n      final TreeMap\u003cInteger, Entry\u003e entries \u003d new TreeMap\u003cInteger, Entry\u003e();\n      FdSet fdSet \u003d new FdSet();\n      addNotificationSocket(entries, fdSet);\n      try {\n        while (true) {\n          lock.lock();\n          try {\n            for (int fd : fdSet.getAndClearReadableFds()) {\n              sendCallback(\"getAndClearReadableFds\", entries, fdSet, fd);\n            }\n            if (!(toAdd.isEmpty() \u0026\u0026 toRemove.isEmpty())) {\n              // Handle pending additions (before pending removes).\n              for (Iterator\u003cEntry\u003e iter \u003d toAdd.iterator(); iter.hasNext(); ) {\n                Entry entry \u003d iter.next();\n                DomainSocket sock \u003d entry.getDomainSocket();\n                Entry prevEntry \u003d entries.put(sock.fd, entry);\n                Preconditions.checkState(prevEntry \u003d\u003d null,\n                    this + \": tried to watch a file descriptor that we \" +\n                    \"were already watching: \" + sock);\n                if (LOG.isTraceEnabled()) {\n                  LOG.trace(this + \": adding fd \" + sock.fd);\n                }\n                fdSet.add(sock.fd);\n                iter.remove();\n              }\n              // Handle pending removals\n              while (true) {\n                Map.Entry\u003cInteger, DomainSocket\u003e entry \u003d toRemove.firstEntry();\n                if (entry \u003d\u003d null) break;\n                sendCallback(\"handlePendingRemovals\",\n                    entries, fdSet, entry.getValue().fd);\n              }\n              processedCond.signalAll();\n            }\n            // Check if the thread should terminate.  Doing this check now is\n            // easier than at the beginning of the loop, since we know toAdd and\n            // toRemove are now empty and processedCond has been notified if it\n            // needed to be.\n            if (closed) {\n              LOG.info(toString() + \" thread terminating.\");\n              return;\n            }\n            // Check if someone sent our thread an InterruptedException while we\n            // were waiting in poll().\n            if (Thread.interrupted()) {\n              throw new InterruptedException();\n            }\n          } finally {\n            lock.unlock();\n          }\n          doPoll0(interruptCheckPeriodMs, fdSet);\n        }\n      } catch (InterruptedException e) {\n        LOG.info(toString() + \" terminating on InterruptedException\");\n      } catch (IOException e) {\n        LOG.error(toString() + \" terminating on IOException\", e);\n      } finally {\n        for (Entry entry : entries.values()) {\n          sendCallback(\"close\", entries, fdSet, entry.getDomainSocket().fd);\n        }\n        entries.clear();\n        fdSet.close();\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/net/unix/DomainSocketWatcher.java"
    }
  }
}