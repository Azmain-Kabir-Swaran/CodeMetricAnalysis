{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "DataXceiver.java",
  "functionName": "replaceBlock",
  "functionId": "replaceBlock___block-ExtendedBlock(modifiers-final)__storageType-StorageType(modifiers-final)__blockToken-Token__BlockTokenIdentifier__(modifiers-final)__delHint-String(modifiers-final)__proxySource-DatanodeInfo(modifiers-final)__storageId-String(modifiers-final)",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
  "functionStartLine": 1152,
  "functionEndLine": 1293,
  "numCommitsSeen": 275,
  "timeTaken": 14562,
  "changeHistory": [
    "f20dc0d5770d3876954faf0a6e8dcce6539ffc23",
    "a3954ccab148bddc290cb96528e63ff19799bcc9",
    "2f73396b5901fd5fe29f6cd76fc1b3134b854b37",
    "e24a923db50879f7dbe5d2afac0e6757089fb07d",
    "e4a25456202feeee9880d822a8e6f9c19cbcf24a",
    "aede8c10ecad4f2a8802a834e4bd0b8286cebade",
    "d1d4e16690cc85f7f22fbead9cf596260819b561",
    "38c4c14472996562eb3d610649246770c2888c6b",
    "49949a4bb03aa81cbb9115e91ab1c61cc6dc8a62",
    "490bb5ebd6c6d6f9c08fcad167f976687fc3aa42",
    "88d8736ddeff10a03acaa99a9a0ee99dcfabe590",
    "4da8490b512a33a255ed27309860859388d7c168",
    "6ae2a0d048e133b43249c248a75a4d77d9abb80d",
    "36e4cd3be6f7fec8db82d3d1bcb258af470ece2e",
    "67ed59348d638d56e6752ba2c71fdcd69567546d",
    "085b1e293ff53f7a86aa21406cfd4bfa0f3bf33b",
    "058af60c56207907f2bedf76df4284e86d923e0c",
    "2d4f3e567e4bb8068c028de12df118a4f3fa6343",
    "86cad007d7d6366b293bb9a073814889081c8662",
    "a317bd7b02c37bd57743bfad59593ec12f53f4ed",
    "195961a7c1da86421761162836766b1de07930fd",
    "6554994fab2d8a2a139fb71ed54be144f4057e08",
    "471b1368e2a81b4d9850f0f4d98d31df1451354c",
    "25b0e8471ed744578b2d8e3f0debe5477b268e54",
    "3b54223c0f32d42a84436c670d80b791a8e9696d",
    "1fbb04e367d7c330e6052207f9f11911f4f5f368",
    "97acde2d33967f7f870f7dfe96c6b558e6fe324b",
    "907fb15ee8c150e5ecc0560b7374441c57a84122",
    "01f37e42f050207b7659bf74e2484cf8bdae2d89",
    "c1314eb2a382bd9ce045a2fcc4a9e5c1fc368a24",
    "c9db06f2e4d1c1f71f021d5070323f9fc194cdd7",
    "3cd17b614e9436d06cd9b4ccc5f9cf59fbe1cf21",
    "837e17b2eac1471d93e2eff395272063b265fee7",
    "239b2742d0e80d13c970fd062af4930e672fe903",
    "cea7bbc630deede93dbe6a1bbda56ad49de4f3de",
    "f98d8eb291be364102b5c3011ce72e8f43eab389",
    "9b4a7900c7dfc0590316eedaa97144f938885651",
    "be7dd8333a7e56e732171db0781786987de03195",
    "905a127850d5e0cba85c2e075f989fa0f5cf129a",
    "1c940637b14eee777a65d153d0d712a1aea3866c",
    "c46876982ed90d0819a94b518f6135b82334d10d",
    "8ae98a9d1ca4725e28783370517cb3a3ecda7324",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "d86f3183d93714ba078416af4f609d26376eadb0",
    "ef223e8e8e1e18733fc18cd84e34dd0bb0f9a710",
    "2f48fae72aa52e6ec42264cad24fab36b6a426c2",
    "3f190b3e1acc5ea9e9a03e85a4df0e3f0ab73b9f",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc"
  ],
  "changeHistoryShort": {
    "f20dc0d5770d3876954faf0a6e8dcce6539ffc23": "Ybodychange",
    "a3954ccab148bddc290cb96528e63ff19799bcc9": "Ymultichange(Yparameterchange,Ybodychange)",
    "2f73396b5901fd5fe29f6cd76fc1b3134b854b37": "Ybodychange",
    "e24a923db50879f7dbe5d2afac0e6757089fb07d": "Ybodychange",
    "e4a25456202feeee9880d822a8e6f9c19cbcf24a": "Ybodychange",
    "aede8c10ecad4f2a8802a834e4bd0b8286cebade": "Ybodychange",
    "d1d4e16690cc85f7f22fbead9cf596260819b561": "Ybodychange",
    "38c4c14472996562eb3d610649246770c2888c6b": "Ybodychange",
    "49949a4bb03aa81cbb9115e91ab1c61cc6dc8a62": "Ybodychange",
    "490bb5ebd6c6d6f9c08fcad167f976687fc3aa42": "Ybodychange",
    "88d8736ddeff10a03acaa99a9a0ee99dcfabe590": "Ybodychange",
    "4da8490b512a33a255ed27309860859388d7c168": "Ybodychange",
    "6ae2a0d048e133b43249c248a75a4d77d9abb80d": "Ybodychange",
    "36e4cd3be6f7fec8db82d3d1bcb258af470ece2e": "Ybodychange",
    "67ed59348d638d56e6752ba2c71fdcd69567546d": "Ybodychange",
    "085b1e293ff53f7a86aa21406cfd4bfa0f3bf33b": "Ybodychange",
    "058af60c56207907f2bedf76df4284e86d923e0c": "Ybodychange",
    "2d4f3e567e4bb8068c028de12df118a4f3fa6343": "Ybodychange",
    "86cad007d7d6366b293bb9a073814889081c8662": "Ybodychange",
    "a317bd7b02c37bd57743bfad59593ec12f53f4ed": "Ybodychange",
    "195961a7c1da86421761162836766b1de07930fd": "Ybodychange",
    "6554994fab2d8a2a139fb71ed54be144f4057e08": "Ybodychange",
    "471b1368e2a81b4d9850f0f4d98d31df1451354c": "Ybodychange",
    "25b0e8471ed744578b2d8e3f0debe5477b268e54": "Ymultichange(Yparameterchange,Ybodychange)",
    "3b54223c0f32d42a84436c670d80b791a8e9696d": "Ybodychange",
    "1fbb04e367d7c330e6052207f9f11911f4f5f368": "Ybodychange",
    "97acde2d33967f7f870f7dfe96c6b558e6fe324b": "Ybodychange",
    "907fb15ee8c150e5ecc0560b7374441c57a84122": "Ybodychange",
    "01f37e42f050207b7659bf74e2484cf8bdae2d89": "Ybodychange",
    "c1314eb2a382bd9ce045a2fcc4a9e5c1fc368a24": "Ybodychange",
    "c9db06f2e4d1c1f71f021d5070323f9fc194cdd7": "Ybodychange",
    "3cd17b614e9436d06cd9b4ccc5f9cf59fbe1cf21": "Ybodychange",
    "837e17b2eac1471d93e2eff395272063b265fee7": "Ybodychange",
    "239b2742d0e80d13c970fd062af4930e672fe903": "Ybodychange",
    "cea7bbc630deede93dbe6a1bbda56ad49de4f3de": "Ybodychange",
    "f98d8eb291be364102b5c3011ce72e8f43eab389": "Ybodychange",
    "9b4a7900c7dfc0590316eedaa97144f938885651": "Ybodychange",
    "be7dd8333a7e56e732171db0781786987de03195": "Ybodychange",
    "905a127850d5e0cba85c2e075f989fa0f5cf129a": "Ybodychange",
    "1c940637b14eee777a65d153d0d712a1aea3866c": "Ybodychange",
    "c46876982ed90d0819a94b518f6135b82334d10d": "Ybodychange",
    "8ae98a9d1ca4725e28783370517cb3a3ecda7324": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "d86f3183d93714ba078416af4f609d26376eadb0": "Yfilerename",
    "ef223e8e8e1e18733fc18cd84e34dd0bb0f9a710": "Ybodychange",
    "2f48fae72aa52e6ec42264cad24fab36b6a426c2": "Ymultichange(Yrename,Yparameterchange,Ymodifierchange,Ybodychange,Yparametermetachange)",
    "3f190b3e1acc5ea9e9a03e85a4df0e3f0ab73b9f": "Ybodychange",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yintroduced"
  },
  "changeHistoryDetails": {
    "f20dc0d5770d3876954faf0a6e8dcce6539ffc23": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10571. Use Log.*(Object, Throwable) overload to log exceptions.\nContributed by Andras Bokor.\n",
      "commitDate": "14/02/18 8:20 AM",
      "commitName": "f20dc0d5770d3876954faf0a6e8dcce6539ffc23",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "01/11/17 1:41 AM",
      "commitNameOld": "56b88b06705441f6f171eec7fb2fa77946ca204b",
      "commitAuthorOld": "Weiwei Yang",
      "daysBetweenCommits": 105.32,
      "commitsBetweenForRepo": 696,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,143 +1,142 @@\n   public void replaceBlock(final ExtendedBlock block,\n       final StorageType storageType, \n       final Token\u003cBlockTokenIdentifier\u003e blockToken,\n       final String delHint,\n       final DatanodeInfo proxySource,\n       final String storageId) throws IOException {\n     updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n     DataOutputStream replyOut \u003d new DataOutputStream(getOutputStream());\n     checkAccess(replyOut, true, block, blockToken,\n         Op.REPLACE_BLOCK, BlockTokenIdentifier.AccessMode.REPLACE,\n         new StorageType[]{storageType},\n         new String[]{storageId});\n \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n       String msg \u003d \"Not able to receive block \" + block.getBlockId() +\n           \" from \" + peer.getRemoteAddressString() + \" because threads \" +\n           \"quota is exceeded.\";\n       LOG.warn(msg);\n       sendResponse(ERROR, msg);\n       return;\n     }\n \n     Socket proxySock \u003d null;\n     DataOutputStream proxyOut \u003d null;\n     Status opStatus \u003d SUCCESS;\n     String errMsg \u003d null;\n     DataInputStream proxyReply \u003d null;\n     boolean IoeDuringCopyBlockOperation \u003d false;\n     try {\n       // Move the block to different storage in the same datanode\n       if (proxySource.equals(datanode.getDatanodeId())) {\n         ReplicaInfo oldReplica \u003d datanode.data.moveBlockAcrossStorage(block,\n             storageType, storageId);\n         if (oldReplica !\u003d null) {\n-          LOG.info(\"Moved \" + block + \" from StorageType \"\n-              + oldReplica.getVolume().getStorageType() + \" to \" + storageType);\n+          LOG.info(\"Moved {} from StorageType {} to {}\",\n+              block, oldReplica.getVolume().getStorageType(), storageType);\n         }\n       } else {\n         block.setNumBytes(dataXceiverServer.estimateBlockSize);\n         // get the output stream to the proxy\n         final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n-        if (LOG.isDebugEnabled()) {\n-          LOG.debug(\"Connecting to datanode \" + dnAddr);\n-        }\n+        LOG.debug(\"Connecting to datanode {}\", dnAddr);\n         InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n         proxySock \u003d datanode.newSocket();\n         NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n         proxySock.setTcpNoDelay(dnConf.getDataTransferServerTcpNoDelay());\n         proxySock.setSoTimeout(dnConf.socketTimeout);\n         proxySock.setKeepAlive(true);\n \n         OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n             dnConf.socketWriteTimeout);\n         InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n         DataEncryptionKeyFactory keyFactory \u003d\n             datanode.getDataEncryptionKeyFactoryForBlock(block);\n         IOStreamPair saslStreams \u003d datanode.saslClient.socketSend(proxySock,\n             unbufProxyOut, unbufProxyIn, keyFactory, blockToken, proxySource);\n         unbufProxyOut \u003d saslStreams.out;\n         unbufProxyIn \u003d saslStreams.in;\n         \n         proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut,\n             smallBufferSize));\n         proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n             ioFileBufferSize));\n         \n         /* send request to the proxy */\n         IoeDuringCopyBlockOperation \u003d true;\n         new Sender(proxyOut).copyBlock(block, blockToken);\n         IoeDuringCopyBlockOperation \u003d false;\n         \n         // receive the response from the proxy\n         \n         BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n             PBHelperClient.vintPrefixed(proxyReply));\n \n         String logInfo \u003d \"copy block \" + block + \" from \"\n             + proxySock.getRemoteSocketAddress();\n         DataTransferProtoUtil.checkBlockOpStatus(copyResponse, logInfo, true);\n \n         // get checksum info about the block we\u0027re copying\n         ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n         DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n             checksumInfo.getChecksum());\n         // open a block receiver and check if the block does not exist\n         setCurrentBlockReceiver(getBlockReceiver(block, storageType,\n             proxyReply, proxySock.getRemoteSocketAddress().toString(),\n             proxySock.getLocalSocketAddress().toString(),\n             null, 0, 0, 0, \"\", null, datanode, remoteChecksum,\n             CachingStrategy.newDropBehind(), false, false, storageId));\n         \n         // receive a block\n         blockReceiver.receiveBlock(null, null, replyOut, null, \n             dataXceiverServer.balanceThrottler, null, true);\n         \n         // notify name node\n         final Replica r \u003d blockReceiver.getReplica();\n         datanode.notifyNamenodeReceivedBlock(\n             block, delHint, r.getStorageUuid(), r.isOnTransientStorage());\n         \n-        LOG.info(\"Moved \" + block + \" from \" + peer.getRemoteAddressString()\n-            + \", delHint\u003d\" + delHint);\n+        LOG.info(\"Moved {} from {}, delHint\u003d{}\",\n+            block, peer.getRemoteAddressString(), delHint);\n       }\n     } catch (IOException ioe) {\n       opStatus \u003d ERROR;\n       if (ioe instanceof BlockPinningException) {\n         opStatus \u003d Status.ERROR_BLOCK_PINNED;\n       }\n       errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n       LOG.info(errMsg);\n       if (!IoeDuringCopyBlockOperation) {\n         // Don\u0027t double count IO errors\n         incrDatanodeNetworkErrors();\n       }\n       throw ioe;\n     } finally {\n       // receive the last byte that indicates the proxy released its thread resource\n       if (opStatus \u003d\u003d SUCCESS \u0026\u0026 proxyReply !\u003d null) {\n         try {\n           proxyReply.readChar();\n         } catch (IOException ignored) {\n         }\n       }\n       \n       // now release the thread resource\n       dataXceiverServer.balanceThrottler.release();\n       \n       // send response back\n       try {\n         sendResponse(opStatus, errMsg);\n       } catch (IOException ioe) {\n-        LOG.warn(\"Error writing reply back to \" + peer.getRemoteAddressString());\n+        LOG.warn(\"Error writing reply back to {}\",\n+            peer.getRemoteAddressString());\n         incrDatanodeNetworkErrors();\n       }\n       IOUtils.closeStream(proxyOut);\n       IOUtils.closeStream(blockReceiver);\n       IOUtils.closeStream(proxyReply);\n       IOUtils.closeStream(replyOut);\n     }\n \n     //update metrics\n     datanode.metrics.addReplaceBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void replaceBlock(final ExtendedBlock block,\n      final StorageType storageType, \n      final Token\u003cBlockTokenIdentifier\u003e blockToken,\n      final String delHint,\n      final DatanodeInfo proxySource,\n      final String storageId) throws IOException {\n    updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n    DataOutputStream replyOut \u003d new DataOutputStream(getOutputStream());\n    checkAccess(replyOut, true, block, blockToken,\n        Op.REPLACE_BLOCK, BlockTokenIdentifier.AccessMode.REPLACE,\n        new StorageType[]{storageType},\n        new String[]{storageId});\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      String msg \u003d \"Not able to receive block \" + block.getBlockId() +\n          \" from \" + peer.getRemoteAddressString() + \" because threads \" +\n          \"quota is exceeded.\";\n      LOG.warn(msg);\n      sendResponse(ERROR, msg);\n      return;\n    }\n\n    Socket proxySock \u003d null;\n    DataOutputStream proxyOut \u003d null;\n    Status opStatus \u003d SUCCESS;\n    String errMsg \u003d null;\n    DataInputStream proxyReply \u003d null;\n    boolean IoeDuringCopyBlockOperation \u003d false;\n    try {\n      // Move the block to different storage in the same datanode\n      if (proxySource.equals(datanode.getDatanodeId())) {\n        ReplicaInfo oldReplica \u003d datanode.data.moveBlockAcrossStorage(block,\n            storageType, storageId);\n        if (oldReplica !\u003d null) {\n          LOG.info(\"Moved {} from StorageType {} to {}\",\n              block, oldReplica.getVolume().getStorageType(), storageType);\n        }\n      } else {\n        block.setNumBytes(dataXceiverServer.estimateBlockSize);\n        // get the output stream to the proxy\n        final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n        LOG.debug(\"Connecting to datanode {}\", dnAddr);\n        InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n        proxySock \u003d datanode.newSocket();\n        NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n        proxySock.setTcpNoDelay(dnConf.getDataTransferServerTcpNoDelay());\n        proxySock.setSoTimeout(dnConf.socketTimeout);\n        proxySock.setKeepAlive(true);\n\n        OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n            dnConf.socketWriteTimeout);\n        InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n        DataEncryptionKeyFactory keyFactory \u003d\n            datanode.getDataEncryptionKeyFactoryForBlock(block);\n        IOStreamPair saslStreams \u003d datanode.saslClient.socketSend(proxySock,\n            unbufProxyOut, unbufProxyIn, keyFactory, blockToken, proxySource);\n        unbufProxyOut \u003d saslStreams.out;\n        unbufProxyIn \u003d saslStreams.in;\n        \n        proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut,\n            smallBufferSize));\n        proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n            ioFileBufferSize));\n        \n        /* send request to the proxy */\n        IoeDuringCopyBlockOperation \u003d true;\n        new Sender(proxyOut).copyBlock(block, blockToken);\n        IoeDuringCopyBlockOperation \u003d false;\n        \n        // receive the response from the proxy\n        \n        BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n            PBHelperClient.vintPrefixed(proxyReply));\n\n        String logInfo \u003d \"copy block \" + block + \" from \"\n            + proxySock.getRemoteSocketAddress();\n        DataTransferProtoUtil.checkBlockOpStatus(copyResponse, logInfo, true);\n\n        // get checksum info about the block we\u0027re copying\n        ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n        DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n            checksumInfo.getChecksum());\n        // open a block receiver and check if the block does not exist\n        setCurrentBlockReceiver(getBlockReceiver(block, storageType,\n            proxyReply, proxySock.getRemoteSocketAddress().toString(),\n            proxySock.getLocalSocketAddress().toString(),\n            null, 0, 0, 0, \"\", null, datanode, remoteChecksum,\n            CachingStrategy.newDropBehind(), false, false, storageId));\n        \n        // receive a block\n        blockReceiver.receiveBlock(null, null, replyOut, null, \n            dataXceiverServer.balanceThrottler, null, true);\n        \n        // notify name node\n        final Replica r \u003d blockReceiver.getReplica();\n        datanode.notifyNamenodeReceivedBlock(\n            block, delHint, r.getStorageUuid(), r.isOnTransientStorage());\n        \n        LOG.info(\"Moved {} from {}, delHint\u003d{}\",\n            block, peer.getRemoteAddressString(), delHint);\n      }\n    } catch (IOException ioe) {\n      opStatus \u003d ERROR;\n      if (ioe instanceof BlockPinningException) {\n        opStatus \u003d Status.ERROR_BLOCK_PINNED;\n      }\n      errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n      LOG.info(errMsg);\n      if (!IoeDuringCopyBlockOperation) {\n        // Don\u0027t double count IO errors\n        incrDatanodeNetworkErrors();\n      }\n      throw ioe;\n    } finally {\n      // receive the last byte that indicates the proxy released its thread resource\n      if (opStatus \u003d\u003d SUCCESS \u0026\u0026 proxyReply !\u003d null) {\n        try {\n          proxyReply.readChar();\n        } catch (IOException ignored) {\n        }\n      }\n      \n      // now release the thread resource\n      dataXceiverServer.balanceThrottler.release();\n      \n      // send response back\n      try {\n        sendResponse(opStatus, errMsg);\n      } catch (IOException ioe) {\n        LOG.warn(\"Error writing reply back to {}\",\n            peer.getRemoteAddressString());\n        incrDatanodeNetworkErrors();\n      }\n      IOUtils.closeStream(proxyOut);\n      IOUtils.closeStream(blockReceiver);\n      IOUtils.closeStream(proxyReply);\n      IOUtils.closeStream(replyOut);\n    }\n\n    //update metrics\n    datanode.metrics.addReplaceBlockOp(elapsed());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "a3954ccab148bddc290cb96528e63ff19799bcc9": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-9807. Add an optional StorageID to writes. Contributed by Ewan Higgs\n",
      "commitDate": "05/05/17 12:01 PM",
      "commitName": "a3954ccab148bddc290cb96528e63ff19799bcc9",
      "commitAuthor": "Chris Douglas",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-9807. Add an optional StorageID to writes. Contributed by Ewan Higgs\n",
          "commitDate": "05/05/17 12:01 PM",
          "commitName": "a3954ccab148bddc290cb96528e63ff19799bcc9",
          "commitAuthor": "Chris Douglas",
          "commitDateOld": "25/04/17 11:57 PM",
          "commitNameOld": "2f73396b5901fd5fe29f6cd76fc1b3134b854b37",
          "commitAuthorOld": "Chris Douglas",
          "daysBetweenCommits": 9.5,
          "commitsBetweenForRepo": 64,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,141 +1,143 @@\n   public void replaceBlock(final ExtendedBlock block,\n       final StorageType storageType, \n       final Token\u003cBlockTokenIdentifier\u003e blockToken,\n       final String delHint,\n-      final DatanodeInfo proxySource) throws IOException {\n+      final DatanodeInfo proxySource,\n+      final String storageId) throws IOException {\n     updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n     DataOutputStream replyOut \u003d new DataOutputStream(getOutputStream());\n     checkAccess(replyOut, true, block, blockToken,\n         Op.REPLACE_BLOCK, BlockTokenIdentifier.AccessMode.REPLACE,\n-        new StorageType[]{ storageType });\n+        new StorageType[]{storageType},\n+        new String[]{storageId});\n \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n       String msg \u003d \"Not able to receive block \" + block.getBlockId() +\n           \" from \" + peer.getRemoteAddressString() + \" because threads \" +\n           \"quota is exceeded.\";\n       LOG.warn(msg);\n       sendResponse(ERROR, msg);\n       return;\n     }\n \n     Socket proxySock \u003d null;\n     DataOutputStream proxyOut \u003d null;\n     Status opStatus \u003d SUCCESS;\n     String errMsg \u003d null;\n     DataInputStream proxyReply \u003d null;\n     boolean IoeDuringCopyBlockOperation \u003d false;\n     try {\n       // Move the block to different storage in the same datanode\n       if (proxySource.equals(datanode.getDatanodeId())) {\n         ReplicaInfo oldReplica \u003d datanode.data.moveBlockAcrossStorage(block,\n-            storageType);\n+            storageType, storageId);\n         if (oldReplica !\u003d null) {\n           LOG.info(\"Moved \" + block + \" from StorageType \"\n               + oldReplica.getVolume().getStorageType() + \" to \" + storageType);\n         }\n       } else {\n         block.setNumBytes(dataXceiverServer.estimateBlockSize);\n         // get the output stream to the proxy\n         final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Connecting to datanode \" + dnAddr);\n         }\n         InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n         proxySock \u003d datanode.newSocket();\n         NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n         proxySock.setTcpNoDelay(dnConf.getDataTransferServerTcpNoDelay());\n         proxySock.setSoTimeout(dnConf.socketTimeout);\n         proxySock.setKeepAlive(true);\n \n         OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n             dnConf.socketWriteTimeout);\n         InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n         DataEncryptionKeyFactory keyFactory \u003d\n             datanode.getDataEncryptionKeyFactoryForBlock(block);\n         IOStreamPair saslStreams \u003d datanode.saslClient.socketSend(proxySock,\n             unbufProxyOut, unbufProxyIn, keyFactory, blockToken, proxySource);\n         unbufProxyOut \u003d saslStreams.out;\n         unbufProxyIn \u003d saslStreams.in;\n         \n         proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut,\n             smallBufferSize));\n         proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n             ioFileBufferSize));\n         \n         /* send request to the proxy */\n         IoeDuringCopyBlockOperation \u003d true;\n         new Sender(proxyOut).copyBlock(block, blockToken);\n         IoeDuringCopyBlockOperation \u003d false;\n         \n         // receive the response from the proxy\n         \n         BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n             PBHelperClient.vintPrefixed(proxyReply));\n \n         String logInfo \u003d \"copy block \" + block + \" from \"\n             + proxySock.getRemoteSocketAddress();\n         DataTransferProtoUtil.checkBlockOpStatus(copyResponse, logInfo, true);\n \n         // get checksum info about the block we\u0027re copying\n         ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n         DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n             checksumInfo.getChecksum());\n         // open a block receiver and check if the block does not exist\n         setCurrentBlockReceiver(getBlockReceiver(block, storageType,\n             proxyReply, proxySock.getRemoteSocketAddress().toString(),\n             proxySock.getLocalSocketAddress().toString(),\n             null, 0, 0, 0, \"\", null, datanode, remoteChecksum,\n-            CachingStrategy.newDropBehind(), false, false));\n+            CachingStrategy.newDropBehind(), false, false, storageId));\n         \n         // receive a block\n         blockReceiver.receiveBlock(null, null, replyOut, null, \n             dataXceiverServer.balanceThrottler, null, true);\n         \n         // notify name node\n         final Replica r \u003d blockReceiver.getReplica();\n         datanode.notifyNamenodeReceivedBlock(\n             block, delHint, r.getStorageUuid(), r.isOnTransientStorage());\n         \n         LOG.info(\"Moved \" + block + \" from \" + peer.getRemoteAddressString()\n             + \", delHint\u003d\" + delHint);\n       }\n     } catch (IOException ioe) {\n       opStatus \u003d ERROR;\n       if (ioe instanceof BlockPinningException) {\n         opStatus \u003d Status.ERROR_BLOCK_PINNED;\n       }\n       errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n       LOG.info(errMsg);\n       if (!IoeDuringCopyBlockOperation) {\n         // Don\u0027t double count IO errors\n         incrDatanodeNetworkErrors();\n       }\n       throw ioe;\n     } finally {\n       // receive the last byte that indicates the proxy released its thread resource\n       if (opStatus \u003d\u003d SUCCESS \u0026\u0026 proxyReply !\u003d null) {\n         try {\n           proxyReply.readChar();\n         } catch (IOException ignored) {\n         }\n       }\n       \n       // now release the thread resource\n       dataXceiverServer.balanceThrottler.release();\n       \n       // send response back\n       try {\n         sendResponse(opStatus, errMsg);\n       } catch (IOException ioe) {\n         LOG.warn(\"Error writing reply back to \" + peer.getRemoteAddressString());\n         incrDatanodeNetworkErrors();\n       }\n       IOUtils.closeStream(proxyOut);\n       IOUtils.closeStream(blockReceiver);\n       IOUtils.closeStream(proxyReply);\n       IOUtils.closeStream(replyOut);\n     }\n \n     //update metrics\n     datanode.metrics.addReplaceBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void replaceBlock(final ExtendedBlock block,\n      final StorageType storageType, \n      final Token\u003cBlockTokenIdentifier\u003e blockToken,\n      final String delHint,\n      final DatanodeInfo proxySource,\n      final String storageId) throws IOException {\n    updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n    DataOutputStream replyOut \u003d new DataOutputStream(getOutputStream());\n    checkAccess(replyOut, true, block, blockToken,\n        Op.REPLACE_BLOCK, BlockTokenIdentifier.AccessMode.REPLACE,\n        new StorageType[]{storageType},\n        new String[]{storageId});\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      String msg \u003d \"Not able to receive block \" + block.getBlockId() +\n          \" from \" + peer.getRemoteAddressString() + \" because threads \" +\n          \"quota is exceeded.\";\n      LOG.warn(msg);\n      sendResponse(ERROR, msg);\n      return;\n    }\n\n    Socket proxySock \u003d null;\n    DataOutputStream proxyOut \u003d null;\n    Status opStatus \u003d SUCCESS;\n    String errMsg \u003d null;\n    DataInputStream proxyReply \u003d null;\n    boolean IoeDuringCopyBlockOperation \u003d false;\n    try {\n      // Move the block to different storage in the same datanode\n      if (proxySource.equals(datanode.getDatanodeId())) {\n        ReplicaInfo oldReplica \u003d datanode.data.moveBlockAcrossStorage(block,\n            storageType, storageId);\n        if (oldReplica !\u003d null) {\n          LOG.info(\"Moved \" + block + \" from StorageType \"\n              + oldReplica.getVolume().getStorageType() + \" to \" + storageType);\n        }\n      } else {\n        block.setNumBytes(dataXceiverServer.estimateBlockSize);\n        // get the output stream to the proxy\n        final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Connecting to datanode \" + dnAddr);\n        }\n        InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n        proxySock \u003d datanode.newSocket();\n        NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n        proxySock.setTcpNoDelay(dnConf.getDataTransferServerTcpNoDelay());\n        proxySock.setSoTimeout(dnConf.socketTimeout);\n        proxySock.setKeepAlive(true);\n\n        OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n            dnConf.socketWriteTimeout);\n        InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n        DataEncryptionKeyFactory keyFactory \u003d\n            datanode.getDataEncryptionKeyFactoryForBlock(block);\n        IOStreamPair saslStreams \u003d datanode.saslClient.socketSend(proxySock,\n            unbufProxyOut, unbufProxyIn, keyFactory, blockToken, proxySource);\n        unbufProxyOut \u003d saslStreams.out;\n        unbufProxyIn \u003d saslStreams.in;\n        \n        proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut,\n            smallBufferSize));\n        proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n            ioFileBufferSize));\n        \n        /* send request to the proxy */\n        IoeDuringCopyBlockOperation \u003d true;\n        new Sender(proxyOut).copyBlock(block, blockToken);\n        IoeDuringCopyBlockOperation \u003d false;\n        \n        // receive the response from the proxy\n        \n        BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n            PBHelperClient.vintPrefixed(proxyReply));\n\n        String logInfo \u003d \"copy block \" + block + \" from \"\n            + proxySock.getRemoteSocketAddress();\n        DataTransferProtoUtil.checkBlockOpStatus(copyResponse, logInfo, true);\n\n        // get checksum info about the block we\u0027re copying\n        ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n        DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n            checksumInfo.getChecksum());\n        // open a block receiver and check if the block does not exist\n        setCurrentBlockReceiver(getBlockReceiver(block, storageType,\n            proxyReply, proxySock.getRemoteSocketAddress().toString(),\n            proxySock.getLocalSocketAddress().toString(),\n            null, 0, 0, 0, \"\", null, datanode, remoteChecksum,\n            CachingStrategy.newDropBehind(), false, false, storageId));\n        \n        // receive a block\n        blockReceiver.receiveBlock(null, null, replyOut, null, \n            dataXceiverServer.balanceThrottler, null, true);\n        \n        // notify name node\n        final Replica r \u003d blockReceiver.getReplica();\n        datanode.notifyNamenodeReceivedBlock(\n            block, delHint, r.getStorageUuid(), r.isOnTransientStorage());\n        \n        LOG.info(\"Moved \" + block + \" from \" + peer.getRemoteAddressString()\n            + \", delHint\u003d\" + delHint);\n      }\n    } catch (IOException ioe) {\n      opStatus \u003d ERROR;\n      if (ioe instanceof BlockPinningException) {\n        opStatus \u003d Status.ERROR_BLOCK_PINNED;\n      }\n      errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n      LOG.info(errMsg);\n      if (!IoeDuringCopyBlockOperation) {\n        // Don\u0027t double count IO errors\n        incrDatanodeNetworkErrors();\n      }\n      throw ioe;\n    } finally {\n      // receive the last byte that indicates the proxy released its thread resource\n      if (opStatus \u003d\u003d SUCCESS \u0026\u0026 proxyReply !\u003d null) {\n        try {\n          proxyReply.readChar();\n        } catch (IOException ignored) {\n        }\n      }\n      \n      // now release the thread resource\n      dataXceiverServer.balanceThrottler.release();\n      \n      // send response back\n      try {\n        sendResponse(opStatus, errMsg);\n      } catch (IOException ioe) {\n        LOG.warn(\"Error writing reply back to \" + peer.getRemoteAddressString());\n        incrDatanodeNetworkErrors();\n      }\n      IOUtils.closeStream(proxyOut);\n      IOUtils.closeStream(blockReceiver);\n      IOUtils.closeStream(proxyReply);\n      IOUtils.closeStream(replyOut);\n    }\n\n    //update metrics\n    datanode.metrics.addReplaceBlockOp(elapsed());\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
          "extendedDetails": {
            "oldValue": "[block-ExtendedBlock(modifiers-final), storageType-StorageType(modifiers-final), blockToken-Token\u003cBlockTokenIdentifier\u003e(modifiers-final), delHint-String(modifiers-final), proxySource-DatanodeInfo(modifiers-final)]",
            "newValue": "[block-ExtendedBlock(modifiers-final), storageType-StorageType(modifiers-final), blockToken-Token\u003cBlockTokenIdentifier\u003e(modifiers-final), delHint-String(modifiers-final), proxySource-DatanodeInfo(modifiers-final), storageId-String(modifiers-final)]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-9807. Add an optional StorageID to writes. Contributed by Ewan Higgs\n",
          "commitDate": "05/05/17 12:01 PM",
          "commitName": "a3954ccab148bddc290cb96528e63ff19799bcc9",
          "commitAuthor": "Chris Douglas",
          "commitDateOld": "25/04/17 11:57 PM",
          "commitNameOld": "2f73396b5901fd5fe29f6cd76fc1b3134b854b37",
          "commitAuthorOld": "Chris Douglas",
          "daysBetweenCommits": 9.5,
          "commitsBetweenForRepo": 64,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,141 +1,143 @@\n   public void replaceBlock(final ExtendedBlock block,\n       final StorageType storageType, \n       final Token\u003cBlockTokenIdentifier\u003e blockToken,\n       final String delHint,\n-      final DatanodeInfo proxySource) throws IOException {\n+      final DatanodeInfo proxySource,\n+      final String storageId) throws IOException {\n     updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n     DataOutputStream replyOut \u003d new DataOutputStream(getOutputStream());\n     checkAccess(replyOut, true, block, blockToken,\n         Op.REPLACE_BLOCK, BlockTokenIdentifier.AccessMode.REPLACE,\n-        new StorageType[]{ storageType });\n+        new StorageType[]{storageType},\n+        new String[]{storageId});\n \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n       String msg \u003d \"Not able to receive block \" + block.getBlockId() +\n           \" from \" + peer.getRemoteAddressString() + \" because threads \" +\n           \"quota is exceeded.\";\n       LOG.warn(msg);\n       sendResponse(ERROR, msg);\n       return;\n     }\n \n     Socket proxySock \u003d null;\n     DataOutputStream proxyOut \u003d null;\n     Status opStatus \u003d SUCCESS;\n     String errMsg \u003d null;\n     DataInputStream proxyReply \u003d null;\n     boolean IoeDuringCopyBlockOperation \u003d false;\n     try {\n       // Move the block to different storage in the same datanode\n       if (proxySource.equals(datanode.getDatanodeId())) {\n         ReplicaInfo oldReplica \u003d datanode.data.moveBlockAcrossStorage(block,\n-            storageType);\n+            storageType, storageId);\n         if (oldReplica !\u003d null) {\n           LOG.info(\"Moved \" + block + \" from StorageType \"\n               + oldReplica.getVolume().getStorageType() + \" to \" + storageType);\n         }\n       } else {\n         block.setNumBytes(dataXceiverServer.estimateBlockSize);\n         // get the output stream to the proxy\n         final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Connecting to datanode \" + dnAddr);\n         }\n         InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n         proxySock \u003d datanode.newSocket();\n         NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n         proxySock.setTcpNoDelay(dnConf.getDataTransferServerTcpNoDelay());\n         proxySock.setSoTimeout(dnConf.socketTimeout);\n         proxySock.setKeepAlive(true);\n \n         OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n             dnConf.socketWriteTimeout);\n         InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n         DataEncryptionKeyFactory keyFactory \u003d\n             datanode.getDataEncryptionKeyFactoryForBlock(block);\n         IOStreamPair saslStreams \u003d datanode.saslClient.socketSend(proxySock,\n             unbufProxyOut, unbufProxyIn, keyFactory, blockToken, proxySource);\n         unbufProxyOut \u003d saslStreams.out;\n         unbufProxyIn \u003d saslStreams.in;\n         \n         proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut,\n             smallBufferSize));\n         proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n             ioFileBufferSize));\n         \n         /* send request to the proxy */\n         IoeDuringCopyBlockOperation \u003d true;\n         new Sender(proxyOut).copyBlock(block, blockToken);\n         IoeDuringCopyBlockOperation \u003d false;\n         \n         // receive the response from the proxy\n         \n         BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n             PBHelperClient.vintPrefixed(proxyReply));\n \n         String logInfo \u003d \"copy block \" + block + \" from \"\n             + proxySock.getRemoteSocketAddress();\n         DataTransferProtoUtil.checkBlockOpStatus(copyResponse, logInfo, true);\n \n         // get checksum info about the block we\u0027re copying\n         ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n         DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n             checksumInfo.getChecksum());\n         // open a block receiver and check if the block does not exist\n         setCurrentBlockReceiver(getBlockReceiver(block, storageType,\n             proxyReply, proxySock.getRemoteSocketAddress().toString(),\n             proxySock.getLocalSocketAddress().toString(),\n             null, 0, 0, 0, \"\", null, datanode, remoteChecksum,\n-            CachingStrategy.newDropBehind(), false, false));\n+            CachingStrategy.newDropBehind(), false, false, storageId));\n         \n         // receive a block\n         blockReceiver.receiveBlock(null, null, replyOut, null, \n             dataXceiverServer.balanceThrottler, null, true);\n         \n         // notify name node\n         final Replica r \u003d blockReceiver.getReplica();\n         datanode.notifyNamenodeReceivedBlock(\n             block, delHint, r.getStorageUuid(), r.isOnTransientStorage());\n         \n         LOG.info(\"Moved \" + block + \" from \" + peer.getRemoteAddressString()\n             + \", delHint\u003d\" + delHint);\n       }\n     } catch (IOException ioe) {\n       opStatus \u003d ERROR;\n       if (ioe instanceof BlockPinningException) {\n         opStatus \u003d Status.ERROR_BLOCK_PINNED;\n       }\n       errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n       LOG.info(errMsg);\n       if (!IoeDuringCopyBlockOperation) {\n         // Don\u0027t double count IO errors\n         incrDatanodeNetworkErrors();\n       }\n       throw ioe;\n     } finally {\n       // receive the last byte that indicates the proxy released its thread resource\n       if (opStatus \u003d\u003d SUCCESS \u0026\u0026 proxyReply !\u003d null) {\n         try {\n           proxyReply.readChar();\n         } catch (IOException ignored) {\n         }\n       }\n       \n       // now release the thread resource\n       dataXceiverServer.balanceThrottler.release();\n       \n       // send response back\n       try {\n         sendResponse(opStatus, errMsg);\n       } catch (IOException ioe) {\n         LOG.warn(\"Error writing reply back to \" + peer.getRemoteAddressString());\n         incrDatanodeNetworkErrors();\n       }\n       IOUtils.closeStream(proxyOut);\n       IOUtils.closeStream(blockReceiver);\n       IOUtils.closeStream(proxyReply);\n       IOUtils.closeStream(replyOut);\n     }\n \n     //update metrics\n     datanode.metrics.addReplaceBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void replaceBlock(final ExtendedBlock block,\n      final StorageType storageType, \n      final Token\u003cBlockTokenIdentifier\u003e blockToken,\n      final String delHint,\n      final DatanodeInfo proxySource,\n      final String storageId) throws IOException {\n    updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n    DataOutputStream replyOut \u003d new DataOutputStream(getOutputStream());\n    checkAccess(replyOut, true, block, blockToken,\n        Op.REPLACE_BLOCK, BlockTokenIdentifier.AccessMode.REPLACE,\n        new StorageType[]{storageType},\n        new String[]{storageId});\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      String msg \u003d \"Not able to receive block \" + block.getBlockId() +\n          \" from \" + peer.getRemoteAddressString() + \" because threads \" +\n          \"quota is exceeded.\";\n      LOG.warn(msg);\n      sendResponse(ERROR, msg);\n      return;\n    }\n\n    Socket proxySock \u003d null;\n    DataOutputStream proxyOut \u003d null;\n    Status opStatus \u003d SUCCESS;\n    String errMsg \u003d null;\n    DataInputStream proxyReply \u003d null;\n    boolean IoeDuringCopyBlockOperation \u003d false;\n    try {\n      // Move the block to different storage in the same datanode\n      if (proxySource.equals(datanode.getDatanodeId())) {\n        ReplicaInfo oldReplica \u003d datanode.data.moveBlockAcrossStorage(block,\n            storageType, storageId);\n        if (oldReplica !\u003d null) {\n          LOG.info(\"Moved \" + block + \" from StorageType \"\n              + oldReplica.getVolume().getStorageType() + \" to \" + storageType);\n        }\n      } else {\n        block.setNumBytes(dataXceiverServer.estimateBlockSize);\n        // get the output stream to the proxy\n        final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Connecting to datanode \" + dnAddr);\n        }\n        InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n        proxySock \u003d datanode.newSocket();\n        NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n        proxySock.setTcpNoDelay(dnConf.getDataTransferServerTcpNoDelay());\n        proxySock.setSoTimeout(dnConf.socketTimeout);\n        proxySock.setKeepAlive(true);\n\n        OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n            dnConf.socketWriteTimeout);\n        InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n        DataEncryptionKeyFactory keyFactory \u003d\n            datanode.getDataEncryptionKeyFactoryForBlock(block);\n        IOStreamPair saslStreams \u003d datanode.saslClient.socketSend(proxySock,\n            unbufProxyOut, unbufProxyIn, keyFactory, blockToken, proxySource);\n        unbufProxyOut \u003d saslStreams.out;\n        unbufProxyIn \u003d saslStreams.in;\n        \n        proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut,\n            smallBufferSize));\n        proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n            ioFileBufferSize));\n        \n        /* send request to the proxy */\n        IoeDuringCopyBlockOperation \u003d true;\n        new Sender(proxyOut).copyBlock(block, blockToken);\n        IoeDuringCopyBlockOperation \u003d false;\n        \n        // receive the response from the proxy\n        \n        BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n            PBHelperClient.vintPrefixed(proxyReply));\n\n        String logInfo \u003d \"copy block \" + block + \" from \"\n            + proxySock.getRemoteSocketAddress();\n        DataTransferProtoUtil.checkBlockOpStatus(copyResponse, logInfo, true);\n\n        // get checksum info about the block we\u0027re copying\n        ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n        DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n            checksumInfo.getChecksum());\n        // open a block receiver and check if the block does not exist\n        setCurrentBlockReceiver(getBlockReceiver(block, storageType,\n            proxyReply, proxySock.getRemoteSocketAddress().toString(),\n            proxySock.getLocalSocketAddress().toString(),\n            null, 0, 0, 0, \"\", null, datanode, remoteChecksum,\n            CachingStrategy.newDropBehind(), false, false, storageId));\n        \n        // receive a block\n        blockReceiver.receiveBlock(null, null, replyOut, null, \n            dataXceiverServer.balanceThrottler, null, true);\n        \n        // notify name node\n        final Replica r \u003d blockReceiver.getReplica();\n        datanode.notifyNamenodeReceivedBlock(\n            block, delHint, r.getStorageUuid(), r.isOnTransientStorage());\n        \n        LOG.info(\"Moved \" + block + \" from \" + peer.getRemoteAddressString()\n            + \", delHint\u003d\" + delHint);\n      }\n    } catch (IOException ioe) {\n      opStatus \u003d ERROR;\n      if (ioe instanceof BlockPinningException) {\n        opStatus \u003d Status.ERROR_BLOCK_PINNED;\n      }\n      errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n      LOG.info(errMsg);\n      if (!IoeDuringCopyBlockOperation) {\n        // Don\u0027t double count IO errors\n        incrDatanodeNetworkErrors();\n      }\n      throw ioe;\n    } finally {\n      // receive the last byte that indicates the proxy released its thread resource\n      if (opStatus \u003d\u003d SUCCESS \u0026\u0026 proxyReply !\u003d null) {\n        try {\n          proxyReply.readChar();\n        } catch (IOException ignored) {\n        }\n      }\n      \n      // now release the thread resource\n      dataXceiverServer.balanceThrottler.release();\n      \n      // send response back\n      try {\n        sendResponse(opStatus, errMsg);\n      } catch (IOException ioe) {\n        LOG.warn(\"Error writing reply back to \" + peer.getRemoteAddressString());\n        incrDatanodeNetworkErrors();\n      }\n      IOUtils.closeStream(proxyOut);\n      IOUtils.closeStream(blockReceiver);\n      IOUtils.closeStream(proxyReply);\n      IOUtils.closeStream(replyOut);\n    }\n\n    //update metrics\n    datanode.metrics.addReplaceBlockOp(elapsed());\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
          "extendedDetails": {}
        }
      ]
    },
    "2f73396b5901fd5fe29f6cd76fc1b3134b854b37": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6708. StorageType should be encoded in the block token. Contributed by Ewan Higgs\n",
      "commitDate": "25/04/17 11:57 PM",
      "commitName": "2f73396b5901fd5fe29f6cd76fc1b3134b854b37",
      "commitAuthor": "Chris Douglas",
      "commitDateOld": "12/04/17 11:40 AM",
      "commitNameOld": "abce61335678da753cd0f7965a236370274abee8",
      "commitAuthorOld": "Anu Engineer",
      "daysBetweenCommits": 13.51,
      "commitsBetweenForRepo": 57,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,140 +1,141 @@\n   public void replaceBlock(final ExtendedBlock block,\n       final StorageType storageType, \n       final Token\u003cBlockTokenIdentifier\u003e blockToken,\n       final String delHint,\n       final DatanodeInfo proxySource) throws IOException {\n     updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n     DataOutputStream replyOut \u003d new DataOutputStream(getOutputStream());\n     checkAccess(replyOut, true, block, blockToken,\n-        Op.REPLACE_BLOCK, BlockTokenIdentifier.AccessMode.REPLACE);\n+        Op.REPLACE_BLOCK, BlockTokenIdentifier.AccessMode.REPLACE,\n+        new StorageType[]{ storageType });\n \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n       String msg \u003d \"Not able to receive block \" + block.getBlockId() +\n           \" from \" + peer.getRemoteAddressString() + \" because threads \" +\n           \"quota is exceeded.\";\n       LOG.warn(msg);\n       sendResponse(ERROR, msg);\n       return;\n     }\n \n     Socket proxySock \u003d null;\n     DataOutputStream proxyOut \u003d null;\n     Status opStatus \u003d SUCCESS;\n     String errMsg \u003d null;\n     DataInputStream proxyReply \u003d null;\n     boolean IoeDuringCopyBlockOperation \u003d false;\n     try {\n       // Move the block to different storage in the same datanode\n       if (proxySource.equals(datanode.getDatanodeId())) {\n         ReplicaInfo oldReplica \u003d datanode.data.moveBlockAcrossStorage(block,\n             storageType);\n         if (oldReplica !\u003d null) {\n           LOG.info(\"Moved \" + block + \" from StorageType \"\n               + oldReplica.getVolume().getStorageType() + \" to \" + storageType);\n         }\n       } else {\n         block.setNumBytes(dataXceiverServer.estimateBlockSize);\n         // get the output stream to the proxy\n         final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Connecting to datanode \" + dnAddr);\n         }\n         InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n         proxySock \u003d datanode.newSocket();\n         NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n         proxySock.setTcpNoDelay(dnConf.getDataTransferServerTcpNoDelay());\n         proxySock.setSoTimeout(dnConf.socketTimeout);\n         proxySock.setKeepAlive(true);\n \n         OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n             dnConf.socketWriteTimeout);\n         InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n         DataEncryptionKeyFactory keyFactory \u003d\n             datanode.getDataEncryptionKeyFactoryForBlock(block);\n         IOStreamPair saslStreams \u003d datanode.saslClient.socketSend(proxySock,\n             unbufProxyOut, unbufProxyIn, keyFactory, blockToken, proxySource);\n         unbufProxyOut \u003d saslStreams.out;\n         unbufProxyIn \u003d saslStreams.in;\n         \n         proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut,\n             smallBufferSize));\n         proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n             ioFileBufferSize));\n         \n         /* send request to the proxy */\n         IoeDuringCopyBlockOperation \u003d true;\n         new Sender(proxyOut).copyBlock(block, blockToken);\n         IoeDuringCopyBlockOperation \u003d false;\n         \n         // receive the response from the proxy\n         \n         BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n             PBHelperClient.vintPrefixed(proxyReply));\n \n         String logInfo \u003d \"copy block \" + block + \" from \"\n             + proxySock.getRemoteSocketAddress();\n         DataTransferProtoUtil.checkBlockOpStatus(copyResponse, logInfo, true);\n \n         // get checksum info about the block we\u0027re copying\n         ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n         DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n             checksumInfo.getChecksum());\n         // open a block receiver and check if the block does not exist\n         setCurrentBlockReceiver(getBlockReceiver(block, storageType,\n             proxyReply, proxySock.getRemoteSocketAddress().toString(),\n             proxySock.getLocalSocketAddress().toString(),\n             null, 0, 0, 0, \"\", null, datanode, remoteChecksum,\n             CachingStrategy.newDropBehind(), false, false));\n         \n         // receive a block\n         blockReceiver.receiveBlock(null, null, replyOut, null, \n             dataXceiverServer.balanceThrottler, null, true);\n         \n         // notify name node\n         final Replica r \u003d blockReceiver.getReplica();\n         datanode.notifyNamenodeReceivedBlock(\n             block, delHint, r.getStorageUuid(), r.isOnTransientStorage());\n         \n         LOG.info(\"Moved \" + block + \" from \" + peer.getRemoteAddressString()\n             + \", delHint\u003d\" + delHint);\n       }\n     } catch (IOException ioe) {\n       opStatus \u003d ERROR;\n       if (ioe instanceof BlockPinningException) {\n         opStatus \u003d Status.ERROR_BLOCK_PINNED;\n       }\n       errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n       LOG.info(errMsg);\n       if (!IoeDuringCopyBlockOperation) {\n         // Don\u0027t double count IO errors\n         incrDatanodeNetworkErrors();\n       }\n       throw ioe;\n     } finally {\n       // receive the last byte that indicates the proxy released its thread resource\n       if (opStatus \u003d\u003d SUCCESS \u0026\u0026 proxyReply !\u003d null) {\n         try {\n           proxyReply.readChar();\n         } catch (IOException ignored) {\n         }\n       }\n       \n       // now release the thread resource\n       dataXceiverServer.balanceThrottler.release();\n       \n       // send response back\n       try {\n         sendResponse(opStatus, errMsg);\n       } catch (IOException ioe) {\n         LOG.warn(\"Error writing reply back to \" + peer.getRemoteAddressString());\n         incrDatanodeNetworkErrors();\n       }\n       IOUtils.closeStream(proxyOut);\n       IOUtils.closeStream(blockReceiver);\n       IOUtils.closeStream(proxyReply);\n       IOUtils.closeStream(replyOut);\n     }\n \n     //update metrics\n     datanode.metrics.addReplaceBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void replaceBlock(final ExtendedBlock block,\n      final StorageType storageType, \n      final Token\u003cBlockTokenIdentifier\u003e blockToken,\n      final String delHint,\n      final DatanodeInfo proxySource) throws IOException {\n    updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n    DataOutputStream replyOut \u003d new DataOutputStream(getOutputStream());\n    checkAccess(replyOut, true, block, blockToken,\n        Op.REPLACE_BLOCK, BlockTokenIdentifier.AccessMode.REPLACE,\n        new StorageType[]{ storageType });\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      String msg \u003d \"Not able to receive block \" + block.getBlockId() +\n          \" from \" + peer.getRemoteAddressString() + \" because threads \" +\n          \"quota is exceeded.\";\n      LOG.warn(msg);\n      sendResponse(ERROR, msg);\n      return;\n    }\n\n    Socket proxySock \u003d null;\n    DataOutputStream proxyOut \u003d null;\n    Status opStatus \u003d SUCCESS;\n    String errMsg \u003d null;\n    DataInputStream proxyReply \u003d null;\n    boolean IoeDuringCopyBlockOperation \u003d false;\n    try {\n      // Move the block to different storage in the same datanode\n      if (proxySource.equals(datanode.getDatanodeId())) {\n        ReplicaInfo oldReplica \u003d datanode.data.moveBlockAcrossStorage(block,\n            storageType);\n        if (oldReplica !\u003d null) {\n          LOG.info(\"Moved \" + block + \" from StorageType \"\n              + oldReplica.getVolume().getStorageType() + \" to \" + storageType);\n        }\n      } else {\n        block.setNumBytes(dataXceiverServer.estimateBlockSize);\n        // get the output stream to the proxy\n        final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Connecting to datanode \" + dnAddr);\n        }\n        InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n        proxySock \u003d datanode.newSocket();\n        NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n        proxySock.setTcpNoDelay(dnConf.getDataTransferServerTcpNoDelay());\n        proxySock.setSoTimeout(dnConf.socketTimeout);\n        proxySock.setKeepAlive(true);\n\n        OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n            dnConf.socketWriteTimeout);\n        InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n        DataEncryptionKeyFactory keyFactory \u003d\n            datanode.getDataEncryptionKeyFactoryForBlock(block);\n        IOStreamPair saslStreams \u003d datanode.saslClient.socketSend(proxySock,\n            unbufProxyOut, unbufProxyIn, keyFactory, blockToken, proxySource);\n        unbufProxyOut \u003d saslStreams.out;\n        unbufProxyIn \u003d saslStreams.in;\n        \n        proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut,\n            smallBufferSize));\n        proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n            ioFileBufferSize));\n        \n        /* send request to the proxy */\n        IoeDuringCopyBlockOperation \u003d true;\n        new Sender(proxyOut).copyBlock(block, blockToken);\n        IoeDuringCopyBlockOperation \u003d false;\n        \n        // receive the response from the proxy\n        \n        BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n            PBHelperClient.vintPrefixed(proxyReply));\n\n        String logInfo \u003d \"copy block \" + block + \" from \"\n            + proxySock.getRemoteSocketAddress();\n        DataTransferProtoUtil.checkBlockOpStatus(copyResponse, logInfo, true);\n\n        // get checksum info about the block we\u0027re copying\n        ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n        DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n            checksumInfo.getChecksum());\n        // open a block receiver and check if the block does not exist\n        setCurrentBlockReceiver(getBlockReceiver(block, storageType,\n            proxyReply, proxySock.getRemoteSocketAddress().toString(),\n            proxySock.getLocalSocketAddress().toString(),\n            null, 0, 0, 0, \"\", null, datanode, remoteChecksum,\n            CachingStrategy.newDropBehind(), false, false));\n        \n        // receive a block\n        blockReceiver.receiveBlock(null, null, replyOut, null, \n            dataXceiverServer.balanceThrottler, null, true);\n        \n        // notify name node\n        final Replica r \u003d blockReceiver.getReplica();\n        datanode.notifyNamenodeReceivedBlock(\n            block, delHint, r.getStorageUuid(), r.isOnTransientStorage());\n        \n        LOG.info(\"Moved \" + block + \" from \" + peer.getRemoteAddressString()\n            + \", delHint\u003d\" + delHint);\n      }\n    } catch (IOException ioe) {\n      opStatus \u003d ERROR;\n      if (ioe instanceof BlockPinningException) {\n        opStatus \u003d Status.ERROR_BLOCK_PINNED;\n      }\n      errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n      LOG.info(errMsg);\n      if (!IoeDuringCopyBlockOperation) {\n        // Don\u0027t double count IO errors\n        incrDatanodeNetworkErrors();\n      }\n      throw ioe;\n    } finally {\n      // receive the last byte that indicates the proxy released its thread resource\n      if (opStatus \u003d\u003d SUCCESS \u0026\u0026 proxyReply !\u003d null) {\n        try {\n          proxyReply.readChar();\n        } catch (IOException ignored) {\n        }\n      }\n      \n      // now release the thread resource\n      dataXceiverServer.balanceThrottler.release();\n      \n      // send response back\n      try {\n        sendResponse(opStatus, errMsg);\n      } catch (IOException ioe) {\n        LOG.warn(\"Error writing reply back to \" + peer.getRemoteAddressString());\n        incrDatanodeNetworkErrors();\n      }\n      IOUtils.closeStream(proxyOut);\n      IOUtils.closeStream(blockReceiver);\n      IOUtils.closeStream(proxyReply);\n      IOUtils.closeStream(replyOut);\n    }\n\n    //update metrics\n    datanode.metrics.addReplaceBlockOp(elapsed());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "e24a923db50879f7dbe5d2afac0e6757089fb07d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11164: Mover should avoid unnecessary retries if the block is pinned. Contributed by Rakesh R\n",
      "commitDate": "13/12/16 5:09 PM",
      "commitName": "e24a923db50879f7dbe5d2afac0e6757089fb07d",
      "commitAuthor": "Uma Maheswara Rao G",
      "commitDateOld": "30/08/16 10:43 AM",
      "commitNameOld": "c4ee6915a14e00342755d7cdcbf2d61518f306aa",
      "commitAuthorOld": "Wei-Chiu Chuang",
      "daysBetweenCommits": 105.31,
      "commitsBetweenForRepo": 759,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,137 +1,140 @@\n   public void replaceBlock(final ExtendedBlock block,\n       final StorageType storageType, \n       final Token\u003cBlockTokenIdentifier\u003e blockToken,\n       final String delHint,\n       final DatanodeInfo proxySource) throws IOException {\n     updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n     DataOutputStream replyOut \u003d new DataOutputStream(getOutputStream());\n     checkAccess(replyOut, true, block, blockToken,\n         Op.REPLACE_BLOCK, BlockTokenIdentifier.AccessMode.REPLACE);\n \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n       String msg \u003d \"Not able to receive block \" + block.getBlockId() +\n           \" from \" + peer.getRemoteAddressString() + \" because threads \" +\n           \"quota is exceeded.\";\n       LOG.warn(msg);\n       sendResponse(ERROR, msg);\n       return;\n     }\n \n     Socket proxySock \u003d null;\n     DataOutputStream proxyOut \u003d null;\n     Status opStatus \u003d SUCCESS;\n     String errMsg \u003d null;\n     DataInputStream proxyReply \u003d null;\n     boolean IoeDuringCopyBlockOperation \u003d false;\n     try {\n       // Move the block to different storage in the same datanode\n       if (proxySource.equals(datanode.getDatanodeId())) {\n         ReplicaInfo oldReplica \u003d datanode.data.moveBlockAcrossStorage(block,\n             storageType);\n         if (oldReplica !\u003d null) {\n           LOG.info(\"Moved \" + block + \" from StorageType \"\n               + oldReplica.getVolume().getStorageType() + \" to \" + storageType);\n         }\n       } else {\n         block.setNumBytes(dataXceiverServer.estimateBlockSize);\n         // get the output stream to the proxy\n         final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Connecting to datanode \" + dnAddr);\n         }\n         InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n         proxySock \u003d datanode.newSocket();\n         NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n         proxySock.setTcpNoDelay(dnConf.getDataTransferServerTcpNoDelay());\n         proxySock.setSoTimeout(dnConf.socketTimeout);\n         proxySock.setKeepAlive(true);\n \n         OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n             dnConf.socketWriteTimeout);\n         InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n         DataEncryptionKeyFactory keyFactory \u003d\n             datanode.getDataEncryptionKeyFactoryForBlock(block);\n         IOStreamPair saslStreams \u003d datanode.saslClient.socketSend(proxySock,\n             unbufProxyOut, unbufProxyIn, keyFactory, blockToken, proxySource);\n         unbufProxyOut \u003d saslStreams.out;\n         unbufProxyIn \u003d saslStreams.in;\n         \n         proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut,\n             smallBufferSize));\n         proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n             ioFileBufferSize));\n         \n         /* send request to the proxy */\n         IoeDuringCopyBlockOperation \u003d true;\n         new Sender(proxyOut).copyBlock(block, blockToken);\n         IoeDuringCopyBlockOperation \u003d false;\n         \n         // receive the response from the proxy\n         \n         BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n             PBHelperClient.vintPrefixed(proxyReply));\n \n         String logInfo \u003d \"copy block \" + block + \" from \"\n             + proxySock.getRemoteSocketAddress();\n-        DataTransferProtoUtil.checkBlockOpStatus(copyResponse, logInfo);\n+        DataTransferProtoUtil.checkBlockOpStatus(copyResponse, logInfo, true);\n \n         // get checksum info about the block we\u0027re copying\n         ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n         DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n             checksumInfo.getChecksum());\n         // open a block receiver and check if the block does not exist\n         setCurrentBlockReceiver(getBlockReceiver(block, storageType,\n             proxyReply, proxySock.getRemoteSocketAddress().toString(),\n             proxySock.getLocalSocketAddress().toString(),\n             null, 0, 0, 0, \"\", null, datanode, remoteChecksum,\n             CachingStrategy.newDropBehind(), false, false));\n         \n         // receive a block\n         blockReceiver.receiveBlock(null, null, replyOut, null, \n             dataXceiverServer.balanceThrottler, null, true);\n         \n         // notify name node\n         final Replica r \u003d blockReceiver.getReplica();\n         datanode.notifyNamenodeReceivedBlock(\n             block, delHint, r.getStorageUuid(), r.isOnTransientStorage());\n         \n         LOG.info(\"Moved \" + block + \" from \" + peer.getRemoteAddressString()\n             + \", delHint\u003d\" + delHint);\n       }\n     } catch (IOException ioe) {\n       opStatus \u003d ERROR;\n+      if (ioe instanceof BlockPinningException) {\n+        opStatus \u003d Status.ERROR_BLOCK_PINNED;\n+      }\n       errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n       LOG.info(errMsg);\n       if (!IoeDuringCopyBlockOperation) {\n         // Don\u0027t double count IO errors\n         incrDatanodeNetworkErrors();\n       }\n       throw ioe;\n     } finally {\n       // receive the last byte that indicates the proxy released its thread resource\n       if (opStatus \u003d\u003d SUCCESS \u0026\u0026 proxyReply !\u003d null) {\n         try {\n           proxyReply.readChar();\n         } catch (IOException ignored) {\n         }\n       }\n       \n       // now release the thread resource\n       dataXceiverServer.balanceThrottler.release();\n       \n       // send response back\n       try {\n         sendResponse(opStatus, errMsg);\n       } catch (IOException ioe) {\n         LOG.warn(\"Error writing reply back to \" + peer.getRemoteAddressString());\n         incrDatanodeNetworkErrors();\n       }\n       IOUtils.closeStream(proxyOut);\n       IOUtils.closeStream(blockReceiver);\n       IOUtils.closeStream(proxyReply);\n       IOUtils.closeStream(replyOut);\n     }\n \n     //update metrics\n     datanode.metrics.addReplaceBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void replaceBlock(final ExtendedBlock block,\n      final StorageType storageType, \n      final Token\u003cBlockTokenIdentifier\u003e blockToken,\n      final String delHint,\n      final DatanodeInfo proxySource) throws IOException {\n    updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n    DataOutputStream replyOut \u003d new DataOutputStream(getOutputStream());\n    checkAccess(replyOut, true, block, blockToken,\n        Op.REPLACE_BLOCK, BlockTokenIdentifier.AccessMode.REPLACE);\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      String msg \u003d \"Not able to receive block \" + block.getBlockId() +\n          \" from \" + peer.getRemoteAddressString() + \" because threads \" +\n          \"quota is exceeded.\";\n      LOG.warn(msg);\n      sendResponse(ERROR, msg);\n      return;\n    }\n\n    Socket proxySock \u003d null;\n    DataOutputStream proxyOut \u003d null;\n    Status opStatus \u003d SUCCESS;\n    String errMsg \u003d null;\n    DataInputStream proxyReply \u003d null;\n    boolean IoeDuringCopyBlockOperation \u003d false;\n    try {\n      // Move the block to different storage in the same datanode\n      if (proxySource.equals(datanode.getDatanodeId())) {\n        ReplicaInfo oldReplica \u003d datanode.data.moveBlockAcrossStorage(block,\n            storageType);\n        if (oldReplica !\u003d null) {\n          LOG.info(\"Moved \" + block + \" from StorageType \"\n              + oldReplica.getVolume().getStorageType() + \" to \" + storageType);\n        }\n      } else {\n        block.setNumBytes(dataXceiverServer.estimateBlockSize);\n        // get the output stream to the proxy\n        final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Connecting to datanode \" + dnAddr);\n        }\n        InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n        proxySock \u003d datanode.newSocket();\n        NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n        proxySock.setTcpNoDelay(dnConf.getDataTransferServerTcpNoDelay());\n        proxySock.setSoTimeout(dnConf.socketTimeout);\n        proxySock.setKeepAlive(true);\n\n        OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n            dnConf.socketWriteTimeout);\n        InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n        DataEncryptionKeyFactory keyFactory \u003d\n            datanode.getDataEncryptionKeyFactoryForBlock(block);\n        IOStreamPair saslStreams \u003d datanode.saslClient.socketSend(proxySock,\n            unbufProxyOut, unbufProxyIn, keyFactory, blockToken, proxySource);\n        unbufProxyOut \u003d saslStreams.out;\n        unbufProxyIn \u003d saslStreams.in;\n        \n        proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut,\n            smallBufferSize));\n        proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n            ioFileBufferSize));\n        \n        /* send request to the proxy */\n        IoeDuringCopyBlockOperation \u003d true;\n        new Sender(proxyOut).copyBlock(block, blockToken);\n        IoeDuringCopyBlockOperation \u003d false;\n        \n        // receive the response from the proxy\n        \n        BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n            PBHelperClient.vintPrefixed(proxyReply));\n\n        String logInfo \u003d \"copy block \" + block + \" from \"\n            + proxySock.getRemoteSocketAddress();\n        DataTransferProtoUtil.checkBlockOpStatus(copyResponse, logInfo, true);\n\n        // get checksum info about the block we\u0027re copying\n        ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n        DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n            checksumInfo.getChecksum());\n        // open a block receiver and check if the block does not exist\n        setCurrentBlockReceiver(getBlockReceiver(block, storageType,\n            proxyReply, proxySock.getRemoteSocketAddress().toString(),\n            proxySock.getLocalSocketAddress().toString(),\n            null, 0, 0, 0, \"\", null, datanode, remoteChecksum,\n            CachingStrategy.newDropBehind(), false, false));\n        \n        // receive a block\n        blockReceiver.receiveBlock(null, null, replyOut, null, \n            dataXceiverServer.balanceThrottler, null, true);\n        \n        // notify name node\n        final Replica r \u003d blockReceiver.getReplica();\n        datanode.notifyNamenodeReceivedBlock(\n            block, delHint, r.getStorageUuid(), r.isOnTransientStorage());\n        \n        LOG.info(\"Moved \" + block + \" from \" + peer.getRemoteAddressString()\n            + \", delHint\u003d\" + delHint);\n      }\n    } catch (IOException ioe) {\n      opStatus \u003d ERROR;\n      if (ioe instanceof BlockPinningException) {\n        opStatus \u003d Status.ERROR_BLOCK_PINNED;\n      }\n      errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n      LOG.info(errMsg);\n      if (!IoeDuringCopyBlockOperation) {\n        // Don\u0027t double count IO errors\n        incrDatanodeNetworkErrors();\n      }\n      throw ioe;\n    } finally {\n      // receive the last byte that indicates the proxy released its thread resource\n      if (opStatus \u003d\u003d SUCCESS \u0026\u0026 proxyReply !\u003d null) {\n        try {\n          proxyReply.readChar();\n        } catch (IOException ignored) {\n        }\n      }\n      \n      // now release the thread resource\n      dataXceiverServer.balanceThrottler.release();\n      \n      // send response back\n      try {\n        sendResponse(opStatus, errMsg);\n      } catch (IOException ioe) {\n        LOG.warn(\"Error writing reply back to \" + peer.getRemoteAddressString());\n        incrDatanodeNetworkErrors();\n      }\n      IOUtils.closeStream(proxyOut);\n      IOUtils.closeStream(blockReceiver);\n      IOUtils.closeStream(proxyReply);\n      IOUtils.closeStream(replyOut);\n    }\n\n    //update metrics\n    datanode.metrics.addReplaceBlockOp(elapsed());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "e4a25456202feeee9880d822a8e6f9c19cbcf24a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9805. Add server-side configuration for enabling TCP_NODELAY for DataTransferProtocol and default it to true (Gary Helmling via cmccabe)\n",
      "commitDate": "29/06/16 12:41 PM",
      "commitName": "e4a25456202feeee9880d822a8e6f9c19cbcf24a",
      "commitAuthor": "Colin Patrick Mccabe",
      "commitDateOld": "24/06/16 2:39 AM",
      "commitNameOld": "e6cb07520f935efde3e881de8f84ee7f6e0a746f",
      "commitAuthorOld": "Kai Zheng",
      "daysBetweenCommits": 5.42,
      "commitsBetweenForRepo": 28,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,136 +1,137 @@\n   public void replaceBlock(final ExtendedBlock block,\n       final StorageType storageType, \n       final Token\u003cBlockTokenIdentifier\u003e blockToken,\n       final String delHint,\n       final DatanodeInfo proxySource) throws IOException {\n     updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n     DataOutputStream replyOut \u003d new DataOutputStream(getOutputStream());\n     checkAccess(replyOut, true, block, blockToken,\n         Op.REPLACE_BLOCK, BlockTokenIdentifier.AccessMode.REPLACE);\n \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n       String msg \u003d \"Not able to receive block \" + block.getBlockId() +\n           \" from \" + peer.getRemoteAddressString() + \" because threads \" +\n           \"quota is exceeded.\";\n       LOG.warn(msg);\n       sendResponse(ERROR, msg);\n       return;\n     }\n \n     Socket proxySock \u003d null;\n     DataOutputStream proxyOut \u003d null;\n     Status opStatus \u003d SUCCESS;\n     String errMsg \u003d null;\n     DataInputStream proxyReply \u003d null;\n     boolean IoeDuringCopyBlockOperation \u003d false;\n     try {\n       // Move the block to different storage in the same datanode\n       if (proxySource.equals(datanode.getDatanodeId())) {\n         ReplicaInfo oldReplica \u003d datanode.data.moveBlockAcrossStorage(block,\n             storageType);\n         if (oldReplica !\u003d null) {\n           LOG.info(\"Moved \" + block + \" from StorageType \"\n               + oldReplica.getVolume().getStorageType() + \" to \" + storageType);\n         }\n       } else {\n         block.setNumBytes(dataXceiverServer.estimateBlockSize);\n         // get the output stream to the proxy\n         final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Connecting to datanode \" + dnAddr);\n         }\n         InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n         proxySock \u003d datanode.newSocket();\n         NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n+        proxySock.setTcpNoDelay(dnConf.getDataTransferServerTcpNoDelay());\n         proxySock.setSoTimeout(dnConf.socketTimeout);\n         proxySock.setKeepAlive(true);\n \n         OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n             dnConf.socketWriteTimeout);\n         InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n         DataEncryptionKeyFactory keyFactory \u003d\n             datanode.getDataEncryptionKeyFactoryForBlock(block);\n         IOStreamPair saslStreams \u003d datanode.saslClient.socketSend(proxySock,\n             unbufProxyOut, unbufProxyIn, keyFactory, blockToken, proxySource);\n         unbufProxyOut \u003d saslStreams.out;\n         unbufProxyIn \u003d saslStreams.in;\n         \n         proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut,\n             smallBufferSize));\n         proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n             ioFileBufferSize));\n         \n         /* send request to the proxy */\n         IoeDuringCopyBlockOperation \u003d true;\n         new Sender(proxyOut).copyBlock(block, blockToken);\n         IoeDuringCopyBlockOperation \u003d false;\n         \n         // receive the response from the proxy\n         \n         BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n             PBHelperClient.vintPrefixed(proxyReply));\n \n         String logInfo \u003d \"copy block \" + block + \" from \"\n             + proxySock.getRemoteSocketAddress();\n         DataTransferProtoUtil.checkBlockOpStatus(copyResponse, logInfo);\n \n         // get checksum info about the block we\u0027re copying\n         ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n         DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n             checksumInfo.getChecksum());\n         // open a block receiver and check if the block does not exist\n         setCurrentBlockReceiver(getBlockReceiver(block, storageType,\n             proxyReply, proxySock.getRemoteSocketAddress().toString(),\n             proxySock.getLocalSocketAddress().toString(),\n             null, 0, 0, 0, \"\", null, datanode, remoteChecksum,\n             CachingStrategy.newDropBehind(), false, false));\n         \n         // receive a block\n         blockReceiver.receiveBlock(null, null, replyOut, null, \n             dataXceiverServer.balanceThrottler, null, true);\n         \n         // notify name node\n         final Replica r \u003d blockReceiver.getReplica();\n         datanode.notifyNamenodeReceivedBlock(\n             block, delHint, r.getStorageUuid(), r.isOnTransientStorage());\n         \n         LOG.info(\"Moved \" + block + \" from \" + peer.getRemoteAddressString()\n             + \", delHint\u003d\" + delHint);\n       }\n     } catch (IOException ioe) {\n       opStatus \u003d ERROR;\n       errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n       LOG.info(errMsg);\n       if (!IoeDuringCopyBlockOperation) {\n         // Don\u0027t double count IO errors\n         incrDatanodeNetworkErrors();\n       }\n       throw ioe;\n     } finally {\n       // receive the last byte that indicates the proxy released its thread resource\n       if (opStatus \u003d\u003d SUCCESS \u0026\u0026 proxyReply !\u003d null) {\n         try {\n           proxyReply.readChar();\n         } catch (IOException ignored) {\n         }\n       }\n       \n       // now release the thread resource\n       dataXceiverServer.balanceThrottler.release();\n       \n       // send response back\n       try {\n         sendResponse(opStatus, errMsg);\n       } catch (IOException ioe) {\n         LOG.warn(\"Error writing reply back to \" + peer.getRemoteAddressString());\n         incrDatanodeNetworkErrors();\n       }\n       IOUtils.closeStream(proxyOut);\n       IOUtils.closeStream(blockReceiver);\n       IOUtils.closeStream(proxyReply);\n       IOUtils.closeStream(replyOut);\n     }\n \n     //update metrics\n     datanode.metrics.addReplaceBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void replaceBlock(final ExtendedBlock block,\n      final StorageType storageType, \n      final Token\u003cBlockTokenIdentifier\u003e blockToken,\n      final String delHint,\n      final DatanodeInfo proxySource) throws IOException {\n    updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n    DataOutputStream replyOut \u003d new DataOutputStream(getOutputStream());\n    checkAccess(replyOut, true, block, blockToken,\n        Op.REPLACE_BLOCK, BlockTokenIdentifier.AccessMode.REPLACE);\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      String msg \u003d \"Not able to receive block \" + block.getBlockId() +\n          \" from \" + peer.getRemoteAddressString() + \" because threads \" +\n          \"quota is exceeded.\";\n      LOG.warn(msg);\n      sendResponse(ERROR, msg);\n      return;\n    }\n\n    Socket proxySock \u003d null;\n    DataOutputStream proxyOut \u003d null;\n    Status opStatus \u003d SUCCESS;\n    String errMsg \u003d null;\n    DataInputStream proxyReply \u003d null;\n    boolean IoeDuringCopyBlockOperation \u003d false;\n    try {\n      // Move the block to different storage in the same datanode\n      if (proxySource.equals(datanode.getDatanodeId())) {\n        ReplicaInfo oldReplica \u003d datanode.data.moveBlockAcrossStorage(block,\n            storageType);\n        if (oldReplica !\u003d null) {\n          LOG.info(\"Moved \" + block + \" from StorageType \"\n              + oldReplica.getVolume().getStorageType() + \" to \" + storageType);\n        }\n      } else {\n        block.setNumBytes(dataXceiverServer.estimateBlockSize);\n        // get the output stream to the proxy\n        final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Connecting to datanode \" + dnAddr);\n        }\n        InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n        proxySock \u003d datanode.newSocket();\n        NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n        proxySock.setTcpNoDelay(dnConf.getDataTransferServerTcpNoDelay());\n        proxySock.setSoTimeout(dnConf.socketTimeout);\n        proxySock.setKeepAlive(true);\n\n        OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n            dnConf.socketWriteTimeout);\n        InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n        DataEncryptionKeyFactory keyFactory \u003d\n            datanode.getDataEncryptionKeyFactoryForBlock(block);\n        IOStreamPair saslStreams \u003d datanode.saslClient.socketSend(proxySock,\n            unbufProxyOut, unbufProxyIn, keyFactory, blockToken, proxySource);\n        unbufProxyOut \u003d saslStreams.out;\n        unbufProxyIn \u003d saslStreams.in;\n        \n        proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut,\n            smallBufferSize));\n        proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n            ioFileBufferSize));\n        \n        /* send request to the proxy */\n        IoeDuringCopyBlockOperation \u003d true;\n        new Sender(proxyOut).copyBlock(block, blockToken);\n        IoeDuringCopyBlockOperation \u003d false;\n        \n        // receive the response from the proxy\n        \n        BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n            PBHelperClient.vintPrefixed(proxyReply));\n\n        String logInfo \u003d \"copy block \" + block + \" from \"\n            + proxySock.getRemoteSocketAddress();\n        DataTransferProtoUtil.checkBlockOpStatus(copyResponse, logInfo);\n\n        // get checksum info about the block we\u0027re copying\n        ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n        DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n            checksumInfo.getChecksum());\n        // open a block receiver and check if the block does not exist\n        setCurrentBlockReceiver(getBlockReceiver(block, storageType,\n            proxyReply, proxySock.getRemoteSocketAddress().toString(),\n            proxySock.getLocalSocketAddress().toString(),\n            null, 0, 0, 0, \"\", null, datanode, remoteChecksum,\n            CachingStrategy.newDropBehind(), false, false));\n        \n        // receive a block\n        blockReceiver.receiveBlock(null, null, replyOut, null, \n            dataXceiverServer.balanceThrottler, null, true);\n        \n        // notify name node\n        final Replica r \u003d blockReceiver.getReplica();\n        datanode.notifyNamenodeReceivedBlock(\n            block, delHint, r.getStorageUuid(), r.isOnTransientStorage());\n        \n        LOG.info(\"Moved \" + block + \" from \" + peer.getRemoteAddressString()\n            + \", delHint\u003d\" + delHint);\n      }\n    } catch (IOException ioe) {\n      opStatus \u003d ERROR;\n      errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n      LOG.info(errMsg);\n      if (!IoeDuringCopyBlockOperation) {\n        // Don\u0027t double count IO errors\n        incrDatanodeNetworkErrors();\n      }\n      throw ioe;\n    } finally {\n      // receive the last byte that indicates the proxy released its thread resource\n      if (opStatus \u003d\u003d SUCCESS \u0026\u0026 proxyReply !\u003d null) {\n        try {\n          proxyReply.readChar();\n        } catch (IOException ignored) {\n        }\n      }\n      \n      // now release the thread resource\n      dataXceiverServer.balanceThrottler.release();\n      \n      // send response back\n      try {\n        sendResponse(opStatus, errMsg);\n      } catch (IOException ioe) {\n        LOG.warn(\"Error writing reply back to \" + peer.getRemoteAddressString());\n        incrDatanodeNetworkErrors();\n      }\n      IOUtils.closeStream(proxyOut);\n      IOUtils.closeStream(blockReceiver);\n      IOUtils.closeStream(proxyReply);\n      IOUtils.closeStream(replyOut);\n    }\n\n    //update metrics\n    datanode.metrics.addReplaceBlockOp(elapsed());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "aede8c10ecad4f2a8802a834e4bd0b8286cebade": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9945. Datanode command for evicting writers. Contributed by Kihwal Lee\n",
      "commitDate": "06/04/16 1:20 PM",
      "commitName": "aede8c10ecad4f2a8802a834e4bd0b8286cebade",
      "commitAuthor": "Eric Payne",
      "commitDateOld": "26/03/16 7:58 PM",
      "commitNameOld": "3a4ff7776e8fab6cc87932b9aa8fb48f7b69c720",
      "commitAuthorOld": "Uma Maheswara Rao G",
      "daysBetweenCommits": 10.72,
      "commitsBetweenForRepo": 76,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,137 +1,136 @@\n   public void replaceBlock(final ExtendedBlock block,\n       final StorageType storageType, \n       final Token\u003cBlockTokenIdentifier\u003e blockToken,\n       final String delHint,\n       final DatanodeInfo proxySource) throws IOException {\n     updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n     DataOutputStream replyOut \u003d new DataOutputStream(getOutputStream());\n     checkAccess(replyOut, true, block, blockToken,\n         Op.REPLACE_BLOCK, BlockTokenIdentifier.AccessMode.REPLACE);\n \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n       String msg \u003d \"Not able to receive block \" + block.getBlockId() +\n           \" from \" + peer.getRemoteAddressString() + \" because threads \" +\n           \"quota is exceeded.\";\n       LOG.warn(msg);\n       sendResponse(ERROR, msg);\n       return;\n     }\n \n     Socket proxySock \u003d null;\n     DataOutputStream proxyOut \u003d null;\n     Status opStatus \u003d SUCCESS;\n     String errMsg \u003d null;\n-    BlockReceiver blockReceiver \u003d null;\n     DataInputStream proxyReply \u003d null;\n     boolean IoeDuringCopyBlockOperation \u003d false;\n     try {\n       // Move the block to different storage in the same datanode\n       if (proxySource.equals(datanode.getDatanodeId())) {\n         ReplicaInfo oldReplica \u003d datanode.data.moveBlockAcrossStorage(block,\n             storageType);\n         if (oldReplica !\u003d null) {\n           LOG.info(\"Moved \" + block + \" from StorageType \"\n               + oldReplica.getVolume().getStorageType() + \" to \" + storageType);\n         }\n       } else {\n         block.setNumBytes(dataXceiverServer.estimateBlockSize);\n         // get the output stream to the proxy\n         final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Connecting to datanode \" + dnAddr);\n         }\n         InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n         proxySock \u003d datanode.newSocket();\n         NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n         proxySock.setSoTimeout(dnConf.socketTimeout);\n         proxySock.setKeepAlive(true);\n \n         OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n             dnConf.socketWriteTimeout);\n         InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n         DataEncryptionKeyFactory keyFactory \u003d\n             datanode.getDataEncryptionKeyFactoryForBlock(block);\n         IOStreamPair saslStreams \u003d datanode.saslClient.socketSend(proxySock,\n             unbufProxyOut, unbufProxyIn, keyFactory, blockToken, proxySource);\n         unbufProxyOut \u003d saslStreams.out;\n         unbufProxyIn \u003d saslStreams.in;\n         \n         proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut,\n             smallBufferSize));\n         proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n             ioFileBufferSize));\n         \n         /* send request to the proxy */\n         IoeDuringCopyBlockOperation \u003d true;\n         new Sender(proxyOut).copyBlock(block, blockToken);\n         IoeDuringCopyBlockOperation \u003d false;\n         \n         // receive the response from the proxy\n         \n         BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n             PBHelperClient.vintPrefixed(proxyReply));\n \n         String logInfo \u003d \"copy block \" + block + \" from \"\n             + proxySock.getRemoteSocketAddress();\n         DataTransferProtoUtil.checkBlockOpStatus(copyResponse, logInfo);\n \n         // get checksum info about the block we\u0027re copying\n         ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n         DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n             checksumInfo.getChecksum());\n         // open a block receiver and check if the block does not exist\n-        blockReceiver \u003d getBlockReceiver(block, storageType,\n+        setCurrentBlockReceiver(getBlockReceiver(block, storageType,\n             proxyReply, proxySock.getRemoteSocketAddress().toString(),\n             proxySock.getLocalSocketAddress().toString(),\n             null, 0, 0, 0, \"\", null, datanode, remoteChecksum,\n-            CachingStrategy.newDropBehind(), false, false);\n+            CachingStrategy.newDropBehind(), false, false));\n         \n         // receive a block\n         blockReceiver.receiveBlock(null, null, replyOut, null, \n             dataXceiverServer.balanceThrottler, null, true);\n         \n         // notify name node\n         final Replica r \u003d blockReceiver.getReplica();\n         datanode.notifyNamenodeReceivedBlock(\n             block, delHint, r.getStorageUuid(), r.isOnTransientStorage());\n         \n         LOG.info(\"Moved \" + block + \" from \" + peer.getRemoteAddressString()\n             + \", delHint\u003d\" + delHint);\n       }\n     } catch (IOException ioe) {\n       opStatus \u003d ERROR;\n       errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n       LOG.info(errMsg);\n       if (!IoeDuringCopyBlockOperation) {\n         // Don\u0027t double count IO errors\n         incrDatanodeNetworkErrors();\n       }\n       throw ioe;\n     } finally {\n       // receive the last byte that indicates the proxy released its thread resource\n       if (opStatus \u003d\u003d SUCCESS \u0026\u0026 proxyReply !\u003d null) {\n         try {\n           proxyReply.readChar();\n         } catch (IOException ignored) {\n         }\n       }\n       \n       // now release the thread resource\n       dataXceiverServer.balanceThrottler.release();\n       \n       // send response back\n       try {\n         sendResponse(opStatus, errMsg);\n       } catch (IOException ioe) {\n         LOG.warn(\"Error writing reply back to \" + peer.getRemoteAddressString());\n         incrDatanodeNetworkErrors();\n       }\n       IOUtils.closeStream(proxyOut);\n       IOUtils.closeStream(blockReceiver);\n       IOUtils.closeStream(proxyReply);\n       IOUtils.closeStream(replyOut);\n     }\n \n     //update metrics\n     datanode.metrics.addReplaceBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void replaceBlock(final ExtendedBlock block,\n      final StorageType storageType, \n      final Token\u003cBlockTokenIdentifier\u003e blockToken,\n      final String delHint,\n      final DatanodeInfo proxySource) throws IOException {\n    updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n    DataOutputStream replyOut \u003d new DataOutputStream(getOutputStream());\n    checkAccess(replyOut, true, block, blockToken,\n        Op.REPLACE_BLOCK, BlockTokenIdentifier.AccessMode.REPLACE);\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      String msg \u003d \"Not able to receive block \" + block.getBlockId() +\n          \" from \" + peer.getRemoteAddressString() + \" because threads \" +\n          \"quota is exceeded.\";\n      LOG.warn(msg);\n      sendResponse(ERROR, msg);\n      return;\n    }\n\n    Socket proxySock \u003d null;\n    DataOutputStream proxyOut \u003d null;\n    Status opStatus \u003d SUCCESS;\n    String errMsg \u003d null;\n    DataInputStream proxyReply \u003d null;\n    boolean IoeDuringCopyBlockOperation \u003d false;\n    try {\n      // Move the block to different storage in the same datanode\n      if (proxySource.equals(datanode.getDatanodeId())) {\n        ReplicaInfo oldReplica \u003d datanode.data.moveBlockAcrossStorage(block,\n            storageType);\n        if (oldReplica !\u003d null) {\n          LOG.info(\"Moved \" + block + \" from StorageType \"\n              + oldReplica.getVolume().getStorageType() + \" to \" + storageType);\n        }\n      } else {\n        block.setNumBytes(dataXceiverServer.estimateBlockSize);\n        // get the output stream to the proxy\n        final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Connecting to datanode \" + dnAddr);\n        }\n        InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n        proxySock \u003d datanode.newSocket();\n        NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n        proxySock.setSoTimeout(dnConf.socketTimeout);\n        proxySock.setKeepAlive(true);\n\n        OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n            dnConf.socketWriteTimeout);\n        InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n        DataEncryptionKeyFactory keyFactory \u003d\n            datanode.getDataEncryptionKeyFactoryForBlock(block);\n        IOStreamPair saslStreams \u003d datanode.saslClient.socketSend(proxySock,\n            unbufProxyOut, unbufProxyIn, keyFactory, blockToken, proxySource);\n        unbufProxyOut \u003d saslStreams.out;\n        unbufProxyIn \u003d saslStreams.in;\n        \n        proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut,\n            smallBufferSize));\n        proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n            ioFileBufferSize));\n        \n        /* send request to the proxy */\n        IoeDuringCopyBlockOperation \u003d true;\n        new Sender(proxyOut).copyBlock(block, blockToken);\n        IoeDuringCopyBlockOperation \u003d false;\n        \n        // receive the response from the proxy\n        \n        BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n            PBHelperClient.vintPrefixed(proxyReply));\n\n        String logInfo \u003d \"copy block \" + block + \" from \"\n            + proxySock.getRemoteSocketAddress();\n        DataTransferProtoUtil.checkBlockOpStatus(copyResponse, logInfo);\n\n        // get checksum info about the block we\u0027re copying\n        ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n        DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n            checksumInfo.getChecksum());\n        // open a block receiver and check if the block does not exist\n        setCurrentBlockReceiver(getBlockReceiver(block, storageType,\n            proxyReply, proxySock.getRemoteSocketAddress().toString(),\n            proxySock.getLocalSocketAddress().toString(),\n            null, 0, 0, 0, \"\", null, datanode, remoteChecksum,\n            CachingStrategy.newDropBehind(), false, false));\n        \n        // receive a block\n        blockReceiver.receiveBlock(null, null, replyOut, null, \n            dataXceiverServer.balanceThrottler, null, true);\n        \n        // notify name node\n        final Replica r \u003d blockReceiver.getReplica();\n        datanode.notifyNamenodeReceivedBlock(\n            block, delHint, r.getStorageUuid(), r.isOnTransientStorage());\n        \n        LOG.info(\"Moved \" + block + \" from \" + peer.getRemoteAddressString()\n            + \", delHint\u003d\" + delHint);\n      }\n    } catch (IOException ioe) {\n      opStatus \u003d ERROR;\n      errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n      LOG.info(errMsg);\n      if (!IoeDuringCopyBlockOperation) {\n        // Don\u0027t double count IO errors\n        incrDatanodeNetworkErrors();\n      }\n      throw ioe;\n    } finally {\n      // receive the last byte that indicates the proxy released its thread resource\n      if (opStatus \u003d\u003d SUCCESS \u0026\u0026 proxyReply !\u003d null) {\n        try {\n          proxyReply.readChar();\n        } catch (IOException ignored) {\n        }\n      }\n      \n      // now release the thread resource\n      dataXceiverServer.balanceThrottler.release();\n      \n      // send response back\n      try {\n        sendResponse(opStatus, errMsg);\n      } catch (IOException ioe) {\n        LOG.warn(\"Error writing reply back to \" + peer.getRemoteAddressString());\n        incrDatanodeNetworkErrors();\n      }\n      IOUtils.closeStream(proxyOut);\n      IOUtils.closeStream(blockReceiver);\n      IOUtils.closeStream(proxyReply);\n      IOUtils.closeStream(replyOut);\n    }\n\n    //update metrics\n    datanode.metrics.addReplaceBlockOp(elapsed());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "d1d4e16690cc85f7f22fbead9cf596260819b561": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9710. DN can be configured to send block receipt IBRs in batches.\n",
      "commitDate": "26/02/16 3:32 PM",
      "commitName": "d1d4e16690cc85f7f22fbead9cf596260819b561",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "commitDateOld": "07/02/16 8:50 PM",
      "commitNameOld": "aea31eee78a287f251447686ba3f5bbcfe9c60a3",
      "commitAuthorOld": "Uma Maheswara Rao G",
      "daysBetweenCommits": 18.78,
      "commitsBetweenForRepo": 140,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,136 +1,137 @@\n   public void replaceBlock(final ExtendedBlock block,\n       final StorageType storageType, \n       final Token\u003cBlockTokenIdentifier\u003e blockToken,\n       final String delHint,\n       final DatanodeInfo proxySource) throws IOException {\n     updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n     DataOutputStream replyOut \u003d new DataOutputStream(getOutputStream());\n     checkAccess(replyOut, true, block, blockToken,\n         Op.REPLACE_BLOCK, BlockTokenIdentifier.AccessMode.REPLACE);\n \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n       String msg \u003d \"Not able to receive block \" + block.getBlockId() +\n           \" from \" + peer.getRemoteAddressString() + \" because threads \" +\n           \"quota is exceeded.\";\n       LOG.warn(msg);\n       sendResponse(ERROR, msg);\n       return;\n     }\n \n     Socket proxySock \u003d null;\n     DataOutputStream proxyOut \u003d null;\n     Status opStatus \u003d SUCCESS;\n     String errMsg \u003d null;\n     BlockReceiver blockReceiver \u003d null;\n     DataInputStream proxyReply \u003d null;\n     boolean IoeDuringCopyBlockOperation \u003d false;\n     try {\n       // Move the block to different storage in the same datanode\n       if (proxySource.equals(datanode.getDatanodeId())) {\n         ReplicaInfo oldReplica \u003d datanode.data.moveBlockAcrossStorage(block,\n             storageType);\n         if (oldReplica !\u003d null) {\n           LOG.info(\"Moved \" + block + \" from StorageType \"\n               + oldReplica.getVolume().getStorageType() + \" to \" + storageType);\n         }\n       } else {\n         block.setNumBytes(dataXceiverServer.estimateBlockSize);\n         // get the output stream to the proxy\n         final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Connecting to datanode \" + dnAddr);\n         }\n         InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n         proxySock \u003d datanode.newSocket();\n         NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n         proxySock.setSoTimeout(dnConf.socketTimeout);\n         proxySock.setKeepAlive(true);\n \n         OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n             dnConf.socketWriteTimeout);\n         InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n         DataEncryptionKeyFactory keyFactory \u003d\n             datanode.getDataEncryptionKeyFactoryForBlock(block);\n         IOStreamPair saslStreams \u003d datanode.saslClient.socketSend(proxySock,\n             unbufProxyOut, unbufProxyIn, keyFactory, blockToken, proxySource);\n         unbufProxyOut \u003d saslStreams.out;\n         unbufProxyIn \u003d saslStreams.in;\n         \n         proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut,\n             smallBufferSize));\n         proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n             ioFileBufferSize));\n         \n         /* send request to the proxy */\n         IoeDuringCopyBlockOperation \u003d true;\n         new Sender(proxyOut).copyBlock(block, blockToken);\n         IoeDuringCopyBlockOperation \u003d false;\n         \n         // receive the response from the proxy\n         \n         BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n             PBHelperClient.vintPrefixed(proxyReply));\n \n         String logInfo \u003d \"copy block \" + block + \" from \"\n             + proxySock.getRemoteSocketAddress();\n         DataTransferProtoUtil.checkBlockOpStatus(copyResponse, logInfo);\n \n         // get checksum info about the block we\u0027re copying\n         ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n         DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n             checksumInfo.getChecksum());\n         // open a block receiver and check if the block does not exist\n         blockReceiver \u003d getBlockReceiver(block, storageType,\n             proxyReply, proxySock.getRemoteSocketAddress().toString(),\n             proxySock.getLocalSocketAddress().toString(),\n             null, 0, 0, 0, \"\", null, datanode, remoteChecksum,\n             CachingStrategy.newDropBehind(), false, false);\n         \n         // receive a block\n         blockReceiver.receiveBlock(null, null, replyOut, null, \n             dataXceiverServer.balanceThrottler, null, true);\n         \n         // notify name node\n+        final Replica r \u003d blockReceiver.getReplica();\n         datanode.notifyNamenodeReceivedBlock(\n-            block, delHint, blockReceiver.getStorageUuid());\n+            block, delHint, r.getStorageUuid(), r.isOnTransientStorage());\n         \n         LOG.info(\"Moved \" + block + \" from \" + peer.getRemoteAddressString()\n             + \", delHint\u003d\" + delHint);\n       }\n     } catch (IOException ioe) {\n       opStatus \u003d ERROR;\n       errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n       LOG.info(errMsg);\n       if (!IoeDuringCopyBlockOperation) {\n         // Don\u0027t double count IO errors\n         incrDatanodeNetworkErrors();\n       }\n       throw ioe;\n     } finally {\n       // receive the last byte that indicates the proxy released its thread resource\n       if (opStatus \u003d\u003d SUCCESS \u0026\u0026 proxyReply !\u003d null) {\n         try {\n           proxyReply.readChar();\n         } catch (IOException ignored) {\n         }\n       }\n       \n       // now release the thread resource\n       dataXceiverServer.balanceThrottler.release();\n       \n       // send response back\n       try {\n         sendResponse(opStatus, errMsg);\n       } catch (IOException ioe) {\n         LOG.warn(\"Error writing reply back to \" + peer.getRemoteAddressString());\n         incrDatanodeNetworkErrors();\n       }\n       IOUtils.closeStream(proxyOut);\n       IOUtils.closeStream(blockReceiver);\n       IOUtils.closeStream(proxyReply);\n       IOUtils.closeStream(replyOut);\n     }\n \n     //update metrics\n     datanode.metrics.addReplaceBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void replaceBlock(final ExtendedBlock block,\n      final StorageType storageType, \n      final Token\u003cBlockTokenIdentifier\u003e blockToken,\n      final String delHint,\n      final DatanodeInfo proxySource) throws IOException {\n    updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n    DataOutputStream replyOut \u003d new DataOutputStream(getOutputStream());\n    checkAccess(replyOut, true, block, blockToken,\n        Op.REPLACE_BLOCK, BlockTokenIdentifier.AccessMode.REPLACE);\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      String msg \u003d \"Not able to receive block \" + block.getBlockId() +\n          \" from \" + peer.getRemoteAddressString() + \" because threads \" +\n          \"quota is exceeded.\";\n      LOG.warn(msg);\n      sendResponse(ERROR, msg);\n      return;\n    }\n\n    Socket proxySock \u003d null;\n    DataOutputStream proxyOut \u003d null;\n    Status opStatus \u003d SUCCESS;\n    String errMsg \u003d null;\n    BlockReceiver blockReceiver \u003d null;\n    DataInputStream proxyReply \u003d null;\n    boolean IoeDuringCopyBlockOperation \u003d false;\n    try {\n      // Move the block to different storage in the same datanode\n      if (proxySource.equals(datanode.getDatanodeId())) {\n        ReplicaInfo oldReplica \u003d datanode.data.moveBlockAcrossStorage(block,\n            storageType);\n        if (oldReplica !\u003d null) {\n          LOG.info(\"Moved \" + block + \" from StorageType \"\n              + oldReplica.getVolume().getStorageType() + \" to \" + storageType);\n        }\n      } else {\n        block.setNumBytes(dataXceiverServer.estimateBlockSize);\n        // get the output stream to the proxy\n        final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Connecting to datanode \" + dnAddr);\n        }\n        InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n        proxySock \u003d datanode.newSocket();\n        NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n        proxySock.setSoTimeout(dnConf.socketTimeout);\n        proxySock.setKeepAlive(true);\n\n        OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n            dnConf.socketWriteTimeout);\n        InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n        DataEncryptionKeyFactory keyFactory \u003d\n            datanode.getDataEncryptionKeyFactoryForBlock(block);\n        IOStreamPair saslStreams \u003d datanode.saslClient.socketSend(proxySock,\n            unbufProxyOut, unbufProxyIn, keyFactory, blockToken, proxySource);\n        unbufProxyOut \u003d saslStreams.out;\n        unbufProxyIn \u003d saslStreams.in;\n        \n        proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut,\n            smallBufferSize));\n        proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n            ioFileBufferSize));\n        \n        /* send request to the proxy */\n        IoeDuringCopyBlockOperation \u003d true;\n        new Sender(proxyOut).copyBlock(block, blockToken);\n        IoeDuringCopyBlockOperation \u003d false;\n        \n        // receive the response from the proxy\n        \n        BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n            PBHelperClient.vintPrefixed(proxyReply));\n\n        String logInfo \u003d \"copy block \" + block + \" from \"\n            + proxySock.getRemoteSocketAddress();\n        DataTransferProtoUtil.checkBlockOpStatus(copyResponse, logInfo);\n\n        // get checksum info about the block we\u0027re copying\n        ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n        DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n            checksumInfo.getChecksum());\n        // open a block receiver and check if the block does not exist\n        blockReceiver \u003d getBlockReceiver(block, storageType,\n            proxyReply, proxySock.getRemoteSocketAddress().toString(),\n            proxySock.getLocalSocketAddress().toString(),\n            null, 0, 0, 0, \"\", null, datanode, remoteChecksum,\n            CachingStrategy.newDropBehind(), false, false);\n        \n        // receive a block\n        blockReceiver.receiveBlock(null, null, replyOut, null, \n            dataXceiverServer.balanceThrottler, null, true);\n        \n        // notify name node\n        final Replica r \u003d blockReceiver.getReplica();\n        datanode.notifyNamenodeReceivedBlock(\n            block, delHint, r.getStorageUuid(), r.isOnTransientStorage());\n        \n        LOG.info(\"Moved \" + block + \" from \" + peer.getRemoteAddressString()\n            + \", delHint\u003d\" + delHint);\n      }\n    } catch (IOException ioe) {\n      opStatus \u003d ERROR;\n      errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n      LOG.info(errMsg);\n      if (!IoeDuringCopyBlockOperation) {\n        // Don\u0027t double count IO errors\n        incrDatanodeNetworkErrors();\n      }\n      throw ioe;\n    } finally {\n      // receive the last byte that indicates the proxy released its thread resource\n      if (opStatus \u003d\u003d SUCCESS \u0026\u0026 proxyReply !\u003d null) {\n        try {\n          proxyReply.readChar();\n        } catch (IOException ignored) {\n        }\n      }\n      \n      // now release the thread resource\n      dataXceiverServer.balanceThrottler.release();\n      \n      // send response back\n      try {\n        sendResponse(opStatus, errMsg);\n      } catch (IOException ioe) {\n        LOG.warn(\"Error writing reply back to \" + peer.getRemoteAddressString());\n        incrDatanodeNetworkErrors();\n      }\n      IOUtils.closeStream(proxyOut);\n      IOUtils.closeStream(blockReceiver);\n      IOUtils.closeStream(proxyReply);\n      IOUtils.closeStream(replyOut);\n    }\n\n    //update metrics\n    datanode.metrics.addReplaceBlockOp(elapsed());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "38c4c14472996562eb3d610649246770c2888c6b": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9574. Reduce client failures during datanode restart. Contributed by Kihwal Lee.\n",
      "commitDate": "08/01/16 9:13 AM",
      "commitName": "38c4c14472996562eb3d610649246770c2888c6b",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "04/01/16 2:32 PM",
      "commitNameOld": "778146eaae5b1e17928a1f26fb1e46536a6ee510",
      "commitAuthorOld": "Uma Mahesh",
      "daysBetweenCommits": 3.78,
      "commitsBetweenForRepo": 30,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,148 +1,136 @@\n   public void replaceBlock(final ExtendedBlock block,\n       final StorageType storageType, \n       final Token\u003cBlockTokenIdentifier\u003e blockToken,\n       final String delHint,\n       final DatanodeInfo proxySource) throws IOException {\n     updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n-\n-    /* read header */\n-    if (datanode.isBlockTokenEnabled) {\n-      try {\n-        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n-            BlockTokenIdentifier.AccessMode.REPLACE);\n-      } catch (InvalidToken e) {\n-        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n-            + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n-            + e.getLocalizedMessage());\n-        sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n-        return;\n-      }\n-    }\n+    DataOutputStream replyOut \u003d new DataOutputStream(getOutputStream());\n+    checkAccess(replyOut, true, block, blockToken,\n+        Op.REPLACE_BLOCK, BlockTokenIdentifier.AccessMode.REPLACE);\n \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n       String msg \u003d \"Not able to receive block \" + block.getBlockId() +\n           \" from \" + peer.getRemoteAddressString() + \" because threads \" +\n           \"quota is exceeded.\";\n       LOG.warn(msg);\n       sendResponse(ERROR, msg);\n       return;\n     }\n \n     Socket proxySock \u003d null;\n     DataOutputStream proxyOut \u003d null;\n     Status opStatus \u003d SUCCESS;\n     String errMsg \u003d null;\n     BlockReceiver blockReceiver \u003d null;\n     DataInputStream proxyReply \u003d null;\n-    DataOutputStream replyOut \u003d new DataOutputStream(getOutputStream());\n     boolean IoeDuringCopyBlockOperation \u003d false;\n     try {\n       // Move the block to different storage in the same datanode\n       if (proxySource.equals(datanode.getDatanodeId())) {\n         ReplicaInfo oldReplica \u003d datanode.data.moveBlockAcrossStorage(block,\n             storageType);\n         if (oldReplica !\u003d null) {\n           LOG.info(\"Moved \" + block + \" from StorageType \"\n               + oldReplica.getVolume().getStorageType() + \" to \" + storageType);\n         }\n       } else {\n         block.setNumBytes(dataXceiverServer.estimateBlockSize);\n         // get the output stream to the proxy\n         final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Connecting to datanode \" + dnAddr);\n         }\n         InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n         proxySock \u003d datanode.newSocket();\n         NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n         proxySock.setSoTimeout(dnConf.socketTimeout);\n         proxySock.setKeepAlive(true);\n \n         OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n             dnConf.socketWriteTimeout);\n         InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n         DataEncryptionKeyFactory keyFactory \u003d\n             datanode.getDataEncryptionKeyFactoryForBlock(block);\n         IOStreamPair saslStreams \u003d datanode.saslClient.socketSend(proxySock,\n             unbufProxyOut, unbufProxyIn, keyFactory, blockToken, proxySource);\n         unbufProxyOut \u003d saslStreams.out;\n         unbufProxyIn \u003d saslStreams.in;\n         \n         proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut,\n             smallBufferSize));\n         proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n             ioFileBufferSize));\n         \n         /* send request to the proxy */\n         IoeDuringCopyBlockOperation \u003d true;\n         new Sender(proxyOut).copyBlock(block, blockToken);\n         IoeDuringCopyBlockOperation \u003d false;\n         \n         // receive the response from the proxy\n         \n         BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n             PBHelperClient.vintPrefixed(proxyReply));\n \n         String logInfo \u003d \"copy block \" + block + \" from \"\n             + proxySock.getRemoteSocketAddress();\n         DataTransferProtoUtil.checkBlockOpStatus(copyResponse, logInfo);\n \n         // get checksum info about the block we\u0027re copying\n         ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n         DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n             checksumInfo.getChecksum());\n         // open a block receiver and check if the block does not exist\n         blockReceiver \u003d getBlockReceiver(block, storageType,\n             proxyReply, proxySock.getRemoteSocketAddress().toString(),\n             proxySock.getLocalSocketAddress().toString(),\n             null, 0, 0, 0, \"\", null, datanode, remoteChecksum,\n             CachingStrategy.newDropBehind(), false, false);\n         \n         // receive a block\n         blockReceiver.receiveBlock(null, null, replyOut, null, \n             dataXceiverServer.balanceThrottler, null, true);\n         \n         // notify name node\n         datanode.notifyNamenodeReceivedBlock(\n             block, delHint, blockReceiver.getStorageUuid());\n         \n         LOG.info(\"Moved \" + block + \" from \" + peer.getRemoteAddressString()\n             + \", delHint\u003d\" + delHint);\n       }\n     } catch (IOException ioe) {\n       opStatus \u003d ERROR;\n       errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n       LOG.info(errMsg);\n       if (!IoeDuringCopyBlockOperation) {\n         // Don\u0027t double count IO errors\n         incrDatanodeNetworkErrors();\n       }\n       throw ioe;\n     } finally {\n       // receive the last byte that indicates the proxy released its thread resource\n       if (opStatus \u003d\u003d SUCCESS \u0026\u0026 proxyReply !\u003d null) {\n         try {\n           proxyReply.readChar();\n         } catch (IOException ignored) {\n         }\n       }\n       \n       // now release the thread resource\n       dataXceiverServer.balanceThrottler.release();\n       \n       // send response back\n       try {\n         sendResponse(opStatus, errMsg);\n       } catch (IOException ioe) {\n         LOG.warn(\"Error writing reply back to \" + peer.getRemoteAddressString());\n         incrDatanodeNetworkErrors();\n       }\n       IOUtils.closeStream(proxyOut);\n       IOUtils.closeStream(blockReceiver);\n       IOUtils.closeStream(proxyReply);\n       IOUtils.closeStream(replyOut);\n     }\n \n     //update metrics\n     datanode.metrics.addReplaceBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void replaceBlock(final ExtendedBlock block,\n      final StorageType storageType, \n      final Token\u003cBlockTokenIdentifier\u003e blockToken,\n      final String delHint,\n      final DatanodeInfo proxySource) throws IOException {\n    updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n    DataOutputStream replyOut \u003d new DataOutputStream(getOutputStream());\n    checkAccess(replyOut, true, block, blockToken,\n        Op.REPLACE_BLOCK, BlockTokenIdentifier.AccessMode.REPLACE);\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      String msg \u003d \"Not able to receive block \" + block.getBlockId() +\n          \" from \" + peer.getRemoteAddressString() + \" because threads \" +\n          \"quota is exceeded.\";\n      LOG.warn(msg);\n      sendResponse(ERROR, msg);\n      return;\n    }\n\n    Socket proxySock \u003d null;\n    DataOutputStream proxyOut \u003d null;\n    Status opStatus \u003d SUCCESS;\n    String errMsg \u003d null;\n    BlockReceiver blockReceiver \u003d null;\n    DataInputStream proxyReply \u003d null;\n    boolean IoeDuringCopyBlockOperation \u003d false;\n    try {\n      // Move the block to different storage in the same datanode\n      if (proxySource.equals(datanode.getDatanodeId())) {\n        ReplicaInfo oldReplica \u003d datanode.data.moveBlockAcrossStorage(block,\n            storageType);\n        if (oldReplica !\u003d null) {\n          LOG.info(\"Moved \" + block + \" from StorageType \"\n              + oldReplica.getVolume().getStorageType() + \" to \" + storageType);\n        }\n      } else {\n        block.setNumBytes(dataXceiverServer.estimateBlockSize);\n        // get the output stream to the proxy\n        final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Connecting to datanode \" + dnAddr);\n        }\n        InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n        proxySock \u003d datanode.newSocket();\n        NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n        proxySock.setSoTimeout(dnConf.socketTimeout);\n        proxySock.setKeepAlive(true);\n\n        OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n            dnConf.socketWriteTimeout);\n        InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n        DataEncryptionKeyFactory keyFactory \u003d\n            datanode.getDataEncryptionKeyFactoryForBlock(block);\n        IOStreamPair saslStreams \u003d datanode.saslClient.socketSend(proxySock,\n            unbufProxyOut, unbufProxyIn, keyFactory, blockToken, proxySource);\n        unbufProxyOut \u003d saslStreams.out;\n        unbufProxyIn \u003d saslStreams.in;\n        \n        proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut,\n            smallBufferSize));\n        proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n            ioFileBufferSize));\n        \n        /* send request to the proxy */\n        IoeDuringCopyBlockOperation \u003d true;\n        new Sender(proxyOut).copyBlock(block, blockToken);\n        IoeDuringCopyBlockOperation \u003d false;\n        \n        // receive the response from the proxy\n        \n        BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n            PBHelperClient.vintPrefixed(proxyReply));\n\n        String logInfo \u003d \"copy block \" + block + \" from \"\n            + proxySock.getRemoteSocketAddress();\n        DataTransferProtoUtil.checkBlockOpStatus(copyResponse, logInfo);\n\n        // get checksum info about the block we\u0027re copying\n        ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n        DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n            checksumInfo.getChecksum());\n        // open a block receiver and check if the block does not exist\n        blockReceiver \u003d getBlockReceiver(block, storageType,\n            proxyReply, proxySock.getRemoteSocketAddress().toString(),\n            proxySock.getLocalSocketAddress().toString(),\n            null, 0, 0, 0, \"\", null, datanode, remoteChecksum,\n            CachingStrategy.newDropBehind(), false, false);\n        \n        // receive a block\n        blockReceiver.receiveBlock(null, null, replyOut, null, \n            dataXceiverServer.balanceThrottler, null, true);\n        \n        // notify name node\n        datanode.notifyNamenodeReceivedBlock(\n            block, delHint, blockReceiver.getStorageUuid());\n        \n        LOG.info(\"Moved \" + block + \" from \" + peer.getRemoteAddressString()\n            + \", delHint\u003d\" + delHint);\n      }\n    } catch (IOException ioe) {\n      opStatus \u003d ERROR;\n      errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n      LOG.info(errMsg);\n      if (!IoeDuringCopyBlockOperation) {\n        // Don\u0027t double count IO errors\n        incrDatanodeNetworkErrors();\n      }\n      throw ioe;\n    } finally {\n      // receive the last byte that indicates the proxy released its thread resource\n      if (opStatus \u003d\u003d SUCCESS \u0026\u0026 proxyReply !\u003d null) {\n        try {\n          proxyReply.readChar();\n        } catch (IOException ignored) {\n        }\n      }\n      \n      // now release the thread resource\n      dataXceiverServer.balanceThrottler.release();\n      \n      // send response back\n      try {\n        sendResponse(opStatus, errMsg);\n      } catch (IOException ioe) {\n        LOG.warn(\"Error writing reply back to \" + peer.getRemoteAddressString());\n        incrDatanodeNetworkErrors();\n      }\n      IOUtils.closeStream(proxyOut);\n      IOUtils.closeStream(blockReceiver);\n      IOUtils.closeStream(proxyReply);\n      IOUtils.closeStream(replyOut);\n    }\n\n    //update metrics\n    datanode.metrics.addReplaceBlockOp(elapsed());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "49949a4bb03aa81cbb9115e91ab1c61cc6dc8a62": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8894. Set SO_KEEPALIVE on DN server sockets. Contributed by Kanaka Kumar Avvaru.\n",
      "commitDate": "15/12/15 2:38 PM",
      "commitName": "49949a4bb03aa81cbb9115e91ab1c61cc6dc8a62",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "22/11/15 3:54 PM",
      "commitNameOld": "176ff5ce90f2cbcd8342016d0f5570337d2ff79f",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 22.95,
      "commitsBetweenForRepo": 158,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,147 +1,148 @@\n   public void replaceBlock(final ExtendedBlock block,\n       final StorageType storageType, \n       final Token\u003cBlockTokenIdentifier\u003e blockToken,\n       final String delHint,\n       final DatanodeInfo proxySource) throws IOException {\n     updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n \n     /* read header */\n     if (datanode.isBlockTokenEnabled) {\n       try {\n         datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n             BlockTokenIdentifier.AccessMode.REPLACE);\n       } catch (InvalidToken e) {\n         LOG.warn(\"Invalid access token in request from \" + remoteAddress\n             + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n             + e.getLocalizedMessage());\n         sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n         return;\n       }\n     }\n \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n       String msg \u003d \"Not able to receive block \" + block.getBlockId() +\n           \" from \" + peer.getRemoteAddressString() + \" because threads \" +\n           \"quota is exceeded.\";\n       LOG.warn(msg);\n       sendResponse(ERROR, msg);\n       return;\n     }\n \n     Socket proxySock \u003d null;\n     DataOutputStream proxyOut \u003d null;\n     Status opStatus \u003d SUCCESS;\n     String errMsg \u003d null;\n     BlockReceiver blockReceiver \u003d null;\n     DataInputStream proxyReply \u003d null;\n     DataOutputStream replyOut \u003d new DataOutputStream(getOutputStream());\n     boolean IoeDuringCopyBlockOperation \u003d false;\n     try {\n       // Move the block to different storage in the same datanode\n       if (proxySource.equals(datanode.getDatanodeId())) {\n         ReplicaInfo oldReplica \u003d datanode.data.moveBlockAcrossStorage(block,\n             storageType);\n         if (oldReplica !\u003d null) {\n           LOG.info(\"Moved \" + block + \" from StorageType \"\n               + oldReplica.getVolume().getStorageType() + \" to \" + storageType);\n         }\n       } else {\n         block.setNumBytes(dataXceiverServer.estimateBlockSize);\n         // get the output stream to the proxy\n         final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Connecting to datanode \" + dnAddr);\n         }\n         InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n         proxySock \u003d datanode.newSocket();\n         NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n         proxySock.setSoTimeout(dnConf.socketTimeout);\n-        \n+        proxySock.setKeepAlive(true);\n+\n         OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n             dnConf.socketWriteTimeout);\n         InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n         DataEncryptionKeyFactory keyFactory \u003d\n             datanode.getDataEncryptionKeyFactoryForBlock(block);\n         IOStreamPair saslStreams \u003d datanode.saslClient.socketSend(proxySock,\n             unbufProxyOut, unbufProxyIn, keyFactory, blockToken, proxySource);\n         unbufProxyOut \u003d saslStreams.out;\n         unbufProxyIn \u003d saslStreams.in;\n         \n         proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut,\n             smallBufferSize));\n         proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n             ioFileBufferSize));\n         \n         /* send request to the proxy */\n         IoeDuringCopyBlockOperation \u003d true;\n         new Sender(proxyOut).copyBlock(block, blockToken);\n         IoeDuringCopyBlockOperation \u003d false;\n         \n         // receive the response from the proxy\n         \n         BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n             PBHelperClient.vintPrefixed(proxyReply));\n \n         String logInfo \u003d \"copy block \" + block + \" from \"\n             + proxySock.getRemoteSocketAddress();\n         DataTransferProtoUtil.checkBlockOpStatus(copyResponse, logInfo);\n \n         // get checksum info about the block we\u0027re copying\n         ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n         DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n             checksumInfo.getChecksum());\n         // open a block receiver and check if the block does not exist\n         blockReceiver \u003d getBlockReceiver(block, storageType,\n             proxyReply, proxySock.getRemoteSocketAddress().toString(),\n             proxySock.getLocalSocketAddress().toString(),\n             null, 0, 0, 0, \"\", null, datanode, remoteChecksum,\n             CachingStrategy.newDropBehind(), false, false);\n         \n         // receive a block\n         blockReceiver.receiveBlock(null, null, replyOut, null, \n             dataXceiverServer.balanceThrottler, null, true);\n         \n         // notify name node\n         datanode.notifyNamenodeReceivedBlock(\n             block, delHint, blockReceiver.getStorageUuid());\n         \n         LOG.info(\"Moved \" + block + \" from \" + peer.getRemoteAddressString()\n             + \", delHint\u003d\" + delHint);\n       }\n     } catch (IOException ioe) {\n       opStatus \u003d ERROR;\n       errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n       LOG.info(errMsg);\n       if (!IoeDuringCopyBlockOperation) {\n         // Don\u0027t double count IO errors\n         incrDatanodeNetworkErrors();\n       }\n       throw ioe;\n     } finally {\n       // receive the last byte that indicates the proxy released its thread resource\n       if (opStatus \u003d\u003d SUCCESS \u0026\u0026 proxyReply !\u003d null) {\n         try {\n           proxyReply.readChar();\n         } catch (IOException ignored) {\n         }\n       }\n       \n       // now release the thread resource\n       dataXceiverServer.balanceThrottler.release();\n       \n       // send response back\n       try {\n         sendResponse(opStatus, errMsg);\n       } catch (IOException ioe) {\n         LOG.warn(\"Error writing reply back to \" + peer.getRemoteAddressString());\n         incrDatanodeNetworkErrors();\n       }\n       IOUtils.closeStream(proxyOut);\n       IOUtils.closeStream(blockReceiver);\n       IOUtils.closeStream(proxyReply);\n       IOUtils.closeStream(replyOut);\n     }\n \n     //update metrics\n     datanode.metrics.addReplaceBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void replaceBlock(final ExtendedBlock block,\n      final StorageType storageType, \n      final Token\u003cBlockTokenIdentifier\u003e blockToken,\n      final String delHint,\n      final DatanodeInfo proxySource) throws IOException {\n    updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n\n    /* read header */\n    if (datanode.isBlockTokenEnabled) {\n      try {\n        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n            BlockTokenIdentifier.AccessMode.REPLACE);\n      } catch (InvalidToken e) {\n        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n            + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n            + e.getLocalizedMessage());\n        sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n        return;\n      }\n    }\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      String msg \u003d \"Not able to receive block \" + block.getBlockId() +\n          \" from \" + peer.getRemoteAddressString() + \" because threads \" +\n          \"quota is exceeded.\";\n      LOG.warn(msg);\n      sendResponse(ERROR, msg);\n      return;\n    }\n\n    Socket proxySock \u003d null;\n    DataOutputStream proxyOut \u003d null;\n    Status opStatus \u003d SUCCESS;\n    String errMsg \u003d null;\n    BlockReceiver blockReceiver \u003d null;\n    DataInputStream proxyReply \u003d null;\n    DataOutputStream replyOut \u003d new DataOutputStream(getOutputStream());\n    boolean IoeDuringCopyBlockOperation \u003d false;\n    try {\n      // Move the block to different storage in the same datanode\n      if (proxySource.equals(datanode.getDatanodeId())) {\n        ReplicaInfo oldReplica \u003d datanode.data.moveBlockAcrossStorage(block,\n            storageType);\n        if (oldReplica !\u003d null) {\n          LOG.info(\"Moved \" + block + \" from StorageType \"\n              + oldReplica.getVolume().getStorageType() + \" to \" + storageType);\n        }\n      } else {\n        block.setNumBytes(dataXceiverServer.estimateBlockSize);\n        // get the output stream to the proxy\n        final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Connecting to datanode \" + dnAddr);\n        }\n        InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n        proxySock \u003d datanode.newSocket();\n        NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n        proxySock.setSoTimeout(dnConf.socketTimeout);\n        proxySock.setKeepAlive(true);\n\n        OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n            dnConf.socketWriteTimeout);\n        InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n        DataEncryptionKeyFactory keyFactory \u003d\n            datanode.getDataEncryptionKeyFactoryForBlock(block);\n        IOStreamPair saslStreams \u003d datanode.saslClient.socketSend(proxySock,\n            unbufProxyOut, unbufProxyIn, keyFactory, blockToken, proxySource);\n        unbufProxyOut \u003d saslStreams.out;\n        unbufProxyIn \u003d saslStreams.in;\n        \n        proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut,\n            smallBufferSize));\n        proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n            ioFileBufferSize));\n        \n        /* send request to the proxy */\n        IoeDuringCopyBlockOperation \u003d true;\n        new Sender(proxyOut).copyBlock(block, blockToken);\n        IoeDuringCopyBlockOperation \u003d false;\n        \n        // receive the response from the proxy\n        \n        BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n            PBHelperClient.vintPrefixed(proxyReply));\n\n        String logInfo \u003d \"copy block \" + block + \" from \"\n            + proxySock.getRemoteSocketAddress();\n        DataTransferProtoUtil.checkBlockOpStatus(copyResponse, logInfo);\n\n        // get checksum info about the block we\u0027re copying\n        ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n        DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n            checksumInfo.getChecksum());\n        // open a block receiver and check if the block does not exist\n        blockReceiver \u003d getBlockReceiver(block, storageType,\n            proxyReply, proxySock.getRemoteSocketAddress().toString(),\n            proxySock.getLocalSocketAddress().toString(),\n            null, 0, 0, 0, \"\", null, datanode, remoteChecksum,\n            CachingStrategy.newDropBehind(), false, false);\n        \n        // receive a block\n        blockReceiver.receiveBlock(null, null, replyOut, null, \n            dataXceiverServer.balanceThrottler, null, true);\n        \n        // notify name node\n        datanode.notifyNamenodeReceivedBlock(\n            block, delHint, blockReceiver.getStorageUuid());\n        \n        LOG.info(\"Moved \" + block + \" from \" + peer.getRemoteAddressString()\n            + \", delHint\u003d\" + delHint);\n      }\n    } catch (IOException ioe) {\n      opStatus \u003d ERROR;\n      errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n      LOG.info(errMsg);\n      if (!IoeDuringCopyBlockOperation) {\n        // Don\u0027t double count IO errors\n        incrDatanodeNetworkErrors();\n      }\n      throw ioe;\n    } finally {\n      // receive the last byte that indicates the proxy released its thread resource\n      if (opStatus \u003d\u003d SUCCESS \u0026\u0026 proxyReply !\u003d null) {\n        try {\n          proxyReply.readChar();\n        } catch (IOException ignored) {\n        }\n      }\n      \n      // now release the thread resource\n      dataXceiverServer.balanceThrottler.release();\n      \n      // send response back\n      try {\n        sendResponse(opStatus, errMsg);\n      } catch (IOException ioe) {\n        LOG.warn(\"Error writing reply back to \" + peer.getRemoteAddressString());\n        incrDatanodeNetworkErrors();\n      }\n      IOUtils.closeStream(proxyOut);\n      IOUtils.closeStream(blockReceiver);\n      IOUtils.closeStream(proxyReply);\n      IOUtils.closeStream(replyOut);\n    }\n\n    //update metrics\n    datanode.metrics.addReplaceBlockOp(elapsed());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "490bb5ebd6c6d6f9c08fcad167f976687fc3aa42": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8934. Move ShortCircuitShm to hdfs-client. Contributed by Mingliang Liu.\n",
      "commitDate": "22/08/15 1:31 PM",
      "commitName": "490bb5ebd6c6d6f9c08fcad167f976687fc3aa42",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "19/08/15 11:28 AM",
      "commitNameOld": "3aac4758b007a56e3d66998d457b2156effca528",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 3.09,
      "commitsBetweenForRepo": 18,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,147 +1,147 @@\n   public void replaceBlock(final ExtendedBlock block,\n       final StorageType storageType, \n       final Token\u003cBlockTokenIdentifier\u003e blockToken,\n       final String delHint,\n       final DatanodeInfo proxySource) throws IOException {\n     updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n \n     /* read header */\n     if (datanode.isBlockTokenEnabled) {\n       try {\n         datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n             BlockTokenIdentifier.AccessMode.REPLACE);\n       } catch (InvalidToken e) {\n         LOG.warn(\"Invalid access token in request from \" + remoteAddress\n             + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n             + e.getLocalizedMessage());\n         sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n         return;\n       }\n     }\n \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n       String msg \u003d \"Not able to receive block \" + block.getBlockId() +\n           \" from \" + peer.getRemoteAddressString() + \" because threads \" +\n           \"quota is exceeded.\";\n       LOG.warn(msg);\n       sendResponse(ERROR, msg);\n       return;\n     }\n \n     Socket proxySock \u003d null;\n     DataOutputStream proxyOut \u003d null;\n     Status opStatus \u003d SUCCESS;\n     String errMsg \u003d null;\n     BlockReceiver blockReceiver \u003d null;\n     DataInputStream proxyReply \u003d null;\n     DataOutputStream replyOut \u003d new DataOutputStream(getOutputStream());\n     boolean IoeDuringCopyBlockOperation \u003d false;\n     try {\n       // Move the block to different storage in the same datanode\n       if (proxySource.equals(datanode.getDatanodeId())) {\n         ReplicaInfo oldReplica \u003d datanode.data.moveBlockAcrossStorage(block,\n             storageType);\n         if (oldReplica !\u003d null) {\n           LOG.info(\"Moved \" + block + \" from StorageType \"\n               + oldReplica.getVolume().getStorageType() + \" to \" + storageType);\n         }\n       } else {\n         block.setNumBytes(dataXceiverServer.estimateBlockSize);\n         // get the output stream to the proxy\n         final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Connecting to datanode \" + dnAddr);\n         }\n         InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n         proxySock \u003d datanode.newSocket();\n         NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n         proxySock.setSoTimeout(dnConf.socketTimeout);\n         \n         OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n             dnConf.socketWriteTimeout);\n         InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n         DataEncryptionKeyFactory keyFactory \u003d\n             datanode.getDataEncryptionKeyFactoryForBlock(block);\n         IOStreamPair saslStreams \u003d datanode.saslClient.socketSend(proxySock,\n             unbufProxyOut, unbufProxyIn, keyFactory, blockToken, proxySource);\n         unbufProxyOut \u003d saslStreams.out;\n         unbufProxyIn \u003d saslStreams.in;\n         \n         proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut,\n             smallBufferSize));\n         proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n             ioFileBufferSize));\n         \n         /* send request to the proxy */\n         IoeDuringCopyBlockOperation \u003d true;\n         new Sender(proxyOut).copyBlock(block, blockToken);\n         IoeDuringCopyBlockOperation \u003d false;\n         \n         // receive the response from the proxy\n         \n         BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n-            PBHelper.vintPrefixed(proxyReply));\n-        \n+            PBHelperClient.vintPrefixed(proxyReply));\n+\n         String logInfo \u003d \"copy block \" + block + \" from \"\n             + proxySock.getRemoteSocketAddress();\n         DataTransferProtoUtil.checkBlockOpStatus(copyResponse, logInfo);\n \n         // get checksum info about the block we\u0027re copying\n         ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n         DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n             checksumInfo.getChecksum());\n         // open a block receiver and check if the block does not exist\n         blockReceiver \u003d getBlockReceiver(block, storageType,\n             proxyReply, proxySock.getRemoteSocketAddress().toString(),\n             proxySock.getLocalSocketAddress().toString(),\n             null, 0, 0, 0, \"\", null, datanode, remoteChecksum,\n             CachingStrategy.newDropBehind(), false, false);\n         \n         // receive a block\n         blockReceiver.receiveBlock(null, null, replyOut, null, \n             dataXceiverServer.balanceThrottler, null, true);\n         \n         // notify name node\n         datanode.notifyNamenodeReceivedBlock(\n             block, delHint, blockReceiver.getStorageUuid());\n         \n         LOG.info(\"Moved \" + block + \" from \" + peer.getRemoteAddressString()\n             + \", delHint\u003d\" + delHint);\n       }\n     } catch (IOException ioe) {\n       opStatus \u003d ERROR;\n       errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n       LOG.info(errMsg);\n       if (!IoeDuringCopyBlockOperation) {\n         // Don\u0027t double count IO errors\n         incrDatanodeNetworkErrors();\n       }\n       throw ioe;\n     } finally {\n       // receive the last byte that indicates the proxy released its thread resource\n       if (opStatus \u003d\u003d SUCCESS \u0026\u0026 proxyReply !\u003d null) {\n         try {\n           proxyReply.readChar();\n         } catch (IOException ignored) {\n         }\n       }\n       \n       // now release the thread resource\n       dataXceiverServer.balanceThrottler.release();\n       \n       // send response back\n       try {\n         sendResponse(opStatus, errMsg);\n       } catch (IOException ioe) {\n         LOG.warn(\"Error writing reply back to \" + peer.getRemoteAddressString());\n         incrDatanodeNetworkErrors();\n       }\n       IOUtils.closeStream(proxyOut);\n       IOUtils.closeStream(blockReceiver);\n       IOUtils.closeStream(proxyReply);\n       IOUtils.closeStream(replyOut);\n     }\n \n     //update metrics\n     datanode.metrics.addReplaceBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void replaceBlock(final ExtendedBlock block,\n      final StorageType storageType, \n      final Token\u003cBlockTokenIdentifier\u003e blockToken,\n      final String delHint,\n      final DatanodeInfo proxySource) throws IOException {\n    updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n\n    /* read header */\n    if (datanode.isBlockTokenEnabled) {\n      try {\n        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n            BlockTokenIdentifier.AccessMode.REPLACE);\n      } catch (InvalidToken e) {\n        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n            + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n            + e.getLocalizedMessage());\n        sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n        return;\n      }\n    }\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      String msg \u003d \"Not able to receive block \" + block.getBlockId() +\n          \" from \" + peer.getRemoteAddressString() + \" because threads \" +\n          \"quota is exceeded.\";\n      LOG.warn(msg);\n      sendResponse(ERROR, msg);\n      return;\n    }\n\n    Socket proxySock \u003d null;\n    DataOutputStream proxyOut \u003d null;\n    Status opStatus \u003d SUCCESS;\n    String errMsg \u003d null;\n    BlockReceiver blockReceiver \u003d null;\n    DataInputStream proxyReply \u003d null;\n    DataOutputStream replyOut \u003d new DataOutputStream(getOutputStream());\n    boolean IoeDuringCopyBlockOperation \u003d false;\n    try {\n      // Move the block to different storage in the same datanode\n      if (proxySource.equals(datanode.getDatanodeId())) {\n        ReplicaInfo oldReplica \u003d datanode.data.moveBlockAcrossStorage(block,\n            storageType);\n        if (oldReplica !\u003d null) {\n          LOG.info(\"Moved \" + block + \" from StorageType \"\n              + oldReplica.getVolume().getStorageType() + \" to \" + storageType);\n        }\n      } else {\n        block.setNumBytes(dataXceiverServer.estimateBlockSize);\n        // get the output stream to the proxy\n        final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Connecting to datanode \" + dnAddr);\n        }\n        InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n        proxySock \u003d datanode.newSocket();\n        NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n        proxySock.setSoTimeout(dnConf.socketTimeout);\n        \n        OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n            dnConf.socketWriteTimeout);\n        InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n        DataEncryptionKeyFactory keyFactory \u003d\n            datanode.getDataEncryptionKeyFactoryForBlock(block);\n        IOStreamPair saslStreams \u003d datanode.saslClient.socketSend(proxySock,\n            unbufProxyOut, unbufProxyIn, keyFactory, blockToken, proxySource);\n        unbufProxyOut \u003d saslStreams.out;\n        unbufProxyIn \u003d saslStreams.in;\n        \n        proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut,\n            smallBufferSize));\n        proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n            ioFileBufferSize));\n        \n        /* send request to the proxy */\n        IoeDuringCopyBlockOperation \u003d true;\n        new Sender(proxyOut).copyBlock(block, blockToken);\n        IoeDuringCopyBlockOperation \u003d false;\n        \n        // receive the response from the proxy\n        \n        BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n            PBHelperClient.vintPrefixed(proxyReply));\n\n        String logInfo \u003d \"copy block \" + block + \" from \"\n            + proxySock.getRemoteSocketAddress();\n        DataTransferProtoUtil.checkBlockOpStatus(copyResponse, logInfo);\n\n        // get checksum info about the block we\u0027re copying\n        ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n        DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n            checksumInfo.getChecksum());\n        // open a block receiver and check if the block does not exist\n        blockReceiver \u003d getBlockReceiver(block, storageType,\n            proxyReply, proxySock.getRemoteSocketAddress().toString(),\n            proxySock.getLocalSocketAddress().toString(),\n            null, 0, 0, 0, \"\", null, datanode, remoteChecksum,\n            CachingStrategy.newDropBehind(), false, false);\n        \n        // receive a block\n        blockReceiver.receiveBlock(null, null, replyOut, null, \n            dataXceiverServer.balanceThrottler, null, true);\n        \n        // notify name node\n        datanode.notifyNamenodeReceivedBlock(\n            block, delHint, blockReceiver.getStorageUuid());\n        \n        LOG.info(\"Moved \" + block + \" from \" + peer.getRemoteAddressString()\n            + \", delHint\u003d\" + delHint);\n      }\n    } catch (IOException ioe) {\n      opStatus \u003d ERROR;\n      errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n      LOG.info(errMsg);\n      if (!IoeDuringCopyBlockOperation) {\n        // Don\u0027t double count IO errors\n        incrDatanodeNetworkErrors();\n      }\n      throw ioe;\n    } finally {\n      // receive the last byte that indicates the proxy released its thread resource\n      if (opStatus \u003d\u003d SUCCESS \u0026\u0026 proxyReply !\u003d null) {\n        try {\n          proxyReply.readChar();\n        } catch (IOException ignored) {\n        }\n      }\n      \n      // now release the thread resource\n      dataXceiverServer.balanceThrottler.release();\n      \n      // send response back\n      try {\n        sendResponse(opStatus, errMsg);\n      } catch (IOException ioe) {\n        LOG.warn(\"Error writing reply back to \" + peer.getRemoteAddressString());\n        incrDatanodeNetworkErrors();\n      }\n      IOUtils.closeStream(proxyOut);\n      IOUtils.closeStream(blockReceiver);\n      IOUtils.closeStream(proxyReply);\n      IOUtils.closeStream(replyOut);\n    }\n\n    //update metrics\n    datanode.metrics.addReplaceBlockOp(elapsed());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "88d8736ddeff10a03acaa99a9a0ee99dcfabe590": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7192. DN should ignore lazyPersist hint if the writer is not local. (Contributed by Arpit Agarwal)\n",
      "commitDate": "30/07/15 1:16 PM",
      "commitName": "88d8736ddeff10a03acaa99a9a0ee99dcfabe590",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "05/05/15 3:41 PM",
      "commitNameOld": "4da8490b512a33a255ed27309860859388d7c168",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 85.9,
      "commitsBetweenForRepo": 672,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,147 +1,147 @@\n   public void replaceBlock(final ExtendedBlock block,\n       final StorageType storageType, \n       final Token\u003cBlockTokenIdentifier\u003e blockToken,\n       final String delHint,\n       final DatanodeInfo proxySource) throws IOException {\n     updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n \n     /* read header */\n     if (datanode.isBlockTokenEnabled) {\n       try {\n         datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n             BlockTokenIdentifier.AccessMode.REPLACE);\n       } catch (InvalidToken e) {\n         LOG.warn(\"Invalid access token in request from \" + remoteAddress\n             + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n             + e.getLocalizedMessage());\n         sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n         return;\n       }\n     }\n \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n       String msg \u003d \"Not able to receive block \" + block.getBlockId() +\n           \" from \" + peer.getRemoteAddressString() + \" because threads \" +\n           \"quota is exceeded.\";\n       LOG.warn(msg);\n       sendResponse(ERROR, msg);\n       return;\n     }\n \n     Socket proxySock \u003d null;\n     DataOutputStream proxyOut \u003d null;\n     Status opStatus \u003d SUCCESS;\n     String errMsg \u003d null;\n     BlockReceiver blockReceiver \u003d null;\n     DataInputStream proxyReply \u003d null;\n     DataOutputStream replyOut \u003d new DataOutputStream(getOutputStream());\n     boolean IoeDuringCopyBlockOperation \u003d false;\n     try {\n       // Move the block to different storage in the same datanode\n       if (proxySource.equals(datanode.getDatanodeId())) {\n         ReplicaInfo oldReplica \u003d datanode.data.moveBlockAcrossStorage(block,\n             storageType);\n         if (oldReplica !\u003d null) {\n           LOG.info(\"Moved \" + block + \" from StorageType \"\n               + oldReplica.getVolume().getStorageType() + \" to \" + storageType);\n         }\n       } else {\n         block.setNumBytes(dataXceiverServer.estimateBlockSize);\n         // get the output stream to the proxy\n         final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Connecting to datanode \" + dnAddr);\n         }\n         InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n         proxySock \u003d datanode.newSocket();\n         NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n         proxySock.setSoTimeout(dnConf.socketTimeout);\n         \n         OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n             dnConf.socketWriteTimeout);\n         InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n         DataEncryptionKeyFactory keyFactory \u003d\n             datanode.getDataEncryptionKeyFactoryForBlock(block);\n         IOStreamPair saslStreams \u003d datanode.saslClient.socketSend(proxySock,\n             unbufProxyOut, unbufProxyIn, keyFactory, blockToken, proxySource);\n         unbufProxyOut \u003d saslStreams.out;\n         unbufProxyIn \u003d saslStreams.in;\n         \n         proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut,\n             smallBufferSize));\n         proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n             ioFileBufferSize));\n         \n         /* send request to the proxy */\n         IoeDuringCopyBlockOperation \u003d true;\n         new Sender(proxyOut).copyBlock(block, blockToken);\n         IoeDuringCopyBlockOperation \u003d false;\n         \n         // receive the response from the proxy\n         \n         BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n             PBHelper.vintPrefixed(proxyReply));\n         \n         String logInfo \u003d \"copy block \" + block + \" from \"\n             + proxySock.getRemoteSocketAddress();\n         DataTransferProtoUtil.checkBlockOpStatus(copyResponse, logInfo);\n \n         // get checksum info about the block we\u0027re copying\n         ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n         DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n             checksumInfo.getChecksum());\n         // open a block receiver and check if the block does not exist\n-        blockReceiver \u003d new BlockReceiver(block, storageType,\n+        blockReceiver \u003d getBlockReceiver(block, storageType,\n             proxyReply, proxySock.getRemoteSocketAddress().toString(),\n             proxySock.getLocalSocketAddress().toString(),\n             null, 0, 0, 0, \"\", null, datanode, remoteChecksum,\n             CachingStrategy.newDropBehind(), false, false);\n         \n         // receive a block\n         blockReceiver.receiveBlock(null, null, replyOut, null, \n             dataXceiverServer.balanceThrottler, null, true);\n         \n         // notify name node\n         datanode.notifyNamenodeReceivedBlock(\n             block, delHint, blockReceiver.getStorageUuid());\n         \n         LOG.info(\"Moved \" + block + \" from \" + peer.getRemoteAddressString()\n             + \", delHint\u003d\" + delHint);\n       }\n     } catch (IOException ioe) {\n       opStatus \u003d ERROR;\n       errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n       LOG.info(errMsg);\n       if (!IoeDuringCopyBlockOperation) {\n         // Don\u0027t double count IO errors\n         incrDatanodeNetworkErrors();\n       }\n       throw ioe;\n     } finally {\n       // receive the last byte that indicates the proxy released its thread resource\n       if (opStatus \u003d\u003d SUCCESS \u0026\u0026 proxyReply !\u003d null) {\n         try {\n           proxyReply.readChar();\n         } catch (IOException ignored) {\n         }\n       }\n       \n       // now release the thread resource\n       dataXceiverServer.balanceThrottler.release();\n       \n       // send response back\n       try {\n         sendResponse(opStatus, errMsg);\n       } catch (IOException ioe) {\n         LOG.warn(\"Error writing reply back to \" + peer.getRemoteAddressString());\n         incrDatanodeNetworkErrors();\n       }\n       IOUtils.closeStream(proxyOut);\n       IOUtils.closeStream(blockReceiver);\n       IOUtils.closeStream(proxyReply);\n       IOUtils.closeStream(replyOut);\n     }\n \n     //update metrics\n     datanode.metrics.addReplaceBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void replaceBlock(final ExtendedBlock block,\n      final StorageType storageType, \n      final Token\u003cBlockTokenIdentifier\u003e blockToken,\n      final String delHint,\n      final DatanodeInfo proxySource) throws IOException {\n    updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n\n    /* read header */\n    if (datanode.isBlockTokenEnabled) {\n      try {\n        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n            BlockTokenIdentifier.AccessMode.REPLACE);\n      } catch (InvalidToken e) {\n        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n            + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n            + e.getLocalizedMessage());\n        sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n        return;\n      }\n    }\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      String msg \u003d \"Not able to receive block \" + block.getBlockId() +\n          \" from \" + peer.getRemoteAddressString() + \" because threads \" +\n          \"quota is exceeded.\";\n      LOG.warn(msg);\n      sendResponse(ERROR, msg);\n      return;\n    }\n\n    Socket proxySock \u003d null;\n    DataOutputStream proxyOut \u003d null;\n    Status opStatus \u003d SUCCESS;\n    String errMsg \u003d null;\n    BlockReceiver blockReceiver \u003d null;\n    DataInputStream proxyReply \u003d null;\n    DataOutputStream replyOut \u003d new DataOutputStream(getOutputStream());\n    boolean IoeDuringCopyBlockOperation \u003d false;\n    try {\n      // Move the block to different storage in the same datanode\n      if (proxySource.equals(datanode.getDatanodeId())) {\n        ReplicaInfo oldReplica \u003d datanode.data.moveBlockAcrossStorage(block,\n            storageType);\n        if (oldReplica !\u003d null) {\n          LOG.info(\"Moved \" + block + \" from StorageType \"\n              + oldReplica.getVolume().getStorageType() + \" to \" + storageType);\n        }\n      } else {\n        block.setNumBytes(dataXceiverServer.estimateBlockSize);\n        // get the output stream to the proxy\n        final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Connecting to datanode \" + dnAddr);\n        }\n        InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n        proxySock \u003d datanode.newSocket();\n        NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n        proxySock.setSoTimeout(dnConf.socketTimeout);\n        \n        OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n            dnConf.socketWriteTimeout);\n        InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n        DataEncryptionKeyFactory keyFactory \u003d\n            datanode.getDataEncryptionKeyFactoryForBlock(block);\n        IOStreamPair saslStreams \u003d datanode.saslClient.socketSend(proxySock,\n            unbufProxyOut, unbufProxyIn, keyFactory, blockToken, proxySource);\n        unbufProxyOut \u003d saslStreams.out;\n        unbufProxyIn \u003d saslStreams.in;\n        \n        proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut,\n            smallBufferSize));\n        proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n            ioFileBufferSize));\n        \n        /* send request to the proxy */\n        IoeDuringCopyBlockOperation \u003d true;\n        new Sender(proxyOut).copyBlock(block, blockToken);\n        IoeDuringCopyBlockOperation \u003d false;\n        \n        // receive the response from the proxy\n        \n        BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n            PBHelper.vintPrefixed(proxyReply));\n        \n        String logInfo \u003d \"copy block \" + block + \" from \"\n            + proxySock.getRemoteSocketAddress();\n        DataTransferProtoUtil.checkBlockOpStatus(copyResponse, logInfo);\n\n        // get checksum info about the block we\u0027re copying\n        ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n        DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n            checksumInfo.getChecksum());\n        // open a block receiver and check if the block does not exist\n        blockReceiver \u003d getBlockReceiver(block, storageType,\n            proxyReply, proxySock.getRemoteSocketAddress().toString(),\n            proxySock.getLocalSocketAddress().toString(),\n            null, 0, 0, 0, \"\", null, datanode, remoteChecksum,\n            CachingStrategy.newDropBehind(), false, false);\n        \n        // receive a block\n        blockReceiver.receiveBlock(null, null, replyOut, null, \n            dataXceiverServer.balanceThrottler, null, true);\n        \n        // notify name node\n        datanode.notifyNamenodeReceivedBlock(\n            block, delHint, blockReceiver.getStorageUuid());\n        \n        LOG.info(\"Moved \" + block + \" from \" + peer.getRemoteAddressString()\n            + \", delHint\u003d\" + delHint);\n      }\n    } catch (IOException ioe) {\n      opStatus \u003d ERROR;\n      errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n      LOG.info(errMsg);\n      if (!IoeDuringCopyBlockOperation) {\n        // Don\u0027t double count IO errors\n        incrDatanodeNetworkErrors();\n      }\n      throw ioe;\n    } finally {\n      // receive the last byte that indicates the proxy released its thread resource\n      if (opStatus \u003d\u003d SUCCESS \u0026\u0026 proxyReply !\u003d null) {\n        try {\n          proxyReply.readChar();\n        } catch (IOException ignored) {\n        }\n      }\n      \n      // now release the thread resource\n      dataXceiverServer.balanceThrottler.release();\n      \n      // send response back\n      try {\n        sendResponse(opStatus, errMsg);\n      } catch (IOException ioe) {\n        LOG.warn(\"Error writing reply back to \" + peer.getRemoteAddressString());\n        incrDatanodeNetworkErrors();\n      }\n      IOUtils.closeStream(proxyOut);\n      IOUtils.closeStream(blockReceiver);\n      IOUtils.closeStream(proxyReply);\n      IOUtils.closeStream(replyOut);\n    }\n\n    //update metrics\n    datanode.metrics.addReplaceBlockOp(elapsed());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "4da8490b512a33a255ed27309860859388d7c168": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8314. Move HdfsServerConstants#IO_FILE_BUFFER_SIZE and SMALL_BUFFER_SIZE to the users. Contributed by Li Lu.\n",
      "commitDate": "05/05/15 3:41 PM",
      "commitName": "4da8490b512a33a255ed27309860859388d7c168",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "02/05/15 10:03 AM",
      "commitNameOld": "6ae2a0d048e133b43249c248a75a4d77d9abb80d",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 3.23,
      "commitsBetweenForRepo": 31,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,147 +1,147 @@\n   public void replaceBlock(final ExtendedBlock block,\n       final StorageType storageType, \n       final Token\u003cBlockTokenIdentifier\u003e blockToken,\n       final String delHint,\n       final DatanodeInfo proxySource) throws IOException {\n     updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n \n     /* read header */\n     if (datanode.isBlockTokenEnabled) {\n       try {\n         datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n             BlockTokenIdentifier.AccessMode.REPLACE);\n       } catch (InvalidToken e) {\n         LOG.warn(\"Invalid access token in request from \" + remoteAddress\n             + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n             + e.getLocalizedMessage());\n         sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n         return;\n       }\n     }\n \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n       String msg \u003d \"Not able to receive block \" + block.getBlockId() +\n           \" from \" + peer.getRemoteAddressString() + \" because threads \" +\n           \"quota is exceeded.\";\n       LOG.warn(msg);\n       sendResponse(ERROR, msg);\n       return;\n     }\n \n     Socket proxySock \u003d null;\n     DataOutputStream proxyOut \u003d null;\n     Status opStatus \u003d SUCCESS;\n     String errMsg \u003d null;\n     BlockReceiver blockReceiver \u003d null;\n     DataInputStream proxyReply \u003d null;\n     DataOutputStream replyOut \u003d new DataOutputStream(getOutputStream());\n     boolean IoeDuringCopyBlockOperation \u003d false;\n     try {\n       // Move the block to different storage in the same datanode\n       if (proxySource.equals(datanode.getDatanodeId())) {\n         ReplicaInfo oldReplica \u003d datanode.data.moveBlockAcrossStorage(block,\n             storageType);\n         if (oldReplica !\u003d null) {\n           LOG.info(\"Moved \" + block + \" from StorageType \"\n               + oldReplica.getVolume().getStorageType() + \" to \" + storageType);\n         }\n       } else {\n         block.setNumBytes(dataXceiverServer.estimateBlockSize);\n         // get the output stream to the proxy\n         final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Connecting to datanode \" + dnAddr);\n         }\n         InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n         proxySock \u003d datanode.newSocket();\n         NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n         proxySock.setSoTimeout(dnConf.socketTimeout);\n         \n         OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n             dnConf.socketWriteTimeout);\n         InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n         DataEncryptionKeyFactory keyFactory \u003d\n             datanode.getDataEncryptionKeyFactoryForBlock(block);\n         IOStreamPair saslStreams \u003d datanode.saslClient.socketSend(proxySock,\n             unbufProxyOut, unbufProxyIn, keyFactory, blockToken, proxySource);\n         unbufProxyOut \u003d saslStreams.out;\n         unbufProxyIn \u003d saslStreams.in;\n         \n-        proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut, \n-            HdfsServerConstants.SMALL_BUFFER_SIZE));\n+        proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut,\n+            smallBufferSize));\n         proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n-            HdfsServerConstants.IO_FILE_BUFFER_SIZE));\n+            ioFileBufferSize));\n         \n         /* send request to the proxy */\n         IoeDuringCopyBlockOperation \u003d true;\n         new Sender(proxyOut).copyBlock(block, blockToken);\n         IoeDuringCopyBlockOperation \u003d false;\n         \n         // receive the response from the proxy\n         \n         BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n             PBHelper.vintPrefixed(proxyReply));\n         \n         String logInfo \u003d \"copy block \" + block + \" from \"\n             + proxySock.getRemoteSocketAddress();\n         DataTransferProtoUtil.checkBlockOpStatus(copyResponse, logInfo);\n \n         // get checksum info about the block we\u0027re copying\n         ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n         DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n             checksumInfo.getChecksum());\n         // open a block receiver and check if the block does not exist\n         blockReceiver \u003d new BlockReceiver(block, storageType,\n             proxyReply, proxySock.getRemoteSocketAddress().toString(),\n             proxySock.getLocalSocketAddress().toString(),\n             null, 0, 0, 0, \"\", null, datanode, remoteChecksum,\n             CachingStrategy.newDropBehind(), false, false);\n         \n         // receive a block\n         blockReceiver.receiveBlock(null, null, replyOut, null, \n             dataXceiverServer.balanceThrottler, null, true);\n         \n         // notify name node\n         datanode.notifyNamenodeReceivedBlock(\n             block, delHint, blockReceiver.getStorageUuid());\n         \n         LOG.info(\"Moved \" + block + \" from \" + peer.getRemoteAddressString()\n             + \", delHint\u003d\" + delHint);\n       }\n     } catch (IOException ioe) {\n       opStatus \u003d ERROR;\n       errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n       LOG.info(errMsg);\n       if (!IoeDuringCopyBlockOperation) {\n         // Don\u0027t double count IO errors\n         incrDatanodeNetworkErrors();\n       }\n       throw ioe;\n     } finally {\n       // receive the last byte that indicates the proxy released its thread resource\n       if (opStatus \u003d\u003d SUCCESS \u0026\u0026 proxyReply !\u003d null) {\n         try {\n           proxyReply.readChar();\n         } catch (IOException ignored) {\n         }\n       }\n       \n       // now release the thread resource\n       dataXceiverServer.balanceThrottler.release();\n       \n       // send response back\n       try {\n         sendResponse(opStatus, errMsg);\n       } catch (IOException ioe) {\n         LOG.warn(\"Error writing reply back to \" + peer.getRemoteAddressString());\n         incrDatanodeNetworkErrors();\n       }\n       IOUtils.closeStream(proxyOut);\n       IOUtils.closeStream(blockReceiver);\n       IOUtils.closeStream(proxyReply);\n       IOUtils.closeStream(replyOut);\n     }\n \n     //update metrics\n     datanode.metrics.addReplaceBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void replaceBlock(final ExtendedBlock block,\n      final StorageType storageType, \n      final Token\u003cBlockTokenIdentifier\u003e blockToken,\n      final String delHint,\n      final DatanodeInfo proxySource) throws IOException {\n    updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n\n    /* read header */\n    if (datanode.isBlockTokenEnabled) {\n      try {\n        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n            BlockTokenIdentifier.AccessMode.REPLACE);\n      } catch (InvalidToken e) {\n        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n            + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n            + e.getLocalizedMessage());\n        sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n        return;\n      }\n    }\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      String msg \u003d \"Not able to receive block \" + block.getBlockId() +\n          \" from \" + peer.getRemoteAddressString() + \" because threads \" +\n          \"quota is exceeded.\";\n      LOG.warn(msg);\n      sendResponse(ERROR, msg);\n      return;\n    }\n\n    Socket proxySock \u003d null;\n    DataOutputStream proxyOut \u003d null;\n    Status opStatus \u003d SUCCESS;\n    String errMsg \u003d null;\n    BlockReceiver blockReceiver \u003d null;\n    DataInputStream proxyReply \u003d null;\n    DataOutputStream replyOut \u003d new DataOutputStream(getOutputStream());\n    boolean IoeDuringCopyBlockOperation \u003d false;\n    try {\n      // Move the block to different storage in the same datanode\n      if (proxySource.equals(datanode.getDatanodeId())) {\n        ReplicaInfo oldReplica \u003d datanode.data.moveBlockAcrossStorage(block,\n            storageType);\n        if (oldReplica !\u003d null) {\n          LOG.info(\"Moved \" + block + \" from StorageType \"\n              + oldReplica.getVolume().getStorageType() + \" to \" + storageType);\n        }\n      } else {\n        block.setNumBytes(dataXceiverServer.estimateBlockSize);\n        // get the output stream to the proxy\n        final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Connecting to datanode \" + dnAddr);\n        }\n        InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n        proxySock \u003d datanode.newSocket();\n        NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n        proxySock.setSoTimeout(dnConf.socketTimeout);\n        \n        OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n            dnConf.socketWriteTimeout);\n        InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n        DataEncryptionKeyFactory keyFactory \u003d\n            datanode.getDataEncryptionKeyFactoryForBlock(block);\n        IOStreamPair saslStreams \u003d datanode.saslClient.socketSend(proxySock,\n            unbufProxyOut, unbufProxyIn, keyFactory, blockToken, proxySource);\n        unbufProxyOut \u003d saslStreams.out;\n        unbufProxyIn \u003d saslStreams.in;\n        \n        proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut,\n            smallBufferSize));\n        proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n            ioFileBufferSize));\n        \n        /* send request to the proxy */\n        IoeDuringCopyBlockOperation \u003d true;\n        new Sender(proxyOut).copyBlock(block, blockToken);\n        IoeDuringCopyBlockOperation \u003d false;\n        \n        // receive the response from the proxy\n        \n        BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n            PBHelper.vintPrefixed(proxyReply));\n        \n        String logInfo \u003d \"copy block \" + block + \" from \"\n            + proxySock.getRemoteSocketAddress();\n        DataTransferProtoUtil.checkBlockOpStatus(copyResponse, logInfo);\n\n        // get checksum info about the block we\u0027re copying\n        ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n        DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n            checksumInfo.getChecksum());\n        // open a block receiver and check if the block does not exist\n        blockReceiver \u003d new BlockReceiver(block, storageType,\n            proxyReply, proxySock.getRemoteSocketAddress().toString(),\n            proxySock.getLocalSocketAddress().toString(),\n            null, 0, 0, 0, \"\", null, datanode, remoteChecksum,\n            CachingStrategy.newDropBehind(), false, false);\n        \n        // receive a block\n        blockReceiver.receiveBlock(null, null, replyOut, null, \n            dataXceiverServer.balanceThrottler, null, true);\n        \n        // notify name node\n        datanode.notifyNamenodeReceivedBlock(\n            block, delHint, blockReceiver.getStorageUuid());\n        \n        LOG.info(\"Moved \" + block + \" from \" + peer.getRemoteAddressString()\n            + \", delHint\u003d\" + delHint);\n      }\n    } catch (IOException ioe) {\n      opStatus \u003d ERROR;\n      errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n      LOG.info(errMsg);\n      if (!IoeDuringCopyBlockOperation) {\n        // Don\u0027t double count IO errors\n        incrDatanodeNetworkErrors();\n      }\n      throw ioe;\n    } finally {\n      // receive the last byte that indicates the proxy released its thread resource\n      if (opStatus \u003d\u003d SUCCESS \u0026\u0026 proxyReply !\u003d null) {\n        try {\n          proxyReply.readChar();\n        } catch (IOException ignored) {\n        }\n      }\n      \n      // now release the thread resource\n      dataXceiverServer.balanceThrottler.release();\n      \n      // send response back\n      try {\n        sendResponse(opStatus, errMsg);\n      } catch (IOException ioe) {\n        LOG.warn(\"Error writing reply back to \" + peer.getRemoteAddressString());\n        incrDatanodeNetworkErrors();\n      }\n      IOUtils.closeStream(proxyOut);\n      IOUtils.closeStream(blockReceiver);\n      IOUtils.closeStream(proxyReply);\n      IOUtils.closeStream(replyOut);\n    }\n\n    //update metrics\n    datanode.metrics.addReplaceBlockOp(elapsed());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "6ae2a0d048e133b43249c248a75a4d77d9abb80d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8249. Separate HdfsConstants into the client and the server side class. Contributed by Haohui Mai.\n",
      "commitDate": "02/05/15 10:03 AM",
      "commitName": "6ae2a0d048e133b43249c248a75a4d77d9abb80d",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "23/04/15 7:00 PM",
      "commitNameOld": "a0e0a63209b5eb17dca5cc503be36aa52defeabd",
      "commitAuthorOld": "Colin Patrick Mccabe",
      "daysBetweenCommits": 8.63,
      "commitsBetweenForRepo": 77,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,147 +1,147 @@\n   public void replaceBlock(final ExtendedBlock block,\n       final StorageType storageType, \n       final Token\u003cBlockTokenIdentifier\u003e blockToken,\n       final String delHint,\n       final DatanodeInfo proxySource) throws IOException {\n     updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n \n     /* read header */\n     if (datanode.isBlockTokenEnabled) {\n       try {\n         datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n             BlockTokenIdentifier.AccessMode.REPLACE);\n       } catch (InvalidToken e) {\n         LOG.warn(\"Invalid access token in request from \" + remoteAddress\n             + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n             + e.getLocalizedMessage());\n         sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n         return;\n       }\n     }\n \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n       String msg \u003d \"Not able to receive block \" + block.getBlockId() +\n           \" from \" + peer.getRemoteAddressString() + \" because threads \" +\n           \"quota is exceeded.\";\n       LOG.warn(msg);\n       sendResponse(ERROR, msg);\n       return;\n     }\n \n     Socket proxySock \u003d null;\n     DataOutputStream proxyOut \u003d null;\n     Status opStatus \u003d SUCCESS;\n     String errMsg \u003d null;\n     BlockReceiver blockReceiver \u003d null;\n     DataInputStream proxyReply \u003d null;\n     DataOutputStream replyOut \u003d new DataOutputStream(getOutputStream());\n     boolean IoeDuringCopyBlockOperation \u003d false;\n     try {\n       // Move the block to different storage in the same datanode\n       if (proxySource.equals(datanode.getDatanodeId())) {\n         ReplicaInfo oldReplica \u003d datanode.data.moveBlockAcrossStorage(block,\n             storageType);\n         if (oldReplica !\u003d null) {\n           LOG.info(\"Moved \" + block + \" from StorageType \"\n               + oldReplica.getVolume().getStorageType() + \" to \" + storageType);\n         }\n       } else {\n         block.setNumBytes(dataXceiverServer.estimateBlockSize);\n         // get the output stream to the proxy\n         final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Connecting to datanode \" + dnAddr);\n         }\n         InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n         proxySock \u003d datanode.newSocket();\n         NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n         proxySock.setSoTimeout(dnConf.socketTimeout);\n         \n         OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n             dnConf.socketWriteTimeout);\n         InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n         DataEncryptionKeyFactory keyFactory \u003d\n             datanode.getDataEncryptionKeyFactoryForBlock(block);\n         IOStreamPair saslStreams \u003d datanode.saslClient.socketSend(proxySock,\n             unbufProxyOut, unbufProxyIn, keyFactory, blockToken, proxySource);\n         unbufProxyOut \u003d saslStreams.out;\n         unbufProxyIn \u003d saslStreams.in;\n         \n         proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut, \n-            HdfsConstants.SMALL_BUFFER_SIZE));\n+            HdfsServerConstants.SMALL_BUFFER_SIZE));\n         proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n-            HdfsConstants.IO_FILE_BUFFER_SIZE));\n+            HdfsServerConstants.IO_FILE_BUFFER_SIZE));\n         \n         /* send request to the proxy */\n         IoeDuringCopyBlockOperation \u003d true;\n         new Sender(proxyOut).copyBlock(block, blockToken);\n         IoeDuringCopyBlockOperation \u003d false;\n         \n         // receive the response from the proxy\n         \n         BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n             PBHelper.vintPrefixed(proxyReply));\n         \n         String logInfo \u003d \"copy block \" + block + \" from \"\n             + proxySock.getRemoteSocketAddress();\n         DataTransferProtoUtil.checkBlockOpStatus(copyResponse, logInfo);\n \n         // get checksum info about the block we\u0027re copying\n         ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n         DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n             checksumInfo.getChecksum());\n         // open a block receiver and check if the block does not exist\n         blockReceiver \u003d new BlockReceiver(block, storageType,\n             proxyReply, proxySock.getRemoteSocketAddress().toString(),\n             proxySock.getLocalSocketAddress().toString(),\n             null, 0, 0, 0, \"\", null, datanode, remoteChecksum,\n             CachingStrategy.newDropBehind(), false, false);\n         \n         // receive a block\n         blockReceiver.receiveBlock(null, null, replyOut, null, \n             dataXceiverServer.balanceThrottler, null, true);\n         \n         // notify name node\n         datanode.notifyNamenodeReceivedBlock(\n             block, delHint, blockReceiver.getStorageUuid());\n         \n         LOG.info(\"Moved \" + block + \" from \" + peer.getRemoteAddressString()\n             + \", delHint\u003d\" + delHint);\n       }\n     } catch (IOException ioe) {\n       opStatus \u003d ERROR;\n       errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n       LOG.info(errMsg);\n       if (!IoeDuringCopyBlockOperation) {\n         // Don\u0027t double count IO errors\n         incrDatanodeNetworkErrors();\n       }\n       throw ioe;\n     } finally {\n       // receive the last byte that indicates the proxy released its thread resource\n       if (opStatus \u003d\u003d SUCCESS \u0026\u0026 proxyReply !\u003d null) {\n         try {\n           proxyReply.readChar();\n         } catch (IOException ignored) {\n         }\n       }\n       \n       // now release the thread resource\n       dataXceiverServer.balanceThrottler.release();\n       \n       // send response back\n       try {\n         sendResponse(opStatus, errMsg);\n       } catch (IOException ioe) {\n         LOG.warn(\"Error writing reply back to \" + peer.getRemoteAddressString());\n         incrDatanodeNetworkErrors();\n       }\n       IOUtils.closeStream(proxyOut);\n       IOUtils.closeStream(blockReceiver);\n       IOUtils.closeStream(proxyReply);\n       IOUtils.closeStream(replyOut);\n     }\n \n     //update metrics\n     datanode.metrics.addReplaceBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void replaceBlock(final ExtendedBlock block,\n      final StorageType storageType, \n      final Token\u003cBlockTokenIdentifier\u003e blockToken,\n      final String delHint,\n      final DatanodeInfo proxySource) throws IOException {\n    updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n\n    /* read header */\n    if (datanode.isBlockTokenEnabled) {\n      try {\n        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n            BlockTokenIdentifier.AccessMode.REPLACE);\n      } catch (InvalidToken e) {\n        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n            + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n            + e.getLocalizedMessage());\n        sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n        return;\n      }\n    }\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      String msg \u003d \"Not able to receive block \" + block.getBlockId() +\n          \" from \" + peer.getRemoteAddressString() + \" because threads \" +\n          \"quota is exceeded.\";\n      LOG.warn(msg);\n      sendResponse(ERROR, msg);\n      return;\n    }\n\n    Socket proxySock \u003d null;\n    DataOutputStream proxyOut \u003d null;\n    Status opStatus \u003d SUCCESS;\n    String errMsg \u003d null;\n    BlockReceiver blockReceiver \u003d null;\n    DataInputStream proxyReply \u003d null;\n    DataOutputStream replyOut \u003d new DataOutputStream(getOutputStream());\n    boolean IoeDuringCopyBlockOperation \u003d false;\n    try {\n      // Move the block to different storage in the same datanode\n      if (proxySource.equals(datanode.getDatanodeId())) {\n        ReplicaInfo oldReplica \u003d datanode.data.moveBlockAcrossStorage(block,\n            storageType);\n        if (oldReplica !\u003d null) {\n          LOG.info(\"Moved \" + block + \" from StorageType \"\n              + oldReplica.getVolume().getStorageType() + \" to \" + storageType);\n        }\n      } else {\n        block.setNumBytes(dataXceiverServer.estimateBlockSize);\n        // get the output stream to the proxy\n        final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Connecting to datanode \" + dnAddr);\n        }\n        InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n        proxySock \u003d datanode.newSocket();\n        NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n        proxySock.setSoTimeout(dnConf.socketTimeout);\n        \n        OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n            dnConf.socketWriteTimeout);\n        InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n        DataEncryptionKeyFactory keyFactory \u003d\n            datanode.getDataEncryptionKeyFactoryForBlock(block);\n        IOStreamPair saslStreams \u003d datanode.saslClient.socketSend(proxySock,\n            unbufProxyOut, unbufProxyIn, keyFactory, blockToken, proxySource);\n        unbufProxyOut \u003d saslStreams.out;\n        unbufProxyIn \u003d saslStreams.in;\n        \n        proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut, \n            HdfsServerConstants.SMALL_BUFFER_SIZE));\n        proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n            HdfsServerConstants.IO_FILE_BUFFER_SIZE));\n        \n        /* send request to the proxy */\n        IoeDuringCopyBlockOperation \u003d true;\n        new Sender(proxyOut).copyBlock(block, blockToken);\n        IoeDuringCopyBlockOperation \u003d false;\n        \n        // receive the response from the proxy\n        \n        BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n            PBHelper.vintPrefixed(proxyReply));\n        \n        String logInfo \u003d \"copy block \" + block + \" from \"\n            + proxySock.getRemoteSocketAddress();\n        DataTransferProtoUtil.checkBlockOpStatus(copyResponse, logInfo);\n\n        // get checksum info about the block we\u0027re copying\n        ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n        DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n            checksumInfo.getChecksum());\n        // open a block receiver and check if the block does not exist\n        blockReceiver \u003d new BlockReceiver(block, storageType,\n            proxyReply, proxySock.getRemoteSocketAddress().toString(),\n            proxySock.getLocalSocketAddress().toString(),\n            null, 0, 0, 0, \"\", null, datanode, remoteChecksum,\n            CachingStrategy.newDropBehind(), false, false);\n        \n        // receive a block\n        blockReceiver.receiveBlock(null, null, replyOut, null, \n            dataXceiverServer.balanceThrottler, null, true);\n        \n        // notify name node\n        datanode.notifyNamenodeReceivedBlock(\n            block, delHint, blockReceiver.getStorageUuid());\n        \n        LOG.info(\"Moved \" + block + \" from \" + peer.getRemoteAddressString()\n            + \", delHint\u003d\" + delHint);\n      }\n    } catch (IOException ioe) {\n      opStatus \u003d ERROR;\n      errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n      LOG.info(errMsg);\n      if (!IoeDuringCopyBlockOperation) {\n        // Don\u0027t double count IO errors\n        incrDatanodeNetworkErrors();\n      }\n      throw ioe;\n    } finally {\n      // receive the last byte that indicates the proxy released its thread resource\n      if (opStatus \u003d\u003d SUCCESS \u0026\u0026 proxyReply !\u003d null) {\n        try {\n          proxyReply.readChar();\n        } catch (IOException ignored) {\n        }\n      }\n      \n      // now release the thread resource\n      dataXceiverServer.balanceThrottler.release();\n      \n      // send response back\n      try {\n        sendResponse(opStatus, errMsg);\n      } catch (IOException ioe) {\n        LOG.warn(\"Error writing reply back to \" + peer.getRemoteAddressString());\n        incrDatanodeNetworkErrors();\n      }\n      IOUtils.closeStream(proxyOut);\n      IOUtils.closeStream(blockReceiver);\n      IOUtils.closeStream(proxyReply);\n      IOUtils.closeStream(replyOut);\n    }\n\n    //update metrics\n    datanode.metrics.addReplaceBlockOp(elapsed());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "36e4cd3be6f7fec8db82d3d1bcb258af470ece2e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8103. Move BlockTokenSecretManager.AccessMode into BlockTokenIdentifier. Contributed by Haohui Mai.\n",
      "commitDate": "10/04/15 4:36 PM",
      "commitName": "36e4cd3be6f7fec8db82d3d1bcb258af470ece2e",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "20/03/15 12:02 PM",
      "commitNameOld": "75ead273bea8a7dad61c4f99c3a16cab2697c498",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 21.19,
      "commitsBetweenForRepo": 196,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,147 +1,147 @@\n   public void replaceBlock(final ExtendedBlock block,\n       final StorageType storageType, \n       final Token\u003cBlockTokenIdentifier\u003e blockToken,\n       final String delHint,\n       final DatanodeInfo proxySource) throws IOException {\n     updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n \n     /* read header */\n     if (datanode.isBlockTokenEnabled) {\n       try {\n         datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n-            BlockTokenSecretManager.AccessMode.REPLACE);\n+            BlockTokenIdentifier.AccessMode.REPLACE);\n       } catch (InvalidToken e) {\n         LOG.warn(\"Invalid access token in request from \" + remoteAddress\n             + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n             + e.getLocalizedMessage());\n         sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n         return;\n       }\n     }\n \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n       String msg \u003d \"Not able to receive block \" + block.getBlockId() +\n           \" from \" + peer.getRemoteAddressString() + \" because threads \" +\n           \"quota is exceeded.\";\n       LOG.warn(msg);\n       sendResponse(ERROR, msg);\n       return;\n     }\n \n     Socket proxySock \u003d null;\n     DataOutputStream proxyOut \u003d null;\n     Status opStatus \u003d SUCCESS;\n     String errMsg \u003d null;\n     BlockReceiver blockReceiver \u003d null;\n     DataInputStream proxyReply \u003d null;\n     DataOutputStream replyOut \u003d new DataOutputStream(getOutputStream());\n     boolean IoeDuringCopyBlockOperation \u003d false;\n     try {\n       // Move the block to different storage in the same datanode\n       if (proxySource.equals(datanode.getDatanodeId())) {\n         ReplicaInfo oldReplica \u003d datanode.data.moveBlockAcrossStorage(block,\n             storageType);\n         if (oldReplica !\u003d null) {\n           LOG.info(\"Moved \" + block + \" from StorageType \"\n               + oldReplica.getVolume().getStorageType() + \" to \" + storageType);\n         }\n       } else {\n         block.setNumBytes(dataXceiverServer.estimateBlockSize);\n         // get the output stream to the proxy\n         final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Connecting to datanode \" + dnAddr);\n         }\n         InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n         proxySock \u003d datanode.newSocket();\n         NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n         proxySock.setSoTimeout(dnConf.socketTimeout);\n         \n         OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n             dnConf.socketWriteTimeout);\n         InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n         DataEncryptionKeyFactory keyFactory \u003d\n             datanode.getDataEncryptionKeyFactoryForBlock(block);\n         IOStreamPair saslStreams \u003d datanode.saslClient.socketSend(proxySock,\n             unbufProxyOut, unbufProxyIn, keyFactory, blockToken, proxySource);\n         unbufProxyOut \u003d saslStreams.out;\n         unbufProxyIn \u003d saslStreams.in;\n         \n         proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut, \n             HdfsConstants.SMALL_BUFFER_SIZE));\n         proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n             HdfsConstants.IO_FILE_BUFFER_SIZE));\n         \n         /* send request to the proxy */\n         IoeDuringCopyBlockOperation \u003d true;\n         new Sender(proxyOut).copyBlock(block, blockToken);\n         IoeDuringCopyBlockOperation \u003d false;\n         \n         // receive the response from the proxy\n         \n         BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n             PBHelper.vintPrefixed(proxyReply));\n         \n         String logInfo \u003d \"copy block \" + block + \" from \"\n             + proxySock.getRemoteSocketAddress();\n         DataTransferProtoUtil.checkBlockOpStatus(copyResponse, logInfo);\n \n         // get checksum info about the block we\u0027re copying\n         ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n         DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n             checksumInfo.getChecksum());\n         // open a block receiver and check if the block does not exist\n         blockReceiver \u003d new BlockReceiver(block, storageType,\n             proxyReply, proxySock.getRemoteSocketAddress().toString(),\n             proxySock.getLocalSocketAddress().toString(),\n             null, 0, 0, 0, \"\", null, datanode, remoteChecksum,\n             CachingStrategy.newDropBehind(), false, false);\n         \n         // receive a block\n         blockReceiver.receiveBlock(null, null, replyOut, null, \n             dataXceiverServer.balanceThrottler, null, true);\n         \n         // notify name node\n         datanode.notifyNamenodeReceivedBlock(\n             block, delHint, blockReceiver.getStorageUuid());\n         \n         LOG.info(\"Moved \" + block + \" from \" + peer.getRemoteAddressString()\n             + \", delHint\u003d\" + delHint);\n       }\n     } catch (IOException ioe) {\n       opStatus \u003d ERROR;\n       errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n       LOG.info(errMsg);\n       if (!IoeDuringCopyBlockOperation) {\n         // Don\u0027t double count IO errors\n         incrDatanodeNetworkErrors();\n       }\n       throw ioe;\n     } finally {\n       // receive the last byte that indicates the proxy released its thread resource\n       if (opStatus \u003d\u003d SUCCESS \u0026\u0026 proxyReply !\u003d null) {\n         try {\n           proxyReply.readChar();\n         } catch (IOException ignored) {\n         }\n       }\n       \n       // now release the thread resource\n       dataXceiverServer.balanceThrottler.release();\n       \n       // send response back\n       try {\n         sendResponse(opStatus, errMsg);\n       } catch (IOException ioe) {\n         LOG.warn(\"Error writing reply back to \" + peer.getRemoteAddressString());\n         incrDatanodeNetworkErrors();\n       }\n       IOUtils.closeStream(proxyOut);\n       IOUtils.closeStream(blockReceiver);\n       IOUtils.closeStream(proxyReply);\n       IOUtils.closeStream(replyOut);\n     }\n \n     //update metrics\n     datanode.metrics.addReplaceBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void replaceBlock(final ExtendedBlock block,\n      final StorageType storageType, \n      final Token\u003cBlockTokenIdentifier\u003e blockToken,\n      final String delHint,\n      final DatanodeInfo proxySource) throws IOException {\n    updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n\n    /* read header */\n    if (datanode.isBlockTokenEnabled) {\n      try {\n        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n            BlockTokenIdentifier.AccessMode.REPLACE);\n      } catch (InvalidToken e) {\n        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n            + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n            + e.getLocalizedMessage());\n        sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n        return;\n      }\n    }\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      String msg \u003d \"Not able to receive block \" + block.getBlockId() +\n          \" from \" + peer.getRemoteAddressString() + \" because threads \" +\n          \"quota is exceeded.\";\n      LOG.warn(msg);\n      sendResponse(ERROR, msg);\n      return;\n    }\n\n    Socket proxySock \u003d null;\n    DataOutputStream proxyOut \u003d null;\n    Status opStatus \u003d SUCCESS;\n    String errMsg \u003d null;\n    BlockReceiver blockReceiver \u003d null;\n    DataInputStream proxyReply \u003d null;\n    DataOutputStream replyOut \u003d new DataOutputStream(getOutputStream());\n    boolean IoeDuringCopyBlockOperation \u003d false;\n    try {\n      // Move the block to different storage in the same datanode\n      if (proxySource.equals(datanode.getDatanodeId())) {\n        ReplicaInfo oldReplica \u003d datanode.data.moveBlockAcrossStorage(block,\n            storageType);\n        if (oldReplica !\u003d null) {\n          LOG.info(\"Moved \" + block + \" from StorageType \"\n              + oldReplica.getVolume().getStorageType() + \" to \" + storageType);\n        }\n      } else {\n        block.setNumBytes(dataXceiverServer.estimateBlockSize);\n        // get the output stream to the proxy\n        final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Connecting to datanode \" + dnAddr);\n        }\n        InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n        proxySock \u003d datanode.newSocket();\n        NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n        proxySock.setSoTimeout(dnConf.socketTimeout);\n        \n        OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n            dnConf.socketWriteTimeout);\n        InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n        DataEncryptionKeyFactory keyFactory \u003d\n            datanode.getDataEncryptionKeyFactoryForBlock(block);\n        IOStreamPair saslStreams \u003d datanode.saslClient.socketSend(proxySock,\n            unbufProxyOut, unbufProxyIn, keyFactory, blockToken, proxySource);\n        unbufProxyOut \u003d saslStreams.out;\n        unbufProxyIn \u003d saslStreams.in;\n        \n        proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut, \n            HdfsConstants.SMALL_BUFFER_SIZE));\n        proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n            HdfsConstants.IO_FILE_BUFFER_SIZE));\n        \n        /* send request to the proxy */\n        IoeDuringCopyBlockOperation \u003d true;\n        new Sender(proxyOut).copyBlock(block, blockToken);\n        IoeDuringCopyBlockOperation \u003d false;\n        \n        // receive the response from the proxy\n        \n        BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n            PBHelper.vintPrefixed(proxyReply));\n        \n        String logInfo \u003d \"copy block \" + block + \" from \"\n            + proxySock.getRemoteSocketAddress();\n        DataTransferProtoUtil.checkBlockOpStatus(copyResponse, logInfo);\n\n        // get checksum info about the block we\u0027re copying\n        ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n        DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n            checksumInfo.getChecksum());\n        // open a block receiver and check if the block does not exist\n        blockReceiver \u003d new BlockReceiver(block, storageType,\n            proxyReply, proxySock.getRemoteSocketAddress().toString(),\n            proxySock.getLocalSocketAddress().toString(),\n            null, 0, 0, 0, \"\", null, datanode, remoteChecksum,\n            CachingStrategy.newDropBehind(), false, false);\n        \n        // receive a block\n        blockReceiver.receiveBlock(null, null, replyOut, null, \n            dataXceiverServer.balanceThrottler, null, true);\n        \n        // notify name node\n        datanode.notifyNamenodeReceivedBlock(\n            block, delHint, blockReceiver.getStorageUuid());\n        \n        LOG.info(\"Moved \" + block + \" from \" + peer.getRemoteAddressString()\n            + \", delHint\u003d\" + delHint);\n      }\n    } catch (IOException ioe) {\n      opStatus \u003d ERROR;\n      errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n      LOG.info(errMsg);\n      if (!IoeDuringCopyBlockOperation) {\n        // Don\u0027t double count IO errors\n        incrDatanodeNetworkErrors();\n      }\n      throw ioe;\n    } finally {\n      // receive the last byte that indicates the proxy released its thread resource\n      if (opStatus \u003d\u003d SUCCESS \u0026\u0026 proxyReply !\u003d null) {\n        try {\n          proxyReply.readChar();\n        } catch (IOException ignored) {\n        }\n      }\n      \n      // now release the thread resource\n      dataXceiverServer.balanceThrottler.release();\n      \n      // send response back\n      try {\n        sendResponse(opStatus, errMsg);\n      } catch (IOException ioe) {\n        LOG.warn(\"Error writing reply back to \" + peer.getRemoteAddressString());\n        incrDatanodeNetworkErrors();\n      }\n      IOUtils.closeStream(proxyOut);\n      IOUtils.closeStream(blockReceiver);\n      IOUtils.closeStream(proxyReply);\n      IOUtils.closeStream(replyOut);\n    }\n\n    //update metrics\n    datanode.metrics.addReplaceBlockOp(elapsed());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "67ed59348d638d56e6752ba2c71fdcd69567546d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7439. Add BlockOpResponseProto\u0027s message to the exception messages.  Contributed by Takanobu Asanuma\n",
      "commitDate": "01/03/15 11:03 PM",
      "commitName": "67ed59348d638d56e6752ba2c71fdcd69567546d",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "commitDateOld": "21/02/15 3:38 PM",
      "commitNameOld": "8b465b4b8caed31ca9daeaae108f9a868a30a455",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 8.31,
      "commitsBetweenForRepo": 60,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,153 +1,147 @@\n   public void replaceBlock(final ExtendedBlock block,\n       final StorageType storageType, \n       final Token\u003cBlockTokenIdentifier\u003e blockToken,\n       final String delHint,\n       final DatanodeInfo proxySource) throws IOException {\n     updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n \n     /* read header */\n     if (datanode.isBlockTokenEnabled) {\n       try {\n         datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n             BlockTokenSecretManager.AccessMode.REPLACE);\n       } catch (InvalidToken e) {\n         LOG.warn(\"Invalid access token in request from \" + remoteAddress\n             + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n             + e.getLocalizedMessage());\n         sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n         return;\n       }\n     }\n \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n       String msg \u003d \"Not able to receive block \" + block.getBlockId() +\n           \" from \" + peer.getRemoteAddressString() + \" because threads \" +\n           \"quota is exceeded.\";\n       LOG.warn(msg);\n       sendResponse(ERROR, msg);\n       return;\n     }\n \n     Socket proxySock \u003d null;\n     DataOutputStream proxyOut \u003d null;\n     Status opStatus \u003d SUCCESS;\n     String errMsg \u003d null;\n     BlockReceiver blockReceiver \u003d null;\n     DataInputStream proxyReply \u003d null;\n     DataOutputStream replyOut \u003d new DataOutputStream(getOutputStream());\n     boolean IoeDuringCopyBlockOperation \u003d false;\n     try {\n       // Move the block to different storage in the same datanode\n       if (proxySource.equals(datanode.getDatanodeId())) {\n         ReplicaInfo oldReplica \u003d datanode.data.moveBlockAcrossStorage(block,\n             storageType);\n         if (oldReplica !\u003d null) {\n           LOG.info(\"Moved \" + block + \" from StorageType \"\n               + oldReplica.getVolume().getStorageType() + \" to \" + storageType);\n         }\n       } else {\n         block.setNumBytes(dataXceiverServer.estimateBlockSize);\n         // get the output stream to the proxy\n         final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Connecting to datanode \" + dnAddr);\n         }\n         InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n         proxySock \u003d datanode.newSocket();\n         NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n         proxySock.setSoTimeout(dnConf.socketTimeout);\n         \n         OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n             dnConf.socketWriteTimeout);\n         InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n         DataEncryptionKeyFactory keyFactory \u003d\n             datanode.getDataEncryptionKeyFactoryForBlock(block);\n         IOStreamPair saslStreams \u003d datanode.saslClient.socketSend(proxySock,\n             unbufProxyOut, unbufProxyIn, keyFactory, blockToken, proxySource);\n         unbufProxyOut \u003d saslStreams.out;\n         unbufProxyIn \u003d saslStreams.in;\n         \n         proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut, \n             HdfsConstants.SMALL_BUFFER_SIZE));\n         proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n             HdfsConstants.IO_FILE_BUFFER_SIZE));\n         \n         /* send request to the proxy */\n         IoeDuringCopyBlockOperation \u003d true;\n         new Sender(proxyOut).copyBlock(block, blockToken);\n         IoeDuringCopyBlockOperation \u003d false;\n         \n         // receive the response from the proxy\n         \n         BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n             PBHelper.vintPrefixed(proxyReply));\n         \n-        if (copyResponse.getStatus() !\u003d SUCCESS) {\n-          if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n-            throw new IOException(\"Copy block \" + block + \" from \"\n-                + proxySock.getRemoteSocketAddress()\n-                + \" failed due to access token error\");\n-          }\n-          throw new IOException(\"Copy block \" + block + \" from \"\n-              + proxySock.getRemoteSocketAddress() + \" failed\");\n-        }\n-        \n+        String logInfo \u003d \"copy block \" + block + \" from \"\n+            + proxySock.getRemoteSocketAddress();\n+        DataTransferProtoUtil.checkBlockOpStatus(copyResponse, logInfo);\n+\n         // get checksum info about the block we\u0027re copying\n         ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n         DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n             checksumInfo.getChecksum());\n         // open a block receiver and check if the block does not exist\n         blockReceiver \u003d new BlockReceiver(block, storageType,\n             proxyReply, proxySock.getRemoteSocketAddress().toString(),\n             proxySock.getLocalSocketAddress().toString(),\n             null, 0, 0, 0, \"\", null, datanode, remoteChecksum,\n             CachingStrategy.newDropBehind(), false, false);\n         \n         // receive a block\n         blockReceiver.receiveBlock(null, null, replyOut, null, \n             dataXceiverServer.balanceThrottler, null, true);\n         \n         // notify name node\n         datanode.notifyNamenodeReceivedBlock(\n             block, delHint, blockReceiver.getStorageUuid());\n         \n         LOG.info(\"Moved \" + block + \" from \" + peer.getRemoteAddressString()\n             + \", delHint\u003d\" + delHint);\n       }\n     } catch (IOException ioe) {\n       opStatus \u003d ERROR;\n       errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n       LOG.info(errMsg);\n       if (!IoeDuringCopyBlockOperation) {\n         // Don\u0027t double count IO errors\n         incrDatanodeNetworkErrors();\n       }\n       throw ioe;\n     } finally {\n       // receive the last byte that indicates the proxy released its thread resource\n       if (opStatus \u003d\u003d SUCCESS \u0026\u0026 proxyReply !\u003d null) {\n         try {\n           proxyReply.readChar();\n         } catch (IOException ignored) {\n         }\n       }\n       \n       // now release the thread resource\n       dataXceiverServer.balanceThrottler.release();\n       \n       // send response back\n       try {\n         sendResponse(opStatus, errMsg);\n       } catch (IOException ioe) {\n         LOG.warn(\"Error writing reply back to \" + peer.getRemoteAddressString());\n         incrDatanodeNetworkErrors();\n       }\n       IOUtils.closeStream(proxyOut);\n       IOUtils.closeStream(blockReceiver);\n       IOUtils.closeStream(proxyReply);\n       IOUtils.closeStream(replyOut);\n     }\n \n     //update metrics\n     datanode.metrics.addReplaceBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void replaceBlock(final ExtendedBlock block,\n      final StorageType storageType, \n      final Token\u003cBlockTokenIdentifier\u003e blockToken,\n      final String delHint,\n      final DatanodeInfo proxySource) throws IOException {\n    updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n\n    /* read header */\n    if (datanode.isBlockTokenEnabled) {\n      try {\n        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n            BlockTokenSecretManager.AccessMode.REPLACE);\n      } catch (InvalidToken e) {\n        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n            + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n            + e.getLocalizedMessage());\n        sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n        return;\n      }\n    }\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      String msg \u003d \"Not able to receive block \" + block.getBlockId() +\n          \" from \" + peer.getRemoteAddressString() + \" because threads \" +\n          \"quota is exceeded.\";\n      LOG.warn(msg);\n      sendResponse(ERROR, msg);\n      return;\n    }\n\n    Socket proxySock \u003d null;\n    DataOutputStream proxyOut \u003d null;\n    Status opStatus \u003d SUCCESS;\n    String errMsg \u003d null;\n    BlockReceiver blockReceiver \u003d null;\n    DataInputStream proxyReply \u003d null;\n    DataOutputStream replyOut \u003d new DataOutputStream(getOutputStream());\n    boolean IoeDuringCopyBlockOperation \u003d false;\n    try {\n      // Move the block to different storage in the same datanode\n      if (proxySource.equals(datanode.getDatanodeId())) {\n        ReplicaInfo oldReplica \u003d datanode.data.moveBlockAcrossStorage(block,\n            storageType);\n        if (oldReplica !\u003d null) {\n          LOG.info(\"Moved \" + block + \" from StorageType \"\n              + oldReplica.getVolume().getStorageType() + \" to \" + storageType);\n        }\n      } else {\n        block.setNumBytes(dataXceiverServer.estimateBlockSize);\n        // get the output stream to the proxy\n        final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Connecting to datanode \" + dnAddr);\n        }\n        InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n        proxySock \u003d datanode.newSocket();\n        NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n        proxySock.setSoTimeout(dnConf.socketTimeout);\n        \n        OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n            dnConf.socketWriteTimeout);\n        InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n        DataEncryptionKeyFactory keyFactory \u003d\n            datanode.getDataEncryptionKeyFactoryForBlock(block);\n        IOStreamPair saslStreams \u003d datanode.saslClient.socketSend(proxySock,\n            unbufProxyOut, unbufProxyIn, keyFactory, blockToken, proxySource);\n        unbufProxyOut \u003d saslStreams.out;\n        unbufProxyIn \u003d saslStreams.in;\n        \n        proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut, \n            HdfsConstants.SMALL_BUFFER_SIZE));\n        proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n            HdfsConstants.IO_FILE_BUFFER_SIZE));\n        \n        /* send request to the proxy */\n        IoeDuringCopyBlockOperation \u003d true;\n        new Sender(proxyOut).copyBlock(block, blockToken);\n        IoeDuringCopyBlockOperation \u003d false;\n        \n        // receive the response from the proxy\n        \n        BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n            PBHelper.vintPrefixed(proxyReply));\n        \n        String logInfo \u003d \"copy block \" + block + \" from \"\n            + proxySock.getRemoteSocketAddress();\n        DataTransferProtoUtil.checkBlockOpStatus(copyResponse, logInfo);\n\n        // get checksum info about the block we\u0027re copying\n        ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n        DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n            checksumInfo.getChecksum());\n        // open a block receiver and check if the block does not exist\n        blockReceiver \u003d new BlockReceiver(block, storageType,\n            proxyReply, proxySock.getRemoteSocketAddress().toString(),\n            proxySock.getLocalSocketAddress().toString(),\n            null, 0, 0, 0, \"\", null, datanode, remoteChecksum,\n            CachingStrategy.newDropBehind(), false, false);\n        \n        // receive a block\n        blockReceiver.receiveBlock(null, null, replyOut, null, \n            dataXceiverServer.balanceThrottler, null, true);\n        \n        // notify name node\n        datanode.notifyNamenodeReceivedBlock(\n            block, delHint, blockReceiver.getStorageUuid());\n        \n        LOG.info(\"Moved \" + block + \" from \" + peer.getRemoteAddressString()\n            + \", delHint\u003d\" + delHint);\n      }\n    } catch (IOException ioe) {\n      opStatus \u003d ERROR;\n      errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n      LOG.info(errMsg);\n      if (!IoeDuringCopyBlockOperation) {\n        // Don\u0027t double count IO errors\n        incrDatanodeNetworkErrors();\n      }\n      throw ioe;\n    } finally {\n      // receive the last byte that indicates the proxy released its thread resource\n      if (opStatus \u003d\u003d SUCCESS \u0026\u0026 proxyReply !\u003d null) {\n        try {\n          proxyReply.readChar();\n        } catch (IOException ignored) {\n        }\n      }\n      \n      // now release the thread resource\n      dataXceiverServer.balanceThrottler.release();\n      \n      // send response back\n      try {\n        sendResponse(opStatus, errMsg);\n      } catch (IOException ioe) {\n        LOG.warn(\"Error writing reply back to \" + peer.getRemoteAddressString());\n        incrDatanodeNetworkErrors();\n      }\n      IOUtils.closeStream(proxyOut);\n      IOUtils.closeStream(blockReceiver);\n      IOUtils.closeStream(proxyReply);\n      IOUtils.closeStream(replyOut);\n    }\n\n    //update metrics\n    datanode.metrics.addReplaceBlockOp(elapsed());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "085b1e293ff53f7a86aa21406cfd4bfa0f3bf33b": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6133. Add a feature for replica pinning so that a pinned replica will not be moved by Balancer/Mover.  Contributed by zhaoyunjiong\n",
      "commitDate": "11/02/15 3:12 PM",
      "commitName": "085b1e293ff53f7a86aa21406cfd4bfa0f3bf33b",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "commitDateOld": "18/12/14 3:03 PM",
      "commitNameOld": "5df7ecb33ab24de903f0fd98e2a055164874def5",
      "commitAuthorOld": "cnauroth",
      "daysBetweenCommits": 55.01,
      "commitsBetweenForRepo": 369,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,153 +1,153 @@\n   public void replaceBlock(final ExtendedBlock block,\n       final StorageType storageType, \n       final Token\u003cBlockTokenIdentifier\u003e blockToken,\n       final String delHint,\n       final DatanodeInfo proxySource) throws IOException {\n     updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n \n     /* read header */\n     if (datanode.isBlockTokenEnabled) {\n       try {\n         datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n             BlockTokenSecretManager.AccessMode.REPLACE);\n       } catch (InvalidToken e) {\n         LOG.warn(\"Invalid access token in request from \" + remoteAddress\n             + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n             + e.getLocalizedMessage());\n         sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n         return;\n       }\n     }\n \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n       String msg \u003d \"Not able to receive block \" + block.getBlockId() +\n           \" from \" + peer.getRemoteAddressString() + \" because threads \" +\n           \"quota is exceeded.\";\n       LOG.warn(msg);\n       sendResponse(ERROR, msg);\n       return;\n     }\n \n     Socket proxySock \u003d null;\n     DataOutputStream proxyOut \u003d null;\n     Status opStatus \u003d SUCCESS;\n     String errMsg \u003d null;\n     BlockReceiver blockReceiver \u003d null;\n     DataInputStream proxyReply \u003d null;\n     DataOutputStream replyOut \u003d new DataOutputStream(getOutputStream());\n     boolean IoeDuringCopyBlockOperation \u003d false;\n     try {\n       // Move the block to different storage in the same datanode\n       if (proxySource.equals(datanode.getDatanodeId())) {\n         ReplicaInfo oldReplica \u003d datanode.data.moveBlockAcrossStorage(block,\n             storageType);\n         if (oldReplica !\u003d null) {\n           LOG.info(\"Moved \" + block + \" from StorageType \"\n               + oldReplica.getVolume().getStorageType() + \" to \" + storageType);\n         }\n       } else {\n         block.setNumBytes(dataXceiverServer.estimateBlockSize);\n         // get the output stream to the proxy\n         final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Connecting to datanode \" + dnAddr);\n         }\n         InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n         proxySock \u003d datanode.newSocket();\n         NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n         proxySock.setSoTimeout(dnConf.socketTimeout);\n         \n         OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n             dnConf.socketWriteTimeout);\n         InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n         DataEncryptionKeyFactory keyFactory \u003d\n             datanode.getDataEncryptionKeyFactoryForBlock(block);\n         IOStreamPair saslStreams \u003d datanode.saslClient.socketSend(proxySock,\n             unbufProxyOut, unbufProxyIn, keyFactory, blockToken, proxySource);\n         unbufProxyOut \u003d saslStreams.out;\n         unbufProxyIn \u003d saslStreams.in;\n         \n         proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut, \n             HdfsConstants.SMALL_BUFFER_SIZE));\n         proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n             HdfsConstants.IO_FILE_BUFFER_SIZE));\n         \n         /* send request to the proxy */\n         IoeDuringCopyBlockOperation \u003d true;\n         new Sender(proxyOut).copyBlock(block, blockToken);\n         IoeDuringCopyBlockOperation \u003d false;\n         \n         // receive the response from the proxy\n         \n         BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n             PBHelper.vintPrefixed(proxyReply));\n         \n         if (copyResponse.getStatus() !\u003d SUCCESS) {\n           if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n             throw new IOException(\"Copy block \" + block + \" from \"\n                 + proxySock.getRemoteSocketAddress()\n                 + \" failed due to access token error\");\n           }\n           throw new IOException(\"Copy block \" + block + \" from \"\n               + proxySock.getRemoteSocketAddress() + \" failed\");\n         }\n         \n         // get checksum info about the block we\u0027re copying\n         ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n         DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n             checksumInfo.getChecksum());\n         // open a block receiver and check if the block does not exist\n         blockReceiver \u003d new BlockReceiver(block, storageType,\n             proxyReply, proxySock.getRemoteSocketAddress().toString(),\n             proxySock.getLocalSocketAddress().toString(),\n             null, 0, 0, 0, \"\", null, datanode, remoteChecksum,\n-            CachingStrategy.newDropBehind(), false);\n+            CachingStrategy.newDropBehind(), false, false);\n         \n         // receive a block\n         blockReceiver.receiveBlock(null, null, replyOut, null, \n             dataXceiverServer.balanceThrottler, null, true);\n         \n         // notify name node\n         datanode.notifyNamenodeReceivedBlock(\n             block, delHint, blockReceiver.getStorageUuid());\n         \n         LOG.info(\"Moved \" + block + \" from \" + peer.getRemoteAddressString()\n             + \", delHint\u003d\" + delHint);\n       }\n     } catch (IOException ioe) {\n       opStatus \u003d ERROR;\n       errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n       LOG.info(errMsg);\n       if (!IoeDuringCopyBlockOperation) {\n         // Don\u0027t double count IO errors\n         incrDatanodeNetworkErrors();\n       }\n       throw ioe;\n     } finally {\n       // receive the last byte that indicates the proxy released its thread resource\n       if (opStatus \u003d\u003d SUCCESS \u0026\u0026 proxyReply !\u003d null) {\n         try {\n           proxyReply.readChar();\n         } catch (IOException ignored) {\n         }\n       }\n       \n       // now release the thread resource\n       dataXceiverServer.balanceThrottler.release();\n       \n       // send response back\n       try {\n         sendResponse(opStatus, errMsg);\n       } catch (IOException ioe) {\n         LOG.warn(\"Error writing reply back to \" + peer.getRemoteAddressString());\n         incrDatanodeNetworkErrors();\n       }\n       IOUtils.closeStream(proxyOut);\n       IOUtils.closeStream(blockReceiver);\n       IOUtils.closeStream(proxyReply);\n       IOUtils.closeStream(replyOut);\n     }\n \n     //update metrics\n     datanode.metrics.addReplaceBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void replaceBlock(final ExtendedBlock block,\n      final StorageType storageType, \n      final Token\u003cBlockTokenIdentifier\u003e blockToken,\n      final String delHint,\n      final DatanodeInfo proxySource) throws IOException {\n    updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n\n    /* read header */\n    if (datanode.isBlockTokenEnabled) {\n      try {\n        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n            BlockTokenSecretManager.AccessMode.REPLACE);\n      } catch (InvalidToken e) {\n        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n            + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n            + e.getLocalizedMessage());\n        sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n        return;\n      }\n    }\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      String msg \u003d \"Not able to receive block \" + block.getBlockId() +\n          \" from \" + peer.getRemoteAddressString() + \" because threads \" +\n          \"quota is exceeded.\";\n      LOG.warn(msg);\n      sendResponse(ERROR, msg);\n      return;\n    }\n\n    Socket proxySock \u003d null;\n    DataOutputStream proxyOut \u003d null;\n    Status opStatus \u003d SUCCESS;\n    String errMsg \u003d null;\n    BlockReceiver blockReceiver \u003d null;\n    DataInputStream proxyReply \u003d null;\n    DataOutputStream replyOut \u003d new DataOutputStream(getOutputStream());\n    boolean IoeDuringCopyBlockOperation \u003d false;\n    try {\n      // Move the block to different storage in the same datanode\n      if (proxySource.equals(datanode.getDatanodeId())) {\n        ReplicaInfo oldReplica \u003d datanode.data.moveBlockAcrossStorage(block,\n            storageType);\n        if (oldReplica !\u003d null) {\n          LOG.info(\"Moved \" + block + \" from StorageType \"\n              + oldReplica.getVolume().getStorageType() + \" to \" + storageType);\n        }\n      } else {\n        block.setNumBytes(dataXceiverServer.estimateBlockSize);\n        // get the output stream to the proxy\n        final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Connecting to datanode \" + dnAddr);\n        }\n        InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n        proxySock \u003d datanode.newSocket();\n        NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n        proxySock.setSoTimeout(dnConf.socketTimeout);\n        \n        OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n            dnConf.socketWriteTimeout);\n        InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n        DataEncryptionKeyFactory keyFactory \u003d\n            datanode.getDataEncryptionKeyFactoryForBlock(block);\n        IOStreamPair saslStreams \u003d datanode.saslClient.socketSend(proxySock,\n            unbufProxyOut, unbufProxyIn, keyFactory, blockToken, proxySource);\n        unbufProxyOut \u003d saslStreams.out;\n        unbufProxyIn \u003d saslStreams.in;\n        \n        proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut, \n            HdfsConstants.SMALL_BUFFER_SIZE));\n        proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n            HdfsConstants.IO_FILE_BUFFER_SIZE));\n        \n        /* send request to the proxy */\n        IoeDuringCopyBlockOperation \u003d true;\n        new Sender(proxyOut).copyBlock(block, blockToken);\n        IoeDuringCopyBlockOperation \u003d false;\n        \n        // receive the response from the proxy\n        \n        BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n            PBHelper.vintPrefixed(proxyReply));\n        \n        if (copyResponse.getStatus() !\u003d SUCCESS) {\n          if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n            throw new IOException(\"Copy block \" + block + \" from \"\n                + proxySock.getRemoteSocketAddress()\n                + \" failed due to access token error\");\n          }\n          throw new IOException(\"Copy block \" + block + \" from \"\n              + proxySock.getRemoteSocketAddress() + \" failed\");\n        }\n        \n        // get checksum info about the block we\u0027re copying\n        ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n        DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n            checksumInfo.getChecksum());\n        // open a block receiver and check if the block does not exist\n        blockReceiver \u003d new BlockReceiver(block, storageType,\n            proxyReply, proxySock.getRemoteSocketAddress().toString(),\n            proxySock.getLocalSocketAddress().toString(),\n            null, 0, 0, 0, \"\", null, datanode, remoteChecksum,\n            CachingStrategy.newDropBehind(), false, false);\n        \n        // receive a block\n        blockReceiver.receiveBlock(null, null, replyOut, null, \n            dataXceiverServer.balanceThrottler, null, true);\n        \n        // notify name node\n        datanode.notifyNamenodeReceivedBlock(\n            block, delHint, blockReceiver.getStorageUuid());\n        \n        LOG.info(\"Moved \" + block + \" from \" + peer.getRemoteAddressString()\n            + \", delHint\u003d\" + delHint);\n      }\n    } catch (IOException ioe) {\n      opStatus \u003d ERROR;\n      errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n      LOG.info(errMsg);\n      if (!IoeDuringCopyBlockOperation) {\n        // Don\u0027t double count IO errors\n        incrDatanodeNetworkErrors();\n      }\n      throw ioe;\n    } finally {\n      // receive the last byte that indicates the proxy released its thread resource\n      if (opStatus \u003d\u003d SUCCESS \u0026\u0026 proxyReply !\u003d null) {\n        try {\n          proxyReply.readChar();\n        } catch (IOException ignored) {\n        }\n      }\n      \n      // now release the thread resource\n      dataXceiverServer.balanceThrottler.release();\n      \n      // send response back\n      try {\n        sendResponse(opStatus, errMsg);\n      } catch (IOException ioe) {\n        LOG.warn(\"Error writing reply back to \" + peer.getRemoteAddressString());\n        incrDatanodeNetworkErrors();\n      }\n      IOUtils.closeStream(proxyOut);\n      IOUtils.closeStream(blockReceiver);\n      IOUtils.closeStream(proxyReply);\n      IOUtils.closeStream(replyOut);\n    }\n\n    //update metrics\n    datanode.metrics.addReplaceBlockOp(elapsed());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "058af60c56207907f2bedf76df4284e86d923e0c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7310. Mover can give first priority to local DN if it has target storage type available in local DN. (Vinayakumar B via umamahesh)\n",
      "commitDate": "26/11/14 9:57 AM",
      "commitName": "058af60c56207907f2bedf76df4284e86d923e0c",
      "commitAuthor": "Uma Maheswara Rao G",
      "commitDateOld": "21/11/14 4:36 PM",
      "commitNameOld": "2d4f3e567e4bb8068c028de12df118a4f3fa6343",
      "commitAuthorOld": "Aaron T. Myers",
      "daysBetweenCommits": 4.72,
      "commitsBetweenForRepo": 24,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,144 +1,153 @@\n   public void replaceBlock(final ExtendedBlock block,\n       final StorageType storageType, \n       final Token\u003cBlockTokenIdentifier\u003e blockToken,\n       final String delHint,\n       final DatanodeInfo proxySource) throws IOException {\n     updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n \n     /* read header */\n-    block.setNumBytes(dataXceiverServer.estimateBlockSize);\n     if (datanode.isBlockTokenEnabled) {\n       try {\n         datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n             BlockTokenSecretManager.AccessMode.REPLACE);\n       } catch (InvalidToken e) {\n         LOG.warn(\"Invalid access token in request from \" + remoteAddress\n             + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n             + e.getLocalizedMessage());\n         sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n         return;\n       }\n     }\n \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n       String msg \u003d \"Not able to receive block \" + block.getBlockId() +\n           \" from \" + peer.getRemoteAddressString() + \" because threads \" +\n           \"quota is exceeded.\";\n       LOG.warn(msg);\n       sendResponse(ERROR, msg);\n       return;\n     }\n \n     Socket proxySock \u003d null;\n     DataOutputStream proxyOut \u003d null;\n     Status opStatus \u003d SUCCESS;\n     String errMsg \u003d null;\n     BlockReceiver blockReceiver \u003d null;\n     DataInputStream proxyReply \u003d null;\n     DataOutputStream replyOut \u003d new DataOutputStream(getOutputStream());\n     boolean IoeDuringCopyBlockOperation \u003d false;\n     try {\n-      // get the output stream to the proxy\n-      final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"Connecting to datanode \" + dnAddr);\n-      }\n-      InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n-      proxySock \u003d datanode.newSocket();\n-      NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n-      proxySock.setSoTimeout(dnConf.socketTimeout);\n-\n-      OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n-          dnConf.socketWriteTimeout);\n-      InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n-      DataEncryptionKeyFactory keyFactory \u003d\n-        datanode.getDataEncryptionKeyFactoryForBlock(block);\n-      IOStreamPair saslStreams \u003d datanode.saslClient.socketSend(proxySock,\n-        unbufProxyOut, unbufProxyIn, keyFactory, blockToken, proxySource);\n-      unbufProxyOut \u003d saslStreams.out;\n-      unbufProxyIn \u003d saslStreams.in;\n-      \n-      proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut, \n-          HdfsConstants.SMALL_BUFFER_SIZE));\n-      proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n-          HdfsConstants.IO_FILE_BUFFER_SIZE));\n-\n-      /* send request to the proxy */\n-      IoeDuringCopyBlockOperation \u003d true;\n-      new Sender(proxyOut).copyBlock(block, blockToken);\n-      IoeDuringCopyBlockOperation \u003d false;\n-\n-      // receive the response from the proxy\n-      \n-      BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n-          PBHelper.vintPrefixed(proxyReply));\n-\n-      if (copyResponse.getStatus() !\u003d SUCCESS) {\n-        if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n-          throw new IOException(\"Copy block \" + block + \" from \"\n-              + proxySock.getRemoteSocketAddress()\n-              + \" failed due to access token error\");\n+      // Move the block to different storage in the same datanode\n+      if (proxySource.equals(datanode.getDatanodeId())) {\n+        ReplicaInfo oldReplica \u003d datanode.data.moveBlockAcrossStorage(block,\n+            storageType);\n+        if (oldReplica !\u003d null) {\n+          LOG.info(\"Moved \" + block + \" from StorageType \"\n+              + oldReplica.getVolume().getStorageType() + \" to \" + storageType);\n         }\n-        throw new IOException(\"Copy block \" + block + \" from \"\n-            + proxySock.getRemoteSocketAddress() + \" failed\");\n+      } else {\n+        block.setNumBytes(dataXceiverServer.estimateBlockSize);\n+        // get the output stream to the proxy\n+        final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"Connecting to datanode \" + dnAddr);\n+        }\n+        InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n+        proxySock \u003d datanode.newSocket();\n+        NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n+        proxySock.setSoTimeout(dnConf.socketTimeout);\n+        \n+        OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n+            dnConf.socketWriteTimeout);\n+        InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n+        DataEncryptionKeyFactory keyFactory \u003d\n+            datanode.getDataEncryptionKeyFactoryForBlock(block);\n+        IOStreamPair saslStreams \u003d datanode.saslClient.socketSend(proxySock,\n+            unbufProxyOut, unbufProxyIn, keyFactory, blockToken, proxySource);\n+        unbufProxyOut \u003d saslStreams.out;\n+        unbufProxyIn \u003d saslStreams.in;\n+        \n+        proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut, \n+            HdfsConstants.SMALL_BUFFER_SIZE));\n+        proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n+            HdfsConstants.IO_FILE_BUFFER_SIZE));\n+        \n+        /* send request to the proxy */\n+        IoeDuringCopyBlockOperation \u003d true;\n+        new Sender(proxyOut).copyBlock(block, blockToken);\n+        IoeDuringCopyBlockOperation \u003d false;\n+        \n+        // receive the response from the proxy\n+        \n+        BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n+            PBHelper.vintPrefixed(proxyReply));\n+        \n+        if (copyResponse.getStatus() !\u003d SUCCESS) {\n+          if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n+            throw new IOException(\"Copy block \" + block + \" from \"\n+                + proxySock.getRemoteSocketAddress()\n+                + \" failed due to access token error\");\n+          }\n+          throw new IOException(\"Copy block \" + block + \" from \"\n+              + proxySock.getRemoteSocketAddress() + \" failed\");\n+        }\n+        \n+        // get checksum info about the block we\u0027re copying\n+        ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n+        DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n+            checksumInfo.getChecksum());\n+        // open a block receiver and check if the block does not exist\n+        blockReceiver \u003d new BlockReceiver(block, storageType,\n+            proxyReply, proxySock.getRemoteSocketAddress().toString(),\n+            proxySock.getLocalSocketAddress().toString(),\n+            null, 0, 0, 0, \"\", null, datanode, remoteChecksum,\n+            CachingStrategy.newDropBehind(), false);\n+        \n+        // receive a block\n+        blockReceiver.receiveBlock(null, null, replyOut, null, \n+            dataXceiverServer.balanceThrottler, null, true);\n+        \n+        // notify name node\n+        datanode.notifyNamenodeReceivedBlock(\n+            block, delHint, blockReceiver.getStorageUuid());\n+        \n+        LOG.info(\"Moved \" + block + \" from \" + peer.getRemoteAddressString()\n+            + \", delHint\u003d\" + delHint);\n       }\n-      \n-      // get checksum info about the block we\u0027re copying\n-      ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n-      DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n-          checksumInfo.getChecksum());\n-      // open a block receiver and check if the block does not exist\n-      blockReceiver \u003d new BlockReceiver(block, storageType,\n-          proxyReply, proxySock.getRemoteSocketAddress().toString(),\n-          proxySock.getLocalSocketAddress().toString(),\n-          null, 0, 0, 0, \"\", null, datanode, remoteChecksum,\n-          CachingStrategy.newDropBehind(), false);\n-\n-      // receive a block\n-      blockReceiver.receiveBlock(null, null, replyOut, null, \n-          dataXceiverServer.balanceThrottler, null, true);\n-                    \n-      // notify name node\n-      datanode.notifyNamenodeReceivedBlock(\n-          block, delHint, blockReceiver.getStorageUuid());\n-\n-      LOG.info(\"Moved \" + block + \" from \" + peer.getRemoteAddressString()\n-          + \", delHint\u003d\" + delHint);\n-      \n     } catch (IOException ioe) {\n       opStatus \u003d ERROR;\n       errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n       LOG.info(errMsg);\n       if (!IoeDuringCopyBlockOperation) {\n         // Don\u0027t double count IO errors\n         incrDatanodeNetworkErrors();\n       }\n       throw ioe;\n     } finally {\n       // receive the last byte that indicates the proxy released its thread resource\n-      if (opStatus \u003d\u003d SUCCESS) {\n+      if (opStatus \u003d\u003d SUCCESS \u0026\u0026 proxyReply !\u003d null) {\n         try {\n           proxyReply.readChar();\n         } catch (IOException ignored) {\n         }\n       }\n       \n       // now release the thread resource\n       dataXceiverServer.balanceThrottler.release();\n       \n       // send response back\n       try {\n         sendResponse(opStatus, errMsg);\n       } catch (IOException ioe) {\n         LOG.warn(\"Error writing reply back to \" + peer.getRemoteAddressString());\n         incrDatanodeNetworkErrors();\n       }\n       IOUtils.closeStream(proxyOut);\n       IOUtils.closeStream(blockReceiver);\n       IOUtils.closeStream(proxyReply);\n       IOUtils.closeStream(replyOut);\n     }\n \n     //update metrics\n     datanode.metrics.addReplaceBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void replaceBlock(final ExtendedBlock block,\n      final StorageType storageType, \n      final Token\u003cBlockTokenIdentifier\u003e blockToken,\n      final String delHint,\n      final DatanodeInfo proxySource) throws IOException {\n    updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n\n    /* read header */\n    if (datanode.isBlockTokenEnabled) {\n      try {\n        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n            BlockTokenSecretManager.AccessMode.REPLACE);\n      } catch (InvalidToken e) {\n        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n            + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n            + e.getLocalizedMessage());\n        sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n        return;\n      }\n    }\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      String msg \u003d \"Not able to receive block \" + block.getBlockId() +\n          \" from \" + peer.getRemoteAddressString() + \" because threads \" +\n          \"quota is exceeded.\";\n      LOG.warn(msg);\n      sendResponse(ERROR, msg);\n      return;\n    }\n\n    Socket proxySock \u003d null;\n    DataOutputStream proxyOut \u003d null;\n    Status opStatus \u003d SUCCESS;\n    String errMsg \u003d null;\n    BlockReceiver blockReceiver \u003d null;\n    DataInputStream proxyReply \u003d null;\n    DataOutputStream replyOut \u003d new DataOutputStream(getOutputStream());\n    boolean IoeDuringCopyBlockOperation \u003d false;\n    try {\n      // Move the block to different storage in the same datanode\n      if (proxySource.equals(datanode.getDatanodeId())) {\n        ReplicaInfo oldReplica \u003d datanode.data.moveBlockAcrossStorage(block,\n            storageType);\n        if (oldReplica !\u003d null) {\n          LOG.info(\"Moved \" + block + \" from StorageType \"\n              + oldReplica.getVolume().getStorageType() + \" to \" + storageType);\n        }\n      } else {\n        block.setNumBytes(dataXceiverServer.estimateBlockSize);\n        // get the output stream to the proxy\n        final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Connecting to datanode \" + dnAddr);\n        }\n        InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n        proxySock \u003d datanode.newSocket();\n        NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n        proxySock.setSoTimeout(dnConf.socketTimeout);\n        \n        OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n            dnConf.socketWriteTimeout);\n        InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n        DataEncryptionKeyFactory keyFactory \u003d\n            datanode.getDataEncryptionKeyFactoryForBlock(block);\n        IOStreamPair saslStreams \u003d datanode.saslClient.socketSend(proxySock,\n            unbufProxyOut, unbufProxyIn, keyFactory, blockToken, proxySource);\n        unbufProxyOut \u003d saslStreams.out;\n        unbufProxyIn \u003d saslStreams.in;\n        \n        proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut, \n            HdfsConstants.SMALL_BUFFER_SIZE));\n        proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n            HdfsConstants.IO_FILE_BUFFER_SIZE));\n        \n        /* send request to the proxy */\n        IoeDuringCopyBlockOperation \u003d true;\n        new Sender(proxyOut).copyBlock(block, blockToken);\n        IoeDuringCopyBlockOperation \u003d false;\n        \n        // receive the response from the proxy\n        \n        BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n            PBHelper.vintPrefixed(proxyReply));\n        \n        if (copyResponse.getStatus() !\u003d SUCCESS) {\n          if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n            throw new IOException(\"Copy block \" + block + \" from \"\n                + proxySock.getRemoteSocketAddress()\n                + \" failed due to access token error\");\n          }\n          throw new IOException(\"Copy block \" + block + \" from \"\n              + proxySock.getRemoteSocketAddress() + \" failed\");\n        }\n        \n        // get checksum info about the block we\u0027re copying\n        ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n        DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n            checksumInfo.getChecksum());\n        // open a block receiver and check if the block does not exist\n        blockReceiver \u003d new BlockReceiver(block, storageType,\n            proxyReply, proxySock.getRemoteSocketAddress().toString(),\n            proxySock.getLocalSocketAddress().toString(),\n            null, 0, 0, 0, \"\", null, datanode, remoteChecksum,\n            CachingStrategy.newDropBehind(), false);\n        \n        // receive a block\n        blockReceiver.receiveBlock(null, null, replyOut, null, \n            dataXceiverServer.balanceThrottler, null, true);\n        \n        // notify name node\n        datanode.notifyNamenodeReceivedBlock(\n            block, delHint, blockReceiver.getStorageUuid());\n        \n        LOG.info(\"Moved \" + block + \" from \" + peer.getRemoteAddressString()\n            + \", delHint\u003d\" + delHint);\n      }\n    } catch (IOException ioe) {\n      opStatus \u003d ERROR;\n      errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n      LOG.info(errMsg);\n      if (!IoeDuringCopyBlockOperation) {\n        // Don\u0027t double count IO errors\n        incrDatanodeNetworkErrors();\n      }\n      throw ioe;\n    } finally {\n      // receive the last byte that indicates the proxy released its thread resource\n      if (opStatus \u003d\u003d SUCCESS \u0026\u0026 proxyReply !\u003d null) {\n        try {\n          proxyReply.readChar();\n        } catch (IOException ignored) {\n        }\n      }\n      \n      // now release the thread resource\n      dataXceiverServer.balanceThrottler.release();\n      \n      // send response back\n      try {\n        sendResponse(opStatus, errMsg);\n      } catch (IOException ioe) {\n        LOG.warn(\"Error writing reply back to \" + peer.getRemoteAddressString());\n        incrDatanodeNetworkErrors();\n      }\n      IOUtils.closeStream(proxyOut);\n      IOUtils.closeStream(blockReceiver);\n      IOUtils.closeStream(proxyReply);\n      IOUtils.closeStream(replyOut);\n    }\n\n    //update metrics\n    datanode.metrics.addReplaceBlockOp(elapsed());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "2d4f3e567e4bb8068c028de12df118a4f3fa6343": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7331. Add Datanode network counts to datanode jmx page. Contributed by Charles Lamb.\n",
      "commitDate": "21/11/14 4:36 PM",
      "commitName": "2d4f3e567e4bb8068c028de12df118a4f3fa6343",
      "commitAuthor": "Aaron T. Myers",
      "commitDateOld": "08/11/14 10:24 PM",
      "commitNameOld": "9ba8d8c7eb65eeb6fe673f04e493d9eedd95a822",
      "commitAuthorOld": "cnauroth",
      "daysBetweenCommits": 12.76,
      "commitsBetweenForRepo": 104,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,144 +1,144 @@\n   public void replaceBlock(final ExtendedBlock block,\n       final StorageType storageType, \n       final Token\u003cBlockTokenIdentifier\u003e blockToken,\n       final String delHint,\n       final DatanodeInfo proxySource) throws IOException {\n     updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n \n     /* read header */\n     block.setNumBytes(dataXceiverServer.estimateBlockSize);\n     if (datanode.isBlockTokenEnabled) {\n       try {\n         datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n             BlockTokenSecretManager.AccessMode.REPLACE);\n       } catch (InvalidToken e) {\n         LOG.warn(\"Invalid access token in request from \" + remoteAddress\n             + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n             + e.getLocalizedMessage());\n         sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n         return;\n       }\n     }\n \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n       String msg \u003d \"Not able to receive block \" + block.getBlockId() +\n           \" from \" + peer.getRemoteAddressString() + \" because threads \" +\n           \"quota is exceeded.\";\n       LOG.warn(msg);\n       sendResponse(ERROR, msg);\n       return;\n     }\n \n     Socket proxySock \u003d null;\n     DataOutputStream proxyOut \u003d null;\n     Status opStatus \u003d SUCCESS;\n     String errMsg \u003d null;\n     BlockReceiver blockReceiver \u003d null;\n     DataInputStream proxyReply \u003d null;\n     DataOutputStream replyOut \u003d new DataOutputStream(getOutputStream());\n     boolean IoeDuringCopyBlockOperation \u003d false;\n     try {\n       // get the output stream to the proxy\n       final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Connecting to datanode \" + dnAddr);\n       }\n       InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n       proxySock \u003d datanode.newSocket();\n       NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n       proxySock.setSoTimeout(dnConf.socketTimeout);\n \n       OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n           dnConf.socketWriteTimeout);\n       InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n       DataEncryptionKeyFactory keyFactory \u003d\n         datanode.getDataEncryptionKeyFactoryForBlock(block);\n       IOStreamPair saslStreams \u003d datanode.saslClient.socketSend(proxySock,\n         unbufProxyOut, unbufProxyIn, keyFactory, blockToken, proxySource);\n       unbufProxyOut \u003d saslStreams.out;\n       unbufProxyIn \u003d saslStreams.in;\n       \n       proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut, \n           HdfsConstants.SMALL_BUFFER_SIZE));\n       proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n           HdfsConstants.IO_FILE_BUFFER_SIZE));\n \n       /* send request to the proxy */\n       IoeDuringCopyBlockOperation \u003d true;\n       new Sender(proxyOut).copyBlock(block, blockToken);\n       IoeDuringCopyBlockOperation \u003d false;\n \n       // receive the response from the proxy\n       \n       BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n           PBHelper.vintPrefixed(proxyReply));\n \n       if (copyResponse.getStatus() !\u003d SUCCESS) {\n         if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n           throw new IOException(\"Copy block \" + block + \" from \"\n               + proxySock.getRemoteSocketAddress()\n               + \" failed due to access token error\");\n         }\n         throw new IOException(\"Copy block \" + block + \" from \"\n             + proxySock.getRemoteSocketAddress() + \" failed\");\n       }\n       \n       // get checksum info about the block we\u0027re copying\n       ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n       DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n           checksumInfo.getChecksum());\n       // open a block receiver and check if the block does not exist\n       blockReceiver \u003d new BlockReceiver(block, storageType,\n           proxyReply, proxySock.getRemoteSocketAddress().toString(),\n           proxySock.getLocalSocketAddress().toString(),\n           null, 0, 0, 0, \"\", null, datanode, remoteChecksum,\n           CachingStrategy.newDropBehind(), false);\n \n       // receive a block\n       blockReceiver.receiveBlock(null, null, replyOut, null, \n           dataXceiverServer.balanceThrottler, null, true);\n                     \n       // notify name node\n       datanode.notifyNamenodeReceivedBlock(\n           block, delHint, blockReceiver.getStorageUuid());\n \n       LOG.info(\"Moved \" + block + \" from \" + peer.getRemoteAddressString()\n           + \", delHint\u003d\" + delHint);\n       \n     } catch (IOException ioe) {\n       opStatus \u003d ERROR;\n       errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n       LOG.info(errMsg);\n       if (!IoeDuringCopyBlockOperation) {\n         // Don\u0027t double count IO errors\n-        datanode.metrics.incrDatanodeNetworkErrors();\n+        incrDatanodeNetworkErrors();\n       }\n       throw ioe;\n     } finally {\n       // receive the last byte that indicates the proxy released its thread resource\n       if (opStatus \u003d\u003d SUCCESS) {\n         try {\n           proxyReply.readChar();\n         } catch (IOException ignored) {\n         }\n       }\n       \n       // now release the thread resource\n       dataXceiverServer.balanceThrottler.release();\n       \n       // send response back\n       try {\n         sendResponse(opStatus, errMsg);\n       } catch (IOException ioe) {\n         LOG.warn(\"Error writing reply back to \" + peer.getRemoteAddressString());\n-        datanode.metrics.incrDatanodeNetworkErrors();\n+        incrDatanodeNetworkErrors();\n       }\n       IOUtils.closeStream(proxyOut);\n       IOUtils.closeStream(blockReceiver);\n       IOUtils.closeStream(proxyReply);\n       IOUtils.closeStream(replyOut);\n     }\n \n     //update metrics\n     datanode.metrics.addReplaceBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void replaceBlock(final ExtendedBlock block,\n      final StorageType storageType, \n      final Token\u003cBlockTokenIdentifier\u003e blockToken,\n      final String delHint,\n      final DatanodeInfo proxySource) throws IOException {\n    updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n\n    /* read header */\n    block.setNumBytes(dataXceiverServer.estimateBlockSize);\n    if (datanode.isBlockTokenEnabled) {\n      try {\n        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n            BlockTokenSecretManager.AccessMode.REPLACE);\n      } catch (InvalidToken e) {\n        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n            + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n            + e.getLocalizedMessage());\n        sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n        return;\n      }\n    }\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      String msg \u003d \"Not able to receive block \" + block.getBlockId() +\n          \" from \" + peer.getRemoteAddressString() + \" because threads \" +\n          \"quota is exceeded.\";\n      LOG.warn(msg);\n      sendResponse(ERROR, msg);\n      return;\n    }\n\n    Socket proxySock \u003d null;\n    DataOutputStream proxyOut \u003d null;\n    Status opStatus \u003d SUCCESS;\n    String errMsg \u003d null;\n    BlockReceiver blockReceiver \u003d null;\n    DataInputStream proxyReply \u003d null;\n    DataOutputStream replyOut \u003d new DataOutputStream(getOutputStream());\n    boolean IoeDuringCopyBlockOperation \u003d false;\n    try {\n      // get the output stream to the proxy\n      final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Connecting to datanode \" + dnAddr);\n      }\n      InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n      proxySock \u003d datanode.newSocket();\n      NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n      proxySock.setSoTimeout(dnConf.socketTimeout);\n\n      OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n          dnConf.socketWriteTimeout);\n      InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n      DataEncryptionKeyFactory keyFactory \u003d\n        datanode.getDataEncryptionKeyFactoryForBlock(block);\n      IOStreamPair saslStreams \u003d datanode.saslClient.socketSend(proxySock,\n        unbufProxyOut, unbufProxyIn, keyFactory, blockToken, proxySource);\n      unbufProxyOut \u003d saslStreams.out;\n      unbufProxyIn \u003d saslStreams.in;\n      \n      proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut, \n          HdfsConstants.SMALL_BUFFER_SIZE));\n      proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n          HdfsConstants.IO_FILE_BUFFER_SIZE));\n\n      /* send request to the proxy */\n      IoeDuringCopyBlockOperation \u003d true;\n      new Sender(proxyOut).copyBlock(block, blockToken);\n      IoeDuringCopyBlockOperation \u003d false;\n\n      // receive the response from the proxy\n      \n      BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n          PBHelper.vintPrefixed(proxyReply));\n\n      if (copyResponse.getStatus() !\u003d SUCCESS) {\n        if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n          throw new IOException(\"Copy block \" + block + \" from \"\n              + proxySock.getRemoteSocketAddress()\n              + \" failed due to access token error\");\n        }\n        throw new IOException(\"Copy block \" + block + \" from \"\n            + proxySock.getRemoteSocketAddress() + \" failed\");\n      }\n      \n      // get checksum info about the block we\u0027re copying\n      ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n      DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n          checksumInfo.getChecksum());\n      // open a block receiver and check if the block does not exist\n      blockReceiver \u003d new BlockReceiver(block, storageType,\n          proxyReply, proxySock.getRemoteSocketAddress().toString(),\n          proxySock.getLocalSocketAddress().toString(),\n          null, 0, 0, 0, \"\", null, datanode, remoteChecksum,\n          CachingStrategy.newDropBehind(), false);\n\n      // receive a block\n      blockReceiver.receiveBlock(null, null, replyOut, null, \n          dataXceiverServer.balanceThrottler, null, true);\n                    \n      // notify name node\n      datanode.notifyNamenodeReceivedBlock(\n          block, delHint, blockReceiver.getStorageUuid());\n\n      LOG.info(\"Moved \" + block + \" from \" + peer.getRemoteAddressString()\n          + \", delHint\u003d\" + delHint);\n      \n    } catch (IOException ioe) {\n      opStatus \u003d ERROR;\n      errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n      LOG.info(errMsg);\n      if (!IoeDuringCopyBlockOperation) {\n        // Don\u0027t double count IO errors\n        incrDatanodeNetworkErrors();\n      }\n      throw ioe;\n    } finally {\n      // receive the last byte that indicates the proxy released its thread resource\n      if (opStatus \u003d\u003d SUCCESS) {\n        try {\n          proxyReply.readChar();\n        } catch (IOException ignored) {\n        }\n      }\n      \n      // now release the thread resource\n      dataXceiverServer.balanceThrottler.release();\n      \n      // send response back\n      try {\n        sendResponse(opStatus, errMsg);\n      } catch (IOException ioe) {\n        LOG.warn(\"Error writing reply back to \" + peer.getRemoteAddressString());\n        incrDatanodeNetworkErrors();\n      }\n      IOUtils.closeStream(proxyOut);\n      IOUtils.closeStream(blockReceiver);\n      IOUtils.closeStream(proxyReply);\n      IOUtils.closeStream(replyOut);\n    }\n\n    //update metrics\n    datanode.metrics.addReplaceBlockOp(elapsed());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "86cad007d7d6366b293bb9a073814889081c8662": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7222. Expose DataNode network errors as a metric. (Charles Lamb via wang)\n",
      "commitDate": "23/10/14 12:53 PM",
      "commitName": "86cad007d7d6366b293bb9a073814889081c8662",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "27/08/14 9:47 PM",
      "commitNameOld": "a317bd7b02c37bd57743bfad59593ec12f53f4ed",
      "commitAuthorOld": "arp",
      "daysBetweenCommits": 56.63,
      "commitsBetweenForRepo": 574,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,136 +1,144 @@\n   public void replaceBlock(final ExtendedBlock block,\n       final StorageType storageType, \n       final Token\u003cBlockTokenIdentifier\u003e blockToken,\n       final String delHint,\n       final DatanodeInfo proxySource) throws IOException {\n     updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n \n     /* read header */\n     block.setNumBytes(dataXceiverServer.estimateBlockSize);\n     if (datanode.isBlockTokenEnabled) {\n       try {\n         datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n             BlockTokenSecretManager.AccessMode.REPLACE);\n       } catch (InvalidToken e) {\n         LOG.warn(\"Invalid access token in request from \" + remoteAddress\n             + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n             + e.getLocalizedMessage());\n         sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n         return;\n       }\n     }\n \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n       String msg \u003d \"Not able to receive block \" + block.getBlockId() +\n           \" from \" + peer.getRemoteAddressString() + \" because threads \" +\n           \"quota is exceeded.\";\n       LOG.warn(msg);\n       sendResponse(ERROR, msg);\n       return;\n     }\n \n     Socket proxySock \u003d null;\n     DataOutputStream proxyOut \u003d null;\n     Status opStatus \u003d SUCCESS;\n     String errMsg \u003d null;\n     BlockReceiver blockReceiver \u003d null;\n     DataInputStream proxyReply \u003d null;\n     DataOutputStream replyOut \u003d new DataOutputStream(getOutputStream());\n+    boolean IoeDuringCopyBlockOperation \u003d false;\n     try {\n       // get the output stream to the proxy\n       final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Connecting to datanode \" + dnAddr);\n       }\n       InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n       proxySock \u003d datanode.newSocket();\n       NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n       proxySock.setSoTimeout(dnConf.socketTimeout);\n \n       OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n           dnConf.socketWriteTimeout);\n       InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n       DataEncryptionKeyFactory keyFactory \u003d\n         datanode.getDataEncryptionKeyFactoryForBlock(block);\n       IOStreamPair saslStreams \u003d datanode.saslClient.socketSend(proxySock,\n         unbufProxyOut, unbufProxyIn, keyFactory, blockToken, proxySource);\n       unbufProxyOut \u003d saslStreams.out;\n       unbufProxyIn \u003d saslStreams.in;\n       \n       proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut, \n           HdfsConstants.SMALL_BUFFER_SIZE));\n       proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n           HdfsConstants.IO_FILE_BUFFER_SIZE));\n \n       /* send request to the proxy */\n+      IoeDuringCopyBlockOperation \u003d true;\n       new Sender(proxyOut).copyBlock(block, blockToken);\n+      IoeDuringCopyBlockOperation \u003d false;\n \n       // receive the response from the proxy\n       \n       BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n           PBHelper.vintPrefixed(proxyReply));\n \n       if (copyResponse.getStatus() !\u003d SUCCESS) {\n         if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n           throw new IOException(\"Copy block \" + block + \" from \"\n               + proxySock.getRemoteSocketAddress()\n               + \" failed due to access token error\");\n         }\n         throw new IOException(\"Copy block \" + block + \" from \"\n             + proxySock.getRemoteSocketAddress() + \" failed\");\n       }\n       \n       // get checksum info about the block we\u0027re copying\n       ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n       DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n           checksumInfo.getChecksum());\n       // open a block receiver and check if the block does not exist\n       blockReceiver \u003d new BlockReceiver(block, storageType,\n           proxyReply, proxySock.getRemoteSocketAddress().toString(),\n           proxySock.getLocalSocketAddress().toString(),\n           null, 0, 0, 0, \"\", null, datanode, remoteChecksum,\n           CachingStrategy.newDropBehind(), false);\n \n       // receive a block\n       blockReceiver.receiveBlock(null, null, replyOut, null, \n           dataXceiverServer.balanceThrottler, null, true);\n                     \n       // notify name node\n       datanode.notifyNamenodeReceivedBlock(\n           block, delHint, blockReceiver.getStorageUuid());\n \n       LOG.info(\"Moved \" + block + \" from \" + peer.getRemoteAddressString()\n           + \", delHint\u003d\" + delHint);\n       \n     } catch (IOException ioe) {\n       opStatus \u003d ERROR;\n       errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n       LOG.info(errMsg);\n+      if (!IoeDuringCopyBlockOperation) {\n+        // Don\u0027t double count IO errors\n+        datanode.metrics.incrDatanodeNetworkErrors();\n+      }\n       throw ioe;\n     } finally {\n       // receive the last byte that indicates the proxy released its thread resource\n       if (opStatus \u003d\u003d SUCCESS) {\n         try {\n           proxyReply.readChar();\n         } catch (IOException ignored) {\n         }\n       }\n       \n       // now release the thread resource\n       dataXceiverServer.balanceThrottler.release();\n       \n       // send response back\n       try {\n         sendResponse(opStatus, errMsg);\n       } catch (IOException ioe) {\n         LOG.warn(\"Error writing reply back to \" + peer.getRemoteAddressString());\n+        datanode.metrics.incrDatanodeNetworkErrors();\n       }\n       IOUtils.closeStream(proxyOut);\n       IOUtils.closeStream(blockReceiver);\n       IOUtils.closeStream(proxyReply);\n       IOUtils.closeStream(replyOut);\n     }\n \n     //update metrics\n     datanode.metrics.addReplaceBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void replaceBlock(final ExtendedBlock block,\n      final StorageType storageType, \n      final Token\u003cBlockTokenIdentifier\u003e blockToken,\n      final String delHint,\n      final DatanodeInfo proxySource) throws IOException {\n    updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n\n    /* read header */\n    block.setNumBytes(dataXceiverServer.estimateBlockSize);\n    if (datanode.isBlockTokenEnabled) {\n      try {\n        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n            BlockTokenSecretManager.AccessMode.REPLACE);\n      } catch (InvalidToken e) {\n        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n            + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n            + e.getLocalizedMessage());\n        sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n        return;\n      }\n    }\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      String msg \u003d \"Not able to receive block \" + block.getBlockId() +\n          \" from \" + peer.getRemoteAddressString() + \" because threads \" +\n          \"quota is exceeded.\";\n      LOG.warn(msg);\n      sendResponse(ERROR, msg);\n      return;\n    }\n\n    Socket proxySock \u003d null;\n    DataOutputStream proxyOut \u003d null;\n    Status opStatus \u003d SUCCESS;\n    String errMsg \u003d null;\n    BlockReceiver blockReceiver \u003d null;\n    DataInputStream proxyReply \u003d null;\n    DataOutputStream replyOut \u003d new DataOutputStream(getOutputStream());\n    boolean IoeDuringCopyBlockOperation \u003d false;\n    try {\n      // get the output stream to the proxy\n      final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Connecting to datanode \" + dnAddr);\n      }\n      InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n      proxySock \u003d datanode.newSocket();\n      NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n      proxySock.setSoTimeout(dnConf.socketTimeout);\n\n      OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n          dnConf.socketWriteTimeout);\n      InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n      DataEncryptionKeyFactory keyFactory \u003d\n        datanode.getDataEncryptionKeyFactoryForBlock(block);\n      IOStreamPair saslStreams \u003d datanode.saslClient.socketSend(proxySock,\n        unbufProxyOut, unbufProxyIn, keyFactory, blockToken, proxySource);\n      unbufProxyOut \u003d saslStreams.out;\n      unbufProxyIn \u003d saslStreams.in;\n      \n      proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut, \n          HdfsConstants.SMALL_BUFFER_SIZE));\n      proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n          HdfsConstants.IO_FILE_BUFFER_SIZE));\n\n      /* send request to the proxy */\n      IoeDuringCopyBlockOperation \u003d true;\n      new Sender(proxyOut).copyBlock(block, blockToken);\n      IoeDuringCopyBlockOperation \u003d false;\n\n      // receive the response from the proxy\n      \n      BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n          PBHelper.vintPrefixed(proxyReply));\n\n      if (copyResponse.getStatus() !\u003d SUCCESS) {\n        if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n          throw new IOException(\"Copy block \" + block + \" from \"\n              + proxySock.getRemoteSocketAddress()\n              + \" failed due to access token error\");\n        }\n        throw new IOException(\"Copy block \" + block + \" from \"\n            + proxySock.getRemoteSocketAddress() + \" failed\");\n      }\n      \n      // get checksum info about the block we\u0027re copying\n      ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n      DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n          checksumInfo.getChecksum());\n      // open a block receiver and check if the block does not exist\n      blockReceiver \u003d new BlockReceiver(block, storageType,\n          proxyReply, proxySock.getRemoteSocketAddress().toString(),\n          proxySock.getLocalSocketAddress().toString(),\n          null, 0, 0, 0, \"\", null, datanode, remoteChecksum,\n          CachingStrategy.newDropBehind(), false);\n\n      // receive a block\n      blockReceiver.receiveBlock(null, null, replyOut, null, \n          dataXceiverServer.balanceThrottler, null, true);\n                    \n      // notify name node\n      datanode.notifyNamenodeReceivedBlock(\n          block, delHint, blockReceiver.getStorageUuid());\n\n      LOG.info(\"Moved \" + block + \" from \" + peer.getRemoteAddressString()\n          + \", delHint\u003d\" + delHint);\n      \n    } catch (IOException ioe) {\n      opStatus \u003d ERROR;\n      errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n      LOG.info(errMsg);\n      if (!IoeDuringCopyBlockOperation) {\n        // Don\u0027t double count IO errors\n        datanode.metrics.incrDatanodeNetworkErrors();\n      }\n      throw ioe;\n    } finally {\n      // receive the last byte that indicates the proxy released its thread resource\n      if (opStatus \u003d\u003d SUCCESS) {\n        try {\n          proxyReply.readChar();\n        } catch (IOException ignored) {\n        }\n      }\n      \n      // now release the thread resource\n      dataXceiverServer.balanceThrottler.release();\n      \n      // send response back\n      try {\n        sendResponse(opStatus, errMsg);\n      } catch (IOException ioe) {\n        LOG.warn(\"Error writing reply back to \" + peer.getRemoteAddressString());\n        datanode.metrics.incrDatanodeNetworkErrors();\n      }\n      IOUtils.closeStream(proxyOut);\n      IOUtils.closeStream(blockReceiver);\n      IOUtils.closeStream(proxyReply);\n      IOUtils.closeStream(replyOut);\n    }\n\n    //update metrics\n    datanode.metrics.addReplaceBlockOp(elapsed());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "a317bd7b02c37bd57743bfad59593ec12f53f4ed": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6925. DataNode should attempt to place replicas on transient storage first if lazyPersist flag is received. (Arpit Agarwal)\n",
      "commitDate": "27/08/14 9:47 PM",
      "commitName": "a317bd7b02c37bd57743bfad59593ec12f53f4ed",
      "commitAuthor": "arp",
      "commitDateOld": "27/08/14 9:47 PM",
      "commitNameOld": "c2354a7f81ff5a48a5b65d25e1036d3e0ba86420",
      "commitAuthorOld": "arp",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,136 +1,136 @@\n   public void replaceBlock(final ExtendedBlock block,\n       final StorageType storageType, \n       final Token\u003cBlockTokenIdentifier\u003e blockToken,\n       final String delHint,\n       final DatanodeInfo proxySource) throws IOException {\n     updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n \n     /* read header */\n     block.setNumBytes(dataXceiverServer.estimateBlockSize);\n     if (datanode.isBlockTokenEnabled) {\n       try {\n         datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n             BlockTokenSecretManager.AccessMode.REPLACE);\n       } catch (InvalidToken e) {\n         LOG.warn(\"Invalid access token in request from \" + remoteAddress\n             + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n             + e.getLocalizedMessage());\n         sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n         return;\n       }\n     }\n \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n       String msg \u003d \"Not able to receive block \" + block.getBlockId() +\n           \" from \" + peer.getRemoteAddressString() + \" because threads \" +\n           \"quota is exceeded.\";\n       LOG.warn(msg);\n       sendResponse(ERROR, msg);\n       return;\n     }\n \n     Socket proxySock \u003d null;\n     DataOutputStream proxyOut \u003d null;\n     Status opStatus \u003d SUCCESS;\n     String errMsg \u003d null;\n     BlockReceiver blockReceiver \u003d null;\n     DataInputStream proxyReply \u003d null;\n     DataOutputStream replyOut \u003d new DataOutputStream(getOutputStream());\n     try {\n       // get the output stream to the proxy\n       final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Connecting to datanode \" + dnAddr);\n       }\n       InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n       proxySock \u003d datanode.newSocket();\n       NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n       proxySock.setSoTimeout(dnConf.socketTimeout);\n \n       OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n           dnConf.socketWriteTimeout);\n       InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n       DataEncryptionKeyFactory keyFactory \u003d\n         datanode.getDataEncryptionKeyFactoryForBlock(block);\n       IOStreamPair saslStreams \u003d datanode.saslClient.socketSend(proxySock,\n         unbufProxyOut, unbufProxyIn, keyFactory, blockToken, proxySource);\n       unbufProxyOut \u003d saslStreams.out;\n       unbufProxyIn \u003d saslStreams.in;\n       \n       proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut, \n           HdfsConstants.SMALL_BUFFER_SIZE));\n       proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n           HdfsConstants.IO_FILE_BUFFER_SIZE));\n \n       /* send request to the proxy */\n       new Sender(proxyOut).copyBlock(block, blockToken);\n \n       // receive the response from the proxy\n       \n       BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n           PBHelper.vintPrefixed(proxyReply));\n \n       if (copyResponse.getStatus() !\u003d SUCCESS) {\n         if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n           throw new IOException(\"Copy block \" + block + \" from \"\n               + proxySock.getRemoteSocketAddress()\n               + \" failed due to access token error\");\n         }\n         throw new IOException(\"Copy block \" + block + \" from \"\n             + proxySock.getRemoteSocketAddress() + \" failed\");\n       }\n       \n       // get checksum info about the block we\u0027re copying\n       ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n       DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n           checksumInfo.getChecksum());\n       // open a block receiver and check if the block does not exist\n       blockReceiver \u003d new BlockReceiver(block, storageType,\n           proxyReply, proxySock.getRemoteSocketAddress().toString(),\n           proxySock.getLocalSocketAddress().toString(),\n           null, 0, 0, 0, \"\", null, datanode, remoteChecksum,\n-          CachingStrategy.newDropBehind());\n+          CachingStrategy.newDropBehind(), false);\n \n       // receive a block\n       blockReceiver.receiveBlock(null, null, replyOut, null, \n           dataXceiverServer.balanceThrottler, null, true);\n                     \n       // notify name node\n       datanode.notifyNamenodeReceivedBlock(\n           block, delHint, blockReceiver.getStorageUuid());\n \n       LOG.info(\"Moved \" + block + \" from \" + peer.getRemoteAddressString()\n           + \", delHint\u003d\" + delHint);\n       \n     } catch (IOException ioe) {\n       opStatus \u003d ERROR;\n       errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n       LOG.info(errMsg);\n       throw ioe;\n     } finally {\n       // receive the last byte that indicates the proxy released its thread resource\n       if (opStatus \u003d\u003d SUCCESS) {\n         try {\n           proxyReply.readChar();\n         } catch (IOException ignored) {\n         }\n       }\n       \n       // now release the thread resource\n       dataXceiverServer.balanceThrottler.release();\n       \n       // send response back\n       try {\n         sendResponse(opStatus, errMsg);\n       } catch (IOException ioe) {\n         LOG.warn(\"Error writing reply back to \" + peer.getRemoteAddressString());\n       }\n       IOUtils.closeStream(proxyOut);\n       IOUtils.closeStream(blockReceiver);\n       IOUtils.closeStream(proxyReply);\n       IOUtils.closeStream(replyOut);\n     }\n \n     //update metrics\n     datanode.metrics.addReplaceBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void replaceBlock(final ExtendedBlock block,\n      final StorageType storageType, \n      final Token\u003cBlockTokenIdentifier\u003e blockToken,\n      final String delHint,\n      final DatanodeInfo proxySource) throws IOException {\n    updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n\n    /* read header */\n    block.setNumBytes(dataXceiverServer.estimateBlockSize);\n    if (datanode.isBlockTokenEnabled) {\n      try {\n        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n            BlockTokenSecretManager.AccessMode.REPLACE);\n      } catch (InvalidToken e) {\n        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n            + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n            + e.getLocalizedMessage());\n        sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n        return;\n      }\n    }\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      String msg \u003d \"Not able to receive block \" + block.getBlockId() +\n          \" from \" + peer.getRemoteAddressString() + \" because threads \" +\n          \"quota is exceeded.\";\n      LOG.warn(msg);\n      sendResponse(ERROR, msg);\n      return;\n    }\n\n    Socket proxySock \u003d null;\n    DataOutputStream proxyOut \u003d null;\n    Status opStatus \u003d SUCCESS;\n    String errMsg \u003d null;\n    BlockReceiver blockReceiver \u003d null;\n    DataInputStream proxyReply \u003d null;\n    DataOutputStream replyOut \u003d new DataOutputStream(getOutputStream());\n    try {\n      // get the output stream to the proxy\n      final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Connecting to datanode \" + dnAddr);\n      }\n      InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n      proxySock \u003d datanode.newSocket();\n      NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n      proxySock.setSoTimeout(dnConf.socketTimeout);\n\n      OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n          dnConf.socketWriteTimeout);\n      InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n      DataEncryptionKeyFactory keyFactory \u003d\n        datanode.getDataEncryptionKeyFactoryForBlock(block);\n      IOStreamPair saslStreams \u003d datanode.saslClient.socketSend(proxySock,\n        unbufProxyOut, unbufProxyIn, keyFactory, blockToken, proxySource);\n      unbufProxyOut \u003d saslStreams.out;\n      unbufProxyIn \u003d saslStreams.in;\n      \n      proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut, \n          HdfsConstants.SMALL_BUFFER_SIZE));\n      proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n          HdfsConstants.IO_FILE_BUFFER_SIZE));\n\n      /* send request to the proxy */\n      new Sender(proxyOut).copyBlock(block, blockToken);\n\n      // receive the response from the proxy\n      \n      BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n          PBHelper.vintPrefixed(proxyReply));\n\n      if (copyResponse.getStatus() !\u003d SUCCESS) {\n        if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n          throw new IOException(\"Copy block \" + block + \" from \"\n              + proxySock.getRemoteSocketAddress()\n              + \" failed due to access token error\");\n        }\n        throw new IOException(\"Copy block \" + block + \" from \"\n            + proxySock.getRemoteSocketAddress() + \" failed\");\n      }\n      \n      // get checksum info about the block we\u0027re copying\n      ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n      DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n          checksumInfo.getChecksum());\n      // open a block receiver and check if the block does not exist\n      blockReceiver \u003d new BlockReceiver(block, storageType,\n          proxyReply, proxySock.getRemoteSocketAddress().toString(),\n          proxySock.getLocalSocketAddress().toString(),\n          null, 0, 0, 0, \"\", null, datanode, remoteChecksum,\n          CachingStrategy.newDropBehind(), false);\n\n      // receive a block\n      blockReceiver.receiveBlock(null, null, replyOut, null, \n          dataXceiverServer.balanceThrottler, null, true);\n                    \n      // notify name node\n      datanode.notifyNamenodeReceivedBlock(\n          block, delHint, blockReceiver.getStorageUuid());\n\n      LOG.info(\"Moved \" + block + \" from \" + peer.getRemoteAddressString()\n          + \", delHint\u003d\" + delHint);\n      \n    } catch (IOException ioe) {\n      opStatus \u003d ERROR;\n      errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n      LOG.info(errMsg);\n      throw ioe;\n    } finally {\n      // receive the last byte that indicates the proxy released its thread resource\n      if (opStatus \u003d\u003d SUCCESS) {\n        try {\n          proxyReply.readChar();\n        } catch (IOException ignored) {\n        }\n      }\n      \n      // now release the thread resource\n      dataXceiverServer.balanceThrottler.release();\n      \n      // send response back\n      try {\n        sendResponse(opStatus, errMsg);\n      } catch (IOException ioe) {\n        LOG.warn(\"Error writing reply back to \" + peer.getRemoteAddressString());\n      }\n      IOUtils.closeStream(proxyOut);\n      IOUtils.closeStream(blockReceiver);\n      IOUtils.closeStream(proxyReply);\n      IOUtils.closeStream(replyOut);\n    }\n\n    //update metrics\n    datanode.metrics.addReplaceBlockOp(elapsed());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "195961a7c1da86421761162836766b1de07930fd": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6247. Avoid timeouts for replaceBlock() call by sending intermediate responses to Balancer (vinayakumarb)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1617799 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "13/08/14 11:43 AM",
      "commitName": "195961a7c1da86421761162836766b1de07930fd",
      "commitAuthor": "Vinayakumar B",
      "commitDateOld": "13/08/14 11:36 AM",
      "commitNameOld": "6554994fab2d8a2a139fb71ed54be144f4057e08",
      "commitAuthorOld": "Vinayakumar B",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,135 +1,136 @@\n   public void replaceBlock(final ExtendedBlock block,\n       final StorageType storageType, \n       final Token\u003cBlockTokenIdentifier\u003e blockToken,\n       final String delHint,\n       final DatanodeInfo proxySource) throws IOException {\n     updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n \n     /* read header */\n     block.setNumBytes(dataXceiverServer.estimateBlockSize);\n     if (datanode.isBlockTokenEnabled) {\n       try {\n         datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n             BlockTokenSecretManager.AccessMode.REPLACE);\n       } catch (InvalidToken e) {\n         LOG.warn(\"Invalid access token in request from \" + remoteAddress\n             + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n             + e.getLocalizedMessage());\n         sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n         return;\n       }\n     }\n \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n       String msg \u003d \"Not able to receive block \" + block.getBlockId() +\n           \" from \" + peer.getRemoteAddressString() + \" because threads \" +\n           \"quota is exceeded.\";\n       LOG.warn(msg);\n       sendResponse(ERROR, msg);\n       return;\n     }\n \n     Socket proxySock \u003d null;\n     DataOutputStream proxyOut \u003d null;\n     Status opStatus \u003d SUCCESS;\n     String errMsg \u003d null;\n     BlockReceiver blockReceiver \u003d null;\n     DataInputStream proxyReply \u003d null;\n-    \n+    DataOutputStream replyOut \u003d new DataOutputStream(getOutputStream());\n     try {\n       // get the output stream to the proxy\n       final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Connecting to datanode \" + dnAddr);\n       }\n       InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n       proxySock \u003d datanode.newSocket();\n       NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n       proxySock.setSoTimeout(dnConf.socketTimeout);\n \n       OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n           dnConf.socketWriteTimeout);\n       InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n       DataEncryptionKeyFactory keyFactory \u003d\n         datanode.getDataEncryptionKeyFactoryForBlock(block);\n       IOStreamPair saslStreams \u003d datanode.saslClient.socketSend(proxySock,\n         unbufProxyOut, unbufProxyIn, keyFactory, blockToken, proxySource);\n       unbufProxyOut \u003d saslStreams.out;\n       unbufProxyIn \u003d saslStreams.in;\n       \n       proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut, \n           HdfsConstants.SMALL_BUFFER_SIZE));\n       proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n           HdfsConstants.IO_FILE_BUFFER_SIZE));\n \n       /* send request to the proxy */\n       new Sender(proxyOut).copyBlock(block, blockToken);\n \n       // receive the response from the proxy\n       \n       BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n           PBHelper.vintPrefixed(proxyReply));\n \n       if (copyResponse.getStatus() !\u003d SUCCESS) {\n         if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n           throw new IOException(\"Copy block \" + block + \" from \"\n               + proxySock.getRemoteSocketAddress()\n               + \" failed due to access token error\");\n         }\n         throw new IOException(\"Copy block \" + block + \" from \"\n             + proxySock.getRemoteSocketAddress() + \" failed\");\n       }\n       \n       // get checksum info about the block we\u0027re copying\n       ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n       DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n           checksumInfo.getChecksum());\n       // open a block receiver and check if the block does not exist\n       blockReceiver \u003d new BlockReceiver(block, storageType,\n           proxyReply, proxySock.getRemoteSocketAddress().toString(),\n           proxySock.getLocalSocketAddress().toString(),\n           null, 0, 0, 0, \"\", null, datanode, remoteChecksum,\n           CachingStrategy.newDropBehind());\n \n       // receive a block\n-      blockReceiver.receiveBlock(null, null, null, null, \n-          dataXceiverServer.balanceThrottler, null);\n+      blockReceiver.receiveBlock(null, null, replyOut, null, \n+          dataXceiverServer.balanceThrottler, null, true);\n                     \n       // notify name node\n       datanode.notifyNamenodeReceivedBlock(\n           block, delHint, blockReceiver.getStorageUuid());\n \n       LOG.info(\"Moved \" + block + \" from \" + peer.getRemoteAddressString()\n           + \", delHint\u003d\" + delHint);\n       \n     } catch (IOException ioe) {\n       opStatus \u003d ERROR;\n       errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n       LOG.info(errMsg);\n       throw ioe;\n     } finally {\n       // receive the last byte that indicates the proxy released its thread resource\n       if (opStatus \u003d\u003d SUCCESS) {\n         try {\n           proxyReply.readChar();\n         } catch (IOException ignored) {\n         }\n       }\n       \n       // now release the thread resource\n       dataXceiverServer.balanceThrottler.release();\n       \n       // send response back\n       try {\n         sendResponse(opStatus, errMsg);\n       } catch (IOException ioe) {\n         LOG.warn(\"Error writing reply back to \" + peer.getRemoteAddressString());\n       }\n       IOUtils.closeStream(proxyOut);\n       IOUtils.closeStream(blockReceiver);\n       IOUtils.closeStream(proxyReply);\n+      IOUtils.closeStream(replyOut);\n     }\n \n     //update metrics\n     datanode.metrics.addReplaceBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void replaceBlock(final ExtendedBlock block,\n      final StorageType storageType, \n      final Token\u003cBlockTokenIdentifier\u003e blockToken,\n      final String delHint,\n      final DatanodeInfo proxySource) throws IOException {\n    updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n\n    /* read header */\n    block.setNumBytes(dataXceiverServer.estimateBlockSize);\n    if (datanode.isBlockTokenEnabled) {\n      try {\n        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n            BlockTokenSecretManager.AccessMode.REPLACE);\n      } catch (InvalidToken e) {\n        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n            + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n            + e.getLocalizedMessage());\n        sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n        return;\n      }\n    }\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      String msg \u003d \"Not able to receive block \" + block.getBlockId() +\n          \" from \" + peer.getRemoteAddressString() + \" because threads \" +\n          \"quota is exceeded.\";\n      LOG.warn(msg);\n      sendResponse(ERROR, msg);\n      return;\n    }\n\n    Socket proxySock \u003d null;\n    DataOutputStream proxyOut \u003d null;\n    Status opStatus \u003d SUCCESS;\n    String errMsg \u003d null;\n    BlockReceiver blockReceiver \u003d null;\n    DataInputStream proxyReply \u003d null;\n    DataOutputStream replyOut \u003d new DataOutputStream(getOutputStream());\n    try {\n      // get the output stream to the proxy\n      final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Connecting to datanode \" + dnAddr);\n      }\n      InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n      proxySock \u003d datanode.newSocket();\n      NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n      proxySock.setSoTimeout(dnConf.socketTimeout);\n\n      OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n          dnConf.socketWriteTimeout);\n      InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n      DataEncryptionKeyFactory keyFactory \u003d\n        datanode.getDataEncryptionKeyFactoryForBlock(block);\n      IOStreamPair saslStreams \u003d datanode.saslClient.socketSend(proxySock,\n        unbufProxyOut, unbufProxyIn, keyFactory, blockToken, proxySource);\n      unbufProxyOut \u003d saslStreams.out;\n      unbufProxyIn \u003d saslStreams.in;\n      \n      proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut, \n          HdfsConstants.SMALL_BUFFER_SIZE));\n      proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n          HdfsConstants.IO_FILE_BUFFER_SIZE));\n\n      /* send request to the proxy */\n      new Sender(proxyOut).copyBlock(block, blockToken);\n\n      // receive the response from the proxy\n      \n      BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n          PBHelper.vintPrefixed(proxyReply));\n\n      if (copyResponse.getStatus() !\u003d SUCCESS) {\n        if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n          throw new IOException(\"Copy block \" + block + \" from \"\n              + proxySock.getRemoteSocketAddress()\n              + \" failed due to access token error\");\n        }\n        throw new IOException(\"Copy block \" + block + \" from \"\n            + proxySock.getRemoteSocketAddress() + \" failed\");\n      }\n      \n      // get checksum info about the block we\u0027re copying\n      ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n      DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n          checksumInfo.getChecksum());\n      // open a block receiver and check if the block does not exist\n      blockReceiver \u003d new BlockReceiver(block, storageType,\n          proxyReply, proxySock.getRemoteSocketAddress().toString(),\n          proxySock.getLocalSocketAddress().toString(),\n          null, 0, 0, 0, \"\", null, datanode, remoteChecksum,\n          CachingStrategy.newDropBehind());\n\n      // receive a block\n      blockReceiver.receiveBlock(null, null, replyOut, null, \n          dataXceiverServer.balanceThrottler, null, true);\n                    \n      // notify name node\n      datanode.notifyNamenodeReceivedBlock(\n          block, delHint, blockReceiver.getStorageUuid());\n\n      LOG.info(\"Moved \" + block + \" from \" + peer.getRemoteAddressString()\n          + \", delHint\u003d\" + delHint);\n      \n    } catch (IOException ioe) {\n      opStatus \u003d ERROR;\n      errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n      LOG.info(errMsg);\n      throw ioe;\n    } finally {\n      // receive the last byte that indicates the proxy released its thread resource\n      if (opStatus \u003d\u003d SUCCESS) {\n        try {\n          proxyReply.readChar();\n        } catch (IOException ignored) {\n        }\n      }\n      \n      // now release the thread resource\n      dataXceiverServer.balanceThrottler.release();\n      \n      // send response back\n      try {\n        sendResponse(opStatus, errMsg);\n      } catch (IOException ioe) {\n        LOG.warn(\"Error writing reply back to \" + peer.getRemoteAddressString());\n      }\n      IOUtils.closeStream(proxyOut);\n      IOUtils.closeStream(blockReceiver);\n      IOUtils.closeStream(proxyReply);\n      IOUtils.closeStream(replyOut);\n    }\n\n    //update metrics\n    datanode.metrics.addReplaceBlockOp(elapsed());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "6554994fab2d8a2a139fb71ed54be144f4057e08": {
      "type": "Ybodychange",
      "commitMessage": "Reverted\nMerged revision(s) 1617784 from hadoop/common/trunk:\nHDFS-6847. Avoid timeouts for replaceBlock() call by sending intermediate responses to Balancer (Contributed by Vinayakumar B.)\n........\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1617794 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "13/08/14 11:36 AM",
      "commitName": "6554994fab2d8a2a139fb71ed54be144f4057e08",
      "commitAuthor": "Vinayakumar B",
      "commitDateOld": "13/08/14 11:06 AM",
      "commitNameOld": "471b1368e2a81b4d9850f0f4d98d31df1451354c",
      "commitAuthorOld": "Vinayakumar B",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,136 +1,135 @@\n   public void replaceBlock(final ExtendedBlock block,\n       final StorageType storageType, \n       final Token\u003cBlockTokenIdentifier\u003e blockToken,\n       final String delHint,\n       final DatanodeInfo proxySource) throws IOException {\n     updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n \n     /* read header */\n     block.setNumBytes(dataXceiverServer.estimateBlockSize);\n     if (datanode.isBlockTokenEnabled) {\n       try {\n         datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n             BlockTokenSecretManager.AccessMode.REPLACE);\n       } catch (InvalidToken e) {\n         LOG.warn(\"Invalid access token in request from \" + remoteAddress\n             + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n             + e.getLocalizedMessage());\n         sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n         return;\n       }\n     }\n \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n       String msg \u003d \"Not able to receive block \" + block.getBlockId() +\n           \" from \" + peer.getRemoteAddressString() + \" because threads \" +\n           \"quota is exceeded.\";\n       LOG.warn(msg);\n       sendResponse(ERROR, msg);\n       return;\n     }\n \n     Socket proxySock \u003d null;\n     DataOutputStream proxyOut \u003d null;\n     Status opStatus \u003d SUCCESS;\n     String errMsg \u003d null;\n     BlockReceiver blockReceiver \u003d null;\n     DataInputStream proxyReply \u003d null;\n-    DataOutputStream replyOut \u003d new DataOutputStream(getOutputStream());\n+    \n     try {\n       // get the output stream to the proxy\n       final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Connecting to datanode \" + dnAddr);\n       }\n       InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n       proxySock \u003d datanode.newSocket();\n       NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n       proxySock.setSoTimeout(dnConf.socketTimeout);\n \n       OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n           dnConf.socketWriteTimeout);\n       InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n       DataEncryptionKeyFactory keyFactory \u003d\n         datanode.getDataEncryptionKeyFactoryForBlock(block);\n       IOStreamPair saslStreams \u003d datanode.saslClient.socketSend(proxySock,\n         unbufProxyOut, unbufProxyIn, keyFactory, blockToken, proxySource);\n       unbufProxyOut \u003d saslStreams.out;\n       unbufProxyIn \u003d saslStreams.in;\n       \n       proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut, \n           HdfsConstants.SMALL_BUFFER_SIZE));\n       proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n           HdfsConstants.IO_FILE_BUFFER_SIZE));\n \n       /* send request to the proxy */\n       new Sender(proxyOut).copyBlock(block, blockToken);\n \n       // receive the response from the proxy\n       \n       BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n           PBHelper.vintPrefixed(proxyReply));\n \n       if (copyResponse.getStatus() !\u003d SUCCESS) {\n         if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n           throw new IOException(\"Copy block \" + block + \" from \"\n               + proxySock.getRemoteSocketAddress()\n               + \" failed due to access token error\");\n         }\n         throw new IOException(\"Copy block \" + block + \" from \"\n             + proxySock.getRemoteSocketAddress() + \" failed\");\n       }\n       \n       // get checksum info about the block we\u0027re copying\n       ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n       DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n           checksumInfo.getChecksum());\n       // open a block receiver and check if the block does not exist\n       blockReceiver \u003d new BlockReceiver(block, storageType,\n           proxyReply, proxySock.getRemoteSocketAddress().toString(),\n           proxySock.getLocalSocketAddress().toString(),\n           null, 0, 0, 0, \"\", null, datanode, remoteChecksum,\n           CachingStrategy.newDropBehind());\n \n       // receive a block\n-      blockReceiver.receiveBlock(null, null, replyOut, null, \n-          dataXceiverServer.balanceThrottler, null, true);\n+      blockReceiver.receiveBlock(null, null, null, null, \n+          dataXceiverServer.balanceThrottler, null);\n                     \n       // notify name node\n       datanode.notifyNamenodeReceivedBlock(\n           block, delHint, blockReceiver.getStorageUuid());\n \n       LOG.info(\"Moved \" + block + \" from \" + peer.getRemoteAddressString()\n           + \", delHint\u003d\" + delHint);\n       \n     } catch (IOException ioe) {\n       opStatus \u003d ERROR;\n       errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n       LOG.info(errMsg);\n       throw ioe;\n     } finally {\n       // receive the last byte that indicates the proxy released its thread resource\n       if (opStatus \u003d\u003d SUCCESS) {\n         try {\n           proxyReply.readChar();\n         } catch (IOException ignored) {\n         }\n       }\n       \n       // now release the thread resource\n       dataXceiverServer.balanceThrottler.release();\n       \n       // send response back\n       try {\n         sendResponse(opStatus, errMsg);\n       } catch (IOException ioe) {\n         LOG.warn(\"Error writing reply back to \" + peer.getRemoteAddressString());\n       }\n       IOUtils.closeStream(proxyOut);\n       IOUtils.closeStream(blockReceiver);\n       IOUtils.closeStream(proxyReply);\n-      IOUtils.closeStream(replyOut);\n     }\n \n     //update metrics\n     datanode.metrics.addReplaceBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void replaceBlock(final ExtendedBlock block,\n      final StorageType storageType, \n      final Token\u003cBlockTokenIdentifier\u003e blockToken,\n      final String delHint,\n      final DatanodeInfo proxySource) throws IOException {\n    updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n\n    /* read header */\n    block.setNumBytes(dataXceiverServer.estimateBlockSize);\n    if (datanode.isBlockTokenEnabled) {\n      try {\n        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n            BlockTokenSecretManager.AccessMode.REPLACE);\n      } catch (InvalidToken e) {\n        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n            + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n            + e.getLocalizedMessage());\n        sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n        return;\n      }\n    }\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      String msg \u003d \"Not able to receive block \" + block.getBlockId() +\n          \" from \" + peer.getRemoteAddressString() + \" because threads \" +\n          \"quota is exceeded.\";\n      LOG.warn(msg);\n      sendResponse(ERROR, msg);\n      return;\n    }\n\n    Socket proxySock \u003d null;\n    DataOutputStream proxyOut \u003d null;\n    Status opStatus \u003d SUCCESS;\n    String errMsg \u003d null;\n    BlockReceiver blockReceiver \u003d null;\n    DataInputStream proxyReply \u003d null;\n    \n    try {\n      // get the output stream to the proxy\n      final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Connecting to datanode \" + dnAddr);\n      }\n      InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n      proxySock \u003d datanode.newSocket();\n      NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n      proxySock.setSoTimeout(dnConf.socketTimeout);\n\n      OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n          dnConf.socketWriteTimeout);\n      InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n      DataEncryptionKeyFactory keyFactory \u003d\n        datanode.getDataEncryptionKeyFactoryForBlock(block);\n      IOStreamPair saslStreams \u003d datanode.saslClient.socketSend(proxySock,\n        unbufProxyOut, unbufProxyIn, keyFactory, blockToken, proxySource);\n      unbufProxyOut \u003d saslStreams.out;\n      unbufProxyIn \u003d saslStreams.in;\n      \n      proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut, \n          HdfsConstants.SMALL_BUFFER_SIZE));\n      proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n          HdfsConstants.IO_FILE_BUFFER_SIZE));\n\n      /* send request to the proxy */\n      new Sender(proxyOut).copyBlock(block, blockToken);\n\n      // receive the response from the proxy\n      \n      BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n          PBHelper.vintPrefixed(proxyReply));\n\n      if (copyResponse.getStatus() !\u003d SUCCESS) {\n        if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n          throw new IOException(\"Copy block \" + block + \" from \"\n              + proxySock.getRemoteSocketAddress()\n              + \" failed due to access token error\");\n        }\n        throw new IOException(\"Copy block \" + block + \" from \"\n            + proxySock.getRemoteSocketAddress() + \" failed\");\n      }\n      \n      // get checksum info about the block we\u0027re copying\n      ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n      DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n          checksumInfo.getChecksum());\n      // open a block receiver and check if the block does not exist\n      blockReceiver \u003d new BlockReceiver(block, storageType,\n          proxyReply, proxySock.getRemoteSocketAddress().toString(),\n          proxySock.getLocalSocketAddress().toString(),\n          null, 0, 0, 0, \"\", null, datanode, remoteChecksum,\n          CachingStrategy.newDropBehind());\n\n      // receive a block\n      blockReceiver.receiveBlock(null, null, null, null, \n          dataXceiverServer.balanceThrottler, null);\n                    \n      // notify name node\n      datanode.notifyNamenodeReceivedBlock(\n          block, delHint, blockReceiver.getStorageUuid());\n\n      LOG.info(\"Moved \" + block + \" from \" + peer.getRemoteAddressString()\n          + \", delHint\u003d\" + delHint);\n      \n    } catch (IOException ioe) {\n      opStatus \u003d ERROR;\n      errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n      LOG.info(errMsg);\n      throw ioe;\n    } finally {\n      // receive the last byte that indicates the proxy released its thread resource\n      if (opStatus \u003d\u003d SUCCESS) {\n        try {\n          proxyReply.readChar();\n        } catch (IOException ignored) {\n        }\n      }\n      \n      // now release the thread resource\n      dataXceiverServer.balanceThrottler.release();\n      \n      // send response back\n      try {\n        sendResponse(opStatus, errMsg);\n      } catch (IOException ioe) {\n        LOG.warn(\"Error writing reply back to \" + peer.getRemoteAddressString());\n      }\n      IOUtils.closeStream(proxyOut);\n      IOUtils.closeStream(blockReceiver);\n      IOUtils.closeStream(proxyReply);\n    }\n\n    //update metrics\n    datanode.metrics.addReplaceBlockOp(elapsed());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "471b1368e2a81b4d9850f0f4d98d31df1451354c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6847. Avoid timeouts for replaceBlock() call by sending intermediate responses to Balancer (Contributed by Vinayakumar B.)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1617784 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "13/08/14 11:06 AM",
      "commitName": "471b1368e2a81b4d9850f0f4d98d31df1451354c",
      "commitAuthor": "Vinayakumar B",
      "commitDateOld": "22/07/14 12:41 AM",
      "commitNameOld": "25b0e8471ed744578b2d8e3f0debe5477b268e54",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 22.43,
      "commitsBetweenForRepo": 167,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,135 +1,136 @@\n   public void replaceBlock(final ExtendedBlock block,\n       final StorageType storageType, \n       final Token\u003cBlockTokenIdentifier\u003e blockToken,\n       final String delHint,\n       final DatanodeInfo proxySource) throws IOException {\n     updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n \n     /* read header */\n     block.setNumBytes(dataXceiverServer.estimateBlockSize);\n     if (datanode.isBlockTokenEnabled) {\n       try {\n         datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n             BlockTokenSecretManager.AccessMode.REPLACE);\n       } catch (InvalidToken e) {\n         LOG.warn(\"Invalid access token in request from \" + remoteAddress\n             + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n             + e.getLocalizedMessage());\n         sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n         return;\n       }\n     }\n \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n       String msg \u003d \"Not able to receive block \" + block.getBlockId() +\n           \" from \" + peer.getRemoteAddressString() + \" because threads \" +\n           \"quota is exceeded.\";\n       LOG.warn(msg);\n       sendResponse(ERROR, msg);\n       return;\n     }\n \n     Socket proxySock \u003d null;\n     DataOutputStream proxyOut \u003d null;\n     Status opStatus \u003d SUCCESS;\n     String errMsg \u003d null;\n     BlockReceiver blockReceiver \u003d null;\n     DataInputStream proxyReply \u003d null;\n-    \n+    DataOutputStream replyOut \u003d new DataOutputStream(getOutputStream());\n     try {\n       // get the output stream to the proxy\n       final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Connecting to datanode \" + dnAddr);\n       }\n       InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n       proxySock \u003d datanode.newSocket();\n       NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n       proxySock.setSoTimeout(dnConf.socketTimeout);\n \n       OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n           dnConf.socketWriteTimeout);\n       InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n       DataEncryptionKeyFactory keyFactory \u003d\n         datanode.getDataEncryptionKeyFactoryForBlock(block);\n       IOStreamPair saslStreams \u003d datanode.saslClient.socketSend(proxySock,\n         unbufProxyOut, unbufProxyIn, keyFactory, blockToken, proxySource);\n       unbufProxyOut \u003d saslStreams.out;\n       unbufProxyIn \u003d saslStreams.in;\n       \n       proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut, \n           HdfsConstants.SMALL_BUFFER_SIZE));\n       proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n           HdfsConstants.IO_FILE_BUFFER_SIZE));\n \n       /* send request to the proxy */\n       new Sender(proxyOut).copyBlock(block, blockToken);\n \n       // receive the response from the proxy\n       \n       BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n           PBHelper.vintPrefixed(proxyReply));\n \n       if (copyResponse.getStatus() !\u003d SUCCESS) {\n         if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n           throw new IOException(\"Copy block \" + block + \" from \"\n               + proxySock.getRemoteSocketAddress()\n               + \" failed due to access token error\");\n         }\n         throw new IOException(\"Copy block \" + block + \" from \"\n             + proxySock.getRemoteSocketAddress() + \" failed\");\n       }\n       \n       // get checksum info about the block we\u0027re copying\n       ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n       DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n           checksumInfo.getChecksum());\n       // open a block receiver and check if the block does not exist\n       blockReceiver \u003d new BlockReceiver(block, storageType,\n           proxyReply, proxySock.getRemoteSocketAddress().toString(),\n           proxySock.getLocalSocketAddress().toString(),\n           null, 0, 0, 0, \"\", null, datanode, remoteChecksum,\n           CachingStrategy.newDropBehind());\n \n       // receive a block\n-      blockReceiver.receiveBlock(null, null, null, null, \n-          dataXceiverServer.balanceThrottler, null);\n+      blockReceiver.receiveBlock(null, null, replyOut, null, \n+          dataXceiverServer.balanceThrottler, null, true);\n                     \n       // notify name node\n       datanode.notifyNamenodeReceivedBlock(\n           block, delHint, blockReceiver.getStorageUuid());\n \n       LOG.info(\"Moved \" + block + \" from \" + peer.getRemoteAddressString()\n           + \", delHint\u003d\" + delHint);\n       \n     } catch (IOException ioe) {\n       opStatus \u003d ERROR;\n       errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n       LOG.info(errMsg);\n       throw ioe;\n     } finally {\n       // receive the last byte that indicates the proxy released its thread resource\n       if (opStatus \u003d\u003d SUCCESS) {\n         try {\n           proxyReply.readChar();\n         } catch (IOException ignored) {\n         }\n       }\n       \n       // now release the thread resource\n       dataXceiverServer.balanceThrottler.release();\n       \n       // send response back\n       try {\n         sendResponse(opStatus, errMsg);\n       } catch (IOException ioe) {\n         LOG.warn(\"Error writing reply back to \" + peer.getRemoteAddressString());\n       }\n       IOUtils.closeStream(proxyOut);\n       IOUtils.closeStream(blockReceiver);\n       IOUtils.closeStream(proxyReply);\n+      IOUtils.closeStream(replyOut);\n     }\n \n     //update metrics\n     datanode.metrics.addReplaceBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void replaceBlock(final ExtendedBlock block,\n      final StorageType storageType, \n      final Token\u003cBlockTokenIdentifier\u003e blockToken,\n      final String delHint,\n      final DatanodeInfo proxySource) throws IOException {\n    updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n\n    /* read header */\n    block.setNumBytes(dataXceiverServer.estimateBlockSize);\n    if (datanode.isBlockTokenEnabled) {\n      try {\n        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n            BlockTokenSecretManager.AccessMode.REPLACE);\n      } catch (InvalidToken e) {\n        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n            + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n            + e.getLocalizedMessage());\n        sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n        return;\n      }\n    }\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      String msg \u003d \"Not able to receive block \" + block.getBlockId() +\n          \" from \" + peer.getRemoteAddressString() + \" because threads \" +\n          \"quota is exceeded.\";\n      LOG.warn(msg);\n      sendResponse(ERROR, msg);\n      return;\n    }\n\n    Socket proxySock \u003d null;\n    DataOutputStream proxyOut \u003d null;\n    Status opStatus \u003d SUCCESS;\n    String errMsg \u003d null;\n    BlockReceiver blockReceiver \u003d null;\n    DataInputStream proxyReply \u003d null;\n    DataOutputStream replyOut \u003d new DataOutputStream(getOutputStream());\n    try {\n      // get the output stream to the proxy\n      final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Connecting to datanode \" + dnAddr);\n      }\n      InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n      proxySock \u003d datanode.newSocket();\n      NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n      proxySock.setSoTimeout(dnConf.socketTimeout);\n\n      OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n          dnConf.socketWriteTimeout);\n      InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n      DataEncryptionKeyFactory keyFactory \u003d\n        datanode.getDataEncryptionKeyFactoryForBlock(block);\n      IOStreamPair saslStreams \u003d datanode.saslClient.socketSend(proxySock,\n        unbufProxyOut, unbufProxyIn, keyFactory, blockToken, proxySource);\n      unbufProxyOut \u003d saslStreams.out;\n      unbufProxyIn \u003d saslStreams.in;\n      \n      proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut, \n          HdfsConstants.SMALL_BUFFER_SIZE));\n      proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n          HdfsConstants.IO_FILE_BUFFER_SIZE));\n\n      /* send request to the proxy */\n      new Sender(proxyOut).copyBlock(block, blockToken);\n\n      // receive the response from the proxy\n      \n      BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n          PBHelper.vintPrefixed(proxyReply));\n\n      if (copyResponse.getStatus() !\u003d SUCCESS) {\n        if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n          throw new IOException(\"Copy block \" + block + \" from \"\n              + proxySock.getRemoteSocketAddress()\n              + \" failed due to access token error\");\n        }\n        throw new IOException(\"Copy block \" + block + \" from \"\n            + proxySock.getRemoteSocketAddress() + \" failed\");\n      }\n      \n      // get checksum info about the block we\u0027re copying\n      ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n      DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n          checksumInfo.getChecksum());\n      // open a block receiver and check if the block does not exist\n      blockReceiver \u003d new BlockReceiver(block, storageType,\n          proxyReply, proxySock.getRemoteSocketAddress().toString(),\n          proxySock.getLocalSocketAddress().toString(),\n          null, 0, 0, 0, \"\", null, datanode, remoteChecksum,\n          CachingStrategy.newDropBehind());\n\n      // receive a block\n      blockReceiver.receiveBlock(null, null, replyOut, null, \n          dataXceiverServer.balanceThrottler, null, true);\n                    \n      // notify name node\n      datanode.notifyNamenodeReceivedBlock(\n          block, delHint, blockReceiver.getStorageUuid());\n\n      LOG.info(\"Moved \" + block + \" from \" + peer.getRemoteAddressString()\n          + \", delHint\u003d\" + delHint);\n      \n    } catch (IOException ioe) {\n      opStatus \u003d ERROR;\n      errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n      LOG.info(errMsg);\n      throw ioe;\n    } finally {\n      // receive the last byte that indicates the proxy released its thread resource\n      if (opStatus \u003d\u003d SUCCESS) {\n        try {\n          proxyReply.readChar();\n        } catch (IOException ignored) {\n        }\n      }\n      \n      // now release the thread resource\n      dataXceiverServer.balanceThrottler.release();\n      \n      // send response back\n      try {\n        sendResponse(opStatus, errMsg);\n      } catch (IOException ioe) {\n        LOG.warn(\"Error writing reply back to \" + peer.getRemoteAddressString());\n      }\n      IOUtils.closeStream(proxyOut);\n      IOUtils.closeStream(blockReceiver);\n      IOUtils.closeStream(proxyReply);\n      IOUtils.closeStream(replyOut);\n    }\n\n    //update metrics\n    datanode.metrics.addReplaceBlockOp(elapsed());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "25b0e8471ed744578b2d8e3f0debe5477b268e54": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-6702. Change DFSClient to pass the StorageType from the namenode to datanodes and change datanode to write block replicas using the specified storage type.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1612493 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "22/07/14 12:41 AM",
      "commitName": "25b0e8471ed744578b2d8e3f0debe5477b268e54",
      "commitAuthor": "Tsz-wo Sze",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-6702. Change DFSClient to pass the StorageType from the namenode to datanodes and change datanode to write block replicas using the specified storage type.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1612493 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "22/07/14 12:41 AM",
          "commitName": "25b0e8471ed744578b2d8e3f0debe5477b268e54",
          "commitAuthor": "Tsz-wo Sze",
          "commitDateOld": "14/07/14 11:10 AM",
          "commitNameOld": "3b54223c0f32d42a84436c670d80b791a8e9696d",
          "commitAuthorOld": "Chris Nauroth",
          "daysBetweenCommits": 7.56,
          "commitsBetweenForRepo": 68,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,134 +1,135 @@\n   public void replaceBlock(final ExtendedBlock block,\n+      final StorageType storageType, \n       final Token\u003cBlockTokenIdentifier\u003e blockToken,\n       final String delHint,\n       final DatanodeInfo proxySource) throws IOException {\n     updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n \n     /* read header */\n     block.setNumBytes(dataXceiverServer.estimateBlockSize);\n     if (datanode.isBlockTokenEnabled) {\n       try {\n         datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n             BlockTokenSecretManager.AccessMode.REPLACE);\n       } catch (InvalidToken e) {\n         LOG.warn(\"Invalid access token in request from \" + remoteAddress\n             + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n             + e.getLocalizedMessage());\n         sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n         return;\n       }\n     }\n \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n       String msg \u003d \"Not able to receive block \" + block.getBlockId() +\n           \" from \" + peer.getRemoteAddressString() + \" because threads \" +\n           \"quota is exceeded.\";\n       LOG.warn(msg);\n       sendResponse(ERROR, msg);\n       return;\n     }\n \n     Socket proxySock \u003d null;\n     DataOutputStream proxyOut \u003d null;\n     Status opStatus \u003d SUCCESS;\n     String errMsg \u003d null;\n     BlockReceiver blockReceiver \u003d null;\n     DataInputStream proxyReply \u003d null;\n     \n     try {\n       // get the output stream to the proxy\n       final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Connecting to datanode \" + dnAddr);\n       }\n       InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n       proxySock \u003d datanode.newSocket();\n       NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n       proxySock.setSoTimeout(dnConf.socketTimeout);\n \n       OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n           dnConf.socketWriteTimeout);\n       InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n       DataEncryptionKeyFactory keyFactory \u003d\n         datanode.getDataEncryptionKeyFactoryForBlock(block);\n       IOStreamPair saslStreams \u003d datanode.saslClient.socketSend(proxySock,\n         unbufProxyOut, unbufProxyIn, keyFactory, blockToken, proxySource);\n       unbufProxyOut \u003d saslStreams.out;\n       unbufProxyIn \u003d saslStreams.in;\n       \n       proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut, \n           HdfsConstants.SMALL_BUFFER_SIZE));\n       proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n           HdfsConstants.IO_FILE_BUFFER_SIZE));\n \n       /* send request to the proxy */\n       new Sender(proxyOut).copyBlock(block, blockToken);\n \n       // receive the response from the proxy\n       \n       BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n           PBHelper.vintPrefixed(proxyReply));\n \n       if (copyResponse.getStatus() !\u003d SUCCESS) {\n         if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n           throw new IOException(\"Copy block \" + block + \" from \"\n               + proxySock.getRemoteSocketAddress()\n               + \" failed due to access token error\");\n         }\n         throw new IOException(\"Copy block \" + block + \" from \"\n             + proxySock.getRemoteSocketAddress() + \" failed\");\n       }\n       \n       // get checksum info about the block we\u0027re copying\n       ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n       DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n           checksumInfo.getChecksum());\n       // open a block receiver and check if the block does not exist\n-      blockReceiver \u003d new BlockReceiver(\n-          block, proxyReply, proxySock.getRemoteSocketAddress().toString(),\n+      blockReceiver \u003d new BlockReceiver(block, storageType,\n+          proxyReply, proxySock.getRemoteSocketAddress().toString(),\n           proxySock.getLocalSocketAddress().toString(),\n           null, 0, 0, 0, \"\", null, datanode, remoteChecksum,\n           CachingStrategy.newDropBehind());\n \n       // receive a block\n       blockReceiver.receiveBlock(null, null, null, null, \n           dataXceiverServer.balanceThrottler, null);\n                     \n       // notify name node\n       datanode.notifyNamenodeReceivedBlock(\n           block, delHint, blockReceiver.getStorageUuid());\n \n       LOG.info(\"Moved \" + block + \" from \" + peer.getRemoteAddressString()\n           + \", delHint\u003d\" + delHint);\n       \n     } catch (IOException ioe) {\n       opStatus \u003d ERROR;\n       errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n       LOG.info(errMsg);\n       throw ioe;\n     } finally {\n       // receive the last byte that indicates the proxy released its thread resource\n       if (opStatus \u003d\u003d SUCCESS) {\n         try {\n           proxyReply.readChar();\n         } catch (IOException ignored) {\n         }\n       }\n       \n       // now release the thread resource\n       dataXceiverServer.balanceThrottler.release();\n       \n       // send response back\n       try {\n         sendResponse(opStatus, errMsg);\n       } catch (IOException ioe) {\n         LOG.warn(\"Error writing reply back to \" + peer.getRemoteAddressString());\n       }\n       IOUtils.closeStream(proxyOut);\n       IOUtils.closeStream(blockReceiver);\n       IOUtils.closeStream(proxyReply);\n     }\n \n     //update metrics\n     datanode.metrics.addReplaceBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void replaceBlock(final ExtendedBlock block,\n      final StorageType storageType, \n      final Token\u003cBlockTokenIdentifier\u003e blockToken,\n      final String delHint,\n      final DatanodeInfo proxySource) throws IOException {\n    updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n\n    /* read header */\n    block.setNumBytes(dataXceiverServer.estimateBlockSize);\n    if (datanode.isBlockTokenEnabled) {\n      try {\n        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n            BlockTokenSecretManager.AccessMode.REPLACE);\n      } catch (InvalidToken e) {\n        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n            + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n            + e.getLocalizedMessage());\n        sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n        return;\n      }\n    }\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      String msg \u003d \"Not able to receive block \" + block.getBlockId() +\n          \" from \" + peer.getRemoteAddressString() + \" because threads \" +\n          \"quota is exceeded.\";\n      LOG.warn(msg);\n      sendResponse(ERROR, msg);\n      return;\n    }\n\n    Socket proxySock \u003d null;\n    DataOutputStream proxyOut \u003d null;\n    Status opStatus \u003d SUCCESS;\n    String errMsg \u003d null;\n    BlockReceiver blockReceiver \u003d null;\n    DataInputStream proxyReply \u003d null;\n    \n    try {\n      // get the output stream to the proxy\n      final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Connecting to datanode \" + dnAddr);\n      }\n      InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n      proxySock \u003d datanode.newSocket();\n      NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n      proxySock.setSoTimeout(dnConf.socketTimeout);\n\n      OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n          dnConf.socketWriteTimeout);\n      InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n      DataEncryptionKeyFactory keyFactory \u003d\n        datanode.getDataEncryptionKeyFactoryForBlock(block);\n      IOStreamPair saslStreams \u003d datanode.saslClient.socketSend(proxySock,\n        unbufProxyOut, unbufProxyIn, keyFactory, blockToken, proxySource);\n      unbufProxyOut \u003d saslStreams.out;\n      unbufProxyIn \u003d saslStreams.in;\n      \n      proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut, \n          HdfsConstants.SMALL_BUFFER_SIZE));\n      proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n          HdfsConstants.IO_FILE_BUFFER_SIZE));\n\n      /* send request to the proxy */\n      new Sender(proxyOut).copyBlock(block, blockToken);\n\n      // receive the response from the proxy\n      \n      BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n          PBHelper.vintPrefixed(proxyReply));\n\n      if (copyResponse.getStatus() !\u003d SUCCESS) {\n        if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n          throw new IOException(\"Copy block \" + block + \" from \"\n              + proxySock.getRemoteSocketAddress()\n              + \" failed due to access token error\");\n        }\n        throw new IOException(\"Copy block \" + block + \" from \"\n            + proxySock.getRemoteSocketAddress() + \" failed\");\n      }\n      \n      // get checksum info about the block we\u0027re copying\n      ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n      DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n          checksumInfo.getChecksum());\n      // open a block receiver and check if the block does not exist\n      blockReceiver \u003d new BlockReceiver(block, storageType,\n          proxyReply, proxySock.getRemoteSocketAddress().toString(),\n          proxySock.getLocalSocketAddress().toString(),\n          null, 0, 0, 0, \"\", null, datanode, remoteChecksum,\n          CachingStrategy.newDropBehind());\n\n      // receive a block\n      blockReceiver.receiveBlock(null, null, null, null, \n          dataXceiverServer.balanceThrottler, null);\n                    \n      // notify name node\n      datanode.notifyNamenodeReceivedBlock(\n          block, delHint, blockReceiver.getStorageUuid());\n\n      LOG.info(\"Moved \" + block + \" from \" + peer.getRemoteAddressString()\n          + \", delHint\u003d\" + delHint);\n      \n    } catch (IOException ioe) {\n      opStatus \u003d ERROR;\n      errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n      LOG.info(errMsg);\n      throw ioe;\n    } finally {\n      // receive the last byte that indicates the proxy released its thread resource\n      if (opStatus \u003d\u003d SUCCESS) {\n        try {\n          proxyReply.readChar();\n        } catch (IOException ignored) {\n        }\n      }\n      \n      // now release the thread resource\n      dataXceiverServer.balanceThrottler.release();\n      \n      // send response back\n      try {\n        sendResponse(opStatus, errMsg);\n      } catch (IOException ioe) {\n        LOG.warn(\"Error writing reply back to \" + peer.getRemoteAddressString());\n      }\n      IOUtils.closeStream(proxyOut);\n      IOUtils.closeStream(blockReceiver);\n      IOUtils.closeStream(proxyReply);\n    }\n\n    //update metrics\n    datanode.metrics.addReplaceBlockOp(elapsed());\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
          "extendedDetails": {
            "oldValue": "[block-ExtendedBlock(modifiers-final), blockToken-Token\u003cBlockTokenIdentifier\u003e(modifiers-final), delHint-String(modifiers-final), proxySource-DatanodeInfo(modifiers-final)]",
            "newValue": "[block-ExtendedBlock(modifiers-final), storageType-StorageType(modifiers-final), blockToken-Token\u003cBlockTokenIdentifier\u003e(modifiers-final), delHint-String(modifiers-final), proxySource-DatanodeInfo(modifiers-final)]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-6702. Change DFSClient to pass the StorageType from the namenode to datanodes and change datanode to write block replicas using the specified storage type.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1612493 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "22/07/14 12:41 AM",
          "commitName": "25b0e8471ed744578b2d8e3f0debe5477b268e54",
          "commitAuthor": "Tsz-wo Sze",
          "commitDateOld": "14/07/14 11:10 AM",
          "commitNameOld": "3b54223c0f32d42a84436c670d80b791a8e9696d",
          "commitAuthorOld": "Chris Nauroth",
          "daysBetweenCommits": 7.56,
          "commitsBetweenForRepo": 68,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,134 +1,135 @@\n   public void replaceBlock(final ExtendedBlock block,\n+      final StorageType storageType, \n       final Token\u003cBlockTokenIdentifier\u003e blockToken,\n       final String delHint,\n       final DatanodeInfo proxySource) throws IOException {\n     updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n \n     /* read header */\n     block.setNumBytes(dataXceiverServer.estimateBlockSize);\n     if (datanode.isBlockTokenEnabled) {\n       try {\n         datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n             BlockTokenSecretManager.AccessMode.REPLACE);\n       } catch (InvalidToken e) {\n         LOG.warn(\"Invalid access token in request from \" + remoteAddress\n             + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n             + e.getLocalizedMessage());\n         sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n         return;\n       }\n     }\n \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n       String msg \u003d \"Not able to receive block \" + block.getBlockId() +\n           \" from \" + peer.getRemoteAddressString() + \" because threads \" +\n           \"quota is exceeded.\";\n       LOG.warn(msg);\n       sendResponse(ERROR, msg);\n       return;\n     }\n \n     Socket proxySock \u003d null;\n     DataOutputStream proxyOut \u003d null;\n     Status opStatus \u003d SUCCESS;\n     String errMsg \u003d null;\n     BlockReceiver blockReceiver \u003d null;\n     DataInputStream proxyReply \u003d null;\n     \n     try {\n       // get the output stream to the proxy\n       final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Connecting to datanode \" + dnAddr);\n       }\n       InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n       proxySock \u003d datanode.newSocket();\n       NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n       proxySock.setSoTimeout(dnConf.socketTimeout);\n \n       OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n           dnConf.socketWriteTimeout);\n       InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n       DataEncryptionKeyFactory keyFactory \u003d\n         datanode.getDataEncryptionKeyFactoryForBlock(block);\n       IOStreamPair saslStreams \u003d datanode.saslClient.socketSend(proxySock,\n         unbufProxyOut, unbufProxyIn, keyFactory, blockToken, proxySource);\n       unbufProxyOut \u003d saslStreams.out;\n       unbufProxyIn \u003d saslStreams.in;\n       \n       proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut, \n           HdfsConstants.SMALL_BUFFER_SIZE));\n       proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n           HdfsConstants.IO_FILE_BUFFER_SIZE));\n \n       /* send request to the proxy */\n       new Sender(proxyOut).copyBlock(block, blockToken);\n \n       // receive the response from the proxy\n       \n       BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n           PBHelper.vintPrefixed(proxyReply));\n \n       if (copyResponse.getStatus() !\u003d SUCCESS) {\n         if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n           throw new IOException(\"Copy block \" + block + \" from \"\n               + proxySock.getRemoteSocketAddress()\n               + \" failed due to access token error\");\n         }\n         throw new IOException(\"Copy block \" + block + \" from \"\n             + proxySock.getRemoteSocketAddress() + \" failed\");\n       }\n       \n       // get checksum info about the block we\u0027re copying\n       ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n       DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n           checksumInfo.getChecksum());\n       // open a block receiver and check if the block does not exist\n-      blockReceiver \u003d new BlockReceiver(\n-          block, proxyReply, proxySock.getRemoteSocketAddress().toString(),\n+      blockReceiver \u003d new BlockReceiver(block, storageType,\n+          proxyReply, proxySock.getRemoteSocketAddress().toString(),\n           proxySock.getLocalSocketAddress().toString(),\n           null, 0, 0, 0, \"\", null, datanode, remoteChecksum,\n           CachingStrategy.newDropBehind());\n \n       // receive a block\n       blockReceiver.receiveBlock(null, null, null, null, \n           dataXceiverServer.balanceThrottler, null);\n                     \n       // notify name node\n       datanode.notifyNamenodeReceivedBlock(\n           block, delHint, blockReceiver.getStorageUuid());\n \n       LOG.info(\"Moved \" + block + \" from \" + peer.getRemoteAddressString()\n           + \", delHint\u003d\" + delHint);\n       \n     } catch (IOException ioe) {\n       opStatus \u003d ERROR;\n       errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n       LOG.info(errMsg);\n       throw ioe;\n     } finally {\n       // receive the last byte that indicates the proxy released its thread resource\n       if (opStatus \u003d\u003d SUCCESS) {\n         try {\n           proxyReply.readChar();\n         } catch (IOException ignored) {\n         }\n       }\n       \n       // now release the thread resource\n       dataXceiverServer.balanceThrottler.release();\n       \n       // send response back\n       try {\n         sendResponse(opStatus, errMsg);\n       } catch (IOException ioe) {\n         LOG.warn(\"Error writing reply back to \" + peer.getRemoteAddressString());\n       }\n       IOUtils.closeStream(proxyOut);\n       IOUtils.closeStream(blockReceiver);\n       IOUtils.closeStream(proxyReply);\n     }\n \n     //update metrics\n     datanode.metrics.addReplaceBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void replaceBlock(final ExtendedBlock block,\n      final StorageType storageType, \n      final Token\u003cBlockTokenIdentifier\u003e blockToken,\n      final String delHint,\n      final DatanodeInfo proxySource) throws IOException {\n    updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n\n    /* read header */\n    block.setNumBytes(dataXceiverServer.estimateBlockSize);\n    if (datanode.isBlockTokenEnabled) {\n      try {\n        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n            BlockTokenSecretManager.AccessMode.REPLACE);\n      } catch (InvalidToken e) {\n        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n            + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n            + e.getLocalizedMessage());\n        sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n        return;\n      }\n    }\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      String msg \u003d \"Not able to receive block \" + block.getBlockId() +\n          \" from \" + peer.getRemoteAddressString() + \" because threads \" +\n          \"quota is exceeded.\";\n      LOG.warn(msg);\n      sendResponse(ERROR, msg);\n      return;\n    }\n\n    Socket proxySock \u003d null;\n    DataOutputStream proxyOut \u003d null;\n    Status opStatus \u003d SUCCESS;\n    String errMsg \u003d null;\n    BlockReceiver blockReceiver \u003d null;\n    DataInputStream proxyReply \u003d null;\n    \n    try {\n      // get the output stream to the proxy\n      final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Connecting to datanode \" + dnAddr);\n      }\n      InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n      proxySock \u003d datanode.newSocket();\n      NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n      proxySock.setSoTimeout(dnConf.socketTimeout);\n\n      OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n          dnConf.socketWriteTimeout);\n      InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n      DataEncryptionKeyFactory keyFactory \u003d\n        datanode.getDataEncryptionKeyFactoryForBlock(block);\n      IOStreamPair saslStreams \u003d datanode.saslClient.socketSend(proxySock,\n        unbufProxyOut, unbufProxyIn, keyFactory, blockToken, proxySource);\n      unbufProxyOut \u003d saslStreams.out;\n      unbufProxyIn \u003d saslStreams.in;\n      \n      proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut, \n          HdfsConstants.SMALL_BUFFER_SIZE));\n      proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n          HdfsConstants.IO_FILE_BUFFER_SIZE));\n\n      /* send request to the proxy */\n      new Sender(proxyOut).copyBlock(block, blockToken);\n\n      // receive the response from the proxy\n      \n      BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n          PBHelper.vintPrefixed(proxyReply));\n\n      if (copyResponse.getStatus() !\u003d SUCCESS) {\n        if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n          throw new IOException(\"Copy block \" + block + \" from \"\n              + proxySock.getRemoteSocketAddress()\n              + \" failed due to access token error\");\n        }\n        throw new IOException(\"Copy block \" + block + \" from \"\n            + proxySock.getRemoteSocketAddress() + \" failed\");\n      }\n      \n      // get checksum info about the block we\u0027re copying\n      ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n      DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n          checksumInfo.getChecksum());\n      // open a block receiver and check if the block does not exist\n      blockReceiver \u003d new BlockReceiver(block, storageType,\n          proxyReply, proxySock.getRemoteSocketAddress().toString(),\n          proxySock.getLocalSocketAddress().toString(),\n          null, 0, 0, 0, \"\", null, datanode, remoteChecksum,\n          CachingStrategy.newDropBehind());\n\n      // receive a block\n      blockReceiver.receiveBlock(null, null, null, null, \n          dataXceiverServer.balanceThrottler, null);\n                    \n      // notify name node\n      datanode.notifyNamenodeReceivedBlock(\n          block, delHint, blockReceiver.getStorageUuid());\n\n      LOG.info(\"Moved \" + block + \" from \" + peer.getRemoteAddressString()\n          + \", delHint\u003d\" + delHint);\n      \n    } catch (IOException ioe) {\n      opStatus \u003d ERROR;\n      errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n      LOG.info(errMsg);\n      throw ioe;\n    } finally {\n      // receive the last byte that indicates the proxy released its thread resource\n      if (opStatus \u003d\u003d SUCCESS) {\n        try {\n          proxyReply.readChar();\n        } catch (IOException ignored) {\n        }\n      }\n      \n      // now release the thread resource\n      dataXceiverServer.balanceThrottler.release();\n      \n      // send response back\n      try {\n        sendResponse(opStatus, errMsg);\n      } catch (IOException ioe) {\n        LOG.warn(\"Error writing reply back to \" + peer.getRemoteAddressString());\n      }\n      IOUtils.closeStream(proxyOut);\n      IOUtils.closeStream(blockReceiver);\n      IOUtils.closeStream(proxyReply);\n    }\n\n    //update metrics\n    datanode.metrics.addReplaceBlockOp(elapsed());\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
          "extendedDetails": {}
        }
      ]
    },
    "3b54223c0f32d42a84436c670d80b791a8e9696d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2856. Fix block protocol so that Datanodes don\u0027t require root or jsvc. Contributed by Chris Nauroth.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1610474 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/07/14 11:10 AM",
      "commitName": "3b54223c0f32d42a84436c670d80b791a8e9696d",
      "commitAuthor": "Chris Nauroth",
      "commitDateOld": "22/05/14 11:17 AM",
      "commitNameOld": "3671a5e16fbddbe5a0516289ce98e1305e02291c",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 53.0,
      "commitsBetweenForRepo": 313,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,139 +1,134 @@\n   public void replaceBlock(final ExtendedBlock block,\n       final Token\u003cBlockTokenIdentifier\u003e blockToken,\n       final String delHint,\n       final DatanodeInfo proxySource) throws IOException {\n     updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n \n     /* read header */\n     block.setNumBytes(dataXceiverServer.estimateBlockSize);\n     if (datanode.isBlockTokenEnabled) {\n       try {\n         datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n             BlockTokenSecretManager.AccessMode.REPLACE);\n       } catch (InvalidToken e) {\n         LOG.warn(\"Invalid access token in request from \" + remoteAddress\n             + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n             + e.getLocalizedMessage());\n         sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n         return;\n       }\n     }\n \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n       String msg \u003d \"Not able to receive block \" + block.getBlockId() +\n           \" from \" + peer.getRemoteAddressString() + \" because threads \" +\n           \"quota is exceeded.\";\n       LOG.warn(msg);\n       sendResponse(ERROR, msg);\n       return;\n     }\n \n     Socket proxySock \u003d null;\n     DataOutputStream proxyOut \u003d null;\n     Status opStatus \u003d SUCCESS;\n     String errMsg \u003d null;\n     BlockReceiver blockReceiver \u003d null;\n     DataInputStream proxyReply \u003d null;\n     \n     try {\n       // get the output stream to the proxy\n       final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Connecting to datanode \" + dnAddr);\n       }\n       InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n       proxySock \u003d datanode.newSocket();\n       NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n       proxySock.setSoTimeout(dnConf.socketTimeout);\n \n       OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n           dnConf.socketWriteTimeout);\n       InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n-      if (dnConf.encryptDataTransfer \u0026\u0026 \n-          !dnConf.trustedChannelResolver.isTrusted(\n-              proxySock.getInetAddress())) {\n-        IOStreamPair encryptedStreams \u003d\n-            DataTransferEncryptor.getEncryptedStreams(\n-                unbufProxyOut, unbufProxyIn,\n-                datanode.blockPoolTokenSecretManager\n-                    .generateDataEncryptionKey(block.getBlockPoolId()));\n-        unbufProxyOut \u003d encryptedStreams.out;\n-        unbufProxyIn \u003d encryptedStreams.in;\n-      }\n+      DataEncryptionKeyFactory keyFactory \u003d\n+        datanode.getDataEncryptionKeyFactoryForBlock(block);\n+      IOStreamPair saslStreams \u003d datanode.saslClient.socketSend(proxySock,\n+        unbufProxyOut, unbufProxyIn, keyFactory, blockToken, proxySource);\n+      unbufProxyOut \u003d saslStreams.out;\n+      unbufProxyIn \u003d saslStreams.in;\n       \n       proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut, \n           HdfsConstants.SMALL_BUFFER_SIZE));\n       proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n           HdfsConstants.IO_FILE_BUFFER_SIZE));\n \n       /* send request to the proxy */\n       new Sender(proxyOut).copyBlock(block, blockToken);\n \n       // receive the response from the proxy\n       \n       BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n           PBHelper.vintPrefixed(proxyReply));\n \n       if (copyResponse.getStatus() !\u003d SUCCESS) {\n         if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n           throw new IOException(\"Copy block \" + block + \" from \"\n               + proxySock.getRemoteSocketAddress()\n               + \" failed due to access token error\");\n         }\n         throw new IOException(\"Copy block \" + block + \" from \"\n             + proxySock.getRemoteSocketAddress() + \" failed\");\n       }\n       \n       // get checksum info about the block we\u0027re copying\n       ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n       DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n           checksumInfo.getChecksum());\n       // open a block receiver and check if the block does not exist\n       blockReceiver \u003d new BlockReceiver(\n           block, proxyReply, proxySock.getRemoteSocketAddress().toString(),\n           proxySock.getLocalSocketAddress().toString(),\n           null, 0, 0, 0, \"\", null, datanode, remoteChecksum,\n           CachingStrategy.newDropBehind());\n \n       // receive a block\n       blockReceiver.receiveBlock(null, null, null, null, \n           dataXceiverServer.balanceThrottler, null);\n                     \n       // notify name node\n       datanode.notifyNamenodeReceivedBlock(\n           block, delHint, blockReceiver.getStorageUuid());\n \n       LOG.info(\"Moved \" + block + \" from \" + peer.getRemoteAddressString()\n           + \", delHint\u003d\" + delHint);\n       \n     } catch (IOException ioe) {\n       opStatus \u003d ERROR;\n       errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n       LOG.info(errMsg);\n       throw ioe;\n     } finally {\n       // receive the last byte that indicates the proxy released its thread resource\n       if (opStatus \u003d\u003d SUCCESS) {\n         try {\n           proxyReply.readChar();\n         } catch (IOException ignored) {\n         }\n       }\n       \n       // now release the thread resource\n       dataXceiverServer.balanceThrottler.release();\n       \n       // send response back\n       try {\n         sendResponse(opStatus, errMsg);\n       } catch (IOException ioe) {\n         LOG.warn(\"Error writing reply back to \" + peer.getRemoteAddressString());\n       }\n       IOUtils.closeStream(proxyOut);\n       IOUtils.closeStream(blockReceiver);\n       IOUtils.closeStream(proxyReply);\n     }\n \n     //update metrics\n     datanode.metrics.addReplaceBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void replaceBlock(final ExtendedBlock block,\n      final Token\u003cBlockTokenIdentifier\u003e blockToken,\n      final String delHint,\n      final DatanodeInfo proxySource) throws IOException {\n    updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n\n    /* read header */\n    block.setNumBytes(dataXceiverServer.estimateBlockSize);\n    if (datanode.isBlockTokenEnabled) {\n      try {\n        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n            BlockTokenSecretManager.AccessMode.REPLACE);\n      } catch (InvalidToken e) {\n        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n            + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n            + e.getLocalizedMessage());\n        sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n        return;\n      }\n    }\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      String msg \u003d \"Not able to receive block \" + block.getBlockId() +\n          \" from \" + peer.getRemoteAddressString() + \" because threads \" +\n          \"quota is exceeded.\";\n      LOG.warn(msg);\n      sendResponse(ERROR, msg);\n      return;\n    }\n\n    Socket proxySock \u003d null;\n    DataOutputStream proxyOut \u003d null;\n    Status opStatus \u003d SUCCESS;\n    String errMsg \u003d null;\n    BlockReceiver blockReceiver \u003d null;\n    DataInputStream proxyReply \u003d null;\n    \n    try {\n      // get the output stream to the proxy\n      final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Connecting to datanode \" + dnAddr);\n      }\n      InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n      proxySock \u003d datanode.newSocket();\n      NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n      proxySock.setSoTimeout(dnConf.socketTimeout);\n\n      OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n          dnConf.socketWriteTimeout);\n      InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n      DataEncryptionKeyFactory keyFactory \u003d\n        datanode.getDataEncryptionKeyFactoryForBlock(block);\n      IOStreamPair saslStreams \u003d datanode.saslClient.socketSend(proxySock,\n        unbufProxyOut, unbufProxyIn, keyFactory, blockToken, proxySource);\n      unbufProxyOut \u003d saslStreams.out;\n      unbufProxyIn \u003d saslStreams.in;\n      \n      proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut, \n          HdfsConstants.SMALL_BUFFER_SIZE));\n      proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n          HdfsConstants.IO_FILE_BUFFER_SIZE));\n\n      /* send request to the proxy */\n      new Sender(proxyOut).copyBlock(block, blockToken);\n\n      // receive the response from the proxy\n      \n      BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n          PBHelper.vintPrefixed(proxyReply));\n\n      if (copyResponse.getStatus() !\u003d SUCCESS) {\n        if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n          throw new IOException(\"Copy block \" + block + \" from \"\n              + proxySock.getRemoteSocketAddress()\n              + \" failed due to access token error\");\n        }\n        throw new IOException(\"Copy block \" + block + \" from \"\n            + proxySock.getRemoteSocketAddress() + \" failed\");\n      }\n      \n      // get checksum info about the block we\u0027re copying\n      ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n      DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n          checksumInfo.getChecksum());\n      // open a block receiver and check if the block does not exist\n      blockReceiver \u003d new BlockReceiver(\n          block, proxyReply, proxySock.getRemoteSocketAddress().toString(),\n          proxySock.getLocalSocketAddress().toString(),\n          null, 0, 0, 0, \"\", null, datanode, remoteChecksum,\n          CachingStrategy.newDropBehind());\n\n      // receive a block\n      blockReceiver.receiveBlock(null, null, null, null, \n          dataXceiverServer.balanceThrottler, null);\n                    \n      // notify name node\n      datanode.notifyNamenodeReceivedBlock(\n          block, delHint, blockReceiver.getStorageUuid());\n\n      LOG.info(\"Moved \" + block + \" from \" + peer.getRemoteAddressString()\n          + \", delHint\u003d\" + delHint);\n      \n    } catch (IOException ioe) {\n      opStatus \u003d ERROR;\n      errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n      LOG.info(errMsg);\n      throw ioe;\n    } finally {\n      // receive the last byte that indicates the proxy released its thread resource\n      if (opStatus \u003d\u003d SUCCESS) {\n        try {\n          proxyReply.readChar();\n        } catch (IOException ignored) {\n        }\n      }\n      \n      // now release the thread resource\n      dataXceiverServer.balanceThrottler.release();\n      \n      // send response back\n      try {\n        sendResponse(opStatus, errMsg);\n      } catch (IOException ioe) {\n        LOG.warn(\"Error writing reply back to \" + peer.getRemoteAddressString());\n      }\n      IOUtils.closeStream(proxyOut);\n      IOUtils.closeStream(blockReceiver);\n      IOUtils.closeStream(proxyReply);\n    }\n\n    //update metrics\n    datanode.metrics.addReplaceBlockOp(elapsed());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "1fbb04e367d7c330e6052207f9f11911f4f5f368": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5910. Enhance DataTransferProtocol to allow per-connection choice of encryption/plain-text. (Contributed by Benoy Antony)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1581688 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/03/14 9:11 PM",
      "commitName": "1fbb04e367d7c330e6052207f9f11911f4f5f368",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "19/03/14 2:04 PM",
      "commitNameOld": "cfb468332e482a51f0a8aea61da4fe5245419a89",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 6.3,
      "commitsBetweenForRepo": 55,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,137 +1,139 @@\n   public void replaceBlock(final ExtendedBlock block,\n       final Token\u003cBlockTokenIdentifier\u003e blockToken,\n       final String delHint,\n       final DatanodeInfo proxySource) throws IOException {\n     updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n \n     /* read header */\n     block.setNumBytes(dataXceiverServer.estimateBlockSize);\n     if (datanode.isBlockTokenEnabled) {\n       try {\n         datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n             BlockTokenSecretManager.AccessMode.REPLACE);\n       } catch (InvalidToken e) {\n         LOG.warn(\"Invalid access token in request from \" + remoteAddress\n             + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n             + e.getLocalizedMessage());\n         sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n         return;\n       }\n     }\n \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n       String msg \u003d \"Not able to receive block \" + block.getBlockId() +\n           \" from \" + peer.getRemoteAddressString() + \" because threads \" +\n           \"quota is exceeded.\";\n       LOG.warn(msg);\n       sendResponse(ERROR, msg);\n       return;\n     }\n \n     Socket proxySock \u003d null;\n     DataOutputStream proxyOut \u003d null;\n     Status opStatus \u003d SUCCESS;\n     String errMsg \u003d null;\n     BlockReceiver blockReceiver \u003d null;\n     DataInputStream proxyReply \u003d null;\n     \n     try {\n       // get the output stream to the proxy\n       final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Connecting to datanode \" + dnAddr);\n       }\n       InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n       proxySock \u003d datanode.newSocket();\n       NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n       proxySock.setSoTimeout(dnConf.socketTimeout);\n \n       OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n           dnConf.socketWriteTimeout);\n       InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n-      if (dnConf.encryptDataTransfer) {\n+      if (dnConf.encryptDataTransfer \u0026\u0026 \n+          !dnConf.trustedChannelResolver.isTrusted(\n+              proxySock.getInetAddress())) {\n         IOStreamPair encryptedStreams \u003d\n             DataTransferEncryptor.getEncryptedStreams(\n                 unbufProxyOut, unbufProxyIn,\n                 datanode.blockPoolTokenSecretManager\n                     .generateDataEncryptionKey(block.getBlockPoolId()));\n         unbufProxyOut \u003d encryptedStreams.out;\n         unbufProxyIn \u003d encryptedStreams.in;\n       }\n       \n       proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut, \n           HdfsConstants.SMALL_BUFFER_SIZE));\n       proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n           HdfsConstants.IO_FILE_BUFFER_SIZE));\n \n       /* send request to the proxy */\n       new Sender(proxyOut).copyBlock(block, blockToken);\n \n       // receive the response from the proxy\n       \n       BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n           PBHelper.vintPrefixed(proxyReply));\n \n       if (copyResponse.getStatus() !\u003d SUCCESS) {\n         if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n           throw new IOException(\"Copy block \" + block + \" from \"\n               + proxySock.getRemoteSocketAddress()\n               + \" failed due to access token error\");\n         }\n         throw new IOException(\"Copy block \" + block + \" from \"\n             + proxySock.getRemoteSocketAddress() + \" failed\");\n       }\n       \n       // get checksum info about the block we\u0027re copying\n       ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n       DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n           checksumInfo.getChecksum());\n       // open a block receiver and check if the block does not exist\n       blockReceiver \u003d new BlockReceiver(\n           block, proxyReply, proxySock.getRemoteSocketAddress().toString(),\n           proxySock.getLocalSocketAddress().toString(),\n           null, 0, 0, 0, \"\", null, datanode, remoteChecksum,\n           CachingStrategy.newDropBehind());\n \n       // receive a block\n       blockReceiver.receiveBlock(null, null, null, null, \n           dataXceiverServer.balanceThrottler, null);\n                     \n       // notify name node\n       datanode.notifyNamenodeReceivedBlock(\n           block, delHint, blockReceiver.getStorageUuid());\n \n       LOG.info(\"Moved \" + block + \" from \" + peer.getRemoteAddressString()\n           + \", delHint\u003d\" + delHint);\n       \n     } catch (IOException ioe) {\n       opStatus \u003d ERROR;\n       errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n       LOG.info(errMsg);\n       throw ioe;\n     } finally {\n       // receive the last byte that indicates the proxy released its thread resource\n       if (opStatus \u003d\u003d SUCCESS) {\n         try {\n           proxyReply.readChar();\n         } catch (IOException ignored) {\n         }\n       }\n       \n       // now release the thread resource\n       dataXceiverServer.balanceThrottler.release();\n       \n       // send response back\n       try {\n         sendResponse(opStatus, errMsg);\n       } catch (IOException ioe) {\n         LOG.warn(\"Error writing reply back to \" + peer.getRemoteAddressString());\n       }\n       IOUtils.closeStream(proxyOut);\n       IOUtils.closeStream(blockReceiver);\n       IOUtils.closeStream(proxyReply);\n     }\n \n     //update metrics\n     datanode.metrics.addReplaceBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void replaceBlock(final ExtendedBlock block,\n      final Token\u003cBlockTokenIdentifier\u003e blockToken,\n      final String delHint,\n      final DatanodeInfo proxySource) throws IOException {\n    updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n\n    /* read header */\n    block.setNumBytes(dataXceiverServer.estimateBlockSize);\n    if (datanode.isBlockTokenEnabled) {\n      try {\n        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n            BlockTokenSecretManager.AccessMode.REPLACE);\n      } catch (InvalidToken e) {\n        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n            + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n            + e.getLocalizedMessage());\n        sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n        return;\n      }\n    }\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      String msg \u003d \"Not able to receive block \" + block.getBlockId() +\n          \" from \" + peer.getRemoteAddressString() + \" because threads \" +\n          \"quota is exceeded.\";\n      LOG.warn(msg);\n      sendResponse(ERROR, msg);\n      return;\n    }\n\n    Socket proxySock \u003d null;\n    DataOutputStream proxyOut \u003d null;\n    Status opStatus \u003d SUCCESS;\n    String errMsg \u003d null;\n    BlockReceiver blockReceiver \u003d null;\n    DataInputStream proxyReply \u003d null;\n    \n    try {\n      // get the output stream to the proxy\n      final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Connecting to datanode \" + dnAddr);\n      }\n      InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n      proxySock \u003d datanode.newSocket();\n      NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n      proxySock.setSoTimeout(dnConf.socketTimeout);\n\n      OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n          dnConf.socketWriteTimeout);\n      InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n      if (dnConf.encryptDataTransfer \u0026\u0026 \n          !dnConf.trustedChannelResolver.isTrusted(\n              proxySock.getInetAddress())) {\n        IOStreamPair encryptedStreams \u003d\n            DataTransferEncryptor.getEncryptedStreams(\n                unbufProxyOut, unbufProxyIn,\n                datanode.blockPoolTokenSecretManager\n                    .generateDataEncryptionKey(block.getBlockPoolId()));\n        unbufProxyOut \u003d encryptedStreams.out;\n        unbufProxyIn \u003d encryptedStreams.in;\n      }\n      \n      proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut, \n          HdfsConstants.SMALL_BUFFER_SIZE));\n      proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n          HdfsConstants.IO_FILE_BUFFER_SIZE));\n\n      /* send request to the proxy */\n      new Sender(proxyOut).copyBlock(block, blockToken);\n\n      // receive the response from the proxy\n      \n      BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n          PBHelper.vintPrefixed(proxyReply));\n\n      if (copyResponse.getStatus() !\u003d SUCCESS) {\n        if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n          throw new IOException(\"Copy block \" + block + \" from \"\n              + proxySock.getRemoteSocketAddress()\n              + \" failed due to access token error\");\n        }\n        throw new IOException(\"Copy block \" + block + \" from \"\n            + proxySock.getRemoteSocketAddress() + \" failed\");\n      }\n      \n      // get checksum info about the block we\u0027re copying\n      ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n      DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n          checksumInfo.getChecksum());\n      // open a block receiver and check if the block does not exist\n      blockReceiver \u003d new BlockReceiver(\n          block, proxyReply, proxySock.getRemoteSocketAddress().toString(),\n          proxySock.getLocalSocketAddress().toString(),\n          null, 0, 0, 0, \"\", null, datanode, remoteChecksum,\n          CachingStrategy.newDropBehind());\n\n      // receive a block\n      blockReceiver.receiveBlock(null, null, null, null, \n          dataXceiverServer.balanceThrottler, null);\n                    \n      // notify name node\n      datanode.notifyNamenodeReceivedBlock(\n          block, delHint, blockReceiver.getStorageUuid());\n\n      LOG.info(\"Moved \" + block + \" from \" + peer.getRemoteAddressString()\n          + \", delHint\u003d\" + delHint);\n      \n    } catch (IOException ioe) {\n      opStatus \u003d ERROR;\n      errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n      LOG.info(errMsg);\n      throw ioe;\n    } finally {\n      // receive the last byte that indicates the proxy released its thread resource\n      if (opStatus \u003d\u003d SUCCESS) {\n        try {\n          proxyReply.readChar();\n        } catch (IOException ignored) {\n        }\n      }\n      \n      // now release the thread resource\n      dataXceiverServer.balanceThrottler.release();\n      \n      // send response back\n      try {\n        sendResponse(opStatus, errMsg);\n      } catch (IOException ioe) {\n        LOG.warn(\"Error writing reply back to \" + peer.getRemoteAddressString());\n      }\n      IOUtils.closeStream(proxyOut);\n      IOUtils.closeStream(blockReceiver);\n      IOUtils.closeStream(proxyReply);\n    }\n\n    //update metrics\n    datanode.metrics.addReplaceBlockOp(elapsed());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "97acde2d33967f7f870f7dfe96c6b558e6fe324b": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5542. Fix TODO and clean up the code in HDFS-2832. (Contributed by szetszwo)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2832@1544664 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "22/11/13 12:07 PM",
      "commitName": "97acde2d33967f7f870f7dfe96c6b558e6fe324b",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "10/11/13 12:59 PM",
      "commitNameOld": "907fb15ee8c150e5ecc0560b7374441c57a84122",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 11.96,
      "commitsBetweenForRepo": 102,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,137 +1,137 @@\n   public void replaceBlock(final ExtendedBlock block,\n       final Token\u003cBlockTokenIdentifier\u003e blockToken,\n       final String delHint,\n       final DatanodeInfo proxySource) throws IOException {\n     updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n \n     /* read header */\n     block.setNumBytes(dataXceiverServer.estimateBlockSize);\n     if (datanode.isBlockTokenEnabled) {\n       try {\n         datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n             BlockTokenSecretManager.AccessMode.REPLACE);\n       } catch (InvalidToken e) {\n         LOG.warn(\"Invalid access token in request from \" + remoteAddress\n             + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n             + e.getLocalizedMessage());\n         sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n         return;\n       }\n     }\n \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n       String msg \u003d \"Not able to receive block \" + block.getBlockId() +\n           \" from \" + peer.getRemoteAddressString() + \" because threads \" +\n           \"quota is exceeded.\";\n       LOG.warn(msg);\n       sendResponse(ERROR, msg);\n       return;\n     }\n \n     Socket proxySock \u003d null;\n     DataOutputStream proxyOut \u003d null;\n     Status opStatus \u003d SUCCESS;\n     String errMsg \u003d null;\n     BlockReceiver blockReceiver \u003d null;\n     DataInputStream proxyReply \u003d null;\n     \n     try {\n       // get the output stream to the proxy\n       final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Connecting to datanode \" + dnAddr);\n       }\n       InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n       proxySock \u003d datanode.newSocket();\n       NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n       proxySock.setSoTimeout(dnConf.socketTimeout);\n \n       OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n           dnConf.socketWriteTimeout);\n       InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n       if (dnConf.encryptDataTransfer) {\n         IOStreamPair encryptedStreams \u003d\n             DataTransferEncryptor.getEncryptedStreams(\n                 unbufProxyOut, unbufProxyIn,\n                 datanode.blockPoolTokenSecretManager\n                     .generateDataEncryptionKey(block.getBlockPoolId()));\n         unbufProxyOut \u003d encryptedStreams.out;\n         unbufProxyIn \u003d encryptedStreams.in;\n       }\n       \n       proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut, \n           HdfsConstants.SMALL_BUFFER_SIZE));\n       proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n           HdfsConstants.IO_FILE_BUFFER_SIZE));\n \n       /* send request to the proxy */\n       new Sender(proxyOut).copyBlock(block, blockToken);\n \n       // receive the response from the proxy\n       \n       BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n           PBHelper.vintPrefixed(proxyReply));\n \n       if (copyResponse.getStatus() !\u003d SUCCESS) {\n         if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n           throw new IOException(\"Copy block \" + block + \" from \"\n               + proxySock.getRemoteSocketAddress()\n               + \" failed due to access token error\");\n         }\n         throw new IOException(\"Copy block \" + block + \" from \"\n             + proxySock.getRemoteSocketAddress() + \" failed\");\n       }\n       \n       // get checksum info about the block we\u0027re copying\n       ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n       DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n           checksumInfo.getChecksum());\n       // open a block receiver and check if the block does not exist\n       blockReceiver \u003d new BlockReceiver(\n           block, proxyReply, proxySock.getRemoteSocketAddress().toString(),\n           proxySock.getLocalSocketAddress().toString(),\n           null, 0, 0, 0, \"\", null, datanode, remoteChecksum,\n           CachingStrategy.newDropBehind());\n \n       // receive a block\n       blockReceiver.receiveBlock(null, null, null, null, \n           dataXceiverServer.balanceThrottler, null);\n                     \n       // notify name node\n       datanode.notifyNamenodeReceivedBlock(\n-          block, delHint, blockReceiver.getReplicaInfo().getStorageUuid());\n+          block, delHint, blockReceiver.getStorageUuid());\n \n       LOG.info(\"Moved \" + block + \" from \" + peer.getRemoteAddressString()\n           + \", delHint\u003d\" + delHint);\n       \n     } catch (IOException ioe) {\n       opStatus \u003d ERROR;\n       errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n       LOG.info(errMsg);\n       throw ioe;\n     } finally {\n       // receive the last byte that indicates the proxy released its thread resource\n       if (opStatus \u003d\u003d SUCCESS) {\n         try {\n           proxyReply.readChar();\n         } catch (IOException ignored) {\n         }\n       }\n       \n       // now release the thread resource\n       dataXceiverServer.balanceThrottler.release();\n       \n       // send response back\n       try {\n         sendResponse(opStatus, errMsg);\n       } catch (IOException ioe) {\n         LOG.warn(\"Error writing reply back to \" + peer.getRemoteAddressString());\n       }\n       IOUtils.closeStream(proxyOut);\n       IOUtils.closeStream(blockReceiver);\n       IOUtils.closeStream(proxyReply);\n     }\n \n     //update metrics\n     datanode.metrics.addReplaceBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void replaceBlock(final ExtendedBlock block,\n      final Token\u003cBlockTokenIdentifier\u003e blockToken,\n      final String delHint,\n      final DatanodeInfo proxySource) throws IOException {\n    updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n\n    /* read header */\n    block.setNumBytes(dataXceiverServer.estimateBlockSize);\n    if (datanode.isBlockTokenEnabled) {\n      try {\n        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n            BlockTokenSecretManager.AccessMode.REPLACE);\n      } catch (InvalidToken e) {\n        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n            + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n            + e.getLocalizedMessage());\n        sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n        return;\n      }\n    }\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      String msg \u003d \"Not able to receive block \" + block.getBlockId() +\n          \" from \" + peer.getRemoteAddressString() + \" because threads \" +\n          \"quota is exceeded.\";\n      LOG.warn(msg);\n      sendResponse(ERROR, msg);\n      return;\n    }\n\n    Socket proxySock \u003d null;\n    DataOutputStream proxyOut \u003d null;\n    Status opStatus \u003d SUCCESS;\n    String errMsg \u003d null;\n    BlockReceiver blockReceiver \u003d null;\n    DataInputStream proxyReply \u003d null;\n    \n    try {\n      // get the output stream to the proxy\n      final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Connecting to datanode \" + dnAddr);\n      }\n      InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n      proxySock \u003d datanode.newSocket();\n      NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n      proxySock.setSoTimeout(dnConf.socketTimeout);\n\n      OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n          dnConf.socketWriteTimeout);\n      InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n      if (dnConf.encryptDataTransfer) {\n        IOStreamPair encryptedStreams \u003d\n            DataTransferEncryptor.getEncryptedStreams(\n                unbufProxyOut, unbufProxyIn,\n                datanode.blockPoolTokenSecretManager\n                    .generateDataEncryptionKey(block.getBlockPoolId()));\n        unbufProxyOut \u003d encryptedStreams.out;\n        unbufProxyIn \u003d encryptedStreams.in;\n      }\n      \n      proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut, \n          HdfsConstants.SMALL_BUFFER_SIZE));\n      proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n          HdfsConstants.IO_FILE_BUFFER_SIZE));\n\n      /* send request to the proxy */\n      new Sender(proxyOut).copyBlock(block, blockToken);\n\n      // receive the response from the proxy\n      \n      BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n          PBHelper.vintPrefixed(proxyReply));\n\n      if (copyResponse.getStatus() !\u003d SUCCESS) {\n        if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n          throw new IOException(\"Copy block \" + block + \" from \"\n              + proxySock.getRemoteSocketAddress()\n              + \" failed due to access token error\");\n        }\n        throw new IOException(\"Copy block \" + block + \" from \"\n            + proxySock.getRemoteSocketAddress() + \" failed\");\n      }\n      \n      // get checksum info about the block we\u0027re copying\n      ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n      DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n          checksumInfo.getChecksum());\n      // open a block receiver and check if the block does not exist\n      blockReceiver \u003d new BlockReceiver(\n          block, proxyReply, proxySock.getRemoteSocketAddress().toString(),\n          proxySock.getLocalSocketAddress().toString(),\n          null, 0, 0, 0, \"\", null, datanode, remoteChecksum,\n          CachingStrategy.newDropBehind());\n\n      // receive a block\n      blockReceiver.receiveBlock(null, null, null, null, \n          dataXceiverServer.balanceThrottler, null);\n                    \n      // notify name node\n      datanode.notifyNamenodeReceivedBlock(\n          block, delHint, blockReceiver.getStorageUuid());\n\n      LOG.info(\"Moved \" + block + \" from \" + peer.getRemoteAddressString()\n          + \", delHint\u003d\" + delHint);\n      \n    } catch (IOException ioe) {\n      opStatus \u003d ERROR;\n      errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n      LOG.info(errMsg);\n      throw ioe;\n    } finally {\n      // receive the last byte that indicates the proxy released its thread resource\n      if (opStatus \u003d\u003d SUCCESS) {\n        try {\n          proxyReply.readChar();\n        } catch (IOException ignored) {\n        }\n      }\n      \n      // now release the thread resource\n      dataXceiverServer.balanceThrottler.release();\n      \n      // send response back\n      try {\n        sendResponse(opStatus, errMsg);\n      } catch (IOException ioe) {\n        LOG.warn(\"Error writing reply back to \" + peer.getRemoteAddressString());\n      }\n      IOUtils.closeStream(proxyOut);\n      IOUtils.closeStream(blockReceiver);\n      IOUtils.closeStream(proxyReply);\n    }\n\n    //update metrics\n    datanode.metrics.addReplaceBlockOp(elapsed());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "907fb15ee8c150e5ecc0560b7374441c57a84122": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5480. Update Balancer for HDFS-2832. (Contributed by szetszwo)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2832@1540547 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/11/13 12:59 PM",
      "commitName": "907fb15ee8c150e5ecc0560b7374441c57a84122",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "22/10/13 6:28 PM",
      "commitNameOld": "01f37e42f050207b7659bf74e2484cf8bdae2d89",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 18.81,
      "commitsBetweenForRepo": 87,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,136 +1,137 @@\n   public void replaceBlock(final ExtendedBlock block,\n       final Token\u003cBlockTokenIdentifier\u003e blockToken,\n       final String delHint,\n       final DatanodeInfo proxySource) throws IOException {\n     updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n \n     /* read header */\n     block.setNumBytes(dataXceiverServer.estimateBlockSize);\n     if (datanode.isBlockTokenEnabled) {\n       try {\n         datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n             BlockTokenSecretManager.AccessMode.REPLACE);\n       } catch (InvalidToken e) {\n         LOG.warn(\"Invalid access token in request from \" + remoteAddress\n             + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n             + e.getLocalizedMessage());\n         sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n         return;\n       }\n     }\n \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n       String msg \u003d \"Not able to receive block \" + block.getBlockId() +\n           \" from \" + peer.getRemoteAddressString() + \" because threads \" +\n           \"quota is exceeded.\";\n       LOG.warn(msg);\n       sendResponse(ERROR, msg);\n       return;\n     }\n \n     Socket proxySock \u003d null;\n     DataOutputStream proxyOut \u003d null;\n     Status opStatus \u003d SUCCESS;\n     String errMsg \u003d null;\n     BlockReceiver blockReceiver \u003d null;\n     DataInputStream proxyReply \u003d null;\n     \n     try {\n       // get the output stream to the proxy\n       final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Connecting to datanode \" + dnAddr);\n       }\n       InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n       proxySock \u003d datanode.newSocket();\n       NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n       proxySock.setSoTimeout(dnConf.socketTimeout);\n \n       OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n           dnConf.socketWriteTimeout);\n       InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n       if (dnConf.encryptDataTransfer) {\n         IOStreamPair encryptedStreams \u003d\n             DataTransferEncryptor.getEncryptedStreams(\n                 unbufProxyOut, unbufProxyIn,\n                 datanode.blockPoolTokenSecretManager\n                     .generateDataEncryptionKey(block.getBlockPoolId()));\n         unbufProxyOut \u003d encryptedStreams.out;\n         unbufProxyIn \u003d encryptedStreams.in;\n       }\n       \n       proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut, \n           HdfsConstants.SMALL_BUFFER_SIZE));\n       proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n           HdfsConstants.IO_FILE_BUFFER_SIZE));\n \n       /* send request to the proxy */\n       new Sender(proxyOut).copyBlock(block, blockToken);\n \n       // receive the response from the proxy\n       \n       BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n           PBHelper.vintPrefixed(proxyReply));\n \n       if (copyResponse.getStatus() !\u003d SUCCESS) {\n         if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n           throw new IOException(\"Copy block \" + block + \" from \"\n               + proxySock.getRemoteSocketAddress()\n               + \" failed due to access token error\");\n         }\n         throw new IOException(\"Copy block \" + block + \" from \"\n             + proxySock.getRemoteSocketAddress() + \" failed\");\n       }\n       \n       // get checksum info about the block we\u0027re copying\n       ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n       DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n           checksumInfo.getChecksum());\n       // open a block receiver and check if the block does not exist\n       blockReceiver \u003d new BlockReceiver(\n           block, proxyReply, proxySock.getRemoteSocketAddress().toString(),\n           proxySock.getLocalSocketAddress().toString(),\n           null, 0, 0, 0, \"\", null, datanode, remoteChecksum,\n           CachingStrategy.newDropBehind());\n \n       // receive a block\n       blockReceiver.receiveBlock(null, null, null, null, \n           dataXceiverServer.balanceThrottler, null);\n                     \n       // notify name node\n       datanode.notifyNamenodeReceivedBlock(\n           block, delHint, blockReceiver.getReplicaInfo().getStorageUuid());\n \n-      LOG.info(\"Moved \" + block + \" from \" + peer.getRemoteAddressString());\n+      LOG.info(\"Moved \" + block + \" from \" + peer.getRemoteAddressString()\n+          + \", delHint\u003d\" + delHint);\n       \n     } catch (IOException ioe) {\n       opStatus \u003d ERROR;\n       errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n       LOG.info(errMsg);\n       throw ioe;\n     } finally {\n       // receive the last byte that indicates the proxy released its thread resource\n       if (opStatus \u003d\u003d SUCCESS) {\n         try {\n           proxyReply.readChar();\n         } catch (IOException ignored) {\n         }\n       }\n       \n       // now release the thread resource\n       dataXceiverServer.balanceThrottler.release();\n       \n       // send response back\n       try {\n         sendResponse(opStatus, errMsg);\n       } catch (IOException ioe) {\n         LOG.warn(\"Error writing reply back to \" + peer.getRemoteAddressString());\n       }\n       IOUtils.closeStream(proxyOut);\n       IOUtils.closeStream(blockReceiver);\n       IOUtils.closeStream(proxyReply);\n     }\n \n     //update metrics\n     datanode.metrics.addReplaceBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void replaceBlock(final ExtendedBlock block,\n      final Token\u003cBlockTokenIdentifier\u003e blockToken,\n      final String delHint,\n      final DatanodeInfo proxySource) throws IOException {\n    updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n\n    /* read header */\n    block.setNumBytes(dataXceiverServer.estimateBlockSize);\n    if (datanode.isBlockTokenEnabled) {\n      try {\n        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n            BlockTokenSecretManager.AccessMode.REPLACE);\n      } catch (InvalidToken e) {\n        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n            + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n            + e.getLocalizedMessage());\n        sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n        return;\n      }\n    }\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      String msg \u003d \"Not able to receive block \" + block.getBlockId() +\n          \" from \" + peer.getRemoteAddressString() + \" because threads \" +\n          \"quota is exceeded.\";\n      LOG.warn(msg);\n      sendResponse(ERROR, msg);\n      return;\n    }\n\n    Socket proxySock \u003d null;\n    DataOutputStream proxyOut \u003d null;\n    Status opStatus \u003d SUCCESS;\n    String errMsg \u003d null;\n    BlockReceiver blockReceiver \u003d null;\n    DataInputStream proxyReply \u003d null;\n    \n    try {\n      // get the output stream to the proxy\n      final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Connecting to datanode \" + dnAddr);\n      }\n      InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n      proxySock \u003d datanode.newSocket();\n      NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n      proxySock.setSoTimeout(dnConf.socketTimeout);\n\n      OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n          dnConf.socketWriteTimeout);\n      InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n      if (dnConf.encryptDataTransfer) {\n        IOStreamPair encryptedStreams \u003d\n            DataTransferEncryptor.getEncryptedStreams(\n                unbufProxyOut, unbufProxyIn,\n                datanode.blockPoolTokenSecretManager\n                    .generateDataEncryptionKey(block.getBlockPoolId()));\n        unbufProxyOut \u003d encryptedStreams.out;\n        unbufProxyIn \u003d encryptedStreams.in;\n      }\n      \n      proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut, \n          HdfsConstants.SMALL_BUFFER_SIZE));\n      proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n          HdfsConstants.IO_FILE_BUFFER_SIZE));\n\n      /* send request to the proxy */\n      new Sender(proxyOut).copyBlock(block, blockToken);\n\n      // receive the response from the proxy\n      \n      BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n          PBHelper.vintPrefixed(proxyReply));\n\n      if (copyResponse.getStatus() !\u003d SUCCESS) {\n        if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n          throw new IOException(\"Copy block \" + block + \" from \"\n              + proxySock.getRemoteSocketAddress()\n              + \" failed due to access token error\");\n        }\n        throw new IOException(\"Copy block \" + block + \" from \"\n            + proxySock.getRemoteSocketAddress() + \" failed\");\n      }\n      \n      // get checksum info about the block we\u0027re copying\n      ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n      DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n          checksumInfo.getChecksum());\n      // open a block receiver and check if the block does not exist\n      blockReceiver \u003d new BlockReceiver(\n          block, proxyReply, proxySock.getRemoteSocketAddress().toString(),\n          proxySock.getLocalSocketAddress().toString(),\n          null, 0, 0, 0, \"\", null, datanode, remoteChecksum,\n          CachingStrategy.newDropBehind());\n\n      // receive a block\n      blockReceiver.receiveBlock(null, null, null, null, \n          dataXceiverServer.balanceThrottler, null);\n                    \n      // notify name node\n      datanode.notifyNamenodeReceivedBlock(\n          block, delHint, blockReceiver.getReplicaInfo().getStorageUuid());\n\n      LOG.info(\"Moved \" + block + \" from \" + peer.getRemoteAddressString()\n          + \", delHint\u003d\" + delHint);\n      \n    } catch (IOException ioe) {\n      opStatus \u003d ERROR;\n      errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n      LOG.info(errMsg);\n      throw ioe;\n    } finally {\n      // receive the last byte that indicates the proxy released its thread resource\n      if (opStatus \u003d\u003d SUCCESS) {\n        try {\n          proxyReply.readChar();\n        } catch (IOException ignored) {\n        }\n      }\n      \n      // now release the thread resource\n      dataXceiverServer.balanceThrottler.release();\n      \n      // send response back\n      try {\n        sendResponse(opStatus, errMsg);\n      } catch (IOException ioe) {\n        LOG.warn(\"Error writing reply back to \" + peer.getRemoteAddressString());\n      }\n      IOUtils.closeStream(proxyOut);\n      IOUtils.closeStream(blockReceiver);\n      IOUtils.closeStream(proxyReply);\n    }\n\n    //update metrics\n    datanode.metrics.addReplaceBlockOp(elapsed());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "01f37e42f050207b7659bf74e2484cf8bdae2d89": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5390. Send one incremental block report per storage directory.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2832@1534891 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "22/10/13 6:28 PM",
      "commitName": "01f37e42f050207b7659bf74e2484cf8bdae2d89",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "22/09/13 11:03 AM",
      "commitNameOld": "4551da302d94cffea0313eac79479ab6f9b7cb34",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 30.31,
      "commitsBetweenForRepo": 225,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,135 +1,136 @@\n   public void replaceBlock(final ExtendedBlock block,\n       final Token\u003cBlockTokenIdentifier\u003e blockToken,\n       final String delHint,\n       final DatanodeInfo proxySource) throws IOException {\n     updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n \n     /* read header */\n     block.setNumBytes(dataXceiverServer.estimateBlockSize);\n     if (datanode.isBlockTokenEnabled) {\n       try {\n         datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n             BlockTokenSecretManager.AccessMode.REPLACE);\n       } catch (InvalidToken e) {\n         LOG.warn(\"Invalid access token in request from \" + remoteAddress\n             + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n             + e.getLocalizedMessage());\n         sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n         return;\n       }\n     }\n \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n       String msg \u003d \"Not able to receive block \" + block.getBlockId() +\n           \" from \" + peer.getRemoteAddressString() + \" because threads \" +\n           \"quota is exceeded.\";\n       LOG.warn(msg);\n       sendResponse(ERROR, msg);\n       return;\n     }\n \n     Socket proxySock \u003d null;\n     DataOutputStream proxyOut \u003d null;\n     Status opStatus \u003d SUCCESS;\n     String errMsg \u003d null;\n     BlockReceiver blockReceiver \u003d null;\n     DataInputStream proxyReply \u003d null;\n     \n     try {\n       // get the output stream to the proxy\n       final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Connecting to datanode \" + dnAddr);\n       }\n       InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n       proxySock \u003d datanode.newSocket();\n       NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n       proxySock.setSoTimeout(dnConf.socketTimeout);\n \n       OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n           dnConf.socketWriteTimeout);\n       InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n       if (dnConf.encryptDataTransfer) {\n         IOStreamPair encryptedStreams \u003d\n             DataTransferEncryptor.getEncryptedStreams(\n                 unbufProxyOut, unbufProxyIn,\n                 datanode.blockPoolTokenSecretManager\n                     .generateDataEncryptionKey(block.getBlockPoolId()));\n         unbufProxyOut \u003d encryptedStreams.out;\n         unbufProxyIn \u003d encryptedStreams.in;\n       }\n       \n       proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut, \n           HdfsConstants.SMALL_BUFFER_SIZE));\n       proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n           HdfsConstants.IO_FILE_BUFFER_SIZE));\n \n       /* send request to the proxy */\n       new Sender(proxyOut).copyBlock(block, blockToken);\n \n       // receive the response from the proxy\n       \n       BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n           PBHelper.vintPrefixed(proxyReply));\n \n       if (copyResponse.getStatus() !\u003d SUCCESS) {\n         if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n           throw new IOException(\"Copy block \" + block + \" from \"\n               + proxySock.getRemoteSocketAddress()\n               + \" failed due to access token error\");\n         }\n         throw new IOException(\"Copy block \" + block + \" from \"\n             + proxySock.getRemoteSocketAddress() + \" failed\");\n       }\n       \n       // get checksum info about the block we\u0027re copying\n       ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n       DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n           checksumInfo.getChecksum());\n       // open a block receiver and check if the block does not exist\n       blockReceiver \u003d new BlockReceiver(\n           block, proxyReply, proxySock.getRemoteSocketAddress().toString(),\n           proxySock.getLocalSocketAddress().toString(),\n           null, 0, 0, 0, \"\", null, datanode, remoteChecksum,\n           CachingStrategy.newDropBehind());\n \n       // receive a block\n       blockReceiver.receiveBlock(null, null, null, null, \n           dataXceiverServer.balanceThrottler, null);\n                     \n       // notify name node\n-      datanode.notifyNamenodeReceivedBlock(block, delHint);\n+      datanode.notifyNamenodeReceivedBlock(\n+          block, delHint, blockReceiver.getReplicaInfo().getStorageUuid());\n \n       LOG.info(\"Moved \" + block + \" from \" + peer.getRemoteAddressString());\n       \n     } catch (IOException ioe) {\n       opStatus \u003d ERROR;\n       errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n       LOG.info(errMsg);\n       throw ioe;\n     } finally {\n       // receive the last byte that indicates the proxy released its thread resource\n       if (opStatus \u003d\u003d SUCCESS) {\n         try {\n           proxyReply.readChar();\n         } catch (IOException ignored) {\n         }\n       }\n       \n       // now release the thread resource\n       dataXceiverServer.balanceThrottler.release();\n       \n       // send response back\n       try {\n         sendResponse(opStatus, errMsg);\n       } catch (IOException ioe) {\n         LOG.warn(\"Error writing reply back to \" + peer.getRemoteAddressString());\n       }\n       IOUtils.closeStream(proxyOut);\n       IOUtils.closeStream(blockReceiver);\n       IOUtils.closeStream(proxyReply);\n     }\n \n     //update metrics\n     datanode.metrics.addReplaceBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void replaceBlock(final ExtendedBlock block,\n      final Token\u003cBlockTokenIdentifier\u003e blockToken,\n      final String delHint,\n      final DatanodeInfo proxySource) throws IOException {\n    updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n\n    /* read header */\n    block.setNumBytes(dataXceiverServer.estimateBlockSize);\n    if (datanode.isBlockTokenEnabled) {\n      try {\n        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n            BlockTokenSecretManager.AccessMode.REPLACE);\n      } catch (InvalidToken e) {\n        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n            + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n            + e.getLocalizedMessage());\n        sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n        return;\n      }\n    }\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      String msg \u003d \"Not able to receive block \" + block.getBlockId() +\n          \" from \" + peer.getRemoteAddressString() + \" because threads \" +\n          \"quota is exceeded.\";\n      LOG.warn(msg);\n      sendResponse(ERROR, msg);\n      return;\n    }\n\n    Socket proxySock \u003d null;\n    DataOutputStream proxyOut \u003d null;\n    Status opStatus \u003d SUCCESS;\n    String errMsg \u003d null;\n    BlockReceiver blockReceiver \u003d null;\n    DataInputStream proxyReply \u003d null;\n    \n    try {\n      // get the output stream to the proxy\n      final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Connecting to datanode \" + dnAddr);\n      }\n      InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n      proxySock \u003d datanode.newSocket();\n      NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n      proxySock.setSoTimeout(dnConf.socketTimeout);\n\n      OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n          dnConf.socketWriteTimeout);\n      InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n      if (dnConf.encryptDataTransfer) {\n        IOStreamPair encryptedStreams \u003d\n            DataTransferEncryptor.getEncryptedStreams(\n                unbufProxyOut, unbufProxyIn,\n                datanode.blockPoolTokenSecretManager\n                    .generateDataEncryptionKey(block.getBlockPoolId()));\n        unbufProxyOut \u003d encryptedStreams.out;\n        unbufProxyIn \u003d encryptedStreams.in;\n      }\n      \n      proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut, \n          HdfsConstants.SMALL_BUFFER_SIZE));\n      proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n          HdfsConstants.IO_FILE_BUFFER_SIZE));\n\n      /* send request to the proxy */\n      new Sender(proxyOut).copyBlock(block, blockToken);\n\n      // receive the response from the proxy\n      \n      BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n          PBHelper.vintPrefixed(proxyReply));\n\n      if (copyResponse.getStatus() !\u003d SUCCESS) {\n        if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n          throw new IOException(\"Copy block \" + block + \" from \"\n              + proxySock.getRemoteSocketAddress()\n              + \" failed due to access token error\");\n        }\n        throw new IOException(\"Copy block \" + block + \" from \"\n            + proxySock.getRemoteSocketAddress() + \" failed\");\n      }\n      \n      // get checksum info about the block we\u0027re copying\n      ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n      DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n          checksumInfo.getChecksum());\n      // open a block receiver and check if the block does not exist\n      blockReceiver \u003d new BlockReceiver(\n          block, proxyReply, proxySock.getRemoteSocketAddress().toString(),\n          proxySock.getLocalSocketAddress().toString(),\n          null, 0, 0, 0, \"\", null, datanode, remoteChecksum,\n          CachingStrategy.newDropBehind());\n\n      // receive a block\n      blockReceiver.receiveBlock(null, null, null, null, \n          dataXceiverServer.balanceThrottler, null);\n                    \n      // notify name node\n      datanode.notifyNamenodeReceivedBlock(\n          block, delHint, blockReceiver.getReplicaInfo().getStorageUuid());\n\n      LOG.info(\"Moved \" + block + \" from \" + peer.getRemoteAddressString());\n      \n    } catch (IOException ioe) {\n      opStatus \u003d ERROR;\n      errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n      LOG.info(errMsg);\n      throw ioe;\n    } finally {\n      // receive the last byte that indicates the proxy released its thread resource\n      if (opStatus \u003d\u003d SUCCESS) {\n        try {\n          proxyReply.readChar();\n        } catch (IOException ignored) {\n        }\n      }\n      \n      // now release the thread resource\n      dataXceiverServer.balanceThrottler.release();\n      \n      // send response back\n      try {\n        sendResponse(opStatus, errMsg);\n      } catch (IOException ioe) {\n        LOG.warn(\"Error writing reply back to \" + peer.getRemoteAddressString());\n      }\n      IOUtils.closeStream(proxyOut);\n      IOUtils.closeStream(blockReceiver);\n      IOUtils.closeStream(proxyReply);\n    }\n\n    //update metrics\n    datanode.metrics.addReplaceBlockOp(elapsed());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "c1314eb2a382bd9ce045a2fcc4a9e5c1fc368a24": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4817.  Make HDFS advisory caching configurable on a per-file basis.  (Colin Patrick McCabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1505753 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "22/07/13 11:15 AM",
      "commitName": "c1314eb2a382bd9ce045a2fcc4a9e5c1fc368a24",
      "commitAuthor": "Colin McCabe",
      "commitDateOld": "09/05/13 5:03 PM",
      "commitNameOld": "a18fd620d070cf8e84aaf80d93807ac9ee207a0f",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 73.76,
      "commitsBetweenForRepo": 437,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,134 +1,135 @@\n   public void replaceBlock(final ExtendedBlock block,\n       final Token\u003cBlockTokenIdentifier\u003e blockToken,\n       final String delHint,\n       final DatanodeInfo proxySource) throws IOException {\n     updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n \n     /* read header */\n     block.setNumBytes(dataXceiverServer.estimateBlockSize);\n     if (datanode.isBlockTokenEnabled) {\n       try {\n         datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n             BlockTokenSecretManager.AccessMode.REPLACE);\n       } catch (InvalidToken e) {\n         LOG.warn(\"Invalid access token in request from \" + remoteAddress\n             + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n             + e.getLocalizedMessage());\n         sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n         return;\n       }\n     }\n \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n       String msg \u003d \"Not able to receive block \" + block.getBlockId() +\n           \" from \" + peer.getRemoteAddressString() + \" because threads \" +\n           \"quota is exceeded.\";\n       LOG.warn(msg);\n       sendResponse(ERROR, msg);\n       return;\n     }\n \n     Socket proxySock \u003d null;\n     DataOutputStream proxyOut \u003d null;\n     Status opStatus \u003d SUCCESS;\n     String errMsg \u003d null;\n     BlockReceiver blockReceiver \u003d null;\n     DataInputStream proxyReply \u003d null;\n     \n     try {\n       // get the output stream to the proxy\n       final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Connecting to datanode \" + dnAddr);\n       }\n       InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n       proxySock \u003d datanode.newSocket();\n       NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n       proxySock.setSoTimeout(dnConf.socketTimeout);\n \n       OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n           dnConf.socketWriteTimeout);\n       InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n       if (dnConf.encryptDataTransfer) {\n         IOStreamPair encryptedStreams \u003d\n             DataTransferEncryptor.getEncryptedStreams(\n                 unbufProxyOut, unbufProxyIn,\n                 datanode.blockPoolTokenSecretManager\n                     .generateDataEncryptionKey(block.getBlockPoolId()));\n         unbufProxyOut \u003d encryptedStreams.out;\n         unbufProxyIn \u003d encryptedStreams.in;\n       }\n       \n       proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut, \n           HdfsConstants.SMALL_BUFFER_SIZE));\n       proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n           HdfsConstants.IO_FILE_BUFFER_SIZE));\n \n       /* send request to the proxy */\n       new Sender(proxyOut).copyBlock(block, blockToken);\n \n       // receive the response from the proxy\n       \n       BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n           PBHelper.vintPrefixed(proxyReply));\n \n       if (copyResponse.getStatus() !\u003d SUCCESS) {\n         if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n           throw new IOException(\"Copy block \" + block + \" from \"\n               + proxySock.getRemoteSocketAddress()\n               + \" failed due to access token error\");\n         }\n         throw new IOException(\"Copy block \" + block + \" from \"\n             + proxySock.getRemoteSocketAddress() + \" failed\");\n       }\n       \n       // get checksum info about the block we\u0027re copying\n       ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n       DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n           checksumInfo.getChecksum());\n       // open a block receiver and check if the block does not exist\n       blockReceiver \u003d new BlockReceiver(\n           block, proxyReply, proxySock.getRemoteSocketAddress().toString(),\n           proxySock.getLocalSocketAddress().toString(),\n-          null, 0, 0, 0, \"\", null, datanode, remoteChecksum);\n+          null, 0, 0, 0, \"\", null, datanode, remoteChecksum,\n+          CachingStrategy.newDropBehind());\n \n       // receive a block\n       blockReceiver.receiveBlock(null, null, null, null, \n           dataXceiverServer.balanceThrottler, null);\n                     \n       // notify name node\n       datanode.notifyNamenodeReceivedBlock(block, delHint);\n \n       LOG.info(\"Moved \" + block + \" from \" + peer.getRemoteAddressString());\n       \n     } catch (IOException ioe) {\n       opStatus \u003d ERROR;\n       errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n       LOG.info(errMsg);\n       throw ioe;\n     } finally {\n       // receive the last byte that indicates the proxy released its thread resource\n       if (opStatus \u003d\u003d SUCCESS) {\n         try {\n           proxyReply.readChar();\n         } catch (IOException ignored) {\n         }\n       }\n       \n       // now release the thread resource\n       dataXceiverServer.balanceThrottler.release();\n       \n       // send response back\n       try {\n         sendResponse(opStatus, errMsg);\n       } catch (IOException ioe) {\n         LOG.warn(\"Error writing reply back to \" + peer.getRemoteAddressString());\n       }\n       IOUtils.closeStream(proxyOut);\n       IOUtils.closeStream(blockReceiver);\n       IOUtils.closeStream(proxyReply);\n     }\n \n     //update metrics\n     datanode.metrics.addReplaceBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void replaceBlock(final ExtendedBlock block,\n      final Token\u003cBlockTokenIdentifier\u003e blockToken,\n      final String delHint,\n      final DatanodeInfo proxySource) throws IOException {\n    updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n\n    /* read header */\n    block.setNumBytes(dataXceiverServer.estimateBlockSize);\n    if (datanode.isBlockTokenEnabled) {\n      try {\n        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n            BlockTokenSecretManager.AccessMode.REPLACE);\n      } catch (InvalidToken e) {\n        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n            + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n            + e.getLocalizedMessage());\n        sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n        return;\n      }\n    }\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      String msg \u003d \"Not able to receive block \" + block.getBlockId() +\n          \" from \" + peer.getRemoteAddressString() + \" because threads \" +\n          \"quota is exceeded.\";\n      LOG.warn(msg);\n      sendResponse(ERROR, msg);\n      return;\n    }\n\n    Socket proxySock \u003d null;\n    DataOutputStream proxyOut \u003d null;\n    Status opStatus \u003d SUCCESS;\n    String errMsg \u003d null;\n    BlockReceiver blockReceiver \u003d null;\n    DataInputStream proxyReply \u003d null;\n    \n    try {\n      // get the output stream to the proxy\n      final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Connecting to datanode \" + dnAddr);\n      }\n      InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n      proxySock \u003d datanode.newSocket();\n      NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n      proxySock.setSoTimeout(dnConf.socketTimeout);\n\n      OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n          dnConf.socketWriteTimeout);\n      InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n      if (dnConf.encryptDataTransfer) {\n        IOStreamPair encryptedStreams \u003d\n            DataTransferEncryptor.getEncryptedStreams(\n                unbufProxyOut, unbufProxyIn,\n                datanode.blockPoolTokenSecretManager\n                    .generateDataEncryptionKey(block.getBlockPoolId()));\n        unbufProxyOut \u003d encryptedStreams.out;\n        unbufProxyIn \u003d encryptedStreams.in;\n      }\n      \n      proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut, \n          HdfsConstants.SMALL_BUFFER_SIZE));\n      proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n          HdfsConstants.IO_FILE_BUFFER_SIZE));\n\n      /* send request to the proxy */\n      new Sender(proxyOut).copyBlock(block, blockToken);\n\n      // receive the response from the proxy\n      \n      BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n          PBHelper.vintPrefixed(proxyReply));\n\n      if (copyResponse.getStatus() !\u003d SUCCESS) {\n        if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n          throw new IOException(\"Copy block \" + block + \" from \"\n              + proxySock.getRemoteSocketAddress()\n              + \" failed due to access token error\");\n        }\n        throw new IOException(\"Copy block \" + block + \" from \"\n            + proxySock.getRemoteSocketAddress() + \" failed\");\n      }\n      \n      // get checksum info about the block we\u0027re copying\n      ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n      DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n          checksumInfo.getChecksum());\n      // open a block receiver and check if the block does not exist\n      blockReceiver \u003d new BlockReceiver(\n          block, proxyReply, proxySock.getRemoteSocketAddress().toString(),\n          proxySock.getLocalSocketAddress().toString(),\n          null, 0, 0, 0, \"\", null, datanode, remoteChecksum,\n          CachingStrategy.newDropBehind());\n\n      // receive a block\n      blockReceiver.receiveBlock(null, null, null, null, \n          dataXceiverServer.balanceThrottler, null);\n                    \n      // notify name node\n      datanode.notifyNamenodeReceivedBlock(block, delHint);\n\n      LOG.info(\"Moved \" + block + \" from \" + peer.getRemoteAddressString());\n      \n    } catch (IOException ioe) {\n      opStatus \u003d ERROR;\n      errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n      LOG.info(errMsg);\n      throw ioe;\n    } finally {\n      // receive the last byte that indicates the proxy released its thread resource\n      if (opStatus \u003d\u003d SUCCESS) {\n        try {\n          proxyReply.readChar();\n        } catch (IOException ignored) {\n        }\n      }\n      \n      // now release the thread resource\n      dataXceiverServer.balanceThrottler.release();\n      \n      // send response back\n      try {\n        sendResponse(opStatus, errMsg);\n      } catch (IOException ioe) {\n        LOG.warn(\"Error writing reply back to \" + peer.getRemoteAddressString());\n      }\n      IOUtils.closeStream(proxyOut);\n      IOUtils.closeStream(blockReceiver);\n      IOUtils.closeStream(proxyReply);\n    }\n\n    //update metrics\n    datanode.metrics.addReplaceBlockOp(elapsed());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "c9db06f2e4d1c1f71f021d5070323f9fc194cdd7": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4353. Encapsulate connections to peers in Peer and PeerServer classes. Contributed by Colin Patrick McCabe.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-347@1431097 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/01/13 1:34 PM",
      "commitName": "c9db06f2e4d1c1f71f021d5070323f9fc194cdd7",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "08/01/13 6:39 PM",
      "commitNameOld": "837e17b2eac1471d93e2eff395272063b265fee7",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 0.79,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,133 +1,134 @@\n   public void replaceBlock(final ExtendedBlock block,\n       final Token\u003cBlockTokenIdentifier\u003e blockToken,\n       final String delHint,\n       final DatanodeInfo proxySource) throws IOException {\n     updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n \n     /* read header */\n     block.setNumBytes(dataXceiverServer.estimateBlockSize);\n     if (datanode.isBlockTokenEnabled) {\n       try {\n         datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n             BlockTokenSecretManager.AccessMode.REPLACE);\n       } catch (InvalidToken e) {\n         LOG.warn(\"Invalid access token in request from \" + remoteAddress\n             + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n             + e.getLocalizedMessage());\n         sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n         return;\n       }\n     }\n \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n-      String msg \u003d \"Not able to receive block \" + block.getBlockId() + \" from \" \n-          + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\"; \n+      String msg \u003d \"Not able to receive block \" + block.getBlockId() +\n+          \" from \" + peer.getRemoteAddressString() + \" because threads \" +\n+          \"quota is exceeded.\";\n       LOG.warn(msg);\n       sendResponse(ERROR, msg);\n       return;\n     }\n \n     Socket proxySock \u003d null;\n     DataOutputStream proxyOut \u003d null;\n     Status opStatus \u003d SUCCESS;\n     String errMsg \u003d null;\n     BlockReceiver blockReceiver \u003d null;\n     DataInputStream proxyReply \u003d null;\n     \n     try {\n       // get the output stream to the proxy\n       final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Connecting to datanode \" + dnAddr);\n       }\n       InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n       proxySock \u003d datanode.newSocket();\n       NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n       proxySock.setSoTimeout(dnConf.socketTimeout);\n \n       OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n           dnConf.socketWriteTimeout);\n       InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n       if (dnConf.encryptDataTransfer) {\n         IOStreamPair encryptedStreams \u003d\n             DataTransferEncryptor.getEncryptedStreams(\n                 unbufProxyOut, unbufProxyIn,\n                 datanode.blockPoolTokenSecretManager\n                     .generateDataEncryptionKey(block.getBlockPoolId()));\n         unbufProxyOut \u003d encryptedStreams.out;\n         unbufProxyIn \u003d encryptedStreams.in;\n       }\n       \n       proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut, \n           HdfsConstants.SMALL_BUFFER_SIZE));\n       proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n           HdfsConstants.IO_FILE_BUFFER_SIZE));\n \n       /* send request to the proxy */\n       new Sender(proxyOut).copyBlock(block, blockToken);\n \n       // receive the response from the proxy\n       \n       BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n           HdfsProtoUtil.vintPrefixed(proxyReply));\n \n       if (copyResponse.getStatus() !\u003d SUCCESS) {\n         if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n           throw new IOException(\"Copy block \" + block + \" from \"\n               + proxySock.getRemoteSocketAddress()\n               + \" failed due to access token error\");\n         }\n         throw new IOException(\"Copy block \" + block + \" from \"\n             + proxySock.getRemoteSocketAddress() + \" failed\");\n       }\n       \n       // get checksum info about the block we\u0027re copying\n       ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n       DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n           checksumInfo.getChecksum());\n       // open a block receiver and check if the block does not exist\n       blockReceiver \u003d new BlockReceiver(\n           block, proxyReply, proxySock.getRemoteSocketAddress().toString(),\n           proxySock.getLocalSocketAddress().toString(),\n           null, 0, 0, 0, \"\", null, datanode, remoteChecksum);\n \n       // receive a block\n       blockReceiver.receiveBlock(null, null, null, null, \n           dataXceiverServer.balanceThrottler, null);\n                     \n       // notify name node\n       datanode.notifyNamenodeReceivedBlock(block, delHint);\n \n-      LOG.info(\"Moved \" + block + \" from \" + s.getRemoteSocketAddress());\n+      LOG.info(\"Moved \" + block + \" from \" + peer.getRemoteAddressString());\n       \n     } catch (IOException ioe) {\n       opStatus \u003d ERROR;\n       errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n       LOG.info(errMsg);\n       throw ioe;\n     } finally {\n       // receive the last byte that indicates the proxy released its thread resource\n       if (opStatus \u003d\u003d SUCCESS) {\n         try {\n           proxyReply.readChar();\n         } catch (IOException ignored) {\n         }\n       }\n       \n       // now release the thread resource\n       dataXceiverServer.balanceThrottler.release();\n       \n       // send response back\n       try {\n         sendResponse(opStatus, errMsg);\n       } catch (IOException ioe) {\n-        LOG.warn(\"Error writing reply back to \" + s.getRemoteSocketAddress());\n+        LOG.warn(\"Error writing reply back to \" + peer.getRemoteAddressString());\n       }\n       IOUtils.closeStream(proxyOut);\n       IOUtils.closeStream(blockReceiver);\n       IOUtils.closeStream(proxyReply);\n     }\n \n     //update metrics\n     datanode.metrics.addReplaceBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void replaceBlock(final ExtendedBlock block,\n      final Token\u003cBlockTokenIdentifier\u003e blockToken,\n      final String delHint,\n      final DatanodeInfo proxySource) throws IOException {\n    updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n\n    /* read header */\n    block.setNumBytes(dataXceiverServer.estimateBlockSize);\n    if (datanode.isBlockTokenEnabled) {\n      try {\n        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n            BlockTokenSecretManager.AccessMode.REPLACE);\n      } catch (InvalidToken e) {\n        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n            + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n            + e.getLocalizedMessage());\n        sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n        return;\n      }\n    }\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      String msg \u003d \"Not able to receive block \" + block.getBlockId() +\n          \" from \" + peer.getRemoteAddressString() + \" because threads \" +\n          \"quota is exceeded.\";\n      LOG.warn(msg);\n      sendResponse(ERROR, msg);\n      return;\n    }\n\n    Socket proxySock \u003d null;\n    DataOutputStream proxyOut \u003d null;\n    Status opStatus \u003d SUCCESS;\n    String errMsg \u003d null;\n    BlockReceiver blockReceiver \u003d null;\n    DataInputStream proxyReply \u003d null;\n    \n    try {\n      // get the output stream to the proxy\n      final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Connecting to datanode \" + dnAddr);\n      }\n      InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n      proxySock \u003d datanode.newSocket();\n      NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n      proxySock.setSoTimeout(dnConf.socketTimeout);\n\n      OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n          dnConf.socketWriteTimeout);\n      InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n      if (dnConf.encryptDataTransfer) {\n        IOStreamPair encryptedStreams \u003d\n            DataTransferEncryptor.getEncryptedStreams(\n                unbufProxyOut, unbufProxyIn,\n                datanode.blockPoolTokenSecretManager\n                    .generateDataEncryptionKey(block.getBlockPoolId()));\n        unbufProxyOut \u003d encryptedStreams.out;\n        unbufProxyIn \u003d encryptedStreams.in;\n      }\n      \n      proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut, \n          HdfsConstants.SMALL_BUFFER_SIZE));\n      proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n          HdfsConstants.IO_FILE_BUFFER_SIZE));\n\n      /* send request to the proxy */\n      new Sender(proxyOut).copyBlock(block, blockToken);\n\n      // receive the response from the proxy\n      \n      BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n          HdfsProtoUtil.vintPrefixed(proxyReply));\n\n      if (copyResponse.getStatus() !\u003d SUCCESS) {\n        if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n          throw new IOException(\"Copy block \" + block + \" from \"\n              + proxySock.getRemoteSocketAddress()\n              + \" failed due to access token error\");\n        }\n        throw new IOException(\"Copy block \" + block + \" from \"\n            + proxySock.getRemoteSocketAddress() + \" failed\");\n      }\n      \n      // get checksum info about the block we\u0027re copying\n      ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n      DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n          checksumInfo.getChecksum());\n      // open a block receiver and check if the block does not exist\n      blockReceiver \u003d new BlockReceiver(\n          block, proxyReply, proxySock.getRemoteSocketAddress().toString(),\n          proxySock.getLocalSocketAddress().toString(),\n          null, 0, 0, 0, \"\", null, datanode, remoteChecksum);\n\n      // receive a block\n      blockReceiver.receiveBlock(null, null, null, null, \n          dataXceiverServer.balanceThrottler, null);\n                    \n      // notify name node\n      datanode.notifyNamenodeReceivedBlock(block, delHint);\n\n      LOG.info(\"Moved \" + block + \" from \" + peer.getRemoteAddressString());\n      \n    } catch (IOException ioe) {\n      opStatus \u003d ERROR;\n      errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n      LOG.info(errMsg);\n      throw ioe;\n    } finally {\n      // receive the last byte that indicates the proxy released its thread resource\n      if (opStatus \u003d\u003d SUCCESS) {\n        try {\n          proxyReply.readChar();\n        } catch (IOException ignored) {\n        }\n      }\n      \n      // now release the thread resource\n      dataXceiverServer.balanceThrottler.release();\n      \n      // send response back\n      try {\n        sendResponse(opStatus, errMsg);\n      } catch (IOException ioe) {\n        LOG.warn(\"Error writing reply back to \" + peer.getRemoteAddressString());\n      }\n      IOUtils.closeStream(proxyOut);\n      IOUtils.closeStream(blockReceiver);\n      IOUtils.closeStream(proxyReply);\n    }\n\n    //update metrics\n    datanode.metrics.addReplaceBlockOp(elapsed());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "3cd17b614e9436d06cd9b4ccc5f9cf59fbe1cf21": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4363. Combine PBHelper and HdfsProtoUtil and remove redundant methods. Contributed by Suresh Srinivas.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1431088 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/01/13 1:20 PM",
      "commitName": "3cd17b614e9436d06cd9b4ccc5f9cf59fbe1cf21",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "08/01/13 6:39 PM",
      "commitNameOld": "837e17b2eac1471d93e2eff395272063b265fee7",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 0.78,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,133 +1,133 @@\n   public void replaceBlock(final ExtendedBlock block,\n       final Token\u003cBlockTokenIdentifier\u003e blockToken,\n       final String delHint,\n       final DatanodeInfo proxySource) throws IOException {\n     updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n \n     /* read header */\n     block.setNumBytes(dataXceiverServer.estimateBlockSize);\n     if (datanode.isBlockTokenEnabled) {\n       try {\n         datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n             BlockTokenSecretManager.AccessMode.REPLACE);\n       } catch (InvalidToken e) {\n         LOG.warn(\"Invalid access token in request from \" + remoteAddress\n             + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n             + e.getLocalizedMessage());\n         sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n         return;\n       }\n     }\n \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n       String msg \u003d \"Not able to receive block \" + block.getBlockId() + \" from \" \n           + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\"; \n       LOG.warn(msg);\n       sendResponse(ERROR, msg);\n       return;\n     }\n \n     Socket proxySock \u003d null;\n     DataOutputStream proxyOut \u003d null;\n     Status opStatus \u003d SUCCESS;\n     String errMsg \u003d null;\n     BlockReceiver blockReceiver \u003d null;\n     DataInputStream proxyReply \u003d null;\n     \n     try {\n       // get the output stream to the proxy\n       final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Connecting to datanode \" + dnAddr);\n       }\n       InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n       proxySock \u003d datanode.newSocket();\n       NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n       proxySock.setSoTimeout(dnConf.socketTimeout);\n \n       OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n           dnConf.socketWriteTimeout);\n       InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n       if (dnConf.encryptDataTransfer) {\n         IOStreamPair encryptedStreams \u003d\n             DataTransferEncryptor.getEncryptedStreams(\n                 unbufProxyOut, unbufProxyIn,\n                 datanode.blockPoolTokenSecretManager\n                     .generateDataEncryptionKey(block.getBlockPoolId()));\n         unbufProxyOut \u003d encryptedStreams.out;\n         unbufProxyIn \u003d encryptedStreams.in;\n       }\n       \n       proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut, \n           HdfsConstants.SMALL_BUFFER_SIZE));\n       proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n           HdfsConstants.IO_FILE_BUFFER_SIZE));\n \n       /* send request to the proxy */\n       new Sender(proxyOut).copyBlock(block, blockToken);\n \n       // receive the response from the proxy\n       \n       BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n-          HdfsProtoUtil.vintPrefixed(proxyReply));\n+          PBHelper.vintPrefixed(proxyReply));\n \n       if (copyResponse.getStatus() !\u003d SUCCESS) {\n         if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n           throw new IOException(\"Copy block \" + block + \" from \"\n               + proxySock.getRemoteSocketAddress()\n               + \" failed due to access token error\");\n         }\n         throw new IOException(\"Copy block \" + block + \" from \"\n             + proxySock.getRemoteSocketAddress() + \" failed\");\n       }\n       \n       // get checksum info about the block we\u0027re copying\n       ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n       DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n           checksumInfo.getChecksum());\n       // open a block receiver and check if the block does not exist\n       blockReceiver \u003d new BlockReceiver(\n           block, proxyReply, proxySock.getRemoteSocketAddress().toString(),\n           proxySock.getLocalSocketAddress().toString(),\n           null, 0, 0, 0, \"\", null, datanode, remoteChecksum);\n \n       // receive a block\n       blockReceiver.receiveBlock(null, null, null, null, \n           dataXceiverServer.balanceThrottler, null);\n                     \n       // notify name node\n       datanode.notifyNamenodeReceivedBlock(block, delHint);\n \n       LOG.info(\"Moved \" + block + \" from \" + s.getRemoteSocketAddress());\n       \n     } catch (IOException ioe) {\n       opStatus \u003d ERROR;\n       errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n       LOG.info(errMsg);\n       throw ioe;\n     } finally {\n       // receive the last byte that indicates the proxy released its thread resource\n       if (opStatus \u003d\u003d SUCCESS) {\n         try {\n           proxyReply.readChar();\n         } catch (IOException ignored) {\n         }\n       }\n       \n       // now release the thread resource\n       dataXceiverServer.balanceThrottler.release();\n       \n       // send response back\n       try {\n         sendResponse(opStatus, errMsg);\n       } catch (IOException ioe) {\n         LOG.warn(\"Error writing reply back to \" + s.getRemoteSocketAddress());\n       }\n       IOUtils.closeStream(proxyOut);\n       IOUtils.closeStream(blockReceiver);\n       IOUtils.closeStream(proxyReply);\n     }\n \n     //update metrics\n     datanode.metrics.addReplaceBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void replaceBlock(final ExtendedBlock block,\n      final Token\u003cBlockTokenIdentifier\u003e blockToken,\n      final String delHint,\n      final DatanodeInfo proxySource) throws IOException {\n    updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n\n    /* read header */\n    block.setNumBytes(dataXceiverServer.estimateBlockSize);\n    if (datanode.isBlockTokenEnabled) {\n      try {\n        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n            BlockTokenSecretManager.AccessMode.REPLACE);\n      } catch (InvalidToken e) {\n        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n            + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n            + e.getLocalizedMessage());\n        sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n        return;\n      }\n    }\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      String msg \u003d \"Not able to receive block \" + block.getBlockId() + \" from \" \n          + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\"; \n      LOG.warn(msg);\n      sendResponse(ERROR, msg);\n      return;\n    }\n\n    Socket proxySock \u003d null;\n    DataOutputStream proxyOut \u003d null;\n    Status opStatus \u003d SUCCESS;\n    String errMsg \u003d null;\n    BlockReceiver blockReceiver \u003d null;\n    DataInputStream proxyReply \u003d null;\n    \n    try {\n      // get the output stream to the proxy\n      final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Connecting to datanode \" + dnAddr);\n      }\n      InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n      proxySock \u003d datanode.newSocket();\n      NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n      proxySock.setSoTimeout(dnConf.socketTimeout);\n\n      OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n          dnConf.socketWriteTimeout);\n      InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n      if (dnConf.encryptDataTransfer) {\n        IOStreamPair encryptedStreams \u003d\n            DataTransferEncryptor.getEncryptedStreams(\n                unbufProxyOut, unbufProxyIn,\n                datanode.blockPoolTokenSecretManager\n                    .generateDataEncryptionKey(block.getBlockPoolId()));\n        unbufProxyOut \u003d encryptedStreams.out;\n        unbufProxyIn \u003d encryptedStreams.in;\n      }\n      \n      proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut, \n          HdfsConstants.SMALL_BUFFER_SIZE));\n      proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n          HdfsConstants.IO_FILE_BUFFER_SIZE));\n\n      /* send request to the proxy */\n      new Sender(proxyOut).copyBlock(block, blockToken);\n\n      // receive the response from the proxy\n      \n      BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n          PBHelper.vintPrefixed(proxyReply));\n\n      if (copyResponse.getStatus() !\u003d SUCCESS) {\n        if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n          throw new IOException(\"Copy block \" + block + \" from \"\n              + proxySock.getRemoteSocketAddress()\n              + \" failed due to access token error\");\n        }\n        throw new IOException(\"Copy block \" + block + \" from \"\n            + proxySock.getRemoteSocketAddress() + \" failed\");\n      }\n      \n      // get checksum info about the block we\u0027re copying\n      ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n      DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n          checksumInfo.getChecksum());\n      // open a block receiver and check if the block does not exist\n      blockReceiver \u003d new BlockReceiver(\n          block, proxyReply, proxySock.getRemoteSocketAddress().toString(),\n          proxySock.getLocalSocketAddress().toString(),\n          null, 0, 0, 0, \"\", null, datanode, remoteChecksum);\n\n      // receive a block\n      blockReceiver.receiveBlock(null, null, null, null, \n          dataXceiverServer.balanceThrottler, null);\n                    \n      // notify name node\n      datanode.notifyNamenodeReceivedBlock(block, delHint);\n\n      LOG.info(\"Moved \" + block + \" from \" + s.getRemoteSocketAddress());\n      \n    } catch (IOException ioe) {\n      opStatus \u003d ERROR;\n      errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n      LOG.info(errMsg);\n      throw ioe;\n    } finally {\n      // receive the last byte that indicates the proxy released its thread resource\n      if (opStatus \u003d\u003d SUCCESS) {\n        try {\n          proxyReply.readChar();\n        } catch (IOException ignored) {\n        }\n      }\n      \n      // now release the thread resource\n      dataXceiverServer.balanceThrottler.release();\n      \n      // send response back\n      try {\n        sendResponse(opStatus, errMsg);\n      } catch (IOException ioe) {\n        LOG.warn(\"Error writing reply back to \" + s.getRemoteSocketAddress());\n      }\n      IOUtils.closeStream(proxyOut);\n      IOUtils.closeStream(blockReceiver);\n      IOUtils.closeStream(proxyReply);\n    }\n\n    //update metrics\n    datanode.metrics.addReplaceBlockOp(elapsed());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "837e17b2eac1471d93e2eff395272063b265fee7": {
      "type": "Ybodychange",
      "commitMessage": "svn merge -c -1430507 . for reverting HDFS-4353. Encapsulate connections to peers in Peer and PeerServer classes\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1430662 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/01/13 6:39 PM",
      "commitName": "837e17b2eac1471d93e2eff395272063b265fee7",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "08/01/13 12:44 PM",
      "commitNameOld": "239b2742d0e80d13c970fd062af4930e672fe903",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 0.25,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,134 +1,133 @@\n   public void replaceBlock(final ExtendedBlock block,\n       final Token\u003cBlockTokenIdentifier\u003e blockToken,\n       final String delHint,\n       final DatanodeInfo proxySource) throws IOException {\n     updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n \n     /* read header */\n     block.setNumBytes(dataXceiverServer.estimateBlockSize);\n     if (datanode.isBlockTokenEnabled) {\n       try {\n         datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n             BlockTokenSecretManager.AccessMode.REPLACE);\n       } catch (InvalidToken e) {\n         LOG.warn(\"Invalid access token in request from \" + remoteAddress\n             + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n             + e.getLocalizedMessage());\n         sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n         return;\n       }\n     }\n \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n-      String msg \u003d \"Not able to receive block \" + block.getBlockId() +\n-          \" from \" + peer.getRemoteAddressString() + \" because threads \" +\n-          \"quota is exceeded.\";\n+      String msg \u003d \"Not able to receive block \" + block.getBlockId() + \" from \" \n+          + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\"; \n       LOG.warn(msg);\n       sendResponse(ERROR, msg);\n       return;\n     }\n \n     Socket proxySock \u003d null;\n     DataOutputStream proxyOut \u003d null;\n     Status opStatus \u003d SUCCESS;\n     String errMsg \u003d null;\n     BlockReceiver blockReceiver \u003d null;\n     DataInputStream proxyReply \u003d null;\n     \n     try {\n       // get the output stream to the proxy\n       final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Connecting to datanode \" + dnAddr);\n       }\n       InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n       proxySock \u003d datanode.newSocket();\n       NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n       proxySock.setSoTimeout(dnConf.socketTimeout);\n \n       OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n           dnConf.socketWriteTimeout);\n       InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n       if (dnConf.encryptDataTransfer) {\n         IOStreamPair encryptedStreams \u003d\n             DataTransferEncryptor.getEncryptedStreams(\n                 unbufProxyOut, unbufProxyIn,\n                 datanode.blockPoolTokenSecretManager\n                     .generateDataEncryptionKey(block.getBlockPoolId()));\n         unbufProxyOut \u003d encryptedStreams.out;\n         unbufProxyIn \u003d encryptedStreams.in;\n       }\n       \n       proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut, \n           HdfsConstants.SMALL_BUFFER_SIZE));\n       proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n           HdfsConstants.IO_FILE_BUFFER_SIZE));\n \n       /* send request to the proxy */\n       new Sender(proxyOut).copyBlock(block, blockToken);\n \n       // receive the response from the proxy\n       \n       BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n           HdfsProtoUtil.vintPrefixed(proxyReply));\n \n       if (copyResponse.getStatus() !\u003d SUCCESS) {\n         if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n           throw new IOException(\"Copy block \" + block + \" from \"\n               + proxySock.getRemoteSocketAddress()\n               + \" failed due to access token error\");\n         }\n         throw new IOException(\"Copy block \" + block + \" from \"\n             + proxySock.getRemoteSocketAddress() + \" failed\");\n       }\n       \n       // get checksum info about the block we\u0027re copying\n       ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n       DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n           checksumInfo.getChecksum());\n       // open a block receiver and check if the block does not exist\n       blockReceiver \u003d new BlockReceiver(\n           block, proxyReply, proxySock.getRemoteSocketAddress().toString(),\n           proxySock.getLocalSocketAddress().toString(),\n           null, 0, 0, 0, \"\", null, datanode, remoteChecksum);\n \n       // receive a block\n       blockReceiver.receiveBlock(null, null, null, null, \n           dataXceiverServer.balanceThrottler, null);\n                     \n       // notify name node\n       datanode.notifyNamenodeReceivedBlock(block, delHint);\n \n-      LOG.info(\"Moved \" + block + \" from \" + peer.getRemoteAddressString());\n+      LOG.info(\"Moved \" + block + \" from \" + s.getRemoteSocketAddress());\n       \n     } catch (IOException ioe) {\n       opStatus \u003d ERROR;\n       errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n       LOG.info(errMsg);\n       throw ioe;\n     } finally {\n       // receive the last byte that indicates the proxy released its thread resource\n       if (opStatus \u003d\u003d SUCCESS) {\n         try {\n           proxyReply.readChar();\n         } catch (IOException ignored) {\n         }\n       }\n       \n       // now release the thread resource\n       dataXceiverServer.balanceThrottler.release();\n       \n       // send response back\n       try {\n         sendResponse(opStatus, errMsg);\n       } catch (IOException ioe) {\n-        LOG.warn(\"Error writing reply back to \" + peer.getRemoteAddressString());\n+        LOG.warn(\"Error writing reply back to \" + s.getRemoteSocketAddress());\n       }\n       IOUtils.closeStream(proxyOut);\n       IOUtils.closeStream(blockReceiver);\n       IOUtils.closeStream(proxyReply);\n     }\n \n     //update metrics\n     datanode.metrics.addReplaceBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void replaceBlock(final ExtendedBlock block,\n      final Token\u003cBlockTokenIdentifier\u003e blockToken,\n      final String delHint,\n      final DatanodeInfo proxySource) throws IOException {\n    updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n\n    /* read header */\n    block.setNumBytes(dataXceiverServer.estimateBlockSize);\n    if (datanode.isBlockTokenEnabled) {\n      try {\n        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n            BlockTokenSecretManager.AccessMode.REPLACE);\n      } catch (InvalidToken e) {\n        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n            + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n            + e.getLocalizedMessage());\n        sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n        return;\n      }\n    }\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      String msg \u003d \"Not able to receive block \" + block.getBlockId() + \" from \" \n          + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\"; \n      LOG.warn(msg);\n      sendResponse(ERROR, msg);\n      return;\n    }\n\n    Socket proxySock \u003d null;\n    DataOutputStream proxyOut \u003d null;\n    Status opStatus \u003d SUCCESS;\n    String errMsg \u003d null;\n    BlockReceiver blockReceiver \u003d null;\n    DataInputStream proxyReply \u003d null;\n    \n    try {\n      // get the output stream to the proxy\n      final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Connecting to datanode \" + dnAddr);\n      }\n      InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n      proxySock \u003d datanode.newSocket();\n      NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n      proxySock.setSoTimeout(dnConf.socketTimeout);\n\n      OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n          dnConf.socketWriteTimeout);\n      InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n      if (dnConf.encryptDataTransfer) {\n        IOStreamPair encryptedStreams \u003d\n            DataTransferEncryptor.getEncryptedStreams(\n                unbufProxyOut, unbufProxyIn,\n                datanode.blockPoolTokenSecretManager\n                    .generateDataEncryptionKey(block.getBlockPoolId()));\n        unbufProxyOut \u003d encryptedStreams.out;\n        unbufProxyIn \u003d encryptedStreams.in;\n      }\n      \n      proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut, \n          HdfsConstants.SMALL_BUFFER_SIZE));\n      proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n          HdfsConstants.IO_FILE_BUFFER_SIZE));\n\n      /* send request to the proxy */\n      new Sender(proxyOut).copyBlock(block, blockToken);\n\n      // receive the response from the proxy\n      \n      BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n          HdfsProtoUtil.vintPrefixed(proxyReply));\n\n      if (copyResponse.getStatus() !\u003d SUCCESS) {\n        if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n          throw new IOException(\"Copy block \" + block + \" from \"\n              + proxySock.getRemoteSocketAddress()\n              + \" failed due to access token error\");\n        }\n        throw new IOException(\"Copy block \" + block + \" from \"\n            + proxySock.getRemoteSocketAddress() + \" failed\");\n      }\n      \n      // get checksum info about the block we\u0027re copying\n      ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n      DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n          checksumInfo.getChecksum());\n      // open a block receiver and check if the block does not exist\n      blockReceiver \u003d new BlockReceiver(\n          block, proxyReply, proxySock.getRemoteSocketAddress().toString(),\n          proxySock.getLocalSocketAddress().toString(),\n          null, 0, 0, 0, \"\", null, datanode, remoteChecksum);\n\n      // receive a block\n      blockReceiver.receiveBlock(null, null, null, null, \n          dataXceiverServer.balanceThrottler, null);\n                    \n      // notify name node\n      datanode.notifyNamenodeReceivedBlock(block, delHint);\n\n      LOG.info(\"Moved \" + block + \" from \" + s.getRemoteSocketAddress());\n      \n    } catch (IOException ioe) {\n      opStatus \u003d ERROR;\n      errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n      LOG.info(errMsg);\n      throw ioe;\n    } finally {\n      // receive the last byte that indicates the proxy released its thread resource\n      if (opStatus \u003d\u003d SUCCESS) {\n        try {\n          proxyReply.readChar();\n        } catch (IOException ignored) {\n        }\n      }\n      \n      // now release the thread resource\n      dataXceiverServer.balanceThrottler.release();\n      \n      // send response back\n      try {\n        sendResponse(opStatus, errMsg);\n      } catch (IOException ioe) {\n        LOG.warn(\"Error writing reply back to \" + s.getRemoteSocketAddress());\n      }\n      IOUtils.closeStream(proxyOut);\n      IOUtils.closeStream(blockReceiver);\n      IOUtils.closeStream(proxyReply);\n    }\n\n    //update metrics\n    datanode.metrics.addReplaceBlockOp(elapsed());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "239b2742d0e80d13c970fd062af4930e672fe903": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4353. Encapsulate connections to peers in Peer and PeerServer classes. Contributed by Colin Patrick McCabe.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1430507 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/01/13 12:44 PM",
      "commitName": "239b2742d0e80d13c970fd062af4930e672fe903",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "28/10/12 4:10 PM",
      "commitNameOld": "cea7bbc630deede93dbe6a1bbda56ad49de4f3de",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 71.9,
      "commitsBetweenForRepo": 300,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,133 +1,134 @@\n   public void replaceBlock(final ExtendedBlock block,\n       final Token\u003cBlockTokenIdentifier\u003e blockToken,\n       final String delHint,\n       final DatanodeInfo proxySource) throws IOException {\n     updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n \n     /* read header */\n     block.setNumBytes(dataXceiverServer.estimateBlockSize);\n     if (datanode.isBlockTokenEnabled) {\n       try {\n         datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n             BlockTokenSecretManager.AccessMode.REPLACE);\n       } catch (InvalidToken e) {\n         LOG.warn(\"Invalid access token in request from \" + remoteAddress\n             + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n             + e.getLocalizedMessage());\n         sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n         return;\n       }\n     }\n \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n-      String msg \u003d \"Not able to receive block \" + block.getBlockId() + \" from \" \n-          + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\"; \n+      String msg \u003d \"Not able to receive block \" + block.getBlockId() +\n+          \" from \" + peer.getRemoteAddressString() + \" because threads \" +\n+          \"quota is exceeded.\";\n       LOG.warn(msg);\n       sendResponse(ERROR, msg);\n       return;\n     }\n \n     Socket proxySock \u003d null;\n     DataOutputStream proxyOut \u003d null;\n     Status opStatus \u003d SUCCESS;\n     String errMsg \u003d null;\n     BlockReceiver blockReceiver \u003d null;\n     DataInputStream proxyReply \u003d null;\n     \n     try {\n       // get the output stream to the proxy\n       final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Connecting to datanode \" + dnAddr);\n       }\n       InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n       proxySock \u003d datanode.newSocket();\n       NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n       proxySock.setSoTimeout(dnConf.socketTimeout);\n \n       OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n           dnConf.socketWriteTimeout);\n       InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n       if (dnConf.encryptDataTransfer) {\n         IOStreamPair encryptedStreams \u003d\n             DataTransferEncryptor.getEncryptedStreams(\n                 unbufProxyOut, unbufProxyIn,\n                 datanode.blockPoolTokenSecretManager\n                     .generateDataEncryptionKey(block.getBlockPoolId()));\n         unbufProxyOut \u003d encryptedStreams.out;\n         unbufProxyIn \u003d encryptedStreams.in;\n       }\n       \n       proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut, \n           HdfsConstants.SMALL_BUFFER_SIZE));\n       proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n           HdfsConstants.IO_FILE_BUFFER_SIZE));\n \n       /* send request to the proxy */\n       new Sender(proxyOut).copyBlock(block, blockToken);\n \n       // receive the response from the proxy\n       \n       BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n           HdfsProtoUtil.vintPrefixed(proxyReply));\n \n       if (copyResponse.getStatus() !\u003d SUCCESS) {\n         if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n           throw new IOException(\"Copy block \" + block + \" from \"\n               + proxySock.getRemoteSocketAddress()\n               + \" failed due to access token error\");\n         }\n         throw new IOException(\"Copy block \" + block + \" from \"\n             + proxySock.getRemoteSocketAddress() + \" failed\");\n       }\n       \n       // get checksum info about the block we\u0027re copying\n       ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n       DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n           checksumInfo.getChecksum());\n       // open a block receiver and check if the block does not exist\n       blockReceiver \u003d new BlockReceiver(\n           block, proxyReply, proxySock.getRemoteSocketAddress().toString(),\n           proxySock.getLocalSocketAddress().toString(),\n           null, 0, 0, 0, \"\", null, datanode, remoteChecksum);\n \n       // receive a block\n       blockReceiver.receiveBlock(null, null, null, null, \n           dataXceiverServer.balanceThrottler, null);\n                     \n       // notify name node\n       datanode.notifyNamenodeReceivedBlock(block, delHint);\n \n-      LOG.info(\"Moved \" + block + \" from \" + s.getRemoteSocketAddress());\n+      LOG.info(\"Moved \" + block + \" from \" + peer.getRemoteAddressString());\n       \n     } catch (IOException ioe) {\n       opStatus \u003d ERROR;\n       errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n       LOG.info(errMsg);\n       throw ioe;\n     } finally {\n       // receive the last byte that indicates the proxy released its thread resource\n       if (opStatus \u003d\u003d SUCCESS) {\n         try {\n           proxyReply.readChar();\n         } catch (IOException ignored) {\n         }\n       }\n       \n       // now release the thread resource\n       dataXceiverServer.balanceThrottler.release();\n       \n       // send response back\n       try {\n         sendResponse(opStatus, errMsg);\n       } catch (IOException ioe) {\n-        LOG.warn(\"Error writing reply back to \" + s.getRemoteSocketAddress());\n+        LOG.warn(\"Error writing reply back to \" + peer.getRemoteAddressString());\n       }\n       IOUtils.closeStream(proxyOut);\n       IOUtils.closeStream(blockReceiver);\n       IOUtils.closeStream(proxyReply);\n     }\n \n     //update metrics\n     datanode.metrics.addReplaceBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void replaceBlock(final ExtendedBlock block,\n      final Token\u003cBlockTokenIdentifier\u003e blockToken,\n      final String delHint,\n      final DatanodeInfo proxySource) throws IOException {\n    updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n\n    /* read header */\n    block.setNumBytes(dataXceiverServer.estimateBlockSize);\n    if (datanode.isBlockTokenEnabled) {\n      try {\n        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n            BlockTokenSecretManager.AccessMode.REPLACE);\n      } catch (InvalidToken e) {\n        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n            + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n            + e.getLocalizedMessage());\n        sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n        return;\n      }\n    }\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      String msg \u003d \"Not able to receive block \" + block.getBlockId() +\n          \" from \" + peer.getRemoteAddressString() + \" because threads \" +\n          \"quota is exceeded.\";\n      LOG.warn(msg);\n      sendResponse(ERROR, msg);\n      return;\n    }\n\n    Socket proxySock \u003d null;\n    DataOutputStream proxyOut \u003d null;\n    Status opStatus \u003d SUCCESS;\n    String errMsg \u003d null;\n    BlockReceiver blockReceiver \u003d null;\n    DataInputStream proxyReply \u003d null;\n    \n    try {\n      // get the output stream to the proxy\n      final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Connecting to datanode \" + dnAddr);\n      }\n      InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n      proxySock \u003d datanode.newSocket();\n      NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n      proxySock.setSoTimeout(dnConf.socketTimeout);\n\n      OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n          dnConf.socketWriteTimeout);\n      InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n      if (dnConf.encryptDataTransfer) {\n        IOStreamPair encryptedStreams \u003d\n            DataTransferEncryptor.getEncryptedStreams(\n                unbufProxyOut, unbufProxyIn,\n                datanode.blockPoolTokenSecretManager\n                    .generateDataEncryptionKey(block.getBlockPoolId()));\n        unbufProxyOut \u003d encryptedStreams.out;\n        unbufProxyIn \u003d encryptedStreams.in;\n      }\n      \n      proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut, \n          HdfsConstants.SMALL_BUFFER_SIZE));\n      proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n          HdfsConstants.IO_FILE_BUFFER_SIZE));\n\n      /* send request to the proxy */\n      new Sender(proxyOut).copyBlock(block, blockToken);\n\n      // receive the response from the proxy\n      \n      BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n          HdfsProtoUtil.vintPrefixed(proxyReply));\n\n      if (copyResponse.getStatus() !\u003d SUCCESS) {\n        if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n          throw new IOException(\"Copy block \" + block + \" from \"\n              + proxySock.getRemoteSocketAddress()\n              + \" failed due to access token error\");\n        }\n        throw new IOException(\"Copy block \" + block + \" from \"\n            + proxySock.getRemoteSocketAddress() + \" failed\");\n      }\n      \n      // get checksum info about the block we\u0027re copying\n      ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n      DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n          checksumInfo.getChecksum());\n      // open a block receiver and check if the block does not exist\n      blockReceiver \u003d new BlockReceiver(\n          block, proxyReply, proxySock.getRemoteSocketAddress().toString(),\n          proxySock.getLocalSocketAddress().toString(),\n          null, 0, 0, 0, \"\", null, datanode, remoteChecksum);\n\n      // receive a block\n      blockReceiver.receiveBlock(null, null, null, null, \n          dataXceiverServer.balanceThrottler, null);\n                    \n      // notify name node\n      datanode.notifyNamenodeReceivedBlock(block, delHint);\n\n      LOG.info(\"Moved \" + block + \" from \" + peer.getRemoteAddressString());\n      \n    } catch (IOException ioe) {\n      opStatus \u003d ERROR;\n      errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n      LOG.info(errMsg);\n      throw ioe;\n    } finally {\n      // receive the last byte that indicates the proxy released its thread resource\n      if (opStatus \u003d\u003d SUCCESS) {\n        try {\n          proxyReply.readChar();\n        } catch (IOException ignored) {\n        }\n      }\n      \n      // now release the thread resource\n      dataXceiverServer.balanceThrottler.release();\n      \n      // send response back\n      try {\n        sendResponse(opStatus, errMsg);\n      } catch (IOException ioe) {\n        LOG.warn(\"Error writing reply back to \" + peer.getRemoteAddressString());\n      }\n      IOUtils.closeStream(proxyOut);\n      IOUtils.closeStream(blockReceiver);\n      IOUtils.closeStream(proxyReply);\n    }\n\n    //update metrics\n    datanode.metrics.addReplaceBlockOp(elapsed());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "cea7bbc630deede93dbe6a1bbda56ad49de4f3de": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4122. Cleanup HDFS logs and reduce the size of logged messages. Contributed by Suresh Srinivas.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1403120 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "28/10/12 4:10 PM",
      "commitName": "cea7bbc630deede93dbe6a1bbda56ad49de4f3de",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "24/08/12 7:15 AM",
      "commitNameOld": "c46de830da98959f40dd41c95bdebecdfb9ea730",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 65.37,
      "commitsBetweenForRepo": 392,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,134 +1,133 @@\n   public void replaceBlock(final ExtendedBlock block,\n       final Token\u003cBlockTokenIdentifier\u003e blockToken,\n       final String delHint,\n       final DatanodeInfo proxySource) throws IOException {\n     updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n \n     /* read header */\n     block.setNumBytes(dataXceiverServer.estimateBlockSize);\n     if (datanode.isBlockTokenEnabled) {\n       try {\n         datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n             BlockTokenSecretManager.AccessMode.REPLACE);\n       } catch (InvalidToken e) {\n         LOG.warn(\"Invalid access token in request from \" + remoteAddress\n             + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n             + e.getLocalizedMessage());\n         sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n         return;\n       }\n     }\n \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n       String msg \u003d \"Not able to receive block \" + block.getBlockId() + \" from \" \n           + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\"; \n       LOG.warn(msg);\n       sendResponse(ERROR, msg);\n       return;\n     }\n \n     Socket proxySock \u003d null;\n     DataOutputStream proxyOut \u003d null;\n     Status opStatus \u003d SUCCESS;\n     String errMsg \u003d null;\n     BlockReceiver blockReceiver \u003d null;\n     DataInputStream proxyReply \u003d null;\n     \n     try {\n       // get the output stream to the proxy\n       final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Connecting to datanode \" + dnAddr);\n       }\n       InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n       proxySock \u003d datanode.newSocket();\n       NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n       proxySock.setSoTimeout(dnConf.socketTimeout);\n \n       OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n           dnConf.socketWriteTimeout);\n       InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n       if (dnConf.encryptDataTransfer) {\n         IOStreamPair encryptedStreams \u003d\n             DataTransferEncryptor.getEncryptedStreams(\n                 unbufProxyOut, unbufProxyIn,\n                 datanode.blockPoolTokenSecretManager\n                     .generateDataEncryptionKey(block.getBlockPoolId()));\n         unbufProxyOut \u003d encryptedStreams.out;\n         unbufProxyIn \u003d encryptedStreams.in;\n       }\n       \n       proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut, \n           HdfsConstants.SMALL_BUFFER_SIZE));\n       proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n           HdfsConstants.IO_FILE_BUFFER_SIZE));\n \n       /* send request to the proxy */\n       new Sender(proxyOut).copyBlock(block, blockToken);\n \n       // receive the response from the proxy\n       \n       BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n           HdfsProtoUtil.vintPrefixed(proxyReply));\n \n       if (copyResponse.getStatus() !\u003d SUCCESS) {\n         if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n           throw new IOException(\"Copy block \" + block + \" from \"\n               + proxySock.getRemoteSocketAddress()\n               + \" failed due to access token error\");\n         }\n         throw new IOException(\"Copy block \" + block + \" from \"\n             + proxySock.getRemoteSocketAddress() + \" failed\");\n       }\n       \n       // get checksum info about the block we\u0027re copying\n       ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n       DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n           checksumInfo.getChecksum());\n       // open a block receiver and check if the block does not exist\n       blockReceiver \u003d new BlockReceiver(\n           block, proxyReply, proxySock.getRemoteSocketAddress().toString(),\n           proxySock.getLocalSocketAddress().toString(),\n           null, 0, 0, 0, \"\", null, datanode, remoteChecksum);\n \n       // receive a block\n       blockReceiver.receiveBlock(null, null, null, null, \n           dataXceiverServer.balanceThrottler, null);\n                     \n       // notify name node\n       datanode.notifyNamenodeReceivedBlock(block, delHint);\n \n-      LOG.info(\"Moved block \" + block + \n-          \" from \" + s.getRemoteSocketAddress());\n+      LOG.info(\"Moved \" + block + \" from \" + s.getRemoteSocketAddress());\n       \n     } catch (IOException ioe) {\n       opStatus \u003d ERROR;\n       errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n       LOG.info(errMsg);\n       throw ioe;\n     } finally {\n       // receive the last byte that indicates the proxy released its thread resource\n       if (opStatus \u003d\u003d SUCCESS) {\n         try {\n           proxyReply.readChar();\n         } catch (IOException ignored) {\n         }\n       }\n       \n       // now release the thread resource\n       dataXceiverServer.balanceThrottler.release();\n       \n       // send response back\n       try {\n         sendResponse(opStatus, errMsg);\n       } catch (IOException ioe) {\n         LOG.warn(\"Error writing reply back to \" + s.getRemoteSocketAddress());\n       }\n       IOUtils.closeStream(proxyOut);\n       IOUtils.closeStream(blockReceiver);\n       IOUtils.closeStream(proxyReply);\n     }\n \n     //update metrics\n     datanode.metrics.addReplaceBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void replaceBlock(final ExtendedBlock block,\n      final Token\u003cBlockTokenIdentifier\u003e blockToken,\n      final String delHint,\n      final DatanodeInfo proxySource) throws IOException {\n    updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n\n    /* read header */\n    block.setNumBytes(dataXceiverServer.estimateBlockSize);\n    if (datanode.isBlockTokenEnabled) {\n      try {\n        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n            BlockTokenSecretManager.AccessMode.REPLACE);\n      } catch (InvalidToken e) {\n        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n            + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n            + e.getLocalizedMessage());\n        sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n        return;\n      }\n    }\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      String msg \u003d \"Not able to receive block \" + block.getBlockId() + \" from \" \n          + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\"; \n      LOG.warn(msg);\n      sendResponse(ERROR, msg);\n      return;\n    }\n\n    Socket proxySock \u003d null;\n    DataOutputStream proxyOut \u003d null;\n    Status opStatus \u003d SUCCESS;\n    String errMsg \u003d null;\n    BlockReceiver blockReceiver \u003d null;\n    DataInputStream proxyReply \u003d null;\n    \n    try {\n      // get the output stream to the proxy\n      final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Connecting to datanode \" + dnAddr);\n      }\n      InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n      proxySock \u003d datanode.newSocket();\n      NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n      proxySock.setSoTimeout(dnConf.socketTimeout);\n\n      OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n          dnConf.socketWriteTimeout);\n      InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n      if (dnConf.encryptDataTransfer) {\n        IOStreamPair encryptedStreams \u003d\n            DataTransferEncryptor.getEncryptedStreams(\n                unbufProxyOut, unbufProxyIn,\n                datanode.blockPoolTokenSecretManager\n                    .generateDataEncryptionKey(block.getBlockPoolId()));\n        unbufProxyOut \u003d encryptedStreams.out;\n        unbufProxyIn \u003d encryptedStreams.in;\n      }\n      \n      proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut, \n          HdfsConstants.SMALL_BUFFER_SIZE));\n      proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n          HdfsConstants.IO_FILE_BUFFER_SIZE));\n\n      /* send request to the proxy */\n      new Sender(proxyOut).copyBlock(block, blockToken);\n\n      // receive the response from the proxy\n      \n      BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n          HdfsProtoUtil.vintPrefixed(proxyReply));\n\n      if (copyResponse.getStatus() !\u003d SUCCESS) {\n        if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n          throw new IOException(\"Copy block \" + block + \" from \"\n              + proxySock.getRemoteSocketAddress()\n              + \" failed due to access token error\");\n        }\n        throw new IOException(\"Copy block \" + block + \" from \"\n            + proxySock.getRemoteSocketAddress() + \" failed\");\n      }\n      \n      // get checksum info about the block we\u0027re copying\n      ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n      DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n          checksumInfo.getChecksum());\n      // open a block receiver and check if the block does not exist\n      blockReceiver \u003d new BlockReceiver(\n          block, proxyReply, proxySock.getRemoteSocketAddress().toString(),\n          proxySock.getLocalSocketAddress().toString(),\n          null, 0, 0, 0, \"\", null, datanode, remoteChecksum);\n\n      // receive a block\n      blockReceiver.receiveBlock(null, null, null, null, \n          dataXceiverServer.balanceThrottler, null);\n                    \n      // notify name node\n      datanode.notifyNamenodeReceivedBlock(block, delHint);\n\n      LOG.info(\"Moved \" + block + \" from \" + s.getRemoteSocketAddress());\n      \n    } catch (IOException ioe) {\n      opStatus \u003d ERROR;\n      errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n      LOG.info(errMsg);\n      throw ioe;\n    } finally {\n      // receive the last byte that indicates the proxy released its thread resource\n      if (opStatus \u003d\u003d SUCCESS) {\n        try {\n          proxyReply.readChar();\n        } catch (IOException ignored) {\n        }\n      }\n      \n      // now release the thread resource\n      dataXceiverServer.balanceThrottler.release();\n      \n      // send response back\n      try {\n        sendResponse(opStatus, errMsg);\n      } catch (IOException ioe) {\n        LOG.warn(\"Error writing reply back to \" + s.getRemoteSocketAddress());\n      }\n      IOUtils.closeStream(proxyOut);\n      IOUtils.closeStream(blockReceiver);\n      IOUtils.closeStream(proxyReply);\n    }\n\n    //update metrics\n    datanode.metrics.addReplaceBlockOp(elapsed());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "f98d8eb291be364102b5c3011ce72e8f43eab389": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3150. Add option for clients to contact DNs via hostname. Contributed by Eli Collins\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1373094 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/08/12 1:59 PM",
      "commitName": "f98d8eb291be364102b5c3011ce72e8f43eab389",
      "commitAuthor": "Eli Collins",
      "commitDateOld": "07/08/12 9:40 AM",
      "commitNameOld": "9b4a7900c7dfc0590316eedaa97144f938885651",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 7.18,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,131 +1,134 @@\n   public void replaceBlock(final ExtendedBlock block,\n       final Token\u003cBlockTokenIdentifier\u003e blockToken,\n       final String delHint,\n       final DatanodeInfo proxySource) throws IOException {\n     updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n \n     /* read header */\n     block.setNumBytes(dataXceiverServer.estimateBlockSize);\n     if (datanode.isBlockTokenEnabled) {\n       try {\n         datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n             BlockTokenSecretManager.AccessMode.REPLACE);\n       } catch (InvalidToken e) {\n         LOG.warn(\"Invalid access token in request from \" + remoteAddress\n             + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n             + e.getLocalizedMessage());\n         sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n         return;\n       }\n     }\n \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n       String msg \u003d \"Not able to receive block \" + block.getBlockId() + \" from \" \n           + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\"; \n       LOG.warn(msg);\n       sendResponse(ERROR, msg);\n       return;\n     }\n \n     Socket proxySock \u003d null;\n     DataOutputStream proxyOut \u003d null;\n     Status opStatus \u003d SUCCESS;\n     String errMsg \u003d null;\n     BlockReceiver blockReceiver \u003d null;\n     DataInputStream proxyReply \u003d null;\n     \n     try {\n       // get the output stream to the proxy\n-      InetSocketAddress proxyAddr \u003d\n-        NetUtils.createSocketAddr(proxySource.getXferAddr());\n+      final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Connecting to datanode \" + dnAddr);\n+      }\n+      InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n       proxySock \u003d datanode.newSocket();\n       NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n       proxySock.setSoTimeout(dnConf.socketTimeout);\n \n       OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n           dnConf.socketWriteTimeout);\n       InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n       if (dnConf.encryptDataTransfer) {\n         IOStreamPair encryptedStreams \u003d\n             DataTransferEncryptor.getEncryptedStreams(\n                 unbufProxyOut, unbufProxyIn,\n                 datanode.blockPoolTokenSecretManager\n                     .generateDataEncryptionKey(block.getBlockPoolId()));\n         unbufProxyOut \u003d encryptedStreams.out;\n         unbufProxyIn \u003d encryptedStreams.in;\n       }\n       \n       proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut, \n           HdfsConstants.SMALL_BUFFER_SIZE));\n       proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n           HdfsConstants.IO_FILE_BUFFER_SIZE));\n \n       /* send request to the proxy */\n       new Sender(proxyOut).copyBlock(block, blockToken);\n \n       // receive the response from the proxy\n       \n       BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n           HdfsProtoUtil.vintPrefixed(proxyReply));\n \n       if (copyResponse.getStatus() !\u003d SUCCESS) {\n         if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n           throw new IOException(\"Copy block \" + block + \" from \"\n               + proxySock.getRemoteSocketAddress()\n               + \" failed due to access token error\");\n         }\n         throw new IOException(\"Copy block \" + block + \" from \"\n             + proxySock.getRemoteSocketAddress() + \" failed\");\n       }\n       \n       // get checksum info about the block we\u0027re copying\n       ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n       DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n           checksumInfo.getChecksum());\n       // open a block receiver and check if the block does not exist\n       blockReceiver \u003d new BlockReceiver(\n           block, proxyReply, proxySock.getRemoteSocketAddress().toString(),\n           proxySock.getLocalSocketAddress().toString(),\n           null, 0, 0, 0, \"\", null, datanode, remoteChecksum);\n \n       // receive a block\n       blockReceiver.receiveBlock(null, null, null, null, \n           dataXceiverServer.balanceThrottler, null);\n                     \n       // notify name node\n       datanode.notifyNamenodeReceivedBlock(block, delHint);\n \n       LOG.info(\"Moved block \" + block + \n           \" from \" + s.getRemoteSocketAddress());\n       \n     } catch (IOException ioe) {\n       opStatus \u003d ERROR;\n       errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n       LOG.info(errMsg);\n       throw ioe;\n     } finally {\n       // receive the last byte that indicates the proxy released its thread resource\n       if (opStatus \u003d\u003d SUCCESS) {\n         try {\n           proxyReply.readChar();\n         } catch (IOException ignored) {\n         }\n       }\n       \n       // now release the thread resource\n       dataXceiverServer.balanceThrottler.release();\n       \n       // send response back\n       try {\n         sendResponse(opStatus, errMsg);\n       } catch (IOException ioe) {\n         LOG.warn(\"Error writing reply back to \" + s.getRemoteSocketAddress());\n       }\n       IOUtils.closeStream(proxyOut);\n       IOUtils.closeStream(blockReceiver);\n       IOUtils.closeStream(proxyReply);\n     }\n \n     //update metrics\n     datanode.metrics.addReplaceBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void replaceBlock(final ExtendedBlock block,\n      final Token\u003cBlockTokenIdentifier\u003e blockToken,\n      final String delHint,\n      final DatanodeInfo proxySource) throws IOException {\n    updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n\n    /* read header */\n    block.setNumBytes(dataXceiverServer.estimateBlockSize);\n    if (datanode.isBlockTokenEnabled) {\n      try {\n        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n            BlockTokenSecretManager.AccessMode.REPLACE);\n      } catch (InvalidToken e) {\n        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n            + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n            + e.getLocalizedMessage());\n        sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n        return;\n      }\n    }\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      String msg \u003d \"Not able to receive block \" + block.getBlockId() + \" from \" \n          + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\"; \n      LOG.warn(msg);\n      sendResponse(ERROR, msg);\n      return;\n    }\n\n    Socket proxySock \u003d null;\n    DataOutputStream proxyOut \u003d null;\n    Status opStatus \u003d SUCCESS;\n    String errMsg \u003d null;\n    BlockReceiver blockReceiver \u003d null;\n    DataInputStream proxyReply \u003d null;\n    \n    try {\n      // get the output stream to the proxy\n      final String dnAddr \u003d proxySource.getXferAddr(connectToDnViaHostname);\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Connecting to datanode \" + dnAddr);\n      }\n      InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(dnAddr);\n      proxySock \u003d datanode.newSocket();\n      NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n      proxySock.setSoTimeout(dnConf.socketTimeout);\n\n      OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n          dnConf.socketWriteTimeout);\n      InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n      if (dnConf.encryptDataTransfer) {\n        IOStreamPair encryptedStreams \u003d\n            DataTransferEncryptor.getEncryptedStreams(\n                unbufProxyOut, unbufProxyIn,\n                datanode.blockPoolTokenSecretManager\n                    .generateDataEncryptionKey(block.getBlockPoolId()));\n        unbufProxyOut \u003d encryptedStreams.out;\n        unbufProxyIn \u003d encryptedStreams.in;\n      }\n      \n      proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut, \n          HdfsConstants.SMALL_BUFFER_SIZE));\n      proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n          HdfsConstants.IO_FILE_BUFFER_SIZE));\n\n      /* send request to the proxy */\n      new Sender(proxyOut).copyBlock(block, blockToken);\n\n      // receive the response from the proxy\n      \n      BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n          HdfsProtoUtil.vintPrefixed(proxyReply));\n\n      if (copyResponse.getStatus() !\u003d SUCCESS) {\n        if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n          throw new IOException(\"Copy block \" + block + \" from \"\n              + proxySock.getRemoteSocketAddress()\n              + \" failed due to access token error\");\n        }\n        throw new IOException(\"Copy block \" + block + \" from \"\n            + proxySock.getRemoteSocketAddress() + \" failed\");\n      }\n      \n      // get checksum info about the block we\u0027re copying\n      ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n      DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n          checksumInfo.getChecksum());\n      // open a block receiver and check if the block does not exist\n      blockReceiver \u003d new BlockReceiver(\n          block, proxyReply, proxySock.getRemoteSocketAddress().toString(),\n          proxySock.getLocalSocketAddress().toString(),\n          null, 0, 0, 0, \"\", null, datanode, remoteChecksum);\n\n      // receive a block\n      blockReceiver.receiveBlock(null, null, null, null, \n          dataXceiverServer.balanceThrottler, null);\n                    \n      // notify name node\n      datanode.notifyNamenodeReceivedBlock(block, delHint);\n\n      LOG.info(\"Moved block \" + block + \n          \" from \" + s.getRemoteSocketAddress());\n      \n    } catch (IOException ioe) {\n      opStatus \u003d ERROR;\n      errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n      LOG.info(errMsg);\n      throw ioe;\n    } finally {\n      // receive the last byte that indicates the proxy released its thread resource\n      if (opStatus \u003d\u003d SUCCESS) {\n        try {\n          proxyReply.readChar();\n        } catch (IOException ignored) {\n        }\n      }\n      \n      // now release the thread resource\n      dataXceiverServer.balanceThrottler.release();\n      \n      // send response back\n      try {\n        sendResponse(opStatus, errMsg);\n      } catch (IOException ioe) {\n        LOG.warn(\"Error writing reply back to \" + s.getRemoteSocketAddress());\n      }\n      IOUtils.closeStream(proxyOut);\n      IOUtils.closeStream(blockReceiver);\n      IOUtils.closeStream(proxyReply);\n    }\n\n    //update metrics\n    datanode.metrics.addReplaceBlockOp(elapsed());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "9b4a7900c7dfc0590316eedaa97144f938885651": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3637. Add support for encrypting the DataTransferProtocol. Contributed by Aaron T. Myers.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1370354 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/08/12 9:40 AM",
      "commitName": "9b4a7900c7dfc0590316eedaa97144f938885651",
      "commitAuthor": "Aaron Myers",
      "commitDateOld": "15/07/12 7:58 PM",
      "commitNameOld": "0e8e499ff482c165d21c8e4f5ff9c33f306ca0d9",
      "commitAuthorOld": "Harsh J",
      "daysBetweenCommits": 22.57,
      "commitsBetweenForRepo": 106,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,120 +1,131 @@\n   public void replaceBlock(final ExtendedBlock block,\n       final Token\u003cBlockTokenIdentifier\u003e blockToken,\n       final String delHint,\n       final DatanodeInfo proxySource) throws IOException {\n     updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n \n     /* read header */\n     block.setNumBytes(dataXceiverServer.estimateBlockSize);\n     if (datanode.isBlockTokenEnabled) {\n       try {\n         datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n             BlockTokenSecretManager.AccessMode.REPLACE);\n       } catch (InvalidToken e) {\n         LOG.warn(\"Invalid access token in request from \" + remoteAddress\n             + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n             + e.getLocalizedMessage());\n-        sendResponse(s, ERROR_ACCESS_TOKEN, \"Invalid access token\",\n-            dnConf.socketWriteTimeout);\n+        sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n         return;\n       }\n     }\n \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n       String msg \u003d \"Not able to receive block \" + block.getBlockId() + \" from \" \n           + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\"; \n       LOG.warn(msg);\n-      sendResponse(s, ERROR, msg, dnConf.socketWriteTimeout);\n+      sendResponse(ERROR, msg);\n       return;\n     }\n \n     Socket proxySock \u003d null;\n     DataOutputStream proxyOut \u003d null;\n     Status opStatus \u003d SUCCESS;\n     String errMsg \u003d null;\n     BlockReceiver blockReceiver \u003d null;\n     DataInputStream proxyReply \u003d null;\n     \n     try {\n       // get the output stream to the proxy\n       InetSocketAddress proxyAddr \u003d\n         NetUtils.createSocketAddr(proxySource.getXferAddr());\n       proxySock \u003d datanode.newSocket();\n       NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n       proxySock.setSoTimeout(dnConf.socketTimeout);\n \n-      OutputStream baseStream \u003d NetUtils.getOutputStream(proxySock, \n+      OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n           dnConf.socketWriteTimeout);\n-      proxyOut \u003d new DataOutputStream(new BufferedOutputStream(baseStream,\n+      InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n+      if (dnConf.encryptDataTransfer) {\n+        IOStreamPair encryptedStreams \u003d\n+            DataTransferEncryptor.getEncryptedStreams(\n+                unbufProxyOut, unbufProxyIn,\n+                datanode.blockPoolTokenSecretManager\n+                    .generateDataEncryptionKey(block.getBlockPoolId()));\n+        unbufProxyOut \u003d encryptedStreams.out;\n+        unbufProxyIn \u003d encryptedStreams.in;\n+      }\n+      \n+      proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut, \n           HdfsConstants.SMALL_BUFFER_SIZE));\n+      proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n+          HdfsConstants.IO_FILE_BUFFER_SIZE));\n \n       /* send request to the proxy */\n       new Sender(proxyOut).copyBlock(block, blockToken);\n \n       // receive the response from the proxy\n-      proxyReply \u003d new DataInputStream(new BufferedInputStream(\n-          NetUtils.getInputStream(proxySock), HdfsConstants.IO_FILE_BUFFER_SIZE));\n+      \n       BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n           HdfsProtoUtil.vintPrefixed(proxyReply));\n \n       if (copyResponse.getStatus() !\u003d SUCCESS) {\n         if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n           throw new IOException(\"Copy block \" + block + \" from \"\n               + proxySock.getRemoteSocketAddress()\n               + \" failed due to access token error\");\n         }\n         throw new IOException(\"Copy block \" + block + \" from \"\n             + proxySock.getRemoteSocketAddress() + \" failed\");\n       }\n       \n       // get checksum info about the block we\u0027re copying\n       ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n       DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n           checksumInfo.getChecksum());\n       // open a block receiver and check if the block does not exist\n       blockReceiver \u003d new BlockReceiver(\n           block, proxyReply, proxySock.getRemoteSocketAddress().toString(),\n           proxySock.getLocalSocketAddress().toString(),\n           null, 0, 0, 0, \"\", null, datanode, remoteChecksum);\n \n       // receive a block\n       blockReceiver.receiveBlock(null, null, null, null, \n           dataXceiverServer.balanceThrottler, null);\n                     \n       // notify name node\n       datanode.notifyNamenodeReceivedBlock(block, delHint);\n \n       LOG.info(\"Moved block \" + block + \n           \" from \" + s.getRemoteSocketAddress());\n       \n     } catch (IOException ioe) {\n       opStatus \u003d ERROR;\n       errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n       LOG.info(errMsg);\n       throw ioe;\n     } finally {\n       // receive the last byte that indicates the proxy released its thread resource\n       if (opStatus \u003d\u003d SUCCESS) {\n         try {\n           proxyReply.readChar();\n         } catch (IOException ignored) {\n         }\n       }\n       \n       // now release the thread resource\n       dataXceiverServer.balanceThrottler.release();\n       \n       // send response back\n       try {\n-        sendResponse(s, opStatus, errMsg, dnConf.socketWriteTimeout);\n+        sendResponse(opStatus, errMsg);\n       } catch (IOException ioe) {\n         LOG.warn(\"Error writing reply back to \" + s.getRemoteSocketAddress());\n       }\n       IOUtils.closeStream(proxyOut);\n       IOUtils.closeStream(blockReceiver);\n       IOUtils.closeStream(proxyReply);\n     }\n \n     //update metrics\n     datanode.metrics.addReplaceBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void replaceBlock(final ExtendedBlock block,\n      final Token\u003cBlockTokenIdentifier\u003e blockToken,\n      final String delHint,\n      final DatanodeInfo proxySource) throws IOException {\n    updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n\n    /* read header */\n    block.setNumBytes(dataXceiverServer.estimateBlockSize);\n    if (datanode.isBlockTokenEnabled) {\n      try {\n        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n            BlockTokenSecretManager.AccessMode.REPLACE);\n      } catch (InvalidToken e) {\n        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n            + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n            + e.getLocalizedMessage());\n        sendResponse(ERROR_ACCESS_TOKEN, \"Invalid access token\");\n        return;\n      }\n    }\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      String msg \u003d \"Not able to receive block \" + block.getBlockId() + \" from \" \n          + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\"; \n      LOG.warn(msg);\n      sendResponse(ERROR, msg);\n      return;\n    }\n\n    Socket proxySock \u003d null;\n    DataOutputStream proxyOut \u003d null;\n    Status opStatus \u003d SUCCESS;\n    String errMsg \u003d null;\n    BlockReceiver blockReceiver \u003d null;\n    DataInputStream proxyReply \u003d null;\n    \n    try {\n      // get the output stream to the proxy\n      InetSocketAddress proxyAddr \u003d\n        NetUtils.createSocketAddr(proxySource.getXferAddr());\n      proxySock \u003d datanode.newSocket();\n      NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n      proxySock.setSoTimeout(dnConf.socketTimeout);\n\n      OutputStream unbufProxyOut \u003d NetUtils.getOutputStream(proxySock,\n          dnConf.socketWriteTimeout);\n      InputStream unbufProxyIn \u003d NetUtils.getInputStream(proxySock);\n      if (dnConf.encryptDataTransfer) {\n        IOStreamPair encryptedStreams \u003d\n            DataTransferEncryptor.getEncryptedStreams(\n                unbufProxyOut, unbufProxyIn,\n                datanode.blockPoolTokenSecretManager\n                    .generateDataEncryptionKey(block.getBlockPoolId()));\n        unbufProxyOut \u003d encryptedStreams.out;\n        unbufProxyIn \u003d encryptedStreams.in;\n      }\n      \n      proxyOut \u003d new DataOutputStream(new BufferedOutputStream(unbufProxyOut, \n          HdfsConstants.SMALL_BUFFER_SIZE));\n      proxyReply \u003d new DataInputStream(new BufferedInputStream(unbufProxyIn,\n          HdfsConstants.IO_FILE_BUFFER_SIZE));\n\n      /* send request to the proxy */\n      new Sender(proxyOut).copyBlock(block, blockToken);\n\n      // receive the response from the proxy\n      \n      BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n          HdfsProtoUtil.vintPrefixed(proxyReply));\n\n      if (copyResponse.getStatus() !\u003d SUCCESS) {\n        if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n          throw new IOException(\"Copy block \" + block + \" from \"\n              + proxySock.getRemoteSocketAddress()\n              + \" failed due to access token error\");\n        }\n        throw new IOException(\"Copy block \" + block + \" from \"\n            + proxySock.getRemoteSocketAddress() + \" failed\");\n      }\n      \n      // get checksum info about the block we\u0027re copying\n      ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n      DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n          checksumInfo.getChecksum());\n      // open a block receiver and check if the block does not exist\n      blockReceiver \u003d new BlockReceiver(\n          block, proxyReply, proxySock.getRemoteSocketAddress().toString(),\n          proxySock.getLocalSocketAddress().toString(),\n          null, 0, 0, 0, \"\", null, datanode, remoteChecksum);\n\n      // receive a block\n      blockReceiver.receiveBlock(null, null, null, null, \n          dataXceiverServer.balanceThrottler, null);\n                    \n      // notify name node\n      datanode.notifyNamenodeReceivedBlock(block, delHint);\n\n      LOG.info(\"Moved block \" + block + \n          \" from \" + s.getRemoteSocketAddress());\n      \n    } catch (IOException ioe) {\n      opStatus \u003d ERROR;\n      errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n      LOG.info(errMsg);\n      throw ioe;\n    } finally {\n      // receive the last byte that indicates the proxy released its thread resource\n      if (opStatus \u003d\u003d SUCCESS) {\n        try {\n          proxyReply.readChar();\n        } catch (IOException ignored) {\n        }\n      }\n      \n      // now release the thread resource\n      dataXceiverServer.balanceThrottler.release();\n      \n      // send response back\n      try {\n        sendResponse(opStatus, errMsg);\n      } catch (IOException ioe) {\n        LOG.warn(\"Error writing reply back to \" + s.getRemoteSocketAddress());\n      }\n      IOUtils.closeStream(proxyOut);\n      IOUtils.closeStream(blockReceiver);\n      IOUtils.closeStream(proxyReply);\n    }\n\n    //update metrics\n    datanode.metrics.addReplaceBlockOp(elapsed());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "be7dd8333a7e56e732171db0781786987de03195": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3144. Refactor DatanodeID#getName by use. Contributed by Eli Collins\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1308205 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "01/04/12 3:12 PM",
      "commitName": "be7dd8333a7e56e732171db0781786987de03195",
      "commitAuthor": "Eli Collins",
      "commitDateOld": "31/03/12 8:41 PM",
      "commitNameOld": "0663dbaac0a19719ddf9cd4290ba893bfca69da2",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 0.77,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,120 +1,120 @@\n   public void replaceBlock(final ExtendedBlock block,\n       final Token\u003cBlockTokenIdentifier\u003e blockToken,\n       final String delHint,\n       final DatanodeInfo proxySource) throws IOException {\n     updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n \n     /* read header */\n     block.setNumBytes(dataXceiverServer.estimateBlockSize);\n     if (datanode.isBlockTokenEnabled) {\n       try {\n         datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n             BlockTokenSecretManager.AccessMode.REPLACE);\n       } catch (InvalidToken e) {\n         LOG.warn(\"Invalid access token in request from \" + remoteAddress\n             + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n             + e.getLocalizedMessage());\n         sendResponse(s, ERROR_ACCESS_TOKEN, \"Invalid access token\",\n             dnConf.socketWriteTimeout);\n         return;\n       }\n     }\n \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n       String msg \u003d \"Not able to receive block \" + block.getBlockId() + \" from \" \n           + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\"; \n       LOG.warn(msg);\n       sendResponse(s, ERROR, msg, dnConf.socketWriteTimeout);\n       return;\n     }\n \n     Socket proxySock \u003d null;\n     DataOutputStream proxyOut \u003d null;\n     Status opStatus \u003d SUCCESS;\n     String errMsg \u003d null;\n     BlockReceiver blockReceiver \u003d null;\n     DataInputStream proxyReply \u003d null;\n     \n     try {\n       // get the output stream to the proxy\n-      InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(\n-          proxySource.getName());\n+      InetSocketAddress proxyAddr \u003d\n+        NetUtils.createSocketAddr(proxySource.getXferAddr());\n       proxySock \u003d datanode.newSocket();\n       NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n       proxySock.setSoTimeout(dnConf.socketTimeout);\n \n       OutputStream baseStream \u003d NetUtils.getOutputStream(proxySock, \n           dnConf.socketWriteTimeout);\n       proxyOut \u003d new DataOutputStream(new BufferedOutputStream(baseStream,\n           HdfsConstants.SMALL_BUFFER_SIZE));\n \n       /* send request to the proxy */\n       new Sender(proxyOut).copyBlock(block, blockToken);\n \n       // receive the response from the proxy\n       proxyReply \u003d new DataInputStream(new BufferedInputStream(\n           NetUtils.getInputStream(proxySock), HdfsConstants.IO_FILE_BUFFER_SIZE));\n       BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n           HdfsProtoUtil.vintPrefixed(proxyReply));\n \n       if (copyResponse.getStatus() !\u003d SUCCESS) {\n         if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n           throw new IOException(\"Copy block \" + block + \" from \"\n               + proxySock.getRemoteSocketAddress()\n               + \" failed due to access token error\");\n         }\n         throw new IOException(\"Copy block \" + block + \" from \"\n             + proxySock.getRemoteSocketAddress() + \" failed\");\n       }\n       \n       // get checksum info about the block we\u0027re copying\n       ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n       DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n           checksumInfo.getChecksum());\n       // open a block receiver and check if the block does not exist\n       blockReceiver \u003d new BlockReceiver(\n           block, proxyReply, proxySock.getRemoteSocketAddress().toString(),\n           proxySock.getLocalSocketAddress().toString(),\n           null, 0, 0, 0, \"\", null, datanode, remoteChecksum);\n \n       // receive a block\n       blockReceiver.receiveBlock(null, null, null, null, \n           dataXceiverServer.balanceThrottler, null);\n                     \n       // notify name node\n       datanode.notifyNamenodeReceivedBlock(block, delHint);\n \n       LOG.info(\"Moved block \" + block + \n           \" from \" + s.getRemoteSocketAddress());\n       \n     } catch (IOException ioe) {\n       opStatus \u003d ERROR;\n       errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n       LOG.info(errMsg);\n       throw ioe;\n     } finally {\n       // receive the last byte that indicates the proxy released its thread resource\n       if (opStatus \u003d\u003d SUCCESS) {\n         try {\n           proxyReply.readChar();\n         } catch (IOException ignored) {\n         }\n       }\n       \n       // now release the thread resource\n       dataXceiverServer.balanceThrottler.release();\n       \n       // send response back\n       try {\n         sendResponse(s, opStatus, errMsg, dnConf.socketWriteTimeout);\n       } catch (IOException ioe) {\n         LOG.warn(\"Error writing reply back to \" + s.getRemoteSocketAddress());\n       }\n       IOUtils.closeStream(proxyOut);\n       IOUtils.closeStream(blockReceiver);\n       IOUtils.closeStream(proxyReply);\n     }\n \n     //update metrics\n     datanode.metrics.addReplaceBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void replaceBlock(final ExtendedBlock block,\n      final Token\u003cBlockTokenIdentifier\u003e blockToken,\n      final String delHint,\n      final DatanodeInfo proxySource) throws IOException {\n    updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n\n    /* read header */\n    block.setNumBytes(dataXceiverServer.estimateBlockSize);\n    if (datanode.isBlockTokenEnabled) {\n      try {\n        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n            BlockTokenSecretManager.AccessMode.REPLACE);\n      } catch (InvalidToken e) {\n        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n            + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n            + e.getLocalizedMessage());\n        sendResponse(s, ERROR_ACCESS_TOKEN, \"Invalid access token\",\n            dnConf.socketWriteTimeout);\n        return;\n      }\n    }\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      String msg \u003d \"Not able to receive block \" + block.getBlockId() + \" from \" \n          + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\"; \n      LOG.warn(msg);\n      sendResponse(s, ERROR, msg, dnConf.socketWriteTimeout);\n      return;\n    }\n\n    Socket proxySock \u003d null;\n    DataOutputStream proxyOut \u003d null;\n    Status opStatus \u003d SUCCESS;\n    String errMsg \u003d null;\n    BlockReceiver blockReceiver \u003d null;\n    DataInputStream proxyReply \u003d null;\n    \n    try {\n      // get the output stream to the proxy\n      InetSocketAddress proxyAddr \u003d\n        NetUtils.createSocketAddr(proxySource.getXferAddr());\n      proxySock \u003d datanode.newSocket();\n      NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n      proxySock.setSoTimeout(dnConf.socketTimeout);\n\n      OutputStream baseStream \u003d NetUtils.getOutputStream(proxySock, \n          dnConf.socketWriteTimeout);\n      proxyOut \u003d new DataOutputStream(new BufferedOutputStream(baseStream,\n          HdfsConstants.SMALL_BUFFER_SIZE));\n\n      /* send request to the proxy */\n      new Sender(proxyOut).copyBlock(block, blockToken);\n\n      // receive the response from the proxy\n      proxyReply \u003d new DataInputStream(new BufferedInputStream(\n          NetUtils.getInputStream(proxySock), HdfsConstants.IO_FILE_BUFFER_SIZE));\n      BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n          HdfsProtoUtil.vintPrefixed(proxyReply));\n\n      if (copyResponse.getStatus() !\u003d SUCCESS) {\n        if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n          throw new IOException(\"Copy block \" + block + \" from \"\n              + proxySock.getRemoteSocketAddress()\n              + \" failed due to access token error\");\n        }\n        throw new IOException(\"Copy block \" + block + \" from \"\n            + proxySock.getRemoteSocketAddress() + \" failed\");\n      }\n      \n      // get checksum info about the block we\u0027re copying\n      ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n      DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n          checksumInfo.getChecksum());\n      // open a block receiver and check if the block does not exist\n      blockReceiver \u003d new BlockReceiver(\n          block, proxyReply, proxySock.getRemoteSocketAddress().toString(),\n          proxySock.getLocalSocketAddress().toString(),\n          null, 0, 0, 0, \"\", null, datanode, remoteChecksum);\n\n      // receive a block\n      blockReceiver.receiveBlock(null, null, null, null, \n          dataXceiverServer.balanceThrottler, null);\n                    \n      // notify name node\n      datanode.notifyNamenodeReceivedBlock(block, delHint);\n\n      LOG.info(\"Moved block \" + block + \n          \" from \" + s.getRemoteSocketAddress());\n      \n    } catch (IOException ioe) {\n      opStatus \u003d ERROR;\n      errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n      LOG.info(errMsg);\n      throw ioe;\n    } finally {\n      // receive the last byte that indicates the proxy released its thread resource\n      if (opStatus \u003d\u003d SUCCESS) {\n        try {\n          proxyReply.readChar();\n        } catch (IOException ignored) {\n        }\n      }\n      \n      // now release the thread resource\n      dataXceiverServer.balanceThrottler.release();\n      \n      // send response back\n      try {\n        sendResponse(s, opStatus, errMsg, dnConf.socketWriteTimeout);\n      } catch (IOException ioe) {\n        LOG.warn(\"Error writing reply back to \" + s.getRemoteSocketAddress());\n      }\n      IOUtils.closeStream(proxyOut);\n      IOUtils.closeStream(blockReceiver);\n      IOUtils.closeStream(proxyReply);\n    }\n\n    //update metrics\n    datanode.metrics.addReplaceBlockOp(elapsed());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "905a127850d5e0cba85c2e075f989fa0f5cf129a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2562. Refactor DN configuration variables out of DataNode class. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1203543 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/11/11 1:04 AM",
      "commitName": "905a127850d5e0cba85c2e075f989fa0f5cf129a",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "31/10/11 10:17 PM",
      "commitNameOld": "1c940637b14eee777a65d153d0d712a1aea3866c",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 17.16,
      "commitsBetweenForRepo": 77,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,120 +1,120 @@\n   public void replaceBlock(final ExtendedBlock block,\n       final Token\u003cBlockTokenIdentifier\u003e blockToken,\n       final String delHint,\n       final DatanodeInfo proxySource) throws IOException {\n     updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n \n     /* read header */\n     block.setNumBytes(dataXceiverServer.estimateBlockSize);\n     if (datanode.isBlockTokenEnabled) {\n       try {\n         datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n             BlockTokenSecretManager.AccessMode.REPLACE);\n       } catch (InvalidToken e) {\n         LOG.warn(\"Invalid access token in request from \" + remoteAddress\n             + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n             + e.getLocalizedMessage());\n         sendResponse(s, ERROR_ACCESS_TOKEN, \"Invalid access token\",\n-            datanode.socketWriteTimeout);\n+            dnConf.socketWriteTimeout);\n         return;\n       }\n     }\n \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n       String msg \u003d \"Not able to receive block \" + block.getBlockId() + \" from \" \n           + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\"; \n       LOG.warn(msg);\n-      sendResponse(s, ERROR, msg, datanode.socketWriteTimeout);\n+      sendResponse(s, ERROR, msg, dnConf.socketWriteTimeout);\n       return;\n     }\n \n     Socket proxySock \u003d null;\n     DataOutputStream proxyOut \u003d null;\n     Status opStatus \u003d SUCCESS;\n     String errMsg \u003d null;\n     BlockReceiver blockReceiver \u003d null;\n     DataInputStream proxyReply \u003d null;\n     \n     try {\n       // get the output stream to the proxy\n       InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(\n           proxySource.getName());\n       proxySock \u003d datanode.newSocket();\n-      NetUtils.connect(proxySock, proxyAddr, datanode.socketTimeout);\n-      proxySock.setSoTimeout(datanode.socketTimeout);\n+      NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n+      proxySock.setSoTimeout(dnConf.socketTimeout);\n \n       OutputStream baseStream \u003d NetUtils.getOutputStream(proxySock, \n-          datanode.socketWriteTimeout);\n+          dnConf.socketWriteTimeout);\n       proxyOut \u003d new DataOutputStream(new BufferedOutputStream(baseStream,\n           HdfsConstants.SMALL_BUFFER_SIZE));\n \n       /* send request to the proxy */\n       new Sender(proxyOut).copyBlock(block, blockToken);\n \n       // receive the response from the proxy\n       proxyReply \u003d new DataInputStream(new BufferedInputStream(\n           NetUtils.getInputStream(proxySock), HdfsConstants.IO_FILE_BUFFER_SIZE));\n       BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n           HdfsProtoUtil.vintPrefixed(proxyReply));\n \n       if (copyResponse.getStatus() !\u003d SUCCESS) {\n         if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n           throw new IOException(\"Copy block \" + block + \" from \"\n               + proxySock.getRemoteSocketAddress()\n               + \" failed due to access token error\");\n         }\n         throw new IOException(\"Copy block \" + block + \" from \"\n             + proxySock.getRemoteSocketAddress() + \" failed\");\n       }\n       \n       // get checksum info about the block we\u0027re copying\n       ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n       DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n           checksumInfo.getChecksum());\n       // open a block receiver and check if the block does not exist\n       blockReceiver \u003d new BlockReceiver(\n           block, proxyReply, proxySock.getRemoteSocketAddress().toString(),\n           proxySock.getLocalSocketAddress().toString(),\n           null, 0, 0, 0, \"\", null, datanode, remoteChecksum);\n \n       // receive a block\n       blockReceiver.receiveBlock(null, null, null, null, \n           dataXceiverServer.balanceThrottler, null);\n                     \n       // notify name node\n       datanode.notifyNamenodeReceivedBlock(block, delHint);\n \n       LOG.info(\"Moved block \" + block + \n           \" from \" + s.getRemoteSocketAddress());\n       \n     } catch (IOException ioe) {\n       opStatus \u003d ERROR;\n       errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n       LOG.info(errMsg);\n       throw ioe;\n     } finally {\n       // receive the last byte that indicates the proxy released its thread resource\n       if (opStatus \u003d\u003d SUCCESS) {\n         try {\n           proxyReply.readChar();\n         } catch (IOException ignored) {\n         }\n       }\n       \n       // now release the thread resource\n       dataXceiverServer.balanceThrottler.release();\n       \n       // send response back\n       try {\n-        sendResponse(s, opStatus, errMsg, datanode.socketWriteTimeout);\n+        sendResponse(s, opStatus, errMsg, dnConf.socketWriteTimeout);\n       } catch (IOException ioe) {\n         LOG.warn(\"Error writing reply back to \" + s.getRemoteSocketAddress());\n       }\n       IOUtils.closeStream(proxyOut);\n       IOUtils.closeStream(blockReceiver);\n       IOUtils.closeStream(proxyReply);\n     }\n \n     //update metrics\n     datanode.metrics.addReplaceBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void replaceBlock(final ExtendedBlock block,\n      final Token\u003cBlockTokenIdentifier\u003e blockToken,\n      final String delHint,\n      final DatanodeInfo proxySource) throws IOException {\n    updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n\n    /* read header */\n    block.setNumBytes(dataXceiverServer.estimateBlockSize);\n    if (datanode.isBlockTokenEnabled) {\n      try {\n        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n            BlockTokenSecretManager.AccessMode.REPLACE);\n      } catch (InvalidToken e) {\n        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n            + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n            + e.getLocalizedMessage());\n        sendResponse(s, ERROR_ACCESS_TOKEN, \"Invalid access token\",\n            dnConf.socketWriteTimeout);\n        return;\n      }\n    }\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      String msg \u003d \"Not able to receive block \" + block.getBlockId() + \" from \" \n          + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\"; \n      LOG.warn(msg);\n      sendResponse(s, ERROR, msg, dnConf.socketWriteTimeout);\n      return;\n    }\n\n    Socket proxySock \u003d null;\n    DataOutputStream proxyOut \u003d null;\n    Status opStatus \u003d SUCCESS;\n    String errMsg \u003d null;\n    BlockReceiver blockReceiver \u003d null;\n    DataInputStream proxyReply \u003d null;\n    \n    try {\n      // get the output stream to the proxy\n      InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(\n          proxySource.getName());\n      proxySock \u003d datanode.newSocket();\n      NetUtils.connect(proxySock, proxyAddr, dnConf.socketTimeout);\n      proxySock.setSoTimeout(dnConf.socketTimeout);\n\n      OutputStream baseStream \u003d NetUtils.getOutputStream(proxySock, \n          dnConf.socketWriteTimeout);\n      proxyOut \u003d new DataOutputStream(new BufferedOutputStream(baseStream,\n          HdfsConstants.SMALL_BUFFER_SIZE));\n\n      /* send request to the proxy */\n      new Sender(proxyOut).copyBlock(block, blockToken);\n\n      // receive the response from the proxy\n      proxyReply \u003d new DataInputStream(new BufferedInputStream(\n          NetUtils.getInputStream(proxySock), HdfsConstants.IO_FILE_BUFFER_SIZE));\n      BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n          HdfsProtoUtil.vintPrefixed(proxyReply));\n\n      if (copyResponse.getStatus() !\u003d SUCCESS) {\n        if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n          throw new IOException(\"Copy block \" + block + \" from \"\n              + proxySock.getRemoteSocketAddress()\n              + \" failed due to access token error\");\n        }\n        throw new IOException(\"Copy block \" + block + \" from \"\n            + proxySock.getRemoteSocketAddress() + \" failed\");\n      }\n      \n      // get checksum info about the block we\u0027re copying\n      ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n      DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n          checksumInfo.getChecksum());\n      // open a block receiver and check if the block does not exist\n      blockReceiver \u003d new BlockReceiver(\n          block, proxyReply, proxySock.getRemoteSocketAddress().toString(),\n          proxySock.getLocalSocketAddress().toString(),\n          null, 0, 0, 0, \"\", null, datanode, remoteChecksum);\n\n      // receive a block\n      blockReceiver.receiveBlock(null, null, null, null, \n          dataXceiverServer.balanceThrottler, null);\n                    \n      // notify name node\n      datanode.notifyNamenodeReceivedBlock(block, delHint);\n\n      LOG.info(\"Moved block \" + block + \n          \" from \" + s.getRemoteSocketAddress());\n      \n    } catch (IOException ioe) {\n      opStatus \u003d ERROR;\n      errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n      LOG.info(errMsg);\n      throw ioe;\n    } finally {\n      // receive the last byte that indicates the proxy released its thread resource\n      if (opStatus \u003d\u003d SUCCESS) {\n        try {\n          proxyReply.readChar();\n        } catch (IOException ignored) {\n        }\n      }\n      \n      // now release the thread resource\n      dataXceiverServer.balanceThrottler.release();\n      \n      // send response back\n      try {\n        sendResponse(s, opStatus, errMsg, dnConf.socketWriteTimeout);\n      } catch (IOException ioe) {\n        LOG.warn(\"Error writing reply back to \" + s.getRemoteSocketAddress());\n      }\n      IOUtils.closeStream(proxyOut);\n      IOUtils.closeStream(blockReceiver);\n      IOUtils.closeStream(proxyReply);\n    }\n\n    //update metrics\n    datanode.metrics.addReplaceBlockOp(elapsed());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "1c940637b14eee777a65d153d0d712a1aea3866c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2521. Remove custom checksum headers from data transfer protocol. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1195829 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "31/10/11 10:17 PM",
      "commitName": "1c940637b14eee777a65d153d0d712a1aea3866c",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "31/10/11 2:53 PM",
      "commitNameOld": "c46876982ed90d0819a94b518f6135b82334d10d",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 0.31,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,115 +1,120 @@\n   public void replaceBlock(final ExtendedBlock block,\n       final Token\u003cBlockTokenIdentifier\u003e blockToken,\n       final String delHint,\n       final DatanodeInfo proxySource) throws IOException {\n     updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n \n     /* read header */\n     block.setNumBytes(dataXceiverServer.estimateBlockSize);\n     if (datanode.isBlockTokenEnabled) {\n       try {\n         datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n             BlockTokenSecretManager.AccessMode.REPLACE);\n       } catch (InvalidToken e) {\n         LOG.warn(\"Invalid access token in request from \" + remoteAddress\n             + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n             + e.getLocalizedMessage());\n         sendResponse(s, ERROR_ACCESS_TOKEN, \"Invalid access token\",\n             datanode.socketWriteTimeout);\n         return;\n       }\n     }\n \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n       String msg \u003d \"Not able to receive block \" + block.getBlockId() + \" from \" \n           + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\"; \n       LOG.warn(msg);\n       sendResponse(s, ERROR, msg, datanode.socketWriteTimeout);\n       return;\n     }\n \n     Socket proxySock \u003d null;\n     DataOutputStream proxyOut \u003d null;\n     Status opStatus \u003d SUCCESS;\n     String errMsg \u003d null;\n     BlockReceiver blockReceiver \u003d null;\n     DataInputStream proxyReply \u003d null;\n     \n     try {\n       // get the output stream to the proxy\n       InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(\n           proxySource.getName());\n       proxySock \u003d datanode.newSocket();\n       NetUtils.connect(proxySock, proxyAddr, datanode.socketTimeout);\n       proxySock.setSoTimeout(datanode.socketTimeout);\n \n       OutputStream baseStream \u003d NetUtils.getOutputStream(proxySock, \n           datanode.socketWriteTimeout);\n       proxyOut \u003d new DataOutputStream(new BufferedOutputStream(baseStream,\n           HdfsConstants.SMALL_BUFFER_SIZE));\n \n       /* send request to the proxy */\n       new Sender(proxyOut).copyBlock(block, blockToken);\n \n       // receive the response from the proxy\n       proxyReply \u003d new DataInputStream(new BufferedInputStream(\n           NetUtils.getInputStream(proxySock), HdfsConstants.IO_FILE_BUFFER_SIZE));\n       BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n           HdfsProtoUtil.vintPrefixed(proxyReply));\n \n       if (copyResponse.getStatus() !\u003d SUCCESS) {\n         if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n           throw new IOException(\"Copy block \" + block + \" from \"\n               + proxySock.getRemoteSocketAddress()\n               + \" failed due to access token error\");\n         }\n         throw new IOException(\"Copy block \" + block + \" from \"\n             + proxySock.getRemoteSocketAddress() + \" failed\");\n       }\n+      \n+      // get checksum info about the block we\u0027re copying\n+      ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n+      DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n+          checksumInfo.getChecksum());\n       // open a block receiver and check if the block does not exist\n       blockReceiver \u003d new BlockReceiver(\n           block, proxyReply, proxySock.getRemoteSocketAddress().toString(),\n           proxySock.getLocalSocketAddress().toString(),\n-          null, 0, 0, 0, \"\", null, datanode);\n+          null, 0, 0, 0, \"\", null, datanode, remoteChecksum);\n \n       // receive a block\n       blockReceiver.receiveBlock(null, null, null, null, \n           dataXceiverServer.balanceThrottler, null);\n                     \n       // notify name node\n       datanode.notifyNamenodeReceivedBlock(block, delHint);\n \n       LOG.info(\"Moved block \" + block + \n           \" from \" + s.getRemoteSocketAddress());\n       \n     } catch (IOException ioe) {\n       opStatus \u003d ERROR;\n       errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n       LOG.info(errMsg);\n       throw ioe;\n     } finally {\n       // receive the last byte that indicates the proxy released its thread resource\n       if (opStatus \u003d\u003d SUCCESS) {\n         try {\n           proxyReply.readChar();\n         } catch (IOException ignored) {\n         }\n       }\n       \n       // now release the thread resource\n       dataXceiverServer.balanceThrottler.release();\n       \n       // send response back\n       try {\n         sendResponse(s, opStatus, errMsg, datanode.socketWriteTimeout);\n       } catch (IOException ioe) {\n         LOG.warn(\"Error writing reply back to \" + s.getRemoteSocketAddress());\n       }\n       IOUtils.closeStream(proxyOut);\n       IOUtils.closeStream(blockReceiver);\n       IOUtils.closeStream(proxyReply);\n     }\n \n     //update metrics\n     datanode.metrics.addReplaceBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void replaceBlock(final ExtendedBlock block,\n      final Token\u003cBlockTokenIdentifier\u003e blockToken,\n      final String delHint,\n      final DatanodeInfo proxySource) throws IOException {\n    updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n\n    /* read header */\n    block.setNumBytes(dataXceiverServer.estimateBlockSize);\n    if (datanode.isBlockTokenEnabled) {\n      try {\n        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n            BlockTokenSecretManager.AccessMode.REPLACE);\n      } catch (InvalidToken e) {\n        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n            + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n            + e.getLocalizedMessage());\n        sendResponse(s, ERROR_ACCESS_TOKEN, \"Invalid access token\",\n            datanode.socketWriteTimeout);\n        return;\n      }\n    }\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      String msg \u003d \"Not able to receive block \" + block.getBlockId() + \" from \" \n          + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\"; \n      LOG.warn(msg);\n      sendResponse(s, ERROR, msg, datanode.socketWriteTimeout);\n      return;\n    }\n\n    Socket proxySock \u003d null;\n    DataOutputStream proxyOut \u003d null;\n    Status opStatus \u003d SUCCESS;\n    String errMsg \u003d null;\n    BlockReceiver blockReceiver \u003d null;\n    DataInputStream proxyReply \u003d null;\n    \n    try {\n      // get the output stream to the proxy\n      InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(\n          proxySource.getName());\n      proxySock \u003d datanode.newSocket();\n      NetUtils.connect(proxySock, proxyAddr, datanode.socketTimeout);\n      proxySock.setSoTimeout(datanode.socketTimeout);\n\n      OutputStream baseStream \u003d NetUtils.getOutputStream(proxySock, \n          datanode.socketWriteTimeout);\n      proxyOut \u003d new DataOutputStream(new BufferedOutputStream(baseStream,\n          HdfsConstants.SMALL_BUFFER_SIZE));\n\n      /* send request to the proxy */\n      new Sender(proxyOut).copyBlock(block, blockToken);\n\n      // receive the response from the proxy\n      proxyReply \u003d new DataInputStream(new BufferedInputStream(\n          NetUtils.getInputStream(proxySock), HdfsConstants.IO_FILE_BUFFER_SIZE));\n      BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n          HdfsProtoUtil.vintPrefixed(proxyReply));\n\n      if (copyResponse.getStatus() !\u003d SUCCESS) {\n        if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n          throw new IOException(\"Copy block \" + block + \" from \"\n              + proxySock.getRemoteSocketAddress()\n              + \" failed due to access token error\");\n        }\n        throw new IOException(\"Copy block \" + block + \" from \"\n            + proxySock.getRemoteSocketAddress() + \" failed\");\n      }\n      \n      // get checksum info about the block we\u0027re copying\n      ReadOpChecksumInfoProto checksumInfo \u003d copyResponse.getReadOpChecksumInfo();\n      DataChecksum remoteChecksum \u003d DataTransferProtoUtil.fromProto(\n          checksumInfo.getChecksum());\n      // open a block receiver and check if the block does not exist\n      blockReceiver \u003d new BlockReceiver(\n          block, proxyReply, proxySock.getRemoteSocketAddress().toString(),\n          proxySock.getLocalSocketAddress().toString(),\n          null, 0, 0, 0, \"\", null, datanode, remoteChecksum);\n\n      // receive a block\n      blockReceiver.receiveBlock(null, null, null, null, \n          dataXceiverServer.balanceThrottler, null);\n                    \n      // notify name node\n      datanode.notifyNamenodeReceivedBlock(block, delHint);\n\n      LOG.info(\"Moved block \" + block + \n          \" from \" + s.getRemoteSocketAddress());\n      \n    } catch (IOException ioe) {\n      opStatus \u003d ERROR;\n      errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n      LOG.info(errMsg);\n      throw ioe;\n    } finally {\n      // receive the last byte that indicates the proxy released its thread resource\n      if (opStatus \u003d\u003d SUCCESS) {\n        try {\n          proxyReply.readChar();\n        } catch (IOException ignored) {\n        }\n      }\n      \n      // now release the thread resource\n      dataXceiverServer.balanceThrottler.release();\n      \n      // send response back\n      try {\n        sendResponse(s, opStatus, errMsg, datanode.socketWriteTimeout);\n      } catch (IOException ioe) {\n        LOG.warn(\"Error writing reply back to \" + s.getRemoteSocketAddress());\n      }\n      IOUtils.closeStream(proxyOut);\n      IOUtils.closeStream(blockReceiver);\n      IOUtils.closeStream(proxyReply);\n    }\n\n    //update metrics\n    datanode.metrics.addReplaceBlockOp(elapsed());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "c46876982ed90d0819a94b518f6135b82334d10d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2512. Add textual error message to data transfer protocol responses. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1195693 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "31/10/11 2:53 PM",
      "commitName": "c46876982ed90d0819a94b518f6135b82334d10d",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "23/10/11 1:17 PM",
      "commitNameOld": "6e0991704ffda5cf4cff758f0e7086523fa7bcb4",
      "commitAuthorOld": "Konstantin Shvachko",
      "daysBetweenCommits": 8.07,
      "commitsBetweenForRepo": 100,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,111 +1,115 @@\n   public void replaceBlock(final ExtendedBlock block,\n       final Token\u003cBlockTokenIdentifier\u003e blockToken,\n       final String delHint,\n       final DatanodeInfo proxySource) throws IOException {\n     updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n \n     /* read header */\n     block.setNumBytes(dataXceiverServer.estimateBlockSize);\n     if (datanode.isBlockTokenEnabled) {\n       try {\n         datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n             BlockTokenSecretManager.AccessMode.REPLACE);\n       } catch (InvalidToken e) {\n         LOG.warn(\"Invalid access token in request from \" + remoteAddress\n             + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n             + e.getLocalizedMessage());\n-        sendResponse(s, ERROR_ACCESS_TOKEN, datanode.socketWriteTimeout);\n+        sendResponse(s, ERROR_ACCESS_TOKEN, \"Invalid access token\",\n+            datanode.socketWriteTimeout);\n         return;\n       }\n     }\n \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n-      LOG.warn(\"Not able to receive block \" + block.getBlockId() + \" from \" \n-          + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\");\n-      sendResponse(s, ERROR, datanode.socketWriteTimeout);\n+      String msg \u003d \"Not able to receive block \" + block.getBlockId() + \" from \" \n+          + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\"; \n+      LOG.warn(msg);\n+      sendResponse(s, ERROR, msg, datanode.socketWriteTimeout);\n       return;\n     }\n \n     Socket proxySock \u003d null;\n     DataOutputStream proxyOut \u003d null;\n     Status opStatus \u003d SUCCESS;\n+    String errMsg \u003d null;\n     BlockReceiver blockReceiver \u003d null;\n     DataInputStream proxyReply \u003d null;\n     \n     try {\n       // get the output stream to the proxy\n       InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(\n           proxySource.getName());\n       proxySock \u003d datanode.newSocket();\n       NetUtils.connect(proxySock, proxyAddr, datanode.socketTimeout);\n       proxySock.setSoTimeout(datanode.socketTimeout);\n \n       OutputStream baseStream \u003d NetUtils.getOutputStream(proxySock, \n           datanode.socketWriteTimeout);\n       proxyOut \u003d new DataOutputStream(new BufferedOutputStream(baseStream,\n           HdfsConstants.SMALL_BUFFER_SIZE));\n \n       /* send request to the proxy */\n       new Sender(proxyOut).copyBlock(block, blockToken);\n \n       // receive the response from the proxy\n       proxyReply \u003d new DataInputStream(new BufferedInputStream(\n           NetUtils.getInputStream(proxySock), HdfsConstants.IO_FILE_BUFFER_SIZE));\n       BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n           HdfsProtoUtil.vintPrefixed(proxyReply));\n \n       if (copyResponse.getStatus() !\u003d SUCCESS) {\n         if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n           throw new IOException(\"Copy block \" + block + \" from \"\n               + proxySock.getRemoteSocketAddress()\n               + \" failed due to access token error\");\n         }\n         throw new IOException(\"Copy block \" + block + \" from \"\n             + proxySock.getRemoteSocketAddress() + \" failed\");\n       }\n       // open a block receiver and check if the block does not exist\n       blockReceiver \u003d new BlockReceiver(\n           block, proxyReply, proxySock.getRemoteSocketAddress().toString(),\n           proxySock.getLocalSocketAddress().toString(),\n           null, 0, 0, 0, \"\", null, datanode);\n \n       // receive a block\n       blockReceiver.receiveBlock(null, null, null, null, \n           dataXceiverServer.balanceThrottler, null);\n                     \n       // notify name node\n       datanode.notifyNamenodeReceivedBlock(block, delHint);\n \n       LOG.info(\"Moved block \" + block + \n           \" from \" + s.getRemoteSocketAddress());\n       \n     } catch (IOException ioe) {\n       opStatus \u003d ERROR;\n-      LOG.info(\"opReplaceBlock \" + block + \" received exception \" + ioe);\n+      errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n+      LOG.info(errMsg);\n       throw ioe;\n     } finally {\n       // receive the last byte that indicates the proxy released its thread resource\n       if (opStatus \u003d\u003d SUCCESS) {\n         try {\n           proxyReply.readChar();\n         } catch (IOException ignored) {\n         }\n       }\n       \n       // now release the thread resource\n       dataXceiverServer.balanceThrottler.release();\n       \n       // send response back\n       try {\n-        sendResponse(s, opStatus, datanode.socketWriteTimeout);\n+        sendResponse(s, opStatus, errMsg, datanode.socketWriteTimeout);\n       } catch (IOException ioe) {\n         LOG.warn(\"Error writing reply back to \" + s.getRemoteSocketAddress());\n       }\n       IOUtils.closeStream(proxyOut);\n       IOUtils.closeStream(blockReceiver);\n       IOUtils.closeStream(proxyReply);\n     }\n \n     //update metrics\n     datanode.metrics.addReplaceBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void replaceBlock(final ExtendedBlock block,\n      final Token\u003cBlockTokenIdentifier\u003e blockToken,\n      final String delHint,\n      final DatanodeInfo proxySource) throws IOException {\n    updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n\n    /* read header */\n    block.setNumBytes(dataXceiverServer.estimateBlockSize);\n    if (datanode.isBlockTokenEnabled) {\n      try {\n        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n            BlockTokenSecretManager.AccessMode.REPLACE);\n      } catch (InvalidToken e) {\n        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n            + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n            + e.getLocalizedMessage());\n        sendResponse(s, ERROR_ACCESS_TOKEN, \"Invalid access token\",\n            datanode.socketWriteTimeout);\n        return;\n      }\n    }\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      String msg \u003d \"Not able to receive block \" + block.getBlockId() + \" from \" \n          + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\"; \n      LOG.warn(msg);\n      sendResponse(s, ERROR, msg, datanode.socketWriteTimeout);\n      return;\n    }\n\n    Socket proxySock \u003d null;\n    DataOutputStream proxyOut \u003d null;\n    Status opStatus \u003d SUCCESS;\n    String errMsg \u003d null;\n    BlockReceiver blockReceiver \u003d null;\n    DataInputStream proxyReply \u003d null;\n    \n    try {\n      // get the output stream to the proxy\n      InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(\n          proxySource.getName());\n      proxySock \u003d datanode.newSocket();\n      NetUtils.connect(proxySock, proxyAddr, datanode.socketTimeout);\n      proxySock.setSoTimeout(datanode.socketTimeout);\n\n      OutputStream baseStream \u003d NetUtils.getOutputStream(proxySock, \n          datanode.socketWriteTimeout);\n      proxyOut \u003d new DataOutputStream(new BufferedOutputStream(baseStream,\n          HdfsConstants.SMALL_BUFFER_SIZE));\n\n      /* send request to the proxy */\n      new Sender(proxyOut).copyBlock(block, blockToken);\n\n      // receive the response from the proxy\n      proxyReply \u003d new DataInputStream(new BufferedInputStream(\n          NetUtils.getInputStream(proxySock), HdfsConstants.IO_FILE_BUFFER_SIZE));\n      BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n          HdfsProtoUtil.vintPrefixed(proxyReply));\n\n      if (copyResponse.getStatus() !\u003d SUCCESS) {\n        if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n          throw new IOException(\"Copy block \" + block + \" from \"\n              + proxySock.getRemoteSocketAddress()\n              + \" failed due to access token error\");\n        }\n        throw new IOException(\"Copy block \" + block + \" from \"\n            + proxySock.getRemoteSocketAddress() + \" failed\");\n      }\n      // open a block receiver and check if the block does not exist\n      blockReceiver \u003d new BlockReceiver(\n          block, proxyReply, proxySock.getRemoteSocketAddress().toString(),\n          proxySock.getLocalSocketAddress().toString(),\n          null, 0, 0, 0, \"\", null, datanode);\n\n      // receive a block\n      blockReceiver.receiveBlock(null, null, null, null, \n          dataXceiverServer.balanceThrottler, null);\n                    \n      // notify name node\n      datanode.notifyNamenodeReceivedBlock(block, delHint);\n\n      LOG.info(\"Moved block \" + block + \n          \" from \" + s.getRemoteSocketAddress());\n      \n    } catch (IOException ioe) {\n      opStatus \u003d ERROR;\n      errMsg \u003d \"opReplaceBlock \" + block + \" received exception \" + ioe; \n      LOG.info(errMsg);\n      throw ioe;\n    } finally {\n      // receive the last byte that indicates the proxy released its thread resource\n      if (opStatus \u003d\u003d SUCCESS) {\n        try {\n          proxyReply.readChar();\n        } catch (IOException ignored) {\n        }\n      }\n      \n      // now release the thread resource\n      dataXceiverServer.balanceThrottler.release();\n      \n      // send response back\n      try {\n        sendResponse(s, opStatus, errMsg, datanode.socketWriteTimeout);\n      } catch (IOException ioe) {\n        LOG.warn(\"Error writing reply back to \" + s.getRemoteSocketAddress());\n      }\n      IOUtils.closeStream(proxyOut);\n      IOUtils.closeStream(blockReceiver);\n      IOUtils.closeStream(proxyReply);\n    }\n\n    //update metrics\n    datanode.metrics.addReplaceBlockOp(elapsed());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "8ae98a9d1ca4725e28783370517cb3a3ecda7324": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-1620. Rename HdfsConstants -\u003e HdfsServerConstants, FSConstants -\u003e HdfsConstants. (Harsh J Chouraria via atm)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1165096 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/09/11 12:30 PM",
      "commitName": "8ae98a9d1ca4725e28783370517cb3a3ecda7324",
      "commitAuthor": "Aaron Myers",
      "commitDateOld": "24/08/11 5:14 PM",
      "commitNameOld": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 10.8,
      "commitsBetweenForRepo": 53,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,111 +1,111 @@\n   public void replaceBlock(final ExtendedBlock block,\n       final Token\u003cBlockTokenIdentifier\u003e blockToken,\n       final String delHint,\n       final DatanodeInfo proxySource) throws IOException {\n     updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n \n     /* read header */\n     block.setNumBytes(dataXceiverServer.estimateBlockSize);\n     if (datanode.isBlockTokenEnabled) {\n       try {\n         datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n             BlockTokenSecretManager.AccessMode.REPLACE);\n       } catch (InvalidToken e) {\n         LOG.warn(\"Invalid access token in request from \" + remoteAddress\n             + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n             + e.getLocalizedMessage());\n         sendResponse(s, ERROR_ACCESS_TOKEN, datanode.socketWriteTimeout);\n         return;\n       }\n     }\n \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n       LOG.warn(\"Not able to receive block \" + block.getBlockId() + \" from \" \n           + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\");\n       sendResponse(s, ERROR, datanode.socketWriteTimeout);\n       return;\n     }\n \n     Socket proxySock \u003d null;\n     DataOutputStream proxyOut \u003d null;\n     Status opStatus \u003d SUCCESS;\n     BlockReceiver blockReceiver \u003d null;\n     DataInputStream proxyReply \u003d null;\n     \n     try {\n       // get the output stream to the proxy\n       InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(\n           proxySource.getName());\n       proxySock \u003d datanode.newSocket();\n       NetUtils.connect(proxySock, proxyAddr, datanode.socketTimeout);\n       proxySock.setSoTimeout(datanode.socketTimeout);\n \n       OutputStream baseStream \u003d NetUtils.getOutputStream(proxySock, \n           datanode.socketWriteTimeout);\n       proxyOut \u003d new DataOutputStream(new BufferedOutputStream(baseStream,\n-          FSConstants.SMALL_BUFFER_SIZE));\n+          HdfsConstants.SMALL_BUFFER_SIZE));\n \n       /* send request to the proxy */\n       new Sender(proxyOut).copyBlock(block, blockToken);\n \n       // receive the response from the proxy\n       proxyReply \u003d new DataInputStream(new BufferedInputStream(\n-          NetUtils.getInputStream(proxySock), FSConstants.IO_FILE_BUFFER_SIZE));\n+          NetUtils.getInputStream(proxySock), HdfsConstants.IO_FILE_BUFFER_SIZE));\n       BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n           HdfsProtoUtil.vintPrefixed(proxyReply));\n \n       if (copyResponse.getStatus() !\u003d SUCCESS) {\n         if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n           throw new IOException(\"Copy block \" + block + \" from \"\n               + proxySock.getRemoteSocketAddress()\n               + \" failed due to access token error\");\n         }\n         throw new IOException(\"Copy block \" + block + \" from \"\n             + proxySock.getRemoteSocketAddress() + \" failed\");\n       }\n       // open a block receiver and check if the block does not exist\n       blockReceiver \u003d new BlockReceiver(\n           block, proxyReply, proxySock.getRemoteSocketAddress().toString(),\n           proxySock.getLocalSocketAddress().toString(),\n           null, 0, 0, 0, \"\", null, datanode);\n \n       // receive a block\n       blockReceiver.receiveBlock(null, null, null, null, \n           dataXceiverServer.balanceThrottler, null);\n                     \n       // notify name node\n       datanode.notifyNamenodeReceivedBlock(block, delHint);\n \n       LOG.info(\"Moved block \" + block + \n           \" from \" + s.getRemoteSocketAddress());\n       \n     } catch (IOException ioe) {\n       opStatus \u003d ERROR;\n       LOG.info(\"opReplaceBlock \" + block + \" received exception \" + ioe);\n       throw ioe;\n     } finally {\n       // receive the last byte that indicates the proxy released its thread resource\n       if (opStatus \u003d\u003d SUCCESS) {\n         try {\n           proxyReply.readChar();\n         } catch (IOException ignored) {\n         }\n       }\n       \n       // now release the thread resource\n       dataXceiverServer.balanceThrottler.release();\n       \n       // send response back\n       try {\n         sendResponse(s, opStatus, datanode.socketWriteTimeout);\n       } catch (IOException ioe) {\n         LOG.warn(\"Error writing reply back to \" + s.getRemoteSocketAddress());\n       }\n       IOUtils.closeStream(proxyOut);\n       IOUtils.closeStream(blockReceiver);\n       IOUtils.closeStream(proxyReply);\n     }\n \n     //update metrics\n     datanode.metrics.addReplaceBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void replaceBlock(final ExtendedBlock block,\n      final Token\u003cBlockTokenIdentifier\u003e blockToken,\n      final String delHint,\n      final DatanodeInfo proxySource) throws IOException {\n    updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n\n    /* read header */\n    block.setNumBytes(dataXceiverServer.estimateBlockSize);\n    if (datanode.isBlockTokenEnabled) {\n      try {\n        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n            BlockTokenSecretManager.AccessMode.REPLACE);\n      } catch (InvalidToken e) {\n        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n            + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n            + e.getLocalizedMessage());\n        sendResponse(s, ERROR_ACCESS_TOKEN, datanode.socketWriteTimeout);\n        return;\n      }\n    }\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      LOG.warn(\"Not able to receive block \" + block.getBlockId() + \" from \" \n          + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\");\n      sendResponse(s, ERROR, datanode.socketWriteTimeout);\n      return;\n    }\n\n    Socket proxySock \u003d null;\n    DataOutputStream proxyOut \u003d null;\n    Status opStatus \u003d SUCCESS;\n    BlockReceiver blockReceiver \u003d null;\n    DataInputStream proxyReply \u003d null;\n    \n    try {\n      // get the output stream to the proxy\n      InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(\n          proxySource.getName());\n      proxySock \u003d datanode.newSocket();\n      NetUtils.connect(proxySock, proxyAddr, datanode.socketTimeout);\n      proxySock.setSoTimeout(datanode.socketTimeout);\n\n      OutputStream baseStream \u003d NetUtils.getOutputStream(proxySock, \n          datanode.socketWriteTimeout);\n      proxyOut \u003d new DataOutputStream(new BufferedOutputStream(baseStream,\n          HdfsConstants.SMALL_BUFFER_SIZE));\n\n      /* send request to the proxy */\n      new Sender(proxyOut).copyBlock(block, blockToken);\n\n      // receive the response from the proxy\n      proxyReply \u003d new DataInputStream(new BufferedInputStream(\n          NetUtils.getInputStream(proxySock), HdfsConstants.IO_FILE_BUFFER_SIZE));\n      BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n          HdfsProtoUtil.vintPrefixed(proxyReply));\n\n      if (copyResponse.getStatus() !\u003d SUCCESS) {\n        if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n          throw new IOException(\"Copy block \" + block + \" from \"\n              + proxySock.getRemoteSocketAddress()\n              + \" failed due to access token error\");\n        }\n        throw new IOException(\"Copy block \" + block + \" from \"\n            + proxySock.getRemoteSocketAddress() + \" failed\");\n      }\n      // open a block receiver and check if the block does not exist\n      blockReceiver \u003d new BlockReceiver(\n          block, proxyReply, proxySock.getRemoteSocketAddress().toString(),\n          proxySock.getLocalSocketAddress().toString(),\n          null, 0, 0, 0, \"\", null, datanode);\n\n      // receive a block\n      blockReceiver.receiveBlock(null, null, null, null, \n          dataXceiverServer.balanceThrottler, null);\n                    \n      // notify name node\n      datanode.notifyNamenodeReceivedBlock(block, delHint);\n\n      LOG.info(\"Moved block \" + block + \n          \" from \" + s.getRemoteSocketAddress());\n      \n    } catch (IOException ioe) {\n      opStatus \u003d ERROR;\n      LOG.info(\"opReplaceBlock \" + block + \" received exception \" + ioe);\n      throw ioe;\n    } finally {\n      // receive the last byte that indicates the proxy released its thread resource\n      if (opStatus \u003d\u003d SUCCESS) {\n        try {\n          proxyReply.readChar();\n        } catch (IOException ignored) {\n        }\n      }\n      \n      // now release the thread resource\n      dataXceiverServer.balanceThrottler.release();\n      \n      // send response back\n      try {\n        sendResponse(s, opStatus, datanode.socketWriteTimeout);\n      } catch (IOException ioe) {\n        LOG.warn(\"Error writing reply back to \" + s.getRemoteSocketAddress());\n      }\n      IOUtils.closeStream(proxyOut);\n      IOUtils.closeStream(blockReceiver);\n      IOUtils.closeStream(proxyReply);\n    }\n\n    //update metrics\n    datanode.metrics.addReplaceBlockOp(elapsed());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public void replaceBlock(final ExtendedBlock block,\n      final Token\u003cBlockTokenIdentifier\u003e blockToken,\n      final String delHint,\n      final DatanodeInfo proxySource) throws IOException {\n    updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n\n    /* read header */\n    block.setNumBytes(dataXceiverServer.estimateBlockSize);\n    if (datanode.isBlockTokenEnabled) {\n      try {\n        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n            BlockTokenSecretManager.AccessMode.REPLACE);\n      } catch (InvalidToken e) {\n        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n            + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n            + e.getLocalizedMessage());\n        sendResponse(s, ERROR_ACCESS_TOKEN, datanode.socketWriteTimeout);\n        return;\n      }\n    }\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      LOG.warn(\"Not able to receive block \" + block.getBlockId() + \" from \" \n          + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\");\n      sendResponse(s, ERROR, datanode.socketWriteTimeout);\n      return;\n    }\n\n    Socket proxySock \u003d null;\n    DataOutputStream proxyOut \u003d null;\n    Status opStatus \u003d SUCCESS;\n    BlockReceiver blockReceiver \u003d null;\n    DataInputStream proxyReply \u003d null;\n    \n    try {\n      // get the output stream to the proxy\n      InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(\n          proxySource.getName());\n      proxySock \u003d datanode.newSocket();\n      NetUtils.connect(proxySock, proxyAddr, datanode.socketTimeout);\n      proxySock.setSoTimeout(datanode.socketTimeout);\n\n      OutputStream baseStream \u003d NetUtils.getOutputStream(proxySock, \n          datanode.socketWriteTimeout);\n      proxyOut \u003d new DataOutputStream(new BufferedOutputStream(baseStream,\n          FSConstants.SMALL_BUFFER_SIZE));\n\n      /* send request to the proxy */\n      new Sender(proxyOut).copyBlock(block, blockToken);\n\n      // receive the response from the proxy\n      proxyReply \u003d new DataInputStream(new BufferedInputStream(\n          NetUtils.getInputStream(proxySock), FSConstants.IO_FILE_BUFFER_SIZE));\n      BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n          HdfsProtoUtil.vintPrefixed(proxyReply));\n\n      if (copyResponse.getStatus() !\u003d SUCCESS) {\n        if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n          throw new IOException(\"Copy block \" + block + \" from \"\n              + proxySock.getRemoteSocketAddress()\n              + \" failed due to access token error\");\n        }\n        throw new IOException(\"Copy block \" + block + \" from \"\n            + proxySock.getRemoteSocketAddress() + \" failed\");\n      }\n      // open a block receiver and check if the block does not exist\n      blockReceiver \u003d new BlockReceiver(\n          block, proxyReply, proxySock.getRemoteSocketAddress().toString(),\n          proxySock.getLocalSocketAddress().toString(),\n          null, 0, 0, 0, \"\", null, datanode);\n\n      // receive a block\n      blockReceiver.receiveBlock(null, null, null, null, \n          dataXceiverServer.balanceThrottler, null);\n                    \n      // notify name node\n      datanode.notifyNamenodeReceivedBlock(block, delHint);\n\n      LOG.info(\"Moved block \" + block + \n          \" from \" + s.getRemoteSocketAddress());\n      \n    } catch (IOException ioe) {\n      opStatus \u003d ERROR;\n      LOG.info(\"opReplaceBlock \" + block + \" received exception \" + ioe);\n      throw ioe;\n    } finally {\n      // receive the last byte that indicates the proxy released its thread resource\n      if (opStatus \u003d\u003d SUCCESS) {\n        try {\n          proxyReply.readChar();\n        } catch (IOException ignored) {\n        }\n      }\n      \n      // now release the thread resource\n      dataXceiverServer.balanceThrottler.release();\n      \n      // send response back\n      try {\n        sendResponse(s, opStatus, datanode.socketWriteTimeout);\n      } catch (IOException ioe) {\n        LOG.warn(\"Error writing reply back to \" + s.getRemoteSocketAddress());\n      }\n      IOUtils.closeStream(proxyOut);\n      IOUtils.closeStream(blockReceiver);\n      IOUtils.closeStream(proxyReply);\n    }\n\n    //update metrics\n    datanode.metrics.addReplaceBlockOp(elapsed());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java"
      }
    },
    "d86f3183d93714ba078416af4f609d26376eadb0": {
      "type": "Yfilerename",
      "commitMessage": "HDFS-2096. Mavenization of hadoop-hdfs. Contributed by Alejandro Abdelnur.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159702 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/08/11 10:36 AM",
      "commitName": "d86f3183d93714ba078416af4f609d26376eadb0",
      "commitAuthor": "Thomas White",
      "commitDateOld": "19/08/11 10:26 AM",
      "commitNameOld": "6ee5a73e0e91a2ef27753a32c576835e951d8119",
      "commitAuthorOld": "Thomas White",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public void replaceBlock(final ExtendedBlock block,\n      final Token\u003cBlockTokenIdentifier\u003e blockToken,\n      final String delHint,\n      final DatanodeInfo proxySource) throws IOException {\n    updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n\n    /* read header */\n    block.setNumBytes(dataXceiverServer.estimateBlockSize);\n    if (datanode.isBlockTokenEnabled) {\n      try {\n        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n            BlockTokenSecretManager.AccessMode.REPLACE);\n      } catch (InvalidToken e) {\n        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n            + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n            + e.getLocalizedMessage());\n        sendResponse(s, ERROR_ACCESS_TOKEN, datanode.socketWriteTimeout);\n        return;\n      }\n    }\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      LOG.warn(\"Not able to receive block \" + block.getBlockId() + \" from \" \n          + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\");\n      sendResponse(s, ERROR, datanode.socketWriteTimeout);\n      return;\n    }\n\n    Socket proxySock \u003d null;\n    DataOutputStream proxyOut \u003d null;\n    Status opStatus \u003d SUCCESS;\n    BlockReceiver blockReceiver \u003d null;\n    DataInputStream proxyReply \u003d null;\n    \n    try {\n      // get the output stream to the proxy\n      InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(\n          proxySource.getName());\n      proxySock \u003d datanode.newSocket();\n      NetUtils.connect(proxySock, proxyAddr, datanode.socketTimeout);\n      proxySock.setSoTimeout(datanode.socketTimeout);\n\n      OutputStream baseStream \u003d NetUtils.getOutputStream(proxySock, \n          datanode.socketWriteTimeout);\n      proxyOut \u003d new DataOutputStream(new BufferedOutputStream(baseStream,\n          FSConstants.SMALL_BUFFER_SIZE));\n\n      /* send request to the proxy */\n      new Sender(proxyOut).copyBlock(block, blockToken);\n\n      // receive the response from the proxy\n      proxyReply \u003d new DataInputStream(new BufferedInputStream(\n          NetUtils.getInputStream(proxySock), FSConstants.IO_FILE_BUFFER_SIZE));\n      BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n          HdfsProtoUtil.vintPrefixed(proxyReply));\n\n      if (copyResponse.getStatus() !\u003d SUCCESS) {\n        if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n          throw new IOException(\"Copy block \" + block + \" from \"\n              + proxySock.getRemoteSocketAddress()\n              + \" failed due to access token error\");\n        }\n        throw new IOException(\"Copy block \" + block + \" from \"\n            + proxySock.getRemoteSocketAddress() + \" failed\");\n      }\n      // open a block receiver and check if the block does not exist\n      blockReceiver \u003d new BlockReceiver(\n          block, proxyReply, proxySock.getRemoteSocketAddress().toString(),\n          proxySock.getLocalSocketAddress().toString(),\n          null, 0, 0, 0, \"\", null, datanode);\n\n      // receive a block\n      blockReceiver.receiveBlock(null, null, null, null, \n          dataXceiverServer.balanceThrottler, null);\n                    \n      // notify name node\n      datanode.notifyNamenodeReceivedBlock(block, delHint);\n\n      LOG.info(\"Moved block \" + block + \n          \" from \" + s.getRemoteSocketAddress());\n      \n    } catch (IOException ioe) {\n      opStatus \u003d ERROR;\n      LOG.info(\"opReplaceBlock \" + block + \" received exception \" + ioe);\n      throw ioe;\n    } finally {\n      // receive the last byte that indicates the proxy released its thread resource\n      if (opStatus \u003d\u003d SUCCESS) {\n        try {\n          proxyReply.readChar();\n        } catch (IOException ignored) {\n        }\n      }\n      \n      // now release the thread resource\n      dataXceiverServer.balanceThrottler.release();\n      \n      // send response back\n      try {\n        sendResponse(s, opStatus, datanode.socketWriteTimeout);\n      } catch (IOException ioe) {\n        LOG.warn(\"Error writing reply back to \" + s.getRemoteSocketAddress());\n      }\n      IOUtils.closeStream(proxyOut);\n      IOUtils.closeStream(blockReceiver);\n      IOUtils.closeStream(proxyReply);\n    }\n\n    //update metrics\n    datanode.metrics.addReplaceBlockOp(elapsed());\n  }",
      "path": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {
        "oldPath": "hdfs/src/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
        "newPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java"
      }
    },
    "ef223e8e8e1e18733fc18cd84e34dd0bb0f9a710": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2241. Remove implementing FSConstants interface to just get the constants from the interface. Contributed by Suresh Srinivas.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1156420 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/08/11 5:46 PM",
      "commitName": "ef223e8e8e1e18733fc18cd84e34dd0bb0f9a710",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "12/07/11 6:11 PM",
      "commitNameOld": "2c5dd549e31aa5d3377ff2619ede8e92b8dc5d0f",
      "commitAuthorOld": "Jitendra Nath Pandey",
      "daysBetweenCommits": 28.98,
      "commitsBetweenForRepo": 108,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,111 +1,111 @@\n   public void replaceBlock(final ExtendedBlock block,\n       final Token\u003cBlockTokenIdentifier\u003e blockToken,\n       final String delHint,\n       final DatanodeInfo proxySource) throws IOException {\n     updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n \n     /* read header */\n     block.setNumBytes(dataXceiverServer.estimateBlockSize);\n     if (datanode.isBlockTokenEnabled) {\n       try {\n         datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n             BlockTokenSecretManager.AccessMode.REPLACE);\n       } catch (InvalidToken e) {\n         LOG.warn(\"Invalid access token in request from \" + remoteAddress\n             + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n             + e.getLocalizedMessage());\n         sendResponse(s, ERROR_ACCESS_TOKEN, datanode.socketWriteTimeout);\n         return;\n       }\n     }\n \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n       LOG.warn(\"Not able to receive block \" + block.getBlockId() + \" from \" \n           + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\");\n       sendResponse(s, ERROR, datanode.socketWriteTimeout);\n       return;\n     }\n \n     Socket proxySock \u003d null;\n     DataOutputStream proxyOut \u003d null;\n     Status opStatus \u003d SUCCESS;\n     BlockReceiver blockReceiver \u003d null;\n     DataInputStream proxyReply \u003d null;\n     \n     try {\n       // get the output stream to the proxy\n       InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(\n           proxySource.getName());\n       proxySock \u003d datanode.newSocket();\n       NetUtils.connect(proxySock, proxyAddr, datanode.socketTimeout);\n       proxySock.setSoTimeout(datanode.socketTimeout);\n \n       OutputStream baseStream \u003d NetUtils.getOutputStream(proxySock, \n           datanode.socketWriteTimeout);\n-      proxyOut \u003d new DataOutputStream(\n-                     new BufferedOutputStream(baseStream, SMALL_BUFFER_SIZE));\n+      proxyOut \u003d new DataOutputStream(new BufferedOutputStream(baseStream,\n+          FSConstants.SMALL_BUFFER_SIZE));\n \n       /* send request to the proxy */\n       new Sender(proxyOut).copyBlock(block, blockToken);\n \n       // receive the response from the proxy\n       proxyReply \u003d new DataInputStream(new BufferedInputStream(\n-          NetUtils.getInputStream(proxySock), BUFFER_SIZE));\n+          NetUtils.getInputStream(proxySock), FSConstants.IO_FILE_BUFFER_SIZE));\n       BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n           HdfsProtoUtil.vintPrefixed(proxyReply));\n \n       if (copyResponse.getStatus() !\u003d SUCCESS) {\n         if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n           throw new IOException(\"Copy block \" + block + \" from \"\n               + proxySock.getRemoteSocketAddress()\n               + \" failed due to access token error\");\n         }\n         throw new IOException(\"Copy block \" + block + \" from \"\n             + proxySock.getRemoteSocketAddress() + \" failed\");\n       }\n       // open a block receiver and check if the block does not exist\n       blockReceiver \u003d new BlockReceiver(\n           block, proxyReply, proxySock.getRemoteSocketAddress().toString(),\n           proxySock.getLocalSocketAddress().toString(),\n           null, 0, 0, 0, \"\", null, datanode);\n \n       // receive a block\n       blockReceiver.receiveBlock(null, null, null, null, \n           dataXceiverServer.balanceThrottler, null);\n                     \n       // notify name node\n       datanode.notifyNamenodeReceivedBlock(block, delHint);\n \n       LOG.info(\"Moved block \" + block + \n           \" from \" + s.getRemoteSocketAddress());\n       \n     } catch (IOException ioe) {\n       opStatus \u003d ERROR;\n       LOG.info(\"opReplaceBlock \" + block + \" received exception \" + ioe);\n       throw ioe;\n     } finally {\n       // receive the last byte that indicates the proxy released its thread resource\n       if (opStatus \u003d\u003d SUCCESS) {\n         try {\n           proxyReply.readChar();\n         } catch (IOException ignored) {\n         }\n       }\n       \n       // now release the thread resource\n       dataXceiverServer.balanceThrottler.release();\n       \n       // send response back\n       try {\n         sendResponse(s, opStatus, datanode.socketWriteTimeout);\n       } catch (IOException ioe) {\n         LOG.warn(\"Error writing reply back to \" + s.getRemoteSocketAddress());\n       }\n       IOUtils.closeStream(proxyOut);\n       IOUtils.closeStream(blockReceiver);\n       IOUtils.closeStream(proxyReply);\n     }\n \n     //update metrics\n     datanode.metrics.addReplaceBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void replaceBlock(final ExtendedBlock block,\n      final Token\u003cBlockTokenIdentifier\u003e blockToken,\n      final String delHint,\n      final DatanodeInfo proxySource) throws IOException {\n    updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n\n    /* read header */\n    block.setNumBytes(dataXceiverServer.estimateBlockSize);\n    if (datanode.isBlockTokenEnabled) {\n      try {\n        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n            BlockTokenSecretManager.AccessMode.REPLACE);\n      } catch (InvalidToken e) {\n        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n            + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n            + e.getLocalizedMessage());\n        sendResponse(s, ERROR_ACCESS_TOKEN, datanode.socketWriteTimeout);\n        return;\n      }\n    }\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      LOG.warn(\"Not able to receive block \" + block.getBlockId() + \" from \" \n          + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\");\n      sendResponse(s, ERROR, datanode.socketWriteTimeout);\n      return;\n    }\n\n    Socket proxySock \u003d null;\n    DataOutputStream proxyOut \u003d null;\n    Status opStatus \u003d SUCCESS;\n    BlockReceiver blockReceiver \u003d null;\n    DataInputStream proxyReply \u003d null;\n    \n    try {\n      // get the output stream to the proxy\n      InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(\n          proxySource.getName());\n      proxySock \u003d datanode.newSocket();\n      NetUtils.connect(proxySock, proxyAddr, datanode.socketTimeout);\n      proxySock.setSoTimeout(datanode.socketTimeout);\n\n      OutputStream baseStream \u003d NetUtils.getOutputStream(proxySock, \n          datanode.socketWriteTimeout);\n      proxyOut \u003d new DataOutputStream(new BufferedOutputStream(baseStream,\n          FSConstants.SMALL_BUFFER_SIZE));\n\n      /* send request to the proxy */\n      new Sender(proxyOut).copyBlock(block, blockToken);\n\n      // receive the response from the proxy\n      proxyReply \u003d new DataInputStream(new BufferedInputStream(\n          NetUtils.getInputStream(proxySock), FSConstants.IO_FILE_BUFFER_SIZE));\n      BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n          HdfsProtoUtil.vintPrefixed(proxyReply));\n\n      if (copyResponse.getStatus() !\u003d SUCCESS) {\n        if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n          throw new IOException(\"Copy block \" + block + \" from \"\n              + proxySock.getRemoteSocketAddress()\n              + \" failed due to access token error\");\n        }\n        throw new IOException(\"Copy block \" + block + \" from \"\n            + proxySock.getRemoteSocketAddress() + \" failed\");\n      }\n      // open a block receiver and check if the block does not exist\n      blockReceiver \u003d new BlockReceiver(\n          block, proxyReply, proxySock.getRemoteSocketAddress().toString(),\n          proxySock.getLocalSocketAddress().toString(),\n          null, 0, 0, 0, \"\", null, datanode);\n\n      // receive a block\n      blockReceiver.receiveBlock(null, null, null, null, \n          dataXceiverServer.balanceThrottler, null);\n                    \n      // notify name node\n      datanode.notifyNamenodeReceivedBlock(block, delHint);\n\n      LOG.info(\"Moved block \" + block + \n          \" from \" + s.getRemoteSocketAddress());\n      \n    } catch (IOException ioe) {\n      opStatus \u003d ERROR;\n      LOG.info(\"opReplaceBlock \" + block + \" received exception \" + ioe);\n      throw ioe;\n    } finally {\n      // receive the last byte that indicates the proxy released its thread resource\n      if (opStatus \u003d\u003d SUCCESS) {\n        try {\n          proxyReply.readChar();\n        } catch (IOException ignored) {\n        }\n      }\n      \n      // now release the thread resource\n      dataXceiverServer.balanceThrottler.release();\n      \n      // send response back\n      try {\n        sendResponse(s, opStatus, datanode.socketWriteTimeout);\n      } catch (IOException ioe) {\n        LOG.warn(\"Error writing reply back to \" + s.getRemoteSocketAddress());\n      }\n      IOUtils.closeStream(proxyOut);\n      IOUtils.closeStream(blockReceiver);\n      IOUtils.closeStream(proxyReply);\n    }\n\n    //update metrics\n    datanode.metrics.addReplaceBlockOp(elapsed());\n  }",
      "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "2f48fae72aa52e6ec42264cad24fab36b6a426c2": {
      "type": "Ymultichange(Yrename,Yparameterchange,Ymodifierchange,Ybodychange,Yparametermetachange)",
      "commitMessage": "HDFS-2087. Declare methods in DataTransferProtocol interface, and change Sender and Receiver to implement the interface.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1139124 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/06/11 4:57 PM",
      "commitName": "2f48fae72aa52e6ec42264cad24fab36b6a426c2",
      "commitAuthor": "Tsz-wo Sze",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "HDFS-2087. Declare methods in DataTransferProtocol interface, and change Sender and Receiver to implement the interface.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1139124 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "23/06/11 4:57 PM",
          "commitName": "2f48fae72aa52e6ec42264cad24fab36b6a426c2",
          "commitAuthor": "Tsz-wo Sze",
          "commitDateOld": "21/06/11 10:12 AM",
          "commitNameOld": "3f190b3e1acc5ea9e9a03e85a4df0e3f0ab73b9f",
          "commitAuthorOld": "Tsz-wo Sze",
          "daysBetweenCommits": 2.28,
          "commitsBetweenForRepo": 7,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,110 +1,111 @@\n-  protected void opReplaceBlock(DataInputStream in,\n-      ExtendedBlock block, String sourceID, DatanodeInfo proxySource,\n-      Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n-    updateCurrentThreadName(\"Replacing block \" + block + \" from \" + sourceID);\n+  public void replaceBlock(final ExtendedBlock block,\n+      final Token\u003cBlockTokenIdentifier\u003e blockToken,\n+      final String delHint,\n+      final DatanodeInfo proxySource) throws IOException {\n+    updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n \n     /* read header */\n     block.setNumBytes(dataXceiverServer.estimateBlockSize);\n     if (datanode.isBlockTokenEnabled) {\n       try {\n         datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n             BlockTokenSecretManager.AccessMode.REPLACE);\n       } catch (InvalidToken e) {\n         LOG.warn(\"Invalid access token in request from \" + remoteAddress\n             + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n             + e.getLocalizedMessage());\n         sendResponse(s, ERROR_ACCESS_TOKEN, datanode.socketWriteTimeout);\n         return;\n       }\n     }\n \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n       LOG.warn(\"Not able to receive block \" + block.getBlockId() + \" from \" \n           + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\");\n       sendResponse(s, ERROR, datanode.socketWriteTimeout);\n       return;\n     }\n \n     Socket proxySock \u003d null;\n     DataOutputStream proxyOut \u003d null;\n     Status opStatus \u003d SUCCESS;\n     BlockReceiver blockReceiver \u003d null;\n     DataInputStream proxyReply \u003d null;\n     \n     try {\n       // get the output stream to the proxy\n       InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(\n           proxySource.getName());\n       proxySock \u003d datanode.newSocket();\n       NetUtils.connect(proxySock, proxyAddr, datanode.socketTimeout);\n       proxySock.setSoTimeout(datanode.socketTimeout);\n \n       OutputStream baseStream \u003d NetUtils.getOutputStream(proxySock, \n           datanode.socketWriteTimeout);\n       proxyOut \u003d new DataOutputStream(\n                      new BufferedOutputStream(baseStream, SMALL_BUFFER_SIZE));\n \n       /* send request to the proxy */\n-      Sender.opCopyBlock(proxyOut, block, blockToken);\n+      new Sender(proxyOut).copyBlock(block, blockToken);\n \n       // receive the response from the proxy\n       proxyReply \u003d new DataInputStream(new BufferedInputStream(\n           NetUtils.getInputStream(proxySock), BUFFER_SIZE));\n       BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n           HdfsProtoUtil.vintPrefixed(proxyReply));\n \n       if (copyResponse.getStatus() !\u003d SUCCESS) {\n         if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n           throw new IOException(\"Copy block \" + block + \" from \"\n               + proxySock.getRemoteSocketAddress()\n               + \" failed due to access token error\");\n         }\n         throw new IOException(\"Copy block \" + block + \" from \"\n             + proxySock.getRemoteSocketAddress() + \" failed\");\n       }\n       // open a block receiver and check if the block does not exist\n       blockReceiver \u003d new BlockReceiver(\n           block, proxyReply, proxySock.getRemoteSocketAddress().toString(),\n           proxySock.getLocalSocketAddress().toString(),\n           null, 0, 0, 0, \"\", null, datanode);\n \n       // receive a block\n       blockReceiver.receiveBlock(null, null, null, null, \n           dataXceiverServer.balanceThrottler, null);\n                     \n       // notify name node\n-      datanode.notifyNamenodeReceivedBlock(block, sourceID);\n+      datanode.notifyNamenodeReceivedBlock(block, delHint);\n \n       LOG.info(\"Moved block \" + block + \n           \" from \" + s.getRemoteSocketAddress());\n       \n     } catch (IOException ioe) {\n       opStatus \u003d ERROR;\n       LOG.info(\"opReplaceBlock \" + block + \" received exception \" + ioe);\n       throw ioe;\n     } finally {\n       // receive the last byte that indicates the proxy released its thread resource\n       if (opStatus \u003d\u003d SUCCESS) {\n         try {\n           proxyReply.readChar();\n         } catch (IOException ignored) {\n         }\n       }\n       \n       // now release the thread resource\n       dataXceiverServer.balanceThrottler.release();\n       \n       // send response back\n       try {\n         sendResponse(s, opStatus, datanode.socketWriteTimeout);\n       } catch (IOException ioe) {\n         LOG.warn(\"Error writing reply back to \" + s.getRemoteSocketAddress());\n       }\n       IOUtils.closeStream(proxyOut);\n       IOUtils.closeStream(blockReceiver);\n       IOUtils.closeStream(proxyReply);\n     }\n \n     //update metrics\n     datanode.metrics.addReplaceBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void replaceBlock(final ExtendedBlock block,\n      final Token\u003cBlockTokenIdentifier\u003e blockToken,\n      final String delHint,\n      final DatanodeInfo proxySource) throws IOException {\n    updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n\n    /* read header */\n    block.setNumBytes(dataXceiverServer.estimateBlockSize);\n    if (datanode.isBlockTokenEnabled) {\n      try {\n        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n            BlockTokenSecretManager.AccessMode.REPLACE);\n      } catch (InvalidToken e) {\n        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n            + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n            + e.getLocalizedMessage());\n        sendResponse(s, ERROR_ACCESS_TOKEN, datanode.socketWriteTimeout);\n        return;\n      }\n    }\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      LOG.warn(\"Not able to receive block \" + block.getBlockId() + \" from \" \n          + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\");\n      sendResponse(s, ERROR, datanode.socketWriteTimeout);\n      return;\n    }\n\n    Socket proxySock \u003d null;\n    DataOutputStream proxyOut \u003d null;\n    Status opStatus \u003d SUCCESS;\n    BlockReceiver blockReceiver \u003d null;\n    DataInputStream proxyReply \u003d null;\n    \n    try {\n      // get the output stream to the proxy\n      InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(\n          proxySource.getName());\n      proxySock \u003d datanode.newSocket();\n      NetUtils.connect(proxySock, proxyAddr, datanode.socketTimeout);\n      proxySock.setSoTimeout(datanode.socketTimeout);\n\n      OutputStream baseStream \u003d NetUtils.getOutputStream(proxySock, \n          datanode.socketWriteTimeout);\n      proxyOut \u003d new DataOutputStream(\n                     new BufferedOutputStream(baseStream, SMALL_BUFFER_SIZE));\n\n      /* send request to the proxy */\n      new Sender(proxyOut).copyBlock(block, blockToken);\n\n      // receive the response from the proxy\n      proxyReply \u003d new DataInputStream(new BufferedInputStream(\n          NetUtils.getInputStream(proxySock), BUFFER_SIZE));\n      BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n          HdfsProtoUtil.vintPrefixed(proxyReply));\n\n      if (copyResponse.getStatus() !\u003d SUCCESS) {\n        if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n          throw new IOException(\"Copy block \" + block + \" from \"\n              + proxySock.getRemoteSocketAddress()\n              + \" failed due to access token error\");\n        }\n        throw new IOException(\"Copy block \" + block + \" from \"\n            + proxySock.getRemoteSocketAddress() + \" failed\");\n      }\n      // open a block receiver and check if the block does not exist\n      blockReceiver \u003d new BlockReceiver(\n          block, proxyReply, proxySock.getRemoteSocketAddress().toString(),\n          proxySock.getLocalSocketAddress().toString(),\n          null, 0, 0, 0, \"\", null, datanode);\n\n      // receive a block\n      blockReceiver.receiveBlock(null, null, null, null, \n          dataXceiverServer.balanceThrottler, null);\n                    \n      // notify name node\n      datanode.notifyNamenodeReceivedBlock(block, delHint);\n\n      LOG.info(\"Moved block \" + block + \n          \" from \" + s.getRemoteSocketAddress());\n      \n    } catch (IOException ioe) {\n      opStatus \u003d ERROR;\n      LOG.info(\"opReplaceBlock \" + block + \" received exception \" + ioe);\n      throw ioe;\n    } finally {\n      // receive the last byte that indicates the proxy released its thread resource\n      if (opStatus \u003d\u003d SUCCESS) {\n        try {\n          proxyReply.readChar();\n        } catch (IOException ignored) {\n        }\n      }\n      \n      // now release the thread resource\n      dataXceiverServer.balanceThrottler.release();\n      \n      // send response back\n      try {\n        sendResponse(s, opStatus, datanode.socketWriteTimeout);\n      } catch (IOException ioe) {\n        LOG.warn(\"Error writing reply back to \" + s.getRemoteSocketAddress());\n      }\n      IOUtils.closeStream(proxyOut);\n      IOUtils.closeStream(blockReceiver);\n      IOUtils.closeStream(proxyReply);\n    }\n\n    //update metrics\n    datanode.metrics.addReplaceBlockOp(elapsed());\n  }",
          "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
          "extendedDetails": {
            "oldValue": "opReplaceBlock",
            "newValue": "replaceBlock"
          }
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-2087. Declare methods in DataTransferProtocol interface, and change Sender and Receiver to implement the interface.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1139124 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "23/06/11 4:57 PM",
          "commitName": "2f48fae72aa52e6ec42264cad24fab36b6a426c2",
          "commitAuthor": "Tsz-wo Sze",
          "commitDateOld": "21/06/11 10:12 AM",
          "commitNameOld": "3f190b3e1acc5ea9e9a03e85a4df0e3f0ab73b9f",
          "commitAuthorOld": "Tsz-wo Sze",
          "daysBetweenCommits": 2.28,
          "commitsBetweenForRepo": 7,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,110 +1,111 @@\n-  protected void opReplaceBlock(DataInputStream in,\n-      ExtendedBlock block, String sourceID, DatanodeInfo proxySource,\n-      Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n-    updateCurrentThreadName(\"Replacing block \" + block + \" from \" + sourceID);\n+  public void replaceBlock(final ExtendedBlock block,\n+      final Token\u003cBlockTokenIdentifier\u003e blockToken,\n+      final String delHint,\n+      final DatanodeInfo proxySource) throws IOException {\n+    updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n \n     /* read header */\n     block.setNumBytes(dataXceiverServer.estimateBlockSize);\n     if (datanode.isBlockTokenEnabled) {\n       try {\n         datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n             BlockTokenSecretManager.AccessMode.REPLACE);\n       } catch (InvalidToken e) {\n         LOG.warn(\"Invalid access token in request from \" + remoteAddress\n             + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n             + e.getLocalizedMessage());\n         sendResponse(s, ERROR_ACCESS_TOKEN, datanode.socketWriteTimeout);\n         return;\n       }\n     }\n \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n       LOG.warn(\"Not able to receive block \" + block.getBlockId() + \" from \" \n           + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\");\n       sendResponse(s, ERROR, datanode.socketWriteTimeout);\n       return;\n     }\n \n     Socket proxySock \u003d null;\n     DataOutputStream proxyOut \u003d null;\n     Status opStatus \u003d SUCCESS;\n     BlockReceiver blockReceiver \u003d null;\n     DataInputStream proxyReply \u003d null;\n     \n     try {\n       // get the output stream to the proxy\n       InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(\n           proxySource.getName());\n       proxySock \u003d datanode.newSocket();\n       NetUtils.connect(proxySock, proxyAddr, datanode.socketTimeout);\n       proxySock.setSoTimeout(datanode.socketTimeout);\n \n       OutputStream baseStream \u003d NetUtils.getOutputStream(proxySock, \n           datanode.socketWriteTimeout);\n       proxyOut \u003d new DataOutputStream(\n                      new BufferedOutputStream(baseStream, SMALL_BUFFER_SIZE));\n \n       /* send request to the proxy */\n-      Sender.opCopyBlock(proxyOut, block, blockToken);\n+      new Sender(proxyOut).copyBlock(block, blockToken);\n \n       // receive the response from the proxy\n       proxyReply \u003d new DataInputStream(new BufferedInputStream(\n           NetUtils.getInputStream(proxySock), BUFFER_SIZE));\n       BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n           HdfsProtoUtil.vintPrefixed(proxyReply));\n \n       if (copyResponse.getStatus() !\u003d SUCCESS) {\n         if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n           throw new IOException(\"Copy block \" + block + \" from \"\n               + proxySock.getRemoteSocketAddress()\n               + \" failed due to access token error\");\n         }\n         throw new IOException(\"Copy block \" + block + \" from \"\n             + proxySock.getRemoteSocketAddress() + \" failed\");\n       }\n       // open a block receiver and check if the block does not exist\n       blockReceiver \u003d new BlockReceiver(\n           block, proxyReply, proxySock.getRemoteSocketAddress().toString(),\n           proxySock.getLocalSocketAddress().toString(),\n           null, 0, 0, 0, \"\", null, datanode);\n \n       // receive a block\n       blockReceiver.receiveBlock(null, null, null, null, \n           dataXceiverServer.balanceThrottler, null);\n                     \n       // notify name node\n-      datanode.notifyNamenodeReceivedBlock(block, sourceID);\n+      datanode.notifyNamenodeReceivedBlock(block, delHint);\n \n       LOG.info(\"Moved block \" + block + \n           \" from \" + s.getRemoteSocketAddress());\n       \n     } catch (IOException ioe) {\n       opStatus \u003d ERROR;\n       LOG.info(\"opReplaceBlock \" + block + \" received exception \" + ioe);\n       throw ioe;\n     } finally {\n       // receive the last byte that indicates the proxy released its thread resource\n       if (opStatus \u003d\u003d SUCCESS) {\n         try {\n           proxyReply.readChar();\n         } catch (IOException ignored) {\n         }\n       }\n       \n       // now release the thread resource\n       dataXceiverServer.balanceThrottler.release();\n       \n       // send response back\n       try {\n         sendResponse(s, opStatus, datanode.socketWriteTimeout);\n       } catch (IOException ioe) {\n         LOG.warn(\"Error writing reply back to \" + s.getRemoteSocketAddress());\n       }\n       IOUtils.closeStream(proxyOut);\n       IOUtils.closeStream(blockReceiver);\n       IOUtils.closeStream(proxyReply);\n     }\n \n     //update metrics\n     datanode.metrics.addReplaceBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void replaceBlock(final ExtendedBlock block,\n      final Token\u003cBlockTokenIdentifier\u003e blockToken,\n      final String delHint,\n      final DatanodeInfo proxySource) throws IOException {\n    updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n\n    /* read header */\n    block.setNumBytes(dataXceiverServer.estimateBlockSize);\n    if (datanode.isBlockTokenEnabled) {\n      try {\n        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n            BlockTokenSecretManager.AccessMode.REPLACE);\n      } catch (InvalidToken e) {\n        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n            + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n            + e.getLocalizedMessage());\n        sendResponse(s, ERROR_ACCESS_TOKEN, datanode.socketWriteTimeout);\n        return;\n      }\n    }\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      LOG.warn(\"Not able to receive block \" + block.getBlockId() + \" from \" \n          + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\");\n      sendResponse(s, ERROR, datanode.socketWriteTimeout);\n      return;\n    }\n\n    Socket proxySock \u003d null;\n    DataOutputStream proxyOut \u003d null;\n    Status opStatus \u003d SUCCESS;\n    BlockReceiver blockReceiver \u003d null;\n    DataInputStream proxyReply \u003d null;\n    \n    try {\n      // get the output stream to the proxy\n      InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(\n          proxySource.getName());\n      proxySock \u003d datanode.newSocket();\n      NetUtils.connect(proxySock, proxyAddr, datanode.socketTimeout);\n      proxySock.setSoTimeout(datanode.socketTimeout);\n\n      OutputStream baseStream \u003d NetUtils.getOutputStream(proxySock, \n          datanode.socketWriteTimeout);\n      proxyOut \u003d new DataOutputStream(\n                     new BufferedOutputStream(baseStream, SMALL_BUFFER_SIZE));\n\n      /* send request to the proxy */\n      new Sender(proxyOut).copyBlock(block, blockToken);\n\n      // receive the response from the proxy\n      proxyReply \u003d new DataInputStream(new BufferedInputStream(\n          NetUtils.getInputStream(proxySock), BUFFER_SIZE));\n      BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n          HdfsProtoUtil.vintPrefixed(proxyReply));\n\n      if (copyResponse.getStatus() !\u003d SUCCESS) {\n        if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n          throw new IOException(\"Copy block \" + block + \" from \"\n              + proxySock.getRemoteSocketAddress()\n              + \" failed due to access token error\");\n        }\n        throw new IOException(\"Copy block \" + block + \" from \"\n            + proxySock.getRemoteSocketAddress() + \" failed\");\n      }\n      // open a block receiver and check if the block does not exist\n      blockReceiver \u003d new BlockReceiver(\n          block, proxyReply, proxySock.getRemoteSocketAddress().toString(),\n          proxySock.getLocalSocketAddress().toString(),\n          null, 0, 0, 0, \"\", null, datanode);\n\n      // receive a block\n      blockReceiver.receiveBlock(null, null, null, null, \n          dataXceiverServer.balanceThrottler, null);\n                    \n      // notify name node\n      datanode.notifyNamenodeReceivedBlock(block, delHint);\n\n      LOG.info(\"Moved block \" + block + \n          \" from \" + s.getRemoteSocketAddress());\n      \n    } catch (IOException ioe) {\n      opStatus \u003d ERROR;\n      LOG.info(\"opReplaceBlock \" + block + \" received exception \" + ioe);\n      throw ioe;\n    } finally {\n      // receive the last byte that indicates the proxy released its thread resource\n      if (opStatus \u003d\u003d SUCCESS) {\n        try {\n          proxyReply.readChar();\n        } catch (IOException ignored) {\n        }\n      }\n      \n      // now release the thread resource\n      dataXceiverServer.balanceThrottler.release();\n      \n      // send response back\n      try {\n        sendResponse(s, opStatus, datanode.socketWriteTimeout);\n      } catch (IOException ioe) {\n        LOG.warn(\"Error writing reply back to \" + s.getRemoteSocketAddress());\n      }\n      IOUtils.closeStream(proxyOut);\n      IOUtils.closeStream(blockReceiver);\n      IOUtils.closeStream(proxyReply);\n    }\n\n    //update metrics\n    datanode.metrics.addReplaceBlockOp(elapsed());\n  }",
          "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
          "extendedDetails": {
            "oldValue": "[in-DataInputStream, block-ExtendedBlock, sourceID-String, proxySource-DatanodeInfo, blockToken-Token\u003cBlockTokenIdentifier\u003e]",
            "newValue": "[block-ExtendedBlock(modifiers-final), blockToken-Token\u003cBlockTokenIdentifier\u003e(modifiers-final), delHint-String(modifiers-final), proxySource-DatanodeInfo(modifiers-final)]"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "HDFS-2087. Declare methods in DataTransferProtocol interface, and change Sender and Receiver to implement the interface.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1139124 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "23/06/11 4:57 PM",
          "commitName": "2f48fae72aa52e6ec42264cad24fab36b6a426c2",
          "commitAuthor": "Tsz-wo Sze",
          "commitDateOld": "21/06/11 10:12 AM",
          "commitNameOld": "3f190b3e1acc5ea9e9a03e85a4df0e3f0ab73b9f",
          "commitAuthorOld": "Tsz-wo Sze",
          "daysBetweenCommits": 2.28,
          "commitsBetweenForRepo": 7,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,110 +1,111 @@\n-  protected void opReplaceBlock(DataInputStream in,\n-      ExtendedBlock block, String sourceID, DatanodeInfo proxySource,\n-      Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n-    updateCurrentThreadName(\"Replacing block \" + block + \" from \" + sourceID);\n+  public void replaceBlock(final ExtendedBlock block,\n+      final Token\u003cBlockTokenIdentifier\u003e blockToken,\n+      final String delHint,\n+      final DatanodeInfo proxySource) throws IOException {\n+    updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n \n     /* read header */\n     block.setNumBytes(dataXceiverServer.estimateBlockSize);\n     if (datanode.isBlockTokenEnabled) {\n       try {\n         datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n             BlockTokenSecretManager.AccessMode.REPLACE);\n       } catch (InvalidToken e) {\n         LOG.warn(\"Invalid access token in request from \" + remoteAddress\n             + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n             + e.getLocalizedMessage());\n         sendResponse(s, ERROR_ACCESS_TOKEN, datanode.socketWriteTimeout);\n         return;\n       }\n     }\n \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n       LOG.warn(\"Not able to receive block \" + block.getBlockId() + \" from \" \n           + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\");\n       sendResponse(s, ERROR, datanode.socketWriteTimeout);\n       return;\n     }\n \n     Socket proxySock \u003d null;\n     DataOutputStream proxyOut \u003d null;\n     Status opStatus \u003d SUCCESS;\n     BlockReceiver blockReceiver \u003d null;\n     DataInputStream proxyReply \u003d null;\n     \n     try {\n       // get the output stream to the proxy\n       InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(\n           proxySource.getName());\n       proxySock \u003d datanode.newSocket();\n       NetUtils.connect(proxySock, proxyAddr, datanode.socketTimeout);\n       proxySock.setSoTimeout(datanode.socketTimeout);\n \n       OutputStream baseStream \u003d NetUtils.getOutputStream(proxySock, \n           datanode.socketWriteTimeout);\n       proxyOut \u003d new DataOutputStream(\n                      new BufferedOutputStream(baseStream, SMALL_BUFFER_SIZE));\n \n       /* send request to the proxy */\n-      Sender.opCopyBlock(proxyOut, block, blockToken);\n+      new Sender(proxyOut).copyBlock(block, blockToken);\n \n       // receive the response from the proxy\n       proxyReply \u003d new DataInputStream(new BufferedInputStream(\n           NetUtils.getInputStream(proxySock), BUFFER_SIZE));\n       BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n           HdfsProtoUtil.vintPrefixed(proxyReply));\n \n       if (copyResponse.getStatus() !\u003d SUCCESS) {\n         if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n           throw new IOException(\"Copy block \" + block + \" from \"\n               + proxySock.getRemoteSocketAddress()\n               + \" failed due to access token error\");\n         }\n         throw new IOException(\"Copy block \" + block + \" from \"\n             + proxySock.getRemoteSocketAddress() + \" failed\");\n       }\n       // open a block receiver and check if the block does not exist\n       blockReceiver \u003d new BlockReceiver(\n           block, proxyReply, proxySock.getRemoteSocketAddress().toString(),\n           proxySock.getLocalSocketAddress().toString(),\n           null, 0, 0, 0, \"\", null, datanode);\n \n       // receive a block\n       blockReceiver.receiveBlock(null, null, null, null, \n           dataXceiverServer.balanceThrottler, null);\n                     \n       // notify name node\n-      datanode.notifyNamenodeReceivedBlock(block, sourceID);\n+      datanode.notifyNamenodeReceivedBlock(block, delHint);\n \n       LOG.info(\"Moved block \" + block + \n           \" from \" + s.getRemoteSocketAddress());\n       \n     } catch (IOException ioe) {\n       opStatus \u003d ERROR;\n       LOG.info(\"opReplaceBlock \" + block + \" received exception \" + ioe);\n       throw ioe;\n     } finally {\n       // receive the last byte that indicates the proxy released its thread resource\n       if (opStatus \u003d\u003d SUCCESS) {\n         try {\n           proxyReply.readChar();\n         } catch (IOException ignored) {\n         }\n       }\n       \n       // now release the thread resource\n       dataXceiverServer.balanceThrottler.release();\n       \n       // send response back\n       try {\n         sendResponse(s, opStatus, datanode.socketWriteTimeout);\n       } catch (IOException ioe) {\n         LOG.warn(\"Error writing reply back to \" + s.getRemoteSocketAddress());\n       }\n       IOUtils.closeStream(proxyOut);\n       IOUtils.closeStream(blockReceiver);\n       IOUtils.closeStream(proxyReply);\n     }\n \n     //update metrics\n     datanode.metrics.addReplaceBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void replaceBlock(final ExtendedBlock block,\n      final Token\u003cBlockTokenIdentifier\u003e blockToken,\n      final String delHint,\n      final DatanodeInfo proxySource) throws IOException {\n    updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n\n    /* read header */\n    block.setNumBytes(dataXceiverServer.estimateBlockSize);\n    if (datanode.isBlockTokenEnabled) {\n      try {\n        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n            BlockTokenSecretManager.AccessMode.REPLACE);\n      } catch (InvalidToken e) {\n        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n            + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n            + e.getLocalizedMessage());\n        sendResponse(s, ERROR_ACCESS_TOKEN, datanode.socketWriteTimeout);\n        return;\n      }\n    }\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      LOG.warn(\"Not able to receive block \" + block.getBlockId() + \" from \" \n          + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\");\n      sendResponse(s, ERROR, datanode.socketWriteTimeout);\n      return;\n    }\n\n    Socket proxySock \u003d null;\n    DataOutputStream proxyOut \u003d null;\n    Status opStatus \u003d SUCCESS;\n    BlockReceiver blockReceiver \u003d null;\n    DataInputStream proxyReply \u003d null;\n    \n    try {\n      // get the output stream to the proxy\n      InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(\n          proxySource.getName());\n      proxySock \u003d datanode.newSocket();\n      NetUtils.connect(proxySock, proxyAddr, datanode.socketTimeout);\n      proxySock.setSoTimeout(datanode.socketTimeout);\n\n      OutputStream baseStream \u003d NetUtils.getOutputStream(proxySock, \n          datanode.socketWriteTimeout);\n      proxyOut \u003d new DataOutputStream(\n                     new BufferedOutputStream(baseStream, SMALL_BUFFER_SIZE));\n\n      /* send request to the proxy */\n      new Sender(proxyOut).copyBlock(block, blockToken);\n\n      // receive the response from the proxy\n      proxyReply \u003d new DataInputStream(new BufferedInputStream(\n          NetUtils.getInputStream(proxySock), BUFFER_SIZE));\n      BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n          HdfsProtoUtil.vintPrefixed(proxyReply));\n\n      if (copyResponse.getStatus() !\u003d SUCCESS) {\n        if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n          throw new IOException(\"Copy block \" + block + \" from \"\n              + proxySock.getRemoteSocketAddress()\n              + \" failed due to access token error\");\n        }\n        throw new IOException(\"Copy block \" + block + \" from \"\n            + proxySock.getRemoteSocketAddress() + \" failed\");\n      }\n      // open a block receiver and check if the block does not exist\n      blockReceiver \u003d new BlockReceiver(\n          block, proxyReply, proxySock.getRemoteSocketAddress().toString(),\n          proxySock.getLocalSocketAddress().toString(),\n          null, 0, 0, 0, \"\", null, datanode);\n\n      // receive a block\n      blockReceiver.receiveBlock(null, null, null, null, \n          dataXceiverServer.balanceThrottler, null);\n                    \n      // notify name node\n      datanode.notifyNamenodeReceivedBlock(block, delHint);\n\n      LOG.info(\"Moved block \" + block + \n          \" from \" + s.getRemoteSocketAddress());\n      \n    } catch (IOException ioe) {\n      opStatus \u003d ERROR;\n      LOG.info(\"opReplaceBlock \" + block + \" received exception \" + ioe);\n      throw ioe;\n    } finally {\n      // receive the last byte that indicates the proxy released its thread resource\n      if (opStatus \u003d\u003d SUCCESS) {\n        try {\n          proxyReply.readChar();\n        } catch (IOException ignored) {\n        }\n      }\n      \n      // now release the thread resource\n      dataXceiverServer.balanceThrottler.release();\n      \n      // send response back\n      try {\n        sendResponse(s, opStatus, datanode.socketWriteTimeout);\n      } catch (IOException ioe) {\n        LOG.warn(\"Error writing reply back to \" + s.getRemoteSocketAddress());\n      }\n      IOUtils.closeStream(proxyOut);\n      IOUtils.closeStream(blockReceiver);\n      IOUtils.closeStream(proxyReply);\n    }\n\n    //update metrics\n    datanode.metrics.addReplaceBlockOp(elapsed());\n  }",
          "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
          "extendedDetails": {
            "oldValue": "[protected]",
            "newValue": "[public]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-2087. Declare methods in DataTransferProtocol interface, and change Sender and Receiver to implement the interface.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1139124 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "23/06/11 4:57 PM",
          "commitName": "2f48fae72aa52e6ec42264cad24fab36b6a426c2",
          "commitAuthor": "Tsz-wo Sze",
          "commitDateOld": "21/06/11 10:12 AM",
          "commitNameOld": "3f190b3e1acc5ea9e9a03e85a4df0e3f0ab73b9f",
          "commitAuthorOld": "Tsz-wo Sze",
          "daysBetweenCommits": 2.28,
          "commitsBetweenForRepo": 7,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,110 +1,111 @@\n-  protected void opReplaceBlock(DataInputStream in,\n-      ExtendedBlock block, String sourceID, DatanodeInfo proxySource,\n-      Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n-    updateCurrentThreadName(\"Replacing block \" + block + \" from \" + sourceID);\n+  public void replaceBlock(final ExtendedBlock block,\n+      final Token\u003cBlockTokenIdentifier\u003e blockToken,\n+      final String delHint,\n+      final DatanodeInfo proxySource) throws IOException {\n+    updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n \n     /* read header */\n     block.setNumBytes(dataXceiverServer.estimateBlockSize);\n     if (datanode.isBlockTokenEnabled) {\n       try {\n         datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n             BlockTokenSecretManager.AccessMode.REPLACE);\n       } catch (InvalidToken e) {\n         LOG.warn(\"Invalid access token in request from \" + remoteAddress\n             + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n             + e.getLocalizedMessage());\n         sendResponse(s, ERROR_ACCESS_TOKEN, datanode.socketWriteTimeout);\n         return;\n       }\n     }\n \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n       LOG.warn(\"Not able to receive block \" + block.getBlockId() + \" from \" \n           + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\");\n       sendResponse(s, ERROR, datanode.socketWriteTimeout);\n       return;\n     }\n \n     Socket proxySock \u003d null;\n     DataOutputStream proxyOut \u003d null;\n     Status opStatus \u003d SUCCESS;\n     BlockReceiver blockReceiver \u003d null;\n     DataInputStream proxyReply \u003d null;\n     \n     try {\n       // get the output stream to the proxy\n       InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(\n           proxySource.getName());\n       proxySock \u003d datanode.newSocket();\n       NetUtils.connect(proxySock, proxyAddr, datanode.socketTimeout);\n       proxySock.setSoTimeout(datanode.socketTimeout);\n \n       OutputStream baseStream \u003d NetUtils.getOutputStream(proxySock, \n           datanode.socketWriteTimeout);\n       proxyOut \u003d new DataOutputStream(\n                      new BufferedOutputStream(baseStream, SMALL_BUFFER_SIZE));\n \n       /* send request to the proxy */\n-      Sender.opCopyBlock(proxyOut, block, blockToken);\n+      new Sender(proxyOut).copyBlock(block, blockToken);\n \n       // receive the response from the proxy\n       proxyReply \u003d new DataInputStream(new BufferedInputStream(\n           NetUtils.getInputStream(proxySock), BUFFER_SIZE));\n       BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n           HdfsProtoUtil.vintPrefixed(proxyReply));\n \n       if (copyResponse.getStatus() !\u003d SUCCESS) {\n         if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n           throw new IOException(\"Copy block \" + block + \" from \"\n               + proxySock.getRemoteSocketAddress()\n               + \" failed due to access token error\");\n         }\n         throw new IOException(\"Copy block \" + block + \" from \"\n             + proxySock.getRemoteSocketAddress() + \" failed\");\n       }\n       // open a block receiver and check if the block does not exist\n       blockReceiver \u003d new BlockReceiver(\n           block, proxyReply, proxySock.getRemoteSocketAddress().toString(),\n           proxySock.getLocalSocketAddress().toString(),\n           null, 0, 0, 0, \"\", null, datanode);\n \n       // receive a block\n       blockReceiver.receiveBlock(null, null, null, null, \n           dataXceiverServer.balanceThrottler, null);\n                     \n       // notify name node\n-      datanode.notifyNamenodeReceivedBlock(block, sourceID);\n+      datanode.notifyNamenodeReceivedBlock(block, delHint);\n \n       LOG.info(\"Moved block \" + block + \n           \" from \" + s.getRemoteSocketAddress());\n       \n     } catch (IOException ioe) {\n       opStatus \u003d ERROR;\n       LOG.info(\"opReplaceBlock \" + block + \" received exception \" + ioe);\n       throw ioe;\n     } finally {\n       // receive the last byte that indicates the proxy released its thread resource\n       if (opStatus \u003d\u003d SUCCESS) {\n         try {\n           proxyReply.readChar();\n         } catch (IOException ignored) {\n         }\n       }\n       \n       // now release the thread resource\n       dataXceiverServer.balanceThrottler.release();\n       \n       // send response back\n       try {\n         sendResponse(s, opStatus, datanode.socketWriteTimeout);\n       } catch (IOException ioe) {\n         LOG.warn(\"Error writing reply back to \" + s.getRemoteSocketAddress());\n       }\n       IOUtils.closeStream(proxyOut);\n       IOUtils.closeStream(blockReceiver);\n       IOUtils.closeStream(proxyReply);\n     }\n \n     //update metrics\n     datanode.metrics.addReplaceBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void replaceBlock(final ExtendedBlock block,\n      final Token\u003cBlockTokenIdentifier\u003e blockToken,\n      final String delHint,\n      final DatanodeInfo proxySource) throws IOException {\n    updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n\n    /* read header */\n    block.setNumBytes(dataXceiverServer.estimateBlockSize);\n    if (datanode.isBlockTokenEnabled) {\n      try {\n        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n            BlockTokenSecretManager.AccessMode.REPLACE);\n      } catch (InvalidToken e) {\n        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n            + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n            + e.getLocalizedMessage());\n        sendResponse(s, ERROR_ACCESS_TOKEN, datanode.socketWriteTimeout);\n        return;\n      }\n    }\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      LOG.warn(\"Not able to receive block \" + block.getBlockId() + \" from \" \n          + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\");\n      sendResponse(s, ERROR, datanode.socketWriteTimeout);\n      return;\n    }\n\n    Socket proxySock \u003d null;\n    DataOutputStream proxyOut \u003d null;\n    Status opStatus \u003d SUCCESS;\n    BlockReceiver blockReceiver \u003d null;\n    DataInputStream proxyReply \u003d null;\n    \n    try {\n      // get the output stream to the proxy\n      InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(\n          proxySource.getName());\n      proxySock \u003d datanode.newSocket();\n      NetUtils.connect(proxySock, proxyAddr, datanode.socketTimeout);\n      proxySock.setSoTimeout(datanode.socketTimeout);\n\n      OutputStream baseStream \u003d NetUtils.getOutputStream(proxySock, \n          datanode.socketWriteTimeout);\n      proxyOut \u003d new DataOutputStream(\n                     new BufferedOutputStream(baseStream, SMALL_BUFFER_SIZE));\n\n      /* send request to the proxy */\n      new Sender(proxyOut).copyBlock(block, blockToken);\n\n      // receive the response from the proxy\n      proxyReply \u003d new DataInputStream(new BufferedInputStream(\n          NetUtils.getInputStream(proxySock), BUFFER_SIZE));\n      BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n          HdfsProtoUtil.vintPrefixed(proxyReply));\n\n      if (copyResponse.getStatus() !\u003d SUCCESS) {\n        if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n          throw new IOException(\"Copy block \" + block + \" from \"\n              + proxySock.getRemoteSocketAddress()\n              + \" failed due to access token error\");\n        }\n        throw new IOException(\"Copy block \" + block + \" from \"\n            + proxySock.getRemoteSocketAddress() + \" failed\");\n      }\n      // open a block receiver and check if the block does not exist\n      blockReceiver \u003d new BlockReceiver(\n          block, proxyReply, proxySock.getRemoteSocketAddress().toString(),\n          proxySock.getLocalSocketAddress().toString(),\n          null, 0, 0, 0, \"\", null, datanode);\n\n      // receive a block\n      blockReceiver.receiveBlock(null, null, null, null, \n          dataXceiverServer.balanceThrottler, null);\n                    \n      // notify name node\n      datanode.notifyNamenodeReceivedBlock(block, delHint);\n\n      LOG.info(\"Moved block \" + block + \n          \" from \" + s.getRemoteSocketAddress());\n      \n    } catch (IOException ioe) {\n      opStatus \u003d ERROR;\n      LOG.info(\"opReplaceBlock \" + block + \" received exception \" + ioe);\n      throw ioe;\n    } finally {\n      // receive the last byte that indicates the proxy released its thread resource\n      if (opStatus \u003d\u003d SUCCESS) {\n        try {\n          proxyReply.readChar();\n        } catch (IOException ignored) {\n        }\n      }\n      \n      // now release the thread resource\n      dataXceiverServer.balanceThrottler.release();\n      \n      // send response back\n      try {\n        sendResponse(s, opStatus, datanode.socketWriteTimeout);\n      } catch (IOException ioe) {\n        LOG.warn(\"Error writing reply back to \" + s.getRemoteSocketAddress());\n      }\n      IOUtils.closeStream(proxyOut);\n      IOUtils.closeStream(blockReceiver);\n      IOUtils.closeStream(proxyReply);\n    }\n\n    //update metrics\n    datanode.metrics.addReplaceBlockOp(elapsed());\n  }",
          "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
          "extendedDetails": {}
        },
        {
          "type": "Yparametermetachange",
          "commitMessage": "HDFS-2087. Declare methods in DataTransferProtocol interface, and change Sender and Receiver to implement the interface.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1139124 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "23/06/11 4:57 PM",
          "commitName": "2f48fae72aa52e6ec42264cad24fab36b6a426c2",
          "commitAuthor": "Tsz-wo Sze",
          "commitDateOld": "21/06/11 10:12 AM",
          "commitNameOld": "3f190b3e1acc5ea9e9a03e85a4df0e3f0ab73b9f",
          "commitAuthorOld": "Tsz-wo Sze",
          "daysBetweenCommits": 2.28,
          "commitsBetweenForRepo": 7,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,110 +1,111 @@\n-  protected void opReplaceBlock(DataInputStream in,\n-      ExtendedBlock block, String sourceID, DatanodeInfo proxySource,\n-      Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n-    updateCurrentThreadName(\"Replacing block \" + block + \" from \" + sourceID);\n+  public void replaceBlock(final ExtendedBlock block,\n+      final Token\u003cBlockTokenIdentifier\u003e blockToken,\n+      final String delHint,\n+      final DatanodeInfo proxySource) throws IOException {\n+    updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n \n     /* read header */\n     block.setNumBytes(dataXceiverServer.estimateBlockSize);\n     if (datanode.isBlockTokenEnabled) {\n       try {\n         datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n             BlockTokenSecretManager.AccessMode.REPLACE);\n       } catch (InvalidToken e) {\n         LOG.warn(\"Invalid access token in request from \" + remoteAddress\n             + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n             + e.getLocalizedMessage());\n         sendResponse(s, ERROR_ACCESS_TOKEN, datanode.socketWriteTimeout);\n         return;\n       }\n     }\n \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n       LOG.warn(\"Not able to receive block \" + block.getBlockId() + \" from \" \n           + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\");\n       sendResponse(s, ERROR, datanode.socketWriteTimeout);\n       return;\n     }\n \n     Socket proxySock \u003d null;\n     DataOutputStream proxyOut \u003d null;\n     Status opStatus \u003d SUCCESS;\n     BlockReceiver blockReceiver \u003d null;\n     DataInputStream proxyReply \u003d null;\n     \n     try {\n       // get the output stream to the proxy\n       InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(\n           proxySource.getName());\n       proxySock \u003d datanode.newSocket();\n       NetUtils.connect(proxySock, proxyAddr, datanode.socketTimeout);\n       proxySock.setSoTimeout(datanode.socketTimeout);\n \n       OutputStream baseStream \u003d NetUtils.getOutputStream(proxySock, \n           datanode.socketWriteTimeout);\n       proxyOut \u003d new DataOutputStream(\n                      new BufferedOutputStream(baseStream, SMALL_BUFFER_SIZE));\n \n       /* send request to the proxy */\n-      Sender.opCopyBlock(proxyOut, block, blockToken);\n+      new Sender(proxyOut).copyBlock(block, blockToken);\n \n       // receive the response from the proxy\n       proxyReply \u003d new DataInputStream(new BufferedInputStream(\n           NetUtils.getInputStream(proxySock), BUFFER_SIZE));\n       BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n           HdfsProtoUtil.vintPrefixed(proxyReply));\n \n       if (copyResponse.getStatus() !\u003d SUCCESS) {\n         if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n           throw new IOException(\"Copy block \" + block + \" from \"\n               + proxySock.getRemoteSocketAddress()\n               + \" failed due to access token error\");\n         }\n         throw new IOException(\"Copy block \" + block + \" from \"\n             + proxySock.getRemoteSocketAddress() + \" failed\");\n       }\n       // open a block receiver and check if the block does not exist\n       blockReceiver \u003d new BlockReceiver(\n           block, proxyReply, proxySock.getRemoteSocketAddress().toString(),\n           proxySock.getLocalSocketAddress().toString(),\n           null, 0, 0, 0, \"\", null, datanode);\n \n       // receive a block\n       blockReceiver.receiveBlock(null, null, null, null, \n           dataXceiverServer.balanceThrottler, null);\n                     \n       // notify name node\n-      datanode.notifyNamenodeReceivedBlock(block, sourceID);\n+      datanode.notifyNamenodeReceivedBlock(block, delHint);\n \n       LOG.info(\"Moved block \" + block + \n           \" from \" + s.getRemoteSocketAddress());\n       \n     } catch (IOException ioe) {\n       opStatus \u003d ERROR;\n       LOG.info(\"opReplaceBlock \" + block + \" received exception \" + ioe);\n       throw ioe;\n     } finally {\n       // receive the last byte that indicates the proxy released its thread resource\n       if (opStatus \u003d\u003d SUCCESS) {\n         try {\n           proxyReply.readChar();\n         } catch (IOException ignored) {\n         }\n       }\n       \n       // now release the thread resource\n       dataXceiverServer.balanceThrottler.release();\n       \n       // send response back\n       try {\n         sendResponse(s, opStatus, datanode.socketWriteTimeout);\n       } catch (IOException ioe) {\n         LOG.warn(\"Error writing reply back to \" + s.getRemoteSocketAddress());\n       }\n       IOUtils.closeStream(proxyOut);\n       IOUtils.closeStream(blockReceiver);\n       IOUtils.closeStream(proxyReply);\n     }\n \n     //update metrics\n     datanode.metrics.addReplaceBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void replaceBlock(final ExtendedBlock block,\n      final Token\u003cBlockTokenIdentifier\u003e blockToken,\n      final String delHint,\n      final DatanodeInfo proxySource) throws IOException {\n    updateCurrentThreadName(\"Replacing block \" + block + \" from \" + delHint);\n\n    /* read header */\n    block.setNumBytes(dataXceiverServer.estimateBlockSize);\n    if (datanode.isBlockTokenEnabled) {\n      try {\n        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n            BlockTokenSecretManager.AccessMode.REPLACE);\n      } catch (InvalidToken e) {\n        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n            + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n            + e.getLocalizedMessage());\n        sendResponse(s, ERROR_ACCESS_TOKEN, datanode.socketWriteTimeout);\n        return;\n      }\n    }\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      LOG.warn(\"Not able to receive block \" + block.getBlockId() + \" from \" \n          + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\");\n      sendResponse(s, ERROR, datanode.socketWriteTimeout);\n      return;\n    }\n\n    Socket proxySock \u003d null;\n    DataOutputStream proxyOut \u003d null;\n    Status opStatus \u003d SUCCESS;\n    BlockReceiver blockReceiver \u003d null;\n    DataInputStream proxyReply \u003d null;\n    \n    try {\n      // get the output stream to the proxy\n      InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(\n          proxySource.getName());\n      proxySock \u003d datanode.newSocket();\n      NetUtils.connect(proxySock, proxyAddr, datanode.socketTimeout);\n      proxySock.setSoTimeout(datanode.socketTimeout);\n\n      OutputStream baseStream \u003d NetUtils.getOutputStream(proxySock, \n          datanode.socketWriteTimeout);\n      proxyOut \u003d new DataOutputStream(\n                     new BufferedOutputStream(baseStream, SMALL_BUFFER_SIZE));\n\n      /* send request to the proxy */\n      new Sender(proxyOut).copyBlock(block, blockToken);\n\n      // receive the response from the proxy\n      proxyReply \u003d new DataInputStream(new BufferedInputStream(\n          NetUtils.getInputStream(proxySock), BUFFER_SIZE));\n      BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n          HdfsProtoUtil.vintPrefixed(proxyReply));\n\n      if (copyResponse.getStatus() !\u003d SUCCESS) {\n        if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n          throw new IOException(\"Copy block \" + block + \" from \"\n              + proxySock.getRemoteSocketAddress()\n              + \" failed due to access token error\");\n        }\n        throw new IOException(\"Copy block \" + block + \" from \"\n            + proxySock.getRemoteSocketAddress() + \" failed\");\n      }\n      // open a block receiver and check if the block does not exist\n      blockReceiver \u003d new BlockReceiver(\n          block, proxyReply, proxySock.getRemoteSocketAddress().toString(),\n          proxySock.getLocalSocketAddress().toString(),\n          null, 0, 0, 0, \"\", null, datanode);\n\n      // receive a block\n      blockReceiver.receiveBlock(null, null, null, null, \n          dataXceiverServer.balanceThrottler, null);\n                    \n      // notify name node\n      datanode.notifyNamenodeReceivedBlock(block, delHint);\n\n      LOG.info(\"Moved block \" + block + \n          \" from \" + s.getRemoteSocketAddress());\n      \n    } catch (IOException ioe) {\n      opStatus \u003d ERROR;\n      LOG.info(\"opReplaceBlock \" + block + \" received exception \" + ioe);\n      throw ioe;\n    } finally {\n      // receive the last byte that indicates the proxy released its thread resource\n      if (opStatus \u003d\u003d SUCCESS) {\n        try {\n          proxyReply.readChar();\n        } catch (IOException ignored) {\n        }\n      }\n      \n      // now release the thread resource\n      dataXceiverServer.balanceThrottler.release();\n      \n      // send response back\n      try {\n        sendResponse(s, opStatus, datanode.socketWriteTimeout);\n      } catch (IOException ioe) {\n        LOG.warn(\"Error writing reply back to \" + s.getRemoteSocketAddress());\n      }\n      IOUtils.closeStream(proxyOut);\n      IOUtils.closeStream(blockReceiver);\n      IOUtils.closeStream(proxyReply);\n    }\n\n    //update metrics\n    datanode.metrics.addReplaceBlockOp(elapsed());\n  }",
          "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
          "extendedDetails": {
            "oldValue": "[in-DataInputStream, block-ExtendedBlock, sourceID-String, proxySource-DatanodeInfo, blockToken-Token\u003cBlockTokenIdentifier\u003e]",
            "newValue": "[block-ExtendedBlock(modifiers-final), blockToken-Token\u003cBlockTokenIdentifier\u003e(modifiers-final), delHint-String(modifiers-final), proxySource-DatanodeInfo(modifiers-final)]"
          }
        }
      ]
    },
    "3f190b3e1acc5ea9e9a03e85a4df0e3f0ab73b9f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-1568. Improve the log messages in DataXceiver.  Contributed by Joey Echeverria\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1138098 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/06/11 10:12 AM",
      "commitName": "3f190b3e1acc5ea9e9a03e85a4df0e3f0ab73b9f",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "15/06/11 2:36 PM",
      "commitNameOld": "6a3963cc8b4cdadf6dc8d2a9ca4f3af4da50a1d2",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 5.82,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,109 +1,110 @@\n   protected void opReplaceBlock(DataInputStream in,\n       ExtendedBlock block, String sourceID, DatanodeInfo proxySource,\n       Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n     updateCurrentThreadName(\"Replacing block \" + block + \" from \" + sourceID);\n \n     /* read header */\n     block.setNumBytes(dataXceiverServer.estimateBlockSize);\n     if (datanode.isBlockTokenEnabled) {\n       try {\n         datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n             BlockTokenSecretManager.AccessMode.REPLACE);\n       } catch (InvalidToken e) {\n         LOG.warn(\"Invalid access token in request from \" + remoteAddress\n             + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n             + e.getLocalizedMessage());\n         sendResponse(s, ERROR_ACCESS_TOKEN, datanode.socketWriteTimeout);\n         return;\n       }\n     }\n \n     if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n       LOG.warn(\"Not able to receive block \" + block.getBlockId() + \" from \" \n           + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\");\n       sendResponse(s, ERROR, datanode.socketWriteTimeout);\n       return;\n     }\n \n     Socket proxySock \u003d null;\n     DataOutputStream proxyOut \u003d null;\n     Status opStatus \u003d SUCCESS;\n     BlockReceiver blockReceiver \u003d null;\n     DataInputStream proxyReply \u003d null;\n     \n     try {\n       // get the output stream to the proxy\n       InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(\n           proxySource.getName());\n       proxySock \u003d datanode.newSocket();\n       NetUtils.connect(proxySock, proxyAddr, datanode.socketTimeout);\n       proxySock.setSoTimeout(datanode.socketTimeout);\n \n       OutputStream baseStream \u003d NetUtils.getOutputStream(proxySock, \n           datanode.socketWriteTimeout);\n       proxyOut \u003d new DataOutputStream(\n                      new BufferedOutputStream(baseStream, SMALL_BUFFER_SIZE));\n \n       /* send request to the proxy */\n       Sender.opCopyBlock(proxyOut, block, blockToken);\n \n       // receive the response from the proxy\n       proxyReply \u003d new DataInputStream(new BufferedInputStream(\n           NetUtils.getInputStream(proxySock), BUFFER_SIZE));\n       BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n           HdfsProtoUtil.vintPrefixed(proxyReply));\n \n       if (copyResponse.getStatus() !\u003d SUCCESS) {\n         if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n           throw new IOException(\"Copy block \" + block + \" from \"\n               + proxySock.getRemoteSocketAddress()\n               + \" failed due to access token error\");\n         }\n         throw new IOException(\"Copy block \" + block + \" from \"\n             + proxySock.getRemoteSocketAddress() + \" failed\");\n       }\n       // open a block receiver and check if the block does not exist\n       blockReceiver \u003d new BlockReceiver(\n           block, proxyReply, proxySock.getRemoteSocketAddress().toString(),\n           proxySock.getLocalSocketAddress().toString(),\n           null, 0, 0, 0, \"\", null, datanode);\n \n       // receive a block\n       blockReceiver.receiveBlock(null, null, null, null, \n           dataXceiverServer.balanceThrottler, null);\n                     \n       // notify name node\n       datanode.notifyNamenodeReceivedBlock(block, sourceID);\n \n       LOG.info(\"Moved block \" + block + \n           \" from \" + s.getRemoteSocketAddress());\n       \n     } catch (IOException ioe) {\n       opStatus \u003d ERROR;\n+      LOG.info(\"opReplaceBlock \" + block + \" received exception \" + ioe);\n       throw ioe;\n     } finally {\n       // receive the last byte that indicates the proxy released its thread resource\n       if (opStatus \u003d\u003d SUCCESS) {\n         try {\n           proxyReply.readChar();\n         } catch (IOException ignored) {\n         }\n       }\n       \n       // now release the thread resource\n       dataXceiverServer.balanceThrottler.release();\n       \n       // send response back\n       try {\n         sendResponse(s, opStatus, datanode.socketWriteTimeout);\n       } catch (IOException ioe) {\n         LOG.warn(\"Error writing reply back to \" + s.getRemoteSocketAddress());\n       }\n       IOUtils.closeStream(proxyOut);\n       IOUtils.closeStream(blockReceiver);\n       IOUtils.closeStream(proxyReply);\n     }\n \n     //update metrics\n     datanode.metrics.addReplaceBlockOp(elapsed());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void opReplaceBlock(DataInputStream in,\n      ExtendedBlock block, String sourceID, DatanodeInfo proxySource,\n      Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n    updateCurrentThreadName(\"Replacing block \" + block + \" from \" + sourceID);\n\n    /* read header */\n    block.setNumBytes(dataXceiverServer.estimateBlockSize);\n    if (datanode.isBlockTokenEnabled) {\n      try {\n        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n            BlockTokenSecretManager.AccessMode.REPLACE);\n      } catch (InvalidToken e) {\n        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n            + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n            + e.getLocalizedMessage());\n        sendResponse(s, ERROR_ACCESS_TOKEN, datanode.socketWriteTimeout);\n        return;\n      }\n    }\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      LOG.warn(\"Not able to receive block \" + block.getBlockId() + \" from \" \n          + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\");\n      sendResponse(s, ERROR, datanode.socketWriteTimeout);\n      return;\n    }\n\n    Socket proxySock \u003d null;\n    DataOutputStream proxyOut \u003d null;\n    Status opStatus \u003d SUCCESS;\n    BlockReceiver blockReceiver \u003d null;\n    DataInputStream proxyReply \u003d null;\n    \n    try {\n      // get the output stream to the proxy\n      InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(\n          proxySource.getName());\n      proxySock \u003d datanode.newSocket();\n      NetUtils.connect(proxySock, proxyAddr, datanode.socketTimeout);\n      proxySock.setSoTimeout(datanode.socketTimeout);\n\n      OutputStream baseStream \u003d NetUtils.getOutputStream(proxySock, \n          datanode.socketWriteTimeout);\n      proxyOut \u003d new DataOutputStream(\n                     new BufferedOutputStream(baseStream, SMALL_BUFFER_SIZE));\n\n      /* send request to the proxy */\n      Sender.opCopyBlock(proxyOut, block, blockToken);\n\n      // receive the response from the proxy\n      proxyReply \u003d new DataInputStream(new BufferedInputStream(\n          NetUtils.getInputStream(proxySock), BUFFER_SIZE));\n      BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n          HdfsProtoUtil.vintPrefixed(proxyReply));\n\n      if (copyResponse.getStatus() !\u003d SUCCESS) {\n        if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n          throw new IOException(\"Copy block \" + block + \" from \"\n              + proxySock.getRemoteSocketAddress()\n              + \" failed due to access token error\");\n        }\n        throw new IOException(\"Copy block \" + block + \" from \"\n            + proxySock.getRemoteSocketAddress() + \" failed\");\n      }\n      // open a block receiver and check if the block does not exist\n      blockReceiver \u003d new BlockReceiver(\n          block, proxyReply, proxySock.getRemoteSocketAddress().toString(),\n          proxySock.getLocalSocketAddress().toString(),\n          null, 0, 0, 0, \"\", null, datanode);\n\n      // receive a block\n      blockReceiver.receiveBlock(null, null, null, null, \n          dataXceiverServer.balanceThrottler, null);\n                    \n      // notify name node\n      datanode.notifyNamenodeReceivedBlock(block, sourceID);\n\n      LOG.info(\"Moved block \" + block + \n          \" from \" + s.getRemoteSocketAddress());\n      \n    } catch (IOException ioe) {\n      opStatus \u003d ERROR;\n      LOG.info(\"opReplaceBlock \" + block + \" received exception \" + ioe);\n      throw ioe;\n    } finally {\n      // receive the last byte that indicates the proxy released its thread resource\n      if (opStatus \u003d\u003d SUCCESS) {\n        try {\n          proxyReply.readChar();\n        } catch (IOException ignored) {\n        }\n      }\n      \n      // now release the thread resource\n      dataXceiverServer.balanceThrottler.release();\n      \n      // send response back\n      try {\n        sendResponse(s, opStatus, datanode.socketWriteTimeout);\n      } catch (IOException ioe) {\n        LOG.warn(\"Error writing reply back to \" + s.getRemoteSocketAddress());\n      }\n      IOUtils.closeStream(proxyOut);\n      IOUtils.closeStream(blockReceiver);\n      IOUtils.closeStream(proxyReply);\n    }\n\n    //update metrics\n    datanode.metrics.addReplaceBlockOp(elapsed());\n  }",
      "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java",
      "extendedDetails": {}
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "diff": "@@ -0,0 +1,109 @@\n+  protected void opReplaceBlock(DataInputStream in,\n+      ExtendedBlock block, String sourceID, DatanodeInfo proxySource,\n+      Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n+    updateCurrentThreadName(\"Replacing block \" + block + \" from \" + sourceID);\n+\n+    /* read header */\n+    block.setNumBytes(dataXceiverServer.estimateBlockSize);\n+    if (datanode.isBlockTokenEnabled) {\n+      try {\n+        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n+            BlockTokenSecretManager.AccessMode.REPLACE);\n+      } catch (InvalidToken e) {\n+        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n+            + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n+            + e.getLocalizedMessage());\n+        sendResponse(s, ERROR_ACCESS_TOKEN, datanode.socketWriteTimeout);\n+        return;\n+      }\n+    }\n+\n+    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n+      LOG.warn(\"Not able to receive block \" + block.getBlockId() + \" from \" \n+          + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\");\n+      sendResponse(s, ERROR, datanode.socketWriteTimeout);\n+      return;\n+    }\n+\n+    Socket proxySock \u003d null;\n+    DataOutputStream proxyOut \u003d null;\n+    Status opStatus \u003d SUCCESS;\n+    BlockReceiver blockReceiver \u003d null;\n+    DataInputStream proxyReply \u003d null;\n+    \n+    try {\n+      // get the output stream to the proxy\n+      InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(\n+          proxySource.getName());\n+      proxySock \u003d datanode.newSocket();\n+      NetUtils.connect(proxySock, proxyAddr, datanode.socketTimeout);\n+      proxySock.setSoTimeout(datanode.socketTimeout);\n+\n+      OutputStream baseStream \u003d NetUtils.getOutputStream(proxySock, \n+          datanode.socketWriteTimeout);\n+      proxyOut \u003d new DataOutputStream(\n+                     new BufferedOutputStream(baseStream, SMALL_BUFFER_SIZE));\n+\n+      /* send request to the proxy */\n+      Sender.opCopyBlock(proxyOut, block, blockToken);\n+\n+      // receive the response from the proxy\n+      proxyReply \u003d new DataInputStream(new BufferedInputStream(\n+          NetUtils.getInputStream(proxySock), BUFFER_SIZE));\n+      BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n+          HdfsProtoUtil.vintPrefixed(proxyReply));\n+\n+      if (copyResponse.getStatus() !\u003d SUCCESS) {\n+        if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n+          throw new IOException(\"Copy block \" + block + \" from \"\n+              + proxySock.getRemoteSocketAddress()\n+              + \" failed due to access token error\");\n+        }\n+        throw new IOException(\"Copy block \" + block + \" from \"\n+            + proxySock.getRemoteSocketAddress() + \" failed\");\n+      }\n+      // open a block receiver and check if the block does not exist\n+      blockReceiver \u003d new BlockReceiver(\n+          block, proxyReply, proxySock.getRemoteSocketAddress().toString(),\n+          proxySock.getLocalSocketAddress().toString(),\n+          null, 0, 0, 0, \"\", null, datanode);\n+\n+      // receive a block\n+      blockReceiver.receiveBlock(null, null, null, null, \n+          dataXceiverServer.balanceThrottler, null);\n+                    \n+      // notify name node\n+      datanode.notifyNamenodeReceivedBlock(block, sourceID);\n+\n+      LOG.info(\"Moved block \" + block + \n+          \" from \" + s.getRemoteSocketAddress());\n+      \n+    } catch (IOException ioe) {\n+      opStatus \u003d ERROR;\n+      throw ioe;\n+    } finally {\n+      // receive the last byte that indicates the proxy released its thread resource\n+      if (opStatus \u003d\u003d SUCCESS) {\n+        try {\n+          proxyReply.readChar();\n+        } catch (IOException ignored) {\n+        }\n+      }\n+      \n+      // now release the thread resource\n+      dataXceiverServer.balanceThrottler.release();\n+      \n+      // send response back\n+      try {\n+        sendResponse(s, opStatus, datanode.socketWriteTimeout);\n+      } catch (IOException ioe) {\n+        LOG.warn(\"Error writing reply back to \" + s.getRemoteSocketAddress());\n+      }\n+      IOUtils.closeStream(proxyOut);\n+      IOUtils.closeStream(blockReceiver);\n+      IOUtils.closeStream(proxyReply);\n+    }\n+\n+    //update metrics\n+    datanode.metrics.addReplaceBlockOp(elapsed());\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  protected void opReplaceBlock(DataInputStream in,\n      ExtendedBlock block, String sourceID, DatanodeInfo proxySource,\n      Token\u003cBlockTokenIdentifier\u003e blockToken) throws IOException {\n    updateCurrentThreadName(\"Replacing block \" + block + \" from \" + sourceID);\n\n    /* read header */\n    block.setNumBytes(dataXceiverServer.estimateBlockSize);\n    if (datanode.isBlockTokenEnabled) {\n      try {\n        datanode.blockPoolTokenSecretManager.checkAccess(blockToken, null, block,\n            BlockTokenSecretManager.AccessMode.REPLACE);\n      } catch (InvalidToken e) {\n        LOG.warn(\"Invalid access token in request from \" + remoteAddress\n            + \" for OP_REPLACE_BLOCK for block \" + block + \" : \"\n            + e.getLocalizedMessage());\n        sendResponse(s, ERROR_ACCESS_TOKEN, datanode.socketWriteTimeout);\n        return;\n      }\n    }\n\n    if (!dataXceiverServer.balanceThrottler.acquire()) { // not able to start\n      LOG.warn(\"Not able to receive block \" + block.getBlockId() + \" from \" \n          + s.getRemoteSocketAddress() + \" because threads quota is exceeded.\");\n      sendResponse(s, ERROR, datanode.socketWriteTimeout);\n      return;\n    }\n\n    Socket proxySock \u003d null;\n    DataOutputStream proxyOut \u003d null;\n    Status opStatus \u003d SUCCESS;\n    BlockReceiver blockReceiver \u003d null;\n    DataInputStream proxyReply \u003d null;\n    \n    try {\n      // get the output stream to the proxy\n      InetSocketAddress proxyAddr \u003d NetUtils.createSocketAddr(\n          proxySource.getName());\n      proxySock \u003d datanode.newSocket();\n      NetUtils.connect(proxySock, proxyAddr, datanode.socketTimeout);\n      proxySock.setSoTimeout(datanode.socketTimeout);\n\n      OutputStream baseStream \u003d NetUtils.getOutputStream(proxySock, \n          datanode.socketWriteTimeout);\n      proxyOut \u003d new DataOutputStream(\n                     new BufferedOutputStream(baseStream, SMALL_BUFFER_SIZE));\n\n      /* send request to the proxy */\n      Sender.opCopyBlock(proxyOut, block, blockToken);\n\n      // receive the response from the proxy\n      proxyReply \u003d new DataInputStream(new BufferedInputStream(\n          NetUtils.getInputStream(proxySock), BUFFER_SIZE));\n      BlockOpResponseProto copyResponse \u003d BlockOpResponseProto.parseFrom(\n          HdfsProtoUtil.vintPrefixed(proxyReply));\n\n      if (copyResponse.getStatus() !\u003d SUCCESS) {\n        if (copyResponse.getStatus() \u003d\u003d ERROR_ACCESS_TOKEN) {\n          throw new IOException(\"Copy block \" + block + \" from \"\n              + proxySock.getRemoteSocketAddress()\n              + \" failed due to access token error\");\n        }\n        throw new IOException(\"Copy block \" + block + \" from \"\n            + proxySock.getRemoteSocketAddress() + \" failed\");\n      }\n      // open a block receiver and check if the block does not exist\n      blockReceiver \u003d new BlockReceiver(\n          block, proxyReply, proxySock.getRemoteSocketAddress().toString(),\n          proxySock.getLocalSocketAddress().toString(),\n          null, 0, 0, 0, \"\", null, datanode);\n\n      // receive a block\n      blockReceiver.receiveBlock(null, null, null, null, \n          dataXceiverServer.balanceThrottler, null);\n                    \n      // notify name node\n      datanode.notifyNamenodeReceivedBlock(block, sourceID);\n\n      LOG.info(\"Moved block \" + block + \n          \" from \" + s.getRemoteSocketAddress());\n      \n    } catch (IOException ioe) {\n      opStatus \u003d ERROR;\n      throw ioe;\n    } finally {\n      // receive the last byte that indicates the proxy released its thread resource\n      if (opStatus \u003d\u003d SUCCESS) {\n        try {\n          proxyReply.readChar();\n        } catch (IOException ignored) {\n        }\n      }\n      \n      // now release the thread resource\n      dataXceiverServer.balanceThrottler.release();\n      \n      // send response back\n      try {\n        sendResponse(s, opStatus, datanode.socketWriteTimeout);\n      } catch (IOException ioe) {\n        LOG.warn(\"Error writing reply back to \" + s.getRemoteSocketAddress());\n      }\n      IOUtils.closeStream(proxyOut);\n      IOUtils.closeStream(blockReceiver);\n      IOUtils.closeStream(proxyReply);\n    }\n\n    //update metrics\n    datanode.metrics.addReplaceBlockOp(elapsed());\n  }",
      "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/datanode/DataXceiver.java"
    }
  }
}