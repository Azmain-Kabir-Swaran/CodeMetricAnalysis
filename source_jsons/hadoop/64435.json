{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "S3AInputStream.java",
  "functionName": "seekInStream",
  "functionId": "seekInStream___targetPos-long__length-long",
  "sourceFilePath": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AInputStream.java",
  "functionStartLine": 265,
  "functionEndLine": 330,
  "numCommitsSeen": 28,
  "timeTaken": 2122,
  "changeHistory": [
    "0cbe9ad8c23d3fd2ac8ac423b6d2df68de720981",
    "1ba491ff907fc5d2618add980734a3534e2be098",
    "c6a39232456fa0c98b2b9b6dbeaec762294ca01e",
    "4ee3543625c77c06d566fe81644d21c607d6d74d",
    "27c4e90efce04e1b1302f668b5eb22412e00d033",
    "b9e3eff62a7415d8666656a75db69ff3e43f8e7e"
  ],
  "changeHistoryShort": {
    "0cbe9ad8c23d3fd2ac8ac423b6d2df68de720981": "Ybodychange",
    "1ba491ff907fc5d2618add980734a3534e2be098": "Ybodychange",
    "c6a39232456fa0c98b2b9b6dbeaec762294ca01e": "Ybodychange",
    "4ee3543625c77c06d566fe81644d21c607d6d74d": "Ybodychange",
    "27c4e90efce04e1b1302f668b5eb22412e00d033": "Ybodychange",
    "b9e3eff62a7415d8666656a75db69ff3e43f8e7e": "Yintroduced"
  },
  "changeHistoryDetails": {
    "0cbe9ad8c23d3fd2ac8ac423b6d2df68de720981": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16109. Parquet reading S3AFileSystem causes EOF\n\nNobody gets seek right. No matter how many times they think they have.\n\nReproducible test from: Dave Christianson\nFixed seek() logic: Steve Loughran\n",
      "commitDate": "09/03/19 8:00 AM",
      "commitName": "0cbe9ad8c23d3fd2ac8ac423b6d2df68de720981",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "05/02/19 3:51 AM",
      "commitNameOld": "f365957c6326f88734bc0a5d01cfb7eac713db20",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 32.17,
      "commitsBetweenForRepo": 287,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,66 @@\n   private void seekInStream(long targetPos, long length) throws IOException {\n     checkNotClosed();\n     if (wrappedStream \u003d\u003d null) {\n       return;\n     }\n     // compute how much more to skip\n     long diff \u003d targetPos - pos;\n     if (diff \u003e 0) {\n       // forward seek -this is where data can be skipped\n \n       int available \u003d wrappedStream.available();\n       // always seek at least as far as what is available\n       long forwardSeekRange \u003d Math.max(readahead, available);\n       // work out how much is actually left in the stream\n       // then choose whichever comes first: the range or the EOF\n       long remainingInCurrentRequest \u003d remainingInCurrentRequest();\n \n       long forwardSeekLimit \u003d Math.min(remainingInCurrentRequest,\n           forwardSeekRange);\n       boolean skipForward \u003d remainingInCurrentRequest \u003e 0\n-          \u0026\u0026 diff \u003c\u003d forwardSeekLimit;\n+          \u0026\u0026 diff \u003c forwardSeekLimit;\n       if (skipForward) {\n         // the forward seek range is within the limits\n         LOG.debug(\"Forward seek on {}, of {} bytes\", uri, diff);\n         streamStatistics.seekForwards(diff);\n         long skipped \u003d wrappedStream.skip(diff);\n         if (skipped \u003e 0) {\n           pos +\u003d skipped;\n           // as these bytes have been read, they are included in the counter\n           incrementBytesRead(diff);\n         }\n \n         if (pos \u003d\u003d targetPos) {\n           // all is well\n+          LOG.debug(\"Now at {}: bytes remaining in current request: {}\",\n+              pos, remainingInCurrentRequest());\n           return;\n         } else {\n           // log a warning; continue to attempt to re-open\n           LOG.warn(\"Failed to seek on {} to {}. Current position {}\",\n               uri, targetPos,  pos);\n         }\n       }\n     } else if (diff \u003c 0) {\n       // backwards seek\n       streamStatistics.seekBackwards(diff);\n       // if the stream is in \"Normal\" mode, switch to random IO at this\n       // point, as it is indicative of columnar format IO\n       if (inputPolicy.equals(S3AInputPolicy.Normal)) {\n         LOG.info(\"Switching to Random IO seek policy\");\n         setInputPolicy(S3AInputPolicy.Random);\n       }\n     } else {\n       // targetPos \u003d\u003d pos\n       if (remainingInCurrentRequest() \u003e 0) {\n         // if there is data left in the stream, keep going\n         return;\n       }\n \n     }\n \n     // if the code reaches here, the stream needs to be reopened.\n     // close the stream; if read the object will be opened at the new pos\n     closeStream(\"seekInStream()\", this.contentRangeFinish, false);\n     pos \u003d targetPos;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void seekInStream(long targetPos, long length) throws IOException {\n    checkNotClosed();\n    if (wrappedStream \u003d\u003d null) {\n      return;\n    }\n    // compute how much more to skip\n    long diff \u003d targetPos - pos;\n    if (diff \u003e 0) {\n      // forward seek -this is where data can be skipped\n\n      int available \u003d wrappedStream.available();\n      // always seek at least as far as what is available\n      long forwardSeekRange \u003d Math.max(readahead, available);\n      // work out how much is actually left in the stream\n      // then choose whichever comes first: the range or the EOF\n      long remainingInCurrentRequest \u003d remainingInCurrentRequest();\n\n      long forwardSeekLimit \u003d Math.min(remainingInCurrentRequest,\n          forwardSeekRange);\n      boolean skipForward \u003d remainingInCurrentRequest \u003e 0\n          \u0026\u0026 diff \u003c forwardSeekLimit;\n      if (skipForward) {\n        // the forward seek range is within the limits\n        LOG.debug(\"Forward seek on {}, of {} bytes\", uri, diff);\n        streamStatistics.seekForwards(diff);\n        long skipped \u003d wrappedStream.skip(diff);\n        if (skipped \u003e 0) {\n          pos +\u003d skipped;\n          // as these bytes have been read, they are included in the counter\n          incrementBytesRead(diff);\n        }\n\n        if (pos \u003d\u003d targetPos) {\n          // all is well\n          LOG.debug(\"Now at {}: bytes remaining in current request: {}\",\n              pos, remainingInCurrentRequest());\n          return;\n        } else {\n          // log a warning; continue to attempt to re-open\n          LOG.warn(\"Failed to seek on {} to {}. Current position {}\",\n              uri, targetPos,  pos);\n        }\n      }\n    } else if (diff \u003c 0) {\n      // backwards seek\n      streamStatistics.seekBackwards(diff);\n      // if the stream is in \"Normal\" mode, switch to random IO at this\n      // point, as it is indicative of columnar format IO\n      if (inputPolicy.equals(S3AInputPolicy.Normal)) {\n        LOG.info(\"Switching to Random IO seek policy\");\n        setInputPolicy(S3AInputPolicy.Random);\n      }\n    } else {\n      // targetPos \u003d\u003d pos\n      if (remainingInCurrentRequest() \u003e 0) {\n        // if there is data left in the stream, keep going\n        return;\n      }\n\n    }\n\n    // if the code reaches here, the stream needs to be reopened.\n    // close the stream; if read the object will be opened at the new pos\n    closeStream(\"seekInStream()\", this.contentRangeFinish, false);\n    pos \u003d targetPos;\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AInputStream.java",
      "extendedDetails": {}
    },
    "1ba491ff907fc5d2618add980734a3534e2be098": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14965. S3a input stream \"normal\" fadvise mode to be adaptive\n",
      "commitDate": "20/12/17 10:25 AM",
      "commitName": "1ba491ff907fc5d2618add980734a3534e2be098",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "22/11/17 7:28 AM",
      "commitNameOld": "de8b6ca5ef8614de6d6277b7617e27c788b0555c",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 28.12,
      "commitsBetweenForRepo": 198,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,58 +1,64 @@\n   private void seekInStream(long targetPos, long length) throws IOException {\n     checkNotClosed();\n     if (wrappedStream \u003d\u003d null) {\n       return;\n     }\n     // compute how much more to skip\n     long diff \u003d targetPos - pos;\n     if (diff \u003e 0) {\n       // forward seek -this is where data can be skipped\n \n       int available \u003d wrappedStream.available();\n       // always seek at least as far as what is available\n       long forwardSeekRange \u003d Math.max(readahead, available);\n       // work out how much is actually left in the stream\n       // then choose whichever comes first: the range or the EOF\n       long remainingInCurrentRequest \u003d remainingInCurrentRequest();\n \n       long forwardSeekLimit \u003d Math.min(remainingInCurrentRequest,\n           forwardSeekRange);\n       boolean skipForward \u003d remainingInCurrentRequest \u003e 0\n           \u0026\u0026 diff \u003c\u003d forwardSeekLimit;\n       if (skipForward) {\n         // the forward seek range is within the limits\n         LOG.debug(\"Forward seek on {}, of {} bytes\", uri, diff);\n         streamStatistics.seekForwards(diff);\n         long skipped \u003d wrappedStream.skip(diff);\n         if (skipped \u003e 0) {\n           pos +\u003d skipped;\n           // as these bytes have been read, they are included in the counter\n           incrementBytesRead(diff);\n         }\n \n         if (pos \u003d\u003d targetPos) {\n           // all is well\n           return;\n         } else {\n           // log a warning; continue to attempt to re-open\n           LOG.warn(\"Failed to seek on {} to {}. Current position {}\",\n               uri, targetPos,  pos);\n         }\n       }\n     } else if (diff \u003c 0) {\n       // backwards seek\n       streamStatistics.seekBackwards(diff);\n+      // if the stream is in \"Normal\" mode, switch to random IO at this\n+      // point, as it is indicative of columnar format IO\n+      if (inputPolicy.equals(S3AInputPolicy.Normal)) {\n+        LOG.info(\"Switching to Random IO seek policy\");\n+        setInputPolicy(S3AInputPolicy.Random);\n+      }\n     } else {\n       // targetPos \u003d\u003d pos\n       if (remainingInCurrentRequest() \u003e 0) {\n         // if there is data left in the stream, keep going\n         return;\n       }\n \n     }\n \n     // if the code reaches here, the stream needs to be reopened.\n     // close the stream; if read the object will be opened at the new pos\n     closeStream(\"seekInStream()\", this.contentRangeFinish, false);\n     pos \u003d targetPos;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void seekInStream(long targetPos, long length) throws IOException {\n    checkNotClosed();\n    if (wrappedStream \u003d\u003d null) {\n      return;\n    }\n    // compute how much more to skip\n    long diff \u003d targetPos - pos;\n    if (diff \u003e 0) {\n      // forward seek -this is where data can be skipped\n\n      int available \u003d wrappedStream.available();\n      // always seek at least as far as what is available\n      long forwardSeekRange \u003d Math.max(readahead, available);\n      // work out how much is actually left in the stream\n      // then choose whichever comes first: the range or the EOF\n      long remainingInCurrentRequest \u003d remainingInCurrentRequest();\n\n      long forwardSeekLimit \u003d Math.min(remainingInCurrentRequest,\n          forwardSeekRange);\n      boolean skipForward \u003d remainingInCurrentRequest \u003e 0\n          \u0026\u0026 diff \u003c\u003d forwardSeekLimit;\n      if (skipForward) {\n        // the forward seek range is within the limits\n        LOG.debug(\"Forward seek on {}, of {} bytes\", uri, diff);\n        streamStatistics.seekForwards(diff);\n        long skipped \u003d wrappedStream.skip(diff);\n        if (skipped \u003e 0) {\n          pos +\u003d skipped;\n          // as these bytes have been read, they are included in the counter\n          incrementBytesRead(diff);\n        }\n\n        if (pos \u003d\u003d targetPos) {\n          // all is well\n          return;\n        } else {\n          // log a warning; continue to attempt to re-open\n          LOG.warn(\"Failed to seek on {} to {}. Current position {}\",\n              uri, targetPos,  pos);\n        }\n      }\n    } else if (diff \u003c 0) {\n      // backwards seek\n      streamStatistics.seekBackwards(diff);\n      // if the stream is in \"Normal\" mode, switch to random IO at this\n      // point, as it is indicative of columnar format IO\n      if (inputPolicy.equals(S3AInputPolicy.Normal)) {\n        LOG.info(\"Switching to Random IO seek policy\");\n        setInputPolicy(S3AInputPolicy.Random);\n      }\n    } else {\n      // targetPos \u003d\u003d pos\n      if (remainingInCurrentRequest() \u003e 0) {\n        // if there is data left in the stream, keep going\n        return;\n      }\n\n    }\n\n    // if the code reaches here, the stream needs to be reopened.\n    // close the stream; if read the object will be opened at the new pos\n    closeStream(\"seekInStream()\", this.contentRangeFinish, false);\n    pos \u003d targetPos;\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AInputStream.java",
      "extendedDetails": {}
    },
    "c6a39232456fa0c98b2b9b6dbeaec762294ca01e": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13871. ITestS3AInputStreamPerformance.testTimeToOpenAndReadWholeFileBlocks performance awful. Contributed by Steve Loughran\n",
      "commitDate": "12/12/16 2:55 PM",
      "commitName": "c6a39232456fa0c98b2b9b6dbeaec762294ca01e",
      "commitAuthor": "Mingliang Liu",
      "commitDateOld": "06/09/16 9:36 AM",
      "commitNameOld": "d152557cf7f4d2288524c222fcbaf152bdc038b0",
      "commitAuthorOld": "Chris Nauroth",
      "daysBetweenCommits": 97.26,
      "commitsBetweenForRepo": 728,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,58 +1,58 @@\n   private void seekInStream(long targetPos, long length) throws IOException {\n     checkNotClosed();\n     if (wrappedStream \u003d\u003d null) {\n       return;\n     }\n     // compute how much more to skip\n     long diff \u003d targetPos - pos;\n     if (diff \u003e 0) {\n       // forward seek -this is where data can be skipped\n \n       int available \u003d wrappedStream.available();\n       // always seek at least as far as what is available\n       long forwardSeekRange \u003d Math.max(readahead, available);\n       // work out how much is actually left in the stream\n       // then choose whichever comes first: the range or the EOF\n       long remainingInCurrentRequest \u003d remainingInCurrentRequest();\n \n       long forwardSeekLimit \u003d Math.min(remainingInCurrentRequest,\n           forwardSeekRange);\n       boolean skipForward \u003d remainingInCurrentRequest \u003e 0\n           \u0026\u0026 diff \u003c\u003d forwardSeekLimit;\n       if (skipForward) {\n         // the forward seek range is within the limits\n         LOG.debug(\"Forward seek on {}, of {} bytes\", uri, diff);\n         streamStatistics.seekForwards(diff);\n         long skipped \u003d wrappedStream.skip(diff);\n         if (skipped \u003e 0) {\n           pos +\u003d skipped;\n           // as these bytes have been read, they are included in the counter\n           incrementBytesRead(diff);\n         }\n \n         if (pos \u003d\u003d targetPos) {\n           // all is well\n           return;\n         } else {\n           // log a warning; continue to attempt to re-open\n           LOG.warn(\"Failed to seek on {} to {}. Current position {}\",\n               uri, targetPos,  pos);\n         }\n       }\n     } else if (diff \u003c 0) {\n       // backwards seek\n       streamStatistics.seekBackwards(diff);\n     } else {\n       // targetPos \u003d\u003d pos\n       if (remainingInCurrentRequest() \u003e 0) {\n         // if there is data left in the stream, keep going\n         return;\n       }\n \n     }\n \n     // if the code reaches here, the stream needs to be reopened.\n     // close the stream; if read the object will be opened at the new pos\n-    closeStream(\"seekInStream()\", this.contentRangeFinish);\n+    closeStream(\"seekInStream()\", this.contentRangeFinish, false);\n     pos \u003d targetPos;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void seekInStream(long targetPos, long length) throws IOException {\n    checkNotClosed();\n    if (wrappedStream \u003d\u003d null) {\n      return;\n    }\n    // compute how much more to skip\n    long diff \u003d targetPos - pos;\n    if (diff \u003e 0) {\n      // forward seek -this is where data can be skipped\n\n      int available \u003d wrappedStream.available();\n      // always seek at least as far as what is available\n      long forwardSeekRange \u003d Math.max(readahead, available);\n      // work out how much is actually left in the stream\n      // then choose whichever comes first: the range or the EOF\n      long remainingInCurrentRequest \u003d remainingInCurrentRequest();\n\n      long forwardSeekLimit \u003d Math.min(remainingInCurrentRequest,\n          forwardSeekRange);\n      boolean skipForward \u003d remainingInCurrentRequest \u003e 0\n          \u0026\u0026 diff \u003c\u003d forwardSeekLimit;\n      if (skipForward) {\n        // the forward seek range is within the limits\n        LOG.debug(\"Forward seek on {}, of {} bytes\", uri, diff);\n        streamStatistics.seekForwards(diff);\n        long skipped \u003d wrappedStream.skip(diff);\n        if (skipped \u003e 0) {\n          pos +\u003d skipped;\n          // as these bytes have been read, they are included in the counter\n          incrementBytesRead(diff);\n        }\n\n        if (pos \u003d\u003d targetPos) {\n          // all is well\n          return;\n        } else {\n          // log a warning; continue to attempt to re-open\n          LOG.warn(\"Failed to seek on {} to {}. Current position {}\",\n              uri, targetPos,  pos);\n        }\n      }\n    } else if (diff \u003c 0) {\n      // backwards seek\n      streamStatistics.seekBackwards(diff);\n    } else {\n      // targetPos \u003d\u003d pos\n      if (remainingInCurrentRequest() \u003e 0) {\n        // if there is data left in the stream, keep going\n        return;\n      }\n\n    }\n\n    // if the code reaches here, the stream needs to be reopened.\n    // close the stream; if read the object will be opened at the new pos\n    closeStream(\"seekInStream()\", this.contentRangeFinish, false);\n    pos \u003d targetPos;\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AInputStream.java",
      "extendedDetails": {}
    },
    "4ee3543625c77c06d566fe81644d21c607d6d74d": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13203 S3A: Support fadvise \"random\" mode for high performance readPositioned() reads. Contributed by Rajesh Balamohan and stevel.\n",
      "commitDate": "22/06/16 7:45 AM",
      "commitName": "4ee3543625c77c06d566fe81644d21c607d6d74d",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "21/05/16 8:39 AM",
      "commitNameOld": "39ec1515a205952eda7e171408a8b83eceb4abde",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 31.96,
      "commitsBetweenForRepo": 198,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,51 +1,58 @@\n   private void seekInStream(long targetPos, long length) throws IOException {\n     checkNotClosed();\n     if (wrappedStream \u003d\u003d null) {\n       return;\n     }\n     // compute how much more to skip\n     long diff \u003d targetPos - pos;\n     if (diff \u003e 0) {\n       // forward seek -this is where data can be skipped\n \n       int available \u003d wrappedStream.available();\n       // always seek at least as far as what is available\n       long forwardSeekRange \u003d Math.max(readahead, available);\n       // work out how much is actually left in the stream\n       // then choose whichever comes first: the range or the EOF\n-      long forwardSeekLimit \u003d Math.min(remaining(), forwardSeekRange);\n-      if (diff \u003c\u003d forwardSeekLimit) {\n+      long remainingInCurrentRequest \u003d remainingInCurrentRequest();\n+\n+      long forwardSeekLimit \u003d Math.min(remainingInCurrentRequest,\n+          forwardSeekRange);\n+      boolean skipForward \u003d remainingInCurrentRequest \u003e 0\n+          \u0026\u0026 diff \u003c\u003d forwardSeekLimit;\n+      if (skipForward) {\n         // the forward seek range is within the limits\n         LOG.debug(\"Forward seek on {}, of {} bytes\", uri, diff);\n         streamStatistics.seekForwards(diff);\n         long skipped \u003d wrappedStream.skip(diff);\n         if (skipped \u003e 0) {\n           pos +\u003d skipped;\n           // as these bytes have been read, they are included in the counter\n           incrementBytesRead(diff);\n         }\n \n         if (pos \u003d\u003d targetPos) {\n           // all is well\n           return;\n         } else {\n           // log a warning; continue to attempt to re-open\n           LOG.warn(\"Failed to seek on {} to {}. Current position {}\",\n               uri, targetPos,  pos);\n         }\n       }\n     } else if (diff \u003c 0) {\n       // backwards seek\n       streamStatistics.seekBackwards(diff);\n     } else {\n       // targetPos \u003d\u003d pos\n-      // this should never happen as the caller filters it out.\n-      // Retained just in case\n-      LOG.debug(\"Ignoring seek {} to {} as target position \u003d\u003d current\",\n-          uri, targetPos);\n+      if (remainingInCurrentRequest() \u003e 0) {\n+        // if there is data left in the stream, keep going\n+        return;\n+      }\n+\n     }\n \n+    // if the code reaches here, the stream needs to be reopened.\n     // close the stream; if read the object will be opened at the new pos\n-    closeStream(\"seekInStream()\", this.requestedStreamLen);\n+    closeStream(\"seekInStream()\", this.contentRangeFinish);\n     pos \u003d targetPos;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void seekInStream(long targetPos, long length) throws IOException {\n    checkNotClosed();\n    if (wrappedStream \u003d\u003d null) {\n      return;\n    }\n    // compute how much more to skip\n    long diff \u003d targetPos - pos;\n    if (diff \u003e 0) {\n      // forward seek -this is where data can be skipped\n\n      int available \u003d wrappedStream.available();\n      // always seek at least as far as what is available\n      long forwardSeekRange \u003d Math.max(readahead, available);\n      // work out how much is actually left in the stream\n      // then choose whichever comes first: the range or the EOF\n      long remainingInCurrentRequest \u003d remainingInCurrentRequest();\n\n      long forwardSeekLimit \u003d Math.min(remainingInCurrentRequest,\n          forwardSeekRange);\n      boolean skipForward \u003d remainingInCurrentRequest \u003e 0\n          \u0026\u0026 diff \u003c\u003d forwardSeekLimit;\n      if (skipForward) {\n        // the forward seek range is within the limits\n        LOG.debug(\"Forward seek on {}, of {} bytes\", uri, diff);\n        streamStatistics.seekForwards(diff);\n        long skipped \u003d wrappedStream.skip(diff);\n        if (skipped \u003e 0) {\n          pos +\u003d skipped;\n          // as these bytes have been read, they are included in the counter\n          incrementBytesRead(diff);\n        }\n\n        if (pos \u003d\u003d targetPos) {\n          // all is well\n          return;\n        } else {\n          // log a warning; continue to attempt to re-open\n          LOG.warn(\"Failed to seek on {} to {}. Current position {}\",\n              uri, targetPos,  pos);\n        }\n      }\n    } else if (diff \u003c 0) {\n      // backwards seek\n      streamStatistics.seekBackwards(diff);\n    } else {\n      // targetPos \u003d\u003d pos\n      if (remainingInCurrentRequest() \u003e 0) {\n        // if there is data left in the stream, keep going\n        return;\n      }\n\n    }\n\n    // if the code reaches here, the stream needs to be reopened.\n    // close the stream; if read the object will be opened at the new pos\n    closeStream(\"seekInStream()\", this.contentRangeFinish);\n    pos \u003d targetPos;\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AInputStream.java",
      "extendedDetails": {}
    },
    "27c4e90efce04e1b1302f668b5eb22412e00d033": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13028 add low level counter metrics for S3A; use in read performance tests. contributed by: stevel\npatch includes\nHADOOP-12844 Recover when S3A fails on IOException in read()\nHADOOP-13058 S3A FS fails during init against a read-only FS if multipart purge\nHADOOP-13047 S3a Forward seek in stream length to be configurable\n",
      "commitDate": "12/05/16 11:24 AM",
      "commitName": "27c4e90efce04e1b1302f668b5eb22412e00d033",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "09/04/16 3:25 AM",
      "commitNameOld": "b9e3eff62a7415d8666656a75db69ff3e43f8e7e",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 33.33,
      "commitsBetweenForRepo": 203,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,24 +1,51 @@\n   private void seekInStream(long targetPos, long length) throws IOException {\n     checkNotClosed();\n     if (wrappedStream \u003d\u003d null) {\n       return;\n     }\n-\n     // compute how much more to skip\n     long diff \u003d targetPos - pos;\n-    if (targetPos \u003e pos) {\n-      if ((diff + length) \u003c\u003d wrappedStream.available()) {\n-        // already available in buffer\n-        pos +\u003d wrappedStream.skip(diff);\n-        if (pos !\u003d targetPos) {\n-          throw new IOException(\"Failed to seek to \" + targetPos\n-              + \". Current position \" + pos);\n+    if (diff \u003e 0) {\n+      // forward seek -this is where data can be skipped\n+\n+      int available \u003d wrappedStream.available();\n+      // always seek at least as far as what is available\n+      long forwardSeekRange \u003d Math.max(readahead, available);\n+      // work out how much is actually left in the stream\n+      // then choose whichever comes first: the range or the EOF\n+      long forwardSeekLimit \u003d Math.min(remaining(), forwardSeekRange);\n+      if (diff \u003c\u003d forwardSeekLimit) {\n+        // the forward seek range is within the limits\n+        LOG.debug(\"Forward seek on {}, of {} bytes\", uri, diff);\n+        streamStatistics.seekForwards(diff);\n+        long skipped \u003d wrappedStream.skip(diff);\n+        if (skipped \u003e 0) {\n+          pos +\u003d skipped;\n+          // as these bytes have been read, they are included in the counter\n+          incrementBytesRead(diff);\n         }\n-        return;\n+\n+        if (pos \u003d\u003d targetPos) {\n+          // all is well\n+          return;\n+        } else {\n+          // log a warning; continue to attempt to re-open\n+          LOG.warn(\"Failed to seek on {} to {}. Current position {}\",\n+              uri, targetPos,  pos);\n+        }\n       }\n+    } else if (diff \u003c 0) {\n+      // backwards seek\n+      streamStatistics.seekBackwards(diff);\n+    } else {\n+      // targetPos \u003d\u003d pos\n+      // this should never happen as the caller filters it out.\n+      // Retained just in case\n+      LOG.debug(\"Ignoring seek {} to {} as target position \u003d\u003d current\",\n+          uri, targetPos);\n     }\n \n     // close the stream; if read the object will be opened at the new pos\n-    closeStream(this.requestedStreamLen);\n+    closeStream(\"seekInStream()\", this.requestedStreamLen);\n     pos \u003d targetPos;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void seekInStream(long targetPos, long length) throws IOException {\n    checkNotClosed();\n    if (wrappedStream \u003d\u003d null) {\n      return;\n    }\n    // compute how much more to skip\n    long diff \u003d targetPos - pos;\n    if (diff \u003e 0) {\n      // forward seek -this is where data can be skipped\n\n      int available \u003d wrappedStream.available();\n      // always seek at least as far as what is available\n      long forwardSeekRange \u003d Math.max(readahead, available);\n      // work out how much is actually left in the stream\n      // then choose whichever comes first: the range or the EOF\n      long forwardSeekLimit \u003d Math.min(remaining(), forwardSeekRange);\n      if (diff \u003c\u003d forwardSeekLimit) {\n        // the forward seek range is within the limits\n        LOG.debug(\"Forward seek on {}, of {} bytes\", uri, diff);\n        streamStatistics.seekForwards(diff);\n        long skipped \u003d wrappedStream.skip(diff);\n        if (skipped \u003e 0) {\n          pos +\u003d skipped;\n          // as these bytes have been read, they are included in the counter\n          incrementBytesRead(diff);\n        }\n\n        if (pos \u003d\u003d targetPos) {\n          // all is well\n          return;\n        } else {\n          // log a warning; continue to attempt to re-open\n          LOG.warn(\"Failed to seek on {} to {}. Current position {}\",\n              uri, targetPos,  pos);\n        }\n      }\n    } else if (diff \u003c 0) {\n      // backwards seek\n      streamStatistics.seekBackwards(diff);\n    } else {\n      // targetPos \u003d\u003d pos\n      // this should never happen as the caller filters it out.\n      // Retained just in case\n      LOG.debug(\"Ignoring seek {} to {} as target position \u003d\u003d current\",\n          uri, targetPos);\n    }\n\n    // close the stream; if read the object will be opened at the new pos\n    closeStream(\"seekInStream()\", this.requestedStreamLen);\n    pos \u003d targetPos;\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AInputStream.java",
      "extendedDetails": {}
    },
    "b9e3eff62a7415d8666656a75db69ff3e43f8e7e": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-12444 Support lazy seek in S3AInputStream. Rajesh Balamohan via stevel\n",
      "commitDate": "09/04/16 3:25 AM",
      "commitName": "b9e3eff62a7415d8666656a75db69ff3e43f8e7e",
      "commitAuthor": "Steve Loughran",
      "diff": "@@ -0,0 +1,24 @@\n+  private void seekInStream(long targetPos, long length) throws IOException {\n+    checkNotClosed();\n+    if (wrappedStream \u003d\u003d null) {\n+      return;\n+    }\n+\n+    // compute how much more to skip\n+    long diff \u003d targetPos - pos;\n+    if (targetPos \u003e pos) {\n+      if ((diff + length) \u003c\u003d wrappedStream.available()) {\n+        // already available in buffer\n+        pos +\u003d wrappedStream.skip(diff);\n+        if (pos !\u003d targetPos) {\n+          throw new IOException(\"Failed to seek to \" + targetPos\n+              + \". Current position \" + pos);\n+        }\n+        return;\n+      }\n+    }\n+\n+    // close the stream; if read the object will be opened at the new pos\n+    closeStream(this.requestedStreamLen);\n+    pos \u003d targetPos;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void seekInStream(long targetPos, long length) throws IOException {\n    checkNotClosed();\n    if (wrappedStream \u003d\u003d null) {\n      return;\n    }\n\n    // compute how much more to skip\n    long diff \u003d targetPos - pos;\n    if (targetPos \u003e pos) {\n      if ((diff + length) \u003c\u003d wrappedStream.available()) {\n        // already available in buffer\n        pos +\u003d wrappedStream.skip(diff);\n        if (pos !\u003d targetPos) {\n          throw new IOException(\"Failed to seek to \" + targetPos\n              + \". Current position \" + pos);\n        }\n        return;\n      }\n    }\n\n    // close the stream; if read the object will be opened at the new pos\n    closeStream(this.requestedStreamLen);\n    pos \u003d targetPos;\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AInputStream.java"
    }
  }
}