{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ImageServlet.java",
  "functionName": "doPut",
  "functionId": "doPut___request-HttpServletRequest(modifiers-final)__response-HttpServletResponse(modifiers-final)",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ImageServlet.java",
  "functionStartLine": 523,
  "functionEndLine": 688,
  "numCommitsSeen": 20,
  "timeTaken": 3950,
  "changeHistory": [
    "7bb902bc0d0c62d63a8960db444de3abb0a6ad22",
    "65c4660bcd897e139fc175ca438cff75ec0c6be8",
    "5e6cc6fe8a11a638ba98913ca402efdc988fe73a",
    "49dfad942970459297f72632ed8dfd353e0c86de",
    "d3268c4b10a0f728b554ddb6d69b666a9ca13f12",
    "193f11a7ab539c360ecd9f2015c0f46cd070a875",
    "94a1632fcb677fda6f4d812614026417f1d0a360"
  ],
  "changeHistoryShort": {
    "7bb902bc0d0c62d63a8960db444de3abb0a6ad22": "Ybodychange",
    "65c4660bcd897e139fc175ca438cff75ec0c6be8": "Ybodychange",
    "5e6cc6fe8a11a638ba98913ca402efdc988fe73a": "Ybodychange",
    "49dfad942970459297f72632ed8dfd353e0c86de": "Ybodychange",
    "d3268c4b10a0f728b554ddb6d69b666a9ca13f12": "Ybodychange",
    "193f11a7ab539c360ecd9f2015c0f46cd070a875": "Ybodychange",
    "94a1632fcb677fda6f4d812614026417f1d0a360": "Yintroduced"
  },
  "changeHistoryDetails": {
    "7bb902bc0d0c62d63a8960db444de3abb0a6ad22": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-15293. Relax the condition for accepting a fsimage when receiving a checkpoint. Contributed by Chen Liang\n",
      "commitDate": "18/05/20 10:58 AM",
      "commitName": "7bb902bc0d0c62d63a8960db444de3abb0a6ad22",
      "commitAuthor": "Chen Liang",
      "commitDateOld": "12/12/19 10:22 AM",
      "commitNameOld": "65c4660bcd897e139fc175ca438cff75ec0c6be8",
      "commitAuthorOld": "Chen Liang",
      "daysBetweenCommits": 157.98,
      "commitsBetweenForRepo": 520,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,160 +1,166 @@\n   protected void doPut(final HttpServletRequest request,\n       final HttpServletResponse response) throws ServletException, IOException {\n     try {\n       ServletContext context \u003d getServletContext();\n       final FSImage nnImage \u003d NameNodeHttpServer.getFsImageFromContext(context);\n       final Configuration conf \u003d (Configuration) getServletContext()\n           .getAttribute(JspHelper.CURRENT_CONF);\n       final PutImageParams parsedParams \u003d new PutImageParams(request, response,\n           conf);\n       final NameNodeMetrics metrics \u003d NameNode.getNameNodeMetrics();\n       final boolean checkRecentImageEnable;\n       Object checkRecentImageEnableObj \u003d\n           context.getAttribute(RECENT_IMAGE_CHECK_ENABLED);\n       if (checkRecentImageEnableObj !\u003d null) {\n         if (checkRecentImageEnableObj instanceof Boolean) {\n           checkRecentImageEnable \u003d (boolean) checkRecentImageEnableObj;\n         } else {\n           // This is an error case, but crashing NN due to this\n           // seems more undesirable. Only log the error and set to default.\n           LOG.error(\"Expecting boolean obj for setting checking recent image, \"\n               + \"but got \" + checkRecentImageEnableObj.getClass() + \". This is \"\n               + \"unexpected! Setting to default.\");\n           checkRecentImageEnable \u003d RECENT_IMAGE_CHECK_ENABLED_DEFAULT;\n         }\n       } else {\n         checkRecentImageEnable \u003d RECENT_IMAGE_CHECK_ENABLED_DEFAULT;\n       }\n \n       validateRequest(context, conf, request, response, nnImage,\n           parsedParams.getStorageInfoString());\n \n       UserGroupInformation.getCurrentUser().doAs(\n           new PrivilegedExceptionAction\u003cVoid\u003e() {\n \n             @Override\n             public Void run() throws Exception {\n               // if its not the active NN, then we need to notify the caller it was was the wrong\n               // target (regardless of the fact that we got the image)\n               HAServiceProtocol.HAServiceState state \u003d NameNodeHttpServer\n                   .getNameNodeStateFromContext(getServletContext());\n               if (state !\u003d HAServiceProtocol.HAServiceState.ACTIVE \u0026\u0026\n                   state !\u003d HAServiceProtocol.HAServiceState.OBSERVER) {\n                 // we need a different response type here so the client can differentiate this\n                 // from the failure to upload due to (1) security, or (2) other checkpoints already\n                 // present\n                 response.sendError(HttpServletResponse.SC_EXPECTATION_FAILED,\n                     \"Nameode \"+request.getLocalAddr()+\" is currently not in a state which can \"\n                         + \"accept uploads of new fsimages. State: \"+state);\n                 return null;\n               }\n \n               final long txid \u003d parsedParams.getTxId();\n               String remoteAddr \u003d request.getRemoteAddr();\n               ImageUploadRequest imageRequest \u003d new ImageUploadRequest(txid, remoteAddr);\n \n               final NameNodeFile nnf \u003d parsedParams.getNameNodeFile();\n \n               // if the node is attempting to upload an older transaction, we ignore it\n               SortedSet\u003cImageUploadRequest\u003e larger \u003d currentlyDownloadingCheckpoints.tailSet(imageRequest);\n               if (larger.size() \u003e 0) {\n                 response.sendError(HttpServletResponse.SC_CONFLICT,\n                     \"Another checkpointer is already in the process of uploading a\" +\n                         \" checkpoint made up to transaction ID \" + larger.last());\n                 return null;\n               }\n \n               //make sure no one else has started uploading one\n               if (!currentlyDownloadingCheckpoints.add(imageRequest)) {\n                 response.sendError(HttpServletResponse.SC_CONFLICT,\n                     \"Either current namenode is checkpointing or another\"\n                         + \" checkpointer is already in the process of \"\n                         + \"uploading a checkpoint made at transaction ID \"\n                         + txid);\n                 return null;\n               }\n \n               long now \u003d System.currentTimeMillis();\n               long lastCheckpointTime \u003d\n                   nnImage.getStorage().getMostRecentCheckpointTime();\n               long lastCheckpointTxid \u003d\n                   nnImage.getStorage().getMostRecentCheckpointTxId();\n \n               long checkpointPeriod \u003d\n                   conf.getTimeDuration(DFS_NAMENODE_CHECKPOINT_PERIOD_KEY,\n                       DFS_NAMENODE_CHECKPOINT_PERIOD_DEFAULT, TimeUnit.SECONDS);\n+              checkpointPeriod \u003d Math.round(\n+                  checkpointPeriod * recentImageCheckTimePrecision);\n+\n               long checkpointTxnCount \u003d\n                   conf.getLong(DFS_NAMENODE_CHECKPOINT_TXNS_KEY,\n                       DFS_NAMENODE_CHECKPOINT_TXNS_DEFAULT);\n \n               long timeDelta \u003d TimeUnit.MILLISECONDS.toSeconds(\n                   now - lastCheckpointTime);\n \n               // Since the goal of the check below is to prevent overly\n               // frequent upload from Standby, the check should only be done\n               // for the periodical upload from Standby. For the other\n               // scenarios such as rollback image and ckpt file, they skip\n               // this check, see HDFS-15036 for more info.\n               if (checkRecentImageEnable \u0026\u0026\n                   NameNodeFile.IMAGE.equals(parsedParams.getNameNodeFile()) \u0026\u0026\n                   timeDelta \u003c checkpointPeriod \u0026\u0026\n                   txid - lastCheckpointTxid \u003c checkpointTxnCount) {\n                 // only when at least one of two conditions are met we accept\n                 // a new fsImage\n                 // 1. most recent image\u0027s txid is too far behind\n                 // 2. last checkpoint time was too old\n-                response.sendError(HttpServletResponse.SC_CONFLICT,\n-                    \"Most recent checkpoint is neither too far behind in \"\n-                        + \"txid, nor too old. New txnid cnt is \"\n-                        + (txid - lastCheckpointTxid)\n-                        + \", expecting at least \" + checkpointTxnCount\n-                        + \" unless too long since last upload.\");\n+                String message \u003d \"Rejecting a fsimage due to small time delta \"\n+                    + \"and txnid delta. Time since previous checkpoint is \"\n+                    + timeDelta + \" expecting at least \" + checkpointPeriod\n+                    + \" txnid delta since previous checkpoint is \" +\n+                    (txid - lastCheckpointTxid) + \" expecting at least \"\n+                    + checkpointTxnCount;\n+                LOG.info(message);\n+                response.sendError(HttpServletResponse.SC_CONFLICT, message);\n                 return null;\n               }\n \n               try {\n                 if (nnImage.getStorage().findImageFile(nnf, txid) !\u003d null) {\n-                  response.sendError(HttpServletResponse.SC_CONFLICT,\n-                      \"Either current namenode has checkpointed or \"\n-                          + \"another checkpointer already uploaded an \"\n-                          + \"checkpoint for txid \" + txid);\n+                  String message \u003d \"Either current namenode has checkpointed or \"\n+                      + \"another checkpointer already uploaded an \"\n+                      + \"checkpoint for txid \" + txid;\n+                  LOG.info(message);\n+                  response.sendError(HttpServletResponse.SC_CONFLICT, message);\n                   return null;\n                 }\n \n                 InputStream stream \u003d request.getInputStream();\n                 try {\n                   long start \u003d monotonicNow();\n                   MD5Hash downloadImageDigest \u003d TransferFsImage\n                       .handleUploadImageRequest(request, txid,\n                           nnImage.getStorage(), stream,\n                           parsedParams.getFileSize(), getThrottler(conf));\n                   nnImage.saveDigestAndRenameCheckpointImage(nnf, txid,\n                       downloadImageDigest);\n                   // Metrics non-null only when used inside name node\n                   if (metrics !\u003d null) {\n                     long elapsed \u003d monotonicNow() - start;\n                     metrics.addPutImage(elapsed);\n                   }\n                   // Now that we have a new checkpoint, we might be able to\n                   // remove some old ones.\n                   nnImage.purgeOldStorage(nnf);\n                 } finally {\n                   // remove the request once we\u0027ve processed it, or it threw an error, so we\n                   // aren\u0027t using it either\n                   currentlyDownloadingCheckpoints.remove(imageRequest);\n \n                   stream.close();\n                 }\n               } finally {\n                 nnImage.removeFromCheckpointing(txid);\n               }\n               return null;\n             }\n \n           });\n     } catch (Throwable t) {\n       String errMsg \u003d \"PutImage failed. \" + StringUtils.stringifyException(t);\n       response.sendError(HttpServletResponse.SC_GONE, errMsg);\n       throw new IOException(errMsg);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void doPut(final HttpServletRequest request,\n      final HttpServletResponse response) throws ServletException, IOException {\n    try {\n      ServletContext context \u003d getServletContext();\n      final FSImage nnImage \u003d NameNodeHttpServer.getFsImageFromContext(context);\n      final Configuration conf \u003d (Configuration) getServletContext()\n          .getAttribute(JspHelper.CURRENT_CONF);\n      final PutImageParams parsedParams \u003d new PutImageParams(request, response,\n          conf);\n      final NameNodeMetrics metrics \u003d NameNode.getNameNodeMetrics();\n      final boolean checkRecentImageEnable;\n      Object checkRecentImageEnableObj \u003d\n          context.getAttribute(RECENT_IMAGE_CHECK_ENABLED);\n      if (checkRecentImageEnableObj !\u003d null) {\n        if (checkRecentImageEnableObj instanceof Boolean) {\n          checkRecentImageEnable \u003d (boolean) checkRecentImageEnableObj;\n        } else {\n          // This is an error case, but crashing NN due to this\n          // seems more undesirable. Only log the error and set to default.\n          LOG.error(\"Expecting boolean obj for setting checking recent image, \"\n              + \"but got \" + checkRecentImageEnableObj.getClass() + \". This is \"\n              + \"unexpected! Setting to default.\");\n          checkRecentImageEnable \u003d RECENT_IMAGE_CHECK_ENABLED_DEFAULT;\n        }\n      } else {\n        checkRecentImageEnable \u003d RECENT_IMAGE_CHECK_ENABLED_DEFAULT;\n      }\n\n      validateRequest(context, conf, request, response, nnImage,\n          parsedParams.getStorageInfoString());\n\n      UserGroupInformation.getCurrentUser().doAs(\n          new PrivilegedExceptionAction\u003cVoid\u003e() {\n\n            @Override\n            public Void run() throws Exception {\n              // if its not the active NN, then we need to notify the caller it was was the wrong\n              // target (regardless of the fact that we got the image)\n              HAServiceProtocol.HAServiceState state \u003d NameNodeHttpServer\n                  .getNameNodeStateFromContext(getServletContext());\n              if (state !\u003d HAServiceProtocol.HAServiceState.ACTIVE \u0026\u0026\n                  state !\u003d HAServiceProtocol.HAServiceState.OBSERVER) {\n                // we need a different response type here so the client can differentiate this\n                // from the failure to upload due to (1) security, or (2) other checkpoints already\n                // present\n                response.sendError(HttpServletResponse.SC_EXPECTATION_FAILED,\n                    \"Nameode \"+request.getLocalAddr()+\" is currently not in a state which can \"\n                        + \"accept uploads of new fsimages. State: \"+state);\n                return null;\n              }\n\n              final long txid \u003d parsedParams.getTxId();\n              String remoteAddr \u003d request.getRemoteAddr();\n              ImageUploadRequest imageRequest \u003d new ImageUploadRequest(txid, remoteAddr);\n\n              final NameNodeFile nnf \u003d parsedParams.getNameNodeFile();\n\n              // if the node is attempting to upload an older transaction, we ignore it\n              SortedSet\u003cImageUploadRequest\u003e larger \u003d currentlyDownloadingCheckpoints.tailSet(imageRequest);\n              if (larger.size() \u003e 0) {\n                response.sendError(HttpServletResponse.SC_CONFLICT,\n                    \"Another checkpointer is already in the process of uploading a\" +\n                        \" checkpoint made up to transaction ID \" + larger.last());\n                return null;\n              }\n\n              //make sure no one else has started uploading one\n              if (!currentlyDownloadingCheckpoints.add(imageRequest)) {\n                response.sendError(HttpServletResponse.SC_CONFLICT,\n                    \"Either current namenode is checkpointing or another\"\n                        + \" checkpointer is already in the process of \"\n                        + \"uploading a checkpoint made at transaction ID \"\n                        + txid);\n                return null;\n              }\n\n              long now \u003d System.currentTimeMillis();\n              long lastCheckpointTime \u003d\n                  nnImage.getStorage().getMostRecentCheckpointTime();\n              long lastCheckpointTxid \u003d\n                  nnImage.getStorage().getMostRecentCheckpointTxId();\n\n              long checkpointPeriod \u003d\n                  conf.getTimeDuration(DFS_NAMENODE_CHECKPOINT_PERIOD_KEY,\n                      DFS_NAMENODE_CHECKPOINT_PERIOD_DEFAULT, TimeUnit.SECONDS);\n              checkpointPeriod \u003d Math.round(\n                  checkpointPeriod * recentImageCheckTimePrecision);\n\n              long checkpointTxnCount \u003d\n                  conf.getLong(DFS_NAMENODE_CHECKPOINT_TXNS_KEY,\n                      DFS_NAMENODE_CHECKPOINT_TXNS_DEFAULT);\n\n              long timeDelta \u003d TimeUnit.MILLISECONDS.toSeconds(\n                  now - lastCheckpointTime);\n\n              // Since the goal of the check below is to prevent overly\n              // frequent upload from Standby, the check should only be done\n              // for the periodical upload from Standby. For the other\n              // scenarios such as rollback image and ckpt file, they skip\n              // this check, see HDFS-15036 for more info.\n              if (checkRecentImageEnable \u0026\u0026\n                  NameNodeFile.IMAGE.equals(parsedParams.getNameNodeFile()) \u0026\u0026\n                  timeDelta \u003c checkpointPeriod \u0026\u0026\n                  txid - lastCheckpointTxid \u003c checkpointTxnCount) {\n                // only when at least one of two conditions are met we accept\n                // a new fsImage\n                // 1. most recent image\u0027s txid is too far behind\n                // 2. last checkpoint time was too old\n                String message \u003d \"Rejecting a fsimage due to small time delta \"\n                    + \"and txnid delta. Time since previous checkpoint is \"\n                    + timeDelta + \" expecting at least \" + checkpointPeriod\n                    + \" txnid delta since previous checkpoint is \" +\n                    (txid - lastCheckpointTxid) + \" expecting at least \"\n                    + checkpointTxnCount;\n                LOG.info(message);\n                response.sendError(HttpServletResponse.SC_CONFLICT, message);\n                return null;\n              }\n\n              try {\n                if (nnImage.getStorage().findImageFile(nnf, txid) !\u003d null) {\n                  String message \u003d \"Either current namenode has checkpointed or \"\n                      + \"another checkpointer already uploaded an \"\n                      + \"checkpoint for txid \" + txid;\n                  LOG.info(message);\n                  response.sendError(HttpServletResponse.SC_CONFLICT, message);\n                  return null;\n                }\n\n                InputStream stream \u003d request.getInputStream();\n                try {\n                  long start \u003d monotonicNow();\n                  MD5Hash downloadImageDigest \u003d TransferFsImage\n                      .handleUploadImageRequest(request, txid,\n                          nnImage.getStorage(), stream,\n                          parsedParams.getFileSize(), getThrottler(conf));\n                  nnImage.saveDigestAndRenameCheckpointImage(nnf, txid,\n                      downloadImageDigest);\n                  // Metrics non-null only when used inside name node\n                  if (metrics !\u003d null) {\n                    long elapsed \u003d monotonicNow() - start;\n                    metrics.addPutImage(elapsed);\n                  }\n                  // Now that we have a new checkpoint, we might be able to\n                  // remove some old ones.\n                  nnImage.purgeOldStorage(nnf);\n                } finally {\n                  // remove the request once we\u0027ve processed it, or it threw an error, so we\n                  // aren\u0027t using it either\n                  currentlyDownloadingCheckpoints.remove(imageRequest);\n\n                  stream.close();\n                }\n              } finally {\n                nnImage.removeFromCheckpointing(txid);\n              }\n              return null;\n            }\n\n          });\n    } catch (Throwable t) {\n      String errMsg \u003d \"PutImage failed. \" + StringUtils.stringifyException(t);\n      response.sendError(HttpServletResponse.SC_GONE, errMsg);\n      throw new IOException(errMsg);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ImageServlet.java",
      "extendedDetails": {}
    },
    "65c4660bcd897e139fc175ca438cff75ec0c6be8": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-15036. Active NameNode should not silently fail the image transfer. Contributed by Chen Liang.\n",
      "commitDate": "12/12/19 10:22 AM",
      "commitName": "65c4660bcd897e139fc175ca438cff75ec0c6be8",
      "commitAuthor": "Chen Liang",
      "commitDateOld": "17/07/19 2:37 PM",
      "commitNameOld": "5e6cc6fe8a11a638ba98913ca402efdc988fe73a",
      "commitAuthorOld": "Chen Liang",
      "daysBetweenCommits": 147.86,
      "commitsBetweenForRepo": 996,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,154 +1,160 @@\n   protected void doPut(final HttpServletRequest request,\n       final HttpServletResponse response) throws ServletException, IOException {\n     try {\n       ServletContext context \u003d getServletContext();\n       final FSImage nnImage \u003d NameNodeHttpServer.getFsImageFromContext(context);\n       final Configuration conf \u003d (Configuration) getServletContext()\n           .getAttribute(JspHelper.CURRENT_CONF);\n       final PutImageParams parsedParams \u003d new PutImageParams(request, response,\n           conf);\n       final NameNodeMetrics metrics \u003d NameNode.getNameNodeMetrics();\n       final boolean checkRecentImageEnable;\n       Object checkRecentImageEnableObj \u003d\n           context.getAttribute(RECENT_IMAGE_CHECK_ENABLED);\n       if (checkRecentImageEnableObj !\u003d null) {\n         if (checkRecentImageEnableObj instanceof Boolean) {\n           checkRecentImageEnable \u003d (boolean) checkRecentImageEnableObj;\n         } else {\n           // This is an error case, but crashing NN due to this\n           // seems more undesirable. Only log the error and set to default.\n           LOG.error(\"Expecting boolean obj for setting checking recent image, \"\n               + \"but got \" + checkRecentImageEnableObj.getClass() + \". This is \"\n               + \"unexpected! Setting to default.\");\n           checkRecentImageEnable \u003d RECENT_IMAGE_CHECK_ENABLED_DEFAULT;\n         }\n       } else {\n         checkRecentImageEnable \u003d RECENT_IMAGE_CHECK_ENABLED_DEFAULT;\n       }\n \n       validateRequest(context, conf, request, response, nnImage,\n           parsedParams.getStorageInfoString());\n \n       UserGroupInformation.getCurrentUser().doAs(\n           new PrivilegedExceptionAction\u003cVoid\u003e() {\n \n             @Override\n             public Void run() throws Exception {\n               // if its not the active NN, then we need to notify the caller it was was the wrong\n               // target (regardless of the fact that we got the image)\n               HAServiceProtocol.HAServiceState state \u003d NameNodeHttpServer\n                   .getNameNodeStateFromContext(getServletContext());\n               if (state !\u003d HAServiceProtocol.HAServiceState.ACTIVE \u0026\u0026\n                   state !\u003d HAServiceProtocol.HAServiceState.OBSERVER) {\n                 // we need a different response type here so the client can differentiate this\n                 // from the failure to upload due to (1) security, or (2) other checkpoints already\n                 // present\n                 response.sendError(HttpServletResponse.SC_EXPECTATION_FAILED,\n                     \"Nameode \"+request.getLocalAddr()+\" is currently not in a state which can \"\n                         + \"accept uploads of new fsimages. State: \"+state);\n                 return null;\n               }\n \n               final long txid \u003d parsedParams.getTxId();\n               String remoteAddr \u003d request.getRemoteAddr();\n               ImageUploadRequest imageRequest \u003d new ImageUploadRequest(txid, remoteAddr);\n \n               final NameNodeFile nnf \u003d parsedParams.getNameNodeFile();\n \n               // if the node is attempting to upload an older transaction, we ignore it\n               SortedSet\u003cImageUploadRequest\u003e larger \u003d currentlyDownloadingCheckpoints.tailSet(imageRequest);\n               if (larger.size() \u003e 0) {\n                 response.sendError(HttpServletResponse.SC_CONFLICT,\n                     \"Another checkpointer is already in the process of uploading a\" +\n                         \" checkpoint made up to transaction ID \" + larger.last());\n                 return null;\n               }\n \n               //make sure no one else has started uploading one\n               if (!currentlyDownloadingCheckpoints.add(imageRequest)) {\n                 response.sendError(HttpServletResponse.SC_CONFLICT,\n                     \"Either current namenode is checkpointing or another\"\n                         + \" checkpointer is already in the process of \"\n                         + \"uploading a checkpoint made at transaction ID \"\n                         + txid);\n                 return null;\n               }\n \n               long now \u003d System.currentTimeMillis();\n               long lastCheckpointTime \u003d\n                   nnImage.getStorage().getMostRecentCheckpointTime();\n               long lastCheckpointTxid \u003d\n                   nnImage.getStorage().getMostRecentCheckpointTxId();\n \n               long checkpointPeriod \u003d\n                   conf.getTimeDuration(DFS_NAMENODE_CHECKPOINT_PERIOD_KEY,\n                       DFS_NAMENODE_CHECKPOINT_PERIOD_DEFAULT, TimeUnit.SECONDS);\n               long checkpointTxnCount \u003d\n                   conf.getLong(DFS_NAMENODE_CHECKPOINT_TXNS_KEY,\n                       DFS_NAMENODE_CHECKPOINT_TXNS_DEFAULT);\n \n               long timeDelta \u003d TimeUnit.MILLISECONDS.toSeconds(\n                   now - lastCheckpointTime);\n \n+              // Since the goal of the check below is to prevent overly\n+              // frequent upload from Standby, the check should only be done\n+              // for the periodical upload from Standby. For the other\n+              // scenarios such as rollback image and ckpt file, they skip\n+              // this check, see HDFS-15036 for more info.\n               if (checkRecentImageEnable \u0026\u0026\n+                  NameNodeFile.IMAGE.equals(parsedParams.getNameNodeFile()) \u0026\u0026\n                   timeDelta \u003c checkpointPeriod \u0026\u0026\n                   txid - lastCheckpointTxid \u003c checkpointTxnCount) {\n                 // only when at least one of two conditions are met we accept\n                 // a new fsImage\n                 // 1. most recent image\u0027s txid is too far behind\n                 // 2. last checkpoint time was too old\n                 response.sendError(HttpServletResponse.SC_CONFLICT,\n                     \"Most recent checkpoint is neither too far behind in \"\n                         + \"txid, nor too old. New txnid cnt is \"\n                         + (txid - lastCheckpointTxid)\n                         + \", expecting at least \" + checkpointTxnCount\n                         + \" unless too long since last upload.\");\n                 return null;\n               }\n \n               try {\n                 if (nnImage.getStorage().findImageFile(nnf, txid) !\u003d null) {\n                   response.sendError(HttpServletResponse.SC_CONFLICT,\n                       \"Either current namenode has checkpointed or \"\n                           + \"another checkpointer already uploaded an \"\n                           + \"checkpoint for txid \" + txid);\n                   return null;\n                 }\n \n                 InputStream stream \u003d request.getInputStream();\n                 try {\n                   long start \u003d monotonicNow();\n                   MD5Hash downloadImageDigest \u003d TransferFsImage\n                       .handleUploadImageRequest(request, txid,\n                           nnImage.getStorage(), stream,\n                           parsedParams.getFileSize(), getThrottler(conf));\n                   nnImage.saveDigestAndRenameCheckpointImage(nnf, txid,\n                       downloadImageDigest);\n                   // Metrics non-null only when used inside name node\n                   if (metrics !\u003d null) {\n                     long elapsed \u003d monotonicNow() - start;\n                     metrics.addPutImage(elapsed);\n                   }\n                   // Now that we have a new checkpoint, we might be able to\n                   // remove some old ones.\n                   nnImage.purgeOldStorage(nnf);\n                 } finally {\n                   // remove the request once we\u0027ve processed it, or it threw an error, so we\n                   // aren\u0027t using it either\n                   currentlyDownloadingCheckpoints.remove(imageRequest);\n \n                   stream.close();\n                 }\n               } finally {\n                 nnImage.removeFromCheckpointing(txid);\n               }\n               return null;\n             }\n \n           });\n     } catch (Throwable t) {\n       String errMsg \u003d \"PutImage failed. \" + StringUtils.stringifyException(t);\n       response.sendError(HttpServletResponse.SC_GONE, errMsg);\n       throw new IOException(errMsg);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void doPut(final HttpServletRequest request,\n      final HttpServletResponse response) throws ServletException, IOException {\n    try {\n      ServletContext context \u003d getServletContext();\n      final FSImage nnImage \u003d NameNodeHttpServer.getFsImageFromContext(context);\n      final Configuration conf \u003d (Configuration) getServletContext()\n          .getAttribute(JspHelper.CURRENT_CONF);\n      final PutImageParams parsedParams \u003d new PutImageParams(request, response,\n          conf);\n      final NameNodeMetrics metrics \u003d NameNode.getNameNodeMetrics();\n      final boolean checkRecentImageEnable;\n      Object checkRecentImageEnableObj \u003d\n          context.getAttribute(RECENT_IMAGE_CHECK_ENABLED);\n      if (checkRecentImageEnableObj !\u003d null) {\n        if (checkRecentImageEnableObj instanceof Boolean) {\n          checkRecentImageEnable \u003d (boolean) checkRecentImageEnableObj;\n        } else {\n          // This is an error case, but crashing NN due to this\n          // seems more undesirable. Only log the error and set to default.\n          LOG.error(\"Expecting boolean obj for setting checking recent image, \"\n              + \"but got \" + checkRecentImageEnableObj.getClass() + \". This is \"\n              + \"unexpected! Setting to default.\");\n          checkRecentImageEnable \u003d RECENT_IMAGE_CHECK_ENABLED_DEFAULT;\n        }\n      } else {\n        checkRecentImageEnable \u003d RECENT_IMAGE_CHECK_ENABLED_DEFAULT;\n      }\n\n      validateRequest(context, conf, request, response, nnImage,\n          parsedParams.getStorageInfoString());\n\n      UserGroupInformation.getCurrentUser().doAs(\n          new PrivilegedExceptionAction\u003cVoid\u003e() {\n\n            @Override\n            public Void run() throws Exception {\n              // if its not the active NN, then we need to notify the caller it was was the wrong\n              // target (regardless of the fact that we got the image)\n              HAServiceProtocol.HAServiceState state \u003d NameNodeHttpServer\n                  .getNameNodeStateFromContext(getServletContext());\n              if (state !\u003d HAServiceProtocol.HAServiceState.ACTIVE \u0026\u0026\n                  state !\u003d HAServiceProtocol.HAServiceState.OBSERVER) {\n                // we need a different response type here so the client can differentiate this\n                // from the failure to upload due to (1) security, or (2) other checkpoints already\n                // present\n                response.sendError(HttpServletResponse.SC_EXPECTATION_FAILED,\n                    \"Nameode \"+request.getLocalAddr()+\" is currently not in a state which can \"\n                        + \"accept uploads of new fsimages. State: \"+state);\n                return null;\n              }\n\n              final long txid \u003d parsedParams.getTxId();\n              String remoteAddr \u003d request.getRemoteAddr();\n              ImageUploadRequest imageRequest \u003d new ImageUploadRequest(txid, remoteAddr);\n\n              final NameNodeFile nnf \u003d parsedParams.getNameNodeFile();\n\n              // if the node is attempting to upload an older transaction, we ignore it\n              SortedSet\u003cImageUploadRequest\u003e larger \u003d currentlyDownloadingCheckpoints.tailSet(imageRequest);\n              if (larger.size() \u003e 0) {\n                response.sendError(HttpServletResponse.SC_CONFLICT,\n                    \"Another checkpointer is already in the process of uploading a\" +\n                        \" checkpoint made up to transaction ID \" + larger.last());\n                return null;\n              }\n\n              //make sure no one else has started uploading one\n              if (!currentlyDownloadingCheckpoints.add(imageRequest)) {\n                response.sendError(HttpServletResponse.SC_CONFLICT,\n                    \"Either current namenode is checkpointing or another\"\n                        + \" checkpointer is already in the process of \"\n                        + \"uploading a checkpoint made at transaction ID \"\n                        + txid);\n                return null;\n              }\n\n              long now \u003d System.currentTimeMillis();\n              long lastCheckpointTime \u003d\n                  nnImage.getStorage().getMostRecentCheckpointTime();\n              long lastCheckpointTxid \u003d\n                  nnImage.getStorage().getMostRecentCheckpointTxId();\n\n              long checkpointPeriod \u003d\n                  conf.getTimeDuration(DFS_NAMENODE_CHECKPOINT_PERIOD_KEY,\n                      DFS_NAMENODE_CHECKPOINT_PERIOD_DEFAULT, TimeUnit.SECONDS);\n              long checkpointTxnCount \u003d\n                  conf.getLong(DFS_NAMENODE_CHECKPOINT_TXNS_KEY,\n                      DFS_NAMENODE_CHECKPOINT_TXNS_DEFAULT);\n\n              long timeDelta \u003d TimeUnit.MILLISECONDS.toSeconds(\n                  now - lastCheckpointTime);\n\n              // Since the goal of the check below is to prevent overly\n              // frequent upload from Standby, the check should only be done\n              // for the periodical upload from Standby. For the other\n              // scenarios such as rollback image and ckpt file, they skip\n              // this check, see HDFS-15036 for more info.\n              if (checkRecentImageEnable \u0026\u0026\n                  NameNodeFile.IMAGE.equals(parsedParams.getNameNodeFile()) \u0026\u0026\n                  timeDelta \u003c checkpointPeriod \u0026\u0026\n                  txid - lastCheckpointTxid \u003c checkpointTxnCount) {\n                // only when at least one of two conditions are met we accept\n                // a new fsImage\n                // 1. most recent image\u0027s txid is too far behind\n                // 2. last checkpoint time was too old\n                response.sendError(HttpServletResponse.SC_CONFLICT,\n                    \"Most recent checkpoint is neither too far behind in \"\n                        + \"txid, nor too old. New txnid cnt is \"\n                        + (txid - lastCheckpointTxid)\n                        + \", expecting at least \" + checkpointTxnCount\n                        + \" unless too long since last upload.\");\n                return null;\n              }\n\n              try {\n                if (nnImage.getStorage().findImageFile(nnf, txid) !\u003d null) {\n                  response.sendError(HttpServletResponse.SC_CONFLICT,\n                      \"Either current namenode has checkpointed or \"\n                          + \"another checkpointer already uploaded an \"\n                          + \"checkpoint for txid \" + txid);\n                  return null;\n                }\n\n                InputStream stream \u003d request.getInputStream();\n                try {\n                  long start \u003d monotonicNow();\n                  MD5Hash downloadImageDigest \u003d TransferFsImage\n                      .handleUploadImageRequest(request, txid,\n                          nnImage.getStorage(), stream,\n                          parsedParams.getFileSize(), getThrottler(conf));\n                  nnImage.saveDigestAndRenameCheckpointImage(nnf, txid,\n                      downloadImageDigest);\n                  // Metrics non-null only when used inside name node\n                  if (metrics !\u003d null) {\n                    long elapsed \u003d monotonicNow() - start;\n                    metrics.addPutImage(elapsed);\n                  }\n                  // Now that we have a new checkpoint, we might be able to\n                  // remove some old ones.\n                  nnImage.purgeOldStorage(nnf);\n                } finally {\n                  // remove the request once we\u0027ve processed it, or it threw an error, so we\n                  // aren\u0027t using it either\n                  currentlyDownloadingCheckpoints.remove(imageRequest);\n\n                  stream.close();\n                }\n              } finally {\n                nnImage.removeFromCheckpointing(txid);\n              }\n              return null;\n            }\n\n          });\n    } catch (Throwable t) {\n      String errMsg \u003d \"PutImage failed. \" + StringUtils.stringifyException(t);\n      response.sendError(HttpServletResponse.SC_GONE, errMsg);\n      throw new IOException(errMsg);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ImageServlet.java",
      "extendedDetails": {}
    },
    "5e6cc6fe8a11a638ba98913ca402efdc988fe73a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12979. [SBN read] StandbyNode should upload FsImage to ObserverNode after checkpointing. Contributed by Chen Liang.\n",
      "commitDate": "17/07/19 2:37 PM",
      "commitName": "5e6cc6fe8a11a638ba98913ca402efdc988fe73a",
      "commitAuthor": "Chen Liang",
      "commitDateOld": "07/12/18 6:30 PM",
      "commitNameOld": "8fc0d04517912766a3102f3e611f7d0fabd2f815",
      "commitAuthorOld": "Inigo Goiri",
      "daysBetweenCommits": 221.8,
      "commitsBetweenForRepo": 1590,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,103 +1,154 @@\n   protected void doPut(final HttpServletRequest request,\n       final HttpServletResponse response) throws ServletException, IOException {\n     try {\n       ServletContext context \u003d getServletContext();\n       final FSImage nnImage \u003d NameNodeHttpServer.getFsImageFromContext(context);\n       final Configuration conf \u003d (Configuration) getServletContext()\n           .getAttribute(JspHelper.CURRENT_CONF);\n       final PutImageParams parsedParams \u003d new PutImageParams(request, response,\n           conf);\n       final NameNodeMetrics metrics \u003d NameNode.getNameNodeMetrics();\n+      final boolean checkRecentImageEnable;\n+      Object checkRecentImageEnableObj \u003d\n+          context.getAttribute(RECENT_IMAGE_CHECK_ENABLED);\n+      if (checkRecentImageEnableObj !\u003d null) {\n+        if (checkRecentImageEnableObj instanceof Boolean) {\n+          checkRecentImageEnable \u003d (boolean) checkRecentImageEnableObj;\n+        } else {\n+          // This is an error case, but crashing NN due to this\n+          // seems more undesirable. Only log the error and set to default.\n+          LOG.error(\"Expecting boolean obj for setting checking recent image, \"\n+              + \"but got \" + checkRecentImageEnableObj.getClass() + \". This is \"\n+              + \"unexpected! Setting to default.\");\n+          checkRecentImageEnable \u003d RECENT_IMAGE_CHECK_ENABLED_DEFAULT;\n+        }\n+      } else {\n+        checkRecentImageEnable \u003d RECENT_IMAGE_CHECK_ENABLED_DEFAULT;\n+      }\n \n       validateRequest(context, conf, request, response, nnImage,\n           parsedParams.getStorageInfoString());\n \n       UserGroupInformation.getCurrentUser().doAs(\n           new PrivilegedExceptionAction\u003cVoid\u003e() {\n \n             @Override\n             public Void run() throws Exception {\n               // if its not the active NN, then we need to notify the caller it was was the wrong\n               // target (regardless of the fact that we got the image)\n               HAServiceProtocol.HAServiceState state \u003d NameNodeHttpServer\n                   .getNameNodeStateFromContext(getServletContext());\n-              if (state !\u003d HAServiceProtocol.HAServiceState.ACTIVE) {\n+              if (state !\u003d HAServiceProtocol.HAServiceState.ACTIVE \u0026\u0026\n+                  state !\u003d HAServiceProtocol.HAServiceState.OBSERVER) {\n                 // we need a different response type here so the client can differentiate this\n                 // from the failure to upload due to (1) security, or (2) other checkpoints already\n                 // present\n                 response.sendError(HttpServletResponse.SC_EXPECTATION_FAILED,\n                     \"Nameode \"+request.getLocalAddr()+\" is currently not in a state which can \"\n                         + \"accept uploads of new fsimages. State: \"+state);\n                 return null;\n               }\n \n               final long txid \u003d parsedParams.getTxId();\n               String remoteAddr \u003d request.getRemoteAddr();\n               ImageUploadRequest imageRequest \u003d new ImageUploadRequest(txid, remoteAddr);\n \n               final NameNodeFile nnf \u003d parsedParams.getNameNodeFile();\n \n               // if the node is attempting to upload an older transaction, we ignore it\n               SortedSet\u003cImageUploadRequest\u003e larger \u003d currentlyDownloadingCheckpoints.tailSet(imageRequest);\n               if (larger.size() \u003e 0) {\n                 response.sendError(HttpServletResponse.SC_CONFLICT,\n                     \"Another checkpointer is already in the process of uploading a\" +\n                         \" checkpoint made up to transaction ID \" + larger.last());\n                 return null;\n               }\n \n               //make sure no one else has started uploading one\n               if (!currentlyDownloadingCheckpoints.add(imageRequest)) {\n                 response.sendError(HttpServletResponse.SC_CONFLICT,\n                     \"Either current namenode is checkpointing or another\"\n                         + \" checkpointer is already in the process of \"\n                         + \"uploading a checkpoint made at transaction ID \"\n                         + txid);\n                 return null;\n               }\n+\n+              long now \u003d System.currentTimeMillis();\n+              long lastCheckpointTime \u003d\n+                  nnImage.getStorage().getMostRecentCheckpointTime();\n+              long lastCheckpointTxid \u003d\n+                  nnImage.getStorage().getMostRecentCheckpointTxId();\n+\n+              long checkpointPeriod \u003d\n+                  conf.getTimeDuration(DFS_NAMENODE_CHECKPOINT_PERIOD_KEY,\n+                      DFS_NAMENODE_CHECKPOINT_PERIOD_DEFAULT, TimeUnit.SECONDS);\n+              long checkpointTxnCount \u003d\n+                  conf.getLong(DFS_NAMENODE_CHECKPOINT_TXNS_KEY,\n+                      DFS_NAMENODE_CHECKPOINT_TXNS_DEFAULT);\n+\n+              long timeDelta \u003d TimeUnit.MILLISECONDS.toSeconds(\n+                  now - lastCheckpointTime);\n+\n+              if (checkRecentImageEnable \u0026\u0026\n+                  timeDelta \u003c checkpointPeriod \u0026\u0026\n+                  txid - lastCheckpointTxid \u003c checkpointTxnCount) {\n+                // only when at least one of two conditions are met we accept\n+                // a new fsImage\n+                // 1. most recent image\u0027s txid is too far behind\n+                // 2. last checkpoint time was too old\n+                response.sendError(HttpServletResponse.SC_CONFLICT,\n+                    \"Most recent checkpoint is neither too far behind in \"\n+                        + \"txid, nor too old. New txnid cnt is \"\n+                        + (txid - lastCheckpointTxid)\n+                        + \", expecting at least \" + checkpointTxnCount\n+                        + \" unless too long since last upload.\");\n+                return null;\n+              }\n+\n               try {\n                 if (nnImage.getStorage().findImageFile(nnf, txid) !\u003d null) {\n                   response.sendError(HttpServletResponse.SC_CONFLICT,\n                       \"Either current namenode has checkpointed or \"\n                           + \"another checkpointer already uploaded an \"\n                           + \"checkpoint for txid \" + txid);\n                   return null;\n                 }\n \n                 InputStream stream \u003d request.getInputStream();\n                 try {\n                   long start \u003d monotonicNow();\n                   MD5Hash downloadImageDigest \u003d TransferFsImage\n                       .handleUploadImageRequest(request, txid,\n                           nnImage.getStorage(), stream,\n                           parsedParams.getFileSize(), getThrottler(conf));\n                   nnImage.saveDigestAndRenameCheckpointImage(nnf, txid,\n                       downloadImageDigest);\n                   // Metrics non-null only when used inside name node\n                   if (metrics !\u003d null) {\n                     long elapsed \u003d monotonicNow() - start;\n                     metrics.addPutImage(elapsed);\n                   }\n                   // Now that we have a new checkpoint, we might be able to\n                   // remove some old ones.\n                   nnImage.purgeOldStorage(nnf);\n                 } finally {\n                   // remove the request once we\u0027ve processed it, or it threw an error, so we\n                   // aren\u0027t using it either\n                   currentlyDownloadingCheckpoints.remove(imageRequest);\n \n                   stream.close();\n                 }\n               } finally {\n                 nnImage.removeFromCheckpointing(txid);\n               }\n               return null;\n             }\n \n           });\n     } catch (Throwable t) {\n       String errMsg \u003d \"PutImage failed. \" + StringUtils.stringifyException(t);\n       response.sendError(HttpServletResponse.SC_GONE, errMsg);\n       throw new IOException(errMsg);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void doPut(final HttpServletRequest request,\n      final HttpServletResponse response) throws ServletException, IOException {\n    try {\n      ServletContext context \u003d getServletContext();\n      final FSImage nnImage \u003d NameNodeHttpServer.getFsImageFromContext(context);\n      final Configuration conf \u003d (Configuration) getServletContext()\n          .getAttribute(JspHelper.CURRENT_CONF);\n      final PutImageParams parsedParams \u003d new PutImageParams(request, response,\n          conf);\n      final NameNodeMetrics metrics \u003d NameNode.getNameNodeMetrics();\n      final boolean checkRecentImageEnable;\n      Object checkRecentImageEnableObj \u003d\n          context.getAttribute(RECENT_IMAGE_CHECK_ENABLED);\n      if (checkRecentImageEnableObj !\u003d null) {\n        if (checkRecentImageEnableObj instanceof Boolean) {\n          checkRecentImageEnable \u003d (boolean) checkRecentImageEnableObj;\n        } else {\n          // This is an error case, but crashing NN due to this\n          // seems more undesirable. Only log the error and set to default.\n          LOG.error(\"Expecting boolean obj for setting checking recent image, \"\n              + \"but got \" + checkRecentImageEnableObj.getClass() + \". This is \"\n              + \"unexpected! Setting to default.\");\n          checkRecentImageEnable \u003d RECENT_IMAGE_CHECK_ENABLED_DEFAULT;\n        }\n      } else {\n        checkRecentImageEnable \u003d RECENT_IMAGE_CHECK_ENABLED_DEFAULT;\n      }\n\n      validateRequest(context, conf, request, response, nnImage,\n          parsedParams.getStorageInfoString());\n\n      UserGroupInformation.getCurrentUser().doAs(\n          new PrivilegedExceptionAction\u003cVoid\u003e() {\n\n            @Override\n            public Void run() throws Exception {\n              // if its not the active NN, then we need to notify the caller it was was the wrong\n              // target (regardless of the fact that we got the image)\n              HAServiceProtocol.HAServiceState state \u003d NameNodeHttpServer\n                  .getNameNodeStateFromContext(getServletContext());\n              if (state !\u003d HAServiceProtocol.HAServiceState.ACTIVE \u0026\u0026\n                  state !\u003d HAServiceProtocol.HAServiceState.OBSERVER) {\n                // we need a different response type here so the client can differentiate this\n                // from the failure to upload due to (1) security, or (2) other checkpoints already\n                // present\n                response.sendError(HttpServletResponse.SC_EXPECTATION_FAILED,\n                    \"Nameode \"+request.getLocalAddr()+\" is currently not in a state which can \"\n                        + \"accept uploads of new fsimages. State: \"+state);\n                return null;\n              }\n\n              final long txid \u003d parsedParams.getTxId();\n              String remoteAddr \u003d request.getRemoteAddr();\n              ImageUploadRequest imageRequest \u003d new ImageUploadRequest(txid, remoteAddr);\n\n              final NameNodeFile nnf \u003d parsedParams.getNameNodeFile();\n\n              // if the node is attempting to upload an older transaction, we ignore it\n              SortedSet\u003cImageUploadRequest\u003e larger \u003d currentlyDownloadingCheckpoints.tailSet(imageRequest);\n              if (larger.size() \u003e 0) {\n                response.sendError(HttpServletResponse.SC_CONFLICT,\n                    \"Another checkpointer is already in the process of uploading a\" +\n                        \" checkpoint made up to transaction ID \" + larger.last());\n                return null;\n              }\n\n              //make sure no one else has started uploading one\n              if (!currentlyDownloadingCheckpoints.add(imageRequest)) {\n                response.sendError(HttpServletResponse.SC_CONFLICT,\n                    \"Either current namenode is checkpointing or another\"\n                        + \" checkpointer is already in the process of \"\n                        + \"uploading a checkpoint made at transaction ID \"\n                        + txid);\n                return null;\n              }\n\n              long now \u003d System.currentTimeMillis();\n              long lastCheckpointTime \u003d\n                  nnImage.getStorage().getMostRecentCheckpointTime();\n              long lastCheckpointTxid \u003d\n                  nnImage.getStorage().getMostRecentCheckpointTxId();\n\n              long checkpointPeriod \u003d\n                  conf.getTimeDuration(DFS_NAMENODE_CHECKPOINT_PERIOD_KEY,\n                      DFS_NAMENODE_CHECKPOINT_PERIOD_DEFAULT, TimeUnit.SECONDS);\n              long checkpointTxnCount \u003d\n                  conf.getLong(DFS_NAMENODE_CHECKPOINT_TXNS_KEY,\n                      DFS_NAMENODE_CHECKPOINT_TXNS_DEFAULT);\n\n              long timeDelta \u003d TimeUnit.MILLISECONDS.toSeconds(\n                  now - lastCheckpointTime);\n\n              if (checkRecentImageEnable \u0026\u0026\n                  timeDelta \u003c checkpointPeriod \u0026\u0026\n                  txid - lastCheckpointTxid \u003c checkpointTxnCount) {\n                // only when at least one of two conditions are met we accept\n                // a new fsImage\n                // 1. most recent image\u0027s txid is too far behind\n                // 2. last checkpoint time was too old\n                response.sendError(HttpServletResponse.SC_CONFLICT,\n                    \"Most recent checkpoint is neither too far behind in \"\n                        + \"txid, nor too old. New txnid cnt is \"\n                        + (txid - lastCheckpointTxid)\n                        + \", expecting at least \" + checkpointTxnCount\n                        + \" unless too long since last upload.\");\n                return null;\n              }\n\n              try {\n                if (nnImage.getStorage().findImageFile(nnf, txid) !\u003d null) {\n                  response.sendError(HttpServletResponse.SC_CONFLICT,\n                      \"Either current namenode has checkpointed or \"\n                          + \"another checkpointer already uploaded an \"\n                          + \"checkpoint for txid \" + txid);\n                  return null;\n                }\n\n                InputStream stream \u003d request.getInputStream();\n                try {\n                  long start \u003d monotonicNow();\n                  MD5Hash downloadImageDigest \u003d TransferFsImage\n                      .handleUploadImageRequest(request, txid,\n                          nnImage.getStorage(), stream,\n                          parsedParams.getFileSize(), getThrottler(conf));\n                  nnImage.saveDigestAndRenameCheckpointImage(nnf, txid,\n                      downloadImageDigest);\n                  // Metrics non-null only when used inside name node\n                  if (metrics !\u003d null) {\n                    long elapsed \u003d monotonicNow() - start;\n                    metrics.addPutImage(elapsed);\n                  }\n                  // Now that we have a new checkpoint, we might be able to\n                  // remove some old ones.\n                  nnImage.purgeOldStorage(nnf);\n                } finally {\n                  // remove the request once we\u0027ve processed it, or it threw an error, so we\n                  // aren\u0027t using it either\n                  currentlyDownloadingCheckpoints.remove(imageRequest);\n\n                  stream.close();\n                }\n              } finally {\n                nnImage.removeFromCheckpointing(txid);\n              }\n              return null;\n            }\n\n          });\n    } catch (Throwable t) {\n      String errMsg \u003d \"PutImage failed. \" + StringUtils.stringifyException(t);\n      response.sendError(HttpServletResponse.SC_GONE, errMsg);\n      throw new IOException(errMsg);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ImageServlet.java",
      "extendedDetails": {}
    },
    "49dfad942970459297f72632ed8dfd353e0c86de": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6440. Support more than 2 NameNodes. Contributed by Jesse Yates.\n",
      "commitDate": "23/06/15 5:26 PM",
      "commitName": "49dfad942970459297f72632ed8dfd353e0c86de",
      "commitAuthor": "Aaron T. Myers",
      "commitDateOld": "12/02/15 5:40 PM",
      "commitNameOld": "46b6d23e8fbed4c2ba537dd752116c173805bca7",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 130.95,
      "commitsBetweenForRepo": 1150,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,74 +1,103 @@\n   protected void doPut(final HttpServletRequest request,\n       final HttpServletResponse response) throws ServletException, IOException {\n     try {\n       ServletContext context \u003d getServletContext();\n       final FSImage nnImage \u003d NameNodeHttpServer.getFsImageFromContext(context);\n       final Configuration conf \u003d (Configuration) getServletContext()\n           .getAttribute(JspHelper.CURRENT_CONF);\n       final PutImageParams parsedParams \u003d new PutImageParams(request, response,\n           conf);\n       final NameNodeMetrics metrics \u003d NameNode.getNameNodeMetrics();\n \n       validateRequest(context, conf, request, response, nnImage,\n           parsedParams.getStorageInfoString());\n \n       UserGroupInformation.getCurrentUser().doAs(\n           new PrivilegedExceptionAction\u003cVoid\u003e() {\n \n             @Override\n             public Void run() throws Exception {\n+              // if its not the active NN, then we need to notify the caller it was was the wrong\n+              // target (regardless of the fact that we got the image)\n+              HAServiceProtocol.HAServiceState state \u003d NameNodeHttpServer\n+                  .getNameNodeStateFromContext(getServletContext());\n+              if (state !\u003d HAServiceProtocol.HAServiceState.ACTIVE) {\n+                // we need a different response type here so the client can differentiate this\n+                // from the failure to upload due to (1) security, or (2) other checkpoints already\n+                // present\n+                response.sendError(HttpServletResponse.SC_EXPECTATION_FAILED,\n+                    \"Nameode \"+request.getLocalAddr()+\" is currently not in a state which can \"\n+                        + \"accept uploads of new fsimages. State: \"+state);\n+                return null;\n+              }\n \n               final long txid \u003d parsedParams.getTxId();\n+              String remoteAddr \u003d request.getRemoteAddr();\n+              ImageUploadRequest imageRequest \u003d new ImageUploadRequest(txid, remoteAddr);\n \n               final NameNodeFile nnf \u003d parsedParams.getNameNodeFile();\n \n-              if (!nnImage.addToCheckpointing(txid)) {\n+              // if the node is attempting to upload an older transaction, we ignore it\n+              SortedSet\u003cImageUploadRequest\u003e larger \u003d currentlyDownloadingCheckpoints.tailSet(imageRequest);\n+              if (larger.size() \u003e 0) {\n+                response.sendError(HttpServletResponse.SC_CONFLICT,\n+                    \"Another checkpointer is already in the process of uploading a\" +\n+                        \" checkpoint made up to transaction ID \" + larger.last());\n+                return null;\n+              }\n+\n+              //make sure no one else has started uploading one\n+              if (!currentlyDownloadingCheckpoints.add(imageRequest)) {\n                 response.sendError(HttpServletResponse.SC_CONFLICT,\n                     \"Either current namenode is checkpointing or another\"\n                         + \" checkpointer is already in the process of \"\n                         + \"uploading a checkpoint made at transaction ID \"\n                         + txid);\n                 return null;\n               }\n               try {\n                 if (nnImage.getStorage().findImageFile(nnf, txid) !\u003d null) {\n                   response.sendError(HttpServletResponse.SC_CONFLICT,\n                       \"Either current namenode has checkpointed or \"\n                           + \"another checkpointer already uploaded an \"\n                           + \"checkpoint for txid \" + txid);\n                   return null;\n                 }\n \n                 InputStream stream \u003d request.getInputStream();\n                 try {\n                   long start \u003d monotonicNow();\n                   MD5Hash downloadImageDigest \u003d TransferFsImage\n                       .handleUploadImageRequest(request, txid,\n                           nnImage.getStorage(), stream,\n                           parsedParams.getFileSize(), getThrottler(conf));\n                   nnImage.saveDigestAndRenameCheckpointImage(nnf, txid,\n                       downloadImageDigest);\n                   // Metrics non-null only when used inside name node\n                   if (metrics !\u003d null) {\n                     long elapsed \u003d monotonicNow() - start;\n                     metrics.addPutImage(elapsed);\n                   }\n                   // Now that we have a new checkpoint, we might be able to\n                   // remove some old ones.\n                   nnImage.purgeOldStorage(nnf);\n                 } finally {\n+                  // remove the request once we\u0027ve processed it, or it threw an error, so we\n+                  // aren\u0027t using it either\n+                  currentlyDownloadingCheckpoints.remove(imageRequest);\n+\n                   stream.close();\n                 }\n               } finally {\n                 nnImage.removeFromCheckpointing(txid);\n               }\n               return null;\n             }\n \n           });\n     } catch (Throwable t) {\n       String errMsg \u003d \"PutImage failed. \" + StringUtils.stringifyException(t);\n       response.sendError(HttpServletResponse.SC_GONE, errMsg);\n       throw new IOException(errMsg);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void doPut(final HttpServletRequest request,\n      final HttpServletResponse response) throws ServletException, IOException {\n    try {\n      ServletContext context \u003d getServletContext();\n      final FSImage nnImage \u003d NameNodeHttpServer.getFsImageFromContext(context);\n      final Configuration conf \u003d (Configuration) getServletContext()\n          .getAttribute(JspHelper.CURRENT_CONF);\n      final PutImageParams parsedParams \u003d new PutImageParams(request, response,\n          conf);\n      final NameNodeMetrics metrics \u003d NameNode.getNameNodeMetrics();\n\n      validateRequest(context, conf, request, response, nnImage,\n          parsedParams.getStorageInfoString());\n\n      UserGroupInformation.getCurrentUser().doAs(\n          new PrivilegedExceptionAction\u003cVoid\u003e() {\n\n            @Override\n            public Void run() throws Exception {\n              // if its not the active NN, then we need to notify the caller it was was the wrong\n              // target (regardless of the fact that we got the image)\n              HAServiceProtocol.HAServiceState state \u003d NameNodeHttpServer\n                  .getNameNodeStateFromContext(getServletContext());\n              if (state !\u003d HAServiceProtocol.HAServiceState.ACTIVE) {\n                // we need a different response type here so the client can differentiate this\n                // from the failure to upload due to (1) security, or (2) other checkpoints already\n                // present\n                response.sendError(HttpServletResponse.SC_EXPECTATION_FAILED,\n                    \"Nameode \"+request.getLocalAddr()+\" is currently not in a state which can \"\n                        + \"accept uploads of new fsimages. State: \"+state);\n                return null;\n              }\n\n              final long txid \u003d parsedParams.getTxId();\n              String remoteAddr \u003d request.getRemoteAddr();\n              ImageUploadRequest imageRequest \u003d new ImageUploadRequest(txid, remoteAddr);\n\n              final NameNodeFile nnf \u003d parsedParams.getNameNodeFile();\n\n              // if the node is attempting to upload an older transaction, we ignore it\n              SortedSet\u003cImageUploadRequest\u003e larger \u003d currentlyDownloadingCheckpoints.tailSet(imageRequest);\n              if (larger.size() \u003e 0) {\n                response.sendError(HttpServletResponse.SC_CONFLICT,\n                    \"Another checkpointer is already in the process of uploading a\" +\n                        \" checkpoint made up to transaction ID \" + larger.last());\n                return null;\n              }\n\n              //make sure no one else has started uploading one\n              if (!currentlyDownloadingCheckpoints.add(imageRequest)) {\n                response.sendError(HttpServletResponse.SC_CONFLICT,\n                    \"Either current namenode is checkpointing or another\"\n                        + \" checkpointer is already in the process of \"\n                        + \"uploading a checkpoint made at transaction ID \"\n                        + txid);\n                return null;\n              }\n              try {\n                if (nnImage.getStorage().findImageFile(nnf, txid) !\u003d null) {\n                  response.sendError(HttpServletResponse.SC_CONFLICT,\n                      \"Either current namenode has checkpointed or \"\n                          + \"another checkpointer already uploaded an \"\n                          + \"checkpoint for txid \" + txid);\n                  return null;\n                }\n\n                InputStream stream \u003d request.getInputStream();\n                try {\n                  long start \u003d monotonicNow();\n                  MD5Hash downloadImageDigest \u003d TransferFsImage\n                      .handleUploadImageRequest(request, txid,\n                          nnImage.getStorage(), stream,\n                          parsedParams.getFileSize(), getThrottler(conf));\n                  nnImage.saveDigestAndRenameCheckpointImage(nnf, txid,\n                      downloadImageDigest);\n                  // Metrics non-null only when used inside name node\n                  if (metrics !\u003d null) {\n                    long elapsed \u003d monotonicNow() - start;\n                    metrics.addPutImage(elapsed);\n                  }\n                  // Now that we have a new checkpoint, we might be able to\n                  // remove some old ones.\n                  nnImage.purgeOldStorage(nnf);\n                } finally {\n                  // remove the request once we\u0027ve processed it, or it threw an error, so we\n                  // aren\u0027t using it either\n                  currentlyDownloadingCheckpoints.remove(imageRequest);\n\n                  stream.close();\n                }\n              } finally {\n                nnImage.removeFromCheckpointing(txid);\n              }\n              return null;\n            }\n\n          });\n    } catch (Throwable t) {\n      String errMsg \u003d \"PutImage failed. \" + StringUtils.stringifyException(t);\n      response.sendError(HttpServletResponse.SC_GONE, errMsg);\n      throw new IOException(errMsg);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ImageServlet.java",
      "extendedDetails": {}
    },
    "d3268c4b10a0f728b554ddb6d69b666a9ca13f12": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3519. Checkpoint upload may interfere with a concurrent saveNamespace. Contributed by Ming Ma.\n",
      "commitDate": "22/01/15 4:26 PM",
      "commitName": "d3268c4b10a0f728b554ddb6d69b666a9ca13f12",
      "commitAuthor": "cnauroth",
      "commitDateOld": "05/11/14 3:09 PM",
      "commitNameOld": "ba1d4ad25b301f7247f3f23df15e7f800e50feed",
      "commitAuthorOld": "cnauroth",
      "daysBetweenCommits": 78.05,
      "commitsBetweenForRepo": 508,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,71 +1,74 @@\n   protected void doPut(final HttpServletRequest request,\n       final HttpServletResponse response) throws ServletException, IOException {\n     try {\n       ServletContext context \u003d getServletContext();\n       final FSImage nnImage \u003d NameNodeHttpServer.getFsImageFromContext(context);\n       final Configuration conf \u003d (Configuration) getServletContext()\n           .getAttribute(JspHelper.CURRENT_CONF);\n       final PutImageParams parsedParams \u003d new PutImageParams(request, response,\n           conf);\n       final NameNodeMetrics metrics \u003d NameNode.getNameNodeMetrics();\n \n       validateRequest(context, conf, request, response, nnImage,\n           parsedParams.getStorageInfoString());\n \n       UserGroupInformation.getCurrentUser().doAs(\n           new PrivilegedExceptionAction\u003cVoid\u003e() {\n \n             @Override\n             public Void run() throws Exception {\n \n               final long txid \u003d parsedParams.getTxId();\n \n               final NameNodeFile nnf \u003d parsedParams.getNameNodeFile();\n \n-              if (!currentlyDownloadingCheckpoints.add(txid)) {\n+              if (!nnImage.addToCheckpointing(txid)) {\n                 response.sendError(HttpServletResponse.SC_CONFLICT,\n-                    \"Another checkpointer is already in the process of uploading a\"\n-                        + \" checkpoint made at transaction ID \" + txid);\n+                    \"Either current namenode is checkpointing or another\"\n+                        + \" checkpointer is already in the process of \"\n+                        + \"uploading a checkpoint made at transaction ID \"\n+                        + txid);\n                 return null;\n               }\n               try {\n                 if (nnImage.getStorage().findImageFile(nnf, txid) !\u003d null) {\n                   response.sendError(HttpServletResponse.SC_CONFLICT,\n-                      \"Another checkpointer already uploaded an checkpoint \"\n-                          + \"for txid \" + txid);\n+                      \"Either current namenode has checkpointed or \"\n+                          + \"another checkpointer already uploaded an \"\n+                          + \"checkpoint for txid \" + txid);\n                   return null;\n                 }\n \n                 InputStream stream \u003d request.getInputStream();\n                 try {\n                   long start \u003d monotonicNow();\n                   MD5Hash downloadImageDigest \u003d TransferFsImage\n                       .handleUploadImageRequest(request, txid,\n                           nnImage.getStorage(), stream,\n                           parsedParams.getFileSize(), getThrottler(conf));\n                   nnImage.saveDigestAndRenameCheckpointImage(nnf, txid,\n                       downloadImageDigest);\n                   // Metrics non-null only when used inside name node\n                   if (metrics !\u003d null) {\n                     long elapsed \u003d monotonicNow() - start;\n                     metrics.addPutImage(elapsed);\n                   }\n                   // Now that we have a new checkpoint, we might be able to\n                   // remove some old ones.\n                   nnImage.purgeOldStorage(nnf);\n                 } finally {\n                   stream.close();\n                 }\n               } finally {\n-                currentlyDownloadingCheckpoints.remove(txid);\n+                nnImage.removeFromCheckpointing(txid);\n               }\n               return null;\n             }\n \n           });\n     } catch (Throwable t) {\n       String errMsg \u003d \"PutImage failed. \" + StringUtils.stringifyException(t);\n       response.sendError(HttpServletResponse.SC_GONE, errMsg);\n       throw new IOException(errMsg);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void doPut(final HttpServletRequest request,\n      final HttpServletResponse response) throws ServletException, IOException {\n    try {\n      ServletContext context \u003d getServletContext();\n      final FSImage nnImage \u003d NameNodeHttpServer.getFsImageFromContext(context);\n      final Configuration conf \u003d (Configuration) getServletContext()\n          .getAttribute(JspHelper.CURRENT_CONF);\n      final PutImageParams parsedParams \u003d new PutImageParams(request, response,\n          conf);\n      final NameNodeMetrics metrics \u003d NameNode.getNameNodeMetrics();\n\n      validateRequest(context, conf, request, response, nnImage,\n          parsedParams.getStorageInfoString());\n\n      UserGroupInformation.getCurrentUser().doAs(\n          new PrivilegedExceptionAction\u003cVoid\u003e() {\n\n            @Override\n            public Void run() throws Exception {\n\n              final long txid \u003d parsedParams.getTxId();\n\n              final NameNodeFile nnf \u003d parsedParams.getNameNodeFile();\n\n              if (!nnImage.addToCheckpointing(txid)) {\n                response.sendError(HttpServletResponse.SC_CONFLICT,\n                    \"Either current namenode is checkpointing or another\"\n                        + \" checkpointer is already in the process of \"\n                        + \"uploading a checkpoint made at transaction ID \"\n                        + txid);\n                return null;\n              }\n              try {\n                if (nnImage.getStorage().findImageFile(nnf, txid) !\u003d null) {\n                  response.sendError(HttpServletResponse.SC_CONFLICT,\n                      \"Either current namenode has checkpointed or \"\n                          + \"another checkpointer already uploaded an \"\n                          + \"checkpoint for txid \" + txid);\n                  return null;\n                }\n\n                InputStream stream \u003d request.getInputStream();\n                try {\n                  long start \u003d monotonicNow();\n                  MD5Hash downloadImageDigest \u003d TransferFsImage\n                      .handleUploadImageRequest(request, txid,\n                          nnImage.getStorage(), stream,\n                          parsedParams.getFileSize(), getThrottler(conf));\n                  nnImage.saveDigestAndRenameCheckpointImage(nnf, txid,\n                      downloadImageDigest);\n                  // Metrics non-null only when used inside name node\n                  if (metrics !\u003d null) {\n                    long elapsed \u003d monotonicNow() - start;\n                    metrics.addPutImage(elapsed);\n                  }\n                  // Now that we have a new checkpoint, we might be able to\n                  // remove some old ones.\n                  nnImage.purgeOldStorage(nnf);\n                } finally {\n                  stream.close();\n                }\n              } finally {\n                nnImage.removeFromCheckpointing(txid);\n              }\n              return null;\n            }\n\n          });\n    } catch (Throwable t) {\n      String errMsg \u003d \"PutImage failed. \" + StringUtils.stringifyException(t);\n      response.sendError(HttpServletResponse.SC_GONE, errMsg);\n      throw new IOException(errMsg);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ImageServlet.java",
      "extendedDetails": {}
    },
    "193f11a7ab539c360ecd9f2015c0f46cd070a875": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6236. ImageServlet should use Time#monotonicNow to measure latency. Contributed by Chris Nauroth.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1586902 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/04/14 2:38 PM",
      "commitName": "193f11a7ab539c360ecd9f2015c0f46cd070a875",
      "commitAuthor": "Chris Nauroth",
      "commitDateOld": "07/04/14 11:55 AM",
      "commitNameOld": "a5b37c6ed14e92f5a7f7dd76a9a82b3f859fb6dd",
      "commitAuthorOld": "Brandon Li",
      "daysBetweenCommits": 5.11,
      "commitsBetweenForRepo": 59,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,71 +1,71 @@\n   protected void doPut(final HttpServletRequest request,\n       final HttpServletResponse response) throws ServletException, IOException {\n     try {\n       ServletContext context \u003d getServletContext();\n       final FSImage nnImage \u003d NameNodeHttpServer.getFsImageFromContext(context);\n       final Configuration conf \u003d (Configuration) getServletContext()\n           .getAttribute(JspHelper.CURRENT_CONF);\n       final PutImageParams parsedParams \u003d new PutImageParams(request, response,\n           conf);\n       final NameNodeMetrics metrics \u003d NameNode.getNameNodeMetrics();\n \n       validateRequest(context, conf, request, response, nnImage,\n           parsedParams.getStorageInfoString());\n \n       UserGroupInformation.getCurrentUser().doAs(\n           new PrivilegedExceptionAction\u003cVoid\u003e() {\n \n             @Override\n             public Void run() throws Exception {\n \n               final long txid \u003d parsedParams.getTxId();\n \n               final NameNodeFile nnf \u003d parsedParams.getNameNodeFile();\n \n               if (!currentlyDownloadingCheckpoints.add(txid)) {\n                 response.sendError(HttpServletResponse.SC_CONFLICT,\n                     \"Another checkpointer is already in the process of uploading a\"\n                         + \" checkpoint made at transaction ID \" + txid);\n                 return null;\n               }\n               try {\n                 if (nnImage.getStorage().findImageFile(nnf, txid) !\u003d null) {\n                   response.sendError(HttpServletResponse.SC_CONFLICT,\n                       \"Another checkpointer already uploaded an checkpoint \"\n                           + \"for txid \" + txid);\n                   return null;\n                 }\n \n                 InputStream stream \u003d request.getInputStream();\n                 try {\n-                  long start \u003d now();\n+                  long start \u003d monotonicNow();\n                   MD5Hash downloadImageDigest \u003d TransferFsImage\n                       .handleUploadImageRequest(request, txid,\n                           nnImage.getStorage(), stream,\n                           parsedParams.getFileSize(), getThrottler(conf));\n                   nnImage.saveDigestAndRenameCheckpointImage(nnf, txid,\n                       downloadImageDigest);\n                   // Metrics non-null only when used inside name node\n                   if (metrics !\u003d null) {\n-                    long elapsed \u003d now() - start;\n+                    long elapsed \u003d monotonicNow() - start;\n                     metrics.addPutImage(elapsed);\n                   }\n                   // Now that we have a new checkpoint, we might be able to\n                   // remove some old ones.\n                   nnImage.purgeOldStorage(nnf);\n                 } finally {\n                   stream.close();\n                 }\n               } finally {\n                 currentlyDownloadingCheckpoints.remove(txid);\n               }\n               return null;\n             }\n \n           });\n     } catch (Throwable t) {\n       String errMsg \u003d \"PutImage failed. \" + StringUtils.stringifyException(t);\n       response.sendError(HttpServletResponse.SC_GONE, errMsg);\n       throw new IOException(errMsg);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void doPut(final HttpServletRequest request,\n      final HttpServletResponse response) throws ServletException, IOException {\n    try {\n      ServletContext context \u003d getServletContext();\n      final FSImage nnImage \u003d NameNodeHttpServer.getFsImageFromContext(context);\n      final Configuration conf \u003d (Configuration) getServletContext()\n          .getAttribute(JspHelper.CURRENT_CONF);\n      final PutImageParams parsedParams \u003d new PutImageParams(request, response,\n          conf);\n      final NameNodeMetrics metrics \u003d NameNode.getNameNodeMetrics();\n\n      validateRequest(context, conf, request, response, nnImage,\n          parsedParams.getStorageInfoString());\n\n      UserGroupInformation.getCurrentUser().doAs(\n          new PrivilegedExceptionAction\u003cVoid\u003e() {\n\n            @Override\n            public Void run() throws Exception {\n\n              final long txid \u003d parsedParams.getTxId();\n\n              final NameNodeFile nnf \u003d parsedParams.getNameNodeFile();\n\n              if (!currentlyDownloadingCheckpoints.add(txid)) {\n                response.sendError(HttpServletResponse.SC_CONFLICT,\n                    \"Another checkpointer is already in the process of uploading a\"\n                        + \" checkpoint made at transaction ID \" + txid);\n                return null;\n              }\n              try {\n                if (nnImage.getStorage().findImageFile(nnf, txid) !\u003d null) {\n                  response.sendError(HttpServletResponse.SC_CONFLICT,\n                      \"Another checkpointer already uploaded an checkpoint \"\n                          + \"for txid \" + txid);\n                  return null;\n                }\n\n                InputStream stream \u003d request.getInputStream();\n                try {\n                  long start \u003d monotonicNow();\n                  MD5Hash downloadImageDigest \u003d TransferFsImage\n                      .handleUploadImageRequest(request, txid,\n                          nnImage.getStorage(), stream,\n                          parsedParams.getFileSize(), getThrottler(conf));\n                  nnImage.saveDigestAndRenameCheckpointImage(nnf, txid,\n                      downloadImageDigest);\n                  // Metrics non-null only when used inside name node\n                  if (metrics !\u003d null) {\n                    long elapsed \u003d monotonicNow() - start;\n                    metrics.addPutImage(elapsed);\n                  }\n                  // Now that we have a new checkpoint, we might be able to\n                  // remove some old ones.\n                  nnImage.purgeOldStorage(nnf);\n                } finally {\n                  stream.close();\n                }\n              } finally {\n                currentlyDownloadingCheckpoints.remove(txid);\n              }\n              return null;\n            }\n\n          });\n    } catch (Throwable t) {\n      String errMsg \u003d \"PutImage failed. \" + StringUtils.stringifyException(t);\n      response.sendError(HttpServletResponse.SC_GONE, errMsg);\n      throw new IOException(errMsg);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ImageServlet.java",
      "extendedDetails": {}
    },
    "94a1632fcb677fda6f4d812614026417f1d0a360": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-3405. Checkpointing should use HTTP POST or PUT instead of GET-GET to send merged fsimages. Contributed by Vinayakumar B.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1575611 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/03/14 1:25 PM",
      "commitName": "94a1632fcb677fda6f4d812614026417f1d0a360",
      "commitAuthor": "Andrew Wang",
      "diff": "@@ -0,0 +1,71 @@\n+  protected void doPut(final HttpServletRequest request,\n+      final HttpServletResponse response) throws ServletException, IOException {\n+    try {\n+      ServletContext context \u003d getServletContext();\n+      final FSImage nnImage \u003d NameNodeHttpServer.getFsImageFromContext(context);\n+      final Configuration conf \u003d (Configuration) getServletContext()\n+          .getAttribute(JspHelper.CURRENT_CONF);\n+      final PutImageParams parsedParams \u003d new PutImageParams(request, response,\n+          conf);\n+      final NameNodeMetrics metrics \u003d NameNode.getNameNodeMetrics();\n+\n+      validateRequest(context, conf, request, response, nnImage,\n+          parsedParams.getStorageInfoString());\n+\n+      UserGroupInformation.getCurrentUser().doAs(\n+          new PrivilegedExceptionAction\u003cVoid\u003e() {\n+\n+            @Override\n+            public Void run() throws Exception {\n+\n+              final long txid \u003d parsedParams.getTxId();\n+\n+              final NameNodeFile nnf \u003d parsedParams.getNameNodeFile();\n+\n+              if (!currentlyDownloadingCheckpoints.add(txid)) {\n+                response.sendError(HttpServletResponse.SC_CONFLICT,\n+                    \"Another checkpointer is already in the process of uploading a\"\n+                        + \" checkpoint made at transaction ID \" + txid);\n+                return null;\n+              }\n+              try {\n+                if (nnImage.getStorage().findImageFile(nnf, txid) !\u003d null) {\n+                  response.sendError(HttpServletResponse.SC_CONFLICT,\n+                      \"Another checkpointer already uploaded an checkpoint \"\n+                          + \"for txid \" + txid);\n+                  return null;\n+                }\n+\n+                InputStream stream \u003d request.getInputStream();\n+                try {\n+                  long start \u003d now();\n+                  MD5Hash downloadImageDigest \u003d TransferFsImage\n+                      .handleUploadImageRequest(request, txid,\n+                          nnImage.getStorage(), stream,\n+                          parsedParams.getFileSize(), getThrottler(conf));\n+                  nnImage.saveDigestAndRenameCheckpointImage(nnf, txid,\n+                      downloadImageDigest);\n+                  // Metrics non-null only when used inside name node\n+                  if (metrics !\u003d null) {\n+                    long elapsed \u003d now() - start;\n+                    metrics.addPutImage(elapsed);\n+                  }\n+                  // Now that we have a new checkpoint, we might be able to\n+                  // remove some old ones.\n+                  nnImage.purgeOldStorage(nnf);\n+                } finally {\n+                  stream.close();\n+                }\n+              } finally {\n+                currentlyDownloadingCheckpoints.remove(txid);\n+              }\n+              return null;\n+            }\n+\n+          });\n+    } catch (Throwable t) {\n+      String errMsg \u003d \"PutImage failed. \" + StringUtils.stringifyException(t);\n+      response.sendError(HttpServletResponse.SC_GONE, errMsg);\n+      throw new IOException(errMsg);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  protected void doPut(final HttpServletRequest request,\n      final HttpServletResponse response) throws ServletException, IOException {\n    try {\n      ServletContext context \u003d getServletContext();\n      final FSImage nnImage \u003d NameNodeHttpServer.getFsImageFromContext(context);\n      final Configuration conf \u003d (Configuration) getServletContext()\n          .getAttribute(JspHelper.CURRENT_CONF);\n      final PutImageParams parsedParams \u003d new PutImageParams(request, response,\n          conf);\n      final NameNodeMetrics metrics \u003d NameNode.getNameNodeMetrics();\n\n      validateRequest(context, conf, request, response, nnImage,\n          parsedParams.getStorageInfoString());\n\n      UserGroupInformation.getCurrentUser().doAs(\n          new PrivilegedExceptionAction\u003cVoid\u003e() {\n\n            @Override\n            public Void run() throws Exception {\n\n              final long txid \u003d parsedParams.getTxId();\n\n              final NameNodeFile nnf \u003d parsedParams.getNameNodeFile();\n\n              if (!currentlyDownloadingCheckpoints.add(txid)) {\n                response.sendError(HttpServletResponse.SC_CONFLICT,\n                    \"Another checkpointer is already in the process of uploading a\"\n                        + \" checkpoint made at transaction ID \" + txid);\n                return null;\n              }\n              try {\n                if (nnImage.getStorage().findImageFile(nnf, txid) !\u003d null) {\n                  response.sendError(HttpServletResponse.SC_CONFLICT,\n                      \"Another checkpointer already uploaded an checkpoint \"\n                          + \"for txid \" + txid);\n                  return null;\n                }\n\n                InputStream stream \u003d request.getInputStream();\n                try {\n                  long start \u003d now();\n                  MD5Hash downloadImageDigest \u003d TransferFsImage\n                      .handleUploadImageRequest(request, txid,\n                          nnImage.getStorage(), stream,\n                          parsedParams.getFileSize(), getThrottler(conf));\n                  nnImage.saveDigestAndRenameCheckpointImage(nnf, txid,\n                      downloadImageDigest);\n                  // Metrics non-null only when used inside name node\n                  if (metrics !\u003d null) {\n                    long elapsed \u003d now() - start;\n                    metrics.addPutImage(elapsed);\n                  }\n                  // Now that we have a new checkpoint, we might be able to\n                  // remove some old ones.\n                  nnImage.purgeOldStorage(nnf);\n                } finally {\n                  stream.close();\n                }\n              } finally {\n                currentlyDownloadingCheckpoints.remove(txid);\n              }\n              return null;\n            }\n\n          });\n    } catch (Throwable t) {\n      String errMsg \u003d \"PutImage failed. \" + StringUtils.stringifyException(t);\n      response.sendError(HttpServletResponse.SC_GONE, errMsg);\n      throw new IOException(errMsg);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ImageServlet.java"
    }
  }
}