{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "AbstractSchedulerPlanFollower.java",
  "functionName": "synchronizePlan",
  "functionId": "synchronizePlan___plan-Plan__shouldReplan-boolean",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/AbstractSchedulerPlanFollower.java",
  "functionStartLine": 74,
  "functionEndLine": 216,
  "numCommitsSeen": 14,
  "timeTaken": 5715,
  "changeHistory": [
    "2064ca015d1584263aac0cc20c60b925a3aff612",
    "b6e7d1369690eaf50ce9ea7968f91a72ecb74de0",
    "e3345e985bff93c6c74a76747e45376c6027f42c",
    "7996eca7dcfaa1bdf970e32022274f2699bef8a1",
    "42f90ab885d9693fcc1e52f9637f7de4111110ae",
    "2798723a5443d04455b9d79c48d61f435ab52267",
    "0c4b11267717eb451fa6ed4c586317f2db32fbd5",
    "e7257acd8a7adb74d81cd1d009d4a99f023ed844",
    "f2ea555ac6c06a3f2f6559731f48711fff05d3f1",
    "3418c56bcf4bbddaf483bdaa1a15a8bbc4039bfe"
  ],
  "changeHistoryShort": {
    "2064ca015d1584263aac0cc20c60b925a3aff612": "Ybodychange",
    "b6e7d1369690eaf50ce9ea7968f91a72ecb74de0": "Ybodychange",
    "e3345e985bff93c6c74a76747e45376c6027f42c": "Ybodychange",
    "7996eca7dcfaa1bdf970e32022274f2699bef8a1": "Ybodychange",
    "42f90ab885d9693fcc1e52f9637f7de4111110ae": "Ybodychange",
    "2798723a5443d04455b9d79c48d61f435ab52267": "Ymultichange(Yparameterchange,Ybodychange)",
    "0c4b11267717eb451fa6ed4c586317f2db32fbd5": "Ybodychange",
    "e7257acd8a7adb74d81cd1d009d4a99f023ed844": "Ymultichange(Ymovefromfile,Ybodychange)",
    "f2ea555ac6c06a3f2f6559731f48711fff05d3f1": "Ybodychange",
    "3418c56bcf4bbddaf483bdaa1a15a8bbc4039bfe": "Yintroduced"
  },
  "changeHistoryDetails": {
    "2064ca015d1584263aac0cc20c60b925a3aff612": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9349.  Changed logging to use slf4j api.\n            Contributed by Prabhu Joseph\n",
      "commitDate": "15/03/19 4:20 PM",
      "commitName": "2064ca015d1584263aac0cc20c60b925a3aff612",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "16/04/18 5:32 PM",
      "commitNameOld": "f1461b2487d6c7a0b87e3799a8fdb5ade40ad898",
      "commitAuthorOld": "Inigo Goiri",
      "daysBetweenCommits": 332.95,
      "commitsBetweenForRepo": 3107,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,149 +1,143 @@\n   public synchronized void synchronizePlan(Plan plan, boolean shouldReplan) {\n     String planQueueName \u003d plan.getQueueName();\n-    if (LOG.isDebugEnabled()) {\n-      LOG.debug(\"Running plan follower edit policy for plan: \" + planQueueName);\n-    }\n+    LOG.debug(\"Running plan follower edit policy for plan: {}\", planQueueName);\n     // align with plan step\n     long step \u003d plan.getStep();\n     long now \u003d clock.getTime();\n     if (now % step !\u003d 0) {\n       now +\u003d step - (now % step);\n     }\n     Queue planQueue \u003d getPlanQueue(planQueueName);\n     if (planQueue \u003d\u003d null) {\n       return;\n     }\n \n     // first we publish to the plan the current availability of resources\n     Resource clusterResources \u003d scheduler.getClusterResource();\n     Resource planResources \u003d\n         getPlanResources(plan, planQueue, clusterResources);\n     Set\u003cReservationAllocation\u003e currentReservations \u003d\n         plan.getReservationsAtTime(now);\n     Set\u003cString\u003e curReservationNames \u003d new HashSet\u003cString\u003e();\n     Resource reservedResources \u003d Resource.newInstance(0, 0);\n     int numRes \u003d getReservedResources(now, currentReservations,\n         curReservationNames, reservedResources);\n     // create the default reservation queue if it doesnt exist\n     String defReservationId \u003d getReservationIdFromQueueName(planQueueName)\n         + ReservationConstants.DEFAULT_QUEUE_SUFFIX;\n     String defReservationQueue \u003d\n         getReservationQueueName(planQueueName, defReservationId);\n     createDefaultReservationQueue(planQueueName, planQueue, defReservationId);\n     curReservationNames.add(defReservationId);\n     // if the resources dedicated to this plan has shrunk invoke replanner\n     boolean shouldResize \u003d false;\n     if (arePlanResourcesLessThanReservations(plan.getResourceCalculator(),\n         clusterResources, planResources, reservedResources)) {\n       if (shouldReplan) {\n         try {\n           plan.getReplanner().plan(plan, null);\n         } catch (PlanningException e) {\n           LOG.warn(\"Exception while trying to replan: {}\", planQueueName, e);\n         }\n       } else {\n         shouldResize \u003d true;\n       }\n     }\n     // identify the reservations that have expired and new reservations that\n     // have to be activated\n     List\u003c? extends Queue\u003e resQueues \u003d getChildReservationQueues(planQueue);\n     Set\u003cString\u003e expired \u003d new HashSet\u003cString\u003e();\n     for (Queue resQueue : resQueues) {\n       String resQueueName \u003d resQueue.getQueueName();\n       String reservationId \u003d getReservationIdFromQueueName(resQueueName);\n       if (curReservationNames.contains(reservationId)) {\n         // it is already existing reservation, so needed not create new\n         // reservation queue\n         curReservationNames.remove(reservationId);\n       } else {\n         // the reservation has termination, mark for cleanup\n         expired.add(reservationId);\n       }\n     }\n     // garbage collect expired reservations\n     cleanupExpiredQueues(planQueueName, plan.getMoveOnExpiry(), expired,\n         defReservationQueue);\n     // Add new reservations and update existing ones\n     float totalAssignedCapacity \u003d 0f;\n     if (currentReservations !\u003d null) {\n       // first release all excess capacity in default queue\n       try {\n         setQueueEntitlement(planQueueName, defReservationQueue, 0f, 1.0f);\n       } catch (YarnException e) {\n         LOG.warn(\n             \"Exception while trying to release default queue capacity for plan: {}\",\n             planQueueName, e);\n       }\n       // sort allocations from the one giving up the most resources, to the\n       // one asking for the most avoid order-of-operation errors that\n       // temporarily violate 100% capacity bound\n       List\u003cReservationAllocation\u003e sortedAllocations \u003d sortByDelta(\n           new ArrayList\u003cReservationAllocation\u003e(currentReservations), now, plan);\n       for (ReservationAllocation res : sortedAllocations) {\n         String currResId \u003d res.getReservationId().toString();\n         if (curReservationNames.contains(currResId)) {\n           addReservationQueue(planQueueName, planQueue, currResId);\n         }\n         Resource capToAssign \u003d res.getResourcesAtTime(now);\n         float targetCapacity \u003d 0f;\n         if (planResources.getMemorySize() \u003e 0\n             \u0026\u0026 planResources.getVirtualCores() \u003e 0) {\n           if (shouldResize) {\n             capToAssign \u003d calculateReservationToPlanProportion(\n                 plan.getResourceCalculator(), planResources, reservedResources,\n                 capToAssign);\n           }\n           targetCapacity \u003d\n               calculateReservationToPlanRatio(plan.getResourceCalculator(),\n                   clusterResources, planResources, capToAssign);\n         }\n-        if (LOG.isDebugEnabled()) {\n-          LOG.debug(\n+        LOG.debug(\n               \"Assigning capacity of {} to queue {} with target capacity {}\",\n               capToAssign, currResId, targetCapacity);\n-        }\n         // set maxCapacity to 100% unless the job requires gang, in which\n         // case we stick to capacity (as running early/before is likely a\n         // waste of resources)\n         float maxCapacity \u003d 1.0f;\n         if (res.containsGangs()) {\n           maxCapacity \u003d targetCapacity;\n         }\n         try {\n           setQueueEntitlement(planQueueName, currResId, targetCapacity,\n               maxCapacity);\n         } catch (YarnException e) {\n           LOG.warn(\"Exception while trying to size reservation for plan: {}\",\n               currResId, planQueueName, e);\n         }\n         totalAssignedCapacity +\u003d targetCapacity;\n       }\n     }\n     // compute the default queue capacity\n     float defQCap \u003d 1.0f - totalAssignedCapacity;\n-    if (LOG.isDebugEnabled()) {\n-      LOG.debug(\n+    LOG.debug(\n           \"PlanFollowerEditPolicyTask: total Plan Capacity: {} \"\n               + \"currReservation: {} default-queue capacity: {}\",\n           planResources, numRes, defQCap);\n-    }\n     // set the default queue to eat-up all remaining capacity\n     try {\n       setQueueEntitlement(planQueueName, defReservationQueue, defQCap, 1.0f);\n     } catch (YarnException e) {\n       LOG.warn(\n           \"Exception while trying to reclaim default queue capacity for plan: {}\",\n           planQueueName, e);\n     }\n     // garbage collect finished reservations from plan\n     try {\n       plan.archiveCompletedReservations(now);\n     } catch (PlanningException e) {\n       LOG.error(\"Exception in archiving completed reservations: \", e);\n     }\n     LOG.info(\"Finished iteration of plan follower edit policy for plan: \"\n         + planQueueName);\n     // Extension: update plan with app states,\n     // useful to support smart replanning\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void synchronizePlan(Plan plan, boolean shouldReplan) {\n    String planQueueName \u003d plan.getQueueName();\n    LOG.debug(\"Running plan follower edit policy for plan: {}\", planQueueName);\n    // align with plan step\n    long step \u003d plan.getStep();\n    long now \u003d clock.getTime();\n    if (now % step !\u003d 0) {\n      now +\u003d step - (now % step);\n    }\n    Queue planQueue \u003d getPlanQueue(planQueueName);\n    if (planQueue \u003d\u003d null) {\n      return;\n    }\n\n    // first we publish to the plan the current availability of resources\n    Resource clusterResources \u003d scheduler.getClusterResource();\n    Resource planResources \u003d\n        getPlanResources(plan, planQueue, clusterResources);\n    Set\u003cReservationAllocation\u003e currentReservations \u003d\n        plan.getReservationsAtTime(now);\n    Set\u003cString\u003e curReservationNames \u003d new HashSet\u003cString\u003e();\n    Resource reservedResources \u003d Resource.newInstance(0, 0);\n    int numRes \u003d getReservedResources(now, currentReservations,\n        curReservationNames, reservedResources);\n    // create the default reservation queue if it doesnt exist\n    String defReservationId \u003d getReservationIdFromQueueName(planQueueName)\n        + ReservationConstants.DEFAULT_QUEUE_SUFFIX;\n    String defReservationQueue \u003d\n        getReservationQueueName(planQueueName, defReservationId);\n    createDefaultReservationQueue(planQueueName, planQueue, defReservationId);\n    curReservationNames.add(defReservationId);\n    // if the resources dedicated to this plan has shrunk invoke replanner\n    boolean shouldResize \u003d false;\n    if (arePlanResourcesLessThanReservations(plan.getResourceCalculator(),\n        clusterResources, planResources, reservedResources)) {\n      if (shouldReplan) {\n        try {\n          plan.getReplanner().plan(plan, null);\n        } catch (PlanningException e) {\n          LOG.warn(\"Exception while trying to replan: {}\", planQueueName, e);\n        }\n      } else {\n        shouldResize \u003d true;\n      }\n    }\n    // identify the reservations that have expired and new reservations that\n    // have to be activated\n    List\u003c? extends Queue\u003e resQueues \u003d getChildReservationQueues(planQueue);\n    Set\u003cString\u003e expired \u003d new HashSet\u003cString\u003e();\n    for (Queue resQueue : resQueues) {\n      String resQueueName \u003d resQueue.getQueueName();\n      String reservationId \u003d getReservationIdFromQueueName(resQueueName);\n      if (curReservationNames.contains(reservationId)) {\n        // it is already existing reservation, so needed not create new\n        // reservation queue\n        curReservationNames.remove(reservationId);\n      } else {\n        // the reservation has termination, mark for cleanup\n        expired.add(reservationId);\n      }\n    }\n    // garbage collect expired reservations\n    cleanupExpiredQueues(planQueueName, plan.getMoveOnExpiry(), expired,\n        defReservationQueue);\n    // Add new reservations and update existing ones\n    float totalAssignedCapacity \u003d 0f;\n    if (currentReservations !\u003d null) {\n      // first release all excess capacity in default queue\n      try {\n        setQueueEntitlement(planQueueName, defReservationQueue, 0f, 1.0f);\n      } catch (YarnException e) {\n        LOG.warn(\n            \"Exception while trying to release default queue capacity for plan: {}\",\n            planQueueName, e);\n      }\n      // sort allocations from the one giving up the most resources, to the\n      // one asking for the most avoid order-of-operation errors that\n      // temporarily violate 100% capacity bound\n      List\u003cReservationAllocation\u003e sortedAllocations \u003d sortByDelta(\n          new ArrayList\u003cReservationAllocation\u003e(currentReservations), now, plan);\n      for (ReservationAllocation res : sortedAllocations) {\n        String currResId \u003d res.getReservationId().toString();\n        if (curReservationNames.contains(currResId)) {\n          addReservationQueue(planQueueName, planQueue, currResId);\n        }\n        Resource capToAssign \u003d res.getResourcesAtTime(now);\n        float targetCapacity \u003d 0f;\n        if (planResources.getMemorySize() \u003e 0\n            \u0026\u0026 planResources.getVirtualCores() \u003e 0) {\n          if (shouldResize) {\n            capToAssign \u003d calculateReservationToPlanProportion(\n                plan.getResourceCalculator(), planResources, reservedResources,\n                capToAssign);\n          }\n          targetCapacity \u003d\n              calculateReservationToPlanRatio(plan.getResourceCalculator(),\n                  clusterResources, planResources, capToAssign);\n        }\n        LOG.debug(\n              \"Assigning capacity of {} to queue {} with target capacity {}\",\n              capToAssign, currResId, targetCapacity);\n        // set maxCapacity to 100% unless the job requires gang, in which\n        // case we stick to capacity (as running early/before is likely a\n        // waste of resources)\n        float maxCapacity \u003d 1.0f;\n        if (res.containsGangs()) {\n          maxCapacity \u003d targetCapacity;\n        }\n        try {\n          setQueueEntitlement(planQueueName, currResId, targetCapacity,\n              maxCapacity);\n        } catch (YarnException e) {\n          LOG.warn(\"Exception while trying to size reservation for plan: {}\",\n              currResId, planQueueName, e);\n        }\n        totalAssignedCapacity +\u003d targetCapacity;\n      }\n    }\n    // compute the default queue capacity\n    float defQCap \u003d 1.0f - totalAssignedCapacity;\n    LOG.debug(\n          \"PlanFollowerEditPolicyTask: total Plan Capacity: {} \"\n              + \"currReservation: {} default-queue capacity: {}\",\n          planResources, numRes, defQCap);\n    // set the default queue to eat-up all remaining capacity\n    try {\n      setQueueEntitlement(planQueueName, defReservationQueue, defQCap, 1.0f);\n    } catch (YarnException e) {\n      LOG.warn(\n          \"Exception while trying to reclaim default queue capacity for plan: {}\",\n          planQueueName, e);\n    }\n    // garbage collect finished reservations from plan\n    try {\n      plan.archiveCompletedReservations(now);\n    } catch (PlanningException e) {\n      LOG.error(\"Exception in archiving completed reservations: \", e);\n    }\n    LOG.info(\"Finished iteration of plan follower edit policy for plan: \"\n        + planQueueName);\n    // Extension: update plan with app states,\n    // useful to support smart replanning\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/AbstractSchedulerPlanFollower.java",
      "extendedDetails": {}
    },
    "b6e7d1369690eaf50ce9ea7968f91a72ecb74de0": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5328. Plan/ResourceAllocation data structure enhancements required to support recurring reservations in ReservationSystem.\n",
      "commitDate": "06/09/17 4:46 PM",
      "commitName": "b6e7d1369690eaf50ce9ea7968f91a72ecb74de0",
      "commitAuthor": "Subru Krishnan",
      "commitDateOld": "06/09/17 4:39 PM",
      "commitNameOld": "e3345e985bff93c6c74a76747e45376c6027f42c",
      "commitAuthorOld": "Subru Krishnan",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,149 +1,149 @@\n   public synchronized void synchronizePlan(Plan plan, boolean shouldReplan) {\n-     String planQueueName \u003d plan.getQueueName();\n+    String planQueueName \u003d plan.getQueueName();\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Running plan follower edit policy for plan: \" + planQueueName);\n     }\n     // align with plan step\n     long step \u003d plan.getStep();\n     long now \u003d clock.getTime();\n     if (now % step !\u003d 0) {\n       now +\u003d step - (now % step);\n     }\n     Queue planQueue \u003d getPlanQueue(planQueueName);\n-    if (planQueue \u003d\u003d null) return;\n+    if (planQueue \u003d\u003d null) {\n+      return;\n+    }\n \n     // first we publish to the plan the current availability of resources\n     Resource clusterResources \u003d scheduler.getClusterResource();\n-    Resource planResources \u003d getPlanResources(plan, planQueue,\n-        clusterResources);\n+    Resource planResources \u003d\n+        getPlanResources(plan, planQueue, clusterResources);\n     Set\u003cReservationAllocation\u003e currentReservations \u003d\n         plan.getReservationsAtTime(now);\n     Set\u003cString\u003e curReservationNames \u003d new HashSet\u003cString\u003e();\n     Resource reservedResources \u003d Resource.newInstance(0, 0);\n     int numRes \u003d getReservedResources(now, currentReservations,\n         curReservationNames, reservedResources);\n     // create the default reservation queue if it doesnt exist\n-    String defReservationId \u003d getReservationIdFromQueueName(planQueueName) +\n-        ReservationConstants.DEFAULT_QUEUE_SUFFIX;\n-    String defReservationQueue \u003d getReservationQueueName(planQueueName,\n-        defReservationId);\n-    createDefaultReservationQueue(planQueueName, planQueue,\n-        defReservationId);\n+    String defReservationId \u003d getReservationIdFromQueueName(planQueueName)\n+        + ReservationConstants.DEFAULT_QUEUE_SUFFIX;\n+    String defReservationQueue \u003d\n+        getReservationQueueName(planQueueName, defReservationId);\n+    createDefaultReservationQueue(planQueueName, planQueue, defReservationId);\n     curReservationNames.add(defReservationId);\n     // if the resources dedicated to this plan has shrunk invoke replanner\n     boolean shouldResize \u003d false;\n     if (arePlanResourcesLessThanReservations(plan.getResourceCalculator(),\n         clusterResources, planResources, reservedResources)) {\n       if (shouldReplan) {\n         try {\n           plan.getReplanner().plan(plan, null);\n         } catch (PlanningException e) {\n           LOG.warn(\"Exception while trying to replan: {}\", planQueueName, e);\n         }\n       } else {\n         shouldResize \u003d true;\n       }\n     }\n     // identify the reservations that have expired and new reservations that\n     // have to be activated\n     List\u003c? extends Queue\u003e resQueues \u003d getChildReservationQueues(planQueue);\n     Set\u003cString\u003e expired \u003d new HashSet\u003cString\u003e();\n     for (Queue resQueue : resQueues) {\n       String resQueueName \u003d resQueue.getQueueName();\n       String reservationId \u003d getReservationIdFromQueueName(resQueueName);\n       if (curReservationNames.contains(reservationId)) {\n         // it is already existing reservation, so needed not create new\n         // reservation queue\n         curReservationNames.remove(reservationId);\n       } else {\n         // the reservation has termination, mark for cleanup\n         expired.add(reservationId);\n       }\n     }\n     // garbage collect expired reservations\n     cleanupExpiredQueues(planQueueName, plan.getMoveOnExpiry(), expired,\n         defReservationQueue);\n     // Add new reservations and update existing ones\n     float totalAssignedCapacity \u003d 0f;\n     if (currentReservations !\u003d null) {\n       // first release all excess capacity in default queue\n       try {\n         setQueueEntitlement(planQueueName, defReservationQueue, 0f, 1.0f);\n       } catch (YarnException e) {\n         LOG.warn(\n             \"Exception while trying to release default queue capacity for plan: {}\",\n             planQueueName, e);\n       }\n       // sort allocations from the one giving up the most resources, to the\n       // one asking for the most avoid order-of-operation errors that\n       // temporarily violate 100% capacity bound\n-      List\u003cReservationAllocation\u003e sortedAllocations \u003d\n-          sortByDelta(\n-              new ArrayList\u003cReservationAllocation\u003e(currentReservations), now,\n-              plan);\n+      List\u003cReservationAllocation\u003e sortedAllocations \u003d sortByDelta(\n+          new ArrayList\u003cReservationAllocation\u003e(currentReservations), now, plan);\n       for (ReservationAllocation res : sortedAllocations) {\n         String currResId \u003d res.getReservationId().toString();\n         if (curReservationNames.contains(currResId)) {\n           addReservationQueue(planQueueName, planQueue, currResId);\n         }\n         Resource capToAssign \u003d res.getResourcesAtTime(now);\n         float targetCapacity \u003d 0f;\n         if (planResources.getMemorySize() \u003e 0\n             \u0026\u0026 planResources.getVirtualCores() \u003e 0) {\n           if (shouldResize) {\n-            capToAssign \u003d\n-                calculateReservationToPlanProportion(\n-                    plan.getResourceCalculator(), planResources,\n-                    reservedResources, capToAssign);\n+            capToAssign \u003d calculateReservationToPlanProportion(\n+                plan.getResourceCalculator(), planResources, reservedResources,\n+                capToAssign);\n           }\n           targetCapacity \u003d\n               calculateReservationToPlanRatio(plan.getResourceCalculator(),\n                   clusterResources, planResources, capToAssign);\n         }\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\n               \"Assigning capacity of {} to queue {} with target capacity {}\",\n               capToAssign, currResId, targetCapacity);\n         }\n         // set maxCapacity to 100% unless the job requires gang, in which\n         // case we stick to capacity (as running early/before is likely a\n         // waste of resources)\n         float maxCapacity \u003d 1.0f;\n         if (res.containsGangs()) {\n           maxCapacity \u003d targetCapacity;\n         }\n         try {\n-          setQueueEntitlement(planQueueName, currResId, targetCapacity, maxCapacity);\n+          setQueueEntitlement(planQueueName, currResId, targetCapacity,\n+              maxCapacity);\n         } catch (YarnException e) {\n           LOG.warn(\"Exception while trying to size reservation for plan: {}\",\n               currResId, planQueueName, e);\n         }\n         totalAssignedCapacity +\u003d targetCapacity;\n       }\n     }\n     // compute the default queue capacity\n     float defQCap \u003d 1.0f - totalAssignedCapacity;\n     if (LOG.isDebugEnabled()) {\n-      LOG.debug(\"PlanFollowerEditPolicyTask: total Plan Capacity: {} \"\n-          + \"currReservation: {} default-queue capacity: {}\", planResources,\n-          numRes, defQCap);\n+      LOG.debug(\n+          \"PlanFollowerEditPolicyTask: total Plan Capacity: {} \"\n+              + \"currReservation: {} default-queue capacity: {}\",\n+          planResources, numRes, defQCap);\n     }\n     // set the default queue to eat-up all remaining capacity\n     try {\n       setQueueEntitlement(planQueueName, defReservationQueue, defQCap, 1.0f);\n     } catch (YarnException e) {\n       LOG.warn(\n           \"Exception while trying to reclaim default queue capacity for plan: {}\",\n           planQueueName, e);\n     }\n     // garbage collect finished reservations from plan\n     try {\n       plan.archiveCompletedReservations(now);\n     } catch (PlanningException e) {\n       LOG.error(\"Exception in archiving completed reservations: \", e);\n     }\n     LOG.info(\"Finished iteration of plan follower edit policy for plan: \"\n         + planQueueName);\n     // Extension: update plan with app states,\n     // useful to support smart replanning\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void synchronizePlan(Plan plan, boolean shouldReplan) {\n    String planQueueName \u003d plan.getQueueName();\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Running plan follower edit policy for plan: \" + planQueueName);\n    }\n    // align with plan step\n    long step \u003d plan.getStep();\n    long now \u003d clock.getTime();\n    if (now % step !\u003d 0) {\n      now +\u003d step - (now % step);\n    }\n    Queue planQueue \u003d getPlanQueue(planQueueName);\n    if (planQueue \u003d\u003d null) {\n      return;\n    }\n\n    // first we publish to the plan the current availability of resources\n    Resource clusterResources \u003d scheduler.getClusterResource();\n    Resource planResources \u003d\n        getPlanResources(plan, planQueue, clusterResources);\n    Set\u003cReservationAllocation\u003e currentReservations \u003d\n        plan.getReservationsAtTime(now);\n    Set\u003cString\u003e curReservationNames \u003d new HashSet\u003cString\u003e();\n    Resource reservedResources \u003d Resource.newInstance(0, 0);\n    int numRes \u003d getReservedResources(now, currentReservations,\n        curReservationNames, reservedResources);\n    // create the default reservation queue if it doesnt exist\n    String defReservationId \u003d getReservationIdFromQueueName(planQueueName)\n        + ReservationConstants.DEFAULT_QUEUE_SUFFIX;\n    String defReservationQueue \u003d\n        getReservationQueueName(planQueueName, defReservationId);\n    createDefaultReservationQueue(planQueueName, planQueue, defReservationId);\n    curReservationNames.add(defReservationId);\n    // if the resources dedicated to this plan has shrunk invoke replanner\n    boolean shouldResize \u003d false;\n    if (arePlanResourcesLessThanReservations(plan.getResourceCalculator(),\n        clusterResources, planResources, reservedResources)) {\n      if (shouldReplan) {\n        try {\n          plan.getReplanner().plan(plan, null);\n        } catch (PlanningException e) {\n          LOG.warn(\"Exception while trying to replan: {}\", planQueueName, e);\n        }\n      } else {\n        shouldResize \u003d true;\n      }\n    }\n    // identify the reservations that have expired and new reservations that\n    // have to be activated\n    List\u003c? extends Queue\u003e resQueues \u003d getChildReservationQueues(planQueue);\n    Set\u003cString\u003e expired \u003d new HashSet\u003cString\u003e();\n    for (Queue resQueue : resQueues) {\n      String resQueueName \u003d resQueue.getQueueName();\n      String reservationId \u003d getReservationIdFromQueueName(resQueueName);\n      if (curReservationNames.contains(reservationId)) {\n        // it is already existing reservation, so needed not create new\n        // reservation queue\n        curReservationNames.remove(reservationId);\n      } else {\n        // the reservation has termination, mark for cleanup\n        expired.add(reservationId);\n      }\n    }\n    // garbage collect expired reservations\n    cleanupExpiredQueues(planQueueName, plan.getMoveOnExpiry(), expired,\n        defReservationQueue);\n    // Add new reservations and update existing ones\n    float totalAssignedCapacity \u003d 0f;\n    if (currentReservations !\u003d null) {\n      // first release all excess capacity in default queue\n      try {\n        setQueueEntitlement(planQueueName, defReservationQueue, 0f, 1.0f);\n      } catch (YarnException e) {\n        LOG.warn(\n            \"Exception while trying to release default queue capacity for plan: {}\",\n            planQueueName, e);\n      }\n      // sort allocations from the one giving up the most resources, to the\n      // one asking for the most avoid order-of-operation errors that\n      // temporarily violate 100% capacity bound\n      List\u003cReservationAllocation\u003e sortedAllocations \u003d sortByDelta(\n          new ArrayList\u003cReservationAllocation\u003e(currentReservations), now, plan);\n      for (ReservationAllocation res : sortedAllocations) {\n        String currResId \u003d res.getReservationId().toString();\n        if (curReservationNames.contains(currResId)) {\n          addReservationQueue(planQueueName, planQueue, currResId);\n        }\n        Resource capToAssign \u003d res.getResourcesAtTime(now);\n        float targetCapacity \u003d 0f;\n        if (planResources.getMemorySize() \u003e 0\n            \u0026\u0026 planResources.getVirtualCores() \u003e 0) {\n          if (shouldResize) {\n            capToAssign \u003d calculateReservationToPlanProportion(\n                plan.getResourceCalculator(), planResources, reservedResources,\n                capToAssign);\n          }\n          targetCapacity \u003d\n              calculateReservationToPlanRatio(plan.getResourceCalculator(),\n                  clusterResources, planResources, capToAssign);\n        }\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\n              \"Assigning capacity of {} to queue {} with target capacity {}\",\n              capToAssign, currResId, targetCapacity);\n        }\n        // set maxCapacity to 100% unless the job requires gang, in which\n        // case we stick to capacity (as running early/before is likely a\n        // waste of resources)\n        float maxCapacity \u003d 1.0f;\n        if (res.containsGangs()) {\n          maxCapacity \u003d targetCapacity;\n        }\n        try {\n          setQueueEntitlement(planQueueName, currResId, targetCapacity,\n              maxCapacity);\n        } catch (YarnException e) {\n          LOG.warn(\"Exception while trying to size reservation for plan: {}\",\n              currResId, planQueueName, e);\n        }\n        totalAssignedCapacity +\u003d targetCapacity;\n      }\n    }\n    // compute the default queue capacity\n    float defQCap \u003d 1.0f - totalAssignedCapacity;\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\n          \"PlanFollowerEditPolicyTask: total Plan Capacity: {} \"\n              + \"currReservation: {} default-queue capacity: {}\",\n          planResources, numRes, defQCap);\n    }\n    // set the default queue to eat-up all remaining capacity\n    try {\n      setQueueEntitlement(planQueueName, defReservationQueue, defQCap, 1.0f);\n    } catch (YarnException e) {\n      LOG.warn(\n          \"Exception while trying to reclaim default queue capacity for plan: {}\",\n          planQueueName, e);\n    }\n    // garbage collect finished reservations from plan\n    try {\n      plan.archiveCompletedReservations(now);\n    } catch (PlanningException e) {\n      LOG.error(\"Exception in archiving completed reservations: \", e);\n    }\n    LOG.info(\"Finished iteration of plan follower edit policy for plan: \"\n        + planQueueName);\n    // Extension: update plan with app states,\n    // useful to support smart replanning\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/AbstractSchedulerPlanFollower.java",
      "extendedDetails": {}
    },
    "e3345e985bff93c6c74a76747e45376c6027f42c": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"Plan/ResourceAllocation data structure enhancements required to support recurring reservations in ReservationSystem.\"\n\nThis reverts commit 7996eca7dcfaa1bdf970e32022274f2699bef8a1.\n",
      "commitDate": "06/09/17 4:39 PM",
      "commitName": "e3345e985bff93c6c74a76747e45376c6027f42c",
      "commitAuthor": "Subru Krishnan",
      "commitDateOld": "01/09/17 3:16 PM",
      "commitNameOld": "7996eca7dcfaa1bdf970e32022274f2699bef8a1",
      "commitAuthorOld": "Subru Krishnan",
      "daysBetweenCommits": 5.06,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,149 +1,149 @@\n   public synchronized void synchronizePlan(Plan plan, boolean shouldReplan) {\n-    String planQueueName \u003d plan.getQueueName();\n+     String planQueueName \u003d plan.getQueueName();\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Running plan follower edit policy for plan: \" + planQueueName);\n     }\n     // align with plan step\n     long step \u003d plan.getStep();\n     long now \u003d clock.getTime();\n     if (now % step !\u003d 0) {\n       now +\u003d step - (now % step);\n     }\n     Queue planQueue \u003d getPlanQueue(planQueueName);\n-    if (planQueue \u003d\u003d null) {\n-      return;\n-    }\n+    if (planQueue \u003d\u003d null) return;\n \n     // first we publish to the plan the current availability of resources\n     Resource clusterResources \u003d scheduler.getClusterResource();\n-    Resource planResources \u003d\n-        getPlanResources(plan, planQueue, clusterResources);\n+    Resource planResources \u003d getPlanResources(plan, planQueue,\n+        clusterResources);\n     Set\u003cReservationAllocation\u003e currentReservations \u003d\n         plan.getReservationsAtTime(now);\n     Set\u003cString\u003e curReservationNames \u003d new HashSet\u003cString\u003e();\n     Resource reservedResources \u003d Resource.newInstance(0, 0);\n     int numRes \u003d getReservedResources(now, currentReservations,\n         curReservationNames, reservedResources);\n     // create the default reservation queue if it doesnt exist\n-    String defReservationId \u003d getReservationIdFromQueueName(planQueueName)\n-        + ReservationConstants.DEFAULT_QUEUE_SUFFIX;\n-    String defReservationQueue \u003d\n-        getReservationQueueName(planQueueName, defReservationId);\n-    createDefaultReservationQueue(planQueueName, planQueue, defReservationId);\n+    String defReservationId \u003d getReservationIdFromQueueName(planQueueName) +\n+        ReservationConstants.DEFAULT_QUEUE_SUFFIX;\n+    String defReservationQueue \u003d getReservationQueueName(planQueueName,\n+        defReservationId);\n+    createDefaultReservationQueue(planQueueName, planQueue,\n+        defReservationId);\n     curReservationNames.add(defReservationId);\n     // if the resources dedicated to this plan has shrunk invoke replanner\n     boolean shouldResize \u003d false;\n     if (arePlanResourcesLessThanReservations(plan.getResourceCalculator(),\n         clusterResources, planResources, reservedResources)) {\n       if (shouldReplan) {\n         try {\n           plan.getReplanner().plan(plan, null);\n         } catch (PlanningException e) {\n           LOG.warn(\"Exception while trying to replan: {}\", planQueueName, e);\n         }\n       } else {\n         shouldResize \u003d true;\n       }\n     }\n     // identify the reservations that have expired and new reservations that\n     // have to be activated\n     List\u003c? extends Queue\u003e resQueues \u003d getChildReservationQueues(planQueue);\n     Set\u003cString\u003e expired \u003d new HashSet\u003cString\u003e();\n     for (Queue resQueue : resQueues) {\n       String resQueueName \u003d resQueue.getQueueName();\n       String reservationId \u003d getReservationIdFromQueueName(resQueueName);\n       if (curReservationNames.contains(reservationId)) {\n         // it is already existing reservation, so needed not create new\n         // reservation queue\n         curReservationNames.remove(reservationId);\n       } else {\n         // the reservation has termination, mark for cleanup\n         expired.add(reservationId);\n       }\n     }\n     // garbage collect expired reservations\n     cleanupExpiredQueues(planQueueName, plan.getMoveOnExpiry(), expired,\n         defReservationQueue);\n     // Add new reservations and update existing ones\n     float totalAssignedCapacity \u003d 0f;\n     if (currentReservations !\u003d null) {\n       // first release all excess capacity in default queue\n       try {\n         setQueueEntitlement(planQueueName, defReservationQueue, 0f, 1.0f);\n       } catch (YarnException e) {\n         LOG.warn(\n             \"Exception while trying to release default queue capacity for plan: {}\",\n             planQueueName, e);\n       }\n       // sort allocations from the one giving up the most resources, to the\n       // one asking for the most avoid order-of-operation errors that\n       // temporarily violate 100% capacity bound\n-      List\u003cReservationAllocation\u003e sortedAllocations \u003d sortByDelta(\n-          new ArrayList\u003cReservationAllocation\u003e(currentReservations), now, plan);\n+      List\u003cReservationAllocation\u003e sortedAllocations \u003d\n+          sortByDelta(\n+              new ArrayList\u003cReservationAllocation\u003e(currentReservations), now,\n+              plan);\n       for (ReservationAllocation res : sortedAllocations) {\n         String currResId \u003d res.getReservationId().toString();\n         if (curReservationNames.contains(currResId)) {\n           addReservationQueue(planQueueName, planQueue, currResId);\n         }\n         Resource capToAssign \u003d res.getResourcesAtTime(now);\n         float targetCapacity \u003d 0f;\n         if (planResources.getMemorySize() \u003e 0\n             \u0026\u0026 planResources.getVirtualCores() \u003e 0) {\n           if (shouldResize) {\n-            capToAssign \u003d calculateReservationToPlanProportion(\n-                plan.getResourceCalculator(), planResources, reservedResources,\n-                capToAssign);\n+            capToAssign \u003d\n+                calculateReservationToPlanProportion(\n+                    plan.getResourceCalculator(), planResources,\n+                    reservedResources, capToAssign);\n           }\n           targetCapacity \u003d\n               calculateReservationToPlanRatio(plan.getResourceCalculator(),\n                   clusterResources, planResources, capToAssign);\n         }\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\n               \"Assigning capacity of {} to queue {} with target capacity {}\",\n               capToAssign, currResId, targetCapacity);\n         }\n         // set maxCapacity to 100% unless the job requires gang, in which\n         // case we stick to capacity (as running early/before is likely a\n         // waste of resources)\n         float maxCapacity \u003d 1.0f;\n         if (res.containsGangs()) {\n           maxCapacity \u003d targetCapacity;\n         }\n         try {\n-          setQueueEntitlement(planQueueName, currResId, targetCapacity,\n-              maxCapacity);\n+          setQueueEntitlement(planQueueName, currResId, targetCapacity, maxCapacity);\n         } catch (YarnException e) {\n           LOG.warn(\"Exception while trying to size reservation for plan: {}\",\n               currResId, planQueueName, e);\n         }\n         totalAssignedCapacity +\u003d targetCapacity;\n       }\n     }\n     // compute the default queue capacity\n     float defQCap \u003d 1.0f - totalAssignedCapacity;\n     if (LOG.isDebugEnabled()) {\n-      LOG.debug(\n-          \"PlanFollowerEditPolicyTask: total Plan Capacity: {} \"\n-              + \"currReservation: {} default-queue capacity: {}\",\n-          planResources, numRes, defQCap);\n+      LOG.debug(\"PlanFollowerEditPolicyTask: total Plan Capacity: {} \"\n+          + \"currReservation: {} default-queue capacity: {}\", planResources,\n+          numRes, defQCap);\n     }\n     // set the default queue to eat-up all remaining capacity\n     try {\n       setQueueEntitlement(planQueueName, defReservationQueue, defQCap, 1.0f);\n     } catch (YarnException e) {\n       LOG.warn(\n           \"Exception while trying to reclaim default queue capacity for plan: {}\",\n           planQueueName, e);\n     }\n     // garbage collect finished reservations from plan\n     try {\n       plan.archiveCompletedReservations(now);\n     } catch (PlanningException e) {\n       LOG.error(\"Exception in archiving completed reservations: \", e);\n     }\n     LOG.info(\"Finished iteration of plan follower edit policy for plan: \"\n         + planQueueName);\n     // Extension: update plan with app states,\n     // useful to support smart replanning\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void synchronizePlan(Plan plan, boolean shouldReplan) {\n     String planQueueName \u003d plan.getQueueName();\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Running plan follower edit policy for plan: \" + planQueueName);\n    }\n    // align with plan step\n    long step \u003d plan.getStep();\n    long now \u003d clock.getTime();\n    if (now % step !\u003d 0) {\n      now +\u003d step - (now % step);\n    }\n    Queue planQueue \u003d getPlanQueue(planQueueName);\n    if (planQueue \u003d\u003d null) return;\n\n    // first we publish to the plan the current availability of resources\n    Resource clusterResources \u003d scheduler.getClusterResource();\n    Resource planResources \u003d getPlanResources(plan, planQueue,\n        clusterResources);\n    Set\u003cReservationAllocation\u003e currentReservations \u003d\n        plan.getReservationsAtTime(now);\n    Set\u003cString\u003e curReservationNames \u003d new HashSet\u003cString\u003e();\n    Resource reservedResources \u003d Resource.newInstance(0, 0);\n    int numRes \u003d getReservedResources(now, currentReservations,\n        curReservationNames, reservedResources);\n    // create the default reservation queue if it doesnt exist\n    String defReservationId \u003d getReservationIdFromQueueName(planQueueName) +\n        ReservationConstants.DEFAULT_QUEUE_SUFFIX;\n    String defReservationQueue \u003d getReservationQueueName(planQueueName,\n        defReservationId);\n    createDefaultReservationQueue(planQueueName, planQueue,\n        defReservationId);\n    curReservationNames.add(defReservationId);\n    // if the resources dedicated to this plan has shrunk invoke replanner\n    boolean shouldResize \u003d false;\n    if (arePlanResourcesLessThanReservations(plan.getResourceCalculator(),\n        clusterResources, planResources, reservedResources)) {\n      if (shouldReplan) {\n        try {\n          plan.getReplanner().plan(plan, null);\n        } catch (PlanningException e) {\n          LOG.warn(\"Exception while trying to replan: {}\", planQueueName, e);\n        }\n      } else {\n        shouldResize \u003d true;\n      }\n    }\n    // identify the reservations that have expired and new reservations that\n    // have to be activated\n    List\u003c? extends Queue\u003e resQueues \u003d getChildReservationQueues(planQueue);\n    Set\u003cString\u003e expired \u003d new HashSet\u003cString\u003e();\n    for (Queue resQueue : resQueues) {\n      String resQueueName \u003d resQueue.getQueueName();\n      String reservationId \u003d getReservationIdFromQueueName(resQueueName);\n      if (curReservationNames.contains(reservationId)) {\n        // it is already existing reservation, so needed not create new\n        // reservation queue\n        curReservationNames.remove(reservationId);\n      } else {\n        // the reservation has termination, mark for cleanup\n        expired.add(reservationId);\n      }\n    }\n    // garbage collect expired reservations\n    cleanupExpiredQueues(planQueueName, plan.getMoveOnExpiry(), expired,\n        defReservationQueue);\n    // Add new reservations and update existing ones\n    float totalAssignedCapacity \u003d 0f;\n    if (currentReservations !\u003d null) {\n      // first release all excess capacity in default queue\n      try {\n        setQueueEntitlement(planQueueName, defReservationQueue, 0f, 1.0f);\n      } catch (YarnException e) {\n        LOG.warn(\n            \"Exception while trying to release default queue capacity for plan: {}\",\n            planQueueName, e);\n      }\n      // sort allocations from the one giving up the most resources, to the\n      // one asking for the most avoid order-of-operation errors that\n      // temporarily violate 100% capacity bound\n      List\u003cReservationAllocation\u003e sortedAllocations \u003d\n          sortByDelta(\n              new ArrayList\u003cReservationAllocation\u003e(currentReservations), now,\n              plan);\n      for (ReservationAllocation res : sortedAllocations) {\n        String currResId \u003d res.getReservationId().toString();\n        if (curReservationNames.contains(currResId)) {\n          addReservationQueue(planQueueName, planQueue, currResId);\n        }\n        Resource capToAssign \u003d res.getResourcesAtTime(now);\n        float targetCapacity \u003d 0f;\n        if (planResources.getMemorySize() \u003e 0\n            \u0026\u0026 planResources.getVirtualCores() \u003e 0) {\n          if (shouldResize) {\n            capToAssign \u003d\n                calculateReservationToPlanProportion(\n                    plan.getResourceCalculator(), planResources,\n                    reservedResources, capToAssign);\n          }\n          targetCapacity \u003d\n              calculateReservationToPlanRatio(plan.getResourceCalculator(),\n                  clusterResources, planResources, capToAssign);\n        }\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\n              \"Assigning capacity of {} to queue {} with target capacity {}\",\n              capToAssign, currResId, targetCapacity);\n        }\n        // set maxCapacity to 100% unless the job requires gang, in which\n        // case we stick to capacity (as running early/before is likely a\n        // waste of resources)\n        float maxCapacity \u003d 1.0f;\n        if (res.containsGangs()) {\n          maxCapacity \u003d targetCapacity;\n        }\n        try {\n          setQueueEntitlement(planQueueName, currResId, targetCapacity, maxCapacity);\n        } catch (YarnException e) {\n          LOG.warn(\"Exception while trying to size reservation for plan: {}\",\n              currResId, planQueueName, e);\n        }\n        totalAssignedCapacity +\u003d targetCapacity;\n      }\n    }\n    // compute the default queue capacity\n    float defQCap \u003d 1.0f - totalAssignedCapacity;\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"PlanFollowerEditPolicyTask: total Plan Capacity: {} \"\n          + \"currReservation: {} default-queue capacity: {}\", planResources,\n          numRes, defQCap);\n    }\n    // set the default queue to eat-up all remaining capacity\n    try {\n      setQueueEntitlement(planQueueName, defReservationQueue, defQCap, 1.0f);\n    } catch (YarnException e) {\n      LOG.warn(\n          \"Exception while trying to reclaim default queue capacity for plan: {}\",\n          planQueueName, e);\n    }\n    // garbage collect finished reservations from plan\n    try {\n      plan.archiveCompletedReservations(now);\n    } catch (PlanningException e) {\n      LOG.error(\"Exception in archiving completed reservations: \", e);\n    }\n    LOG.info(\"Finished iteration of plan follower edit policy for plan: \"\n        + planQueueName);\n    // Extension: update plan with app states,\n    // useful to support smart replanning\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/AbstractSchedulerPlanFollower.java",
      "extendedDetails": {}
    },
    "7996eca7dcfaa1bdf970e32022274f2699bef8a1": {
      "type": "Ybodychange",
      "commitMessage": "Plan/ResourceAllocation data structure enhancements required to support recurring reservations in ReservationSystem.\n",
      "commitDate": "01/09/17 3:16 PM",
      "commitName": "7996eca7dcfaa1bdf970e32022274f2699bef8a1",
      "commitAuthor": "Subru Krishnan",
      "commitDateOld": "29/05/16 8:54 AM",
      "commitNameOld": "42f90ab885d9693fcc1e52f9637f7de4111110ae",
      "commitAuthorOld": "Varun Vasudev",
      "daysBetweenCommits": 460.27,
      "commitsBetweenForRepo": 3015,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,149 +1,149 @@\n   public synchronized void synchronizePlan(Plan plan, boolean shouldReplan) {\n-     String planQueueName \u003d plan.getQueueName();\n+    String planQueueName \u003d plan.getQueueName();\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Running plan follower edit policy for plan: \" + planQueueName);\n     }\n     // align with plan step\n     long step \u003d plan.getStep();\n     long now \u003d clock.getTime();\n     if (now % step !\u003d 0) {\n       now +\u003d step - (now % step);\n     }\n     Queue planQueue \u003d getPlanQueue(planQueueName);\n-    if (planQueue \u003d\u003d null) return;\n+    if (planQueue \u003d\u003d null) {\n+      return;\n+    }\n \n     // first we publish to the plan the current availability of resources\n     Resource clusterResources \u003d scheduler.getClusterResource();\n-    Resource planResources \u003d getPlanResources(plan, planQueue,\n-        clusterResources);\n+    Resource planResources \u003d\n+        getPlanResources(plan, planQueue, clusterResources);\n     Set\u003cReservationAllocation\u003e currentReservations \u003d\n         plan.getReservationsAtTime(now);\n     Set\u003cString\u003e curReservationNames \u003d new HashSet\u003cString\u003e();\n     Resource reservedResources \u003d Resource.newInstance(0, 0);\n     int numRes \u003d getReservedResources(now, currentReservations,\n         curReservationNames, reservedResources);\n     // create the default reservation queue if it doesnt exist\n-    String defReservationId \u003d getReservationIdFromQueueName(planQueueName) +\n-        ReservationConstants.DEFAULT_QUEUE_SUFFIX;\n-    String defReservationQueue \u003d getReservationQueueName(planQueueName,\n-        defReservationId);\n-    createDefaultReservationQueue(planQueueName, planQueue,\n-        defReservationId);\n+    String defReservationId \u003d getReservationIdFromQueueName(planQueueName)\n+        + ReservationConstants.DEFAULT_QUEUE_SUFFIX;\n+    String defReservationQueue \u003d\n+        getReservationQueueName(planQueueName, defReservationId);\n+    createDefaultReservationQueue(planQueueName, planQueue, defReservationId);\n     curReservationNames.add(defReservationId);\n     // if the resources dedicated to this plan has shrunk invoke replanner\n     boolean shouldResize \u003d false;\n     if (arePlanResourcesLessThanReservations(plan.getResourceCalculator(),\n         clusterResources, planResources, reservedResources)) {\n       if (shouldReplan) {\n         try {\n           plan.getReplanner().plan(plan, null);\n         } catch (PlanningException e) {\n           LOG.warn(\"Exception while trying to replan: {}\", planQueueName, e);\n         }\n       } else {\n         shouldResize \u003d true;\n       }\n     }\n     // identify the reservations that have expired and new reservations that\n     // have to be activated\n     List\u003c? extends Queue\u003e resQueues \u003d getChildReservationQueues(planQueue);\n     Set\u003cString\u003e expired \u003d new HashSet\u003cString\u003e();\n     for (Queue resQueue : resQueues) {\n       String resQueueName \u003d resQueue.getQueueName();\n       String reservationId \u003d getReservationIdFromQueueName(resQueueName);\n       if (curReservationNames.contains(reservationId)) {\n         // it is already existing reservation, so needed not create new\n         // reservation queue\n         curReservationNames.remove(reservationId);\n       } else {\n         // the reservation has termination, mark for cleanup\n         expired.add(reservationId);\n       }\n     }\n     // garbage collect expired reservations\n     cleanupExpiredQueues(planQueueName, plan.getMoveOnExpiry(), expired,\n         defReservationQueue);\n     // Add new reservations and update existing ones\n     float totalAssignedCapacity \u003d 0f;\n     if (currentReservations !\u003d null) {\n       // first release all excess capacity in default queue\n       try {\n         setQueueEntitlement(planQueueName, defReservationQueue, 0f, 1.0f);\n       } catch (YarnException e) {\n         LOG.warn(\n             \"Exception while trying to release default queue capacity for plan: {}\",\n             planQueueName, e);\n       }\n       // sort allocations from the one giving up the most resources, to the\n       // one asking for the most avoid order-of-operation errors that\n       // temporarily violate 100% capacity bound\n-      List\u003cReservationAllocation\u003e sortedAllocations \u003d\n-          sortByDelta(\n-              new ArrayList\u003cReservationAllocation\u003e(currentReservations), now,\n-              plan);\n+      List\u003cReservationAllocation\u003e sortedAllocations \u003d sortByDelta(\n+          new ArrayList\u003cReservationAllocation\u003e(currentReservations), now, plan);\n       for (ReservationAllocation res : sortedAllocations) {\n         String currResId \u003d res.getReservationId().toString();\n         if (curReservationNames.contains(currResId)) {\n           addReservationQueue(planQueueName, planQueue, currResId);\n         }\n         Resource capToAssign \u003d res.getResourcesAtTime(now);\n         float targetCapacity \u003d 0f;\n         if (planResources.getMemorySize() \u003e 0\n             \u0026\u0026 planResources.getVirtualCores() \u003e 0) {\n           if (shouldResize) {\n-            capToAssign \u003d\n-                calculateReservationToPlanProportion(\n-                    plan.getResourceCalculator(), planResources,\n-                    reservedResources, capToAssign);\n+            capToAssign \u003d calculateReservationToPlanProportion(\n+                plan.getResourceCalculator(), planResources, reservedResources,\n+                capToAssign);\n           }\n           targetCapacity \u003d\n               calculateReservationToPlanRatio(plan.getResourceCalculator(),\n                   clusterResources, planResources, capToAssign);\n         }\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\n               \"Assigning capacity of {} to queue {} with target capacity {}\",\n               capToAssign, currResId, targetCapacity);\n         }\n         // set maxCapacity to 100% unless the job requires gang, in which\n         // case we stick to capacity (as running early/before is likely a\n         // waste of resources)\n         float maxCapacity \u003d 1.0f;\n         if (res.containsGangs()) {\n           maxCapacity \u003d targetCapacity;\n         }\n         try {\n-          setQueueEntitlement(planQueueName, currResId, targetCapacity, maxCapacity);\n+          setQueueEntitlement(planQueueName, currResId, targetCapacity,\n+              maxCapacity);\n         } catch (YarnException e) {\n           LOG.warn(\"Exception while trying to size reservation for plan: {}\",\n               currResId, planQueueName, e);\n         }\n         totalAssignedCapacity +\u003d targetCapacity;\n       }\n     }\n     // compute the default queue capacity\n     float defQCap \u003d 1.0f - totalAssignedCapacity;\n     if (LOG.isDebugEnabled()) {\n-      LOG.debug(\"PlanFollowerEditPolicyTask: total Plan Capacity: {} \"\n-          + \"currReservation: {} default-queue capacity: {}\", planResources,\n-          numRes, defQCap);\n+      LOG.debug(\n+          \"PlanFollowerEditPolicyTask: total Plan Capacity: {} \"\n+              + \"currReservation: {} default-queue capacity: {}\",\n+          planResources, numRes, defQCap);\n     }\n     // set the default queue to eat-up all remaining capacity\n     try {\n       setQueueEntitlement(planQueueName, defReservationQueue, defQCap, 1.0f);\n     } catch (YarnException e) {\n       LOG.warn(\n           \"Exception while trying to reclaim default queue capacity for plan: {}\",\n           planQueueName, e);\n     }\n     // garbage collect finished reservations from plan\n     try {\n       plan.archiveCompletedReservations(now);\n     } catch (PlanningException e) {\n       LOG.error(\"Exception in archiving completed reservations: \", e);\n     }\n     LOG.info(\"Finished iteration of plan follower edit policy for plan: \"\n         + planQueueName);\n     // Extension: update plan with app states,\n     // useful to support smart replanning\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void synchronizePlan(Plan plan, boolean shouldReplan) {\n    String planQueueName \u003d plan.getQueueName();\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Running plan follower edit policy for plan: \" + planQueueName);\n    }\n    // align with plan step\n    long step \u003d plan.getStep();\n    long now \u003d clock.getTime();\n    if (now % step !\u003d 0) {\n      now +\u003d step - (now % step);\n    }\n    Queue planQueue \u003d getPlanQueue(planQueueName);\n    if (planQueue \u003d\u003d null) {\n      return;\n    }\n\n    // first we publish to the plan the current availability of resources\n    Resource clusterResources \u003d scheduler.getClusterResource();\n    Resource planResources \u003d\n        getPlanResources(plan, planQueue, clusterResources);\n    Set\u003cReservationAllocation\u003e currentReservations \u003d\n        plan.getReservationsAtTime(now);\n    Set\u003cString\u003e curReservationNames \u003d new HashSet\u003cString\u003e();\n    Resource reservedResources \u003d Resource.newInstance(0, 0);\n    int numRes \u003d getReservedResources(now, currentReservations,\n        curReservationNames, reservedResources);\n    // create the default reservation queue if it doesnt exist\n    String defReservationId \u003d getReservationIdFromQueueName(planQueueName)\n        + ReservationConstants.DEFAULT_QUEUE_SUFFIX;\n    String defReservationQueue \u003d\n        getReservationQueueName(planQueueName, defReservationId);\n    createDefaultReservationQueue(planQueueName, planQueue, defReservationId);\n    curReservationNames.add(defReservationId);\n    // if the resources dedicated to this plan has shrunk invoke replanner\n    boolean shouldResize \u003d false;\n    if (arePlanResourcesLessThanReservations(plan.getResourceCalculator(),\n        clusterResources, planResources, reservedResources)) {\n      if (shouldReplan) {\n        try {\n          plan.getReplanner().plan(plan, null);\n        } catch (PlanningException e) {\n          LOG.warn(\"Exception while trying to replan: {}\", planQueueName, e);\n        }\n      } else {\n        shouldResize \u003d true;\n      }\n    }\n    // identify the reservations that have expired and new reservations that\n    // have to be activated\n    List\u003c? extends Queue\u003e resQueues \u003d getChildReservationQueues(planQueue);\n    Set\u003cString\u003e expired \u003d new HashSet\u003cString\u003e();\n    for (Queue resQueue : resQueues) {\n      String resQueueName \u003d resQueue.getQueueName();\n      String reservationId \u003d getReservationIdFromQueueName(resQueueName);\n      if (curReservationNames.contains(reservationId)) {\n        // it is already existing reservation, so needed not create new\n        // reservation queue\n        curReservationNames.remove(reservationId);\n      } else {\n        // the reservation has termination, mark for cleanup\n        expired.add(reservationId);\n      }\n    }\n    // garbage collect expired reservations\n    cleanupExpiredQueues(planQueueName, plan.getMoveOnExpiry(), expired,\n        defReservationQueue);\n    // Add new reservations and update existing ones\n    float totalAssignedCapacity \u003d 0f;\n    if (currentReservations !\u003d null) {\n      // first release all excess capacity in default queue\n      try {\n        setQueueEntitlement(planQueueName, defReservationQueue, 0f, 1.0f);\n      } catch (YarnException e) {\n        LOG.warn(\n            \"Exception while trying to release default queue capacity for plan: {}\",\n            planQueueName, e);\n      }\n      // sort allocations from the one giving up the most resources, to the\n      // one asking for the most avoid order-of-operation errors that\n      // temporarily violate 100% capacity bound\n      List\u003cReservationAllocation\u003e sortedAllocations \u003d sortByDelta(\n          new ArrayList\u003cReservationAllocation\u003e(currentReservations), now, plan);\n      for (ReservationAllocation res : sortedAllocations) {\n        String currResId \u003d res.getReservationId().toString();\n        if (curReservationNames.contains(currResId)) {\n          addReservationQueue(planQueueName, planQueue, currResId);\n        }\n        Resource capToAssign \u003d res.getResourcesAtTime(now);\n        float targetCapacity \u003d 0f;\n        if (planResources.getMemorySize() \u003e 0\n            \u0026\u0026 planResources.getVirtualCores() \u003e 0) {\n          if (shouldResize) {\n            capToAssign \u003d calculateReservationToPlanProportion(\n                plan.getResourceCalculator(), planResources, reservedResources,\n                capToAssign);\n          }\n          targetCapacity \u003d\n              calculateReservationToPlanRatio(plan.getResourceCalculator(),\n                  clusterResources, planResources, capToAssign);\n        }\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\n              \"Assigning capacity of {} to queue {} with target capacity {}\",\n              capToAssign, currResId, targetCapacity);\n        }\n        // set maxCapacity to 100% unless the job requires gang, in which\n        // case we stick to capacity (as running early/before is likely a\n        // waste of resources)\n        float maxCapacity \u003d 1.0f;\n        if (res.containsGangs()) {\n          maxCapacity \u003d targetCapacity;\n        }\n        try {\n          setQueueEntitlement(planQueueName, currResId, targetCapacity,\n              maxCapacity);\n        } catch (YarnException e) {\n          LOG.warn(\"Exception while trying to size reservation for plan: {}\",\n              currResId, planQueueName, e);\n        }\n        totalAssignedCapacity +\u003d targetCapacity;\n      }\n    }\n    // compute the default queue capacity\n    float defQCap \u003d 1.0f - totalAssignedCapacity;\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\n          \"PlanFollowerEditPolicyTask: total Plan Capacity: {} \"\n              + \"currReservation: {} default-queue capacity: {}\",\n          planResources, numRes, defQCap);\n    }\n    // set the default queue to eat-up all remaining capacity\n    try {\n      setQueueEntitlement(planQueueName, defReservationQueue, defQCap, 1.0f);\n    } catch (YarnException e) {\n      LOG.warn(\n          \"Exception while trying to reclaim default queue capacity for plan: {}\",\n          planQueueName, e);\n    }\n    // garbage collect finished reservations from plan\n    try {\n      plan.archiveCompletedReservations(now);\n    } catch (PlanningException e) {\n      LOG.error(\"Exception in archiving completed reservations: \", e);\n    }\n    LOG.info(\"Finished iteration of plan follower edit policy for plan: \"\n        + planQueueName);\n    // Extension: update plan with app states,\n    // useful to support smart replanning\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/AbstractSchedulerPlanFollower.java",
      "extendedDetails": {}
    },
    "42f90ab885d9693fcc1e52f9637f7de4111110ae": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4844. Add getMemorySize/getVirtualCoresSize to o.a.h.y.api.records.Resource. Contributed by Wangda Tan.\n",
      "commitDate": "29/05/16 8:54 AM",
      "commitName": "42f90ab885d9693fcc1e52f9637f7de4111110ae",
      "commitAuthor": "Varun Vasudev",
      "commitDateOld": "22/10/15 6:51 AM",
      "commitNameOld": "2798723a5443d04455b9d79c48d61f435ab52267",
      "commitAuthorOld": "Anubhav Dhoot",
      "daysBetweenCommits": 220.09,
      "commitsBetweenForRepo": 1444,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,149 +1,149 @@\n   public synchronized void synchronizePlan(Plan plan, boolean shouldReplan) {\n      String planQueueName \u003d plan.getQueueName();\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Running plan follower edit policy for plan: \" + planQueueName);\n     }\n     // align with plan step\n     long step \u003d plan.getStep();\n     long now \u003d clock.getTime();\n     if (now % step !\u003d 0) {\n       now +\u003d step - (now % step);\n     }\n     Queue planQueue \u003d getPlanQueue(planQueueName);\n     if (planQueue \u003d\u003d null) return;\n \n     // first we publish to the plan the current availability of resources\n     Resource clusterResources \u003d scheduler.getClusterResource();\n     Resource planResources \u003d getPlanResources(plan, planQueue,\n         clusterResources);\n     Set\u003cReservationAllocation\u003e currentReservations \u003d\n         plan.getReservationsAtTime(now);\n     Set\u003cString\u003e curReservationNames \u003d new HashSet\u003cString\u003e();\n     Resource reservedResources \u003d Resource.newInstance(0, 0);\n     int numRes \u003d getReservedResources(now, currentReservations,\n         curReservationNames, reservedResources);\n     // create the default reservation queue if it doesnt exist\n     String defReservationId \u003d getReservationIdFromQueueName(planQueueName) +\n         ReservationConstants.DEFAULT_QUEUE_SUFFIX;\n     String defReservationQueue \u003d getReservationQueueName(planQueueName,\n         defReservationId);\n     createDefaultReservationQueue(planQueueName, planQueue,\n         defReservationId);\n     curReservationNames.add(defReservationId);\n     // if the resources dedicated to this plan has shrunk invoke replanner\n     boolean shouldResize \u003d false;\n     if (arePlanResourcesLessThanReservations(plan.getResourceCalculator(),\n         clusterResources, planResources, reservedResources)) {\n       if (shouldReplan) {\n         try {\n           plan.getReplanner().plan(plan, null);\n         } catch (PlanningException e) {\n           LOG.warn(\"Exception while trying to replan: {}\", planQueueName, e);\n         }\n       } else {\n         shouldResize \u003d true;\n       }\n     }\n     // identify the reservations that have expired and new reservations that\n     // have to be activated\n     List\u003c? extends Queue\u003e resQueues \u003d getChildReservationQueues(planQueue);\n     Set\u003cString\u003e expired \u003d new HashSet\u003cString\u003e();\n     for (Queue resQueue : resQueues) {\n       String resQueueName \u003d resQueue.getQueueName();\n       String reservationId \u003d getReservationIdFromQueueName(resQueueName);\n       if (curReservationNames.contains(reservationId)) {\n         // it is already existing reservation, so needed not create new\n         // reservation queue\n         curReservationNames.remove(reservationId);\n       } else {\n         // the reservation has termination, mark for cleanup\n         expired.add(reservationId);\n       }\n     }\n     // garbage collect expired reservations\n     cleanupExpiredQueues(planQueueName, plan.getMoveOnExpiry(), expired,\n         defReservationQueue);\n     // Add new reservations and update existing ones\n     float totalAssignedCapacity \u003d 0f;\n     if (currentReservations !\u003d null) {\n       // first release all excess capacity in default queue\n       try {\n         setQueueEntitlement(planQueueName, defReservationQueue, 0f, 1.0f);\n       } catch (YarnException e) {\n         LOG.warn(\n             \"Exception while trying to release default queue capacity for plan: {}\",\n             planQueueName, e);\n       }\n       // sort allocations from the one giving up the most resources, to the\n       // one asking for the most avoid order-of-operation errors that\n       // temporarily violate 100% capacity bound\n       List\u003cReservationAllocation\u003e sortedAllocations \u003d\n           sortByDelta(\n               new ArrayList\u003cReservationAllocation\u003e(currentReservations), now,\n               plan);\n       for (ReservationAllocation res : sortedAllocations) {\n         String currResId \u003d res.getReservationId().toString();\n         if (curReservationNames.contains(currResId)) {\n           addReservationQueue(planQueueName, planQueue, currResId);\n         }\n         Resource capToAssign \u003d res.getResourcesAtTime(now);\n         float targetCapacity \u003d 0f;\n-        if (planResources.getMemory() \u003e 0\n+        if (planResources.getMemorySize() \u003e 0\n             \u0026\u0026 planResources.getVirtualCores() \u003e 0) {\n           if (shouldResize) {\n             capToAssign \u003d\n                 calculateReservationToPlanProportion(\n                     plan.getResourceCalculator(), planResources,\n                     reservedResources, capToAssign);\n           }\n           targetCapacity \u003d\n               calculateReservationToPlanRatio(plan.getResourceCalculator(),\n                   clusterResources, planResources, capToAssign);\n         }\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\n               \"Assigning capacity of {} to queue {} with target capacity {}\",\n               capToAssign, currResId, targetCapacity);\n         }\n         // set maxCapacity to 100% unless the job requires gang, in which\n         // case we stick to capacity (as running early/before is likely a\n         // waste of resources)\n         float maxCapacity \u003d 1.0f;\n         if (res.containsGangs()) {\n           maxCapacity \u003d targetCapacity;\n         }\n         try {\n           setQueueEntitlement(planQueueName, currResId, targetCapacity, maxCapacity);\n         } catch (YarnException e) {\n           LOG.warn(\"Exception while trying to size reservation for plan: {}\",\n               currResId, planQueueName, e);\n         }\n         totalAssignedCapacity +\u003d targetCapacity;\n       }\n     }\n     // compute the default queue capacity\n     float defQCap \u003d 1.0f - totalAssignedCapacity;\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"PlanFollowerEditPolicyTask: total Plan Capacity: {} \"\n           + \"currReservation: {} default-queue capacity: {}\", planResources,\n           numRes, defQCap);\n     }\n     // set the default queue to eat-up all remaining capacity\n     try {\n       setQueueEntitlement(planQueueName, defReservationQueue, defQCap, 1.0f);\n     } catch (YarnException e) {\n       LOG.warn(\n           \"Exception while trying to reclaim default queue capacity for plan: {}\",\n           planQueueName, e);\n     }\n     // garbage collect finished reservations from plan\n     try {\n       plan.archiveCompletedReservations(now);\n     } catch (PlanningException e) {\n       LOG.error(\"Exception in archiving completed reservations: \", e);\n     }\n     LOG.info(\"Finished iteration of plan follower edit policy for plan: \"\n         + planQueueName);\n     // Extension: update plan with app states,\n     // useful to support smart replanning\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void synchronizePlan(Plan plan, boolean shouldReplan) {\n     String planQueueName \u003d plan.getQueueName();\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Running plan follower edit policy for plan: \" + planQueueName);\n    }\n    // align with plan step\n    long step \u003d plan.getStep();\n    long now \u003d clock.getTime();\n    if (now % step !\u003d 0) {\n      now +\u003d step - (now % step);\n    }\n    Queue planQueue \u003d getPlanQueue(planQueueName);\n    if (planQueue \u003d\u003d null) return;\n\n    // first we publish to the plan the current availability of resources\n    Resource clusterResources \u003d scheduler.getClusterResource();\n    Resource planResources \u003d getPlanResources(plan, planQueue,\n        clusterResources);\n    Set\u003cReservationAllocation\u003e currentReservations \u003d\n        plan.getReservationsAtTime(now);\n    Set\u003cString\u003e curReservationNames \u003d new HashSet\u003cString\u003e();\n    Resource reservedResources \u003d Resource.newInstance(0, 0);\n    int numRes \u003d getReservedResources(now, currentReservations,\n        curReservationNames, reservedResources);\n    // create the default reservation queue if it doesnt exist\n    String defReservationId \u003d getReservationIdFromQueueName(planQueueName) +\n        ReservationConstants.DEFAULT_QUEUE_SUFFIX;\n    String defReservationQueue \u003d getReservationQueueName(planQueueName,\n        defReservationId);\n    createDefaultReservationQueue(planQueueName, planQueue,\n        defReservationId);\n    curReservationNames.add(defReservationId);\n    // if the resources dedicated to this plan has shrunk invoke replanner\n    boolean shouldResize \u003d false;\n    if (arePlanResourcesLessThanReservations(plan.getResourceCalculator(),\n        clusterResources, planResources, reservedResources)) {\n      if (shouldReplan) {\n        try {\n          plan.getReplanner().plan(plan, null);\n        } catch (PlanningException e) {\n          LOG.warn(\"Exception while trying to replan: {}\", planQueueName, e);\n        }\n      } else {\n        shouldResize \u003d true;\n      }\n    }\n    // identify the reservations that have expired and new reservations that\n    // have to be activated\n    List\u003c? extends Queue\u003e resQueues \u003d getChildReservationQueues(planQueue);\n    Set\u003cString\u003e expired \u003d new HashSet\u003cString\u003e();\n    for (Queue resQueue : resQueues) {\n      String resQueueName \u003d resQueue.getQueueName();\n      String reservationId \u003d getReservationIdFromQueueName(resQueueName);\n      if (curReservationNames.contains(reservationId)) {\n        // it is already existing reservation, so needed not create new\n        // reservation queue\n        curReservationNames.remove(reservationId);\n      } else {\n        // the reservation has termination, mark for cleanup\n        expired.add(reservationId);\n      }\n    }\n    // garbage collect expired reservations\n    cleanupExpiredQueues(planQueueName, plan.getMoveOnExpiry(), expired,\n        defReservationQueue);\n    // Add new reservations and update existing ones\n    float totalAssignedCapacity \u003d 0f;\n    if (currentReservations !\u003d null) {\n      // first release all excess capacity in default queue\n      try {\n        setQueueEntitlement(planQueueName, defReservationQueue, 0f, 1.0f);\n      } catch (YarnException e) {\n        LOG.warn(\n            \"Exception while trying to release default queue capacity for plan: {}\",\n            planQueueName, e);\n      }\n      // sort allocations from the one giving up the most resources, to the\n      // one asking for the most avoid order-of-operation errors that\n      // temporarily violate 100% capacity bound\n      List\u003cReservationAllocation\u003e sortedAllocations \u003d\n          sortByDelta(\n              new ArrayList\u003cReservationAllocation\u003e(currentReservations), now,\n              plan);\n      for (ReservationAllocation res : sortedAllocations) {\n        String currResId \u003d res.getReservationId().toString();\n        if (curReservationNames.contains(currResId)) {\n          addReservationQueue(planQueueName, planQueue, currResId);\n        }\n        Resource capToAssign \u003d res.getResourcesAtTime(now);\n        float targetCapacity \u003d 0f;\n        if (planResources.getMemorySize() \u003e 0\n            \u0026\u0026 planResources.getVirtualCores() \u003e 0) {\n          if (shouldResize) {\n            capToAssign \u003d\n                calculateReservationToPlanProportion(\n                    plan.getResourceCalculator(), planResources,\n                    reservedResources, capToAssign);\n          }\n          targetCapacity \u003d\n              calculateReservationToPlanRatio(plan.getResourceCalculator(),\n                  clusterResources, planResources, capToAssign);\n        }\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\n              \"Assigning capacity of {} to queue {} with target capacity {}\",\n              capToAssign, currResId, targetCapacity);\n        }\n        // set maxCapacity to 100% unless the job requires gang, in which\n        // case we stick to capacity (as running early/before is likely a\n        // waste of resources)\n        float maxCapacity \u003d 1.0f;\n        if (res.containsGangs()) {\n          maxCapacity \u003d targetCapacity;\n        }\n        try {\n          setQueueEntitlement(planQueueName, currResId, targetCapacity, maxCapacity);\n        } catch (YarnException e) {\n          LOG.warn(\"Exception while trying to size reservation for plan: {}\",\n              currResId, planQueueName, e);\n        }\n        totalAssignedCapacity +\u003d targetCapacity;\n      }\n    }\n    // compute the default queue capacity\n    float defQCap \u003d 1.0f - totalAssignedCapacity;\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"PlanFollowerEditPolicyTask: total Plan Capacity: {} \"\n          + \"currReservation: {} default-queue capacity: {}\", planResources,\n          numRes, defQCap);\n    }\n    // set the default queue to eat-up all remaining capacity\n    try {\n      setQueueEntitlement(planQueueName, defReservationQueue, defQCap, 1.0f);\n    } catch (YarnException e) {\n      LOG.warn(\n          \"Exception while trying to reclaim default queue capacity for plan: {}\",\n          planQueueName, e);\n    }\n    // garbage collect finished reservations from plan\n    try {\n      plan.archiveCompletedReservations(now);\n    } catch (PlanningException e) {\n      LOG.error(\"Exception in archiving completed reservations: \", e);\n    }\n    LOG.info(\"Finished iteration of plan follower edit policy for plan: \"\n        + planQueueName);\n    // Extension: update plan with app states,\n    // useful to support smart replanning\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/AbstractSchedulerPlanFollower.java",
      "extendedDetails": {}
    },
    "2798723a5443d04455b9d79c48d61f435ab52267": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-3739. Add reservation system recovery to RM recovery process. Contributed by  Subru Krishnan.\n",
      "commitDate": "22/10/15 6:51 AM",
      "commitName": "2798723a5443d04455b9d79c48d61f435ab52267",
      "commitAuthor": "Anubhav Dhoot",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-3739. Add reservation system recovery to RM recovery process. Contributed by  Subru Krishnan.\n",
          "commitDate": "22/10/15 6:51 AM",
          "commitName": "2798723a5443d04455b9d79c48d61f435ab52267",
          "commitAuthor": "Anubhav Dhoot",
          "commitDateOld": "05/01/15 3:12 PM",
          "commitNameOld": "0c4b11267717eb451fa6ed4c586317f2db32fbd5",
          "commitAuthorOld": "Karthik Kambatla",
          "daysBetweenCommits": 289.61,
          "commitsBetweenForRepo": 2472,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,145 +1,149 @@\n-  public synchronized void synchronizePlan(Plan plan) {\n+  public synchronized void synchronizePlan(Plan plan, boolean shouldReplan) {\n      String planQueueName \u003d plan.getQueueName();\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Running plan follower edit policy for plan: \" + planQueueName);\n     }\n     // align with plan step\n     long step \u003d plan.getStep();\n     long now \u003d clock.getTime();\n     if (now % step !\u003d 0) {\n       now +\u003d step - (now % step);\n     }\n     Queue planQueue \u003d getPlanQueue(planQueueName);\n     if (planQueue \u003d\u003d null) return;\n \n     // first we publish to the plan the current availability of resources\n     Resource clusterResources \u003d scheduler.getClusterResource();\n     Resource planResources \u003d getPlanResources(plan, planQueue,\n         clusterResources);\n-\n     Set\u003cReservationAllocation\u003e currentReservations \u003d\n         plan.getReservationsAtTime(now);\n     Set\u003cString\u003e curReservationNames \u003d new HashSet\u003cString\u003e();\n     Resource reservedResources \u003d Resource.newInstance(0, 0);\n     int numRes \u003d getReservedResources(now, currentReservations,\n         curReservationNames, reservedResources);\n-\n     // create the default reservation queue if it doesnt exist\n     String defReservationId \u003d getReservationIdFromQueueName(planQueueName) +\n         ReservationConstants.DEFAULT_QUEUE_SUFFIX;\n     String defReservationQueue \u003d getReservationQueueName(planQueueName,\n         defReservationId);\n     createDefaultReservationQueue(planQueueName, planQueue,\n         defReservationId);\n     curReservationNames.add(defReservationId);\n-\n     // if the resources dedicated to this plan has shrunk invoke replanner\n-    if (arePlanResourcesLessThanReservations(clusterResources, planResources,\n-        reservedResources)) {\n-      try {\n-        plan.getReplanner().plan(plan, null);\n-      } catch (PlanningException e) {\n-        LOG.warn(\"Exception while trying to replan: {}\", planQueueName, e);\n+    boolean shouldResize \u003d false;\n+    if (arePlanResourcesLessThanReservations(plan.getResourceCalculator(),\n+        clusterResources, planResources, reservedResources)) {\n+      if (shouldReplan) {\n+        try {\n+          plan.getReplanner().plan(plan, null);\n+        } catch (PlanningException e) {\n+          LOG.warn(\"Exception while trying to replan: {}\", planQueueName, e);\n+        }\n+      } else {\n+        shouldResize \u003d true;\n       }\n     }\n     // identify the reservations that have expired and new reservations that\n     // have to be activated\n     List\u003c? extends Queue\u003e resQueues \u003d getChildReservationQueues(planQueue);\n     Set\u003cString\u003e expired \u003d new HashSet\u003cString\u003e();\n     for (Queue resQueue : resQueues) {\n       String resQueueName \u003d resQueue.getQueueName();\n       String reservationId \u003d getReservationIdFromQueueName(resQueueName);\n       if (curReservationNames.contains(reservationId)) {\n         // it is already existing reservation, so needed not create new\n         // reservation queue\n         curReservationNames.remove(reservationId);\n       } else {\n         // the reservation has termination, mark for cleanup\n         expired.add(reservationId);\n       }\n     }\n     // garbage collect expired reservations\n     cleanupExpiredQueues(planQueueName, plan.getMoveOnExpiry(), expired,\n         defReservationQueue);\n-\n     // Add new reservations and update existing ones\n     float totalAssignedCapacity \u003d 0f;\n     if (currentReservations !\u003d null) {\n       // first release all excess capacity in default queue\n       try {\n         setQueueEntitlement(planQueueName, defReservationQueue, 0f, 1.0f);\n       } catch (YarnException e) {\n         LOG.warn(\n             \"Exception while trying to release default queue capacity for plan: {}\",\n             planQueueName, e);\n       }\n       // sort allocations from the one giving up the most resources, to the\n-      // one asking for the most\n-      // avoid order-of-operation errors that temporarily violate 100%\n-      // capacity bound\n+      // one asking for the most avoid order-of-operation errors that\n+      // temporarily violate 100% capacity bound\n       List\u003cReservationAllocation\u003e sortedAllocations \u003d\n           sortByDelta(\n               new ArrayList\u003cReservationAllocation\u003e(currentReservations), now,\n               plan);\n       for (ReservationAllocation res : sortedAllocations) {\n         String currResId \u003d res.getReservationId().toString();\n         if (curReservationNames.contains(currResId)) {\n           addReservationQueue(planQueueName, planQueue, currResId);\n         }\n         Resource capToAssign \u003d res.getResourcesAtTime(now);\n         float targetCapacity \u003d 0f;\n         if (planResources.getMemory() \u003e 0\n             \u0026\u0026 planResources.getVirtualCores() \u003e 0) {\n+          if (shouldResize) {\n+            capToAssign \u003d\n+                calculateReservationToPlanProportion(\n+                    plan.getResourceCalculator(), planResources,\n+                    reservedResources, capToAssign);\n+          }\n           targetCapacity \u003d\n-              calculateReservationToPlanRatio(clusterResources,\n-                  planResources,\n-                  capToAssign);\n+              calculateReservationToPlanRatio(plan.getResourceCalculator(),\n+                  clusterResources, planResources, capToAssign);\n         }\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\n               \"Assigning capacity of {} to queue {} with target capacity {}\",\n               capToAssign, currResId, targetCapacity);\n         }\n         // set maxCapacity to 100% unless the job requires gang, in which\n         // case we stick to capacity (as running early/before is likely a\n         // waste of resources)\n         float maxCapacity \u003d 1.0f;\n         if (res.containsGangs()) {\n           maxCapacity \u003d targetCapacity;\n         }\n         try {\n           setQueueEntitlement(planQueueName, currResId, targetCapacity, maxCapacity);\n         } catch (YarnException e) {\n           LOG.warn(\"Exception while trying to size reservation for plan: {}\",\n               currResId, planQueueName, e);\n         }\n         totalAssignedCapacity +\u003d targetCapacity;\n       }\n     }\n     // compute the default queue capacity\n     float defQCap \u003d 1.0f - totalAssignedCapacity;\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"PlanFollowerEditPolicyTask: total Plan Capacity: {} \"\n           + \"currReservation: {} default-queue capacity: {}\", planResources,\n           numRes, defQCap);\n     }\n     // set the default queue to eat-up all remaining capacity\n     try {\n       setQueueEntitlement(planQueueName, defReservationQueue, defQCap, 1.0f);\n     } catch (YarnException e) {\n       LOG.warn(\n           \"Exception while trying to reclaim default queue capacity for plan: {}\",\n           planQueueName, e);\n     }\n     // garbage collect finished reservations from plan\n     try {\n       plan.archiveCompletedReservations(now);\n     } catch (PlanningException e) {\n       LOG.error(\"Exception in archiving completed reservations: \", e);\n     }\n     LOG.info(\"Finished iteration of plan follower edit policy for plan: \"\n         + planQueueName);\n-\n     // Extension: update plan with app states,\n     // useful to support smart replanning\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public synchronized void synchronizePlan(Plan plan, boolean shouldReplan) {\n     String planQueueName \u003d plan.getQueueName();\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Running plan follower edit policy for plan: \" + planQueueName);\n    }\n    // align with plan step\n    long step \u003d plan.getStep();\n    long now \u003d clock.getTime();\n    if (now % step !\u003d 0) {\n      now +\u003d step - (now % step);\n    }\n    Queue planQueue \u003d getPlanQueue(planQueueName);\n    if (planQueue \u003d\u003d null) return;\n\n    // first we publish to the plan the current availability of resources\n    Resource clusterResources \u003d scheduler.getClusterResource();\n    Resource planResources \u003d getPlanResources(plan, planQueue,\n        clusterResources);\n    Set\u003cReservationAllocation\u003e currentReservations \u003d\n        plan.getReservationsAtTime(now);\n    Set\u003cString\u003e curReservationNames \u003d new HashSet\u003cString\u003e();\n    Resource reservedResources \u003d Resource.newInstance(0, 0);\n    int numRes \u003d getReservedResources(now, currentReservations,\n        curReservationNames, reservedResources);\n    // create the default reservation queue if it doesnt exist\n    String defReservationId \u003d getReservationIdFromQueueName(planQueueName) +\n        ReservationConstants.DEFAULT_QUEUE_SUFFIX;\n    String defReservationQueue \u003d getReservationQueueName(planQueueName,\n        defReservationId);\n    createDefaultReservationQueue(planQueueName, planQueue,\n        defReservationId);\n    curReservationNames.add(defReservationId);\n    // if the resources dedicated to this plan has shrunk invoke replanner\n    boolean shouldResize \u003d false;\n    if (arePlanResourcesLessThanReservations(plan.getResourceCalculator(),\n        clusterResources, planResources, reservedResources)) {\n      if (shouldReplan) {\n        try {\n          plan.getReplanner().plan(plan, null);\n        } catch (PlanningException e) {\n          LOG.warn(\"Exception while trying to replan: {}\", planQueueName, e);\n        }\n      } else {\n        shouldResize \u003d true;\n      }\n    }\n    // identify the reservations that have expired and new reservations that\n    // have to be activated\n    List\u003c? extends Queue\u003e resQueues \u003d getChildReservationQueues(planQueue);\n    Set\u003cString\u003e expired \u003d new HashSet\u003cString\u003e();\n    for (Queue resQueue : resQueues) {\n      String resQueueName \u003d resQueue.getQueueName();\n      String reservationId \u003d getReservationIdFromQueueName(resQueueName);\n      if (curReservationNames.contains(reservationId)) {\n        // it is already existing reservation, so needed not create new\n        // reservation queue\n        curReservationNames.remove(reservationId);\n      } else {\n        // the reservation has termination, mark for cleanup\n        expired.add(reservationId);\n      }\n    }\n    // garbage collect expired reservations\n    cleanupExpiredQueues(planQueueName, plan.getMoveOnExpiry(), expired,\n        defReservationQueue);\n    // Add new reservations and update existing ones\n    float totalAssignedCapacity \u003d 0f;\n    if (currentReservations !\u003d null) {\n      // first release all excess capacity in default queue\n      try {\n        setQueueEntitlement(planQueueName, defReservationQueue, 0f, 1.0f);\n      } catch (YarnException e) {\n        LOG.warn(\n            \"Exception while trying to release default queue capacity for plan: {}\",\n            planQueueName, e);\n      }\n      // sort allocations from the one giving up the most resources, to the\n      // one asking for the most avoid order-of-operation errors that\n      // temporarily violate 100% capacity bound\n      List\u003cReservationAllocation\u003e sortedAllocations \u003d\n          sortByDelta(\n              new ArrayList\u003cReservationAllocation\u003e(currentReservations), now,\n              plan);\n      for (ReservationAllocation res : sortedAllocations) {\n        String currResId \u003d res.getReservationId().toString();\n        if (curReservationNames.contains(currResId)) {\n          addReservationQueue(planQueueName, planQueue, currResId);\n        }\n        Resource capToAssign \u003d res.getResourcesAtTime(now);\n        float targetCapacity \u003d 0f;\n        if (planResources.getMemory() \u003e 0\n            \u0026\u0026 planResources.getVirtualCores() \u003e 0) {\n          if (shouldResize) {\n            capToAssign \u003d\n                calculateReservationToPlanProportion(\n                    plan.getResourceCalculator(), planResources,\n                    reservedResources, capToAssign);\n          }\n          targetCapacity \u003d\n              calculateReservationToPlanRatio(plan.getResourceCalculator(),\n                  clusterResources, planResources, capToAssign);\n        }\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\n              \"Assigning capacity of {} to queue {} with target capacity {}\",\n              capToAssign, currResId, targetCapacity);\n        }\n        // set maxCapacity to 100% unless the job requires gang, in which\n        // case we stick to capacity (as running early/before is likely a\n        // waste of resources)\n        float maxCapacity \u003d 1.0f;\n        if (res.containsGangs()) {\n          maxCapacity \u003d targetCapacity;\n        }\n        try {\n          setQueueEntitlement(planQueueName, currResId, targetCapacity, maxCapacity);\n        } catch (YarnException e) {\n          LOG.warn(\"Exception while trying to size reservation for plan: {}\",\n              currResId, planQueueName, e);\n        }\n        totalAssignedCapacity +\u003d targetCapacity;\n      }\n    }\n    // compute the default queue capacity\n    float defQCap \u003d 1.0f - totalAssignedCapacity;\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"PlanFollowerEditPolicyTask: total Plan Capacity: {} \"\n          + \"currReservation: {} default-queue capacity: {}\", planResources,\n          numRes, defQCap);\n    }\n    // set the default queue to eat-up all remaining capacity\n    try {\n      setQueueEntitlement(planQueueName, defReservationQueue, defQCap, 1.0f);\n    } catch (YarnException e) {\n      LOG.warn(\n          \"Exception while trying to reclaim default queue capacity for plan: {}\",\n          planQueueName, e);\n    }\n    // garbage collect finished reservations from plan\n    try {\n      plan.archiveCompletedReservations(now);\n    } catch (PlanningException e) {\n      LOG.error(\"Exception in archiving completed reservations: \", e);\n    }\n    LOG.info(\"Finished iteration of plan follower edit policy for plan: \"\n        + planQueueName);\n    // Extension: update plan with app states,\n    // useful to support smart replanning\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/AbstractSchedulerPlanFollower.java",
          "extendedDetails": {
            "oldValue": "[plan-Plan]",
            "newValue": "[plan-Plan, shouldReplan-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-3739. Add reservation system recovery to RM recovery process. Contributed by  Subru Krishnan.\n",
          "commitDate": "22/10/15 6:51 AM",
          "commitName": "2798723a5443d04455b9d79c48d61f435ab52267",
          "commitAuthor": "Anubhav Dhoot",
          "commitDateOld": "05/01/15 3:12 PM",
          "commitNameOld": "0c4b11267717eb451fa6ed4c586317f2db32fbd5",
          "commitAuthorOld": "Karthik Kambatla",
          "daysBetweenCommits": 289.61,
          "commitsBetweenForRepo": 2472,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,145 +1,149 @@\n-  public synchronized void synchronizePlan(Plan plan) {\n+  public synchronized void synchronizePlan(Plan plan, boolean shouldReplan) {\n      String planQueueName \u003d plan.getQueueName();\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Running plan follower edit policy for plan: \" + planQueueName);\n     }\n     // align with plan step\n     long step \u003d plan.getStep();\n     long now \u003d clock.getTime();\n     if (now % step !\u003d 0) {\n       now +\u003d step - (now % step);\n     }\n     Queue planQueue \u003d getPlanQueue(planQueueName);\n     if (planQueue \u003d\u003d null) return;\n \n     // first we publish to the plan the current availability of resources\n     Resource clusterResources \u003d scheduler.getClusterResource();\n     Resource planResources \u003d getPlanResources(plan, planQueue,\n         clusterResources);\n-\n     Set\u003cReservationAllocation\u003e currentReservations \u003d\n         plan.getReservationsAtTime(now);\n     Set\u003cString\u003e curReservationNames \u003d new HashSet\u003cString\u003e();\n     Resource reservedResources \u003d Resource.newInstance(0, 0);\n     int numRes \u003d getReservedResources(now, currentReservations,\n         curReservationNames, reservedResources);\n-\n     // create the default reservation queue if it doesnt exist\n     String defReservationId \u003d getReservationIdFromQueueName(planQueueName) +\n         ReservationConstants.DEFAULT_QUEUE_SUFFIX;\n     String defReservationQueue \u003d getReservationQueueName(planQueueName,\n         defReservationId);\n     createDefaultReservationQueue(planQueueName, planQueue,\n         defReservationId);\n     curReservationNames.add(defReservationId);\n-\n     // if the resources dedicated to this plan has shrunk invoke replanner\n-    if (arePlanResourcesLessThanReservations(clusterResources, planResources,\n-        reservedResources)) {\n-      try {\n-        plan.getReplanner().plan(plan, null);\n-      } catch (PlanningException e) {\n-        LOG.warn(\"Exception while trying to replan: {}\", planQueueName, e);\n+    boolean shouldResize \u003d false;\n+    if (arePlanResourcesLessThanReservations(plan.getResourceCalculator(),\n+        clusterResources, planResources, reservedResources)) {\n+      if (shouldReplan) {\n+        try {\n+          plan.getReplanner().plan(plan, null);\n+        } catch (PlanningException e) {\n+          LOG.warn(\"Exception while trying to replan: {}\", planQueueName, e);\n+        }\n+      } else {\n+        shouldResize \u003d true;\n       }\n     }\n     // identify the reservations that have expired and new reservations that\n     // have to be activated\n     List\u003c? extends Queue\u003e resQueues \u003d getChildReservationQueues(planQueue);\n     Set\u003cString\u003e expired \u003d new HashSet\u003cString\u003e();\n     for (Queue resQueue : resQueues) {\n       String resQueueName \u003d resQueue.getQueueName();\n       String reservationId \u003d getReservationIdFromQueueName(resQueueName);\n       if (curReservationNames.contains(reservationId)) {\n         // it is already existing reservation, so needed not create new\n         // reservation queue\n         curReservationNames.remove(reservationId);\n       } else {\n         // the reservation has termination, mark for cleanup\n         expired.add(reservationId);\n       }\n     }\n     // garbage collect expired reservations\n     cleanupExpiredQueues(planQueueName, plan.getMoveOnExpiry(), expired,\n         defReservationQueue);\n-\n     // Add new reservations and update existing ones\n     float totalAssignedCapacity \u003d 0f;\n     if (currentReservations !\u003d null) {\n       // first release all excess capacity in default queue\n       try {\n         setQueueEntitlement(planQueueName, defReservationQueue, 0f, 1.0f);\n       } catch (YarnException e) {\n         LOG.warn(\n             \"Exception while trying to release default queue capacity for plan: {}\",\n             planQueueName, e);\n       }\n       // sort allocations from the one giving up the most resources, to the\n-      // one asking for the most\n-      // avoid order-of-operation errors that temporarily violate 100%\n-      // capacity bound\n+      // one asking for the most avoid order-of-operation errors that\n+      // temporarily violate 100% capacity bound\n       List\u003cReservationAllocation\u003e sortedAllocations \u003d\n           sortByDelta(\n               new ArrayList\u003cReservationAllocation\u003e(currentReservations), now,\n               plan);\n       for (ReservationAllocation res : sortedAllocations) {\n         String currResId \u003d res.getReservationId().toString();\n         if (curReservationNames.contains(currResId)) {\n           addReservationQueue(planQueueName, planQueue, currResId);\n         }\n         Resource capToAssign \u003d res.getResourcesAtTime(now);\n         float targetCapacity \u003d 0f;\n         if (planResources.getMemory() \u003e 0\n             \u0026\u0026 planResources.getVirtualCores() \u003e 0) {\n+          if (shouldResize) {\n+            capToAssign \u003d\n+                calculateReservationToPlanProportion(\n+                    plan.getResourceCalculator(), planResources,\n+                    reservedResources, capToAssign);\n+          }\n           targetCapacity \u003d\n-              calculateReservationToPlanRatio(clusterResources,\n-                  planResources,\n-                  capToAssign);\n+              calculateReservationToPlanRatio(plan.getResourceCalculator(),\n+                  clusterResources, planResources, capToAssign);\n         }\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\n               \"Assigning capacity of {} to queue {} with target capacity {}\",\n               capToAssign, currResId, targetCapacity);\n         }\n         // set maxCapacity to 100% unless the job requires gang, in which\n         // case we stick to capacity (as running early/before is likely a\n         // waste of resources)\n         float maxCapacity \u003d 1.0f;\n         if (res.containsGangs()) {\n           maxCapacity \u003d targetCapacity;\n         }\n         try {\n           setQueueEntitlement(planQueueName, currResId, targetCapacity, maxCapacity);\n         } catch (YarnException e) {\n           LOG.warn(\"Exception while trying to size reservation for plan: {}\",\n               currResId, planQueueName, e);\n         }\n         totalAssignedCapacity +\u003d targetCapacity;\n       }\n     }\n     // compute the default queue capacity\n     float defQCap \u003d 1.0f - totalAssignedCapacity;\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"PlanFollowerEditPolicyTask: total Plan Capacity: {} \"\n           + \"currReservation: {} default-queue capacity: {}\", planResources,\n           numRes, defQCap);\n     }\n     // set the default queue to eat-up all remaining capacity\n     try {\n       setQueueEntitlement(planQueueName, defReservationQueue, defQCap, 1.0f);\n     } catch (YarnException e) {\n       LOG.warn(\n           \"Exception while trying to reclaim default queue capacity for plan: {}\",\n           planQueueName, e);\n     }\n     // garbage collect finished reservations from plan\n     try {\n       plan.archiveCompletedReservations(now);\n     } catch (PlanningException e) {\n       LOG.error(\"Exception in archiving completed reservations: \", e);\n     }\n     LOG.info(\"Finished iteration of plan follower edit policy for plan: \"\n         + planQueueName);\n-\n     // Extension: update plan with app states,\n     // useful to support smart replanning\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public synchronized void synchronizePlan(Plan plan, boolean shouldReplan) {\n     String planQueueName \u003d plan.getQueueName();\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Running plan follower edit policy for plan: \" + planQueueName);\n    }\n    // align with plan step\n    long step \u003d plan.getStep();\n    long now \u003d clock.getTime();\n    if (now % step !\u003d 0) {\n      now +\u003d step - (now % step);\n    }\n    Queue planQueue \u003d getPlanQueue(planQueueName);\n    if (planQueue \u003d\u003d null) return;\n\n    // first we publish to the plan the current availability of resources\n    Resource clusterResources \u003d scheduler.getClusterResource();\n    Resource planResources \u003d getPlanResources(plan, planQueue,\n        clusterResources);\n    Set\u003cReservationAllocation\u003e currentReservations \u003d\n        plan.getReservationsAtTime(now);\n    Set\u003cString\u003e curReservationNames \u003d new HashSet\u003cString\u003e();\n    Resource reservedResources \u003d Resource.newInstance(0, 0);\n    int numRes \u003d getReservedResources(now, currentReservations,\n        curReservationNames, reservedResources);\n    // create the default reservation queue if it doesnt exist\n    String defReservationId \u003d getReservationIdFromQueueName(planQueueName) +\n        ReservationConstants.DEFAULT_QUEUE_SUFFIX;\n    String defReservationQueue \u003d getReservationQueueName(planQueueName,\n        defReservationId);\n    createDefaultReservationQueue(planQueueName, planQueue,\n        defReservationId);\n    curReservationNames.add(defReservationId);\n    // if the resources dedicated to this plan has shrunk invoke replanner\n    boolean shouldResize \u003d false;\n    if (arePlanResourcesLessThanReservations(plan.getResourceCalculator(),\n        clusterResources, planResources, reservedResources)) {\n      if (shouldReplan) {\n        try {\n          plan.getReplanner().plan(plan, null);\n        } catch (PlanningException e) {\n          LOG.warn(\"Exception while trying to replan: {}\", planQueueName, e);\n        }\n      } else {\n        shouldResize \u003d true;\n      }\n    }\n    // identify the reservations that have expired and new reservations that\n    // have to be activated\n    List\u003c? extends Queue\u003e resQueues \u003d getChildReservationQueues(planQueue);\n    Set\u003cString\u003e expired \u003d new HashSet\u003cString\u003e();\n    for (Queue resQueue : resQueues) {\n      String resQueueName \u003d resQueue.getQueueName();\n      String reservationId \u003d getReservationIdFromQueueName(resQueueName);\n      if (curReservationNames.contains(reservationId)) {\n        // it is already existing reservation, so needed not create new\n        // reservation queue\n        curReservationNames.remove(reservationId);\n      } else {\n        // the reservation has termination, mark for cleanup\n        expired.add(reservationId);\n      }\n    }\n    // garbage collect expired reservations\n    cleanupExpiredQueues(planQueueName, plan.getMoveOnExpiry(), expired,\n        defReservationQueue);\n    // Add new reservations and update existing ones\n    float totalAssignedCapacity \u003d 0f;\n    if (currentReservations !\u003d null) {\n      // first release all excess capacity in default queue\n      try {\n        setQueueEntitlement(planQueueName, defReservationQueue, 0f, 1.0f);\n      } catch (YarnException e) {\n        LOG.warn(\n            \"Exception while trying to release default queue capacity for plan: {}\",\n            planQueueName, e);\n      }\n      // sort allocations from the one giving up the most resources, to the\n      // one asking for the most avoid order-of-operation errors that\n      // temporarily violate 100% capacity bound\n      List\u003cReservationAllocation\u003e sortedAllocations \u003d\n          sortByDelta(\n              new ArrayList\u003cReservationAllocation\u003e(currentReservations), now,\n              plan);\n      for (ReservationAllocation res : sortedAllocations) {\n        String currResId \u003d res.getReservationId().toString();\n        if (curReservationNames.contains(currResId)) {\n          addReservationQueue(planQueueName, planQueue, currResId);\n        }\n        Resource capToAssign \u003d res.getResourcesAtTime(now);\n        float targetCapacity \u003d 0f;\n        if (planResources.getMemory() \u003e 0\n            \u0026\u0026 planResources.getVirtualCores() \u003e 0) {\n          if (shouldResize) {\n            capToAssign \u003d\n                calculateReservationToPlanProportion(\n                    plan.getResourceCalculator(), planResources,\n                    reservedResources, capToAssign);\n          }\n          targetCapacity \u003d\n              calculateReservationToPlanRatio(plan.getResourceCalculator(),\n                  clusterResources, planResources, capToAssign);\n        }\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\n              \"Assigning capacity of {} to queue {} with target capacity {}\",\n              capToAssign, currResId, targetCapacity);\n        }\n        // set maxCapacity to 100% unless the job requires gang, in which\n        // case we stick to capacity (as running early/before is likely a\n        // waste of resources)\n        float maxCapacity \u003d 1.0f;\n        if (res.containsGangs()) {\n          maxCapacity \u003d targetCapacity;\n        }\n        try {\n          setQueueEntitlement(planQueueName, currResId, targetCapacity, maxCapacity);\n        } catch (YarnException e) {\n          LOG.warn(\"Exception while trying to size reservation for plan: {}\",\n              currResId, planQueueName, e);\n        }\n        totalAssignedCapacity +\u003d targetCapacity;\n      }\n    }\n    // compute the default queue capacity\n    float defQCap \u003d 1.0f - totalAssignedCapacity;\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"PlanFollowerEditPolicyTask: total Plan Capacity: {} \"\n          + \"currReservation: {} default-queue capacity: {}\", planResources,\n          numRes, defQCap);\n    }\n    // set the default queue to eat-up all remaining capacity\n    try {\n      setQueueEntitlement(planQueueName, defReservationQueue, defQCap, 1.0f);\n    } catch (YarnException e) {\n      LOG.warn(\n          \"Exception while trying to reclaim default queue capacity for plan: {}\",\n          planQueueName, e);\n    }\n    // garbage collect finished reservations from plan\n    try {\n      plan.archiveCompletedReservations(now);\n    } catch (PlanningException e) {\n      LOG.error(\"Exception in archiving completed reservations: \", e);\n    }\n    LOG.info(\"Finished iteration of plan follower edit policy for plan: \"\n        + planQueueName);\n    // Extension: update plan with app states,\n    // useful to support smart replanning\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/AbstractSchedulerPlanFollower.java",
          "extendedDetails": {}
        }
      ]
    },
    "0c4b11267717eb451fa6ed4c586317f2db32fbd5": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2881. [YARN-2574] Implement PlanFollower for FairScheduler. (Anubhav Dhoot via kasha)\n",
      "commitDate": "05/01/15 3:12 PM",
      "commitName": "0c4b11267717eb451fa6ed4c586317f2db32fbd5",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "30/12/14 7:55 PM",
      "commitNameOld": "e7257acd8a7adb74d81cd1d009d4a99f023ed844",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 5.8,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,145 +1,145 @@\n   public synchronized void synchronizePlan(Plan plan) {\n      String planQueueName \u003d plan.getQueueName();\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Running plan follower edit policy for plan: \" + planQueueName);\n     }\n     // align with plan step\n     long step \u003d plan.getStep();\n     long now \u003d clock.getTime();\n     if (now % step !\u003d 0) {\n       now +\u003d step - (now % step);\n     }\n     Queue planQueue \u003d getPlanQueue(planQueueName);\n     if (planQueue \u003d\u003d null) return;\n \n     // first we publish to the plan the current availability of resources\n     Resource clusterResources \u003d scheduler.getClusterResource();\n     Resource planResources \u003d getPlanResources(plan, planQueue,\n         clusterResources);\n \n     Set\u003cReservationAllocation\u003e currentReservations \u003d\n         plan.getReservationsAtTime(now);\n     Set\u003cString\u003e curReservationNames \u003d new HashSet\u003cString\u003e();\n     Resource reservedResources \u003d Resource.newInstance(0, 0);\n     int numRes \u003d getReservedResources(now, currentReservations,\n         curReservationNames, reservedResources);\n \n     // create the default reservation queue if it doesnt exist\n     String defReservationId \u003d getReservationIdFromQueueName(planQueueName) +\n-        PlanQueue.DEFAULT_QUEUE_SUFFIX;\n+        ReservationConstants.DEFAULT_QUEUE_SUFFIX;\n     String defReservationQueue \u003d getReservationQueueName(planQueueName,\n         defReservationId);\n     createDefaultReservationQueue(planQueueName, planQueue,\n         defReservationId);\n     curReservationNames.add(defReservationId);\n \n     // if the resources dedicated to this plan has shrunk invoke replanner\n     if (arePlanResourcesLessThanReservations(clusterResources, planResources,\n         reservedResources)) {\n       try {\n         plan.getReplanner().plan(plan, null);\n       } catch (PlanningException e) {\n         LOG.warn(\"Exception while trying to replan: {}\", planQueueName, e);\n       }\n     }\n     // identify the reservations that have expired and new reservations that\n     // have to be activated\n     List\u003c? extends Queue\u003e resQueues \u003d getChildReservationQueues(planQueue);\n     Set\u003cString\u003e expired \u003d new HashSet\u003cString\u003e();\n     for (Queue resQueue : resQueues) {\n       String resQueueName \u003d resQueue.getQueueName();\n       String reservationId \u003d getReservationIdFromQueueName(resQueueName);\n       if (curReservationNames.contains(reservationId)) {\n         // it is already existing reservation, so needed not create new\n         // reservation queue\n         curReservationNames.remove(reservationId);\n       } else {\n         // the reservation has termination, mark for cleanup\n         expired.add(reservationId);\n       }\n     }\n     // garbage collect expired reservations\n     cleanupExpiredQueues(planQueueName, plan.getMoveOnExpiry(), expired,\n         defReservationQueue);\n \n     // Add new reservations and update existing ones\n     float totalAssignedCapacity \u003d 0f;\n     if (currentReservations !\u003d null) {\n       // first release all excess capacity in default queue\n       try {\n         setQueueEntitlement(planQueueName, defReservationQueue, 0f, 1.0f);\n       } catch (YarnException e) {\n         LOG.warn(\n             \"Exception while trying to release default queue capacity for plan: {}\",\n             planQueueName, e);\n       }\n       // sort allocations from the one giving up the most resources, to the\n       // one asking for the most\n       // avoid order-of-operation errors that temporarily violate 100%\n       // capacity bound\n       List\u003cReservationAllocation\u003e sortedAllocations \u003d\n           sortByDelta(\n               new ArrayList\u003cReservationAllocation\u003e(currentReservations), now,\n               plan);\n       for (ReservationAllocation res : sortedAllocations) {\n         String currResId \u003d res.getReservationId().toString();\n         if (curReservationNames.contains(currResId)) {\n           addReservationQueue(planQueueName, planQueue, currResId);\n         }\n         Resource capToAssign \u003d res.getResourcesAtTime(now);\n         float targetCapacity \u003d 0f;\n         if (planResources.getMemory() \u003e 0\n             \u0026\u0026 planResources.getVirtualCores() \u003e 0) {\n           targetCapacity \u003d\n               calculateReservationToPlanRatio(clusterResources,\n                   planResources,\n                   capToAssign);\n         }\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\n               \"Assigning capacity of {} to queue {} with target capacity {}\",\n               capToAssign, currResId, targetCapacity);\n         }\n         // set maxCapacity to 100% unless the job requires gang, in which\n         // case we stick to capacity (as running early/before is likely a\n         // waste of resources)\n         float maxCapacity \u003d 1.0f;\n         if (res.containsGangs()) {\n           maxCapacity \u003d targetCapacity;\n         }\n         try {\n           setQueueEntitlement(planQueueName, currResId, targetCapacity, maxCapacity);\n         } catch (YarnException e) {\n           LOG.warn(\"Exception while trying to size reservation for plan: {}\",\n               currResId, planQueueName, e);\n         }\n         totalAssignedCapacity +\u003d targetCapacity;\n       }\n     }\n     // compute the default queue capacity\n     float defQCap \u003d 1.0f - totalAssignedCapacity;\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"PlanFollowerEditPolicyTask: total Plan Capacity: {} \"\n           + \"currReservation: {} default-queue capacity: {}\", planResources,\n           numRes, defQCap);\n     }\n     // set the default queue to eat-up all remaining capacity\n     try {\n       setQueueEntitlement(planQueueName, defReservationQueue, defQCap, 1.0f);\n     } catch (YarnException e) {\n       LOG.warn(\n           \"Exception while trying to reclaim default queue capacity for plan: {}\",\n           planQueueName, e);\n     }\n     // garbage collect finished reservations from plan\n     try {\n       plan.archiveCompletedReservations(now);\n     } catch (PlanningException e) {\n       LOG.error(\"Exception in archiving completed reservations: \", e);\n     }\n     LOG.info(\"Finished iteration of plan follower edit policy for plan: \"\n         + planQueueName);\n \n     // Extension: update plan with app states,\n     // useful to support smart replanning\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void synchronizePlan(Plan plan) {\n     String planQueueName \u003d plan.getQueueName();\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Running plan follower edit policy for plan: \" + planQueueName);\n    }\n    // align with plan step\n    long step \u003d plan.getStep();\n    long now \u003d clock.getTime();\n    if (now % step !\u003d 0) {\n      now +\u003d step - (now % step);\n    }\n    Queue planQueue \u003d getPlanQueue(planQueueName);\n    if (planQueue \u003d\u003d null) return;\n\n    // first we publish to the plan the current availability of resources\n    Resource clusterResources \u003d scheduler.getClusterResource();\n    Resource planResources \u003d getPlanResources(plan, planQueue,\n        clusterResources);\n\n    Set\u003cReservationAllocation\u003e currentReservations \u003d\n        plan.getReservationsAtTime(now);\n    Set\u003cString\u003e curReservationNames \u003d new HashSet\u003cString\u003e();\n    Resource reservedResources \u003d Resource.newInstance(0, 0);\n    int numRes \u003d getReservedResources(now, currentReservations,\n        curReservationNames, reservedResources);\n\n    // create the default reservation queue if it doesnt exist\n    String defReservationId \u003d getReservationIdFromQueueName(planQueueName) +\n        ReservationConstants.DEFAULT_QUEUE_SUFFIX;\n    String defReservationQueue \u003d getReservationQueueName(planQueueName,\n        defReservationId);\n    createDefaultReservationQueue(planQueueName, planQueue,\n        defReservationId);\n    curReservationNames.add(defReservationId);\n\n    // if the resources dedicated to this plan has shrunk invoke replanner\n    if (arePlanResourcesLessThanReservations(clusterResources, planResources,\n        reservedResources)) {\n      try {\n        plan.getReplanner().plan(plan, null);\n      } catch (PlanningException e) {\n        LOG.warn(\"Exception while trying to replan: {}\", planQueueName, e);\n      }\n    }\n    // identify the reservations that have expired and new reservations that\n    // have to be activated\n    List\u003c? extends Queue\u003e resQueues \u003d getChildReservationQueues(planQueue);\n    Set\u003cString\u003e expired \u003d new HashSet\u003cString\u003e();\n    for (Queue resQueue : resQueues) {\n      String resQueueName \u003d resQueue.getQueueName();\n      String reservationId \u003d getReservationIdFromQueueName(resQueueName);\n      if (curReservationNames.contains(reservationId)) {\n        // it is already existing reservation, so needed not create new\n        // reservation queue\n        curReservationNames.remove(reservationId);\n      } else {\n        // the reservation has termination, mark for cleanup\n        expired.add(reservationId);\n      }\n    }\n    // garbage collect expired reservations\n    cleanupExpiredQueues(planQueueName, plan.getMoveOnExpiry(), expired,\n        defReservationQueue);\n\n    // Add new reservations and update existing ones\n    float totalAssignedCapacity \u003d 0f;\n    if (currentReservations !\u003d null) {\n      // first release all excess capacity in default queue\n      try {\n        setQueueEntitlement(planQueueName, defReservationQueue, 0f, 1.0f);\n      } catch (YarnException e) {\n        LOG.warn(\n            \"Exception while trying to release default queue capacity for plan: {}\",\n            planQueueName, e);\n      }\n      // sort allocations from the one giving up the most resources, to the\n      // one asking for the most\n      // avoid order-of-operation errors that temporarily violate 100%\n      // capacity bound\n      List\u003cReservationAllocation\u003e sortedAllocations \u003d\n          sortByDelta(\n              new ArrayList\u003cReservationAllocation\u003e(currentReservations), now,\n              plan);\n      for (ReservationAllocation res : sortedAllocations) {\n        String currResId \u003d res.getReservationId().toString();\n        if (curReservationNames.contains(currResId)) {\n          addReservationQueue(planQueueName, planQueue, currResId);\n        }\n        Resource capToAssign \u003d res.getResourcesAtTime(now);\n        float targetCapacity \u003d 0f;\n        if (planResources.getMemory() \u003e 0\n            \u0026\u0026 planResources.getVirtualCores() \u003e 0) {\n          targetCapacity \u003d\n              calculateReservationToPlanRatio(clusterResources,\n                  planResources,\n                  capToAssign);\n        }\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\n              \"Assigning capacity of {} to queue {} with target capacity {}\",\n              capToAssign, currResId, targetCapacity);\n        }\n        // set maxCapacity to 100% unless the job requires gang, in which\n        // case we stick to capacity (as running early/before is likely a\n        // waste of resources)\n        float maxCapacity \u003d 1.0f;\n        if (res.containsGangs()) {\n          maxCapacity \u003d targetCapacity;\n        }\n        try {\n          setQueueEntitlement(planQueueName, currResId, targetCapacity, maxCapacity);\n        } catch (YarnException e) {\n          LOG.warn(\"Exception while trying to size reservation for plan: {}\",\n              currResId, planQueueName, e);\n        }\n        totalAssignedCapacity +\u003d targetCapacity;\n      }\n    }\n    // compute the default queue capacity\n    float defQCap \u003d 1.0f - totalAssignedCapacity;\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"PlanFollowerEditPolicyTask: total Plan Capacity: {} \"\n          + \"currReservation: {} default-queue capacity: {}\", planResources,\n          numRes, defQCap);\n    }\n    // set the default queue to eat-up all remaining capacity\n    try {\n      setQueueEntitlement(planQueueName, defReservationQueue, defQCap, 1.0f);\n    } catch (YarnException e) {\n      LOG.warn(\n          \"Exception while trying to reclaim default queue capacity for plan: {}\",\n          planQueueName, e);\n    }\n    // garbage collect finished reservations from plan\n    try {\n      plan.archiveCompletedReservations(now);\n    } catch (PlanningException e) {\n      LOG.error(\"Exception in archiving completed reservations: \", e);\n    }\n    LOG.info(\"Finished iteration of plan follower edit policy for plan: \"\n        + planQueueName);\n\n    // Extension: update plan with app states,\n    // useful to support smart replanning\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/AbstractSchedulerPlanFollower.java",
      "extendedDetails": {}
    },
    "e7257acd8a7adb74d81cd1d009d4a99f023ed844": {
      "type": "Ymultichange(Ymovefromfile,Ybodychange)",
      "commitMessage": "YARN-2998. Abstract out scheduler independent PlanFollower components. (Anubhav Dhoot via kasha)\n",
      "commitDate": "30/12/14 7:55 PM",
      "commitName": "e7257acd8a7adb74d81cd1d009d4a99f023ed844",
      "commitAuthor": "Karthik Kambatla",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "YARN-2998. Abstract out scheduler independent PlanFollower components. (Anubhav Dhoot via kasha)\n",
          "commitDate": "30/12/14 7:55 PM",
          "commitName": "e7257acd8a7adb74d81cd1d009d4a99f023ed844",
          "commitAuthor": "Karthik Kambatla",
          "commitDateOld": "30/12/14 5:15 PM",
          "commitNameOld": "e2351c7ae24cea9b217af4174512d279c55e8efd",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 0.11,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,174 +1,145 @@\n   public synchronized void synchronizePlan(Plan plan) {\n-    String planQueueName \u003d plan.getQueueName();\n+     String planQueueName \u003d plan.getQueueName();\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Running plan follower edit policy for plan: \" + planQueueName);\n     }\n     // align with plan step\n     long step \u003d plan.getStep();\n     long now \u003d clock.getTime();\n     if (now % step !\u003d 0) {\n       now +\u003d step - (now % step);\n     }\n-    CSQueue queue \u003d scheduler.getQueue(planQueueName);\n-    if (!(queue instanceof PlanQueue)) {\n-      LOG.error(\"The Plan is not an PlanQueue!\");\n-      return;\n-    }\n-    PlanQueue planQueue \u003d (PlanQueue) queue;\n+    Queue planQueue \u003d getPlanQueue(planQueueName);\n+    if (planQueue \u003d\u003d null) return;\n+\n     // first we publish to the plan the current availability of resources\n     Resource clusterResources \u003d scheduler.getClusterResource();\n-    float planAbsCap \u003d planQueue.getAbsoluteCapacity();\n-    Resource planResources \u003d Resources.multiply(clusterResources, planAbsCap);\n-    plan.setTotalCapacity(planResources);\n+    Resource planResources \u003d getPlanResources(plan, planQueue,\n+        clusterResources);\n \n     Set\u003cReservationAllocation\u003e currentReservations \u003d\n         plan.getReservationsAtTime(now);\n     Set\u003cString\u003e curReservationNames \u003d new HashSet\u003cString\u003e();\n     Resource reservedResources \u003d Resource.newInstance(0, 0);\n-    int numRes \u003d 0;\n-    if (currentReservations !\u003d null) {\n-      numRes \u003d currentReservations.size();\n-      for (ReservationAllocation reservation : currentReservations) {\n-        curReservationNames.add(reservation.getReservationId().toString());\n-        Resources.addTo(reservedResources, reservation.getResourcesAtTime(now));\n-      }\n-    }\n+    int numRes \u003d getReservedResources(now, currentReservations,\n+        curReservationNames, reservedResources);\n+\n     // create the default reservation queue if it doesnt exist\n-    String defReservationQueue \u003d planQueueName + PlanQueue.DEFAULT_QUEUE_SUFFIX;\n-    if (scheduler.getQueue(defReservationQueue) \u003d\u003d null) {\n-      try {\n-        ReservationQueue defQueue \u003d\n-            new ReservationQueue(scheduler, defReservationQueue, planQueue);\n-        scheduler.addQueue(defQueue);\n-      } catch (SchedulerDynamicEditException e) {\n-        LOG.warn(\n-            \"Exception while trying to create default reservation queue for plan: {}\",\n-            planQueueName, e);\n-      } catch (IOException e) {\n-        LOG.warn(\n-            \"Exception while trying to create default reservation queue for plan: {}\",\n-            planQueueName, e);\n-      }\n-    }\n-    curReservationNames.add(defReservationQueue);\n+    String defReservationId \u003d getReservationIdFromQueueName(planQueueName) +\n+        PlanQueue.DEFAULT_QUEUE_SUFFIX;\n+    String defReservationQueue \u003d getReservationQueueName(planQueueName,\n+        defReservationId);\n+    createDefaultReservationQueue(planQueueName, planQueue,\n+        defReservationId);\n+    curReservationNames.add(defReservationId);\n+\n     // if the resources dedicated to this plan has shrunk invoke replanner\n-    if (Resources.greaterThan(scheduler.getResourceCalculator(),\n-        clusterResources, reservedResources, planResources)) {\n+    if (arePlanResourcesLessThanReservations(clusterResources, planResources,\n+        reservedResources)) {\n       try {\n         plan.getReplanner().plan(plan, null);\n       } catch (PlanningException e) {\n         LOG.warn(\"Exception while trying to replan: {}\", planQueueName, e);\n       }\n     }\n     // identify the reservations that have expired and new reservations that\n     // have to be activated\n-    List\u003cCSQueue\u003e resQueues \u003d planQueue.getChildQueues();\n+    List\u003c? extends Queue\u003e resQueues \u003d getChildReservationQueues(planQueue);\n     Set\u003cString\u003e expired \u003d new HashSet\u003cString\u003e();\n-    for (CSQueue resQueue : resQueues) {\n+    for (Queue resQueue : resQueues) {\n       String resQueueName \u003d resQueue.getQueueName();\n-      if (curReservationNames.contains(resQueueName)) {\n+      String reservationId \u003d getReservationIdFromQueueName(resQueueName);\n+      if (curReservationNames.contains(reservationId)) {\n         // it is already existing reservation, so needed not create new\n         // reservation queue\n-        curReservationNames.remove(resQueueName);\n+        curReservationNames.remove(reservationId);\n       } else {\n         // the reservation has termination, mark for cleanup\n-        expired.add(resQueueName);\n+        expired.add(reservationId);\n       }\n     }\n     // garbage collect expired reservations\n-    cleanupExpiredQueues(plan.getMoveOnExpiry(), expired, defReservationQueue);\n+    cleanupExpiredQueues(planQueueName, plan.getMoveOnExpiry(), expired,\n+        defReservationQueue);\n \n     // Add new reservations and update existing ones\n     float totalAssignedCapacity \u003d 0f;\n     if (currentReservations !\u003d null) {\n       // first release all excess capacity in default queue\n       try {\n-        scheduler.setEntitlement(defReservationQueue, new QueueEntitlement(0f,\n-            1.0f));\n+        setQueueEntitlement(planQueueName, defReservationQueue, 0f, 1.0f);\n       } catch (YarnException e) {\n         LOG.warn(\n             \"Exception while trying to release default queue capacity for plan: {}\",\n             planQueueName, e);\n       }\n       // sort allocations from the one giving up the most resources, to the\n       // one asking for the most\n       // avoid order-of-operation errors that temporarily violate 100%\n       // capacity bound\n       List\u003cReservationAllocation\u003e sortedAllocations \u003d\n           sortByDelta(\n-              new ArrayList\u003cReservationAllocation\u003e(currentReservations), now);\n+              new ArrayList\u003cReservationAllocation\u003e(currentReservations), now,\n+              plan);\n       for (ReservationAllocation res : sortedAllocations) {\n         String currResId \u003d res.getReservationId().toString();\n         if (curReservationNames.contains(currResId)) {\n-          try {\n-            ReservationQueue resQueue \u003d\n-                new ReservationQueue(scheduler, currResId, planQueue);\n-            scheduler.addQueue(resQueue);\n-          } catch (SchedulerDynamicEditException e) {\n-            LOG.warn(\n-                \"Exception while trying to activate reservation: {} for plan: {}\",\n-                currResId, planQueueName, e);\n-          } catch (IOException e) {\n-            LOG.warn(\n-                \"Exception while trying to activate reservation: {} for plan: {}\",\n-                currResId, planQueueName, e);\n-          }\n+          addReservationQueue(planQueueName, planQueue, currResId);\n         }\n         Resource capToAssign \u003d res.getResourcesAtTime(now);\n         float targetCapacity \u003d 0f;\n         if (planResources.getMemory() \u003e 0\n             \u0026\u0026 planResources.getVirtualCores() \u003e 0) {\n           targetCapacity \u003d\n-              Resources.divide(scheduler.getResourceCalculator(),\n-                  clusterResources, capToAssign, planResources);\n+              calculateReservationToPlanRatio(clusterResources,\n+                  planResources,\n+                  capToAssign);\n         }\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\n               \"Assigning capacity of {} to queue {} with target capacity {}\",\n               capToAssign, currResId, targetCapacity);\n         }\n         // set maxCapacity to 100% unless the job requires gang, in which\n         // case we stick to capacity (as running early/before is likely a\n         // waste of resources)\n         float maxCapacity \u003d 1.0f;\n         if (res.containsGangs()) {\n           maxCapacity \u003d targetCapacity;\n         }\n         try {\n-          scheduler.setEntitlement(currResId, new QueueEntitlement(\n-              targetCapacity, maxCapacity));\n+          setQueueEntitlement(planQueueName, currResId, targetCapacity, maxCapacity);\n         } catch (YarnException e) {\n           LOG.warn(\"Exception while trying to size reservation for plan: {}\",\n               currResId, planQueueName, e);\n         }\n         totalAssignedCapacity +\u003d targetCapacity;\n       }\n     }\n     // compute the default queue capacity\n     float defQCap \u003d 1.0f - totalAssignedCapacity;\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"PlanFollowerEditPolicyTask: total Plan Capacity: {} \"\n           + \"currReservation: {} default-queue capacity: {}\", planResources,\n           numRes, defQCap);\n     }\n     // set the default queue to eat-up all remaining capacity\n     try {\n-      scheduler.setEntitlement(defReservationQueue, new QueueEntitlement(\n-          defQCap, 1.0f));\n+      setQueueEntitlement(planQueueName, defReservationQueue, defQCap, 1.0f);\n     } catch (YarnException e) {\n       LOG.warn(\n           \"Exception while trying to reclaim default queue capacity for plan: {}\",\n           planQueueName, e);\n     }\n     // garbage collect finished reservations from plan\n     try {\n       plan.archiveCompletedReservations(now);\n     } catch (PlanningException e) {\n       LOG.error(\"Exception in archiving completed reservations: \", e);\n     }\n     LOG.info(\"Finished iteration of plan follower edit policy for plan: \"\n         + planQueueName);\n \n     // Extension: update plan with app states,\n     // useful to support smart replanning\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public synchronized void synchronizePlan(Plan plan) {\n     String planQueueName \u003d plan.getQueueName();\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Running plan follower edit policy for plan: \" + planQueueName);\n    }\n    // align with plan step\n    long step \u003d plan.getStep();\n    long now \u003d clock.getTime();\n    if (now % step !\u003d 0) {\n      now +\u003d step - (now % step);\n    }\n    Queue planQueue \u003d getPlanQueue(planQueueName);\n    if (planQueue \u003d\u003d null) return;\n\n    // first we publish to the plan the current availability of resources\n    Resource clusterResources \u003d scheduler.getClusterResource();\n    Resource planResources \u003d getPlanResources(plan, planQueue,\n        clusterResources);\n\n    Set\u003cReservationAllocation\u003e currentReservations \u003d\n        plan.getReservationsAtTime(now);\n    Set\u003cString\u003e curReservationNames \u003d new HashSet\u003cString\u003e();\n    Resource reservedResources \u003d Resource.newInstance(0, 0);\n    int numRes \u003d getReservedResources(now, currentReservations,\n        curReservationNames, reservedResources);\n\n    // create the default reservation queue if it doesnt exist\n    String defReservationId \u003d getReservationIdFromQueueName(planQueueName) +\n        PlanQueue.DEFAULT_QUEUE_SUFFIX;\n    String defReservationQueue \u003d getReservationQueueName(planQueueName,\n        defReservationId);\n    createDefaultReservationQueue(planQueueName, planQueue,\n        defReservationId);\n    curReservationNames.add(defReservationId);\n\n    // if the resources dedicated to this plan has shrunk invoke replanner\n    if (arePlanResourcesLessThanReservations(clusterResources, planResources,\n        reservedResources)) {\n      try {\n        plan.getReplanner().plan(plan, null);\n      } catch (PlanningException e) {\n        LOG.warn(\"Exception while trying to replan: {}\", planQueueName, e);\n      }\n    }\n    // identify the reservations that have expired and new reservations that\n    // have to be activated\n    List\u003c? extends Queue\u003e resQueues \u003d getChildReservationQueues(planQueue);\n    Set\u003cString\u003e expired \u003d new HashSet\u003cString\u003e();\n    for (Queue resQueue : resQueues) {\n      String resQueueName \u003d resQueue.getQueueName();\n      String reservationId \u003d getReservationIdFromQueueName(resQueueName);\n      if (curReservationNames.contains(reservationId)) {\n        // it is already existing reservation, so needed not create new\n        // reservation queue\n        curReservationNames.remove(reservationId);\n      } else {\n        // the reservation has termination, mark for cleanup\n        expired.add(reservationId);\n      }\n    }\n    // garbage collect expired reservations\n    cleanupExpiredQueues(planQueueName, plan.getMoveOnExpiry(), expired,\n        defReservationQueue);\n\n    // Add new reservations and update existing ones\n    float totalAssignedCapacity \u003d 0f;\n    if (currentReservations !\u003d null) {\n      // first release all excess capacity in default queue\n      try {\n        setQueueEntitlement(planQueueName, defReservationQueue, 0f, 1.0f);\n      } catch (YarnException e) {\n        LOG.warn(\n            \"Exception while trying to release default queue capacity for plan: {}\",\n            planQueueName, e);\n      }\n      // sort allocations from the one giving up the most resources, to the\n      // one asking for the most\n      // avoid order-of-operation errors that temporarily violate 100%\n      // capacity bound\n      List\u003cReservationAllocation\u003e sortedAllocations \u003d\n          sortByDelta(\n              new ArrayList\u003cReservationAllocation\u003e(currentReservations), now,\n              plan);\n      for (ReservationAllocation res : sortedAllocations) {\n        String currResId \u003d res.getReservationId().toString();\n        if (curReservationNames.contains(currResId)) {\n          addReservationQueue(planQueueName, planQueue, currResId);\n        }\n        Resource capToAssign \u003d res.getResourcesAtTime(now);\n        float targetCapacity \u003d 0f;\n        if (planResources.getMemory() \u003e 0\n            \u0026\u0026 planResources.getVirtualCores() \u003e 0) {\n          targetCapacity \u003d\n              calculateReservationToPlanRatio(clusterResources,\n                  planResources,\n                  capToAssign);\n        }\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\n              \"Assigning capacity of {} to queue {} with target capacity {}\",\n              capToAssign, currResId, targetCapacity);\n        }\n        // set maxCapacity to 100% unless the job requires gang, in which\n        // case we stick to capacity (as running early/before is likely a\n        // waste of resources)\n        float maxCapacity \u003d 1.0f;\n        if (res.containsGangs()) {\n          maxCapacity \u003d targetCapacity;\n        }\n        try {\n          setQueueEntitlement(planQueueName, currResId, targetCapacity, maxCapacity);\n        } catch (YarnException e) {\n          LOG.warn(\"Exception while trying to size reservation for plan: {}\",\n              currResId, planQueueName, e);\n        }\n        totalAssignedCapacity +\u003d targetCapacity;\n      }\n    }\n    // compute the default queue capacity\n    float defQCap \u003d 1.0f - totalAssignedCapacity;\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"PlanFollowerEditPolicyTask: total Plan Capacity: {} \"\n          + \"currReservation: {} default-queue capacity: {}\", planResources,\n          numRes, defQCap);\n    }\n    // set the default queue to eat-up all remaining capacity\n    try {\n      setQueueEntitlement(planQueueName, defReservationQueue, defQCap, 1.0f);\n    } catch (YarnException e) {\n      LOG.warn(\n          \"Exception while trying to reclaim default queue capacity for plan: {}\",\n          planQueueName, e);\n    }\n    // garbage collect finished reservations from plan\n    try {\n      plan.archiveCompletedReservations(now);\n    } catch (PlanningException e) {\n      LOG.error(\"Exception in archiving completed reservations: \", e);\n    }\n    LOG.info(\"Finished iteration of plan follower edit policy for plan: \"\n        + planQueueName);\n\n    // Extension: update plan with app states,\n    // useful to support smart replanning\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/AbstractSchedulerPlanFollower.java",
          "extendedDetails": {
            "oldPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/CapacitySchedulerPlanFollower.java",
            "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/AbstractSchedulerPlanFollower.java",
            "oldMethodName": "synchronizePlan",
            "newMethodName": "synchronizePlan"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-2998. Abstract out scheduler independent PlanFollower components. (Anubhav Dhoot via kasha)\n",
          "commitDate": "30/12/14 7:55 PM",
          "commitName": "e7257acd8a7adb74d81cd1d009d4a99f023ed844",
          "commitAuthor": "Karthik Kambatla",
          "commitDateOld": "30/12/14 5:15 PM",
          "commitNameOld": "e2351c7ae24cea9b217af4174512d279c55e8efd",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 0.11,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,174 +1,145 @@\n   public synchronized void synchronizePlan(Plan plan) {\n-    String planQueueName \u003d plan.getQueueName();\n+     String planQueueName \u003d plan.getQueueName();\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Running plan follower edit policy for plan: \" + planQueueName);\n     }\n     // align with plan step\n     long step \u003d plan.getStep();\n     long now \u003d clock.getTime();\n     if (now % step !\u003d 0) {\n       now +\u003d step - (now % step);\n     }\n-    CSQueue queue \u003d scheduler.getQueue(planQueueName);\n-    if (!(queue instanceof PlanQueue)) {\n-      LOG.error(\"The Plan is not an PlanQueue!\");\n-      return;\n-    }\n-    PlanQueue planQueue \u003d (PlanQueue) queue;\n+    Queue planQueue \u003d getPlanQueue(planQueueName);\n+    if (planQueue \u003d\u003d null) return;\n+\n     // first we publish to the plan the current availability of resources\n     Resource clusterResources \u003d scheduler.getClusterResource();\n-    float planAbsCap \u003d planQueue.getAbsoluteCapacity();\n-    Resource planResources \u003d Resources.multiply(clusterResources, planAbsCap);\n-    plan.setTotalCapacity(planResources);\n+    Resource planResources \u003d getPlanResources(plan, planQueue,\n+        clusterResources);\n \n     Set\u003cReservationAllocation\u003e currentReservations \u003d\n         plan.getReservationsAtTime(now);\n     Set\u003cString\u003e curReservationNames \u003d new HashSet\u003cString\u003e();\n     Resource reservedResources \u003d Resource.newInstance(0, 0);\n-    int numRes \u003d 0;\n-    if (currentReservations !\u003d null) {\n-      numRes \u003d currentReservations.size();\n-      for (ReservationAllocation reservation : currentReservations) {\n-        curReservationNames.add(reservation.getReservationId().toString());\n-        Resources.addTo(reservedResources, reservation.getResourcesAtTime(now));\n-      }\n-    }\n+    int numRes \u003d getReservedResources(now, currentReservations,\n+        curReservationNames, reservedResources);\n+\n     // create the default reservation queue if it doesnt exist\n-    String defReservationQueue \u003d planQueueName + PlanQueue.DEFAULT_QUEUE_SUFFIX;\n-    if (scheduler.getQueue(defReservationQueue) \u003d\u003d null) {\n-      try {\n-        ReservationQueue defQueue \u003d\n-            new ReservationQueue(scheduler, defReservationQueue, planQueue);\n-        scheduler.addQueue(defQueue);\n-      } catch (SchedulerDynamicEditException e) {\n-        LOG.warn(\n-            \"Exception while trying to create default reservation queue for plan: {}\",\n-            planQueueName, e);\n-      } catch (IOException e) {\n-        LOG.warn(\n-            \"Exception while trying to create default reservation queue for plan: {}\",\n-            planQueueName, e);\n-      }\n-    }\n-    curReservationNames.add(defReservationQueue);\n+    String defReservationId \u003d getReservationIdFromQueueName(planQueueName) +\n+        PlanQueue.DEFAULT_QUEUE_SUFFIX;\n+    String defReservationQueue \u003d getReservationQueueName(planQueueName,\n+        defReservationId);\n+    createDefaultReservationQueue(planQueueName, planQueue,\n+        defReservationId);\n+    curReservationNames.add(defReservationId);\n+\n     // if the resources dedicated to this plan has shrunk invoke replanner\n-    if (Resources.greaterThan(scheduler.getResourceCalculator(),\n-        clusterResources, reservedResources, planResources)) {\n+    if (arePlanResourcesLessThanReservations(clusterResources, planResources,\n+        reservedResources)) {\n       try {\n         plan.getReplanner().plan(plan, null);\n       } catch (PlanningException e) {\n         LOG.warn(\"Exception while trying to replan: {}\", planQueueName, e);\n       }\n     }\n     // identify the reservations that have expired and new reservations that\n     // have to be activated\n-    List\u003cCSQueue\u003e resQueues \u003d planQueue.getChildQueues();\n+    List\u003c? extends Queue\u003e resQueues \u003d getChildReservationQueues(planQueue);\n     Set\u003cString\u003e expired \u003d new HashSet\u003cString\u003e();\n-    for (CSQueue resQueue : resQueues) {\n+    for (Queue resQueue : resQueues) {\n       String resQueueName \u003d resQueue.getQueueName();\n-      if (curReservationNames.contains(resQueueName)) {\n+      String reservationId \u003d getReservationIdFromQueueName(resQueueName);\n+      if (curReservationNames.contains(reservationId)) {\n         // it is already existing reservation, so needed not create new\n         // reservation queue\n-        curReservationNames.remove(resQueueName);\n+        curReservationNames.remove(reservationId);\n       } else {\n         // the reservation has termination, mark for cleanup\n-        expired.add(resQueueName);\n+        expired.add(reservationId);\n       }\n     }\n     // garbage collect expired reservations\n-    cleanupExpiredQueues(plan.getMoveOnExpiry(), expired, defReservationQueue);\n+    cleanupExpiredQueues(planQueueName, plan.getMoveOnExpiry(), expired,\n+        defReservationQueue);\n \n     // Add new reservations and update existing ones\n     float totalAssignedCapacity \u003d 0f;\n     if (currentReservations !\u003d null) {\n       // first release all excess capacity in default queue\n       try {\n-        scheduler.setEntitlement(defReservationQueue, new QueueEntitlement(0f,\n-            1.0f));\n+        setQueueEntitlement(planQueueName, defReservationQueue, 0f, 1.0f);\n       } catch (YarnException e) {\n         LOG.warn(\n             \"Exception while trying to release default queue capacity for plan: {}\",\n             planQueueName, e);\n       }\n       // sort allocations from the one giving up the most resources, to the\n       // one asking for the most\n       // avoid order-of-operation errors that temporarily violate 100%\n       // capacity bound\n       List\u003cReservationAllocation\u003e sortedAllocations \u003d\n           sortByDelta(\n-              new ArrayList\u003cReservationAllocation\u003e(currentReservations), now);\n+              new ArrayList\u003cReservationAllocation\u003e(currentReservations), now,\n+              plan);\n       for (ReservationAllocation res : sortedAllocations) {\n         String currResId \u003d res.getReservationId().toString();\n         if (curReservationNames.contains(currResId)) {\n-          try {\n-            ReservationQueue resQueue \u003d\n-                new ReservationQueue(scheduler, currResId, planQueue);\n-            scheduler.addQueue(resQueue);\n-          } catch (SchedulerDynamicEditException e) {\n-            LOG.warn(\n-                \"Exception while trying to activate reservation: {} for plan: {}\",\n-                currResId, planQueueName, e);\n-          } catch (IOException e) {\n-            LOG.warn(\n-                \"Exception while trying to activate reservation: {} for plan: {}\",\n-                currResId, planQueueName, e);\n-          }\n+          addReservationQueue(planQueueName, planQueue, currResId);\n         }\n         Resource capToAssign \u003d res.getResourcesAtTime(now);\n         float targetCapacity \u003d 0f;\n         if (planResources.getMemory() \u003e 0\n             \u0026\u0026 planResources.getVirtualCores() \u003e 0) {\n           targetCapacity \u003d\n-              Resources.divide(scheduler.getResourceCalculator(),\n-                  clusterResources, capToAssign, planResources);\n+              calculateReservationToPlanRatio(clusterResources,\n+                  planResources,\n+                  capToAssign);\n         }\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\n               \"Assigning capacity of {} to queue {} with target capacity {}\",\n               capToAssign, currResId, targetCapacity);\n         }\n         // set maxCapacity to 100% unless the job requires gang, in which\n         // case we stick to capacity (as running early/before is likely a\n         // waste of resources)\n         float maxCapacity \u003d 1.0f;\n         if (res.containsGangs()) {\n           maxCapacity \u003d targetCapacity;\n         }\n         try {\n-          scheduler.setEntitlement(currResId, new QueueEntitlement(\n-              targetCapacity, maxCapacity));\n+          setQueueEntitlement(planQueueName, currResId, targetCapacity, maxCapacity);\n         } catch (YarnException e) {\n           LOG.warn(\"Exception while trying to size reservation for plan: {}\",\n               currResId, planQueueName, e);\n         }\n         totalAssignedCapacity +\u003d targetCapacity;\n       }\n     }\n     // compute the default queue capacity\n     float defQCap \u003d 1.0f - totalAssignedCapacity;\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"PlanFollowerEditPolicyTask: total Plan Capacity: {} \"\n           + \"currReservation: {} default-queue capacity: {}\", planResources,\n           numRes, defQCap);\n     }\n     // set the default queue to eat-up all remaining capacity\n     try {\n-      scheduler.setEntitlement(defReservationQueue, new QueueEntitlement(\n-          defQCap, 1.0f));\n+      setQueueEntitlement(planQueueName, defReservationQueue, defQCap, 1.0f);\n     } catch (YarnException e) {\n       LOG.warn(\n           \"Exception while trying to reclaim default queue capacity for plan: {}\",\n           planQueueName, e);\n     }\n     // garbage collect finished reservations from plan\n     try {\n       plan.archiveCompletedReservations(now);\n     } catch (PlanningException e) {\n       LOG.error(\"Exception in archiving completed reservations: \", e);\n     }\n     LOG.info(\"Finished iteration of plan follower edit policy for plan: \"\n         + planQueueName);\n \n     // Extension: update plan with app states,\n     // useful to support smart replanning\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public synchronized void synchronizePlan(Plan plan) {\n     String planQueueName \u003d plan.getQueueName();\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Running plan follower edit policy for plan: \" + planQueueName);\n    }\n    // align with plan step\n    long step \u003d plan.getStep();\n    long now \u003d clock.getTime();\n    if (now % step !\u003d 0) {\n      now +\u003d step - (now % step);\n    }\n    Queue planQueue \u003d getPlanQueue(planQueueName);\n    if (planQueue \u003d\u003d null) return;\n\n    // first we publish to the plan the current availability of resources\n    Resource clusterResources \u003d scheduler.getClusterResource();\n    Resource planResources \u003d getPlanResources(plan, planQueue,\n        clusterResources);\n\n    Set\u003cReservationAllocation\u003e currentReservations \u003d\n        plan.getReservationsAtTime(now);\n    Set\u003cString\u003e curReservationNames \u003d new HashSet\u003cString\u003e();\n    Resource reservedResources \u003d Resource.newInstance(0, 0);\n    int numRes \u003d getReservedResources(now, currentReservations,\n        curReservationNames, reservedResources);\n\n    // create the default reservation queue if it doesnt exist\n    String defReservationId \u003d getReservationIdFromQueueName(planQueueName) +\n        PlanQueue.DEFAULT_QUEUE_SUFFIX;\n    String defReservationQueue \u003d getReservationQueueName(planQueueName,\n        defReservationId);\n    createDefaultReservationQueue(planQueueName, planQueue,\n        defReservationId);\n    curReservationNames.add(defReservationId);\n\n    // if the resources dedicated to this plan has shrunk invoke replanner\n    if (arePlanResourcesLessThanReservations(clusterResources, planResources,\n        reservedResources)) {\n      try {\n        plan.getReplanner().plan(plan, null);\n      } catch (PlanningException e) {\n        LOG.warn(\"Exception while trying to replan: {}\", planQueueName, e);\n      }\n    }\n    // identify the reservations that have expired and new reservations that\n    // have to be activated\n    List\u003c? extends Queue\u003e resQueues \u003d getChildReservationQueues(planQueue);\n    Set\u003cString\u003e expired \u003d new HashSet\u003cString\u003e();\n    for (Queue resQueue : resQueues) {\n      String resQueueName \u003d resQueue.getQueueName();\n      String reservationId \u003d getReservationIdFromQueueName(resQueueName);\n      if (curReservationNames.contains(reservationId)) {\n        // it is already existing reservation, so needed not create new\n        // reservation queue\n        curReservationNames.remove(reservationId);\n      } else {\n        // the reservation has termination, mark for cleanup\n        expired.add(reservationId);\n      }\n    }\n    // garbage collect expired reservations\n    cleanupExpiredQueues(planQueueName, plan.getMoveOnExpiry(), expired,\n        defReservationQueue);\n\n    // Add new reservations and update existing ones\n    float totalAssignedCapacity \u003d 0f;\n    if (currentReservations !\u003d null) {\n      // first release all excess capacity in default queue\n      try {\n        setQueueEntitlement(planQueueName, defReservationQueue, 0f, 1.0f);\n      } catch (YarnException e) {\n        LOG.warn(\n            \"Exception while trying to release default queue capacity for plan: {}\",\n            planQueueName, e);\n      }\n      // sort allocations from the one giving up the most resources, to the\n      // one asking for the most\n      // avoid order-of-operation errors that temporarily violate 100%\n      // capacity bound\n      List\u003cReservationAllocation\u003e sortedAllocations \u003d\n          sortByDelta(\n              new ArrayList\u003cReservationAllocation\u003e(currentReservations), now,\n              plan);\n      for (ReservationAllocation res : sortedAllocations) {\n        String currResId \u003d res.getReservationId().toString();\n        if (curReservationNames.contains(currResId)) {\n          addReservationQueue(planQueueName, planQueue, currResId);\n        }\n        Resource capToAssign \u003d res.getResourcesAtTime(now);\n        float targetCapacity \u003d 0f;\n        if (planResources.getMemory() \u003e 0\n            \u0026\u0026 planResources.getVirtualCores() \u003e 0) {\n          targetCapacity \u003d\n              calculateReservationToPlanRatio(clusterResources,\n                  planResources,\n                  capToAssign);\n        }\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\n              \"Assigning capacity of {} to queue {} with target capacity {}\",\n              capToAssign, currResId, targetCapacity);\n        }\n        // set maxCapacity to 100% unless the job requires gang, in which\n        // case we stick to capacity (as running early/before is likely a\n        // waste of resources)\n        float maxCapacity \u003d 1.0f;\n        if (res.containsGangs()) {\n          maxCapacity \u003d targetCapacity;\n        }\n        try {\n          setQueueEntitlement(planQueueName, currResId, targetCapacity, maxCapacity);\n        } catch (YarnException e) {\n          LOG.warn(\"Exception while trying to size reservation for plan: {}\",\n              currResId, planQueueName, e);\n        }\n        totalAssignedCapacity +\u003d targetCapacity;\n      }\n    }\n    // compute the default queue capacity\n    float defQCap \u003d 1.0f - totalAssignedCapacity;\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"PlanFollowerEditPolicyTask: total Plan Capacity: {} \"\n          + \"currReservation: {} default-queue capacity: {}\", planResources,\n          numRes, defQCap);\n    }\n    // set the default queue to eat-up all remaining capacity\n    try {\n      setQueueEntitlement(planQueueName, defReservationQueue, defQCap, 1.0f);\n    } catch (YarnException e) {\n      LOG.warn(\n          \"Exception while trying to reclaim default queue capacity for plan: {}\",\n          planQueueName, e);\n    }\n    // garbage collect finished reservations from plan\n    try {\n      plan.archiveCompletedReservations(now);\n    } catch (PlanningException e) {\n      LOG.error(\"Exception in archiving completed reservations: \", e);\n    }\n    LOG.info(\"Finished iteration of plan follower edit policy for plan: \"\n        + planQueueName);\n\n    // Extension: update plan with app states,\n    // useful to support smart replanning\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/AbstractSchedulerPlanFollower.java",
          "extendedDetails": {}
        }
      ]
    },
    "f2ea555ac6c06a3f2f6559731f48711fff05d3f1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2496. Enhanced Capacity Scheduler to have basic support for allocating resources based on node-labels. Contributed by Wangda Tan.\nYARN-2500. Ehnaced ResourceManager to support schedulers allocating resources based on node-labels. Contributed by Wangda Tan.\n",
      "commitDate": "15/10/14 6:33 PM",
      "commitName": "f2ea555ac6c06a3f2f6559731f48711fff05d3f1",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "03/10/14 3:43 PM",
      "commitNameOld": "a2986234be4e02f9ccb589f9ff5f7ffb28bc6400",
      "commitAuthorOld": "subru",
      "daysBetweenCommits": 12.12,
      "commitsBetweenForRepo": 88,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,166 +1,174 @@\n   public synchronized void synchronizePlan(Plan plan) {\n     String planQueueName \u003d plan.getQueueName();\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Running plan follower edit policy for plan: \" + planQueueName);\n     }\n     // align with plan step\n     long step \u003d plan.getStep();\n     long now \u003d clock.getTime();\n     if (now % step !\u003d 0) {\n       now +\u003d step - (now % step);\n     }\n     CSQueue queue \u003d scheduler.getQueue(planQueueName);\n     if (!(queue instanceof PlanQueue)) {\n       LOG.error(\"The Plan is not an PlanQueue!\");\n       return;\n     }\n     PlanQueue planQueue \u003d (PlanQueue) queue;\n     // first we publish to the plan the current availability of resources\n     Resource clusterResources \u003d scheduler.getClusterResource();\n     float planAbsCap \u003d planQueue.getAbsoluteCapacity();\n     Resource planResources \u003d Resources.multiply(clusterResources, planAbsCap);\n     plan.setTotalCapacity(planResources);\n \n     Set\u003cReservationAllocation\u003e currentReservations \u003d\n         plan.getReservationsAtTime(now);\n     Set\u003cString\u003e curReservationNames \u003d new HashSet\u003cString\u003e();\n     Resource reservedResources \u003d Resource.newInstance(0, 0);\n     int numRes \u003d 0;\n     if (currentReservations !\u003d null) {\n       numRes \u003d currentReservations.size();\n       for (ReservationAllocation reservation : currentReservations) {\n         curReservationNames.add(reservation.getReservationId().toString());\n         Resources.addTo(reservedResources, reservation.getResourcesAtTime(now));\n       }\n     }\n     // create the default reservation queue if it doesnt exist\n     String defReservationQueue \u003d planQueueName + PlanQueue.DEFAULT_QUEUE_SUFFIX;\n     if (scheduler.getQueue(defReservationQueue) \u003d\u003d null) {\n-      ReservationQueue defQueue \u003d\n-          new ReservationQueue(scheduler, defReservationQueue, planQueue);\n       try {\n+        ReservationQueue defQueue \u003d\n+            new ReservationQueue(scheduler, defReservationQueue, planQueue);\n         scheduler.addQueue(defQueue);\n       } catch (SchedulerDynamicEditException e) {\n         LOG.warn(\n             \"Exception while trying to create default reservation queue for plan: {}\",\n             planQueueName, e);\n+      } catch (IOException e) {\n+        LOG.warn(\n+            \"Exception while trying to create default reservation queue for plan: {}\",\n+            planQueueName, e);\n       }\n     }\n     curReservationNames.add(defReservationQueue);\n     // if the resources dedicated to this plan has shrunk invoke replanner\n     if (Resources.greaterThan(scheduler.getResourceCalculator(),\n         clusterResources, reservedResources, planResources)) {\n       try {\n         plan.getReplanner().plan(plan, null);\n       } catch (PlanningException e) {\n         LOG.warn(\"Exception while trying to replan: {}\", planQueueName, e);\n       }\n     }\n     // identify the reservations that have expired and new reservations that\n     // have to be activated\n     List\u003cCSQueue\u003e resQueues \u003d planQueue.getChildQueues();\n     Set\u003cString\u003e expired \u003d new HashSet\u003cString\u003e();\n     for (CSQueue resQueue : resQueues) {\n       String resQueueName \u003d resQueue.getQueueName();\n       if (curReservationNames.contains(resQueueName)) {\n         // it is already existing reservation, so needed not create new\n         // reservation queue\n         curReservationNames.remove(resQueueName);\n       } else {\n         // the reservation has termination, mark for cleanup\n         expired.add(resQueueName);\n       }\n     }\n     // garbage collect expired reservations\n     cleanupExpiredQueues(plan.getMoveOnExpiry(), expired, defReservationQueue);\n \n     // Add new reservations and update existing ones\n     float totalAssignedCapacity \u003d 0f;\n     if (currentReservations !\u003d null) {\n       // first release all excess capacity in default queue\n       try {\n         scheduler.setEntitlement(defReservationQueue, new QueueEntitlement(0f,\n             1.0f));\n       } catch (YarnException e) {\n         LOG.warn(\n             \"Exception while trying to release default queue capacity for plan: {}\",\n             planQueueName, e);\n       }\n       // sort allocations from the one giving up the most resources, to the\n       // one asking for the most\n       // avoid order-of-operation errors that temporarily violate 100%\n       // capacity bound\n       List\u003cReservationAllocation\u003e sortedAllocations \u003d\n           sortByDelta(\n               new ArrayList\u003cReservationAllocation\u003e(currentReservations), now);\n       for (ReservationAllocation res : sortedAllocations) {\n         String currResId \u003d res.getReservationId().toString();\n         if (curReservationNames.contains(currResId)) {\n-          ReservationQueue resQueue \u003d\n-              new ReservationQueue(scheduler, currResId, planQueue);\n           try {\n+            ReservationQueue resQueue \u003d\n+                new ReservationQueue(scheduler, currResId, planQueue);\n             scheduler.addQueue(resQueue);\n           } catch (SchedulerDynamicEditException e) {\n             LOG.warn(\n                 \"Exception while trying to activate reservation: {} for plan: {}\",\n                 currResId, planQueueName, e);\n+          } catch (IOException e) {\n+            LOG.warn(\n+                \"Exception while trying to activate reservation: {} for plan: {}\",\n+                currResId, planQueueName, e);\n           }\n         }\n         Resource capToAssign \u003d res.getResourcesAtTime(now);\n         float targetCapacity \u003d 0f;\n         if (planResources.getMemory() \u003e 0\n             \u0026\u0026 planResources.getVirtualCores() \u003e 0) {\n           targetCapacity \u003d\n               Resources.divide(scheduler.getResourceCalculator(),\n                   clusterResources, capToAssign, planResources);\n         }\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\n               \"Assigning capacity of {} to queue {} with target capacity {}\",\n               capToAssign, currResId, targetCapacity);\n         }\n         // set maxCapacity to 100% unless the job requires gang, in which\n         // case we stick to capacity (as running early/before is likely a\n         // waste of resources)\n         float maxCapacity \u003d 1.0f;\n         if (res.containsGangs()) {\n           maxCapacity \u003d targetCapacity;\n         }\n         try {\n           scheduler.setEntitlement(currResId, new QueueEntitlement(\n               targetCapacity, maxCapacity));\n         } catch (YarnException e) {\n           LOG.warn(\"Exception while trying to size reservation for plan: {}\",\n               currResId, planQueueName, e);\n         }\n         totalAssignedCapacity +\u003d targetCapacity;\n       }\n     }\n     // compute the default queue capacity\n     float defQCap \u003d 1.0f - totalAssignedCapacity;\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"PlanFollowerEditPolicyTask: total Plan Capacity: {} \"\n           + \"currReservation: {} default-queue capacity: {}\", planResources,\n           numRes, defQCap);\n     }\n     // set the default queue to eat-up all remaining capacity\n     try {\n       scheduler.setEntitlement(defReservationQueue, new QueueEntitlement(\n           defQCap, 1.0f));\n     } catch (YarnException e) {\n       LOG.warn(\n           \"Exception while trying to reclaim default queue capacity for plan: {}\",\n           planQueueName, e);\n     }\n     // garbage collect finished reservations from plan\n     try {\n       plan.archiveCompletedReservations(now);\n     } catch (PlanningException e) {\n       LOG.error(\"Exception in archiving completed reservations: \", e);\n     }\n     LOG.info(\"Finished iteration of plan follower edit policy for plan: \"\n         + planQueueName);\n \n     // Extension: update plan with app states,\n     // useful to support smart replanning\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void synchronizePlan(Plan plan) {\n    String planQueueName \u003d plan.getQueueName();\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Running plan follower edit policy for plan: \" + planQueueName);\n    }\n    // align with plan step\n    long step \u003d plan.getStep();\n    long now \u003d clock.getTime();\n    if (now % step !\u003d 0) {\n      now +\u003d step - (now % step);\n    }\n    CSQueue queue \u003d scheduler.getQueue(planQueueName);\n    if (!(queue instanceof PlanQueue)) {\n      LOG.error(\"The Plan is not an PlanQueue!\");\n      return;\n    }\n    PlanQueue planQueue \u003d (PlanQueue) queue;\n    // first we publish to the plan the current availability of resources\n    Resource clusterResources \u003d scheduler.getClusterResource();\n    float planAbsCap \u003d planQueue.getAbsoluteCapacity();\n    Resource planResources \u003d Resources.multiply(clusterResources, planAbsCap);\n    plan.setTotalCapacity(planResources);\n\n    Set\u003cReservationAllocation\u003e currentReservations \u003d\n        plan.getReservationsAtTime(now);\n    Set\u003cString\u003e curReservationNames \u003d new HashSet\u003cString\u003e();\n    Resource reservedResources \u003d Resource.newInstance(0, 0);\n    int numRes \u003d 0;\n    if (currentReservations !\u003d null) {\n      numRes \u003d currentReservations.size();\n      for (ReservationAllocation reservation : currentReservations) {\n        curReservationNames.add(reservation.getReservationId().toString());\n        Resources.addTo(reservedResources, reservation.getResourcesAtTime(now));\n      }\n    }\n    // create the default reservation queue if it doesnt exist\n    String defReservationQueue \u003d planQueueName + PlanQueue.DEFAULT_QUEUE_SUFFIX;\n    if (scheduler.getQueue(defReservationQueue) \u003d\u003d null) {\n      try {\n        ReservationQueue defQueue \u003d\n            new ReservationQueue(scheduler, defReservationQueue, planQueue);\n        scheduler.addQueue(defQueue);\n      } catch (SchedulerDynamicEditException e) {\n        LOG.warn(\n            \"Exception while trying to create default reservation queue for plan: {}\",\n            planQueueName, e);\n      } catch (IOException e) {\n        LOG.warn(\n            \"Exception while trying to create default reservation queue for plan: {}\",\n            planQueueName, e);\n      }\n    }\n    curReservationNames.add(defReservationQueue);\n    // if the resources dedicated to this plan has shrunk invoke replanner\n    if (Resources.greaterThan(scheduler.getResourceCalculator(),\n        clusterResources, reservedResources, planResources)) {\n      try {\n        plan.getReplanner().plan(plan, null);\n      } catch (PlanningException e) {\n        LOG.warn(\"Exception while trying to replan: {}\", planQueueName, e);\n      }\n    }\n    // identify the reservations that have expired and new reservations that\n    // have to be activated\n    List\u003cCSQueue\u003e resQueues \u003d planQueue.getChildQueues();\n    Set\u003cString\u003e expired \u003d new HashSet\u003cString\u003e();\n    for (CSQueue resQueue : resQueues) {\n      String resQueueName \u003d resQueue.getQueueName();\n      if (curReservationNames.contains(resQueueName)) {\n        // it is already existing reservation, so needed not create new\n        // reservation queue\n        curReservationNames.remove(resQueueName);\n      } else {\n        // the reservation has termination, mark for cleanup\n        expired.add(resQueueName);\n      }\n    }\n    // garbage collect expired reservations\n    cleanupExpiredQueues(plan.getMoveOnExpiry(), expired, defReservationQueue);\n\n    // Add new reservations and update existing ones\n    float totalAssignedCapacity \u003d 0f;\n    if (currentReservations !\u003d null) {\n      // first release all excess capacity in default queue\n      try {\n        scheduler.setEntitlement(defReservationQueue, new QueueEntitlement(0f,\n            1.0f));\n      } catch (YarnException e) {\n        LOG.warn(\n            \"Exception while trying to release default queue capacity for plan: {}\",\n            planQueueName, e);\n      }\n      // sort allocations from the one giving up the most resources, to the\n      // one asking for the most\n      // avoid order-of-operation errors that temporarily violate 100%\n      // capacity bound\n      List\u003cReservationAllocation\u003e sortedAllocations \u003d\n          sortByDelta(\n              new ArrayList\u003cReservationAllocation\u003e(currentReservations), now);\n      for (ReservationAllocation res : sortedAllocations) {\n        String currResId \u003d res.getReservationId().toString();\n        if (curReservationNames.contains(currResId)) {\n          try {\n            ReservationQueue resQueue \u003d\n                new ReservationQueue(scheduler, currResId, planQueue);\n            scheduler.addQueue(resQueue);\n          } catch (SchedulerDynamicEditException e) {\n            LOG.warn(\n                \"Exception while trying to activate reservation: {} for plan: {}\",\n                currResId, planQueueName, e);\n          } catch (IOException e) {\n            LOG.warn(\n                \"Exception while trying to activate reservation: {} for plan: {}\",\n                currResId, planQueueName, e);\n          }\n        }\n        Resource capToAssign \u003d res.getResourcesAtTime(now);\n        float targetCapacity \u003d 0f;\n        if (planResources.getMemory() \u003e 0\n            \u0026\u0026 planResources.getVirtualCores() \u003e 0) {\n          targetCapacity \u003d\n              Resources.divide(scheduler.getResourceCalculator(),\n                  clusterResources, capToAssign, planResources);\n        }\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\n              \"Assigning capacity of {} to queue {} with target capacity {}\",\n              capToAssign, currResId, targetCapacity);\n        }\n        // set maxCapacity to 100% unless the job requires gang, in which\n        // case we stick to capacity (as running early/before is likely a\n        // waste of resources)\n        float maxCapacity \u003d 1.0f;\n        if (res.containsGangs()) {\n          maxCapacity \u003d targetCapacity;\n        }\n        try {\n          scheduler.setEntitlement(currResId, new QueueEntitlement(\n              targetCapacity, maxCapacity));\n        } catch (YarnException e) {\n          LOG.warn(\"Exception while trying to size reservation for plan: {}\",\n              currResId, planQueueName, e);\n        }\n        totalAssignedCapacity +\u003d targetCapacity;\n      }\n    }\n    // compute the default queue capacity\n    float defQCap \u003d 1.0f - totalAssignedCapacity;\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"PlanFollowerEditPolicyTask: total Plan Capacity: {} \"\n          + \"currReservation: {} default-queue capacity: {}\", planResources,\n          numRes, defQCap);\n    }\n    // set the default queue to eat-up all remaining capacity\n    try {\n      scheduler.setEntitlement(defReservationQueue, new QueueEntitlement(\n          defQCap, 1.0f));\n    } catch (YarnException e) {\n      LOG.warn(\n          \"Exception while trying to reclaim default queue capacity for plan: {}\",\n          planQueueName, e);\n    }\n    // garbage collect finished reservations from plan\n    try {\n      plan.archiveCompletedReservations(now);\n    } catch (PlanningException e) {\n      LOG.error(\"Exception in archiving completed reservations: \", e);\n    }\n    LOG.info(\"Finished iteration of plan follower edit policy for plan: \"\n        + planQueueName);\n\n    // Extension: update plan with app states,\n    // useful to support smart replanning\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/CapacitySchedulerPlanFollower.java",
      "extendedDetails": {}
    },
    "3418c56bcf4bbddaf483bdaa1a15a8bbc4039bfe": {
      "type": "Yintroduced",
      "commitMessage": "YARN-1712. Plan follower that synchronizes the current state of reservation subsystem with the scheduler. Contributed by Subru Krishnan and Carlo Curino.\n(cherry picked from commit 169085319b8b76641f8b9f6840a3fef06d221e2b)\n",
      "commitDate": "03/10/14 3:42 PM",
      "commitName": "3418c56bcf4bbddaf483bdaa1a15a8bbc4039bfe",
      "commitAuthor": "subru",
      "diff": "@@ -0,0 +1,166 @@\n+  public synchronized void synchronizePlan(Plan plan) {\n+    String planQueueName \u003d plan.getQueueName();\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(\"Running plan follower edit policy for plan: \" + planQueueName);\n+    }\n+    // align with plan step\n+    long step \u003d plan.getStep();\n+    long now \u003d clock.getTime();\n+    if (now % step !\u003d 0) {\n+      now +\u003d step - (now % step);\n+    }\n+    CSQueue queue \u003d scheduler.getQueue(planQueueName);\n+    if (!(queue instanceof PlanQueue)) {\n+      LOG.error(\"The Plan is not an PlanQueue!\");\n+      return;\n+    }\n+    PlanQueue planQueue \u003d (PlanQueue) queue;\n+    // first we publish to the plan the current availability of resources\n+    Resource clusterResources \u003d scheduler.getClusterResource();\n+    float planAbsCap \u003d planQueue.getAbsoluteCapacity();\n+    Resource planResources \u003d Resources.multiply(clusterResources, planAbsCap);\n+    plan.setTotalCapacity(planResources);\n+\n+    Set\u003cReservationAllocation\u003e currentReservations \u003d\n+        plan.getReservationsAtTime(now);\n+    Set\u003cString\u003e curReservationNames \u003d new HashSet\u003cString\u003e();\n+    Resource reservedResources \u003d Resource.newInstance(0, 0);\n+    int numRes \u003d 0;\n+    if (currentReservations !\u003d null) {\n+      numRes \u003d currentReservations.size();\n+      for (ReservationAllocation reservation : currentReservations) {\n+        curReservationNames.add(reservation.getReservationId().toString());\n+        Resources.addTo(reservedResources, reservation.getResourcesAtTime(now));\n+      }\n+    }\n+    // create the default reservation queue if it doesnt exist\n+    String defReservationQueue \u003d planQueueName + PlanQueue.DEFAULT_QUEUE_SUFFIX;\n+    if (scheduler.getQueue(defReservationQueue) \u003d\u003d null) {\n+      ReservationQueue defQueue \u003d\n+          new ReservationQueue(scheduler, defReservationQueue, planQueue);\n+      try {\n+        scheduler.addQueue(defQueue);\n+      } catch (SchedulerDynamicEditException e) {\n+        LOG.warn(\n+            \"Exception while trying to create default reservation queue for plan: {}\",\n+            planQueueName, e);\n+      }\n+    }\n+    curReservationNames.add(defReservationQueue);\n+    // if the resources dedicated to this plan has shrunk invoke replanner\n+    if (Resources.greaterThan(scheduler.getResourceCalculator(),\n+        clusterResources, reservedResources, planResources)) {\n+      try {\n+        plan.getReplanner().plan(plan, null);\n+      } catch (PlanningException e) {\n+        LOG.warn(\"Exception while trying to replan: {}\", planQueueName, e);\n+      }\n+    }\n+    // identify the reservations that have expired and new reservations that\n+    // have to be activated\n+    List\u003cCSQueue\u003e resQueues \u003d planQueue.getChildQueues();\n+    Set\u003cString\u003e expired \u003d new HashSet\u003cString\u003e();\n+    for (CSQueue resQueue : resQueues) {\n+      String resQueueName \u003d resQueue.getQueueName();\n+      if (curReservationNames.contains(resQueueName)) {\n+        // it is already existing reservation, so needed not create new\n+        // reservation queue\n+        curReservationNames.remove(resQueueName);\n+      } else {\n+        // the reservation has termination, mark for cleanup\n+        expired.add(resQueueName);\n+      }\n+    }\n+    // garbage collect expired reservations\n+    cleanupExpiredQueues(plan.getMoveOnExpiry(), expired, defReservationQueue);\n+\n+    // Add new reservations and update existing ones\n+    float totalAssignedCapacity \u003d 0f;\n+    if (currentReservations !\u003d null) {\n+      // first release all excess capacity in default queue\n+      try {\n+        scheduler.setEntitlement(defReservationQueue, new QueueEntitlement(0f,\n+            1.0f));\n+      } catch (YarnException e) {\n+        LOG.warn(\n+            \"Exception while trying to release default queue capacity for plan: {}\",\n+            planQueueName, e);\n+      }\n+      // sort allocations from the one giving up the most resources, to the\n+      // one asking for the most\n+      // avoid order-of-operation errors that temporarily violate 100%\n+      // capacity bound\n+      List\u003cReservationAllocation\u003e sortedAllocations \u003d\n+          sortByDelta(\n+              new ArrayList\u003cReservationAllocation\u003e(currentReservations), now);\n+      for (ReservationAllocation res : sortedAllocations) {\n+        String currResId \u003d res.getReservationId().toString();\n+        if (curReservationNames.contains(currResId)) {\n+          ReservationQueue resQueue \u003d\n+              new ReservationQueue(scheduler, currResId, planQueue);\n+          try {\n+            scheduler.addQueue(resQueue);\n+          } catch (SchedulerDynamicEditException e) {\n+            LOG.warn(\n+                \"Exception while trying to activate reservation: {} for plan: {}\",\n+                currResId, planQueueName, e);\n+          }\n+        }\n+        Resource capToAssign \u003d res.getResourcesAtTime(now);\n+        float targetCapacity \u003d 0f;\n+        if (planResources.getMemory() \u003e 0\n+            \u0026\u0026 planResources.getVirtualCores() \u003e 0) {\n+          targetCapacity \u003d\n+              Resources.divide(scheduler.getResourceCalculator(),\n+                  clusterResources, capToAssign, planResources);\n+        }\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\n+              \"Assigning capacity of {} to queue {} with target capacity {}\",\n+              capToAssign, currResId, targetCapacity);\n+        }\n+        // set maxCapacity to 100% unless the job requires gang, in which\n+        // case we stick to capacity (as running early/before is likely a\n+        // waste of resources)\n+        float maxCapacity \u003d 1.0f;\n+        if (res.containsGangs()) {\n+          maxCapacity \u003d targetCapacity;\n+        }\n+        try {\n+          scheduler.setEntitlement(currResId, new QueueEntitlement(\n+              targetCapacity, maxCapacity));\n+        } catch (YarnException e) {\n+          LOG.warn(\"Exception while trying to size reservation for plan: {}\",\n+              currResId, planQueueName, e);\n+        }\n+        totalAssignedCapacity +\u003d targetCapacity;\n+      }\n+    }\n+    // compute the default queue capacity\n+    float defQCap \u003d 1.0f - totalAssignedCapacity;\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(\"PlanFollowerEditPolicyTask: total Plan Capacity: {} \"\n+          + \"currReservation: {} default-queue capacity: {}\", planResources,\n+          numRes, defQCap);\n+    }\n+    // set the default queue to eat-up all remaining capacity\n+    try {\n+      scheduler.setEntitlement(defReservationQueue, new QueueEntitlement(\n+          defQCap, 1.0f));\n+    } catch (YarnException e) {\n+      LOG.warn(\n+          \"Exception while trying to reclaim default queue capacity for plan: {}\",\n+          planQueueName, e);\n+    }\n+    // garbage collect finished reservations from plan\n+    try {\n+      plan.archiveCompletedReservations(now);\n+    } catch (PlanningException e) {\n+      LOG.error(\"Exception in archiving completed reservations: \", e);\n+    }\n+    LOG.info(\"Finished iteration of plan follower edit policy for plan: \"\n+        + planQueueName);\n+\n+    // Extension: update plan with app states,\n+    // useful to support smart replanning\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void synchronizePlan(Plan plan) {\n    String planQueueName \u003d plan.getQueueName();\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Running plan follower edit policy for plan: \" + planQueueName);\n    }\n    // align with plan step\n    long step \u003d plan.getStep();\n    long now \u003d clock.getTime();\n    if (now % step !\u003d 0) {\n      now +\u003d step - (now % step);\n    }\n    CSQueue queue \u003d scheduler.getQueue(planQueueName);\n    if (!(queue instanceof PlanQueue)) {\n      LOG.error(\"The Plan is not an PlanQueue!\");\n      return;\n    }\n    PlanQueue planQueue \u003d (PlanQueue) queue;\n    // first we publish to the plan the current availability of resources\n    Resource clusterResources \u003d scheduler.getClusterResource();\n    float planAbsCap \u003d planQueue.getAbsoluteCapacity();\n    Resource planResources \u003d Resources.multiply(clusterResources, planAbsCap);\n    plan.setTotalCapacity(planResources);\n\n    Set\u003cReservationAllocation\u003e currentReservations \u003d\n        plan.getReservationsAtTime(now);\n    Set\u003cString\u003e curReservationNames \u003d new HashSet\u003cString\u003e();\n    Resource reservedResources \u003d Resource.newInstance(0, 0);\n    int numRes \u003d 0;\n    if (currentReservations !\u003d null) {\n      numRes \u003d currentReservations.size();\n      for (ReservationAllocation reservation : currentReservations) {\n        curReservationNames.add(reservation.getReservationId().toString());\n        Resources.addTo(reservedResources, reservation.getResourcesAtTime(now));\n      }\n    }\n    // create the default reservation queue if it doesnt exist\n    String defReservationQueue \u003d planQueueName + PlanQueue.DEFAULT_QUEUE_SUFFIX;\n    if (scheduler.getQueue(defReservationQueue) \u003d\u003d null) {\n      ReservationQueue defQueue \u003d\n          new ReservationQueue(scheduler, defReservationQueue, planQueue);\n      try {\n        scheduler.addQueue(defQueue);\n      } catch (SchedulerDynamicEditException e) {\n        LOG.warn(\n            \"Exception while trying to create default reservation queue for plan: {}\",\n            planQueueName, e);\n      }\n    }\n    curReservationNames.add(defReservationQueue);\n    // if the resources dedicated to this plan has shrunk invoke replanner\n    if (Resources.greaterThan(scheduler.getResourceCalculator(),\n        clusterResources, reservedResources, planResources)) {\n      try {\n        plan.getReplanner().plan(plan, null);\n      } catch (PlanningException e) {\n        LOG.warn(\"Exception while trying to replan: {}\", planQueueName, e);\n      }\n    }\n    // identify the reservations that have expired and new reservations that\n    // have to be activated\n    List\u003cCSQueue\u003e resQueues \u003d planQueue.getChildQueues();\n    Set\u003cString\u003e expired \u003d new HashSet\u003cString\u003e();\n    for (CSQueue resQueue : resQueues) {\n      String resQueueName \u003d resQueue.getQueueName();\n      if (curReservationNames.contains(resQueueName)) {\n        // it is already existing reservation, so needed not create new\n        // reservation queue\n        curReservationNames.remove(resQueueName);\n      } else {\n        // the reservation has termination, mark for cleanup\n        expired.add(resQueueName);\n      }\n    }\n    // garbage collect expired reservations\n    cleanupExpiredQueues(plan.getMoveOnExpiry(), expired, defReservationQueue);\n\n    // Add new reservations and update existing ones\n    float totalAssignedCapacity \u003d 0f;\n    if (currentReservations !\u003d null) {\n      // first release all excess capacity in default queue\n      try {\n        scheduler.setEntitlement(defReservationQueue, new QueueEntitlement(0f,\n            1.0f));\n      } catch (YarnException e) {\n        LOG.warn(\n            \"Exception while trying to release default queue capacity for plan: {}\",\n            planQueueName, e);\n      }\n      // sort allocations from the one giving up the most resources, to the\n      // one asking for the most\n      // avoid order-of-operation errors that temporarily violate 100%\n      // capacity bound\n      List\u003cReservationAllocation\u003e sortedAllocations \u003d\n          sortByDelta(\n              new ArrayList\u003cReservationAllocation\u003e(currentReservations), now);\n      for (ReservationAllocation res : sortedAllocations) {\n        String currResId \u003d res.getReservationId().toString();\n        if (curReservationNames.contains(currResId)) {\n          ReservationQueue resQueue \u003d\n              new ReservationQueue(scheduler, currResId, planQueue);\n          try {\n            scheduler.addQueue(resQueue);\n          } catch (SchedulerDynamicEditException e) {\n            LOG.warn(\n                \"Exception while trying to activate reservation: {} for plan: {}\",\n                currResId, planQueueName, e);\n          }\n        }\n        Resource capToAssign \u003d res.getResourcesAtTime(now);\n        float targetCapacity \u003d 0f;\n        if (planResources.getMemory() \u003e 0\n            \u0026\u0026 planResources.getVirtualCores() \u003e 0) {\n          targetCapacity \u003d\n              Resources.divide(scheduler.getResourceCalculator(),\n                  clusterResources, capToAssign, planResources);\n        }\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\n              \"Assigning capacity of {} to queue {} with target capacity {}\",\n              capToAssign, currResId, targetCapacity);\n        }\n        // set maxCapacity to 100% unless the job requires gang, in which\n        // case we stick to capacity (as running early/before is likely a\n        // waste of resources)\n        float maxCapacity \u003d 1.0f;\n        if (res.containsGangs()) {\n          maxCapacity \u003d targetCapacity;\n        }\n        try {\n          scheduler.setEntitlement(currResId, new QueueEntitlement(\n              targetCapacity, maxCapacity));\n        } catch (YarnException e) {\n          LOG.warn(\"Exception while trying to size reservation for plan: {}\",\n              currResId, planQueueName, e);\n        }\n        totalAssignedCapacity +\u003d targetCapacity;\n      }\n    }\n    // compute the default queue capacity\n    float defQCap \u003d 1.0f - totalAssignedCapacity;\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"PlanFollowerEditPolicyTask: total Plan Capacity: {} \"\n          + \"currReservation: {} default-queue capacity: {}\", planResources,\n          numRes, defQCap);\n    }\n    // set the default queue to eat-up all remaining capacity\n    try {\n      scheduler.setEntitlement(defReservationQueue, new QueueEntitlement(\n          defQCap, 1.0f));\n    } catch (YarnException e) {\n      LOG.warn(\n          \"Exception while trying to reclaim default queue capacity for plan: {}\",\n          planQueueName, e);\n    }\n    // garbage collect finished reservations from plan\n    try {\n      plan.archiveCompletedReservations(now);\n    } catch (PlanningException e) {\n      LOG.error(\"Exception in archiving completed reservations: \", e);\n    }\n    LOG.info(\"Finished iteration of plan follower edit policy for plan: \"\n        + planQueueName);\n\n    // Extension: update plan with app states,\n    // useful to support smart replanning\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/CapacitySchedulerPlanFollower.java"
    }
  }
}