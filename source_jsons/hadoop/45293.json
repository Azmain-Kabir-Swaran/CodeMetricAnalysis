{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "YarnClientUtils.java",
  "functionName": "buildNodeLabelsFromStr",
  "functionId": "buildNodeLabelsFromStr___args-String",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/util/YarnClientUtils.java",
  "functionStartLine": 117,
  "functionEndLine": 174,
  "numCommitsSeen": 87,
  "timeTaken": 6798,
  "changeHistory": [
    "9fea5c9ee76bd36f273ae93afef5f3ef3c477a53",
    "f5fe35e297ed4a00a1ba93d090207ef67cebcc9d",
    "c65f1b382ec5ec93dccf459dbf8b2c93c3e150ab",
    "82567664988b673f1b819a42a4baf31cb0dcb331"
  ],
  "changeHistoryShort": {
    "9fea5c9ee76bd36f273ae93afef5f3ef3c477a53": "Ymultichange(Ymovefromfile,Ymodifierchange,Ybodychange)",
    "f5fe35e297ed4a00a1ba93d090207ef67cebcc9d": "Ymultichange(Yrename,Yreturntypechange,Ybodychange)",
    "c65f1b382ec5ec93dccf459dbf8b2c93c3e150ab": "Ymultichange(Yrename,Yreturntypechange,Yexceptionschange,Ybodychange)",
    "82567664988b673f1b819a42a4baf31cb0dcb331": "Yintroduced"
  },
  "changeHistoryDetails": {
    "9fea5c9ee76bd36f273ae93afef5f3ef3c477a53": {
      "type": "Ymultichange(Ymovefromfile,Ymodifierchange,Ybodychange)",
      "commitMessage": "YARN-8175. Add support for Node Labels in SLS. Contributed by Abhishek Modi.\n",
      "commitDate": "31/07/18 9:36 AM",
      "commitName": "9fea5c9ee76bd36f273ae93afef5f3ef3c477a53",
      "commitAuthor": "Inigo Goiri",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "YARN-8175. Add support for Node Labels in SLS. Contributed by Abhishek Modi.\n",
          "commitDate": "31/07/18 9:36 AM",
          "commitName": "9fea5c9ee76bd36f273ae93afef5f3ef3c477a53",
          "commitAuthor": "Inigo Goiri",
          "commitDateOld": "31/07/18 7:20 AM",
          "commitNameOld": "b28bdc7e8b488ef0df62a92bcfe7eb74bbe177c1",
          "commitAuthorOld": "Mukul Kumar Singh",
          "daysBetweenCommits": 0.09,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,58 +1,58 @@\n-  private List\u003cNodeLabel\u003e buildNodeLabelsFromStr(String args) {\n+  public static List\u003cNodeLabel\u003e buildNodeLabelsFromStr(String args) {\n     List\u003cNodeLabel\u003e nodeLabels \u003d new ArrayList\u003c\u003e();\n     for (String p : args.split(\",\")) {\n       if (!p.trim().isEmpty()) {\n         String labelName \u003d p;\n \n         // Try to parse exclusive\n         boolean exclusive \u003d NodeLabel.DEFAULT_NODE_LABEL_EXCLUSIVITY;\n         int leftParenthesisIdx \u003d p.indexOf(\"(\");\n         int rightParenthesisIdx \u003d p.indexOf(\")\");\n \n         if ((leftParenthesisIdx \u003d\u003d -1 \u0026\u0026 rightParenthesisIdx !\u003d -1)\n             || (leftParenthesisIdx !\u003d -1 \u0026\u0026 rightParenthesisIdx \u003d\u003d -1)) {\n-          // Parenthese not match\n+          // Parentheses not match\n           throw new IllegalArgumentException(ADD_LABEL_FORMAT_ERR_MSG);\n         }\n \n         if (leftParenthesisIdx \u003e 0 \u0026\u0026 rightParenthesisIdx \u003e 0) {\n           if (leftParenthesisIdx \u003e rightParenthesisIdx) {\n-            // Parentese not match\n+            // Parentheses not match\n             throw new IllegalArgumentException(ADD_LABEL_FORMAT_ERR_MSG);\n           }\n \n           String property \u003d p.substring(p.indexOf(\"(\") + 1, p.indexOf(\")\"));\n           if (property.contains(\"\u003d\")) {\n             String key \u003d property.substring(0, property.indexOf(\"\u003d\")).trim();\n             String value \u003d\n                 property\n                     .substring(property.indexOf(\"\u003d\") + 1, property.length())\n                     .trim();\n \n             // Now we only support one property, which is exclusive, so check if\n             // key \u003d exclusive and value \u003d {true/false}\n             if (key.equals(\"exclusive\")\n                 \u0026\u0026 ImmutableSet.of(\"true\", \"false\").contains(value)) {\n               exclusive \u003d Boolean.parseBoolean(value);\n             } else {\n               throw new IllegalArgumentException(ADD_LABEL_FORMAT_ERR_MSG);\n             }\n           } else if (!property.trim().isEmpty()) {\n             throw new IllegalArgumentException(ADD_LABEL_FORMAT_ERR_MSG);\n           }\n         }\n \n         // Try to get labelName if there\u0027s \"(..)\"\n         if (labelName.contains(\"(\")) {\n           labelName \u003d labelName.substring(0, labelName.indexOf(\"(\")).trim();\n         }\n \n         nodeLabels.add(NodeLabel.newInstance(labelName, exclusive));\n       }\n     }\n \n     if (nodeLabels.isEmpty()) {\n       throw new IllegalArgumentException(NO_LABEL_ERR_MSG);\n     }\n     return nodeLabels;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static List\u003cNodeLabel\u003e buildNodeLabelsFromStr(String args) {\n    List\u003cNodeLabel\u003e nodeLabels \u003d new ArrayList\u003c\u003e();\n    for (String p : args.split(\",\")) {\n      if (!p.trim().isEmpty()) {\n        String labelName \u003d p;\n\n        // Try to parse exclusive\n        boolean exclusive \u003d NodeLabel.DEFAULT_NODE_LABEL_EXCLUSIVITY;\n        int leftParenthesisIdx \u003d p.indexOf(\"(\");\n        int rightParenthesisIdx \u003d p.indexOf(\")\");\n\n        if ((leftParenthesisIdx \u003d\u003d -1 \u0026\u0026 rightParenthesisIdx !\u003d -1)\n            || (leftParenthesisIdx !\u003d -1 \u0026\u0026 rightParenthesisIdx \u003d\u003d -1)) {\n          // Parentheses not match\n          throw new IllegalArgumentException(ADD_LABEL_FORMAT_ERR_MSG);\n        }\n\n        if (leftParenthesisIdx \u003e 0 \u0026\u0026 rightParenthesisIdx \u003e 0) {\n          if (leftParenthesisIdx \u003e rightParenthesisIdx) {\n            // Parentheses not match\n            throw new IllegalArgumentException(ADD_LABEL_FORMAT_ERR_MSG);\n          }\n\n          String property \u003d p.substring(p.indexOf(\"(\") + 1, p.indexOf(\")\"));\n          if (property.contains(\"\u003d\")) {\n            String key \u003d property.substring(0, property.indexOf(\"\u003d\")).trim();\n            String value \u003d\n                property\n                    .substring(property.indexOf(\"\u003d\") + 1, property.length())\n                    .trim();\n\n            // Now we only support one property, which is exclusive, so check if\n            // key \u003d exclusive and value \u003d {true/false}\n            if (key.equals(\"exclusive\")\n                \u0026\u0026 ImmutableSet.of(\"true\", \"false\").contains(value)) {\n              exclusive \u003d Boolean.parseBoolean(value);\n            } else {\n              throw new IllegalArgumentException(ADD_LABEL_FORMAT_ERR_MSG);\n            }\n          } else if (!property.trim().isEmpty()) {\n            throw new IllegalArgumentException(ADD_LABEL_FORMAT_ERR_MSG);\n          }\n        }\n\n        // Try to get labelName if there\u0027s \"(..)\"\n        if (labelName.contains(\"(\")) {\n          labelName \u003d labelName.substring(0, labelName.indexOf(\"(\")).trim();\n        }\n\n        nodeLabels.add(NodeLabel.newInstance(labelName, exclusive));\n      }\n    }\n\n    if (nodeLabels.isEmpty()) {\n      throw new IllegalArgumentException(NO_LABEL_ERR_MSG);\n    }\n    return nodeLabels;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/util/YarnClientUtils.java",
          "extendedDetails": {
            "oldPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/RMAdminCLI.java",
            "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/util/YarnClientUtils.java",
            "oldMethodName": "buildNodeLabelsFromStr",
            "newMethodName": "buildNodeLabelsFromStr"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "YARN-8175. Add support for Node Labels in SLS. Contributed by Abhishek Modi.\n",
          "commitDate": "31/07/18 9:36 AM",
          "commitName": "9fea5c9ee76bd36f273ae93afef5f3ef3c477a53",
          "commitAuthor": "Inigo Goiri",
          "commitDateOld": "31/07/18 7:20 AM",
          "commitNameOld": "b28bdc7e8b488ef0df62a92bcfe7eb74bbe177c1",
          "commitAuthorOld": "Mukul Kumar Singh",
          "daysBetweenCommits": 0.09,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,58 +1,58 @@\n-  private List\u003cNodeLabel\u003e buildNodeLabelsFromStr(String args) {\n+  public static List\u003cNodeLabel\u003e buildNodeLabelsFromStr(String args) {\n     List\u003cNodeLabel\u003e nodeLabels \u003d new ArrayList\u003c\u003e();\n     for (String p : args.split(\",\")) {\n       if (!p.trim().isEmpty()) {\n         String labelName \u003d p;\n \n         // Try to parse exclusive\n         boolean exclusive \u003d NodeLabel.DEFAULT_NODE_LABEL_EXCLUSIVITY;\n         int leftParenthesisIdx \u003d p.indexOf(\"(\");\n         int rightParenthesisIdx \u003d p.indexOf(\")\");\n \n         if ((leftParenthesisIdx \u003d\u003d -1 \u0026\u0026 rightParenthesisIdx !\u003d -1)\n             || (leftParenthesisIdx !\u003d -1 \u0026\u0026 rightParenthesisIdx \u003d\u003d -1)) {\n-          // Parenthese not match\n+          // Parentheses not match\n           throw new IllegalArgumentException(ADD_LABEL_FORMAT_ERR_MSG);\n         }\n \n         if (leftParenthesisIdx \u003e 0 \u0026\u0026 rightParenthesisIdx \u003e 0) {\n           if (leftParenthesisIdx \u003e rightParenthesisIdx) {\n-            // Parentese not match\n+            // Parentheses not match\n             throw new IllegalArgumentException(ADD_LABEL_FORMAT_ERR_MSG);\n           }\n \n           String property \u003d p.substring(p.indexOf(\"(\") + 1, p.indexOf(\")\"));\n           if (property.contains(\"\u003d\")) {\n             String key \u003d property.substring(0, property.indexOf(\"\u003d\")).trim();\n             String value \u003d\n                 property\n                     .substring(property.indexOf(\"\u003d\") + 1, property.length())\n                     .trim();\n \n             // Now we only support one property, which is exclusive, so check if\n             // key \u003d exclusive and value \u003d {true/false}\n             if (key.equals(\"exclusive\")\n                 \u0026\u0026 ImmutableSet.of(\"true\", \"false\").contains(value)) {\n               exclusive \u003d Boolean.parseBoolean(value);\n             } else {\n               throw new IllegalArgumentException(ADD_LABEL_FORMAT_ERR_MSG);\n             }\n           } else if (!property.trim().isEmpty()) {\n             throw new IllegalArgumentException(ADD_LABEL_FORMAT_ERR_MSG);\n           }\n         }\n \n         // Try to get labelName if there\u0027s \"(..)\"\n         if (labelName.contains(\"(\")) {\n           labelName \u003d labelName.substring(0, labelName.indexOf(\"(\")).trim();\n         }\n \n         nodeLabels.add(NodeLabel.newInstance(labelName, exclusive));\n       }\n     }\n \n     if (nodeLabels.isEmpty()) {\n       throw new IllegalArgumentException(NO_LABEL_ERR_MSG);\n     }\n     return nodeLabels;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static List\u003cNodeLabel\u003e buildNodeLabelsFromStr(String args) {\n    List\u003cNodeLabel\u003e nodeLabels \u003d new ArrayList\u003c\u003e();\n    for (String p : args.split(\",\")) {\n      if (!p.trim().isEmpty()) {\n        String labelName \u003d p;\n\n        // Try to parse exclusive\n        boolean exclusive \u003d NodeLabel.DEFAULT_NODE_LABEL_EXCLUSIVITY;\n        int leftParenthesisIdx \u003d p.indexOf(\"(\");\n        int rightParenthesisIdx \u003d p.indexOf(\")\");\n\n        if ((leftParenthesisIdx \u003d\u003d -1 \u0026\u0026 rightParenthesisIdx !\u003d -1)\n            || (leftParenthesisIdx !\u003d -1 \u0026\u0026 rightParenthesisIdx \u003d\u003d -1)) {\n          // Parentheses not match\n          throw new IllegalArgumentException(ADD_LABEL_FORMAT_ERR_MSG);\n        }\n\n        if (leftParenthesisIdx \u003e 0 \u0026\u0026 rightParenthesisIdx \u003e 0) {\n          if (leftParenthesisIdx \u003e rightParenthesisIdx) {\n            // Parentheses not match\n            throw new IllegalArgumentException(ADD_LABEL_FORMAT_ERR_MSG);\n          }\n\n          String property \u003d p.substring(p.indexOf(\"(\") + 1, p.indexOf(\")\"));\n          if (property.contains(\"\u003d\")) {\n            String key \u003d property.substring(0, property.indexOf(\"\u003d\")).trim();\n            String value \u003d\n                property\n                    .substring(property.indexOf(\"\u003d\") + 1, property.length())\n                    .trim();\n\n            // Now we only support one property, which is exclusive, so check if\n            // key \u003d exclusive and value \u003d {true/false}\n            if (key.equals(\"exclusive\")\n                \u0026\u0026 ImmutableSet.of(\"true\", \"false\").contains(value)) {\n              exclusive \u003d Boolean.parseBoolean(value);\n            } else {\n              throw new IllegalArgumentException(ADD_LABEL_FORMAT_ERR_MSG);\n            }\n          } else if (!property.trim().isEmpty()) {\n            throw new IllegalArgumentException(ADD_LABEL_FORMAT_ERR_MSG);\n          }\n        }\n\n        // Try to get labelName if there\u0027s \"(..)\"\n        if (labelName.contains(\"(\")) {\n          labelName \u003d labelName.substring(0, labelName.indexOf(\"(\")).trim();\n        }\n\n        nodeLabels.add(NodeLabel.newInstance(labelName, exclusive));\n      }\n    }\n\n    if (nodeLabels.isEmpty()) {\n      throw new IllegalArgumentException(NO_LABEL_ERR_MSG);\n    }\n    return nodeLabels;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/util/YarnClientUtils.java",
          "extendedDetails": {
            "oldValue": "[private]",
            "newValue": "[public, static]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-8175. Add support for Node Labels in SLS. Contributed by Abhishek Modi.\n",
          "commitDate": "31/07/18 9:36 AM",
          "commitName": "9fea5c9ee76bd36f273ae93afef5f3ef3c477a53",
          "commitAuthor": "Inigo Goiri",
          "commitDateOld": "31/07/18 7:20 AM",
          "commitNameOld": "b28bdc7e8b488ef0df62a92bcfe7eb74bbe177c1",
          "commitAuthorOld": "Mukul Kumar Singh",
          "daysBetweenCommits": 0.09,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,58 +1,58 @@\n-  private List\u003cNodeLabel\u003e buildNodeLabelsFromStr(String args) {\n+  public static List\u003cNodeLabel\u003e buildNodeLabelsFromStr(String args) {\n     List\u003cNodeLabel\u003e nodeLabels \u003d new ArrayList\u003c\u003e();\n     for (String p : args.split(\",\")) {\n       if (!p.trim().isEmpty()) {\n         String labelName \u003d p;\n \n         // Try to parse exclusive\n         boolean exclusive \u003d NodeLabel.DEFAULT_NODE_LABEL_EXCLUSIVITY;\n         int leftParenthesisIdx \u003d p.indexOf(\"(\");\n         int rightParenthesisIdx \u003d p.indexOf(\")\");\n \n         if ((leftParenthesisIdx \u003d\u003d -1 \u0026\u0026 rightParenthesisIdx !\u003d -1)\n             || (leftParenthesisIdx !\u003d -1 \u0026\u0026 rightParenthesisIdx \u003d\u003d -1)) {\n-          // Parenthese not match\n+          // Parentheses not match\n           throw new IllegalArgumentException(ADD_LABEL_FORMAT_ERR_MSG);\n         }\n \n         if (leftParenthesisIdx \u003e 0 \u0026\u0026 rightParenthesisIdx \u003e 0) {\n           if (leftParenthesisIdx \u003e rightParenthesisIdx) {\n-            // Parentese not match\n+            // Parentheses not match\n             throw new IllegalArgumentException(ADD_LABEL_FORMAT_ERR_MSG);\n           }\n \n           String property \u003d p.substring(p.indexOf(\"(\") + 1, p.indexOf(\")\"));\n           if (property.contains(\"\u003d\")) {\n             String key \u003d property.substring(0, property.indexOf(\"\u003d\")).trim();\n             String value \u003d\n                 property\n                     .substring(property.indexOf(\"\u003d\") + 1, property.length())\n                     .trim();\n \n             // Now we only support one property, which is exclusive, so check if\n             // key \u003d exclusive and value \u003d {true/false}\n             if (key.equals(\"exclusive\")\n                 \u0026\u0026 ImmutableSet.of(\"true\", \"false\").contains(value)) {\n               exclusive \u003d Boolean.parseBoolean(value);\n             } else {\n               throw new IllegalArgumentException(ADD_LABEL_FORMAT_ERR_MSG);\n             }\n           } else if (!property.trim().isEmpty()) {\n             throw new IllegalArgumentException(ADD_LABEL_FORMAT_ERR_MSG);\n           }\n         }\n \n         // Try to get labelName if there\u0027s \"(..)\"\n         if (labelName.contains(\"(\")) {\n           labelName \u003d labelName.substring(0, labelName.indexOf(\"(\")).trim();\n         }\n \n         nodeLabels.add(NodeLabel.newInstance(labelName, exclusive));\n       }\n     }\n \n     if (nodeLabels.isEmpty()) {\n       throw new IllegalArgumentException(NO_LABEL_ERR_MSG);\n     }\n     return nodeLabels;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static List\u003cNodeLabel\u003e buildNodeLabelsFromStr(String args) {\n    List\u003cNodeLabel\u003e nodeLabels \u003d new ArrayList\u003c\u003e();\n    for (String p : args.split(\",\")) {\n      if (!p.trim().isEmpty()) {\n        String labelName \u003d p;\n\n        // Try to parse exclusive\n        boolean exclusive \u003d NodeLabel.DEFAULT_NODE_LABEL_EXCLUSIVITY;\n        int leftParenthesisIdx \u003d p.indexOf(\"(\");\n        int rightParenthesisIdx \u003d p.indexOf(\")\");\n\n        if ((leftParenthesisIdx \u003d\u003d -1 \u0026\u0026 rightParenthesisIdx !\u003d -1)\n            || (leftParenthesisIdx !\u003d -1 \u0026\u0026 rightParenthesisIdx \u003d\u003d -1)) {\n          // Parentheses not match\n          throw new IllegalArgumentException(ADD_LABEL_FORMAT_ERR_MSG);\n        }\n\n        if (leftParenthesisIdx \u003e 0 \u0026\u0026 rightParenthesisIdx \u003e 0) {\n          if (leftParenthesisIdx \u003e rightParenthesisIdx) {\n            // Parentheses not match\n            throw new IllegalArgumentException(ADD_LABEL_FORMAT_ERR_MSG);\n          }\n\n          String property \u003d p.substring(p.indexOf(\"(\") + 1, p.indexOf(\")\"));\n          if (property.contains(\"\u003d\")) {\n            String key \u003d property.substring(0, property.indexOf(\"\u003d\")).trim();\n            String value \u003d\n                property\n                    .substring(property.indexOf(\"\u003d\") + 1, property.length())\n                    .trim();\n\n            // Now we only support one property, which is exclusive, so check if\n            // key \u003d exclusive and value \u003d {true/false}\n            if (key.equals(\"exclusive\")\n                \u0026\u0026 ImmutableSet.of(\"true\", \"false\").contains(value)) {\n              exclusive \u003d Boolean.parseBoolean(value);\n            } else {\n              throw new IllegalArgumentException(ADD_LABEL_FORMAT_ERR_MSG);\n            }\n          } else if (!property.trim().isEmpty()) {\n            throw new IllegalArgumentException(ADD_LABEL_FORMAT_ERR_MSG);\n          }\n        }\n\n        // Try to get labelName if there\u0027s \"(..)\"\n        if (labelName.contains(\"(\")) {\n          labelName \u003d labelName.substring(0, labelName.indexOf(\"(\")).trim();\n        }\n\n        nodeLabels.add(NodeLabel.newInstance(labelName, exclusive));\n      }\n    }\n\n    if (nodeLabels.isEmpty()) {\n      throw new IllegalArgumentException(NO_LABEL_ERR_MSG);\n    }\n    return nodeLabels;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/util/YarnClientUtils.java",
          "extendedDetails": {}
        }
      ]
    },
    "f5fe35e297ed4a00a1ba93d090207ef67cebcc9d": {
      "type": "Ymultichange(Yrename,Yreturntypechange,Ybodychange)",
      "commitMessage": "YARN-3413. Changed Nodelabel attributes (like exclusivity) to be settable only via addToClusterNodeLabels but not changeable at runtime. (Wangda Tan via vinodkv)\n",
      "commitDate": "23/04/15 11:19 AM",
      "commitName": "f5fe35e297ed4a00a1ba93d090207ef67cebcc9d",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "YARN-3413. Changed Nodelabel attributes (like exclusivity) to be settable only via addToClusterNodeLabels but not changeable at runtime. (Wangda Tan via vinodkv)\n",
          "commitDate": "23/04/15 11:19 AM",
          "commitName": "f5fe35e297ed4a00a1ba93d090207ef67cebcc9d",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "22/04/15 10:07 AM",
          "commitNameOld": "fad9d7e85b1ba0934ab592daa9d3c9550b2bb501",
          "commitAuthorOld": "Junping Du",
          "daysBetweenCommits": 1.05,
          "commitsBetweenForRepo": 16,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,13 +1,58 @@\n-  private Set\u003cString\u003e buildNodeLabelsSetFromStr(String args) {\n-    Set\u003cString\u003e labels \u003d new HashSet\u003cString\u003e();\n+  private List\u003cNodeLabel\u003e buildNodeLabelsFromStr(String args) {\n+    List\u003cNodeLabel\u003e nodeLabels \u003d new ArrayList\u003c\u003e();\n     for (String p : args.split(\",\")) {\n       if (!p.trim().isEmpty()) {\n-        labels.add(p.trim());\n+        String labelName \u003d p;\n+\n+        // Try to parse exclusive\n+        boolean exclusive \u003d NodeLabel.DEFAULT_NODE_LABEL_EXCLUSIVITY;\n+        int leftParenthesisIdx \u003d p.indexOf(\"(\");\n+        int rightParenthesisIdx \u003d p.indexOf(\")\");\n+\n+        if ((leftParenthesisIdx \u003d\u003d -1 \u0026\u0026 rightParenthesisIdx !\u003d -1)\n+            || (leftParenthesisIdx !\u003d -1 \u0026\u0026 rightParenthesisIdx \u003d\u003d -1)) {\n+          // Parenthese not match\n+          throw new IllegalArgumentException(ADD_LABEL_FORMAT_ERR_MSG);\n+        }\n+\n+        if (leftParenthesisIdx \u003e 0 \u0026\u0026 rightParenthesisIdx \u003e 0) {\n+          if (leftParenthesisIdx \u003e rightParenthesisIdx) {\n+            // Parentese not match\n+            throw new IllegalArgumentException(ADD_LABEL_FORMAT_ERR_MSG);\n+          }\n+\n+          String property \u003d p.substring(p.indexOf(\"(\") + 1, p.indexOf(\")\"));\n+          if (property.contains(\"\u003d\")) {\n+            String key \u003d property.substring(0, property.indexOf(\"\u003d\")).trim();\n+            String value \u003d\n+                property\n+                    .substring(property.indexOf(\"\u003d\") + 1, property.length())\n+                    .trim();\n+\n+            // Now we only support one property, which is exclusive, so check if\n+            // key \u003d exclusive and value \u003d {true/false}\n+            if (key.equals(\"exclusive\")\n+                \u0026\u0026 ImmutableSet.of(\"true\", \"false\").contains(value)) {\n+              exclusive \u003d Boolean.parseBoolean(value);\n+            } else {\n+              throw new IllegalArgumentException(ADD_LABEL_FORMAT_ERR_MSG);\n+            }\n+          } else if (!property.trim().isEmpty()) {\n+            throw new IllegalArgumentException(ADD_LABEL_FORMAT_ERR_MSG);\n+          }\n+        }\n+\n+        // Try to get labelName if there\u0027s \"(..)\"\n+        if (labelName.contains(\"(\")) {\n+          labelName \u003d labelName.substring(0, labelName.indexOf(\"(\")).trim();\n+        }\n+\n+        nodeLabels.add(NodeLabel.newInstance(labelName, exclusive));\n       }\n     }\n \n-    if (labels.isEmpty()) {\n+    if (nodeLabels.isEmpty()) {\n       throw new IllegalArgumentException(NO_LABEL_ERR_MSG);\n     }\n-    return labels;\n+    return nodeLabels;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private List\u003cNodeLabel\u003e buildNodeLabelsFromStr(String args) {\n    List\u003cNodeLabel\u003e nodeLabels \u003d new ArrayList\u003c\u003e();\n    for (String p : args.split(\",\")) {\n      if (!p.trim().isEmpty()) {\n        String labelName \u003d p;\n\n        // Try to parse exclusive\n        boolean exclusive \u003d NodeLabel.DEFAULT_NODE_LABEL_EXCLUSIVITY;\n        int leftParenthesisIdx \u003d p.indexOf(\"(\");\n        int rightParenthesisIdx \u003d p.indexOf(\")\");\n\n        if ((leftParenthesisIdx \u003d\u003d -1 \u0026\u0026 rightParenthesisIdx !\u003d -1)\n            || (leftParenthesisIdx !\u003d -1 \u0026\u0026 rightParenthesisIdx \u003d\u003d -1)) {\n          // Parenthese not match\n          throw new IllegalArgumentException(ADD_LABEL_FORMAT_ERR_MSG);\n        }\n\n        if (leftParenthesisIdx \u003e 0 \u0026\u0026 rightParenthesisIdx \u003e 0) {\n          if (leftParenthesisIdx \u003e rightParenthesisIdx) {\n            // Parentese not match\n            throw new IllegalArgumentException(ADD_LABEL_FORMAT_ERR_MSG);\n          }\n\n          String property \u003d p.substring(p.indexOf(\"(\") + 1, p.indexOf(\")\"));\n          if (property.contains(\"\u003d\")) {\n            String key \u003d property.substring(0, property.indexOf(\"\u003d\")).trim();\n            String value \u003d\n                property\n                    .substring(property.indexOf(\"\u003d\") + 1, property.length())\n                    .trim();\n\n            // Now we only support one property, which is exclusive, so check if\n            // key \u003d exclusive and value \u003d {true/false}\n            if (key.equals(\"exclusive\")\n                \u0026\u0026 ImmutableSet.of(\"true\", \"false\").contains(value)) {\n              exclusive \u003d Boolean.parseBoolean(value);\n            } else {\n              throw new IllegalArgumentException(ADD_LABEL_FORMAT_ERR_MSG);\n            }\n          } else if (!property.trim().isEmpty()) {\n            throw new IllegalArgumentException(ADD_LABEL_FORMAT_ERR_MSG);\n          }\n        }\n\n        // Try to get labelName if there\u0027s \"(..)\"\n        if (labelName.contains(\"(\")) {\n          labelName \u003d labelName.substring(0, labelName.indexOf(\"(\")).trim();\n        }\n\n        nodeLabels.add(NodeLabel.newInstance(labelName, exclusive));\n      }\n    }\n\n    if (nodeLabels.isEmpty()) {\n      throw new IllegalArgumentException(NO_LABEL_ERR_MSG);\n    }\n    return nodeLabels;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/RMAdminCLI.java",
          "extendedDetails": {
            "oldValue": "buildNodeLabelsSetFromStr",
            "newValue": "buildNodeLabelsFromStr"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "YARN-3413. Changed Nodelabel attributes (like exclusivity) to be settable only via addToClusterNodeLabels but not changeable at runtime. (Wangda Tan via vinodkv)\n",
          "commitDate": "23/04/15 11:19 AM",
          "commitName": "f5fe35e297ed4a00a1ba93d090207ef67cebcc9d",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "22/04/15 10:07 AM",
          "commitNameOld": "fad9d7e85b1ba0934ab592daa9d3c9550b2bb501",
          "commitAuthorOld": "Junping Du",
          "daysBetweenCommits": 1.05,
          "commitsBetweenForRepo": 16,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,13 +1,58 @@\n-  private Set\u003cString\u003e buildNodeLabelsSetFromStr(String args) {\n-    Set\u003cString\u003e labels \u003d new HashSet\u003cString\u003e();\n+  private List\u003cNodeLabel\u003e buildNodeLabelsFromStr(String args) {\n+    List\u003cNodeLabel\u003e nodeLabels \u003d new ArrayList\u003c\u003e();\n     for (String p : args.split(\",\")) {\n       if (!p.trim().isEmpty()) {\n-        labels.add(p.trim());\n+        String labelName \u003d p;\n+\n+        // Try to parse exclusive\n+        boolean exclusive \u003d NodeLabel.DEFAULT_NODE_LABEL_EXCLUSIVITY;\n+        int leftParenthesisIdx \u003d p.indexOf(\"(\");\n+        int rightParenthesisIdx \u003d p.indexOf(\")\");\n+\n+        if ((leftParenthesisIdx \u003d\u003d -1 \u0026\u0026 rightParenthesisIdx !\u003d -1)\n+            || (leftParenthesisIdx !\u003d -1 \u0026\u0026 rightParenthesisIdx \u003d\u003d -1)) {\n+          // Parenthese not match\n+          throw new IllegalArgumentException(ADD_LABEL_FORMAT_ERR_MSG);\n+        }\n+\n+        if (leftParenthesisIdx \u003e 0 \u0026\u0026 rightParenthesisIdx \u003e 0) {\n+          if (leftParenthesisIdx \u003e rightParenthesisIdx) {\n+            // Parentese not match\n+            throw new IllegalArgumentException(ADD_LABEL_FORMAT_ERR_MSG);\n+          }\n+\n+          String property \u003d p.substring(p.indexOf(\"(\") + 1, p.indexOf(\")\"));\n+          if (property.contains(\"\u003d\")) {\n+            String key \u003d property.substring(0, property.indexOf(\"\u003d\")).trim();\n+            String value \u003d\n+                property\n+                    .substring(property.indexOf(\"\u003d\") + 1, property.length())\n+                    .trim();\n+\n+            // Now we only support one property, which is exclusive, so check if\n+            // key \u003d exclusive and value \u003d {true/false}\n+            if (key.equals(\"exclusive\")\n+                \u0026\u0026 ImmutableSet.of(\"true\", \"false\").contains(value)) {\n+              exclusive \u003d Boolean.parseBoolean(value);\n+            } else {\n+              throw new IllegalArgumentException(ADD_LABEL_FORMAT_ERR_MSG);\n+            }\n+          } else if (!property.trim().isEmpty()) {\n+            throw new IllegalArgumentException(ADD_LABEL_FORMAT_ERR_MSG);\n+          }\n+        }\n+\n+        // Try to get labelName if there\u0027s \"(..)\"\n+        if (labelName.contains(\"(\")) {\n+          labelName \u003d labelName.substring(0, labelName.indexOf(\"(\")).trim();\n+        }\n+\n+        nodeLabels.add(NodeLabel.newInstance(labelName, exclusive));\n       }\n     }\n \n-    if (labels.isEmpty()) {\n+    if (nodeLabels.isEmpty()) {\n       throw new IllegalArgumentException(NO_LABEL_ERR_MSG);\n     }\n-    return labels;\n+    return nodeLabels;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private List\u003cNodeLabel\u003e buildNodeLabelsFromStr(String args) {\n    List\u003cNodeLabel\u003e nodeLabels \u003d new ArrayList\u003c\u003e();\n    for (String p : args.split(\",\")) {\n      if (!p.trim().isEmpty()) {\n        String labelName \u003d p;\n\n        // Try to parse exclusive\n        boolean exclusive \u003d NodeLabel.DEFAULT_NODE_LABEL_EXCLUSIVITY;\n        int leftParenthesisIdx \u003d p.indexOf(\"(\");\n        int rightParenthesisIdx \u003d p.indexOf(\")\");\n\n        if ((leftParenthesisIdx \u003d\u003d -1 \u0026\u0026 rightParenthesisIdx !\u003d -1)\n            || (leftParenthesisIdx !\u003d -1 \u0026\u0026 rightParenthesisIdx \u003d\u003d -1)) {\n          // Parenthese not match\n          throw new IllegalArgumentException(ADD_LABEL_FORMAT_ERR_MSG);\n        }\n\n        if (leftParenthesisIdx \u003e 0 \u0026\u0026 rightParenthesisIdx \u003e 0) {\n          if (leftParenthesisIdx \u003e rightParenthesisIdx) {\n            // Parentese not match\n            throw new IllegalArgumentException(ADD_LABEL_FORMAT_ERR_MSG);\n          }\n\n          String property \u003d p.substring(p.indexOf(\"(\") + 1, p.indexOf(\")\"));\n          if (property.contains(\"\u003d\")) {\n            String key \u003d property.substring(0, property.indexOf(\"\u003d\")).trim();\n            String value \u003d\n                property\n                    .substring(property.indexOf(\"\u003d\") + 1, property.length())\n                    .trim();\n\n            // Now we only support one property, which is exclusive, so check if\n            // key \u003d exclusive and value \u003d {true/false}\n            if (key.equals(\"exclusive\")\n                \u0026\u0026 ImmutableSet.of(\"true\", \"false\").contains(value)) {\n              exclusive \u003d Boolean.parseBoolean(value);\n            } else {\n              throw new IllegalArgumentException(ADD_LABEL_FORMAT_ERR_MSG);\n            }\n          } else if (!property.trim().isEmpty()) {\n            throw new IllegalArgumentException(ADD_LABEL_FORMAT_ERR_MSG);\n          }\n        }\n\n        // Try to get labelName if there\u0027s \"(..)\"\n        if (labelName.contains(\"(\")) {\n          labelName \u003d labelName.substring(0, labelName.indexOf(\"(\")).trim();\n        }\n\n        nodeLabels.add(NodeLabel.newInstance(labelName, exclusive));\n      }\n    }\n\n    if (nodeLabels.isEmpty()) {\n      throw new IllegalArgumentException(NO_LABEL_ERR_MSG);\n    }\n    return nodeLabels;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/RMAdminCLI.java",
          "extendedDetails": {
            "oldValue": "Set\u003cString\u003e",
            "newValue": "List\u003cNodeLabel\u003e"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-3413. Changed Nodelabel attributes (like exclusivity) to be settable only via addToClusterNodeLabels but not changeable at runtime. (Wangda Tan via vinodkv)\n",
          "commitDate": "23/04/15 11:19 AM",
          "commitName": "f5fe35e297ed4a00a1ba93d090207ef67cebcc9d",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "22/04/15 10:07 AM",
          "commitNameOld": "fad9d7e85b1ba0934ab592daa9d3c9550b2bb501",
          "commitAuthorOld": "Junping Du",
          "daysBetweenCommits": 1.05,
          "commitsBetweenForRepo": 16,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,13 +1,58 @@\n-  private Set\u003cString\u003e buildNodeLabelsSetFromStr(String args) {\n-    Set\u003cString\u003e labels \u003d new HashSet\u003cString\u003e();\n+  private List\u003cNodeLabel\u003e buildNodeLabelsFromStr(String args) {\n+    List\u003cNodeLabel\u003e nodeLabels \u003d new ArrayList\u003c\u003e();\n     for (String p : args.split(\",\")) {\n       if (!p.trim().isEmpty()) {\n-        labels.add(p.trim());\n+        String labelName \u003d p;\n+\n+        // Try to parse exclusive\n+        boolean exclusive \u003d NodeLabel.DEFAULT_NODE_LABEL_EXCLUSIVITY;\n+        int leftParenthesisIdx \u003d p.indexOf(\"(\");\n+        int rightParenthesisIdx \u003d p.indexOf(\")\");\n+\n+        if ((leftParenthesisIdx \u003d\u003d -1 \u0026\u0026 rightParenthesisIdx !\u003d -1)\n+            || (leftParenthesisIdx !\u003d -1 \u0026\u0026 rightParenthesisIdx \u003d\u003d -1)) {\n+          // Parenthese not match\n+          throw new IllegalArgumentException(ADD_LABEL_FORMAT_ERR_MSG);\n+        }\n+\n+        if (leftParenthesisIdx \u003e 0 \u0026\u0026 rightParenthesisIdx \u003e 0) {\n+          if (leftParenthesisIdx \u003e rightParenthesisIdx) {\n+            // Parentese not match\n+            throw new IllegalArgumentException(ADD_LABEL_FORMAT_ERR_MSG);\n+          }\n+\n+          String property \u003d p.substring(p.indexOf(\"(\") + 1, p.indexOf(\")\"));\n+          if (property.contains(\"\u003d\")) {\n+            String key \u003d property.substring(0, property.indexOf(\"\u003d\")).trim();\n+            String value \u003d\n+                property\n+                    .substring(property.indexOf(\"\u003d\") + 1, property.length())\n+                    .trim();\n+\n+            // Now we only support one property, which is exclusive, so check if\n+            // key \u003d exclusive and value \u003d {true/false}\n+            if (key.equals(\"exclusive\")\n+                \u0026\u0026 ImmutableSet.of(\"true\", \"false\").contains(value)) {\n+              exclusive \u003d Boolean.parseBoolean(value);\n+            } else {\n+              throw new IllegalArgumentException(ADD_LABEL_FORMAT_ERR_MSG);\n+            }\n+          } else if (!property.trim().isEmpty()) {\n+            throw new IllegalArgumentException(ADD_LABEL_FORMAT_ERR_MSG);\n+          }\n+        }\n+\n+        // Try to get labelName if there\u0027s \"(..)\"\n+        if (labelName.contains(\"(\")) {\n+          labelName \u003d labelName.substring(0, labelName.indexOf(\"(\")).trim();\n+        }\n+\n+        nodeLabels.add(NodeLabel.newInstance(labelName, exclusive));\n       }\n     }\n \n-    if (labels.isEmpty()) {\n+    if (nodeLabels.isEmpty()) {\n       throw new IllegalArgumentException(NO_LABEL_ERR_MSG);\n     }\n-    return labels;\n+    return nodeLabels;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private List\u003cNodeLabel\u003e buildNodeLabelsFromStr(String args) {\n    List\u003cNodeLabel\u003e nodeLabels \u003d new ArrayList\u003c\u003e();\n    for (String p : args.split(\",\")) {\n      if (!p.trim().isEmpty()) {\n        String labelName \u003d p;\n\n        // Try to parse exclusive\n        boolean exclusive \u003d NodeLabel.DEFAULT_NODE_LABEL_EXCLUSIVITY;\n        int leftParenthesisIdx \u003d p.indexOf(\"(\");\n        int rightParenthesisIdx \u003d p.indexOf(\")\");\n\n        if ((leftParenthesisIdx \u003d\u003d -1 \u0026\u0026 rightParenthesisIdx !\u003d -1)\n            || (leftParenthesisIdx !\u003d -1 \u0026\u0026 rightParenthesisIdx \u003d\u003d -1)) {\n          // Parenthese not match\n          throw new IllegalArgumentException(ADD_LABEL_FORMAT_ERR_MSG);\n        }\n\n        if (leftParenthesisIdx \u003e 0 \u0026\u0026 rightParenthesisIdx \u003e 0) {\n          if (leftParenthesisIdx \u003e rightParenthesisIdx) {\n            // Parentese not match\n            throw new IllegalArgumentException(ADD_LABEL_FORMAT_ERR_MSG);\n          }\n\n          String property \u003d p.substring(p.indexOf(\"(\") + 1, p.indexOf(\")\"));\n          if (property.contains(\"\u003d\")) {\n            String key \u003d property.substring(0, property.indexOf(\"\u003d\")).trim();\n            String value \u003d\n                property\n                    .substring(property.indexOf(\"\u003d\") + 1, property.length())\n                    .trim();\n\n            // Now we only support one property, which is exclusive, so check if\n            // key \u003d exclusive and value \u003d {true/false}\n            if (key.equals(\"exclusive\")\n                \u0026\u0026 ImmutableSet.of(\"true\", \"false\").contains(value)) {\n              exclusive \u003d Boolean.parseBoolean(value);\n            } else {\n              throw new IllegalArgumentException(ADD_LABEL_FORMAT_ERR_MSG);\n            }\n          } else if (!property.trim().isEmpty()) {\n            throw new IllegalArgumentException(ADD_LABEL_FORMAT_ERR_MSG);\n          }\n        }\n\n        // Try to get labelName if there\u0027s \"(..)\"\n        if (labelName.contains(\"(\")) {\n          labelName \u003d labelName.substring(0, labelName.indexOf(\"(\")).trim();\n        }\n\n        nodeLabels.add(NodeLabel.newInstance(labelName, exclusive));\n      }\n    }\n\n    if (nodeLabels.isEmpty()) {\n      throw new IllegalArgumentException(NO_LABEL_ERR_MSG);\n    }\n    return nodeLabels;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/RMAdminCLI.java",
          "extendedDetails": {}
        }
      ]
    },
    "c65f1b382ec5ec93dccf459dbf8b2c93c3e150ab": {
      "type": "Ymultichange(Yrename,Yreturntypechange,Yexceptionschange,Ybodychange)",
      "commitMessage": "YARN-2762. Fixed RMAdminCLI to trim and check node-label related arguments before sending to RM. Contributed by Rohith Sharmaks\n",
      "commitDate": "16/12/14 11:00 AM",
      "commitName": "c65f1b382ec5ec93dccf459dbf8b2c93c3e150ab",
      "commitAuthor": "Jian He",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "YARN-2762. Fixed RMAdminCLI to trim and check node-label related arguments before sending to RM. Contributed by Rohith Sharmaks\n",
          "commitDate": "16/12/14 11:00 AM",
          "commitName": "c65f1b382ec5ec93dccf459dbf8b2c93c3e150ab",
          "commitAuthor": "Jian He",
          "commitDateOld": "09/12/14 5:56 PM",
          "commitNameOld": "437322afcaa4b1b260501af160283c97eb589419",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 6.71,
          "commitsBetweenForRepo": 48,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,9 +1,13 @@\n-  private int addToClusterNodeLabels(String args) throws IOException,\n-      YarnException {\n+  private Set\u003cString\u003e buildNodeLabelsSetFromStr(String args) {\n     Set\u003cString\u003e labels \u003d new HashSet\u003cString\u003e();\n     for (String p : args.split(\",\")) {\n-      labels.add(p);\n+      if (!p.trim().isEmpty()) {\n+        labels.add(p.trim());\n+      }\n     }\n \n-    return addToClusterNodeLabels(labels);\n+    if (labels.isEmpty()) {\n+      throw new IllegalArgumentException(NO_LABEL_ERR_MSG);\n+    }\n+    return labels;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private Set\u003cString\u003e buildNodeLabelsSetFromStr(String args) {\n    Set\u003cString\u003e labels \u003d new HashSet\u003cString\u003e();\n    for (String p : args.split(\",\")) {\n      if (!p.trim().isEmpty()) {\n        labels.add(p.trim());\n      }\n    }\n\n    if (labels.isEmpty()) {\n      throw new IllegalArgumentException(NO_LABEL_ERR_MSG);\n    }\n    return labels;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/RMAdminCLI.java",
          "extendedDetails": {
            "oldValue": "addToClusterNodeLabels",
            "newValue": "buildNodeLabelsSetFromStr"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "YARN-2762. Fixed RMAdminCLI to trim and check node-label related arguments before sending to RM. Contributed by Rohith Sharmaks\n",
          "commitDate": "16/12/14 11:00 AM",
          "commitName": "c65f1b382ec5ec93dccf459dbf8b2c93c3e150ab",
          "commitAuthor": "Jian He",
          "commitDateOld": "09/12/14 5:56 PM",
          "commitNameOld": "437322afcaa4b1b260501af160283c97eb589419",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 6.71,
          "commitsBetweenForRepo": 48,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,9 +1,13 @@\n-  private int addToClusterNodeLabels(String args) throws IOException,\n-      YarnException {\n+  private Set\u003cString\u003e buildNodeLabelsSetFromStr(String args) {\n     Set\u003cString\u003e labels \u003d new HashSet\u003cString\u003e();\n     for (String p : args.split(\",\")) {\n-      labels.add(p);\n+      if (!p.trim().isEmpty()) {\n+        labels.add(p.trim());\n+      }\n     }\n \n-    return addToClusterNodeLabels(labels);\n+    if (labels.isEmpty()) {\n+      throw new IllegalArgumentException(NO_LABEL_ERR_MSG);\n+    }\n+    return labels;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private Set\u003cString\u003e buildNodeLabelsSetFromStr(String args) {\n    Set\u003cString\u003e labels \u003d new HashSet\u003cString\u003e();\n    for (String p : args.split(\",\")) {\n      if (!p.trim().isEmpty()) {\n        labels.add(p.trim());\n      }\n    }\n\n    if (labels.isEmpty()) {\n      throw new IllegalArgumentException(NO_LABEL_ERR_MSG);\n    }\n    return labels;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/RMAdminCLI.java",
          "extendedDetails": {
            "oldValue": "int",
            "newValue": "Set\u003cString\u003e"
          }
        },
        {
          "type": "Yexceptionschange",
          "commitMessage": "YARN-2762. Fixed RMAdminCLI to trim and check node-label related arguments before sending to RM. Contributed by Rohith Sharmaks\n",
          "commitDate": "16/12/14 11:00 AM",
          "commitName": "c65f1b382ec5ec93dccf459dbf8b2c93c3e150ab",
          "commitAuthor": "Jian He",
          "commitDateOld": "09/12/14 5:56 PM",
          "commitNameOld": "437322afcaa4b1b260501af160283c97eb589419",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 6.71,
          "commitsBetweenForRepo": 48,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,9 +1,13 @@\n-  private int addToClusterNodeLabels(String args) throws IOException,\n-      YarnException {\n+  private Set\u003cString\u003e buildNodeLabelsSetFromStr(String args) {\n     Set\u003cString\u003e labels \u003d new HashSet\u003cString\u003e();\n     for (String p : args.split(\",\")) {\n-      labels.add(p);\n+      if (!p.trim().isEmpty()) {\n+        labels.add(p.trim());\n+      }\n     }\n \n-    return addToClusterNodeLabels(labels);\n+    if (labels.isEmpty()) {\n+      throw new IllegalArgumentException(NO_LABEL_ERR_MSG);\n+    }\n+    return labels;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private Set\u003cString\u003e buildNodeLabelsSetFromStr(String args) {\n    Set\u003cString\u003e labels \u003d new HashSet\u003cString\u003e();\n    for (String p : args.split(\",\")) {\n      if (!p.trim().isEmpty()) {\n        labels.add(p.trim());\n      }\n    }\n\n    if (labels.isEmpty()) {\n      throw new IllegalArgumentException(NO_LABEL_ERR_MSG);\n    }\n    return labels;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/RMAdminCLI.java",
          "extendedDetails": {
            "oldValue": "[IOException, YarnException]",
            "newValue": "[]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-2762. Fixed RMAdminCLI to trim and check node-label related arguments before sending to RM. Contributed by Rohith Sharmaks\n",
          "commitDate": "16/12/14 11:00 AM",
          "commitName": "c65f1b382ec5ec93dccf459dbf8b2c93c3e150ab",
          "commitAuthor": "Jian He",
          "commitDateOld": "09/12/14 5:56 PM",
          "commitNameOld": "437322afcaa4b1b260501af160283c97eb589419",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 6.71,
          "commitsBetweenForRepo": 48,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,9 +1,13 @@\n-  private int addToClusterNodeLabels(String args) throws IOException,\n-      YarnException {\n+  private Set\u003cString\u003e buildNodeLabelsSetFromStr(String args) {\n     Set\u003cString\u003e labels \u003d new HashSet\u003cString\u003e();\n     for (String p : args.split(\",\")) {\n-      labels.add(p);\n+      if (!p.trim().isEmpty()) {\n+        labels.add(p.trim());\n+      }\n     }\n \n-    return addToClusterNodeLabels(labels);\n+    if (labels.isEmpty()) {\n+      throw new IllegalArgumentException(NO_LABEL_ERR_MSG);\n+    }\n+    return labels;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private Set\u003cString\u003e buildNodeLabelsSetFromStr(String args) {\n    Set\u003cString\u003e labels \u003d new HashSet\u003cString\u003e();\n    for (String p : args.split(\",\")) {\n      if (!p.trim().isEmpty()) {\n        labels.add(p.trim());\n      }\n    }\n\n    if (labels.isEmpty()) {\n      throw new IllegalArgumentException(NO_LABEL_ERR_MSG);\n    }\n    return labels;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/RMAdminCLI.java",
          "extendedDetails": {}
        }
      ]
    },
    "82567664988b673f1b819a42a4baf31cb0dcb331": {
      "type": "Yintroduced",
      "commitMessage": "YARN-2504. Enhanced RM Admin CLI to support management of node-labels. Contribyted by Wangda Tan.\n",
      "commitDate": "18/10/14 12:07 PM",
      "commitName": "82567664988b673f1b819a42a4baf31cb0dcb331",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,9 @@\n+  private int addToClusterNodeLabels(String args) throws IOException,\n+      YarnException {\n+    Set\u003cString\u003e labels \u003d new HashSet\u003cString\u003e();\n+    for (String p : args.split(\",\")) {\n+      labels.add(p);\n+    }\n+\n+    return addToClusterNodeLabels(labels);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private int addToClusterNodeLabels(String args) throws IOException,\n      YarnException {\n    Set\u003cString\u003e labels \u003d new HashSet\u003cString\u003e();\n    for (String p : args.split(\",\")) {\n      labels.add(p);\n    }\n\n    return addToClusterNodeLabels(labels);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/RMAdminCLI.java"
    }
  }
}