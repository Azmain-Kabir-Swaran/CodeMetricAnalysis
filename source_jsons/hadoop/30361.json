{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ApplicationHistoryManagerOnTimelineStore.java",
  "functionName": "convertToContainerReport",
  "functionId": "convertToContainerReport___entity-TimelineEntity__serverHttpAddress-String__user-String",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/applicationhistoryservice/ApplicationHistoryManagerOnTimelineStore.java",
  "functionStartLine": 565,
  "functionEndLine": 678,
  "numCommitsSeen": 42,
  "timeTaken": 3232,
  "changeHistory": [
    "f82922dcfae0b7e3e68ce970c441d8b7edc59acf",
    "1f304b0c7f261369dd68839507bb609a949965ad",
    "c77a1095dc556e8bea87df6d8ddf36e898f27e86",
    "b2ed6ae73197990a950ce71ece80c0f23221c384",
    "85f6d67fa78511f255fcfa810afc9a156a7b483b",
    "6b8b1608e64e300e4e1d23c60476febaca29ca38"
  ],
  "changeHistoryShort": {
    "f82922dcfae0b7e3e68ce970c441d8b7edc59acf": "Ybodychange",
    "1f304b0c7f261369dd68839507bb609a949965ad": "Ybodychange",
    "c77a1095dc556e8bea87df6d8ddf36e898f27e86": "Ybodychange",
    "b2ed6ae73197990a950ce71ece80c0f23221c384": "Ybodychange",
    "85f6d67fa78511f255fcfa810afc9a156a7b483b": "Ybodychange",
    "6b8b1608e64e300e4e1d23c60476febaca29ca38": "Yintroduced"
  },
  "changeHistoryDetails": {
    "f82922dcfae0b7e3e68ce970c441d8b7edc59acf": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5168. Added exposed port information for Docker container.\n           Contributed by Xun Liu\n",
      "commitDate": "21/12/18 4:44 PM",
      "commitName": "f82922dcfae0b7e3e68ce970c441d8b7edc59acf",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "12/09/17 9:19 AM",
      "commitNameOld": "dae65f3bef8ffa34d02a37041f1dfdfeeee91845",
      "commitAuthorOld": "Sunil G",
      "daysBetweenCommits": 465.35,
      "commitsBetweenForRepo": 4100,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,103 +1,114 @@\n   private static ContainerReport convertToContainerReport(\n       TimelineEntity entity, String serverHttpAddress, String user) {\n     int allocatedMem \u003d 0;\n     int allocatedVcore \u003d 0;\n     String allocatedHost \u003d null;\n     int allocatedPort \u003d -1;\n     int allocatedPriority \u003d 0;\n     long createdTime \u003d 0;\n     long finishedTime \u003d 0;\n     String diagnosticsInfo \u003d null;\n     int exitStatus \u003d ContainerExitStatus.INVALID;\n     ContainerState state \u003d null;\n     String nodeHttpAddress \u003d null;\n+    Map\u003cString, List\u003cMap\u003cString, String\u003e\u003e\u003e exposedPorts \u003d null;\n+\n     Map\u003cString, Object\u003e entityInfo \u003d entity.getOtherInfo();\n     if (entityInfo !\u003d null) {\n       if (entityInfo\n           .containsKey(ContainerMetricsConstants.ALLOCATED_MEMORY_INFO)) {\n         allocatedMem \u003d (Integer) entityInfo.get(\n                 ContainerMetricsConstants.ALLOCATED_MEMORY_INFO);\n       }\n       if (entityInfo\n           .containsKey(ContainerMetricsConstants.ALLOCATED_VCORE_INFO)) {\n         allocatedVcore \u003d (Integer) entityInfo.get(\n                 ContainerMetricsConstants.ALLOCATED_VCORE_INFO);\n       }\n       if (entityInfo\n           .containsKey(ContainerMetricsConstants.ALLOCATED_HOST_INFO)) {\n         allocatedHost \u003d\n             entityInfo\n                 .get(ContainerMetricsConstants.ALLOCATED_HOST_INFO)\n                 .toString();\n       }\n       if (entityInfo\n           .containsKey(ContainerMetricsConstants.ALLOCATED_PORT_INFO)) {\n         allocatedPort \u003d (Integer) entityInfo.get(\n                 ContainerMetricsConstants.ALLOCATED_PORT_INFO);\n       }\n       if (entityInfo\n           .containsKey(ContainerMetricsConstants.ALLOCATED_PRIORITY_INFO)) {\n         allocatedPriority \u003d (Integer) entityInfo.get(\n                 ContainerMetricsConstants.ALLOCATED_PRIORITY_INFO);\n       }\n       if (entityInfo.containsKey(\n           ContainerMetricsConstants.ALLOCATED_HOST_HTTP_ADDRESS_INFO)) {\n         nodeHttpAddress \u003d\n             (String) entityInfo\n               .get(ContainerMetricsConstants.ALLOCATED_HOST_HTTP_ADDRESS_INFO);\n       }\n+      if (entityInfo.containsKey(\n+          ContainerMetricsConstants.ALLOCATED_EXPOSED_PORTS)) {\n+        exposedPorts \u003d\n+            (Map\u003cString, List\u003cMap\u003cString, String\u003e\u003e\u003e) entityInfo\n+                .get(ContainerMetricsConstants.ALLOCATED_EXPOSED_PORTS);\n+      }\n     }\n     List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n     if (events !\u003d null) {\n       for (TimelineEvent event : events) {\n         if (event.getEventType().equals(\n             ContainerMetricsConstants.CREATED_EVENT_TYPE)) {\n           createdTime \u003d event.getTimestamp();\n         } else if (event.getEventType().equals(\n             ContainerMetricsConstants.FINISHED_EVENT_TYPE)) {\n           finishedTime \u003d event.getTimestamp();\n           Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n           if (eventInfo \u003d\u003d null) {\n             continue;\n           }\n           if (eventInfo\n               .containsKey(ContainerMetricsConstants.DIAGNOSTICS_INFO)) {\n             diagnosticsInfo \u003d\n                 eventInfo.get(\n                     ContainerMetricsConstants.DIAGNOSTICS_INFO)\n                     .toString();\n           }\n           if (eventInfo\n               .containsKey(ContainerMetricsConstants.EXIT_STATUS_INFO)) {\n             exitStatus \u003d (Integer) eventInfo.get(\n                     ContainerMetricsConstants.EXIT_STATUS_INFO);\n           }\n           if (eventInfo\n               .containsKey(ContainerMetricsConstants.STATE_INFO)) {\n             state \u003d\n                 ContainerState.valueOf(eventInfo.get(\n                     ContainerMetricsConstants.STATE_INFO).toString());\n           }\n         }\n       }\n     }\n     ContainerId containerId \u003d\n         ContainerId.fromString(entity.getEntityId());\n     String logUrl \u003d null;\n     NodeId allocatedNode \u003d null;\n     if (allocatedHost !\u003d null) {\n       allocatedNode \u003d NodeId.newInstance(allocatedHost, allocatedPort);\n       logUrl \u003d WebAppUtils.getAggregatedLogURL(\n           serverHttpAddress,\n           allocatedNode.toString(),\n           containerId.toString(),\n           containerId.toString(),\n           user);\n     }\n-    return ContainerReport.newInstance(\n+    ContainerReport container \u003d ContainerReport.newInstance(\n         ContainerId.fromString(entity.getEntityId()),\n         Resource.newInstance(allocatedMem, allocatedVcore), allocatedNode,\n         Priority.newInstance(allocatedPriority),\n         createdTime, finishedTime, diagnosticsInfo, logUrl, exitStatus, state,\n         nodeHttpAddress);\n+    container.setExposedPorts(exposedPorts);\n+\n+    return container;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static ContainerReport convertToContainerReport(\n      TimelineEntity entity, String serverHttpAddress, String user) {\n    int allocatedMem \u003d 0;\n    int allocatedVcore \u003d 0;\n    String allocatedHost \u003d null;\n    int allocatedPort \u003d -1;\n    int allocatedPriority \u003d 0;\n    long createdTime \u003d 0;\n    long finishedTime \u003d 0;\n    String diagnosticsInfo \u003d null;\n    int exitStatus \u003d ContainerExitStatus.INVALID;\n    ContainerState state \u003d null;\n    String nodeHttpAddress \u003d null;\n    Map\u003cString, List\u003cMap\u003cString, String\u003e\u003e\u003e exposedPorts \u003d null;\n\n    Map\u003cString, Object\u003e entityInfo \u003d entity.getOtherInfo();\n    if (entityInfo !\u003d null) {\n      if (entityInfo\n          .containsKey(ContainerMetricsConstants.ALLOCATED_MEMORY_INFO)) {\n        allocatedMem \u003d (Integer) entityInfo.get(\n                ContainerMetricsConstants.ALLOCATED_MEMORY_INFO);\n      }\n      if (entityInfo\n          .containsKey(ContainerMetricsConstants.ALLOCATED_VCORE_INFO)) {\n        allocatedVcore \u003d (Integer) entityInfo.get(\n                ContainerMetricsConstants.ALLOCATED_VCORE_INFO);\n      }\n      if (entityInfo\n          .containsKey(ContainerMetricsConstants.ALLOCATED_HOST_INFO)) {\n        allocatedHost \u003d\n            entityInfo\n                .get(ContainerMetricsConstants.ALLOCATED_HOST_INFO)\n                .toString();\n      }\n      if (entityInfo\n          .containsKey(ContainerMetricsConstants.ALLOCATED_PORT_INFO)) {\n        allocatedPort \u003d (Integer) entityInfo.get(\n                ContainerMetricsConstants.ALLOCATED_PORT_INFO);\n      }\n      if (entityInfo\n          .containsKey(ContainerMetricsConstants.ALLOCATED_PRIORITY_INFO)) {\n        allocatedPriority \u003d (Integer) entityInfo.get(\n                ContainerMetricsConstants.ALLOCATED_PRIORITY_INFO);\n      }\n      if (entityInfo.containsKey(\n          ContainerMetricsConstants.ALLOCATED_HOST_HTTP_ADDRESS_INFO)) {\n        nodeHttpAddress \u003d\n            (String) entityInfo\n              .get(ContainerMetricsConstants.ALLOCATED_HOST_HTTP_ADDRESS_INFO);\n      }\n      if (entityInfo.containsKey(\n          ContainerMetricsConstants.ALLOCATED_EXPOSED_PORTS)) {\n        exposedPorts \u003d\n            (Map\u003cString, List\u003cMap\u003cString, String\u003e\u003e\u003e) entityInfo\n                .get(ContainerMetricsConstants.ALLOCATED_EXPOSED_PORTS);\n      }\n    }\n    List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n    if (events !\u003d null) {\n      for (TimelineEvent event : events) {\n        if (event.getEventType().equals(\n            ContainerMetricsConstants.CREATED_EVENT_TYPE)) {\n          createdTime \u003d event.getTimestamp();\n        } else if (event.getEventType().equals(\n            ContainerMetricsConstants.FINISHED_EVENT_TYPE)) {\n          finishedTime \u003d event.getTimestamp();\n          Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n          if (eventInfo \u003d\u003d null) {\n            continue;\n          }\n          if (eventInfo\n              .containsKey(ContainerMetricsConstants.DIAGNOSTICS_INFO)) {\n            diagnosticsInfo \u003d\n                eventInfo.get(\n                    ContainerMetricsConstants.DIAGNOSTICS_INFO)\n                    .toString();\n          }\n          if (eventInfo\n              .containsKey(ContainerMetricsConstants.EXIT_STATUS_INFO)) {\n            exitStatus \u003d (Integer) eventInfo.get(\n                    ContainerMetricsConstants.EXIT_STATUS_INFO);\n          }\n          if (eventInfo\n              .containsKey(ContainerMetricsConstants.STATE_INFO)) {\n            state \u003d\n                ContainerState.valueOf(eventInfo.get(\n                    ContainerMetricsConstants.STATE_INFO).toString());\n          }\n        }\n      }\n    }\n    ContainerId containerId \u003d\n        ContainerId.fromString(entity.getEntityId());\n    String logUrl \u003d null;\n    NodeId allocatedNode \u003d null;\n    if (allocatedHost !\u003d null) {\n      allocatedNode \u003d NodeId.newInstance(allocatedHost, allocatedPort);\n      logUrl \u003d WebAppUtils.getAggregatedLogURL(\n          serverHttpAddress,\n          allocatedNode.toString(),\n          containerId.toString(),\n          containerId.toString(),\n          user);\n    }\n    ContainerReport container \u003d ContainerReport.newInstance(\n        ContainerId.fromString(entity.getEntityId()),\n        Resource.newInstance(allocatedMem, allocatedVcore), allocatedNode,\n        Priority.newInstance(allocatedPriority),\n        createdTime, finishedTime, diagnosticsInfo, logUrl, exitStatus, state,\n        nodeHttpAddress);\n    container.setExposedPorts(exposedPorts);\n\n    return container;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/applicationhistoryservice/ApplicationHistoryManagerOnTimelineStore.java",
      "extendedDetails": {}
    },
    "1f304b0c7f261369dd68839507bb609a949965ad": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5699. Retrospect yarn entity fields which are publishing in events info fields. Contributed by Rohith Sharma K S.\n",
      "commitDate": "15/10/16 1:54 PM",
      "commitName": "1f304b0c7f261369dd68839507bb609a949965ad",
      "commitAuthor": "Sangjin Lee",
      "commitDateOld": "06/10/16 8:12 AM",
      "commitNameOld": "4d2f380d787a6145f45c87ba663079fedbf645b8",
      "commitAuthorOld": "Rohith Sharma K S",
      "daysBetweenCommits": 9.24,
      "commitsBetweenForRepo": 73,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,103 +1,103 @@\n   private static ContainerReport convertToContainerReport(\n       TimelineEntity entity, String serverHttpAddress, String user) {\n     int allocatedMem \u003d 0;\n     int allocatedVcore \u003d 0;\n     String allocatedHost \u003d null;\n     int allocatedPort \u003d -1;\n     int allocatedPriority \u003d 0;\n     long createdTime \u003d 0;\n     long finishedTime \u003d 0;\n     String diagnosticsInfo \u003d null;\n     int exitStatus \u003d ContainerExitStatus.INVALID;\n     ContainerState state \u003d null;\n     String nodeHttpAddress \u003d null;\n     Map\u003cString, Object\u003e entityInfo \u003d entity.getOtherInfo();\n     if (entityInfo !\u003d null) {\n       if (entityInfo\n-          .containsKey(ContainerMetricsConstants.ALLOCATED_MEMORY_ENTITY_INFO)) {\n+          .containsKey(ContainerMetricsConstants.ALLOCATED_MEMORY_INFO)) {\n         allocatedMem \u003d (Integer) entityInfo.get(\n-                ContainerMetricsConstants.ALLOCATED_MEMORY_ENTITY_INFO);\n+                ContainerMetricsConstants.ALLOCATED_MEMORY_INFO);\n       }\n       if (entityInfo\n-          .containsKey(ContainerMetricsConstants.ALLOCATED_VCORE_ENTITY_INFO)) {\n+          .containsKey(ContainerMetricsConstants.ALLOCATED_VCORE_INFO)) {\n         allocatedVcore \u003d (Integer) entityInfo.get(\n-                ContainerMetricsConstants.ALLOCATED_VCORE_ENTITY_INFO);\n+                ContainerMetricsConstants.ALLOCATED_VCORE_INFO);\n       }\n       if (entityInfo\n-          .containsKey(ContainerMetricsConstants.ALLOCATED_HOST_ENTITY_INFO)) {\n+          .containsKey(ContainerMetricsConstants.ALLOCATED_HOST_INFO)) {\n         allocatedHost \u003d\n             entityInfo\n-                .get(ContainerMetricsConstants.ALLOCATED_HOST_ENTITY_INFO)\n+                .get(ContainerMetricsConstants.ALLOCATED_HOST_INFO)\n                 .toString();\n       }\n       if (entityInfo\n-          .containsKey(ContainerMetricsConstants.ALLOCATED_PORT_ENTITY_INFO)) {\n+          .containsKey(ContainerMetricsConstants.ALLOCATED_PORT_INFO)) {\n         allocatedPort \u003d (Integer) entityInfo.get(\n-                ContainerMetricsConstants.ALLOCATED_PORT_ENTITY_INFO);\n+                ContainerMetricsConstants.ALLOCATED_PORT_INFO);\n       }\n       if (entityInfo\n-          .containsKey(ContainerMetricsConstants.ALLOCATED_PRIORITY_ENTITY_INFO)) {\n+          .containsKey(ContainerMetricsConstants.ALLOCATED_PRIORITY_INFO)) {\n         allocatedPriority \u003d (Integer) entityInfo.get(\n-                ContainerMetricsConstants.ALLOCATED_PRIORITY_ENTITY_INFO);\n+                ContainerMetricsConstants.ALLOCATED_PRIORITY_INFO);\n       }\n       if (entityInfo.containsKey(\n-          ContainerMetricsConstants.ALLOCATED_HOST_HTTP_ADDRESS_ENTITY_INFO)) {\n+          ContainerMetricsConstants.ALLOCATED_HOST_HTTP_ADDRESS_INFO)) {\n         nodeHttpAddress \u003d\n             (String) entityInfo\n-              .get(ContainerMetricsConstants.ALLOCATED_HOST_HTTP_ADDRESS_ENTITY_INFO);\n+              .get(ContainerMetricsConstants.ALLOCATED_HOST_HTTP_ADDRESS_INFO);\n       }\n     }\n     List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n     if (events !\u003d null) {\n       for (TimelineEvent event : events) {\n         if (event.getEventType().equals(\n             ContainerMetricsConstants.CREATED_EVENT_TYPE)) {\n           createdTime \u003d event.getTimestamp();\n         } else if (event.getEventType().equals(\n             ContainerMetricsConstants.FINISHED_EVENT_TYPE)) {\n           finishedTime \u003d event.getTimestamp();\n           Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n           if (eventInfo \u003d\u003d null) {\n             continue;\n           }\n           if (eventInfo\n-              .containsKey(ContainerMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)) {\n+              .containsKey(ContainerMetricsConstants.DIAGNOSTICS_INFO)) {\n             diagnosticsInfo \u003d\n                 eventInfo.get(\n-                    ContainerMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)\n+                    ContainerMetricsConstants.DIAGNOSTICS_INFO)\n                     .toString();\n           }\n           if (eventInfo\n-              .containsKey(ContainerMetricsConstants.EXIT_STATUS_EVENT_INFO)) {\n+              .containsKey(ContainerMetricsConstants.EXIT_STATUS_INFO)) {\n             exitStatus \u003d (Integer) eventInfo.get(\n-                    ContainerMetricsConstants.EXIT_STATUS_EVENT_INFO);\n+                    ContainerMetricsConstants.EXIT_STATUS_INFO);\n           }\n           if (eventInfo\n-              .containsKey(ContainerMetricsConstants.STATE_EVENT_INFO)) {\n+              .containsKey(ContainerMetricsConstants.STATE_INFO)) {\n             state \u003d\n                 ContainerState.valueOf(eventInfo.get(\n-                    ContainerMetricsConstants.STATE_EVENT_INFO).toString());\n+                    ContainerMetricsConstants.STATE_INFO).toString());\n           }\n         }\n       }\n     }\n     ContainerId containerId \u003d\n         ContainerId.fromString(entity.getEntityId());\n     String logUrl \u003d null;\n     NodeId allocatedNode \u003d null;\n     if (allocatedHost !\u003d null) {\n       allocatedNode \u003d NodeId.newInstance(allocatedHost, allocatedPort);\n       logUrl \u003d WebAppUtils.getAggregatedLogURL(\n           serverHttpAddress,\n           allocatedNode.toString(),\n           containerId.toString(),\n           containerId.toString(),\n           user);\n     }\n     return ContainerReport.newInstance(\n         ContainerId.fromString(entity.getEntityId()),\n         Resource.newInstance(allocatedMem, allocatedVcore), allocatedNode,\n         Priority.newInstance(allocatedPriority),\n         createdTime, finishedTime, diagnosticsInfo, logUrl, exitStatus, state,\n         nodeHttpAddress);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static ContainerReport convertToContainerReport(\n      TimelineEntity entity, String serverHttpAddress, String user) {\n    int allocatedMem \u003d 0;\n    int allocatedVcore \u003d 0;\n    String allocatedHost \u003d null;\n    int allocatedPort \u003d -1;\n    int allocatedPriority \u003d 0;\n    long createdTime \u003d 0;\n    long finishedTime \u003d 0;\n    String diagnosticsInfo \u003d null;\n    int exitStatus \u003d ContainerExitStatus.INVALID;\n    ContainerState state \u003d null;\n    String nodeHttpAddress \u003d null;\n    Map\u003cString, Object\u003e entityInfo \u003d entity.getOtherInfo();\n    if (entityInfo !\u003d null) {\n      if (entityInfo\n          .containsKey(ContainerMetricsConstants.ALLOCATED_MEMORY_INFO)) {\n        allocatedMem \u003d (Integer) entityInfo.get(\n                ContainerMetricsConstants.ALLOCATED_MEMORY_INFO);\n      }\n      if (entityInfo\n          .containsKey(ContainerMetricsConstants.ALLOCATED_VCORE_INFO)) {\n        allocatedVcore \u003d (Integer) entityInfo.get(\n                ContainerMetricsConstants.ALLOCATED_VCORE_INFO);\n      }\n      if (entityInfo\n          .containsKey(ContainerMetricsConstants.ALLOCATED_HOST_INFO)) {\n        allocatedHost \u003d\n            entityInfo\n                .get(ContainerMetricsConstants.ALLOCATED_HOST_INFO)\n                .toString();\n      }\n      if (entityInfo\n          .containsKey(ContainerMetricsConstants.ALLOCATED_PORT_INFO)) {\n        allocatedPort \u003d (Integer) entityInfo.get(\n                ContainerMetricsConstants.ALLOCATED_PORT_INFO);\n      }\n      if (entityInfo\n          .containsKey(ContainerMetricsConstants.ALLOCATED_PRIORITY_INFO)) {\n        allocatedPriority \u003d (Integer) entityInfo.get(\n                ContainerMetricsConstants.ALLOCATED_PRIORITY_INFO);\n      }\n      if (entityInfo.containsKey(\n          ContainerMetricsConstants.ALLOCATED_HOST_HTTP_ADDRESS_INFO)) {\n        nodeHttpAddress \u003d\n            (String) entityInfo\n              .get(ContainerMetricsConstants.ALLOCATED_HOST_HTTP_ADDRESS_INFO);\n      }\n    }\n    List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n    if (events !\u003d null) {\n      for (TimelineEvent event : events) {\n        if (event.getEventType().equals(\n            ContainerMetricsConstants.CREATED_EVENT_TYPE)) {\n          createdTime \u003d event.getTimestamp();\n        } else if (event.getEventType().equals(\n            ContainerMetricsConstants.FINISHED_EVENT_TYPE)) {\n          finishedTime \u003d event.getTimestamp();\n          Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n          if (eventInfo \u003d\u003d null) {\n            continue;\n          }\n          if (eventInfo\n              .containsKey(ContainerMetricsConstants.DIAGNOSTICS_INFO)) {\n            diagnosticsInfo \u003d\n                eventInfo.get(\n                    ContainerMetricsConstants.DIAGNOSTICS_INFO)\n                    .toString();\n          }\n          if (eventInfo\n              .containsKey(ContainerMetricsConstants.EXIT_STATUS_INFO)) {\n            exitStatus \u003d (Integer) eventInfo.get(\n                    ContainerMetricsConstants.EXIT_STATUS_INFO);\n          }\n          if (eventInfo\n              .containsKey(ContainerMetricsConstants.STATE_INFO)) {\n            state \u003d\n                ContainerState.valueOf(eventInfo.get(\n                    ContainerMetricsConstants.STATE_INFO).toString());\n          }\n        }\n      }\n    }\n    ContainerId containerId \u003d\n        ContainerId.fromString(entity.getEntityId());\n    String logUrl \u003d null;\n    NodeId allocatedNode \u003d null;\n    if (allocatedHost !\u003d null) {\n      allocatedNode \u003d NodeId.newInstance(allocatedHost, allocatedPort);\n      logUrl \u003d WebAppUtils.getAggregatedLogURL(\n          serverHttpAddress,\n          allocatedNode.toString(),\n          containerId.toString(),\n          containerId.toString(),\n          user);\n    }\n    return ContainerReport.newInstance(\n        ContainerId.fromString(entity.getEntityId()),\n        Resource.newInstance(allocatedMem, allocatedVcore), allocatedNode,\n        Priority.newInstance(allocatedPriority),\n        createdTime, finishedTime, diagnosticsInfo, logUrl, exitStatus, state,\n        nodeHttpAddress);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/applicationhistoryservice/ApplicationHistoryManagerOnTimelineStore.java",
      "extendedDetails": {}
    },
    "c77a1095dc556e8bea87df6d8ddf36e898f27e86": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1942. Deprecate toString/fromString methods from ConverterUtils and move them to records classes like ContainerId/ApplicationId, etc. (wangda)\n",
      "commitDate": "14/06/16 3:06 PM",
      "commitName": "c77a1095dc556e8bea87df6d8ddf36e898f27e86",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "19/05/16 9:13 AM",
      "commitNameOld": "141873ca7d68619e3458712b17aed57fec8fd7c8",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 26.25,
      "commitsBetweenForRepo": 163,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,103 +1,103 @@\n   private static ContainerReport convertToContainerReport(\n       TimelineEntity entity, String serverHttpAddress, String user) {\n     int allocatedMem \u003d 0;\n     int allocatedVcore \u003d 0;\n     String allocatedHost \u003d null;\n     int allocatedPort \u003d -1;\n     int allocatedPriority \u003d 0;\n     long createdTime \u003d 0;\n     long finishedTime \u003d 0;\n     String diagnosticsInfo \u003d null;\n     int exitStatus \u003d ContainerExitStatus.INVALID;\n     ContainerState state \u003d null;\n     String nodeHttpAddress \u003d null;\n     Map\u003cString, Object\u003e entityInfo \u003d entity.getOtherInfo();\n     if (entityInfo !\u003d null) {\n       if (entityInfo\n           .containsKey(ContainerMetricsConstants.ALLOCATED_MEMORY_ENTITY_INFO)) {\n         allocatedMem \u003d (Integer) entityInfo.get(\n                 ContainerMetricsConstants.ALLOCATED_MEMORY_ENTITY_INFO);\n       }\n       if (entityInfo\n           .containsKey(ContainerMetricsConstants.ALLOCATED_VCORE_ENTITY_INFO)) {\n         allocatedVcore \u003d (Integer) entityInfo.get(\n                 ContainerMetricsConstants.ALLOCATED_VCORE_ENTITY_INFO);\n       }\n       if (entityInfo\n           .containsKey(ContainerMetricsConstants.ALLOCATED_HOST_ENTITY_INFO)) {\n         allocatedHost \u003d\n             entityInfo\n                 .get(ContainerMetricsConstants.ALLOCATED_HOST_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo\n           .containsKey(ContainerMetricsConstants.ALLOCATED_PORT_ENTITY_INFO)) {\n         allocatedPort \u003d (Integer) entityInfo.get(\n                 ContainerMetricsConstants.ALLOCATED_PORT_ENTITY_INFO);\n       }\n       if (entityInfo\n           .containsKey(ContainerMetricsConstants.ALLOCATED_PRIORITY_ENTITY_INFO)) {\n         allocatedPriority \u003d (Integer) entityInfo.get(\n                 ContainerMetricsConstants.ALLOCATED_PRIORITY_ENTITY_INFO);\n       }\n       if (entityInfo.containsKey(\n           ContainerMetricsConstants.ALLOCATED_HOST_HTTP_ADDRESS_ENTITY_INFO)) {\n         nodeHttpAddress \u003d\n             (String) entityInfo\n               .get(ContainerMetricsConstants.ALLOCATED_HOST_HTTP_ADDRESS_ENTITY_INFO);\n       }\n     }\n     List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n     if (events !\u003d null) {\n       for (TimelineEvent event : events) {\n         if (event.getEventType().equals(\n             ContainerMetricsConstants.CREATED_EVENT_TYPE)) {\n           createdTime \u003d event.getTimestamp();\n         } else if (event.getEventType().equals(\n             ContainerMetricsConstants.FINISHED_EVENT_TYPE)) {\n           finishedTime \u003d event.getTimestamp();\n           Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n           if (eventInfo \u003d\u003d null) {\n             continue;\n           }\n           if (eventInfo\n               .containsKey(ContainerMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)) {\n             diagnosticsInfo \u003d\n                 eventInfo.get(\n                     ContainerMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)\n                     .toString();\n           }\n           if (eventInfo\n               .containsKey(ContainerMetricsConstants.EXIT_STATUS_EVENT_INFO)) {\n             exitStatus \u003d (Integer) eventInfo.get(\n                     ContainerMetricsConstants.EXIT_STATUS_EVENT_INFO);\n           }\n           if (eventInfo\n               .containsKey(ContainerMetricsConstants.STATE_EVENT_INFO)) {\n             state \u003d\n                 ContainerState.valueOf(eventInfo.get(\n                     ContainerMetricsConstants.STATE_EVENT_INFO).toString());\n           }\n         }\n       }\n     }\n     ContainerId containerId \u003d\n-        ConverterUtils.toContainerId(entity.getEntityId());\n+        ContainerId.fromString(entity.getEntityId());\n     String logUrl \u003d null;\n     NodeId allocatedNode \u003d null;\n     if (allocatedHost !\u003d null) {\n       allocatedNode \u003d NodeId.newInstance(allocatedHost, allocatedPort);\n       logUrl \u003d WebAppUtils.getAggregatedLogURL(\n           serverHttpAddress,\n           allocatedNode.toString(),\n           containerId.toString(),\n           containerId.toString(),\n           user);\n     }\n     return ContainerReport.newInstance(\n-        ConverterUtils.toContainerId(entity.getEntityId()),\n+        ContainerId.fromString(entity.getEntityId()),\n         Resource.newInstance(allocatedMem, allocatedVcore), allocatedNode,\n         Priority.newInstance(allocatedPriority),\n         createdTime, finishedTime, diagnosticsInfo, logUrl, exitStatus, state,\n         nodeHttpAddress);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static ContainerReport convertToContainerReport(\n      TimelineEntity entity, String serverHttpAddress, String user) {\n    int allocatedMem \u003d 0;\n    int allocatedVcore \u003d 0;\n    String allocatedHost \u003d null;\n    int allocatedPort \u003d -1;\n    int allocatedPriority \u003d 0;\n    long createdTime \u003d 0;\n    long finishedTime \u003d 0;\n    String diagnosticsInfo \u003d null;\n    int exitStatus \u003d ContainerExitStatus.INVALID;\n    ContainerState state \u003d null;\n    String nodeHttpAddress \u003d null;\n    Map\u003cString, Object\u003e entityInfo \u003d entity.getOtherInfo();\n    if (entityInfo !\u003d null) {\n      if (entityInfo\n          .containsKey(ContainerMetricsConstants.ALLOCATED_MEMORY_ENTITY_INFO)) {\n        allocatedMem \u003d (Integer) entityInfo.get(\n                ContainerMetricsConstants.ALLOCATED_MEMORY_ENTITY_INFO);\n      }\n      if (entityInfo\n          .containsKey(ContainerMetricsConstants.ALLOCATED_VCORE_ENTITY_INFO)) {\n        allocatedVcore \u003d (Integer) entityInfo.get(\n                ContainerMetricsConstants.ALLOCATED_VCORE_ENTITY_INFO);\n      }\n      if (entityInfo\n          .containsKey(ContainerMetricsConstants.ALLOCATED_HOST_ENTITY_INFO)) {\n        allocatedHost \u003d\n            entityInfo\n                .get(ContainerMetricsConstants.ALLOCATED_HOST_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo\n          .containsKey(ContainerMetricsConstants.ALLOCATED_PORT_ENTITY_INFO)) {\n        allocatedPort \u003d (Integer) entityInfo.get(\n                ContainerMetricsConstants.ALLOCATED_PORT_ENTITY_INFO);\n      }\n      if (entityInfo\n          .containsKey(ContainerMetricsConstants.ALLOCATED_PRIORITY_ENTITY_INFO)) {\n        allocatedPriority \u003d (Integer) entityInfo.get(\n                ContainerMetricsConstants.ALLOCATED_PRIORITY_ENTITY_INFO);\n      }\n      if (entityInfo.containsKey(\n          ContainerMetricsConstants.ALLOCATED_HOST_HTTP_ADDRESS_ENTITY_INFO)) {\n        nodeHttpAddress \u003d\n            (String) entityInfo\n              .get(ContainerMetricsConstants.ALLOCATED_HOST_HTTP_ADDRESS_ENTITY_INFO);\n      }\n    }\n    List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n    if (events !\u003d null) {\n      for (TimelineEvent event : events) {\n        if (event.getEventType().equals(\n            ContainerMetricsConstants.CREATED_EVENT_TYPE)) {\n          createdTime \u003d event.getTimestamp();\n        } else if (event.getEventType().equals(\n            ContainerMetricsConstants.FINISHED_EVENT_TYPE)) {\n          finishedTime \u003d event.getTimestamp();\n          Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n          if (eventInfo \u003d\u003d null) {\n            continue;\n          }\n          if (eventInfo\n              .containsKey(ContainerMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)) {\n            diagnosticsInfo \u003d\n                eventInfo.get(\n                    ContainerMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)\n                    .toString();\n          }\n          if (eventInfo\n              .containsKey(ContainerMetricsConstants.EXIT_STATUS_EVENT_INFO)) {\n            exitStatus \u003d (Integer) eventInfo.get(\n                    ContainerMetricsConstants.EXIT_STATUS_EVENT_INFO);\n          }\n          if (eventInfo\n              .containsKey(ContainerMetricsConstants.STATE_EVENT_INFO)) {\n            state \u003d\n                ContainerState.valueOf(eventInfo.get(\n                    ContainerMetricsConstants.STATE_EVENT_INFO).toString());\n          }\n        }\n      }\n    }\n    ContainerId containerId \u003d\n        ContainerId.fromString(entity.getEntityId());\n    String logUrl \u003d null;\n    NodeId allocatedNode \u003d null;\n    if (allocatedHost !\u003d null) {\n      allocatedNode \u003d NodeId.newInstance(allocatedHost, allocatedPort);\n      logUrl \u003d WebAppUtils.getAggregatedLogURL(\n          serverHttpAddress,\n          allocatedNode.toString(),\n          containerId.toString(),\n          containerId.toString(),\n          user);\n    }\n    return ContainerReport.newInstance(\n        ContainerId.fromString(entity.getEntityId()),\n        Resource.newInstance(allocatedMem, allocatedVcore), allocatedNode,\n        Priority.newInstance(allocatedPriority),\n        createdTime, finishedTime, diagnosticsInfo, logUrl, exitStatus, state,\n        nodeHttpAddress);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/applicationhistoryservice/ApplicationHistoryManagerOnTimelineStore.java",
      "extendedDetails": {}
    },
    "b2ed6ae73197990a950ce71ece80c0f23221c384": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4747. AHS error 500 due to NPE when container start event is missing. Contributed by Varun Saxena\n",
      "commitDate": "06/05/16 3:59 PM",
      "commitName": "b2ed6ae73197990a950ce71ece80c0f23221c384",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "29/02/16 6:19 PM",
      "commitNameOld": "d93c22ec274b1a0f29609217039b80732886fed7",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 66.86,
      "commitsBetweenForRepo": 399,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,100 +1,103 @@\n   private static ContainerReport convertToContainerReport(\n       TimelineEntity entity, String serverHttpAddress, String user) {\n     int allocatedMem \u003d 0;\n     int allocatedVcore \u003d 0;\n     String allocatedHost \u003d null;\n     int allocatedPort \u003d -1;\n     int allocatedPriority \u003d 0;\n     long createdTime \u003d 0;\n     long finishedTime \u003d 0;\n     String diagnosticsInfo \u003d null;\n     int exitStatus \u003d ContainerExitStatus.INVALID;\n     ContainerState state \u003d null;\n     String nodeHttpAddress \u003d null;\n     Map\u003cString, Object\u003e entityInfo \u003d entity.getOtherInfo();\n     if (entityInfo !\u003d null) {\n       if (entityInfo\n           .containsKey(ContainerMetricsConstants.ALLOCATED_MEMORY_ENTITY_INFO)) {\n         allocatedMem \u003d (Integer) entityInfo.get(\n                 ContainerMetricsConstants.ALLOCATED_MEMORY_ENTITY_INFO);\n       }\n       if (entityInfo\n           .containsKey(ContainerMetricsConstants.ALLOCATED_VCORE_ENTITY_INFO)) {\n         allocatedVcore \u003d (Integer) entityInfo.get(\n                 ContainerMetricsConstants.ALLOCATED_VCORE_ENTITY_INFO);\n       }\n       if (entityInfo\n           .containsKey(ContainerMetricsConstants.ALLOCATED_HOST_ENTITY_INFO)) {\n         allocatedHost \u003d\n             entityInfo\n                 .get(ContainerMetricsConstants.ALLOCATED_HOST_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo\n           .containsKey(ContainerMetricsConstants.ALLOCATED_PORT_ENTITY_INFO)) {\n         allocatedPort \u003d (Integer) entityInfo.get(\n                 ContainerMetricsConstants.ALLOCATED_PORT_ENTITY_INFO);\n       }\n       if (entityInfo\n           .containsKey(ContainerMetricsConstants.ALLOCATED_PRIORITY_ENTITY_INFO)) {\n         allocatedPriority \u003d (Integer) entityInfo.get(\n                 ContainerMetricsConstants.ALLOCATED_PRIORITY_ENTITY_INFO);\n       }\n       if (entityInfo.containsKey(\n           ContainerMetricsConstants.ALLOCATED_HOST_HTTP_ADDRESS_ENTITY_INFO)) {\n         nodeHttpAddress \u003d\n             (String) entityInfo\n               .get(ContainerMetricsConstants.ALLOCATED_HOST_HTTP_ADDRESS_ENTITY_INFO);\n       }\n     }\n     List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n     if (events !\u003d null) {\n       for (TimelineEvent event : events) {\n         if (event.getEventType().equals(\n             ContainerMetricsConstants.CREATED_EVENT_TYPE)) {\n           createdTime \u003d event.getTimestamp();\n         } else if (event.getEventType().equals(\n             ContainerMetricsConstants.FINISHED_EVENT_TYPE)) {\n           finishedTime \u003d event.getTimestamp();\n           Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n           if (eventInfo \u003d\u003d null) {\n             continue;\n           }\n           if (eventInfo\n               .containsKey(ContainerMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)) {\n             diagnosticsInfo \u003d\n                 eventInfo.get(\n                     ContainerMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)\n                     .toString();\n           }\n           if (eventInfo\n               .containsKey(ContainerMetricsConstants.EXIT_STATUS_EVENT_INFO)) {\n             exitStatus \u003d (Integer) eventInfo.get(\n                     ContainerMetricsConstants.EXIT_STATUS_EVENT_INFO);\n           }\n           if (eventInfo\n               .containsKey(ContainerMetricsConstants.STATE_EVENT_INFO)) {\n             state \u003d\n                 ContainerState.valueOf(eventInfo.get(\n                     ContainerMetricsConstants.STATE_EVENT_INFO).toString());\n           }\n         }\n       }\n     }\n-    NodeId allocatedNode \u003d NodeId.newInstance(allocatedHost, allocatedPort);\n     ContainerId containerId \u003d\n         ConverterUtils.toContainerId(entity.getEntityId());\n-    String logUrl \u003d WebAppUtils.getAggregatedLogURL(\n-        serverHttpAddress,\n-        allocatedNode.toString(),\n-        containerId.toString(),\n-        containerId.toString(),\n-        user);\n+    String logUrl \u003d null;\n+    NodeId allocatedNode \u003d null;\n+    if (allocatedHost !\u003d null) {\n+      allocatedNode \u003d NodeId.newInstance(allocatedHost, allocatedPort);\n+      logUrl \u003d WebAppUtils.getAggregatedLogURL(\n+          serverHttpAddress,\n+          allocatedNode.toString(),\n+          containerId.toString(),\n+          containerId.toString(),\n+          user);\n+    }\n     return ContainerReport.newInstance(\n         ConverterUtils.toContainerId(entity.getEntityId()),\n-        Resource.newInstance(allocatedMem, allocatedVcore),\n-        NodeId.newInstance(allocatedHost, allocatedPort),\n+        Resource.newInstance(allocatedMem, allocatedVcore), allocatedNode,\n         Priority.newInstance(allocatedPriority),\n         createdTime, finishedTime, diagnosticsInfo, logUrl, exitStatus, state,\n         nodeHttpAddress);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static ContainerReport convertToContainerReport(\n      TimelineEntity entity, String serverHttpAddress, String user) {\n    int allocatedMem \u003d 0;\n    int allocatedVcore \u003d 0;\n    String allocatedHost \u003d null;\n    int allocatedPort \u003d -1;\n    int allocatedPriority \u003d 0;\n    long createdTime \u003d 0;\n    long finishedTime \u003d 0;\n    String diagnosticsInfo \u003d null;\n    int exitStatus \u003d ContainerExitStatus.INVALID;\n    ContainerState state \u003d null;\n    String nodeHttpAddress \u003d null;\n    Map\u003cString, Object\u003e entityInfo \u003d entity.getOtherInfo();\n    if (entityInfo !\u003d null) {\n      if (entityInfo\n          .containsKey(ContainerMetricsConstants.ALLOCATED_MEMORY_ENTITY_INFO)) {\n        allocatedMem \u003d (Integer) entityInfo.get(\n                ContainerMetricsConstants.ALLOCATED_MEMORY_ENTITY_INFO);\n      }\n      if (entityInfo\n          .containsKey(ContainerMetricsConstants.ALLOCATED_VCORE_ENTITY_INFO)) {\n        allocatedVcore \u003d (Integer) entityInfo.get(\n                ContainerMetricsConstants.ALLOCATED_VCORE_ENTITY_INFO);\n      }\n      if (entityInfo\n          .containsKey(ContainerMetricsConstants.ALLOCATED_HOST_ENTITY_INFO)) {\n        allocatedHost \u003d\n            entityInfo\n                .get(ContainerMetricsConstants.ALLOCATED_HOST_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo\n          .containsKey(ContainerMetricsConstants.ALLOCATED_PORT_ENTITY_INFO)) {\n        allocatedPort \u003d (Integer) entityInfo.get(\n                ContainerMetricsConstants.ALLOCATED_PORT_ENTITY_INFO);\n      }\n      if (entityInfo\n          .containsKey(ContainerMetricsConstants.ALLOCATED_PRIORITY_ENTITY_INFO)) {\n        allocatedPriority \u003d (Integer) entityInfo.get(\n                ContainerMetricsConstants.ALLOCATED_PRIORITY_ENTITY_INFO);\n      }\n      if (entityInfo.containsKey(\n          ContainerMetricsConstants.ALLOCATED_HOST_HTTP_ADDRESS_ENTITY_INFO)) {\n        nodeHttpAddress \u003d\n            (String) entityInfo\n              .get(ContainerMetricsConstants.ALLOCATED_HOST_HTTP_ADDRESS_ENTITY_INFO);\n      }\n    }\n    List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n    if (events !\u003d null) {\n      for (TimelineEvent event : events) {\n        if (event.getEventType().equals(\n            ContainerMetricsConstants.CREATED_EVENT_TYPE)) {\n          createdTime \u003d event.getTimestamp();\n        } else if (event.getEventType().equals(\n            ContainerMetricsConstants.FINISHED_EVENT_TYPE)) {\n          finishedTime \u003d event.getTimestamp();\n          Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n          if (eventInfo \u003d\u003d null) {\n            continue;\n          }\n          if (eventInfo\n              .containsKey(ContainerMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)) {\n            diagnosticsInfo \u003d\n                eventInfo.get(\n                    ContainerMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)\n                    .toString();\n          }\n          if (eventInfo\n              .containsKey(ContainerMetricsConstants.EXIT_STATUS_EVENT_INFO)) {\n            exitStatus \u003d (Integer) eventInfo.get(\n                    ContainerMetricsConstants.EXIT_STATUS_EVENT_INFO);\n          }\n          if (eventInfo\n              .containsKey(ContainerMetricsConstants.STATE_EVENT_INFO)) {\n            state \u003d\n                ContainerState.valueOf(eventInfo.get(\n                    ContainerMetricsConstants.STATE_EVENT_INFO).toString());\n          }\n        }\n      }\n    }\n    ContainerId containerId \u003d\n        ConverterUtils.toContainerId(entity.getEntityId());\n    String logUrl \u003d null;\n    NodeId allocatedNode \u003d null;\n    if (allocatedHost !\u003d null) {\n      allocatedNode \u003d NodeId.newInstance(allocatedHost, allocatedPort);\n      logUrl \u003d WebAppUtils.getAggregatedLogURL(\n          serverHttpAddress,\n          allocatedNode.toString(),\n          containerId.toString(),\n          containerId.toString(),\n          user);\n    }\n    return ContainerReport.newInstance(\n        ConverterUtils.toContainerId(entity.getEntityId()),\n        Resource.newInstance(allocatedMem, allocatedVcore), allocatedNode,\n        Priority.newInstance(allocatedPriority),\n        createdTime, finishedTime, diagnosticsInfo, logUrl, exitStatus, state,\n        nodeHttpAddress);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/applicationhistoryservice/ApplicationHistoryManagerOnTimelineStore.java",
      "extendedDetails": {}
    },
    "85f6d67fa78511f255fcfa810afc9a156a7b483b": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1884. Added nodeHttpAddress into ContainerReport and fixed the link to NM web page. Contributed by Xuan Gong.\n",
      "commitDate": "11/03/15 7:35 PM",
      "commitName": "85f6d67fa78511f255fcfa810afc9a156a7b483b",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "03/02/15 5:34 PM",
      "commitNameOld": "e5b56e2af6b48cbc8501f624ae4b4f9d13eccacf",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 36.04,
      "commitsBetweenForRepo": 358,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,92 +1,100 @@\n   private static ContainerReport convertToContainerReport(\n       TimelineEntity entity, String serverHttpAddress, String user) {\n     int allocatedMem \u003d 0;\n     int allocatedVcore \u003d 0;\n     String allocatedHost \u003d null;\n     int allocatedPort \u003d -1;\n     int allocatedPriority \u003d 0;\n     long createdTime \u003d 0;\n     long finishedTime \u003d 0;\n     String diagnosticsInfo \u003d null;\n     int exitStatus \u003d ContainerExitStatus.INVALID;\n     ContainerState state \u003d null;\n+    String nodeHttpAddress \u003d null;\n     Map\u003cString, Object\u003e entityInfo \u003d entity.getOtherInfo();\n     if (entityInfo !\u003d null) {\n       if (entityInfo\n           .containsKey(ContainerMetricsConstants.ALLOCATED_MEMORY_ENTITY_INFO)) {\n         allocatedMem \u003d (Integer) entityInfo.get(\n                 ContainerMetricsConstants.ALLOCATED_MEMORY_ENTITY_INFO);\n       }\n       if (entityInfo\n           .containsKey(ContainerMetricsConstants.ALLOCATED_VCORE_ENTITY_INFO)) {\n         allocatedVcore \u003d (Integer) entityInfo.get(\n                 ContainerMetricsConstants.ALLOCATED_VCORE_ENTITY_INFO);\n       }\n       if (entityInfo\n           .containsKey(ContainerMetricsConstants.ALLOCATED_HOST_ENTITY_INFO)) {\n         allocatedHost \u003d\n             entityInfo\n                 .get(ContainerMetricsConstants.ALLOCATED_HOST_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo\n           .containsKey(ContainerMetricsConstants.ALLOCATED_PORT_ENTITY_INFO)) {\n         allocatedPort \u003d (Integer) entityInfo.get(\n                 ContainerMetricsConstants.ALLOCATED_PORT_ENTITY_INFO);\n       }\n       if (entityInfo\n           .containsKey(ContainerMetricsConstants.ALLOCATED_PRIORITY_ENTITY_INFO)) {\n         allocatedPriority \u003d (Integer) entityInfo.get(\n                 ContainerMetricsConstants.ALLOCATED_PRIORITY_ENTITY_INFO);\n       }\n+      if (entityInfo.containsKey(\n+          ContainerMetricsConstants.ALLOCATED_HOST_HTTP_ADDRESS_ENTITY_INFO)) {\n+        nodeHttpAddress \u003d\n+            (String) entityInfo\n+              .get(ContainerMetricsConstants.ALLOCATED_HOST_HTTP_ADDRESS_ENTITY_INFO);\n+      }\n     }\n     List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n     if (events !\u003d null) {\n       for (TimelineEvent event : events) {\n         if (event.getEventType().equals(\n             ContainerMetricsConstants.CREATED_EVENT_TYPE)) {\n           createdTime \u003d event.getTimestamp();\n         } else if (event.getEventType().equals(\n             ContainerMetricsConstants.FINISHED_EVENT_TYPE)) {\n           finishedTime \u003d event.getTimestamp();\n           Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n           if (eventInfo \u003d\u003d null) {\n             continue;\n           }\n           if (eventInfo\n               .containsKey(ContainerMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)) {\n             diagnosticsInfo \u003d\n                 eventInfo.get(\n                     ContainerMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)\n                     .toString();\n           }\n           if (eventInfo\n               .containsKey(ContainerMetricsConstants.EXIT_STATUS_EVENT_INFO)) {\n             exitStatus \u003d (Integer) eventInfo.get(\n                     ContainerMetricsConstants.EXIT_STATUS_EVENT_INFO);\n           }\n           if (eventInfo\n               .containsKey(ContainerMetricsConstants.STATE_EVENT_INFO)) {\n             state \u003d\n                 ContainerState.valueOf(eventInfo.get(\n                     ContainerMetricsConstants.STATE_EVENT_INFO).toString());\n           }\n         }\n       }\n     }\n     NodeId allocatedNode \u003d NodeId.newInstance(allocatedHost, allocatedPort);\n     ContainerId containerId \u003d\n         ConverterUtils.toContainerId(entity.getEntityId());\n     String logUrl \u003d WebAppUtils.getAggregatedLogURL(\n         serverHttpAddress,\n         allocatedNode.toString(),\n         containerId.toString(),\n         containerId.toString(),\n         user);\n     return ContainerReport.newInstance(\n         ConverterUtils.toContainerId(entity.getEntityId()),\n         Resource.newInstance(allocatedMem, allocatedVcore),\n         NodeId.newInstance(allocatedHost, allocatedPort),\n         Priority.newInstance(allocatedPriority),\n-        createdTime, finishedTime, diagnosticsInfo, logUrl, exitStatus, state);\n+        createdTime, finishedTime, diagnosticsInfo, logUrl, exitStatus, state,\n+        nodeHttpAddress);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static ContainerReport convertToContainerReport(\n      TimelineEntity entity, String serverHttpAddress, String user) {\n    int allocatedMem \u003d 0;\n    int allocatedVcore \u003d 0;\n    String allocatedHost \u003d null;\n    int allocatedPort \u003d -1;\n    int allocatedPriority \u003d 0;\n    long createdTime \u003d 0;\n    long finishedTime \u003d 0;\n    String diagnosticsInfo \u003d null;\n    int exitStatus \u003d ContainerExitStatus.INVALID;\n    ContainerState state \u003d null;\n    String nodeHttpAddress \u003d null;\n    Map\u003cString, Object\u003e entityInfo \u003d entity.getOtherInfo();\n    if (entityInfo !\u003d null) {\n      if (entityInfo\n          .containsKey(ContainerMetricsConstants.ALLOCATED_MEMORY_ENTITY_INFO)) {\n        allocatedMem \u003d (Integer) entityInfo.get(\n                ContainerMetricsConstants.ALLOCATED_MEMORY_ENTITY_INFO);\n      }\n      if (entityInfo\n          .containsKey(ContainerMetricsConstants.ALLOCATED_VCORE_ENTITY_INFO)) {\n        allocatedVcore \u003d (Integer) entityInfo.get(\n                ContainerMetricsConstants.ALLOCATED_VCORE_ENTITY_INFO);\n      }\n      if (entityInfo\n          .containsKey(ContainerMetricsConstants.ALLOCATED_HOST_ENTITY_INFO)) {\n        allocatedHost \u003d\n            entityInfo\n                .get(ContainerMetricsConstants.ALLOCATED_HOST_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo\n          .containsKey(ContainerMetricsConstants.ALLOCATED_PORT_ENTITY_INFO)) {\n        allocatedPort \u003d (Integer) entityInfo.get(\n                ContainerMetricsConstants.ALLOCATED_PORT_ENTITY_INFO);\n      }\n      if (entityInfo\n          .containsKey(ContainerMetricsConstants.ALLOCATED_PRIORITY_ENTITY_INFO)) {\n        allocatedPriority \u003d (Integer) entityInfo.get(\n                ContainerMetricsConstants.ALLOCATED_PRIORITY_ENTITY_INFO);\n      }\n      if (entityInfo.containsKey(\n          ContainerMetricsConstants.ALLOCATED_HOST_HTTP_ADDRESS_ENTITY_INFO)) {\n        nodeHttpAddress \u003d\n            (String) entityInfo\n              .get(ContainerMetricsConstants.ALLOCATED_HOST_HTTP_ADDRESS_ENTITY_INFO);\n      }\n    }\n    List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n    if (events !\u003d null) {\n      for (TimelineEvent event : events) {\n        if (event.getEventType().equals(\n            ContainerMetricsConstants.CREATED_EVENT_TYPE)) {\n          createdTime \u003d event.getTimestamp();\n        } else if (event.getEventType().equals(\n            ContainerMetricsConstants.FINISHED_EVENT_TYPE)) {\n          finishedTime \u003d event.getTimestamp();\n          Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n          if (eventInfo \u003d\u003d null) {\n            continue;\n          }\n          if (eventInfo\n              .containsKey(ContainerMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)) {\n            diagnosticsInfo \u003d\n                eventInfo.get(\n                    ContainerMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)\n                    .toString();\n          }\n          if (eventInfo\n              .containsKey(ContainerMetricsConstants.EXIT_STATUS_EVENT_INFO)) {\n            exitStatus \u003d (Integer) eventInfo.get(\n                    ContainerMetricsConstants.EXIT_STATUS_EVENT_INFO);\n          }\n          if (eventInfo\n              .containsKey(ContainerMetricsConstants.STATE_EVENT_INFO)) {\n            state \u003d\n                ContainerState.valueOf(eventInfo.get(\n                    ContainerMetricsConstants.STATE_EVENT_INFO).toString());\n          }\n        }\n      }\n    }\n    NodeId allocatedNode \u003d NodeId.newInstance(allocatedHost, allocatedPort);\n    ContainerId containerId \u003d\n        ConverterUtils.toContainerId(entity.getEntityId());\n    String logUrl \u003d WebAppUtils.getAggregatedLogURL(\n        serverHttpAddress,\n        allocatedNode.toString(),\n        containerId.toString(),\n        containerId.toString(),\n        user);\n    return ContainerReport.newInstance(\n        ConverterUtils.toContainerId(entity.getEntityId()),\n        Resource.newInstance(allocatedMem, allocatedVcore),\n        NodeId.newInstance(allocatedHost, allocatedPort),\n        Priority.newInstance(allocatedPriority),\n        createdTime, finishedTime, diagnosticsInfo, logUrl, exitStatus, state,\n        nodeHttpAddress);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/applicationhistoryservice/ApplicationHistoryManagerOnTimelineStore.java",
      "extendedDetails": {}
    },
    "6b8b1608e64e300e4e1d23c60476febaca29ca38": {
      "type": "Yintroduced",
      "commitMessage": "YARN-2033. Merging generic-history into the Timeline Store (Contributed by Zhijie Shen)\n",
      "commitDate": "11/09/14 7:04 PM",
      "commitName": "6b8b1608e64e300e4e1d23c60476febaca29ca38",
      "commitAuthor": "junping_du",
      "diff": "@@ -0,0 +1,92 @@\n+  private static ContainerReport convertToContainerReport(\n+      TimelineEntity entity, String serverHttpAddress, String user) {\n+    int allocatedMem \u003d 0;\n+    int allocatedVcore \u003d 0;\n+    String allocatedHost \u003d null;\n+    int allocatedPort \u003d -1;\n+    int allocatedPriority \u003d 0;\n+    long createdTime \u003d 0;\n+    long finishedTime \u003d 0;\n+    String diagnosticsInfo \u003d null;\n+    int exitStatus \u003d ContainerExitStatus.INVALID;\n+    ContainerState state \u003d null;\n+    Map\u003cString, Object\u003e entityInfo \u003d entity.getOtherInfo();\n+    if (entityInfo !\u003d null) {\n+      if (entityInfo\n+          .containsKey(ContainerMetricsConstants.ALLOCATED_MEMORY_ENTITY_INFO)) {\n+        allocatedMem \u003d (Integer) entityInfo.get(\n+                ContainerMetricsConstants.ALLOCATED_MEMORY_ENTITY_INFO);\n+      }\n+      if (entityInfo\n+          .containsKey(ContainerMetricsConstants.ALLOCATED_VCORE_ENTITY_INFO)) {\n+        allocatedVcore \u003d (Integer) entityInfo.get(\n+                ContainerMetricsConstants.ALLOCATED_VCORE_ENTITY_INFO);\n+      }\n+      if (entityInfo\n+          .containsKey(ContainerMetricsConstants.ALLOCATED_HOST_ENTITY_INFO)) {\n+        allocatedHost \u003d\n+            entityInfo\n+                .get(ContainerMetricsConstants.ALLOCATED_HOST_ENTITY_INFO)\n+                .toString();\n+      }\n+      if (entityInfo\n+          .containsKey(ContainerMetricsConstants.ALLOCATED_PORT_ENTITY_INFO)) {\n+        allocatedPort \u003d (Integer) entityInfo.get(\n+                ContainerMetricsConstants.ALLOCATED_PORT_ENTITY_INFO);\n+      }\n+      if (entityInfo\n+          .containsKey(ContainerMetricsConstants.ALLOCATED_PRIORITY_ENTITY_INFO)) {\n+        allocatedPriority \u003d (Integer) entityInfo.get(\n+                ContainerMetricsConstants.ALLOCATED_PRIORITY_ENTITY_INFO);\n+      }\n+    }\n+    List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n+    if (events !\u003d null) {\n+      for (TimelineEvent event : events) {\n+        if (event.getEventType().equals(\n+            ContainerMetricsConstants.CREATED_EVENT_TYPE)) {\n+          createdTime \u003d event.getTimestamp();\n+        } else if (event.getEventType().equals(\n+            ContainerMetricsConstants.FINISHED_EVENT_TYPE)) {\n+          finishedTime \u003d event.getTimestamp();\n+          Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n+          if (eventInfo \u003d\u003d null) {\n+            continue;\n+          }\n+          if (eventInfo\n+              .containsKey(ContainerMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)) {\n+            diagnosticsInfo \u003d\n+                eventInfo.get(\n+                    ContainerMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)\n+                    .toString();\n+          }\n+          if (eventInfo\n+              .containsKey(ContainerMetricsConstants.EXIT_STATUS_EVENT_INFO)) {\n+            exitStatus \u003d (Integer) eventInfo.get(\n+                    ContainerMetricsConstants.EXIT_STATUS_EVENT_INFO);\n+          }\n+          if (eventInfo\n+              .containsKey(ContainerMetricsConstants.STATE_EVENT_INFO)) {\n+            state \u003d\n+                ContainerState.valueOf(eventInfo.get(\n+                    ContainerMetricsConstants.STATE_EVENT_INFO).toString());\n+          }\n+        }\n+      }\n+    }\n+    NodeId allocatedNode \u003d NodeId.newInstance(allocatedHost, allocatedPort);\n+    ContainerId containerId \u003d\n+        ConverterUtils.toContainerId(entity.getEntityId());\n+    String logUrl \u003d WebAppUtils.getAggregatedLogURL(\n+        serverHttpAddress,\n+        allocatedNode.toString(),\n+        containerId.toString(),\n+        containerId.toString(),\n+        user);\n+    return ContainerReport.newInstance(\n+        ConverterUtils.toContainerId(entity.getEntityId()),\n+        Resource.newInstance(allocatedMem, allocatedVcore),\n+        NodeId.newInstance(allocatedHost, allocatedPort),\n+        Priority.newInstance(allocatedPriority),\n+        createdTime, finishedTime, diagnosticsInfo, logUrl, exitStatus, state);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private static ContainerReport convertToContainerReport(\n      TimelineEntity entity, String serverHttpAddress, String user) {\n    int allocatedMem \u003d 0;\n    int allocatedVcore \u003d 0;\n    String allocatedHost \u003d null;\n    int allocatedPort \u003d -1;\n    int allocatedPriority \u003d 0;\n    long createdTime \u003d 0;\n    long finishedTime \u003d 0;\n    String diagnosticsInfo \u003d null;\n    int exitStatus \u003d ContainerExitStatus.INVALID;\n    ContainerState state \u003d null;\n    Map\u003cString, Object\u003e entityInfo \u003d entity.getOtherInfo();\n    if (entityInfo !\u003d null) {\n      if (entityInfo\n          .containsKey(ContainerMetricsConstants.ALLOCATED_MEMORY_ENTITY_INFO)) {\n        allocatedMem \u003d (Integer) entityInfo.get(\n                ContainerMetricsConstants.ALLOCATED_MEMORY_ENTITY_INFO);\n      }\n      if (entityInfo\n          .containsKey(ContainerMetricsConstants.ALLOCATED_VCORE_ENTITY_INFO)) {\n        allocatedVcore \u003d (Integer) entityInfo.get(\n                ContainerMetricsConstants.ALLOCATED_VCORE_ENTITY_INFO);\n      }\n      if (entityInfo\n          .containsKey(ContainerMetricsConstants.ALLOCATED_HOST_ENTITY_INFO)) {\n        allocatedHost \u003d\n            entityInfo\n                .get(ContainerMetricsConstants.ALLOCATED_HOST_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo\n          .containsKey(ContainerMetricsConstants.ALLOCATED_PORT_ENTITY_INFO)) {\n        allocatedPort \u003d (Integer) entityInfo.get(\n                ContainerMetricsConstants.ALLOCATED_PORT_ENTITY_INFO);\n      }\n      if (entityInfo\n          .containsKey(ContainerMetricsConstants.ALLOCATED_PRIORITY_ENTITY_INFO)) {\n        allocatedPriority \u003d (Integer) entityInfo.get(\n                ContainerMetricsConstants.ALLOCATED_PRIORITY_ENTITY_INFO);\n      }\n    }\n    List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n    if (events !\u003d null) {\n      for (TimelineEvent event : events) {\n        if (event.getEventType().equals(\n            ContainerMetricsConstants.CREATED_EVENT_TYPE)) {\n          createdTime \u003d event.getTimestamp();\n        } else if (event.getEventType().equals(\n            ContainerMetricsConstants.FINISHED_EVENT_TYPE)) {\n          finishedTime \u003d event.getTimestamp();\n          Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n          if (eventInfo \u003d\u003d null) {\n            continue;\n          }\n          if (eventInfo\n              .containsKey(ContainerMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)) {\n            diagnosticsInfo \u003d\n                eventInfo.get(\n                    ContainerMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)\n                    .toString();\n          }\n          if (eventInfo\n              .containsKey(ContainerMetricsConstants.EXIT_STATUS_EVENT_INFO)) {\n            exitStatus \u003d (Integer) eventInfo.get(\n                    ContainerMetricsConstants.EXIT_STATUS_EVENT_INFO);\n          }\n          if (eventInfo\n              .containsKey(ContainerMetricsConstants.STATE_EVENT_INFO)) {\n            state \u003d\n                ContainerState.valueOf(eventInfo.get(\n                    ContainerMetricsConstants.STATE_EVENT_INFO).toString());\n          }\n        }\n      }\n    }\n    NodeId allocatedNode \u003d NodeId.newInstance(allocatedHost, allocatedPort);\n    ContainerId containerId \u003d\n        ConverterUtils.toContainerId(entity.getEntityId());\n    String logUrl \u003d WebAppUtils.getAggregatedLogURL(\n        serverHttpAddress,\n        allocatedNode.toString(),\n        containerId.toString(),\n        containerId.toString(),\n        user);\n    return ContainerReport.newInstance(\n        ConverterUtils.toContainerId(entity.getEntityId()),\n        Resource.newInstance(allocatedMem, allocatedVcore),\n        NodeId.newInstance(allocatedHost, allocatedPort),\n        Priority.newInstance(allocatedPriority),\n        createdTime, finishedTime, diagnosticsInfo, logUrl, exitStatus, state);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/applicationhistoryservice/ApplicationHistoryManagerOnTimelineStore.java"
    }
  }
}