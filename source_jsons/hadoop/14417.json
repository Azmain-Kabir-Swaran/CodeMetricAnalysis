{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "Journal.java",
  "functionName": "finalizeLogSegment",
  "functionId": "finalizeLogSegment___reqInfo-RequestInfo__startTxId-long__endTxId-long",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/qjournal/server/Journal.java",
  "functionStartLine": 629,
  "functionEndLine": 685,
  "numCommitsSeen": 64,
  "timeTaken": 3537,
  "changeHistory": [
    "151c8ddbe4c05fcb5f251fa4450edc452f6c735a",
    "6beb25ab7e4f5454dba0315a296081e61753f301",
    "53bad4eb008ec553dcdbe01e7ae975dcecde6590",
    "6ae2a0d048e133b43249c248a75a4d77d9abb80d",
    "9dab514b22f49322738935cfd915c2b4eba50b88",
    "60c20e559b8036410e2d9081b9c60d1e04e56253",
    "cae8116a146cb27d40e4e41cece9a17945bc7f9c",
    "8021d9199f278345aca6211f318145342ad036f4",
    "1e68d4726b225fb4a62eb8d79a3160dd03059ccb",
    "4a9b3c693def87579298fb59b7df0b8892a3508e",
    "f765fdb65701e61887daedb2b369af4be12cb432",
    "74d4573a23db5586c6e47ff2277aa7c35237da34"
  ],
  "changeHistoryShort": {
    "151c8ddbe4c05fcb5f251fa4450edc452f6c735a": "Ybodychange",
    "6beb25ab7e4f5454dba0315a296081e61753f301": "Ybodychange",
    "53bad4eb008ec553dcdbe01e7ae975dcecde6590": "Ybodychange",
    "6ae2a0d048e133b43249c248a75a4d77d9abb80d": "Ybodychange",
    "9dab514b22f49322738935cfd915c2b4eba50b88": "Ybodychange",
    "60c20e559b8036410e2d9081b9c60d1e04e56253": "Ybodychange",
    "cae8116a146cb27d40e4e41cece9a17945bc7f9c": "Ybodychange",
    "8021d9199f278345aca6211f318145342ad036f4": "Ybodychange",
    "1e68d4726b225fb4a62eb8d79a3160dd03059ccb": "Ybodychange",
    "4a9b3c693def87579298fb59b7df0b8892a3508e": "Ybodychange",
    "f765fdb65701e61887daedb2b369af4be12cb432": "Ybodychange",
    "74d4573a23db5586c6e47ff2277aa7c35237da34": "Yintroduced"
  },
  "changeHistoryDetails": {
    "151c8ddbe4c05fcb5f251fa4450edc452f6c735a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13608. [SBN read] Edit Tail Fast Path Part 2: Add ability for JournalNode to serve edits via RPC. Contributed by Erik Krogen.\n",
      "commitDate": "24/12/18 9:33 AM",
      "commitName": "151c8ddbe4c05fcb5f251fa4450edc452f6c735a",
      "commitAuthor": "Erik Krogen",
      "commitDateOld": "06/09/18 2:48 PM",
      "commitNameOld": "eca1a4bfe952fc184fe90dde50bac9b0e5293568",
      "commitAuthorOld": "Giovanni Matteo Fumarola",
      "daysBetweenCommits": 108.82,
      "commitsBetweenForRepo": 926,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,56 +1,57 @@\n   public synchronized void finalizeLogSegment(RequestInfo reqInfo, long startTxId,\n       long endTxId) throws IOException {\n     checkFormatted();\n     checkRequest(reqInfo);\n \n     boolean needsValidation \u003d true;\n \n     // Finalizing the log that the writer was just writing.\n     if (startTxId \u003d\u003d curSegmentTxId) {\n       if (curSegment !\u003d null) {\n         curSegment.close();\n         curSegment \u003d null;\n         curSegmentTxId \u003d HdfsServerConstants.INVALID_TXID;\n+        curSegmentLayoutVersion \u003d 0;\n       }\n       \n       checkSync(nextTxId \u003d\u003d endTxId + 1,\n           \"Trying to finalize in-progress log segment %s to end at \" +\n           \"txid %s but only written up to txid %s ; journal id: %s\",\n           startTxId, endTxId, nextTxId - 1, journalId);\n       // No need to validate the edit log if the client is finalizing\n       // the log segment that it was just writing to.\n       needsValidation \u003d false;\n     }\n     \n     FileJournalManager.EditLogFile elf \u003d fjm.getLogFile(startTxId);\n     if (elf \u003d\u003d null) {\n       throw new JournalOutOfSyncException(\"No log file to finalize at \" +\n           \"transaction ID \" + startTxId + \" ; journal id: \" + journalId);\n     }\n \n     if (elf.isInProgress()) {\n       if (needsValidation) {\n         LOG.info(\"Validating log segment \" + elf.getFile() + \" about to be \" +\n             \"finalized ; journal id: \" + journalId);\n         elf.scanLog(Long.MAX_VALUE, false);\n   \n         checkSync(elf.getLastTxId() \u003d\u003d endTxId,\n             \"Trying to finalize in-progress log segment %s to end at \" +\n             \"txid %s but log %s on disk only contains up to txid %s \" +\n             \"; journal id: %s\",\n             startTxId, endTxId, elf.getFile(), elf.getLastTxId(), journalId);\n       }\n       fjm.finalizeLogSegment(startTxId, endTxId);\n     } else {\n       Preconditions.checkArgument(endTxId \u003d\u003d elf.getLastTxId(),\n           \"Trying to re-finalize already finalized log \" +\n               elf + \" with different endTxId \" + endTxId +\n               \" ; journal id: \" + journalId);\n     }\n \n     // Once logs are finalized, a different length will never be decided.\n     // During recovery, we treat a finalized segment the same as an accepted\n     // recovery. Thus, we no longer need to keep track of the previously-\n     // accepted decision. The existence of the finalized log segment is enough.\n     purgePaxosDecision(elf.getFirstTxId());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void finalizeLogSegment(RequestInfo reqInfo, long startTxId,\n      long endTxId) throws IOException {\n    checkFormatted();\n    checkRequest(reqInfo);\n\n    boolean needsValidation \u003d true;\n\n    // Finalizing the log that the writer was just writing.\n    if (startTxId \u003d\u003d curSegmentTxId) {\n      if (curSegment !\u003d null) {\n        curSegment.close();\n        curSegment \u003d null;\n        curSegmentTxId \u003d HdfsServerConstants.INVALID_TXID;\n        curSegmentLayoutVersion \u003d 0;\n      }\n      \n      checkSync(nextTxId \u003d\u003d endTxId + 1,\n          \"Trying to finalize in-progress log segment %s to end at \" +\n          \"txid %s but only written up to txid %s ; journal id: %s\",\n          startTxId, endTxId, nextTxId - 1, journalId);\n      // No need to validate the edit log if the client is finalizing\n      // the log segment that it was just writing to.\n      needsValidation \u003d false;\n    }\n    \n    FileJournalManager.EditLogFile elf \u003d fjm.getLogFile(startTxId);\n    if (elf \u003d\u003d null) {\n      throw new JournalOutOfSyncException(\"No log file to finalize at \" +\n          \"transaction ID \" + startTxId + \" ; journal id: \" + journalId);\n    }\n\n    if (elf.isInProgress()) {\n      if (needsValidation) {\n        LOG.info(\"Validating log segment \" + elf.getFile() + \" about to be \" +\n            \"finalized ; journal id: \" + journalId);\n        elf.scanLog(Long.MAX_VALUE, false);\n  \n        checkSync(elf.getLastTxId() \u003d\u003d endTxId,\n            \"Trying to finalize in-progress log segment %s to end at \" +\n            \"txid %s but log %s on disk only contains up to txid %s \" +\n            \"; journal id: %s\",\n            startTxId, endTxId, elf.getFile(), elf.getLastTxId(), journalId);\n      }\n      fjm.finalizeLogSegment(startTxId, endTxId);\n    } else {\n      Preconditions.checkArgument(endTxId \u003d\u003d elf.getLastTxId(),\n          \"Trying to re-finalize already finalized log \" +\n              elf + \" with different endTxId \" + endTxId +\n              \" ; journal id: \" + journalId);\n    }\n\n    // Once logs are finalized, a different length will never be decided.\n    // During recovery, we treat a finalized segment the same as an accepted\n    // recovery. Thus, we no longer need to keep track of the previously-\n    // accepted decision. The existence of the finalized log segment is enough.\n    purgePaxosDecision(elf.getFirstTxId());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/qjournal/server/Journal.java",
      "extendedDetails": {}
    },
    "6beb25ab7e4f5454dba0315a296081e61753f301": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13544. Improve logging for JournalNode in federated cluster.\n",
      "commitDate": "14/05/18 10:12 AM",
      "commitName": "6beb25ab7e4f5454dba0315a296081e61753f301",
      "commitAuthor": "Hanisha Koneru",
      "commitDateOld": "13/10/17 2:22 PM",
      "commitNameOld": "8dd1eeb94fef59feaf19182dd8f1fcf1389c7f34",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 212.83,
      "commitsBetweenForRepo": 2051,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,56 @@\n   public synchronized void finalizeLogSegment(RequestInfo reqInfo, long startTxId,\n       long endTxId) throws IOException {\n     checkFormatted();\n     checkRequest(reqInfo);\n \n     boolean needsValidation \u003d true;\n \n     // Finalizing the log that the writer was just writing.\n     if (startTxId \u003d\u003d curSegmentTxId) {\n       if (curSegment !\u003d null) {\n         curSegment.close();\n         curSegment \u003d null;\n         curSegmentTxId \u003d HdfsServerConstants.INVALID_TXID;\n       }\n       \n       checkSync(nextTxId \u003d\u003d endTxId + 1,\n           \"Trying to finalize in-progress log segment %s to end at \" +\n-          \"txid %s but only written up to txid %s\",\n-          startTxId, endTxId, nextTxId - 1);\n+          \"txid %s but only written up to txid %s ; journal id: %s\",\n+          startTxId, endTxId, nextTxId - 1, journalId);\n       // No need to validate the edit log if the client is finalizing\n       // the log segment that it was just writing to.\n       needsValidation \u003d false;\n     }\n     \n     FileJournalManager.EditLogFile elf \u003d fjm.getLogFile(startTxId);\n     if (elf \u003d\u003d null) {\n       throw new JournalOutOfSyncException(\"No log file to finalize at \" +\n-          \"transaction ID \" + startTxId);\n+          \"transaction ID \" + startTxId + \" ; journal id: \" + journalId);\n     }\n \n     if (elf.isInProgress()) {\n       if (needsValidation) {\n         LOG.info(\"Validating log segment \" + elf.getFile() + \" about to be \" +\n-            \"finalized\");\n+            \"finalized ; journal id: \" + journalId);\n         elf.scanLog(Long.MAX_VALUE, false);\n   \n         checkSync(elf.getLastTxId() \u003d\u003d endTxId,\n             \"Trying to finalize in-progress log segment %s to end at \" +\n-            \"txid %s but log %s on disk only contains up to txid %s\",\n-            startTxId, endTxId, elf.getFile(), elf.getLastTxId());\n+            \"txid %s but log %s on disk only contains up to txid %s \" +\n+            \"; journal id: %s\",\n+            startTxId, endTxId, elf.getFile(), elf.getLastTxId(), journalId);\n       }\n       fjm.finalizeLogSegment(startTxId, endTxId);\n     } else {\n       Preconditions.checkArgument(endTxId \u003d\u003d elf.getLastTxId(),\n           \"Trying to re-finalize already finalized log \" +\n-              elf + \" with different endTxId \" + endTxId);\n+              elf + \" with different endTxId \" + endTxId +\n+              \" ; journal id: \" + journalId);\n     }\n \n     // Once logs are finalized, a different length will never be decided.\n     // During recovery, we treat a finalized segment the same as an accepted\n     // recovery. Thus, we no longer need to keep track of the previously-\n     // accepted decision. The existence of the finalized log segment is enough.\n     purgePaxosDecision(elf.getFirstTxId());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void finalizeLogSegment(RequestInfo reqInfo, long startTxId,\n      long endTxId) throws IOException {\n    checkFormatted();\n    checkRequest(reqInfo);\n\n    boolean needsValidation \u003d true;\n\n    // Finalizing the log that the writer was just writing.\n    if (startTxId \u003d\u003d curSegmentTxId) {\n      if (curSegment !\u003d null) {\n        curSegment.close();\n        curSegment \u003d null;\n        curSegmentTxId \u003d HdfsServerConstants.INVALID_TXID;\n      }\n      \n      checkSync(nextTxId \u003d\u003d endTxId + 1,\n          \"Trying to finalize in-progress log segment %s to end at \" +\n          \"txid %s but only written up to txid %s ; journal id: %s\",\n          startTxId, endTxId, nextTxId - 1, journalId);\n      // No need to validate the edit log if the client is finalizing\n      // the log segment that it was just writing to.\n      needsValidation \u003d false;\n    }\n    \n    FileJournalManager.EditLogFile elf \u003d fjm.getLogFile(startTxId);\n    if (elf \u003d\u003d null) {\n      throw new JournalOutOfSyncException(\"No log file to finalize at \" +\n          \"transaction ID \" + startTxId + \" ; journal id: \" + journalId);\n    }\n\n    if (elf.isInProgress()) {\n      if (needsValidation) {\n        LOG.info(\"Validating log segment \" + elf.getFile() + \" about to be \" +\n            \"finalized ; journal id: \" + journalId);\n        elf.scanLog(Long.MAX_VALUE, false);\n  \n        checkSync(elf.getLastTxId() \u003d\u003d endTxId,\n            \"Trying to finalize in-progress log segment %s to end at \" +\n            \"txid %s but log %s on disk only contains up to txid %s \" +\n            \"; journal id: %s\",\n            startTxId, endTxId, elf.getFile(), elf.getLastTxId(), journalId);\n      }\n      fjm.finalizeLogSegment(startTxId, endTxId);\n    } else {\n      Preconditions.checkArgument(endTxId \u003d\u003d elf.getLastTxId(),\n          \"Trying to re-finalize already finalized log \" +\n              elf + \" with different endTxId \" + endTxId +\n              \" ; journal id: \" + journalId);\n    }\n\n    // Once logs are finalized, a different length will never be decided.\n    // During recovery, we treat a finalized segment the same as an accepted\n    // recovery. Thus, we no longer need to keep track of the previously-\n    // accepted decision. The existence of the finalized log segment is enough.\n    purgePaxosDecision(elf.getFirstTxId());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/qjournal/server/Journal.java",
      "extendedDetails": {}
    },
    "53bad4eb008ec553dcdbe01e7ae975dcecde6590": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8996. Consolidate validateLog and scanLog in FJM#EditLogFile (Zhe Zhang via Colin P. McCabe)\n",
      "commitDate": "14/09/15 3:22 PM",
      "commitName": "53bad4eb008ec553dcdbe01e7ae975dcecde6590",
      "commitAuthor": "Colin Patrick Mccabe",
      "commitDateOld": "08/09/15 10:33 PM",
      "commitNameOld": "94cf7ab9d28a885181afeb2c181dfe857d158254",
      "commitAuthorOld": "Vinayakumar B",
      "daysBetweenCommits": 5.7,
      "commitsBetweenForRepo": 32,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,54 @@\n   public synchronized void finalizeLogSegment(RequestInfo reqInfo, long startTxId,\n       long endTxId) throws IOException {\n     checkFormatted();\n     checkRequest(reqInfo);\n \n     boolean needsValidation \u003d true;\n \n     // Finalizing the log that the writer was just writing.\n     if (startTxId \u003d\u003d curSegmentTxId) {\n       if (curSegment !\u003d null) {\n         curSegment.close();\n         curSegment \u003d null;\n         curSegmentTxId \u003d HdfsServerConstants.INVALID_TXID;\n       }\n       \n       checkSync(nextTxId \u003d\u003d endTxId + 1,\n           \"Trying to finalize in-progress log segment %s to end at \" +\n           \"txid %s but only written up to txid %s\",\n           startTxId, endTxId, nextTxId - 1);\n       // No need to validate the edit log if the client is finalizing\n       // the log segment that it was just writing to.\n       needsValidation \u003d false;\n     }\n     \n     FileJournalManager.EditLogFile elf \u003d fjm.getLogFile(startTxId);\n     if (elf \u003d\u003d null) {\n       throw new JournalOutOfSyncException(\"No log file to finalize at \" +\n           \"transaction ID \" + startTxId);\n     }\n \n     if (elf.isInProgress()) {\n       if (needsValidation) {\n         LOG.info(\"Validating log segment \" + elf.getFile() + \" about to be \" +\n             \"finalized\");\n-        elf.scanLog();\n+        elf.scanLog(Long.MAX_VALUE, false);\n   \n         checkSync(elf.getLastTxId() \u003d\u003d endTxId,\n             \"Trying to finalize in-progress log segment %s to end at \" +\n             \"txid %s but log %s on disk only contains up to txid %s\",\n             startTxId, endTxId, elf.getFile(), elf.getLastTxId());\n       }\n       fjm.finalizeLogSegment(startTxId, endTxId);\n     } else {\n       Preconditions.checkArgument(endTxId \u003d\u003d elf.getLastTxId(),\n           \"Trying to re-finalize already finalized log \" +\n               elf + \" with different endTxId \" + endTxId);\n     }\n \n     // Once logs are finalized, a different length will never be decided.\n     // During recovery, we treat a finalized segment the same as an accepted\n     // recovery. Thus, we no longer need to keep track of the previously-\n     // accepted decision. The existence of the finalized log segment is enough.\n     purgePaxosDecision(elf.getFirstTxId());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void finalizeLogSegment(RequestInfo reqInfo, long startTxId,\n      long endTxId) throws IOException {\n    checkFormatted();\n    checkRequest(reqInfo);\n\n    boolean needsValidation \u003d true;\n\n    // Finalizing the log that the writer was just writing.\n    if (startTxId \u003d\u003d curSegmentTxId) {\n      if (curSegment !\u003d null) {\n        curSegment.close();\n        curSegment \u003d null;\n        curSegmentTxId \u003d HdfsServerConstants.INVALID_TXID;\n      }\n      \n      checkSync(nextTxId \u003d\u003d endTxId + 1,\n          \"Trying to finalize in-progress log segment %s to end at \" +\n          \"txid %s but only written up to txid %s\",\n          startTxId, endTxId, nextTxId - 1);\n      // No need to validate the edit log if the client is finalizing\n      // the log segment that it was just writing to.\n      needsValidation \u003d false;\n    }\n    \n    FileJournalManager.EditLogFile elf \u003d fjm.getLogFile(startTxId);\n    if (elf \u003d\u003d null) {\n      throw new JournalOutOfSyncException(\"No log file to finalize at \" +\n          \"transaction ID \" + startTxId);\n    }\n\n    if (elf.isInProgress()) {\n      if (needsValidation) {\n        LOG.info(\"Validating log segment \" + elf.getFile() + \" about to be \" +\n            \"finalized\");\n        elf.scanLog(Long.MAX_VALUE, false);\n  \n        checkSync(elf.getLastTxId() \u003d\u003d endTxId,\n            \"Trying to finalize in-progress log segment %s to end at \" +\n            \"txid %s but log %s on disk only contains up to txid %s\",\n            startTxId, endTxId, elf.getFile(), elf.getLastTxId());\n      }\n      fjm.finalizeLogSegment(startTxId, endTxId);\n    } else {\n      Preconditions.checkArgument(endTxId \u003d\u003d elf.getLastTxId(),\n          \"Trying to re-finalize already finalized log \" +\n              elf + \" with different endTxId \" + endTxId);\n    }\n\n    // Once logs are finalized, a different length will never be decided.\n    // During recovery, we treat a finalized segment the same as an accepted\n    // recovery. Thus, we no longer need to keep track of the previously-\n    // accepted decision. The existence of the finalized log segment is enough.\n    purgePaxosDecision(elf.getFirstTxId());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/qjournal/server/Journal.java",
      "extendedDetails": {}
    },
    "6ae2a0d048e133b43249c248a75a4d77d9abb80d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8249. Separate HdfsConstants into the client and the server side class. Contributed by Haohui Mai.\n",
      "commitDate": "02/05/15 10:03 AM",
      "commitName": "6ae2a0d048e133b43249c248a75a4d77d9abb80d",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "08/01/15 4:09 PM",
      "commitNameOld": "ae91b13a4b1896b893268253104f935c3078d345",
      "commitAuthorOld": "Colin Patrick Mccabe",
      "daysBetweenCommits": 113.7,
      "commitsBetweenForRepo": 1004,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,54 @@\n   public synchronized void finalizeLogSegment(RequestInfo reqInfo, long startTxId,\n       long endTxId) throws IOException {\n     checkFormatted();\n     checkRequest(reqInfo);\n \n     boolean needsValidation \u003d true;\n \n     // Finalizing the log that the writer was just writing.\n     if (startTxId \u003d\u003d curSegmentTxId) {\n       if (curSegment !\u003d null) {\n         curSegment.close();\n         curSegment \u003d null;\n-        curSegmentTxId \u003d HdfsConstants.INVALID_TXID;\n+        curSegmentTxId \u003d HdfsServerConstants.INVALID_TXID;\n       }\n       \n       checkSync(nextTxId \u003d\u003d endTxId + 1,\n           \"Trying to finalize in-progress log segment %s to end at \" +\n           \"txid %s but only written up to txid %s\",\n           startTxId, endTxId, nextTxId - 1);\n       // No need to validate the edit log if the client is finalizing\n       // the log segment that it was just writing to.\n       needsValidation \u003d false;\n     }\n     \n     FileJournalManager.EditLogFile elf \u003d fjm.getLogFile(startTxId);\n     if (elf \u003d\u003d null) {\n       throw new JournalOutOfSyncException(\"No log file to finalize at \" +\n           \"transaction ID \" + startTxId);\n     }\n \n     if (elf.isInProgress()) {\n       if (needsValidation) {\n         LOG.info(\"Validating log segment \" + elf.getFile() + \" about to be \" +\n             \"finalized\");\n         elf.scanLog();\n   \n         checkSync(elf.getLastTxId() \u003d\u003d endTxId,\n             \"Trying to finalize in-progress log segment %s to end at \" +\n             \"txid %s but log %s on disk only contains up to txid %s\",\n             startTxId, endTxId, elf.getFile(), elf.getLastTxId());\n       }\n       fjm.finalizeLogSegment(startTxId, endTxId);\n     } else {\n       Preconditions.checkArgument(endTxId \u003d\u003d elf.getLastTxId(),\n           \"Trying to re-finalize already finalized log \" +\n               elf + \" with different endTxId \" + endTxId);\n     }\n \n     // Once logs are finalized, a different length will never be decided.\n     // During recovery, we treat a finalized segment the same as an accepted\n     // recovery. Thus, we no longer need to keep track of the previously-\n     // accepted decision. The existence of the finalized log segment is enough.\n     purgePaxosDecision(elf.getFirstTxId());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void finalizeLogSegment(RequestInfo reqInfo, long startTxId,\n      long endTxId) throws IOException {\n    checkFormatted();\n    checkRequest(reqInfo);\n\n    boolean needsValidation \u003d true;\n\n    // Finalizing the log that the writer was just writing.\n    if (startTxId \u003d\u003d curSegmentTxId) {\n      if (curSegment !\u003d null) {\n        curSegment.close();\n        curSegment \u003d null;\n        curSegmentTxId \u003d HdfsServerConstants.INVALID_TXID;\n      }\n      \n      checkSync(nextTxId \u003d\u003d endTxId + 1,\n          \"Trying to finalize in-progress log segment %s to end at \" +\n          \"txid %s but only written up to txid %s\",\n          startTxId, endTxId, nextTxId - 1);\n      // No need to validate the edit log if the client is finalizing\n      // the log segment that it was just writing to.\n      needsValidation \u003d false;\n    }\n    \n    FileJournalManager.EditLogFile elf \u003d fjm.getLogFile(startTxId);\n    if (elf \u003d\u003d null) {\n      throw new JournalOutOfSyncException(\"No log file to finalize at \" +\n          \"transaction ID \" + startTxId);\n    }\n\n    if (elf.isInProgress()) {\n      if (needsValidation) {\n        LOG.info(\"Validating log segment \" + elf.getFile() + \" about to be \" +\n            \"finalized\");\n        elf.scanLog();\n  \n        checkSync(elf.getLastTxId() \u003d\u003d endTxId,\n            \"Trying to finalize in-progress log segment %s to end at \" +\n            \"txid %s but log %s on disk only contains up to txid %s\",\n            startTxId, endTxId, elf.getFile(), elf.getLastTxId());\n      }\n      fjm.finalizeLogSegment(startTxId, endTxId);\n    } else {\n      Preconditions.checkArgument(endTxId \u003d\u003d elf.getLastTxId(),\n          \"Trying to re-finalize already finalized log \" +\n              elf + \" with different endTxId \" + endTxId);\n    }\n\n    // Once logs are finalized, a different length will never be decided.\n    // During recovery, we treat a finalized segment the same as an accepted\n    // recovery. Thus, we no longer need to keep track of the previously-\n    // accepted decision. The existence of the finalized log segment is enough.\n    purgePaxosDecision(elf.getFirstTxId());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/qjournal/server/Journal.java",
      "extendedDetails": {}
    },
    "9dab514b22f49322738935cfd915c2b4eba50b88": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6038. Allow JournalNode to handle editlog produced by new release with future layoutversion. Contributed by Jing Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1579813 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "20/03/14 4:06 PM",
      "commitName": "9dab514b22f49322738935cfd915c2b4eba50b88",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "20/02/14 3:21 PM",
      "commitNameOld": "329c7051817c956bfc64661f4e1349b7009a2747",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 27.99,
      "commitsBetweenForRepo": 248,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,54 @@\n   public synchronized void finalizeLogSegment(RequestInfo reqInfo, long startTxId,\n       long endTxId) throws IOException {\n     checkFormatted();\n     checkRequest(reqInfo);\n \n     boolean needsValidation \u003d true;\n \n     // Finalizing the log that the writer was just writing.\n     if (startTxId \u003d\u003d curSegmentTxId) {\n       if (curSegment !\u003d null) {\n         curSegment.close();\n         curSegment \u003d null;\n         curSegmentTxId \u003d HdfsConstants.INVALID_TXID;\n       }\n       \n       checkSync(nextTxId \u003d\u003d endTxId + 1,\n           \"Trying to finalize in-progress log segment %s to end at \" +\n           \"txid %s but only written up to txid %s\",\n           startTxId, endTxId, nextTxId - 1);\n       // No need to validate the edit log if the client is finalizing\n       // the log segment that it was just writing to.\n       needsValidation \u003d false;\n     }\n     \n     FileJournalManager.EditLogFile elf \u003d fjm.getLogFile(startTxId);\n     if (elf \u003d\u003d null) {\n       throw new JournalOutOfSyncException(\"No log file to finalize at \" +\n           \"transaction ID \" + startTxId);\n     }\n \n     if (elf.isInProgress()) {\n       if (needsValidation) {\n         LOG.info(\"Validating log segment \" + elf.getFile() + \" about to be \" +\n             \"finalized\");\n-        elf.validateLog();\n+        elf.scanLog();\n   \n         checkSync(elf.getLastTxId() \u003d\u003d endTxId,\n             \"Trying to finalize in-progress log segment %s to end at \" +\n             \"txid %s but log %s on disk only contains up to txid %s\",\n             startTxId, endTxId, elf.getFile(), elf.getLastTxId());\n       }\n       fjm.finalizeLogSegment(startTxId, endTxId);\n     } else {\n       Preconditions.checkArgument(endTxId \u003d\u003d elf.getLastTxId(),\n           \"Trying to re-finalize already finalized log \" +\n               elf + \" with different endTxId \" + endTxId);\n     }\n \n     // Once logs are finalized, a different length will never be decided.\n     // During recovery, we treat a finalized segment the same as an accepted\n     // recovery. Thus, we no longer need to keep track of the previously-\n     // accepted decision. The existence of the finalized log segment is enough.\n     purgePaxosDecision(elf.getFirstTxId());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void finalizeLogSegment(RequestInfo reqInfo, long startTxId,\n      long endTxId) throws IOException {\n    checkFormatted();\n    checkRequest(reqInfo);\n\n    boolean needsValidation \u003d true;\n\n    // Finalizing the log that the writer was just writing.\n    if (startTxId \u003d\u003d curSegmentTxId) {\n      if (curSegment !\u003d null) {\n        curSegment.close();\n        curSegment \u003d null;\n        curSegmentTxId \u003d HdfsConstants.INVALID_TXID;\n      }\n      \n      checkSync(nextTxId \u003d\u003d endTxId + 1,\n          \"Trying to finalize in-progress log segment %s to end at \" +\n          \"txid %s but only written up to txid %s\",\n          startTxId, endTxId, nextTxId - 1);\n      // No need to validate the edit log if the client is finalizing\n      // the log segment that it was just writing to.\n      needsValidation \u003d false;\n    }\n    \n    FileJournalManager.EditLogFile elf \u003d fjm.getLogFile(startTxId);\n    if (elf \u003d\u003d null) {\n      throw new JournalOutOfSyncException(\"No log file to finalize at \" +\n          \"transaction ID \" + startTxId);\n    }\n\n    if (elf.isInProgress()) {\n      if (needsValidation) {\n        LOG.info(\"Validating log segment \" + elf.getFile() + \" about to be \" +\n            \"finalized\");\n        elf.scanLog();\n  \n        checkSync(elf.getLastTxId() \u003d\u003d endTxId,\n            \"Trying to finalize in-progress log segment %s to end at \" +\n            \"txid %s but log %s on disk only contains up to txid %s\",\n            startTxId, endTxId, elf.getFile(), elf.getLastTxId());\n      }\n      fjm.finalizeLogSegment(startTxId, endTxId);\n    } else {\n      Preconditions.checkArgument(endTxId \u003d\u003d elf.getLastTxId(),\n          \"Trying to re-finalize already finalized log \" +\n              elf + \" with different endTxId \" + endTxId);\n    }\n\n    // Once logs are finalized, a different length will never be decided.\n    // During recovery, we treat a finalized segment the same as an accepted\n    // recovery. Thus, we no longer need to keep track of the previously-\n    // accepted decision. The existence of the finalized log segment is enough.\n    purgePaxosDecision(elf.getFirstTxId());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/qjournal/server/Journal.java",
      "extendedDetails": {}
    },
    "60c20e559b8036410e2d9081b9c60d1e04e56253": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3900. QJM: avoid validating log segments on log rolls. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-3077@1383041 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/09/12 11:53 AM",
      "commitName": "60c20e559b8036410e2d9081b9c60d1e04e56253",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "10/09/12 11:51 AM",
      "commitNameOld": "ca4582222e89114e4c61d38fbf973a66d2867abf",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,54 @@\n   public synchronized void finalizeLogSegment(RequestInfo reqInfo, long startTxId,\n       long endTxId) throws IOException {\n     checkFormatted();\n     checkRequest(reqInfo);\n \n+    boolean needsValidation \u003d true;\n+\n+    // Finalizing the log that the writer was just writing.\n     if (startTxId \u003d\u003d curSegmentTxId) {\n       if (curSegment !\u003d null) {\n         curSegment.close();\n         curSegment \u003d null;\n+        curSegmentTxId \u003d HdfsConstants.INVALID_TXID;\n       }\n+      \n+      checkSync(nextTxId \u003d\u003d endTxId + 1,\n+          \"Trying to finalize in-progress log segment %s to end at \" +\n+          \"txid %s but only written up to txid %s\",\n+          startTxId, endTxId, nextTxId - 1);\n+      // No need to validate the edit log if the client is finalizing\n+      // the log segment that it was just writing to.\n+      needsValidation \u003d false;\n     }\n     \n     FileJournalManager.EditLogFile elf \u003d fjm.getLogFile(startTxId);\n     if (elf \u003d\u003d null) {\n       throw new JournalOutOfSyncException(\"No log file to finalize at \" +\n           \"transaction ID \" + startTxId);\n     }\n \n     if (elf.isInProgress()) {\n-      // TODO: this is slow to validate when in non-recovery cases\n-      // we already know the length here!\n-\n-      LOG.info(\"Validating log about to be finalized: \" + elf);\n-      elf.validateLog();\n-\n-      checkSync(elf.getLastTxId() \u003d\u003d endTxId,\n-          \"Trying to finalize log %s-%s, but current state of log \" +\n-          \"is %s\", startTxId, endTxId, elf);\n+      if (needsValidation) {\n+        LOG.info(\"Validating log segment \" + elf.getFile() + \" about to be \" +\n+            \"finalized\");\n+        elf.validateLog();\n+  \n+        checkSync(elf.getLastTxId() \u003d\u003d endTxId,\n+            \"Trying to finalize in-progress log segment %s to end at \" +\n+            \"txid %s but log %s on disk only contains up to txid %s\",\n+            startTxId, endTxId, elf.getFile(), elf.getLastTxId());\n+      }\n       fjm.finalizeLogSegment(startTxId, endTxId);\n     } else {\n       Preconditions.checkArgument(endTxId \u003d\u003d elf.getLastTxId(),\n           \"Trying to re-finalize already finalized log \" +\n               elf + \" with different endTxId \" + endTxId);\n     }\n \n     // Once logs are finalized, a different length will never be decided.\n     // During recovery, we treat a finalized segment the same as an accepted\n     // recovery. Thus, we no longer need to keep track of the previously-\n     // accepted decision. The existence of the finalized log segment is enough.\n     purgePaxosDecision(elf.getFirstTxId());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void finalizeLogSegment(RequestInfo reqInfo, long startTxId,\n      long endTxId) throws IOException {\n    checkFormatted();\n    checkRequest(reqInfo);\n\n    boolean needsValidation \u003d true;\n\n    // Finalizing the log that the writer was just writing.\n    if (startTxId \u003d\u003d curSegmentTxId) {\n      if (curSegment !\u003d null) {\n        curSegment.close();\n        curSegment \u003d null;\n        curSegmentTxId \u003d HdfsConstants.INVALID_TXID;\n      }\n      \n      checkSync(nextTxId \u003d\u003d endTxId + 1,\n          \"Trying to finalize in-progress log segment %s to end at \" +\n          \"txid %s but only written up to txid %s\",\n          startTxId, endTxId, nextTxId - 1);\n      // No need to validate the edit log if the client is finalizing\n      // the log segment that it was just writing to.\n      needsValidation \u003d false;\n    }\n    \n    FileJournalManager.EditLogFile elf \u003d fjm.getLogFile(startTxId);\n    if (elf \u003d\u003d null) {\n      throw new JournalOutOfSyncException(\"No log file to finalize at \" +\n          \"transaction ID \" + startTxId);\n    }\n\n    if (elf.isInProgress()) {\n      if (needsValidation) {\n        LOG.info(\"Validating log segment \" + elf.getFile() + \" about to be \" +\n            \"finalized\");\n        elf.validateLog();\n  \n        checkSync(elf.getLastTxId() \u003d\u003d endTxId,\n            \"Trying to finalize in-progress log segment %s to end at \" +\n            \"txid %s but log %s on disk only contains up to txid %s\",\n            startTxId, endTxId, elf.getFile(), elf.getLastTxId());\n      }\n      fjm.finalizeLogSegment(startTxId, endTxId);\n    } else {\n      Preconditions.checkArgument(endTxId \u003d\u003d elf.getLastTxId(),\n          \"Trying to re-finalize already finalized log \" +\n              elf + \" with different endTxId \" + endTxId);\n    }\n\n    // Once logs are finalized, a different length will never be decided.\n    // During recovery, we treat a finalized segment the same as an accepted\n    // recovery. Thus, we no longer need to keep track of the previously-\n    // accepted decision. The existence of the finalized log segment is enough.\n    purgePaxosDecision(elf.getFirstTxId());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/qjournal/server/Journal.java",
      "extendedDetails": {}
    },
    "cae8116a146cb27d40e4e41cece9a17945bc7f9c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3726. If a logger misses an RPC, don\u0027t retry that logger until next segment. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-3077@1381482 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "06/09/12 12:03 AM",
      "commitName": "cae8116a146cb27d40e4e41cece9a17945bc7f9c",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "04/09/12 9:30 PM",
      "commitNameOld": "13daca1ef6aa4a24ff9a840397dda1bbddb16e37",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 1.11,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,41 @@\n   public synchronized void finalizeLogSegment(RequestInfo reqInfo, long startTxId,\n       long endTxId) throws IOException {\n     checkFormatted();\n     checkRequest(reqInfo);\n \n     if (startTxId \u003d\u003d curSegmentTxId) {\n       if (curSegment !\u003d null) {\n         curSegment.close();\n         curSegment \u003d null;\n       }\n     }\n     \n     FileJournalManager.EditLogFile elf \u003d fjm.getLogFile(startTxId);\n     if (elf \u003d\u003d null) {\n-      throw new IllegalStateException(\"No log file to finalize at \" +\n+      throw new JournalOutOfSyncException(\"No log file to finalize at \" +\n           \"transaction ID \" + startTxId);\n     }\n \n     if (elf.isInProgress()) {\n       // TODO: this is slow to validate when in non-recovery cases\n       // we already know the length here!\n \n       LOG.info(\"Validating log about to be finalized: \" + elf);\n       elf.validateLog();\n-      \n-      Preconditions.checkState(elf.getLastTxId() \u003d\u003d endTxId,\n+\n+      checkSync(elf.getLastTxId() \u003d\u003d endTxId,\n           \"Trying to finalize log %s-%s, but current state of log \" +\n           \"is %s\", startTxId, endTxId, elf);\n       fjm.finalizeLogSegment(startTxId, endTxId);\n     } else {\n       Preconditions.checkArgument(endTxId \u003d\u003d elf.getLastTxId(),\n           \"Trying to re-finalize already finalized log \" +\n               elf + \" with different endTxId \" + endTxId);\n     }\n \n     // Once logs are finalized, a different length will never be decided.\n     // During recovery, we treat a finalized segment the same as an accepted\n     // recovery. Thus, we no longer need to keep track of the previously-\n     // accepted decision. The existence of the finalized log segment is enough.\n     purgePaxosDecision(elf.getFirstTxId());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void finalizeLogSegment(RequestInfo reqInfo, long startTxId,\n      long endTxId) throws IOException {\n    checkFormatted();\n    checkRequest(reqInfo);\n\n    if (startTxId \u003d\u003d curSegmentTxId) {\n      if (curSegment !\u003d null) {\n        curSegment.close();\n        curSegment \u003d null;\n      }\n    }\n    \n    FileJournalManager.EditLogFile elf \u003d fjm.getLogFile(startTxId);\n    if (elf \u003d\u003d null) {\n      throw new JournalOutOfSyncException(\"No log file to finalize at \" +\n          \"transaction ID \" + startTxId);\n    }\n\n    if (elf.isInProgress()) {\n      // TODO: this is slow to validate when in non-recovery cases\n      // we already know the length here!\n\n      LOG.info(\"Validating log about to be finalized: \" + elf);\n      elf.validateLog();\n\n      checkSync(elf.getLastTxId() \u003d\u003d endTxId,\n          \"Trying to finalize log %s-%s, but current state of log \" +\n          \"is %s\", startTxId, endTxId, elf);\n      fjm.finalizeLogSegment(startTxId, endTxId);\n    } else {\n      Preconditions.checkArgument(endTxId \u003d\u003d elf.getLastTxId(),\n          \"Trying to re-finalize already finalized log \" +\n              elf + \" with different endTxId \" + endTxId);\n    }\n\n    // Once logs are finalized, a different length will never be decided.\n    // During recovery, we treat a finalized segment the same as an accepted\n    // recovery. Thus, we no longer need to keep track of the previously-\n    // accepted decision. The existence of the finalized log segment is enough.\n    purgePaxosDecision(elf.getFirstTxId());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/qjournal/server/Journal.java",
      "extendedDetails": {}
    },
    "8021d9199f278345aca6211f318145342ad036f4": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3863. Track last \"committed\" txid in QJM. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-3077@1380976 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/09/12 9:13 PM",
      "commitName": "8021d9199f278345aca6211f318145342ad036f4",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "27/08/12 12:55 PM",
      "commitNameOld": "1e68d4726b225fb4a62eb8d79a3160dd03059ccb",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 8.35,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,41 @@\n   public synchronized void finalizeLogSegment(RequestInfo reqInfo, long startTxId,\n       long endTxId) throws IOException {\n-    checkRequest(reqInfo);\n     checkFormatted();\n+    checkRequest(reqInfo);\n \n     if (startTxId \u003d\u003d curSegmentTxId) {\n       if (curSegment !\u003d null) {\n         curSegment.close();\n         curSegment \u003d null;\n       }\n     }\n     \n     FileJournalManager.EditLogFile elf \u003d fjm.getLogFile(startTxId);\n     if (elf \u003d\u003d null) {\n       throw new IllegalStateException(\"No log file to finalize at \" +\n           \"transaction ID \" + startTxId);\n     }\n \n     if (elf.isInProgress()) {\n       // TODO: this is slow to validate when in non-recovery cases\n       // we already know the length here!\n \n       LOG.info(\"Validating log about to be finalized: \" + elf);\n       elf.validateLog();\n       \n       Preconditions.checkState(elf.getLastTxId() \u003d\u003d endTxId,\n           \"Trying to finalize log %s-%s, but current state of log \" +\n           \"is %s\", startTxId, endTxId, elf);\n       fjm.finalizeLogSegment(startTxId, endTxId);\n     } else {\n       Preconditions.checkArgument(endTxId \u003d\u003d elf.getLastTxId(),\n           \"Trying to re-finalize already finalized log \" +\n               elf + \" with different endTxId \" + endTxId);\n     }\n \n     // Once logs are finalized, a different length will never be decided.\n     // During recovery, we treat a finalized segment the same as an accepted\n     // recovery. Thus, we no longer need to keep track of the previously-\n     // accepted decision. The existence of the finalized log segment is enough.\n     purgePaxosDecision(elf.getFirstTxId());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void finalizeLogSegment(RequestInfo reqInfo, long startTxId,\n      long endTxId) throws IOException {\n    checkFormatted();\n    checkRequest(reqInfo);\n\n    if (startTxId \u003d\u003d curSegmentTxId) {\n      if (curSegment !\u003d null) {\n        curSegment.close();\n        curSegment \u003d null;\n      }\n    }\n    \n    FileJournalManager.EditLogFile elf \u003d fjm.getLogFile(startTxId);\n    if (elf \u003d\u003d null) {\n      throw new IllegalStateException(\"No log file to finalize at \" +\n          \"transaction ID \" + startTxId);\n    }\n\n    if (elf.isInProgress()) {\n      // TODO: this is slow to validate when in non-recovery cases\n      // we already know the length here!\n\n      LOG.info(\"Validating log about to be finalized: \" + elf);\n      elf.validateLog();\n      \n      Preconditions.checkState(elf.getLastTxId() \u003d\u003d endTxId,\n          \"Trying to finalize log %s-%s, but current state of log \" +\n          \"is %s\", startTxId, endTxId, elf);\n      fjm.finalizeLogSegment(startTxId, endTxId);\n    } else {\n      Preconditions.checkArgument(endTxId \u003d\u003d elf.getLastTxId(),\n          \"Trying to re-finalize already finalized log \" +\n              elf + \" with different endTxId \" + endTxId);\n    }\n\n    // Once logs are finalized, a different length will never be decided.\n    // During recovery, we treat a finalized segment the same as an accepted\n    // recovery. Thus, we no longer need to keep track of the previously-\n    // accepted decision. The existence of the finalized log segment is enough.\n    purgePaxosDecision(elf.getFirstTxId());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/qjournal/server/Journal.java",
      "extendedDetails": {}
    },
    "1e68d4726b225fb4a62eb8d79a3160dd03059ccb": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3845. Fixes for edge cases in QJM recovery protocol. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-3077@1377809 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/08/12 12:55 PM",
      "commitName": "1e68d4726b225fb4a62eb8d79a3160dd03059ccb",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "15/08/12 11:58 AM",
      "commitNameOld": "42cdc1b0835abb4a331d40f30f2c210143b747bc",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 12.04,
      "commitsBetweenForRepo": 78,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,41 @@\n   public synchronized void finalizeLogSegment(RequestInfo reqInfo, long startTxId,\n       long endTxId) throws IOException {\n     checkRequest(reqInfo);\n     checkFormatted();\n \n     if (startTxId \u003d\u003d curSegmentTxId) {\n       if (curSegment !\u003d null) {\n         curSegment.close();\n         curSegment \u003d null;\n       }\n     }\n     \n     FileJournalManager.EditLogFile elf \u003d fjm.getLogFile(startTxId);\n     if (elf \u003d\u003d null) {\n       throw new IllegalStateException(\"No log file to finalize at \" +\n           \"transaction ID \" + startTxId);\n     }\n \n     if (elf.isInProgress()) {\n       // TODO: this is slow to validate when in non-recovery cases\n       // we already know the length here!\n \n       LOG.info(\"Validating log about to be finalized: \" + elf);\n       elf.validateLog();\n       \n       Preconditions.checkState(elf.getLastTxId() \u003d\u003d endTxId,\n           \"Trying to finalize log %s-%s, but current state of log \" +\n           \"is %s\", startTxId, endTxId, elf);\n       fjm.finalizeLogSegment(startTxId, endTxId);\n     } else {\n       Preconditions.checkArgument(endTxId \u003d\u003d elf.getLastTxId(),\n           \"Trying to re-finalize already finalized log \" +\n               elf + \" with different endTxId \" + endTxId);\n     }\n+\n+    // Once logs are finalized, a different length will never be decided.\n+    // During recovery, we treat a finalized segment the same as an accepted\n+    // recovery. Thus, we no longer need to keep track of the previously-\n+    // accepted decision. The existence of the finalized log segment is enough.\n+    purgePaxosDecision(elf.getFirstTxId());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void finalizeLogSegment(RequestInfo reqInfo, long startTxId,\n      long endTxId) throws IOException {\n    checkRequest(reqInfo);\n    checkFormatted();\n\n    if (startTxId \u003d\u003d curSegmentTxId) {\n      if (curSegment !\u003d null) {\n        curSegment.close();\n        curSegment \u003d null;\n      }\n    }\n    \n    FileJournalManager.EditLogFile elf \u003d fjm.getLogFile(startTxId);\n    if (elf \u003d\u003d null) {\n      throw new IllegalStateException(\"No log file to finalize at \" +\n          \"transaction ID \" + startTxId);\n    }\n\n    if (elf.isInProgress()) {\n      // TODO: this is slow to validate when in non-recovery cases\n      // we already know the length here!\n\n      LOG.info(\"Validating log about to be finalized: \" + elf);\n      elf.validateLog();\n      \n      Preconditions.checkState(elf.getLastTxId() \u003d\u003d endTxId,\n          \"Trying to finalize log %s-%s, but current state of log \" +\n          \"is %s\", startTxId, endTxId, elf);\n      fjm.finalizeLogSegment(startTxId, endTxId);\n    } else {\n      Preconditions.checkArgument(endTxId \u003d\u003d elf.getLastTxId(),\n          \"Trying to re-finalize already finalized log \" +\n              elf + \" with different endTxId \" + endTxId);\n    }\n\n    // Once logs are finalized, a different length will never be decided.\n    // During recovery, we treat a finalized segment the same as an accepted\n    // recovery. Thus, we no longer need to keep track of the previously-\n    // accepted decision. The existence of the finalized log segment is enough.\n    purgePaxosDecision(elf.getFirstTxId());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/qjournal/server/Journal.java",
      "extendedDetails": {}
    },
    "4a9b3c693def87579298fb59b7df0b8892a3508e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3798. Avoid throwing NPE when finalizeSegment() is called on invalid segment. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-3077@1373179 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/08/12 5:54 PM",
      "commitName": "4a9b3c693def87579298fb59b7df0b8892a3508e",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "14/08/12 5:48 PM",
      "commitNameOld": "f765fdb65701e61887daedb2b369af4be12cb432",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,30 +1,35 @@\n   public synchronized void finalizeLogSegment(RequestInfo reqInfo, long startTxId,\n       long endTxId) throws IOException {\n     checkRequest(reqInfo);\n     checkFormatted();\n \n     if (startTxId \u003d\u003d curSegmentTxId) {\n       if (curSegment !\u003d null) {\n         curSegment.close();\n         curSegment \u003d null;\n       }\n     }\n     \n     FileJournalManager.EditLogFile elf \u003d fjm.getLogFile(startTxId);\n+    if (elf \u003d\u003d null) {\n+      throw new IllegalStateException(\"No log file to finalize at \" +\n+          \"transaction ID \" + startTxId);\n+    }\n+\n     if (elf.isInProgress()) {\n       // TODO: this is slow to validate when in non-recovery cases\n       // we already know the length here!\n \n       LOG.info(\"Validating log about to be finalized: \" + elf);\n       elf.validateLog();\n       \n       Preconditions.checkState(elf.getLastTxId() \u003d\u003d endTxId,\n-          \"Trying to finalize log %s-%s, but current state of log\" +\n+          \"Trying to finalize log %s-%s, but current state of log \" +\n           \"is %s\", startTxId, endTxId, elf);\n       fjm.finalizeLogSegment(startTxId, endTxId);\n     } else {\n       Preconditions.checkArgument(endTxId \u003d\u003d elf.getLastTxId(),\n           \"Trying to re-finalize already finalized log \" +\n               elf + \" with different endTxId \" + endTxId);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void finalizeLogSegment(RequestInfo reqInfo, long startTxId,\n      long endTxId) throws IOException {\n    checkRequest(reqInfo);\n    checkFormatted();\n\n    if (startTxId \u003d\u003d curSegmentTxId) {\n      if (curSegment !\u003d null) {\n        curSegment.close();\n        curSegment \u003d null;\n      }\n    }\n    \n    FileJournalManager.EditLogFile elf \u003d fjm.getLogFile(startTxId);\n    if (elf \u003d\u003d null) {\n      throw new IllegalStateException(\"No log file to finalize at \" +\n          \"transaction ID \" + startTxId);\n    }\n\n    if (elf.isInProgress()) {\n      // TODO: this is slow to validate when in non-recovery cases\n      // we already know the length here!\n\n      LOG.info(\"Validating log about to be finalized: \" + elf);\n      elf.validateLog();\n      \n      Preconditions.checkState(elf.getLastTxId() \u003d\u003d endTxId,\n          \"Trying to finalize log %s-%s, but current state of log \" +\n          \"is %s\", startTxId, endTxId, elf);\n      fjm.finalizeLogSegment(startTxId, endTxId);\n    } else {\n      Preconditions.checkArgument(endTxId \u003d\u003d elf.getLastTxId(),\n          \"Trying to re-finalize already finalized log \" +\n              elf + \" with different endTxId \" + endTxId);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/qjournal/server/Journal.java",
      "extendedDetails": {}
    },
    "f765fdb65701e61887daedb2b369af4be12cb432": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3793. Implement genericized format() in QJM. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-3077@1373177 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/08/12 5:48 PM",
      "commitName": "f765fdb65701e61887daedb2b369af4be12cb432",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "25/07/12 2:47 PM",
      "commitNameOld": "b17018e4b821ec860144d8bd38bc1fcb0d7eeaa5",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 20.13,
      "commitsBetweenForRepo": 82,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,30 @@\n   public synchronized void finalizeLogSegment(RequestInfo reqInfo, long startTxId,\n       long endTxId) throws IOException {\n     checkRequest(reqInfo);\n+    checkFormatted();\n \n     if (startTxId \u003d\u003d curSegmentTxId) {\n       if (curSegment !\u003d null) {\n         curSegment.close();\n         curSegment \u003d null;\n       }\n     }\n     \n     FileJournalManager.EditLogFile elf \u003d fjm.getLogFile(startTxId);\n     if (elf.isInProgress()) {\n       // TODO: this is slow to validate when in non-recovery cases\n       // we already know the length here!\n \n       LOG.info(\"Validating log about to be finalized: \" + elf);\n       elf.validateLog();\n       \n       Preconditions.checkState(elf.getLastTxId() \u003d\u003d endTxId,\n           \"Trying to finalize log %s-%s, but current state of log\" +\n           \"is %s\", startTxId, endTxId, elf);\n       fjm.finalizeLogSegment(startTxId, endTxId);\n     } else {\n       Preconditions.checkArgument(endTxId \u003d\u003d elf.getLastTxId(),\n           \"Trying to re-finalize already finalized log \" +\n               elf + \" with different endTxId \" + endTxId);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void finalizeLogSegment(RequestInfo reqInfo, long startTxId,\n      long endTxId) throws IOException {\n    checkRequest(reqInfo);\n    checkFormatted();\n\n    if (startTxId \u003d\u003d curSegmentTxId) {\n      if (curSegment !\u003d null) {\n        curSegment.close();\n        curSegment \u003d null;\n      }\n    }\n    \n    FileJournalManager.EditLogFile elf \u003d fjm.getLogFile(startTxId);\n    if (elf.isInProgress()) {\n      // TODO: this is slow to validate when in non-recovery cases\n      // we already know the length here!\n\n      LOG.info(\"Validating log about to be finalized: \" + elf);\n      elf.validateLog();\n      \n      Preconditions.checkState(elf.getLastTxId() \u003d\u003d endTxId,\n          \"Trying to finalize log %s-%s, but current state of log\" +\n          \"is %s\", startTxId, endTxId, elf);\n      fjm.finalizeLogSegment(startTxId, endTxId);\n    } else {\n      Preconditions.checkArgument(endTxId \u003d\u003d elf.getLastTxId(),\n          \"Trying to re-finalize already finalized log \" +\n              elf + \" with different endTxId \" + endTxId);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/qjournal/server/Journal.java",
      "extendedDetails": {}
    },
    "74d4573a23db5586c6e47ff2277aa7c35237da34": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-3077. Quorum-based protocol for reading and writing edit logs. Contributed by Todd Lipcon based on initial work from Brandon Li and Hari Mankude.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-3077@1363596 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/07/12 5:25 PM",
      "commitName": "74d4573a23db5586c6e47ff2277aa7c35237da34",
      "commitAuthor": "Todd Lipcon",
      "diff": "@@ -0,0 +1,29 @@\n+  public synchronized void finalizeLogSegment(RequestInfo reqInfo, long startTxId,\n+      long endTxId) throws IOException {\n+    checkRequest(reqInfo);\n+\n+    if (startTxId \u003d\u003d curSegmentTxId) {\n+      if (curSegment !\u003d null) {\n+        curSegment.close();\n+        curSegment \u003d null;\n+      }\n+    }\n+    \n+    FileJournalManager.EditLogFile elf \u003d fjm.getLogFile(startTxId);\n+    if (elf.isInProgress()) {\n+      // TODO: this is slow to validate when in non-recovery cases\n+      // we already know the length here!\n+\n+      LOG.info(\"Validating log about to be finalized: \" + elf);\n+      elf.validateLog();\n+      \n+      Preconditions.checkState(elf.getLastTxId() \u003d\u003d endTxId,\n+          \"Trying to finalize log %s-%s, but current state of log\" +\n+          \"is %s\", startTxId, endTxId, elf);\n+      fjm.finalizeLogSegment(startTxId, endTxId);\n+    } else {\n+      Preconditions.checkArgument(endTxId \u003d\u003d elf.getLastTxId(),\n+          \"Trying to re-finalize already finalized log \" +\n+              elf + \" with different endTxId \" + endTxId);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void finalizeLogSegment(RequestInfo reqInfo, long startTxId,\n      long endTxId) throws IOException {\n    checkRequest(reqInfo);\n\n    if (startTxId \u003d\u003d curSegmentTxId) {\n      if (curSegment !\u003d null) {\n        curSegment.close();\n        curSegment \u003d null;\n      }\n    }\n    \n    FileJournalManager.EditLogFile elf \u003d fjm.getLogFile(startTxId);\n    if (elf.isInProgress()) {\n      // TODO: this is slow to validate when in non-recovery cases\n      // we already know the length here!\n\n      LOG.info(\"Validating log about to be finalized: \" + elf);\n      elf.validateLog();\n      \n      Preconditions.checkState(elf.getLastTxId() \u003d\u003d endTxId,\n          \"Trying to finalize log %s-%s, but current state of log\" +\n          \"is %s\", startTxId, endTxId, elf);\n      fjm.finalizeLogSegment(startTxId, endTxId);\n    } else {\n      Preconditions.checkArgument(endTxId \u003d\u003d elf.getLastTxId(),\n          \"Trying to re-finalize already finalized log \" +\n              elf + \" with different endTxId \" + endTxId);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/qjournal/server/Journal.java"
    }
  }
}