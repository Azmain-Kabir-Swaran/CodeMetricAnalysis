{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "Mover.java",
  "functionName": "getNameNodePaths",
  "functionId": "getNameNodePaths___line-CommandLine__conf-Configuration",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/mover/Mover.java",
  "functionStartLine": 728,
  "functionEndLine": 780,
  "numCommitsSeen": 54,
  "timeTaken": 2024,
  "changeHistory": [
    "15ed080e3610b7526eff12391de780948a75fa7b",
    "2b5c528a7331a00cfc67e64cd10342650948d686"
  ],
  "changeHistoryShort": {
    "15ed080e3610b7526eff12391de780948a75fa7b": "Ybodychange",
    "2b5c528a7331a00cfc67e64cd10342650948d686": "Yintroduced"
  },
  "changeHistoryDetails": {
    "15ed080e3610b7526eff12391de780948a75fa7b": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9365. Balaner does not work with the HDFS-6376 HA setup.\n",
      "commitDate": "24/05/16 12:49 PM",
      "commitName": "15ed080e3610b7526eff12391de780948a75fa7b",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "commitDateOld": "29/04/16 11:22 AM",
      "commitNameOld": "4da6f69ca129b28a5dad0a66d0c24e725ce25a3a",
      "commitAuthorOld": "Tsz-Wo Nicholas Sze",
      "daysBetweenCommits": 25.06,
      "commitsBetweenForRepo": 163,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,53 @@\n     private static Map\u003cURI, List\u003cPath\u003e\u003e getNameNodePaths(CommandLine line,\n         Configuration conf) throws Exception {\n       Map\u003cURI, List\u003cPath\u003e\u003e map \u003d Maps.newHashMap();\n       String[] paths \u003d null;\n       if (line.hasOption(\"f\")) {\n         paths \u003d readPathFile(line.getOptionValue(\"f\"));\n       } else if (line.hasOption(\"p\")) {\n         paths \u003d line.getOptionValues(\"p\");\n       }\n-      Collection\u003cURI\u003e namenodes \u003d DFSUtil.getNsServiceRpcUris(conf);\n+      Collection\u003cURI\u003e namenodes \u003d DFSUtil.getInternalNsRpcUris(conf);\n       if (paths \u003d\u003d null || paths.length \u003d\u003d 0) {\n         for (URI namenode : namenodes) {\n           map.put(namenode, null);\n         }\n         return map;\n       }\n       final URI singleNs \u003d namenodes.size() \u003d\u003d 1 ?\n           namenodes.iterator().next() : null;\n       for (String path : paths) {\n         Path target \u003d new Path(path);\n         if (!target.isUriPathAbsolute()) {\n           throw new IllegalArgumentException(\"The path \" + target\n               + \" is not absolute\");\n         }\n         URI targetUri \u003d target.toUri();\n         if ((targetUri.getAuthority() \u003d\u003d null || targetUri.getScheme() \u003d\u003d\n             null) \u0026\u0026 singleNs \u003d\u003d null) {\n           // each path must contains both scheme and authority information\n           // unless there is only one name service specified in the\n           // configuration\n           throw new IllegalArgumentException(\"The path \" + target\n               + \" does not contain scheme and authority thus cannot identify\"\n               + \" its name service\");\n         }\n         URI key \u003d singleNs;\n         if (singleNs \u003d\u003d null) {\n           key \u003d new URI(targetUri.getScheme(), targetUri.getAuthority(),\n               null, null, null);\n           if (!namenodes.contains(key)) {\n             throw new IllegalArgumentException(\"Cannot resolve the path \" +\n                 target + \". The namenode services specified in the \" +\n                 \"configuration: \" + namenodes);\n           }\n         }\n         List\u003cPath\u003e targets \u003d map.get(key);\n         if (targets \u003d\u003d null) {\n           targets \u003d Lists.newArrayList();\n           map.put(key, targets);\n         }\n         targets.add(Path.getPathWithoutSchemeAndAuthority(target));\n       }\n       return map;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private static Map\u003cURI, List\u003cPath\u003e\u003e getNameNodePaths(CommandLine line,\n        Configuration conf) throws Exception {\n      Map\u003cURI, List\u003cPath\u003e\u003e map \u003d Maps.newHashMap();\n      String[] paths \u003d null;\n      if (line.hasOption(\"f\")) {\n        paths \u003d readPathFile(line.getOptionValue(\"f\"));\n      } else if (line.hasOption(\"p\")) {\n        paths \u003d line.getOptionValues(\"p\");\n      }\n      Collection\u003cURI\u003e namenodes \u003d DFSUtil.getInternalNsRpcUris(conf);\n      if (paths \u003d\u003d null || paths.length \u003d\u003d 0) {\n        for (URI namenode : namenodes) {\n          map.put(namenode, null);\n        }\n        return map;\n      }\n      final URI singleNs \u003d namenodes.size() \u003d\u003d 1 ?\n          namenodes.iterator().next() : null;\n      for (String path : paths) {\n        Path target \u003d new Path(path);\n        if (!target.isUriPathAbsolute()) {\n          throw new IllegalArgumentException(\"The path \" + target\n              + \" is not absolute\");\n        }\n        URI targetUri \u003d target.toUri();\n        if ((targetUri.getAuthority() \u003d\u003d null || targetUri.getScheme() \u003d\u003d\n            null) \u0026\u0026 singleNs \u003d\u003d null) {\n          // each path must contains both scheme and authority information\n          // unless there is only one name service specified in the\n          // configuration\n          throw new IllegalArgumentException(\"The path \" + target\n              + \" does not contain scheme and authority thus cannot identify\"\n              + \" its name service\");\n        }\n        URI key \u003d singleNs;\n        if (singleNs \u003d\u003d null) {\n          key \u003d new URI(targetUri.getScheme(), targetUri.getAuthority(),\n              null, null, null);\n          if (!namenodes.contains(key)) {\n            throw new IllegalArgumentException(\"Cannot resolve the path \" +\n                target + \". The namenode services specified in the \" +\n                \"configuration: \" + namenodes);\n          }\n        }\n        List\u003cPath\u003e targets \u003d map.get(key);\n        if (targets \u003d\u003d null) {\n          targets \u003d Lists.newArrayList();\n          map.put(key, targets);\n        }\n        targets.add(Path.getPathWithoutSchemeAndAuthority(target));\n      }\n      return map;\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/mover/Mover.java",
      "extendedDetails": {}
    },
    "2b5c528a7331a00cfc67e64cd10342650948d686": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-6875. Archival Storage: support migration for a list of specified paths. Contributed by Jing Zhao.\n",
      "commitDate": "08/09/14 2:10 PM",
      "commitName": "2b5c528a7331a00cfc67e64cd10342650948d686",
      "commitAuthor": "Jing Zhao",
      "diff": "@@ -0,0 +1,53 @@\n+    private static Map\u003cURI, List\u003cPath\u003e\u003e getNameNodePaths(CommandLine line,\n+        Configuration conf) throws Exception {\n+      Map\u003cURI, List\u003cPath\u003e\u003e map \u003d Maps.newHashMap();\n+      String[] paths \u003d null;\n+      if (line.hasOption(\"f\")) {\n+        paths \u003d readPathFile(line.getOptionValue(\"f\"));\n+      } else if (line.hasOption(\"p\")) {\n+        paths \u003d line.getOptionValues(\"p\");\n+      }\n+      Collection\u003cURI\u003e namenodes \u003d DFSUtil.getNsServiceRpcUris(conf);\n+      if (paths \u003d\u003d null || paths.length \u003d\u003d 0) {\n+        for (URI namenode : namenodes) {\n+          map.put(namenode, null);\n+        }\n+        return map;\n+      }\n+      final URI singleNs \u003d namenodes.size() \u003d\u003d 1 ?\n+          namenodes.iterator().next() : null;\n+      for (String path : paths) {\n+        Path target \u003d new Path(path);\n+        if (!target.isUriPathAbsolute()) {\n+          throw new IllegalArgumentException(\"The path \" + target\n+              + \" is not absolute\");\n+        }\n+        URI targetUri \u003d target.toUri();\n+        if ((targetUri.getAuthority() \u003d\u003d null || targetUri.getScheme() \u003d\u003d\n+            null) \u0026\u0026 singleNs \u003d\u003d null) {\n+          // each path must contains both scheme and authority information\n+          // unless there is only one name service specified in the\n+          // configuration\n+          throw new IllegalArgumentException(\"The path \" + target\n+              + \" does not contain scheme and authority thus cannot identify\"\n+              + \" its name service\");\n+        }\n+        URI key \u003d singleNs;\n+        if (singleNs \u003d\u003d null) {\n+          key \u003d new URI(targetUri.getScheme(), targetUri.getAuthority(),\n+              null, null, null);\n+          if (!namenodes.contains(key)) {\n+            throw new IllegalArgumentException(\"Cannot resolve the path \" +\n+                target + \". The namenode services specified in the \" +\n+                \"configuration: \" + namenodes);\n+          }\n+        }\n+        List\u003cPath\u003e targets \u003d map.get(key);\n+        if (targets \u003d\u003d null) {\n+          targets \u003d Lists.newArrayList();\n+          map.put(key, targets);\n+        }\n+        targets.add(Path.getPathWithoutSchemeAndAuthority(target));\n+      }\n+      return map;\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    private static Map\u003cURI, List\u003cPath\u003e\u003e getNameNodePaths(CommandLine line,\n        Configuration conf) throws Exception {\n      Map\u003cURI, List\u003cPath\u003e\u003e map \u003d Maps.newHashMap();\n      String[] paths \u003d null;\n      if (line.hasOption(\"f\")) {\n        paths \u003d readPathFile(line.getOptionValue(\"f\"));\n      } else if (line.hasOption(\"p\")) {\n        paths \u003d line.getOptionValues(\"p\");\n      }\n      Collection\u003cURI\u003e namenodes \u003d DFSUtil.getNsServiceRpcUris(conf);\n      if (paths \u003d\u003d null || paths.length \u003d\u003d 0) {\n        for (URI namenode : namenodes) {\n          map.put(namenode, null);\n        }\n        return map;\n      }\n      final URI singleNs \u003d namenodes.size() \u003d\u003d 1 ?\n          namenodes.iterator().next() : null;\n      for (String path : paths) {\n        Path target \u003d new Path(path);\n        if (!target.isUriPathAbsolute()) {\n          throw new IllegalArgumentException(\"The path \" + target\n              + \" is not absolute\");\n        }\n        URI targetUri \u003d target.toUri();\n        if ((targetUri.getAuthority() \u003d\u003d null || targetUri.getScheme() \u003d\u003d\n            null) \u0026\u0026 singleNs \u003d\u003d null) {\n          // each path must contains both scheme and authority information\n          // unless there is only one name service specified in the\n          // configuration\n          throw new IllegalArgumentException(\"The path \" + target\n              + \" does not contain scheme and authority thus cannot identify\"\n              + \" its name service\");\n        }\n        URI key \u003d singleNs;\n        if (singleNs \u003d\u003d null) {\n          key \u003d new URI(targetUri.getScheme(), targetUri.getAuthority(),\n              null, null, null);\n          if (!namenodes.contains(key)) {\n            throw new IllegalArgumentException(\"Cannot resolve the path \" +\n                target + \". The namenode services specified in the \" +\n                \"configuration: \" + namenodes);\n          }\n        }\n        List\u003cPath\u003e targets \u003d map.get(key);\n        if (targets \u003d\u003d null) {\n          targets \u003d Lists.newArrayList();\n          map.put(key, targets);\n        }\n        targets.add(Path.getPathWithoutSchemeAndAuthority(target));\n      }\n      return map;\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/mover/Mover.java"
    }
  }
}