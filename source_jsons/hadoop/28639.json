{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "UnmanagedApplicationManager.java",
  "functionName": "monitorCurrentAppAttempt",
  "functionId": "monitorCurrentAppAttempt___appId-ApplicationId__appStates-Set__YarnApplicationState____attemptState-YarnApplicationAttemptState",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/uam/UnmanagedApplicationManager.java",
  "functionStartLine": 448,
  "functionEndLine": 503,
  "numCommitsSeen": 13,
  "timeTaken": 1166,
  "changeHistory": [
    "d5f66888b8d767ee6706fab9950c194a1bf26d32",
    "859aa1f9d621d07693825e610bdc0149f7a2770a"
  ],
  "changeHistoryShort": {
    "d5f66888b8d767ee6706fab9950c194a1bf26d32": "Ybodychange",
    "859aa1f9d621d07693825e610bdc0149f7a2770a": "Yintroduced"
  },
  "changeHistoryDetails": {
    "d5f66888b8d767ee6706fab9950c194a1bf26d32": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6128. Add support for AMRMProxy HA. (Botong Huang via Subru).\n",
      "commitDate": "17/11/17 5:39 PM",
      "commitName": "d5f66888b8d767ee6706fab9950c194a1bf26d32",
      "commitAuthor": "Subru Krishnan",
      "commitDateOld": "29/08/17 2:53 PM",
      "commitNameOld": "cc8893edc0b7960e958723c81062986c12f06ade",
      "commitAuthorOld": "Carlo Curino",
      "daysBetweenCommits": 80.16,
      "commitsBetweenForRepo": 783,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,56 @@\n   private ApplicationAttemptReport monitorCurrentAppAttempt(ApplicationId appId,\n       Set\u003cYarnApplicationState\u003e appStates,\n       YarnApplicationAttemptState attemptState)\n       throws YarnException, IOException {\n \n     long startTime \u003d System.currentTimeMillis();\n     ApplicationAttemptId appAttemptId \u003d null;\n     while (true) {\n       if (appAttemptId \u003d\u003d null) {\n         // Get application report for the appId we are interested in\n         ApplicationReport report \u003d getApplicationReport(appId);\n         YarnApplicationState state \u003d report.getYarnApplicationState();\n         if (appStates.contains(state)) {\n           if (state !\u003d YarnApplicationState.ACCEPTED) {\n             throw new YarnRuntimeException(\n-                \"Received non-accepted application state: \" + state\n-                    + \". Application \" + appId + \" not the first attempt?\");\n+                \"Received non-accepted application state: \" + state + \" for \"\n+                    + appId + \". This is likely because this is not the first \"\n+                    + \"app attempt in home sub-cluster, and AMRMProxy HA \"\n+                    + \"(yarn.nodemanager.amrmproxy.ha.enable) is not enabled.\");\n           }\n           appAttemptId \u003d\n               getApplicationReport(appId).getCurrentApplicationAttemptId();\n         } else {\n           LOG.info(\"Current application state of {} is {}, will retry later.\",\n               appId, state);\n         }\n       }\n \n       if (appAttemptId !\u003d null) {\n         GetApplicationAttemptReportRequest req \u003d this.recordFactory\n             .newRecordInstance(GetApplicationAttemptReportRequest.class);\n         req.setApplicationAttemptId(appAttemptId);\n         ApplicationAttemptReport attemptReport \u003d this.rmClient\n             .getApplicationAttemptReport(req).getApplicationAttemptReport();\n         if (attemptState\n             .equals(attemptReport.getYarnApplicationAttemptState())) {\n           return attemptReport;\n         }\n         LOG.info(\"Current attempt state of \" + appAttemptId + \" is \"\n             + attemptReport.getYarnApplicationAttemptState()\n             + \", waiting for current attempt to reach \" + attemptState);\n       }\n \n       try {\n         Thread.sleep(this.asyncApiPollIntervalMillis);\n       } catch (InterruptedException e) {\n         LOG.warn(\"Interrupted while waiting for current attempt of \" + appId\n             + \" to reach \" + attemptState);\n       }\n \n       if (System.currentTimeMillis() - startTime \u003e AM_STATE_WAIT_TIMEOUT_MS) {\n         throw new RuntimeException(\"Timeout for waiting current attempt of \"\n             + appId + \" to reach \" + attemptState);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private ApplicationAttemptReport monitorCurrentAppAttempt(ApplicationId appId,\n      Set\u003cYarnApplicationState\u003e appStates,\n      YarnApplicationAttemptState attemptState)\n      throws YarnException, IOException {\n\n    long startTime \u003d System.currentTimeMillis();\n    ApplicationAttemptId appAttemptId \u003d null;\n    while (true) {\n      if (appAttemptId \u003d\u003d null) {\n        // Get application report for the appId we are interested in\n        ApplicationReport report \u003d getApplicationReport(appId);\n        YarnApplicationState state \u003d report.getYarnApplicationState();\n        if (appStates.contains(state)) {\n          if (state !\u003d YarnApplicationState.ACCEPTED) {\n            throw new YarnRuntimeException(\n                \"Received non-accepted application state: \" + state + \" for \"\n                    + appId + \". This is likely because this is not the first \"\n                    + \"app attempt in home sub-cluster, and AMRMProxy HA \"\n                    + \"(yarn.nodemanager.amrmproxy.ha.enable) is not enabled.\");\n          }\n          appAttemptId \u003d\n              getApplicationReport(appId).getCurrentApplicationAttemptId();\n        } else {\n          LOG.info(\"Current application state of {} is {}, will retry later.\",\n              appId, state);\n        }\n      }\n\n      if (appAttemptId !\u003d null) {\n        GetApplicationAttemptReportRequest req \u003d this.recordFactory\n            .newRecordInstance(GetApplicationAttemptReportRequest.class);\n        req.setApplicationAttemptId(appAttemptId);\n        ApplicationAttemptReport attemptReport \u003d this.rmClient\n            .getApplicationAttemptReport(req).getApplicationAttemptReport();\n        if (attemptState\n            .equals(attemptReport.getYarnApplicationAttemptState())) {\n          return attemptReport;\n        }\n        LOG.info(\"Current attempt state of \" + appAttemptId + \" is \"\n            + attemptReport.getYarnApplicationAttemptState()\n            + \", waiting for current attempt to reach \" + attemptState);\n      }\n\n      try {\n        Thread.sleep(this.asyncApiPollIntervalMillis);\n      } catch (InterruptedException e) {\n        LOG.warn(\"Interrupted while waiting for current attempt of \" + appId\n            + \" to reach \" + attemptState);\n      }\n\n      if (System.currentTimeMillis() - startTime \u003e AM_STATE_WAIT_TIMEOUT_MS) {\n        throw new RuntimeException(\"Timeout for waiting current attempt of \"\n            + appId + \" to reach \" + attemptState);\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/uam/UnmanagedApplicationManager.java",
      "extendedDetails": {}
    },
    "859aa1f9d621d07693825e610bdc0149f7a2770a": {
      "type": "Yintroduced",
      "commitMessage": "YARN-5531. UnmanagedAM pool manager for federating application across clusters. (Botong Huang via Subru).\n\n(cherry picked from commit 73bb2102ce4b82b3a3bed91319f7c8f067ddc3e8)\n",
      "commitDate": "01/08/17 5:28 PM",
      "commitName": "859aa1f9d621d07693825e610bdc0149f7a2770a",
      "commitAuthor": "Subru Krishnan",
      "diff": "@@ -0,0 +1,54 @@\n+  private ApplicationAttemptReport monitorCurrentAppAttempt(ApplicationId appId,\n+      Set\u003cYarnApplicationState\u003e appStates,\n+      YarnApplicationAttemptState attemptState)\n+      throws YarnException, IOException {\n+\n+    long startTime \u003d System.currentTimeMillis();\n+    ApplicationAttemptId appAttemptId \u003d null;\n+    while (true) {\n+      if (appAttemptId \u003d\u003d null) {\n+        // Get application report for the appId we are interested in\n+        ApplicationReport report \u003d getApplicationReport(appId);\n+        YarnApplicationState state \u003d report.getYarnApplicationState();\n+        if (appStates.contains(state)) {\n+          if (state !\u003d YarnApplicationState.ACCEPTED) {\n+            throw new YarnRuntimeException(\n+                \"Received non-accepted application state: \" + state\n+                    + \". Application \" + appId + \" not the first attempt?\");\n+          }\n+          appAttemptId \u003d\n+              getApplicationReport(appId).getCurrentApplicationAttemptId();\n+        } else {\n+          LOG.info(\"Current application state of {} is {}, will retry later.\",\n+              appId, state);\n+        }\n+      }\n+\n+      if (appAttemptId !\u003d null) {\n+        GetApplicationAttemptReportRequest req \u003d this.recordFactory\n+            .newRecordInstance(GetApplicationAttemptReportRequest.class);\n+        req.setApplicationAttemptId(appAttemptId);\n+        ApplicationAttemptReport attemptReport \u003d this.rmClient\n+            .getApplicationAttemptReport(req).getApplicationAttemptReport();\n+        if (attemptState\n+            .equals(attemptReport.getYarnApplicationAttemptState())) {\n+          return attemptReport;\n+        }\n+        LOG.info(\"Current attempt state of \" + appAttemptId + \" is \"\n+            + attemptReport.getYarnApplicationAttemptState()\n+            + \", waiting for current attempt to reach \" + attemptState);\n+      }\n+\n+      try {\n+        Thread.sleep(this.asyncApiPollIntervalMillis);\n+      } catch (InterruptedException e) {\n+        LOG.warn(\"Interrupted while waiting for current attempt of \" + appId\n+            + \" to reach \" + attemptState);\n+      }\n+\n+      if (System.currentTimeMillis() - startTime \u003e AM_STATE_WAIT_TIMEOUT_MS) {\n+        throw new RuntimeException(\"Timeout for waiting current attempt of \"\n+            + appId + \" to reach \" + attemptState);\n+      }\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private ApplicationAttemptReport monitorCurrentAppAttempt(ApplicationId appId,\n      Set\u003cYarnApplicationState\u003e appStates,\n      YarnApplicationAttemptState attemptState)\n      throws YarnException, IOException {\n\n    long startTime \u003d System.currentTimeMillis();\n    ApplicationAttemptId appAttemptId \u003d null;\n    while (true) {\n      if (appAttemptId \u003d\u003d null) {\n        // Get application report for the appId we are interested in\n        ApplicationReport report \u003d getApplicationReport(appId);\n        YarnApplicationState state \u003d report.getYarnApplicationState();\n        if (appStates.contains(state)) {\n          if (state !\u003d YarnApplicationState.ACCEPTED) {\n            throw new YarnRuntimeException(\n                \"Received non-accepted application state: \" + state\n                    + \". Application \" + appId + \" not the first attempt?\");\n          }\n          appAttemptId \u003d\n              getApplicationReport(appId).getCurrentApplicationAttemptId();\n        } else {\n          LOG.info(\"Current application state of {} is {}, will retry later.\",\n              appId, state);\n        }\n      }\n\n      if (appAttemptId !\u003d null) {\n        GetApplicationAttemptReportRequest req \u003d this.recordFactory\n            .newRecordInstance(GetApplicationAttemptReportRequest.class);\n        req.setApplicationAttemptId(appAttemptId);\n        ApplicationAttemptReport attemptReport \u003d this.rmClient\n            .getApplicationAttemptReport(req).getApplicationAttemptReport();\n        if (attemptState\n            .equals(attemptReport.getYarnApplicationAttemptState())) {\n          return attemptReport;\n        }\n        LOG.info(\"Current attempt state of \" + appAttemptId + \" is \"\n            + attemptReport.getYarnApplicationAttemptState()\n            + \", waiting for current attempt to reach \" + attemptState);\n      }\n\n      try {\n        Thread.sleep(this.asyncApiPollIntervalMillis);\n      } catch (InterruptedException e) {\n        LOG.warn(\"Interrupted while waiting for current attempt of \" + appId\n            + \" to reach \" + attemptState);\n      }\n\n      if (System.currentTimeMillis() - startTime \u003e AM_STATE_WAIT_TIMEOUT_MS) {\n        throw new RuntimeException(\"Timeout for waiting current attempt of \"\n            + appId + \" to reach \" + attemptState);\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/uam/UnmanagedApplicationManager.java"
    }
  }
}