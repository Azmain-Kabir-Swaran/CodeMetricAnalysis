{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "NativeAzureFileSystem.java",
  "functionName": "createNonRecursive",
  "functionId": "createNonRecursive___f-Path__permission-FsPermission__overwrite-boolean__bufferSize-int__replication-short__blockSize-long__progress-Progressable",
  "sourceFilePath": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
  "functionStartLine": 1673,
  "functionEndLine": 1748,
  "numCommitsSeen": 66,
  "timeTaken": 3764,
  "changeHistory": [
    "9288206cb3c1a39044a8e106436987185ef43ddf",
    "8bc93db2e7c64830b6a662f28c8917a9eef4e7c9",
    "5f6edb30c2bb648d5564c951edc25645e17e6636",
    "2217e2f8ff418b88eac6ad36cafe3a9795a11f40"
  ],
  "changeHistoryShort": {
    "9288206cb3c1a39044a8e106436987185ef43ddf": "Ybodychange",
    "8bc93db2e7c64830b6a662f28c8917a9eef4e7c9": "Ybodychange",
    "5f6edb30c2bb648d5564c951edc25645e17e6636": "Ybodychange",
    "2217e2f8ff418b88eac6ad36cafe3a9795a11f40": "Yintroduced"
  },
  "changeHistoryDetails": {
    "9288206cb3c1a39044a8e106436987185ef43ddf": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14845. Azure wasb: getFileStatus not making any auth check.\nContributed by Sivaguru Sankaridurg\n",
      "commitDate": "05/10/17 7:05 AM",
      "commitName": "9288206cb3c1a39044a8e106436987185ef43ddf",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "28/09/17 11:52 AM",
      "commitNameOld": "a530e7ab3b3f5bd71143a91266b46787962ac532",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 6.8,
      "commitsBetweenForRepo": 42,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,72 +1,76 @@\n   public FSDataOutputStream createNonRecursive(Path f, FsPermission permission,\n       boolean overwrite, int bufferSize, short replication, long blockSize,\n       Progressable progress) throws IOException {\n \n     Path parent \u003d f.getParent();\n \n     // Get exclusive access to folder if this is a directory designated\n     // for atomic rename. The primary use case of for HBase write-ahead\n     // log file management.\n     SelfRenewingLease lease \u003d null;\n     if (store.isAtomicRenameKey(pathToKey(f))) {\n       try {\n         lease \u003d acquireLease(parent);\n       } catch (AzureException e) {\n \n         String errorCode \u003d \"\";\n         try {\n           StorageException e2 \u003d (StorageException) e.getCause();\n           errorCode \u003d e2.getErrorCode();\n         } catch (Exception e3) {\n           // do nothing if cast fails\n         }\n         if (errorCode.equals(\"BlobNotFound\")) {\n           throw new FileNotFoundException(\"Cannot create file \" +\n               f.getName() + \" because parent folder does not exist.\");\n         }\n \n         LOG.warn(\"Got unexpected exception trying to get lease on {} . {}\",\n           pathToKey(parent), e.getMessage());\n         throw e;\n       }\n     }\n \n     // See if the parent folder exists. If not, throw error.\n     // The exists() check will push any pending rename operation forward,\n     // if there is one, and return false.\n     //\n     // At this point, we have exclusive access to the source folder\n     // via the lease, so we will not conflict with an active folder\n     // rename operation.\n+    //\n+    // In the secure case, the call to exists will happen in the context\n+    // of the user that initiated the operation. In this case, we should\n+    // do the auth-check against ranger for the path.\n     if (!exists(parent)) {\n       try {\n \n         // This\u0027ll let the keep-alive thread exit as soon as it wakes up.\n         lease.free();\n       } catch (Exception e) {\n         LOG.warn(\"Unable to free lease because: {}\", e.getMessage());\n       }\n       throw new FileNotFoundException(\"Cannot create file \" +\n           f.getName() + \" because parent folder does not exist.\");\n     }\n \n     // Create file inside folder.\n     FSDataOutputStream out \u003d null;\n     try {\n       out \u003d create(f, permission, overwrite, false,\n           bufferSize, replication, blockSize, progress, lease);\n     } finally {\n       // Release exclusive access to folder.\n       try {\n         if (lease !\u003d null) {\n           lease.free();\n         }\n       } catch (Exception e) {\n         NativeAzureFileSystemHelper.cleanup(LOG, out);\n         String msg \u003d \"Unable to free lease on \" + parent.toUri();\n         LOG.error(msg);\n         throw new IOException(msg, e);\n       }\n     }\n     return out;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FSDataOutputStream createNonRecursive(Path f, FsPermission permission,\n      boolean overwrite, int bufferSize, short replication, long blockSize,\n      Progressable progress) throws IOException {\n\n    Path parent \u003d f.getParent();\n\n    // Get exclusive access to folder if this is a directory designated\n    // for atomic rename. The primary use case of for HBase write-ahead\n    // log file management.\n    SelfRenewingLease lease \u003d null;\n    if (store.isAtomicRenameKey(pathToKey(f))) {\n      try {\n        lease \u003d acquireLease(parent);\n      } catch (AzureException e) {\n\n        String errorCode \u003d \"\";\n        try {\n          StorageException e2 \u003d (StorageException) e.getCause();\n          errorCode \u003d e2.getErrorCode();\n        } catch (Exception e3) {\n          // do nothing if cast fails\n        }\n        if (errorCode.equals(\"BlobNotFound\")) {\n          throw new FileNotFoundException(\"Cannot create file \" +\n              f.getName() + \" because parent folder does not exist.\");\n        }\n\n        LOG.warn(\"Got unexpected exception trying to get lease on {} . {}\",\n          pathToKey(parent), e.getMessage());\n        throw e;\n      }\n    }\n\n    // See if the parent folder exists. If not, throw error.\n    // The exists() check will push any pending rename operation forward,\n    // if there is one, and return false.\n    //\n    // At this point, we have exclusive access to the source folder\n    // via the lease, so we will not conflict with an active folder\n    // rename operation.\n    //\n    // In the secure case, the call to exists will happen in the context\n    // of the user that initiated the operation. In this case, we should\n    // do the auth-check against ranger for the path.\n    if (!exists(parent)) {\n      try {\n\n        // This\u0027ll let the keep-alive thread exit as soon as it wakes up.\n        lease.free();\n      } catch (Exception e) {\n        LOG.warn(\"Unable to free lease because: {}\", e.getMessage());\n      }\n      throw new FileNotFoundException(\"Cannot create file \" +\n          f.getName() + \" because parent folder does not exist.\");\n    }\n\n    // Create file inside folder.\n    FSDataOutputStream out \u003d null;\n    try {\n      out \u003d create(f, permission, overwrite, false,\n          bufferSize, replication, blockSize, progress, lease);\n    } finally {\n      // Release exclusive access to folder.\n      try {\n        if (lease !\u003d null) {\n          lease.free();\n        }\n      } catch (Exception e) {\n        NativeAzureFileSystemHelper.cleanup(LOG, out);\n        String msg \u003d \"Unable to free lease on \" + parent.toUri();\n        LOG.error(msg);\n        throw new IOException(msg, e);\n      }\n    }\n    return out;\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
      "extendedDetails": {}
    },
    "8bc93db2e7c64830b6a662f28c8917a9eef4e7c9": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-12635. Adding Append API support for WASB. Contributed by Dushyanth.\n",
      "commitDate": "18/01/16 9:08 AM",
      "commitName": "8bc93db2e7c64830b6a662f28c8917a9eef4e7c9",
      "commitAuthor": "cnauroth",
      "commitDateOld": "09/01/16 10:18 PM",
      "commitNameOld": "0e76f1fceaaaeb66bdb4818f43b9a55fc092bf79",
      "commitAuthorOld": "cnauroth",
      "daysBetweenCommits": 8.45,
      "commitsBetweenForRepo": 64,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,72 +1,72 @@\n   public FSDataOutputStream createNonRecursive(Path f, FsPermission permission,\n       boolean overwrite, int bufferSize, short replication, long blockSize,\n       Progressable progress) throws IOException {\n \n     Path parent \u003d f.getParent();\n \n     // Get exclusive access to folder if this is a directory designated\n     // for atomic rename. The primary use case of for HBase write-ahead\n     // log file management.\n     SelfRenewingLease lease \u003d null;\n     if (store.isAtomicRenameKey(pathToKey(f))) {\n       try {\n         lease \u003d acquireLease(parent);\n       } catch (AzureException e) {\n \n         String errorCode \u003d \"\";\n         try {\n           StorageException e2 \u003d (StorageException) e.getCause();\n           errorCode \u003d e2.getErrorCode();\n         } catch (Exception e3) {\n           // do nothing if cast fails\n         }\n         if (errorCode.equals(\"BlobNotFound\")) {\n           throw new FileNotFoundException(\"Cannot create file \" +\n               f.getName() + \" because parent folder does not exist.\");\n         }\n \n         LOG.warn(\"Got unexpected exception trying to get lease on {} . {}\",\n           pathToKey(parent), e.getMessage());\n         throw e;\n       }\n     }\n \n     // See if the parent folder exists. If not, throw error.\n     // The exists() check will push any pending rename operation forward,\n     // if there is one, and return false.\n     //\n     // At this point, we have exclusive access to the source folder\n     // via the lease, so we will not conflict with an active folder\n     // rename operation.\n     if (!exists(parent)) {\n       try {\n \n         // This\u0027ll let the keep-alive thread exit as soon as it wakes up.\n         lease.free();\n       } catch (Exception e) {\n         LOG.warn(\"Unable to free lease because: {}\", e.getMessage());\n       }\n       throw new FileNotFoundException(\"Cannot create file \" +\n           f.getName() + \" because parent folder does not exist.\");\n     }\n \n     // Create file inside folder.\n     FSDataOutputStream out \u003d null;\n     try {\n       out \u003d create(f, permission, overwrite, false,\n           bufferSize, replication, blockSize, progress, lease);\n     } finally {\n       // Release exclusive access to folder.\n       try {\n         if (lease !\u003d null) {\n           lease.free();\n         }\n       } catch (Exception e) {\n-        NativeAzureFileSystem.cleanup(LOG, out);\n+        NativeAzureFileSystemHelper.cleanup(LOG, out);\n         String msg \u003d \"Unable to free lease on \" + parent.toUri();\n         LOG.error(msg);\n         throw new IOException(msg, e);\n       }\n     }\n     return out;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FSDataOutputStream createNonRecursive(Path f, FsPermission permission,\n      boolean overwrite, int bufferSize, short replication, long blockSize,\n      Progressable progress) throws IOException {\n\n    Path parent \u003d f.getParent();\n\n    // Get exclusive access to folder if this is a directory designated\n    // for atomic rename. The primary use case of for HBase write-ahead\n    // log file management.\n    SelfRenewingLease lease \u003d null;\n    if (store.isAtomicRenameKey(pathToKey(f))) {\n      try {\n        lease \u003d acquireLease(parent);\n      } catch (AzureException e) {\n\n        String errorCode \u003d \"\";\n        try {\n          StorageException e2 \u003d (StorageException) e.getCause();\n          errorCode \u003d e2.getErrorCode();\n        } catch (Exception e3) {\n          // do nothing if cast fails\n        }\n        if (errorCode.equals(\"BlobNotFound\")) {\n          throw new FileNotFoundException(\"Cannot create file \" +\n              f.getName() + \" because parent folder does not exist.\");\n        }\n\n        LOG.warn(\"Got unexpected exception trying to get lease on {} . {}\",\n          pathToKey(parent), e.getMessage());\n        throw e;\n      }\n    }\n\n    // See if the parent folder exists. If not, throw error.\n    // The exists() check will push any pending rename operation forward,\n    // if there is one, and return false.\n    //\n    // At this point, we have exclusive access to the source folder\n    // via the lease, so we will not conflict with an active folder\n    // rename operation.\n    if (!exists(parent)) {\n      try {\n\n        // This\u0027ll let the keep-alive thread exit as soon as it wakes up.\n        lease.free();\n      } catch (Exception e) {\n        LOG.warn(\"Unable to free lease because: {}\", e.getMessage());\n      }\n      throw new FileNotFoundException(\"Cannot create file \" +\n          f.getName() + \" because parent folder does not exist.\");\n    }\n\n    // Create file inside folder.\n    FSDataOutputStream out \u003d null;\n    try {\n      out \u003d create(f, permission, overwrite, false,\n          bufferSize, replication, blockSize, progress, lease);\n    } finally {\n      // Release exclusive access to folder.\n      try {\n        if (lease !\u003d null) {\n          lease.free();\n        }\n      } catch (Exception e) {\n        NativeAzureFileSystemHelper.cleanup(LOG, out);\n        String msg \u003d \"Unable to free lease on \" + parent.toUri();\n        LOG.error(msg);\n        throw new IOException(msg, e);\n      }\n    }\n    return out;\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
      "extendedDetails": {}
    },
    "5f6edb30c2bb648d5564c951edc25645e17e6636": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-12350. WASB Logging: Improve WASB Logging around deletes, reads and writes. Contributed by Dushyanth.\n",
      "commitDate": "05/10/15 8:11 PM",
      "commitName": "5f6edb30c2bb648d5564c951edc25645e17e6636",
      "commitAuthor": "cnauroth",
      "commitDateOld": "28/09/15 3:31 PM",
      "commitNameOld": "3abbdc929bde05f8819f5410cef1eaeb8940203f",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 7.19,
      "commitsBetweenForRepo": 44,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,72 +1,72 @@\n   public FSDataOutputStream createNonRecursive(Path f, FsPermission permission,\n       boolean overwrite, int bufferSize, short replication, long blockSize,\n       Progressable progress) throws IOException {\n \n     Path parent \u003d f.getParent();\n \n     // Get exclusive access to folder if this is a directory designated\n     // for atomic rename. The primary use case of for HBase write-ahead\n     // log file management.\n     SelfRenewingLease lease \u003d null;\n     if (store.isAtomicRenameKey(pathToKey(f))) {\n       try {\n         lease \u003d acquireLease(parent);\n       } catch (AzureException e) {\n \n         String errorCode \u003d \"\";\n         try {\n           StorageException e2 \u003d (StorageException) e.getCause();\n           errorCode \u003d e2.getErrorCode();\n         } catch (Exception e3) {\n           // do nothing if cast fails\n         }\n         if (errorCode.equals(\"BlobNotFound\")) {\n           throw new FileNotFoundException(\"Cannot create file \" +\n               f.getName() + \" because parent folder does not exist.\");\n         }\n \n-        LOG.warn(\"Got unexpected exception trying to get lease on \"\n-          + pathToKey(parent) + \". \" + e.getMessage());\n+        LOG.warn(\"Got unexpected exception trying to get lease on {} . {}\",\n+          pathToKey(parent), e.getMessage());\n         throw e;\n       }\n     }\n \n     // See if the parent folder exists. If not, throw error.\n     // The exists() check will push any pending rename operation forward,\n     // if there is one, and return false.\n     //\n     // At this point, we have exclusive access to the source folder\n     // via the lease, so we will not conflict with an active folder\n     // rename operation.\n     if (!exists(parent)) {\n       try {\n \n         // This\u0027ll let the keep-alive thread exit as soon as it wakes up.\n         lease.free();\n       } catch (Exception e) {\n-        LOG.warn(\"Unable to free lease because: \" + e.getMessage());\n+        LOG.warn(\"Unable to free lease because: {}\", e.getMessage());\n       }\n       throw new FileNotFoundException(\"Cannot create file \" +\n           f.getName() + \" because parent folder does not exist.\");\n     }\n \n     // Create file inside folder.\n     FSDataOutputStream out \u003d null;\n     try {\n       out \u003d create(f, permission, overwrite, false,\n           bufferSize, replication, blockSize, progress, lease);\n     } finally {\n       // Release exclusive access to folder.\n       try {\n         if (lease !\u003d null) {\n           lease.free();\n         }\n       } catch (Exception e) {\n-        IOUtils.cleanup(LOG, out);\n+        NativeAzureFileSystem.cleanup(LOG, out);\n         String msg \u003d \"Unable to free lease on \" + parent.toUri();\n         LOG.error(msg);\n         throw new IOException(msg, e);\n       }\n     }\n     return out;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FSDataOutputStream createNonRecursive(Path f, FsPermission permission,\n      boolean overwrite, int bufferSize, short replication, long blockSize,\n      Progressable progress) throws IOException {\n\n    Path parent \u003d f.getParent();\n\n    // Get exclusive access to folder if this is a directory designated\n    // for atomic rename. The primary use case of for HBase write-ahead\n    // log file management.\n    SelfRenewingLease lease \u003d null;\n    if (store.isAtomicRenameKey(pathToKey(f))) {\n      try {\n        lease \u003d acquireLease(parent);\n      } catch (AzureException e) {\n\n        String errorCode \u003d \"\";\n        try {\n          StorageException e2 \u003d (StorageException) e.getCause();\n          errorCode \u003d e2.getErrorCode();\n        } catch (Exception e3) {\n          // do nothing if cast fails\n        }\n        if (errorCode.equals(\"BlobNotFound\")) {\n          throw new FileNotFoundException(\"Cannot create file \" +\n              f.getName() + \" because parent folder does not exist.\");\n        }\n\n        LOG.warn(\"Got unexpected exception trying to get lease on {} . {}\",\n          pathToKey(parent), e.getMessage());\n        throw e;\n      }\n    }\n\n    // See if the parent folder exists. If not, throw error.\n    // The exists() check will push any pending rename operation forward,\n    // if there is one, and return false.\n    //\n    // At this point, we have exclusive access to the source folder\n    // via the lease, so we will not conflict with an active folder\n    // rename operation.\n    if (!exists(parent)) {\n      try {\n\n        // This\u0027ll let the keep-alive thread exit as soon as it wakes up.\n        lease.free();\n      } catch (Exception e) {\n        LOG.warn(\"Unable to free lease because: {}\", e.getMessage());\n      }\n      throw new FileNotFoundException(\"Cannot create file \" +\n          f.getName() + \" because parent folder does not exist.\");\n    }\n\n    // Create file inside folder.\n    FSDataOutputStream out \u003d null;\n    try {\n      out \u003d create(f, permission, overwrite, false,\n          bufferSize, replication, blockSize, progress, lease);\n    } finally {\n      // Release exclusive access to folder.\n      try {\n        if (lease !\u003d null) {\n          lease.free();\n        }\n      } catch (Exception e) {\n        NativeAzureFileSystem.cleanup(LOG, out);\n        String msg \u003d \"Unable to free lease on \" + parent.toUri();\n        LOG.error(msg);\n        throw new IOException(msg, e);\n      }\n    }\n    return out;\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
      "extendedDetails": {}
    },
    "2217e2f8ff418b88eac6ad36cafe3a9795a11f40": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-10809. hadoop-azure: page blob support. Contributed by Dexter Bradshaw, Mostafa Elhemali, Eric Hanson, and Mike Liddell.\n",
      "commitDate": "08/10/14 2:20 PM",
      "commitName": "2217e2f8ff418b88eac6ad36cafe3a9795a11f40",
      "commitAuthor": "cnauroth",
      "diff": "@@ -0,0 +1,72 @@\n+  public FSDataOutputStream createNonRecursive(Path f, FsPermission permission,\n+      boolean overwrite, int bufferSize, short replication, long blockSize,\n+      Progressable progress) throws IOException {\n+\n+    Path parent \u003d f.getParent();\n+\n+    // Get exclusive access to folder if this is a directory designated\n+    // for atomic rename. The primary use case of for HBase write-ahead\n+    // log file management.\n+    SelfRenewingLease lease \u003d null;\n+    if (store.isAtomicRenameKey(pathToKey(f))) {\n+      try {\n+        lease \u003d acquireLease(parent);\n+      } catch (AzureException e) {\n+\n+        String errorCode \u003d \"\";\n+        try {\n+          StorageException e2 \u003d (StorageException) e.getCause();\n+          errorCode \u003d e2.getErrorCode();\n+        } catch (Exception e3) {\n+          // do nothing if cast fails\n+        }\n+        if (errorCode.equals(\"BlobNotFound\")) {\n+          throw new FileNotFoundException(\"Cannot create file \" +\n+              f.getName() + \" because parent folder does not exist.\");\n+        }\n+\n+        LOG.warn(\"Got unexpected exception trying to get lease on \"\n+          + pathToKey(parent) + \". \" + e.getMessage());\n+        throw e;\n+      }\n+    }\n+\n+    // See if the parent folder exists. If not, throw error.\n+    // The exists() check will push any pending rename operation forward,\n+    // if there is one, and return false.\n+    //\n+    // At this point, we have exclusive access to the source folder\n+    // via the lease, so we will not conflict with an active folder\n+    // rename operation.\n+    if (!exists(parent)) {\n+      try {\n+\n+        // This\u0027ll let the keep-alive thread exit as soon as it wakes up.\n+        lease.free();\n+      } catch (Exception e) {\n+        LOG.warn(\"Unable to free lease because: \" + e.getMessage());\n+      }\n+      throw new FileNotFoundException(\"Cannot create file \" +\n+          f.getName() + \" because parent folder does not exist.\");\n+    }\n+\n+    // Create file inside folder.\n+    FSDataOutputStream out \u003d null;\n+    try {\n+      out \u003d create(f, permission, overwrite, false,\n+          bufferSize, replication, blockSize, progress, lease);\n+    } finally {\n+      // Release exclusive access to folder.\n+      try {\n+        if (lease !\u003d null) {\n+          lease.free();\n+        }\n+      } catch (Exception e) {\n+        IOUtils.cleanup(LOG, out);\n+        String msg \u003d \"Unable to free lease on \" + parent.toUri();\n+        LOG.error(msg);\n+        throw new IOException(msg, e);\n+      }\n+    }\n+    return out;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public FSDataOutputStream createNonRecursive(Path f, FsPermission permission,\n      boolean overwrite, int bufferSize, short replication, long blockSize,\n      Progressable progress) throws IOException {\n\n    Path parent \u003d f.getParent();\n\n    // Get exclusive access to folder if this is a directory designated\n    // for atomic rename. The primary use case of for HBase write-ahead\n    // log file management.\n    SelfRenewingLease lease \u003d null;\n    if (store.isAtomicRenameKey(pathToKey(f))) {\n      try {\n        lease \u003d acquireLease(parent);\n      } catch (AzureException e) {\n\n        String errorCode \u003d \"\";\n        try {\n          StorageException e2 \u003d (StorageException) e.getCause();\n          errorCode \u003d e2.getErrorCode();\n        } catch (Exception e3) {\n          // do nothing if cast fails\n        }\n        if (errorCode.equals(\"BlobNotFound\")) {\n          throw new FileNotFoundException(\"Cannot create file \" +\n              f.getName() + \" because parent folder does not exist.\");\n        }\n\n        LOG.warn(\"Got unexpected exception trying to get lease on \"\n          + pathToKey(parent) + \". \" + e.getMessage());\n        throw e;\n      }\n    }\n\n    // See if the parent folder exists. If not, throw error.\n    // The exists() check will push any pending rename operation forward,\n    // if there is one, and return false.\n    //\n    // At this point, we have exclusive access to the source folder\n    // via the lease, so we will not conflict with an active folder\n    // rename operation.\n    if (!exists(parent)) {\n      try {\n\n        // This\u0027ll let the keep-alive thread exit as soon as it wakes up.\n        lease.free();\n      } catch (Exception e) {\n        LOG.warn(\"Unable to free lease because: \" + e.getMessage());\n      }\n      throw new FileNotFoundException(\"Cannot create file \" +\n          f.getName() + \" because parent folder does not exist.\");\n    }\n\n    // Create file inside folder.\n    FSDataOutputStream out \u003d null;\n    try {\n      out \u003d create(f, permission, overwrite, false,\n          bufferSize, replication, blockSize, progress, lease);\n    } finally {\n      // Release exclusive access to folder.\n      try {\n        if (lease !\u003d null) {\n          lease.free();\n        }\n      } catch (Exception e) {\n        IOUtils.cleanup(LOG, out);\n        String msg \u003d \"Unable to free lease on \" + parent.toUri();\n        LOG.error(msg);\n        throw new IOException(msg, e);\n      }\n    }\n    return out;\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java"
    }
  }
}