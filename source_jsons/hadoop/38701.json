{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FiCaSchedulerApp.java",
  "functionName": "apply",
  "functionId": "apply___cluster-Resource__request-ResourceCommitRequest__FiCaSchedulerApp,FiCaSchedulerNode____updatePending-boolean",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/common/fica/FiCaSchedulerApp.java",
  "functionStartLine": 553,
  "functionEndLine": 685,
  "numCommitsSeen": 169,
  "timeTaken": 8922,
  "changeHistory": [
    "c30c23cb665761e997bcfc1dc00908f70b069fa2",
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635",
    "2ab611d48b7669b31bd2c9b918f47251da77d0f6",
    "51654a3962bcd0482c0e1dd32765e9533e3f9158",
    "47f711eebca315804c80012eea5f31275ac25518",
    "f8c5f5b23732a1e35f012c1a6850bed09c8a5180",
    "38af23796971193fa529c3d08ffde8fcd6e607b6",
    "88d8d3f40b2923fab23a933bce1cd2e9c320ae84",
    "a957f1c60e1308d1d70a1803381994f59949c5f8",
    "eac6b4c35c50e555c2f1b5f913bb2c4d839f1ff4",
    "0a55bd841ec0f2eb89a0383f4c589526e8b138d4",
    "de3b4aac561258ad242a3c5ed1c919428893fd4c"
  ],
  "changeHistoryShort": {
    "c30c23cb665761e997bcfc1dc00908f70b069fa2": "Ybodychange",
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635": "Ybodychange",
    "2ab611d48b7669b31bd2c9b918f47251da77d0f6": "Ybodychange",
    "51654a3962bcd0482c0e1dd32765e9533e3f9158": "Ybodychange",
    "47f711eebca315804c80012eea5f31275ac25518": "Ymultichange(Yreturntypechange,Ybodychange)",
    "f8c5f5b23732a1e35f012c1a6850bed09c8a5180": "Ybodychange",
    "38af23796971193fa529c3d08ffde8fcd6e607b6": "Ybodychange",
    "88d8d3f40b2923fab23a933bce1cd2e9c320ae84": "Ymultichange(Yparameterchange,Ybodychange)",
    "a957f1c60e1308d1d70a1803381994f59949c5f8": "Ybodychange",
    "eac6b4c35c50e555c2f1b5f913bb2c4d839f1ff4": "Ybodychange",
    "0a55bd841ec0f2eb89a0383f4c589526e8b138d4": "Ybodychange",
    "de3b4aac561258ad242a3c5ed1c919428893fd4c": "Yintroduced"
  },
  "changeHistoryDetails": {
    "c30c23cb665761e997bcfc1dc00908f70b069fa2": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6492. Generate queue metrics for each partition. Contributed by Manikandan R\n",
      "commitDate": "26/05/20 4:29 PM",
      "commitName": "c30c23cb665761e997bcfc1dc00908f70b069fa2",
      "commitAuthor": "Jonathan Hung",
      "commitDateOld": "25/03/20 4:20 AM",
      "commitNameOld": "cdb2107066a2d8557270888c0a9a75f29a6853bf",
      "commitAuthorOld": "Sunil G",
      "daysBetweenCommits": 62.51,
      "commitsBetweenForRepo": 213,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,133 +1,133 @@\n   public boolean apply(Resource cluster, ResourceCommitRequest\u003cFiCaSchedulerApp,\n       FiCaSchedulerNode\u003e request, boolean updatePending) {\n     boolean reReservation \u003d false;\n \n     writeLock.lock();\n     try {\n \n       // If we allocated something\n       if (request.anythingAllocatedOrReserved()) {\n         ContainerAllocationProposal\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n             allocation \u003d request.getFirstAllocatedOrReservedContainer();\n         SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n             schedulerContainer \u003d allocation.getAllocatedOrReservedContainer();\n \n         // Required sanity check - AM can call \u0027allocate\u0027 to update resource\n         // request without locking the scheduler, hence we need to check\n         if (updatePending \u0026\u0026\n             getOutstandingAsksCount(schedulerContainer.getSchedulerRequestKey())\n                 \u003c\u003d 0) {\n           return false;\n         }\n \n         RMContainer rmContainer \u003d schedulerContainer.getRmContainer();\n         reReservation \u003d\n             (!schedulerContainer.isAllocated()) \u0026\u0026 (rmContainer.getState()\n                 \u003d\u003d RMContainerState.RESERVED);\n \n         // Generate new containerId if it is not an allocation for increasing\n         // Or re-reservation\n         if (rmContainer.getContainer().getId() \u003d\u003d null) {\n           rmContainer.setContainerId(BuilderUtils\n               .newContainerId(getApplicationAttemptId(),\n                   getNewContainerId()));\n         }\n         ContainerId containerId \u003d rmContainer.getContainerId();\n \n         if (schedulerContainer.isAllocated()) {\n           // This allocation is from a reserved container\n           // Unreserve it first\n           if (allocation.getAllocateFromReservedContainer() !\u003d null) {\n             RMContainer reservedContainer \u003d\n                 allocation.getAllocateFromReservedContainer().getRmContainer();\n             // Handling container allocation\n             // Did we previously reserve containers at this \u0027priority\u0027?\n             unreserve(schedulerContainer.getSchedulerRequestKey(),\n                 schedulerContainer.getSchedulerNode(), reservedContainer);\n           }\n \n           // Allocate a new container\n           addToNewlyAllocatedContainers(\n               schedulerContainer.getSchedulerNode(), rmContainer);\n           liveContainers.put(containerId, rmContainer);\n \n           // Deduct pending resource requests\n           if (updatePending) {\n             ContainerRequest containerRequest \u003d appSchedulingInfo.allocate(\n                 allocation.getAllocationLocalityType(),\n                 schedulerContainer.getSchedulerNode(),\n                 schedulerContainer.getSchedulerRequestKey(),\n-                schedulerContainer.getRmContainer().getContainer());\n+                  schedulerContainer.getRmContainer());\n             ((RMContainerImpl) rmContainer).setContainerRequest(\n                 containerRequest);\n \n             // If this is from a SchedulingRequest, set allocation tags.\n             if (containerRequest !\u003d null\n                 \u0026\u0026 containerRequest.getSchedulingRequest() !\u003d null) {\n               ((RMContainerImpl) rmContainer).setAllocationTags(\n                   containerRequest.getSchedulingRequest().getAllocationTags());\n             }\n           } else {\n             AppSchedulingInfo.updateMetrics(getApplicationId(),\n                 allocation.getAllocationLocalityType(),\n                 schedulerContainer.getSchedulerNode(),\n-                schedulerContainer.getRmContainer().getContainer(), getUser(),\n+                schedulerContainer.getRmContainer(), getUser(),\n                 getQueue());\n           }\n \n           attemptResourceUsage.incUsed(schedulerContainer.getNodePartition(),\n               allocation.getAllocatedOrReservedResource());\n \n           rmContainer.handle(\n               new RMContainerEvent(containerId, RMContainerEventType.START));\n \n           // Inform the node\n           schedulerContainer.getSchedulerNode().allocateContainer(\n               rmContainer);\n \n           // update locality statistics,\n           incNumAllocatedContainers(allocation.getAllocationLocalityType(),\n               allocation.getRequestLocalityType());\n \n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"allocate: applicationAttemptId\u003d\" + containerId\n                 .getApplicationAttemptId() + \" container\u003d\" + containerId\n                 + \" host\u003d\" + rmContainer.getAllocatedNode().getHost()\n                 + \" type\u003d\" + allocation.getAllocationLocalityType());\n           }\n           // In order to save space in the audit log, only include the partition\n           // if it is not the default partition.\n           String partition \u003d\n               schedulerContainer.getSchedulerNode().getPartition();\n           if (partition !\u003d null \u0026\u0026 partition.isEmpty()) {\n             partition \u003d null;\n           }\n           RMAuditLogger.logSuccess(getUser(), AuditConstants.ALLOC_CONTAINER,\n               \"SchedulerApp\", getApplicationId(), containerId,\n               allocation.getAllocatedOrReservedResource(), getQueueName(),\n               partition);\n         } else {\n           // If the rmContainer\u0027s state is already updated to RESERVED, this is\n           // a reReservation\n           reserve(schedulerContainer.getSchedulerRequestKey(),\n               schedulerContainer.getSchedulerNode(),\n               schedulerContainer.getRmContainer(),\n               schedulerContainer.getRmContainer().getContainer(),\n               reReservation);\n \n           LOG.info(\"Reserved container\u003d\" + rmContainer.getContainerId()\n               + \", on node\u003d\" + schedulerContainer.getSchedulerNode()\n               + \" with resource\u003d\" + rmContainer\n               .getAllocatedOrReservedResource());\n         }\n       }\n     } finally {\n       writeLock.unlock();\n     }\n \n     // Don\u0027t bother CS leaf queue if it is a re-reservation\n     if (!reReservation) {\n       getCSLeafQueue().apply(cluster, request);\n     }\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean apply(Resource cluster, ResourceCommitRequest\u003cFiCaSchedulerApp,\n      FiCaSchedulerNode\u003e request, boolean updatePending) {\n    boolean reReservation \u003d false;\n\n    writeLock.lock();\n    try {\n\n      // If we allocated something\n      if (request.anythingAllocatedOrReserved()) {\n        ContainerAllocationProposal\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n            allocation \u003d request.getFirstAllocatedOrReservedContainer();\n        SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n            schedulerContainer \u003d allocation.getAllocatedOrReservedContainer();\n\n        // Required sanity check - AM can call \u0027allocate\u0027 to update resource\n        // request without locking the scheduler, hence we need to check\n        if (updatePending \u0026\u0026\n            getOutstandingAsksCount(schedulerContainer.getSchedulerRequestKey())\n                \u003c\u003d 0) {\n          return false;\n        }\n\n        RMContainer rmContainer \u003d schedulerContainer.getRmContainer();\n        reReservation \u003d\n            (!schedulerContainer.isAllocated()) \u0026\u0026 (rmContainer.getState()\n                \u003d\u003d RMContainerState.RESERVED);\n\n        // Generate new containerId if it is not an allocation for increasing\n        // Or re-reservation\n        if (rmContainer.getContainer().getId() \u003d\u003d null) {\n          rmContainer.setContainerId(BuilderUtils\n              .newContainerId(getApplicationAttemptId(),\n                  getNewContainerId()));\n        }\n        ContainerId containerId \u003d rmContainer.getContainerId();\n\n        if (schedulerContainer.isAllocated()) {\n          // This allocation is from a reserved container\n          // Unreserve it first\n          if (allocation.getAllocateFromReservedContainer() !\u003d null) {\n            RMContainer reservedContainer \u003d\n                allocation.getAllocateFromReservedContainer().getRmContainer();\n            // Handling container allocation\n            // Did we previously reserve containers at this \u0027priority\u0027?\n            unreserve(schedulerContainer.getSchedulerRequestKey(),\n                schedulerContainer.getSchedulerNode(), reservedContainer);\n          }\n\n          // Allocate a new container\n          addToNewlyAllocatedContainers(\n              schedulerContainer.getSchedulerNode(), rmContainer);\n          liveContainers.put(containerId, rmContainer);\n\n          // Deduct pending resource requests\n          if (updatePending) {\n            ContainerRequest containerRequest \u003d appSchedulingInfo.allocate(\n                allocation.getAllocationLocalityType(),\n                schedulerContainer.getSchedulerNode(),\n                schedulerContainer.getSchedulerRequestKey(),\n                  schedulerContainer.getRmContainer());\n            ((RMContainerImpl) rmContainer).setContainerRequest(\n                containerRequest);\n\n            // If this is from a SchedulingRequest, set allocation tags.\n            if (containerRequest !\u003d null\n                \u0026\u0026 containerRequest.getSchedulingRequest() !\u003d null) {\n              ((RMContainerImpl) rmContainer).setAllocationTags(\n                  containerRequest.getSchedulingRequest().getAllocationTags());\n            }\n          } else {\n            AppSchedulingInfo.updateMetrics(getApplicationId(),\n                allocation.getAllocationLocalityType(),\n                schedulerContainer.getSchedulerNode(),\n                schedulerContainer.getRmContainer(), getUser(),\n                getQueue());\n          }\n\n          attemptResourceUsage.incUsed(schedulerContainer.getNodePartition(),\n              allocation.getAllocatedOrReservedResource());\n\n          rmContainer.handle(\n              new RMContainerEvent(containerId, RMContainerEventType.START));\n\n          // Inform the node\n          schedulerContainer.getSchedulerNode().allocateContainer(\n              rmContainer);\n\n          // update locality statistics,\n          incNumAllocatedContainers(allocation.getAllocationLocalityType(),\n              allocation.getRequestLocalityType());\n\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"allocate: applicationAttemptId\u003d\" + containerId\n                .getApplicationAttemptId() + \" container\u003d\" + containerId\n                + \" host\u003d\" + rmContainer.getAllocatedNode().getHost()\n                + \" type\u003d\" + allocation.getAllocationLocalityType());\n          }\n          // In order to save space in the audit log, only include the partition\n          // if it is not the default partition.\n          String partition \u003d\n              schedulerContainer.getSchedulerNode().getPartition();\n          if (partition !\u003d null \u0026\u0026 partition.isEmpty()) {\n            partition \u003d null;\n          }\n          RMAuditLogger.logSuccess(getUser(), AuditConstants.ALLOC_CONTAINER,\n              \"SchedulerApp\", getApplicationId(), containerId,\n              allocation.getAllocatedOrReservedResource(), getQueueName(),\n              partition);\n        } else {\n          // If the rmContainer\u0027s state is already updated to RESERVED, this is\n          // a reReservation\n          reserve(schedulerContainer.getSchedulerRequestKey(),\n              schedulerContainer.getSchedulerNode(),\n              schedulerContainer.getRmContainer(),\n              schedulerContainer.getRmContainer().getContainer(),\n              reReservation);\n\n          LOG.info(\"Reserved container\u003d\" + rmContainer.getContainerId()\n              + \", on node\u003d\" + schedulerContainer.getSchedulerNode()\n              + \" with resource\u003d\" + rmContainer\n              .getAllocatedOrReservedResource());\n        }\n      }\n    } finally {\n      writeLock.unlock();\n    }\n\n    // Don\u0027t bother CS leaf queue if it is a re-reservation\n    if (!reReservation) {\n      getCSLeafQueue().apply(cluster, request);\n    }\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/common/fica/FiCaSchedulerApp.java",
      "extendedDetails": {}
    },
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9341.  Fixed enentrant lock usage in YARN project.\n            Contributed by Prabhu Joseph\n",
      "commitDate": "07/03/19 1:47 PM",
      "commitName": "39b4a37e02e929a698fcf9e32f1f71bb6b977635",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "04/03/19 9:10 PM",
      "commitNameOld": "e40e2d6ad5cbe782c3a067229270738b501ed27e",
      "commitAuthorOld": "Prabhu Joseph",
      "daysBetweenCommits": 2.69,
      "commitsBetweenForRepo": 39,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,133 +1,133 @@\n   public boolean apply(Resource cluster, ResourceCommitRequest\u003cFiCaSchedulerApp,\n       FiCaSchedulerNode\u003e request, boolean updatePending) {\n     boolean reReservation \u003d false;\n \n+    writeLock.lock();\n     try {\n-      writeLock.lock();\n \n       // If we allocated something\n       if (request.anythingAllocatedOrReserved()) {\n         ContainerAllocationProposal\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n             allocation \u003d request.getFirstAllocatedOrReservedContainer();\n         SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n             schedulerContainer \u003d allocation.getAllocatedOrReservedContainer();\n \n         // Required sanity check - AM can call \u0027allocate\u0027 to update resource\n         // request without locking the scheduler, hence we need to check\n         if (updatePending \u0026\u0026\n             getOutstandingAsksCount(schedulerContainer.getSchedulerRequestKey())\n                 \u003c\u003d 0) {\n           return false;\n         }\n \n         RMContainer rmContainer \u003d schedulerContainer.getRmContainer();\n         reReservation \u003d\n             (!schedulerContainer.isAllocated()) \u0026\u0026 (rmContainer.getState()\n                 \u003d\u003d RMContainerState.RESERVED);\n \n         // Generate new containerId if it is not an allocation for increasing\n         // Or re-reservation\n         if (rmContainer.getContainer().getId() \u003d\u003d null) {\n           rmContainer.setContainerId(BuilderUtils\n               .newContainerId(getApplicationAttemptId(),\n                   getNewContainerId()));\n         }\n         ContainerId containerId \u003d rmContainer.getContainerId();\n \n         if (schedulerContainer.isAllocated()) {\n           // This allocation is from a reserved container\n           // Unreserve it first\n           if (allocation.getAllocateFromReservedContainer() !\u003d null) {\n             RMContainer reservedContainer \u003d\n                 allocation.getAllocateFromReservedContainer().getRmContainer();\n             // Handling container allocation\n             // Did we previously reserve containers at this \u0027priority\u0027?\n             unreserve(schedulerContainer.getSchedulerRequestKey(),\n                 schedulerContainer.getSchedulerNode(), reservedContainer);\n           }\n \n           // Allocate a new container\n           addToNewlyAllocatedContainers(\n               schedulerContainer.getSchedulerNode(), rmContainer);\n           liveContainers.put(containerId, rmContainer);\n \n           // Deduct pending resource requests\n           if (updatePending) {\n             ContainerRequest containerRequest \u003d appSchedulingInfo.allocate(\n                 allocation.getAllocationLocalityType(),\n                 schedulerContainer.getSchedulerNode(),\n                 schedulerContainer.getSchedulerRequestKey(),\n                 schedulerContainer.getRmContainer().getContainer());\n             ((RMContainerImpl) rmContainer).setContainerRequest(\n                 containerRequest);\n \n             // If this is from a SchedulingRequest, set allocation tags.\n             if (containerRequest !\u003d null\n                 \u0026\u0026 containerRequest.getSchedulingRequest() !\u003d null) {\n               ((RMContainerImpl) rmContainer).setAllocationTags(\n                   containerRequest.getSchedulingRequest().getAllocationTags());\n             }\n           } else {\n             AppSchedulingInfo.updateMetrics(getApplicationId(),\n                 allocation.getAllocationLocalityType(),\n                 schedulerContainer.getSchedulerNode(),\n                 schedulerContainer.getRmContainer().getContainer(), getUser(),\n                 getQueue());\n           }\n \n           attemptResourceUsage.incUsed(schedulerContainer.getNodePartition(),\n               allocation.getAllocatedOrReservedResource());\n \n           rmContainer.handle(\n               new RMContainerEvent(containerId, RMContainerEventType.START));\n \n           // Inform the node\n           schedulerContainer.getSchedulerNode().allocateContainer(\n               rmContainer);\n \n           // update locality statistics,\n           incNumAllocatedContainers(allocation.getAllocationLocalityType(),\n               allocation.getRequestLocalityType());\n \n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"allocate: applicationAttemptId\u003d\" + containerId\n                 .getApplicationAttemptId() + \" container\u003d\" + containerId\n                 + \" host\u003d\" + rmContainer.getAllocatedNode().getHost()\n                 + \" type\u003d\" + allocation.getAllocationLocalityType());\n           }\n           // In order to save space in the audit log, only include the partition\n           // if it is not the default partition.\n           String partition \u003d\n               schedulerContainer.getSchedulerNode().getPartition();\n           if (partition !\u003d null \u0026\u0026 partition.isEmpty()) {\n             partition \u003d null;\n           }\n           RMAuditLogger.logSuccess(getUser(), AuditConstants.ALLOC_CONTAINER,\n               \"SchedulerApp\", getApplicationId(), containerId,\n               allocation.getAllocatedOrReservedResource(), getQueueName(),\n               partition);\n         } else {\n           // If the rmContainer\u0027s state is already updated to RESERVED, this is\n           // a reReservation\n           reserve(schedulerContainer.getSchedulerRequestKey(),\n               schedulerContainer.getSchedulerNode(),\n               schedulerContainer.getRmContainer(),\n               schedulerContainer.getRmContainer().getContainer(),\n               reReservation);\n \n           LOG.info(\"Reserved container\u003d\" + rmContainer.getContainerId()\n               + \", on node\u003d\" + schedulerContainer.getSchedulerNode()\n               + \" with resource\u003d\" + rmContainer\n               .getAllocatedOrReservedResource());\n         }\n       }\n     } finally {\n       writeLock.unlock();\n     }\n \n     // Don\u0027t bother CS leaf queue if it is a re-reservation\n     if (!reReservation) {\n       getCSLeafQueue().apply(cluster, request);\n     }\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean apply(Resource cluster, ResourceCommitRequest\u003cFiCaSchedulerApp,\n      FiCaSchedulerNode\u003e request, boolean updatePending) {\n    boolean reReservation \u003d false;\n\n    writeLock.lock();\n    try {\n\n      // If we allocated something\n      if (request.anythingAllocatedOrReserved()) {\n        ContainerAllocationProposal\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n            allocation \u003d request.getFirstAllocatedOrReservedContainer();\n        SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n            schedulerContainer \u003d allocation.getAllocatedOrReservedContainer();\n\n        // Required sanity check - AM can call \u0027allocate\u0027 to update resource\n        // request without locking the scheduler, hence we need to check\n        if (updatePending \u0026\u0026\n            getOutstandingAsksCount(schedulerContainer.getSchedulerRequestKey())\n                \u003c\u003d 0) {\n          return false;\n        }\n\n        RMContainer rmContainer \u003d schedulerContainer.getRmContainer();\n        reReservation \u003d\n            (!schedulerContainer.isAllocated()) \u0026\u0026 (rmContainer.getState()\n                \u003d\u003d RMContainerState.RESERVED);\n\n        // Generate new containerId if it is not an allocation for increasing\n        // Or re-reservation\n        if (rmContainer.getContainer().getId() \u003d\u003d null) {\n          rmContainer.setContainerId(BuilderUtils\n              .newContainerId(getApplicationAttemptId(),\n                  getNewContainerId()));\n        }\n        ContainerId containerId \u003d rmContainer.getContainerId();\n\n        if (schedulerContainer.isAllocated()) {\n          // This allocation is from a reserved container\n          // Unreserve it first\n          if (allocation.getAllocateFromReservedContainer() !\u003d null) {\n            RMContainer reservedContainer \u003d\n                allocation.getAllocateFromReservedContainer().getRmContainer();\n            // Handling container allocation\n            // Did we previously reserve containers at this \u0027priority\u0027?\n            unreserve(schedulerContainer.getSchedulerRequestKey(),\n                schedulerContainer.getSchedulerNode(), reservedContainer);\n          }\n\n          // Allocate a new container\n          addToNewlyAllocatedContainers(\n              schedulerContainer.getSchedulerNode(), rmContainer);\n          liveContainers.put(containerId, rmContainer);\n\n          // Deduct pending resource requests\n          if (updatePending) {\n            ContainerRequest containerRequest \u003d appSchedulingInfo.allocate(\n                allocation.getAllocationLocalityType(),\n                schedulerContainer.getSchedulerNode(),\n                schedulerContainer.getSchedulerRequestKey(),\n                schedulerContainer.getRmContainer().getContainer());\n            ((RMContainerImpl) rmContainer).setContainerRequest(\n                containerRequest);\n\n            // If this is from a SchedulingRequest, set allocation tags.\n            if (containerRequest !\u003d null\n                \u0026\u0026 containerRequest.getSchedulingRequest() !\u003d null) {\n              ((RMContainerImpl) rmContainer).setAllocationTags(\n                  containerRequest.getSchedulingRequest().getAllocationTags());\n            }\n          } else {\n            AppSchedulingInfo.updateMetrics(getApplicationId(),\n                allocation.getAllocationLocalityType(),\n                schedulerContainer.getSchedulerNode(),\n                schedulerContainer.getRmContainer().getContainer(), getUser(),\n                getQueue());\n          }\n\n          attemptResourceUsage.incUsed(schedulerContainer.getNodePartition(),\n              allocation.getAllocatedOrReservedResource());\n\n          rmContainer.handle(\n              new RMContainerEvent(containerId, RMContainerEventType.START));\n\n          // Inform the node\n          schedulerContainer.getSchedulerNode().allocateContainer(\n              rmContainer);\n\n          // update locality statistics,\n          incNumAllocatedContainers(allocation.getAllocationLocalityType(),\n              allocation.getRequestLocalityType());\n\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"allocate: applicationAttemptId\u003d\" + containerId\n                .getApplicationAttemptId() + \" container\u003d\" + containerId\n                + \" host\u003d\" + rmContainer.getAllocatedNode().getHost()\n                + \" type\u003d\" + allocation.getAllocationLocalityType());\n          }\n          // In order to save space in the audit log, only include the partition\n          // if it is not the default partition.\n          String partition \u003d\n              schedulerContainer.getSchedulerNode().getPartition();\n          if (partition !\u003d null \u0026\u0026 partition.isEmpty()) {\n            partition \u003d null;\n          }\n          RMAuditLogger.logSuccess(getUser(), AuditConstants.ALLOC_CONTAINER,\n              \"SchedulerApp\", getApplicationId(), containerId,\n              allocation.getAllocatedOrReservedResource(), getQueueName(),\n              partition);\n        } else {\n          // If the rmContainer\u0027s state is already updated to RESERVED, this is\n          // a reReservation\n          reserve(schedulerContainer.getSchedulerRequestKey(),\n              schedulerContainer.getSchedulerNode(),\n              schedulerContainer.getRmContainer(),\n              schedulerContainer.getRmContainer().getContainer(),\n              reReservation);\n\n          LOG.info(\"Reserved container\u003d\" + rmContainer.getContainerId()\n              + \", on node\u003d\" + schedulerContainer.getSchedulerNode()\n              + \" with resource\u003d\" + rmContainer\n              .getAllocatedOrReservedResource());\n        }\n      }\n    } finally {\n      writeLock.unlock();\n    }\n\n    // Don\u0027t bother CS leaf queue if it is a re-reservation\n    if (!reReservation) {\n      getCSLeafQueue().apply(cluster, request);\n    }\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/common/fica/FiCaSchedulerApp.java",
      "extendedDetails": {}
    },
    "2ab611d48b7669b31bd2c9b918f47251da77d0f6": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7225. Add queue and partition info to RM audit log. Contributed by Eric Payne\n",
      "commitDate": "01/11/18 2:22 PM",
      "commitName": "2ab611d48b7669b31bd2c9b918f47251da77d0f6",
      "commitAuthor": "Jonathan Hung",
      "commitDateOld": "21/08/18 7:42 AM",
      "commitNameOld": "9c3fc3ef2865164aa5f121793ac914cfeb21a181",
      "commitAuthorOld": "Weiwei Yang",
      "daysBetweenCommits": 72.28,
      "commitsBetweenForRepo": 682,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,125 +1,133 @@\n   public boolean apply(Resource cluster, ResourceCommitRequest\u003cFiCaSchedulerApp,\n       FiCaSchedulerNode\u003e request, boolean updatePending) {\n     boolean reReservation \u003d false;\n \n     try {\n       writeLock.lock();\n \n       // If we allocated something\n       if (request.anythingAllocatedOrReserved()) {\n         ContainerAllocationProposal\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n             allocation \u003d request.getFirstAllocatedOrReservedContainer();\n         SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n             schedulerContainer \u003d allocation.getAllocatedOrReservedContainer();\n \n         // Required sanity check - AM can call \u0027allocate\u0027 to update resource\n         // request without locking the scheduler, hence we need to check\n         if (updatePending \u0026\u0026\n             getOutstandingAsksCount(schedulerContainer.getSchedulerRequestKey())\n                 \u003c\u003d 0) {\n           return false;\n         }\n \n         RMContainer rmContainer \u003d schedulerContainer.getRmContainer();\n         reReservation \u003d\n             (!schedulerContainer.isAllocated()) \u0026\u0026 (rmContainer.getState()\n                 \u003d\u003d RMContainerState.RESERVED);\n \n         // Generate new containerId if it is not an allocation for increasing\n         // Or re-reservation\n         if (rmContainer.getContainer().getId() \u003d\u003d null) {\n           rmContainer.setContainerId(BuilderUtils\n               .newContainerId(getApplicationAttemptId(),\n                   getNewContainerId()));\n         }\n         ContainerId containerId \u003d rmContainer.getContainerId();\n \n         if (schedulerContainer.isAllocated()) {\n           // This allocation is from a reserved container\n           // Unreserve it first\n           if (allocation.getAllocateFromReservedContainer() !\u003d null) {\n             RMContainer reservedContainer \u003d\n                 allocation.getAllocateFromReservedContainer().getRmContainer();\n             // Handling container allocation\n             // Did we previously reserve containers at this \u0027priority\u0027?\n             unreserve(schedulerContainer.getSchedulerRequestKey(),\n                 schedulerContainer.getSchedulerNode(), reservedContainer);\n           }\n \n           // Allocate a new container\n           addToNewlyAllocatedContainers(\n               schedulerContainer.getSchedulerNode(), rmContainer);\n           liveContainers.put(containerId, rmContainer);\n \n           // Deduct pending resource requests\n           if (updatePending) {\n             ContainerRequest containerRequest \u003d appSchedulingInfo.allocate(\n                 allocation.getAllocationLocalityType(),\n                 schedulerContainer.getSchedulerNode(),\n                 schedulerContainer.getSchedulerRequestKey(),\n                 schedulerContainer.getRmContainer().getContainer());\n             ((RMContainerImpl) rmContainer).setContainerRequest(\n                 containerRequest);\n \n             // If this is from a SchedulingRequest, set allocation tags.\n             if (containerRequest !\u003d null\n                 \u0026\u0026 containerRequest.getSchedulingRequest() !\u003d null) {\n               ((RMContainerImpl) rmContainer).setAllocationTags(\n                   containerRequest.getSchedulingRequest().getAllocationTags());\n             }\n           } else {\n             AppSchedulingInfo.updateMetrics(getApplicationId(),\n                 allocation.getAllocationLocalityType(),\n                 schedulerContainer.getSchedulerNode(),\n                 schedulerContainer.getRmContainer().getContainer(), getUser(),\n                 getQueue());\n           }\n \n           attemptResourceUsage.incUsed(schedulerContainer.getNodePartition(),\n               allocation.getAllocatedOrReservedResource());\n \n           rmContainer.handle(\n               new RMContainerEvent(containerId, RMContainerEventType.START));\n \n           // Inform the node\n           schedulerContainer.getSchedulerNode().allocateContainer(\n               rmContainer);\n \n           // update locality statistics,\n           incNumAllocatedContainers(allocation.getAllocationLocalityType(),\n               allocation.getRequestLocalityType());\n \n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"allocate: applicationAttemptId\u003d\" + containerId\n                 .getApplicationAttemptId() + \" container\u003d\" + containerId\n                 + \" host\u003d\" + rmContainer.getAllocatedNode().getHost()\n                 + \" type\u003d\" + allocation.getAllocationLocalityType());\n           }\n+          // In order to save space in the audit log, only include the partition\n+          // if it is not the default partition.\n+          String partition \u003d\n+              schedulerContainer.getSchedulerNode().getPartition();\n+          if (partition !\u003d null \u0026\u0026 partition.isEmpty()) {\n+            partition \u003d null;\n+          }\n           RMAuditLogger.logSuccess(getUser(), AuditConstants.ALLOC_CONTAINER,\n               \"SchedulerApp\", getApplicationId(), containerId,\n-              allocation.getAllocatedOrReservedResource());\n+              allocation.getAllocatedOrReservedResource(), getQueueName(),\n+              partition);\n         } else {\n           // If the rmContainer\u0027s state is already updated to RESERVED, this is\n           // a reReservation\n           reserve(schedulerContainer.getSchedulerRequestKey(),\n               schedulerContainer.getSchedulerNode(),\n               schedulerContainer.getRmContainer(),\n               schedulerContainer.getRmContainer().getContainer(),\n               reReservation);\n \n           LOG.info(\"Reserved container\u003d\" + rmContainer.getContainerId()\n               + \", on node\u003d\" + schedulerContainer.getSchedulerNode()\n               + \" with resource\u003d\" + rmContainer\n               .getAllocatedOrReservedResource());\n         }\n       }\n     } finally {\n       writeLock.unlock();\n     }\n \n     // Don\u0027t bother CS leaf queue if it is a re-reservation\n     if (!reReservation) {\n       getCSLeafQueue().apply(cluster, request);\n     }\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean apply(Resource cluster, ResourceCommitRequest\u003cFiCaSchedulerApp,\n      FiCaSchedulerNode\u003e request, boolean updatePending) {\n    boolean reReservation \u003d false;\n\n    try {\n      writeLock.lock();\n\n      // If we allocated something\n      if (request.anythingAllocatedOrReserved()) {\n        ContainerAllocationProposal\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n            allocation \u003d request.getFirstAllocatedOrReservedContainer();\n        SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n            schedulerContainer \u003d allocation.getAllocatedOrReservedContainer();\n\n        // Required sanity check - AM can call \u0027allocate\u0027 to update resource\n        // request without locking the scheduler, hence we need to check\n        if (updatePending \u0026\u0026\n            getOutstandingAsksCount(schedulerContainer.getSchedulerRequestKey())\n                \u003c\u003d 0) {\n          return false;\n        }\n\n        RMContainer rmContainer \u003d schedulerContainer.getRmContainer();\n        reReservation \u003d\n            (!schedulerContainer.isAllocated()) \u0026\u0026 (rmContainer.getState()\n                \u003d\u003d RMContainerState.RESERVED);\n\n        // Generate new containerId if it is not an allocation for increasing\n        // Or re-reservation\n        if (rmContainer.getContainer().getId() \u003d\u003d null) {\n          rmContainer.setContainerId(BuilderUtils\n              .newContainerId(getApplicationAttemptId(),\n                  getNewContainerId()));\n        }\n        ContainerId containerId \u003d rmContainer.getContainerId();\n\n        if (schedulerContainer.isAllocated()) {\n          // This allocation is from a reserved container\n          // Unreserve it first\n          if (allocation.getAllocateFromReservedContainer() !\u003d null) {\n            RMContainer reservedContainer \u003d\n                allocation.getAllocateFromReservedContainer().getRmContainer();\n            // Handling container allocation\n            // Did we previously reserve containers at this \u0027priority\u0027?\n            unreserve(schedulerContainer.getSchedulerRequestKey(),\n                schedulerContainer.getSchedulerNode(), reservedContainer);\n          }\n\n          // Allocate a new container\n          addToNewlyAllocatedContainers(\n              schedulerContainer.getSchedulerNode(), rmContainer);\n          liveContainers.put(containerId, rmContainer);\n\n          // Deduct pending resource requests\n          if (updatePending) {\n            ContainerRequest containerRequest \u003d appSchedulingInfo.allocate(\n                allocation.getAllocationLocalityType(),\n                schedulerContainer.getSchedulerNode(),\n                schedulerContainer.getSchedulerRequestKey(),\n                schedulerContainer.getRmContainer().getContainer());\n            ((RMContainerImpl) rmContainer).setContainerRequest(\n                containerRequest);\n\n            // If this is from a SchedulingRequest, set allocation tags.\n            if (containerRequest !\u003d null\n                \u0026\u0026 containerRequest.getSchedulingRequest() !\u003d null) {\n              ((RMContainerImpl) rmContainer).setAllocationTags(\n                  containerRequest.getSchedulingRequest().getAllocationTags());\n            }\n          } else {\n            AppSchedulingInfo.updateMetrics(getApplicationId(),\n                allocation.getAllocationLocalityType(),\n                schedulerContainer.getSchedulerNode(),\n                schedulerContainer.getRmContainer().getContainer(), getUser(),\n                getQueue());\n          }\n\n          attemptResourceUsage.incUsed(schedulerContainer.getNodePartition(),\n              allocation.getAllocatedOrReservedResource());\n\n          rmContainer.handle(\n              new RMContainerEvent(containerId, RMContainerEventType.START));\n\n          // Inform the node\n          schedulerContainer.getSchedulerNode().allocateContainer(\n              rmContainer);\n\n          // update locality statistics,\n          incNumAllocatedContainers(allocation.getAllocationLocalityType(),\n              allocation.getRequestLocalityType());\n\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"allocate: applicationAttemptId\u003d\" + containerId\n                .getApplicationAttemptId() + \" container\u003d\" + containerId\n                + \" host\u003d\" + rmContainer.getAllocatedNode().getHost()\n                + \" type\u003d\" + allocation.getAllocationLocalityType());\n          }\n          // In order to save space in the audit log, only include the partition\n          // if it is not the default partition.\n          String partition \u003d\n              schedulerContainer.getSchedulerNode().getPartition();\n          if (partition !\u003d null \u0026\u0026 partition.isEmpty()) {\n            partition \u003d null;\n          }\n          RMAuditLogger.logSuccess(getUser(), AuditConstants.ALLOC_CONTAINER,\n              \"SchedulerApp\", getApplicationId(), containerId,\n              allocation.getAllocatedOrReservedResource(), getQueueName(),\n              partition);\n        } else {\n          // If the rmContainer\u0027s state is already updated to RESERVED, this is\n          // a reReservation\n          reserve(schedulerContainer.getSchedulerRequestKey(),\n              schedulerContainer.getSchedulerNode(),\n              schedulerContainer.getRmContainer(),\n              schedulerContainer.getRmContainer().getContainer(),\n              reReservation);\n\n          LOG.info(\"Reserved container\u003d\" + rmContainer.getContainerId()\n              + \", on node\u003d\" + schedulerContainer.getSchedulerNode()\n              + \" with resource\u003d\" + rmContainer\n              .getAllocatedOrReservedResource());\n        }\n      }\n    } finally {\n      writeLock.unlock();\n    }\n\n    // Don\u0027t bother CS leaf queue if it is a re-reservation\n    if (!reReservation) {\n      getCSLeafQueue().apply(cluster, request);\n    }\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/common/fica/FiCaSchedulerApp.java",
      "extendedDetails": {}
    },
    "51654a3962bcd0482c0e1dd32765e9533e3f9158": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8459. Improve Capacity Scheduler logs to debug invalid states. Contributed by Wangda Tan.\n",
      "commitDate": "03/07/18 9:59 AM",
      "commitName": "51654a3962bcd0482c0e1dd32765e9533e3f9158",
      "commitAuthor": "Sunil G",
      "commitDateOld": "11/04/18 2:15 AM",
      "commitNameOld": "7eb783e2634d8c11fb646f1f2fdf597336325312",
      "commitAuthorOld": "Weiwei Yang",
      "daysBetweenCommits": 83.32,
      "commitsBetweenForRepo": 1098,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,120 +1,125 @@\n   public boolean apply(Resource cluster, ResourceCommitRequest\u003cFiCaSchedulerApp,\n       FiCaSchedulerNode\u003e request, boolean updatePending) {\n     boolean reReservation \u003d false;\n \n     try {\n       writeLock.lock();\n \n       // If we allocated something\n       if (request.anythingAllocatedOrReserved()) {\n         ContainerAllocationProposal\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n             allocation \u003d request.getFirstAllocatedOrReservedContainer();\n         SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n             schedulerContainer \u003d allocation.getAllocatedOrReservedContainer();\n \n         // Required sanity check - AM can call \u0027allocate\u0027 to update resource\n         // request without locking the scheduler, hence we need to check\n         if (updatePending \u0026\u0026\n             getOutstandingAsksCount(schedulerContainer.getSchedulerRequestKey())\n                 \u003c\u003d 0) {\n           return false;\n         }\n \n         RMContainer rmContainer \u003d schedulerContainer.getRmContainer();\n         reReservation \u003d\n             (!schedulerContainer.isAllocated()) \u0026\u0026 (rmContainer.getState()\n                 \u003d\u003d RMContainerState.RESERVED);\n \n         // Generate new containerId if it is not an allocation for increasing\n         // Or re-reservation\n         if (rmContainer.getContainer().getId() \u003d\u003d null) {\n           rmContainer.setContainerId(BuilderUtils\n               .newContainerId(getApplicationAttemptId(),\n                   getNewContainerId()));\n         }\n         ContainerId containerId \u003d rmContainer.getContainerId();\n \n         if (schedulerContainer.isAllocated()) {\n           // This allocation is from a reserved container\n           // Unreserve it first\n           if (allocation.getAllocateFromReservedContainer() !\u003d null) {\n             RMContainer reservedContainer \u003d\n                 allocation.getAllocateFromReservedContainer().getRmContainer();\n             // Handling container allocation\n             // Did we previously reserve containers at this \u0027priority\u0027?\n             unreserve(schedulerContainer.getSchedulerRequestKey(),\n                 schedulerContainer.getSchedulerNode(), reservedContainer);\n           }\n \n           // Allocate a new container\n           addToNewlyAllocatedContainers(\n               schedulerContainer.getSchedulerNode(), rmContainer);\n           liveContainers.put(containerId, rmContainer);\n \n           // Deduct pending resource requests\n           if (updatePending) {\n             ContainerRequest containerRequest \u003d appSchedulingInfo.allocate(\n                 allocation.getAllocationLocalityType(),\n                 schedulerContainer.getSchedulerNode(),\n                 schedulerContainer.getSchedulerRequestKey(),\n                 schedulerContainer.getRmContainer().getContainer());\n             ((RMContainerImpl) rmContainer).setContainerRequest(\n                 containerRequest);\n \n             // If this is from a SchedulingRequest, set allocation tags.\n             if (containerRequest !\u003d null\n                 \u0026\u0026 containerRequest.getSchedulingRequest() !\u003d null) {\n               ((RMContainerImpl) rmContainer).setAllocationTags(\n                   containerRequest.getSchedulingRequest().getAllocationTags());\n             }\n           } else {\n             AppSchedulingInfo.updateMetrics(getApplicationId(),\n                 allocation.getAllocationLocalityType(),\n                 schedulerContainer.getSchedulerNode(),\n                 schedulerContainer.getRmContainer().getContainer(), getUser(),\n                 getQueue());\n           }\n \n           attemptResourceUsage.incUsed(schedulerContainer.getNodePartition(),\n               allocation.getAllocatedOrReservedResource());\n \n           rmContainer.handle(\n               new RMContainerEvent(containerId, RMContainerEventType.START));\n \n           // Inform the node\n           schedulerContainer.getSchedulerNode().allocateContainer(\n               rmContainer);\n \n           // update locality statistics,\n           incNumAllocatedContainers(allocation.getAllocationLocalityType(),\n               allocation.getRequestLocalityType());\n \n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"allocate: applicationAttemptId\u003d\" + containerId\n                 .getApplicationAttemptId() + \" container\u003d\" + containerId\n                 + \" host\u003d\" + rmContainer.getAllocatedNode().getHost()\n                 + \" type\u003d\" + allocation.getAllocationLocalityType());\n           }\n           RMAuditLogger.logSuccess(getUser(), AuditConstants.ALLOC_CONTAINER,\n               \"SchedulerApp\", getApplicationId(), containerId,\n               allocation.getAllocatedOrReservedResource());\n         } else {\n           // If the rmContainer\u0027s state is already updated to RESERVED, this is\n           // a reReservation\n           reserve(schedulerContainer.getSchedulerRequestKey(),\n               schedulerContainer.getSchedulerNode(),\n               schedulerContainer.getRmContainer(),\n               schedulerContainer.getRmContainer().getContainer(),\n               reReservation);\n+\n+          LOG.info(\"Reserved container\u003d\" + rmContainer.getContainerId()\n+              + \", on node\u003d\" + schedulerContainer.getSchedulerNode()\n+              + \" with resource\u003d\" + rmContainer\n+              .getAllocatedOrReservedResource());\n         }\n       }\n     } finally {\n       writeLock.unlock();\n     }\n \n     // Don\u0027t bother CS leaf queue if it is a re-reservation\n     if (!reReservation) {\n       getCSLeafQueue().apply(cluster, request);\n     }\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean apply(Resource cluster, ResourceCommitRequest\u003cFiCaSchedulerApp,\n      FiCaSchedulerNode\u003e request, boolean updatePending) {\n    boolean reReservation \u003d false;\n\n    try {\n      writeLock.lock();\n\n      // If we allocated something\n      if (request.anythingAllocatedOrReserved()) {\n        ContainerAllocationProposal\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n            allocation \u003d request.getFirstAllocatedOrReservedContainer();\n        SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n            schedulerContainer \u003d allocation.getAllocatedOrReservedContainer();\n\n        // Required sanity check - AM can call \u0027allocate\u0027 to update resource\n        // request without locking the scheduler, hence we need to check\n        if (updatePending \u0026\u0026\n            getOutstandingAsksCount(schedulerContainer.getSchedulerRequestKey())\n                \u003c\u003d 0) {\n          return false;\n        }\n\n        RMContainer rmContainer \u003d schedulerContainer.getRmContainer();\n        reReservation \u003d\n            (!schedulerContainer.isAllocated()) \u0026\u0026 (rmContainer.getState()\n                \u003d\u003d RMContainerState.RESERVED);\n\n        // Generate new containerId if it is not an allocation for increasing\n        // Or re-reservation\n        if (rmContainer.getContainer().getId() \u003d\u003d null) {\n          rmContainer.setContainerId(BuilderUtils\n              .newContainerId(getApplicationAttemptId(),\n                  getNewContainerId()));\n        }\n        ContainerId containerId \u003d rmContainer.getContainerId();\n\n        if (schedulerContainer.isAllocated()) {\n          // This allocation is from a reserved container\n          // Unreserve it first\n          if (allocation.getAllocateFromReservedContainer() !\u003d null) {\n            RMContainer reservedContainer \u003d\n                allocation.getAllocateFromReservedContainer().getRmContainer();\n            // Handling container allocation\n            // Did we previously reserve containers at this \u0027priority\u0027?\n            unreserve(schedulerContainer.getSchedulerRequestKey(),\n                schedulerContainer.getSchedulerNode(), reservedContainer);\n          }\n\n          // Allocate a new container\n          addToNewlyAllocatedContainers(\n              schedulerContainer.getSchedulerNode(), rmContainer);\n          liveContainers.put(containerId, rmContainer);\n\n          // Deduct pending resource requests\n          if (updatePending) {\n            ContainerRequest containerRequest \u003d appSchedulingInfo.allocate(\n                allocation.getAllocationLocalityType(),\n                schedulerContainer.getSchedulerNode(),\n                schedulerContainer.getSchedulerRequestKey(),\n                schedulerContainer.getRmContainer().getContainer());\n            ((RMContainerImpl) rmContainer).setContainerRequest(\n                containerRequest);\n\n            // If this is from a SchedulingRequest, set allocation tags.\n            if (containerRequest !\u003d null\n                \u0026\u0026 containerRequest.getSchedulingRequest() !\u003d null) {\n              ((RMContainerImpl) rmContainer).setAllocationTags(\n                  containerRequest.getSchedulingRequest().getAllocationTags());\n            }\n          } else {\n            AppSchedulingInfo.updateMetrics(getApplicationId(),\n                allocation.getAllocationLocalityType(),\n                schedulerContainer.getSchedulerNode(),\n                schedulerContainer.getRmContainer().getContainer(), getUser(),\n                getQueue());\n          }\n\n          attemptResourceUsage.incUsed(schedulerContainer.getNodePartition(),\n              allocation.getAllocatedOrReservedResource());\n\n          rmContainer.handle(\n              new RMContainerEvent(containerId, RMContainerEventType.START));\n\n          // Inform the node\n          schedulerContainer.getSchedulerNode().allocateContainer(\n              rmContainer);\n\n          // update locality statistics,\n          incNumAllocatedContainers(allocation.getAllocationLocalityType(),\n              allocation.getRequestLocalityType());\n\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"allocate: applicationAttemptId\u003d\" + containerId\n                .getApplicationAttemptId() + \" container\u003d\" + containerId\n                + \" host\u003d\" + rmContainer.getAllocatedNode().getHost()\n                + \" type\u003d\" + allocation.getAllocationLocalityType());\n          }\n          RMAuditLogger.logSuccess(getUser(), AuditConstants.ALLOC_CONTAINER,\n              \"SchedulerApp\", getApplicationId(), containerId,\n              allocation.getAllocatedOrReservedResource());\n        } else {\n          // If the rmContainer\u0027s state is already updated to RESERVED, this is\n          // a reReservation\n          reserve(schedulerContainer.getSchedulerRequestKey(),\n              schedulerContainer.getSchedulerNode(),\n              schedulerContainer.getRmContainer(),\n              schedulerContainer.getRmContainer().getContainer(),\n              reReservation);\n\n          LOG.info(\"Reserved container\u003d\" + rmContainer.getContainerId()\n              + \", on node\u003d\" + schedulerContainer.getSchedulerNode()\n              + \" with resource\u003d\" + rmContainer\n              .getAllocatedOrReservedResource());\n        }\n      }\n    } finally {\n      writeLock.unlock();\n    }\n\n    // Don\u0027t bother CS leaf queue if it is a re-reservation\n    if (!reReservation) {\n      getCSLeafQueue().apply(cluster, request);\n    }\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/common/fica/FiCaSchedulerApp.java",
      "extendedDetails": {}
    },
    "47f711eebca315804c80012eea5f31275ac25518": {
      "type": "Ymultichange(Yreturntypechange,Ybodychange)",
      "commitMessage": "YARN-6629. NPE occurred when container allocation proposal is applied but its resource requests are removed before. (Tao Yang via wangda)\n\nChange-Id: I805880f90b3f6798ec96ed8e8e75755f390a9ad5\n",
      "commitDate": "28/03/18 11:07 AM",
      "commitName": "47f711eebca315804c80012eea5f31275ac25518",
      "commitAuthor": "Wangda Tan",
      "subchanges": [
        {
          "type": "Yreturntypechange",
          "commitMessage": "YARN-6629. NPE occurred when container allocation proposal is applied but its resource requests are removed before. (Tao Yang via wangda)\n\nChange-Id: I805880f90b3f6798ec96ed8e8e75755f390a9ad5\n",
          "commitDate": "28/03/18 11:07 AM",
          "commitName": "47f711eebca315804c80012eea5f31275ac25518",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "31/01/18 1:30 AM",
          "commitNameOld": "f8c5f5b23732a1e35f012c1a6850bed09c8a5180",
          "commitAuthorOld": "Arun Suresh",
          "daysBetweenCommits": 56.36,
          "commitsBetweenForRepo": 500,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,110 +1,120 @@\n-  public void apply(Resource cluster, ResourceCommitRequest\u003cFiCaSchedulerApp,\n+  public boolean apply(Resource cluster, ResourceCommitRequest\u003cFiCaSchedulerApp,\n       FiCaSchedulerNode\u003e request, boolean updatePending) {\n     boolean reReservation \u003d false;\n \n     try {\n       writeLock.lock();\n \n       // If we allocated something\n       if (request.anythingAllocatedOrReserved()) {\n         ContainerAllocationProposal\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n             allocation \u003d request.getFirstAllocatedOrReservedContainer();\n         SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n             schedulerContainer \u003d allocation.getAllocatedOrReservedContainer();\n-        RMContainer rmContainer \u003d schedulerContainer.getRmContainer();\n \n+        // Required sanity check - AM can call \u0027allocate\u0027 to update resource\n+        // request without locking the scheduler, hence we need to check\n+        if (updatePending \u0026\u0026\n+            getOutstandingAsksCount(schedulerContainer.getSchedulerRequestKey())\n+                \u003c\u003d 0) {\n+          return false;\n+        }\n+\n+        RMContainer rmContainer \u003d schedulerContainer.getRmContainer();\n         reReservation \u003d\n             (!schedulerContainer.isAllocated()) \u0026\u0026 (rmContainer.getState()\n                 \u003d\u003d RMContainerState.RESERVED);\n \n         // Generate new containerId if it is not an allocation for increasing\n         // Or re-reservation\n         if (rmContainer.getContainer().getId() \u003d\u003d null) {\n           rmContainer.setContainerId(BuilderUtils\n               .newContainerId(getApplicationAttemptId(),\n                   getNewContainerId()));\n         }\n         ContainerId containerId \u003d rmContainer.getContainerId();\n \n         if (schedulerContainer.isAllocated()) {\n           // This allocation is from a reserved container\n           // Unreserve it first\n           if (allocation.getAllocateFromReservedContainer() !\u003d null) {\n             RMContainer reservedContainer \u003d\n                 allocation.getAllocateFromReservedContainer().getRmContainer();\n             // Handling container allocation\n             // Did we previously reserve containers at this \u0027priority\u0027?\n             unreserve(schedulerContainer.getSchedulerRequestKey(),\n                 schedulerContainer.getSchedulerNode(), reservedContainer);\n           }\n \n           // Allocate a new container\n           addToNewlyAllocatedContainers(\n               schedulerContainer.getSchedulerNode(), rmContainer);\n           liveContainers.put(containerId, rmContainer);\n \n           // Deduct pending resource requests\n           if (updatePending) {\n             ContainerRequest containerRequest \u003d appSchedulingInfo.allocate(\n                 allocation.getAllocationLocalityType(),\n                 schedulerContainer.getSchedulerNode(),\n                 schedulerContainer.getSchedulerRequestKey(),\n                 schedulerContainer.getRmContainer().getContainer());\n             ((RMContainerImpl) rmContainer).setContainerRequest(\n                 containerRequest);\n \n             // If this is from a SchedulingRequest, set allocation tags.\n-            if (containerRequest.getSchedulingRequest() !\u003d null) {\n+            if (containerRequest !\u003d null\n+                \u0026\u0026 containerRequest.getSchedulingRequest() !\u003d null) {\n               ((RMContainerImpl) rmContainer).setAllocationTags(\n                   containerRequest.getSchedulingRequest().getAllocationTags());\n             }\n           } else {\n             AppSchedulingInfo.updateMetrics(getApplicationId(),\n                 allocation.getAllocationLocalityType(),\n                 schedulerContainer.getSchedulerNode(),\n                 schedulerContainer.getRmContainer().getContainer(), getUser(),\n                 getQueue());\n           }\n \n           attemptResourceUsage.incUsed(schedulerContainer.getNodePartition(),\n               allocation.getAllocatedOrReservedResource());\n \n           rmContainer.handle(\n               new RMContainerEvent(containerId, RMContainerEventType.START));\n \n           // Inform the node\n           schedulerContainer.getSchedulerNode().allocateContainer(\n               rmContainer);\n \n           // update locality statistics,\n           incNumAllocatedContainers(allocation.getAllocationLocalityType(),\n               allocation.getRequestLocalityType());\n \n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"allocate: applicationAttemptId\u003d\" + containerId\n                 .getApplicationAttemptId() + \" container\u003d\" + containerId\n                 + \" host\u003d\" + rmContainer.getAllocatedNode().getHost()\n                 + \" type\u003d\" + allocation.getAllocationLocalityType());\n           }\n           RMAuditLogger.logSuccess(getUser(), AuditConstants.ALLOC_CONTAINER,\n               \"SchedulerApp\", getApplicationId(), containerId,\n               allocation.getAllocatedOrReservedResource());\n         } else {\n           // If the rmContainer\u0027s state is already updated to RESERVED, this is\n           // a reReservation\n           reserve(schedulerContainer.getSchedulerRequestKey(),\n               schedulerContainer.getSchedulerNode(),\n               schedulerContainer.getRmContainer(),\n               schedulerContainer.getRmContainer().getContainer(),\n               reReservation);\n         }\n       }\n     } finally {\n       writeLock.unlock();\n     }\n \n     // Don\u0027t bother CS leaf queue if it is a re-reservation\n     if (!reReservation) {\n       getCSLeafQueue().apply(cluster, request);\n     }\n+    return true;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public boolean apply(Resource cluster, ResourceCommitRequest\u003cFiCaSchedulerApp,\n      FiCaSchedulerNode\u003e request, boolean updatePending) {\n    boolean reReservation \u003d false;\n\n    try {\n      writeLock.lock();\n\n      // If we allocated something\n      if (request.anythingAllocatedOrReserved()) {\n        ContainerAllocationProposal\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n            allocation \u003d request.getFirstAllocatedOrReservedContainer();\n        SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n            schedulerContainer \u003d allocation.getAllocatedOrReservedContainer();\n\n        // Required sanity check - AM can call \u0027allocate\u0027 to update resource\n        // request without locking the scheduler, hence we need to check\n        if (updatePending \u0026\u0026\n            getOutstandingAsksCount(schedulerContainer.getSchedulerRequestKey())\n                \u003c\u003d 0) {\n          return false;\n        }\n\n        RMContainer rmContainer \u003d schedulerContainer.getRmContainer();\n        reReservation \u003d\n            (!schedulerContainer.isAllocated()) \u0026\u0026 (rmContainer.getState()\n                \u003d\u003d RMContainerState.RESERVED);\n\n        // Generate new containerId if it is not an allocation for increasing\n        // Or re-reservation\n        if (rmContainer.getContainer().getId() \u003d\u003d null) {\n          rmContainer.setContainerId(BuilderUtils\n              .newContainerId(getApplicationAttemptId(),\n                  getNewContainerId()));\n        }\n        ContainerId containerId \u003d rmContainer.getContainerId();\n\n        if (schedulerContainer.isAllocated()) {\n          // This allocation is from a reserved container\n          // Unreserve it first\n          if (allocation.getAllocateFromReservedContainer() !\u003d null) {\n            RMContainer reservedContainer \u003d\n                allocation.getAllocateFromReservedContainer().getRmContainer();\n            // Handling container allocation\n            // Did we previously reserve containers at this \u0027priority\u0027?\n            unreserve(schedulerContainer.getSchedulerRequestKey(),\n                schedulerContainer.getSchedulerNode(), reservedContainer);\n          }\n\n          // Allocate a new container\n          addToNewlyAllocatedContainers(\n              schedulerContainer.getSchedulerNode(), rmContainer);\n          liveContainers.put(containerId, rmContainer);\n\n          // Deduct pending resource requests\n          if (updatePending) {\n            ContainerRequest containerRequest \u003d appSchedulingInfo.allocate(\n                allocation.getAllocationLocalityType(),\n                schedulerContainer.getSchedulerNode(),\n                schedulerContainer.getSchedulerRequestKey(),\n                schedulerContainer.getRmContainer().getContainer());\n            ((RMContainerImpl) rmContainer).setContainerRequest(\n                containerRequest);\n\n            // If this is from a SchedulingRequest, set allocation tags.\n            if (containerRequest !\u003d null\n                \u0026\u0026 containerRequest.getSchedulingRequest() !\u003d null) {\n              ((RMContainerImpl) rmContainer).setAllocationTags(\n                  containerRequest.getSchedulingRequest().getAllocationTags());\n            }\n          } else {\n            AppSchedulingInfo.updateMetrics(getApplicationId(),\n                allocation.getAllocationLocalityType(),\n                schedulerContainer.getSchedulerNode(),\n                schedulerContainer.getRmContainer().getContainer(), getUser(),\n                getQueue());\n          }\n\n          attemptResourceUsage.incUsed(schedulerContainer.getNodePartition(),\n              allocation.getAllocatedOrReservedResource());\n\n          rmContainer.handle(\n              new RMContainerEvent(containerId, RMContainerEventType.START));\n\n          // Inform the node\n          schedulerContainer.getSchedulerNode().allocateContainer(\n              rmContainer);\n\n          // update locality statistics,\n          incNumAllocatedContainers(allocation.getAllocationLocalityType(),\n              allocation.getRequestLocalityType());\n\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"allocate: applicationAttemptId\u003d\" + containerId\n                .getApplicationAttemptId() + \" container\u003d\" + containerId\n                + \" host\u003d\" + rmContainer.getAllocatedNode().getHost()\n                + \" type\u003d\" + allocation.getAllocationLocalityType());\n          }\n          RMAuditLogger.logSuccess(getUser(), AuditConstants.ALLOC_CONTAINER,\n              \"SchedulerApp\", getApplicationId(), containerId,\n              allocation.getAllocatedOrReservedResource());\n        } else {\n          // If the rmContainer\u0027s state is already updated to RESERVED, this is\n          // a reReservation\n          reserve(schedulerContainer.getSchedulerRequestKey(),\n              schedulerContainer.getSchedulerNode(),\n              schedulerContainer.getRmContainer(),\n              schedulerContainer.getRmContainer().getContainer(),\n              reReservation);\n        }\n      }\n    } finally {\n      writeLock.unlock();\n    }\n\n    // Don\u0027t bother CS leaf queue if it is a re-reservation\n    if (!reReservation) {\n      getCSLeafQueue().apply(cluster, request);\n    }\n    return true;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/common/fica/FiCaSchedulerApp.java",
          "extendedDetails": {
            "oldValue": "void",
            "newValue": "boolean"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-6629. NPE occurred when container allocation proposal is applied but its resource requests are removed before. (Tao Yang via wangda)\n\nChange-Id: I805880f90b3f6798ec96ed8e8e75755f390a9ad5\n",
          "commitDate": "28/03/18 11:07 AM",
          "commitName": "47f711eebca315804c80012eea5f31275ac25518",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "31/01/18 1:30 AM",
          "commitNameOld": "f8c5f5b23732a1e35f012c1a6850bed09c8a5180",
          "commitAuthorOld": "Arun Suresh",
          "daysBetweenCommits": 56.36,
          "commitsBetweenForRepo": 500,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,110 +1,120 @@\n-  public void apply(Resource cluster, ResourceCommitRequest\u003cFiCaSchedulerApp,\n+  public boolean apply(Resource cluster, ResourceCommitRequest\u003cFiCaSchedulerApp,\n       FiCaSchedulerNode\u003e request, boolean updatePending) {\n     boolean reReservation \u003d false;\n \n     try {\n       writeLock.lock();\n \n       // If we allocated something\n       if (request.anythingAllocatedOrReserved()) {\n         ContainerAllocationProposal\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n             allocation \u003d request.getFirstAllocatedOrReservedContainer();\n         SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n             schedulerContainer \u003d allocation.getAllocatedOrReservedContainer();\n-        RMContainer rmContainer \u003d schedulerContainer.getRmContainer();\n \n+        // Required sanity check - AM can call \u0027allocate\u0027 to update resource\n+        // request without locking the scheduler, hence we need to check\n+        if (updatePending \u0026\u0026\n+            getOutstandingAsksCount(schedulerContainer.getSchedulerRequestKey())\n+                \u003c\u003d 0) {\n+          return false;\n+        }\n+\n+        RMContainer rmContainer \u003d schedulerContainer.getRmContainer();\n         reReservation \u003d\n             (!schedulerContainer.isAllocated()) \u0026\u0026 (rmContainer.getState()\n                 \u003d\u003d RMContainerState.RESERVED);\n \n         // Generate new containerId if it is not an allocation for increasing\n         // Or re-reservation\n         if (rmContainer.getContainer().getId() \u003d\u003d null) {\n           rmContainer.setContainerId(BuilderUtils\n               .newContainerId(getApplicationAttemptId(),\n                   getNewContainerId()));\n         }\n         ContainerId containerId \u003d rmContainer.getContainerId();\n \n         if (schedulerContainer.isAllocated()) {\n           // This allocation is from a reserved container\n           // Unreserve it first\n           if (allocation.getAllocateFromReservedContainer() !\u003d null) {\n             RMContainer reservedContainer \u003d\n                 allocation.getAllocateFromReservedContainer().getRmContainer();\n             // Handling container allocation\n             // Did we previously reserve containers at this \u0027priority\u0027?\n             unreserve(schedulerContainer.getSchedulerRequestKey(),\n                 schedulerContainer.getSchedulerNode(), reservedContainer);\n           }\n \n           // Allocate a new container\n           addToNewlyAllocatedContainers(\n               schedulerContainer.getSchedulerNode(), rmContainer);\n           liveContainers.put(containerId, rmContainer);\n \n           // Deduct pending resource requests\n           if (updatePending) {\n             ContainerRequest containerRequest \u003d appSchedulingInfo.allocate(\n                 allocation.getAllocationLocalityType(),\n                 schedulerContainer.getSchedulerNode(),\n                 schedulerContainer.getSchedulerRequestKey(),\n                 schedulerContainer.getRmContainer().getContainer());\n             ((RMContainerImpl) rmContainer).setContainerRequest(\n                 containerRequest);\n \n             // If this is from a SchedulingRequest, set allocation tags.\n-            if (containerRequest.getSchedulingRequest() !\u003d null) {\n+            if (containerRequest !\u003d null\n+                \u0026\u0026 containerRequest.getSchedulingRequest() !\u003d null) {\n               ((RMContainerImpl) rmContainer).setAllocationTags(\n                   containerRequest.getSchedulingRequest().getAllocationTags());\n             }\n           } else {\n             AppSchedulingInfo.updateMetrics(getApplicationId(),\n                 allocation.getAllocationLocalityType(),\n                 schedulerContainer.getSchedulerNode(),\n                 schedulerContainer.getRmContainer().getContainer(), getUser(),\n                 getQueue());\n           }\n \n           attemptResourceUsage.incUsed(schedulerContainer.getNodePartition(),\n               allocation.getAllocatedOrReservedResource());\n \n           rmContainer.handle(\n               new RMContainerEvent(containerId, RMContainerEventType.START));\n \n           // Inform the node\n           schedulerContainer.getSchedulerNode().allocateContainer(\n               rmContainer);\n \n           // update locality statistics,\n           incNumAllocatedContainers(allocation.getAllocationLocalityType(),\n               allocation.getRequestLocalityType());\n \n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"allocate: applicationAttemptId\u003d\" + containerId\n                 .getApplicationAttemptId() + \" container\u003d\" + containerId\n                 + \" host\u003d\" + rmContainer.getAllocatedNode().getHost()\n                 + \" type\u003d\" + allocation.getAllocationLocalityType());\n           }\n           RMAuditLogger.logSuccess(getUser(), AuditConstants.ALLOC_CONTAINER,\n               \"SchedulerApp\", getApplicationId(), containerId,\n               allocation.getAllocatedOrReservedResource());\n         } else {\n           // If the rmContainer\u0027s state is already updated to RESERVED, this is\n           // a reReservation\n           reserve(schedulerContainer.getSchedulerRequestKey(),\n               schedulerContainer.getSchedulerNode(),\n               schedulerContainer.getRmContainer(),\n               schedulerContainer.getRmContainer().getContainer(),\n               reReservation);\n         }\n       }\n     } finally {\n       writeLock.unlock();\n     }\n \n     // Don\u0027t bother CS leaf queue if it is a re-reservation\n     if (!reReservation) {\n       getCSLeafQueue().apply(cluster, request);\n     }\n+    return true;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public boolean apply(Resource cluster, ResourceCommitRequest\u003cFiCaSchedulerApp,\n      FiCaSchedulerNode\u003e request, boolean updatePending) {\n    boolean reReservation \u003d false;\n\n    try {\n      writeLock.lock();\n\n      // If we allocated something\n      if (request.anythingAllocatedOrReserved()) {\n        ContainerAllocationProposal\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n            allocation \u003d request.getFirstAllocatedOrReservedContainer();\n        SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n            schedulerContainer \u003d allocation.getAllocatedOrReservedContainer();\n\n        // Required sanity check - AM can call \u0027allocate\u0027 to update resource\n        // request without locking the scheduler, hence we need to check\n        if (updatePending \u0026\u0026\n            getOutstandingAsksCount(schedulerContainer.getSchedulerRequestKey())\n                \u003c\u003d 0) {\n          return false;\n        }\n\n        RMContainer rmContainer \u003d schedulerContainer.getRmContainer();\n        reReservation \u003d\n            (!schedulerContainer.isAllocated()) \u0026\u0026 (rmContainer.getState()\n                \u003d\u003d RMContainerState.RESERVED);\n\n        // Generate new containerId if it is not an allocation for increasing\n        // Or re-reservation\n        if (rmContainer.getContainer().getId() \u003d\u003d null) {\n          rmContainer.setContainerId(BuilderUtils\n              .newContainerId(getApplicationAttemptId(),\n                  getNewContainerId()));\n        }\n        ContainerId containerId \u003d rmContainer.getContainerId();\n\n        if (schedulerContainer.isAllocated()) {\n          // This allocation is from a reserved container\n          // Unreserve it first\n          if (allocation.getAllocateFromReservedContainer() !\u003d null) {\n            RMContainer reservedContainer \u003d\n                allocation.getAllocateFromReservedContainer().getRmContainer();\n            // Handling container allocation\n            // Did we previously reserve containers at this \u0027priority\u0027?\n            unreserve(schedulerContainer.getSchedulerRequestKey(),\n                schedulerContainer.getSchedulerNode(), reservedContainer);\n          }\n\n          // Allocate a new container\n          addToNewlyAllocatedContainers(\n              schedulerContainer.getSchedulerNode(), rmContainer);\n          liveContainers.put(containerId, rmContainer);\n\n          // Deduct pending resource requests\n          if (updatePending) {\n            ContainerRequest containerRequest \u003d appSchedulingInfo.allocate(\n                allocation.getAllocationLocalityType(),\n                schedulerContainer.getSchedulerNode(),\n                schedulerContainer.getSchedulerRequestKey(),\n                schedulerContainer.getRmContainer().getContainer());\n            ((RMContainerImpl) rmContainer).setContainerRequest(\n                containerRequest);\n\n            // If this is from a SchedulingRequest, set allocation tags.\n            if (containerRequest !\u003d null\n                \u0026\u0026 containerRequest.getSchedulingRequest() !\u003d null) {\n              ((RMContainerImpl) rmContainer).setAllocationTags(\n                  containerRequest.getSchedulingRequest().getAllocationTags());\n            }\n          } else {\n            AppSchedulingInfo.updateMetrics(getApplicationId(),\n                allocation.getAllocationLocalityType(),\n                schedulerContainer.getSchedulerNode(),\n                schedulerContainer.getRmContainer().getContainer(), getUser(),\n                getQueue());\n          }\n\n          attemptResourceUsage.incUsed(schedulerContainer.getNodePartition(),\n              allocation.getAllocatedOrReservedResource());\n\n          rmContainer.handle(\n              new RMContainerEvent(containerId, RMContainerEventType.START));\n\n          // Inform the node\n          schedulerContainer.getSchedulerNode().allocateContainer(\n              rmContainer);\n\n          // update locality statistics,\n          incNumAllocatedContainers(allocation.getAllocationLocalityType(),\n              allocation.getRequestLocalityType());\n\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"allocate: applicationAttemptId\u003d\" + containerId\n                .getApplicationAttemptId() + \" container\u003d\" + containerId\n                + \" host\u003d\" + rmContainer.getAllocatedNode().getHost()\n                + \" type\u003d\" + allocation.getAllocationLocalityType());\n          }\n          RMAuditLogger.logSuccess(getUser(), AuditConstants.ALLOC_CONTAINER,\n              \"SchedulerApp\", getApplicationId(), containerId,\n              allocation.getAllocatedOrReservedResource());\n        } else {\n          // If the rmContainer\u0027s state is already updated to RESERVED, this is\n          // a reReservation\n          reserve(schedulerContainer.getSchedulerRequestKey(),\n              schedulerContainer.getSchedulerNode(),\n              schedulerContainer.getRmContainer(),\n              schedulerContainer.getRmContainer().getContainer(),\n              reReservation);\n        }\n      }\n    } finally {\n      writeLock.unlock();\n    }\n\n    // Don\u0027t bother CS leaf queue if it is a re-reservation\n    if (!reReservation) {\n      getCSLeafQueue().apply(cluster, request);\n    }\n    return true;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/common/fica/FiCaSchedulerApp.java",
          "extendedDetails": {}
        }
      ]
    },
    "f8c5f5b23732a1e35f012c1a6850bed09c8a5180": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7784. Fix Cluster metrics when placement processor is enabled. (asuresh)\n",
      "commitDate": "31/01/18 1:30 AM",
      "commitName": "f8c5f5b23732a1e35f012c1a6850bed09c8a5180",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "31/01/18 1:30 AM",
      "commitNameOld": "38af23796971193fa529c3d08ffde8fcd6e607b6",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,104 +1,110 @@\n   public void apply(Resource cluster, ResourceCommitRequest\u003cFiCaSchedulerApp,\n       FiCaSchedulerNode\u003e request, boolean updatePending) {\n     boolean reReservation \u003d false;\n \n     try {\n       writeLock.lock();\n \n       // If we allocated something\n       if (request.anythingAllocatedOrReserved()) {\n         ContainerAllocationProposal\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n             allocation \u003d request.getFirstAllocatedOrReservedContainer();\n         SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n             schedulerContainer \u003d allocation.getAllocatedOrReservedContainer();\n         RMContainer rmContainer \u003d schedulerContainer.getRmContainer();\n \n         reReservation \u003d\n             (!schedulerContainer.isAllocated()) \u0026\u0026 (rmContainer.getState()\n                 \u003d\u003d RMContainerState.RESERVED);\n \n         // Generate new containerId if it is not an allocation for increasing\n         // Or re-reservation\n         if (rmContainer.getContainer().getId() \u003d\u003d null) {\n           rmContainer.setContainerId(BuilderUtils\n               .newContainerId(getApplicationAttemptId(),\n                   getNewContainerId()));\n         }\n         ContainerId containerId \u003d rmContainer.getContainerId();\n \n         if (schedulerContainer.isAllocated()) {\n           // This allocation is from a reserved container\n           // Unreserve it first\n           if (allocation.getAllocateFromReservedContainer() !\u003d null) {\n             RMContainer reservedContainer \u003d\n                 allocation.getAllocateFromReservedContainer().getRmContainer();\n             // Handling container allocation\n             // Did we previously reserve containers at this \u0027priority\u0027?\n             unreserve(schedulerContainer.getSchedulerRequestKey(),\n                 schedulerContainer.getSchedulerNode(), reservedContainer);\n           }\n \n           // Allocate a new container\n           addToNewlyAllocatedContainers(\n               schedulerContainer.getSchedulerNode(), rmContainer);\n           liveContainers.put(containerId, rmContainer);\n \n           // Deduct pending resource requests\n           if (updatePending) {\n             ContainerRequest containerRequest \u003d appSchedulingInfo.allocate(\n                 allocation.getAllocationLocalityType(),\n                 schedulerContainer.getSchedulerNode(),\n                 schedulerContainer.getSchedulerRequestKey(),\n                 schedulerContainer.getRmContainer().getContainer());\n             ((RMContainerImpl) rmContainer).setContainerRequest(\n                 containerRequest);\n \n             // If this is from a SchedulingRequest, set allocation tags.\n             if (containerRequest.getSchedulingRequest() !\u003d null) {\n               ((RMContainerImpl) rmContainer).setAllocationTags(\n                   containerRequest.getSchedulingRequest().getAllocationTags());\n             }\n+          } else {\n+            AppSchedulingInfo.updateMetrics(getApplicationId(),\n+                allocation.getAllocationLocalityType(),\n+                schedulerContainer.getSchedulerNode(),\n+                schedulerContainer.getRmContainer().getContainer(), getUser(),\n+                getQueue());\n           }\n \n           attemptResourceUsage.incUsed(schedulerContainer.getNodePartition(),\n               allocation.getAllocatedOrReservedResource());\n \n           rmContainer.handle(\n               new RMContainerEvent(containerId, RMContainerEventType.START));\n \n           // Inform the node\n           schedulerContainer.getSchedulerNode().allocateContainer(\n               rmContainer);\n \n           // update locality statistics,\n           incNumAllocatedContainers(allocation.getAllocationLocalityType(),\n               allocation.getRequestLocalityType());\n \n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"allocate: applicationAttemptId\u003d\" + containerId\n                 .getApplicationAttemptId() + \" container\u003d\" + containerId\n                 + \" host\u003d\" + rmContainer.getAllocatedNode().getHost()\n                 + \" type\u003d\" + allocation.getAllocationLocalityType());\n           }\n           RMAuditLogger.logSuccess(getUser(), AuditConstants.ALLOC_CONTAINER,\n               \"SchedulerApp\", getApplicationId(), containerId,\n               allocation.getAllocatedOrReservedResource());\n         } else {\n           // If the rmContainer\u0027s state is already updated to RESERVED, this is\n           // a reReservation\n           reserve(schedulerContainer.getSchedulerRequestKey(),\n               schedulerContainer.getSchedulerNode(),\n               schedulerContainer.getRmContainer(),\n               schedulerContainer.getRmContainer().getContainer(),\n               reReservation);\n         }\n       }\n     } finally {\n       writeLock.unlock();\n     }\n \n     // Don\u0027t bother CS leaf queue if it is a re-reservation\n     if (!reReservation) {\n       getCSLeafQueue().apply(cluster, request);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void apply(Resource cluster, ResourceCommitRequest\u003cFiCaSchedulerApp,\n      FiCaSchedulerNode\u003e request, boolean updatePending) {\n    boolean reReservation \u003d false;\n\n    try {\n      writeLock.lock();\n\n      // If we allocated something\n      if (request.anythingAllocatedOrReserved()) {\n        ContainerAllocationProposal\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n            allocation \u003d request.getFirstAllocatedOrReservedContainer();\n        SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n            schedulerContainer \u003d allocation.getAllocatedOrReservedContainer();\n        RMContainer rmContainer \u003d schedulerContainer.getRmContainer();\n\n        reReservation \u003d\n            (!schedulerContainer.isAllocated()) \u0026\u0026 (rmContainer.getState()\n                \u003d\u003d RMContainerState.RESERVED);\n\n        // Generate new containerId if it is not an allocation for increasing\n        // Or re-reservation\n        if (rmContainer.getContainer().getId() \u003d\u003d null) {\n          rmContainer.setContainerId(BuilderUtils\n              .newContainerId(getApplicationAttemptId(),\n                  getNewContainerId()));\n        }\n        ContainerId containerId \u003d rmContainer.getContainerId();\n\n        if (schedulerContainer.isAllocated()) {\n          // This allocation is from a reserved container\n          // Unreserve it first\n          if (allocation.getAllocateFromReservedContainer() !\u003d null) {\n            RMContainer reservedContainer \u003d\n                allocation.getAllocateFromReservedContainer().getRmContainer();\n            // Handling container allocation\n            // Did we previously reserve containers at this \u0027priority\u0027?\n            unreserve(schedulerContainer.getSchedulerRequestKey(),\n                schedulerContainer.getSchedulerNode(), reservedContainer);\n          }\n\n          // Allocate a new container\n          addToNewlyAllocatedContainers(\n              schedulerContainer.getSchedulerNode(), rmContainer);\n          liveContainers.put(containerId, rmContainer);\n\n          // Deduct pending resource requests\n          if (updatePending) {\n            ContainerRequest containerRequest \u003d appSchedulingInfo.allocate(\n                allocation.getAllocationLocalityType(),\n                schedulerContainer.getSchedulerNode(),\n                schedulerContainer.getSchedulerRequestKey(),\n                schedulerContainer.getRmContainer().getContainer());\n            ((RMContainerImpl) rmContainer).setContainerRequest(\n                containerRequest);\n\n            // If this is from a SchedulingRequest, set allocation tags.\n            if (containerRequest.getSchedulingRequest() !\u003d null) {\n              ((RMContainerImpl) rmContainer).setAllocationTags(\n                  containerRequest.getSchedulingRequest().getAllocationTags());\n            }\n          } else {\n            AppSchedulingInfo.updateMetrics(getApplicationId(),\n                allocation.getAllocationLocalityType(),\n                schedulerContainer.getSchedulerNode(),\n                schedulerContainer.getRmContainer().getContainer(), getUser(),\n                getQueue());\n          }\n\n          attemptResourceUsage.incUsed(schedulerContainer.getNodePartition(),\n              allocation.getAllocatedOrReservedResource());\n\n          rmContainer.handle(\n              new RMContainerEvent(containerId, RMContainerEventType.START));\n\n          // Inform the node\n          schedulerContainer.getSchedulerNode().allocateContainer(\n              rmContainer);\n\n          // update locality statistics,\n          incNumAllocatedContainers(allocation.getAllocationLocalityType(),\n              allocation.getRequestLocalityType());\n\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"allocate: applicationAttemptId\u003d\" + containerId\n                .getApplicationAttemptId() + \" container\u003d\" + containerId\n                + \" host\u003d\" + rmContainer.getAllocatedNode().getHost()\n                + \" type\u003d\" + allocation.getAllocationLocalityType());\n          }\n          RMAuditLogger.logSuccess(getUser(), AuditConstants.ALLOC_CONTAINER,\n              \"SchedulerApp\", getApplicationId(), containerId,\n              allocation.getAllocatedOrReservedResource());\n        } else {\n          // If the rmContainer\u0027s state is already updated to RESERVED, this is\n          // a reReservation\n          reserve(schedulerContainer.getSchedulerRequestKey(),\n              schedulerContainer.getSchedulerNode(),\n              schedulerContainer.getRmContainer(),\n              schedulerContainer.getRmContainer().getContainer(),\n              reReservation);\n        }\n      }\n    } finally {\n      writeLock.unlock();\n    }\n\n    // Don\u0027t bother CS leaf queue if it is a re-reservation\n    if (!reReservation) {\n      getCSLeafQueue().apply(cluster, request);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/common/fica/FiCaSchedulerApp.java",
      "extendedDetails": {}
    },
    "38af23796971193fa529c3d08ffde8fcd6e607b6": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6599. Support anti-affinity constraint via AppPlacementAllocator. (Wangda Tan via asuresh)\n",
      "commitDate": "31/01/18 1:30 AM",
      "commitName": "38af23796971193fa529c3d08ffde8fcd6e607b6",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "31/01/18 1:30 AM",
      "commitNameOld": "88d8d3f40b2923fab23a933bce1cd2e9c320ae84",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,98 +1,104 @@\n   public void apply(Resource cluster, ResourceCommitRequest\u003cFiCaSchedulerApp,\n       FiCaSchedulerNode\u003e request, boolean updatePending) {\n     boolean reReservation \u003d false;\n \n     try {\n       writeLock.lock();\n \n       // If we allocated something\n       if (request.anythingAllocatedOrReserved()) {\n         ContainerAllocationProposal\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n             allocation \u003d request.getFirstAllocatedOrReservedContainer();\n         SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n             schedulerContainer \u003d allocation.getAllocatedOrReservedContainer();\n         RMContainer rmContainer \u003d schedulerContainer.getRmContainer();\n \n         reReservation \u003d\n             (!schedulerContainer.isAllocated()) \u0026\u0026 (rmContainer.getState()\n                 \u003d\u003d RMContainerState.RESERVED);\n \n         // Generate new containerId if it is not an allocation for increasing\n         // Or re-reservation\n         if (rmContainer.getContainer().getId() \u003d\u003d null) {\n           rmContainer.setContainerId(BuilderUtils\n               .newContainerId(getApplicationAttemptId(),\n                   getNewContainerId()));\n         }\n         ContainerId containerId \u003d rmContainer.getContainerId();\n \n         if (schedulerContainer.isAllocated()) {\n           // This allocation is from a reserved container\n           // Unreserve it first\n           if (allocation.getAllocateFromReservedContainer() !\u003d null) {\n             RMContainer reservedContainer \u003d\n                 allocation.getAllocateFromReservedContainer().getRmContainer();\n             // Handling container allocation\n             // Did we previously reserve containers at this \u0027priority\u0027?\n             unreserve(schedulerContainer.getSchedulerRequestKey(),\n                 schedulerContainer.getSchedulerNode(), reservedContainer);\n           }\n \n           // Allocate a new container\n           addToNewlyAllocatedContainers(\n               schedulerContainer.getSchedulerNode(), rmContainer);\n           liveContainers.put(containerId, rmContainer);\n \n           // Deduct pending resource requests\n           if (updatePending) {\n             ContainerRequest containerRequest \u003d appSchedulingInfo.allocate(\n                 allocation.getAllocationLocalityType(),\n                 schedulerContainer.getSchedulerNode(),\n                 schedulerContainer.getSchedulerRequestKey(),\n                 schedulerContainer.getRmContainer().getContainer());\n             ((RMContainerImpl) rmContainer).setContainerRequest(\n                 containerRequest);\n+\n+            // If this is from a SchedulingRequest, set allocation tags.\n+            if (containerRequest.getSchedulingRequest() !\u003d null) {\n+              ((RMContainerImpl) rmContainer).setAllocationTags(\n+                  containerRequest.getSchedulingRequest().getAllocationTags());\n+            }\n           }\n \n           attemptResourceUsage.incUsed(schedulerContainer.getNodePartition(),\n               allocation.getAllocatedOrReservedResource());\n \n           rmContainer.handle(\n               new RMContainerEvent(containerId, RMContainerEventType.START));\n \n           // Inform the node\n           schedulerContainer.getSchedulerNode().allocateContainer(\n               rmContainer);\n \n           // update locality statistics,\n           incNumAllocatedContainers(allocation.getAllocationLocalityType(),\n               allocation.getRequestLocalityType());\n \n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"allocate: applicationAttemptId\u003d\" + containerId\n                 .getApplicationAttemptId() + \" container\u003d\" + containerId\n                 + \" host\u003d\" + rmContainer.getAllocatedNode().getHost()\n                 + \" type\u003d\" + allocation.getAllocationLocalityType());\n           }\n           RMAuditLogger.logSuccess(getUser(), AuditConstants.ALLOC_CONTAINER,\n               \"SchedulerApp\", getApplicationId(), containerId,\n               allocation.getAllocatedOrReservedResource());\n         } else {\n           // If the rmContainer\u0027s state is already updated to RESERVED, this is\n           // a reReservation\n           reserve(schedulerContainer.getSchedulerRequestKey(),\n               schedulerContainer.getSchedulerNode(),\n               schedulerContainer.getRmContainer(),\n               schedulerContainer.getRmContainer().getContainer(),\n               reReservation);\n         }\n       }\n     } finally {\n       writeLock.unlock();\n     }\n \n     // Don\u0027t bother CS leaf queue if it is a re-reservation\n     if (!reReservation) {\n       getCSLeafQueue().apply(cluster, request);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void apply(Resource cluster, ResourceCommitRequest\u003cFiCaSchedulerApp,\n      FiCaSchedulerNode\u003e request, boolean updatePending) {\n    boolean reReservation \u003d false;\n\n    try {\n      writeLock.lock();\n\n      // If we allocated something\n      if (request.anythingAllocatedOrReserved()) {\n        ContainerAllocationProposal\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n            allocation \u003d request.getFirstAllocatedOrReservedContainer();\n        SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n            schedulerContainer \u003d allocation.getAllocatedOrReservedContainer();\n        RMContainer rmContainer \u003d schedulerContainer.getRmContainer();\n\n        reReservation \u003d\n            (!schedulerContainer.isAllocated()) \u0026\u0026 (rmContainer.getState()\n                \u003d\u003d RMContainerState.RESERVED);\n\n        // Generate new containerId if it is not an allocation for increasing\n        // Or re-reservation\n        if (rmContainer.getContainer().getId() \u003d\u003d null) {\n          rmContainer.setContainerId(BuilderUtils\n              .newContainerId(getApplicationAttemptId(),\n                  getNewContainerId()));\n        }\n        ContainerId containerId \u003d rmContainer.getContainerId();\n\n        if (schedulerContainer.isAllocated()) {\n          // This allocation is from a reserved container\n          // Unreserve it first\n          if (allocation.getAllocateFromReservedContainer() !\u003d null) {\n            RMContainer reservedContainer \u003d\n                allocation.getAllocateFromReservedContainer().getRmContainer();\n            // Handling container allocation\n            // Did we previously reserve containers at this \u0027priority\u0027?\n            unreserve(schedulerContainer.getSchedulerRequestKey(),\n                schedulerContainer.getSchedulerNode(), reservedContainer);\n          }\n\n          // Allocate a new container\n          addToNewlyAllocatedContainers(\n              schedulerContainer.getSchedulerNode(), rmContainer);\n          liveContainers.put(containerId, rmContainer);\n\n          // Deduct pending resource requests\n          if (updatePending) {\n            ContainerRequest containerRequest \u003d appSchedulingInfo.allocate(\n                allocation.getAllocationLocalityType(),\n                schedulerContainer.getSchedulerNode(),\n                schedulerContainer.getSchedulerRequestKey(),\n                schedulerContainer.getRmContainer().getContainer());\n            ((RMContainerImpl) rmContainer).setContainerRequest(\n                containerRequest);\n\n            // If this is from a SchedulingRequest, set allocation tags.\n            if (containerRequest.getSchedulingRequest() !\u003d null) {\n              ((RMContainerImpl) rmContainer).setAllocationTags(\n                  containerRequest.getSchedulingRequest().getAllocationTags());\n            }\n          }\n\n          attemptResourceUsage.incUsed(schedulerContainer.getNodePartition(),\n              allocation.getAllocatedOrReservedResource());\n\n          rmContainer.handle(\n              new RMContainerEvent(containerId, RMContainerEventType.START));\n\n          // Inform the node\n          schedulerContainer.getSchedulerNode().allocateContainer(\n              rmContainer);\n\n          // update locality statistics,\n          incNumAllocatedContainers(allocation.getAllocationLocalityType(),\n              allocation.getRequestLocalityType());\n\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"allocate: applicationAttemptId\u003d\" + containerId\n                .getApplicationAttemptId() + \" container\u003d\" + containerId\n                + \" host\u003d\" + rmContainer.getAllocatedNode().getHost()\n                + \" type\u003d\" + allocation.getAllocationLocalityType());\n          }\n          RMAuditLogger.logSuccess(getUser(), AuditConstants.ALLOC_CONTAINER,\n              \"SchedulerApp\", getApplicationId(), containerId,\n              allocation.getAllocatedOrReservedResource());\n        } else {\n          // If the rmContainer\u0027s state is already updated to RESERVED, this is\n          // a reReservation\n          reserve(schedulerContainer.getSchedulerRequestKey(),\n              schedulerContainer.getSchedulerNode(),\n              schedulerContainer.getRmContainer(),\n              schedulerContainer.getRmContainer().getContainer(),\n              reReservation);\n        }\n      }\n    } finally {\n      writeLock.unlock();\n    }\n\n    // Don\u0027t bother CS leaf queue if it is a re-reservation\n    if (!reReservation) {\n      getCSLeafQueue().apply(cluster, request);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/common/fica/FiCaSchedulerApp.java",
      "extendedDetails": {}
    },
    "88d8d3f40b2923fab23a933bce1cd2e9c320ae84": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-7670. Modifications to the ResourceScheduler API to support SchedulingRequests. (asuresh)\n",
      "commitDate": "31/01/18 1:30 AM",
      "commitName": "88d8d3f40b2923fab23a933bce1cd2e9c320ae84",
      "commitAuthor": "Arun Suresh",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-7670. Modifications to the ResourceScheduler API to support SchedulingRequests. (asuresh)\n",
          "commitDate": "31/01/18 1:30 AM",
          "commitName": "88d8d3f40b2923fab23a933bce1cd2e9c320ae84",
          "commitAuthor": "Arun Suresh",
          "commitDateOld": "09/01/18 4:27 AM",
          "commitNameOld": "b26e30ab1655a8cdf369862a5512db5c2a88ec46",
          "commitAuthorOld": "bibinchundatt",
          "daysBetweenCommits": 21.88,
          "commitsBetweenForRepo": 128,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,95 +1,98 @@\n-  public void apply(Resource cluster,\n-      ResourceCommitRequest\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e request) {\n+  public void apply(Resource cluster, ResourceCommitRequest\u003cFiCaSchedulerApp,\n+      FiCaSchedulerNode\u003e request, boolean updatePending) {\n     boolean reReservation \u003d false;\n \n     try {\n       writeLock.lock();\n \n       // If we allocated something\n       if (request.anythingAllocatedOrReserved()) {\n         ContainerAllocationProposal\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n             allocation \u003d request.getFirstAllocatedOrReservedContainer();\n         SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n             schedulerContainer \u003d allocation.getAllocatedOrReservedContainer();\n         RMContainer rmContainer \u003d schedulerContainer.getRmContainer();\n \n         reReservation \u003d\n             (!schedulerContainer.isAllocated()) \u0026\u0026 (rmContainer.getState()\n                 \u003d\u003d RMContainerState.RESERVED);\n \n         // Generate new containerId if it is not an allocation for increasing\n         // Or re-reservation\n         if (rmContainer.getContainer().getId() \u003d\u003d null) {\n           rmContainer.setContainerId(BuilderUtils\n               .newContainerId(getApplicationAttemptId(),\n                   getNewContainerId()));\n         }\n         ContainerId containerId \u003d rmContainer.getContainerId();\n \n         if (schedulerContainer.isAllocated()) {\n           // This allocation is from a reserved container\n           // Unreserve it first\n           if (allocation.getAllocateFromReservedContainer() !\u003d null) {\n             RMContainer reservedContainer \u003d\n                 allocation.getAllocateFromReservedContainer().getRmContainer();\n             // Handling container allocation\n             // Did we previously reserve containers at this \u0027priority\u0027?\n             unreserve(schedulerContainer.getSchedulerRequestKey(),\n                 schedulerContainer.getSchedulerNode(), reservedContainer);\n           }\n \n           // Allocate a new container\n           addToNewlyAllocatedContainers(\n               schedulerContainer.getSchedulerNode(), rmContainer);\n           liveContainers.put(containerId, rmContainer);\n \n           // Deduct pending resource requests\n-          ContainerRequest containerRequest \u003d appSchedulingInfo.allocate(\n-              allocation.getAllocationLocalityType(),\n-              schedulerContainer.getSchedulerNode(),\n-              schedulerContainer.getSchedulerRequestKey(),\n-              schedulerContainer.getRmContainer().getContainer());\n-          ((RMContainerImpl) rmContainer).setContainerRequest(containerRequest);\n+          if (updatePending) {\n+            ContainerRequest containerRequest \u003d appSchedulingInfo.allocate(\n+                allocation.getAllocationLocalityType(),\n+                schedulerContainer.getSchedulerNode(),\n+                schedulerContainer.getSchedulerRequestKey(),\n+                schedulerContainer.getRmContainer().getContainer());\n+            ((RMContainerImpl) rmContainer).setContainerRequest(\n+                containerRequest);\n+          }\n \n           attemptResourceUsage.incUsed(schedulerContainer.getNodePartition(),\n               allocation.getAllocatedOrReservedResource());\n \n           rmContainer.handle(\n               new RMContainerEvent(containerId, RMContainerEventType.START));\n \n           // Inform the node\n           schedulerContainer.getSchedulerNode().allocateContainer(\n               rmContainer);\n \n           // update locality statistics,\n           incNumAllocatedContainers(allocation.getAllocationLocalityType(),\n               allocation.getRequestLocalityType());\n \n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"allocate: applicationAttemptId\u003d\" + containerId\n                 .getApplicationAttemptId() + \" container\u003d\" + containerId\n                 + \" host\u003d\" + rmContainer.getAllocatedNode().getHost()\n                 + \" type\u003d\" + allocation.getAllocationLocalityType());\n           }\n           RMAuditLogger.logSuccess(getUser(), AuditConstants.ALLOC_CONTAINER,\n               \"SchedulerApp\", getApplicationId(), containerId,\n               allocation.getAllocatedOrReservedResource());\n         } else {\n           // If the rmContainer\u0027s state is already updated to RESERVED, this is\n           // a reReservation\n           reserve(schedulerContainer.getSchedulerRequestKey(),\n               schedulerContainer.getSchedulerNode(),\n               schedulerContainer.getRmContainer(),\n               schedulerContainer.getRmContainer().getContainer(),\n               reReservation);\n         }\n       }\n     } finally {\n       writeLock.unlock();\n     }\n \n     // Don\u0027t bother CS leaf queue if it is a re-reservation\n     if (!reReservation) {\n       getCSLeafQueue().apply(cluster, request);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void apply(Resource cluster, ResourceCommitRequest\u003cFiCaSchedulerApp,\n      FiCaSchedulerNode\u003e request, boolean updatePending) {\n    boolean reReservation \u003d false;\n\n    try {\n      writeLock.lock();\n\n      // If we allocated something\n      if (request.anythingAllocatedOrReserved()) {\n        ContainerAllocationProposal\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n            allocation \u003d request.getFirstAllocatedOrReservedContainer();\n        SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n            schedulerContainer \u003d allocation.getAllocatedOrReservedContainer();\n        RMContainer rmContainer \u003d schedulerContainer.getRmContainer();\n\n        reReservation \u003d\n            (!schedulerContainer.isAllocated()) \u0026\u0026 (rmContainer.getState()\n                \u003d\u003d RMContainerState.RESERVED);\n\n        // Generate new containerId if it is not an allocation for increasing\n        // Or re-reservation\n        if (rmContainer.getContainer().getId() \u003d\u003d null) {\n          rmContainer.setContainerId(BuilderUtils\n              .newContainerId(getApplicationAttemptId(),\n                  getNewContainerId()));\n        }\n        ContainerId containerId \u003d rmContainer.getContainerId();\n\n        if (schedulerContainer.isAllocated()) {\n          // This allocation is from a reserved container\n          // Unreserve it first\n          if (allocation.getAllocateFromReservedContainer() !\u003d null) {\n            RMContainer reservedContainer \u003d\n                allocation.getAllocateFromReservedContainer().getRmContainer();\n            // Handling container allocation\n            // Did we previously reserve containers at this \u0027priority\u0027?\n            unreserve(schedulerContainer.getSchedulerRequestKey(),\n                schedulerContainer.getSchedulerNode(), reservedContainer);\n          }\n\n          // Allocate a new container\n          addToNewlyAllocatedContainers(\n              schedulerContainer.getSchedulerNode(), rmContainer);\n          liveContainers.put(containerId, rmContainer);\n\n          // Deduct pending resource requests\n          if (updatePending) {\n            ContainerRequest containerRequest \u003d appSchedulingInfo.allocate(\n                allocation.getAllocationLocalityType(),\n                schedulerContainer.getSchedulerNode(),\n                schedulerContainer.getSchedulerRequestKey(),\n                schedulerContainer.getRmContainer().getContainer());\n            ((RMContainerImpl) rmContainer).setContainerRequest(\n                containerRequest);\n          }\n\n          attemptResourceUsage.incUsed(schedulerContainer.getNodePartition(),\n              allocation.getAllocatedOrReservedResource());\n\n          rmContainer.handle(\n              new RMContainerEvent(containerId, RMContainerEventType.START));\n\n          // Inform the node\n          schedulerContainer.getSchedulerNode().allocateContainer(\n              rmContainer);\n\n          // update locality statistics,\n          incNumAllocatedContainers(allocation.getAllocationLocalityType(),\n              allocation.getRequestLocalityType());\n\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"allocate: applicationAttemptId\u003d\" + containerId\n                .getApplicationAttemptId() + \" container\u003d\" + containerId\n                + \" host\u003d\" + rmContainer.getAllocatedNode().getHost()\n                + \" type\u003d\" + allocation.getAllocationLocalityType());\n          }\n          RMAuditLogger.logSuccess(getUser(), AuditConstants.ALLOC_CONTAINER,\n              \"SchedulerApp\", getApplicationId(), containerId,\n              allocation.getAllocatedOrReservedResource());\n        } else {\n          // If the rmContainer\u0027s state is already updated to RESERVED, this is\n          // a reReservation\n          reserve(schedulerContainer.getSchedulerRequestKey(),\n              schedulerContainer.getSchedulerNode(),\n              schedulerContainer.getRmContainer(),\n              schedulerContainer.getRmContainer().getContainer(),\n              reReservation);\n        }\n      }\n    } finally {\n      writeLock.unlock();\n    }\n\n    // Don\u0027t bother CS leaf queue if it is a re-reservation\n    if (!reReservation) {\n      getCSLeafQueue().apply(cluster, request);\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/common/fica/FiCaSchedulerApp.java",
          "extendedDetails": {
            "oldValue": "[cluster-Resource, request-ResourceCommitRequest\u003cFiCaSchedulerApp,FiCaSchedulerNode\u003e]",
            "newValue": "[cluster-Resource, request-ResourceCommitRequest\u003cFiCaSchedulerApp,FiCaSchedulerNode\u003e, updatePending-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-7670. Modifications to the ResourceScheduler API to support SchedulingRequests. (asuresh)\n",
          "commitDate": "31/01/18 1:30 AM",
          "commitName": "88d8d3f40b2923fab23a933bce1cd2e9c320ae84",
          "commitAuthor": "Arun Suresh",
          "commitDateOld": "09/01/18 4:27 AM",
          "commitNameOld": "b26e30ab1655a8cdf369862a5512db5c2a88ec46",
          "commitAuthorOld": "bibinchundatt",
          "daysBetweenCommits": 21.88,
          "commitsBetweenForRepo": 128,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,95 +1,98 @@\n-  public void apply(Resource cluster,\n-      ResourceCommitRequest\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e request) {\n+  public void apply(Resource cluster, ResourceCommitRequest\u003cFiCaSchedulerApp,\n+      FiCaSchedulerNode\u003e request, boolean updatePending) {\n     boolean reReservation \u003d false;\n \n     try {\n       writeLock.lock();\n \n       // If we allocated something\n       if (request.anythingAllocatedOrReserved()) {\n         ContainerAllocationProposal\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n             allocation \u003d request.getFirstAllocatedOrReservedContainer();\n         SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n             schedulerContainer \u003d allocation.getAllocatedOrReservedContainer();\n         RMContainer rmContainer \u003d schedulerContainer.getRmContainer();\n \n         reReservation \u003d\n             (!schedulerContainer.isAllocated()) \u0026\u0026 (rmContainer.getState()\n                 \u003d\u003d RMContainerState.RESERVED);\n \n         // Generate new containerId if it is not an allocation for increasing\n         // Or re-reservation\n         if (rmContainer.getContainer().getId() \u003d\u003d null) {\n           rmContainer.setContainerId(BuilderUtils\n               .newContainerId(getApplicationAttemptId(),\n                   getNewContainerId()));\n         }\n         ContainerId containerId \u003d rmContainer.getContainerId();\n \n         if (schedulerContainer.isAllocated()) {\n           // This allocation is from a reserved container\n           // Unreserve it first\n           if (allocation.getAllocateFromReservedContainer() !\u003d null) {\n             RMContainer reservedContainer \u003d\n                 allocation.getAllocateFromReservedContainer().getRmContainer();\n             // Handling container allocation\n             // Did we previously reserve containers at this \u0027priority\u0027?\n             unreserve(schedulerContainer.getSchedulerRequestKey(),\n                 schedulerContainer.getSchedulerNode(), reservedContainer);\n           }\n \n           // Allocate a new container\n           addToNewlyAllocatedContainers(\n               schedulerContainer.getSchedulerNode(), rmContainer);\n           liveContainers.put(containerId, rmContainer);\n \n           // Deduct pending resource requests\n-          ContainerRequest containerRequest \u003d appSchedulingInfo.allocate(\n-              allocation.getAllocationLocalityType(),\n-              schedulerContainer.getSchedulerNode(),\n-              schedulerContainer.getSchedulerRequestKey(),\n-              schedulerContainer.getRmContainer().getContainer());\n-          ((RMContainerImpl) rmContainer).setContainerRequest(containerRequest);\n+          if (updatePending) {\n+            ContainerRequest containerRequest \u003d appSchedulingInfo.allocate(\n+                allocation.getAllocationLocalityType(),\n+                schedulerContainer.getSchedulerNode(),\n+                schedulerContainer.getSchedulerRequestKey(),\n+                schedulerContainer.getRmContainer().getContainer());\n+            ((RMContainerImpl) rmContainer).setContainerRequest(\n+                containerRequest);\n+          }\n \n           attemptResourceUsage.incUsed(schedulerContainer.getNodePartition(),\n               allocation.getAllocatedOrReservedResource());\n \n           rmContainer.handle(\n               new RMContainerEvent(containerId, RMContainerEventType.START));\n \n           // Inform the node\n           schedulerContainer.getSchedulerNode().allocateContainer(\n               rmContainer);\n \n           // update locality statistics,\n           incNumAllocatedContainers(allocation.getAllocationLocalityType(),\n               allocation.getRequestLocalityType());\n \n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"allocate: applicationAttemptId\u003d\" + containerId\n                 .getApplicationAttemptId() + \" container\u003d\" + containerId\n                 + \" host\u003d\" + rmContainer.getAllocatedNode().getHost()\n                 + \" type\u003d\" + allocation.getAllocationLocalityType());\n           }\n           RMAuditLogger.logSuccess(getUser(), AuditConstants.ALLOC_CONTAINER,\n               \"SchedulerApp\", getApplicationId(), containerId,\n               allocation.getAllocatedOrReservedResource());\n         } else {\n           // If the rmContainer\u0027s state is already updated to RESERVED, this is\n           // a reReservation\n           reserve(schedulerContainer.getSchedulerRequestKey(),\n               schedulerContainer.getSchedulerNode(),\n               schedulerContainer.getRmContainer(),\n               schedulerContainer.getRmContainer().getContainer(),\n               reReservation);\n         }\n       }\n     } finally {\n       writeLock.unlock();\n     }\n \n     // Don\u0027t bother CS leaf queue if it is a re-reservation\n     if (!reReservation) {\n       getCSLeafQueue().apply(cluster, request);\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void apply(Resource cluster, ResourceCommitRequest\u003cFiCaSchedulerApp,\n      FiCaSchedulerNode\u003e request, boolean updatePending) {\n    boolean reReservation \u003d false;\n\n    try {\n      writeLock.lock();\n\n      // If we allocated something\n      if (request.anythingAllocatedOrReserved()) {\n        ContainerAllocationProposal\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n            allocation \u003d request.getFirstAllocatedOrReservedContainer();\n        SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n            schedulerContainer \u003d allocation.getAllocatedOrReservedContainer();\n        RMContainer rmContainer \u003d schedulerContainer.getRmContainer();\n\n        reReservation \u003d\n            (!schedulerContainer.isAllocated()) \u0026\u0026 (rmContainer.getState()\n                \u003d\u003d RMContainerState.RESERVED);\n\n        // Generate new containerId if it is not an allocation for increasing\n        // Or re-reservation\n        if (rmContainer.getContainer().getId() \u003d\u003d null) {\n          rmContainer.setContainerId(BuilderUtils\n              .newContainerId(getApplicationAttemptId(),\n                  getNewContainerId()));\n        }\n        ContainerId containerId \u003d rmContainer.getContainerId();\n\n        if (schedulerContainer.isAllocated()) {\n          // This allocation is from a reserved container\n          // Unreserve it first\n          if (allocation.getAllocateFromReservedContainer() !\u003d null) {\n            RMContainer reservedContainer \u003d\n                allocation.getAllocateFromReservedContainer().getRmContainer();\n            // Handling container allocation\n            // Did we previously reserve containers at this \u0027priority\u0027?\n            unreserve(schedulerContainer.getSchedulerRequestKey(),\n                schedulerContainer.getSchedulerNode(), reservedContainer);\n          }\n\n          // Allocate a new container\n          addToNewlyAllocatedContainers(\n              schedulerContainer.getSchedulerNode(), rmContainer);\n          liveContainers.put(containerId, rmContainer);\n\n          // Deduct pending resource requests\n          if (updatePending) {\n            ContainerRequest containerRequest \u003d appSchedulingInfo.allocate(\n                allocation.getAllocationLocalityType(),\n                schedulerContainer.getSchedulerNode(),\n                schedulerContainer.getSchedulerRequestKey(),\n                schedulerContainer.getRmContainer().getContainer());\n            ((RMContainerImpl) rmContainer).setContainerRequest(\n                containerRequest);\n          }\n\n          attemptResourceUsage.incUsed(schedulerContainer.getNodePartition(),\n              allocation.getAllocatedOrReservedResource());\n\n          rmContainer.handle(\n              new RMContainerEvent(containerId, RMContainerEventType.START));\n\n          // Inform the node\n          schedulerContainer.getSchedulerNode().allocateContainer(\n              rmContainer);\n\n          // update locality statistics,\n          incNumAllocatedContainers(allocation.getAllocationLocalityType(),\n              allocation.getRequestLocalityType());\n\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"allocate: applicationAttemptId\u003d\" + containerId\n                .getApplicationAttemptId() + \" container\u003d\" + containerId\n                + \" host\u003d\" + rmContainer.getAllocatedNode().getHost()\n                + \" type\u003d\" + allocation.getAllocationLocalityType());\n          }\n          RMAuditLogger.logSuccess(getUser(), AuditConstants.ALLOC_CONTAINER,\n              \"SchedulerApp\", getApplicationId(), containerId,\n              allocation.getAllocatedOrReservedResource());\n        } else {\n          // If the rmContainer\u0027s state is already updated to RESERVED, this is\n          // a reReservation\n          reserve(schedulerContainer.getSchedulerRequestKey(),\n              schedulerContainer.getSchedulerNode(),\n              schedulerContainer.getRmContainer(),\n              schedulerContainer.getRmContainer().getContainer(),\n              reReservation);\n        }\n      }\n    } finally {\n      writeLock.unlock();\n    }\n\n    // Don\u0027t bother CS leaf queue if it is a re-reservation\n    if (!reReservation) {\n      getCSLeafQueue().apply(cluster, request);\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/common/fica/FiCaSchedulerApp.java",
          "extendedDetails": {}
        }
      ]
    },
    "a957f1c60e1308d1d70a1803381994f59949c5f8": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7438. Additional changes to make SchedulingPlacementSet agnostic to ResourceRequest / placement algorithm. Contributed by Wangda Tan\n",
      "commitDate": "05/12/17 9:20 AM",
      "commitName": "a957f1c60e1308d1d70a1803381994f59949c5f8",
      "commitAuthor": "Sunil G",
      "commitDateOld": "27/11/17 10:19 AM",
      "commitNameOld": "fedabcad42067ac7dd24de40fab6be2d3485a540",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 7.96,
      "commitsBetweenForRepo": 49,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,95 +1,95 @@\n   public void apply(Resource cluster,\n       ResourceCommitRequest\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e request) {\n     boolean reReservation \u003d false;\n \n     try {\n       writeLock.lock();\n \n       // If we allocated something\n       if (request.anythingAllocatedOrReserved()) {\n         ContainerAllocationProposal\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n             allocation \u003d request.getFirstAllocatedOrReservedContainer();\n         SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n             schedulerContainer \u003d allocation.getAllocatedOrReservedContainer();\n         RMContainer rmContainer \u003d schedulerContainer.getRmContainer();\n \n         reReservation \u003d\n             (!schedulerContainer.isAllocated()) \u0026\u0026 (rmContainer.getState()\n                 \u003d\u003d RMContainerState.RESERVED);\n \n         // Generate new containerId if it is not an allocation for increasing\n         // Or re-reservation\n         if (rmContainer.getContainer().getId() \u003d\u003d null) {\n           rmContainer.setContainerId(BuilderUtils\n               .newContainerId(getApplicationAttemptId(),\n                   getNewContainerId()));\n         }\n         ContainerId containerId \u003d rmContainer.getContainerId();\n \n         if (schedulerContainer.isAllocated()) {\n           // This allocation is from a reserved container\n           // Unreserve it first\n           if (allocation.getAllocateFromReservedContainer() !\u003d null) {\n             RMContainer reservedContainer \u003d\n                 allocation.getAllocateFromReservedContainer().getRmContainer();\n             // Handling container allocation\n             // Did we previously reserve containers at this \u0027priority\u0027?\n             unreserve(schedulerContainer.getSchedulerRequestKey(),\n                 schedulerContainer.getSchedulerNode(), reservedContainer);\n           }\n \n           // Allocate a new container\n           addToNewlyAllocatedContainers(\n               schedulerContainer.getSchedulerNode(), rmContainer);\n           liveContainers.put(containerId, rmContainer);\n \n           // Deduct pending resource requests\n-          List\u003cResourceRequest\u003e requests \u003d appSchedulingInfo.allocate(\n+          ContainerRequest containerRequest \u003d appSchedulingInfo.allocate(\n               allocation.getAllocationLocalityType(),\n               schedulerContainer.getSchedulerNode(),\n               schedulerContainer.getSchedulerRequestKey(),\n               schedulerContainer.getRmContainer().getContainer());\n-          ((RMContainerImpl) rmContainer).setResourceRequests(requests);\n+          ((RMContainerImpl) rmContainer).setContainerRequest(containerRequest);\n \n           attemptResourceUsage.incUsed(schedulerContainer.getNodePartition(),\n               allocation.getAllocatedOrReservedResource());\n \n           rmContainer.handle(\n               new RMContainerEvent(containerId, RMContainerEventType.START));\n \n           // Inform the node\n           schedulerContainer.getSchedulerNode().allocateContainer(\n               rmContainer);\n \n           // update locality statistics,\n           incNumAllocatedContainers(allocation.getAllocationLocalityType(),\n               allocation.getRequestLocalityType());\n \n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"allocate: applicationAttemptId\u003d\" + containerId\n                 .getApplicationAttemptId() + \" container\u003d\" + containerId\n                 + \" host\u003d\" + rmContainer.getAllocatedNode().getHost()\n                 + \" type\u003d\" + allocation.getAllocationLocalityType());\n           }\n           RMAuditLogger.logSuccess(getUser(), AuditConstants.ALLOC_CONTAINER,\n               \"SchedulerApp\", getApplicationId(), containerId,\n               allocation.getAllocatedOrReservedResource());\n         } else {\n           // If the rmContainer\u0027s state is already updated to RESERVED, this is\n           // a reReservation\n           reserve(schedulerContainer.getSchedulerRequestKey(),\n               schedulerContainer.getSchedulerNode(),\n               schedulerContainer.getRmContainer(),\n               schedulerContainer.getRmContainer().getContainer(),\n               reReservation);\n         }\n       }\n     } finally {\n       writeLock.unlock();\n     }\n \n     // Don\u0027t bother CS leaf queue if it is a re-reservation\n     if (!reReservation) {\n       getCSLeafQueue().apply(cluster, request);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void apply(Resource cluster,\n      ResourceCommitRequest\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e request) {\n    boolean reReservation \u003d false;\n\n    try {\n      writeLock.lock();\n\n      // If we allocated something\n      if (request.anythingAllocatedOrReserved()) {\n        ContainerAllocationProposal\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n            allocation \u003d request.getFirstAllocatedOrReservedContainer();\n        SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n            schedulerContainer \u003d allocation.getAllocatedOrReservedContainer();\n        RMContainer rmContainer \u003d schedulerContainer.getRmContainer();\n\n        reReservation \u003d\n            (!schedulerContainer.isAllocated()) \u0026\u0026 (rmContainer.getState()\n                \u003d\u003d RMContainerState.RESERVED);\n\n        // Generate new containerId if it is not an allocation for increasing\n        // Or re-reservation\n        if (rmContainer.getContainer().getId() \u003d\u003d null) {\n          rmContainer.setContainerId(BuilderUtils\n              .newContainerId(getApplicationAttemptId(),\n                  getNewContainerId()));\n        }\n        ContainerId containerId \u003d rmContainer.getContainerId();\n\n        if (schedulerContainer.isAllocated()) {\n          // This allocation is from a reserved container\n          // Unreserve it first\n          if (allocation.getAllocateFromReservedContainer() !\u003d null) {\n            RMContainer reservedContainer \u003d\n                allocation.getAllocateFromReservedContainer().getRmContainer();\n            // Handling container allocation\n            // Did we previously reserve containers at this \u0027priority\u0027?\n            unreserve(schedulerContainer.getSchedulerRequestKey(),\n                schedulerContainer.getSchedulerNode(), reservedContainer);\n          }\n\n          // Allocate a new container\n          addToNewlyAllocatedContainers(\n              schedulerContainer.getSchedulerNode(), rmContainer);\n          liveContainers.put(containerId, rmContainer);\n\n          // Deduct pending resource requests\n          ContainerRequest containerRequest \u003d appSchedulingInfo.allocate(\n              allocation.getAllocationLocalityType(),\n              schedulerContainer.getSchedulerNode(),\n              schedulerContainer.getSchedulerRequestKey(),\n              schedulerContainer.getRmContainer().getContainer());\n          ((RMContainerImpl) rmContainer).setContainerRequest(containerRequest);\n\n          attemptResourceUsage.incUsed(schedulerContainer.getNodePartition(),\n              allocation.getAllocatedOrReservedResource());\n\n          rmContainer.handle(\n              new RMContainerEvent(containerId, RMContainerEventType.START));\n\n          // Inform the node\n          schedulerContainer.getSchedulerNode().allocateContainer(\n              rmContainer);\n\n          // update locality statistics,\n          incNumAllocatedContainers(allocation.getAllocationLocalityType(),\n              allocation.getRequestLocalityType());\n\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"allocate: applicationAttemptId\u003d\" + containerId\n                .getApplicationAttemptId() + \" container\u003d\" + containerId\n                + \" host\u003d\" + rmContainer.getAllocatedNode().getHost()\n                + \" type\u003d\" + allocation.getAllocationLocalityType());\n          }\n          RMAuditLogger.logSuccess(getUser(), AuditConstants.ALLOC_CONTAINER,\n              \"SchedulerApp\", getApplicationId(), containerId,\n              allocation.getAllocatedOrReservedResource());\n        } else {\n          // If the rmContainer\u0027s state is already updated to RESERVED, this is\n          // a reReservation\n          reserve(schedulerContainer.getSchedulerRequestKey(),\n              schedulerContainer.getSchedulerNode(),\n              schedulerContainer.getRmContainer(),\n              schedulerContainer.getRmContainer().getContainer(),\n              reReservation);\n        }\n      }\n    } finally {\n      writeLock.unlock();\n    }\n\n    // Don\u0027t bother CS leaf queue if it is a re-reservation\n    if (!reReservation) {\n      getCSLeafQueue().apply(cluster, request);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/common/fica/FiCaSchedulerApp.java",
      "extendedDetails": {}
    },
    "eac6b4c35c50e555c2f1b5f913bb2c4d839f1ff4": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6216. Unify Container Resizing code paths with Container Updates making it scheduler agnostic. (Arun Suresh via wangda)\n",
      "commitDate": "28/02/17 10:35 AM",
      "commitName": "eac6b4c35c50e555c2f1b5f913bb2c4d839f1ff4",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "09/02/17 10:23 AM",
      "commitNameOld": "5fb723bb77722d41df6959eee23e1b0cfeb5584e",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 19.01,
      "commitsBetweenForRepo": 112,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,124 +1,95 @@\n   public void apply(Resource cluster,\n       ResourceCommitRequest\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e request) {\n     boolean reReservation \u003d false;\n \n     try {\n       writeLock.lock();\n \n       // If we allocated something\n       if (request.anythingAllocatedOrReserved()) {\n         ContainerAllocationProposal\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n             allocation \u003d request.getFirstAllocatedOrReservedContainer();\n         SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n             schedulerContainer \u003d allocation.getAllocatedOrReservedContainer();\n         RMContainer rmContainer \u003d schedulerContainer.getRmContainer();\n \n         reReservation \u003d\n             (!schedulerContainer.isAllocated()) \u0026\u0026 (rmContainer.getState()\n                 \u003d\u003d RMContainerState.RESERVED);\n \n         // Generate new containerId if it is not an allocation for increasing\n         // Or re-reservation\n-        if (!allocation.isIncreasedAllocation()) {\n-          if (rmContainer.getContainer().getId() \u003d\u003d null) {\n-            rmContainer.setContainerId(BuilderUtils\n-                .newContainerId(getApplicationAttemptId(),\n-                    getNewContainerId()));\n-          }\n+        if (rmContainer.getContainer().getId() \u003d\u003d null) {\n+          rmContainer.setContainerId(BuilderUtils\n+              .newContainerId(getApplicationAttemptId(),\n+                  getNewContainerId()));\n         }\n         ContainerId containerId \u003d rmContainer.getContainerId();\n \n         if (schedulerContainer.isAllocated()) {\n           // This allocation is from a reserved container\n           // Unreserve it first\n           if (allocation.getAllocateFromReservedContainer() !\u003d null) {\n             RMContainer reservedContainer \u003d\n                 allocation.getAllocateFromReservedContainer().getRmContainer();\n             // Handling container allocation\n             // Did we previously reserve containers at this \u0027priority\u0027?\n             unreserve(schedulerContainer.getSchedulerRequestKey(),\n                 schedulerContainer.getSchedulerNode(), reservedContainer);\n           }\n \n-          // Update this application for the allocated container\n-          if (!allocation.isIncreasedAllocation()) {\n-            // Allocate a new container\n-            addToNewlyAllocatedContainers(\n-                schedulerContainer.getSchedulerNode(), rmContainer);\n-            liveContainers.put(containerId, rmContainer);\n+          // Allocate a new container\n+          addToNewlyAllocatedContainers(\n+              schedulerContainer.getSchedulerNode(), rmContainer);\n+          liveContainers.put(containerId, rmContainer);\n \n-            // Deduct pending resource requests\n-            List\u003cResourceRequest\u003e requests \u003d appSchedulingInfo.allocate(\n-                allocation.getAllocationLocalityType(),\n-                schedulerContainer.getSchedulerNode(),\n-                schedulerContainer.getSchedulerRequestKey(),\n-                schedulerContainer.getRmContainer().getContainer());\n-            ((RMContainerImpl) rmContainer).setResourceRequests(requests);\n+          // Deduct pending resource requests\n+          List\u003cResourceRequest\u003e requests \u003d appSchedulingInfo.allocate(\n+              allocation.getAllocationLocalityType(),\n+              schedulerContainer.getSchedulerNode(),\n+              schedulerContainer.getSchedulerRequestKey(),\n+              schedulerContainer.getRmContainer().getContainer());\n+          ((RMContainerImpl) rmContainer).setResourceRequests(requests);\n \n-            attemptResourceUsage.incUsed(schedulerContainer.getNodePartition(),\n-                allocation.getAllocatedOrReservedResource());\n+          attemptResourceUsage.incUsed(schedulerContainer.getNodePartition(),\n+              allocation.getAllocatedOrReservedResource());\n \n-            rmContainer.handle(\n-                new RMContainerEvent(containerId, RMContainerEventType.START));\n+          rmContainer.handle(\n+              new RMContainerEvent(containerId, RMContainerEventType.START));\n \n-            // Inform the node\n-            schedulerContainer.getSchedulerNode().allocateContainer(\n-                rmContainer);\n+          // Inform the node\n+          schedulerContainer.getSchedulerNode().allocateContainer(\n+              rmContainer);\n \n-            // update locality statistics,\n-            incNumAllocatedContainers(allocation.getAllocationLocalityType(),\n-                allocation.getRequestLocalityType());\n+          // update locality statistics,\n+          incNumAllocatedContainers(allocation.getAllocationLocalityType(),\n+              allocation.getRequestLocalityType());\n \n-            if (LOG.isDebugEnabled()) {\n-              LOG.debug(\"allocate: applicationAttemptId\u003d\" + containerId\n-                  .getApplicationAttemptId() + \" container\u003d\" + containerId\n-                  + \" host\u003d\" + rmContainer.getAllocatedNode().getHost()\n-                  + \" type\u003d\" + allocation.getAllocationLocalityType());\n-            }\n-            RMAuditLogger.logSuccess(getUser(), AuditConstants.ALLOC_CONTAINER,\n-                \"SchedulerApp\", getApplicationId(), containerId,\n-                allocation.getAllocatedOrReservedResource());\n-          } else{\n-            SchedContainerChangeRequest increaseRequest \u003d\n-                getResourceChangeRequest(schedulerContainer);\n-\n-            // allocate resource for an increase request\n-            // Notify node\n-            schedulerContainer.getSchedulerNode().increaseContainer(\n-                increaseRequest.getContainerId(),\n-                increaseRequest.getDeltaCapacity());\n-\n-            // OK, we can allocate this increase request\n-            // Notify application\n-            increaseContainer(increaseRequest);\n+          if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"allocate: applicationAttemptId\u003d\" + containerId\n+                .getApplicationAttemptId() + \" container\u003d\" + containerId\n+                + \" host\u003d\" + rmContainer.getAllocatedNode().getHost()\n+                + \" type\u003d\" + allocation.getAllocationLocalityType());\n           }\n+          RMAuditLogger.logSuccess(getUser(), AuditConstants.ALLOC_CONTAINER,\n+              \"SchedulerApp\", getApplicationId(), containerId,\n+              allocation.getAllocatedOrReservedResource());\n         } else {\n-          if (!allocation.isIncreasedAllocation()) {\n-            // If the rmContainer\u0027s state is already updated to RESERVED, this is\n-            // a reReservation\n-            reserve(schedulerContainer.getSchedulerRequestKey(),\n-                schedulerContainer.getSchedulerNode(),\n-                schedulerContainer.getRmContainer(),\n-                schedulerContainer.getRmContainer().getContainer(),\n-                reReservation);\n-          } else{\n-            SchedContainerChangeRequest increaseRequest \u003d\n-                getResourceChangeRequest(schedulerContainer);\n-\n-            reserveIncreasedContainer(\n-                schedulerContainer.getSchedulerRequestKey(),\n-                schedulerContainer.getSchedulerNode(),\n-                increaseRequest.getRMContainer(),\n-                increaseRequest.getDeltaCapacity());\n-          }\n+          // If the rmContainer\u0027s state is already updated to RESERVED, this is\n+          // a reReservation\n+          reserve(schedulerContainer.getSchedulerRequestKey(),\n+              schedulerContainer.getSchedulerNode(),\n+              schedulerContainer.getRmContainer(),\n+              schedulerContainer.getRmContainer().getContainer(),\n+              reReservation);\n         }\n       }\n     } finally {\n       writeLock.unlock();\n     }\n \n     // Don\u0027t bother CS leaf queue if it is a re-reservation\n     if (!reReservation) {\n       getCSLeafQueue().apply(cluster, request);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void apply(Resource cluster,\n      ResourceCommitRequest\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e request) {\n    boolean reReservation \u003d false;\n\n    try {\n      writeLock.lock();\n\n      // If we allocated something\n      if (request.anythingAllocatedOrReserved()) {\n        ContainerAllocationProposal\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n            allocation \u003d request.getFirstAllocatedOrReservedContainer();\n        SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n            schedulerContainer \u003d allocation.getAllocatedOrReservedContainer();\n        RMContainer rmContainer \u003d schedulerContainer.getRmContainer();\n\n        reReservation \u003d\n            (!schedulerContainer.isAllocated()) \u0026\u0026 (rmContainer.getState()\n                \u003d\u003d RMContainerState.RESERVED);\n\n        // Generate new containerId if it is not an allocation for increasing\n        // Or re-reservation\n        if (rmContainer.getContainer().getId() \u003d\u003d null) {\n          rmContainer.setContainerId(BuilderUtils\n              .newContainerId(getApplicationAttemptId(),\n                  getNewContainerId()));\n        }\n        ContainerId containerId \u003d rmContainer.getContainerId();\n\n        if (schedulerContainer.isAllocated()) {\n          // This allocation is from a reserved container\n          // Unreserve it first\n          if (allocation.getAllocateFromReservedContainer() !\u003d null) {\n            RMContainer reservedContainer \u003d\n                allocation.getAllocateFromReservedContainer().getRmContainer();\n            // Handling container allocation\n            // Did we previously reserve containers at this \u0027priority\u0027?\n            unreserve(schedulerContainer.getSchedulerRequestKey(),\n                schedulerContainer.getSchedulerNode(), reservedContainer);\n          }\n\n          // Allocate a new container\n          addToNewlyAllocatedContainers(\n              schedulerContainer.getSchedulerNode(), rmContainer);\n          liveContainers.put(containerId, rmContainer);\n\n          // Deduct pending resource requests\n          List\u003cResourceRequest\u003e requests \u003d appSchedulingInfo.allocate(\n              allocation.getAllocationLocalityType(),\n              schedulerContainer.getSchedulerNode(),\n              schedulerContainer.getSchedulerRequestKey(),\n              schedulerContainer.getRmContainer().getContainer());\n          ((RMContainerImpl) rmContainer).setResourceRequests(requests);\n\n          attemptResourceUsage.incUsed(schedulerContainer.getNodePartition(),\n              allocation.getAllocatedOrReservedResource());\n\n          rmContainer.handle(\n              new RMContainerEvent(containerId, RMContainerEventType.START));\n\n          // Inform the node\n          schedulerContainer.getSchedulerNode().allocateContainer(\n              rmContainer);\n\n          // update locality statistics,\n          incNumAllocatedContainers(allocation.getAllocationLocalityType(),\n              allocation.getRequestLocalityType());\n\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"allocate: applicationAttemptId\u003d\" + containerId\n                .getApplicationAttemptId() + \" container\u003d\" + containerId\n                + \" host\u003d\" + rmContainer.getAllocatedNode().getHost()\n                + \" type\u003d\" + allocation.getAllocationLocalityType());\n          }\n          RMAuditLogger.logSuccess(getUser(), AuditConstants.ALLOC_CONTAINER,\n              \"SchedulerApp\", getApplicationId(), containerId,\n              allocation.getAllocatedOrReservedResource());\n        } else {\n          // If the rmContainer\u0027s state is already updated to RESERVED, this is\n          // a reReservation\n          reserve(schedulerContainer.getSchedulerRequestKey(),\n              schedulerContainer.getSchedulerNode(),\n              schedulerContainer.getRmContainer(),\n              schedulerContainer.getRmContainer().getContainer(),\n              reReservation);\n        }\n      }\n    } finally {\n      writeLock.unlock();\n    }\n\n    // Don\u0027t bother CS leaf queue if it is a re-reservation\n    if (!reReservation) {\n      getCSLeafQueue().apply(cluster, request);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/common/fica/FiCaSchedulerApp.java",
      "extendedDetails": {}
    },
    "0a55bd841ec0f2eb89a0383f4c589526e8b138d4": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5959. RM changes to support change of container ExecutionType. (Arun Suresh via wangda)\n",
      "commitDate": "05/01/17 10:31 AM",
      "commitName": "0a55bd841ec0f2eb89a0383f4c589526e8b138d4",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "27/12/16 12:40 PM",
      "commitNameOld": "ac1e5d4f77e3b9df8dcacb0b1f72eecc27931eb8",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 8.91,
      "commitsBetweenForRepo": 37,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,122 +1,124 @@\n   public void apply(Resource cluster,\n       ResourceCommitRequest\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e request) {\n     boolean reReservation \u003d false;\n \n     try {\n       writeLock.lock();\n \n       // If we allocated something\n       if (request.anythingAllocatedOrReserved()) {\n         ContainerAllocationProposal\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n             allocation \u003d request.getFirstAllocatedOrReservedContainer();\n         SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n             schedulerContainer \u003d allocation.getAllocatedOrReservedContainer();\n         RMContainer rmContainer \u003d schedulerContainer.getRmContainer();\n \n         reReservation \u003d\n             (!schedulerContainer.isAllocated()) \u0026\u0026 (rmContainer.getState()\n                 \u003d\u003d RMContainerState.RESERVED);\n \n         // Generate new containerId if it is not an allocation for increasing\n         // Or re-reservation\n         if (!allocation.isIncreasedAllocation()) {\n           if (rmContainer.getContainer().getId() \u003d\u003d null) {\n             rmContainer.setContainerId(BuilderUtils\n                 .newContainerId(getApplicationAttemptId(),\n                     getNewContainerId()));\n           }\n         }\n         ContainerId containerId \u003d rmContainer.getContainerId();\n \n         if (schedulerContainer.isAllocated()) {\n           // This allocation is from a reserved container\n           // Unreserve it first\n           if (allocation.getAllocateFromReservedContainer() !\u003d null) {\n             RMContainer reservedContainer \u003d\n                 allocation.getAllocateFromReservedContainer().getRmContainer();\n             // Handling container allocation\n             // Did we previously reserve containers at this \u0027priority\u0027?\n             unreserve(schedulerContainer.getSchedulerRequestKey(),\n                 schedulerContainer.getSchedulerNode(), reservedContainer);\n           }\n \n           // Update this application for the allocated container\n           if (!allocation.isIncreasedAllocation()) {\n             // Allocate a new container\n-            newlyAllocatedContainers.add(rmContainer);\n+            addToNewlyAllocatedContainers(\n+                schedulerContainer.getSchedulerNode(), rmContainer);\n             liveContainers.put(containerId, rmContainer);\n \n             // Deduct pending resource requests\n             List\u003cResourceRequest\u003e requests \u003d appSchedulingInfo.allocate(\n-                allocation.getAllocationLocalityType(), schedulerContainer.getSchedulerNode(),\n+                allocation.getAllocationLocalityType(),\n+                schedulerContainer.getSchedulerNode(),\n                 schedulerContainer.getSchedulerRequestKey(),\n                 schedulerContainer.getRmContainer().getContainer());\n             ((RMContainerImpl) rmContainer).setResourceRequests(requests);\n \n             attemptResourceUsage.incUsed(schedulerContainer.getNodePartition(),\n                 allocation.getAllocatedOrReservedResource());\n \n             rmContainer.handle(\n                 new RMContainerEvent(containerId, RMContainerEventType.START));\n \n             // Inform the node\n             schedulerContainer.getSchedulerNode().allocateContainer(\n                 rmContainer);\n \n             // update locality statistics,\n             incNumAllocatedContainers(allocation.getAllocationLocalityType(),\n                 allocation.getRequestLocalityType());\n \n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"allocate: applicationAttemptId\u003d\" + containerId\n                   .getApplicationAttemptId() + \" container\u003d\" + containerId\n                   + \" host\u003d\" + rmContainer.getAllocatedNode().getHost()\n                   + \" type\u003d\" + allocation.getAllocationLocalityType());\n             }\n             RMAuditLogger.logSuccess(getUser(), AuditConstants.ALLOC_CONTAINER,\n                 \"SchedulerApp\", getApplicationId(), containerId,\n                 allocation.getAllocatedOrReservedResource());\n           } else{\n             SchedContainerChangeRequest increaseRequest \u003d\n                 getResourceChangeRequest(schedulerContainer);\n \n             // allocate resource for an increase request\n             // Notify node\n             schedulerContainer.getSchedulerNode().increaseContainer(\n                 increaseRequest.getContainerId(),\n                 increaseRequest.getDeltaCapacity());\n \n             // OK, we can allocate this increase request\n             // Notify application\n             increaseContainer(increaseRequest);\n           }\n         } else {\n           if (!allocation.isIncreasedAllocation()) {\n             // If the rmContainer\u0027s state is already updated to RESERVED, this is\n             // a reReservation\n             reserve(schedulerContainer.getSchedulerRequestKey(),\n                 schedulerContainer.getSchedulerNode(),\n                 schedulerContainer.getRmContainer(),\n                 schedulerContainer.getRmContainer().getContainer(),\n                 reReservation);\n           } else{\n             SchedContainerChangeRequest increaseRequest \u003d\n                 getResourceChangeRequest(schedulerContainer);\n \n             reserveIncreasedContainer(\n                 schedulerContainer.getSchedulerRequestKey(),\n                 schedulerContainer.getSchedulerNode(),\n                 increaseRequest.getRMContainer(),\n                 increaseRequest.getDeltaCapacity());\n           }\n         }\n       }\n     } finally {\n       writeLock.unlock();\n     }\n \n     // Don\u0027t bother CS leaf queue if it is a re-reservation\n     if (!reReservation) {\n       getCSLeafQueue().apply(cluster, request);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void apply(Resource cluster,\n      ResourceCommitRequest\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e request) {\n    boolean reReservation \u003d false;\n\n    try {\n      writeLock.lock();\n\n      // If we allocated something\n      if (request.anythingAllocatedOrReserved()) {\n        ContainerAllocationProposal\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n            allocation \u003d request.getFirstAllocatedOrReservedContainer();\n        SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n            schedulerContainer \u003d allocation.getAllocatedOrReservedContainer();\n        RMContainer rmContainer \u003d schedulerContainer.getRmContainer();\n\n        reReservation \u003d\n            (!schedulerContainer.isAllocated()) \u0026\u0026 (rmContainer.getState()\n                \u003d\u003d RMContainerState.RESERVED);\n\n        // Generate new containerId if it is not an allocation for increasing\n        // Or re-reservation\n        if (!allocation.isIncreasedAllocation()) {\n          if (rmContainer.getContainer().getId() \u003d\u003d null) {\n            rmContainer.setContainerId(BuilderUtils\n                .newContainerId(getApplicationAttemptId(),\n                    getNewContainerId()));\n          }\n        }\n        ContainerId containerId \u003d rmContainer.getContainerId();\n\n        if (schedulerContainer.isAllocated()) {\n          // This allocation is from a reserved container\n          // Unreserve it first\n          if (allocation.getAllocateFromReservedContainer() !\u003d null) {\n            RMContainer reservedContainer \u003d\n                allocation.getAllocateFromReservedContainer().getRmContainer();\n            // Handling container allocation\n            // Did we previously reserve containers at this \u0027priority\u0027?\n            unreserve(schedulerContainer.getSchedulerRequestKey(),\n                schedulerContainer.getSchedulerNode(), reservedContainer);\n          }\n\n          // Update this application for the allocated container\n          if (!allocation.isIncreasedAllocation()) {\n            // Allocate a new container\n            addToNewlyAllocatedContainers(\n                schedulerContainer.getSchedulerNode(), rmContainer);\n            liveContainers.put(containerId, rmContainer);\n\n            // Deduct pending resource requests\n            List\u003cResourceRequest\u003e requests \u003d appSchedulingInfo.allocate(\n                allocation.getAllocationLocalityType(),\n                schedulerContainer.getSchedulerNode(),\n                schedulerContainer.getSchedulerRequestKey(),\n                schedulerContainer.getRmContainer().getContainer());\n            ((RMContainerImpl) rmContainer).setResourceRequests(requests);\n\n            attemptResourceUsage.incUsed(schedulerContainer.getNodePartition(),\n                allocation.getAllocatedOrReservedResource());\n\n            rmContainer.handle(\n                new RMContainerEvent(containerId, RMContainerEventType.START));\n\n            // Inform the node\n            schedulerContainer.getSchedulerNode().allocateContainer(\n                rmContainer);\n\n            // update locality statistics,\n            incNumAllocatedContainers(allocation.getAllocationLocalityType(),\n                allocation.getRequestLocalityType());\n\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"allocate: applicationAttemptId\u003d\" + containerId\n                  .getApplicationAttemptId() + \" container\u003d\" + containerId\n                  + \" host\u003d\" + rmContainer.getAllocatedNode().getHost()\n                  + \" type\u003d\" + allocation.getAllocationLocalityType());\n            }\n            RMAuditLogger.logSuccess(getUser(), AuditConstants.ALLOC_CONTAINER,\n                \"SchedulerApp\", getApplicationId(), containerId,\n                allocation.getAllocatedOrReservedResource());\n          } else{\n            SchedContainerChangeRequest increaseRequest \u003d\n                getResourceChangeRequest(schedulerContainer);\n\n            // allocate resource for an increase request\n            // Notify node\n            schedulerContainer.getSchedulerNode().increaseContainer(\n                increaseRequest.getContainerId(),\n                increaseRequest.getDeltaCapacity());\n\n            // OK, we can allocate this increase request\n            // Notify application\n            increaseContainer(increaseRequest);\n          }\n        } else {\n          if (!allocation.isIncreasedAllocation()) {\n            // If the rmContainer\u0027s state is already updated to RESERVED, this is\n            // a reReservation\n            reserve(schedulerContainer.getSchedulerRequestKey(),\n                schedulerContainer.getSchedulerNode(),\n                schedulerContainer.getRmContainer(),\n                schedulerContainer.getRmContainer().getContainer(),\n                reReservation);\n          } else{\n            SchedContainerChangeRequest increaseRequest \u003d\n                getResourceChangeRequest(schedulerContainer);\n\n            reserveIncreasedContainer(\n                schedulerContainer.getSchedulerRequestKey(),\n                schedulerContainer.getSchedulerNode(),\n                increaseRequest.getRMContainer(),\n                increaseRequest.getDeltaCapacity());\n          }\n        }\n      }\n    } finally {\n      writeLock.unlock();\n    }\n\n    // Don\u0027t bother CS leaf queue if it is a re-reservation\n    if (!reReservation) {\n      getCSLeafQueue().apply(cluster, request);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/common/fica/FiCaSchedulerApp.java",
      "extendedDetails": {}
    },
    "de3b4aac561258ad242a3c5ed1c919428893fd4c": {
      "type": "Yintroduced",
      "commitMessage": "YARN-5716. Add global scheduler interface definition and update CapacityScheduler to use it. Contributed by Wangda Tan\n",
      "commitDate": "07/11/16 10:14 AM",
      "commitName": "de3b4aac561258ad242a3c5ed1c919428893fd4c",
      "commitAuthor": "Jian He",
      "diff": "@@ -0,0 +1,122 @@\n+  public void apply(Resource cluster,\n+      ResourceCommitRequest\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e request) {\n+    boolean reReservation \u003d false;\n+\n+    try {\n+      writeLock.lock();\n+\n+      // If we allocated something\n+      if (request.anythingAllocatedOrReserved()) {\n+        ContainerAllocationProposal\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n+            allocation \u003d request.getFirstAllocatedOrReservedContainer();\n+        SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n+            schedulerContainer \u003d allocation.getAllocatedOrReservedContainer();\n+        RMContainer rmContainer \u003d schedulerContainer.getRmContainer();\n+\n+        reReservation \u003d\n+            (!schedulerContainer.isAllocated()) \u0026\u0026 (rmContainer.getState()\n+                \u003d\u003d RMContainerState.RESERVED);\n+\n+        // Generate new containerId if it is not an allocation for increasing\n+        // Or re-reservation\n+        if (!allocation.isIncreasedAllocation()) {\n+          if (rmContainer.getContainer().getId() \u003d\u003d null) {\n+            rmContainer.setContainerId(BuilderUtils\n+                .newContainerId(getApplicationAttemptId(),\n+                    getNewContainerId()));\n+          }\n+        }\n+        ContainerId containerId \u003d rmContainer.getContainerId();\n+\n+        if (schedulerContainer.isAllocated()) {\n+          // This allocation is from a reserved container\n+          // Unreserve it first\n+          if (allocation.getAllocateFromReservedContainer() !\u003d null) {\n+            RMContainer reservedContainer \u003d\n+                allocation.getAllocateFromReservedContainer().getRmContainer();\n+            // Handling container allocation\n+            // Did we previously reserve containers at this \u0027priority\u0027?\n+            unreserve(schedulerContainer.getSchedulerRequestKey(),\n+                schedulerContainer.getSchedulerNode(), reservedContainer);\n+          }\n+\n+          // Update this application for the allocated container\n+          if (!allocation.isIncreasedAllocation()) {\n+            // Allocate a new container\n+            newlyAllocatedContainers.add(rmContainer);\n+            liveContainers.put(containerId, rmContainer);\n+\n+            // Deduct pending resource requests\n+            List\u003cResourceRequest\u003e requests \u003d appSchedulingInfo.allocate(\n+                allocation.getAllocationLocalityType(), schedulerContainer.getSchedulerNode(),\n+                schedulerContainer.getSchedulerRequestKey(),\n+                schedulerContainer.getRmContainer().getContainer());\n+            ((RMContainerImpl) rmContainer).setResourceRequests(requests);\n+\n+            attemptResourceUsage.incUsed(schedulerContainer.getNodePartition(),\n+                allocation.getAllocatedOrReservedResource());\n+\n+            rmContainer.handle(\n+                new RMContainerEvent(containerId, RMContainerEventType.START));\n+\n+            // Inform the node\n+            schedulerContainer.getSchedulerNode().allocateContainer(\n+                rmContainer);\n+\n+            // update locality statistics,\n+            incNumAllocatedContainers(allocation.getAllocationLocalityType(),\n+                allocation.getRequestLocalityType());\n+\n+            if (LOG.isDebugEnabled()) {\n+              LOG.debug(\"allocate: applicationAttemptId\u003d\" + containerId\n+                  .getApplicationAttemptId() + \" container\u003d\" + containerId\n+                  + \" host\u003d\" + rmContainer.getAllocatedNode().getHost()\n+                  + \" type\u003d\" + allocation.getAllocationLocalityType());\n+            }\n+            RMAuditLogger.logSuccess(getUser(), AuditConstants.ALLOC_CONTAINER,\n+                \"SchedulerApp\", getApplicationId(), containerId,\n+                allocation.getAllocatedOrReservedResource());\n+          } else{\n+            SchedContainerChangeRequest increaseRequest \u003d\n+                getResourceChangeRequest(schedulerContainer);\n+\n+            // allocate resource for an increase request\n+            // Notify node\n+            schedulerContainer.getSchedulerNode().increaseContainer(\n+                increaseRequest.getContainerId(),\n+                increaseRequest.getDeltaCapacity());\n+\n+            // OK, we can allocate this increase request\n+            // Notify application\n+            increaseContainer(increaseRequest);\n+          }\n+        } else {\n+          if (!allocation.isIncreasedAllocation()) {\n+            // If the rmContainer\u0027s state is already updated to RESERVED, this is\n+            // a reReservation\n+            reserve(schedulerContainer.getSchedulerRequestKey(),\n+                schedulerContainer.getSchedulerNode(),\n+                schedulerContainer.getRmContainer(),\n+                schedulerContainer.getRmContainer().getContainer(),\n+                reReservation);\n+          } else{\n+            SchedContainerChangeRequest increaseRequest \u003d\n+                getResourceChangeRequest(schedulerContainer);\n+\n+            reserveIncreasedContainer(\n+                schedulerContainer.getSchedulerRequestKey(),\n+                schedulerContainer.getSchedulerNode(),\n+                increaseRequest.getRMContainer(),\n+                increaseRequest.getDeltaCapacity());\n+          }\n+        }\n+      }\n+    } finally {\n+      writeLock.unlock();\n+    }\n+\n+    // Don\u0027t bother CS leaf queue if it is a re-reservation\n+    if (!reReservation) {\n+      getCSLeafQueue().apply(cluster, request);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void apply(Resource cluster,\n      ResourceCommitRequest\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e request) {\n    boolean reReservation \u003d false;\n\n    try {\n      writeLock.lock();\n\n      // If we allocated something\n      if (request.anythingAllocatedOrReserved()) {\n        ContainerAllocationProposal\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n            allocation \u003d request.getFirstAllocatedOrReservedContainer();\n        SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n            schedulerContainer \u003d allocation.getAllocatedOrReservedContainer();\n        RMContainer rmContainer \u003d schedulerContainer.getRmContainer();\n\n        reReservation \u003d\n            (!schedulerContainer.isAllocated()) \u0026\u0026 (rmContainer.getState()\n                \u003d\u003d RMContainerState.RESERVED);\n\n        // Generate new containerId if it is not an allocation for increasing\n        // Or re-reservation\n        if (!allocation.isIncreasedAllocation()) {\n          if (rmContainer.getContainer().getId() \u003d\u003d null) {\n            rmContainer.setContainerId(BuilderUtils\n                .newContainerId(getApplicationAttemptId(),\n                    getNewContainerId()));\n          }\n        }\n        ContainerId containerId \u003d rmContainer.getContainerId();\n\n        if (schedulerContainer.isAllocated()) {\n          // This allocation is from a reserved container\n          // Unreserve it first\n          if (allocation.getAllocateFromReservedContainer() !\u003d null) {\n            RMContainer reservedContainer \u003d\n                allocation.getAllocateFromReservedContainer().getRmContainer();\n            // Handling container allocation\n            // Did we previously reserve containers at this \u0027priority\u0027?\n            unreserve(schedulerContainer.getSchedulerRequestKey(),\n                schedulerContainer.getSchedulerNode(), reservedContainer);\n          }\n\n          // Update this application for the allocated container\n          if (!allocation.isIncreasedAllocation()) {\n            // Allocate a new container\n            newlyAllocatedContainers.add(rmContainer);\n            liveContainers.put(containerId, rmContainer);\n\n            // Deduct pending resource requests\n            List\u003cResourceRequest\u003e requests \u003d appSchedulingInfo.allocate(\n                allocation.getAllocationLocalityType(), schedulerContainer.getSchedulerNode(),\n                schedulerContainer.getSchedulerRequestKey(),\n                schedulerContainer.getRmContainer().getContainer());\n            ((RMContainerImpl) rmContainer).setResourceRequests(requests);\n\n            attemptResourceUsage.incUsed(schedulerContainer.getNodePartition(),\n                allocation.getAllocatedOrReservedResource());\n\n            rmContainer.handle(\n                new RMContainerEvent(containerId, RMContainerEventType.START));\n\n            // Inform the node\n            schedulerContainer.getSchedulerNode().allocateContainer(\n                rmContainer);\n\n            // update locality statistics,\n            incNumAllocatedContainers(allocation.getAllocationLocalityType(),\n                allocation.getRequestLocalityType());\n\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"allocate: applicationAttemptId\u003d\" + containerId\n                  .getApplicationAttemptId() + \" container\u003d\" + containerId\n                  + \" host\u003d\" + rmContainer.getAllocatedNode().getHost()\n                  + \" type\u003d\" + allocation.getAllocationLocalityType());\n            }\n            RMAuditLogger.logSuccess(getUser(), AuditConstants.ALLOC_CONTAINER,\n                \"SchedulerApp\", getApplicationId(), containerId,\n                allocation.getAllocatedOrReservedResource());\n          } else{\n            SchedContainerChangeRequest increaseRequest \u003d\n                getResourceChangeRequest(schedulerContainer);\n\n            // allocate resource for an increase request\n            // Notify node\n            schedulerContainer.getSchedulerNode().increaseContainer(\n                increaseRequest.getContainerId(),\n                increaseRequest.getDeltaCapacity());\n\n            // OK, we can allocate this increase request\n            // Notify application\n            increaseContainer(increaseRequest);\n          }\n        } else {\n          if (!allocation.isIncreasedAllocation()) {\n            // If the rmContainer\u0027s state is already updated to RESERVED, this is\n            // a reReservation\n            reserve(schedulerContainer.getSchedulerRequestKey(),\n                schedulerContainer.getSchedulerNode(),\n                schedulerContainer.getRmContainer(),\n                schedulerContainer.getRmContainer().getContainer(),\n                reReservation);\n          } else{\n            SchedContainerChangeRequest increaseRequest \u003d\n                getResourceChangeRequest(schedulerContainer);\n\n            reserveIncreasedContainer(\n                schedulerContainer.getSchedulerRequestKey(),\n                schedulerContainer.getSchedulerNode(),\n                increaseRequest.getRMContainer(),\n                increaseRequest.getDeltaCapacity());\n          }\n        }\n      }\n    } finally {\n      writeLock.unlock();\n    }\n\n    // Don\u0027t bother CS leaf queue if it is a re-reservation\n    if (!reReservation) {\n      getCSLeafQueue().apply(cluster, request);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/common/fica/FiCaSchedulerApp.java"
    }
  }
}