{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "RootDocProcessor.java",
  "functionName": "invoke",
  "functionId": "invoke___proxy-Object__method-Method__args-Object[]",
  "sourceFilePath": "hadoop-common-project/hadoop-annotations/src/main/java/org/apache/hadoop/classification/tools/RootDocProcessor.java",
  "functionStartLine": 101,
  "functionEndLine": 177,
  "numCommitsSeen": 8,
  "timeTaken": 896,
  "changeHistory": [
    "03fc6b1bb0f5c0844cd5477ffba43de8a14d4d60",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
    "980f99bfb7b1c404b6e8346771803e113d16f71d"
  ],
  "changeHistoryShort": {
    "03fc6b1bb0f5c0844cd5477ffba43de8a14d4d60": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52": "Yfilerename",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yfilerename",
    "980f99bfb7b1c404b6e8346771803e113d16f71d": "Yintroduced"
  },
  "changeHistoryDetails": {
    "03fc6b1bb0f5c0844cd5477ffba43de8a14d4d60": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3426. Add jdiff support to YARN. (vinodkv via wangda)\n",
      "commitDate": "10/06/16 9:51 AM",
      "commitName": "03fc6b1bb0f5c0844cd5477ffba43de8a14d4d60",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "08/04/15 5:56 PM",
      "commitNameOld": "dc0282d64c6528b02aa9f2df49be01223f087081",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 428.66,
      "commitsBetweenForRepo": 3172,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,73 +1,77 @@\n     public Object invoke(Object proxy, Method method, Object[] args)\n         throws Throwable {\n       String methodName \u003d method.getName();\n       if (target instanceof Doc) {\n         if (methodName.equals(\"isIncluded\")) {\n           Doc doc \u003d (Doc) target;\n           return !exclude(doc) \u0026\u0026 doc.isIncluded();\n         }\n         if (target instanceof RootDoc) {\n           if (methodName.equals(\"classes\")) {\n             return filter(((RootDoc) target).classes(), ClassDoc.class);\n           } else if (methodName.equals(\"specifiedClasses\")) {\n             return filter(((RootDoc) target).specifiedClasses(), ClassDoc.class);\n           } else if (methodName.equals(\"specifiedPackages\")) {\n             return filter(((RootDoc) target).specifiedPackages(), PackageDoc.class);\n           }\n         } else if (target instanceof ClassDoc) {\n           if (isFiltered(args)) {\n             if (methodName.equals(\"methods\")) {\n               return filter(((ClassDoc) target).methods(true), MethodDoc.class);\n             } else if (methodName.equals(\"fields\")) {\n               return filter(((ClassDoc) target).fields(true), FieldDoc.class);\n             } else if (methodName.equals(\"innerClasses\")) {\n               return filter(((ClassDoc) target).innerClasses(true),\n                   ClassDoc.class);\n             } else if (methodName.equals(\"constructors\")) {\n               return filter(((ClassDoc) target).constructors(true),\n                   ConstructorDoc.class);\n             }\n+          } else {\n+            if (methodName.equals(\"methods\")) {\n+              return filter(((ClassDoc) target).methods(true), MethodDoc.class);\n+            }\n           }\n         } else if (target instanceof PackageDoc) {\n           if (methodName.equals(\"allClasses\")) {\n             if (isFiltered(args)) {\n               return filter(((PackageDoc) target).allClasses(true),\n                   ClassDoc.class);\n             } else {\n               return filter(((PackageDoc) target).allClasses(), ClassDoc.class);\n             }\n           } else if (methodName.equals(\"annotationTypes\")) {\n             return filter(((PackageDoc) target).annotationTypes(),\n                 AnnotationTypeDoc.class);\n           } else if (methodName.equals(\"enums\")) {\n             return filter(((PackageDoc) target).enums(),\n                 ClassDoc.class);\n           } else if (methodName.equals(\"errors\")) {\n             return filter(((PackageDoc) target).errors(),\n                 ClassDoc.class);\n           } else if (methodName.equals(\"exceptions\")) {\n             return filter(((PackageDoc) target).exceptions(),\n                 ClassDoc.class);\n           } else if (methodName.equals(\"interfaces\")) {\n             return filter(((PackageDoc) target).interfaces(),\n                 ClassDoc.class);\n           } else if (methodName.equals(\"ordinaryClasses\")) {\n             return filter(((PackageDoc) target).ordinaryClasses(),\n                 ClassDoc.class);\n           }\n         }\n       }\n \n       if (args !\u003d null) {\n         if (methodName.equals(\"compareTo\") || methodName.equals(\"equals\")\n             || methodName.equals(\"overrides\")\n             || methodName.equals(\"subclassOf\")) {\n           args[0] \u003d unwrap(args[0]);\n         }\n       }\n       try {\n         return process(method.invoke(target, args), method.getReturnType());\n       } catch (InvocationTargetException e) {\n         throw e.getTargetException();\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public Object invoke(Object proxy, Method method, Object[] args)\n        throws Throwable {\n      String methodName \u003d method.getName();\n      if (target instanceof Doc) {\n        if (methodName.equals(\"isIncluded\")) {\n          Doc doc \u003d (Doc) target;\n          return !exclude(doc) \u0026\u0026 doc.isIncluded();\n        }\n        if (target instanceof RootDoc) {\n          if (methodName.equals(\"classes\")) {\n            return filter(((RootDoc) target).classes(), ClassDoc.class);\n          } else if (methodName.equals(\"specifiedClasses\")) {\n            return filter(((RootDoc) target).specifiedClasses(), ClassDoc.class);\n          } else if (methodName.equals(\"specifiedPackages\")) {\n            return filter(((RootDoc) target).specifiedPackages(), PackageDoc.class);\n          }\n        } else if (target instanceof ClassDoc) {\n          if (isFiltered(args)) {\n            if (methodName.equals(\"methods\")) {\n              return filter(((ClassDoc) target).methods(true), MethodDoc.class);\n            } else if (methodName.equals(\"fields\")) {\n              return filter(((ClassDoc) target).fields(true), FieldDoc.class);\n            } else if (methodName.equals(\"innerClasses\")) {\n              return filter(((ClassDoc) target).innerClasses(true),\n                  ClassDoc.class);\n            } else if (methodName.equals(\"constructors\")) {\n              return filter(((ClassDoc) target).constructors(true),\n                  ConstructorDoc.class);\n            }\n          } else {\n            if (methodName.equals(\"methods\")) {\n              return filter(((ClassDoc) target).methods(true), MethodDoc.class);\n            }\n          }\n        } else if (target instanceof PackageDoc) {\n          if (methodName.equals(\"allClasses\")) {\n            if (isFiltered(args)) {\n              return filter(((PackageDoc) target).allClasses(true),\n                  ClassDoc.class);\n            } else {\n              return filter(((PackageDoc) target).allClasses(), ClassDoc.class);\n            }\n          } else if (methodName.equals(\"annotationTypes\")) {\n            return filter(((PackageDoc) target).annotationTypes(),\n                AnnotationTypeDoc.class);\n          } else if (methodName.equals(\"enums\")) {\n            return filter(((PackageDoc) target).enums(),\n                ClassDoc.class);\n          } else if (methodName.equals(\"errors\")) {\n            return filter(((PackageDoc) target).errors(),\n                ClassDoc.class);\n          } else if (methodName.equals(\"exceptions\")) {\n            return filter(((PackageDoc) target).exceptions(),\n                ClassDoc.class);\n          } else if (methodName.equals(\"interfaces\")) {\n            return filter(((PackageDoc) target).interfaces(),\n                ClassDoc.class);\n          } else if (methodName.equals(\"ordinaryClasses\")) {\n            return filter(((PackageDoc) target).ordinaryClasses(),\n                ClassDoc.class);\n          }\n        }\n      }\n\n      if (args !\u003d null) {\n        if (methodName.equals(\"compareTo\") || methodName.equals(\"equals\")\n            || methodName.equals(\"overrides\")\n            || methodName.equals(\"subclassOf\")) {\n          args[0] \u003d unwrap(args[0]);\n        }\n      }\n      try {\n        return process(method.invoke(target, args), method.getReturnType());\n      } catch (InvocationTargetException e) {\n        throw e.getTargetException();\n      }\n    }",
      "path": "hadoop-common-project/hadoop-annotations/src/main/java/org/apache/hadoop/classification/tools/RootDocProcessor.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    public Object invoke(Object proxy, Method method, Object[] args)\n\tthrows Throwable {\n      String methodName \u003d method.getName();\n      if (target instanceof Doc) {\n\tif (methodName.equals(\"isIncluded\")) {\n\t  Doc doc \u003d (Doc) target;\n\t  return !exclude(doc) \u0026\u0026 doc.isIncluded();\n\t}\n\tif (target instanceof RootDoc) {\n\t  if (methodName.equals(\"classes\")) {\n\t    return filter(((RootDoc) target).classes(), ClassDoc.class);\n\t  } else if (methodName.equals(\"specifiedClasses\")) {\n\t    return filter(((RootDoc) target).specifiedClasses(), ClassDoc.class);\n\t  } else if (methodName.equals(\"specifiedPackages\")) {\n\t    return filter(((RootDoc) target).specifiedPackages(), PackageDoc.class);\n\t  }\n\t} else if (target instanceof ClassDoc) {\n\t  if (isFiltered(args)) {\n\t    if (methodName.equals(\"methods\")) {\n\t      return filter(((ClassDoc) target).methods(true), MethodDoc.class);\n\t    } else if (methodName.equals(\"fields\")) {\n\t      return filter(((ClassDoc) target).fields(true), FieldDoc.class);\n\t    } else if (methodName.equals(\"innerClasses\")) {\n\t      return filter(((ClassDoc) target).innerClasses(true),\n\t\t  ClassDoc.class);\n\t    } else if (methodName.equals(\"constructors\")) {\n\t      return filter(((ClassDoc) target).constructors(true),\n\t\t  ConstructorDoc.class);\n\t    }\n\t  }\n\t} else if (target instanceof PackageDoc) {\n\t  if (methodName.equals(\"allClasses\")) {\n\t    if (isFiltered(args)) {\n\t      return filter(((PackageDoc) target).allClasses(true),\n\t\tClassDoc.class);\n\t    } else {\n\t      return filter(((PackageDoc) target).allClasses(), ClassDoc.class);  \n\t    }\n\t  } else if (methodName.equals(\"annotationTypes\")) {\n\t    return filter(((PackageDoc) target).annotationTypes(),\n\t\tAnnotationTypeDoc.class);\n\t  } else if (methodName.equals(\"enums\")) {\n\t    return filter(((PackageDoc) target).enums(),\n\t\tClassDoc.class);\n\t  } else if (methodName.equals(\"errors\")) {\n\t    return filter(((PackageDoc) target).errors(),\n\t\tClassDoc.class);\n\t  } else if (methodName.equals(\"exceptions\")) {\n\t    return filter(((PackageDoc) target).exceptions(),\n\t\tClassDoc.class);\n\t  } else if (methodName.equals(\"interfaces\")) {\n\t    return filter(((PackageDoc) target).interfaces(),\n\t\tClassDoc.class);\n\t  } else if (methodName.equals(\"ordinaryClasses\")) {\n\t    return filter(((PackageDoc) target).ordinaryClasses(),\n\t\tClassDoc.class);\n\t  }\n\t}\n      }\n\n      if (args !\u003d null) {\n\tif (methodName.equals(\"compareTo\") || methodName.equals(\"equals\")\n\t    || methodName.equals(\"overrides\")\n\t    || methodName.equals(\"subclassOf\")) {\n\t  args[0] \u003d unwrap(args[0]);\n\t}\n      }\n      try {\n\treturn process(method.invoke(target, args), method.getReturnType());\n      } catch (InvocationTargetException e) {\n\tthrow e.getTargetException();\n      }\n    }",
      "path": "hadoop-common-project/hadoop-annotations/src/main/java/org/apache/hadoop/classification/tools/RootDocProcessor.java",
      "extendedDetails": {
        "oldPath": "hadoop-annotations/src/main/java/org/apache/hadoop/classification/tools/RootDocProcessor.java",
        "newPath": "hadoop-common-project/hadoop-annotations/src/main/java/org/apache/hadoop/classification/tools/RootDocProcessor.java"
      }
    },
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-6671. Use maven for hadoop common builds. Contributed by Alejandro Abdelnur.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1153184 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/08/11 9:37 AM",
      "commitName": "0f6dfeeacbab65a31a33927a4eb84871d371fe52",
      "commitAuthor": "Thomas White",
      "commitDateOld": "01/08/11 3:53 PM",
      "commitNameOld": "9bac807cedbcff34e1a144fb475eff267e5ed86d",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.74,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    public Object invoke(Object proxy, Method method, Object[] args)\n\tthrows Throwable {\n      String methodName \u003d method.getName();\n      if (target instanceof Doc) {\n\tif (methodName.equals(\"isIncluded\")) {\n\t  Doc doc \u003d (Doc) target;\n\t  return !exclude(doc) \u0026\u0026 doc.isIncluded();\n\t}\n\tif (target instanceof RootDoc) {\n\t  if (methodName.equals(\"classes\")) {\n\t    return filter(((RootDoc) target).classes(), ClassDoc.class);\n\t  } else if (methodName.equals(\"specifiedClasses\")) {\n\t    return filter(((RootDoc) target).specifiedClasses(), ClassDoc.class);\n\t  } else if (methodName.equals(\"specifiedPackages\")) {\n\t    return filter(((RootDoc) target).specifiedPackages(), PackageDoc.class);\n\t  }\n\t} else if (target instanceof ClassDoc) {\n\t  if (isFiltered(args)) {\n\t    if (methodName.equals(\"methods\")) {\n\t      return filter(((ClassDoc) target).methods(true), MethodDoc.class);\n\t    } else if (methodName.equals(\"fields\")) {\n\t      return filter(((ClassDoc) target).fields(true), FieldDoc.class);\n\t    } else if (methodName.equals(\"innerClasses\")) {\n\t      return filter(((ClassDoc) target).innerClasses(true),\n\t\t  ClassDoc.class);\n\t    } else if (methodName.equals(\"constructors\")) {\n\t      return filter(((ClassDoc) target).constructors(true),\n\t\t  ConstructorDoc.class);\n\t    }\n\t  }\n\t} else if (target instanceof PackageDoc) {\n\t  if (methodName.equals(\"allClasses\")) {\n\t    if (isFiltered(args)) {\n\t      return filter(((PackageDoc) target).allClasses(true),\n\t\tClassDoc.class);\n\t    } else {\n\t      return filter(((PackageDoc) target).allClasses(), ClassDoc.class);  \n\t    }\n\t  } else if (methodName.equals(\"annotationTypes\")) {\n\t    return filter(((PackageDoc) target).annotationTypes(),\n\t\tAnnotationTypeDoc.class);\n\t  } else if (methodName.equals(\"enums\")) {\n\t    return filter(((PackageDoc) target).enums(),\n\t\tClassDoc.class);\n\t  } else if (methodName.equals(\"errors\")) {\n\t    return filter(((PackageDoc) target).errors(),\n\t\tClassDoc.class);\n\t  } else if (methodName.equals(\"exceptions\")) {\n\t    return filter(((PackageDoc) target).exceptions(),\n\t\tClassDoc.class);\n\t  } else if (methodName.equals(\"interfaces\")) {\n\t    return filter(((PackageDoc) target).interfaces(),\n\t\tClassDoc.class);\n\t  } else if (methodName.equals(\"ordinaryClasses\")) {\n\t    return filter(((PackageDoc) target).ordinaryClasses(),\n\t\tClassDoc.class);\n\t  }\n\t}\n      }\n\n      if (args !\u003d null) {\n\tif (methodName.equals(\"compareTo\") || methodName.equals(\"equals\")\n\t    || methodName.equals(\"overrides\")\n\t    || methodName.equals(\"subclassOf\")) {\n\t  args[0] \u003d unwrap(args[0]);\n\t}\n      }\n      try {\n\treturn process(method.invoke(target, args), method.getReturnType());\n      } catch (InvocationTargetException e) {\n\tthrow e.getTargetException();\n      }\n    }",
      "path": "hadoop-annotations/src/main/java/org/apache/hadoop/classification/tools/RootDocProcessor.java",
      "extendedDetails": {
        "oldPath": "common/src/java/org/apache/hadoop/classification/tools/RootDocProcessor.java",
        "newPath": "hadoop-annotations/src/main/java/org/apache/hadoop/classification/tools/RootDocProcessor.java"
      }
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "11/06/11 9:13 PM",
      "commitNameOld": "a285fb5effe9ba3be4ec5f942afaf5ddd1186151",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 0.74,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    public Object invoke(Object proxy, Method method, Object[] args)\n\tthrows Throwable {\n      String methodName \u003d method.getName();\n      if (target instanceof Doc) {\n\tif (methodName.equals(\"isIncluded\")) {\n\t  Doc doc \u003d (Doc) target;\n\t  return !exclude(doc) \u0026\u0026 doc.isIncluded();\n\t}\n\tif (target instanceof RootDoc) {\n\t  if (methodName.equals(\"classes\")) {\n\t    return filter(((RootDoc) target).classes(), ClassDoc.class);\n\t  } else if (methodName.equals(\"specifiedClasses\")) {\n\t    return filter(((RootDoc) target).specifiedClasses(), ClassDoc.class);\n\t  } else if (methodName.equals(\"specifiedPackages\")) {\n\t    return filter(((RootDoc) target).specifiedPackages(), PackageDoc.class);\n\t  }\n\t} else if (target instanceof ClassDoc) {\n\t  if (isFiltered(args)) {\n\t    if (methodName.equals(\"methods\")) {\n\t      return filter(((ClassDoc) target).methods(true), MethodDoc.class);\n\t    } else if (methodName.equals(\"fields\")) {\n\t      return filter(((ClassDoc) target).fields(true), FieldDoc.class);\n\t    } else if (methodName.equals(\"innerClasses\")) {\n\t      return filter(((ClassDoc) target).innerClasses(true),\n\t\t  ClassDoc.class);\n\t    } else if (methodName.equals(\"constructors\")) {\n\t      return filter(((ClassDoc) target).constructors(true),\n\t\t  ConstructorDoc.class);\n\t    }\n\t  }\n\t} else if (target instanceof PackageDoc) {\n\t  if (methodName.equals(\"allClasses\")) {\n\t    if (isFiltered(args)) {\n\t      return filter(((PackageDoc) target).allClasses(true),\n\t\tClassDoc.class);\n\t    } else {\n\t      return filter(((PackageDoc) target).allClasses(), ClassDoc.class);  \n\t    }\n\t  } else if (methodName.equals(\"annotationTypes\")) {\n\t    return filter(((PackageDoc) target).annotationTypes(),\n\t\tAnnotationTypeDoc.class);\n\t  } else if (methodName.equals(\"enums\")) {\n\t    return filter(((PackageDoc) target).enums(),\n\t\tClassDoc.class);\n\t  } else if (methodName.equals(\"errors\")) {\n\t    return filter(((PackageDoc) target).errors(),\n\t\tClassDoc.class);\n\t  } else if (methodName.equals(\"exceptions\")) {\n\t    return filter(((PackageDoc) target).exceptions(),\n\t\tClassDoc.class);\n\t  } else if (methodName.equals(\"interfaces\")) {\n\t    return filter(((PackageDoc) target).interfaces(),\n\t\tClassDoc.class);\n\t  } else if (methodName.equals(\"ordinaryClasses\")) {\n\t    return filter(((PackageDoc) target).ordinaryClasses(),\n\t\tClassDoc.class);\n\t  }\n\t}\n      }\n\n      if (args !\u003d null) {\n\tif (methodName.equals(\"compareTo\") || methodName.equals(\"equals\")\n\t    || methodName.equals(\"overrides\")\n\t    || methodName.equals(\"subclassOf\")) {\n\t  args[0] \u003d unwrap(args[0]);\n\t}\n      }\n      try {\n\treturn process(method.invoke(target, args), method.getReturnType());\n      } catch (InvocationTargetException e) {\n\tthrow e.getTargetException();\n      }\n    }",
      "path": "common/src/java/org/apache/hadoop/classification/tools/RootDocProcessor.java",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/hadoop/classification/tools/RootDocProcessor.java",
        "newPath": "common/src/java/org/apache/hadoop/classification/tools/RootDocProcessor.java"
      }
    },
    "980f99bfb7b1c404b6e8346771803e113d16f71d": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-6658. Exclude Private elements from generated Javadoc.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@937052 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "22/04/10 1:48 PM",
      "commitName": "980f99bfb7b1c404b6e8346771803e113d16f71d",
      "commitAuthor": "Thomas White",
      "diff": "@@ -0,0 +1,73 @@\n+    public Object invoke(Object proxy, Method method, Object[] args)\n+\tthrows Throwable {\n+      String methodName \u003d method.getName();\n+      if (target instanceof Doc) {\n+\tif (methodName.equals(\"isIncluded\")) {\n+\t  Doc doc \u003d (Doc) target;\n+\t  return !exclude(doc) \u0026\u0026 doc.isIncluded();\n+\t}\n+\tif (target instanceof RootDoc) {\n+\t  if (methodName.equals(\"classes\")) {\n+\t    return filter(((RootDoc) target).classes(), ClassDoc.class);\n+\t  } else if (methodName.equals(\"specifiedClasses\")) {\n+\t    return filter(((RootDoc) target).specifiedClasses(), ClassDoc.class);\n+\t  } else if (methodName.equals(\"specifiedPackages\")) {\n+\t    return filter(((RootDoc) target).specifiedPackages(), PackageDoc.class);\n+\t  }\n+\t} else if (target instanceof ClassDoc) {\n+\t  if (isFiltered(args)) {\n+\t    if (methodName.equals(\"methods\")) {\n+\t      return filter(((ClassDoc) target).methods(true), MethodDoc.class);\n+\t    } else if (methodName.equals(\"fields\")) {\n+\t      return filter(((ClassDoc) target).fields(true), FieldDoc.class);\n+\t    } else if (methodName.equals(\"innerClasses\")) {\n+\t      return filter(((ClassDoc) target).innerClasses(true),\n+\t\t  ClassDoc.class);\n+\t    } else if (methodName.equals(\"constructors\")) {\n+\t      return filter(((ClassDoc) target).constructors(true),\n+\t\t  ConstructorDoc.class);\n+\t    }\n+\t  }\n+\t} else if (target instanceof PackageDoc) {\n+\t  if (methodName.equals(\"allClasses\")) {\n+\t    if (isFiltered(args)) {\n+\t      return filter(((PackageDoc) target).allClasses(true),\n+\t\tClassDoc.class);\n+\t    } else {\n+\t      return filter(((PackageDoc) target).allClasses(), ClassDoc.class);  \n+\t    }\n+\t  } else if (methodName.equals(\"annotationTypes\")) {\n+\t    return filter(((PackageDoc) target).annotationTypes(),\n+\t\tAnnotationTypeDoc.class);\n+\t  } else if (methodName.equals(\"enums\")) {\n+\t    return filter(((PackageDoc) target).enums(),\n+\t\tClassDoc.class);\n+\t  } else if (methodName.equals(\"errors\")) {\n+\t    return filter(((PackageDoc) target).errors(),\n+\t\tClassDoc.class);\n+\t  } else if (methodName.equals(\"exceptions\")) {\n+\t    return filter(((PackageDoc) target).exceptions(),\n+\t\tClassDoc.class);\n+\t  } else if (methodName.equals(\"interfaces\")) {\n+\t    return filter(((PackageDoc) target).interfaces(),\n+\t\tClassDoc.class);\n+\t  } else if (methodName.equals(\"ordinaryClasses\")) {\n+\t    return filter(((PackageDoc) target).ordinaryClasses(),\n+\t\tClassDoc.class);\n+\t  }\n+\t}\n+      }\n+\n+      if (args !\u003d null) {\n+\tif (methodName.equals(\"compareTo\") || methodName.equals(\"equals\")\n+\t    || methodName.equals(\"overrides\")\n+\t    || methodName.equals(\"subclassOf\")) {\n+\t  args[0] \u003d unwrap(args[0]);\n+\t}\n+      }\n+      try {\n+\treturn process(method.invoke(target, args), method.getReturnType());\n+      } catch (InvocationTargetException e) {\n+\tthrow e.getTargetException();\n+      }\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    public Object invoke(Object proxy, Method method, Object[] args)\n\tthrows Throwable {\n      String methodName \u003d method.getName();\n      if (target instanceof Doc) {\n\tif (methodName.equals(\"isIncluded\")) {\n\t  Doc doc \u003d (Doc) target;\n\t  return !exclude(doc) \u0026\u0026 doc.isIncluded();\n\t}\n\tif (target instanceof RootDoc) {\n\t  if (methodName.equals(\"classes\")) {\n\t    return filter(((RootDoc) target).classes(), ClassDoc.class);\n\t  } else if (methodName.equals(\"specifiedClasses\")) {\n\t    return filter(((RootDoc) target).specifiedClasses(), ClassDoc.class);\n\t  } else if (methodName.equals(\"specifiedPackages\")) {\n\t    return filter(((RootDoc) target).specifiedPackages(), PackageDoc.class);\n\t  }\n\t} else if (target instanceof ClassDoc) {\n\t  if (isFiltered(args)) {\n\t    if (methodName.equals(\"methods\")) {\n\t      return filter(((ClassDoc) target).methods(true), MethodDoc.class);\n\t    } else if (methodName.equals(\"fields\")) {\n\t      return filter(((ClassDoc) target).fields(true), FieldDoc.class);\n\t    } else if (methodName.equals(\"innerClasses\")) {\n\t      return filter(((ClassDoc) target).innerClasses(true),\n\t\t  ClassDoc.class);\n\t    } else if (methodName.equals(\"constructors\")) {\n\t      return filter(((ClassDoc) target).constructors(true),\n\t\t  ConstructorDoc.class);\n\t    }\n\t  }\n\t} else if (target instanceof PackageDoc) {\n\t  if (methodName.equals(\"allClasses\")) {\n\t    if (isFiltered(args)) {\n\t      return filter(((PackageDoc) target).allClasses(true),\n\t\tClassDoc.class);\n\t    } else {\n\t      return filter(((PackageDoc) target).allClasses(), ClassDoc.class);  \n\t    }\n\t  } else if (methodName.equals(\"annotationTypes\")) {\n\t    return filter(((PackageDoc) target).annotationTypes(),\n\t\tAnnotationTypeDoc.class);\n\t  } else if (methodName.equals(\"enums\")) {\n\t    return filter(((PackageDoc) target).enums(),\n\t\tClassDoc.class);\n\t  } else if (methodName.equals(\"errors\")) {\n\t    return filter(((PackageDoc) target).errors(),\n\t\tClassDoc.class);\n\t  } else if (methodName.equals(\"exceptions\")) {\n\t    return filter(((PackageDoc) target).exceptions(),\n\t\tClassDoc.class);\n\t  } else if (methodName.equals(\"interfaces\")) {\n\t    return filter(((PackageDoc) target).interfaces(),\n\t\tClassDoc.class);\n\t  } else if (methodName.equals(\"ordinaryClasses\")) {\n\t    return filter(((PackageDoc) target).ordinaryClasses(),\n\t\tClassDoc.class);\n\t  }\n\t}\n      }\n\n      if (args !\u003d null) {\n\tif (methodName.equals(\"compareTo\") || methodName.equals(\"equals\")\n\t    || methodName.equals(\"overrides\")\n\t    || methodName.equals(\"subclassOf\")) {\n\t  args[0] \u003d unwrap(args[0]);\n\t}\n      }\n      try {\n\treturn process(method.invoke(target, args), method.getReturnType());\n      } catch (InvocationTargetException e) {\n\tthrow e.getTargetException();\n      }\n    }",
      "path": "src/java/org/apache/hadoop/classification/tools/RootDocProcessor.java"
    }
  }
}