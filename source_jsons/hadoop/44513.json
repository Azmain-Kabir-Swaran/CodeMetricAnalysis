{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "UnmanagedAMLauncher.java",
  "functionName": "monitorApplication",
  "functionId": "monitorApplication___appId-ApplicationId__finalState-Set__YarnApplicationState__",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-unmanaged-am-launcher/src/main/java/org/apache/hadoop/yarn/applications/unmanagedamlauncher/UnmanagedAMLauncher.java",
  "functionStartLine": 432,
  "functionEndLine": 496,
  "numCommitsSeen": 24,
  "timeTaken": 1416,
  "changeHistory": [
    "ef9634bf796807501e3c1937a8ea8a70205cb990",
    "5d1b453b8591d87ffb564857015c26c99fb7437c",
    "a83fb61ac07c0468cbc7a38526e92683883dd932",
    "0727ecaf50481fa7a529398bc2a12ce18c9a6b43",
    "2aed48a67f408c290e90c83af9f76165d695f91a",
    "11cf00b08ab7172ff92c35605cdb33664ae621eb",
    "e1fdf62123625e4ba399af02f8aad500637d29d1",
    "3ef19e9dbd5995634aac9b4011765e1d889ea6f5"
  ],
  "changeHistoryShort": {
    "ef9634bf796807501e3c1937a8ea8a70205cb990": "Ybodychange",
    "5d1b453b8591d87ffb564857015c26c99fb7437c": "Ybodychange",
    "a83fb61ac07c0468cbc7a38526e92683883dd932": "Yexceptionschange",
    "0727ecaf50481fa7a529398bc2a12ce18c9a6b43": "Yexceptionschange",
    "2aed48a67f408c290e90c83af9f76165d695f91a": "Ybodychange",
    "11cf00b08ab7172ff92c35605cdb33664ae621eb": "Ybodychange",
    "e1fdf62123625e4ba399af02f8aad500637d29d1": "Yfilerename",
    "3ef19e9dbd5995634aac9b4011765e1d889ea6f5": "Yintroduced"
  },
  "changeHistoryDetails": {
    "ef9634bf796807501e3c1937a8ea8a70205cb990": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1577. Made UnmanagedAMLauncher do launchAM after the attempt reaches the LAUNCHED state. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1580164 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/03/14 9:35 PM",
      "commitName": "ef9634bf796807501e3c1937a8ea8a70205cb990",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "29/07/13 4:17 PM",
      "commitNameOld": "817a6543465a3228cdb28a2eeb8e4f96a2d0f9e6",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 235.22,
      "commitsBetweenForRepo": 1630,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,66 +1,65 @@\n   private ApplicationReport monitorApplication(ApplicationId appId,\n       Set\u003cYarnApplicationState\u003e finalState) throws YarnException,\n       IOException {\n \n     long foundAMCompletedTime \u003d 0;\n-    final int timeToWaitMS \u003d 10000;\n     StringBuilder expectedFinalState \u003d new StringBuilder();\n     boolean first \u003d true;\n     for (YarnApplicationState state : finalState) {\n       if (first) {\n         first \u003d false;\n         expectedFinalState.append(state.name());\n       } else {\n         expectedFinalState.append(\",\" + state.name());\n       }\n     }\n \n     while (true) {\n \n       // Check app status every 1 second.\n       try {\n         Thread.sleep(1000);\n       } catch (InterruptedException e) {\n         LOG.debug(\"Thread sleep in monitoring loop interrupted\");\n       }\n \n       // Get application report for the appId we are interested in\n       ApplicationReport report \u003d rmClient.getApplicationReport(appId);\n \n       LOG.info(\"Got application report from ASM for\" + \", appId\u003d\"\n           + appId.getId() + \", appAttemptId\u003d\"\n           + report.getCurrentApplicationAttemptId() + \", clientToAMToken\u003d\"\n           + report.getClientToAMToken() + \", appDiagnostics\u003d\"\n           + report.getDiagnostics() + \", appMasterHost\u003d\" + report.getHost()\n           + \", appQueue\u003d\" + report.getQueue() + \", appMasterRpcPort\u003d\"\n           + report.getRpcPort() + \", appStartTime\u003d\" + report.getStartTime()\n           + \", yarnAppState\u003d\" + report.getYarnApplicationState().toString()\n           + \", distributedFinalState\u003d\"\n           + report.getFinalApplicationStatus().toString() + \", appTrackingUrl\u003d\"\n           + report.getTrackingUrl() + \", appUser\u003d\" + report.getUser());\n \n       YarnApplicationState state \u003d report.getYarnApplicationState();\n       if (finalState.contains(state)) {\n         return report;\n       }\n \n       // wait for 10 seconds after process has completed for app report to\n       // come back\n       if (amCompleted) {\n         if (foundAMCompletedTime \u003d\u003d 0) {\n           foundAMCompletedTime \u003d System.currentTimeMillis();\n         } else if ((System.currentTimeMillis() - foundAMCompletedTime)\n-            \u003e timeToWaitMS) {\n-          LOG.warn(\"Waited \" + timeToWaitMS/1000\n+            \u003e AM_STATE_WAIT_TIMEOUT_MS) {\n+          LOG.warn(\"Waited \" + AM_STATE_WAIT_TIMEOUT_MS/1000\n               + \" seconds after process completed for AppReport\"\n               + \" to reach desired final state. Not waiting anymore.\"\n               + \"CurrentState \u003d \" + state\n               + \", ExpectedStates \u003d \" + expectedFinalState.toString());\n           throw new RuntimeException(\"Failed to receive final expected state\"\n               + \" in ApplicationReport\"\n               + \", CurrentState\u003d\" + state\n               + \", ExpectedStates\u003d\" + expectedFinalState.toString());\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private ApplicationReport monitorApplication(ApplicationId appId,\n      Set\u003cYarnApplicationState\u003e finalState) throws YarnException,\n      IOException {\n\n    long foundAMCompletedTime \u003d 0;\n    StringBuilder expectedFinalState \u003d new StringBuilder();\n    boolean first \u003d true;\n    for (YarnApplicationState state : finalState) {\n      if (first) {\n        first \u003d false;\n        expectedFinalState.append(state.name());\n      } else {\n        expectedFinalState.append(\",\" + state.name());\n      }\n    }\n\n    while (true) {\n\n      // Check app status every 1 second.\n      try {\n        Thread.sleep(1000);\n      } catch (InterruptedException e) {\n        LOG.debug(\"Thread sleep in monitoring loop interrupted\");\n      }\n\n      // Get application report for the appId we are interested in\n      ApplicationReport report \u003d rmClient.getApplicationReport(appId);\n\n      LOG.info(\"Got application report from ASM for\" + \", appId\u003d\"\n          + appId.getId() + \", appAttemptId\u003d\"\n          + report.getCurrentApplicationAttemptId() + \", clientToAMToken\u003d\"\n          + report.getClientToAMToken() + \", appDiagnostics\u003d\"\n          + report.getDiagnostics() + \", appMasterHost\u003d\" + report.getHost()\n          + \", appQueue\u003d\" + report.getQueue() + \", appMasterRpcPort\u003d\"\n          + report.getRpcPort() + \", appStartTime\u003d\" + report.getStartTime()\n          + \", yarnAppState\u003d\" + report.getYarnApplicationState().toString()\n          + \", distributedFinalState\u003d\"\n          + report.getFinalApplicationStatus().toString() + \", appTrackingUrl\u003d\"\n          + report.getTrackingUrl() + \", appUser\u003d\" + report.getUser());\n\n      YarnApplicationState state \u003d report.getYarnApplicationState();\n      if (finalState.contains(state)) {\n        return report;\n      }\n\n      // wait for 10 seconds after process has completed for app report to\n      // come back\n      if (amCompleted) {\n        if (foundAMCompletedTime \u003d\u003d 0) {\n          foundAMCompletedTime \u003d System.currentTimeMillis();\n        } else if ((System.currentTimeMillis() - foundAMCompletedTime)\n            \u003e AM_STATE_WAIT_TIMEOUT_MS) {\n          LOG.warn(\"Waited \" + AM_STATE_WAIT_TIMEOUT_MS/1000\n              + \" seconds after process completed for AppReport\"\n              + \" to reach desired final state. Not waiting anymore.\"\n              + \"CurrentState \u003d \" + state\n              + \", ExpectedStates \u003d \" + expectedFinalState.toString());\n          throw new RuntimeException(\"Failed to receive final expected state\"\n              + \" in ApplicationReport\"\n              + \", CurrentState\u003d\" + state\n              + \", ExpectedStates\u003d\" + expectedFinalState.toString());\n        }\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-unmanaged-am-launcher/src/main/java/org/apache/hadoop/yarn/applications/unmanagedamlauncher/UnmanagedAMLauncher.java",
      "extendedDetails": {}
    },
    "5d1b453b8591d87ffb564857015c26c99fb7437c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-610. ClientToken is no longer set in the environment of the Containers. Contributed by Omkar Vinit Joshi.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1493968 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/06/13 4:13 PM",
      "commitName": "5d1b453b8591d87ffb564857015c26c99fb7437c",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "16/06/13 8:19 PM",
      "commitNameOld": "ff70f912f781e35e3538d00c892d18b17aefa105",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.83,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,66 +1,66 @@\n   private ApplicationReport monitorApplication(ApplicationId appId,\n       Set\u003cYarnApplicationState\u003e finalState) throws YarnException,\n       IOException {\n \n     long foundAMCompletedTime \u003d 0;\n     final int timeToWaitMS \u003d 10000;\n     StringBuilder expectedFinalState \u003d new StringBuilder();\n     boolean first \u003d true;\n     for (YarnApplicationState state : finalState) {\n       if (first) {\n         first \u003d false;\n         expectedFinalState.append(state.name());\n       } else {\n         expectedFinalState.append(\",\" + state.name());\n       }\n     }\n \n     while (true) {\n \n       // Check app status every 1 second.\n       try {\n         Thread.sleep(1000);\n       } catch (InterruptedException e) {\n         LOG.debug(\"Thread sleep in monitoring loop interrupted\");\n       }\n \n       // Get application report for the appId we are interested in\n       ApplicationReport report \u003d rmClient.getApplicationReport(appId);\n \n       LOG.info(\"Got application report from ASM for\" + \", appId\u003d\"\n           + appId.getId() + \", appAttemptId\u003d\"\n-          + report.getCurrentApplicationAttemptId() + \", clientToken\u003d\"\n-          + report.getClientToken() + \", appDiagnostics\u003d\"\n+          + report.getCurrentApplicationAttemptId() + \", clientToAMToken\u003d\"\n+          + report.getClientToAMToken() + \", appDiagnostics\u003d\"\n           + report.getDiagnostics() + \", appMasterHost\u003d\" + report.getHost()\n           + \", appQueue\u003d\" + report.getQueue() + \", appMasterRpcPort\u003d\"\n           + report.getRpcPort() + \", appStartTime\u003d\" + report.getStartTime()\n           + \", yarnAppState\u003d\" + report.getYarnApplicationState().toString()\n           + \", distributedFinalState\u003d\"\n           + report.getFinalApplicationStatus().toString() + \", appTrackingUrl\u003d\"\n           + report.getTrackingUrl() + \", appUser\u003d\" + report.getUser());\n \n       YarnApplicationState state \u003d report.getYarnApplicationState();\n       if (finalState.contains(state)) {\n         return report;\n       }\n \n       // wait for 10 seconds after process has completed for app report to\n       // come back\n       if (amCompleted) {\n         if (foundAMCompletedTime \u003d\u003d 0) {\n           foundAMCompletedTime \u003d System.currentTimeMillis();\n         } else if ((System.currentTimeMillis() - foundAMCompletedTime)\n             \u003e timeToWaitMS) {\n           LOG.warn(\"Waited \" + timeToWaitMS/1000\n               + \" seconds after process completed for AppReport\"\n               + \" to reach desired final state. Not waiting anymore.\"\n               + \"CurrentState \u003d \" + state\n               + \", ExpectedStates \u003d \" + expectedFinalState.toString());\n           throw new RuntimeException(\"Failed to receive final expected state\"\n               + \" in ApplicationReport\"\n               + \", CurrentState\u003d\" + state\n               + \", ExpectedStates\u003d\" + expectedFinalState.toString());\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private ApplicationReport monitorApplication(ApplicationId appId,\n      Set\u003cYarnApplicationState\u003e finalState) throws YarnException,\n      IOException {\n\n    long foundAMCompletedTime \u003d 0;\n    final int timeToWaitMS \u003d 10000;\n    StringBuilder expectedFinalState \u003d new StringBuilder();\n    boolean first \u003d true;\n    for (YarnApplicationState state : finalState) {\n      if (first) {\n        first \u003d false;\n        expectedFinalState.append(state.name());\n      } else {\n        expectedFinalState.append(\",\" + state.name());\n      }\n    }\n\n    while (true) {\n\n      // Check app status every 1 second.\n      try {\n        Thread.sleep(1000);\n      } catch (InterruptedException e) {\n        LOG.debug(\"Thread sleep in monitoring loop interrupted\");\n      }\n\n      // Get application report for the appId we are interested in\n      ApplicationReport report \u003d rmClient.getApplicationReport(appId);\n\n      LOG.info(\"Got application report from ASM for\" + \", appId\u003d\"\n          + appId.getId() + \", appAttemptId\u003d\"\n          + report.getCurrentApplicationAttemptId() + \", clientToAMToken\u003d\"\n          + report.getClientToAMToken() + \", appDiagnostics\u003d\"\n          + report.getDiagnostics() + \", appMasterHost\u003d\" + report.getHost()\n          + \", appQueue\u003d\" + report.getQueue() + \", appMasterRpcPort\u003d\"\n          + report.getRpcPort() + \", appStartTime\u003d\" + report.getStartTime()\n          + \", yarnAppState\u003d\" + report.getYarnApplicationState().toString()\n          + \", distributedFinalState\u003d\"\n          + report.getFinalApplicationStatus().toString() + \", appTrackingUrl\u003d\"\n          + report.getTrackingUrl() + \", appUser\u003d\" + report.getUser());\n\n      YarnApplicationState state \u003d report.getYarnApplicationState();\n      if (finalState.contains(state)) {\n        return report;\n      }\n\n      // wait for 10 seconds after process has completed for app report to\n      // come back\n      if (amCompleted) {\n        if (foundAMCompletedTime \u003d\u003d 0) {\n          foundAMCompletedTime \u003d System.currentTimeMillis();\n        } else if ((System.currentTimeMillis() - foundAMCompletedTime)\n            \u003e timeToWaitMS) {\n          LOG.warn(\"Waited \" + timeToWaitMS/1000\n              + \" seconds after process completed for AppReport\"\n              + \" to reach desired final state. Not waiting anymore.\"\n              + \"CurrentState \u003d \" + state\n              + \", ExpectedStates \u003d \" + expectedFinalState.toString());\n          throw new RuntimeException(\"Failed to receive final expected state\"\n              + \" in ApplicationReport\"\n              + \", CurrentState\u003d\" + state\n              + \", ExpectedStates\u003d\" + expectedFinalState.toString());\n        }\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-unmanaged-am-launcher/src/main/java/org/apache/hadoop/yarn/applications/unmanagedamlauncher/UnmanagedAMLauncher.java",
      "extendedDetails": {}
    },
    "a83fb61ac07c0468cbc7a38526e92683883dd932": {
      "type": "Yexceptionschange",
      "commitMessage": "YARN-635. Renamed YarnRemoteException to YarnException. Contributed by Siddharth Seth.\nMAPREDUCE-5301. Updated MR code to work with YARN-635 changes of renaming YarnRemoteException to YarnException. Contributed by Siddharth Seth\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1489283 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/06/13 9:05 PM",
      "commitName": "a83fb61ac07c0468cbc7a38526e92683883dd932",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "31/05/13 5:14 PM",
      "commitNameOld": "39f019f41392d9e46ea1dc86ddd5563aabbeda1e",
      "commitAuthorOld": "Siddharth Seth",
      "daysBetweenCommits": 3.16,
      "commitsBetweenForRepo": 36,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,66 +1,66 @@\n   private ApplicationReport monitorApplication(ApplicationId appId,\n-      Set\u003cYarnApplicationState\u003e finalState) throws YarnRemoteException,\n+      Set\u003cYarnApplicationState\u003e finalState) throws YarnException,\n       IOException {\n \n     long foundAMCompletedTime \u003d 0;\n     final int timeToWaitMS \u003d 10000;\n     StringBuilder expectedFinalState \u003d new StringBuilder();\n     boolean first \u003d true;\n     for (YarnApplicationState state : finalState) {\n       if (first) {\n         first \u003d false;\n         expectedFinalState.append(state.name());\n       } else {\n         expectedFinalState.append(\",\" + state.name());\n       }\n     }\n \n     while (true) {\n \n       // Check app status every 1 second.\n       try {\n         Thread.sleep(1000);\n       } catch (InterruptedException e) {\n         LOG.debug(\"Thread sleep in monitoring loop interrupted\");\n       }\n \n       // Get application report for the appId we are interested in\n       ApplicationReport report \u003d rmClient.getApplicationReport(appId);\n \n       LOG.info(\"Got application report from ASM for\" + \", appId\u003d\"\n           + appId.getId() + \", appAttemptId\u003d\"\n           + report.getCurrentApplicationAttemptId() + \", clientToken\u003d\"\n           + report.getClientToken() + \", appDiagnostics\u003d\"\n           + report.getDiagnostics() + \", appMasterHost\u003d\" + report.getHost()\n           + \", appQueue\u003d\" + report.getQueue() + \", appMasterRpcPort\u003d\"\n           + report.getRpcPort() + \", appStartTime\u003d\" + report.getStartTime()\n           + \", yarnAppState\u003d\" + report.getYarnApplicationState().toString()\n           + \", distributedFinalState\u003d\"\n           + report.getFinalApplicationStatus().toString() + \", appTrackingUrl\u003d\"\n           + report.getTrackingUrl() + \", appUser\u003d\" + report.getUser());\n \n       YarnApplicationState state \u003d report.getYarnApplicationState();\n       if (finalState.contains(state)) {\n         return report;\n       }\n \n       // wait for 10 seconds after process has completed for app report to\n       // come back\n       if (amCompleted) {\n         if (foundAMCompletedTime \u003d\u003d 0) {\n           foundAMCompletedTime \u003d System.currentTimeMillis();\n         } else if ((System.currentTimeMillis() - foundAMCompletedTime)\n             \u003e timeToWaitMS) {\n           LOG.warn(\"Waited \" + timeToWaitMS/1000\n               + \" seconds after process completed for AppReport\"\n               + \" to reach desired final state. Not waiting anymore.\"\n               + \"CurrentState \u003d \" + state\n               + \", ExpectedStates \u003d \" + expectedFinalState.toString());\n           throw new RuntimeException(\"Failed to receive final expected state\"\n               + \" in ApplicationReport\"\n               + \", CurrentState\u003d\" + state\n               + \", ExpectedStates\u003d\" + expectedFinalState.toString());\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private ApplicationReport monitorApplication(ApplicationId appId,\n      Set\u003cYarnApplicationState\u003e finalState) throws YarnException,\n      IOException {\n\n    long foundAMCompletedTime \u003d 0;\n    final int timeToWaitMS \u003d 10000;\n    StringBuilder expectedFinalState \u003d new StringBuilder();\n    boolean first \u003d true;\n    for (YarnApplicationState state : finalState) {\n      if (first) {\n        first \u003d false;\n        expectedFinalState.append(state.name());\n      } else {\n        expectedFinalState.append(\",\" + state.name());\n      }\n    }\n\n    while (true) {\n\n      // Check app status every 1 second.\n      try {\n        Thread.sleep(1000);\n      } catch (InterruptedException e) {\n        LOG.debug(\"Thread sleep in monitoring loop interrupted\");\n      }\n\n      // Get application report for the appId we are interested in\n      ApplicationReport report \u003d rmClient.getApplicationReport(appId);\n\n      LOG.info(\"Got application report from ASM for\" + \", appId\u003d\"\n          + appId.getId() + \", appAttemptId\u003d\"\n          + report.getCurrentApplicationAttemptId() + \", clientToken\u003d\"\n          + report.getClientToken() + \", appDiagnostics\u003d\"\n          + report.getDiagnostics() + \", appMasterHost\u003d\" + report.getHost()\n          + \", appQueue\u003d\" + report.getQueue() + \", appMasterRpcPort\u003d\"\n          + report.getRpcPort() + \", appStartTime\u003d\" + report.getStartTime()\n          + \", yarnAppState\u003d\" + report.getYarnApplicationState().toString()\n          + \", distributedFinalState\u003d\"\n          + report.getFinalApplicationStatus().toString() + \", appTrackingUrl\u003d\"\n          + report.getTrackingUrl() + \", appUser\u003d\" + report.getUser());\n\n      YarnApplicationState state \u003d report.getYarnApplicationState();\n      if (finalState.contains(state)) {\n        return report;\n      }\n\n      // wait for 10 seconds after process has completed for app report to\n      // come back\n      if (amCompleted) {\n        if (foundAMCompletedTime \u003d\u003d 0) {\n          foundAMCompletedTime \u003d System.currentTimeMillis();\n        } else if ((System.currentTimeMillis() - foundAMCompletedTime)\n            \u003e timeToWaitMS) {\n          LOG.warn(\"Waited \" + timeToWaitMS/1000\n              + \" seconds after process completed for AppReport\"\n              + \" to reach desired final state. Not waiting anymore.\"\n              + \"CurrentState \u003d \" + state\n              + \", ExpectedStates \u003d \" + expectedFinalState.toString());\n          throw new RuntimeException(\"Failed to receive final expected state\"\n              + \" in ApplicationReport\"\n              + \", CurrentState\u003d\" + state\n              + \", ExpectedStates\u003d\" + expectedFinalState.toString());\n        }\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-unmanaged-am-launcher/src/main/java/org/apache/hadoop/yarn/applications/unmanagedamlauncher/UnmanagedAMLauncher.java",
      "extendedDetails": {
        "oldValue": "[YarnRemoteException, IOException]",
        "newValue": "[YarnException, IOException]"
      }
    },
    "0727ecaf50481fa7a529398bc2a12ce18c9a6b43": {
      "type": "Yexceptionschange",
      "commitMessage": "YARN-631. Changed ClientRMProtocol api to throw IOException and YarnRemoteException. Contributed by Xuan Gong.\nMAPREDUCE-5212. Handling YarnRemoteException separately from IOException in MR App after YARN-631. Contributed by Xuan Gong.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1480494 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/05/13 3:53 PM",
      "commitName": "0727ecaf50481fa7a529398bc2a12ce18c9a6b43",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "06/05/13 12:04 PM",
      "commitNameOld": "92b7165a71656468f17ce8b760ce11e648932f0e",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 2.16,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,65 +1,66 @@\n   private ApplicationReport monitorApplication(ApplicationId appId,\n-      Set\u003cYarnApplicationState\u003e finalState) throws YarnRemoteException {\n+      Set\u003cYarnApplicationState\u003e finalState) throws YarnRemoteException,\n+      IOException {\n \n     long foundAMCompletedTime \u003d 0;\n     final int timeToWaitMS \u003d 10000;\n     StringBuilder expectedFinalState \u003d new StringBuilder();\n     boolean first \u003d true;\n     for (YarnApplicationState state : finalState) {\n       if (first) {\n         first \u003d false;\n         expectedFinalState.append(state.name());\n       } else {\n         expectedFinalState.append(\",\" + state.name());\n       }\n     }\n \n     while (true) {\n \n       // Check app status every 1 second.\n       try {\n         Thread.sleep(1000);\n       } catch (InterruptedException e) {\n         LOG.debug(\"Thread sleep in monitoring loop interrupted\");\n       }\n \n       // Get application report for the appId we are interested in\n       ApplicationReport report \u003d rmClient.getApplicationReport(appId);\n \n       LOG.info(\"Got application report from ASM for\" + \", appId\u003d\"\n           + appId.getId() + \", appAttemptId\u003d\"\n           + report.getCurrentApplicationAttemptId() + \", clientToken\u003d\"\n           + report.getClientToken() + \", appDiagnostics\u003d\"\n           + report.getDiagnostics() + \", appMasterHost\u003d\" + report.getHost()\n           + \", appQueue\u003d\" + report.getQueue() + \", appMasterRpcPort\u003d\"\n           + report.getRpcPort() + \", appStartTime\u003d\" + report.getStartTime()\n           + \", yarnAppState\u003d\" + report.getYarnApplicationState().toString()\n           + \", distributedFinalState\u003d\"\n           + report.getFinalApplicationStatus().toString() + \", appTrackingUrl\u003d\"\n           + report.getTrackingUrl() + \", appUser\u003d\" + report.getUser());\n \n       YarnApplicationState state \u003d report.getYarnApplicationState();\n       if (finalState.contains(state)) {\n         return report;\n       }\n \n       // wait for 10 seconds after process has completed for app report to\n       // come back\n       if (amCompleted) {\n         if (foundAMCompletedTime \u003d\u003d 0) {\n           foundAMCompletedTime \u003d System.currentTimeMillis();\n         } else if ((System.currentTimeMillis() - foundAMCompletedTime)\n             \u003e timeToWaitMS) {\n           LOG.warn(\"Waited \" + timeToWaitMS/1000\n               + \" seconds after process completed for AppReport\"\n               + \" to reach desired final state. Not waiting anymore.\"\n               + \"CurrentState \u003d \" + state\n               + \", ExpectedStates \u003d \" + expectedFinalState.toString());\n           throw new RuntimeException(\"Failed to receive final expected state\"\n               + \" in ApplicationReport\"\n               + \", CurrentState\u003d\" + state\n               + \", ExpectedStates\u003d\" + expectedFinalState.toString());\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private ApplicationReport monitorApplication(ApplicationId appId,\n      Set\u003cYarnApplicationState\u003e finalState) throws YarnRemoteException,\n      IOException {\n\n    long foundAMCompletedTime \u003d 0;\n    final int timeToWaitMS \u003d 10000;\n    StringBuilder expectedFinalState \u003d new StringBuilder();\n    boolean first \u003d true;\n    for (YarnApplicationState state : finalState) {\n      if (first) {\n        first \u003d false;\n        expectedFinalState.append(state.name());\n      } else {\n        expectedFinalState.append(\",\" + state.name());\n      }\n    }\n\n    while (true) {\n\n      // Check app status every 1 second.\n      try {\n        Thread.sleep(1000);\n      } catch (InterruptedException e) {\n        LOG.debug(\"Thread sleep in monitoring loop interrupted\");\n      }\n\n      // Get application report for the appId we are interested in\n      ApplicationReport report \u003d rmClient.getApplicationReport(appId);\n\n      LOG.info(\"Got application report from ASM for\" + \", appId\u003d\"\n          + appId.getId() + \", appAttemptId\u003d\"\n          + report.getCurrentApplicationAttemptId() + \", clientToken\u003d\"\n          + report.getClientToken() + \", appDiagnostics\u003d\"\n          + report.getDiagnostics() + \", appMasterHost\u003d\" + report.getHost()\n          + \", appQueue\u003d\" + report.getQueue() + \", appMasterRpcPort\u003d\"\n          + report.getRpcPort() + \", appStartTime\u003d\" + report.getStartTime()\n          + \", yarnAppState\u003d\" + report.getYarnApplicationState().toString()\n          + \", distributedFinalState\u003d\"\n          + report.getFinalApplicationStatus().toString() + \", appTrackingUrl\u003d\"\n          + report.getTrackingUrl() + \", appUser\u003d\" + report.getUser());\n\n      YarnApplicationState state \u003d report.getYarnApplicationState();\n      if (finalState.contains(state)) {\n        return report;\n      }\n\n      // wait for 10 seconds after process has completed for app report to\n      // come back\n      if (amCompleted) {\n        if (foundAMCompletedTime \u003d\u003d 0) {\n          foundAMCompletedTime \u003d System.currentTimeMillis();\n        } else if ((System.currentTimeMillis() - foundAMCompletedTime)\n            \u003e timeToWaitMS) {\n          LOG.warn(\"Waited \" + timeToWaitMS/1000\n              + \" seconds after process completed for AppReport\"\n              + \" to reach desired final state. Not waiting anymore.\"\n              + \"CurrentState \u003d \" + state\n              + \", ExpectedStates \u003d \" + expectedFinalState.toString());\n          throw new RuntimeException(\"Failed to receive final expected state\"\n              + \" in ApplicationReport\"\n              + \", CurrentState\u003d\" + state\n              + \", ExpectedStates\u003d\" + expectedFinalState.toString());\n        }\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-unmanaged-am-launcher/src/main/java/org/apache/hadoop/yarn/applications/unmanagedamlauncher/UnmanagedAMLauncher.java",
      "extendedDetails": {
        "oldValue": "[YarnRemoteException]",
        "newValue": "[YarnRemoteException, IOException]"
      }
    },
    "2aed48a67f408c290e90c83af9f76165d695f91a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-498. Unmanaged AM launcher does not set various constants in env for an AM, also does not handle failed AMs properly (Hitesh Shah via bikas)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1460954 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/03/13 7:34 PM",
      "commitName": "2aed48a67f408c290e90c83af9f76165d695f91a",
      "commitAuthor": "Bikas Saha",
      "commitDateOld": "23/10/12 2:06 PM",
      "commitNameOld": "88d326f0a411442b75d1a95425f150621b51da59",
      "commitAuthorOld": "Siddharth Seth",
      "daysBetweenCommits": 153.23,
      "commitsBetweenForRepo": 693,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,65 @@\n   private ApplicationReport monitorApplication(ApplicationId appId,\n       Set\u003cYarnApplicationState\u003e finalState) throws YarnRemoteException {\n \n+    long foundAMCompletedTime \u003d 0;\n+    final int timeToWaitMS \u003d 10000;\n+    StringBuilder expectedFinalState \u003d new StringBuilder();\n+    boolean first \u003d true;\n+    for (YarnApplicationState state : finalState) {\n+      if (first) {\n+        first \u003d false;\n+        expectedFinalState.append(state.name());\n+      } else {\n+        expectedFinalState.append(\",\" + state.name());\n+      }\n+    }\n+\n     while (true) {\n \n       // Check app status every 1 second.\n       try {\n         Thread.sleep(1000);\n       } catch (InterruptedException e) {\n         LOG.debug(\"Thread sleep in monitoring loop interrupted\");\n       }\n \n       // Get application report for the appId we are interested in\n       ApplicationReport report \u003d rmClient.getApplicationReport(appId);\n \n       LOG.info(\"Got application report from ASM for\" + \", appId\u003d\"\n           + appId.getId() + \", appAttemptId\u003d\"\n           + report.getCurrentApplicationAttemptId() + \", clientToken\u003d\"\n           + report.getClientToken() + \", appDiagnostics\u003d\"\n           + report.getDiagnostics() + \", appMasterHost\u003d\" + report.getHost()\n           + \", appQueue\u003d\" + report.getQueue() + \", appMasterRpcPort\u003d\"\n           + report.getRpcPort() + \", appStartTime\u003d\" + report.getStartTime()\n           + \", yarnAppState\u003d\" + report.getYarnApplicationState().toString()\n           + \", distributedFinalState\u003d\"\n           + report.getFinalApplicationStatus().toString() + \", appTrackingUrl\u003d\"\n           + report.getTrackingUrl() + \", appUser\u003d\" + report.getUser());\n \n       YarnApplicationState state \u003d report.getYarnApplicationState();\n       if (finalState.contains(state)) {\n         return report;\n       }\n \n+      // wait for 10 seconds after process has completed for app report to\n+      // come back\n+      if (amCompleted) {\n+        if (foundAMCompletedTime \u003d\u003d 0) {\n+          foundAMCompletedTime \u003d System.currentTimeMillis();\n+        } else if ((System.currentTimeMillis() - foundAMCompletedTime)\n+            \u003e timeToWaitMS) {\n+          LOG.warn(\"Waited \" + timeToWaitMS/1000\n+              + \" seconds after process completed for AppReport\"\n+              + \" to reach desired final state. Not waiting anymore.\"\n+              + \"CurrentState \u003d \" + state\n+              + \", ExpectedStates \u003d \" + expectedFinalState.toString());\n+          throw new RuntimeException(\"Failed to receive final expected state\"\n+              + \" in ApplicationReport\"\n+              + \", CurrentState\u003d\" + state\n+              + \", ExpectedStates\u003d\" + expectedFinalState.toString());\n+        }\n+      }\n     }\n-\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private ApplicationReport monitorApplication(ApplicationId appId,\n      Set\u003cYarnApplicationState\u003e finalState) throws YarnRemoteException {\n\n    long foundAMCompletedTime \u003d 0;\n    final int timeToWaitMS \u003d 10000;\n    StringBuilder expectedFinalState \u003d new StringBuilder();\n    boolean first \u003d true;\n    for (YarnApplicationState state : finalState) {\n      if (first) {\n        first \u003d false;\n        expectedFinalState.append(state.name());\n      } else {\n        expectedFinalState.append(\",\" + state.name());\n      }\n    }\n\n    while (true) {\n\n      // Check app status every 1 second.\n      try {\n        Thread.sleep(1000);\n      } catch (InterruptedException e) {\n        LOG.debug(\"Thread sleep in monitoring loop interrupted\");\n      }\n\n      // Get application report for the appId we are interested in\n      ApplicationReport report \u003d rmClient.getApplicationReport(appId);\n\n      LOG.info(\"Got application report from ASM for\" + \", appId\u003d\"\n          + appId.getId() + \", appAttemptId\u003d\"\n          + report.getCurrentApplicationAttemptId() + \", clientToken\u003d\"\n          + report.getClientToken() + \", appDiagnostics\u003d\"\n          + report.getDiagnostics() + \", appMasterHost\u003d\" + report.getHost()\n          + \", appQueue\u003d\" + report.getQueue() + \", appMasterRpcPort\u003d\"\n          + report.getRpcPort() + \", appStartTime\u003d\" + report.getStartTime()\n          + \", yarnAppState\u003d\" + report.getYarnApplicationState().toString()\n          + \", distributedFinalState\u003d\"\n          + report.getFinalApplicationStatus().toString() + \", appTrackingUrl\u003d\"\n          + report.getTrackingUrl() + \", appUser\u003d\" + report.getUser());\n\n      YarnApplicationState state \u003d report.getYarnApplicationState();\n      if (finalState.contains(state)) {\n        return report;\n      }\n\n      // wait for 10 seconds after process has completed for app report to\n      // come back\n      if (amCompleted) {\n        if (foundAMCompletedTime \u003d\u003d 0) {\n          foundAMCompletedTime \u003d System.currentTimeMillis();\n        } else if ((System.currentTimeMillis() - foundAMCompletedTime)\n            \u003e timeToWaitMS) {\n          LOG.warn(\"Waited \" + timeToWaitMS/1000\n              + \" seconds after process completed for AppReport\"\n              + \" to reach desired final state. Not waiting anymore.\"\n              + \"CurrentState \u003d \" + state\n              + \", ExpectedStates \u003d \" + expectedFinalState.toString());\n          throw new RuntimeException(\"Failed to receive final expected state\"\n              + \" in ApplicationReport\"\n              + \", CurrentState\u003d\" + state\n              + \", ExpectedStates\u003d\" + expectedFinalState.toString());\n        }\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-unmanaged-am-launcher/src/main/java/org/apache/hadoop/yarn/applications/unmanagedamlauncher/UnmanagedAMLauncher.java",
      "extendedDetails": {}
    },
    "11cf00b08ab7172ff92c35605cdb33664ae621eb": {
      "type": "Ybodychange",
      "commitMessage": "YARN-78. Changed UnManagedAM application to use YarnClient. Contributed by Bikas Saha.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1383705 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/09/12 5:49 PM",
      "commitName": "11cf00b08ab7172ff92c35605cdb33664ae621eb",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "07/08/12 10:22 PM",
      "commitNameOld": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 34.81,
      "commitsBetweenForRepo": 217,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,35 @@\n   private ApplicationReport monitorApplication(ApplicationId appId,\n       Set\u003cYarnApplicationState\u003e finalState) throws YarnRemoteException {\n \n     while (true) {\n \n       // Check app status every 1 second.\n       try {\n         Thread.sleep(1000);\n       } catch (InterruptedException e) {\n         LOG.debug(\"Thread sleep in monitoring loop interrupted\");\n       }\n \n       // Get application report for the appId we are interested in\n-      GetApplicationReportRequest reportRequest \u003d Records\n-          .newRecord(GetApplicationReportRequest.class);\n-      reportRequest.setApplicationId(appId);\n-      GetApplicationReportResponse reportResponse \u003d rmClient\n-          .getApplicationReport(reportRequest);\n-      ApplicationReport report \u003d reportResponse.getApplicationReport();\n+      ApplicationReport report \u003d rmClient.getApplicationReport(appId);\n \n       LOG.info(\"Got application report from ASM for\" + \", appId\u003d\"\n           + appId.getId() + \", appAttemptId\u003d\"\n           + report.getCurrentApplicationAttemptId() + \", clientToken\u003d\"\n           + report.getClientToken() + \", appDiagnostics\u003d\"\n           + report.getDiagnostics() + \", appMasterHost\u003d\" + report.getHost()\n           + \", appQueue\u003d\" + report.getQueue() + \", appMasterRpcPort\u003d\"\n           + report.getRpcPort() + \", appStartTime\u003d\" + report.getStartTime()\n           + \", yarnAppState\u003d\" + report.getYarnApplicationState().toString()\n           + \", distributedFinalState\u003d\"\n           + report.getFinalApplicationStatus().toString() + \", appTrackingUrl\u003d\"\n           + report.getTrackingUrl() + \", appUser\u003d\" + report.getUser());\n \n       YarnApplicationState state \u003d report.getYarnApplicationState();\n       if (finalState.contains(state)) {\n         return report;\n       }\n \n     }\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  private ApplicationReport monitorApplication(ApplicationId appId,\n      Set\u003cYarnApplicationState\u003e finalState) throws YarnRemoteException {\n\n    while (true) {\n\n      // Check app status every 1 second.\n      try {\n        Thread.sleep(1000);\n      } catch (InterruptedException e) {\n        LOG.debug(\"Thread sleep in monitoring loop interrupted\");\n      }\n\n      // Get application report for the appId we are interested in\n      ApplicationReport report \u003d rmClient.getApplicationReport(appId);\n\n      LOG.info(\"Got application report from ASM for\" + \", appId\u003d\"\n          + appId.getId() + \", appAttemptId\u003d\"\n          + report.getCurrentApplicationAttemptId() + \", clientToken\u003d\"\n          + report.getClientToken() + \", appDiagnostics\u003d\"\n          + report.getDiagnostics() + \", appMasterHost\u003d\" + report.getHost()\n          + \", appQueue\u003d\" + report.getQueue() + \", appMasterRpcPort\u003d\"\n          + report.getRpcPort() + \", appStartTime\u003d\" + report.getStartTime()\n          + \", yarnAppState\u003d\" + report.getYarnApplicationState().toString()\n          + \", distributedFinalState\u003d\"\n          + report.getFinalApplicationStatus().toString() + \", appTrackingUrl\u003d\"\n          + report.getTrackingUrl() + \", appUser\u003d\" + report.getUser());\n\n      YarnApplicationState state \u003d report.getYarnApplicationState();\n      if (finalState.contains(state)) {\n        return report;\n      }\n\n    }\n\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-unmanaged-am-launcher/src/main/java/org/apache/hadoop/yarn/applications/unmanagedamlauncher/UnmanagedAMLauncher.java",
      "extendedDetails": {}
    },
    "e1fdf62123625e4ba399af02f8aad500637d29d1": {
      "type": "Yfilerename",
      "commitMessage": "YARN-1. Promote YARN to be a sub-project of Apache Hadoop.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1370666 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/08/12 10:22 PM",
      "commitName": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "07/08/12 7:53 PM",
      "commitNameOld": "34554d1e11ee1d5b564d7d9ed3e6d55931d72749",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private ApplicationReport monitorApplication(ApplicationId appId,\n      Set\u003cYarnApplicationState\u003e finalState) throws YarnRemoteException {\n\n    while (true) {\n\n      // Check app status every 1 second.\n      try {\n        Thread.sleep(1000);\n      } catch (InterruptedException e) {\n        LOG.debug(\"Thread sleep in monitoring loop interrupted\");\n      }\n\n      // Get application report for the appId we are interested in\n      GetApplicationReportRequest reportRequest \u003d Records\n          .newRecord(GetApplicationReportRequest.class);\n      reportRequest.setApplicationId(appId);\n      GetApplicationReportResponse reportResponse \u003d rmClient\n          .getApplicationReport(reportRequest);\n      ApplicationReport report \u003d reportResponse.getApplicationReport();\n\n      LOG.info(\"Got application report from ASM for\" + \", appId\u003d\"\n          + appId.getId() + \", appAttemptId\u003d\"\n          + report.getCurrentApplicationAttemptId() + \", clientToken\u003d\"\n          + report.getClientToken() + \", appDiagnostics\u003d\"\n          + report.getDiagnostics() + \", appMasterHost\u003d\" + report.getHost()\n          + \", appQueue\u003d\" + report.getQueue() + \", appMasterRpcPort\u003d\"\n          + report.getRpcPort() + \", appStartTime\u003d\" + report.getStartTime()\n          + \", yarnAppState\u003d\" + report.getYarnApplicationState().toString()\n          + \", distributedFinalState\u003d\"\n          + report.getFinalApplicationStatus().toString() + \", appTrackingUrl\u003d\"\n          + report.getTrackingUrl() + \", appUser\u003d\" + report.getUser());\n\n      YarnApplicationState state \u003d report.getYarnApplicationState();\n      if (finalState.contains(state)) {\n        return report;\n      }\n\n    }\n\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-unmanaged-am-launcher/src/main/java/org/apache/hadoop/yarn/applications/unmanagedamlauncher/UnmanagedAMLauncher.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-unmanaged-am-launcher/src/main/java/org/apache/hadoop/yarn/applications/unmanagedamlauncher/UnmanagedAMLauncher.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-unmanaged-am-launcher/src/main/java/org/apache/hadoop/yarn/applications/unmanagedamlauncher/UnmanagedAMLauncher.java"
      }
    },
    "3ef19e9dbd5995634aac9b4011765e1d889ea6f5": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-4438. Add a simple, generic client to run \u0027easy\u0027 AMs in YARN. Contributed by Bikas Saha.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1365185 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/07/12 10:33 AM",
      "commitName": "3ef19e9dbd5995634aac9b4011765e1d889ea6f5",
      "commitAuthor": "Arun Murthy",
      "diff": "@@ -0,0 +1,40 @@\n+  private ApplicationReport monitorApplication(ApplicationId appId,\n+      Set\u003cYarnApplicationState\u003e finalState) throws YarnRemoteException {\n+\n+    while (true) {\n+\n+      // Check app status every 1 second.\n+      try {\n+        Thread.sleep(1000);\n+      } catch (InterruptedException e) {\n+        LOG.debug(\"Thread sleep in monitoring loop interrupted\");\n+      }\n+\n+      // Get application report for the appId we are interested in\n+      GetApplicationReportRequest reportRequest \u003d Records\n+          .newRecord(GetApplicationReportRequest.class);\n+      reportRequest.setApplicationId(appId);\n+      GetApplicationReportResponse reportResponse \u003d rmClient\n+          .getApplicationReport(reportRequest);\n+      ApplicationReport report \u003d reportResponse.getApplicationReport();\n+\n+      LOG.info(\"Got application report from ASM for\" + \", appId\u003d\"\n+          + appId.getId() + \", appAttemptId\u003d\"\n+          + report.getCurrentApplicationAttemptId() + \", clientToken\u003d\"\n+          + report.getClientToken() + \", appDiagnostics\u003d\"\n+          + report.getDiagnostics() + \", appMasterHost\u003d\" + report.getHost()\n+          + \", appQueue\u003d\" + report.getQueue() + \", appMasterRpcPort\u003d\"\n+          + report.getRpcPort() + \", appStartTime\u003d\" + report.getStartTime()\n+          + \", yarnAppState\u003d\" + report.getYarnApplicationState().toString()\n+          + \", distributedFinalState\u003d\"\n+          + report.getFinalApplicationStatus().toString() + \", appTrackingUrl\u003d\"\n+          + report.getTrackingUrl() + \", appUser\u003d\" + report.getUser());\n+\n+      YarnApplicationState state \u003d report.getYarnApplicationState();\n+      if (finalState.contains(state)) {\n+        return report;\n+      }\n+\n+    }\n+\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private ApplicationReport monitorApplication(ApplicationId appId,\n      Set\u003cYarnApplicationState\u003e finalState) throws YarnRemoteException {\n\n    while (true) {\n\n      // Check app status every 1 second.\n      try {\n        Thread.sleep(1000);\n      } catch (InterruptedException e) {\n        LOG.debug(\"Thread sleep in monitoring loop interrupted\");\n      }\n\n      // Get application report for the appId we are interested in\n      GetApplicationReportRequest reportRequest \u003d Records\n          .newRecord(GetApplicationReportRequest.class);\n      reportRequest.setApplicationId(appId);\n      GetApplicationReportResponse reportResponse \u003d rmClient\n          .getApplicationReport(reportRequest);\n      ApplicationReport report \u003d reportResponse.getApplicationReport();\n\n      LOG.info(\"Got application report from ASM for\" + \", appId\u003d\"\n          + appId.getId() + \", appAttemptId\u003d\"\n          + report.getCurrentApplicationAttemptId() + \", clientToken\u003d\"\n          + report.getClientToken() + \", appDiagnostics\u003d\"\n          + report.getDiagnostics() + \", appMasterHost\u003d\" + report.getHost()\n          + \", appQueue\u003d\" + report.getQueue() + \", appMasterRpcPort\u003d\"\n          + report.getRpcPort() + \", appStartTime\u003d\" + report.getStartTime()\n          + \", yarnAppState\u003d\" + report.getYarnApplicationState().toString()\n          + \", distributedFinalState\u003d\"\n          + report.getFinalApplicationStatus().toString() + \", appTrackingUrl\u003d\"\n          + report.getTrackingUrl() + \", appUser\u003d\" + report.getUser());\n\n      YarnApplicationState state \u003d report.getYarnApplicationState();\n      if (finalState.contains(state)) {\n        return report;\n      }\n\n    }\n\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-unmanaged-am-launcher/src/main/java/org/apache/hadoop/yarn/applications/unmanagedamlauncher/UnmanagedAMLauncher.java"
    }
  }
}