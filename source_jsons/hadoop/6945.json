{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FSDirectory.java",
  "functionName": "resolvePath",
  "functionId": "resolvePath___src-String__fsd-FSDirectory",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
  "functionStartLine": 759,
  "functionEndLine": 764,
  "numCommitsSeen": 600,
  "timeTaken": 8776,
  "changeHistory": [
    "869393643de23dcb010cc33091c8eb398de0fd6c",
    "03dea65e0b17ca2f9460bb6110f6ab3a321b8bf2",
    "3dadf369d550c2ae393b751cb5a184dbfe2814df",
    "407bb3d3e452c8277c498dd14e0cc5b7762a7091",
    "ae9109b911b3d9e2d6ca50b400379fc31deeb0cf",
    "14556cc5d8fee8f8a846e4f65572828553be386c",
    "214d4377fc151297c85b09273dfe8fdddae40d3d",
    "a4bae51b7dac4301942ed28d0128fc9ef6a0d13a"
  ],
  "changeHistoryShort": {
    "869393643de23dcb010cc33091c8eb398de0fd6c": "Ybodychange",
    "03dea65e0b17ca2f9460bb6110f6ab3a321b8bf2": "Ymultichange(Yparameterchange,Ybodychange)",
    "3dadf369d550c2ae393b751cb5a184dbfe2814df": "Ybodychange",
    "407bb3d3e452c8277c498dd14e0cc5b7762a7091": "Ybodychange",
    "ae9109b911b3d9e2d6ca50b400379fc31deeb0cf": "Ybodychange",
    "14556cc5d8fee8f8a846e4f65572828553be386c": "Ybodychange",
    "214d4377fc151297c85b09273dfe8fdddae40d3d": "Ybodychange",
    "a4bae51b7dac4301942ed28d0128fc9ef6a0d13a": "Ybodychange"
  },
  "changeHistoryDetails": {
    "869393643de23dcb010cc33091c8eb398de0fd6c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10745. Directly resolve paths into INodesInPath. Contributed by Daryn Sharp.\n",
      "commitDate": "17/08/16 1:53 PM",
      "commitName": "869393643de23dcb010cc33091c8eb398de0fd6c",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "15/08/16 2:45 PM",
      "commitNameOld": "03dea65e0b17ca2f9460bb6110f6ab3a321b8bf2",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 1.96,
      "commitsBetweenForRepo": 23,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,6 @@\n   static String resolvePath(String src,\n       FSDirectory fsd) throws FileNotFoundException {\n     byte[][] pathComponents \u003d INode.getPathComponents(src);\n-    final int nComponents \u003d pathComponents.length;\n-    if (!isReservedName(pathComponents)) {\n-      /* This is not a /.reserved/ path so do nothing. */\n-    } else if (Arrays.equals(DOT_INODES, pathComponents[2])) {\n-      /* It\u0027s a /.reserved/.inodes path. */\n-      if (nComponents \u003e 3) {\n-        pathComponents \u003d resolveDotInodesPath(pathComponents, fsd);\n-      }\n-    } else if (Arrays.equals(RAW, pathComponents[2])) {\n-      /* It\u0027s /.reserved/raw so strip off the /.reserved/raw prefix. */\n-      if (nComponents \u003d\u003d 3) {\n-        pathComponents \u003d new byte[][]{INodeDirectory.ROOT_NAME};\n-      } else {\n-        if (nComponents \u003d\u003d 4\n-            \u0026\u0026 Arrays.equals(DOT_RESERVED, pathComponents[3])) {\n-          /* It\u0027s /.reserved/raw/.reserved so don\u0027t strip */\n-        } else {\n-          pathComponents \u003d constructRemainingPath(\n-              new byte[][]{INodeDirectory.ROOT_NAME}, pathComponents, 3);\n-        }\n-      }\n-    }\n-    // this double conversion will be unnecessary when resolving returns\n-    // INodesInPath (needs components byte[][])\n+    pathComponents \u003d resolveComponents(pathComponents, fsd);\n     return DFSUtil.byteArray2PathString(pathComponents);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static String resolvePath(String src,\n      FSDirectory fsd) throws FileNotFoundException {\n    byte[][] pathComponents \u003d INode.getPathComponents(src);\n    pathComponents \u003d resolveComponents(pathComponents, fsd);\n    return DFSUtil.byteArray2PathString(pathComponents);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "03dea65e0b17ca2f9460bb6110f6ab3a321b8bf2": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-10744. Internally optimize path component resolution. Contributed by Daryn Sharp.\n",
      "commitDate": "15/08/16 2:45 PM",
      "commitName": "03dea65e0b17ca2f9460bb6110f6ab3a321b8bf2",
      "commitAuthor": "Kihwal Lee",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-10744. Internally optimize path component resolution. Contributed by Daryn Sharp.\n",
          "commitDate": "15/08/16 2:45 PM",
          "commitName": "03dea65e0b17ca2f9460bb6110f6ab3a321b8bf2",
          "commitAuthor": "Kihwal Lee",
          "commitDateOld": "12/08/16 5:58 AM",
          "commitNameOld": "9019606b69bfb7019c8642b6cbcbb93645cc19e3",
          "commitAuthorOld": "Wei-Chiu Chuang",
          "daysBetweenCommits": 3.37,
          "commitsBetweenForRepo": 8,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,37 +1,29 @@\n-  static String resolvePath(String src, byte[][] pathComponents,\n+  static String resolvePath(String src,\n       FSDirectory fsd) throws FileNotFoundException {\n-    final int nComponents \u003d (pathComponents \u003d\u003d null) ?\n-        0 : pathComponents.length;\n-    if (nComponents \u003c\u003d 2) {\n-      return src;\n-    }\n-    if (!Arrays.equals(DOT_RESERVED, pathComponents[1])) {\n+    byte[][] pathComponents \u003d INode.getPathComponents(src);\n+    final int nComponents \u003d pathComponents.length;\n+    if (!isReservedName(pathComponents)) {\n       /* This is not a /.reserved/ path so do nothing. */\n-      return src;\n-    }\n-\n-    if (Arrays.equals(DOT_INODES, pathComponents[2])) {\n+    } else if (Arrays.equals(DOT_INODES, pathComponents[2])) {\n       /* It\u0027s a /.reserved/.inodes path. */\n       if (nComponents \u003e 3) {\n-        return resolveDotInodesPath(src, pathComponents, fsd);\n-      } else {\n-        return src;\n+        pathComponents \u003d resolveDotInodesPath(pathComponents, fsd);\n       }\n     } else if (Arrays.equals(RAW, pathComponents[2])) {\n       /* It\u0027s /.reserved/raw so strip off the /.reserved/raw prefix. */\n       if (nComponents \u003d\u003d 3) {\n-        return Path.SEPARATOR;\n+        pathComponents \u003d new byte[][]{INodeDirectory.ROOT_NAME};\n       } else {\n         if (nComponents \u003d\u003d 4\n             \u0026\u0026 Arrays.equals(DOT_RESERVED, pathComponents[3])) {\n           /* It\u0027s /.reserved/raw/.reserved so don\u0027t strip */\n-          return src;\n         } else {\n-          return constructRemainingPath(\"\", pathComponents, 3);\n+          pathComponents \u003d constructRemainingPath(\n+              new byte[][]{INodeDirectory.ROOT_NAME}, pathComponents, 3);\n         }\n       }\n-    } else {\n-      /* It\u0027s some sort of /.reserved/\u003cunknown\u003e path. Ignore it. */\n-      return src;\n     }\n+    // this double conversion will be unnecessary when resolving returns\n+    // INodesInPath (needs components byte[][])\n+    return DFSUtil.byteArray2PathString(pathComponents);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static String resolvePath(String src,\n      FSDirectory fsd) throws FileNotFoundException {\n    byte[][] pathComponents \u003d INode.getPathComponents(src);\n    final int nComponents \u003d pathComponents.length;\n    if (!isReservedName(pathComponents)) {\n      /* This is not a /.reserved/ path so do nothing. */\n    } else if (Arrays.equals(DOT_INODES, pathComponents[2])) {\n      /* It\u0027s a /.reserved/.inodes path. */\n      if (nComponents \u003e 3) {\n        pathComponents \u003d resolveDotInodesPath(pathComponents, fsd);\n      }\n    } else if (Arrays.equals(RAW, pathComponents[2])) {\n      /* It\u0027s /.reserved/raw so strip off the /.reserved/raw prefix. */\n      if (nComponents \u003d\u003d 3) {\n        pathComponents \u003d new byte[][]{INodeDirectory.ROOT_NAME};\n      } else {\n        if (nComponents \u003d\u003d 4\n            \u0026\u0026 Arrays.equals(DOT_RESERVED, pathComponents[3])) {\n          /* It\u0027s /.reserved/raw/.reserved so don\u0027t strip */\n        } else {\n          pathComponents \u003d constructRemainingPath(\n              new byte[][]{INodeDirectory.ROOT_NAME}, pathComponents, 3);\n        }\n      }\n    }\n    // this double conversion will be unnecessary when resolving returns\n    // INodesInPath (needs components byte[][])\n    return DFSUtil.byteArray2PathString(pathComponents);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
          "extendedDetails": {
            "oldValue": "[src-String, pathComponents-byte[][], fsd-FSDirectory]",
            "newValue": "[src-String, fsd-FSDirectory]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-10744. Internally optimize path component resolution. Contributed by Daryn Sharp.\n",
          "commitDate": "15/08/16 2:45 PM",
          "commitName": "03dea65e0b17ca2f9460bb6110f6ab3a321b8bf2",
          "commitAuthor": "Kihwal Lee",
          "commitDateOld": "12/08/16 5:58 AM",
          "commitNameOld": "9019606b69bfb7019c8642b6cbcbb93645cc19e3",
          "commitAuthorOld": "Wei-Chiu Chuang",
          "daysBetweenCommits": 3.37,
          "commitsBetweenForRepo": 8,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,37 +1,29 @@\n-  static String resolvePath(String src, byte[][] pathComponents,\n+  static String resolvePath(String src,\n       FSDirectory fsd) throws FileNotFoundException {\n-    final int nComponents \u003d (pathComponents \u003d\u003d null) ?\n-        0 : pathComponents.length;\n-    if (nComponents \u003c\u003d 2) {\n-      return src;\n-    }\n-    if (!Arrays.equals(DOT_RESERVED, pathComponents[1])) {\n+    byte[][] pathComponents \u003d INode.getPathComponents(src);\n+    final int nComponents \u003d pathComponents.length;\n+    if (!isReservedName(pathComponents)) {\n       /* This is not a /.reserved/ path so do nothing. */\n-      return src;\n-    }\n-\n-    if (Arrays.equals(DOT_INODES, pathComponents[2])) {\n+    } else if (Arrays.equals(DOT_INODES, pathComponents[2])) {\n       /* It\u0027s a /.reserved/.inodes path. */\n       if (nComponents \u003e 3) {\n-        return resolveDotInodesPath(src, pathComponents, fsd);\n-      } else {\n-        return src;\n+        pathComponents \u003d resolveDotInodesPath(pathComponents, fsd);\n       }\n     } else if (Arrays.equals(RAW, pathComponents[2])) {\n       /* It\u0027s /.reserved/raw so strip off the /.reserved/raw prefix. */\n       if (nComponents \u003d\u003d 3) {\n-        return Path.SEPARATOR;\n+        pathComponents \u003d new byte[][]{INodeDirectory.ROOT_NAME};\n       } else {\n         if (nComponents \u003d\u003d 4\n             \u0026\u0026 Arrays.equals(DOT_RESERVED, pathComponents[3])) {\n           /* It\u0027s /.reserved/raw/.reserved so don\u0027t strip */\n-          return src;\n         } else {\n-          return constructRemainingPath(\"\", pathComponents, 3);\n+          pathComponents \u003d constructRemainingPath(\n+              new byte[][]{INodeDirectory.ROOT_NAME}, pathComponents, 3);\n         }\n       }\n-    } else {\n-      /* It\u0027s some sort of /.reserved/\u003cunknown\u003e path. Ignore it. */\n-      return src;\n     }\n+    // this double conversion will be unnecessary when resolving returns\n+    // INodesInPath (needs components byte[][])\n+    return DFSUtil.byteArray2PathString(pathComponents);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static String resolvePath(String src,\n      FSDirectory fsd) throws FileNotFoundException {\n    byte[][] pathComponents \u003d INode.getPathComponents(src);\n    final int nComponents \u003d pathComponents.length;\n    if (!isReservedName(pathComponents)) {\n      /* This is not a /.reserved/ path so do nothing. */\n    } else if (Arrays.equals(DOT_INODES, pathComponents[2])) {\n      /* It\u0027s a /.reserved/.inodes path. */\n      if (nComponents \u003e 3) {\n        pathComponents \u003d resolveDotInodesPath(pathComponents, fsd);\n      }\n    } else if (Arrays.equals(RAW, pathComponents[2])) {\n      /* It\u0027s /.reserved/raw so strip off the /.reserved/raw prefix. */\n      if (nComponents \u003d\u003d 3) {\n        pathComponents \u003d new byte[][]{INodeDirectory.ROOT_NAME};\n      } else {\n        if (nComponents \u003d\u003d 4\n            \u0026\u0026 Arrays.equals(DOT_RESERVED, pathComponents[3])) {\n          /* It\u0027s /.reserved/raw/.reserved so don\u0027t strip */\n        } else {\n          pathComponents \u003d constructRemainingPath(\n              new byte[][]{INodeDirectory.ROOT_NAME}, pathComponents, 3);\n        }\n      }\n    }\n    // this double conversion will be unnecessary when resolving returns\n    // INodesInPath (needs components byte[][])\n    return DFSUtil.byteArray2PathString(pathComponents);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
          "extendedDetails": {}
        }
      ]
    },
    "3dadf369d550c2ae393b751cb5a184dbfe2814df": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7087. Ability to list /.reserved. Contributed by Xiao Chen.\n",
      "commitDate": "21/10/15 4:58 PM",
      "commitName": "3dadf369d550c2ae393b751cb5a184dbfe2814df",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "29/09/15 1:39 AM",
      "commitNameOld": "8fd55202468b28422b0df888641c9b08906fe4a7",
      "commitAuthorOld": "",
      "daysBetweenCommits": 22.64,
      "commitsBetweenForRepo": 171,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,31 +1,37 @@\n   static String resolvePath(String src, byte[][] pathComponents,\n       FSDirectory fsd) throws FileNotFoundException {\n     final int nComponents \u003d (pathComponents \u003d\u003d null) ?\n         0 : pathComponents.length;\n     if (nComponents \u003c\u003d 2) {\n       return src;\n     }\n     if (!Arrays.equals(DOT_RESERVED, pathComponents[1])) {\n       /* This is not a /.reserved/ path so do nothing. */\n       return src;\n     }\n \n     if (Arrays.equals(DOT_INODES, pathComponents[2])) {\n       /* It\u0027s a /.reserved/.inodes path. */\n       if (nComponents \u003e 3) {\n         return resolveDotInodesPath(src, pathComponents, fsd);\n       } else {\n         return src;\n       }\n     } else if (Arrays.equals(RAW, pathComponents[2])) {\n       /* It\u0027s /.reserved/raw so strip off the /.reserved/raw prefix. */\n       if (nComponents \u003d\u003d 3) {\n         return Path.SEPARATOR;\n       } else {\n-        return constructRemainingPath(\"\", pathComponents, 3);\n+        if (nComponents \u003d\u003d 4\n+            \u0026\u0026 Arrays.equals(DOT_RESERVED, pathComponents[3])) {\n+          /* It\u0027s /.reserved/raw/.reserved so don\u0027t strip */\n+          return src;\n+        } else {\n+          return constructRemainingPath(\"\", pathComponents, 3);\n+        }\n       }\n     } else {\n       /* It\u0027s some sort of /.reserved/\u003cunknown\u003e path. Ignore it. */\n       return src;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static String resolvePath(String src, byte[][] pathComponents,\n      FSDirectory fsd) throws FileNotFoundException {\n    final int nComponents \u003d (pathComponents \u003d\u003d null) ?\n        0 : pathComponents.length;\n    if (nComponents \u003c\u003d 2) {\n      return src;\n    }\n    if (!Arrays.equals(DOT_RESERVED, pathComponents[1])) {\n      /* This is not a /.reserved/ path so do nothing. */\n      return src;\n    }\n\n    if (Arrays.equals(DOT_INODES, pathComponents[2])) {\n      /* It\u0027s a /.reserved/.inodes path. */\n      if (nComponents \u003e 3) {\n        return resolveDotInodesPath(src, pathComponents, fsd);\n      } else {\n        return src;\n      }\n    } else if (Arrays.equals(RAW, pathComponents[2])) {\n      /* It\u0027s /.reserved/raw so strip off the /.reserved/raw prefix. */\n      if (nComponents \u003d\u003d 3) {\n        return Path.SEPARATOR;\n      } else {\n        if (nComponents \u003d\u003d 4\n            \u0026\u0026 Arrays.equals(DOT_RESERVED, pathComponents[3])) {\n          /* It\u0027s /.reserved/raw/.reserved so don\u0027t strip */\n          return src;\n        } else {\n          return constructRemainingPath(\"\", pathComponents, 3);\n        }\n      }\n    } else {\n      /* It\u0027s some sort of /.reserved/\u003cunknown\u003e path. Ignore it. */\n      return src;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "407bb3d3e452c8277c498dd14e0cc5b7762a7091": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6509. Create a special /.reserved/raw directory for raw access to encrypted data. Contributed by Charles Lamb.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/fs-encryption@1614490 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/07/14 2:11 PM",
      "commitName": "407bb3d3e452c8277c498dd14e0cc5b7762a7091",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "22/07/14 10:57 AM",
      "commitNameOld": "69b75fca7aec5f5cbf79bc7db3915119cef69e65",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 7.13,
      "commitsBetweenForRepo": 47,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,48 +1,31 @@\n-  static String resolvePath(String src, byte[][] pathComponents, FSDirectory fsd)\n-      throws FileNotFoundException {\n-    if (pathComponents \u003d\u003d null || pathComponents.length \u003c\u003d 3) {\n+  static String resolvePath(String src, byte[][] pathComponents,\n+      FSDirectory fsd) throws FileNotFoundException {\n+    final int nComponents \u003d (pathComponents \u003d\u003d null) ?\n+        0 : pathComponents.length;\n+    if (nComponents \u003c\u003d 2) {\n       return src;\n     }\n-    // Not /.reserved/.inodes\n-    if (!Arrays.equals(DOT_RESERVED, pathComponents[1])\n-        || !Arrays.equals(DOT_INODES, pathComponents[2])) { // Not .inodes path\n+    if (!Arrays.equals(DOT_RESERVED, pathComponents[1])) {\n+      /* This is not a /.reserved/ path so do nothing. */\n       return src;\n     }\n-    final String inodeId \u003d DFSUtil.bytes2String(pathComponents[3]);\n-    final long id;\n-    try {\n-      id \u003d Long.parseLong(inodeId);\n-    } catch (NumberFormatException e) {\n-      throw new FileNotFoundException(\"Invalid inode path: \" + src);\n-    }\n-    if (id \u003d\u003d INodeId.ROOT_INODE_ID \u0026\u0026 pathComponents.length \u003d\u003d 4) {\n-      return Path.SEPARATOR;\n-    }\n-    INode inode \u003d fsd.getInode(id);\n-    if (inode \u003d\u003d null) {\n-      throw new FileNotFoundException(\n-          \"File for given inode path does not exist: \" + src);\n-    }\n-    \n-    // Handle single \"..\" for NFS lookup support.\n-    if ((pathComponents.length \u003e 4)\n-        \u0026\u0026 DFSUtil.bytes2String(pathComponents[4]).equals(\"..\")) {\n-      INode parent \u003d inode.getParent();\n-      if (parent \u003d\u003d null || parent.getId() \u003d\u003d INodeId.ROOT_INODE_ID) {\n-        // inode is root, or its parent is root.\n-        return Path.SEPARATOR;\n-      } else {\n-        return parent.getFullPathName();\n-      }\n-    }\n \n-    StringBuilder path \u003d id \u003d\u003d INodeId.ROOT_INODE_ID ? new StringBuilder()\n-        : new StringBuilder(inode.getFullPathName());\n-    for (int i \u003d 4; i \u003c pathComponents.length; i++) {\n-      path.append(Path.SEPARATOR).append(DFSUtil.bytes2String(pathComponents[i]));\n+    if (Arrays.equals(DOT_INODES, pathComponents[2])) {\n+      /* It\u0027s a /.reserved/.inodes path. */\n+      if (nComponents \u003e 3) {\n+        return resolveDotInodesPath(src, pathComponents, fsd);\n+      } else {\n+        return src;\n+      }\n+    } else if (Arrays.equals(RAW, pathComponents[2])) {\n+      /* It\u0027s /.reserved/raw so strip off the /.reserved/raw prefix. */\n+      if (nComponents \u003d\u003d 3) {\n+        return Path.SEPARATOR;\n+      } else {\n+        return constructRemainingPath(\"\", pathComponents, 3);\n+      }\n+    } else {\n+      /* It\u0027s some sort of /.reserved/\u003cunknown\u003e path. Ignore it. */\n+      return src;\n     }\n-    if (NameNode.LOG.isDebugEnabled()) {\n-      NameNode.LOG.debug(\"Resolved path is \" + path);\n-    }\n-    return path.toString();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static String resolvePath(String src, byte[][] pathComponents,\n      FSDirectory fsd) throws FileNotFoundException {\n    final int nComponents \u003d (pathComponents \u003d\u003d null) ?\n        0 : pathComponents.length;\n    if (nComponents \u003c\u003d 2) {\n      return src;\n    }\n    if (!Arrays.equals(DOT_RESERVED, pathComponents[1])) {\n      /* This is not a /.reserved/ path so do nothing. */\n      return src;\n    }\n\n    if (Arrays.equals(DOT_INODES, pathComponents[2])) {\n      /* It\u0027s a /.reserved/.inodes path. */\n      if (nComponents \u003e 3) {\n        return resolveDotInodesPath(src, pathComponents, fsd);\n      } else {\n        return src;\n      }\n    } else if (Arrays.equals(RAW, pathComponents[2])) {\n      /* It\u0027s /.reserved/raw so strip off the /.reserved/raw prefix. */\n      if (nComponents \u003d\u003d 3) {\n        return Path.SEPARATOR;\n      } else {\n        return constructRemainingPath(\"\", pathComponents, 3);\n      }\n    } else {\n      /* It\u0027s some sort of /.reserved/\u003cunknown\u003e path. Ignore it. */\n      return src;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "ae9109b911b3d9e2d6ca50b400379fc31deeb0cf": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6328. Clean up dead code in FSDirectory. Contributed by Haohui Mai.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1593755 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/05/14 10:06 PM",
      "commitName": "ae9109b911b3d9e2d6ca50b400379fc31deeb0cf",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "30/04/14 10:44 AM",
      "commitNameOld": "0689363343a281a6f7f6f395227668bddc2663eb",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 10.47,
      "commitsBetweenForRepo": 43,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,48 +1,48 @@\n   static String resolvePath(String src, byte[][] pathComponents, FSDirectory fsd)\n       throws FileNotFoundException {\n     if (pathComponents \u003d\u003d null || pathComponents.length \u003c\u003d 3) {\n       return src;\n     }\n     // Not /.reserved/.inodes\n     if (!Arrays.equals(DOT_RESERVED, pathComponents[1])\n         || !Arrays.equals(DOT_INODES, pathComponents[2])) { // Not .inodes path\n       return src;\n     }\n     final String inodeId \u003d DFSUtil.bytes2String(pathComponents[3]);\n-    long id \u003d 0;\n+    final long id;\n     try {\n       id \u003d Long.parseLong(inodeId);\n     } catch (NumberFormatException e) {\n       throw new FileNotFoundException(\"Invalid inode path: \" + src);\n     }\n     if (id \u003d\u003d INodeId.ROOT_INODE_ID \u0026\u0026 pathComponents.length \u003d\u003d 4) {\n       return Path.SEPARATOR;\n     }\n     INode inode \u003d fsd.getInode(id);\n     if (inode \u003d\u003d null) {\n       throw new FileNotFoundException(\n           \"File for given inode path does not exist: \" + src);\n     }\n     \n     // Handle single \"..\" for NFS lookup support.\n     if ((pathComponents.length \u003e 4)\n         \u0026\u0026 DFSUtil.bytes2String(pathComponents[4]).equals(\"..\")) {\n       INode parent \u003d inode.getParent();\n       if (parent \u003d\u003d null || parent.getId() \u003d\u003d INodeId.ROOT_INODE_ID) {\n         // inode is root, or its parent is root.\n         return Path.SEPARATOR;\n       } else {\n         return parent.getFullPathName();\n       }\n     }\n \n     StringBuilder path \u003d id \u003d\u003d INodeId.ROOT_INODE_ID ? new StringBuilder()\n         : new StringBuilder(inode.getFullPathName());\n     for (int i \u003d 4; i \u003c pathComponents.length; i++) {\n       path.append(Path.SEPARATOR).append(DFSUtil.bytes2String(pathComponents[i]));\n     }\n     if (NameNode.LOG.isDebugEnabled()) {\n       NameNode.LOG.debug(\"Resolved path is \" + path);\n     }\n     return path.toString();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static String resolvePath(String src, byte[][] pathComponents, FSDirectory fsd)\n      throws FileNotFoundException {\n    if (pathComponents \u003d\u003d null || pathComponents.length \u003c\u003d 3) {\n      return src;\n    }\n    // Not /.reserved/.inodes\n    if (!Arrays.equals(DOT_RESERVED, pathComponents[1])\n        || !Arrays.equals(DOT_INODES, pathComponents[2])) { // Not .inodes path\n      return src;\n    }\n    final String inodeId \u003d DFSUtil.bytes2String(pathComponents[3]);\n    final long id;\n    try {\n      id \u003d Long.parseLong(inodeId);\n    } catch (NumberFormatException e) {\n      throw new FileNotFoundException(\"Invalid inode path: \" + src);\n    }\n    if (id \u003d\u003d INodeId.ROOT_INODE_ID \u0026\u0026 pathComponents.length \u003d\u003d 4) {\n      return Path.SEPARATOR;\n    }\n    INode inode \u003d fsd.getInode(id);\n    if (inode \u003d\u003d null) {\n      throw new FileNotFoundException(\n          \"File for given inode path does not exist: \" + src);\n    }\n    \n    // Handle single \"..\" for NFS lookup support.\n    if ((pathComponents.length \u003e 4)\n        \u0026\u0026 DFSUtil.bytes2String(pathComponents[4]).equals(\"..\")) {\n      INode parent \u003d inode.getParent();\n      if (parent \u003d\u003d null || parent.getId() \u003d\u003d INodeId.ROOT_INODE_ID) {\n        // inode is root, or its parent is root.\n        return Path.SEPARATOR;\n      } else {\n        return parent.getFullPathName();\n      }\n    }\n\n    StringBuilder path \u003d id \u003d\u003d INodeId.ROOT_INODE_ID ? new StringBuilder()\n        : new StringBuilder(inode.getFullPathName());\n    for (int i \u003d 4; i \u003c pathComponents.length; i++) {\n      path.append(Path.SEPARATOR).append(DFSUtil.bytes2String(pathComponents[i]));\n    }\n    if (NameNode.LOG.isDebugEnabled()) {\n      NameNode.LOG.debug(\"Resolved path is \" + path);\n    }\n    return path.toString();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "14556cc5d8fee8f8a846e4f65572828553be386c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6155. Fix Boxing/unboxing to parse a primitive findbugs warnings. Contributed by Suresh Srinivas.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1582068 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "26/03/14 2:27 PM",
      "commitName": "14556cc5d8fee8f8a846e4f65572828553be386c",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "24/03/14 10:51 PM",
      "commitNameOld": "3a61d25457606b93f7e99a48fe8f66984f4084b0",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 1.65,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,48 +1,48 @@\n   static String resolvePath(String src, byte[][] pathComponents, FSDirectory fsd)\n       throws FileNotFoundException {\n     if (pathComponents \u003d\u003d null || pathComponents.length \u003c\u003d 3) {\n       return src;\n     }\n     // Not /.reserved/.inodes\n     if (!Arrays.equals(DOT_RESERVED, pathComponents[1])\n         || !Arrays.equals(DOT_INODES, pathComponents[2])) { // Not .inodes path\n       return src;\n     }\n     final String inodeId \u003d DFSUtil.bytes2String(pathComponents[3]);\n     long id \u003d 0;\n     try {\n-      id \u003d Long.valueOf(inodeId);\n+      id \u003d Long.parseLong(inodeId);\n     } catch (NumberFormatException e) {\n       throw new FileNotFoundException(\"Invalid inode path: \" + src);\n     }\n     if (id \u003d\u003d INodeId.ROOT_INODE_ID \u0026\u0026 pathComponents.length \u003d\u003d 4) {\n       return Path.SEPARATOR;\n     }\n     INode inode \u003d fsd.getInode(id);\n     if (inode \u003d\u003d null) {\n       throw new FileNotFoundException(\n           \"File for given inode path does not exist: \" + src);\n     }\n     \n     // Handle single \"..\" for NFS lookup support.\n     if ((pathComponents.length \u003e 4)\n         \u0026\u0026 DFSUtil.bytes2String(pathComponents[4]).equals(\"..\")) {\n       INode parent \u003d inode.getParent();\n       if (parent \u003d\u003d null || parent.getId() \u003d\u003d INodeId.ROOT_INODE_ID) {\n         // inode is root, or its parent is root.\n         return Path.SEPARATOR;\n       } else {\n         return parent.getFullPathName();\n       }\n     }\n \n     StringBuilder path \u003d id \u003d\u003d INodeId.ROOT_INODE_ID ? new StringBuilder()\n         : new StringBuilder(inode.getFullPathName());\n     for (int i \u003d 4; i \u003c pathComponents.length; i++) {\n       path.append(Path.SEPARATOR).append(DFSUtil.bytes2String(pathComponents[i]));\n     }\n     if (NameNode.LOG.isDebugEnabled()) {\n       NameNode.LOG.debug(\"Resolved path is \" + path);\n     }\n     return path.toString();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static String resolvePath(String src, byte[][] pathComponents, FSDirectory fsd)\n      throws FileNotFoundException {\n    if (pathComponents \u003d\u003d null || pathComponents.length \u003c\u003d 3) {\n      return src;\n    }\n    // Not /.reserved/.inodes\n    if (!Arrays.equals(DOT_RESERVED, pathComponents[1])\n        || !Arrays.equals(DOT_INODES, pathComponents[2])) { // Not .inodes path\n      return src;\n    }\n    final String inodeId \u003d DFSUtil.bytes2String(pathComponents[3]);\n    long id \u003d 0;\n    try {\n      id \u003d Long.parseLong(inodeId);\n    } catch (NumberFormatException e) {\n      throw new FileNotFoundException(\"Invalid inode path: \" + src);\n    }\n    if (id \u003d\u003d INodeId.ROOT_INODE_ID \u0026\u0026 pathComponents.length \u003d\u003d 4) {\n      return Path.SEPARATOR;\n    }\n    INode inode \u003d fsd.getInode(id);\n    if (inode \u003d\u003d null) {\n      throw new FileNotFoundException(\n          \"File for given inode path does not exist: \" + src);\n    }\n    \n    // Handle single \"..\" for NFS lookup support.\n    if ((pathComponents.length \u003e 4)\n        \u0026\u0026 DFSUtil.bytes2String(pathComponents[4]).equals(\"..\")) {\n      INode parent \u003d inode.getParent();\n      if (parent \u003d\u003d null || parent.getId() \u003d\u003d INodeId.ROOT_INODE_ID) {\n        // inode is root, or its parent is root.\n        return Path.SEPARATOR;\n      } else {\n        return parent.getFullPathName();\n      }\n    }\n\n    StringBuilder path \u003d id \u003d\u003d INodeId.ROOT_INODE_ID ? new StringBuilder()\n        : new StringBuilder(inode.getFullPathName());\n    for (int i \u003d 4; i \u003c pathComponents.length; i++) {\n      path.append(Path.SEPARATOR).append(DFSUtil.bytes2String(pathComponents[i]));\n    }\n    if (NameNode.LOG.isDebugEnabled()) {\n      NameNode.LOG.debug(\"Resolved path is \" + path);\n    }\n    return path.toString();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "214d4377fc151297c85b09273dfe8fdddae40d3d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5104 Support dotdot name in NFS LOOKUP operation. Contributed by Brandon Li\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1515042 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/08/13 2:16 PM",
      "commitName": "214d4377fc151297c85b09273dfe8fdddae40d3d",
      "commitAuthor": "Brandon Li",
      "commitDateOld": "16/08/13 10:14 AM",
      "commitNameOld": "8d21926c2613062149d07d238022f993af4c9c03",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 1.17,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,48 @@\n   static String resolvePath(String src, byte[][] pathComponents, FSDirectory fsd)\n       throws FileNotFoundException {\n     if (pathComponents \u003d\u003d null || pathComponents.length \u003c\u003d 3) {\n       return src;\n     }\n     // Not /.reserved/.inodes\n     if (!Arrays.equals(DOT_RESERVED, pathComponents[1])\n         || !Arrays.equals(DOT_INODES, pathComponents[2])) { // Not .inodes path\n       return src;\n     }\n     final String inodeId \u003d DFSUtil.bytes2String(pathComponents[3]);\n     long id \u003d 0;\n     try {\n       id \u003d Long.valueOf(inodeId);\n     } catch (NumberFormatException e) {\n       throw new FileNotFoundException(\"Invalid inode path: \" + src);\n     }\n     if (id \u003d\u003d INodeId.ROOT_INODE_ID \u0026\u0026 pathComponents.length \u003d\u003d 4) {\n       return Path.SEPARATOR;\n     }\n     INode inode \u003d fsd.getInode(id);\n     if (inode \u003d\u003d null) {\n       throw new FileNotFoundException(\n           \"File for given inode path does not exist: \" + src);\n     }\n+    \n+    // Handle single \"..\" for NFS lookup support.\n+    if ((pathComponents.length \u003e 4)\n+        \u0026\u0026 DFSUtil.bytes2String(pathComponents[4]).equals(\"..\")) {\n+      INode parent \u003d inode.getParent();\n+      if (parent \u003d\u003d null || parent.getId() \u003d\u003d INodeId.ROOT_INODE_ID) {\n+        // inode is root, or its parent is root.\n+        return Path.SEPARATOR;\n+      } else {\n+        return parent.getFullPathName();\n+      }\n+    }\n+\n     StringBuilder path \u003d id \u003d\u003d INodeId.ROOT_INODE_ID ? new StringBuilder()\n         : new StringBuilder(inode.getFullPathName());\n     for (int i \u003d 4; i \u003c pathComponents.length; i++) {\n       path.append(Path.SEPARATOR).append(DFSUtil.bytes2String(pathComponents[i]));\n     }\n     if (NameNode.LOG.isDebugEnabled()) {\n       NameNode.LOG.debug(\"Resolved path is \" + path);\n     }\n     return path.toString();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static String resolvePath(String src, byte[][] pathComponents, FSDirectory fsd)\n      throws FileNotFoundException {\n    if (pathComponents \u003d\u003d null || pathComponents.length \u003c\u003d 3) {\n      return src;\n    }\n    // Not /.reserved/.inodes\n    if (!Arrays.equals(DOT_RESERVED, pathComponents[1])\n        || !Arrays.equals(DOT_INODES, pathComponents[2])) { // Not .inodes path\n      return src;\n    }\n    final String inodeId \u003d DFSUtil.bytes2String(pathComponents[3]);\n    long id \u003d 0;\n    try {\n      id \u003d Long.valueOf(inodeId);\n    } catch (NumberFormatException e) {\n      throw new FileNotFoundException(\"Invalid inode path: \" + src);\n    }\n    if (id \u003d\u003d INodeId.ROOT_INODE_ID \u0026\u0026 pathComponents.length \u003d\u003d 4) {\n      return Path.SEPARATOR;\n    }\n    INode inode \u003d fsd.getInode(id);\n    if (inode \u003d\u003d null) {\n      throw new FileNotFoundException(\n          \"File for given inode path does not exist: \" + src);\n    }\n    \n    // Handle single \"..\" for NFS lookup support.\n    if ((pathComponents.length \u003e 4)\n        \u0026\u0026 DFSUtil.bytes2String(pathComponents[4]).equals(\"..\")) {\n      INode parent \u003d inode.getParent();\n      if (parent \u003d\u003d null || parent.getId() \u003d\u003d INodeId.ROOT_INODE_ID) {\n        // inode is root, or its parent is root.\n        return Path.SEPARATOR;\n      } else {\n        return parent.getFullPathName();\n      }\n    }\n\n    StringBuilder path \u003d id \u003d\u003d INodeId.ROOT_INODE_ID ? new StringBuilder()\n        : new StringBuilder(inode.getFullPathName());\n    for (int i \u003d 4; i \u003c pathComponents.length; i++) {\n      path.append(Path.SEPARATOR).append(DFSUtil.bytes2String(pathComponents[i]));\n    }\n    if (NameNode.LOG.isDebugEnabled()) {\n      NameNode.LOG.debug(\"Resolved path is \" + path);\n    }\n    return path.toString();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    },
    "a4bae51b7dac4301942ed28d0128fc9ef6a0d13a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4784. NPE in FSDirectory.resolvePath(). Contributed by Brandon Li.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1478276 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "01/05/13 11:02 PM",
      "commitName": "a4bae51b7dac4301942ed28d0128fc9ef6a0d13a",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "01/05/13 9:51 PM",
      "commitNameOld": "03ba436d42418226a5edb754f5119fe69039c8b8",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 0.05,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,31 +1,35 @@\n   static String resolvePath(String src, byte[][] pathComponents, FSDirectory fsd)\n       throws FileNotFoundException {\n     if (pathComponents \u003d\u003d null || pathComponents.length \u003c\u003d 3) {\n       return src;\n     }\n     // Not /.reserved/.inodes\n     if (!Arrays.equals(DOT_RESERVED, pathComponents[1])\n         || !Arrays.equals(DOT_INODES, pathComponents[2])) { // Not .inodes path\n       return src;\n     }\n     final String inodeId \u003d DFSUtil.bytes2String(pathComponents[3]);\n     long id \u003d 0;\n     try {\n       id \u003d Long.valueOf(inodeId);\n     } catch (NumberFormatException e) {\n-      throw new FileNotFoundException(\n-          \"File for given inode path does not exist: \" + src);\n+      throw new FileNotFoundException(\"Invalid inode path: \" + src);\n     }\n     if (id \u003d\u003d INodeId.ROOT_INODE_ID \u0026\u0026 pathComponents.length \u003d\u003d 4) {\n       return Path.SEPARATOR;\n     }\n+    INode inode \u003d fsd.getInode(id);\n+    if (inode \u003d\u003d null) {\n+      throw new FileNotFoundException(\n+          \"File for given inode path does not exist: \" + src);\n+    }\n     StringBuilder path \u003d id \u003d\u003d INodeId.ROOT_INODE_ID ? new StringBuilder()\n-        : new StringBuilder(fsd.getInode(id).getFullPathName());\n+        : new StringBuilder(inode.getFullPathName());\n     for (int i \u003d 4; i \u003c pathComponents.length; i++) {\n       path.append(Path.SEPARATOR).append(DFSUtil.bytes2String(pathComponents[i]));\n     }\n     if (NameNode.LOG.isDebugEnabled()) {\n       NameNode.LOG.debug(\"Resolved path is \" + path);\n     }\n     return path.toString();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static String resolvePath(String src, byte[][] pathComponents, FSDirectory fsd)\n      throws FileNotFoundException {\n    if (pathComponents \u003d\u003d null || pathComponents.length \u003c\u003d 3) {\n      return src;\n    }\n    // Not /.reserved/.inodes\n    if (!Arrays.equals(DOT_RESERVED, pathComponents[1])\n        || !Arrays.equals(DOT_INODES, pathComponents[2])) { // Not .inodes path\n      return src;\n    }\n    final String inodeId \u003d DFSUtil.bytes2String(pathComponents[3]);\n    long id \u003d 0;\n    try {\n      id \u003d Long.valueOf(inodeId);\n    } catch (NumberFormatException e) {\n      throw new FileNotFoundException(\"Invalid inode path: \" + src);\n    }\n    if (id \u003d\u003d INodeId.ROOT_INODE_ID \u0026\u0026 pathComponents.length \u003d\u003d 4) {\n      return Path.SEPARATOR;\n    }\n    INode inode \u003d fsd.getInode(id);\n    if (inode \u003d\u003d null) {\n      throw new FileNotFoundException(\n          \"File for given inode path does not exist: \" + src);\n    }\n    StringBuilder path \u003d id \u003d\u003d INodeId.ROOT_INODE_ID ? new StringBuilder()\n        : new StringBuilder(inode.getFullPathName());\n    for (int i \u003d 4; i \u003c pathComponents.length; i++) {\n      path.append(Path.SEPARATOR).append(DFSUtil.bytes2String(pathComponents[i]));\n    }\n    if (NameNode.LOG.isDebugEnabled()) {\n      NameNode.LOG.debug(\"Resolved path is \" + path);\n    }\n    return path.toString();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirectory.java",
      "extendedDetails": {}
    }
  }
}