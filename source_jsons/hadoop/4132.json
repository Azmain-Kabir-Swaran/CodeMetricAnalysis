{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "NameNodeProxiesClient.java",
  "functionName": "createFailoverProxyProvider",
  "functionId": "createFailoverProxyProvider___conf-Configuration__nameNodeUri-URI__xface-Class__T____checkPort-boolean__fallbackToSimpleAuth-AtomicBoolean__proxyFactory-HAProxyFactory__T__",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/NameNodeProxiesClient.java",
  "functionStartLine": 228,
  "functionEndLine": 280,
  "numCommitsSeen": 8,
  "timeTaken": 1327,
  "changeHistory": [
    "9e0e430f18d45cfe125dda8d85916edddf79e8d6"
  ],
  "changeHistoryShort": {
    "9e0e430f18d45cfe125dda8d85916edddf79e8d6": "Yintroduced"
  },
  "changeHistoryDetails": {
    "9e0e430f18d45cfe125dda8d85916edddf79e8d6": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-11538. Move ClientProtocol HA proxies into hadoop-hdfs-client. Contributed by Huafeng Wang.\n",
      "commitDate": "04/04/17 11:05 PM",
      "commitName": "9e0e430f18d45cfe125dda8d85916edddf79e8d6",
      "commitAuthor": "Andrew Wang",
      "diff": "@@ -0,0 +1,53 @@\n+  protected static \u003cT\u003e AbstractNNFailoverProxyProvider\u003cT\u003e createFailoverProxyProvider(\n+      Configuration conf, URI nameNodeUri, Class\u003cT\u003e xface, boolean checkPort,\n+      AtomicBoolean fallbackToSimpleAuth, HAProxyFactory\u003cT\u003e proxyFactory)\n+      throws IOException {\n+    Class\u003cFailoverProxyProvider\u003cT\u003e\u003e failoverProxyProviderClass \u003d null;\n+    AbstractNNFailoverProxyProvider\u003cT\u003e providerNN;\n+    try {\n+      // Obtain the class of the proxy provider\n+      failoverProxyProviderClass \u003d getFailoverProxyProviderClass(conf,\n+          nameNodeUri);\n+      if (failoverProxyProviderClass \u003d\u003d null) {\n+        return null;\n+      }\n+      // Create a proxy provider instance.\n+      Constructor\u003cFailoverProxyProvider\u003cT\u003e\u003e ctor \u003d failoverProxyProviderClass\n+          .getConstructor(Configuration.class, URI.class,\n+              Class.class, HAProxyFactory.class);\n+      FailoverProxyProvider\u003cT\u003e provider \u003d ctor.newInstance(conf, nameNodeUri,\n+          xface, proxyFactory);\n+\n+      // If the proxy provider is of an old implementation, wrap it.\n+      if (!(provider instanceof AbstractNNFailoverProxyProvider)) {\n+        providerNN \u003d new WrappedFailoverProxyProvider\u003c\u003e(provider);\n+      } else {\n+        providerNN \u003d (AbstractNNFailoverProxyProvider\u003cT\u003e)provider;\n+      }\n+    } catch (Exception e) {\n+      final String message \u003d \"Couldn\u0027t create proxy provider \" +\n+          failoverProxyProviderClass;\n+      LOG.debug(message, e);\n+      if (e.getCause() instanceof IOException) {\n+        throw (IOException) e.getCause();\n+      } else {\n+        throw new IOException(message, e);\n+      }\n+    }\n+\n+    // Check the port in the URI, if it is logical.\n+    if (checkPort \u0026\u0026 providerNN.useLogicalURI()) {\n+      int port \u003d nameNodeUri.getPort();\n+      if (port \u003e 0 \u0026\u0026\n+          port !\u003d HdfsClientConfigKeys.DFS_NAMENODE_RPC_PORT_DEFAULT) {\n+        // Throwing here without any cleanup is fine since we have not\n+        // actually created the underlying proxies yet.\n+        throw new IOException(\"Port \" + port + \" specified in URI \"\n+            + nameNodeUri + \" but host \u0027\" + nameNodeUri.getHost()\n+            + \"\u0027 is a logical (HA) namenode\"\n+            + \" and does not use port information.\");\n+      }\n+    }\n+    providerNN.setFallbackToSimpleAuth(fallbackToSimpleAuth);\n+    return providerNN;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  protected static \u003cT\u003e AbstractNNFailoverProxyProvider\u003cT\u003e createFailoverProxyProvider(\n      Configuration conf, URI nameNodeUri, Class\u003cT\u003e xface, boolean checkPort,\n      AtomicBoolean fallbackToSimpleAuth, HAProxyFactory\u003cT\u003e proxyFactory)\n      throws IOException {\n    Class\u003cFailoverProxyProvider\u003cT\u003e\u003e failoverProxyProviderClass \u003d null;\n    AbstractNNFailoverProxyProvider\u003cT\u003e providerNN;\n    try {\n      // Obtain the class of the proxy provider\n      failoverProxyProviderClass \u003d getFailoverProxyProviderClass(conf,\n          nameNodeUri);\n      if (failoverProxyProviderClass \u003d\u003d null) {\n        return null;\n      }\n      // Create a proxy provider instance.\n      Constructor\u003cFailoverProxyProvider\u003cT\u003e\u003e ctor \u003d failoverProxyProviderClass\n          .getConstructor(Configuration.class, URI.class,\n              Class.class, HAProxyFactory.class);\n      FailoverProxyProvider\u003cT\u003e provider \u003d ctor.newInstance(conf, nameNodeUri,\n          xface, proxyFactory);\n\n      // If the proxy provider is of an old implementation, wrap it.\n      if (!(provider instanceof AbstractNNFailoverProxyProvider)) {\n        providerNN \u003d new WrappedFailoverProxyProvider\u003c\u003e(provider);\n      } else {\n        providerNN \u003d (AbstractNNFailoverProxyProvider\u003cT\u003e)provider;\n      }\n    } catch (Exception e) {\n      final String message \u003d \"Couldn\u0027t create proxy provider \" +\n          failoverProxyProviderClass;\n      LOG.debug(message, e);\n      if (e.getCause() instanceof IOException) {\n        throw (IOException) e.getCause();\n      } else {\n        throw new IOException(message, e);\n      }\n    }\n\n    // Check the port in the URI, if it is logical.\n    if (checkPort \u0026\u0026 providerNN.useLogicalURI()) {\n      int port \u003d nameNodeUri.getPort();\n      if (port \u003e 0 \u0026\u0026\n          port !\u003d HdfsClientConfigKeys.DFS_NAMENODE_RPC_PORT_DEFAULT) {\n        // Throwing here without any cleanup is fine since we have not\n        // actually created the underlying proxies yet.\n        throw new IOException(\"Port \" + port + \" specified in URI \"\n            + nameNodeUri + \" but host \u0027\" + nameNodeUri.getHost()\n            + \"\u0027 is a logical (HA) namenode\"\n            + \" and does not use port information.\");\n      }\n    }\n    providerNN.setFallbackToSimpleAuth(fallbackToSimpleAuth);\n    return providerNN;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/NameNodeProxiesClient.java"
    }
  }
}