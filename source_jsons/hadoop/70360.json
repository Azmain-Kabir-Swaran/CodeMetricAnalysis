{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "NativeAzureFileSystem.java",
  "functionName": "delete",
  "functionId": "delete___f-Path__recursive-boolean",
  "sourceFilePath": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
  "functionStartLine": 1934,
  "functionEndLine": 1936,
  "numCommitsSeen": 66,
  "timeTaken": 2762,
  "changeHistory": [
    "2217e2f8ff418b88eac6ad36cafe3a9795a11f40",
    "0d91576ec31f63402f2db6107a04155368e2632d",
    "81bc395deb3ba00567dc067d6ca71bacf9e3bc82"
  ],
  "changeHistoryShort": {
    "2217e2f8ff418b88eac6ad36cafe3a9795a11f40": "Ybodychange",
    "0d91576ec31f63402f2db6107a04155368e2632d": "Ybodychange",
    "81bc395deb3ba00567dc067d6ca71bacf9e3bc82": "Yintroduced"
  },
  "changeHistoryDetails": {
    "2217e2f8ff418b88eac6ad36cafe3a9795a11f40": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10809. hadoop-azure: page blob support. Contributed by Dexter Bradshaw, Mostafa Elhemali, Eric Hanson, and Mike Liddell.\n",
      "commitDate": "08/10/14 2:20 PM",
      "commitName": "2217e2f8ff418b88eac6ad36cafe3a9795a11f40",
      "commitAuthor": "cnauroth",
      "commitDateOld": "19/09/14 11:33 AM",
      "commitNameOld": "9f03a7c018bb2c497cd0ef758f1a3e08e8163d06",
      "commitAuthorOld": "Allen Wittenauer",
      "daysBetweenCommits": 19.12,
      "commitsBetweenForRepo": 199,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,115 +1,3 @@\n   public boolean delete(Path f, boolean recursive) throws IOException {\n-\n-    if (LOG.isDebugEnabled()) {\n-      LOG.debug(\"Deleting file: \" + f.toString());\n-    }\n-\n-    Path absolutePath \u003d makeAbsolute(f);\n-    String key \u003d pathToKey(absolutePath);\n-\n-    // Capture the metadata for the path.\n-    //\n-    FileMetadata metaFile \u003d store.retrieveMetadata(key);\n-\n-    if (null \u003d\u003d metaFile) {\n-      // The path to be deleted does not exist.\n-      return false;\n-    }\n-\n-    // The path exists, determine if it is a folder containing objects,\n-    // an empty folder, or a simple file and take the appropriate actions.\n-    if (!metaFile.isDir()) {\n-      // The path specifies a file. We need to check the parent path\n-      // to make sure it\u0027s a proper materialized directory before we\n-      // delete the file. Otherwise we may get into a situation where\n-      // the file we were deleting was the last one in an implicit directory\n-      // (e.g. the blob store only contains the blob a/b and there\u0027s no\n-      // corresponding directory blob a) and that would implicitly delete\n-      // the directory as well, which is not correct.\n-      Path parentPath \u003d absolutePath.getParent();\n-      if (parentPath.getParent() !\u003d null) {// Not root\n-        String parentKey \u003d pathToKey(parentPath);\n-        FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n-        if (!parentMetadata.isDir()) {\n-          // Invalid state: the parent path is actually a file. Throw.\n-          throw new AzureException(\"File \" + f + \" has a parent directory \"\n-              + parentPath + \" which is also a file. Can\u0027t resolve.\");\n-        }\n-        if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n-          if (LOG.isDebugEnabled()) {\n-            LOG.debug(\"Found an implicit parent directory while trying to\"\n-                + \" delete the file \" + f + \". Creating the directory blob for\"\n-                + \" it in \" + parentKey + \".\");\n-          }\n-          store.storeEmptyFolder(parentKey,\n-              createPermissionStatus(FsPermission.getDefault()));\n-        } else {\n-          store.updateFolderLastModifiedTime(parentKey);\n-        }\n-      }\n-      instrumentation.fileDeleted();\n-      store.delete(key);\n-    } else {\n-      // The path specifies a folder. Recursively delete all entries under the\n-      // folder.\n-      Path parentPath \u003d absolutePath.getParent();\n-      if (parentPath.getParent() !\u003d null) {\n-        String parentKey \u003d pathToKey(parentPath);\n-        FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n-\n-        if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n-          if (LOG.isDebugEnabled()) {\n-            LOG.debug(\"Found an implicit parent directory while trying to\"\n-                + \" delete the directory \" + f\n-                + \". Creating the directory blob for\" + \" it in \" + parentKey\n-                + \".\");\n-          }\n-          store.storeEmptyFolder(parentKey,\n-              createPermissionStatus(FsPermission.getDefault()));\n-        }\n-      }\n-\n-      // List all the blobs in the current folder.\n-      String priorLastKey \u003d null;\n-      PartialListing listing \u003d store.listAll(key, AZURE_LIST_ALL, 1,\n-          priorLastKey);\n-      FileMetadata[] contents \u003d listing.getFiles();\n-      if (!recursive \u0026\u0026 contents.length \u003e 0) {\n-        // The folder is non-empty and recursive delete was not specified.\n-        // Throw an exception indicating that a non-recursive delete was\n-        // specified for a non-empty folder.\n-        throw new IOException(\"Non-recursive delete of non-empty directory \"\n-            + f.toString());\n-      }\n-\n-      // Delete all the files in the folder.\n-      for (FileMetadata p : contents) {\n-        // Tag on the directory name found as the suffix of the suffix of the\n-        // parent directory to get the new absolute path.\n-        String suffix \u003d p.getKey().substring(\n-            p.getKey().lastIndexOf(PATH_DELIMITER));\n-        if (!p.isDir()) {\n-          store.delete(key + suffix);\n-          instrumentation.fileDeleted();\n-        } else {\n-          // Recursively delete contents of the sub-folders. Notice this also\n-          // deletes the blob for the directory.\n-          if (!delete(new Path(f.toString() + suffix), true)) {\n-            return false;\n-          }\n-        }\n-      }\n-      store.delete(key);\n-\n-      // Update parent directory last modified time\n-      Path parent \u003d absolutePath.getParent();\n-      if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) { // not root\n-        String parentKey \u003d pathToKey(parent);\n-        store.updateFolderLastModifiedTime(parentKey);\n-      }\n-      instrumentation.directoryDeleted();\n-    }\n-\n-    // File or directory was successfully deleted.\n-    return true;\n+    return delete(f, recursive, false);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean delete(Path f, boolean recursive) throws IOException {\n    return delete(f, recursive, false);\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
      "extendedDetails": {}
    },
    "0d91576ec31f63402f2db6107a04155368e2632d": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10728. Metrics system for Windows Azure Storage Filesystem. Contributed by Dexter Bradshaw, Mostafa Elhemali, Xi Fang, Johannes Klein, David Lao, Mike Liddell, Chuan Liu, Lengning Liu, Ivan Mitic, Michael Rys, Alexander Stojanovic, Brian Swan, and Min Wei.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1605187 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/06/14 1:52 PM",
      "commitName": "0d91576ec31f63402f2db6107a04155368e2632d",
      "commitAuthor": "Chris Nauroth",
      "commitDateOld": "20/06/14 11:36 AM",
      "commitNameOld": "61bf9f779919206296d2ce84a8a6b2d912709a59",
      "commitAuthorOld": "Chris Nauroth",
      "daysBetweenCommits": 4.09,
      "commitsBetweenForRepo": 30,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,112 +1,115 @@\n   public boolean delete(Path f, boolean recursive) throws IOException {\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Deleting file: \" + f.toString());\n     }\n \n     Path absolutePath \u003d makeAbsolute(f);\n     String key \u003d pathToKey(absolutePath);\n \n     // Capture the metadata for the path.\n     //\n     FileMetadata metaFile \u003d store.retrieveMetadata(key);\n \n     if (null \u003d\u003d metaFile) {\n       // The path to be deleted does not exist.\n       return false;\n     }\n \n     // The path exists, determine if it is a folder containing objects,\n     // an empty folder, or a simple file and take the appropriate actions.\n     if (!metaFile.isDir()) {\n       // The path specifies a file. We need to check the parent path\n       // to make sure it\u0027s a proper materialized directory before we\n       // delete the file. Otherwise we may get into a situation where\n       // the file we were deleting was the last one in an implicit directory\n       // (e.g. the blob store only contains the blob a/b and there\u0027s no\n       // corresponding directory blob a) and that would implicitly delete\n       // the directory as well, which is not correct.\n       Path parentPath \u003d absolutePath.getParent();\n       if (parentPath.getParent() !\u003d null) {// Not root\n         String parentKey \u003d pathToKey(parentPath);\n         FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n         if (!parentMetadata.isDir()) {\n           // Invalid state: the parent path is actually a file. Throw.\n           throw new AzureException(\"File \" + f + \" has a parent directory \"\n               + parentPath + \" which is also a file. Can\u0027t resolve.\");\n         }\n         if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Found an implicit parent directory while trying to\"\n                 + \" delete the file \" + f + \". Creating the directory blob for\"\n                 + \" it in \" + parentKey + \".\");\n           }\n           store.storeEmptyFolder(parentKey,\n               createPermissionStatus(FsPermission.getDefault()));\n         } else {\n           store.updateFolderLastModifiedTime(parentKey);\n         }\n       }\n+      instrumentation.fileDeleted();\n       store.delete(key);\n     } else {\n       // The path specifies a folder. Recursively delete all entries under the\n       // folder.\n       Path parentPath \u003d absolutePath.getParent();\n       if (parentPath.getParent() !\u003d null) {\n         String parentKey \u003d pathToKey(parentPath);\n         FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n \n         if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Found an implicit parent directory while trying to\"\n                 + \" delete the directory \" + f\n                 + \". Creating the directory blob for\" + \" it in \" + parentKey\n                 + \".\");\n           }\n           store.storeEmptyFolder(parentKey,\n               createPermissionStatus(FsPermission.getDefault()));\n         }\n       }\n \n       // List all the blobs in the current folder.\n       String priorLastKey \u003d null;\n       PartialListing listing \u003d store.listAll(key, AZURE_LIST_ALL, 1,\n           priorLastKey);\n       FileMetadata[] contents \u003d listing.getFiles();\n       if (!recursive \u0026\u0026 contents.length \u003e 0) {\n         // The folder is non-empty and recursive delete was not specified.\n         // Throw an exception indicating that a non-recursive delete was\n         // specified for a non-empty folder.\n         throw new IOException(\"Non-recursive delete of non-empty directory \"\n             + f.toString());\n       }\n \n       // Delete all the files in the folder.\n       for (FileMetadata p : contents) {\n         // Tag on the directory name found as the suffix of the suffix of the\n         // parent directory to get the new absolute path.\n         String suffix \u003d p.getKey().substring(\n             p.getKey().lastIndexOf(PATH_DELIMITER));\n         if (!p.isDir()) {\n           store.delete(key + suffix);\n+          instrumentation.fileDeleted();\n         } else {\n           // Recursively delete contents of the sub-folders. Notice this also\n           // deletes the blob for the directory.\n           if (!delete(new Path(f.toString() + suffix), true)) {\n             return false;\n           }\n         }\n       }\n       store.delete(key);\n \n       // Update parent directory last modified time\n       Path parent \u003d absolutePath.getParent();\n       if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) { // not root\n         String parentKey \u003d pathToKey(parent);\n         store.updateFolderLastModifiedTime(parentKey);\n       }\n+      instrumentation.directoryDeleted();\n     }\n \n     // File or directory was successfully deleted.\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean delete(Path f, boolean recursive) throws IOException {\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Deleting file: \" + f.toString());\n    }\n\n    Path absolutePath \u003d makeAbsolute(f);\n    String key \u003d pathToKey(absolutePath);\n\n    // Capture the metadata for the path.\n    //\n    FileMetadata metaFile \u003d store.retrieveMetadata(key);\n\n    if (null \u003d\u003d metaFile) {\n      // The path to be deleted does not exist.\n      return false;\n    }\n\n    // The path exists, determine if it is a folder containing objects,\n    // an empty folder, or a simple file and take the appropriate actions.\n    if (!metaFile.isDir()) {\n      // The path specifies a file. We need to check the parent path\n      // to make sure it\u0027s a proper materialized directory before we\n      // delete the file. Otherwise we may get into a situation where\n      // the file we were deleting was the last one in an implicit directory\n      // (e.g. the blob store only contains the blob a/b and there\u0027s no\n      // corresponding directory blob a) and that would implicitly delete\n      // the directory as well, which is not correct.\n      Path parentPath \u003d absolutePath.getParent();\n      if (parentPath.getParent() !\u003d null) {// Not root\n        String parentKey \u003d pathToKey(parentPath);\n        FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n        if (!parentMetadata.isDir()) {\n          // Invalid state: the parent path is actually a file. Throw.\n          throw new AzureException(\"File \" + f + \" has a parent directory \"\n              + parentPath + \" which is also a file. Can\u0027t resolve.\");\n        }\n        if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Found an implicit parent directory while trying to\"\n                + \" delete the file \" + f + \". Creating the directory blob for\"\n                + \" it in \" + parentKey + \".\");\n          }\n          store.storeEmptyFolder(parentKey,\n              createPermissionStatus(FsPermission.getDefault()));\n        } else {\n          store.updateFolderLastModifiedTime(parentKey);\n        }\n      }\n      instrumentation.fileDeleted();\n      store.delete(key);\n    } else {\n      // The path specifies a folder. Recursively delete all entries under the\n      // folder.\n      Path parentPath \u003d absolutePath.getParent();\n      if (parentPath.getParent() !\u003d null) {\n        String parentKey \u003d pathToKey(parentPath);\n        FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n\n        if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Found an implicit parent directory while trying to\"\n                + \" delete the directory \" + f\n                + \". Creating the directory blob for\" + \" it in \" + parentKey\n                + \".\");\n          }\n          store.storeEmptyFolder(parentKey,\n              createPermissionStatus(FsPermission.getDefault()));\n        }\n      }\n\n      // List all the blobs in the current folder.\n      String priorLastKey \u003d null;\n      PartialListing listing \u003d store.listAll(key, AZURE_LIST_ALL, 1,\n          priorLastKey);\n      FileMetadata[] contents \u003d listing.getFiles();\n      if (!recursive \u0026\u0026 contents.length \u003e 0) {\n        // The folder is non-empty and recursive delete was not specified.\n        // Throw an exception indicating that a non-recursive delete was\n        // specified for a non-empty folder.\n        throw new IOException(\"Non-recursive delete of non-empty directory \"\n            + f.toString());\n      }\n\n      // Delete all the files in the folder.\n      for (FileMetadata p : contents) {\n        // Tag on the directory name found as the suffix of the suffix of the\n        // parent directory to get the new absolute path.\n        String suffix \u003d p.getKey().substring(\n            p.getKey().lastIndexOf(PATH_DELIMITER));\n        if (!p.isDir()) {\n          store.delete(key + suffix);\n          instrumentation.fileDeleted();\n        } else {\n          // Recursively delete contents of the sub-folders. Notice this also\n          // deletes the blob for the directory.\n          if (!delete(new Path(f.toString() + suffix), true)) {\n            return false;\n          }\n        }\n      }\n      store.delete(key);\n\n      // Update parent directory last modified time\n      Path parent \u003d absolutePath.getParent();\n      if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) { // not root\n        String parentKey \u003d pathToKey(parent);\n        store.updateFolderLastModifiedTime(parentKey);\n      }\n      instrumentation.directoryDeleted();\n    }\n\n    // File or directory was successfully deleted.\n    return true;\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
      "extendedDetails": {}
    },
    "81bc395deb3ba00567dc067d6ca71bacf9e3bc82": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-9629. Support Windows Azure Storage - Blob as a file system in Hadoop. Contributed by Dexter Bradshaw, Mostafa Elhemali, Xi Fang, Johannes Klein, David Lao, Mike Liddell, Chuan Liu, Lengning Liu, Ivan Mitic, Michael Rys, Alexander Stojanovic, Brian Swan, and Min Wei.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1601781 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/06/14 3:26 PM",
      "commitName": "81bc395deb3ba00567dc067d6ca71bacf9e3bc82",
      "commitAuthor": "Chris Nauroth",
      "diff": "@@ -0,0 +1,112 @@\n+  public boolean delete(Path f, boolean recursive) throws IOException {\n+\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(\"Deleting file: \" + f.toString());\n+    }\n+\n+    Path absolutePath \u003d makeAbsolute(f);\n+    String key \u003d pathToKey(absolutePath);\n+\n+    // Capture the metadata for the path.\n+    //\n+    FileMetadata metaFile \u003d store.retrieveMetadata(key);\n+\n+    if (null \u003d\u003d metaFile) {\n+      // The path to be deleted does not exist.\n+      return false;\n+    }\n+\n+    // The path exists, determine if it is a folder containing objects,\n+    // an empty folder, or a simple file and take the appropriate actions.\n+    if (!metaFile.isDir()) {\n+      // The path specifies a file. We need to check the parent path\n+      // to make sure it\u0027s a proper materialized directory before we\n+      // delete the file. Otherwise we may get into a situation where\n+      // the file we were deleting was the last one in an implicit directory\n+      // (e.g. the blob store only contains the blob a/b and there\u0027s no\n+      // corresponding directory blob a) and that would implicitly delete\n+      // the directory as well, which is not correct.\n+      Path parentPath \u003d absolutePath.getParent();\n+      if (parentPath.getParent() !\u003d null) {// Not root\n+        String parentKey \u003d pathToKey(parentPath);\n+        FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n+        if (!parentMetadata.isDir()) {\n+          // Invalid state: the parent path is actually a file. Throw.\n+          throw new AzureException(\"File \" + f + \" has a parent directory \"\n+              + parentPath + \" which is also a file. Can\u0027t resolve.\");\n+        }\n+        if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n+          if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"Found an implicit parent directory while trying to\"\n+                + \" delete the file \" + f + \". Creating the directory blob for\"\n+                + \" it in \" + parentKey + \".\");\n+          }\n+          store.storeEmptyFolder(parentKey,\n+              createPermissionStatus(FsPermission.getDefault()));\n+        } else {\n+          store.updateFolderLastModifiedTime(parentKey);\n+        }\n+      }\n+      store.delete(key);\n+    } else {\n+      // The path specifies a folder. Recursively delete all entries under the\n+      // folder.\n+      Path parentPath \u003d absolutePath.getParent();\n+      if (parentPath.getParent() !\u003d null) {\n+        String parentKey \u003d pathToKey(parentPath);\n+        FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n+\n+        if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n+          if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"Found an implicit parent directory while trying to\"\n+                + \" delete the directory \" + f\n+                + \". Creating the directory blob for\" + \" it in \" + parentKey\n+                + \".\");\n+          }\n+          store.storeEmptyFolder(parentKey,\n+              createPermissionStatus(FsPermission.getDefault()));\n+        }\n+      }\n+\n+      // List all the blobs in the current folder.\n+      String priorLastKey \u003d null;\n+      PartialListing listing \u003d store.listAll(key, AZURE_LIST_ALL, 1,\n+          priorLastKey);\n+      FileMetadata[] contents \u003d listing.getFiles();\n+      if (!recursive \u0026\u0026 contents.length \u003e 0) {\n+        // The folder is non-empty and recursive delete was not specified.\n+        // Throw an exception indicating that a non-recursive delete was\n+        // specified for a non-empty folder.\n+        throw new IOException(\"Non-recursive delete of non-empty directory \"\n+            + f.toString());\n+      }\n+\n+      // Delete all the files in the folder.\n+      for (FileMetadata p : contents) {\n+        // Tag on the directory name found as the suffix of the suffix of the\n+        // parent directory to get the new absolute path.\n+        String suffix \u003d p.getKey().substring(\n+            p.getKey().lastIndexOf(PATH_DELIMITER));\n+        if (!p.isDir()) {\n+          store.delete(key + suffix);\n+        } else {\n+          // Recursively delete contents of the sub-folders. Notice this also\n+          // deletes the blob for the directory.\n+          if (!delete(new Path(f.toString() + suffix), true)) {\n+            return false;\n+          }\n+        }\n+      }\n+      store.delete(key);\n+\n+      // Update parent directory last modified time\n+      Path parent \u003d absolutePath.getParent();\n+      if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) { // not root\n+        String parentKey \u003d pathToKey(parent);\n+        store.updateFolderLastModifiedTime(parentKey);\n+      }\n+    }\n+\n+    // File or directory was successfully deleted.\n+    return true;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean delete(Path f, boolean recursive) throws IOException {\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Deleting file: \" + f.toString());\n    }\n\n    Path absolutePath \u003d makeAbsolute(f);\n    String key \u003d pathToKey(absolutePath);\n\n    // Capture the metadata for the path.\n    //\n    FileMetadata metaFile \u003d store.retrieveMetadata(key);\n\n    if (null \u003d\u003d metaFile) {\n      // The path to be deleted does not exist.\n      return false;\n    }\n\n    // The path exists, determine if it is a folder containing objects,\n    // an empty folder, or a simple file and take the appropriate actions.\n    if (!metaFile.isDir()) {\n      // The path specifies a file. We need to check the parent path\n      // to make sure it\u0027s a proper materialized directory before we\n      // delete the file. Otherwise we may get into a situation where\n      // the file we were deleting was the last one in an implicit directory\n      // (e.g. the blob store only contains the blob a/b and there\u0027s no\n      // corresponding directory blob a) and that would implicitly delete\n      // the directory as well, which is not correct.\n      Path parentPath \u003d absolutePath.getParent();\n      if (parentPath.getParent() !\u003d null) {// Not root\n        String parentKey \u003d pathToKey(parentPath);\n        FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n        if (!parentMetadata.isDir()) {\n          // Invalid state: the parent path is actually a file. Throw.\n          throw new AzureException(\"File \" + f + \" has a parent directory \"\n              + parentPath + \" which is also a file. Can\u0027t resolve.\");\n        }\n        if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Found an implicit parent directory while trying to\"\n                + \" delete the file \" + f + \". Creating the directory blob for\"\n                + \" it in \" + parentKey + \".\");\n          }\n          store.storeEmptyFolder(parentKey,\n              createPermissionStatus(FsPermission.getDefault()));\n        } else {\n          store.updateFolderLastModifiedTime(parentKey);\n        }\n      }\n      store.delete(key);\n    } else {\n      // The path specifies a folder. Recursively delete all entries under the\n      // folder.\n      Path parentPath \u003d absolutePath.getParent();\n      if (parentPath.getParent() !\u003d null) {\n        String parentKey \u003d pathToKey(parentPath);\n        FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n\n        if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Found an implicit parent directory while trying to\"\n                + \" delete the directory \" + f\n                + \". Creating the directory blob for\" + \" it in \" + parentKey\n                + \".\");\n          }\n          store.storeEmptyFolder(parentKey,\n              createPermissionStatus(FsPermission.getDefault()));\n        }\n      }\n\n      // List all the blobs in the current folder.\n      String priorLastKey \u003d null;\n      PartialListing listing \u003d store.listAll(key, AZURE_LIST_ALL, 1,\n          priorLastKey);\n      FileMetadata[] contents \u003d listing.getFiles();\n      if (!recursive \u0026\u0026 contents.length \u003e 0) {\n        // The folder is non-empty and recursive delete was not specified.\n        // Throw an exception indicating that a non-recursive delete was\n        // specified for a non-empty folder.\n        throw new IOException(\"Non-recursive delete of non-empty directory \"\n            + f.toString());\n      }\n\n      // Delete all the files in the folder.\n      for (FileMetadata p : contents) {\n        // Tag on the directory name found as the suffix of the suffix of the\n        // parent directory to get the new absolute path.\n        String suffix \u003d p.getKey().substring(\n            p.getKey().lastIndexOf(PATH_DELIMITER));\n        if (!p.isDir()) {\n          store.delete(key + suffix);\n        } else {\n          // Recursively delete contents of the sub-folders. Notice this also\n          // deletes the blob for the directory.\n          if (!delete(new Path(f.toString() + suffix), true)) {\n            return false;\n          }\n        }\n      }\n      store.delete(key);\n\n      // Update parent directory last modified time\n      Path parent \u003d absolutePath.getParent();\n      if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) { // not root\n        String parentKey \u003d pathToKey(parent);\n        store.updateFolderLastModifiedTime(parentKey);\n      }\n    }\n\n    // File or directory was successfully deleted.\n    return true;\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java"
    }
  }
}