{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "NodeManager.java",
  "functionName": "serviceInit",
  "functionId": "serviceInit___conf-Configuration",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java",
  "functionStartLine": 363,
  "functionEndLine": 496,
  "numCommitsSeen": 141,
  "timeTaken": 22963,
  "changeHistory": [
    "631dbbc6f2f7c1c9c61f036e96a5ece6608ed7fa",
    "0e22e9ab83438af37d821cb2f96e31f9a19ace2c",
    "4d3c580b03475a6ec9323d11e6875c542f8e3f6d",
    "9b54dd71863af58c2ef5f2194f5097626b8ef18a",
    "96e3027e46a953ca995e4b44ef50bc2a30c7e838",
    "3b3b6efe2103244febfe6b4f61989e92bd7bb08a",
    "363bd16e314490e31758cc82de584e75cd8357cc",
    "100470140d86eede0fa240a9aa93226f274ee4f5",
    "4bf622043f034835d65ff2a4785b9b06d0ef1fd2",
    "443523f9c0fcc4ba2503791090b1879c6031759b",
    "3d65dbe032e202361d613344ccc6d9c5f99ba395",
    "7f515f57ede74dae787994f37bfafd5d20c9aa4c",
    "0cc98ae0ec69419ded066f3f7decf59728b35e9d",
    "fa5cfc68f37c78b6cf26ce13247b9ff34da806cd",
    "dd43b895c2e50fa97cb7327be77509b87dad1823",
    "a59df15757fac7f917cb96fc8fcfeb7017475e4f",
    "2273a74c1f3895163046cca09ff5e983df301d22",
    "aa3cab1eb29c56368d15882d7260a994e615e8d8",
    "10be45986cdf86a89055065b752959bd6369d54f",
    "e6fcfe28e304062c7d09231db757acb2953703ce",
    "82c9e061017c32e633e0b0cbb7978749a6df4fb2",
    "89e5c44f9e891a3579384c3fa3766937cd4970f1",
    "5712b8f9fd1859fe046b482889239bd164ed7dab",
    "2188a07e5bea1da26bf679ca0ece26ab596d3438",
    "9b5636408005676ae580f8d929f8e912c27828e7",
    "0a5def155eff4564b5dc7685e7460952f51bbd24",
    "c282a08f3892e2e8ceb58e1e9a411062fbd1fb2b",
    "d284e187b8db43056236032ebc2114ee462c27f6",
    "65f395226ba6cc3750a268a308e288b916f8df1e",
    "5acdde4744c131e05db7b4b5f7d684fed7608b99",
    "13604bd5f119fc81b9942190dfa366afad61bc92",
    "cfee02b3bdd1117370200c9d8ce216676cff8888",
    "674c7ef64916fabbe59c8d6cdd50ca19cf7ddb7c",
    "2a945d24f7de1a7ae6e7bd6636188ce3b55c7f52",
    "d4ac6822e1c5dfac504ced48f10ab57a55b49e93",
    "2050e0dad661bade3e140d7a5692cfe1999badc3",
    "403ec8ea80d59f209823a7370dc8185fa2c1c368",
    "6d7dbd4fedd91a5177a2f0d90c5822394ab18529",
    "66598697a6e777615334ebde5ba7738135da83ae",
    "245012a9d9b0a21b8e93837e3e1a1892adcbf73c",
    "d3841bd4997a77855ab2abd9cc294eae7d795a5b",
    "a759abcd898224c3481c55aa7e424bc286f60b15",
    "3ca892dc0a24f95e9bbd00d3235ca6eb6b7fc329",
    "412e19f8e3118e602c567d60461e17c0dfe98b88",
    "f0eb4bc342370ec87d1f2665ffaf48ff4b3fbacb",
    "0928502029ef141759008997335ea2cd836a7154",
    "a83fb61ac07c0468cbc7a38526e92683883dd932",
    "2692675fc3b5046d2ec88542c30203c87e135b70",
    "ca8024673178fa1c80224b390dfba932921693d9",
    "fbb55784d93e1a819daf55d936e864d344579cbf",
    "2e3b56f6e907f15f7c6caaad37d37b9e0ee89963",
    "3e9200ddde4858be8ecdd8347b5fee63ed83df84",
    "6a482a88b8f56a4c5590e71ce6713d7f63830e92",
    "2cd41855d51fd18955a1ab187900ba02c6a6cfa9",
    "235749a8ab5f303b5b3a2993da8c5bea1818183b",
    "ffd2e01604be814fa3db1dded7cd7cff26a79b1e",
    "e1fdf62123625e4ba399af02f8aad500637d29d1",
    "3bfb26ad3b5ac46f992a632541c97ca2bc897638",
    "5ee495e6f34faff231ad87ec890188eb63617393",
    "ea17da82f7fc4b7fcc05bba82d141e27289fd7cb",
    "c56e05196190f172e9c8cdcd9d59d09950f1419b",
    "cbdb07f4ca358b9507296868a913977ad82ed716",
    "df2991c0cbc3f35c2640b93680667507c4f810dd",
    "4ba2acf3363bdfd7fcdd9de496cd57f8af6f03ad",
    "6b2f2efe4de4e709a2b9c64b7b3b3138e1939668",
    "fafe8cd28e726566509c679e19d7da622f29f90d",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517"
  ],
  "changeHistoryShort": {
    "631dbbc6f2f7c1c9c61f036e96a5ece6608ed7fa": "Ybodychange",
    "0e22e9ab83438af37d821cb2f96e31f9a19ace2c": "Ybodychange",
    "4d3c580b03475a6ec9323d11e6875c542f8e3f6d": "Ybodychange",
    "9b54dd71863af58c2ef5f2194f5097626b8ef18a": "Ybodychange",
    "96e3027e46a953ca995e4b44ef50bc2a30c7e838": "Ybodychange",
    "3b3b6efe2103244febfe6b4f61989e92bd7bb08a": "Ybodychange",
    "363bd16e314490e31758cc82de584e75cd8357cc": "Ybodychange",
    "100470140d86eede0fa240a9aa93226f274ee4f5": "Ybodychange",
    "4bf622043f034835d65ff2a4785b9b06d0ef1fd2": "Ybodychange",
    "443523f9c0fcc4ba2503791090b1879c6031759b": "Ybodychange",
    "3d65dbe032e202361d613344ccc6d9c5f99ba395": "Ybodychange",
    "7f515f57ede74dae787994f37bfafd5d20c9aa4c": "Ybodychange",
    "0cc98ae0ec69419ded066f3f7decf59728b35e9d": "Ybodychange",
    "fa5cfc68f37c78b6cf26ce13247b9ff34da806cd": "Ybodychange",
    "dd43b895c2e50fa97cb7327be77509b87dad1823": "Ybodychange",
    "a59df15757fac7f917cb96fc8fcfeb7017475e4f": "Ybodychange",
    "2273a74c1f3895163046cca09ff5e983df301d22": "Ybodychange",
    "aa3cab1eb29c56368d15882d7260a994e615e8d8": "Ybodychange",
    "10be45986cdf86a89055065b752959bd6369d54f": "Ybodychange",
    "e6fcfe28e304062c7d09231db757acb2953703ce": "Ybodychange",
    "82c9e061017c32e633e0b0cbb7978749a6df4fb2": "Ybodychange",
    "89e5c44f9e891a3579384c3fa3766937cd4970f1": "Ybodychange",
    "5712b8f9fd1859fe046b482889239bd164ed7dab": "Ybodychange",
    "2188a07e5bea1da26bf679ca0ece26ab596d3438": "Ybodychange",
    "9b5636408005676ae580f8d929f8e912c27828e7": "Ybodychange",
    "0a5def155eff4564b5dc7685e7460952f51bbd24": "Ybodychange",
    "c282a08f3892e2e8ceb58e1e9a411062fbd1fb2b": "Ybodychange",
    "d284e187b8db43056236032ebc2114ee462c27f6": "Ybodychange",
    "65f395226ba6cc3750a268a308e288b916f8df1e": "Ybodychange",
    "5acdde4744c131e05db7b4b5f7d684fed7608b99": "Ybodychange",
    "13604bd5f119fc81b9942190dfa366afad61bc92": "Ybodychange",
    "cfee02b3bdd1117370200c9d8ce216676cff8888": "Ybodychange",
    "674c7ef64916fabbe59c8d6cdd50ca19cf7ddb7c": "Ybodychange",
    "2a945d24f7de1a7ae6e7bd6636188ce3b55c7f52": "Ybodychange",
    "d4ac6822e1c5dfac504ced48f10ab57a55b49e93": "Ybodychange",
    "2050e0dad661bade3e140d7a5692cfe1999badc3": "Ybodychange",
    "403ec8ea80d59f209823a7370dc8185fa2c1c368": "Ybodychange",
    "6d7dbd4fedd91a5177a2f0d90c5822394ab18529": "Ybodychange",
    "66598697a6e777615334ebde5ba7738135da83ae": "Ybodychange",
    "245012a9d9b0a21b8e93837e3e1a1892adcbf73c": "Ybodychange",
    "d3841bd4997a77855ab2abd9cc294eae7d795a5b": "Ybodychange",
    "a759abcd898224c3481c55aa7e424bc286f60b15": "Ybodychange",
    "3ca892dc0a24f95e9bbd00d3235ca6eb6b7fc329": "Ybodychange",
    "412e19f8e3118e602c567d60461e17c0dfe98b88": "Ybodychange",
    "f0eb4bc342370ec87d1f2665ffaf48ff4b3fbacb": "Ybodychange",
    "0928502029ef141759008997335ea2cd836a7154": "Ymultichange(Yrename,Ymodifierchange,Yexceptionschange,Ybodychange)",
    "a83fb61ac07c0468cbc7a38526e92683883dd932": "Ybodychange",
    "2692675fc3b5046d2ec88542c30203c87e135b70": "Ybodychange",
    "ca8024673178fa1c80224b390dfba932921693d9": "Ybodychange",
    "fbb55784d93e1a819daf55d936e864d344579cbf": "Ybodychange",
    "2e3b56f6e907f15f7c6caaad37d37b9e0ee89963": "Ybodychange",
    "3e9200ddde4858be8ecdd8347b5fee63ed83df84": "Ybodychange",
    "6a482a88b8f56a4c5590e71ce6713d7f63830e92": "Ybodychange",
    "2cd41855d51fd18955a1ab187900ba02c6a6cfa9": "Ybodychange",
    "235749a8ab5f303b5b3a2993da8c5bea1818183b": "Ybodychange",
    "ffd2e01604be814fa3db1dded7cd7cff26a79b1e": "Ybodychange",
    "e1fdf62123625e4ba399af02f8aad500637d29d1": "Yfilerename",
    "3bfb26ad3b5ac46f992a632541c97ca2bc897638": "Ybodychange",
    "5ee495e6f34faff231ad87ec890188eb63617393": "Ybodychange",
    "ea17da82f7fc4b7fcc05bba82d141e27289fd7cb": "Ybodychange",
    "c56e05196190f172e9c8cdcd9d59d09950f1419b": "Ybodychange",
    "cbdb07f4ca358b9507296868a913977ad82ed716": "Ybodychange",
    "df2991c0cbc3f35c2640b93680667507c4f810dd": "Ybodychange",
    "4ba2acf3363bdfd7fcdd9de496cd57f8af6f03ad": "Ybodychange",
    "6b2f2efe4de4e709a2b9c64b7b3b3138e1939668": "Ybodychange",
    "fafe8cd28e726566509c679e19d7da622f29f90d": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": "Yintroduced"
  },
  "changeHistoryDetails": {
    "631dbbc6f2f7c1c9c61f036e96a5ece6608ed7fa": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9923. Introduce HealthReporter interface to support multiple health checker files. Contributed by Adam Antal\n",
      "commitDate": "15/12/19 8:28 AM",
      "commitName": "631dbbc6f2f7c1c9c61f036e96a5ece6608ed7fa",
      "commitAuthor": "Szilard Nemeth",
      "commitDateOld": "18/11/19 1:56 PM",
      "commitNameOld": "0e22e9ab83438af37d821cb2f96e31f9a19ace2c",
      "commitAuthorOld": "Eric Badger",
      "daysBetweenCommits": 26.77,
      "commitsBetweenForRepo": 110,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,137 +1,134 @@\n   protected void serviceInit(Configuration conf) throws Exception {\n     UserGroupInformation.setConfiguration(conf);\n     rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n             .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n         YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n \n     try {\n       initAndStartRecoveryStore(conf);\n     } catch (IOException e) {\n       String recoveryDirName \u003d conf.get(YarnConfiguration.NM_RECOVERY_DIR);\n       throw new\n           YarnRuntimeException(\"Unable to initialize recovery directory at \"\n               + recoveryDirName, e);\n     }\n \n     NMContainerTokenSecretManager containerTokenSecretManager \u003d\n         new NMContainerTokenSecretManager(conf, nmStore);\n \n     NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n         new NMTokenSecretManagerInNM(nmStore);\n \n     recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n     \n     this.aclsManager \u003d new ApplicationACLsManager(conf);\n \n     this.dirsHandler \u003d new LocalDirsHandlerService(metrics);\n \n     boolean isDistSchedulingEnabled \u003d\n         conf.getBoolean(YarnConfiguration.DIST_SCHEDULING_ENABLED,\n             YarnConfiguration.DEFAULT_DIST_SCHEDULING_ENABLED);\n \n     this.context \u003d createNMContext(containerTokenSecretManager,\n         nmTokenSecretManager, nmStore, isDistSchedulingEnabled, conf);\n \n     ResourcePluginManager pluginManager \u003d createResourcePluginManager();\n     pluginManager.initialize(context);\n     ((NMContext)context).setResourcePluginManager(pluginManager);\n \n     ContainerExecutor exec \u003d createContainerExecutor(conf);\n     try {\n       exec.init(context);\n     } catch (IOException e) {\n       throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n     }\n     DeletionService del \u003d createDeletionService(exec);\n     addService(del);\n \n     // NodeManager level dispatcher\n     this.dispatcher \u003d createNMDispatcher();\n \n-    nodeHealthChecker \u003d\n-        new NodeHealthCheckerService(\n-            getNodeHealthScriptRunner(conf), dirsHandler);\n+    this.nodeHealthChecker \u003d new NodeHealthCheckerService(dirsHandler);\n     addService(nodeHealthChecker);\n \n-\n     ((NMContext)context).setContainerExecutor(exec);\n     ((NMContext)context).setDeletionService(del);\n \n     nodeStatusUpdater \u003d\n         createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n \n     nodeLabelsProvider \u003d createNodeLabelsProvider(conf);\n     if (nodeLabelsProvider !\u003d null) {\n       addIfService(nodeLabelsProvider);\n       nodeStatusUpdater.setNodeLabelsProvider(nodeLabelsProvider);\n     }\n \n     nodeAttributesProvider \u003d createNodeAttributesProvider(conf);\n     if (nodeAttributesProvider !\u003d null) {\n       addIfService(nodeAttributesProvider);\n       nodeStatusUpdater.setNodeAttributesProvider(nodeAttributesProvider);\n     }\n \n     nodeResourceMonitor \u003d createNodeResourceMonitor();\n     addService(nodeResourceMonitor);\n     ((NMContext) context).setNodeResourceMonitor(nodeResourceMonitor);\n \n     containerManager \u003d\n         createContainerManager(context, exec, del, nodeStatusUpdater,\n         this.aclsManager, dirsHandler);\n     addService(containerManager);\n     ((NMContext) context).setContainerManager(containerManager);\n \n     this.nmLogAggregationStatusTracker \u003d createNMLogAggregationStatusTracker(\n         context);\n     addService(nmLogAggregationStatusTracker);\n     ((NMContext)context).setNMLogAggregationStatusTracker(\n         this.nmLogAggregationStatusTracker);\n \n     WebServer webServer \u003d createWebServer(context, containerManager\n         .getContainersMonitor(), this.aclsManager, dirsHandler);\n     addService(webServer);\n     ((NMContext) context).setWebServer(webServer);\n     int maxAllocationsPerAMHeartbeat \u003d conf.getInt(\n         YarnConfiguration.OPP_CONTAINER_MAX_ALLOCATIONS_PER_AM_HEARTBEAT,\n         YarnConfiguration.\n             DEFAULT_OPP_CONTAINER_MAX_ALLOCATIONS_PER_AM_HEARTBEAT);\n     ((NMContext) context).setQueueableContainerAllocator(\n         new DistributedOpportunisticContainerAllocator(\n             context.getContainerTokenSecretManager(),\n             maxAllocationsPerAMHeartbeat));\n \n     dispatcher.register(ContainerManagerEventType.class, containerManager);\n     dispatcher.register(NodeManagerEventType.class, this);\n     addService(dispatcher);\n \n     pauseMonitor \u003d new JvmPauseMonitor();\n     addService(pauseMonitor);\n     metrics.getJvmMetrics().setPauseMonitor(pauseMonitor);\n \n     DefaultMetricsSystem.initialize(\"NodeManager\");\n \n     if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n       this.nmCollectorService \u003d createNMCollectorService(context);\n       addService(nmCollectorService);\n     }\n \n     // StatusUpdater should be added last so that it get started last \n     // so that we make sure everything is up before registering with RM. \n     addService(nodeStatusUpdater);\n     ((NMContext) context).setNodeStatusUpdater(nodeStatusUpdater);\n     nmStore.setNodeStatusUpdater(nodeStatusUpdater);\n \n     // Do secure login before calling init for added services.\n     try {\n       doSecureLogin();\n     } catch (IOException e) {\n       throw new YarnRuntimeException(\"Failed NodeManager login\", e);\n     }\n \n     registerMXBean();\n \n     context.getContainerExecutor().start();\n     super.serviceInit(conf);\n     // TODO add local dirs to del\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceInit(Configuration conf) throws Exception {\n    UserGroupInformation.setConfiguration(conf);\n    rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n            .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n        YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n\n    try {\n      initAndStartRecoveryStore(conf);\n    } catch (IOException e) {\n      String recoveryDirName \u003d conf.get(YarnConfiguration.NM_RECOVERY_DIR);\n      throw new\n          YarnRuntimeException(\"Unable to initialize recovery directory at \"\n              + recoveryDirName, e);\n    }\n\n    NMContainerTokenSecretManager containerTokenSecretManager \u003d\n        new NMContainerTokenSecretManager(conf, nmStore);\n\n    NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n        new NMTokenSecretManagerInNM(nmStore);\n\n    recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n    \n    this.aclsManager \u003d new ApplicationACLsManager(conf);\n\n    this.dirsHandler \u003d new LocalDirsHandlerService(metrics);\n\n    boolean isDistSchedulingEnabled \u003d\n        conf.getBoolean(YarnConfiguration.DIST_SCHEDULING_ENABLED,\n            YarnConfiguration.DEFAULT_DIST_SCHEDULING_ENABLED);\n\n    this.context \u003d createNMContext(containerTokenSecretManager,\n        nmTokenSecretManager, nmStore, isDistSchedulingEnabled, conf);\n\n    ResourcePluginManager pluginManager \u003d createResourcePluginManager();\n    pluginManager.initialize(context);\n    ((NMContext)context).setResourcePluginManager(pluginManager);\n\n    ContainerExecutor exec \u003d createContainerExecutor(conf);\n    try {\n      exec.init(context);\n    } catch (IOException e) {\n      throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n    }\n    DeletionService del \u003d createDeletionService(exec);\n    addService(del);\n\n    // NodeManager level dispatcher\n    this.dispatcher \u003d createNMDispatcher();\n\n    this.nodeHealthChecker \u003d new NodeHealthCheckerService(dirsHandler);\n    addService(nodeHealthChecker);\n\n    ((NMContext)context).setContainerExecutor(exec);\n    ((NMContext)context).setDeletionService(del);\n\n    nodeStatusUpdater \u003d\n        createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n\n    nodeLabelsProvider \u003d createNodeLabelsProvider(conf);\n    if (nodeLabelsProvider !\u003d null) {\n      addIfService(nodeLabelsProvider);\n      nodeStatusUpdater.setNodeLabelsProvider(nodeLabelsProvider);\n    }\n\n    nodeAttributesProvider \u003d createNodeAttributesProvider(conf);\n    if (nodeAttributesProvider !\u003d null) {\n      addIfService(nodeAttributesProvider);\n      nodeStatusUpdater.setNodeAttributesProvider(nodeAttributesProvider);\n    }\n\n    nodeResourceMonitor \u003d createNodeResourceMonitor();\n    addService(nodeResourceMonitor);\n    ((NMContext) context).setNodeResourceMonitor(nodeResourceMonitor);\n\n    containerManager \u003d\n        createContainerManager(context, exec, del, nodeStatusUpdater,\n        this.aclsManager, dirsHandler);\n    addService(containerManager);\n    ((NMContext) context).setContainerManager(containerManager);\n\n    this.nmLogAggregationStatusTracker \u003d createNMLogAggregationStatusTracker(\n        context);\n    addService(nmLogAggregationStatusTracker);\n    ((NMContext)context).setNMLogAggregationStatusTracker(\n        this.nmLogAggregationStatusTracker);\n\n    WebServer webServer \u003d createWebServer(context, containerManager\n        .getContainersMonitor(), this.aclsManager, dirsHandler);\n    addService(webServer);\n    ((NMContext) context).setWebServer(webServer);\n    int maxAllocationsPerAMHeartbeat \u003d conf.getInt(\n        YarnConfiguration.OPP_CONTAINER_MAX_ALLOCATIONS_PER_AM_HEARTBEAT,\n        YarnConfiguration.\n            DEFAULT_OPP_CONTAINER_MAX_ALLOCATIONS_PER_AM_HEARTBEAT);\n    ((NMContext) context).setQueueableContainerAllocator(\n        new DistributedOpportunisticContainerAllocator(\n            context.getContainerTokenSecretManager(),\n            maxAllocationsPerAMHeartbeat));\n\n    dispatcher.register(ContainerManagerEventType.class, containerManager);\n    dispatcher.register(NodeManagerEventType.class, this);\n    addService(dispatcher);\n\n    pauseMonitor \u003d new JvmPauseMonitor();\n    addService(pauseMonitor);\n    metrics.getJvmMetrics().setPauseMonitor(pauseMonitor);\n\n    DefaultMetricsSystem.initialize(\"NodeManager\");\n\n    if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n      this.nmCollectorService \u003d createNMCollectorService(context);\n      addService(nmCollectorService);\n    }\n\n    // StatusUpdater should be added last so that it get started last \n    // so that we make sure everything is up before registering with RM. \n    addService(nodeStatusUpdater);\n    ((NMContext) context).setNodeStatusUpdater(nodeStatusUpdater);\n    nmStore.setNodeStatusUpdater(nodeStatusUpdater);\n\n    // Do secure login before calling init for added services.\n    try {\n      doSecureLogin();\n    } catch (IOException e) {\n      throw new YarnRuntimeException(\"Failed NodeManager login\", e);\n    }\n\n    registerMXBean();\n\n    context.getContainerExecutor().start();\n    super.serviceInit(conf);\n    // TODO add local dirs to del\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java",
      "extendedDetails": {}
    },
    "0e22e9ab83438af37d821cb2f96e31f9a19ace2c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9562. Add Java changes for the new RuncContainerRuntime. Contributed by Eric Badger\n",
      "commitDate": "18/11/19 1:56 PM",
      "commitName": "0e22e9ab83438af37d821cb2f96e31f9a19ace2c",
      "commitAuthor": "Eric Badger",
      "commitDateOld": "30/09/19 11:10 AM",
      "commitNameOld": "4d3c580b03475a6ec9323d11e6875c542f8e3f6d",
      "commitAuthorOld": "Abhishek Modi",
      "daysBetweenCommits": 49.16,
      "commitsBetweenForRepo": 238,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,136 +1,137 @@\n   protected void serviceInit(Configuration conf) throws Exception {\n     UserGroupInformation.setConfiguration(conf);\n     rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n             .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n         YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n \n     try {\n       initAndStartRecoveryStore(conf);\n     } catch (IOException e) {\n       String recoveryDirName \u003d conf.get(YarnConfiguration.NM_RECOVERY_DIR);\n       throw new\n           YarnRuntimeException(\"Unable to initialize recovery directory at \"\n               + recoveryDirName, e);\n     }\n \n     NMContainerTokenSecretManager containerTokenSecretManager \u003d\n         new NMContainerTokenSecretManager(conf, nmStore);\n \n     NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n         new NMTokenSecretManagerInNM(nmStore);\n \n     recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n     \n     this.aclsManager \u003d new ApplicationACLsManager(conf);\n \n     this.dirsHandler \u003d new LocalDirsHandlerService(metrics);\n \n     boolean isDistSchedulingEnabled \u003d\n         conf.getBoolean(YarnConfiguration.DIST_SCHEDULING_ENABLED,\n             YarnConfiguration.DEFAULT_DIST_SCHEDULING_ENABLED);\n \n     this.context \u003d createNMContext(containerTokenSecretManager,\n         nmTokenSecretManager, nmStore, isDistSchedulingEnabled, conf);\n \n     ResourcePluginManager pluginManager \u003d createResourcePluginManager();\n     pluginManager.initialize(context);\n     ((NMContext)context).setResourcePluginManager(pluginManager);\n \n     ContainerExecutor exec \u003d createContainerExecutor(conf);\n     try {\n       exec.init(context);\n     } catch (IOException e) {\n       throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n-    }    \n+    }\n     DeletionService del \u003d createDeletionService(exec);\n     addService(del);\n \n     // NodeManager level dispatcher\n     this.dispatcher \u003d createNMDispatcher();\n \n     nodeHealthChecker \u003d\n         new NodeHealthCheckerService(\n             getNodeHealthScriptRunner(conf), dirsHandler);\n     addService(nodeHealthChecker);\n \n \n     ((NMContext)context).setContainerExecutor(exec);\n     ((NMContext)context).setDeletionService(del);\n \n     nodeStatusUpdater \u003d\n         createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n \n     nodeLabelsProvider \u003d createNodeLabelsProvider(conf);\n     if (nodeLabelsProvider !\u003d null) {\n       addIfService(nodeLabelsProvider);\n       nodeStatusUpdater.setNodeLabelsProvider(nodeLabelsProvider);\n     }\n \n     nodeAttributesProvider \u003d createNodeAttributesProvider(conf);\n     if (nodeAttributesProvider !\u003d null) {\n       addIfService(nodeAttributesProvider);\n       nodeStatusUpdater.setNodeAttributesProvider(nodeAttributesProvider);\n     }\n \n     nodeResourceMonitor \u003d createNodeResourceMonitor();\n     addService(nodeResourceMonitor);\n     ((NMContext) context).setNodeResourceMonitor(nodeResourceMonitor);\n \n     containerManager \u003d\n         createContainerManager(context, exec, del, nodeStatusUpdater,\n         this.aclsManager, dirsHandler);\n     addService(containerManager);\n     ((NMContext) context).setContainerManager(containerManager);\n \n     this.nmLogAggregationStatusTracker \u003d createNMLogAggregationStatusTracker(\n         context);\n     addService(nmLogAggregationStatusTracker);\n     ((NMContext)context).setNMLogAggregationStatusTracker(\n         this.nmLogAggregationStatusTracker);\n \n     WebServer webServer \u003d createWebServer(context, containerManager\n         .getContainersMonitor(), this.aclsManager, dirsHandler);\n     addService(webServer);\n     ((NMContext) context).setWebServer(webServer);\n     int maxAllocationsPerAMHeartbeat \u003d conf.getInt(\n         YarnConfiguration.OPP_CONTAINER_MAX_ALLOCATIONS_PER_AM_HEARTBEAT,\n         YarnConfiguration.\n             DEFAULT_OPP_CONTAINER_MAX_ALLOCATIONS_PER_AM_HEARTBEAT);\n     ((NMContext) context).setQueueableContainerAllocator(\n         new DistributedOpportunisticContainerAllocator(\n             context.getContainerTokenSecretManager(),\n             maxAllocationsPerAMHeartbeat));\n \n     dispatcher.register(ContainerManagerEventType.class, containerManager);\n     dispatcher.register(NodeManagerEventType.class, this);\n     addService(dispatcher);\n \n     pauseMonitor \u003d new JvmPauseMonitor();\n     addService(pauseMonitor);\n     metrics.getJvmMetrics().setPauseMonitor(pauseMonitor);\n \n     DefaultMetricsSystem.initialize(\"NodeManager\");\n \n     if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n       this.nmCollectorService \u003d createNMCollectorService(context);\n       addService(nmCollectorService);\n     }\n \n     // StatusUpdater should be added last so that it get started last \n     // so that we make sure everything is up before registering with RM. \n     addService(nodeStatusUpdater);\n     ((NMContext) context).setNodeStatusUpdater(nodeStatusUpdater);\n     nmStore.setNodeStatusUpdater(nodeStatusUpdater);\n \n     // Do secure login before calling init for added services.\n     try {\n       doSecureLogin();\n     } catch (IOException e) {\n       throw new YarnRuntimeException(\"Failed NodeManager login\", e);\n     }\n \n     registerMXBean();\n \n+    context.getContainerExecutor().start();\n     super.serviceInit(conf);\n     // TODO add local dirs to del\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceInit(Configuration conf) throws Exception {\n    UserGroupInformation.setConfiguration(conf);\n    rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n            .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n        YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n\n    try {\n      initAndStartRecoveryStore(conf);\n    } catch (IOException e) {\n      String recoveryDirName \u003d conf.get(YarnConfiguration.NM_RECOVERY_DIR);\n      throw new\n          YarnRuntimeException(\"Unable to initialize recovery directory at \"\n              + recoveryDirName, e);\n    }\n\n    NMContainerTokenSecretManager containerTokenSecretManager \u003d\n        new NMContainerTokenSecretManager(conf, nmStore);\n\n    NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n        new NMTokenSecretManagerInNM(nmStore);\n\n    recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n    \n    this.aclsManager \u003d new ApplicationACLsManager(conf);\n\n    this.dirsHandler \u003d new LocalDirsHandlerService(metrics);\n\n    boolean isDistSchedulingEnabled \u003d\n        conf.getBoolean(YarnConfiguration.DIST_SCHEDULING_ENABLED,\n            YarnConfiguration.DEFAULT_DIST_SCHEDULING_ENABLED);\n\n    this.context \u003d createNMContext(containerTokenSecretManager,\n        nmTokenSecretManager, nmStore, isDistSchedulingEnabled, conf);\n\n    ResourcePluginManager pluginManager \u003d createResourcePluginManager();\n    pluginManager.initialize(context);\n    ((NMContext)context).setResourcePluginManager(pluginManager);\n\n    ContainerExecutor exec \u003d createContainerExecutor(conf);\n    try {\n      exec.init(context);\n    } catch (IOException e) {\n      throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n    }\n    DeletionService del \u003d createDeletionService(exec);\n    addService(del);\n\n    // NodeManager level dispatcher\n    this.dispatcher \u003d createNMDispatcher();\n\n    nodeHealthChecker \u003d\n        new NodeHealthCheckerService(\n            getNodeHealthScriptRunner(conf), dirsHandler);\n    addService(nodeHealthChecker);\n\n\n    ((NMContext)context).setContainerExecutor(exec);\n    ((NMContext)context).setDeletionService(del);\n\n    nodeStatusUpdater \u003d\n        createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n\n    nodeLabelsProvider \u003d createNodeLabelsProvider(conf);\n    if (nodeLabelsProvider !\u003d null) {\n      addIfService(nodeLabelsProvider);\n      nodeStatusUpdater.setNodeLabelsProvider(nodeLabelsProvider);\n    }\n\n    nodeAttributesProvider \u003d createNodeAttributesProvider(conf);\n    if (nodeAttributesProvider !\u003d null) {\n      addIfService(nodeAttributesProvider);\n      nodeStatusUpdater.setNodeAttributesProvider(nodeAttributesProvider);\n    }\n\n    nodeResourceMonitor \u003d createNodeResourceMonitor();\n    addService(nodeResourceMonitor);\n    ((NMContext) context).setNodeResourceMonitor(nodeResourceMonitor);\n\n    containerManager \u003d\n        createContainerManager(context, exec, del, nodeStatusUpdater,\n        this.aclsManager, dirsHandler);\n    addService(containerManager);\n    ((NMContext) context).setContainerManager(containerManager);\n\n    this.nmLogAggregationStatusTracker \u003d createNMLogAggregationStatusTracker(\n        context);\n    addService(nmLogAggregationStatusTracker);\n    ((NMContext)context).setNMLogAggregationStatusTracker(\n        this.nmLogAggregationStatusTracker);\n\n    WebServer webServer \u003d createWebServer(context, containerManager\n        .getContainersMonitor(), this.aclsManager, dirsHandler);\n    addService(webServer);\n    ((NMContext) context).setWebServer(webServer);\n    int maxAllocationsPerAMHeartbeat \u003d conf.getInt(\n        YarnConfiguration.OPP_CONTAINER_MAX_ALLOCATIONS_PER_AM_HEARTBEAT,\n        YarnConfiguration.\n            DEFAULT_OPP_CONTAINER_MAX_ALLOCATIONS_PER_AM_HEARTBEAT);\n    ((NMContext) context).setQueueableContainerAllocator(\n        new DistributedOpportunisticContainerAllocator(\n            context.getContainerTokenSecretManager(),\n            maxAllocationsPerAMHeartbeat));\n\n    dispatcher.register(ContainerManagerEventType.class, containerManager);\n    dispatcher.register(NodeManagerEventType.class, this);\n    addService(dispatcher);\n\n    pauseMonitor \u003d new JvmPauseMonitor();\n    addService(pauseMonitor);\n    metrics.getJvmMetrics().setPauseMonitor(pauseMonitor);\n\n    DefaultMetricsSystem.initialize(\"NodeManager\");\n\n    if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n      this.nmCollectorService \u003d createNMCollectorService(context);\n      addService(nmCollectorService);\n    }\n\n    // StatusUpdater should be added last so that it get started last \n    // so that we make sure everything is up before registering with RM. \n    addService(nodeStatusUpdater);\n    ((NMContext) context).setNodeStatusUpdater(nodeStatusUpdater);\n    nmStore.setNodeStatusUpdater(nodeStatusUpdater);\n\n    // Do secure login before calling init for added services.\n    try {\n      doSecureLogin();\n    } catch (IOException e) {\n      throw new YarnRuntimeException(\"Failed NodeManager login\", e);\n    }\n\n    registerMXBean();\n\n    context.getContainerExecutor().start();\n    super.serviceInit(conf);\n    // TODO add local dirs to del\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java",
      "extendedDetails": {}
    },
    "4d3c580b03475a6ec9323d11e6875c542f8e3f6d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9859. Refactoring of OpportunisticContainerAllocator. Contributed by Abhishek Modi.\n",
      "commitDate": "30/09/19 11:10 AM",
      "commitName": "4d3c580b03475a6ec9323d11e6875c542f8e3f6d",
      "commitAuthor": "Abhishek Modi",
      "commitDateOld": "11/07/19 1:57 PM",
      "commitNameOld": "9b54dd71863af58c2ef5f2194f5097626b8ef18a",
      "commitAuthorOld": "Haibo Chen",
      "daysBetweenCommits": 80.88,
      "commitsBetweenForRepo": 705,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,136 +1,136 @@\n   protected void serviceInit(Configuration conf) throws Exception {\n     UserGroupInformation.setConfiguration(conf);\n     rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n             .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n         YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n \n     try {\n       initAndStartRecoveryStore(conf);\n     } catch (IOException e) {\n       String recoveryDirName \u003d conf.get(YarnConfiguration.NM_RECOVERY_DIR);\n       throw new\n           YarnRuntimeException(\"Unable to initialize recovery directory at \"\n               + recoveryDirName, e);\n     }\n \n     NMContainerTokenSecretManager containerTokenSecretManager \u003d\n         new NMContainerTokenSecretManager(conf, nmStore);\n \n     NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n         new NMTokenSecretManagerInNM(nmStore);\n \n     recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n     \n     this.aclsManager \u003d new ApplicationACLsManager(conf);\n \n     this.dirsHandler \u003d new LocalDirsHandlerService(metrics);\n \n     boolean isDistSchedulingEnabled \u003d\n         conf.getBoolean(YarnConfiguration.DIST_SCHEDULING_ENABLED,\n             YarnConfiguration.DEFAULT_DIST_SCHEDULING_ENABLED);\n \n     this.context \u003d createNMContext(containerTokenSecretManager,\n         nmTokenSecretManager, nmStore, isDistSchedulingEnabled, conf);\n \n     ResourcePluginManager pluginManager \u003d createResourcePluginManager();\n     pluginManager.initialize(context);\n     ((NMContext)context).setResourcePluginManager(pluginManager);\n \n     ContainerExecutor exec \u003d createContainerExecutor(conf);\n     try {\n       exec.init(context);\n     } catch (IOException e) {\n       throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n     }    \n     DeletionService del \u003d createDeletionService(exec);\n     addService(del);\n \n     // NodeManager level dispatcher\n     this.dispatcher \u003d createNMDispatcher();\n \n     nodeHealthChecker \u003d\n         new NodeHealthCheckerService(\n             getNodeHealthScriptRunner(conf), dirsHandler);\n     addService(nodeHealthChecker);\n \n \n     ((NMContext)context).setContainerExecutor(exec);\n     ((NMContext)context).setDeletionService(del);\n \n     nodeStatusUpdater \u003d\n         createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n \n     nodeLabelsProvider \u003d createNodeLabelsProvider(conf);\n     if (nodeLabelsProvider !\u003d null) {\n       addIfService(nodeLabelsProvider);\n       nodeStatusUpdater.setNodeLabelsProvider(nodeLabelsProvider);\n     }\n \n     nodeAttributesProvider \u003d createNodeAttributesProvider(conf);\n     if (nodeAttributesProvider !\u003d null) {\n       addIfService(nodeAttributesProvider);\n       nodeStatusUpdater.setNodeAttributesProvider(nodeAttributesProvider);\n     }\n \n     nodeResourceMonitor \u003d createNodeResourceMonitor();\n     addService(nodeResourceMonitor);\n     ((NMContext) context).setNodeResourceMonitor(nodeResourceMonitor);\n \n     containerManager \u003d\n         createContainerManager(context, exec, del, nodeStatusUpdater,\n         this.aclsManager, dirsHandler);\n     addService(containerManager);\n     ((NMContext) context).setContainerManager(containerManager);\n \n     this.nmLogAggregationStatusTracker \u003d createNMLogAggregationStatusTracker(\n         context);\n     addService(nmLogAggregationStatusTracker);\n     ((NMContext)context).setNMLogAggregationStatusTracker(\n         this.nmLogAggregationStatusTracker);\n \n     WebServer webServer \u003d createWebServer(context, containerManager\n         .getContainersMonitor(), this.aclsManager, dirsHandler);\n     addService(webServer);\n     ((NMContext) context).setWebServer(webServer);\n     int maxAllocationsPerAMHeartbeat \u003d conf.getInt(\n         YarnConfiguration.OPP_CONTAINER_MAX_ALLOCATIONS_PER_AM_HEARTBEAT,\n         YarnConfiguration.\n             DEFAULT_OPP_CONTAINER_MAX_ALLOCATIONS_PER_AM_HEARTBEAT);\n     ((NMContext) context).setQueueableContainerAllocator(\n-        new OpportunisticContainerAllocator(\n+        new DistributedOpportunisticContainerAllocator(\n             context.getContainerTokenSecretManager(),\n             maxAllocationsPerAMHeartbeat));\n \n     dispatcher.register(ContainerManagerEventType.class, containerManager);\n     dispatcher.register(NodeManagerEventType.class, this);\n     addService(dispatcher);\n \n     pauseMonitor \u003d new JvmPauseMonitor();\n     addService(pauseMonitor);\n     metrics.getJvmMetrics().setPauseMonitor(pauseMonitor);\n \n     DefaultMetricsSystem.initialize(\"NodeManager\");\n \n     if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n       this.nmCollectorService \u003d createNMCollectorService(context);\n       addService(nmCollectorService);\n     }\n \n     // StatusUpdater should be added last so that it get started last \n     // so that we make sure everything is up before registering with RM. \n     addService(nodeStatusUpdater);\n     ((NMContext) context).setNodeStatusUpdater(nodeStatusUpdater);\n     nmStore.setNodeStatusUpdater(nodeStatusUpdater);\n \n     // Do secure login before calling init for added services.\n     try {\n       doSecureLogin();\n     } catch (IOException e) {\n       throw new YarnRuntimeException(\"Failed NodeManager login\", e);\n     }\n \n     registerMXBean();\n \n     super.serviceInit(conf);\n     // TODO add local dirs to del\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceInit(Configuration conf) throws Exception {\n    UserGroupInformation.setConfiguration(conf);\n    rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n            .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n        YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n\n    try {\n      initAndStartRecoveryStore(conf);\n    } catch (IOException e) {\n      String recoveryDirName \u003d conf.get(YarnConfiguration.NM_RECOVERY_DIR);\n      throw new\n          YarnRuntimeException(\"Unable to initialize recovery directory at \"\n              + recoveryDirName, e);\n    }\n\n    NMContainerTokenSecretManager containerTokenSecretManager \u003d\n        new NMContainerTokenSecretManager(conf, nmStore);\n\n    NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n        new NMTokenSecretManagerInNM(nmStore);\n\n    recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n    \n    this.aclsManager \u003d new ApplicationACLsManager(conf);\n\n    this.dirsHandler \u003d new LocalDirsHandlerService(metrics);\n\n    boolean isDistSchedulingEnabled \u003d\n        conf.getBoolean(YarnConfiguration.DIST_SCHEDULING_ENABLED,\n            YarnConfiguration.DEFAULT_DIST_SCHEDULING_ENABLED);\n\n    this.context \u003d createNMContext(containerTokenSecretManager,\n        nmTokenSecretManager, nmStore, isDistSchedulingEnabled, conf);\n\n    ResourcePluginManager pluginManager \u003d createResourcePluginManager();\n    pluginManager.initialize(context);\n    ((NMContext)context).setResourcePluginManager(pluginManager);\n\n    ContainerExecutor exec \u003d createContainerExecutor(conf);\n    try {\n      exec.init(context);\n    } catch (IOException e) {\n      throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n    }    \n    DeletionService del \u003d createDeletionService(exec);\n    addService(del);\n\n    // NodeManager level dispatcher\n    this.dispatcher \u003d createNMDispatcher();\n\n    nodeHealthChecker \u003d\n        new NodeHealthCheckerService(\n            getNodeHealthScriptRunner(conf), dirsHandler);\n    addService(nodeHealthChecker);\n\n\n    ((NMContext)context).setContainerExecutor(exec);\n    ((NMContext)context).setDeletionService(del);\n\n    nodeStatusUpdater \u003d\n        createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n\n    nodeLabelsProvider \u003d createNodeLabelsProvider(conf);\n    if (nodeLabelsProvider !\u003d null) {\n      addIfService(nodeLabelsProvider);\n      nodeStatusUpdater.setNodeLabelsProvider(nodeLabelsProvider);\n    }\n\n    nodeAttributesProvider \u003d createNodeAttributesProvider(conf);\n    if (nodeAttributesProvider !\u003d null) {\n      addIfService(nodeAttributesProvider);\n      nodeStatusUpdater.setNodeAttributesProvider(nodeAttributesProvider);\n    }\n\n    nodeResourceMonitor \u003d createNodeResourceMonitor();\n    addService(nodeResourceMonitor);\n    ((NMContext) context).setNodeResourceMonitor(nodeResourceMonitor);\n\n    containerManager \u003d\n        createContainerManager(context, exec, del, nodeStatusUpdater,\n        this.aclsManager, dirsHandler);\n    addService(containerManager);\n    ((NMContext) context).setContainerManager(containerManager);\n\n    this.nmLogAggregationStatusTracker \u003d createNMLogAggregationStatusTracker(\n        context);\n    addService(nmLogAggregationStatusTracker);\n    ((NMContext)context).setNMLogAggregationStatusTracker(\n        this.nmLogAggregationStatusTracker);\n\n    WebServer webServer \u003d createWebServer(context, containerManager\n        .getContainersMonitor(), this.aclsManager, dirsHandler);\n    addService(webServer);\n    ((NMContext) context).setWebServer(webServer);\n    int maxAllocationsPerAMHeartbeat \u003d conf.getInt(\n        YarnConfiguration.OPP_CONTAINER_MAX_ALLOCATIONS_PER_AM_HEARTBEAT,\n        YarnConfiguration.\n            DEFAULT_OPP_CONTAINER_MAX_ALLOCATIONS_PER_AM_HEARTBEAT);\n    ((NMContext) context).setQueueableContainerAllocator(\n        new DistributedOpportunisticContainerAllocator(\n            context.getContainerTokenSecretManager(),\n            maxAllocationsPerAMHeartbeat));\n\n    dispatcher.register(ContainerManagerEventType.class, containerManager);\n    dispatcher.register(NodeManagerEventType.class, this);\n    addService(dispatcher);\n\n    pauseMonitor \u003d new JvmPauseMonitor();\n    addService(pauseMonitor);\n    metrics.getJvmMetrics().setPauseMonitor(pauseMonitor);\n\n    DefaultMetricsSystem.initialize(\"NodeManager\");\n\n    if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n      this.nmCollectorService \u003d createNMCollectorService(context);\n      addService(nmCollectorService);\n    }\n\n    // StatusUpdater should be added last so that it get started last \n    // so that we make sure everything is up before registering with RM. \n    addService(nodeStatusUpdater);\n    ((NMContext) context).setNodeStatusUpdater(nodeStatusUpdater);\n    nmStore.setNodeStatusUpdater(nodeStatusUpdater);\n\n    // Do secure login before calling init for added services.\n    try {\n      doSecureLogin();\n    } catch (IOException e) {\n      throw new YarnRuntimeException(\"Failed NodeManager login\", e);\n    }\n\n    registerMXBean();\n\n    super.serviceInit(conf);\n    // TODO add local dirs to del\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java",
      "extendedDetails": {}
    },
    "9b54dd71863af58c2ef5f2194f5097626b8ef18a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9668. UGI conf doesn\u0027t read user overridden configurations on RM and NM startup. (Contributed by Jonathan Hung)\n",
      "commitDate": "11/07/19 1:57 PM",
      "commitName": "9b54dd71863af58c2ef5f2194f5097626b8ef18a",
      "commitAuthor": "Haibo Chen",
      "commitDateOld": "02/06/19 11:09 PM",
      "commitNameOld": "4530f4500d308c9cefbcc5990769c04bd061ad87",
      "commitAuthorOld": "Weiwei Yang",
      "daysBetweenCommits": 38.62,
      "commitsBetweenForRepo": 335,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,135 +1,136 @@\n   protected void serviceInit(Configuration conf) throws Exception {\n+    UserGroupInformation.setConfiguration(conf);\n     rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n             .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n         YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n \n     try {\n       initAndStartRecoveryStore(conf);\n     } catch (IOException e) {\n       String recoveryDirName \u003d conf.get(YarnConfiguration.NM_RECOVERY_DIR);\n       throw new\n           YarnRuntimeException(\"Unable to initialize recovery directory at \"\n               + recoveryDirName, e);\n     }\n \n     NMContainerTokenSecretManager containerTokenSecretManager \u003d\n         new NMContainerTokenSecretManager(conf, nmStore);\n \n     NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n         new NMTokenSecretManagerInNM(nmStore);\n \n     recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n     \n     this.aclsManager \u003d new ApplicationACLsManager(conf);\n \n     this.dirsHandler \u003d new LocalDirsHandlerService(metrics);\n \n     boolean isDistSchedulingEnabled \u003d\n         conf.getBoolean(YarnConfiguration.DIST_SCHEDULING_ENABLED,\n             YarnConfiguration.DEFAULT_DIST_SCHEDULING_ENABLED);\n \n     this.context \u003d createNMContext(containerTokenSecretManager,\n         nmTokenSecretManager, nmStore, isDistSchedulingEnabled, conf);\n \n     ResourcePluginManager pluginManager \u003d createResourcePluginManager();\n     pluginManager.initialize(context);\n     ((NMContext)context).setResourcePluginManager(pluginManager);\n \n     ContainerExecutor exec \u003d createContainerExecutor(conf);\n     try {\n       exec.init(context);\n     } catch (IOException e) {\n       throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n     }    \n     DeletionService del \u003d createDeletionService(exec);\n     addService(del);\n \n     // NodeManager level dispatcher\n     this.dispatcher \u003d createNMDispatcher();\n \n     nodeHealthChecker \u003d\n         new NodeHealthCheckerService(\n             getNodeHealthScriptRunner(conf), dirsHandler);\n     addService(nodeHealthChecker);\n \n \n     ((NMContext)context).setContainerExecutor(exec);\n     ((NMContext)context).setDeletionService(del);\n \n     nodeStatusUpdater \u003d\n         createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n \n     nodeLabelsProvider \u003d createNodeLabelsProvider(conf);\n     if (nodeLabelsProvider !\u003d null) {\n       addIfService(nodeLabelsProvider);\n       nodeStatusUpdater.setNodeLabelsProvider(nodeLabelsProvider);\n     }\n \n     nodeAttributesProvider \u003d createNodeAttributesProvider(conf);\n     if (nodeAttributesProvider !\u003d null) {\n       addIfService(nodeAttributesProvider);\n       nodeStatusUpdater.setNodeAttributesProvider(nodeAttributesProvider);\n     }\n \n     nodeResourceMonitor \u003d createNodeResourceMonitor();\n     addService(nodeResourceMonitor);\n     ((NMContext) context).setNodeResourceMonitor(nodeResourceMonitor);\n \n     containerManager \u003d\n         createContainerManager(context, exec, del, nodeStatusUpdater,\n         this.aclsManager, dirsHandler);\n     addService(containerManager);\n     ((NMContext) context).setContainerManager(containerManager);\n \n     this.nmLogAggregationStatusTracker \u003d createNMLogAggregationStatusTracker(\n         context);\n     addService(nmLogAggregationStatusTracker);\n     ((NMContext)context).setNMLogAggregationStatusTracker(\n         this.nmLogAggregationStatusTracker);\n \n     WebServer webServer \u003d createWebServer(context, containerManager\n         .getContainersMonitor(), this.aclsManager, dirsHandler);\n     addService(webServer);\n     ((NMContext) context).setWebServer(webServer);\n     int maxAllocationsPerAMHeartbeat \u003d conf.getInt(\n         YarnConfiguration.OPP_CONTAINER_MAX_ALLOCATIONS_PER_AM_HEARTBEAT,\n         YarnConfiguration.\n             DEFAULT_OPP_CONTAINER_MAX_ALLOCATIONS_PER_AM_HEARTBEAT);\n     ((NMContext) context).setQueueableContainerAllocator(\n         new OpportunisticContainerAllocator(\n             context.getContainerTokenSecretManager(),\n             maxAllocationsPerAMHeartbeat));\n \n     dispatcher.register(ContainerManagerEventType.class, containerManager);\n     dispatcher.register(NodeManagerEventType.class, this);\n     addService(dispatcher);\n \n     pauseMonitor \u003d new JvmPauseMonitor();\n     addService(pauseMonitor);\n     metrics.getJvmMetrics().setPauseMonitor(pauseMonitor);\n \n     DefaultMetricsSystem.initialize(\"NodeManager\");\n \n     if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n       this.nmCollectorService \u003d createNMCollectorService(context);\n       addService(nmCollectorService);\n     }\n \n     // StatusUpdater should be added last so that it get started last \n     // so that we make sure everything is up before registering with RM. \n     addService(nodeStatusUpdater);\n     ((NMContext) context).setNodeStatusUpdater(nodeStatusUpdater);\n     nmStore.setNodeStatusUpdater(nodeStatusUpdater);\n \n     // Do secure login before calling init for added services.\n     try {\n       doSecureLogin();\n     } catch (IOException e) {\n       throw new YarnRuntimeException(\"Failed NodeManager login\", e);\n     }\n \n     registerMXBean();\n \n     super.serviceInit(conf);\n     // TODO add local dirs to del\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceInit(Configuration conf) throws Exception {\n    UserGroupInformation.setConfiguration(conf);\n    rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n            .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n        YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n\n    try {\n      initAndStartRecoveryStore(conf);\n    } catch (IOException e) {\n      String recoveryDirName \u003d conf.get(YarnConfiguration.NM_RECOVERY_DIR);\n      throw new\n          YarnRuntimeException(\"Unable to initialize recovery directory at \"\n              + recoveryDirName, e);\n    }\n\n    NMContainerTokenSecretManager containerTokenSecretManager \u003d\n        new NMContainerTokenSecretManager(conf, nmStore);\n\n    NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n        new NMTokenSecretManagerInNM(nmStore);\n\n    recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n    \n    this.aclsManager \u003d new ApplicationACLsManager(conf);\n\n    this.dirsHandler \u003d new LocalDirsHandlerService(metrics);\n\n    boolean isDistSchedulingEnabled \u003d\n        conf.getBoolean(YarnConfiguration.DIST_SCHEDULING_ENABLED,\n            YarnConfiguration.DEFAULT_DIST_SCHEDULING_ENABLED);\n\n    this.context \u003d createNMContext(containerTokenSecretManager,\n        nmTokenSecretManager, nmStore, isDistSchedulingEnabled, conf);\n\n    ResourcePluginManager pluginManager \u003d createResourcePluginManager();\n    pluginManager.initialize(context);\n    ((NMContext)context).setResourcePluginManager(pluginManager);\n\n    ContainerExecutor exec \u003d createContainerExecutor(conf);\n    try {\n      exec.init(context);\n    } catch (IOException e) {\n      throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n    }    \n    DeletionService del \u003d createDeletionService(exec);\n    addService(del);\n\n    // NodeManager level dispatcher\n    this.dispatcher \u003d createNMDispatcher();\n\n    nodeHealthChecker \u003d\n        new NodeHealthCheckerService(\n            getNodeHealthScriptRunner(conf), dirsHandler);\n    addService(nodeHealthChecker);\n\n\n    ((NMContext)context).setContainerExecutor(exec);\n    ((NMContext)context).setDeletionService(del);\n\n    nodeStatusUpdater \u003d\n        createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n\n    nodeLabelsProvider \u003d createNodeLabelsProvider(conf);\n    if (nodeLabelsProvider !\u003d null) {\n      addIfService(nodeLabelsProvider);\n      nodeStatusUpdater.setNodeLabelsProvider(nodeLabelsProvider);\n    }\n\n    nodeAttributesProvider \u003d createNodeAttributesProvider(conf);\n    if (nodeAttributesProvider !\u003d null) {\n      addIfService(nodeAttributesProvider);\n      nodeStatusUpdater.setNodeAttributesProvider(nodeAttributesProvider);\n    }\n\n    nodeResourceMonitor \u003d createNodeResourceMonitor();\n    addService(nodeResourceMonitor);\n    ((NMContext) context).setNodeResourceMonitor(nodeResourceMonitor);\n\n    containerManager \u003d\n        createContainerManager(context, exec, del, nodeStatusUpdater,\n        this.aclsManager, dirsHandler);\n    addService(containerManager);\n    ((NMContext) context).setContainerManager(containerManager);\n\n    this.nmLogAggregationStatusTracker \u003d createNMLogAggregationStatusTracker(\n        context);\n    addService(nmLogAggregationStatusTracker);\n    ((NMContext)context).setNMLogAggregationStatusTracker(\n        this.nmLogAggregationStatusTracker);\n\n    WebServer webServer \u003d createWebServer(context, containerManager\n        .getContainersMonitor(), this.aclsManager, dirsHandler);\n    addService(webServer);\n    ((NMContext) context).setWebServer(webServer);\n    int maxAllocationsPerAMHeartbeat \u003d conf.getInt(\n        YarnConfiguration.OPP_CONTAINER_MAX_ALLOCATIONS_PER_AM_HEARTBEAT,\n        YarnConfiguration.\n            DEFAULT_OPP_CONTAINER_MAX_ALLOCATIONS_PER_AM_HEARTBEAT);\n    ((NMContext) context).setQueueableContainerAllocator(\n        new OpportunisticContainerAllocator(\n            context.getContainerTokenSecretManager(),\n            maxAllocationsPerAMHeartbeat));\n\n    dispatcher.register(ContainerManagerEventType.class, containerManager);\n    dispatcher.register(NodeManagerEventType.class, this);\n    addService(dispatcher);\n\n    pauseMonitor \u003d new JvmPauseMonitor();\n    addService(pauseMonitor);\n    metrics.getJvmMetrics().setPauseMonitor(pauseMonitor);\n\n    DefaultMetricsSystem.initialize(\"NodeManager\");\n\n    if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n      this.nmCollectorService \u003d createNMCollectorService(context);\n      addService(nmCollectorService);\n    }\n\n    // StatusUpdater should be added last so that it get started last \n    // so that we make sure everything is up before registering with RM. \n    addService(nodeStatusUpdater);\n    ((NMContext) context).setNodeStatusUpdater(nodeStatusUpdater);\n    nmStore.setNodeStatusUpdater(nodeStatusUpdater);\n\n    // Do secure login before calling init for added services.\n    try {\n      doSecureLogin();\n    } catch (IOException e) {\n      throw new YarnRuntimeException(\"Failed NodeManager login\", e);\n    }\n\n    registerMXBean();\n\n    super.serviceInit(conf);\n    // TODO add local dirs to del\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java",
      "extendedDetails": {}
    },
    "96e3027e46a953ca995e4b44ef50bc2a30c7e838": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2889. Limit the number of opportunistic container allocated per AM heartbeat. Contributed by Abhishek Modi.\n",
      "commitDate": "22/04/19 9:49 AM",
      "commitName": "96e3027e46a953ca995e4b44ef50bc2a30c7e838",
      "commitAuthor": "Inigo Goiri",
      "commitDateOld": "15/03/19 4:20 PM",
      "commitNameOld": "2064ca015d1584263aac0cc20c60b925a3aff612",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 37.73,
      "commitsBetweenForRepo": 249,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,131 +1,135 @@\n   protected void serviceInit(Configuration conf) throws Exception {\n     rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n             .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n         YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n \n     try {\n       initAndStartRecoveryStore(conf);\n     } catch (IOException e) {\n       String recoveryDirName \u003d conf.get(YarnConfiguration.NM_RECOVERY_DIR);\n       throw new\n           YarnRuntimeException(\"Unable to initialize recovery directory at \"\n               + recoveryDirName, e);\n     }\n \n     NMContainerTokenSecretManager containerTokenSecretManager \u003d\n         new NMContainerTokenSecretManager(conf, nmStore);\n \n     NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n         new NMTokenSecretManagerInNM(nmStore);\n \n     recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n     \n     this.aclsManager \u003d new ApplicationACLsManager(conf);\n \n     this.dirsHandler \u003d new LocalDirsHandlerService(metrics);\n \n     boolean isDistSchedulingEnabled \u003d\n         conf.getBoolean(YarnConfiguration.DIST_SCHEDULING_ENABLED,\n             YarnConfiguration.DEFAULT_DIST_SCHEDULING_ENABLED);\n \n     this.context \u003d createNMContext(containerTokenSecretManager,\n         nmTokenSecretManager, nmStore, isDistSchedulingEnabled, conf);\n \n     ResourcePluginManager pluginManager \u003d createResourcePluginManager();\n     pluginManager.initialize(context);\n     ((NMContext)context).setResourcePluginManager(pluginManager);\n \n     ContainerExecutor exec \u003d createContainerExecutor(conf);\n     try {\n       exec.init(context);\n     } catch (IOException e) {\n       throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n     }    \n     DeletionService del \u003d createDeletionService(exec);\n     addService(del);\n \n     // NodeManager level dispatcher\n     this.dispatcher \u003d createNMDispatcher();\n \n     nodeHealthChecker \u003d\n         new NodeHealthCheckerService(\n             getNodeHealthScriptRunner(conf), dirsHandler);\n     addService(nodeHealthChecker);\n \n \n     ((NMContext)context).setContainerExecutor(exec);\n     ((NMContext)context).setDeletionService(del);\n \n     nodeStatusUpdater \u003d\n         createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n \n     nodeLabelsProvider \u003d createNodeLabelsProvider(conf);\n     if (nodeLabelsProvider !\u003d null) {\n       addIfService(nodeLabelsProvider);\n       nodeStatusUpdater.setNodeLabelsProvider(nodeLabelsProvider);\n     }\n \n     nodeAttributesProvider \u003d createNodeAttributesProvider(conf);\n     if (nodeAttributesProvider !\u003d null) {\n       addIfService(nodeAttributesProvider);\n       nodeStatusUpdater.setNodeAttributesProvider(nodeAttributesProvider);\n     }\n \n     nodeResourceMonitor \u003d createNodeResourceMonitor();\n     addService(nodeResourceMonitor);\n     ((NMContext) context).setNodeResourceMonitor(nodeResourceMonitor);\n \n     containerManager \u003d\n         createContainerManager(context, exec, del, nodeStatusUpdater,\n         this.aclsManager, dirsHandler);\n     addService(containerManager);\n     ((NMContext) context).setContainerManager(containerManager);\n \n     this.nmLogAggregationStatusTracker \u003d createNMLogAggregationStatusTracker(\n         context);\n     addService(nmLogAggregationStatusTracker);\n     ((NMContext)context).setNMLogAggregationStatusTracker(\n         this.nmLogAggregationStatusTracker);\n \n     WebServer webServer \u003d createWebServer(context, containerManager\n         .getContainersMonitor(), this.aclsManager, dirsHandler);\n     addService(webServer);\n     ((NMContext) context).setWebServer(webServer);\n-\n+    int maxAllocationsPerAMHeartbeat \u003d conf.getInt(\n+        YarnConfiguration.OPP_CONTAINER_MAX_ALLOCATIONS_PER_AM_HEARTBEAT,\n+        YarnConfiguration.\n+            DEFAULT_OPP_CONTAINER_MAX_ALLOCATIONS_PER_AM_HEARTBEAT);\n     ((NMContext) context).setQueueableContainerAllocator(\n         new OpportunisticContainerAllocator(\n-            context.getContainerTokenSecretManager()));\n+            context.getContainerTokenSecretManager(),\n+            maxAllocationsPerAMHeartbeat));\n \n     dispatcher.register(ContainerManagerEventType.class, containerManager);\n     dispatcher.register(NodeManagerEventType.class, this);\n     addService(dispatcher);\n \n     pauseMonitor \u003d new JvmPauseMonitor();\n     addService(pauseMonitor);\n     metrics.getJvmMetrics().setPauseMonitor(pauseMonitor);\n \n     DefaultMetricsSystem.initialize(\"NodeManager\");\n \n     if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n       this.nmCollectorService \u003d createNMCollectorService(context);\n       addService(nmCollectorService);\n     }\n \n     // StatusUpdater should be added last so that it get started last \n     // so that we make sure everything is up before registering with RM. \n     addService(nodeStatusUpdater);\n     ((NMContext) context).setNodeStatusUpdater(nodeStatusUpdater);\n     nmStore.setNodeStatusUpdater(nodeStatusUpdater);\n \n     // Do secure login before calling init for added services.\n     try {\n       doSecureLogin();\n     } catch (IOException e) {\n       throw new YarnRuntimeException(\"Failed NodeManager login\", e);\n     }\n \n     registerMXBean();\n \n     super.serviceInit(conf);\n     // TODO add local dirs to del\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceInit(Configuration conf) throws Exception {\n    rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n            .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n        YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n\n    try {\n      initAndStartRecoveryStore(conf);\n    } catch (IOException e) {\n      String recoveryDirName \u003d conf.get(YarnConfiguration.NM_RECOVERY_DIR);\n      throw new\n          YarnRuntimeException(\"Unable to initialize recovery directory at \"\n              + recoveryDirName, e);\n    }\n\n    NMContainerTokenSecretManager containerTokenSecretManager \u003d\n        new NMContainerTokenSecretManager(conf, nmStore);\n\n    NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n        new NMTokenSecretManagerInNM(nmStore);\n\n    recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n    \n    this.aclsManager \u003d new ApplicationACLsManager(conf);\n\n    this.dirsHandler \u003d new LocalDirsHandlerService(metrics);\n\n    boolean isDistSchedulingEnabled \u003d\n        conf.getBoolean(YarnConfiguration.DIST_SCHEDULING_ENABLED,\n            YarnConfiguration.DEFAULT_DIST_SCHEDULING_ENABLED);\n\n    this.context \u003d createNMContext(containerTokenSecretManager,\n        nmTokenSecretManager, nmStore, isDistSchedulingEnabled, conf);\n\n    ResourcePluginManager pluginManager \u003d createResourcePluginManager();\n    pluginManager.initialize(context);\n    ((NMContext)context).setResourcePluginManager(pluginManager);\n\n    ContainerExecutor exec \u003d createContainerExecutor(conf);\n    try {\n      exec.init(context);\n    } catch (IOException e) {\n      throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n    }    \n    DeletionService del \u003d createDeletionService(exec);\n    addService(del);\n\n    // NodeManager level dispatcher\n    this.dispatcher \u003d createNMDispatcher();\n\n    nodeHealthChecker \u003d\n        new NodeHealthCheckerService(\n            getNodeHealthScriptRunner(conf), dirsHandler);\n    addService(nodeHealthChecker);\n\n\n    ((NMContext)context).setContainerExecutor(exec);\n    ((NMContext)context).setDeletionService(del);\n\n    nodeStatusUpdater \u003d\n        createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n\n    nodeLabelsProvider \u003d createNodeLabelsProvider(conf);\n    if (nodeLabelsProvider !\u003d null) {\n      addIfService(nodeLabelsProvider);\n      nodeStatusUpdater.setNodeLabelsProvider(nodeLabelsProvider);\n    }\n\n    nodeAttributesProvider \u003d createNodeAttributesProvider(conf);\n    if (nodeAttributesProvider !\u003d null) {\n      addIfService(nodeAttributesProvider);\n      nodeStatusUpdater.setNodeAttributesProvider(nodeAttributesProvider);\n    }\n\n    nodeResourceMonitor \u003d createNodeResourceMonitor();\n    addService(nodeResourceMonitor);\n    ((NMContext) context).setNodeResourceMonitor(nodeResourceMonitor);\n\n    containerManager \u003d\n        createContainerManager(context, exec, del, nodeStatusUpdater,\n        this.aclsManager, dirsHandler);\n    addService(containerManager);\n    ((NMContext) context).setContainerManager(containerManager);\n\n    this.nmLogAggregationStatusTracker \u003d createNMLogAggregationStatusTracker(\n        context);\n    addService(nmLogAggregationStatusTracker);\n    ((NMContext)context).setNMLogAggregationStatusTracker(\n        this.nmLogAggregationStatusTracker);\n\n    WebServer webServer \u003d createWebServer(context, containerManager\n        .getContainersMonitor(), this.aclsManager, dirsHandler);\n    addService(webServer);\n    ((NMContext) context).setWebServer(webServer);\n    int maxAllocationsPerAMHeartbeat \u003d conf.getInt(\n        YarnConfiguration.OPP_CONTAINER_MAX_ALLOCATIONS_PER_AM_HEARTBEAT,\n        YarnConfiguration.\n            DEFAULT_OPP_CONTAINER_MAX_ALLOCATIONS_PER_AM_HEARTBEAT);\n    ((NMContext) context).setQueueableContainerAllocator(\n        new OpportunisticContainerAllocator(\n            context.getContainerTokenSecretManager(),\n            maxAllocationsPerAMHeartbeat));\n\n    dispatcher.register(ContainerManagerEventType.class, containerManager);\n    dispatcher.register(NodeManagerEventType.class, this);\n    addService(dispatcher);\n\n    pauseMonitor \u003d new JvmPauseMonitor();\n    addService(pauseMonitor);\n    metrics.getJvmMetrics().setPauseMonitor(pauseMonitor);\n\n    DefaultMetricsSystem.initialize(\"NodeManager\");\n\n    if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n      this.nmCollectorService \u003d createNMCollectorService(context);\n      addService(nmCollectorService);\n    }\n\n    // StatusUpdater should be added last so that it get started last \n    // so that we make sure everything is up before registering with RM. \n    addService(nodeStatusUpdater);\n    ((NMContext) context).setNodeStatusUpdater(nodeStatusUpdater);\n    nmStore.setNodeStatusUpdater(nodeStatusUpdater);\n\n    // Do secure login before calling init for added services.\n    try {\n      doSecureLogin();\n    } catch (IOException e) {\n      throw new YarnRuntimeException(\"Failed NodeManager login\", e);\n    }\n\n    registerMXBean();\n\n    super.serviceInit(conf);\n    // TODO add local dirs to del\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java",
      "extendedDetails": {}
    },
    "3b3b6efe2103244febfe6b4f61989e92bd7bb08a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7871. Node attributes reporting from NM to RM. Contributed by Weiwei Yang.\n",
      "commitDate": "12/09/18 3:31 AM",
      "commitName": "3b3b6efe2103244febfe6b4f61989e92bd7bb08a",
      "commitAuthor": "Naganarasimha",
      "commitDateOld": "14/08/18 5:19 PM",
      "commitNameOld": "363bd16e314490e31758cc82de584e75cd8357cc",
      "commitAuthorOld": "Wei-Chiu Chuang",
      "daysBetweenCommits": 28.43,
      "commitsBetweenForRepo": 188,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,128 +1,131 @@\n   protected void serviceInit(Configuration conf) throws Exception {\n     rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n             .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n         YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n \n     try {\n       initAndStartRecoveryStore(conf);\n     } catch (IOException e) {\n       String recoveryDirName \u003d conf.get(YarnConfiguration.NM_RECOVERY_DIR);\n       throw new\n           YarnRuntimeException(\"Unable to initialize recovery directory at \"\n               + recoveryDirName, e);\n     }\n \n     NMContainerTokenSecretManager containerTokenSecretManager \u003d\n         new NMContainerTokenSecretManager(conf, nmStore);\n \n     NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n         new NMTokenSecretManagerInNM(nmStore);\n \n     recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n     \n     this.aclsManager \u003d new ApplicationACLsManager(conf);\n \n     this.dirsHandler \u003d new LocalDirsHandlerService(metrics);\n \n     boolean isDistSchedulingEnabled \u003d\n         conf.getBoolean(YarnConfiguration.DIST_SCHEDULING_ENABLED,\n             YarnConfiguration.DEFAULT_DIST_SCHEDULING_ENABLED);\n \n     this.context \u003d createNMContext(containerTokenSecretManager,\n         nmTokenSecretManager, nmStore, isDistSchedulingEnabled, conf);\n \n     ResourcePluginManager pluginManager \u003d createResourcePluginManager();\n     pluginManager.initialize(context);\n     ((NMContext)context).setResourcePluginManager(pluginManager);\n \n     ContainerExecutor exec \u003d createContainerExecutor(conf);\n     try {\n       exec.init(context);\n     } catch (IOException e) {\n       throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n     }    \n     DeletionService del \u003d createDeletionService(exec);\n     addService(del);\n \n     // NodeManager level dispatcher\n     this.dispatcher \u003d createNMDispatcher();\n \n     nodeHealthChecker \u003d\n         new NodeHealthCheckerService(\n             getNodeHealthScriptRunner(conf), dirsHandler);\n     addService(nodeHealthChecker);\n \n \n     ((NMContext)context).setContainerExecutor(exec);\n     ((NMContext)context).setDeletionService(del);\n \n-    nodeLabelsProvider \u003d createNodeLabelsProvider(conf);\n+    nodeStatusUpdater \u003d\n+        createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n \n-    if (null \u003d\u003d nodeLabelsProvider) {\n-      nodeStatusUpdater \u003d\n-          createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n-    } else {\n+    nodeLabelsProvider \u003d createNodeLabelsProvider(conf);\n+    if (nodeLabelsProvider !\u003d null) {\n       addIfService(nodeLabelsProvider);\n-      nodeStatusUpdater \u003d\n-          createNodeStatusUpdater(context, dispatcher, nodeHealthChecker,\n-              nodeLabelsProvider);\n+      nodeStatusUpdater.setNodeLabelsProvider(nodeLabelsProvider);\n+    }\n+\n+    nodeAttributesProvider \u003d createNodeAttributesProvider(conf);\n+    if (nodeAttributesProvider !\u003d null) {\n+      addIfService(nodeAttributesProvider);\n+      nodeStatusUpdater.setNodeAttributesProvider(nodeAttributesProvider);\n     }\n \n     nodeResourceMonitor \u003d createNodeResourceMonitor();\n     addService(nodeResourceMonitor);\n     ((NMContext) context).setNodeResourceMonitor(nodeResourceMonitor);\n \n     containerManager \u003d\n         createContainerManager(context, exec, del, nodeStatusUpdater,\n         this.aclsManager, dirsHandler);\n     addService(containerManager);\n     ((NMContext) context).setContainerManager(containerManager);\n \n     this.nmLogAggregationStatusTracker \u003d createNMLogAggregationStatusTracker(\n         context);\n     addService(nmLogAggregationStatusTracker);\n     ((NMContext)context).setNMLogAggregationStatusTracker(\n         this.nmLogAggregationStatusTracker);\n \n     WebServer webServer \u003d createWebServer(context, containerManager\n         .getContainersMonitor(), this.aclsManager, dirsHandler);\n     addService(webServer);\n     ((NMContext) context).setWebServer(webServer);\n \n     ((NMContext) context).setQueueableContainerAllocator(\n         new OpportunisticContainerAllocator(\n             context.getContainerTokenSecretManager()));\n \n     dispatcher.register(ContainerManagerEventType.class, containerManager);\n     dispatcher.register(NodeManagerEventType.class, this);\n     addService(dispatcher);\n \n     pauseMonitor \u003d new JvmPauseMonitor();\n     addService(pauseMonitor);\n     metrics.getJvmMetrics().setPauseMonitor(pauseMonitor);\n \n     DefaultMetricsSystem.initialize(\"NodeManager\");\n \n     if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n       this.nmCollectorService \u003d createNMCollectorService(context);\n       addService(nmCollectorService);\n     }\n \n     // StatusUpdater should be added last so that it get started last \n     // so that we make sure everything is up before registering with RM. \n     addService(nodeStatusUpdater);\n     ((NMContext) context).setNodeStatusUpdater(nodeStatusUpdater);\n     nmStore.setNodeStatusUpdater(nodeStatusUpdater);\n \n     // Do secure login before calling init for added services.\n     try {\n       doSecureLogin();\n     } catch (IOException e) {\n       throw new YarnRuntimeException(\"Failed NodeManager login\", e);\n     }\n \n     registerMXBean();\n \n     super.serviceInit(conf);\n     // TODO add local dirs to del\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceInit(Configuration conf) throws Exception {\n    rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n            .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n        YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n\n    try {\n      initAndStartRecoveryStore(conf);\n    } catch (IOException e) {\n      String recoveryDirName \u003d conf.get(YarnConfiguration.NM_RECOVERY_DIR);\n      throw new\n          YarnRuntimeException(\"Unable to initialize recovery directory at \"\n              + recoveryDirName, e);\n    }\n\n    NMContainerTokenSecretManager containerTokenSecretManager \u003d\n        new NMContainerTokenSecretManager(conf, nmStore);\n\n    NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n        new NMTokenSecretManagerInNM(nmStore);\n\n    recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n    \n    this.aclsManager \u003d new ApplicationACLsManager(conf);\n\n    this.dirsHandler \u003d new LocalDirsHandlerService(metrics);\n\n    boolean isDistSchedulingEnabled \u003d\n        conf.getBoolean(YarnConfiguration.DIST_SCHEDULING_ENABLED,\n            YarnConfiguration.DEFAULT_DIST_SCHEDULING_ENABLED);\n\n    this.context \u003d createNMContext(containerTokenSecretManager,\n        nmTokenSecretManager, nmStore, isDistSchedulingEnabled, conf);\n\n    ResourcePluginManager pluginManager \u003d createResourcePluginManager();\n    pluginManager.initialize(context);\n    ((NMContext)context).setResourcePluginManager(pluginManager);\n\n    ContainerExecutor exec \u003d createContainerExecutor(conf);\n    try {\n      exec.init(context);\n    } catch (IOException e) {\n      throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n    }    \n    DeletionService del \u003d createDeletionService(exec);\n    addService(del);\n\n    // NodeManager level dispatcher\n    this.dispatcher \u003d createNMDispatcher();\n\n    nodeHealthChecker \u003d\n        new NodeHealthCheckerService(\n            getNodeHealthScriptRunner(conf), dirsHandler);\n    addService(nodeHealthChecker);\n\n\n    ((NMContext)context).setContainerExecutor(exec);\n    ((NMContext)context).setDeletionService(del);\n\n    nodeStatusUpdater \u003d\n        createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n\n    nodeLabelsProvider \u003d createNodeLabelsProvider(conf);\n    if (nodeLabelsProvider !\u003d null) {\n      addIfService(nodeLabelsProvider);\n      nodeStatusUpdater.setNodeLabelsProvider(nodeLabelsProvider);\n    }\n\n    nodeAttributesProvider \u003d createNodeAttributesProvider(conf);\n    if (nodeAttributesProvider !\u003d null) {\n      addIfService(nodeAttributesProvider);\n      nodeStatusUpdater.setNodeAttributesProvider(nodeAttributesProvider);\n    }\n\n    nodeResourceMonitor \u003d createNodeResourceMonitor();\n    addService(nodeResourceMonitor);\n    ((NMContext) context).setNodeResourceMonitor(nodeResourceMonitor);\n\n    containerManager \u003d\n        createContainerManager(context, exec, del, nodeStatusUpdater,\n        this.aclsManager, dirsHandler);\n    addService(containerManager);\n    ((NMContext) context).setContainerManager(containerManager);\n\n    this.nmLogAggregationStatusTracker \u003d createNMLogAggregationStatusTracker(\n        context);\n    addService(nmLogAggregationStatusTracker);\n    ((NMContext)context).setNMLogAggregationStatusTracker(\n        this.nmLogAggregationStatusTracker);\n\n    WebServer webServer \u003d createWebServer(context, containerManager\n        .getContainersMonitor(), this.aclsManager, dirsHandler);\n    addService(webServer);\n    ((NMContext) context).setWebServer(webServer);\n\n    ((NMContext) context).setQueueableContainerAllocator(\n        new OpportunisticContainerAllocator(\n            context.getContainerTokenSecretManager()));\n\n    dispatcher.register(ContainerManagerEventType.class, containerManager);\n    dispatcher.register(NodeManagerEventType.class, this);\n    addService(dispatcher);\n\n    pauseMonitor \u003d new JvmPauseMonitor();\n    addService(pauseMonitor);\n    metrics.getJvmMetrics().setPauseMonitor(pauseMonitor);\n\n    DefaultMetricsSystem.initialize(\"NodeManager\");\n\n    if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n      this.nmCollectorService \u003d createNMCollectorService(context);\n      addService(nmCollectorService);\n    }\n\n    // StatusUpdater should be added last so that it get started last \n    // so that we make sure everything is up before registering with RM. \n    addService(nodeStatusUpdater);\n    ((NMContext) context).setNodeStatusUpdater(nodeStatusUpdater);\n    nmStore.setNodeStatusUpdater(nodeStatusUpdater);\n\n    // Do secure login before calling init for added services.\n    try {\n      doSecureLogin();\n    } catch (IOException e) {\n      throw new YarnRuntimeException(\"Failed NodeManager login\", e);\n    }\n\n    registerMXBean();\n\n    super.serviceInit(conf);\n    // TODO add local dirs to del\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java",
      "extendedDetails": {}
    },
    "363bd16e314490e31758cc82de584e75cd8357cc": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14212. Expose SecurityEnabled boolean field in JMX for other services besides NameNode. Contributed by Adam Antal.\n",
      "commitDate": "14/08/18 5:19 PM",
      "commitName": "363bd16e314490e31758cc82de584e75cd8357cc",
      "commitAuthor": "Wei-Chiu Chuang",
      "commitDateOld": "29/06/18 11:06 AM",
      "commitNameOld": "100470140d86eede0fa240a9aa93226f274ee4f5",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 46.26,
      "commitsBetweenForRepo": 352,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,126 +1,128 @@\n   protected void serviceInit(Configuration conf) throws Exception {\n     rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n             .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n         YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n \n     try {\n       initAndStartRecoveryStore(conf);\n     } catch (IOException e) {\n       String recoveryDirName \u003d conf.get(YarnConfiguration.NM_RECOVERY_DIR);\n       throw new\n           YarnRuntimeException(\"Unable to initialize recovery directory at \"\n               + recoveryDirName, e);\n     }\n \n     NMContainerTokenSecretManager containerTokenSecretManager \u003d\n         new NMContainerTokenSecretManager(conf, nmStore);\n \n     NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n         new NMTokenSecretManagerInNM(nmStore);\n \n     recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n     \n     this.aclsManager \u003d new ApplicationACLsManager(conf);\n \n     this.dirsHandler \u003d new LocalDirsHandlerService(metrics);\n \n     boolean isDistSchedulingEnabled \u003d\n         conf.getBoolean(YarnConfiguration.DIST_SCHEDULING_ENABLED,\n             YarnConfiguration.DEFAULT_DIST_SCHEDULING_ENABLED);\n \n     this.context \u003d createNMContext(containerTokenSecretManager,\n         nmTokenSecretManager, nmStore, isDistSchedulingEnabled, conf);\n \n     ResourcePluginManager pluginManager \u003d createResourcePluginManager();\n     pluginManager.initialize(context);\n     ((NMContext)context).setResourcePluginManager(pluginManager);\n \n     ContainerExecutor exec \u003d createContainerExecutor(conf);\n     try {\n       exec.init(context);\n     } catch (IOException e) {\n       throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n     }    \n     DeletionService del \u003d createDeletionService(exec);\n     addService(del);\n \n     // NodeManager level dispatcher\n     this.dispatcher \u003d createNMDispatcher();\n \n     nodeHealthChecker \u003d\n         new NodeHealthCheckerService(\n             getNodeHealthScriptRunner(conf), dirsHandler);\n     addService(nodeHealthChecker);\n \n \n     ((NMContext)context).setContainerExecutor(exec);\n     ((NMContext)context).setDeletionService(del);\n \n     nodeLabelsProvider \u003d createNodeLabelsProvider(conf);\n \n     if (null \u003d\u003d nodeLabelsProvider) {\n       nodeStatusUpdater \u003d\n           createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n     } else {\n       addIfService(nodeLabelsProvider);\n       nodeStatusUpdater \u003d\n           createNodeStatusUpdater(context, dispatcher, nodeHealthChecker,\n               nodeLabelsProvider);\n     }\n \n     nodeResourceMonitor \u003d createNodeResourceMonitor();\n     addService(nodeResourceMonitor);\n     ((NMContext) context).setNodeResourceMonitor(nodeResourceMonitor);\n \n     containerManager \u003d\n         createContainerManager(context, exec, del, nodeStatusUpdater,\n         this.aclsManager, dirsHandler);\n     addService(containerManager);\n     ((NMContext) context).setContainerManager(containerManager);\n \n     this.nmLogAggregationStatusTracker \u003d createNMLogAggregationStatusTracker(\n         context);\n     addService(nmLogAggregationStatusTracker);\n     ((NMContext)context).setNMLogAggregationStatusTracker(\n         this.nmLogAggregationStatusTracker);\n \n     WebServer webServer \u003d createWebServer(context, containerManager\n         .getContainersMonitor(), this.aclsManager, dirsHandler);\n     addService(webServer);\n     ((NMContext) context).setWebServer(webServer);\n \n     ((NMContext) context).setQueueableContainerAllocator(\n         new OpportunisticContainerAllocator(\n             context.getContainerTokenSecretManager()));\n \n     dispatcher.register(ContainerManagerEventType.class, containerManager);\n     dispatcher.register(NodeManagerEventType.class, this);\n     addService(dispatcher);\n \n     pauseMonitor \u003d new JvmPauseMonitor();\n     addService(pauseMonitor);\n     metrics.getJvmMetrics().setPauseMonitor(pauseMonitor);\n \n     DefaultMetricsSystem.initialize(\"NodeManager\");\n \n     if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n       this.nmCollectorService \u003d createNMCollectorService(context);\n       addService(nmCollectorService);\n     }\n \n     // StatusUpdater should be added last so that it get started last \n     // so that we make sure everything is up before registering with RM. \n     addService(nodeStatusUpdater);\n     ((NMContext) context).setNodeStatusUpdater(nodeStatusUpdater);\n     nmStore.setNodeStatusUpdater(nodeStatusUpdater);\n \n     // Do secure login before calling init for added services.\n     try {\n       doSecureLogin();\n     } catch (IOException e) {\n       throw new YarnRuntimeException(\"Failed NodeManager login\", e);\n     }\n \n+    registerMXBean();\n+\n     super.serviceInit(conf);\n     // TODO add local dirs to del\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceInit(Configuration conf) throws Exception {\n    rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n            .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n        YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n\n    try {\n      initAndStartRecoveryStore(conf);\n    } catch (IOException e) {\n      String recoveryDirName \u003d conf.get(YarnConfiguration.NM_RECOVERY_DIR);\n      throw new\n          YarnRuntimeException(\"Unable to initialize recovery directory at \"\n              + recoveryDirName, e);\n    }\n\n    NMContainerTokenSecretManager containerTokenSecretManager \u003d\n        new NMContainerTokenSecretManager(conf, nmStore);\n\n    NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n        new NMTokenSecretManagerInNM(nmStore);\n\n    recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n    \n    this.aclsManager \u003d new ApplicationACLsManager(conf);\n\n    this.dirsHandler \u003d new LocalDirsHandlerService(metrics);\n\n    boolean isDistSchedulingEnabled \u003d\n        conf.getBoolean(YarnConfiguration.DIST_SCHEDULING_ENABLED,\n            YarnConfiguration.DEFAULT_DIST_SCHEDULING_ENABLED);\n\n    this.context \u003d createNMContext(containerTokenSecretManager,\n        nmTokenSecretManager, nmStore, isDistSchedulingEnabled, conf);\n\n    ResourcePluginManager pluginManager \u003d createResourcePluginManager();\n    pluginManager.initialize(context);\n    ((NMContext)context).setResourcePluginManager(pluginManager);\n\n    ContainerExecutor exec \u003d createContainerExecutor(conf);\n    try {\n      exec.init(context);\n    } catch (IOException e) {\n      throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n    }    \n    DeletionService del \u003d createDeletionService(exec);\n    addService(del);\n\n    // NodeManager level dispatcher\n    this.dispatcher \u003d createNMDispatcher();\n\n    nodeHealthChecker \u003d\n        new NodeHealthCheckerService(\n            getNodeHealthScriptRunner(conf), dirsHandler);\n    addService(nodeHealthChecker);\n\n\n    ((NMContext)context).setContainerExecutor(exec);\n    ((NMContext)context).setDeletionService(del);\n\n    nodeLabelsProvider \u003d createNodeLabelsProvider(conf);\n\n    if (null \u003d\u003d nodeLabelsProvider) {\n      nodeStatusUpdater \u003d\n          createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n    } else {\n      addIfService(nodeLabelsProvider);\n      nodeStatusUpdater \u003d\n          createNodeStatusUpdater(context, dispatcher, nodeHealthChecker,\n              nodeLabelsProvider);\n    }\n\n    nodeResourceMonitor \u003d createNodeResourceMonitor();\n    addService(nodeResourceMonitor);\n    ((NMContext) context).setNodeResourceMonitor(nodeResourceMonitor);\n\n    containerManager \u003d\n        createContainerManager(context, exec, del, nodeStatusUpdater,\n        this.aclsManager, dirsHandler);\n    addService(containerManager);\n    ((NMContext) context).setContainerManager(containerManager);\n\n    this.nmLogAggregationStatusTracker \u003d createNMLogAggregationStatusTracker(\n        context);\n    addService(nmLogAggregationStatusTracker);\n    ((NMContext)context).setNMLogAggregationStatusTracker(\n        this.nmLogAggregationStatusTracker);\n\n    WebServer webServer \u003d createWebServer(context, containerManager\n        .getContainersMonitor(), this.aclsManager, dirsHandler);\n    addService(webServer);\n    ((NMContext) context).setWebServer(webServer);\n\n    ((NMContext) context).setQueueableContainerAllocator(\n        new OpportunisticContainerAllocator(\n            context.getContainerTokenSecretManager()));\n\n    dispatcher.register(ContainerManagerEventType.class, containerManager);\n    dispatcher.register(NodeManagerEventType.class, this);\n    addService(dispatcher);\n\n    pauseMonitor \u003d new JvmPauseMonitor();\n    addService(pauseMonitor);\n    metrics.getJvmMetrics().setPauseMonitor(pauseMonitor);\n\n    DefaultMetricsSystem.initialize(\"NodeManager\");\n\n    if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n      this.nmCollectorService \u003d createNMCollectorService(context);\n      addService(nmCollectorService);\n    }\n\n    // StatusUpdater should be added last so that it get started last \n    // so that we make sure everything is up before registering with RM. \n    addService(nodeStatusUpdater);\n    ((NMContext) context).setNodeStatusUpdater(nodeStatusUpdater);\n    nmStore.setNodeStatusUpdater(nodeStatusUpdater);\n\n    // Do secure login before calling init for added services.\n    try {\n      doSecureLogin();\n    } catch (IOException e) {\n      throw new YarnRuntimeException(\"Failed NodeManager login\", e);\n    }\n\n    registerMXBean();\n\n    super.serviceInit(conf);\n    // TODO add local dirs to del\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java",
      "extendedDetails": {}
    },
    "100470140d86eede0fa240a9aa93226f274ee4f5": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8451. Multiple NM heartbeat thread created when a slow NM resync with RM. Contributed by Botong Huang\n",
      "commitDate": "29/06/18 11:06 AM",
      "commitName": "100470140d86eede0fa240a9aa93226f274ee4f5",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "15/03/18 1:26 PM",
      "commitNameOld": "4bf622043f034835d65ff2a4785b9b06d0ef1fd2",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 105.9,
      "commitsBetweenForRepo": 1360,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,126 +1,126 @@\n   protected void serviceInit(Configuration conf) throws Exception {\n     rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n             .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n         YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n \n     try {\n       initAndStartRecoveryStore(conf);\n     } catch (IOException e) {\n       String recoveryDirName \u003d conf.get(YarnConfiguration.NM_RECOVERY_DIR);\n       throw new\n           YarnRuntimeException(\"Unable to initialize recovery directory at \"\n               + recoveryDirName, e);\n     }\n \n     NMContainerTokenSecretManager containerTokenSecretManager \u003d\n         new NMContainerTokenSecretManager(conf, nmStore);\n \n     NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n         new NMTokenSecretManagerInNM(nmStore);\n \n     recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n     \n     this.aclsManager \u003d new ApplicationACLsManager(conf);\n \n     this.dirsHandler \u003d new LocalDirsHandlerService(metrics);\n \n     boolean isDistSchedulingEnabled \u003d\n         conf.getBoolean(YarnConfiguration.DIST_SCHEDULING_ENABLED,\n             YarnConfiguration.DEFAULT_DIST_SCHEDULING_ENABLED);\n \n     this.context \u003d createNMContext(containerTokenSecretManager,\n         nmTokenSecretManager, nmStore, isDistSchedulingEnabled, conf);\n \n     ResourcePluginManager pluginManager \u003d createResourcePluginManager();\n     pluginManager.initialize(context);\n     ((NMContext)context).setResourcePluginManager(pluginManager);\n \n     ContainerExecutor exec \u003d createContainerExecutor(conf);\n     try {\n       exec.init(context);\n     } catch (IOException e) {\n       throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n     }    \n     DeletionService del \u003d createDeletionService(exec);\n     addService(del);\n \n     // NodeManager level dispatcher\n-    this.dispatcher \u003d new AsyncDispatcher(\"NM Event dispatcher\");\n+    this.dispatcher \u003d createNMDispatcher();\n \n     nodeHealthChecker \u003d\n         new NodeHealthCheckerService(\n             getNodeHealthScriptRunner(conf), dirsHandler);\n     addService(nodeHealthChecker);\n \n \n     ((NMContext)context).setContainerExecutor(exec);\n     ((NMContext)context).setDeletionService(del);\n \n     nodeLabelsProvider \u003d createNodeLabelsProvider(conf);\n \n     if (null \u003d\u003d nodeLabelsProvider) {\n       nodeStatusUpdater \u003d\n           createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n     } else {\n       addIfService(nodeLabelsProvider);\n       nodeStatusUpdater \u003d\n           createNodeStatusUpdater(context, dispatcher, nodeHealthChecker,\n               nodeLabelsProvider);\n     }\n \n     nodeResourceMonitor \u003d createNodeResourceMonitor();\n     addService(nodeResourceMonitor);\n     ((NMContext) context).setNodeResourceMonitor(nodeResourceMonitor);\n \n     containerManager \u003d\n         createContainerManager(context, exec, del, nodeStatusUpdater,\n         this.aclsManager, dirsHandler);\n     addService(containerManager);\n     ((NMContext) context).setContainerManager(containerManager);\n \n     this.nmLogAggregationStatusTracker \u003d createNMLogAggregationStatusTracker(\n         context);\n     addService(nmLogAggregationStatusTracker);\n     ((NMContext)context).setNMLogAggregationStatusTracker(\n         this.nmLogAggregationStatusTracker);\n \n     WebServer webServer \u003d createWebServer(context, containerManager\n         .getContainersMonitor(), this.aclsManager, dirsHandler);\n     addService(webServer);\n     ((NMContext) context).setWebServer(webServer);\n \n     ((NMContext) context).setQueueableContainerAllocator(\n         new OpportunisticContainerAllocator(\n             context.getContainerTokenSecretManager()));\n \n     dispatcher.register(ContainerManagerEventType.class, containerManager);\n     dispatcher.register(NodeManagerEventType.class, this);\n     addService(dispatcher);\n \n     pauseMonitor \u003d new JvmPauseMonitor();\n     addService(pauseMonitor);\n     metrics.getJvmMetrics().setPauseMonitor(pauseMonitor);\n \n     DefaultMetricsSystem.initialize(\"NodeManager\");\n \n     if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n       this.nmCollectorService \u003d createNMCollectorService(context);\n       addService(nmCollectorService);\n     }\n \n     // StatusUpdater should be added last so that it get started last \n     // so that we make sure everything is up before registering with RM. \n     addService(nodeStatusUpdater);\n     ((NMContext) context).setNodeStatusUpdater(nodeStatusUpdater);\n     nmStore.setNodeStatusUpdater(nodeStatusUpdater);\n \n     // Do secure login before calling init for added services.\n     try {\n       doSecureLogin();\n     } catch (IOException e) {\n       throw new YarnRuntimeException(\"Failed NodeManager login\", e);\n     }\n \n     super.serviceInit(conf);\n     // TODO add local dirs to del\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceInit(Configuration conf) throws Exception {\n    rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n            .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n        YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n\n    try {\n      initAndStartRecoveryStore(conf);\n    } catch (IOException e) {\n      String recoveryDirName \u003d conf.get(YarnConfiguration.NM_RECOVERY_DIR);\n      throw new\n          YarnRuntimeException(\"Unable to initialize recovery directory at \"\n              + recoveryDirName, e);\n    }\n\n    NMContainerTokenSecretManager containerTokenSecretManager \u003d\n        new NMContainerTokenSecretManager(conf, nmStore);\n\n    NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n        new NMTokenSecretManagerInNM(nmStore);\n\n    recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n    \n    this.aclsManager \u003d new ApplicationACLsManager(conf);\n\n    this.dirsHandler \u003d new LocalDirsHandlerService(metrics);\n\n    boolean isDistSchedulingEnabled \u003d\n        conf.getBoolean(YarnConfiguration.DIST_SCHEDULING_ENABLED,\n            YarnConfiguration.DEFAULT_DIST_SCHEDULING_ENABLED);\n\n    this.context \u003d createNMContext(containerTokenSecretManager,\n        nmTokenSecretManager, nmStore, isDistSchedulingEnabled, conf);\n\n    ResourcePluginManager pluginManager \u003d createResourcePluginManager();\n    pluginManager.initialize(context);\n    ((NMContext)context).setResourcePluginManager(pluginManager);\n\n    ContainerExecutor exec \u003d createContainerExecutor(conf);\n    try {\n      exec.init(context);\n    } catch (IOException e) {\n      throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n    }    \n    DeletionService del \u003d createDeletionService(exec);\n    addService(del);\n\n    // NodeManager level dispatcher\n    this.dispatcher \u003d createNMDispatcher();\n\n    nodeHealthChecker \u003d\n        new NodeHealthCheckerService(\n            getNodeHealthScriptRunner(conf), dirsHandler);\n    addService(nodeHealthChecker);\n\n\n    ((NMContext)context).setContainerExecutor(exec);\n    ((NMContext)context).setDeletionService(del);\n\n    nodeLabelsProvider \u003d createNodeLabelsProvider(conf);\n\n    if (null \u003d\u003d nodeLabelsProvider) {\n      nodeStatusUpdater \u003d\n          createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n    } else {\n      addIfService(nodeLabelsProvider);\n      nodeStatusUpdater \u003d\n          createNodeStatusUpdater(context, dispatcher, nodeHealthChecker,\n              nodeLabelsProvider);\n    }\n\n    nodeResourceMonitor \u003d createNodeResourceMonitor();\n    addService(nodeResourceMonitor);\n    ((NMContext) context).setNodeResourceMonitor(nodeResourceMonitor);\n\n    containerManager \u003d\n        createContainerManager(context, exec, del, nodeStatusUpdater,\n        this.aclsManager, dirsHandler);\n    addService(containerManager);\n    ((NMContext) context).setContainerManager(containerManager);\n\n    this.nmLogAggregationStatusTracker \u003d createNMLogAggregationStatusTracker(\n        context);\n    addService(nmLogAggregationStatusTracker);\n    ((NMContext)context).setNMLogAggregationStatusTracker(\n        this.nmLogAggregationStatusTracker);\n\n    WebServer webServer \u003d createWebServer(context, containerManager\n        .getContainersMonitor(), this.aclsManager, dirsHandler);\n    addService(webServer);\n    ((NMContext) context).setWebServer(webServer);\n\n    ((NMContext) context).setQueueableContainerAllocator(\n        new OpportunisticContainerAllocator(\n            context.getContainerTokenSecretManager()));\n\n    dispatcher.register(ContainerManagerEventType.class, containerManager);\n    dispatcher.register(NodeManagerEventType.class, this);\n    addService(dispatcher);\n\n    pauseMonitor \u003d new JvmPauseMonitor();\n    addService(pauseMonitor);\n    metrics.getJvmMetrics().setPauseMonitor(pauseMonitor);\n\n    DefaultMetricsSystem.initialize(\"NodeManager\");\n\n    if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n      this.nmCollectorService \u003d createNMCollectorService(context);\n      addService(nmCollectorService);\n    }\n\n    // StatusUpdater should be added last so that it get started last \n    // so that we make sure everything is up before registering with RM. \n    addService(nodeStatusUpdater);\n    ((NMContext) context).setNodeStatusUpdater(nodeStatusUpdater);\n    nmStore.setNodeStatusUpdater(nodeStatusUpdater);\n\n    // Do secure login before calling init for added services.\n    try {\n      doSecureLogin();\n    } catch (IOException e) {\n      throw new YarnRuntimeException(\"Failed NodeManager login\", e);\n    }\n\n    super.serviceInit(conf);\n    // TODO add local dirs to del\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java",
      "extendedDetails": {}
    },
    "4bf622043f034835d65ff2a4785b9b06d0ef1fd2": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7952. RM should be able to recover log aggregation status after restart/fail-over. (Xuan Gong via wangda)\n\nChange-Id: I725c9afe64831eda0aa6b0bebdbc79d2dd165707\n",
      "commitDate": "15/03/18 1:26 PM",
      "commitName": "4bf622043f034835d65ff2a4785b9b06d0ef1fd2",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "07/03/18 3:46 PM",
      "commitNameOld": "e718ac597f2225cb4946e1ac4b3986c336645643",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 7.86,
      "commitsBetweenForRepo": 74,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,120 +1,126 @@\n   protected void serviceInit(Configuration conf) throws Exception {\n     rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n             .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n         YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n \n     try {\n       initAndStartRecoveryStore(conf);\n     } catch (IOException e) {\n       String recoveryDirName \u003d conf.get(YarnConfiguration.NM_RECOVERY_DIR);\n       throw new\n           YarnRuntimeException(\"Unable to initialize recovery directory at \"\n               + recoveryDirName, e);\n     }\n \n     NMContainerTokenSecretManager containerTokenSecretManager \u003d\n         new NMContainerTokenSecretManager(conf, nmStore);\n \n     NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n         new NMTokenSecretManagerInNM(nmStore);\n \n     recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n     \n     this.aclsManager \u003d new ApplicationACLsManager(conf);\n \n     this.dirsHandler \u003d new LocalDirsHandlerService(metrics);\n \n     boolean isDistSchedulingEnabled \u003d\n         conf.getBoolean(YarnConfiguration.DIST_SCHEDULING_ENABLED,\n             YarnConfiguration.DEFAULT_DIST_SCHEDULING_ENABLED);\n \n     this.context \u003d createNMContext(containerTokenSecretManager,\n         nmTokenSecretManager, nmStore, isDistSchedulingEnabled, conf);\n \n     ResourcePluginManager pluginManager \u003d createResourcePluginManager();\n     pluginManager.initialize(context);\n     ((NMContext)context).setResourcePluginManager(pluginManager);\n \n     ContainerExecutor exec \u003d createContainerExecutor(conf);\n     try {\n       exec.init(context);\n     } catch (IOException e) {\n       throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n     }    \n     DeletionService del \u003d createDeletionService(exec);\n     addService(del);\n \n     // NodeManager level dispatcher\n     this.dispatcher \u003d new AsyncDispatcher(\"NM Event dispatcher\");\n \n     nodeHealthChecker \u003d\n         new NodeHealthCheckerService(\n             getNodeHealthScriptRunner(conf), dirsHandler);\n     addService(nodeHealthChecker);\n \n \n     ((NMContext)context).setContainerExecutor(exec);\n     ((NMContext)context).setDeletionService(del);\n \n     nodeLabelsProvider \u003d createNodeLabelsProvider(conf);\n \n     if (null \u003d\u003d nodeLabelsProvider) {\n       nodeStatusUpdater \u003d\n           createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n     } else {\n       addIfService(nodeLabelsProvider);\n       nodeStatusUpdater \u003d\n           createNodeStatusUpdater(context, dispatcher, nodeHealthChecker,\n               nodeLabelsProvider);\n     }\n \n     nodeResourceMonitor \u003d createNodeResourceMonitor();\n     addService(nodeResourceMonitor);\n     ((NMContext) context).setNodeResourceMonitor(nodeResourceMonitor);\n \n     containerManager \u003d\n         createContainerManager(context, exec, del, nodeStatusUpdater,\n         this.aclsManager, dirsHandler);\n     addService(containerManager);\n     ((NMContext) context).setContainerManager(containerManager);\n \n+    this.nmLogAggregationStatusTracker \u003d createNMLogAggregationStatusTracker(\n+        context);\n+    addService(nmLogAggregationStatusTracker);\n+    ((NMContext)context).setNMLogAggregationStatusTracker(\n+        this.nmLogAggregationStatusTracker);\n+\n     WebServer webServer \u003d createWebServer(context, containerManager\n         .getContainersMonitor(), this.aclsManager, dirsHandler);\n     addService(webServer);\n     ((NMContext) context).setWebServer(webServer);\n \n     ((NMContext) context).setQueueableContainerAllocator(\n         new OpportunisticContainerAllocator(\n             context.getContainerTokenSecretManager()));\n \n     dispatcher.register(ContainerManagerEventType.class, containerManager);\n     dispatcher.register(NodeManagerEventType.class, this);\n     addService(dispatcher);\n \n     pauseMonitor \u003d new JvmPauseMonitor();\n     addService(pauseMonitor);\n     metrics.getJvmMetrics().setPauseMonitor(pauseMonitor);\n \n     DefaultMetricsSystem.initialize(\"NodeManager\");\n \n     if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n       this.nmCollectorService \u003d createNMCollectorService(context);\n       addService(nmCollectorService);\n     }\n \n     // StatusUpdater should be added last so that it get started last \n     // so that we make sure everything is up before registering with RM. \n     addService(nodeStatusUpdater);\n     ((NMContext) context).setNodeStatusUpdater(nodeStatusUpdater);\n     nmStore.setNodeStatusUpdater(nodeStatusUpdater);\n \n     // Do secure login before calling init for added services.\n     try {\n       doSecureLogin();\n     } catch (IOException e) {\n       throw new YarnRuntimeException(\"Failed NodeManager login\", e);\n     }\n \n     super.serviceInit(conf);\n     // TODO add local dirs to del\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceInit(Configuration conf) throws Exception {\n    rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n            .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n        YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n\n    try {\n      initAndStartRecoveryStore(conf);\n    } catch (IOException e) {\n      String recoveryDirName \u003d conf.get(YarnConfiguration.NM_RECOVERY_DIR);\n      throw new\n          YarnRuntimeException(\"Unable to initialize recovery directory at \"\n              + recoveryDirName, e);\n    }\n\n    NMContainerTokenSecretManager containerTokenSecretManager \u003d\n        new NMContainerTokenSecretManager(conf, nmStore);\n\n    NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n        new NMTokenSecretManagerInNM(nmStore);\n\n    recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n    \n    this.aclsManager \u003d new ApplicationACLsManager(conf);\n\n    this.dirsHandler \u003d new LocalDirsHandlerService(metrics);\n\n    boolean isDistSchedulingEnabled \u003d\n        conf.getBoolean(YarnConfiguration.DIST_SCHEDULING_ENABLED,\n            YarnConfiguration.DEFAULT_DIST_SCHEDULING_ENABLED);\n\n    this.context \u003d createNMContext(containerTokenSecretManager,\n        nmTokenSecretManager, nmStore, isDistSchedulingEnabled, conf);\n\n    ResourcePluginManager pluginManager \u003d createResourcePluginManager();\n    pluginManager.initialize(context);\n    ((NMContext)context).setResourcePluginManager(pluginManager);\n\n    ContainerExecutor exec \u003d createContainerExecutor(conf);\n    try {\n      exec.init(context);\n    } catch (IOException e) {\n      throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n    }    \n    DeletionService del \u003d createDeletionService(exec);\n    addService(del);\n\n    // NodeManager level dispatcher\n    this.dispatcher \u003d new AsyncDispatcher(\"NM Event dispatcher\");\n\n    nodeHealthChecker \u003d\n        new NodeHealthCheckerService(\n            getNodeHealthScriptRunner(conf), dirsHandler);\n    addService(nodeHealthChecker);\n\n\n    ((NMContext)context).setContainerExecutor(exec);\n    ((NMContext)context).setDeletionService(del);\n\n    nodeLabelsProvider \u003d createNodeLabelsProvider(conf);\n\n    if (null \u003d\u003d nodeLabelsProvider) {\n      nodeStatusUpdater \u003d\n          createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n    } else {\n      addIfService(nodeLabelsProvider);\n      nodeStatusUpdater \u003d\n          createNodeStatusUpdater(context, dispatcher, nodeHealthChecker,\n              nodeLabelsProvider);\n    }\n\n    nodeResourceMonitor \u003d createNodeResourceMonitor();\n    addService(nodeResourceMonitor);\n    ((NMContext) context).setNodeResourceMonitor(nodeResourceMonitor);\n\n    containerManager \u003d\n        createContainerManager(context, exec, del, nodeStatusUpdater,\n        this.aclsManager, dirsHandler);\n    addService(containerManager);\n    ((NMContext) context).setContainerManager(containerManager);\n\n    this.nmLogAggregationStatusTracker \u003d createNMLogAggregationStatusTracker(\n        context);\n    addService(nmLogAggregationStatusTracker);\n    ((NMContext)context).setNMLogAggregationStatusTracker(\n        this.nmLogAggregationStatusTracker);\n\n    WebServer webServer \u003d createWebServer(context, containerManager\n        .getContainersMonitor(), this.aclsManager, dirsHandler);\n    addService(webServer);\n    ((NMContext) context).setWebServer(webServer);\n\n    ((NMContext) context).setQueueableContainerAllocator(\n        new OpportunisticContainerAllocator(\n            context.getContainerTokenSecretManager()));\n\n    dispatcher.register(ContainerManagerEventType.class, containerManager);\n    dispatcher.register(NodeManagerEventType.class, this);\n    addService(dispatcher);\n\n    pauseMonitor \u003d new JvmPauseMonitor();\n    addService(pauseMonitor);\n    metrics.getJvmMetrics().setPauseMonitor(pauseMonitor);\n\n    DefaultMetricsSystem.initialize(\"NodeManager\");\n\n    if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n      this.nmCollectorService \u003d createNMCollectorService(context);\n      addService(nmCollectorService);\n    }\n\n    // StatusUpdater should be added last so that it get started last \n    // so that we make sure everything is up before registering with RM. \n    addService(nodeStatusUpdater);\n    ((NMContext) context).setNodeStatusUpdater(nodeStatusUpdater);\n    nmStore.setNodeStatusUpdater(nodeStatusUpdater);\n\n    // Do secure login before calling init for added services.\n    try {\n      doSecureLogin();\n    } catch (IOException e) {\n      throw new YarnRuntimeException(\"Failed NodeManager login\", e);\n    }\n\n    super.serviceInit(conf);\n    // TODO add local dirs to del\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java",
      "extendedDetails": {}
    },
    "443523f9c0fcc4ba2503791090b1879c6031759b": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7765. Fixed an issue that kerberos tgt not found when NM posting timeline events. Contributed by Rohith Sharma K S\n",
      "commitDate": "27/01/18 10:18 PM",
      "commitName": "443523f9c0fcc4ba2503791090b1879c6031759b",
      "commitAuthor": "Jian He",
      "commitDateOld": "12/01/18 10:41 AM",
      "commitNameOld": "3d65dbe032e202361d613344ccc6d9c5f99ba395",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 15.48,
      "commitsBetweenForRepo": 85,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,113 +1,120 @@\n   protected void serviceInit(Configuration conf) throws Exception {\n     rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n             .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n         YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n \n     try {\n       initAndStartRecoveryStore(conf);\n     } catch (IOException e) {\n       String recoveryDirName \u003d conf.get(YarnConfiguration.NM_RECOVERY_DIR);\n       throw new\n           YarnRuntimeException(\"Unable to initialize recovery directory at \"\n               + recoveryDirName, e);\n     }\n \n     NMContainerTokenSecretManager containerTokenSecretManager \u003d\n         new NMContainerTokenSecretManager(conf, nmStore);\n \n     NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n         new NMTokenSecretManagerInNM(nmStore);\n \n     recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n     \n     this.aclsManager \u003d new ApplicationACLsManager(conf);\n \n     this.dirsHandler \u003d new LocalDirsHandlerService(metrics);\n \n     boolean isDistSchedulingEnabled \u003d\n         conf.getBoolean(YarnConfiguration.DIST_SCHEDULING_ENABLED,\n             YarnConfiguration.DEFAULT_DIST_SCHEDULING_ENABLED);\n \n     this.context \u003d createNMContext(containerTokenSecretManager,\n         nmTokenSecretManager, nmStore, isDistSchedulingEnabled, conf);\n \n     ResourcePluginManager pluginManager \u003d createResourcePluginManager();\n     pluginManager.initialize(context);\n     ((NMContext)context).setResourcePluginManager(pluginManager);\n \n     ContainerExecutor exec \u003d createContainerExecutor(conf);\n     try {\n       exec.init(context);\n     } catch (IOException e) {\n       throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n     }    \n     DeletionService del \u003d createDeletionService(exec);\n     addService(del);\n \n     // NodeManager level dispatcher\n     this.dispatcher \u003d new AsyncDispatcher(\"NM Event dispatcher\");\n \n     nodeHealthChecker \u003d\n         new NodeHealthCheckerService(\n             getNodeHealthScriptRunner(conf), dirsHandler);\n     addService(nodeHealthChecker);\n \n \n     ((NMContext)context).setContainerExecutor(exec);\n     ((NMContext)context).setDeletionService(del);\n \n     nodeLabelsProvider \u003d createNodeLabelsProvider(conf);\n \n     if (null \u003d\u003d nodeLabelsProvider) {\n       nodeStatusUpdater \u003d\n           createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n     } else {\n       addIfService(nodeLabelsProvider);\n       nodeStatusUpdater \u003d\n           createNodeStatusUpdater(context, dispatcher, nodeHealthChecker,\n               nodeLabelsProvider);\n     }\n \n     nodeResourceMonitor \u003d createNodeResourceMonitor();\n     addService(nodeResourceMonitor);\n     ((NMContext) context).setNodeResourceMonitor(nodeResourceMonitor);\n \n     containerManager \u003d\n         createContainerManager(context, exec, del, nodeStatusUpdater,\n         this.aclsManager, dirsHandler);\n     addService(containerManager);\n     ((NMContext) context).setContainerManager(containerManager);\n \n     WebServer webServer \u003d createWebServer(context, containerManager\n         .getContainersMonitor(), this.aclsManager, dirsHandler);\n     addService(webServer);\n     ((NMContext) context).setWebServer(webServer);\n \n     ((NMContext) context).setQueueableContainerAllocator(\n         new OpportunisticContainerAllocator(\n             context.getContainerTokenSecretManager()));\n \n     dispatcher.register(ContainerManagerEventType.class, containerManager);\n     dispatcher.register(NodeManagerEventType.class, this);\n     addService(dispatcher);\n \n     pauseMonitor \u003d new JvmPauseMonitor();\n     addService(pauseMonitor);\n     metrics.getJvmMetrics().setPauseMonitor(pauseMonitor);\n \n     DefaultMetricsSystem.initialize(\"NodeManager\");\n \n     if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n       this.nmCollectorService \u003d createNMCollectorService(context);\n       addService(nmCollectorService);\n     }\n \n     // StatusUpdater should be added last so that it get started last \n     // so that we make sure everything is up before registering with RM. \n     addService(nodeStatusUpdater);\n     ((NMContext) context).setNodeStatusUpdater(nodeStatusUpdater);\n     nmStore.setNodeStatusUpdater(nodeStatusUpdater);\n \n+    // Do secure login before calling init for added services.\n+    try {\n+      doSecureLogin();\n+    } catch (IOException e) {\n+      throw new YarnRuntimeException(\"Failed NodeManager login\", e);\n+    }\n+\n     super.serviceInit(conf);\n     // TODO add local dirs to del\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceInit(Configuration conf) throws Exception {\n    rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n            .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n        YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n\n    try {\n      initAndStartRecoveryStore(conf);\n    } catch (IOException e) {\n      String recoveryDirName \u003d conf.get(YarnConfiguration.NM_RECOVERY_DIR);\n      throw new\n          YarnRuntimeException(\"Unable to initialize recovery directory at \"\n              + recoveryDirName, e);\n    }\n\n    NMContainerTokenSecretManager containerTokenSecretManager \u003d\n        new NMContainerTokenSecretManager(conf, nmStore);\n\n    NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n        new NMTokenSecretManagerInNM(nmStore);\n\n    recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n    \n    this.aclsManager \u003d new ApplicationACLsManager(conf);\n\n    this.dirsHandler \u003d new LocalDirsHandlerService(metrics);\n\n    boolean isDistSchedulingEnabled \u003d\n        conf.getBoolean(YarnConfiguration.DIST_SCHEDULING_ENABLED,\n            YarnConfiguration.DEFAULT_DIST_SCHEDULING_ENABLED);\n\n    this.context \u003d createNMContext(containerTokenSecretManager,\n        nmTokenSecretManager, nmStore, isDistSchedulingEnabled, conf);\n\n    ResourcePluginManager pluginManager \u003d createResourcePluginManager();\n    pluginManager.initialize(context);\n    ((NMContext)context).setResourcePluginManager(pluginManager);\n\n    ContainerExecutor exec \u003d createContainerExecutor(conf);\n    try {\n      exec.init(context);\n    } catch (IOException e) {\n      throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n    }    \n    DeletionService del \u003d createDeletionService(exec);\n    addService(del);\n\n    // NodeManager level dispatcher\n    this.dispatcher \u003d new AsyncDispatcher(\"NM Event dispatcher\");\n\n    nodeHealthChecker \u003d\n        new NodeHealthCheckerService(\n            getNodeHealthScriptRunner(conf), dirsHandler);\n    addService(nodeHealthChecker);\n\n\n    ((NMContext)context).setContainerExecutor(exec);\n    ((NMContext)context).setDeletionService(del);\n\n    nodeLabelsProvider \u003d createNodeLabelsProvider(conf);\n\n    if (null \u003d\u003d nodeLabelsProvider) {\n      nodeStatusUpdater \u003d\n          createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n    } else {\n      addIfService(nodeLabelsProvider);\n      nodeStatusUpdater \u003d\n          createNodeStatusUpdater(context, dispatcher, nodeHealthChecker,\n              nodeLabelsProvider);\n    }\n\n    nodeResourceMonitor \u003d createNodeResourceMonitor();\n    addService(nodeResourceMonitor);\n    ((NMContext) context).setNodeResourceMonitor(nodeResourceMonitor);\n\n    containerManager \u003d\n        createContainerManager(context, exec, del, nodeStatusUpdater,\n        this.aclsManager, dirsHandler);\n    addService(containerManager);\n    ((NMContext) context).setContainerManager(containerManager);\n\n    WebServer webServer \u003d createWebServer(context, containerManager\n        .getContainersMonitor(), this.aclsManager, dirsHandler);\n    addService(webServer);\n    ((NMContext) context).setWebServer(webServer);\n\n    ((NMContext) context).setQueueableContainerAllocator(\n        new OpportunisticContainerAllocator(\n            context.getContainerTokenSecretManager()));\n\n    dispatcher.register(ContainerManagerEventType.class, containerManager);\n    dispatcher.register(NodeManagerEventType.class, this);\n    addService(dispatcher);\n\n    pauseMonitor \u003d new JvmPauseMonitor();\n    addService(pauseMonitor);\n    metrics.getJvmMetrics().setPauseMonitor(pauseMonitor);\n\n    DefaultMetricsSystem.initialize(\"NodeManager\");\n\n    if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n      this.nmCollectorService \u003d createNMCollectorService(context);\n      addService(nmCollectorService);\n    }\n\n    // StatusUpdater should be added last so that it get started last \n    // so that we make sure everything is up before registering with RM. \n    addService(nodeStatusUpdater);\n    ((NMContext) context).setNodeStatusUpdater(nodeStatusUpdater);\n    nmStore.setNodeStatusUpdater(nodeStatusUpdater);\n\n    // Do secure login before calling init for added services.\n    try {\n      doSecureLogin();\n    } catch (IOException e) {\n      throw new YarnRuntimeException(\"Failed NodeManager login\", e);\n    }\n\n    super.serviceInit(conf);\n    // TODO add local dirs to del\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java",
      "extendedDetails": {}
    },
    "3d65dbe032e202361d613344ccc6d9c5f99ba395": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5366. Improve signal handling and delete delay for Docker on Yarn.\n           (Contributed by Shane Kumpf)\n",
      "commitDate": "12/01/18 10:41 AM",
      "commitName": "3d65dbe032e202361d613344ccc6d9c5f99ba395",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "02/01/18 6:03 PM",
      "commitNameOld": "7f515f57ede74dae787994f37bfafd5d20c9aa4c",
      "commitAuthorOld": "Miklos Szegedi",
      "daysBetweenCommits": 9.69,
      "commitsBetweenForRepo": 48,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,112 +1,113 @@\n   protected void serviceInit(Configuration conf) throws Exception {\n     rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n             .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n         YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n \n     try {\n       initAndStartRecoveryStore(conf);\n     } catch (IOException e) {\n       String recoveryDirName \u003d conf.get(YarnConfiguration.NM_RECOVERY_DIR);\n       throw new\n           YarnRuntimeException(\"Unable to initialize recovery directory at \"\n               + recoveryDirName, e);\n     }\n \n     NMContainerTokenSecretManager containerTokenSecretManager \u003d\n         new NMContainerTokenSecretManager(conf, nmStore);\n \n     NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n         new NMTokenSecretManagerInNM(nmStore);\n \n     recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n     \n     this.aclsManager \u003d new ApplicationACLsManager(conf);\n \n     this.dirsHandler \u003d new LocalDirsHandlerService(metrics);\n \n     boolean isDistSchedulingEnabled \u003d\n         conf.getBoolean(YarnConfiguration.DIST_SCHEDULING_ENABLED,\n             YarnConfiguration.DEFAULT_DIST_SCHEDULING_ENABLED);\n \n     this.context \u003d createNMContext(containerTokenSecretManager,\n         nmTokenSecretManager, nmStore, isDistSchedulingEnabled, conf);\n \n     ResourcePluginManager pluginManager \u003d createResourcePluginManager();\n     pluginManager.initialize(context);\n     ((NMContext)context).setResourcePluginManager(pluginManager);\n \n     ContainerExecutor exec \u003d createContainerExecutor(conf);\n     try {\n       exec.init(context);\n     } catch (IOException e) {\n       throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n     }    \n     DeletionService del \u003d createDeletionService(exec);\n     addService(del);\n \n     // NodeManager level dispatcher\n     this.dispatcher \u003d new AsyncDispatcher(\"NM Event dispatcher\");\n \n     nodeHealthChecker \u003d\n         new NodeHealthCheckerService(\n             getNodeHealthScriptRunner(conf), dirsHandler);\n     addService(nodeHealthChecker);\n \n \n     ((NMContext)context).setContainerExecutor(exec);\n+    ((NMContext)context).setDeletionService(del);\n \n     nodeLabelsProvider \u003d createNodeLabelsProvider(conf);\n \n     if (null \u003d\u003d nodeLabelsProvider) {\n       nodeStatusUpdater \u003d\n           createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n     } else {\n       addIfService(nodeLabelsProvider);\n       nodeStatusUpdater \u003d\n           createNodeStatusUpdater(context, dispatcher, nodeHealthChecker,\n               nodeLabelsProvider);\n     }\n \n     nodeResourceMonitor \u003d createNodeResourceMonitor();\n     addService(nodeResourceMonitor);\n     ((NMContext) context).setNodeResourceMonitor(nodeResourceMonitor);\n \n     containerManager \u003d\n         createContainerManager(context, exec, del, nodeStatusUpdater,\n         this.aclsManager, dirsHandler);\n     addService(containerManager);\n     ((NMContext) context).setContainerManager(containerManager);\n \n     WebServer webServer \u003d createWebServer(context, containerManager\n         .getContainersMonitor(), this.aclsManager, dirsHandler);\n     addService(webServer);\n     ((NMContext) context).setWebServer(webServer);\n \n     ((NMContext) context).setQueueableContainerAllocator(\n         new OpportunisticContainerAllocator(\n             context.getContainerTokenSecretManager()));\n \n     dispatcher.register(ContainerManagerEventType.class, containerManager);\n     dispatcher.register(NodeManagerEventType.class, this);\n     addService(dispatcher);\n \n     pauseMonitor \u003d new JvmPauseMonitor();\n     addService(pauseMonitor);\n     metrics.getJvmMetrics().setPauseMonitor(pauseMonitor);\n \n     DefaultMetricsSystem.initialize(\"NodeManager\");\n \n     if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n       this.nmCollectorService \u003d createNMCollectorService(context);\n       addService(nmCollectorService);\n     }\n \n     // StatusUpdater should be added last so that it get started last \n     // so that we make sure everything is up before registering with RM. \n     addService(nodeStatusUpdater);\n     ((NMContext) context).setNodeStatusUpdater(nodeStatusUpdater);\n     nmStore.setNodeStatusUpdater(nodeStatusUpdater);\n \n     super.serviceInit(conf);\n     // TODO add local dirs to del\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceInit(Configuration conf) throws Exception {\n    rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n            .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n        YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n\n    try {\n      initAndStartRecoveryStore(conf);\n    } catch (IOException e) {\n      String recoveryDirName \u003d conf.get(YarnConfiguration.NM_RECOVERY_DIR);\n      throw new\n          YarnRuntimeException(\"Unable to initialize recovery directory at \"\n              + recoveryDirName, e);\n    }\n\n    NMContainerTokenSecretManager containerTokenSecretManager \u003d\n        new NMContainerTokenSecretManager(conf, nmStore);\n\n    NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n        new NMTokenSecretManagerInNM(nmStore);\n\n    recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n    \n    this.aclsManager \u003d new ApplicationACLsManager(conf);\n\n    this.dirsHandler \u003d new LocalDirsHandlerService(metrics);\n\n    boolean isDistSchedulingEnabled \u003d\n        conf.getBoolean(YarnConfiguration.DIST_SCHEDULING_ENABLED,\n            YarnConfiguration.DEFAULT_DIST_SCHEDULING_ENABLED);\n\n    this.context \u003d createNMContext(containerTokenSecretManager,\n        nmTokenSecretManager, nmStore, isDistSchedulingEnabled, conf);\n\n    ResourcePluginManager pluginManager \u003d createResourcePluginManager();\n    pluginManager.initialize(context);\n    ((NMContext)context).setResourcePluginManager(pluginManager);\n\n    ContainerExecutor exec \u003d createContainerExecutor(conf);\n    try {\n      exec.init(context);\n    } catch (IOException e) {\n      throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n    }    \n    DeletionService del \u003d createDeletionService(exec);\n    addService(del);\n\n    // NodeManager level dispatcher\n    this.dispatcher \u003d new AsyncDispatcher(\"NM Event dispatcher\");\n\n    nodeHealthChecker \u003d\n        new NodeHealthCheckerService(\n            getNodeHealthScriptRunner(conf), dirsHandler);\n    addService(nodeHealthChecker);\n\n\n    ((NMContext)context).setContainerExecutor(exec);\n    ((NMContext)context).setDeletionService(del);\n\n    nodeLabelsProvider \u003d createNodeLabelsProvider(conf);\n\n    if (null \u003d\u003d nodeLabelsProvider) {\n      nodeStatusUpdater \u003d\n          createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n    } else {\n      addIfService(nodeLabelsProvider);\n      nodeStatusUpdater \u003d\n          createNodeStatusUpdater(context, dispatcher, nodeHealthChecker,\n              nodeLabelsProvider);\n    }\n\n    nodeResourceMonitor \u003d createNodeResourceMonitor();\n    addService(nodeResourceMonitor);\n    ((NMContext) context).setNodeResourceMonitor(nodeResourceMonitor);\n\n    containerManager \u003d\n        createContainerManager(context, exec, del, nodeStatusUpdater,\n        this.aclsManager, dirsHandler);\n    addService(containerManager);\n    ((NMContext) context).setContainerManager(containerManager);\n\n    WebServer webServer \u003d createWebServer(context, containerManager\n        .getContainersMonitor(), this.aclsManager, dirsHandler);\n    addService(webServer);\n    ((NMContext) context).setWebServer(webServer);\n\n    ((NMContext) context).setQueueableContainerAllocator(\n        new OpportunisticContainerAllocator(\n            context.getContainerTokenSecretManager()));\n\n    dispatcher.register(ContainerManagerEventType.class, containerManager);\n    dispatcher.register(NodeManagerEventType.class, this);\n    addService(dispatcher);\n\n    pauseMonitor \u003d new JvmPauseMonitor();\n    addService(pauseMonitor);\n    metrics.getJvmMetrics().setPauseMonitor(pauseMonitor);\n\n    DefaultMetricsSystem.initialize(\"NodeManager\");\n\n    if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n      this.nmCollectorService \u003d createNMCollectorService(context);\n      addService(nmCollectorService);\n    }\n\n    // StatusUpdater should be added last so that it get started last \n    // so that we make sure everything is up before registering with RM. \n    addService(nodeStatusUpdater);\n    ((NMContext) context).setNodeStatusUpdater(nodeStatusUpdater);\n    nmStore.setNodeStatusUpdater(nodeStatusUpdater);\n\n    super.serviceInit(conf);\n    // TODO add local dirs to del\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java",
      "extendedDetails": {}
    },
    "7f515f57ede74dae787994f37bfafd5d20c9aa4c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7585. NodeManager should go unhealthy when state store throws DBException. Contributed by Wilfred Spiegelenburg.\n",
      "commitDate": "02/01/18 6:03 PM",
      "commitName": "7f515f57ede74dae787994f37bfafd5d20c9aa4c",
      "commitAuthor": "Miklos Szegedi",
      "commitDateOld": "12/12/17 10:56 AM",
      "commitNameOld": "06f0eb2dce2a7a098f7844682ea6c232d0ddb0be",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 21.3,
      "commitsBetweenForRepo": 119,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,111 +1,112 @@\n   protected void serviceInit(Configuration conf) throws Exception {\n     rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n             .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n         YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n \n     try {\n       initAndStartRecoveryStore(conf);\n     } catch (IOException e) {\n       String recoveryDirName \u003d conf.get(YarnConfiguration.NM_RECOVERY_DIR);\n       throw new\n           YarnRuntimeException(\"Unable to initialize recovery directory at \"\n               + recoveryDirName, e);\n     }\n \n     NMContainerTokenSecretManager containerTokenSecretManager \u003d\n         new NMContainerTokenSecretManager(conf, nmStore);\n \n     NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n         new NMTokenSecretManagerInNM(nmStore);\n \n     recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n     \n     this.aclsManager \u003d new ApplicationACLsManager(conf);\n \n     this.dirsHandler \u003d new LocalDirsHandlerService(metrics);\n \n     boolean isDistSchedulingEnabled \u003d\n         conf.getBoolean(YarnConfiguration.DIST_SCHEDULING_ENABLED,\n             YarnConfiguration.DEFAULT_DIST_SCHEDULING_ENABLED);\n \n     this.context \u003d createNMContext(containerTokenSecretManager,\n         nmTokenSecretManager, nmStore, isDistSchedulingEnabled, conf);\n \n     ResourcePluginManager pluginManager \u003d createResourcePluginManager();\n     pluginManager.initialize(context);\n     ((NMContext)context).setResourcePluginManager(pluginManager);\n \n     ContainerExecutor exec \u003d createContainerExecutor(conf);\n     try {\n       exec.init(context);\n     } catch (IOException e) {\n       throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n     }    \n     DeletionService del \u003d createDeletionService(exec);\n     addService(del);\n \n     // NodeManager level dispatcher\n     this.dispatcher \u003d new AsyncDispatcher(\"NM Event dispatcher\");\n \n     nodeHealthChecker \u003d\n         new NodeHealthCheckerService(\n             getNodeHealthScriptRunner(conf), dirsHandler);\n     addService(nodeHealthChecker);\n \n \n     ((NMContext)context).setContainerExecutor(exec);\n \n     nodeLabelsProvider \u003d createNodeLabelsProvider(conf);\n \n     if (null \u003d\u003d nodeLabelsProvider) {\n       nodeStatusUpdater \u003d\n           createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n     } else {\n       addIfService(nodeLabelsProvider);\n       nodeStatusUpdater \u003d\n           createNodeStatusUpdater(context, dispatcher, nodeHealthChecker,\n               nodeLabelsProvider);\n     }\n \n     nodeResourceMonitor \u003d createNodeResourceMonitor();\n     addService(nodeResourceMonitor);\n     ((NMContext) context).setNodeResourceMonitor(nodeResourceMonitor);\n \n     containerManager \u003d\n         createContainerManager(context, exec, del, nodeStatusUpdater,\n         this.aclsManager, dirsHandler);\n     addService(containerManager);\n     ((NMContext) context).setContainerManager(containerManager);\n \n     WebServer webServer \u003d createWebServer(context, containerManager\n         .getContainersMonitor(), this.aclsManager, dirsHandler);\n     addService(webServer);\n     ((NMContext) context).setWebServer(webServer);\n \n     ((NMContext) context).setQueueableContainerAllocator(\n         new OpportunisticContainerAllocator(\n             context.getContainerTokenSecretManager()));\n \n     dispatcher.register(ContainerManagerEventType.class, containerManager);\n     dispatcher.register(NodeManagerEventType.class, this);\n     addService(dispatcher);\n \n     pauseMonitor \u003d new JvmPauseMonitor();\n     addService(pauseMonitor);\n     metrics.getJvmMetrics().setPauseMonitor(pauseMonitor);\n \n     DefaultMetricsSystem.initialize(\"NodeManager\");\n \n     if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n       this.nmCollectorService \u003d createNMCollectorService(context);\n       addService(nmCollectorService);\n     }\n \n     // StatusUpdater should be added last so that it get started last \n     // so that we make sure everything is up before registering with RM. \n     addService(nodeStatusUpdater);\n     ((NMContext) context).setNodeStatusUpdater(nodeStatusUpdater);\n+    nmStore.setNodeStatusUpdater(nodeStatusUpdater);\n \n     super.serviceInit(conf);\n     // TODO add local dirs to del\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceInit(Configuration conf) throws Exception {\n    rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n            .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n        YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n\n    try {\n      initAndStartRecoveryStore(conf);\n    } catch (IOException e) {\n      String recoveryDirName \u003d conf.get(YarnConfiguration.NM_RECOVERY_DIR);\n      throw new\n          YarnRuntimeException(\"Unable to initialize recovery directory at \"\n              + recoveryDirName, e);\n    }\n\n    NMContainerTokenSecretManager containerTokenSecretManager \u003d\n        new NMContainerTokenSecretManager(conf, nmStore);\n\n    NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n        new NMTokenSecretManagerInNM(nmStore);\n\n    recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n    \n    this.aclsManager \u003d new ApplicationACLsManager(conf);\n\n    this.dirsHandler \u003d new LocalDirsHandlerService(metrics);\n\n    boolean isDistSchedulingEnabled \u003d\n        conf.getBoolean(YarnConfiguration.DIST_SCHEDULING_ENABLED,\n            YarnConfiguration.DEFAULT_DIST_SCHEDULING_ENABLED);\n\n    this.context \u003d createNMContext(containerTokenSecretManager,\n        nmTokenSecretManager, nmStore, isDistSchedulingEnabled, conf);\n\n    ResourcePluginManager pluginManager \u003d createResourcePluginManager();\n    pluginManager.initialize(context);\n    ((NMContext)context).setResourcePluginManager(pluginManager);\n\n    ContainerExecutor exec \u003d createContainerExecutor(conf);\n    try {\n      exec.init(context);\n    } catch (IOException e) {\n      throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n    }    \n    DeletionService del \u003d createDeletionService(exec);\n    addService(del);\n\n    // NodeManager level dispatcher\n    this.dispatcher \u003d new AsyncDispatcher(\"NM Event dispatcher\");\n\n    nodeHealthChecker \u003d\n        new NodeHealthCheckerService(\n            getNodeHealthScriptRunner(conf), dirsHandler);\n    addService(nodeHealthChecker);\n\n\n    ((NMContext)context).setContainerExecutor(exec);\n\n    nodeLabelsProvider \u003d createNodeLabelsProvider(conf);\n\n    if (null \u003d\u003d nodeLabelsProvider) {\n      nodeStatusUpdater \u003d\n          createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n    } else {\n      addIfService(nodeLabelsProvider);\n      nodeStatusUpdater \u003d\n          createNodeStatusUpdater(context, dispatcher, nodeHealthChecker,\n              nodeLabelsProvider);\n    }\n\n    nodeResourceMonitor \u003d createNodeResourceMonitor();\n    addService(nodeResourceMonitor);\n    ((NMContext) context).setNodeResourceMonitor(nodeResourceMonitor);\n\n    containerManager \u003d\n        createContainerManager(context, exec, del, nodeStatusUpdater,\n        this.aclsManager, dirsHandler);\n    addService(containerManager);\n    ((NMContext) context).setContainerManager(containerManager);\n\n    WebServer webServer \u003d createWebServer(context, containerManager\n        .getContainersMonitor(), this.aclsManager, dirsHandler);\n    addService(webServer);\n    ((NMContext) context).setWebServer(webServer);\n\n    ((NMContext) context).setQueueableContainerAllocator(\n        new OpportunisticContainerAllocator(\n            context.getContainerTokenSecretManager()));\n\n    dispatcher.register(ContainerManagerEventType.class, containerManager);\n    dispatcher.register(NodeManagerEventType.class, this);\n    addService(dispatcher);\n\n    pauseMonitor \u003d new JvmPauseMonitor();\n    addService(pauseMonitor);\n    metrics.getJvmMetrics().setPauseMonitor(pauseMonitor);\n\n    DefaultMetricsSystem.initialize(\"NodeManager\");\n\n    if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n      this.nmCollectorService \u003d createNMCollectorService(context);\n      addService(nmCollectorService);\n    }\n\n    // StatusUpdater should be added last so that it get started last \n    // so that we make sure everything is up before registering with RM. \n    addService(nodeStatusUpdater);\n    ((NMContext) context).setNodeStatusUpdater(nodeStatusUpdater);\n    nmStore.setNodeStatusUpdater(nodeStatusUpdater);\n\n    super.serviceInit(conf);\n    // TODO add local dirs to del\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java",
      "extendedDetails": {}
    },
    "0cc98ae0ec69419ded066f3f7decf59728b35e9d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7396. NPE when accessing container logs due to null dirsHandler. Contributed by Jonathan Hung\n",
      "commitDate": "01/11/17 5:00 PM",
      "commitName": "0cc98ae0ec69419ded066f3f7decf59728b35e9d",
      "commitAuthor": "Jian He",
      "commitDateOld": "11/10/17 11:14 AM",
      "commitNameOld": "fa5cfc68f37c78b6cf26ce13247b9ff34da806cd",
      "commitAuthorOld": "Sunil G",
      "daysBetweenCommits": 21.24,
      "commitsBetweenForRepo": 130,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,110 +1,111 @@\n   protected void serviceInit(Configuration conf) throws Exception {\n     rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n             .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n         YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n \n     try {\n       initAndStartRecoveryStore(conf);\n     } catch (IOException e) {\n       String recoveryDirName \u003d conf.get(YarnConfiguration.NM_RECOVERY_DIR);\n       throw new\n           YarnRuntimeException(\"Unable to initialize recovery directory at \"\n               + recoveryDirName, e);\n     }\n \n     NMContainerTokenSecretManager containerTokenSecretManager \u003d\n         new NMContainerTokenSecretManager(conf, nmStore);\n \n     NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n         new NMTokenSecretManagerInNM(nmStore);\n \n     recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n     \n     this.aclsManager \u003d new ApplicationACLsManager(conf);\n \n+    this.dirsHandler \u003d new LocalDirsHandlerService(metrics);\n+\n     boolean isDistSchedulingEnabled \u003d\n         conf.getBoolean(YarnConfiguration.DIST_SCHEDULING_ENABLED,\n             YarnConfiguration.DEFAULT_DIST_SCHEDULING_ENABLED);\n \n     this.context \u003d createNMContext(containerTokenSecretManager,\n         nmTokenSecretManager, nmStore, isDistSchedulingEnabled, conf);\n \n     ResourcePluginManager pluginManager \u003d createResourcePluginManager();\n     pluginManager.initialize(context);\n     ((NMContext)context).setResourcePluginManager(pluginManager);\n \n     ContainerExecutor exec \u003d createContainerExecutor(conf);\n     try {\n       exec.init(context);\n     } catch (IOException e) {\n       throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n     }    \n     DeletionService del \u003d createDeletionService(exec);\n     addService(del);\n \n     // NodeManager level dispatcher\n     this.dispatcher \u003d new AsyncDispatcher(\"NM Event dispatcher\");\n \n-    dirsHandler \u003d new LocalDirsHandlerService(metrics);\n     nodeHealthChecker \u003d\n         new NodeHealthCheckerService(\n             getNodeHealthScriptRunner(conf), dirsHandler);\n     addService(nodeHealthChecker);\n \n \n     ((NMContext)context).setContainerExecutor(exec);\n \n     nodeLabelsProvider \u003d createNodeLabelsProvider(conf);\n \n     if (null \u003d\u003d nodeLabelsProvider) {\n       nodeStatusUpdater \u003d\n           createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n     } else {\n       addIfService(nodeLabelsProvider);\n       nodeStatusUpdater \u003d\n           createNodeStatusUpdater(context, dispatcher, nodeHealthChecker,\n               nodeLabelsProvider);\n     }\n \n     nodeResourceMonitor \u003d createNodeResourceMonitor();\n     addService(nodeResourceMonitor);\n     ((NMContext) context).setNodeResourceMonitor(nodeResourceMonitor);\n \n     containerManager \u003d\n         createContainerManager(context, exec, del, nodeStatusUpdater,\n         this.aclsManager, dirsHandler);\n     addService(containerManager);\n     ((NMContext) context).setContainerManager(containerManager);\n \n     WebServer webServer \u003d createWebServer(context, containerManager\n         .getContainersMonitor(), this.aclsManager, dirsHandler);\n     addService(webServer);\n     ((NMContext) context).setWebServer(webServer);\n \n     ((NMContext) context).setQueueableContainerAllocator(\n         new OpportunisticContainerAllocator(\n             context.getContainerTokenSecretManager()));\n \n     dispatcher.register(ContainerManagerEventType.class, containerManager);\n     dispatcher.register(NodeManagerEventType.class, this);\n     addService(dispatcher);\n \n     pauseMonitor \u003d new JvmPauseMonitor();\n     addService(pauseMonitor);\n     metrics.getJvmMetrics().setPauseMonitor(pauseMonitor);\n \n     DefaultMetricsSystem.initialize(\"NodeManager\");\n \n     if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n       this.nmCollectorService \u003d createNMCollectorService(context);\n       addService(nmCollectorService);\n     }\n \n     // StatusUpdater should be added last so that it get started last \n     // so that we make sure everything is up before registering with RM. \n     addService(nodeStatusUpdater);\n     ((NMContext) context).setNodeStatusUpdater(nodeStatusUpdater);\n \n     super.serviceInit(conf);\n     // TODO add local dirs to del\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceInit(Configuration conf) throws Exception {\n    rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n            .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n        YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n\n    try {\n      initAndStartRecoveryStore(conf);\n    } catch (IOException e) {\n      String recoveryDirName \u003d conf.get(YarnConfiguration.NM_RECOVERY_DIR);\n      throw new\n          YarnRuntimeException(\"Unable to initialize recovery directory at \"\n              + recoveryDirName, e);\n    }\n\n    NMContainerTokenSecretManager containerTokenSecretManager \u003d\n        new NMContainerTokenSecretManager(conf, nmStore);\n\n    NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n        new NMTokenSecretManagerInNM(nmStore);\n\n    recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n    \n    this.aclsManager \u003d new ApplicationACLsManager(conf);\n\n    this.dirsHandler \u003d new LocalDirsHandlerService(metrics);\n\n    boolean isDistSchedulingEnabled \u003d\n        conf.getBoolean(YarnConfiguration.DIST_SCHEDULING_ENABLED,\n            YarnConfiguration.DEFAULT_DIST_SCHEDULING_ENABLED);\n\n    this.context \u003d createNMContext(containerTokenSecretManager,\n        nmTokenSecretManager, nmStore, isDistSchedulingEnabled, conf);\n\n    ResourcePluginManager pluginManager \u003d createResourcePluginManager();\n    pluginManager.initialize(context);\n    ((NMContext)context).setResourcePluginManager(pluginManager);\n\n    ContainerExecutor exec \u003d createContainerExecutor(conf);\n    try {\n      exec.init(context);\n    } catch (IOException e) {\n      throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n    }    \n    DeletionService del \u003d createDeletionService(exec);\n    addService(del);\n\n    // NodeManager level dispatcher\n    this.dispatcher \u003d new AsyncDispatcher(\"NM Event dispatcher\");\n\n    nodeHealthChecker \u003d\n        new NodeHealthCheckerService(\n            getNodeHealthScriptRunner(conf), dirsHandler);\n    addService(nodeHealthChecker);\n\n\n    ((NMContext)context).setContainerExecutor(exec);\n\n    nodeLabelsProvider \u003d createNodeLabelsProvider(conf);\n\n    if (null \u003d\u003d nodeLabelsProvider) {\n      nodeStatusUpdater \u003d\n          createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n    } else {\n      addIfService(nodeLabelsProvider);\n      nodeStatusUpdater \u003d\n          createNodeStatusUpdater(context, dispatcher, nodeHealthChecker,\n              nodeLabelsProvider);\n    }\n\n    nodeResourceMonitor \u003d createNodeResourceMonitor();\n    addService(nodeResourceMonitor);\n    ((NMContext) context).setNodeResourceMonitor(nodeResourceMonitor);\n\n    containerManager \u003d\n        createContainerManager(context, exec, del, nodeStatusUpdater,\n        this.aclsManager, dirsHandler);\n    addService(containerManager);\n    ((NMContext) context).setContainerManager(containerManager);\n\n    WebServer webServer \u003d createWebServer(context, containerManager\n        .getContainersMonitor(), this.aclsManager, dirsHandler);\n    addService(webServer);\n    ((NMContext) context).setWebServer(webServer);\n\n    ((NMContext) context).setQueueableContainerAllocator(\n        new OpportunisticContainerAllocator(\n            context.getContainerTokenSecretManager()));\n\n    dispatcher.register(ContainerManagerEventType.class, containerManager);\n    dispatcher.register(NodeManagerEventType.class, this);\n    addService(dispatcher);\n\n    pauseMonitor \u003d new JvmPauseMonitor();\n    addService(pauseMonitor);\n    metrics.getJvmMetrics().setPauseMonitor(pauseMonitor);\n\n    DefaultMetricsSystem.initialize(\"NodeManager\");\n\n    if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n      this.nmCollectorService \u003d createNMCollectorService(context);\n      addService(nmCollectorService);\n    }\n\n    // StatusUpdater should be added last so that it get started last \n    // so that we make sure everything is up before registering with RM. \n    addService(nodeStatusUpdater);\n    ((NMContext) context).setNodeStatusUpdater(nodeStatusUpdater);\n\n    super.serviceInit(conf);\n    // TODO add local dirs to del\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java",
      "extendedDetails": {}
    },
    "fa5cfc68f37c78b6cf26ce13247b9ff34da806cd": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6620. Add support in NodeManager to isolate GPU devices by using CGroups. Contributed by Wangda Tan.\n",
      "commitDate": "11/10/17 11:14 AM",
      "commitName": "fa5cfc68f37c78b6cf26ce13247b9ff34da806cd",
      "commitAuthor": "Sunil G",
      "commitDateOld": "18/09/17 8:16 AM",
      "commitNameOld": "a4f9c7c9247801dd37beec6fc195622af1b884ad",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 23.12,
      "commitsBetweenForRepo": 202,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,108 +1,110 @@\n   protected void serviceInit(Configuration conf) throws Exception {\n     rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n             .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n         YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n \n     try {\n       initAndStartRecoveryStore(conf);\n     } catch (IOException e) {\n       String recoveryDirName \u003d conf.get(YarnConfiguration.NM_RECOVERY_DIR);\n       throw new\n           YarnRuntimeException(\"Unable to initialize recovery directory at \"\n               + recoveryDirName, e);\n     }\n \n     NMContainerTokenSecretManager containerTokenSecretManager \u003d\n         new NMContainerTokenSecretManager(conf, nmStore);\n \n     NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n         new NMTokenSecretManagerInNM(nmStore);\n \n     recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n     \n     this.aclsManager \u003d new ApplicationACLsManager(conf);\n \n-    ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n-        conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n-          DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n+    boolean isDistSchedulingEnabled \u003d\n+        conf.getBoolean(YarnConfiguration.DIST_SCHEDULING_ENABLED,\n+            YarnConfiguration.DEFAULT_DIST_SCHEDULING_ENABLED);\n+\n+    this.context \u003d createNMContext(containerTokenSecretManager,\n+        nmTokenSecretManager, nmStore, isDistSchedulingEnabled, conf);\n+\n+    ResourcePluginManager pluginManager \u003d createResourcePluginManager();\n+    pluginManager.initialize(context);\n+    ((NMContext)context).setResourcePluginManager(pluginManager);\n+\n+    ContainerExecutor exec \u003d createContainerExecutor(conf);\n     try {\n-      exec.init();\n+      exec.init(context);\n     } catch (IOException e) {\n       throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n     }    \n     DeletionService del \u003d createDeletionService(exec);\n     addService(del);\n \n     // NodeManager level dispatcher\n     this.dispatcher \u003d new AsyncDispatcher(\"NM Event dispatcher\");\n \n     dirsHandler \u003d new LocalDirsHandlerService(metrics);\n     nodeHealthChecker \u003d\n         new NodeHealthCheckerService(\n             getNodeHealthScriptRunner(conf), dirsHandler);\n     addService(nodeHealthChecker);\n \n-    boolean isDistSchedulingEnabled \u003d\n-        conf.getBoolean(YarnConfiguration.DIST_SCHEDULING_ENABLED,\n-            YarnConfiguration.DEFAULT_DIST_SCHEDULING_ENABLED);\n-\n-    this.context \u003d createNMContext(containerTokenSecretManager,\n-        nmTokenSecretManager, nmStore, isDistSchedulingEnabled, conf);\n-\n \n     ((NMContext)context).setContainerExecutor(exec);\n \n     nodeLabelsProvider \u003d createNodeLabelsProvider(conf);\n \n     if (null \u003d\u003d nodeLabelsProvider) {\n       nodeStatusUpdater \u003d\n           createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n     } else {\n       addIfService(nodeLabelsProvider);\n       nodeStatusUpdater \u003d\n           createNodeStatusUpdater(context, dispatcher, nodeHealthChecker,\n               nodeLabelsProvider);\n     }\n \n     nodeResourceMonitor \u003d createNodeResourceMonitor();\n     addService(nodeResourceMonitor);\n     ((NMContext) context).setNodeResourceMonitor(nodeResourceMonitor);\n \n     containerManager \u003d\n         createContainerManager(context, exec, del, nodeStatusUpdater,\n         this.aclsManager, dirsHandler);\n     addService(containerManager);\n     ((NMContext) context).setContainerManager(containerManager);\n \n     WebServer webServer \u003d createWebServer(context, containerManager\n         .getContainersMonitor(), this.aclsManager, dirsHandler);\n     addService(webServer);\n     ((NMContext) context).setWebServer(webServer);\n \n     ((NMContext) context).setQueueableContainerAllocator(\n         new OpportunisticContainerAllocator(\n             context.getContainerTokenSecretManager()));\n \n     dispatcher.register(ContainerManagerEventType.class, containerManager);\n     dispatcher.register(NodeManagerEventType.class, this);\n     addService(dispatcher);\n \n     pauseMonitor \u003d new JvmPauseMonitor();\n     addService(pauseMonitor);\n     metrics.getJvmMetrics().setPauseMonitor(pauseMonitor);\n \n     DefaultMetricsSystem.initialize(\"NodeManager\");\n \n     if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n       this.nmCollectorService \u003d createNMCollectorService(context);\n       addService(nmCollectorService);\n     }\n \n     // StatusUpdater should be added last so that it get started last \n     // so that we make sure everything is up before registering with RM. \n     addService(nodeStatusUpdater);\n     ((NMContext) context).setNodeStatusUpdater(nodeStatusUpdater);\n \n     super.serviceInit(conf);\n     // TODO add local dirs to del\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceInit(Configuration conf) throws Exception {\n    rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n            .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n        YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n\n    try {\n      initAndStartRecoveryStore(conf);\n    } catch (IOException e) {\n      String recoveryDirName \u003d conf.get(YarnConfiguration.NM_RECOVERY_DIR);\n      throw new\n          YarnRuntimeException(\"Unable to initialize recovery directory at \"\n              + recoveryDirName, e);\n    }\n\n    NMContainerTokenSecretManager containerTokenSecretManager \u003d\n        new NMContainerTokenSecretManager(conf, nmStore);\n\n    NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n        new NMTokenSecretManagerInNM(nmStore);\n\n    recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n    \n    this.aclsManager \u003d new ApplicationACLsManager(conf);\n\n    boolean isDistSchedulingEnabled \u003d\n        conf.getBoolean(YarnConfiguration.DIST_SCHEDULING_ENABLED,\n            YarnConfiguration.DEFAULT_DIST_SCHEDULING_ENABLED);\n\n    this.context \u003d createNMContext(containerTokenSecretManager,\n        nmTokenSecretManager, nmStore, isDistSchedulingEnabled, conf);\n\n    ResourcePluginManager pluginManager \u003d createResourcePluginManager();\n    pluginManager.initialize(context);\n    ((NMContext)context).setResourcePluginManager(pluginManager);\n\n    ContainerExecutor exec \u003d createContainerExecutor(conf);\n    try {\n      exec.init(context);\n    } catch (IOException e) {\n      throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n    }    \n    DeletionService del \u003d createDeletionService(exec);\n    addService(del);\n\n    // NodeManager level dispatcher\n    this.dispatcher \u003d new AsyncDispatcher(\"NM Event dispatcher\");\n\n    dirsHandler \u003d new LocalDirsHandlerService(metrics);\n    nodeHealthChecker \u003d\n        new NodeHealthCheckerService(\n            getNodeHealthScriptRunner(conf), dirsHandler);\n    addService(nodeHealthChecker);\n\n\n    ((NMContext)context).setContainerExecutor(exec);\n\n    nodeLabelsProvider \u003d createNodeLabelsProvider(conf);\n\n    if (null \u003d\u003d nodeLabelsProvider) {\n      nodeStatusUpdater \u003d\n          createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n    } else {\n      addIfService(nodeLabelsProvider);\n      nodeStatusUpdater \u003d\n          createNodeStatusUpdater(context, dispatcher, nodeHealthChecker,\n              nodeLabelsProvider);\n    }\n\n    nodeResourceMonitor \u003d createNodeResourceMonitor();\n    addService(nodeResourceMonitor);\n    ((NMContext) context).setNodeResourceMonitor(nodeResourceMonitor);\n\n    containerManager \u003d\n        createContainerManager(context, exec, del, nodeStatusUpdater,\n        this.aclsManager, dirsHandler);\n    addService(containerManager);\n    ((NMContext) context).setContainerManager(containerManager);\n\n    WebServer webServer \u003d createWebServer(context, containerManager\n        .getContainersMonitor(), this.aclsManager, dirsHandler);\n    addService(webServer);\n    ((NMContext) context).setWebServer(webServer);\n\n    ((NMContext) context).setQueueableContainerAllocator(\n        new OpportunisticContainerAllocator(\n            context.getContainerTokenSecretManager()));\n\n    dispatcher.register(ContainerManagerEventType.class, containerManager);\n    dispatcher.register(NodeManagerEventType.class, this);\n    addService(dispatcher);\n\n    pauseMonitor \u003d new JvmPauseMonitor();\n    addService(pauseMonitor);\n    metrics.getJvmMetrics().setPauseMonitor(pauseMonitor);\n\n    DefaultMetricsSystem.initialize(\"NodeManager\");\n\n    if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n      this.nmCollectorService \u003d createNMCollectorService(context);\n      addService(nmCollectorService);\n    }\n\n    // StatusUpdater should be added last so that it get started last \n    // so that we make sure everything is up before registering with RM. \n    addService(nodeStatusUpdater);\n    ((NMContext) context).setNodeStatusUpdater(nodeStatusUpdater);\n\n    super.serviceInit(conf);\n    // TODO add local dirs to del\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java",
      "extendedDetails": {}
    },
    "dd43b895c2e50fa97cb7327be77509b87dad1823": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6202. Configuration item Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY is disregarded\n(Contributed by Yufei Gu via Daniel Templeton)\n",
      "commitDate": "19/04/17 11:44 AM",
      "commitName": "dd43b895c2e50fa97cb7327be77509b87dad1823",
      "commitAuthor": "Daniel Templeton",
      "commitDateOld": "07/04/17 2:28 PM",
      "commitNameOld": "63f7322522e0ab223ceb91440636eb62ca0a3e41",
      "commitAuthorOld": "Robert Kanter",
      "daysBetweenCommits": 11.89,
      "commitsBetweenForRepo": 58,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,111 +1,108 @@\n   protected void serviceInit(Configuration conf) throws Exception {\n-\n-    conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n-\n     rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n             .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n         YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n \n     try {\n       initAndStartRecoveryStore(conf);\n     } catch (IOException e) {\n       String recoveryDirName \u003d conf.get(YarnConfiguration.NM_RECOVERY_DIR);\n       throw new\n           YarnRuntimeException(\"Unable to initialize recovery directory at \"\n               + recoveryDirName, e);\n     }\n \n     NMContainerTokenSecretManager containerTokenSecretManager \u003d\n         new NMContainerTokenSecretManager(conf, nmStore);\n \n     NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n         new NMTokenSecretManagerInNM(nmStore);\n \n     recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n     \n     this.aclsManager \u003d new ApplicationACLsManager(conf);\n \n     ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n         conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n           DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n     try {\n       exec.init();\n     } catch (IOException e) {\n       throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n     }    \n     DeletionService del \u003d createDeletionService(exec);\n     addService(del);\n \n     // NodeManager level dispatcher\n     this.dispatcher \u003d new AsyncDispatcher(\"NM Event dispatcher\");\n \n     dirsHandler \u003d new LocalDirsHandlerService(metrics);\n     nodeHealthChecker \u003d\n         new NodeHealthCheckerService(\n             getNodeHealthScriptRunner(conf), dirsHandler);\n     addService(nodeHealthChecker);\n \n     boolean isDistSchedulingEnabled \u003d\n         conf.getBoolean(YarnConfiguration.DIST_SCHEDULING_ENABLED,\n             YarnConfiguration.DEFAULT_DIST_SCHEDULING_ENABLED);\n \n     this.context \u003d createNMContext(containerTokenSecretManager,\n         nmTokenSecretManager, nmStore, isDistSchedulingEnabled, conf);\n \n \n     ((NMContext)context).setContainerExecutor(exec);\n \n     nodeLabelsProvider \u003d createNodeLabelsProvider(conf);\n \n     if (null \u003d\u003d nodeLabelsProvider) {\n       nodeStatusUpdater \u003d\n           createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n     } else {\n       addIfService(nodeLabelsProvider);\n       nodeStatusUpdater \u003d\n           createNodeStatusUpdater(context, dispatcher, nodeHealthChecker,\n               nodeLabelsProvider);\n     }\n \n     nodeResourceMonitor \u003d createNodeResourceMonitor();\n     addService(nodeResourceMonitor);\n     ((NMContext) context).setNodeResourceMonitor(nodeResourceMonitor);\n \n     containerManager \u003d\n         createContainerManager(context, exec, del, nodeStatusUpdater,\n         this.aclsManager, dirsHandler);\n     addService(containerManager);\n     ((NMContext) context).setContainerManager(containerManager);\n \n     WebServer webServer \u003d createWebServer(context, containerManager\n         .getContainersMonitor(), this.aclsManager, dirsHandler);\n     addService(webServer);\n     ((NMContext) context).setWebServer(webServer);\n \n     ((NMContext) context).setQueueableContainerAllocator(\n         new OpportunisticContainerAllocator(\n             context.getContainerTokenSecretManager()));\n \n     dispatcher.register(ContainerManagerEventType.class, containerManager);\n     dispatcher.register(NodeManagerEventType.class, this);\n     addService(dispatcher);\n \n     pauseMonitor \u003d new JvmPauseMonitor();\n     addService(pauseMonitor);\n     metrics.getJvmMetrics().setPauseMonitor(pauseMonitor);\n \n     DefaultMetricsSystem.initialize(\"NodeManager\");\n \n     if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n       this.nmCollectorService \u003d createNMCollectorService(context);\n       addService(nmCollectorService);\n     }\n \n     // StatusUpdater should be added last so that it get started last \n     // so that we make sure everything is up before registering with RM. \n     addService(nodeStatusUpdater);\n     ((NMContext) context).setNodeStatusUpdater(nodeStatusUpdater);\n \n     super.serviceInit(conf);\n     // TODO add local dirs to del\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceInit(Configuration conf) throws Exception {\n    rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n            .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n        YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n\n    try {\n      initAndStartRecoveryStore(conf);\n    } catch (IOException e) {\n      String recoveryDirName \u003d conf.get(YarnConfiguration.NM_RECOVERY_DIR);\n      throw new\n          YarnRuntimeException(\"Unable to initialize recovery directory at \"\n              + recoveryDirName, e);\n    }\n\n    NMContainerTokenSecretManager containerTokenSecretManager \u003d\n        new NMContainerTokenSecretManager(conf, nmStore);\n\n    NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n        new NMTokenSecretManagerInNM(nmStore);\n\n    recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n    \n    this.aclsManager \u003d new ApplicationACLsManager(conf);\n\n    ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n        conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n          DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n    try {\n      exec.init();\n    } catch (IOException e) {\n      throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n    }    \n    DeletionService del \u003d createDeletionService(exec);\n    addService(del);\n\n    // NodeManager level dispatcher\n    this.dispatcher \u003d new AsyncDispatcher(\"NM Event dispatcher\");\n\n    dirsHandler \u003d new LocalDirsHandlerService(metrics);\n    nodeHealthChecker \u003d\n        new NodeHealthCheckerService(\n            getNodeHealthScriptRunner(conf), dirsHandler);\n    addService(nodeHealthChecker);\n\n    boolean isDistSchedulingEnabled \u003d\n        conf.getBoolean(YarnConfiguration.DIST_SCHEDULING_ENABLED,\n            YarnConfiguration.DEFAULT_DIST_SCHEDULING_ENABLED);\n\n    this.context \u003d createNMContext(containerTokenSecretManager,\n        nmTokenSecretManager, nmStore, isDistSchedulingEnabled, conf);\n\n\n    ((NMContext)context).setContainerExecutor(exec);\n\n    nodeLabelsProvider \u003d createNodeLabelsProvider(conf);\n\n    if (null \u003d\u003d nodeLabelsProvider) {\n      nodeStatusUpdater \u003d\n          createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n    } else {\n      addIfService(nodeLabelsProvider);\n      nodeStatusUpdater \u003d\n          createNodeStatusUpdater(context, dispatcher, nodeHealthChecker,\n              nodeLabelsProvider);\n    }\n\n    nodeResourceMonitor \u003d createNodeResourceMonitor();\n    addService(nodeResourceMonitor);\n    ((NMContext) context).setNodeResourceMonitor(nodeResourceMonitor);\n\n    containerManager \u003d\n        createContainerManager(context, exec, del, nodeStatusUpdater,\n        this.aclsManager, dirsHandler);\n    addService(containerManager);\n    ((NMContext) context).setContainerManager(containerManager);\n\n    WebServer webServer \u003d createWebServer(context, containerManager\n        .getContainersMonitor(), this.aclsManager, dirsHandler);\n    addService(webServer);\n    ((NMContext) context).setWebServer(webServer);\n\n    ((NMContext) context).setQueueableContainerAllocator(\n        new OpportunisticContainerAllocator(\n            context.getContainerTokenSecretManager()));\n\n    dispatcher.register(ContainerManagerEventType.class, containerManager);\n    dispatcher.register(NodeManagerEventType.class, this);\n    addService(dispatcher);\n\n    pauseMonitor \u003d new JvmPauseMonitor();\n    addService(pauseMonitor);\n    metrics.getJvmMetrics().setPauseMonitor(pauseMonitor);\n\n    DefaultMetricsSystem.initialize(\"NodeManager\");\n\n    if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n      this.nmCollectorService \u003d createNMCollectorService(context);\n      addService(nmCollectorService);\n    }\n\n    // StatusUpdater should be added last so that it get started last \n    // so that we make sure everything is up before registering with RM. \n    addService(nodeStatusUpdater);\n    ((NMContext) context).setNodeStatusUpdater(nodeStatusUpdater);\n\n    super.serviceInit(conf);\n    // TODO add local dirs to del\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java",
      "extendedDetails": {}
    },
    "a59df15757fac7f917cb96fc8fcfeb7017475e4f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6015. AsyncDispatcher thread name can be set to improved debugging. Contributed by Ajith S.\n",
      "commitDate": "06/01/17 6:41 PM",
      "commitName": "a59df15757fac7f917cb96fc8fcfeb7017475e4f",
      "commitAuthor": "Naganarasimha",
      "commitDateOld": "16/12/16 8:14 AM",
      "commitNameOld": "2273a74c1f3895163046cca09ff5e983df301d22",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 21.44,
      "commitsBetweenForRepo": 83,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,111 +1,111 @@\n   protected void serviceInit(Configuration conf) throws Exception {\n \n     conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n \n     rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n             .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n         YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n \n     try {\n       initAndStartRecoveryStore(conf);\n     } catch (IOException e) {\n       String recoveryDirName \u003d conf.get(YarnConfiguration.NM_RECOVERY_DIR);\n       throw new\n           YarnRuntimeException(\"Unable to initialize recovery directory at \"\n               + recoveryDirName, e);\n     }\n \n     NMContainerTokenSecretManager containerTokenSecretManager \u003d\n         new NMContainerTokenSecretManager(conf, nmStore);\n \n     NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n         new NMTokenSecretManagerInNM(nmStore);\n \n     recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n     \n     this.aclsManager \u003d new ApplicationACLsManager(conf);\n \n     ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n         conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n           DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n     try {\n       exec.init();\n     } catch (IOException e) {\n       throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n     }    \n     DeletionService del \u003d createDeletionService(exec);\n     addService(del);\n \n     // NodeManager level dispatcher\n-    this.dispatcher \u003d new AsyncDispatcher();\n+    this.dispatcher \u003d new AsyncDispatcher(\"NM Event dispatcher\");\n \n     dirsHandler \u003d new LocalDirsHandlerService(metrics);\n     nodeHealthChecker \u003d\n         new NodeHealthCheckerService(\n             getNodeHealthScriptRunner(conf), dirsHandler);\n     addService(nodeHealthChecker);\n \n     boolean isDistSchedulingEnabled \u003d\n         conf.getBoolean(YarnConfiguration.DIST_SCHEDULING_ENABLED,\n             YarnConfiguration.DEFAULT_DIST_SCHEDULING_ENABLED);\n \n     this.context \u003d createNMContext(containerTokenSecretManager,\n         nmTokenSecretManager, nmStore, isDistSchedulingEnabled, conf);\n \n \n     ((NMContext)context).setContainerExecutor(exec);\n \n     nodeLabelsProvider \u003d createNodeLabelsProvider(conf);\n \n     if (null \u003d\u003d nodeLabelsProvider) {\n       nodeStatusUpdater \u003d\n           createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n     } else {\n       addIfService(nodeLabelsProvider);\n       nodeStatusUpdater \u003d\n           createNodeStatusUpdater(context, dispatcher, nodeHealthChecker,\n               nodeLabelsProvider);\n     }\n \n     nodeResourceMonitor \u003d createNodeResourceMonitor();\n     addService(nodeResourceMonitor);\n     ((NMContext) context).setNodeResourceMonitor(nodeResourceMonitor);\n \n     containerManager \u003d\n         createContainerManager(context, exec, del, nodeStatusUpdater,\n         this.aclsManager, dirsHandler);\n     addService(containerManager);\n     ((NMContext) context).setContainerManager(containerManager);\n \n     WebServer webServer \u003d createWebServer(context, containerManager\n         .getContainersMonitor(), this.aclsManager, dirsHandler);\n     addService(webServer);\n     ((NMContext) context).setWebServer(webServer);\n \n     ((NMContext) context).setQueueableContainerAllocator(\n         new OpportunisticContainerAllocator(\n             context.getContainerTokenSecretManager()));\n \n     dispatcher.register(ContainerManagerEventType.class, containerManager);\n     dispatcher.register(NodeManagerEventType.class, this);\n     addService(dispatcher);\n \n     pauseMonitor \u003d new JvmPauseMonitor();\n     addService(pauseMonitor);\n     metrics.getJvmMetrics().setPauseMonitor(pauseMonitor);\n \n     DefaultMetricsSystem.initialize(\"NodeManager\");\n \n     if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n       this.nmCollectorService \u003d createNMCollectorService(context);\n       addService(nmCollectorService);\n     }\n \n     // StatusUpdater should be added last so that it get started last \n     // so that we make sure everything is up before registering with RM. \n     addService(nodeStatusUpdater);\n     ((NMContext) context).setNodeStatusUpdater(nodeStatusUpdater);\n \n     super.serviceInit(conf);\n     // TODO add local dirs to del\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceInit(Configuration conf) throws Exception {\n\n    conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n\n    rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n            .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n        YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n\n    try {\n      initAndStartRecoveryStore(conf);\n    } catch (IOException e) {\n      String recoveryDirName \u003d conf.get(YarnConfiguration.NM_RECOVERY_DIR);\n      throw new\n          YarnRuntimeException(\"Unable to initialize recovery directory at \"\n              + recoveryDirName, e);\n    }\n\n    NMContainerTokenSecretManager containerTokenSecretManager \u003d\n        new NMContainerTokenSecretManager(conf, nmStore);\n\n    NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n        new NMTokenSecretManagerInNM(nmStore);\n\n    recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n    \n    this.aclsManager \u003d new ApplicationACLsManager(conf);\n\n    ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n        conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n          DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n    try {\n      exec.init();\n    } catch (IOException e) {\n      throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n    }    \n    DeletionService del \u003d createDeletionService(exec);\n    addService(del);\n\n    // NodeManager level dispatcher\n    this.dispatcher \u003d new AsyncDispatcher(\"NM Event dispatcher\");\n\n    dirsHandler \u003d new LocalDirsHandlerService(metrics);\n    nodeHealthChecker \u003d\n        new NodeHealthCheckerService(\n            getNodeHealthScriptRunner(conf), dirsHandler);\n    addService(nodeHealthChecker);\n\n    boolean isDistSchedulingEnabled \u003d\n        conf.getBoolean(YarnConfiguration.DIST_SCHEDULING_ENABLED,\n            YarnConfiguration.DEFAULT_DIST_SCHEDULING_ENABLED);\n\n    this.context \u003d createNMContext(containerTokenSecretManager,\n        nmTokenSecretManager, nmStore, isDistSchedulingEnabled, conf);\n\n\n    ((NMContext)context).setContainerExecutor(exec);\n\n    nodeLabelsProvider \u003d createNodeLabelsProvider(conf);\n\n    if (null \u003d\u003d nodeLabelsProvider) {\n      nodeStatusUpdater \u003d\n          createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n    } else {\n      addIfService(nodeLabelsProvider);\n      nodeStatusUpdater \u003d\n          createNodeStatusUpdater(context, dispatcher, nodeHealthChecker,\n              nodeLabelsProvider);\n    }\n\n    nodeResourceMonitor \u003d createNodeResourceMonitor();\n    addService(nodeResourceMonitor);\n    ((NMContext) context).setNodeResourceMonitor(nodeResourceMonitor);\n\n    containerManager \u003d\n        createContainerManager(context, exec, del, nodeStatusUpdater,\n        this.aclsManager, dirsHandler);\n    addService(containerManager);\n    ((NMContext) context).setContainerManager(containerManager);\n\n    WebServer webServer \u003d createWebServer(context, containerManager\n        .getContainersMonitor(), this.aclsManager, dirsHandler);\n    addService(webServer);\n    ((NMContext) context).setWebServer(webServer);\n\n    ((NMContext) context).setQueueableContainerAllocator(\n        new OpportunisticContainerAllocator(\n            context.getContainerTokenSecretManager()));\n\n    dispatcher.register(ContainerManagerEventType.class, containerManager);\n    dispatcher.register(NodeManagerEventType.class, this);\n    addService(dispatcher);\n\n    pauseMonitor \u003d new JvmPauseMonitor();\n    addService(pauseMonitor);\n    metrics.getJvmMetrics().setPauseMonitor(pauseMonitor);\n\n    DefaultMetricsSystem.initialize(\"NodeManager\");\n\n    if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n      this.nmCollectorService \u003d createNMCollectorService(context);\n      addService(nmCollectorService);\n    }\n\n    // StatusUpdater should be added last so that it get started last \n    // so that we make sure everything is up before registering with RM. \n    addService(nodeStatusUpdater);\n    ((NMContext) context).setNodeStatusUpdater(nodeStatusUpdater);\n\n    super.serviceInit(conf);\n    // TODO add local dirs to del\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java",
      "extendedDetails": {}
    },
    "2273a74c1f3895163046cca09ff5e983df301d22": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5646. Add documentation and update config parameter names for scheduling of OPPORTUNISTIC containers. (Konstantinos Karanasos via asuresh)\n",
      "commitDate": "16/12/16 8:14 AM",
      "commitName": "2273a74c1f3895163046cca09ff5e983df301d22",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "15/11/16 7:56 AM",
      "commitNameOld": "3219b7b4ac7d12aee343f6ab2980b3357fc618b6",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 31.01,
      "commitsBetweenForRepo": 191,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,111 +1,111 @@\n   protected void serviceInit(Configuration conf) throws Exception {\n \n     conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n \n     rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n             .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n         YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n \n     try {\n       initAndStartRecoveryStore(conf);\n     } catch (IOException e) {\n       String recoveryDirName \u003d conf.get(YarnConfiguration.NM_RECOVERY_DIR);\n       throw new\n           YarnRuntimeException(\"Unable to initialize recovery directory at \"\n               + recoveryDirName, e);\n     }\n \n     NMContainerTokenSecretManager containerTokenSecretManager \u003d\n         new NMContainerTokenSecretManager(conf, nmStore);\n \n     NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n         new NMTokenSecretManagerInNM(nmStore);\n \n     recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n     \n     this.aclsManager \u003d new ApplicationACLsManager(conf);\n \n     ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n         conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n           DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n     try {\n       exec.init();\n     } catch (IOException e) {\n       throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n     }    \n     DeletionService del \u003d createDeletionService(exec);\n     addService(del);\n \n     // NodeManager level dispatcher\n     this.dispatcher \u003d new AsyncDispatcher();\n \n     dirsHandler \u003d new LocalDirsHandlerService(metrics);\n     nodeHealthChecker \u003d\n         new NodeHealthCheckerService(\n             getNodeHealthScriptRunner(conf), dirsHandler);\n     addService(nodeHealthChecker);\n \n     boolean isDistSchedulingEnabled \u003d\n         conf.getBoolean(YarnConfiguration.DIST_SCHEDULING_ENABLED,\n-            YarnConfiguration.DIST_SCHEDULING_ENABLED_DEFAULT);\n+            YarnConfiguration.DEFAULT_DIST_SCHEDULING_ENABLED);\n \n     this.context \u003d createNMContext(containerTokenSecretManager,\n         nmTokenSecretManager, nmStore, isDistSchedulingEnabled, conf);\n \n \n     ((NMContext)context).setContainerExecutor(exec);\n \n     nodeLabelsProvider \u003d createNodeLabelsProvider(conf);\n \n     if (null \u003d\u003d nodeLabelsProvider) {\n       nodeStatusUpdater \u003d\n           createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n     } else {\n       addIfService(nodeLabelsProvider);\n       nodeStatusUpdater \u003d\n           createNodeStatusUpdater(context, dispatcher, nodeHealthChecker,\n               nodeLabelsProvider);\n     }\n \n     nodeResourceMonitor \u003d createNodeResourceMonitor();\n     addService(nodeResourceMonitor);\n     ((NMContext) context).setNodeResourceMonitor(nodeResourceMonitor);\n \n     containerManager \u003d\n         createContainerManager(context, exec, del, nodeStatusUpdater,\n         this.aclsManager, dirsHandler);\n     addService(containerManager);\n     ((NMContext) context).setContainerManager(containerManager);\n \n     WebServer webServer \u003d createWebServer(context, containerManager\n         .getContainersMonitor(), this.aclsManager, dirsHandler);\n     addService(webServer);\n     ((NMContext) context).setWebServer(webServer);\n \n     ((NMContext) context).setQueueableContainerAllocator(\n         new OpportunisticContainerAllocator(\n             context.getContainerTokenSecretManager()));\n \n     dispatcher.register(ContainerManagerEventType.class, containerManager);\n     dispatcher.register(NodeManagerEventType.class, this);\n     addService(dispatcher);\n \n     pauseMonitor \u003d new JvmPauseMonitor();\n     addService(pauseMonitor);\n     metrics.getJvmMetrics().setPauseMonitor(pauseMonitor);\n \n     DefaultMetricsSystem.initialize(\"NodeManager\");\n \n     if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n       this.nmCollectorService \u003d createNMCollectorService(context);\n       addService(nmCollectorService);\n     }\n \n     // StatusUpdater should be added last so that it get started last \n     // so that we make sure everything is up before registering with RM. \n     addService(nodeStatusUpdater);\n     ((NMContext) context).setNodeStatusUpdater(nodeStatusUpdater);\n \n     super.serviceInit(conf);\n     // TODO add local dirs to del\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceInit(Configuration conf) throws Exception {\n\n    conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n\n    rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n            .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n        YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n\n    try {\n      initAndStartRecoveryStore(conf);\n    } catch (IOException e) {\n      String recoveryDirName \u003d conf.get(YarnConfiguration.NM_RECOVERY_DIR);\n      throw new\n          YarnRuntimeException(\"Unable to initialize recovery directory at \"\n              + recoveryDirName, e);\n    }\n\n    NMContainerTokenSecretManager containerTokenSecretManager \u003d\n        new NMContainerTokenSecretManager(conf, nmStore);\n\n    NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n        new NMTokenSecretManagerInNM(nmStore);\n\n    recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n    \n    this.aclsManager \u003d new ApplicationACLsManager(conf);\n\n    ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n        conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n          DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n    try {\n      exec.init();\n    } catch (IOException e) {\n      throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n    }    \n    DeletionService del \u003d createDeletionService(exec);\n    addService(del);\n\n    // NodeManager level dispatcher\n    this.dispatcher \u003d new AsyncDispatcher();\n\n    dirsHandler \u003d new LocalDirsHandlerService(metrics);\n    nodeHealthChecker \u003d\n        new NodeHealthCheckerService(\n            getNodeHealthScriptRunner(conf), dirsHandler);\n    addService(nodeHealthChecker);\n\n    boolean isDistSchedulingEnabled \u003d\n        conf.getBoolean(YarnConfiguration.DIST_SCHEDULING_ENABLED,\n            YarnConfiguration.DEFAULT_DIST_SCHEDULING_ENABLED);\n\n    this.context \u003d createNMContext(containerTokenSecretManager,\n        nmTokenSecretManager, nmStore, isDistSchedulingEnabled, conf);\n\n\n    ((NMContext)context).setContainerExecutor(exec);\n\n    nodeLabelsProvider \u003d createNodeLabelsProvider(conf);\n\n    if (null \u003d\u003d nodeLabelsProvider) {\n      nodeStatusUpdater \u003d\n          createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n    } else {\n      addIfService(nodeLabelsProvider);\n      nodeStatusUpdater \u003d\n          createNodeStatusUpdater(context, dispatcher, nodeHealthChecker,\n              nodeLabelsProvider);\n    }\n\n    nodeResourceMonitor \u003d createNodeResourceMonitor();\n    addService(nodeResourceMonitor);\n    ((NMContext) context).setNodeResourceMonitor(nodeResourceMonitor);\n\n    containerManager \u003d\n        createContainerManager(context, exec, del, nodeStatusUpdater,\n        this.aclsManager, dirsHandler);\n    addService(containerManager);\n    ((NMContext) context).setContainerManager(containerManager);\n\n    WebServer webServer \u003d createWebServer(context, containerManager\n        .getContainersMonitor(), this.aclsManager, dirsHandler);\n    addService(webServer);\n    ((NMContext) context).setWebServer(webServer);\n\n    ((NMContext) context).setQueueableContainerAllocator(\n        new OpportunisticContainerAllocator(\n            context.getContainerTokenSecretManager()));\n\n    dispatcher.register(ContainerManagerEventType.class, containerManager);\n    dispatcher.register(NodeManagerEventType.class, this);\n    addService(dispatcher);\n\n    pauseMonitor \u003d new JvmPauseMonitor();\n    addService(pauseMonitor);\n    metrics.getJvmMetrics().setPauseMonitor(pauseMonitor);\n\n    DefaultMetricsSystem.initialize(\"NodeManager\");\n\n    if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n      this.nmCollectorService \u003d createNMCollectorService(context);\n      addService(nmCollectorService);\n    }\n\n    // StatusUpdater should be added last so that it get started last \n    // so that we make sure everything is up before registering with RM. \n    addService(nodeStatusUpdater);\n    ((NMContext) context).setNodeStatusUpdater(nodeStatusUpdater);\n\n    super.serviceInit(conf);\n    // TODO add local dirs to del\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java",
      "extendedDetails": {}
    },
    "aa3cab1eb29c56368d15882d7260a994e615e8d8": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5799. Fix Opportunistic Allocation to set the correct value of Node Http Address. (asuresh)\n",
      "commitDate": "29/10/16 2:03 AM",
      "commitName": "aa3cab1eb29c56368d15882d7260a994e615e8d8",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "28/10/16 7:57 AM",
      "commitNameOld": "c017171da00a6cd71a2901c84a0298ce14a49e23",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 0.75,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,111 +1,111 @@\n   protected void serviceInit(Configuration conf) throws Exception {\n \n     conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n \n     rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n             .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n         YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n \n     try {\n       initAndStartRecoveryStore(conf);\n     } catch (IOException e) {\n       String recoveryDirName \u003d conf.get(YarnConfiguration.NM_RECOVERY_DIR);\n       throw new\n           YarnRuntimeException(\"Unable to initialize recovery directory at \"\n               + recoveryDirName, e);\n     }\n \n     NMContainerTokenSecretManager containerTokenSecretManager \u003d\n         new NMContainerTokenSecretManager(conf, nmStore);\n \n     NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n         new NMTokenSecretManagerInNM(nmStore);\n \n     recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n     \n     this.aclsManager \u003d new ApplicationACLsManager(conf);\n \n     ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n         conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n           DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n     try {\n       exec.init();\n     } catch (IOException e) {\n       throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n     }    \n     DeletionService del \u003d createDeletionService(exec);\n     addService(del);\n \n     // NodeManager level dispatcher\n     this.dispatcher \u003d new AsyncDispatcher();\n \n     dirsHandler \u003d new LocalDirsHandlerService(metrics);\n     nodeHealthChecker \u003d\n         new NodeHealthCheckerService(\n             getNodeHealthScriptRunner(conf), dirsHandler);\n     addService(nodeHealthChecker);\n \n     boolean isDistSchedulingEnabled \u003d\n         conf.getBoolean(YarnConfiguration.DIST_SCHEDULING_ENABLED,\n             YarnConfiguration.DIST_SCHEDULING_ENABLED_DEFAULT);\n \n     this.context \u003d createNMContext(containerTokenSecretManager,\n         nmTokenSecretManager, nmStore, isDistSchedulingEnabled, conf);\n \n \n     ((NMContext)context).setContainerExecutor(exec);\n \n     nodeLabelsProvider \u003d createNodeLabelsProvider(conf);\n \n     if (null \u003d\u003d nodeLabelsProvider) {\n       nodeStatusUpdater \u003d\n           createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n     } else {\n       addIfService(nodeLabelsProvider);\n       nodeStatusUpdater \u003d\n           createNodeStatusUpdater(context, dispatcher, nodeHealthChecker,\n               nodeLabelsProvider);\n     }\n \n     nodeResourceMonitor \u003d createNodeResourceMonitor();\n     addService(nodeResourceMonitor);\n     ((NMContext) context).setNodeResourceMonitor(nodeResourceMonitor);\n \n     containerManager \u003d\n         createContainerManager(context, exec, del, nodeStatusUpdater,\n         this.aclsManager, dirsHandler);\n     addService(containerManager);\n     ((NMContext) context).setContainerManager(containerManager);\n \n     WebServer webServer \u003d createWebServer(context, containerManager\n         .getContainersMonitor(), this.aclsManager, dirsHandler);\n     addService(webServer);\n     ((NMContext) context).setWebServer(webServer);\n \n     ((NMContext) context).setQueueableContainerAllocator(\n         new OpportunisticContainerAllocator(\n-            context.getContainerTokenSecretManager(), webServer.getPort()));\n+            context.getContainerTokenSecretManager()));\n \n     dispatcher.register(ContainerManagerEventType.class, containerManager);\n     dispatcher.register(NodeManagerEventType.class, this);\n     addService(dispatcher);\n \n     pauseMonitor \u003d new JvmPauseMonitor();\n     addService(pauseMonitor);\n     metrics.getJvmMetrics().setPauseMonitor(pauseMonitor);\n \n     DefaultMetricsSystem.initialize(\"NodeManager\");\n \n     if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n       this.nmCollectorService \u003d createNMCollectorService(context);\n       addService(nmCollectorService);\n     }\n \n     // StatusUpdater should be added last so that it get started last \n     // so that we make sure everything is up before registering with RM. \n     addService(nodeStatusUpdater);\n     ((NMContext) context).setNodeStatusUpdater(nodeStatusUpdater);\n \n     super.serviceInit(conf);\n     // TODO add local dirs to del\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceInit(Configuration conf) throws Exception {\n\n    conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n\n    rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n            .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n        YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n\n    try {\n      initAndStartRecoveryStore(conf);\n    } catch (IOException e) {\n      String recoveryDirName \u003d conf.get(YarnConfiguration.NM_RECOVERY_DIR);\n      throw new\n          YarnRuntimeException(\"Unable to initialize recovery directory at \"\n              + recoveryDirName, e);\n    }\n\n    NMContainerTokenSecretManager containerTokenSecretManager \u003d\n        new NMContainerTokenSecretManager(conf, nmStore);\n\n    NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n        new NMTokenSecretManagerInNM(nmStore);\n\n    recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n    \n    this.aclsManager \u003d new ApplicationACLsManager(conf);\n\n    ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n        conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n          DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n    try {\n      exec.init();\n    } catch (IOException e) {\n      throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n    }    \n    DeletionService del \u003d createDeletionService(exec);\n    addService(del);\n\n    // NodeManager level dispatcher\n    this.dispatcher \u003d new AsyncDispatcher();\n\n    dirsHandler \u003d new LocalDirsHandlerService(metrics);\n    nodeHealthChecker \u003d\n        new NodeHealthCheckerService(\n            getNodeHealthScriptRunner(conf), dirsHandler);\n    addService(nodeHealthChecker);\n\n    boolean isDistSchedulingEnabled \u003d\n        conf.getBoolean(YarnConfiguration.DIST_SCHEDULING_ENABLED,\n            YarnConfiguration.DIST_SCHEDULING_ENABLED_DEFAULT);\n\n    this.context \u003d createNMContext(containerTokenSecretManager,\n        nmTokenSecretManager, nmStore, isDistSchedulingEnabled, conf);\n\n\n    ((NMContext)context).setContainerExecutor(exec);\n\n    nodeLabelsProvider \u003d createNodeLabelsProvider(conf);\n\n    if (null \u003d\u003d nodeLabelsProvider) {\n      nodeStatusUpdater \u003d\n          createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n    } else {\n      addIfService(nodeLabelsProvider);\n      nodeStatusUpdater \u003d\n          createNodeStatusUpdater(context, dispatcher, nodeHealthChecker,\n              nodeLabelsProvider);\n    }\n\n    nodeResourceMonitor \u003d createNodeResourceMonitor();\n    addService(nodeResourceMonitor);\n    ((NMContext) context).setNodeResourceMonitor(nodeResourceMonitor);\n\n    containerManager \u003d\n        createContainerManager(context, exec, del, nodeStatusUpdater,\n        this.aclsManager, dirsHandler);\n    addService(containerManager);\n    ((NMContext) context).setContainerManager(containerManager);\n\n    WebServer webServer \u003d createWebServer(context, containerManager\n        .getContainersMonitor(), this.aclsManager, dirsHandler);\n    addService(webServer);\n    ((NMContext) context).setWebServer(webServer);\n\n    ((NMContext) context).setQueueableContainerAllocator(\n        new OpportunisticContainerAllocator(\n            context.getContainerTokenSecretManager()));\n\n    dispatcher.register(ContainerManagerEventType.class, containerManager);\n    dispatcher.register(NodeManagerEventType.class, this);\n    addService(dispatcher);\n\n    pauseMonitor \u003d new JvmPauseMonitor();\n    addService(pauseMonitor);\n    metrics.getJvmMetrics().setPauseMonitor(pauseMonitor);\n\n    DefaultMetricsSystem.initialize(\"NodeManager\");\n\n    if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n      this.nmCollectorService \u003d createNMCollectorService(context);\n      addService(nmCollectorService);\n    }\n\n    // StatusUpdater should be added last so that it get started last \n    // so that we make sure everything is up before registering with RM. \n    addService(nodeStatusUpdater);\n    ((NMContext) context).setNodeStatusUpdater(nodeStatusUpdater);\n\n    super.serviceInit(conf);\n    // TODO add local dirs to del\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java",
      "extendedDetails": {}
    },
    "10be45986cdf86a89055065b752959bd6369d54f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5486. Update OpportunisticContainerAllocatorAMService::allocate method to handle OPPORTUNISTIC container requests. (Konstantinos Karanasos via asuresh)\n",
      "commitDate": "29/09/16 3:11 PM",
      "commitName": "10be45986cdf86a89055065b752959bd6369d54f",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "06/09/16 7:31 AM",
      "commitNameOld": "e6fcfe28e304062c7d09231db757acb2953703ce",
      "commitAuthorOld": "Varun Vasudev",
      "daysBetweenCommits": 23.32,
      "commitsBetweenForRepo": 143,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,112 +1,111 @@\n   protected void serviceInit(Configuration conf) throws Exception {\n \n     conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n \n     rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n             .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n         YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n \n     try {\n       initAndStartRecoveryStore(conf);\n     } catch (IOException e) {\n       String recoveryDirName \u003d conf.get(YarnConfiguration.NM_RECOVERY_DIR);\n       throw new\n           YarnRuntimeException(\"Unable to initialize recovery directory at \"\n               + recoveryDirName, e);\n     }\n \n     NMContainerTokenSecretManager containerTokenSecretManager \u003d\n         new NMContainerTokenSecretManager(conf, nmStore);\n \n     NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n         new NMTokenSecretManagerInNM(nmStore);\n \n     recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n     \n     this.aclsManager \u003d new ApplicationACLsManager(conf);\n \n     ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n         conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n           DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n     try {\n       exec.init();\n     } catch (IOException e) {\n       throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n     }    \n     DeletionService del \u003d createDeletionService(exec);\n     addService(del);\n \n     // NodeManager level dispatcher\n     this.dispatcher \u003d new AsyncDispatcher();\n \n     dirsHandler \u003d new LocalDirsHandlerService(metrics);\n     nodeHealthChecker \u003d\n         new NodeHealthCheckerService(\n             getNodeHealthScriptRunner(conf), dirsHandler);\n     addService(nodeHealthChecker);\n \n     boolean isDistSchedulingEnabled \u003d\n-        conf.getBoolean(YarnConfiguration.\n-            OPPORTUNISTIC_CONTAINER_ALLOCATION_ENABLED,\n+        conf.getBoolean(YarnConfiguration.DIST_SCHEDULING_ENABLED,\n             YarnConfiguration.DIST_SCHEDULING_ENABLED_DEFAULT);\n \n     this.context \u003d createNMContext(containerTokenSecretManager,\n         nmTokenSecretManager, nmStore, isDistSchedulingEnabled, conf);\n \n \n     ((NMContext)context).setContainerExecutor(exec);\n \n     nodeLabelsProvider \u003d createNodeLabelsProvider(conf);\n \n     if (null \u003d\u003d nodeLabelsProvider) {\n       nodeStatusUpdater \u003d\n           createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n     } else {\n       addIfService(nodeLabelsProvider);\n       nodeStatusUpdater \u003d\n           createNodeStatusUpdater(context, dispatcher, nodeHealthChecker,\n               nodeLabelsProvider);\n     }\n \n     nodeResourceMonitor \u003d createNodeResourceMonitor();\n     addService(nodeResourceMonitor);\n     ((NMContext) context).setNodeResourceMonitor(nodeResourceMonitor);\n \n     containerManager \u003d\n         createContainerManager(context, exec, del, nodeStatusUpdater,\n         this.aclsManager, dirsHandler);\n     addService(containerManager);\n     ((NMContext) context).setContainerManager(containerManager);\n \n     WebServer webServer \u003d createWebServer(context, containerManager\n         .getContainersMonitor(), this.aclsManager, dirsHandler);\n     addService(webServer);\n     ((NMContext) context).setWebServer(webServer);\n \n     ((NMContext) context).setQueueableContainerAllocator(\n         new OpportunisticContainerAllocator(\n             context.getContainerTokenSecretManager(), webServer.getPort()));\n \n     dispatcher.register(ContainerManagerEventType.class, containerManager);\n     dispatcher.register(NodeManagerEventType.class, this);\n     addService(dispatcher);\n \n     pauseMonitor \u003d new JvmPauseMonitor();\n     addService(pauseMonitor);\n     metrics.getJvmMetrics().setPauseMonitor(pauseMonitor);\n \n     DefaultMetricsSystem.initialize(\"NodeManager\");\n \n     if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n       this.nmCollectorService \u003d createNMCollectorService(context);\n       addService(nmCollectorService);\n     }\n \n     // StatusUpdater should be added last so that it get started last \n     // so that we make sure everything is up before registering with RM. \n     addService(nodeStatusUpdater);\n     ((NMContext) context).setNodeStatusUpdater(nodeStatusUpdater);\n \n     super.serviceInit(conf);\n     // TODO add local dirs to del\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceInit(Configuration conf) throws Exception {\n\n    conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n\n    rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n            .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n        YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n\n    try {\n      initAndStartRecoveryStore(conf);\n    } catch (IOException e) {\n      String recoveryDirName \u003d conf.get(YarnConfiguration.NM_RECOVERY_DIR);\n      throw new\n          YarnRuntimeException(\"Unable to initialize recovery directory at \"\n              + recoveryDirName, e);\n    }\n\n    NMContainerTokenSecretManager containerTokenSecretManager \u003d\n        new NMContainerTokenSecretManager(conf, nmStore);\n\n    NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n        new NMTokenSecretManagerInNM(nmStore);\n\n    recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n    \n    this.aclsManager \u003d new ApplicationACLsManager(conf);\n\n    ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n        conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n          DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n    try {\n      exec.init();\n    } catch (IOException e) {\n      throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n    }    \n    DeletionService del \u003d createDeletionService(exec);\n    addService(del);\n\n    // NodeManager level dispatcher\n    this.dispatcher \u003d new AsyncDispatcher();\n\n    dirsHandler \u003d new LocalDirsHandlerService(metrics);\n    nodeHealthChecker \u003d\n        new NodeHealthCheckerService(\n            getNodeHealthScriptRunner(conf), dirsHandler);\n    addService(nodeHealthChecker);\n\n    boolean isDistSchedulingEnabled \u003d\n        conf.getBoolean(YarnConfiguration.DIST_SCHEDULING_ENABLED,\n            YarnConfiguration.DIST_SCHEDULING_ENABLED_DEFAULT);\n\n    this.context \u003d createNMContext(containerTokenSecretManager,\n        nmTokenSecretManager, nmStore, isDistSchedulingEnabled, conf);\n\n\n    ((NMContext)context).setContainerExecutor(exec);\n\n    nodeLabelsProvider \u003d createNodeLabelsProvider(conf);\n\n    if (null \u003d\u003d nodeLabelsProvider) {\n      nodeStatusUpdater \u003d\n          createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n    } else {\n      addIfService(nodeLabelsProvider);\n      nodeStatusUpdater \u003d\n          createNodeStatusUpdater(context, dispatcher, nodeHealthChecker,\n              nodeLabelsProvider);\n    }\n\n    nodeResourceMonitor \u003d createNodeResourceMonitor();\n    addService(nodeResourceMonitor);\n    ((NMContext) context).setNodeResourceMonitor(nodeResourceMonitor);\n\n    containerManager \u003d\n        createContainerManager(context, exec, del, nodeStatusUpdater,\n        this.aclsManager, dirsHandler);\n    addService(containerManager);\n    ((NMContext) context).setContainerManager(containerManager);\n\n    WebServer webServer \u003d createWebServer(context, containerManager\n        .getContainersMonitor(), this.aclsManager, dirsHandler);\n    addService(webServer);\n    ((NMContext) context).setWebServer(webServer);\n\n    ((NMContext) context).setQueueableContainerAllocator(\n        new OpportunisticContainerAllocator(\n            context.getContainerTokenSecretManager(), webServer.getPort()));\n\n    dispatcher.register(ContainerManagerEventType.class, containerManager);\n    dispatcher.register(NodeManagerEventType.class, this);\n    addService(dispatcher);\n\n    pauseMonitor \u003d new JvmPauseMonitor();\n    addService(pauseMonitor);\n    metrics.getJvmMetrics().setPauseMonitor(pauseMonitor);\n\n    DefaultMetricsSystem.initialize(\"NodeManager\");\n\n    if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n      this.nmCollectorService \u003d createNMCollectorService(context);\n      addService(nmCollectorService);\n    }\n\n    // StatusUpdater should be added last so that it get started last \n    // so that we make sure everything is up before registering with RM. \n    addService(nodeStatusUpdater);\n    ((NMContext) context).setNodeStatusUpdater(nodeStatusUpdater);\n\n    super.serviceInit(conf);\n    // TODO add local dirs to del\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java",
      "extendedDetails": {}
    },
    "e6fcfe28e304062c7d09231db757acb2953703ce": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5576. Allow resource localization while container is running. Contributed by Jian He.\n",
      "commitDate": "06/09/16 7:31 AM",
      "commitName": "e6fcfe28e304062c7d09231db757acb2953703ce",
      "commitAuthor": "Varun Vasudev",
      "commitDateOld": "09/08/16 12:42 AM",
      "commitNameOld": "82c9e061017c32e633e0b0cbb7978749a6df4fb2",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 28.28,
      "commitsBetweenForRepo": 176,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,109 +1,112 @@\n   protected void serviceInit(Configuration conf) throws Exception {\n \n     conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n \n     rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n             .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n         YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n \n     try {\n       initAndStartRecoveryStore(conf);\n     } catch (IOException e) {\n       String recoveryDirName \u003d conf.get(YarnConfiguration.NM_RECOVERY_DIR);\n       throw new\n           YarnRuntimeException(\"Unable to initialize recovery directory at \"\n               + recoveryDirName, e);\n     }\n \n     NMContainerTokenSecretManager containerTokenSecretManager \u003d\n         new NMContainerTokenSecretManager(conf, nmStore);\n \n     NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n         new NMTokenSecretManagerInNM(nmStore);\n \n     recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n     \n     this.aclsManager \u003d new ApplicationACLsManager(conf);\n \n     ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n         conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n           DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n     try {\n       exec.init();\n     } catch (IOException e) {\n       throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n     }    \n     DeletionService del \u003d createDeletionService(exec);\n     addService(del);\n \n     // NodeManager level dispatcher\n     this.dispatcher \u003d new AsyncDispatcher();\n \n     dirsHandler \u003d new LocalDirsHandlerService(metrics);\n     nodeHealthChecker \u003d\n         new NodeHealthCheckerService(\n             getNodeHealthScriptRunner(conf), dirsHandler);\n     addService(nodeHealthChecker);\n \n     boolean isDistSchedulingEnabled \u003d\n         conf.getBoolean(YarnConfiguration.\n             OPPORTUNISTIC_CONTAINER_ALLOCATION_ENABLED,\n             YarnConfiguration.DIST_SCHEDULING_ENABLED_DEFAULT);\n \n     this.context \u003d createNMContext(containerTokenSecretManager,\n         nmTokenSecretManager, nmStore, isDistSchedulingEnabled, conf);\n \n+\n+    ((NMContext)context).setContainerExecutor(exec);\n+\n     nodeLabelsProvider \u003d createNodeLabelsProvider(conf);\n \n     if (null \u003d\u003d nodeLabelsProvider) {\n       nodeStatusUpdater \u003d\n           createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n     } else {\n       addIfService(nodeLabelsProvider);\n       nodeStatusUpdater \u003d\n           createNodeStatusUpdater(context, dispatcher, nodeHealthChecker,\n               nodeLabelsProvider);\n     }\n \n     nodeResourceMonitor \u003d createNodeResourceMonitor();\n     addService(nodeResourceMonitor);\n     ((NMContext) context).setNodeResourceMonitor(nodeResourceMonitor);\n \n     containerManager \u003d\n         createContainerManager(context, exec, del, nodeStatusUpdater,\n         this.aclsManager, dirsHandler);\n     addService(containerManager);\n     ((NMContext) context).setContainerManager(containerManager);\n \n     WebServer webServer \u003d createWebServer(context, containerManager\n         .getContainersMonitor(), this.aclsManager, dirsHandler);\n     addService(webServer);\n     ((NMContext) context).setWebServer(webServer);\n \n     ((NMContext) context).setQueueableContainerAllocator(\n         new OpportunisticContainerAllocator(\n             context.getContainerTokenSecretManager(), webServer.getPort()));\n \n     dispatcher.register(ContainerManagerEventType.class, containerManager);\n     dispatcher.register(NodeManagerEventType.class, this);\n     addService(dispatcher);\n \n     pauseMonitor \u003d new JvmPauseMonitor();\n     addService(pauseMonitor);\n     metrics.getJvmMetrics().setPauseMonitor(pauseMonitor);\n \n     DefaultMetricsSystem.initialize(\"NodeManager\");\n \n     if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n       this.nmCollectorService \u003d createNMCollectorService(context);\n       addService(nmCollectorService);\n     }\n \n     // StatusUpdater should be added last so that it get started last \n     // so that we make sure everything is up before registering with RM. \n     addService(nodeStatusUpdater);\n     ((NMContext) context).setNodeStatusUpdater(nodeStatusUpdater);\n \n     super.serviceInit(conf);\n     // TODO add local dirs to del\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceInit(Configuration conf) throws Exception {\n\n    conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n\n    rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n            .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n        YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n\n    try {\n      initAndStartRecoveryStore(conf);\n    } catch (IOException e) {\n      String recoveryDirName \u003d conf.get(YarnConfiguration.NM_RECOVERY_DIR);\n      throw new\n          YarnRuntimeException(\"Unable to initialize recovery directory at \"\n              + recoveryDirName, e);\n    }\n\n    NMContainerTokenSecretManager containerTokenSecretManager \u003d\n        new NMContainerTokenSecretManager(conf, nmStore);\n\n    NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n        new NMTokenSecretManagerInNM(nmStore);\n\n    recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n    \n    this.aclsManager \u003d new ApplicationACLsManager(conf);\n\n    ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n        conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n          DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n    try {\n      exec.init();\n    } catch (IOException e) {\n      throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n    }    \n    DeletionService del \u003d createDeletionService(exec);\n    addService(del);\n\n    // NodeManager level dispatcher\n    this.dispatcher \u003d new AsyncDispatcher();\n\n    dirsHandler \u003d new LocalDirsHandlerService(metrics);\n    nodeHealthChecker \u003d\n        new NodeHealthCheckerService(\n            getNodeHealthScriptRunner(conf), dirsHandler);\n    addService(nodeHealthChecker);\n\n    boolean isDistSchedulingEnabled \u003d\n        conf.getBoolean(YarnConfiguration.\n            OPPORTUNISTIC_CONTAINER_ALLOCATION_ENABLED,\n            YarnConfiguration.DIST_SCHEDULING_ENABLED_DEFAULT);\n\n    this.context \u003d createNMContext(containerTokenSecretManager,\n        nmTokenSecretManager, nmStore, isDistSchedulingEnabled, conf);\n\n\n    ((NMContext)context).setContainerExecutor(exec);\n\n    nodeLabelsProvider \u003d createNodeLabelsProvider(conf);\n\n    if (null \u003d\u003d nodeLabelsProvider) {\n      nodeStatusUpdater \u003d\n          createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n    } else {\n      addIfService(nodeLabelsProvider);\n      nodeStatusUpdater \u003d\n          createNodeStatusUpdater(context, dispatcher, nodeHealthChecker,\n              nodeLabelsProvider);\n    }\n\n    nodeResourceMonitor \u003d createNodeResourceMonitor();\n    addService(nodeResourceMonitor);\n    ((NMContext) context).setNodeResourceMonitor(nodeResourceMonitor);\n\n    containerManager \u003d\n        createContainerManager(context, exec, del, nodeStatusUpdater,\n        this.aclsManager, dirsHandler);\n    addService(containerManager);\n    ((NMContext) context).setContainerManager(containerManager);\n\n    WebServer webServer \u003d createWebServer(context, containerManager\n        .getContainersMonitor(), this.aclsManager, dirsHandler);\n    addService(webServer);\n    ((NMContext) context).setWebServer(webServer);\n\n    ((NMContext) context).setQueueableContainerAllocator(\n        new OpportunisticContainerAllocator(\n            context.getContainerTokenSecretManager(), webServer.getPort()));\n\n    dispatcher.register(ContainerManagerEventType.class, containerManager);\n    dispatcher.register(NodeManagerEventType.class, this);\n    addService(dispatcher);\n\n    pauseMonitor \u003d new JvmPauseMonitor();\n    addService(pauseMonitor);\n    metrics.getJvmMetrics().setPauseMonitor(pauseMonitor);\n\n    DefaultMetricsSystem.initialize(\"NodeManager\");\n\n    if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n      this.nmCollectorService \u003d createNMCollectorService(context);\n      addService(nmCollectorService);\n    }\n\n    // StatusUpdater should be added last so that it get started last \n    // so that we make sure everything is up before registering with RM. \n    addService(nodeStatusUpdater);\n    ((NMContext) context).setNodeStatusUpdater(nodeStatusUpdater);\n\n    super.serviceInit(conf);\n    // TODO add local dirs to del\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java",
      "extendedDetails": {}
    },
    "82c9e061017c32e633e0b0cbb7978749a6df4fb2": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5457. Refactor DistributedScheduling framework to pull out common functionality. (asuresh)\n",
      "commitDate": "09/08/16 12:42 AM",
      "commitName": "82c9e061017c32e633e0b0cbb7978749a6df4fb2",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "10/07/16 8:46 AM",
      "commitNameOld": "6cf6ab7b780de2b0c2c9ea730e1f366965a0d682",
      "commitAuthorOld": "Sangjin Lee",
      "daysBetweenCommits": 29.66,
      "commitsBetweenForRepo": 202,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,108 +1,109 @@\n   protected void serviceInit(Configuration conf) throws Exception {\n \n     conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n \n     rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n             .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n         YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n \n     try {\n       initAndStartRecoveryStore(conf);\n     } catch (IOException e) {\n       String recoveryDirName \u003d conf.get(YarnConfiguration.NM_RECOVERY_DIR);\n       throw new\n           YarnRuntimeException(\"Unable to initialize recovery directory at \"\n               + recoveryDirName, e);\n     }\n \n     NMContainerTokenSecretManager containerTokenSecretManager \u003d\n         new NMContainerTokenSecretManager(conf, nmStore);\n \n     NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n         new NMTokenSecretManagerInNM(nmStore);\n \n     recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n     \n     this.aclsManager \u003d new ApplicationACLsManager(conf);\n \n     ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n         conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n           DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n     try {\n       exec.init();\n     } catch (IOException e) {\n       throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n     }    \n     DeletionService del \u003d createDeletionService(exec);\n     addService(del);\n \n     // NodeManager level dispatcher\n     this.dispatcher \u003d new AsyncDispatcher();\n \n     dirsHandler \u003d new LocalDirsHandlerService(metrics);\n     nodeHealthChecker \u003d\n         new NodeHealthCheckerService(\n             getNodeHealthScriptRunner(conf), dirsHandler);\n     addService(nodeHealthChecker);\n \n     boolean isDistSchedulingEnabled \u003d\n-        conf.getBoolean(YarnConfiguration.DIST_SCHEDULING_ENABLED,\n+        conf.getBoolean(YarnConfiguration.\n+            OPPORTUNISTIC_CONTAINER_ALLOCATION_ENABLED,\n             YarnConfiguration.DIST_SCHEDULING_ENABLED_DEFAULT);\n \n     this.context \u003d createNMContext(containerTokenSecretManager,\n         nmTokenSecretManager, nmStore, isDistSchedulingEnabled, conf);\n \n     nodeLabelsProvider \u003d createNodeLabelsProvider(conf);\n \n     if (null \u003d\u003d nodeLabelsProvider) {\n       nodeStatusUpdater \u003d\n           createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n     } else {\n       addIfService(nodeLabelsProvider);\n       nodeStatusUpdater \u003d\n           createNodeStatusUpdater(context, dispatcher, nodeHealthChecker,\n               nodeLabelsProvider);\n     }\n \n     nodeResourceMonitor \u003d createNodeResourceMonitor();\n     addService(nodeResourceMonitor);\n     ((NMContext) context).setNodeResourceMonitor(nodeResourceMonitor);\n \n     containerManager \u003d\n         createContainerManager(context, exec, del, nodeStatusUpdater,\n         this.aclsManager, dirsHandler);\n     addService(containerManager);\n     ((NMContext) context).setContainerManager(containerManager);\n \n     WebServer webServer \u003d createWebServer(context, containerManager\n         .getContainersMonitor(), this.aclsManager, dirsHandler);\n     addService(webServer);\n     ((NMContext) context).setWebServer(webServer);\n \n     ((NMContext) context).setQueueableContainerAllocator(\n-        new OpportunisticContainerAllocator(nodeStatusUpdater, context,\n-            webServer.getPort()));\n+        new OpportunisticContainerAllocator(\n+            context.getContainerTokenSecretManager(), webServer.getPort()));\n \n     dispatcher.register(ContainerManagerEventType.class, containerManager);\n     dispatcher.register(NodeManagerEventType.class, this);\n     addService(dispatcher);\n \n     pauseMonitor \u003d new JvmPauseMonitor();\n     addService(pauseMonitor);\n     metrics.getJvmMetrics().setPauseMonitor(pauseMonitor);\n \n     DefaultMetricsSystem.initialize(\"NodeManager\");\n \n     if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n       this.nmCollectorService \u003d createNMCollectorService(context);\n       addService(nmCollectorService);\n     }\n \n     // StatusUpdater should be added last so that it get started last \n     // so that we make sure everything is up before registering with RM. \n     addService(nodeStatusUpdater);\n     ((NMContext) context).setNodeStatusUpdater(nodeStatusUpdater);\n \n     super.serviceInit(conf);\n     // TODO add local dirs to del\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceInit(Configuration conf) throws Exception {\n\n    conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n\n    rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n            .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n        YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n\n    try {\n      initAndStartRecoveryStore(conf);\n    } catch (IOException e) {\n      String recoveryDirName \u003d conf.get(YarnConfiguration.NM_RECOVERY_DIR);\n      throw new\n          YarnRuntimeException(\"Unable to initialize recovery directory at \"\n              + recoveryDirName, e);\n    }\n\n    NMContainerTokenSecretManager containerTokenSecretManager \u003d\n        new NMContainerTokenSecretManager(conf, nmStore);\n\n    NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n        new NMTokenSecretManagerInNM(nmStore);\n\n    recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n    \n    this.aclsManager \u003d new ApplicationACLsManager(conf);\n\n    ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n        conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n          DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n    try {\n      exec.init();\n    } catch (IOException e) {\n      throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n    }    \n    DeletionService del \u003d createDeletionService(exec);\n    addService(del);\n\n    // NodeManager level dispatcher\n    this.dispatcher \u003d new AsyncDispatcher();\n\n    dirsHandler \u003d new LocalDirsHandlerService(metrics);\n    nodeHealthChecker \u003d\n        new NodeHealthCheckerService(\n            getNodeHealthScriptRunner(conf), dirsHandler);\n    addService(nodeHealthChecker);\n\n    boolean isDistSchedulingEnabled \u003d\n        conf.getBoolean(YarnConfiguration.\n            OPPORTUNISTIC_CONTAINER_ALLOCATION_ENABLED,\n            YarnConfiguration.DIST_SCHEDULING_ENABLED_DEFAULT);\n\n    this.context \u003d createNMContext(containerTokenSecretManager,\n        nmTokenSecretManager, nmStore, isDistSchedulingEnabled, conf);\n\n    nodeLabelsProvider \u003d createNodeLabelsProvider(conf);\n\n    if (null \u003d\u003d nodeLabelsProvider) {\n      nodeStatusUpdater \u003d\n          createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n    } else {\n      addIfService(nodeLabelsProvider);\n      nodeStatusUpdater \u003d\n          createNodeStatusUpdater(context, dispatcher, nodeHealthChecker,\n              nodeLabelsProvider);\n    }\n\n    nodeResourceMonitor \u003d createNodeResourceMonitor();\n    addService(nodeResourceMonitor);\n    ((NMContext) context).setNodeResourceMonitor(nodeResourceMonitor);\n\n    containerManager \u003d\n        createContainerManager(context, exec, del, nodeStatusUpdater,\n        this.aclsManager, dirsHandler);\n    addService(containerManager);\n    ((NMContext) context).setContainerManager(containerManager);\n\n    WebServer webServer \u003d createWebServer(context, containerManager\n        .getContainersMonitor(), this.aclsManager, dirsHandler);\n    addService(webServer);\n    ((NMContext) context).setWebServer(webServer);\n\n    ((NMContext) context).setQueueableContainerAllocator(\n        new OpportunisticContainerAllocator(\n            context.getContainerTokenSecretManager(), webServer.getPort()));\n\n    dispatcher.register(ContainerManagerEventType.class, containerManager);\n    dispatcher.register(NodeManagerEventType.class, this);\n    addService(dispatcher);\n\n    pauseMonitor \u003d new JvmPauseMonitor();\n    addService(pauseMonitor);\n    metrics.getJvmMetrics().setPauseMonitor(pauseMonitor);\n\n    DefaultMetricsSystem.initialize(\"NodeManager\");\n\n    if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n      this.nmCollectorService \u003d createNMCollectorService(context);\n      addService(nmCollectorService);\n    }\n\n    // StatusUpdater should be added last so that it get started last \n    // so that we make sure everything is up before registering with RM. \n    addService(nodeStatusUpdater);\n    ((NMContext) context).setNodeStatusUpdater(nodeStatusUpdater);\n\n    super.serviceInit(conf);\n    // TODO add local dirs to del\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java",
      "extendedDetails": {}
    },
    "89e5c44f9e891a3579384c3fa3766937cd4970f1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4356. Ensure the timeline service v.2 is disabled cleanly and has no\nimpact when it\u0027s turned off. Contributed by Sangjin Lee.\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "89e5c44f9e891a3579384c3fa3766937cd4970f1",
      "commitAuthor": "Li Lu",
      "commitDateOld": "10/07/16 8:45 AM",
      "commitNameOld": "477a30f536277bf95d7181bf1b2fdda52d83bf51",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 21,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,106 +1,108 @@\n   protected void serviceInit(Configuration conf) throws Exception {\n \n     conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n \n     rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n             .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n         YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n \n     try {\n       initAndStartRecoveryStore(conf);\n     } catch (IOException e) {\n       String recoveryDirName \u003d conf.get(YarnConfiguration.NM_RECOVERY_DIR);\n       throw new\n           YarnRuntimeException(\"Unable to initialize recovery directory at \"\n               + recoveryDirName, e);\n     }\n \n     NMContainerTokenSecretManager containerTokenSecretManager \u003d\n         new NMContainerTokenSecretManager(conf, nmStore);\n \n     NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n         new NMTokenSecretManagerInNM(nmStore);\n \n     recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n     \n     this.aclsManager \u003d new ApplicationACLsManager(conf);\n \n     ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n         conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n           DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n     try {\n       exec.init();\n     } catch (IOException e) {\n       throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n     }    \n     DeletionService del \u003d createDeletionService(exec);\n     addService(del);\n \n     // NodeManager level dispatcher\n     this.dispatcher \u003d new AsyncDispatcher();\n \n     dirsHandler \u003d new LocalDirsHandlerService(metrics);\n     nodeHealthChecker \u003d\n         new NodeHealthCheckerService(\n             getNodeHealthScriptRunner(conf), dirsHandler);\n     addService(nodeHealthChecker);\n \n     boolean isDistSchedulingEnabled \u003d\n         conf.getBoolean(YarnConfiguration.DIST_SCHEDULING_ENABLED,\n             YarnConfiguration.DIST_SCHEDULING_ENABLED_DEFAULT);\n \n     this.context \u003d createNMContext(containerTokenSecretManager,\n         nmTokenSecretManager, nmStore, isDistSchedulingEnabled, conf);\n \n     nodeLabelsProvider \u003d createNodeLabelsProvider(conf);\n \n     if (null \u003d\u003d nodeLabelsProvider) {\n       nodeStatusUpdater \u003d\n           createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n     } else {\n       addIfService(nodeLabelsProvider);\n       nodeStatusUpdater \u003d\n           createNodeStatusUpdater(context, dispatcher, nodeHealthChecker,\n               nodeLabelsProvider);\n     }\n \n     nodeResourceMonitor \u003d createNodeResourceMonitor();\n     addService(nodeResourceMonitor);\n     ((NMContext) context).setNodeResourceMonitor(nodeResourceMonitor);\n \n     containerManager \u003d\n         createContainerManager(context, exec, del, nodeStatusUpdater,\n         this.aclsManager, dirsHandler);\n     addService(containerManager);\n     ((NMContext) context).setContainerManager(containerManager);\n \n     WebServer webServer \u003d createWebServer(context, containerManager\n         .getContainersMonitor(), this.aclsManager, dirsHandler);\n     addService(webServer);\n     ((NMContext) context).setWebServer(webServer);\n \n     ((NMContext) context).setQueueableContainerAllocator(\n         new OpportunisticContainerAllocator(nodeStatusUpdater, context,\n             webServer.getPort()));\n \n     dispatcher.register(ContainerManagerEventType.class, containerManager);\n     dispatcher.register(NodeManagerEventType.class, this);\n     addService(dispatcher);\n \n     pauseMonitor \u003d new JvmPauseMonitor();\n     addService(pauseMonitor);\n     metrics.getJvmMetrics().setPauseMonitor(pauseMonitor);\n \n     DefaultMetricsSystem.initialize(\"NodeManager\");\n \n-    this.nmCollectorService \u003d createNMCollectorService(context);\n-    addService(nmCollectorService);\n+    if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n+      this.nmCollectorService \u003d createNMCollectorService(context);\n+      addService(nmCollectorService);\n+    }\n \n     // StatusUpdater should be added last so that it get started last \n     // so that we make sure everything is up before registering with RM. \n     addService(nodeStatusUpdater);\n     ((NMContext) context).setNodeStatusUpdater(nodeStatusUpdater);\n \n     super.serviceInit(conf);\n     // TODO add local dirs to del\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceInit(Configuration conf) throws Exception {\n\n    conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n\n    rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n            .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n        YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n\n    try {\n      initAndStartRecoveryStore(conf);\n    } catch (IOException e) {\n      String recoveryDirName \u003d conf.get(YarnConfiguration.NM_RECOVERY_DIR);\n      throw new\n          YarnRuntimeException(\"Unable to initialize recovery directory at \"\n              + recoveryDirName, e);\n    }\n\n    NMContainerTokenSecretManager containerTokenSecretManager \u003d\n        new NMContainerTokenSecretManager(conf, nmStore);\n\n    NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n        new NMTokenSecretManagerInNM(nmStore);\n\n    recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n    \n    this.aclsManager \u003d new ApplicationACLsManager(conf);\n\n    ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n        conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n          DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n    try {\n      exec.init();\n    } catch (IOException e) {\n      throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n    }    \n    DeletionService del \u003d createDeletionService(exec);\n    addService(del);\n\n    // NodeManager level dispatcher\n    this.dispatcher \u003d new AsyncDispatcher();\n\n    dirsHandler \u003d new LocalDirsHandlerService(metrics);\n    nodeHealthChecker \u003d\n        new NodeHealthCheckerService(\n            getNodeHealthScriptRunner(conf), dirsHandler);\n    addService(nodeHealthChecker);\n\n    boolean isDistSchedulingEnabled \u003d\n        conf.getBoolean(YarnConfiguration.DIST_SCHEDULING_ENABLED,\n            YarnConfiguration.DIST_SCHEDULING_ENABLED_DEFAULT);\n\n    this.context \u003d createNMContext(containerTokenSecretManager,\n        nmTokenSecretManager, nmStore, isDistSchedulingEnabled, conf);\n\n    nodeLabelsProvider \u003d createNodeLabelsProvider(conf);\n\n    if (null \u003d\u003d nodeLabelsProvider) {\n      nodeStatusUpdater \u003d\n          createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n    } else {\n      addIfService(nodeLabelsProvider);\n      nodeStatusUpdater \u003d\n          createNodeStatusUpdater(context, dispatcher, nodeHealthChecker,\n              nodeLabelsProvider);\n    }\n\n    nodeResourceMonitor \u003d createNodeResourceMonitor();\n    addService(nodeResourceMonitor);\n    ((NMContext) context).setNodeResourceMonitor(nodeResourceMonitor);\n\n    containerManager \u003d\n        createContainerManager(context, exec, del, nodeStatusUpdater,\n        this.aclsManager, dirsHandler);\n    addService(containerManager);\n    ((NMContext) context).setContainerManager(containerManager);\n\n    WebServer webServer \u003d createWebServer(context, containerManager\n        .getContainersMonitor(), this.aclsManager, dirsHandler);\n    addService(webServer);\n    ((NMContext) context).setWebServer(webServer);\n\n    ((NMContext) context).setQueueableContainerAllocator(\n        new OpportunisticContainerAllocator(nodeStatusUpdater, context,\n            webServer.getPort()));\n\n    dispatcher.register(ContainerManagerEventType.class, containerManager);\n    dispatcher.register(NodeManagerEventType.class, this);\n    addService(dispatcher);\n\n    pauseMonitor \u003d new JvmPauseMonitor();\n    addService(pauseMonitor);\n    metrics.getJvmMetrics().setPauseMonitor(pauseMonitor);\n\n    DefaultMetricsSystem.initialize(\"NodeManager\");\n\n    if (YarnConfiguration.timelineServiceV2Enabled(conf)) {\n      this.nmCollectorService \u003d createNMCollectorService(context);\n      addService(nmCollectorService);\n    }\n\n    // StatusUpdater should be added last so that it get started last \n    // so that we make sure everything is up before registering with RM. \n    addService(nodeStatusUpdater);\n    ((NMContext) context).setNodeStatusUpdater(nodeStatusUpdater);\n\n    super.serviceInit(conf);\n    // TODO add local dirs to del\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java",
      "extendedDetails": {}
    },
    "5712b8f9fd1859fe046b482889239bd164ed7dab": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3334. NM uses timeline client to publish container metrics to new timeline service. Contributed by Junping Du.\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "5712b8f9fd1859fe046b482889239bd164ed7dab",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "10/07/16 8:45 AM",
      "commitNameOld": "2188a07e5bea1da26bf679ca0ece26ab596d3438",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,106 +1,106 @@\n   protected void serviceInit(Configuration conf) throws Exception {\n \n     conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n \n     rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n             .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n         YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n \n     try {\n       initAndStartRecoveryStore(conf);\n     } catch (IOException e) {\n       String recoveryDirName \u003d conf.get(YarnConfiguration.NM_RECOVERY_DIR);\n       throw new\n           YarnRuntimeException(\"Unable to initialize recovery directory at \"\n               + recoveryDirName, e);\n     }\n \n     NMContainerTokenSecretManager containerTokenSecretManager \u003d\n         new NMContainerTokenSecretManager(conf, nmStore);\n \n     NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n         new NMTokenSecretManagerInNM(nmStore);\n \n     recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n     \n     this.aclsManager \u003d new ApplicationACLsManager(conf);\n \n     ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n         conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n           DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n     try {\n       exec.init();\n     } catch (IOException e) {\n       throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n     }    \n     DeletionService del \u003d createDeletionService(exec);\n     addService(del);\n \n     // NodeManager level dispatcher\n     this.dispatcher \u003d new AsyncDispatcher();\n \n     dirsHandler \u003d new LocalDirsHandlerService(metrics);\n     nodeHealthChecker \u003d\n         new NodeHealthCheckerService(\n             getNodeHealthScriptRunner(conf), dirsHandler);\n     addService(nodeHealthChecker);\n \n     boolean isDistSchedulingEnabled \u003d\n         conf.getBoolean(YarnConfiguration.DIST_SCHEDULING_ENABLED,\n             YarnConfiguration.DIST_SCHEDULING_ENABLED_DEFAULT);\n \n     this.context \u003d createNMContext(containerTokenSecretManager,\n-        nmTokenSecretManager, nmStore, isDistSchedulingEnabled);\n+        nmTokenSecretManager, nmStore, isDistSchedulingEnabled, conf);\n \n     nodeLabelsProvider \u003d createNodeLabelsProvider(conf);\n \n     if (null \u003d\u003d nodeLabelsProvider) {\n       nodeStatusUpdater \u003d\n           createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n     } else {\n       addIfService(nodeLabelsProvider);\n       nodeStatusUpdater \u003d\n           createNodeStatusUpdater(context, dispatcher, nodeHealthChecker,\n               nodeLabelsProvider);\n     }\n \n     nodeResourceMonitor \u003d createNodeResourceMonitor();\n     addService(nodeResourceMonitor);\n     ((NMContext) context).setNodeResourceMonitor(nodeResourceMonitor);\n \n     containerManager \u003d\n         createContainerManager(context, exec, del, nodeStatusUpdater,\n         this.aclsManager, dirsHandler);\n     addService(containerManager);\n     ((NMContext) context).setContainerManager(containerManager);\n \n     WebServer webServer \u003d createWebServer(context, containerManager\n         .getContainersMonitor(), this.aclsManager, dirsHandler);\n     addService(webServer);\n     ((NMContext) context).setWebServer(webServer);\n \n     ((NMContext) context).setQueueableContainerAllocator(\n         new OpportunisticContainerAllocator(nodeStatusUpdater, context,\n             webServer.getPort()));\n \n     dispatcher.register(ContainerManagerEventType.class, containerManager);\n     dispatcher.register(NodeManagerEventType.class, this);\n     addService(dispatcher);\n \n     pauseMonitor \u003d new JvmPauseMonitor();\n     addService(pauseMonitor);\n     metrics.getJvmMetrics().setPauseMonitor(pauseMonitor);\n \n     DefaultMetricsSystem.initialize(\"NodeManager\");\n \n     this.nmCollectorService \u003d createNMCollectorService(context);\n     addService(nmCollectorService);\n \n     // StatusUpdater should be added last so that it get started last \n     // so that we make sure everything is up before registering with RM. \n     addService(nodeStatusUpdater);\n     ((NMContext) context).setNodeStatusUpdater(nodeStatusUpdater);\n \n     super.serviceInit(conf);\n     // TODO add local dirs to del\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceInit(Configuration conf) throws Exception {\n\n    conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n\n    rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n            .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n        YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n\n    try {\n      initAndStartRecoveryStore(conf);\n    } catch (IOException e) {\n      String recoveryDirName \u003d conf.get(YarnConfiguration.NM_RECOVERY_DIR);\n      throw new\n          YarnRuntimeException(\"Unable to initialize recovery directory at \"\n              + recoveryDirName, e);\n    }\n\n    NMContainerTokenSecretManager containerTokenSecretManager \u003d\n        new NMContainerTokenSecretManager(conf, nmStore);\n\n    NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n        new NMTokenSecretManagerInNM(nmStore);\n\n    recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n    \n    this.aclsManager \u003d new ApplicationACLsManager(conf);\n\n    ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n        conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n          DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n    try {\n      exec.init();\n    } catch (IOException e) {\n      throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n    }    \n    DeletionService del \u003d createDeletionService(exec);\n    addService(del);\n\n    // NodeManager level dispatcher\n    this.dispatcher \u003d new AsyncDispatcher();\n\n    dirsHandler \u003d new LocalDirsHandlerService(metrics);\n    nodeHealthChecker \u003d\n        new NodeHealthCheckerService(\n            getNodeHealthScriptRunner(conf), dirsHandler);\n    addService(nodeHealthChecker);\n\n    boolean isDistSchedulingEnabled \u003d\n        conf.getBoolean(YarnConfiguration.DIST_SCHEDULING_ENABLED,\n            YarnConfiguration.DIST_SCHEDULING_ENABLED_DEFAULT);\n\n    this.context \u003d createNMContext(containerTokenSecretManager,\n        nmTokenSecretManager, nmStore, isDistSchedulingEnabled, conf);\n\n    nodeLabelsProvider \u003d createNodeLabelsProvider(conf);\n\n    if (null \u003d\u003d nodeLabelsProvider) {\n      nodeStatusUpdater \u003d\n          createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n    } else {\n      addIfService(nodeLabelsProvider);\n      nodeStatusUpdater \u003d\n          createNodeStatusUpdater(context, dispatcher, nodeHealthChecker,\n              nodeLabelsProvider);\n    }\n\n    nodeResourceMonitor \u003d createNodeResourceMonitor();\n    addService(nodeResourceMonitor);\n    ((NMContext) context).setNodeResourceMonitor(nodeResourceMonitor);\n\n    containerManager \u003d\n        createContainerManager(context, exec, del, nodeStatusUpdater,\n        this.aclsManager, dirsHandler);\n    addService(containerManager);\n    ((NMContext) context).setContainerManager(containerManager);\n\n    WebServer webServer \u003d createWebServer(context, containerManager\n        .getContainersMonitor(), this.aclsManager, dirsHandler);\n    addService(webServer);\n    ((NMContext) context).setWebServer(webServer);\n\n    ((NMContext) context).setQueueableContainerAllocator(\n        new OpportunisticContainerAllocator(nodeStatusUpdater, context,\n            webServer.getPort()));\n\n    dispatcher.register(ContainerManagerEventType.class, containerManager);\n    dispatcher.register(NodeManagerEventType.class, this);\n    addService(dispatcher);\n\n    pauseMonitor \u003d new JvmPauseMonitor();\n    addService(pauseMonitor);\n    metrics.getJvmMetrics().setPauseMonitor(pauseMonitor);\n\n    DefaultMetricsSystem.initialize(\"NodeManager\");\n\n    this.nmCollectorService \u003d createNMCollectorService(context);\n    addService(nmCollectorService);\n\n    // StatusUpdater should be added last so that it get started last \n    // so that we make sure everything is up before registering with RM. \n    addService(nodeStatusUpdater);\n    ((NMContext) context).setNodeStatusUpdater(nodeStatusUpdater);\n\n    super.serviceInit(conf);\n    // TODO add local dirs to del\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java",
      "extendedDetails": {}
    },
    "2188a07e5bea1da26bf679ca0ece26ab596d3438": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3333. Rename TimelineAggregator etc. to TimelineCollector. Contributed by Sangjin Lee\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "2188a07e5bea1da26bf679ca0ece26ab596d3438",
      "commitAuthor": "Junping Du",
      "commitDateOld": "10/07/16 8:45 AM",
      "commitNameOld": "9b5636408005676ae580f8d929f8e912c27828e7",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,106 +1,106 @@\n   protected void serviceInit(Configuration conf) throws Exception {\n \n     conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n \n     rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n             .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n         YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n \n     try {\n       initAndStartRecoveryStore(conf);\n     } catch (IOException e) {\n       String recoveryDirName \u003d conf.get(YarnConfiguration.NM_RECOVERY_DIR);\n       throw new\n           YarnRuntimeException(\"Unable to initialize recovery directory at \"\n               + recoveryDirName, e);\n     }\n \n     NMContainerTokenSecretManager containerTokenSecretManager \u003d\n         new NMContainerTokenSecretManager(conf, nmStore);\n \n     NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n         new NMTokenSecretManagerInNM(nmStore);\n \n     recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n     \n     this.aclsManager \u003d new ApplicationACLsManager(conf);\n \n     ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n         conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n           DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n     try {\n       exec.init();\n     } catch (IOException e) {\n       throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n     }    \n     DeletionService del \u003d createDeletionService(exec);\n     addService(del);\n \n     // NodeManager level dispatcher\n     this.dispatcher \u003d new AsyncDispatcher();\n \n     dirsHandler \u003d new LocalDirsHandlerService(metrics);\n     nodeHealthChecker \u003d\n         new NodeHealthCheckerService(\n             getNodeHealthScriptRunner(conf), dirsHandler);\n     addService(nodeHealthChecker);\n \n     boolean isDistSchedulingEnabled \u003d\n         conf.getBoolean(YarnConfiguration.DIST_SCHEDULING_ENABLED,\n             YarnConfiguration.DIST_SCHEDULING_ENABLED_DEFAULT);\n \n     this.context \u003d createNMContext(containerTokenSecretManager,\n         nmTokenSecretManager, nmStore, isDistSchedulingEnabled);\n \n     nodeLabelsProvider \u003d createNodeLabelsProvider(conf);\n \n     if (null \u003d\u003d nodeLabelsProvider) {\n       nodeStatusUpdater \u003d\n           createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n     } else {\n       addIfService(nodeLabelsProvider);\n       nodeStatusUpdater \u003d\n           createNodeStatusUpdater(context, dispatcher, nodeHealthChecker,\n               nodeLabelsProvider);\n     }\n \n     nodeResourceMonitor \u003d createNodeResourceMonitor();\n     addService(nodeResourceMonitor);\n     ((NMContext) context).setNodeResourceMonitor(nodeResourceMonitor);\n \n     containerManager \u003d\n         createContainerManager(context, exec, del, nodeStatusUpdater,\n         this.aclsManager, dirsHandler);\n     addService(containerManager);\n     ((NMContext) context).setContainerManager(containerManager);\n \n     WebServer webServer \u003d createWebServer(context, containerManager\n         .getContainersMonitor(), this.aclsManager, dirsHandler);\n     addService(webServer);\n     ((NMContext) context).setWebServer(webServer);\n \n     ((NMContext) context).setQueueableContainerAllocator(\n         new OpportunisticContainerAllocator(nodeStatusUpdater, context,\n             webServer.getPort()));\n \n     dispatcher.register(ContainerManagerEventType.class, containerManager);\n     dispatcher.register(NodeManagerEventType.class, this);\n     addService(dispatcher);\n \n     pauseMonitor \u003d new JvmPauseMonitor();\n     addService(pauseMonitor);\n     metrics.getJvmMetrics().setPauseMonitor(pauseMonitor);\n \n     DefaultMetricsSystem.initialize(\"NodeManager\");\n-    \n-    this.nmAggregatorService \u003d createNMAggregatorService(context);\n-    addService(nmAggregatorService);\n+\n+    this.nmCollectorService \u003d createNMCollectorService(context);\n+    addService(nmCollectorService);\n \n     // StatusUpdater should be added last so that it get started last \n     // so that we make sure everything is up before registering with RM. \n     addService(nodeStatusUpdater);\n     ((NMContext) context).setNodeStatusUpdater(nodeStatusUpdater);\n \n     super.serviceInit(conf);\n     // TODO add local dirs to del\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceInit(Configuration conf) throws Exception {\n\n    conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n\n    rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n            .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n        YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n\n    try {\n      initAndStartRecoveryStore(conf);\n    } catch (IOException e) {\n      String recoveryDirName \u003d conf.get(YarnConfiguration.NM_RECOVERY_DIR);\n      throw new\n          YarnRuntimeException(\"Unable to initialize recovery directory at \"\n              + recoveryDirName, e);\n    }\n\n    NMContainerTokenSecretManager containerTokenSecretManager \u003d\n        new NMContainerTokenSecretManager(conf, nmStore);\n\n    NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n        new NMTokenSecretManagerInNM(nmStore);\n\n    recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n    \n    this.aclsManager \u003d new ApplicationACLsManager(conf);\n\n    ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n        conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n          DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n    try {\n      exec.init();\n    } catch (IOException e) {\n      throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n    }    \n    DeletionService del \u003d createDeletionService(exec);\n    addService(del);\n\n    // NodeManager level dispatcher\n    this.dispatcher \u003d new AsyncDispatcher();\n\n    dirsHandler \u003d new LocalDirsHandlerService(metrics);\n    nodeHealthChecker \u003d\n        new NodeHealthCheckerService(\n            getNodeHealthScriptRunner(conf), dirsHandler);\n    addService(nodeHealthChecker);\n\n    boolean isDistSchedulingEnabled \u003d\n        conf.getBoolean(YarnConfiguration.DIST_SCHEDULING_ENABLED,\n            YarnConfiguration.DIST_SCHEDULING_ENABLED_DEFAULT);\n\n    this.context \u003d createNMContext(containerTokenSecretManager,\n        nmTokenSecretManager, nmStore, isDistSchedulingEnabled);\n\n    nodeLabelsProvider \u003d createNodeLabelsProvider(conf);\n\n    if (null \u003d\u003d nodeLabelsProvider) {\n      nodeStatusUpdater \u003d\n          createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n    } else {\n      addIfService(nodeLabelsProvider);\n      nodeStatusUpdater \u003d\n          createNodeStatusUpdater(context, dispatcher, nodeHealthChecker,\n              nodeLabelsProvider);\n    }\n\n    nodeResourceMonitor \u003d createNodeResourceMonitor();\n    addService(nodeResourceMonitor);\n    ((NMContext) context).setNodeResourceMonitor(nodeResourceMonitor);\n\n    containerManager \u003d\n        createContainerManager(context, exec, del, nodeStatusUpdater,\n        this.aclsManager, dirsHandler);\n    addService(containerManager);\n    ((NMContext) context).setContainerManager(containerManager);\n\n    WebServer webServer \u003d createWebServer(context, containerManager\n        .getContainersMonitor(), this.aclsManager, dirsHandler);\n    addService(webServer);\n    ((NMContext) context).setWebServer(webServer);\n\n    ((NMContext) context).setQueueableContainerAllocator(\n        new OpportunisticContainerAllocator(nodeStatusUpdater, context,\n            webServer.getPort()));\n\n    dispatcher.register(ContainerManagerEventType.class, containerManager);\n    dispatcher.register(NodeManagerEventType.class, this);\n    addService(dispatcher);\n\n    pauseMonitor \u003d new JvmPauseMonitor();\n    addService(pauseMonitor);\n    metrics.getJvmMetrics().setPauseMonitor(pauseMonitor);\n\n    DefaultMetricsSystem.initialize(\"NodeManager\");\n\n    this.nmCollectorService \u003d createNMCollectorService(context);\n    addService(nmCollectorService);\n\n    // StatusUpdater should be added last so that it get started last \n    // so that we make sure everything is up before registering with RM. \n    addService(nodeStatusUpdater);\n    ((NMContext) context).setNodeStatusUpdater(nodeStatusUpdater);\n\n    super.serviceInit(conf);\n    // TODO add local dirs to del\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java",
      "extendedDetails": {}
    },
    "9b5636408005676ae580f8d929f8e912c27828e7": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3039. Implemented the app-level timeline aggregator discovery service. Contributed by Junping Du.\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "9b5636408005676ae580f8d929f8e912c27828e7",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "01/07/16 3:53 PM",
      "commitNameOld": "0a5def155eff4564b5dc7685e7460952f51bbd24",
      "commitAuthorOld": "Ray Chiang",
      "daysBetweenCommits": 8.7,
      "commitsBetweenForRepo": 38,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,103 +1,106 @@\n   protected void serviceInit(Configuration conf) throws Exception {\n \n     conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n \n     rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n             .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n         YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n \n     try {\n       initAndStartRecoveryStore(conf);\n     } catch (IOException e) {\n       String recoveryDirName \u003d conf.get(YarnConfiguration.NM_RECOVERY_DIR);\n       throw new\n           YarnRuntimeException(\"Unable to initialize recovery directory at \"\n               + recoveryDirName, e);\n     }\n \n     NMContainerTokenSecretManager containerTokenSecretManager \u003d\n         new NMContainerTokenSecretManager(conf, nmStore);\n \n     NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n         new NMTokenSecretManagerInNM(nmStore);\n \n     recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n     \n     this.aclsManager \u003d new ApplicationACLsManager(conf);\n \n     ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n         conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n           DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n     try {\n       exec.init();\n     } catch (IOException e) {\n       throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n     }    \n     DeletionService del \u003d createDeletionService(exec);\n     addService(del);\n \n     // NodeManager level dispatcher\n     this.dispatcher \u003d new AsyncDispatcher();\n \n     dirsHandler \u003d new LocalDirsHandlerService(metrics);\n     nodeHealthChecker \u003d\n         new NodeHealthCheckerService(\n             getNodeHealthScriptRunner(conf), dirsHandler);\n     addService(nodeHealthChecker);\n \n     boolean isDistSchedulingEnabled \u003d\n         conf.getBoolean(YarnConfiguration.DIST_SCHEDULING_ENABLED,\n             YarnConfiguration.DIST_SCHEDULING_ENABLED_DEFAULT);\n \n     this.context \u003d createNMContext(containerTokenSecretManager,\n         nmTokenSecretManager, nmStore, isDistSchedulingEnabled);\n \n     nodeLabelsProvider \u003d createNodeLabelsProvider(conf);\n \n     if (null \u003d\u003d nodeLabelsProvider) {\n       nodeStatusUpdater \u003d\n           createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n     } else {\n       addIfService(nodeLabelsProvider);\n       nodeStatusUpdater \u003d\n           createNodeStatusUpdater(context, dispatcher, nodeHealthChecker,\n               nodeLabelsProvider);\n     }\n \n     nodeResourceMonitor \u003d createNodeResourceMonitor();\n     addService(nodeResourceMonitor);\n     ((NMContext) context).setNodeResourceMonitor(nodeResourceMonitor);\n \n     containerManager \u003d\n         createContainerManager(context, exec, del, nodeStatusUpdater,\n         this.aclsManager, dirsHandler);\n     addService(containerManager);\n     ((NMContext) context).setContainerManager(containerManager);\n \n     WebServer webServer \u003d createWebServer(context, containerManager\n         .getContainersMonitor(), this.aclsManager, dirsHandler);\n     addService(webServer);\n     ((NMContext) context).setWebServer(webServer);\n \n     ((NMContext) context).setQueueableContainerAllocator(\n         new OpportunisticContainerAllocator(nodeStatusUpdater, context,\n             webServer.getPort()));\n \n     dispatcher.register(ContainerManagerEventType.class, containerManager);\n     dispatcher.register(NodeManagerEventType.class, this);\n     addService(dispatcher);\n \n     pauseMonitor \u003d new JvmPauseMonitor();\n     addService(pauseMonitor);\n     metrics.getJvmMetrics().setPauseMonitor(pauseMonitor);\n \n     DefaultMetricsSystem.initialize(\"NodeManager\");\n+    \n+    this.nmAggregatorService \u003d createNMAggregatorService(context);\n+    addService(nmAggregatorService);\n \n     // StatusUpdater should be added last so that it get started last \n     // so that we make sure everything is up before registering with RM. \n     addService(nodeStatusUpdater);\n     ((NMContext) context).setNodeStatusUpdater(nodeStatusUpdater);\n \n     super.serviceInit(conf);\n     // TODO add local dirs to del\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceInit(Configuration conf) throws Exception {\n\n    conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n\n    rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n            .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n        YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n\n    try {\n      initAndStartRecoveryStore(conf);\n    } catch (IOException e) {\n      String recoveryDirName \u003d conf.get(YarnConfiguration.NM_RECOVERY_DIR);\n      throw new\n          YarnRuntimeException(\"Unable to initialize recovery directory at \"\n              + recoveryDirName, e);\n    }\n\n    NMContainerTokenSecretManager containerTokenSecretManager \u003d\n        new NMContainerTokenSecretManager(conf, nmStore);\n\n    NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n        new NMTokenSecretManagerInNM(nmStore);\n\n    recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n    \n    this.aclsManager \u003d new ApplicationACLsManager(conf);\n\n    ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n        conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n          DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n    try {\n      exec.init();\n    } catch (IOException e) {\n      throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n    }    \n    DeletionService del \u003d createDeletionService(exec);\n    addService(del);\n\n    // NodeManager level dispatcher\n    this.dispatcher \u003d new AsyncDispatcher();\n\n    dirsHandler \u003d new LocalDirsHandlerService(metrics);\n    nodeHealthChecker \u003d\n        new NodeHealthCheckerService(\n            getNodeHealthScriptRunner(conf), dirsHandler);\n    addService(nodeHealthChecker);\n\n    boolean isDistSchedulingEnabled \u003d\n        conf.getBoolean(YarnConfiguration.DIST_SCHEDULING_ENABLED,\n            YarnConfiguration.DIST_SCHEDULING_ENABLED_DEFAULT);\n\n    this.context \u003d createNMContext(containerTokenSecretManager,\n        nmTokenSecretManager, nmStore, isDistSchedulingEnabled);\n\n    nodeLabelsProvider \u003d createNodeLabelsProvider(conf);\n\n    if (null \u003d\u003d nodeLabelsProvider) {\n      nodeStatusUpdater \u003d\n          createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n    } else {\n      addIfService(nodeLabelsProvider);\n      nodeStatusUpdater \u003d\n          createNodeStatusUpdater(context, dispatcher, nodeHealthChecker,\n              nodeLabelsProvider);\n    }\n\n    nodeResourceMonitor \u003d createNodeResourceMonitor();\n    addService(nodeResourceMonitor);\n    ((NMContext) context).setNodeResourceMonitor(nodeResourceMonitor);\n\n    containerManager \u003d\n        createContainerManager(context, exec, del, nodeStatusUpdater,\n        this.aclsManager, dirsHandler);\n    addService(containerManager);\n    ((NMContext) context).setContainerManager(containerManager);\n\n    WebServer webServer \u003d createWebServer(context, containerManager\n        .getContainersMonitor(), this.aclsManager, dirsHandler);\n    addService(webServer);\n    ((NMContext) context).setWebServer(webServer);\n\n    ((NMContext) context).setQueueableContainerAllocator(\n        new OpportunisticContainerAllocator(nodeStatusUpdater, context,\n            webServer.getPort()));\n\n    dispatcher.register(ContainerManagerEventType.class, containerManager);\n    dispatcher.register(NodeManagerEventType.class, this);\n    addService(dispatcher);\n\n    pauseMonitor \u003d new JvmPauseMonitor();\n    addService(pauseMonitor);\n    metrics.getJvmMetrics().setPauseMonitor(pauseMonitor);\n\n    DefaultMetricsSystem.initialize(\"NodeManager\");\n    \n    this.nmAggregatorService \u003d createNMAggregatorService(context);\n    addService(nmAggregatorService);\n\n    // StatusUpdater should be added last so that it get started last \n    // so that we make sure everything is up before registering with RM. \n    addService(nodeStatusUpdater);\n    ((NMContext) context).setNodeStatusUpdater(nodeStatusUpdater);\n\n    super.serviceInit(conf);\n    // TODO add local dirs to del\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java",
      "extendedDetails": {}
    },
    "0a5def155eff4564b5dc7685e7460952f51bbd24": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4568. Fix message when NodeManager runs into errors initializing the recovery directory. (rchiang)\n",
      "commitDate": "01/07/16 3:53 PM",
      "commitName": "0a5def155eff4564b5dc7685e7460952f51bbd24",
      "commitAuthor": "Ray Chiang",
      "commitDateOld": "13/05/16 1:38 PM",
      "commitNameOld": "f0ac18d001d97914a9ee810b1fab56c5cebff830",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 49.09,
      "commitsBetweenForRepo": 359,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,96 +1,103 @@\n   protected void serviceInit(Configuration conf) throws Exception {\n \n     conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n \n     rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n             .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n         YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n \n-    initAndStartRecoveryStore(conf);\n+    try {\n+      initAndStartRecoveryStore(conf);\n+    } catch (IOException e) {\n+      String recoveryDirName \u003d conf.get(YarnConfiguration.NM_RECOVERY_DIR);\n+      throw new\n+          YarnRuntimeException(\"Unable to initialize recovery directory at \"\n+              + recoveryDirName, e);\n+    }\n \n     NMContainerTokenSecretManager containerTokenSecretManager \u003d\n         new NMContainerTokenSecretManager(conf, nmStore);\n \n     NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n         new NMTokenSecretManagerInNM(nmStore);\n \n     recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n     \n     this.aclsManager \u003d new ApplicationACLsManager(conf);\n \n     ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n         conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n           DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n     try {\n       exec.init();\n     } catch (IOException e) {\n       throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n     }    \n     DeletionService del \u003d createDeletionService(exec);\n     addService(del);\n \n     // NodeManager level dispatcher\n     this.dispatcher \u003d new AsyncDispatcher();\n \n     dirsHandler \u003d new LocalDirsHandlerService(metrics);\n     nodeHealthChecker \u003d\n         new NodeHealthCheckerService(\n             getNodeHealthScriptRunner(conf), dirsHandler);\n     addService(nodeHealthChecker);\n \n     boolean isDistSchedulingEnabled \u003d\n         conf.getBoolean(YarnConfiguration.DIST_SCHEDULING_ENABLED,\n             YarnConfiguration.DIST_SCHEDULING_ENABLED_DEFAULT);\n \n     this.context \u003d createNMContext(containerTokenSecretManager,\n         nmTokenSecretManager, nmStore, isDistSchedulingEnabled);\n \n     nodeLabelsProvider \u003d createNodeLabelsProvider(conf);\n \n     if (null \u003d\u003d nodeLabelsProvider) {\n       nodeStatusUpdater \u003d\n           createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n     } else {\n       addIfService(nodeLabelsProvider);\n       nodeStatusUpdater \u003d\n           createNodeStatusUpdater(context, dispatcher, nodeHealthChecker,\n               nodeLabelsProvider);\n     }\n \n     nodeResourceMonitor \u003d createNodeResourceMonitor();\n     addService(nodeResourceMonitor);\n     ((NMContext) context).setNodeResourceMonitor(nodeResourceMonitor);\n \n     containerManager \u003d\n         createContainerManager(context, exec, del, nodeStatusUpdater,\n         this.aclsManager, dirsHandler);\n     addService(containerManager);\n     ((NMContext) context).setContainerManager(containerManager);\n \n     WebServer webServer \u003d createWebServer(context, containerManager\n         .getContainersMonitor(), this.aclsManager, dirsHandler);\n     addService(webServer);\n     ((NMContext) context).setWebServer(webServer);\n \n     ((NMContext) context).setQueueableContainerAllocator(\n         new OpportunisticContainerAllocator(nodeStatusUpdater, context,\n             webServer.getPort()));\n \n     dispatcher.register(ContainerManagerEventType.class, containerManager);\n     dispatcher.register(NodeManagerEventType.class, this);\n     addService(dispatcher);\n \n     pauseMonitor \u003d new JvmPauseMonitor();\n     addService(pauseMonitor);\n     metrics.getJvmMetrics().setPauseMonitor(pauseMonitor);\n \n     DefaultMetricsSystem.initialize(\"NodeManager\");\n \n     // StatusUpdater should be added last so that it get started last \n     // so that we make sure everything is up before registering with RM. \n     addService(nodeStatusUpdater);\n     ((NMContext) context).setNodeStatusUpdater(nodeStatusUpdater);\n \n     super.serviceInit(conf);\n     // TODO add local dirs to del\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceInit(Configuration conf) throws Exception {\n\n    conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n\n    rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n            .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n        YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n\n    try {\n      initAndStartRecoveryStore(conf);\n    } catch (IOException e) {\n      String recoveryDirName \u003d conf.get(YarnConfiguration.NM_RECOVERY_DIR);\n      throw new\n          YarnRuntimeException(\"Unable to initialize recovery directory at \"\n              + recoveryDirName, e);\n    }\n\n    NMContainerTokenSecretManager containerTokenSecretManager \u003d\n        new NMContainerTokenSecretManager(conf, nmStore);\n\n    NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n        new NMTokenSecretManagerInNM(nmStore);\n\n    recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n    \n    this.aclsManager \u003d new ApplicationACLsManager(conf);\n\n    ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n        conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n          DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n    try {\n      exec.init();\n    } catch (IOException e) {\n      throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n    }    \n    DeletionService del \u003d createDeletionService(exec);\n    addService(del);\n\n    // NodeManager level dispatcher\n    this.dispatcher \u003d new AsyncDispatcher();\n\n    dirsHandler \u003d new LocalDirsHandlerService(metrics);\n    nodeHealthChecker \u003d\n        new NodeHealthCheckerService(\n            getNodeHealthScriptRunner(conf), dirsHandler);\n    addService(nodeHealthChecker);\n\n    boolean isDistSchedulingEnabled \u003d\n        conf.getBoolean(YarnConfiguration.DIST_SCHEDULING_ENABLED,\n            YarnConfiguration.DIST_SCHEDULING_ENABLED_DEFAULT);\n\n    this.context \u003d createNMContext(containerTokenSecretManager,\n        nmTokenSecretManager, nmStore, isDistSchedulingEnabled);\n\n    nodeLabelsProvider \u003d createNodeLabelsProvider(conf);\n\n    if (null \u003d\u003d nodeLabelsProvider) {\n      nodeStatusUpdater \u003d\n          createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n    } else {\n      addIfService(nodeLabelsProvider);\n      nodeStatusUpdater \u003d\n          createNodeStatusUpdater(context, dispatcher, nodeHealthChecker,\n              nodeLabelsProvider);\n    }\n\n    nodeResourceMonitor \u003d createNodeResourceMonitor();\n    addService(nodeResourceMonitor);\n    ((NMContext) context).setNodeResourceMonitor(nodeResourceMonitor);\n\n    containerManager \u003d\n        createContainerManager(context, exec, del, nodeStatusUpdater,\n        this.aclsManager, dirsHandler);\n    addService(containerManager);\n    ((NMContext) context).setContainerManager(containerManager);\n\n    WebServer webServer \u003d createWebServer(context, containerManager\n        .getContainersMonitor(), this.aclsManager, dirsHandler);\n    addService(webServer);\n    ((NMContext) context).setWebServer(webServer);\n\n    ((NMContext) context).setQueueableContainerAllocator(\n        new OpportunisticContainerAllocator(nodeStatusUpdater, context,\n            webServer.getPort()));\n\n    dispatcher.register(ContainerManagerEventType.class, containerManager);\n    dispatcher.register(NodeManagerEventType.class, this);\n    addService(dispatcher);\n\n    pauseMonitor \u003d new JvmPauseMonitor();\n    addService(pauseMonitor);\n    metrics.getJvmMetrics().setPauseMonitor(pauseMonitor);\n\n    DefaultMetricsSystem.initialize(\"NodeManager\");\n\n    // StatusUpdater should be added last so that it get started last \n    // so that we make sure everything is up before registering with RM. \n    addService(nodeStatusUpdater);\n    ((NMContext) context).setNodeStatusUpdater(nodeStatusUpdater);\n\n    super.serviceInit(conf);\n    // TODO add local dirs to del\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java",
      "extendedDetails": {}
    },
    "c282a08f3892e2e8ceb58e1e9a411062fbd1fb2b": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2885. Create AMRMProxy request interceptor and ContainerAllocator to distribute OPPORTUNISTIC containers to appropriate Nodes (asuresh)\n\n(cherry picked from commit 2bf025278a318b0452fdc9ece4427b4c42124e39)\n",
      "commitDate": "24/04/16 10:38 PM",
      "commitName": "c282a08f3892e2e8ceb58e1e9a411062fbd1fb2b",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "20/04/16 9:55 AM",
      "commitNameOld": "c8172f5f143d2fefafa5a412899ab7cd081b406d",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 4.53,
      "commitsBetweenForRepo": 30,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,88 +1,96 @@\n   protected void serviceInit(Configuration conf) throws Exception {\n \n     conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n \n     rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n             .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n         YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n \n     initAndStartRecoveryStore(conf);\n \n     NMContainerTokenSecretManager containerTokenSecretManager \u003d\n         new NMContainerTokenSecretManager(conf, nmStore);\n \n     NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n         new NMTokenSecretManagerInNM(nmStore);\n \n     recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n     \n     this.aclsManager \u003d new ApplicationACLsManager(conf);\n \n     ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n         conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n           DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n     try {\n       exec.init();\n     } catch (IOException e) {\n       throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n     }    \n     DeletionService del \u003d createDeletionService(exec);\n     addService(del);\n \n     // NodeManager level dispatcher\n     this.dispatcher \u003d new AsyncDispatcher();\n \n     dirsHandler \u003d new LocalDirsHandlerService(metrics);\n     nodeHealthChecker \u003d\n         new NodeHealthCheckerService(\n             getNodeHealthScriptRunner(conf), dirsHandler);\n     addService(nodeHealthChecker);\n \n+    boolean isDistSchedulingEnabled \u003d\n+        conf.getBoolean(YarnConfiguration.DIST_SCHEDULING_ENABLED,\n+            YarnConfiguration.DIST_SCHEDULING_ENABLED_DEFAULT);\n+\n     this.context \u003d createNMContext(containerTokenSecretManager,\n-        nmTokenSecretManager, nmStore);\n+        nmTokenSecretManager, nmStore, isDistSchedulingEnabled);\n \n     nodeLabelsProvider \u003d createNodeLabelsProvider(conf);\n \n     if (null \u003d\u003d nodeLabelsProvider) {\n       nodeStatusUpdater \u003d\n           createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n     } else {\n       addIfService(nodeLabelsProvider);\n       nodeStatusUpdater \u003d\n           createNodeStatusUpdater(context, dispatcher, nodeHealthChecker,\n               nodeLabelsProvider);\n     }\n \n     nodeResourceMonitor \u003d createNodeResourceMonitor();\n     addService(nodeResourceMonitor);\n     ((NMContext) context).setNodeResourceMonitor(nodeResourceMonitor);\n \n     containerManager \u003d\n         createContainerManager(context, exec, del, nodeStatusUpdater,\n         this.aclsManager, dirsHandler);\n     addService(containerManager);\n     ((NMContext) context).setContainerManager(containerManager);\n \n     WebServer webServer \u003d createWebServer(context, containerManager\n         .getContainersMonitor(), this.aclsManager, dirsHandler);\n     addService(webServer);\n     ((NMContext) context).setWebServer(webServer);\n \n+    ((NMContext) context).setQueueableContainerAllocator(\n+        new OpportunisticContainerAllocator(nodeStatusUpdater, context,\n+            webServer.getPort()));\n+\n     dispatcher.register(ContainerManagerEventType.class, containerManager);\n     dispatcher.register(NodeManagerEventType.class, this);\n     addService(dispatcher);\n \n     pauseMonitor \u003d new JvmPauseMonitor();\n     addService(pauseMonitor);\n     metrics.getJvmMetrics().setPauseMonitor(pauseMonitor);\n \n     DefaultMetricsSystem.initialize(\"NodeManager\");\n \n     // StatusUpdater should be added last so that it get started last \n     // so that we make sure everything is up before registering with RM. \n     addService(nodeStatusUpdater);\n     ((NMContext) context).setNodeStatusUpdater(nodeStatusUpdater);\n \n     super.serviceInit(conf);\n     // TODO add local dirs to del\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceInit(Configuration conf) throws Exception {\n\n    conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n\n    rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n            .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n        YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n\n    initAndStartRecoveryStore(conf);\n\n    NMContainerTokenSecretManager containerTokenSecretManager \u003d\n        new NMContainerTokenSecretManager(conf, nmStore);\n\n    NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n        new NMTokenSecretManagerInNM(nmStore);\n\n    recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n    \n    this.aclsManager \u003d new ApplicationACLsManager(conf);\n\n    ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n        conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n          DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n    try {\n      exec.init();\n    } catch (IOException e) {\n      throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n    }    \n    DeletionService del \u003d createDeletionService(exec);\n    addService(del);\n\n    // NodeManager level dispatcher\n    this.dispatcher \u003d new AsyncDispatcher();\n\n    dirsHandler \u003d new LocalDirsHandlerService(metrics);\n    nodeHealthChecker \u003d\n        new NodeHealthCheckerService(\n            getNodeHealthScriptRunner(conf), dirsHandler);\n    addService(nodeHealthChecker);\n\n    boolean isDistSchedulingEnabled \u003d\n        conf.getBoolean(YarnConfiguration.DIST_SCHEDULING_ENABLED,\n            YarnConfiguration.DIST_SCHEDULING_ENABLED_DEFAULT);\n\n    this.context \u003d createNMContext(containerTokenSecretManager,\n        nmTokenSecretManager, nmStore, isDistSchedulingEnabled);\n\n    nodeLabelsProvider \u003d createNodeLabelsProvider(conf);\n\n    if (null \u003d\u003d nodeLabelsProvider) {\n      nodeStatusUpdater \u003d\n          createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n    } else {\n      addIfService(nodeLabelsProvider);\n      nodeStatusUpdater \u003d\n          createNodeStatusUpdater(context, dispatcher, nodeHealthChecker,\n              nodeLabelsProvider);\n    }\n\n    nodeResourceMonitor \u003d createNodeResourceMonitor();\n    addService(nodeResourceMonitor);\n    ((NMContext) context).setNodeResourceMonitor(nodeResourceMonitor);\n\n    containerManager \u003d\n        createContainerManager(context, exec, del, nodeStatusUpdater,\n        this.aclsManager, dirsHandler);\n    addService(containerManager);\n    ((NMContext) context).setContainerManager(containerManager);\n\n    WebServer webServer \u003d createWebServer(context, containerManager\n        .getContainersMonitor(), this.aclsManager, dirsHandler);\n    addService(webServer);\n    ((NMContext) context).setWebServer(webServer);\n\n    ((NMContext) context).setQueueableContainerAllocator(\n        new OpportunisticContainerAllocator(nodeStatusUpdater, context,\n            webServer.getPort()));\n\n    dispatcher.register(ContainerManagerEventType.class, containerManager);\n    dispatcher.register(NodeManagerEventType.class, this);\n    addService(dispatcher);\n\n    pauseMonitor \u003d new JvmPauseMonitor();\n    addService(pauseMonitor);\n    metrics.getJvmMetrics().setPauseMonitor(pauseMonitor);\n\n    DefaultMetricsSystem.initialize(\"NodeManager\");\n\n    // StatusUpdater should be added last so that it get started last \n    // so that we make sure everything is up before registering with RM. \n    addService(nodeStatusUpdater);\n    ((NMContext) context).setNodeStatusUpdater(nodeStatusUpdater);\n\n    super.serviceInit(conf);\n    // TODO add local dirs to del\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java",
      "extendedDetails": {}
    },
    "d284e187b8db43056236032ebc2114ee462c27f6": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2046. Out of band heartbeats are sent only on container kill and possibly too early. Contributed by Ming Ma\n",
      "commitDate": "23/02/16 12:49 PM",
      "commitName": "d284e187b8db43056236032ebc2114ee462c27f6",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "06/12/15 9:43 AM",
      "commitNameOld": "65f395226ba6cc3750a268a308e288b916f8df1e",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 79.13,
      "commitsBetweenForRepo": 498,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,87 +1,88 @@\n   protected void serviceInit(Configuration conf) throws Exception {\n \n     conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n \n     rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n             .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n         YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n \n     initAndStartRecoveryStore(conf);\n \n     NMContainerTokenSecretManager containerTokenSecretManager \u003d\n         new NMContainerTokenSecretManager(conf, nmStore);\n \n     NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n         new NMTokenSecretManagerInNM(nmStore);\n \n     recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n     \n     this.aclsManager \u003d new ApplicationACLsManager(conf);\n \n     ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n         conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n           DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n     try {\n       exec.init();\n     } catch (IOException e) {\n       throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n     }    \n     DeletionService del \u003d createDeletionService(exec);\n     addService(del);\n \n     // NodeManager level dispatcher\n     this.dispatcher \u003d new AsyncDispatcher();\n \n     dirsHandler \u003d new LocalDirsHandlerService(metrics);\n     nodeHealthChecker \u003d\n         new NodeHealthCheckerService(\n             getNodeHealthScriptRunner(conf), dirsHandler);\n     addService(nodeHealthChecker);\n \n     this.context \u003d createNMContext(containerTokenSecretManager,\n         nmTokenSecretManager, nmStore);\n \n     nodeLabelsProvider \u003d createNodeLabelsProvider(conf);\n \n     if (null \u003d\u003d nodeLabelsProvider) {\n       nodeStatusUpdater \u003d\n           createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n     } else {\n       addIfService(nodeLabelsProvider);\n       nodeStatusUpdater \u003d\n           createNodeStatusUpdater(context, dispatcher, nodeHealthChecker,\n               nodeLabelsProvider);\n     }\n \n     nodeResourceMonitor \u003d createNodeResourceMonitor();\n     addService(nodeResourceMonitor);\n     ((NMContext) context).setNodeResourceMonitor(nodeResourceMonitor);\n \n     containerManager \u003d\n         createContainerManager(context, exec, del, nodeStatusUpdater,\n         this.aclsManager, dirsHandler);\n     addService(containerManager);\n     ((NMContext) context).setContainerManager(containerManager);\n \n     WebServer webServer \u003d createWebServer(context, containerManager\n         .getContainersMonitor(), this.aclsManager, dirsHandler);\n     addService(webServer);\n     ((NMContext) context).setWebServer(webServer);\n \n     dispatcher.register(ContainerManagerEventType.class, containerManager);\n     dispatcher.register(NodeManagerEventType.class, this);\n     addService(dispatcher);\n \n     pauseMonitor \u003d new JvmPauseMonitor();\n     addService(pauseMonitor);\n     metrics.getJvmMetrics().setPauseMonitor(pauseMonitor);\n \n     DefaultMetricsSystem.initialize(\"NodeManager\");\n \n     // StatusUpdater should be added last so that it get started last \n     // so that we make sure everything is up before registering with RM. \n     addService(nodeStatusUpdater);\n+    ((NMContext) context).setNodeStatusUpdater(nodeStatusUpdater);\n \n     super.serviceInit(conf);\n     // TODO add local dirs to del\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceInit(Configuration conf) throws Exception {\n\n    conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n\n    rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n            .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n        YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n\n    initAndStartRecoveryStore(conf);\n\n    NMContainerTokenSecretManager containerTokenSecretManager \u003d\n        new NMContainerTokenSecretManager(conf, nmStore);\n\n    NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n        new NMTokenSecretManagerInNM(nmStore);\n\n    recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n    \n    this.aclsManager \u003d new ApplicationACLsManager(conf);\n\n    ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n        conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n          DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n    try {\n      exec.init();\n    } catch (IOException e) {\n      throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n    }    \n    DeletionService del \u003d createDeletionService(exec);\n    addService(del);\n\n    // NodeManager level dispatcher\n    this.dispatcher \u003d new AsyncDispatcher();\n\n    dirsHandler \u003d new LocalDirsHandlerService(metrics);\n    nodeHealthChecker \u003d\n        new NodeHealthCheckerService(\n            getNodeHealthScriptRunner(conf), dirsHandler);\n    addService(nodeHealthChecker);\n\n    this.context \u003d createNMContext(containerTokenSecretManager,\n        nmTokenSecretManager, nmStore);\n\n    nodeLabelsProvider \u003d createNodeLabelsProvider(conf);\n\n    if (null \u003d\u003d nodeLabelsProvider) {\n      nodeStatusUpdater \u003d\n          createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n    } else {\n      addIfService(nodeLabelsProvider);\n      nodeStatusUpdater \u003d\n          createNodeStatusUpdater(context, dispatcher, nodeHealthChecker,\n              nodeLabelsProvider);\n    }\n\n    nodeResourceMonitor \u003d createNodeResourceMonitor();\n    addService(nodeResourceMonitor);\n    ((NMContext) context).setNodeResourceMonitor(nodeResourceMonitor);\n\n    containerManager \u003d\n        createContainerManager(context, exec, del, nodeStatusUpdater,\n        this.aclsManager, dirsHandler);\n    addService(containerManager);\n    ((NMContext) context).setContainerManager(containerManager);\n\n    WebServer webServer \u003d createWebServer(context, containerManager\n        .getContainersMonitor(), this.aclsManager, dirsHandler);\n    addService(webServer);\n    ((NMContext) context).setWebServer(webServer);\n\n    dispatcher.register(ContainerManagerEventType.class, containerManager);\n    dispatcher.register(NodeManagerEventType.class, this);\n    addService(dispatcher);\n\n    pauseMonitor \u003d new JvmPauseMonitor();\n    addService(pauseMonitor);\n    metrics.getJvmMetrics().setPauseMonitor(pauseMonitor);\n\n    DefaultMetricsSystem.initialize(\"NodeManager\");\n\n    // StatusUpdater should be added last so that it get started last \n    // so that we make sure everything is up before registering with RM. \n    addService(nodeStatusUpdater);\n    ((NMContext) context).setNodeStatusUpdater(nodeStatusUpdater);\n\n    super.serviceInit(conf);\n    // TODO add local dirs to del\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java",
      "extendedDetails": {}
    },
    "65f395226ba6cc3750a268a308e288b916f8df1e": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-12321. Make JvmPauseMonitor an AbstractService. (Sunil G via Stevel) [includes HDFS-8947 MAPREDUCE-6462 and YARN-4072]\n",
      "commitDate": "06/12/15 9:43 AM",
      "commitName": "65f395226ba6cc3750a268a308e288b916f8df1e",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "26/10/15 3:12 AM",
      "commitNameOld": "5acdde4744c131e05db7b4b5f7d684fed7608b99",
      "commitAuthorOld": "Rohith Sharma K S",
      "daysBetweenCommits": 41.31,
      "commitsBetweenForRepo": 307,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,86 +1,87 @@\n   protected void serviceInit(Configuration conf) throws Exception {\n \n     conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n \n     rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n             .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n         YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n \n     initAndStartRecoveryStore(conf);\n \n     NMContainerTokenSecretManager containerTokenSecretManager \u003d\n         new NMContainerTokenSecretManager(conf, nmStore);\n \n     NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n         new NMTokenSecretManagerInNM(nmStore);\n \n     recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n     \n     this.aclsManager \u003d new ApplicationACLsManager(conf);\n \n     ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n         conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n           DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n     try {\n       exec.init();\n     } catch (IOException e) {\n       throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n     }    \n     DeletionService del \u003d createDeletionService(exec);\n     addService(del);\n \n     // NodeManager level dispatcher\n     this.dispatcher \u003d new AsyncDispatcher();\n \n     dirsHandler \u003d new LocalDirsHandlerService(metrics);\n     nodeHealthChecker \u003d\n         new NodeHealthCheckerService(\n             getNodeHealthScriptRunner(conf), dirsHandler);\n     addService(nodeHealthChecker);\n \n     this.context \u003d createNMContext(containerTokenSecretManager,\n         nmTokenSecretManager, nmStore);\n \n     nodeLabelsProvider \u003d createNodeLabelsProvider(conf);\n \n     if (null \u003d\u003d nodeLabelsProvider) {\n       nodeStatusUpdater \u003d\n           createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n     } else {\n       addIfService(nodeLabelsProvider);\n       nodeStatusUpdater \u003d\n           createNodeStatusUpdater(context, dispatcher, nodeHealthChecker,\n               nodeLabelsProvider);\n     }\n \n     nodeResourceMonitor \u003d createNodeResourceMonitor();\n     addService(nodeResourceMonitor);\n     ((NMContext) context).setNodeResourceMonitor(nodeResourceMonitor);\n \n     containerManager \u003d\n         createContainerManager(context, exec, del, nodeStatusUpdater,\n         this.aclsManager, dirsHandler);\n     addService(containerManager);\n     ((NMContext) context).setContainerManager(containerManager);\n \n     WebServer webServer \u003d createWebServer(context, containerManager\n         .getContainersMonitor(), this.aclsManager, dirsHandler);\n     addService(webServer);\n     ((NMContext) context).setWebServer(webServer);\n \n     dispatcher.register(ContainerManagerEventType.class, containerManager);\n     dispatcher.register(NodeManagerEventType.class, this);\n     addService(dispatcher);\n \n-    pauseMonitor \u003d new JvmPauseMonitor(conf);\n+    pauseMonitor \u003d new JvmPauseMonitor();\n+    addService(pauseMonitor);\n     metrics.getJvmMetrics().setPauseMonitor(pauseMonitor);\n \n     DefaultMetricsSystem.initialize(\"NodeManager\");\n \n     // StatusUpdater should be added last so that it get started last \n     // so that we make sure everything is up before registering with RM. \n     addService(nodeStatusUpdater);\n \n     super.serviceInit(conf);\n     // TODO add local dirs to del\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceInit(Configuration conf) throws Exception {\n\n    conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n\n    rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n            .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n        YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n\n    initAndStartRecoveryStore(conf);\n\n    NMContainerTokenSecretManager containerTokenSecretManager \u003d\n        new NMContainerTokenSecretManager(conf, nmStore);\n\n    NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n        new NMTokenSecretManagerInNM(nmStore);\n\n    recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n    \n    this.aclsManager \u003d new ApplicationACLsManager(conf);\n\n    ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n        conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n          DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n    try {\n      exec.init();\n    } catch (IOException e) {\n      throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n    }    \n    DeletionService del \u003d createDeletionService(exec);\n    addService(del);\n\n    // NodeManager level dispatcher\n    this.dispatcher \u003d new AsyncDispatcher();\n\n    dirsHandler \u003d new LocalDirsHandlerService(metrics);\n    nodeHealthChecker \u003d\n        new NodeHealthCheckerService(\n            getNodeHealthScriptRunner(conf), dirsHandler);\n    addService(nodeHealthChecker);\n\n    this.context \u003d createNMContext(containerTokenSecretManager,\n        nmTokenSecretManager, nmStore);\n\n    nodeLabelsProvider \u003d createNodeLabelsProvider(conf);\n\n    if (null \u003d\u003d nodeLabelsProvider) {\n      nodeStatusUpdater \u003d\n          createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n    } else {\n      addIfService(nodeLabelsProvider);\n      nodeStatusUpdater \u003d\n          createNodeStatusUpdater(context, dispatcher, nodeHealthChecker,\n              nodeLabelsProvider);\n    }\n\n    nodeResourceMonitor \u003d createNodeResourceMonitor();\n    addService(nodeResourceMonitor);\n    ((NMContext) context).setNodeResourceMonitor(nodeResourceMonitor);\n\n    containerManager \u003d\n        createContainerManager(context, exec, del, nodeStatusUpdater,\n        this.aclsManager, dirsHandler);\n    addService(containerManager);\n    ((NMContext) context).setContainerManager(containerManager);\n\n    WebServer webServer \u003d createWebServer(context, containerManager\n        .getContainersMonitor(), this.aclsManager, dirsHandler);\n    addService(webServer);\n    ((NMContext) context).setWebServer(webServer);\n\n    dispatcher.register(ContainerManagerEventType.class, containerManager);\n    dispatcher.register(NodeManagerEventType.class, this);\n    addService(dispatcher);\n\n    pauseMonitor \u003d new JvmPauseMonitor();\n    addService(pauseMonitor);\n    metrics.getJvmMetrics().setPauseMonitor(pauseMonitor);\n\n    DefaultMetricsSystem.initialize(\"NodeManager\");\n\n    // StatusUpdater should be added last so that it get started last \n    // so that we make sure everything is up before registering with RM. \n    addService(nodeStatusUpdater);\n\n    super.serviceInit(conf);\n    // TODO add local dirs to del\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java",
      "extendedDetails": {}
    },
    "5acdde4744c131e05db7b4b5f7d684fed7608b99": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2729. Support script based NodeLabelsProvider Interface in Distributed Node Label Configuration Setup. (Naganarasimha G R via rohithsharmaks)\n",
      "commitDate": "26/10/15 3:12 AM",
      "commitName": "5acdde4744c131e05db7b4b5f7d684fed7608b99",
      "commitAuthor": "Rohith Sharma K S",
      "commitDateOld": "05/10/15 10:56 AM",
      "commitNameOld": "f1c19b9365cbac88e45a9eed516fbfc6c9aa9947",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 20.68,
      "commitsBetweenForRepo": 170,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,86 +1,86 @@\n   protected void serviceInit(Configuration conf) throws Exception {\n \n     conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n \n     rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n             .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n         YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n \n     initAndStartRecoveryStore(conf);\n \n     NMContainerTokenSecretManager containerTokenSecretManager \u003d\n         new NMContainerTokenSecretManager(conf, nmStore);\n \n     NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n         new NMTokenSecretManagerInNM(nmStore);\n \n     recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n     \n     this.aclsManager \u003d new ApplicationACLsManager(conf);\n \n     ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n         conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n           DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n     try {\n       exec.init();\n     } catch (IOException e) {\n       throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n     }    \n     DeletionService del \u003d createDeletionService(exec);\n     addService(del);\n \n     // NodeManager level dispatcher\n     this.dispatcher \u003d new AsyncDispatcher();\n \n     dirsHandler \u003d new LocalDirsHandlerService(metrics);\n     nodeHealthChecker \u003d\n         new NodeHealthCheckerService(\n             getNodeHealthScriptRunner(conf), dirsHandler);\n     addService(nodeHealthChecker);\n \n     this.context \u003d createNMContext(containerTokenSecretManager,\n         nmTokenSecretManager, nmStore);\n \n     nodeLabelsProvider \u003d createNodeLabelsProvider(conf);\n \n     if (null \u003d\u003d nodeLabelsProvider) {\n       nodeStatusUpdater \u003d\n           createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n     } else {\n-      addService(nodeLabelsProvider);\n+      addIfService(nodeLabelsProvider);\n       nodeStatusUpdater \u003d\n           createNodeStatusUpdater(context, dispatcher, nodeHealthChecker,\n               nodeLabelsProvider);\n     }\n \n     nodeResourceMonitor \u003d createNodeResourceMonitor();\n     addService(nodeResourceMonitor);\n     ((NMContext) context).setNodeResourceMonitor(nodeResourceMonitor);\n \n     containerManager \u003d\n         createContainerManager(context, exec, del, nodeStatusUpdater,\n         this.aclsManager, dirsHandler);\n     addService(containerManager);\n     ((NMContext) context).setContainerManager(containerManager);\n \n     WebServer webServer \u003d createWebServer(context, containerManager\n         .getContainersMonitor(), this.aclsManager, dirsHandler);\n     addService(webServer);\n     ((NMContext) context).setWebServer(webServer);\n \n     dispatcher.register(ContainerManagerEventType.class, containerManager);\n     dispatcher.register(NodeManagerEventType.class, this);\n     addService(dispatcher);\n \n     pauseMonitor \u003d new JvmPauseMonitor(conf);\n     metrics.getJvmMetrics().setPauseMonitor(pauseMonitor);\n \n     DefaultMetricsSystem.initialize(\"NodeManager\");\n \n     // StatusUpdater should be added last so that it get started last \n     // so that we make sure everything is up before registering with RM. \n     addService(nodeStatusUpdater);\n \n     super.serviceInit(conf);\n     // TODO add local dirs to del\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceInit(Configuration conf) throws Exception {\n\n    conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n\n    rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n            .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n        YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n\n    initAndStartRecoveryStore(conf);\n\n    NMContainerTokenSecretManager containerTokenSecretManager \u003d\n        new NMContainerTokenSecretManager(conf, nmStore);\n\n    NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n        new NMTokenSecretManagerInNM(nmStore);\n\n    recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n    \n    this.aclsManager \u003d new ApplicationACLsManager(conf);\n\n    ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n        conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n          DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n    try {\n      exec.init();\n    } catch (IOException e) {\n      throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n    }    \n    DeletionService del \u003d createDeletionService(exec);\n    addService(del);\n\n    // NodeManager level dispatcher\n    this.dispatcher \u003d new AsyncDispatcher();\n\n    dirsHandler \u003d new LocalDirsHandlerService(metrics);\n    nodeHealthChecker \u003d\n        new NodeHealthCheckerService(\n            getNodeHealthScriptRunner(conf), dirsHandler);\n    addService(nodeHealthChecker);\n\n    this.context \u003d createNMContext(containerTokenSecretManager,\n        nmTokenSecretManager, nmStore);\n\n    nodeLabelsProvider \u003d createNodeLabelsProvider(conf);\n\n    if (null \u003d\u003d nodeLabelsProvider) {\n      nodeStatusUpdater \u003d\n          createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n    } else {\n      addIfService(nodeLabelsProvider);\n      nodeStatusUpdater \u003d\n          createNodeStatusUpdater(context, dispatcher, nodeHealthChecker,\n              nodeLabelsProvider);\n    }\n\n    nodeResourceMonitor \u003d createNodeResourceMonitor();\n    addService(nodeResourceMonitor);\n    ((NMContext) context).setNodeResourceMonitor(nodeResourceMonitor);\n\n    containerManager \u003d\n        createContainerManager(context, exec, del, nodeStatusUpdater,\n        this.aclsManager, dirsHandler);\n    addService(containerManager);\n    ((NMContext) context).setContainerManager(containerManager);\n\n    WebServer webServer \u003d createWebServer(context, containerManager\n        .getContainersMonitor(), this.aclsManager, dirsHandler);\n    addService(webServer);\n    ((NMContext) context).setWebServer(webServer);\n\n    dispatcher.register(ContainerManagerEventType.class, containerManager);\n    dispatcher.register(NodeManagerEventType.class, this);\n    addService(dispatcher);\n\n    pauseMonitor \u003d new JvmPauseMonitor(conf);\n    metrics.getJvmMetrics().setPauseMonitor(pauseMonitor);\n\n    DefaultMetricsSystem.initialize(\"NodeManager\");\n\n    // StatusUpdater should be added last so that it get started last \n    // so that we make sure everything is up before registering with RM. \n    addService(nodeStatusUpdater);\n\n    super.serviceInit(conf);\n    // TODO add local dirs to del\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java",
      "extendedDetails": {}
    },
    "13604bd5f119fc81b9942190dfa366afad61bc92": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4055. Report node resource utilization in heartbeat. (Inigo Goiri via kasha)\n",
      "commitDate": "16/08/15 3:08 PM",
      "commitName": "13604bd5f119fc81b9942190dfa366afad61bc92",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "06/08/15 6:49 AM",
      "commitNameOld": "cfee02b3bdd1117370200c9d8ce216676cff8888",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 10.35,
      "commitsBetweenForRepo": 42,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,85 +1,86 @@\n   protected void serviceInit(Configuration conf) throws Exception {\n \n     conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n \n     rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n             .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n         YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n \n     initAndStartRecoveryStore(conf);\n \n     NMContainerTokenSecretManager containerTokenSecretManager \u003d\n         new NMContainerTokenSecretManager(conf, nmStore);\n \n     NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n         new NMTokenSecretManagerInNM(nmStore);\n \n     recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n     \n     this.aclsManager \u003d new ApplicationACLsManager(conf);\n \n     ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n         conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n           DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n     try {\n       exec.init();\n     } catch (IOException e) {\n       throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n     }    \n     DeletionService del \u003d createDeletionService(exec);\n     addService(del);\n \n     // NodeManager level dispatcher\n     this.dispatcher \u003d new AsyncDispatcher();\n \n     dirsHandler \u003d new LocalDirsHandlerService(metrics);\n     nodeHealthChecker \u003d\n         new NodeHealthCheckerService(\n             getNodeHealthScriptRunner(conf), dirsHandler);\n     addService(nodeHealthChecker);\n \n     this.context \u003d createNMContext(containerTokenSecretManager,\n         nmTokenSecretManager, nmStore);\n \n     nodeLabelsProvider \u003d createNodeLabelsProvider(conf);\n \n     if (null \u003d\u003d nodeLabelsProvider) {\n       nodeStatusUpdater \u003d\n           createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n     } else {\n       addService(nodeLabelsProvider);\n       nodeStatusUpdater \u003d\n           createNodeStatusUpdater(context, dispatcher, nodeHealthChecker,\n               nodeLabelsProvider);\n     }\n \n-    NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n+    nodeResourceMonitor \u003d createNodeResourceMonitor();\n     addService(nodeResourceMonitor);\n+    ((NMContext) context).setNodeResourceMonitor(nodeResourceMonitor);\n \n     containerManager \u003d\n         createContainerManager(context, exec, del, nodeStatusUpdater,\n         this.aclsManager, dirsHandler);\n     addService(containerManager);\n     ((NMContext) context).setContainerManager(containerManager);\n \n     WebServer webServer \u003d createWebServer(context, containerManager\n         .getContainersMonitor(), this.aclsManager, dirsHandler);\n     addService(webServer);\n     ((NMContext) context).setWebServer(webServer);\n \n     dispatcher.register(ContainerManagerEventType.class, containerManager);\n     dispatcher.register(NodeManagerEventType.class, this);\n     addService(dispatcher);\n \n     pauseMonitor \u003d new JvmPauseMonitor(conf);\n     metrics.getJvmMetrics().setPauseMonitor(pauseMonitor);\n \n     DefaultMetricsSystem.initialize(\"NodeManager\");\n \n     // StatusUpdater should be added last so that it get started last \n     // so that we make sure everything is up before registering with RM. \n     addService(nodeStatusUpdater);\n \n     super.serviceInit(conf);\n     // TODO add local dirs to del\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceInit(Configuration conf) throws Exception {\n\n    conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n\n    rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n            .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n        YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n\n    initAndStartRecoveryStore(conf);\n\n    NMContainerTokenSecretManager containerTokenSecretManager \u003d\n        new NMContainerTokenSecretManager(conf, nmStore);\n\n    NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n        new NMTokenSecretManagerInNM(nmStore);\n\n    recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n    \n    this.aclsManager \u003d new ApplicationACLsManager(conf);\n\n    ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n        conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n          DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n    try {\n      exec.init();\n    } catch (IOException e) {\n      throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n    }    \n    DeletionService del \u003d createDeletionService(exec);\n    addService(del);\n\n    // NodeManager level dispatcher\n    this.dispatcher \u003d new AsyncDispatcher();\n\n    dirsHandler \u003d new LocalDirsHandlerService(metrics);\n    nodeHealthChecker \u003d\n        new NodeHealthCheckerService(\n            getNodeHealthScriptRunner(conf), dirsHandler);\n    addService(nodeHealthChecker);\n\n    this.context \u003d createNMContext(containerTokenSecretManager,\n        nmTokenSecretManager, nmStore);\n\n    nodeLabelsProvider \u003d createNodeLabelsProvider(conf);\n\n    if (null \u003d\u003d nodeLabelsProvider) {\n      nodeStatusUpdater \u003d\n          createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n    } else {\n      addService(nodeLabelsProvider);\n      nodeStatusUpdater \u003d\n          createNodeStatusUpdater(context, dispatcher, nodeHealthChecker,\n              nodeLabelsProvider);\n    }\n\n    nodeResourceMonitor \u003d createNodeResourceMonitor();\n    addService(nodeResourceMonitor);\n    ((NMContext) context).setNodeResourceMonitor(nodeResourceMonitor);\n\n    containerManager \u003d\n        createContainerManager(context, exec, del, nodeStatusUpdater,\n        this.aclsManager, dirsHandler);\n    addService(containerManager);\n    ((NMContext) context).setContainerManager(containerManager);\n\n    WebServer webServer \u003d createWebServer(context, containerManager\n        .getContainersMonitor(), this.aclsManager, dirsHandler);\n    addService(webServer);\n    ((NMContext) context).setWebServer(webServer);\n\n    dispatcher.register(ContainerManagerEventType.class, containerManager);\n    dispatcher.register(NodeManagerEventType.class, this);\n    addService(dispatcher);\n\n    pauseMonitor \u003d new JvmPauseMonitor(conf);\n    metrics.getJvmMetrics().setPauseMonitor(pauseMonitor);\n\n    DefaultMetricsSystem.initialize(\"NodeManager\");\n\n    // StatusUpdater should be added last so that it get started last \n    // so that we make sure everything is up before registering with RM. \n    addService(nodeStatusUpdater);\n\n    super.serviceInit(conf);\n    // TODO add local dirs to del\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java",
      "extendedDetails": {}
    },
    "cfee02b3bdd1117370200c9d8ce216676cff8888": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4019. Add JvmPauseMonitor to ResourceManager and NodeManager. Contributed by Robert Kanter.\n",
      "commitDate": "06/08/15 6:49 AM",
      "commitName": "cfee02b3bdd1117370200c9d8ce216676cff8888",
      "commitAuthor": "Junping Du",
      "commitDateOld": "03/08/15 8:53 AM",
      "commitNameOld": "469cfcd695da979e56c83d9303f9bc1f898c08ce",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 2.91,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,82 +1,85 @@\n   protected void serviceInit(Configuration conf) throws Exception {\n \n     conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n \n     rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n             .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n         YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n \n     initAndStartRecoveryStore(conf);\n \n     NMContainerTokenSecretManager containerTokenSecretManager \u003d\n         new NMContainerTokenSecretManager(conf, nmStore);\n \n     NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n         new NMTokenSecretManagerInNM(nmStore);\n \n     recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n     \n     this.aclsManager \u003d new ApplicationACLsManager(conf);\n \n     ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n         conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n           DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n     try {\n       exec.init();\n     } catch (IOException e) {\n       throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n     }    \n     DeletionService del \u003d createDeletionService(exec);\n     addService(del);\n \n     // NodeManager level dispatcher\n     this.dispatcher \u003d new AsyncDispatcher();\n \n     dirsHandler \u003d new LocalDirsHandlerService(metrics);\n     nodeHealthChecker \u003d\n         new NodeHealthCheckerService(\n             getNodeHealthScriptRunner(conf), dirsHandler);\n     addService(nodeHealthChecker);\n \n     this.context \u003d createNMContext(containerTokenSecretManager,\n         nmTokenSecretManager, nmStore);\n \n     nodeLabelsProvider \u003d createNodeLabelsProvider(conf);\n \n     if (null \u003d\u003d nodeLabelsProvider) {\n       nodeStatusUpdater \u003d\n           createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n     } else {\n       addService(nodeLabelsProvider);\n       nodeStatusUpdater \u003d\n           createNodeStatusUpdater(context, dispatcher, nodeHealthChecker,\n               nodeLabelsProvider);\n     }\n \n     NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n     addService(nodeResourceMonitor);\n \n     containerManager \u003d\n         createContainerManager(context, exec, del, nodeStatusUpdater,\n         this.aclsManager, dirsHandler);\n     addService(containerManager);\n     ((NMContext) context).setContainerManager(containerManager);\n \n     WebServer webServer \u003d createWebServer(context, containerManager\n         .getContainersMonitor(), this.aclsManager, dirsHandler);\n     addService(webServer);\n     ((NMContext) context).setWebServer(webServer);\n \n     dispatcher.register(ContainerManagerEventType.class, containerManager);\n     dispatcher.register(NodeManagerEventType.class, this);\n     addService(dispatcher);\n-    \n+\n+    pauseMonitor \u003d new JvmPauseMonitor(conf);\n+    metrics.getJvmMetrics().setPauseMonitor(pauseMonitor);\n+\n     DefaultMetricsSystem.initialize(\"NodeManager\");\n \n     // StatusUpdater should be added last so that it get started last \n     // so that we make sure everything is up before registering with RM. \n     addService(nodeStatusUpdater);\n-    \n+\n     super.serviceInit(conf);\n     // TODO add local dirs to del\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceInit(Configuration conf) throws Exception {\n\n    conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n\n    rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n            .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n        YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n\n    initAndStartRecoveryStore(conf);\n\n    NMContainerTokenSecretManager containerTokenSecretManager \u003d\n        new NMContainerTokenSecretManager(conf, nmStore);\n\n    NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n        new NMTokenSecretManagerInNM(nmStore);\n\n    recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n    \n    this.aclsManager \u003d new ApplicationACLsManager(conf);\n\n    ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n        conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n          DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n    try {\n      exec.init();\n    } catch (IOException e) {\n      throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n    }    \n    DeletionService del \u003d createDeletionService(exec);\n    addService(del);\n\n    // NodeManager level dispatcher\n    this.dispatcher \u003d new AsyncDispatcher();\n\n    dirsHandler \u003d new LocalDirsHandlerService(metrics);\n    nodeHealthChecker \u003d\n        new NodeHealthCheckerService(\n            getNodeHealthScriptRunner(conf), dirsHandler);\n    addService(nodeHealthChecker);\n\n    this.context \u003d createNMContext(containerTokenSecretManager,\n        nmTokenSecretManager, nmStore);\n\n    nodeLabelsProvider \u003d createNodeLabelsProvider(conf);\n\n    if (null \u003d\u003d nodeLabelsProvider) {\n      nodeStatusUpdater \u003d\n          createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n    } else {\n      addService(nodeLabelsProvider);\n      nodeStatusUpdater \u003d\n          createNodeStatusUpdater(context, dispatcher, nodeHealthChecker,\n              nodeLabelsProvider);\n    }\n\n    NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n    addService(nodeResourceMonitor);\n\n    containerManager \u003d\n        createContainerManager(context, exec, del, nodeStatusUpdater,\n        this.aclsManager, dirsHandler);\n    addService(containerManager);\n    ((NMContext) context).setContainerManager(containerManager);\n\n    WebServer webServer \u003d createWebServer(context, containerManager\n        .getContainersMonitor(), this.aclsManager, dirsHandler);\n    addService(webServer);\n    ((NMContext) context).setWebServer(webServer);\n\n    dispatcher.register(ContainerManagerEventType.class, containerManager);\n    dispatcher.register(NodeManagerEventType.class, this);\n    addService(dispatcher);\n\n    pauseMonitor \u003d new JvmPauseMonitor(conf);\n    metrics.getJvmMetrics().setPauseMonitor(pauseMonitor);\n\n    DefaultMetricsSystem.initialize(\"NodeManager\");\n\n    // StatusUpdater should be added last so that it get started last \n    // so that we make sure everything is up before registering with RM. \n    addService(nodeStatusUpdater);\n\n    super.serviceInit(conf);\n    // TODO add local dirs to del\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java",
      "extendedDetails": {}
    },
    "674c7ef64916fabbe59c8d6cdd50ca19cf7ddb7c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3503. Expose disk utilization percentage and bad local and log dir counts in NM metrics. Contributed by Varun Vasudev\n",
      "commitDate": "21/04/15 8:57 PM",
      "commitName": "674c7ef64916fabbe59c8d6cdd50ca19cf7ddb7c",
      "commitAuthor": "Jian He",
      "commitDateOld": "10/04/15 8:56 AM",
      "commitNameOld": "92431c961741747b5d6442f4025016d48d9a6863",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 11.5,
      "commitsBetweenForRepo": 78,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,82 +1,82 @@\n   protected void serviceInit(Configuration conf) throws Exception {\n \n     conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n \n     rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n             .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n         YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n \n     initAndStartRecoveryStore(conf);\n \n     NMContainerTokenSecretManager containerTokenSecretManager \u003d\n         new NMContainerTokenSecretManager(conf, nmStore);\n \n     NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n         new NMTokenSecretManagerInNM(nmStore);\n \n     recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n     \n     this.aclsManager \u003d new ApplicationACLsManager(conf);\n \n     ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n         conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n           DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n     try {\n       exec.init();\n     } catch (IOException e) {\n       throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n     }    \n     DeletionService del \u003d createDeletionService(exec);\n     addService(del);\n \n     // NodeManager level dispatcher\n     this.dispatcher \u003d new AsyncDispatcher();\n \n-    dirsHandler \u003d new LocalDirsHandlerService();\n+    dirsHandler \u003d new LocalDirsHandlerService(metrics);\n     nodeHealthChecker \u003d\n         new NodeHealthCheckerService(\n             getNodeHealthScriptRunner(conf), dirsHandler);\n     addService(nodeHealthChecker);\n \n     this.context \u003d createNMContext(containerTokenSecretManager,\n         nmTokenSecretManager, nmStore);\n \n     nodeLabelsProvider \u003d createNodeLabelsProvider(conf);\n \n     if (null \u003d\u003d nodeLabelsProvider) {\n       nodeStatusUpdater \u003d\n           createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n     } else {\n       addService(nodeLabelsProvider);\n       nodeStatusUpdater \u003d\n           createNodeStatusUpdater(context, dispatcher, nodeHealthChecker,\n               nodeLabelsProvider);\n     }\n \n     NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n     addService(nodeResourceMonitor);\n \n     containerManager \u003d\n         createContainerManager(context, exec, del, nodeStatusUpdater,\n         this.aclsManager, dirsHandler);\n     addService(containerManager);\n     ((NMContext) context).setContainerManager(containerManager);\n \n     WebServer webServer \u003d createWebServer(context, containerManager\n         .getContainersMonitor(), this.aclsManager, dirsHandler);\n     addService(webServer);\n     ((NMContext) context).setWebServer(webServer);\n \n     dispatcher.register(ContainerManagerEventType.class, containerManager);\n     dispatcher.register(NodeManagerEventType.class, this);\n     addService(dispatcher);\n     \n     DefaultMetricsSystem.initialize(\"NodeManager\");\n \n     // StatusUpdater should be added last so that it get started last \n     // so that we make sure everything is up before registering with RM. \n     addService(nodeStatusUpdater);\n     \n     super.serviceInit(conf);\n     // TODO add local dirs to del\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceInit(Configuration conf) throws Exception {\n\n    conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n\n    rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n            .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n        YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n\n    initAndStartRecoveryStore(conf);\n\n    NMContainerTokenSecretManager containerTokenSecretManager \u003d\n        new NMContainerTokenSecretManager(conf, nmStore);\n\n    NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n        new NMTokenSecretManagerInNM(nmStore);\n\n    recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n    \n    this.aclsManager \u003d new ApplicationACLsManager(conf);\n\n    ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n        conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n          DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n    try {\n      exec.init();\n    } catch (IOException e) {\n      throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n    }    \n    DeletionService del \u003d createDeletionService(exec);\n    addService(del);\n\n    // NodeManager level dispatcher\n    this.dispatcher \u003d new AsyncDispatcher();\n\n    dirsHandler \u003d new LocalDirsHandlerService(metrics);\n    nodeHealthChecker \u003d\n        new NodeHealthCheckerService(\n            getNodeHealthScriptRunner(conf), dirsHandler);\n    addService(nodeHealthChecker);\n\n    this.context \u003d createNMContext(containerTokenSecretManager,\n        nmTokenSecretManager, nmStore);\n\n    nodeLabelsProvider \u003d createNodeLabelsProvider(conf);\n\n    if (null \u003d\u003d nodeLabelsProvider) {\n      nodeStatusUpdater \u003d\n          createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n    } else {\n      addService(nodeLabelsProvider);\n      nodeStatusUpdater \u003d\n          createNodeStatusUpdater(context, dispatcher, nodeHealthChecker,\n              nodeLabelsProvider);\n    }\n\n    NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n    addService(nodeResourceMonitor);\n\n    containerManager \u003d\n        createContainerManager(context, exec, del, nodeStatusUpdater,\n        this.aclsManager, dirsHandler);\n    addService(containerManager);\n    ((NMContext) context).setContainerManager(containerManager);\n\n    WebServer webServer \u003d createWebServer(context, containerManager\n        .getContainersMonitor(), this.aclsManager, dirsHandler);\n    addService(webServer);\n    ((NMContext) context).setWebServer(webServer);\n\n    dispatcher.register(ContainerManagerEventType.class, containerManager);\n    dispatcher.register(NodeManagerEventType.class, this);\n    addService(dispatcher);\n    \n    DefaultMetricsSystem.initialize(\"NodeManager\");\n\n    // StatusUpdater should be added last so that it get started last \n    // so that we make sure everything is up before registering with RM. \n    addService(nodeStatusUpdater);\n    \n    super.serviceInit(conf);\n    // TODO add local dirs to del\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java",
      "extendedDetails": {}
    },
    "2a945d24f7de1a7ae6e7bd6636188ce3b55c7f52": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2495. Allow admin specify labels from each NM (Distributed configuration for node label). (Naganarasimha G R via wangda)\n",
      "commitDate": "30/03/15 12:05 PM",
      "commitName": "2a945d24f7de1a7ae6e7bd6636188ce3b55c7f52",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "26/02/15 5:12 PM",
      "commitNameOld": "8ca0d957c4b1076e801e1cdce5b44aa805de889c",
      "commitAuthorOld": "Konstantin V Shvachko",
      "daysBetweenCommits": 31.75,
      "commitsBetweenForRepo": 273,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,73 +1,82 @@\n   protected void serviceInit(Configuration conf) throws Exception {\n \n     conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n \n     rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n             .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n         YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n \n     initAndStartRecoveryStore(conf);\n \n     NMContainerTokenSecretManager containerTokenSecretManager \u003d\n         new NMContainerTokenSecretManager(conf, nmStore);\n \n     NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n         new NMTokenSecretManagerInNM(nmStore);\n \n     recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n     \n     this.aclsManager \u003d new ApplicationACLsManager(conf);\n \n     ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n         conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n           DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n     try {\n       exec.init();\n     } catch (IOException e) {\n       throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n     }    \n     DeletionService del \u003d createDeletionService(exec);\n     addService(del);\n \n     // NodeManager level dispatcher\n     this.dispatcher \u003d new AsyncDispatcher();\n \n     dirsHandler \u003d new LocalDirsHandlerService();\n     nodeHealthChecker \u003d\n         new NodeHealthCheckerService(\n             getNodeHealthScriptRunner(conf), dirsHandler);\n     addService(nodeHealthChecker);\n \n     this.context \u003d createNMContext(containerTokenSecretManager,\n         nmTokenSecretManager, nmStore);\n-    \n-    nodeStatusUpdater \u003d\n-        createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n+\n+    nodeLabelsProvider \u003d createNodeLabelsProvider(conf);\n+\n+    if (null \u003d\u003d nodeLabelsProvider) {\n+      nodeStatusUpdater \u003d\n+          createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n+    } else {\n+      addService(nodeLabelsProvider);\n+      nodeStatusUpdater \u003d\n+          createNodeStatusUpdater(context, dispatcher, nodeHealthChecker,\n+              nodeLabelsProvider);\n+    }\n \n     NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n     addService(nodeResourceMonitor);\n \n     containerManager \u003d\n         createContainerManager(context, exec, del, nodeStatusUpdater,\n         this.aclsManager, dirsHandler);\n     addService(containerManager);\n     ((NMContext) context).setContainerManager(containerManager);\n \n     WebServer webServer \u003d createWebServer(context, containerManager\n         .getContainersMonitor(), this.aclsManager, dirsHandler);\n     addService(webServer);\n     ((NMContext) context).setWebServer(webServer);\n \n     dispatcher.register(ContainerManagerEventType.class, containerManager);\n     dispatcher.register(NodeManagerEventType.class, this);\n     addService(dispatcher);\n     \n     DefaultMetricsSystem.initialize(\"NodeManager\");\n \n     // StatusUpdater should be added last so that it get started last \n     // so that we make sure everything is up before registering with RM. \n     addService(nodeStatusUpdater);\n     \n     super.serviceInit(conf);\n     // TODO add local dirs to del\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceInit(Configuration conf) throws Exception {\n\n    conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n\n    rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n            .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n        YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n\n    initAndStartRecoveryStore(conf);\n\n    NMContainerTokenSecretManager containerTokenSecretManager \u003d\n        new NMContainerTokenSecretManager(conf, nmStore);\n\n    NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n        new NMTokenSecretManagerInNM(nmStore);\n\n    recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n    \n    this.aclsManager \u003d new ApplicationACLsManager(conf);\n\n    ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n        conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n          DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n    try {\n      exec.init();\n    } catch (IOException e) {\n      throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n    }    \n    DeletionService del \u003d createDeletionService(exec);\n    addService(del);\n\n    // NodeManager level dispatcher\n    this.dispatcher \u003d new AsyncDispatcher();\n\n    dirsHandler \u003d new LocalDirsHandlerService();\n    nodeHealthChecker \u003d\n        new NodeHealthCheckerService(\n            getNodeHealthScriptRunner(conf), dirsHandler);\n    addService(nodeHealthChecker);\n\n    this.context \u003d createNMContext(containerTokenSecretManager,\n        nmTokenSecretManager, nmStore);\n\n    nodeLabelsProvider \u003d createNodeLabelsProvider(conf);\n\n    if (null \u003d\u003d nodeLabelsProvider) {\n      nodeStatusUpdater \u003d\n          createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n    } else {\n      addService(nodeLabelsProvider);\n      nodeStatusUpdater \u003d\n          createNodeStatusUpdater(context, dispatcher, nodeHealthChecker,\n              nodeLabelsProvider);\n    }\n\n    NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n    addService(nodeResourceMonitor);\n\n    containerManager \u003d\n        createContainerManager(context, exec, del, nodeStatusUpdater,\n        this.aclsManager, dirsHandler);\n    addService(containerManager);\n    ((NMContext) context).setContainerManager(containerManager);\n\n    WebServer webServer \u003d createWebServer(context, containerManager\n        .getContainersMonitor(), this.aclsManager, dirsHandler);\n    addService(webServer);\n    ((NMContext) context).setWebServer(webServer);\n\n    dispatcher.register(ContainerManagerEventType.class, containerManager);\n    dispatcher.register(NodeManagerEventType.class, this);\n    addService(dispatcher);\n    \n    DefaultMetricsSystem.initialize(\"NodeManager\");\n\n    // StatusUpdater should be added last so that it get started last \n    // so that we make sure everything is up before registering with RM. \n    addService(nodeStatusUpdater);\n    \n    super.serviceInit(conf);\n    // TODO add local dirs to del\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java",
      "extendedDetails": {}
    },
    "d4ac6822e1c5dfac504ced48f10ab57a55b49e93": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2980. Move health check script related functionality to hadoop-common (Varun Saxena via aw)\n",
      "commitDate": "24/02/15 11:25 AM",
      "commitName": "d4ac6822e1c5dfac504ced48f10ab57a55b49e93",
      "commitAuthor": "Allen Wittenauer",
      "commitDateOld": "12/11/14 11:07 AM",
      "commitNameOld": "be7bf956e96dd0fd9b521ca71df9124b9cc5ebd0",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 104.01,
      "commitsBetweenForRepo": 762,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,71 +1,73 @@\n   protected void serviceInit(Configuration conf) throws Exception {\n \n     conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n \n     rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n             .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n         YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n \n     initAndStartRecoveryStore(conf);\n \n     NMContainerTokenSecretManager containerTokenSecretManager \u003d\n         new NMContainerTokenSecretManager(conf, nmStore);\n \n     NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n         new NMTokenSecretManagerInNM(nmStore);\n \n     recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n     \n     this.aclsManager \u003d new ApplicationACLsManager(conf);\n \n     ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n         conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n           DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n     try {\n       exec.init();\n     } catch (IOException e) {\n       throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n     }    \n     DeletionService del \u003d createDeletionService(exec);\n     addService(del);\n \n     // NodeManager level dispatcher\n     this.dispatcher \u003d new AsyncDispatcher();\n \n-    nodeHealthChecker \u003d new NodeHealthCheckerService();\n+    dirsHandler \u003d new LocalDirsHandlerService();\n+    nodeHealthChecker \u003d\n+        new NodeHealthCheckerService(\n+            getNodeHealthScriptRunner(conf), dirsHandler);\n     addService(nodeHealthChecker);\n-    dirsHandler \u003d nodeHealthChecker.getDiskHandler();\n \n     this.context \u003d createNMContext(containerTokenSecretManager,\n         nmTokenSecretManager, nmStore);\n     \n     nodeStatusUpdater \u003d\n         createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n \n     NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n     addService(nodeResourceMonitor);\n \n     containerManager \u003d\n         createContainerManager(context, exec, del, nodeStatusUpdater,\n         this.aclsManager, dirsHandler);\n     addService(containerManager);\n     ((NMContext) context).setContainerManager(containerManager);\n \n     WebServer webServer \u003d createWebServer(context, containerManager\n         .getContainersMonitor(), this.aclsManager, dirsHandler);\n     addService(webServer);\n     ((NMContext) context).setWebServer(webServer);\n \n     dispatcher.register(ContainerManagerEventType.class, containerManager);\n     dispatcher.register(NodeManagerEventType.class, this);\n     addService(dispatcher);\n     \n     DefaultMetricsSystem.initialize(\"NodeManager\");\n \n     // StatusUpdater should be added last so that it get started last \n     // so that we make sure everything is up before registering with RM. \n     addService(nodeStatusUpdater);\n     \n     super.serviceInit(conf);\n     // TODO add local dirs to del\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceInit(Configuration conf) throws Exception {\n\n    conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n\n    rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n            .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n        YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n\n    initAndStartRecoveryStore(conf);\n\n    NMContainerTokenSecretManager containerTokenSecretManager \u003d\n        new NMContainerTokenSecretManager(conf, nmStore);\n\n    NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n        new NMTokenSecretManagerInNM(nmStore);\n\n    recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n    \n    this.aclsManager \u003d new ApplicationACLsManager(conf);\n\n    ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n        conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n          DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n    try {\n      exec.init();\n    } catch (IOException e) {\n      throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n    }    \n    DeletionService del \u003d createDeletionService(exec);\n    addService(del);\n\n    // NodeManager level dispatcher\n    this.dispatcher \u003d new AsyncDispatcher();\n\n    dirsHandler \u003d new LocalDirsHandlerService();\n    nodeHealthChecker \u003d\n        new NodeHealthCheckerService(\n            getNodeHealthScriptRunner(conf), dirsHandler);\n    addService(nodeHealthChecker);\n\n    this.context \u003d createNMContext(containerTokenSecretManager,\n        nmTokenSecretManager, nmStore);\n    \n    nodeStatusUpdater \u003d\n        createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n\n    NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n    addService(nodeResourceMonitor);\n\n    containerManager \u003d\n        createContainerManager(context, exec, del, nodeStatusUpdater,\n        this.aclsManager, dirsHandler);\n    addService(containerManager);\n    ((NMContext) context).setContainerManager(containerManager);\n\n    WebServer webServer \u003d createWebServer(context, containerManager\n        .getContainersMonitor(), this.aclsManager, dirsHandler);\n    addService(webServer);\n    ((NMContext) context).setWebServer(webServer);\n\n    dispatcher.register(ContainerManagerEventType.class, containerManager);\n    dispatcher.register(NodeManagerEventType.class, this);\n    addService(dispatcher);\n    \n    DefaultMetricsSystem.initialize(\"NodeManager\");\n\n    // StatusUpdater should be added last so that it get started last \n    // so that we make sure everything is up before registering with RM. \n    addService(nodeStatusUpdater);\n    \n    super.serviceInit(conf);\n    // TODO add local dirs to del\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java",
      "extendedDetails": {}
    },
    "2050e0dad661bade3e140d7a5692cfe1999badc3": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1342. Recover container tokens upon nodemanager restart. Contributed by Jason Lowe.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1612995 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/07/14 10:02 PM",
      "commitName": "2050e0dad661bade3e140d7a5692cfe1999badc3",
      "commitAuthor": "Devarajulu K",
      "commitDateOld": "17/07/14 4:33 PM",
      "commitNameOld": "403ec8ea80d59f209823a7370dc8185fa2c1c368",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 6.23,
      "commitsBetweenForRepo": 56,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,71 +1,71 @@\n   protected void serviceInit(Configuration conf) throws Exception {\n \n     conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n \n     rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n             .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n         YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n \n     initAndStartRecoveryStore(conf);\n \n     NMContainerTokenSecretManager containerTokenSecretManager \u003d\n-        new NMContainerTokenSecretManager(conf);\n+        new NMContainerTokenSecretManager(conf, nmStore);\n \n     NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n         new NMTokenSecretManagerInNM(nmStore);\n \n     recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n     \n     this.aclsManager \u003d new ApplicationACLsManager(conf);\n \n     ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n         conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n           DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n     try {\n       exec.init();\n     } catch (IOException e) {\n       throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n     }    \n     DeletionService del \u003d createDeletionService(exec);\n     addService(del);\n \n     // NodeManager level dispatcher\n     this.dispatcher \u003d new AsyncDispatcher();\n \n     nodeHealthChecker \u003d new NodeHealthCheckerService();\n     addService(nodeHealthChecker);\n     dirsHandler \u003d nodeHealthChecker.getDiskHandler();\n \n     this.context \u003d createNMContext(containerTokenSecretManager,\n         nmTokenSecretManager, nmStore);\n     \n     nodeStatusUpdater \u003d\n         createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n \n     NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n     addService(nodeResourceMonitor);\n \n     containerManager \u003d\n         createContainerManager(context, exec, del, nodeStatusUpdater,\n         this.aclsManager, dirsHandler);\n     addService(containerManager);\n     ((NMContext) context).setContainerManager(containerManager);\n \n     WebServer webServer \u003d createWebServer(context, containerManager\n         .getContainersMonitor(), this.aclsManager, dirsHandler);\n     addService(webServer);\n     ((NMContext) context).setWebServer(webServer);\n \n     dispatcher.register(ContainerManagerEventType.class, containerManager);\n     dispatcher.register(NodeManagerEventType.class, this);\n     addService(dispatcher);\n     \n     DefaultMetricsSystem.initialize(\"NodeManager\");\n \n     // StatusUpdater should be added last so that it get started last \n     // so that we make sure everything is up before registering with RM. \n     addService(nodeStatusUpdater);\n     \n     super.serviceInit(conf);\n     // TODO add local dirs to del\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceInit(Configuration conf) throws Exception {\n\n    conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n\n    rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n            .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n        YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n\n    initAndStartRecoveryStore(conf);\n\n    NMContainerTokenSecretManager containerTokenSecretManager \u003d\n        new NMContainerTokenSecretManager(conf, nmStore);\n\n    NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n        new NMTokenSecretManagerInNM(nmStore);\n\n    recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n    \n    this.aclsManager \u003d new ApplicationACLsManager(conf);\n\n    ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n        conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n          DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n    try {\n      exec.init();\n    } catch (IOException e) {\n      throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n    }    \n    DeletionService del \u003d createDeletionService(exec);\n    addService(del);\n\n    // NodeManager level dispatcher\n    this.dispatcher \u003d new AsyncDispatcher();\n\n    nodeHealthChecker \u003d new NodeHealthCheckerService();\n    addService(nodeHealthChecker);\n    dirsHandler \u003d nodeHealthChecker.getDiskHandler();\n\n    this.context \u003d createNMContext(containerTokenSecretManager,\n        nmTokenSecretManager, nmStore);\n    \n    nodeStatusUpdater \u003d\n        createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n\n    NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n    addService(nodeResourceMonitor);\n\n    containerManager \u003d\n        createContainerManager(context, exec, del, nodeStatusUpdater,\n        this.aclsManager, dirsHandler);\n    addService(containerManager);\n    ((NMContext) context).setContainerManager(containerManager);\n\n    WebServer webServer \u003d createWebServer(context, containerManager\n        .getContainersMonitor(), this.aclsManager, dirsHandler);\n    addService(webServer);\n    ((NMContext) context).setWebServer(webServer);\n\n    dispatcher.register(ContainerManagerEventType.class, containerManager);\n    dispatcher.register(NodeManagerEventType.class, this);\n    addService(dispatcher);\n    \n    DefaultMetricsSystem.initialize(\"NodeManager\");\n\n    // StatusUpdater should be added last so that it get started last \n    // so that we make sure everything is up before registering with RM. \n    addService(nodeStatusUpdater);\n    \n    super.serviceInit(conf);\n    // TODO add local dirs to del\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java",
      "extendedDetails": {}
    },
    "403ec8ea80d59f209823a7370dc8185fa2c1c368": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1341. Recover NMTokens upon nodemanager restart. (Contributed by Jason Lowe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1611512 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/07/14 4:33 PM",
      "commitName": "403ec8ea80d59f209823a7370dc8185fa2c1c368",
      "commitAuthor": "Junping Du",
      "commitDateOld": "06/07/14 9:37 PM",
      "commitNameOld": "6d7dbd4fedd91a5177a2f0d90c5822394ab18529",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 10.79,
      "commitsBetweenForRepo": 84,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,69 +1,71 @@\n   protected void serviceInit(Configuration conf) throws Exception {\n \n     conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n \n     rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n             .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n         YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n \n     initAndStartRecoveryStore(conf);\n \n     NMContainerTokenSecretManager containerTokenSecretManager \u003d\n         new NMContainerTokenSecretManager(conf);\n \n     NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n-        new NMTokenSecretManagerInNM();\n+        new NMTokenSecretManagerInNM(nmStore);\n+\n+    recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n     \n     this.aclsManager \u003d new ApplicationACLsManager(conf);\n \n     ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n         conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n           DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n     try {\n       exec.init();\n     } catch (IOException e) {\n       throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n     }    \n     DeletionService del \u003d createDeletionService(exec);\n     addService(del);\n \n     // NodeManager level dispatcher\n     this.dispatcher \u003d new AsyncDispatcher();\n \n     nodeHealthChecker \u003d new NodeHealthCheckerService();\n     addService(nodeHealthChecker);\n     dirsHandler \u003d nodeHealthChecker.getDiskHandler();\n \n     this.context \u003d createNMContext(containerTokenSecretManager,\n         nmTokenSecretManager, nmStore);\n     \n     nodeStatusUpdater \u003d\n         createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n \n     NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n     addService(nodeResourceMonitor);\n \n     containerManager \u003d\n         createContainerManager(context, exec, del, nodeStatusUpdater,\n         this.aclsManager, dirsHandler);\n     addService(containerManager);\n     ((NMContext) context).setContainerManager(containerManager);\n \n     WebServer webServer \u003d createWebServer(context, containerManager\n         .getContainersMonitor(), this.aclsManager, dirsHandler);\n     addService(webServer);\n     ((NMContext) context).setWebServer(webServer);\n \n     dispatcher.register(ContainerManagerEventType.class, containerManager);\n     dispatcher.register(NodeManagerEventType.class, this);\n     addService(dispatcher);\n     \n     DefaultMetricsSystem.initialize(\"NodeManager\");\n \n     // StatusUpdater should be added last so that it get started last \n     // so that we make sure everything is up before registering with RM. \n     addService(nodeStatusUpdater);\n     \n     super.serviceInit(conf);\n     // TODO add local dirs to del\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceInit(Configuration conf) throws Exception {\n\n    conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n\n    rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n            .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n        YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n\n    initAndStartRecoveryStore(conf);\n\n    NMContainerTokenSecretManager containerTokenSecretManager \u003d\n        new NMContainerTokenSecretManager(conf);\n\n    NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n        new NMTokenSecretManagerInNM(nmStore);\n\n    recoverTokens(nmTokenSecretManager, containerTokenSecretManager);\n    \n    this.aclsManager \u003d new ApplicationACLsManager(conf);\n\n    ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n        conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n          DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n    try {\n      exec.init();\n    } catch (IOException e) {\n      throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n    }    \n    DeletionService del \u003d createDeletionService(exec);\n    addService(del);\n\n    // NodeManager level dispatcher\n    this.dispatcher \u003d new AsyncDispatcher();\n\n    nodeHealthChecker \u003d new NodeHealthCheckerService();\n    addService(nodeHealthChecker);\n    dirsHandler \u003d nodeHealthChecker.getDiskHandler();\n\n    this.context \u003d createNMContext(containerTokenSecretManager,\n        nmTokenSecretManager, nmStore);\n    \n    nodeStatusUpdater \u003d\n        createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n\n    NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n    addService(nodeResourceMonitor);\n\n    containerManager \u003d\n        createContainerManager(context, exec, del, nodeStatusUpdater,\n        this.aclsManager, dirsHandler);\n    addService(containerManager);\n    ((NMContext) context).setContainerManager(containerManager);\n\n    WebServer webServer \u003d createWebServer(context, containerManager\n        .getContainersMonitor(), this.aclsManager, dirsHandler);\n    addService(webServer);\n    ((NMContext) context).setWebServer(webServer);\n\n    dispatcher.register(ContainerManagerEventType.class, containerManager);\n    dispatcher.register(NodeManagerEventType.class, this);\n    addService(dispatcher);\n    \n    DefaultMetricsSystem.initialize(\"NodeManager\");\n\n    // StatusUpdater should be added last so that it get started last \n    // so that we make sure everything is up before registering with RM. \n    addService(nodeStatusUpdater);\n    \n    super.serviceInit(conf);\n    // TODO add local dirs to del\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java",
      "extendedDetails": {}
    },
    "6d7dbd4fedd91a5177a2f0d90c5822394ab18529": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1367. Changed NM to not kill containers on NM resync if RM work-preserving restart is enabled. Contributed by Anubhav Dhoot\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1608334 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "06/07/14 9:37 PM",
      "commitName": "6d7dbd4fedd91a5177a2f0d90c5822394ab18529",
      "commitAuthor": "Jian He",
      "commitDateOld": "16/06/14 6:02 PM",
      "commitNameOld": "072360d1286cf1de3f83664755144b4d468dae6e",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 20.15,
      "commitsBetweenForRepo": 132,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,65 +1,69 @@\n   protected void serviceInit(Configuration conf) throws Exception {\n \n     conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n \n+    rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n+            .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n+        YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n+\n     initAndStartRecoveryStore(conf);\n \n     NMContainerTokenSecretManager containerTokenSecretManager \u003d\n         new NMContainerTokenSecretManager(conf);\n \n     NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n         new NMTokenSecretManagerInNM();\n     \n     this.aclsManager \u003d new ApplicationACLsManager(conf);\n \n     ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n         conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n           DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n     try {\n       exec.init();\n     } catch (IOException e) {\n       throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n     }    \n     DeletionService del \u003d createDeletionService(exec);\n     addService(del);\n \n     // NodeManager level dispatcher\n     this.dispatcher \u003d new AsyncDispatcher();\n \n     nodeHealthChecker \u003d new NodeHealthCheckerService();\n     addService(nodeHealthChecker);\n     dirsHandler \u003d nodeHealthChecker.getDiskHandler();\n \n     this.context \u003d createNMContext(containerTokenSecretManager,\n         nmTokenSecretManager, nmStore);\n     \n     nodeStatusUpdater \u003d\n         createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n \n     NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n     addService(nodeResourceMonitor);\n \n     containerManager \u003d\n         createContainerManager(context, exec, del, nodeStatusUpdater,\n         this.aclsManager, dirsHandler);\n     addService(containerManager);\n     ((NMContext) context).setContainerManager(containerManager);\n \n     WebServer webServer \u003d createWebServer(context, containerManager\n         .getContainersMonitor(), this.aclsManager, dirsHandler);\n     addService(webServer);\n     ((NMContext) context).setWebServer(webServer);\n \n     dispatcher.register(ContainerManagerEventType.class, containerManager);\n     dispatcher.register(NodeManagerEventType.class, this);\n     addService(dispatcher);\n     \n     DefaultMetricsSystem.initialize(\"NodeManager\");\n \n     // StatusUpdater should be added last so that it get started last \n     // so that we make sure everything is up before registering with RM. \n     addService(nodeStatusUpdater);\n     \n     super.serviceInit(conf);\n     // TODO add local dirs to del\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceInit(Configuration conf) throws Exception {\n\n    conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n\n    rmWorkPreservingRestartEnabled \u003d conf.getBoolean(YarnConfiguration\n            .RM_WORK_PRESERVING_RECOVERY_ENABLED,\n        YarnConfiguration.DEFAULT_RM_WORK_PRESERVING_RECOVERY_ENABLED);\n\n    initAndStartRecoveryStore(conf);\n\n    NMContainerTokenSecretManager containerTokenSecretManager \u003d\n        new NMContainerTokenSecretManager(conf);\n\n    NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n        new NMTokenSecretManagerInNM();\n    \n    this.aclsManager \u003d new ApplicationACLsManager(conf);\n\n    ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n        conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n          DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n    try {\n      exec.init();\n    } catch (IOException e) {\n      throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n    }    \n    DeletionService del \u003d createDeletionService(exec);\n    addService(del);\n\n    // NodeManager level dispatcher\n    this.dispatcher \u003d new AsyncDispatcher();\n\n    nodeHealthChecker \u003d new NodeHealthCheckerService();\n    addService(nodeHealthChecker);\n    dirsHandler \u003d nodeHealthChecker.getDiskHandler();\n\n    this.context \u003d createNMContext(containerTokenSecretManager,\n        nmTokenSecretManager, nmStore);\n    \n    nodeStatusUpdater \u003d\n        createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n\n    NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n    addService(nodeResourceMonitor);\n\n    containerManager \u003d\n        createContainerManager(context, exec, del, nodeStatusUpdater,\n        this.aclsManager, dirsHandler);\n    addService(containerManager);\n    ((NMContext) context).setContainerManager(containerManager);\n\n    WebServer webServer \u003d createWebServer(context, containerManager\n        .getContainersMonitor(), this.aclsManager, dirsHandler);\n    addService(webServer);\n    ((NMContext) context).setWebServer(webServer);\n\n    dispatcher.register(ContainerManagerEventType.class, containerManager);\n    dispatcher.register(NodeManagerEventType.class, this);\n    addService(dispatcher);\n    \n    DefaultMetricsSystem.initialize(\"NodeManager\");\n\n    // StatusUpdater should be added last so that it get started last \n    // so that we make sure everything is up before registering with RM. \n    addService(nodeStatusUpdater);\n    \n    super.serviceInit(conf);\n    // TODO add local dirs to del\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java",
      "extendedDetails": {}
    },
    "66598697a6e777615334ebde5ba7738135da83ae": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1338. Recover localized resource cache state upon nodemanager restart (Contributed by Jason Lowe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1598640 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/05/14 8:37 AM",
      "commitName": "66598697a6e777615334ebde5ba7738135da83ae",
      "commitAuthor": "Junping Du",
      "commitDateOld": "13/05/14 5:20 PM",
      "commitNameOld": "b29434a5c8df8757e6bcdcf643df2f5756a221d9",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 16.64,
      "commitsBetweenForRepo": 92,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,77 +1,65 @@\n   protected void serviceInit(Configuration conf) throws Exception {\n \n     conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n \n-    boolean recoveryEnabled \u003d conf.getBoolean(\n-        YarnConfiguration.NM_RECOVERY_ENABLED,\n-        YarnConfiguration.DEFAULT_NM_RECOVERY_ENABLED);\n-    if (recoveryEnabled) {\n-      FileSystem recoveryFs \u003d FileSystem.getLocal(conf);\n-      String recoveryDirName \u003d conf.get(YarnConfiguration.NM_RECOVERY_DIR);\n-      if (recoveryDirName \u003d\u003d null) {\n-        throw new IllegalArgumentException(\"Recovery is enabled but \" +\n-            YarnConfiguration.NM_RECOVERY_DIR + \" is not set.\");\n-      }\n-      Path recoveryRoot \u003d new Path(recoveryDirName);\n-      recoveryFs.mkdirs(recoveryRoot, new FsPermission((short)0700));\n-    }\n+    initAndStartRecoveryStore(conf);\n \n     NMContainerTokenSecretManager containerTokenSecretManager \u003d\n         new NMContainerTokenSecretManager(conf);\n \n     NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n         new NMTokenSecretManagerInNM();\n     \n     this.aclsManager \u003d new ApplicationACLsManager(conf);\n \n     ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n         conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n           DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n     try {\n       exec.init();\n     } catch (IOException e) {\n       throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n     }    \n     DeletionService del \u003d createDeletionService(exec);\n     addService(del);\n \n     // NodeManager level dispatcher\n     this.dispatcher \u003d new AsyncDispatcher();\n \n     nodeHealthChecker \u003d new NodeHealthCheckerService();\n     addService(nodeHealthChecker);\n     dirsHandler \u003d nodeHealthChecker.getDiskHandler();\n \n     this.context \u003d createNMContext(containerTokenSecretManager,\n-        nmTokenSecretManager);\n+        nmTokenSecretManager, nmStore);\n     \n     nodeStatusUpdater \u003d\n         createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n \n     NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n     addService(nodeResourceMonitor);\n \n     containerManager \u003d\n         createContainerManager(context, exec, del, nodeStatusUpdater,\n         this.aclsManager, dirsHandler);\n     addService(containerManager);\n     ((NMContext) context).setContainerManager(containerManager);\n \n     WebServer webServer \u003d createWebServer(context, containerManager\n         .getContainersMonitor(), this.aclsManager, dirsHandler);\n     addService(webServer);\n     ((NMContext) context).setWebServer(webServer);\n \n     dispatcher.register(ContainerManagerEventType.class, containerManager);\n     dispatcher.register(NodeManagerEventType.class, this);\n     addService(dispatcher);\n     \n     DefaultMetricsSystem.initialize(\"NodeManager\");\n \n     // StatusUpdater should be added last so that it get started last \n     // so that we make sure everything is up before registering with RM. \n     addService(nodeStatusUpdater);\n     \n     super.serviceInit(conf);\n     // TODO add local dirs to del\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceInit(Configuration conf) throws Exception {\n\n    conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n\n    initAndStartRecoveryStore(conf);\n\n    NMContainerTokenSecretManager containerTokenSecretManager \u003d\n        new NMContainerTokenSecretManager(conf);\n\n    NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n        new NMTokenSecretManagerInNM();\n    \n    this.aclsManager \u003d new ApplicationACLsManager(conf);\n\n    ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n        conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n          DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n    try {\n      exec.init();\n    } catch (IOException e) {\n      throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n    }    \n    DeletionService del \u003d createDeletionService(exec);\n    addService(del);\n\n    // NodeManager level dispatcher\n    this.dispatcher \u003d new AsyncDispatcher();\n\n    nodeHealthChecker \u003d new NodeHealthCheckerService();\n    addService(nodeHealthChecker);\n    dirsHandler \u003d nodeHealthChecker.getDiskHandler();\n\n    this.context \u003d createNMContext(containerTokenSecretManager,\n        nmTokenSecretManager, nmStore);\n    \n    nodeStatusUpdater \u003d\n        createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n\n    NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n    addService(nodeResourceMonitor);\n\n    containerManager \u003d\n        createContainerManager(context, exec, del, nodeStatusUpdater,\n        this.aclsManager, dirsHandler);\n    addService(containerManager);\n    ((NMContext) context).setContainerManager(containerManager);\n\n    WebServer webServer \u003d createWebServer(context, containerManager\n        .getContainersMonitor(), this.aclsManager, dirsHandler);\n    addService(webServer);\n    ((NMContext) context).setWebServer(webServer);\n\n    dispatcher.register(ContainerManagerEventType.class, containerManager);\n    dispatcher.register(NodeManagerEventType.class, this);\n    addService(dispatcher);\n    \n    DefaultMetricsSystem.initialize(\"NodeManager\");\n\n    // StatusUpdater should be added last so that it get started last \n    // so that we make sure everything is up before registering with RM. \n    addService(nodeStatusUpdater);\n    \n    super.serviceInit(conf);\n    // TODO add local dirs to del\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java",
      "extendedDetails": {}
    },
    "245012a9d9b0a21b8e93837e3e1a1892adcbf73c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1757. NM Recovery. Auxiliary service support. (Jason Lowe via kasha)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1585783 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/04/14 10:15 AM",
      "commitName": "245012a9d9b0a21b8e93837e3e1a1892adcbf73c",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "07/03/14 2:36 PM",
      "commitNameOld": "1c4047b0e46e95a92509de2e59a93433f5968538",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 31.78,
      "commitsBetweenForRepo": 220,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,63 +1,77 @@\n   protected void serviceInit(Configuration conf) throws Exception {\n \n     conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n \n+    boolean recoveryEnabled \u003d conf.getBoolean(\n+        YarnConfiguration.NM_RECOVERY_ENABLED,\n+        YarnConfiguration.DEFAULT_NM_RECOVERY_ENABLED);\n+    if (recoveryEnabled) {\n+      FileSystem recoveryFs \u003d FileSystem.getLocal(conf);\n+      String recoveryDirName \u003d conf.get(YarnConfiguration.NM_RECOVERY_DIR);\n+      if (recoveryDirName \u003d\u003d null) {\n+        throw new IllegalArgumentException(\"Recovery is enabled but \" +\n+            YarnConfiguration.NM_RECOVERY_DIR + \" is not set.\");\n+      }\n+      Path recoveryRoot \u003d new Path(recoveryDirName);\n+      recoveryFs.mkdirs(recoveryRoot, new FsPermission((short)0700));\n+    }\n+\n     NMContainerTokenSecretManager containerTokenSecretManager \u003d\n         new NMContainerTokenSecretManager(conf);\n \n     NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n         new NMTokenSecretManagerInNM();\n     \n     this.aclsManager \u003d new ApplicationACLsManager(conf);\n \n     ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n         conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n           DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n     try {\n       exec.init();\n     } catch (IOException e) {\n       throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n     }    \n     DeletionService del \u003d createDeletionService(exec);\n     addService(del);\n \n     // NodeManager level dispatcher\n     this.dispatcher \u003d new AsyncDispatcher();\n \n     nodeHealthChecker \u003d new NodeHealthCheckerService();\n     addService(nodeHealthChecker);\n     dirsHandler \u003d nodeHealthChecker.getDiskHandler();\n \n     this.context \u003d createNMContext(containerTokenSecretManager,\n         nmTokenSecretManager);\n     \n     nodeStatusUpdater \u003d\n         createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n \n     NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n     addService(nodeResourceMonitor);\n \n     containerManager \u003d\n         createContainerManager(context, exec, del, nodeStatusUpdater,\n         this.aclsManager, dirsHandler);\n     addService(containerManager);\n     ((NMContext) context).setContainerManager(containerManager);\n \n     WebServer webServer \u003d createWebServer(context, containerManager\n         .getContainersMonitor(), this.aclsManager, dirsHandler);\n     addService(webServer);\n     ((NMContext) context).setWebServer(webServer);\n \n     dispatcher.register(ContainerManagerEventType.class, containerManager);\n     dispatcher.register(NodeManagerEventType.class, this);\n     addService(dispatcher);\n     \n     DefaultMetricsSystem.initialize(\"NodeManager\");\n \n     // StatusUpdater should be added last so that it get started last \n     // so that we make sure everything is up before registering with RM. \n     addService(nodeStatusUpdater);\n     \n     super.serviceInit(conf);\n     // TODO add local dirs to del\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceInit(Configuration conf) throws Exception {\n\n    conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n\n    boolean recoveryEnabled \u003d conf.getBoolean(\n        YarnConfiguration.NM_RECOVERY_ENABLED,\n        YarnConfiguration.DEFAULT_NM_RECOVERY_ENABLED);\n    if (recoveryEnabled) {\n      FileSystem recoveryFs \u003d FileSystem.getLocal(conf);\n      String recoveryDirName \u003d conf.get(YarnConfiguration.NM_RECOVERY_DIR);\n      if (recoveryDirName \u003d\u003d null) {\n        throw new IllegalArgumentException(\"Recovery is enabled but \" +\n            YarnConfiguration.NM_RECOVERY_DIR + \" is not set.\");\n      }\n      Path recoveryRoot \u003d new Path(recoveryDirName);\n      recoveryFs.mkdirs(recoveryRoot, new FsPermission((short)0700));\n    }\n\n    NMContainerTokenSecretManager containerTokenSecretManager \u003d\n        new NMContainerTokenSecretManager(conf);\n\n    NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n        new NMTokenSecretManagerInNM();\n    \n    this.aclsManager \u003d new ApplicationACLsManager(conf);\n\n    ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n        conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n          DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n    try {\n      exec.init();\n    } catch (IOException e) {\n      throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n    }    \n    DeletionService del \u003d createDeletionService(exec);\n    addService(del);\n\n    // NodeManager level dispatcher\n    this.dispatcher \u003d new AsyncDispatcher();\n\n    nodeHealthChecker \u003d new NodeHealthCheckerService();\n    addService(nodeHealthChecker);\n    dirsHandler \u003d nodeHealthChecker.getDiskHandler();\n\n    this.context \u003d createNMContext(containerTokenSecretManager,\n        nmTokenSecretManager);\n    \n    nodeStatusUpdater \u003d\n        createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n\n    NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n    addService(nodeResourceMonitor);\n\n    containerManager \u003d\n        createContainerManager(context, exec, del, nodeStatusUpdater,\n        this.aclsManager, dirsHandler);\n    addService(containerManager);\n    ((NMContext) context).setContainerManager(containerManager);\n\n    WebServer webServer \u003d createWebServer(context, containerManager\n        .getContainersMonitor(), this.aclsManager, dirsHandler);\n    addService(webServer);\n    ((NMContext) context).setWebServer(webServer);\n\n    dispatcher.register(ContainerManagerEventType.class, containerManager);\n    dispatcher.register(NodeManagerEventType.class, this);\n    addService(dispatcher);\n    \n    DefaultMetricsSystem.initialize(\"NodeManager\");\n\n    // StatusUpdater should be added last so that it get started last \n    // so that we make sure everything is up before registering with RM. \n    addService(nodeStatusUpdater);\n    \n    super.serviceInit(conf);\n    // TODO add local dirs to del\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java",
      "extendedDetails": {}
    },
    "d3841bd4997a77855ab2abd9cc294eae7d795a5b": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1149. NM throws InvalidStateTransitonException: Invalid event: APPLICATION_LOG_HANDLING_FINISHED at RUNNING. Contributed by Xuan Gong.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1529043 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/10/13 5:43 PM",
      "commitName": "d3841bd4997a77855ab2abd9cc294eae7d795a5b",
      "commitAuthor": "Hitesh Shah",
      "commitDateOld": "01/09/13 5:09 PM",
      "commitNameOld": "a759abcd898224c3481c55aa7e424bc286f60b15",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 32.02,
      "commitsBetweenForRepo": 186,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,70 +1,63 @@\n   protected void serviceInit(Configuration conf) throws Exception {\n \n     conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n \n     NMContainerTokenSecretManager containerTokenSecretManager \u003d\n         new NMContainerTokenSecretManager(conf);\n \n     NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n         new NMTokenSecretManagerInNM();\n     \n     this.aclsManager \u003d new ApplicationACLsManager(conf);\n \n     ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n         conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n           DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n     try {\n       exec.init();\n     } catch (IOException e) {\n       throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n     }    \n     DeletionService del \u003d createDeletionService(exec);\n     addService(del);\n \n     // NodeManager level dispatcher\n     this.dispatcher \u003d new AsyncDispatcher();\n \n     nodeHealthChecker \u003d new NodeHealthCheckerService();\n     addService(nodeHealthChecker);\n     dirsHandler \u003d nodeHealthChecker.getDiskHandler();\n \n     this.context \u003d createNMContext(containerTokenSecretManager,\n         nmTokenSecretManager);\n     \n     nodeStatusUpdater \u003d\n         createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n \n     NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n     addService(nodeResourceMonitor);\n \n     containerManager \u003d\n         createContainerManager(context, exec, del, nodeStatusUpdater,\n         this.aclsManager, dirsHandler);\n     addService(containerManager);\n     ((NMContext) context).setContainerManager(containerManager);\n \n     WebServer webServer \u003d createWebServer(context, containerManager\n         .getContainersMonitor(), this.aclsManager, dirsHandler);\n     addService(webServer);\n     ((NMContext) context).setWebServer(webServer);\n \n     dispatcher.register(ContainerManagerEventType.class, containerManager);\n     dispatcher.register(NodeManagerEventType.class, this);\n     addService(dispatcher);\n     \n     DefaultMetricsSystem.initialize(\"NodeManager\");\n \n     // StatusUpdater should be added last so that it get started last \n     // so that we make sure everything is up before registering with RM. \n     addService(nodeStatusUpdater);\n     \n-    waitForContainersOnShutdownMillis \u003d\n-        conf.getLong(YarnConfiguration.NM_SLEEP_DELAY_BEFORE_SIGKILL_MS,\n-            YarnConfiguration.DEFAULT_NM_SLEEP_DELAY_BEFORE_SIGKILL_MS) + \n-        conf.getLong(YarnConfiguration.NM_PROCESS_KILL_WAIT_MS,\n-            YarnConfiguration.DEFAULT_NM_PROCESS_KILL_WAIT_MS) +\n-        SHUTDOWN_CLEANUP_SLOP_MS;\n-    \n     super.serviceInit(conf);\n     // TODO add local dirs to del\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceInit(Configuration conf) throws Exception {\n\n    conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n\n    NMContainerTokenSecretManager containerTokenSecretManager \u003d\n        new NMContainerTokenSecretManager(conf);\n\n    NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n        new NMTokenSecretManagerInNM();\n    \n    this.aclsManager \u003d new ApplicationACLsManager(conf);\n\n    ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n        conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n          DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n    try {\n      exec.init();\n    } catch (IOException e) {\n      throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n    }    \n    DeletionService del \u003d createDeletionService(exec);\n    addService(del);\n\n    // NodeManager level dispatcher\n    this.dispatcher \u003d new AsyncDispatcher();\n\n    nodeHealthChecker \u003d new NodeHealthCheckerService();\n    addService(nodeHealthChecker);\n    dirsHandler \u003d nodeHealthChecker.getDiskHandler();\n\n    this.context \u003d createNMContext(containerTokenSecretManager,\n        nmTokenSecretManager);\n    \n    nodeStatusUpdater \u003d\n        createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n\n    NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n    addService(nodeResourceMonitor);\n\n    containerManager \u003d\n        createContainerManager(context, exec, del, nodeStatusUpdater,\n        this.aclsManager, dirsHandler);\n    addService(containerManager);\n    ((NMContext) context).setContainerManager(containerManager);\n\n    WebServer webServer \u003d createWebServer(context, containerManager\n        .getContainersMonitor(), this.aclsManager, dirsHandler);\n    addService(webServer);\n    ((NMContext) context).setWebServer(webServer);\n\n    dispatcher.register(ContainerManagerEventType.class, containerManager);\n    dispatcher.register(NodeManagerEventType.class, this);\n    addService(dispatcher);\n    \n    DefaultMetricsSystem.initialize(\"NodeManager\");\n\n    // StatusUpdater should be added last so that it get started last \n    // so that we make sure everything is up before registering with RM. \n    addService(nodeStatusUpdater);\n    \n    super.serviceInit(conf);\n    // TODO add local dirs to del\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java",
      "extendedDetails": {}
    },
    "a759abcd898224c3481c55aa7e424bc286f60b15": {
      "type": "Ybodychange",
      "commitMessage": "YARN-649. Added a new NM web-service to serve container logs in plain text over HTTP. Contributed by Sandy Ryza.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1519326 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "01/09/13 5:09 PM",
      "commitName": "a759abcd898224c3481c55aa7e424bc286f60b15",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "01/08/13 11:54 PM",
      "commitNameOld": "5b7889f9a7dea81bbb3c8be6944419b59ca4bed1",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 30.72,
      "commitsBetweenForRepo": 175,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,71 +1,70 @@\n   protected void serviceInit(Configuration conf) throws Exception {\n \n     conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n \n     NMContainerTokenSecretManager containerTokenSecretManager \u003d\n         new NMContainerTokenSecretManager(conf);\n \n     NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n         new NMTokenSecretManagerInNM();\n     \n-    this.context \u003d\n-        createNMContext(containerTokenSecretManager, nmTokenSecretManager);\n-\n     this.aclsManager \u003d new ApplicationACLsManager(conf);\n \n     ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n         conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n           DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n     try {\n       exec.init();\n     } catch (IOException e) {\n       throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n     }    \n     DeletionService del \u003d createDeletionService(exec);\n     addService(del);\n \n     // NodeManager level dispatcher\n     this.dispatcher \u003d new AsyncDispatcher();\n \n     nodeHealthChecker \u003d new NodeHealthCheckerService();\n     addService(nodeHealthChecker);\n     dirsHandler \u003d nodeHealthChecker.getDiskHandler();\n \n-\n+    this.context \u003d createNMContext(containerTokenSecretManager,\n+        nmTokenSecretManager);\n+    \n     nodeStatusUpdater \u003d\n         createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n \n     NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n     addService(nodeResourceMonitor);\n \n     containerManager \u003d\n         createContainerManager(context, exec, del, nodeStatusUpdater,\n         this.aclsManager, dirsHandler);\n     addService(containerManager);\n     ((NMContext) context).setContainerManager(containerManager);\n \n     WebServer webServer \u003d createWebServer(context, containerManager\n         .getContainersMonitor(), this.aclsManager, dirsHandler);\n     addService(webServer);\n     ((NMContext) context).setWebServer(webServer);\n \n     dispatcher.register(ContainerManagerEventType.class, containerManager);\n     dispatcher.register(NodeManagerEventType.class, this);\n     addService(dispatcher);\n     \n     DefaultMetricsSystem.initialize(\"NodeManager\");\n \n     // StatusUpdater should be added last so that it get started last \n     // so that we make sure everything is up before registering with RM. \n     addService(nodeStatusUpdater);\n     \n     waitForContainersOnShutdownMillis \u003d\n         conf.getLong(YarnConfiguration.NM_SLEEP_DELAY_BEFORE_SIGKILL_MS,\n             YarnConfiguration.DEFAULT_NM_SLEEP_DELAY_BEFORE_SIGKILL_MS) + \n         conf.getLong(YarnConfiguration.NM_PROCESS_KILL_WAIT_MS,\n             YarnConfiguration.DEFAULT_NM_PROCESS_KILL_WAIT_MS) +\n         SHUTDOWN_CLEANUP_SLOP_MS;\n     \n     super.serviceInit(conf);\n     // TODO add local dirs to del\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceInit(Configuration conf) throws Exception {\n\n    conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n\n    NMContainerTokenSecretManager containerTokenSecretManager \u003d\n        new NMContainerTokenSecretManager(conf);\n\n    NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n        new NMTokenSecretManagerInNM();\n    \n    this.aclsManager \u003d new ApplicationACLsManager(conf);\n\n    ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n        conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n          DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n    try {\n      exec.init();\n    } catch (IOException e) {\n      throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n    }    \n    DeletionService del \u003d createDeletionService(exec);\n    addService(del);\n\n    // NodeManager level dispatcher\n    this.dispatcher \u003d new AsyncDispatcher();\n\n    nodeHealthChecker \u003d new NodeHealthCheckerService();\n    addService(nodeHealthChecker);\n    dirsHandler \u003d nodeHealthChecker.getDiskHandler();\n\n    this.context \u003d createNMContext(containerTokenSecretManager,\n        nmTokenSecretManager);\n    \n    nodeStatusUpdater \u003d\n        createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n\n    NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n    addService(nodeResourceMonitor);\n\n    containerManager \u003d\n        createContainerManager(context, exec, del, nodeStatusUpdater,\n        this.aclsManager, dirsHandler);\n    addService(containerManager);\n    ((NMContext) context).setContainerManager(containerManager);\n\n    WebServer webServer \u003d createWebServer(context, containerManager\n        .getContainersMonitor(), this.aclsManager, dirsHandler);\n    addService(webServer);\n    ((NMContext) context).setWebServer(webServer);\n\n    dispatcher.register(ContainerManagerEventType.class, containerManager);\n    dispatcher.register(NodeManagerEventType.class, this);\n    addService(dispatcher);\n    \n    DefaultMetricsSystem.initialize(\"NodeManager\");\n\n    // StatusUpdater should be added last so that it get started last \n    // so that we make sure everything is up before registering with RM. \n    addService(nodeStatusUpdater);\n    \n    waitForContainersOnShutdownMillis \u003d\n        conf.getLong(YarnConfiguration.NM_SLEEP_DELAY_BEFORE_SIGKILL_MS,\n            YarnConfiguration.DEFAULT_NM_SLEEP_DELAY_BEFORE_SIGKILL_MS) + \n        conf.getLong(YarnConfiguration.NM_PROCESS_KILL_WAIT_MS,\n            YarnConfiguration.DEFAULT_NM_PROCESS_KILL_WAIT_MS) +\n        SHUTDOWN_CLEANUP_SLOP_MS;\n    \n    super.serviceInit(conf);\n    // TODO add local dirs to del\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java",
      "extendedDetails": {}
    },
    "3ca892dc0a24f95e9bbd00d3235ca6eb6b7fc329": {
      "type": "Ybodychange",
      "commitMessage": "Reverting YARN-245 to fix a critical bug.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1508277 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/07/13 8:06 PM",
      "commitName": "3ca892dc0a24f95e9bbd00d3235ca6eb6b7fc329",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "29/07/13 11:15 AM",
      "commitNameOld": "412e19f8e3118e602c567d60461e17c0dfe98b88",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 0.37,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,71 +1,71 @@\n   protected void serviceInit(Configuration conf) throws Exception {\n \n     conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n \n     NMContainerTokenSecretManager containerTokenSecretManager \u003d\n         new NMContainerTokenSecretManager(conf);\n \n     NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n         new NMTokenSecretManagerInNM();\n     \n     this.context \u003d\n         createNMContext(containerTokenSecretManager, nmTokenSecretManager);\n \n     this.aclsManager \u003d new ApplicationACLsManager(conf);\n \n     ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n         conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n           DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n     try {\n       exec.init();\n     } catch (IOException e) {\n       throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n     }    \n     DeletionService del \u003d createDeletionService(exec);\n     addService(del);\n \n     // NodeManager level dispatcher\n-    this.dispatcher \u003d (AsyncDispatcher) createDispatcher();\n+    this.dispatcher \u003d new AsyncDispatcher();\n \n     nodeHealthChecker \u003d new NodeHealthCheckerService();\n     addService(nodeHealthChecker);\n     dirsHandler \u003d nodeHealthChecker.getDiskHandler();\n \n \n     nodeStatusUpdater \u003d\n         createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n \n     NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n     addService(nodeResourceMonitor);\n \n     containerManager \u003d\n         createContainerManager(context, exec, del, nodeStatusUpdater,\n         this.aclsManager, dirsHandler);\n     addService(containerManager);\n     ((NMContext) context).setContainerManager(containerManager);\n \n     WebServer webServer \u003d createWebServer(context, containerManager\n         .getContainersMonitor(), this.aclsManager, dirsHandler);\n     addService(webServer);\n     ((NMContext) context).setWebServer(webServer);\n \n     dispatcher.register(ContainerManagerEventType.class, containerManager);\n     dispatcher.register(NodeManagerEventType.class, this);\n     addService(dispatcher);\n     \n     DefaultMetricsSystem.initialize(\"NodeManager\");\n \n     // StatusUpdater should be added last so that it get started last \n     // so that we make sure everything is up before registering with RM. \n     addService(nodeStatusUpdater);\n     \n     waitForContainersOnShutdownMillis \u003d\n         conf.getLong(YarnConfiguration.NM_SLEEP_DELAY_BEFORE_SIGKILL_MS,\n             YarnConfiguration.DEFAULT_NM_SLEEP_DELAY_BEFORE_SIGKILL_MS) + \n         conf.getLong(YarnConfiguration.NM_PROCESS_KILL_WAIT_MS,\n             YarnConfiguration.DEFAULT_NM_PROCESS_KILL_WAIT_MS) +\n         SHUTDOWN_CLEANUP_SLOP_MS;\n     \n     super.serviceInit(conf);\n     // TODO add local dirs to del\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceInit(Configuration conf) throws Exception {\n\n    conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n\n    NMContainerTokenSecretManager containerTokenSecretManager \u003d\n        new NMContainerTokenSecretManager(conf);\n\n    NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n        new NMTokenSecretManagerInNM();\n    \n    this.context \u003d\n        createNMContext(containerTokenSecretManager, nmTokenSecretManager);\n\n    this.aclsManager \u003d new ApplicationACLsManager(conf);\n\n    ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n        conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n          DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n    try {\n      exec.init();\n    } catch (IOException e) {\n      throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n    }    \n    DeletionService del \u003d createDeletionService(exec);\n    addService(del);\n\n    // NodeManager level dispatcher\n    this.dispatcher \u003d new AsyncDispatcher();\n\n    nodeHealthChecker \u003d new NodeHealthCheckerService();\n    addService(nodeHealthChecker);\n    dirsHandler \u003d nodeHealthChecker.getDiskHandler();\n\n\n    nodeStatusUpdater \u003d\n        createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n\n    NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n    addService(nodeResourceMonitor);\n\n    containerManager \u003d\n        createContainerManager(context, exec, del, nodeStatusUpdater,\n        this.aclsManager, dirsHandler);\n    addService(containerManager);\n    ((NMContext) context).setContainerManager(containerManager);\n\n    WebServer webServer \u003d createWebServer(context, containerManager\n        .getContainersMonitor(), this.aclsManager, dirsHandler);\n    addService(webServer);\n    ((NMContext) context).setWebServer(webServer);\n\n    dispatcher.register(ContainerManagerEventType.class, containerManager);\n    dispatcher.register(NodeManagerEventType.class, this);\n    addService(dispatcher);\n    \n    DefaultMetricsSystem.initialize(\"NodeManager\");\n\n    // StatusUpdater should be added last so that it get started last \n    // so that we make sure everything is up before registering with RM. \n    addService(nodeStatusUpdater);\n    \n    waitForContainersOnShutdownMillis \u003d\n        conf.getLong(YarnConfiguration.NM_SLEEP_DELAY_BEFORE_SIGKILL_MS,\n            YarnConfiguration.DEFAULT_NM_SLEEP_DELAY_BEFORE_SIGKILL_MS) + \n        conf.getLong(YarnConfiguration.NM_PROCESS_KILL_WAIT_MS,\n            YarnConfiguration.DEFAULT_NM_PROCESS_KILL_WAIT_MS) +\n        SHUTDOWN_CLEANUP_SLOP_MS;\n    \n    super.serviceInit(conf);\n    // TODO add local dirs to del\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java",
      "extendedDetails": {}
    },
    "412e19f8e3118e602c567d60461e17c0dfe98b88": {
      "type": "Ybodychange",
      "commitMessage": "YARN-245. Fixed NodeManager to handle duplicate responses from ResourceManager. Contributed by Mayank Bansal.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1508157 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/07/13 11:15 AM",
      "commitName": "412e19f8e3118e602c567d60461e17c0dfe98b88",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "24/07/13 9:14 PM",
      "commitNameOld": "db1e0c1eefc1f6ad8fd317088d548c7814ea7aff",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 4.58,
      "commitsBetweenForRepo": 24,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,71 +1,71 @@\n   protected void serviceInit(Configuration conf) throws Exception {\n \n     conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n \n     NMContainerTokenSecretManager containerTokenSecretManager \u003d\n         new NMContainerTokenSecretManager(conf);\n \n     NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n         new NMTokenSecretManagerInNM();\n     \n     this.context \u003d\n         createNMContext(containerTokenSecretManager, nmTokenSecretManager);\n \n     this.aclsManager \u003d new ApplicationACLsManager(conf);\n \n     ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n         conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n           DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n     try {\n       exec.init();\n     } catch (IOException e) {\n       throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n     }    \n     DeletionService del \u003d createDeletionService(exec);\n     addService(del);\n \n     // NodeManager level dispatcher\n-    this.dispatcher \u003d new AsyncDispatcher();\n+    this.dispatcher \u003d (AsyncDispatcher) createDispatcher();\n \n     nodeHealthChecker \u003d new NodeHealthCheckerService();\n     addService(nodeHealthChecker);\n     dirsHandler \u003d nodeHealthChecker.getDiskHandler();\n \n \n     nodeStatusUpdater \u003d\n         createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n \n     NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n     addService(nodeResourceMonitor);\n \n     containerManager \u003d\n         createContainerManager(context, exec, del, nodeStatusUpdater,\n         this.aclsManager, dirsHandler);\n     addService(containerManager);\n     ((NMContext) context).setContainerManager(containerManager);\n \n     WebServer webServer \u003d createWebServer(context, containerManager\n         .getContainersMonitor(), this.aclsManager, dirsHandler);\n     addService(webServer);\n     ((NMContext) context).setWebServer(webServer);\n \n     dispatcher.register(ContainerManagerEventType.class, containerManager);\n     dispatcher.register(NodeManagerEventType.class, this);\n     addService(dispatcher);\n     \n     DefaultMetricsSystem.initialize(\"NodeManager\");\n \n     // StatusUpdater should be added last so that it get started last \n     // so that we make sure everything is up before registering with RM. \n     addService(nodeStatusUpdater);\n     \n     waitForContainersOnShutdownMillis \u003d\n         conf.getLong(YarnConfiguration.NM_SLEEP_DELAY_BEFORE_SIGKILL_MS,\n             YarnConfiguration.DEFAULT_NM_SLEEP_DELAY_BEFORE_SIGKILL_MS) + \n         conf.getLong(YarnConfiguration.NM_PROCESS_KILL_WAIT_MS,\n             YarnConfiguration.DEFAULT_NM_PROCESS_KILL_WAIT_MS) +\n         SHUTDOWN_CLEANUP_SLOP_MS;\n     \n     super.serviceInit(conf);\n     // TODO add local dirs to del\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceInit(Configuration conf) throws Exception {\n\n    conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n\n    NMContainerTokenSecretManager containerTokenSecretManager \u003d\n        new NMContainerTokenSecretManager(conf);\n\n    NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n        new NMTokenSecretManagerInNM();\n    \n    this.context \u003d\n        createNMContext(containerTokenSecretManager, nmTokenSecretManager);\n\n    this.aclsManager \u003d new ApplicationACLsManager(conf);\n\n    ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n        conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n          DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n    try {\n      exec.init();\n    } catch (IOException e) {\n      throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n    }    \n    DeletionService del \u003d createDeletionService(exec);\n    addService(del);\n\n    // NodeManager level dispatcher\n    this.dispatcher \u003d (AsyncDispatcher) createDispatcher();\n\n    nodeHealthChecker \u003d new NodeHealthCheckerService();\n    addService(nodeHealthChecker);\n    dirsHandler \u003d nodeHealthChecker.getDiskHandler();\n\n\n    nodeStatusUpdater \u003d\n        createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n\n    NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n    addService(nodeResourceMonitor);\n\n    containerManager \u003d\n        createContainerManager(context, exec, del, nodeStatusUpdater,\n        this.aclsManager, dirsHandler);\n    addService(containerManager);\n    ((NMContext) context).setContainerManager(containerManager);\n\n    WebServer webServer \u003d createWebServer(context, containerManager\n        .getContainersMonitor(), this.aclsManager, dirsHandler);\n    addService(webServer);\n    ((NMContext) context).setWebServer(webServer);\n\n    dispatcher.register(ContainerManagerEventType.class, containerManager);\n    dispatcher.register(NodeManagerEventType.class, this);\n    addService(dispatcher);\n    \n    DefaultMetricsSystem.initialize(\"NodeManager\");\n\n    // StatusUpdater should be added last so that it get started last \n    // so that we make sure everything is up before registering with RM. \n    addService(nodeStatusUpdater);\n    \n    waitForContainersOnShutdownMillis \u003d\n        conf.getLong(YarnConfiguration.NM_SLEEP_DELAY_BEFORE_SIGKILL_MS,\n            YarnConfiguration.DEFAULT_NM_SLEEP_DELAY_BEFORE_SIGKILL_MS) + \n        conf.getLong(YarnConfiguration.NM_PROCESS_KILL_WAIT_MS,\n            YarnConfiguration.DEFAULT_NM_PROCESS_KILL_WAIT_MS) +\n        SHUTDOWN_CLEANUP_SLOP_MS;\n    \n    super.serviceInit(conf);\n    // TODO add local dirs to del\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java",
      "extendedDetails": {}
    },
    "f0eb4bc342370ec87d1f2665ffaf48ff4b3fbacb": {
      "type": "Ybodychange",
      "commitMessage": "YARN-692. Creating NMToken master key on RM and sharing it with NM as a part of RM-NM heartbeat. Contributed by Omkar Vinit Joshi.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1492907 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "13/06/13 5:06 PM",
      "commitName": "f0eb4bc342370ec87d1f2665ffaf48ff4b3fbacb",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "13/06/13 4:25 PM",
      "commitNameOld": "c0cd68d8fbf5c8cafa6d563c7d0401e7a87a2d9e",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,67 +1,71 @@\n   protected void serviceInit(Configuration conf) throws Exception {\n \n     conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n \n     NMContainerTokenSecretManager containerTokenSecretManager \u003d\n         new NMContainerTokenSecretManager(conf);\n \n-    this.context \u003d createNMContext(containerTokenSecretManager);\n+    NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n+        new NMTokenSecretManagerInNM();\n+    \n+    this.context \u003d\n+        createNMContext(containerTokenSecretManager, nmTokenSecretManager);\n \n     this.aclsManager \u003d new ApplicationACLsManager(conf);\n \n     ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n         conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n           DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n     try {\n       exec.init();\n     } catch (IOException e) {\n       throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n     }    \n     DeletionService del \u003d createDeletionService(exec);\n     addService(del);\n \n     // NodeManager level dispatcher\n     this.dispatcher \u003d new AsyncDispatcher();\n \n     nodeHealthChecker \u003d new NodeHealthCheckerService();\n     addService(nodeHealthChecker);\n     dirsHandler \u003d nodeHealthChecker.getDiskHandler();\n \n \n     nodeStatusUpdater \u003d\n         createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n \n     NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n     addService(nodeResourceMonitor);\n \n     containerManager \u003d\n         createContainerManager(context, exec, del, nodeStatusUpdater,\n         this.aclsManager, dirsHandler);\n     addService(containerManager);\n     ((NMContext) context).setContainerManager(containerManager);\n \n     WebServer webServer \u003d createWebServer(context, containerManager\n         .getContainersMonitor(), this.aclsManager, dirsHandler);\n     addService(webServer);\n     ((NMContext) context).setWebServer(webServer);\n \n     dispatcher.register(ContainerManagerEventType.class, containerManager);\n     dispatcher.register(NodeManagerEventType.class, this);\n     addService(dispatcher);\n     \n     DefaultMetricsSystem.initialize(\"NodeManager\");\n \n     // StatusUpdater should be added last so that it get started last \n     // so that we make sure everything is up before registering with RM. \n     addService(nodeStatusUpdater);\n     \n     waitForContainersOnShutdownMillis \u003d\n         conf.getLong(YarnConfiguration.NM_SLEEP_DELAY_BEFORE_SIGKILL_MS,\n             YarnConfiguration.DEFAULT_NM_SLEEP_DELAY_BEFORE_SIGKILL_MS) + \n         conf.getLong(YarnConfiguration.NM_PROCESS_KILL_WAIT_MS,\n             YarnConfiguration.DEFAULT_NM_PROCESS_KILL_WAIT_MS) +\n         SHUTDOWN_CLEANUP_SLOP_MS;\n     \n     super.serviceInit(conf);\n     // TODO add local dirs to del\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceInit(Configuration conf) throws Exception {\n\n    conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n\n    NMContainerTokenSecretManager containerTokenSecretManager \u003d\n        new NMContainerTokenSecretManager(conf);\n\n    NMTokenSecretManagerInNM nmTokenSecretManager \u003d\n        new NMTokenSecretManagerInNM();\n    \n    this.context \u003d\n        createNMContext(containerTokenSecretManager, nmTokenSecretManager);\n\n    this.aclsManager \u003d new ApplicationACLsManager(conf);\n\n    ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n        conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n          DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n    try {\n      exec.init();\n    } catch (IOException e) {\n      throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n    }    \n    DeletionService del \u003d createDeletionService(exec);\n    addService(del);\n\n    // NodeManager level dispatcher\n    this.dispatcher \u003d new AsyncDispatcher();\n\n    nodeHealthChecker \u003d new NodeHealthCheckerService();\n    addService(nodeHealthChecker);\n    dirsHandler \u003d nodeHealthChecker.getDiskHandler();\n\n\n    nodeStatusUpdater \u003d\n        createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n\n    NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n    addService(nodeResourceMonitor);\n\n    containerManager \u003d\n        createContainerManager(context, exec, del, nodeStatusUpdater,\n        this.aclsManager, dirsHandler);\n    addService(containerManager);\n    ((NMContext) context).setContainerManager(containerManager);\n\n    WebServer webServer \u003d createWebServer(context, containerManager\n        .getContainersMonitor(), this.aclsManager, dirsHandler);\n    addService(webServer);\n    ((NMContext) context).setWebServer(webServer);\n\n    dispatcher.register(ContainerManagerEventType.class, containerManager);\n    dispatcher.register(NodeManagerEventType.class, this);\n    addService(dispatcher);\n    \n    DefaultMetricsSystem.initialize(\"NodeManager\");\n\n    // StatusUpdater should be added last so that it get started last \n    // so that we make sure everything is up before registering with RM. \n    addService(nodeStatusUpdater);\n    \n    waitForContainersOnShutdownMillis \u003d\n        conf.getLong(YarnConfiguration.NM_SLEEP_DELAY_BEFORE_SIGKILL_MS,\n            YarnConfiguration.DEFAULT_NM_SLEEP_DELAY_BEFORE_SIGKILL_MS) + \n        conf.getLong(YarnConfiguration.NM_PROCESS_KILL_WAIT_MS,\n            YarnConfiguration.DEFAULT_NM_PROCESS_KILL_WAIT_MS) +\n        SHUTDOWN_CLEANUP_SLOP_MS;\n    \n    super.serviceInit(conf);\n    // TODO add local dirs to del\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java",
      "extendedDetails": {}
    },
    "0928502029ef141759008997335ea2cd836a7154": {
      "type": "Ymultichange(Yrename,Ymodifierchange,Yexceptionschange,Ybodychange)",
      "commitMessage": "YARN-530. Defined Service model strictly, implemented AbstractService for robust subclassing and migrated yarn-common services. Contributed by Steve Loughran.\nYARN-117. Migrated rest of YARN to the new service model. Contributed by Steve Louhran.\nMAPREDUCE-5298. Moved MapReduce services to YARN-530 stricter lifecycle. Contributed by Steve Loughran.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1492718 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "13/06/13 8:54 AM",
      "commitName": "0928502029ef141759008997335ea2cd836a7154",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "YARN-530. Defined Service model strictly, implemented AbstractService for robust subclassing and migrated yarn-common services. Contributed by Steve Loughran.\nYARN-117. Migrated rest of YARN to the new service model. Contributed by Steve Louhran.\nMAPREDUCE-5298. Moved MapReduce services to YARN-530 stricter lifecycle. Contributed by Steve Loughran.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1492718 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "13/06/13 8:54 AM",
          "commitName": "0928502029ef141759008997335ea2cd836a7154",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "03/06/13 9:05 PM",
          "commitNameOld": "a83fb61ac07c0468cbc7a38526e92683883dd932",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 9.49,
          "commitsBetweenForRepo": 61,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,67 +1,67 @@\n-  public void init(Configuration conf) {\n+  protected void serviceInit(Configuration conf) throws Exception {\n \n     conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n \n     NMContainerTokenSecretManager containerTokenSecretManager \u003d\n         new NMContainerTokenSecretManager(conf);\n \n     this.context \u003d createNMContext(containerTokenSecretManager);\n \n     this.aclsManager \u003d new ApplicationACLsManager(conf);\n \n     ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n         conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n           DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n     try {\n       exec.init();\n     } catch (IOException e) {\n       throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n     }    \n     DeletionService del \u003d createDeletionService(exec);\n     addService(del);\n \n     // NodeManager level dispatcher\n     this.dispatcher \u003d new AsyncDispatcher();\n \n     nodeHealthChecker \u003d new NodeHealthCheckerService();\n     addService(nodeHealthChecker);\n     dirsHandler \u003d nodeHealthChecker.getDiskHandler();\n \n \n     nodeStatusUpdater \u003d\n         createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n \n     NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n     addService(nodeResourceMonitor);\n \n     containerManager \u003d\n         createContainerManager(context, exec, del, nodeStatusUpdater,\n         this.aclsManager, dirsHandler);\n     addService(containerManager);\n     ((NMContext) context).setContainerManager(containerManager);\n \n     WebServer webServer \u003d createWebServer(context, containerManager\n         .getContainersMonitor(), this.aclsManager, dirsHandler);\n     addService(webServer);\n     ((NMContext) context).setWebServer(webServer);\n \n     dispatcher.register(ContainerManagerEventType.class, containerManager);\n     dispatcher.register(NodeManagerEventType.class, this);\n     addService(dispatcher);\n     \n     DefaultMetricsSystem.initialize(\"NodeManager\");\n \n     // StatusUpdater should be added last so that it get started last \n     // so that we make sure everything is up before registering with RM. \n     addService(nodeStatusUpdater);\n     \n     waitForContainersOnShutdownMillis \u003d\n         conf.getLong(YarnConfiguration.NM_SLEEP_DELAY_BEFORE_SIGKILL_MS,\n             YarnConfiguration.DEFAULT_NM_SLEEP_DELAY_BEFORE_SIGKILL_MS) + \n         conf.getLong(YarnConfiguration.NM_PROCESS_KILL_WAIT_MS,\n             YarnConfiguration.DEFAULT_NM_PROCESS_KILL_WAIT_MS) +\n         SHUTDOWN_CLEANUP_SLOP_MS;\n     \n-    super.init(conf);\n+    super.serviceInit(conf);\n     // TODO add local dirs to del\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected void serviceInit(Configuration conf) throws Exception {\n\n    conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n\n    NMContainerTokenSecretManager containerTokenSecretManager \u003d\n        new NMContainerTokenSecretManager(conf);\n\n    this.context \u003d createNMContext(containerTokenSecretManager);\n\n    this.aclsManager \u003d new ApplicationACLsManager(conf);\n\n    ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n        conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n          DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n    try {\n      exec.init();\n    } catch (IOException e) {\n      throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n    }    \n    DeletionService del \u003d createDeletionService(exec);\n    addService(del);\n\n    // NodeManager level dispatcher\n    this.dispatcher \u003d new AsyncDispatcher();\n\n    nodeHealthChecker \u003d new NodeHealthCheckerService();\n    addService(nodeHealthChecker);\n    dirsHandler \u003d nodeHealthChecker.getDiskHandler();\n\n\n    nodeStatusUpdater \u003d\n        createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n\n    NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n    addService(nodeResourceMonitor);\n\n    containerManager \u003d\n        createContainerManager(context, exec, del, nodeStatusUpdater,\n        this.aclsManager, dirsHandler);\n    addService(containerManager);\n    ((NMContext) context).setContainerManager(containerManager);\n\n    WebServer webServer \u003d createWebServer(context, containerManager\n        .getContainersMonitor(), this.aclsManager, dirsHandler);\n    addService(webServer);\n    ((NMContext) context).setWebServer(webServer);\n\n    dispatcher.register(ContainerManagerEventType.class, containerManager);\n    dispatcher.register(NodeManagerEventType.class, this);\n    addService(dispatcher);\n    \n    DefaultMetricsSystem.initialize(\"NodeManager\");\n\n    // StatusUpdater should be added last so that it get started last \n    // so that we make sure everything is up before registering with RM. \n    addService(nodeStatusUpdater);\n    \n    waitForContainersOnShutdownMillis \u003d\n        conf.getLong(YarnConfiguration.NM_SLEEP_DELAY_BEFORE_SIGKILL_MS,\n            YarnConfiguration.DEFAULT_NM_SLEEP_DELAY_BEFORE_SIGKILL_MS) + \n        conf.getLong(YarnConfiguration.NM_PROCESS_KILL_WAIT_MS,\n            YarnConfiguration.DEFAULT_NM_PROCESS_KILL_WAIT_MS) +\n        SHUTDOWN_CLEANUP_SLOP_MS;\n    \n    super.serviceInit(conf);\n    // TODO add local dirs to del\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java",
          "extendedDetails": {
            "oldValue": "init",
            "newValue": "serviceInit"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "YARN-530. Defined Service model strictly, implemented AbstractService for robust subclassing and migrated yarn-common services. Contributed by Steve Loughran.\nYARN-117. Migrated rest of YARN to the new service model. Contributed by Steve Louhran.\nMAPREDUCE-5298. Moved MapReduce services to YARN-530 stricter lifecycle. Contributed by Steve Loughran.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1492718 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "13/06/13 8:54 AM",
          "commitName": "0928502029ef141759008997335ea2cd836a7154",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "03/06/13 9:05 PM",
          "commitNameOld": "a83fb61ac07c0468cbc7a38526e92683883dd932",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 9.49,
          "commitsBetweenForRepo": 61,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,67 +1,67 @@\n-  public void init(Configuration conf) {\n+  protected void serviceInit(Configuration conf) throws Exception {\n \n     conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n \n     NMContainerTokenSecretManager containerTokenSecretManager \u003d\n         new NMContainerTokenSecretManager(conf);\n \n     this.context \u003d createNMContext(containerTokenSecretManager);\n \n     this.aclsManager \u003d new ApplicationACLsManager(conf);\n \n     ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n         conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n           DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n     try {\n       exec.init();\n     } catch (IOException e) {\n       throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n     }    \n     DeletionService del \u003d createDeletionService(exec);\n     addService(del);\n \n     // NodeManager level dispatcher\n     this.dispatcher \u003d new AsyncDispatcher();\n \n     nodeHealthChecker \u003d new NodeHealthCheckerService();\n     addService(nodeHealthChecker);\n     dirsHandler \u003d nodeHealthChecker.getDiskHandler();\n \n \n     nodeStatusUpdater \u003d\n         createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n \n     NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n     addService(nodeResourceMonitor);\n \n     containerManager \u003d\n         createContainerManager(context, exec, del, nodeStatusUpdater,\n         this.aclsManager, dirsHandler);\n     addService(containerManager);\n     ((NMContext) context).setContainerManager(containerManager);\n \n     WebServer webServer \u003d createWebServer(context, containerManager\n         .getContainersMonitor(), this.aclsManager, dirsHandler);\n     addService(webServer);\n     ((NMContext) context).setWebServer(webServer);\n \n     dispatcher.register(ContainerManagerEventType.class, containerManager);\n     dispatcher.register(NodeManagerEventType.class, this);\n     addService(dispatcher);\n     \n     DefaultMetricsSystem.initialize(\"NodeManager\");\n \n     // StatusUpdater should be added last so that it get started last \n     // so that we make sure everything is up before registering with RM. \n     addService(nodeStatusUpdater);\n     \n     waitForContainersOnShutdownMillis \u003d\n         conf.getLong(YarnConfiguration.NM_SLEEP_DELAY_BEFORE_SIGKILL_MS,\n             YarnConfiguration.DEFAULT_NM_SLEEP_DELAY_BEFORE_SIGKILL_MS) + \n         conf.getLong(YarnConfiguration.NM_PROCESS_KILL_WAIT_MS,\n             YarnConfiguration.DEFAULT_NM_PROCESS_KILL_WAIT_MS) +\n         SHUTDOWN_CLEANUP_SLOP_MS;\n     \n-    super.init(conf);\n+    super.serviceInit(conf);\n     // TODO add local dirs to del\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected void serviceInit(Configuration conf) throws Exception {\n\n    conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n\n    NMContainerTokenSecretManager containerTokenSecretManager \u003d\n        new NMContainerTokenSecretManager(conf);\n\n    this.context \u003d createNMContext(containerTokenSecretManager);\n\n    this.aclsManager \u003d new ApplicationACLsManager(conf);\n\n    ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n        conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n          DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n    try {\n      exec.init();\n    } catch (IOException e) {\n      throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n    }    \n    DeletionService del \u003d createDeletionService(exec);\n    addService(del);\n\n    // NodeManager level dispatcher\n    this.dispatcher \u003d new AsyncDispatcher();\n\n    nodeHealthChecker \u003d new NodeHealthCheckerService();\n    addService(nodeHealthChecker);\n    dirsHandler \u003d nodeHealthChecker.getDiskHandler();\n\n\n    nodeStatusUpdater \u003d\n        createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n\n    NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n    addService(nodeResourceMonitor);\n\n    containerManager \u003d\n        createContainerManager(context, exec, del, nodeStatusUpdater,\n        this.aclsManager, dirsHandler);\n    addService(containerManager);\n    ((NMContext) context).setContainerManager(containerManager);\n\n    WebServer webServer \u003d createWebServer(context, containerManager\n        .getContainersMonitor(), this.aclsManager, dirsHandler);\n    addService(webServer);\n    ((NMContext) context).setWebServer(webServer);\n\n    dispatcher.register(ContainerManagerEventType.class, containerManager);\n    dispatcher.register(NodeManagerEventType.class, this);\n    addService(dispatcher);\n    \n    DefaultMetricsSystem.initialize(\"NodeManager\");\n\n    // StatusUpdater should be added last so that it get started last \n    // so that we make sure everything is up before registering with RM. \n    addService(nodeStatusUpdater);\n    \n    waitForContainersOnShutdownMillis \u003d\n        conf.getLong(YarnConfiguration.NM_SLEEP_DELAY_BEFORE_SIGKILL_MS,\n            YarnConfiguration.DEFAULT_NM_SLEEP_DELAY_BEFORE_SIGKILL_MS) + \n        conf.getLong(YarnConfiguration.NM_PROCESS_KILL_WAIT_MS,\n            YarnConfiguration.DEFAULT_NM_PROCESS_KILL_WAIT_MS) +\n        SHUTDOWN_CLEANUP_SLOP_MS;\n    \n    super.serviceInit(conf);\n    // TODO add local dirs to del\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java",
          "extendedDetails": {
            "oldValue": "[public]",
            "newValue": "[protected]"
          }
        },
        {
          "type": "Yexceptionschange",
          "commitMessage": "YARN-530. Defined Service model strictly, implemented AbstractService for robust subclassing and migrated yarn-common services. Contributed by Steve Loughran.\nYARN-117. Migrated rest of YARN to the new service model. Contributed by Steve Louhran.\nMAPREDUCE-5298. Moved MapReduce services to YARN-530 stricter lifecycle. Contributed by Steve Loughran.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1492718 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "13/06/13 8:54 AM",
          "commitName": "0928502029ef141759008997335ea2cd836a7154",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "03/06/13 9:05 PM",
          "commitNameOld": "a83fb61ac07c0468cbc7a38526e92683883dd932",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 9.49,
          "commitsBetweenForRepo": 61,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,67 +1,67 @@\n-  public void init(Configuration conf) {\n+  protected void serviceInit(Configuration conf) throws Exception {\n \n     conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n \n     NMContainerTokenSecretManager containerTokenSecretManager \u003d\n         new NMContainerTokenSecretManager(conf);\n \n     this.context \u003d createNMContext(containerTokenSecretManager);\n \n     this.aclsManager \u003d new ApplicationACLsManager(conf);\n \n     ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n         conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n           DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n     try {\n       exec.init();\n     } catch (IOException e) {\n       throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n     }    \n     DeletionService del \u003d createDeletionService(exec);\n     addService(del);\n \n     // NodeManager level dispatcher\n     this.dispatcher \u003d new AsyncDispatcher();\n \n     nodeHealthChecker \u003d new NodeHealthCheckerService();\n     addService(nodeHealthChecker);\n     dirsHandler \u003d nodeHealthChecker.getDiskHandler();\n \n \n     nodeStatusUpdater \u003d\n         createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n \n     NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n     addService(nodeResourceMonitor);\n \n     containerManager \u003d\n         createContainerManager(context, exec, del, nodeStatusUpdater,\n         this.aclsManager, dirsHandler);\n     addService(containerManager);\n     ((NMContext) context).setContainerManager(containerManager);\n \n     WebServer webServer \u003d createWebServer(context, containerManager\n         .getContainersMonitor(), this.aclsManager, dirsHandler);\n     addService(webServer);\n     ((NMContext) context).setWebServer(webServer);\n \n     dispatcher.register(ContainerManagerEventType.class, containerManager);\n     dispatcher.register(NodeManagerEventType.class, this);\n     addService(dispatcher);\n     \n     DefaultMetricsSystem.initialize(\"NodeManager\");\n \n     // StatusUpdater should be added last so that it get started last \n     // so that we make sure everything is up before registering with RM. \n     addService(nodeStatusUpdater);\n     \n     waitForContainersOnShutdownMillis \u003d\n         conf.getLong(YarnConfiguration.NM_SLEEP_DELAY_BEFORE_SIGKILL_MS,\n             YarnConfiguration.DEFAULT_NM_SLEEP_DELAY_BEFORE_SIGKILL_MS) + \n         conf.getLong(YarnConfiguration.NM_PROCESS_KILL_WAIT_MS,\n             YarnConfiguration.DEFAULT_NM_PROCESS_KILL_WAIT_MS) +\n         SHUTDOWN_CLEANUP_SLOP_MS;\n     \n-    super.init(conf);\n+    super.serviceInit(conf);\n     // TODO add local dirs to del\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected void serviceInit(Configuration conf) throws Exception {\n\n    conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n\n    NMContainerTokenSecretManager containerTokenSecretManager \u003d\n        new NMContainerTokenSecretManager(conf);\n\n    this.context \u003d createNMContext(containerTokenSecretManager);\n\n    this.aclsManager \u003d new ApplicationACLsManager(conf);\n\n    ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n        conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n          DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n    try {\n      exec.init();\n    } catch (IOException e) {\n      throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n    }    \n    DeletionService del \u003d createDeletionService(exec);\n    addService(del);\n\n    // NodeManager level dispatcher\n    this.dispatcher \u003d new AsyncDispatcher();\n\n    nodeHealthChecker \u003d new NodeHealthCheckerService();\n    addService(nodeHealthChecker);\n    dirsHandler \u003d nodeHealthChecker.getDiskHandler();\n\n\n    nodeStatusUpdater \u003d\n        createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n\n    NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n    addService(nodeResourceMonitor);\n\n    containerManager \u003d\n        createContainerManager(context, exec, del, nodeStatusUpdater,\n        this.aclsManager, dirsHandler);\n    addService(containerManager);\n    ((NMContext) context).setContainerManager(containerManager);\n\n    WebServer webServer \u003d createWebServer(context, containerManager\n        .getContainersMonitor(), this.aclsManager, dirsHandler);\n    addService(webServer);\n    ((NMContext) context).setWebServer(webServer);\n\n    dispatcher.register(ContainerManagerEventType.class, containerManager);\n    dispatcher.register(NodeManagerEventType.class, this);\n    addService(dispatcher);\n    \n    DefaultMetricsSystem.initialize(\"NodeManager\");\n\n    // StatusUpdater should be added last so that it get started last \n    // so that we make sure everything is up before registering with RM. \n    addService(nodeStatusUpdater);\n    \n    waitForContainersOnShutdownMillis \u003d\n        conf.getLong(YarnConfiguration.NM_SLEEP_DELAY_BEFORE_SIGKILL_MS,\n            YarnConfiguration.DEFAULT_NM_SLEEP_DELAY_BEFORE_SIGKILL_MS) + \n        conf.getLong(YarnConfiguration.NM_PROCESS_KILL_WAIT_MS,\n            YarnConfiguration.DEFAULT_NM_PROCESS_KILL_WAIT_MS) +\n        SHUTDOWN_CLEANUP_SLOP_MS;\n    \n    super.serviceInit(conf);\n    // TODO add local dirs to del\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[Exception]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-530. Defined Service model strictly, implemented AbstractService for robust subclassing and migrated yarn-common services. Contributed by Steve Loughran.\nYARN-117. Migrated rest of YARN to the new service model. Contributed by Steve Louhran.\nMAPREDUCE-5298. Moved MapReduce services to YARN-530 stricter lifecycle. Contributed by Steve Loughran.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1492718 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "13/06/13 8:54 AM",
          "commitName": "0928502029ef141759008997335ea2cd836a7154",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "03/06/13 9:05 PM",
          "commitNameOld": "a83fb61ac07c0468cbc7a38526e92683883dd932",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 9.49,
          "commitsBetweenForRepo": 61,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,67 +1,67 @@\n-  public void init(Configuration conf) {\n+  protected void serviceInit(Configuration conf) throws Exception {\n \n     conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n \n     NMContainerTokenSecretManager containerTokenSecretManager \u003d\n         new NMContainerTokenSecretManager(conf);\n \n     this.context \u003d createNMContext(containerTokenSecretManager);\n \n     this.aclsManager \u003d new ApplicationACLsManager(conf);\n \n     ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n         conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n           DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n     try {\n       exec.init();\n     } catch (IOException e) {\n       throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n     }    \n     DeletionService del \u003d createDeletionService(exec);\n     addService(del);\n \n     // NodeManager level dispatcher\n     this.dispatcher \u003d new AsyncDispatcher();\n \n     nodeHealthChecker \u003d new NodeHealthCheckerService();\n     addService(nodeHealthChecker);\n     dirsHandler \u003d nodeHealthChecker.getDiskHandler();\n \n \n     nodeStatusUpdater \u003d\n         createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n \n     NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n     addService(nodeResourceMonitor);\n \n     containerManager \u003d\n         createContainerManager(context, exec, del, nodeStatusUpdater,\n         this.aclsManager, dirsHandler);\n     addService(containerManager);\n     ((NMContext) context).setContainerManager(containerManager);\n \n     WebServer webServer \u003d createWebServer(context, containerManager\n         .getContainersMonitor(), this.aclsManager, dirsHandler);\n     addService(webServer);\n     ((NMContext) context).setWebServer(webServer);\n \n     dispatcher.register(ContainerManagerEventType.class, containerManager);\n     dispatcher.register(NodeManagerEventType.class, this);\n     addService(dispatcher);\n     \n     DefaultMetricsSystem.initialize(\"NodeManager\");\n \n     // StatusUpdater should be added last so that it get started last \n     // so that we make sure everything is up before registering with RM. \n     addService(nodeStatusUpdater);\n     \n     waitForContainersOnShutdownMillis \u003d\n         conf.getLong(YarnConfiguration.NM_SLEEP_DELAY_BEFORE_SIGKILL_MS,\n             YarnConfiguration.DEFAULT_NM_SLEEP_DELAY_BEFORE_SIGKILL_MS) + \n         conf.getLong(YarnConfiguration.NM_PROCESS_KILL_WAIT_MS,\n             YarnConfiguration.DEFAULT_NM_PROCESS_KILL_WAIT_MS) +\n         SHUTDOWN_CLEANUP_SLOP_MS;\n     \n-    super.init(conf);\n+    super.serviceInit(conf);\n     // TODO add local dirs to del\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected void serviceInit(Configuration conf) throws Exception {\n\n    conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n\n    NMContainerTokenSecretManager containerTokenSecretManager \u003d\n        new NMContainerTokenSecretManager(conf);\n\n    this.context \u003d createNMContext(containerTokenSecretManager);\n\n    this.aclsManager \u003d new ApplicationACLsManager(conf);\n\n    ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n        conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n          DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n    try {\n      exec.init();\n    } catch (IOException e) {\n      throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n    }    \n    DeletionService del \u003d createDeletionService(exec);\n    addService(del);\n\n    // NodeManager level dispatcher\n    this.dispatcher \u003d new AsyncDispatcher();\n\n    nodeHealthChecker \u003d new NodeHealthCheckerService();\n    addService(nodeHealthChecker);\n    dirsHandler \u003d nodeHealthChecker.getDiskHandler();\n\n\n    nodeStatusUpdater \u003d\n        createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n\n    NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n    addService(nodeResourceMonitor);\n\n    containerManager \u003d\n        createContainerManager(context, exec, del, nodeStatusUpdater,\n        this.aclsManager, dirsHandler);\n    addService(containerManager);\n    ((NMContext) context).setContainerManager(containerManager);\n\n    WebServer webServer \u003d createWebServer(context, containerManager\n        .getContainersMonitor(), this.aclsManager, dirsHandler);\n    addService(webServer);\n    ((NMContext) context).setWebServer(webServer);\n\n    dispatcher.register(ContainerManagerEventType.class, containerManager);\n    dispatcher.register(NodeManagerEventType.class, this);\n    addService(dispatcher);\n    \n    DefaultMetricsSystem.initialize(\"NodeManager\");\n\n    // StatusUpdater should be added last so that it get started last \n    // so that we make sure everything is up before registering with RM. \n    addService(nodeStatusUpdater);\n    \n    waitForContainersOnShutdownMillis \u003d\n        conf.getLong(YarnConfiguration.NM_SLEEP_DELAY_BEFORE_SIGKILL_MS,\n            YarnConfiguration.DEFAULT_NM_SLEEP_DELAY_BEFORE_SIGKILL_MS) + \n        conf.getLong(YarnConfiguration.NM_PROCESS_KILL_WAIT_MS,\n            YarnConfiguration.DEFAULT_NM_PROCESS_KILL_WAIT_MS) +\n        SHUTDOWN_CLEANUP_SLOP_MS;\n    \n    super.serviceInit(conf);\n    // TODO add local dirs to del\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java",
          "extendedDetails": {}
        }
      ]
    },
    "a83fb61ac07c0468cbc7a38526e92683883dd932": {
      "type": "Ybodychange",
      "commitMessage": "YARN-635. Renamed YarnRemoteException to YarnException. Contributed by Siddharth Seth.\nMAPREDUCE-5301. Updated MR code to work with YARN-635 changes of renaming YarnRemoteException to YarnException. Contributed by Siddharth Seth\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1489283 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/06/13 9:05 PM",
      "commitName": "a83fb61ac07c0468cbc7a38526e92683883dd932",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "31/05/13 5:14 PM",
      "commitNameOld": "39f019f41392d9e46ea1dc86ddd5563aabbeda1e",
      "commitAuthorOld": "Siddharth Seth",
      "daysBetweenCommits": 3.16,
      "commitsBetweenForRepo": 36,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,67 +1,67 @@\n   public void init(Configuration conf) {\n \n     conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n \n     NMContainerTokenSecretManager containerTokenSecretManager \u003d\n         new NMContainerTokenSecretManager(conf);\n \n     this.context \u003d createNMContext(containerTokenSecretManager);\n \n     this.aclsManager \u003d new ApplicationACLsManager(conf);\n \n     ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n         conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n           DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n     try {\n       exec.init();\n     } catch (IOException e) {\n-      throw new YarnException(\"Failed to initialize container executor\", e);\n+      throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n     }    \n     DeletionService del \u003d createDeletionService(exec);\n     addService(del);\n \n     // NodeManager level dispatcher\n     this.dispatcher \u003d new AsyncDispatcher();\n \n     nodeHealthChecker \u003d new NodeHealthCheckerService();\n     addService(nodeHealthChecker);\n     dirsHandler \u003d nodeHealthChecker.getDiskHandler();\n \n \n     nodeStatusUpdater \u003d\n         createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n \n     NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n     addService(nodeResourceMonitor);\n \n     containerManager \u003d\n         createContainerManager(context, exec, del, nodeStatusUpdater,\n         this.aclsManager, dirsHandler);\n     addService(containerManager);\n     ((NMContext) context).setContainerManager(containerManager);\n \n     WebServer webServer \u003d createWebServer(context, containerManager\n         .getContainersMonitor(), this.aclsManager, dirsHandler);\n     addService(webServer);\n     ((NMContext) context).setWebServer(webServer);\n \n     dispatcher.register(ContainerManagerEventType.class, containerManager);\n     dispatcher.register(NodeManagerEventType.class, this);\n     addService(dispatcher);\n     \n     DefaultMetricsSystem.initialize(\"NodeManager\");\n \n     // StatusUpdater should be added last so that it get started last \n     // so that we make sure everything is up before registering with RM. \n     addService(nodeStatusUpdater);\n     \n     waitForContainersOnShutdownMillis \u003d\n         conf.getLong(YarnConfiguration.NM_SLEEP_DELAY_BEFORE_SIGKILL_MS,\n             YarnConfiguration.DEFAULT_NM_SLEEP_DELAY_BEFORE_SIGKILL_MS) + \n         conf.getLong(YarnConfiguration.NM_PROCESS_KILL_WAIT_MS,\n             YarnConfiguration.DEFAULT_NM_PROCESS_KILL_WAIT_MS) +\n         SHUTDOWN_CLEANUP_SLOP_MS;\n     \n     super.init(conf);\n     // TODO add local dirs to del\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void init(Configuration conf) {\n\n    conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n\n    NMContainerTokenSecretManager containerTokenSecretManager \u003d\n        new NMContainerTokenSecretManager(conf);\n\n    this.context \u003d createNMContext(containerTokenSecretManager);\n\n    this.aclsManager \u003d new ApplicationACLsManager(conf);\n\n    ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n        conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n          DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n    try {\n      exec.init();\n    } catch (IOException e) {\n      throw new YarnRuntimeException(\"Failed to initialize container executor\", e);\n    }    \n    DeletionService del \u003d createDeletionService(exec);\n    addService(del);\n\n    // NodeManager level dispatcher\n    this.dispatcher \u003d new AsyncDispatcher();\n\n    nodeHealthChecker \u003d new NodeHealthCheckerService();\n    addService(nodeHealthChecker);\n    dirsHandler \u003d nodeHealthChecker.getDiskHandler();\n\n\n    nodeStatusUpdater \u003d\n        createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n\n    NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n    addService(nodeResourceMonitor);\n\n    containerManager \u003d\n        createContainerManager(context, exec, del, nodeStatusUpdater,\n        this.aclsManager, dirsHandler);\n    addService(containerManager);\n    ((NMContext) context).setContainerManager(containerManager);\n\n    WebServer webServer \u003d createWebServer(context, containerManager\n        .getContainersMonitor(), this.aclsManager, dirsHandler);\n    addService(webServer);\n    ((NMContext) context).setWebServer(webServer);\n\n    dispatcher.register(ContainerManagerEventType.class, containerManager);\n    dispatcher.register(NodeManagerEventType.class, this);\n    addService(dispatcher);\n    \n    DefaultMetricsSystem.initialize(\"NodeManager\");\n\n    // StatusUpdater should be added last so that it get started last \n    // so that we make sure everything is up before registering with RM. \n    addService(nodeStatusUpdater);\n    \n    waitForContainersOnShutdownMillis \u003d\n        conf.getLong(YarnConfiguration.NM_SLEEP_DELAY_BEFORE_SIGKILL_MS,\n            YarnConfiguration.DEFAULT_NM_SLEEP_DELAY_BEFORE_SIGKILL_MS) + \n        conf.getLong(YarnConfiguration.NM_PROCESS_KILL_WAIT_MS,\n            YarnConfiguration.DEFAULT_NM_PROCESS_KILL_WAIT_MS) +\n        SHUTDOWN_CLEANUP_SLOP_MS;\n    \n    super.init(conf);\n    // TODO add local dirs to del\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java",
      "extendedDetails": {}
    },
    "2692675fc3b5046d2ec88542c30203c87e135b70": {
      "type": "Ybodychange",
      "commitMessage": "YARN-684. ContainerManager.startContainer should use ContainerTokenIdentifier instead of the entire Container. Contributed by Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1488085 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/05/13 9:13 PM",
      "commitName": "2692675fc3b5046d2ec88542c30203c87e135b70",
      "commitAuthor": "Siddharth Seth",
      "commitDateOld": "16/05/13 11:36 PM",
      "commitNameOld": "ca8024673178fa1c80224b390dfba932921693d9",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 13.9,
      "commitsBetweenForRepo": 57,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,66 +1,67 @@\n   public void init(Configuration conf) {\n \n     conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n \n     NMContainerTokenSecretManager containerTokenSecretManager \u003d\n         new NMContainerTokenSecretManager(conf);\n \n     this.context \u003d createNMContext(containerTokenSecretManager);\n \n     this.aclsManager \u003d new ApplicationACLsManager(conf);\n \n     ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n         conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n           DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n     try {\n       exec.init();\n     } catch (IOException e) {\n       throw new YarnException(\"Failed to initialize container executor\", e);\n     }    \n     DeletionService del \u003d createDeletionService(exec);\n     addService(del);\n \n     // NodeManager level dispatcher\n     this.dispatcher \u003d new AsyncDispatcher();\n \n     nodeHealthChecker \u003d new NodeHealthCheckerService();\n     addService(nodeHealthChecker);\n     dirsHandler \u003d nodeHealthChecker.getDiskHandler();\n \n \n     nodeStatusUpdater \u003d\n         createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n \n     NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n     addService(nodeResourceMonitor);\n \n     containerManager \u003d\n         createContainerManager(context, exec, del, nodeStatusUpdater,\n         this.aclsManager, dirsHandler);\n     addService(containerManager);\n     ((NMContext) context).setContainerManager(containerManager);\n \n-    Service webServer \u003d createWebServer(context, containerManager\n+    WebServer webServer \u003d createWebServer(context, containerManager\n         .getContainersMonitor(), this.aclsManager, dirsHandler);\n     addService(webServer);\n+    ((NMContext) context).setWebServer(webServer);\n \n     dispatcher.register(ContainerManagerEventType.class, containerManager);\n     dispatcher.register(NodeManagerEventType.class, this);\n     addService(dispatcher);\n     \n     DefaultMetricsSystem.initialize(\"NodeManager\");\n \n     // StatusUpdater should be added last so that it get started last \n     // so that we make sure everything is up before registering with RM. \n     addService(nodeStatusUpdater);\n     \n     waitForContainersOnShutdownMillis \u003d\n         conf.getLong(YarnConfiguration.NM_SLEEP_DELAY_BEFORE_SIGKILL_MS,\n             YarnConfiguration.DEFAULT_NM_SLEEP_DELAY_BEFORE_SIGKILL_MS) + \n         conf.getLong(YarnConfiguration.NM_PROCESS_KILL_WAIT_MS,\n             YarnConfiguration.DEFAULT_NM_PROCESS_KILL_WAIT_MS) +\n         SHUTDOWN_CLEANUP_SLOP_MS;\n     \n     super.init(conf);\n     // TODO add local dirs to del\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void init(Configuration conf) {\n\n    conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n\n    NMContainerTokenSecretManager containerTokenSecretManager \u003d\n        new NMContainerTokenSecretManager(conf);\n\n    this.context \u003d createNMContext(containerTokenSecretManager);\n\n    this.aclsManager \u003d new ApplicationACLsManager(conf);\n\n    ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n        conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n          DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n    try {\n      exec.init();\n    } catch (IOException e) {\n      throw new YarnException(\"Failed to initialize container executor\", e);\n    }    \n    DeletionService del \u003d createDeletionService(exec);\n    addService(del);\n\n    // NodeManager level dispatcher\n    this.dispatcher \u003d new AsyncDispatcher();\n\n    nodeHealthChecker \u003d new NodeHealthCheckerService();\n    addService(nodeHealthChecker);\n    dirsHandler \u003d nodeHealthChecker.getDiskHandler();\n\n\n    nodeStatusUpdater \u003d\n        createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n\n    NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n    addService(nodeResourceMonitor);\n\n    containerManager \u003d\n        createContainerManager(context, exec, del, nodeStatusUpdater,\n        this.aclsManager, dirsHandler);\n    addService(containerManager);\n    ((NMContext) context).setContainerManager(containerManager);\n\n    WebServer webServer \u003d createWebServer(context, containerManager\n        .getContainersMonitor(), this.aclsManager, dirsHandler);\n    addService(webServer);\n    ((NMContext) context).setWebServer(webServer);\n\n    dispatcher.register(ContainerManagerEventType.class, containerManager);\n    dispatcher.register(NodeManagerEventType.class, this);\n    addService(dispatcher);\n    \n    DefaultMetricsSystem.initialize(\"NodeManager\");\n\n    // StatusUpdater should be added last so that it get started last \n    // so that we make sure everything is up before registering with RM. \n    addService(nodeStatusUpdater);\n    \n    waitForContainersOnShutdownMillis \u003d\n        conf.getLong(YarnConfiguration.NM_SLEEP_DELAY_BEFORE_SIGKILL_MS,\n            YarnConfiguration.DEFAULT_NM_SLEEP_DELAY_BEFORE_SIGKILL_MS) + \n        conf.getLong(YarnConfiguration.NM_PROCESS_KILL_WAIT_MS,\n            YarnConfiguration.DEFAULT_NM_PROCESS_KILL_WAIT_MS) +\n        SHUTDOWN_CLEANUP_SLOP_MS;\n    \n    super.init(conf);\n    // TODO add local dirs to del\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java",
      "extendedDetails": {}
    },
    "ca8024673178fa1c80224b390dfba932921693d9": {
      "type": "Ybodychange",
      "commitMessage": "YARN-617. Made ContainerTokens to be used for validation at NodeManager also in unsecure mode to prevent AMs from faking resource requirements in unsecure mode. Contributed by Omkar Vinit Joshi.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1483667 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/05/13 11:36 PM",
      "commitName": "ca8024673178fa1c80224b390dfba932921693d9",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "25/04/13 8:50 PM",
      "commitNameOld": "fbb55784d93e1a819daf55d936e864d344579cbf",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 21.12,
      "commitsBetweenForRepo": 137,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,71 +1,66 @@\n   public void init(Configuration conf) {\n \n     conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n \n-    // Create the secretManager if need be.\n-    NMContainerTokenSecretManager containerTokenSecretManager \u003d null;\n-    if (UserGroupInformation.isSecurityEnabled()) {\n-      LOG.info(\"Security is enabled on NodeManager. \"\n-          + \"Creating ContainerTokenSecretManager\");\n-      containerTokenSecretManager \u003d new NMContainerTokenSecretManager(conf);\n-    }\n+    NMContainerTokenSecretManager containerTokenSecretManager \u003d\n+        new NMContainerTokenSecretManager(conf);\n \n     this.context \u003d createNMContext(containerTokenSecretManager);\n \n     this.aclsManager \u003d new ApplicationACLsManager(conf);\n \n     ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n         conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n           DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n     try {\n       exec.init();\n     } catch (IOException e) {\n       throw new YarnException(\"Failed to initialize container executor\", e);\n     }    \n     DeletionService del \u003d createDeletionService(exec);\n     addService(del);\n \n     // NodeManager level dispatcher\n     this.dispatcher \u003d new AsyncDispatcher();\n \n     nodeHealthChecker \u003d new NodeHealthCheckerService();\n     addService(nodeHealthChecker);\n     dirsHandler \u003d nodeHealthChecker.getDiskHandler();\n \n \n     nodeStatusUpdater \u003d\n         createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n \n     NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n     addService(nodeResourceMonitor);\n \n     containerManager \u003d\n         createContainerManager(context, exec, del, nodeStatusUpdater,\n         this.aclsManager, dirsHandler);\n     addService(containerManager);\n     ((NMContext) context).setContainerManager(containerManager);\n \n     Service webServer \u003d createWebServer(context, containerManager\n         .getContainersMonitor(), this.aclsManager, dirsHandler);\n     addService(webServer);\n \n     dispatcher.register(ContainerManagerEventType.class, containerManager);\n     dispatcher.register(NodeManagerEventType.class, this);\n     addService(dispatcher);\n     \n     DefaultMetricsSystem.initialize(\"NodeManager\");\n \n     // StatusUpdater should be added last so that it get started last \n     // so that we make sure everything is up before registering with RM. \n     addService(nodeStatusUpdater);\n     \n     waitForContainersOnShutdownMillis \u003d\n         conf.getLong(YarnConfiguration.NM_SLEEP_DELAY_BEFORE_SIGKILL_MS,\n             YarnConfiguration.DEFAULT_NM_SLEEP_DELAY_BEFORE_SIGKILL_MS) + \n         conf.getLong(YarnConfiguration.NM_PROCESS_KILL_WAIT_MS,\n             YarnConfiguration.DEFAULT_NM_PROCESS_KILL_WAIT_MS) +\n         SHUTDOWN_CLEANUP_SLOP_MS;\n     \n     super.init(conf);\n     // TODO add local dirs to del\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void init(Configuration conf) {\n\n    conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n\n    NMContainerTokenSecretManager containerTokenSecretManager \u003d\n        new NMContainerTokenSecretManager(conf);\n\n    this.context \u003d createNMContext(containerTokenSecretManager);\n\n    this.aclsManager \u003d new ApplicationACLsManager(conf);\n\n    ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n        conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n          DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n    try {\n      exec.init();\n    } catch (IOException e) {\n      throw new YarnException(\"Failed to initialize container executor\", e);\n    }    \n    DeletionService del \u003d createDeletionService(exec);\n    addService(del);\n\n    // NodeManager level dispatcher\n    this.dispatcher \u003d new AsyncDispatcher();\n\n    nodeHealthChecker \u003d new NodeHealthCheckerService();\n    addService(nodeHealthChecker);\n    dirsHandler \u003d nodeHealthChecker.getDiskHandler();\n\n\n    nodeStatusUpdater \u003d\n        createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n\n    NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n    addService(nodeResourceMonitor);\n\n    containerManager \u003d\n        createContainerManager(context, exec, del, nodeStatusUpdater,\n        this.aclsManager, dirsHandler);\n    addService(containerManager);\n    ((NMContext) context).setContainerManager(containerManager);\n\n    Service webServer \u003d createWebServer(context, containerManager\n        .getContainersMonitor(), this.aclsManager, dirsHandler);\n    addService(webServer);\n\n    dispatcher.register(ContainerManagerEventType.class, containerManager);\n    dispatcher.register(NodeManagerEventType.class, this);\n    addService(dispatcher);\n    \n    DefaultMetricsSystem.initialize(\"NodeManager\");\n\n    // StatusUpdater should be added last so that it get started last \n    // so that we make sure everything is up before registering with RM. \n    addService(nodeStatusUpdater);\n    \n    waitForContainersOnShutdownMillis \u003d\n        conf.getLong(YarnConfiguration.NM_SLEEP_DELAY_BEFORE_SIGKILL_MS,\n            YarnConfiguration.DEFAULT_NM_SLEEP_DELAY_BEFORE_SIGKILL_MS) + \n        conf.getLong(YarnConfiguration.NM_PROCESS_KILL_WAIT_MS,\n            YarnConfiguration.DEFAULT_NM_PROCESS_KILL_WAIT_MS) +\n        SHUTDOWN_CLEANUP_SLOP_MS;\n    \n    super.init(conf);\n    // TODO add local dirs to del\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java",
      "extendedDetails": {}
    },
    "fbb55784d93e1a819daf55d936e864d344579cbf": {
      "type": "Ybodychange",
      "commitMessage": "YARN-562. Modified NM to reject any containers allocated by a previous ResourceManager. Contributed by Jian He.\nMAPREDUCE-5167. Update MR App after YARN-562 to use the new builder API for the container. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1476034 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/04/13 8:50 PM",
      "commitName": "fbb55784d93e1a819daf55d936e864d344579cbf",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "10/04/13 7:00 PM",
      "commitNameOld": "2e3b56f6e907f15f7c6caaad37d37b9e0ee89963",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 15.08,
      "commitsBetweenForRepo": 83,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,69 +1,71 @@\n   public void init(Configuration conf) {\n \n     conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n \n     // Create the secretManager if need be.\n     NMContainerTokenSecretManager containerTokenSecretManager \u003d null;\n     if (UserGroupInformation.isSecurityEnabled()) {\n       LOG.info(\"Security is enabled on NodeManager. \"\n           + \"Creating ContainerTokenSecretManager\");\n       containerTokenSecretManager \u003d new NMContainerTokenSecretManager(conf);\n     }\n \n     this.context \u003d createNMContext(containerTokenSecretManager);\n \n     this.aclsManager \u003d new ApplicationACLsManager(conf);\n \n     ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n         conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n           DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n     try {\n       exec.init();\n     } catch (IOException e) {\n       throw new YarnException(\"Failed to initialize container executor\", e);\n     }    \n     DeletionService del \u003d createDeletionService(exec);\n     addService(del);\n \n     // NodeManager level dispatcher\n     this.dispatcher \u003d new AsyncDispatcher();\n \n     nodeHealthChecker \u003d new NodeHealthCheckerService();\n     addService(nodeHealthChecker);\n     dirsHandler \u003d nodeHealthChecker.getDiskHandler();\n \n+\n     nodeStatusUpdater \u003d\n         createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n \n     NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n     addService(nodeResourceMonitor);\n \n     containerManager \u003d\n         createContainerManager(context, exec, del, nodeStatusUpdater,\n         this.aclsManager, dirsHandler);\n     addService(containerManager);\n+    ((NMContext) context).setContainerManager(containerManager);\n \n     Service webServer \u003d createWebServer(context, containerManager\n         .getContainersMonitor(), this.aclsManager, dirsHandler);\n     addService(webServer);\n \n     dispatcher.register(ContainerManagerEventType.class, containerManager);\n     dispatcher.register(NodeManagerEventType.class, this);\n     addService(dispatcher);\n     \n     DefaultMetricsSystem.initialize(\"NodeManager\");\n \n     // StatusUpdater should be added last so that it get started last \n     // so that we make sure everything is up before registering with RM. \n     addService(nodeStatusUpdater);\n     \n     waitForContainersOnShutdownMillis \u003d\n         conf.getLong(YarnConfiguration.NM_SLEEP_DELAY_BEFORE_SIGKILL_MS,\n             YarnConfiguration.DEFAULT_NM_SLEEP_DELAY_BEFORE_SIGKILL_MS) + \n         conf.getLong(YarnConfiguration.NM_PROCESS_KILL_WAIT_MS,\n             YarnConfiguration.DEFAULT_NM_PROCESS_KILL_WAIT_MS) +\n         SHUTDOWN_CLEANUP_SLOP_MS;\n     \n     super.init(conf);\n     // TODO add local dirs to del\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void init(Configuration conf) {\n\n    conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n\n    // Create the secretManager if need be.\n    NMContainerTokenSecretManager containerTokenSecretManager \u003d null;\n    if (UserGroupInformation.isSecurityEnabled()) {\n      LOG.info(\"Security is enabled on NodeManager. \"\n          + \"Creating ContainerTokenSecretManager\");\n      containerTokenSecretManager \u003d new NMContainerTokenSecretManager(conf);\n    }\n\n    this.context \u003d createNMContext(containerTokenSecretManager);\n\n    this.aclsManager \u003d new ApplicationACLsManager(conf);\n\n    ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n        conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n          DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n    try {\n      exec.init();\n    } catch (IOException e) {\n      throw new YarnException(\"Failed to initialize container executor\", e);\n    }    \n    DeletionService del \u003d createDeletionService(exec);\n    addService(del);\n\n    // NodeManager level dispatcher\n    this.dispatcher \u003d new AsyncDispatcher();\n\n    nodeHealthChecker \u003d new NodeHealthCheckerService();\n    addService(nodeHealthChecker);\n    dirsHandler \u003d nodeHealthChecker.getDiskHandler();\n\n\n    nodeStatusUpdater \u003d\n        createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n\n    NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n    addService(nodeResourceMonitor);\n\n    containerManager \u003d\n        createContainerManager(context, exec, del, nodeStatusUpdater,\n        this.aclsManager, dirsHandler);\n    addService(containerManager);\n    ((NMContext) context).setContainerManager(containerManager);\n\n    Service webServer \u003d createWebServer(context, containerManager\n        .getContainersMonitor(), this.aclsManager, dirsHandler);\n    addService(webServer);\n\n    dispatcher.register(ContainerManagerEventType.class, containerManager);\n    dispatcher.register(NodeManagerEventType.class, this);\n    addService(dispatcher);\n    \n    DefaultMetricsSystem.initialize(\"NodeManager\");\n\n    // StatusUpdater should be added last so that it get started last \n    // so that we make sure everything is up before registering with RM. \n    addService(nodeStatusUpdater);\n    \n    waitForContainersOnShutdownMillis \u003d\n        conf.getLong(YarnConfiguration.NM_SLEEP_DELAY_BEFORE_SIGKILL_MS,\n            YarnConfiguration.DEFAULT_NM_SLEEP_DELAY_BEFORE_SIGKILL_MS) + \n        conf.getLong(YarnConfiguration.NM_PROCESS_KILL_WAIT_MS,\n            YarnConfiguration.DEFAULT_NM_PROCESS_KILL_WAIT_MS) +\n        SHUTDOWN_CLEANUP_SLOP_MS;\n    \n    super.init(conf);\n    // TODO add local dirs to del\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java",
      "extendedDetails": {}
    },
    "2e3b56f6e907f15f7c6caaad37d37b9e0ee89963": {
      "type": "Ybodychange",
      "commitMessage": "YARN-495. Changed NM reboot behaviour to be a simple resync - kill all containers  and re-register with RM. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1466752 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/04/13 7:00 PM",
      "commitName": "2e3b56f6e907f15f7c6caaad37d37b9e0ee89963",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "03/04/13 9:57 AM",
      "commitNameOld": "3e9200ddde4858be8ecdd8347b5fee63ed83df84",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 7.38,
      "commitsBetweenForRepo": 42,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,69 +1,69 @@\n   public void init(Configuration conf) {\n \n     conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n \n     // Create the secretManager if need be.\n     NMContainerTokenSecretManager containerTokenSecretManager \u003d null;\n     if (UserGroupInformation.isSecurityEnabled()) {\n       LOG.info(\"Security is enabled on NodeManager. \"\n           + \"Creating ContainerTokenSecretManager\");\n       containerTokenSecretManager \u003d new NMContainerTokenSecretManager(conf);\n     }\n \n     this.context \u003d createNMContext(containerTokenSecretManager);\n \n     this.aclsManager \u003d new ApplicationACLsManager(conf);\n \n     ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n         conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n           DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n     try {\n       exec.init();\n     } catch (IOException e) {\n       throw new YarnException(\"Failed to initialize container executor\", e);\n     }    \n     DeletionService del \u003d createDeletionService(exec);\n     addService(del);\n \n     // NodeManager level dispatcher\n     this.dispatcher \u003d new AsyncDispatcher();\n \n     nodeHealthChecker \u003d new NodeHealthCheckerService();\n     addService(nodeHealthChecker);\n     dirsHandler \u003d nodeHealthChecker.getDiskHandler();\n \n-    NodeStatusUpdater nodeStatusUpdater \u003d\n+    nodeStatusUpdater \u003d\n         createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n \n     NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n     addService(nodeResourceMonitor);\n \n     containerManager \u003d\n         createContainerManager(context, exec, del, nodeStatusUpdater,\n         this.aclsManager, dirsHandler);\n     addService(containerManager);\n \n     Service webServer \u003d createWebServer(context, containerManager\n         .getContainersMonitor(), this.aclsManager, dirsHandler);\n     addService(webServer);\n \n     dispatcher.register(ContainerManagerEventType.class, containerManager);\n     dispatcher.register(NodeManagerEventType.class, this);\n     addService(dispatcher);\n     \n     DefaultMetricsSystem.initialize(\"NodeManager\");\n \n     // StatusUpdater should be added last so that it get started last \n     // so that we make sure everything is up before registering with RM. \n     addService(nodeStatusUpdater);\n     \n     waitForContainersOnShutdownMillis \u003d\n         conf.getLong(YarnConfiguration.NM_SLEEP_DELAY_BEFORE_SIGKILL_MS,\n             YarnConfiguration.DEFAULT_NM_SLEEP_DELAY_BEFORE_SIGKILL_MS) + \n         conf.getLong(YarnConfiguration.NM_PROCESS_KILL_WAIT_MS,\n             YarnConfiguration.DEFAULT_NM_PROCESS_KILL_WAIT_MS) +\n         SHUTDOWN_CLEANUP_SLOP_MS;\n     \n     super.init(conf);\n     // TODO add local dirs to del\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void init(Configuration conf) {\n\n    conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n\n    // Create the secretManager if need be.\n    NMContainerTokenSecretManager containerTokenSecretManager \u003d null;\n    if (UserGroupInformation.isSecurityEnabled()) {\n      LOG.info(\"Security is enabled on NodeManager. \"\n          + \"Creating ContainerTokenSecretManager\");\n      containerTokenSecretManager \u003d new NMContainerTokenSecretManager(conf);\n    }\n\n    this.context \u003d createNMContext(containerTokenSecretManager);\n\n    this.aclsManager \u003d new ApplicationACLsManager(conf);\n\n    ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n        conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n          DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n    try {\n      exec.init();\n    } catch (IOException e) {\n      throw new YarnException(\"Failed to initialize container executor\", e);\n    }    \n    DeletionService del \u003d createDeletionService(exec);\n    addService(del);\n\n    // NodeManager level dispatcher\n    this.dispatcher \u003d new AsyncDispatcher();\n\n    nodeHealthChecker \u003d new NodeHealthCheckerService();\n    addService(nodeHealthChecker);\n    dirsHandler \u003d nodeHealthChecker.getDiskHandler();\n\n    nodeStatusUpdater \u003d\n        createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n\n    NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n    addService(nodeResourceMonitor);\n\n    containerManager \u003d\n        createContainerManager(context, exec, del, nodeStatusUpdater,\n        this.aclsManager, dirsHandler);\n    addService(containerManager);\n\n    Service webServer \u003d createWebServer(context, containerManager\n        .getContainersMonitor(), this.aclsManager, dirsHandler);\n    addService(webServer);\n\n    dispatcher.register(ContainerManagerEventType.class, containerManager);\n    dispatcher.register(NodeManagerEventType.class, this);\n    addService(dispatcher);\n    \n    DefaultMetricsSystem.initialize(\"NodeManager\");\n\n    // StatusUpdater should be added last so that it get started last \n    // so that we make sure everything is up before registering with RM. \n    addService(nodeStatusUpdater);\n    \n    waitForContainersOnShutdownMillis \u003d\n        conf.getLong(YarnConfiguration.NM_SLEEP_DELAY_BEFORE_SIGKILL_MS,\n            YarnConfiguration.DEFAULT_NM_SLEEP_DELAY_BEFORE_SIGKILL_MS) + \n        conf.getLong(YarnConfiguration.NM_PROCESS_KILL_WAIT_MS,\n            YarnConfiguration.DEFAULT_NM_PROCESS_KILL_WAIT_MS) +\n        SHUTDOWN_CLEANUP_SLOP_MS;\n    \n    super.init(conf);\n    // TODO add local dirs to del\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java",
      "extendedDetails": {}
    },
    "3e9200ddde4858be8ecdd8347b5fee63ed83df84": {
      "type": "Ybodychange",
      "commitMessage": "YARN-101. Fix NodeManager heartbeat processing to not lose track of completed containers in case of dropped heartbeats. Contributed by Xuan Gong.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1464105 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/04/13 9:57 AM",
      "commitName": "3e9200ddde4858be8ecdd8347b5fee63ed83df84",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "25/03/13 11:23 AM",
      "commitNameOld": "6a482a88b8f56a4c5590e71ce6713d7f63830e92",
      "commitAuthorOld": "Siddharth Seth",
      "daysBetweenCommits": 8.94,
      "commitsBetweenForRepo": 49,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,69 +1,69 @@\n   public void init(Configuration conf) {\n \n     conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n \n     // Create the secretManager if need be.\n     NMContainerTokenSecretManager containerTokenSecretManager \u003d null;\n     if (UserGroupInformation.isSecurityEnabled()) {\n       LOG.info(\"Security is enabled on NodeManager. \"\n           + \"Creating ContainerTokenSecretManager\");\n       containerTokenSecretManager \u003d new NMContainerTokenSecretManager(conf);\n     }\n \n-    this.context \u003d new NMContext(containerTokenSecretManager);\n+    this.context \u003d createNMContext(containerTokenSecretManager);\n \n     this.aclsManager \u003d new ApplicationACLsManager(conf);\n \n     ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n         conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n           DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n     try {\n       exec.init();\n     } catch (IOException e) {\n       throw new YarnException(\"Failed to initialize container executor\", e);\n     }    \n     DeletionService del \u003d createDeletionService(exec);\n     addService(del);\n \n     // NodeManager level dispatcher\n     this.dispatcher \u003d new AsyncDispatcher();\n \n     nodeHealthChecker \u003d new NodeHealthCheckerService();\n     addService(nodeHealthChecker);\n     dirsHandler \u003d nodeHealthChecker.getDiskHandler();\n \n     NodeStatusUpdater nodeStatusUpdater \u003d\n         createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n \n     NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n     addService(nodeResourceMonitor);\n \n     containerManager \u003d\n         createContainerManager(context, exec, del, nodeStatusUpdater,\n         this.aclsManager, dirsHandler);\n     addService(containerManager);\n \n     Service webServer \u003d createWebServer(context, containerManager\n         .getContainersMonitor(), this.aclsManager, dirsHandler);\n     addService(webServer);\n \n     dispatcher.register(ContainerManagerEventType.class, containerManager);\n     dispatcher.register(NodeManagerEventType.class, this);\n     addService(dispatcher);\n     \n     DefaultMetricsSystem.initialize(\"NodeManager\");\n \n     // StatusUpdater should be added last so that it get started last \n     // so that we make sure everything is up before registering with RM. \n     addService(nodeStatusUpdater);\n     \n     waitForContainersOnShutdownMillis \u003d\n         conf.getLong(YarnConfiguration.NM_SLEEP_DELAY_BEFORE_SIGKILL_MS,\n             YarnConfiguration.DEFAULT_NM_SLEEP_DELAY_BEFORE_SIGKILL_MS) + \n         conf.getLong(YarnConfiguration.NM_PROCESS_KILL_WAIT_MS,\n             YarnConfiguration.DEFAULT_NM_PROCESS_KILL_WAIT_MS) +\n         SHUTDOWN_CLEANUP_SLOP_MS;\n     \n     super.init(conf);\n     // TODO add local dirs to del\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void init(Configuration conf) {\n\n    conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n\n    // Create the secretManager if need be.\n    NMContainerTokenSecretManager containerTokenSecretManager \u003d null;\n    if (UserGroupInformation.isSecurityEnabled()) {\n      LOG.info(\"Security is enabled on NodeManager. \"\n          + \"Creating ContainerTokenSecretManager\");\n      containerTokenSecretManager \u003d new NMContainerTokenSecretManager(conf);\n    }\n\n    this.context \u003d createNMContext(containerTokenSecretManager);\n\n    this.aclsManager \u003d new ApplicationACLsManager(conf);\n\n    ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n        conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n          DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n    try {\n      exec.init();\n    } catch (IOException e) {\n      throw new YarnException(\"Failed to initialize container executor\", e);\n    }    \n    DeletionService del \u003d createDeletionService(exec);\n    addService(del);\n\n    // NodeManager level dispatcher\n    this.dispatcher \u003d new AsyncDispatcher();\n\n    nodeHealthChecker \u003d new NodeHealthCheckerService();\n    addService(nodeHealthChecker);\n    dirsHandler \u003d nodeHealthChecker.getDiskHandler();\n\n    NodeStatusUpdater nodeStatusUpdater \u003d\n        createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n\n    NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n    addService(nodeResourceMonitor);\n\n    containerManager \u003d\n        createContainerManager(context, exec, del, nodeStatusUpdater,\n        this.aclsManager, dirsHandler);\n    addService(containerManager);\n\n    Service webServer \u003d createWebServer(context, containerManager\n        .getContainersMonitor(), this.aclsManager, dirsHandler);\n    addService(webServer);\n\n    dispatcher.register(ContainerManagerEventType.class, containerManager);\n    dispatcher.register(NodeManagerEventType.class, this);\n    addService(dispatcher);\n    \n    DefaultMetricsSystem.initialize(\"NodeManager\");\n\n    // StatusUpdater should be added last so that it get started last \n    // so that we make sure everything is up before registering with RM. \n    addService(nodeStatusUpdater);\n    \n    waitForContainersOnShutdownMillis \u003d\n        conf.getLong(YarnConfiguration.NM_SLEEP_DELAY_BEFORE_SIGKILL_MS,\n            YarnConfiguration.DEFAULT_NM_SLEEP_DELAY_BEFORE_SIGKILL_MS) + \n        conf.getLong(YarnConfiguration.NM_PROCESS_KILL_WAIT_MS,\n            YarnConfiguration.DEFAULT_NM_PROCESS_KILL_WAIT_MS) +\n        SHUTDOWN_CLEANUP_SLOP_MS;\n    \n    super.init(conf);\n    // TODO add local dirs to del\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java",
      "extendedDetails": {}
    },
    "6a482a88b8f56a4c5590e71ce6713d7f63830e92": {
      "type": "Ybodychange",
      "commitMessage": "YARN-71. Fix the NodeManager to clean up local-dirs on restart. Contributed by Xuan Gong.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1460808 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/03/13 11:23 AM",
      "commitName": "6a482a88b8f56a4c5590e71ce6713d7f63830e92",
      "commitAuthor": "Siddharth Seth",
      "commitDateOld": "12/03/13 9:24 PM",
      "commitNameOld": "44eb4c31b84e89356574c01c649a9d4545027d59",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 12.58,
      "commitsBetweenForRepo": 66,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,69 +1,69 @@\n   public void init(Configuration conf) {\n \n     conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n \n     // Create the secretManager if need be.\n     NMContainerTokenSecretManager containerTokenSecretManager \u003d null;\n     if (UserGroupInformation.isSecurityEnabled()) {\n       LOG.info(\"Security is enabled on NodeManager. \"\n           + \"Creating ContainerTokenSecretManager\");\n       containerTokenSecretManager \u003d new NMContainerTokenSecretManager(conf);\n     }\n \n     this.context \u003d new NMContext(containerTokenSecretManager);\n \n     this.aclsManager \u003d new ApplicationACLsManager(conf);\n \n     ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n         conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n           DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n     try {\n       exec.init();\n     } catch (IOException e) {\n       throw new YarnException(\"Failed to initialize container executor\", e);\n     }    \n-    DeletionService del \u003d new DeletionService(exec);\n+    DeletionService del \u003d createDeletionService(exec);\n     addService(del);\n \n     // NodeManager level dispatcher\n     this.dispatcher \u003d new AsyncDispatcher();\n \n     nodeHealthChecker \u003d new NodeHealthCheckerService();\n     addService(nodeHealthChecker);\n     dirsHandler \u003d nodeHealthChecker.getDiskHandler();\n \n     NodeStatusUpdater nodeStatusUpdater \u003d\n         createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n \n     NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n     addService(nodeResourceMonitor);\n \n     containerManager \u003d\n         createContainerManager(context, exec, del, nodeStatusUpdater,\n         this.aclsManager, dirsHandler);\n     addService(containerManager);\n \n     Service webServer \u003d createWebServer(context, containerManager\n         .getContainersMonitor(), this.aclsManager, dirsHandler);\n     addService(webServer);\n \n     dispatcher.register(ContainerManagerEventType.class, containerManager);\n     dispatcher.register(NodeManagerEventType.class, this);\n     addService(dispatcher);\n     \n     DefaultMetricsSystem.initialize(\"NodeManager\");\n \n     // StatusUpdater should be added last so that it get started last \n     // so that we make sure everything is up before registering with RM. \n     addService(nodeStatusUpdater);\n     \n     waitForContainersOnShutdownMillis \u003d\n         conf.getLong(YarnConfiguration.NM_SLEEP_DELAY_BEFORE_SIGKILL_MS,\n             YarnConfiguration.DEFAULT_NM_SLEEP_DELAY_BEFORE_SIGKILL_MS) + \n         conf.getLong(YarnConfiguration.NM_PROCESS_KILL_WAIT_MS,\n             YarnConfiguration.DEFAULT_NM_PROCESS_KILL_WAIT_MS) +\n         SHUTDOWN_CLEANUP_SLOP_MS;\n     \n     super.init(conf);\n     // TODO add local dirs to del\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void init(Configuration conf) {\n\n    conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n\n    // Create the secretManager if need be.\n    NMContainerTokenSecretManager containerTokenSecretManager \u003d null;\n    if (UserGroupInformation.isSecurityEnabled()) {\n      LOG.info(\"Security is enabled on NodeManager. \"\n          + \"Creating ContainerTokenSecretManager\");\n      containerTokenSecretManager \u003d new NMContainerTokenSecretManager(conf);\n    }\n\n    this.context \u003d new NMContext(containerTokenSecretManager);\n\n    this.aclsManager \u003d new ApplicationACLsManager(conf);\n\n    ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n        conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n          DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n    try {\n      exec.init();\n    } catch (IOException e) {\n      throw new YarnException(\"Failed to initialize container executor\", e);\n    }    \n    DeletionService del \u003d createDeletionService(exec);\n    addService(del);\n\n    // NodeManager level dispatcher\n    this.dispatcher \u003d new AsyncDispatcher();\n\n    nodeHealthChecker \u003d new NodeHealthCheckerService();\n    addService(nodeHealthChecker);\n    dirsHandler \u003d nodeHealthChecker.getDiskHandler();\n\n    NodeStatusUpdater nodeStatusUpdater \u003d\n        createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n\n    NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n    addService(nodeResourceMonitor);\n\n    containerManager \u003d\n        createContainerManager(context, exec, del, nodeStatusUpdater,\n        this.aclsManager, dirsHandler);\n    addService(containerManager);\n\n    Service webServer \u003d createWebServer(context, containerManager\n        .getContainersMonitor(), this.aclsManager, dirsHandler);\n    addService(webServer);\n\n    dispatcher.register(ContainerManagerEventType.class, containerManager);\n    dispatcher.register(NodeManagerEventType.class, this);\n    addService(dispatcher);\n    \n    DefaultMetricsSystem.initialize(\"NodeManager\");\n\n    // StatusUpdater should be added last so that it get started last \n    // so that we make sure everything is up before registering with RM. \n    addService(nodeStatusUpdater);\n    \n    waitForContainersOnShutdownMillis \u003d\n        conf.getLong(YarnConfiguration.NM_SLEEP_DELAY_BEFORE_SIGKILL_MS,\n            YarnConfiguration.DEFAULT_NM_SLEEP_DELAY_BEFORE_SIGKILL_MS) + \n        conf.getLong(YarnConfiguration.NM_PROCESS_KILL_WAIT_MS,\n            YarnConfiguration.DEFAULT_NM_PROCESS_KILL_WAIT_MS) +\n        SHUTDOWN_CLEANUP_SLOP_MS;\n    \n    super.init(conf);\n    // TODO add local dirs to del\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java",
      "extendedDetails": {}
    },
    "2cd41855d51fd18955a1ab187900ba02c6a6cfa9": {
      "type": "Ybodychange",
      "commitMessage": "YARN-170. Change NodeManager stop to be reentrant. Contributed by Sandy Ryza.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1429796 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/01/13 5:43 AM",
      "commitName": "2cd41855d51fd18955a1ab187900ba02c6a6cfa9",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "03/12/12 4:12 AM",
      "commitNameOld": "235749a8ab5f303b5b3a2993da8c5bea1818183b",
      "commitAuthorOld": "Thomas White",
      "daysBetweenCommits": 35.06,
      "commitsBetweenForRepo": 122,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,69 +1,69 @@\n   public void init(Configuration conf) {\n \n     conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n \n     // Create the secretManager if need be.\n     NMContainerTokenSecretManager containerTokenSecretManager \u003d null;\n     if (UserGroupInformation.isSecurityEnabled()) {\n       LOG.info(\"Security is enabled on NodeManager. \"\n           + \"Creating ContainerTokenSecretManager\");\n       containerTokenSecretManager \u003d new NMContainerTokenSecretManager(conf);\n     }\n \n     this.context \u003d new NMContext(containerTokenSecretManager);\n \n     this.aclsManager \u003d new ApplicationACLsManager(conf);\n \n     ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n         conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n           DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n     try {\n       exec.init();\n     } catch (IOException e) {\n       throw new YarnException(\"Failed to initialize container executor\", e);\n     }    \n     DeletionService del \u003d new DeletionService(exec);\n     addService(del);\n \n     // NodeManager level dispatcher\n     this.dispatcher \u003d new AsyncDispatcher();\n \n     nodeHealthChecker \u003d new NodeHealthCheckerService();\n     addService(nodeHealthChecker);\n     dirsHandler \u003d nodeHealthChecker.getDiskHandler();\n \n     NodeStatusUpdater nodeStatusUpdater \u003d\n         createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n-    nodeStatusUpdater.register(this);\n \n     NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n     addService(nodeResourceMonitor);\n \n     containerManager \u003d\n         createContainerManager(context, exec, del, nodeStatusUpdater,\n         this.aclsManager, dirsHandler);\n     addService(containerManager);\n \n     Service webServer \u003d createWebServer(context, containerManager\n         .getContainersMonitor(), this.aclsManager, dirsHandler);\n     addService(webServer);\n \n     dispatcher.register(ContainerManagerEventType.class, containerManager);\n+    dispatcher.register(NodeManagerEventType.class, this);\n     addService(dispatcher);\n     \n     DefaultMetricsSystem.initialize(\"NodeManager\");\n \n     // StatusUpdater should be added last so that it get started last \n     // so that we make sure everything is up before registering with RM. \n     addService(nodeStatusUpdater);\n     \n     waitForContainersOnShutdownMillis \u003d\n         conf.getLong(YarnConfiguration.NM_SLEEP_DELAY_BEFORE_SIGKILL_MS,\n             YarnConfiguration.DEFAULT_NM_SLEEP_DELAY_BEFORE_SIGKILL_MS) + \n         conf.getLong(YarnConfiguration.NM_PROCESS_KILL_WAIT_MS,\n             YarnConfiguration.DEFAULT_NM_PROCESS_KILL_WAIT_MS) +\n         SHUTDOWN_CLEANUP_SLOP_MS;\n     \n     super.init(conf);\n     // TODO add local dirs to del\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void init(Configuration conf) {\n\n    conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n\n    // Create the secretManager if need be.\n    NMContainerTokenSecretManager containerTokenSecretManager \u003d null;\n    if (UserGroupInformation.isSecurityEnabled()) {\n      LOG.info(\"Security is enabled on NodeManager. \"\n          + \"Creating ContainerTokenSecretManager\");\n      containerTokenSecretManager \u003d new NMContainerTokenSecretManager(conf);\n    }\n\n    this.context \u003d new NMContext(containerTokenSecretManager);\n\n    this.aclsManager \u003d new ApplicationACLsManager(conf);\n\n    ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n        conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n          DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n    try {\n      exec.init();\n    } catch (IOException e) {\n      throw new YarnException(\"Failed to initialize container executor\", e);\n    }    \n    DeletionService del \u003d new DeletionService(exec);\n    addService(del);\n\n    // NodeManager level dispatcher\n    this.dispatcher \u003d new AsyncDispatcher();\n\n    nodeHealthChecker \u003d new NodeHealthCheckerService();\n    addService(nodeHealthChecker);\n    dirsHandler \u003d nodeHealthChecker.getDiskHandler();\n\n    NodeStatusUpdater nodeStatusUpdater \u003d\n        createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n\n    NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n    addService(nodeResourceMonitor);\n\n    containerManager \u003d\n        createContainerManager(context, exec, del, nodeStatusUpdater,\n        this.aclsManager, dirsHandler);\n    addService(containerManager);\n\n    Service webServer \u003d createWebServer(context, containerManager\n        .getContainersMonitor(), this.aclsManager, dirsHandler);\n    addService(webServer);\n\n    dispatcher.register(ContainerManagerEventType.class, containerManager);\n    dispatcher.register(NodeManagerEventType.class, this);\n    addService(dispatcher);\n    \n    DefaultMetricsSystem.initialize(\"NodeManager\");\n\n    // StatusUpdater should be added last so that it get started last \n    // so that we make sure everything is up before registering with RM. \n    addService(nodeStatusUpdater);\n    \n    waitForContainersOnShutdownMillis \u003d\n        conf.getLong(YarnConfiguration.NM_SLEEP_DELAY_BEFORE_SIGKILL_MS,\n            YarnConfiguration.DEFAULT_NM_SLEEP_DELAY_BEFORE_SIGKILL_MS) + \n        conf.getLong(YarnConfiguration.NM_PROCESS_KILL_WAIT_MS,\n            YarnConfiguration.DEFAULT_NM_PROCESS_KILL_WAIT_MS) +\n        SHUTDOWN_CLEANUP_SLOP_MS;\n    \n    super.init(conf);\n    // TODO add local dirs to del\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java",
      "extendedDetails": {}
    },
    "235749a8ab5f303b5b3a2993da8c5bea1818183b": {
      "type": "Ybodychange",
      "commitMessage": "YARN-72. NM should handle cleaning up containers when it shuts down. Contributed by Sandy Ryza.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1416484 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/12/12 4:12 AM",
      "commitName": "235749a8ab5f303b5b3a2993da8c5bea1818183b",
      "commitAuthor": "Thomas White",
      "commitDateOld": "22/10/12 2:25 PM",
      "commitNameOld": "4da8e2613ec192bb0f29340cac0378bbadf15dde",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 41.62,
      "commitsBetweenForRepo": 201,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,62 +1,69 @@\n   public void init(Configuration conf) {\n \n     conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n \n     // Create the secretManager if need be.\n     NMContainerTokenSecretManager containerTokenSecretManager \u003d null;\n     if (UserGroupInformation.isSecurityEnabled()) {\n       LOG.info(\"Security is enabled on NodeManager. \"\n           + \"Creating ContainerTokenSecretManager\");\n       containerTokenSecretManager \u003d new NMContainerTokenSecretManager(conf);\n     }\n \n-    Context context \u003d new NMContext(containerTokenSecretManager);\n+    this.context \u003d new NMContext(containerTokenSecretManager);\n \n     this.aclsManager \u003d new ApplicationACLsManager(conf);\n \n     ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n         conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n           DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n     try {\n       exec.init();\n     } catch (IOException e) {\n       throw new YarnException(\"Failed to initialize container executor\", e);\n     }    \n     DeletionService del \u003d new DeletionService(exec);\n     addService(del);\n \n     // NodeManager level dispatcher\n-    AsyncDispatcher dispatcher \u003d new AsyncDispatcher();\n+    this.dispatcher \u003d new AsyncDispatcher();\n \n     nodeHealthChecker \u003d new NodeHealthCheckerService();\n     addService(nodeHealthChecker);\n     dirsHandler \u003d nodeHealthChecker.getDiskHandler();\n \n     NodeStatusUpdater nodeStatusUpdater \u003d\n         createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n     nodeStatusUpdater.register(this);\n \n     NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n     addService(nodeResourceMonitor);\n \n-    ContainerManagerImpl containerManager \u003d\n+    containerManager \u003d\n         createContainerManager(context, exec, del, nodeStatusUpdater,\n         this.aclsManager, dirsHandler);\n     addService(containerManager);\n \n     Service webServer \u003d createWebServer(context, containerManager\n         .getContainersMonitor(), this.aclsManager, dirsHandler);\n     addService(webServer);\n \n     dispatcher.register(ContainerManagerEventType.class, containerManager);\n     addService(dispatcher);\n-\n+    \n     DefaultMetricsSystem.initialize(\"NodeManager\");\n \n     // StatusUpdater should be added last so that it get started last \n     // so that we make sure everything is up before registering with RM. \n     addService(nodeStatusUpdater);\n-\n+    \n+    waitForContainersOnShutdownMillis \u003d\n+        conf.getLong(YarnConfiguration.NM_SLEEP_DELAY_BEFORE_SIGKILL_MS,\n+            YarnConfiguration.DEFAULT_NM_SLEEP_DELAY_BEFORE_SIGKILL_MS) + \n+        conf.getLong(YarnConfiguration.NM_PROCESS_KILL_WAIT_MS,\n+            YarnConfiguration.DEFAULT_NM_PROCESS_KILL_WAIT_MS) +\n+        SHUTDOWN_CLEANUP_SLOP_MS;\n+    \n     super.init(conf);\n     // TODO add local dirs to del\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void init(Configuration conf) {\n\n    conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n\n    // Create the secretManager if need be.\n    NMContainerTokenSecretManager containerTokenSecretManager \u003d null;\n    if (UserGroupInformation.isSecurityEnabled()) {\n      LOG.info(\"Security is enabled on NodeManager. \"\n          + \"Creating ContainerTokenSecretManager\");\n      containerTokenSecretManager \u003d new NMContainerTokenSecretManager(conf);\n    }\n\n    this.context \u003d new NMContext(containerTokenSecretManager);\n\n    this.aclsManager \u003d new ApplicationACLsManager(conf);\n\n    ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n        conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n          DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n    try {\n      exec.init();\n    } catch (IOException e) {\n      throw new YarnException(\"Failed to initialize container executor\", e);\n    }    \n    DeletionService del \u003d new DeletionService(exec);\n    addService(del);\n\n    // NodeManager level dispatcher\n    this.dispatcher \u003d new AsyncDispatcher();\n\n    nodeHealthChecker \u003d new NodeHealthCheckerService();\n    addService(nodeHealthChecker);\n    dirsHandler \u003d nodeHealthChecker.getDiskHandler();\n\n    NodeStatusUpdater nodeStatusUpdater \u003d\n        createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n    nodeStatusUpdater.register(this);\n\n    NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n    addService(nodeResourceMonitor);\n\n    containerManager \u003d\n        createContainerManager(context, exec, del, nodeStatusUpdater,\n        this.aclsManager, dirsHandler);\n    addService(containerManager);\n\n    Service webServer \u003d createWebServer(context, containerManager\n        .getContainersMonitor(), this.aclsManager, dirsHandler);\n    addService(webServer);\n\n    dispatcher.register(ContainerManagerEventType.class, containerManager);\n    addService(dispatcher);\n    \n    DefaultMetricsSystem.initialize(\"NodeManager\");\n\n    // StatusUpdater should be added last so that it get started last \n    // so that we make sure everything is up before registering with RM. \n    addService(nodeStatusUpdater);\n    \n    waitForContainersOnShutdownMillis \u003d\n        conf.getLong(YarnConfiguration.NM_SLEEP_DELAY_BEFORE_SIGKILL_MS,\n            YarnConfiguration.DEFAULT_NM_SLEEP_DELAY_BEFORE_SIGKILL_MS) + \n        conf.getLong(YarnConfiguration.NM_PROCESS_KILL_WAIT_MS,\n            YarnConfiguration.DEFAULT_NM_PROCESS_KILL_WAIT_MS) +\n        SHUTDOWN_CLEANUP_SLOP_MS;\n    \n    super.init(conf);\n    // TODO add local dirs to del\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java",
      "extendedDetails": {}
    },
    "ffd2e01604be814fa3db1dded7cd7cff26a79b1e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-39. RM-NM secret-keys should be randomly generated and rolled every so often. (Contributed by Vinod Kumar Vavilapalli and Siddharth Seth)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1377180 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/12 7:18 PM",
      "commitName": "ffd2e01604be814fa3db1dded7cd7cff26a79b1e",
      "commitAuthor": "Siddharth Seth",
      "commitDateOld": "07/08/12 10:22 PM",
      "commitNameOld": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 16.87,
      "commitsBetweenForRepo": 114,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,61 +1,62 @@\n   public void init(Configuration conf) {\n \n     conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n \n-    Context context \u003d new NMContext();\n-\n     // Create the secretManager if need be.\n+    NMContainerTokenSecretManager containerTokenSecretManager \u003d null;\n     if (UserGroupInformation.isSecurityEnabled()) {\n       LOG.info(\"Security is enabled on NodeManager. \"\n           + \"Creating ContainerTokenSecretManager\");\n-      this.containerTokenSecretManager \u003d new ContainerTokenSecretManager(conf);\n+      containerTokenSecretManager \u003d new NMContainerTokenSecretManager(conf);\n     }\n \n+    Context context \u003d new NMContext(containerTokenSecretManager);\n+\n     this.aclsManager \u003d new ApplicationACLsManager(conf);\n \n     ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n         conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n           DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n     try {\n       exec.init();\n     } catch (IOException e) {\n       throw new YarnException(\"Failed to initialize container executor\", e);\n     }    \n     DeletionService del \u003d new DeletionService(exec);\n     addService(del);\n \n     // NodeManager level dispatcher\n     AsyncDispatcher dispatcher \u003d new AsyncDispatcher();\n \n     nodeHealthChecker \u003d new NodeHealthCheckerService();\n     addService(nodeHealthChecker);\n     dirsHandler \u003d nodeHealthChecker.getDiskHandler();\n \n-    NodeStatusUpdater nodeStatusUpdater \u003d createNodeStatusUpdater(context,\n-        dispatcher, nodeHealthChecker, this.containerTokenSecretManager);\n+    NodeStatusUpdater nodeStatusUpdater \u003d\n+        createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n     nodeStatusUpdater.register(this);\n \n     NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n     addService(nodeResourceMonitor);\n \n     ContainerManagerImpl containerManager \u003d\n         createContainerManager(context, exec, del, nodeStatusUpdater,\n-        this.containerTokenSecretManager, this.aclsManager, dirsHandler);\n+        this.aclsManager, dirsHandler);\n     addService(containerManager);\n \n     Service webServer \u003d createWebServer(context, containerManager\n         .getContainersMonitor(), this.aclsManager, dirsHandler);\n     addService(webServer);\n \n     dispatcher.register(ContainerManagerEventType.class, containerManager);\n     addService(dispatcher);\n \n     DefaultMetricsSystem.initialize(\"NodeManager\");\n \n     // StatusUpdater should be added last so that it get started last \n     // so that we make sure everything is up before registering with RM. \n     addService(nodeStatusUpdater);\n \n     super.init(conf);\n     // TODO add local dirs to del\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void init(Configuration conf) {\n\n    conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n\n    // Create the secretManager if need be.\n    NMContainerTokenSecretManager containerTokenSecretManager \u003d null;\n    if (UserGroupInformation.isSecurityEnabled()) {\n      LOG.info(\"Security is enabled on NodeManager. \"\n          + \"Creating ContainerTokenSecretManager\");\n      containerTokenSecretManager \u003d new NMContainerTokenSecretManager(conf);\n    }\n\n    Context context \u003d new NMContext(containerTokenSecretManager);\n\n    this.aclsManager \u003d new ApplicationACLsManager(conf);\n\n    ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n        conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n          DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n    try {\n      exec.init();\n    } catch (IOException e) {\n      throw new YarnException(\"Failed to initialize container executor\", e);\n    }    \n    DeletionService del \u003d new DeletionService(exec);\n    addService(del);\n\n    // NodeManager level dispatcher\n    AsyncDispatcher dispatcher \u003d new AsyncDispatcher();\n\n    nodeHealthChecker \u003d new NodeHealthCheckerService();\n    addService(nodeHealthChecker);\n    dirsHandler \u003d nodeHealthChecker.getDiskHandler();\n\n    NodeStatusUpdater nodeStatusUpdater \u003d\n        createNodeStatusUpdater(context, dispatcher, nodeHealthChecker);\n    nodeStatusUpdater.register(this);\n\n    NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n    addService(nodeResourceMonitor);\n\n    ContainerManagerImpl containerManager \u003d\n        createContainerManager(context, exec, del, nodeStatusUpdater,\n        this.aclsManager, dirsHandler);\n    addService(containerManager);\n\n    Service webServer \u003d createWebServer(context, containerManager\n        .getContainersMonitor(), this.aclsManager, dirsHandler);\n    addService(webServer);\n\n    dispatcher.register(ContainerManagerEventType.class, containerManager);\n    addService(dispatcher);\n\n    DefaultMetricsSystem.initialize(\"NodeManager\");\n\n    // StatusUpdater should be added last so that it get started last \n    // so that we make sure everything is up before registering with RM. \n    addService(nodeStatusUpdater);\n\n    super.init(conf);\n    // TODO add local dirs to del\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java",
      "extendedDetails": {}
    },
    "e1fdf62123625e4ba399af02f8aad500637d29d1": {
      "type": "Yfilerename",
      "commitMessage": "YARN-1. Promote YARN to be a sub-project of Apache Hadoop.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1370666 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/08/12 10:22 PM",
      "commitName": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "07/08/12 7:53 PM",
      "commitNameOld": "34554d1e11ee1d5b564d7d9ed3e6d55931d72749",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public void init(Configuration conf) {\n\n    conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n\n    Context context \u003d new NMContext();\n\n    // Create the secretManager if need be.\n    if (UserGroupInformation.isSecurityEnabled()) {\n      LOG.info(\"Security is enabled on NodeManager. \"\n          + \"Creating ContainerTokenSecretManager\");\n      this.containerTokenSecretManager \u003d new ContainerTokenSecretManager(conf);\n    }\n\n    this.aclsManager \u003d new ApplicationACLsManager(conf);\n\n    ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n        conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n          DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n    try {\n      exec.init();\n    } catch (IOException e) {\n      throw new YarnException(\"Failed to initialize container executor\", e);\n    }    \n    DeletionService del \u003d new DeletionService(exec);\n    addService(del);\n\n    // NodeManager level dispatcher\n    AsyncDispatcher dispatcher \u003d new AsyncDispatcher();\n\n    nodeHealthChecker \u003d new NodeHealthCheckerService();\n    addService(nodeHealthChecker);\n    dirsHandler \u003d nodeHealthChecker.getDiskHandler();\n\n    NodeStatusUpdater nodeStatusUpdater \u003d createNodeStatusUpdater(context,\n        dispatcher, nodeHealthChecker, this.containerTokenSecretManager);\n    nodeStatusUpdater.register(this);\n\n    NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n    addService(nodeResourceMonitor);\n\n    ContainerManagerImpl containerManager \u003d\n        createContainerManager(context, exec, del, nodeStatusUpdater,\n        this.containerTokenSecretManager, this.aclsManager, dirsHandler);\n    addService(containerManager);\n\n    Service webServer \u003d createWebServer(context, containerManager\n        .getContainersMonitor(), this.aclsManager, dirsHandler);\n    addService(webServer);\n\n    dispatcher.register(ContainerManagerEventType.class, containerManager);\n    addService(dispatcher);\n\n    DefaultMetricsSystem.initialize(\"NodeManager\");\n\n    // StatusUpdater should be added last so that it get started last \n    // so that we make sure everything is up before registering with RM. \n    addService(nodeStatusUpdater);\n\n    super.init(conf);\n    // TODO add local dirs to del\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java"
      }
    },
    "3bfb26ad3b5ac46f992a632541c97ca2bc897638": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3940. ContainerTokens should have an expiry interval. Contributed by Siddharth Seth and Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1359910 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/07/12 2:26 PM",
      "commitName": "3bfb26ad3b5ac46f992a632541c97ca2bc897638",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "09/07/12 2:08 PM",
      "commitNameOld": "11782dd3a5ee5a2f6ad42b335f0386d00baa9ae1",
      "commitAuthorOld": "Thomas Graves",
      "daysBetweenCommits": 1.01,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,61 +1,61 @@\n   public void init(Configuration conf) {\n \n     conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n \n     Context context \u003d new NMContext();\n \n     // Create the secretManager if need be.\n     if (UserGroupInformation.isSecurityEnabled()) {\n       LOG.info(\"Security is enabled on NodeManager. \"\n           + \"Creating ContainerTokenSecretManager\");\n-      this.containerTokenSecretManager \u003d new ContainerTokenSecretManager();\n+      this.containerTokenSecretManager \u003d new ContainerTokenSecretManager(conf);\n     }\n \n     this.aclsManager \u003d new ApplicationACLsManager(conf);\n \n     ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n         conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n           DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n     try {\n       exec.init();\n     } catch (IOException e) {\n       throw new YarnException(\"Failed to initialize container executor\", e);\n     }    \n     DeletionService del \u003d new DeletionService(exec);\n     addService(del);\n \n     // NodeManager level dispatcher\n     AsyncDispatcher dispatcher \u003d new AsyncDispatcher();\n \n     nodeHealthChecker \u003d new NodeHealthCheckerService();\n     addService(nodeHealthChecker);\n     dirsHandler \u003d nodeHealthChecker.getDiskHandler();\n \n     NodeStatusUpdater nodeStatusUpdater \u003d createNodeStatusUpdater(context,\n         dispatcher, nodeHealthChecker, this.containerTokenSecretManager);\n     nodeStatusUpdater.register(this);\n \n     NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n     addService(nodeResourceMonitor);\n \n     ContainerManagerImpl containerManager \u003d\n         createContainerManager(context, exec, del, nodeStatusUpdater,\n         this.containerTokenSecretManager, this.aclsManager, dirsHandler);\n     addService(containerManager);\n \n     Service webServer \u003d createWebServer(context, containerManager\n         .getContainersMonitor(), this.aclsManager, dirsHandler);\n     addService(webServer);\n \n     dispatcher.register(ContainerManagerEventType.class, containerManager);\n     addService(dispatcher);\n \n     DefaultMetricsSystem.initialize(\"NodeManager\");\n \n     // StatusUpdater should be added last so that it get started last \n     // so that we make sure everything is up before registering with RM. \n     addService(nodeStatusUpdater);\n \n     super.init(conf);\n     // TODO add local dirs to del\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void init(Configuration conf) {\n\n    conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n\n    Context context \u003d new NMContext();\n\n    // Create the secretManager if need be.\n    if (UserGroupInformation.isSecurityEnabled()) {\n      LOG.info(\"Security is enabled on NodeManager. \"\n          + \"Creating ContainerTokenSecretManager\");\n      this.containerTokenSecretManager \u003d new ContainerTokenSecretManager(conf);\n    }\n\n    this.aclsManager \u003d new ApplicationACLsManager(conf);\n\n    ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n        conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n          DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n    try {\n      exec.init();\n    } catch (IOException e) {\n      throw new YarnException(\"Failed to initialize container executor\", e);\n    }    \n    DeletionService del \u003d new DeletionService(exec);\n    addService(del);\n\n    // NodeManager level dispatcher\n    AsyncDispatcher dispatcher \u003d new AsyncDispatcher();\n\n    nodeHealthChecker \u003d new NodeHealthCheckerService();\n    addService(nodeHealthChecker);\n    dirsHandler \u003d nodeHealthChecker.getDiskHandler();\n\n    NodeStatusUpdater nodeStatusUpdater \u003d createNodeStatusUpdater(context,\n        dispatcher, nodeHealthChecker, this.containerTokenSecretManager);\n    nodeStatusUpdater.register(this);\n\n    NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n    addService(nodeResourceMonitor);\n\n    ContainerManagerImpl containerManager \u003d\n        createContainerManager(context, exec, del, nodeStatusUpdater,\n        this.containerTokenSecretManager, this.aclsManager, dirsHandler);\n    addService(containerManager);\n\n    Service webServer \u003d createWebServer(context, containerManager\n        .getContainersMonitor(), this.aclsManager, dirsHandler);\n    addService(webServer);\n\n    dispatcher.register(ContainerManagerEventType.class, containerManager);\n    addService(dispatcher);\n\n    DefaultMetricsSystem.initialize(\"NodeManager\");\n\n    // StatusUpdater should be added last so that it get started last \n    // so that we make sure everything is up before registering with RM. \n    addService(nodeStatusUpdater);\n\n    super.init(conf);\n    // TODO add local dirs to del\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java",
      "extendedDetails": {}
    },
    "5ee495e6f34faff231ad87ec890188eb63617393": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3634. Fixed all daemons to crash instead of hanging around when their EventHandlers get exceptions. (vinodkv)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1291598 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "20/02/12 9:08 PM",
      "commitName": "5ee495e6f34faff231ad87ec890188eb63617393",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "29/11/11 3:17 PM",
      "commitNameOld": "ea17da82f7fc4b7fcc05bba82d141e27289fd7cb",
      "commitAuthorOld": "Mahadev Konar",
      "daysBetweenCommits": 83.24,
      "commitsBetweenForRepo": 471,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,59 +1,61 @@\n   public void init(Configuration conf) {\n \n+    conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n+\n     Context context \u003d new NMContext();\n \n     // Create the secretManager if need be.\n     if (UserGroupInformation.isSecurityEnabled()) {\n       LOG.info(\"Security is enabled on NodeManager. \"\n           + \"Creating ContainerTokenSecretManager\");\n       this.containerTokenSecretManager \u003d new ContainerTokenSecretManager();\n     }\n \n     this.aclsManager \u003d new ApplicationACLsManager(conf);\n \n     ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n         conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n           DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n     try {\n       exec.init();\n     } catch (IOException e) {\n       throw new YarnException(\"Failed to initialize container executor\", e);\n     }    \n     DeletionService del \u003d new DeletionService(exec);\n     addService(del);\n \n     // NodeManager level dispatcher\n     AsyncDispatcher dispatcher \u003d new AsyncDispatcher();\n \n     nodeHealthChecker \u003d new NodeHealthCheckerService();\n     addService(nodeHealthChecker);\n     dirsHandler \u003d nodeHealthChecker.getDiskHandler();\n \n     NodeStatusUpdater nodeStatusUpdater \u003d createNodeStatusUpdater(context,\n         dispatcher, nodeHealthChecker, this.containerTokenSecretManager);\n     nodeStatusUpdater.register(this);\n \n     NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n     addService(nodeResourceMonitor);\n \n     ContainerManagerImpl containerManager \u003d\n         createContainerManager(context, exec, del, nodeStatusUpdater,\n         this.containerTokenSecretManager, this.aclsManager, dirsHandler);\n     addService(containerManager);\n \n     Service webServer \u003d createWebServer(context, containerManager\n         .getContainersMonitor(), this.aclsManager, dirsHandler);\n     addService(webServer);\n \n     dispatcher.register(ContainerManagerEventType.class, containerManager);\n     addService(dispatcher);\n \n     DefaultMetricsSystem.initialize(\"NodeManager\");\n \n     // StatusUpdater should be added last so that it get started last \n     // so that we make sure everything is up before registering with RM. \n     addService(nodeStatusUpdater);\n \n     super.init(conf);\n     // TODO add local dirs to del\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void init(Configuration conf) {\n\n    conf.setBoolean(Dispatcher.DISPATCHER_EXIT_ON_ERROR_KEY, true);\n\n    Context context \u003d new NMContext();\n\n    // Create the secretManager if need be.\n    if (UserGroupInformation.isSecurityEnabled()) {\n      LOG.info(\"Security is enabled on NodeManager. \"\n          + \"Creating ContainerTokenSecretManager\");\n      this.containerTokenSecretManager \u003d new ContainerTokenSecretManager();\n    }\n\n    this.aclsManager \u003d new ApplicationACLsManager(conf);\n\n    ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n        conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n          DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n    try {\n      exec.init();\n    } catch (IOException e) {\n      throw new YarnException(\"Failed to initialize container executor\", e);\n    }    \n    DeletionService del \u003d new DeletionService(exec);\n    addService(del);\n\n    // NodeManager level dispatcher\n    AsyncDispatcher dispatcher \u003d new AsyncDispatcher();\n\n    nodeHealthChecker \u003d new NodeHealthCheckerService();\n    addService(nodeHealthChecker);\n    dirsHandler \u003d nodeHealthChecker.getDiskHandler();\n\n    NodeStatusUpdater nodeStatusUpdater \u003d createNodeStatusUpdater(context,\n        dispatcher, nodeHealthChecker, this.containerTokenSecretManager);\n    nodeStatusUpdater.register(this);\n\n    NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n    addService(nodeResourceMonitor);\n\n    ContainerManagerImpl containerManager \u003d\n        createContainerManager(context, exec, del, nodeStatusUpdater,\n        this.containerTokenSecretManager, this.aclsManager, dirsHandler);\n    addService(containerManager);\n\n    Service webServer \u003d createWebServer(context, containerManager\n        .getContainersMonitor(), this.aclsManager, dirsHandler);\n    addService(webServer);\n\n    dispatcher.register(ContainerManagerEventType.class, containerManager);\n    addService(dispatcher);\n\n    DefaultMetricsSystem.initialize(\"NodeManager\");\n\n    // StatusUpdater should be added last so that it get started last \n    // so that we make sure everything is up before registering with RM. \n    addService(nodeStatusUpdater);\n\n    super.init(conf);\n    // TODO add local dirs to del\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java",
      "extendedDetails": {}
    },
    "ea17da82f7fc4b7fcc05bba82d141e27289fd7cb": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3121. NodeManager should handle disk-failures (Ravi Gummadi via mahadev)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1208131 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/11/11 3:17 PM",
      "commitName": "ea17da82f7fc4b7fcc05bba82d141e27289fd7cb",
      "commitAuthor": "Mahadev Konar",
      "commitDateOld": "15/11/11 2:30 AM",
      "commitNameOld": "c56e05196190f172e9c8cdcd9d59d09950f1419b",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 14.53,
      "commitsBetweenForRepo": 77,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,63 +1,59 @@\n   public void init(Configuration conf) {\n \n     Context context \u003d new NMContext();\n \n     // Create the secretManager if need be.\n     if (UserGroupInformation.isSecurityEnabled()) {\n       LOG.info(\"Security is enabled on NodeManager. \"\n           + \"Creating ContainerTokenSecretManager\");\n       this.containerTokenSecretManager \u003d new ContainerTokenSecretManager();\n     }\n \n     this.aclsManager \u003d new ApplicationACLsManager(conf);\n \n     ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n         conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n           DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n     try {\n       exec.init();\n     } catch (IOException e) {\n       throw new YarnException(\"Failed to initialize container executor\", e);\n     }    \n     DeletionService del \u003d new DeletionService(exec);\n     addService(del);\n \n     // NodeManager level dispatcher\n     AsyncDispatcher dispatcher \u003d new AsyncDispatcher();\n \n-    NodeHealthCheckerService healthChecker \u003d null;\n-    if (NodeHealthCheckerService.shouldRun(conf)) {\n-      healthChecker \u003d new NodeHealthCheckerService();\n-      addService(healthChecker);\n-    }\n+    nodeHealthChecker \u003d new NodeHealthCheckerService();\n+    addService(nodeHealthChecker);\n+    dirsHandler \u003d nodeHealthChecker.getDiskHandler();\n \n-    NodeStatusUpdater nodeStatusUpdater \u003d\n-        createNodeStatusUpdater(context, dispatcher, healthChecker, \n-        this.containerTokenSecretManager);\n-    \n+    NodeStatusUpdater nodeStatusUpdater \u003d createNodeStatusUpdater(context,\n+        dispatcher, nodeHealthChecker, this.containerTokenSecretManager);\n     nodeStatusUpdater.register(this);\n \n     NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n     addService(nodeResourceMonitor);\n \n     ContainerManagerImpl containerManager \u003d\n         createContainerManager(context, exec, del, nodeStatusUpdater,\n-        this.containerTokenSecretManager, this.aclsManager);\n+        this.containerTokenSecretManager, this.aclsManager, dirsHandler);\n     addService(containerManager);\n \n     Service webServer \u003d createWebServer(context, containerManager\n-        .getContainersMonitor(), this.aclsManager);\n+        .getContainersMonitor(), this.aclsManager, dirsHandler);\n     addService(webServer);\n \n     dispatcher.register(ContainerManagerEventType.class, containerManager);\n     addService(dispatcher);\n \n     DefaultMetricsSystem.initialize(\"NodeManager\");\n \n     // StatusUpdater should be added last so that it get started last \n     // so that we make sure everything is up before registering with RM. \n     addService(nodeStatusUpdater);\n \n     super.init(conf);\n     // TODO add local dirs to del\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void init(Configuration conf) {\n\n    Context context \u003d new NMContext();\n\n    // Create the secretManager if need be.\n    if (UserGroupInformation.isSecurityEnabled()) {\n      LOG.info(\"Security is enabled on NodeManager. \"\n          + \"Creating ContainerTokenSecretManager\");\n      this.containerTokenSecretManager \u003d new ContainerTokenSecretManager();\n    }\n\n    this.aclsManager \u003d new ApplicationACLsManager(conf);\n\n    ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n        conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n          DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n    try {\n      exec.init();\n    } catch (IOException e) {\n      throw new YarnException(\"Failed to initialize container executor\", e);\n    }    \n    DeletionService del \u003d new DeletionService(exec);\n    addService(del);\n\n    // NodeManager level dispatcher\n    AsyncDispatcher dispatcher \u003d new AsyncDispatcher();\n\n    nodeHealthChecker \u003d new NodeHealthCheckerService();\n    addService(nodeHealthChecker);\n    dirsHandler \u003d nodeHealthChecker.getDiskHandler();\n\n    NodeStatusUpdater nodeStatusUpdater \u003d createNodeStatusUpdater(context,\n        dispatcher, nodeHealthChecker, this.containerTokenSecretManager);\n    nodeStatusUpdater.register(this);\n\n    NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n    addService(nodeResourceMonitor);\n\n    ContainerManagerImpl containerManager \u003d\n        createContainerManager(context, exec, del, nodeStatusUpdater,\n        this.containerTokenSecretManager, this.aclsManager, dirsHandler);\n    addService(containerManager);\n\n    Service webServer \u003d createWebServer(context, containerManager\n        .getContainersMonitor(), this.aclsManager, dirsHandler);\n    addService(webServer);\n\n    dispatcher.register(ContainerManagerEventType.class, containerManager);\n    addService(dispatcher);\n\n    DefaultMetricsSystem.initialize(\"NodeManager\");\n\n    // StatusUpdater should be added last so that it get started last \n    // so that we make sure everything is up before registering with RM. \n    addService(nodeStatusUpdater);\n\n    super.init(conf);\n    // TODO add local dirs to del\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java",
      "extendedDetails": {}
    },
    "c56e05196190f172e9c8cdcd9d59d09950f1419b": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3102. Changed NodeManager to fail fast when LinuxContainerExecutor has wrong configuration or permissions. Contributed by Hitesh Shah.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1202117 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "15/11/11 2:30 AM",
      "commitName": "c56e05196190f172e9c8cdcd9d59d09950f1419b",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "28/10/11 10:31 AM",
      "commitNameOld": "cbdb07f4ca358b9507296868a913977ad82ed716",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 17.71,
      "commitsBetweenForRepo": 105,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,58 +1,63 @@\n   public void init(Configuration conf) {\n \n     Context context \u003d new NMContext();\n \n     // Create the secretManager if need be.\n     if (UserGroupInformation.isSecurityEnabled()) {\n       LOG.info(\"Security is enabled on NodeManager. \"\n           + \"Creating ContainerTokenSecretManager\");\n       this.containerTokenSecretManager \u003d new ContainerTokenSecretManager();\n     }\n \n     this.aclsManager \u003d new ApplicationACLsManager(conf);\n \n     ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n         conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n           DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n+    try {\n+      exec.init();\n+    } catch (IOException e) {\n+      throw new YarnException(\"Failed to initialize container executor\", e);\n+    }    \n     DeletionService del \u003d new DeletionService(exec);\n     addService(del);\n \n     // NodeManager level dispatcher\n     AsyncDispatcher dispatcher \u003d new AsyncDispatcher();\n \n     NodeHealthCheckerService healthChecker \u003d null;\n     if (NodeHealthCheckerService.shouldRun(conf)) {\n       healthChecker \u003d new NodeHealthCheckerService();\n       addService(healthChecker);\n     }\n \n     NodeStatusUpdater nodeStatusUpdater \u003d\n         createNodeStatusUpdater(context, dispatcher, healthChecker, \n         this.containerTokenSecretManager);\n     \n     nodeStatusUpdater.register(this);\n \n     NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n     addService(nodeResourceMonitor);\n \n     ContainerManagerImpl containerManager \u003d\n         createContainerManager(context, exec, del, nodeStatusUpdater,\n         this.containerTokenSecretManager, this.aclsManager);\n     addService(containerManager);\n \n     Service webServer \u003d createWebServer(context, containerManager\n         .getContainersMonitor(), this.aclsManager);\n     addService(webServer);\n \n     dispatcher.register(ContainerManagerEventType.class, containerManager);\n     addService(dispatcher);\n \n     DefaultMetricsSystem.initialize(\"NodeManager\");\n \n     // StatusUpdater should be added last so that it get started last \n     // so that we make sure everything is up before registering with RM. \n     addService(nodeStatusUpdater);\n \n     super.init(conf);\n     // TODO add local dirs to del\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void init(Configuration conf) {\n\n    Context context \u003d new NMContext();\n\n    // Create the secretManager if need be.\n    if (UserGroupInformation.isSecurityEnabled()) {\n      LOG.info(\"Security is enabled on NodeManager. \"\n          + \"Creating ContainerTokenSecretManager\");\n      this.containerTokenSecretManager \u003d new ContainerTokenSecretManager();\n    }\n\n    this.aclsManager \u003d new ApplicationACLsManager(conf);\n\n    ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n        conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n          DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n    try {\n      exec.init();\n    } catch (IOException e) {\n      throw new YarnException(\"Failed to initialize container executor\", e);\n    }    \n    DeletionService del \u003d new DeletionService(exec);\n    addService(del);\n\n    // NodeManager level dispatcher\n    AsyncDispatcher dispatcher \u003d new AsyncDispatcher();\n\n    NodeHealthCheckerService healthChecker \u003d null;\n    if (NodeHealthCheckerService.shouldRun(conf)) {\n      healthChecker \u003d new NodeHealthCheckerService();\n      addService(healthChecker);\n    }\n\n    NodeStatusUpdater nodeStatusUpdater \u003d\n        createNodeStatusUpdater(context, dispatcher, healthChecker, \n        this.containerTokenSecretManager);\n    \n    nodeStatusUpdater.register(this);\n\n    NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n    addService(nodeResourceMonitor);\n\n    ContainerManagerImpl containerManager \u003d\n        createContainerManager(context, exec, del, nodeStatusUpdater,\n        this.containerTokenSecretManager, this.aclsManager);\n    addService(containerManager);\n\n    Service webServer \u003d createWebServer(context, containerManager\n        .getContainersMonitor(), this.aclsManager);\n    addService(webServer);\n\n    dispatcher.register(ContainerManagerEventType.class, containerManager);\n    addService(dispatcher);\n\n    DefaultMetricsSystem.initialize(\"NodeManager\");\n\n    // StatusUpdater should be added last so that it get started last \n    // so that we make sure everything is up before registering with RM. \n    addService(nodeStatusUpdater);\n\n    super.init(conf);\n    // TODO add local dirs to del\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java",
      "extendedDetails": {}
    },
    "cbdb07f4ca358b9507296868a913977ad82ed716": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2775. Fixed ResourceManager and NodeManager to force a decommissioned node to shutdown. Contributed by Devaraj K.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1190467 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "28/10/11 10:31 AM",
      "commitName": "cbdb07f4ca358b9507296868a913977ad82ed716",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "20/10/11 4:45 AM",
      "commitNameOld": "df2991c0cbc3f35c2640b93680667507c4f810dd",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 8.24,
      "commitsBetweenForRepo": 92,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,56 +1,58 @@\n   public void init(Configuration conf) {\n \n     Context context \u003d new NMContext();\n \n     // Create the secretManager if need be.\n     if (UserGroupInformation.isSecurityEnabled()) {\n       LOG.info(\"Security is enabled on NodeManager. \"\n           + \"Creating ContainerTokenSecretManager\");\n       this.containerTokenSecretManager \u003d new ContainerTokenSecretManager();\n     }\n \n     this.aclsManager \u003d new ApplicationACLsManager(conf);\n \n     ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n         conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n           DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n     DeletionService del \u003d new DeletionService(exec);\n     addService(del);\n \n     // NodeManager level dispatcher\n     AsyncDispatcher dispatcher \u003d new AsyncDispatcher();\n \n     NodeHealthCheckerService healthChecker \u003d null;\n     if (NodeHealthCheckerService.shouldRun(conf)) {\n       healthChecker \u003d new NodeHealthCheckerService();\n       addService(healthChecker);\n     }\n \n     NodeStatusUpdater nodeStatusUpdater \u003d\n         createNodeStatusUpdater(context, dispatcher, healthChecker, \n         this.containerTokenSecretManager);\n+    \n+    nodeStatusUpdater.register(this);\n \n     NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n     addService(nodeResourceMonitor);\n \n     ContainerManagerImpl containerManager \u003d\n         createContainerManager(context, exec, del, nodeStatusUpdater,\n         this.containerTokenSecretManager, this.aclsManager);\n     addService(containerManager);\n \n     Service webServer \u003d createWebServer(context, containerManager\n         .getContainersMonitor(), this.aclsManager);\n     addService(webServer);\n \n     dispatcher.register(ContainerManagerEventType.class, containerManager);\n     addService(dispatcher);\n \n     DefaultMetricsSystem.initialize(\"NodeManager\");\n \n     // StatusUpdater should be added last so that it get started last \n     // so that we make sure everything is up before registering with RM. \n     addService(nodeStatusUpdater);\n \n     super.init(conf);\n     // TODO add local dirs to del\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void init(Configuration conf) {\n\n    Context context \u003d new NMContext();\n\n    // Create the secretManager if need be.\n    if (UserGroupInformation.isSecurityEnabled()) {\n      LOG.info(\"Security is enabled on NodeManager. \"\n          + \"Creating ContainerTokenSecretManager\");\n      this.containerTokenSecretManager \u003d new ContainerTokenSecretManager();\n    }\n\n    this.aclsManager \u003d new ApplicationACLsManager(conf);\n\n    ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n        conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n          DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n    DeletionService del \u003d new DeletionService(exec);\n    addService(del);\n\n    // NodeManager level dispatcher\n    AsyncDispatcher dispatcher \u003d new AsyncDispatcher();\n\n    NodeHealthCheckerService healthChecker \u003d null;\n    if (NodeHealthCheckerService.shouldRun(conf)) {\n      healthChecker \u003d new NodeHealthCheckerService();\n      addService(healthChecker);\n    }\n\n    NodeStatusUpdater nodeStatusUpdater \u003d\n        createNodeStatusUpdater(context, dispatcher, healthChecker, \n        this.containerTokenSecretManager);\n    \n    nodeStatusUpdater.register(this);\n\n    NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n    addService(nodeResourceMonitor);\n\n    ContainerManagerImpl containerManager \u003d\n        createContainerManager(context, exec, del, nodeStatusUpdater,\n        this.containerTokenSecretManager, this.aclsManager);\n    addService(containerManager);\n\n    Service webServer \u003d createWebServer(context, containerManager\n        .getContainersMonitor(), this.aclsManager);\n    addService(webServer);\n\n    dispatcher.register(ContainerManagerEventType.class, containerManager);\n    addService(dispatcher);\n\n    DefaultMetricsSystem.initialize(\"NodeManager\");\n\n    // StatusUpdater should be added last so that it get started last \n    // so that we make sure everything is up before registering with RM. \n    addService(nodeStatusUpdater);\n\n    super.init(conf);\n    // TODO add local dirs to del\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java",
      "extendedDetails": {}
    },
    "df2991c0cbc3f35c2640b93680667507c4f810dd": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3104. Implemented Application-acls. (vinodkv)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1186748 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "20/10/11 4:45 AM",
      "commitName": "df2991c0cbc3f35c2640b93680667507c4f810dd",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "03/10/11 4:21 PM",
      "commitNameOld": "12743d2169f5a24a9b3be07c9e9dcc3f2f1001f0",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 16.52,
      "commitsBetweenForRepo": 145,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,56 @@\n   public void init(Configuration conf) {\n \n     Context context \u003d new NMContext();\n \n     // Create the secretManager if need be.\n     if (UserGroupInformation.isSecurityEnabled()) {\n       LOG.info(\"Security is enabled on NodeManager. \"\n           + \"Creating ContainerTokenSecretManager\");\n       this.containerTokenSecretManager \u003d new ContainerTokenSecretManager();\n     }\n \n+    this.aclsManager \u003d new ApplicationACLsManager(conf);\n+\n     ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n         conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n           DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n     DeletionService del \u003d new DeletionService(exec);\n     addService(del);\n \n     // NodeManager level dispatcher\n     AsyncDispatcher dispatcher \u003d new AsyncDispatcher();\n \n     NodeHealthCheckerService healthChecker \u003d null;\n     if (NodeHealthCheckerService.shouldRun(conf)) {\n       healthChecker \u003d new NodeHealthCheckerService();\n       addService(healthChecker);\n     }\n \n     NodeStatusUpdater nodeStatusUpdater \u003d\n         createNodeStatusUpdater(context, dispatcher, healthChecker, \n         this.containerTokenSecretManager);\n \n     NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n     addService(nodeResourceMonitor);\n \n     ContainerManagerImpl containerManager \u003d\n         createContainerManager(context, exec, del, nodeStatusUpdater,\n-        this.containerTokenSecretManager);\n+        this.containerTokenSecretManager, this.aclsManager);\n     addService(containerManager);\n \n-    Service webServer \u003d\n-        createWebServer(context, containerManager.getContainersMonitor());\n+    Service webServer \u003d createWebServer(context, containerManager\n+        .getContainersMonitor(), this.aclsManager);\n     addService(webServer);\n \n     dispatcher.register(ContainerManagerEventType.class, containerManager);\n     addService(dispatcher);\n \n     DefaultMetricsSystem.initialize(\"NodeManager\");\n \n     // StatusUpdater should be added last so that it get started last \n     // so that we make sure everything is up before registering with RM. \n     addService(nodeStatusUpdater);\n \n     super.init(conf);\n     // TODO add local dirs to del\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void init(Configuration conf) {\n\n    Context context \u003d new NMContext();\n\n    // Create the secretManager if need be.\n    if (UserGroupInformation.isSecurityEnabled()) {\n      LOG.info(\"Security is enabled on NodeManager. \"\n          + \"Creating ContainerTokenSecretManager\");\n      this.containerTokenSecretManager \u003d new ContainerTokenSecretManager();\n    }\n\n    this.aclsManager \u003d new ApplicationACLsManager(conf);\n\n    ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n        conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n          DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n    DeletionService del \u003d new DeletionService(exec);\n    addService(del);\n\n    // NodeManager level dispatcher\n    AsyncDispatcher dispatcher \u003d new AsyncDispatcher();\n\n    NodeHealthCheckerService healthChecker \u003d null;\n    if (NodeHealthCheckerService.shouldRun(conf)) {\n      healthChecker \u003d new NodeHealthCheckerService();\n      addService(healthChecker);\n    }\n\n    NodeStatusUpdater nodeStatusUpdater \u003d\n        createNodeStatusUpdater(context, dispatcher, healthChecker, \n        this.containerTokenSecretManager);\n\n    NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n    addService(nodeResourceMonitor);\n\n    ContainerManagerImpl containerManager \u003d\n        createContainerManager(context, exec, del, nodeStatusUpdater,\n        this.containerTokenSecretManager, this.aclsManager);\n    addService(containerManager);\n\n    Service webServer \u003d createWebServer(context, containerManager\n        .getContainersMonitor(), this.aclsManager);\n    addService(webServer);\n\n    dispatcher.register(ContainerManagerEventType.class, containerManager);\n    addService(dispatcher);\n\n    DefaultMetricsSystem.initialize(\"NodeManager\");\n\n    // StatusUpdater should be added last so that it get started last \n    // so that we make sure everything is up before registering with RM. \n    addService(nodeStatusUpdater);\n\n    super.init(conf);\n    // TODO add local dirs to del\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java",
      "extendedDetails": {}
    },
    "4ba2acf3363bdfd7fcdd9de496cd57f8af6f03ad": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2966. Added ShutDown hooks for MRV2 processes so that they can gracefully exit. Contributed by Abhijit Suresh Shingate.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1170746 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/09/11 10:57 AM",
      "commitName": "4ba2acf3363bdfd7fcdd9de496cd57f8af6f03ad",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "12/09/11 12:11 AM",
      "commitNameOld": "6b2f2efe4de4e709a2b9c64b7b3b3138e1939668",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 2.45,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,61 +1,54 @@\n   public void init(Configuration conf) {\n \n     Context context \u003d new NMContext();\n \n     // Create the secretManager if need be.\n     if (UserGroupInformation.isSecurityEnabled()) {\n       LOG.info(\"Security is enabled on NodeManager. \"\n           + \"Creating ContainerTokenSecretManager\");\n       this.containerTokenSecretManager \u003d new ContainerTokenSecretManager();\n     }\n \n     ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n         conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n           DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n     DeletionService del \u003d new DeletionService(exec);\n     addService(del);\n \n     // NodeManager level dispatcher\n     AsyncDispatcher dispatcher \u003d new AsyncDispatcher();\n \n     NodeHealthCheckerService healthChecker \u003d null;\n     if (NodeHealthCheckerService.shouldRun(conf)) {\n       healthChecker \u003d new NodeHealthCheckerService();\n       addService(healthChecker);\n     }\n \n     NodeStatusUpdater nodeStatusUpdater \u003d\n         createNodeStatusUpdater(context, dispatcher, healthChecker, \n         this.containerTokenSecretManager);\n \n     NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n     addService(nodeResourceMonitor);\n \n     ContainerManagerImpl containerManager \u003d\n         createContainerManager(context, exec, del, nodeStatusUpdater,\n         this.containerTokenSecretManager);\n     addService(containerManager);\n \n     Service webServer \u003d\n         createWebServer(context, containerManager.getContainersMonitor());\n     addService(webServer);\n \n     dispatcher.register(ContainerManagerEventType.class, containerManager);\n     addService(dispatcher);\n \n-    Runtime.getRuntime().addShutdownHook(new Thread() {\n-          @Override\n-          public void run() {\n-            NodeManager.this.stop();\n-          }\n-        });\n-\n     DefaultMetricsSystem.initialize(\"NodeManager\");\n \n     // StatusUpdater should be added last so that it get started last \n     // so that we make sure everything is up before registering with RM. \n     addService(nodeStatusUpdater);\n \n     super.init(conf);\n     // TODO add local dirs to del\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void init(Configuration conf) {\n\n    Context context \u003d new NMContext();\n\n    // Create the secretManager if need be.\n    if (UserGroupInformation.isSecurityEnabled()) {\n      LOG.info(\"Security is enabled on NodeManager. \"\n          + \"Creating ContainerTokenSecretManager\");\n      this.containerTokenSecretManager \u003d new ContainerTokenSecretManager();\n    }\n\n    ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n        conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n          DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n    DeletionService del \u003d new DeletionService(exec);\n    addService(del);\n\n    // NodeManager level dispatcher\n    AsyncDispatcher dispatcher \u003d new AsyncDispatcher();\n\n    NodeHealthCheckerService healthChecker \u003d null;\n    if (NodeHealthCheckerService.shouldRun(conf)) {\n      healthChecker \u003d new NodeHealthCheckerService();\n      addService(healthChecker);\n    }\n\n    NodeStatusUpdater nodeStatusUpdater \u003d\n        createNodeStatusUpdater(context, dispatcher, healthChecker, \n        this.containerTokenSecretManager);\n\n    NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n    addService(nodeResourceMonitor);\n\n    ContainerManagerImpl containerManager \u003d\n        createContainerManager(context, exec, del, nodeStatusUpdater,\n        this.containerTokenSecretManager);\n    addService(containerManager);\n\n    Service webServer \u003d\n        createWebServer(context, containerManager.getContainersMonitor());\n    addService(webServer);\n\n    dispatcher.register(ContainerManagerEventType.class, containerManager);\n    addService(dispatcher);\n\n    DefaultMetricsSystem.initialize(\"NodeManager\");\n\n    // StatusUpdater should be added last so that it get started last \n    // so that we make sure everything is up before registering with RM. \n    addService(nodeStatusUpdater);\n\n    super.init(conf);\n    // TODO add local dirs to del\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java",
      "extendedDetails": {}
    },
    "6b2f2efe4de4e709a2b9c64b7b3b3138e1939668": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2749. Ensure NM registers with RM after starting all its services correctly. Contributed by Thomas Graves.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1169621 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/09/11 12:11 AM",
      "commitName": "6b2f2efe4de4e709a2b9c64b7b3b3138e1939668",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "08/09/11 6:44 PM",
      "commitNameOld": "fafe8cd28e726566509c679e19d7da622f29f90d",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 3.23,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,61 @@\n   public void init(Configuration conf) {\n \n     Context context \u003d new NMContext();\n \n+    // Create the secretManager if need be.\n+    if (UserGroupInformation.isSecurityEnabled()) {\n+      LOG.info(\"Security is enabled on NodeManager. \"\n+          + \"Creating ContainerTokenSecretManager\");\n+      this.containerTokenSecretManager \u003d new ContainerTokenSecretManager();\n+    }\n+\n     ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n         conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n           DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n     DeletionService del \u003d new DeletionService(exec);\n     addService(del);\n \n     // NodeManager level dispatcher\n     AsyncDispatcher dispatcher \u003d new AsyncDispatcher();\n \n     NodeHealthCheckerService healthChecker \u003d null;\n     if (NodeHealthCheckerService.shouldRun(conf)) {\n       healthChecker \u003d new NodeHealthCheckerService();\n       addService(healthChecker);\n     }\n \n-    // StatusUpdater should be added first so that it can start first. Once it\n-    // contacts RM, does registration and gets tokens, then only\n-    // ContainerManager can start.\n     NodeStatusUpdater nodeStatusUpdater \u003d\n-        createNodeStatusUpdater(context, dispatcher, healthChecker);\n-    addService(nodeStatusUpdater);\n+        createNodeStatusUpdater(context, dispatcher, healthChecker, \n+        this.containerTokenSecretManager);\n \n     NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n     addService(nodeResourceMonitor);\n \n     ContainerManagerImpl containerManager \u003d\n-        createContainerManager(context, exec, del, nodeStatusUpdater);\n+        createContainerManager(context, exec, del, nodeStatusUpdater,\n+        this.containerTokenSecretManager);\n     addService(containerManager);\n \n     Service webServer \u003d\n         createWebServer(context, containerManager.getContainersMonitor());\n     addService(webServer);\n \n     dispatcher.register(ContainerManagerEventType.class, containerManager);\n     addService(dispatcher);\n \n     Runtime.getRuntime().addShutdownHook(new Thread() {\n           @Override\n           public void run() {\n             NodeManager.this.stop();\n           }\n         });\n \n     DefaultMetricsSystem.initialize(\"NodeManager\");\n \n+    // StatusUpdater should be added last so that it get started last \n+    // so that we make sure everything is up before registering with RM. \n+    addService(nodeStatusUpdater);\n+\n     super.init(conf);\n     // TODO add local dirs to del\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void init(Configuration conf) {\n\n    Context context \u003d new NMContext();\n\n    // Create the secretManager if need be.\n    if (UserGroupInformation.isSecurityEnabled()) {\n      LOG.info(\"Security is enabled on NodeManager. \"\n          + \"Creating ContainerTokenSecretManager\");\n      this.containerTokenSecretManager \u003d new ContainerTokenSecretManager();\n    }\n\n    ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n        conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n          DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n    DeletionService del \u003d new DeletionService(exec);\n    addService(del);\n\n    // NodeManager level dispatcher\n    AsyncDispatcher dispatcher \u003d new AsyncDispatcher();\n\n    NodeHealthCheckerService healthChecker \u003d null;\n    if (NodeHealthCheckerService.shouldRun(conf)) {\n      healthChecker \u003d new NodeHealthCheckerService();\n      addService(healthChecker);\n    }\n\n    NodeStatusUpdater nodeStatusUpdater \u003d\n        createNodeStatusUpdater(context, dispatcher, healthChecker, \n        this.containerTokenSecretManager);\n\n    NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n    addService(nodeResourceMonitor);\n\n    ContainerManagerImpl containerManager \u003d\n        createContainerManager(context, exec, del, nodeStatusUpdater,\n        this.containerTokenSecretManager);\n    addService(containerManager);\n\n    Service webServer \u003d\n        createWebServer(context, containerManager.getContainersMonitor());\n    addService(webServer);\n\n    dispatcher.register(ContainerManagerEventType.class, containerManager);\n    addService(dispatcher);\n\n    Runtime.getRuntime().addShutdownHook(new Thread() {\n          @Override\n          public void run() {\n            NodeManager.this.stop();\n          }\n        });\n\n    DefaultMetricsSystem.initialize(\"NodeManager\");\n\n    // StatusUpdater should be added last so that it get started last \n    // so that we make sure everything is up before registering with RM. \n    addService(nodeStatusUpdater);\n\n    super.init(conf);\n    // TODO add local dirs to del\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java",
      "extendedDetails": {}
    },
    "fafe8cd28e726566509c679e19d7da622f29f90d": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2864. Normalize configuration variable names for YARN. Contributed by Robert Evans.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1166955 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/09/11 6:44 PM",
      "commitName": "fafe8cd28e726566509c679e19d7da622f29f90d",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "06/09/11 4:40 PM",
      "commitNameOld": "d51078eb7edf4d28069163bad30d28e35c5e166e",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 2.09,
      "commitsBetweenForRepo": 18,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,52 @@\n   public void init(Configuration conf) {\n \n     Context context \u003d new NMContext();\n \n     ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n-        conf.getClass(NM_CONTAINER_EXECUTOR_CLASS,\n+        conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n           DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n     DeletionService del \u003d new DeletionService(exec);\n     addService(del);\n \n     // NodeManager level dispatcher\n     AsyncDispatcher dispatcher \u003d new AsyncDispatcher();\n \n     NodeHealthCheckerService healthChecker \u003d null;\n     if (NodeHealthCheckerService.shouldRun(conf)) {\n       healthChecker \u003d new NodeHealthCheckerService();\n       addService(healthChecker);\n     }\n \n     // StatusUpdater should be added first so that it can start first. Once it\n     // contacts RM, does registration and gets tokens, then only\n     // ContainerManager can start.\n     NodeStatusUpdater nodeStatusUpdater \u003d\n         createNodeStatusUpdater(context, dispatcher, healthChecker);\n     addService(nodeStatusUpdater);\n \n     NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n     addService(nodeResourceMonitor);\n \n     ContainerManagerImpl containerManager \u003d\n         createContainerManager(context, exec, del, nodeStatusUpdater);\n     addService(containerManager);\n \n     Service webServer \u003d\n         createWebServer(context, containerManager.getContainersMonitor());\n     addService(webServer);\n \n     dispatcher.register(ContainerManagerEventType.class, containerManager);\n     addService(dispatcher);\n \n     Runtime.getRuntime().addShutdownHook(new Thread() {\n           @Override\n           public void run() {\n             NodeManager.this.stop();\n           }\n         });\n \n     DefaultMetricsSystem.initialize(\"NodeManager\");\n \n     super.init(conf);\n     // TODO add local dirs to del\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void init(Configuration conf) {\n\n    Context context \u003d new NMContext();\n\n    ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n        conf.getClass(YarnConfiguration.NM_CONTAINER_EXECUTOR,\n          DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n    DeletionService del \u003d new DeletionService(exec);\n    addService(del);\n\n    // NodeManager level dispatcher\n    AsyncDispatcher dispatcher \u003d new AsyncDispatcher();\n\n    NodeHealthCheckerService healthChecker \u003d null;\n    if (NodeHealthCheckerService.shouldRun(conf)) {\n      healthChecker \u003d new NodeHealthCheckerService();\n      addService(healthChecker);\n    }\n\n    // StatusUpdater should be added first so that it can start first. Once it\n    // contacts RM, does registration and gets tokens, then only\n    // ContainerManager can start.\n    NodeStatusUpdater nodeStatusUpdater \u003d\n        createNodeStatusUpdater(context, dispatcher, healthChecker);\n    addService(nodeStatusUpdater);\n\n    NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n    addService(nodeResourceMonitor);\n\n    ContainerManagerImpl containerManager \u003d\n        createContainerManager(context, exec, del, nodeStatusUpdater);\n    addService(containerManager);\n\n    Service webServer \u003d\n        createWebServer(context, containerManager.getContainersMonitor());\n    addService(webServer);\n\n    dispatcher.register(ContainerManagerEventType.class, containerManager);\n    addService(dispatcher);\n\n    Runtime.getRuntime().addShutdownHook(new Thread() {\n          @Override\n          public void run() {\n            NodeManager.this.stop();\n          }\n        });\n\n    DefaultMetricsSystem.initialize(\"NodeManager\");\n\n    super.init(conf);\n    // TODO add local dirs to del\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public void init(Configuration conf) {\n\n    Context context \u003d new NMContext();\n\n    ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n        conf.getClass(NM_CONTAINER_EXECUTOR_CLASS,\n          DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n    DeletionService del \u003d new DeletionService(exec);\n    addService(del);\n\n    // NodeManager level dispatcher\n    AsyncDispatcher dispatcher \u003d new AsyncDispatcher();\n\n    NodeHealthCheckerService healthChecker \u003d null;\n    if (NodeHealthCheckerService.shouldRun(conf)) {\n      healthChecker \u003d new NodeHealthCheckerService();\n      addService(healthChecker);\n    }\n\n    // StatusUpdater should be added first so that it can start first. Once it\n    // contacts RM, does registration and gets tokens, then only\n    // ContainerManager can start.\n    NodeStatusUpdater nodeStatusUpdater \u003d\n        createNodeStatusUpdater(context, dispatcher, healthChecker);\n    addService(nodeStatusUpdater);\n\n    NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n    addService(nodeResourceMonitor);\n\n    ContainerManagerImpl containerManager \u003d\n        createContainerManager(context, exec, del, nodeStatusUpdater);\n    addService(containerManager);\n\n    Service webServer \u003d\n        createWebServer(context, containerManager.getContainersMonitor());\n    addService(webServer);\n\n    dispatcher.register(ContainerManagerEventType.class, containerManager);\n    addService(dispatcher);\n\n    Runtime.getRuntime().addShutdownHook(new Thread() {\n          @Override\n          public void run() {\n            NodeManager.this.stop();\n          }\n        });\n\n    DefaultMetricsSystem.initialize(\"NodeManager\");\n\n    super.init(conf);\n    // TODO add local dirs to del\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java",
        "newPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java"
      }
    },
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-279. MapReduce 2.0. Merging MR-279 branch into trunk. Contributed by Arun C Murthy, Christopher Douglas, Devaraj Das, Greg Roelofs, Jeffrey Naisbitt, Josh Wills, Jonathan Eagles, Krishna Ramachandran, Luke Lu, Mahadev Konar, Robert Evans, Sharad Agarwal, Siddharth Seth, Thomas Graves, and Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159166 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/08/11 4:07 AM",
      "commitName": "dbecbe5dfe50f834fc3b8401709079e9470cc517",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,52 @@\n+  public void init(Configuration conf) {\n+\n+    Context context \u003d new NMContext();\n+\n+    ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n+        conf.getClass(NM_CONTAINER_EXECUTOR_CLASS,\n+          DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n+    DeletionService del \u003d new DeletionService(exec);\n+    addService(del);\n+\n+    // NodeManager level dispatcher\n+    AsyncDispatcher dispatcher \u003d new AsyncDispatcher();\n+\n+    NodeHealthCheckerService healthChecker \u003d null;\n+    if (NodeHealthCheckerService.shouldRun(conf)) {\n+      healthChecker \u003d new NodeHealthCheckerService();\n+      addService(healthChecker);\n+    }\n+\n+    // StatusUpdater should be added first so that it can start first. Once it\n+    // contacts RM, does registration and gets tokens, then only\n+    // ContainerManager can start.\n+    NodeStatusUpdater nodeStatusUpdater \u003d\n+        createNodeStatusUpdater(context, dispatcher, healthChecker);\n+    addService(nodeStatusUpdater);\n+\n+    NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n+    addService(nodeResourceMonitor);\n+\n+    ContainerManagerImpl containerManager \u003d\n+        createContainerManager(context, exec, del, nodeStatusUpdater);\n+    addService(containerManager);\n+\n+    Service webServer \u003d\n+        createWebServer(context, containerManager.getContainersMonitor());\n+    addService(webServer);\n+\n+    dispatcher.register(ContainerManagerEventType.class, containerManager);\n+    addService(dispatcher);\n+\n+    Runtime.getRuntime().addShutdownHook(new Thread() {\n+          @Override\n+          public void run() {\n+            NodeManager.this.stop();\n+          }\n+        });\n+\n+    DefaultMetricsSystem.initialize(\"NodeManager\");\n+\n+    super.init(conf);\n+    // TODO add local dirs to del\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void init(Configuration conf) {\n\n    Context context \u003d new NMContext();\n\n    ContainerExecutor exec \u003d ReflectionUtils.newInstance(\n        conf.getClass(NM_CONTAINER_EXECUTOR_CLASS,\n          DefaultContainerExecutor.class, ContainerExecutor.class), conf);\n    DeletionService del \u003d new DeletionService(exec);\n    addService(del);\n\n    // NodeManager level dispatcher\n    AsyncDispatcher dispatcher \u003d new AsyncDispatcher();\n\n    NodeHealthCheckerService healthChecker \u003d null;\n    if (NodeHealthCheckerService.shouldRun(conf)) {\n      healthChecker \u003d new NodeHealthCheckerService();\n      addService(healthChecker);\n    }\n\n    // StatusUpdater should be added first so that it can start first. Once it\n    // contacts RM, does registration and gets tokens, then only\n    // ContainerManager can start.\n    NodeStatusUpdater nodeStatusUpdater \u003d\n        createNodeStatusUpdater(context, dispatcher, healthChecker);\n    addService(nodeStatusUpdater);\n\n    NodeResourceMonitor nodeResourceMonitor \u003d createNodeResourceMonitor();\n    addService(nodeResourceMonitor);\n\n    ContainerManagerImpl containerManager \u003d\n        createContainerManager(context, exec, del, nodeStatusUpdater);\n    addService(containerManager);\n\n    Service webServer \u003d\n        createWebServer(context, containerManager.getContainersMonitor());\n    addService(webServer);\n\n    dispatcher.register(ContainerManagerEventType.class, containerManager);\n    addService(dispatcher);\n\n    Runtime.getRuntime().addShutdownHook(new Thread() {\n          @Override\n          public void run() {\n            NodeManager.this.stop();\n          }\n        });\n\n    DefaultMetricsSystem.initialize(\"NodeManager\");\n\n    super.init(conf);\n    // TODO add local dirs to del\n  }",
      "path": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/NodeManager.java"
    }
  }
}