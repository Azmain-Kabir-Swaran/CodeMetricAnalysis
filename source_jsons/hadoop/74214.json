{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "LdapGroupsMapping.java",
  "functionName": "getGroups",
  "functionId": "getGroups___user-String",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/LdapGroupsMapping.java",
  "functionStartLine": 350,
  "functionEndLine": 383,
  "numCommitsSeen": 29,
  "timeTaken": 2905,
  "changeHistory": [
    "ba4e7bd1928a73d21a3dc5afb95f0d35d5b63000",
    "c9a3aa64dc95b097c51070f71a3b1a2ad126b2b9",
    "6f0aa75121224589fe1e20630c597f851ef3bed2",
    "f305d9c0f64fd7d085f01eaae2154ef13b05b197",
    "d3bf8186aeeb7ecf8c0e121eae1107bd582dbbd7",
    "fc5fd80e9fa21b9c3981fb5afc8fce376aa6a2d9",
    "21426e6e42a2f1c0f5a0eca23ad62057901e4855"
  ],
  "changeHistoryShort": {
    "ba4e7bd1928a73d21a3dc5afb95f0d35d5b63000": "Ybodychange",
    "c9a3aa64dc95b097c51070f71a3b1a2ad126b2b9": "Ybodychange",
    "6f0aa75121224589fe1e20630c597f851ef3bed2": "Ybodychange",
    "f305d9c0f64fd7d085f01eaae2154ef13b05b197": "Ymultichange(Yexceptionschange,Ybodychange)",
    "d3bf8186aeeb7ecf8c0e121eae1107bd582dbbd7": "Ybodychange",
    "fc5fd80e9fa21b9c3981fb5afc8fce376aa6a2d9": "Ybodychange",
    "21426e6e42a2f1c0f5a0eca23ad62057901e4855": "Yintroduced"
  },
  "changeHistoryDetails": {
    "ba4e7bd1928a73d21a3dc5afb95f0d35d5b63000": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16125. Support multiple bind users in LdapGroupsMapping. Contributed by Lukas Majercak.\n",
      "commitDate": "25/02/19 1:39 PM",
      "commitName": "ba4e7bd1928a73d21a3dc5afb95f0d35d5b63000",
      "commitAuthor": "Inigo Goiri",
      "commitDateOld": "12/12/18 11:10 AM",
      "commitNameOld": "76efeacd5f8563bd02b5b2f09c59cee3acdad8c7",
      "commitAuthorOld": "Giovanni Matteo Fumarola",
      "daysBetweenCommits": 75.1,
      "commitsBetweenForRepo": 536,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,32 +1,34 @@\n   public synchronized List\u003cString\u003e getGroups(String user) {\n     /*\n      * Normal garbage collection takes care of removing Context instances when\n      * they are no longer in use. Connections used by Context instances being\n      * garbage collected will be closed automatically. So in case connection is\n      * closed and gets CommunicationException, retry some times with new new\n      * DirContext/connection.\n      */\n \n     // Tracks the number of attempts made using the same LDAP server\n     int atemptsBeforeFailover \u003d 1;\n \n     for (int attempt \u003d 1; attempt \u003c\u003d numAttempts; attempt++,\n         atemptsBeforeFailover++) {\n       try {\n         return doGetGroups(user, groupHierarchyLevels);\n+      } catch (AuthenticationException e) {\n+        switchBindUser(e);\n       } catch (NamingException e) {\n         LOG.warn(\"Failed to get groups for user {} (attempt\u003d{}/{}) using {}. \" +\n             \"Exception: \", user, attempt, numAttempts, currentLdapUrl, e);\n         LOG.trace(\"TRACE\", e);\n \n         if (failover(atemptsBeforeFailover, numAttemptsBeforeFailover)) {\n           atemptsBeforeFailover \u003d 0;\n         }\n       }\n \n       // Reset ctx so that new DirContext can be created with new connection\n       this.ctx \u003d null;\n     }\n     \n     return Collections.emptyList();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized List\u003cString\u003e getGroups(String user) {\n    /*\n     * Normal garbage collection takes care of removing Context instances when\n     * they are no longer in use. Connections used by Context instances being\n     * garbage collected will be closed automatically. So in case connection is\n     * closed and gets CommunicationException, retry some times with new new\n     * DirContext/connection.\n     */\n\n    // Tracks the number of attempts made using the same LDAP server\n    int atemptsBeforeFailover \u003d 1;\n\n    for (int attempt \u003d 1; attempt \u003c\u003d numAttempts; attempt++,\n        atemptsBeforeFailover++) {\n      try {\n        return doGetGroups(user, groupHierarchyLevels);\n      } catch (AuthenticationException e) {\n        switchBindUser(e);\n      } catch (NamingException e) {\n        LOG.warn(\"Failed to get groups for user {} (attempt\u003d{}/{}) using {}. \" +\n            \"Exception: \", user, attempt, numAttempts, currentLdapUrl, e);\n        LOG.trace(\"TRACE\", e);\n\n        if (failover(atemptsBeforeFailover, numAttemptsBeforeFailover)) {\n          atemptsBeforeFailover \u003d 0;\n        }\n      }\n\n      // Reset ctx so that new DirContext can be created with new connection\n      this.ctx \u003d null;\n    }\n    \n    return Collections.emptyList();\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/LdapGroupsMapping.java",
      "extendedDetails": {}
    },
    "c9a3aa64dc95b097c51070f71a3b1a2ad126b2b9": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15950. Failover for LdapGroupsMapping. Contributed by Lukas Majercak.\n",
      "commitDate": "03/12/18 12:10 PM",
      "commitName": "c9a3aa64dc95b097c51070f71a3b1a2ad126b2b9",
      "commitAuthor": "Giovanni Matteo Fumarola",
      "commitDateOld": "29/03/18 5:16 PM",
      "commitNameOld": "2216bde322961c0fe33b5822510880a65d5c45fd",
      "commitAuthorOld": "Konstantin V Shvachko",
      "daysBetweenCommits": 248.83,
      "commitsBetweenForRepo": 2455,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,21 +1,32 @@\n   public synchronized List\u003cString\u003e getGroups(String user) {\n     /*\n-     * Normal garbage collection takes care of removing Context instances when they are no longer in use. \n-     * Connections used by Context instances being garbage collected will be closed automatically.\n-     * So in case connection is closed and gets CommunicationException, retry some times with new new DirContext/connection. \n+     * Normal garbage collection takes care of removing Context instances when\n+     * they are no longer in use. Connections used by Context instances being\n+     * garbage collected will be closed automatically. So in case connection is\n+     * closed and gets CommunicationException, retry some times with new new\n+     * DirContext/connection.\n      */\n-    for(int retry \u003d 0; retry \u003c RECONNECT_RETRY_COUNT; retry++) {\n+\n+    // Tracks the number of attempts made using the same LDAP server\n+    int atemptsBeforeFailover \u003d 1;\n+\n+    for (int attempt \u003d 1; attempt \u003c\u003d numAttempts; attempt++,\n+        atemptsBeforeFailover++) {\n       try {\n         return doGetGroups(user, groupHierarchyLevels);\n       } catch (NamingException e) {\n-        LOG.warn(\"Failed to get groups for user \" + user + \" (retry\u003d\" + retry\n-            + \") by \" + e);\n+        LOG.warn(\"Failed to get groups for user {} (attempt\u003d{}/{}) using {}. \" +\n+            \"Exception: \", user, attempt, numAttempts, currentLdapUrl, e);\n         LOG.trace(\"TRACE\", e);\n+\n+        if (failover(atemptsBeforeFailover, numAttemptsBeforeFailover)) {\n+          atemptsBeforeFailover \u003d 0;\n+        }\n       }\n \n-      //reset ctx so that new DirContext can be created with new connection\n+      // Reset ctx so that new DirContext can be created with new connection\n       this.ctx \u003d null;\n     }\n     \n     return Collections.emptyList();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized List\u003cString\u003e getGroups(String user) {\n    /*\n     * Normal garbage collection takes care of removing Context instances when\n     * they are no longer in use. Connections used by Context instances being\n     * garbage collected will be closed automatically. So in case connection is\n     * closed and gets CommunicationException, retry some times with new new\n     * DirContext/connection.\n     */\n\n    // Tracks the number of attempts made using the same LDAP server\n    int atemptsBeforeFailover \u003d 1;\n\n    for (int attempt \u003d 1; attempt \u003c\u003d numAttempts; attempt++,\n        atemptsBeforeFailover++) {\n      try {\n        return doGetGroups(user, groupHierarchyLevels);\n      } catch (NamingException e) {\n        LOG.warn(\"Failed to get groups for user {} (attempt\u003d{}/{}) using {}. \" +\n            \"Exception: \", user, attempt, numAttempts, currentLdapUrl, e);\n        LOG.trace(\"TRACE\", e);\n\n        if (failover(atemptsBeforeFailover, numAttemptsBeforeFailover)) {\n          atemptsBeforeFailover \u003d 0;\n        }\n      }\n\n      // Reset ctx so that new DirContext can be created with new connection\n      this.ctx \u003d null;\n    }\n    \n    return Collections.emptyList();\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/LdapGroupsMapping.java",
      "extendedDetails": {}
    },
    "6f0aa75121224589fe1e20630c597f851ef3bed2": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-12291. Add support for nested groups in LdapGroupsMapping. Contributed by Esther Kundin.\n",
      "commitDate": "15/06/16 11:41 AM",
      "commitName": "6f0aa75121224589fe1e20630c597f851ef3bed2",
      "commitAuthor": "Jitendra Pandey",
      "commitDateOld": "03/06/16 4:38 PM",
      "commitNameOld": "d82bc8501869be78780fc09752dbf7af918c14af",
      "commitAuthorOld": "Chris Nauroth",
      "daysBetweenCommits": 11.79,
      "commitsBetweenForRepo": 75,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,21 +1,21 @@\n   public synchronized List\u003cString\u003e getGroups(String user) {\n     /*\n      * Normal garbage collection takes care of removing Context instances when they are no longer in use. \n      * Connections used by Context instances being garbage collected will be closed automatically.\n      * So in case connection is closed and gets CommunicationException, retry some times with new new DirContext/connection. \n      */\n     for(int retry \u003d 0; retry \u003c RECONNECT_RETRY_COUNT; retry++) {\n       try {\n-        return doGetGroups(user);\n+        return doGetGroups(user, groupHierarchyLevels);\n       } catch (NamingException e) {\n         LOG.warn(\"Failed to get groups for user \" + user + \" (retry\u003d\" + retry\n             + \") by \" + e);\n         LOG.trace(\"TRACE\", e);\n       }\n \n       //reset ctx so that new DirContext can be created with new connection\n       this.ctx \u003d null;\n     }\n     \n     return Collections.emptyList();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized List\u003cString\u003e getGroups(String user) {\n    /*\n     * Normal garbage collection takes care of removing Context instances when they are no longer in use. \n     * Connections used by Context instances being garbage collected will be closed automatically.\n     * So in case connection is closed and gets CommunicationException, retry some times with new new DirContext/connection. \n     */\n    for(int retry \u003d 0; retry \u003c RECONNECT_RETRY_COUNT; retry++) {\n      try {\n        return doGetGroups(user, groupHierarchyLevels);\n      } catch (NamingException e) {\n        LOG.warn(\"Failed to get groups for user \" + user + \" (retry\u003d\" + retry\n            + \") by \" + e);\n        LOG.trace(\"TRACE\", e);\n      }\n\n      //reset ctx so that new DirContext can be created with new connection\n      this.ctx \u003d null;\n    }\n    \n    return Collections.emptyList();\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/LdapGroupsMapping.java",
      "extendedDetails": {}
    },
    "f305d9c0f64fd7d085f01eaae2154ef13b05b197": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "HADOOP-13103 Group resolution from LDAP may fail on javax.naming.ServiceUnavailableException\n",
      "commitDate": "05/05/16 3:53 PM",
      "commitName": "f305d9c0f64fd7d085f01eaae2154ef13b05b197",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "HADOOP-13103 Group resolution from LDAP may fail on javax.naming.ServiceUnavailableException\n",
          "commitDate": "05/05/16 3:53 PM",
          "commitName": "f305d9c0f64fd7d085f01eaae2154ef13b05b197",
          "commitAuthor": "Tsz-Wo Nicholas Sze",
          "commitDateOld": "15/06/15 2:22 PM",
          "commitNameOld": "722aa1db1f2ac3db0e70063022436a90f90643f3",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 325.06,
          "commitsBetweenForRepo": 2157,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,35 +1,21 @@\n-  public synchronized List\u003cString\u003e getGroups(String user) throws IOException {\n-    List\u003cString\u003e emptyResults \u003d new ArrayList\u003cString\u003e();\n+  public synchronized List\u003cString\u003e getGroups(String user) {\n     /*\n      * Normal garbage collection takes care of removing Context instances when they are no longer in use. \n      * Connections used by Context instances being garbage collected will be closed automatically.\n      * So in case connection is closed and gets CommunicationException, retry some times with new new DirContext/connection. \n      */\n-    try {\n-      return doGetGroups(user);\n-    } catch (CommunicationException e) {\n-      LOG.warn(\"Connection is closed, will try to reconnect\");\n-    } catch (NamingException e) {\n-      LOG.warn(\"Exception trying to get groups for user \" + user + \": \"\n-          + e.getMessage());\n-      return emptyResults;\n-    }\n-\n-    int retryCount \u003d 0;\n-    while (retryCount ++ \u003c RECONNECT_RETRY_COUNT) {\n-      //reset ctx so that new DirContext can be created with new connection\n-      this.ctx \u003d null;\n-      \n+    for(int retry \u003d 0; retry \u003c RECONNECT_RETRY_COUNT; retry++) {\n       try {\n         return doGetGroups(user);\n-      } catch (CommunicationException e) {\n-        LOG.warn(\"Connection being closed, reconnecting failed, retryCount \u003d \" + retryCount);\n       } catch (NamingException e) {\n-        LOG.warn(\"Exception trying to get groups for user \" + user + \":\"\n-            + e.getMessage());\n-        return emptyResults;\n+        LOG.warn(\"Failed to get groups for user \" + user + \" (retry\u003d\" + retry\n+            + \") by \" + e);\n+        LOG.trace(\"TRACE\", e);\n       }\n+\n+      //reset ctx so that new DirContext can be created with new connection\n+      this.ctx \u003d null;\n     }\n     \n-    return emptyResults;\n+    return Collections.emptyList();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public synchronized List\u003cString\u003e getGroups(String user) {\n    /*\n     * Normal garbage collection takes care of removing Context instances when they are no longer in use. \n     * Connections used by Context instances being garbage collected will be closed automatically.\n     * So in case connection is closed and gets CommunicationException, retry some times with new new DirContext/connection. \n     */\n    for(int retry \u003d 0; retry \u003c RECONNECT_RETRY_COUNT; retry++) {\n      try {\n        return doGetGroups(user);\n      } catch (NamingException e) {\n        LOG.warn(\"Failed to get groups for user \" + user + \" (retry\u003d\" + retry\n            + \") by \" + e);\n        LOG.trace(\"TRACE\", e);\n      }\n\n      //reset ctx so that new DirContext can be created with new connection\n      this.ctx \u003d null;\n    }\n    \n    return Collections.emptyList();\n  }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/LdapGroupsMapping.java",
          "extendedDetails": {
            "oldValue": "[IOException]",
            "newValue": "[]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-13103 Group resolution from LDAP may fail on javax.naming.ServiceUnavailableException\n",
          "commitDate": "05/05/16 3:53 PM",
          "commitName": "f305d9c0f64fd7d085f01eaae2154ef13b05b197",
          "commitAuthor": "Tsz-Wo Nicholas Sze",
          "commitDateOld": "15/06/15 2:22 PM",
          "commitNameOld": "722aa1db1f2ac3db0e70063022436a90f90643f3",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 325.06,
          "commitsBetweenForRepo": 2157,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,35 +1,21 @@\n-  public synchronized List\u003cString\u003e getGroups(String user) throws IOException {\n-    List\u003cString\u003e emptyResults \u003d new ArrayList\u003cString\u003e();\n+  public synchronized List\u003cString\u003e getGroups(String user) {\n     /*\n      * Normal garbage collection takes care of removing Context instances when they are no longer in use. \n      * Connections used by Context instances being garbage collected will be closed automatically.\n      * So in case connection is closed and gets CommunicationException, retry some times with new new DirContext/connection. \n      */\n-    try {\n-      return doGetGroups(user);\n-    } catch (CommunicationException e) {\n-      LOG.warn(\"Connection is closed, will try to reconnect\");\n-    } catch (NamingException e) {\n-      LOG.warn(\"Exception trying to get groups for user \" + user + \": \"\n-          + e.getMessage());\n-      return emptyResults;\n-    }\n-\n-    int retryCount \u003d 0;\n-    while (retryCount ++ \u003c RECONNECT_RETRY_COUNT) {\n-      //reset ctx so that new DirContext can be created with new connection\n-      this.ctx \u003d null;\n-      \n+    for(int retry \u003d 0; retry \u003c RECONNECT_RETRY_COUNT; retry++) {\n       try {\n         return doGetGroups(user);\n-      } catch (CommunicationException e) {\n-        LOG.warn(\"Connection being closed, reconnecting failed, retryCount \u003d \" + retryCount);\n       } catch (NamingException e) {\n-        LOG.warn(\"Exception trying to get groups for user \" + user + \":\"\n-            + e.getMessage());\n-        return emptyResults;\n+        LOG.warn(\"Failed to get groups for user \" + user + \" (retry\u003d\" + retry\n+            + \") by \" + e);\n+        LOG.trace(\"TRACE\", e);\n       }\n+\n+      //reset ctx so that new DirContext can be created with new connection\n+      this.ctx \u003d null;\n     }\n     \n-    return emptyResults;\n+    return Collections.emptyList();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public synchronized List\u003cString\u003e getGroups(String user) {\n    /*\n     * Normal garbage collection takes care of removing Context instances when they are no longer in use. \n     * Connections used by Context instances being garbage collected will be closed automatically.\n     * So in case connection is closed and gets CommunicationException, retry some times with new new DirContext/connection. \n     */\n    for(int retry \u003d 0; retry \u003c RECONNECT_RETRY_COUNT; retry++) {\n      try {\n        return doGetGroups(user);\n      } catch (NamingException e) {\n        LOG.warn(\"Failed to get groups for user \" + user + \" (retry\u003d\" + retry\n            + \") by \" + e);\n        LOG.trace(\"TRACE\", e);\n      }\n\n      //reset ctx so that new DirContext can be created with new connection\n      this.ctx \u003d null;\n    }\n    \n    return Collections.emptyList();\n  }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/LdapGroupsMapping.java",
          "extendedDetails": {}
        }
      ]
    },
    "d3bf8186aeeb7ecf8c0e121eae1107bd582dbbd7": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10755. Support negative caching of user-group mapping. Contributed by Lei Xu.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1612408 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/07/14 2:52 PM",
      "commitName": "d3bf8186aeeb7ecf8c0e121eae1107bd582dbbd7",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "11/06/14 11:54 AM",
      "commitNameOld": "ca8f112d2f422c11c62bb30660b60fb5fb275457",
      "commitAuthorOld": "Brandon Li",
      "daysBetweenCommits": 40.12,
      "commitsBetweenForRepo": 275,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,33 +1,35 @@\n   public synchronized List\u003cString\u003e getGroups(String user) throws IOException {\n     List\u003cString\u003e emptyResults \u003d new ArrayList\u003cString\u003e();\n     /*\n      * Normal garbage collection takes care of removing Context instances when they are no longer in use. \n      * Connections used by Context instances being garbage collected will be closed automatically.\n      * So in case connection is closed and gets CommunicationException, retry some times with new new DirContext/connection. \n      */\n     try {\n       return doGetGroups(user);\n     } catch (CommunicationException e) {\n       LOG.warn(\"Connection is closed, will try to reconnect\");\n     } catch (NamingException e) {\n-      LOG.warn(\"Exception trying to get groups for user \" + user, e);\n+      LOG.warn(\"Exception trying to get groups for user \" + user + \": \"\n+          + e.getMessage());\n       return emptyResults;\n     }\n \n     int retryCount \u003d 0;\n     while (retryCount ++ \u003c RECONNECT_RETRY_COUNT) {\n       //reset ctx so that new DirContext can be created with new connection\n       this.ctx \u003d null;\n       \n       try {\n         return doGetGroups(user);\n       } catch (CommunicationException e) {\n         LOG.warn(\"Connection being closed, reconnecting failed, retryCount \u003d \" + retryCount);\n       } catch (NamingException e) {\n-        LOG.warn(\"Exception trying to get groups for user \" + user, e);\n+        LOG.warn(\"Exception trying to get groups for user \" + user + \":\"\n+            + e.getMessage());\n         return emptyResults;\n       }\n     }\n     \n     return emptyResults;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized List\u003cString\u003e getGroups(String user) throws IOException {\n    List\u003cString\u003e emptyResults \u003d new ArrayList\u003cString\u003e();\n    /*\n     * Normal garbage collection takes care of removing Context instances when they are no longer in use. \n     * Connections used by Context instances being garbage collected will be closed automatically.\n     * So in case connection is closed and gets CommunicationException, retry some times with new new DirContext/connection. \n     */\n    try {\n      return doGetGroups(user);\n    } catch (CommunicationException e) {\n      LOG.warn(\"Connection is closed, will try to reconnect\");\n    } catch (NamingException e) {\n      LOG.warn(\"Exception trying to get groups for user \" + user + \": \"\n          + e.getMessage());\n      return emptyResults;\n    }\n\n    int retryCount \u003d 0;\n    while (retryCount ++ \u003c RECONNECT_RETRY_COUNT) {\n      //reset ctx so that new DirContext can be created with new connection\n      this.ctx \u003d null;\n      \n      try {\n        return doGetGroups(user);\n      } catch (CommunicationException e) {\n        LOG.warn(\"Connection being closed, reconnecting failed, retryCount \u003d \" + retryCount);\n      } catch (NamingException e) {\n        LOG.warn(\"Exception trying to get groups for user \" + user + \":\"\n            + e.getMessage());\n        return emptyResults;\n      }\n    }\n    \n    return emptyResults;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/LdapGroupsMapping.java",
      "extendedDetails": {}
    },
    "fc5fd80e9fa21b9c3981fb5afc8fce376aa6a2d9": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9125. LdapGroupsMapping threw CommunicationException after some idle time. Contributed by Kai Zheng.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1461863 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/03/13 2:49 PM",
      "commitName": "fc5fd80e9fa21b9c3981fb5afc8fce376aa6a2d9",
      "commitAuthor": "Aaron Myers",
      "commitDateOld": "19/03/12 11:32 PM",
      "commitNameOld": "12fca4cf3382ff333cec84d936710d1c02bbf4f5",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 372.64,
      "commitsBetweenForRepo": 2052,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,33 +1,33 @@\n   public synchronized List\u003cString\u003e getGroups(String user) throws IOException {\n-    List\u003cString\u003e groups \u003d new ArrayList\u003cString\u003e();\n-\n+    List\u003cString\u003e emptyResults \u003d new ArrayList\u003cString\u003e();\n+    /*\n+     * Normal garbage collection takes care of removing Context instances when they are no longer in use. \n+     * Connections used by Context instances being garbage collected will be closed automatically.\n+     * So in case connection is closed and gets CommunicationException, retry some times with new new DirContext/connection. \n+     */\n     try {\n-      DirContext ctx \u003d getDirContext();\n-\n-      // Search for the user. We\u0027ll only ever need to look at the first result\n-      NamingEnumeration\u003cSearchResult\u003e results \u003d ctx.search(baseDN,\n-                                                           userSearchFilter,\n-                                                           new Object[]{user},\n-                                                           SEARCH_CONTROLS);\n-      if (results.hasMoreElements()) {\n-        SearchResult result \u003d results.nextElement();\n-        String userDn \u003d result.getNameInNamespace();\n-\n-        NamingEnumeration\u003cSearchResult\u003e groupResults \u003d\n-          ctx.search(baseDN,\n-                     \"(\u0026\" + groupSearchFilter + \"(\" + groupMemberAttr + \"\u003d{0}))\",\n-                     new Object[]{userDn},\n-                     SEARCH_CONTROLS);\n-        while (groupResults.hasMoreElements()) {\n-          SearchResult groupResult \u003d groupResults.nextElement();\n-          Attribute groupName \u003d groupResult.getAttributes().get(groupNameAttr);\n-          groups.add(groupName.get().toString());\n-        }\n-      }\n+      return doGetGroups(user);\n+    } catch (CommunicationException e) {\n+      LOG.warn(\"Connection is closed, will try to reconnect\");\n     } catch (NamingException e) {\n       LOG.warn(\"Exception trying to get groups for user \" + user, e);\n-      return new ArrayList\u003cString\u003e();\n+      return emptyResults;\n     }\n \n-    return groups;\n+    int retryCount \u003d 0;\n+    while (retryCount ++ \u003c RECONNECT_RETRY_COUNT) {\n+      //reset ctx so that new DirContext can be created with new connection\n+      this.ctx \u003d null;\n+      \n+      try {\n+        return doGetGroups(user);\n+      } catch (CommunicationException e) {\n+        LOG.warn(\"Connection being closed, reconnecting failed, retryCount \u003d \" + retryCount);\n+      } catch (NamingException e) {\n+        LOG.warn(\"Exception trying to get groups for user \" + user, e);\n+        return emptyResults;\n+      }\n+    }\n+    \n+    return emptyResults;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized List\u003cString\u003e getGroups(String user) throws IOException {\n    List\u003cString\u003e emptyResults \u003d new ArrayList\u003cString\u003e();\n    /*\n     * Normal garbage collection takes care of removing Context instances when they are no longer in use. \n     * Connections used by Context instances being garbage collected will be closed automatically.\n     * So in case connection is closed and gets CommunicationException, retry some times with new new DirContext/connection. \n     */\n    try {\n      return doGetGroups(user);\n    } catch (CommunicationException e) {\n      LOG.warn(\"Connection is closed, will try to reconnect\");\n    } catch (NamingException e) {\n      LOG.warn(\"Exception trying to get groups for user \" + user, e);\n      return emptyResults;\n    }\n\n    int retryCount \u003d 0;\n    while (retryCount ++ \u003c RECONNECT_RETRY_COUNT) {\n      //reset ctx so that new DirContext can be created with new connection\n      this.ctx \u003d null;\n      \n      try {\n        return doGetGroups(user);\n      } catch (CommunicationException e) {\n        LOG.warn(\"Connection being closed, reconnecting failed, retryCount \u003d \" + retryCount);\n      } catch (NamingException e) {\n        LOG.warn(\"Exception trying to get groups for user \" + user, e);\n        return emptyResults;\n      }\n    }\n    \n    return emptyResults;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/LdapGroupsMapping.java",
      "extendedDetails": {}
    },
    "21426e6e42a2f1c0f5a0eca23ad62057901e4855": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-8121. Active Directory Group Mapping Service. Contributed by Jonathan Natkins.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1302740 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/03/12 6:00 PM",
      "commitName": "21426e6e42a2f1c0f5a0eca23ad62057901e4855",
      "commitAuthor": "Aaron Myers",
      "diff": "@@ -0,0 +1,33 @@\n+  public synchronized List\u003cString\u003e getGroups(String user) throws IOException {\n+    List\u003cString\u003e groups \u003d new ArrayList\u003cString\u003e();\n+\n+    try {\n+      DirContext ctx \u003d getDirContext();\n+\n+      // Search for the user. We\u0027ll only ever need to look at the first result\n+      NamingEnumeration\u003cSearchResult\u003e results \u003d ctx.search(baseDN,\n+                                                           userSearchFilter,\n+                                                           new Object[]{user},\n+                                                           SEARCH_CONTROLS);\n+      if (results.hasMoreElements()) {\n+        SearchResult result \u003d results.nextElement();\n+        String userDn \u003d result.getNameInNamespace();\n+\n+        NamingEnumeration\u003cSearchResult\u003e groupResults \u003d\n+          ctx.search(baseDN,\n+                     \"(\u0026\" + groupSearchFilter + \"(\" + groupMemberAttr + \"\u003d{0}))\",\n+                     new Object[]{userDn},\n+                     SEARCH_CONTROLS);\n+        while (groupResults.hasMoreElements()) {\n+          SearchResult groupResult \u003d groupResults.nextElement();\n+          Attribute groupName \u003d groupResult.getAttributes().get(groupNameAttr);\n+          groups.add(groupName.get().toString());\n+        }\n+      }\n+    } catch (NamingException e) {\n+      LOG.warn(\"Exception trying to get groups for user \" + user, e);\n+      return new ArrayList\u003cString\u003e();\n+    }\n+\n+    return groups;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized List\u003cString\u003e getGroups(String user) throws IOException {\n    List\u003cString\u003e groups \u003d new ArrayList\u003cString\u003e();\n\n    try {\n      DirContext ctx \u003d getDirContext();\n\n      // Search for the user. We\u0027ll only ever need to look at the first result\n      NamingEnumeration\u003cSearchResult\u003e results \u003d ctx.search(baseDN,\n                                                           userSearchFilter,\n                                                           new Object[]{user},\n                                                           SEARCH_CONTROLS);\n      if (results.hasMoreElements()) {\n        SearchResult result \u003d results.nextElement();\n        String userDn \u003d result.getNameInNamespace();\n\n        NamingEnumeration\u003cSearchResult\u003e groupResults \u003d\n          ctx.search(baseDN,\n                     \"(\u0026\" + groupSearchFilter + \"(\" + groupMemberAttr + \"\u003d{0}))\",\n                     new Object[]{userDn},\n                     SEARCH_CONTROLS);\n        while (groupResults.hasMoreElements()) {\n          SearchResult groupResult \u003d groupResults.nextElement();\n          Attribute groupName \u003d groupResult.getAttributes().get(groupNameAttr);\n          groups.add(groupName.get().toString());\n        }\n      }\n    } catch (NamingException e) {\n      LOG.warn(\"Exception trying to get groups for user \" + user, e);\n      return new ArrayList\u003cString\u003e();\n    }\n\n    return groups;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/LdapGroupsMapping.java"
    }
  }
}