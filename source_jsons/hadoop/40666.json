{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "AllocationTagsManager.java",
  "functionName": "absorb",
  "functionId": "absorb___target-TypeToCountedTags__T__(modifiers-final)",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/constraint/AllocationTagsManager.java",
  "functionStartLine": 231,
  "functionEndLine": 261,
  "numCommitsSeen": 12,
  "timeTaken": 1167,
  "changeHistory": [
    "a08921ca6cb1dad98935808c8f474b654f861263"
  ],
  "changeHistoryShort": {
    "a08921ca6cb1dad98935808c8f474b654f861263": "Yintroduced"
  },
  "changeHistoryDetails": {
    "a08921ca6cb1dad98935808c8f474b654f861263": {
      "type": "Yintroduced",
      "commitMessage": "YARN-8002. Support NOT_SELF and ALL namespace types for allocation tag. (Weiwei Yang via wangda)\n\nChange-Id: I63b4e4192a95bf7ded98c54e46a2871c72869700\n",
      "commitDate": "19/03/18 11:04 AM",
      "commitName": "a08921ca6cb1dad98935808c8f474b654f861263",
      "commitAuthor": "Wangda Tan",
      "diff": "@@ -0,0 +1,31 @@\n+    protected void absorb(final TypeToCountedTags\u003cT\u003e target) {\n+      // No opt if the given target is null.\n+      if (target \u003d\u003d null || target.getTypeToTagsWithCount() \u003d\u003d null) {\n+        return;\n+      }\n+\n+      // Merge the target.\n+      Map\u003cT, Map\u003cString, Long\u003e\u003e targetMap \u003d target.getTypeToTagsWithCount();\n+      for (Map.Entry\u003cT, Map\u003cString, Long\u003e\u003e targetEntry :\n+          targetMap.entrySet()) {\n+        // Get a mutable copy, do not modify the target reference.\n+        Map\u003cString, Long\u003e copy \u003d Maps.newHashMap(targetEntry.getValue());\n+\n+        // If the target type doesn\u0027t exist in the current mapping,\n+        // add as a new entry.\n+        Map\u003cString, Long\u003e existingMapping \u003d\n+            this.typeToTagsWithCount.putIfAbsent(targetEntry.getKey(), copy);\n+        // There was a mapping for this target type,\n+        // do proper merging on the operator.\n+        if (existingMapping !\u003d null) {\n+          Map\u003cString, Long\u003e localMap \u003d\n+              this.typeToTagsWithCount.get(targetEntry.getKey());\n+          // Merge the target map to the inner map.\n+          Map\u003cString, Long\u003e targetValue \u003d targetEntry.getValue();\n+          for (Map.Entry\u003cString, Long\u003e entry : targetValue.entrySet()) {\n+            localMap.merge(entry.getKey(), entry.getValue(),\n+                (a, b) -\u003e Long.sum(a, b));\n+          }\n+        }\n+      }\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    protected void absorb(final TypeToCountedTags\u003cT\u003e target) {\n      // No opt if the given target is null.\n      if (target \u003d\u003d null || target.getTypeToTagsWithCount() \u003d\u003d null) {\n        return;\n      }\n\n      // Merge the target.\n      Map\u003cT, Map\u003cString, Long\u003e\u003e targetMap \u003d target.getTypeToTagsWithCount();\n      for (Map.Entry\u003cT, Map\u003cString, Long\u003e\u003e targetEntry :\n          targetMap.entrySet()) {\n        // Get a mutable copy, do not modify the target reference.\n        Map\u003cString, Long\u003e copy \u003d Maps.newHashMap(targetEntry.getValue());\n\n        // If the target type doesn\u0027t exist in the current mapping,\n        // add as a new entry.\n        Map\u003cString, Long\u003e existingMapping \u003d\n            this.typeToTagsWithCount.putIfAbsent(targetEntry.getKey(), copy);\n        // There was a mapping for this target type,\n        // do proper merging on the operator.\n        if (existingMapping !\u003d null) {\n          Map\u003cString, Long\u003e localMap \u003d\n              this.typeToTagsWithCount.get(targetEntry.getKey());\n          // Merge the target map to the inner map.\n          Map\u003cString, Long\u003e targetValue \u003d targetEntry.getValue();\n          for (Map.Entry\u003cString, Long\u003e entry : targetValue.entrySet()) {\n            localMap.merge(entry.getKey(), entry.getValue(),\n                (a, b) -\u003e Long.sum(a, b));\n          }\n        }\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/constraint/AllocationTagsManager.java"
    }
  }
}