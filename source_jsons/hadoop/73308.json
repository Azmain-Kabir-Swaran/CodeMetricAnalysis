{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "DecayRpcScheduler.java",
  "functionName": "decayCurrentCosts",
  "functionId": "decayCurrentCosts",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/DecayRpcScheduler.java",
  "functionStartLine": 425,
  "functionEndLine": 475,
  "numCommitsSeen": 36,
  "timeTaken": 3486,
  "changeHistory": [
    "129576f628d370def74e56112aba3a93e97bbf70",
    "9089790cabb4771198be0fe64c1317a3ff1c80f1",
    "2b2399d623539ab68e71a38fa9fbfc9a405bddb8",
    "4ca8859583839761663fc1fc1de1b3ce2e3fc5b5",
    "d95c6eb32cec7768ac418fb467b1198ccf3cf0dc",
    "e0a9e1bfb724b60af322666b8267c7a9121f84a7"
  ],
  "changeHistoryShort": {
    "129576f628d370def74e56112aba3a93e97bbf70": "Ymultichange(Yrename,Ybodychange)",
    "9089790cabb4771198be0fe64c1317a3ff1c80f1": "Ybodychange",
    "2b2399d623539ab68e71a38fa9fbfc9a405bddb8": "Ybodychange",
    "4ca8859583839761663fc1fc1de1b3ce2e3fc5b5": "Ybodychange",
    "d95c6eb32cec7768ac418fb467b1198ccf3cf0dc": "Ybodychange",
    "e0a9e1bfb724b60af322666b8267c7a9121f84a7": "Yintroduced"
  },
  "changeHistoryDetails": {
    "129576f628d370def74e56112aba3a93e97bbf70": {
      "type": "Ymultichange(Yrename,Ybodychange)",
      "commitMessage": "HDFS-14403. Cost-based extension to the RPC Fair Call Queue. Contributed by Christopher Gregorian.\n",
      "commitDate": "24/06/19 12:09 PM",
      "commitName": "129576f628d370def74e56112aba3a93e97bbf70",
      "commitAuthor": "Christopher Gregorian",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "HDFS-14403. Cost-based extension to the RPC Fair Call Queue. Contributed by Christopher Gregorian.\n",
          "commitDate": "24/06/19 12:09 PM",
          "commitName": "129576f628d370def74e56112aba3a93e97bbf70",
          "commitAuthor": "Christopher Gregorian",
          "commitDateOld": "23/05/19 10:28 AM",
          "commitNameOld": "f96a2df38d889f29314c57f4d94227b2e419a11f",
          "commitAuthorOld": "Christopher Gregorian",
          "daysBetweenCommits": 32.07,
          "commitsBetweenForRepo": 314,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,51 +1,51 @@\n-  private void decayCurrentCounts() {\n-    LOG.debug(\"Start to decay current counts.\");\n+  private void decayCurrentCosts() {\n+    LOG.debug(\"Start to decay current costs.\");\n     try {\n-      long totalDecayedCount \u003d 0;\n-      long totalRawCount \u003d 0;\n+      long totalDecayedCost \u003d 0;\n+      long totalRawCost \u003d 0;\n       Iterator\u003cMap.Entry\u003cObject, List\u003cAtomicLong\u003e\u003e\u003e it \u003d\n-          callCounts.entrySet().iterator();\n+          callCosts.entrySet().iterator();\n \n       while (it.hasNext()) {\n         Map.Entry\u003cObject, List\u003cAtomicLong\u003e\u003e entry \u003d it.next();\n-        AtomicLong decayedCount \u003d entry.getValue().get(0);\n-        AtomicLong rawCount \u003d entry.getValue().get(1);\n+        AtomicLong decayedCost \u003d entry.getValue().get(0);\n+        AtomicLong rawCost \u003d entry.getValue().get(1);\n \n \n         // Compute the next value by reducing it by the decayFactor\n-        totalRawCount +\u003d rawCount.get();\n-        long currentValue \u003d decayedCount.get();\n+        totalRawCost +\u003d rawCost.get();\n+        long currentValue \u003d decayedCost.get();\n         long nextValue \u003d (long) (currentValue * decayFactor);\n-        totalDecayedCount +\u003d nextValue;\n-        decayedCount.set(nextValue);\n+        totalDecayedCost +\u003d nextValue;\n+        decayedCost.set(nextValue);\n \n-        LOG.debug(\"Decaying counts for the user: {}, \" +\n-            \"its decayedCount: {}, rawCount: {}\", entry.getKey(),\n-            nextValue, rawCount.get());\n+        LOG.debug(\n+            \"Decaying costs for the user: {}, its decayedCost: {}, rawCost: {}\",\n+            entry.getKey(), nextValue, rawCost.get());\n         if (nextValue \u003d\u003d 0) {\n-          LOG.debug(\"The decayed count for the user {} is zero \" +\n+          LOG.debug(\"The decayed cost for the user {} is zero \" +\n               \"and being cleaned.\", entry.getKey());\n           // We will clean up unused keys here. An interesting optimization\n-          // might be to have an upper bound on keyspace in callCounts and only\n+          // might be to have an upper bound on keyspace in callCosts and only\n           // clean once we pass it.\n           it.remove();\n         }\n       }\n \n       // Update the total so that we remain in sync\n-      totalDecayedCallCount.set(totalDecayedCount);\n-      totalRawCallCount.set(totalRawCount);\n+      totalDecayedCallCost.set(totalDecayedCost);\n+      totalRawCallCost.set(totalRawCost);\n \n-      LOG.debug(\"After decaying the stored counts, totalDecayedCount: {}, \" +\n-          \"totalRawCallCount: {}.\", totalDecayedCount, totalRawCount);\n+      LOG.debug(\"After decaying the stored costs, totalDecayedCost: {}, \" +\n+          \"totalRawCallCost: {}.\", totalDecayedCost, totalRawCost);\n       // Now refresh the cache of scheduling decisions\n       recomputeScheduleCache();\n \n       // Update average response time with decay\n       updateAverageResponseTime(true);\n     } catch (Exception ex) {\n-      LOG.error(\"decayCurrentCounts exception: \" +\n+      LOG.error(\"decayCurrentCosts exception: \" +\n           ExceptionUtils.getStackTrace(ex));\n       throw ex;\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void decayCurrentCosts() {\n    LOG.debug(\"Start to decay current costs.\");\n    try {\n      long totalDecayedCost \u003d 0;\n      long totalRawCost \u003d 0;\n      Iterator\u003cMap.Entry\u003cObject, List\u003cAtomicLong\u003e\u003e\u003e it \u003d\n          callCosts.entrySet().iterator();\n\n      while (it.hasNext()) {\n        Map.Entry\u003cObject, List\u003cAtomicLong\u003e\u003e entry \u003d it.next();\n        AtomicLong decayedCost \u003d entry.getValue().get(0);\n        AtomicLong rawCost \u003d entry.getValue().get(1);\n\n\n        // Compute the next value by reducing it by the decayFactor\n        totalRawCost +\u003d rawCost.get();\n        long currentValue \u003d decayedCost.get();\n        long nextValue \u003d (long) (currentValue * decayFactor);\n        totalDecayedCost +\u003d nextValue;\n        decayedCost.set(nextValue);\n\n        LOG.debug(\n            \"Decaying costs for the user: {}, its decayedCost: {}, rawCost: {}\",\n            entry.getKey(), nextValue, rawCost.get());\n        if (nextValue \u003d\u003d 0) {\n          LOG.debug(\"The decayed cost for the user {} is zero \" +\n              \"and being cleaned.\", entry.getKey());\n          // We will clean up unused keys here. An interesting optimization\n          // might be to have an upper bound on keyspace in callCosts and only\n          // clean once we pass it.\n          it.remove();\n        }\n      }\n\n      // Update the total so that we remain in sync\n      totalDecayedCallCost.set(totalDecayedCost);\n      totalRawCallCost.set(totalRawCost);\n\n      LOG.debug(\"After decaying the stored costs, totalDecayedCost: {}, \" +\n          \"totalRawCallCost: {}.\", totalDecayedCost, totalRawCost);\n      // Now refresh the cache of scheduling decisions\n      recomputeScheduleCache();\n\n      // Update average response time with decay\n      updateAverageResponseTime(true);\n    } catch (Exception ex) {\n      LOG.error(\"decayCurrentCosts exception: \" +\n          ExceptionUtils.getStackTrace(ex));\n      throw ex;\n    }\n  }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/DecayRpcScheduler.java",
          "extendedDetails": {
            "oldValue": "decayCurrentCounts",
            "newValue": "decayCurrentCosts"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-14403. Cost-based extension to the RPC Fair Call Queue. Contributed by Christopher Gregorian.\n",
          "commitDate": "24/06/19 12:09 PM",
          "commitName": "129576f628d370def74e56112aba3a93e97bbf70",
          "commitAuthor": "Christopher Gregorian",
          "commitDateOld": "23/05/19 10:28 AM",
          "commitNameOld": "f96a2df38d889f29314c57f4d94227b2e419a11f",
          "commitAuthorOld": "Christopher Gregorian",
          "daysBetweenCommits": 32.07,
          "commitsBetweenForRepo": 314,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,51 +1,51 @@\n-  private void decayCurrentCounts() {\n-    LOG.debug(\"Start to decay current counts.\");\n+  private void decayCurrentCosts() {\n+    LOG.debug(\"Start to decay current costs.\");\n     try {\n-      long totalDecayedCount \u003d 0;\n-      long totalRawCount \u003d 0;\n+      long totalDecayedCost \u003d 0;\n+      long totalRawCost \u003d 0;\n       Iterator\u003cMap.Entry\u003cObject, List\u003cAtomicLong\u003e\u003e\u003e it \u003d\n-          callCounts.entrySet().iterator();\n+          callCosts.entrySet().iterator();\n \n       while (it.hasNext()) {\n         Map.Entry\u003cObject, List\u003cAtomicLong\u003e\u003e entry \u003d it.next();\n-        AtomicLong decayedCount \u003d entry.getValue().get(0);\n-        AtomicLong rawCount \u003d entry.getValue().get(1);\n+        AtomicLong decayedCost \u003d entry.getValue().get(0);\n+        AtomicLong rawCost \u003d entry.getValue().get(1);\n \n \n         // Compute the next value by reducing it by the decayFactor\n-        totalRawCount +\u003d rawCount.get();\n-        long currentValue \u003d decayedCount.get();\n+        totalRawCost +\u003d rawCost.get();\n+        long currentValue \u003d decayedCost.get();\n         long nextValue \u003d (long) (currentValue * decayFactor);\n-        totalDecayedCount +\u003d nextValue;\n-        decayedCount.set(nextValue);\n+        totalDecayedCost +\u003d nextValue;\n+        decayedCost.set(nextValue);\n \n-        LOG.debug(\"Decaying counts for the user: {}, \" +\n-            \"its decayedCount: {}, rawCount: {}\", entry.getKey(),\n-            nextValue, rawCount.get());\n+        LOG.debug(\n+            \"Decaying costs for the user: {}, its decayedCost: {}, rawCost: {}\",\n+            entry.getKey(), nextValue, rawCost.get());\n         if (nextValue \u003d\u003d 0) {\n-          LOG.debug(\"The decayed count for the user {} is zero \" +\n+          LOG.debug(\"The decayed cost for the user {} is zero \" +\n               \"and being cleaned.\", entry.getKey());\n           // We will clean up unused keys here. An interesting optimization\n-          // might be to have an upper bound on keyspace in callCounts and only\n+          // might be to have an upper bound on keyspace in callCosts and only\n           // clean once we pass it.\n           it.remove();\n         }\n       }\n \n       // Update the total so that we remain in sync\n-      totalDecayedCallCount.set(totalDecayedCount);\n-      totalRawCallCount.set(totalRawCount);\n+      totalDecayedCallCost.set(totalDecayedCost);\n+      totalRawCallCost.set(totalRawCost);\n \n-      LOG.debug(\"After decaying the stored counts, totalDecayedCount: {}, \" +\n-          \"totalRawCallCount: {}.\", totalDecayedCount, totalRawCount);\n+      LOG.debug(\"After decaying the stored costs, totalDecayedCost: {}, \" +\n+          \"totalRawCallCost: {}.\", totalDecayedCost, totalRawCost);\n       // Now refresh the cache of scheduling decisions\n       recomputeScheduleCache();\n \n       // Update average response time with decay\n       updateAverageResponseTime(true);\n     } catch (Exception ex) {\n-      LOG.error(\"decayCurrentCounts exception: \" +\n+      LOG.error(\"decayCurrentCosts exception: \" +\n           ExceptionUtils.getStackTrace(ex));\n       throw ex;\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void decayCurrentCosts() {\n    LOG.debug(\"Start to decay current costs.\");\n    try {\n      long totalDecayedCost \u003d 0;\n      long totalRawCost \u003d 0;\n      Iterator\u003cMap.Entry\u003cObject, List\u003cAtomicLong\u003e\u003e\u003e it \u003d\n          callCosts.entrySet().iterator();\n\n      while (it.hasNext()) {\n        Map.Entry\u003cObject, List\u003cAtomicLong\u003e\u003e entry \u003d it.next();\n        AtomicLong decayedCost \u003d entry.getValue().get(0);\n        AtomicLong rawCost \u003d entry.getValue().get(1);\n\n\n        // Compute the next value by reducing it by the decayFactor\n        totalRawCost +\u003d rawCost.get();\n        long currentValue \u003d decayedCost.get();\n        long nextValue \u003d (long) (currentValue * decayFactor);\n        totalDecayedCost +\u003d nextValue;\n        decayedCost.set(nextValue);\n\n        LOG.debug(\n            \"Decaying costs for the user: {}, its decayedCost: {}, rawCost: {}\",\n            entry.getKey(), nextValue, rawCost.get());\n        if (nextValue \u003d\u003d 0) {\n          LOG.debug(\"The decayed cost for the user {} is zero \" +\n              \"and being cleaned.\", entry.getKey());\n          // We will clean up unused keys here. An interesting optimization\n          // might be to have an upper bound on keyspace in callCosts and only\n          // clean once we pass it.\n          it.remove();\n        }\n      }\n\n      // Update the total so that we remain in sync\n      totalDecayedCallCost.set(totalDecayedCost);\n      totalRawCallCost.set(totalRawCost);\n\n      LOG.debug(\"After decaying the stored costs, totalDecayedCost: {}, \" +\n          \"totalRawCallCost: {}.\", totalDecayedCost, totalRawCost);\n      // Now refresh the cache of scheduling decisions\n      recomputeScheduleCache();\n\n      // Update average response time with decay\n      updateAverageResponseTime(true);\n    } catch (Exception ex) {\n      LOG.error(\"decayCurrentCosts exception: \" +\n          ExceptionUtils.getStackTrace(ex));\n      throw ex;\n    }\n  }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/DecayRpcScheduler.java",
          "extendedDetails": {}
        }
      ]
    },
    "9089790cabb4771198be0fe64c1317a3ff1c80f1": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15611. Log more details for FairCallQueue. Contributed by Ryan Wu.\n",
      "commitDate": "26/07/18 3:08 AM",
      "commitName": "9089790cabb4771198be0fe64c1317a3ff1c80f1",
      "commitAuthor": "Yiqun Lin",
      "commitDateOld": "27/06/18 10:37 PM",
      "commitNameOld": "2b2399d623539ab68e71a38fa9fbfc9a405bddb8",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 28.19,
      "commitsBetweenForRepo": 176,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,43 +1,51 @@\n   private void decayCurrentCounts() {\n+    LOG.debug(\"Start to decay current counts.\");\n     try {\n       long totalDecayedCount \u003d 0;\n       long totalRawCount \u003d 0;\n       Iterator\u003cMap.Entry\u003cObject, List\u003cAtomicLong\u003e\u003e\u003e it \u003d\n           callCounts.entrySet().iterator();\n \n       while (it.hasNext()) {\n         Map.Entry\u003cObject, List\u003cAtomicLong\u003e\u003e entry \u003d it.next();\n         AtomicLong decayedCount \u003d entry.getValue().get(0);\n         AtomicLong rawCount \u003d entry.getValue().get(1);\n \n \n         // Compute the next value by reducing it by the decayFactor\n         totalRawCount +\u003d rawCount.get();\n         long currentValue \u003d decayedCount.get();\n         long nextValue \u003d (long) (currentValue * decayFactor);\n         totalDecayedCount +\u003d nextValue;\n         decayedCount.set(nextValue);\n \n+        LOG.debug(\"Decaying counts for the user: {}, \" +\n+            \"its decayedCount: {}, rawCount: {}\", entry.getKey(),\n+            nextValue, rawCount.get());\n         if (nextValue \u003d\u003d 0) {\n+          LOG.debug(\"The decayed count for the user {} is zero \" +\n+              \"and being cleaned.\", entry.getKey());\n           // We will clean up unused keys here. An interesting optimization\n           // might be to have an upper bound on keyspace in callCounts and only\n           // clean once we pass it.\n           it.remove();\n         }\n       }\n \n       // Update the total so that we remain in sync\n       totalDecayedCallCount.set(totalDecayedCount);\n       totalRawCallCount.set(totalRawCount);\n \n+      LOG.debug(\"After decaying the stored counts, totalDecayedCount: {}, \" +\n+          \"totalRawCallCount: {}.\", totalDecayedCount, totalRawCount);\n       // Now refresh the cache of scheduling decisions\n       recomputeScheduleCache();\n \n       // Update average response time with decay\n       updateAverageResponseTime(true);\n     } catch (Exception ex) {\n       LOG.error(\"decayCurrentCounts exception: \" +\n           ExceptionUtils.getStackTrace(ex));\n       throw ex;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void decayCurrentCounts() {\n    LOG.debug(\"Start to decay current counts.\");\n    try {\n      long totalDecayedCount \u003d 0;\n      long totalRawCount \u003d 0;\n      Iterator\u003cMap.Entry\u003cObject, List\u003cAtomicLong\u003e\u003e\u003e it \u003d\n          callCounts.entrySet().iterator();\n\n      while (it.hasNext()) {\n        Map.Entry\u003cObject, List\u003cAtomicLong\u003e\u003e entry \u003d it.next();\n        AtomicLong decayedCount \u003d entry.getValue().get(0);\n        AtomicLong rawCount \u003d entry.getValue().get(1);\n\n\n        // Compute the next value by reducing it by the decayFactor\n        totalRawCount +\u003d rawCount.get();\n        long currentValue \u003d decayedCount.get();\n        long nextValue \u003d (long) (currentValue * decayFactor);\n        totalDecayedCount +\u003d nextValue;\n        decayedCount.set(nextValue);\n\n        LOG.debug(\"Decaying counts for the user: {}, \" +\n            \"its decayedCount: {}, rawCount: {}\", entry.getKey(),\n            nextValue, rawCount.get());\n        if (nextValue \u003d\u003d 0) {\n          LOG.debug(\"The decayed count for the user {} is zero \" +\n              \"and being cleaned.\", entry.getKey());\n          // We will clean up unused keys here. An interesting optimization\n          // might be to have an upper bound on keyspace in callCounts and only\n          // clean once we pass it.\n          it.remove();\n        }\n      }\n\n      // Update the total so that we remain in sync\n      totalDecayedCallCount.set(totalDecayedCount);\n      totalRawCallCount.set(totalRawCount);\n\n      LOG.debug(\"After decaying the stored counts, totalDecayedCount: {}, \" +\n          \"totalRawCallCount: {}.\", totalDecayedCount, totalRawCount);\n      // Now refresh the cache of scheduling decisions\n      recomputeScheduleCache();\n\n      // Update average response time with decay\n      updateAverageResponseTime(true);\n    } catch (Exception ex) {\n      LOG.error(\"decayCurrentCounts exception: \" +\n          ExceptionUtils.getStackTrace(ex));\n      throw ex;\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/DecayRpcScheduler.java",
      "extendedDetails": {}
    },
    "2b2399d623539ab68e71a38fa9fbfc9a405bddb8": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15495. Upgrade commons-lang version to 3.7 in hadoop-common-project and hadoop-tools. Contributed by Takanobu Asanuma.\n",
      "commitDate": "27/06/18 10:37 PM",
      "commitName": "2b2399d623539ab68e71a38fa9fbfc9a405bddb8",
      "commitAuthor": "Akira Ajisaka",
      "commitDateOld": "22/01/18 3:54 PM",
      "commitNameOld": "3fde0f1db599227773c0cd537b33312d368ad4d9",
      "commitAuthorOld": "Hanisha Koneru",
      "daysBetweenCommits": 156.24,
      "commitsBetweenForRepo": 1723,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,43 +1,43 @@\n   private void decayCurrentCounts() {\n     try {\n       long totalDecayedCount \u003d 0;\n       long totalRawCount \u003d 0;\n       Iterator\u003cMap.Entry\u003cObject, List\u003cAtomicLong\u003e\u003e\u003e it \u003d\n           callCounts.entrySet().iterator();\n \n       while (it.hasNext()) {\n         Map.Entry\u003cObject, List\u003cAtomicLong\u003e\u003e entry \u003d it.next();\n         AtomicLong decayedCount \u003d entry.getValue().get(0);\n         AtomicLong rawCount \u003d entry.getValue().get(1);\n \n \n         // Compute the next value by reducing it by the decayFactor\n         totalRawCount +\u003d rawCount.get();\n         long currentValue \u003d decayedCount.get();\n         long nextValue \u003d (long) (currentValue * decayFactor);\n         totalDecayedCount +\u003d nextValue;\n         decayedCount.set(nextValue);\n \n         if (nextValue \u003d\u003d 0) {\n           // We will clean up unused keys here. An interesting optimization\n           // might be to have an upper bound on keyspace in callCounts and only\n           // clean once we pass it.\n           it.remove();\n         }\n       }\n \n       // Update the total so that we remain in sync\n       totalDecayedCallCount.set(totalDecayedCount);\n       totalRawCallCount.set(totalRawCount);\n \n       // Now refresh the cache of scheduling decisions\n       recomputeScheduleCache();\n \n       // Update average response time with decay\n       updateAverageResponseTime(true);\n     } catch (Exception ex) {\n       LOG.error(\"decayCurrentCounts exception: \" +\n-          ExceptionUtils.getFullStackTrace(ex));\n+          ExceptionUtils.getStackTrace(ex));\n       throw ex;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void decayCurrentCounts() {\n    try {\n      long totalDecayedCount \u003d 0;\n      long totalRawCount \u003d 0;\n      Iterator\u003cMap.Entry\u003cObject, List\u003cAtomicLong\u003e\u003e\u003e it \u003d\n          callCounts.entrySet().iterator();\n\n      while (it.hasNext()) {\n        Map.Entry\u003cObject, List\u003cAtomicLong\u003e\u003e entry \u003d it.next();\n        AtomicLong decayedCount \u003d entry.getValue().get(0);\n        AtomicLong rawCount \u003d entry.getValue().get(1);\n\n\n        // Compute the next value by reducing it by the decayFactor\n        totalRawCount +\u003d rawCount.get();\n        long currentValue \u003d decayedCount.get();\n        long nextValue \u003d (long) (currentValue * decayFactor);\n        totalDecayedCount +\u003d nextValue;\n        decayedCount.set(nextValue);\n\n        if (nextValue \u003d\u003d 0) {\n          // We will clean up unused keys here. An interesting optimization\n          // might be to have an upper bound on keyspace in callCounts and only\n          // clean once we pass it.\n          it.remove();\n        }\n      }\n\n      // Update the total so that we remain in sync\n      totalDecayedCallCount.set(totalDecayedCount);\n      totalRawCallCount.set(totalRawCount);\n\n      // Now refresh the cache of scheduling decisions\n      recomputeScheduleCache();\n\n      // Update average response time with decay\n      updateAverageResponseTime(true);\n    } catch (Exception ex) {\n      LOG.error(\"decayCurrentCounts exception: \" +\n          ExceptionUtils.getStackTrace(ex));\n      throw ex;\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/DecayRpcScheduler.java",
      "extendedDetails": {}
    },
    "4ca8859583839761663fc1fc1de1b3ce2e3fc5b5": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13197. Add non-decayed call metrics for DecayRpcScheduler. Contributed by Xiaoyu Yao.\n",
      "commitDate": "27/05/16 6:07 PM",
      "commitName": "4ca8859583839761663fc1fc1de1b3ce2e3fc5b5",
      "commitAuthor": "Xiaoyu Yao",
      "commitDateOld": "17/05/16 2:58 PM",
      "commitNameOld": "94784848456a92a6502f3a3c0074e44fba4b19c9",
      "commitAuthorOld": "Xiaoyu Yao",
      "daysBetweenCommits": 10.13,
      "commitsBetweenForRepo": 84,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,43 @@\n   private void decayCurrentCounts() {\n     try {\n-      long total \u003d 0;\n-      Iterator\u003cMap.Entry\u003cObject, AtomicLong\u003e\u003e it \u003d\n+      long totalDecayedCount \u003d 0;\n+      long totalRawCount \u003d 0;\n+      Iterator\u003cMap.Entry\u003cObject, List\u003cAtomicLong\u003e\u003e\u003e it \u003d\n           callCounts.entrySet().iterator();\n \n       while (it.hasNext()) {\n-        Map.Entry\u003cObject, AtomicLong\u003e entry \u003d it.next();\n-        AtomicLong count \u003d entry.getValue();\n+        Map.Entry\u003cObject, List\u003cAtomicLong\u003e\u003e entry \u003d it.next();\n+        AtomicLong decayedCount \u003d entry.getValue().get(0);\n+        AtomicLong rawCount \u003d entry.getValue().get(1);\n+\n \n         // Compute the next value by reducing it by the decayFactor\n-        long currentValue \u003d count.get();\n+        totalRawCount +\u003d rawCount.get();\n+        long currentValue \u003d decayedCount.get();\n         long nextValue \u003d (long) (currentValue * decayFactor);\n-        total +\u003d nextValue;\n-        count.set(nextValue);\n+        totalDecayedCount +\u003d nextValue;\n+        decayedCount.set(nextValue);\n \n         if (nextValue \u003d\u003d 0) {\n           // We will clean up unused keys here. An interesting optimization\n           // might be to have an upper bound on keyspace in callCounts and only\n           // clean once we pass it.\n           it.remove();\n         }\n       }\n \n       // Update the total so that we remain in sync\n-      totalCalls.set(total);\n+      totalDecayedCallCount.set(totalDecayedCount);\n+      totalRawCallCount.set(totalRawCount);\n \n       // Now refresh the cache of scheduling decisions\n       recomputeScheduleCache();\n \n       // Update average response time with decay\n       updateAverageResponseTime(true);\n     } catch (Exception ex) {\n       LOG.error(\"decayCurrentCounts exception: \" +\n           ExceptionUtils.getFullStackTrace(ex));\n       throw ex;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void decayCurrentCounts() {\n    try {\n      long totalDecayedCount \u003d 0;\n      long totalRawCount \u003d 0;\n      Iterator\u003cMap.Entry\u003cObject, List\u003cAtomicLong\u003e\u003e\u003e it \u003d\n          callCounts.entrySet().iterator();\n\n      while (it.hasNext()) {\n        Map.Entry\u003cObject, List\u003cAtomicLong\u003e\u003e entry \u003d it.next();\n        AtomicLong decayedCount \u003d entry.getValue().get(0);\n        AtomicLong rawCount \u003d entry.getValue().get(1);\n\n\n        // Compute the next value by reducing it by the decayFactor\n        totalRawCount +\u003d rawCount.get();\n        long currentValue \u003d decayedCount.get();\n        long nextValue \u003d (long) (currentValue * decayFactor);\n        totalDecayedCount +\u003d nextValue;\n        decayedCount.set(nextValue);\n\n        if (nextValue \u003d\u003d 0) {\n          // We will clean up unused keys here. An interesting optimization\n          // might be to have an upper bound on keyspace in callCounts and only\n          // clean once we pass it.\n          it.remove();\n        }\n      }\n\n      // Update the total so that we remain in sync\n      totalDecayedCallCount.set(totalDecayedCount);\n      totalRawCallCount.set(totalRawCount);\n\n      // Now refresh the cache of scheduling decisions\n      recomputeScheduleCache();\n\n      // Update average response time with decay\n      updateAverageResponseTime(true);\n    } catch (Exception ex) {\n      LOG.error(\"decayCurrentCounts exception: \" +\n          ExceptionUtils.getFullStackTrace(ex));\n      throw ex;\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/DecayRpcScheduler.java",
      "extendedDetails": {}
    },
    "d95c6eb32cec7768ac418fb467b1198ccf3cf0dc": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-12916. Allow RPC scheduler/callqueue backoff using response times. Contributed by Xiaoyu Yao.\n",
      "commitDate": "31/03/16 8:42 AM",
      "commitName": "d95c6eb32cec7768ac418fb467b1198ccf3cf0dc",
      "commitAuthor": "Xiaoyu Yao",
      "commitDateOld": "01/12/15 9:27 AM",
      "commitNameOld": "485c3468a8520fcde14800af3e4a075231c946de",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 120.93,
      "commitsBetweenForRepo": 745,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,38 @@\n   private void decayCurrentCounts() {\n-    long total \u003d 0;\n-    Iterator\u003cMap.Entry\u003cObject, AtomicLong\u003e\u003e it \u003d\n-      callCounts.entrySet().iterator();\n+    try {\n+      long total \u003d 0;\n+      Iterator\u003cMap.Entry\u003cObject, AtomicLong\u003e\u003e it \u003d\n+          callCounts.entrySet().iterator();\n \n-    while (it.hasNext()) {\n-      Map.Entry\u003cObject, AtomicLong\u003e entry \u003d it.next();\n-      AtomicLong count \u003d entry.getValue();\n+      while (it.hasNext()) {\n+        Map.Entry\u003cObject, AtomicLong\u003e entry \u003d it.next();\n+        AtomicLong count \u003d entry.getValue();\n \n-      // Compute the next value by reducing it by the decayFactor\n-      long currentValue \u003d count.get();\n-      long nextValue \u003d (long)(currentValue * decayFactor);\n-      total +\u003d nextValue;\n-      count.set(nextValue);\n+        // Compute the next value by reducing it by the decayFactor\n+        long currentValue \u003d count.get();\n+        long nextValue \u003d (long) (currentValue * decayFactor);\n+        total +\u003d nextValue;\n+        count.set(nextValue);\n \n-      if (nextValue \u003d\u003d 0) {\n-        // We will clean up unused keys here. An interesting optimization might\n-        // be to have an upper bound on keyspace in callCounts and only\n-        // clean once we pass it.\n-        it.remove();\n+        if (nextValue \u003d\u003d 0) {\n+          // We will clean up unused keys here. An interesting optimization\n+          // might be to have an upper bound on keyspace in callCounts and only\n+          // clean once we pass it.\n+          it.remove();\n+        }\n       }\n+\n+      // Update the total so that we remain in sync\n+      totalCalls.set(total);\n+\n+      // Now refresh the cache of scheduling decisions\n+      recomputeScheduleCache();\n+\n+      // Update average response time with decay\n+      updateAverageResponseTime(true);\n+    } catch (Exception ex) {\n+      LOG.error(\"decayCurrentCounts exception: \" +\n+          ExceptionUtils.getFullStackTrace(ex));\n+      throw ex;\n     }\n-\n-    // Update the total so that we remain in sync\n-    totalCalls.set(total);\n-\n-    // Now refresh the cache of scheduling decisions\n-    recomputeScheduleCache();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void decayCurrentCounts() {\n    try {\n      long total \u003d 0;\n      Iterator\u003cMap.Entry\u003cObject, AtomicLong\u003e\u003e it \u003d\n          callCounts.entrySet().iterator();\n\n      while (it.hasNext()) {\n        Map.Entry\u003cObject, AtomicLong\u003e entry \u003d it.next();\n        AtomicLong count \u003d entry.getValue();\n\n        // Compute the next value by reducing it by the decayFactor\n        long currentValue \u003d count.get();\n        long nextValue \u003d (long) (currentValue * decayFactor);\n        total +\u003d nextValue;\n        count.set(nextValue);\n\n        if (nextValue \u003d\u003d 0) {\n          // We will clean up unused keys here. An interesting optimization\n          // might be to have an upper bound on keyspace in callCounts and only\n          // clean once we pass it.\n          it.remove();\n        }\n      }\n\n      // Update the total so that we remain in sync\n      totalCalls.set(total);\n\n      // Now refresh the cache of scheduling decisions\n      recomputeScheduleCache();\n\n      // Update average response time with decay\n      updateAverageResponseTime(true);\n    } catch (Exception ex) {\n      LOG.error(\"decayCurrentCounts exception: \" +\n          ExceptionUtils.getFullStackTrace(ex));\n      throw ex;\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/DecayRpcScheduler.java",
      "extendedDetails": {}
    },
    "e0a9e1bfb724b60af322666b8267c7a9121f84a7": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-10281. Create a scheduler, which assigns schedulables a priority level. (Contributed by Chris Li)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1617643 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/08/14 5:54 PM",
      "commitName": "e0a9e1bfb724b60af322666b8267c7a9121f84a7",
      "commitAuthor": "Arpit Agarwal",
      "diff": "@@ -0,0 +1,29 @@\n+  private void decayCurrentCounts() {\n+    long total \u003d 0;\n+    Iterator\u003cMap.Entry\u003cObject, AtomicLong\u003e\u003e it \u003d\n+      callCounts.entrySet().iterator();\n+\n+    while (it.hasNext()) {\n+      Map.Entry\u003cObject, AtomicLong\u003e entry \u003d it.next();\n+      AtomicLong count \u003d entry.getValue();\n+\n+      // Compute the next value by reducing it by the decayFactor\n+      long currentValue \u003d count.get();\n+      long nextValue \u003d (long)(currentValue * decayFactor);\n+      total +\u003d nextValue;\n+      count.set(nextValue);\n+\n+      if (nextValue \u003d\u003d 0) {\n+        // We will clean up unused keys here. An interesting optimization might\n+        // be to have an upper bound on keyspace in callCounts and only\n+        // clean once we pass it.\n+        it.remove();\n+      }\n+    }\n+\n+    // Update the total so that we remain in sync\n+    totalCalls.set(total);\n+\n+    // Now refresh the cache of scheduling decisions\n+    recomputeScheduleCache();\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void decayCurrentCounts() {\n    long total \u003d 0;\n    Iterator\u003cMap.Entry\u003cObject, AtomicLong\u003e\u003e it \u003d\n      callCounts.entrySet().iterator();\n\n    while (it.hasNext()) {\n      Map.Entry\u003cObject, AtomicLong\u003e entry \u003d it.next();\n      AtomicLong count \u003d entry.getValue();\n\n      // Compute the next value by reducing it by the decayFactor\n      long currentValue \u003d count.get();\n      long nextValue \u003d (long)(currentValue * decayFactor);\n      total +\u003d nextValue;\n      count.set(nextValue);\n\n      if (nextValue \u003d\u003d 0) {\n        // We will clean up unused keys here. An interesting optimization might\n        // be to have an upper bound on keyspace in callCounts and only\n        // clean once we pass it.\n        it.remove();\n      }\n    }\n\n    // Update the total so that we remain in sync\n    totalCalls.set(total);\n\n    // Now refresh the cache of scheduling decisions\n    recomputeScheduleCache();\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/DecayRpcScheduler.java"
    }
  }
}