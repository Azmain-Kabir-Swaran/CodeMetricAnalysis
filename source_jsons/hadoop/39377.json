{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "GuaranteedOrZeroCapacityOverTimePolicy.java",
  "functionName": "updateLeafQueueState",
  "functionId": "updateLeafQueueState",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/queuemanagement/GuaranteedOrZeroCapacityOverTimePolicy.java",
  "functionStartLine": 487,
  "functionEndLine": 534,
  "numCommitsSeen": 7,
  "timeTaken": 3637,
  "changeHistory": [
    "cdb2107066a2d8557270888c0a9a75f29a6853bf",
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635",
    "344c335a920e6f32a35ebace0a118a9dc4a22fb7",
    "821b0de4c59156d4a65112de03ba3e7e1c88e309",
    "b38643c9a8dd2c53024ae830b9565a550d0ec39c"
  ],
  "changeHistoryShort": {
    "cdb2107066a2d8557270888c0a9a75f29a6853bf": "Ybodychange",
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635": "Ybodychange",
    "344c335a920e6f32a35ebace0a118a9dc4a22fb7": "Ybodychange",
    "821b0de4c59156d4a65112de03ba3e7e1c88e309": "Ybodychange",
    "b38643c9a8dd2c53024ae830b9565a550d0ec39c": "Yintroduced"
  },
  "changeHistoryDetails": {
    "cdb2107066a2d8557270888c0a9a75f29a6853bf": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9879. Allow multiple leaf queues with the same name in CapacityScheduler. Contributed by Gergely Pollak.\n",
      "commitDate": "25/03/20 4:20 AM",
      "commitName": "cdb2107066a2d8557270888c0a9a75f29a6853bf",
      "commitAuthor": "Sunil G",
      "commitDateOld": "18/03/19 10:57 AM",
      "commitNameOld": "5f6e22516668ff94a76737ad5e2cdcb2ff9f6dfd",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 372.72,
      "commitsBetweenForRepo": 2179,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,48 +1,48 @@\n   void updateLeafQueueState() {\n     writeLock.lock();\n     try {\n       Set\u003cString\u003e newPartitions \u003d new HashSet\u003c\u003e();\n       Set\u003cString\u003e newQueues \u003d new HashSet\u003c\u003e();\n \n       for (CSQueue newQueue : managedParentQueue.getChildQueues()) {\n         if (newQueue instanceof LeafQueue) {\n           for (String nodeLabel : leafQueueTemplateNodeLabels) {\n             leafQueueState.createLeafQueueStateIfNotExists((LeafQueue) newQueue,\n                 nodeLabel);\n             newPartitions.add(nodeLabel);\n           }\n-          newQueues.add(newQueue.getQueueName());\n+          newQueues.add(newQueue.getQueuePath());\n         }\n       }\n \n       for (Iterator\u003cMap.Entry\u003cString, Map\u003cString, LeafQueueStatePerPartition\u003e\u003e\u003e\n            itr \u003d leafQueueState.getLeafQueueStateMap().entrySet().iterator();\n            itr.hasNext(); ) {\n         Map.Entry\u003cString, Map\u003cString, LeafQueueStatePerPartition\u003e\u003e e \u003d\n             itr.next();\n         String partition \u003d e.getKey();\n         if (!newPartitions.contains(partition)) {\n           itr.remove();\n-          LOG.info(managedParentQueue.getQueueName()  +\n+          LOG.info(managedParentQueue.getQueuePath()  +\n               \" : Removed partition \" + partition + \" from leaf queue \" +\n               \"state\");\n         } else{\n           Map\u003cString, LeafQueueStatePerPartition\u003e queues \u003d e.getValue();\n           for (\n               Iterator\u003cMap.Entry\u003cString, LeafQueueStatePerPartition\u003e\u003e queueItr \u003d\n               queues.entrySet().iterator(); queueItr.hasNext(); ) {\n             String queue \u003d queueItr.next().getKey();\n             if (!newQueues.contains(queue)) {\n               queueItr.remove();\n-              LOG.info(managedParentQueue.getQueueName() + \" : Removed queue\"\n+              LOG.info(managedParentQueue.getQueuePath() + \" : Removed queue\"\n                   + queue + \" from \"\n                   + \"leaf queue \"\n                   + \"state from partition \" + partition);\n             }\n           }\n         }\n       }\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void updateLeafQueueState() {\n    writeLock.lock();\n    try {\n      Set\u003cString\u003e newPartitions \u003d new HashSet\u003c\u003e();\n      Set\u003cString\u003e newQueues \u003d new HashSet\u003c\u003e();\n\n      for (CSQueue newQueue : managedParentQueue.getChildQueues()) {\n        if (newQueue instanceof LeafQueue) {\n          for (String nodeLabel : leafQueueTemplateNodeLabels) {\n            leafQueueState.createLeafQueueStateIfNotExists((LeafQueue) newQueue,\n                nodeLabel);\n            newPartitions.add(nodeLabel);\n          }\n          newQueues.add(newQueue.getQueuePath());\n        }\n      }\n\n      for (Iterator\u003cMap.Entry\u003cString, Map\u003cString, LeafQueueStatePerPartition\u003e\u003e\u003e\n           itr \u003d leafQueueState.getLeafQueueStateMap().entrySet().iterator();\n           itr.hasNext(); ) {\n        Map.Entry\u003cString, Map\u003cString, LeafQueueStatePerPartition\u003e\u003e e \u003d\n            itr.next();\n        String partition \u003d e.getKey();\n        if (!newPartitions.contains(partition)) {\n          itr.remove();\n          LOG.info(managedParentQueue.getQueuePath()  +\n              \" : Removed partition \" + partition + \" from leaf queue \" +\n              \"state\");\n        } else{\n          Map\u003cString, LeafQueueStatePerPartition\u003e queues \u003d e.getValue();\n          for (\n              Iterator\u003cMap.Entry\u003cString, LeafQueueStatePerPartition\u003e\u003e queueItr \u003d\n              queues.entrySet().iterator(); queueItr.hasNext(); ) {\n            String queue \u003d queueItr.next().getKey();\n            if (!newQueues.contains(queue)) {\n              queueItr.remove();\n              LOG.info(managedParentQueue.getQueuePath() + \" : Removed queue\"\n                  + queue + \" from \"\n                  + \"leaf queue \"\n                  + \"state from partition \" + partition);\n            }\n          }\n        }\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/queuemanagement/GuaranteedOrZeroCapacityOverTimePolicy.java",
      "extendedDetails": {}
    },
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9341.  Fixed enentrant lock usage in YARN project.\n            Contributed by Prabhu Joseph\n",
      "commitDate": "07/03/19 1:47 PM",
      "commitName": "39b4a37e02e929a698fcf9e32f1f71bb6b977635",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "09/08/18 11:04 AM",
      "commitNameOld": "344c335a920e6f32a35ebace0a118a9dc4a22fb7",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 210.16,
      "commitsBetweenForRepo": 1721,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,48 +1,48 @@\n   void updateLeafQueueState() {\n+    writeLock.lock();\n     try {\n-      writeLock.lock();\n       Set\u003cString\u003e newPartitions \u003d new HashSet\u003c\u003e();\n       Set\u003cString\u003e newQueues \u003d new HashSet\u003c\u003e();\n \n       for (CSQueue newQueue : managedParentQueue.getChildQueues()) {\n         if (newQueue instanceof LeafQueue) {\n           for (String nodeLabel : leafQueueTemplateNodeLabels) {\n             leafQueueState.createLeafQueueStateIfNotExists((LeafQueue) newQueue,\n                 nodeLabel);\n             newPartitions.add(nodeLabel);\n           }\n           newQueues.add(newQueue.getQueueName());\n         }\n       }\n \n       for (Iterator\u003cMap.Entry\u003cString, Map\u003cString, LeafQueueStatePerPartition\u003e\u003e\u003e\n            itr \u003d leafQueueState.getLeafQueueStateMap().entrySet().iterator();\n            itr.hasNext(); ) {\n         Map.Entry\u003cString, Map\u003cString, LeafQueueStatePerPartition\u003e\u003e e \u003d\n             itr.next();\n         String partition \u003d e.getKey();\n         if (!newPartitions.contains(partition)) {\n           itr.remove();\n           LOG.info(managedParentQueue.getQueueName()  +\n               \" : Removed partition \" + partition + \" from leaf queue \" +\n               \"state\");\n         } else{\n           Map\u003cString, LeafQueueStatePerPartition\u003e queues \u003d e.getValue();\n           for (\n               Iterator\u003cMap.Entry\u003cString, LeafQueueStatePerPartition\u003e\u003e queueItr \u003d\n               queues.entrySet().iterator(); queueItr.hasNext(); ) {\n             String queue \u003d queueItr.next().getKey();\n             if (!newQueues.contains(queue)) {\n               queueItr.remove();\n               LOG.info(managedParentQueue.getQueueName() + \" : Removed queue\"\n                   + queue + \" from \"\n                   + \"leaf queue \"\n                   + \"state from partition \" + partition);\n             }\n           }\n         }\n       }\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void updateLeafQueueState() {\n    writeLock.lock();\n    try {\n      Set\u003cString\u003e newPartitions \u003d new HashSet\u003c\u003e();\n      Set\u003cString\u003e newQueues \u003d new HashSet\u003c\u003e();\n\n      for (CSQueue newQueue : managedParentQueue.getChildQueues()) {\n        if (newQueue instanceof LeafQueue) {\n          for (String nodeLabel : leafQueueTemplateNodeLabels) {\n            leafQueueState.createLeafQueueStateIfNotExists((LeafQueue) newQueue,\n                nodeLabel);\n            newPartitions.add(nodeLabel);\n          }\n          newQueues.add(newQueue.getQueueName());\n        }\n      }\n\n      for (Iterator\u003cMap.Entry\u003cString, Map\u003cString, LeafQueueStatePerPartition\u003e\u003e\u003e\n           itr \u003d leafQueueState.getLeafQueueStateMap().entrySet().iterator();\n           itr.hasNext(); ) {\n        Map.Entry\u003cString, Map\u003cString, LeafQueueStatePerPartition\u003e\u003e e \u003d\n            itr.next();\n        String partition \u003d e.getKey();\n        if (!newPartitions.contains(partition)) {\n          itr.remove();\n          LOG.info(managedParentQueue.getQueueName()  +\n              \" : Removed partition \" + partition + \" from leaf queue \" +\n              \"state\");\n        } else{\n          Map\u003cString, LeafQueueStatePerPartition\u003e queues \u003d e.getValue();\n          for (\n              Iterator\u003cMap.Entry\u003cString, LeafQueueStatePerPartition\u003e\u003e queueItr \u003d\n              queues.entrySet().iterator(); queueItr.hasNext(); ) {\n            String queue \u003d queueItr.next().getKey();\n            if (!newQueues.contains(queue)) {\n              queueItr.remove();\n              LOG.info(managedParentQueue.getQueueName() + \" : Removed queue\"\n                  + queue + \" from \"\n                  + \"leaf queue \"\n                  + \"state from partition \" + partition);\n            }\n          }\n        }\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/queuemanagement/GuaranteedOrZeroCapacityOverTimePolicy.java",
      "extendedDetails": {}
    },
    "344c335a920e6f32a35ebace0a118a9dc4a22fb7": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8588. Logging improvements for better debuggability. (Suma Shivaprasad via wangda)\n\nChange-Id: I66aa4b0ec031ae5ce0fae558e2f8cbcbbfebc442\n",
      "commitDate": "09/08/18 11:04 AM",
      "commitName": "344c335a920e6f32a35ebace0a118a9dc4a22fb7",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "09/04/18 8:47 AM",
      "commitNameOld": "821b0de4c59156d4a65112de03ba3e7e1c88e309",
      "commitAuthorOld": "Sunil G",
      "daysBetweenCommits": 122.09,
      "commitsBetweenForRepo": 1381,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,45 +1,48 @@\n   void updateLeafQueueState() {\n     try {\n       writeLock.lock();\n       Set\u003cString\u003e newPartitions \u003d new HashSet\u003c\u003e();\n       Set\u003cString\u003e newQueues \u003d new HashSet\u003c\u003e();\n \n       for (CSQueue newQueue : managedParentQueue.getChildQueues()) {\n         if (newQueue instanceof LeafQueue) {\n           for (String nodeLabel : leafQueueTemplateNodeLabels) {\n             leafQueueState.createLeafQueueStateIfNotExists((LeafQueue) newQueue,\n                 nodeLabel);\n             newPartitions.add(nodeLabel);\n           }\n           newQueues.add(newQueue.getQueueName());\n         }\n       }\n \n       for (Iterator\u003cMap.Entry\u003cString, Map\u003cString, LeafQueueStatePerPartition\u003e\u003e\u003e\n            itr \u003d leafQueueState.getLeafQueueStateMap().entrySet().iterator();\n            itr.hasNext(); ) {\n         Map.Entry\u003cString, Map\u003cString, LeafQueueStatePerPartition\u003e\u003e e \u003d\n             itr.next();\n         String partition \u003d e.getKey();\n         if (!newPartitions.contains(partition)) {\n           itr.remove();\n-          LOG.info(\n-              \"Removed partition \" + partition + \" from leaf queue \" + \"state\");\n+          LOG.info(managedParentQueue.getQueueName()  +\n+              \" : Removed partition \" + partition + \" from leaf queue \" +\n+              \"state\");\n         } else{\n           Map\u003cString, LeafQueueStatePerPartition\u003e queues \u003d e.getValue();\n           for (\n               Iterator\u003cMap.Entry\u003cString, LeafQueueStatePerPartition\u003e\u003e queueItr \u003d\n               queues.entrySet().iterator(); queueItr.hasNext(); ) {\n             String queue \u003d queueItr.next().getKey();\n             if (!newQueues.contains(queue)) {\n               queueItr.remove();\n-              LOG.info(\"Removed queue \" + queue + \" from leaf queue \"\n+              LOG.info(managedParentQueue.getQueueName() + \" : Removed queue\"\n+                  + queue + \" from \"\n+                  + \"leaf queue \"\n                   + \"state from partition \" + partition);\n             }\n           }\n         }\n       }\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void updateLeafQueueState() {\n    try {\n      writeLock.lock();\n      Set\u003cString\u003e newPartitions \u003d new HashSet\u003c\u003e();\n      Set\u003cString\u003e newQueues \u003d new HashSet\u003c\u003e();\n\n      for (CSQueue newQueue : managedParentQueue.getChildQueues()) {\n        if (newQueue instanceof LeafQueue) {\n          for (String nodeLabel : leafQueueTemplateNodeLabels) {\n            leafQueueState.createLeafQueueStateIfNotExists((LeafQueue) newQueue,\n                nodeLabel);\n            newPartitions.add(nodeLabel);\n          }\n          newQueues.add(newQueue.getQueueName());\n        }\n      }\n\n      for (Iterator\u003cMap.Entry\u003cString, Map\u003cString, LeafQueueStatePerPartition\u003e\u003e\u003e\n           itr \u003d leafQueueState.getLeafQueueStateMap().entrySet().iterator();\n           itr.hasNext(); ) {\n        Map.Entry\u003cString, Map\u003cString, LeafQueueStatePerPartition\u003e\u003e e \u003d\n            itr.next();\n        String partition \u003d e.getKey();\n        if (!newPartitions.contains(partition)) {\n          itr.remove();\n          LOG.info(managedParentQueue.getQueueName()  +\n              \" : Removed partition \" + partition + \" from leaf queue \" +\n              \"state\");\n        } else{\n          Map\u003cString, LeafQueueStatePerPartition\u003e queues \u003d e.getValue();\n          for (\n              Iterator\u003cMap.Entry\u003cString, LeafQueueStatePerPartition\u003e\u003e queueItr \u003d\n              queues.entrySet().iterator(); queueItr.hasNext(); ) {\n            String queue \u003d queueItr.next().getKey();\n            if (!newQueues.contains(queue)) {\n              queueItr.remove();\n              LOG.info(managedParentQueue.getQueueName() + \" : Removed queue\"\n                  + queue + \" from \"\n                  + \"leaf queue \"\n                  + \"state from partition \" + partition);\n            }\n          }\n        }\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/queuemanagement/GuaranteedOrZeroCapacityOverTimePolicy.java",
      "extendedDetails": {}
    },
    "821b0de4c59156d4a65112de03ba3e7e1c88e309": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7574. Add support for Node Labels on Auto Created Leaf Queue Template. Contributed by Suma Shivaprasad.\n",
      "commitDate": "09/04/18 8:47 AM",
      "commitName": "821b0de4c59156d4a65112de03ba3e7e1c88e309",
      "commitAuthor": "Sunil G",
      "commitDateOld": "08/12/17 3:10 PM",
      "commitNameOld": "b38643c9a8dd2c53024ae830b9565a550d0ec39c",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 121.69,
      "commitsBetweenForRepo": 859,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,23 +1,45 @@\n   void updateLeafQueueState() {\n     try {\n       writeLock.lock();\n+      Set\u003cString\u003e newPartitions \u003d new HashSet\u003c\u003e();\n       Set\u003cString\u003e newQueues \u003d new HashSet\u003c\u003e();\n+\n       for (CSQueue newQueue : managedParentQueue.getChildQueues()) {\n         if (newQueue instanceof LeafQueue) {\n-          addLeafQueueStateIfNotExists((LeafQueue) newQueue);\n+          for (String nodeLabel : leafQueueTemplateNodeLabels) {\n+            leafQueueState.createLeafQueueStateIfNotExists((LeafQueue) newQueue,\n+                nodeLabel);\n+            newPartitions.add(nodeLabel);\n+          }\n           newQueues.add(newQueue.getQueueName());\n         }\n       }\n \n-      for (Iterator\u003cMap.Entry\u003cString, LeafQueueState\u003e\u003e itr \u003d\n-           leafQueueStateMap.entrySet().iterator(); itr.hasNext(); ) {\n-        Map.Entry\u003cString, LeafQueueState\u003e e \u003d itr.next();\n-        String queueName \u003d e.getKey();\n-        if (!newQueues.contains(queueName)) {\n+      for (Iterator\u003cMap.Entry\u003cString, Map\u003cString, LeafQueueStatePerPartition\u003e\u003e\u003e\n+           itr \u003d leafQueueState.getLeafQueueStateMap().entrySet().iterator();\n+           itr.hasNext(); ) {\n+        Map.Entry\u003cString, Map\u003cString, LeafQueueStatePerPartition\u003e\u003e e \u003d\n+            itr.next();\n+        String partition \u003d e.getKey();\n+        if (!newPartitions.contains(partition)) {\n           itr.remove();\n+          LOG.info(\n+              \"Removed partition \" + partition + \" from leaf queue \" + \"state\");\n+        } else{\n+          Map\u003cString, LeafQueueStatePerPartition\u003e queues \u003d e.getValue();\n+          for (\n+              Iterator\u003cMap.Entry\u003cString, LeafQueueStatePerPartition\u003e\u003e queueItr \u003d\n+              queues.entrySet().iterator(); queueItr.hasNext(); ) {\n+            String queue \u003d queueItr.next().getKey();\n+            if (!newQueues.contains(queue)) {\n+              queueItr.remove();\n+              LOG.info(\"Removed queue \" + queue + \" from leaf queue \"\n+                  + \"state from partition \" + partition);\n+            }\n+          }\n         }\n       }\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void updateLeafQueueState() {\n    try {\n      writeLock.lock();\n      Set\u003cString\u003e newPartitions \u003d new HashSet\u003c\u003e();\n      Set\u003cString\u003e newQueues \u003d new HashSet\u003c\u003e();\n\n      for (CSQueue newQueue : managedParentQueue.getChildQueues()) {\n        if (newQueue instanceof LeafQueue) {\n          for (String nodeLabel : leafQueueTemplateNodeLabels) {\n            leafQueueState.createLeafQueueStateIfNotExists((LeafQueue) newQueue,\n                nodeLabel);\n            newPartitions.add(nodeLabel);\n          }\n          newQueues.add(newQueue.getQueueName());\n        }\n      }\n\n      for (Iterator\u003cMap.Entry\u003cString, Map\u003cString, LeafQueueStatePerPartition\u003e\u003e\u003e\n           itr \u003d leafQueueState.getLeafQueueStateMap().entrySet().iterator();\n           itr.hasNext(); ) {\n        Map.Entry\u003cString, Map\u003cString, LeafQueueStatePerPartition\u003e\u003e e \u003d\n            itr.next();\n        String partition \u003d e.getKey();\n        if (!newPartitions.contains(partition)) {\n          itr.remove();\n          LOG.info(\n              \"Removed partition \" + partition + \" from leaf queue \" + \"state\");\n        } else{\n          Map\u003cString, LeafQueueStatePerPartition\u003e queues \u003d e.getValue();\n          for (\n              Iterator\u003cMap.Entry\u003cString, LeafQueueStatePerPartition\u003e\u003e queueItr \u003d\n              queues.entrySet().iterator(); queueItr.hasNext(); ) {\n            String queue \u003d queueItr.next().getKey();\n            if (!newQueues.contains(queue)) {\n              queueItr.remove();\n              LOG.info(\"Removed queue \" + queue + \" from leaf queue \"\n                  + \"state from partition \" + partition);\n            }\n          }\n        }\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/queuemanagement/GuaranteedOrZeroCapacityOverTimePolicy.java",
      "extendedDetails": {}
    },
    "b38643c9a8dd2c53024ae830b9565a550d0ec39c": {
      "type": "Yintroduced",
      "commitMessage": "YARN-7473. Implement Framework and policy for capacity management of auto created queues. (Suma Shivaprasad via wangda)\n\nChange-Id: Icca7805fe12f6f7fb335effff4b121b6f7f6337b\n",
      "commitDate": "08/12/17 3:10 PM",
      "commitName": "b38643c9a8dd2c53024ae830b9565a550d0ec39c",
      "commitAuthor": "Wangda Tan",
      "diff": "@@ -0,0 +1,23 @@\n+  void updateLeafQueueState() {\n+    try {\n+      writeLock.lock();\n+      Set\u003cString\u003e newQueues \u003d new HashSet\u003c\u003e();\n+      for (CSQueue newQueue : managedParentQueue.getChildQueues()) {\n+        if (newQueue instanceof LeafQueue) {\n+          addLeafQueueStateIfNotExists((LeafQueue) newQueue);\n+          newQueues.add(newQueue.getQueueName());\n+        }\n+      }\n+\n+      for (Iterator\u003cMap.Entry\u003cString, LeafQueueState\u003e\u003e itr \u003d\n+           leafQueueStateMap.entrySet().iterator(); itr.hasNext(); ) {\n+        Map.Entry\u003cString, LeafQueueState\u003e e \u003d itr.next();\n+        String queueName \u003d e.getKey();\n+        if (!newQueues.contains(queueName)) {\n+          itr.remove();\n+        }\n+      }\n+    } finally {\n+      writeLock.unlock();\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  void updateLeafQueueState() {\n    try {\n      writeLock.lock();\n      Set\u003cString\u003e newQueues \u003d new HashSet\u003c\u003e();\n      for (CSQueue newQueue : managedParentQueue.getChildQueues()) {\n        if (newQueue instanceof LeafQueue) {\n          addLeafQueueStateIfNotExists((LeafQueue) newQueue);\n          newQueues.add(newQueue.getQueueName());\n        }\n      }\n\n      for (Iterator\u003cMap.Entry\u003cString, LeafQueueState\u003e\u003e itr \u003d\n           leafQueueStateMap.entrySet().iterator(); itr.hasNext(); ) {\n        Map.Entry\u003cString, LeafQueueState\u003e e \u003d itr.next();\n        String queueName \u003d e.getKey();\n        if (!newQueues.contains(queueName)) {\n          itr.remove();\n        }\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/queuemanagement/GuaranteedOrZeroCapacityOverTimePolicy.java"
    }
  }
}