{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "Configuration.java",
  "functionName": "handleInclude",
  "functionId": "handleInclude",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/conf/Configuration.java",
  "functionStartLine": 3206,
  "functionEndLine": 3274,
  "numCommitsSeen": 132,
  "timeTaken": 2223,
  "changeHistory": [
    "3961690037fa4274a3640104b3c344e8626caa10",
    "f51da9c4d1423c2ac92eb4f40e973264e7e968cc"
  ],
  "changeHistoryShort": {
    "3961690037fa4274a3640104b3c344e8626caa10": "Ymultichange(Yexceptionschange,Ybodychange)",
    "f51da9c4d1423c2ac92eb4f40e973264e7e968cc": "Yintroduced"
  },
  "changeHistoryDetails": {
    "3961690037fa4274a3640104b3c344e8626caa10": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "HADOOP-15973. Configuration: Included properties are not cached if resource is a stream. Contributed by Eric Payne\n",
      "commitDate": "20/12/18 7:29 AM",
      "commitName": "3961690037fa4274a3640104b3c344e8626caa10",
      "commitAuthor": "Jason Lowe",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "HADOOP-15973. Configuration: Included properties are not cached if resource is a stream. Contributed by Eric Payne\n",
          "commitDate": "20/12/18 7:29 AM",
          "commitName": "3961690037fa4274a3640104b3c344e8626caa10",
          "commitAuthor": "Jason Lowe",
          "commitDateOld": "10/10/18 9:51 PM",
          "commitNameOld": "7b57f2f71fbaa5af4897309597cca70a95b04edd",
          "commitAuthorOld": "Takanobu Asanuma",
          "daysBetweenCommits": 70.44,
          "commitsBetweenForRepo": 544,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,57 +1,69 @@\n-    private void handleInclude() throws MalformedURLException {\n+    private void handleInclude() throws XMLStreamException, IOException {\n       // Determine href for xi:include\n       confInclude \u003d null;\n       int attrCount \u003d reader.getAttributeCount();\n+      List\u003cParsedItem\u003e items;\n       for (int i \u003d 0; i \u003c attrCount; i++) {\n         String attrName \u003d reader.getAttributeLocalName(i);\n         if (\"href\".equals(attrName)) {\n           confInclude \u003d reader.getAttributeValue(i);\n         }\n       }\n       if (confInclude \u003d\u003d null) {\n         return;\n       }\n       if (isRestricted) {\n         throw new RuntimeException(\"Error parsing resource \" + wrapper\n             + \": XInclude is not supported for restricted resources\");\n       }\n       // Determine if the included resource is a classpath resource\n       // otherwise fallback to a file resource\n       // xi:include are treated as inline and retain current source\n       URL include \u003d getResource(confInclude);\n       if (include !\u003d null) {\n         Resource classpathResource \u003d new Resource(include, name,\n             wrapper.isParserRestricted());\n         // This is only called recursively while the lock is already held\n         // by this thread, but synchronizing avoids a findbugs warning.\n         synchronized (Configuration.this) {\n-          loadResource(properties, classpathResource, quiet);\n+          XMLStreamReader2 includeReader \u003d\n+              getStreamReader(classpathResource, quiet);\n+          if (includeReader \u003d\u003d null) {\n+            throw new RuntimeException(classpathResource + \" not found\");\n+          }\n+          items \u003d new Parser(includeReader, classpathResource, quiet).parse();\n         }\n       } else {\n         URL url;\n         try {\n           url \u003d new URL(confInclude);\n           url.openConnection().connect();\n         } catch (IOException ioe) {\n           File href \u003d new File(confInclude);\n           if (!href.isAbsolute()) {\n             // Included resources are relative to the current resource\n             File baseFile \u003d new File(name).getParentFile();\n             href \u003d new File(baseFile, href.getPath());\n           }\n           if (!href.exists()) {\n             // Resource errors are non-fatal iff there is 1 xi:fallback\n             fallbackAllowed \u003d true;\n             return;\n           }\n           url \u003d href.toURI().toURL();\n         }\n         Resource uriResource \u003d new Resource(url, name,\n             wrapper.isParserRestricted());\n         // This is only called recursively while the lock is already held\n         // by this thread, but synchronizing avoids a findbugs warning.\n         synchronized (Configuration.this) {\n-          loadResource(properties, uriResource, quiet);\n+          XMLStreamReader2 includeReader \u003d\n+              getStreamReader(uriResource, quiet);\n+          if (includeReader \u003d\u003d null) {\n+            throw new RuntimeException(uriResource + \" not found\");\n+          }\n+          items \u003d new Parser(includeReader, uriResource, quiet).parse();\n         }\n       }\n+      results.addAll(items);\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private void handleInclude() throws XMLStreamException, IOException {\n      // Determine href for xi:include\n      confInclude \u003d null;\n      int attrCount \u003d reader.getAttributeCount();\n      List\u003cParsedItem\u003e items;\n      for (int i \u003d 0; i \u003c attrCount; i++) {\n        String attrName \u003d reader.getAttributeLocalName(i);\n        if (\"href\".equals(attrName)) {\n          confInclude \u003d reader.getAttributeValue(i);\n        }\n      }\n      if (confInclude \u003d\u003d null) {\n        return;\n      }\n      if (isRestricted) {\n        throw new RuntimeException(\"Error parsing resource \" + wrapper\n            + \": XInclude is not supported for restricted resources\");\n      }\n      // Determine if the included resource is a classpath resource\n      // otherwise fallback to a file resource\n      // xi:include are treated as inline and retain current source\n      URL include \u003d getResource(confInclude);\n      if (include !\u003d null) {\n        Resource classpathResource \u003d new Resource(include, name,\n            wrapper.isParserRestricted());\n        // This is only called recursively while the lock is already held\n        // by this thread, but synchronizing avoids a findbugs warning.\n        synchronized (Configuration.this) {\n          XMLStreamReader2 includeReader \u003d\n              getStreamReader(classpathResource, quiet);\n          if (includeReader \u003d\u003d null) {\n            throw new RuntimeException(classpathResource + \" not found\");\n          }\n          items \u003d new Parser(includeReader, classpathResource, quiet).parse();\n        }\n      } else {\n        URL url;\n        try {\n          url \u003d new URL(confInclude);\n          url.openConnection().connect();\n        } catch (IOException ioe) {\n          File href \u003d new File(confInclude);\n          if (!href.isAbsolute()) {\n            // Included resources are relative to the current resource\n            File baseFile \u003d new File(name).getParentFile();\n            href \u003d new File(baseFile, href.getPath());\n          }\n          if (!href.exists()) {\n            // Resource errors are non-fatal iff there is 1 xi:fallback\n            fallbackAllowed \u003d true;\n            return;\n          }\n          url \u003d href.toURI().toURL();\n        }\n        Resource uriResource \u003d new Resource(url, name,\n            wrapper.isParserRestricted());\n        // This is only called recursively while the lock is already held\n        // by this thread, but synchronizing avoids a findbugs warning.\n        synchronized (Configuration.this) {\n          XMLStreamReader2 includeReader \u003d\n              getStreamReader(uriResource, quiet);\n          if (includeReader \u003d\u003d null) {\n            throw new RuntimeException(uriResource + \" not found\");\n          }\n          items \u003d new Parser(includeReader, uriResource, quiet).parse();\n        }\n      }\n      results.addAll(items);\n    }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/conf/Configuration.java",
          "extendedDetails": {
            "oldValue": "[MalformedURLException]",
            "newValue": "[XMLStreamException, IOException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-15973. Configuration: Included properties are not cached if resource is a stream. Contributed by Eric Payne\n",
          "commitDate": "20/12/18 7:29 AM",
          "commitName": "3961690037fa4274a3640104b3c344e8626caa10",
          "commitAuthor": "Jason Lowe",
          "commitDateOld": "10/10/18 9:51 PM",
          "commitNameOld": "7b57f2f71fbaa5af4897309597cca70a95b04edd",
          "commitAuthorOld": "Takanobu Asanuma",
          "daysBetweenCommits": 70.44,
          "commitsBetweenForRepo": 544,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,57 +1,69 @@\n-    private void handleInclude() throws MalformedURLException {\n+    private void handleInclude() throws XMLStreamException, IOException {\n       // Determine href for xi:include\n       confInclude \u003d null;\n       int attrCount \u003d reader.getAttributeCount();\n+      List\u003cParsedItem\u003e items;\n       for (int i \u003d 0; i \u003c attrCount; i++) {\n         String attrName \u003d reader.getAttributeLocalName(i);\n         if (\"href\".equals(attrName)) {\n           confInclude \u003d reader.getAttributeValue(i);\n         }\n       }\n       if (confInclude \u003d\u003d null) {\n         return;\n       }\n       if (isRestricted) {\n         throw new RuntimeException(\"Error parsing resource \" + wrapper\n             + \": XInclude is not supported for restricted resources\");\n       }\n       // Determine if the included resource is a classpath resource\n       // otherwise fallback to a file resource\n       // xi:include are treated as inline and retain current source\n       URL include \u003d getResource(confInclude);\n       if (include !\u003d null) {\n         Resource classpathResource \u003d new Resource(include, name,\n             wrapper.isParserRestricted());\n         // This is only called recursively while the lock is already held\n         // by this thread, but synchronizing avoids a findbugs warning.\n         synchronized (Configuration.this) {\n-          loadResource(properties, classpathResource, quiet);\n+          XMLStreamReader2 includeReader \u003d\n+              getStreamReader(classpathResource, quiet);\n+          if (includeReader \u003d\u003d null) {\n+            throw new RuntimeException(classpathResource + \" not found\");\n+          }\n+          items \u003d new Parser(includeReader, classpathResource, quiet).parse();\n         }\n       } else {\n         URL url;\n         try {\n           url \u003d new URL(confInclude);\n           url.openConnection().connect();\n         } catch (IOException ioe) {\n           File href \u003d new File(confInclude);\n           if (!href.isAbsolute()) {\n             // Included resources are relative to the current resource\n             File baseFile \u003d new File(name).getParentFile();\n             href \u003d new File(baseFile, href.getPath());\n           }\n           if (!href.exists()) {\n             // Resource errors are non-fatal iff there is 1 xi:fallback\n             fallbackAllowed \u003d true;\n             return;\n           }\n           url \u003d href.toURI().toURL();\n         }\n         Resource uriResource \u003d new Resource(url, name,\n             wrapper.isParserRestricted());\n         // This is only called recursively while the lock is already held\n         // by this thread, but synchronizing avoids a findbugs warning.\n         synchronized (Configuration.this) {\n-          loadResource(properties, uriResource, quiet);\n+          XMLStreamReader2 includeReader \u003d\n+              getStreamReader(uriResource, quiet);\n+          if (includeReader \u003d\u003d null) {\n+            throw new RuntimeException(uriResource + \" not found\");\n+          }\n+          items \u003d new Parser(includeReader, uriResource, quiet).parse();\n         }\n       }\n+      results.addAll(items);\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private void handleInclude() throws XMLStreamException, IOException {\n      // Determine href for xi:include\n      confInclude \u003d null;\n      int attrCount \u003d reader.getAttributeCount();\n      List\u003cParsedItem\u003e items;\n      for (int i \u003d 0; i \u003c attrCount; i++) {\n        String attrName \u003d reader.getAttributeLocalName(i);\n        if (\"href\".equals(attrName)) {\n          confInclude \u003d reader.getAttributeValue(i);\n        }\n      }\n      if (confInclude \u003d\u003d null) {\n        return;\n      }\n      if (isRestricted) {\n        throw new RuntimeException(\"Error parsing resource \" + wrapper\n            + \": XInclude is not supported for restricted resources\");\n      }\n      // Determine if the included resource is a classpath resource\n      // otherwise fallback to a file resource\n      // xi:include are treated as inline and retain current source\n      URL include \u003d getResource(confInclude);\n      if (include !\u003d null) {\n        Resource classpathResource \u003d new Resource(include, name,\n            wrapper.isParserRestricted());\n        // This is only called recursively while the lock is already held\n        // by this thread, but synchronizing avoids a findbugs warning.\n        synchronized (Configuration.this) {\n          XMLStreamReader2 includeReader \u003d\n              getStreamReader(classpathResource, quiet);\n          if (includeReader \u003d\u003d null) {\n            throw new RuntimeException(classpathResource + \" not found\");\n          }\n          items \u003d new Parser(includeReader, classpathResource, quiet).parse();\n        }\n      } else {\n        URL url;\n        try {\n          url \u003d new URL(confInclude);\n          url.openConnection().connect();\n        } catch (IOException ioe) {\n          File href \u003d new File(confInclude);\n          if (!href.isAbsolute()) {\n            // Included resources are relative to the current resource\n            File baseFile \u003d new File(name).getParentFile();\n            href \u003d new File(baseFile, href.getPath());\n          }\n          if (!href.exists()) {\n            // Resource errors are non-fatal iff there is 1 xi:fallback\n            fallbackAllowed \u003d true;\n            return;\n          }\n          url \u003d href.toURI().toURL();\n        }\n        Resource uriResource \u003d new Resource(url, name,\n            wrapper.isParserRestricted());\n        // This is only called recursively while the lock is already held\n        // by this thread, but synchronizing avoids a findbugs warning.\n        synchronized (Configuration.this) {\n          XMLStreamReader2 includeReader \u003d\n              getStreamReader(uriResource, quiet);\n          if (includeReader \u003d\u003d null) {\n            throw new RuntimeException(uriResource + \" not found\");\n          }\n          items \u003d new Parser(includeReader, uriResource, quiet).parse();\n        }\n      }\n      results.addAll(items);\n    }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/conf/Configuration.java",
          "extendedDetails": {}
        }
      ]
    },
    "f51da9c4d1423c2ac92eb4f40e973264e7e968cc": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-15554. Improve JIT performance for Configuration parsing. Contributed by Todd Lipcon.\n",
      "commitDate": "02/07/18 9:31 AM",
      "commitName": "f51da9c4d1423c2ac92eb4f40e973264e7e968cc",
      "commitAuthor": "Andrew Wang",
      "diff": "@@ -0,0 +1,57 @@\n+    private void handleInclude() throws MalformedURLException {\n+      // Determine href for xi:include\n+      confInclude \u003d null;\n+      int attrCount \u003d reader.getAttributeCount();\n+      for (int i \u003d 0; i \u003c attrCount; i++) {\n+        String attrName \u003d reader.getAttributeLocalName(i);\n+        if (\"href\".equals(attrName)) {\n+          confInclude \u003d reader.getAttributeValue(i);\n+        }\n+      }\n+      if (confInclude \u003d\u003d null) {\n+        return;\n+      }\n+      if (isRestricted) {\n+        throw new RuntimeException(\"Error parsing resource \" + wrapper\n+            + \": XInclude is not supported for restricted resources\");\n+      }\n+      // Determine if the included resource is a classpath resource\n+      // otherwise fallback to a file resource\n+      // xi:include are treated as inline and retain current source\n+      URL include \u003d getResource(confInclude);\n+      if (include !\u003d null) {\n+        Resource classpathResource \u003d new Resource(include, name,\n+            wrapper.isParserRestricted());\n+        // This is only called recursively while the lock is already held\n+        // by this thread, but synchronizing avoids a findbugs warning.\n+        synchronized (Configuration.this) {\n+          loadResource(properties, classpathResource, quiet);\n+        }\n+      } else {\n+        URL url;\n+        try {\n+          url \u003d new URL(confInclude);\n+          url.openConnection().connect();\n+        } catch (IOException ioe) {\n+          File href \u003d new File(confInclude);\n+          if (!href.isAbsolute()) {\n+            // Included resources are relative to the current resource\n+            File baseFile \u003d new File(name).getParentFile();\n+            href \u003d new File(baseFile, href.getPath());\n+          }\n+          if (!href.exists()) {\n+            // Resource errors are non-fatal iff there is 1 xi:fallback\n+            fallbackAllowed \u003d true;\n+            return;\n+          }\n+          url \u003d href.toURI().toURL();\n+        }\n+        Resource uriResource \u003d new Resource(url, name,\n+            wrapper.isParserRestricted());\n+        // This is only called recursively while the lock is already held\n+        // by this thread, but synchronizing avoids a findbugs warning.\n+        synchronized (Configuration.this) {\n+          loadResource(properties, uriResource, quiet);\n+        }\n+      }\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    private void handleInclude() throws MalformedURLException {\n      // Determine href for xi:include\n      confInclude \u003d null;\n      int attrCount \u003d reader.getAttributeCount();\n      for (int i \u003d 0; i \u003c attrCount; i++) {\n        String attrName \u003d reader.getAttributeLocalName(i);\n        if (\"href\".equals(attrName)) {\n          confInclude \u003d reader.getAttributeValue(i);\n        }\n      }\n      if (confInclude \u003d\u003d null) {\n        return;\n      }\n      if (isRestricted) {\n        throw new RuntimeException(\"Error parsing resource \" + wrapper\n            + \": XInclude is not supported for restricted resources\");\n      }\n      // Determine if the included resource is a classpath resource\n      // otherwise fallback to a file resource\n      // xi:include are treated as inline and retain current source\n      URL include \u003d getResource(confInclude);\n      if (include !\u003d null) {\n        Resource classpathResource \u003d new Resource(include, name,\n            wrapper.isParserRestricted());\n        // This is only called recursively while the lock is already held\n        // by this thread, but synchronizing avoids a findbugs warning.\n        synchronized (Configuration.this) {\n          loadResource(properties, classpathResource, quiet);\n        }\n      } else {\n        URL url;\n        try {\n          url \u003d new URL(confInclude);\n          url.openConnection().connect();\n        } catch (IOException ioe) {\n          File href \u003d new File(confInclude);\n          if (!href.isAbsolute()) {\n            // Included resources are relative to the current resource\n            File baseFile \u003d new File(name).getParentFile();\n            href \u003d new File(baseFile, href.getPath());\n          }\n          if (!href.exists()) {\n            // Resource errors are non-fatal iff there is 1 xi:fallback\n            fallbackAllowed \u003d true;\n            return;\n          }\n          url \u003d href.toURI().toURL();\n        }\n        Resource uriResource \u003d new Resource(url, name,\n            wrapper.isParserRestricted());\n        // This is only called recursively while the lock is already held\n        // by this thread, but synchronizing avoids a findbugs warning.\n        synchronized (Configuration.this) {\n          loadResource(properties, uriResource, quiet);\n        }\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/conf/Configuration.java"
    }
  }
}