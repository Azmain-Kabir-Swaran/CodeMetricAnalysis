{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "Storage.java",
  "functionName": "tryLock",
  "functionId": "tryLock",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/common/Storage.java",
  "functionStartLine": 911,
  "functionEndLine": 950,
  "numCommitsSeen": 57,
  "timeTaken": 6698,
  "changeHistory": [
    "b3ae11d59790bb08b81848e9f944db7d3afbbd8a",
    "1403b84b122fb76ef2b085a728b5402c32499c1f",
    "b9f6d0c956f0278c8b9b83e05b523a442a730ebb",
    "203c63030f625866e220656a8efdf05109dc7627",
    "af0fe05a92b2bd694f98c09a836851f45a6f03cf",
    "9daa958c5a69d5577e742fad94167e713abf688f",
    "6449f524552f8c24d20b314ad21f6c579fa08e85",
    "e5b00f1bdc16dfd55ce28280d1e6cfe1f27fb7e4",
    "6d5510dfb8bdd1cce577dc713b1d5849dc572d91",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "d86f3183d93714ba078416af4f609d26376eadb0",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc"
  ],
  "changeHistoryShort": {
    "b3ae11d59790bb08b81848e9f944db7d3afbbd8a": "Ybodychange",
    "1403b84b122fb76ef2b085a728b5402c32499c1f": "Ybodychange",
    "b9f6d0c956f0278c8b9b83e05b523a442a730ebb": "Ybodychange",
    "203c63030f625866e220656a8efdf05109dc7627": "Ybodychange",
    "af0fe05a92b2bd694f98c09a836851f45a6f03cf": "Ybodychange",
    "9daa958c5a69d5577e742fad94167e713abf688f": "Ybodychange",
    "6449f524552f8c24d20b314ad21f6c579fa08e85": "Ybodychange",
    "e5b00f1bdc16dfd55ce28280d1e6cfe1f27fb7e4": "Ybodychange",
    "6d5510dfb8bdd1cce577dc713b1d5849dc572d91": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "d86f3183d93714ba078416af4f609d26376eadb0": "Yfilerename",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yintroduced"
  },
  "changeHistoryDetails": {
    "b3ae11d59790bb08b81848e9f944db7d3afbbd8a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12997. Move logging to slf4j in BlockPoolSliceStorage and Storage. Contributed by Ajay Kumar.\n",
      "commitDate": "01/02/18 10:45 AM",
      "commitName": "b3ae11d59790bb08b81848e9f944db7d3afbbd8a",
      "commitAuthor": "Xiaoyu Yao",
      "commitDateOld": "15/12/17 5:51 PM",
      "commitNameOld": "8239e3afb31d3c4485817d4b8b8b195b554acbe7",
      "commitAuthorOld": "Virajith Jalaparti",
      "daysBetweenCommits": 47.7,
      "commitsBetweenForRepo": 240,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,40 @@\n     FileLock tryLock() throws IOException {\n       boolean deletionHookAdded \u003d false;\n       File lockF \u003d new File(root, STORAGE_FILE_LOCK);\n       if (!lockF.exists()) {\n         lockF.deleteOnExit();\n         deletionHookAdded \u003d true;\n       }\n       RandomAccessFile file \u003d new RandomAccessFile(lockF, \"rws\");\n       String jvmName \u003d ManagementFactory.getRuntimeMXBean().getName();\n       FileLock res \u003d null;\n       try {\n         res \u003d file.getChannel().tryLock();\n         if (null \u003d\u003d res) {\n-          LOG.error(\"Unable to acquire file lock on path \" + lockF.toString());\n+          LOG.error(\"Unable to acquire file lock on path {}\", lockF);\n           throw new OverlappingFileLockException();\n         }\n         file.write(jvmName.getBytes(Charsets.UTF_8));\n-        LOG.info(\"Lock on \" + lockF + \" acquired by nodename \" + jvmName);\n+        LOG.info(\"Lock on {} acquired by nodename {}\", lockF, jvmName);\n       } catch(OverlappingFileLockException oe) {\n         // Cannot read from the locked file on Windows.\n         String lockingJvmName \u003d Path.WINDOWS ? \"\" : (\" \" + file.readLine());\n-        LOG.error(\"It appears that another node \" + lockingJvmName\n-            + \" has already locked the storage directory: \" + root, oe);\n+        LOG.error(\"It appears that another node {} has already locked the \"\n+            + \"storage directory: {}\", lockingJvmName, root, oe);\n         file.close();\n         return null;\n       } catch(IOException e) {\n-        LOG.error(\"Failed to acquire lock on \" + lockF\n-            + \". If this storage directory is mounted via NFS, \" \n-            + \"ensure that the appropriate nfs lock services are running.\", e);\n+        LOG.error(\"Failed to acquire lock on {}. If this storage directory is\"\n+            + \" mounted via NFS, ensure that the appropriate nfs lock services\"\n+            + \" are running.\", lockF, e);\n         file.close();\n         throw e;\n       }\n       if (!deletionHookAdded) {\n         // If the file existed prior to our startup, we didn\u0027t\n         // call deleteOnExit above. But since we successfully locked\n         // the dir, we can take care of cleaning it up.\n         lockF.deleteOnExit();\n       }\n       return res;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    FileLock tryLock() throws IOException {\n      boolean deletionHookAdded \u003d false;\n      File lockF \u003d new File(root, STORAGE_FILE_LOCK);\n      if (!lockF.exists()) {\n        lockF.deleteOnExit();\n        deletionHookAdded \u003d true;\n      }\n      RandomAccessFile file \u003d new RandomAccessFile(lockF, \"rws\");\n      String jvmName \u003d ManagementFactory.getRuntimeMXBean().getName();\n      FileLock res \u003d null;\n      try {\n        res \u003d file.getChannel().tryLock();\n        if (null \u003d\u003d res) {\n          LOG.error(\"Unable to acquire file lock on path {}\", lockF);\n          throw new OverlappingFileLockException();\n        }\n        file.write(jvmName.getBytes(Charsets.UTF_8));\n        LOG.info(\"Lock on {} acquired by nodename {}\", lockF, jvmName);\n      } catch(OverlappingFileLockException oe) {\n        // Cannot read from the locked file on Windows.\n        String lockingJvmName \u003d Path.WINDOWS ? \"\" : (\" \" + file.readLine());\n        LOG.error(\"It appears that another node {} has already locked the \"\n            + \"storage directory: {}\", lockingJvmName, root, oe);\n        file.close();\n        return null;\n      } catch(IOException e) {\n        LOG.error(\"Failed to acquire lock on {}. If this storage directory is\"\n            + \" mounted via NFS, ensure that the appropriate nfs lock services\"\n            + \" are running.\", lockF, e);\n        file.close();\n        throw e;\n      }\n      if (!deletionHookAdded) {\n        // If the file existed prior to our startup, we didn\u0027t\n        // call deleteOnExit above. But since we successfully locked\n        // the dir, we can take care of cleaning it up.\n        lockF.deleteOnExit();\n      }\n      return res;\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/common/Storage.java",
      "extendedDetails": {}
    },
    "1403b84b122fb76ef2b085a728b5402c32499c1f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8546. Use try with resources in DataStorage and Storage.\n",
      "commitDate": "25/06/15 5:50 PM",
      "commitName": "1403b84b122fb76ef2b085a728b5402c32499c1f",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "10/03/15 6:20 PM",
      "commitNameOld": "5c1036d598051cf6af595740f1ab82092b0b6554",
      "commitAuthorOld": "Colin Patrick Mccabe",
      "daysBetweenCommits": 106.98,
      "commitsBetweenForRepo": 951,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,39 +1,40 @@\n     FileLock tryLock() throws IOException {\n       boolean deletionHookAdded \u003d false;\n       File lockF \u003d new File(root, STORAGE_FILE_LOCK);\n       if (!lockF.exists()) {\n         lockF.deleteOnExit();\n         deletionHookAdded \u003d true;\n       }\n       RandomAccessFile file \u003d new RandomAccessFile(lockF, \"rws\");\n       String jvmName \u003d ManagementFactory.getRuntimeMXBean().getName();\n       FileLock res \u003d null;\n       try {\n         res \u003d file.getChannel().tryLock();\n         if (null \u003d\u003d res) {\n+          LOG.error(\"Unable to acquire file lock on path \" + lockF.toString());\n           throw new OverlappingFileLockException();\n         }\n         file.write(jvmName.getBytes(Charsets.UTF_8));\n         LOG.info(\"Lock on \" + lockF + \" acquired by nodename \" + jvmName);\n       } catch(OverlappingFileLockException oe) {\n         // Cannot read from the locked file on Windows.\n         String lockingJvmName \u003d Path.WINDOWS ? \"\" : (\" \" + file.readLine());\n         LOG.error(\"It appears that another node \" + lockingJvmName\n             + \" has already locked the storage directory: \" + root, oe);\n         file.close();\n         return null;\n       } catch(IOException e) {\n         LOG.error(\"Failed to acquire lock on \" + lockF\n             + \". If this storage directory is mounted via NFS, \" \n             + \"ensure that the appropriate nfs lock services are running.\", e);\n         file.close();\n         throw e;\n       }\n       if (!deletionHookAdded) {\n         // If the file existed prior to our startup, we didn\u0027t\n         // call deleteOnExit above. But since we successfully locked\n         // the dir, we can take care of cleaning it up.\n         lockF.deleteOnExit();\n       }\n       return res;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    FileLock tryLock() throws IOException {\n      boolean deletionHookAdded \u003d false;\n      File lockF \u003d new File(root, STORAGE_FILE_LOCK);\n      if (!lockF.exists()) {\n        lockF.deleteOnExit();\n        deletionHookAdded \u003d true;\n      }\n      RandomAccessFile file \u003d new RandomAccessFile(lockF, \"rws\");\n      String jvmName \u003d ManagementFactory.getRuntimeMXBean().getName();\n      FileLock res \u003d null;\n      try {\n        res \u003d file.getChannel().tryLock();\n        if (null \u003d\u003d res) {\n          LOG.error(\"Unable to acquire file lock on path \" + lockF.toString());\n          throw new OverlappingFileLockException();\n        }\n        file.write(jvmName.getBytes(Charsets.UTF_8));\n        LOG.info(\"Lock on \" + lockF + \" acquired by nodename \" + jvmName);\n      } catch(OverlappingFileLockException oe) {\n        // Cannot read from the locked file on Windows.\n        String lockingJvmName \u003d Path.WINDOWS ? \"\" : (\" \" + file.readLine());\n        LOG.error(\"It appears that another node \" + lockingJvmName\n            + \" has already locked the storage directory: \" + root, oe);\n        file.close();\n        return null;\n      } catch(IOException e) {\n        LOG.error(\"Failed to acquire lock on \" + lockF\n            + \". If this storage directory is mounted via NFS, \" \n            + \"ensure that the appropriate nfs lock services are running.\", e);\n        file.close();\n        throw e;\n      }\n      if (!deletionHookAdded) {\n        // If the file existed prior to our startup, we didn\u0027t\n        // call deleteOnExit above. But since we successfully locked\n        // the dir, we can take care of cleaning it up.\n        lockF.deleteOnExit();\n      }\n      return res;\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/common/Storage.java",
      "extendedDetails": {}
    },
    "b9f6d0c956f0278c8b9b83e05b523a442a730ebb": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7515. Fix new findbugs warnings in hadoop-hdfs. Contributed by Haohui Mai.\n",
      "commitDate": "11/12/14 12:36 PM",
      "commitName": "b9f6d0c956f0278c8b9b83e05b523a442a730ebb",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "05/11/14 9:53 AM",
      "commitNameOld": "203c63030f625866e220656a8efdf05109dc7627",
      "commitAuthorOld": "Konstantin V Shvachko",
      "daysBetweenCommits": 36.11,
      "commitsBetweenForRepo": 279,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,39 +1,39 @@\n     FileLock tryLock() throws IOException {\n       boolean deletionHookAdded \u003d false;\n       File lockF \u003d new File(root, STORAGE_FILE_LOCK);\n       if (!lockF.exists()) {\n         lockF.deleteOnExit();\n         deletionHookAdded \u003d true;\n       }\n       RandomAccessFile file \u003d new RandomAccessFile(lockF, \"rws\");\n       String jvmName \u003d ManagementFactory.getRuntimeMXBean().getName();\n       FileLock res \u003d null;\n       try {\n         res \u003d file.getChannel().tryLock();\n         if (null \u003d\u003d res) {\n           throw new OverlappingFileLockException();\n         }\n         file.write(jvmName.getBytes(Charsets.UTF_8));\n         LOG.info(\"Lock on \" + lockF + \" acquired by nodename \" + jvmName);\n       } catch(OverlappingFileLockException oe) {\n         // Cannot read from the locked file on Windows.\n         String lockingJvmName \u003d Path.WINDOWS ? \"\" : (\" \" + file.readLine());\n         LOG.error(\"It appears that another node \" + lockingJvmName\n             + \" has already locked the storage directory: \" + root, oe);\n         file.close();\n         return null;\n       } catch(IOException e) {\n         LOG.error(\"Failed to acquire lock on \" + lockF\n             + \". If this storage directory is mounted via NFS, \" \n             + \"ensure that the appropriate nfs lock services are running.\", e);\n         file.close();\n         throw e;\n       }\n-      if (res !\u003d null \u0026\u0026 !deletionHookAdded) {\n+      if (!deletionHookAdded) {\n         // If the file existed prior to our startup, we didn\u0027t\n         // call deleteOnExit above. But since we successfully locked\n         // the dir, we can take care of cleaning it up.\n         lockF.deleteOnExit();\n       }\n       return res;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    FileLock tryLock() throws IOException {\n      boolean deletionHookAdded \u003d false;\n      File lockF \u003d new File(root, STORAGE_FILE_LOCK);\n      if (!lockF.exists()) {\n        lockF.deleteOnExit();\n        deletionHookAdded \u003d true;\n      }\n      RandomAccessFile file \u003d new RandomAccessFile(lockF, \"rws\");\n      String jvmName \u003d ManagementFactory.getRuntimeMXBean().getName();\n      FileLock res \u003d null;\n      try {\n        res \u003d file.getChannel().tryLock();\n        if (null \u003d\u003d res) {\n          throw new OverlappingFileLockException();\n        }\n        file.write(jvmName.getBytes(Charsets.UTF_8));\n        LOG.info(\"Lock on \" + lockF + \" acquired by nodename \" + jvmName);\n      } catch(OverlappingFileLockException oe) {\n        // Cannot read from the locked file on Windows.\n        String lockingJvmName \u003d Path.WINDOWS ? \"\" : (\" \" + file.readLine());\n        LOG.error(\"It appears that another node \" + lockingJvmName\n            + \" has already locked the storage directory: \" + root, oe);\n        file.close();\n        return null;\n      } catch(IOException e) {\n        LOG.error(\"Failed to acquire lock on \" + lockF\n            + \". If this storage directory is mounted via NFS, \" \n            + \"ensure that the appropriate nfs lock services are running.\", e);\n        file.close();\n        throw e;\n      }\n      if (!deletionHookAdded) {\n        // If the file existed prior to our startup, we didn\u0027t\n        // call deleteOnExit above. But since we successfully locked\n        // the dir, we can take care of cleaning it up.\n        lockF.deleteOnExit();\n      }\n      return res;\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/common/Storage.java",
      "extendedDetails": {}
    },
    "203c63030f625866e220656a8efdf05109dc7627": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7333. Improve logging in Storage.tryLock(). Contributed by Konstantin Shvachko.",
      "commitDate": "05/11/14 9:53 AM",
      "commitName": "203c63030f625866e220656a8efdf05109dc7627",
      "commitAuthor": "Konstantin V Shvachko",
      "commitDateOld": "30/10/14 5:31 PM",
      "commitNameOld": "a9331fe9b071fdcdae0c6c747d7b6b306142e671",
      "commitAuthorOld": "Colin Patrick Mccabe",
      "daysBetweenCommits": 5.72,
      "commitsBetweenForRepo": 56,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,39 @@\n     FileLock tryLock() throws IOException {\n       boolean deletionHookAdded \u003d false;\n       File lockF \u003d new File(root, STORAGE_FILE_LOCK);\n       if (!lockF.exists()) {\n         lockF.deleteOnExit();\n         deletionHookAdded \u003d true;\n       }\n       RandomAccessFile file \u003d new RandomAccessFile(lockF, \"rws\");\n       String jvmName \u003d ManagementFactory.getRuntimeMXBean().getName();\n       FileLock res \u003d null;\n       try {\n         res \u003d file.getChannel().tryLock();\n         if (null \u003d\u003d res) {\n           throw new OverlappingFileLockException();\n         }\n         file.write(jvmName.getBytes(Charsets.UTF_8));\n         LOG.info(\"Lock on \" + lockF + \" acquired by nodename \" + jvmName);\n       } catch(OverlappingFileLockException oe) {\n         // Cannot read from the locked file on Windows.\n         String lockingJvmName \u003d Path.WINDOWS ? \"\" : (\" \" + file.readLine());\n-        LOG.error(\"It appears that another namenode\" + lockingJvmName\n-            + \" has already locked the storage directory\");\n+        LOG.error(\"It appears that another node \" + lockingJvmName\n+            + \" has already locked the storage directory: \" + root, oe);\n         file.close();\n         return null;\n       } catch(IOException e) {\n-        LOG.error(\"Failed to acquire lock on \" + lockF + \". If this storage directory is mounted via NFS, \" \n+        LOG.error(\"Failed to acquire lock on \" + lockF\n+            + \". If this storage directory is mounted via NFS, \" \n             + \"ensure that the appropriate nfs lock services are running.\", e);\n         file.close();\n         throw e;\n       }\n       if (res !\u003d null \u0026\u0026 !deletionHookAdded) {\n         // If the file existed prior to our startup, we didn\u0027t\n         // call deleteOnExit above. But since we successfully locked\n         // the dir, we can take care of cleaning it up.\n         lockF.deleteOnExit();\n       }\n       return res;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    FileLock tryLock() throws IOException {\n      boolean deletionHookAdded \u003d false;\n      File lockF \u003d new File(root, STORAGE_FILE_LOCK);\n      if (!lockF.exists()) {\n        lockF.deleteOnExit();\n        deletionHookAdded \u003d true;\n      }\n      RandomAccessFile file \u003d new RandomAccessFile(lockF, \"rws\");\n      String jvmName \u003d ManagementFactory.getRuntimeMXBean().getName();\n      FileLock res \u003d null;\n      try {\n        res \u003d file.getChannel().tryLock();\n        if (null \u003d\u003d res) {\n          throw new OverlappingFileLockException();\n        }\n        file.write(jvmName.getBytes(Charsets.UTF_8));\n        LOG.info(\"Lock on \" + lockF + \" acquired by nodename \" + jvmName);\n      } catch(OverlappingFileLockException oe) {\n        // Cannot read from the locked file on Windows.\n        String lockingJvmName \u003d Path.WINDOWS ? \"\" : (\" \" + file.readLine());\n        LOG.error(\"It appears that another node \" + lockingJvmName\n            + \" has already locked the storage directory: \" + root, oe);\n        file.close();\n        return null;\n      } catch(IOException e) {\n        LOG.error(\"Failed to acquire lock on \" + lockF\n            + \". If this storage directory is mounted via NFS, \" \n            + \"ensure that the appropriate nfs lock services are running.\", e);\n        file.close();\n        throw e;\n      }\n      if (res !\u003d null \u0026\u0026 !deletionHookAdded) {\n        // If the file existed prior to our startup, we didn\u0027t\n        // call deleteOnExit above. But since we successfully locked\n        // the dir, we can take care of cleaning it up.\n        lockF.deleteOnExit();\n      }\n      return res;\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/common/Storage.java",
      "extendedDetails": {}
    },
    "af0fe05a92b2bd694f98c09a836851f45a6f03cf": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5669. Storage#tryLock() should check for null before logging successfull message. Contributed by Vinayakumar B\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1586392 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/04/14 11:11 AM",
      "commitName": "af0fe05a92b2bd694f98c09a836851f45a6f03cf",
      "commitAuthor": "Uma Maheswara Rao G",
      "commitDateOld": "24/03/14 4:32 PM",
      "commitNameOld": "c2ef7e239eb0e81cf8a3e971378e9e696202de67",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 16.78,
      "commitsBetweenForRepo": 110,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,38 @@\n     FileLock tryLock() throws IOException {\n       boolean deletionHookAdded \u003d false;\n       File lockF \u003d new File(root, STORAGE_FILE_LOCK);\n       if (!lockF.exists()) {\n         lockF.deleteOnExit();\n         deletionHookAdded \u003d true;\n       }\n       RandomAccessFile file \u003d new RandomAccessFile(lockF, \"rws\");\n       String jvmName \u003d ManagementFactory.getRuntimeMXBean().getName();\n       FileLock res \u003d null;\n       try {\n         res \u003d file.getChannel().tryLock();\n+        if (null \u003d\u003d res) {\n+          throw new OverlappingFileLockException();\n+        }\n         file.write(jvmName.getBytes(Charsets.UTF_8));\n         LOG.info(\"Lock on \" + lockF + \" acquired by nodename \" + jvmName);\n       } catch(OverlappingFileLockException oe) {\n         // Cannot read from the locked file on Windows.\n         String lockingJvmName \u003d Path.WINDOWS ? \"\" : (\" \" + file.readLine());\n         LOG.error(\"It appears that another namenode\" + lockingJvmName\n             + \" has already locked the storage directory\");\n         file.close();\n         return null;\n       } catch(IOException e) {\n         LOG.error(\"Failed to acquire lock on \" + lockF + \". If this storage directory is mounted via NFS, \" \n             + \"ensure that the appropriate nfs lock services are running.\", e);\n         file.close();\n         throw e;\n       }\n       if (res !\u003d null \u0026\u0026 !deletionHookAdded) {\n         // If the file existed prior to our startup, we didn\u0027t\n         // call deleteOnExit above. But since we successfully locked\n         // the dir, we can take care of cleaning it up.\n         lockF.deleteOnExit();\n       }\n       return res;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    FileLock tryLock() throws IOException {\n      boolean deletionHookAdded \u003d false;\n      File lockF \u003d new File(root, STORAGE_FILE_LOCK);\n      if (!lockF.exists()) {\n        lockF.deleteOnExit();\n        deletionHookAdded \u003d true;\n      }\n      RandomAccessFile file \u003d new RandomAccessFile(lockF, \"rws\");\n      String jvmName \u003d ManagementFactory.getRuntimeMXBean().getName();\n      FileLock res \u003d null;\n      try {\n        res \u003d file.getChannel().tryLock();\n        if (null \u003d\u003d res) {\n          throw new OverlappingFileLockException();\n        }\n        file.write(jvmName.getBytes(Charsets.UTF_8));\n        LOG.info(\"Lock on \" + lockF + \" acquired by nodename \" + jvmName);\n      } catch(OverlappingFileLockException oe) {\n        // Cannot read from the locked file on Windows.\n        String lockingJvmName \u003d Path.WINDOWS ? \"\" : (\" \" + file.readLine());\n        LOG.error(\"It appears that another namenode\" + lockingJvmName\n            + \" has already locked the storage directory\");\n        file.close();\n        return null;\n      } catch(IOException e) {\n        LOG.error(\"Failed to acquire lock on \" + lockF + \". If this storage directory is mounted via NFS, \" \n            + \"ensure that the appropriate nfs lock services are running.\", e);\n        file.close();\n        throw e;\n      }\n      if (res !\u003d null \u0026\u0026 !deletionHookAdded) {\n        // If the file existed prior to our startup, we didn\u0027t\n        // call deleteOnExit above. But since we successfully locked\n        // the dir, we can take care of cleaning it up.\n        lockF.deleteOnExit();\n      }\n      return res;\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/common/Storage.java",
      "extendedDetails": {}
    },
    "9daa958c5a69d5577e742fad94167e713abf688f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4572. Fix TestJournal failures on Windows. Contributed by Arpit Agarwal.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1455360 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/03/13 4:13 PM",
      "commitName": "9daa958c5a69d5577e742fad94167e713abf688f",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "04/02/13 1:29 PM",
      "commitNameOld": "a8e39feed2642dbfedb8fd22648904ad4bb6af97",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 35.07,
      "commitsBetweenForRepo": 140,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,33 +1,35 @@\n     FileLock tryLock() throws IOException {\n       boolean deletionHookAdded \u003d false;\n       File lockF \u003d new File(root, STORAGE_FILE_LOCK);\n       if (!lockF.exists()) {\n         lockF.deleteOnExit();\n         deletionHookAdded \u003d true;\n       }\n       RandomAccessFile file \u003d new RandomAccessFile(lockF, \"rws\");\n       String jvmName \u003d ManagementFactory.getRuntimeMXBean().getName();\n       FileLock res \u003d null;\n       try {\n         res \u003d file.getChannel().tryLock();\n         file.write(jvmName.getBytes(Charsets.UTF_8));\n         LOG.info(\"Lock on \" + lockF + \" acquired by nodename \" + jvmName);\n       } catch(OverlappingFileLockException oe) {\n-        LOG.error(\"It appears that another namenode \" + file.readLine() \n+        // Cannot read from the locked file on Windows.\n+        String lockingJvmName \u003d Path.WINDOWS ? \"\" : (\" \" + file.readLine());\n+        LOG.error(\"It appears that another namenode\" + lockingJvmName\n             + \" has already locked the storage directory\");\n         file.close();\n         return null;\n       } catch(IOException e) {\n         LOG.error(\"Failed to acquire lock on \" + lockF + \". If this storage directory is mounted via NFS, \" \n             + \"ensure that the appropriate nfs lock services are running.\", e);\n         file.close();\n         throw e;\n       }\n       if (res !\u003d null \u0026\u0026 !deletionHookAdded) {\n         // If the file existed prior to our startup, we didn\u0027t\n         // call deleteOnExit above. But since we successfully locked\n         // the dir, we can take care of cleaning it up.\n         lockF.deleteOnExit();\n       }\n       return res;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    FileLock tryLock() throws IOException {\n      boolean deletionHookAdded \u003d false;\n      File lockF \u003d new File(root, STORAGE_FILE_LOCK);\n      if (!lockF.exists()) {\n        lockF.deleteOnExit();\n        deletionHookAdded \u003d true;\n      }\n      RandomAccessFile file \u003d new RandomAccessFile(lockF, \"rws\");\n      String jvmName \u003d ManagementFactory.getRuntimeMXBean().getName();\n      FileLock res \u003d null;\n      try {\n        res \u003d file.getChannel().tryLock();\n        file.write(jvmName.getBytes(Charsets.UTF_8));\n        LOG.info(\"Lock on \" + lockF + \" acquired by nodename \" + jvmName);\n      } catch(OverlappingFileLockException oe) {\n        // Cannot read from the locked file on Windows.\n        String lockingJvmName \u003d Path.WINDOWS ? \"\" : (\" \" + file.readLine());\n        LOG.error(\"It appears that another namenode\" + lockingJvmName\n            + \" has already locked the storage directory\");\n        file.close();\n        return null;\n      } catch(IOException e) {\n        LOG.error(\"Failed to acquire lock on \" + lockF + \". If this storage directory is mounted via NFS, \" \n            + \"ensure that the appropriate nfs lock services are running.\", e);\n        file.close();\n        throw e;\n      }\n      if (res !\u003d null \u0026\u0026 !deletionHookAdded) {\n        // If the file existed prior to our startup, we didn\u0027t\n        // call deleteOnExit above. But since we successfully locked\n        // the dir, we can take care of cleaning it up.\n        lockF.deleteOnExit();\n      }\n      return res;\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/common/Storage.java",
      "extendedDetails": {}
    },
    "6449f524552f8c24d20b314ad21f6c579fa08e85": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4032. Specify the charset explicitly rather than rely on the default. Contributed by Eli Collins\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1431179 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/01/13 6:30 PM",
      "commitName": "6449f524552f8c24d20b314ad21f6c579fa08e85",
      "commitAuthor": "Eli Collins",
      "commitDateOld": "08/11/12 6:57 PM",
      "commitNameOld": "312eb235981166b905a668c82c146ce373ecaffa",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 61.98,
      "commitsBetweenForRepo": 258,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,33 +1,33 @@\n     FileLock tryLock() throws IOException {\n       boolean deletionHookAdded \u003d false;\n       File lockF \u003d new File(root, STORAGE_FILE_LOCK);\n       if (!lockF.exists()) {\n         lockF.deleteOnExit();\n         deletionHookAdded \u003d true;\n       }\n       RandomAccessFile file \u003d new RandomAccessFile(lockF, \"rws\");\n       String jvmName \u003d ManagementFactory.getRuntimeMXBean().getName();\n       FileLock res \u003d null;\n       try {\n         res \u003d file.getChannel().tryLock();\n-        file.write(jvmName.getBytes());\n+        file.write(jvmName.getBytes(Charsets.UTF_8));\n         LOG.info(\"Lock on \" + lockF + \" acquired by nodename \" + jvmName);\n       } catch(OverlappingFileLockException oe) {\n         LOG.error(\"It appears that another namenode \" + file.readLine() \n             + \" has already locked the storage directory\");\n         file.close();\n         return null;\n       } catch(IOException e) {\n         LOG.error(\"Failed to acquire lock on \" + lockF + \". If this storage directory is mounted via NFS, \" \n             + \"ensure that the appropriate nfs lock services are running.\", e);\n         file.close();\n         throw e;\n       }\n       if (res !\u003d null \u0026\u0026 !deletionHookAdded) {\n         // If the file existed prior to our startup, we didn\u0027t\n         // call deleteOnExit above. But since we successfully locked\n         // the dir, we can take care of cleaning it up.\n         lockF.deleteOnExit();\n       }\n       return res;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    FileLock tryLock() throws IOException {\n      boolean deletionHookAdded \u003d false;\n      File lockF \u003d new File(root, STORAGE_FILE_LOCK);\n      if (!lockF.exists()) {\n        lockF.deleteOnExit();\n        deletionHookAdded \u003d true;\n      }\n      RandomAccessFile file \u003d new RandomAccessFile(lockF, \"rws\");\n      String jvmName \u003d ManagementFactory.getRuntimeMXBean().getName();\n      FileLock res \u003d null;\n      try {\n        res \u003d file.getChannel().tryLock();\n        file.write(jvmName.getBytes(Charsets.UTF_8));\n        LOG.info(\"Lock on \" + lockF + \" acquired by nodename \" + jvmName);\n      } catch(OverlappingFileLockException oe) {\n        LOG.error(\"It appears that another namenode \" + file.readLine() \n            + \" has already locked the storage directory\");\n        file.close();\n        return null;\n      } catch(IOException e) {\n        LOG.error(\"Failed to acquire lock on \" + lockF + \". If this storage directory is mounted via NFS, \" \n            + \"ensure that the appropriate nfs lock services are running.\", e);\n        file.close();\n        throw e;\n      }\n      if (res !\u003d null \u0026\u0026 !deletionHookAdded) {\n        // If the file existed prior to our startup, we didn\u0027t\n        // call deleteOnExit above. But since we successfully locked\n        // the dir, we can take care of cleaning it up.\n        lockF.deleteOnExit();\n      }\n      return res;\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/common/Storage.java",
      "extendedDetails": {}
    },
    "e5b00f1bdc16dfd55ce28280d1e6cfe1f27fb7e4": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2988. Improve error message when storage directory lock fails. Contributed by Miomir Boljanovic. (harsh)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1358683 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/07/12 5:36 PM",
      "commitName": "e5b00f1bdc16dfd55ce28280d1e6cfe1f27fb7e4",
      "commitAuthor": "Harsh J",
      "commitDateOld": "02/07/12 4:59 PM",
      "commitNameOld": "8dd3148e734fa9d1db761ce65410fdc49c0fe1d5",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 5.03,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,27 +1,33 @@\n     FileLock tryLock() throws IOException {\n       boolean deletionHookAdded \u003d false;\n       File lockF \u003d new File(root, STORAGE_FILE_LOCK);\n       if (!lockF.exists()) {\n         lockF.deleteOnExit();\n         deletionHookAdded \u003d true;\n       }\n       RandomAccessFile file \u003d new RandomAccessFile(lockF, \"rws\");\n+      String jvmName \u003d ManagementFactory.getRuntimeMXBean().getName();\n       FileLock res \u003d null;\n       try {\n         res \u003d file.getChannel().tryLock();\n+        file.write(jvmName.getBytes());\n+        LOG.info(\"Lock on \" + lockF + \" acquired by nodename \" + jvmName);\n       } catch(OverlappingFileLockException oe) {\n+        LOG.error(\"It appears that another namenode \" + file.readLine() \n+            + \" has already locked the storage directory\");\n         file.close();\n         return null;\n       } catch(IOException e) {\n-        LOG.error(\"Cannot create lock on \" + lockF, e);\n+        LOG.error(\"Failed to acquire lock on \" + lockF + \". If this storage directory is mounted via NFS, \" \n+            + \"ensure that the appropriate nfs lock services are running.\", e);\n         file.close();\n         throw e;\n       }\n       if (res !\u003d null \u0026\u0026 !deletionHookAdded) {\n         // If the file existed prior to our startup, we didn\u0027t\n         // call deleteOnExit above. But since we successfully locked\n         // the dir, we can take care of cleaning it up.\n         lockF.deleteOnExit();\n       }\n       return res;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    FileLock tryLock() throws IOException {\n      boolean deletionHookAdded \u003d false;\n      File lockF \u003d new File(root, STORAGE_FILE_LOCK);\n      if (!lockF.exists()) {\n        lockF.deleteOnExit();\n        deletionHookAdded \u003d true;\n      }\n      RandomAccessFile file \u003d new RandomAccessFile(lockF, \"rws\");\n      String jvmName \u003d ManagementFactory.getRuntimeMXBean().getName();\n      FileLock res \u003d null;\n      try {\n        res \u003d file.getChannel().tryLock();\n        file.write(jvmName.getBytes());\n        LOG.info(\"Lock on \" + lockF + \" acquired by nodename \" + jvmName);\n      } catch(OverlappingFileLockException oe) {\n        LOG.error(\"It appears that another namenode \" + file.readLine() \n            + \" has already locked the storage directory\");\n        file.close();\n        return null;\n      } catch(IOException e) {\n        LOG.error(\"Failed to acquire lock on \" + lockF + \". If this storage directory is mounted via NFS, \" \n            + \"ensure that the appropriate nfs lock services are running.\", e);\n        file.close();\n        throw e;\n      }\n      if (res !\u003d null \u0026\u0026 !deletionHookAdded) {\n        // If the file existed prior to our startup, we didn\u0027t\n        // call deleteOnExit above. But since we successfully locked\n        // the dir, we can take care of cleaning it up.\n        lockF.deleteOnExit();\n      }\n      return res;\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/common/Storage.java",
      "extendedDetails": {}
    },
    "6d5510dfb8bdd1cce577dc713b1d5849dc572d91": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2877. If locking of a storage dir fails, it will remove the other NN\u0027s lock file on exit. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1239880 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/02/12 2:12 PM",
      "commitName": "6d5510dfb8bdd1cce577dc713b1d5849dc572d91",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "04/09/11 12:30 PM",
      "commitNameOld": "8ae98a9d1ca4725e28783370517cb3a3ecda7324",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 151.11,
      "commitsBetweenForRepo": 954,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,17 +1,27 @@\n     FileLock tryLock() throws IOException {\n+      boolean deletionHookAdded \u003d false;\n       File lockF \u003d new File(root, STORAGE_FILE_LOCK);\n-      lockF.deleteOnExit();\n+      if (!lockF.exists()) {\n+        lockF.deleteOnExit();\n+        deletionHookAdded \u003d true;\n+      }\n       RandomAccessFile file \u003d new RandomAccessFile(lockF, \"rws\");\n       FileLock res \u003d null;\n       try {\n         res \u003d file.getChannel().tryLock();\n       } catch(OverlappingFileLockException oe) {\n         file.close();\n         return null;\n       } catch(IOException e) {\n         LOG.error(\"Cannot create lock on \" + lockF, e);\n         file.close();\n         throw e;\n       }\n+      if (res !\u003d null \u0026\u0026 !deletionHookAdded) {\n+        // If the file existed prior to our startup, we didn\u0027t\n+        // call deleteOnExit above. But since we successfully locked\n+        // the dir, we can take care of cleaning it up.\n+        lockF.deleteOnExit();\n+      }\n       return res;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    FileLock tryLock() throws IOException {\n      boolean deletionHookAdded \u003d false;\n      File lockF \u003d new File(root, STORAGE_FILE_LOCK);\n      if (!lockF.exists()) {\n        lockF.deleteOnExit();\n        deletionHookAdded \u003d true;\n      }\n      RandomAccessFile file \u003d new RandomAccessFile(lockF, \"rws\");\n      FileLock res \u003d null;\n      try {\n        res \u003d file.getChannel().tryLock();\n      } catch(OverlappingFileLockException oe) {\n        file.close();\n        return null;\n      } catch(IOException e) {\n        LOG.error(\"Cannot create lock on \" + lockF, e);\n        file.close();\n        throw e;\n      }\n      if (res !\u003d null \u0026\u0026 !deletionHookAdded) {\n        // If the file existed prior to our startup, we didn\u0027t\n        // call deleteOnExit above. But since we successfully locked\n        // the dir, we can take care of cleaning it up.\n        lockF.deleteOnExit();\n      }\n      return res;\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/common/Storage.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    FileLock tryLock() throws IOException {\n      File lockF \u003d new File(root, STORAGE_FILE_LOCK);\n      lockF.deleteOnExit();\n      RandomAccessFile file \u003d new RandomAccessFile(lockF, \"rws\");\n      FileLock res \u003d null;\n      try {\n        res \u003d file.getChannel().tryLock();\n      } catch(OverlappingFileLockException oe) {\n        file.close();\n        return null;\n      } catch(IOException e) {\n        LOG.error(\"Cannot create lock on \" + lockF, e);\n        file.close();\n        throw e;\n      }\n      return res;\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/common/Storage.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/common/Storage.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/common/Storage.java"
      }
    },
    "d86f3183d93714ba078416af4f609d26376eadb0": {
      "type": "Yfilerename",
      "commitMessage": "HDFS-2096. Mavenization of hadoop-hdfs. Contributed by Alejandro Abdelnur.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159702 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/08/11 10:36 AM",
      "commitName": "d86f3183d93714ba078416af4f609d26376eadb0",
      "commitAuthor": "Thomas White",
      "commitDateOld": "19/08/11 10:26 AM",
      "commitNameOld": "6ee5a73e0e91a2ef27753a32c576835e951d8119",
      "commitAuthorOld": "Thomas White",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    FileLock tryLock() throws IOException {\n      File lockF \u003d new File(root, STORAGE_FILE_LOCK);\n      lockF.deleteOnExit();\n      RandomAccessFile file \u003d new RandomAccessFile(lockF, \"rws\");\n      FileLock res \u003d null;\n      try {\n        res \u003d file.getChannel().tryLock();\n      } catch(OverlappingFileLockException oe) {\n        file.close();\n        return null;\n      } catch(IOException e) {\n        LOG.error(\"Cannot create lock on \" + lockF, e);\n        file.close();\n        throw e;\n      }\n      return res;\n    }",
      "path": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/common/Storage.java",
      "extendedDetails": {
        "oldPath": "hdfs/src/java/org/apache/hadoop/hdfs/server/common/Storage.java",
        "newPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/common/Storage.java"
      }
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "diff": "@@ -0,0 +1,17 @@\n+    FileLock tryLock() throws IOException {\n+      File lockF \u003d new File(root, STORAGE_FILE_LOCK);\n+      lockF.deleteOnExit();\n+      RandomAccessFile file \u003d new RandomAccessFile(lockF, \"rws\");\n+      FileLock res \u003d null;\n+      try {\n+        res \u003d file.getChannel().tryLock();\n+      } catch(OverlappingFileLockException oe) {\n+        file.close();\n+        return null;\n+      } catch(IOException e) {\n+        LOG.error(\"Cannot create lock on \" + lockF, e);\n+        file.close();\n+        throw e;\n+      }\n+      return res;\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    FileLock tryLock() throws IOException {\n      File lockF \u003d new File(root, STORAGE_FILE_LOCK);\n      lockF.deleteOnExit();\n      RandomAccessFile file \u003d new RandomAccessFile(lockF, \"rws\");\n      FileLock res \u003d null;\n      try {\n        res \u003d file.getChannel().tryLock();\n      } catch(OverlappingFileLockException oe) {\n        file.close();\n        return null;\n      } catch(IOException e) {\n        LOG.error(\"Cannot create lock on \" + lockF, e);\n        file.close();\n        throw e;\n      }\n      return res;\n    }",
      "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/common/Storage.java"
    }
  }
}