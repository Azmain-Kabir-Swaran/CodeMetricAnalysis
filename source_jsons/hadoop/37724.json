{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "DefaultAMSProcessor.java",
  "functionName": "allocate",
  "functionId": "allocate___appAttemptId-ApplicationAttemptId__request-AllocateRequest__response-AllocateResponse",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/DefaultAMSProcessor.java",
  "functionStartLine": 217,
  "functionEndLine": 363,
  "numCommitsSeen": 104,
  "timeTaken": 11525,
  "changeHistory": [
    "ef950b086354c8a02eecd6745f6ab0fe5449f7b0",
    "425a6c89aedb4d5ad9a524c9f1e631eea2816f9c",
    "c2731d4b6399f88f76341ed697e80652ed1b61ea",
    "570fa2da20706490dc7823efd0ce0cef3ddc81f9",
    "ed13cf84068ad50a78e66211132c1f08238fb65b",
    "f1a893fdbc2dbe949cae786f08bdb2651b88d673",
    "2cccf4061cc4021c48e29879700dbc94f832b7d1",
    "4d4dde5112e9ee6b37cbdea17104c5a4c6870bd5",
    "38af23796971193fa529c3d08ffde8fcd6e607b6",
    "fedabcad42067ac7dd24de40fab6be2d3485a540",
    "7594d1de7bbc34cd2e64202095a5e1757154d7d0",
    "78b7e070d8009c78665a2baa64fe888788f53e69",
    "077fcf6a96e420e7f36350931722b8603d010cf1",
    "5496a34c0cb2b1a83cfa6b0aba5a77b05ff2d8f0",
    "0a55bd841ec0f2eb89a0383f4c589526e8b138d4",
    "ac1e5d4f77e3b9df8dcacb0b1f72eecc27931eb8"
  ],
  "changeHistoryShort": {
    "ef950b086354c8a02eecd6745f6ab0fe5449f7b0": "Ybodychange",
    "425a6c89aedb4d5ad9a524c9f1e631eea2816f9c": "Ybodychange",
    "c2731d4b6399f88f76341ed697e80652ed1b61ea": "Ybodychange",
    "570fa2da20706490dc7823efd0ce0cef3ddc81f9": "Ybodychange",
    "ed13cf84068ad50a78e66211132c1f08238fb65b": "Ybodychange",
    "f1a893fdbc2dbe949cae786f08bdb2651b88d673": "Ybodychange",
    "2cccf4061cc4021c48e29879700dbc94f832b7d1": "Ybodychange",
    "4d4dde5112e9ee6b37cbdea17104c5a4c6870bd5": "Ybodychange",
    "38af23796971193fa529c3d08ffde8fcd6e607b6": "Ybodychange",
    "fedabcad42067ac7dd24de40fab6be2d3485a540": "Ybodychange",
    "7594d1de7bbc34cd2e64202095a5e1757154d7d0": "Ybodychange",
    "78b7e070d8009c78665a2baa64fe888788f53e69": "Ybodychange",
    "077fcf6a96e420e7f36350931722b8603d010cf1": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
    "5496a34c0cb2b1a83cfa6b0aba5a77b05ff2d8f0": "Ymultichange(Ymovefromfile,Yreturntypechange,Ymodifierchange,Ybodychange,Yrename,Yparameterchange)",
    "0a55bd841ec0f2eb89a0383f4c589526e8b138d4": "Ybodychange",
    "ac1e5d4f77e3b9df8dcacb0b1f72eecc27931eb8": "Yintroduced"
  },
  "changeHistoryDetails": {
    "ef950b086354c8a02eecd6745f6ab0fe5449f7b0": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9290. Invalid SchedulingRequest not rejected in Scheduler PlacementConstraintsHandler. Contributed by Prabhu Joseph\n",
      "commitDate": "26/11/19 1:04 PM",
      "commitName": "ef950b086354c8a02eecd6745f6ab0fe5449f7b0",
      "commitAuthor": "Szilard Nemeth",
      "commitDateOld": "01/10/19 3:32 AM",
      "commitNameOld": "425a6c89aedb4d5ad9a524c9f1e631eea2816f9c",
      "commitAuthorOld": "bibinchundatt",
      "daysBetweenCommits": 56.44,
      "commitsBetweenForRepo": 274,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,144 +1,147 @@\n   public void allocate(ApplicationAttemptId appAttemptId,\n       AllocateRequest request, AllocateResponse response) throws YarnException {\n \n     handleProgress(appAttemptId, request);\n \n     List\u003cResourceRequest\u003e ask \u003d request.getAskList();\n     List\u003cContainerId\u003e release \u003d request.getReleaseList();\n \n     ResourceBlacklistRequest blacklistRequest \u003d\n         request.getResourceBlacklistRequest();\n     List\u003cString\u003e blacklistAdditions \u003d\n         (blacklistRequest !\u003d null) ?\n             blacklistRequest.getBlacklistAdditions() : Collections.emptyList();\n     List\u003cString\u003e blacklistRemovals \u003d\n         (blacklistRequest !\u003d null) ?\n             blacklistRequest.getBlacklistRemovals() : Collections.emptyList();\n     RMApp app \u003d\n         getRmContext().getRMApps().get(appAttemptId.getApplicationId());\n \n     // set label expression for Resource Requests if resourceName\u003dANY\n     ApplicationSubmissionContext asc \u003d app.getApplicationSubmissionContext();\n     for (ResourceRequest req : ask) {\n       if (null \u003d\u003d req.getNodeLabelExpression()\n           \u0026\u0026 ResourceRequest.ANY.equals(req.getResourceName())) {\n         req.setNodeLabelExpression(asc.getNodeLabelExpression());\n       }\n       if (ResourceRequest.ANY.equals(req.getResourceName())) {\n         SchedulerUtils.enforcePartitionExclusivity(req,\n             exclusiveEnforcedPartitions, asc.getNodeLabelExpression());\n       }\n     }\n \n     Resource maximumCapacity \u003d\n         getScheduler().getMaximumResourceCapability(app.getQueue());\n \n     // sanity check\n     try {\n       RMServerUtils.normalizeAndValidateRequests(ask,\n           maximumCapacity, app.getQueue(),\n           getScheduler(), getRmContext(), nodelabelsEnabled);\n     } catch (InvalidResourceRequestException e) {\n       RMAppAttempt rmAppAttempt \u003d app.getRMAppAttempt(appAttemptId);\n       handleInvalidResourceException(e, rmAppAttempt);\n     }\n \n     try {\n       RMServerUtils.validateBlacklistRequest(blacklistRequest);\n     }  catch (InvalidResourceBlacklistRequestException e) {\n       LOG.warn(\"Invalid blacklist request by application \" + appAttemptId, e);\n       throw e;\n     }\n \n     // In the case of work-preserving AM restart, it\u0027s possible for the\n     // AM to release containers from the earlier attempt.\n     if (!app.getApplicationSubmissionContext()\n         .getKeepContainersAcrossApplicationAttempts()) {\n       try {\n         RMServerUtils.validateContainerReleaseRequest(release, appAttemptId);\n       } catch (InvalidContainerReleaseException e) {\n         LOG.warn(\"Invalid container release by application \" + appAttemptId,\n             e);\n         throw e;\n       }\n     }\n \n     // Split Update Resource Requests into increase and decrease.\n     // No Exceptions are thrown here. All update errors are aggregated\n     // and returned to the AM.\n     List\u003cUpdateContainerError\u003e updateErrors \u003d new ArrayList\u003c\u003e();\n     ContainerUpdates containerUpdateRequests \u003d\n         RMServerUtils.validateAndSplitUpdateResourceRequests(\n             getRmContext(), request, maximumCapacity, updateErrors);\n \n     // Send new requests to appAttempt.\n     Allocation allocation;\n     RMAppAttemptState state \u003d\n         app.getRMAppAttempt(appAttemptId).getAppAttemptState();\n     if (state.equals(RMAppAttemptState.FINAL_SAVING) ||\n         state.equals(RMAppAttemptState.FINISHING) ||\n         app.isAppFinalStateStored()) {\n       LOG.warn(appAttemptId + \" is in \" + state +\n           \" state, ignore container allocate request.\");\n       allocation \u003d EMPTY_ALLOCATION;\n     } else {\n       try {\n         allocation \u003d getScheduler().allocate(appAttemptId, ask,\n             request.getSchedulingRequests(), release,\n             blacklistAdditions, blacklistRemovals, containerUpdateRequests);\n       } catch (SchedulerInvalidResoureRequestException e) {\n         LOG.warn(\"Exceptions caught when scheduler handling requests\");\n         throw new YarnException(e);\n       }\n     }\n \n     if (!blacklistAdditions.isEmpty() || !blacklistRemovals.isEmpty()) {\n       LOG.info(\"blacklist are updated in Scheduler.\" +\n           \"blacklistAdditions: \" + blacklistAdditions + \", \" +\n           \"blacklistRemovals: \" + blacklistRemovals);\n     }\n     RMAppAttempt appAttempt \u003d app.getRMAppAttempt(appAttemptId);\n \n     if (allocation.getNMTokens() !\u003d null \u0026\u0026\n         !allocation.getNMTokens().isEmpty()) {\n       response.setNMTokens(allocation.getNMTokens());\n     }\n \n     // Notify the AM of container update errors\n     ApplicationMasterServiceUtils.addToUpdateContainerErrors(\n         response, updateErrors);\n \n     // update the response with the deltas of node status changes\n     handleNodeUpdates(app, response);\n \n     ApplicationMasterServiceUtils.addToAllocatedContainers(\n         response, allocation.getContainers());\n \n     response.setCompletedContainersStatuses(appAttempt\n         .pullJustFinishedContainers());\n     response.setAvailableResources(allocation.getResourceLimit());\n \n     addToContainerUpdates(response, allocation,\n         ((AbstractYarnScheduler)getScheduler())\n             .getApplicationAttempt(appAttemptId).pullUpdateContainerErrors());\n \n     response.setNumClusterNodes(getScheduler().getNumClusterNodes());\n \n     // add collector address for this application\n     if (timelineServiceV2Enabled) {\n       CollectorInfo collectorInfo \u003d app.getCollectorInfo();\n       if (collectorInfo !\u003d null) {\n         response.setCollectorInfo(collectorInfo);\n       }\n     }\n \n     // add preemption to the allocateResponse message (if any)\n     response.setPreemptionMessage(generatePreemptionMessage(allocation));\n \n     // Set application priority\n     response.setApplicationPriority(app\n         .getApplicationPriority());\n \n     response.setContainersFromPreviousAttempts(\n         allocation.getPreviousAttemptContainers());\n+\n+    response.setRejectedSchedulingRequests(allocation.getRejectedRequest());\n+\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void allocate(ApplicationAttemptId appAttemptId,\n      AllocateRequest request, AllocateResponse response) throws YarnException {\n\n    handleProgress(appAttemptId, request);\n\n    List\u003cResourceRequest\u003e ask \u003d request.getAskList();\n    List\u003cContainerId\u003e release \u003d request.getReleaseList();\n\n    ResourceBlacklistRequest blacklistRequest \u003d\n        request.getResourceBlacklistRequest();\n    List\u003cString\u003e blacklistAdditions \u003d\n        (blacklistRequest !\u003d null) ?\n            blacklistRequest.getBlacklistAdditions() : Collections.emptyList();\n    List\u003cString\u003e blacklistRemovals \u003d\n        (blacklistRequest !\u003d null) ?\n            blacklistRequest.getBlacklistRemovals() : Collections.emptyList();\n    RMApp app \u003d\n        getRmContext().getRMApps().get(appAttemptId.getApplicationId());\n\n    // set label expression for Resource Requests if resourceName\u003dANY\n    ApplicationSubmissionContext asc \u003d app.getApplicationSubmissionContext();\n    for (ResourceRequest req : ask) {\n      if (null \u003d\u003d req.getNodeLabelExpression()\n          \u0026\u0026 ResourceRequest.ANY.equals(req.getResourceName())) {\n        req.setNodeLabelExpression(asc.getNodeLabelExpression());\n      }\n      if (ResourceRequest.ANY.equals(req.getResourceName())) {\n        SchedulerUtils.enforcePartitionExclusivity(req,\n            exclusiveEnforcedPartitions, asc.getNodeLabelExpression());\n      }\n    }\n\n    Resource maximumCapacity \u003d\n        getScheduler().getMaximumResourceCapability(app.getQueue());\n\n    // sanity check\n    try {\n      RMServerUtils.normalizeAndValidateRequests(ask,\n          maximumCapacity, app.getQueue(),\n          getScheduler(), getRmContext(), nodelabelsEnabled);\n    } catch (InvalidResourceRequestException e) {\n      RMAppAttempt rmAppAttempt \u003d app.getRMAppAttempt(appAttemptId);\n      handleInvalidResourceException(e, rmAppAttempt);\n    }\n\n    try {\n      RMServerUtils.validateBlacklistRequest(blacklistRequest);\n    }  catch (InvalidResourceBlacklistRequestException e) {\n      LOG.warn(\"Invalid blacklist request by application \" + appAttemptId, e);\n      throw e;\n    }\n\n    // In the case of work-preserving AM restart, it\u0027s possible for the\n    // AM to release containers from the earlier attempt.\n    if (!app.getApplicationSubmissionContext()\n        .getKeepContainersAcrossApplicationAttempts()) {\n      try {\n        RMServerUtils.validateContainerReleaseRequest(release, appAttemptId);\n      } catch (InvalidContainerReleaseException e) {\n        LOG.warn(\"Invalid container release by application \" + appAttemptId,\n            e);\n        throw e;\n      }\n    }\n\n    // Split Update Resource Requests into increase and decrease.\n    // No Exceptions are thrown here. All update errors are aggregated\n    // and returned to the AM.\n    List\u003cUpdateContainerError\u003e updateErrors \u003d new ArrayList\u003c\u003e();\n    ContainerUpdates containerUpdateRequests \u003d\n        RMServerUtils.validateAndSplitUpdateResourceRequests(\n            getRmContext(), request, maximumCapacity, updateErrors);\n\n    // Send new requests to appAttempt.\n    Allocation allocation;\n    RMAppAttemptState state \u003d\n        app.getRMAppAttempt(appAttemptId).getAppAttemptState();\n    if (state.equals(RMAppAttemptState.FINAL_SAVING) ||\n        state.equals(RMAppAttemptState.FINISHING) ||\n        app.isAppFinalStateStored()) {\n      LOG.warn(appAttemptId + \" is in \" + state +\n          \" state, ignore container allocate request.\");\n      allocation \u003d EMPTY_ALLOCATION;\n    } else {\n      try {\n        allocation \u003d getScheduler().allocate(appAttemptId, ask,\n            request.getSchedulingRequests(), release,\n            blacklistAdditions, blacklistRemovals, containerUpdateRequests);\n      } catch (SchedulerInvalidResoureRequestException e) {\n        LOG.warn(\"Exceptions caught when scheduler handling requests\");\n        throw new YarnException(e);\n      }\n    }\n\n    if (!blacklistAdditions.isEmpty() || !blacklistRemovals.isEmpty()) {\n      LOG.info(\"blacklist are updated in Scheduler.\" +\n          \"blacklistAdditions: \" + blacklistAdditions + \", \" +\n          \"blacklistRemovals: \" + blacklistRemovals);\n    }\n    RMAppAttempt appAttempt \u003d app.getRMAppAttempt(appAttemptId);\n\n    if (allocation.getNMTokens() !\u003d null \u0026\u0026\n        !allocation.getNMTokens().isEmpty()) {\n      response.setNMTokens(allocation.getNMTokens());\n    }\n\n    // Notify the AM of container update errors\n    ApplicationMasterServiceUtils.addToUpdateContainerErrors(\n        response, updateErrors);\n\n    // update the response with the deltas of node status changes\n    handleNodeUpdates(app, response);\n\n    ApplicationMasterServiceUtils.addToAllocatedContainers(\n        response, allocation.getContainers());\n\n    response.setCompletedContainersStatuses(appAttempt\n        .pullJustFinishedContainers());\n    response.setAvailableResources(allocation.getResourceLimit());\n\n    addToContainerUpdates(response, allocation,\n        ((AbstractYarnScheduler)getScheduler())\n            .getApplicationAttempt(appAttemptId).pullUpdateContainerErrors());\n\n    response.setNumClusterNodes(getScheduler().getNumClusterNodes());\n\n    // add collector address for this application\n    if (timelineServiceV2Enabled) {\n      CollectorInfo collectorInfo \u003d app.getCollectorInfo();\n      if (collectorInfo !\u003d null) {\n        response.setCollectorInfo(collectorInfo);\n      }\n    }\n\n    // add preemption to the allocateResponse message (if any)\n    response.setPreemptionMessage(generatePreemptionMessage(allocation));\n\n    // Set application priority\n    response.setApplicationPriority(app\n        .getApplicationPriority());\n\n    response.setContainersFromPreviousAttempts(\n        allocation.getPreviousAttemptContainers());\n\n    response.setRejectedSchedulingRequests(allocation.getRejectedRequest());\n\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/DefaultAMSProcessor.java",
      "extendedDetails": {}
    },
    "425a6c89aedb4d5ad9a524c9f1e631eea2816f9c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9858. Optimize RMContext getExclusiveEnforcedPartitions. Contributed by Jonathan Hung.\n",
      "commitDate": "01/10/19 3:32 AM",
      "commitName": "425a6c89aedb4d5ad9a524c9f1e631eea2816f9c",
      "commitAuthor": "bibinchundatt",
      "commitDateOld": "24/09/19 1:51 PM",
      "commitNameOld": "c2731d4b6399f88f76341ed697e80652ed1b61ea",
      "commitAuthorOld": "Jonathan Hung",
      "daysBetweenCommits": 6.57,
      "commitsBetweenForRepo": 47,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,145 +1,144 @@\n   public void allocate(ApplicationAttemptId appAttemptId,\n       AllocateRequest request, AllocateResponse response) throws YarnException {\n \n     handleProgress(appAttemptId, request);\n \n     List\u003cResourceRequest\u003e ask \u003d request.getAskList();\n     List\u003cContainerId\u003e release \u003d request.getReleaseList();\n \n     ResourceBlacklistRequest blacklistRequest \u003d\n         request.getResourceBlacklistRequest();\n     List\u003cString\u003e blacklistAdditions \u003d\n         (blacklistRequest !\u003d null) ?\n             blacklistRequest.getBlacklistAdditions() : Collections.emptyList();\n     List\u003cString\u003e blacklistRemovals \u003d\n         (blacklistRequest !\u003d null) ?\n             blacklistRequest.getBlacklistRemovals() : Collections.emptyList();\n     RMApp app \u003d\n         getRmContext().getRMApps().get(appAttemptId.getApplicationId());\n \n     // set label expression for Resource Requests if resourceName\u003dANY\n     ApplicationSubmissionContext asc \u003d app.getApplicationSubmissionContext();\n     for (ResourceRequest req : ask) {\n       if (null \u003d\u003d req.getNodeLabelExpression()\n           \u0026\u0026 ResourceRequest.ANY.equals(req.getResourceName())) {\n         req.setNodeLabelExpression(asc.getNodeLabelExpression());\n       }\n       if (ResourceRequest.ANY.equals(req.getResourceName())) {\n         SchedulerUtils.enforcePartitionExclusivity(req,\n-            getRmContext().getExclusiveEnforcedPartitions(),\n-            asc.getNodeLabelExpression());\n+            exclusiveEnforcedPartitions, asc.getNodeLabelExpression());\n       }\n     }\n \n     Resource maximumCapacity \u003d\n         getScheduler().getMaximumResourceCapability(app.getQueue());\n \n     // sanity check\n     try {\n       RMServerUtils.normalizeAndValidateRequests(ask,\n           maximumCapacity, app.getQueue(),\n           getScheduler(), getRmContext(), nodelabelsEnabled);\n     } catch (InvalidResourceRequestException e) {\n       RMAppAttempt rmAppAttempt \u003d app.getRMAppAttempt(appAttemptId);\n       handleInvalidResourceException(e, rmAppAttempt);\n     }\n \n     try {\n       RMServerUtils.validateBlacklistRequest(blacklistRequest);\n     }  catch (InvalidResourceBlacklistRequestException e) {\n       LOG.warn(\"Invalid blacklist request by application \" + appAttemptId, e);\n       throw e;\n     }\n \n     // In the case of work-preserving AM restart, it\u0027s possible for the\n     // AM to release containers from the earlier attempt.\n     if (!app.getApplicationSubmissionContext()\n         .getKeepContainersAcrossApplicationAttempts()) {\n       try {\n         RMServerUtils.validateContainerReleaseRequest(release, appAttemptId);\n       } catch (InvalidContainerReleaseException e) {\n         LOG.warn(\"Invalid container release by application \" + appAttemptId,\n             e);\n         throw e;\n       }\n     }\n \n     // Split Update Resource Requests into increase and decrease.\n     // No Exceptions are thrown here. All update errors are aggregated\n     // and returned to the AM.\n     List\u003cUpdateContainerError\u003e updateErrors \u003d new ArrayList\u003c\u003e();\n     ContainerUpdates containerUpdateRequests \u003d\n         RMServerUtils.validateAndSplitUpdateResourceRequests(\n             getRmContext(), request, maximumCapacity, updateErrors);\n \n     // Send new requests to appAttempt.\n     Allocation allocation;\n     RMAppAttemptState state \u003d\n         app.getRMAppAttempt(appAttemptId).getAppAttemptState();\n     if (state.equals(RMAppAttemptState.FINAL_SAVING) ||\n         state.equals(RMAppAttemptState.FINISHING) ||\n         app.isAppFinalStateStored()) {\n       LOG.warn(appAttemptId + \" is in \" + state +\n           \" state, ignore container allocate request.\");\n       allocation \u003d EMPTY_ALLOCATION;\n     } else {\n       try {\n         allocation \u003d getScheduler().allocate(appAttemptId, ask,\n             request.getSchedulingRequests(), release,\n             blacklistAdditions, blacklistRemovals, containerUpdateRequests);\n       } catch (SchedulerInvalidResoureRequestException e) {\n         LOG.warn(\"Exceptions caught when scheduler handling requests\");\n         throw new YarnException(e);\n       }\n     }\n \n     if (!blacklistAdditions.isEmpty() || !blacklistRemovals.isEmpty()) {\n       LOG.info(\"blacklist are updated in Scheduler.\" +\n           \"blacklistAdditions: \" + blacklistAdditions + \", \" +\n           \"blacklistRemovals: \" + blacklistRemovals);\n     }\n     RMAppAttempt appAttempt \u003d app.getRMAppAttempt(appAttemptId);\n \n     if (allocation.getNMTokens() !\u003d null \u0026\u0026\n         !allocation.getNMTokens().isEmpty()) {\n       response.setNMTokens(allocation.getNMTokens());\n     }\n \n     // Notify the AM of container update errors\n     ApplicationMasterServiceUtils.addToUpdateContainerErrors(\n         response, updateErrors);\n \n     // update the response with the deltas of node status changes\n     handleNodeUpdates(app, response);\n \n     ApplicationMasterServiceUtils.addToAllocatedContainers(\n         response, allocation.getContainers());\n \n     response.setCompletedContainersStatuses(appAttempt\n         .pullJustFinishedContainers());\n     response.setAvailableResources(allocation.getResourceLimit());\n \n     addToContainerUpdates(response, allocation,\n         ((AbstractYarnScheduler)getScheduler())\n             .getApplicationAttempt(appAttemptId).pullUpdateContainerErrors());\n \n     response.setNumClusterNodes(getScheduler().getNumClusterNodes());\n \n     // add collector address for this application\n     if (timelineServiceV2Enabled) {\n       CollectorInfo collectorInfo \u003d app.getCollectorInfo();\n       if (collectorInfo !\u003d null) {\n         response.setCollectorInfo(collectorInfo);\n       }\n     }\n \n     // add preemption to the allocateResponse message (if any)\n     response.setPreemptionMessage(generatePreemptionMessage(allocation));\n \n     // Set application priority\n     response.setApplicationPriority(app\n         .getApplicationPriority());\n \n     response.setContainersFromPreviousAttempts(\n         allocation.getPreviousAttemptContainers());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void allocate(ApplicationAttemptId appAttemptId,\n      AllocateRequest request, AllocateResponse response) throws YarnException {\n\n    handleProgress(appAttemptId, request);\n\n    List\u003cResourceRequest\u003e ask \u003d request.getAskList();\n    List\u003cContainerId\u003e release \u003d request.getReleaseList();\n\n    ResourceBlacklistRequest blacklistRequest \u003d\n        request.getResourceBlacklistRequest();\n    List\u003cString\u003e blacklistAdditions \u003d\n        (blacklistRequest !\u003d null) ?\n            blacklistRequest.getBlacklistAdditions() : Collections.emptyList();\n    List\u003cString\u003e blacklistRemovals \u003d\n        (blacklistRequest !\u003d null) ?\n            blacklistRequest.getBlacklistRemovals() : Collections.emptyList();\n    RMApp app \u003d\n        getRmContext().getRMApps().get(appAttemptId.getApplicationId());\n\n    // set label expression for Resource Requests if resourceName\u003dANY\n    ApplicationSubmissionContext asc \u003d app.getApplicationSubmissionContext();\n    for (ResourceRequest req : ask) {\n      if (null \u003d\u003d req.getNodeLabelExpression()\n          \u0026\u0026 ResourceRequest.ANY.equals(req.getResourceName())) {\n        req.setNodeLabelExpression(asc.getNodeLabelExpression());\n      }\n      if (ResourceRequest.ANY.equals(req.getResourceName())) {\n        SchedulerUtils.enforcePartitionExclusivity(req,\n            exclusiveEnforcedPartitions, asc.getNodeLabelExpression());\n      }\n    }\n\n    Resource maximumCapacity \u003d\n        getScheduler().getMaximumResourceCapability(app.getQueue());\n\n    // sanity check\n    try {\n      RMServerUtils.normalizeAndValidateRequests(ask,\n          maximumCapacity, app.getQueue(),\n          getScheduler(), getRmContext(), nodelabelsEnabled);\n    } catch (InvalidResourceRequestException e) {\n      RMAppAttempt rmAppAttempt \u003d app.getRMAppAttempt(appAttemptId);\n      handleInvalidResourceException(e, rmAppAttempt);\n    }\n\n    try {\n      RMServerUtils.validateBlacklistRequest(blacklistRequest);\n    }  catch (InvalidResourceBlacklistRequestException e) {\n      LOG.warn(\"Invalid blacklist request by application \" + appAttemptId, e);\n      throw e;\n    }\n\n    // In the case of work-preserving AM restart, it\u0027s possible for the\n    // AM to release containers from the earlier attempt.\n    if (!app.getApplicationSubmissionContext()\n        .getKeepContainersAcrossApplicationAttempts()) {\n      try {\n        RMServerUtils.validateContainerReleaseRequest(release, appAttemptId);\n      } catch (InvalidContainerReleaseException e) {\n        LOG.warn(\"Invalid container release by application \" + appAttemptId,\n            e);\n        throw e;\n      }\n    }\n\n    // Split Update Resource Requests into increase and decrease.\n    // No Exceptions are thrown here. All update errors are aggregated\n    // and returned to the AM.\n    List\u003cUpdateContainerError\u003e updateErrors \u003d new ArrayList\u003c\u003e();\n    ContainerUpdates containerUpdateRequests \u003d\n        RMServerUtils.validateAndSplitUpdateResourceRequests(\n            getRmContext(), request, maximumCapacity, updateErrors);\n\n    // Send new requests to appAttempt.\n    Allocation allocation;\n    RMAppAttemptState state \u003d\n        app.getRMAppAttempt(appAttemptId).getAppAttemptState();\n    if (state.equals(RMAppAttemptState.FINAL_SAVING) ||\n        state.equals(RMAppAttemptState.FINISHING) ||\n        app.isAppFinalStateStored()) {\n      LOG.warn(appAttemptId + \" is in \" + state +\n          \" state, ignore container allocate request.\");\n      allocation \u003d EMPTY_ALLOCATION;\n    } else {\n      try {\n        allocation \u003d getScheduler().allocate(appAttemptId, ask,\n            request.getSchedulingRequests(), release,\n            blacklistAdditions, blacklistRemovals, containerUpdateRequests);\n      } catch (SchedulerInvalidResoureRequestException e) {\n        LOG.warn(\"Exceptions caught when scheduler handling requests\");\n        throw new YarnException(e);\n      }\n    }\n\n    if (!blacklistAdditions.isEmpty() || !blacklistRemovals.isEmpty()) {\n      LOG.info(\"blacklist are updated in Scheduler.\" +\n          \"blacklistAdditions: \" + blacklistAdditions + \", \" +\n          \"blacklistRemovals: \" + blacklistRemovals);\n    }\n    RMAppAttempt appAttempt \u003d app.getRMAppAttempt(appAttemptId);\n\n    if (allocation.getNMTokens() !\u003d null \u0026\u0026\n        !allocation.getNMTokens().isEmpty()) {\n      response.setNMTokens(allocation.getNMTokens());\n    }\n\n    // Notify the AM of container update errors\n    ApplicationMasterServiceUtils.addToUpdateContainerErrors(\n        response, updateErrors);\n\n    // update the response with the deltas of node status changes\n    handleNodeUpdates(app, response);\n\n    ApplicationMasterServiceUtils.addToAllocatedContainers(\n        response, allocation.getContainers());\n\n    response.setCompletedContainersStatuses(appAttempt\n        .pullJustFinishedContainers());\n    response.setAvailableResources(allocation.getResourceLimit());\n\n    addToContainerUpdates(response, allocation,\n        ((AbstractYarnScheduler)getScheduler())\n            .getApplicationAttempt(appAttemptId).pullUpdateContainerErrors());\n\n    response.setNumClusterNodes(getScheduler().getNumClusterNodes());\n\n    // add collector address for this application\n    if (timelineServiceV2Enabled) {\n      CollectorInfo collectorInfo \u003d app.getCollectorInfo();\n      if (collectorInfo !\u003d null) {\n        response.setCollectorInfo(collectorInfo);\n      }\n    }\n\n    // add preemption to the allocateResponse message (if any)\n    response.setPreemptionMessage(generatePreemptionMessage(allocation));\n\n    // Set application priority\n    response.setApplicationPriority(app\n        .getApplicationPriority());\n\n    response.setContainersFromPreviousAttempts(\n        allocation.getPreviousAttemptContainers());\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/DefaultAMSProcessor.java",
      "extendedDetails": {}
    },
    "c2731d4b6399f88f76341ed697e80652ed1b61ea": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9730. Support forcing configured partitions to be exclusive based on app node label\n",
      "commitDate": "24/09/19 1:51 PM",
      "commitName": "c2731d4b6399f88f76341ed697e80652ed1b61ea",
      "commitAuthor": "Jonathan Hung",
      "commitDateOld": "15/05/19 1:00 AM",
      "commitNameOld": "570fa2da20706490dc7823efd0ce0cef3ddc81f9",
      "commitAuthorOld": "bibinchundatt",
      "daysBetweenCommits": 132.54,
      "commitsBetweenForRepo": 1114,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,140 +1,145 @@\n   public void allocate(ApplicationAttemptId appAttemptId,\n       AllocateRequest request, AllocateResponse response) throws YarnException {\n \n     handleProgress(appAttemptId, request);\n \n     List\u003cResourceRequest\u003e ask \u003d request.getAskList();\n     List\u003cContainerId\u003e release \u003d request.getReleaseList();\n \n     ResourceBlacklistRequest blacklistRequest \u003d\n         request.getResourceBlacklistRequest();\n     List\u003cString\u003e blacklistAdditions \u003d\n         (blacklistRequest !\u003d null) ?\n             blacklistRequest.getBlacklistAdditions() : Collections.emptyList();\n     List\u003cString\u003e blacklistRemovals \u003d\n         (blacklistRequest !\u003d null) ?\n             blacklistRequest.getBlacklistRemovals() : Collections.emptyList();\n     RMApp app \u003d\n         getRmContext().getRMApps().get(appAttemptId.getApplicationId());\n \n     // set label expression for Resource Requests if resourceName\u003dANY\n     ApplicationSubmissionContext asc \u003d app.getApplicationSubmissionContext();\n     for (ResourceRequest req : ask) {\n       if (null \u003d\u003d req.getNodeLabelExpression()\n           \u0026\u0026 ResourceRequest.ANY.equals(req.getResourceName())) {\n         req.setNodeLabelExpression(asc.getNodeLabelExpression());\n       }\n+      if (ResourceRequest.ANY.equals(req.getResourceName())) {\n+        SchedulerUtils.enforcePartitionExclusivity(req,\n+            getRmContext().getExclusiveEnforcedPartitions(),\n+            asc.getNodeLabelExpression());\n+      }\n     }\n \n     Resource maximumCapacity \u003d\n         getScheduler().getMaximumResourceCapability(app.getQueue());\n \n     // sanity check\n     try {\n       RMServerUtils.normalizeAndValidateRequests(ask,\n           maximumCapacity, app.getQueue(),\n           getScheduler(), getRmContext(), nodelabelsEnabled);\n     } catch (InvalidResourceRequestException e) {\n       RMAppAttempt rmAppAttempt \u003d app.getRMAppAttempt(appAttemptId);\n       handleInvalidResourceException(e, rmAppAttempt);\n     }\n \n     try {\n       RMServerUtils.validateBlacklistRequest(blacklistRequest);\n     }  catch (InvalidResourceBlacklistRequestException e) {\n       LOG.warn(\"Invalid blacklist request by application \" + appAttemptId, e);\n       throw e;\n     }\n \n     // In the case of work-preserving AM restart, it\u0027s possible for the\n     // AM to release containers from the earlier attempt.\n     if (!app.getApplicationSubmissionContext()\n         .getKeepContainersAcrossApplicationAttempts()) {\n       try {\n         RMServerUtils.validateContainerReleaseRequest(release, appAttemptId);\n       } catch (InvalidContainerReleaseException e) {\n         LOG.warn(\"Invalid container release by application \" + appAttemptId,\n             e);\n         throw e;\n       }\n     }\n \n     // Split Update Resource Requests into increase and decrease.\n     // No Exceptions are thrown here. All update errors are aggregated\n     // and returned to the AM.\n     List\u003cUpdateContainerError\u003e updateErrors \u003d new ArrayList\u003c\u003e();\n     ContainerUpdates containerUpdateRequests \u003d\n         RMServerUtils.validateAndSplitUpdateResourceRequests(\n             getRmContext(), request, maximumCapacity, updateErrors);\n \n     // Send new requests to appAttempt.\n     Allocation allocation;\n     RMAppAttemptState state \u003d\n         app.getRMAppAttempt(appAttemptId).getAppAttemptState();\n     if (state.equals(RMAppAttemptState.FINAL_SAVING) ||\n         state.equals(RMAppAttemptState.FINISHING) ||\n         app.isAppFinalStateStored()) {\n       LOG.warn(appAttemptId + \" is in \" + state +\n           \" state, ignore container allocate request.\");\n       allocation \u003d EMPTY_ALLOCATION;\n     } else {\n       try {\n         allocation \u003d getScheduler().allocate(appAttemptId, ask,\n             request.getSchedulingRequests(), release,\n             blacklistAdditions, blacklistRemovals, containerUpdateRequests);\n       } catch (SchedulerInvalidResoureRequestException e) {\n         LOG.warn(\"Exceptions caught when scheduler handling requests\");\n         throw new YarnException(e);\n       }\n     }\n \n     if (!blacklistAdditions.isEmpty() || !blacklistRemovals.isEmpty()) {\n       LOG.info(\"blacklist are updated in Scheduler.\" +\n           \"blacklistAdditions: \" + blacklistAdditions + \", \" +\n           \"blacklistRemovals: \" + blacklistRemovals);\n     }\n     RMAppAttempt appAttempt \u003d app.getRMAppAttempt(appAttemptId);\n \n     if (allocation.getNMTokens() !\u003d null \u0026\u0026\n         !allocation.getNMTokens().isEmpty()) {\n       response.setNMTokens(allocation.getNMTokens());\n     }\n \n     // Notify the AM of container update errors\n     ApplicationMasterServiceUtils.addToUpdateContainerErrors(\n         response, updateErrors);\n \n     // update the response with the deltas of node status changes\n     handleNodeUpdates(app, response);\n \n     ApplicationMasterServiceUtils.addToAllocatedContainers(\n         response, allocation.getContainers());\n \n     response.setCompletedContainersStatuses(appAttempt\n         .pullJustFinishedContainers());\n     response.setAvailableResources(allocation.getResourceLimit());\n \n     addToContainerUpdates(response, allocation,\n         ((AbstractYarnScheduler)getScheduler())\n             .getApplicationAttempt(appAttemptId).pullUpdateContainerErrors());\n \n     response.setNumClusterNodes(getScheduler().getNumClusterNodes());\n \n     // add collector address for this application\n     if (timelineServiceV2Enabled) {\n       CollectorInfo collectorInfo \u003d app.getCollectorInfo();\n       if (collectorInfo !\u003d null) {\n         response.setCollectorInfo(collectorInfo);\n       }\n     }\n \n     // add preemption to the allocateResponse message (if any)\n     response.setPreemptionMessage(generatePreemptionMessage(allocation));\n \n     // Set application priority\n     response.setApplicationPriority(app\n         .getApplicationPriority());\n \n     response.setContainersFromPreviousAttempts(\n         allocation.getPreviousAttemptContainers());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void allocate(ApplicationAttemptId appAttemptId,\n      AllocateRequest request, AllocateResponse response) throws YarnException {\n\n    handleProgress(appAttemptId, request);\n\n    List\u003cResourceRequest\u003e ask \u003d request.getAskList();\n    List\u003cContainerId\u003e release \u003d request.getReleaseList();\n\n    ResourceBlacklistRequest blacklistRequest \u003d\n        request.getResourceBlacklistRequest();\n    List\u003cString\u003e blacklistAdditions \u003d\n        (blacklistRequest !\u003d null) ?\n            blacklistRequest.getBlacklistAdditions() : Collections.emptyList();\n    List\u003cString\u003e blacklistRemovals \u003d\n        (blacklistRequest !\u003d null) ?\n            blacklistRequest.getBlacklistRemovals() : Collections.emptyList();\n    RMApp app \u003d\n        getRmContext().getRMApps().get(appAttemptId.getApplicationId());\n\n    // set label expression for Resource Requests if resourceName\u003dANY\n    ApplicationSubmissionContext asc \u003d app.getApplicationSubmissionContext();\n    for (ResourceRequest req : ask) {\n      if (null \u003d\u003d req.getNodeLabelExpression()\n          \u0026\u0026 ResourceRequest.ANY.equals(req.getResourceName())) {\n        req.setNodeLabelExpression(asc.getNodeLabelExpression());\n      }\n      if (ResourceRequest.ANY.equals(req.getResourceName())) {\n        SchedulerUtils.enforcePartitionExclusivity(req,\n            getRmContext().getExclusiveEnforcedPartitions(),\n            asc.getNodeLabelExpression());\n      }\n    }\n\n    Resource maximumCapacity \u003d\n        getScheduler().getMaximumResourceCapability(app.getQueue());\n\n    // sanity check\n    try {\n      RMServerUtils.normalizeAndValidateRequests(ask,\n          maximumCapacity, app.getQueue(),\n          getScheduler(), getRmContext(), nodelabelsEnabled);\n    } catch (InvalidResourceRequestException e) {\n      RMAppAttempt rmAppAttempt \u003d app.getRMAppAttempt(appAttemptId);\n      handleInvalidResourceException(e, rmAppAttempt);\n    }\n\n    try {\n      RMServerUtils.validateBlacklistRequest(blacklistRequest);\n    }  catch (InvalidResourceBlacklistRequestException e) {\n      LOG.warn(\"Invalid blacklist request by application \" + appAttemptId, e);\n      throw e;\n    }\n\n    // In the case of work-preserving AM restart, it\u0027s possible for the\n    // AM to release containers from the earlier attempt.\n    if (!app.getApplicationSubmissionContext()\n        .getKeepContainersAcrossApplicationAttempts()) {\n      try {\n        RMServerUtils.validateContainerReleaseRequest(release, appAttemptId);\n      } catch (InvalidContainerReleaseException e) {\n        LOG.warn(\"Invalid container release by application \" + appAttemptId,\n            e);\n        throw e;\n      }\n    }\n\n    // Split Update Resource Requests into increase and decrease.\n    // No Exceptions are thrown here. All update errors are aggregated\n    // and returned to the AM.\n    List\u003cUpdateContainerError\u003e updateErrors \u003d new ArrayList\u003c\u003e();\n    ContainerUpdates containerUpdateRequests \u003d\n        RMServerUtils.validateAndSplitUpdateResourceRequests(\n            getRmContext(), request, maximumCapacity, updateErrors);\n\n    // Send new requests to appAttempt.\n    Allocation allocation;\n    RMAppAttemptState state \u003d\n        app.getRMAppAttempt(appAttemptId).getAppAttemptState();\n    if (state.equals(RMAppAttemptState.FINAL_SAVING) ||\n        state.equals(RMAppAttemptState.FINISHING) ||\n        app.isAppFinalStateStored()) {\n      LOG.warn(appAttemptId + \" is in \" + state +\n          \" state, ignore container allocate request.\");\n      allocation \u003d EMPTY_ALLOCATION;\n    } else {\n      try {\n        allocation \u003d getScheduler().allocate(appAttemptId, ask,\n            request.getSchedulingRequests(), release,\n            blacklistAdditions, blacklistRemovals, containerUpdateRequests);\n      } catch (SchedulerInvalidResoureRequestException e) {\n        LOG.warn(\"Exceptions caught when scheduler handling requests\");\n        throw new YarnException(e);\n      }\n    }\n\n    if (!blacklistAdditions.isEmpty() || !blacklistRemovals.isEmpty()) {\n      LOG.info(\"blacklist are updated in Scheduler.\" +\n          \"blacklistAdditions: \" + blacklistAdditions + \", \" +\n          \"blacklistRemovals: \" + blacklistRemovals);\n    }\n    RMAppAttempt appAttempt \u003d app.getRMAppAttempt(appAttemptId);\n\n    if (allocation.getNMTokens() !\u003d null \u0026\u0026\n        !allocation.getNMTokens().isEmpty()) {\n      response.setNMTokens(allocation.getNMTokens());\n    }\n\n    // Notify the AM of container update errors\n    ApplicationMasterServiceUtils.addToUpdateContainerErrors(\n        response, updateErrors);\n\n    // update the response with the deltas of node status changes\n    handleNodeUpdates(app, response);\n\n    ApplicationMasterServiceUtils.addToAllocatedContainers(\n        response, allocation.getContainers());\n\n    response.setCompletedContainersStatuses(appAttempt\n        .pullJustFinishedContainers());\n    response.setAvailableResources(allocation.getResourceLimit());\n\n    addToContainerUpdates(response, allocation,\n        ((AbstractYarnScheduler)getScheduler())\n            .getApplicationAttempt(appAttemptId).pullUpdateContainerErrors());\n\n    response.setNumClusterNodes(getScheduler().getNumClusterNodes());\n\n    // add collector address for this application\n    if (timelineServiceV2Enabled) {\n      CollectorInfo collectorInfo \u003d app.getCollectorInfo();\n      if (collectorInfo !\u003d null) {\n        response.setCollectorInfo(collectorInfo);\n      }\n    }\n\n    // add preemption to the allocateResponse message (if any)\n    response.setPreemptionMessage(generatePreemptionMessage(allocation));\n\n    // Set application priority\n    response.setApplicationPriority(app\n        .getApplicationPriority());\n\n    response.setContainersFromPreviousAttempts(\n        allocation.getPreviousAttemptContainers());\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/DefaultAMSProcessor.java",
      "extendedDetails": {}
    },
    "570fa2da20706490dc7823efd0ce0cef3ddc81f9": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9508. YarnConfiguration areNodeLabel enabled is costly in allocation flow. Contributed by Bilwa S T.\n",
      "commitDate": "15/05/19 1:00 AM",
      "commitName": "570fa2da20706490dc7823efd0ce0cef3ddc81f9",
      "commitAuthor": "bibinchundatt",
      "commitDateOld": "04/03/19 9:10 PM",
      "commitNameOld": "e40e2d6ad5cbe782c3a067229270738b501ed27e",
      "commitAuthorOld": "Prabhu Joseph",
      "daysBetweenCommits": 71.12,
      "commitsBetweenForRepo": 467,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,140 +1,140 @@\n   public void allocate(ApplicationAttemptId appAttemptId,\n       AllocateRequest request, AllocateResponse response) throws YarnException {\n \n     handleProgress(appAttemptId, request);\n \n     List\u003cResourceRequest\u003e ask \u003d request.getAskList();\n     List\u003cContainerId\u003e release \u003d request.getReleaseList();\n \n     ResourceBlacklistRequest blacklistRequest \u003d\n         request.getResourceBlacklistRequest();\n     List\u003cString\u003e blacklistAdditions \u003d\n         (blacklistRequest !\u003d null) ?\n             blacklistRequest.getBlacklistAdditions() : Collections.emptyList();\n     List\u003cString\u003e blacklistRemovals \u003d\n         (blacklistRequest !\u003d null) ?\n             blacklistRequest.getBlacklistRemovals() : Collections.emptyList();\n     RMApp app \u003d\n         getRmContext().getRMApps().get(appAttemptId.getApplicationId());\n \n     // set label expression for Resource Requests if resourceName\u003dANY\n     ApplicationSubmissionContext asc \u003d app.getApplicationSubmissionContext();\n     for (ResourceRequest req : ask) {\n       if (null \u003d\u003d req.getNodeLabelExpression()\n           \u0026\u0026 ResourceRequest.ANY.equals(req.getResourceName())) {\n         req.setNodeLabelExpression(asc.getNodeLabelExpression());\n       }\n     }\n \n     Resource maximumCapacity \u003d\n         getScheduler().getMaximumResourceCapability(app.getQueue());\n \n     // sanity check\n     try {\n       RMServerUtils.normalizeAndValidateRequests(ask,\n           maximumCapacity, app.getQueue(),\n-          getScheduler(), getRmContext());\n+          getScheduler(), getRmContext(), nodelabelsEnabled);\n     } catch (InvalidResourceRequestException e) {\n       RMAppAttempt rmAppAttempt \u003d app.getRMAppAttempt(appAttemptId);\n       handleInvalidResourceException(e, rmAppAttempt);\n     }\n \n     try {\n       RMServerUtils.validateBlacklistRequest(blacklistRequest);\n     }  catch (InvalidResourceBlacklistRequestException e) {\n       LOG.warn(\"Invalid blacklist request by application \" + appAttemptId, e);\n       throw e;\n     }\n \n     // In the case of work-preserving AM restart, it\u0027s possible for the\n     // AM to release containers from the earlier attempt.\n     if (!app.getApplicationSubmissionContext()\n         .getKeepContainersAcrossApplicationAttempts()) {\n       try {\n         RMServerUtils.validateContainerReleaseRequest(release, appAttemptId);\n       } catch (InvalidContainerReleaseException e) {\n         LOG.warn(\"Invalid container release by application \" + appAttemptId,\n             e);\n         throw e;\n       }\n     }\n \n     // Split Update Resource Requests into increase and decrease.\n     // No Exceptions are thrown here. All update errors are aggregated\n     // and returned to the AM.\n     List\u003cUpdateContainerError\u003e updateErrors \u003d new ArrayList\u003c\u003e();\n     ContainerUpdates containerUpdateRequests \u003d\n         RMServerUtils.validateAndSplitUpdateResourceRequests(\n             getRmContext(), request, maximumCapacity, updateErrors);\n \n     // Send new requests to appAttempt.\n     Allocation allocation;\n     RMAppAttemptState state \u003d\n         app.getRMAppAttempt(appAttemptId).getAppAttemptState();\n     if (state.equals(RMAppAttemptState.FINAL_SAVING) ||\n         state.equals(RMAppAttemptState.FINISHING) ||\n         app.isAppFinalStateStored()) {\n       LOG.warn(appAttemptId + \" is in \" + state +\n           \" state, ignore container allocate request.\");\n       allocation \u003d EMPTY_ALLOCATION;\n     } else {\n       try {\n         allocation \u003d getScheduler().allocate(appAttemptId, ask,\n             request.getSchedulingRequests(), release,\n             blacklistAdditions, blacklistRemovals, containerUpdateRequests);\n       } catch (SchedulerInvalidResoureRequestException e) {\n         LOG.warn(\"Exceptions caught when scheduler handling requests\");\n         throw new YarnException(e);\n       }\n     }\n \n     if (!blacklistAdditions.isEmpty() || !blacklistRemovals.isEmpty()) {\n       LOG.info(\"blacklist are updated in Scheduler.\" +\n           \"blacklistAdditions: \" + blacklistAdditions + \", \" +\n           \"blacklistRemovals: \" + blacklistRemovals);\n     }\n     RMAppAttempt appAttempt \u003d app.getRMAppAttempt(appAttemptId);\n \n     if (allocation.getNMTokens() !\u003d null \u0026\u0026\n         !allocation.getNMTokens().isEmpty()) {\n       response.setNMTokens(allocation.getNMTokens());\n     }\n \n     // Notify the AM of container update errors\n     ApplicationMasterServiceUtils.addToUpdateContainerErrors(\n         response, updateErrors);\n \n     // update the response with the deltas of node status changes\n     handleNodeUpdates(app, response);\n \n     ApplicationMasterServiceUtils.addToAllocatedContainers(\n         response, allocation.getContainers());\n \n     response.setCompletedContainersStatuses(appAttempt\n         .pullJustFinishedContainers());\n     response.setAvailableResources(allocation.getResourceLimit());\n \n     addToContainerUpdates(response, allocation,\n         ((AbstractYarnScheduler)getScheduler())\n             .getApplicationAttempt(appAttemptId).pullUpdateContainerErrors());\n \n     response.setNumClusterNodes(getScheduler().getNumClusterNodes());\n \n     // add collector address for this application\n     if (timelineServiceV2Enabled) {\n       CollectorInfo collectorInfo \u003d app.getCollectorInfo();\n       if (collectorInfo !\u003d null) {\n         response.setCollectorInfo(collectorInfo);\n       }\n     }\n \n     // add preemption to the allocateResponse message (if any)\n     response.setPreemptionMessage(generatePreemptionMessage(allocation));\n \n     // Set application priority\n     response.setApplicationPriority(app\n         .getApplicationPriority());\n \n     response.setContainersFromPreviousAttempts(\n         allocation.getPreviousAttemptContainers());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void allocate(ApplicationAttemptId appAttemptId,\n      AllocateRequest request, AllocateResponse response) throws YarnException {\n\n    handleProgress(appAttemptId, request);\n\n    List\u003cResourceRequest\u003e ask \u003d request.getAskList();\n    List\u003cContainerId\u003e release \u003d request.getReleaseList();\n\n    ResourceBlacklistRequest blacklistRequest \u003d\n        request.getResourceBlacklistRequest();\n    List\u003cString\u003e blacklistAdditions \u003d\n        (blacklistRequest !\u003d null) ?\n            blacklistRequest.getBlacklistAdditions() : Collections.emptyList();\n    List\u003cString\u003e blacklistRemovals \u003d\n        (blacklistRequest !\u003d null) ?\n            blacklistRequest.getBlacklistRemovals() : Collections.emptyList();\n    RMApp app \u003d\n        getRmContext().getRMApps().get(appAttemptId.getApplicationId());\n\n    // set label expression for Resource Requests if resourceName\u003dANY\n    ApplicationSubmissionContext asc \u003d app.getApplicationSubmissionContext();\n    for (ResourceRequest req : ask) {\n      if (null \u003d\u003d req.getNodeLabelExpression()\n          \u0026\u0026 ResourceRequest.ANY.equals(req.getResourceName())) {\n        req.setNodeLabelExpression(asc.getNodeLabelExpression());\n      }\n    }\n\n    Resource maximumCapacity \u003d\n        getScheduler().getMaximumResourceCapability(app.getQueue());\n\n    // sanity check\n    try {\n      RMServerUtils.normalizeAndValidateRequests(ask,\n          maximumCapacity, app.getQueue(),\n          getScheduler(), getRmContext(), nodelabelsEnabled);\n    } catch (InvalidResourceRequestException e) {\n      RMAppAttempt rmAppAttempt \u003d app.getRMAppAttempt(appAttemptId);\n      handleInvalidResourceException(e, rmAppAttempt);\n    }\n\n    try {\n      RMServerUtils.validateBlacklistRequest(blacklistRequest);\n    }  catch (InvalidResourceBlacklistRequestException e) {\n      LOG.warn(\"Invalid blacklist request by application \" + appAttemptId, e);\n      throw e;\n    }\n\n    // In the case of work-preserving AM restart, it\u0027s possible for the\n    // AM to release containers from the earlier attempt.\n    if (!app.getApplicationSubmissionContext()\n        .getKeepContainersAcrossApplicationAttempts()) {\n      try {\n        RMServerUtils.validateContainerReleaseRequest(release, appAttemptId);\n      } catch (InvalidContainerReleaseException e) {\n        LOG.warn(\"Invalid container release by application \" + appAttemptId,\n            e);\n        throw e;\n      }\n    }\n\n    // Split Update Resource Requests into increase and decrease.\n    // No Exceptions are thrown here. All update errors are aggregated\n    // and returned to the AM.\n    List\u003cUpdateContainerError\u003e updateErrors \u003d new ArrayList\u003c\u003e();\n    ContainerUpdates containerUpdateRequests \u003d\n        RMServerUtils.validateAndSplitUpdateResourceRequests(\n            getRmContext(), request, maximumCapacity, updateErrors);\n\n    // Send new requests to appAttempt.\n    Allocation allocation;\n    RMAppAttemptState state \u003d\n        app.getRMAppAttempt(appAttemptId).getAppAttemptState();\n    if (state.equals(RMAppAttemptState.FINAL_SAVING) ||\n        state.equals(RMAppAttemptState.FINISHING) ||\n        app.isAppFinalStateStored()) {\n      LOG.warn(appAttemptId + \" is in \" + state +\n          \" state, ignore container allocate request.\");\n      allocation \u003d EMPTY_ALLOCATION;\n    } else {\n      try {\n        allocation \u003d getScheduler().allocate(appAttemptId, ask,\n            request.getSchedulingRequests(), release,\n            blacklistAdditions, blacklistRemovals, containerUpdateRequests);\n      } catch (SchedulerInvalidResoureRequestException e) {\n        LOG.warn(\"Exceptions caught when scheduler handling requests\");\n        throw new YarnException(e);\n      }\n    }\n\n    if (!blacklistAdditions.isEmpty() || !blacklistRemovals.isEmpty()) {\n      LOG.info(\"blacklist are updated in Scheduler.\" +\n          \"blacklistAdditions: \" + blacklistAdditions + \", \" +\n          \"blacklistRemovals: \" + blacklistRemovals);\n    }\n    RMAppAttempt appAttempt \u003d app.getRMAppAttempt(appAttemptId);\n\n    if (allocation.getNMTokens() !\u003d null \u0026\u0026\n        !allocation.getNMTokens().isEmpty()) {\n      response.setNMTokens(allocation.getNMTokens());\n    }\n\n    // Notify the AM of container update errors\n    ApplicationMasterServiceUtils.addToUpdateContainerErrors(\n        response, updateErrors);\n\n    // update the response with the deltas of node status changes\n    handleNodeUpdates(app, response);\n\n    ApplicationMasterServiceUtils.addToAllocatedContainers(\n        response, allocation.getContainers());\n\n    response.setCompletedContainersStatuses(appAttempt\n        .pullJustFinishedContainers());\n    response.setAvailableResources(allocation.getResourceLimit());\n\n    addToContainerUpdates(response, allocation,\n        ((AbstractYarnScheduler)getScheduler())\n            .getApplicationAttempt(appAttemptId).pullUpdateContainerErrors());\n\n    response.setNumClusterNodes(getScheduler().getNumClusterNodes());\n\n    // add collector address for this application\n    if (timelineServiceV2Enabled) {\n      CollectorInfo collectorInfo \u003d app.getCollectorInfo();\n      if (collectorInfo !\u003d null) {\n        response.setCollectorInfo(collectorInfo);\n      }\n    }\n\n    // add preemption to the allocateResponse message (if any)\n    response.setPreemptionMessage(generatePreemptionMessage(allocation));\n\n    // Set application priority\n    response.setApplicationPriority(app\n        .getApplicationPriority());\n\n    response.setContainersFromPreviousAttempts(\n        allocation.getPreviousAttemptContainers());\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/DefaultAMSProcessor.java",
      "extendedDetails": {}
    },
    "ed13cf84068ad50a78e66211132c1f08238fb65b": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9317. Avoid repeated YarnConfiguration#timelineServiceV2Enabled check. Contributed by Prabhu Joseph\n",
      "commitDate": "22/02/19 7:31 AM",
      "commitName": "ed13cf84068ad50a78e66211132c1f08238fb65b",
      "commitAuthor": "bibinchundatt",
      "commitDateOld": "14/09/18 1:33 AM",
      "commitNameOld": "f1a893fdbc2dbe949cae786f08bdb2651b88d673",
      "commitAuthorOld": "Weiwei Yang",
      "daysBetweenCommits": 161.29,
      "commitsBetweenForRepo": 1260,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,141 +1,140 @@\n   public void allocate(ApplicationAttemptId appAttemptId,\n       AllocateRequest request, AllocateResponse response) throws YarnException {\n \n     handleProgress(appAttemptId, request);\n \n     List\u003cResourceRequest\u003e ask \u003d request.getAskList();\n     List\u003cContainerId\u003e release \u003d request.getReleaseList();\n \n     ResourceBlacklistRequest blacklistRequest \u003d\n         request.getResourceBlacklistRequest();\n     List\u003cString\u003e blacklistAdditions \u003d\n         (blacklistRequest !\u003d null) ?\n             blacklistRequest.getBlacklistAdditions() : Collections.emptyList();\n     List\u003cString\u003e blacklistRemovals \u003d\n         (blacklistRequest !\u003d null) ?\n             blacklistRequest.getBlacklistRemovals() : Collections.emptyList();\n     RMApp app \u003d\n         getRmContext().getRMApps().get(appAttemptId.getApplicationId());\n \n     // set label expression for Resource Requests if resourceName\u003dANY\n     ApplicationSubmissionContext asc \u003d app.getApplicationSubmissionContext();\n     for (ResourceRequest req : ask) {\n       if (null \u003d\u003d req.getNodeLabelExpression()\n           \u0026\u0026 ResourceRequest.ANY.equals(req.getResourceName())) {\n         req.setNodeLabelExpression(asc.getNodeLabelExpression());\n       }\n     }\n \n     Resource maximumCapacity \u003d\n         getScheduler().getMaximumResourceCapability(app.getQueue());\n \n     // sanity check\n     try {\n       RMServerUtils.normalizeAndValidateRequests(ask,\n           maximumCapacity, app.getQueue(),\n           getScheduler(), getRmContext());\n     } catch (InvalidResourceRequestException e) {\n       RMAppAttempt rmAppAttempt \u003d app.getRMAppAttempt(appAttemptId);\n       handleInvalidResourceException(e, rmAppAttempt);\n     }\n \n     try {\n       RMServerUtils.validateBlacklistRequest(blacklistRequest);\n     }  catch (InvalidResourceBlacklistRequestException e) {\n       LOG.warn(\"Invalid blacklist request by application \" + appAttemptId, e);\n       throw e;\n     }\n \n     // In the case of work-preserving AM restart, it\u0027s possible for the\n     // AM to release containers from the earlier attempt.\n     if (!app.getApplicationSubmissionContext()\n         .getKeepContainersAcrossApplicationAttempts()) {\n       try {\n         RMServerUtils.validateContainerReleaseRequest(release, appAttemptId);\n       } catch (InvalidContainerReleaseException e) {\n         LOG.warn(\"Invalid container release by application \" + appAttemptId,\n             e);\n         throw e;\n       }\n     }\n \n     // Split Update Resource Requests into increase and decrease.\n     // No Exceptions are thrown here. All update errors are aggregated\n     // and returned to the AM.\n     List\u003cUpdateContainerError\u003e updateErrors \u003d new ArrayList\u003c\u003e();\n     ContainerUpdates containerUpdateRequests \u003d\n         RMServerUtils.validateAndSplitUpdateResourceRequests(\n             getRmContext(), request, maximumCapacity, updateErrors);\n \n     // Send new requests to appAttempt.\n     Allocation allocation;\n     RMAppAttemptState state \u003d\n         app.getRMAppAttempt(appAttemptId).getAppAttemptState();\n     if (state.equals(RMAppAttemptState.FINAL_SAVING) ||\n         state.equals(RMAppAttemptState.FINISHING) ||\n         app.isAppFinalStateStored()) {\n       LOG.warn(appAttemptId + \" is in \" + state +\n           \" state, ignore container allocate request.\");\n       allocation \u003d EMPTY_ALLOCATION;\n     } else {\n       try {\n         allocation \u003d getScheduler().allocate(appAttemptId, ask,\n             request.getSchedulingRequests(), release,\n             blacklistAdditions, blacklistRemovals, containerUpdateRequests);\n       } catch (SchedulerInvalidResoureRequestException e) {\n         LOG.warn(\"Exceptions caught when scheduler handling requests\");\n         throw new YarnException(e);\n       }\n     }\n \n     if (!blacklistAdditions.isEmpty() || !blacklistRemovals.isEmpty()) {\n       LOG.info(\"blacklist are updated in Scheduler.\" +\n           \"blacklistAdditions: \" + blacklistAdditions + \", \" +\n           \"blacklistRemovals: \" + blacklistRemovals);\n     }\n     RMAppAttempt appAttempt \u003d app.getRMAppAttempt(appAttemptId);\n \n     if (allocation.getNMTokens() !\u003d null \u0026\u0026\n         !allocation.getNMTokens().isEmpty()) {\n       response.setNMTokens(allocation.getNMTokens());\n     }\n \n     // Notify the AM of container update errors\n     ApplicationMasterServiceUtils.addToUpdateContainerErrors(\n         response, updateErrors);\n \n     // update the response with the deltas of node status changes\n     handleNodeUpdates(app, response);\n \n     ApplicationMasterServiceUtils.addToAllocatedContainers(\n         response, allocation.getContainers());\n \n     response.setCompletedContainersStatuses(appAttempt\n         .pullJustFinishedContainers());\n     response.setAvailableResources(allocation.getResourceLimit());\n \n     addToContainerUpdates(response, allocation,\n         ((AbstractYarnScheduler)getScheduler())\n             .getApplicationAttempt(appAttemptId).pullUpdateContainerErrors());\n \n     response.setNumClusterNodes(getScheduler().getNumClusterNodes());\n \n     // add collector address for this application\n-    if (YarnConfiguration.timelineServiceV2Enabled(\n-        getRmContext().getYarnConfiguration())) {\n+    if (timelineServiceV2Enabled) {\n       CollectorInfo collectorInfo \u003d app.getCollectorInfo();\n       if (collectorInfo !\u003d null) {\n         response.setCollectorInfo(collectorInfo);\n       }\n     }\n \n     // add preemption to the allocateResponse message (if any)\n     response.setPreemptionMessage(generatePreemptionMessage(allocation));\n \n     // Set application priority\n     response.setApplicationPriority(app\n         .getApplicationPriority());\n \n     response.setContainersFromPreviousAttempts(\n         allocation.getPreviousAttemptContainers());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void allocate(ApplicationAttemptId appAttemptId,\n      AllocateRequest request, AllocateResponse response) throws YarnException {\n\n    handleProgress(appAttemptId, request);\n\n    List\u003cResourceRequest\u003e ask \u003d request.getAskList();\n    List\u003cContainerId\u003e release \u003d request.getReleaseList();\n\n    ResourceBlacklistRequest blacklistRequest \u003d\n        request.getResourceBlacklistRequest();\n    List\u003cString\u003e blacklistAdditions \u003d\n        (blacklistRequest !\u003d null) ?\n            blacklistRequest.getBlacklistAdditions() : Collections.emptyList();\n    List\u003cString\u003e blacklistRemovals \u003d\n        (blacklistRequest !\u003d null) ?\n            blacklistRequest.getBlacklistRemovals() : Collections.emptyList();\n    RMApp app \u003d\n        getRmContext().getRMApps().get(appAttemptId.getApplicationId());\n\n    // set label expression for Resource Requests if resourceName\u003dANY\n    ApplicationSubmissionContext asc \u003d app.getApplicationSubmissionContext();\n    for (ResourceRequest req : ask) {\n      if (null \u003d\u003d req.getNodeLabelExpression()\n          \u0026\u0026 ResourceRequest.ANY.equals(req.getResourceName())) {\n        req.setNodeLabelExpression(asc.getNodeLabelExpression());\n      }\n    }\n\n    Resource maximumCapacity \u003d\n        getScheduler().getMaximumResourceCapability(app.getQueue());\n\n    // sanity check\n    try {\n      RMServerUtils.normalizeAndValidateRequests(ask,\n          maximumCapacity, app.getQueue(),\n          getScheduler(), getRmContext());\n    } catch (InvalidResourceRequestException e) {\n      RMAppAttempt rmAppAttempt \u003d app.getRMAppAttempt(appAttemptId);\n      handleInvalidResourceException(e, rmAppAttempt);\n    }\n\n    try {\n      RMServerUtils.validateBlacklistRequest(blacklistRequest);\n    }  catch (InvalidResourceBlacklistRequestException e) {\n      LOG.warn(\"Invalid blacklist request by application \" + appAttemptId, e);\n      throw e;\n    }\n\n    // In the case of work-preserving AM restart, it\u0027s possible for the\n    // AM to release containers from the earlier attempt.\n    if (!app.getApplicationSubmissionContext()\n        .getKeepContainersAcrossApplicationAttempts()) {\n      try {\n        RMServerUtils.validateContainerReleaseRequest(release, appAttemptId);\n      } catch (InvalidContainerReleaseException e) {\n        LOG.warn(\"Invalid container release by application \" + appAttemptId,\n            e);\n        throw e;\n      }\n    }\n\n    // Split Update Resource Requests into increase and decrease.\n    // No Exceptions are thrown here. All update errors are aggregated\n    // and returned to the AM.\n    List\u003cUpdateContainerError\u003e updateErrors \u003d new ArrayList\u003c\u003e();\n    ContainerUpdates containerUpdateRequests \u003d\n        RMServerUtils.validateAndSplitUpdateResourceRequests(\n            getRmContext(), request, maximumCapacity, updateErrors);\n\n    // Send new requests to appAttempt.\n    Allocation allocation;\n    RMAppAttemptState state \u003d\n        app.getRMAppAttempt(appAttemptId).getAppAttemptState();\n    if (state.equals(RMAppAttemptState.FINAL_SAVING) ||\n        state.equals(RMAppAttemptState.FINISHING) ||\n        app.isAppFinalStateStored()) {\n      LOG.warn(appAttemptId + \" is in \" + state +\n          \" state, ignore container allocate request.\");\n      allocation \u003d EMPTY_ALLOCATION;\n    } else {\n      try {\n        allocation \u003d getScheduler().allocate(appAttemptId, ask,\n            request.getSchedulingRequests(), release,\n            blacklistAdditions, blacklistRemovals, containerUpdateRequests);\n      } catch (SchedulerInvalidResoureRequestException e) {\n        LOG.warn(\"Exceptions caught when scheduler handling requests\");\n        throw new YarnException(e);\n      }\n    }\n\n    if (!blacklistAdditions.isEmpty() || !blacklistRemovals.isEmpty()) {\n      LOG.info(\"blacklist are updated in Scheduler.\" +\n          \"blacklistAdditions: \" + blacklistAdditions + \", \" +\n          \"blacklistRemovals: \" + blacklistRemovals);\n    }\n    RMAppAttempt appAttempt \u003d app.getRMAppAttempt(appAttemptId);\n\n    if (allocation.getNMTokens() !\u003d null \u0026\u0026\n        !allocation.getNMTokens().isEmpty()) {\n      response.setNMTokens(allocation.getNMTokens());\n    }\n\n    // Notify the AM of container update errors\n    ApplicationMasterServiceUtils.addToUpdateContainerErrors(\n        response, updateErrors);\n\n    // update the response with the deltas of node status changes\n    handleNodeUpdates(app, response);\n\n    ApplicationMasterServiceUtils.addToAllocatedContainers(\n        response, allocation.getContainers());\n\n    response.setCompletedContainersStatuses(appAttempt\n        .pullJustFinishedContainers());\n    response.setAvailableResources(allocation.getResourceLimit());\n\n    addToContainerUpdates(response, allocation,\n        ((AbstractYarnScheduler)getScheduler())\n            .getApplicationAttempt(appAttemptId).pullUpdateContainerErrors());\n\n    response.setNumClusterNodes(getScheduler().getNumClusterNodes());\n\n    // add collector address for this application\n    if (timelineServiceV2Enabled) {\n      CollectorInfo collectorInfo \u003d app.getCollectorInfo();\n      if (collectorInfo !\u003d null) {\n        response.setCollectorInfo(collectorInfo);\n      }\n    }\n\n    // add preemption to the allocateResponse message (if any)\n    response.setPreemptionMessage(generatePreemptionMessage(allocation));\n\n    // Set application priority\n    response.setApplicationPriority(app\n        .getApplicationPriority());\n\n    response.setContainersFromPreviousAttempts(\n        allocation.getPreviousAttemptContainers());\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/DefaultAMSProcessor.java",
      "extendedDetails": {}
    },
    "f1a893fdbc2dbe949cae786f08bdb2651b88d673": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8720. CapacityScheduler does not enforce max resource allocation check at queue level. Contributed by Tarun Parimi.\n",
      "commitDate": "14/09/18 1:33 AM",
      "commitName": "f1a893fdbc2dbe949cae786f08bdb2651b88d673",
      "commitAuthor": "Weiwei Yang",
      "commitDateOld": "30/07/18 5:44 PM",
      "commitNameOld": "3e06a5dcea8224ba71aec284df23b47d536bb06d",
      "commitAuthorOld": "Jonathan Hung",
      "daysBetweenCommits": 45.33,
      "commitsBetweenForRepo": 393,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,140 +1,141 @@\n   public void allocate(ApplicationAttemptId appAttemptId,\n       AllocateRequest request, AllocateResponse response) throws YarnException {\n \n     handleProgress(appAttemptId, request);\n \n     List\u003cResourceRequest\u003e ask \u003d request.getAskList();\n     List\u003cContainerId\u003e release \u003d request.getReleaseList();\n \n     ResourceBlacklistRequest blacklistRequest \u003d\n         request.getResourceBlacklistRequest();\n     List\u003cString\u003e blacklistAdditions \u003d\n         (blacklistRequest !\u003d null) ?\n             blacklistRequest.getBlacklistAdditions() : Collections.emptyList();\n     List\u003cString\u003e blacklistRemovals \u003d\n         (blacklistRequest !\u003d null) ?\n             blacklistRequest.getBlacklistRemovals() : Collections.emptyList();\n     RMApp app \u003d\n         getRmContext().getRMApps().get(appAttemptId.getApplicationId());\n \n     // set label expression for Resource Requests if resourceName\u003dANY\n     ApplicationSubmissionContext asc \u003d app.getApplicationSubmissionContext();\n     for (ResourceRequest req : ask) {\n       if (null \u003d\u003d req.getNodeLabelExpression()\n           \u0026\u0026 ResourceRequest.ANY.equals(req.getResourceName())) {\n         req.setNodeLabelExpression(asc.getNodeLabelExpression());\n       }\n     }\n \n-    Resource maximumCapacity \u003d getScheduler().getMaximumResourceCapability();\n+    Resource maximumCapacity \u003d\n+        getScheduler().getMaximumResourceCapability(app.getQueue());\n \n     // sanity check\n     try {\n       RMServerUtils.normalizeAndValidateRequests(ask,\n           maximumCapacity, app.getQueue(),\n           getScheduler(), getRmContext());\n     } catch (InvalidResourceRequestException e) {\n       RMAppAttempt rmAppAttempt \u003d app.getRMAppAttempt(appAttemptId);\n       handleInvalidResourceException(e, rmAppAttempt);\n     }\n \n     try {\n       RMServerUtils.validateBlacklistRequest(blacklistRequest);\n     }  catch (InvalidResourceBlacklistRequestException e) {\n       LOG.warn(\"Invalid blacklist request by application \" + appAttemptId, e);\n       throw e;\n     }\n \n     // In the case of work-preserving AM restart, it\u0027s possible for the\n     // AM to release containers from the earlier attempt.\n     if (!app.getApplicationSubmissionContext()\n         .getKeepContainersAcrossApplicationAttempts()) {\n       try {\n         RMServerUtils.validateContainerReleaseRequest(release, appAttemptId);\n       } catch (InvalidContainerReleaseException e) {\n         LOG.warn(\"Invalid container release by application \" + appAttemptId,\n             e);\n         throw e;\n       }\n     }\n \n     // Split Update Resource Requests into increase and decrease.\n     // No Exceptions are thrown here. All update errors are aggregated\n     // and returned to the AM.\n     List\u003cUpdateContainerError\u003e updateErrors \u003d new ArrayList\u003c\u003e();\n     ContainerUpdates containerUpdateRequests \u003d\n         RMServerUtils.validateAndSplitUpdateResourceRequests(\n             getRmContext(), request, maximumCapacity, updateErrors);\n \n     // Send new requests to appAttempt.\n     Allocation allocation;\n     RMAppAttemptState state \u003d\n         app.getRMAppAttempt(appAttemptId).getAppAttemptState();\n     if (state.equals(RMAppAttemptState.FINAL_SAVING) ||\n         state.equals(RMAppAttemptState.FINISHING) ||\n         app.isAppFinalStateStored()) {\n       LOG.warn(appAttemptId + \" is in \" + state +\n           \" state, ignore container allocate request.\");\n       allocation \u003d EMPTY_ALLOCATION;\n     } else {\n       try {\n         allocation \u003d getScheduler().allocate(appAttemptId, ask,\n             request.getSchedulingRequests(), release,\n             blacklistAdditions, blacklistRemovals, containerUpdateRequests);\n       } catch (SchedulerInvalidResoureRequestException e) {\n         LOG.warn(\"Exceptions caught when scheduler handling requests\");\n         throw new YarnException(e);\n       }\n     }\n \n     if (!blacklistAdditions.isEmpty() || !blacklistRemovals.isEmpty()) {\n       LOG.info(\"blacklist are updated in Scheduler.\" +\n           \"blacklistAdditions: \" + blacklistAdditions + \", \" +\n           \"blacklistRemovals: \" + blacklistRemovals);\n     }\n     RMAppAttempt appAttempt \u003d app.getRMAppAttempt(appAttemptId);\n \n     if (allocation.getNMTokens() !\u003d null \u0026\u0026\n         !allocation.getNMTokens().isEmpty()) {\n       response.setNMTokens(allocation.getNMTokens());\n     }\n \n     // Notify the AM of container update errors\n     ApplicationMasterServiceUtils.addToUpdateContainerErrors(\n         response, updateErrors);\n \n     // update the response with the deltas of node status changes\n     handleNodeUpdates(app, response);\n \n     ApplicationMasterServiceUtils.addToAllocatedContainers(\n         response, allocation.getContainers());\n \n     response.setCompletedContainersStatuses(appAttempt\n         .pullJustFinishedContainers());\n     response.setAvailableResources(allocation.getResourceLimit());\n \n     addToContainerUpdates(response, allocation,\n         ((AbstractYarnScheduler)getScheduler())\n             .getApplicationAttempt(appAttemptId).pullUpdateContainerErrors());\n \n     response.setNumClusterNodes(getScheduler().getNumClusterNodes());\n \n     // add collector address for this application\n     if (YarnConfiguration.timelineServiceV2Enabled(\n         getRmContext().getYarnConfiguration())) {\n       CollectorInfo collectorInfo \u003d app.getCollectorInfo();\n       if (collectorInfo !\u003d null) {\n         response.setCollectorInfo(collectorInfo);\n       }\n     }\n \n     // add preemption to the allocateResponse message (if any)\n     response.setPreemptionMessage(generatePreemptionMessage(allocation));\n \n     // Set application priority\n     response.setApplicationPriority(app\n         .getApplicationPriority());\n \n     response.setContainersFromPreviousAttempts(\n         allocation.getPreviousAttemptContainers());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void allocate(ApplicationAttemptId appAttemptId,\n      AllocateRequest request, AllocateResponse response) throws YarnException {\n\n    handleProgress(appAttemptId, request);\n\n    List\u003cResourceRequest\u003e ask \u003d request.getAskList();\n    List\u003cContainerId\u003e release \u003d request.getReleaseList();\n\n    ResourceBlacklistRequest blacklistRequest \u003d\n        request.getResourceBlacklistRequest();\n    List\u003cString\u003e blacklistAdditions \u003d\n        (blacklistRequest !\u003d null) ?\n            blacklistRequest.getBlacklistAdditions() : Collections.emptyList();\n    List\u003cString\u003e blacklistRemovals \u003d\n        (blacklistRequest !\u003d null) ?\n            blacklistRequest.getBlacklistRemovals() : Collections.emptyList();\n    RMApp app \u003d\n        getRmContext().getRMApps().get(appAttemptId.getApplicationId());\n\n    // set label expression for Resource Requests if resourceName\u003dANY\n    ApplicationSubmissionContext asc \u003d app.getApplicationSubmissionContext();\n    for (ResourceRequest req : ask) {\n      if (null \u003d\u003d req.getNodeLabelExpression()\n          \u0026\u0026 ResourceRequest.ANY.equals(req.getResourceName())) {\n        req.setNodeLabelExpression(asc.getNodeLabelExpression());\n      }\n    }\n\n    Resource maximumCapacity \u003d\n        getScheduler().getMaximumResourceCapability(app.getQueue());\n\n    // sanity check\n    try {\n      RMServerUtils.normalizeAndValidateRequests(ask,\n          maximumCapacity, app.getQueue(),\n          getScheduler(), getRmContext());\n    } catch (InvalidResourceRequestException e) {\n      RMAppAttempt rmAppAttempt \u003d app.getRMAppAttempt(appAttemptId);\n      handleInvalidResourceException(e, rmAppAttempt);\n    }\n\n    try {\n      RMServerUtils.validateBlacklistRequest(blacklistRequest);\n    }  catch (InvalidResourceBlacklistRequestException e) {\n      LOG.warn(\"Invalid blacklist request by application \" + appAttemptId, e);\n      throw e;\n    }\n\n    // In the case of work-preserving AM restart, it\u0027s possible for the\n    // AM to release containers from the earlier attempt.\n    if (!app.getApplicationSubmissionContext()\n        .getKeepContainersAcrossApplicationAttempts()) {\n      try {\n        RMServerUtils.validateContainerReleaseRequest(release, appAttemptId);\n      } catch (InvalidContainerReleaseException e) {\n        LOG.warn(\"Invalid container release by application \" + appAttemptId,\n            e);\n        throw e;\n      }\n    }\n\n    // Split Update Resource Requests into increase and decrease.\n    // No Exceptions are thrown here. All update errors are aggregated\n    // and returned to the AM.\n    List\u003cUpdateContainerError\u003e updateErrors \u003d new ArrayList\u003c\u003e();\n    ContainerUpdates containerUpdateRequests \u003d\n        RMServerUtils.validateAndSplitUpdateResourceRequests(\n            getRmContext(), request, maximumCapacity, updateErrors);\n\n    // Send new requests to appAttempt.\n    Allocation allocation;\n    RMAppAttemptState state \u003d\n        app.getRMAppAttempt(appAttemptId).getAppAttemptState();\n    if (state.equals(RMAppAttemptState.FINAL_SAVING) ||\n        state.equals(RMAppAttemptState.FINISHING) ||\n        app.isAppFinalStateStored()) {\n      LOG.warn(appAttemptId + \" is in \" + state +\n          \" state, ignore container allocate request.\");\n      allocation \u003d EMPTY_ALLOCATION;\n    } else {\n      try {\n        allocation \u003d getScheduler().allocate(appAttemptId, ask,\n            request.getSchedulingRequests(), release,\n            blacklistAdditions, blacklistRemovals, containerUpdateRequests);\n      } catch (SchedulerInvalidResoureRequestException e) {\n        LOG.warn(\"Exceptions caught when scheduler handling requests\");\n        throw new YarnException(e);\n      }\n    }\n\n    if (!blacklistAdditions.isEmpty() || !blacklistRemovals.isEmpty()) {\n      LOG.info(\"blacklist are updated in Scheduler.\" +\n          \"blacklistAdditions: \" + blacklistAdditions + \", \" +\n          \"blacklistRemovals: \" + blacklistRemovals);\n    }\n    RMAppAttempt appAttempt \u003d app.getRMAppAttempt(appAttemptId);\n\n    if (allocation.getNMTokens() !\u003d null \u0026\u0026\n        !allocation.getNMTokens().isEmpty()) {\n      response.setNMTokens(allocation.getNMTokens());\n    }\n\n    // Notify the AM of container update errors\n    ApplicationMasterServiceUtils.addToUpdateContainerErrors(\n        response, updateErrors);\n\n    // update the response with the deltas of node status changes\n    handleNodeUpdates(app, response);\n\n    ApplicationMasterServiceUtils.addToAllocatedContainers(\n        response, allocation.getContainers());\n\n    response.setCompletedContainersStatuses(appAttempt\n        .pullJustFinishedContainers());\n    response.setAvailableResources(allocation.getResourceLimit());\n\n    addToContainerUpdates(response, allocation,\n        ((AbstractYarnScheduler)getScheduler())\n            .getApplicationAttempt(appAttemptId).pullUpdateContainerErrors());\n\n    response.setNumClusterNodes(getScheduler().getNumClusterNodes());\n\n    // add collector address for this application\n    if (YarnConfiguration.timelineServiceV2Enabled(\n        getRmContext().getYarnConfiguration())) {\n      CollectorInfo collectorInfo \u003d app.getCollectorInfo();\n      if (collectorInfo !\u003d null) {\n        response.setCollectorInfo(collectorInfo);\n      }\n    }\n\n    // add preemption to the allocateResponse message (if any)\n    response.setPreemptionMessage(generatePreemptionMessage(allocation));\n\n    // Set application priority\n    response.setApplicationPriority(app\n        .getApplicationPriority());\n\n    response.setContainersFromPreviousAttempts(\n        allocation.getPreviousAttemptContainers());\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/DefaultAMSProcessor.java",
      "extendedDetails": {}
    },
    "2cccf4061cc4021c48e29879700dbc94f832b7d1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8517. getContainer and getContainers ResourceManager REST API methods are not documented (snemeth via rkanter)\n",
      "commitDate": "27/07/18 2:35 PM",
      "commitName": "2cccf4061cc4021c48e29879700dbc94f832b7d1",
      "commitAuthor": "Robert Kanter",
      "commitDateOld": "18/02/18 5:19 AM",
      "commitNameOld": "4d4dde5112e9ee6b37cbdea17104c5a4c6870bd5",
      "commitAuthorOld": "fang zhenyi",
      "daysBetweenCommits": 159.34,
      "commitsBetweenForRepo": 1740,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,140 +1,140 @@\n   public void allocate(ApplicationAttemptId appAttemptId,\n       AllocateRequest request, AllocateResponse response) throws YarnException {\n \n     handleProgress(appAttemptId, request);\n \n     List\u003cResourceRequest\u003e ask \u003d request.getAskList();\n     List\u003cContainerId\u003e release \u003d request.getReleaseList();\n \n     ResourceBlacklistRequest blacklistRequest \u003d\n         request.getResourceBlacklistRequest();\n     List\u003cString\u003e blacklistAdditions \u003d\n         (blacklistRequest !\u003d null) ?\n             blacklistRequest.getBlacklistAdditions() : Collections.emptyList();\n     List\u003cString\u003e blacklistRemovals \u003d\n         (blacklistRequest !\u003d null) ?\n             blacklistRequest.getBlacklistRemovals() : Collections.emptyList();\n     RMApp app \u003d\n         getRmContext().getRMApps().get(appAttemptId.getApplicationId());\n \n     // set label expression for Resource Requests if resourceName\u003dANY\n     ApplicationSubmissionContext asc \u003d app.getApplicationSubmissionContext();\n     for (ResourceRequest req : ask) {\n       if (null \u003d\u003d req.getNodeLabelExpression()\n           \u0026\u0026 ResourceRequest.ANY.equals(req.getResourceName())) {\n         req.setNodeLabelExpression(asc.getNodeLabelExpression());\n       }\n     }\n \n     Resource maximumCapacity \u003d getScheduler().getMaximumResourceCapability();\n \n     // sanity check\n     try {\n       RMServerUtils.normalizeAndValidateRequests(ask,\n           maximumCapacity, app.getQueue(),\n           getScheduler(), getRmContext());\n     } catch (InvalidResourceRequestException e) {\n-      LOG.warn(\"Invalid resource ask by application \" + appAttemptId, e);\n-      throw e;\n+      RMAppAttempt rmAppAttempt \u003d app.getRMAppAttempt(appAttemptId);\n+      handleInvalidResourceException(e, rmAppAttempt);\n     }\n \n     try {\n       RMServerUtils.validateBlacklistRequest(blacklistRequest);\n     }  catch (InvalidResourceBlacklistRequestException e) {\n       LOG.warn(\"Invalid blacklist request by application \" + appAttemptId, e);\n       throw e;\n     }\n \n     // In the case of work-preserving AM restart, it\u0027s possible for the\n     // AM to release containers from the earlier attempt.\n     if (!app.getApplicationSubmissionContext()\n         .getKeepContainersAcrossApplicationAttempts()) {\n       try {\n         RMServerUtils.validateContainerReleaseRequest(release, appAttemptId);\n       } catch (InvalidContainerReleaseException e) {\n         LOG.warn(\"Invalid container release by application \" + appAttemptId,\n             e);\n         throw e;\n       }\n     }\n \n     // Split Update Resource Requests into increase and decrease.\n     // No Exceptions are thrown here. All update errors are aggregated\n     // and returned to the AM.\n     List\u003cUpdateContainerError\u003e updateErrors \u003d new ArrayList\u003c\u003e();\n     ContainerUpdates containerUpdateRequests \u003d\n         RMServerUtils.validateAndSplitUpdateResourceRequests(\n             getRmContext(), request, maximumCapacity, updateErrors);\n \n     // Send new requests to appAttempt.\n     Allocation allocation;\n     RMAppAttemptState state \u003d\n         app.getRMAppAttempt(appAttemptId).getAppAttemptState();\n     if (state.equals(RMAppAttemptState.FINAL_SAVING) ||\n         state.equals(RMAppAttemptState.FINISHING) ||\n         app.isAppFinalStateStored()) {\n       LOG.warn(appAttemptId + \" is in \" + state +\n           \" state, ignore container allocate request.\");\n       allocation \u003d EMPTY_ALLOCATION;\n     } else {\n       try {\n         allocation \u003d getScheduler().allocate(appAttemptId, ask,\n             request.getSchedulingRequests(), release,\n             blacklistAdditions, blacklistRemovals, containerUpdateRequests);\n       } catch (SchedulerInvalidResoureRequestException e) {\n         LOG.warn(\"Exceptions caught when scheduler handling requests\");\n         throw new YarnException(e);\n       }\n     }\n \n     if (!blacklistAdditions.isEmpty() || !blacklistRemovals.isEmpty()) {\n       LOG.info(\"blacklist are updated in Scheduler.\" +\n           \"blacklistAdditions: \" + blacklistAdditions + \", \" +\n           \"blacklistRemovals: \" + blacklistRemovals);\n     }\n     RMAppAttempt appAttempt \u003d app.getRMAppAttempt(appAttemptId);\n \n     if (allocation.getNMTokens() !\u003d null \u0026\u0026\n         !allocation.getNMTokens().isEmpty()) {\n       response.setNMTokens(allocation.getNMTokens());\n     }\n \n     // Notify the AM of container update errors\n     ApplicationMasterServiceUtils.addToUpdateContainerErrors(\n         response, updateErrors);\n \n     // update the response with the deltas of node status changes\n     handleNodeUpdates(app, response);\n \n     ApplicationMasterServiceUtils.addToAllocatedContainers(\n         response, allocation.getContainers());\n \n     response.setCompletedContainersStatuses(appAttempt\n         .pullJustFinishedContainers());\n     response.setAvailableResources(allocation.getResourceLimit());\n \n     addToContainerUpdates(response, allocation,\n         ((AbstractYarnScheduler)getScheduler())\n             .getApplicationAttempt(appAttemptId).pullUpdateContainerErrors());\n \n     response.setNumClusterNodes(getScheduler().getNumClusterNodes());\n \n     // add collector address for this application\n     if (YarnConfiguration.timelineServiceV2Enabled(\n         getRmContext().getYarnConfiguration())) {\n       CollectorInfo collectorInfo \u003d app.getCollectorInfo();\n       if (collectorInfo !\u003d null) {\n         response.setCollectorInfo(collectorInfo);\n       }\n     }\n \n     // add preemption to the allocateResponse message (if any)\n     response.setPreemptionMessage(generatePreemptionMessage(allocation));\n \n     // Set application priority\n     response.setApplicationPriority(app\n         .getApplicationPriority());\n \n     response.setContainersFromPreviousAttempts(\n         allocation.getPreviousAttemptContainers());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void allocate(ApplicationAttemptId appAttemptId,\n      AllocateRequest request, AllocateResponse response) throws YarnException {\n\n    handleProgress(appAttemptId, request);\n\n    List\u003cResourceRequest\u003e ask \u003d request.getAskList();\n    List\u003cContainerId\u003e release \u003d request.getReleaseList();\n\n    ResourceBlacklistRequest blacklistRequest \u003d\n        request.getResourceBlacklistRequest();\n    List\u003cString\u003e blacklistAdditions \u003d\n        (blacklistRequest !\u003d null) ?\n            blacklistRequest.getBlacklistAdditions() : Collections.emptyList();\n    List\u003cString\u003e blacklistRemovals \u003d\n        (blacklistRequest !\u003d null) ?\n            blacklistRequest.getBlacklistRemovals() : Collections.emptyList();\n    RMApp app \u003d\n        getRmContext().getRMApps().get(appAttemptId.getApplicationId());\n\n    // set label expression for Resource Requests if resourceName\u003dANY\n    ApplicationSubmissionContext asc \u003d app.getApplicationSubmissionContext();\n    for (ResourceRequest req : ask) {\n      if (null \u003d\u003d req.getNodeLabelExpression()\n          \u0026\u0026 ResourceRequest.ANY.equals(req.getResourceName())) {\n        req.setNodeLabelExpression(asc.getNodeLabelExpression());\n      }\n    }\n\n    Resource maximumCapacity \u003d getScheduler().getMaximumResourceCapability();\n\n    // sanity check\n    try {\n      RMServerUtils.normalizeAndValidateRequests(ask,\n          maximumCapacity, app.getQueue(),\n          getScheduler(), getRmContext());\n    } catch (InvalidResourceRequestException e) {\n      RMAppAttempt rmAppAttempt \u003d app.getRMAppAttempt(appAttemptId);\n      handleInvalidResourceException(e, rmAppAttempt);\n    }\n\n    try {\n      RMServerUtils.validateBlacklistRequest(blacklistRequest);\n    }  catch (InvalidResourceBlacklistRequestException e) {\n      LOG.warn(\"Invalid blacklist request by application \" + appAttemptId, e);\n      throw e;\n    }\n\n    // In the case of work-preserving AM restart, it\u0027s possible for the\n    // AM to release containers from the earlier attempt.\n    if (!app.getApplicationSubmissionContext()\n        .getKeepContainersAcrossApplicationAttempts()) {\n      try {\n        RMServerUtils.validateContainerReleaseRequest(release, appAttemptId);\n      } catch (InvalidContainerReleaseException e) {\n        LOG.warn(\"Invalid container release by application \" + appAttemptId,\n            e);\n        throw e;\n      }\n    }\n\n    // Split Update Resource Requests into increase and decrease.\n    // No Exceptions are thrown here. All update errors are aggregated\n    // and returned to the AM.\n    List\u003cUpdateContainerError\u003e updateErrors \u003d new ArrayList\u003c\u003e();\n    ContainerUpdates containerUpdateRequests \u003d\n        RMServerUtils.validateAndSplitUpdateResourceRequests(\n            getRmContext(), request, maximumCapacity, updateErrors);\n\n    // Send new requests to appAttempt.\n    Allocation allocation;\n    RMAppAttemptState state \u003d\n        app.getRMAppAttempt(appAttemptId).getAppAttemptState();\n    if (state.equals(RMAppAttemptState.FINAL_SAVING) ||\n        state.equals(RMAppAttemptState.FINISHING) ||\n        app.isAppFinalStateStored()) {\n      LOG.warn(appAttemptId + \" is in \" + state +\n          \" state, ignore container allocate request.\");\n      allocation \u003d EMPTY_ALLOCATION;\n    } else {\n      try {\n        allocation \u003d getScheduler().allocate(appAttemptId, ask,\n            request.getSchedulingRequests(), release,\n            blacklistAdditions, blacklistRemovals, containerUpdateRequests);\n      } catch (SchedulerInvalidResoureRequestException e) {\n        LOG.warn(\"Exceptions caught when scheduler handling requests\");\n        throw new YarnException(e);\n      }\n    }\n\n    if (!blacklistAdditions.isEmpty() || !blacklistRemovals.isEmpty()) {\n      LOG.info(\"blacklist are updated in Scheduler.\" +\n          \"blacklistAdditions: \" + blacklistAdditions + \", \" +\n          \"blacklistRemovals: \" + blacklistRemovals);\n    }\n    RMAppAttempt appAttempt \u003d app.getRMAppAttempt(appAttemptId);\n\n    if (allocation.getNMTokens() !\u003d null \u0026\u0026\n        !allocation.getNMTokens().isEmpty()) {\n      response.setNMTokens(allocation.getNMTokens());\n    }\n\n    // Notify the AM of container update errors\n    ApplicationMasterServiceUtils.addToUpdateContainerErrors(\n        response, updateErrors);\n\n    // update the response with the deltas of node status changes\n    handleNodeUpdates(app, response);\n\n    ApplicationMasterServiceUtils.addToAllocatedContainers(\n        response, allocation.getContainers());\n\n    response.setCompletedContainersStatuses(appAttempt\n        .pullJustFinishedContainers());\n    response.setAvailableResources(allocation.getResourceLimit());\n\n    addToContainerUpdates(response, allocation,\n        ((AbstractYarnScheduler)getScheduler())\n            .getApplicationAttempt(appAttemptId).pullUpdateContainerErrors());\n\n    response.setNumClusterNodes(getScheduler().getNumClusterNodes());\n\n    // add collector address for this application\n    if (YarnConfiguration.timelineServiceV2Enabled(\n        getRmContext().getYarnConfiguration())) {\n      CollectorInfo collectorInfo \u003d app.getCollectorInfo();\n      if (collectorInfo !\u003d null) {\n        response.setCollectorInfo(collectorInfo);\n      }\n    }\n\n    // add preemption to the allocateResponse message (if any)\n    response.setPreemptionMessage(generatePreemptionMessage(allocation));\n\n    // Set application priority\n    response.setApplicationPriority(app\n        .getApplicationPriority());\n\n    response.setContainersFromPreviousAttempts(\n        allocation.getPreviousAttemptContainers());\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/DefaultAMSProcessor.java",
      "extendedDetails": {}
    },
    "4d4dde5112e9ee6b37cbdea17104c5a4c6870bd5": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15223. Replace Collections.EMPTY* with empty* when available\n\nSigned-off-by: Akira Ajisaka \u003caajisaka@apache.org\u003e\n",
      "commitDate": "18/02/18 5:19 AM",
      "commitName": "4d4dde5112e9ee6b37cbdea17104c5a4c6870bd5",
      "commitAuthor": "fang zhenyi",
      "commitDateOld": "31/01/18 1:30 AM",
      "commitNameOld": "38af23796971193fa529c3d08ffde8fcd6e607b6",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 18.16,
      "commitsBetweenForRepo": 117,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,140 +1,140 @@\n   public void allocate(ApplicationAttemptId appAttemptId,\n       AllocateRequest request, AllocateResponse response) throws YarnException {\n \n     handleProgress(appAttemptId, request);\n \n     List\u003cResourceRequest\u003e ask \u003d request.getAskList();\n     List\u003cContainerId\u003e release \u003d request.getReleaseList();\n \n     ResourceBlacklistRequest blacklistRequest \u003d\n         request.getResourceBlacklistRequest();\n     List\u003cString\u003e blacklistAdditions \u003d\n         (blacklistRequest !\u003d null) ?\n-            blacklistRequest.getBlacklistAdditions() : Collections.EMPTY_LIST;\n+            blacklistRequest.getBlacklistAdditions() : Collections.emptyList();\n     List\u003cString\u003e blacklistRemovals \u003d\n         (blacklistRequest !\u003d null) ?\n-            blacklistRequest.getBlacklistRemovals() : Collections.EMPTY_LIST;\n+            blacklistRequest.getBlacklistRemovals() : Collections.emptyList();\n     RMApp app \u003d\n         getRmContext().getRMApps().get(appAttemptId.getApplicationId());\n \n     // set label expression for Resource Requests if resourceName\u003dANY\n     ApplicationSubmissionContext asc \u003d app.getApplicationSubmissionContext();\n     for (ResourceRequest req : ask) {\n       if (null \u003d\u003d req.getNodeLabelExpression()\n           \u0026\u0026 ResourceRequest.ANY.equals(req.getResourceName())) {\n         req.setNodeLabelExpression(asc.getNodeLabelExpression());\n       }\n     }\n \n     Resource maximumCapacity \u003d getScheduler().getMaximumResourceCapability();\n \n     // sanity check\n     try {\n       RMServerUtils.normalizeAndValidateRequests(ask,\n           maximumCapacity, app.getQueue(),\n           getScheduler(), getRmContext());\n     } catch (InvalidResourceRequestException e) {\n       LOG.warn(\"Invalid resource ask by application \" + appAttemptId, e);\n       throw e;\n     }\n \n     try {\n       RMServerUtils.validateBlacklistRequest(blacklistRequest);\n     }  catch (InvalidResourceBlacklistRequestException e) {\n       LOG.warn(\"Invalid blacklist request by application \" + appAttemptId, e);\n       throw e;\n     }\n \n     // In the case of work-preserving AM restart, it\u0027s possible for the\n     // AM to release containers from the earlier attempt.\n     if (!app.getApplicationSubmissionContext()\n         .getKeepContainersAcrossApplicationAttempts()) {\n       try {\n         RMServerUtils.validateContainerReleaseRequest(release, appAttemptId);\n       } catch (InvalidContainerReleaseException e) {\n         LOG.warn(\"Invalid container release by application \" + appAttemptId,\n             e);\n         throw e;\n       }\n     }\n \n     // Split Update Resource Requests into increase and decrease.\n     // No Exceptions are thrown here. All update errors are aggregated\n     // and returned to the AM.\n     List\u003cUpdateContainerError\u003e updateErrors \u003d new ArrayList\u003c\u003e();\n     ContainerUpdates containerUpdateRequests \u003d\n         RMServerUtils.validateAndSplitUpdateResourceRequests(\n             getRmContext(), request, maximumCapacity, updateErrors);\n \n     // Send new requests to appAttempt.\n     Allocation allocation;\n     RMAppAttemptState state \u003d\n         app.getRMAppAttempt(appAttemptId).getAppAttemptState();\n     if (state.equals(RMAppAttemptState.FINAL_SAVING) ||\n         state.equals(RMAppAttemptState.FINISHING) ||\n         app.isAppFinalStateStored()) {\n       LOG.warn(appAttemptId + \" is in \" + state +\n           \" state, ignore container allocate request.\");\n       allocation \u003d EMPTY_ALLOCATION;\n     } else {\n       try {\n         allocation \u003d getScheduler().allocate(appAttemptId, ask,\n             request.getSchedulingRequests(), release,\n             blacklistAdditions, blacklistRemovals, containerUpdateRequests);\n       } catch (SchedulerInvalidResoureRequestException e) {\n         LOG.warn(\"Exceptions caught when scheduler handling requests\");\n         throw new YarnException(e);\n       }\n     }\n \n     if (!blacklistAdditions.isEmpty() || !blacklistRemovals.isEmpty()) {\n       LOG.info(\"blacklist are updated in Scheduler.\" +\n           \"blacklistAdditions: \" + blacklistAdditions + \", \" +\n           \"blacklistRemovals: \" + blacklistRemovals);\n     }\n     RMAppAttempt appAttempt \u003d app.getRMAppAttempt(appAttemptId);\n \n     if (allocation.getNMTokens() !\u003d null \u0026\u0026\n         !allocation.getNMTokens().isEmpty()) {\n       response.setNMTokens(allocation.getNMTokens());\n     }\n \n     // Notify the AM of container update errors\n     ApplicationMasterServiceUtils.addToUpdateContainerErrors(\n         response, updateErrors);\n \n     // update the response with the deltas of node status changes\n     handleNodeUpdates(app, response);\n \n     ApplicationMasterServiceUtils.addToAllocatedContainers(\n         response, allocation.getContainers());\n \n     response.setCompletedContainersStatuses(appAttempt\n         .pullJustFinishedContainers());\n     response.setAvailableResources(allocation.getResourceLimit());\n \n     addToContainerUpdates(response, allocation,\n         ((AbstractYarnScheduler)getScheduler())\n             .getApplicationAttempt(appAttemptId).pullUpdateContainerErrors());\n \n     response.setNumClusterNodes(getScheduler().getNumClusterNodes());\n \n     // add collector address for this application\n     if (YarnConfiguration.timelineServiceV2Enabled(\n         getRmContext().getYarnConfiguration())) {\n       CollectorInfo collectorInfo \u003d app.getCollectorInfo();\n       if (collectorInfo !\u003d null) {\n         response.setCollectorInfo(collectorInfo);\n       }\n     }\n \n     // add preemption to the allocateResponse message (if any)\n     response.setPreemptionMessage(generatePreemptionMessage(allocation));\n \n     // Set application priority\n     response.setApplicationPriority(app\n         .getApplicationPriority());\n \n     response.setContainersFromPreviousAttempts(\n         allocation.getPreviousAttemptContainers());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void allocate(ApplicationAttemptId appAttemptId,\n      AllocateRequest request, AllocateResponse response) throws YarnException {\n\n    handleProgress(appAttemptId, request);\n\n    List\u003cResourceRequest\u003e ask \u003d request.getAskList();\n    List\u003cContainerId\u003e release \u003d request.getReleaseList();\n\n    ResourceBlacklistRequest blacklistRequest \u003d\n        request.getResourceBlacklistRequest();\n    List\u003cString\u003e blacklistAdditions \u003d\n        (blacklistRequest !\u003d null) ?\n            blacklistRequest.getBlacklistAdditions() : Collections.emptyList();\n    List\u003cString\u003e blacklistRemovals \u003d\n        (blacklistRequest !\u003d null) ?\n            blacklistRequest.getBlacklistRemovals() : Collections.emptyList();\n    RMApp app \u003d\n        getRmContext().getRMApps().get(appAttemptId.getApplicationId());\n\n    // set label expression for Resource Requests if resourceName\u003dANY\n    ApplicationSubmissionContext asc \u003d app.getApplicationSubmissionContext();\n    for (ResourceRequest req : ask) {\n      if (null \u003d\u003d req.getNodeLabelExpression()\n          \u0026\u0026 ResourceRequest.ANY.equals(req.getResourceName())) {\n        req.setNodeLabelExpression(asc.getNodeLabelExpression());\n      }\n    }\n\n    Resource maximumCapacity \u003d getScheduler().getMaximumResourceCapability();\n\n    // sanity check\n    try {\n      RMServerUtils.normalizeAndValidateRequests(ask,\n          maximumCapacity, app.getQueue(),\n          getScheduler(), getRmContext());\n    } catch (InvalidResourceRequestException e) {\n      LOG.warn(\"Invalid resource ask by application \" + appAttemptId, e);\n      throw e;\n    }\n\n    try {\n      RMServerUtils.validateBlacklistRequest(blacklistRequest);\n    }  catch (InvalidResourceBlacklistRequestException e) {\n      LOG.warn(\"Invalid blacklist request by application \" + appAttemptId, e);\n      throw e;\n    }\n\n    // In the case of work-preserving AM restart, it\u0027s possible for the\n    // AM to release containers from the earlier attempt.\n    if (!app.getApplicationSubmissionContext()\n        .getKeepContainersAcrossApplicationAttempts()) {\n      try {\n        RMServerUtils.validateContainerReleaseRequest(release, appAttemptId);\n      } catch (InvalidContainerReleaseException e) {\n        LOG.warn(\"Invalid container release by application \" + appAttemptId,\n            e);\n        throw e;\n      }\n    }\n\n    // Split Update Resource Requests into increase and decrease.\n    // No Exceptions are thrown here. All update errors are aggregated\n    // and returned to the AM.\n    List\u003cUpdateContainerError\u003e updateErrors \u003d new ArrayList\u003c\u003e();\n    ContainerUpdates containerUpdateRequests \u003d\n        RMServerUtils.validateAndSplitUpdateResourceRequests(\n            getRmContext(), request, maximumCapacity, updateErrors);\n\n    // Send new requests to appAttempt.\n    Allocation allocation;\n    RMAppAttemptState state \u003d\n        app.getRMAppAttempt(appAttemptId).getAppAttemptState();\n    if (state.equals(RMAppAttemptState.FINAL_SAVING) ||\n        state.equals(RMAppAttemptState.FINISHING) ||\n        app.isAppFinalStateStored()) {\n      LOG.warn(appAttemptId + \" is in \" + state +\n          \" state, ignore container allocate request.\");\n      allocation \u003d EMPTY_ALLOCATION;\n    } else {\n      try {\n        allocation \u003d getScheduler().allocate(appAttemptId, ask,\n            request.getSchedulingRequests(), release,\n            blacklistAdditions, blacklistRemovals, containerUpdateRequests);\n      } catch (SchedulerInvalidResoureRequestException e) {\n        LOG.warn(\"Exceptions caught when scheduler handling requests\");\n        throw new YarnException(e);\n      }\n    }\n\n    if (!blacklistAdditions.isEmpty() || !blacklistRemovals.isEmpty()) {\n      LOG.info(\"blacklist are updated in Scheduler.\" +\n          \"blacklistAdditions: \" + blacklistAdditions + \", \" +\n          \"blacklistRemovals: \" + blacklistRemovals);\n    }\n    RMAppAttempt appAttempt \u003d app.getRMAppAttempt(appAttemptId);\n\n    if (allocation.getNMTokens() !\u003d null \u0026\u0026\n        !allocation.getNMTokens().isEmpty()) {\n      response.setNMTokens(allocation.getNMTokens());\n    }\n\n    // Notify the AM of container update errors\n    ApplicationMasterServiceUtils.addToUpdateContainerErrors(\n        response, updateErrors);\n\n    // update the response with the deltas of node status changes\n    handleNodeUpdates(app, response);\n\n    ApplicationMasterServiceUtils.addToAllocatedContainers(\n        response, allocation.getContainers());\n\n    response.setCompletedContainersStatuses(appAttempt\n        .pullJustFinishedContainers());\n    response.setAvailableResources(allocation.getResourceLimit());\n\n    addToContainerUpdates(response, allocation,\n        ((AbstractYarnScheduler)getScheduler())\n            .getApplicationAttempt(appAttemptId).pullUpdateContainerErrors());\n\n    response.setNumClusterNodes(getScheduler().getNumClusterNodes());\n\n    // add collector address for this application\n    if (YarnConfiguration.timelineServiceV2Enabled(\n        getRmContext().getYarnConfiguration())) {\n      CollectorInfo collectorInfo \u003d app.getCollectorInfo();\n      if (collectorInfo !\u003d null) {\n        response.setCollectorInfo(collectorInfo);\n      }\n    }\n\n    // add preemption to the allocateResponse message (if any)\n    response.setPreemptionMessage(generatePreemptionMessage(allocation));\n\n    // Set application priority\n    response.setApplicationPriority(app\n        .getApplicationPriority());\n\n    response.setContainersFromPreviousAttempts(\n        allocation.getPreviousAttemptContainers());\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/DefaultAMSProcessor.java",
      "extendedDetails": {}
    },
    "38af23796971193fa529c3d08ffde8fcd6e607b6": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6599. Support anti-affinity constraint via AppPlacementAllocator. (Wangda Tan via asuresh)\n",
      "commitDate": "31/01/18 1:30 AM",
      "commitName": "38af23796971193fa529c3d08ffde8fcd6e607b6",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "27/11/17 10:19 AM",
      "commitNameOld": "fedabcad42067ac7dd24de40fab6be2d3485a540",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 64.63,
      "commitsBetweenForRepo": 382,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,136 +1,140 @@\n   public void allocate(ApplicationAttemptId appAttemptId,\n       AllocateRequest request, AllocateResponse response) throws YarnException {\n \n     handleProgress(appAttemptId, request);\n \n     List\u003cResourceRequest\u003e ask \u003d request.getAskList();\n     List\u003cContainerId\u003e release \u003d request.getReleaseList();\n \n     ResourceBlacklistRequest blacklistRequest \u003d\n         request.getResourceBlacklistRequest();\n     List\u003cString\u003e blacklistAdditions \u003d\n         (blacklistRequest !\u003d null) ?\n             blacklistRequest.getBlacklistAdditions() : Collections.EMPTY_LIST;\n     List\u003cString\u003e blacklistRemovals \u003d\n         (blacklistRequest !\u003d null) ?\n             blacklistRequest.getBlacklistRemovals() : Collections.EMPTY_LIST;\n     RMApp app \u003d\n         getRmContext().getRMApps().get(appAttemptId.getApplicationId());\n \n     // set label expression for Resource Requests if resourceName\u003dANY\n     ApplicationSubmissionContext asc \u003d app.getApplicationSubmissionContext();\n     for (ResourceRequest req : ask) {\n       if (null \u003d\u003d req.getNodeLabelExpression()\n           \u0026\u0026 ResourceRequest.ANY.equals(req.getResourceName())) {\n         req.setNodeLabelExpression(asc.getNodeLabelExpression());\n       }\n     }\n \n     Resource maximumCapacity \u003d getScheduler().getMaximumResourceCapability();\n \n     // sanity check\n     try {\n       RMServerUtils.normalizeAndValidateRequests(ask,\n           maximumCapacity, app.getQueue(),\n           getScheduler(), getRmContext());\n     } catch (InvalidResourceRequestException e) {\n       LOG.warn(\"Invalid resource ask by application \" + appAttemptId, e);\n       throw e;\n     }\n \n     try {\n       RMServerUtils.validateBlacklistRequest(blacklistRequest);\n     }  catch (InvalidResourceBlacklistRequestException e) {\n       LOG.warn(\"Invalid blacklist request by application \" + appAttemptId, e);\n       throw e;\n     }\n \n     // In the case of work-preserving AM restart, it\u0027s possible for the\n     // AM to release containers from the earlier attempt.\n     if (!app.getApplicationSubmissionContext()\n         .getKeepContainersAcrossApplicationAttempts()) {\n       try {\n         RMServerUtils.validateContainerReleaseRequest(release, appAttemptId);\n       } catch (InvalidContainerReleaseException e) {\n         LOG.warn(\"Invalid container release by application \" + appAttemptId,\n             e);\n         throw e;\n       }\n     }\n \n     // Split Update Resource Requests into increase and decrease.\n     // No Exceptions are thrown here. All update errors are aggregated\n     // and returned to the AM.\n     List\u003cUpdateContainerError\u003e updateErrors \u003d new ArrayList\u003c\u003e();\n     ContainerUpdates containerUpdateRequests \u003d\n         RMServerUtils.validateAndSplitUpdateResourceRequests(\n             getRmContext(), request, maximumCapacity, updateErrors);\n \n     // Send new requests to appAttempt.\n     Allocation allocation;\n     RMAppAttemptState state \u003d\n         app.getRMAppAttempt(appAttemptId).getAppAttemptState();\n     if (state.equals(RMAppAttemptState.FINAL_SAVING) ||\n         state.equals(RMAppAttemptState.FINISHING) ||\n         app.isAppFinalStateStored()) {\n       LOG.warn(appAttemptId + \" is in \" + state +\n           \" state, ignore container allocate request.\");\n       allocation \u003d EMPTY_ALLOCATION;\n     } else {\n-      allocation \u003d\n-          getScheduler().allocate(appAttemptId, ask, release,\n-              blacklistAdditions, blacklistRemovals,\n-              containerUpdateRequests);\n+      try {\n+        allocation \u003d getScheduler().allocate(appAttemptId, ask,\n+            request.getSchedulingRequests(), release,\n+            blacklistAdditions, blacklistRemovals, containerUpdateRequests);\n+      } catch (SchedulerInvalidResoureRequestException e) {\n+        LOG.warn(\"Exceptions caught when scheduler handling requests\");\n+        throw new YarnException(e);\n+      }\n     }\n \n     if (!blacklistAdditions.isEmpty() || !blacklistRemovals.isEmpty()) {\n       LOG.info(\"blacklist are updated in Scheduler.\" +\n           \"blacklistAdditions: \" + blacklistAdditions + \", \" +\n           \"blacklistRemovals: \" + blacklistRemovals);\n     }\n     RMAppAttempt appAttempt \u003d app.getRMAppAttempt(appAttemptId);\n \n     if (allocation.getNMTokens() !\u003d null \u0026\u0026\n         !allocation.getNMTokens().isEmpty()) {\n       response.setNMTokens(allocation.getNMTokens());\n     }\n \n     // Notify the AM of container update errors\n     ApplicationMasterServiceUtils.addToUpdateContainerErrors(\n         response, updateErrors);\n \n     // update the response with the deltas of node status changes\n     handleNodeUpdates(app, response);\n \n     ApplicationMasterServiceUtils.addToAllocatedContainers(\n         response, allocation.getContainers());\n \n     response.setCompletedContainersStatuses(appAttempt\n         .pullJustFinishedContainers());\n     response.setAvailableResources(allocation.getResourceLimit());\n \n     addToContainerUpdates(response, allocation,\n         ((AbstractYarnScheduler)getScheduler())\n             .getApplicationAttempt(appAttemptId).pullUpdateContainerErrors());\n \n     response.setNumClusterNodes(getScheduler().getNumClusterNodes());\n \n     // add collector address for this application\n     if (YarnConfiguration.timelineServiceV2Enabled(\n         getRmContext().getYarnConfiguration())) {\n       CollectorInfo collectorInfo \u003d app.getCollectorInfo();\n       if (collectorInfo !\u003d null) {\n         response.setCollectorInfo(collectorInfo);\n       }\n     }\n \n     // add preemption to the allocateResponse message (if any)\n     response.setPreemptionMessage(generatePreemptionMessage(allocation));\n \n     // Set application priority\n     response.setApplicationPriority(app\n         .getApplicationPriority());\n \n     response.setContainersFromPreviousAttempts(\n         allocation.getPreviousAttemptContainers());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void allocate(ApplicationAttemptId appAttemptId,\n      AllocateRequest request, AllocateResponse response) throws YarnException {\n\n    handleProgress(appAttemptId, request);\n\n    List\u003cResourceRequest\u003e ask \u003d request.getAskList();\n    List\u003cContainerId\u003e release \u003d request.getReleaseList();\n\n    ResourceBlacklistRequest blacklistRequest \u003d\n        request.getResourceBlacklistRequest();\n    List\u003cString\u003e blacklistAdditions \u003d\n        (blacklistRequest !\u003d null) ?\n            blacklistRequest.getBlacklistAdditions() : Collections.EMPTY_LIST;\n    List\u003cString\u003e blacklistRemovals \u003d\n        (blacklistRequest !\u003d null) ?\n            blacklistRequest.getBlacklistRemovals() : Collections.EMPTY_LIST;\n    RMApp app \u003d\n        getRmContext().getRMApps().get(appAttemptId.getApplicationId());\n\n    // set label expression for Resource Requests if resourceName\u003dANY\n    ApplicationSubmissionContext asc \u003d app.getApplicationSubmissionContext();\n    for (ResourceRequest req : ask) {\n      if (null \u003d\u003d req.getNodeLabelExpression()\n          \u0026\u0026 ResourceRequest.ANY.equals(req.getResourceName())) {\n        req.setNodeLabelExpression(asc.getNodeLabelExpression());\n      }\n    }\n\n    Resource maximumCapacity \u003d getScheduler().getMaximumResourceCapability();\n\n    // sanity check\n    try {\n      RMServerUtils.normalizeAndValidateRequests(ask,\n          maximumCapacity, app.getQueue(),\n          getScheduler(), getRmContext());\n    } catch (InvalidResourceRequestException e) {\n      LOG.warn(\"Invalid resource ask by application \" + appAttemptId, e);\n      throw e;\n    }\n\n    try {\n      RMServerUtils.validateBlacklistRequest(blacklistRequest);\n    }  catch (InvalidResourceBlacklistRequestException e) {\n      LOG.warn(\"Invalid blacklist request by application \" + appAttemptId, e);\n      throw e;\n    }\n\n    // In the case of work-preserving AM restart, it\u0027s possible for the\n    // AM to release containers from the earlier attempt.\n    if (!app.getApplicationSubmissionContext()\n        .getKeepContainersAcrossApplicationAttempts()) {\n      try {\n        RMServerUtils.validateContainerReleaseRequest(release, appAttemptId);\n      } catch (InvalidContainerReleaseException e) {\n        LOG.warn(\"Invalid container release by application \" + appAttemptId,\n            e);\n        throw e;\n      }\n    }\n\n    // Split Update Resource Requests into increase and decrease.\n    // No Exceptions are thrown here. All update errors are aggregated\n    // and returned to the AM.\n    List\u003cUpdateContainerError\u003e updateErrors \u003d new ArrayList\u003c\u003e();\n    ContainerUpdates containerUpdateRequests \u003d\n        RMServerUtils.validateAndSplitUpdateResourceRequests(\n            getRmContext(), request, maximumCapacity, updateErrors);\n\n    // Send new requests to appAttempt.\n    Allocation allocation;\n    RMAppAttemptState state \u003d\n        app.getRMAppAttempt(appAttemptId).getAppAttemptState();\n    if (state.equals(RMAppAttemptState.FINAL_SAVING) ||\n        state.equals(RMAppAttemptState.FINISHING) ||\n        app.isAppFinalStateStored()) {\n      LOG.warn(appAttemptId + \" is in \" + state +\n          \" state, ignore container allocate request.\");\n      allocation \u003d EMPTY_ALLOCATION;\n    } else {\n      try {\n        allocation \u003d getScheduler().allocate(appAttemptId, ask,\n            request.getSchedulingRequests(), release,\n            blacklistAdditions, blacklistRemovals, containerUpdateRequests);\n      } catch (SchedulerInvalidResoureRequestException e) {\n        LOG.warn(\"Exceptions caught when scheduler handling requests\");\n        throw new YarnException(e);\n      }\n    }\n\n    if (!blacklistAdditions.isEmpty() || !blacklistRemovals.isEmpty()) {\n      LOG.info(\"blacklist are updated in Scheduler.\" +\n          \"blacklistAdditions: \" + blacklistAdditions + \", \" +\n          \"blacklistRemovals: \" + blacklistRemovals);\n    }\n    RMAppAttempt appAttempt \u003d app.getRMAppAttempt(appAttemptId);\n\n    if (allocation.getNMTokens() !\u003d null \u0026\u0026\n        !allocation.getNMTokens().isEmpty()) {\n      response.setNMTokens(allocation.getNMTokens());\n    }\n\n    // Notify the AM of container update errors\n    ApplicationMasterServiceUtils.addToUpdateContainerErrors(\n        response, updateErrors);\n\n    // update the response with the deltas of node status changes\n    handleNodeUpdates(app, response);\n\n    ApplicationMasterServiceUtils.addToAllocatedContainers(\n        response, allocation.getContainers());\n\n    response.setCompletedContainersStatuses(appAttempt\n        .pullJustFinishedContainers());\n    response.setAvailableResources(allocation.getResourceLimit());\n\n    addToContainerUpdates(response, allocation,\n        ((AbstractYarnScheduler)getScheduler())\n            .getApplicationAttempt(appAttemptId).pullUpdateContainerErrors());\n\n    response.setNumClusterNodes(getScheduler().getNumClusterNodes());\n\n    // add collector address for this application\n    if (YarnConfiguration.timelineServiceV2Enabled(\n        getRmContext().getYarnConfiguration())) {\n      CollectorInfo collectorInfo \u003d app.getCollectorInfo();\n      if (collectorInfo !\u003d null) {\n        response.setCollectorInfo(collectorInfo);\n      }\n    }\n\n    // add preemption to the allocateResponse message (if any)\n    response.setPreemptionMessage(generatePreemptionMessage(allocation));\n\n    // Set application priority\n    response.setApplicationPriority(app\n        .getApplicationPriority());\n\n    response.setContainersFromPreviousAttempts(\n        allocation.getPreviousAttemptContainers());\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/DefaultAMSProcessor.java",
      "extendedDetails": {}
    },
    "fedabcad42067ac7dd24de40fab6be2d3485a540": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6168. Restarted RM may not inform AM about all existing containers. Contributed by Chandni Singh\n",
      "commitDate": "27/11/17 10:19 AM",
      "commitName": "fedabcad42067ac7dd24de40fab6be2d3485a540",
      "commitAuthor": "Jian He",
      "commitDateOld": "22/11/17 7:18 PM",
      "commitNameOld": "b46ca7e73b8bac3fdbff0b13afe009308078acf2",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 4.63,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,133 +1,136 @@\n   public void allocate(ApplicationAttemptId appAttemptId,\n       AllocateRequest request, AllocateResponse response) throws YarnException {\n \n     handleProgress(appAttemptId, request);\n \n     List\u003cResourceRequest\u003e ask \u003d request.getAskList();\n     List\u003cContainerId\u003e release \u003d request.getReleaseList();\n \n     ResourceBlacklistRequest blacklistRequest \u003d\n         request.getResourceBlacklistRequest();\n     List\u003cString\u003e blacklistAdditions \u003d\n         (blacklistRequest !\u003d null) ?\n             blacklistRequest.getBlacklistAdditions() : Collections.EMPTY_LIST;\n     List\u003cString\u003e blacklistRemovals \u003d\n         (blacklistRequest !\u003d null) ?\n             blacklistRequest.getBlacklistRemovals() : Collections.EMPTY_LIST;\n     RMApp app \u003d\n         getRmContext().getRMApps().get(appAttemptId.getApplicationId());\n \n     // set label expression for Resource Requests if resourceName\u003dANY\n     ApplicationSubmissionContext asc \u003d app.getApplicationSubmissionContext();\n     for (ResourceRequest req : ask) {\n       if (null \u003d\u003d req.getNodeLabelExpression()\n           \u0026\u0026 ResourceRequest.ANY.equals(req.getResourceName())) {\n         req.setNodeLabelExpression(asc.getNodeLabelExpression());\n       }\n     }\n \n     Resource maximumCapacity \u003d getScheduler().getMaximumResourceCapability();\n \n     // sanity check\n     try {\n       RMServerUtils.normalizeAndValidateRequests(ask,\n           maximumCapacity, app.getQueue(),\n           getScheduler(), getRmContext());\n     } catch (InvalidResourceRequestException e) {\n       LOG.warn(\"Invalid resource ask by application \" + appAttemptId, e);\n       throw e;\n     }\n \n     try {\n       RMServerUtils.validateBlacklistRequest(blacklistRequest);\n     }  catch (InvalidResourceBlacklistRequestException e) {\n       LOG.warn(\"Invalid blacklist request by application \" + appAttemptId, e);\n       throw e;\n     }\n \n     // In the case of work-preserving AM restart, it\u0027s possible for the\n     // AM to release containers from the earlier attempt.\n     if (!app.getApplicationSubmissionContext()\n         .getKeepContainersAcrossApplicationAttempts()) {\n       try {\n         RMServerUtils.validateContainerReleaseRequest(release, appAttemptId);\n       } catch (InvalidContainerReleaseException e) {\n         LOG.warn(\"Invalid container release by application \" + appAttemptId,\n             e);\n         throw e;\n       }\n     }\n \n     // Split Update Resource Requests into increase and decrease.\n     // No Exceptions are thrown here. All update errors are aggregated\n     // and returned to the AM.\n     List\u003cUpdateContainerError\u003e updateErrors \u003d new ArrayList\u003c\u003e();\n     ContainerUpdates containerUpdateRequests \u003d\n         RMServerUtils.validateAndSplitUpdateResourceRequests(\n             getRmContext(), request, maximumCapacity, updateErrors);\n \n     // Send new requests to appAttempt.\n     Allocation allocation;\n     RMAppAttemptState state \u003d\n         app.getRMAppAttempt(appAttemptId).getAppAttemptState();\n     if (state.equals(RMAppAttemptState.FINAL_SAVING) ||\n         state.equals(RMAppAttemptState.FINISHING) ||\n         app.isAppFinalStateStored()) {\n       LOG.warn(appAttemptId + \" is in \" + state +\n           \" state, ignore container allocate request.\");\n       allocation \u003d EMPTY_ALLOCATION;\n     } else {\n       allocation \u003d\n           getScheduler().allocate(appAttemptId, ask, release,\n               blacklistAdditions, blacklistRemovals,\n               containerUpdateRequests);\n     }\n \n     if (!blacklistAdditions.isEmpty() || !blacklistRemovals.isEmpty()) {\n       LOG.info(\"blacklist are updated in Scheduler.\" +\n           \"blacklistAdditions: \" + blacklistAdditions + \", \" +\n           \"blacklistRemovals: \" + blacklistRemovals);\n     }\n     RMAppAttempt appAttempt \u003d app.getRMAppAttempt(appAttemptId);\n \n     if (allocation.getNMTokens() !\u003d null \u0026\u0026\n         !allocation.getNMTokens().isEmpty()) {\n       response.setNMTokens(allocation.getNMTokens());\n     }\n \n     // Notify the AM of container update errors\n     ApplicationMasterServiceUtils.addToUpdateContainerErrors(\n         response, updateErrors);\n \n     // update the response with the deltas of node status changes\n     handleNodeUpdates(app, response);\n \n     ApplicationMasterServiceUtils.addToAllocatedContainers(\n         response, allocation.getContainers());\n \n     response.setCompletedContainersStatuses(appAttempt\n         .pullJustFinishedContainers());\n     response.setAvailableResources(allocation.getResourceLimit());\n \n     addToContainerUpdates(response, allocation,\n         ((AbstractYarnScheduler)getScheduler())\n             .getApplicationAttempt(appAttemptId).pullUpdateContainerErrors());\n \n     response.setNumClusterNodes(getScheduler().getNumClusterNodes());\n \n     // add collector address for this application\n     if (YarnConfiguration.timelineServiceV2Enabled(\n         getRmContext().getYarnConfiguration())) {\n       CollectorInfo collectorInfo \u003d app.getCollectorInfo();\n       if (collectorInfo !\u003d null) {\n         response.setCollectorInfo(collectorInfo);\n       }\n     }\n \n     // add preemption to the allocateResponse message (if any)\n     response.setPreemptionMessage(generatePreemptionMessage(allocation));\n \n     // Set application priority\n     response.setApplicationPriority(app\n         .getApplicationPriority());\n+\n+    response.setContainersFromPreviousAttempts(\n+        allocation.getPreviousAttemptContainers());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void allocate(ApplicationAttemptId appAttemptId,\n      AllocateRequest request, AllocateResponse response) throws YarnException {\n\n    handleProgress(appAttemptId, request);\n\n    List\u003cResourceRequest\u003e ask \u003d request.getAskList();\n    List\u003cContainerId\u003e release \u003d request.getReleaseList();\n\n    ResourceBlacklistRequest blacklistRequest \u003d\n        request.getResourceBlacklistRequest();\n    List\u003cString\u003e blacklistAdditions \u003d\n        (blacklistRequest !\u003d null) ?\n            blacklistRequest.getBlacklistAdditions() : Collections.EMPTY_LIST;\n    List\u003cString\u003e blacklistRemovals \u003d\n        (blacklistRequest !\u003d null) ?\n            blacklistRequest.getBlacklistRemovals() : Collections.EMPTY_LIST;\n    RMApp app \u003d\n        getRmContext().getRMApps().get(appAttemptId.getApplicationId());\n\n    // set label expression for Resource Requests if resourceName\u003dANY\n    ApplicationSubmissionContext asc \u003d app.getApplicationSubmissionContext();\n    for (ResourceRequest req : ask) {\n      if (null \u003d\u003d req.getNodeLabelExpression()\n          \u0026\u0026 ResourceRequest.ANY.equals(req.getResourceName())) {\n        req.setNodeLabelExpression(asc.getNodeLabelExpression());\n      }\n    }\n\n    Resource maximumCapacity \u003d getScheduler().getMaximumResourceCapability();\n\n    // sanity check\n    try {\n      RMServerUtils.normalizeAndValidateRequests(ask,\n          maximumCapacity, app.getQueue(),\n          getScheduler(), getRmContext());\n    } catch (InvalidResourceRequestException e) {\n      LOG.warn(\"Invalid resource ask by application \" + appAttemptId, e);\n      throw e;\n    }\n\n    try {\n      RMServerUtils.validateBlacklistRequest(blacklistRequest);\n    }  catch (InvalidResourceBlacklistRequestException e) {\n      LOG.warn(\"Invalid blacklist request by application \" + appAttemptId, e);\n      throw e;\n    }\n\n    // In the case of work-preserving AM restart, it\u0027s possible for the\n    // AM to release containers from the earlier attempt.\n    if (!app.getApplicationSubmissionContext()\n        .getKeepContainersAcrossApplicationAttempts()) {\n      try {\n        RMServerUtils.validateContainerReleaseRequest(release, appAttemptId);\n      } catch (InvalidContainerReleaseException e) {\n        LOG.warn(\"Invalid container release by application \" + appAttemptId,\n            e);\n        throw e;\n      }\n    }\n\n    // Split Update Resource Requests into increase and decrease.\n    // No Exceptions are thrown here. All update errors are aggregated\n    // and returned to the AM.\n    List\u003cUpdateContainerError\u003e updateErrors \u003d new ArrayList\u003c\u003e();\n    ContainerUpdates containerUpdateRequests \u003d\n        RMServerUtils.validateAndSplitUpdateResourceRequests(\n            getRmContext(), request, maximumCapacity, updateErrors);\n\n    // Send new requests to appAttempt.\n    Allocation allocation;\n    RMAppAttemptState state \u003d\n        app.getRMAppAttempt(appAttemptId).getAppAttemptState();\n    if (state.equals(RMAppAttemptState.FINAL_SAVING) ||\n        state.equals(RMAppAttemptState.FINISHING) ||\n        app.isAppFinalStateStored()) {\n      LOG.warn(appAttemptId + \" is in \" + state +\n          \" state, ignore container allocate request.\");\n      allocation \u003d EMPTY_ALLOCATION;\n    } else {\n      allocation \u003d\n          getScheduler().allocate(appAttemptId, ask, release,\n              blacklistAdditions, blacklistRemovals,\n              containerUpdateRequests);\n    }\n\n    if (!blacklistAdditions.isEmpty() || !blacklistRemovals.isEmpty()) {\n      LOG.info(\"blacklist are updated in Scheduler.\" +\n          \"blacklistAdditions: \" + blacklistAdditions + \", \" +\n          \"blacklistRemovals: \" + blacklistRemovals);\n    }\n    RMAppAttempt appAttempt \u003d app.getRMAppAttempt(appAttemptId);\n\n    if (allocation.getNMTokens() !\u003d null \u0026\u0026\n        !allocation.getNMTokens().isEmpty()) {\n      response.setNMTokens(allocation.getNMTokens());\n    }\n\n    // Notify the AM of container update errors\n    ApplicationMasterServiceUtils.addToUpdateContainerErrors(\n        response, updateErrors);\n\n    // update the response with the deltas of node status changes\n    handleNodeUpdates(app, response);\n\n    ApplicationMasterServiceUtils.addToAllocatedContainers(\n        response, allocation.getContainers());\n\n    response.setCompletedContainersStatuses(appAttempt\n        .pullJustFinishedContainers());\n    response.setAvailableResources(allocation.getResourceLimit());\n\n    addToContainerUpdates(response, allocation,\n        ((AbstractYarnScheduler)getScheduler())\n            .getApplicationAttempt(appAttemptId).pullUpdateContainerErrors());\n\n    response.setNumClusterNodes(getScheduler().getNumClusterNodes());\n\n    // add collector address for this application\n    if (YarnConfiguration.timelineServiceV2Enabled(\n        getRmContext().getYarnConfiguration())) {\n      CollectorInfo collectorInfo \u003d app.getCollectorInfo();\n      if (collectorInfo !\u003d null) {\n        response.setCollectorInfo(collectorInfo);\n      }\n    }\n\n    // add preemption to the allocateResponse message (if any)\n    response.setPreemptionMessage(generatePreemptionMessage(allocation));\n\n    // Set application priority\n    response.setApplicationPriority(app\n        .getApplicationPriority());\n\n    response.setContainersFromPreviousAttempts(\n        allocation.getPreviousAttemptContainers());\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/DefaultAMSProcessor.java",
      "extendedDetails": {}
    },
    "7594d1de7bbc34cd2e64202095a5e1757154d7d0": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6130. [ATSv2 Security] Generate a delegation token for AM when app collector is created and pass it to AM via NM and RM. Contributed by Varun Saxena.\n",
      "commitDate": "29/08/17 10:59 PM",
      "commitName": "7594d1de7bbc34cd2e64202095a5e1757154d7d0",
      "commitAuthor": "Rohith Sharma K S",
      "commitDateOld": "29/08/17 10:59 PM",
      "commitNameOld": "78b7e070d8009c78665a2baa64fe888788f53e69",
      "commitAuthorOld": "Sangjin Lee",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 38,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,133 +1,133 @@\n   public void allocate(ApplicationAttemptId appAttemptId,\n       AllocateRequest request, AllocateResponse response) throws YarnException {\n \n     handleProgress(appAttemptId, request);\n \n     List\u003cResourceRequest\u003e ask \u003d request.getAskList();\n     List\u003cContainerId\u003e release \u003d request.getReleaseList();\n \n     ResourceBlacklistRequest blacklistRequest \u003d\n         request.getResourceBlacklistRequest();\n     List\u003cString\u003e blacklistAdditions \u003d\n         (blacklistRequest !\u003d null) ?\n             blacklistRequest.getBlacklistAdditions() : Collections.EMPTY_LIST;\n     List\u003cString\u003e blacklistRemovals \u003d\n         (blacklistRequest !\u003d null) ?\n             blacklistRequest.getBlacklistRemovals() : Collections.EMPTY_LIST;\n     RMApp app \u003d\n         getRmContext().getRMApps().get(appAttemptId.getApplicationId());\n \n     // set label expression for Resource Requests if resourceName\u003dANY\n     ApplicationSubmissionContext asc \u003d app.getApplicationSubmissionContext();\n     for (ResourceRequest req : ask) {\n       if (null \u003d\u003d req.getNodeLabelExpression()\n           \u0026\u0026 ResourceRequest.ANY.equals(req.getResourceName())) {\n         req.setNodeLabelExpression(asc.getNodeLabelExpression());\n       }\n     }\n \n     Resource maximumCapacity \u003d getScheduler().getMaximumResourceCapability();\n \n     // sanity check\n     try {\n       RMServerUtils.normalizeAndValidateRequests(ask,\n           maximumCapacity, app.getQueue(),\n           getScheduler(), getRmContext());\n     } catch (InvalidResourceRequestException e) {\n       LOG.warn(\"Invalid resource ask by application \" + appAttemptId, e);\n       throw e;\n     }\n \n     try {\n       RMServerUtils.validateBlacklistRequest(blacklistRequest);\n     }  catch (InvalidResourceBlacklistRequestException e) {\n       LOG.warn(\"Invalid blacklist request by application \" + appAttemptId, e);\n       throw e;\n     }\n \n     // In the case of work-preserving AM restart, it\u0027s possible for the\n     // AM to release containers from the earlier attempt.\n     if (!app.getApplicationSubmissionContext()\n         .getKeepContainersAcrossApplicationAttempts()) {\n       try {\n         RMServerUtils.validateContainerReleaseRequest(release, appAttemptId);\n       } catch (InvalidContainerReleaseException e) {\n         LOG.warn(\"Invalid container release by application \" + appAttemptId,\n             e);\n         throw e;\n       }\n     }\n \n     // Split Update Resource Requests into increase and decrease.\n     // No Exceptions are thrown here. All update errors are aggregated\n     // and returned to the AM.\n     List\u003cUpdateContainerError\u003e updateErrors \u003d new ArrayList\u003c\u003e();\n     ContainerUpdates containerUpdateRequests \u003d\n         RMServerUtils.validateAndSplitUpdateResourceRequests(\n             getRmContext(), request, maximumCapacity, updateErrors);\n \n     // Send new requests to appAttempt.\n     Allocation allocation;\n     RMAppAttemptState state \u003d\n         app.getRMAppAttempt(appAttemptId).getAppAttemptState();\n     if (state.equals(RMAppAttemptState.FINAL_SAVING) ||\n         state.equals(RMAppAttemptState.FINISHING) ||\n         app.isAppFinalStateStored()) {\n       LOG.warn(appAttemptId + \" is in \" + state +\n           \" state, ignore container allocate request.\");\n       allocation \u003d EMPTY_ALLOCATION;\n     } else {\n       allocation \u003d\n           getScheduler().allocate(appAttemptId, ask, release,\n               blacklistAdditions, blacklistRemovals,\n               containerUpdateRequests);\n     }\n \n     if (!blacklistAdditions.isEmpty() || !blacklistRemovals.isEmpty()) {\n       LOG.info(\"blacklist are updated in Scheduler.\" +\n           \"blacklistAdditions: \" + blacklistAdditions + \", \" +\n           \"blacklistRemovals: \" + blacklistRemovals);\n     }\n     RMAppAttempt appAttempt \u003d app.getRMAppAttempt(appAttemptId);\n \n     if (allocation.getNMTokens() !\u003d null \u0026\u0026\n         !allocation.getNMTokens().isEmpty()) {\n       response.setNMTokens(allocation.getNMTokens());\n     }\n \n     // Notify the AM of container update errors\n     ApplicationMasterServiceUtils.addToUpdateContainerErrors(\n         response, updateErrors);\n \n     // update the response with the deltas of node status changes\n     handleNodeUpdates(app, response);\n \n     ApplicationMasterServiceUtils.addToAllocatedContainers(\n         response, allocation.getContainers());\n \n     response.setCompletedContainersStatuses(appAttempt\n         .pullJustFinishedContainers());\n     response.setAvailableResources(allocation.getResourceLimit());\n \n     addToContainerUpdates(response, allocation,\n         ((AbstractYarnScheduler)getScheduler())\n             .getApplicationAttempt(appAttemptId).pullUpdateContainerErrors());\n \n     response.setNumClusterNodes(getScheduler().getNumClusterNodes());\n \n     // add collector address for this application\n     if (YarnConfiguration.timelineServiceV2Enabled(\n         getRmContext().getYarnConfiguration())) {\n-      AppCollectorData data \u003d app.getCollectorData();\n-      if (data !\u003d null) {\n-        response.setCollectorAddr(data.getCollectorAddr());\n+      CollectorInfo collectorInfo \u003d app.getCollectorInfo();\n+      if (collectorInfo !\u003d null) {\n+        response.setCollectorInfo(collectorInfo);\n       }\n     }\n \n     // add preemption to the allocateResponse message (if any)\n     response.setPreemptionMessage(generatePreemptionMessage(allocation));\n \n     // Set application priority\n     response.setApplicationPriority(app\n         .getApplicationPriority());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void allocate(ApplicationAttemptId appAttemptId,\n      AllocateRequest request, AllocateResponse response) throws YarnException {\n\n    handleProgress(appAttemptId, request);\n\n    List\u003cResourceRequest\u003e ask \u003d request.getAskList();\n    List\u003cContainerId\u003e release \u003d request.getReleaseList();\n\n    ResourceBlacklistRequest blacklistRequest \u003d\n        request.getResourceBlacklistRequest();\n    List\u003cString\u003e blacklistAdditions \u003d\n        (blacklistRequest !\u003d null) ?\n            blacklistRequest.getBlacklistAdditions() : Collections.EMPTY_LIST;\n    List\u003cString\u003e blacklistRemovals \u003d\n        (blacklistRequest !\u003d null) ?\n            blacklistRequest.getBlacklistRemovals() : Collections.EMPTY_LIST;\n    RMApp app \u003d\n        getRmContext().getRMApps().get(appAttemptId.getApplicationId());\n\n    // set label expression for Resource Requests if resourceName\u003dANY\n    ApplicationSubmissionContext asc \u003d app.getApplicationSubmissionContext();\n    for (ResourceRequest req : ask) {\n      if (null \u003d\u003d req.getNodeLabelExpression()\n          \u0026\u0026 ResourceRequest.ANY.equals(req.getResourceName())) {\n        req.setNodeLabelExpression(asc.getNodeLabelExpression());\n      }\n    }\n\n    Resource maximumCapacity \u003d getScheduler().getMaximumResourceCapability();\n\n    // sanity check\n    try {\n      RMServerUtils.normalizeAndValidateRequests(ask,\n          maximumCapacity, app.getQueue(),\n          getScheduler(), getRmContext());\n    } catch (InvalidResourceRequestException e) {\n      LOG.warn(\"Invalid resource ask by application \" + appAttemptId, e);\n      throw e;\n    }\n\n    try {\n      RMServerUtils.validateBlacklistRequest(blacklistRequest);\n    }  catch (InvalidResourceBlacklistRequestException e) {\n      LOG.warn(\"Invalid blacklist request by application \" + appAttemptId, e);\n      throw e;\n    }\n\n    // In the case of work-preserving AM restart, it\u0027s possible for the\n    // AM to release containers from the earlier attempt.\n    if (!app.getApplicationSubmissionContext()\n        .getKeepContainersAcrossApplicationAttempts()) {\n      try {\n        RMServerUtils.validateContainerReleaseRequest(release, appAttemptId);\n      } catch (InvalidContainerReleaseException e) {\n        LOG.warn(\"Invalid container release by application \" + appAttemptId,\n            e);\n        throw e;\n      }\n    }\n\n    // Split Update Resource Requests into increase and decrease.\n    // No Exceptions are thrown here. All update errors are aggregated\n    // and returned to the AM.\n    List\u003cUpdateContainerError\u003e updateErrors \u003d new ArrayList\u003c\u003e();\n    ContainerUpdates containerUpdateRequests \u003d\n        RMServerUtils.validateAndSplitUpdateResourceRequests(\n            getRmContext(), request, maximumCapacity, updateErrors);\n\n    // Send new requests to appAttempt.\n    Allocation allocation;\n    RMAppAttemptState state \u003d\n        app.getRMAppAttempt(appAttemptId).getAppAttemptState();\n    if (state.equals(RMAppAttemptState.FINAL_SAVING) ||\n        state.equals(RMAppAttemptState.FINISHING) ||\n        app.isAppFinalStateStored()) {\n      LOG.warn(appAttemptId + \" is in \" + state +\n          \" state, ignore container allocate request.\");\n      allocation \u003d EMPTY_ALLOCATION;\n    } else {\n      allocation \u003d\n          getScheduler().allocate(appAttemptId, ask, release,\n              blacklistAdditions, blacklistRemovals,\n              containerUpdateRequests);\n    }\n\n    if (!blacklistAdditions.isEmpty() || !blacklistRemovals.isEmpty()) {\n      LOG.info(\"blacklist are updated in Scheduler.\" +\n          \"blacklistAdditions: \" + blacklistAdditions + \", \" +\n          \"blacklistRemovals: \" + blacklistRemovals);\n    }\n    RMAppAttempt appAttempt \u003d app.getRMAppAttempt(appAttemptId);\n\n    if (allocation.getNMTokens() !\u003d null \u0026\u0026\n        !allocation.getNMTokens().isEmpty()) {\n      response.setNMTokens(allocation.getNMTokens());\n    }\n\n    // Notify the AM of container update errors\n    ApplicationMasterServiceUtils.addToUpdateContainerErrors(\n        response, updateErrors);\n\n    // update the response with the deltas of node status changes\n    handleNodeUpdates(app, response);\n\n    ApplicationMasterServiceUtils.addToAllocatedContainers(\n        response, allocation.getContainers());\n\n    response.setCompletedContainersStatuses(appAttempt\n        .pullJustFinishedContainers());\n    response.setAvailableResources(allocation.getResourceLimit());\n\n    addToContainerUpdates(response, allocation,\n        ((AbstractYarnScheduler)getScheduler())\n            .getApplicationAttempt(appAttemptId).pullUpdateContainerErrors());\n\n    response.setNumClusterNodes(getScheduler().getNumClusterNodes());\n\n    // add collector address for this application\n    if (YarnConfiguration.timelineServiceV2Enabled(\n        getRmContext().getYarnConfiguration())) {\n      CollectorInfo collectorInfo \u003d app.getCollectorInfo();\n      if (collectorInfo !\u003d null) {\n        response.setCollectorInfo(collectorInfo);\n      }\n    }\n\n    // add preemption to the allocateResponse message (if any)\n    response.setPreemptionMessage(generatePreemptionMessage(allocation));\n\n    // Set application priority\n    response.setApplicationPriority(app\n        .getApplicationPriority());\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/DefaultAMSProcessor.java",
      "extendedDetails": {}
    },
    "78b7e070d8009c78665a2baa64fe888788f53e69": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5638. Introduce a collector timestamp to uniquely identify collectors creation order in collector discovery. Contributed by Li Lu.\n",
      "commitDate": "29/08/17 10:59 PM",
      "commitName": "78b7e070d8009c78665a2baa64fe888788f53e69",
      "commitAuthor": "Sangjin Lee",
      "commitDateOld": "19/07/17 12:26 PM",
      "commitNameOld": "077fcf6a96e420e7f36350931722b8603d010cf1",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 41.44,
      "commitsBetweenForRepo": 299,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,132 +1,133 @@\n   public void allocate(ApplicationAttemptId appAttemptId,\n       AllocateRequest request, AllocateResponse response) throws YarnException {\n \n     handleProgress(appAttemptId, request);\n \n     List\u003cResourceRequest\u003e ask \u003d request.getAskList();\n     List\u003cContainerId\u003e release \u003d request.getReleaseList();\n \n     ResourceBlacklistRequest blacklistRequest \u003d\n         request.getResourceBlacklistRequest();\n     List\u003cString\u003e blacklistAdditions \u003d\n         (blacklistRequest !\u003d null) ?\n             blacklistRequest.getBlacklistAdditions() : Collections.EMPTY_LIST;\n     List\u003cString\u003e blacklistRemovals \u003d\n         (blacklistRequest !\u003d null) ?\n             blacklistRequest.getBlacklistRemovals() : Collections.EMPTY_LIST;\n     RMApp app \u003d\n         getRmContext().getRMApps().get(appAttemptId.getApplicationId());\n \n     // set label expression for Resource Requests if resourceName\u003dANY\n     ApplicationSubmissionContext asc \u003d app.getApplicationSubmissionContext();\n     for (ResourceRequest req : ask) {\n       if (null \u003d\u003d req.getNodeLabelExpression()\n           \u0026\u0026 ResourceRequest.ANY.equals(req.getResourceName())) {\n         req.setNodeLabelExpression(asc.getNodeLabelExpression());\n       }\n     }\n \n     Resource maximumCapacity \u003d getScheduler().getMaximumResourceCapability();\n \n     // sanity check\n     try {\n       RMServerUtils.normalizeAndValidateRequests(ask,\n           maximumCapacity, app.getQueue(),\n           getScheduler(), getRmContext());\n     } catch (InvalidResourceRequestException e) {\n       LOG.warn(\"Invalid resource ask by application \" + appAttemptId, e);\n       throw e;\n     }\n \n     try {\n       RMServerUtils.validateBlacklistRequest(blacklistRequest);\n     }  catch (InvalidResourceBlacklistRequestException e) {\n       LOG.warn(\"Invalid blacklist request by application \" + appAttemptId, e);\n       throw e;\n     }\n \n     // In the case of work-preserving AM restart, it\u0027s possible for the\n     // AM to release containers from the earlier attempt.\n     if (!app.getApplicationSubmissionContext()\n         .getKeepContainersAcrossApplicationAttempts()) {\n       try {\n         RMServerUtils.validateContainerReleaseRequest(release, appAttemptId);\n       } catch (InvalidContainerReleaseException e) {\n         LOG.warn(\"Invalid container release by application \" + appAttemptId,\n             e);\n         throw e;\n       }\n     }\n \n     // Split Update Resource Requests into increase and decrease.\n     // No Exceptions are thrown here. All update errors are aggregated\n     // and returned to the AM.\n     List\u003cUpdateContainerError\u003e updateErrors \u003d new ArrayList\u003c\u003e();\n     ContainerUpdates containerUpdateRequests \u003d\n         RMServerUtils.validateAndSplitUpdateResourceRequests(\n             getRmContext(), request, maximumCapacity, updateErrors);\n \n     // Send new requests to appAttempt.\n     Allocation allocation;\n     RMAppAttemptState state \u003d\n         app.getRMAppAttempt(appAttemptId).getAppAttemptState();\n     if (state.equals(RMAppAttemptState.FINAL_SAVING) ||\n         state.equals(RMAppAttemptState.FINISHING) ||\n         app.isAppFinalStateStored()) {\n       LOG.warn(appAttemptId + \" is in \" + state +\n           \" state, ignore container allocate request.\");\n       allocation \u003d EMPTY_ALLOCATION;\n     } else {\n       allocation \u003d\n           getScheduler().allocate(appAttemptId, ask, release,\n               blacklistAdditions, blacklistRemovals,\n               containerUpdateRequests);\n     }\n \n     if (!blacklistAdditions.isEmpty() || !blacklistRemovals.isEmpty()) {\n       LOG.info(\"blacklist are updated in Scheduler.\" +\n           \"blacklistAdditions: \" + blacklistAdditions + \", \" +\n           \"blacklistRemovals: \" + blacklistRemovals);\n     }\n     RMAppAttempt appAttempt \u003d app.getRMAppAttempt(appAttemptId);\n \n     if (allocation.getNMTokens() !\u003d null \u0026\u0026\n         !allocation.getNMTokens().isEmpty()) {\n       response.setNMTokens(allocation.getNMTokens());\n     }\n \n     // Notify the AM of container update errors\n     ApplicationMasterServiceUtils.addToUpdateContainerErrors(\n         response, updateErrors);\n \n     // update the response with the deltas of node status changes\n     handleNodeUpdates(app, response);\n \n     ApplicationMasterServiceUtils.addToAllocatedContainers(\n         response, allocation.getContainers());\n \n     response.setCompletedContainersStatuses(appAttempt\n         .pullJustFinishedContainers());\n     response.setAvailableResources(allocation.getResourceLimit());\n \n     addToContainerUpdates(response, allocation,\n         ((AbstractYarnScheduler)getScheduler())\n             .getApplicationAttempt(appAttemptId).pullUpdateContainerErrors());\n \n     response.setNumClusterNodes(getScheduler().getNumClusterNodes());\n \n     // add collector address for this application\n     if (YarnConfiguration.timelineServiceV2Enabled(\n         getRmContext().getYarnConfiguration())) {\n-      response.setCollectorAddr(\n-          getRmContext().getRMApps().get(appAttemptId.getApplicationId())\n-              .getCollectorAddr());\n+      AppCollectorData data \u003d app.getCollectorData();\n+      if (data !\u003d null) {\n+        response.setCollectorAddr(data.getCollectorAddr());\n+      }\n     }\n \n     // add preemption to the allocateResponse message (if any)\n     response.setPreemptionMessage(generatePreemptionMessage(allocation));\n \n     // Set application priority\n     response.setApplicationPriority(app\n         .getApplicationPriority());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void allocate(ApplicationAttemptId appAttemptId,\n      AllocateRequest request, AllocateResponse response) throws YarnException {\n\n    handleProgress(appAttemptId, request);\n\n    List\u003cResourceRequest\u003e ask \u003d request.getAskList();\n    List\u003cContainerId\u003e release \u003d request.getReleaseList();\n\n    ResourceBlacklistRequest blacklistRequest \u003d\n        request.getResourceBlacklistRequest();\n    List\u003cString\u003e blacklistAdditions \u003d\n        (blacklistRequest !\u003d null) ?\n            blacklistRequest.getBlacklistAdditions() : Collections.EMPTY_LIST;\n    List\u003cString\u003e blacklistRemovals \u003d\n        (blacklistRequest !\u003d null) ?\n            blacklistRequest.getBlacklistRemovals() : Collections.EMPTY_LIST;\n    RMApp app \u003d\n        getRmContext().getRMApps().get(appAttemptId.getApplicationId());\n\n    // set label expression for Resource Requests if resourceName\u003dANY\n    ApplicationSubmissionContext asc \u003d app.getApplicationSubmissionContext();\n    for (ResourceRequest req : ask) {\n      if (null \u003d\u003d req.getNodeLabelExpression()\n          \u0026\u0026 ResourceRequest.ANY.equals(req.getResourceName())) {\n        req.setNodeLabelExpression(asc.getNodeLabelExpression());\n      }\n    }\n\n    Resource maximumCapacity \u003d getScheduler().getMaximumResourceCapability();\n\n    // sanity check\n    try {\n      RMServerUtils.normalizeAndValidateRequests(ask,\n          maximumCapacity, app.getQueue(),\n          getScheduler(), getRmContext());\n    } catch (InvalidResourceRequestException e) {\n      LOG.warn(\"Invalid resource ask by application \" + appAttemptId, e);\n      throw e;\n    }\n\n    try {\n      RMServerUtils.validateBlacklistRequest(blacklistRequest);\n    }  catch (InvalidResourceBlacklistRequestException e) {\n      LOG.warn(\"Invalid blacklist request by application \" + appAttemptId, e);\n      throw e;\n    }\n\n    // In the case of work-preserving AM restart, it\u0027s possible for the\n    // AM to release containers from the earlier attempt.\n    if (!app.getApplicationSubmissionContext()\n        .getKeepContainersAcrossApplicationAttempts()) {\n      try {\n        RMServerUtils.validateContainerReleaseRequest(release, appAttemptId);\n      } catch (InvalidContainerReleaseException e) {\n        LOG.warn(\"Invalid container release by application \" + appAttemptId,\n            e);\n        throw e;\n      }\n    }\n\n    // Split Update Resource Requests into increase and decrease.\n    // No Exceptions are thrown here. All update errors are aggregated\n    // and returned to the AM.\n    List\u003cUpdateContainerError\u003e updateErrors \u003d new ArrayList\u003c\u003e();\n    ContainerUpdates containerUpdateRequests \u003d\n        RMServerUtils.validateAndSplitUpdateResourceRequests(\n            getRmContext(), request, maximumCapacity, updateErrors);\n\n    // Send new requests to appAttempt.\n    Allocation allocation;\n    RMAppAttemptState state \u003d\n        app.getRMAppAttempt(appAttemptId).getAppAttemptState();\n    if (state.equals(RMAppAttemptState.FINAL_SAVING) ||\n        state.equals(RMAppAttemptState.FINISHING) ||\n        app.isAppFinalStateStored()) {\n      LOG.warn(appAttemptId + \" is in \" + state +\n          \" state, ignore container allocate request.\");\n      allocation \u003d EMPTY_ALLOCATION;\n    } else {\n      allocation \u003d\n          getScheduler().allocate(appAttemptId, ask, release,\n              blacklistAdditions, blacklistRemovals,\n              containerUpdateRequests);\n    }\n\n    if (!blacklistAdditions.isEmpty() || !blacklistRemovals.isEmpty()) {\n      LOG.info(\"blacklist are updated in Scheduler.\" +\n          \"blacklistAdditions: \" + blacklistAdditions + \", \" +\n          \"blacklistRemovals: \" + blacklistRemovals);\n    }\n    RMAppAttempt appAttempt \u003d app.getRMAppAttempt(appAttemptId);\n\n    if (allocation.getNMTokens() !\u003d null \u0026\u0026\n        !allocation.getNMTokens().isEmpty()) {\n      response.setNMTokens(allocation.getNMTokens());\n    }\n\n    // Notify the AM of container update errors\n    ApplicationMasterServiceUtils.addToUpdateContainerErrors(\n        response, updateErrors);\n\n    // update the response with the deltas of node status changes\n    handleNodeUpdates(app, response);\n\n    ApplicationMasterServiceUtils.addToAllocatedContainers(\n        response, allocation.getContainers());\n\n    response.setCompletedContainersStatuses(appAttempt\n        .pullJustFinishedContainers());\n    response.setAvailableResources(allocation.getResourceLimit());\n\n    addToContainerUpdates(response, allocation,\n        ((AbstractYarnScheduler)getScheduler())\n            .getApplicationAttempt(appAttemptId).pullUpdateContainerErrors());\n\n    response.setNumClusterNodes(getScheduler().getNumClusterNodes());\n\n    // add collector address for this application\n    if (YarnConfiguration.timelineServiceV2Enabled(\n        getRmContext().getYarnConfiguration())) {\n      AppCollectorData data \u003d app.getCollectorData();\n      if (data !\u003d null) {\n        response.setCollectorAddr(data.getCollectorAddr());\n      }\n    }\n\n    // add preemption to the allocateResponse message (if any)\n    response.setPreemptionMessage(generatePreemptionMessage(allocation));\n\n    // Set application priority\n    response.setApplicationPriority(app\n        .getApplicationPriority());\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/DefaultAMSProcessor.java",
      "extendedDetails": {}
    },
    "077fcf6a96e420e7f36350931722b8603d010cf1": {
      "type": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
      "commitMessage": "YARN-6777. Support for ApplicationMasterService processing chain of interceptors. (asuresh)\n",
      "commitDate": "19/07/17 12:26 PM",
      "commitName": "077fcf6a96e420e7f36350931722b8603d010cf1",
      "commitAuthor": "Arun Suresh",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-6777. Support for ApplicationMasterService processing chain of interceptors. (asuresh)\n",
          "commitDate": "19/07/17 12:26 PM",
          "commitName": "077fcf6a96e420e7f36350931722b8603d010cf1",
          "commitAuthor": "Arun Suresh",
          "commitDateOld": "10/07/17 2:34 PM",
          "commitNameOld": "5496a34c0cb2b1a83cfa6b0aba5a77b05ff2d8f0",
          "commitAuthorOld": "Arun Suresh",
          "daysBetweenCommits": 8.91,
          "commitsBetweenForRepo": 53,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,136 +1,132 @@\n-  public AllocateResponse allocate(ApplicationAttemptId appAttemptId,\n-      AllocateRequest request) throws YarnException {\n+  public void allocate(ApplicationAttemptId appAttemptId,\n+      AllocateRequest request, AllocateResponse response) throws YarnException {\n \n     handleProgress(appAttemptId, request);\n \n     List\u003cResourceRequest\u003e ask \u003d request.getAskList();\n     List\u003cContainerId\u003e release \u003d request.getReleaseList();\n \n     ResourceBlacklistRequest blacklistRequest \u003d\n         request.getResourceBlacklistRequest();\n     List\u003cString\u003e blacklistAdditions \u003d\n         (blacklistRequest !\u003d null) ?\n             blacklistRequest.getBlacklistAdditions() : Collections.EMPTY_LIST;\n     List\u003cString\u003e blacklistRemovals \u003d\n         (blacklistRequest !\u003d null) ?\n             blacklistRequest.getBlacklistRemovals() : Collections.EMPTY_LIST;\n     RMApp app \u003d\n         getRmContext().getRMApps().get(appAttemptId.getApplicationId());\n \n     // set label expression for Resource Requests if resourceName\u003dANY\n     ApplicationSubmissionContext asc \u003d app.getApplicationSubmissionContext();\n     for (ResourceRequest req : ask) {\n       if (null \u003d\u003d req.getNodeLabelExpression()\n           \u0026\u0026 ResourceRequest.ANY.equals(req.getResourceName())) {\n         req.setNodeLabelExpression(asc.getNodeLabelExpression());\n       }\n     }\n \n     Resource maximumCapacity \u003d getScheduler().getMaximumResourceCapability();\n \n     // sanity check\n     try {\n       RMServerUtils.normalizeAndValidateRequests(ask,\n           maximumCapacity, app.getQueue(),\n           getScheduler(), getRmContext());\n     } catch (InvalidResourceRequestException e) {\n       LOG.warn(\"Invalid resource ask by application \" + appAttemptId, e);\n       throw e;\n     }\n \n     try {\n       RMServerUtils.validateBlacklistRequest(blacklistRequest);\n     }  catch (InvalidResourceBlacklistRequestException e) {\n       LOG.warn(\"Invalid blacklist request by application \" + appAttemptId, e);\n       throw e;\n     }\n \n     // In the case of work-preserving AM restart, it\u0027s possible for the\n     // AM to release containers from the earlier attempt.\n     if (!app.getApplicationSubmissionContext()\n         .getKeepContainersAcrossApplicationAttempts()) {\n       try {\n         RMServerUtils.validateContainerReleaseRequest(release, appAttemptId);\n       } catch (InvalidContainerReleaseException e) {\n         LOG.warn(\"Invalid container release by application \" + appAttemptId,\n             e);\n         throw e;\n       }\n     }\n \n     // Split Update Resource Requests into increase and decrease.\n     // No Exceptions are thrown here. All update errors are aggregated\n     // and returned to the AM.\n     List\u003cUpdateContainerError\u003e updateErrors \u003d new ArrayList\u003c\u003e();\n     ContainerUpdates containerUpdateRequests \u003d\n         RMServerUtils.validateAndSplitUpdateResourceRequests(\n             getRmContext(), request, maximumCapacity, updateErrors);\n \n     // Send new requests to appAttempt.\n     Allocation allocation;\n     RMAppAttemptState state \u003d\n         app.getRMAppAttempt(appAttemptId).getAppAttemptState();\n     if (state.equals(RMAppAttemptState.FINAL_SAVING) ||\n         state.equals(RMAppAttemptState.FINISHING) ||\n         app.isAppFinalStateStored()) {\n       LOG.warn(appAttemptId + \" is in \" + state +\n           \" state, ignore container allocate request.\");\n       allocation \u003d EMPTY_ALLOCATION;\n     } else {\n       allocation \u003d\n           getScheduler().allocate(appAttemptId, ask, release,\n               blacklistAdditions, blacklistRemovals,\n               containerUpdateRequests);\n     }\n \n     if (!blacklistAdditions.isEmpty() || !blacklistRemovals.isEmpty()) {\n       LOG.info(\"blacklist are updated in Scheduler.\" +\n           \"blacklistAdditions: \" + blacklistAdditions + \", \" +\n           \"blacklistRemovals: \" + blacklistRemovals);\n     }\n     RMAppAttempt appAttempt \u003d app.getRMAppAttempt(appAttemptId);\n-    AllocateResponse allocateResponse \u003d\n-        recordFactory.newRecordInstance(AllocateResponse.class);\n \n     if (allocation.getNMTokens() !\u003d null \u0026\u0026\n         !allocation.getNMTokens().isEmpty()) {\n-      allocateResponse.setNMTokens(allocation.getNMTokens());\n+      response.setNMTokens(allocation.getNMTokens());\n     }\n \n     // Notify the AM of container update errors\n     ApplicationMasterServiceUtils.addToUpdateContainerErrors(\n-        allocateResponse, updateErrors);\n+        response, updateErrors);\n \n     // update the response with the deltas of node status changes\n-    handleNodeUpdates(app, allocateResponse);\n+    handleNodeUpdates(app, response);\n \n     ApplicationMasterServiceUtils.addToAllocatedContainers(\n-        allocateResponse, allocation.getContainers());\n+        response, allocation.getContainers());\n \n-    allocateResponse.setCompletedContainersStatuses(appAttempt\n+    response.setCompletedContainersStatuses(appAttempt\n         .pullJustFinishedContainers());\n-    allocateResponse.setAvailableResources(allocation.getResourceLimit());\n+    response.setAvailableResources(allocation.getResourceLimit());\n \n-    addToContainerUpdates(allocateResponse, allocation,\n+    addToContainerUpdates(response, allocation,\n         ((AbstractYarnScheduler)getScheduler())\n             .getApplicationAttempt(appAttemptId).pullUpdateContainerErrors());\n \n-    allocateResponse.setNumClusterNodes(getScheduler().getNumClusterNodes());\n+    response.setNumClusterNodes(getScheduler().getNumClusterNodes());\n \n     // add collector address for this application\n     if (YarnConfiguration.timelineServiceV2Enabled(\n         getRmContext().getYarnConfiguration())) {\n-      allocateResponse.setCollectorAddr(\n+      response.setCollectorAddr(\n           getRmContext().getRMApps().get(appAttemptId.getApplicationId())\n               .getCollectorAddr());\n     }\n \n     // add preemption to the allocateResponse message (if any)\n-    allocateResponse\n-        .setPreemptionMessage(generatePreemptionMessage(allocation));\n+    response.setPreemptionMessage(generatePreemptionMessage(allocation));\n \n     // Set application priority\n-    allocateResponse.setApplicationPriority(app\n+    response.setApplicationPriority(app\n         .getApplicationPriority());\n-    return allocateResponse;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void allocate(ApplicationAttemptId appAttemptId,\n      AllocateRequest request, AllocateResponse response) throws YarnException {\n\n    handleProgress(appAttemptId, request);\n\n    List\u003cResourceRequest\u003e ask \u003d request.getAskList();\n    List\u003cContainerId\u003e release \u003d request.getReleaseList();\n\n    ResourceBlacklistRequest blacklistRequest \u003d\n        request.getResourceBlacklistRequest();\n    List\u003cString\u003e blacklistAdditions \u003d\n        (blacklistRequest !\u003d null) ?\n            blacklistRequest.getBlacklistAdditions() : Collections.EMPTY_LIST;\n    List\u003cString\u003e blacklistRemovals \u003d\n        (blacklistRequest !\u003d null) ?\n            blacklistRequest.getBlacklistRemovals() : Collections.EMPTY_LIST;\n    RMApp app \u003d\n        getRmContext().getRMApps().get(appAttemptId.getApplicationId());\n\n    // set label expression for Resource Requests if resourceName\u003dANY\n    ApplicationSubmissionContext asc \u003d app.getApplicationSubmissionContext();\n    for (ResourceRequest req : ask) {\n      if (null \u003d\u003d req.getNodeLabelExpression()\n          \u0026\u0026 ResourceRequest.ANY.equals(req.getResourceName())) {\n        req.setNodeLabelExpression(asc.getNodeLabelExpression());\n      }\n    }\n\n    Resource maximumCapacity \u003d getScheduler().getMaximumResourceCapability();\n\n    // sanity check\n    try {\n      RMServerUtils.normalizeAndValidateRequests(ask,\n          maximumCapacity, app.getQueue(),\n          getScheduler(), getRmContext());\n    } catch (InvalidResourceRequestException e) {\n      LOG.warn(\"Invalid resource ask by application \" + appAttemptId, e);\n      throw e;\n    }\n\n    try {\n      RMServerUtils.validateBlacklistRequest(blacklistRequest);\n    }  catch (InvalidResourceBlacklistRequestException e) {\n      LOG.warn(\"Invalid blacklist request by application \" + appAttemptId, e);\n      throw e;\n    }\n\n    // In the case of work-preserving AM restart, it\u0027s possible for the\n    // AM to release containers from the earlier attempt.\n    if (!app.getApplicationSubmissionContext()\n        .getKeepContainersAcrossApplicationAttempts()) {\n      try {\n        RMServerUtils.validateContainerReleaseRequest(release, appAttemptId);\n      } catch (InvalidContainerReleaseException e) {\n        LOG.warn(\"Invalid container release by application \" + appAttemptId,\n            e);\n        throw e;\n      }\n    }\n\n    // Split Update Resource Requests into increase and decrease.\n    // No Exceptions are thrown here. All update errors are aggregated\n    // and returned to the AM.\n    List\u003cUpdateContainerError\u003e updateErrors \u003d new ArrayList\u003c\u003e();\n    ContainerUpdates containerUpdateRequests \u003d\n        RMServerUtils.validateAndSplitUpdateResourceRequests(\n            getRmContext(), request, maximumCapacity, updateErrors);\n\n    // Send new requests to appAttempt.\n    Allocation allocation;\n    RMAppAttemptState state \u003d\n        app.getRMAppAttempt(appAttemptId).getAppAttemptState();\n    if (state.equals(RMAppAttemptState.FINAL_SAVING) ||\n        state.equals(RMAppAttemptState.FINISHING) ||\n        app.isAppFinalStateStored()) {\n      LOG.warn(appAttemptId + \" is in \" + state +\n          \" state, ignore container allocate request.\");\n      allocation \u003d EMPTY_ALLOCATION;\n    } else {\n      allocation \u003d\n          getScheduler().allocate(appAttemptId, ask, release,\n              blacklistAdditions, blacklistRemovals,\n              containerUpdateRequests);\n    }\n\n    if (!blacklistAdditions.isEmpty() || !blacklistRemovals.isEmpty()) {\n      LOG.info(\"blacklist are updated in Scheduler.\" +\n          \"blacklistAdditions: \" + blacklistAdditions + \", \" +\n          \"blacklistRemovals: \" + blacklistRemovals);\n    }\n    RMAppAttempt appAttempt \u003d app.getRMAppAttempt(appAttemptId);\n\n    if (allocation.getNMTokens() !\u003d null \u0026\u0026\n        !allocation.getNMTokens().isEmpty()) {\n      response.setNMTokens(allocation.getNMTokens());\n    }\n\n    // Notify the AM of container update errors\n    ApplicationMasterServiceUtils.addToUpdateContainerErrors(\n        response, updateErrors);\n\n    // update the response with the deltas of node status changes\n    handleNodeUpdates(app, response);\n\n    ApplicationMasterServiceUtils.addToAllocatedContainers(\n        response, allocation.getContainers());\n\n    response.setCompletedContainersStatuses(appAttempt\n        .pullJustFinishedContainers());\n    response.setAvailableResources(allocation.getResourceLimit());\n\n    addToContainerUpdates(response, allocation,\n        ((AbstractYarnScheduler)getScheduler())\n            .getApplicationAttempt(appAttemptId).pullUpdateContainerErrors());\n\n    response.setNumClusterNodes(getScheduler().getNumClusterNodes());\n\n    // add collector address for this application\n    if (YarnConfiguration.timelineServiceV2Enabled(\n        getRmContext().getYarnConfiguration())) {\n      response.setCollectorAddr(\n          getRmContext().getRMApps().get(appAttemptId.getApplicationId())\n              .getCollectorAddr());\n    }\n\n    // add preemption to the allocateResponse message (if any)\n    response.setPreemptionMessage(generatePreemptionMessage(allocation));\n\n    // Set application priority\n    response.setApplicationPriority(app\n        .getApplicationPriority());\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/DefaultAMSProcessor.java",
          "extendedDetails": {
            "oldValue": "[appAttemptId-ApplicationAttemptId, request-AllocateRequest]",
            "newValue": "[appAttemptId-ApplicationAttemptId, request-AllocateRequest, response-AllocateResponse]"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "YARN-6777. Support for ApplicationMasterService processing chain of interceptors. (asuresh)\n",
          "commitDate": "19/07/17 12:26 PM",
          "commitName": "077fcf6a96e420e7f36350931722b8603d010cf1",
          "commitAuthor": "Arun Suresh",
          "commitDateOld": "10/07/17 2:34 PM",
          "commitNameOld": "5496a34c0cb2b1a83cfa6b0aba5a77b05ff2d8f0",
          "commitAuthorOld": "Arun Suresh",
          "daysBetweenCommits": 8.91,
          "commitsBetweenForRepo": 53,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,136 +1,132 @@\n-  public AllocateResponse allocate(ApplicationAttemptId appAttemptId,\n-      AllocateRequest request) throws YarnException {\n+  public void allocate(ApplicationAttemptId appAttemptId,\n+      AllocateRequest request, AllocateResponse response) throws YarnException {\n \n     handleProgress(appAttemptId, request);\n \n     List\u003cResourceRequest\u003e ask \u003d request.getAskList();\n     List\u003cContainerId\u003e release \u003d request.getReleaseList();\n \n     ResourceBlacklistRequest blacklistRequest \u003d\n         request.getResourceBlacklistRequest();\n     List\u003cString\u003e blacklistAdditions \u003d\n         (blacklistRequest !\u003d null) ?\n             blacklistRequest.getBlacklistAdditions() : Collections.EMPTY_LIST;\n     List\u003cString\u003e blacklistRemovals \u003d\n         (blacklistRequest !\u003d null) ?\n             blacklistRequest.getBlacklistRemovals() : Collections.EMPTY_LIST;\n     RMApp app \u003d\n         getRmContext().getRMApps().get(appAttemptId.getApplicationId());\n \n     // set label expression for Resource Requests if resourceName\u003dANY\n     ApplicationSubmissionContext asc \u003d app.getApplicationSubmissionContext();\n     for (ResourceRequest req : ask) {\n       if (null \u003d\u003d req.getNodeLabelExpression()\n           \u0026\u0026 ResourceRequest.ANY.equals(req.getResourceName())) {\n         req.setNodeLabelExpression(asc.getNodeLabelExpression());\n       }\n     }\n \n     Resource maximumCapacity \u003d getScheduler().getMaximumResourceCapability();\n \n     // sanity check\n     try {\n       RMServerUtils.normalizeAndValidateRequests(ask,\n           maximumCapacity, app.getQueue(),\n           getScheduler(), getRmContext());\n     } catch (InvalidResourceRequestException e) {\n       LOG.warn(\"Invalid resource ask by application \" + appAttemptId, e);\n       throw e;\n     }\n \n     try {\n       RMServerUtils.validateBlacklistRequest(blacklistRequest);\n     }  catch (InvalidResourceBlacklistRequestException e) {\n       LOG.warn(\"Invalid blacklist request by application \" + appAttemptId, e);\n       throw e;\n     }\n \n     // In the case of work-preserving AM restart, it\u0027s possible for the\n     // AM to release containers from the earlier attempt.\n     if (!app.getApplicationSubmissionContext()\n         .getKeepContainersAcrossApplicationAttempts()) {\n       try {\n         RMServerUtils.validateContainerReleaseRequest(release, appAttemptId);\n       } catch (InvalidContainerReleaseException e) {\n         LOG.warn(\"Invalid container release by application \" + appAttemptId,\n             e);\n         throw e;\n       }\n     }\n \n     // Split Update Resource Requests into increase and decrease.\n     // No Exceptions are thrown here. All update errors are aggregated\n     // and returned to the AM.\n     List\u003cUpdateContainerError\u003e updateErrors \u003d new ArrayList\u003c\u003e();\n     ContainerUpdates containerUpdateRequests \u003d\n         RMServerUtils.validateAndSplitUpdateResourceRequests(\n             getRmContext(), request, maximumCapacity, updateErrors);\n \n     // Send new requests to appAttempt.\n     Allocation allocation;\n     RMAppAttemptState state \u003d\n         app.getRMAppAttempt(appAttemptId).getAppAttemptState();\n     if (state.equals(RMAppAttemptState.FINAL_SAVING) ||\n         state.equals(RMAppAttemptState.FINISHING) ||\n         app.isAppFinalStateStored()) {\n       LOG.warn(appAttemptId + \" is in \" + state +\n           \" state, ignore container allocate request.\");\n       allocation \u003d EMPTY_ALLOCATION;\n     } else {\n       allocation \u003d\n           getScheduler().allocate(appAttemptId, ask, release,\n               blacklistAdditions, blacklistRemovals,\n               containerUpdateRequests);\n     }\n \n     if (!blacklistAdditions.isEmpty() || !blacklistRemovals.isEmpty()) {\n       LOG.info(\"blacklist are updated in Scheduler.\" +\n           \"blacklistAdditions: \" + blacklistAdditions + \", \" +\n           \"blacklistRemovals: \" + blacklistRemovals);\n     }\n     RMAppAttempt appAttempt \u003d app.getRMAppAttempt(appAttemptId);\n-    AllocateResponse allocateResponse \u003d\n-        recordFactory.newRecordInstance(AllocateResponse.class);\n \n     if (allocation.getNMTokens() !\u003d null \u0026\u0026\n         !allocation.getNMTokens().isEmpty()) {\n-      allocateResponse.setNMTokens(allocation.getNMTokens());\n+      response.setNMTokens(allocation.getNMTokens());\n     }\n \n     // Notify the AM of container update errors\n     ApplicationMasterServiceUtils.addToUpdateContainerErrors(\n-        allocateResponse, updateErrors);\n+        response, updateErrors);\n \n     // update the response with the deltas of node status changes\n-    handleNodeUpdates(app, allocateResponse);\n+    handleNodeUpdates(app, response);\n \n     ApplicationMasterServiceUtils.addToAllocatedContainers(\n-        allocateResponse, allocation.getContainers());\n+        response, allocation.getContainers());\n \n-    allocateResponse.setCompletedContainersStatuses(appAttempt\n+    response.setCompletedContainersStatuses(appAttempt\n         .pullJustFinishedContainers());\n-    allocateResponse.setAvailableResources(allocation.getResourceLimit());\n+    response.setAvailableResources(allocation.getResourceLimit());\n \n-    addToContainerUpdates(allocateResponse, allocation,\n+    addToContainerUpdates(response, allocation,\n         ((AbstractYarnScheduler)getScheduler())\n             .getApplicationAttempt(appAttemptId).pullUpdateContainerErrors());\n \n-    allocateResponse.setNumClusterNodes(getScheduler().getNumClusterNodes());\n+    response.setNumClusterNodes(getScheduler().getNumClusterNodes());\n \n     // add collector address for this application\n     if (YarnConfiguration.timelineServiceV2Enabled(\n         getRmContext().getYarnConfiguration())) {\n-      allocateResponse.setCollectorAddr(\n+      response.setCollectorAddr(\n           getRmContext().getRMApps().get(appAttemptId.getApplicationId())\n               .getCollectorAddr());\n     }\n \n     // add preemption to the allocateResponse message (if any)\n-    allocateResponse\n-        .setPreemptionMessage(generatePreemptionMessage(allocation));\n+    response.setPreemptionMessage(generatePreemptionMessage(allocation));\n \n     // Set application priority\n-    allocateResponse.setApplicationPriority(app\n+    response.setApplicationPriority(app\n         .getApplicationPriority());\n-    return allocateResponse;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void allocate(ApplicationAttemptId appAttemptId,\n      AllocateRequest request, AllocateResponse response) throws YarnException {\n\n    handleProgress(appAttemptId, request);\n\n    List\u003cResourceRequest\u003e ask \u003d request.getAskList();\n    List\u003cContainerId\u003e release \u003d request.getReleaseList();\n\n    ResourceBlacklistRequest blacklistRequest \u003d\n        request.getResourceBlacklistRequest();\n    List\u003cString\u003e blacklistAdditions \u003d\n        (blacklistRequest !\u003d null) ?\n            blacklistRequest.getBlacklistAdditions() : Collections.EMPTY_LIST;\n    List\u003cString\u003e blacklistRemovals \u003d\n        (blacklistRequest !\u003d null) ?\n            blacklistRequest.getBlacklistRemovals() : Collections.EMPTY_LIST;\n    RMApp app \u003d\n        getRmContext().getRMApps().get(appAttemptId.getApplicationId());\n\n    // set label expression for Resource Requests if resourceName\u003dANY\n    ApplicationSubmissionContext asc \u003d app.getApplicationSubmissionContext();\n    for (ResourceRequest req : ask) {\n      if (null \u003d\u003d req.getNodeLabelExpression()\n          \u0026\u0026 ResourceRequest.ANY.equals(req.getResourceName())) {\n        req.setNodeLabelExpression(asc.getNodeLabelExpression());\n      }\n    }\n\n    Resource maximumCapacity \u003d getScheduler().getMaximumResourceCapability();\n\n    // sanity check\n    try {\n      RMServerUtils.normalizeAndValidateRequests(ask,\n          maximumCapacity, app.getQueue(),\n          getScheduler(), getRmContext());\n    } catch (InvalidResourceRequestException e) {\n      LOG.warn(\"Invalid resource ask by application \" + appAttemptId, e);\n      throw e;\n    }\n\n    try {\n      RMServerUtils.validateBlacklistRequest(blacklistRequest);\n    }  catch (InvalidResourceBlacklistRequestException e) {\n      LOG.warn(\"Invalid blacklist request by application \" + appAttemptId, e);\n      throw e;\n    }\n\n    // In the case of work-preserving AM restart, it\u0027s possible for the\n    // AM to release containers from the earlier attempt.\n    if (!app.getApplicationSubmissionContext()\n        .getKeepContainersAcrossApplicationAttempts()) {\n      try {\n        RMServerUtils.validateContainerReleaseRequest(release, appAttemptId);\n      } catch (InvalidContainerReleaseException e) {\n        LOG.warn(\"Invalid container release by application \" + appAttemptId,\n            e);\n        throw e;\n      }\n    }\n\n    // Split Update Resource Requests into increase and decrease.\n    // No Exceptions are thrown here. All update errors are aggregated\n    // and returned to the AM.\n    List\u003cUpdateContainerError\u003e updateErrors \u003d new ArrayList\u003c\u003e();\n    ContainerUpdates containerUpdateRequests \u003d\n        RMServerUtils.validateAndSplitUpdateResourceRequests(\n            getRmContext(), request, maximumCapacity, updateErrors);\n\n    // Send new requests to appAttempt.\n    Allocation allocation;\n    RMAppAttemptState state \u003d\n        app.getRMAppAttempt(appAttemptId).getAppAttemptState();\n    if (state.equals(RMAppAttemptState.FINAL_SAVING) ||\n        state.equals(RMAppAttemptState.FINISHING) ||\n        app.isAppFinalStateStored()) {\n      LOG.warn(appAttemptId + \" is in \" + state +\n          \" state, ignore container allocate request.\");\n      allocation \u003d EMPTY_ALLOCATION;\n    } else {\n      allocation \u003d\n          getScheduler().allocate(appAttemptId, ask, release,\n              blacklistAdditions, blacklistRemovals,\n              containerUpdateRequests);\n    }\n\n    if (!blacklistAdditions.isEmpty() || !blacklistRemovals.isEmpty()) {\n      LOG.info(\"blacklist are updated in Scheduler.\" +\n          \"blacklistAdditions: \" + blacklistAdditions + \", \" +\n          \"blacklistRemovals: \" + blacklistRemovals);\n    }\n    RMAppAttempt appAttempt \u003d app.getRMAppAttempt(appAttemptId);\n\n    if (allocation.getNMTokens() !\u003d null \u0026\u0026\n        !allocation.getNMTokens().isEmpty()) {\n      response.setNMTokens(allocation.getNMTokens());\n    }\n\n    // Notify the AM of container update errors\n    ApplicationMasterServiceUtils.addToUpdateContainerErrors(\n        response, updateErrors);\n\n    // update the response with the deltas of node status changes\n    handleNodeUpdates(app, response);\n\n    ApplicationMasterServiceUtils.addToAllocatedContainers(\n        response, allocation.getContainers());\n\n    response.setCompletedContainersStatuses(appAttempt\n        .pullJustFinishedContainers());\n    response.setAvailableResources(allocation.getResourceLimit());\n\n    addToContainerUpdates(response, allocation,\n        ((AbstractYarnScheduler)getScheduler())\n            .getApplicationAttempt(appAttemptId).pullUpdateContainerErrors());\n\n    response.setNumClusterNodes(getScheduler().getNumClusterNodes());\n\n    // add collector address for this application\n    if (YarnConfiguration.timelineServiceV2Enabled(\n        getRmContext().getYarnConfiguration())) {\n      response.setCollectorAddr(\n          getRmContext().getRMApps().get(appAttemptId.getApplicationId())\n              .getCollectorAddr());\n    }\n\n    // add preemption to the allocateResponse message (if any)\n    response.setPreemptionMessage(generatePreemptionMessage(allocation));\n\n    // Set application priority\n    response.setApplicationPriority(app\n        .getApplicationPriority());\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/DefaultAMSProcessor.java",
          "extendedDetails": {
            "oldValue": "AllocateResponse",
            "newValue": "void"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-6777. Support for ApplicationMasterService processing chain of interceptors. (asuresh)\n",
          "commitDate": "19/07/17 12:26 PM",
          "commitName": "077fcf6a96e420e7f36350931722b8603d010cf1",
          "commitAuthor": "Arun Suresh",
          "commitDateOld": "10/07/17 2:34 PM",
          "commitNameOld": "5496a34c0cb2b1a83cfa6b0aba5a77b05ff2d8f0",
          "commitAuthorOld": "Arun Suresh",
          "daysBetweenCommits": 8.91,
          "commitsBetweenForRepo": 53,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,136 +1,132 @@\n-  public AllocateResponse allocate(ApplicationAttemptId appAttemptId,\n-      AllocateRequest request) throws YarnException {\n+  public void allocate(ApplicationAttemptId appAttemptId,\n+      AllocateRequest request, AllocateResponse response) throws YarnException {\n \n     handleProgress(appAttemptId, request);\n \n     List\u003cResourceRequest\u003e ask \u003d request.getAskList();\n     List\u003cContainerId\u003e release \u003d request.getReleaseList();\n \n     ResourceBlacklistRequest blacklistRequest \u003d\n         request.getResourceBlacklistRequest();\n     List\u003cString\u003e blacklistAdditions \u003d\n         (blacklistRequest !\u003d null) ?\n             blacklistRequest.getBlacklistAdditions() : Collections.EMPTY_LIST;\n     List\u003cString\u003e blacklistRemovals \u003d\n         (blacklistRequest !\u003d null) ?\n             blacklistRequest.getBlacklistRemovals() : Collections.EMPTY_LIST;\n     RMApp app \u003d\n         getRmContext().getRMApps().get(appAttemptId.getApplicationId());\n \n     // set label expression for Resource Requests if resourceName\u003dANY\n     ApplicationSubmissionContext asc \u003d app.getApplicationSubmissionContext();\n     for (ResourceRequest req : ask) {\n       if (null \u003d\u003d req.getNodeLabelExpression()\n           \u0026\u0026 ResourceRequest.ANY.equals(req.getResourceName())) {\n         req.setNodeLabelExpression(asc.getNodeLabelExpression());\n       }\n     }\n \n     Resource maximumCapacity \u003d getScheduler().getMaximumResourceCapability();\n \n     // sanity check\n     try {\n       RMServerUtils.normalizeAndValidateRequests(ask,\n           maximumCapacity, app.getQueue(),\n           getScheduler(), getRmContext());\n     } catch (InvalidResourceRequestException e) {\n       LOG.warn(\"Invalid resource ask by application \" + appAttemptId, e);\n       throw e;\n     }\n \n     try {\n       RMServerUtils.validateBlacklistRequest(blacklistRequest);\n     }  catch (InvalidResourceBlacklistRequestException e) {\n       LOG.warn(\"Invalid blacklist request by application \" + appAttemptId, e);\n       throw e;\n     }\n \n     // In the case of work-preserving AM restart, it\u0027s possible for the\n     // AM to release containers from the earlier attempt.\n     if (!app.getApplicationSubmissionContext()\n         .getKeepContainersAcrossApplicationAttempts()) {\n       try {\n         RMServerUtils.validateContainerReleaseRequest(release, appAttemptId);\n       } catch (InvalidContainerReleaseException e) {\n         LOG.warn(\"Invalid container release by application \" + appAttemptId,\n             e);\n         throw e;\n       }\n     }\n \n     // Split Update Resource Requests into increase and decrease.\n     // No Exceptions are thrown here. All update errors are aggregated\n     // and returned to the AM.\n     List\u003cUpdateContainerError\u003e updateErrors \u003d new ArrayList\u003c\u003e();\n     ContainerUpdates containerUpdateRequests \u003d\n         RMServerUtils.validateAndSplitUpdateResourceRequests(\n             getRmContext(), request, maximumCapacity, updateErrors);\n \n     // Send new requests to appAttempt.\n     Allocation allocation;\n     RMAppAttemptState state \u003d\n         app.getRMAppAttempt(appAttemptId).getAppAttemptState();\n     if (state.equals(RMAppAttemptState.FINAL_SAVING) ||\n         state.equals(RMAppAttemptState.FINISHING) ||\n         app.isAppFinalStateStored()) {\n       LOG.warn(appAttemptId + \" is in \" + state +\n           \" state, ignore container allocate request.\");\n       allocation \u003d EMPTY_ALLOCATION;\n     } else {\n       allocation \u003d\n           getScheduler().allocate(appAttemptId, ask, release,\n               blacklistAdditions, blacklistRemovals,\n               containerUpdateRequests);\n     }\n \n     if (!blacklistAdditions.isEmpty() || !blacklistRemovals.isEmpty()) {\n       LOG.info(\"blacklist are updated in Scheduler.\" +\n           \"blacklistAdditions: \" + blacklistAdditions + \", \" +\n           \"blacklistRemovals: \" + blacklistRemovals);\n     }\n     RMAppAttempt appAttempt \u003d app.getRMAppAttempt(appAttemptId);\n-    AllocateResponse allocateResponse \u003d\n-        recordFactory.newRecordInstance(AllocateResponse.class);\n \n     if (allocation.getNMTokens() !\u003d null \u0026\u0026\n         !allocation.getNMTokens().isEmpty()) {\n-      allocateResponse.setNMTokens(allocation.getNMTokens());\n+      response.setNMTokens(allocation.getNMTokens());\n     }\n \n     // Notify the AM of container update errors\n     ApplicationMasterServiceUtils.addToUpdateContainerErrors(\n-        allocateResponse, updateErrors);\n+        response, updateErrors);\n \n     // update the response with the deltas of node status changes\n-    handleNodeUpdates(app, allocateResponse);\n+    handleNodeUpdates(app, response);\n \n     ApplicationMasterServiceUtils.addToAllocatedContainers(\n-        allocateResponse, allocation.getContainers());\n+        response, allocation.getContainers());\n \n-    allocateResponse.setCompletedContainersStatuses(appAttempt\n+    response.setCompletedContainersStatuses(appAttempt\n         .pullJustFinishedContainers());\n-    allocateResponse.setAvailableResources(allocation.getResourceLimit());\n+    response.setAvailableResources(allocation.getResourceLimit());\n \n-    addToContainerUpdates(allocateResponse, allocation,\n+    addToContainerUpdates(response, allocation,\n         ((AbstractYarnScheduler)getScheduler())\n             .getApplicationAttempt(appAttemptId).pullUpdateContainerErrors());\n \n-    allocateResponse.setNumClusterNodes(getScheduler().getNumClusterNodes());\n+    response.setNumClusterNodes(getScheduler().getNumClusterNodes());\n \n     // add collector address for this application\n     if (YarnConfiguration.timelineServiceV2Enabled(\n         getRmContext().getYarnConfiguration())) {\n-      allocateResponse.setCollectorAddr(\n+      response.setCollectorAddr(\n           getRmContext().getRMApps().get(appAttemptId.getApplicationId())\n               .getCollectorAddr());\n     }\n \n     // add preemption to the allocateResponse message (if any)\n-    allocateResponse\n-        .setPreemptionMessage(generatePreemptionMessage(allocation));\n+    response.setPreemptionMessage(generatePreemptionMessage(allocation));\n \n     // Set application priority\n-    allocateResponse.setApplicationPriority(app\n+    response.setApplicationPriority(app\n         .getApplicationPriority());\n-    return allocateResponse;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void allocate(ApplicationAttemptId appAttemptId,\n      AllocateRequest request, AllocateResponse response) throws YarnException {\n\n    handleProgress(appAttemptId, request);\n\n    List\u003cResourceRequest\u003e ask \u003d request.getAskList();\n    List\u003cContainerId\u003e release \u003d request.getReleaseList();\n\n    ResourceBlacklistRequest blacklistRequest \u003d\n        request.getResourceBlacklistRequest();\n    List\u003cString\u003e blacklistAdditions \u003d\n        (blacklistRequest !\u003d null) ?\n            blacklistRequest.getBlacklistAdditions() : Collections.EMPTY_LIST;\n    List\u003cString\u003e blacklistRemovals \u003d\n        (blacklistRequest !\u003d null) ?\n            blacklistRequest.getBlacklistRemovals() : Collections.EMPTY_LIST;\n    RMApp app \u003d\n        getRmContext().getRMApps().get(appAttemptId.getApplicationId());\n\n    // set label expression for Resource Requests if resourceName\u003dANY\n    ApplicationSubmissionContext asc \u003d app.getApplicationSubmissionContext();\n    for (ResourceRequest req : ask) {\n      if (null \u003d\u003d req.getNodeLabelExpression()\n          \u0026\u0026 ResourceRequest.ANY.equals(req.getResourceName())) {\n        req.setNodeLabelExpression(asc.getNodeLabelExpression());\n      }\n    }\n\n    Resource maximumCapacity \u003d getScheduler().getMaximumResourceCapability();\n\n    // sanity check\n    try {\n      RMServerUtils.normalizeAndValidateRequests(ask,\n          maximumCapacity, app.getQueue(),\n          getScheduler(), getRmContext());\n    } catch (InvalidResourceRequestException e) {\n      LOG.warn(\"Invalid resource ask by application \" + appAttemptId, e);\n      throw e;\n    }\n\n    try {\n      RMServerUtils.validateBlacklistRequest(blacklistRequest);\n    }  catch (InvalidResourceBlacklistRequestException e) {\n      LOG.warn(\"Invalid blacklist request by application \" + appAttemptId, e);\n      throw e;\n    }\n\n    // In the case of work-preserving AM restart, it\u0027s possible for the\n    // AM to release containers from the earlier attempt.\n    if (!app.getApplicationSubmissionContext()\n        .getKeepContainersAcrossApplicationAttempts()) {\n      try {\n        RMServerUtils.validateContainerReleaseRequest(release, appAttemptId);\n      } catch (InvalidContainerReleaseException e) {\n        LOG.warn(\"Invalid container release by application \" + appAttemptId,\n            e);\n        throw e;\n      }\n    }\n\n    // Split Update Resource Requests into increase and decrease.\n    // No Exceptions are thrown here. All update errors are aggregated\n    // and returned to the AM.\n    List\u003cUpdateContainerError\u003e updateErrors \u003d new ArrayList\u003c\u003e();\n    ContainerUpdates containerUpdateRequests \u003d\n        RMServerUtils.validateAndSplitUpdateResourceRequests(\n            getRmContext(), request, maximumCapacity, updateErrors);\n\n    // Send new requests to appAttempt.\n    Allocation allocation;\n    RMAppAttemptState state \u003d\n        app.getRMAppAttempt(appAttemptId).getAppAttemptState();\n    if (state.equals(RMAppAttemptState.FINAL_SAVING) ||\n        state.equals(RMAppAttemptState.FINISHING) ||\n        app.isAppFinalStateStored()) {\n      LOG.warn(appAttemptId + \" is in \" + state +\n          \" state, ignore container allocate request.\");\n      allocation \u003d EMPTY_ALLOCATION;\n    } else {\n      allocation \u003d\n          getScheduler().allocate(appAttemptId, ask, release,\n              blacklistAdditions, blacklistRemovals,\n              containerUpdateRequests);\n    }\n\n    if (!blacklistAdditions.isEmpty() || !blacklistRemovals.isEmpty()) {\n      LOG.info(\"blacklist are updated in Scheduler.\" +\n          \"blacklistAdditions: \" + blacklistAdditions + \", \" +\n          \"blacklistRemovals: \" + blacklistRemovals);\n    }\n    RMAppAttempt appAttempt \u003d app.getRMAppAttempt(appAttemptId);\n\n    if (allocation.getNMTokens() !\u003d null \u0026\u0026\n        !allocation.getNMTokens().isEmpty()) {\n      response.setNMTokens(allocation.getNMTokens());\n    }\n\n    // Notify the AM of container update errors\n    ApplicationMasterServiceUtils.addToUpdateContainerErrors(\n        response, updateErrors);\n\n    // update the response with the deltas of node status changes\n    handleNodeUpdates(app, response);\n\n    ApplicationMasterServiceUtils.addToAllocatedContainers(\n        response, allocation.getContainers());\n\n    response.setCompletedContainersStatuses(appAttempt\n        .pullJustFinishedContainers());\n    response.setAvailableResources(allocation.getResourceLimit());\n\n    addToContainerUpdates(response, allocation,\n        ((AbstractYarnScheduler)getScheduler())\n            .getApplicationAttempt(appAttemptId).pullUpdateContainerErrors());\n\n    response.setNumClusterNodes(getScheduler().getNumClusterNodes());\n\n    // add collector address for this application\n    if (YarnConfiguration.timelineServiceV2Enabled(\n        getRmContext().getYarnConfiguration())) {\n      response.setCollectorAddr(\n          getRmContext().getRMApps().get(appAttemptId.getApplicationId())\n              .getCollectorAddr());\n    }\n\n    // add preemption to the allocateResponse message (if any)\n    response.setPreemptionMessage(generatePreemptionMessage(allocation));\n\n    // Set application priority\n    response.setApplicationPriority(app\n        .getApplicationPriority());\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/DefaultAMSProcessor.java",
          "extendedDetails": {}
        }
      ]
    },
    "5496a34c0cb2b1a83cfa6b0aba5a77b05ff2d8f0": {
      "type": "Ymultichange(Ymovefromfile,Yreturntypechange,Ymodifierchange,Ybodychange,Yrename,Yparameterchange)",
      "commitMessage": "YARN-6776. Refactor ApplicaitonMasterService to move actual processing logic to a separate class. (asuresh)\n",
      "commitDate": "10/07/17 2:34 PM",
      "commitName": "5496a34c0cb2b1a83cfa6b0aba5a77b05ff2d8f0",
      "commitAuthor": "Arun Suresh",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "YARN-6776. Refactor ApplicaitonMasterService to move actual processing logic to a separate class. (asuresh)\n",
          "commitDate": "10/07/17 2:34 PM",
          "commitName": "5496a34c0cb2b1a83cfa6b0aba5a77b05ff2d8f0",
          "commitAuthor": "Arun Suresh",
          "commitDateOld": "10/07/17 3:53 AM",
          "commitNameOld": "09653ea098a17fddcf111b0da289085915c351d1",
          "commitAuthorOld": "Steve Loughran",
          "daysBetweenCommits": 0.45,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,166 +1,136 @@\n-  protected void allocateInternal(ApplicationAttemptId appAttemptId,\n-      AllocateRequest request, AllocateResponse allocateResponse)\n-      throws YarnException {\n+  public AllocateResponse allocate(ApplicationAttemptId appAttemptId,\n+      AllocateRequest request) throws YarnException {\n \n-    //filter illegal progress values\n-    float filteredProgress \u003d request.getProgress();\n-    if (Float.isNaN(filteredProgress) ||\n-        filteredProgress \u003d\u003d Float.NEGATIVE_INFINITY ||\n-        filteredProgress \u003c 0) {\n-      request.setProgress(0);\n-    } else if (filteredProgress \u003e 1 ||\n-        filteredProgress \u003d\u003d Float.POSITIVE_INFINITY) {\n-      request.setProgress(1);\n-    }\n-\n-    // Send the status update to the appAttempt.\n-    this.rmContext.getDispatcher().getEventHandler().handle(\n-        new RMAppAttemptStatusupdateEvent(appAttemptId, request\n-            .getProgress()));\n+    handleProgress(appAttemptId, request);\n \n     List\u003cResourceRequest\u003e ask \u003d request.getAskList();\n     List\u003cContainerId\u003e release \u003d request.getReleaseList();\n \n     ResourceBlacklistRequest blacklistRequest \u003d\n         request.getResourceBlacklistRequest();\n     List\u003cString\u003e blacklistAdditions \u003d\n         (blacklistRequest !\u003d null) ?\n             blacklistRequest.getBlacklistAdditions() : Collections.EMPTY_LIST;\n     List\u003cString\u003e blacklistRemovals \u003d\n         (blacklistRequest !\u003d null) ?\n             blacklistRequest.getBlacklistRemovals() : Collections.EMPTY_LIST;\n     RMApp app \u003d\n-        this.rmContext.getRMApps().get(appAttemptId.getApplicationId());\n+        getRmContext().getRMApps().get(appAttemptId.getApplicationId());\n \n     // set label expression for Resource Requests if resourceName\u003dANY\n     ApplicationSubmissionContext asc \u003d app.getApplicationSubmissionContext();\n     for (ResourceRequest req : ask) {\n       if (null \u003d\u003d req.getNodeLabelExpression()\n           \u0026\u0026 ResourceRequest.ANY.equals(req.getResourceName())) {\n         req.setNodeLabelExpression(asc.getNodeLabelExpression());\n       }\n     }\n \n-    Resource maximumCapacity \u003d rScheduler.getMaximumResourceCapability();\n+    Resource maximumCapacity \u003d getScheduler().getMaximumResourceCapability();\n \n     // sanity check\n     try {\n       RMServerUtils.normalizeAndValidateRequests(ask,\n           maximumCapacity, app.getQueue(),\n-          rScheduler, rmContext);\n+          getScheduler(), getRmContext());\n     } catch (InvalidResourceRequestException e) {\n       LOG.warn(\"Invalid resource ask by application \" + appAttemptId, e);\n       throw e;\n     }\n \n     try {\n       RMServerUtils.validateBlacklistRequest(blacklistRequest);\n     }  catch (InvalidResourceBlacklistRequestException e) {\n       LOG.warn(\"Invalid blacklist request by application \" + appAttemptId, e);\n       throw e;\n     }\n \n     // In the case of work-preserving AM restart, it\u0027s possible for the\n     // AM to release containers from the earlier attempt.\n     if (!app.getApplicationSubmissionContext()\n         .getKeepContainersAcrossApplicationAttempts()) {\n       try {\n         RMServerUtils.validateContainerReleaseRequest(release, appAttemptId);\n       } catch (InvalidContainerReleaseException e) {\n         LOG.warn(\"Invalid container release by application \" + appAttemptId,\n             e);\n         throw e;\n       }\n     }\n \n     // Split Update Resource Requests into increase and decrease.\n     // No Exceptions are thrown here. All update errors are aggregated\n     // and returned to the AM.\n     List\u003cUpdateContainerError\u003e updateErrors \u003d new ArrayList\u003c\u003e();\n     ContainerUpdates containerUpdateRequests \u003d\n         RMServerUtils.validateAndSplitUpdateResourceRequests(\n-        rmContext, request, maximumCapacity, updateErrors);\n+            getRmContext(), request, maximumCapacity, updateErrors);\n \n     // Send new requests to appAttempt.\n     Allocation allocation;\n     RMAppAttemptState state \u003d\n         app.getRMAppAttempt(appAttemptId).getAppAttemptState();\n     if (state.equals(RMAppAttemptState.FINAL_SAVING) ||\n         state.equals(RMAppAttemptState.FINISHING) ||\n         app.isAppFinalStateStored()) {\n       LOG.warn(appAttemptId + \" is in \" + state +\n-               \" state, ignore container allocate request.\");\n+          \" state, ignore container allocate request.\");\n       allocation \u003d EMPTY_ALLOCATION;\n     } else {\n       allocation \u003d\n-          this.rScheduler.allocate(appAttemptId, ask, release,\n+          getScheduler().allocate(appAttemptId, ask, release,\n               blacklistAdditions, blacklistRemovals,\n               containerUpdateRequests);\n     }\n \n     if (!blacklistAdditions.isEmpty() || !blacklistRemovals.isEmpty()) {\n       LOG.info(\"blacklist are updated in Scheduler.\" +\n           \"blacklistAdditions: \" + blacklistAdditions + \", \" +\n           \"blacklistRemovals: \" + blacklistRemovals);\n     }\n     RMAppAttempt appAttempt \u003d app.getRMAppAttempt(appAttemptId);\n+    AllocateResponse allocateResponse \u003d\n+        recordFactory.newRecordInstance(AllocateResponse.class);\n \n     if (allocation.getNMTokens() !\u003d null \u0026\u0026\n         !allocation.getNMTokens().isEmpty()) {\n       allocateResponse.setNMTokens(allocation.getNMTokens());\n     }\n \n     // Notify the AM of container update errors\n-    addToUpdateContainerErrors(allocateResponse, updateErrors);\n+    ApplicationMasterServiceUtils.addToUpdateContainerErrors(\n+        allocateResponse, updateErrors);\n \n     // update the response with the deltas of node status changes\n-    List\u003cRMNode\u003e updatedNodes \u003d new ArrayList\u003cRMNode\u003e();\n-    if(app.pullRMNodeUpdates(updatedNodes) \u003e 0) {\n-      List\u003cNodeReport\u003e updatedNodeReports \u003d new ArrayList\u003cNodeReport\u003e();\n-      for(RMNode rmNode: updatedNodes) {\n-        SchedulerNodeReport schedulerNodeReport \u003d\n-            rScheduler.getNodeReport(rmNode.getNodeID());\n-        Resource used \u003d BuilderUtils.newResource(0, 0);\n-        int numContainers \u003d 0;\n-        if (schedulerNodeReport !\u003d null) {\n-          used \u003d schedulerNodeReport.getUsedResource();\n-          numContainers \u003d schedulerNodeReport.getNumContainers();\n-        }\n-        NodeId nodeId \u003d rmNode.getNodeID();\n-        NodeReport report \u003d\n-            BuilderUtils.newNodeReport(nodeId, rmNode.getState(),\n-                rmNode.getHttpAddress(), rmNode.getRackName(), used,\n-                rmNode.getTotalCapability(), numContainers,\n-                rmNode.getHealthReport(), rmNode.getLastHealthReportTime(),\n-                rmNode.getNodeLabels());\n+    handleNodeUpdates(app, allocateResponse);\n \n-        updatedNodeReports.add(report);\n-      }\n-      allocateResponse.setUpdatedNodes(updatedNodeReports);\n-    }\n-\n-    addToAllocatedContainers(allocateResponse, allocation.getContainers());\n+    ApplicationMasterServiceUtils.addToAllocatedContainers(\n+        allocateResponse, allocation.getContainers());\n \n     allocateResponse.setCompletedContainersStatuses(appAttempt\n         .pullJustFinishedContainers());\n     allocateResponse.setAvailableResources(allocation.getResourceLimit());\n \n-    addToContainerUpdates(appAttemptId, allocateResponse, allocation);\n+    addToContainerUpdates(allocateResponse, allocation,\n+        ((AbstractYarnScheduler)getScheduler())\n+            .getApplicationAttempt(appAttemptId).pullUpdateContainerErrors());\n \n-    allocateResponse.setNumClusterNodes(this.rScheduler.getNumClusterNodes());\n+    allocateResponse.setNumClusterNodes(getScheduler().getNumClusterNodes());\n \n     // add collector address for this application\n-    if (YarnConfiguration.timelineServiceV2Enabled(getConfig())) {\n+    if (YarnConfiguration.timelineServiceV2Enabled(\n+        getRmContext().getYarnConfiguration())) {\n       allocateResponse.setCollectorAddr(\n-          this.rmContext.getRMApps().get(appAttemptId.getApplicationId())\n+          getRmContext().getRMApps().get(appAttemptId.getApplicationId())\n               .getCollectorAddr());\n     }\n \n     // add preemption to the allocateResponse message (if any)\n     allocateResponse\n         .setPreemptionMessage(generatePreemptionMessage(allocation));\n \n     // Set application priority\n     allocateResponse.setApplicationPriority(app\n         .getApplicationPriority());\n+    return allocateResponse;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public AllocateResponse allocate(ApplicationAttemptId appAttemptId,\n      AllocateRequest request) throws YarnException {\n\n    handleProgress(appAttemptId, request);\n\n    List\u003cResourceRequest\u003e ask \u003d request.getAskList();\n    List\u003cContainerId\u003e release \u003d request.getReleaseList();\n\n    ResourceBlacklistRequest blacklistRequest \u003d\n        request.getResourceBlacklistRequest();\n    List\u003cString\u003e blacklistAdditions \u003d\n        (blacklistRequest !\u003d null) ?\n            blacklistRequest.getBlacklistAdditions() : Collections.EMPTY_LIST;\n    List\u003cString\u003e blacklistRemovals \u003d\n        (blacklistRequest !\u003d null) ?\n            blacklistRequest.getBlacklistRemovals() : Collections.EMPTY_LIST;\n    RMApp app \u003d\n        getRmContext().getRMApps().get(appAttemptId.getApplicationId());\n\n    // set label expression for Resource Requests if resourceName\u003dANY\n    ApplicationSubmissionContext asc \u003d app.getApplicationSubmissionContext();\n    for (ResourceRequest req : ask) {\n      if (null \u003d\u003d req.getNodeLabelExpression()\n          \u0026\u0026 ResourceRequest.ANY.equals(req.getResourceName())) {\n        req.setNodeLabelExpression(asc.getNodeLabelExpression());\n      }\n    }\n\n    Resource maximumCapacity \u003d getScheduler().getMaximumResourceCapability();\n\n    // sanity check\n    try {\n      RMServerUtils.normalizeAndValidateRequests(ask,\n          maximumCapacity, app.getQueue(),\n          getScheduler(), getRmContext());\n    } catch (InvalidResourceRequestException e) {\n      LOG.warn(\"Invalid resource ask by application \" + appAttemptId, e);\n      throw e;\n    }\n\n    try {\n      RMServerUtils.validateBlacklistRequest(blacklistRequest);\n    }  catch (InvalidResourceBlacklistRequestException e) {\n      LOG.warn(\"Invalid blacklist request by application \" + appAttemptId, e);\n      throw e;\n    }\n\n    // In the case of work-preserving AM restart, it\u0027s possible for the\n    // AM to release containers from the earlier attempt.\n    if (!app.getApplicationSubmissionContext()\n        .getKeepContainersAcrossApplicationAttempts()) {\n      try {\n        RMServerUtils.validateContainerReleaseRequest(release, appAttemptId);\n      } catch (InvalidContainerReleaseException e) {\n        LOG.warn(\"Invalid container release by application \" + appAttemptId,\n            e);\n        throw e;\n      }\n    }\n\n    // Split Update Resource Requests into increase and decrease.\n    // No Exceptions are thrown here. All update errors are aggregated\n    // and returned to the AM.\n    List\u003cUpdateContainerError\u003e updateErrors \u003d new ArrayList\u003c\u003e();\n    ContainerUpdates containerUpdateRequests \u003d\n        RMServerUtils.validateAndSplitUpdateResourceRequests(\n            getRmContext(), request, maximumCapacity, updateErrors);\n\n    // Send new requests to appAttempt.\n    Allocation allocation;\n    RMAppAttemptState state \u003d\n        app.getRMAppAttempt(appAttemptId).getAppAttemptState();\n    if (state.equals(RMAppAttemptState.FINAL_SAVING) ||\n        state.equals(RMAppAttemptState.FINISHING) ||\n        app.isAppFinalStateStored()) {\n      LOG.warn(appAttemptId + \" is in \" + state +\n          \" state, ignore container allocate request.\");\n      allocation \u003d EMPTY_ALLOCATION;\n    } else {\n      allocation \u003d\n          getScheduler().allocate(appAttemptId, ask, release,\n              blacklistAdditions, blacklistRemovals,\n              containerUpdateRequests);\n    }\n\n    if (!blacklistAdditions.isEmpty() || !blacklistRemovals.isEmpty()) {\n      LOG.info(\"blacklist are updated in Scheduler.\" +\n          \"blacklistAdditions: \" + blacklistAdditions + \", \" +\n          \"blacklistRemovals: \" + blacklistRemovals);\n    }\n    RMAppAttempt appAttempt \u003d app.getRMAppAttempt(appAttemptId);\n    AllocateResponse allocateResponse \u003d\n        recordFactory.newRecordInstance(AllocateResponse.class);\n\n    if (allocation.getNMTokens() !\u003d null \u0026\u0026\n        !allocation.getNMTokens().isEmpty()) {\n      allocateResponse.setNMTokens(allocation.getNMTokens());\n    }\n\n    // Notify the AM of container update errors\n    ApplicationMasterServiceUtils.addToUpdateContainerErrors(\n        allocateResponse, updateErrors);\n\n    // update the response with the deltas of node status changes\n    handleNodeUpdates(app, allocateResponse);\n\n    ApplicationMasterServiceUtils.addToAllocatedContainers(\n        allocateResponse, allocation.getContainers());\n\n    allocateResponse.setCompletedContainersStatuses(appAttempt\n        .pullJustFinishedContainers());\n    allocateResponse.setAvailableResources(allocation.getResourceLimit());\n\n    addToContainerUpdates(allocateResponse, allocation,\n        ((AbstractYarnScheduler)getScheduler())\n            .getApplicationAttempt(appAttemptId).pullUpdateContainerErrors());\n\n    allocateResponse.setNumClusterNodes(getScheduler().getNumClusterNodes());\n\n    // add collector address for this application\n    if (YarnConfiguration.timelineServiceV2Enabled(\n        getRmContext().getYarnConfiguration())) {\n      allocateResponse.setCollectorAddr(\n          getRmContext().getRMApps().get(appAttemptId.getApplicationId())\n              .getCollectorAddr());\n    }\n\n    // add preemption to the allocateResponse message (if any)\n    allocateResponse\n        .setPreemptionMessage(generatePreemptionMessage(allocation));\n\n    // Set application priority\n    allocateResponse.setApplicationPriority(app\n        .getApplicationPriority());\n    return allocateResponse;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/DefaultAMSProcessor.java",
          "extendedDetails": {
            "oldPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java",
            "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/DefaultAMSProcessor.java",
            "oldMethodName": "allocateInternal",
            "newMethodName": "allocate"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "YARN-6776. Refactor ApplicaitonMasterService to move actual processing logic to a separate class. (asuresh)\n",
          "commitDate": "10/07/17 2:34 PM",
          "commitName": "5496a34c0cb2b1a83cfa6b0aba5a77b05ff2d8f0",
          "commitAuthor": "Arun Suresh",
          "commitDateOld": "10/07/17 3:53 AM",
          "commitNameOld": "09653ea098a17fddcf111b0da289085915c351d1",
          "commitAuthorOld": "Steve Loughran",
          "daysBetweenCommits": 0.45,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,166 +1,136 @@\n-  protected void allocateInternal(ApplicationAttemptId appAttemptId,\n-      AllocateRequest request, AllocateResponse allocateResponse)\n-      throws YarnException {\n+  public AllocateResponse allocate(ApplicationAttemptId appAttemptId,\n+      AllocateRequest request) throws YarnException {\n \n-    //filter illegal progress values\n-    float filteredProgress \u003d request.getProgress();\n-    if (Float.isNaN(filteredProgress) ||\n-        filteredProgress \u003d\u003d Float.NEGATIVE_INFINITY ||\n-        filteredProgress \u003c 0) {\n-      request.setProgress(0);\n-    } else if (filteredProgress \u003e 1 ||\n-        filteredProgress \u003d\u003d Float.POSITIVE_INFINITY) {\n-      request.setProgress(1);\n-    }\n-\n-    // Send the status update to the appAttempt.\n-    this.rmContext.getDispatcher().getEventHandler().handle(\n-        new RMAppAttemptStatusupdateEvent(appAttemptId, request\n-            .getProgress()));\n+    handleProgress(appAttemptId, request);\n \n     List\u003cResourceRequest\u003e ask \u003d request.getAskList();\n     List\u003cContainerId\u003e release \u003d request.getReleaseList();\n \n     ResourceBlacklistRequest blacklistRequest \u003d\n         request.getResourceBlacklistRequest();\n     List\u003cString\u003e blacklistAdditions \u003d\n         (blacklistRequest !\u003d null) ?\n             blacklistRequest.getBlacklistAdditions() : Collections.EMPTY_LIST;\n     List\u003cString\u003e blacklistRemovals \u003d\n         (blacklistRequest !\u003d null) ?\n             blacklistRequest.getBlacklistRemovals() : Collections.EMPTY_LIST;\n     RMApp app \u003d\n-        this.rmContext.getRMApps().get(appAttemptId.getApplicationId());\n+        getRmContext().getRMApps().get(appAttemptId.getApplicationId());\n \n     // set label expression for Resource Requests if resourceName\u003dANY\n     ApplicationSubmissionContext asc \u003d app.getApplicationSubmissionContext();\n     for (ResourceRequest req : ask) {\n       if (null \u003d\u003d req.getNodeLabelExpression()\n           \u0026\u0026 ResourceRequest.ANY.equals(req.getResourceName())) {\n         req.setNodeLabelExpression(asc.getNodeLabelExpression());\n       }\n     }\n \n-    Resource maximumCapacity \u003d rScheduler.getMaximumResourceCapability();\n+    Resource maximumCapacity \u003d getScheduler().getMaximumResourceCapability();\n \n     // sanity check\n     try {\n       RMServerUtils.normalizeAndValidateRequests(ask,\n           maximumCapacity, app.getQueue(),\n-          rScheduler, rmContext);\n+          getScheduler(), getRmContext());\n     } catch (InvalidResourceRequestException e) {\n       LOG.warn(\"Invalid resource ask by application \" + appAttemptId, e);\n       throw e;\n     }\n \n     try {\n       RMServerUtils.validateBlacklistRequest(blacklistRequest);\n     }  catch (InvalidResourceBlacklistRequestException e) {\n       LOG.warn(\"Invalid blacklist request by application \" + appAttemptId, e);\n       throw e;\n     }\n \n     // In the case of work-preserving AM restart, it\u0027s possible for the\n     // AM to release containers from the earlier attempt.\n     if (!app.getApplicationSubmissionContext()\n         .getKeepContainersAcrossApplicationAttempts()) {\n       try {\n         RMServerUtils.validateContainerReleaseRequest(release, appAttemptId);\n       } catch (InvalidContainerReleaseException e) {\n         LOG.warn(\"Invalid container release by application \" + appAttemptId,\n             e);\n         throw e;\n       }\n     }\n \n     // Split Update Resource Requests into increase and decrease.\n     // No Exceptions are thrown here. All update errors are aggregated\n     // and returned to the AM.\n     List\u003cUpdateContainerError\u003e updateErrors \u003d new ArrayList\u003c\u003e();\n     ContainerUpdates containerUpdateRequests \u003d\n         RMServerUtils.validateAndSplitUpdateResourceRequests(\n-        rmContext, request, maximumCapacity, updateErrors);\n+            getRmContext(), request, maximumCapacity, updateErrors);\n \n     // Send new requests to appAttempt.\n     Allocation allocation;\n     RMAppAttemptState state \u003d\n         app.getRMAppAttempt(appAttemptId).getAppAttemptState();\n     if (state.equals(RMAppAttemptState.FINAL_SAVING) ||\n         state.equals(RMAppAttemptState.FINISHING) ||\n         app.isAppFinalStateStored()) {\n       LOG.warn(appAttemptId + \" is in \" + state +\n-               \" state, ignore container allocate request.\");\n+          \" state, ignore container allocate request.\");\n       allocation \u003d EMPTY_ALLOCATION;\n     } else {\n       allocation \u003d\n-          this.rScheduler.allocate(appAttemptId, ask, release,\n+          getScheduler().allocate(appAttemptId, ask, release,\n               blacklistAdditions, blacklistRemovals,\n               containerUpdateRequests);\n     }\n \n     if (!blacklistAdditions.isEmpty() || !blacklistRemovals.isEmpty()) {\n       LOG.info(\"blacklist are updated in Scheduler.\" +\n           \"blacklistAdditions: \" + blacklistAdditions + \", \" +\n           \"blacklistRemovals: \" + blacklistRemovals);\n     }\n     RMAppAttempt appAttempt \u003d app.getRMAppAttempt(appAttemptId);\n+    AllocateResponse allocateResponse \u003d\n+        recordFactory.newRecordInstance(AllocateResponse.class);\n \n     if (allocation.getNMTokens() !\u003d null \u0026\u0026\n         !allocation.getNMTokens().isEmpty()) {\n       allocateResponse.setNMTokens(allocation.getNMTokens());\n     }\n \n     // Notify the AM of container update errors\n-    addToUpdateContainerErrors(allocateResponse, updateErrors);\n+    ApplicationMasterServiceUtils.addToUpdateContainerErrors(\n+        allocateResponse, updateErrors);\n \n     // update the response with the deltas of node status changes\n-    List\u003cRMNode\u003e updatedNodes \u003d new ArrayList\u003cRMNode\u003e();\n-    if(app.pullRMNodeUpdates(updatedNodes) \u003e 0) {\n-      List\u003cNodeReport\u003e updatedNodeReports \u003d new ArrayList\u003cNodeReport\u003e();\n-      for(RMNode rmNode: updatedNodes) {\n-        SchedulerNodeReport schedulerNodeReport \u003d\n-            rScheduler.getNodeReport(rmNode.getNodeID());\n-        Resource used \u003d BuilderUtils.newResource(0, 0);\n-        int numContainers \u003d 0;\n-        if (schedulerNodeReport !\u003d null) {\n-          used \u003d schedulerNodeReport.getUsedResource();\n-          numContainers \u003d schedulerNodeReport.getNumContainers();\n-        }\n-        NodeId nodeId \u003d rmNode.getNodeID();\n-        NodeReport report \u003d\n-            BuilderUtils.newNodeReport(nodeId, rmNode.getState(),\n-                rmNode.getHttpAddress(), rmNode.getRackName(), used,\n-                rmNode.getTotalCapability(), numContainers,\n-                rmNode.getHealthReport(), rmNode.getLastHealthReportTime(),\n-                rmNode.getNodeLabels());\n+    handleNodeUpdates(app, allocateResponse);\n \n-        updatedNodeReports.add(report);\n-      }\n-      allocateResponse.setUpdatedNodes(updatedNodeReports);\n-    }\n-\n-    addToAllocatedContainers(allocateResponse, allocation.getContainers());\n+    ApplicationMasterServiceUtils.addToAllocatedContainers(\n+        allocateResponse, allocation.getContainers());\n \n     allocateResponse.setCompletedContainersStatuses(appAttempt\n         .pullJustFinishedContainers());\n     allocateResponse.setAvailableResources(allocation.getResourceLimit());\n \n-    addToContainerUpdates(appAttemptId, allocateResponse, allocation);\n+    addToContainerUpdates(allocateResponse, allocation,\n+        ((AbstractYarnScheduler)getScheduler())\n+            .getApplicationAttempt(appAttemptId).pullUpdateContainerErrors());\n \n-    allocateResponse.setNumClusterNodes(this.rScheduler.getNumClusterNodes());\n+    allocateResponse.setNumClusterNodes(getScheduler().getNumClusterNodes());\n \n     // add collector address for this application\n-    if (YarnConfiguration.timelineServiceV2Enabled(getConfig())) {\n+    if (YarnConfiguration.timelineServiceV2Enabled(\n+        getRmContext().getYarnConfiguration())) {\n       allocateResponse.setCollectorAddr(\n-          this.rmContext.getRMApps().get(appAttemptId.getApplicationId())\n+          getRmContext().getRMApps().get(appAttemptId.getApplicationId())\n               .getCollectorAddr());\n     }\n \n     // add preemption to the allocateResponse message (if any)\n     allocateResponse\n         .setPreemptionMessage(generatePreemptionMessage(allocation));\n \n     // Set application priority\n     allocateResponse.setApplicationPriority(app\n         .getApplicationPriority());\n+    return allocateResponse;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public AllocateResponse allocate(ApplicationAttemptId appAttemptId,\n      AllocateRequest request) throws YarnException {\n\n    handleProgress(appAttemptId, request);\n\n    List\u003cResourceRequest\u003e ask \u003d request.getAskList();\n    List\u003cContainerId\u003e release \u003d request.getReleaseList();\n\n    ResourceBlacklistRequest blacklistRequest \u003d\n        request.getResourceBlacklistRequest();\n    List\u003cString\u003e blacklistAdditions \u003d\n        (blacklistRequest !\u003d null) ?\n            blacklistRequest.getBlacklistAdditions() : Collections.EMPTY_LIST;\n    List\u003cString\u003e blacklistRemovals \u003d\n        (blacklistRequest !\u003d null) ?\n            blacklistRequest.getBlacklistRemovals() : Collections.EMPTY_LIST;\n    RMApp app \u003d\n        getRmContext().getRMApps().get(appAttemptId.getApplicationId());\n\n    // set label expression for Resource Requests if resourceName\u003dANY\n    ApplicationSubmissionContext asc \u003d app.getApplicationSubmissionContext();\n    for (ResourceRequest req : ask) {\n      if (null \u003d\u003d req.getNodeLabelExpression()\n          \u0026\u0026 ResourceRequest.ANY.equals(req.getResourceName())) {\n        req.setNodeLabelExpression(asc.getNodeLabelExpression());\n      }\n    }\n\n    Resource maximumCapacity \u003d getScheduler().getMaximumResourceCapability();\n\n    // sanity check\n    try {\n      RMServerUtils.normalizeAndValidateRequests(ask,\n          maximumCapacity, app.getQueue(),\n          getScheduler(), getRmContext());\n    } catch (InvalidResourceRequestException e) {\n      LOG.warn(\"Invalid resource ask by application \" + appAttemptId, e);\n      throw e;\n    }\n\n    try {\n      RMServerUtils.validateBlacklistRequest(blacklistRequest);\n    }  catch (InvalidResourceBlacklistRequestException e) {\n      LOG.warn(\"Invalid blacklist request by application \" + appAttemptId, e);\n      throw e;\n    }\n\n    // In the case of work-preserving AM restart, it\u0027s possible for the\n    // AM to release containers from the earlier attempt.\n    if (!app.getApplicationSubmissionContext()\n        .getKeepContainersAcrossApplicationAttempts()) {\n      try {\n        RMServerUtils.validateContainerReleaseRequest(release, appAttemptId);\n      } catch (InvalidContainerReleaseException e) {\n        LOG.warn(\"Invalid container release by application \" + appAttemptId,\n            e);\n        throw e;\n      }\n    }\n\n    // Split Update Resource Requests into increase and decrease.\n    // No Exceptions are thrown here. All update errors are aggregated\n    // and returned to the AM.\n    List\u003cUpdateContainerError\u003e updateErrors \u003d new ArrayList\u003c\u003e();\n    ContainerUpdates containerUpdateRequests \u003d\n        RMServerUtils.validateAndSplitUpdateResourceRequests(\n            getRmContext(), request, maximumCapacity, updateErrors);\n\n    // Send new requests to appAttempt.\n    Allocation allocation;\n    RMAppAttemptState state \u003d\n        app.getRMAppAttempt(appAttemptId).getAppAttemptState();\n    if (state.equals(RMAppAttemptState.FINAL_SAVING) ||\n        state.equals(RMAppAttemptState.FINISHING) ||\n        app.isAppFinalStateStored()) {\n      LOG.warn(appAttemptId + \" is in \" + state +\n          \" state, ignore container allocate request.\");\n      allocation \u003d EMPTY_ALLOCATION;\n    } else {\n      allocation \u003d\n          getScheduler().allocate(appAttemptId, ask, release,\n              blacklistAdditions, blacklistRemovals,\n              containerUpdateRequests);\n    }\n\n    if (!blacklistAdditions.isEmpty() || !blacklistRemovals.isEmpty()) {\n      LOG.info(\"blacklist are updated in Scheduler.\" +\n          \"blacklistAdditions: \" + blacklistAdditions + \", \" +\n          \"blacklistRemovals: \" + blacklistRemovals);\n    }\n    RMAppAttempt appAttempt \u003d app.getRMAppAttempt(appAttemptId);\n    AllocateResponse allocateResponse \u003d\n        recordFactory.newRecordInstance(AllocateResponse.class);\n\n    if (allocation.getNMTokens() !\u003d null \u0026\u0026\n        !allocation.getNMTokens().isEmpty()) {\n      allocateResponse.setNMTokens(allocation.getNMTokens());\n    }\n\n    // Notify the AM of container update errors\n    ApplicationMasterServiceUtils.addToUpdateContainerErrors(\n        allocateResponse, updateErrors);\n\n    // update the response with the deltas of node status changes\n    handleNodeUpdates(app, allocateResponse);\n\n    ApplicationMasterServiceUtils.addToAllocatedContainers(\n        allocateResponse, allocation.getContainers());\n\n    allocateResponse.setCompletedContainersStatuses(appAttempt\n        .pullJustFinishedContainers());\n    allocateResponse.setAvailableResources(allocation.getResourceLimit());\n\n    addToContainerUpdates(allocateResponse, allocation,\n        ((AbstractYarnScheduler)getScheduler())\n            .getApplicationAttempt(appAttemptId).pullUpdateContainerErrors());\n\n    allocateResponse.setNumClusterNodes(getScheduler().getNumClusterNodes());\n\n    // add collector address for this application\n    if (YarnConfiguration.timelineServiceV2Enabled(\n        getRmContext().getYarnConfiguration())) {\n      allocateResponse.setCollectorAddr(\n          getRmContext().getRMApps().get(appAttemptId.getApplicationId())\n              .getCollectorAddr());\n    }\n\n    // add preemption to the allocateResponse message (if any)\n    allocateResponse\n        .setPreemptionMessage(generatePreemptionMessage(allocation));\n\n    // Set application priority\n    allocateResponse.setApplicationPriority(app\n        .getApplicationPriority());\n    return allocateResponse;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/DefaultAMSProcessor.java",
          "extendedDetails": {
            "oldValue": "void",
            "newValue": "AllocateResponse"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "YARN-6776. Refactor ApplicaitonMasterService to move actual processing logic to a separate class. (asuresh)\n",
          "commitDate": "10/07/17 2:34 PM",
          "commitName": "5496a34c0cb2b1a83cfa6b0aba5a77b05ff2d8f0",
          "commitAuthor": "Arun Suresh",
          "commitDateOld": "10/07/17 3:53 AM",
          "commitNameOld": "09653ea098a17fddcf111b0da289085915c351d1",
          "commitAuthorOld": "Steve Loughran",
          "daysBetweenCommits": 0.45,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,166 +1,136 @@\n-  protected void allocateInternal(ApplicationAttemptId appAttemptId,\n-      AllocateRequest request, AllocateResponse allocateResponse)\n-      throws YarnException {\n+  public AllocateResponse allocate(ApplicationAttemptId appAttemptId,\n+      AllocateRequest request) throws YarnException {\n \n-    //filter illegal progress values\n-    float filteredProgress \u003d request.getProgress();\n-    if (Float.isNaN(filteredProgress) ||\n-        filteredProgress \u003d\u003d Float.NEGATIVE_INFINITY ||\n-        filteredProgress \u003c 0) {\n-      request.setProgress(0);\n-    } else if (filteredProgress \u003e 1 ||\n-        filteredProgress \u003d\u003d Float.POSITIVE_INFINITY) {\n-      request.setProgress(1);\n-    }\n-\n-    // Send the status update to the appAttempt.\n-    this.rmContext.getDispatcher().getEventHandler().handle(\n-        new RMAppAttemptStatusupdateEvent(appAttemptId, request\n-            .getProgress()));\n+    handleProgress(appAttemptId, request);\n \n     List\u003cResourceRequest\u003e ask \u003d request.getAskList();\n     List\u003cContainerId\u003e release \u003d request.getReleaseList();\n \n     ResourceBlacklistRequest blacklistRequest \u003d\n         request.getResourceBlacklistRequest();\n     List\u003cString\u003e blacklistAdditions \u003d\n         (blacklistRequest !\u003d null) ?\n             blacklistRequest.getBlacklistAdditions() : Collections.EMPTY_LIST;\n     List\u003cString\u003e blacklistRemovals \u003d\n         (blacklistRequest !\u003d null) ?\n             blacklistRequest.getBlacklistRemovals() : Collections.EMPTY_LIST;\n     RMApp app \u003d\n-        this.rmContext.getRMApps().get(appAttemptId.getApplicationId());\n+        getRmContext().getRMApps().get(appAttemptId.getApplicationId());\n \n     // set label expression for Resource Requests if resourceName\u003dANY\n     ApplicationSubmissionContext asc \u003d app.getApplicationSubmissionContext();\n     for (ResourceRequest req : ask) {\n       if (null \u003d\u003d req.getNodeLabelExpression()\n           \u0026\u0026 ResourceRequest.ANY.equals(req.getResourceName())) {\n         req.setNodeLabelExpression(asc.getNodeLabelExpression());\n       }\n     }\n \n-    Resource maximumCapacity \u003d rScheduler.getMaximumResourceCapability();\n+    Resource maximumCapacity \u003d getScheduler().getMaximumResourceCapability();\n \n     // sanity check\n     try {\n       RMServerUtils.normalizeAndValidateRequests(ask,\n           maximumCapacity, app.getQueue(),\n-          rScheduler, rmContext);\n+          getScheduler(), getRmContext());\n     } catch (InvalidResourceRequestException e) {\n       LOG.warn(\"Invalid resource ask by application \" + appAttemptId, e);\n       throw e;\n     }\n \n     try {\n       RMServerUtils.validateBlacklistRequest(blacklistRequest);\n     }  catch (InvalidResourceBlacklistRequestException e) {\n       LOG.warn(\"Invalid blacklist request by application \" + appAttemptId, e);\n       throw e;\n     }\n \n     // In the case of work-preserving AM restart, it\u0027s possible for the\n     // AM to release containers from the earlier attempt.\n     if (!app.getApplicationSubmissionContext()\n         .getKeepContainersAcrossApplicationAttempts()) {\n       try {\n         RMServerUtils.validateContainerReleaseRequest(release, appAttemptId);\n       } catch (InvalidContainerReleaseException e) {\n         LOG.warn(\"Invalid container release by application \" + appAttemptId,\n             e);\n         throw e;\n       }\n     }\n \n     // Split Update Resource Requests into increase and decrease.\n     // No Exceptions are thrown here. All update errors are aggregated\n     // and returned to the AM.\n     List\u003cUpdateContainerError\u003e updateErrors \u003d new ArrayList\u003c\u003e();\n     ContainerUpdates containerUpdateRequests \u003d\n         RMServerUtils.validateAndSplitUpdateResourceRequests(\n-        rmContext, request, maximumCapacity, updateErrors);\n+            getRmContext(), request, maximumCapacity, updateErrors);\n \n     // Send new requests to appAttempt.\n     Allocation allocation;\n     RMAppAttemptState state \u003d\n         app.getRMAppAttempt(appAttemptId).getAppAttemptState();\n     if (state.equals(RMAppAttemptState.FINAL_SAVING) ||\n         state.equals(RMAppAttemptState.FINISHING) ||\n         app.isAppFinalStateStored()) {\n       LOG.warn(appAttemptId + \" is in \" + state +\n-               \" state, ignore container allocate request.\");\n+          \" state, ignore container allocate request.\");\n       allocation \u003d EMPTY_ALLOCATION;\n     } else {\n       allocation \u003d\n-          this.rScheduler.allocate(appAttemptId, ask, release,\n+          getScheduler().allocate(appAttemptId, ask, release,\n               blacklistAdditions, blacklistRemovals,\n               containerUpdateRequests);\n     }\n \n     if (!blacklistAdditions.isEmpty() || !blacklistRemovals.isEmpty()) {\n       LOG.info(\"blacklist are updated in Scheduler.\" +\n           \"blacklistAdditions: \" + blacklistAdditions + \", \" +\n           \"blacklistRemovals: \" + blacklistRemovals);\n     }\n     RMAppAttempt appAttempt \u003d app.getRMAppAttempt(appAttemptId);\n+    AllocateResponse allocateResponse \u003d\n+        recordFactory.newRecordInstance(AllocateResponse.class);\n \n     if (allocation.getNMTokens() !\u003d null \u0026\u0026\n         !allocation.getNMTokens().isEmpty()) {\n       allocateResponse.setNMTokens(allocation.getNMTokens());\n     }\n \n     // Notify the AM of container update errors\n-    addToUpdateContainerErrors(allocateResponse, updateErrors);\n+    ApplicationMasterServiceUtils.addToUpdateContainerErrors(\n+        allocateResponse, updateErrors);\n \n     // update the response with the deltas of node status changes\n-    List\u003cRMNode\u003e updatedNodes \u003d new ArrayList\u003cRMNode\u003e();\n-    if(app.pullRMNodeUpdates(updatedNodes) \u003e 0) {\n-      List\u003cNodeReport\u003e updatedNodeReports \u003d new ArrayList\u003cNodeReport\u003e();\n-      for(RMNode rmNode: updatedNodes) {\n-        SchedulerNodeReport schedulerNodeReport \u003d\n-            rScheduler.getNodeReport(rmNode.getNodeID());\n-        Resource used \u003d BuilderUtils.newResource(0, 0);\n-        int numContainers \u003d 0;\n-        if (schedulerNodeReport !\u003d null) {\n-          used \u003d schedulerNodeReport.getUsedResource();\n-          numContainers \u003d schedulerNodeReport.getNumContainers();\n-        }\n-        NodeId nodeId \u003d rmNode.getNodeID();\n-        NodeReport report \u003d\n-            BuilderUtils.newNodeReport(nodeId, rmNode.getState(),\n-                rmNode.getHttpAddress(), rmNode.getRackName(), used,\n-                rmNode.getTotalCapability(), numContainers,\n-                rmNode.getHealthReport(), rmNode.getLastHealthReportTime(),\n-                rmNode.getNodeLabels());\n+    handleNodeUpdates(app, allocateResponse);\n \n-        updatedNodeReports.add(report);\n-      }\n-      allocateResponse.setUpdatedNodes(updatedNodeReports);\n-    }\n-\n-    addToAllocatedContainers(allocateResponse, allocation.getContainers());\n+    ApplicationMasterServiceUtils.addToAllocatedContainers(\n+        allocateResponse, allocation.getContainers());\n \n     allocateResponse.setCompletedContainersStatuses(appAttempt\n         .pullJustFinishedContainers());\n     allocateResponse.setAvailableResources(allocation.getResourceLimit());\n \n-    addToContainerUpdates(appAttemptId, allocateResponse, allocation);\n+    addToContainerUpdates(allocateResponse, allocation,\n+        ((AbstractYarnScheduler)getScheduler())\n+            .getApplicationAttempt(appAttemptId).pullUpdateContainerErrors());\n \n-    allocateResponse.setNumClusterNodes(this.rScheduler.getNumClusterNodes());\n+    allocateResponse.setNumClusterNodes(getScheduler().getNumClusterNodes());\n \n     // add collector address for this application\n-    if (YarnConfiguration.timelineServiceV2Enabled(getConfig())) {\n+    if (YarnConfiguration.timelineServiceV2Enabled(\n+        getRmContext().getYarnConfiguration())) {\n       allocateResponse.setCollectorAddr(\n-          this.rmContext.getRMApps().get(appAttemptId.getApplicationId())\n+          getRmContext().getRMApps().get(appAttemptId.getApplicationId())\n               .getCollectorAddr());\n     }\n \n     // add preemption to the allocateResponse message (if any)\n     allocateResponse\n         .setPreemptionMessage(generatePreemptionMessage(allocation));\n \n     // Set application priority\n     allocateResponse.setApplicationPriority(app\n         .getApplicationPriority());\n+    return allocateResponse;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public AllocateResponse allocate(ApplicationAttemptId appAttemptId,\n      AllocateRequest request) throws YarnException {\n\n    handleProgress(appAttemptId, request);\n\n    List\u003cResourceRequest\u003e ask \u003d request.getAskList();\n    List\u003cContainerId\u003e release \u003d request.getReleaseList();\n\n    ResourceBlacklistRequest blacklistRequest \u003d\n        request.getResourceBlacklistRequest();\n    List\u003cString\u003e blacklistAdditions \u003d\n        (blacklistRequest !\u003d null) ?\n            blacklistRequest.getBlacklistAdditions() : Collections.EMPTY_LIST;\n    List\u003cString\u003e blacklistRemovals \u003d\n        (blacklistRequest !\u003d null) ?\n            blacklistRequest.getBlacklistRemovals() : Collections.EMPTY_LIST;\n    RMApp app \u003d\n        getRmContext().getRMApps().get(appAttemptId.getApplicationId());\n\n    // set label expression for Resource Requests if resourceName\u003dANY\n    ApplicationSubmissionContext asc \u003d app.getApplicationSubmissionContext();\n    for (ResourceRequest req : ask) {\n      if (null \u003d\u003d req.getNodeLabelExpression()\n          \u0026\u0026 ResourceRequest.ANY.equals(req.getResourceName())) {\n        req.setNodeLabelExpression(asc.getNodeLabelExpression());\n      }\n    }\n\n    Resource maximumCapacity \u003d getScheduler().getMaximumResourceCapability();\n\n    // sanity check\n    try {\n      RMServerUtils.normalizeAndValidateRequests(ask,\n          maximumCapacity, app.getQueue(),\n          getScheduler(), getRmContext());\n    } catch (InvalidResourceRequestException e) {\n      LOG.warn(\"Invalid resource ask by application \" + appAttemptId, e);\n      throw e;\n    }\n\n    try {\n      RMServerUtils.validateBlacklistRequest(blacklistRequest);\n    }  catch (InvalidResourceBlacklistRequestException e) {\n      LOG.warn(\"Invalid blacklist request by application \" + appAttemptId, e);\n      throw e;\n    }\n\n    // In the case of work-preserving AM restart, it\u0027s possible for the\n    // AM to release containers from the earlier attempt.\n    if (!app.getApplicationSubmissionContext()\n        .getKeepContainersAcrossApplicationAttempts()) {\n      try {\n        RMServerUtils.validateContainerReleaseRequest(release, appAttemptId);\n      } catch (InvalidContainerReleaseException e) {\n        LOG.warn(\"Invalid container release by application \" + appAttemptId,\n            e);\n        throw e;\n      }\n    }\n\n    // Split Update Resource Requests into increase and decrease.\n    // No Exceptions are thrown here. All update errors are aggregated\n    // and returned to the AM.\n    List\u003cUpdateContainerError\u003e updateErrors \u003d new ArrayList\u003c\u003e();\n    ContainerUpdates containerUpdateRequests \u003d\n        RMServerUtils.validateAndSplitUpdateResourceRequests(\n            getRmContext(), request, maximumCapacity, updateErrors);\n\n    // Send new requests to appAttempt.\n    Allocation allocation;\n    RMAppAttemptState state \u003d\n        app.getRMAppAttempt(appAttemptId).getAppAttemptState();\n    if (state.equals(RMAppAttemptState.FINAL_SAVING) ||\n        state.equals(RMAppAttemptState.FINISHING) ||\n        app.isAppFinalStateStored()) {\n      LOG.warn(appAttemptId + \" is in \" + state +\n          \" state, ignore container allocate request.\");\n      allocation \u003d EMPTY_ALLOCATION;\n    } else {\n      allocation \u003d\n          getScheduler().allocate(appAttemptId, ask, release,\n              blacklistAdditions, blacklistRemovals,\n              containerUpdateRequests);\n    }\n\n    if (!blacklistAdditions.isEmpty() || !blacklistRemovals.isEmpty()) {\n      LOG.info(\"blacklist are updated in Scheduler.\" +\n          \"blacklistAdditions: \" + blacklistAdditions + \", \" +\n          \"blacklistRemovals: \" + blacklistRemovals);\n    }\n    RMAppAttempt appAttempt \u003d app.getRMAppAttempt(appAttemptId);\n    AllocateResponse allocateResponse \u003d\n        recordFactory.newRecordInstance(AllocateResponse.class);\n\n    if (allocation.getNMTokens() !\u003d null \u0026\u0026\n        !allocation.getNMTokens().isEmpty()) {\n      allocateResponse.setNMTokens(allocation.getNMTokens());\n    }\n\n    // Notify the AM of container update errors\n    ApplicationMasterServiceUtils.addToUpdateContainerErrors(\n        allocateResponse, updateErrors);\n\n    // update the response with the deltas of node status changes\n    handleNodeUpdates(app, allocateResponse);\n\n    ApplicationMasterServiceUtils.addToAllocatedContainers(\n        allocateResponse, allocation.getContainers());\n\n    allocateResponse.setCompletedContainersStatuses(appAttempt\n        .pullJustFinishedContainers());\n    allocateResponse.setAvailableResources(allocation.getResourceLimit());\n\n    addToContainerUpdates(allocateResponse, allocation,\n        ((AbstractYarnScheduler)getScheduler())\n            .getApplicationAttempt(appAttemptId).pullUpdateContainerErrors());\n\n    allocateResponse.setNumClusterNodes(getScheduler().getNumClusterNodes());\n\n    // add collector address for this application\n    if (YarnConfiguration.timelineServiceV2Enabled(\n        getRmContext().getYarnConfiguration())) {\n      allocateResponse.setCollectorAddr(\n          getRmContext().getRMApps().get(appAttemptId.getApplicationId())\n              .getCollectorAddr());\n    }\n\n    // add preemption to the allocateResponse message (if any)\n    allocateResponse\n        .setPreemptionMessage(generatePreemptionMessage(allocation));\n\n    // Set application priority\n    allocateResponse.setApplicationPriority(app\n        .getApplicationPriority());\n    return allocateResponse;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/DefaultAMSProcessor.java",
          "extendedDetails": {
            "oldValue": "[protected]",
            "newValue": "[public]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-6776. Refactor ApplicaitonMasterService to move actual processing logic to a separate class. (asuresh)\n",
          "commitDate": "10/07/17 2:34 PM",
          "commitName": "5496a34c0cb2b1a83cfa6b0aba5a77b05ff2d8f0",
          "commitAuthor": "Arun Suresh",
          "commitDateOld": "10/07/17 3:53 AM",
          "commitNameOld": "09653ea098a17fddcf111b0da289085915c351d1",
          "commitAuthorOld": "Steve Loughran",
          "daysBetweenCommits": 0.45,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,166 +1,136 @@\n-  protected void allocateInternal(ApplicationAttemptId appAttemptId,\n-      AllocateRequest request, AllocateResponse allocateResponse)\n-      throws YarnException {\n+  public AllocateResponse allocate(ApplicationAttemptId appAttemptId,\n+      AllocateRequest request) throws YarnException {\n \n-    //filter illegal progress values\n-    float filteredProgress \u003d request.getProgress();\n-    if (Float.isNaN(filteredProgress) ||\n-        filteredProgress \u003d\u003d Float.NEGATIVE_INFINITY ||\n-        filteredProgress \u003c 0) {\n-      request.setProgress(0);\n-    } else if (filteredProgress \u003e 1 ||\n-        filteredProgress \u003d\u003d Float.POSITIVE_INFINITY) {\n-      request.setProgress(1);\n-    }\n-\n-    // Send the status update to the appAttempt.\n-    this.rmContext.getDispatcher().getEventHandler().handle(\n-        new RMAppAttemptStatusupdateEvent(appAttemptId, request\n-            .getProgress()));\n+    handleProgress(appAttemptId, request);\n \n     List\u003cResourceRequest\u003e ask \u003d request.getAskList();\n     List\u003cContainerId\u003e release \u003d request.getReleaseList();\n \n     ResourceBlacklistRequest blacklistRequest \u003d\n         request.getResourceBlacklistRequest();\n     List\u003cString\u003e blacklistAdditions \u003d\n         (blacklistRequest !\u003d null) ?\n             blacklistRequest.getBlacklistAdditions() : Collections.EMPTY_LIST;\n     List\u003cString\u003e blacklistRemovals \u003d\n         (blacklistRequest !\u003d null) ?\n             blacklistRequest.getBlacklistRemovals() : Collections.EMPTY_LIST;\n     RMApp app \u003d\n-        this.rmContext.getRMApps().get(appAttemptId.getApplicationId());\n+        getRmContext().getRMApps().get(appAttemptId.getApplicationId());\n \n     // set label expression for Resource Requests if resourceName\u003dANY\n     ApplicationSubmissionContext asc \u003d app.getApplicationSubmissionContext();\n     for (ResourceRequest req : ask) {\n       if (null \u003d\u003d req.getNodeLabelExpression()\n           \u0026\u0026 ResourceRequest.ANY.equals(req.getResourceName())) {\n         req.setNodeLabelExpression(asc.getNodeLabelExpression());\n       }\n     }\n \n-    Resource maximumCapacity \u003d rScheduler.getMaximumResourceCapability();\n+    Resource maximumCapacity \u003d getScheduler().getMaximumResourceCapability();\n \n     // sanity check\n     try {\n       RMServerUtils.normalizeAndValidateRequests(ask,\n           maximumCapacity, app.getQueue(),\n-          rScheduler, rmContext);\n+          getScheduler(), getRmContext());\n     } catch (InvalidResourceRequestException e) {\n       LOG.warn(\"Invalid resource ask by application \" + appAttemptId, e);\n       throw e;\n     }\n \n     try {\n       RMServerUtils.validateBlacklistRequest(blacklistRequest);\n     }  catch (InvalidResourceBlacklistRequestException e) {\n       LOG.warn(\"Invalid blacklist request by application \" + appAttemptId, e);\n       throw e;\n     }\n \n     // In the case of work-preserving AM restart, it\u0027s possible for the\n     // AM to release containers from the earlier attempt.\n     if (!app.getApplicationSubmissionContext()\n         .getKeepContainersAcrossApplicationAttempts()) {\n       try {\n         RMServerUtils.validateContainerReleaseRequest(release, appAttemptId);\n       } catch (InvalidContainerReleaseException e) {\n         LOG.warn(\"Invalid container release by application \" + appAttemptId,\n             e);\n         throw e;\n       }\n     }\n \n     // Split Update Resource Requests into increase and decrease.\n     // No Exceptions are thrown here. All update errors are aggregated\n     // and returned to the AM.\n     List\u003cUpdateContainerError\u003e updateErrors \u003d new ArrayList\u003c\u003e();\n     ContainerUpdates containerUpdateRequests \u003d\n         RMServerUtils.validateAndSplitUpdateResourceRequests(\n-        rmContext, request, maximumCapacity, updateErrors);\n+            getRmContext(), request, maximumCapacity, updateErrors);\n \n     // Send new requests to appAttempt.\n     Allocation allocation;\n     RMAppAttemptState state \u003d\n         app.getRMAppAttempt(appAttemptId).getAppAttemptState();\n     if (state.equals(RMAppAttemptState.FINAL_SAVING) ||\n         state.equals(RMAppAttemptState.FINISHING) ||\n         app.isAppFinalStateStored()) {\n       LOG.warn(appAttemptId + \" is in \" + state +\n-               \" state, ignore container allocate request.\");\n+          \" state, ignore container allocate request.\");\n       allocation \u003d EMPTY_ALLOCATION;\n     } else {\n       allocation \u003d\n-          this.rScheduler.allocate(appAttemptId, ask, release,\n+          getScheduler().allocate(appAttemptId, ask, release,\n               blacklistAdditions, blacklistRemovals,\n               containerUpdateRequests);\n     }\n \n     if (!blacklistAdditions.isEmpty() || !blacklistRemovals.isEmpty()) {\n       LOG.info(\"blacklist are updated in Scheduler.\" +\n           \"blacklistAdditions: \" + blacklistAdditions + \", \" +\n           \"blacklistRemovals: \" + blacklistRemovals);\n     }\n     RMAppAttempt appAttempt \u003d app.getRMAppAttempt(appAttemptId);\n+    AllocateResponse allocateResponse \u003d\n+        recordFactory.newRecordInstance(AllocateResponse.class);\n \n     if (allocation.getNMTokens() !\u003d null \u0026\u0026\n         !allocation.getNMTokens().isEmpty()) {\n       allocateResponse.setNMTokens(allocation.getNMTokens());\n     }\n \n     // Notify the AM of container update errors\n-    addToUpdateContainerErrors(allocateResponse, updateErrors);\n+    ApplicationMasterServiceUtils.addToUpdateContainerErrors(\n+        allocateResponse, updateErrors);\n \n     // update the response with the deltas of node status changes\n-    List\u003cRMNode\u003e updatedNodes \u003d new ArrayList\u003cRMNode\u003e();\n-    if(app.pullRMNodeUpdates(updatedNodes) \u003e 0) {\n-      List\u003cNodeReport\u003e updatedNodeReports \u003d new ArrayList\u003cNodeReport\u003e();\n-      for(RMNode rmNode: updatedNodes) {\n-        SchedulerNodeReport schedulerNodeReport \u003d\n-            rScheduler.getNodeReport(rmNode.getNodeID());\n-        Resource used \u003d BuilderUtils.newResource(0, 0);\n-        int numContainers \u003d 0;\n-        if (schedulerNodeReport !\u003d null) {\n-          used \u003d schedulerNodeReport.getUsedResource();\n-          numContainers \u003d schedulerNodeReport.getNumContainers();\n-        }\n-        NodeId nodeId \u003d rmNode.getNodeID();\n-        NodeReport report \u003d\n-            BuilderUtils.newNodeReport(nodeId, rmNode.getState(),\n-                rmNode.getHttpAddress(), rmNode.getRackName(), used,\n-                rmNode.getTotalCapability(), numContainers,\n-                rmNode.getHealthReport(), rmNode.getLastHealthReportTime(),\n-                rmNode.getNodeLabels());\n+    handleNodeUpdates(app, allocateResponse);\n \n-        updatedNodeReports.add(report);\n-      }\n-      allocateResponse.setUpdatedNodes(updatedNodeReports);\n-    }\n-\n-    addToAllocatedContainers(allocateResponse, allocation.getContainers());\n+    ApplicationMasterServiceUtils.addToAllocatedContainers(\n+        allocateResponse, allocation.getContainers());\n \n     allocateResponse.setCompletedContainersStatuses(appAttempt\n         .pullJustFinishedContainers());\n     allocateResponse.setAvailableResources(allocation.getResourceLimit());\n \n-    addToContainerUpdates(appAttemptId, allocateResponse, allocation);\n+    addToContainerUpdates(allocateResponse, allocation,\n+        ((AbstractYarnScheduler)getScheduler())\n+            .getApplicationAttempt(appAttemptId).pullUpdateContainerErrors());\n \n-    allocateResponse.setNumClusterNodes(this.rScheduler.getNumClusterNodes());\n+    allocateResponse.setNumClusterNodes(getScheduler().getNumClusterNodes());\n \n     // add collector address for this application\n-    if (YarnConfiguration.timelineServiceV2Enabled(getConfig())) {\n+    if (YarnConfiguration.timelineServiceV2Enabled(\n+        getRmContext().getYarnConfiguration())) {\n       allocateResponse.setCollectorAddr(\n-          this.rmContext.getRMApps().get(appAttemptId.getApplicationId())\n+          getRmContext().getRMApps().get(appAttemptId.getApplicationId())\n               .getCollectorAddr());\n     }\n \n     // add preemption to the allocateResponse message (if any)\n     allocateResponse\n         .setPreemptionMessage(generatePreemptionMessage(allocation));\n \n     // Set application priority\n     allocateResponse.setApplicationPriority(app\n         .getApplicationPriority());\n+    return allocateResponse;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public AllocateResponse allocate(ApplicationAttemptId appAttemptId,\n      AllocateRequest request) throws YarnException {\n\n    handleProgress(appAttemptId, request);\n\n    List\u003cResourceRequest\u003e ask \u003d request.getAskList();\n    List\u003cContainerId\u003e release \u003d request.getReleaseList();\n\n    ResourceBlacklistRequest blacklistRequest \u003d\n        request.getResourceBlacklistRequest();\n    List\u003cString\u003e blacklistAdditions \u003d\n        (blacklistRequest !\u003d null) ?\n            blacklistRequest.getBlacklistAdditions() : Collections.EMPTY_LIST;\n    List\u003cString\u003e blacklistRemovals \u003d\n        (blacklistRequest !\u003d null) ?\n            blacklistRequest.getBlacklistRemovals() : Collections.EMPTY_LIST;\n    RMApp app \u003d\n        getRmContext().getRMApps().get(appAttemptId.getApplicationId());\n\n    // set label expression for Resource Requests if resourceName\u003dANY\n    ApplicationSubmissionContext asc \u003d app.getApplicationSubmissionContext();\n    for (ResourceRequest req : ask) {\n      if (null \u003d\u003d req.getNodeLabelExpression()\n          \u0026\u0026 ResourceRequest.ANY.equals(req.getResourceName())) {\n        req.setNodeLabelExpression(asc.getNodeLabelExpression());\n      }\n    }\n\n    Resource maximumCapacity \u003d getScheduler().getMaximumResourceCapability();\n\n    // sanity check\n    try {\n      RMServerUtils.normalizeAndValidateRequests(ask,\n          maximumCapacity, app.getQueue(),\n          getScheduler(), getRmContext());\n    } catch (InvalidResourceRequestException e) {\n      LOG.warn(\"Invalid resource ask by application \" + appAttemptId, e);\n      throw e;\n    }\n\n    try {\n      RMServerUtils.validateBlacklistRequest(blacklistRequest);\n    }  catch (InvalidResourceBlacklistRequestException e) {\n      LOG.warn(\"Invalid blacklist request by application \" + appAttemptId, e);\n      throw e;\n    }\n\n    // In the case of work-preserving AM restart, it\u0027s possible for the\n    // AM to release containers from the earlier attempt.\n    if (!app.getApplicationSubmissionContext()\n        .getKeepContainersAcrossApplicationAttempts()) {\n      try {\n        RMServerUtils.validateContainerReleaseRequest(release, appAttemptId);\n      } catch (InvalidContainerReleaseException e) {\n        LOG.warn(\"Invalid container release by application \" + appAttemptId,\n            e);\n        throw e;\n      }\n    }\n\n    // Split Update Resource Requests into increase and decrease.\n    // No Exceptions are thrown here. All update errors are aggregated\n    // and returned to the AM.\n    List\u003cUpdateContainerError\u003e updateErrors \u003d new ArrayList\u003c\u003e();\n    ContainerUpdates containerUpdateRequests \u003d\n        RMServerUtils.validateAndSplitUpdateResourceRequests(\n            getRmContext(), request, maximumCapacity, updateErrors);\n\n    // Send new requests to appAttempt.\n    Allocation allocation;\n    RMAppAttemptState state \u003d\n        app.getRMAppAttempt(appAttemptId).getAppAttemptState();\n    if (state.equals(RMAppAttemptState.FINAL_SAVING) ||\n        state.equals(RMAppAttemptState.FINISHING) ||\n        app.isAppFinalStateStored()) {\n      LOG.warn(appAttemptId + \" is in \" + state +\n          \" state, ignore container allocate request.\");\n      allocation \u003d EMPTY_ALLOCATION;\n    } else {\n      allocation \u003d\n          getScheduler().allocate(appAttemptId, ask, release,\n              blacklistAdditions, blacklistRemovals,\n              containerUpdateRequests);\n    }\n\n    if (!blacklistAdditions.isEmpty() || !blacklistRemovals.isEmpty()) {\n      LOG.info(\"blacklist are updated in Scheduler.\" +\n          \"blacklistAdditions: \" + blacklistAdditions + \", \" +\n          \"blacklistRemovals: \" + blacklistRemovals);\n    }\n    RMAppAttempt appAttempt \u003d app.getRMAppAttempt(appAttemptId);\n    AllocateResponse allocateResponse \u003d\n        recordFactory.newRecordInstance(AllocateResponse.class);\n\n    if (allocation.getNMTokens() !\u003d null \u0026\u0026\n        !allocation.getNMTokens().isEmpty()) {\n      allocateResponse.setNMTokens(allocation.getNMTokens());\n    }\n\n    // Notify the AM of container update errors\n    ApplicationMasterServiceUtils.addToUpdateContainerErrors(\n        allocateResponse, updateErrors);\n\n    // update the response with the deltas of node status changes\n    handleNodeUpdates(app, allocateResponse);\n\n    ApplicationMasterServiceUtils.addToAllocatedContainers(\n        allocateResponse, allocation.getContainers());\n\n    allocateResponse.setCompletedContainersStatuses(appAttempt\n        .pullJustFinishedContainers());\n    allocateResponse.setAvailableResources(allocation.getResourceLimit());\n\n    addToContainerUpdates(allocateResponse, allocation,\n        ((AbstractYarnScheduler)getScheduler())\n            .getApplicationAttempt(appAttemptId).pullUpdateContainerErrors());\n\n    allocateResponse.setNumClusterNodes(getScheduler().getNumClusterNodes());\n\n    // add collector address for this application\n    if (YarnConfiguration.timelineServiceV2Enabled(\n        getRmContext().getYarnConfiguration())) {\n      allocateResponse.setCollectorAddr(\n          getRmContext().getRMApps().get(appAttemptId.getApplicationId())\n              .getCollectorAddr());\n    }\n\n    // add preemption to the allocateResponse message (if any)\n    allocateResponse\n        .setPreemptionMessage(generatePreemptionMessage(allocation));\n\n    // Set application priority\n    allocateResponse.setApplicationPriority(app\n        .getApplicationPriority());\n    return allocateResponse;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/DefaultAMSProcessor.java",
          "extendedDetails": {}
        },
        {
          "type": "Yrename",
          "commitMessage": "YARN-6776. Refactor ApplicaitonMasterService to move actual processing logic to a separate class. (asuresh)\n",
          "commitDate": "10/07/17 2:34 PM",
          "commitName": "5496a34c0cb2b1a83cfa6b0aba5a77b05ff2d8f0",
          "commitAuthor": "Arun Suresh",
          "commitDateOld": "10/07/17 3:53 AM",
          "commitNameOld": "09653ea098a17fddcf111b0da289085915c351d1",
          "commitAuthorOld": "Steve Loughran",
          "daysBetweenCommits": 0.45,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,166 +1,136 @@\n-  protected void allocateInternal(ApplicationAttemptId appAttemptId,\n-      AllocateRequest request, AllocateResponse allocateResponse)\n-      throws YarnException {\n+  public AllocateResponse allocate(ApplicationAttemptId appAttemptId,\n+      AllocateRequest request) throws YarnException {\n \n-    //filter illegal progress values\n-    float filteredProgress \u003d request.getProgress();\n-    if (Float.isNaN(filteredProgress) ||\n-        filteredProgress \u003d\u003d Float.NEGATIVE_INFINITY ||\n-        filteredProgress \u003c 0) {\n-      request.setProgress(0);\n-    } else if (filteredProgress \u003e 1 ||\n-        filteredProgress \u003d\u003d Float.POSITIVE_INFINITY) {\n-      request.setProgress(1);\n-    }\n-\n-    // Send the status update to the appAttempt.\n-    this.rmContext.getDispatcher().getEventHandler().handle(\n-        new RMAppAttemptStatusupdateEvent(appAttemptId, request\n-            .getProgress()));\n+    handleProgress(appAttemptId, request);\n \n     List\u003cResourceRequest\u003e ask \u003d request.getAskList();\n     List\u003cContainerId\u003e release \u003d request.getReleaseList();\n \n     ResourceBlacklistRequest blacklistRequest \u003d\n         request.getResourceBlacklistRequest();\n     List\u003cString\u003e blacklistAdditions \u003d\n         (blacklistRequest !\u003d null) ?\n             blacklistRequest.getBlacklistAdditions() : Collections.EMPTY_LIST;\n     List\u003cString\u003e blacklistRemovals \u003d\n         (blacklistRequest !\u003d null) ?\n             blacklistRequest.getBlacklistRemovals() : Collections.EMPTY_LIST;\n     RMApp app \u003d\n-        this.rmContext.getRMApps().get(appAttemptId.getApplicationId());\n+        getRmContext().getRMApps().get(appAttemptId.getApplicationId());\n \n     // set label expression for Resource Requests if resourceName\u003dANY\n     ApplicationSubmissionContext asc \u003d app.getApplicationSubmissionContext();\n     for (ResourceRequest req : ask) {\n       if (null \u003d\u003d req.getNodeLabelExpression()\n           \u0026\u0026 ResourceRequest.ANY.equals(req.getResourceName())) {\n         req.setNodeLabelExpression(asc.getNodeLabelExpression());\n       }\n     }\n \n-    Resource maximumCapacity \u003d rScheduler.getMaximumResourceCapability();\n+    Resource maximumCapacity \u003d getScheduler().getMaximumResourceCapability();\n \n     // sanity check\n     try {\n       RMServerUtils.normalizeAndValidateRequests(ask,\n           maximumCapacity, app.getQueue(),\n-          rScheduler, rmContext);\n+          getScheduler(), getRmContext());\n     } catch (InvalidResourceRequestException e) {\n       LOG.warn(\"Invalid resource ask by application \" + appAttemptId, e);\n       throw e;\n     }\n \n     try {\n       RMServerUtils.validateBlacklistRequest(blacklistRequest);\n     }  catch (InvalidResourceBlacklistRequestException e) {\n       LOG.warn(\"Invalid blacklist request by application \" + appAttemptId, e);\n       throw e;\n     }\n \n     // In the case of work-preserving AM restart, it\u0027s possible for the\n     // AM to release containers from the earlier attempt.\n     if (!app.getApplicationSubmissionContext()\n         .getKeepContainersAcrossApplicationAttempts()) {\n       try {\n         RMServerUtils.validateContainerReleaseRequest(release, appAttemptId);\n       } catch (InvalidContainerReleaseException e) {\n         LOG.warn(\"Invalid container release by application \" + appAttemptId,\n             e);\n         throw e;\n       }\n     }\n \n     // Split Update Resource Requests into increase and decrease.\n     // No Exceptions are thrown here. All update errors are aggregated\n     // and returned to the AM.\n     List\u003cUpdateContainerError\u003e updateErrors \u003d new ArrayList\u003c\u003e();\n     ContainerUpdates containerUpdateRequests \u003d\n         RMServerUtils.validateAndSplitUpdateResourceRequests(\n-        rmContext, request, maximumCapacity, updateErrors);\n+            getRmContext(), request, maximumCapacity, updateErrors);\n \n     // Send new requests to appAttempt.\n     Allocation allocation;\n     RMAppAttemptState state \u003d\n         app.getRMAppAttempt(appAttemptId).getAppAttemptState();\n     if (state.equals(RMAppAttemptState.FINAL_SAVING) ||\n         state.equals(RMAppAttemptState.FINISHING) ||\n         app.isAppFinalStateStored()) {\n       LOG.warn(appAttemptId + \" is in \" + state +\n-               \" state, ignore container allocate request.\");\n+          \" state, ignore container allocate request.\");\n       allocation \u003d EMPTY_ALLOCATION;\n     } else {\n       allocation \u003d\n-          this.rScheduler.allocate(appAttemptId, ask, release,\n+          getScheduler().allocate(appAttemptId, ask, release,\n               blacklistAdditions, blacklistRemovals,\n               containerUpdateRequests);\n     }\n \n     if (!blacklistAdditions.isEmpty() || !blacklistRemovals.isEmpty()) {\n       LOG.info(\"blacklist are updated in Scheduler.\" +\n           \"blacklistAdditions: \" + blacklistAdditions + \", \" +\n           \"blacklistRemovals: \" + blacklistRemovals);\n     }\n     RMAppAttempt appAttempt \u003d app.getRMAppAttempt(appAttemptId);\n+    AllocateResponse allocateResponse \u003d\n+        recordFactory.newRecordInstance(AllocateResponse.class);\n \n     if (allocation.getNMTokens() !\u003d null \u0026\u0026\n         !allocation.getNMTokens().isEmpty()) {\n       allocateResponse.setNMTokens(allocation.getNMTokens());\n     }\n \n     // Notify the AM of container update errors\n-    addToUpdateContainerErrors(allocateResponse, updateErrors);\n+    ApplicationMasterServiceUtils.addToUpdateContainerErrors(\n+        allocateResponse, updateErrors);\n \n     // update the response with the deltas of node status changes\n-    List\u003cRMNode\u003e updatedNodes \u003d new ArrayList\u003cRMNode\u003e();\n-    if(app.pullRMNodeUpdates(updatedNodes) \u003e 0) {\n-      List\u003cNodeReport\u003e updatedNodeReports \u003d new ArrayList\u003cNodeReport\u003e();\n-      for(RMNode rmNode: updatedNodes) {\n-        SchedulerNodeReport schedulerNodeReport \u003d\n-            rScheduler.getNodeReport(rmNode.getNodeID());\n-        Resource used \u003d BuilderUtils.newResource(0, 0);\n-        int numContainers \u003d 0;\n-        if (schedulerNodeReport !\u003d null) {\n-          used \u003d schedulerNodeReport.getUsedResource();\n-          numContainers \u003d schedulerNodeReport.getNumContainers();\n-        }\n-        NodeId nodeId \u003d rmNode.getNodeID();\n-        NodeReport report \u003d\n-            BuilderUtils.newNodeReport(nodeId, rmNode.getState(),\n-                rmNode.getHttpAddress(), rmNode.getRackName(), used,\n-                rmNode.getTotalCapability(), numContainers,\n-                rmNode.getHealthReport(), rmNode.getLastHealthReportTime(),\n-                rmNode.getNodeLabels());\n+    handleNodeUpdates(app, allocateResponse);\n \n-        updatedNodeReports.add(report);\n-      }\n-      allocateResponse.setUpdatedNodes(updatedNodeReports);\n-    }\n-\n-    addToAllocatedContainers(allocateResponse, allocation.getContainers());\n+    ApplicationMasterServiceUtils.addToAllocatedContainers(\n+        allocateResponse, allocation.getContainers());\n \n     allocateResponse.setCompletedContainersStatuses(appAttempt\n         .pullJustFinishedContainers());\n     allocateResponse.setAvailableResources(allocation.getResourceLimit());\n \n-    addToContainerUpdates(appAttemptId, allocateResponse, allocation);\n+    addToContainerUpdates(allocateResponse, allocation,\n+        ((AbstractYarnScheduler)getScheduler())\n+            .getApplicationAttempt(appAttemptId).pullUpdateContainerErrors());\n \n-    allocateResponse.setNumClusterNodes(this.rScheduler.getNumClusterNodes());\n+    allocateResponse.setNumClusterNodes(getScheduler().getNumClusterNodes());\n \n     // add collector address for this application\n-    if (YarnConfiguration.timelineServiceV2Enabled(getConfig())) {\n+    if (YarnConfiguration.timelineServiceV2Enabled(\n+        getRmContext().getYarnConfiguration())) {\n       allocateResponse.setCollectorAddr(\n-          this.rmContext.getRMApps().get(appAttemptId.getApplicationId())\n+          getRmContext().getRMApps().get(appAttemptId.getApplicationId())\n               .getCollectorAddr());\n     }\n \n     // add preemption to the allocateResponse message (if any)\n     allocateResponse\n         .setPreemptionMessage(generatePreemptionMessage(allocation));\n \n     // Set application priority\n     allocateResponse.setApplicationPriority(app\n         .getApplicationPriority());\n+    return allocateResponse;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public AllocateResponse allocate(ApplicationAttemptId appAttemptId,\n      AllocateRequest request) throws YarnException {\n\n    handleProgress(appAttemptId, request);\n\n    List\u003cResourceRequest\u003e ask \u003d request.getAskList();\n    List\u003cContainerId\u003e release \u003d request.getReleaseList();\n\n    ResourceBlacklistRequest blacklistRequest \u003d\n        request.getResourceBlacklistRequest();\n    List\u003cString\u003e blacklistAdditions \u003d\n        (blacklistRequest !\u003d null) ?\n            blacklistRequest.getBlacklistAdditions() : Collections.EMPTY_LIST;\n    List\u003cString\u003e blacklistRemovals \u003d\n        (blacklistRequest !\u003d null) ?\n            blacklistRequest.getBlacklistRemovals() : Collections.EMPTY_LIST;\n    RMApp app \u003d\n        getRmContext().getRMApps().get(appAttemptId.getApplicationId());\n\n    // set label expression for Resource Requests if resourceName\u003dANY\n    ApplicationSubmissionContext asc \u003d app.getApplicationSubmissionContext();\n    for (ResourceRequest req : ask) {\n      if (null \u003d\u003d req.getNodeLabelExpression()\n          \u0026\u0026 ResourceRequest.ANY.equals(req.getResourceName())) {\n        req.setNodeLabelExpression(asc.getNodeLabelExpression());\n      }\n    }\n\n    Resource maximumCapacity \u003d getScheduler().getMaximumResourceCapability();\n\n    // sanity check\n    try {\n      RMServerUtils.normalizeAndValidateRequests(ask,\n          maximumCapacity, app.getQueue(),\n          getScheduler(), getRmContext());\n    } catch (InvalidResourceRequestException e) {\n      LOG.warn(\"Invalid resource ask by application \" + appAttemptId, e);\n      throw e;\n    }\n\n    try {\n      RMServerUtils.validateBlacklistRequest(blacklistRequest);\n    }  catch (InvalidResourceBlacklistRequestException e) {\n      LOG.warn(\"Invalid blacklist request by application \" + appAttemptId, e);\n      throw e;\n    }\n\n    // In the case of work-preserving AM restart, it\u0027s possible for the\n    // AM to release containers from the earlier attempt.\n    if (!app.getApplicationSubmissionContext()\n        .getKeepContainersAcrossApplicationAttempts()) {\n      try {\n        RMServerUtils.validateContainerReleaseRequest(release, appAttemptId);\n      } catch (InvalidContainerReleaseException e) {\n        LOG.warn(\"Invalid container release by application \" + appAttemptId,\n            e);\n        throw e;\n      }\n    }\n\n    // Split Update Resource Requests into increase and decrease.\n    // No Exceptions are thrown here. All update errors are aggregated\n    // and returned to the AM.\n    List\u003cUpdateContainerError\u003e updateErrors \u003d new ArrayList\u003c\u003e();\n    ContainerUpdates containerUpdateRequests \u003d\n        RMServerUtils.validateAndSplitUpdateResourceRequests(\n            getRmContext(), request, maximumCapacity, updateErrors);\n\n    // Send new requests to appAttempt.\n    Allocation allocation;\n    RMAppAttemptState state \u003d\n        app.getRMAppAttempt(appAttemptId).getAppAttemptState();\n    if (state.equals(RMAppAttemptState.FINAL_SAVING) ||\n        state.equals(RMAppAttemptState.FINISHING) ||\n        app.isAppFinalStateStored()) {\n      LOG.warn(appAttemptId + \" is in \" + state +\n          \" state, ignore container allocate request.\");\n      allocation \u003d EMPTY_ALLOCATION;\n    } else {\n      allocation \u003d\n          getScheduler().allocate(appAttemptId, ask, release,\n              blacklistAdditions, blacklistRemovals,\n              containerUpdateRequests);\n    }\n\n    if (!blacklistAdditions.isEmpty() || !blacklistRemovals.isEmpty()) {\n      LOG.info(\"blacklist are updated in Scheduler.\" +\n          \"blacklistAdditions: \" + blacklistAdditions + \", \" +\n          \"blacklistRemovals: \" + blacklistRemovals);\n    }\n    RMAppAttempt appAttempt \u003d app.getRMAppAttempt(appAttemptId);\n    AllocateResponse allocateResponse \u003d\n        recordFactory.newRecordInstance(AllocateResponse.class);\n\n    if (allocation.getNMTokens() !\u003d null \u0026\u0026\n        !allocation.getNMTokens().isEmpty()) {\n      allocateResponse.setNMTokens(allocation.getNMTokens());\n    }\n\n    // Notify the AM of container update errors\n    ApplicationMasterServiceUtils.addToUpdateContainerErrors(\n        allocateResponse, updateErrors);\n\n    // update the response with the deltas of node status changes\n    handleNodeUpdates(app, allocateResponse);\n\n    ApplicationMasterServiceUtils.addToAllocatedContainers(\n        allocateResponse, allocation.getContainers());\n\n    allocateResponse.setCompletedContainersStatuses(appAttempt\n        .pullJustFinishedContainers());\n    allocateResponse.setAvailableResources(allocation.getResourceLimit());\n\n    addToContainerUpdates(allocateResponse, allocation,\n        ((AbstractYarnScheduler)getScheduler())\n            .getApplicationAttempt(appAttemptId).pullUpdateContainerErrors());\n\n    allocateResponse.setNumClusterNodes(getScheduler().getNumClusterNodes());\n\n    // add collector address for this application\n    if (YarnConfiguration.timelineServiceV2Enabled(\n        getRmContext().getYarnConfiguration())) {\n      allocateResponse.setCollectorAddr(\n          getRmContext().getRMApps().get(appAttemptId.getApplicationId())\n              .getCollectorAddr());\n    }\n\n    // add preemption to the allocateResponse message (if any)\n    allocateResponse\n        .setPreemptionMessage(generatePreemptionMessage(allocation));\n\n    // Set application priority\n    allocateResponse.setApplicationPriority(app\n        .getApplicationPriority());\n    return allocateResponse;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/DefaultAMSProcessor.java",
          "extendedDetails": {
            "oldValue": "allocateInternal",
            "newValue": "allocate"
          }
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-6776. Refactor ApplicaitonMasterService to move actual processing logic to a separate class. (asuresh)\n",
          "commitDate": "10/07/17 2:34 PM",
          "commitName": "5496a34c0cb2b1a83cfa6b0aba5a77b05ff2d8f0",
          "commitAuthor": "Arun Suresh",
          "commitDateOld": "10/07/17 3:53 AM",
          "commitNameOld": "09653ea098a17fddcf111b0da289085915c351d1",
          "commitAuthorOld": "Steve Loughran",
          "daysBetweenCommits": 0.45,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,166 +1,136 @@\n-  protected void allocateInternal(ApplicationAttemptId appAttemptId,\n-      AllocateRequest request, AllocateResponse allocateResponse)\n-      throws YarnException {\n+  public AllocateResponse allocate(ApplicationAttemptId appAttemptId,\n+      AllocateRequest request) throws YarnException {\n \n-    //filter illegal progress values\n-    float filteredProgress \u003d request.getProgress();\n-    if (Float.isNaN(filteredProgress) ||\n-        filteredProgress \u003d\u003d Float.NEGATIVE_INFINITY ||\n-        filteredProgress \u003c 0) {\n-      request.setProgress(0);\n-    } else if (filteredProgress \u003e 1 ||\n-        filteredProgress \u003d\u003d Float.POSITIVE_INFINITY) {\n-      request.setProgress(1);\n-    }\n-\n-    // Send the status update to the appAttempt.\n-    this.rmContext.getDispatcher().getEventHandler().handle(\n-        new RMAppAttemptStatusupdateEvent(appAttemptId, request\n-            .getProgress()));\n+    handleProgress(appAttemptId, request);\n \n     List\u003cResourceRequest\u003e ask \u003d request.getAskList();\n     List\u003cContainerId\u003e release \u003d request.getReleaseList();\n \n     ResourceBlacklistRequest blacklistRequest \u003d\n         request.getResourceBlacklistRequest();\n     List\u003cString\u003e blacklistAdditions \u003d\n         (blacklistRequest !\u003d null) ?\n             blacklistRequest.getBlacklistAdditions() : Collections.EMPTY_LIST;\n     List\u003cString\u003e blacklistRemovals \u003d\n         (blacklistRequest !\u003d null) ?\n             blacklistRequest.getBlacklistRemovals() : Collections.EMPTY_LIST;\n     RMApp app \u003d\n-        this.rmContext.getRMApps().get(appAttemptId.getApplicationId());\n+        getRmContext().getRMApps().get(appAttemptId.getApplicationId());\n \n     // set label expression for Resource Requests if resourceName\u003dANY\n     ApplicationSubmissionContext asc \u003d app.getApplicationSubmissionContext();\n     for (ResourceRequest req : ask) {\n       if (null \u003d\u003d req.getNodeLabelExpression()\n           \u0026\u0026 ResourceRequest.ANY.equals(req.getResourceName())) {\n         req.setNodeLabelExpression(asc.getNodeLabelExpression());\n       }\n     }\n \n-    Resource maximumCapacity \u003d rScheduler.getMaximumResourceCapability();\n+    Resource maximumCapacity \u003d getScheduler().getMaximumResourceCapability();\n \n     // sanity check\n     try {\n       RMServerUtils.normalizeAndValidateRequests(ask,\n           maximumCapacity, app.getQueue(),\n-          rScheduler, rmContext);\n+          getScheduler(), getRmContext());\n     } catch (InvalidResourceRequestException e) {\n       LOG.warn(\"Invalid resource ask by application \" + appAttemptId, e);\n       throw e;\n     }\n \n     try {\n       RMServerUtils.validateBlacklistRequest(blacklistRequest);\n     }  catch (InvalidResourceBlacklistRequestException e) {\n       LOG.warn(\"Invalid blacklist request by application \" + appAttemptId, e);\n       throw e;\n     }\n \n     // In the case of work-preserving AM restart, it\u0027s possible for the\n     // AM to release containers from the earlier attempt.\n     if (!app.getApplicationSubmissionContext()\n         .getKeepContainersAcrossApplicationAttempts()) {\n       try {\n         RMServerUtils.validateContainerReleaseRequest(release, appAttemptId);\n       } catch (InvalidContainerReleaseException e) {\n         LOG.warn(\"Invalid container release by application \" + appAttemptId,\n             e);\n         throw e;\n       }\n     }\n \n     // Split Update Resource Requests into increase and decrease.\n     // No Exceptions are thrown here. All update errors are aggregated\n     // and returned to the AM.\n     List\u003cUpdateContainerError\u003e updateErrors \u003d new ArrayList\u003c\u003e();\n     ContainerUpdates containerUpdateRequests \u003d\n         RMServerUtils.validateAndSplitUpdateResourceRequests(\n-        rmContext, request, maximumCapacity, updateErrors);\n+            getRmContext(), request, maximumCapacity, updateErrors);\n \n     // Send new requests to appAttempt.\n     Allocation allocation;\n     RMAppAttemptState state \u003d\n         app.getRMAppAttempt(appAttemptId).getAppAttemptState();\n     if (state.equals(RMAppAttemptState.FINAL_SAVING) ||\n         state.equals(RMAppAttemptState.FINISHING) ||\n         app.isAppFinalStateStored()) {\n       LOG.warn(appAttemptId + \" is in \" + state +\n-               \" state, ignore container allocate request.\");\n+          \" state, ignore container allocate request.\");\n       allocation \u003d EMPTY_ALLOCATION;\n     } else {\n       allocation \u003d\n-          this.rScheduler.allocate(appAttemptId, ask, release,\n+          getScheduler().allocate(appAttemptId, ask, release,\n               blacklistAdditions, blacklistRemovals,\n               containerUpdateRequests);\n     }\n \n     if (!blacklistAdditions.isEmpty() || !blacklistRemovals.isEmpty()) {\n       LOG.info(\"blacklist are updated in Scheduler.\" +\n           \"blacklistAdditions: \" + blacklistAdditions + \", \" +\n           \"blacklistRemovals: \" + blacklistRemovals);\n     }\n     RMAppAttempt appAttempt \u003d app.getRMAppAttempt(appAttemptId);\n+    AllocateResponse allocateResponse \u003d\n+        recordFactory.newRecordInstance(AllocateResponse.class);\n \n     if (allocation.getNMTokens() !\u003d null \u0026\u0026\n         !allocation.getNMTokens().isEmpty()) {\n       allocateResponse.setNMTokens(allocation.getNMTokens());\n     }\n \n     // Notify the AM of container update errors\n-    addToUpdateContainerErrors(allocateResponse, updateErrors);\n+    ApplicationMasterServiceUtils.addToUpdateContainerErrors(\n+        allocateResponse, updateErrors);\n \n     // update the response with the deltas of node status changes\n-    List\u003cRMNode\u003e updatedNodes \u003d new ArrayList\u003cRMNode\u003e();\n-    if(app.pullRMNodeUpdates(updatedNodes) \u003e 0) {\n-      List\u003cNodeReport\u003e updatedNodeReports \u003d new ArrayList\u003cNodeReport\u003e();\n-      for(RMNode rmNode: updatedNodes) {\n-        SchedulerNodeReport schedulerNodeReport \u003d\n-            rScheduler.getNodeReport(rmNode.getNodeID());\n-        Resource used \u003d BuilderUtils.newResource(0, 0);\n-        int numContainers \u003d 0;\n-        if (schedulerNodeReport !\u003d null) {\n-          used \u003d schedulerNodeReport.getUsedResource();\n-          numContainers \u003d schedulerNodeReport.getNumContainers();\n-        }\n-        NodeId nodeId \u003d rmNode.getNodeID();\n-        NodeReport report \u003d\n-            BuilderUtils.newNodeReport(nodeId, rmNode.getState(),\n-                rmNode.getHttpAddress(), rmNode.getRackName(), used,\n-                rmNode.getTotalCapability(), numContainers,\n-                rmNode.getHealthReport(), rmNode.getLastHealthReportTime(),\n-                rmNode.getNodeLabels());\n+    handleNodeUpdates(app, allocateResponse);\n \n-        updatedNodeReports.add(report);\n-      }\n-      allocateResponse.setUpdatedNodes(updatedNodeReports);\n-    }\n-\n-    addToAllocatedContainers(allocateResponse, allocation.getContainers());\n+    ApplicationMasterServiceUtils.addToAllocatedContainers(\n+        allocateResponse, allocation.getContainers());\n \n     allocateResponse.setCompletedContainersStatuses(appAttempt\n         .pullJustFinishedContainers());\n     allocateResponse.setAvailableResources(allocation.getResourceLimit());\n \n-    addToContainerUpdates(appAttemptId, allocateResponse, allocation);\n+    addToContainerUpdates(allocateResponse, allocation,\n+        ((AbstractYarnScheduler)getScheduler())\n+            .getApplicationAttempt(appAttemptId).pullUpdateContainerErrors());\n \n-    allocateResponse.setNumClusterNodes(this.rScheduler.getNumClusterNodes());\n+    allocateResponse.setNumClusterNodes(getScheduler().getNumClusterNodes());\n \n     // add collector address for this application\n-    if (YarnConfiguration.timelineServiceV2Enabled(getConfig())) {\n+    if (YarnConfiguration.timelineServiceV2Enabled(\n+        getRmContext().getYarnConfiguration())) {\n       allocateResponse.setCollectorAddr(\n-          this.rmContext.getRMApps().get(appAttemptId.getApplicationId())\n+          getRmContext().getRMApps().get(appAttemptId.getApplicationId())\n               .getCollectorAddr());\n     }\n \n     // add preemption to the allocateResponse message (if any)\n     allocateResponse\n         .setPreemptionMessage(generatePreemptionMessage(allocation));\n \n     // Set application priority\n     allocateResponse.setApplicationPriority(app\n         .getApplicationPriority());\n+    return allocateResponse;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public AllocateResponse allocate(ApplicationAttemptId appAttemptId,\n      AllocateRequest request) throws YarnException {\n\n    handleProgress(appAttemptId, request);\n\n    List\u003cResourceRequest\u003e ask \u003d request.getAskList();\n    List\u003cContainerId\u003e release \u003d request.getReleaseList();\n\n    ResourceBlacklistRequest blacklistRequest \u003d\n        request.getResourceBlacklistRequest();\n    List\u003cString\u003e blacklistAdditions \u003d\n        (blacklistRequest !\u003d null) ?\n            blacklistRequest.getBlacklistAdditions() : Collections.EMPTY_LIST;\n    List\u003cString\u003e blacklistRemovals \u003d\n        (blacklistRequest !\u003d null) ?\n            blacklistRequest.getBlacklistRemovals() : Collections.EMPTY_LIST;\n    RMApp app \u003d\n        getRmContext().getRMApps().get(appAttemptId.getApplicationId());\n\n    // set label expression for Resource Requests if resourceName\u003dANY\n    ApplicationSubmissionContext asc \u003d app.getApplicationSubmissionContext();\n    for (ResourceRequest req : ask) {\n      if (null \u003d\u003d req.getNodeLabelExpression()\n          \u0026\u0026 ResourceRequest.ANY.equals(req.getResourceName())) {\n        req.setNodeLabelExpression(asc.getNodeLabelExpression());\n      }\n    }\n\n    Resource maximumCapacity \u003d getScheduler().getMaximumResourceCapability();\n\n    // sanity check\n    try {\n      RMServerUtils.normalizeAndValidateRequests(ask,\n          maximumCapacity, app.getQueue(),\n          getScheduler(), getRmContext());\n    } catch (InvalidResourceRequestException e) {\n      LOG.warn(\"Invalid resource ask by application \" + appAttemptId, e);\n      throw e;\n    }\n\n    try {\n      RMServerUtils.validateBlacklistRequest(blacklistRequest);\n    }  catch (InvalidResourceBlacklistRequestException e) {\n      LOG.warn(\"Invalid blacklist request by application \" + appAttemptId, e);\n      throw e;\n    }\n\n    // In the case of work-preserving AM restart, it\u0027s possible for the\n    // AM to release containers from the earlier attempt.\n    if (!app.getApplicationSubmissionContext()\n        .getKeepContainersAcrossApplicationAttempts()) {\n      try {\n        RMServerUtils.validateContainerReleaseRequest(release, appAttemptId);\n      } catch (InvalidContainerReleaseException e) {\n        LOG.warn(\"Invalid container release by application \" + appAttemptId,\n            e);\n        throw e;\n      }\n    }\n\n    // Split Update Resource Requests into increase and decrease.\n    // No Exceptions are thrown here. All update errors are aggregated\n    // and returned to the AM.\n    List\u003cUpdateContainerError\u003e updateErrors \u003d new ArrayList\u003c\u003e();\n    ContainerUpdates containerUpdateRequests \u003d\n        RMServerUtils.validateAndSplitUpdateResourceRequests(\n            getRmContext(), request, maximumCapacity, updateErrors);\n\n    // Send new requests to appAttempt.\n    Allocation allocation;\n    RMAppAttemptState state \u003d\n        app.getRMAppAttempt(appAttemptId).getAppAttemptState();\n    if (state.equals(RMAppAttemptState.FINAL_SAVING) ||\n        state.equals(RMAppAttemptState.FINISHING) ||\n        app.isAppFinalStateStored()) {\n      LOG.warn(appAttemptId + \" is in \" + state +\n          \" state, ignore container allocate request.\");\n      allocation \u003d EMPTY_ALLOCATION;\n    } else {\n      allocation \u003d\n          getScheduler().allocate(appAttemptId, ask, release,\n              blacklistAdditions, blacklistRemovals,\n              containerUpdateRequests);\n    }\n\n    if (!blacklistAdditions.isEmpty() || !blacklistRemovals.isEmpty()) {\n      LOG.info(\"blacklist are updated in Scheduler.\" +\n          \"blacklistAdditions: \" + blacklistAdditions + \", \" +\n          \"blacklistRemovals: \" + blacklistRemovals);\n    }\n    RMAppAttempt appAttempt \u003d app.getRMAppAttempt(appAttemptId);\n    AllocateResponse allocateResponse \u003d\n        recordFactory.newRecordInstance(AllocateResponse.class);\n\n    if (allocation.getNMTokens() !\u003d null \u0026\u0026\n        !allocation.getNMTokens().isEmpty()) {\n      allocateResponse.setNMTokens(allocation.getNMTokens());\n    }\n\n    // Notify the AM of container update errors\n    ApplicationMasterServiceUtils.addToUpdateContainerErrors(\n        allocateResponse, updateErrors);\n\n    // update the response with the deltas of node status changes\n    handleNodeUpdates(app, allocateResponse);\n\n    ApplicationMasterServiceUtils.addToAllocatedContainers(\n        allocateResponse, allocation.getContainers());\n\n    allocateResponse.setCompletedContainersStatuses(appAttempt\n        .pullJustFinishedContainers());\n    allocateResponse.setAvailableResources(allocation.getResourceLimit());\n\n    addToContainerUpdates(allocateResponse, allocation,\n        ((AbstractYarnScheduler)getScheduler())\n            .getApplicationAttempt(appAttemptId).pullUpdateContainerErrors());\n\n    allocateResponse.setNumClusterNodes(getScheduler().getNumClusterNodes());\n\n    // add collector address for this application\n    if (YarnConfiguration.timelineServiceV2Enabled(\n        getRmContext().getYarnConfiguration())) {\n      allocateResponse.setCollectorAddr(\n          getRmContext().getRMApps().get(appAttemptId.getApplicationId())\n              .getCollectorAddr());\n    }\n\n    // add preemption to the allocateResponse message (if any)\n    allocateResponse\n        .setPreemptionMessage(generatePreemptionMessage(allocation));\n\n    // Set application priority\n    allocateResponse.setApplicationPriority(app\n        .getApplicationPriority());\n    return allocateResponse;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/DefaultAMSProcessor.java",
          "extendedDetails": {
            "oldValue": "[appAttemptId-ApplicationAttemptId, request-AllocateRequest, allocateResponse-AllocateResponse]",
            "newValue": "[appAttemptId-ApplicationAttemptId, request-AllocateRequest]"
          }
        }
      ]
    },
    "0a55bd841ec0f2eb89a0383f4c589526e8b138d4": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5959. RM changes to support change of container ExecutionType. (Arun Suresh via wangda)\n",
      "commitDate": "05/01/17 10:31 AM",
      "commitName": "0a55bd841ec0f2eb89a0383f4c589526e8b138d4",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "27/12/16 12:40 PM",
      "commitNameOld": "ac1e5d4f77e3b9df8dcacb0b1f72eecc27931eb8",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 8.91,
      "commitsBetweenForRepo": 37,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,176 +1,166 @@\n   protected void allocateInternal(ApplicationAttemptId appAttemptId,\n       AllocateRequest request, AllocateResponse allocateResponse)\n       throws YarnException {\n \n     //filter illegal progress values\n     float filteredProgress \u003d request.getProgress();\n     if (Float.isNaN(filteredProgress) ||\n         filteredProgress \u003d\u003d Float.NEGATIVE_INFINITY ||\n         filteredProgress \u003c 0) {\n       request.setProgress(0);\n     } else if (filteredProgress \u003e 1 ||\n         filteredProgress \u003d\u003d Float.POSITIVE_INFINITY) {\n       request.setProgress(1);\n     }\n \n     // Send the status update to the appAttempt.\n     this.rmContext.getDispatcher().getEventHandler().handle(\n         new RMAppAttemptStatusupdateEvent(appAttemptId, request\n             .getProgress()));\n \n     List\u003cResourceRequest\u003e ask \u003d request.getAskList();\n     List\u003cContainerId\u003e release \u003d request.getReleaseList();\n \n     ResourceBlacklistRequest blacklistRequest \u003d\n         request.getResourceBlacklistRequest();\n     List\u003cString\u003e blacklistAdditions \u003d\n         (blacklistRequest !\u003d null) ?\n             blacklistRequest.getBlacklistAdditions() : Collections.EMPTY_LIST;\n     List\u003cString\u003e blacklistRemovals \u003d\n         (blacklistRequest !\u003d null) ?\n             blacklistRequest.getBlacklistRemovals() : Collections.EMPTY_LIST;\n     RMApp app \u003d\n         this.rmContext.getRMApps().get(appAttemptId.getApplicationId());\n \n     // set label expression for Resource Requests if resourceName\u003dANY\n     ApplicationSubmissionContext asc \u003d app.getApplicationSubmissionContext();\n     for (ResourceRequest req : ask) {\n       if (null \u003d\u003d req.getNodeLabelExpression()\n           \u0026\u0026 ResourceRequest.ANY.equals(req.getResourceName())) {\n         req.setNodeLabelExpression(asc.getNodeLabelExpression());\n       }\n     }\n \n     Resource maximumCapacity \u003d rScheduler.getMaximumResourceCapability();\n \n     // sanity check\n     try {\n       RMServerUtils.normalizeAndValidateRequests(ask,\n           maximumCapacity, app.getQueue(),\n           rScheduler, rmContext);\n     } catch (InvalidResourceRequestException e) {\n       LOG.warn(\"Invalid resource ask by application \" + appAttemptId, e);\n       throw e;\n     }\n \n     try {\n       RMServerUtils.validateBlacklistRequest(blacklistRequest);\n     }  catch (InvalidResourceBlacklistRequestException e) {\n       LOG.warn(\"Invalid blacklist request by application \" + appAttemptId, e);\n       throw e;\n     }\n \n     // In the case of work-preserving AM restart, it\u0027s possible for the\n     // AM to release containers from the earlier attempt.\n     if (!app.getApplicationSubmissionContext()\n         .getKeepContainersAcrossApplicationAttempts()) {\n       try {\n         RMServerUtils.validateContainerReleaseRequest(release, appAttemptId);\n       } catch (InvalidContainerReleaseException e) {\n         LOG.warn(\"Invalid container release by application \" + appAttemptId,\n             e);\n         throw e;\n       }\n     }\n \n     // Split Update Resource Requests into increase and decrease.\n     // No Exceptions are thrown here. All update errors are aggregated\n     // and returned to the AM.\n-    List\u003cUpdateContainerRequest\u003e increaseResourceReqs \u003d new ArrayList\u003c\u003e();\n-    List\u003cUpdateContainerRequest\u003e decreaseResourceReqs \u003d new ArrayList\u003c\u003e();\n-    List\u003cUpdateContainerError\u003e updateContainerErrors \u003d\n+    List\u003cUpdateContainerError\u003e updateErrors \u003d new ArrayList\u003c\u003e();\n+    ContainerUpdates containerUpdateRequests \u003d\n         RMServerUtils.validateAndSplitUpdateResourceRequests(\n-            rmContext, request, maximumCapacity,\n-            increaseResourceReqs, decreaseResourceReqs);\n+        rmContext, request, maximumCapacity, updateErrors);\n \n     // Send new requests to appAttempt.\n     Allocation allocation;\n     RMAppAttemptState state \u003d\n         app.getRMAppAttempt(appAttemptId).getAppAttemptState();\n     if (state.equals(RMAppAttemptState.FINAL_SAVING) ||\n         state.equals(RMAppAttemptState.FINISHING) ||\n         app.isAppFinalStateStored()) {\n       LOG.warn(appAttemptId + \" is in \" + state +\n                \" state, ignore container allocate request.\");\n       allocation \u003d EMPTY_ALLOCATION;\n     } else {\n       allocation \u003d\n           this.rScheduler.allocate(appAttemptId, ask, release,\n               blacklistAdditions, blacklistRemovals,\n-              increaseResourceReqs, decreaseResourceReqs);\n+              containerUpdateRequests);\n     }\n \n     if (!blacklistAdditions.isEmpty() || !blacklistRemovals.isEmpty()) {\n       LOG.info(\"blacklist are updated in Scheduler.\" +\n           \"blacklistAdditions: \" + blacklistAdditions + \", \" +\n           \"blacklistRemovals: \" + blacklistRemovals);\n     }\n     RMAppAttempt appAttempt \u003d app.getRMAppAttempt(appAttemptId);\n \n     if (allocation.getNMTokens() !\u003d null \u0026\u0026\n         !allocation.getNMTokens().isEmpty()) {\n       allocateResponse.setNMTokens(allocation.getNMTokens());\n     }\n \n     // Notify the AM of container update errors\n-    addToUpdateContainerErrors(allocateResponse, updateContainerErrors);\n+    addToUpdateContainerErrors(allocateResponse, updateErrors);\n \n     // update the response with the deltas of node status changes\n     List\u003cRMNode\u003e updatedNodes \u003d new ArrayList\u003cRMNode\u003e();\n     if(app.pullRMNodeUpdates(updatedNodes) \u003e 0) {\n       List\u003cNodeReport\u003e updatedNodeReports \u003d new ArrayList\u003cNodeReport\u003e();\n       for(RMNode rmNode: updatedNodes) {\n         SchedulerNodeReport schedulerNodeReport \u003d\n             rScheduler.getNodeReport(rmNode.getNodeID());\n         Resource used \u003d BuilderUtils.newResource(0, 0);\n         int numContainers \u003d 0;\n         if (schedulerNodeReport !\u003d null) {\n           used \u003d schedulerNodeReport.getUsedResource();\n           numContainers \u003d schedulerNodeReport.getNumContainers();\n         }\n         NodeId nodeId \u003d rmNode.getNodeID();\n         NodeReport report \u003d\n             BuilderUtils.newNodeReport(nodeId, rmNode.getState(),\n                 rmNode.getHttpAddress(), rmNode.getRackName(), used,\n                 rmNode.getTotalCapability(), numContainers,\n                 rmNode.getHealthReport(), rmNode.getLastHealthReportTime(),\n                 rmNode.getNodeLabels());\n \n         updatedNodeReports.add(report);\n       }\n       allocateResponse.setUpdatedNodes(updatedNodeReports);\n     }\n \n     addToAllocatedContainers(allocateResponse, allocation.getContainers());\n \n     allocateResponse.setCompletedContainersStatuses(appAttempt\n         .pullJustFinishedContainers());\n     allocateResponse.setAvailableResources(allocation.getResourceLimit());\n \n-    // Handling increased containers\n-    addToUpdatedContainers(\n-        allocateResponse, ContainerUpdateType.INCREASE_RESOURCE,\n-        allocation.getIncreasedContainers());\n-\n-    // Handling decreased containers\n-    addToUpdatedContainers(\n-        allocateResponse, ContainerUpdateType.DECREASE_RESOURCE,\n-        allocation.getDecreasedContainers());\n+    addToContainerUpdates(appAttemptId, allocateResponse, allocation);\n \n     allocateResponse.setNumClusterNodes(this.rScheduler.getNumClusterNodes());\n \n     // add collector address for this application\n     if (YarnConfiguration.timelineServiceV2Enabled(getConfig())) {\n       allocateResponse.setCollectorAddr(\n           this.rmContext.getRMApps().get(appAttemptId.getApplicationId())\n               .getCollectorAddr());\n     }\n \n     // add preemption to the allocateResponse message (if any)\n     allocateResponse\n         .setPreemptionMessage(generatePreemptionMessage(allocation));\n \n     // Set application priority\n     allocateResponse.setApplicationPriority(app\n         .getApplicationPriority());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void allocateInternal(ApplicationAttemptId appAttemptId,\n      AllocateRequest request, AllocateResponse allocateResponse)\n      throws YarnException {\n\n    //filter illegal progress values\n    float filteredProgress \u003d request.getProgress();\n    if (Float.isNaN(filteredProgress) ||\n        filteredProgress \u003d\u003d Float.NEGATIVE_INFINITY ||\n        filteredProgress \u003c 0) {\n      request.setProgress(0);\n    } else if (filteredProgress \u003e 1 ||\n        filteredProgress \u003d\u003d Float.POSITIVE_INFINITY) {\n      request.setProgress(1);\n    }\n\n    // Send the status update to the appAttempt.\n    this.rmContext.getDispatcher().getEventHandler().handle(\n        new RMAppAttemptStatusupdateEvent(appAttemptId, request\n            .getProgress()));\n\n    List\u003cResourceRequest\u003e ask \u003d request.getAskList();\n    List\u003cContainerId\u003e release \u003d request.getReleaseList();\n\n    ResourceBlacklistRequest blacklistRequest \u003d\n        request.getResourceBlacklistRequest();\n    List\u003cString\u003e blacklistAdditions \u003d\n        (blacklistRequest !\u003d null) ?\n            blacklistRequest.getBlacklistAdditions() : Collections.EMPTY_LIST;\n    List\u003cString\u003e blacklistRemovals \u003d\n        (blacklistRequest !\u003d null) ?\n            blacklistRequest.getBlacklistRemovals() : Collections.EMPTY_LIST;\n    RMApp app \u003d\n        this.rmContext.getRMApps().get(appAttemptId.getApplicationId());\n\n    // set label expression for Resource Requests if resourceName\u003dANY\n    ApplicationSubmissionContext asc \u003d app.getApplicationSubmissionContext();\n    for (ResourceRequest req : ask) {\n      if (null \u003d\u003d req.getNodeLabelExpression()\n          \u0026\u0026 ResourceRequest.ANY.equals(req.getResourceName())) {\n        req.setNodeLabelExpression(asc.getNodeLabelExpression());\n      }\n    }\n\n    Resource maximumCapacity \u003d rScheduler.getMaximumResourceCapability();\n\n    // sanity check\n    try {\n      RMServerUtils.normalizeAndValidateRequests(ask,\n          maximumCapacity, app.getQueue(),\n          rScheduler, rmContext);\n    } catch (InvalidResourceRequestException e) {\n      LOG.warn(\"Invalid resource ask by application \" + appAttemptId, e);\n      throw e;\n    }\n\n    try {\n      RMServerUtils.validateBlacklistRequest(blacklistRequest);\n    }  catch (InvalidResourceBlacklistRequestException e) {\n      LOG.warn(\"Invalid blacklist request by application \" + appAttemptId, e);\n      throw e;\n    }\n\n    // In the case of work-preserving AM restart, it\u0027s possible for the\n    // AM to release containers from the earlier attempt.\n    if (!app.getApplicationSubmissionContext()\n        .getKeepContainersAcrossApplicationAttempts()) {\n      try {\n        RMServerUtils.validateContainerReleaseRequest(release, appAttemptId);\n      } catch (InvalidContainerReleaseException e) {\n        LOG.warn(\"Invalid container release by application \" + appAttemptId,\n            e);\n        throw e;\n      }\n    }\n\n    // Split Update Resource Requests into increase and decrease.\n    // No Exceptions are thrown here. All update errors are aggregated\n    // and returned to the AM.\n    List\u003cUpdateContainerError\u003e updateErrors \u003d new ArrayList\u003c\u003e();\n    ContainerUpdates containerUpdateRequests \u003d\n        RMServerUtils.validateAndSplitUpdateResourceRequests(\n        rmContext, request, maximumCapacity, updateErrors);\n\n    // Send new requests to appAttempt.\n    Allocation allocation;\n    RMAppAttemptState state \u003d\n        app.getRMAppAttempt(appAttemptId).getAppAttemptState();\n    if (state.equals(RMAppAttemptState.FINAL_SAVING) ||\n        state.equals(RMAppAttemptState.FINISHING) ||\n        app.isAppFinalStateStored()) {\n      LOG.warn(appAttemptId + \" is in \" + state +\n               \" state, ignore container allocate request.\");\n      allocation \u003d EMPTY_ALLOCATION;\n    } else {\n      allocation \u003d\n          this.rScheduler.allocate(appAttemptId, ask, release,\n              blacklistAdditions, blacklistRemovals,\n              containerUpdateRequests);\n    }\n\n    if (!blacklistAdditions.isEmpty() || !blacklistRemovals.isEmpty()) {\n      LOG.info(\"blacklist are updated in Scheduler.\" +\n          \"blacklistAdditions: \" + blacklistAdditions + \", \" +\n          \"blacklistRemovals: \" + blacklistRemovals);\n    }\n    RMAppAttempt appAttempt \u003d app.getRMAppAttempt(appAttemptId);\n\n    if (allocation.getNMTokens() !\u003d null \u0026\u0026\n        !allocation.getNMTokens().isEmpty()) {\n      allocateResponse.setNMTokens(allocation.getNMTokens());\n    }\n\n    // Notify the AM of container update errors\n    addToUpdateContainerErrors(allocateResponse, updateErrors);\n\n    // update the response with the deltas of node status changes\n    List\u003cRMNode\u003e updatedNodes \u003d new ArrayList\u003cRMNode\u003e();\n    if(app.pullRMNodeUpdates(updatedNodes) \u003e 0) {\n      List\u003cNodeReport\u003e updatedNodeReports \u003d new ArrayList\u003cNodeReport\u003e();\n      for(RMNode rmNode: updatedNodes) {\n        SchedulerNodeReport schedulerNodeReport \u003d\n            rScheduler.getNodeReport(rmNode.getNodeID());\n        Resource used \u003d BuilderUtils.newResource(0, 0);\n        int numContainers \u003d 0;\n        if (schedulerNodeReport !\u003d null) {\n          used \u003d schedulerNodeReport.getUsedResource();\n          numContainers \u003d schedulerNodeReport.getNumContainers();\n        }\n        NodeId nodeId \u003d rmNode.getNodeID();\n        NodeReport report \u003d\n            BuilderUtils.newNodeReport(nodeId, rmNode.getState(),\n                rmNode.getHttpAddress(), rmNode.getRackName(), used,\n                rmNode.getTotalCapability(), numContainers,\n                rmNode.getHealthReport(), rmNode.getLastHealthReportTime(),\n                rmNode.getNodeLabels());\n\n        updatedNodeReports.add(report);\n      }\n      allocateResponse.setUpdatedNodes(updatedNodeReports);\n    }\n\n    addToAllocatedContainers(allocateResponse, allocation.getContainers());\n\n    allocateResponse.setCompletedContainersStatuses(appAttempt\n        .pullJustFinishedContainers());\n    allocateResponse.setAvailableResources(allocation.getResourceLimit());\n\n    addToContainerUpdates(appAttemptId, allocateResponse, allocation);\n\n    allocateResponse.setNumClusterNodes(this.rScheduler.getNumClusterNodes());\n\n    // add collector address for this application\n    if (YarnConfiguration.timelineServiceV2Enabled(getConfig())) {\n      allocateResponse.setCollectorAddr(\n          this.rmContext.getRMApps().get(appAttemptId.getApplicationId())\n              .getCollectorAddr());\n    }\n\n    // add preemption to the allocateResponse message (if any)\n    allocateResponse\n        .setPreemptionMessage(generatePreemptionMessage(allocation));\n\n    // Set application priority\n    allocateResponse.setApplicationPriority(app\n        .getApplicationPriority());\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java",
      "extendedDetails": {}
    },
    "ac1e5d4f77e3b9df8dcacb0b1f72eecc27931eb8": {
      "type": "Yintroduced",
      "commitMessage": "YARN-5938. Refactoring OpportunisticContainerAllocator to use SchedulerRequestKey instead of Priority and other misc fixes (asuresh)\n",
      "commitDate": "27/12/16 12:40 PM",
      "commitName": "ac1e5d4f77e3b9df8dcacb0b1f72eecc27931eb8",
      "commitAuthor": "Arun Suresh",
      "diff": "@@ -0,0 +1,176 @@\n+  protected void allocateInternal(ApplicationAttemptId appAttemptId,\n+      AllocateRequest request, AllocateResponse allocateResponse)\n+      throws YarnException {\n+\n+    //filter illegal progress values\n+    float filteredProgress \u003d request.getProgress();\n+    if (Float.isNaN(filteredProgress) ||\n+        filteredProgress \u003d\u003d Float.NEGATIVE_INFINITY ||\n+        filteredProgress \u003c 0) {\n+      request.setProgress(0);\n+    } else if (filteredProgress \u003e 1 ||\n+        filteredProgress \u003d\u003d Float.POSITIVE_INFINITY) {\n+      request.setProgress(1);\n+    }\n+\n+    // Send the status update to the appAttempt.\n+    this.rmContext.getDispatcher().getEventHandler().handle(\n+        new RMAppAttemptStatusupdateEvent(appAttemptId, request\n+            .getProgress()));\n+\n+    List\u003cResourceRequest\u003e ask \u003d request.getAskList();\n+    List\u003cContainerId\u003e release \u003d request.getReleaseList();\n+\n+    ResourceBlacklistRequest blacklistRequest \u003d\n+        request.getResourceBlacklistRequest();\n+    List\u003cString\u003e blacklistAdditions \u003d\n+        (blacklistRequest !\u003d null) ?\n+            blacklistRequest.getBlacklistAdditions() : Collections.EMPTY_LIST;\n+    List\u003cString\u003e blacklistRemovals \u003d\n+        (blacklistRequest !\u003d null) ?\n+            blacklistRequest.getBlacklistRemovals() : Collections.EMPTY_LIST;\n+    RMApp app \u003d\n+        this.rmContext.getRMApps().get(appAttemptId.getApplicationId());\n+\n+    // set label expression for Resource Requests if resourceName\u003dANY\n+    ApplicationSubmissionContext asc \u003d app.getApplicationSubmissionContext();\n+    for (ResourceRequest req : ask) {\n+      if (null \u003d\u003d req.getNodeLabelExpression()\n+          \u0026\u0026 ResourceRequest.ANY.equals(req.getResourceName())) {\n+        req.setNodeLabelExpression(asc.getNodeLabelExpression());\n+      }\n+    }\n+\n+    Resource maximumCapacity \u003d rScheduler.getMaximumResourceCapability();\n+\n+    // sanity check\n+    try {\n+      RMServerUtils.normalizeAndValidateRequests(ask,\n+          maximumCapacity, app.getQueue(),\n+          rScheduler, rmContext);\n+    } catch (InvalidResourceRequestException e) {\n+      LOG.warn(\"Invalid resource ask by application \" + appAttemptId, e);\n+      throw e;\n+    }\n+\n+    try {\n+      RMServerUtils.validateBlacklistRequest(blacklistRequest);\n+    }  catch (InvalidResourceBlacklistRequestException e) {\n+      LOG.warn(\"Invalid blacklist request by application \" + appAttemptId, e);\n+      throw e;\n+    }\n+\n+    // In the case of work-preserving AM restart, it\u0027s possible for the\n+    // AM to release containers from the earlier attempt.\n+    if (!app.getApplicationSubmissionContext()\n+        .getKeepContainersAcrossApplicationAttempts()) {\n+      try {\n+        RMServerUtils.validateContainerReleaseRequest(release, appAttemptId);\n+      } catch (InvalidContainerReleaseException e) {\n+        LOG.warn(\"Invalid container release by application \" + appAttemptId,\n+            e);\n+        throw e;\n+      }\n+    }\n+\n+    // Split Update Resource Requests into increase and decrease.\n+    // No Exceptions are thrown here. All update errors are aggregated\n+    // and returned to the AM.\n+    List\u003cUpdateContainerRequest\u003e increaseResourceReqs \u003d new ArrayList\u003c\u003e();\n+    List\u003cUpdateContainerRequest\u003e decreaseResourceReqs \u003d new ArrayList\u003c\u003e();\n+    List\u003cUpdateContainerError\u003e updateContainerErrors \u003d\n+        RMServerUtils.validateAndSplitUpdateResourceRequests(\n+            rmContext, request, maximumCapacity,\n+            increaseResourceReqs, decreaseResourceReqs);\n+\n+    // Send new requests to appAttempt.\n+    Allocation allocation;\n+    RMAppAttemptState state \u003d\n+        app.getRMAppAttempt(appAttemptId).getAppAttemptState();\n+    if (state.equals(RMAppAttemptState.FINAL_SAVING) ||\n+        state.equals(RMAppAttemptState.FINISHING) ||\n+        app.isAppFinalStateStored()) {\n+      LOG.warn(appAttemptId + \" is in \" + state +\n+               \" state, ignore container allocate request.\");\n+      allocation \u003d EMPTY_ALLOCATION;\n+    } else {\n+      allocation \u003d\n+          this.rScheduler.allocate(appAttemptId, ask, release,\n+              blacklistAdditions, blacklistRemovals,\n+              increaseResourceReqs, decreaseResourceReqs);\n+    }\n+\n+    if (!blacklistAdditions.isEmpty() || !blacklistRemovals.isEmpty()) {\n+      LOG.info(\"blacklist are updated in Scheduler.\" +\n+          \"blacklistAdditions: \" + blacklistAdditions + \", \" +\n+          \"blacklistRemovals: \" + blacklistRemovals);\n+    }\n+    RMAppAttempt appAttempt \u003d app.getRMAppAttempt(appAttemptId);\n+\n+    if (allocation.getNMTokens() !\u003d null \u0026\u0026\n+        !allocation.getNMTokens().isEmpty()) {\n+      allocateResponse.setNMTokens(allocation.getNMTokens());\n+    }\n+\n+    // Notify the AM of container update errors\n+    addToUpdateContainerErrors(allocateResponse, updateContainerErrors);\n+\n+    // update the response with the deltas of node status changes\n+    List\u003cRMNode\u003e updatedNodes \u003d new ArrayList\u003cRMNode\u003e();\n+    if(app.pullRMNodeUpdates(updatedNodes) \u003e 0) {\n+      List\u003cNodeReport\u003e updatedNodeReports \u003d new ArrayList\u003cNodeReport\u003e();\n+      for(RMNode rmNode: updatedNodes) {\n+        SchedulerNodeReport schedulerNodeReport \u003d\n+            rScheduler.getNodeReport(rmNode.getNodeID());\n+        Resource used \u003d BuilderUtils.newResource(0, 0);\n+        int numContainers \u003d 0;\n+        if (schedulerNodeReport !\u003d null) {\n+          used \u003d schedulerNodeReport.getUsedResource();\n+          numContainers \u003d schedulerNodeReport.getNumContainers();\n+        }\n+        NodeId nodeId \u003d rmNode.getNodeID();\n+        NodeReport report \u003d\n+            BuilderUtils.newNodeReport(nodeId, rmNode.getState(),\n+                rmNode.getHttpAddress(), rmNode.getRackName(), used,\n+                rmNode.getTotalCapability(), numContainers,\n+                rmNode.getHealthReport(), rmNode.getLastHealthReportTime(),\n+                rmNode.getNodeLabels());\n+\n+        updatedNodeReports.add(report);\n+      }\n+      allocateResponse.setUpdatedNodes(updatedNodeReports);\n+    }\n+\n+    addToAllocatedContainers(allocateResponse, allocation.getContainers());\n+\n+    allocateResponse.setCompletedContainersStatuses(appAttempt\n+        .pullJustFinishedContainers());\n+    allocateResponse.setAvailableResources(allocation.getResourceLimit());\n+\n+    // Handling increased containers\n+    addToUpdatedContainers(\n+        allocateResponse, ContainerUpdateType.INCREASE_RESOURCE,\n+        allocation.getIncreasedContainers());\n+\n+    // Handling decreased containers\n+    addToUpdatedContainers(\n+        allocateResponse, ContainerUpdateType.DECREASE_RESOURCE,\n+        allocation.getDecreasedContainers());\n+\n+    allocateResponse.setNumClusterNodes(this.rScheduler.getNumClusterNodes());\n+\n+    // add collector address for this application\n+    if (YarnConfiguration.timelineServiceV2Enabled(getConfig())) {\n+      allocateResponse.setCollectorAddr(\n+          this.rmContext.getRMApps().get(appAttemptId.getApplicationId())\n+              .getCollectorAddr());\n+    }\n+\n+    // add preemption to the allocateResponse message (if any)\n+    allocateResponse\n+        .setPreemptionMessage(generatePreemptionMessage(allocation));\n+\n+    // Set application priority\n+    allocateResponse.setApplicationPriority(app\n+        .getApplicationPriority());\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  protected void allocateInternal(ApplicationAttemptId appAttemptId,\n      AllocateRequest request, AllocateResponse allocateResponse)\n      throws YarnException {\n\n    //filter illegal progress values\n    float filteredProgress \u003d request.getProgress();\n    if (Float.isNaN(filteredProgress) ||\n        filteredProgress \u003d\u003d Float.NEGATIVE_INFINITY ||\n        filteredProgress \u003c 0) {\n      request.setProgress(0);\n    } else if (filteredProgress \u003e 1 ||\n        filteredProgress \u003d\u003d Float.POSITIVE_INFINITY) {\n      request.setProgress(1);\n    }\n\n    // Send the status update to the appAttempt.\n    this.rmContext.getDispatcher().getEventHandler().handle(\n        new RMAppAttemptStatusupdateEvent(appAttemptId, request\n            .getProgress()));\n\n    List\u003cResourceRequest\u003e ask \u003d request.getAskList();\n    List\u003cContainerId\u003e release \u003d request.getReleaseList();\n\n    ResourceBlacklistRequest blacklistRequest \u003d\n        request.getResourceBlacklistRequest();\n    List\u003cString\u003e blacklistAdditions \u003d\n        (blacklistRequest !\u003d null) ?\n            blacklistRequest.getBlacklistAdditions() : Collections.EMPTY_LIST;\n    List\u003cString\u003e blacklistRemovals \u003d\n        (blacklistRequest !\u003d null) ?\n            blacklistRequest.getBlacklistRemovals() : Collections.EMPTY_LIST;\n    RMApp app \u003d\n        this.rmContext.getRMApps().get(appAttemptId.getApplicationId());\n\n    // set label expression for Resource Requests if resourceName\u003dANY\n    ApplicationSubmissionContext asc \u003d app.getApplicationSubmissionContext();\n    for (ResourceRequest req : ask) {\n      if (null \u003d\u003d req.getNodeLabelExpression()\n          \u0026\u0026 ResourceRequest.ANY.equals(req.getResourceName())) {\n        req.setNodeLabelExpression(asc.getNodeLabelExpression());\n      }\n    }\n\n    Resource maximumCapacity \u003d rScheduler.getMaximumResourceCapability();\n\n    // sanity check\n    try {\n      RMServerUtils.normalizeAndValidateRequests(ask,\n          maximumCapacity, app.getQueue(),\n          rScheduler, rmContext);\n    } catch (InvalidResourceRequestException e) {\n      LOG.warn(\"Invalid resource ask by application \" + appAttemptId, e);\n      throw e;\n    }\n\n    try {\n      RMServerUtils.validateBlacklistRequest(blacklistRequest);\n    }  catch (InvalidResourceBlacklistRequestException e) {\n      LOG.warn(\"Invalid blacklist request by application \" + appAttemptId, e);\n      throw e;\n    }\n\n    // In the case of work-preserving AM restart, it\u0027s possible for the\n    // AM to release containers from the earlier attempt.\n    if (!app.getApplicationSubmissionContext()\n        .getKeepContainersAcrossApplicationAttempts()) {\n      try {\n        RMServerUtils.validateContainerReleaseRequest(release, appAttemptId);\n      } catch (InvalidContainerReleaseException e) {\n        LOG.warn(\"Invalid container release by application \" + appAttemptId,\n            e);\n        throw e;\n      }\n    }\n\n    // Split Update Resource Requests into increase and decrease.\n    // No Exceptions are thrown here. All update errors are aggregated\n    // and returned to the AM.\n    List\u003cUpdateContainerRequest\u003e increaseResourceReqs \u003d new ArrayList\u003c\u003e();\n    List\u003cUpdateContainerRequest\u003e decreaseResourceReqs \u003d new ArrayList\u003c\u003e();\n    List\u003cUpdateContainerError\u003e updateContainerErrors \u003d\n        RMServerUtils.validateAndSplitUpdateResourceRequests(\n            rmContext, request, maximumCapacity,\n            increaseResourceReqs, decreaseResourceReqs);\n\n    // Send new requests to appAttempt.\n    Allocation allocation;\n    RMAppAttemptState state \u003d\n        app.getRMAppAttempt(appAttemptId).getAppAttemptState();\n    if (state.equals(RMAppAttemptState.FINAL_SAVING) ||\n        state.equals(RMAppAttemptState.FINISHING) ||\n        app.isAppFinalStateStored()) {\n      LOG.warn(appAttemptId + \" is in \" + state +\n               \" state, ignore container allocate request.\");\n      allocation \u003d EMPTY_ALLOCATION;\n    } else {\n      allocation \u003d\n          this.rScheduler.allocate(appAttemptId, ask, release,\n              blacklistAdditions, blacklistRemovals,\n              increaseResourceReqs, decreaseResourceReqs);\n    }\n\n    if (!blacklistAdditions.isEmpty() || !blacklistRemovals.isEmpty()) {\n      LOG.info(\"blacklist are updated in Scheduler.\" +\n          \"blacklistAdditions: \" + blacklistAdditions + \", \" +\n          \"blacklistRemovals: \" + blacklistRemovals);\n    }\n    RMAppAttempt appAttempt \u003d app.getRMAppAttempt(appAttemptId);\n\n    if (allocation.getNMTokens() !\u003d null \u0026\u0026\n        !allocation.getNMTokens().isEmpty()) {\n      allocateResponse.setNMTokens(allocation.getNMTokens());\n    }\n\n    // Notify the AM of container update errors\n    addToUpdateContainerErrors(allocateResponse, updateContainerErrors);\n\n    // update the response with the deltas of node status changes\n    List\u003cRMNode\u003e updatedNodes \u003d new ArrayList\u003cRMNode\u003e();\n    if(app.pullRMNodeUpdates(updatedNodes) \u003e 0) {\n      List\u003cNodeReport\u003e updatedNodeReports \u003d new ArrayList\u003cNodeReport\u003e();\n      for(RMNode rmNode: updatedNodes) {\n        SchedulerNodeReport schedulerNodeReport \u003d\n            rScheduler.getNodeReport(rmNode.getNodeID());\n        Resource used \u003d BuilderUtils.newResource(0, 0);\n        int numContainers \u003d 0;\n        if (schedulerNodeReport !\u003d null) {\n          used \u003d schedulerNodeReport.getUsedResource();\n          numContainers \u003d schedulerNodeReport.getNumContainers();\n        }\n        NodeId nodeId \u003d rmNode.getNodeID();\n        NodeReport report \u003d\n            BuilderUtils.newNodeReport(nodeId, rmNode.getState(),\n                rmNode.getHttpAddress(), rmNode.getRackName(), used,\n                rmNode.getTotalCapability(), numContainers,\n                rmNode.getHealthReport(), rmNode.getLastHealthReportTime(),\n                rmNode.getNodeLabels());\n\n        updatedNodeReports.add(report);\n      }\n      allocateResponse.setUpdatedNodes(updatedNodeReports);\n    }\n\n    addToAllocatedContainers(allocateResponse, allocation.getContainers());\n\n    allocateResponse.setCompletedContainersStatuses(appAttempt\n        .pullJustFinishedContainers());\n    allocateResponse.setAvailableResources(allocation.getResourceLimit());\n\n    // Handling increased containers\n    addToUpdatedContainers(\n        allocateResponse, ContainerUpdateType.INCREASE_RESOURCE,\n        allocation.getIncreasedContainers());\n\n    // Handling decreased containers\n    addToUpdatedContainers(\n        allocateResponse, ContainerUpdateType.DECREASE_RESOURCE,\n        allocation.getDecreasedContainers());\n\n    allocateResponse.setNumClusterNodes(this.rScheduler.getNumClusterNodes());\n\n    // add collector address for this application\n    if (YarnConfiguration.timelineServiceV2Enabled(getConfig())) {\n      allocateResponse.setCollectorAddr(\n          this.rmContext.getRMApps().get(appAttemptId.getApplicationId())\n              .getCollectorAddr());\n    }\n\n    // add preemption to the allocateResponse message (if any)\n    allocateResponse\n        .setPreemptionMessage(generatePreemptionMessage(allocation));\n\n    // Set application priority\n    allocateResponse.setApplicationPriority(app\n        .getApplicationPriority());\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java"
    }
  }
}