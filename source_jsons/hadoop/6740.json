{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FSEditLogOp.java",
  "functionName": "readOp",
  "functionId": "readOp___skipBrokenEdits-boolean",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSEditLogOp.java",
  "functionStartLine": 5018,
  "functionEndLine": 5047,
  "numCommitsSeen": 117,
  "timeTaken": 7851,
  "changeHistory": [
    "19dd66a3f616cd8a4527f2adeef911a7d4b3f349",
    "56d2ef6f5ed25055f19eb61e02c52fb9237a78b7",
    "05a73a3a1ea064b0d819d1851bce820e7d1f3f65",
    "bef65d0601a9334cdcfa97796755eb71350d50e3",
    "7d1f97b8213795efa26eb53c1914819c74c22502",
    "95710c15b7a724897bcde826e112df6d4b4fe56b",
    "706394d03992b394e9f907aff2155df493e4ea4e",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "d86f3183d93714ba078416af4f609d26376eadb0",
    "28e6a4e44a3e920dcaf858f9a74a6358226b3a63",
    "438c32aaf9fb0c63f55044cf5ef1b2e0adcf7fea",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc"
  ],
  "changeHistoryShort": {
    "19dd66a3f616cd8a4527f2adeef911a7d4b3f349": "Ybodychange",
    "56d2ef6f5ed25055f19eb61e02c52fb9237a78b7": "Ybodychange",
    "05a73a3a1ea064b0d819d1851bce820e7d1f3f65": "Ybodychange",
    "bef65d0601a9334cdcfa97796755eb71350d50e3": "Ybodychange",
    "7d1f97b8213795efa26eb53c1914819c74c22502": "Ybodychange",
    "95710c15b7a724897bcde826e112df6d4b4fe56b": "Ybodychange",
    "706394d03992b394e9f907aff2155df493e4ea4e": "Ymultichange(Yparameterchange,Ybodychange)",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "d86f3183d93714ba078416af4f609d26376eadb0": "Yfilerename",
    "28e6a4e44a3e920dcaf858f9a74a6358226b3a63": "Ybodychange",
    "438c32aaf9fb0c63f55044cf5ef1b2e0adcf7fea": "Ybodychange",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yintroduced"
  },
  "changeHistoryDetails": {
    "19dd66a3f616cd8a4527f2adeef911a7d4b3f349": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3510.  Editlog pre-allocation is performed prior to writing edits to avoid partial edits case disk out of space. Contributed by Collin McCabe.\n        \n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1355189 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "28/06/12 4:00 PM",
      "commitName": "19dd66a3f616cd8a4527f2adeef911a7d4b3f349",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "11/06/12 11:01 AM",
      "commitNameOld": "56d2ef6f5ed25055f19eb61e02c52fb9237a78b7",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 17.21,
      "commitsBetweenForRepo": 80,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,48 +1,30 @@\n     public FSEditLogOp readOp(boolean skipBrokenEdits) throws IOException {\n       while (true) {\n         try {\n-          limiter.setLimit(MAX_OP_SIZE);\n-          in.mark(MAX_OP_SIZE);\n           return decodeOp();\n-        } catch (GarbageAfterTerminatorException e) {\n-          in.reset();\n-          if (!skipBrokenEdits) {\n-            throw e;\n-          }\n-          // If we saw a terminator opcode followed by a long region of 0x00 or\n-          // 0xff, we want to skip over that region, because there\u0027s nothing\n-          // interesting there.\n-          long numSkip \u003d e.getNumAfterTerminator();\n-          try {\n-            IOUtils.skipFully(in,  numSkip);\n-          } catch (Throwable t) {\n-            FSImage.LOG.error(\"Failed to skip \" + numSkip + \" bytes of \" +\n-              \"garbage after an OP_INVALID.\", t);\n-            return null;\n-          }\n         } catch (IOException e) {\n           in.reset();\n           if (!skipBrokenEdits) {\n             throw e;\n           }\n         } catch (RuntimeException e) {\n           // FSEditLogOp#decodeOp is not supposed to throw RuntimeException.\n           // However, we handle it here for recovery mode, just to be more\n           // robust.\n           in.reset();\n           if (!skipBrokenEdits) {\n             throw e;\n           }\n         } catch (Throwable e) {\n           in.reset();\n           if (!skipBrokenEdits) {\n             throw new IOException(\"got unexpected exception \" +\n                 e.getMessage(), e);\n           }\n         }\n         // Move ahead one byte and re-try the decode process.\n         if (in.skip(1) \u003c 1) {\n           return null;\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public FSEditLogOp readOp(boolean skipBrokenEdits) throws IOException {\n      while (true) {\n        try {\n          return decodeOp();\n        } catch (IOException e) {\n          in.reset();\n          if (!skipBrokenEdits) {\n            throw e;\n          }\n        } catch (RuntimeException e) {\n          // FSEditLogOp#decodeOp is not supposed to throw RuntimeException.\n          // However, we handle it here for recovery mode, just to be more\n          // robust.\n          in.reset();\n          if (!skipBrokenEdits) {\n            throw e;\n          }\n        } catch (Throwable e) {\n          in.reset();\n          if (!skipBrokenEdits) {\n            throw new IOException(\"got unexpected exception \" +\n                e.getMessage(), e);\n          }\n        }\n        // Move ahead one byte and re-try the decode process.\n        if (in.skip(1) \u003c 1) {\n          return null;\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSEditLogOp.java",
      "extendedDetails": {}
    },
    "56d2ef6f5ed25055f19eb61e02c52fb9237a78b7": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2797. Fix misuses of InputStream#skip in the edit log code. Contributed by Colin Patrick McCabe\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1348945 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/06/12 11:01 AM",
      "commitName": "56d2ef6f5ed25055f19eb61e02c52fb9237a78b7",
      "commitAuthor": "Eli Collins",
      "commitDateOld": "07/06/12 2:06 PM",
      "commitNameOld": "05a73a3a1ea064b0d819d1851bce820e7d1f3f65",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 3.87,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,48 @@\n     public FSEditLogOp readOp(boolean skipBrokenEdits) throws IOException {\n       while (true) {\n         try {\n           limiter.setLimit(MAX_OP_SIZE);\n           in.mark(MAX_OP_SIZE);\n           return decodeOp();\n         } catch (GarbageAfterTerminatorException e) {\n           in.reset();\n           if (!skipBrokenEdits) {\n             throw e;\n           }\n           // If we saw a terminator opcode followed by a long region of 0x00 or\n           // 0xff, we want to skip over that region, because there\u0027s nothing\n           // interesting there.\n           long numSkip \u003d e.getNumAfterTerminator();\n-          if (in.skip(numSkip) \u003c numSkip) {\n+          try {\n+            IOUtils.skipFully(in,  numSkip);\n+          } catch (Throwable t) {\n             FSImage.LOG.error(\"Failed to skip \" + numSkip + \" bytes of \" +\n-              \"garbage after an OP_INVALID.  Unexpected early EOF.\");\n+              \"garbage after an OP_INVALID.\", t);\n             return null;\n           }\n         } catch (IOException e) {\n           in.reset();\n           if (!skipBrokenEdits) {\n             throw e;\n           }\n         } catch (RuntimeException e) {\n           // FSEditLogOp#decodeOp is not supposed to throw RuntimeException.\n           // However, we handle it here for recovery mode, just to be more\n           // robust.\n           in.reset();\n           if (!skipBrokenEdits) {\n             throw e;\n           }\n         } catch (Throwable e) {\n           in.reset();\n           if (!skipBrokenEdits) {\n             throw new IOException(\"got unexpected exception \" +\n                 e.getMessage(), e);\n           }\n         }\n         // Move ahead one byte and re-try the decode process.\n         if (in.skip(1) \u003c 1) {\n           return null;\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public FSEditLogOp readOp(boolean skipBrokenEdits) throws IOException {\n      while (true) {\n        try {\n          limiter.setLimit(MAX_OP_SIZE);\n          in.mark(MAX_OP_SIZE);\n          return decodeOp();\n        } catch (GarbageAfterTerminatorException e) {\n          in.reset();\n          if (!skipBrokenEdits) {\n            throw e;\n          }\n          // If we saw a terminator opcode followed by a long region of 0x00 or\n          // 0xff, we want to skip over that region, because there\u0027s nothing\n          // interesting there.\n          long numSkip \u003d e.getNumAfterTerminator();\n          try {\n            IOUtils.skipFully(in,  numSkip);\n          } catch (Throwable t) {\n            FSImage.LOG.error(\"Failed to skip \" + numSkip + \" bytes of \" +\n              \"garbage after an OP_INVALID.\", t);\n            return null;\n          }\n        } catch (IOException e) {\n          in.reset();\n          if (!skipBrokenEdits) {\n            throw e;\n          }\n        } catch (RuntimeException e) {\n          // FSEditLogOp#decodeOp is not supposed to throw RuntimeException.\n          // However, we handle it here for recovery mode, just to be more\n          // robust.\n          in.reset();\n          if (!skipBrokenEdits) {\n            throw e;\n          }\n        } catch (Throwable e) {\n          in.reset();\n          if (!skipBrokenEdits) {\n            throw new IOException(\"got unexpected exception \" +\n                e.getMessage(), e);\n          }\n        }\n        // Move ahead one byte and re-try the decode process.\n        if (in.skip(1) \u003c 1) {\n          return null;\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSEditLogOp.java",
      "extendedDetails": {}
    },
    "05a73a3a1ea064b0d819d1851bce820e7d1f3f65": {
      "type": "Ybodychange",
      "commitMessage": "Revert HDFS-3492 from r1347192: patch broke TestShortCircuitLocalRead\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1347796 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/06/12 2:06 PM",
      "commitName": "05a73a3a1ea064b0d819d1851bce820e7d1f3f65",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "06/06/12 3:48 PM",
      "commitNameOld": "bef65d0601a9334cdcfa97796755eb71350d50e3",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 0.93,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,48 +1,46 @@\n     public FSEditLogOp readOp(boolean skipBrokenEdits) throws IOException {\n       while (true) {\n         try {\n           limiter.setLimit(MAX_OP_SIZE);\n           in.mark(MAX_OP_SIZE);\n           return decodeOp();\n         } catch (GarbageAfterTerminatorException e) {\n           in.reset();\n           if (!skipBrokenEdits) {\n             throw e;\n           }\n           // If we saw a terminator opcode followed by a long region of 0x00 or\n           // 0xff, we want to skip over that region, because there\u0027s nothing\n           // interesting there.\n           long numSkip \u003d e.getNumAfterTerminator();\n-          try {\n-            IOUtils.skipFully(in, numSkip);\n-          } catch (IOException t) {\n+          if (in.skip(numSkip) \u003c numSkip) {\n             FSImage.LOG.error(\"Failed to skip \" + numSkip + \" bytes of \" +\n-              \"garbage after an OP_INVALID.  Unexpected early EOF.\", t);\n+              \"garbage after an OP_INVALID.  Unexpected early EOF.\");\n             return null;\n           }\n         } catch (IOException e) {\n           in.reset();\n           if (!skipBrokenEdits) {\n             throw e;\n           }\n         } catch (RuntimeException e) {\n           // FSEditLogOp#decodeOp is not supposed to throw RuntimeException.\n           // However, we handle it here for recovery mode, just to be more\n           // robust.\n           in.reset();\n           if (!skipBrokenEdits) {\n             throw e;\n           }\n         } catch (Throwable e) {\n           in.reset();\n           if (!skipBrokenEdits) {\n             throw new IOException(\"got unexpected exception \" +\n                 e.getMessage(), e);\n           }\n         }\n         // Move ahead one byte and re-try the decode process.\n         if (in.skip(1) \u003c 1) {\n           return null;\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public FSEditLogOp readOp(boolean skipBrokenEdits) throws IOException {\n      while (true) {\n        try {\n          limiter.setLimit(MAX_OP_SIZE);\n          in.mark(MAX_OP_SIZE);\n          return decodeOp();\n        } catch (GarbageAfterTerminatorException e) {\n          in.reset();\n          if (!skipBrokenEdits) {\n            throw e;\n          }\n          // If we saw a terminator opcode followed by a long region of 0x00 or\n          // 0xff, we want to skip over that region, because there\u0027s nothing\n          // interesting there.\n          long numSkip \u003d e.getNumAfterTerminator();\n          if (in.skip(numSkip) \u003c numSkip) {\n            FSImage.LOG.error(\"Failed to skip \" + numSkip + \" bytes of \" +\n              \"garbage after an OP_INVALID.  Unexpected early EOF.\");\n            return null;\n          }\n        } catch (IOException e) {\n          in.reset();\n          if (!skipBrokenEdits) {\n            throw e;\n          }\n        } catch (RuntimeException e) {\n          // FSEditLogOp#decodeOp is not supposed to throw RuntimeException.\n          // However, we handle it here for recovery mode, just to be more\n          // robust.\n          in.reset();\n          if (!skipBrokenEdits) {\n            throw e;\n          }\n        } catch (Throwable e) {\n          in.reset();\n          if (!skipBrokenEdits) {\n            throw new IOException(\"got unexpected exception \" +\n                e.getMessage(), e);\n          }\n        }\n        // Move ahead one byte and re-try the decode process.\n        if (in.skip(1) \u003c 1) {\n          return null;\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSEditLogOp.java",
      "extendedDetails": {}
    },
    "bef65d0601a9334cdcfa97796755eb71350d50e3": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3492. Fix some misuses of InputStream#skip. Contributed by Colin Patrick McCabe.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1347192 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "06/06/12 3:48 PM",
      "commitName": "bef65d0601a9334cdcfa97796755eb71350d50e3",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "17/05/12 10:28 PM",
      "commitNameOld": "7d1f97b8213795efa26eb53c1914819c74c22502",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 19.72,
      "commitsBetweenForRepo": 79,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,48 @@\n     public FSEditLogOp readOp(boolean skipBrokenEdits) throws IOException {\n       while (true) {\n         try {\n           limiter.setLimit(MAX_OP_SIZE);\n           in.mark(MAX_OP_SIZE);\n           return decodeOp();\n         } catch (GarbageAfterTerminatorException e) {\n           in.reset();\n           if (!skipBrokenEdits) {\n             throw e;\n           }\n           // If we saw a terminator opcode followed by a long region of 0x00 or\n           // 0xff, we want to skip over that region, because there\u0027s nothing\n           // interesting there.\n           long numSkip \u003d e.getNumAfterTerminator();\n-          if (in.skip(numSkip) \u003c numSkip) {\n+          try {\n+            IOUtils.skipFully(in, numSkip);\n+          } catch (IOException t) {\n             FSImage.LOG.error(\"Failed to skip \" + numSkip + \" bytes of \" +\n-              \"garbage after an OP_INVALID.  Unexpected early EOF.\");\n+              \"garbage after an OP_INVALID.  Unexpected early EOF.\", t);\n             return null;\n           }\n         } catch (IOException e) {\n           in.reset();\n           if (!skipBrokenEdits) {\n             throw e;\n           }\n         } catch (RuntimeException e) {\n           // FSEditLogOp#decodeOp is not supposed to throw RuntimeException.\n           // However, we handle it here for recovery mode, just to be more\n           // robust.\n           in.reset();\n           if (!skipBrokenEdits) {\n             throw e;\n           }\n         } catch (Throwable e) {\n           in.reset();\n           if (!skipBrokenEdits) {\n             throw new IOException(\"got unexpected exception \" +\n                 e.getMessage(), e);\n           }\n         }\n         // Move ahead one byte and re-try the decode process.\n         if (in.skip(1) \u003c 1) {\n           return null;\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public FSEditLogOp readOp(boolean skipBrokenEdits) throws IOException {\n      while (true) {\n        try {\n          limiter.setLimit(MAX_OP_SIZE);\n          in.mark(MAX_OP_SIZE);\n          return decodeOp();\n        } catch (GarbageAfterTerminatorException e) {\n          in.reset();\n          if (!skipBrokenEdits) {\n            throw e;\n          }\n          // If we saw a terminator opcode followed by a long region of 0x00 or\n          // 0xff, we want to skip over that region, because there\u0027s nothing\n          // interesting there.\n          long numSkip \u003d e.getNumAfterTerminator();\n          try {\n            IOUtils.skipFully(in, numSkip);\n          } catch (IOException t) {\n            FSImage.LOG.error(\"Failed to skip \" + numSkip + \" bytes of \" +\n              \"garbage after an OP_INVALID.  Unexpected early EOF.\", t);\n            return null;\n          }\n        } catch (IOException e) {\n          in.reset();\n          if (!skipBrokenEdits) {\n            throw e;\n          }\n        } catch (RuntimeException e) {\n          // FSEditLogOp#decodeOp is not supposed to throw RuntimeException.\n          // However, we handle it here for recovery mode, just to be more\n          // robust.\n          in.reset();\n          if (!skipBrokenEdits) {\n            throw e;\n          }\n        } catch (Throwable e) {\n          in.reset();\n          if (!skipBrokenEdits) {\n            throw new IOException(\"got unexpected exception \" +\n                e.getMessage(), e);\n          }\n        }\n        // Move ahead one byte and re-try the decode process.\n        if (in.skip(1) \u003c 1) {\n          return null;\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSEditLogOp.java",
      "extendedDetails": {}
    },
    "7d1f97b8213795efa26eb53c1914819c74c22502": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3440. More effectively limit stream memory consumption when reading corrupt edit logs. Contributed by Colin Patrick McCabe.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1339978 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/05/12 10:28 PM",
      "commitName": "7d1f97b8213795efa26eb53c1914819c74c22502",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "14/05/12 5:41 PM",
      "commitNameOld": "95710c15b7a724897bcde826e112df6d4b4fe56b",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 3.2,
      "commitsBetweenForRepo": 28,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,45 +1,46 @@\n     public FSEditLogOp readOp(boolean skipBrokenEdits) throws IOException {\n       while (true) {\n         try {\n+          limiter.setLimit(MAX_OP_SIZE);\n           in.mark(MAX_OP_SIZE);\n           return decodeOp();\n         } catch (GarbageAfterTerminatorException e) {\n           in.reset();\n           if (!skipBrokenEdits) {\n             throw e;\n           }\n           // If we saw a terminator opcode followed by a long region of 0x00 or\n           // 0xff, we want to skip over that region, because there\u0027s nothing\n           // interesting there.\n           long numSkip \u003d e.getNumAfterTerminator();\n           if (in.skip(numSkip) \u003c numSkip) {\n             FSImage.LOG.error(\"Failed to skip \" + numSkip + \" bytes of \" +\n               \"garbage after an OP_INVALID.  Unexpected early EOF.\");\n             return null;\n           }\n         } catch (IOException e) {\n           in.reset();\n           if (!skipBrokenEdits) {\n             throw e;\n           }\n         } catch (RuntimeException e) {\n           // FSEditLogOp#decodeOp is not supposed to throw RuntimeException.\n           // However, we handle it here for recovery mode, just to be more\n           // robust.\n           in.reset();\n           if (!skipBrokenEdits) {\n             throw e;\n           }\n         } catch (Throwable e) {\n           in.reset();\n           if (!skipBrokenEdits) {\n             throw new IOException(\"got unexpected exception \" +\n                 e.getMessage(), e);\n           }\n         }\n         // Move ahead one byte and re-try the decode process.\n         if (in.skip(1) \u003c 1) {\n           return null;\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public FSEditLogOp readOp(boolean skipBrokenEdits) throws IOException {\n      while (true) {\n        try {\n          limiter.setLimit(MAX_OP_SIZE);\n          in.mark(MAX_OP_SIZE);\n          return decodeOp();\n        } catch (GarbageAfterTerminatorException e) {\n          in.reset();\n          if (!skipBrokenEdits) {\n            throw e;\n          }\n          // If we saw a terminator opcode followed by a long region of 0x00 or\n          // 0xff, we want to skip over that region, because there\u0027s nothing\n          // interesting there.\n          long numSkip \u003d e.getNumAfterTerminator();\n          if (in.skip(numSkip) \u003c numSkip) {\n            FSImage.LOG.error(\"Failed to skip \" + numSkip + \" bytes of \" +\n              \"garbage after an OP_INVALID.  Unexpected early EOF.\");\n            return null;\n          }\n        } catch (IOException e) {\n          in.reset();\n          if (!skipBrokenEdits) {\n            throw e;\n          }\n        } catch (RuntimeException e) {\n          // FSEditLogOp#decodeOp is not supposed to throw RuntimeException.\n          // However, we handle it here for recovery mode, just to be more\n          // robust.\n          in.reset();\n          if (!skipBrokenEdits) {\n            throw e;\n          }\n        } catch (Throwable e) {\n          in.reset();\n          if (!skipBrokenEdits) {\n            throw new IOException(\"got unexpected exception \" +\n                e.getMessage(), e);\n          }\n        }\n        // Move ahead one byte and re-try the decode process.\n        if (in.skip(1) \u003c 1) {\n          return null;\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSEditLogOp.java",
      "extendedDetails": {}
    },
    "95710c15b7a724897bcde826e112df6d4b4fe56b": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3335. check for edit log corruption at the end of the log. Contributed by Colin Patrick McCabe.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1338492 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/05/12 5:41 PM",
      "commitName": "95710c15b7a724897bcde826e112df6d4b4fe56b",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "10/05/12 4:13 PM",
      "commitNameOld": "98b00d7cc015555642068827e6c52eaed0740c94",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 4.06,
      "commitsBetweenForRepo": 24,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,25 +1,45 @@\n     public FSEditLogOp readOp(boolean skipBrokenEdits) throws IOException {\n-      FSEditLogOp op \u003d null;\n       while (true) {\n         try {\n-          in.mark(in.available());\n-          try {\n-            op \u003d decodeOp();\n-          } finally {\n-            // If we encountered an exception or an end-of-file condition,\n-            // do not advance the input stream.\n-            if (op \u003d\u003d null) {\n-              in.reset();\n-            }\n-          }\n-          return op;\n-        } catch (IOException e) {\n+          in.mark(MAX_OP_SIZE);\n+          return decodeOp();\n+        } catch (GarbageAfterTerminatorException e) {\n+          in.reset();\n           if (!skipBrokenEdits) {\n             throw e;\n           }\n-          if (in.skip(1) \u003c 1) {\n+          // If we saw a terminator opcode followed by a long region of 0x00 or\n+          // 0xff, we want to skip over that region, because there\u0027s nothing\n+          // interesting there.\n+          long numSkip \u003d e.getNumAfterTerminator();\n+          if (in.skip(numSkip) \u003c numSkip) {\n+            FSImage.LOG.error(\"Failed to skip \" + numSkip + \" bytes of \" +\n+              \"garbage after an OP_INVALID.  Unexpected early EOF.\");\n             return null;\n           }\n+        } catch (IOException e) {\n+          in.reset();\n+          if (!skipBrokenEdits) {\n+            throw e;\n+          }\n+        } catch (RuntimeException e) {\n+          // FSEditLogOp#decodeOp is not supposed to throw RuntimeException.\n+          // However, we handle it here for recovery mode, just to be more\n+          // robust.\n+          in.reset();\n+          if (!skipBrokenEdits) {\n+            throw e;\n+          }\n+        } catch (Throwable e) {\n+          in.reset();\n+          if (!skipBrokenEdits) {\n+            throw new IOException(\"got unexpected exception \" +\n+                e.getMessage(), e);\n+          }\n+        }\n+        // Move ahead one byte and re-try the decode process.\n+        if (in.skip(1) \u003c 1) {\n+          return null;\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public FSEditLogOp readOp(boolean skipBrokenEdits) throws IOException {\n      while (true) {\n        try {\n          in.mark(MAX_OP_SIZE);\n          return decodeOp();\n        } catch (GarbageAfterTerminatorException e) {\n          in.reset();\n          if (!skipBrokenEdits) {\n            throw e;\n          }\n          // If we saw a terminator opcode followed by a long region of 0x00 or\n          // 0xff, we want to skip over that region, because there\u0027s nothing\n          // interesting there.\n          long numSkip \u003d e.getNumAfterTerminator();\n          if (in.skip(numSkip) \u003c numSkip) {\n            FSImage.LOG.error(\"Failed to skip \" + numSkip + \" bytes of \" +\n              \"garbage after an OP_INVALID.  Unexpected early EOF.\");\n            return null;\n          }\n        } catch (IOException e) {\n          in.reset();\n          if (!skipBrokenEdits) {\n            throw e;\n          }\n        } catch (RuntimeException e) {\n          // FSEditLogOp#decodeOp is not supposed to throw RuntimeException.\n          // However, we handle it here for recovery mode, just to be more\n          // robust.\n          in.reset();\n          if (!skipBrokenEdits) {\n            throw e;\n          }\n        } catch (Throwable e) {\n          in.reset();\n          if (!skipBrokenEdits) {\n            throw new IOException(\"got unexpected exception \" +\n                e.getMessage(), e);\n          }\n        }\n        // Move ahead one byte and re-try the decode process.\n        if (in.skip(1) \u003c 1) {\n          return null;\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSEditLogOp.java",
      "extendedDetails": {}
    },
    "706394d03992b394e9f907aff2155df493e4ea4e": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-3004. Implement Recovery Mode. Contributed by Colin Patrick McCabe\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1311394 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/04/12 12:39 PM",
      "commitName": "706394d03992b394e9f907aff2155df493e4ea4e",
      "commitAuthor": "Eli Collins",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-3004. Implement Recovery Mode. Contributed by Colin Patrick McCabe\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1311394 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "09/04/12 12:39 PM",
          "commitName": "706394d03992b394e9f907aff2155df493e4ea4e",
          "commitAuthor": "Eli Collins",
          "commitDateOld": "04/04/12 5:02 PM",
          "commitNameOld": "4f6e0a5a659064e0af3bec315e7c25d5e43b47f5",
          "commitAuthorOld": "Eli Collins",
          "daysBetweenCommits": 4.82,
          "commitsBetweenForRepo": 36,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,36 +1,25 @@\n-    public FSEditLogOp readOp() throws IOException {\n-      if (checksum !\u003d null) {\n-        checksum.reset();\n+    public FSEditLogOp readOp(boolean skipBrokenEdits) throws IOException {\n+      FSEditLogOp op \u003d null;\n+      while (true) {\n+        try {\n+          in.mark(in.available());\n+          try {\n+            op \u003d decodeOp();\n+          } finally {\n+            // If we encountered an exception or an end-of-file condition,\n+            // do not advance the input stream.\n+            if (op \u003d\u003d null) {\n+              in.reset();\n+            }\n+          }\n+          return op;\n+        } catch (IOException e) {\n+          if (!skipBrokenEdits) {\n+            throw e;\n+          }\n+          if (in.skip(1) \u003c 1) {\n+            return null;\n+          }\n+        }\n       }\n-\n-      in.mark(1);\n-\n-      byte opCodeByte;\n-      try {\n-        opCodeByte \u003d in.readByte();\n-      } catch (EOFException eof) {\n-        // EOF at an opcode boundary is expected.\n-        return null;\n-      }\n-\n-      FSEditLogOpCodes opCode \u003d FSEditLogOpCodes.fromByte(opCodeByte);\n-      if (opCode \u003d\u003d OP_INVALID) {\n-        in.reset(); // reset back to end of file if somebody reads it again\n-        return null;\n-      }\n-\n-      FSEditLogOp op \u003d opInstances.get().get(opCode);\n-      if (op \u003d\u003d null) {\n-        throw new IOException(\"Read invalid opcode \" + opCode);\n-      }\n-\n-      if (LayoutVersion.supports(Feature.STORED_TXIDS, logVersion)) {\n-        // Read the txid\n-        op.setTransactionId(in.readLong());\n-      }\n-\n-      op.readFields(in, logVersion);\n-\n-      validateChecksum(in, checksum, op.txid);\n-      return op;\n     }\n\\ No newline at end of file\n",
          "actualSource": "    public FSEditLogOp readOp(boolean skipBrokenEdits) throws IOException {\n      FSEditLogOp op \u003d null;\n      while (true) {\n        try {\n          in.mark(in.available());\n          try {\n            op \u003d decodeOp();\n          } finally {\n            // If we encountered an exception or an end-of-file condition,\n            // do not advance the input stream.\n            if (op \u003d\u003d null) {\n              in.reset();\n            }\n          }\n          return op;\n        } catch (IOException e) {\n          if (!skipBrokenEdits) {\n            throw e;\n          }\n          if (in.skip(1) \u003c 1) {\n            return null;\n          }\n        }\n      }\n    }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSEditLogOp.java",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[skipBrokenEdits-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-3004. Implement Recovery Mode. Contributed by Colin Patrick McCabe\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1311394 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "09/04/12 12:39 PM",
          "commitName": "706394d03992b394e9f907aff2155df493e4ea4e",
          "commitAuthor": "Eli Collins",
          "commitDateOld": "04/04/12 5:02 PM",
          "commitNameOld": "4f6e0a5a659064e0af3bec315e7c25d5e43b47f5",
          "commitAuthorOld": "Eli Collins",
          "daysBetweenCommits": 4.82,
          "commitsBetweenForRepo": 36,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,36 +1,25 @@\n-    public FSEditLogOp readOp() throws IOException {\n-      if (checksum !\u003d null) {\n-        checksum.reset();\n+    public FSEditLogOp readOp(boolean skipBrokenEdits) throws IOException {\n+      FSEditLogOp op \u003d null;\n+      while (true) {\n+        try {\n+          in.mark(in.available());\n+          try {\n+            op \u003d decodeOp();\n+          } finally {\n+            // If we encountered an exception or an end-of-file condition,\n+            // do not advance the input stream.\n+            if (op \u003d\u003d null) {\n+              in.reset();\n+            }\n+          }\n+          return op;\n+        } catch (IOException e) {\n+          if (!skipBrokenEdits) {\n+            throw e;\n+          }\n+          if (in.skip(1) \u003c 1) {\n+            return null;\n+          }\n+        }\n       }\n-\n-      in.mark(1);\n-\n-      byte opCodeByte;\n-      try {\n-        opCodeByte \u003d in.readByte();\n-      } catch (EOFException eof) {\n-        // EOF at an opcode boundary is expected.\n-        return null;\n-      }\n-\n-      FSEditLogOpCodes opCode \u003d FSEditLogOpCodes.fromByte(opCodeByte);\n-      if (opCode \u003d\u003d OP_INVALID) {\n-        in.reset(); // reset back to end of file if somebody reads it again\n-        return null;\n-      }\n-\n-      FSEditLogOp op \u003d opInstances.get().get(opCode);\n-      if (op \u003d\u003d null) {\n-        throw new IOException(\"Read invalid opcode \" + opCode);\n-      }\n-\n-      if (LayoutVersion.supports(Feature.STORED_TXIDS, logVersion)) {\n-        // Read the txid\n-        op.setTransactionId(in.readLong());\n-      }\n-\n-      op.readFields(in, logVersion);\n-\n-      validateChecksum(in, checksum, op.txid);\n-      return op;\n     }\n\\ No newline at end of file\n",
          "actualSource": "    public FSEditLogOp readOp(boolean skipBrokenEdits) throws IOException {\n      FSEditLogOp op \u003d null;\n      while (true) {\n        try {\n          in.mark(in.available());\n          try {\n            op \u003d decodeOp();\n          } finally {\n            // If we encountered an exception or an end-of-file condition,\n            // do not advance the input stream.\n            if (op \u003d\u003d null) {\n              in.reset();\n            }\n          }\n          return op;\n        } catch (IOException e) {\n          if (!skipBrokenEdits) {\n            throw e;\n          }\n          if (in.skip(1) \u003c 1) {\n            return null;\n          }\n        }\n      }\n    }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSEditLogOp.java",
          "extendedDetails": {}
        }
      ]
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    public FSEditLogOp readOp() throws IOException {\n      if (checksum !\u003d null) {\n        checksum.reset();\n      }\n\n      in.mark(1);\n\n      byte opCodeByte;\n      try {\n        opCodeByte \u003d in.readByte();\n      } catch (EOFException eof) {\n        // EOF at an opcode boundary is expected.\n        return null;\n      }\n\n      FSEditLogOpCodes opCode \u003d FSEditLogOpCodes.fromByte(opCodeByte);\n      if (opCode \u003d\u003d OP_INVALID) {\n        in.reset(); // reset back to end of file if somebody reads it again\n        return null;\n      }\n\n      FSEditLogOp op \u003d opInstances.get().get(opCode);\n      if (op \u003d\u003d null) {\n        throw new IOException(\"Read invalid opcode \" + opCode);\n      }\n\n      if (LayoutVersion.supports(Feature.STORED_TXIDS, logVersion)) {\n        // Read the txid\n        op.setTransactionId(in.readLong());\n      }\n\n      op.readFields(in, logVersion);\n\n      validateChecksum(in, checksum, op.txid);\n      return op;\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSEditLogOp.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSEditLogOp.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSEditLogOp.java"
      }
    },
    "d86f3183d93714ba078416af4f609d26376eadb0": {
      "type": "Yfilerename",
      "commitMessage": "HDFS-2096. Mavenization of hadoop-hdfs. Contributed by Alejandro Abdelnur.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159702 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/08/11 10:36 AM",
      "commitName": "d86f3183d93714ba078416af4f609d26376eadb0",
      "commitAuthor": "Thomas White",
      "commitDateOld": "19/08/11 10:26 AM",
      "commitNameOld": "6ee5a73e0e91a2ef27753a32c576835e951d8119",
      "commitAuthorOld": "Thomas White",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    public FSEditLogOp readOp() throws IOException {\n      if (checksum !\u003d null) {\n        checksum.reset();\n      }\n\n      in.mark(1);\n\n      byte opCodeByte;\n      try {\n        opCodeByte \u003d in.readByte();\n      } catch (EOFException eof) {\n        // EOF at an opcode boundary is expected.\n        return null;\n      }\n\n      FSEditLogOpCodes opCode \u003d FSEditLogOpCodes.fromByte(opCodeByte);\n      if (opCode \u003d\u003d OP_INVALID) {\n        in.reset(); // reset back to end of file if somebody reads it again\n        return null;\n      }\n\n      FSEditLogOp op \u003d opInstances.get().get(opCode);\n      if (op \u003d\u003d null) {\n        throw new IOException(\"Read invalid opcode \" + opCode);\n      }\n\n      if (LayoutVersion.supports(Feature.STORED_TXIDS, logVersion)) {\n        // Read the txid\n        op.setTransactionId(in.readLong());\n      }\n\n      op.readFields(in, logVersion);\n\n      validateChecksum(in, checksum, op.txid);\n      return op;\n    }",
      "path": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSEditLogOp.java",
      "extendedDetails": {
        "oldPath": "hdfs/src/java/org/apache/hadoop/hdfs/server/namenode/FSEditLogOp.java",
        "newPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSEditLogOp.java"
      }
    },
    "28e6a4e44a3e920dcaf858f9a74a6358226b3a63": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-1073. Redesign the NameNode\u0027s storage layout for image checkpoints and edit logs to introduce transaction IDs and be more robust. Contributed by Todd Lipcon and Ivan Kelly.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1152295 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/07/11 9:28 AM",
      "commitName": "28e6a4e44a3e920dcaf858f9a74a6358226b3a63",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "27/07/11 10:46 PM",
      "commitNameOld": "44320eed1732ea59bd9ec83009eb10e0e6f13023",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 1.45,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,30 +1,36 @@\n     public FSEditLogOp readOp() throws IOException {\n       if (checksum !\u003d null) {\n         checksum.reset();\n       }\n \n       in.mark(1);\n \n       byte opCodeByte;\n       try {\n         opCodeByte \u003d in.readByte();\n       } catch (EOFException eof) {\n         // EOF at an opcode boundary is expected.\n         return null;\n       }\n \n       FSEditLogOpCodes opCode \u003d FSEditLogOpCodes.fromByte(opCodeByte);\n       if (opCode \u003d\u003d OP_INVALID) {\n         in.reset(); // reset back to end of file if somebody reads it again\n         return null;\n       }\n \n       FSEditLogOp op \u003d opInstances.get().get(opCode);\n       if (op \u003d\u003d null) {\n         throw new IOException(\"Read invalid opcode \" + opCode);\n       }\n+\n+      if (LayoutVersion.supports(Feature.STORED_TXIDS, logVersion)) {\n+        // Read the txid\n+        op.setTransactionId(in.readLong());\n+      }\n+\n       op.readFields(in, logVersion);\n \n-      validateChecksum(in, checksum);\n+      validateChecksum(in, checksum, op.txid);\n       return op;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public FSEditLogOp readOp() throws IOException {\n      if (checksum !\u003d null) {\n        checksum.reset();\n      }\n\n      in.mark(1);\n\n      byte opCodeByte;\n      try {\n        opCodeByte \u003d in.readByte();\n      } catch (EOFException eof) {\n        // EOF at an opcode boundary is expected.\n        return null;\n      }\n\n      FSEditLogOpCodes opCode \u003d FSEditLogOpCodes.fromByte(opCodeByte);\n      if (opCode \u003d\u003d OP_INVALID) {\n        in.reset(); // reset back to end of file if somebody reads it again\n        return null;\n      }\n\n      FSEditLogOp op \u003d opInstances.get().get(opCode);\n      if (op \u003d\u003d null) {\n        throw new IOException(\"Read invalid opcode \" + opCode);\n      }\n\n      if (LayoutVersion.supports(Feature.STORED_TXIDS, logVersion)) {\n        // Read the txid\n        op.setTransactionId(in.readLong());\n      }\n\n      op.readFields(in, logVersion);\n\n      validateChecksum(in, checksum, op.txid);\n      return op;\n    }",
      "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/namenode/FSEditLogOp.java",
      "extendedDetails": {}
    },
    "438c32aaf9fb0c63f55044cf5ef1b2e0adcf7fea": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2149. Move EditLogOp serialization formats into FsEditLogOp implementations. Contributed by Ivan Kelly.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1151238 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "26/07/11 1:46 PM",
      "commitName": "438c32aaf9fb0c63f55044cf5ef1b2e0adcf7fea",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "28/06/11 6:31 PM",
      "commitNameOld": "09b6f98de431628c80bc8a6faf0070eeaf72ff2a",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 27.8,
      "commitsBetweenForRepo": 92,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,30 +1,30 @@\n     public FSEditLogOp readOp() throws IOException {\n       if (checksum !\u003d null) {\n         checksum.reset();\n       }\n \n       in.mark(1);\n \n       byte opCodeByte;\n       try {\n         opCodeByte \u003d in.readByte();\n       } catch (EOFException eof) {\n         // EOF at an opcode boundary is expected.\n         return null;\n       }\n \n       FSEditLogOpCodes opCode \u003d FSEditLogOpCodes.fromByte(opCodeByte);\n       if (opCode \u003d\u003d OP_INVALID) {\n         in.reset(); // reset back to end of file if somebody reads it again\n         return null;\n       }\n \n-      FSEditLogOp op \u003d opInstances.get(opCode);\n+      FSEditLogOp op \u003d opInstances.get().get(opCode);\n       if (op \u003d\u003d null) {\n         throw new IOException(\"Read invalid opcode \" + opCode);\n       }\n       op.readFields(in, logVersion);\n \n       validateChecksum(in, checksum);\n       return op;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public FSEditLogOp readOp() throws IOException {\n      if (checksum !\u003d null) {\n        checksum.reset();\n      }\n\n      in.mark(1);\n\n      byte opCodeByte;\n      try {\n        opCodeByte \u003d in.readByte();\n      } catch (EOFException eof) {\n        // EOF at an opcode boundary is expected.\n        return null;\n      }\n\n      FSEditLogOpCodes opCode \u003d FSEditLogOpCodes.fromByte(opCodeByte);\n      if (opCode \u003d\u003d OP_INVALID) {\n        in.reset(); // reset back to end of file if somebody reads it again\n        return null;\n      }\n\n      FSEditLogOp op \u003d opInstances.get().get(opCode);\n      if (op \u003d\u003d null) {\n        throw new IOException(\"Read invalid opcode \" + opCode);\n      }\n      op.readFields(in, logVersion);\n\n      validateChecksum(in, checksum);\n      return op;\n    }",
      "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/namenode/FSEditLogOp.java",
      "extendedDetails": {}
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "diff": "@@ -0,0 +1,30 @@\n+    public FSEditLogOp readOp() throws IOException {\n+      if (checksum !\u003d null) {\n+        checksum.reset();\n+      }\n+\n+      in.mark(1);\n+\n+      byte opCodeByte;\n+      try {\n+        opCodeByte \u003d in.readByte();\n+      } catch (EOFException eof) {\n+        // EOF at an opcode boundary is expected.\n+        return null;\n+      }\n+\n+      FSEditLogOpCodes opCode \u003d FSEditLogOpCodes.fromByte(opCodeByte);\n+      if (opCode \u003d\u003d OP_INVALID) {\n+        in.reset(); // reset back to end of file if somebody reads it again\n+        return null;\n+      }\n+\n+      FSEditLogOp op \u003d opInstances.get(opCode);\n+      if (op \u003d\u003d null) {\n+        throw new IOException(\"Read invalid opcode \" + opCode);\n+      }\n+      op.readFields(in, logVersion);\n+\n+      validateChecksum(in, checksum);\n+      return op;\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    public FSEditLogOp readOp() throws IOException {\n      if (checksum !\u003d null) {\n        checksum.reset();\n      }\n\n      in.mark(1);\n\n      byte opCodeByte;\n      try {\n        opCodeByte \u003d in.readByte();\n      } catch (EOFException eof) {\n        // EOF at an opcode boundary is expected.\n        return null;\n      }\n\n      FSEditLogOpCodes opCode \u003d FSEditLogOpCodes.fromByte(opCodeByte);\n      if (opCode \u003d\u003d OP_INVALID) {\n        in.reset(); // reset back to end of file if somebody reads it again\n        return null;\n      }\n\n      FSEditLogOp op \u003d opInstances.get(opCode);\n      if (op \u003d\u003d null) {\n        throw new IOException(\"Read invalid opcode \" + opCode);\n      }\n      op.readFields(in, logVersion);\n\n      validateChecksum(in, checksum);\n      return op;\n    }",
      "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/namenode/FSEditLogOp.java"
    }
  }
}