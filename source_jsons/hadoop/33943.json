{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "DefaultOOMHandler.java",
  "functionName": "sigKill",
  "functionId": "sigKill___container-Container",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/resources/DefaultOOMHandler.java",
  "functionStartLine": 121,
  "functionEndLine": 170,
  "numCommitsSeen": 5,
  "timeTaken": 1876,
  "changeHistory": [
    "69b328943edf2f61c8fc139934420e3f10bf3813",
    "d9964799544eefcf424fcc178d987525f5356cdf"
  ],
  "changeHistoryShort": {
    "69b328943edf2f61c8fc139934420e3f10bf3813": "Ymultichange(Yreturntypechange,Ybodychange)",
    "d9964799544eefcf424fcc178d987525f5356cdf": "Yintroduced"
  },
  "changeHistoryDetails": {
    "69b328943edf2f61c8fc139934420e3f10bf3813": {
      "type": "Ymultichange(Yreturntypechange,Ybodychange)",
      "commitMessage": "YARN-8929. DefaultOOMHandler should only pick running containers to kill upon oom events (haibochen via rkanter)\n",
      "commitDate": "24/10/18 1:15 PM",
      "commitName": "69b328943edf2f61c8fc139934420e3f10bf3813",
      "commitAuthor": "Robert Kanter",
      "subchanges": [
        {
          "type": "Yreturntypechange",
          "commitMessage": "YARN-8929. DefaultOOMHandler should only pick running containers to kill upon oom events (haibochen via rkanter)\n",
          "commitDate": "24/10/18 1:15 PM",
          "commitName": "69b328943edf2f61c8fc139934420e3f10bf3813",
          "commitAuthor": "Robert Kanter",
          "commitDateOld": "12/06/18 8:35 AM",
          "commitNameOld": "652bcbb3e4950758e61ce123ecc1798ae2b60a7f",
          "commitAuthorOld": "Akira Ajisaka",
          "daysBetweenCommits": 134.19,
          "commitsBetweenForRepo": 1124,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,43 +1,50 @@\n-  private void sigKill(Container container) {\n+  private boolean sigKill(Container container) {\n+    boolean containerKilled \u003d false;\n     boolean finished \u003d false;\n     try {\n       while (!finished) {\n         String[] pids \u003d\n             cgroups.getCGroupParam(\n                 CGroupsHandler.CGroupController.MEMORY,\n                 container.getContainerId().toString(),\n-                CGROUP_FILE_TASKS)\n+                CGROUP_PROCS_FILE)\n                 .split(\"\\n\");\n         finished \u003d true;\n         for (String pid : pids) {\n           // Note: this kills only PGIDs currently\n           if (pid !\u003d null \u0026\u0026 !pid.isEmpty()) {\n             LOG.debug(String.format(\n                 \"Terminating container %s Sending SIGKILL to -%s\",\n                 container.getContainerId().toString(),\n                 pid));\n             finished \u003d false;\n             try {\n               context.getContainerExecutor().signalContainer(\n                   new ContainerSignalContext.Builder().setContainer(container)\n                       .setUser(container.getUser())\n                       .setPid(pid).setSignal(ContainerExecutor.Signal.KILL)\n                       .build());\n             } catch (IOException ex) {\n               LOG.warn(String.format(\"Cannot kill container %s pid -%s.\",\n                   container.getContainerId(), pid), ex);\n             }\n           }\n         }\n         try {\n           Thread.sleep(10);\n         } catch (InterruptedException e) {\n           LOG.debug(\"Interrupted while waiting for processes to disappear\");\n         }\n       }\n+      containerKilled \u003d true;\n     } catch (ResourceHandlerException ex) {\n+      // the tasks file of the container may not be available because the\n+      // container may not have been launched at this point when the root\n+      // cgroup is under oom\n       LOG.warn(String.format(\n           \"Cannot list more tasks in container %s to kill.\",\n           container.getContainerId()));\n     }\n+\n+    return containerKilled;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private boolean sigKill(Container container) {\n    boolean containerKilled \u003d false;\n    boolean finished \u003d false;\n    try {\n      while (!finished) {\n        String[] pids \u003d\n            cgroups.getCGroupParam(\n                CGroupsHandler.CGroupController.MEMORY,\n                container.getContainerId().toString(),\n                CGROUP_PROCS_FILE)\n                .split(\"\\n\");\n        finished \u003d true;\n        for (String pid : pids) {\n          // Note: this kills only PGIDs currently\n          if (pid !\u003d null \u0026\u0026 !pid.isEmpty()) {\n            LOG.debug(String.format(\n                \"Terminating container %s Sending SIGKILL to -%s\",\n                container.getContainerId().toString(),\n                pid));\n            finished \u003d false;\n            try {\n              context.getContainerExecutor().signalContainer(\n                  new ContainerSignalContext.Builder().setContainer(container)\n                      .setUser(container.getUser())\n                      .setPid(pid).setSignal(ContainerExecutor.Signal.KILL)\n                      .build());\n            } catch (IOException ex) {\n              LOG.warn(String.format(\"Cannot kill container %s pid -%s.\",\n                  container.getContainerId(), pid), ex);\n            }\n          }\n        }\n        try {\n          Thread.sleep(10);\n        } catch (InterruptedException e) {\n          LOG.debug(\"Interrupted while waiting for processes to disappear\");\n        }\n      }\n      containerKilled \u003d true;\n    } catch (ResourceHandlerException ex) {\n      // the tasks file of the container may not be available because the\n      // container may not have been launched at this point when the root\n      // cgroup is under oom\n      LOG.warn(String.format(\n          \"Cannot list more tasks in container %s to kill.\",\n          container.getContainerId()));\n    }\n\n    return containerKilled;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/resources/DefaultOOMHandler.java",
          "extendedDetails": {
            "oldValue": "void",
            "newValue": "boolean"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-8929. DefaultOOMHandler should only pick running containers to kill upon oom events (haibochen via rkanter)\n",
          "commitDate": "24/10/18 1:15 PM",
          "commitName": "69b328943edf2f61c8fc139934420e3f10bf3813",
          "commitAuthor": "Robert Kanter",
          "commitDateOld": "12/06/18 8:35 AM",
          "commitNameOld": "652bcbb3e4950758e61ce123ecc1798ae2b60a7f",
          "commitAuthorOld": "Akira Ajisaka",
          "daysBetweenCommits": 134.19,
          "commitsBetweenForRepo": 1124,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,43 +1,50 @@\n-  private void sigKill(Container container) {\n+  private boolean sigKill(Container container) {\n+    boolean containerKilled \u003d false;\n     boolean finished \u003d false;\n     try {\n       while (!finished) {\n         String[] pids \u003d\n             cgroups.getCGroupParam(\n                 CGroupsHandler.CGroupController.MEMORY,\n                 container.getContainerId().toString(),\n-                CGROUP_FILE_TASKS)\n+                CGROUP_PROCS_FILE)\n                 .split(\"\\n\");\n         finished \u003d true;\n         for (String pid : pids) {\n           // Note: this kills only PGIDs currently\n           if (pid !\u003d null \u0026\u0026 !pid.isEmpty()) {\n             LOG.debug(String.format(\n                 \"Terminating container %s Sending SIGKILL to -%s\",\n                 container.getContainerId().toString(),\n                 pid));\n             finished \u003d false;\n             try {\n               context.getContainerExecutor().signalContainer(\n                   new ContainerSignalContext.Builder().setContainer(container)\n                       .setUser(container.getUser())\n                       .setPid(pid).setSignal(ContainerExecutor.Signal.KILL)\n                       .build());\n             } catch (IOException ex) {\n               LOG.warn(String.format(\"Cannot kill container %s pid -%s.\",\n                   container.getContainerId(), pid), ex);\n             }\n           }\n         }\n         try {\n           Thread.sleep(10);\n         } catch (InterruptedException e) {\n           LOG.debug(\"Interrupted while waiting for processes to disappear\");\n         }\n       }\n+      containerKilled \u003d true;\n     } catch (ResourceHandlerException ex) {\n+      // the tasks file of the container may not be available because the\n+      // container may not have been launched at this point when the root\n+      // cgroup is under oom\n       LOG.warn(String.format(\n           \"Cannot list more tasks in container %s to kill.\",\n           container.getContainerId()));\n     }\n+\n+    return containerKilled;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private boolean sigKill(Container container) {\n    boolean containerKilled \u003d false;\n    boolean finished \u003d false;\n    try {\n      while (!finished) {\n        String[] pids \u003d\n            cgroups.getCGroupParam(\n                CGroupsHandler.CGroupController.MEMORY,\n                container.getContainerId().toString(),\n                CGROUP_PROCS_FILE)\n                .split(\"\\n\");\n        finished \u003d true;\n        for (String pid : pids) {\n          // Note: this kills only PGIDs currently\n          if (pid !\u003d null \u0026\u0026 !pid.isEmpty()) {\n            LOG.debug(String.format(\n                \"Terminating container %s Sending SIGKILL to -%s\",\n                container.getContainerId().toString(),\n                pid));\n            finished \u003d false;\n            try {\n              context.getContainerExecutor().signalContainer(\n                  new ContainerSignalContext.Builder().setContainer(container)\n                      .setUser(container.getUser())\n                      .setPid(pid).setSignal(ContainerExecutor.Signal.KILL)\n                      .build());\n            } catch (IOException ex) {\n              LOG.warn(String.format(\"Cannot kill container %s pid -%s.\",\n                  container.getContainerId(), pid), ex);\n            }\n          }\n        }\n        try {\n          Thread.sleep(10);\n        } catch (InterruptedException e) {\n          LOG.debug(\"Interrupted while waiting for processes to disappear\");\n        }\n      }\n      containerKilled \u003d true;\n    } catch (ResourceHandlerException ex) {\n      // the tasks file of the container may not be available because the\n      // container may not have been launched at this point when the root\n      // cgroup is under oom\n      LOG.warn(String.format(\n          \"Cannot list more tasks in container %s to kill.\",\n          container.getContainerId()));\n    }\n\n    return containerKilled;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/resources/DefaultOOMHandler.java",
          "extendedDetails": {}
        }
      ]
    },
    "d9964799544eefcf424fcc178d987525f5356cdf": {
      "type": "Yintroduced",
      "commitMessage": "YARN-4599. Set OOM control for memory cgroups. (Miklos Szegedi via Haibo Chen)\n",
      "commitDate": "23/05/18 4:35 PM",
      "commitName": "d9964799544eefcf424fcc178d987525f5356cdf",
      "commitAuthor": "Haibo Chen",
      "diff": "@@ -0,0 +1,43 @@\n+  private void sigKill(Container container) {\n+    boolean finished \u003d false;\n+    try {\n+      while (!finished) {\n+        String[] pids \u003d\n+            cgroups.getCGroupParam(\n+                CGroupsHandler.CGroupController.MEMORY,\n+                container.getContainerId().toString(),\n+                CGROUP_FILE_TASKS)\n+                .split(\"\\n\");\n+        finished \u003d true;\n+        for (String pid : pids) {\n+          // Note: this kills only PGIDs currently\n+          if (pid !\u003d null \u0026\u0026 !pid.isEmpty()) {\n+            LOG.debug(String.format(\n+                \"Terminating container %s Sending SIGKILL to -%s\",\n+                container.getContainerId().toString(),\n+                pid));\n+            finished \u003d false;\n+            try {\n+              context.getContainerExecutor().signalContainer(\n+                  new ContainerSignalContext.Builder().setContainer(container)\n+                      .setUser(container.getUser())\n+                      .setPid(pid).setSignal(ContainerExecutor.Signal.KILL)\n+                      .build());\n+            } catch (IOException ex) {\n+              LOG.warn(String.format(\"Cannot kill container %s pid -%s.\",\n+                  container.getContainerId(), pid), ex);\n+            }\n+          }\n+        }\n+        try {\n+          Thread.sleep(10);\n+        } catch (InterruptedException e) {\n+          LOG.debug(\"Interrupted while waiting for processes to disappear\");\n+        }\n+      }\n+    } catch (ResourceHandlerException ex) {\n+      LOG.warn(String.format(\n+          \"Cannot list more tasks in container %s to kill.\",\n+          container.getContainerId()));\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void sigKill(Container container) {\n    boolean finished \u003d false;\n    try {\n      while (!finished) {\n        String[] pids \u003d\n            cgroups.getCGroupParam(\n                CGroupsHandler.CGroupController.MEMORY,\n                container.getContainerId().toString(),\n                CGROUP_FILE_TASKS)\n                .split(\"\\n\");\n        finished \u003d true;\n        for (String pid : pids) {\n          // Note: this kills only PGIDs currently\n          if (pid !\u003d null \u0026\u0026 !pid.isEmpty()) {\n            LOG.debug(String.format(\n                \"Terminating container %s Sending SIGKILL to -%s\",\n                container.getContainerId().toString(),\n                pid));\n            finished \u003d false;\n            try {\n              context.getContainerExecutor().signalContainer(\n                  new ContainerSignalContext.Builder().setContainer(container)\n                      .setUser(container.getUser())\n                      .setPid(pid).setSignal(ContainerExecutor.Signal.KILL)\n                      .build());\n            } catch (IOException ex) {\n              LOG.warn(String.format(\"Cannot kill container %s pid -%s.\",\n                  container.getContainerId(), pid), ex);\n            }\n          }\n        }\n        try {\n          Thread.sleep(10);\n        } catch (InterruptedException e) {\n          LOG.debug(\"Interrupted while waiting for processes to disappear\");\n        }\n      }\n    } catch (ResourceHandlerException ex) {\n      LOG.warn(String.format(\n          \"Cannot list more tasks in container %s to kill.\",\n          container.getContainerId()));\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/resources/DefaultOOMHandler.java"
    }
  }
}