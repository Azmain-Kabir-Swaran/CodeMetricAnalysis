{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ApplicationMasterService.java",
  "functionName": "finishApplicationMaster",
  "functionId": "finishApplicationMaster___request-FinishApplicationMasterRequest",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java",
  "functionStartLine": 300,
  "functionEndLine": 354,
  "numCommitsSeen": 119,
  "timeTaken": 13474,
  "changeHistory": [
    "d70f5231a794804d9baf0bdb7e6833533fe60db5",
    "ed13cf84068ad50a78e66211132c1f08238fb65b",
    "78b7e070d8009c78665a2baa64fe888788f53e69",
    "077fcf6a96e420e7f36350931722b8603d010cf1",
    "5496a34c0cb2b1a83cfa6b0aba5a77b05ff2d8f0",
    "89e5c44f9e891a3579384c3fa3766937cd4970f1",
    "2188a07e5bea1da26bf679ca0ece26ab596d3438",
    "9b5636408005676ae580f8d929f8e912c27828e7",
    "6f72f1e6003ab11679bebeb96f27f1f62b3b3e02",
    "3651fe1b089851b38be351c00a9899817166bf3e",
    "c3de2412eb7633ff16c67e71e73bbe27a982d984",
    "f2ea555ac6c06a3f2f6559731f48711fff05d3f1",
    "eeb4acd955802e2a84ea94cecf2e2341b83d5efb",
    "c3f1c30e65cc6a10928299f50801782ecbb4ccb6",
    "7da07461ffadb462567c81ad155d3d1473ad89d7",
    "8cd23c5b4845a242bb3a0e220444f48dff285c34",
    "bb2e2fee6071233fa3f708c04c58091f4b8b0f99",
    "b774d7b3de81cda4165a0e86bc2267fda8546cb5",
    "8caae1d5a65bf082eef9bd03a50fd5025c290406",
    "ec010a29362c6c5572f8681f4e7d0469176345e1",
    "ac914f79bc80b152e71e7de5497b73f22824f4a7",
    "a83fb61ac07c0468cbc7a38526e92683883dd932",
    "9c4f86879cad6d6e19255d4ae8f28b61328bd10b",
    "1bd345d6e3855ab330963efd32e0fac102e61d1a",
    "e1fdf62123625e4ba399af02f8aad500637d29d1",
    "db8ac0ec3cbec046f9cf32644c16fd2a51dd85a2",
    "063e33a862f99ce93b8399924c35d39ccd880f01",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517"
  ],
  "changeHistoryShort": {
    "d70f5231a794804d9baf0bdb7e6833533fe60db5": "Ybodychange",
    "ed13cf84068ad50a78e66211132c1f08238fb65b": "Ybodychange",
    "78b7e070d8009c78665a2baa64fe888788f53e69": "Ybodychange",
    "077fcf6a96e420e7f36350931722b8603d010cf1": "Ybodychange",
    "5496a34c0cb2b1a83cfa6b0aba5a77b05ff2d8f0": "Ybodychange",
    "89e5c44f9e891a3579384c3fa3766937cd4970f1": "Ybodychange",
    "2188a07e5bea1da26bf679ca0ece26ab596d3438": "Ybodychange",
    "9b5636408005676ae580f8d929f8e912c27828e7": "Ybodychange",
    "6f72f1e6003ab11679bebeb96f27f1f62b3b3e02": "Ybodychange",
    "3651fe1b089851b38be351c00a9899817166bf3e": "Ybodychange",
    "c3de2412eb7633ff16c67e71e73bbe27a982d984": "Ybodychange",
    "f2ea555ac6c06a3f2f6559731f48711fff05d3f1": "Ybodychange",
    "eeb4acd955802e2a84ea94cecf2e2341b83d5efb": "Ybodychange",
    "c3f1c30e65cc6a10928299f50801782ecbb4ccb6": "Ybodychange",
    "7da07461ffadb462567c81ad155d3d1473ad89d7": "Ybodychange",
    "8cd23c5b4845a242bb3a0e220444f48dff285c34": "Ybodychange",
    "bb2e2fee6071233fa3f708c04c58091f4b8b0f99": "Ybodychange",
    "b774d7b3de81cda4165a0e86bc2267fda8546cb5": "Ybodychange",
    "8caae1d5a65bf082eef9bd03a50fd5025c290406": "Ybodychange",
    "ec010a29362c6c5572f8681f4e7d0469176345e1": "Ybodychange",
    "ac914f79bc80b152e71e7de5497b73f22824f4a7": "Ybodychange",
    "a83fb61ac07c0468cbc7a38526e92683883dd932": "Yexceptionschange",
    "9c4f86879cad6d6e19255d4ae8f28b61328bd10b": "Yexceptionschange",
    "1bd345d6e3855ab330963efd32e0fac102e61d1a": "Ybodychange",
    "e1fdf62123625e4ba399af02f8aad500637d29d1": "Yfilerename",
    "db8ac0ec3cbec046f9cf32644c16fd2a51dd85a2": "Ybodychange",
    "063e33a862f99ce93b8399924c35d39ccd880f01": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": "Yintroduced"
  },
  "changeHistoryDetails": {
    "d70f5231a794804d9baf0bdb7e6833533fe60db5": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9640. Slow event processing could cause too many attempt unregister events. Contributed by Bibin A Chundatt.\n",
      "commitDate": "26/08/19 8:08 PM",
      "commitName": "d70f5231a794804d9baf0bdb7e6833533fe60db5",
      "commitAuthor": "Rohith Sharma K S",
      "commitDateOld": "04/03/19 9:10 PM",
      "commitNameOld": "e40e2d6ad5cbe782c3a067229270738b501ed27e",
      "commitAuthorOld": "Prabhu Joseph",
      "daysBetweenCommits": 174.92,
      "commitsBetweenForRepo": 1329,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,55 @@\n   public FinishApplicationMasterResponse finishApplicationMaster(\n       FinishApplicationMasterRequest request) throws YarnException,\n       IOException {\n \n     ApplicationAttemptId applicationAttemptId \u003d\n         YarnServerSecurityUtils.authorizeRequest().getApplicationAttemptId();\n     ApplicationId appId \u003d applicationAttemptId.getApplicationId();\n \n     RMApp rmApp \u003d\n         rmContext.getRMApps().get(applicationAttemptId.getApplicationId());\n \n     // Remove collector address when app get finished.\n     if (timelineServiceV2Enabled) {\n       ((RMAppImpl) rmApp).removeCollectorData();\n     }\n     // checking whether the app exits in RMStateStore at first not to throw\n     // ApplicationDoesNotExistInCacheException before and after\n     // RM work-preserving restart.\n     if (rmApp.isAppFinalStateStored()) {\n       LOG.info(rmApp.getApplicationId() + \" unregistered successfully. \");\n       return FinishApplicationMasterResponse.newInstance(true);\n     }\n \n     AllocateResponseLock lock \u003d responseMap.get(applicationAttemptId);\n     if (lock \u003d\u003d null) {\n       throwApplicationDoesNotExistInCacheException(applicationAttemptId);\n     }\n \n     // Allow only one thread in AM to do finishApp at a time.\n     synchronized (lock) {\n       if (!hasApplicationMasterRegistered(applicationAttemptId)) {\n         String message \u003d\n             \"Application Master is trying to unregister before registering for: \"\n                 + appId;\n         LOG.error(message);\n         RMAuditLogger.logFailure(\n             this.rmContext.getRMApps()\n                 .get(appId).getUser(),\n             AuditConstants.UNREGISTER_AM, \"\", \"ApplicationMasterService\",\n             message, appId,\n             applicationAttemptId);\n         throw new ApplicationMasterNotRegisteredException(message);\n       }\n \n-      this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n       FinishApplicationMasterResponse response \u003d\n           FinishApplicationMasterResponse.newInstance(false);\n-      this.amsProcessingChain.finishApplicationMaster(\n-          applicationAttemptId, request, response);\n+      if (finishedAttemptCache.putIfAbsent(applicationAttemptId, true)\n+          \u003d\u003d null) {\n+        this.amsProcessingChain\n+            .finishApplicationMaster(applicationAttemptId, request, response);\n+      }\n+      this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n       return response;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FinishApplicationMasterResponse finishApplicationMaster(\n      FinishApplicationMasterRequest request) throws YarnException,\n      IOException {\n\n    ApplicationAttemptId applicationAttemptId \u003d\n        YarnServerSecurityUtils.authorizeRequest().getApplicationAttemptId();\n    ApplicationId appId \u003d applicationAttemptId.getApplicationId();\n\n    RMApp rmApp \u003d\n        rmContext.getRMApps().get(applicationAttemptId.getApplicationId());\n\n    // Remove collector address when app get finished.\n    if (timelineServiceV2Enabled) {\n      ((RMAppImpl) rmApp).removeCollectorData();\n    }\n    // checking whether the app exits in RMStateStore at first not to throw\n    // ApplicationDoesNotExistInCacheException before and after\n    // RM work-preserving restart.\n    if (rmApp.isAppFinalStateStored()) {\n      LOG.info(rmApp.getApplicationId() + \" unregistered successfully. \");\n      return FinishApplicationMasterResponse.newInstance(true);\n    }\n\n    AllocateResponseLock lock \u003d responseMap.get(applicationAttemptId);\n    if (lock \u003d\u003d null) {\n      throwApplicationDoesNotExistInCacheException(applicationAttemptId);\n    }\n\n    // Allow only one thread in AM to do finishApp at a time.\n    synchronized (lock) {\n      if (!hasApplicationMasterRegistered(applicationAttemptId)) {\n        String message \u003d\n            \"Application Master is trying to unregister before registering for: \"\n                + appId;\n        LOG.error(message);\n        RMAuditLogger.logFailure(\n            this.rmContext.getRMApps()\n                .get(appId).getUser(),\n            AuditConstants.UNREGISTER_AM, \"\", \"ApplicationMasterService\",\n            message, appId,\n            applicationAttemptId);\n        throw new ApplicationMasterNotRegisteredException(message);\n      }\n\n      FinishApplicationMasterResponse response \u003d\n          FinishApplicationMasterResponse.newInstance(false);\n      if (finishedAttemptCache.putIfAbsent(applicationAttemptId, true)\n          \u003d\u003d null) {\n        this.amsProcessingChain\n            .finishApplicationMaster(applicationAttemptId, request, response);\n      }\n      this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n      return response;\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java",
      "extendedDetails": {}
    },
    "ed13cf84068ad50a78e66211132c1f08238fb65b": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9317. Avoid repeated YarnConfiguration#timelineServiceV2Enabled check. Contributed by Prabhu Joseph\n",
      "commitDate": "22/02/19 7:31 AM",
      "commitName": "ed13cf84068ad50a78e66211132c1f08238fb65b",
      "commitAuthor": "bibinchundatt",
      "commitDateOld": "24/09/18 11:37 AM",
      "commitNameOld": "3090922805699b8374a359e92323884a4177dc4e",
      "commitAuthorOld": "Giovanni Matteo Fumarola",
      "daysBetweenCommits": 150.87,
      "commitsBetweenForRepo": 1138,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,52 @@\n   public FinishApplicationMasterResponse finishApplicationMaster(\n       FinishApplicationMasterRequest request) throws YarnException,\n       IOException {\n \n     ApplicationAttemptId applicationAttemptId \u003d\n         YarnServerSecurityUtils.authorizeRequest().getApplicationAttemptId();\n     ApplicationId appId \u003d applicationAttemptId.getApplicationId();\n \n     RMApp rmApp \u003d\n         rmContext.getRMApps().get(applicationAttemptId.getApplicationId());\n \n     // Remove collector address when app get finished.\n-    if (YarnConfiguration.timelineServiceV2Enabled(getConfig())) {\n+    if (timelineServiceV2Enabled) {\n       ((RMAppImpl) rmApp).removeCollectorData();\n     }\n     // checking whether the app exits in RMStateStore at first not to throw\n     // ApplicationDoesNotExistInCacheException before and after\n     // RM work-preserving restart.\n     if (rmApp.isAppFinalStateStored()) {\n       LOG.info(rmApp.getApplicationId() + \" unregistered successfully. \");\n       return FinishApplicationMasterResponse.newInstance(true);\n     }\n \n     AllocateResponseLock lock \u003d responseMap.get(applicationAttemptId);\n     if (lock \u003d\u003d null) {\n       throwApplicationDoesNotExistInCacheException(applicationAttemptId);\n     }\n \n     // Allow only one thread in AM to do finishApp at a time.\n     synchronized (lock) {\n       if (!hasApplicationMasterRegistered(applicationAttemptId)) {\n         String message \u003d\n             \"Application Master is trying to unregister before registering for: \"\n                 + appId;\n         LOG.error(message);\n         RMAuditLogger.logFailure(\n             this.rmContext.getRMApps()\n                 .get(appId).getUser(),\n             AuditConstants.UNREGISTER_AM, \"\", \"ApplicationMasterService\",\n             message, appId,\n             applicationAttemptId);\n         throw new ApplicationMasterNotRegisteredException(message);\n       }\n \n       this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n       FinishApplicationMasterResponse response \u003d\n           FinishApplicationMasterResponse.newInstance(false);\n       this.amsProcessingChain.finishApplicationMaster(\n           applicationAttemptId, request, response);\n       return response;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FinishApplicationMasterResponse finishApplicationMaster(\n      FinishApplicationMasterRequest request) throws YarnException,\n      IOException {\n\n    ApplicationAttemptId applicationAttemptId \u003d\n        YarnServerSecurityUtils.authorizeRequest().getApplicationAttemptId();\n    ApplicationId appId \u003d applicationAttemptId.getApplicationId();\n\n    RMApp rmApp \u003d\n        rmContext.getRMApps().get(applicationAttemptId.getApplicationId());\n\n    // Remove collector address when app get finished.\n    if (timelineServiceV2Enabled) {\n      ((RMAppImpl) rmApp).removeCollectorData();\n    }\n    // checking whether the app exits in RMStateStore at first not to throw\n    // ApplicationDoesNotExistInCacheException before and after\n    // RM work-preserving restart.\n    if (rmApp.isAppFinalStateStored()) {\n      LOG.info(rmApp.getApplicationId() + \" unregistered successfully. \");\n      return FinishApplicationMasterResponse.newInstance(true);\n    }\n\n    AllocateResponseLock lock \u003d responseMap.get(applicationAttemptId);\n    if (lock \u003d\u003d null) {\n      throwApplicationDoesNotExistInCacheException(applicationAttemptId);\n    }\n\n    // Allow only one thread in AM to do finishApp at a time.\n    synchronized (lock) {\n      if (!hasApplicationMasterRegistered(applicationAttemptId)) {\n        String message \u003d\n            \"Application Master is trying to unregister before registering for: \"\n                + appId;\n        LOG.error(message);\n        RMAuditLogger.logFailure(\n            this.rmContext.getRMApps()\n                .get(appId).getUser(),\n            AuditConstants.UNREGISTER_AM, \"\", \"ApplicationMasterService\",\n            message, appId,\n            applicationAttemptId);\n        throw new ApplicationMasterNotRegisteredException(message);\n      }\n\n      this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n      FinishApplicationMasterResponse response \u003d\n          FinishApplicationMasterResponse.newInstance(false);\n      this.amsProcessingChain.finishApplicationMaster(\n          applicationAttemptId, request, response);\n      return response;\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java",
      "extendedDetails": {}
    },
    "78b7e070d8009c78665a2baa64fe888788f53e69": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5638. Introduce a collector timestamp to uniquely identify collectors creation order in collector discovery. Contributed by Li Lu.\n",
      "commitDate": "29/08/17 10:59 PM",
      "commitName": "78b7e070d8009c78665a2baa64fe888788f53e69",
      "commitAuthor": "Sangjin Lee",
      "commitDateOld": "25/08/17 7:16 AM",
      "commitNameOld": "3a4e861169dc3da9df0158ba6f44a9bc8576e217",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 4.66,
      "commitsBetweenForRepo": 34,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,52 @@\n   public FinishApplicationMasterResponse finishApplicationMaster(\n       FinishApplicationMasterRequest request) throws YarnException,\n       IOException {\n \n     ApplicationAttemptId applicationAttemptId \u003d\n         YarnServerSecurityUtils.authorizeRequest().getApplicationAttemptId();\n     ApplicationId appId \u003d applicationAttemptId.getApplicationId();\n \n     RMApp rmApp \u003d\n         rmContext.getRMApps().get(applicationAttemptId.getApplicationId());\n \n     // Remove collector address when app get finished.\n     if (YarnConfiguration.timelineServiceV2Enabled(getConfig())) {\n-      rmApp.removeCollectorAddr();\n+      ((RMAppImpl) rmApp).removeCollectorData();\n     }\n     // checking whether the app exits in RMStateStore at first not to throw\n     // ApplicationDoesNotExistInCacheException before and after\n     // RM work-preserving restart.\n     if (rmApp.isAppFinalStateStored()) {\n       LOG.info(rmApp.getApplicationId() + \" unregistered successfully. \");\n       return FinishApplicationMasterResponse.newInstance(true);\n     }\n \n     AllocateResponseLock lock \u003d responseMap.get(applicationAttemptId);\n     if (lock \u003d\u003d null) {\n       throwApplicationDoesNotExistInCacheException(applicationAttemptId);\n     }\n \n     // Allow only one thread in AM to do finishApp at a time.\n     synchronized (lock) {\n       if (!hasApplicationMasterRegistered(applicationAttemptId)) {\n         String message \u003d\n             \"Application Master is trying to unregister before registering for: \"\n                 + appId;\n         LOG.error(message);\n         RMAuditLogger.logFailure(\n             this.rmContext.getRMApps()\n                 .get(appId).getUser(),\n             AuditConstants.UNREGISTER_AM, \"\", \"ApplicationMasterService\",\n             message, appId,\n             applicationAttemptId);\n         throw new ApplicationMasterNotRegisteredException(message);\n       }\n \n       this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n       FinishApplicationMasterResponse response \u003d\n           FinishApplicationMasterResponse.newInstance(false);\n       this.amsProcessingChain.finishApplicationMaster(\n           applicationAttemptId, request, response);\n       return response;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FinishApplicationMasterResponse finishApplicationMaster(\n      FinishApplicationMasterRequest request) throws YarnException,\n      IOException {\n\n    ApplicationAttemptId applicationAttemptId \u003d\n        YarnServerSecurityUtils.authorizeRequest().getApplicationAttemptId();\n    ApplicationId appId \u003d applicationAttemptId.getApplicationId();\n\n    RMApp rmApp \u003d\n        rmContext.getRMApps().get(applicationAttemptId.getApplicationId());\n\n    // Remove collector address when app get finished.\n    if (YarnConfiguration.timelineServiceV2Enabled(getConfig())) {\n      ((RMAppImpl) rmApp).removeCollectorData();\n    }\n    // checking whether the app exits in RMStateStore at first not to throw\n    // ApplicationDoesNotExistInCacheException before and after\n    // RM work-preserving restart.\n    if (rmApp.isAppFinalStateStored()) {\n      LOG.info(rmApp.getApplicationId() + \" unregistered successfully. \");\n      return FinishApplicationMasterResponse.newInstance(true);\n    }\n\n    AllocateResponseLock lock \u003d responseMap.get(applicationAttemptId);\n    if (lock \u003d\u003d null) {\n      throwApplicationDoesNotExistInCacheException(applicationAttemptId);\n    }\n\n    // Allow only one thread in AM to do finishApp at a time.\n    synchronized (lock) {\n      if (!hasApplicationMasterRegistered(applicationAttemptId)) {\n        String message \u003d\n            \"Application Master is trying to unregister before registering for: \"\n                + appId;\n        LOG.error(message);\n        RMAuditLogger.logFailure(\n            this.rmContext.getRMApps()\n                .get(appId).getUser(),\n            AuditConstants.UNREGISTER_AM, \"\", \"ApplicationMasterService\",\n            message, appId,\n            applicationAttemptId);\n        throw new ApplicationMasterNotRegisteredException(message);\n      }\n\n      this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n      FinishApplicationMasterResponse response \u003d\n          FinishApplicationMasterResponse.newInstance(false);\n      this.amsProcessingChain.finishApplicationMaster(\n          applicationAttemptId, request, response);\n      return response;\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java",
      "extendedDetails": {}
    },
    "077fcf6a96e420e7f36350931722b8603d010cf1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6777. Support for ApplicationMasterService processing chain of interceptors. (asuresh)\n",
      "commitDate": "19/07/17 12:26 PM",
      "commitName": "077fcf6a96e420e7f36350931722b8603d010cf1",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "10/07/17 2:34 PM",
      "commitNameOld": "5496a34c0cb2b1a83cfa6b0aba5a77b05ff2d8f0",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 8.91,
      "commitsBetweenForRepo": 53,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,49 +1,52 @@\n   public FinishApplicationMasterResponse finishApplicationMaster(\n       FinishApplicationMasterRequest request) throws YarnException,\n       IOException {\n \n     ApplicationAttemptId applicationAttemptId \u003d\n         YarnServerSecurityUtils.authorizeRequest().getApplicationAttemptId();\n     ApplicationId appId \u003d applicationAttemptId.getApplicationId();\n \n     RMApp rmApp \u003d\n         rmContext.getRMApps().get(applicationAttemptId.getApplicationId());\n \n     // Remove collector address when app get finished.\n     if (YarnConfiguration.timelineServiceV2Enabled(getConfig())) {\n       rmApp.removeCollectorAddr();\n     }\n     // checking whether the app exits in RMStateStore at first not to throw\n     // ApplicationDoesNotExistInCacheException before and after\n     // RM work-preserving restart.\n     if (rmApp.isAppFinalStateStored()) {\n       LOG.info(rmApp.getApplicationId() + \" unregistered successfully. \");\n       return FinishApplicationMasterResponse.newInstance(true);\n     }\n \n     AllocateResponseLock lock \u003d responseMap.get(applicationAttemptId);\n     if (lock \u003d\u003d null) {\n       throwApplicationDoesNotExistInCacheException(applicationAttemptId);\n     }\n \n     // Allow only one thread in AM to do finishApp at a time.\n     synchronized (lock) {\n       if (!hasApplicationMasterRegistered(applicationAttemptId)) {\n         String message \u003d\n             \"Application Master is trying to unregister before registering for: \"\n                 + appId;\n         LOG.error(message);\n         RMAuditLogger.logFailure(\n             this.rmContext.getRMApps()\n                 .get(appId).getUser(),\n             AuditConstants.UNREGISTER_AM, \"\", \"ApplicationMasterService\",\n             message, appId,\n             applicationAttemptId);\n         throw new ApplicationMasterNotRegisteredException(message);\n       }\n \n       this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n-      return this.amsProcessor.finishApplicationMaster(\n-          applicationAttemptId, request);\n+      FinishApplicationMasterResponse response \u003d\n+          FinishApplicationMasterResponse.newInstance(false);\n+      this.amsProcessingChain.finishApplicationMaster(\n+          applicationAttemptId, request, response);\n+      return response;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FinishApplicationMasterResponse finishApplicationMaster(\n      FinishApplicationMasterRequest request) throws YarnException,\n      IOException {\n\n    ApplicationAttemptId applicationAttemptId \u003d\n        YarnServerSecurityUtils.authorizeRequest().getApplicationAttemptId();\n    ApplicationId appId \u003d applicationAttemptId.getApplicationId();\n\n    RMApp rmApp \u003d\n        rmContext.getRMApps().get(applicationAttemptId.getApplicationId());\n\n    // Remove collector address when app get finished.\n    if (YarnConfiguration.timelineServiceV2Enabled(getConfig())) {\n      rmApp.removeCollectorAddr();\n    }\n    // checking whether the app exits in RMStateStore at first not to throw\n    // ApplicationDoesNotExistInCacheException before and after\n    // RM work-preserving restart.\n    if (rmApp.isAppFinalStateStored()) {\n      LOG.info(rmApp.getApplicationId() + \" unregistered successfully. \");\n      return FinishApplicationMasterResponse.newInstance(true);\n    }\n\n    AllocateResponseLock lock \u003d responseMap.get(applicationAttemptId);\n    if (lock \u003d\u003d null) {\n      throwApplicationDoesNotExistInCacheException(applicationAttemptId);\n    }\n\n    // Allow only one thread in AM to do finishApp at a time.\n    synchronized (lock) {\n      if (!hasApplicationMasterRegistered(applicationAttemptId)) {\n        String message \u003d\n            \"Application Master is trying to unregister before registering for: \"\n                + appId;\n        LOG.error(message);\n        RMAuditLogger.logFailure(\n            this.rmContext.getRMApps()\n                .get(appId).getUser(),\n            AuditConstants.UNREGISTER_AM, \"\", \"ApplicationMasterService\",\n            message, appId,\n            applicationAttemptId);\n        throw new ApplicationMasterNotRegisteredException(message);\n      }\n\n      this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n      FinishApplicationMasterResponse response \u003d\n          FinishApplicationMasterResponse.newInstance(false);\n      this.amsProcessingChain.finishApplicationMaster(\n          applicationAttemptId, request, response);\n      return response;\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java",
      "extendedDetails": {}
    },
    "5496a34c0cb2b1a83cfa6b0aba5a77b05ff2d8f0": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6776. Refactor ApplicaitonMasterService to move actual processing logic to a separate class. (asuresh)\n",
      "commitDate": "10/07/17 2:34 PM",
      "commitName": "5496a34c0cb2b1a83cfa6b0aba5a77b05ff2d8f0",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "01/05/17 7:45 AM",
      "commitNameOld": "30fc5801966feb7f9bdd7d79db75acc595102913",
      "commitAuthorOld": "Naganarasimha",
      "daysBetweenCommits": 70.28,
      "commitsBetweenForRepo": 344,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,56 +1,49 @@\n   public FinishApplicationMasterResponse finishApplicationMaster(\n       FinishApplicationMasterRequest request) throws YarnException,\n       IOException {\n \n     ApplicationAttemptId applicationAttemptId \u003d\n         YarnServerSecurityUtils.authorizeRequest().getApplicationAttemptId();\n     ApplicationId appId \u003d applicationAttemptId.getApplicationId();\n \n     RMApp rmApp \u003d\n         rmContext.getRMApps().get(applicationAttemptId.getApplicationId());\n \n     // Remove collector address when app get finished.\n     if (YarnConfiguration.timelineServiceV2Enabled(getConfig())) {\n       rmApp.removeCollectorAddr();\n     }\n     // checking whether the app exits in RMStateStore at first not to throw\n     // ApplicationDoesNotExistInCacheException before and after\n     // RM work-preserving restart.\n     if (rmApp.isAppFinalStateStored()) {\n       LOG.info(rmApp.getApplicationId() + \" unregistered successfully. \");\n       return FinishApplicationMasterResponse.newInstance(true);\n     }\n \n     AllocateResponseLock lock \u003d responseMap.get(applicationAttemptId);\n     if (lock \u003d\u003d null) {\n       throwApplicationDoesNotExistInCacheException(applicationAttemptId);\n     }\n \n     // Allow only one thread in AM to do finishApp at a time.\n     synchronized (lock) {\n       if (!hasApplicationMasterRegistered(applicationAttemptId)) {\n         String message \u003d\n             \"Application Master is trying to unregister before registering for: \"\n                 + appId;\n         LOG.error(message);\n         RMAuditLogger.logFailure(\n             this.rmContext.getRMApps()\n                 .get(appId).getUser(),\n             AuditConstants.UNREGISTER_AM, \"\", \"ApplicationMasterService\",\n             message, appId,\n             applicationAttemptId);\n         throw new ApplicationMasterNotRegisteredException(message);\n       }\n \n       this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n-\n-      rmContext.getDispatcher().getEventHandler().handle(\n-          new RMAppAttemptUnregistrationEvent(applicationAttemptId, request\n-              .getTrackingUrl(), request.getFinalApplicationStatus(), request\n-              .getDiagnostics()));\n-\n-      // For UnmanagedAMs, return true so they don\u0027t retry\n-      return FinishApplicationMasterResponse.newInstance(\n-          rmApp.getApplicationSubmissionContext().getUnmanagedAM());\n+      return this.amsProcessor.finishApplicationMaster(\n+          applicationAttemptId, request);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FinishApplicationMasterResponse finishApplicationMaster(\n      FinishApplicationMasterRequest request) throws YarnException,\n      IOException {\n\n    ApplicationAttemptId applicationAttemptId \u003d\n        YarnServerSecurityUtils.authorizeRequest().getApplicationAttemptId();\n    ApplicationId appId \u003d applicationAttemptId.getApplicationId();\n\n    RMApp rmApp \u003d\n        rmContext.getRMApps().get(applicationAttemptId.getApplicationId());\n\n    // Remove collector address when app get finished.\n    if (YarnConfiguration.timelineServiceV2Enabled(getConfig())) {\n      rmApp.removeCollectorAddr();\n    }\n    // checking whether the app exits in RMStateStore at first not to throw\n    // ApplicationDoesNotExistInCacheException before and after\n    // RM work-preserving restart.\n    if (rmApp.isAppFinalStateStored()) {\n      LOG.info(rmApp.getApplicationId() + \" unregistered successfully. \");\n      return FinishApplicationMasterResponse.newInstance(true);\n    }\n\n    AllocateResponseLock lock \u003d responseMap.get(applicationAttemptId);\n    if (lock \u003d\u003d null) {\n      throwApplicationDoesNotExistInCacheException(applicationAttemptId);\n    }\n\n    // Allow only one thread in AM to do finishApp at a time.\n    synchronized (lock) {\n      if (!hasApplicationMasterRegistered(applicationAttemptId)) {\n        String message \u003d\n            \"Application Master is trying to unregister before registering for: \"\n                + appId;\n        LOG.error(message);\n        RMAuditLogger.logFailure(\n            this.rmContext.getRMApps()\n                .get(appId).getUser(),\n            AuditConstants.UNREGISTER_AM, \"\", \"ApplicationMasterService\",\n            message, appId,\n            applicationAttemptId);\n        throw new ApplicationMasterNotRegisteredException(message);\n      }\n\n      this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n      return this.amsProcessor.finishApplicationMaster(\n          applicationAttemptId, request);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java",
      "extendedDetails": {}
    },
    "89e5c44f9e891a3579384c3fa3766937cd4970f1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4356. Ensure the timeline service v.2 is disabled cleanly and has no\nimpact when it\u0027s turned off. Contributed by Sangjin Lee.\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "89e5c44f9e891a3579384c3fa3766937cd4970f1",
      "commitAuthor": "Li Lu",
      "commitDateOld": "10/07/16 8:45 AM",
      "commitNameOld": "2188a07e5bea1da26bf679ca0ece26ab596d3438",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 57,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,56 @@\n   public FinishApplicationMasterResponse finishApplicationMaster(\n       FinishApplicationMasterRequest request) throws YarnException,\n       IOException {\n \n     ApplicationAttemptId applicationAttemptId \u003d\n         YarnServerSecurityUtils.authorizeRequest().getApplicationAttemptId();\n     ApplicationId appId \u003d applicationAttemptId.getApplicationId();\n \n     RMApp rmApp \u003d\n         rmContext.getRMApps().get(applicationAttemptId.getApplicationId());\n+\n     // Remove collector address when app get finished.\n-    rmApp.removeCollectorAddr();\n+    if (YarnConfiguration.timelineServiceV2Enabled(getConfig())) {\n+      rmApp.removeCollectorAddr();\n+    }\n     // checking whether the app exits in RMStateStore at first not to throw\n     // ApplicationDoesNotExistInCacheException before and after\n     // RM work-preserving restart.\n     if (rmApp.isAppFinalStateStored()) {\n       LOG.info(rmApp.getApplicationId() + \" unregistered successfully. \");\n       return FinishApplicationMasterResponse.newInstance(true);\n     }\n \n     AllocateResponseLock lock \u003d responseMap.get(applicationAttemptId);\n     if (lock \u003d\u003d null) {\n       throwApplicationDoesNotExistInCacheException(applicationAttemptId);\n     }\n \n     // Allow only one thread in AM to do finishApp at a time.\n     synchronized (lock) {\n       if (!hasApplicationMasterRegistered(applicationAttemptId)) {\n         String message \u003d\n             \"Application Master is trying to unregister before registering for: \"\n                 + appId;\n         LOG.error(message);\n         RMAuditLogger.logFailure(\n             this.rmContext.getRMApps()\n                 .get(appId).getUser(),\n             AuditConstants.UNREGISTER_AM, \"\", \"ApplicationMasterService\",\n             message, appId,\n             applicationAttemptId);\n         throw new ApplicationMasterNotRegisteredException(message);\n       }\n \n       this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n \n       rmContext.getDispatcher().getEventHandler().handle(\n           new RMAppAttemptUnregistrationEvent(applicationAttemptId, request\n               .getTrackingUrl(), request.getFinalApplicationStatus(), request\n               .getDiagnostics()));\n \n       // For UnmanagedAMs, return true so they don\u0027t retry\n       return FinishApplicationMasterResponse.newInstance(\n           rmApp.getApplicationSubmissionContext().getUnmanagedAM());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FinishApplicationMasterResponse finishApplicationMaster(\n      FinishApplicationMasterRequest request) throws YarnException,\n      IOException {\n\n    ApplicationAttemptId applicationAttemptId \u003d\n        YarnServerSecurityUtils.authorizeRequest().getApplicationAttemptId();\n    ApplicationId appId \u003d applicationAttemptId.getApplicationId();\n\n    RMApp rmApp \u003d\n        rmContext.getRMApps().get(applicationAttemptId.getApplicationId());\n\n    // Remove collector address when app get finished.\n    if (YarnConfiguration.timelineServiceV2Enabled(getConfig())) {\n      rmApp.removeCollectorAddr();\n    }\n    // checking whether the app exits in RMStateStore at first not to throw\n    // ApplicationDoesNotExistInCacheException before and after\n    // RM work-preserving restart.\n    if (rmApp.isAppFinalStateStored()) {\n      LOG.info(rmApp.getApplicationId() + \" unregistered successfully. \");\n      return FinishApplicationMasterResponse.newInstance(true);\n    }\n\n    AllocateResponseLock lock \u003d responseMap.get(applicationAttemptId);\n    if (lock \u003d\u003d null) {\n      throwApplicationDoesNotExistInCacheException(applicationAttemptId);\n    }\n\n    // Allow only one thread in AM to do finishApp at a time.\n    synchronized (lock) {\n      if (!hasApplicationMasterRegistered(applicationAttemptId)) {\n        String message \u003d\n            \"Application Master is trying to unregister before registering for: \"\n                + appId;\n        LOG.error(message);\n        RMAuditLogger.logFailure(\n            this.rmContext.getRMApps()\n                .get(appId).getUser(),\n            AuditConstants.UNREGISTER_AM, \"\", \"ApplicationMasterService\",\n            message, appId,\n            applicationAttemptId);\n        throw new ApplicationMasterNotRegisteredException(message);\n      }\n\n      this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n\n      rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppAttemptUnregistrationEvent(applicationAttemptId, request\n              .getTrackingUrl(), request.getFinalApplicationStatus(), request\n              .getDiagnostics()));\n\n      // For UnmanagedAMs, return true so they don\u0027t retry\n      return FinishApplicationMasterResponse.newInstance(\n          rmApp.getApplicationSubmissionContext().getUnmanagedAM());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java",
      "extendedDetails": {}
    },
    "2188a07e5bea1da26bf679ca0ece26ab596d3438": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3333. Rename TimelineAggregator etc. to TimelineCollector. Contributed by Sangjin Lee\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "2188a07e5bea1da26bf679ca0ece26ab596d3438",
      "commitAuthor": "Junping Du",
      "commitDateOld": "10/07/16 8:45 AM",
      "commitNameOld": "9b5636408005676ae580f8d929f8e912c27828e7",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,53 @@\n   public FinishApplicationMasterResponse finishApplicationMaster(\n       FinishApplicationMasterRequest request) throws YarnException,\n       IOException {\n \n     ApplicationAttemptId applicationAttemptId \u003d\n         YarnServerSecurityUtils.authorizeRequest().getApplicationAttemptId();\n     ApplicationId appId \u003d applicationAttemptId.getApplicationId();\n \n     RMApp rmApp \u003d\n         rmContext.getRMApps().get(applicationAttemptId.getApplicationId());\n-    // Remove aggregator address when app get finished.\n-    rmApp.removeAggregatorAddr();\n+    // Remove collector address when app get finished.\n+    rmApp.removeCollectorAddr();\n     // checking whether the app exits in RMStateStore at first not to throw\n     // ApplicationDoesNotExistInCacheException before and after\n     // RM work-preserving restart.\n     if (rmApp.isAppFinalStateStored()) {\n       LOG.info(rmApp.getApplicationId() + \" unregistered successfully. \");\n       return FinishApplicationMasterResponse.newInstance(true);\n     }\n \n     AllocateResponseLock lock \u003d responseMap.get(applicationAttemptId);\n     if (lock \u003d\u003d null) {\n       throwApplicationDoesNotExistInCacheException(applicationAttemptId);\n     }\n \n     // Allow only one thread in AM to do finishApp at a time.\n     synchronized (lock) {\n       if (!hasApplicationMasterRegistered(applicationAttemptId)) {\n         String message \u003d\n             \"Application Master is trying to unregister before registering for: \"\n                 + appId;\n         LOG.error(message);\n         RMAuditLogger.logFailure(\n             this.rmContext.getRMApps()\n                 .get(appId).getUser(),\n             AuditConstants.UNREGISTER_AM, \"\", \"ApplicationMasterService\",\n             message, appId,\n             applicationAttemptId);\n         throw new ApplicationMasterNotRegisteredException(message);\n       }\n \n       this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n \n       rmContext.getDispatcher().getEventHandler().handle(\n           new RMAppAttemptUnregistrationEvent(applicationAttemptId, request\n               .getTrackingUrl(), request.getFinalApplicationStatus(), request\n               .getDiagnostics()));\n \n       // For UnmanagedAMs, return true so they don\u0027t retry\n       return FinishApplicationMasterResponse.newInstance(\n           rmApp.getApplicationSubmissionContext().getUnmanagedAM());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FinishApplicationMasterResponse finishApplicationMaster(\n      FinishApplicationMasterRequest request) throws YarnException,\n      IOException {\n\n    ApplicationAttemptId applicationAttemptId \u003d\n        YarnServerSecurityUtils.authorizeRequest().getApplicationAttemptId();\n    ApplicationId appId \u003d applicationAttemptId.getApplicationId();\n\n    RMApp rmApp \u003d\n        rmContext.getRMApps().get(applicationAttemptId.getApplicationId());\n    // Remove collector address when app get finished.\n    rmApp.removeCollectorAddr();\n    // checking whether the app exits in RMStateStore at first not to throw\n    // ApplicationDoesNotExistInCacheException before and after\n    // RM work-preserving restart.\n    if (rmApp.isAppFinalStateStored()) {\n      LOG.info(rmApp.getApplicationId() + \" unregistered successfully. \");\n      return FinishApplicationMasterResponse.newInstance(true);\n    }\n\n    AllocateResponseLock lock \u003d responseMap.get(applicationAttemptId);\n    if (lock \u003d\u003d null) {\n      throwApplicationDoesNotExistInCacheException(applicationAttemptId);\n    }\n\n    // Allow only one thread in AM to do finishApp at a time.\n    synchronized (lock) {\n      if (!hasApplicationMasterRegistered(applicationAttemptId)) {\n        String message \u003d\n            \"Application Master is trying to unregister before registering for: \"\n                + appId;\n        LOG.error(message);\n        RMAuditLogger.logFailure(\n            this.rmContext.getRMApps()\n                .get(appId).getUser(),\n            AuditConstants.UNREGISTER_AM, \"\", \"ApplicationMasterService\",\n            message, appId,\n            applicationAttemptId);\n        throw new ApplicationMasterNotRegisteredException(message);\n      }\n\n      this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n\n      rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppAttemptUnregistrationEvent(applicationAttemptId, request\n              .getTrackingUrl(), request.getFinalApplicationStatus(), request\n              .getDiagnostics()));\n\n      // For UnmanagedAMs, return true so they don\u0027t retry\n      return FinishApplicationMasterResponse.newInstance(\n          rmApp.getApplicationSubmissionContext().getUnmanagedAM());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java",
      "extendedDetails": {}
    },
    "9b5636408005676ae580f8d929f8e912c27828e7": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3039. Implemented the app-level timeline aggregator discovery service. Contributed by Junping Du.\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "9b5636408005676ae580f8d929f8e912c27828e7",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "08/07/16 11:39 AM",
      "commitNameOld": "5252562edf1f65a9c5d502016df8bb92fbe78095",
      "commitAuthorOld": "Varun Saxena",
      "daysBetweenCommits": 1.88,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,51 +1,53 @@\n   public FinishApplicationMasterResponse finishApplicationMaster(\n       FinishApplicationMasterRequest request) throws YarnException,\n       IOException {\n \n     ApplicationAttemptId applicationAttemptId \u003d\n         YarnServerSecurityUtils.authorizeRequest().getApplicationAttemptId();\n     ApplicationId appId \u003d applicationAttemptId.getApplicationId();\n \n     RMApp rmApp \u003d\n         rmContext.getRMApps().get(applicationAttemptId.getApplicationId());\n+    // Remove aggregator address when app get finished.\n+    rmApp.removeAggregatorAddr();\n     // checking whether the app exits in RMStateStore at first not to throw\n     // ApplicationDoesNotExistInCacheException before and after\n     // RM work-preserving restart.\n     if (rmApp.isAppFinalStateStored()) {\n       LOG.info(rmApp.getApplicationId() + \" unregistered successfully. \");\n       return FinishApplicationMasterResponse.newInstance(true);\n     }\n \n     AllocateResponseLock lock \u003d responseMap.get(applicationAttemptId);\n     if (lock \u003d\u003d null) {\n       throwApplicationDoesNotExistInCacheException(applicationAttemptId);\n     }\n \n     // Allow only one thread in AM to do finishApp at a time.\n     synchronized (lock) {\n       if (!hasApplicationMasterRegistered(applicationAttemptId)) {\n         String message \u003d\n             \"Application Master is trying to unregister before registering for: \"\n                 + appId;\n         LOG.error(message);\n         RMAuditLogger.logFailure(\n             this.rmContext.getRMApps()\n                 .get(appId).getUser(),\n             AuditConstants.UNREGISTER_AM, \"\", \"ApplicationMasterService\",\n             message, appId,\n             applicationAttemptId);\n         throw new ApplicationMasterNotRegisteredException(message);\n       }\n \n       this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n \n       rmContext.getDispatcher().getEventHandler().handle(\n           new RMAppAttemptUnregistrationEvent(applicationAttemptId, request\n               .getTrackingUrl(), request.getFinalApplicationStatus(), request\n               .getDiagnostics()));\n \n       // For UnmanagedAMs, return true so they don\u0027t retry\n       return FinishApplicationMasterResponse.newInstance(\n           rmApp.getApplicationSubmissionContext().getUnmanagedAM());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FinishApplicationMasterResponse finishApplicationMaster(\n      FinishApplicationMasterRequest request) throws YarnException,\n      IOException {\n\n    ApplicationAttemptId applicationAttemptId \u003d\n        YarnServerSecurityUtils.authorizeRequest().getApplicationAttemptId();\n    ApplicationId appId \u003d applicationAttemptId.getApplicationId();\n\n    RMApp rmApp \u003d\n        rmContext.getRMApps().get(applicationAttemptId.getApplicationId());\n    // Remove aggregator address when app get finished.\n    rmApp.removeAggregatorAddr();\n    // checking whether the app exits in RMStateStore at first not to throw\n    // ApplicationDoesNotExistInCacheException before and after\n    // RM work-preserving restart.\n    if (rmApp.isAppFinalStateStored()) {\n      LOG.info(rmApp.getApplicationId() + \" unregistered successfully. \");\n      return FinishApplicationMasterResponse.newInstance(true);\n    }\n\n    AllocateResponseLock lock \u003d responseMap.get(applicationAttemptId);\n    if (lock \u003d\u003d null) {\n      throwApplicationDoesNotExistInCacheException(applicationAttemptId);\n    }\n\n    // Allow only one thread in AM to do finishApp at a time.\n    synchronized (lock) {\n      if (!hasApplicationMasterRegistered(applicationAttemptId)) {\n        String message \u003d\n            \"Application Master is trying to unregister before registering for: \"\n                + appId;\n        LOG.error(message);\n        RMAuditLogger.logFailure(\n            this.rmContext.getRMApps()\n                .get(appId).getUser(),\n            AuditConstants.UNREGISTER_AM, \"\", \"ApplicationMasterService\",\n            message, appId,\n            applicationAttemptId);\n        throw new ApplicationMasterNotRegisteredException(message);\n      }\n\n      this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n\n      rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppAttemptUnregistrationEvent(applicationAttemptId, request\n              .getTrackingUrl(), request.getFinalApplicationStatus(), request\n              .getDiagnostics()));\n\n      // For UnmanagedAMs, return true so they don\u0027t retry\n      return FinishApplicationMasterResponse.newInstance(\n          rmApp.getApplicationSubmissionContext().getUnmanagedAM());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java",
      "extendedDetails": {}
    },
    "6f72f1e6003ab11679bebeb96f27f1f62b3b3e02": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2884. Added a proxy service in NM to proxy the the communication between AM and RM. Contributed by Kishore Chaliparambil\n",
      "commitDate": "07/09/15 6:35 PM",
      "commitName": "6f72f1e6003ab11679bebeb96f27f1f62b3b3e02",
      "commitAuthor": "Jian He",
      "commitDateOld": "20/08/15 10:21 PM",
      "commitNameOld": "22de7c1dca1be63d523de833163ae51bfe638a79",
      "commitAuthorOld": "Rohith Sharma K S",
      "daysBetweenCommits": 17.84,
      "commitsBetweenForRepo": 89,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,51 +1,51 @@\n   public FinishApplicationMasterResponse finishApplicationMaster(\n       FinishApplicationMasterRequest request) throws YarnException,\n       IOException {\n \n     ApplicationAttemptId applicationAttemptId \u003d\n-        authorizeRequest().getApplicationAttemptId();\n+        YarnServerSecurityUtils.authorizeRequest().getApplicationAttemptId();\n     ApplicationId appId \u003d applicationAttemptId.getApplicationId();\n \n     RMApp rmApp \u003d\n         rmContext.getRMApps().get(applicationAttemptId.getApplicationId());\n     // checking whether the app exits in RMStateStore at first not to throw\n     // ApplicationDoesNotExistInCacheException before and after\n     // RM work-preserving restart.\n     if (rmApp.isAppFinalStateStored()) {\n       LOG.info(rmApp.getApplicationId() + \" unregistered successfully. \");\n       return FinishApplicationMasterResponse.newInstance(true);\n     }\n \n     AllocateResponseLock lock \u003d responseMap.get(applicationAttemptId);\n     if (lock \u003d\u003d null) {\n       throwApplicationDoesNotExistInCacheException(applicationAttemptId);\n     }\n \n     // Allow only one thread in AM to do finishApp at a time.\n     synchronized (lock) {\n       if (!hasApplicationMasterRegistered(applicationAttemptId)) {\n         String message \u003d\n             \"Application Master is trying to unregister before registering for: \"\n                 + appId;\n         LOG.error(message);\n         RMAuditLogger.logFailure(\n             this.rmContext.getRMApps()\n                 .get(appId).getUser(),\n             AuditConstants.UNREGISTER_AM, \"\", \"ApplicationMasterService\",\n             message, appId,\n             applicationAttemptId);\n         throw new ApplicationMasterNotRegisteredException(message);\n       }\n \n       this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n \n       rmContext.getDispatcher().getEventHandler().handle(\n           new RMAppAttemptUnregistrationEvent(applicationAttemptId, request\n               .getTrackingUrl(), request.getFinalApplicationStatus(), request\n               .getDiagnostics()));\n \n       // For UnmanagedAMs, return true so they don\u0027t retry\n       return FinishApplicationMasterResponse.newInstance(\n           rmApp.getApplicationSubmissionContext().getUnmanagedAM());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FinishApplicationMasterResponse finishApplicationMaster(\n      FinishApplicationMasterRequest request) throws YarnException,\n      IOException {\n\n    ApplicationAttemptId applicationAttemptId \u003d\n        YarnServerSecurityUtils.authorizeRequest().getApplicationAttemptId();\n    ApplicationId appId \u003d applicationAttemptId.getApplicationId();\n\n    RMApp rmApp \u003d\n        rmContext.getRMApps().get(applicationAttemptId.getApplicationId());\n    // checking whether the app exits in RMStateStore at first not to throw\n    // ApplicationDoesNotExistInCacheException before and after\n    // RM work-preserving restart.\n    if (rmApp.isAppFinalStateStored()) {\n      LOG.info(rmApp.getApplicationId() + \" unregistered successfully. \");\n      return FinishApplicationMasterResponse.newInstance(true);\n    }\n\n    AllocateResponseLock lock \u003d responseMap.get(applicationAttemptId);\n    if (lock \u003d\u003d null) {\n      throwApplicationDoesNotExistInCacheException(applicationAttemptId);\n    }\n\n    // Allow only one thread in AM to do finishApp at a time.\n    synchronized (lock) {\n      if (!hasApplicationMasterRegistered(applicationAttemptId)) {\n        String message \u003d\n            \"Application Master is trying to unregister before registering for: \"\n                + appId;\n        LOG.error(message);\n        RMAuditLogger.logFailure(\n            this.rmContext.getRMApps()\n                .get(appId).getUser(),\n            AuditConstants.UNREGISTER_AM, \"\", \"ApplicationMasterService\",\n            message, appId,\n            applicationAttemptId);\n        throw new ApplicationMasterNotRegisteredException(message);\n      }\n\n      this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n\n      rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppAttemptUnregistrationEvent(applicationAttemptId, request\n              .getTrackingUrl(), request.getFinalApplicationStatus(), request\n              .getDiagnostics()));\n\n      // For UnmanagedAMs, return true so they don\u0027t retry\n      return FinishApplicationMasterResponse.newInstance(\n          rmApp.getApplicationSubmissionContext().getUnmanagedAM());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java",
      "extendedDetails": {}
    },
    "3651fe1b089851b38be351c00a9899817166bf3e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2853. Fixed a bug in ResourceManager causing apps to hang when the user kill request races with ApplicationMaster finish. Contributed by Jian He.\n",
      "commitDate": "13/11/14 8:13 AM",
      "commitName": "3651fe1b089851b38be351c00a9899817166bf3e",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "30/10/14 10:59 PM",
      "commitNameOld": "e0233c16ebd06bb3aabeb523cd17259008e243ef",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 13.43,
      "commitsBetweenForRepo": 140,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,50 +1,51 @@\n   public FinishApplicationMasterResponse finishApplicationMaster(\n       FinishApplicationMasterRequest request) throws YarnException,\n       IOException {\n \n     ApplicationAttemptId applicationAttemptId \u003d\n         authorizeRequest().getApplicationAttemptId();\n     ApplicationId appId \u003d applicationAttemptId.getApplicationId();\n \n     RMApp rmApp \u003d\n         rmContext.getRMApps().get(applicationAttemptId.getApplicationId());\n     // checking whether the app exits in RMStateStore at first not to throw\n     // ApplicationDoesNotExistInCacheException before and after\n     // RM work-preserving restart.\n     if (rmApp.isAppFinalStateStored()) {\n+      LOG.info(rmApp.getApplicationId() + \" unregistered successfully. \");\n       return FinishApplicationMasterResponse.newInstance(true);\n     }\n \n     AllocateResponseLock lock \u003d responseMap.get(applicationAttemptId);\n     if (lock \u003d\u003d null) {\n       throwApplicationDoesNotExistInCacheException(applicationAttemptId);\n     }\n \n     // Allow only one thread in AM to do finishApp at a time.\n     synchronized (lock) {\n       if (!hasApplicationMasterRegistered(applicationAttemptId)) {\n         String message \u003d\n             \"Application Master is trying to unregister before registering for: \"\n                 + appId;\n         LOG.error(message);\n         RMAuditLogger.logFailure(\n             this.rmContext.getRMApps()\n                 .get(appId).getUser(),\n             AuditConstants.UNREGISTER_AM, \"\", \"ApplicationMasterService\",\n             message, appId,\n             applicationAttemptId);\n         throw new ApplicationMasterNotRegisteredException(message);\n       }\n \n       this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n \n       rmContext.getDispatcher().getEventHandler().handle(\n           new RMAppAttemptUnregistrationEvent(applicationAttemptId, request\n               .getTrackingUrl(), request.getFinalApplicationStatus(), request\n               .getDiagnostics()));\n \n       // For UnmanagedAMs, return true so they don\u0027t retry\n       return FinishApplicationMasterResponse.newInstance(\n           rmApp.getApplicationSubmissionContext().getUnmanagedAM());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FinishApplicationMasterResponse finishApplicationMaster(\n      FinishApplicationMasterRequest request) throws YarnException,\n      IOException {\n\n    ApplicationAttemptId applicationAttemptId \u003d\n        authorizeRequest().getApplicationAttemptId();\n    ApplicationId appId \u003d applicationAttemptId.getApplicationId();\n\n    RMApp rmApp \u003d\n        rmContext.getRMApps().get(applicationAttemptId.getApplicationId());\n    // checking whether the app exits in RMStateStore at first not to throw\n    // ApplicationDoesNotExistInCacheException before and after\n    // RM work-preserving restart.\n    if (rmApp.isAppFinalStateStored()) {\n      LOG.info(rmApp.getApplicationId() + \" unregistered successfully. \");\n      return FinishApplicationMasterResponse.newInstance(true);\n    }\n\n    AllocateResponseLock lock \u003d responseMap.get(applicationAttemptId);\n    if (lock \u003d\u003d null) {\n      throwApplicationDoesNotExistInCacheException(applicationAttemptId);\n    }\n\n    // Allow only one thread in AM to do finishApp at a time.\n    synchronized (lock) {\n      if (!hasApplicationMasterRegistered(applicationAttemptId)) {\n        String message \u003d\n            \"Application Master is trying to unregister before registering for: \"\n                + appId;\n        LOG.error(message);\n        RMAuditLogger.logFailure(\n            this.rmContext.getRMApps()\n                .get(appId).getUser(),\n            AuditConstants.UNREGISTER_AM, \"\", \"ApplicationMasterService\",\n            message, appId,\n            applicationAttemptId);\n        throw new ApplicationMasterNotRegisteredException(message);\n      }\n\n      this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n\n      rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppAttemptUnregistrationEvent(applicationAttemptId, request\n              .getTrackingUrl(), request.getFinalApplicationStatus(), request\n              .getDiagnostics()));\n\n      // For UnmanagedAMs, return true so they don\u0027t retry\n      return FinishApplicationMasterResponse.newInstance(\n          rmApp.getApplicationSubmissionContext().getUnmanagedAM());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java",
      "extendedDetails": {}
    },
    "c3de2412eb7633ff16c67e71e73bbe27a982d984": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1879. Marked Idempotent/AtMostOnce annotations to ApplicationMasterProtocol for RM fail over. Contributed by Tsuyoshi OZAWA\n",
      "commitDate": "17/10/14 4:35 PM",
      "commitName": "c3de2412eb7633ff16c67e71e73bbe27a982d984",
      "commitAuthor": "Jian He",
      "commitDateOld": "15/10/14 6:33 PM",
      "commitNameOld": "f2ea555ac6c06a3f2f6559731f48711fff05d3f1",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 1.92,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,48 +1,50 @@\n   public FinishApplicationMasterResponse finishApplicationMaster(\n       FinishApplicationMasterRequest request) throws YarnException,\n       IOException {\n \n     ApplicationAttemptId applicationAttemptId \u003d\n         authorizeRequest().getApplicationAttemptId();\n     ApplicationId appId \u003d applicationAttemptId.getApplicationId();\n \n+    RMApp rmApp \u003d\n+        rmContext.getRMApps().get(applicationAttemptId.getApplicationId());\n+    // checking whether the app exits in RMStateStore at first not to throw\n+    // ApplicationDoesNotExistInCacheException before and after\n+    // RM work-preserving restart.\n+    if (rmApp.isAppFinalStateStored()) {\n+      return FinishApplicationMasterResponse.newInstance(true);\n+    }\n+\n     AllocateResponseLock lock \u003d responseMap.get(applicationAttemptId);\n     if (lock \u003d\u003d null) {\n       throwApplicationDoesNotExistInCacheException(applicationAttemptId);\n     }\n \n     // Allow only one thread in AM to do finishApp at a time.\n     synchronized (lock) {\n       if (!hasApplicationMasterRegistered(applicationAttemptId)) {\n         String message \u003d\n             \"Application Master is trying to unregister before registering for: \"\n                 + appId;\n         LOG.error(message);\n         RMAuditLogger.logFailure(\n             this.rmContext.getRMApps()\n                 .get(appId).getUser(),\n             AuditConstants.UNREGISTER_AM, \"\", \"ApplicationMasterService\",\n             message, appId,\n             applicationAttemptId);\n         throw new ApplicationMasterNotRegisteredException(message);\n       }\n \n       this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n \n-      RMApp rmApp \u003d\n-          rmContext.getRMApps().get(appId);\n-\n-      if (rmApp.isAppFinalStateStored()) {\n-        return FinishApplicationMasterResponse.newInstance(true);\n-      }\n-\n       rmContext.getDispatcher().getEventHandler().handle(\n           new RMAppAttemptUnregistrationEvent(applicationAttemptId, request\n               .getTrackingUrl(), request.getFinalApplicationStatus(), request\n               .getDiagnostics()));\n \n       // For UnmanagedAMs, return true so they don\u0027t retry\n       return FinishApplicationMasterResponse.newInstance(\n           rmApp.getApplicationSubmissionContext().getUnmanagedAM());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FinishApplicationMasterResponse finishApplicationMaster(\n      FinishApplicationMasterRequest request) throws YarnException,\n      IOException {\n\n    ApplicationAttemptId applicationAttemptId \u003d\n        authorizeRequest().getApplicationAttemptId();\n    ApplicationId appId \u003d applicationAttemptId.getApplicationId();\n\n    RMApp rmApp \u003d\n        rmContext.getRMApps().get(applicationAttemptId.getApplicationId());\n    // checking whether the app exits in RMStateStore at first not to throw\n    // ApplicationDoesNotExistInCacheException before and after\n    // RM work-preserving restart.\n    if (rmApp.isAppFinalStateStored()) {\n      return FinishApplicationMasterResponse.newInstance(true);\n    }\n\n    AllocateResponseLock lock \u003d responseMap.get(applicationAttemptId);\n    if (lock \u003d\u003d null) {\n      throwApplicationDoesNotExistInCacheException(applicationAttemptId);\n    }\n\n    // Allow only one thread in AM to do finishApp at a time.\n    synchronized (lock) {\n      if (!hasApplicationMasterRegistered(applicationAttemptId)) {\n        String message \u003d\n            \"Application Master is trying to unregister before registering for: \"\n                + appId;\n        LOG.error(message);\n        RMAuditLogger.logFailure(\n            this.rmContext.getRMApps()\n                .get(appId).getUser(),\n            AuditConstants.UNREGISTER_AM, \"\", \"ApplicationMasterService\",\n            message, appId,\n            applicationAttemptId);\n        throw new ApplicationMasterNotRegisteredException(message);\n      }\n\n      this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n\n      rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppAttemptUnregistrationEvent(applicationAttemptId, request\n              .getTrackingUrl(), request.getFinalApplicationStatus(), request\n              .getDiagnostics()));\n\n      // For UnmanagedAMs, return true so they don\u0027t retry\n      return FinishApplicationMasterResponse.newInstance(\n          rmApp.getApplicationSubmissionContext().getUnmanagedAM());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java",
      "extendedDetails": {}
    },
    "f2ea555ac6c06a3f2f6559731f48711fff05d3f1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2496. Enhanced Capacity Scheduler to have basic support for allocating resources based on node-labels. Contributed by Wangda Tan.\nYARN-2500. Ehnaced ResourceManager to support schedulers allocating resources based on node-labels. Contributed by Wangda Tan.\n",
      "commitDate": "15/10/14 6:33 PM",
      "commitName": "f2ea555ac6c06a3f2f6559731f48711fff05d3f1",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "11/09/14 10:19 PM",
      "commitNameOld": "469ea3dcef6e427d02fd08b859b2789cc25189f9",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 33.84,
      "commitsBetweenForRepo": 350,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,48 @@\n   public FinishApplicationMasterResponse finishApplicationMaster(\n       FinishApplicationMasterRequest request) throws YarnException,\n       IOException {\n \n     ApplicationAttemptId applicationAttemptId \u003d\n         authorizeRequest().getApplicationAttemptId();\n+    ApplicationId appId \u003d applicationAttemptId.getApplicationId();\n \n     AllocateResponseLock lock \u003d responseMap.get(applicationAttemptId);\n     if (lock \u003d\u003d null) {\n       throwApplicationDoesNotExistInCacheException(applicationAttemptId);\n     }\n \n     // Allow only one thread in AM to do finishApp at a time.\n     synchronized (lock) {\n       if (!hasApplicationMasterRegistered(applicationAttemptId)) {\n         String message \u003d\n             \"Application Master is trying to unregister before registering for: \"\n-                + applicationAttemptId.getApplicationId();\n+                + appId;\n         LOG.error(message);\n         RMAuditLogger.logFailure(\n             this.rmContext.getRMApps()\n-                .get(applicationAttemptId.getApplicationId()).getUser(),\n+                .get(appId).getUser(),\n             AuditConstants.UNREGISTER_AM, \"\", \"ApplicationMasterService\",\n-            message, applicationAttemptId.getApplicationId(),\n+            message, appId,\n             applicationAttemptId);\n         throw new ApplicationMasterNotRegisteredException(message);\n       }\n \n       this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n \n       RMApp rmApp \u003d\n-          rmContext.getRMApps().get(applicationAttemptId.getApplicationId());\n+          rmContext.getRMApps().get(appId);\n \n       if (rmApp.isAppFinalStateStored()) {\n         return FinishApplicationMasterResponse.newInstance(true);\n       }\n \n       rmContext.getDispatcher().getEventHandler().handle(\n           new RMAppAttemptUnregistrationEvent(applicationAttemptId, request\n               .getTrackingUrl(), request.getFinalApplicationStatus(), request\n               .getDiagnostics()));\n \n       // For UnmanagedAMs, return true so they don\u0027t retry\n       return FinishApplicationMasterResponse.newInstance(\n           rmApp.getApplicationSubmissionContext().getUnmanagedAM());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FinishApplicationMasterResponse finishApplicationMaster(\n      FinishApplicationMasterRequest request) throws YarnException,\n      IOException {\n\n    ApplicationAttemptId applicationAttemptId \u003d\n        authorizeRequest().getApplicationAttemptId();\n    ApplicationId appId \u003d applicationAttemptId.getApplicationId();\n\n    AllocateResponseLock lock \u003d responseMap.get(applicationAttemptId);\n    if (lock \u003d\u003d null) {\n      throwApplicationDoesNotExistInCacheException(applicationAttemptId);\n    }\n\n    // Allow only one thread in AM to do finishApp at a time.\n    synchronized (lock) {\n      if (!hasApplicationMasterRegistered(applicationAttemptId)) {\n        String message \u003d\n            \"Application Master is trying to unregister before registering for: \"\n                + appId;\n        LOG.error(message);\n        RMAuditLogger.logFailure(\n            this.rmContext.getRMApps()\n                .get(appId).getUser(),\n            AuditConstants.UNREGISTER_AM, \"\", \"ApplicationMasterService\",\n            message, appId,\n            applicationAttemptId);\n        throw new ApplicationMasterNotRegisteredException(message);\n      }\n\n      this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n\n      RMApp rmApp \u003d\n          rmContext.getRMApps().get(appId);\n\n      if (rmApp.isAppFinalStateStored()) {\n        return FinishApplicationMasterResponse.newInstance(true);\n      }\n\n      rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppAttemptUnregistrationEvent(applicationAttemptId, request\n              .getTrackingUrl(), request.getFinalApplicationStatus(), request\n              .getDiagnostics()));\n\n      // For UnmanagedAMs, return true so they don\u0027t retry\n      return FinishApplicationMasterResponse.newInstance(\n          rmApp.getApplicationSubmissionContext().getUnmanagedAM());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java",
      "extendedDetails": {}
    },
    "eeb4acd955802e2a84ea94cecf2e2341b83d5efb": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2212: ApplicationMaster needs to find a way to update the AMRMToken periodically. Contributed by Xuan Gong\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1616892 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/08/14 2:38 PM",
      "commitName": "eeb4acd955802e2a84ea94cecf2e2341b83d5efb",
      "commitAuthor": "Xuan Gong",
      "commitDateOld": "31/07/14 1:06 PM",
      "commitNameOld": "e52f67e3897a67a0b6d29e557a31cfa881738821",
      "commitAuthorOld": "Xuan Gong",
      "daysBetweenCommits": 8.06,
      "commitsBetweenForRepo": 70,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,47 @@\n   public FinishApplicationMasterResponse finishApplicationMaster(\n       FinishApplicationMasterRequest request) throws YarnException,\n       IOException {\n \n-    ApplicationAttemptId applicationAttemptId \u003d authorizeRequest();\n+    ApplicationAttemptId applicationAttemptId \u003d\n+        authorizeRequest().getApplicationAttemptId();\n \n     AllocateResponseLock lock \u003d responseMap.get(applicationAttemptId);\n     if (lock \u003d\u003d null) {\n       throwApplicationDoesNotExistInCacheException(applicationAttemptId);\n     }\n \n     // Allow only one thread in AM to do finishApp at a time.\n     synchronized (lock) {\n       if (!hasApplicationMasterRegistered(applicationAttemptId)) {\n         String message \u003d\n             \"Application Master is trying to unregister before registering for: \"\n                 + applicationAttemptId.getApplicationId();\n         LOG.error(message);\n         RMAuditLogger.logFailure(\n             this.rmContext.getRMApps()\n                 .get(applicationAttemptId.getApplicationId()).getUser(),\n             AuditConstants.UNREGISTER_AM, \"\", \"ApplicationMasterService\",\n             message, applicationAttemptId.getApplicationId(),\n             applicationAttemptId);\n         throw new ApplicationMasterNotRegisteredException(message);\n       }\n \n       this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n \n       RMApp rmApp \u003d\n           rmContext.getRMApps().get(applicationAttemptId.getApplicationId());\n \n       if (rmApp.isAppFinalStateStored()) {\n         return FinishApplicationMasterResponse.newInstance(true);\n       }\n \n       rmContext.getDispatcher().getEventHandler().handle(\n           new RMAppAttemptUnregistrationEvent(applicationAttemptId, request\n               .getTrackingUrl(), request.getFinalApplicationStatus(), request\n               .getDiagnostics()));\n \n       // For UnmanagedAMs, return true so they don\u0027t retry\n       return FinishApplicationMasterResponse.newInstance(\n           rmApp.getApplicationSubmissionContext().getUnmanagedAM());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FinishApplicationMasterResponse finishApplicationMaster(\n      FinishApplicationMasterRequest request) throws YarnException,\n      IOException {\n\n    ApplicationAttemptId applicationAttemptId \u003d\n        authorizeRequest().getApplicationAttemptId();\n\n    AllocateResponseLock lock \u003d responseMap.get(applicationAttemptId);\n    if (lock \u003d\u003d null) {\n      throwApplicationDoesNotExistInCacheException(applicationAttemptId);\n    }\n\n    // Allow only one thread in AM to do finishApp at a time.\n    synchronized (lock) {\n      if (!hasApplicationMasterRegistered(applicationAttemptId)) {\n        String message \u003d\n            \"Application Master is trying to unregister before registering for: \"\n                + applicationAttemptId.getApplicationId();\n        LOG.error(message);\n        RMAuditLogger.logFailure(\n            this.rmContext.getRMApps()\n                .get(applicationAttemptId.getApplicationId()).getUser(),\n            AuditConstants.UNREGISTER_AM, \"\", \"ApplicationMasterService\",\n            message, applicationAttemptId.getApplicationId(),\n            applicationAttemptId);\n        throw new ApplicationMasterNotRegisteredException(message);\n      }\n\n      this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n\n      RMApp rmApp \u003d\n          rmContext.getRMApps().get(applicationAttemptId.getApplicationId());\n\n      if (rmApp.isAppFinalStateStored()) {\n        return FinishApplicationMasterResponse.newInstance(true);\n      }\n\n      rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppAttemptUnregistrationEvent(applicationAttemptId, request\n              .getTrackingUrl(), request.getFinalApplicationStatus(), request\n              .getDiagnostics()));\n\n      // For UnmanagedAMs, return true so they don\u0027t retry\n      return FinishApplicationMasterResponse.newInstance(\n          rmApp.getApplicationSubmissionContext().getUnmanagedAM());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java",
      "extendedDetails": {}
    },
    "c3f1c30e65cc6a10928299f50801782ecbb4ccb6": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1365. Changed ApplicationMasterService to allow an app to re-register after RM restart. Contributed by Anubhav Dhoot\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1605263 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/06/14 9:42 PM",
      "commitName": "c3f1c30e65cc6a10928299f50801782ecbb4ccb6",
      "commitAuthor": "Jian He",
      "commitDateOld": "15/05/14 11:22 PM",
      "commitNameOld": "0f9147c8579a8e8a1600e8c8182662d94296bd51",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 39.93,
      "commitsBetweenForRepo": 242,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,46 @@\n   public FinishApplicationMasterResponse finishApplicationMaster(\n       FinishApplicationMasterRequest request) throws YarnException,\n       IOException {\n \n     ApplicationAttemptId applicationAttemptId \u003d authorizeRequest();\n \n     AllocateResponseLock lock \u003d responseMap.get(applicationAttemptId);\n     if (lock \u003d\u003d null) {\n       throwApplicationDoesNotExistInCacheException(applicationAttemptId);\n     }\n \n     // Allow only one thread in AM to do finishApp at a time.\n     synchronized (lock) {\n       if (!hasApplicationMasterRegistered(applicationAttemptId)) {\n         String message \u003d\n             \"Application Master is trying to unregister before registering for: \"\n                 + applicationAttemptId.getApplicationId();\n         LOG.error(message);\n         RMAuditLogger.logFailure(\n             this.rmContext.getRMApps()\n                 .get(applicationAttemptId.getApplicationId()).getUser(),\n             AuditConstants.UNREGISTER_AM, \"\", \"ApplicationMasterService\",\n             message, applicationAttemptId.getApplicationId(),\n             applicationAttemptId);\n-        throw new InvalidApplicationMasterRequestException(message);\n+        throw new ApplicationMasterNotRegisteredException(message);\n       }\n-      \n+\n       this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n \n       RMApp rmApp \u003d\n           rmContext.getRMApps().get(applicationAttemptId.getApplicationId());\n \n       if (rmApp.isAppFinalStateStored()) {\n         return FinishApplicationMasterResponse.newInstance(true);\n       }\n \n       rmContext.getDispatcher().getEventHandler().handle(\n           new RMAppAttemptUnregistrationEvent(applicationAttemptId, request\n               .getTrackingUrl(), request.getFinalApplicationStatus(), request\n               .getDiagnostics()));\n \n       // For UnmanagedAMs, return true so they don\u0027t retry\n       return FinishApplicationMasterResponse.newInstance(\n           rmApp.getApplicationSubmissionContext().getUnmanagedAM());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FinishApplicationMasterResponse finishApplicationMaster(\n      FinishApplicationMasterRequest request) throws YarnException,\n      IOException {\n\n    ApplicationAttemptId applicationAttemptId \u003d authorizeRequest();\n\n    AllocateResponseLock lock \u003d responseMap.get(applicationAttemptId);\n    if (lock \u003d\u003d null) {\n      throwApplicationDoesNotExistInCacheException(applicationAttemptId);\n    }\n\n    // Allow only one thread in AM to do finishApp at a time.\n    synchronized (lock) {\n      if (!hasApplicationMasterRegistered(applicationAttemptId)) {\n        String message \u003d\n            \"Application Master is trying to unregister before registering for: \"\n                + applicationAttemptId.getApplicationId();\n        LOG.error(message);\n        RMAuditLogger.logFailure(\n            this.rmContext.getRMApps()\n                .get(applicationAttemptId.getApplicationId()).getUser(),\n            AuditConstants.UNREGISTER_AM, \"\", \"ApplicationMasterService\",\n            message, applicationAttemptId.getApplicationId(),\n            applicationAttemptId);\n        throw new ApplicationMasterNotRegisteredException(message);\n      }\n\n      this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n\n      RMApp rmApp \u003d\n          rmContext.getRMApps().get(applicationAttemptId.getApplicationId());\n\n      if (rmApp.isAppFinalStateStored()) {\n        return FinishApplicationMasterResponse.newInstance(true);\n      }\n\n      rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppAttemptUnregistrationEvent(applicationAttemptId, request\n              .getTrackingUrl(), request.getFinalApplicationStatus(), request\n              .getDiagnostics()));\n\n      // For UnmanagedAMs, return true so they don\u0027t retry\n      return FinishApplicationMasterResponse.newInstance(\n          rmApp.getApplicationSubmissionContext().getUnmanagedAM());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java",
      "extendedDetails": {}
    },
    "7da07461ffadb462567c81ad155d3d1473ad89d7": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1793. Fixed ClientRMService#forceKillApplication not killing unmanaged application. Contributed by Karthik Kambatla\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1576023 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/03/14 10:58 AM",
      "commitName": "7da07461ffadb462567c81ad155d3d1473ad89d7",
      "commitAuthor": "Jian He",
      "commitDateOld": "05/03/14 11:04 AM",
      "commitNameOld": "8cd23c5b4845a242bb3a0e220444f48dff285c34",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 4.95,
      "commitsBetweenForRepo": 38,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,55 +1,46 @@\n   public FinishApplicationMasterResponse finishApplicationMaster(\n       FinishApplicationMasterRequest request) throws YarnException,\n       IOException {\n \n     ApplicationAttemptId applicationAttemptId \u003d authorizeRequest();\n \n     AllocateResponseLock lock \u003d responseMap.get(applicationAttemptId);\n     if (lock \u003d\u003d null) {\n       throwApplicationDoesNotExistInCacheException(applicationAttemptId);\n     }\n \n     // Allow only one thread in AM to do finishApp at a time.\n     synchronized (lock) {\n       if (!hasApplicationMasterRegistered(applicationAttemptId)) {\n         String message \u003d\n             \"Application Master is trying to unregister before registering for: \"\n                 + applicationAttemptId.getApplicationId();\n         LOG.error(message);\n         RMAuditLogger.logFailure(\n             this.rmContext.getRMApps()\n                 .get(applicationAttemptId.getApplicationId()).getUser(),\n             AuditConstants.UNREGISTER_AM, \"\", \"ApplicationMasterService\",\n             message, applicationAttemptId.getApplicationId(),\n             applicationAttemptId);\n         throw new InvalidApplicationMasterRequestException(message);\n       }\n       \n       this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n \n       RMApp rmApp \u003d\n           rmContext.getRMApps().get(applicationAttemptId.getApplicationId());\n \n-      if (rmApp.getApplicationSubmissionContext().getUnmanagedAM()) {\n-        // No recovery supported yet for unmanaged AM. Send the unregister event\n-        // and (falsely) acknowledge state-store write immediately.\n-        rmContext.getDispatcher().getEventHandler().handle(\n-          new RMAppAttemptUnregistrationEvent(applicationAttemptId, request\n-              .getTrackingUrl(), request.getFinalApplicationStatus(), request\n-              .getDiagnostics()));\n+      if (rmApp.isAppFinalStateStored()) {\n         return FinishApplicationMasterResponse.newInstance(true);\n       }\n \n-      // Not an unmanaged-AM.\n-      if (rmApp.isAppSafeToTerminate()) {\n-        return FinishApplicationMasterResponse.newInstance(true);\n-      } else {\n-        // keep sending the unregister event as RM may crash in the meanwhile.\n-        rmContext.getDispatcher().getEventHandler().handle(\n+      rmContext.getDispatcher().getEventHandler().handle(\n           new RMAppAttemptUnregistrationEvent(applicationAttemptId, request\n               .getTrackingUrl(), request.getFinalApplicationStatus(), request\n               .getDiagnostics()));\n-        return FinishApplicationMasterResponse.newInstance(false);\n-      }\n+\n+      // For UnmanagedAMs, return true so they don\u0027t retry\n+      return FinishApplicationMasterResponse.newInstance(\n+          rmApp.getApplicationSubmissionContext().getUnmanagedAM());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FinishApplicationMasterResponse finishApplicationMaster(\n      FinishApplicationMasterRequest request) throws YarnException,\n      IOException {\n\n    ApplicationAttemptId applicationAttemptId \u003d authorizeRequest();\n\n    AllocateResponseLock lock \u003d responseMap.get(applicationAttemptId);\n    if (lock \u003d\u003d null) {\n      throwApplicationDoesNotExistInCacheException(applicationAttemptId);\n    }\n\n    // Allow only one thread in AM to do finishApp at a time.\n    synchronized (lock) {\n      if (!hasApplicationMasterRegistered(applicationAttemptId)) {\n        String message \u003d\n            \"Application Master is trying to unregister before registering for: \"\n                + applicationAttemptId.getApplicationId();\n        LOG.error(message);\n        RMAuditLogger.logFailure(\n            this.rmContext.getRMApps()\n                .get(applicationAttemptId.getApplicationId()).getUser(),\n            AuditConstants.UNREGISTER_AM, \"\", \"ApplicationMasterService\",\n            message, applicationAttemptId.getApplicationId(),\n            applicationAttemptId);\n        throw new InvalidApplicationMasterRequestException(message);\n      }\n      \n      this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n\n      RMApp rmApp \u003d\n          rmContext.getRMApps().get(applicationAttemptId.getApplicationId());\n\n      if (rmApp.isAppFinalStateStored()) {\n        return FinishApplicationMasterResponse.newInstance(true);\n      }\n\n      rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppAttemptUnregistrationEvent(applicationAttemptId, request\n              .getTrackingUrl(), request.getFinalApplicationStatus(), request\n              .getDiagnostics()));\n\n      // For UnmanagedAMs, return true so they don\u0027t retry\n      return FinishApplicationMasterResponse.newInstance(\n          rmApp.getApplicationSubmissionContext().getUnmanagedAM());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java",
      "extendedDetails": {}
    },
    "8cd23c5b4845a242bb3a0e220444f48dff285c34": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1752. Fixed ApplicationMasterService to reject unregister request if AM did not register before. Contributed by Rohith Sharma.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1574623 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "05/03/14 11:04 AM",
      "commitName": "8cd23c5b4845a242bb3a0e220444f48dff285c34",
      "commitAuthor": "Jian He",
      "commitDateOld": "03/03/14 11:41 AM",
      "commitNameOld": "a60434368cdf0fd119d024c2ed10942abdb2e7f1",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 1.97,
      "commitsBetweenForRepo": 27,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,55 @@\n   public FinishApplicationMasterResponse finishApplicationMaster(\n       FinishApplicationMasterRequest request) throws YarnException,\n       IOException {\n \n     ApplicationAttemptId applicationAttemptId \u003d authorizeRequest();\n \n     AllocateResponseLock lock \u003d responseMap.get(applicationAttemptId);\n     if (lock \u003d\u003d null) {\n       throwApplicationDoesNotExistInCacheException(applicationAttemptId);\n     }\n \n     // Allow only one thread in AM to do finishApp at a time.\n     synchronized (lock) {\n+      if (!hasApplicationMasterRegistered(applicationAttemptId)) {\n+        String message \u003d\n+            \"Application Master is trying to unregister before registering for: \"\n+                + applicationAttemptId.getApplicationId();\n+        LOG.error(message);\n+        RMAuditLogger.logFailure(\n+            this.rmContext.getRMApps()\n+                .get(applicationAttemptId.getApplicationId()).getUser(),\n+            AuditConstants.UNREGISTER_AM, \"\", \"ApplicationMasterService\",\n+            message, applicationAttemptId.getApplicationId(),\n+            applicationAttemptId);\n+        throw new InvalidApplicationMasterRequestException(message);\n+      }\n       \n       this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n \n       RMApp rmApp \u003d\n           rmContext.getRMApps().get(applicationAttemptId.getApplicationId());\n \n       if (rmApp.getApplicationSubmissionContext().getUnmanagedAM()) {\n         // No recovery supported yet for unmanaged AM. Send the unregister event\n         // and (falsely) acknowledge state-store write immediately.\n         rmContext.getDispatcher().getEventHandler().handle(\n           new RMAppAttemptUnregistrationEvent(applicationAttemptId, request\n               .getTrackingUrl(), request.getFinalApplicationStatus(), request\n               .getDiagnostics()));\n         return FinishApplicationMasterResponse.newInstance(true);\n       }\n \n       // Not an unmanaged-AM.\n       if (rmApp.isAppSafeToTerminate()) {\n         return FinishApplicationMasterResponse.newInstance(true);\n       } else {\n         // keep sending the unregister event as RM may crash in the meanwhile.\n         rmContext.getDispatcher().getEventHandler().handle(\n           new RMAppAttemptUnregistrationEvent(applicationAttemptId, request\n               .getTrackingUrl(), request.getFinalApplicationStatus(), request\n               .getDiagnostics()));\n         return FinishApplicationMasterResponse.newInstance(false);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FinishApplicationMasterResponse finishApplicationMaster(\n      FinishApplicationMasterRequest request) throws YarnException,\n      IOException {\n\n    ApplicationAttemptId applicationAttemptId \u003d authorizeRequest();\n\n    AllocateResponseLock lock \u003d responseMap.get(applicationAttemptId);\n    if (lock \u003d\u003d null) {\n      throwApplicationDoesNotExistInCacheException(applicationAttemptId);\n    }\n\n    // Allow only one thread in AM to do finishApp at a time.\n    synchronized (lock) {\n      if (!hasApplicationMasterRegistered(applicationAttemptId)) {\n        String message \u003d\n            \"Application Master is trying to unregister before registering for: \"\n                + applicationAttemptId.getApplicationId();\n        LOG.error(message);\n        RMAuditLogger.logFailure(\n            this.rmContext.getRMApps()\n                .get(applicationAttemptId.getApplicationId()).getUser(),\n            AuditConstants.UNREGISTER_AM, \"\", \"ApplicationMasterService\",\n            message, applicationAttemptId.getApplicationId(),\n            applicationAttemptId);\n        throw new InvalidApplicationMasterRequestException(message);\n      }\n      \n      this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n\n      RMApp rmApp \u003d\n          rmContext.getRMApps().get(applicationAttemptId.getApplicationId());\n\n      if (rmApp.getApplicationSubmissionContext().getUnmanagedAM()) {\n        // No recovery supported yet for unmanaged AM. Send the unregister event\n        // and (falsely) acknowledge state-store write immediately.\n        rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppAttemptUnregistrationEvent(applicationAttemptId, request\n              .getTrackingUrl(), request.getFinalApplicationStatus(), request\n              .getDiagnostics()));\n        return FinishApplicationMasterResponse.newInstance(true);\n      }\n\n      // Not an unmanaged-AM.\n      if (rmApp.isAppSafeToTerminate()) {\n        return FinishApplicationMasterResponse.newInstance(true);\n      } else {\n        // keep sending the unregister event as RM may crash in the meanwhile.\n        rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppAttemptUnregistrationEvent(applicationAttemptId, request\n              .getTrackingUrl(), request.getFinalApplicationStatus(), request\n              .getDiagnostics()));\n        return FinishApplicationMasterResponse.newInstance(false);\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java",
      "extendedDetails": {}
    },
    "bb2e2fee6071233fa3f708c04c58091f4b8b0f99": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1549. Fixed a bug in ResourceManager\u0027s ApplicationMasterService that was causing unamanged AMs to not finish correctly. Contributed by haosdent.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1554886 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/01/14 11:54 AM",
      "commitName": "bb2e2fee6071233fa3f708c04c58091f4b8b0f99",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "16/12/13 6:16 PM",
      "commitNameOld": "b774d7b3de81cda4165a0e86bc2267fda8546cb5",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 16.73,
      "commitsBetweenForRepo": 59,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,42 @@\n   public FinishApplicationMasterResponse finishApplicationMaster(\n       FinishApplicationMasterRequest request) throws YarnException,\n       IOException {\n \n     ApplicationAttemptId applicationAttemptId \u003d authorizeRequest();\n \n     AllocateResponseLock lock \u003d responseMap.get(applicationAttemptId);\n     if (lock \u003d\u003d null) {\n       throwApplicationDoesNotExistInCacheException(applicationAttemptId);\n     }\n \n     // Allow only one thread in AM to do finishApp at a time.\n     synchronized (lock) {\n       \n       this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n \n-      if (rmContext.getRMApps().get(applicationAttemptId.getApplicationId())\n-          .isAppSafeToTerminate()) {\n+      RMApp rmApp \u003d\n+          rmContext.getRMApps().get(applicationAttemptId.getApplicationId());\n+\n+      if (rmApp.getApplicationSubmissionContext().getUnmanagedAM()) {\n+        // No recovery supported yet for unmanaged AM. Send the unregister event\n+        // and (falsely) acknowledge state-store write immediately.\n+        rmContext.getDispatcher().getEventHandler().handle(\n+          new RMAppAttemptUnregistrationEvent(applicationAttemptId, request\n+              .getTrackingUrl(), request.getFinalApplicationStatus(), request\n+              .getDiagnostics()));\n+        return FinishApplicationMasterResponse.newInstance(true);\n+      }\n+\n+      // Not an unmanaged-AM.\n+      if (rmApp.isAppSafeToTerminate()) {\n         return FinishApplicationMasterResponse.newInstance(true);\n       } else {\n         // keep sending the unregister event as RM may crash in the meanwhile.\n         rmContext.getDispatcher().getEventHandler().handle(\n           new RMAppAttemptUnregistrationEvent(applicationAttemptId, request\n               .getTrackingUrl(), request.getFinalApplicationStatus(), request\n               .getDiagnostics()));\n         return FinishApplicationMasterResponse.newInstance(false);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FinishApplicationMasterResponse finishApplicationMaster(\n      FinishApplicationMasterRequest request) throws YarnException,\n      IOException {\n\n    ApplicationAttemptId applicationAttemptId \u003d authorizeRequest();\n\n    AllocateResponseLock lock \u003d responseMap.get(applicationAttemptId);\n    if (lock \u003d\u003d null) {\n      throwApplicationDoesNotExistInCacheException(applicationAttemptId);\n    }\n\n    // Allow only one thread in AM to do finishApp at a time.\n    synchronized (lock) {\n      \n      this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n\n      RMApp rmApp \u003d\n          rmContext.getRMApps().get(applicationAttemptId.getApplicationId());\n\n      if (rmApp.getApplicationSubmissionContext().getUnmanagedAM()) {\n        // No recovery supported yet for unmanaged AM. Send the unregister event\n        // and (falsely) acknowledge state-store write immediately.\n        rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppAttemptUnregistrationEvent(applicationAttemptId, request\n              .getTrackingUrl(), request.getFinalApplicationStatus(), request\n              .getDiagnostics()));\n        return FinishApplicationMasterResponse.newInstance(true);\n      }\n\n      // Not an unmanaged-AM.\n      if (rmApp.isAppSafeToTerminate()) {\n        return FinishApplicationMasterResponse.newInstance(true);\n      } else {\n        // keep sending the unregister event as RM may crash in the meanwhile.\n        rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppAttemptUnregistrationEvent(applicationAttemptId, request\n              .getTrackingUrl(), request.getFinalApplicationStatus(), request\n              .getDiagnostics()));\n        return FinishApplicationMasterResponse.newInstance(false);\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java",
      "extendedDetails": {}
    },
    "b774d7b3de81cda4165a0e86bc2267fda8546cb5": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1446. Changed client API to retry killing application till RM acknowledges so as to account for RM crashes/failover. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1551444 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/12/13 6:16 PM",
      "commitName": "b774d7b3de81cda4165a0e86bc2267fda8546cb5",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "19/11/13 9:06 PM",
      "commitNameOld": "8caae1d5a65bf082eef9bd03a50fd5025c290406",
      "commitAuthorOld": "Bikas Saha",
      "daysBetweenCommits": 26.88,
      "commitsBetweenForRepo": 150,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,29 @@\n   public FinishApplicationMasterResponse finishApplicationMaster(\n       FinishApplicationMasterRequest request) throws YarnException,\n       IOException {\n \n     ApplicationAttemptId applicationAttemptId \u003d authorizeRequest();\n \n     AllocateResponseLock lock \u003d responseMap.get(applicationAttemptId);\n     if (lock \u003d\u003d null) {\n       throwApplicationDoesNotExistInCacheException(applicationAttemptId);\n     }\n \n     // Allow only one thread in AM to do finishApp at a time.\n     synchronized (lock) {\n       \n       this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n \n-      rmContext.getDispatcher().getEventHandler().handle(\n+      if (rmContext.getRMApps().get(applicationAttemptId.getApplicationId())\n+          .isAppSafeToTerminate()) {\n+        return FinishApplicationMasterResponse.newInstance(true);\n+      } else {\n+        // keep sending the unregister event as RM may crash in the meanwhile.\n+        rmContext.getDispatcher().getEventHandler().handle(\n           new RMAppAttemptUnregistrationEvent(applicationAttemptId, request\n               .getTrackingUrl(), request.getFinalApplicationStatus(), request\n               .getDiagnostics()));\n-\n-      if (rmContext.getRMApps().get(applicationAttemptId.getApplicationId())\n-          .isAppSafeToUnregister()) {\n-        return FinishApplicationMasterResponse.newInstance(true);\n-      } else {\n         return FinishApplicationMasterResponse.newInstance(false);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FinishApplicationMasterResponse finishApplicationMaster(\n      FinishApplicationMasterRequest request) throws YarnException,\n      IOException {\n\n    ApplicationAttemptId applicationAttemptId \u003d authorizeRequest();\n\n    AllocateResponseLock lock \u003d responseMap.get(applicationAttemptId);\n    if (lock \u003d\u003d null) {\n      throwApplicationDoesNotExistInCacheException(applicationAttemptId);\n    }\n\n    // Allow only one thread in AM to do finishApp at a time.\n    synchronized (lock) {\n      \n      this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n\n      if (rmContext.getRMApps().get(applicationAttemptId.getApplicationId())\n          .isAppSafeToTerminate()) {\n        return FinishApplicationMasterResponse.newInstance(true);\n      } else {\n        // keep sending the unregister event as RM may crash in the meanwhile.\n        rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppAttemptUnregistrationEvent(applicationAttemptId, request\n              .getTrackingUrl(), request.getFinalApplicationStatus(), request\n              .getDiagnostics()));\n        return FinishApplicationMasterResponse.newInstance(false);\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java",
      "extendedDetails": {}
    },
    "8caae1d5a65bf082eef9bd03a50fd5025c290406": {
      "type": "Ybodychange",
      "commitMessage": "YARN-744. Race condition in ApplicationMasterService.allocate .. It might process same allocate request twice resulting in additional containers getting allocated. (Omkar Vinit Joshi via bikas)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1543707 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/11/13 9:06 PM",
      "commitName": "8caae1d5a65bf082eef9bd03a50fd5025c290406",
      "commitAuthor": "Bikas Saha",
      "commitDateOld": "14/09/13 6:01 PM",
      "commitNameOld": "ec010a29362c6c5572f8681f4e7d0469176345e1",
      "commitAuthorOld": "Bikas Saha",
      "daysBetweenCommits": 66.17,
      "commitsBetweenForRepo": 434,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,32 +1,29 @@\n   public FinishApplicationMasterResponse finishApplicationMaster(\n       FinishApplicationMasterRequest request) throws YarnException,\n       IOException {\n \n     ApplicationAttemptId applicationAttemptId \u003d authorizeRequest();\n \n-    AllocateResponse lastResponse \u003d responseMap.get(applicationAttemptId);\n-    if (lastResponse \u003d\u003d null) {\n-      String message \u003d \"Application doesn\u0027t exist in cache \"\n-          + applicationAttemptId;\n-      LOG.error(message);\n-      throw RPCUtil.getRemoteException(message);\n+    AllocateResponseLock lock \u003d responseMap.get(applicationAttemptId);\n+    if (lock \u003d\u003d null) {\n+      throwApplicationDoesNotExistInCacheException(applicationAttemptId);\n     }\n \n     // Allow only one thread in AM to do finishApp at a time.\n-    synchronized (lastResponse) {\n-\n+    synchronized (lock) {\n+      \n       this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n \n       rmContext.getDispatcher().getEventHandler().handle(\n           new RMAppAttemptUnregistrationEvent(applicationAttemptId, request\n               .getTrackingUrl(), request.getFinalApplicationStatus(), request\n               .getDiagnostics()));\n \n       if (rmContext.getRMApps().get(applicationAttemptId.getApplicationId())\n           .isAppSafeToUnregister()) {\n         return FinishApplicationMasterResponse.newInstance(true);\n       } else {\n         return FinishApplicationMasterResponse.newInstance(false);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FinishApplicationMasterResponse finishApplicationMaster(\n      FinishApplicationMasterRequest request) throws YarnException,\n      IOException {\n\n    ApplicationAttemptId applicationAttemptId \u003d authorizeRequest();\n\n    AllocateResponseLock lock \u003d responseMap.get(applicationAttemptId);\n    if (lock \u003d\u003d null) {\n      throwApplicationDoesNotExistInCacheException(applicationAttemptId);\n    }\n\n    // Allow only one thread in AM to do finishApp at a time.\n    synchronized (lock) {\n      \n      this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n\n      rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppAttemptUnregistrationEvent(applicationAttemptId, request\n              .getTrackingUrl(), request.getFinalApplicationStatus(), request\n              .getDiagnostics()));\n\n      if (rmContext.getRMApps().get(applicationAttemptId.getApplicationId())\n          .isAppSafeToUnregister()) {\n        return FinishApplicationMasterResponse.newInstance(true);\n      } else {\n        return FinishApplicationMasterResponse.newInstance(false);\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java",
      "extendedDetails": {}
    },
    "ec010a29362c6c5572f8681f4e7d0469176345e1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-540. Race condition causing RM to potentially relaunch already unregistered AMs on RM restart (Jian He via bikas)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1523376 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/09/13 6:01 PM",
      "commitName": "ec010a29362c6c5572f8681f4e7d0469176345e1",
      "commitAuthor": "Bikas Saha",
      "commitDateOld": "30/07/13 1:30 PM",
      "commitNameOld": "48264f1994c8b6002d5f1ac2fea46da28798df2d",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 46.19,
      "commitsBetweenForRepo": 251,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,32 @@\n   public FinishApplicationMasterResponse finishApplicationMaster(\n       FinishApplicationMasterRequest request) throws YarnException,\n       IOException {\n \n     ApplicationAttemptId applicationAttemptId \u003d authorizeRequest();\n \n     AllocateResponse lastResponse \u003d responseMap.get(applicationAttemptId);\n     if (lastResponse \u003d\u003d null) {\n       String message \u003d \"Application doesn\u0027t exist in cache \"\n           + applicationAttemptId;\n       LOG.error(message);\n       throw RPCUtil.getRemoteException(message);\n     }\n \n     // Allow only one thread in AM to do finishApp at a time.\n     synchronized (lastResponse) {\n \n       this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n \n       rmContext.getDispatcher().getEventHandler().handle(\n           new RMAppAttemptUnregistrationEvent(applicationAttemptId, request\n               .getTrackingUrl(), request.getFinalApplicationStatus(), request\n               .getDiagnostics()));\n \n-      FinishApplicationMasterResponse response \u003d recordFactory\n-          .newRecordInstance(FinishApplicationMasterResponse.class);\n-      return response;\n+      if (rmContext.getRMApps().get(applicationAttemptId.getApplicationId())\n+          .isAppSafeToUnregister()) {\n+        return FinishApplicationMasterResponse.newInstance(true);\n+      } else {\n+        return FinishApplicationMasterResponse.newInstance(false);\n+      }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FinishApplicationMasterResponse finishApplicationMaster(\n      FinishApplicationMasterRequest request) throws YarnException,\n      IOException {\n\n    ApplicationAttemptId applicationAttemptId \u003d authorizeRequest();\n\n    AllocateResponse lastResponse \u003d responseMap.get(applicationAttemptId);\n    if (lastResponse \u003d\u003d null) {\n      String message \u003d \"Application doesn\u0027t exist in cache \"\n          + applicationAttemptId;\n      LOG.error(message);\n      throw RPCUtil.getRemoteException(message);\n    }\n\n    // Allow only one thread in AM to do finishApp at a time.\n    synchronized (lastResponse) {\n\n      this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n\n      rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppAttemptUnregistrationEvent(applicationAttemptId, request\n              .getTrackingUrl(), request.getFinalApplicationStatus(), request\n              .getDiagnostics()));\n\n      if (rmContext.getRMApps().get(applicationAttemptId.getApplicationId())\n          .isAppSafeToUnregister()) {\n        return FinishApplicationMasterResponse.newInstance(true);\n      } else {\n        return FinishApplicationMasterResponse.newInstance(false);\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java",
      "extendedDetails": {}
    },
    "ac914f79bc80b152e71e7de5497b73f22824f4a7": {
      "type": "Ybodychange",
      "commitMessage": "YARN-918. Remove ApplicationAttemptId from RegisterApplicationMasterRequestProto. Contributed by Vinod K V.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1504735 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/07/13 5:57 PM",
      "commitName": "ac914f79bc80b152e71e7de5497b73f22824f4a7",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "18/07/13 12:03 PM",
      "commitNameOld": "32bc200d54928d39acdc837c2c77b4c443fb46be",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.25,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,31 +1,29 @@\n   public FinishApplicationMasterResponse finishApplicationMaster(\n       FinishApplicationMasterRequest request) throws YarnException,\n       IOException {\n \n-    ApplicationAttemptId applicationAttemptId \u003d request\n-        .getApplicationAttemptId();\n-    authorizeRequest(applicationAttemptId);\n+    ApplicationAttemptId applicationAttemptId \u003d authorizeRequest();\n \n     AllocateResponse lastResponse \u003d responseMap.get(applicationAttemptId);\n     if (lastResponse \u003d\u003d null) {\n       String message \u003d \"Application doesn\u0027t exist in cache \"\n           + applicationAttemptId;\n       LOG.error(message);\n       throw RPCUtil.getRemoteException(message);\n     }\n \n     // Allow only one thread in AM to do finishApp at a time.\n     synchronized (lastResponse) {\n \n       this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n \n       rmContext.getDispatcher().getEventHandler().handle(\n           new RMAppAttemptUnregistrationEvent(applicationAttemptId, request\n               .getTrackingUrl(), request.getFinalApplicationStatus(), request\n               .getDiagnostics()));\n \n       FinishApplicationMasterResponse response \u003d recordFactory\n           .newRecordInstance(FinishApplicationMasterResponse.class);\n       return response;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FinishApplicationMasterResponse finishApplicationMaster(\n      FinishApplicationMasterRequest request) throws YarnException,\n      IOException {\n\n    ApplicationAttemptId applicationAttemptId \u003d authorizeRequest();\n\n    AllocateResponse lastResponse \u003d responseMap.get(applicationAttemptId);\n    if (lastResponse \u003d\u003d null) {\n      String message \u003d \"Application doesn\u0027t exist in cache \"\n          + applicationAttemptId;\n      LOG.error(message);\n      throw RPCUtil.getRemoteException(message);\n    }\n\n    // Allow only one thread in AM to do finishApp at a time.\n    synchronized (lastResponse) {\n\n      this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n\n      rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppAttemptUnregistrationEvent(applicationAttemptId, request\n              .getTrackingUrl(), request.getFinalApplicationStatus(), request\n              .getDiagnostics()));\n\n      FinishApplicationMasterResponse response \u003d recordFactory\n          .newRecordInstance(FinishApplicationMasterResponse.class);\n      return response;\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java",
      "extendedDetails": {}
    },
    "a83fb61ac07c0468cbc7a38526e92683883dd932": {
      "type": "Yexceptionschange",
      "commitMessage": "YARN-635. Renamed YarnRemoteException to YarnException. Contributed by Siddharth Seth.\nMAPREDUCE-5301. Updated MR code to work with YARN-635 changes of renaming YarnRemoteException to YarnException. Contributed by Siddharth Seth\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1489283 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/06/13 9:05 PM",
      "commitName": "a83fb61ac07c0468cbc7a38526e92683883dd932",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "03/06/13 5:34 PM",
      "commitNameOld": "d33534c4fb35cb82ff8d56abeeb63a949e72a031",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 0.15,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,31 +1,31 @@\n   public FinishApplicationMasterResponse finishApplicationMaster(\n-      FinishApplicationMasterRequest request) throws YarnRemoteException,\n+      FinishApplicationMasterRequest request) throws YarnException,\n       IOException {\n \n     ApplicationAttemptId applicationAttemptId \u003d request\n         .getApplicationAttemptId();\n     authorizeRequest(applicationAttemptId);\n \n     AllocateResponse lastResponse \u003d responseMap.get(applicationAttemptId);\n     if (lastResponse \u003d\u003d null) {\n       String message \u003d \"Application doesn\u0027t exist in cache \"\n           + applicationAttemptId;\n       LOG.error(message);\n       throw RPCUtil.getRemoteException(message);\n     }\n \n     // Allow only one thread in AM to do finishApp at a time.\n     synchronized (lastResponse) {\n \n       this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n \n       rmContext.getDispatcher().getEventHandler().handle(\n           new RMAppAttemptUnregistrationEvent(applicationAttemptId, request\n               .getTrackingUrl(), request.getFinalApplicationStatus(), request\n               .getDiagnostics()));\n \n       FinishApplicationMasterResponse response \u003d recordFactory\n           .newRecordInstance(FinishApplicationMasterResponse.class);\n       return response;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FinishApplicationMasterResponse finishApplicationMaster(\n      FinishApplicationMasterRequest request) throws YarnException,\n      IOException {\n\n    ApplicationAttemptId applicationAttemptId \u003d request\n        .getApplicationAttemptId();\n    authorizeRequest(applicationAttemptId);\n\n    AllocateResponse lastResponse \u003d responseMap.get(applicationAttemptId);\n    if (lastResponse \u003d\u003d null) {\n      String message \u003d \"Application doesn\u0027t exist in cache \"\n          + applicationAttemptId;\n      LOG.error(message);\n      throw RPCUtil.getRemoteException(message);\n    }\n\n    // Allow only one thread in AM to do finishApp at a time.\n    synchronized (lastResponse) {\n\n      this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n\n      rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppAttemptUnregistrationEvent(applicationAttemptId, request\n              .getTrackingUrl(), request.getFinalApplicationStatus(), request\n              .getDiagnostics()));\n\n      FinishApplicationMasterResponse response \u003d recordFactory\n          .newRecordInstance(FinishApplicationMasterResponse.class);\n      return response;\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java",
      "extendedDetails": {
        "oldValue": "[YarnRemoteException, IOException]",
        "newValue": "[YarnException, IOException]"
      }
    },
    "9c4f86879cad6d6e19255d4ae8f28b61328bd10b": {
      "type": "Yexceptionschange",
      "commitMessage": "YARN-630. Changed AMRMProtocol api to throw IOException and YarnRemoteException. Contributed by Xuan Gong.\nMAPREDUCE-5226. Handling YarnRemoteException separately from IOException in MR App\u0027s use of AMRMProtocol after YARN-630. Contributed by Xuan Gong.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1480529 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/05/13 10:32 PM",
      "commitName": "9c4f86879cad6d6e19255d4ae8f28b61328bd10b",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "05/04/13 10:45 AM",
      "commitNameOld": "bc6777dd5bdcbaef09897b506bc6511ae456033d",
      "commitAuthorOld": "Bikas Saha",
      "daysBetweenCommits": 33.49,
      "commitsBetweenForRepo": 178,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,30 +1,31 @@\n   public FinishApplicationMasterResponse finishApplicationMaster(\n-      FinishApplicationMasterRequest request) throws YarnRemoteException {\n+      FinishApplicationMasterRequest request) throws YarnRemoteException,\n+      IOException {\n \n     ApplicationAttemptId applicationAttemptId \u003d request\n         .getApplicationAttemptId();\n     authorizeRequest(applicationAttemptId);\n \n     AllocateResponse lastResponse \u003d responseMap.get(applicationAttemptId);\n     if (lastResponse \u003d\u003d null) {\n       String message \u003d \"Application doesn\u0027t exist in cache \"\n           + applicationAttemptId;\n       LOG.error(message);\n       throw RPCUtil.getRemoteException(message);\n     }\n \n     // Allow only one thread in AM to do finishApp at a time.\n     synchronized (lastResponse) {\n \n       this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n \n       rmContext.getDispatcher().getEventHandler().handle(\n           new RMAppAttemptUnregistrationEvent(applicationAttemptId, request\n               .getTrackingUrl(), request.getFinalApplicationStatus(), request\n               .getDiagnostics()));\n \n       FinishApplicationMasterResponse response \u003d recordFactory\n           .newRecordInstance(FinishApplicationMasterResponse.class);\n       return response;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FinishApplicationMasterResponse finishApplicationMaster(\n      FinishApplicationMasterRequest request) throws YarnRemoteException,\n      IOException {\n\n    ApplicationAttemptId applicationAttemptId \u003d request\n        .getApplicationAttemptId();\n    authorizeRequest(applicationAttemptId);\n\n    AllocateResponse lastResponse \u003d responseMap.get(applicationAttemptId);\n    if (lastResponse \u003d\u003d null) {\n      String message \u003d \"Application doesn\u0027t exist in cache \"\n          + applicationAttemptId;\n      LOG.error(message);\n      throw RPCUtil.getRemoteException(message);\n    }\n\n    // Allow only one thread in AM to do finishApp at a time.\n    synchronized (lastResponse) {\n\n      this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n\n      rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppAttemptUnregistrationEvent(applicationAttemptId, request\n              .getTrackingUrl(), request.getFinalApplicationStatus(), request\n              .getDiagnostics()));\n\n      FinishApplicationMasterResponse response \u003d recordFactory\n          .newRecordInstance(FinishApplicationMasterResponse.class);\n      return response;\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java",
      "extendedDetails": {
        "oldValue": "[YarnRemoteException]",
        "newValue": "[YarnRemoteException, IOException]"
      }
    },
    "1bd345d6e3855ab330963efd32e0fac102e61d1a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-396. Rationalize AllocateResponse in RM Scheduler API. Contributed by Zhijie Shen.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1459040 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "20/03/13 1:44 PM",
      "commitName": "1bd345d6e3855ab330963efd32e0fac102e61d1a",
      "commitAuthor": "Hitesh Shah",
      "commitDateOld": "08/01/13 9:08 PM",
      "commitNameOld": "453926397182078c65a4428eb5de5a90d6af6448",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 70.65,
      "commitsBetweenForRepo": 330,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,30 +1,30 @@\n   public FinishApplicationMasterResponse finishApplicationMaster(\n       FinishApplicationMasterRequest request) throws YarnRemoteException {\n \n     ApplicationAttemptId applicationAttemptId \u003d request\n         .getApplicationAttemptId();\n     authorizeRequest(applicationAttemptId);\n \n-    AMResponse lastResponse \u003d responseMap.get(applicationAttemptId);\n+    AllocateResponse lastResponse \u003d responseMap.get(applicationAttemptId);\n     if (lastResponse \u003d\u003d null) {\n       String message \u003d \"Application doesn\u0027t exist in cache \"\n           + applicationAttemptId;\n       LOG.error(message);\n       throw RPCUtil.getRemoteException(message);\n     }\n \n     // Allow only one thread in AM to do finishApp at a time.\n     synchronized (lastResponse) {\n \n       this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n \n       rmContext.getDispatcher().getEventHandler().handle(\n           new RMAppAttemptUnregistrationEvent(applicationAttemptId, request\n               .getTrackingUrl(), request.getFinalApplicationStatus(), request\n               .getDiagnostics()));\n \n       FinishApplicationMasterResponse response \u003d recordFactory\n           .newRecordInstance(FinishApplicationMasterResponse.class);\n       return response;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FinishApplicationMasterResponse finishApplicationMaster(\n      FinishApplicationMasterRequest request) throws YarnRemoteException {\n\n    ApplicationAttemptId applicationAttemptId \u003d request\n        .getApplicationAttemptId();\n    authorizeRequest(applicationAttemptId);\n\n    AllocateResponse lastResponse \u003d responseMap.get(applicationAttemptId);\n    if (lastResponse \u003d\u003d null) {\n      String message \u003d \"Application doesn\u0027t exist in cache \"\n          + applicationAttemptId;\n      LOG.error(message);\n      throw RPCUtil.getRemoteException(message);\n    }\n\n    // Allow only one thread in AM to do finishApp at a time.\n    synchronized (lastResponse) {\n\n      this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n\n      rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppAttemptUnregistrationEvent(applicationAttemptId, request\n              .getTrackingUrl(), request.getFinalApplicationStatus(), request\n              .getDiagnostics()));\n\n      FinishApplicationMasterResponse response \u003d recordFactory\n          .newRecordInstance(FinishApplicationMasterResponse.class);\n      return response;\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java",
      "extendedDetails": {}
    },
    "e1fdf62123625e4ba399af02f8aad500637d29d1": {
      "type": "Yfilerename",
      "commitMessage": "YARN-1. Promote YARN to be a sub-project of Apache Hadoop.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1370666 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/08/12 10:22 PM",
      "commitName": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "07/08/12 7:53 PM",
      "commitNameOld": "34554d1e11ee1d5b564d7d9ed3e6d55931d72749",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public FinishApplicationMasterResponse finishApplicationMaster(\n      FinishApplicationMasterRequest request) throws YarnRemoteException {\n\n    ApplicationAttemptId applicationAttemptId \u003d request\n        .getApplicationAttemptId();\n    authorizeRequest(applicationAttemptId);\n\n    AMResponse lastResponse \u003d responseMap.get(applicationAttemptId);\n    if (lastResponse \u003d\u003d null) {\n      String message \u003d \"Application doesn\u0027t exist in cache \"\n          + applicationAttemptId;\n      LOG.error(message);\n      throw RPCUtil.getRemoteException(message);\n    }\n\n    // Allow only one thread in AM to do finishApp at a time.\n    synchronized (lastResponse) {\n\n      this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n\n      rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppAttemptUnregistrationEvent(applicationAttemptId, request\n              .getTrackingUrl(), request.getFinalApplicationStatus(), request\n              .getDiagnostics()));\n\n      FinishApplicationMasterResponse response \u003d recordFactory\n          .newRecordInstance(FinishApplicationMasterResponse.class);\n      return response;\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java"
      }
    },
    "db8ac0ec3cbec046f9cf32644c16fd2a51dd85a2": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3257. Added authorization checks for the protocol between ResourceManager and ApplicatoinMaster. Contributed by Vinod K V. \n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1189630 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "26/10/11 11:24 PM",
      "commitName": "db8ac0ec3cbec046f9cf32644c16fd2a51dd85a2",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/10/11 11:07 PM",
      "commitNameOld": "d19cfe01642f9582e1fe5d567beb480399c37a01",
      "commitAuthorOld": "Mahadev Konar",
      "daysBetweenCommits": 2.01,
      "commitsBetweenForRepo": 22,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,28 +1,30 @@\n   public FinishApplicationMasterResponse finishApplicationMaster(\n       FinishApplicationMasterRequest request) throws YarnRemoteException {\n \n     ApplicationAttemptId applicationAttemptId \u003d request\n         .getApplicationAttemptId();\n+    authorizeRequest(applicationAttemptId);\n+\n     AMResponse lastResponse \u003d responseMap.get(applicationAttemptId);\n     if (lastResponse \u003d\u003d null) {\n       String message \u003d \"Application doesn\u0027t exist in cache \"\n           + applicationAttemptId;\n       LOG.error(message);\n       throw RPCUtil.getRemoteException(message);\n     }\n \n     // Allow only one thread in AM to do finishApp at a time.\n     synchronized (lastResponse) {\n \n       this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n \n       rmContext.getDispatcher().getEventHandler().handle(\n           new RMAppAttemptUnregistrationEvent(applicationAttemptId, request\n               .getTrackingUrl(), request.getFinalApplicationStatus(), request\n               .getDiagnostics()));\n \n       FinishApplicationMasterResponse response \u003d recordFactory\n           .newRecordInstance(FinishApplicationMasterResponse.class);\n       return response;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FinishApplicationMasterResponse finishApplicationMaster(\n      FinishApplicationMasterRequest request) throws YarnRemoteException {\n\n    ApplicationAttemptId applicationAttemptId \u003d request\n        .getApplicationAttemptId();\n    authorizeRequest(applicationAttemptId);\n\n    AMResponse lastResponse \u003d responseMap.get(applicationAttemptId);\n    if (lastResponse \u003d\u003d null) {\n      String message \u003d \"Application doesn\u0027t exist in cache \"\n          + applicationAttemptId;\n      LOG.error(message);\n      throw RPCUtil.getRemoteException(message);\n    }\n\n    // Allow only one thread in AM to do finishApp at a time.\n    synchronized (lastResponse) {\n\n      this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n\n      rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppAttemptUnregistrationEvent(applicationAttemptId, request\n              .getTrackingUrl(), request.getFinalApplicationStatus(), request\n              .getDiagnostics()));\n\n      FinishApplicationMasterResponse response \u003d recordFactory\n          .newRecordInstance(FinishApplicationMasterResponse.class);\n      return response;\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java",
      "extendedDetails": {}
    },
    "063e33a862f99ce93b8399924c35d39ccd880f01": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3098. Fixed RM and MR AM to report YarnApplicationState and application\u0027s FinalStatus separately. Contributed by Hitesh Shah.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1177633 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/09/11 5:46 AM",
      "commitName": "063e33a862f99ce93b8399924c35d39ccd880f01",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "11/09/11 10:26 AM",
      "commitNameOld": "817ead65b99f465fc2dfa18072cf23cadf5f05d0",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 18.81,
      "commitsBetweenForRepo": 132,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,28 +1,28 @@\n   public FinishApplicationMasterResponse finishApplicationMaster(\n       FinishApplicationMasterRequest request) throws YarnRemoteException {\n \n     ApplicationAttemptId applicationAttemptId \u003d request\n         .getApplicationAttemptId();\n     AMResponse lastResponse \u003d responseMap.get(applicationAttemptId);\n     if (lastResponse \u003d\u003d null) {\n       String message \u003d \"Application doesn\u0027t exist in cache \"\n           + applicationAttemptId;\n       LOG.error(message);\n       throw RPCUtil.getRemoteException(message);\n     }\n \n     // Allow only one thread in AM to do finishApp at a time.\n     synchronized (lastResponse) {\n \n       this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n \n       rmContext.getDispatcher().getEventHandler().handle(\n           new RMAppAttemptUnregistrationEvent(applicationAttemptId, request\n-              .getTrackingUrl(), request.getFinalState(), request\n+              .getTrackingUrl(), request.getFinalApplicationStatus(), request\n               .getDiagnostics()));\n \n       FinishApplicationMasterResponse response \u003d recordFactory\n           .newRecordInstance(FinishApplicationMasterResponse.class);\n       return response;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FinishApplicationMasterResponse finishApplicationMaster(\n      FinishApplicationMasterRequest request) throws YarnRemoteException {\n\n    ApplicationAttemptId applicationAttemptId \u003d request\n        .getApplicationAttemptId();\n    AMResponse lastResponse \u003d responseMap.get(applicationAttemptId);\n    if (lastResponse \u003d\u003d null) {\n      String message \u003d \"Application doesn\u0027t exist in cache \"\n          + applicationAttemptId;\n      LOG.error(message);\n      throw RPCUtil.getRemoteException(message);\n    }\n\n    // Allow only one thread in AM to do finishApp at a time.\n    synchronized (lastResponse) {\n\n      this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n\n      rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppAttemptUnregistrationEvent(applicationAttemptId, request\n              .getTrackingUrl(), request.getFinalApplicationStatus(), request\n              .getDiagnostics()));\n\n      FinishApplicationMasterResponse response \u003d recordFactory\n          .newRecordInstance(FinishApplicationMasterResponse.class);\n      return response;\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public FinishApplicationMasterResponse finishApplicationMaster(\n      FinishApplicationMasterRequest request) throws YarnRemoteException {\n\n    ApplicationAttemptId applicationAttemptId \u003d request\n        .getApplicationAttemptId();\n    AMResponse lastResponse \u003d responseMap.get(applicationAttemptId);\n    if (lastResponse \u003d\u003d null) {\n      String message \u003d \"Application doesn\u0027t exist in cache \"\n          + applicationAttemptId;\n      LOG.error(message);\n      throw RPCUtil.getRemoteException(message);\n    }\n\n    // Allow only one thread in AM to do finishApp at a time.\n    synchronized (lastResponse) {\n\n      this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n\n      rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppAttemptUnregistrationEvent(applicationAttemptId, request\n              .getTrackingUrl(), request.getFinalState(), request\n              .getDiagnostics()));\n\n      FinishApplicationMasterResponse response \u003d recordFactory\n          .newRecordInstance(FinishApplicationMasterResponse.class);\n      return response;\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java",
        "newPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java"
      }
    },
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-279. MapReduce 2.0. Merging MR-279 branch into trunk. Contributed by Arun C Murthy, Christopher Douglas, Devaraj Das, Greg Roelofs, Jeffrey Naisbitt, Josh Wills, Jonathan Eagles, Krishna Ramachandran, Luke Lu, Mahadev Konar, Robert Evans, Sharad Agarwal, Siddharth Seth, Thomas Graves, and Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159166 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/08/11 4:07 AM",
      "commitName": "dbecbe5dfe50f834fc3b8401709079e9470cc517",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,28 @@\n+  public FinishApplicationMasterResponse finishApplicationMaster(\n+      FinishApplicationMasterRequest request) throws YarnRemoteException {\n+\n+    ApplicationAttemptId applicationAttemptId \u003d request\n+        .getApplicationAttemptId();\n+    AMResponse lastResponse \u003d responseMap.get(applicationAttemptId);\n+    if (lastResponse \u003d\u003d null) {\n+      String message \u003d \"Application doesn\u0027t exist in cache \"\n+          + applicationAttemptId;\n+      LOG.error(message);\n+      throw RPCUtil.getRemoteException(message);\n+    }\n+\n+    // Allow only one thread in AM to do finishApp at a time.\n+    synchronized (lastResponse) {\n+\n+      this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n+\n+      rmContext.getDispatcher().getEventHandler().handle(\n+          new RMAppAttemptUnregistrationEvent(applicationAttemptId, request\n+              .getTrackingUrl(), request.getFinalState(), request\n+              .getDiagnostics()));\n+\n+      FinishApplicationMasterResponse response \u003d recordFactory\n+          .newRecordInstance(FinishApplicationMasterResponse.class);\n+      return response;\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public FinishApplicationMasterResponse finishApplicationMaster(\n      FinishApplicationMasterRequest request) throws YarnRemoteException {\n\n    ApplicationAttemptId applicationAttemptId \u003d request\n        .getApplicationAttemptId();\n    AMResponse lastResponse \u003d responseMap.get(applicationAttemptId);\n    if (lastResponse \u003d\u003d null) {\n      String message \u003d \"Application doesn\u0027t exist in cache \"\n          + applicationAttemptId;\n      LOG.error(message);\n      throw RPCUtil.getRemoteException(message);\n    }\n\n    // Allow only one thread in AM to do finishApp at a time.\n    synchronized (lastResponse) {\n\n      this.amLivelinessMonitor.receivedPing(applicationAttemptId);\n\n      rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppAttemptUnregistrationEvent(applicationAttemptId, request\n              .getTrackingUrl(), request.getFinalState(), request\n              .getDiagnostics()));\n\n      FinishApplicationMasterResponse response \u003d recordFactory\n          .newRecordInstance(FinishApplicationMasterResponse.class);\n      return response;\n    }\n  }",
      "path": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ApplicationMasterService.java"
    }
  }
}