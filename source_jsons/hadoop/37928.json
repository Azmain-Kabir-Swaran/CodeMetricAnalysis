{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ResourceTrackerService.java",
  "functionName": "registerNodeManager",
  "functionId": "registerNodeManager___request-RegisterNodeManagerRequest",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
  "functionStartLine": 328,
  "functionEndLine": 545,
  "numCommitsSeen": 115,
  "timeTaken": 17018,
  "changeHistory": [
    "2064ca015d1584263aac0cc20c60b925a3aff612",
    "f659485ee83f3f34e3717631983adfc8fa1e53dc",
    "9bb2801e8ce1e6298241944a65f593f555ae10e2",
    "4bf622043f034835d65ff2a4785b9b06d0ef1fd2",
    "e718ac597f2225cb4946e1ac4b3986c336645643",
    "4d53ef7eefb14661d824924e503a910de1ae997f",
    "ff8378eb1b960c72d18a984c7e5d145b407ca11a",
    "759114b0063907d4c07ea6ee261e861bf5cc3a9a",
    "3f93ac0733058238a2c8f23960c986c71dca0e02",
    "30ee57ceb1e80c30ea3adfe7736d4d4c7d5c8386",
    "42f90ab885d9693fcc1e52f9637f7de4111110ae",
    "fa3bc3405dc2f8497faab45ba5c4de2caf4c29bc",
    "2a5da97f81d69b481e4d1324a47e64bb55b9407c",
    "1cbcd4a491e6a57d466c2897335614dc6770b475",
    "524bc3c33aff301c1a8d60ed8e6a3b240e305045",
    "db9304788187c700647c4d84caeb3b5ad6d868d8",
    "feaf0349949e831ce3f25814c1bbff52f17bfe8f",
    "b37da52a1c4fb3da2bd21bfadc5ec61c5f953a59",
    "db1b674b50ddecf2774f4092d677c412722bdcb1",
    "2a945d24f7de1a7ae6e7bd6636188ce3b55c7f52",
    "a64dd3d24bfcb9af21eb63869924f6482b147fd3",
    "0a641496c706fc175e7bf66d69ebf71c7d078e84",
    "5c14bc426b4be381383018ebc2236be83eef15cd",
    "b8f151231ba37247b9daa23ecce1211fdca0e49f",
    "95897ca14b7abd7fe047fdcf150473a8a2cbb024",
    "424fd9494f144c035fdef8c533be51e2027ad8d9",
    "23c325ad47e305989b7f2cf172bd709f73dd26d1",
    "f67218809c50b194e463af6e6196db298353c8c1",
    "477ed62b3fe8db4b07d99479f56a2b997933cb01",
    "cfa783141fa69c2cf154d1d9e5393353d14ce5e1",
    "6990355e577ad19371cb656c250fb665ed14062f",
    "7b687dda098c94b55c9848827cfc2d6326b6f9b6",
    "5a15c392a1a18c5720dbe630bc07e58268c8e6a7",
    "ead3dcc3dea0d5b6d3248c1e1a6300f0714a8456",
    "769a0bd8314cd7317c083a9b74abf47242acb58c",
    "f0eb4bc342370ec87d1f2665ffaf48ff4b3fbacb",
    "a83fb61ac07c0468cbc7a38526e92683883dd932",
    "ca8024673178fa1c80224b390dfba932921693d9",
    "68148989bfb8b893529eb9920d849bce0dd575ec",
    "a35c7fd80bcb19a7c6a7b9234d782adaf2d51529",
    "d9ce42479e5b2cbbf54dd2861680f9d37bdf31f3",
    "fbb55784d93e1a819daf55d936e864d344579cbf",
    "66e90b205a079c7056bd85e6c5e3dbb2a96e7461",
    "453926397182078c65a4428eb5de5a90d6af6448",
    "45a8e8c5a46535287de97fd6609c0743eef888ee",
    "ffd2e01604be814fa3db1dded7cd7cff26a79b1e",
    "e1fdf62123625e4ba399af02f8aad500637d29d1",
    "c0572656ced07a885f848c1134edd7b1c291d246",
    "cbdb07f4ca358b9507296868a913977ad82ed716",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517"
  ],
  "changeHistoryShort": {
    "2064ca015d1584263aac0cc20c60b925a3aff612": "Ybodychange",
    "f659485ee83f3f34e3717631983adfc8fa1e53dc": "Ybodychange",
    "9bb2801e8ce1e6298241944a65f593f555ae10e2": "Ybodychange",
    "4bf622043f034835d65ff2a4785b9b06d0ef1fd2": "Ybodychange",
    "e718ac597f2225cb4946e1ac4b3986c336645643": "Ybodychange",
    "4d53ef7eefb14661d824924e503a910de1ae997f": "Ybodychange",
    "ff8378eb1b960c72d18a984c7e5d145b407ca11a": "Ybodychange",
    "759114b0063907d4c07ea6ee261e861bf5cc3a9a": "Ybodychange",
    "3f93ac0733058238a2c8f23960c986c71dca0e02": "Ybodychange",
    "30ee57ceb1e80c30ea3adfe7736d4d4c7d5c8386": "Ybodychange",
    "42f90ab885d9693fcc1e52f9637f7de4111110ae": "Ybodychange",
    "fa3bc3405dc2f8497faab45ba5c4de2caf4c29bc": "Ybodychange",
    "2a5da97f81d69b481e4d1324a47e64bb55b9407c": "Ybodychange",
    "1cbcd4a491e6a57d466c2897335614dc6770b475": "Ybodychange",
    "524bc3c33aff301c1a8d60ed8e6a3b240e305045": "Ybodychange",
    "db9304788187c700647c4d84caeb3b5ad6d868d8": "Ybodychange",
    "feaf0349949e831ce3f25814c1bbff52f17bfe8f": "Ybodychange",
    "b37da52a1c4fb3da2bd21bfadc5ec61c5f953a59": "Ybodychange",
    "db1b674b50ddecf2774f4092d677c412722bdcb1": "Ybodychange",
    "2a945d24f7de1a7ae6e7bd6636188ce3b55c7f52": "Ybodychange",
    "a64dd3d24bfcb9af21eb63869924f6482b147fd3": "Ybodychange",
    "0a641496c706fc175e7bf66d69ebf71c7d078e84": "Ybodychange",
    "5c14bc426b4be381383018ebc2236be83eef15cd": "Ybodychange",
    "b8f151231ba37247b9daa23ecce1211fdca0e49f": "Ybodychange",
    "95897ca14b7abd7fe047fdcf150473a8a2cbb024": "Ybodychange",
    "424fd9494f144c035fdef8c533be51e2027ad8d9": "Ybodychange",
    "23c325ad47e305989b7f2cf172bd709f73dd26d1": "Ybodychange",
    "f67218809c50b194e463af6e6196db298353c8c1": "Ybodychange",
    "477ed62b3fe8db4b07d99479f56a2b997933cb01": "Ybodychange",
    "cfa783141fa69c2cf154d1d9e5393353d14ce5e1": "Ybodychange",
    "6990355e577ad19371cb656c250fb665ed14062f": "Ybodychange",
    "7b687dda098c94b55c9848827cfc2d6326b6f9b6": "Ybodychange",
    "5a15c392a1a18c5720dbe630bc07e58268c8e6a7": "Ybodychange",
    "ead3dcc3dea0d5b6d3248c1e1a6300f0714a8456": "Ybodychange",
    "769a0bd8314cd7317c083a9b74abf47242acb58c": "Ybodychange",
    "f0eb4bc342370ec87d1f2665ffaf48ff4b3fbacb": "Ybodychange",
    "a83fb61ac07c0468cbc7a38526e92683883dd932": "Yexceptionschange",
    "ca8024673178fa1c80224b390dfba932921693d9": "Ybodychange",
    "68148989bfb8b893529eb9920d849bce0dd575ec": "Ybodychange",
    "a35c7fd80bcb19a7c6a7b9234d782adaf2d51529": "Yexceptionschange",
    "d9ce42479e5b2cbbf54dd2861680f9d37bdf31f3": "Ybodychange",
    "fbb55784d93e1a819daf55d936e864d344579cbf": "Ybodychange",
    "66e90b205a079c7056bd85e6c5e3dbb2a96e7461": "Ybodychange",
    "453926397182078c65a4428eb5de5a90d6af6448": "Ybodychange",
    "45a8e8c5a46535287de97fd6609c0743eef888ee": "Ybodychange",
    "ffd2e01604be814fa3db1dded7cd7cff26a79b1e": "Ybodychange",
    "e1fdf62123625e4ba399af02f8aad500637d29d1": "Yfilerename",
    "c0572656ced07a885f848c1134edd7b1c291d246": "Ybodychange",
    "cbdb07f4ca358b9507296868a913977ad82ed716": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": "Yintroduced"
  },
  "changeHistoryDetails": {
    "2064ca015d1584263aac0cc20c60b925a3aff612": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9349.  Changed logging to use slf4j api.\n            Contributed by Prabhu Joseph\n",
      "commitDate": "15/03/19 4:20 PM",
      "commitName": "2064ca015d1584263aac0cc20c60b925a3aff612",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "04/03/19 9:10 PM",
      "commitNameOld": "e40e2d6ad5cbe782c3a067229270738b501ed27e",
      "commitAuthorOld": "Prabhu Joseph",
      "daysBetweenCommits": 10.76,
      "commitsBetweenForRepo": 108,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,220 +1,218 @@\n   public RegisterNodeManagerResponse registerNodeManager(\n       RegisterNodeManagerRequest request) throws YarnException,\n       IOException {\n     NodeId nodeId \u003d request.getNodeId();\n     String host \u003d nodeId.getHost();\n     int cmPort \u003d nodeId.getPort();\n     int httpPort \u003d request.getHttpPort();\n     Resource capability \u003d request.getResource();\n     String nodeManagerVersion \u003d request.getNMVersion();\n     Resource physicalResource \u003d request.getPhysicalResource();\n \n     RegisterNodeManagerResponse response \u003d recordFactory\n         .newRecordInstance(RegisterNodeManagerResponse.class);\n \n     if (!minimumNodeManagerVersion.equals(\"NONE\")) {\n       if (minimumNodeManagerVersion.equals(\"EqualToRM\")) {\n         minimumNodeManagerVersion \u003d YarnVersionInfo.getVersion();\n       }\n \n       if ((nodeManagerVersion \u003d\u003d null) ||\n           (VersionUtil.compareVersions(nodeManagerVersion,minimumNodeManagerVersion)) \u003c 0) {\n         String message \u003d\n             \"Disallowed NodeManager Version \" + nodeManagerVersion\n                 + \", is less than the minimum version \"\n                 + minimumNodeManagerVersion + \" sending SHUTDOWN signal to \"\n                 + \"NodeManager.\";\n         LOG.info(message);\n         response.setDiagnosticsMessage(message);\n         response.setNodeAction(NodeAction.SHUTDOWN);\n         return response;\n       }\n     }\n \n     if (checkIpHostnameInRegistration) {\n       InetSocketAddress nmAddress \u003d\n           NetUtils.createSocketAddrForHost(host, cmPort);\n       InetAddress inetAddress \u003d Server.getRemoteIp();\n       if (inetAddress !\u003d null \u0026\u0026 nmAddress.isUnresolved()) {\n         // Reject registration of unresolved nm to prevent resourcemanager\n         // getting stuck at allocations.\n         final String message \u003d\n             \"hostname cannot be resolved (ip\u003d\" + inetAddress.getHostAddress()\n                 + \", hostname\u003d\" + host + \")\";\n         LOG.warn(\"Unresolved nodemanager registration: \" + message);\n         response.setDiagnosticsMessage(message);\n         response.setNodeAction(NodeAction.SHUTDOWN);\n         return response;\n       }\n     }\n \n     // Check if this node is a \u0027valid\u0027 node\n     if (!this.nodesListManager.isValidNode(host) \u0026\u0026\n         !isNodeInDecommissioning(nodeId)) {\n       String message \u003d\n           \"Disallowed NodeManager from  \" + host\n               + \", Sending SHUTDOWN signal to the NodeManager.\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     // check if node\u0027s capacity is load from dynamic-resources.xml\n     String nid \u003d nodeId.toString();\n \n     Resource dynamicLoadCapability \u003d loadNodeResourceFromDRConfiguration(nid);\n     if (dynamicLoadCapability !\u003d null) {\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"Resource for node: \" + nid + \" is adjusted from: \" +\n-            capability + \" to: \" + dynamicLoadCapability +\n-            \" due to settings in dynamic-resources.xml.\");\n-      }\n+      LOG.debug(\"Resource for node: {} is adjusted from: {} to: {} due to\"\n+          + \" settings in dynamic-resources.xml.\", nid, capability,\n+          dynamicLoadCapability);\n       capability \u003d dynamicLoadCapability;\n       // sync back with new resource.\n       response.setResource(capability);\n     }\n \n     // Check if this node has minimum allocations\n     if (capability.getMemorySize() \u003c minAllocMb\n         || capability.getVirtualCores() \u003c minAllocVcores) {\n       String message \u003d \"NodeManager from  \" + host\n           + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n           + \" signal to the NodeManager. Node capabilities are \" + capability\n           + \"; minimums are \" + minAllocMb + \"mb and \" + minAllocVcores\n           + \" vcores\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     response.setContainerTokenMasterKey(containerTokenSecretManager\n         .getCurrentKey());\n     response.setNMTokenMasterKey(nmTokenSecretManager\n         .getCurrentKey());\n \n     RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n         resolve(host), capability, nodeManagerVersion, physicalResource);\n \n     RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n     if (oldNode \u003d\u003d null) {\n       RMNodeStartedEvent startEvent \u003d new RMNodeStartedEvent(nodeId,\n           request.getNMContainerStatuses(),\n           request.getRunningApplications());\n       if (request.getLogAggregationReportsForApps() !\u003d null\n           \u0026\u0026 !request.getLogAggregationReportsForApps().isEmpty()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Found the number of previous cached log aggregation \"\n               + \"status from nodemanager:\" + nodeId + \" is :\"\n               + request.getLogAggregationReportsForApps().size());\n         }\n         startEvent.setLogAggregationReportsForApps(request\n             .getLogAggregationReportsForApps());\n       }\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           startEvent);\n     } else {\n       LOG.info(\"Reconnect from the node at: \" + host);\n       this.nmLivelinessMonitor.unregister(nodeId);\n \n       if (CollectionUtils.isEmpty(request.getRunningApplications())\n           \u0026\u0026 rmNode.getState() !\u003d NodeState.DECOMMISSIONING\n           \u0026\u0026 rmNode.getHttpPort() !\u003d oldNode.getHttpPort()) {\n         // Reconnected node differs, so replace old node and start new node\n         switch (rmNode.getState()) {\n         case RUNNING:\n           ClusterMetrics.getMetrics().decrNumActiveNodes();\n           break;\n         case UNHEALTHY:\n           ClusterMetrics.getMetrics().decrNumUnhealthyNMs();\n           break;\n         default:\n           LOG.debug(\"Unexpected Rmnode state\");\n         }\n         this.rmContext.getDispatcher().getEventHandler()\n             .handle(new NodeRemovedSchedulerEvent(rmNode));\n \n         this.rmContext.getRMNodes().put(nodeId, rmNode);\n         this.rmContext.getDispatcher().getEventHandler()\n             .handle(new RMNodeStartedEvent(nodeId, null, null));\n       } else {\n         // Reset heartbeat ID since node just restarted.\n         oldNode.resetLastNodeHeartBeatResponse();\n \n         this.rmContext.getDispatcher().getEventHandler()\n             .handle(new RMNodeReconnectEvent(nodeId, rmNode,\n                 request.getRunningApplications(),\n                 request.getNMContainerStatuses()));\n       }\n     }\n     // On every node manager register we will be clearing NMToken keys if\n     // present for any running application.\n     this.nmTokenSecretManager.removeNodeKey(nodeId);\n     this.nmLivelinessMonitor.register(nodeId);\n     \n     // Handle received container status, this should be processed after new\n     // RMNode inserted\n     if (!rmContext.isWorkPreservingRecoveryEnabled()) {\n       if (!request.getNMContainerStatuses().isEmpty()) {\n         LOG.info(\"received container statuses on node manager register :\"\n             + request.getNMContainerStatuses());\n         for (NMContainerStatus status : request.getNMContainerStatuses()) {\n           handleNMContainerStatus(status, nodeId);\n         }\n       }\n     }\n \n     // Update node\u0027s labels to RM\u0027s NodeLabelManager.\n     Set\u003cString\u003e nodeLabels \u003d NodeLabelsUtils.convertToStringSet(\n         request.getNodeLabels());\n     if (isDistributedNodeLabelsConf \u0026\u0026 nodeLabels !\u003d null) {\n       try {\n         updateNodeLabelsFromNMReport(nodeLabels, nodeId);\n         response.setAreNodeLabelsAcceptedByRM(true);\n       } catch (IOException ex) {\n         // Ensure the exception is captured in the response\n         response.setDiagnosticsMessage(ex.getMessage());\n         response.setAreNodeLabelsAcceptedByRM(false);\n       }\n     } else if (isDelegatedCentralizedNodeLabelsConf) {\n       this.rmContext.getRMDelegatedNodeLabelsUpdater().updateNodeLabels(nodeId);\n     }\n \n     // Update node\u0027s attributes to RM\u0027s NodeAttributesManager.\n     if (request.getNodeAttributes() !\u003d null) {\n       try {\n         // update node attributes if necessary then update heartbeat response\n         updateNodeAttributesIfNecessary(nodeId, request.getNodeAttributes());\n         response.setAreNodeAttributesAcceptedByRM(true);\n       } catch (IOException ex) {\n         //ensure the error message is captured and sent across in response\n         String errorMsg \u003d response.getDiagnosticsMessage() \u003d\u003d null ?\n             ex.getMessage() :\n             response.getDiagnosticsMessage() + \"\\n\" + ex.getMessage();\n         response.setDiagnosticsMessage(errorMsg);\n         response.setAreNodeAttributesAcceptedByRM(false);\n       }\n     }\n \n     StringBuilder message \u003d new StringBuilder();\n     message.append(\"NodeManager from node \").append(host).append(\"(cmPort: \")\n         .append(cmPort).append(\" httpPort: \");\n     message.append(httpPort).append(\") \")\n         .append(\"registered with capability: \").append(capability);\n     message.append(\", assigned nodeId \").append(nodeId);\n     if (response.getAreNodeLabelsAcceptedByRM()) {\n       message.append(\", node labels { \").append(\n           StringUtils.join(\",\", nodeLabels) + \" } \");\n     }\n     if (response.getAreNodeAttributesAcceptedByRM()) {\n       message.append(\", node attributes { \")\n           .append(request.getNodeAttributes() + \" } \");\n     }\n \n     LOG.info(message.toString());\n     response.setNodeAction(NodeAction.NORMAL);\n     response.setRMIdentifier(ResourceManager.getClusterTimeStamp());\n     response.setRMVersion(YarnVersionInfo.getVersion());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterNodeManagerResponse registerNodeManager(\n      RegisterNodeManagerRequest request) throws YarnException,\n      IOException {\n    NodeId nodeId \u003d request.getNodeId();\n    String host \u003d nodeId.getHost();\n    int cmPort \u003d nodeId.getPort();\n    int httpPort \u003d request.getHttpPort();\n    Resource capability \u003d request.getResource();\n    String nodeManagerVersion \u003d request.getNMVersion();\n    Resource physicalResource \u003d request.getPhysicalResource();\n\n    RegisterNodeManagerResponse response \u003d recordFactory\n        .newRecordInstance(RegisterNodeManagerResponse.class);\n\n    if (!minimumNodeManagerVersion.equals(\"NONE\")) {\n      if (minimumNodeManagerVersion.equals(\"EqualToRM\")) {\n        minimumNodeManagerVersion \u003d YarnVersionInfo.getVersion();\n      }\n\n      if ((nodeManagerVersion \u003d\u003d null) ||\n          (VersionUtil.compareVersions(nodeManagerVersion,minimumNodeManagerVersion)) \u003c 0) {\n        String message \u003d\n            \"Disallowed NodeManager Version \" + nodeManagerVersion\n                + \", is less than the minimum version \"\n                + minimumNodeManagerVersion + \" sending SHUTDOWN signal to \"\n                + \"NodeManager.\";\n        LOG.info(message);\n        response.setDiagnosticsMessage(message);\n        response.setNodeAction(NodeAction.SHUTDOWN);\n        return response;\n      }\n    }\n\n    if (checkIpHostnameInRegistration) {\n      InetSocketAddress nmAddress \u003d\n          NetUtils.createSocketAddrForHost(host, cmPort);\n      InetAddress inetAddress \u003d Server.getRemoteIp();\n      if (inetAddress !\u003d null \u0026\u0026 nmAddress.isUnresolved()) {\n        // Reject registration of unresolved nm to prevent resourcemanager\n        // getting stuck at allocations.\n        final String message \u003d\n            \"hostname cannot be resolved (ip\u003d\" + inetAddress.getHostAddress()\n                + \", hostname\u003d\" + host + \")\";\n        LOG.warn(\"Unresolved nodemanager registration: \" + message);\n        response.setDiagnosticsMessage(message);\n        response.setNodeAction(NodeAction.SHUTDOWN);\n        return response;\n      }\n    }\n\n    // Check if this node is a \u0027valid\u0027 node\n    if (!this.nodesListManager.isValidNode(host) \u0026\u0026\n        !isNodeInDecommissioning(nodeId)) {\n      String message \u003d\n          \"Disallowed NodeManager from  \" + host\n              + \", Sending SHUTDOWN signal to the NodeManager.\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    // check if node\u0027s capacity is load from dynamic-resources.xml\n    String nid \u003d nodeId.toString();\n\n    Resource dynamicLoadCapability \u003d loadNodeResourceFromDRConfiguration(nid);\n    if (dynamicLoadCapability !\u003d null) {\n      LOG.debug(\"Resource for node: {} is adjusted from: {} to: {} due to\"\n          + \" settings in dynamic-resources.xml.\", nid, capability,\n          dynamicLoadCapability);\n      capability \u003d dynamicLoadCapability;\n      // sync back with new resource.\n      response.setResource(capability);\n    }\n\n    // Check if this node has minimum allocations\n    if (capability.getMemorySize() \u003c minAllocMb\n        || capability.getVirtualCores() \u003c minAllocVcores) {\n      String message \u003d \"NodeManager from  \" + host\n          + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n          + \" signal to the NodeManager. Node capabilities are \" + capability\n          + \"; minimums are \" + minAllocMb + \"mb and \" + minAllocVcores\n          + \" vcores\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    response.setContainerTokenMasterKey(containerTokenSecretManager\n        .getCurrentKey());\n    response.setNMTokenMasterKey(nmTokenSecretManager\n        .getCurrentKey());\n\n    RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n        resolve(host), capability, nodeManagerVersion, physicalResource);\n\n    RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n    if (oldNode \u003d\u003d null) {\n      RMNodeStartedEvent startEvent \u003d new RMNodeStartedEvent(nodeId,\n          request.getNMContainerStatuses(),\n          request.getRunningApplications());\n      if (request.getLogAggregationReportsForApps() !\u003d null\n          \u0026\u0026 !request.getLogAggregationReportsForApps().isEmpty()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Found the number of previous cached log aggregation \"\n              + \"status from nodemanager:\" + nodeId + \" is :\"\n              + request.getLogAggregationReportsForApps().size());\n        }\n        startEvent.setLogAggregationReportsForApps(request\n            .getLogAggregationReportsForApps());\n      }\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          startEvent);\n    } else {\n      LOG.info(\"Reconnect from the node at: \" + host);\n      this.nmLivelinessMonitor.unregister(nodeId);\n\n      if (CollectionUtils.isEmpty(request.getRunningApplications())\n          \u0026\u0026 rmNode.getState() !\u003d NodeState.DECOMMISSIONING\n          \u0026\u0026 rmNode.getHttpPort() !\u003d oldNode.getHttpPort()) {\n        // Reconnected node differs, so replace old node and start new node\n        switch (rmNode.getState()) {\n        case RUNNING:\n          ClusterMetrics.getMetrics().decrNumActiveNodes();\n          break;\n        case UNHEALTHY:\n          ClusterMetrics.getMetrics().decrNumUnhealthyNMs();\n          break;\n        default:\n          LOG.debug(\"Unexpected Rmnode state\");\n        }\n        this.rmContext.getDispatcher().getEventHandler()\n            .handle(new NodeRemovedSchedulerEvent(rmNode));\n\n        this.rmContext.getRMNodes().put(nodeId, rmNode);\n        this.rmContext.getDispatcher().getEventHandler()\n            .handle(new RMNodeStartedEvent(nodeId, null, null));\n      } else {\n        // Reset heartbeat ID since node just restarted.\n        oldNode.resetLastNodeHeartBeatResponse();\n\n        this.rmContext.getDispatcher().getEventHandler()\n            .handle(new RMNodeReconnectEvent(nodeId, rmNode,\n                request.getRunningApplications(),\n                request.getNMContainerStatuses()));\n      }\n    }\n    // On every node manager register we will be clearing NMToken keys if\n    // present for any running application.\n    this.nmTokenSecretManager.removeNodeKey(nodeId);\n    this.nmLivelinessMonitor.register(nodeId);\n    \n    // Handle received container status, this should be processed after new\n    // RMNode inserted\n    if (!rmContext.isWorkPreservingRecoveryEnabled()) {\n      if (!request.getNMContainerStatuses().isEmpty()) {\n        LOG.info(\"received container statuses on node manager register :\"\n            + request.getNMContainerStatuses());\n        for (NMContainerStatus status : request.getNMContainerStatuses()) {\n          handleNMContainerStatus(status, nodeId);\n        }\n      }\n    }\n\n    // Update node\u0027s labels to RM\u0027s NodeLabelManager.\n    Set\u003cString\u003e nodeLabels \u003d NodeLabelsUtils.convertToStringSet(\n        request.getNodeLabels());\n    if (isDistributedNodeLabelsConf \u0026\u0026 nodeLabels !\u003d null) {\n      try {\n        updateNodeLabelsFromNMReport(nodeLabels, nodeId);\n        response.setAreNodeLabelsAcceptedByRM(true);\n      } catch (IOException ex) {\n        // Ensure the exception is captured in the response\n        response.setDiagnosticsMessage(ex.getMessage());\n        response.setAreNodeLabelsAcceptedByRM(false);\n      }\n    } else if (isDelegatedCentralizedNodeLabelsConf) {\n      this.rmContext.getRMDelegatedNodeLabelsUpdater().updateNodeLabels(nodeId);\n    }\n\n    // Update node\u0027s attributes to RM\u0027s NodeAttributesManager.\n    if (request.getNodeAttributes() !\u003d null) {\n      try {\n        // update node attributes if necessary then update heartbeat response\n        updateNodeAttributesIfNecessary(nodeId, request.getNodeAttributes());\n        response.setAreNodeAttributesAcceptedByRM(true);\n      } catch (IOException ex) {\n        //ensure the error message is captured and sent across in response\n        String errorMsg \u003d response.getDiagnosticsMessage() \u003d\u003d null ?\n            ex.getMessage() :\n            response.getDiagnosticsMessage() + \"\\n\" + ex.getMessage();\n        response.setDiagnosticsMessage(errorMsg);\n        response.setAreNodeAttributesAcceptedByRM(false);\n      }\n    }\n\n    StringBuilder message \u003d new StringBuilder();\n    message.append(\"NodeManager from node \").append(host).append(\"(cmPort: \")\n        .append(cmPort).append(\" httpPort: \");\n    message.append(httpPort).append(\") \")\n        .append(\"registered with capability: \").append(capability);\n    message.append(\", assigned nodeId \").append(nodeId);\n    if (response.getAreNodeLabelsAcceptedByRM()) {\n      message.append(\", node labels { \").append(\n          StringUtils.join(\",\", nodeLabels) + \" } \");\n    }\n    if (response.getAreNodeAttributesAcceptedByRM()) {\n      message.append(\", node attributes { \")\n          .append(request.getNodeAttributes() + \" } \");\n    }\n\n    LOG.info(message.toString());\n    response.setNodeAction(NodeAction.NORMAL);\n    response.setRMIdentifier(ResourceManager.getClusterTimeStamp());\n    response.setRMVersion(YarnVersionInfo.getVersion());\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "f659485ee83f3f34e3717631983adfc8fa1e53dc": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8925. Updating distributed node attributes only when necessary. Contributed by Tao Yang.\n",
      "commitDate": "20/12/18 6:56 PM",
      "commitName": "f659485ee83f3f34e3717631983adfc8fa1e53dc",
      "commitAuthor": "Weiwei Yang",
      "commitDateOld": "05/10/18 1:52 PM",
      "commitNameOld": "9bb2801e8ce1e6298241944a65f593f555ae10e2",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 76.25,
      "commitsBetweenForRepo": 600,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,200 +1,220 @@\n   public RegisterNodeManagerResponse registerNodeManager(\n       RegisterNodeManagerRequest request) throws YarnException,\n       IOException {\n     NodeId nodeId \u003d request.getNodeId();\n     String host \u003d nodeId.getHost();\n     int cmPort \u003d nodeId.getPort();\n     int httpPort \u003d request.getHttpPort();\n     Resource capability \u003d request.getResource();\n     String nodeManagerVersion \u003d request.getNMVersion();\n     Resource physicalResource \u003d request.getPhysicalResource();\n \n     RegisterNodeManagerResponse response \u003d recordFactory\n         .newRecordInstance(RegisterNodeManagerResponse.class);\n \n     if (!minimumNodeManagerVersion.equals(\"NONE\")) {\n       if (minimumNodeManagerVersion.equals(\"EqualToRM\")) {\n         minimumNodeManagerVersion \u003d YarnVersionInfo.getVersion();\n       }\n \n       if ((nodeManagerVersion \u003d\u003d null) ||\n           (VersionUtil.compareVersions(nodeManagerVersion,minimumNodeManagerVersion)) \u003c 0) {\n         String message \u003d\n             \"Disallowed NodeManager Version \" + nodeManagerVersion\n                 + \", is less than the minimum version \"\n                 + minimumNodeManagerVersion + \" sending SHUTDOWN signal to \"\n                 + \"NodeManager.\";\n         LOG.info(message);\n         response.setDiagnosticsMessage(message);\n         response.setNodeAction(NodeAction.SHUTDOWN);\n         return response;\n       }\n     }\n \n     if (checkIpHostnameInRegistration) {\n       InetSocketAddress nmAddress \u003d\n           NetUtils.createSocketAddrForHost(host, cmPort);\n       InetAddress inetAddress \u003d Server.getRemoteIp();\n       if (inetAddress !\u003d null \u0026\u0026 nmAddress.isUnresolved()) {\n         // Reject registration of unresolved nm to prevent resourcemanager\n         // getting stuck at allocations.\n         final String message \u003d\n             \"hostname cannot be resolved (ip\u003d\" + inetAddress.getHostAddress()\n                 + \", hostname\u003d\" + host + \")\";\n         LOG.warn(\"Unresolved nodemanager registration: \" + message);\n         response.setDiagnosticsMessage(message);\n         response.setNodeAction(NodeAction.SHUTDOWN);\n         return response;\n       }\n     }\n \n     // Check if this node is a \u0027valid\u0027 node\n     if (!this.nodesListManager.isValidNode(host) \u0026\u0026\n         !isNodeInDecommissioning(nodeId)) {\n       String message \u003d\n           \"Disallowed NodeManager from  \" + host\n               + \", Sending SHUTDOWN signal to the NodeManager.\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     // check if node\u0027s capacity is load from dynamic-resources.xml\n     String nid \u003d nodeId.toString();\n \n     Resource dynamicLoadCapability \u003d loadNodeResourceFromDRConfiguration(nid);\n     if (dynamicLoadCapability !\u003d null) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Resource for node: \" + nid + \" is adjusted from: \" +\n             capability + \" to: \" + dynamicLoadCapability +\n             \" due to settings in dynamic-resources.xml.\");\n       }\n       capability \u003d dynamicLoadCapability;\n       // sync back with new resource.\n       response.setResource(capability);\n     }\n \n     // Check if this node has minimum allocations\n     if (capability.getMemorySize() \u003c minAllocMb\n         || capability.getVirtualCores() \u003c minAllocVcores) {\n       String message \u003d \"NodeManager from  \" + host\n           + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n           + \" signal to the NodeManager. Node capabilities are \" + capability\n           + \"; minimums are \" + minAllocMb + \"mb and \" + minAllocVcores\n           + \" vcores\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     response.setContainerTokenMasterKey(containerTokenSecretManager\n         .getCurrentKey());\n     response.setNMTokenMasterKey(nmTokenSecretManager\n         .getCurrentKey());\n \n     RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n         resolve(host), capability, nodeManagerVersion, physicalResource);\n \n     RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n     if (oldNode \u003d\u003d null) {\n       RMNodeStartedEvent startEvent \u003d new RMNodeStartedEvent(nodeId,\n           request.getNMContainerStatuses(),\n           request.getRunningApplications());\n       if (request.getLogAggregationReportsForApps() !\u003d null\n           \u0026\u0026 !request.getLogAggregationReportsForApps().isEmpty()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Found the number of previous cached log aggregation \"\n               + \"status from nodemanager:\" + nodeId + \" is :\"\n               + request.getLogAggregationReportsForApps().size());\n         }\n         startEvent.setLogAggregationReportsForApps(request\n             .getLogAggregationReportsForApps());\n       }\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           startEvent);\n     } else {\n       LOG.info(\"Reconnect from the node at: \" + host);\n       this.nmLivelinessMonitor.unregister(nodeId);\n \n       if (CollectionUtils.isEmpty(request.getRunningApplications())\n           \u0026\u0026 rmNode.getState() !\u003d NodeState.DECOMMISSIONING\n           \u0026\u0026 rmNode.getHttpPort() !\u003d oldNode.getHttpPort()) {\n         // Reconnected node differs, so replace old node and start new node\n         switch (rmNode.getState()) {\n         case RUNNING:\n           ClusterMetrics.getMetrics().decrNumActiveNodes();\n           break;\n         case UNHEALTHY:\n           ClusterMetrics.getMetrics().decrNumUnhealthyNMs();\n           break;\n         default:\n           LOG.debug(\"Unexpected Rmnode state\");\n         }\n         this.rmContext.getDispatcher().getEventHandler()\n             .handle(new NodeRemovedSchedulerEvent(rmNode));\n \n         this.rmContext.getRMNodes().put(nodeId, rmNode);\n         this.rmContext.getDispatcher().getEventHandler()\n             .handle(new RMNodeStartedEvent(nodeId, null, null));\n       } else {\n         // Reset heartbeat ID since node just restarted.\n         oldNode.resetLastNodeHeartBeatResponse();\n \n         this.rmContext.getDispatcher().getEventHandler()\n             .handle(new RMNodeReconnectEvent(nodeId, rmNode,\n                 request.getRunningApplications(),\n                 request.getNMContainerStatuses()));\n       }\n     }\n     // On every node manager register we will be clearing NMToken keys if\n     // present for any running application.\n     this.nmTokenSecretManager.removeNodeKey(nodeId);\n     this.nmLivelinessMonitor.register(nodeId);\n     \n     // Handle received container status, this should be processed after new\n     // RMNode inserted\n     if (!rmContext.isWorkPreservingRecoveryEnabled()) {\n       if (!request.getNMContainerStatuses().isEmpty()) {\n         LOG.info(\"received container statuses on node manager register :\"\n             + request.getNMContainerStatuses());\n         for (NMContainerStatus status : request.getNMContainerStatuses()) {\n           handleNMContainerStatus(status, nodeId);\n         }\n       }\n     }\n \n     // Update node\u0027s labels to RM\u0027s NodeLabelManager.\n     Set\u003cString\u003e nodeLabels \u003d NodeLabelsUtils.convertToStringSet(\n         request.getNodeLabels());\n     if (isDistributedNodeLabelsConf \u0026\u0026 nodeLabels !\u003d null) {\n       try {\n         updateNodeLabelsFromNMReport(nodeLabels, nodeId);\n         response.setAreNodeLabelsAcceptedByRM(true);\n       } catch (IOException ex) {\n         // Ensure the exception is captured in the response\n         response.setDiagnosticsMessage(ex.getMessage());\n         response.setAreNodeLabelsAcceptedByRM(false);\n       }\n     } else if (isDelegatedCentralizedNodeLabelsConf) {\n       this.rmContext.getRMDelegatedNodeLabelsUpdater().updateNodeLabels(nodeId);\n     }\n \n+    // Update node\u0027s attributes to RM\u0027s NodeAttributesManager.\n+    if (request.getNodeAttributes() !\u003d null) {\n+      try {\n+        // update node attributes if necessary then update heartbeat response\n+        updateNodeAttributesIfNecessary(nodeId, request.getNodeAttributes());\n+        response.setAreNodeAttributesAcceptedByRM(true);\n+      } catch (IOException ex) {\n+        //ensure the error message is captured and sent across in response\n+        String errorMsg \u003d response.getDiagnosticsMessage() \u003d\u003d null ?\n+            ex.getMessage() :\n+            response.getDiagnosticsMessage() + \"\\n\" + ex.getMessage();\n+        response.setDiagnosticsMessage(errorMsg);\n+        response.setAreNodeAttributesAcceptedByRM(false);\n+      }\n+    }\n+\n     StringBuilder message \u003d new StringBuilder();\n     message.append(\"NodeManager from node \").append(host).append(\"(cmPort: \")\n         .append(cmPort).append(\" httpPort: \");\n     message.append(httpPort).append(\") \")\n         .append(\"registered with capability: \").append(capability);\n     message.append(\", assigned nodeId \").append(nodeId);\n     if (response.getAreNodeLabelsAcceptedByRM()) {\n       message.append(\", node labels { \").append(\n           StringUtils.join(\",\", nodeLabels) + \" } \");\n     }\n+    if (response.getAreNodeAttributesAcceptedByRM()) {\n+      message.append(\", node attributes { \")\n+          .append(request.getNodeAttributes() + \" } \");\n+    }\n \n     LOG.info(message.toString());\n     response.setNodeAction(NodeAction.NORMAL);\n     response.setRMIdentifier(ResourceManager.getClusterTimeStamp());\n     response.setRMVersion(YarnVersionInfo.getVersion());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterNodeManagerResponse registerNodeManager(\n      RegisterNodeManagerRequest request) throws YarnException,\n      IOException {\n    NodeId nodeId \u003d request.getNodeId();\n    String host \u003d nodeId.getHost();\n    int cmPort \u003d nodeId.getPort();\n    int httpPort \u003d request.getHttpPort();\n    Resource capability \u003d request.getResource();\n    String nodeManagerVersion \u003d request.getNMVersion();\n    Resource physicalResource \u003d request.getPhysicalResource();\n\n    RegisterNodeManagerResponse response \u003d recordFactory\n        .newRecordInstance(RegisterNodeManagerResponse.class);\n\n    if (!minimumNodeManagerVersion.equals(\"NONE\")) {\n      if (minimumNodeManagerVersion.equals(\"EqualToRM\")) {\n        minimumNodeManagerVersion \u003d YarnVersionInfo.getVersion();\n      }\n\n      if ((nodeManagerVersion \u003d\u003d null) ||\n          (VersionUtil.compareVersions(nodeManagerVersion,minimumNodeManagerVersion)) \u003c 0) {\n        String message \u003d\n            \"Disallowed NodeManager Version \" + nodeManagerVersion\n                + \", is less than the minimum version \"\n                + minimumNodeManagerVersion + \" sending SHUTDOWN signal to \"\n                + \"NodeManager.\";\n        LOG.info(message);\n        response.setDiagnosticsMessage(message);\n        response.setNodeAction(NodeAction.SHUTDOWN);\n        return response;\n      }\n    }\n\n    if (checkIpHostnameInRegistration) {\n      InetSocketAddress nmAddress \u003d\n          NetUtils.createSocketAddrForHost(host, cmPort);\n      InetAddress inetAddress \u003d Server.getRemoteIp();\n      if (inetAddress !\u003d null \u0026\u0026 nmAddress.isUnresolved()) {\n        // Reject registration of unresolved nm to prevent resourcemanager\n        // getting stuck at allocations.\n        final String message \u003d\n            \"hostname cannot be resolved (ip\u003d\" + inetAddress.getHostAddress()\n                + \", hostname\u003d\" + host + \")\";\n        LOG.warn(\"Unresolved nodemanager registration: \" + message);\n        response.setDiagnosticsMessage(message);\n        response.setNodeAction(NodeAction.SHUTDOWN);\n        return response;\n      }\n    }\n\n    // Check if this node is a \u0027valid\u0027 node\n    if (!this.nodesListManager.isValidNode(host) \u0026\u0026\n        !isNodeInDecommissioning(nodeId)) {\n      String message \u003d\n          \"Disallowed NodeManager from  \" + host\n              + \", Sending SHUTDOWN signal to the NodeManager.\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    // check if node\u0027s capacity is load from dynamic-resources.xml\n    String nid \u003d nodeId.toString();\n\n    Resource dynamicLoadCapability \u003d loadNodeResourceFromDRConfiguration(nid);\n    if (dynamicLoadCapability !\u003d null) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Resource for node: \" + nid + \" is adjusted from: \" +\n            capability + \" to: \" + dynamicLoadCapability +\n            \" due to settings in dynamic-resources.xml.\");\n      }\n      capability \u003d dynamicLoadCapability;\n      // sync back with new resource.\n      response.setResource(capability);\n    }\n\n    // Check if this node has minimum allocations\n    if (capability.getMemorySize() \u003c minAllocMb\n        || capability.getVirtualCores() \u003c minAllocVcores) {\n      String message \u003d \"NodeManager from  \" + host\n          + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n          + \" signal to the NodeManager. Node capabilities are \" + capability\n          + \"; minimums are \" + minAllocMb + \"mb and \" + minAllocVcores\n          + \" vcores\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    response.setContainerTokenMasterKey(containerTokenSecretManager\n        .getCurrentKey());\n    response.setNMTokenMasterKey(nmTokenSecretManager\n        .getCurrentKey());\n\n    RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n        resolve(host), capability, nodeManagerVersion, physicalResource);\n\n    RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n    if (oldNode \u003d\u003d null) {\n      RMNodeStartedEvent startEvent \u003d new RMNodeStartedEvent(nodeId,\n          request.getNMContainerStatuses(),\n          request.getRunningApplications());\n      if (request.getLogAggregationReportsForApps() !\u003d null\n          \u0026\u0026 !request.getLogAggregationReportsForApps().isEmpty()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Found the number of previous cached log aggregation \"\n              + \"status from nodemanager:\" + nodeId + \" is :\"\n              + request.getLogAggregationReportsForApps().size());\n        }\n        startEvent.setLogAggregationReportsForApps(request\n            .getLogAggregationReportsForApps());\n      }\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          startEvent);\n    } else {\n      LOG.info(\"Reconnect from the node at: \" + host);\n      this.nmLivelinessMonitor.unregister(nodeId);\n\n      if (CollectionUtils.isEmpty(request.getRunningApplications())\n          \u0026\u0026 rmNode.getState() !\u003d NodeState.DECOMMISSIONING\n          \u0026\u0026 rmNode.getHttpPort() !\u003d oldNode.getHttpPort()) {\n        // Reconnected node differs, so replace old node and start new node\n        switch (rmNode.getState()) {\n        case RUNNING:\n          ClusterMetrics.getMetrics().decrNumActiveNodes();\n          break;\n        case UNHEALTHY:\n          ClusterMetrics.getMetrics().decrNumUnhealthyNMs();\n          break;\n        default:\n          LOG.debug(\"Unexpected Rmnode state\");\n        }\n        this.rmContext.getDispatcher().getEventHandler()\n            .handle(new NodeRemovedSchedulerEvent(rmNode));\n\n        this.rmContext.getRMNodes().put(nodeId, rmNode);\n        this.rmContext.getDispatcher().getEventHandler()\n            .handle(new RMNodeStartedEvent(nodeId, null, null));\n      } else {\n        // Reset heartbeat ID since node just restarted.\n        oldNode.resetLastNodeHeartBeatResponse();\n\n        this.rmContext.getDispatcher().getEventHandler()\n            .handle(new RMNodeReconnectEvent(nodeId, rmNode,\n                request.getRunningApplications(),\n                request.getNMContainerStatuses()));\n      }\n    }\n    // On every node manager register we will be clearing NMToken keys if\n    // present for any running application.\n    this.nmTokenSecretManager.removeNodeKey(nodeId);\n    this.nmLivelinessMonitor.register(nodeId);\n    \n    // Handle received container status, this should be processed after new\n    // RMNode inserted\n    if (!rmContext.isWorkPreservingRecoveryEnabled()) {\n      if (!request.getNMContainerStatuses().isEmpty()) {\n        LOG.info(\"received container statuses on node manager register :\"\n            + request.getNMContainerStatuses());\n        for (NMContainerStatus status : request.getNMContainerStatuses()) {\n          handleNMContainerStatus(status, nodeId);\n        }\n      }\n    }\n\n    // Update node\u0027s labels to RM\u0027s NodeLabelManager.\n    Set\u003cString\u003e nodeLabels \u003d NodeLabelsUtils.convertToStringSet(\n        request.getNodeLabels());\n    if (isDistributedNodeLabelsConf \u0026\u0026 nodeLabels !\u003d null) {\n      try {\n        updateNodeLabelsFromNMReport(nodeLabels, nodeId);\n        response.setAreNodeLabelsAcceptedByRM(true);\n      } catch (IOException ex) {\n        // Ensure the exception is captured in the response\n        response.setDiagnosticsMessage(ex.getMessage());\n        response.setAreNodeLabelsAcceptedByRM(false);\n      }\n    } else if (isDelegatedCentralizedNodeLabelsConf) {\n      this.rmContext.getRMDelegatedNodeLabelsUpdater().updateNodeLabels(nodeId);\n    }\n\n    // Update node\u0027s attributes to RM\u0027s NodeAttributesManager.\n    if (request.getNodeAttributes() !\u003d null) {\n      try {\n        // update node attributes if necessary then update heartbeat response\n        updateNodeAttributesIfNecessary(nodeId, request.getNodeAttributes());\n        response.setAreNodeAttributesAcceptedByRM(true);\n      } catch (IOException ex) {\n        //ensure the error message is captured and sent across in response\n        String errorMsg \u003d response.getDiagnosticsMessage() \u003d\u003d null ?\n            ex.getMessage() :\n            response.getDiagnosticsMessage() + \"\\n\" + ex.getMessage();\n        response.setDiagnosticsMessage(errorMsg);\n        response.setAreNodeAttributesAcceptedByRM(false);\n      }\n    }\n\n    StringBuilder message \u003d new StringBuilder();\n    message.append(\"NodeManager from node \").append(host).append(\"(cmPort: \")\n        .append(cmPort).append(\" httpPort: \");\n    message.append(httpPort).append(\") \")\n        .append(\"registered with capability: \").append(capability);\n    message.append(\", assigned nodeId \").append(nodeId);\n    if (response.getAreNodeLabelsAcceptedByRM()) {\n      message.append(\", node labels { \").append(\n          StringUtils.join(\",\", nodeLabels) + \" } \");\n    }\n    if (response.getAreNodeAttributesAcceptedByRM()) {\n      message.append(\", node attributes { \")\n          .append(request.getNodeAttributes() + \" } \");\n    }\n\n    LOG.info(message.toString());\n    response.setNodeAction(NodeAction.NORMAL);\n    response.setRMIdentifier(ResourceManager.getClusterTimeStamp());\n    response.setRMVersion(YarnVersionInfo.getVersion());\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "9bb2801e8ce1e6298241944a65f593f555ae10e2": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4254. ApplicationAttempt stuck for ever due to UnknownHostException. Contributed by Bibin A Chundatt\n",
      "commitDate": "05/10/18 1:52 PM",
      "commitName": "9bb2801e8ce1e6298241944a65f593f555ae10e2",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "12/09/18 3:31 AM",
      "commitNameOld": "c44088ac190e515b099183aeed4f9d6f8bee7da6",
      "commitAuthorOld": "bibinchundatt",
      "daysBetweenCommits": 23.43,
      "commitsBetweenForRepo": 242,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,183 +1,200 @@\n   public RegisterNodeManagerResponse registerNodeManager(\n       RegisterNodeManagerRequest request) throws YarnException,\n       IOException {\n     NodeId nodeId \u003d request.getNodeId();\n     String host \u003d nodeId.getHost();\n     int cmPort \u003d nodeId.getPort();\n     int httpPort \u003d request.getHttpPort();\n     Resource capability \u003d request.getResource();\n     String nodeManagerVersion \u003d request.getNMVersion();\n     Resource physicalResource \u003d request.getPhysicalResource();\n \n     RegisterNodeManagerResponse response \u003d recordFactory\n         .newRecordInstance(RegisterNodeManagerResponse.class);\n \n     if (!minimumNodeManagerVersion.equals(\"NONE\")) {\n       if (minimumNodeManagerVersion.equals(\"EqualToRM\")) {\n         minimumNodeManagerVersion \u003d YarnVersionInfo.getVersion();\n       }\n \n       if ((nodeManagerVersion \u003d\u003d null) ||\n           (VersionUtil.compareVersions(nodeManagerVersion,minimumNodeManagerVersion)) \u003c 0) {\n         String message \u003d\n             \"Disallowed NodeManager Version \" + nodeManagerVersion\n                 + \", is less than the minimum version \"\n                 + minimumNodeManagerVersion + \" sending SHUTDOWN signal to \"\n                 + \"NodeManager.\";\n         LOG.info(message);\n         response.setDiagnosticsMessage(message);\n         response.setNodeAction(NodeAction.SHUTDOWN);\n         return response;\n       }\n     }\n \n+    if (checkIpHostnameInRegistration) {\n+      InetSocketAddress nmAddress \u003d\n+          NetUtils.createSocketAddrForHost(host, cmPort);\n+      InetAddress inetAddress \u003d Server.getRemoteIp();\n+      if (inetAddress !\u003d null \u0026\u0026 nmAddress.isUnresolved()) {\n+        // Reject registration of unresolved nm to prevent resourcemanager\n+        // getting stuck at allocations.\n+        final String message \u003d\n+            \"hostname cannot be resolved (ip\u003d\" + inetAddress.getHostAddress()\n+                + \", hostname\u003d\" + host + \")\";\n+        LOG.warn(\"Unresolved nodemanager registration: \" + message);\n+        response.setDiagnosticsMessage(message);\n+        response.setNodeAction(NodeAction.SHUTDOWN);\n+        return response;\n+      }\n+    }\n+\n     // Check if this node is a \u0027valid\u0027 node\n     if (!this.nodesListManager.isValidNode(host) \u0026\u0026\n         !isNodeInDecommissioning(nodeId)) {\n       String message \u003d\n           \"Disallowed NodeManager from  \" + host\n               + \", Sending SHUTDOWN signal to the NodeManager.\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     // check if node\u0027s capacity is load from dynamic-resources.xml\n     String nid \u003d nodeId.toString();\n \n     Resource dynamicLoadCapability \u003d loadNodeResourceFromDRConfiguration(nid);\n     if (dynamicLoadCapability !\u003d null) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Resource for node: \" + nid + \" is adjusted from: \" +\n             capability + \" to: \" + dynamicLoadCapability +\n             \" due to settings in dynamic-resources.xml.\");\n       }\n       capability \u003d dynamicLoadCapability;\n       // sync back with new resource.\n       response.setResource(capability);\n     }\n \n     // Check if this node has minimum allocations\n     if (capability.getMemorySize() \u003c minAllocMb\n         || capability.getVirtualCores() \u003c minAllocVcores) {\n       String message \u003d \"NodeManager from  \" + host\n           + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n           + \" signal to the NodeManager. Node capabilities are \" + capability\n           + \"; minimums are \" + minAllocMb + \"mb and \" + minAllocVcores\n           + \" vcores\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     response.setContainerTokenMasterKey(containerTokenSecretManager\n         .getCurrentKey());\n     response.setNMTokenMasterKey(nmTokenSecretManager\n         .getCurrentKey());\n \n     RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n         resolve(host), capability, nodeManagerVersion, physicalResource);\n \n     RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n     if (oldNode \u003d\u003d null) {\n       RMNodeStartedEvent startEvent \u003d new RMNodeStartedEvent(nodeId,\n           request.getNMContainerStatuses(),\n           request.getRunningApplications());\n       if (request.getLogAggregationReportsForApps() !\u003d null\n           \u0026\u0026 !request.getLogAggregationReportsForApps().isEmpty()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Found the number of previous cached log aggregation \"\n               + \"status from nodemanager:\" + nodeId + \" is :\"\n               + request.getLogAggregationReportsForApps().size());\n         }\n         startEvent.setLogAggregationReportsForApps(request\n             .getLogAggregationReportsForApps());\n       }\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           startEvent);\n     } else {\n       LOG.info(\"Reconnect from the node at: \" + host);\n       this.nmLivelinessMonitor.unregister(nodeId);\n \n       if (CollectionUtils.isEmpty(request.getRunningApplications())\n           \u0026\u0026 rmNode.getState() !\u003d NodeState.DECOMMISSIONING\n           \u0026\u0026 rmNode.getHttpPort() !\u003d oldNode.getHttpPort()) {\n         // Reconnected node differs, so replace old node and start new node\n         switch (rmNode.getState()) {\n         case RUNNING:\n           ClusterMetrics.getMetrics().decrNumActiveNodes();\n           break;\n         case UNHEALTHY:\n           ClusterMetrics.getMetrics().decrNumUnhealthyNMs();\n           break;\n         default:\n           LOG.debug(\"Unexpected Rmnode state\");\n         }\n         this.rmContext.getDispatcher().getEventHandler()\n             .handle(new NodeRemovedSchedulerEvent(rmNode));\n \n         this.rmContext.getRMNodes().put(nodeId, rmNode);\n         this.rmContext.getDispatcher().getEventHandler()\n             .handle(new RMNodeStartedEvent(nodeId, null, null));\n       } else {\n         // Reset heartbeat ID since node just restarted.\n         oldNode.resetLastNodeHeartBeatResponse();\n \n         this.rmContext.getDispatcher().getEventHandler()\n             .handle(new RMNodeReconnectEvent(nodeId, rmNode,\n                 request.getRunningApplications(),\n                 request.getNMContainerStatuses()));\n       }\n     }\n     // On every node manager register we will be clearing NMToken keys if\n     // present for any running application.\n     this.nmTokenSecretManager.removeNodeKey(nodeId);\n     this.nmLivelinessMonitor.register(nodeId);\n     \n     // Handle received container status, this should be processed after new\n     // RMNode inserted\n     if (!rmContext.isWorkPreservingRecoveryEnabled()) {\n       if (!request.getNMContainerStatuses().isEmpty()) {\n         LOG.info(\"received container statuses on node manager register :\"\n             + request.getNMContainerStatuses());\n         for (NMContainerStatus status : request.getNMContainerStatuses()) {\n           handleNMContainerStatus(status, nodeId);\n         }\n       }\n     }\n \n     // Update node\u0027s labels to RM\u0027s NodeLabelManager.\n     Set\u003cString\u003e nodeLabels \u003d NodeLabelsUtils.convertToStringSet(\n         request.getNodeLabels());\n     if (isDistributedNodeLabelsConf \u0026\u0026 nodeLabels !\u003d null) {\n       try {\n         updateNodeLabelsFromNMReport(nodeLabels, nodeId);\n         response.setAreNodeLabelsAcceptedByRM(true);\n       } catch (IOException ex) {\n         // Ensure the exception is captured in the response\n         response.setDiagnosticsMessage(ex.getMessage());\n         response.setAreNodeLabelsAcceptedByRM(false);\n       }\n     } else if (isDelegatedCentralizedNodeLabelsConf) {\n       this.rmContext.getRMDelegatedNodeLabelsUpdater().updateNodeLabels(nodeId);\n     }\n \n     StringBuilder message \u003d new StringBuilder();\n     message.append(\"NodeManager from node \").append(host).append(\"(cmPort: \")\n         .append(cmPort).append(\" httpPort: \");\n     message.append(httpPort).append(\") \")\n         .append(\"registered with capability: \").append(capability);\n     message.append(\", assigned nodeId \").append(nodeId);\n     if (response.getAreNodeLabelsAcceptedByRM()) {\n       message.append(\", node labels { \").append(\n           StringUtils.join(\",\", nodeLabels) + \" } \");\n     }\n \n     LOG.info(message.toString());\n     response.setNodeAction(NodeAction.NORMAL);\n     response.setRMIdentifier(ResourceManager.getClusterTimeStamp());\n     response.setRMVersion(YarnVersionInfo.getVersion());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterNodeManagerResponse registerNodeManager(\n      RegisterNodeManagerRequest request) throws YarnException,\n      IOException {\n    NodeId nodeId \u003d request.getNodeId();\n    String host \u003d nodeId.getHost();\n    int cmPort \u003d nodeId.getPort();\n    int httpPort \u003d request.getHttpPort();\n    Resource capability \u003d request.getResource();\n    String nodeManagerVersion \u003d request.getNMVersion();\n    Resource physicalResource \u003d request.getPhysicalResource();\n\n    RegisterNodeManagerResponse response \u003d recordFactory\n        .newRecordInstance(RegisterNodeManagerResponse.class);\n\n    if (!minimumNodeManagerVersion.equals(\"NONE\")) {\n      if (minimumNodeManagerVersion.equals(\"EqualToRM\")) {\n        minimumNodeManagerVersion \u003d YarnVersionInfo.getVersion();\n      }\n\n      if ((nodeManagerVersion \u003d\u003d null) ||\n          (VersionUtil.compareVersions(nodeManagerVersion,minimumNodeManagerVersion)) \u003c 0) {\n        String message \u003d\n            \"Disallowed NodeManager Version \" + nodeManagerVersion\n                + \", is less than the minimum version \"\n                + minimumNodeManagerVersion + \" sending SHUTDOWN signal to \"\n                + \"NodeManager.\";\n        LOG.info(message);\n        response.setDiagnosticsMessage(message);\n        response.setNodeAction(NodeAction.SHUTDOWN);\n        return response;\n      }\n    }\n\n    if (checkIpHostnameInRegistration) {\n      InetSocketAddress nmAddress \u003d\n          NetUtils.createSocketAddrForHost(host, cmPort);\n      InetAddress inetAddress \u003d Server.getRemoteIp();\n      if (inetAddress !\u003d null \u0026\u0026 nmAddress.isUnresolved()) {\n        // Reject registration of unresolved nm to prevent resourcemanager\n        // getting stuck at allocations.\n        final String message \u003d\n            \"hostname cannot be resolved (ip\u003d\" + inetAddress.getHostAddress()\n                + \", hostname\u003d\" + host + \")\";\n        LOG.warn(\"Unresolved nodemanager registration: \" + message);\n        response.setDiagnosticsMessage(message);\n        response.setNodeAction(NodeAction.SHUTDOWN);\n        return response;\n      }\n    }\n\n    // Check if this node is a \u0027valid\u0027 node\n    if (!this.nodesListManager.isValidNode(host) \u0026\u0026\n        !isNodeInDecommissioning(nodeId)) {\n      String message \u003d\n          \"Disallowed NodeManager from  \" + host\n              + \", Sending SHUTDOWN signal to the NodeManager.\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    // check if node\u0027s capacity is load from dynamic-resources.xml\n    String nid \u003d nodeId.toString();\n\n    Resource dynamicLoadCapability \u003d loadNodeResourceFromDRConfiguration(nid);\n    if (dynamicLoadCapability !\u003d null) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Resource for node: \" + nid + \" is adjusted from: \" +\n            capability + \" to: \" + dynamicLoadCapability +\n            \" due to settings in dynamic-resources.xml.\");\n      }\n      capability \u003d dynamicLoadCapability;\n      // sync back with new resource.\n      response.setResource(capability);\n    }\n\n    // Check if this node has minimum allocations\n    if (capability.getMemorySize() \u003c minAllocMb\n        || capability.getVirtualCores() \u003c minAllocVcores) {\n      String message \u003d \"NodeManager from  \" + host\n          + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n          + \" signal to the NodeManager. Node capabilities are \" + capability\n          + \"; minimums are \" + minAllocMb + \"mb and \" + minAllocVcores\n          + \" vcores\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    response.setContainerTokenMasterKey(containerTokenSecretManager\n        .getCurrentKey());\n    response.setNMTokenMasterKey(nmTokenSecretManager\n        .getCurrentKey());\n\n    RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n        resolve(host), capability, nodeManagerVersion, physicalResource);\n\n    RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n    if (oldNode \u003d\u003d null) {\n      RMNodeStartedEvent startEvent \u003d new RMNodeStartedEvent(nodeId,\n          request.getNMContainerStatuses(),\n          request.getRunningApplications());\n      if (request.getLogAggregationReportsForApps() !\u003d null\n          \u0026\u0026 !request.getLogAggregationReportsForApps().isEmpty()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Found the number of previous cached log aggregation \"\n              + \"status from nodemanager:\" + nodeId + \" is :\"\n              + request.getLogAggregationReportsForApps().size());\n        }\n        startEvent.setLogAggregationReportsForApps(request\n            .getLogAggregationReportsForApps());\n      }\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          startEvent);\n    } else {\n      LOG.info(\"Reconnect from the node at: \" + host);\n      this.nmLivelinessMonitor.unregister(nodeId);\n\n      if (CollectionUtils.isEmpty(request.getRunningApplications())\n          \u0026\u0026 rmNode.getState() !\u003d NodeState.DECOMMISSIONING\n          \u0026\u0026 rmNode.getHttpPort() !\u003d oldNode.getHttpPort()) {\n        // Reconnected node differs, so replace old node and start new node\n        switch (rmNode.getState()) {\n        case RUNNING:\n          ClusterMetrics.getMetrics().decrNumActiveNodes();\n          break;\n        case UNHEALTHY:\n          ClusterMetrics.getMetrics().decrNumUnhealthyNMs();\n          break;\n        default:\n          LOG.debug(\"Unexpected Rmnode state\");\n        }\n        this.rmContext.getDispatcher().getEventHandler()\n            .handle(new NodeRemovedSchedulerEvent(rmNode));\n\n        this.rmContext.getRMNodes().put(nodeId, rmNode);\n        this.rmContext.getDispatcher().getEventHandler()\n            .handle(new RMNodeStartedEvent(nodeId, null, null));\n      } else {\n        // Reset heartbeat ID since node just restarted.\n        oldNode.resetLastNodeHeartBeatResponse();\n\n        this.rmContext.getDispatcher().getEventHandler()\n            .handle(new RMNodeReconnectEvent(nodeId, rmNode,\n                request.getRunningApplications(),\n                request.getNMContainerStatuses()));\n      }\n    }\n    // On every node manager register we will be clearing NMToken keys if\n    // present for any running application.\n    this.nmTokenSecretManager.removeNodeKey(nodeId);\n    this.nmLivelinessMonitor.register(nodeId);\n    \n    // Handle received container status, this should be processed after new\n    // RMNode inserted\n    if (!rmContext.isWorkPreservingRecoveryEnabled()) {\n      if (!request.getNMContainerStatuses().isEmpty()) {\n        LOG.info(\"received container statuses on node manager register :\"\n            + request.getNMContainerStatuses());\n        for (NMContainerStatus status : request.getNMContainerStatuses()) {\n          handleNMContainerStatus(status, nodeId);\n        }\n      }\n    }\n\n    // Update node\u0027s labels to RM\u0027s NodeLabelManager.\n    Set\u003cString\u003e nodeLabels \u003d NodeLabelsUtils.convertToStringSet(\n        request.getNodeLabels());\n    if (isDistributedNodeLabelsConf \u0026\u0026 nodeLabels !\u003d null) {\n      try {\n        updateNodeLabelsFromNMReport(nodeLabels, nodeId);\n        response.setAreNodeLabelsAcceptedByRM(true);\n      } catch (IOException ex) {\n        // Ensure the exception is captured in the response\n        response.setDiagnosticsMessage(ex.getMessage());\n        response.setAreNodeLabelsAcceptedByRM(false);\n      }\n    } else if (isDelegatedCentralizedNodeLabelsConf) {\n      this.rmContext.getRMDelegatedNodeLabelsUpdater().updateNodeLabels(nodeId);\n    }\n\n    StringBuilder message \u003d new StringBuilder();\n    message.append(\"NodeManager from node \").append(host).append(\"(cmPort: \")\n        .append(cmPort).append(\" httpPort: \");\n    message.append(httpPort).append(\") \")\n        .append(\"registered with capability: \").append(capability);\n    message.append(\", assigned nodeId \").append(nodeId);\n    if (response.getAreNodeLabelsAcceptedByRM()) {\n      message.append(\", node labels { \").append(\n          StringUtils.join(\",\", nodeLabels) + \" } \");\n    }\n\n    LOG.info(message.toString());\n    response.setNodeAction(NodeAction.NORMAL);\n    response.setRMIdentifier(ResourceManager.getClusterTimeStamp());\n    response.setRMVersion(YarnVersionInfo.getVersion());\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "4bf622043f034835d65ff2a4785b9b06d0ef1fd2": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7952. RM should be able to recover log aggregation status after restart/fail-over. (Xuan Gong via wangda)\n\nChange-Id: I725c9afe64831eda0aa6b0bebdbc79d2dd165707\n",
      "commitDate": "15/03/18 1:26 PM",
      "commitName": "4bf622043f034835d65ff2a4785b9b06d0ef1fd2",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "07/03/18 3:46 PM",
      "commitNameOld": "e718ac597f2225cb4946e1ac4b3986c336645643",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 7.86,
      "commitsBetweenForRepo": 74,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,172 +1,183 @@\n   public RegisterNodeManagerResponse registerNodeManager(\n       RegisterNodeManagerRequest request) throws YarnException,\n       IOException {\n     NodeId nodeId \u003d request.getNodeId();\n     String host \u003d nodeId.getHost();\n     int cmPort \u003d nodeId.getPort();\n     int httpPort \u003d request.getHttpPort();\n     Resource capability \u003d request.getResource();\n     String nodeManagerVersion \u003d request.getNMVersion();\n     Resource physicalResource \u003d request.getPhysicalResource();\n \n     RegisterNodeManagerResponse response \u003d recordFactory\n         .newRecordInstance(RegisterNodeManagerResponse.class);\n \n     if (!minimumNodeManagerVersion.equals(\"NONE\")) {\n       if (minimumNodeManagerVersion.equals(\"EqualToRM\")) {\n         minimumNodeManagerVersion \u003d YarnVersionInfo.getVersion();\n       }\n \n       if ((nodeManagerVersion \u003d\u003d null) ||\n           (VersionUtil.compareVersions(nodeManagerVersion,minimumNodeManagerVersion)) \u003c 0) {\n         String message \u003d\n             \"Disallowed NodeManager Version \" + nodeManagerVersion\n                 + \", is less than the minimum version \"\n                 + minimumNodeManagerVersion + \" sending SHUTDOWN signal to \"\n                 + \"NodeManager.\";\n         LOG.info(message);\n         response.setDiagnosticsMessage(message);\n         response.setNodeAction(NodeAction.SHUTDOWN);\n         return response;\n       }\n     }\n \n     // Check if this node is a \u0027valid\u0027 node\n     if (!this.nodesListManager.isValidNode(host) \u0026\u0026\n         !isNodeInDecommissioning(nodeId)) {\n       String message \u003d\n           \"Disallowed NodeManager from  \" + host\n               + \", Sending SHUTDOWN signal to the NodeManager.\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     // check if node\u0027s capacity is load from dynamic-resources.xml\n     String nid \u003d nodeId.toString();\n \n     Resource dynamicLoadCapability \u003d loadNodeResourceFromDRConfiguration(nid);\n     if (dynamicLoadCapability !\u003d null) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Resource for node: \" + nid + \" is adjusted from: \" +\n             capability + \" to: \" + dynamicLoadCapability +\n             \" due to settings in dynamic-resources.xml.\");\n       }\n       capability \u003d dynamicLoadCapability;\n       // sync back with new resource.\n       response.setResource(capability);\n     }\n \n     // Check if this node has minimum allocations\n     if (capability.getMemorySize() \u003c minAllocMb\n         || capability.getVirtualCores() \u003c minAllocVcores) {\n       String message \u003d \"NodeManager from  \" + host\n           + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n           + \" signal to the NodeManager. Node capabilities are \" + capability\n           + \"; minimums are \" + minAllocMb + \"mb and \" + minAllocVcores\n           + \" vcores\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     response.setContainerTokenMasterKey(containerTokenSecretManager\n         .getCurrentKey());\n     response.setNMTokenMasterKey(nmTokenSecretManager\n         .getCurrentKey());\n \n     RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n         resolve(host), capability, nodeManagerVersion, physicalResource);\n \n     RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n     if (oldNode \u003d\u003d null) {\n+      RMNodeStartedEvent startEvent \u003d new RMNodeStartedEvent(nodeId,\n+          request.getNMContainerStatuses(),\n+          request.getRunningApplications());\n+      if (request.getLogAggregationReportsForApps() !\u003d null\n+          \u0026\u0026 !request.getLogAggregationReportsForApps().isEmpty()) {\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"Found the number of previous cached log aggregation \"\n+              + \"status from nodemanager:\" + nodeId + \" is :\"\n+              + request.getLogAggregationReportsForApps().size());\n+        }\n+        startEvent.setLogAggregationReportsForApps(request\n+            .getLogAggregationReportsForApps());\n+      }\n       this.rmContext.getDispatcher().getEventHandler().handle(\n-              new RMNodeStartedEvent(nodeId, request.getNMContainerStatuses(),\n-                  request.getRunningApplications()));\n+          startEvent);\n     } else {\n       LOG.info(\"Reconnect from the node at: \" + host);\n       this.nmLivelinessMonitor.unregister(nodeId);\n \n       if (CollectionUtils.isEmpty(request.getRunningApplications())\n           \u0026\u0026 rmNode.getState() !\u003d NodeState.DECOMMISSIONING\n           \u0026\u0026 rmNode.getHttpPort() !\u003d oldNode.getHttpPort()) {\n         // Reconnected node differs, so replace old node and start new node\n         switch (rmNode.getState()) {\n         case RUNNING:\n           ClusterMetrics.getMetrics().decrNumActiveNodes();\n           break;\n         case UNHEALTHY:\n           ClusterMetrics.getMetrics().decrNumUnhealthyNMs();\n           break;\n         default:\n           LOG.debug(\"Unexpected Rmnode state\");\n         }\n         this.rmContext.getDispatcher().getEventHandler()\n             .handle(new NodeRemovedSchedulerEvent(rmNode));\n \n         this.rmContext.getRMNodes().put(nodeId, rmNode);\n         this.rmContext.getDispatcher().getEventHandler()\n             .handle(new RMNodeStartedEvent(nodeId, null, null));\n-\n       } else {\n         // Reset heartbeat ID since node just restarted.\n         oldNode.resetLastNodeHeartBeatResponse();\n \n         this.rmContext.getDispatcher().getEventHandler()\n             .handle(new RMNodeReconnectEvent(nodeId, rmNode,\n                 request.getRunningApplications(),\n                 request.getNMContainerStatuses()));\n       }\n     }\n     // On every node manager register we will be clearing NMToken keys if\n     // present for any running application.\n     this.nmTokenSecretManager.removeNodeKey(nodeId);\n     this.nmLivelinessMonitor.register(nodeId);\n     \n     // Handle received container status, this should be processed after new\n     // RMNode inserted\n     if (!rmContext.isWorkPreservingRecoveryEnabled()) {\n       if (!request.getNMContainerStatuses().isEmpty()) {\n         LOG.info(\"received container statuses on node manager register :\"\n             + request.getNMContainerStatuses());\n         for (NMContainerStatus status : request.getNMContainerStatuses()) {\n           handleNMContainerStatus(status, nodeId);\n         }\n       }\n     }\n \n     // Update node\u0027s labels to RM\u0027s NodeLabelManager.\n     Set\u003cString\u003e nodeLabels \u003d NodeLabelsUtils.convertToStringSet(\n         request.getNodeLabels());\n     if (isDistributedNodeLabelsConf \u0026\u0026 nodeLabels !\u003d null) {\n       try {\n         updateNodeLabelsFromNMReport(nodeLabels, nodeId);\n         response.setAreNodeLabelsAcceptedByRM(true);\n       } catch (IOException ex) {\n         // Ensure the exception is captured in the response\n         response.setDiagnosticsMessage(ex.getMessage());\n         response.setAreNodeLabelsAcceptedByRM(false);\n       }\n     } else if (isDelegatedCentralizedNodeLabelsConf) {\n       this.rmContext.getRMDelegatedNodeLabelsUpdater().updateNodeLabels(nodeId);\n     }\n \n     StringBuilder message \u003d new StringBuilder();\n     message.append(\"NodeManager from node \").append(host).append(\"(cmPort: \")\n         .append(cmPort).append(\" httpPort: \");\n     message.append(httpPort).append(\") \")\n         .append(\"registered with capability: \").append(capability);\n     message.append(\", assigned nodeId \").append(nodeId);\n     if (response.getAreNodeLabelsAcceptedByRM()) {\n       message.append(\", node labels { \").append(\n           StringUtils.join(\",\", nodeLabels) + \" } \");\n     }\n \n     LOG.info(message.toString());\n     response.setNodeAction(NodeAction.NORMAL);\n     response.setRMIdentifier(ResourceManager.getClusterTimeStamp());\n     response.setRMVersion(YarnVersionInfo.getVersion());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterNodeManagerResponse registerNodeManager(\n      RegisterNodeManagerRequest request) throws YarnException,\n      IOException {\n    NodeId nodeId \u003d request.getNodeId();\n    String host \u003d nodeId.getHost();\n    int cmPort \u003d nodeId.getPort();\n    int httpPort \u003d request.getHttpPort();\n    Resource capability \u003d request.getResource();\n    String nodeManagerVersion \u003d request.getNMVersion();\n    Resource physicalResource \u003d request.getPhysicalResource();\n\n    RegisterNodeManagerResponse response \u003d recordFactory\n        .newRecordInstance(RegisterNodeManagerResponse.class);\n\n    if (!minimumNodeManagerVersion.equals(\"NONE\")) {\n      if (minimumNodeManagerVersion.equals(\"EqualToRM\")) {\n        minimumNodeManagerVersion \u003d YarnVersionInfo.getVersion();\n      }\n\n      if ((nodeManagerVersion \u003d\u003d null) ||\n          (VersionUtil.compareVersions(nodeManagerVersion,minimumNodeManagerVersion)) \u003c 0) {\n        String message \u003d\n            \"Disallowed NodeManager Version \" + nodeManagerVersion\n                + \", is less than the minimum version \"\n                + minimumNodeManagerVersion + \" sending SHUTDOWN signal to \"\n                + \"NodeManager.\";\n        LOG.info(message);\n        response.setDiagnosticsMessage(message);\n        response.setNodeAction(NodeAction.SHUTDOWN);\n        return response;\n      }\n    }\n\n    // Check if this node is a \u0027valid\u0027 node\n    if (!this.nodesListManager.isValidNode(host) \u0026\u0026\n        !isNodeInDecommissioning(nodeId)) {\n      String message \u003d\n          \"Disallowed NodeManager from  \" + host\n              + \", Sending SHUTDOWN signal to the NodeManager.\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    // check if node\u0027s capacity is load from dynamic-resources.xml\n    String nid \u003d nodeId.toString();\n\n    Resource dynamicLoadCapability \u003d loadNodeResourceFromDRConfiguration(nid);\n    if (dynamicLoadCapability !\u003d null) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Resource for node: \" + nid + \" is adjusted from: \" +\n            capability + \" to: \" + dynamicLoadCapability +\n            \" due to settings in dynamic-resources.xml.\");\n      }\n      capability \u003d dynamicLoadCapability;\n      // sync back with new resource.\n      response.setResource(capability);\n    }\n\n    // Check if this node has minimum allocations\n    if (capability.getMemorySize() \u003c minAllocMb\n        || capability.getVirtualCores() \u003c minAllocVcores) {\n      String message \u003d \"NodeManager from  \" + host\n          + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n          + \" signal to the NodeManager. Node capabilities are \" + capability\n          + \"; minimums are \" + minAllocMb + \"mb and \" + minAllocVcores\n          + \" vcores\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    response.setContainerTokenMasterKey(containerTokenSecretManager\n        .getCurrentKey());\n    response.setNMTokenMasterKey(nmTokenSecretManager\n        .getCurrentKey());\n\n    RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n        resolve(host), capability, nodeManagerVersion, physicalResource);\n\n    RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n    if (oldNode \u003d\u003d null) {\n      RMNodeStartedEvent startEvent \u003d new RMNodeStartedEvent(nodeId,\n          request.getNMContainerStatuses(),\n          request.getRunningApplications());\n      if (request.getLogAggregationReportsForApps() !\u003d null\n          \u0026\u0026 !request.getLogAggregationReportsForApps().isEmpty()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Found the number of previous cached log aggregation \"\n              + \"status from nodemanager:\" + nodeId + \" is :\"\n              + request.getLogAggregationReportsForApps().size());\n        }\n        startEvent.setLogAggregationReportsForApps(request\n            .getLogAggregationReportsForApps());\n      }\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          startEvent);\n    } else {\n      LOG.info(\"Reconnect from the node at: \" + host);\n      this.nmLivelinessMonitor.unregister(nodeId);\n\n      if (CollectionUtils.isEmpty(request.getRunningApplications())\n          \u0026\u0026 rmNode.getState() !\u003d NodeState.DECOMMISSIONING\n          \u0026\u0026 rmNode.getHttpPort() !\u003d oldNode.getHttpPort()) {\n        // Reconnected node differs, so replace old node and start new node\n        switch (rmNode.getState()) {\n        case RUNNING:\n          ClusterMetrics.getMetrics().decrNumActiveNodes();\n          break;\n        case UNHEALTHY:\n          ClusterMetrics.getMetrics().decrNumUnhealthyNMs();\n          break;\n        default:\n          LOG.debug(\"Unexpected Rmnode state\");\n        }\n        this.rmContext.getDispatcher().getEventHandler()\n            .handle(new NodeRemovedSchedulerEvent(rmNode));\n\n        this.rmContext.getRMNodes().put(nodeId, rmNode);\n        this.rmContext.getDispatcher().getEventHandler()\n            .handle(new RMNodeStartedEvent(nodeId, null, null));\n      } else {\n        // Reset heartbeat ID since node just restarted.\n        oldNode.resetLastNodeHeartBeatResponse();\n\n        this.rmContext.getDispatcher().getEventHandler()\n            .handle(new RMNodeReconnectEvent(nodeId, rmNode,\n                request.getRunningApplications(),\n                request.getNMContainerStatuses()));\n      }\n    }\n    // On every node manager register we will be clearing NMToken keys if\n    // present for any running application.\n    this.nmTokenSecretManager.removeNodeKey(nodeId);\n    this.nmLivelinessMonitor.register(nodeId);\n    \n    // Handle received container status, this should be processed after new\n    // RMNode inserted\n    if (!rmContext.isWorkPreservingRecoveryEnabled()) {\n      if (!request.getNMContainerStatuses().isEmpty()) {\n        LOG.info(\"received container statuses on node manager register :\"\n            + request.getNMContainerStatuses());\n        for (NMContainerStatus status : request.getNMContainerStatuses()) {\n          handleNMContainerStatus(status, nodeId);\n        }\n      }\n    }\n\n    // Update node\u0027s labels to RM\u0027s NodeLabelManager.\n    Set\u003cString\u003e nodeLabels \u003d NodeLabelsUtils.convertToStringSet(\n        request.getNodeLabels());\n    if (isDistributedNodeLabelsConf \u0026\u0026 nodeLabels !\u003d null) {\n      try {\n        updateNodeLabelsFromNMReport(nodeLabels, nodeId);\n        response.setAreNodeLabelsAcceptedByRM(true);\n      } catch (IOException ex) {\n        // Ensure the exception is captured in the response\n        response.setDiagnosticsMessage(ex.getMessage());\n        response.setAreNodeLabelsAcceptedByRM(false);\n      }\n    } else if (isDelegatedCentralizedNodeLabelsConf) {\n      this.rmContext.getRMDelegatedNodeLabelsUpdater().updateNodeLabels(nodeId);\n    }\n\n    StringBuilder message \u003d new StringBuilder();\n    message.append(\"NodeManager from node \").append(host).append(\"(cmPort: \")\n        .append(cmPort).append(\" httpPort: \");\n    message.append(httpPort).append(\") \")\n        .append(\"registered with capability: \").append(capability);\n    message.append(\", assigned nodeId \").append(nodeId);\n    if (response.getAreNodeLabelsAcceptedByRM()) {\n      message.append(\", node labels { \").append(\n          StringUtils.join(\",\", nodeLabels) + \" } \");\n    }\n\n    LOG.info(message.toString());\n    response.setNodeAction(NodeAction.NORMAL);\n    response.setRMIdentifier(ResourceManager.getClusterTimeStamp());\n    response.setRMVersion(YarnVersionInfo.getVersion());\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "e718ac597f2225cb4946e1ac4b3986c336645643": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"YARN-7891. LogAggregationIndexedFileController should support read from HAR file. (Xuan Gong via wangda)\"\n\nThis reverts commit 4d53ef7eefb14661d824924e503a910de1ae997f.\n",
      "commitDate": "07/03/18 3:46 PM",
      "commitName": "e718ac597f2225cb4946e1ac4b3986c336645643",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "07/03/18 11:30 AM",
      "commitNameOld": "4d53ef7eefb14661d824924e503a910de1ae997f",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 0.18,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,183 +1,172 @@\n   public RegisterNodeManagerResponse registerNodeManager(\n       RegisterNodeManagerRequest request) throws YarnException,\n       IOException {\n     NodeId nodeId \u003d request.getNodeId();\n     String host \u003d nodeId.getHost();\n     int cmPort \u003d nodeId.getPort();\n     int httpPort \u003d request.getHttpPort();\n     Resource capability \u003d request.getResource();\n     String nodeManagerVersion \u003d request.getNMVersion();\n     Resource physicalResource \u003d request.getPhysicalResource();\n \n     RegisterNodeManagerResponse response \u003d recordFactory\n         .newRecordInstance(RegisterNodeManagerResponse.class);\n \n     if (!minimumNodeManagerVersion.equals(\"NONE\")) {\n       if (minimumNodeManagerVersion.equals(\"EqualToRM\")) {\n         minimumNodeManagerVersion \u003d YarnVersionInfo.getVersion();\n       }\n \n       if ((nodeManagerVersion \u003d\u003d null) ||\n           (VersionUtil.compareVersions(nodeManagerVersion,minimumNodeManagerVersion)) \u003c 0) {\n         String message \u003d\n             \"Disallowed NodeManager Version \" + nodeManagerVersion\n                 + \", is less than the minimum version \"\n                 + minimumNodeManagerVersion + \" sending SHUTDOWN signal to \"\n                 + \"NodeManager.\";\n         LOG.info(message);\n         response.setDiagnosticsMessage(message);\n         response.setNodeAction(NodeAction.SHUTDOWN);\n         return response;\n       }\n     }\n \n     // Check if this node is a \u0027valid\u0027 node\n     if (!this.nodesListManager.isValidNode(host) \u0026\u0026\n         !isNodeInDecommissioning(nodeId)) {\n       String message \u003d\n           \"Disallowed NodeManager from  \" + host\n               + \", Sending SHUTDOWN signal to the NodeManager.\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     // check if node\u0027s capacity is load from dynamic-resources.xml\n     String nid \u003d nodeId.toString();\n \n     Resource dynamicLoadCapability \u003d loadNodeResourceFromDRConfiguration(nid);\n     if (dynamicLoadCapability !\u003d null) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Resource for node: \" + nid + \" is adjusted from: \" +\n             capability + \" to: \" + dynamicLoadCapability +\n             \" due to settings in dynamic-resources.xml.\");\n       }\n       capability \u003d dynamicLoadCapability;\n       // sync back with new resource.\n       response.setResource(capability);\n     }\n \n     // Check if this node has minimum allocations\n     if (capability.getMemorySize() \u003c minAllocMb\n         || capability.getVirtualCores() \u003c minAllocVcores) {\n       String message \u003d \"NodeManager from  \" + host\n           + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n           + \" signal to the NodeManager. Node capabilities are \" + capability\n           + \"; minimums are \" + minAllocMb + \"mb and \" + minAllocVcores\n           + \" vcores\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     response.setContainerTokenMasterKey(containerTokenSecretManager\n         .getCurrentKey());\n     response.setNMTokenMasterKey(nmTokenSecretManager\n         .getCurrentKey());\n \n     RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n         resolve(host), capability, nodeManagerVersion, physicalResource);\n \n     RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n     if (oldNode \u003d\u003d null) {\n-      RMNodeStartedEvent startEvent \u003d new RMNodeStartedEvent(nodeId,\n-          request.getNMContainerStatuses(),\n-          request.getRunningApplications());\n-      if (request.getLogAggregationReportsForApps() !\u003d null\n-          \u0026\u0026 !request.getLogAggregationReportsForApps().isEmpty()) {\n-        if (LOG.isDebugEnabled()) {\n-          LOG.debug(\"Found the number of previous cached log aggregation \"\n-              + \"status from nodemanager:\" + nodeId + \" is :\"\n-              + request.getLogAggregationReportsForApps().size());\n-        }\n-        startEvent.setLogAggregationReportsForApps(request\n-            .getLogAggregationReportsForApps());\n-      }\n       this.rmContext.getDispatcher().getEventHandler().handle(\n-          startEvent);\n+              new RMNodeStartedEvent(nodeId, request.getNMContainerStatuses(),\n+                  request.getRunningApplications()));\n     } else {\n       LOG.info(\"Reconnect from the node at: \" + host);\n       this.nmLivelinessMonitor.unregister(nodeId);\n \n       if (CollectionUtils.isEmpty(request.getRunningApplications())\n           \u0026\u0026 rmNode.getState() !\u003d NodeState.DECOMMISSIONING\n           \u0026\u0026 rmNode.getHttpPort() !\u003d oldNode.getHttpPort()) {\n         // Reconnected node differs, so replace old node and start new node\n         switch (rmNode.getState()) {\n         case RUNNING:\n           ClusterMetrics.getMetrics().decrNumActiveNodes();\n           break;\n         case UNHEALTHY:\n           ClusterMetrics.getMetrics().decrNumUnhealthyNMs();\n           break;\n         default:\n           LOG.debug(\"Unexpected Rmnode state\");\n         }\n         this.rmContext.getDispatcher().getEventHandler()\n             .handle(new NodeRemovedSchedulerEvent(rmNode));\n \n         this.rmContext.getRMNodes().put(nodeId, rmNode);\n         this.rmContext.getDispatcher().getEventHandler()\n             .handle(new RMNodeStartedEvent(nodeId, null, null));\n+\n       } else {\n         // Reset heartbeat ID since node just restarted.\n         oldNode.resetLastNodeHeartBeatResponse();\n \n         this.rmContext.getDispatcher().getEventHandler()\n             .handle(new RMNodeReconnectEvent(nodeId, rmNode,\n                 request.getRunningApplications(),\n                 request.getNMContainerStatuses()));\n       }\n     }\n     // On every node manager register we will be clearing NMToken keys if\n     // present for any running application.\n     this.nmTokenSecretManager.removeNodeKey(nodeId);\n     this.nmLivelinessMonitor.register(nodeId);\n     \n     // Handle received container status, this should be processed after new\n     // RMNode inserted\n     if (!rmContext.isWorkPreservingRecoveryEnabled()) {\n       if (!request.getNMContainerStatuses().isEmpty()) {\n         LOG.info(\"received container statuses on node manager register :\"\n             + request.getNMContainerStatuses());\n         for (NMContainerStatus status : request.getNMContainerStatuses()) {\n           handleNMContainerStatus(status, nodeId);\n         }\n       }\n     }\n \n     // Update node\u0027s labels to RM\u0027s NodeLabelManager.\n     Set\u003cString\u003e nodeLabels \u003d NodeLabelsUtils.convertToStringSet(\n         request.getNodeLabels());\n     if (isDistributedNodeLabelsConf \u0026\u0026 nodeLabels !\u003d null) {\n       try {\n         updateNodeLabelsFromNMReport(nodeLabels, nodeId);\n         response.setAreNodeLabelsAcceptedByRM(true);\n       } catch (IOException ex) {\n         // Ensure the exception is captured in the response\n         response.setDiagnosticsMessage(ex.getMessage());\n         response.setAreNodeLabelsAcceptedByRM(false);\n       }\n     } else if (isDelegatedCentralizedNodeLabelsConf) {\n       this.rmContext.getRMDelegatedNodeLabelsUpdater().updateNodeLabels(nodeId);\n     }\n \n     StringBuilder message \u003d new StringBuilder();\n     message.append(\"NodeManager from node \").append(host).append(\"(cmPort: \")\n         .append(cmPort).append(\" httpPort: \");\n     message.append(httpPort).append(\") \")\n         .append(\"registered with capability: \").append(capability);\n     message.append(\", assigned nodeId \").append(nodeId);\n     if (response.getAreNodeLabelsAcceptedByRM()) {\n       message.append(\", node labels { \").append(\n           StringUtils.join(\",\", nodeLabels) + \" } \");\n     }\n \n     LOG.info(message.toString());\n     response.setNodeAction(NodeAction.NORMAL);\n     response.setRMIdentifier(ResourceManager.getClusterTimeStamp());\n     response.setRMVersion(YarnVersionInfo.getVersion());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterNodeManagerResponse registerNodeManager(\n      RegisterNodeManagerRequest request) throws YarnException,\n      IOException {\n    NodeId nodeId \u003d request.getNodeId();\n    String host \u003d nodeId.getHost();\n    int cmPort \u003d nodeId.getPort();\n    int httpPort \u003d request.getHttpPort();\n    Resource capability \u003d request.getResource();\n    String nodeManagerVersion \u003d request.getNMVersion();\n    Resource physicalResource \u003d request.getPhysicalResource();\n\n    RegisterNodeManagerResponse response \u003d recordFactory\n        .newRecordInstance(RegisterNodeManagerResponse.class);\n\n    if (!minimumNodeManagerVersion.equals(\"NONE\")) {\n      if (minimumNodeManagerVersion.equals(\"EqualToRM\")) {\n        minimumNodeManagerVersion \u003d YarnVersionInfo.getVersion();\n      }\n\n      if ((nodeManagerVersion \u003d\u003d null) ||\n          (VersionUtil.compareVersions(nodeManagerVersion,minimumNodeManagerVersion)) \u003c 0) {\n        String message \u003d\n            \"Disallowed NodeManager Version \" + nodeManagerVersion\n                + \", is less than the minimum version \"\n                + minimumNodeManagerVersion + \" sending SHUTDOWN signal to \"\n                + \"NodeManager.\";\n        LOG.info(message);\n        response.setDiagnosticsMessage(message);\n        response.setNodeAction(NodeAction.SHUTDOWN);\n        return response;\n      }\n    }\n\n    // Check if this node is a \u0027valid\u0027 node\n    if (!this.nodesListManager.isValidNode(host) \u0026\u0026\n        !isNodeInDecommissioning(nodeId)) {\n      String message \u003d\n          \"Disallowed NodeManager from  \" + host\n              + \", Sending SHUTDOWN signal to the NodeManager.\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    // check if node\u0027s capacity is load from dynamic-resources.xml\n    String nid \u003d nodeId.toString();\n\n    Resource dynamicLoadCapability \u003d loadNodeResourceFromDRConfiguration(nid);\n    if (dynamicLoadCapability !\u003d null) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Resource for node: \" + nid + \" is adjusted from: \" +\n            capability + \" to: \" + dynamicLoadCapability +\n            \" due to settings in dynamic-resources.xml.\");\n      }\n      capability \u003d dynamicLoadCapability;\n      // sync back with new resource.\n      response.setResource(capability);\n    }\n\n    // Check if this node has minimum allocations\n    if (capability.getMemorySize() \u003c minAllocMb\n        || capability.getVirtualCores() \u003c minAllocVcores) {\n      String message \u003d \"NodeManager from  \" + host\n          + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n          + \" signal to the NodeManager. Node capabilities are \" + capability\n          + \"; minimums are \" + minAllocMb + \"mb and \" + minAllocVcores\n          + \" vcores\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    response.setContainerTokenMasterKey(containerTokenSecretManager\n        .getCurrentKey());\n    response.setNMTokenMasterKey(nmTokenSecretManager\n        .getCurrentKey());\n\n    RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n        resolve(host), capability, nodeManagerVersion, physicalResource);\n\n    RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n    if (oldNode \u003d\u003d null) {\n      this.rmContext.getDispatcher().getEventHandler().handle(\n              new RMNodeStartedEvent(nodeId, request.getNMContainerStatuses(),\n                  request.getRunningApplications()));\n    } else {\n      LOG.info(\"Reconnect from the node at: \" + host);\n      this.nmLivelinessMonitor.unregister(nodeId);\n\n      if (CollectionUtils.isEmpty(request.getRunningApplications())\n          \u0026\u0026 rmNode.getState() !\u003d NodeState.DECOMMISSIONING\n          \u0026\u0026 rmNode.getHttpPort() !\u003d oldNode.getHttpPort()) {\n        // Reconnected node differs, so replace old node and start new node\n        switch (rmNode.getState()) {\n        case RUNNING:\n          ClusterMetrics.getMetrics().decrNumActiveNodes();\n          break;\n        case UNHEALTHY:\n          ClusterMetrics.getMetrics().decrNumUnhealthyNMs();\n          break;\n        default:\n          LOG.debug(\"Unexpected Rmnode state\");\n        }\n        this.rmContext.getDispatcher().getEventHandler()\n            .handle(new NodeRemovedSchedulerEvent(rmNode));\n\n        this.rmContext.getRMNodes().put(nodeId, rmNode);\n        this.rmContext.getDispatcher().getEventHandler()\n            .handle(new RMNodeStartedEvent(nodeId, null, null));\n\n      } else {\n        // Reset heartbeat ID since node just restarted.\n        oldNode.resetLastNodeHeartBeatResponse();\n\n        this.rmContext.getDispatcher().getEventHandler()\n            .handle(new RMNodeReconnectEvent(nodeId, rmNode,\n                request.getRunningApplications(),\n                request.getNMContainerStatuses()));\n      }\n    }\n    // On every node manager register we will be clearing NMToken keys if\n    // present for any running application.\n    this.nmTokenSecretManager.removeNodeKey(nodeId);\n    this.nmLivelinessMonitor.register(nodeId);\n    \n    // Handle received container status, this should be processed after new\n    // RMNode inserted\n    if (!rmContext.isWorkPreservingRecoveryEnabled()) {\n      if (!request.getNMContainerStatuses().isEmpty()) {\n        LOG.info(\"received container statuses on node manager register :\"\n            + request.getNMContainerStatuses());\n        for (NMContainerStatus status : request.getNMContainerStatuses()) {\n          handleNMContainerStatus(status, nodeId);\n        }\n      }\n    }\n\n    // Update node\u0027s labels to RM\u0027s NodeLabelManager.\n    Set\u003cString\u003e nodeLabels \u003d NodeLabelsUtils.convertToStringSet(\n        request.getNodeLabels());\n    if (isDistributedNodeLabelsConf \u0026\u0026 nodeLabels !\u003d null) {\n      try {\n        updateNodeLabelsFromNMReport(nodeLabels, nodeId);\n        response.setAreNodeLabelsAcceptedByRM(true);\n      } catch (IOException ex) {\n        // Ensure the exception is captured in the response\n        response.setDiagnosticsMessage(ex.getMessage());\n        response.setAreNodeLabelsAcceptedByRM(false);\n      }\n    } else if (isDelegatedCentralizedNodeLabelsConf) {\n      this.rmContext.getRMDelegatedNodeLabelsUpdater().updateNodeLabels(nodeId);\n    }\n\n    StringBuilder message \u003d new StringBuilder();\n    message.append(\"NodeManager from node \").append(host).append(\"(cmPort: \")\n        .append(cmPort).append(\" httpPort: \");\n    message.append(httpPort).append(\") \")\n        .append(\"registered with capability: \").append(capability);\n    message.append(\", assigned nodeId \").append(nodeId);\n    if (response.getAreNodeLabelsAcceptedByRM()) {\n      message.append(\", node labels { \").append(\n          StringUtils.join(\",\", nodeLabels) + \" } \");\n    }\n\n    LOG.info(message.toString());\n    response.setNodeAction(NodeAction.NORMAL);\n    response.setRMIdentifier(ResourceManager.getClusterTimeStamp());\n    response.setRMVersion(YarnVersionInfo.getVersion());\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "4d53ef7eefb14661d824924e503a910de1ae997f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7891. LogAggregationIndexedFileController should support read from HAR file. (Xuan Gong via wangda)\n\nChange-Id: Ie16e34039d57df50128c73b37516ad0bc7c9590e\n",
      "commitDate": "07/03/18 11:30 AM",
      "commitName": "4d53ef7eefb14661d824924e503a910de1ae997f",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "25/01/18 3:47 PM",
      "commitNameOld": "ff8378eb1b960c72d18a984c7e5d145b407ca11a",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 40.82,
      "commitsBetweenForRepo": 273,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,172 +1,183 @@\n   public RegisterNodeManagerResponse registerNodeManager(\n       RegisterNodeManagerRequest request) throws YarnException,\n       IOException {\n     NodeId nodeId \u003d request.getNodeId();\n     String host \u003d nodeId.getHost();\n     int cmPort \u003d nodeId.getPort();\n     int httpPort \u003d request.getHttpPort();\n     Resource capability \u003d request.getResource();\n     String nodeManagerVersion \u003d request.getNMVersion();\n     Resource physicalResource \u003d request.getPhysicalResource();\n \n     RegisterNodeManagerResponse response \u003d recordFactory\n         .newRecordInstance(RegisterNodeManagerResponse.class);\n \n     if (!minimumNodeManagerVersion.equals(\"NONE\")) {\n       if (minimumNodeManagerVersion.equals(\"EqualToRM\")) {\n         minimumNodeManagerVersion \u003d YarnVersionInfo.getVersion();\n       }\n \n       if ((nodeManagerVersion \u003d\u003d null) ||\n           (VersionUtil.compareVersions(nodeManagerVersion,minimumNodeManagerVersion)) \u003c 0) {\n         String message \u003d\n             \"Disallowed NodeManager Version \" + nodeManagerVersion\n                 + \", is less than the minimum version \"\n                 + minimumNodeManagerVersion + \" sending SHUTDOWN signal to \"\n                 + \"NodeManager.\";\n         LOG.info(message);\n         response.setDiagnosticsMessage(message);\n         response.setNodeAction(NodeAction.SHUTDOWN);\n         return response;\n       }\n     }\n \n     // Check if this node is a \u0027valid\u0027 node\n     if (!this.nodesListManager.isValidNode(host) \u0026\u0026\n         !isNodeInDecommissioning(nodeId)) {\n       String message \u003d\n           \"Disallowed NodeManager from  \" + host\n               + \", Sending SHUTDOWN signal to the NodeManager.\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     // check if node\u0027s capacity is load from dynamic-resources.xml\n     String nid \u003d nodeId.toString();\n \n     Resource dynamicLoadCapability \u003d loadNodeResourceFromDRConfiguration(nid);\n     if (dynamicLoadCapability !\u003d null) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Resource for node: \" + nid + \" is adjusted from: \" +\n             capability + \" to: \" + dynamicLoadCapability +\n             \" due to settings in dynamic-resources.xml.\");\n       }\n       capability \u003d dynamicLoadCapability;\n       // sync back with new resource.\n       response.setResource(capability);\n     }\n \n     // Check if this node has minimum allocations\n     if (capability.getMemorySize() \u003c minAllocMb\n         || capability.getVirtualCores() \u003c minAllocVcores) {\n       String message \u003d \"NodeManager from  \" + host\n           + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n           + \" signal to the NodeManager. Node capabilities are \" + capability\n           + \"; minimums are \" + minAllocMb + \"mb and \" + minAllocVcores\n           + \" vcores\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     response.setContainerTokenMasterKey(containerTokenSecretManager\n         .getCurrentKey());\n     response.setNMTokenMasterKey(nmTokenSecretManager\n         .getCurrentKey());\n \n     RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n         resolve(host), capability, nodeManagerVersion, physicalResource);\n \n     RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n     if (oldNode \u003d\u003d null) {\n+      RMNodeStartedEvent startEvent \u003d new RMNodeStartedEvent(nodeId,\n+          request.getNMContainerStatuses(),\n+          request.getRunningApplications());\n+      if (request.getLogAggregationReportsForApps() !\u003d null\n+          \u0026\u0026 !request.getLogAggregationReportsForApps().isEmpty()) {\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"Found the number of previous cached log aggregation \"\n+              + \"status from nodemanager:\" + nodeId + \" is :\"\n+              + request.getLogAggregationReportsForApps().size());\n+        }\n+        startEvent.setLogAggregationReportsForApps(request\n+            .getLogAggregationReportsForApps());\n+      }\n       this.rmContext.getDispatcher().getEventHandler().handle(\n-              new RMNodeStartedEvent(nodeId, request.getNMContainerStatuses(),\n-                  request.getRunningApplications()));\n+          startEvent);\n     } else {\n       LOG.info(\"Reconnect from the node at: \" + host);\n       this.nmLivelinessMonitor.unregister(nodeId);\n \n       if (CollectionUtils.isEmpty(request.getRunningApplications())\n           \u0026\u0026 rmNode.getState() !\u003d NodeState.DECOMMISSIONING\n           \u0026\u0026 rmNode.getHttpPort() !\u003d oldNode.getHttpPort()) {\n         // Reconnected node differs, so replace old node and start new node\n         switch (rmNode.getState()) {\n         case RUNNING:\n           ClusterMetrics.getMetrics().decrNumActiveNodes();\n           break;\n         case UNHEALTHY:\n           ClusterMetrics.getMetrics().decrNumUnhealthyNMs();\n           break;\n         default:\n           LOG.debug(\"Unexpected Rmnode state\");\n         }\n         this.rmContext.getDispatcher().getEventHandler()\n             .handle(new NodeRemovedSchedulerEvent(rmNode));\n \n         this.rmContext.getRMNodes().put(nodeId, rmNode);\n         this.rmContext.getDispatcher().getEventHandler()\n             .handle(new RMNodeStartedEvent(nodeId, null, null));\n-\n       } else {\n         // Reset heartbeat ID since node just restarted.\n         oldNode.resetLastNodeHeartBeatResponse();\n \n         this.rmContext.getDispatcher().getEventHandler()\n             .handle(new RMNodeReconnectEvent(nodeId, rmNode,\n                 request.getRunningApplications(),\n                 request.getNMContainerStatuses()));\n       }\n     }\n     // On every node manager register we will be clearing NMToken keys if\n     // present for any running application.\n     this.nmTokenSecretManager.removeNodeKey(nodeId);\n     this.nmLivelinessMonitor.register(nodeId);\n     \n     // Handle received container status, this should be processed after new\n     // RMNode inserted\n     if (!rmContext.isWorkPreservingRecoveryEnabled()) {\n       if (!request.getNMContainerStatuses().isEmpty()) {\n         LOG.info(\"received container statuses on node manager register :\"\n             + request.getNMContainerStatuses());\n         for (NMContainerStatus status : request.getNMContainerStatuses()) {\n           handleNMContainerStatus(status, nodeId);\n         }\n       }\n     }\n \n     // Update node\u0027s labels to RM\u0027s NodeLabelManager.\n     Set\u003cString\u003e nodeLabels \u003d NodeLabelsUtils.convertToStringSet(\n         request.getNodeLabels());\n     if (isDistributedNodeLabelsConf \u0026\u0026 nodeLabels !\u003d null) {\n       try {\n         updateNodeLabelsFromNMReport(nodeLabels, nodeId);\n         response.setAreNodeLabelsAcceptedByRM(true);\n       } catch (IOException ex) {\n         // Ensure the exception is captured in the response\n         response.setDiagnosticsMessage(ex.getMessage());\n         response.setAreNodeLabelsAcceptedByRM(false);\n       }\n     } else if (isDelegatedCentralizedNodeLabelsConf) {\n       this.rmContext.getRMDelegatedNodeLabelsUpdater().updateNodeLabels(nodeId);\n     }\n \n     StringBuilder message \u003d new StringBuilder();\n     message.append(\"NodeManager from node \").append(host).append(\"(cmPort: \")\n         .append(cmPort).append(\" httpPort: \");\n     message.append(httpPort).append(\") \")\n         .append(\"registered with capability: \").append(capability);\n     message.append(\", assigned nodeId \").append(nodeId);\n     if (response.getAreNodeLabelsAcceptedByRM()) {\n       message.append(\", node labels { \").append(\n           StringUtils.join(\",\", nodeLabels) + \" } \");\n     }\n \n     LOG.info(message.toString());\n     response.setNodeAction(NodeAction.NORMAL);\n     response.setRMIdentifier(ResourceManager.getClusterTimeStamp());\n     response.setRMVersion(YarnVersionInfo.getVersion());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterNodeManagerResponse registerNodeManager(\n      RegisterNodeManagerRequest request) throws YarnException,\n      IOException {\n    NodeId nodeId \u003d request.getNodeId();\n    String host \u003d nodeId.getHost();\n    int cmPort \u003d nodeId.getPort();\n    int httpPort \u003d request.getHttpPort();\n    Resource capability \u003d request.getResource();\n    String nodeManagerVersion \u003d request.getNMVersion();\n    Resource physicalResource \u003d request.getPhysicalResource();\n\n    RegisterNodeManagerResponse response \u003d recordFactory\n        .newRecordInstance(RegisterNodeManagerResponse.class);\n\n    if (!minimumNodeManagerVersion.equals(\"NONE\")) {\n      if (minimumNodeManagerVersion.equals(\"EqualToRM\")) {\n        minimumNodeManagerVersion \u003d YarnVersionInfo.getVersion();\n      }\n\n      if ((nodeManagerVersion \u003d\u003d null) ||\n          (VersionUtil.compareVersions(nodeManagerVersion,minimumNodeManagerVersion)) \u003c 0) {\n        String message \u003d\n            \"Disallowed NodeManager Version \" + nodeManagerVersion\n                + \", is less than the minimum version \"\n                + minimumNodeManagerVersion + \" sending SHUTDOWN signal to \"\n                + \"NodeManager.\";\n        LOG.info(message);\n        response.setDiagnosticsMessage(message);\n        response.setNodeAction(NodeAction.SHUTDOWN);\n        return response;\n      }\n    }\n\n    // Check if this node is a \u0027valid\u0027 node\n    if (!this.nodesListManager.isValidNode(host) \u0026\u0026\n        !isNodeInDecommissioning(nodeId)) {\n      String message \u003d\n          \"Disallowed NodeManager from  \" + host\n              + \", Sending SHUTDOWN signal to the NodeManager.\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    // check if node\u0027s capacity is load from dynamic-resources.xml\n    String nid \u003d nodeId.toString();\n\n    Resource dynamicLoadCapability \u003d loadNodeResourceFromDRConfiguration(nid);\n    if (dynamicLoadCapability !\u003d null) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Resource for node: \" + nid + \" is adjusted from: \" +\n            capability + \" to: \" + dynamicLoadCapability +\n            \" due to settings in dynamic-resources.xml.\");\n      }\n      capability \u003d dynamicLoadCapability;\n      // sync back with new resource.\n      response.setResource(capability);\n    }\n\n    // Check if this node has minimum allocations\n    if (capability.getMemorySize() \u003c minAllocMb\n        || capability.getVirtualCores() \u003c minAllocVcores) {\n      String message \u003d \"NodeManager from  \" + host\n          + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n          + \" signal to the NodeManager. Node capabilities are \" + capability\n          + \"; minimums are \" + minAllocMb + \"mb and \" + minAllocVcores\n          + \" vcores\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    response.setContainerTokenMasterKey(containerTokenSecretManager\n        .getCurrentKey());\n    response.setNMTokenMasterKey(nmTokenSecretManager\n        .getCurrentKey());\n\n    RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n        resolve(host), capability, nodeManagerVersion, physicalResource);\n\n    RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n    if (oldNode \u003d\u003d null) {\n      RMNodeStartedEvent startEvent \u003d new RMNodeStartedEvent(nodeId,\n          request.getNMContainerStatuses(),\n          request.getRunningApplications());\n      if (request.getLogAggregationReportsForApps() !\u003d null\n          \u0026\u0026 !request.getLogAggregationReportsForApps().isEmpty()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Found the number of previous cached log aggregation \"\n              + \"status from nodemanager:\" + nodeId + \" is :\"\n              + request.getLogAggregationReportsForApps().size());\n        }\n        startEvent.setLogAggregationReportsForApps(request\n            .getLogAggregationReportsForApps());\n      }\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          startEvent);\n    } else {\n      LOG.info(\"Reconnect from the node at: \" + host);\n      this.nmLivelinessMonitor.unregister(nodeId);\n\n      if (CollectionUtils.isEmpty(request.getRunningApplications())\n          \u0026\u0026 rmNode.getState() !\u003d NodeState.DECOMMISSIONING\n          \u0026\u0026 rmNode.getHttpPort() !\u003d oldNode.getHttpPort()) {\n        // Reconnected node differs, so replace old node and start new node\n        switch (rmNode.getState()) {\n        case RUNNING:\n          ClusterMetrics.getMetrics().decrNumActiveNodes();\n          break;\n        case UNHEALTHY:\n          ClusterMetrics.getMetrics().decrNumUnhealthyNMs();\n          break;\n        default:\n          LOG.debug(\"Unexpected Rmnode state\");\n        }\n        this.rmContext.getDispatcher().getEventHandler()\n            .handle(new NodeRemovedSchedulerEvent(rmNode));\n\n        this.rmContext.getRMNodes().put(nodeId, rmNode);\n        this.rmContext.getDispatcher().getEventHandler()\n            .handle(new RMNodeStartedEvent(nodeId, null, null));\n      } else {\n        // Reset heartbeat ID since node just restarted.\n        oldNode.resetLastNodeHeartBeatResponse();\n\n        this.rmContext.getDispatcher().getEventHandler()\n            .handle(new RMNodeReconnectEvent(nodeId, rmNode,\n                request.getRunningApplications(),\n                request.getNMContainerStatuses()));\n      }\n    }\n    // On every node manager register we will be clearing NMToken keys if\n    // present for any running application.\n    this.nmTokenSecretManager.removeNodeKey(nodeId);\n    this.nmLivelinessMonitor.register(nodeId);\n    \n    // Handle received container status, this should be processed after new\n    // RMNode inserted\n    if (!rmContext.isWorkPreservingRecoveryEnabled()) {\n      if (!request.getNMContainerStatuses().isEmpty()) {\n        LOG.info(\"received container statuses on node manager register :\"\n            + request.getNMContainerStatuses());\n        for (NMContainerStatus status : request.getNMContainerStatuses()) {\n          handleNMContainerStatus(status, nodeId);\n        }\n      }\n    }\n\n    // Update node\u0027s labels to RM\u0027s NodeLabelManager.\n    Set\u003cString\u003e nodeLabels \u003d NodeLabelsUtils.convertToStringSet(\n        request.getNodeLabels());\n    if (isDistributedNodeLabelsConf \u0026\u0026 nodeLabels !\u003d null) {\n      try {\n        updateNodeLabelsFromNMReport(nodeLabels, nodeId);\n        response.setAreNodeLabelsAcceptedByRM(true);\n      } catch (IOException ex) {\n        // Ensure the exception is captured in the response\n        response.setDiagnosticsMessage(ex.getMessage());\n        response.setAreNodeLabelsAcceptedByRM(false);\n      }\n    } else if (isDelegatedCentralizedNodeLabelsConf) {\n      this.rmContext.getRMDelegatedNodeLabelsUpdater().updateNodeLabels(nodeId);\n    }\n\n    StringBuilder message \u003d new StringBuilder();\n    message.append(\"NodeManager from node \").append(host).append(\"(cmPort: \")\n        .append(cmPort).append(\" httpPort: \");\n    message.append(httpPort).append(\") \")\n        .append(\"registered with capability: \").append(capability);\n    message.append(\", assigned nodeId \").append(nodeId);\n    if (response.getAreNodeLabelsAcceptedByRM()) {\n      message.append(\", node labels { \").append(\n          StringUtils.join(\",\", nodeLabels) + \" } \");\n    }\n\n    LOG.info(message.toString());\n    response.setNodeAction(NodeAction.NORMAL);\n    response.setRMIdentifier(ResourceManager.getClusterTimeStamp());\n    response.setRMVersion(YarnVersionInfo.getVersion());\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "ff8378eb1b960c72d18a984c7e5d145b407ca11a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7102. NM heartbeat stuck when responseId overflows MAX_INT. Contributed by Botong Huang\n",
      "commitDate": "25/01/18 3:47 PM",
      "commitName": "ff8378eb1b960c72d18a984c7e5d145b407ca11a",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "12/09/17 9:19 AM",
      "commitNameOld": "759114b0063907d4c07ea6ee261e861bf5cc3a9a",
      "commitAuthorOld": "Varun Vasudev",
      "daysBetweenCommits": 135.31,
      "commitsBetweenForRepo": 980,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,149 +1,172 @@\n   public RegisterNodeManagerResponse registerNodeManager(\n       RegisterNodeManagerRequest request) throws YarnException,\n       IOException {\n     NodeId nodeId \u003d request.getNodeId();\n     String host \u003d nodeId.getHost();\n     int cmPort \u003d nodeId.getPort();\n     int httpPort \u003d request.getHttpPort();\n     Resource capability \u003d request.getResource();\n     String nodeManagerVersion \u003d request.getNMVersion();\n     Resource physicalResource \u003d request.getPhysicalResource();\n \n     RegisterNodeManagerResponse response \u003d recordFactory\n         .newRecordInstance(RegisterNodeManagerResponse.class);\n \n     if (!minimumNodeManagerVersion.equals(\"NONE\")) {\n       if (minimumNodeManagerVersion.equals(\"EqualToRM\")) {\n         minimumNodeManagerVersion \u003d YarnVersionInfo.getVersion();\n       }\n \n       if ((nodeManagerVersion \u003d\u003d null) ||\n           (VersionUtil.compareVersions(nodeManagerVersion,minimumNodeManagerVersion)) \u003c 0) {\n         String message \u003d\n             \"Disallowed NodeManager Version \" + nodeManagerVersion\n                 + \", is less than the minimum version \"\n                 + minimumNodeManagerVersion + \" sending SHUTDOWN signal to \"\n                 + \"NodeManager.\";\n         LOG.info(message);\n         response.setDiagnosticsMessage(message);\n         response.setNodeAction(NodeAction.SHUTDOWN);\n         return response;\n       }\n     }\n \n     // Check if this node is a \u0027valid\u0027 node\n     if (!this.nodesListManager.isValidNode(host) \u0026\u0026\n         !isNodeInDecommissioning(nodeId)) {\n       String message \u003d\n           \"Disallowed NodeManager from  \" + host\n               + \", Sending SHUTDOWN signal to the NodeManager.\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     // check if node\u0027s capacity is load from dynamic-resources.xml\n     String nid \u003d nodeId.toString();\n \n     Resource dynamicLoadCapability \u003d loadNodeResourceFromDRConfiguration(nid);\n     if (dynamicLoadCapability !\u003d null) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Resource for node: \" + nid + \" is adjusted from: \" +\n             capability + \" to: \" + dynamicLoadCapability +\n             \" due to settings in dynamic-resources.xml.\");\n       }\n       capability \u003d dynamicLoadCapability;\n       // sync back with new resource.\n       response.setResource(capability);\n     }\n \n     // Check if this node has minimum allocations\n     if (capability.getMemorySize() \u003c minAllocMb\n         || capability.getVirtualCores() \u003c minAllocVcores) {\n       String message \u003d \"NodeManager from  \" + host\n           + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n           + \" signal to the NodeManager. Node capabilities are \" + capability\n           + \"; minimums are \" + minAllocMb + \"mb and \" + minAllocVcores\n           + \" vcores\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     response.setContainerTokenMasterKey(containerTokenSecretManager\n         .getCurrentKey());\n     response.setNMTokenMasterKey(nmTokenSecretManager\n         .getCurrentKey());\n \n     RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n         resolve(host), capability, nodeManagerVersion, physicalResource);\n \n     RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n     if (oldNode \u003d\u003d null) {\n       this.rmContext.getDispatcher().getEventHandler().handle(\n               new RMNodeStartedEvent(nodeId, request.getNMContainerStatuses(),\n                   request.getRunningApplications()));\n     } else {\n       LOG.info(\"Reconnect from the node at: \" + host);\n       this.nmLivelinessMonitor.unregister(nodeId);\n-      // Reset heartbeat ID since node just restarted.\n-      oldNode.resetLastNodeHeartBeatResponse();\n-      this.rmContext\n-          .getDispatcher()\n-          .getEventHandler()\n-          .handle(\n-              new RMNodeReconnectEvent(nodeId, rmNode, request\n-                  .getRunningApplications(), request.getNMContainerStatuses()));\n+\n+      if (CollectionUtils.isEmpty(request.getRunningApplications())\n+          \u0026\u0026 rmNode.getState() !\u003d NodeState.DECOMMISSIONING\n+          \u0026\u0026 rmNode.getHttpPort() !\u003d oldNode.getHttpPort()) {\n+        // Reconnected node differs, so replace old node and start new node\n+        switch (rmNode.getState()) {\n+        case RUNNING:\n+          ClusterMetrics.getMetrics().decrNumActiveNodes();\n+          break;\n+        case UNHEALTHY:\n+          ClusterMetrics.getMetrics().decrNumUnhealthyNMs();\n+          break;\n+        default:\n+          LOG.debug(\"Unexpected Rmnode state\");\n+        }\n+        this.rmContext.getDispatcher().getEventHandler()\n+            .handle(new NodeRemovedSchedulerEvent(rmNode));\n+\n+        this.rmContext.getRMNodes().put(nodeId, rmNode);\n+        this.rmContext.getDispatcher().getEventHandler()\n+            .handle(new RMNodeStartedEvent(nodeId, null, null));\n+\n+      } else {\n+        // Reset heartbeat ID since node just restarted.\n+        oldNode.resetLastNodeHeartBeatResponse();\n+\n+        this.rmContext.getDispatcher().getEventHandler()\n+            .handle(new RMNodeReconnectEvent(nodeId, rmNode,\n+                request.getRunningApplications(),\n+                request.getNMContainerStatuses()));\n+      }\n     }\n     // On every node manager register we will be clearing NMToken keys if\n     // present for any running application.\n     this.nmTokenSecretManager.removeNodeKey(nodeId);\n     this.nmLivelinessMonitor.register(nodeId);\n     \n     // Handle received container status, this should be processed after new\n     // RMNode inserted\n     if (!rmContext.isWorkPreservingRecoveryEnabled()) {\n       if (!request.getNMContainerStatuses().isEmpty()) {\n         LOG.info(\"received container statuses on node manager register :\"\n             + request.getNMContainerStatuses());\n         for (NMContainerStatus status : request.getNMContainerStatuses()) {\n           handleNMContainerStatus(status, nodeId);\n         }\n       }\n     }\n \n     // Update node\u0027s labels to RM\u0027s NodeLabelManager.\n     Set\u003cString\u003e nodeLabels \u003d NodeLabelsUtils.convertToStringSet(\n         request.getNodeLabels());\n     if (isDistributedNodeLabelsConf \u0026\u0026 nodeLabels !\u003d null) {\n       try {\n         updateNodeLabelsFromNMReport(nodeLabels, nodeId);\n         response.setAreNodeLabelsAcceptedByRM(true);\n       } catch (IOException ex) {\n         // Ensure the exception is captured in the response\n         response.setDiagnosticsMessage(ex.getMessage());\n         response.setAreNodeLabelsAcceptedByRM(false);\n       }\n     } else if (isDelegatedCentralizedNodeLabelsConf) {\n       this.rmContext.getRMDelegatedNodeLabelsUpdater().updateNodeLabels(nodeId);\n     }\n \n     StringBuilder message \u003d new StringBuilder();\n     message.append(\"NodeManager from node \").append(host).append(\"(cmPort: \")\n         .append(cmPort).append(\" httpPort: \");\n     message.append(httpPort).append(\") \")\n         .append(\"registered with capability: \").append(capability);\n     message.append(\", assigned nodeId \").append(nodeId);\n     if (response.getAreNodeLabelsAcceptedByRM()) {\n       message.append(\", node labels { \").append(\n           StringUtils.join(\",\", nodeLabels) + \" } \");\n     }\n \n     LOG.info(message.toString());\n     response.setNodeAction(NodeAction.NORMAL);\n     response.setRMIdentifier(ResourceManager.getClusterTimeStamp());\n     response.setRMVersion(YarnVersionInfo.getVersion());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterNodeManagerResponse registerNodeManager(\n      RegisterNodeManagerRequest request) throws YarnException,\n      IOException {\n    NodeId nodeId \u003d request.getNodeId();\n    String host \u003d nodeId.getHost();\n    int cmPort \u003d nodeId.getPort();\n    int httpPort \u003d request.getHttpPort();\n    Resource capability \u003d request.getResource();\n    String nodeManagerVersion \u003d request.getNMVersion();\n    Resource physicalResource \u003d request.getPhysicalResource();\n\n    RegisterNodeManagerResponse response \u003d recordFactory\n        .newRecordInstance(RegisterNodeManagerResponse.class);\n\n    if (!minimumNodeManagerVersion.equals(\"NONE\")) {\n      if (minimumNodeManagerVersion.equals(\"EqualToRM\")) {\n        minimumNodeManagerVersion \u003d YarnVersionInfo.getVersion();\n      }\n\n      if ((nodeManagerVersion \u003d\u003d null) ||\n          (VersionUtil.compareVersions(nodeManagerVersion,minimumNodeManagerVersion)) \u003c 0) {\n        String message \u003d\n            \"Disallowed NodeManager Version \" + nodeManagerVersion\n                + \", is less than the minimum version \"\n                + minimumNodeManagerVersion + \" sending SHUTDOWN signal to \"\n                + \"NodeManager.\";\n        LOG.info(message);\n        response.setDiagnosticsMessage(message);\n        response.setNodeAction(NodeAction.SHUTDOWN);\n        return response;\n      }\n    }\n\n    // Check if this node is a \u0027valid\u0027 node\n    if (!this.nodesListManager.isValidNode(host) \u0026\u0026\n        !isNodeInDecommissioning(nodeId)) {\n      String message \u003d\n          \"Disallowed NodeManager from  \" + host\n              + \", Sending SHUTDOWN signal to the NodeManager.\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    // check if node\u0027s capacity is load from dynamic-resources.xml\n    String nid \u003d nodeId.toString();\n\n    Resource dynamicLoadCapability \u003d loadNodeResourceFromDRConfiguration(nid);\n    if (dynamicLoadCapability !\u003d null) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Resource for node: \" + nid + \" is adjusted from: \" +\n            capability + \" to: \" + dynamicLoadCapability +\n            \" due to settings in dynamic-resources.xml.\");\n      }\n      capability \u003d dynamicLoadCapability;\n      // sync back with new resource.\n      response.setResource(capability);\n    }\n\n    // Check if this node has minimum allocations\n    if (capability.getMemorySize() \u003c minAllocMb\n        || capability.getVirtualCores() \u003c minAllocVcores) {\n      String message \u003d \"NodeManager from  \" + host\n          + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n          + \" signal to the NodeManager. Node capabilities are \" + capability\n          + \"; minimums are \" + minAllocMb + \"mb and \" + minAllocVcores\n          + \" vcores\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    response.setContainerTokenMasterKey(containerTokenSecretManager\n        .getCurrentKey());\n    response.setNMTokenMasterKey(nmTokenSecretManager\n        .getCurrentKey());\n\n    RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n        resolve(host), capability, nodeManagerVersion, physicalResource);\n\n    RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n    if (oldNode \u003d\u003d null) {\n      this.rmContext.getDispatcher().getEventHandler().handle(\n              new RMNodeStartedEvent(nodeId, request.getNMContainerStatuses(),\n                  request.getRunningApplications()));\n    } else {\n      LOG.info(\"Reconnect from the node at: \" + host);\n      this.nmLivelinessMonitor.unregister(nodeId);\n\n      if (CollectionUtils.isEmpty(request.getRunningApplications())\n          \u0026\u0026 rmNode.getState() !\u003d NodeState.DECOMMISSIONING\n          \u0026\u0026 rmNode.getHttpPort() !\u003d oldNode.getHttpPort()) {\n        // Reconnected node differs, so replace old node and start new node\n        switch (rmNode.getState()) {\n        case RUNNING:\n          ClusterMetrics.getMetrics().decrNumActiveNodes();\n          break;\n        case UNHEALTHY:\n          ClusterMetrics.getMetrics().decrNumUnhealthyNMs();\n          break;\n        default:\n          LOG.debug(\"Unexpected Rmnode state\");\n        }\n        this.rmContext.getDispatcher().getEventHandler()\n            .handle(new NodeRemovedSchedulerEvent(rmNode));\n\n        this.rmContext.getRMNodes().put(nodeId, rmNode);\n        this.rmContext.getDispatcher().getEventHandler()\n            .handle(new RMNodeStartedEvent(nodeId, null, null));\n\n      } else {\n        // Reset heartbeat ID since node just restarted.\n        oldNode.resetLastNodeHeartBeatResponse();\n\n        this.rmContext.getDispatcher().getEventHandler()\n            .handle(new RMNodeReconnectEvent(nodeId, rmNode,\n                request.getRunningApplications(),\n                request.getNMContainerStatuses()));\n      }\n    }\n    // On every node manager register we will be clearing NMToken keys if\n    // present for any running application.\n    this.nmTokenSecretManager.removeNodeKey(nodeId);\n    this.nmLivelinessMonitor.register(nodeId);\n    \n    // Handle received container status, this should be processed after new\n    // RMNode inserted\n    if (!rmContext.isWorkPreservingRecoveryEnabled()) {\n      if (!request.getNMContainerStatuses().isEmpty()) {\n        LOG.info(\"received container statuses on node manager register :\"\n            + request.getNMContainerStatuses());\n        for (NMContainerStatus status : request.getNMContainerStatuses()) {\n          handleNMContainerStatus(status, nodeId);\n        }\n      }\n    }\n\n    // Update node\u0027s labels to RM\u0027s NodeLabelManager.\n    Set\u003cString\u003e nodeLabels \u003d NodeLabelsUtils.convertToStringSet(\n        request.getNodeLabels());\n    if (isDistributedNodeLabelsConf \u0026\u0026 nodeLabels !\u003d null) {\n      try {\n        updateNodeLabelsFromNMReport(nodeLabels, nodeId);\n        response.setAreNodeLabelsAcceptedByRM(true);\n      } catch (IOException ex) {\n        // Ensure the exception is captured in the response\n        response.setDiagnosticsMessage(ex.getMessage());\n        response.setAreNodeLabelsAcceptedByRM(false);\n      }\n    } else if (isDelegatedCentralizedNodeLabelsConf) {\n      this.rmContext.getRMDelegatedNodeLabelsUpdater().updateNodeLabels(nodeId);\n    }\n\n    StringBuilder message \u003d new StringBuilder();\n    message.append(\"NodeManager from node \").append(host).append(\"(cmPort: \")\n        .append(cmPort).append(\" httpPort: \");\n    message.append(httpPort).append(\") \")\n        .append(\"registered with capability: \").append(capability);\n    message.append(\", assigned nodeId \").append(nodeId);\n    if (response.getAreNodeLabelsAcceptedByRM()) {\n      message.append(\", node labels { \").append(\n          StringUtils.join(\",\", nodeLabels) + \" } \");\n    }\n\n    LOG.info(message.toString());\n    response.setNodeAction(NodeAction.NORMAL);\n    response.setRMIdentifier(ResourceManager.getClusterTimeStamp());\n    response.setRMVersion(YarnVersionInfo.getVersion());\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "759114b0063907d4c07ea6ee261e861bf5cc3a9a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4830. Add support for resource types in the nodemanager. Contributed by Varun Vasudev.\n",
      "commitDate": "12/09/17 9:19 AM",
      "commitName": "759114b0063907d4c07ea6ee261e861bf5cc3a9a",
      "commitAuthor": "Varun Vasudev",
      "commitDateOld": "29/08/17 10:59 PM",
      "commitNameOld": "660413165aa25815bbba66ac2195b0ae17184844",
      "commitAuthorOld": "Rohith Sharma K S",
      "daysBetweenCommits": 13.43,
      "commitsBetweenForRepo": 121,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,148 +1,149 @@\n   public RegisterNodeManagerResponse registerNodeManager(\n       RegisterNodeManagerRequest request) throws YarnException,\n       IOException {\n     NodeId nodeId \u003d request.getNodeId();\n     String host \u003d nodeId.getHost();\n     int cmPort \u003d nodeId.getPort();\n     int httpPort \u003d request.getHttpPort();\n     Resource capability \u003d request.getResource();\n     String nodeManagerVersion \u003d request.getNMVersion();\n     Resource physicalResource \u003d request.getPhysicalResource();\n \n     RegisterNodeManagerResponse response \u003d recordFactory\n         .newRecordInstance(RegisterNodeManagerResponse.class);\n \n     if (!minimumNodeManagerVersion.equals(\"NONE\")) {\n       if (minimumNodeManagerVersion.equals(\"EqualToRM\")) {\n         minimumNodeManagerVersion \u003d YarnVersionInfo.getVersion();\n       }\n \n       if ((nodeManagerVersion \u003d\u003d null) ||\n           (VersionUtil.compareVersions(nodeManagerVersion,minimumNodeManagerVersion)) \u003c 0) {\n         String message \u003d\n             \"Disallowed NodeManager Version \" + nodeManagerVersion\n                 + \", is less than the minimum version \"\n                 + minimumNodeManagerVersion + \" sending SHUTDOWN signal to \"\n                 + \"NodeManager.\";\n         LOG.info(message);\n         response.setDiagnosticsMessage(message);\n         response.setNodeAction(NodeAction.SHUTDOWN);\n         return response;\n       }\n     }\n \n     // Check if this node is a \u0027valid\u0027 node\n     if (!this.nodesListManager.isValidNode(host) \u0026\u0026\n         !isNodeInDecommissioning(nodeId)) {\n       String message \u003d\n           \"Disallowed NodeManager from  \" + host\n               + \", Sending SHUTDOWN signal to the NodeManager.\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     // check if node\u0027s capacity is load from dynamic-resources.xml\n     String nid \u003d nodeId.toString();\n \n     Resource dynamicLoadCapability \u003d loadNodeResourceFromDRConfiguration(nid);\n     if (dynamicLoadCapability !\u003d null) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Resource for node: \" + nid + \" is adjusted from: \" +\n             capability + \" to: \" + dynamicLoadCapability +\n             \" due to settings in dynamic-resources.xml.\");\n       }\n       capability \u003d dynamicLoadCapability;\n       // sync back with new resource.\n       response.setResource(capability);\n     }\n \n     // Check if this node has minimum allocations\n     if (capability.getMemorySize() \u003c minAllocMb\n         || capability.getVirtualCores() \u003c minAllocVcores) {\n-      String message \u003d\n-          \"NodeManager from  \" + host\n-              + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n-              + \" signal to the NodeManager.\";\n+      String message \u003d \"NodeManager from  \" + host\n+          + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n+          + \" signal to the NodeManager. Node capabilities are \" + capability\n+          + \"; minimums are \" + minAllocMb + \"mb and \" + minAllocVcores\n+          + \" vcores\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     response.setContainerTokenMasterKey(containerTokenSecretManager\n         .getCurrentKey());\n     response.setNMTokenMasterKey(nmTokenSecretManager\n         .getCurrentKey());\n \n     RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n         resolve(host), capability, nodeManagerVersion, physicalResource);\n \n     RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n     if (oldNode \u003d\u003d null) {\n       this.rmContext.getDispatcher().getEventHandler().handle(\n               new RMNodeStartedEvent(nodeId, request.getNMContainerStatuses(),\n                   request.getRunningApplications()));\n     } else {\n       LOG.info(\"Reconnect from the node at: \" + host);\n       this.nmLivelinessMonitor.unregister(nodeId);\n       // Reset heartbeat ID since node just restarted.\n       oldNode.resetLastNodeHeartBeatResponse();\n       this.rmContext\n           .getDispatcher()\n           .getEventHandler()\n           .handle(\n               new RMNodeReconnectEvent(nodeId, rmNode, request\n                   .getRunningApplications(), request.getNMContainerStatuses()));\n     }\n     // On every node manager register we will be clearing NMToken keys if\n     // present for any running application.\n     this.nmTokenSecretManager.removeNodeKey(nodeId);\n     this.nmLivelinessMonitor.register(nodeId);\n     \n     // Handle received container status, this should be processed after new\n     // RMNode inserted\n     if (!rmContext.isWorkPreservingRecoveryEnabled()) {\n       if (!request.getNMContainerStatuses().isEmpty()) {\n         LOG.info(\"received container statuses on node manager register :\"\n             + request.getNMContainerStatuses());\n         for (NMContainerStatus status : request.getNMContainerStatuses()) {\n           handleNMContainerStatus(status, nodeId);\n         }\n       }\n     }\n \n     // Update node\u0027s labels to RM\u0027s NodeLabelManager.\n     Set\u003cString\u003e nodeLabels \u003d NodeLabelsUtils.convertToStringSet(\n         request.getNodeLabels());\n     if (isDistributedNodeLabelsConf \u0026\u0026 nodeLabels !\u003d null) {\n       try {\n         updateNodeLabelsFromNMReport(nodeLabels, nodeId);\n         response.setAreNodeLabelsAcceptedByRM(true);\n       } catch (IOException ex) {\n         // Ensure the exception is captured in the response\n         response.setDiagnosticsMessage(ex.getMessage());\n         response.setAreNodeLabelsAcceptedByRM(false);\n       }\n     } else if (isDelegatedCentralizedNodeLabelsConf) {\n       this.rmContext.getRMDelegatedNodeLabelsUpdater().updateNodeLabels(nodeId);\n     }\n \n     StringBuilder message \u003d new StringBuilder();\n     message.append(\"NodeManager from node \").append(host).append(\"(cmPort: \")\n         .append(cmPort).append(\" httpPort: \");\n     message.append(httpPort).append(\") \")\n         .append(\"registered with capability: \").append(capability);\n     message.append(\", assigned nodeId \").append(nodeId);\n     if (response.getAreNodeLabelsAcceptedByRM()) {\n       message.append(\", node labels { \").append(\n           StringUtils.join(\",\", nodeLabels) + \" } \");\n     }\n \n     LOG.info(message.toString());\n     response.setNodeAction(NodeAction.NORMAL);\n     response.setRMIdentifier(ResourceManager.getClusterTimeStamp());\n     response.setRMVersion(YarnVersionInfo.getVersion());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterNodeManagerResponse registerNodeManager(\n      RegisterNodeManagerRequest request) throws YarnException,\n      IOException {\n    NodeId nodeId \u003d request.getNodeId();\n    String host \u003d nodeId.getHost();\n    int cmPort \u003d nodeId.getPort();\n    int httpPort \u003d request.getHttpPort();\n    Resource capability \u003d request.getResource();\n    String nodeManagerVersion \u003d request.getNMVersion();\n    Resource physicalResource \u003d request.getPhysicalResource();\n\n    RegisterNodeManagerResponse response \u003d recordFactory\n        .newRecordInstance(RegisterNodeManagerResponse.class);\n\n    if (!minimumNodeManagerVersion.equals(\"NONE\")) {\n      if (minimumNodeManagerVersion.equals(\"EqualToRM\")) {\n        minimumNodeManagerVersion \u003d YarnVersionInfo.getVersion();\n      }\n\n      if ((nodeManagerVersion \u003d\u003d null) ||\n          (VersionUtil.compareVersions(nodeManagerVersion,minimumNodeManagerVersion)) \u003c 0) {\n        String message \u003d\n            \"Disallowed NodeManager Version \" + nodeManagerVersion\n                + \", is less than the minimum version \"\n                + minimumNodeManagerVersion + \" sending SHUTDOWN signal to \"\n                + \"NodeManager.\";\n        LOG.info(message);\n        response.setDiagnosticsMessage(message);\n        response.setNodeAction(NodeAction.SHUTDOWN);\n        return response;\n      }\n    }\n\n    // Check if this node is a \u0027valid\u0027 node\n    if (!this.nodesListManager.isValidNode(host) \u0026\u0026\n        !isNodeInDecommissioning(nodeId)) {\n      String message \u003d\n          \"Disallowed NodeManager from  \" + host\n              + \", Sending SHUTDOWN signal to the NodeManager.\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    // check if node\u0027s capacity is load from dynamic-resources.xml\n    String nid \u003d nodeId.toString();\n\n    Resource dynamicLoadCapability \u003d loadNodeResourceFromDRConfiguration(nid);\n    if (dynamicLoadCapability !\u003d null) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Resource for node: \" + nid + \" is adjusted from: \" +\n            capability + \" to: \" + dynamicLoadCapability +\n            \" due to settings in dynamic-resources.xml.\");\n      }\n      capability \u003d dynamicLoadCapability;\n      // sync back with new resource.\n      response.setResource(capability);\n    }\n\n    // Check if this node has minimum allocations\n    if (capability.getMemorySize() \u003c minAllocMb\n        || capability.getVirtualCores() \u003c minAllocVcores) {\n      String message \u003d \"NodeManager from  \" + host\n          + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n          + \" signal to the NodeManager. Node capabilities are \" + capability\n          + \"; minimums are \" + minAllocMb + \"mb and \" + minAllocVcores\n          + \" vcores\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    response.setContainerTokenMasterKey(containerTokenSecretManager\n        .getCurrentKey());\n    response.setNMTokenMasterKey(nmTokenSecretManager\n        .getCurrentKey());\n\n    RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n        resolve(host), capability, nodeManagerVersion, physicalResource);\n\n    RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n    if (oldNode \u003d\u003d null) {\n      this.rmContext.getDispatcher().getEventHandler().handle(\n              new RMNodeStartedEvent(nodeId, request.getNMContainerStatuses(),\n                  request.getRunningApplications()));\n    } else {\n      LOG.info(\"Reconnect from the node at: \" + host);\n      this.nmLivelinessMonitor.unregister(nodeId);\n      // Reset heartbeat ID since node just restarted.\n      oldNode.resetLastNodeHeartBeatResponse();\n      this.rmContext\n          .getDispatcher()\n          .getEventHandler()\n          .handle(\n              new RMNodeReconnectEvent(nodeId, rmNode, request\n                  .getRunningApplications(), request.getNMContainerStatuses()));\n    }\n    // On every node manager register we will be clearing NMToken keys if\n    // present for any running application.\n    this.nmTokenSecretManager.removeNodeKey(nodeId);\n    this.nmLivelinessMonitor.register(nodeId);\n    \n    // Handle received container status, this should be processed after new\n    // RMNode inserted\n    if (!rmContext.isWorkPreservingRecoveryEnabled()) {\n      if (!request.getNMContainerStatuses().isEmpty()) {\n        LOG.info(\"received container statuses on node manager register :\"\n            + request.getNMContainerStatuses());\n        for (NMContainerStatus status : request.getNMContainerStatuses()) {\n          handleNMContainerStatus(status, nodeId);\n        }\n      }\n    }\n\n    // Update node\u0027s labels to RM\u0027s NodeLabelManager.\n    Set\u003cString\u003e nodeLabels \u003d NodeLabelsUtils.convertToStringSet(\n        request.getNodeLabels());\n    if (isDistributedNodeLabelsConf \u0026\u0026 nodeLabels !\u003d null) {\n      try {\n        updateNodeLabelsFromNMReport(nodeLabels, nodeId);\n        response.setAreNodeLabelsAcceptedByRM(true);\n      } catch (IOException ex) {\n        // Ensure the exception is captured in the response\n        response.setDiagnosticsMessage(ex.getMessage());\n        response.setAreNodeLabelsAcceptedByRM(false);\n      }\n    } else if (isDelegatedCentralizedNodeLabelsConf) {\n      this.rmContext.getRMDelegatedNodeLabelsUpdater().updateNodeLabels(nodeId);\n    }\n\n    StringBuilder message \u003d new StringBuilder();\n    message.append(\"NodeManager from node \").append(host).append(\"(cmPort: \")\n        .append(cmPort).append(\" httpPort: \");\n    message.append(httpPort).append(\") \")\n        .append(\"registered with capability: \").append(capability);\n    message.append(\", assigned nodeId \").append(nodeId);\n    if (response.getAreNodeLabelsAcceptedByRM()) {\n      message.append(\", node labels { \").append(\n          StringUtils.join(\",\", nodeLabels) + \" } \");\n    }\n\n    LOG.info(message.toString());\n    response.setNodeAction(NodeAction.NORMAL);\n    response.setRMIdentifier(ResourceManager.getClusterTimeStamp());\n    response.setRMVersion(YarnVersionInfo.getVersion());\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "3f93ac0733058238a2c8f23960c986c71dca0e02": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5356. NodeManager should communicate physical resource capability to ResourceManager. Contributed by Inigo Goiri\n",
      "commitDate": "08/11/16 2:01 PM",
      "commitName": "3f93ac0733058238a2c8f23960c986c71dca0e02",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "18/08/16 7:27 AM",
      "commitNameOld": "0da69c324dee9baab0f0b9700db1cc5b623f8421",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 82.32,
      "commitsBetweenForRepo": 617,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,147 +1,148 @@\n   public RegisterNodeManagerResponse registerNodeManager(\n       RegisterNodeManagerRequest request) throws YarnException,\n       IOException {\n     NodeId nodeId \u003d request.getNodeId();\n     String host \u003d nodeId.getHost();\n     int cmPort \u003d nodeId.getPort();\n     int httpPort \u003d request.getHttpPort();\n     Resource capability \u003d request.getResource();\n     String nodeManagerVersion \u003d request.getNMVersion();\n+    Resource physicalResource \u003d request.getPhysicalResource();\n \n     RegisterNodeManagerResponse response \u003d recordFactory\n         .newRecordInstance(RegisterNodeManagerResponse.class);\n \n     if (!minimumNodeManagerVersion.equals(\"NONE\")) {\n       if (minimumNodeManagerVersion.equals(\"EqualToRM\")) {\n         minimumNodeManagerVersion \u003d YarnVersionInfo.getVersion();\n       }\n \n       if ((nodeManagerVersion \u003d\u003d null) ||\n           (VersionUtil.compareVersions(nodeManagerVersion,minimumNodeManagerVersion)) \u003c 0) {\n         String message \u003d\n             \"Disallowed NodeManager Version \" + nodeManagerVersion\n                 + \", is less than the minimum version \"\n                 + minimumNodeManagerVersion + \" sending SHUTDOWN signal to \"\n                 + \"NodeManager.\";\n         LOG.info(message);\n         response.setDiagnosticsMessage(message);\n         response.setNodeAction(NodeAction.SHUTDOWN);\n         return response;\n       }\n     }\n \n     // Check if this node is a \u0027valid\u0027 node\n     if (!this.nodesListManager.isValidNode(host) \u0026\u0026\n         !isNodeInDecommissioning(nodeId)) {\n       String message \u003d\n           \"Disallowed NodeManager from  \" + host\n               + \", Sending SHUTDOWN signal to the NodeManager.\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     // check if node\u0027s capacity is load from dynamic-resources.xml\n     String nid \u003d nodeId.toString();\n \n     Resource dynamicLoadCapability \u003d loadNodeResourceFromDRConfiguration(nid);\n     if (dynamicLoadCapability !\u003d null) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Resource for node: \" + nid + \" is adjusted from: \" +\n             capability + \" to: \" + dynamicLoadCapability +\n             \" due to settings in dynamic-resources.xml.\");\n       }\n       capability \u003d dynamicLoadCapability;\n       // sync back with new resource.\n       response.setResource(capability);\n     }\n \n     // Check if this node has minimum allocations\n     if (capability.getMemorySize() \u003c minAllocMb\n         || capability.getVirtualCores() \u003c minAllocVcores) {\n       String message \u003d\n           \"NodeManager from  \" + host\n               + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n               + \" signal to the NodeManager.\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     response.setContainerTokenMasterKey(containerTokenSecretManager\n         .getCurrentKey());\n     response.setNMTokenMasterKey(nmTokenSecretManager\n         .getCurrentKey());\n \n     RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n-        resolve(host), capability, nodeManagerVersion);\n+        resolve(host), capability, nodeManagerVersion, physicalResource);\n \n     RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n     if (oldNode \u003d\u003d null) {\n       this.rmContext.getDispatcher().getEventHandler().handle(\n               new RMNodeStartedEvent(nodeId, request.getNMContainerStatuses(),\n                   request.getRunningApplications()));\n     } else {\n       LOG.info(\"Reconnect from the node at: \" + host);\n       this.nmLivelinessMonitor.unregister(nodeId);\n       // Reset heartbeat ID since node just restarted.\n       oldNode.resetLastNodeHeartBeatResponse();\n       this.rmContext\n           .getDispatcher()\n           .getEventHandler()\n           .handle(\n               new RMNodeReconnectEvent(nodeId, rmNode, request\n                   .getRunningApplications(), request.getNMContainerStatuses()));\n     }\n     // On every node manager register we will be clearing NMToken keys if\n     // present for any running application.\n     this.nmTokenSecretManager.removeNodeKey(nodeId);\n     this.nmLivelinessMonitor.register(nodeId);\n     \n     // Handle received container status, this should be processed after new\n     // RMNode inserted\n     if (!rmContext.isWorkPreservingRecoveryEnabled()) {\n       if (!request.getNMContainerStatuses().isEmpty()) {\n         LOG.info(\"received container statuses on node manager register :\"\n             + request.getNMContainerStatuses());\n         for (NMContainerStatus status : request.getNMContainerStatuses()) {\n           handleNMContainerStatus(status, nodeId);\n         }\n       }\n     }\n \n     // Update node\u0027s labels to RM\u0027s NodeLabelManager.\n     Set\u003cString\u003e nodeLabels \u003d NodeLabelsUtils.convertToStringSet(\n         request.getNodeLabels());\n     if (isDistributedNodeLabelsConf \u0026\u0026 nodeLabels !\u003d null) {\n       try {\n         updateNodeLabelsFromNMReport(nodeLabels, nodeId);\n         response.setAreNodeLabelsAcceptedByRM(true);\n       } catch (IOException ex) {\n         // Ensure the exception is captured in the response\n         response.setDiagnosticsMessage(ex.getMessage());\n         response.setAreNodeLabelsAcceptedByRM(false);\n       }\n     } else if (isDelegatedCentralizedNodeLabelsConf) {\n       this.rmContext.getRMDelegatedNodeLabelsUpdater().updateNodeLabels(nodeId);\n     }\n \n     StringBuilder message \u003d new StringBuilder();\n     message.append(\"NodeManager from node \").append(host).append(\"(cmPort: \")\n         .append(cmPort).append(\" httpPort: \");\n     message.append(httpPort).append(\") \")\n         .append(\"registered with capability: \").append(capability);\n     message.append(\", assigned nodeId \").append(nodeId);\n     if (response.getAreNodeLabelsAcceptedByRM()) {\n       message.append(\", node labels { \").append(\n           StringUtils.join(\",\", nodeLabels) + \" } \");\n     }\n \n     LOG.info(message.toString());\n     response.setNodeAction(NodeAction.NORMAL);\n     response.setRMIdentifier(ResourceManager.getClusterTimeStamp());\n     response.setRMVersion(YarnVersionInfo.getVersion());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterNodeManagerResponse registerNodeManager(\n      RegisterNodeManagerRequest request) throws YarnException,\n      IOException {\n    NodeId nodeId \u003d request.getNodeId();\n    String host \u003d nodeId.getHost();\n    int cmPort \u003d nodeId.getPort();\n    int httpPort \u003d request.getHttpPort();\n    Resource capability \u003d request.getResource();\n    String nodeManagerVersion \u003d request.getNMVersion();\n    Resource physicalResource \u003d request.getPhysicalResource();\n\n    RegisterNodeManagerResponse response \u003d recordFactory\n        .newRecordInstance(RegisterNodeManagerResponse.class);\n\n    if (!minimumNodeManagerVersion.equals(\"NONE\")) {\n      if (minimumNodeManagerVersion.equals(\"EqualToRM\")) {\n        minimumNodeManagerVersion \u003d YarnVersionInfo.getVersion();\n      }\n\n      if ((nodeManagerVersion \u003d\u003d null) ||\n          (VersionUtil.compareVersions(nodeManagerVersion,minimumNodeManagerVersion)) \u003c 0) {\n        String message \u003d\n            \"Disallowed NodeManager Version \" + nodeManagerVersion\n                + \", is less than the minimum version \"\n                + minimumNodeManagerVersion + \" sending SHUTDOWN signal to \"\n                + \"NodeManager.\";\n        LOG.info(message);\n        response.setDiagnosticsMessage(message);\n        response.setNodeAction(NodeAction.SHUTDOWN);\n        return response;\n      }\n    }\n\n    // Check if this node is a \u0027valid\u0027 node\n    if (!this.nodesListManager.isValidNode(host) \u0026\u0026\n        !isNodeInDecommissioning(nodeId)) {\n      String message \u003d\n          \"Disallowed NodeManager from  \" + host\n              + \", Sending SHUTDOWN signal to the NodeManager.\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    // check if node\u0027s capacity is load from dynamic-resources.xml\n    String nid \u003d nodeId.toString();\n\n    Resource dynamicLoadCapability \u003d loadNodeResourceFromDRConfiguration(nid);\n    if (dynamicLoadCapability !\u003d null) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Resource for node: \" + nid + \" is adjusted from: \" +\n            capability + \" to: \" + dynamicLoadCapability +\n            \" due to settings in dynamic-resources.xml.\");\n      }\n      capability \u003d dynamicLoadCapability;\n      // sync back with new resource.\n      response.setResource(capability);\n    }\n\n    // Check if this node has minimum allocations\n    if (capability.getMemorySize() \u003c minAllocMb\n        || capability.getVirtualCores() \u003c minAllocVcores) {\n      String message \u003d\n          \"NodeManager from  \" + host\n              + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n              + \" signal to the NodeManager.\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    response.setContainerTokenMasterKey(containerTokenSecretManager\n        .getCurrentKey());\n    response.setNMTokenMasterKey(nmTokenSecretManager\n        .getCurrentKey());\n\n    RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n        resolve(host), capability, nodeManagerVersion, physicalResource);\n\n    RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n    if (oldNode \u003d\u003d null) {\n      this.rmContext.getDispatcher().getEventHandler().handle(\n              new RMNodeStartedEvent(nodeId, request.getNMContainerStatuses(),\n                  request.getRunningApplications()));\n    } else {\n      LOG.info(\"Reconnect from the node at: \" + host);\n      this.nmLivelinessMonitor.unregister(nodeId);\n      // Reset heartbeat ID since node just restarted.\n      oldNode.resetLastNodeHeartBeatResponse();\n      this.rmContext\n          .getDispatcher()\n          .getEventHandler()\n          .handle(\n              new RMNodeReconnectEvent(nodeId, rmNode, request\n                  .getRunningApplications(), request.getNMContainerStatuses()));\n    }\n    // On every node manager register we will be clearing NMToken keys if\n    // present for any running application.\n    this.nmTokenSecretManager.removeNodeKey(nodeId);\n    this.nmLivelinessMonitor.register(nodeId);\n    \n    // Handle received container status, this should be processed after new\n    // RMNode inserted\n    if (!rmContext.isWorkPreservingRecoveryEnabled()) {\n      if (!request.getNMContainerStatuses().isEmpty()) {\n        LOG.info(\"received container statuses on node manager register :\"\n            + request.getNMContainerStatuses());\n        for (NMContainerStatus status : request.getNMContainerStatuses()) {\n          handleNMContainerStatus(status, nodeId);\n        }\n      }\n    }\n\n    // Update node\u0027s labels to RM\u0027s NodeLabelManager.\n    Set\u003cString\u003e nodeLabels \u003d NodeLabelsUtils.convertToStringSet(\n        request.getNodeLabels());\n    if (isDistributedNodeLabelsConf \u0026\u0026 nodeLabels !\u003d null) {\n      try {\n        updateNodeLabelsFromNMReport(nodeLabels, nodeId);\n        response.setAreNodeLabelsAcceptedByRM(true);\n      } catch (IOException ex) {\n        // Ensure the exception is captured in the response\n        response.setDiagnosticsMessage(ex.getMessage());\n        response.setAreNodeLabelsAcceptedByRM(false);\n      }\n    } else if (isDelegatedCentralizedNodeLabelsConf) {\n      this.rmContext.getRMDelegatedNodeLabelsUpdater().updateNodeLabels(nodeId);\n    }\n\n    StringBuilder message \u003d new StringBuilder();\n    message.append(\"NodeManager from node \").append(host).append(\"(cmPort: \")\n        .append(cmPort).append(\" httpPort: \");\n    message.append(httpPort).append(\") \")\n        .append(\"registered with capability: \").append(capability);\n    message.append(\", assigned nodeId \").append(nodeId);\n    if (response.getAreNodeLabelsAcceptedByRM()) {\n      message.append(\", node labels { \").append(\n          StringUtils.join(\",\", nodeLabels) + \" } \");\n    }\n\n    LOG.info(message.toString());\n    response.setNodeAction(NodeAction.NORMAL);\n    response.setRMIdentifier(ResourceManager.getClusterTimeStamp());\n    response.setRMVersion(YarnVersionInfo.getVersion());\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "30ee57ceb1e80c30ea3adfe7736d4d4c7d5c8386": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4939. The decommissioning Node should keep alive during NM restart. Contributed by sandflee.\n",
      "commitDate": "08/07/16 4:14 AM",
      "commitName": "30ee57ceb1e80c30ea3adfe7736d4d4c7d5c8386",
      "commitAuthor": "Junping Du",
      "commitDateOld": "29/05/16 8:54 AM",
      "commitNameOld": "42f90ab885d9693fcc1e52f9637f7de4111110ae",
      "commitAuthorOld": "Varun Vasudev",
      "daysBetweenCommits": 39.81,
      "commitsBetweenForRepo": 264,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,146 +1,147 @@\n   public RegisterNodeManagerResponse registerNodeManager(\n       RegisterNodeManagerRequest request) throws YarnException,\n       IOException {\n     NodeId nodeId \u003d request.getNodeId();\n     String host \u003d nodeId.getHost();\n     int cmPort \u003d nodeId.getPort();\n     int httpPort \u003d request.getHttpPort();\n     Resource capability \u003d request.getResource();\n     String nodeManagerVersion \u003d request.getNMVersion();\n \n     RegisterNodeManagerResponse response \u003d recordFactory\n         .newRecordInstance(RegisterNodeManagerResponse.class);\n \n     if (!minimumNodeManagerVersion.equals(\"NONE\")) {\n       if (minimumNodeManagerVersion.equals(\"EqualToRM\")) {\n         minimumNodeManagerVersion \u003d YarnVersionInfo.getVersion();\n       }\n \n       if ((nodeManagerVersion \u003d\u003d null) ||\n           (VersionUtil.compareVersions(nodeManagerVersion,minimumNodeManagerVersion)) \u003c 0) {\n         String message \u003d\n             \"Disallowed NodeManager Version \" + nodeManagerVersion\n                 + \", is less than the minimum version \"\n                 + minimumNodeManagerVersion + \" sending SHUTDOWN signal to \"\n                 + \"NodeManager.\";\n         LOG.info(message);\n         response.setDiagnosticsMessage(message);\n         response.setNodeAction(NodeAction.SHUTDOWN);\n         return response;\n       }\n     }\n \n     // Check if this node is a \u0027valid\u0027 node\n-    if (!this.nodesListManager.isValidNode(host)) {\n+    if (!this.nodesListManager.isValidNode(host) \u0026\u0026\n+        !isNodeInDecommissioning(nodeId)) {\n       String message \u003d\n           \"Disallowed NodeManager from  \" + host\n               + \", Sending SHUTDOWN signal to the NodeManager.\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     // check if node\u0027s capacity is load from dynamic-resources.xml\n     String nid \u003d nodeId.toString();\n \n     Resource dynamicLoadCapability \u003d loadNodeResourceFromDRConfiguration(nid);\n     if (dynamicLoadCapability !\u003d null) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Resource for node: \" + nid + \" is adjusted from: \" +\n             capability + \" to: \" + dynamicLoadCapability +\n             \" due to settings in dynamic-resources.xml.\");\n       }\n       capability \u003d dynamicLoadCapability;\n       // sync back with new resource.\n       response.setResource(capability);\n     }\n \n     // Check if this node has minimum allocations\n     if (capability.getMemorySize() \u003c minAllocMb\n         || capability.getVirtualCores() \u003c minAllocVcores) {\n       String message \u003d\n           \"NodeManager from  \" + host\n               + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n               + \" signal to the NodeManager.\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     response.setContainerTokenMasterKey(containerTokenSecretManager\n         .getCurrentKey());\n     response.setNMTokenMasterKey(nmTokenSecretManager\n         .getCurrentKey());\n \n     RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n         resolve(host), capability, nodeManagerVersion);\n \n     RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n     if (oldNode \u003d\u003d null) {\n       this.rmContext.getDispatcher().getEventHandler().handle(\n               new RMNodeStartedEvent(nodeId, request.getNMContainerStatuses(),\n                   request.getRunningApplications()));\n     } else {\n       LOG.info(\"Reconnect from the node at: \" + host);\n       this.nmLivelinessMonitor.unregister(nodeId);\n       // Reset heartbeat ID since node just restarted.\n       oldNode.resetLastNodeHeartBeatResponse();\n       this.rmContext\n           .getDispatcher()\n           .getEventHandler()\n           .handle(\n               new RMNodeReconnectEvent(nodeId, rmNode, request\n                   .getRunningApplications(), request.getNMContainerStatuses()));\n     }\n     // On every node manager register we will be clearing NMToken keys if\n     // present for any running application.\n     this.nmTokenSecretManager.removeNodeKey(nodeId);\n     this.nmLivelinessMonitor.register(nodeId);\n     \n     // Handle received container status, this should be processed after new\n     // RMNode inserted\n     if (!rmContext.isWorkPreservingRecoveryEnabled()) {\n       if (!request.getNMContainerStatuses().isEmpty()) {\n         LOG.info(\"received container statuses on node manager register :\"\n             + request.getNMContainerStatuses());\n         for (NMContainerStatus status : request.getNMContainerStatuses()) {\n           handleNMContainerStatus(status, nodeId);\n         }\n       }\n     }\n \n     // Update node\u0027s labels to RM\u0027s NodeLabelManager.\n     Set\u003cString\u003e nodeLabels \u003d NodeLabelsUtils.convertToStringSet(\n         request.getNodeLabels());\n     if (isDistributedNodeLabelsConf \u0026\u0026 nodeLabels !\u003d null) {\n       try {\n         updateNodeLabelsFromNMReport(nodeLabels, nodeId);\n         response.setAreNodeLabelsAcceptedByRM(true);\n       } catch (IOException ex) {\n         // Ensure the exception is captured in the response\n         response.setDiagnosticsMessage(ex.getMessage());\n         response.setAreNodeLabelsAcceptedByRM(false);\n       }\n     } else if (isDelegatedCentralizedNodeLabelsConf) {\n       this.rmContext.getRMDelegatedNodeLabelsUpdater().updateNodeLabels(nodeId);\n     }\n \n     StringBuilder message \u003d new StringBuilder();\n     message.append(\"NodeManager from node \").append(host).append(\"(cmPort: \")\n         .append(cmPort).append(\" httpPort: \");\n     message.append(httpPort).append(\") \")\n         .append(\"registered with capability: \").append(capability);\n     message.append(\", assigned nodeId \").append(nodeId);\n     if (response.getAreNodeLabelsAcceptedByRM()) {\n       message.append(\", node labels { \").append(\n           StringUtils.join(\",\", nodeLabels) + \" } \");\n     }\n \n     LOG.info(message.toString());\n     response.setNodeAction(NodeAction.NORMAL);\n     response.setRMIdentifier(ResourceManager.getClusterTimeStamp());\n     response.setRMVersion(YarnVersionInfo.getVersion());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterNodeManagerResponse registerNodeManager(\n      RegisterNodeManagerRequest request) throws YarnException,\n      IOException {\n    NodeId nodeId \u003d request.getNodeId();\n    String host \u003d nodeId.getHost();\n    int cmPort \u003d nodeId.getPort();\n    int httpPort \u003d request.getHttpPort();\n    Resource capability \u003d request.getResource();\n    String nodeManagerVersion \u003d request.getNMVersion();\n\n    RegisterNodeManagerResponse response \u003d recordFactory\n        .newRecordInstance(RegisterNodeManagerResponse.class);\n\n    if (!minimumNodeManagerVersion.equals(\"NONE\")) {\n      if (minimumNodeManagerVersion.equals(\"EqualToRM\")) {\n        minimumNodeManagerVersion \u003d YarnVersionInfo.getVersion();\n      }\n\n      if ((nodeManagerVersion \u003d\u003d null) ||\n          (VersionUtil.compareVersions(nodeManagerVersion,minimumNodeManagerVersion)) \u003c 0) {\n        String message \u003d\n            \"Disallowed NodeManager Version \" + nodeManagerVersion\n                + \", is less than the minimum version \"\n                + minimumNodeManagerVersion + \" sending SHUTDOWN signal to \"\n                + \"NodeManager.\";\n        LOG.info(message);\n        response.setDiagnosticsMessage(message);\n        response.setNodeAction(NodeAction.SHUTDOWN);\n        return response;\n      }\n    }\n\n    // Check if this node is a \u0027valid\u0027 node\n    if (!this.nodesListManager.isValidNode(host) \u0026\u0026\n        !isNodeInDecommissioning(nodeId)) {\n      String message \u003d\n          \"Disallowed NodeManager from  \" + host\n              + \", Sending SHUTDOWN signal to the NodeManager.\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    // check if node\u0027s capacity is load from dynamic-resources.xml\n    String nid \u003d nodeId.toString();\n\n    Resource dynamicLoadCapability \u003d loadNodeResourceFromDRConfiguration(nid);\n    if (dynamicLoadCapability !\u003d null) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Resource for node: \" + nid + \" is adjusted from: \" +\n            capability + \" to: \" + dynamicLoadCapability +\n            \" due to settings in dynamic-resources.xml.\");\n      }\n      capability \u003d dynamicLoadCapability;\n      // sync back with new resource.\n      response.setResource(capability);\n    }\n\n    // Check if this node has minimum allocations\n    if (capability.getMemorySize() \u003c minAllocMb\n        || capability.getVirtualCores() \u003c minAllocVcores) {\n      String message \u003d\n          \"NodeManager from  \" + host\n              + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n              + \" signal to the NodeManager.\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    response.setContainerTokenMasterKey(containerTokenSecretManager\n        .getCurrentKey());\n    response.setNMTokenMasterKey(nmTokenSecretManager\n        .getCurrentKey());\n\n    RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n        resolve(host), capability, nodeManagerVersion);\n\n    RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n    if (oldNode \u003d\u003d null) {\n      this.rmContext.getDispatcher().getEventHandler().handle(\n              new RMNodeStartedEvent(nodeId, request.getNMContainerStatuses(),\n                  request.getRunningApplications()));\n    } else {\n      LOG.info(\"Reconnect from the node at: \" + host);\n      this.nmLivelinessMonitor.unregister(nodeId);\n      // Reset heartbeat ID since node just restarted.\n      oldNode.resetLastNodeHeartBeatResponse();\n      this.rmContext\n          .getDispatcher()\n          .getEventHandler()\n          .handle(\n              new RMNodeReconnectEvent(nodeId, rmNode, request\n                  .getRunningApplications(), request.getNMContainerStatuses()));\n    }\n    // On every node manager register we will be clearing NMToken keys if\n    // present for any running application.\n    this.nmTokenSecretManager.removeNodeKey(nodeId);\n    this.nmLivelinessMonitor.register(nodeId);\n    \n    // Handle received container status, this should be processed after new\n    // RMNode inserted\n    if (!rmContext.isWorkPreservingRecoveryEnabled()) {\n      if (!request.getNMContainerStatuses().isEmpty()) {\n        LOG.info(\"received container statuses on node manager register :\"\n            + request.getNMContainerStatuses());\n        for (NMContainerStatus status : request.getNMContainerStatuses()) {\n          handleNMContainerStatus(status, nodeId);\n        }\n      }\n    }\n\n    // Update node\u0027s labels to RM\u0027s NodeLabelManager.\n    Set\u003cString\u003e nodeLabels \u003d NodeLabelsUtils.convertToStringSet(\n        request.getNodeLabels());\n    if (isDistributedNodeLabelsConf \u0026\u0026 nodeLabels !\u003d null) {\n      try {\n        updateNodeLabelsFromNMReport(nodeLabels, nodeId);\n        response.setAreNodeLabelsAcceptedByRM(true);\n      } catch (IOException ex) {\n        // Ensure the exception is captured in the response\n        response.setDiagnosticsMessage(ex.getMessage());\n        response.setAreNodeLabelsAcceptedByRM(false);\n      }\n    } else if (isDelegatedCentralizedNodeLabelsConf) {\n      this.rmContext.getRMDelegatedNodeLabelsUpdater().updateNodeLabels(nodeId);\n    }\n\n    StringBuilder message \u003d new StringBuilder();\n    message.append(\"NodeManager from node \").append(host).append(\"(cmPort: \")\n        .append(cmPort).append(\" httpPort: \");\n    message.append(httpPort).append(\") \")\n        .append(\"registered with capability: \").append(capability);\n    message.append(\", assigned nodeId \").append(nodeId);\n    if (response.getAreNodeLabelsAcceptedByRM()) {\n      message.append(\", node labels { \").append(\n          StringUtils.join(\",\", nodeLabels) + \" } \");\n    }\n\n    LOG.info(message.toString());\n    response.setNodeAction(NodeAction.NORMAL);\n    response.setRMIdentifier(ResourceManager.getClusterTimeStamp());\n    response.setRMVersion(YarnVersionInfo.getVersion());\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "42f90ab885d9693fcc1e52f9637f7de4111110ae": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4844. Add getMemorySize/getVirtualCoresSize to o.a.h.y.api.records.Resource. Contributed by Wangda Tan.\n",
      "commitDate": "29/05/16 8:54 AM",
      "commitName": "42f90ab885d9693fcc1e52f9637f7de4111110ae",
      "commitAuthor": "Varun Vasudev",
      "commitDateOld": "17/05/16 12:52 PM",
      "commitNameOld": "fa3bc3405dc2f8497faab45ba5c4de2caf4c29bc",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 11.83,
      "commitsBetweenForRepo": 92,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,146 +1,146 @@\n   public RegisterNodeManagerResponse registerNodeManager(\n       RegisterNodeManagerRequest request) throws YarnException,\n       IOException {\n     NodeId nodeId \u003d request.getNodeId();\n     String host \u003d nodeId.getHost();\n     int cmPort \u003d nodeId.getPort();\n     int httpPort \u003d request.getHttpPort();\n     Resource capability \u003d request.getResource();\n     String nodeManagerVersion \u003d request.getNMVersion();\n \n     RegisterNodeManagerResponse response \u003d recordFactory\n         .newRecordInstance(RegisterNodeManagerResponse.class);\n \n     if (!minimumNodeManagerVersion.equals(\"NONE\")) {\n       if (minimumNodeManagerVersion.equals(\"EqualToRM\")) {\n         minimumNodeManagerVersion \u003d YarnVersionInfo.getVersion();\n       }\n \n       if ((nodeManagerVersion \u003d\u003d null) ||\n           (VersionUtil.compareVersions(nodeManagerVersion,minimumNodeManagerVersion)) \u003c 0) {\n         String message \u003d\n             \"Disallowed NodeManager Version \" + nodeManagerVersion\n                 + \", is less than the minimum version \"\n                 + minimumNodeManagerVersion + \" sending SHUTDOWN signal to \"\n                 + \"NodeManager.\";\n         LOG.info(message);\n         response.setDiagnosticsMessage(message);\n         response.setNodeAction(NodeAction.SHUTDOWN);\n         return response;\n       }\n     }\n \n     // Check if this node is a \u0027valid\u0027 node\n     if (!this.nodesListManager.isValidNode(host)) {\n       String message \u003d\n           \"Disallowed NodeManager from  \" + host\n               + \", Sending SHUTDOWN signal to the NodeManager.\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     // check if node\u0027s capacity is load from dynamic-resources.xml\n     String nid \u003d nodeId.toString();\n \n     Resource dynamicLoadCapability \u003d loadNodeResourceFromDRConfiguration(nid);\n     if (dynamicLoadCapability !\u003d null) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Resource for node: \" + nid + \" is adjusted from: \" +\n             capability + \" to: \" + dynamicLoadCapability +\n             \" due to settings in dynamic-resources.xml.\");\n       }\n       capability \u003d dynamicLoadCapability;\n       // sync back with new resource.\n       response.setResource(capability);\n     }\n \n     // Check if this node has minimum allocations\n-    if (capability.getMemory() \u003c minAllocMb\n+    if (capability.getMemorySize() \u003c minAllocMb\n         || capability.getVirtualCores() \u003c minAllocVcores) {\n       String message \u003d\n           \"NodeManager from  \" + host\n               + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n               + \" signal to the NodeManager.\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     response.setContainerTokenMasterKey(containerTokenSecretManager\n         .getCurrentKey());\n     response.setNMTokenMasterKey(nmTokenSecretManager\n         .getCurrentKey());\n \n     RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n         resolve(host), capability, nodeManagerVersion);\n \n     RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n     if (oldNode \u003d\u003d null) {\n       this.rmContext.getDispatcher().getEventHandler().handle(\n               new RMNodeStartedEvent(nodeId, request.getNMContainerStatuses(),\n                   request.getRunningApplications()));\n     } else {\n       LOG.info(\"Reconnect from the node at: \" + host);\n       this.nmLivelinessMonitor.unregister(nodeId);\n       // Reset heartbeat ID since node just restarted.\n       oldNode.resetLastNodeHeartBeatResponse();\n       this.rmContext\n           .getDispatcher()\n           .getEventHandler()\n           .handle(\n               new RMNodeReconnectEvent(nodeId, rmNode, request\n                   .getRunningApplications(), request.getNMContainerStatuses()));\n     }\n     // On every node manager register we will be clearing NMToken keys if\n     // present for any running application.\n     this.nmTokenSecretManager.removeNodeKey(nodeId);\n     this.nmLivelinessMonitor.register(nodeId);\n     \n     // Handle received container status, this should be processed after new\n     // RMNode inserted\n     if (!rmContext.isWorkPreservingRecoveryEnabled()) {\n       if (!request.getNMContainerStatuses().isEmpty()) {\n         LOG.info(\"received container statuses on node manager register :\"\n             + request.getNMContainerStatuses());\n         for (NMContainerStatus status : request.getNMContainerStatuses()) {\n           handleNMContainerStatus(status, nodeId);\n         }\n       }\n     }\n \n     // Update node\u0027s labels to RM\u0027s NodeLabelManager.\n     Set\u003cString\u003e nodeLabels \u003d NodeLabelsUtils.convertToStringSet(\n         request.getNodeLabels());\n     if (isDistributedNodeLabelsConf \u0026\u0026 nodeLabels !\u003d null) {\n       try {\n         updateNodeLabelsFromNMReport(nodeLabels, nodeId);\n         response.setAreNodeLabelsAcceptedByRM(true);\n       } catch (IOException ex) {\n         // Ensure the exception is captured in the response\n         response.setDiagnosticsMessage(ex.getMessage());\n         response.setAreNodeLabelsAcceptedByRM(false);\n       }\n     } else if (isDelegatedCentralizedNodeLabelsConf) {\n       this.rmContext.getRMDelegatedNodeLabelsUpdater().updateNodeLabels(nodeId);\n     }\n \n     StringBuilder message \u003d new StringBuilder();\n     message.append(\"NodeManager from node \").append(host).append(\"(cmPort: \")\n         .append(cmPort).append(\" httpPort: \");\n     message.append(httpPort).append(\") \")\n         .append(\"registered with capability: \").append(capability);\n     message.append(\", assigned nodeId \").append(nodeId);\n     if (response.getAreNodeLabelsAcceptedByRM()) {\n       message.append(\", node labels { \").append(\n           StringUtils.join(\",\", nodeLabels) + \" } \");\n     }\n \n     LOG.info(message.toString());\n     response.setNodeAction(NodeAction.NORMAL);\n     response.setRMIdentifier(ResourceManager.getClusterTimeStamp());\n     response.setRMVersion(YarnVersionInfo.getVersion());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterNodeManagerResponse registerNodeManager(\n      RegisterNodeManagerRequest request) throws YarnException,\n      IOException {\n    NodeId nodeId \u003d request.getNodeId();\n    String host \u003d nodeId.getHost();\n    int cmPort \u003d nodeId.getPort();\n    int httpPort \u003d request.getHttpPort();\n    Resource capability \u003d request.getResource();\n    String nodeManagerVersion \u003d request.getNMVersion();\n\n    RegisterNodeManagerResponse response \u003d recordFactory\n        .newRecordInstance(RegisterNodeManagerResponse.class);\n\n    if (!minimumNodeManagerVersion.equals(\"NONE\")) {\n      if (minimumNodeManagerVersion.equals(\"EqualToRM\")) {\n        minimumNodeManagerVersion \u003d YarnVersionInfo.getVersion();\n      }\n\n      if ((nodeManagerVersion \u003d\u003d null) ||\n          (VersionUtil.compareVersions(nodeManagerVersion,minimumNodeManagerVersion)) \u003c 0) {\n        String message \u003d\n            \"Disallowed NodeManager Version \" + nodeManagerVersion\n                + \", is less than the minimum version \"\n                + minimumNodeManagerVersion + \" sending SHUTDOWN signal to \"\n                + \"NodeManager.\";\n        LOG.info(message);\n        response.setDiagnosticsMessage(message);\n        response.setNodeAction(NodeAction.SHUTDOWN);\n        return response;\n      }\n    }\n\n    // Check if this node is a \u0027valid\u0027 node\n    if (!this.nodesListManager.isValidNode(host)) {\n      String message \u003d\n          \"Disallowed NodeManager from  \" + host\n              + \", Sending SHUTDOWN signal to the NodeManager.\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    // check if node\u0027s capacity is load from dynamic-resources.xml\n    String nid \u003d nodeId.toString();\n\n    Resource dynamicLoadCapability \u003d loadNodeResourceFromDRConfiguration(nid);\n    if (dynamicLoadCapability !\u003d null) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Resource for node: \" + nid + \" is adjusted from: \" +\n            capability + \" to: \" + dynamicLoadCapability +\n            \" due to settings in dynamic-resources.xml.\");\n      }\n      capability \u003d dynamicLoadCapability;\n      // sync back with new resource.\n      response.setResource(capability);\n    }\n\n    // Check if this node has minimum allocations\n    if (capability.getMemorySize() \u003c minAllocMb\n        || capability.getVirtualCores() \u003c minAllocVcores) {\n      String message \u003d\n          \"NodeManager from  \" + host\n              + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n              + \" signal to the NodeManager.\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    response.setContainerTokenMasterKey(containerTokenSecretManager\n        .getCurrentKey());\n    response.setNMTokenMasterKey(nmTokenSecretManager\n        .getCurrentKey());\n\n    RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n        resolve(host), capability, nodeManagerVersion);\n\n    RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n    if (oldNode \u003d\u003d null) {\n      this.rmContext.getDispatcher().getEventHandler().handle(\n              new RMNodeStartedEvent(nodeId, request.getNMContainerStatuses(),\n                  request.getRunningApplications()));\n    } else {\n      LOG.info(\"Reconnect from the node at: \" + host);\n      this.nmLivelinessMonitor.unregister(nodeId);\n      // Reset heartbeat ID since node just restarted.\n      oldNode.resetLastNodeHeartBeatResponse();\n      this.rmContext\n          .getDispatcher()\n          .getEventHandler()\n          .handle(\n              new RMNodeReconnectEvent(nodeId, rmNode, request\n                  .getRunningApplications(), request.getNMContainerStatuses()));\n    }\n    // On every node manager register we will be clearing NMToken keys if\n    // present for any running application.\n    this.nmTokenSecretManager.removeNodeKey(nodeId);\n    this.nmLivelinessMonitor.register(nodeId);\n    \n    // Handle received container status, this should be processed after new\n    // RMNode inserted\n    if (!rmContext.isWorkPreservingRecoveryEnabled()) {\n      if (!request.getNMContainerStatuses().isEmpty()) {\n        LOG.info(\"received container statuses on node manager register :\"\n            + request.getNMContainerStatuses());\n        for (NMContainerStatus status : request.getNMContainerStatuses()) {\n          handleNMContainerStatus(status, nodeId);\n        }\n      }\n    }\n\n    // Update node\u0027s labels to RM\u0027s NodeLabelManager.\n    Set\u003cString\u003e nodeLabels \u003d NodeLabelsUtils.convertToStringSet(\n        request.getNodeLabels());\n    if (isDistributedNodeLabelsConf \u0026\u0026 nodeLabels !\u003d null) {\n      try {\n        updateNodeLabelsFromNMReport(nodeLabels, nodeId);\n        response.setAreNodeLabelsAcceptedByRM(true);\n      } catch (IOException ex) {\n        // Ensure the exception is captured in the response\n        response.setDiagnosticsMessage(ex.getMessage());\n        response.setAreNodeLabelsAcceptedByRM(false);\n      }\n    } else if (isDelegatedCentralizedNodeLabelsConf) {\n      this.rmContext.getRMDelegatedNodeLabelsUpdater().updateNodeLabels(nodeId);\n    }\n\n    StringBuilder message \u003d new StringBuilder();\n    message.append(\"NodeManager from node \").append(host).append(\"(cmPort: \")\n        .append(cmPort).append(\" httpPort: \");\n    message.append(httpPort).append(\") \")\n        .append(\"registered with capability: \").append(capability);\n    message.append(\", assigned nodeId \").append(nodeId);\n    if (response.getAreNodeLabelsAcceptedByRM()) {\n      message.append(\", node labels { \").append(\n          StringUtils.join(\",\", nodeLabels) + \" } \");\n    }\n\n    LOG.info(message.toString());\n    response.setNodeAction(NodeAction.NORMAL);\n    response.setRMIdentifier(ResourceManager.getClusterTimeStamp());\n    response.setRMVersion(YarnVersionInfo.getVersion());\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "fa3bc3405dc2f8497faab45ba5c4de2caf4c29bc": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4832. NM side resource value should get updated if change applied in RM side. Contributed by Junping Du\n",
      "commitDate": "17/05/16 12:52 PM",
      "commitName": "fa3bc3405dc2f8497faab45ba5c4de2caf4c29bc",
      "commitAuthor": "Jian He",
      "commitDateOld": "13/05/16 1:38 PM",
      "commitNameOld": "f0ac18d001d97914a9ee810b1fab56c5cebff830",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 3.97,
      "commitsBetweenForRepo": 25,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,144 +1,146 @@\n   public RegisterNodeManagerResponse registerNodeManager(\n       RegisterNodeManagerRequest request) throws YarnException,\n       IOException {\n     NodeId nodeId \u003d request.getNodeId();\n     String host \u003d nodeId.getHost();\n     int cmPort \u003d nodeId.getPort();\n     int httpPort \u003d request.getHttpPort();\n     Resource capability \u003d request.getResource();\n     String nodeManagerVersion \u003d request.getNMVersion();\n \n     RegisterNodeManagerResponse response \u003d recordFactory\n         .newRecordInstance(RegisterNodeManagerResponse.class);\n \n     if (!minimumNodeManagerVersion.equals(\"NONE\")) {\n       if (minimumNodeManagerVersion.equals(\"EqualToRM\")) {\n         minimumNodeManagerVersion \u003d YarnVersionInfo.getVersion();\n       }\n \n       if ((nodeManagerVersion \u003d\u003d null) ||\n           (VersionUtil.compareVersions(nodeManagerVersion,minimumNodeManagerVersion)) \u003c 0) {\n         String message \u003d\n             \"Disallowed NodeManager Version \" + nodeManagerVersion\n                 + \", is less than the minimum version \"\n                 + minimumNodeManagerVersion + \" sending SHUTDOWN signal to \"\n                 + \"NodeManager.\";\n         LOG.info(message);\n         response.setDiagnosticsMessage(message);\n         response.setNodeAction(NodeAction.SHUTDOWN);\n         return response;\n       }\n     }\n \n     // Check if this node is a \u0027valid\u0027 node\n     if (!this.nodesListManager.isValidNode(host)) {\n       String message \u003d\n           \"Disallowed NodeManager from  \" + host\n               + \", Sending SHUTDOWN signal to the NodeManager.\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     // check if node\u0027s capacity is load from dynamic-resources.xml\n-    String[] nodes \u003d this.drConf.getNodes();\n     String nid \u003d nodeId.toString();\n \n-    if (nodes !\u003d null \u0026\u0026 Arrays.asList(nodes).contains(nid)) {\n-      capability.setMemory(this.drConf.getMemoryPerNode(nid));\n-      capability.setVirtualCores(this.drConf.getVcoresPerNode(nid));\n+    Resource dynamicLoadCapability \u003d loadNodeResourceFromDRConfiguration(nid);\n+    if (dynamicLoadCapability !\u003d null) {\n       if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"Resource for node: \" + nid + \" is adjusted to \" +\n-            capability + \" due to settings in dynamic-resources.xml.\");\n+        LOG.debug(\"Resource for node: \" + nid + \" is adjusted from: \" +\n+            capability + \" to: \" + dynamicLoadCapability +\n+            \" due to settings in dynamic-resources.xml.\");\n       }\n+      capability \u003d dynamicLoadCapability;\n+      // sync back with new resource.\n+      response.setResource(capability);\n     }\n \n     // Check if this node has minimum allocations\n     if (capability.getMemory() \u003c minAllocMb\n         || capability.getVirtualCores() \u003c minAllocVcores) {\n       String message \u003d\n           \"NodeManager from  \" + host\n               + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n               + \" signal to the NodeManager.\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     response.setContainerTokenMasterKey(containerTokenSecretManager\n         .getCurrentKey());\n     response.setNMTokenMasterKey(nmTokenSecretManager\n         .getCurrentKey());\n \n     RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n         resolve(host), capability, nodeManagerVersion);\n \n     RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n     if (oldNode \u003d\u003d null) {\n       this.rmContext.getDispatcher().getEventHandler().handle(\n               new RMNodeStartedEvent(nodeId, request.getNMContainerStatuses(),\n                   request.getRunningApplications()));\n     } else {\n       LOG.info(\"Reconnect from the node at: \" + host);\n       this.nmLivelinessMonitor.unregister(nodeId);\n       // Reset heartbeat ID since node just restarted.\n       oldNode.resetLastNodeHeartBeatResponse();\n       this.rmContext\n           .getDispatcher()\n           .getEventHandler()\n           .handle(\n               new RMNodeReconnectEvent(nodeId, rmNode, request\n                   .getRunningApplications(), request.getNMContainerStatuses()));\n     }\n     // On every node manager register we will be clearing NMToken keys if\n     // present for any running application.\n     this.nmTokenSecretManager.removeNodeKey(nodeId);\n     this.nmLivelinessMonitor.register(nodeId);\n     \n     // Handle received container status, this should be processed after new\n     // RMNode inserted\n     if (!rmContext.isWorkPreservingRecoveryEnabled()) {\n       if (!request.getNMContainerStatuses().isEmpty()) {\n         LOG.info(\"received container statuses on node manager register :\"\n             + request.getNMContainerStatuses());\n         for (NMContainerStatus status : request.getNMContainerStatuses()) {\n           handleNMContainerStatus(status, nodeId);\n         }\n       }\n     }\n \n     // Update node\u0027s labels to RM\u0027s NodeLabelManager.\n     Set\u003cString\u003e nodeLabels \u003d NodeLabelsUtils.convertToStringSet(\n         request.getNodeLabels());\n     if (isDistributedNodeLabelsConf \u0026\u0026 nodeLabels !\u003d null) {\n       try {\n         updateNodeLabelsFromNMReport(nodeLabels, nodeId);\n         response.setAreNodeLabelsAcceptedByRM(true);\n       } catch (IOException ex) {\n         // Ensure the exception is captured in the response\n         response.setDiagnosticsMessage(ex.getMessage());\n         response.setAreNodeLabelsAcceptedByRM(false);\n       }\n     } else if (isDelegatedCentralizedNodeLabelsConf) {\n       this.rmContext.getRMDelegatedNodeLabelsUpdater().updateNodeLabels(nodeId);\n     }\n \n     StringBuilder message \u003d new StringBuilder();\n     message.append(\"NodeManager from node \").append(host).append(\"(cmPort: \")\n         .append(cmPort).append(\" httpPort: \");\n     message.append(httpPort).append(\") \")\n         .append(\"registered with capability: \").append(capability);\n     message.append(\", assigned nodeId \").append(nodeId);\n     if (response.getAreNodeLabelsAcceptedByRM()) {\n       message.append(\", node labels { \").append(\n           StringUtils.join(\",\", nodeLabels) + \" } \");\n     }\n \n     LOG.info(message.toString());\n     response.setNodeAction(NodeAction.NORMAL);\n     response.setRMIdentifier(ResourceManager.getClusterTimeStamp());\n     response.setRMVersion(YarnVersionInfo.getVersion());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterNodeManagerResponse registerNodeManager(\n      RegisterNodeManagerRequest request) throws YarnException,\n      IOException {\n    NodeId nodeId \u003d request.getNodeId();\n    String host \u003d nodeId.getHost();\n    int cmPort \u003d nodeId.getPort();\n    int httpPort \u003d request.getHttpPort();\n    Resource capability \u003d request.getResource();\n    String nodeManagerVersion \u003d request.getNMVersion();\n\n    RegisterNodeManagerResponse response \u003d recordFactory\n        .newRecordInstance(RegisterNodeManagerResponse.class);\n\n    if (!minimumNodeManagerVersion.equals(\"NONE\")) {\n      if (minimumNodeManagerVersion.equals(\"EqualToRM\")) {\n        minimumNodeManagerVersion \u003d YarnVersionInfo.getVersion();\n      }\n\n      if ((nodeManagerVersion \u003d\u003d null) ||\n          (VersionUtil.compareVersions(nodeManagerVersion,minimumNodeManagerVersion)) \u003c 0) {\n        String message \u003d\n            \"Disallowed NodeManager Version \" + nodeManagerVersion\n                + \", is less than the minimum version \"\n                + minimumNodeManagerVersion + \" sending SHUTDOWN signal to \"\n                + \"NodeManager.\";\n        LOG.info(message);\n        response.setDiagnosticsMessage(message);\n        response.setNodeAction(NodeAction.SHUTDOWN);\n        return response;\n      }\n    }\n\n    // Check if this node is a \u0027valid\u0027 node\n    if (!this.nodesListManager.isValidNode(host)) {\n      String message \u003d\n          \"Disallowed NodeManager from  \" + host\n              + \", Sending SHUTDOWN signal to the NodeManager.\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    // check if node\u0027s capacity is load from dynamic-resources.xml\n    String nid \u003d nodeId.toString();\n\n    Resource dynamicLoadCapability \u003d loadNodeResourceFromDRConfiguration(nid);\n    if (dynamicLoadCapability !\u003d null) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Resource for node: \" + nid + \" is adjusted from: \" +\n            capability + \" to: \" + dynamicLoadCapability +\n            \" due to settings in dynamic-resources.xml.\");\n      }\n      capability \u003d dynamicLoadCapability;\n      // sync back with new resource.\n      response.setResource(capability);\n    }\n\n    // Check if this node has minimum allocations\n    if (capability.getMemory() \u003c minAllocMb\n        || capability.getVirtualCores() \u003c minAllocVcores) {\n      String message \u003d\n          \"NodeManager from  \" + host\n              + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n              + \" signal to the NodeManager.\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    response.setContainerTokenMasterKey(containerTokenSecretManager\n        .getCurrentKey());\n    response.setNMTokenMasterKey(nmTokenSecretManager\n        .getCurrentKey());\n\n    RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n        resolve(host), capability, nodeManagerVersion);\n\n    RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n    if (oldNode \u003d\u003d null) {\n      this.rmContext.getDispatcher().getEventHandler().handle(\n              new RMNodeStartedEvent(nodeId, request.getNMContainerStatuses(),\n                  request.getRunningApplications()));\n    } else {\n      LOG.info(\"Reconnect from the node at: \" + host);\n      this.nmLivelinessMonitor.unregister(nodeId);\n      // Reset heartbeat ID since node just restarted.\n      oldNode.resetLastNodeHeartBeatResponse();\n      this.rmContext\n          .getDispatcher()\n          .getEventHandler()\n          .handle(\n              new RMNodeReconnectEvent(nodeId, rmNode, request\n                  .getRunningApplications(), request.getNMContainerStatuses()));\n    }\n    // On every node manager register we will be clearing NMToken keys if\n    // present for any running application.\n    this.nmTokenSecretManager.removeNodeKey(nodeId);\n    this.nmLivelinessMonitor.register(nodeId);\n    \n    // Handle received container status, this should be processed after new\n    // RMNode inserted\n    if (!rmContext.isWorkPreservingRecoveryEnabled()) {\n      if (!request.getNMContainerStatuses().isEmpty()) {\n        LOG.info(\"received container statuses on node manager register :\"\n            + request.getNMContainerStatuses());\n        for (NMContainerStatus status : request.getNMContainerStatuses()) {\n          handleNMContainerStatus(status, nodeId);\n        }\n      }\n    }\n\n    // Update node\u0027s labels to RM\u0027s NodeLabelManager.\n    Set\u003cString\u003e nodeLabels \u003d NodeLabelsUtils.convertToStringSet(\n        request.getNodeLabels());\n    if (isDistributedNodeLabelsConf \u0026\u0026 nodeLabels !\u003d null) {\n      try {\n        updateNodeLabelsFromNMReport(nodeLabels, nodeId);\n        response.setAreNodeLabelsAcceptedByRM(true);\n      } catch (IOException ex) {\n        // Ensure the exception is captured in the response\n        response.setDiagnosticsMessage(ex.getMessage());\n        response.setAreNodeLabelsAcceptedByRM(false);\n      }\n    } else if (isDelegatedCentralizedNodeLabelsConf) {\n      this.rmContext.getRMDelegatedNodeLabelsUpdater().updateNodeLabels(nodeId);\n    }\n\n    StringBuilder message \u003d new StringBuilder();\n    message.append(\"NodeManager from node \").append(host).append(\"(cmPort: \")\n        .append(cmPort).append(\" httpPort: \");\n    message.append(httpPort).append(\") \")\n        .append(\"registered with capability: \").append(capability);\n    message.append(\", assigned nodeId \").append(nodeId);\n    if (response.getAreNodeLabelsAcceptedByRM()) {\n      message.append(\", node labels { \").append(\n          StringUtils.join(\",\", nodeLabels) + \" } \");\n    }\n\n    LOG.info(message.toString());\n    response.setNodeAction(NodeAction.NORMAL);\n    response.setRMIdentifier(ResourceManager.getClusterTimeStamp());\n    response.setRMVersion(YarnVersionInfo.getVersion());\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "2a5da97f81d69b481e4d1324a47e64bb55b9407c": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"YARN-4311. Removing nodes from include and exclude lists will not remove them from decommissioned nodes list. Contributed by Kuhu Shukla\"\n\nThis reverts commit 1cbcd4a491e6a57d466c2897335614dc6770b475.\n",
      "commitDate": "11/04/16 8:51 AM",
      "commitName": "2a5da97f81d69b481e4d1324a47e64bb55b9407c",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "05/04/16 6:40 AM",
      "commitNameOld": "1cbcd4a491e6a57d466c2897335614dc6770b475",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 6.09,
      "commitsBetweenForRepo": 38,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,145 +1,144 @@\n   public RegisterNodeManagerResponse registerNodeManager(\n       RegisterNodeManagerRequest request) throws YarnException,\n       IOException {\n     NodeId nodeId \u003d request.getNodeId();\n     String host \u003d nodeId.getHost();\n     int cmPort \u003d nodeId.getPort();\n     int httpPort \u003d request.getHttpPort();\n     Resource capability \u003d request.getResource();\n     String nodeManagerVersion \u003d request.getNMVersion();\n \n     RegisterNodeManagerResponse response \u003d recordFactory\n         .newRecordInstance(RegisterNodeManagerResponse.class);\n \n     if (!minimumNodeManagerVersion.equals(\"NONE\")) {\n       if (minimumNodeManagerVersion.equals(\"EqualToRM\")) {\n         minimumNodeManagerVersion \u003d YarnVersionInfo.getVersion();\n       }\n \n       if ((nodeManagerVersion \u003d\u003d null) ||\n           (VersionUtil.compareVersions(nodeManagerVersion,minimumNodeManagerVersion)) \u003c 0) {\n         String message \u003d\n             \"Disallowed NodeManager Version \" + nodeManagerVersion\n                 + \", is less than the minimum version \"\n                 + minimumNodeManagerVersion + \" sending SHUTDOWN signal to \"\n                 + \"NodeManager.\";\n         LOG.info(message);\n         response.setDiagnosticsMessage(message);\n         response.setNodeAction(NodeAction.SHUTDOWN);\n         return response;\n       }\n     }\n \n     // Check if this node is a \u0027valid\u0027 node\n-    if (!this.nodesListManager.isValidNode(host) ||\n-        this.nodesListManager.isUntrackedNode(host)) {\n+    if (!this.nodesListManager.isValidNode(host)) {\n       String message \u003d\n           \"Disallowed NodeManager from  \" + host\n               + \", Sending SHUTDOWN signal to the NodeManager.\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     // check if node\u0027s capacity is load from dynamic-resources.xml\n     String[] nodes \u003d this.drConf.getNodes();\n     String nid \u003d nodeId.toString();\n \n     if (nodes !\u003d null \u0026\u0026 Arrays.asList(nodes).contains(nid)) {\n       capability.setMemory(this.drConf.getMemoryPerNode(nid));\n       capability.setVirtualCores(this.drConf.getVcoresPerNode(nid));\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Resource for node: \" + nid + \" is adjusted to \" +\n             capability + \" due to settings in dynamic-resources.xml.\");\n       }\n     }\n \n     // Check if this node has minimum allocations\n     if (capability.getMemory() \u003c minAllocMb\n         || capability.getVirtualCores() \u003c minAllocVcores) {\n       String message \u003d\n           \"NodeManager from  \" + host\n               + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n               + \" signal to the NodeManager.\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     response.setContainerTokenMasterKey(containerTokenSecretManager\n         .getCurrentKey());\n     response.setNMTokenMasterKey(nmTokenSecretManager\n         .getCurrentKey());\n \n     RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n         resolve(host), capability, nodeManagerVersion);\n \n     RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n     if (oldNode \u003d\u003d null) {\n       this.rmContext.getDispatcher().getEventHandler().handle(\n               new RMNodeStartedEvent(nodeId, request.getNMContainerStatuses(),\n                   request.getRunningApplications()));\n     } else {\n       LOG.info(\"Reconnect from the node at: \" + host);\n       this.nmLivelinessMonitor.unregister(nodeId);\n       // Reset heartbeat ID since node just restarted.\n       oldNode.resetLastNodeHeartBeatResponse();\n       this.rmContext\n           .getDispatcher()\n           .getEventHandler()\n           .handle(\n               new RMNodeReconnectEvent(nodeId, rmNode, request\n                   .getRunningApplications(), request.getNMContainerStatuses()));\n     }\n     // On every node manager register we will be clearing NMToken keys if\n     // present for any running application.\n     this.nmTokenSecretManager.removeNodeKey(nodeId);\n     this.nmLivelinessMonitor.register(nodeId);\n     \n     // Handle received container status, this should be processed after new\n     // RMNode inserted\n     if (!rmContext.isWorkPreservingRecoveryEnabled()) {\n       if (!request.getNMContainerStatuses().isEmpty()) {\n         LOG.info(\"received container statuses on node manager register :\"\n             + request.getNMContainerStatuses());\n         for (NMContainerStatus status : request.getNMContainerStatuses()) {\n           handleNMContainerStatus(status, nodeId);\n         }\n       }\n     }\n \n     // Update node\u0027s labels to RM\u0027s NodeLabelManager.\n     Set\u003cString\u003e nodeLabels \u003d NodeLabelsUtils.convertToStringSet(\n         request.getNodeLabels());\n     if (isDistributedNodeLabelsConf \u0026\u0026 nodeLabels !\u003d null) {\n       try {\n         updateNodeLabelsFromNMReport(nodeLabels, nodeId);\n         response.setAreNodeLabelsAcceptedByRM(true);\n       } catch (IOException ex) {\n         // Ensure the exception is captured in the response\n         response.setDiagnosticsMessage(ex.getMessage());\n         response.setAreNodeLabelsAcceptedByRM(false);\n       }\n     } else if (isDelegatedCentralizedNodeLabelsConf) {\n       this.rmContext.getRMDelegatedNodeLabelsUpdater().updateNodeLabels(nodeId);\n     }\n \n     StringBuilder message \u003d new StringBuilder();\n     message.append(\"NodeManager from node \").append(host).append(\"(cmPort: \")\n         .append(cmPort).append(\" httpPort: \");\n     message.append(httpPort).append(\") \")\n         .append(\"registered with capability: \").append(capability);\n     message.append(\", assigned nodeId \").append(nodeId);\n     if (response.getAreNodeLabelsAcceptedByRM()) {\n       message.append(\", node labels { \").append(\n           StringUtils.join(\",\", nodeLabels) + \" } \");\n     }\n \n     LOG.info(message.toString());\n     response.setNodeAction(NodeAction.NORMAL);\n     response.setRMIdentifier(ResourceManager.getClusterTimeStamp());\n     response.setRMVersion(YarnVersionInfo.getVersion());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterNodeManagerResponse registerNodeManager(\n      RegisterNodeManagerRequest request) throws YarnException,\n      IOException {\n    NodeId nodeId \u003d request.getNodeId();\n    String host \u003d nodeId.getHost();\n    int cmPort \u003d nodeId.getPort();\n    int httpPort \u003d request.getHttpPort();\n    Resource capability \u003d request.getResource();\n    String nodeManagerVersion \u003d request.getNMVersion();\n\n    RegisterNodeManagerResponse response \u003d recordFactory\n        .newRecordInstance(RegisterNodeManagerResponse.class);\n\n    if (!minimumNodeManagerVersion.equals(\"NONE\")) {\n      if (minimumNodeManagerVersion.equals(\"EqualToRM\")) {\n        minimumNodeManagerVersion \u003d YarnVersionInfo.getVersion();\n      }\n\n      if ((nodeManagerVersion \u003d\u003d null) ||\n          (VersionUtil.compareVersions(nodeManagerVersion,minimumNodeManagerVersion)) \u003c 0) {\n        String message \u003d\n            \"Disallowed NodeManager Version \" + nodeManagerVersion\n                + \", is less than the minimum version \"\n                + minimumNodeManagerVersion + \" sending SHUTDOWN signal to \"\n                + \"NodeManager.\";\n        LOG.info(message);\n        response.setDiagnosticsMessage(message);\n        response.setNodeAction(NodeAction.SHUTDOWN);\n        return response;\n      }\n    }\n\n    // Check if this node is a \u0027valid\u0027 node\n    if (!this.nodesListManager.isValidNode(host)) {\n      String message \u003d\n          \"Disallowed NodeManager from  \" + host\n              + \", Sending SHUTDOWN signal to the NodeManager.\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    // check if node\u0027s capacity is load from dynamic-resources.xml\n    String[] nodes \u003d this.drConf.getNodes();\n    String nid \u003d nodeId.toString();\n\n    if (nodes !\u003d null \u0026\u0026 Arrays.asList(nodes).contains(nid)) {\n      capability.setMemory(this.drConf.getMemoryPerNode(nid));\n      capability.setVirtualCores(this.drConf.getVcoresPerNode(nid));\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Resource for node: \" + nid + \" is adjusted to \" +\n            capability + \" due to settings in dynamic-resources.xml.\");\n      }\n    }\n\n    // Check if this node has minimum allocations\n    if (capability.getMemory() \u003c minAllocMb\n        || capability.getVirtualCores() \u003c minAllocVcores) {\n      String message \u003d\n          \"NodeManager from  \" + host\n              + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n              + \" signal to the NodeManager.\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    response.setContainerTokenMasterKey(containerTokenSecretManager\n        .getCurrentKey());\n    response.setNMTokenMasterKey(nmTokenSecretManager\n        .getCurrentKey());\n\n    RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n        resolve(host), capability, nodeManagerVersion);\n\n    RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n    if (oldNode \u003d\u003d null) {\n      this.rmContext.getDispatcher().getEventHandler().handle(\n              new RMNodeStartedEvent(nodeId, request.getNMContainerStatuses(),\n                  request.getRunningApplications()));\n    } else {\n      LOG.info(\"Reconnect from the node at: \" + host);\n      this.nmLivelinessMonitor.unregister(nodeId);\n      // Reset heartbeat ID since node just restarted.\n      oldNode.resetLastNodeHeartBeatResponse();\n      this.rmContext\n          .getDispatcher()\n          .getEventHandler()\n          .handle(\n              new RMNodeReconnectEvent(nodeId, rmNode, request\n                  .getRunningApplications(), request.getNMContainerStatuses()));\n    }\n    // On every node manager register we will be clearing NMToken keys if\n    // present for any running application.\n    this.nmTokenSecretManager.removeNodeKey(nodeId);\n    this.nmLivelinessMonitor.register(nodeId);\n    \n    // Handle received container status, this should be processed after new\n    // RMNode inserted\n    if (!rmContext.isWorkPreservingRecoveryEnabled()) {\n      if (!request.getNMContainerStatuses().isEmpty()) {\n        LOG.info(\"received container statuses on node manager register :\"\n            + request.getNMContainerStatuses());\n        for (NMContainerStatus status : request.getNMContainerStatuses()) {\n          handleNMContainerStatus(status, nodeId);\n        }\n      }\n    }\n\n    // Update node\u0027s labels to RM\u0027s NodeLabelManager.\n    Set\u003cString\u003e nodeLabels \u003d NodeLabelsUtils.convertToStringSet(\n        request.getNodeLabels());\n    if (isDistributedNodeLabelsConf \u0026\u0026 nodeLabels !\u003d null) {\n      try {\n        updateNodeLabelsFromNMReport(nodeLabels, nodeId);\n        response.setAreNodeLabelsAcceptedByRM(true);\n      } catch (IOException ex) {\n        // Ensure the exception is captured in the response\n        response.setDiagnosticsMessage(ex.getMessage());\n        response.setAreNodeLabelsAcceptedByRM(false);\n      }\n    } else if (isDelegatedCentralizedNodeLabelsConf) {\n      this.rmContext.getRMDelegatedNodeLabelsUpdater().updateNodeLabels(nodeId);\n    }\n\n    StringBuilder message \u003d new StringBuilder();\n    message.append(\"NodeManager from node \").append(host).append(\"(cmPort: \")\n        .append(cmPort).append(\" httpPort: \");\n    message.append(httpPort).append(\") \")\n        .append(\"registered with capability: \").append(capability);\n    message.append(\", assigned nodeId \").append(nodeId);\n    if (response.getAreNodeLabelsAcceptedByRM()) {\n      message.append(\", node labels { \").append(\n          StringUtils.join(\",\", nodeLabels) + \" } \");\n    }\n\n    LOG.info(message.toString());\n    response.setNodeAction(NodeAction.NORMAL);\n    response.setRMIdentifier(ResourceManager.getClusterTimeStamp());\n    response.setRMVersion(YarnVersionInfo.getVersion());\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "1cbcd4a491e6a57d466c2897335614dc6770b475": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4311. Removing nodes from include and exclude lists will not remove them from decommissioned nodes list. Contributed by Kuhu Shukla\n",
      "commitDate": "05/04/16 6:40 AM",
      "commitName": "1cbcd4a491e6a57d466c2897335614dc6770b475",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "28/03/16 11:12 AM",
      "commitNameOld": "524bc3c33aff301c1a8d60ed8e6a3b240e305045",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 7.81,
      "commitsBetweenForRepo": 52,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,144 +1,145 @@\n   public RegisterNodeManagerResponse registerNodeManager(\n       RegisterNodeManagerRequest request) throws YarnException,\n       IOException {\n     NodeId nodeId \u003d request.getNodeId();\n     String host \u003d nodeId.getHost();\n     int cmPort \u003d nodeId.getPort();\n     int httpPort \u003d request.getHttpPort();\n     Resource capability \u003d request.getResource();\n     String nodeManagerVersion \u003d request.getNMVersion();\n \n     RegisterNodeManagerResponse response \u003d recordFactory\n         .newRecordInstance(RegisterNodeManagerResponse.class);\n \n     if (!minimumNodeManagerVersion.equals(\"NONE\")) {\n       if (minimumNodeManagerVersion.equals(\"EqualToRM\")) {\n         minimumNodeManagerVersion \u003d YarnVersionInfo.getVersion();\n       }\n \n       if ((nodeManagerVersion \u003d\u003d null) ||\n           (VersionUtil.compareVersions(nodeManagerVersion,minimumNodeManagerVersion)) \u003c 0) {\n         String message \u003d\n             \"Disallowed NodeManager Version \" + nodeManagerVersion\n                 + \", is less than the minimum version \"\n                 + minimumNodeManagerVersion + \" sending SHUTDOWN signal to \"\n                 + \"NodeManager.\";\n         LOG.info(message);\n         response.setDiagnosticsMessage(message);\n         response.setNodeAction(NodeAction.SHUTDOWN);\n         return response;\n       }\n     }\n \n     // Check if this node is a \u0027valid\u0027 node\n-    if (!this.nodesListManager.isValidNode(host)) {\n+    if (!this.nodesListManager.isValidNode(host) ||\n+        this.nodesListManager.isUntrackedNode(host)) {\n       String message \u003d\n           \"Disallowed NodeManager from  \" + host\n               + \", Sending SHUTDOWN signal to the NodeManager.\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     // check if node\u0027s capacity is load from dynamic-resources.xml\n     String[] nodes \u003d this.drConf.getNodes();\n     String nid \u003d nodeId.toString();\n \n     if (nodes !\u003d null \u0026\u0026 Arrays.asList(nodes).contains(nid)) {\n       capability.setMemory(this.drConf.getMemoryPerNode(nid));\n       capability.setVirtualCores(this.drConf.getVcoresPerNode(nid));\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Resource for node: \" + nid + \" is adjusted to \" +\n             capability + \" due to settings in dynamic-resources.xml.\");\n       }\n     }\n \n     // Check if this node has minimum allocations\n     if (capability.getMemory() \u003c minAllocMb\n         || capability.getVirtualCores() \u003c minAllocVcores) {\n       String message \u003d\n           \"NodeManager from  \" + host\n               + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n               + \" signal to the NodeManager.\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     response.setContainerTokenMasterKey(containerTokenSecretManager\n         .getCurrentKey());\n     response.setNMTokenMasterKey(nmTokenSecretManager\n         .getCurrentKey());\n \n     RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n         resolve(host), capability, nodeManagerVersion);\n \n     RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n     if (oldNode \u003d\u003d null) {\n       this.rmContext.getDispatcher().getEventHandler().handle(\n               new RMNodeStartedEvent(nodeId, request.getNMContainerStatuses(),\n                   request.getRunningApplications()));\n     } else {\n       LOG.info(\"Reconnect from the node at: \" + host);\n       this.nmLivelinessMonitor.unregister(nodeId);\n       // Reset heartbeat ID since node just restarted.\n       oldNode.resetLastNodeHeartBeatResponse();\n       this.rmContext\n           .getDispatcher()\n           .getEventHandler()\n           .handle(\n               new RMNodeReconnectEvent(nodeId, rmNode, request\n                   .getRunningApplications(), request.getNMContainerStatuses()));\n     }\n     // On every node manager register we will be clearing NMToken keys if\n     // present for any running application.\n     this.nmTokenSecretManager.removeNodeKey(nodeId);\n     this.nmLivelinessMonitor.register(nodeId);\n     \n     // Handle received container status, this should be processed after new\n     // RMNode inserted\n     if (!rmContext.isWorkPreservingRecoveryEnabled()) {\n       if (!request.getNMContainerStatuses().isEmpty()) {\n         LOG.info(\"received container statuses on node manager register :\"\n             + request.getNMContainerStatuses());\n         for (NMContainerStatus status : request.getNMContainerStatuses()) {\n           handleNMContainerStatus(status, nodeId);\n         }\n       }\n     }\n \n     // Update node\u0027s labels to RM\u0027s NodeLabelManager.\n     Set\u003cString\u003e nodeLabels \u003d NodeLabelsUtils.convertToStringSet(\n         request.getNodeLabels());\n     if (isDistributedNodeLabelsConf \u0026\u0026 nodeLabels !\u003d null) {\n       try {\n         updateNodeLabelsFromNMReport(nodeLabels, nodeId);\n         response.setAreNodeLabelsAcceptedByRM(true);\n       } catch (IOException ex) {\n         // Ensure the exception is captured in the response\n         response.setDiagnosticsMessage(ex.getMessage());\n         response.setAreNodeLabelsAcceptedByRM(false);\n       }\n     } else if (isDelegatedCentralizedNodeLabelsConf) {\n       this.rmContext.getRMDelegatedNodeLabelsUpdater().updateNodeLabels(nodeId);\n     }\n \n     StringBuilder message \u003d new StringBuilder();\n     message.append(\"NodeManager from node \").append(host).append(\"(cmPort: \")\n         .append(cmPort).append(\" httpPort: \");\n     message.append(httpPort).append(\") \")\n         .append(\"registered with capability: \").append(capability);\n     message.append(\", assigned nodeId \").append(nodeId);\n     if (response.getAreNodeLabelsAcceptedByRM()) {\n       message.append(\", node labels { \").append(\n           StringUtils.join(\",\", nodeLabels) + \" } \");\n     }\n \n     LOG.info(message.toString());\n     response.setNodeAction(NodeAction.NORMAL);\n     response.setRMIdentifier(ResourceManager.getClusterTimeStamp());\n     response.setRMVersion(YarnVersionInfo.getVersion());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterNodeManagerResponse registerNodeManager(\n      RegisterNodeManagerRequest request) throws YarnException,\n      IOException {\n    NodeId nodeId \u003d request.getNodeId();\n    String host \u003d nodeId.getHost();\n    int cmPort \u003d nodeId.getPort();\n    int httpPort \u003d request.getHttpPort();\n    Resource capability \u003d request.getResource();\n    String nodeManagerVersion \u003d request.getNMVersion();\n\n    RegisterNodeManagerResponse response \u003d recordFactory\n        .newRecordInstance(RegisterNodeManagerResponse.class);\n\n    if (!minimumNodeManagerVersion.equals(\"NONE\")) {\n      if (minimumNodeManagerVersion.equals(\"EqualToRM\")) {\n        minimumNodeManagerVersion \u003d YarnVersionInfo.getVersion();\n      }\n\n      if ((nodeManagerVersion \u003d\u003d null) ||\n          (VersionUtil.compareVersions(nodeManagerVersion,minimumNodeManagerVersion)) \u003c 0) {\n        String message \u003d\n            \"Disallowed NodeManager Version \" + nodeManagerVersion\n                + \", is less than the minimum version \"\n                + minimumNodeManagerVersion + \" sending SHUTDOWN signal to \"\n                + \"NodeManager.\";\n        LOG.info(message);\n        response.setDiagnosticsMessage(message);\n        response.setNodeAction(NodeAction.SHUTDOWN);\n        return response;\n      }\n    }\n\n    // Check if this node is a \u0027valid\u0027 node\n    if (!this.nodesListManager.isValidNode(host) ||\n        this.nodesListManager.isUntrackedNode(host)) {\n      String message \u003d\n          \"Disallowed NodeManager from  \" + host\n              + \", Sending SHUTDOWN signal to the NodeManager.\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    // check if node\u0027s capacity is load from dynamic-resources.xml\n    String[] nodes \u003d this.drConf.getNodes();\n    String nid \u003d nodeId.toString();\n\n    if (nodes !\u003d null \u0026\u0026 Arrays.asList(nodes).contains(nid)) {\n      capability.setMemory(this.drConf.getMemoryPerNode(nid));\n      capability.setVirtualCores(this.drConf.getVcoresPerNode(nid));\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Resource for node: \" + nid + \" is adjusted to \" +\n            capability + \" due to settings in dynamic-resources.xml.\");\n      }\n    }\n\n    // Check if this node has minimum allocations\n    if (capability.getMemory() \u003c minAllocMb\n        || capability.getVirtualCores() \u003c minAllocVcores) {\n      String message \u003d\n          \"NodeManager from  \" + host\n              + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n              + \" signal to the NodeManager.\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    response.setContainerTokenMasterKey(containerTokenSecretManager\n        .getCurrentKey());\n    response.setNMTokenMasterKey(nmTokenSecretManager\n        .getCurrentKey());\n\n    RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n        resolve(host), capability, nodeManagerVersion);\n\n    RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n    if (oldNode \u003d\u003d null) {\n      this.rmContext.getDispatcher().getEventHandler().handle(\n              new RMNodeStartedEvent(nodeId, request.getNMContainerStatuses(),\n                  request.getRunningApplications()));\n    } else {\n      LOG.info(\"Reconnect from the node at: \" + host);\n      this.nmLivelinessMonitor.unregister(nodeId);\n      // Reset heartbeat ID since node just restarted.\n      oldNode.resetLastNodeHeartBeatResponse();\n      this.rmContext\n          .getDispatcher()\n          .getEventHandler()\n          .handle(\n              new RMNodeReconnectEvent(nodeId, rmNode, request\n                  .getRunningApplications(), request.getNMContainerStatuses()));\n    }\n    // On every node manager register we will be clearing NMToken keys if\n    // present for any running application.\n    this.nmTokenSecretManager.removeNodeKey(nodeId);\n    this.nmLivelinessMonitor.register(nodeId);\n    \n    // Handle received container status, this should be processed after new\n    // RMNode inserted\n    if (!rmContext.isWorkPreservingRecoveryEnabled()) {\n      if (!request.getNMContainerStatuses().isEmpty()) {\n        LOG.info(\"received container statuses on node manager register :\"\n            + request.getNMContainerStatuses());\n        for (NMContainerStatus status : request.getNMContainerStatuses()) {\n          handleNMContainerStatus(status, nodeId);\n        }\n      }\n    }\n\n    // Update node\u0027s labels to RM\u0027s NodeLabelManager.\n    Set\u003cString\u003e nodeLabels \u003d NodeLabelsUtils.convertToStringSet(\n        request.getNodeLabels());\n    if (isDistributedNodeLabelsConf \u0026\u0026 nodeLabels !\u003d null) {\n      try {\n        updateNodeLabelsFromNMReport(nodeLabels, nodeId);\n        response.setAreNodeLabelsAcceptedByRM(true);\n      } catch (IOException ex) {\n        // Ensure the exception is captured in the response\n        response.setDiagnosticsMessage(ex.getMessage());\n        response.setAreNodeLabelsAcceptedByRM(false);\n      }\n    } else if (isDelegatedCentralizedNodeLabelsConf) {\n      this.rmContext.getRMDelegatedNodeLabelsUpdater().updateNodeLabels(nodeId);\n    }\n\n    StringBuilder message \u003d new StringBuilder();\n    message.append(\"NodeManager from node \").append(host).append(\"(cmPort: \")\n        .append(cmPort).append(\" httpPort: \");\n    message.append(httpPort).append(\") \")\n        .append(\"registered with capability: \").append(capability);\n    message.append(\", assigned nodeId \").append(nodeId);\n    if (response.getAreNodeLabelsAcceptedByRM()) {\n      message.append(\", node labels { \").append(\n          StringUtils.join(\",\", nodeLabels) + \" } \");\n    }\n\n    LOG.info(message.toString());\n    response.setNodeAction(NodeAction.NORMAL);\n    response.setRMIdentifier(ResourceManager.getClusterTimeStamp());\n    response.setRMVersion(YarnVersionInfo.getVersion());\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "524bc3c33aff301c1a8d60ed8e6a3b240e305045": {
      "type": "Ybodychange",
      "commitMessage": "YARN-998. Keep NM resource updated through dynamic resource config for RM/NM restart. Contributed by Junping Du\n",
      "commitDate": "28/03/16 11:12 AM",
      "commitName": "524bc3c33aff301c1a8d60ed8e6a3b240e305045",
      "commitAuthor": "Jian He",
      "commitDateOld": "29/12/15 3:58 PM",
      "commitNameOld": "52734134116eb4b18686e308d00e71e7e903383e",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 89.76,
      "commitsBetweenForRepo": 566,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,131 +1,144 @@\n   public RegisterNodeManagerResponse registerNodeManager(\n       RegisterNodeManagerRequest request) throws YarnException,\n       IOException {\n     NodeId nodeId \u003d request.getNodeId();\n     String host \u003d nodeId.getHost();\n     int cmPort \u003d nodeId.getPort();\n     int httpPort \u003d request.getHttpPort();\n     Resource capability \u003d request.getResource();\n     String nodeManagerVersion \u003d request.getNMVersion();\n \n     RegisterNodeManagerResponse response \u003d recordFactory\n         .newRecordInstance(RegisterNodeManagerResponse.class);\n \n     if (!minimumNodeManagerVersion.equals(\"NONE\")) {\n       if (minimumNodeManagerVersion.equals(\"EqualToRM\")) {\n         minimumNodeManagerVersion \u003d YarnVersionInfo.getVersion();\n       }\n \n       if ((nodeManagerVersion \u003d\u003d null) ||\n           (VersionUtil.compareVersions(nodeManagerVersion,minimumNodeManagerVersion)) \u003c 0) {\n         String message \u003d\n             \"Disallowed NodeManager Version \" + nodeManagerVersion\n                 + \", is less than the minimum version \"\n                 + minimumNodeManagerVersion + \" sending SHUTDOWN signal to \"\n                 + \"NodeManager.\";\n         LOG.info(message);\n         response.setDiagnosticsMessage(message);\n         response.setNodeAction(NodeAction.SHUTDOWN);\n         return response;\n       }\n     }\n \n     // Check if this node is a \u0027valid\u0027 node\n     if (!this.nodesListManager.isValidNode(host)) {\n       String message \u003d\n           \"Disallowed NodeManager from  \" + host\n               + \", Sending SHUTDOWN signal to the NodeManager.\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n+    // check if node\u0027s capacity is load from dynamic-resources.xml\n+    String[] nodes \u003d this.drConf.getNodes();\n+    String nid \u003d nodeId.toString();\n+\n+    if (nodes !\u003d null \u0026\u0026 Arrays.asList(nodes).contains(nid)) {\n+      capability.setMemory(this.drConf.getMemoryPerNode(nid));\n+      capability.setVirtualCores(this.drConf.getVcoresPerNode(nid));\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Resource for node: \" + nid + \" is adjusted to \" +\n+            capability + \" due to settings in dynamic-resources.xml.\");\n+      }\n+    }\n+\n     // Check if this node has minimum allocations\n     if (capability.getMemory() \u003c minAllocMb\n         || capability.getVirtualCores() \u003c minAllocVcores) {\n       String message \u003d\n           \"NodeManager from  \" + host\n               + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n               + \" signal to the NodeManager.\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     response.setContainerTokenMasterKey(containerTokenSecretManager\n         .getCurrentKey());\n     response.setNMTokenMasterKey(nmTokenSecretManager\n-        .getCurrentKey());    \n+        .getCurrentKey());\n \n     RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n         resolve(host), capability, nodeManagerVersion);\n \n     RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n     if (oldNode \u003d\u003d null) {\n       this.rmContext.getDispatcher().getEventHandler().handle(\n               new RMNodeStartedEvent(nodeId, request.getNMContainerStatuses(),\n                   request.getRunningApplications()));\n     } else {\n       LOG.info(\"Reconnect from the node at: \" + host);\n       this.nmLivelinessMonitor.unregister(nodeId);\n       // Reset heartbeat ID since node just restarted.\n       oldNode.resetLastNodeHeartBeatResponse();\n       this.rmContext\n           .getDispatcher()\n           .getEventHandler()\n           .handle(\n               new RMNodeReconnectEvent(nodeId, rmNode, request\n                   .getRunningApplications(), request.getNMContainerStatuses()));\n     }\n     // On every node manager register we will be clearing NMToken keys if\n     // present for any running application.\n     this.nmTokenSecretManager.removeNodeKey(nodeId);\n     this.nmLivelinessMonitor.register(nodeId);\n     \n     // Handle received container status, this should be processed after new\n     // RMNode inserted\n     if (!rmContext.isWorkPreservingRecoveryEnabled()) {\n       if (!request.getNMContainerStatuses().isEmpty()) {\n         LOG.info(\"received container statuses on node manager register :\"\n             + request.getNMContainerStatuses());\n         for (NMContainerStatus status : request.getNMContainerStatuses()) {\n           handleNMContainerStatus(status, nodeId);\n         }\n       }\n     }\n \n     // Update node\u0027s labels to RM\u0027s NodeLabelManager.\n     Set\u003cString\u003e nodeLabels \u003d NodeLabelsUtils.convertToStringSet(\n         request.getNodeLabels());\n     if (isDistributedNodeLabelsConf \u0026\u0026 nodeLabels !\u003d null) {\n       try {\n         updateNodeLabelsFromNMReport(nodeLabels, nodeId);\n         response.setAreNodeLabelsAcceptedByRM(true);\n       } catch (IOException ex) {\n         // Ensure the exception is captured in the response\n         response.setDiagnosticsMessage(ex.getMessage());\n         response.setAreNodeLabelsAcceptedByRM(false);\n       }\n     } else if (isDelegatedCentralizedNodeLabelsConf) {\n       this.rmContext.getRMDelegatedNodeLabelsUpdater().updateNodeLabels(nodeId);\n     }\n \n     StringBuilder message \u003d new StringBuilder();\n     message.append(\"NodeManager from node \").append(host).append(\"(cmPort: \")\n         .append(cmPort).append(\" httpPort: \");\n     message.append(httpPort).append(\") \")\n         .append(\"registered with capability: \").append(capability);\n     message.append(\", assigned nodeId \").append(nodeId);\n     if (response.getAreNodeLabelsAcceptedByRM()) {\n       message.append(\", node labels { \").append(\n           StringUtils.join(\",\", nodeLabels) + \" } \");\n     }\n \n     LOG.info(message.toString());\n     response.setNodeAction(NodeAction.NORMAL);\n     response.setRMIdentifier(ResourceManager.getClusterTimeStamp());\n     response.setRMVersion(YarnVersionInfo.getVersion());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterNodeManagerResponse registerNodeManager(\n      RegisterNodeManagerRequest request) throws YarnException,\n      IOException {\n    NodeId nodeId \u003d request.getNodeId();\n    String host \u003d nodeId.getHost();\n    int cmPort \u003d nodeId.getPort();\n    int httpPort \u003d request.getHttpPort();\n    Resource capability \u003d request.getResource();\n    String nodeManagerVersion \u003d request.getNMVersion();\n\n    RegisterNodeManagerResponse response \u003d recordFactory\n        .newRecordInstance(RegisterNodeManagerResponse.class);\n\n    if (!minimumNodeManagerVersion.equals(\"NONE\")) {\n      if (minimumNodeManagerVersion.equals(\"EqualToRM\")) {\n        minimumNodeManagerVersion \u003d YarnVersionInfo.getVersion();\n      }\n\n      if ((nodeManagerVersion \u003d\u003d null) ||\n          (VersionUtil.compareVersions(nodeManagerVersion,minimumNodeManagerVersion)) \u003c 0) {\n        String message \u003d\n            \"Disallowed NodeManager Version \" + nodeManagerVersion\n                + \", is less than the minimum version \"\n                + minimumNodeManagerVersion + \" sending SHUTDOWN signal to \"\n                + \"NodeManager.\";\n        LOG.info(message);\n        response.setDiagnosticsMessage(message);\n        response.setNodeAction(NodeAction.SHUTDOWN);\n        return response;\n      }\n    }\n\n    // Check if this node is a \u0027valid\u0027 node\n    if (!this.nodesListManager.isValidNode(host)) {\n      String message \u003d\n          \"Disallowed NodeManager from  \" + host\n              + \", Sending SHUTDOWN signal to the NodeManager.\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    // check if node\u0027s capacity is load from dynamic-resources.xml\n    String[] nodes \u003d this.drConf.getNodes();\n    String nid \u003d nodeId.toString();\n\n    if (nodes !\u003d null \u0026\u0026 Arrays.asList(nodes).contains(nid)) {\n      capability.setMemory(this.drConf.getMemoryPerNode(nid));\n      capability.setVirtualCores(this.drConf.getVcoresPerNode(nid));\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Resource for node: \" + nid + \" is adjusted to \" +\n            capability + \" due to settings in dynamic-resources.xml.\");\n      }\n    }\n\n    // Check if this node has minimum allocations\n    if (capability.getMemory() \u003c minAllocMb\n        || capability.getVirtualCores() \u003c minAllocVcores) {\n      String message \u003d\n          \"NodeManager from  \" + host\n              + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n              + \" signal to the NodeManager.\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    response.setContainerTokenMasterKey(containerTokenSecretManager\n        .getCurrentKey());\n    response.setNMTokenMasterKey(nmTokenSecretManager\n        .getCurrentKey());\n\n    RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n        resolve(host), capability, nodeManagerVersion);\n\n    RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n    if (oldNode \u003d\u003d null) {\n      this.rmContext.getDispatcher().getEventHandler().handle(\n              new RMNodeStartedEvent(nodeId, request.getNMContainerStatuses(),\n                  request.getRunningApplications()));\n    } else {\n      LOG.info(\"Reconnect from the node at: \" + host);\n      this.nmLivelinessMonitor.unregister(nodeId);\n      // Reset heartbeat ID since node just restarted.\n      oldNode.resetLastNodeHeartBeatResponse();\n      this.rmContext\n          .getDispatcher()\n          .getEventHandler()\n          .handle(\n              new RMNodeReconnectEvent(nodeId, rmNode, request\n                  .getRunningApplications(), request.getNMContainerStatuses()));\n    }\n    // On every node manager register we will be clearing NMToken keys if\n    // present for any running application.\n    this.nmTokenSecretManager.removeNodeKey(nodeId);\n    this.nmLivelinessMonitor.register(nodeId);\n    \n    // Handle received container status, this should be processed after new\n    // RMNode inserted\n    if (!rmContext.isWorkPreservingRecoveryEnabled()) {\n      if (!request.getNMContainerStatuses().isEmpty()) {\n        LOG.info(\"received container statuses on node manager register :\"\n            + request.getNMContainerStatuses());\n        for (NMContainerStatus status : request.getNMContainerStatuses()) {\n          handleNMContainerStatus(status, nodeId);\n        }\n      }\n    }\n\n    // Update node\u0027s labels to RM\u0027s NodeLabelManager.\n    Set\u003cString\u003e nodeLabels \u003d NodeLabelsUtils.convertToStringSet(\n        request.getNodeLabels());\n    if (isDistributedNodeLabelsConf \u0026\u0026 nodeLabels !\u003d null) {\n      try {\n        updateNodeLabelsFromNMReport(nodeLabels, nodeId);\n        response.setAreNodeLabelsAcceptedByRM(true);\n      } catch (IOException ex) {\n        // Ensure the exception is captured in the response\n        response.setDiagnosticsMessage(ex.getMessage());\n        response.setAreNodeLabelsAcceptedByRM(false);\n      }\n    } else if (isDelegatedCentralizedNodeLabelsConf) {\n      this.rmContext.getRMDelegatedNodeLabelsUpdater().updateNodeLabels(nodeId);\n    }\n\n    StringBuilder message \u003d new StringBuilder();\n    message.append(\"NodeManager from node \").append(host).append(\"(cmPort: \")\n        .append(cmPort).append(\" httpPort: \");\n    message.append(httpPort).append(\") \")\n        .append(\"registered with capability: \").append(capability);\n    message.append(\", assigned nodeId \").append(nodeId);\n    if (response.getAreNodeLabelsAcceptedByRM()) {\n      message.append(\", node labels { \").append(\n          StringUtils.join(\",\", nodeLabels) + \" } \");\n    }\n\n    LOG.info(message.toString());\n    response.setNodeAction(NodeAction.NORMAL);\n    response.setRMIdentifier(ResourceManager.getClusterTimeStamp());\n    response.setRMVersion(YarnVersionInfo.getVersion());\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "db9304788187c700647c4d84caeb3b5ad6d868d8": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3964. Support NodeLabelsProvider at Resource Manager side.\nContributed by Dian Fu.\n",
      "commitDate": "10/10/15 10:51 PM",
      "commitName": "db9304788187c700647c4d84caeb3b5ad6d868d8",
      "commitAuthor": "Devaraj K",
      "commitDateOld": "23/09/15 1:29 PM",
      "commitNameOld": "89cab1ba5f0671f8ef30dbe7432079c18362b434",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 17.39,
      "commitsBetweenForRepo": 126,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,128 +1,131 @@\n   public RegisterNodeManagerResponse registerNodeManager(\n       RegisterNodeManagerRequest request) throws YarnException,\n       IOException {\n     NodeId nodeId \u003d request.getNodeId();\n     String host \u003d nodeId.getHost();\n     int cmPort \u003d nodeId.getPort();\n     int httpPort \u003d request.getHttpPort();\n     Resource capability \u003d request.getResource();\n     String nodeManagerVersion \u003d request.getNMVersion();\n \n     RegisterNodeManagerResponse response \u003d recordFactory\n         .newRecordInstance(RegisterNodeManagerResponse.class);\n \n     if (!minimumNodeManagerVersion.equals(\"NONE\")) {\n       if (minimumNodeManagerVersion.equals(\"EqualToRM\")) {\n         minimumNodeManagerVersion \u003d YarnVersionInfo.getVersion();\n       }\n \n       if ((nodeManagerVersion \u003d\u003d null) ||\n           (VersionUtil.compareVersions(nodeManagerVersion,minimumNodeManagerVersion)) \u003c 0) {\n         String message \u003d\n             \"Disallowed NodeManager Version \" + nodeManagerVersion\n                 + \", is less than the minimum version \"\n                 + minimumNodeManagerVersion + \" sending SHUTDOWN signal to \"\n                 + \"NodeManager.\";\n         LOG.info(message);\n         response.setDiagnosticsMessage(message);\n         response.setNodeAction(NodeAction.SHUTDOWN);\n         return response;\n       }\n     }\n \n     // Check if this node is a \u0027valid\u0027 node\n     if (!this.nodesListManager.isValidNode(host)) {\n       String message \u003d\n           \"Disallowed NodeManager from  \" + host\n               + \", Sending SHUTDOWN signal to the NodeManager.\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     // Check if this node has minimum allocations\n     if (capability.getMemory() \u003c minAllocMb\n         || capability.getVirtualCores() \u003c minAllocVcores) {\n       String message \u003d\n           \"NodeManager from  \" + host\n               + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n               + \" signal to the NodeManager.\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     response.setContainerTokenMasterKey(containerTokenSecretManager\n         .getCurrentKey());\n     response.setNMTokenMasterKey(nmTokenSecretManager\n         .getCurrentKey());    \n \n     RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n         resolve(host), capability, nodeManagerVersion);\n \n     RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n     if (oldNode \u003d\u003d null) {\n       this.rmContext.getDispatcher().getEventHandler().handle(\n               new RMNodeStartedEvent(nodeId, request.getNMContainerStatuses(),\n                   request.getRunningApplications()));\n     } else {\n       LOG.info(\"Reconnect from the node at: \" + host);\n       this.nmLivelinessMonitor.unregister(nodeId);\n       // Reset heartbeat ID since node just restarted.\n       oldNode.resetLastNodeHeartBeatResponse();\n       this.rmContext\n           .getDispatcher()\n           .getEventHandler()\n           .handle(\n               new RMNodeReconnectEvent(nodeId, rmNode, request\n                   .getRunningApplications(), request.getNMContainerStatuses()));\n     }\n     // On every node manager register we will be clearing NMToken keys if\n     // present for any running application.\n     this.nmTokenSecretManager.removeNodeKey(nodeId);\n     this.nmLivelinessMonitor.register(nodeId);\n     \n     // Handle received container status, this should be processed after new\n     // RMNode inserted\n     if (!rmContext.isWorkPreservingRecoveryEnabled()) {\n       if (!request.getNMContainerStatuses().isEmpty()) {\n         LOG.info(\"received container statuses on node manager register :\"\n             + request.getNMContainerStatuses());\n         for (NMContainerStatus status : request.getNMContainerStatuses()) {\n           handleNMContainerStatus(status, nodeId);\n         }\n       }\n     }\n \n     // Update node\u0027s labels to RM\u0027s NodeLabelManager.\n-    Set\u003cString\u003e nodeLabels \u003d convertToStringSet(request.getNodeLabels());\n+    Set\u003cString\u003e nodeLabels \u003d NodeLabelsUtils.convertToStringSet(\n+        request.getNodeLabels());\n     if (isDistributedNodeLabelsConf \u0026\u0026 nodeLabels !\u003d null) {\n       try {\n         updateNodeLabelsFromNMReport(nodeLabels, nodeId);\n         response.setAreNodeLabelsAcceptedByRM(true);\n       } catch (IOException ex) {\n         // Ensure the exception is captured in the response\n         response.setDiagnosticsMessage(ex.getMessage());\n         response.setAreNodeLabelsAcceptedByRM(false);\n       }\n+    } else if (isDelegatedCentralizedNodeLabelsConf) {\n+      this.rmContext.getRMDelegatedNodeLabelsUpdater().updateNodeLabels(nodeId);\n     }\n \n     StringBuilder message \u003d new StringBuilder();\n     message.append(\"NodeManager from node \").append(host).append(\"(cmPort: \")\n         .append(cmPort).append(\" httpPort: \");\n     message.append(httpPort).append(\") \")\n         .append(\"registered with capability: \").append(capability);\n     message.append(\", assigned nodeId \").append(nodeId);\n     if (response.getAreNodeLabelsAcceptedByRM()) {\n       message.append(\", node labels { \").append(\n           StringUtils.join(\",\", nodeLabels) + \" } \");\n     }\n \n     LOG.info(message.toString());\n     response.setNodeAction(NodeAction.NORMAL);\n     response.setRMIdentifier(ResourceManager.getClusterTimeStamp());\n     response.setRMVersion(YarnVersionInfo.getVersion());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterNodeManagerResponse registerNodeManager(\n      RegisterNodeManagerRequest request) throws YarnException,\n      IOException {\n    NodeId nodeId \u003d request.getNodeId();\n    String host \u003d nodeId.getHost();\n    int cmPort \u003d nodeId.getPort();\n    int httpPort \u003d request.getHttpPort();\n    Resource capability \u003d request.getResource();\n    String nodeManagerVersion \u003d request.getNMVersion();\n\n    RegisterNodeManagerResponse response \u003d recordFactory\n        .newRecordInstance(RegisterNodeManagerResponse.class);\n\n    if (!minimumNodeManagerVersion.equals(\"NONE\")) {\n      if (minimumNodeManagerVersion.equals(\"EqualToRM\")) {\n        minimumNodeManagerVersion \u003d YarnVersionInfo.getVersion();\n      }\n\n      if ((nodeManagerVersion \u003d\u003d null) ||\n          (VersionUtil.compareVersions(nodeManagerVersion,minimumNodeManagerVersion)) \u003c 0) {\n        String message \u003d\n            \"Disallowed NodeManager Version \" + nodeManagerVersion\n                + \", is less than the minimum version \"\n                + minimumNodeManagerVersion + \" sending SHUTDOWN signal to \"\n                + \"NodeManager.\";\n        LOG.info(message);\n        response.setDiagnosticsMessage(message);\n        response.setNodeAction(NodeAction.SHUTDOWN);\n        return response;\n      }\n    }\n\n    // Check if this node is a \u0027valid\u0027 node\n    if (!this.nodesListManager.isValidNode(host)) {\n      String message \u003d\n          \"Disallowed NodeManager from  \" + host\n              + \", Sending SHUTDOWN signal to the NodeManager.\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    // Check if this node has minimum allocations\n    if (capability.getMemory() \u003c minAllocMb\n        || capability.getVirtualCores() \u003c minAllocVcores) {\n      String message \u003d\n          \"NodeManager from  \" + host\n              + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n              + \" signal to the NodeManager.\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    response.setContainerTokenMasterKey(containerTokenSecretManager\n        .getCurrentKey());\n    response.setNMTokenMasterKey(nmTokenSecretManager\n        .getCurrentKey());    \n\n    RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n        resolve(host), capability, nodeManagerVersion);\n\n    RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n    if (oldNode \u003d\u003d null) {\n      this.rmContext.getDispatcher().getEventHandler().handle(\n              new RMNodeStartedEvent(nodeId, request.getNMContainerStatuses(),\n                  request.getRunningApplications()));\n    } else {\n      LOG.info(\"Reconnect from the node at: \" + host);\n      this.nmLivelinessMonitor.unregister(nodeId);\n      // Reset heartbeat ID since node just restarted.\n      oldNode.resetLastNodeHeartBeatResponse();\n      this.rmContext\n          .getDispatcher()\n          .getEventHandler()\n          .handle(\n              new RMNodeReconnectEvent(nodeId, rmNode, request\n                  .getRunningApplications(), request.getNMContainerStatuses()));\n    }\n    // On every node manager register we will be clearing NMToken keys if\n    // present for any running application.\n    this.nmTokenSecretManager.removeNodeKey(nodeId);\n    this.nmLivelinessMonitor.register(nodeId);\n    \n    // Handle received container status, this should be processed after new\n    // RMNode inserted\n    if (!rmContext.isWorkPreservingRecoveryEnabled()) {\n      if (!request.getNMContainerStatuses().isEmpty()) {\n        LOG.info(\"received container statuses on node manager register :\"\n            + request.getNMContainerStatuses());\n        for (NMContainerStatus status : request.getNMContainerStatuses()) {\n          handleNMContainerStatus(status, nodeId);\n        }\n      }\n    }\n\n    // Update node\u0027s labels to RM\u0027s NodeLabelManager.\n    Set\u003cString\u003e nodeLabels \u003d NodeLabelsUtils.convertToStringSet(\n        request.getNodeLabels());\n    if (isDistributedNodeLabelsConf \u0026\u0026 nodeLabels !\u003d null) {\n      try {\n        updateNodeLabelsFromNMReport(nodeLabels, nodeId);\n        response.setAreNodeLabelsAcceptedByRM(true);\n      } catch (IOException ex) {\n        // Ensure the exception is captured in the response\n        response.setDiagnosticsMessage(ex.getMessage());\n        response.setAreNodeLabelsAcceptedByRM(false);\n      }\n    } else if (isDelegatedCentralizedNodeLabelsConf) {\n      this.rmContext.getRMDelegatedNodeLabelsUpdater().updateNodeLabels(nodeId);\n    }\n\n    StringBuilder message \u003d new StringBuilder();\n    message.append(\"NodeManager from node \").append(host).append(\"(cmPort: \")\n        .append(cmPort).append(\" httpPort: \");\n    message.append(httpPort).append(\") \")\n        .append(\"registered with capability: \").append(capability);\n    message.append(\", assigned nodeId \").append(nodeId);\n    if (response.getAreNodeLabelsAcceptedByRM()) {\n      message.append(\", node labels { \").append(\n          StringUtils.join(\",\", nodeLabels) + \" } \");\n    }\n\n    LOG.info(message.toString());\n    response.setNodeAction(NodeAction.NORMAL);\n    response.setRMIdentifier(ResourceManager.getClusterTimeStamp());\n    response.setRMVersion(YarnVersionInfo.getVersion());\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "feaf0349949e831ce3f25814c1bbff52f17bfe8f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3896. RMNode transitioned from RUNNING to REBOOTED because its response id has not been reset synchronously. (Jun Gong via rohithsharmaks)\n",
      "commitDate": "23/08/15 10:55 PM",
      "commitName": "feaf0349949e831ce3f25814c1bbff52f17bfe8f",
      "commitAuthor": "Rohith Sharma K S",
      "commitDateOld": "25/06/15 3:43 AM",
      "commitNameOld": "57f1a01eda80f44d3ffcbcb93c4ee290e274946a",
      "commitAuthorOld": "Devaraj K",
      "daysBetweenCommits": 59.8,
      "commitsBetweenForRepo": 347,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,126 +1,128 @@\n   public RegisterNodeManagerResponse registerNodeManager(\n       RegisterNodeManagerRequest request) throws YarnException,\n       IOException {\n     NodeId nodeId \u003d request.getNodeId();\n     String host \u003d nodeId.getHost();\n     int cmPort \u003d nodeId.getPort();\n     int httpPort \u003d request.getHttpPort();\n     Resource capability \u003d request.getResource();\n     String nodeManagerVersion \u003d request.getNMVersion();\n \n     RegisterNodeManagerResponse response \u003d recordFactory\n         .newRecordInstance(RegisterNodeManagerResponse.class);\n \n     if (!minimumNodeManagerVersion.equals(\"NONE\")) {\n       if (minimumNodeManagerVersion.equals(\"EqualToRM\")) {\n         minimumNodeManagerVersion \u003d YarnVersionInfo.getVersion();\n       }\n \n       if ((nodeManagerVersion \u003d\u003d null) ||\n           (VersionUtil.compareVersions(nodeManagerVersion,minimumNodeManagerVersion)) \u003c 0) {\n         String message \u003d\n             \"Disallowed NodeManager Version \" + nodeManagerVersion\n                 + \", is less than the minimum version \"\n                 + minimumNodeManagerVersion + \" sending SHUTDOWN signal to \"\n                 + \"NodeManager.\";\n         LOG.info(message);\n         response.setDiagnosticsMessage(message);\n         response.setNodeAction(NodeAction.SHUTDOWN);\n         return response;\n       }\n     }\n \n     // Check if this node is a \u0027valid\u0027 node\n     if (!this.nodesListManager.isValidNode(host)) {\n       String message \u003d\n           \"Disallowed NodeManager from  \" + host\n               + \", Sending SHUTDOWN signal to the NodeManager.\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     // Check if this node has minimum allocations\n     if (capability.getMemory() \u003c minAllocMb\n         || capability.getVirtualCores() \u003c minAllocVcores) {\n       String message \u003d\n           \"NodeManager from  \" + host\n               + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n               + \" signal to the NodeManager.\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     response.setContainerTokenMasterKey(containerTokenSecretManager\n         .getCurrentKey());\n     response.setNMTokenMasterKey(nmTokenSecretManager\n         .getCurrentKey());    \n \n     RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n         resolve(host), capability, nodeManagerVersion);\n \n     RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n     if (oldNode \u003d\u003d null) {\n       this.rmContext.getDispatcher().getEventHandler().handle(\n               new RMNodeStartedEvent(nodeId, request.getNMContainerStatuses(),\n                   request.getRunningApplications()));\n     } else {\n       LOG.info(\"Reconnect from the node at: \" + host);\n       this.nmLivelinessMonitor.unregister(nodeId);\n+      // Reset heartbeat ID since node just restarted.\n+      oldNode.resetLastNodeHeartBeatResponse();\n       this.rmContext\n           .getDispatcher()\n           .getEventHandler()\n           .handle(\n               new RMNodeReconnectEvent(nodeId, rmNode, request\n                   .getRunningApplications(), request.getNMContainerStatuses()));\n     }\n     // On every node manager register we will be clearing NMToken keys if\n     // present for any running application.\n     this.nmTokenSecretManager.removeNodeKey(nodeId);\n     this.nmLivelinessMonitor.register(nodeId);\n     \n     // Handle received container status, this should be processed after new\n     // RMNode inserted\n     if (!rmContext.isWorkPreservingRecoveryEnabled()) {\n       if (!request.getNMContainerStatuses().isEmpty()) {\n         LOG.info(\"received container statuses on node manager register :\"\n             + request.getNMContainerStatuses());\n         for (NMContainerStatus status : request.getNMContainerStatuses()) {\n           handleNMContainerStatus(status, nodeId);\n         }\n       }\n     }\n \n     // Update node\u0027s labels to RM\u0027s NodeLabelManager.\n     Set\u003cString\u003e nodeLabels \u003d convertToStringSet(request.getNodeLabels());\n     if (isDistributedNodeLabelsConf \u0026\u0026 nodeLabels !\u003d null) {\n       try {\n         updateNodeLabelsFromNMReport(nodeLabels, nodeId);\n         response.setAreNodeLabelsAcceptedByRM(true);\n       } catch (IOException ex) {\n         // Ensure the exception is captured in the response\n         response.setDiagnosticsMessage(ex.getMessage());\n         response.setAreNodeLabelsAcceptedByRM(false);\n       }\n     }\n \n     StringBuilder message \u003d new StringBuilder();\n     message.append(\"NodeManager from node \").append(host).append(\"(cmPort: \")\n         .append(cmPort).append(\" httpPort: \");\n     message.append(httpPort).append(\") \")\n         .append(\"registered with capability: \").append(capability);\n     message.append(\", assigned nodeId \").append(nodeId);\n     if (response.getAreNodeLabelsAcceptedByRM()) {\n       message.append(\", node labels { \").append(\n           StringUtils.join(\",\", nodeLabels) + \" } \");\n     }\n \n     LOG.info(message.toString());\n     response.setNodeAction(NodeAction.NORMAL);\n     response.setRMIdentifier(ResourceManager.getClusterTimeStamp());\n     response.setRMVersion(YarnVersionInfo.getVersion());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterNodeManagerResponse registerNodeManager(\n      RegisterNodeManagerRequest request) throws YarnException,\n      IOException {\n    NodeId nodeId \u003d request.getNodeId();\n    String host \u003d nodeId.getHost();\n    int cmPort \u003d nodeId.getPort();\n    int httpPort \u003d request.getHttpPort();\n    Resource capability \u003d request.getResource();\n    String nodeManagerVersion \u003d request.getNMVersion();\n\n    RegisterNodeManagerResponse response \u003d recordFactory\n        .newRecordInstance(RegisterNodeManagerResponse.class);\n\n    if (!minimumNodeManagerVersion.equals(\"NONE\")) {\n      if (minimumNodeManagerVersion.equals(\"EqualToRM\")) {\n        minimumNodeManagerVersion \u003d YarnVersionInfo.getVersion();\n      }\n\n      if ((nodeManagerVersion \u003d\u003d null) ||\n          (VersionUtil.compareVersions(nodeManagerVersion,minimumNodeManagerVersion)) \u003c 0) {\n        String message \u003d\n            \"Disallowed NodeManager Version \" + nodeManagerVersion\n                + \", is less than the minimum version \"\n                + minimumNodeManagerVersion + \" sending SHUTDOWN signal to \"\n                + \"NodeManager.\";\n        LOG.info(message);\n        response.setDiagnosticsMessage(message);\n        response.setNodeAction(NodeAction.SHUTDOWN);\n        return response;\n      }\n    }\n\n    // Check if this node is a \u0027valid\u0027 node\n    if (!this.nodesListManager.isValidNode(host)) {\n      String message \u003d\n          \"Disallowed NodeManager from  \" + host\n              + \", Sending SHUTDOWN signal to the NodeManager.\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    // Check if this node has minimum allocations\n    if (capability.getMemory() \u003c minAllocMb\n        || capability.getVirtualCores() \u003c minAllocVcores) {\n      String message \u003d\n          \"NodeManager from  \" + host\n              + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n              + \" signal to the NodeManager.\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    response.setContainerTokenMasterKey(containerTokenSecretManager\n        .getCurrentKey());\n    response.setNMTokenMasterKey(nmTokenSecretManager\n        .getCurrentKey());    \n\n    RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n        resolve(host), capability, nodeManagerVersion);\n\n    RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n    if (oldNode \u003d\u003d null) {\n      this.rmContext.getDispatcher().getEventHandler().handle(\n              new RMNodeStartedEvent(nodeId, request.getNMContainerStatuses(),\n                  request.getRunningApplications()));\n    } else {\n      LOG.info(\"Reconnect from the node at: \" + host);\n      this.nmLivelinessMonitor.unregister(nodeId);\n      // Reset heartbeat ID since node just restarted.\n      oldNode.resetLastNodeHeartBeatResponse();\n      this.rmContext\n          .getDispatcher()\n          .getEventHandler()\n          .handle(\n              new RMNodeReconnectEvent(nodeId, rmNode, request\n                  .getRunningApplications(), request.getNMContainerStatuses()));\n    }\n    // On every node manager register we will be clearing NMToken keys if\n    // present for any running application.\n    this.nmTokenSecretManager.removeNodeKey(nodeId);\n    this.nmLivelinessMonitor.register(nodeId);\n    \n    // Handle received container status, this should be processed after new\n    // RMNode inserted\n    if (!rmContext.isWorkPreservingRecoveryEnabled()) {\n      if (!request.getNMContainerStatuses().isEmpty()) {\n        LOG.info(\"received container statuses on node manager register :\"\n            + request.getNMContainerStatuses());\n        for (NMContainerStatus status : request.getNMContainerStatuses()) {\n          handleNMContainerStatus(status, nodeId);\n        }\n      }\n    }\n\n    // Update node\u0027s labels to RM\u0027s NodeLabelManager.\n    Set\u003cString\u003e nodeLabels \u003d convertToStringSet(request.getNodeLabels());\n    if (isDistributedNodeLabelsConf \u0026\u0026 nodeLabels !\u003d null) {\n      try {\n        updateNodeLabelsFromNMReport(nodeLabels, nodeId);\n        response.setAreNodeLabelsAcceptedByRM(true);\n      } catch (IOException ex) {\n        // Ensure the exception is captured in the response\n        response.setDiagnosticsMessage(ex.getMessage());\n        response.setAreNodeLabelsAcceptedByRM(false);\n      }\n    }\n\n    StringBuilder message \u003d new StringBuilder();\n    message.append(\"NodeManager from node \").append(host).append(\"(cmPort: \")\n        .append(cmPort).append(\" httpPort: \");\n    message.append(httpPort).append(\") \")\n        .append(\"registered with capability: \").append(capability);\n    message.append(\", assigned nodeId \").append(nodeId);\n    if (response.getAreNodeLabelsAcceptedByRM()) {\n      message.append(\", node labels { \").append(\n          StringUtils.join(\",\", nodeLabels) + \" } \");\n    }\n\n    LOG.info(message.toString());\n    response.setNodeAction(NodeAction.NORMAL);\n    response.setRMIdentifier(ResourceManager.getClusterTimeStamp());\n    response.setRMVersion(YarnVersionInfo.getVersion());\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "b37da52a1c4fb3da2bd21bfadc5ec61c5f953a59": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3565. NodeHeartbeatRequest/RegisterNodeManagerRequest should use NodeLabel object instead of String. (Naganarasimha G R via wangda)\n",
      "commitDate": "19/05/15 4:34 PM",
      "commitName": "b37da52a1c4fb3da2bd21bfadc5ec61c5f953a59",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "27/04/15 4:24 PM",
      "commitNameOld": "db1b674b50ddecf2774f4092d677c412722bdcb1",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 22.01,
      "commitsBetweenForRepo": 270,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,126 +1,126 @@\n   public RegisterNodeManagerResponse registerNodeManager(\n       RegisterNodeManagerRequest request) throws YarnException,\n       IOException {\n     NodeId nodeId \u003d request.getNodeId();\n     String host \u003d nodeId.getHost();\n     int cmPort \u003d nodeId.getPort();\n     int httpPort \u003d request.getHttpPort();\n     Resource capability \u003d request.getResource();\n     String nodeManagerVersion \u003d request.getNMVersion();\n \n     RegisterNodeManagerResponse response \u003d recordFactory\n         .newRecordInstance(RegisterNodeManagerResponse.class);\n \n     if (!minimumNodeManagerVersion.equals(\"NONE\")) {\n       if (minimumNodeManagerVersion.equals(\"EqualToRM\")) {\n         minimumNodeManagerVersion \u003d YarnVersionInfo.getVersion();\n       }\n \n       if ((nodeManagerVersion \u003d\u003d null) ||\n           (VersionUtil.compareVersions(nodeManagerVersion,minimumNodeManagerVersion)) \u003c 0) {\n         String message \u003d\n             \"Disallowed NodeManager Version \" + nodeManagerVersion\n                 + \", is less than the minimum version \"\n                 + minimumNodeManagerVersion + \" sending SHUTDOWN signal to \"\n                 + \"NodeManager.\";\n         LOG.info(message);\n         response.setDiagnosticsMessage(message);\n         response.setNodeAction(NodeAction.SHUTDOWN);\n         return response;\n       }\n     }\n \n     // Check if this node is a \u0027valid\u0027 node\n     if (!this.nodesListManager.isValidNode(host)) {\n       String message \u003d\n           \"Disallowed NodeManager from  \" + host\n               + \", Sending SHUTDOWN signal to the NodeManager.\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     // Check if this node has minimum allocations\n     if (capability.getMemory() \u003c minAllocMb\n         || capability.getVirtualCores() \u003c minAllocVcores) {\n       String message \u003d\n           \"NodeManager from  \" + host\n               + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n               + \" signal to the NodeManager.\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     response.setContainerTokenMasterKey(containerTokenSecretManager\n         .getCurrentKey());\n     response.setNMTokenMasterKey(nmTokenSecretManager\n         .getCurrentKey());    \n \n     RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n         resolve(host), capability, nodeManagerVersion);\n \n     RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n     if (oldNode \u003d\u003d null) {\n       this.rmContext.getDispatcher().getEventHandler().handle(\n               new RMNodeStartedEvent(nodeId, request.getNMContainerStatuses(),\n                   request.getRunningApplications()));\n     } else {\n       LOG.info(\"Reconnect from the node at: \" + host);\n       this.nmLivelinessMonitor.unregister(nodeId);\n       this.rmContext\n           .getDispatcher()\n           .getEventHandler()\n           .handle(\n               new RMNodeReconnectEvent(nodeId, rmNode, request\n                   .getRunningApplications(), request.getNMContainerStatuses()));\n     }\n     // On every node manager register we will be clearing NMToken keys if\n     // present for any running application.\n     this.nmTokenSecretManager.removeNodeKey(nodeId);\n     this.nmLivelinessMonitor.register(nodeId);\n     \n     // Handle received container status, this should be processed after new\n     // RMNode inserted\n     if (!rmContext.isWorkPreservingRecoveryEnabled()) {\n       if (!request.getNMContainerStatuses().isEmpty()) {\n         LOG.info(\"received container statuses on node manager register :\"\n             + request.getNMContainerStatuses());\n         for (NMContainerStatus status : request.getNMContainerStatuses()) {\n           handleNMContainerStatus(status, nodeId);\n         }\n       }\n     }\n \n     // Update node\u0027s labels to RM\u0027s NodeLabelManager.\n-    Set\u003cString\u003e nodeLabels \u003d request.getNodeLabels();\n+    Set\u003cString\u003e nodeLabels \u003d convertToStringSet(request.getNodeLabels());\n     if (isDistributedNodeLabelsConf \u0026\u0026 nodeLabels !\u003d null) {\n       try {\n         updateNodeLabelsFromNMReport(nodeLabels, nodeId);\n         response.setAreNodeLabelsAcceptedByRM(true);\n       } catch (IOException ex) {\n         // Ensure the exception is captured in the response\n         response.setDiagnosticsMessage(ex.getMessage());\n         response.setAreNodeLabelsAcceptedByRM(false);\n       }\n     }\n \n     StringBuilder message \u003d new StringBuilder();\n     message.append(\"NodeManager from node \").append(host).append(\"(cmPort: \")\n         .append(cmPort).append(\" httpPort: \");\n     message.append(httpPort).append(\") \")\n         .append(\"registered with capability: \").append(capability);\n     message.append(\", assigned nodeId \").append(nodeId);\n     if (response.getAreNodeLabelsAcceptedByRM()) {\n       message.append(\", node labels { \").append(\n           StringUtils.join(\",\", nodeLabels) + \" } \");\n     }\n \n     LOG.info(message.toString());\n     response.setNodeAction(NodeAction.NORMAL);\n     response.setRMIdentifier(ResourceManager.getClusterTimeStamp());\n     response.setRMVersion(YarnVersionInfo.getVersion());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterNodeManagerResponse registerNodeManager(\n      RegisterNodeManagerRequest request) throws YarnException,\n      IOException {\n    NodeId nodeId \u003d request.getNodeId();\n    String host \u003d nodeId.getHost();\n    int cmPort \u003d nodeId.getPort();\n    int httpPort \u003d request.getHttpPort();\n    Resource capability \u003d request.getResource();\n    String nodeManagerVersion \u003d request.getNMVersion();\n\n    RegisterNodeManagerResponse response \u003d recordFactory\n        .newRecordInstance(RegisterNodeManagerResponse.class);\n\n    if (!minimumNodeManagerVersion.equals(\"NONE\")) {\n      if (minimumNodeManagerVersion.equals(\"EqualToRM\")) {\n        minimumNodeManagerVersion \u003d YarnVersionInfo.getVersion();\n      }\n\n      if ((nodeManagerVersion \u003d\u003d null) ||\n          (VersionUtil.compareVersions(nodeManagerVersion,minimumNodeManagerVersion)) \u003c 0) {\n        String message \u003d\n            \"Disallowed NodeManager Version \" + nodeManagerVersion\n                + \", is less than the minimum version \"\n                + minimumNodeManagerVersion + \" sending SHUTDOWN signal to \"\n                + \"NodeManager.\";\n        LOG.info(message);\n        response.setDiagnosticsMessage(message);\n        response.setNodeAction(NodeAction.SHUTDOWN);\n        return response;\n      }\n    }\n\n    // Check if this node is a \u0027valid\u0027 node\n    if (!this.nodesListManager.isValidNode(host)) {\n      String message \u003d\n          \"Disallowed NodeManager from  \" + host\n              + \", Sending SHUTDOWN signal to the NodeManager.\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    // Check if this node has minimum allocations\n    if (capability.getMemory() \u003c minAllocMb\n        || capability.getVirtualCores() \u003c minAllocVcores) {\n      String message \u003d\n          \"NodeManager from  \" + host\n              + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n              + \" signal to the NodeManager.\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    response.setContainerTokenMasterKey(containerTokenSecretManager\n        .getCurrentKey());\n    response.setNMTokenMasterKey(nmTokenSecretManager\n        .getCurrentKey());    \n\n    RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n        resolve(host), capability, nodeManagerVersion);\n\n    RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n    if (oldNode \u003d\u003d null) {\n      this.rmContext.getDispatcher().getEventHandler().handle(\n              new RMNodeStartedEvent(nodeId, request.getNMContainerStatuses(),\n                  request.getRunningApplications()));\n    } else {\n      LOG.info(\"Reconnect from the node at: \" + host);\n      this.nmLivelinessMonitor.unregister(nodeId);\n      this.rmContext\n          .getDispatcher()\n          .getEventHandler()\n          .handle(\n              new RMNodeReconnectEvent(nodeId, rmNode, request\n                  .getRunningApplications(), request.getNMContainerStatuses()));\n    }\n    // On every node manager register we will be clearing NMToken keys if\n    // present for any running application.\n    this.nmTokenSecretManager.removeNodeKey(nodeId);\n    this.nmLivelinessMonitor.register(nodeId);\n    \n    // Handle received container status, this should be processed after new\n    // RMNode inserted\n    if (!rmContext.isWorkPreservingRecoveryEnabled()) {\n      if (!request.getNMContainerStatuses().isEmpty()) {\n        LOG.info(\"received container statuses on node manager register :\"\n            + request.getNMContainerStatuses());\n        for (NMContainerStatus status : request.getNMContainerStatuses()) {\n          handleNMContainerStatus(status, nodeId);\n        }\n      }\n    }\n\n    // Update node\u0027s labels to RM\u0027s NodeLabelManager.\n    Set\u003cString\u003e nodeLabels \u003d convertToStringSet(request.getNodeLabels());\n    if (isDistributedNodeLabelsConf \u0026\u0026 nodeLabels !\u003d null) {\n      try {\n        updateNodeLabelsFromNMReport(nodeLabels, nodeId);\n        response.setAreNodeLabelsAcceptedByRM(true);\n      } catch (IOException ex) {\n        // Ensure the exception is captured in the response\n        response.setDiagnosticsMessage(ex.getMessage());\n        response.setAreNodeLabelsAcceptedByRM(false);\n      }\n    }\n\n    StringBuilder message \u003d new StringBuilder();\n    message.append(\"NodeManager from node \").append(host).append(\"(cmPort: \")\n        .append(cmPort).append(\" httpPort: \");\n    message.append(httpPort).append(\") \")\n        .append(\"registered with capability: \").append(capability);\n    message.append(\", assigned nodeId \").append(nodeId);\n    if (response.getAreNodeLabelsAcceptedByRM()) {\n      message.append(\", node labels { \").append(\n          StringUtils.join(\",\", nodeLabels) + \" } \");\n    }\n\n    LOG.info(message.toString());\n    response.setNodeAction(NodeAction.NORMAL);\n    response.setRMIdentifier(ResourceManager.getClusterTimeStamp());\n    response.setRMVersion(YarnVersionInfo.getVersion());\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "db1b674b50ddecf2774f4092d677c412722bdcb1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2740. Fix NodeLabelsManager to properly handle node label modifications when distributed node label configuration enabled. (Naganarasimha G R via wangda)\n",
      "commitDate": "27/04/15 4:24 PM",
      "commitName": "db1b674b50ddecf2774f4092d677c412722bdcb1",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "10/04/15 8:56 AM",
      "commitNameOld": "92431c961741747b5d6442f4025016d48d9a6863",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 17.31,
      "commitsBetweenForRepo": 142,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,126 +1,126 @@\n   public RegisterNodeManagerResponse registerNodeManager(\n       RegisterNodeManagerRequest request) throws YarnException,\n       IOException {\n     NodeId nodeId \u003d request.getNodeId();\n     String host \u003d nodeId.getHost();\n     int cmPort \u003d nodeId.getPort();\n     int httpPort \u003d request.getHttpPort();\n     Resource capability \u003d request.getResource();\n     String nodeManagerVersion \u003d request.getNMVersion();\n \n     RegisterNodeManagerResponse response \u003d recordFactory\n         .newRecordInstance(RegisterNodeManagerResponse.class);\n \n     if (!minimumNodeManagerVersion.equals(\"NONE\")) {\n       if (minimumNodeManagerVersion.equals(\"EqualToRM\")) {\n         minimumNodeManagerVersion \u003d YarnVersionInfo.getVersion();\n       }\n \n       if ((nodeManagerVersion \u003d\u003d null) ||\n           (VersionUtil.compareVersions(nodeManagerVersion,minimumNodeManagerVersion)) \u003c 0) {\n         String message \u003d\n             \"Disallowed NodeManager Version \" + nodeManagerVersion\n                 + \", is less than the minimum version \"\n                 + minimumNodeManagerVersion + \" sending SHUTDOWN signal to \"\n                 + \"NodeManager.\";\n         LOG.info(message);\n         response.setDiagnosticsMessage(message);\n         response.setNodeAction(NodeAction.SHUTDOWN);\n         return response;\n       }\n     }\n \n     // Check if this node is a \u0027valid\u0027 node\n     if (!this.nodesListManager.isValidNode(host)) {\n       String message \u003d\n           \"Disallowed NodeManager from  \" + host\n               + \", Sending SHUTDOWN signal to the NodeManager.\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     // Check if this node has minimum allocations\n     if (capability.getMemory() \u003c minAllocMb\n         || capability.getVirtualCores() \u003c minAllocVcores) {\n       String message \u003d\n           \"NodeManager from  \" + host\n               + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n               + \" signal to the NodeManager.\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     response.setContainerTokenMasterKey(containerTokenSecretManager\n         .getCurrentKey());\n     response.setNMTokenMasterKey(nmTokenSecretManager\n         .getCurrentKey());    \n \n     RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n         resolve(host), capability, nodeManagerVersion);\n \n     RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n     if (oldNode \u003d\u003d null) {\n       this.rmContext.getDispatcher().getEventHandler().handle(\n               new RMNodeStartedEvent(nodeId, request.getNMContainerStatuses(),\n                   request.getRunningApplications()));\n     } else {\n       LOG.info(\"Reconnect from the node at: \" + host);\n       this.nmLivelinessMonitor.unregister(nodeId);\n       this.rmContext\n           .getDispatcher()\n           .getEventHandler()\n           .handle(\n               new RMNodeReconnectEvent(nodeId, rmNode, request\n                   .getRunningApplications(), request.getNMContainerStatuses()));\n     }\n     // On every node manager register we will be clearing NMToken keys if\n     // present for any running application.\n     this.nmTokenSecretManager.removeNodeKey(nodeId);\n     this.nmLivelinessMonitor.register(nodeId);\n     \n     // Handle received container status, this should be processed after new\n     // RMNode inserted\n     if (!rmContext.isWorkPreservingRecoveryEnabled()) {\n       if (!request.getNMContainerStatuses().isEmpty()) {\n         LOG.info(\"received container statuses on node manager register :\"\n             + request.getNMContainerStatuses());\n         for (NMContainerStatus status : request.getNMContainerStatuses()) {\n           handleNMContainerStatus(status, nodeId);\n         }\n       }\n     }\n \n     // Update node\u0027s labels to RM\u0027s NodeLabelManager.\n     Set\u003cString\u003e nodeLabels \u003d request.getNodeLabels();\n-    if (isDistributesNodeLabelsConf \u0026\u0026 nodeLabels !\u003d null) {\n+    if (isDistributedNodeLabelsConf \u0026\u0026 nodeLabels !\u003d null) {\n       try {\n         updateNodeLabelsFromNMReport(nodeLabels, nodeId);\n         response.setAreNodeLabelsAcceptedByRM(true);\n       } catch (IOException ex) {\n         // Ensure the exception is captured in the response\n         response.setDiagnosticsMessage(ex.getMessage());\n         response.setAreNodeLabelsAcceptedByRM(false);\n       }\n     }\n \n     StringBuilder message \u003d new StringBuilder();\n     message.append(\"NodeManager from node \").append(host).append(\"(cmPort: \")\n         .append(cmPort).append(\" httpPort: \");\n     message.append(httpPort).append(\") \")\n         .append(\"registered with capability: \").append(capability);\n     message.append(\", assigned nodeId \").append(nodeId);\n     if (response.getAreNodeLabelsAcceptedByRM()) {\n       message.append(\", node labels { \").append(\n           StringUtils.join(\",\", nodeLabels) + \" } \");\n     }\n \n     LOG.info(message.toString());\n     response.setNodeAction(NodeAction.NORMAL);\n     response.setRMIdentifier(ResourceManager.getClusterTimeStamp());\n     response.setRMVersion(YarnVersionInfo.getVersion());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterNodeManagerResponse registerNodeManager(\n      RegisterNodeManagerRequest request) throws YarnException,\n      IOException {\n    NodeId nodeId \u003d request.getNodeId();\n    String host \u003d nodeId.getHost();\n    int cmPort \u003d nodeId.getPort();\n    int httpPort \u003d request.getHttpPort();\n    Resource capability \u003d request.getResource();\n    String nodeManagerVersion \u003d request.getNMVersion();\n\n    RegisterNodeManagerResponse response \u003d recordFactory\n        .newRecordInstance(RegisterNodeManagerResponse.class);\n\n    if (!minimumNodeManagerVersion.equals(\"NONE\")) {\n      if (minimumNodeManagerVersion.equals(\"EqualToRM\")) {\n        minimumNodeManagerVersion \u003d YarnVersionInfo.getVersion();\n      }\n\n      if ((nodeManagerVersion \u003d\u003d null) ||\n          (VersionUtil.compareVersions(nodeManagerVersion,minimumNodeManagerVersion)) \u003c 0) {\n        String message \u003d\n            \"Disallowed NodeManager Version \" + nodeManagerVersion\n                + \", is less than the minimum version \"\n                + minimumNodeManagerVersion + \" sending SHUTDOWN signal to \"\n                + \"NodeManager.\";\n        LOG.info(message);\n        response.setDiagnosticsMessage(message);\n        response.setNodeAction(NodeAction.SHUTDOWN);\n        return response;\n      }\n    }\n\n    // Check if this node is a \u0027valid\u0027 node\n    if (!this.nodesListManager.isValidNode(host)) {\n      String message \u003d\n          \"Disallowed NodeManager from  \" + host\n              + \", Sending SHUTDOWN signal to the NodeManager.\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    // Check if this node has minimum allocations\n    if (capability.getMemory() \u003c minAllocMb\n        || capability.getVirtualCores() \u003c minAllocVcores) {\n      String message \u003d\n          \"NodeManager from  \" + host\n              + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n              + \" signal to the NodeManager.\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    response.setContainerTokenMasterKey(containerTokenSecretManager\n        .getCurrentKey());\n    response.setNMTokenMasterKey(nmTokenSecretManager\n        .getCurrentKey());    \n\n    RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n        resolve(host), capability, nodeManagerVersion);\n\n    RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n    if (oldNode \u003d\u003d null) {\n      this.rmContext.getDispatcher().getEventHandler().handle(\n              new RMNodeStartedEvent(nodeId, request.getNMContainerStatuses(),\n                  request.getRunningApplications()));\n    } else {\n      LOG.info(\"Reconnect from the node at: \" + host);\n      this.nmLivelinessMonitor.unregister(nodeId);\n      this.rmContext\n          .getDispatcher()\n          .getEventHandler()\n          .handle(\n              new RMNodeReconnectEvent(nodeId, rmNode, request\n                  .getRunningApplications(), request.getNMContainerStatuses()));\n    }\n    // On every node manager register we will be clearing NMToken keys if\n    // present for any running application.\n    this.nmTokenSecretManager.removeNodeKey(nodeId);\n    this.nmLivelinessMonitor.register(nodeId);\n    \n    // Handle received container status, this should be processed after new\n    // RMNode inserted\n    if (!rmContext.isWorkPreservingRecoveryEnabled()) {\n      if (!request.getNMContainerStatuses().isEmpty()) {\n        LOG.info(\"received container statuses on node manager register :\"\n            + request.getNMContainerStatuses());\n        for (NMContainerStatus status : request.getNMContainerStatuses()) {\n          handleNMContainerStatus(status, nodeId);\n        }\n      }\n    }\n\n    // Update node\u0027s labels to RM\u0027s NodeLabelManager.\n    Set\u003cString\u003e nodeLabels \u003d request.getNodeLabels();\n    if (isDistributedNodeLabelsConf \u0026\u0026 nodeLabels !\u003d null) {\n      try {\n        updateNodeLabelsFromNMReport(nodeLabels, nodeId);\n        response.setAreNodeLabelsAcceptedByRM(true);\n      } catch (IOException ex) {\n        // Ensure the exception is captured in the response\n        response.setDiagnosticsMessage(ex.getMessage());\n        response.setAreNodeLabelsAcceptedByRM(false);\n      }\n    }\n\n    StringBuilder message \u003d new StringBuilder();\n    message.append(\"NodeManager from node \").append(host).append(\"(cmPort: \")\n        .append(cmPort).append(\" httpPort: \");\n    message.append(httpPort).append(\") \")\n        .append(\"registered with capability: \").append(capability);\n    message.append(\", assigned nodeId \").append(nodeId);\n    if (response.getAreNodeLabelsAcceptedByRM()) {\n      message.append(\", node labels { \").append(\n          StringUtils.join(\",\", nodeLabels) + \" } \");\n    }\n\n    LOG.info(message.toString());\n    response.setNodeAction(NodeAction.NORMAL);\n    response.setRMIdentifier(ResourceManager.getClusterTimeStamp());\n    response.setRMVersion(YarnVersionInfo.getVersion());\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "2a945d24f7de1a7ae6e7bd6636188ce3b55c7f52": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2495. Allow admin specify labels from each NM (Distributed configuration for node label). (Naganarasimha G R via wangda)\n",
      "commitDate": "30/03/15 12:05 PM",
      "commitName": "2a945d24f7de1a7ae6e7bd6636188ce3b55c7f52",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "20/02/15 7:10 AM",
      "commitNameOld": "a64dd3d24bfcb9af21eb63869924f6482b147fd3",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 38.16,
      "commitsBetweenForRepo": 326,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,106 +1,126 @@\n   public RegisterNodeManagerResponse registerNodeManager(\n       RegisterNodeManagerRequest request) throws YarnException,\n       IOException {\n     NodeId nodeId \u003d request.getNodeId();\n     String host \u003d nodeId.getHost();\n     int cmPort \u003d nodeId.getPort();\n     int httpPort \u003d request.getHttpPort();\n     Resource capability \u003d request.getResource();\n     String nodeManagerVersion \u003d request.getNMVersion();\n \n     RegisterNodeManagerResponse response \u003d recordFactory\n         .newRecordInstance(RegisterNodeManagerResponse.class);\n \n     if (!minimumNodeManagerVersion.equals(\"NONE\")) {\n       if (minimumNodeManagerVersion.equals(\"EqualToRM\")) {\n         minimumNodeManagerVersion \u003d YarnVersionInfo.getVersion();\n       }\n \n       if ((nodeManagerVersion \u003d\u003d null) ||\n           (VersionUtil.compareVersions(nodeManagerVersion,minimumNodeManagerVersion)) \u003c 0) {\n         String message \u003d\n             \"Disallowed NodeManager Version \" + nodeManagerVersion\n                 + \", is less than the minimum version \"\n                 + minimumNodeManagerVersion + \" sending SHUTDOWN signal to \"\n                 + \"NodeManager.\";\n         LOG.info(message);\n         response.setDiagnosticsMessage(message);\n         response.setNodeAction(NodeAction.SHUTDOWN);\n         return response;\n       }\n     }\n \n     // Check if this node is a \u0027valid\u0027 node\n     if (!this.nodesListManager.isValidNode(host)) {\n       String message \u003d\n           \"Disallowed NodeManager from  \" + host\n               + \", Sending SHUTDOWN signal to the NodeManager.\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     // Check if this node has minimum allocations\n     if (capability.getMemory() \u003c minAllocMb\n         || capability.getVirtualCores() \u003c minAllocVcores) {\n       String message \u003d\n           \"NodeManager from  \" + host\n               + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n               + \" signal to the NodeManager.\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     response.setContainerTokenMasterKey(containerTokenSecretManager\n         .getCurrentKey());\n     response.setNMTokenMasterKey(nmTokenSecretManager\n         .getCurrentKey());    \n \n     RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n         resolve(host), capability, nodeManagerVersion);\n \n     RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n     if (oldNode \u003d\u003d null) {\n       this.rmContext.getDispatcher().getEventHandler().handle(\n               new RMNodeStartedEvent(nodeId, request.getNMContainerStatuses(),\n                   request.getRunningApplications()));\n     } else {\n       LOG.info(\"Reconnect from the node at: \" + host);\n       this.nmLivelinessMonitor.unregister(nodeId);\n       this.rmContext\n           .getDispatcher()\n           .getEventHandler()\n           .handle(\n               new RMNodeReconnectEvent(nodeId, rmNode, request\n                   .getRunningApplications(), request.getNMContainerStatuses()));\n     }\n     // On every node manager register we will be clearing NMToken keys if\n     // present for any running application.\n     this.nmTokenSecretManager.removeNodeKey(nodeId);\n     this.nmLivelinessMonitor.register(nodeId);\n     \n     // Handle received container status, this should be processed after new\n     // RMNode inserted\n     if (!rmContext.isWorkPreservingRecoveryEnabled()) {\n       if (!request.getNMContainerStatuses().isEmpty()) {\n         LOG.info(\"received container statuses on node manager register :\"\n             + request.getNMContainerStatuses());\n         for (NMContainerStatus status : request.getNMContainerStatuses()) {\n           handleNMContainerStatus(status, nodeId);\n         }\n       }\n     }\n \n-    String message \u003d\n-        \"NodeManager from node \" + host + \"(cmPort: \" + cmPort + \" httpPort: \"\n-            + httpPort + \") \" + \"registered with capability: \" + capability\n-            + \", assigned nodeId \" + nodeId;\n-    LOG.info(message);\n+    // Update node\u0027s labels to RM\u0027s NodeLabelManager.\n+    Set\u003cString\u003e nodeLabels \u003d request.getNodeLabels();\n+    if (isDistributesNodeLabelsConf \u0026\u0026 nodeLabels !\u003d null) {\n+      try {\n+        updateNodeLabelsFromNMReport(nodeLabels, nodeId);\n+        response.setAreNodeLabelsAcceptedByRM(true);\n+      } catch (IOException ex) {\n+        // Ensure the exception is captured in the response\n+        response.setDiagnosticsMessage(ex.getMessage());\n+        response.setAreNodeLabelsAcceptedByRM(false);\n+      }\n+    }\n+\n+    StringBuilder message \u003d new StringBuilder();\n+    message.append(\"NodeManager from node \").append(host).append(\"(cmPort: \")\n+        .append(cmPort).append(\" httpPort: \");\n+    message.append(httpPort).append(\") \")\n+        .append(\"registered with capability: \").append(capability);\n+    message.append(\", assigned nodeId \").append(nodeId);\n+    if (response.getAreNodeLabelsAcceptedByRM()) {\n+      message.append(\", node labels { \").append(\n+          StringUtils.join(\",\", nodeLabels) + \" } \");\n+    }\n+\n+    LOG.info(message.toString());\n     response.setNodeAction(NodeAction.NORMAL);\n     response.setRMIdentifier(ResourceManager.getClusterTimeStamp());\n     response.setRMVersion(YarnVersionInfo.getVersion());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterNodeManagerResponse registerNodeManager(\n      RegisterNodeManagerRequest request) throws YarnException,\n      IOException {\n    NodeId nodeId \u003d request.getNodeId();\n    String host \u003d nodeId.getHost();\n    int cmPort \u003d nodeId.getPort();\n    int httpPort \u003d request.getHttpPort();\n    Resource capability \u003d request.getResource();\n    String nodeManagerVersion \u003d request.getNMVersion();\n\n    RegisterNodeManagerResponse response \u003d recordFactory\n        .newRecordInstance(RegisterNodeManagerResponse.class);\n\n    if (!minimumNodeManagerVersion.equals(\"NONE\")) {\n      if (minimumNodeManagerVersion.equals(\"EqualToRM\")) {\n        minimumNodeManagerVersion \u003d YarnVersionInfo.getVersion();\n      }\n\n      if ((nodeManagerVersion \u003d\u003d null) ||\n          (VersionUtil.compareVersions(nodeManagerVersion,minimumNodeManagerVersion)) \u003c 0) {\n        String message \u003d\n            \"Disallowed NodeManager Version \" + nodeManagerVersion\n                + \", is less than the minimum version \"\n                + minimumNodeManagerVersion + \" sending SHUTDOWN signal to \"\n                + \"NodeManager.\";\n        LOG.info(message);\n        response.setDiagnosticsMessage(message);\n        response.setNodeAction(NodeAction.SHUTDOWN);\n        return response;\n      }\n    }\n\n    // Check if this node is a \u0027valid\u0027 node\n    if (!this.nodesListManager.isValidNode(host)) {\n      String message \u003d\n          \"Disallowed NodeManager from  \" + host\n              + \", Sending SHUTDOWN signal to the NodeManager.\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    // Check if this node has minimum allocations\n    if (capability.getMemory() \u003c minAllocMb\n        || capability.getVirtualCores() \u003c minAllocVcores) {\n      String message \u003d\n          \"NodeManager from  \" + host\n              + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n              + \" signal to the NodeManager.\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    response.setContainerTokenMasterKey(containerTokenSecretManager\n        .getCurrentKey());\n    response.setNMTokenMasterKey(nmTokenSecretManager\n        .getCurrentKey());    \n\n    RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n        resolve(host), capability, nodeManagerVersion);\n\n    RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n    if (oldNode \u003d\u003d null) {\n      this.rmContext.getDispatcher().getEventHandler().handle(\n              new RMNodeStartedEvent(nodeId, request.getNMContainerStatuses(),\n                  request.getRunningApplications()));\n    } else {\n      LOG.info(\"Reconnect from the node at: \" + host);\n      this.nmLivelinessMonitor.unregister(nodeId);\n      this.rmContext\n          .getDispatcher()\n          .getEventHandler()\n          .handle(\n              new RMNodeReconnectEvent(nodeId, rmNode, request\n                  .getRunningApplications(), request.getNMContainerStatuses()));\n    }\n    // On every node manager register we will be clearing NMToken keys if\n    // present for any running application.\n    this.nmTokenSecretManager.removeNodeKey(nodeId);\n    this.nmLivelinessMonitor.register(nodeId);\n    \n    // Handle received container status, this should be processed after new\n    // RMNode inserted\n    if (!rmContext.isWorkPreservingRecoveryEnabled()) {\n      if (!request.getNMContainerStatuses().isEmpty()) {\n        LOG.info(\"received container statuses on node manager register :\"\n            + request.getNMContainerStatuses());\n        for (NMContainerStatus status : request.getNMContainerStatuses()) {\n          handleNMContainerStatus(status, nodeId);\n        }\n      }\n    }\n\n    // Update node\u0027s labels to RM\u0027s NodeLabelManager.\n    Set\u003cString\u003e nodeLabels \u003d request.getNodeLabels();\n    if (isDistributesNodeLabelsConf \u0026\u0026 nodeLabels !\u003d null) {\n      try {\n        updateNodeLabelsFromNMReport(nodeLabels, nodeId);\n        response.setAreNodeLabelsAcceptedByRM(true);\n      } catch (IOException ex) {\n        // Ensure the exception is captured in the response\n        response.setDiagnosticsMessage(ex.getMessage());\n        response.setAreNodeLabelsAcceptedByRM(false);\n      }\n    }\n\n    StringBuilder message \u003d new StringBuilder();\n    message.append(\"NodeManager from node \").append(host).append(\"(cmPort: \")\n        .append(cmPort).append(\" httpPort: \");\n    message.append(httpPort).append(\") \")\n        .append(\"registered with capability: \").append(capability);\n    message.append(\", assigned nodeId \").append(nodeId);\n    if (response.getAreNodeLabelsAcceptedByRM()) {\n      message.append(\", node labels { \").append(\n          StringUtils.join(\",\", nodeLabels) + \" } \");\n    }\n\n    LOG.info(message.toString());\n    response.setNodeAction(NodeAction.NORMAL);\n    response.setRMIdentifier(ResourceManager.getClusterTimeStamp());\n    response.setRMVersion(YarnVersionInfo.getVersion());\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "a64dd3d24bfcb9af21eb63869924f6482b147fd3": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3194. RM should handle NMContainerStatuses sent by NM while registering if NM is Reconnected node. Contributed by Rohith\n",
      "commitDate": "20/02/15 7:10 AM",
      "commitName": "a64dd3d24bfcb9af21eb63869924f6482b147fd3",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "12/02/15 4:42 PM",
      "commitNameOld": "99f6bd4f7ab1c5cac57362690c686139e73251d9",
      "commitAuthorOld": "Xuan",
      "daysBetweenCommits": 7.6,
      "commitsBetweenForRepo": 72,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,103 +1,106 @@\n   public RegisterNodeManagerResponse registerNodeManager(\n       RegisterNodeManagerRequest request) throws YarnException,\n       IOException {\n     NodeId nodeId \u003d request.getNodeId();\n     String host \u003d nodeId.getHost();\n     int cmPort \u003d nodeId.getPort();\n     int httpPort \u003d request.getHttpPort();\n     Resource capability \u003d request.getResource();\n     String nodeManagerVersion \u003d request.getNMVersion();\n \n     RegisterNodeManagerResponse response \u003d recordFactory\n         .newRecordInstance(RegisterNodeManagerResponse.class);\n \n     if (!minimumNodeManagerVersion.equals(\"NONE\")) {\n       if (minimumNodeManagerVersion.equals(\"EqualToRM\")) {\n         minimumNodeManagerVersion \u003d YarnVersionInfo.getVersion();\n       }\n \n       if ((nodeManagerVersion \u003d\u003d null) ||\n           (VersionUtil.compareVersions(nodeManagerVersion,minimumNodeManagerVersion)) \u003c 0) {\n         String message \u003d\n             \"Disallowed NodeManager Version \" + nodeManagerVersion\n                 + \", is less than the minimum version \"\n                 + minimumNodeManagerVersion + \" sending SHUTDOWN signal to \"\n                 + \"NodeManager.\";\n         LOG.info(message);\n         response.setDiagnosticsMessage(message);\n         response.setNodeAction(NodeAction.SHUTDOWN);\n         return response;\n       }\n     }\n \n     // Check if this node is a \u0027valid\u0027 node\n     if (!this.nodesListManager.isValidNode(host)) {\n       String message \u003d\n           \"Disallowed NodeManager from  \" + host\n               + \", Sending SHUTDOWN signal to the NodeManager.\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     // Check if this node has minimum allocations\n     if (capability.getMemory() \u003c minAllocMb\n         || capability.getVirtualCores() \u003c minAllocVcores) {\n       String message \u003d\n           \"NodeManager from  \" + host\n               + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n               + \" signal to the NodeManager.\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     response.setContainerTokenMasterKey(containerTokenSecretManager\n         .getCurrentKey());\n     response.setNMTokenMasterKey(nmTokenSecretManager\n         .getCurrentKey());    \n \n     RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n         resolve(host), capability, nodeManagerVersion);\n \n     RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n     if (oldNode \u003d\u003d null) {\n       this.rmContext.getDispatcher().getEventHandler().handle(\n               new RMNodeStartedEvent(nodeId, request.getNMContainerStatuses(),\n                   request.getRunningApplications()));\n     } else {\n       LOG.info(\"Reconnect from the node at: \" + host);\n       this.nmLivelinessMonitor.unregister(nodeId);\n-      this.rmContext.getDispatcher().getEventHandler().handle(\n-          new RMNodeReconnectEvent(nodeId, rmNode,\n-              request.getRunningApplications()));\n+      this.rmContext\n+          .getDispatcher()\n+          .getEventHandler()\n+          .handle(\n+              new RMNodeReconnectEvent(nodeId, rmNode, request\n+                  .getRunningApplications(), request.getNMContainerStatuses()));\n     }\n     // On every node manager register we will be clearing NMToken keys if\n     // present for any running application.\n     this.nmTokenSecretManager.removeNodeKey(nodeId);\n     this.nmLivelinessMonitor.register(nodeId);\n     \n     // Handle received container status, this should be processed after new\n     // RMNode inserted\n     if (!rmContext.isWorkPreservingRecoveryEnabled()) {\n       if (!request.getNMContainerStatuses().isEmpty()) {\n         LOG.info(\"received container statuses on node manager register :\"\n             + request.getNMContainerStatuses());\n         for (NMContainerStatus status : request.getNMContainerStatuses()) {\n           handleNMContainerStatus(status, nodeId);\n         }\n       }\n     }\n \n     String message \u003d\n         \"NodeManager from node \" + host + \"(cmPort: \" + cmPort + \" httpPort: \"\n             + httpPort + \") \" + \"registered with capability: \" + capability\n             + \", assigned nodeId \" + nodeId;\n     LOG.info(message);\n     response.setNodeAction(NodeAction.NORMAL);\n     response.setRMIdentifier(ResourceManager.getClusterTimeStamp());\n     response.setRMVersion(YarnVersionInfo.getVersion());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterNodeManagerResponse registerNodeManager(\n      RegisterNodeManagerRequest request) throws YarnException,\n      IOException {\n    NodeId nodeId \u003d request.getNodeId();\n    String host \u003d nodeId.getHost();\n    int cmPort \u003d nodeId.getPort();\n    int httpPort \u003d request.getHttpPort();\n    Resource capability \u003d request.getResource();\n    String nodeManagerVersion \u003d request.getNMVersion();\n\n    RegisterNodeManagerResponse response \u003d recordFactory\n        .newRecordInstance(RegisterNodeManagerResponse.class);\n\n    if (!minimumNodeManagerVersion.equals(\"NONE\")) {\n      if (minimumNodeManagerVersion.equals(\"EqualToRM\")) {\n        minimumNodeManagerVersion \u003d YarnVersionInfo.getVersion();\n      }\n\n      if ((nodeManagerVersion \u003d\u003d null) ||\n          (VersionUtil.compareVersions(nodeManagerVersion,minimumNodeManagerVersion)) \u003c 0) {\n        String message \u003d\n            \"Disallowed NodeManager Version \" + nodeManagerVersion\n                + \", is less than the minimum version \"\n                + minimumNodeManagerVersion + \" sending SHUTDOWN signal to \"\n                + \"NodeManager.\";\n        LOG.info(message);\n        response.setDiagnosticsMessage(message);\n        response.setNodeAction(NodeAction.SHUTDOWN);\n        return response;\n      }\n    }\n\n    // Check if this node is a \u0027valid\u0027 node\n    if (!this.nodesListManager.isValidNode(host)) {\n      String message \u003d\n          \"Disallowed NodeManager from  \" + host\n              + \", Sending SHUTDOWN signal to the NodeManager.\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    // Check if this node has minimum allocations\n    if (capability.getMemory() \u003c minAllocMb\n        || capability.getVirtualCores() \u003c minAllocVcores) {\n      String message \u003d\n          \"NodeManager from  \" + host\n              + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n              + \" signal to the NodeManager.\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    response.setContainerTokenMasterKey(containerTokenSecretManager\n        .getCurrentKey());\n    response.setNMTokenMasterKey(nmTokenSecretManager\n        .getCurrentKey());    \n\n    RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n        resolve(host), capability, nodeManagerVersion);\n\n    RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n    if (oldNode \u003d\u003d null) {\n      this.rmContext.getDispatcher().getEventHandler().handle(\n              new RMNodeStartedEvent(nodeId, request.getNMContainerStatuses(),\n                  request.getRunningApplications()));\n    } else {\n      LOG.info(\"Reconnect from the node at: \" + host);\n      this.nmLivelinessMonitor.unregister(nodeId);\n      this.rmContext\n          .getDispatcher()\n          .getEventHandler()\n          .handle(\n              new RMNodeReconnectEvent(nodeId, rmNode, request\n                  .getRunningApplications(), request.getNMContainerStatuses()));\n    }\n    // On every node manager register we will be clearing NMToken keys if\n    // present for any running application.\n    this.nmTokenSecretManager.removeNodeKey(nodeId);\n    this.nmLivelinessMonitor.register(nodeId);\n    \n    // Handle received container status, this should be processed after new\n    // RMNode inserted\n    if (!rmContext.isWorkPreservingRecoveryEnabled()) {\n      if (!request.getNMContainerStatuses().isEmpty()) {\n        LOG.info(\"received container statuses on node manager register :\"\n            + request.getNMContainerStatuses());\n        for (NMContainerStatus status : request.getNMContainerStatuses()) {\n          handleNMContainerStatus(status, nodeId);\n        }\n      }\n    }\n\n    String message \u003d\n        \"NodeManager from node \" + host + \"(cmPort: \" + cmPort + \" httpPort: \"\n            + httpPort + \") \" + \"registered with capability: \" + capability\n            + \", assigned nodeId \" + nodeId;\n    LOG.info(message);\n    response.setNodeAction(NodeAction.NORMAL);\n    response.setRMIdentifier(ResourceManager.getClusterTimeStamp());\n    response.setRMVersion(YarnVersionInfo.getVersion());\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "0a641496c706fc175e7bf66d69ebf71c7d078e84": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1372. Ensure all completed containers are reported to the AMs across RM restart. Contributed by Anubhav Dhoot\n",
      "commitDate": "22/09/14 10:30 AM",
      "commitName": "0a641496c706fc175e7bf66d69ebf71c7d078e84",
      "commitAuthor": "Jian He",
      "commitDateOld": "29/08/14 11:05 PM",
      "commitNameOld": "5c14bc426b4be381383018ebc2236be83eef15cd",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 23.48,
      "commitsBetweenForRepo": 230,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,103 +1,103 @@\n   public RegisterNodeManagerResponse registerNodeManager(\n       RegisterNodeManagerRequest request) throws YarnException,\n       IOException {\n     NodeId nodeId \u003d request.getNodeId();\n     String host \u003d nodeId.getHost();\n     int cmPort \u003d nodeId.getPort();\n     int httpPort \u003d request.getHttpPort();\n     Resource capability \u003d request.getResource();\n     String nodeManagerVersion \u003d request.getNMVersion();\n \n     RegisterNodeManagerResponse response \u003d recordFactory\n         .newRecordInstance(RegisterNodeManagerResponse.class);\n \n     if (!minimumNodeManagerVersion.equals(\"NONE\")) {\n       if (minimumNodeManagerVersion.equals(\"EqualToRM\")) {\n         minimumNodeManagerVersion \u003d YarnVersionInfo.getVersion();\n       }\n \n       if ((nodeManagerVersion \u003d\u003d null) ||\n           (VersionUtil.compareVersions(nodeManagerVersion,minimumNodeManagerVersion)) \u003c 0) {\n         String message \u003d\n             \"Disallowed NodeManager Version \" + nodeManagerVersion\n                 + \", is less than the minimum version \"\n                 + minimumNodeManagerVersion + \" sending SHUTDOWN signal to \"\n                 + \"NodeManager.\";\n         LOG.info(message);\n         response.setDiagnosticsMessage(message);\n         response.setNodeAction(NodeAction.SHUTDOWN);\n         return response;\n       }\n     }\n \n     // Check if this node is a \u0027valid\u0027 node\n     if (!this.nodesListManager.isValidNode(host)) {\n       String message \u003d\n           \"Disallowed NodeManager from  \" + host\n               + \", Sending SHUTDOWN signal to the NodeManager.\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     // Check if this node has minimum allocations\n     if (capability.getMemory() \u003c minAllocMb\n         || capability.getVirtualCores() \u003c minAllocVcores) {\n       String message \u003d\n           \"NodeManager from  \" + host\n               + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n               + \" signal to the NodeManager.\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     response.setContainerTokenMasterKey(containerTokenSecretManager\n         .getCurrentKey());\n     response.setNMTokenMasterKey(nmTokenSecretManager\n         .getCurrentKey());    \n \n     RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n         resolve(host), capability, nodeManagerVersion);\n \n     RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n     if (oldNode \u003d\u003d null) {\n       this.rmContext.getDispatcher().getEventHandler().handle(\n               new RMNodeStartedEvent(nodeId, request.getNMContainerStatuses(),\n                   request.getRunningApplications()));\n     } else {\n       LOG.info(\"Reconnect from the node at: \" + host);\n       this.nmLivelinessMonitor.unregister(nodeId);\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeReconnectEvent(nodeId, rmNode,\n               request.getRunningApplications()));\n     }\n     // On every node manager register we will be clearing NMToken keys if\n     // present for any running application.\n     this.nmTokenSecretManager.removeNodeKey(nodeId);\n     this.nmLivelinessMonitor.register(nodeId);\n     \n     // Handle received container status, this should be processed after new\n     // RMNode inserted\n     if (!rmContext.isWorkPreservingRecoveryEnabled()) {\n       if (!request.getNMContainerStatuses().isEmpty()) {\n         LOG.info(\"received container statuses on node manager register :\"\n             + request.getNMContainerStatuses());\n         for (NMContainerStatus status : request.getNMContainerStatuses()) {\n-          handleNMContainerStatus(status);\n+          handleNMContainerStatus(status, nodeId);\n         }\n       }\n     }\n \n     String message \u003d\n         \"NodeManager from node \" + host + \"(cmPort: \" + cmPort + \" httpPort: \"\n             + httpPort + \") \" + \"registered with capability: \" + capability\n             + \", assigned nodeId \" + nodeId;\n     LOG.info(message);\n     response.setNodeAction(NodeAction.NORMAL);\n     response.setRMIdentifier(ResourceManager.getClusterTimeStamp());\n     response.setRMVersion(YarnVersionInfo.getVersion());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterNodeManagerResponse registerNodeManager(\n      RegisterNodeManagerRequest request) throws YarnException,\n      IOException {\n    NodeId nodeId \u003d request.getNodeId();\n    String host \u003d nodeId.getHost();\n    int cmPort \u003d nodeId.getPort();\n    int httpPort \u003d request.getHttpPort();\n    Resource capability \u003d request.getResource();\n    String nodeManagerVersion \u003d request.getNMVersion();\n\n    RegisterNodeManagerResponse response \u003d recordFactory\n        .newRecordInstance(RegisterNodeManagerResponse.class);\n\n    if (!minimumNodeManagerVersion.equals(\"NONE\")) {\n      if (minimumNodeManagerVersion.equals(\"EqualToRM\")) {\n        minimumNodeManagerVersion \u003d YarnVersionInfo.getVersion();\n      }\n\n      if ((nodeManagerVersion \u003d\u003d null) ||\n          (VersionUtil.compareVersions(nodeManagerVersion,minimumNodeManagerVersion)) \u003c 0) {\n        String message \u003d\n            \"Disallowed NodeManager Version \" + nodeManagerVersion\n                + \", is less than the minimum version \"\n                + minimumNodeManagerVersion + \" sending SHUTDOWN signal to \"\n                + \"NodeManager.\";\n        LOG.info(message);\n        response.setDiagnosticsMessage(message);\n        response.setNodeAction(NodeAction.SHUTDOWN);\n        return response;\n      }\n    }\n\n    // Check if this node is a \u0027valid\u0027 node\n    if (!this.nodesListManager.isValidNode(host)) {\n      String message \u003d\n          \"Disallowed NodeManager from  \" + host\n              + \", Sending SHUTDOWN signal to the NodeManager.\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    // Check if this node has minimum allocations\n    if (capability.getMemory() \u003c minAllocMb\n        || capability.getVirtualCores() \u003c minAllocVcores) {\n      String message \u003d\n          \"NodeManager from  \" + host\n              + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n              + \" signal to the NodeManager.\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    response.setContainerTokenMasterKey(containerTokenSecretManager\n        .getCurrentKey());\n    response.setNMTokenMasterKey(nmTokenSecretManager\n        .getCurrentKey());    \n\n    RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n        resolve(host), capability, nodeManagerVersion);\n\n    RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n    if (oldNode \u003d\u003d null) {\n      this.rmContext.getDispatcher().getEventHandler().handle(\n              new RMNodeStartedEvent(nodeId, request.getNMContainerStatuses(),\n                  request.getRunningApplications()));\n    } else {\n      LOG.info(\"Reconnect from the node at: \" + host);\n      this.nmLivelinessMonitor.unregister(nodeId);\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeReconnectEvent(nodeId, rmNode,\n              request.getRunningApplications()));\n    }\n    // On every node manager register we will be clearing NMToken keys if\n    // present for any running application.\n    this.nmTokenSecretManager.removeNodeKey(nodeId);\n    this.nmLivelinessMonitor.register(nodeId);\n    \n    // Handle received container status, this should be processed after new\n    // RMNode inserted\n    if (!rmContext.isWorkPreservingRecoveryEnabled()) {\n      if (!request.getNMContainerStatuses().isEmpty()) {\n        LOG.info(\"received container statuses on node manager register :\"\n            + request.getNMContainerStatuses());\n        for (NMContainerStatus status : request.getNMContainerStatuses()) {\n          handleNMContainerStatus(status, nodeId);\n        }\n      }\n    }\n\n    String message \u003d\n        \"NodeManager from node \" + host + \"(cmPort: \" + cmPort + \" httpPort: \"\n            + httpPort + \") \" + \"registered with capability: \" + capability\n            + \", assigned nodeId \" + nodeId;\n    LOG.info(message);\n    response.setNodeAction(NodeAction.NORMAL);\n    response.setRMIdentifier(ResourceManager.getClusterTimeStamp());\n    response.setRMVersion(YarnVersionInfo.getVersion());\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "5c14bc426b4be381383018ebc2236be83eef15cd": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1506. Changed RMNode/SchedulerNode to update resource with event notification. Contributed by Junping Du\n",
      "commitDate": "29/08/14 11:05 PM",
      "commitName": "5c14bc426b4be381383018ebc2236be83eef15cd",
      "commitAuthor": "Jian He",
      "commitDateOld": "04/08/14 6:25 AM",
      "commitNameOld": "b8f151231ba37247b9daa23ecce1211fdca0e49f",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 25.69,
      "commitsBetweenForRepo": 224,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,104 +1,103 @@\n   public RegisterNodeManagerResponse registerNodeManager(\n       RegisterNodeManagerRequest request) throws YarnException,\n       IOException {\n     NodeId nodeId \u003d request.getNodeId();\n     String host \u003d nodeId.getHost();\n     int cmPort \u003d nodeId.getPort();\n     int httpPort \u003d request.getHttpPort();\n     Resource capability \u003d request.getResource();\n     String nodeManagerVersion \u003d request.getNMVersion();\n \n     RegisterNodeManagerResponse response \u003d recordFactory\n         .newRecordInstance(RegisterNodeManagerResponse.class);\n \n     if (!minimumNodeManagerVersion.equals(\"NONE\")) {\n       if (minimumNodeManagerVersion.equals(\"EqualToRM\")) {\n         minimumNodeManagerVersion \u003d YarnVersionInfo.getVersion();\n       }\n \n       if ((nodeManagerVersion \u003d\u003d null) ||\n           (VersionUtil.compareVersions(nodeManagerVersion,minimumNodeManagerVersion)) \u003c 0) {\n         String message \u003d\n             \"Disallowed NodeManager Version \" + nodeManagerVersion\n                 + \", is less than the minimum version \"\n                 + minimumNodeManagerVersion + \" sending SHUTDOWN signal to \"\n                 + \"NodeManager.\";\n         LOG.info(message);\n         response.setDiagnosticsMessage(message);\n         response.setNodeAction(NodeAction.SHUTDOWN);\n         return response;\n       }\n     }\n \n     // Check if this node is a \u0027valid\u0027 node\n     if (!this.nodesListManager.isValidNode(host)) {\n       String message \u003d\n           \"Disallowed NodeManager from  \" + host\n               + \", Sending SHUTDOWN signal to the NodeManager.\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     // Check if this node has minimum allocations\n     if (capability.getMemory() \u003c minAllocMb\n         || capability.getVirtualCores() \u003c minAllocVcores) {\n       String message \u003d\n           \"NodeManager from  \" + host\n               + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n               + \" signal to the NodeManager.\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     response.setContainerTokenMasterKey(containerTokenSecretManager\n         .getCurrentKey());\n     response.setNMTokenMasterKey(nmTokenSecretManager\n         .getCurrentKey());    \n \n     RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n-        resolve(host), ResourceOption.newInstance(capability, RMNode.OVER_COMMIT_TIMEOUT_MILLIS_DEFAULT),\n-        nodeManagerVersion);\n+        resolve(host), capability, nodeManagerVersion);\n \n     RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n     if (oldNode \u003d\u003d null) {\n       this.rmContext.getDispatcher().getEventHandler().handle(\n               new RMNodeStartedEvent(nodeId, request.getNMContainerStatuses(),\n                   request.getRunningApplications()));\n     } else {\n       LOG.info(\"Reconnect from the node at: \" + host);\n       this.nmLivelinessMonitor.unregister(nodeId);\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeReconnectEvent(nodeId, rmNode,\n               request.getRunningApplications()));\n     }\n     // On every node manager register we will be clearing NMToken keys if\n     // present for any running application.\n     this.nmTokenSecretManager.removeNodeKey(nodeId);\n     this.nmLivelinessMonitor.register(nodeId);\n     \n     // Handle received container status, this should be processed after new\n     // RMNode inserted\n     if (!rmContext.isWorkPreservingRecoveryEnabled()) {\n       if (!request.getNMContainerStatuses().isEmpty()) {\n         LOG.info(\"received container statuses on node manager register :\"\n             + request.getNMContainerStatuses());\n         for (NMContainerStatus status : request.getNMContainerStatuses()) {\n           handleNMContainerStatus(status);\n         }\n       }\n     }\n \n     String message \u003d\n         \"NodeManager from node \" + host + \"(cmPort: \" + cmPort + \" httpPort: \"\n             + httpPort + \") \" + \"registered with capability: \" + capability\n             + \", assigned nodeId \" + nodeId;\n     LOG.info(message);\n     response.setNodeAction(NodeAction.NORMAL);\n     response.setRMIdentifier(ResourceManager.getClusterTimeStamp());\n     response.setRMVersion(YarnVersionInfo.getVersion());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterNodeManagerResponse registerNodeManager(\n      RegisterNodeManagerRequest request) throws YarnException,\n      IOException {\n    NodeId nodeId \u003d request.getNodeId();\n    String host \u003d nodeId.getHost();\n    int cmPort \u003d nodeId.getPort();\n    int httpPort \u003d request.getHttpPort();\n    Resource capability \u003d request.getResource();\n    String nodeManagerVersion \u003d request.getNMVersion();\n\n    RegisterNodeManagerResponse response \u003d recordFactory\n        .newRecordInstance(RegisterNodeManagerResponse.class);\n\n    if (!minimumNodeManagerVersion.equals(\"NONE\")) {\n      if (minimumNodeManagerVersion.equals(\"EqualToRM\")) {\n        minimumNodeManagerVersion \u003d YarnVersionInfo.getVersion();\n      }\n\n      if ((nodeManagerVersion \u003d\u003d null) ||\n          (VersionUtil.compareVersions(nodeManagerVersion,minimumNodeManagerVersion)) \u003c 0) {\n        String message \u003d\n            \"Disallowed NodeManager Version \" + nodeManagerVersion\n                + \", is less than the minimum version \"\n                + minimumNodeManagerVersion + \" sending SHUTDOWN signal to \"\n                + \"NodeManager.\";\n        LOG.info(message);\n        response.setDiagnosticsMessage(message);\n        response.setNodeAction(NodeAction.SHUTDOWN);\n        return response;\n      }\n    }\n\n    // Check if this node is a \u0027valid\u0027 node\n    if (!this.nodesListManager.isValidNode(host)) {\n      String message \u003d\n          \"Disallowed NodeManager from  \" + host\n              + \", Sending SHUTDOWN signal to the NodeManager.\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    // Check if this node has minimum allocations\n    if (capability.getMemory() \u003c minAllocMb\n        || capability.getVirtualCores() \u003c minAllocVcores) {\n      String message \u003d\n          \"NodeManager from  \" + host\n              + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n              + \" signal to the NodeManager.\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    response.setContainerTokenMasterKey(containerTokenSecretManager\n        .getCurrentKey());\n    response.setNMTokenMasterKey(nmTokenSecretManager\n        .getCurrentKey());    \n\n    RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n        resolve(host), capability, nodeManagerVersion);\n\n    RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n    if (oldNode \u003d\u003d null) {\n      this.rmContext.getDispatcher().getEventHandler().handle(\n              new RMNodeStartedEvent(nodeId, request.getNMContainerStatuses(),\n                  request.getRunningApplications()));\n    } else {\n      LOG.info(\"Reconnect from the node at: \" + host);\n      this.nmLivelinessMonitor.unregister(nodeId);\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeReconnectEvent(nodeId, rmNode,\n              request.getRunningApplications()));\n    }\n    // On every node manager register we will be clearing NMToken keys if\n    // present for any running application.\n    this.nmTokenSecretManager.removeNodeKey(nodeId);\n    this.nmLivelinessMonitor.register(nodeId);\n    \n    // Handle received container status, this should be processed after new\n    // RMNode inserted\n    if (!rmContext.isWorkPreservingRecoveryEnabled()) {\n      if (!request.getNMContainerStatuses().isEmpty()) {\n        LOG.info(\"received container statuses on node manager register :\"\n            + request.getNMContainerStatuses());\n        for (NMContainerStatus status : request.getNMContainerStatuses()) {\n          handleNMContainerStatus(status);\n        }\n      }\n    }\n\n    String message \u003d\n        \"NodeManager from node \" + host + \"(cmPort: \" + cmPort + \" httpPort: \"\n            + httpPort + \") \" + \"registered with capability: \" + capability\n            + \", assigned nodeId \" + nodeId;\n    LOG.info(message);\n    response.setNodeAction(NodeAction.NORMAL);\n    response.setRMIdentifier(ResourceManager.getClusterTimeStamp());\n    response.setRMVersion(YarnVersionInfo.getVersion());\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "b8f151231ba37247b9daa23ecce1211fdca0e49f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1354. Recover applications upon nodemanager restart. (Contributed by Jason Lowe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1615550 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/08/14 6:25 AM",
      "commitName": "b8f151231ba37247b9daa23ecce1211fdca0e49f",
      "commitAuthor": "Junping Du",
      "commitDateOld": "31/07/14 1:06 PM",
      "commitNameOld": "e52f67e3897a67a0b6d29e557a31cfa881738821",
      "commitAuthorOld": "Xuan Gong",
      "daysBetweenCommits": 3.72,
      "commitsBetweenForRepo": 22,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,103 +1,104 @@\n   public RegisterNodeManagerResponse registerNodeManager(\n       RegisterNodeManagerRequest request) throws YarnException,\n       IOException {\n     NodeId nodeId \u003d request.getNodeId();\n     String host \u003d nodeId.getHost();\n     int cmPort \u003d nodeId.getPort();\n     int httpPort \u003d request.getHttpPort();\n     Resource capability \u003d request.getResource();\n     String nodeManagerVersion \u003d request.getNMVersion();\n \n     RegisterNodeManagerResponse response \u003d recordFactory\n         .newRecordInstance(RegisterNodeManagerResponse.class);\n \n     if (!minimumNodeManagerVersion.equals(\"NONE\")) {\n       if (minimumNodeManagerVersion.equals(\"EqualToRM\")) {\n         minimumNodeManagerVersion \u003d YarnVersionInfo.getVersion();\n       }\n \n       if ((nodeManagerVersion \u003d\u003d null) ||\n           (VersionUtil.compareVersions(nodeManagerVersion,minimumNodeManagerVersion)) \u003c 0) {\n         String message \u003d\n             \"Disallowed NodeManager Version \" + nodeManagerVersion\n                 + \", is less than the minimum version \"\n                 + minimumNodeManagerVersion + \" sending SHUTDOWN signal to \"\n                 + \"NodeManager.\";\n         LOG.info(message);\n         response.setDiagnosticsMessage(message);\n         response.setNodeAction(NodeAction.SHUTDOWN);\n         return response;\n       }\n     }\n \n     // Check if this node is a \u0027valid\u0027 node\n     if (!this.nodesListManager.isValidNode(host)) {\n       String message \u003d\n           \"Disallowed NodeManager from  \" + host\n               + \", Sending SHUTDOWN signal to the NodeManager.\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     // Check if this node has minimum allocations\n     if (capability.getMemory() \u003c minAllocMb\n         || capability.getVirtualCores() \u003c minAllocVcores) {\n       String message \u003d\n           \"NodeManager from  \" + host\n               + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n               + \" signal to the NodeManager.\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     response.setContainerTokenMasterKey(containerTokenSecretManager\n         .getCurrentKey());\n     response.setNMTokenMasterKey(nmTokenSecretManager\n         .getCurrentKey());    \n \n     RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n         resolve(host), ResourceOption.newInstance(capability, RMNode.OVER_COMMIT_TIMEOUT_MILLIS_DEFAULT),\n         nodeManagerVersion);\n \n     RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n     if (oldNode \u003d\u003d null) {\n       this.rmContext.getDispatcher().getEventHandler().handle(\n               new RMNodeStartedEvent(nodeId, request.getNMContainerStatuses(),\n                   request.getRunningApplications()));\n     } else {\n       LOG.info(\"Reconnect from the node at: \" + host);\n       this.nmLivelinessMonitor.unregister(nodeId);\n       this.rmContext.getDispatcher().getEventHandler().handle(\n-          new RMNodeReconnectEvent(nodeId, rmNode));\n+          new RMNodeReconnectEvent(nodeId, rmNode,\n+              request.getRunningApplications()));\n     }\n     // On every node manager register we will be clearing NMToken keys if\n     // present for any running application.\n     this.nmTokenSecretManager.removeNodeKey(nodeId);\n     this.nmLivelinessMonitor.register(nodeId);\n     \n     // Handle received container status, this should be processed after new\n     // RMNode inserted\n     if (!rmContext.isWorkPreservingRecoveryEnabled()) {\n       if (!request.getNMContainerStatuses().isEmpty()) {\n         LOG.info(\"received container statuses on node manager register :\"\n             + request.getNMContainerStatuses());\n         for (NMContainerStatus status : request.getNMContainerStatuses()) {\n           handleNMContainerStatus(status);\n         }\n       }\n     }\n \n     String message \u003d\n         \"NodeManager from node \" + host + \"(cmPort: \" + cmPort + \" httpPort: \"\n             + httpPort + \") \" + \"registered with capability: \" + capability\n             + \", assigned nodeId \" + nodeId;\n     LOG.info(message);\n     response.setNodeAction(NodeAction.NORMAL);\n     response.setRMIdentifier(ResourceManager.getClusterTimeStamp());\n     response.setRMVersion(YarnVersionInfo.getVersion());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterNodeManagerResponse registerNodeManager(\n      RegisterNodeManagerRequest request) throws YarnException,\n      IOException {\n    NodeId nodeId \u003d request.getNodeId();\n    String host \u003d nodeId.getHost();\n    int cmPort \u003d nodeId.getPort();\n    int httpPort \u003d request.getHttpPort();\n    Resource capability \u003d request.getResource();\n    String nodeManagerVersion \u003d request.getNMVersion();\n\n    RegisterNodeManagerResponse response \u003d recordFactory\n        .newRecordInstance(RegisterNodeManagerResponse.class);\n\n    if (!minimumNodeManagerVersion.equals(\"NONE\")) {\n      if (minimumNodeManagerVersion.equals(\"EqualToRM\")) {\n        minimumNodeManagerVersion \u003d YarnVersionInfo.getVersion();\n      }\n\n      if ((nodeManagerVersion \u003d\u003d null) ||\n          (VersionUtil.compareVersions(nodeManagerVersion,minimumNodeManagerVersion)) \u003c 0) {\n        String message \u003d\n            \"Disallowed NodeManager Version \" + nodeManagerVersion\n                + \", is less than the minimum version \"\n                + minimumNodeManagerVersion + \" sending SHUTDOWN signal to \"\n                + \"NodeManager.\";\n        LOG.info(message);\n        response.setDiagnosticsMessage(message);\n        response.setNodeAction(NodeAction.SHUTDOWN);\n        return response;\n      }\n    }\n\n    // Check if this node is a \u0027valid\u0027 node\n    if (!this.nodesListManager.isValidNode(host)) {\n      String message \u003d\n          \"Disallowed NodeManager from  \" + host\n              + \", Sending SHUTDOWN signal to the NodeManager.\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    // Check if this node has minimum allocations\n    if (capability.getMemory() \u003c minAllocMb\n        || capability.getVirtualCores() \u003c minAllocVcores) {\n      String message \u003d\n          \"NodeManager from  \" + host\n              + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n              + \" signal to the NodeManager.\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    response.setContainerTokenMasterKey(containerTokenSecretManager\n        .getCurrentKey());\n    response.setNMTokenMasterKey(nmTokenSecretManager\n        .getCurrentKey());    \n\n    RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n        resolve(host), ResourceOption.newInstance(capability, RMNode.OVER_COMMIT_TIMEOUT_MILLIS_DEFAULT),\n        nodeManagerVersion);\n\n    RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n    if (oldNode \u003d\u003d null) {\n      this.rmContext.getDispatcher().getEventHandler().handle(\n              new RMNodeStartedEvent(nodeId, request.getNMContainerStatuses(),\n                  request.getRunningApplications()));\n    } else {\n      LOG.info(\"Reconnect from the node at: \" + host);\n      this.nmLivelinessMonitor.unregister(nodeId);\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeReconnectEvent(nodeId, rmNode,\n              request.getRunningApplications()));\n    }\n    // On every node manager register we will be clearing NMToken keys if\n    // present for any running application.\n    this.nmTokenSecretManager.removeNodeKey(nodeId);\n    this.nmLivelinessMonitor.register(nodeId);\n    \n    // Handle received container status, this should be processed after new\n    // RMNode inserted\n    if (!rmContext.isWorkPreservingRecoveryEnabled()) {\n      if (!request.getNMContainerStatuses().isEmpty()) {\n        LOG.info(\"received container statuses on node manager register :\"\n            + request.getNMContainerStatuses());\n        for (NMContainerStatus status : request.getNMContainerStatuses()) {\n          handleNMContainerStatus(status);\n        }\n      }\n    }\n\n    String message \u003d\n        \"NodeManager from node \" + host + \"(cmPort: \" + cmPort + \" httpPort: \"\n            + httpPort + \") \" + \"registered with capability: \" + capability\n            + \", assigned nodeId \" + nodeId;\n    LOG.info(message);\n    response.setNodeAction(NodeAction.NORMAL);\n    response.setRMIdentifier(ResourceManager.getClusterTimeStamp());\n    response.setRMVersion(YarnVersionInfo.getVersion());\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "95897ca14b7abd7fe047fdcf150473a8a2cbb024": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1885. Fixed a bug that RM may not send application-clean-up signal to NMs where the completed applications previously ran in case of RM restart. Contributed by Wangda Tan\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1603028 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/06/14 4:56 PM",
      "commitName": "95897ca14b7abd7fe047fdcf150473a8a2cbb024",
      "commitAuthor": "Jian He",
      "commitDateOld": "08/06/14 8:09 PM",
      "commitNameOld": "424fd9494f144c035fdef8c533be51e2027ad8d9",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 7.87,
      "commitsBetweenForRepo": 56,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,99 +1,103 @@\n   public RegisterNodeManagerResponse registerNodeManager(\n       RegisterNodeManagerRequest request) throws YarnException,\n       IOException {\n     NodeId nodeId \u003d request.getNodeId();\n     String host \u003d nodeId.getHost();\n     int cmPort \u003d nodeId.getPort();\n     int httpPort \u003d request.getHttpPort();\n     Resource capability \u003d request.getResource();\n     String nodeManagerVersion \u003d request.getNMVersion();\n \n-    if (!rmContext.isWorkPreservingRecoveryEnabled()) {\n-      if (!request.getNMContainerStatuses().isEmpty()) {\n-        LOG.info(\"received container statuses on node manager register :\"\n-            + request.getNMContainerStatuses());\n-        for (NMContainerStatus status : request.getNMContainerStatuses()) {\n-          handleNMContainerStatus(status);\n-        }\n-      }\n-    }\n     RegisterNodeManagerResponse response \u003d recordFactory\n         .newRecordInstance(RegisterNodeManagerResponse.class);\n \n     if (!minimumNodeManagerVersion.equals(\"NONE\")) {\n       if (minimumNodeManagerVersion.equals(\"EqualToRM\")) {\n         minimumNodeManagerVersion \u003d YarnVersionInfo.getVersion();\n       }\n \n       if ((nodeManagerVersion \u003d\u003d null) ||\n           (VersionUtil.compareVersions(nodeManagerVersion,minimumNodeManagerVersion)) \u003c 0) {\n         String message \u003d\n             \"Disallowed NodeManager Version \" + nodeManagerVersion\n                 + \", is less than the minimum version \"\n                 + minimumNodeManagerVersion + \" sending SHUTDOWN signal to \"\n                 + \"NodeManager.\";\n         LOG.info(message);\n         response.setDiagnosticsMessage(message);\n         response.setNodeAction(NodeAction.SHUTDOWN);\n         return response;\n       }\n     }\n \n     // Check if this node is a \u0027valid\u0027 node\n     if (!this.nodesListManager.isValidNode(host)) {\n       String message \u003d\n           \"Disallowed NodeManager from  \" + host\n               + \", Sending SHUTDOWN signal to the NodeManager.\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     // Check if this node has minimum allocations\n     if (capability.getMemory() \u003c minAllocMb\n         || capability.getVirtualCores() \u003c minAllocVcores) {\n       String message \u003d\n           \"NodeManager from  \" + host\n               + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n               + \" signal to the NodeManager.\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     response.setContainerTokenMasterKey(containerTokenSecretManager\n         .getCurrentKey());\n     response.setNMTokenMasterKey(nmTokenSecretManager\n         .getCurrentKey());    \n \n     RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n         resolve(host), ResourceOption.newInstance(capability, RMNode.OVER_COMMIT_TIMEOUT_MILLIS_DEFAULT),\n         nodeManagerVersion);\n \n     RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n     if (oldNode \u003d\u003d null) {\n       this.rmContext.getDispatcher().getEventHandler().handle(\n-          new RMNodeStartedEvent(nodeId, request.getNMContainerStatuses()));\n+              new RMNodeStartedEvent(nodeId, request.getNMContainerStatuses(),\n+                  request.getRunningApplications()));\n     } else {\n       LOG.info(\"Reconnect from the node at: \" + host);\n       this.nmLivelinessMonitor.unregister(nodeId);\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeReconnectEvent(nodeId, rmNode));\n     }\n     // On every node manager register we will be clearing NMToken keys if\n     // present for any running application.\n     this.nmTokenSecretManager.removeNodeKey(nodeId);\n     this.nmLivelinessMonitor.register(nodeId);\n+    \n+    // Handle received container status, this should be processed after new\n+    // RMNode inserted\n+    if (!rmContext.isWorkPreservingRecoveryEnabled()) {\n+      if (!request.getNMContainerStatuses().isEmpty()) {\n+        LOG.info(\"received container statuses on node manager register :\"\n+            + request.getNMContainerStatuses());\n+        for (NMContainerStatus status : request.getNMContainerStatuses()) {\n+          handleNMContainerStatus(status);\n+        }\n+      }\n+    }\n \n     String message \u003d\n         \"NodeManager from node \" + host + \"(cmPort: \" + cmPort + \" httpPort: \"\n             + httpPort + \") \" + \"registered with capability: \" + capability\n             + \", assigned nodeId \" + nodeId;\n     LOG.info(message);\n     response.setNodeAction(NodeAction.NORMAL);\n     response.setRMIdentifier(ResourceManager.getClusterTimeStamp());\n     response.setRMVersion(YarnVersionInfo.getVersion());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterNodeManagerResponse registerNodeManager(\n      RegisterNodeManagerRequest request) throws YarnException,\n      IOException {\n    NodeId nodeId \u003d request.getNodeId();\n    String host \u003d nodeId.getHost();\n    int cmPort \u003d nodeId.getPort();\n    int httpPort \u003d request.getHttpPort();\n    Resource capability \u003d request.getResource();\n    String nodeManagerVersion \u003d request.getNMVersion();\n\n    RegisterNodeManagerResponse response \u003d recordFactory\n        .newRecordInstance(RegisterNodeManagerResponse.class);\n\n    if (!minimumNodeManagerVersion.equals(\"NONE\")) {\n      if (minimumNodeManagerVersion.equals(\"EqualToRM\")) {\n        minimumNodeManagerVersion \u003d YarnVersionInfo.getVersion();\n      }\n\n      if ((nodeManagerVersion \u003d\u003d null) ||\n          (VersionUtil.compareVersions(nodeManagerVersion,minimumNodeManagerVersion)) \u003c 0) {\n        String message \u003d\n            \"Disallowed NodeManager Version \" + nodeManagerVersion\n                + \", is less than the minimum version \"\n                + minimumNodeManagerVersion + \" sending SHUTDOWN signal to \"\n                + \"NodeManager.\";\n        LOG.info(message);\n        response.setDiagnosticsMessage(message);\n        response.setNodeAction(NodeAction.SHUTDOWN);\n        return response;\n      }\n    }\n\n    // Check if this node is a \u0027valid\u0027 node\n    if (!this.nodesListManager.isValidNode(host)) {\n      String message \u003d\n          \"Disallowed NodeManager from  \" + host\n              + \", Sending SHUTDOWN signal to the NodeManager.\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    // Check if this node has minimum allocations\n    if (capability.getMemory() \u003c minAllocMb\n        || capability.getVirtualCores() \u003c minAllocVcores) {\n      String message \u003d\n          \"NodeManager from  \" + host\n              + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n              + \" signal to the NodeManager.\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    response.setContainerTokenMasterKey(containerTokenSecretManager\n        .getCurrentKey());\n    response.setNMTokenMasterKey(nmTokenSecretManager\n        .getCurrentKey());    \n\n    RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n        resolve(host), ResourceOption.newInstance(capability, RMNode.OVER_COMMIT_TIMEOUT_MILLIS_DEFAULT),\n        nodeManagerVersion);\n\n    RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n    if (oldNode \u003d\u003d null) {\n      this.rmContext.getDispatcher().getEventHandler().handle(\n              new RMNodeStartedEvent(nodeId, request.getNMContainerStatuses(),\n                  request.getRunningApplications()));\n    } else {\n      LOG.info(\"Reconnect from the node at: \" + host);\n      this.nmLivelinessMonitor.unregister(nodeId);\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeReconnectEvent(nodeId, rmNode));\n    }\n    // On every node manager register we will be clearing NMToken keys if\n    // present for any running application.\n    this.nmTokenSecretManager.removeNodeKey(nodeId);\n    this.nmLivelinessMonitor.register(nodeId);\n    \n    // Handle received container status, this should be processed after new\n    // RMNode inserted\n    if (!rmContext.isWorkPreservingRecoveryEnabled()) {\n      if (!request.getNMContainerStatuses().isEmpty()) {\n        LOG.info(\"received container statuses on node manager register :\"\n            + request.getNMContainerStatuses());\n        for (NMContainerStatus status : request.getNMContainerStatuses()) {\n          handleNMContainerStatus(status);\n        }\n      }\n    }\n\n    String message \u003d\n        \"NodeManager from node \" + host + \"(cmPort: \" + cmPort + \" httpPort: \"\n            + httpPort + \") \" + \"registered with capability: \" + capability\n            + \", assigned nodeId \" + nodeId;\n    LOG.info(message);\n    response.setNodeAction(NodeAction.NORMAL);\n    response.setRMIdentifier(ResourceManager.getClusterTimeStamp());\n    response.setRMVersion(YarnVersionInfo.getVersion());\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "424fd9494f144c035fdef8c533be51e2027ad8d9": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1368. Added core functionality of recovering container state into schedulers after ResourceManager Restart so as to preserve running work in the cluster. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1601303 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/06/14 8:09 PM",
      "commitName": "424fd9494f144c035fdef8c533be51e2027ad8d9",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "30/05/14 5:20 PM",
      "commitNameOld": "23c325ad47e305989b7f2cf172bd709f73dd26d1",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 9.12,
      "commitsBetweenForRepo": 31,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,97 +1,99 @@\n   public RegisterNodeManagerResponse registerNodeManager(\n       RegisterNodeManagerRequest request) throws YarnException,\n       IOException {\n     NodeId nodeId \u003d request.getNodeId();\n     String host \u003d nodeId.getHost();\n     int cmPort \u003d nodeId.getPort();\n     int httpPort \u003d request.getHttpPort();\n     Resource capability \u003d request.getResource();\n     String nodeManagerVersion \u003d request.getNMVersion();\n \n-    if (!request.getNMContainerStatuses().isEmpty()) {\n-      LOG.info(\"received container statuses on node manager register :\"\n-          + request.getNMContainerStatuses());\n-      for (NMContainerStatus report : request.getNMContainerStatuses()) {\n-        handleNMContainerStatus(report);\n+    if (!rmContext.isWorkPreservingRecoveryEnabled()) {\n+      if (!request.getNMContainerStatuses().isEmpty()) {\n+        LOG.info(\"received container statuses on node manager register :\"\n+            + request.getNMContainerStatuses());\n+        for (NMContainerStatus status : request.getNMContainerStatuses()) {\n+          handleNMContainerStatus(status);\n+        }\n       }\n     }\n     RegisterNodeManagerResponse response \u003d recordFactory\n         .newRecordInstance(RegisterNodeManagerResponse.class);\n \n     if (!minimumNodeManagerVersion.equals(\"NONE\")) {\n       if (minimumNodeManagerVersion.equals(\"EqualToRM\")) {\n         minimumNodeManagerVersion \u003d YarnVersionInfo.getVersion();\n       }\n \n       if ((nodeManagerVersion \u003d\u003d null) ||\n           (VersionUtil.compareVersions(nodeManagerVersion,minimumNodeManagerVersion)) \u003c 0) {\n         String message \u003d\n             \"Disallowed NodeManager Version \" + nodeManagerVersion\n                 + \", is less than the minimum version \"\n                 + minimumNodeManagerVersion + \" sending SHUTDOWN signal to \"\n                 + \"NodeManager.\";\n         LOG.info(message);\n         response.setDiagnosticsMessage(message);\n         response.setNodeAction(NodeAction.SHUTDOWN);\n         return response;\n       }\n     }\n \n     // Check if this node is a \u0027valid\u0027 node\n     if (!this.nodesListManager.isValidNode(host)) {\n       String message \u003d\n           \"Disallowed NodeManager from  \" + host\n               + \", Sending SHUTDOWN signal to the NodeManager.\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     // Check if this node has minimum allocations\n     if (capability.getMemory() \u003c minAllocMb\n         || capability.getVirtualCores() \u003c minAllocVcores) {\n       String message \u003d\n           \"NodeManager from  \" + host\n               + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n               + \" signal to the NodeManager.\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     response.setContainerTokenMasterKey(containerTokenSecretManager\n         .getCurrentKey());\n     response.setNMTokenMasterKey(nmTokenSecretManager\n         .getCurrentKey());    \n \n     RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n         resolve(host), ResourceOption.newInstance(capability, RMNode.OVER_COMMIT_TIMEOUT_MILLIS_DEFAULT),\n         nodeManagerVersion);\n \n     RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n     if (oldNode \u003d\u003d null) {\n       this.rmContext.getDispatcher().getEventHandler().handle(\n-          new RMNodeEvent(nodeId, RMNodeEventType.STARTED));\n+          new RMNodeStartedEvent(nodeId, request.getNMContainerStatuses()));\n     } else {\n       LOG.info(\"Reconnect from the node at: \" + host);\n       this.nmLivelinessMonitor.unregister(nodeId);\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeReconnectEvent(nodeId, rmNode));\n     }\n     // On every node manager register we will be clearing NMToken keys if\n     // present for any running application.\n     this.nmTokenSecretManager.removeNodeKey(nodeId);\n     this.nmLivelinessMonitor.register(nodeId);\n \n     String message \u003d\n         \"NodeManager from node \" + host + \"(cmPort: \" + cmPort + \" httpPort: \"\n             + httpPort + \") \" + \"registered with capability: \" + capability\n             + \", assigned nodeId \" + nodeId;\n     LOG.info(message);\n     response.setNodeAction(NodeAction.NORMAL);\n     response.setRMIdentifier(ResourceManager.getClusterTimeStamp());\n     response.setRMVersion(YarnVersionInfo.getVersion());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterNodeManagerResponse registerNodeManager(\n      RegisterNodeManagerRequest request) throws YarnException,\n      IOException {\n    NodeId nodeId \u003d request.getNodeId();\n    String host \u003d nodeId.getHost();\n    int cmPort \u003d nodeId.getPort();\n    int httpPort \u003d request.getHttpPort();\n    Resource capability \u003d request.getResource();\n    String nodeManagerVersion \u003d request.getNMVersion();\n\n    if (!rmContext.isWorkPreservingRecoveryEnabled()) {\n      if (!request.getNMContainerStatuses().isEmpty()) {\n        LOG.info(\"received container statuses on node manager register :\"\n            + request.getNMContainerStatuses());\n        for (NMContainerStatus status : request.getNMContainerStatuses()) {\n          handleNMContainerStatus(status);\n        }\n      }\n    }\n    RegisterNodeManagerResponse response \u003d recordFactory\n        .newRecordInstance(RegisterNodeManagerResponse.class);\n\n    if (!minimumNodeManagerVersion.equals(\"NONE\")) {\n      if (minimumNodeManagerVersion.equals(\"EqualToRM\")) {\n        minimumNodeManagerVersion \u003d YarnVersionInfo.getVersion();\n      }\n\n      if ((nodeManagerVersion \u003d\u003d null) ||\n          (VersionUtil.compareVersions(nodeManagerVersion,minimumNodeManagerVersion)) \u003c 0) {\n        String message \u003d\n            \"Disallowed NodeManager Version \" + nodeManagerVersion\n                + \", is less than the minimum version \"\n                + minimumNodeManagerVersion + \" sending SHUTDOWN signal to \"\n                + \"NodeManager.\";\n        LOG.info(message);\n        response.setDiagnosticsMessage(message);\n        response.setNodeAction(NodeAction.SHUTDOWN);\n        return response;\n      }\n    }\n\n    // Check if this node is a \u0027valid\u0027 node\n    if (!this.nodesListManager.isValidNode(host)) {\n      String message \u003d\n          \"Disallowed NodeManager from  \" + host\n              + \", Sending SHUTDOWN signal to the NodeManager.\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    // Check if this node has minimum allocations\n    if (capability.getMemory() \u003c minAllocMb\n        || capability.getVirtualCores() \u003c minAllocVcores) {\n      String message \u003d\n          \"NodeManager from  \" + host\n              + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n              + \" signal to the NodeManager.\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    response.setContainerTokenMasterKey(containerTokenSecretManager\n        .getCurrentKey());\n    response.setNMTokenMasterKey(nmTokenSecretManager\n        .getCurrentKey());    \n\n    RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n        resolve(host), ResourceOption.newInstance(capability, RMNode.OVER_COMMIT_TIMEOUT_MILLIS_DEFAULT),\n        nodeManagerVersion);\n\n    RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n    if (oldNode \u003d\u003d null) {\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeStartedEvent(nodeId, request.getNMContainerStatuses()));\n    } else {\n      LOG.info(\"Reconnect from the node at: \" + host);\n      this.nmLivelinessMonitor.unregister(nodeId);\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeReconnectEvent(nodeId, rmNode));\n    }\n    // On every node manager register we will be clearing NMToken keys if\n    // present for any running application.\n    this.nmTokenSecretManager.removeNodeKey(nodeId);\n    this.nmLivelinessMonitor.register(nodeId);\n\n    String message \u003d\n        \"NodeManager from node \" + host + \"(cmPort: \" + cmPort + \" httpPort: \"\n            + httpPort + \") \" + \"registered with capability: \" + capability\n            + \", assigned nodeId \" + nodeId;\n    LOG.info(message);\n    response.setNodeAction(NodeAction.NORMAL);\n    response.setRMIdentifier(ResourceManager.getClusterTimeStamp());\n    response.setRMVersion(YarnVersionInfo.getVersion());\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "23c325ad47e305989b7f2cf172bd709f73dd26d1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2115. Replaced RegisterNodeManagerRequest\u0027s ContainerStatus with a new NMContainerStatus which has more information that is needed for work-preserving RM-restart. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1598790 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/05/14 5:20 PM",
      "commitName": "23c325ad47e305989b7f2cf172bd709f73dd26d1",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "21/03/14 3:53 PM",
      "commitNameOld": "f67218809c50b194e463af6e6196db298353c8c1",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 70.06,
      "commitsBetweenForRepo": 428,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,97 +1,97 @@\n   public RegisterNodeManagerResponse registerNodeManager(\n       RegisterNodeManagerRequest request) throws YarnException,\n       IOException {\n     NodeId nodeId \u003d request.getNodeId();\n     String host \u003d nodeId.getHost();\n     int cmPort \u003d nodeId.getPort();\n     int httpPort \u003d request.getHttpPort();\n     Resource capability \u003d request.getResource();\n     String nodeManagerVersion \u003d request.getNMVersion();\n \n-    if (!request.getContainerStatuses().isEmpty()) {\n+    if (!request.getNMContainerStatuses().isEmpty()) {\n       LOG.info(\"received container statuses on node manager register :\"\n-          + request.getContainerStatuses());\n-      for (ContainerStatus containerStatus : request.getContainerStatuses()) {\n-        handleContainerStatus(containerStatus);\n+          + request.getNMContainerStatuses());\n+      for (NMContainerStatus report : request.getNMContainerStatuses()) {\n+        handleNMContainerStatus(report);\n       }\n     }\n     RegisterNodeManagerResponse response \u003d recordFactory\n         .newRecordInstance(RegisterNodeManagerResponse.class);\n \n     if (!minimumNodeManagerVersion.equals(\"NONE\")) {\n       if (minimumNodeManagerVersion.equals(\"EqualToRM\")) {\n         minimumNodeManagerVersion \u003d YarnVersionInfo.getVersion();\n       }\n \n       if ((nodeManagerVersion \u003d\u003d null) ||\n           (VersionUtil.compareVersions(nodeManagerVersion,minimumNodeManagerVersion)) \u003c 0) {\n         String message \u003d\n             \"Disallowed NodeManager Version \" + nodeManagerVersion\n                 + \", is less than the minimum version \"\n                 + minimumNodeManagerVersion + \" sending SHUTDOWN signal to \"\n                 + \"NodeManager.\";\n         LOG.info(message);\n         response.setDiagnosticsMessage(message);\n         response.setNodeAction(NodeAction.SHUTDOWN);\n         return response;\n       }\n     }\n \n     // Check if this node is a \u0027valid\u0027 node\n     if (!this.nodesListManager.isValidNode(host)) {\n       String message \u003d\n           \"Disallowed NodeManager from  \" + host\n               + \", Sending SHUTDOWN signal to the NodeManager.\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     // Check if this node has minimum allocations\n     if (capability.getMemory() \u003c minAllocMb\n         || capability.getVirtualCores() \u003c minAllocVcores) {\n       String message \u003d\n           \"NodeManager from  \" + host\n               + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n               + \" signal to the NodeManager.\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     response.setContainerTokenMasterKey(containerTokenSecretManager\n         .getCurrentKey());\n     response.setNMTokenMasterKey(nmTokenSecretManager\n         .getCurrentKey());    \n \n     RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n         resolve(host), ResourceOption.newInstance(capability, RMNode.OVER_COMMIT_TIMEOUT_MILLIS_DEFAULT),\n         nodeManagerVersion);\n \n     RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n     if (oldNode \u003d\u003d null) {\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.STARTED));\n     } else {\n       LOG.info(\"Reconnect from the node at: \" + host);\n       this.nmLivelinessMonitor.unregister(nodeId);\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeReconnectEvent(nodeId, rmNode));\n     }\n     // On every node manager register we will be clearing NMToken keys if\n     // present for any running application.\n     this.nmTokenSecretManager.removeNodeKey(nodeId);\n     this.nmLivelinessMonitor.register(nodeId);\n \n     String message \u003d\n         \"NodeManager from node \" + host + \"(cmPort: \" + cmPort + \" httpPort: \"\n             + httpPort + \") \" + \"registered with capability: \" + capability\n             + \", assigned nodeId \" + nodeId;\n     LOG.info(message);\n     response.setNodeAction(NodeAction.NORMAL);\n     response.setRMIdentifier(ResourceManager.getClusterTimeStamp());\n     response.setRMVersion(YarnVersionInfo.getVersion());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterNodeManagerResponse registerNodeManager(\n      RegisterNodeManagerRequest request) throws YarnException,\n      IOException {\n    NodeId nodeId \u003d request.getNodeId();\n    String host \u003d nodeId.getHost();\n    int cmPort \u003d nodeId.getPort();\n    int httpPort \u003d request.getHttpPort();\n    Resource capability \u003d request.getResource();\n    String nodeManagerVersion \u003d request.getNMVersion();\n\n    if (!request.getNMContainerStatuses().isEmpty()) {\n      LOG.info(\"received container statuses on node manager register :\"\n          + request.getNMContainerStatuses());\n      for (NMContainerStatus report : request.getNMContainerStatuses()) {\n        handleNMContainerStatus(report);\n      }\n    }\n    RegisterNodeManagerResponse response \u003d recordFactory\n        .newRecordInstance(RegisterNodeManagerResponse.class);\n\n    if (!minimumNodeManagerVersion.equals(\"NONE\")) {\n      if (minimumNodeManagerVersion.equals(\"EqualToRM\")) {\n        minimumNodeManagerVersion \u003d YarnVersionInfo.getVersion();\n      }\n\n      if ((nodeManagerVersion \u003d\u003d null) ||\n          (VersionUtil.compareVersions(nodeManagerVersion,minimumNodeManagerVersion)) \u003c 0) {\n        String message \u003d\n            \"Disallowed NodeManager Version \" + nodeManagerVersion\n                + \", is less than the minimum version \"\n                + minimumNodeManagerVersion + \" sending SHUTDOWN signal to \"\n                + \"NodeManager.\";\n        LOG.info(message);\n        response.setDiagnosticsMessage(message);\n        response.setNodeAction(NodeAction.SHUTDOWN);\n        return response;\n      }\n    }\n\n    // Check if this node is a \u0027valid\u0027 node\n    if (!this.nodesListManager.isValidNode(host)) {\n      String message \u003d\n          \"Disallowed NodeManager from  \" + host\n              + \", Sending SHUTDOWN signal to the NodeManager.\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    // Check if this node has minimum allocations\n    if (capability.getMemory() \u003c minAllocMb\n        || capability.getVirtualCores() \u003c minAllocVcores) {\n      String message \u003d\n          \"NodeManager from  \" + host\n              + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n              + \" signal to the NodeManager.\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    response.setContainerTokenMasterKey(containerTokenSecretManager\n        .getCurrentKey());\n    response.setNMTokenMasterKey(nmTokenSecretManager\n        .getCurrentKey());    \n\n    RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n        resolve(host), ResourceOption.newInstance(capability, RMNode.OVER_COMMIT_TIMEOUT_MILLIS_DEFAULT),\n        nodeManagerVersion);\n\n    RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n    if (oldNode \u003d\u003d null) {\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.STARTED));\n    } else {\n      LOG.info(\"Reconnect from the node at: \" + host);\n      this.nmLivelinessMonitor.unregister(nodeId);\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeReconnectEvent(nodeId, rmNode));\n    }\n    // On every node manager register we will be clearing NMToken keys if\n    // present for any running application.\n    this.nmTokenSecretManager.removeNodeKey(nodeId);\n    this.nmLivelinessMonitor.register(nodeId);\n\n    String message \u003d\n        \"NodeManager from node \" + host + \"(cmPort: \" + cmPort + \" httpPort: \"\n            + httpPort + \") \" + \"registered with capability: \" + capability\n            + \", assigned nodeId \" + nodeId;\n    LOG.info(message);\n    response.setNodeAction(NodeAction.NORMAL);\n    response.setRMIdentifier(ResourceManager.getClusterTimeStamp());\n    response.setRMVersion(YarnVersionInfo.getVersion());\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "f67218809c50b194e463af6e6196db298353c8c1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1849. Fixed NPE in ResourceTrackerService#registerNodeManager for UAM. Contributed by Karthik Kambatla\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1580077 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/03/14 3:53 PM",
      "commitName": "f67218809c50b194e463af6e6196db298353c8c1",
      "commitAuthor": "Jian He",
      "commitDateOld": "11/03/14 3:18 PM",
      "commitNameOld": "477ed62b3fe8db4b07d99479f56a2b997933cb01",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 10.02,
      "commitsBetweenForRepo": 81,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,120 +1,97 @@\n   public RegisterNodeManagerResponse registerNodeManager(\n       RegisterNodeManagerRequest request) throws YarnException,\n       IOException {\n-\n     NodeId nodeId \u003d request.getNodeId();\n     String host \u003d nodeId.getHost();\n     int cmPort \u003d nodeId.getPort();\n     int httpPort \u003d request.getHttpPort();\n     Resource capability \u003d request.getResource();\n     String nodeManagerVersion \u003d request.getNMVersion();\n \n     if (!request.getContainerStatuses().isEmpty()) {\n       LOG.info(\"received container statuses on node manager register :\"\n           + request.getContainerStatuses());\n       for (ContainerStatus containerStatus : request.getContainerStatuses()) {\n-        ApplicationAttemptId appAttemptId \u003d\n-            containerStatus.getContainerId().getApplicationAttemptId();\n-        RMApp rmApp \u003d\n-            rmContext.getRMApps().get(appAttemptId.getApplicationId());\n-        if (rmApp !\u003d null) {\n-          RMAppAttempt rmAppAttempt \u003d rmApp.getRMAppAttempt(appAttemptId);\n-          if (rmAppAttempt !\u003d null) {\n-            if (rmAppAttempt.getMasterContainer().getId()\n-                .equals(containerStatus.getContainerId())\n-                \u0026\u0026 containerStatus.getState() \u003d\u003d ContainerState.COMPLETE) {\n-              // sending master container finished event.\n-              RMAppAttemptContainerFinishedEvent evt \u003d\n-                  new RMAppAttemptContainerFinishedEvent(appAttemptId,\n-                      containerStatus);\n-              rmContext.getDispatcher().getEventHandler().handle(evt);\n-            }\n-          }\n-        } else {\n-          LOG.error(\"Received finished container :\"\n-              + containerStatus.getContainerId()\n-              + \" for non existing application :\"\n-              + appAttemptId.getApplicationId());\n-        }\n+        handleContainerStatus(containerStatus);\n       }\n     }\n     RegisterNodeManagerResponse response \u003d recordFactory\n         .newRecordInstance(RegisterNodeManagerResponse.class);\n \n     if (!minimumNodeManagerVersion.equals(\"NONE\")) {\n       if (minimumNodeManagerVersion.equals(\"EqualToRM\")) {\n         minimumNodeManagerVersion \u003d YarnVersionInfo.getVersion();\n       }\n \n       if ((nodeManagerVersion \u003d\u003d null) ||\n           (VersionUtil.compareVersions(nodeManagerVersion,minimumNodeManagerVersion)) \u003c 0) {\n         String message \u003d\n             \"Disallowed NodeManager Version \" + nodeManagerVersion\n                 + \", is less than the minimum version \"\n                 + minimumNodeManagerVersion + \" sending SHUTDOWN signal to \"\n                 + \"NodeManager.\";\n         LOG.info(message);\n         response.setDiagnosticsMessage(message);\n         response.setNodeAction(NodeAction.SHUTDOWN);\n         return response;\n       }\n     }\n \n     // Check if this node is a \u0027valid\u0027 node\n     if (!this.nodesListManager.isValidNode(host)) {\n       String message \u003d\n           \"Disallowed NodeManager from  \" + host\n               + \", Sending SHUTDOWN signal to the NodeManager.\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     // Check if this node has minimum allocations\n     if (capability.getMemory() \u003c minAllocMb\n         || capability.getVirtualCores() \u003c minAllocVcores) {\n       String message \u003d\n           \"NodeManager from  \" + host\n               + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n               + \" signal to the NodeManager.\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     response.setContainerTokenMasterKey(containerTokenSecretManager\n         .getCurrentKey());\n     response.setNMTokenMasterKey(nmTokenSecretManager\n         .getCurrentKey());    \n \n     RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n         resolve(host), ResourceOption.newInstance(capability, RMNode.OVER_COMMIT_TIMEOUT_MILLIS_DEFAULT),\n         nodeManagerVersion);\n \n     RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n     if (oldNode \u003d\u003d null) {\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.STARTED));\n     } else {\n       LOG.info(\"Reconnect from the node at: \" + host);\n       this.nmLivelinessMonitor.unregister(nodeId);\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeReconnectEvent(nodeId, rmNode));\n     }\n     // On every node manager register we will be clearing NMToken keys if\n     // present for any running application.\n     this.nmTokenSecretManager.removeNodeKey(nodeId);\n     this.nmLivelinessMonitor.register(nodeId);\n \n     String message \u003d\n         \"NodeManager from node \" + host + \"(cmPort: \" + cmPort + \" httpPort: \"\n             + httpPort + \") \" + \"registered with capability: \" + capability\n             + \", assigned nodeId \" + nodeId;\n     LOG.info(message);\n     response.setNodeAction(NodeAction.NORMAL);\n     response.setRMIdentifier(ResourceManager.getClusterTimeStamp());\n     response.setRMVersion(YarnVersionInfo.getVersion());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterNodeManagerResponse registerNodeManager(\n      RegisterNodeManagerRequest request) throws YarnException,\n      IOException {\n    NodeId nodeId \u003d request.getNodeId();\n    String host \u003d nodeId.getHost();\n    int cmPort \u003d nodeId.getPort();\n    int httpPort \u003d request.getHttpPort();\n    Resource capability \u003d request.getResource();\n    String nodeManagerVersion \u003d request.getNMVersion();\n\n    if (!request.getContainerStatuses().isEmpty()) {\n      LOG.info(\"received container statuses on node manager register :\"\n          + request.getContainerStatuses());\n      for (ContainerStatus containerStatus : request.getContainerStatuses()) {\n        handleContainerStatus(containerStatus);\n      }\n    }\n    RegisterNodeManagerResponse response \u003d recordFactory\n        .newRecordInstance(RegisterNodeManagerResponse.class);\n\n    if (!minimumNodeManagerVersion.equals(\"NONE\")) {\n      if (minimumNodeManagerVersion.equals(\"EqualToRM\")) {\n        minimumNodeManagerVersion \u003d YarnVersionInfo.getVersion();\n      }\n\n      if ((nodeManagerVersion \u003d\u003d null) ||\n          (VersionUtil.compareVersions(nodeManagerVersion,minimumNodeManagerVersion)) \u003c 0) {\n        String message \u003d\n            \"Disallowed NodeManager Version \" + nodeManagerVersion\n                + \", is less than the minimum version \"\n                + minimumNodeManagerVersion + \" sending SHUTDOWN signal to \"\n                + \"NodeManager.\";\n        LOG.info(message);\n        response.setDiagnosticsMessage(message);\n        response.setNodeAction(NodeAction.SHUTDOWN);\n        return response;\n      }\n    }\n\n    // Check if this node is a \u0027valid\u0027 node\n    if (!this.nodesListManager.isValidNode(host)) {\n      String message \u003d\n          \"Disallowed NodeManager from  \" + host\n              + \", Sending SHUTDOWN signal to the NodeManager.\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    // Check if this node has minimum allocations\n    if (capability.getMemory() \u003c minAllocMb\n        || capability.getVirtualCores() \u003c minAllocVcores) {\n      String message \u003d\n          \"NodeManager from  \" + host\n              + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n              + \" signal to the NodeManager.\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    response.setContainerTokenMasterKey(containerTokenSecretManager\n        .getCurrentKey());\n    response.setNMTokenMasterKey(nmTokenSecretManager\n        .getCurrentKey());    \n\n    RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n        resolve(host), ResourceOption.newInstance(capability, RMNode.OVER_COMMIT_TIMEOUT_MILLIS_DEFAULT),\n        nodeManagerVersion);\n\n    RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n    if (oldNode \u003d\u003d null) {\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.STARTED));\n    } else {\n      LOG.info(\"Reconnect from the node at: \" + host);\n      this.nmLivelinessMonitor.unregister(nodeId);\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeReconnectEvent(nodeId, rmNode));\n    }\n    // On every node manager register we will be clearing NMToken keys if\n    // present for any running application.\n    this.nmTokenSecretManager.removeNodeKey(nodeId);\n    this.nmLivelinessMonitor.register(nodeId);\n\n    String message \u003d\n        \"NodeManager from node \" + host + \"(cmPort: \" + cmPort + \" httpPort: \"\n            + httpPort + \") \" + \"registered with capability: \" + capability\n            + \", assigned nodeId \" + nodeId;\n    LOG.info(message);\n    response.setNodeAction(NodeAction.NORMAL);\n    response.setRMIdentifier(ResourceManager.getClusterTimeStamp());\n    response.setRMVersion(YarnVersionInfo.getVersion());\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "477ed62b3fe8db4b07d99479f56a2b997933cb01": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1821. NPE on registerNodeManager if the request has containers for UnmanagedAMs (kasha)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1576525 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/03/14 3:18 PM",
      "commitName": "477ed62b3fe8db4b07d99479f56a2b997933cb01",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "03/03/14 11:41 AM",
      "commitNameOld": "a60434368cdf0fd119d024c2ed10942abdb2e7f1",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 8.11,
      "commitsBetweenForRepo": 82,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,118 +1,120 @@\n   public RegisterNodeManagerResponse registerNodeManager(\n       RegisterNodeManagerRequest request) throws YarnException,\n       IOException {\n \n     NodeId nodeId \u003d request.getNodeId();\n     String host \u003d nodeId.getHost();\n     int cmPort \u003d nodeId.getPort();\n     int httpPort \u003d request.getHttpPort();\n     Resource capability \u003d request.getResource();\n     String nodeManagerVersion \u003d request.getNMVersion();\n \n     if (!request.getContainerStatuses().isEmpty()) {\n       LOG.info(\"received container statuses on node manager register :\"\n           + request.getContainerStatuses());\n       for (ContainerStatus containerStatus : request.getContainerStatuses()) {\n         ApplicationAttemptId appAttemptId \u003d\n             containerStatus.getContainerId().getApplicationAttemptId();\n         RMApp rmApp \u003d\n             rmContext.getRMApps().get(appAttemptId.getApplicationId());\n         if (rmApp !\u003d null) {\n           RMAppAttempt rmAppAttempt \u003d rmApp.getRMAppAttempt(appAttemptId);\n-          if (rmAppAttempt.getMasterContainer().getId()\n-              .equals(containerStatus.getContainerId())\n-              \u0026\u0026 containerStatus.getState() \u003d\u003d ContainerState.COMPLETE) {\n-            // sending master container finished event.\n-            RMAppAttemptContainerFinishedEvent evt \u003d\n-                new RMAppAttemptContainerFinishedEvent(appAttemptId,\n-                    containerStatus);\n-            rmContext.getDispatcher().getEventHandler().handle(evt);\n+          if (rmAppAttempt !\u003d null) {\n+            if (rmAppAttempt.getMasterContainer().getId()\n+                .equals(containerStatus.getContainerId())\n+                \u0026\u0026 containerStatus.getState() \u003d\u003d ContainerState.COMPLETE) {\n+              // sending master container finished event.\n+              RMAppAttemptContainerFinishedEvent evt \u003d\n+                  new RMAppAttemptContainerFinishedEvent(appAttemptId,\n+                      containerStatus);\n+              rmContext.getDispatcher().getEventHandler().handle(evt);\n+            }\n           }\n         } else {\n           LOG.error(\"Received finished container :\"\n               + containerStatus.getContainerId()\n               + \" for non existing application :\"\n               + appAttemptId.getApplicationId());\n         }\n       }\n     }\n     RegisterNodeManagerResponse response \u003d recordFactory\n         .newRecordInstance(RegisterNodeManagerResponse.class);\n \n     if (!minimumNodeManagerVersion.equals(\"NONE\")) {\n       if (minimumNodeManagerVersion.equals(\"EqualToRM\")) {\n         minimumNodeManagerVersion \u003d YarnVersionInfo.getVersion();\n       }\n \n       if ((nodeManagerVersion \u003d\u003d null) ||\n           (VersionUtil.compareVersions(nodeManagerVersion,minimumNodeManagerVersion)) \u003c 0) {\n         String message \u003d\n             \"Disallowed NodeManager Version \" + nodeManagerVersion\n                 + \", is less than the minimum version \"\n                 + minimumNodeManagerVersion + \" sending SHUTDOWN signal to \"\n                 + \"NodeManager.\";\n         LOG.info(message);\n         response.setDiagnosticsMessage(message);\n         response.setNodeAction(NodeAction.SHUTDOWN);\n         return response;\n       }\n     }\n \n     // Check if this node is a \u0027valid\u0027 node\n     if (!this.nodesListManager.isValidNode(host)) {\n       String message \u003d\n           \"Disallowed NodeManager from  \" + host\n               + \", Sending SHUTDOWN signal to the NodeManager.\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     // Check if this node has minimum allocations\n     if (capability.getMemory() \u003c minAllocMb\n         || capability.getVirtualCores() \u003c minAllocVcores) {\n       String message \u003d\n           \"NodeManager from  \" + host\n               + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n               + \" signal to the NodeManager.\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     response.setContainerTokenMasterKey(containerTokenSecretManager\n         .getCurrentKey());\n     response.setNMTokenMasterKey(nmTokenSecretManager\n         .getCurrentKey());    \n \n     RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n         resolve(host), ResourceOption.newInstance(capability, RMNode.OVER_COMMIT_TIMEOUT_MILLIS_DEFAULT),\n         nodeManagerVersion);\n \n     RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n     if (oldNode \u003d\u003d null) {\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.STARTED));\n     } else {\n       LOG.info(\"Reconnect from the node at: \" + host);\n       this.nmLivelinessMonitor.unregister(nodeId);\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeReconnectEvent(nodeId, rmNode));\n     }\n     // On every node manager register we will be clearing NMToken keys if\n     // present for any running application.\n     this.nmTokenSecretManager.removeNodeKey(nodeId);\n     this.nmLivelinessMonitor.register(nodeId);\n \n     String message \u003d\n         \"NodeManager from node \" + host + \"(cmPort: \" + cmPort + \" httpPort: \"\n             + httpPort + \") \" + \"registered with capability: \" + capability\n             + \", assigned nodeId \" + nodeId;\n     LOG.info(message);\n     response.setNodeAction(NodeAction.NORMAL);\n     response.setRMIdentifier(ResourceManager.getClusterTimeStamp());\n     response.setRMVersion(YarnVersionInfo.getVersion());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterNodeManagerResponse registerNodeManager(\n      RegisterNodeManagerRequest request) throws YarnException,\n      IOException {\n\n    NodeId nodeId \u003d request.getNodeId();\n    String host \u003d nodeId.getHost();\n    int cmPort \u003d nodeId.getPort();\n    int httpPort \u003d request.getHttpPort();\n    Resource capability \u003d request.getResource();\n    String nodeManagerVersion \u003d request.getNMVersion();\n\n    if (!request.getContainerStatuses().isEmpty()) {\n      LOG.info(\"received container statuses on node manager register :\"\n          + request.getContainerStatuses());\n      for (ContainerStatus containerStatus : request.getContainerStatuses()) {\n        ApplicationAttemptId appAttemptId \u003d\n            containerStatus.getContainerId().getApplicationAttemptId();\n        RMApp rmApp \u003d\n            rmContext.getRMApps().get(appAttemptId.getApplicationId());\n        if (rmApp !\u003d null) {\n          RMAppAttempt rmAppAttempt \u003d rmApp.getRMAppAttempt(appAttemptId);\n          if (rmAppAttempt !\u003d null) {\n            if (rmAppAttempt.getMasterContainer().getId()\n                .equals(containerStatus.getContainerId())\n                \u0026\u0026 containerStatus.getState() \u003d\u003d ContainerState.COMPLETE) {\n              // sending master container finished event.\n              RMAppAttemptContainerFinishedEvent evt \u003d\n                  new RMAppAttemptContainerFinishedEvent(appAttemptId,\n                      containerStatus);\n              rmContext.getDispatcher().getEventHandler().handle(evt);\n            }\n          }\n        } else {\n          LOG.error(\"Received finished container :\"\n              + containerStatus.getContainerId()\n              + \" for non existing application :\"\n              + appAttemptId.getApplicationId());\n        }\n      }\n    }\n    RegisterNodeManagerResponse response \u003d recordFactory\n        .newRecordInstance(RegisterNodeManagerResponse.class);\n\n    if (!minimumNodeManagerVersion.equals(\"NONE\")) {\n      if (minimumNodeManagerVersion.equals(\"EqualToRM\")) {\n        minimumNodeManagerVersion \u003d YarnVersionInfo.getVersion();\n      }\n\n      if ((nodeManagerVersion \u003d\u003d null) ||\n          (VersionUtil.compareVersions(nodeManagerVersion,minimumNodeManagerVersion)) \u003c 0) {\n        String message \u003d\n            \"Disallowed NodeManager Version \" + nodeManagerVersion\n                + \", is less than the minimum version \"\n                + minimumNodeManagerVersion + \" sending SHUTDOWN signal to \"\n                + \"NodeManager.\";\n        LOG.info(message);\n        response.setDiagnosticsMessage(message);\n        response.setNodeAction(NodeAction.SHUTDOWN);\n        return response;\n      }\n    }\n\n    // Check if this node is a \u0027valid\u0027 node\n    if (!this.nodesListManager.isValidNode(host)) {\n      String message \u003d\n          \"Disallowed NodeManager from  \" + host\n              + \", Sending SHUTDOWN signal to the NodeManager.\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    // Check if this node has minimum allocations\n    if (capability.getMemory() \u003c minAllocMb\n        || capability.getVirtualCores() \u003c minAllocVcores) {\n      String message \u003d\n          \"NodeManager from  \" + host\n              + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n              + \" signal to the NodeManager.\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    response.setContainerTokenMasterKey(containerTokenSecretManager\n        .getCurrentKey());\n    response.setNMTokenMasterKey(nmTokenSecretManager\n        .getCurrentKey());    \n\n    RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n        resolve(host), ResourceOption.newInstance(capability, RMNode.OVER_COMMIT_TIMEOUT_MILLIS_DEFAULT),\n        nodeManagerVersion);\n\n    RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n    if (oldNode \u003d\u003d null) {\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.STARTED));\n    } else {\n      LOG.info(\"Reconnect from the node at: \" + host);\n      this.nmLivelinessMonitor.unregister(nodeId);\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeReconnectEvent(nodeId, rmNode));\n    }\n    // On every node manager register we will be clearing NMToken keys if\n    // present for any running application.\n    this.nmTokenSecretManager.removeNodeKey(nodeId);\n    this.nmLivelinessMonitor.register(nodeId);\n\n    String message \u003d\n        \"NodeManager from node \" + host + \"(cmPort: \" + cmPort + \" httpPort: \"\n            + httpPort + \") \" + \"registered with capability: \" + capability\n            + \", assigned nodeId \" + nodeId;\n    LOG.info(message);\n    response.setNodeAction(NodeAction.NORMAL);\n    response.setRMIdentifier(ResourceManager.getClusterTimeStamp());\n    response.setRMVersion(YarnVersionInfo.getVersion());\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "cfa783141fa69c2cf154d1d9e5393353d14ce5e1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1210. Changed RM to start new app-attempts on RM restart only after ensuring that previous AM exited or after expiry time. Contributed by Omkar Vinit Joshi.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1543310 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/11/13 9:17 PM",
      "commitName": "cfa783141fa69c2cf154d1d9e5393353d14ce5e1",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "05/11/13 1:23 PM",
      "commitNameOld": "6990355e577ad19371cb656c250fb665ed14062f",
      "commitAuthorOld": "Luke Lu",
      "daysBetweenCommits": 13.33,
      "commitsBetweenForRepo": 79,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,91 +1,118 @@\n   public RegisterNodeManagerResponse registerNodeManager(\n       RegisterNodeManagerRequest request) throws YarnException,\n       IOException {\n \n     NodeId nodeId \u003d request.getNodeId();\n     String host \u003d nodeId.getHost();\n     int cmPort \u003d nodeId.getPort();\n     int httpPort \u003d request.getHttpPort();\n     Resource capability \u003d request.getResource();\n     String nodeManagerVersion \u003d request.getNMVersion();\n \n+    if (!request.getContainerStatuses().isEmpty()) {\n+      LOG.info(\"received container statuses on node manager register :\"\n+          + request.getContainerStatuses());\n+      for (ContainerStatus containerStatus : request.getContainerStatuses()) {\n+        ApplicationAttemptId appAttemptId \u003d\n+            containerStatus.getContainerId().getApplicationAttemptId();\n+        RMApp rmApp \u003d\n+            rmContext.getRMApps().get(appAttemptId.getApplicationId());\n+        if (rmApp !\u003d null) {\n+          RMAppAttempt rmAppAttempt \u003d rmApp.getRMAppAttempt(appAttemptId);\n+          if (rmAppAttempt.getMasterContainer().getId()\n+              .equals(containerStatus.getContainerId())\n+              \u0026\u0026 containerStatus.getState() \u003d\u003d ContainerState.COMPLETE) {\n+            // sending master container finished event.\n+            RMAppAttemptContainerFinishedEvent evt \u003d\n+                new RMAppAttemptContainerFinishedEvent(appAttemptId,\n+                    containerStatus);\n+            rmContext.getDispatcher().getEventHandler().handle(evt);\n+          }\n+        } else {\n+          LOG.error(\"Received finished container :\"\n+              + containerStatus.getContainerId()\n+              + \" for non existing application :\"\n+              + appAttemptId.getApplicationId());\n+        }\n+      }\n+    }\n     RegisterNodeManagerResponse response \u003d recordFactory\n         .newRecordInstance(RegisterNodeManagerResponse.class);\n \n     if (!minimumNodeManagerVersion.equals(\"NONE\")) {\n       if (minimumNodeManagerVersion.equals(\"EqualToRM\")) {\n         minimumNodeManagerVersion \u003d YarnVersionInfo.getVersion();\n       }\n \n       if ((nodeManagerVersion \u003d\u003d null) ||\n           (VersionUtil.compareVersions(nodeManagerVersion,minimumNodeManagerVersion)) \u003c 0) {\n         String message \u003d\n             \"Disallowed NodeManager Version \" + nodeManagerVersion\n                 + \", is less than the minimum version \"\n                 + minimumNodeManagerVersion + \" sending SHUTDOWN signal to \"\n                 + \"NodeManager.\";\n         LOG.info(message);\n         response.setDiagnosticsMessage(message);\n         response.setNodeAction(NodeAction.SHUTDOWN);\n         return response;\n       }\n     }\n \n     // Check if this node is a \u0027valid\u0027 node\n     if (!this.nodesListManager.isValidNode(host)) {\n       String message \u003d\n           \"Disallowed NodeManager from  \" + host\n               + \", Sending SHUTDOWN signal to the NodeManager.\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     // Check if this node has minimum allocations\n     if (capability.getMemory() \u003c minAllocMb\n         || capability.getVirtualCores() \u003c minAllocVcores) {\n       String message \u003d\n           \"NodeManager from  \" + host\n               + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n               + \" signal to the NodeManager.\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     response.setContainerTokenMasterKey(containerTokenSecretManager\n         .getCurrentKey());\n     response.setNMTokenMasterKey(nmTokenSecretManager\n         .getCurrentKey());    \n \n     RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n         resolve(host), ResourceOption.newInstance(capability, RMNode.OVER_COMMIT_TIMEOUT_MILLIS_DEFAULT),\n         nodeManagerVersion);\n \n     RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n     if (oldNode \u003d\u003d null) {\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.STARTED));\n     } else {\n       LOG.info(\"Reconnect from the node at: \" + host);\n       this.nmLivelinessMonitor.unregister(nodeId);\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeReconnectEvent(nodeId, rmNode));\n     }\n     // On every node manager register we will be clearing NMToken keys if\n     // present for any running application.\n     this.nmTokenSecretManager.removeNodeKey(nodeId);\n     this.nmLivelinessMonitor.register(nodeId);\n \n     String message \u003d\n         \"NodeManager from node \" + host + \"(cmPort: \" + cmPort + \" httpPort: \"\n             + httpPort + \") \" + \"registered with capability: \" + capability\n             + \", assigned nodeId \" + nodeId;\n     LOG.info(message);\n     response.setNodeAction(NodeAction.NORMAL);\n     response.setRMIdentifier(ResourceManager.getClusterTimeStamp());\n     response.setRMVersion(YarnVersionInfo.getVersion());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterNodeManagerResponse registerNodeManager(\n      RegisterNodeManagerRequest request) throws YarnException,\n      IOException {\n\n    NodeId nodeId \u003d request.getNodeId();\n    String host \u003d nodeId.getHost();\n    int cmPort \u003d nodeId.getPort();\n    int httpPort \u003d request.getHttpPort();\n    Resource capability \u003d request.getResource();\n    String nodeManagerVersion \u003d request.getNMVersion();\n\n    if (!request.getContainerStatuses().isEmpty()) {\n      LOG.info(\"received container statuses on node manager register :\"\n          + request.getContainerStatuses());\n      for (ContainerStatus containerStatus : request.getContainerStatuses()) {\n        ApplicationAttemptId appAttemptId \u003d\n            containerStatus.getContainerId().getApplicationAttemptId();\n        RMApp rmApp \u003d\n            rmContext.getRMApps().get(appAttemptId.getApplicationId());\n        if (rmApp !\u003d null) {\n          RMAppAttempt rmAppAttempt \u003d rmApp.getRMAppAttempt(appAttemptId);\n          if (rmAppAttempt.getMasterContainer().getId()\n              .equals(containerStatus.getContainerId())\n              \u0026\u0026 containerStatus.getState() \u003d\u003d ContainerState.COMPLETE) {\n            // sending master container finished event.\n            RMAppAttemptContainerFinishedEvent evt \u003d\n                new RMAppAttemptContainerFinishedEvent(appAttemptId,\n                    containerStatus);\n            rmContext.getDispatcher().getEventHandler().handle(evt);\n          }\n        } else {\n          LOG.error(\"Received finished container :\"\n              + containerStatus.getContainerId()\n              + \" for non existing application :\"\n              + appAttemptId.getApplicationId());\n        }\n      }\n    }\n    RegisterNodeManagerResponse response \u003d recordFactory\n        .newRecordInstance(RegisterNodeManagerResponse.class);\n\n    if (!minimumNodeManagerVersion.equals(\"NONE\")) {\n      if (minimumNodeManagerVersion.equals(\"EqualToRM\")) {\n        minimumNodeManagerVersion \u003d YarnVersionInfo.getVersion();\n      }\n\n      if ((nodeManagerVersion \u003d\u003d null) ||\n          (VersionUtil.compareVersions(nodeManagerVersion,minimumNodeManagerVersion)) \u003c 0) {\n        String message \u003d\n            \"Disallowed NodeManager Version \" + nodeManagerVersion\n                + \", is less than the minimum version \"\n                + minimumNodeManagerVersion + \" sending SHUTDOWN signal to \"\n                + \"NodeManager.\";\n        LOG.info(message);\n        response.setDiagnosticsMessage(message);\n        response.setNodeAction(NodeAction.SHUTDOWN);\n        return response;\n      }\n    }\n\n    // Check if this node is a \u0027valid\u0027 node\n    if (!this.nodesListManager.isValidNode(host)) {\n      String message \u003d\n          \"Disallowed NodeManager from  \" + host\n              + \", Sending SHUTDOWN signal to the NodeManager.\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    // Check if this node has minimum allocations\n    if (capability.getMemory() \u003c minAllocMb\n        || capability.getVirtualCores() \u003c minAllocVcores) {\n      String message \u003d\n          \"NodeManager from  \" + host\n              + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n              + \" signal to the NodeManager.\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    response.setContainerTokenMasterKey(containerTokenSecretManager\n        .getCurrentKey());\n    response.setNMTokenMasterKey(nmTokenSecretManager\n        .getCurrentKey());    \n\n    RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n        resolve(host), ResourceOption.newInstance(capability, RMNode.OVER_COMMIT_TIMEOUT_MILLIS_DEFAULT),\n        nodeManagerVersion);\n\n    RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n    if (oldNode \u003d\u003d null) {\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.STARTED));\n    } else {\n      LOG.info(\"Reconnect from the node at: \" + host);\n      this.nmLivelinessMonitor.unregister(nodeId);\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeReconnectEvent(nodeId, rmNode));\n    }\n    // On every node manager register we will be clearing NMToken keys if\n    // present for any running application.\n    this.nmTokenSecretManager.removeNodeKey(nodeId);\n    this.nmLivelinessMonitor.register(nodeId);\n\n    String message \u003d\n        \"NodeManager from node \" + host + \"(cmPort: \" + cmPort + \" httpPort: \"\n            + httpPort + \") \" + \"registered with capability: \" + capability\n            + \", assigned nodeId \" + nodeId;\n    LOG.info(message);\n    response.setNodeAction(NodeAction.NORMAL);\n    response.setRMIdentifier(ResourceManager.getClusterTimeStamp());\n    response.setRMVersion(YarnVersionInfo.getVersion());\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "6990355e577ad19371cb656c250fb665ed14062f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-311. RM/scheduler support for dynamic resource configuration. (Junping Du via llu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1539134 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "05/11/13 1:23 PM",
      "commitName": "6990355e577ad19371cb656c250fb665ed14062f",
      "commitAuthor": "Luke Lu",
      "commitDateOld": "03/10/13 2:04 PM",
      "commitNameOld": "7b687dda098c94b55c9848827cfc2d6326b6f9b6",
      "commitAuthorOld": "Jonathan Turner Eagles",
      "daysBetweenCommits": 33.01,
      "commitsBetweenForRepo": 212,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,90 +1,91 @@\n   public RegisterNodeManagerResponse registerNodeManager(\n       RegisterNodeManagerRequest request) throws YarnException,\n       IOException {\n \n     NodeId nodeId \u003d request.getNodeId();\n     String host \u003d nodeId.getHost();\n     int cmPort \u003d nodeId.getPort();\n     int httpPort \u003d request.getHttpPort();\n     Resource capability \u003d request.getResource();\n     String nodeManagerVersion \u003d request.getNMVersion();\n \n     RegisterNodeManagerResponse response \u003d recordFactory\n         .newRecordInstance(RegisterNodeManagerResponse.class);\n \n     if (!minimumNodeManagerVersion.equals(\"NONE\")) {\n       if (minimumNodeManagerVersion.equals(\"EqualToRM\")) {\n         minimumNodeManagerVersion \u003d YarnVersionInfo.getVersion();\n       }\n \n       if ((nodeManagerVersion \u003d\u003d null) ||\n           (VersionUtil.compareVersions(nodeManagerVersion,minimumNodeManagerVersion)) \u003c 0) {\n         String message \u003d\n             \"Disallowed NodeManager Version \" + nodeManagerVersion\n                 + \", is less than the minimum version \"\n                 + minimumNodeManagerVersion + \" sending SHUTDOWN signal to \"\n                 + \"NodeManager.\";\n         LOG.info(message);\n         response.setDiagnosticsMessage(message);\n         response.setNodeAction(NodeAction.SHUTDOWN);\n         return response;\n       }\n     }\n \n     // Check if this node is a \u0027valid\u0027 node\n     if (!this.nodesListManager.isValidNode(host)) {\n       String message \u003d\n           \"Disallowed NodeManager from  \" + host\n               + \", Sending SHUTDOWN signal to the NodeManager.\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     // Check if this node has minimum allocations\n     if (capability.getMemory() \u003c minAllocMb\n         || capability.getVirtualCores() \u003c minAllocVcores) {\n       String message \u003d\n           \"NodeManager from  \" + host\n               + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n               + \" signal to the NodeManager.\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     response.setContainerTokenMasterKey(containerTokenSecretManager\n         .getCurrentKey());\n     response.setNMTokenMasterKey(nmTokenSecretManager\n         .getCurrentKey());    \n \n     RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n-        resolve(host), capability, nodeManagerVersion);\n+        resolve(host), ResourceOption.newInstance(capability, RMNode.OVER_COMMIT_TIMEOUT_MILLIS_DEFAULT),\n+        nodeManagerVersion);\n \n     RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n     if (oldNode \u003d\u003d null) {\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.STARTED));\n     } else {\n       LOG.info(\"Reconnect from the node at: \" + host);\n       this.nmLivelinessMonitor.unregister(nodeId);\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeReconnectEvent(nodeId, rmNode));\n     }\n     // On every node manager register we will be clearing NMToken keys if\n     // present for any running application.\n     this.nmTokenSecretManager.removeNodeKey(nodeId);\n     this.nmLivelinessMonitor.register(nodeId);\n \n     String message \u003d\n         \"NodeManager from node \" + host + \"(cmPort: \" + cmPort + \" httpPort: \"\n             + httpPort + \") \" + \"registered with capability: \" + capability\n             + \", assigned nodeId \" + nodeId;\n     LOG.info(message);\n     response.setNodeAction(NodeAction.NORMAL);\n     response.setRMIdentifier(ResourceManager.getClusterTimeStamp());\n     response.setRMVersion(YarnVersionInfo.getVersion());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterNodeManagerResponse registerNodeManager(\n      RegisterNodeManagerRequest request) throws YarnException,\n      IOException {\n\n    NodeId nodeId \u003d request.getNodeId();\n    String host \u003d nodeId.getHost();\n    int cmPort \u003d nodeId.getPort();\n    int httpPort \u003d request.getHttpPort();\n    Resource capability \u003d request.getResource();\n    String nodeManagerVersion \u003d request.getNMVersion();\n\n    RegisterNodeManagerResponse response \u003d recordFactory\n        .newRecordInstance(RegisterNodeManagerResponse.class);\n\n    if (!minimumNodeManagerVersion.equals(\"NONE\")) {\n      if (minimumNodeManagerVersion.equals(\"EqualToRM\")) {\n        minimumNodeManagerVersion \u003d YarnVersionInfo.getVersion();\n      }\n\n      if ((nodeManagerVersion \u003d\u003d null) ||\n          (VersionUtil.compareVersions(nodeManagerVersion,minimumNodeManagerVersion)) \u003c 0) {\n        String message \u003d\n            \"Disallowed NodeManager Version \" + nodeManagerVersion\n                + \", is less than the minimum version \"\n                + minimumNodeManagerVersion + \" sending SHUTDOWN signal to \"\n                + \"NodeManager.\";\n        LOG.info(message);\n        response.setDiagnosticsMessage(message);\n        response.setNodeAction(NodeAction.SHUTDOWN);\n        return response;\n      }\n    }\n\n    // Check if this node is a \u0027valid\u0027 node\n    if (!this.nodesListManager.isValidNode(host)) {\n      String message \u003d\n          \"Disallowed NodeManager from  \" + host\n              + \", Sending SHUTDOWN signal to the NodeManager.\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    // Check if this node has minimum allocations\n    if (capability.getMemory() \u003c minAllocMb\n        || capability.getVirtualCores() \u003c minAllocVcores) {\n      String message \u003d\n          \"NodeManager from  \" + host\n              + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n              + \" signal to the NodeManager.\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    response.setContainerTokenMasterKey(containerTokenSecretManager\n        .getCurrentKey());\n    response.setNMTokenMasterKey(nmTokenSecretManager\n        .getCurrentKey());    \n\n    RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n        resolve(host), ResourceOption.newInstance(capability, RMNode.OVER_COMMIT_TIMEOUT_MILLIS_DEFAULT),\n        nodeManagerVersion);\n\n    RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n    if (oldNode \u003d\u003d null) {\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.STARTED));\n    } else {\n      LOG.info(\"Reconnect from the node at: \" + host);\n      this.nmLivelinessMonitor.unregister(nodeId);\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeReconnectEvent(nodeId, rmNode));\n    }\n    // On every node manager register we will be clearing NMToken keys if\n    // present for any running application.\n    this.nmTokenSecretManager.removeNodeKey(nodeId);\n    this.nmLivelinessMonitor.register(nodeId);\n\n    String message \u003d\n        \"NodeManager from node \" + host + \"(cmPort: \" + cmPort + \" httpPort: \"\n            + httpPort + \") \" + \"registered with capability: \" + capability\n            + \", assigned nodeId \" + nodeId;\n    LOG.info(message);\n    response.setNodeAction(NodeAction.NORMAL);\n    response.setRMIdentifier(ResourceManager.getClusterTimeStamp());\n    response.setRMVersion(YarnVersionInfo.getVersion());\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "7b687dda098c94b55c9848827cfc2d6326b6f9b6": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1199. Make NM/RM Versions Available (Mit Desai via jeagles)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1529003 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/10/13 2:04 PM",
      "commitName": "7b687dda098c94b55c9848827cfc2d6326b6f9b6",
      "commitAuthor": "Jonathan Turner Eagles",
      "commitDateOld": "26/09/13 12:55 PM",
      "commitNameOld": "5a15c392a1a18c5720dbe630bc07e58268c8e6a7",
      "commitAuthorOld": "Jonathan Turner Eagles",
      "daysBetweenCommits": 7.05,
      "commitsBetweenForRepo": 55,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,90 +1,90 @@\n   public RegisterNodeManagerResponse registerNodeManager(\n       RegisterNodeManagerRequest request) throws YarnException,\n       IOException {\n \n     NodeId nodeId \u003d request.getNodeId();\n     String host \u003d nodeId.getHost();\n     int cmPort \u003d nodeId.getPort();\n     int httpPort \u003d request.getHttpPort();\n     Resource capability \u003d request.getResource();\n     String nodeManagerVersion \u003d request.getNMVersion();\n \n     RegisterNodeManagerResponse response \u003d recordFactory\n         .newRecordInstance(RegisterNodeManagerResponse.class);\n \n     if (!minimumNodeManagerVersion.equals(\"NONE\")) {\n       if (minimumNodeManagerVersion.equals(\"EqualToRM\")) {\n         minimumNodeManagerVersion \u003d YarnVersionInfo.getVersion();\n       }\n \n       if ((nodeManagerVersion \u003d\u003d null) ||\n           (VersionUtil.compareVersions(nodeManagerVersion,minimumNodeManagerVersion)) \u003c 0) {\n         String message \u003d\n             \"Disallowed NodeManager Version \" + nodeManagerVersion\n                 + \", is less than the minimum version \"\n                 + minimumNodeManagerVersion + \" sending SHUTDOWN signal to \"\n                 + \"NodeManager.\";\n         LOG.info(message);\n         response.setDiagnosticsMessage(message);\n         response.setNodeAction(NodeAction.SHUTDOWN);\n         return response;\n       }\n     }\n \n     // Check if this node is a \u0027valid\u0027 node\n     if (!this.nodesListManager.isValidNode(host)) {\n       String message \u003d\n           \"Disallowed NodeManager from  \" + host\n               + \", Sending SHUTDOWN signal to the NodeManager.\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     // Check if this node has minimum allocations\n     if (capability.getMemory() \u003c minAllocMb\n         || capability.getVirtualCores() \u003c minAllocVcores) {\n       String message \u003d\n           \"NodeManager from  \" + host\n               + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n               + \" signal to the NodeManager.\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     response.setContainerTokenMasterKey(containerTokenSecretManager\n         .getCurrentKey());\n     response.setNMTokenMasterKey(nmTokenSecretManager\n         .getCurrentKey());    \n \n     RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n-        resolve(host), capability);\n+        resolve(host), capability, nodeManagerVersion);\n \n     RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n     if (oldNode \u003d\u003d null) {\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.STARTED));\n     } else {\n       LOG.info(\"Reconnect from the node at: \" + host);\n       this.nmLivelinessMonitor.unregister(nodeId);\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeReconnectEvent(nodeId, rmNode));\n     }\n     // On every node manager register we will be clearing NMToken keys if\n     // present for any running application.\n     this.nmTokenSecretManager.removeNodeKey(nodeId);\n     this.nmLivelinessMonitor.register(nodeId);\n \n     String message \u003d\n         \"NodeManager from node \" + host + \"(cmPort: \" + cmPort + \" httpPort: \"\n             + httpPort + \") \" + \"registered with capability: \" + capability\n             + \", assigned nodeId \" + nodeId;\n     LOG.info(message);\n     response.setNodeAction(NodeAction.NORMAL);\n     response.setRMIdentifier(ResourceManager.getClusterTimeStamp());\n     response.setRMVersion(YarnVersionInfo.getVersion());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterNodeManagerResponse registerNodeManager(\n      RegisterNodeManagerRequest request) throws YarnException,\n      IOException {\n\n    NodeId nodeId \u003d request.getNodeId();\n    String host \u003d nodeId.getHost();\n    int cmPort \u003d nodeId.getPort();\n    int httpPort \u003d request.getHttpPort();\n    Resource capability \u003d request.getResource();\n    String nodeManagerVersion \u003d request.getNMVersion();\n\n    RegisterNodeManagerResponse response \u003d recordFactory\n        .newRecordInstance(RegisterNodeManagerResponse.class);\n\n    if (!minimumNodeManagerVersion.equals(\"NONE\")) {\n      if (minimumNodeManagerVersion.equals(\"EqualToRM\")) {\n        minimumNodeManagerVersion \u003d YarnVersionInfo.getVersion();\n      }\n\n      if ((nodeManagerVersion \u003d\u003d null) ||\n          (VersionUtil.compareVersions(nodeManagerVersion,minimumNodeManagerVersion)) \u003c 0) {\n        String message \u003d\n            \"Disallowed NodeManager Version \" + nodeManagerVersion\n                + \", is less than the minimum version \"\n                + minimumNodeManagerVersion + \" sending SHUTDOWN signal to \"\n                + \"NodeManager.\";\n        LOG.info(message);\n        response.setDiagnosticsMessage(message);\n        response.setNodeAction(NodeAction.SHUTDOWN);\n        return response;\n      }\n    }\n\n    // Check if this node is a \u0027valid\u0027 node\n    if (!this.nodesListManager.isValidNode(host)) {\n      String message \u003d\n          \"Disallowed NodeManager from  \" + host\n              + \", Sending SHUTDOWN signal to the NodeManager.\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    // Check if this node has minimum allocations\n    if (capability.getMemory() \u003c minAllocMb\n        || capability.getVirtualCores() \u003c minAllocVcores) {\n      String message \u003d\n          \"NodeManager from  \" + host\n              + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n              + \" signal to the NodeManager.\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    response.setContainerTokenMasterKey(containerTokenSecretManager\n        .getCurrentKey());\n    response.setNMTokenMasterKey(nmTokenSecretManager\n        .getCurrentKey());    \n\n    RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n        resolve(host), capability, nodeManagerVersion);\n\n    RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n    if (oldNode \u003d\u003d null) {\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.STARTED));\n    } else {\n      LOG.info(\"Reconnect from the node at: \" + host);\n      this.nmLivelinessMonitor.unregister(nodeId);\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeReconnectEvent(nodeId, rmNode));\n    }\n    // On every node manager register we will be clearing NMToken keys if\n    // present for any running application.\n    this.nmTokenSecretManager.removeNodeKey(nodeId);\n    this.nmLivelinessMonitor.register(nodeId);\n\n    String message \u003d\n        \"NodeManager from node \" + host + \"(cmPort: \" + cmPort + \" httpPort: \"\n            + httpPort + \") \" + \"registered with capability: \" + capability\n            + \", assigned nodeId \" + nodeId;\n    LOG.info(message);\n    response.setNodeAction(NodeAction.NORMAL);\n    response.setRMIdentifier(ResourceManager.getClusterTimeStamp());\n    response.setRMVersion(YarnVersionInfo.getVersion());\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "5a15c392a1a18c5720dbe630bc07e58268c8e6a7": {
      "type": "Ybodychange",
      "commitMessage": "YARN-819. ResourceManager and NodeManager should check for a minimum allowed version (Robert Parker via jeagles)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1526660 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "26/09/13 12:55 PM",
      "commitName": "5a15c392a1a18c5720dbe630bc07e58268c8e6a7",
      "commitAuthor": "Jonathan Turner Eagles",
      "commitDateOld": "16/09/13 11:33 AM",
      "commitNameOld": "ead3dcc3dea0d5b6d3248c1e1a6300f0714a8456",
      "commitAuthorOld": "Bikas Saha",
      "daysBetweenCommits": 10.06,
      "commitsBetweenForRepo": 57,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,69 +1,90 @@\n   public RegisterNodeManagerResponse registerNodeManager(\n       RegisterNodeManagerRequest request) throws YarnException,\n       IOException {\n \n     NodeId nodeId \u003d request.getNodeId();\n     String host \u003d nodeId.getHost();\n     int cmPort \u003d nodeId.getPort();\n     int httpPort \u003d request.getHttpPort();\n     Resource capability \u003d request.getResource();\n+    String nodeManagerVersion \u003d request.getNMVersion();\n \n     RegisterNodeManagerResponse response \u003d recordFactory\n         .newRecordInstance(RegisterNodeManagerResponse.class);\n \n+    if (!minimumNodeManagerVersion.equals(\"NONE\")) {\n+      if (minimumNodeManagerVersion.equals(\"EqualToRM\")) {\n+        minimumNodeManagerVersion \u003d YarnVersionInfo.getVersion();\n+      }\n+\n+      if ((nodeManagerVersion \u003d\u003d null) ||\n+          (VersionUtil.compareVersions(nodeManagerVersion,minimumNodeManagerVersion)) \u003c 0) {\n+        String message \u003d\n+            \"Disallowed NodeManager Version \" + nodeManagerVersion\n+                + \", is less than the minimum version \"\n+                + minimumNodeManagerVersion + \" sending SHUTDOWN signal to \"\n+                + \"NodeManager.\";\n+        LOG.info(message);\n+        response.setDiagnosticsMessage(message);\n+        response.setNodeAction(NodeAction.SHUTDOWN);\n+        return response;\n+      }\n+    }\n+\n     // Check if this node is a \u0027valid\u0027 node\n     if (!this.nodesListManager.isValidNode(host)) {\n       String message \u003d\n           \"Disallowed NodeManager from  \" + host\n               + \", Sending SHUTDOWN signal to the NodeManager.\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     // Check if this node has minimum allocations\n     if (capability.getMemory() \u003c minAllocMb\n         || capability.getVirtualCores() \u003c minAllocVcores) {\n       String message \u003d\n           \"NodeManager from  \" + host\n               + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n               + \" signal to the NodeManager.\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     response.setContainerTokenMasterKey(containerTokenSecretManager\n         .getCurrentKey());\n     response.setNMTokenMasterKey(nmTokenSecretManager\n         .getCurrentKey());    \n \n     RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n         resolve(host), capability);\n \n     RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n     if (oldNode \u003d\u003d null) {\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.STARTED));\n     } else {\n       LOG.info(\"Reconnect from the node at: \" + host);\n       this.nmLivelinessMonitor.unregister(nodeId);\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeReconnectEvent(nodeId, rmNode));\n     }\n     // On every node manager register we will be clearing NMToken keys if\n     // present for any running application.\n     this.nmTokenSecretManager.removeNodeKey(nodeId);\n     this.nmLivelinessMonitor.register(nodeId);\n \n     String message \u003d\n         \"NodeManager from node \" + host + \"(cmPort: \" + cmPort + \" httpPort: \"\n             + httpPort + \") \" + \"registered with capability: \" + capability\n             + \", assigned nodeId \" + nodeId;\n     LOG.info(message);\n     response.setNodeAction(NodeAction.NORMAL);\n     response.setRMIdentifier(ResourceManager.getClusterTimeStamp());\n+    response.setRMVersion(YarnVersionInfo.getVersion());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterNodeManagerResponse registerNodeManager(\n      RegisterNodeManagerRequest request) throws YarnException,\n      IOException {\n\n    NodeId nodeId \u003d request.getNodeId();\n    String host \u003d nodeId.getHost();\n    int cmPort \u003d nodeId.getPort();\n    int httpPort \u003d request.getHttpPort();\n    Resource capability \u003d request.getResource();\n    String nodeManagerVersion \u003d request.getNMVersion();\n\n    RegisterNodeManagerResponse response \u003d recordFactory\n        .newRecordInstance(RegisterNodeManagerResponse.class);\n\n    if (!minimumNodeManagerVersion.equals(\"NONE\")) {\n      if (minimumNodeManagerVersion.equals(\"EqualToRM\")) {\n        minimumNodeManagerVersion \u003d YarnVersionInfo.getVersion();\n      }\n\n      if ((nodeManagerVersion \u003d\u003d null) ||\n          (VersionUtil.compareVersions(nodeManagerVersion,minimumNodeManagerVersion)) \u003c 0) {\n        String message \u003d\n            \"Disallowed NodeManager Version \" + nodeManagerVersion\n                + \", is less than the minimum version \"\n                + minimumNodeManagerVersion + \" sending SHUTDOWN signal to \"\n                + \"NodeManager.\";\n        LOG.info(message);\n        response.setDiagnosticsMessage(message);\n        response.setNodeAction(NodeAction.SHUTDOWN);\n        return response;\n      }\n    }\n\n    // Check if this node is a \u0027valid\u0027 node\n    if (!this.nodesListManager.isValidNode(host)) {\n      String message \u003d\n          \"Disallowed NodeManager from  \" + host\n              + \", Sending SHUTDOWN signal to the NodeManager.\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    // Check if this node has minimum allocations\n    if (capability.getMemory() \u003c minAllocMb\n        || capability.getVirtualCores() \u003c minAllocVcores) {\n      String message \u003d\n          \"NodeManager from  \" + host\n              + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n              + \" signal to the NodeManager.\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    response.setContainerTokenMasterKey(containerTokenSecretManager\n        .getCurrentKey());\n    response.setNMTokenMasterKey(nmTokenSecretManager\n        .getCurrentKey());    \n\n    RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n        resolve(host), capability);\n\n    RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n    if (oldNode \u003d\u003d null) {\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.STARTED));\n    } else {\n      LOG.info(\"Reconnect from the node at: \" + host);\n      this.nmLivelinessMonitor.unregister(nodeId);\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeReconnectEvent(nodeId, rmNode));\n    }\n    // On every node manager register we will be clearing NMToken keys if\n    // present for any running application.\n    this.nmTokenSecretManager.removeNodeKey(nodeId);\n    this.nmLivelinessMonitor.register(nodeId);\n\n    String message \u003d\n        \"NodeManager from node \" + host + \"(cmPort: \" + cmPort + \" httpPort: \"\n            + httpPort + \") \" + \"registered with capability: \" + capability\n            + \", assigned nodeId \" + nodeId;\n    LOG.info(message);\n    response.setNodeAction(NodeAction.NORMAL);\n    response.setRMIdentifier(ResourceManager.getClusterTimeStamp());\n    response.setRMVersion(YarnVersionInfo.getVersion());\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "ead3dcc3dea0d5b6d3248c1e1a6300f0714a8456": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1027. Implement RMHAProtocolService (Karthik Kambatla via bikas)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1523750 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/09/13 11:33 AM",
      "commitName": "ead3dcc3dea0d5b6d3248c1e1a6300f0714a8456",
      "commitAuthor": "Bikas Saha",
      "commitDateOld": "24/07/13 9:14 PM",
      "commitNameOld": "db1e0c1eefc1f6ad8fd317088d548c7814ea7aff",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 53.6,
      "commitsBetweenForRepo": 301,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,69 +1,69 @@\n   public RegisterNodeManagerResponse registerNodeManager(\n       RegisterNodeManagerRequest request) throws YarnException,\n       IOException {\n \n     NodeId nodeId \u003d request.getNodeId();\n     String host \u003d nodeId.getHost();\n     int cmPort \u003d nodeId.getPort();\n     int httpPort \u003d request.getHttpPort();\n     Resource capability \u003d request.getResource();\n \n     RegisterNodeManagerResponse response \u003d recordFactory\n         .newRecordInstance(RegisterNodeManagerResponse.class);\n \n     // Check if this node is a \u0027valid\u0027 node\n     if (!this.nodesListManager.isValidNode(host)) {\n       String message \u003d\n           \"Disallowed NodeManager from  \" + host\n               + \", Sending SHUTDOWN signal to the NodeManager.\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     // Check if this node has minimum allocations\n     if (capability.getMemory() \u003c minAllocMb\n         || capability.getVirtualCores() \u003c minAllocVcores) {\n       String message \u003d\n           \"NodeManager from  \" + host\n               + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n               + \" signal to the NodeManager.\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     response.setContainerTokenMasterKey(containerTokenSecretManager\n         .getCurrentKey());\n     response.setNMTokenMasterKey(nmTokenSecretManager\n         .getCurrentKey());    \n \n     RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n         resolve(host), capability);\n \n     RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n     if (oldNode \u003d\u003d null) {\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.STARTED));\n     } else {\n       LOG.info(\"Reconnect from the node at: \" + host);\n       this.nmLivelinessMonitor.unregister(nodeId);\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeReconnectEvent(nodeId, rmNode));\n     }\n     // On every node manager register we will be clearing NMToken keys if\n     // present for any running application.\n     this.nmTokenSecretManager.removeNodeKey(nodeId);\n     this.nmLivelinessMonitor.register(nodeId);\n \n     String message \u003d\n         \"NodeManager from node \" + host + \"(cmPort: \" + cmPort + \" httpPort: \"\n             + httpPort + \") \" + \"registered with capability: \" + capability\n             + \", assigned nodeId \" + nodeId;\n     LOG.info(message);\n     response.setNodeAction(NodeAction.NORMAL);\n-    response.setRMIdentifier(ResourceManager.clusterTimeStamp);\n+    response.setRMIdentifier(ResourceManager.getClusterTimeStamp());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterNodeManagerResponse registerNodeManager(\n      RegisterNodeManagerRequest request) throws YarnException,\n      IOException {\n\n    NodeId nodeId \u003d request.getNodeId();\n    String host \u003d nodeId.getHost();\n    int cmPort \u003d nodeId.getPort();\n    int httpPort \u003d request.getHttpPort();\n    Resource capability \u003d request.getResource();\n\n    RegisterNodeManagerResponse response \u003d recordFactory\n        .newRecordInstance(RegisterNodeManagerResponse.class);\n\n    // Check if this node is a \u0027valid\u0027 node\n    if (!this.nodesListManager.isValidNode(host)) {\n      String message \u003d\n          \"Disallowed NodeManager from  \" + host\n              + \", Sending SHUTDOWN signal to the NodeManager.\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    // Check if this node has minimum allocations\n    if (capability.getMemory() \u003c minAllocMb\n        || capability.getVirtualCores() \u003c minAllocVcores) {\n      String message \u003d\n          \"NodeManager from  \" + host\n              + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n              + \" signal to the NodeManager.\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    response.setContainerTokenMasterKey(containerTokenSecretManager\n        .getCurrentKey());\n    response.setNMTokenMasterKey(nmTokenSecretManager\n        .getCurrentKey());    \n\n    RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n        resolve(host), capability);\n\n    RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n    if (oldNode \u003d\u003d null) {\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.STARTED));\n    } else {\n      LOG.info(\"Reconnect from the node at: \" + host);\n      this.nmLivelinessMonitor.unregister(nodeId);\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeReconnectEvent(nodeId, rmNode));\n    }\n    // On every node manager register we will be clearing NMToken keys if\n    // present for any running application.\n    this.nmTokenSecretManager.removeNodeKey(nodeId);\n    this.nmLivelinessMonitor.register(nodeId);\n\n    String message \u003d\n        \"NodeManager from node \" + host + \"(cmPort: \" + cmPort + \" httpPort: \"\n            + httpPort + \") \" + \"registered with capability: \" + capability\n            + \", assigned nodeId \" + nodeId;\n    LOG.info(message);\n    response.setNodeAction(NodeAction.NORMAL);\n    response.setRMIdentifier(ResourceManager.getClusterTimeStamp());\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "769a0bd8314cd7317c083a9b74abf47242acb58c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-693. Modified RM to send NMTokens on allocate call so that AMs can then use them for authentication with NMs. Contributed by Omkar Vinit Joshi.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1493448 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "15/06/13 8:11 PM",
      "commitName": "769a0bd8314cd7317c083a9b74abf47242acb58c",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "13/06/13 5:06 PM",
      "commitNameOld": "f0eb4bc342370ec87d1f2665ffaf48ff4b3fbacb",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 2.13,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,67 +1,69 @@\n   public RegisterNodeManagerResponse registerNodeManager(\n       RegisterNodeManagerRequest request) throws YarnException,\n       IOException {\n \n     NodeId nodeId \u003d request.getNodeId();\n     String host \u003d nodeId.getHost();\n     int cmPort \u003d nodeId.getPort();\n     int httpPort \u003d request.getHttpPort();\n     Resource capability \u003d request.getResource();\n \n     RegisterNodeManagerResponse response \u003d recordFactory\n         .newRecordInstance(RegisterNodeManagerResponse.class);\n \n     // Check if this node is a \u0027valid\u0027 node\n     if (!this.nodesListManager.isValidNode(host)) {\n       String message \u003d\n           \"Disallowed NodeManager from  \" + host\n               + \", Sending SHUTDOWN signal to the NodeManager.\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     // Check if this node has minimum allocations\n     if (capability.getMemory() \u003c minAllocMb\n         || capability.getVirtualCores() \u003c minAllocVcores) {\n       String message \u003d\n           \"NodeManager from  \" + host\n               + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n               + \" signal to the NodeManager.\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     response.setContainerTokenMasterKey(containerTokenSecretManager\n         .getCurrentKey());\n     response.setNMTokenMasterKey(nmTokenSecretManager\n         .getCurrentKey());    \n \n     RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n         resolve(host), capability);\n \n     RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n     if (oldNode \u003d\u003d null) {\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.STARTED));\n     } else {\n       LOG.info(\"Reconnect from the node at: \" + host);\n       this.nmLivelinessMonitor.unregister(nodeId);\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeReconnectEvent(nodeId, rmNode));\n     }\n-\n+    // On every node manager register we will be clearing NMToken keys if\n+    // present for any running application.\n+    this.nmTokenSecretManager.removeNodeKey(nodeId);\n     this.nmLivelinessMonitor.register(nodeId);\n \n     String message \u003d\n         \"NodeManager from node \" + host + \"(cmPort: \" + cmPort + \" httpPort: \"\n             + httpPort + \") \" + \"registered with capability: \" + capability\n             + \", assigned nodeId \" + nodeId;\n     LOG.info(message);\n     response.setNodeAction(NodeAction.NORMAL);\n     response.setRMIdentifier(ResourceManager.clusterTimeStamp);\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterNodeManagerResponse registerNodeManager(\n      RegisterNodeManagerRequest request) throws YarnException,\n      IOException {\n\n    NodeId nodeId \u003d request.getNodeId();\n    String host \u003d nodeId.getHost();\n    int cmPort \u003d nodeId.getPort();\n    int httpPort \u003d request.getHttpPort();\n    Resource capability \u003d request.getResource();\n\n    RegisterNodeManagerResponse response \u003d recordFactory\n        .newRecordInstance(RegisterNodeManagerResponse.class);\n\n    // Check if this node is a \u0027valid\u0027 node\n    if (!this.nodesListManager.isValidNode(host)) {\n      String message \u003d\n          \"Disallowed NodeManager from  \" + host\n              + \", Sending SHUTDOWN signal to the NodeManager.\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    // Check if this node has minimum allocations\n    if (capability.getMemory() \u003c minAllocMb\n        || capability.getVirtualCores() \u003c minAllocVcores) {\n      String message \u003d\n          \"NodeManager from  \" + host\n              + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n              + \" signal to the NodeManager.\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    response.setContainerTokenMasterKey(containerTokenSecretManager\n        .getCurrentKey());\n    response.setNMTokenMasterKey(nmTokenSecretManager\n        .getCurrentKey());    \n\n    RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n        resolve(host), capability);\n\n    RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n    if (oldNode \u003d\u003d null) {\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.STARTED));\n    } else {\n      LOG.info(\"Reconnect from the node at: \" + host);\n      this.nmLivelinessMonitor.unregister(nodeId);\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeReconnectEvent(nodeId, rmNode));\n    }\n    // On every node manager register we will be clearing NMToken keys if\n    // present for any running application.\n    this.nmTokenSecretManager.removeNodeKey(nodeId);\n    this.nmLivelinessMonitor.register(nodeId);\n\n    String message \u003d\n        \"NodeManager from node \" + host + \"(cmPort: \" + cmPort + \" httpPort: \"\n            + httpPort + \") \" + \"registered with capability: \" + capability\n            + \", assigned nodeId \" + nodeId;\n    LOG.info(message);\n    response.setNodeAction(NodeAction.NORMAL);\n    response.setRMIdentifier(ResourceManager.clusterTimeStamp);\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "f0eb4bc342370ec87d1f2665ffaf48ff4b3fbacb": {
      "type": "Ybodychange",
      "commitMessage": "YARN-692. Creating NMToken master key on RM and sharing it with NM as a part of RM-NM heartbeat. Contributed by Omkar Vinit Joshi.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1492907 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "13/06/13 5:06 PM",
      "commitName": "f0eb4bc342370ec87d1f2665ffaf48ff4b3fbacb",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "13/06/13 4:25 PM",
      "commitNameOld": "c0cd68d8fbf5c8cafa6d563c7d0401e7a87a2d9e",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,66 +1,67 @@\n   public RegisterNodeManagerResponse registerNodeManager(\n       RegisterNodeManagerRequest request) throws YarnException,\n       IOException {\n \n     NodeId nodeId \u003d request.getNodeId();\n     String host \u003d nodeId.getHost();\n     int cmPort \u003d nodeId.getPort();\n     int httpPort \u003d request.getHttpPort();\n     Resource capability \u003d request.getResource();\n \n     RegisterNodeManagerResponse response \u003d recordFactory\n         .newRecordInstance(RegisterNodeManagerResponse.class);\n \n     // Check if this node is a \u0027valid\u0027 node\n     if (!this.nodesListManager.isValidNode(host)) {\n       String message \u003d\n           \"Disallowed NodeManager from  \" + host\n               + \", Sending SHUTDOWN signal to the NodeManager.\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     // Check if this node has minimum allocations\n     if (capability.getMemory() \u003c minAllocMb\n         || capability.getVirtualCores() \u003c minAllocVcores) {\n       String message \u003d\n           \"NodeManager from  \" + host\n               + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n               + \" signal to the NodeManager.\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n-    MasterKey nextMasterKeyForNode \u003d\n-        this.containerTokenSecretManager.getCurrentKey();\n-    response.setMasterKey(nextMasterKeyForNode);\n+    response.setContainerTokenMasterKey(containerTokenSecretManager\n+        .getCurrentKey());\n+    response.setNMTokenMasterKey(nmTokenSecretManager\n+        .getCurrentKey());    \n \n     RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n         resolve(host), capability);\n \n     RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n     if (oldNode \u003d\u003d null) {\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.STARTED));\n     } else {\n       LOG.info(\"Reconnect from the node at: \" + host);\n       this.nmLivelinessMonitor.unregister(nodeId);\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeReconnectEvent(nodeId, rmNode));\n     }\n \n     this.nmLivelinessMonitor.register(nodeId);\n \n     String message \u003d\n         \"NodeManager from node \" + host + \"(cmPort: \" + cmPort + \" httpPort: \"\n             + httpPort + \") \" + \"registered with capability: \" + capability\n             + \", assigned nodeId \" + nodeId;\n     LOG.info(message);\n     response.setNodeAction(NodeAction.NORMAL);\n     response.setRMIdentifier(ResourceManager.clusterTimeStamp);\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterNodeManagerResponse registerNodeManager(\n      RegisterNodeManagerRequest request) throws YarnException,\n      IOException {\n\n    NodeId nodeId \u003d request.getNodeId();\n    String host \u003d nodeId.getHost();\n    int cmPort \u003d nodeId.getPort();\n    int httpPort \u003d request.getHttpPort();\n    Resource capability \u003d request.getResource();\n\n    RegisterNodeManagerResponse response \u003d recordFactory\n        .newRecordInstance(RegisterNodeManagerResponse.class);\n\n    // Check if this node is a \u0027valid\u0027 node\n    if (!this.nodesListManager.isValidNode(host)) {\n      String message \u003d\n          \"Disallowed NodeManager from  \" + host\n              + \", Sending SHUTDOWN signal to the NodeManager.\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    // Check if this node has minimum allocations\n    if (capability.getMemory() \u003c minAllocMb\n        || capability.getVirtualCores() \u003c minAllocVcores) {\n      String message \u003d\n          \"NodeManager from  \" + host\n              + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n              + \" signal to the NodeManager.\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    response.setContainerTokenMasterKey(containerTokenSecretManager\n        .getCurrentKey());\n    response.setNMTokenMasterKey(nmTokenSecretManager\n        .getCurrentKey());    \n\n    RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n        resolve(host), capability);\n\n    RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n    if (oldNode \u003d\u003d null) {\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.STARTED));\n    } else {\n      LOG.info(\"Reconnect from the node at: \" + host);\n      this.nmLivelinessMonitor.unregister(nodeId);\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeReconnectEvent(nodeId, rmNode));\n    }\n\n    this.nmLivelinessMonitor.register(nodeId);\n\n    String message \u003d\n        \"NodeManager from node \" + host + \"(cmPort: \" + cmPort + \" httpPort: \"\n            + httpPort + \") \" + \"registered with capability: \" + capability\n            + \", assigned nodeId \" + nodeId;\n    LOG.info(message);\n    response.setNodeAction(NodeAction.NORMAL);\n    response.setRMIdentifier(ResourceManager.clusterTimeStamp);\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "a83fb61ac07c0468cbc7a38526e92683883dd932": {
      "type": "Yexceptionschange",
      "commitMessage": "YARN-635. Renamed YarnRemoteException to YarnException. Contributed by Siddharth Seth.\nMAPREDUCE-5301. Updated MR code to work with YARN-635 changes of renaming YarnRemoteException to YarnException. Contributed by Siddharth Seth\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1489283 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/06/13 9:05 PM",
      "commitName": "a83fb61ac07c0468cbc7a38526e92683883dd932",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "16/05/13 11:36 PM",
      "commitNameOld": "ca8024673178fa1c80224b390dfba932921693d9",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 17.9,
      "commitsBetweenForRepo": 100,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,66 +1,66 @@\n   public RegisterNodeManagerResponse registerNodeManager(\n-      RegisterNodeManagerRequest request) throws YarnRemoteException,\n+      RegisterNodeManagerRequest request) throws YarnException,\n       IOException {\n \n     NodeId nodeId \u003d request.getNodeId();\n     String host \u003d nodeId.getHost();\n     int cmPort \u003d nodeId.getPort();\n     int httpPort \u003d request.getHttpPort();\n     Resource capability \u003d request.getResource();\n \n     RegisterNodeManagerResponse response \u003d recordFactory\n         .newRecordInstance(RegisterNodeManagerResponse.class);\n \n     // Check if this node is a \u0027valid\u0027 node\n     if (!this.nodesListManager.isValidNode(host)) {\n       String message \u003d\n           \"Disallowed NodeManager from  \" + host\n               + \", Sending SHUTDOWN signal to the NodeManager.\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     // Check if this node has minimum allocations\n     if (capability.getMemory() \u003c minAllocMb\n         || capability.getVirtualCores() \u003c minAllocVcores) {\n       String message \u003d\n           \"NodeManager from  \" + host\n               + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n               + \" signal to the NodeManager.\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     MasterKey nextMasterKeyForNode \u003d\n         this.containerTokenSecretManager.getCurrentKey();\n     response.setMasterKey(nextMasterKeyForNode);\n \n     RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n         resolve(host), capability);\n \n     RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n     if (oldNode \u003d\u003d null) {\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.STARTED));\n     } else {\n       LOG.info(\"Reconnect from the node at: \" + host);\n       this.nmLivelinessMonitor.unregister(nodeId);\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeReconnectEvent(nodeId, rmNode));\n     }\n \n     this.nmLivelinessMonitor.register(nodeId);\n \n     String message \u003d\n         \"NodeManager from node \" + host + \"(cmPort: \" + cmPort + \" httpPort: \"\n             + httpPort + \") \" + \"registered with capability: \" + capability\n             + \", assigned nodeId \" + nodeId;\n     LOG.info(message);\n     response.setNodeAction(NodeAction.NORMAL);\n     response.setRMIdentifier(ResourceManager.clusterTimeStamp);\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterNodeManagerResponse registerNodeManager(\n      RegisterNodeManagerRequest request) throws YarnException,\n      IOException {\n\n    NodeId nodeId \u003d request.getNodeId();\n    String host \u003d nodeId.getHost();\n    int cmPort \u003d nodeId.getPort();\n    int httpPort \u003d request.getHttpPort();\n    Resource capability \u003d request.getResource();\n\n    RegisterNodeManagerResponse response \u003d recordFactory\n        .newRecordInstance(RegisterNodeManagerResponse.class);\n\n    // Check if this node is a \u0027valid\u0027 node\n    if (!this.nodesListManager.isValidNode(host)) {\n      String message \u003d\n          \"Disallowed NodeManager from  \" + host\n              + \", Sending SHUTDOWN signal to the NodeManager.\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    // Check if this node has minimum allocations\n    if (capability.getMemory() \u003c minAllocMb\n        || capability.getVirtualCores() \u003c minAllocVcores) {\n      String message \u003d\n          \"NodeManager from  \" + host\n              + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n              + \" signal to the NodeManager.\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    MasterKey nextMasterKeyForNode \u003d\n        this.containerTokenSecretManager.getCurrentKey();\n    response.setMasterKey(nextMasterKeyForNode);\n\n    RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n        resolve(host), capability);\n\n    RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n    if (oldNode \u003d\u003d null) {\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.STARTED));\n    } else {\n      LOG.info(\"Reconnect from the node at: \" + host);\n      this.nmLivelinessMonitor.unregister(nodeId);\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeReconnectEvent(nodeId, rmNode));\n    }\n\n    this.nmLivelinessMonitor.register(nodeId);\n\n    String message \u003d\n        \"NodeManager from node \" + host + \"(cmPort: \" + cmPort + \" httpPort: \"\n            + httpPort + \") \" + \"registered with capability: \" + capability\n            + \", assigned nodeId \" + nodeId;\n    LOG.info(message);\n    response.setNodeAction(NodeAction.NORMAL);\n    response.setRMIdentifier(ResourceManager.clusterTimeStamp);\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {
        "oldValue": "[YarnRemoteException, IOException]",
        "newValue": "[YarnException, IOException]"
      }
    },
    "ca8024673178fa1c80224b390dfba932921693d9": {
      "type": "Ybodychange",
      "commitMessage": "YARN-617. Made ContainerTokens to be used for validation at NodeManager also in unsecure mode to prevent AMs from faking resource requirements in unsecure mode. Contributed by Omkar Vinit Joshi.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1483667 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/05/13 11:36 PM",
      "commitName": "ca8024673178fa1c80224b390dfba932921693d9",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "10/05/13 4:37 PM",
      "commitNameOld": "68148989bfb8b893529eb9920d849bce0dd575ec",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 6.29,
      "commitsBetweenForRepo": 28,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,68 +1,66 @@\n   public RegisterNodeManagerResponse registerNodeManager(\n       RegisterNodeManagerRequest request) throws YarnRemoteException,\n       IOException {\n \n     NodeId nodeId \u003d request.getNodeId();\n     String host \u003d nodeId.getHost();\n     int cmPort \u003d nodeId.getPort();\n     int httpPort \u003d request.getHttpPort();\n     Resource capability \u003d request.getResource();\n \n     RegisterNodeManagerResponse response \u003d recordFactory\n         .newRecordInstance(RegisterNodeManagerResponse.class);\n \n     // Check if this node is a \u0027valid\u0027 node\n     if (!this.nodesListManager.isValidNode(host)) {\n       String message \u003d\n           \"Disallowed NodeManager from  \" + host\n               + \", Sending SHUTDOWN signal to the NodeManager.\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     // Check if this node has minimum allocations\n     if (capability.getMemory() \u003c minAllocMb\n         || capability.getVirtualCores() \u003c minAllocVcores) {\n       String message \u003d\n           \"NodeManager from  \" + host\n               + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n               + \" signal to the NodeManager.\";\n       LOG.info(message);\n       response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n-    if (isSecurityEnabled()) {\n-      MasterKey nextMasterKeyForNode \u003d\n-          this.containerTokenSecretManager.getCurrentKey();\n-      response.setMasterKey(nextMasterKeyForNode);\n-    }\n+    MasterKey nextMasterKeyForNode \u003d\n+        this.containerTokenSecretManager.getCurrentKey();\n+    response.setMasterKey(nextMasterKeyForNode);\n \n     RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n         resolve(host), capability);\n \n     RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n     if (oldNode \u003d\u003d null) {\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.STARTED));\n     } else {\n       LOG.info(\"Reconnect from the node at: \" + host);\n       this.nmLivelinessMonitor.unregister(nodeId);\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeReconnectEvent(nodeId, rmNode));\n     }\n \n     this.nmLivelinessMonitor.register(nodeId);\n \n     String message \u003d\n         \"NodeManager from node \" + host + \"(cmPort: \" + cmPort + \" httpPort: \"\n             + httpPort + \") \" + \"registered with capability: \" + capability\n             + \", assigned nodeId \" + nodeId;\n     LOG.info(message);\n     response.setNodeAction(NodeAction.NORMAL);\n     response.setRMIdentifier(ResourceManager.clusterTimeStamp);\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterNodeManagerResponse registerNodeManager(\n      RegisterNodeManagerRequest request) throws YarnRemoteException,\n      IOException {\n\n    NodeId nodeId \u003d request.getNodeId();\n    String host \u003d nodeId.getHost();\n    int cmPort \u003d nodeId.getPort();\n    int httpPort \u003d request.getHttpPort();\n    Resource capability \u003d request.getResource();\n\n    RegisterNodeManagerResponse response \u003d recordFactory\n        .newRecordInstance(RegisterNodeManagerResponse.class);\n\n    // Check if this node is a \u0027valid\u0027 node\n    if (!this.nodesListManager.isValidNode(host)) {\n      String message \u003d\n          \"Disallowed NodeManager from  \" + host\n              + \", Sending SHUTDOWN signal to the NodeManager.\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    // Check if this node has minimum allocations\n    if (capability.getMemory() \u003c minAllocMb\n        || capability.getVirtualCores() \u003c minAllocVcores) {\n      String message \u003d\n          \"NodeManager from  \" + host\n              + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n              + \" signal to the NodeManager.\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    MasterKey nextMasterKeyForNode \u003d\n        this.containerTokenSecretManager.getCurrentKey();\n    response.setMasterKey(nextMasterKeyForNode);\n\n    RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n        resolve(host), capability);\n\n    RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n    if (oldNode \u003d\u003d null) {\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.STARTED));\n    } else {\n      LOG.info(\"Reconnect from the node at: \" + host);\n      this.nmLivelinessMonitor.unregister(nodeId);\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeReconnectEvent(nodeId, rmNode));\n    }\n\n    this.nmLivelinessMonitor.register(nodeId);\n\n    String message \u003d\n        \"NodeManager from node \" + host + \"(cmPort: \" + cmPort + \" httpPort: \"\n            + httpPort + \") \" + \"registered with capability: \" + capability\n            + \", assigned nodeId \" + nodeId;\n    LOG.info(message);\n    response.setNodeAction(NodeAction.NORMAL);\n    response.setRMIdentifier(ResourceManager.clusterTimeStamp);\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "68148989bfb8b893529eb9920d849bce0dd575ec": {
      "type": "Ybodychange",
      "commitMessage": "YARN-590. Added an optional mesage to be returned by ResourceMaanger when RM asks an RM to shutdown/resync etc so that NMs can log this message locally for better debuggability. Contributed by Mayank Bansal.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1481234 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/05/13 4:37 PM",
      "commitName": "68148989bfb8b893529eb9920d849bce0dd575ec",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "10/05/13 2:58 PM",
      "commitNameOld": "a35c7fd80bcb19a7c6a7b9234d782adaf2d51529",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 0.07,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,61 +1,68 @@\n   public RegisterNodeManagerResponse registerNodeManager(\n       RegisterNodeManagerRequest request) throws YarnRemoteException,\n       IOException {\n \n     NodeId nodeId \u003d request.getNodeId();\n     String host \u003d nodeId.getHost();\n     int cmPort \u003d nodeId.getPort();\n     int httpPort \u003d request.getHttpPort();\n     Resource capability \u003d request.getResource();\n \n     RegisterNodeManagerResponse response \u003d recordFactory\n         .newRecordInstance(RegisterNodeManagerResponse.class);\n \n     // Check if this node is a \u0027valid\u0027 node\n     if (!this.nodesListManager.isValidNode(host)) {\n-      LOG.info(\"Disallowed NodeManager from  \" + host\n-          + \", Sending SHUTDOWN signal to the NodeManager.\");\n+      String message \u003d\n+          \"Disallowed NodeManager from  \" + host\n+              + \", Sending SHUTDOWN signal to the NodeManager.\";\n+      LOG.info(message);\n+      response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     // Check if this node has minimum allocations\n     if (capability.getMemory() \u003c minAllocMb\n         || capability.getVirtualCores() \u003c minAllocVcores) {\n-      LOG.info(\"NodeManager from  \" + host\n-          + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n-          + \" signal to the NodeManager.\");\n+      String message \u003d\n+          \"NodeManager from  \" + host\n+              + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n+              + \" signal to the NodeManager.\";\n+      LOG.info(message);\n+      response.setDiagnosticsMessage(message);\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     if (isSecurityEnabled()) {\n       MasterKey nextMasterKeyForNode \u003d\n           this.containerTokenSecretManager.getCurrentKey();\n       response.setMasterKey(nextMasterKeyForNode);\n     }\n \n     RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n         resolve(host), capability);\n \n     RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n     if (oldNode \u003d\u003d null) {\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.STARTED));\n     } else {\n       LOG.info(\"Reconnect from the node at: \" + host);\n       this.nmLivelinessMonitor.unregister(nodeId);\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeReconnectEvent(nodeId, rmNode));\n     }\n \n     this.nmLivelinessMonitor.register(nodeId);\n \n-    LOG.info(\"NodeManager from node \" + host + \"(cmPort: \" + cmPort\n-        + \" httpPort: \" + httpPort + \") \" + \"registered with capability: \"\n-        + capability + \", assigned nodeId \" + nodeId);\n-\n+    String message \u003d\n+        \"NodeManager from node \" + host + \"(cmPort: \" + cmPort + \" httpPort: \"\n+            + httpPort + \") \" + \"registered with capability: \" + capability\n+            + \", assigned nodeId \" + nodeId;\n+    LOG.info(message);\n     response.setNodeAction(NodeAction.NORMAL);\n     response.setRMIdentifier(ResourceManager.clusterTimeStamp);\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterNodeManagerResponse registerNodeManager(\n      RegisterNodeManagerRequest request) throws YarnRemoteException,\n      IOException {\n\n    NodeId nodeId \u003d request.getNodeId();\n    String host \u003d nodeId.getHost();\n    int cmPort \u003d nodeId.getPort();\n    int httpPort \u003d request.getHttpPort();\n    Resource capability \u003d request.getResource();\n\n    RegisterNodeManagerResponse response \u003d recordFactory\n        .newRecordInstance(RegisterNodeManagerResponse.class);\n\n    // Check if this node is a \u0027valid\u0027 node\n    if (!this.nodesListManager.isValidNode(host)) {\n      String message \u003d\n          \"Disallowed NodeManager from  \" + host\n              + \", Sending SHUTDOWN signal to the NodeManager.\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    // Check if this node has minimum allocations\n    if (capability.getMemory() \u003c minAllocMb\n        || capability.getVirtualCores() \u003c minAllocVcores) {\n      String message \u003d\n          \"NodeManager from  \" + host\n              + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n              + \" signal to the NodeManager.\";\n      LOG.info(message);\n      response.setDiagnosticsMessage(message);\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    if (isSecurityEnabled()) {\n      MasterKey nextMasterKeyForNode \u003d\n          this.containerTokenSecretManager.getCurrentKey();\n      response.setMasterKey(nextMasterKeyForNode);\n    }\n\n    RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n        resolve(host), capability);\n\n    RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n    if (oldNode \u003d\u003d null) {\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.STARTED));\n    } else {\n      LOG.info(\"Reconnect from the node at: \" + host);\n      this.nmLivelinessMonitor.unregister(nodeId);\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeReconnectEvent(nodeId, rmNode));\n    }\n\n    this.nmLivelinessMonitor.register(nodeId);\n\n    String message \u003d\n        \"NodeManager from node \" + host + \"(cmPort: \" + cmPort + \" httpPort: \"\n            + httpPort + \") \" + \"registered with capability: \" + capability\n            + \", assigned nodeId \" + nodeId;\n    LOG.info(message);\n    response.setNodeAction(NodeAction.NORMAL);\n    response.setRMIdentifier(ResourceManager.clusterTimeStamp);\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "a35c7fd80bcb19a7c6a7b9234d782adaf2d51529": {
      "type": "Yexceptionschange",
      "commitMessage": "YARN-663. Changed ResourceTracker API and LocalizationProtocol API to throw YarnRemoteException and IOException. Contributed by Xuan Gong.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1481215 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/05/13 2:58 PM",
      "commitName": "a35c7fd80bcb19a7c6a7b9234d782adaf2d51529",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "28/04/13 1:03 PM",
      "commitNameOld": "d9ce42479e5b2cbbf54dd2861680f9d37bdf31f3",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 12.08,
      "commitsBetweenForRepo": 88,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,60 +1,61 @@\n   public RegisterNodeManagerResponse registerNodeManager(\n-      RegisterNodeManagerRequest request) throws YarnRemoteException {\n+      RegisterNodeManagerRequest request) throws YarnRemoteException,\n+      IOException {\n \n     NodeId nodeId \u003d request.getNodeId();\n     String host \u003d nodeId.getHost();\n     int cmPort \u003d nodeId.getPort();\n     int httpPort \u003d request.getHttpPort();\n     Resource capability \u003d request.getResource();\n \n     RegisterNodeManagerResponse response \u003d recordFactory\n         .newRecordInstance(RegisterNodeManagerResponse.class);\n \n     // Check if this node is a \u0027valid\u0027 node\n     if (!this.nodesListManager.isValidNode(host)) {\n       LOG.info(\"Disallowed NodeManager from  \" + host\n           + \", Sending SHUTDOWN signal to the NodeManager.\");\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     // Check if this node has minimum allocations\n     if (capability.getMemory() \u003c minAllocMb\n         || capability.getVirtualCores() \u003c minAllocVcores) {\n       LOG.info(\"NodeManager from  \" + host\n           + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n           + \" signal to the NodeManager.\");\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     if (isSecurityEnabled()) {\n       MasterKey nextMasterKeyForNode \u003d\n           this.containerTokenSecretManager.getCurrentKey();\n       response.setMasterKey(nextMasterKeyForNode);\n     }\n \n     RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n         resolve(host), capability);\n \n     RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n     if (oldNode \u003d\u003d null) {\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.STARTED));\n     } else {\n       LOG.info(\"Reconnect from the node at: \" + host);\n       this.nmLivelinessMonitor.unregister(nodeId);\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeReconnectEvent(nodeId, rmNode));\n     }\n \n     this.nmLivelinessMonitor.register(nodeId);\n \n     LOG.info(\"NodeManager from node \" + host + \"(cmPort: \" + cmPort\n         + \" httpPort: \" + httpPort + \") \" + \"registered with capability: \"\n         + capability + \", assigned nodeId \" + nodeId);\n \n     response.setNodeAction(NodeAction.NORMAL);\n     response.setRMIdentifier(ResourceManager.clusterTimeStamp);\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterNodeManagerResponse registerNodeManager(\n      RegisterNodeManagerRequest request) throws YarnRemoteException,\n      IOException {\n\n    NodeId nodeId \u003d request.getNodeId();\n    String host \u003d nodeId.getHost();\n    int cmPort \u003d nodeId.getPort();\n    int httpPort \u003d request.getHttpPort();\n    Resource capability \u003d request.getResource();\n\n    RegisterNodeManagerResponse response \u003d recordFactory\n        .newRecordInstance(RegisterNodeManagerResponse.class);\n\n    // Check if this node is a \u0027valid\u0027 node\n    if (!this.nodesListManager.isValidNode(host)) {\n      LOG.info(\"Disallowed NodeManager from  \" + host\n          + \", Sending SHUTDOWN signal to the NodeManager.\");\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    // Check if this node has minimum allocations\n    if (capability.getMemory() \u003c minAllocMb\n        || capability.getVirtualCores() \u003c minAllocVcores) {\n      LOG.info(\"NodeManager from  \" + host\n          + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n          + \" signal to the NodeManager.\");\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    if (isSecurityEnabled()) {\n      MasterKey nextMasterKeyForNode \u003d\n          this.containerTokenSecretManager.getCurrentKey();\n      response.setMasterKey(nextMasterKeyForNode);\n    }\n\n    RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n        resolve(host), capability);\n\n    RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n    if (oldNode \u003d\u003d null) {\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.STARTED));\n    } else {\n      LOG.info(\"Reconnect from the node at: \" + host);\n      this.nmLivelinessMonitor.unregister(nodeId);\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeReconnectEvent(nodeId, rmNode));\n    }\n\n    this.nmLivelinessMonitor.register(nodeId);\n\n    LOG.info(\"NodeManager from node \" + host + \"(cmPort: \" + cmPort\n        + \" httpPort: \" + httpPort + \") \" + \"registered with capability: \"\n        + capability + \", assigned nodeId \" + nodeId);\n\n    response.setNodeAction(NodeAction.NORMAL);\n    response.setRMIdentifier(ResourceManager.clusterTimeStamp);\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {
        "oldValue": "[YarnRemoteException]",
        "newValue": "[YarnRemoteException, IOException]"
      }
    },
    "d9ce42479e5b2cbbf54dd2861680f9d37bdf31f3": {
      "type": "Ybodychange",
      "commitMessage": "YARN-576. Modified ResourceManager to reject NodeManagers that don\u0027t satisy minimum resource requirements. Contributed by Kenji Kikushima.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1476824 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "28/04/13 1:03 PM",
      "commitName": "d9ce42479e5b2cbbf54dd2861680f9d37bdf31f3",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "25/04/13 8:50 PM",
      "commitNameOld": "fbb55784d93e1a819daf55d936e864d344579cbf",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 2.68,
      "commitsBetweenForRepo": 18,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,50 +1,60 @@\n   public RegisterNodeManagerResponse registerNodeManager(\n       RegisterNodeManagerRequest request) throws YarnRemoteException {\n \n     NodeId nodeId \u003d request.getNodeId();\n     String host \u003d nodeId.getHost();\n     int cmPort \u003d nodeId.getPort();\n     int httpPort \u003d request.getHttpPort();\n     Resource capability \u003d request.getResource();\n \n     RegisterNodeManagerResponse response \u003d recordFactory\n         .newRecordInstance(RegisterNodeManagerResponse.class);\n \n     // Check if this node is a \u0027valid\u0027 node\n     if (!this.nodesListManager.isValidNode(host)) {\n       LOG.info(\"Disallowed NodeManager from  \" + host\n           + \", Sending SHUTDOWN signal to the NodeManager.\");\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n+    // Check if this node has minimum allocations\n+    if (capability.getMemory() \u003c minAllocMb\n+        || capability.getVirtualCores() \u003c minAllocVcores) {\n+      LOG.info(\"NodeManager from  \" + host\n+          + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n+          + \" signal to the NodeManager.\");\n+      response.setNodeAction(NodeAction.SHUTDOWN);\n+      return response;\n+    }\n+\n     if (isSecurityEnabled()) {\n       MasterKey nextMasterKeyForNode \u003d\n           this.containerTokenSecretManager.getCurrentKey();\n       response.setMasterKey(nextMasterKeyForNode);\n     }\n \n     RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n         resolve(host), capability);\n \n     RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n     if (oldNode \u003d\u003d null) {\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.STARTED));\n     } else {\n       LOG.info(\"Reconnect from the node at: \" + host);\n       this.nmLivelinessMonitor.unregister(nodeId);\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeReconnectEvent(nodeId, rmNode));\n     }\n \n     this.nmLivelinessMonitor.register(nodeId);\n \n     LOG.info(\"NodeManager from node \" + host + \"(cmPort: \" + cmPort\n         + \" httpPort: \" + httpPort + \") \" + \"registered with capability: \"\n         + capability + \", assigned nodeId \" + nodeId);\n \n     response.setNodeAction(NodeAction.NORMAL);\n     response.setRMIdentifier(ResourceManager.clusterTimeStamp);\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterNodeManagerResponse registerNodeManager(\n      RegisterNodeManagerRequest request) throws YarnRemoteException {\n\n    NodeId nodeId \u003d request.getNodeId();\n    String host \u003d nodeId.getHost();\n    int cmPort \u003d nodeId.getPort();\n    int httpPort \u003d request.getHttpPort();\n    Resource capability \u003d request.getResource();\n\n    RegisterNodeManagerResponse response \u003d recordFactory\n        .newRecordInstance(RegisterNodeManagerResponse.class);\n\n    // Check if this node is a \u0027valid\u0027 node\n    if (!this.nodesListManager.isValidNode(host)) {\n      LOG.info(\"Disallowed NodeManager from  \" + host\n          + \", Sending SHUTDOWN signal to the NodeManager.\");\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    // Check if this node has minimum allocations\n    if (capability.getMemory() \u003c minAllocMb\n        || capability.getVirtualCores() \u003c minAllocVcores) {\n      LOG.info(\"NodeManager from  \" + host\n          + \" doesn\u0027t satisfy minimum allocations, Sending SHUTDOWN\"\n          + \" signal to the NodeManager.\");\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    if (isSecurityEnabled()) {\n      MasterKey nextMasterKeyForNode \u003d\n          this.containerTokenSecretManager.getCurrentKey();\n      response.setMasterKey(nextMasterKeyForNode);\n    }\n\n    RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n        resolve(host), capability);\n\n    RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n    if (oldNode \u003d\u003d null) {\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.STARTED));\n    } else {\n      LOG.info(\"Reconnect from the node at: \" + host);\n      this.nmLivelinessMonitor.unregister(nodeId);\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeReconnectEvent(nodeId, rmNode));\n    }\n\n    this.nmLivelinessMonitor.register(nodeId);\n\n    LOG.info(\"NodeManager from node \" + host + \"(cmPort: \" + cmPort\n        + \" httpPort: \" + httpPort + \") \" + \"registered with capability: \"\n        + capability + \", assigned nodeId \" + nodeId);\n\n    response.setNodeAction(NodeAction.NORMAL);\n    response.setRMIdentifier(ResourceManager.clusterTimeStamp);\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "fbb55784d93e1a819daf55d936e864d344579cbf": {
      "type": "Ybodychange",
      "commitMessage": "YARN-562. Modified NM to reject any containers allocated by a previous ResourceManager. Contributed by Jian He.\nMAPREDUCE-5167. Update MR App after YARN-562 to use the new builder API for the container. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1476034 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/04/13 8:50 PM",
      "commitName": "fbb55784d93e1a819daf55d936e864d344579cbf",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "10/04/13 7:00 PM",
      "commitNameOld": "2e3b56f6e907f15f7c6caaad37d37b9e0ee89963",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 15.08,
      "commitsBetweenForRepo": 83,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,49 +1,50 @@\n   public RegisterNodeManagerResponse registerNodeManager(\n       RegisterNodeManagerRequest request) throws YarnRemoteException {\n \n     NodeId nodeId \u003d request.getNodeId();\n     String host \u003d nodeId.getHost();\n     int cmPort \u003d nodeId.getPort();\n     int httpPort \u003d request.getHttpPort();\n     Resource capability \u003d request.getResource();\n \n     RegisterNodeManagerResponse response \u003d recordFactory\n         .newRecordInstance(RegisterNodeManagerResponse.class);\n \n     // Check if this node is a \u0027valid\u0027 node\n     if (!this.nodesListManager.isValidNode(host)) {\n       LOG.info(\"Disallowed NodeManager from  \" + host\n           + \", Sending SHUTDOWN signal to the NodeManager.\");\n       response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     if (isSecurityEnabled()) {\n       MasterKey nextMasterKeyForNode \u003d\n           this.containerTokenSecretManager.getCurrentKey();\n       response.setMasterKey(nextMasterKeyForNode);\n     }\n \n     RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n         resolve(host), capability);\n \n     RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n     if (oldNode \u003d\u003d null) {\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.STARTED));\n     } else {\n       LOG.info(\"Reconnect from the node at: \" + host);\n       this.nmLivelinessMonitor.unregister(nodeId);\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeReconnectEvent(nodeId, rmNode));\n     }\n \n     this.nmLivelinessMonitor.register(nodeId);\n \n     LOG.info(\"NodeManager from node \" + host + \"(cmPort: \" + cmPort\n         + \" httpPort: \" + httpPort + \") \" + \"registered with capability: \"\n         + capability + \", assigned nodeId \" + nodeId);\n \n     response.setNodeAction(NodeAction.NORMAL);\n+    response.setRMIdentifier(ResourceManager.clusterTimeStamp);\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterNodeManagerResponse registerNodeManager(\n      RegisterNodeManagerRequest request) throws YarnRemoteException {\n\n    NodeId nodeId \u003d request.getNodeId();\n    String host \u003d nodeId.getHost();\n    int cmPort \u003d nodeId.getPort();\n    int httpPort \u003d request.getHttpPort();\n    Resource capability \u003d request.getResource();\n\n    RegisterNodeManagerResponse response \u003d recordFactory\n        .newRecordInstance(RegisterNodeManagerResponse.class);\n\n    // Check if this node is a \u0027valid\u0027 node\n    if (!this.nodesListManager.isValidNode(host)) {\n      LOG.info(\"Disallowed NodeManager from  \" + host\n          + \", Sending SHUTDOWN signal to the NodeManager.\");\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    if (isSecurityEnabled()) {\n      MasterKey nextMasterKeyForNode \u003d\n          this.containerTokenSecretManager.getCurrentKey();\n      response.setMasterKey(nextMasterKeyForNode);\n    }\n\n    RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n        resolve(host), capability);\n\n    RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n    if (oldNode \u003d\u003d null) {\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.STARTED));\n    } else {\n      LOG.info(\"Reconnect from the node at: \" + host);\n      this.nmLivelinessMonitor.unregister(nodeId);\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeReconnectEvent(nodeId, rmNode));\n    }\n\n    this.nmLivelinessMonitor.register(nodeId);\n\n    LOG.info(\"NodeManager from node \" + host + \"(cmPort: \" + cmPort\n        + \" httpPort: \" + httpPort + \") \" + \"registered with capability: \"\n        + capability + \", assigned nodeId \" + nodeId);\n\n    response.setNodeAction(NodeAction.NORMAL);\n    response.setRMIdentifier(ResourceManager.clusterTimeStamp);\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "66e90b205a079c7056bd85e6c5e3dbb2a96e7461": {
      "type": "Ybodychange",
      "commitMessage": "YARN-440. Flatten RegisterNodeManagerResponse. Contributed by Xuan Gong.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1461256 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "26/03/13 11:20 AM",
      "commitName": "66e90b205a079c7056bd85e6c5e3dbb2a96e7461",
      "commitAuthor": "Siddharth Seth",
      "commitDateOld": "25/03/13 11:28 AM",
      "commitNameOld": "18e08a8f511652ed9f4ba386bb4f0cf8339e2729",
      "commitAuthorOld": "Siddharth Seth",
      "daysBetweenCommits": 0.99,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,49 @@\n   public RegisterNodeManagerResponse registerNodeManager(\n       RegisterNodeManagerRequest request) throws YarnRemoteException {\n \n     NodeId nodeId \u003d request.getNodeId();\n     String host \u003d nodeId.getHost();\n     int cmPort \u003d nodeId.getPort();\n     int httpPort \u003d request.getHttpPort();\n     Resource capability \u003d request.getResource();\n \n     RegisterNodeManagerResponse response \u003d recordFactory\n         .newRecordInstance(RegisterNodeManagerResponse.class);\n-    RegistrationResponse regResponse \u003d recordFactory\n-        .newRecordInstance(RegistrationResponse.class);\n \n     // Check if this node is a \u0027valid\u0027 node\n     if (!this.nodesListManager.isValidNode(host)) {\n       LOG.info(\"Disallowed NodeManager from  \" + host\n           + \", Sending SHUTDOWN signal to the NodeManager.\");\n-      regResponse.setNodeAction(NodeAction.SHUTDOWN);\n-      response.setRegistrationResponse(regResponse);\n+      response.setNodeAction(NodeAction.SHUTDOWN);\n       return response;\n     }\n \n     if (isSecurityEnabled()) {\n       MasterKey nextMasterKeyForNode \u003d\n           this.containerTokenSecretManager.getCurrentKey();\n-      regResponse.setMasterKey(nextMasterKeyForNode);\n+      response.setMasterKey(nextMasterKeyForNode);\n     }\n \n     RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n         resolve(host), capability);\n \n     RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n     if (oldNode \u003d\u003d null) {\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.STARTED));\n     } else {\n       LOG.info(\"Reconnect from the node at: \" + host);\n       this.nmLivelinessMonitor.unregister(nodeId);\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeReconnectEvent(nodeId, rmNode));\n     }\n \n     this.nmLivelinessMonitor.register(nodeId);\n \n     LOG.info(\"NodeManager from node \" + host + \"(cmPort: \" + cmPort\n         + \" httpPort: \" + httpPort + \") \" + \"registered with capability: \"\n         + capability + \", assigned nodeId \" + nodeId);\n \n-    regResponse.setNodeAction(NodeAction.NORMAL);\n-    response.setRegistrationResponse(regResponse);\n+    response.setNodeAction(NodeAction.NORMAL);\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterNodeManagerResponse registerNodeManager(\n      RegisterNodeManagerRequest request) throws YarnRemoteException {\n\n    NodeId nodeId \u003d request.getNodeId();\n    String host \u003d nodeId.getHost();\n    int cmPort \u003d nodeId.getPort();\n    int httpPort \u003d request.getHttpPort();\n    Resource capability \u003d request.getResource();\n\n    RegisterNodeManagerResponse response \u003d recordFactory\n        .newRecordInstance(RegisterNodeManagerResponse.class);\n\n    // Check if this node is a \u0027valid\u0027 node\n    if (!this.nodesListManager.isValidNode(host)) {\n      LOG.info(\"Disallowed NodeManager from  \" + host\n          + \", Sending SHUTDOWN signal to the NodeManager.\");\n      response.setNodeAction(NodeAction.SHUTDOWN);\n      return response;\n    }\n\n    if (isSecurityEnabled()) {\n      MasterKey nextMasterKeyForNode \u003d\n          this.containerTokenSecretManager.getCurrentKey();\n      response.setMasterKey(nextMasterKeyForNode);\n    }\n\n    RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n        resolve(host), capability);\n\n    RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n    if (oldNode \u003d\u003d null) {\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.STARTED));\n    } else {\n      LOG.info(\"Reconnect from the node at: \" + host);\n      this.nmLivelinessMonitor.unregister(nodeId);\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeReconnectEvent(nodeId, rmNode));\n    }\n\n    this.nmLivelinessMonitor.register(nodeId);\n\n    LOG.info(\"NodeManager from node \" + host + \"(cmPort: \" + cmPort\n        + \" httpPort: \" + httpPort + \") \" + \"registered with capability: \"\n        + capability + \", assigned nodeId \" + nodeId);\n\n    response.setNodeAction(NodeAction.NORMAL);\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "453926397182078c65a4428eb5de5a90d6af6448": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2. Enhanced CapacityScheduler to account for CPU alongwith memory for multi-dimensional resource scheduling. Contributed by Arun C. Murthy.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1430682 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/01/13 9:08 PM",
      "commitName": "453926397182078c65a4428eb5de5a90d6af6448",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "28/11/12 5:56 PM",
      "commitNameOld": "1943fdbec613715f3cdc3ca60cbd273115f28299",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 41.13,
      "commitsBetweenForRepo": 152,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,53 @@\n   public RegisterNodeManagerResponse registerNodeManager(\n       RegisterNodeManagerRequest request) throws YarnRemoteException {\n \n     NodeId nodeId \u003d request.getNodeId();\n     String host \u003d nodeId.getHost();\n     int cmPort \u003d nodeId.getPort();\n     int httpPort \u003d request.getHttpPort();\n     Resource capability \u003d request.getResource();\n \n     RegisterNodeManagerResponse response \u003d recordFactory\n         .newRecordInstance(RegisterNodeManagerResponse.class);\n     RegistrationResponse regResponse \u003d recordFactory\n         .newRecordInstance(RegistrationResponse.class);\n \n     // Check if this node is a \u0027valid\u0027 node\n     if (!this.nodesListManager.isValidNode(host)) {\n       LOG.info(\"Disallowed NodeManager from  \" + host\n           + \", Sending SHUTDOWN signal to the NodeManager.\");\n       regResponse.setNodeAction(NodeAction.SHUTDOWN);\n       response.setRegistrationResponse(regResponse);\n       return response;\n     }\n \n     if (isSecurityEnabled()) {\n       MasterKey nextMasterKeyForNode \u003d\n           this.containerTokenSecretManager.getCurrentKey();\n       regResponse.setMasterKey(nextMasterKeyForNode);\n     }\n \n     RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n         resolve(host), capability);\n \n     RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n     if (oldNode \u003d\u003d null) {\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.STARTED));\n     } else {\n       LOG.info(\"Reconnect from the node at: \" + host);\n       this.nmLivelinessMonitor.unregister(nodeId);\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeReconnectEvent(nodeId, rmNode));\n     }\n \n     this.nmLivelinessMonitor.register(nodeId);\n \n     LOG.info(\"NodeManager from node \" + host + \"(cmPort: \" + cmPort\n         + \" httpPort: \" + httpPort + \") \" + \"registered with capability: \"\n-        + capability.getMemory() + \", assigned nodeId \" + nodeId);\n+        + capability + \", assigned nodeId \" + nodeId);\n \n     regResponse.setNodeAction(NodeAction.NORMAL);\n     response.setRegistrationResponse(regResponse);\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterNodeManagerResponse registerNodeManager(\n      RegisterNodeManagerRequest request) throws YarnRemoteException {\n\n    NodeId nodeId \u003d request.getNodeId();\n    String host \u003d nodeId.getHost();\n    int cmPort \u003d nodeId.getPort();\n    int httpPort \u003d request.getHttpPort();\n    Resource capability \u003d request.getResource();\n\n    RegisterNodeManagerResponse response \u003d recordFactory\n        .newRecordInstance(RegisterNodeManagerResponse.class);\n    RegistrationResponse regResponse \u003d recordFactory\n        .newRecordInstance(RegistrationResponse.class);\n\n    // Check if this node is a \u0027valid\u0027 node\n    if (!this.nodesListManager.isValidNode(host)) {\n      LOG.info(\"Disallowed NodeManager from  \" + host\n          + \", Sending SHUTDOWN signal to the NodeManager.\");\n      regResponse.setNodeAction(NodeAction.SHUTDOWN);\n      response.setRegistrationResponse(regResponse);\n      return response;\n    }\n\n    if (isSecurityEnabled()) {\n      MasterKey nextMasterKeyForNode \u003d\n          this.containerTokenSecretManager.getCurrentKey();\n      regResponse.setMasterKey(nextMasterKeyForNode);\n    }\n\n    RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n        resolve(host), capability);\n\n    RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n    if (oldNode \u003d\u003d null) {\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.STARTED));\n    } else {\n      LOG.info(\"Reconnect from the node at: \" + host);\n      this.nmLivelinessMonitor.unregister(nodeId);\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeReconnectEvent(nodeId, rmNode));\n    }\n\n    this.nmLivelinessMonitor.register(nodeId);\n\n    LOG.info(\"NodeManager from node \" + host + \"(cmPort: \" + cmPort\n        + \" httpPort: \" + httpPort + \") \" + \"registered with capability: \"\n        + capability + \", assigned nodeId \" + nodeId);\n\n    regResponse.setNodeAction(NodeAction.NORMAL);\n    response.setRegistrationResponse(regResponse);\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "45a8e8c5a46535287de97fd6609c0743eef888ee": {
      "type": "Ybodychange",
      "commitMessage": "YARN-60. Fixed a bug in ResourceManager which causes all NMs to get NPEs and thus causes all containers to be rejected. Contributed by Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1379550 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "31/08/12 12:11 PM",
      "commitName": "45a8e8c5a46535287de97fd6609c0743eef888ee",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "24/08/12 7:18 PM",
      "commitNameOld": "ffd2e01604be814fa3db1dded7cd7cff26a79b1e",
      "commitAuthorOld": "Siddharth Seth",
      "daysBetweenCommits": 6.7,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,53 @@\n   public RegisterNodeManagerResponse registerNodeManager(\n       RegisterNodeManagerRequest request) throws YarnRemoteException {\n \n     NodeId nodeId \u003d request.getNodeId();\n     String host \u003d nodeId.getHost();\n     int cmPort \u003d nodeId.getPort();\n     int httpPort \u003d request.getHttpPort();\n     Resource capability \u003d request.getResource();\n \n     RegisterNodeManagerResponse response \u003d recordFactory\n         .newRecordInstance(RegisterNodeManagerResponse.class);\n     RegistrationResponse regResponse \u003d recordFactory\n         .newRecordInstance(RegistrationResponse.class);\n \n     // Check if this node is a \u0027valid\u0027 node\n     if (!this.nodesListManager.isValidNode(host)) {\n       LOG.info(\"Disallowed NodeManager from  \" + host\n           + \", Sending SHUTDOWN signal to the NodeManager.\");\n       regResponse.setNodeAction(NodeAction.SHUTDOWN);\n       response.setRegistrationResponse(regResponse);\n       return response;\n     }\n \n-    MasterKey nextMasterKeyForNode \u003d null;\n     if (isSecurityEnabled()) {\n-      nextMasterKeyForNode \u003d this.containerTokenSecretManager.getCurrentKey();\n+      MasterKey nextMasterKeyForNode \u003d\n+          this.containerTokenSecretManager.getCurrentKey();\n       regResponse.setMasterKey(nextMasterKeyForNode);\n     }\n \n     RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n-        resolve(host), capability, nextMasterKeyForNode);\n+        resolve(host), capability);\n \n     RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n     if (oldNode \u003d\u003d null) {\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.STARTED));\n     } else {\n       LOG.info(\"Reconnect from the node at: \" + host);\n       this.nmLivelinessMonitor.unregister(nodeId);\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeReconnectEvent(nodeId, rmNode));\n     }\n \n     this.nmLivelinessMonitor.register(nodeId);\n \n     LOG.info(\"NodeManager from node \" + host + \"(cmPort: \" + cmPort\n         + \" httpPort: \" + httpPort + \") \" + \"registered with capability: \"\n         + capability.getMemory() + \", assigned nodeId \" + nodeId);\n \n     regResponse.setNodeAction(NodeAction.NORMAL);\n     response.setRegistrationResponse(regResponse);\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterNodeManagerResponse registerNodeManager(\n      RegisterNodeManagerRequest request) throws YarnRemoteException {\n\n    NodeId nodeId \u003d request.getNodeId();\n    String host \u003d nodeId.getHost();\n    int cmPort \u003d nodeId.getPort();\n    int httpPort \u003d request.getHttpPort();\n    Resource capability \u003d request.getResource();\n\n    RegisterNodeManagerResponse response \u003d recordFactory\n        .newRecordInstance(RegisterNodeManagerResponse.class);\n    RegistrationResponse regResponse \u003d recordFactory\n        .newRecordInstance(RegistrationResponse.class);\n\n    // Check if this node is a \u0027valid\u0027 node\n    if (!this.nodesListManager.isValidNode(host)) {\n      LOG.info(\"Disallowed NodeManager from  \" + host\n          + \", Sending SHUTDOWN signal to the NodeManager.\");\n      regResponse.setNodeAction(NodeAction.SHUTDOWN);\n      response.setRegistrationResponse(regResponse);\n      return response;\n    }\n\n    if (isSecurityEnabled()) {\n      MasterKey nextMasterKeyForNode \u003d\n          this.containerTokenSecretManager.getCurrentKey();\n      regResponse.setMasterKey(nextMasterKeyForNode);\n    }\n\n    RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n        resolve(host), capability);\n\n    RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n    if (oldNode \u003d\u003d null) {\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.STARTED));\n    } else {\n      LOG.info(\"Reconnect from the node at: \" + host);\n      this.nmLivelinessMonitor.unregister(nodeId);\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeReconnectEvent(nodeId, rmNode));\n    }\n\n    this.nmLivelinessMonitor.register(nodeId);\n\n    LOG.info(\"NodeManager from node \" + host + \"(cmPort: \" + cmPort\n        + \" httpPort: \" + httpPort + \") \" + \"registered with capability: \"\n        + capability.getMemory() + \", assigned nodeId \" + nodeId);\n\n    regResponse.setNodeAction(NodeAction.NORMAL);\n    response.setRegistrationResponse(regResponse);\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "ffd2e01604be814fa3db1dded7cd7cff26a79b1e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-39. RM-NM secret-keys should be randomly generated and rolled every so often. (Contributed by Vinod Kumar Vavilapalli and Siddharth Seth)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1377180 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/12 7:18 PM",
      "commitName": "ffd2e01604be814fa3db1dded7cd7cff26a79b1e",
      "commitAuthor": "Siddharth Seth",
      "commitDateOld": "07/08/12 10:22 PM",
      "commitNameOld": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 16.87,
      "commitsBetweenForRepo": 114,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,50 +1,53 @@\n   public RegisterNodeManagerResponse registerNodeManager(\n       RegisterNodeManagerRequest request) throws YarnRemoteException {\n \n     NodeId nodeId \u003d request.getNodeId();\n     String host \u003d nodeId.getHost();\n     int cmPort \u003d nodeId.getPort();\n     int httpPort \u003d request.getHttpPort();\n     Resource capability \u003d request.getResource();\n \n     RegisterNodeManagerResponse response \u003d recordFactory\n         .newRecordInstance(RegisterNodeManagerResponse.class);\n     RegistrationResponse regResponse \u003d recordFactory\n         .newRecordInstance(RegistrationResponse.class);\n-    SecretKey secretKey \u003d this.containerTokenSecretManager\n-        .createAndGetSecretKey(nodeId.toString());\n-    regResponse.setSecretKey(ByteBuffer.wrap(secretKey.getEncoded()));\n \n     // Check if this node is a \u0027valid\u0027 node\n     if (!this.nodesListManager.isValidNode(host)) {\n       LOG.info(\"Disallowed NodeManager from  \" + host\n           + \", Sending SHUTDOWN signal to the NodeManager.\");\n       regResponse.setNodeAction(NodeAction.SHUTDOWN);\n       response.setRegistrationResponse(regResponse);\n       return response;\n     }\n \n+    MasterKey nextMasterKeyForNode \u003d null;\n+    if (isSecurityEnabled()) {\n+      nextMasterKeyForNode \u003d this.containerTokenSecretManager.getCurrentKey();\n+      regResponse.setMasterKey(nextMasterKeyForNode);\n+    }\n+\n     RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n-        resolve(host), capability);\n+        resolve(host), capability, nextMasterKeyForNode);\n \n     RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n     if (oldNode \u003d\u003d null) {\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeEvent(nodeId, RMNodeEventType.STARTED));\n     } else {\n       LOG.info(\"Reconnect from the node at: \" + host);\n       this.nmLivelinessMonitor.unregister(nodeId);\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMNodeReconnectEvent(nodeId, rmNode));\n     }\n \n     this.nmLivelinessMonitor.register(nodeId);\n \n     LOG.info(\"NodeManager from node \" + host + \"(cmPort: \" + cmPort\n         + \" httpPort: \" + httpPort + \") \" + \"registered with capability: \"\n         + capability.getMemory() + \", assigned nodeId \" + nodeId);\n \n     regResponse.setNodeAction(NodeAction.NORMAL);\n     response.setRegistrationResponse(regResponse);\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterNodeManagerResponse registerNodeManager(\n      RegisterNodeManagerRequest request) throws YarnRemoteException {\n\n    NodeId nodeId \u003d request.getNodeId();\n    String host \u003d nodeId.getHost();\n    int cmPort \u003d nodeId.getPort();\n    int httpPort \u003d request.getHttpPort();\n    Resource capability \u003d request.getResource();\n\n    RegisterNodeManagerResponse response \u003d recordFactory\n        .newRecordInstance(RegisterNodeManagerResponse.class);\n    RegistrationResponse regResponse \u003d recordFactory\n        .newRecordInstance(RegistrationResponse.class);\n\n    // Check if this node is a \u0027valid\u0027 node\n    if (!this.nodesListManager.isValidNode(host)) {\n      LOG.info(\"Disallowed NodeManager from  \" + host\n          + \", Sending SHUTDOWN signal to the NodeManager.\");\n      regResponse.setNodeAction(NodeAction.SHUTDOWN);\n      response.setRegistrationResponse(regResponse);\n      return response;\n    }\n\n    MasterKey nextMasterKeyForNode \u003d null;\n    if (isSecurityEnabled()) {\n      nextMasterKeyForNode \u003d this.containerTokenSecretManager.getCurrentKey();\n      regResponse.setMasterKey(nextMasterKeyForNode);\n    }\n\n    RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n        resolve(host), capability, nextMasterKeyForNode);\n\n    RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n    if (oldNode \u003d\u003d null) {\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.STARTED));\n    } else {\n      LOG.info(\"Reconnect from the node at: \" + host);\n      this.nmLivelinessMonitor.unregister(nodeId);\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeReconnectEvent(nodeId, rmNode));\n    }\n\n    this.nmLivelinessMonitor.register(nodeId);\n\n    LOG.info(\"NodeManager from node \" + host + \"(cmPort: \" + cmPort\n        + \" httpPort: \" + httpPort + \") \" + \"registered with capability: \"\n        + capability.getMemory() + \", assigned nodeId \" + nodeId);\n\n    regResponse.setNodeAction(NodeAction.NORMAL);\n    response.setRegistrationResponse(regResponse);\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "e1fdf62123625e4ba399af02f8aad500637d29d1": {
      "type": "Yfilerename",
      "commitMessage": "YARN-1. Promote YARN to be a sub-project of Apache Hadoop.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1370666 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/08/12 10:22 PM",
      "commitName": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "07/08/12 7:53 PM",
      "commitNameOld": "34554d1e11ee1d5b564d7d9ed3e6d55931d72749",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public RegisterNodeManagerResponse registerNodeManager(\n      RegisterNodeManagerRequest request) throws YarnRemoteException {\n\n    NodeId nodeId \u003d request.getNodeId();\n    String host \u003d nodeId.getHost();\n    int cmPort \u003d nodeId.getPort();\n    int httpPort \u003d request.getHttpPort();\n    Resource capability \u003d request.getResource();\n\n    RegisterNodeManagerResponse response \u003d recordFactory\n        .newRecordInstance(RegisterNodeManagerResponse.class);\n    RegistrationResponse regResponse \u003d recordFactory\n        .newRecordInstance(RegistrationResponse.class);\n    SecretKey secretKey \u003d this.containerTokenSecretManager\n        .createAndGetSecretKey(nodeId.toString());\n    regResponse.setSecretKey(ByteBuffer.wrap(secretKey.getEncoded()));\n\n    // Check if this node is a \u0027valid\u0027 node\n    if (!this.nodesListManager.isValidNode(host)) {\n      LOG.info(\"Disallowed NodeManager from  \" + host\n          + \", Sending SHUTDOWN signal to the NodeManager.\");\n      regResponse.setNodeAction(NodeAction.SHUTDOWN);\n      response.setRegistrationResponse(regResponse);\n      return response;\n    }\n\n    RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n        resolve(host), capability);\n\n    RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n    if (oldNode \u003d\u003d null) {\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.STARTED));\n    } else {\n      LOG.info(\"Reconnect from the node at: \" + host);\n      this.nmLivelinessMonitor.unregister(nodeId);\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeReconnectEvent(nodeId, rmNode));\n    }\n\n    this.nmLivelinessMonitor.register(nodeId);\n\n    LOG.info(\"NodeManager from node \" + host + \"(cmPort: \" + cmPort\n        + \" httpPort: \" + httpPort + \") \" + \"registered with capability: \"\n        + capability.getMemory() + \", assigned nodeId \" + nodeId);\n\n    regResponse.setNodeAction(NodeAction.NORMAL);\n    response.setRegistrationResponse(regResponse);\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java"
      }
    },
    "c0572656ced07a885f848c1134edd7b1c291d246": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3730. Modified RM to allow restarted NMs to be able to join the cluster without waiting for expiry. Contributed by Jason Lowe.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1293436 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/02/12 1:39 PM",
      "commitName": "c0572656ced07a885f848c1134edd7b1c291d246",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "26/01/12 2:56 PM",
      "commitNameOld": "3cdc100369ce920701fdddae12d7f7247332b3f3",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 28.95,
      "commitsBetweenForRepo": 200,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,50 +1,50 @@\n   public RegisterNodeManagerResponse registerNodeManager(\n       RegisterNodeManagerRequest request) throws YarnRemoteException {\n \n     NodeId nodeId \u003d request.getNodeId();\n     String host \u003d nodeId.getHost();\n     int cmPort \u003d nodeId.getPort();\n     int httpPort \u003d request.getHttpPort();\n     Resource capability \u003d request.getResource();\n \n     RegisterNodeManagerResponse response \u003d recordFactory\n         .newRecordInstance(RegisterNodeManagerResponse.class);\n     RegistrationResponse regResponse \u003d recordFactory\n         .newRecordInstance(RegistrationResponse.class);\n     SecretKey secretKey \u003d this.containerTokenSecretManager\n         .createAndGetSecretKey(nodeId.toString());\n     regResponse.setSecretKey(ByteBuffer.wrap(secretKey.getEncoded()));\n \n     // Check if this node is a \u0027valid\u0027 node\n     if (!this.nodesListManager.isValidNode(host)) {\n       LOG.info(\"Disallowed NodeManager from  \" + host\n           + \", Sending SHUTDOWN signal to the NodeManager.\");\n       regResponse.setNodeAction(NodeAction.SHUTDOWN);\n       response.setRegistrationResponse(regResponse);\n       return response;\n     }\n \n     RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n         resolve(host), capability);\n \n-    if (this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode) !\u003d null) {\n-      LOG.info(\"Duplicate registration from the node at: \" + host\n-          + \", Sending SHUTDOWN Signal to the NodeManager\");\n-      regResponse.setNodeAction(NodeAction.SHUTDOWN);\n-      response.setRegistrationResponse(regResponse);\n-      return response;\n+    RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n+    if (oldNode \u003d\u003d null) {\n+      this.rmContext.getDispatcher().getEventHandler().handle(\n+          new RMNodeEvent(nodeId, RMNodeEventType.STARTED));\n+    } else {\n+      LOG.info(\"Reconnect from the node at: \" + host);\n+      this.nmLivelinessMonitor.unregister(nodeId);\n+      this.rmContext.getDispatcher().getEventHandler().handle(\n+          new RMNodeReconnectEvent(nodeId, rmNode));\n     }\n \n-    this.rmContext.getDispatcher().getEventHandler().handle(\n-        new RMNodeEvent(nodeId, RMNodeEventType.STARTED));\n-\n     this.nmLivelinessMonitor.register(nodeId);\n \n     LOG.info(\"NodeManager from node \" + host + \"(cmPort: \" + cmPort\n         + \" httpPort: \" + httpPort + \") \" + \"registered with capability: \"\n         + capability.getMemory() + \", assigned nodeId \" + nodeId);\n \n     regResponse.setNodeAction(NodeAction.NORMAL);\n     response.setRegistrationResponse(regResponse);\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterNodeManagerResponse registerNodeManager(\n      RegisterNodeManagerRequest request) throws YarnRemoteException {\n\n    NodeId nodeId \u003d request.getNodeId();\n    String host \u003d nodeId.getHost();\n    int cmPort \u003d nodeId.getPort();\n    int httpPort \u003d request.getHttpPort();\n    Resource capability \u003d request.getResource();\n\n    RegisterNodeManagerResponse response \u003d recordFactory\n        .newRecordInstance(RegisterNodeManagerResponse.class);\n    RegistrationResponse regResponse \u003d recordFactory\n        .newRecordInstance(RegistrationResponse.class);\n    SecretKey secretKey \u003d this.containerTokenSecretManager\n        .createAndGetSecretKey(nodeId.toString());\n    regResponse.setSecretKey(ByteBuffer.wrap(secretKey.getEncoded()));\n\n    // Check if this node is a \u0027valid\u0027 node\n    if (!this.nodesListManager.isValidNode(host)) {\n      LOG.info(\"Disallowed NodeManager from  \" + host\n          + \", Sending SHUTDOWN signal to the NodeManager.\");\n      regResponse.setNodeAction(NodeAction.SHUTDOWN);\n      response.setRegistrationResponse(regResponse);\n      return response;\n    }\n\n    RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n        resolve(host), capability);\n\n    RMNode oldNode \u003d this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode);\n    if (oldNode \u003d\u003d null) {\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeEvent(nodeId, RMNodeEventType.STARTED));\n    } else {\n      LOG.info(\"Reconnect from the node at: \" + host);\n      this.nmLivelinessMonitor.unregister(nodeId);\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMNodeReconnectEvent(nodeId, rmNode));\n    }\n\n    this.nmLivelinessMonitor.register(nodeId);\n\n    LOG.info(\"NodeManager from node \" + host + \"(cmPort: \" + cmPort\n        + \" httpPort: \" + httpPort + \") \" + \"registered with capability: \"\n        + capability.getMemory() + \", assigned nodeId \" + nodeId);\n\n    regResponse.setNodeAction(NodeAction.NORMAL);\n    response.setRegistrationResponse(regResponse);\n    return response;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "cbdb07f4ca358b9507296868a913977ad82ed716": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2775. Fixed ResourceManager and NodeManager to force a decommissioned node to shutdown. Contributed by Devaraj K.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1190467 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "28/10/11 10:31 AM",
      "commitName": "cbdb07f4ca358b9507296868a913977ad82ed716",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "25/10/11 7:53 PM",
      "commitNameOld": "29c6c3ed328965a73fe7b68eb29cb30794beef38",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 2.61,
      "commitsBetweenForRepo": 52,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,45 +1,50 @@\n   public RegisterNodeManagerResponse registerNodeManager(\n       RegisterNodeManagerRequest request) throws YarnRemoteException {\n \n     NodeId nodeId \u003d request.getNodeId();\n     String host \u003d nodeId.getHost();\n     int cmPort \u003d nodeId.getPort();\n     int httpPort \u003d request.getHttpPort();\n     Resource capability \u003d request.getResource();\n \n-    try {\n-      // Check if this node is a \u0027valid\u0027 node\n-      if (!this.nodesListManager.isValidNode(host)) {\n-        LOG.info(\"Disallowed NodeManager from  \" + host);\n-        throw new IOException(\"Disallowed NodeManager from  \" + host); \n-      }\n+    RegisterNodeManagerResponse response \u003d recordFactory\n+        .newRecordInstance(RegisterNodeManagerResponse.class);\n+    RegistrationResponse regResponse \u003d recordFactory\n+        .newRecordInstance(RegistrationResponse.class);\n+    SecretKey secretKey \u003d this.containerTokenSecretManager\n+        .createAndGetSecretKey(nodeId.toString());\n+    regResponse.setSecretKey(ByteBuffer.wrap(secretKey.getEncoded()));\n \n-      RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort,\n-          httpPort, resolve(host), capability);\n-\n-      if (this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode) !\u003d null) {\n-        throw new IOException(\"Duplicate registration from the node!\");\n-      }\n-\n-      this.nmLivelinessMonitor.register(nodeId);\n-\n-      LOG.info(\"NodeManager from node \" + host + \n-          \"(cmPort: \" + cmPort + \" httpPort: \" + httpPort + \") \"\n-          + \"registered with capability: \" + capability.getMemory()\n-          + \", assigned nodeId \" + nodeId);\n-\n-      RegistrationResponse regResponse \u003d recordFactory.newRecordInstance(\n-          RegistrationResponse.class);\n-      SecretKey secretKey \u003d this.containerTokenSecretManager\n-          .createAndGetSecretKey(nodeId.toString());\n-      regResponse.setSecretKey(ByteBuffer.wrap(secretKey.getEncoded()));\n-\n-      RegisterNodeManagerResponse response \u003d recordFactory\n-          .newRecordInstance(RegisterNodeManagerResponse.class);\n+    // Check if this node is a \u0027valid\u0027 node\n+    if (!this.nodesListManager.isValidNode(host)) {\n+      LOG.info(\"Disallowed NodeManager from  \" + host\n+          + \", Sending SHUTDOWN signal to the NodeManager.\");\n+      regResponse.setNodeAction(NodeAction.SHUTDOWN);\n       response.setRegistrationResponse(regResponse);\n       return response;\n-    } catch (IOException ioe) {\n-      LOG.info(\"Exception in node registration from \" + nodeId.getHost(), ioe);\n-      throw RPCUtil.getRemoteException(ioe);\n     }\n+\n+    RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n+        resolve(host), capability);\n+\n+    if (this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode) !\u003d null) {\n+      LOG.info(\"Duplicate registration from the node at: \" + host\n+          + \", Sending SHUTDOWN Signal to the NodeManager\");\n+      regResponse.setNodeAction(NodeAction.SHUTDOWN);\n+      response.setRegistrationResponse(regResponse);\n+      return response;\n+    }\n+\n+    this.rmContext.getDispatcher().getEventHandler().handle(\n+        new RMNodeEvent(nodeId, RMNodeEventType.STARTED));\n+\n+    this.nmLivelinessMonitor.register(nodeId);\n+\n+    LOG.info(\"NodeManager from node \" + host + \"(cmPort: \" + cmPort\n+        + \" httpPort: \" + httpPort + \") \" + \"registered with capability: \"\n+        + capability.getMemory() + \", assigned nodeId \" + nodeId);\n+\n+    regResponse.setNodeAction(NodeAction.NORMAL);\n+    response.setRegistrationResponse(regResponse);\n+    return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterNodeManagerResponse registerNodeManager(\n      RegisterNodeManagerRequest request) throws YarnRemoteException {\n\n    NodeId nodeId \u003d request.getNodeId();\n    String host \u003d nodeId.getHost();\n    int cmPort \u003d nodeId.getPort();\n    int httpPort \u003d request.getHttpPort();\n    Resource capability \u003d request.getResource();\n\n    RegisterNodeManagerResponse response \u003d recordFactory\n        .newRecordInstance(RegisterNodeManagerResponse.class);\n    RegistrationResponse regResponse \u003d recordFactory\n        .newRecordInstance(RegistrationResponse.class);\n    SecretKey secretKey \u003d this.containerTokenSecretManager\n        .createAndGetSecretKey(nodeId.toString());\n    regResponse.setSecretKey(ByteBuffer.wrap(secretKey.getEncoded()));\n\n    // Check if this node is a \u0027valid\u0027 node\n    if (!this.nodesListManager.isValidNode(host)) {\n      LOG.info(\"Disallowed NodeManager from  \" + host\n          + \", Sending SHUTDOWN signal to the NodeManager.\");\n      regResponse.setNodeAction(NodeAction.SHUTDOWN);\n      response.setRegistrationResponse(regResponse);\n      return response;\n    }\n\n    RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort, httpPort,\n        resolve(host), capability);\n\n    if (this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode) !\u003d null) {\n      LOG.info(\"Duplicate registration from the node at: \" + host\n          + \", Sending SHUTDOWN Signal to the NodeManager\");\n      regResponse.setNodeAction(NodeAction.SHUTDOWN);\n      response.setRegistrationResponse(regResponse);\n      return response;\n    }\n\n    this.rmContext.getDispatcher().getEventHandler().handle(\n        new RMNodeEvent(nodeId, RMNodeEventType.STARTED));\n\n    this.nmLivelinessMonitor.register(nodeId);\n\n    LOG.info(\"NodeManager from node \" + host + \"(cmPort: \" + cmPort\n        + \" httpPort: \" + httpPort + \") \" + \"registered with capability: \"\n        + capability.getMemory() + \", assigned nodeId \" + nodeId);\n\n    regResponse.setNodeAction(NodeAction.NORMAL);\n    response.setRegistrationResponse(regResponse);\n    return response;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public RegisterNodeManagerResponse registerNodeManager(\n      RegisterNodeManagerRequest request) throws YarnRemoteException {\n\n    NodeId nodeId \u003d request.getNodeId();\n    String host \u003d nodeId.getHost();\n    int cmPort \u003d nodeId.getPort();\n    int httpPort \u003d request.getHttpPort();\n    Resource capability \u003d request.getResource();\n\n    try {\n      // Check if this node is a \u0027valid\u0027 node\n      if (!this.nodesListManager.isValidNode(host)) {\n        LOG.info(\"Disallowed NodeManager from  \" + host);\n        throw new IOException(\"Disallowed NodeManager from  \" + host); \n      }\n\n      RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort,\n          httpPort, resolve(host), capability);\n\n      if (this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode) !\u003d null) {\n        throw new IOException(\"Duplicate registration from the node!\");\n      }\n\n      this.nmLivelinessMonitor.register(nodeId);\n\n      LOG.info(\"NodeManager from node \" + host + \n          \"(cmPort: \" + cmPort + \" httpPort: \" + httpPort + \") \"\n          + \"registered with capability: \" + capability.getMemory()\n          + \", assigned nodeId \" + nodeId);\n\n      RegistrationResponse regResponse \u003d recordFactory.newRecordInstance(\n          RegistrationResponse.class);\n      SecretKey secretKey \u003d this.containerTokenSecretManager\n          .createAndGetSecretKey(nodeId.toString());\n      regResponse.setSecretKey(ByteBuffer.wrap(secretKey.getEncoded()));\n\n      RegisterNodeManagerResponse response \u003d recordFactory\n          .newRecordInstance(RegisterNodeManagerResponse.class);\n      response.setRegistrationResponse(regResponse);\n      return response;\n    } catch (IOException ioe) {\n      LOG.info(\"Exception in node registration from \" + nodeId.getHost(), ioe);\n      throw RPCUtil.getRemoteException(ioe);\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java",
        "newPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java"
      }
    },
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-279. MapReduce 2.0. Merging MR-279 branch into trunk. Contributed by Arun C Murthy, Christopher Douglas, Devaraj Das, Greg Roelofs, Jeffrey Naisbitt, Josh Wills, Jonathan Eagles, Krishna Ramachandran, Luke Lu, Mahadev Konar, Robert Evans, Sharad Agarwal, Siddharth Seth, Thomas Graves, and Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159166 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/08/11 4:07 AM",
      "commitName": "dbecbe5dfe50f834fc3b8401709079e9470cc517",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,45 @@\n+  public RegisterNodeManagerResponse registerNodeManager(\n+      RegisterNodeManagerRequest request) throws YarnRemoteException {\n+\n+    NodeId nodeId \u003d request.getNodeId();\n+    String host \u003d nodeId.getHost();\n+    int cmPort \u003d nodeId.getPort();\n+    int httpPort \u003d request.getHttpPort();\n+    Resource capability \u003d request.getResource();\n+\n+    try {\n+      // Check if this node is a \u0027valid\u0027 node\n+      if (!this.nodesListManager.isValidNode(host)) {\n+        LOG.info(\"Disallowed NodeManager from  \" + host);\n+        throw new IOException(\"Disallowed NodeManager from  \" + host); \n+      }\n+\n+      RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort,\n+          httpPort, resolve(host), capability);\n+\n+      if (this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode) !\u003d null) {\n+        throw new IOException(\"Duplicate registration from the node!\");\n+      }\n+\n+      this.nmLivelinessMonitor.register(nodeId);\n+\n+      LOG.info(\"NodeManager from node \" + host + \n+          \"(cmPort: \" + cmPort + \" httpPort: \" + httpPort + \") \"\n+          + \"registered with capability: \" + capability.getMemory()\n+          + \", assigned nodeId \" + nodeId);\n+\n+      RegistrationResponse regResponse \u003d recordFactory.newRecordInstance(\n+          RegistrationResponse.class);\n+      SecretKey secretKey \u003d this.containerTokenSecretManager\n+          .createAndGetSecretKey(nodeId.toString());\n+      regResponse.setSecretKey(ByteBuffer.wrap(secretKey.getEncoded()));\n+\n+      RegisterNodeManagerResponse response \u003d recordFactory\n+          .newRecordInstance(RegisterNodeManagerResponse.class);\n+      response.setRegistrationResponse(regResponse);\n+      return response;\n+    } catch (IOException ioe) {\n+      LOG.info(\"Exception in node registration from \" + nodeId.getHost(), ioe);\n+      throw RPCUtil.getRemoteException(ioe);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public RegisterNodeManagerResponse registerNodeManager(\n      RegisterNodeManagerRequest request) throws YarnRemoteException {\n\n    NodeId nodeId \u003d request.getNodeId();\n    String host \u003d nodeId.getHost();\n    int cmPort \u003d nodeId.getPort();\n    int httpPort \u003d request.getHttpPort();\n    Resource capability \u003d request.getResource();\n\n    try {\n      // Check if this node is a \u0027valid\u0027 node\n      if (!this.nodesListManager.isValidNode(host)) {\n        LOG.info(\"Disallowed NodeManager from  \" + host);\n        throw new IOException(\"Disallowed NodeManager from  \" + host); \n      }\n\n      RMNode rmNode \u003d new RMNodeImpl(nodeId, rmContext, host, cmPort,\n          httpPort, resolve(host), capability);\n\n      if (this.rmContext.getRMNodes().putIfAbsent(nodeId, rmNode) !\u003d null) {\n        throw new IOException(\"Duplicate registration from the node!\");\n      }\n\n      this.nmLivelinessMonitor.register(nodeId);\n\n      LOG.info(\"NodeManager from node \" + host + \n          \"(cmPort: \" + cmPort + \" httpPort: \" + httpPort + \") \"\n          + \"registered with capability: \" + capability.getMemory()\n          + \", assigned nodeId \" + nodeId);\n\n      RegistrationResponse regResponse \u003d recordFactory.newRecordInstance(\n          RegistrationResponse.class);\n      SecretKey secretKey \u003d this.containerTokenSecretManager\n          .createAndGetSecretKey(nodeId.toString());\n      regResponse.setSecretKey(ByteBuffer.wrap(secretKey.getEncoded()));\n\n      RegisterNodeManagerResponse response \u003d recordFactory\n          .newRecordInstance(RegisterNodeManagerResponse.class);\n      response.setRegistrationResponse(regResponse);\n      return response;\n    } catch (IOException ioe) {\n      LOG.info(\"Exception in node registration from \" + nodeId.getHost(), ioe);\n      throw RPCUtil.getRemoteException(ioe);\n    }\n  }",
      "path": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/ResourceTrackerService.java"
    }
  }
}