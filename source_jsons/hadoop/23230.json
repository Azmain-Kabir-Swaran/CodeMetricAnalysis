{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "KeyFieldBasedComparator.java",
  "functionName": "numericalCompare",
  "functionId": "numericalCompare___a-byte[]__start1-int__end1-int__b-byte[]__start2-int__end2-int",
  "sourceFilePath": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapreduce/lib/partition/KeyFieldBasedComparator.java",
  "functionStartLine": 140,
  "functionEndLine": 226,
  "numCommitsSeen": 4,
  "timeTaken": 4346,
  "changeHistory": [
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc"
  ],
  "changeHistoryShort": {
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": "Yfilerename",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yintroduced"
  },
  "changeHistoryDetails": {
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private int numericalCompare (byte[] a, int start1, int end1, \n      byte[] b, int start2, int end2) {\n    int i \u003d start1;\n    int j \u003d start2;\n    int mul \u003d 1;\n    byte first_a \u003d a[i];\n    byte first_b \u003d b[j];\n    if (first_a \u003d\u003d NEGATIVE) {\n      if (first_b !\u003d NEGATIVE) {\n        //check for cases like -0.0 and 0.0 (they should be declared equal)\n        return oneNegativeCompare(a, start1 + 1, end1, b, start2, end2);\n      }\n      i++;\n    }\n    if (first_b \u003d\u003d NEGATIVE) {\n      if (first_a !\u003d NEGATIVE) {\n        //check for cases like 0.0 and -0.0 (they should be declared equal)\n        return -oneNegativeCompare(b, start2+1, end2, a, start1, end1);\n      }\n      j++;\n    }\n    if (first_b \u003d\u003d NEGATIVE \u0026\u0026 first_a \u003d\u003d NEGATIVE) {\n      mul \u003d -1;\n    }\n\n    //skip over ZEROs\n    while (i \u003c\u003d end1) {\n      if (a[i] !\u003d ZERO) {\n        break;\n      }\n      i++;\n    }\n    while (j \u003c\u003d end2) {\n      if (b[j] !\u003d ZERO) {\n        break;\n      }\n      j++;\n    }\n    \n    //skip over equal characters and stopping at the first nondigit char\n    //The nondigit character could be \u0027.\u0027\n    while (i \u003c\u003d end1 \u0026\u0026 j \u003c\u003d end2) {\n      if (!isdigit(a[i]) || a[i] !\u003d b[j]) {\n        break;\n      }\n      i++; j++;\n    }\n    if (i \u003c\u003d end1) {\n      first_a \u003d a[i];\n    }\n    if (j \u003c\u003d end2) {\n      first_b \u003d b[j];\n    }\n    //store the result of the difference. This could be final result if the\n    //number of digits in the mantissa is the same in both the numbers \n    int firstResult \u003d first_a - first_b;\n    \n    //check whether we hit a decimal in the earlier scan\n    if ((first_a \u003d\u003d DECIMAL \u0026\u0026 (!isdigit(first_b) || j \u003e end2)) ||\n            (first_b \u003d\u003d DECIMAL \u0026\u0026 (!isdigit(first_a) || i \u003e end1))) {\n      return ((mul \u003c 0) ? -decimalCompare(a, i, end1, b, j, end2) : \n        decimalCompare(a, i, end1, b, j, end2));\n    }\n    //check the number of digits in the mantissa of the numbers\n    int numRemainDigits_a \u003d 0;\n    int numRemainDigits_b \u003d 0;\n    while (i \u003c\u003d end1) {\n      //if we encounter a non-digit treat the corresponding number as being \n      //smaller      \n      if (isdigit(a[i++])) {\n        numRemainDigits_a++;\n      } else break;\n    }\n    while (j \u003c\u003d end2) {\n      //if we encounter a non-digit treat the corresponding number as being \n      //smaller\n      if (isdigit(b[j++])) {\n        numRemainDigits_b++;\n      } else break;\n    }\n    int ret \u003d numRemainDigits_a - numRemainDigits_b;\n    if (ret \u003d\u003d 0) { \n      return ((mul \u003c 0) ? -firstResult : firstResult);\n    } else {\n      return ((mul \u003c 0) ? -ret : ret);\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapreduce/lib/partition/KeyFieldBasedComparator.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce/hadoop-mr-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapreduce/lib/partition/KeyFieldBasedComparator.java",
        "newPath": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapreduce/lib/partition/KeyFieldBasedComparator.java"
      }
    },
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": {
      "type": "Yfilerename",
      "commitMessage": "MAPREDUCE-279. MapReduce 2.0. Merging MR-279 branch into trunk. Contributed by Arun C Murthy, Christopher Douglas, Devaraj Das, Greg Roelofs, Jeffrey Naisbitt, Josh Wills, Jonathan Eagles, Krishna Ramachandran, Luke Lu, Mahadev Konar, Robert Evans, Sharad Agarwal, Siddharth Seth, Thomas Graves, and Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159166 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/08/11 4:07 AM",
      "commitName": "dbecbe5dfe50f834fc3b8401709079e9470cc517",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "17/08/11 8:02 PM",
      "commitNameOld": "dd86860633d2ed64705b669a75bf318442ed6225",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 0.34,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private int numericalCompare (byte[] a, int start1, int end1, \n      byte[] b, int start2, int end2) {\n    int i \u003d start1;\n    int j \u003d start2;\n    int mul \u003d 1;\n    byte first_a \u003d a[i];\n    byte first_b \u003d b[j];\n    if (first_a \u003d\u003d NEGATIVE) {\n      if (first_b !\u003d NEGATIVE) {\n        //check for cases like -0.0 and 0.0 (they should be declared equal)\n        return oneNegativeCompare(a, start1 + 1, end1, b, start2, end2);\n      }\n      i++;\n    }\n    if (first_b \u003d\u003d NEGATIVE) {\n      if (first_a !\u003d NEGATIVE) {\n        //check for cases like 0.0 and -0.0 (they should be declared equal)\n        return -oneNegativeCompare(b, start2+1, end2, a, start1, end1);\n      }\n      j++;\n    }\n    if (first_b \u003d\u003d NEGATIVE \u0026\u0026 first_a \u003d\u003d NEGATIVE) {\n      mul \u003d -1;\n    }\n\n    //skip over ZEROs\n    while (i \u003c\u003d end1) {\n      if (a[i] !\u003d ZERO) {\n        break;\n      }\n      i++;\n    }\n    while (j \u003c\u003d end2) {\n      if (b[j] !\u003d ZERO) {\n        break;\n      }\n      j++;\n    }\n    \n    //skip over equal characters and stopping at the first nondigit char\n    //The nondigit character could be \u0027.\u0027\n    while (i \u003c\u003d end1 \u0026\u0026 j \u003c\u003d end2) {\n      if (!isdigit(a[i]) || a[i] !\u003d b[j]) {\n        break;\n      }\n      i++; j++;\n    }\n    if (i \u003c\u003d end1) {\n      first_a \u003d a[i];\n    }\n    if (j \u003c\u003d end2) {\n      first_b \u003d b[j];\n    }\n    //store the result of the difference. This could be final result if the\n    //number of digits in the mantissa is the same in both the numbers \n    int firstResult \u003d first_a - first_b;\n    \n    //check whether we hit a decimal in the earlier scan\n    if ((first_a \u003d\u003d DECIMAL \u0026\u0026 (!isdigit(first_b) || j \u003e end2)) ||\n            (first_b \u003d\u003d DECIMAL \u0026\u0026 (!isdigit(first_a) || i \u003e end1))) {\n      return ((mul \u003c 0) ? -decimalCompare(a, i, end1, b, j, end2) : \n        decimalCompare(a, i, end1, b, j, end2));\n    }\n    //check the number of digits in the mantissa of the numbers\n    int numRemainDigits_a \u003d 0;\n    int numRemainDigits_b \u003d 0;\n    while (i \u003c\u003d end1) {\n      //if we encounter a non-digit treat the corresponding number as being \n      //smaller      \n      if (isdigit(a[i++])) {\n        numRemainDigits_a++;\n      } else break;\n    }\n    while (j \u003c\u003d end2) {\n      //if we encounter a non-digit treat the corresponding number as being \n      //smaller\n      if (isdigit(b[j++])) {\n        numRemainDigits_b++;\n      } else break;\n    }\n    int ret \u003d numRemainDigits_a - numRemainDigits_b;\n    if (ret \u003d\u003d 0) { \n      return ((mul \u003c 0) ? -firstResult : firstResult);\n    } else {\n      return ((mul \u003c 0) ? -ret : ret);\n    }\n  }",
      "path": "hadoop-mapreduce/hadoop-mr-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapreduce/lib/partition/KeyFieldBasedComparator.java",
      "extendedDetails": {
        "oldPath": "mapreduce/src/java/org/apache/hadoop/mapreduce/lib/partition/KeyFieldBasedComparator.java",
        "newPath": "hadoop-mapreduce/hadoop-mr-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapreduce/lib/partition/KeyFieldBasedComparator.java"
      }
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "diff": "@@ -0,0 +1,87 @@\n+  private int numericalCompare (byte[] a, int start1, int end1, \n+      byte[] b, int start2, int end2) {\n+    int i \u003d start1;\n+    int j \u003d start2;\n+    int mul \u003d 1;\n+    byte first_a \u003d a[i];\n+    byte first_b \u003d b[j];\n+    if (first_a \u003d\u003d NEGATIVE) {\n+      if (first_b !\u003d NEGATIVE) {\n+        //check for cases like -0.0 and 0.0 (they should be declared equal)\n+        return oneNegativeCompare(a, start1 + 1, end1, b, start2, end2);\n+      }\n+      i++;\n+    }\n+    if (first_b \u003d\u003d NEGATIVE) {\n+      if (first_a !\u003d NEGATIVE) {\n+        //check for cases like 0.0 and -0.0 (they should be declared equal)\n+        return -oneNegativeCompare(b, start2+1, end2, a, start1, end1);\n+      }\n+      j++;\n+    }\n+    if (first_b \u003d\u003d NEGATIVE \u0026\u0026 first_a \u003d\u003d NEGATIVE) {\n+      mul \u003d -1;\n+    }\n+\n+    //skip over ZEROs\n+    while (i \u003c\u003d end1) {\n+      if (a[i] !\u003d ZERO) {\n+        break;\n+      }\n+      i++;\n+    }\n+    while (j \u003c\u003d end2) {\n+      if (b[j] !\u003d ZERO) {\n+        break;\n+      }\n+      j++;\n+    }\n+    \n+    //skip over equal characters and stopping at the first nondigit char\n+    //The nondigit character could be \u0027.\u0027\n+    while (i \u003c\u003d end1 \u0026\u0026 j \u003c\u003d end2) {\n+      if (!isdigit(a[i]) || a[i] !\u003d b[j]) {\n+        break;\n+      }\n+      i++; j++;\n+    }\n+    if (i \u003c\u003d end1) {\n+      first_a \u003d a[i];\n+    }\n+    if (j \u003c\u003d end2) {\n+      first_b \u003d b[j];\n+    }\n+    //store the result of the difference. This could be final result if the\n+    //number of digits in the mantissa is the same in both the numbers \n+    int firstResult \u003d first_a - first_b;\n+    \n+    //check whether we hit a decimal in the earlier scan\n+    if ((first_a \u003d\u003d DECIMAL \u0026\u0026 (!isdigit(first_b) || j \u003e end2)) ||\n+            (first_b \u003d\u003d DECIMAL \u0026\u0026 (!isdigit(first_a) || i \u003e end1))) {\n+      return ((mul \u003c 0) ? -decimalCompare(a, i, end1, b, j, end2) : \n+        decimalCompare(a, i, end1, b, j, end2));\n+    }\n+    //check the number of digits in the mantissa of the numbers\n+    int numRemainDigits_a \u003d 0;\n+    int numRemainDigits_b \u003d 0;\n+    while (i \u003c\u003d end1) {\n+      //if we encounter a non-digit treat the corresponding number as being \n+      //smaller      \n+      if (isdigit(a[i++])) {\n+        numRemainDigits_a++;\n+      } else break;\n+    }\n+    while (j \u003c\u003d end2) {\n+      //if we encounter a non-digit treat the corresponding number as being \n+      //smaller\n+      if (isdigit(b[j++])) {\n+        numRemainDigits_b++;\n+      } else break;\n+    }\n+    int ret \u003d numRemainDigits_a - numRemainDigits_b;\n+    if (ret \u003d\u003d 0) { \n+      return ((mul \u003c 0) ? -firstResult : firstResult);\n+    } else {\n+      return ((mul \u003c 0) ? -ret : ret);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private int numericalCompare (byte[] a, int start1, int end1, \n      byte[] b, int start2, int end2) {\n    int i \u003d start1;\n    int j \u003d start2;\n    int mul \u003d 1;\n    byte first_a \u003d a[i];\n    byte first_b \u003d b[j];\n    if (first_a \u003d\u003d NEGATIVE) {\n      if (first_b !\u003d NEGATIVE) {\n        //check for cases like -0.0 and 0.0 (they should be declared equal)\n        return oneNegativeCompare(a, start1 + 1, end1, b, start2, end2);\n      }\n      i++;\n    }\n    if (first_b \u003d\u003d NEGATIVE) {\n      if (first_a !\u003d NEGATIVE) {\n        //check for cases like 0.0 and -0.0 (they should be declared equal)\n        return -oneNegativeCompare(b, start2+1, end2, a, start1, end1);\n      }\n      j++;\n    }\n    if (first_b \u003d\u003d NEGATIVE \u0026\u0026 first_a \u003d\u003d NEGATIVE) {\n      mul \u003d -1;\n    }\n\n    //skip over ZEROs\n    while (i \u003c\u003d end1) {\n      if (a[i] !\u003d ZERO) {\n        break;\n      }\n      i++;\n    }\n    while (j \u003c\u003d end2) {\n      if (b[j] !\u003d ZERO) {\n        break;\n      }\n      j++;\n    }\n    \n    //skip over equal characters and stopping at the first nondigit char\n    //The nondigit character could be \u0027.\u0027\n    while (i \u003c\u003d end1 \u0026\u0026 j \u003c\u003d end2) {\n      if (!isdigit(a[i]) || a[i] !\u003d b[j]) {\n        break;\n      }\n      i++; j++;\n    }\n    if (i \u003c\u003d end1) {\n      first_a \u003d a[i];\n    }\n    if (j \u003c\u003d end2) {\n      first_b \u003d b[j];\n    }\n    //store the result of the difference. This could be final result if the\n    //number of digits in the mantissa is the same in both the numbers \n    int firstResult \u003d first_a - first_b;\n    \n    //check whether we hit a decimal in the earlier scan\n    if ((first_a \u003d\u003d DECIMAL \u0026\u0026 (!isdigit(first_b) || j \u003e end2)) ||\n            (first_b \u003d\u003d DECIMAL \u0026\u0026 (!isdigit(first_a) || i \u003e end1))) {\n      return ((mul \u003c 0) ? -decimalCompare(a, i, end1, b, j, end2) : \n        decimalCompare(a, i, end1, b, j, end2));\n    }\n    //check the number of digits in the mantissa of the numbers\n    int numRemainDigits_a \u003d 0;\n    int numRemainDigits_b \u003d 0;\n    while (i \u003c\u003d end1) {\n      //if we encounter a non-digit treat the corresponding number as being \n      //smaller      \n      if (isdigit(a[i++])) {\n        numRemainDigits_a++;\n      } else break;\n    }\n    while (j \u003c\u003d end2) {\n      //if we encounter a non-digit treat the corresponding number as being \n      //smaller\n      if (isdigit(b[j++])) {\n        numRemainDigits_b++;\n      } else break;\n    }\n    int ret \u003d numRemainDigits_a - numRemainDigits_b;\n    if (ret \u003d\u003d 0) { \n      return ((mul \u003c 0) ? -firstResult : firstResult);\n    } else {\n      return ((mul \u003c 0) ? -ret : ret);\n    }\n  }",
      "path": "mapreduce/src/java/org/apache/hadoop/mapreduce/lib/partition/KeyFieldBasedComparator.java"
    }
  }
}