{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "RMWebServices.java",
  "functionName": "getNodes",
  "functionId": "getNodes___states-String(annotations-@QueryParam(RMWSConsts.STATES))",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/webapp/RMWebServices.java",
  "functionStartLine": 443,
  "functionEndLine": 474,
  "numCommitsSeen": 120,
  "timeTaken": 6971,
  "changeHistory": [
    "604b2489a9e168a0fd702343f6f8844df9e86d17",
    "d76fbbc9b82e720d7d5188f9ae2f56a8d78f3a98",
    "547cb53e8ae2f19b55f9de7670b91b009d8f3bdd",
    "d1c6accb6f87b08975175580e15f1ff1fe29ab04",
    "9cedad11d8d2197a54732667a15344983de5c437",
    "946456c6d88780abe0251b098dd771e9e1e93ab3",
    "5e4f6ad1d9aa6df96af837600674af4467c1e99c",
    "0b0be8d4dd88738dd213763742fc8eccba68531f",
    "af8514eef297574240652672d048748100c97733",
    "e1fdf62123625e4ba399af02f8aad500637d29d1",
    "407cfa3b56a0645d64d2d9af305f6ef24307e775",
    "e7583d816a69677bbaa4280deb58ea73dbc42cef",
    "3343494d6c39883485d29c7439831ab3c1c7248d",
    "3cdc100369ce920701fdddae12d7f7247332b3f3",
    "0ea8570be578be60e2f32849900a1c50506d78d3"
  ],
  "changeHistoryShort": {
    "604b2489a9e168a0fd702343f6f8844df9e86d17": "Ybodychange",
    "d76fbbc9b82e720d7d5188f9ae2f56a8d78f3a98": "Ybodychange",
    "547cb53e8ae2f19b55f9de7670b91b009d8f3bdd": "Ymultichange(Ybodychange,Yparametermetachange)",
    "d1c6accb6f87b08975175580e15f1ff1fe29ab04": "Ybodychange",
    "9cedad11d8d2197a54732667a15344983de5c437": "Ybodychange",
    "946456c6d88780abe0251b098dd771e9e1e93ab3": "Ybodychange",
    "5e4f6ad1d9aa6df96af837600674af4467c1e99c": "Ymultichange(Yparameterchange,Ybodychange)",
    "0b0be8d4dd88738dd213763742fc8eccba68531f": "Ymultichange(Yparameterchange,Ybodychange)",
    "af8514eef297574240652672d048748100c97733": "Ybodychange",
    "e1fdf62123625e4ba399af02f8aad500637d29d1": "Yfilerename",
    "407cfa3b56a0645d64d2d9af305f6ef24307e775": "Ybodychange",
    "e7583d816a69677bbaa4280deb58ea73dbc42cef": "Ybodychange",
    "3343494d6c39883485d29c7439831ab3c1c7248d": "Ybodychange",
    "3cdc100369ce920701fdddae12d7f7247332b3f3": "Ybodychange",
    "0ea8570be578be60e2f32849900a1c50506d78d3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "604b2489a9e168a0fd702343f6f8844df9e86d17": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9206. RMServerUtils does not count SHUTDOWN as an accepted state. Contributed by Kuhu Shukla.\n",
      "commitDate": "03/02/19 11:18 PM",
      "commitName": "604b2489a9e168a0fd702343f6f8844df9e86d17",
      "commitAuthor": "Sunil G",
      "commitDateOld": "09/08/18 8:46 AM",
      "commitNameOld": "d352f167ebb865a6486afbbdac8e2a5e97a7bbad",
      "commitAuthorOld": "Weiwei Yang",
      "daysBetweenCommits": 178.65,
      "commitsBetweenForRepo": 1433,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,32 @@\n   public NodesInfo getNodes(@QueryParam(RMWSConsts.STATES) String states) {\n     initForReadableEndpoints();\n \n     ResourceScheduler sched \u003d this.rm.getResourceScheduler();\n     if (sched \u003d\u003d null) {\n       throw new NotFoundException(\"Null ResourceScheduler instance\");\n     }\n \n     EnumSet\u003cNodeState\u003e acceptedStates;\n     if (states \u003d\u003d null) {\n       acceptedStates \u003d EnumSet.allOf(NodeState.class);\n     } else {\n       acceptedStates \u003d EnumSet.noneOf(NodeState.class);\n       for (String stateStr : states.split(\",\")) {\n         acceptedStates\n             .add(NodeState.valueOf(StringUtils.toUpperCase(stateStr)));\n       }\n     }\n \n     Collection\u003cRMNode\u003e rmNodes \u003d\n         RMServerUtils.queryRMNodes(this.rm.getRMContext(), acceptedStates);\n     NodesInfo nodesInfo \u003d new NodesInfo();\n     for (RMNode rmNode : rmNodes) {\n       NodeInfo nodeInfo \u003d new NodeInfo(rmNode, sched);\n-      if (EnumSet\n-          .of(NodeState.LOST, NodeState.DECOMMISSIONED, NodeState.REBOOTED)\n-          .contains(rmNode.getState())) {\n+      if (rmNode.getState().isInactiveState()) {\n         nodeInfo.setNodeHTTPAddress(RMWSConsts.EMPTY);\n       }\n       nodesInfo.add(nodeInfo);\n     }\n \n     return nodesInfo;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public NodesInfo getNodes(@QueryParam(RMWSConsts.STATES) String states) {\n    initForReadableEndpoints();\n\n    ResourceScheduler sched \u003d this.rm.getResourceScheduler();\n    if (sched \u003d\u003d null) {\n      throw new NotFoundException(\"Null ResourceScheduler instance\");\n    }\n\n    EnumSet\u003cNodeState\u003e acceptedStates;\n    if (states \u003d\u003d null) {\n      acceptedStates \u003d EnumSet.allOf(NodeState.class);\n    } else {\n      acceptedStates \u003d EnumSet.noneOf(NodeState.class);\n      for (String stateStr : states.split(\",\")) {\n        acceptedStates\n            .add(NodeState.valueOf(StringUtils.toUpperCase(stateStr)));\n      }\n    }\n\n    Collection\u003cRMNode\u003e rmNodes \u003d\n        RMServerUtils.queryRMNodes(this.rm.getRMContext(), acceptedStates);\n    NodesInfo nodesInfo \u003d new NodesInfo();\n    for (RMNode rmNode : rmNodes) {\n      NodeInfo nodeInfo \u003d new NodeInfo(rmNode, sched);\n      if (rmNode.getState().isInactiveState()) {\n        nodeInfo.setNodeHTTPAddress(RMWSConsts.EMPTY);\n      }\n      nodesInfo.add(nodeInfo);\n    }\n\n    return nodesInfo;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/webapp/RMWebServices.java",
      "extendedDetails": {}
    },
    "d76fbbc9b82e720d7d5188f9ae2f56a8d78f3a98": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8249. Fixed few REST APIs in RMWebServices to have static-user check. Contributed by Sunil Govindan.\n",
      "commitDate": "10/05/18 7:05 PM",
      "commitName": "d76fbbc9b82e720d7d5188f9ae2f56a8d78f3a98",
      "commitAuthor": "Vinod Kumar Vavilapalli (I am also known as @tshooter.)",
      "commitDateOld": "27/04/18 10:28 AM",
      "commitNameOld": "ef3ecc308dbea41c6a88bd4d16739c7bbc10cdda",
      "commitAuthorOld": "Rohith Sharma K S",
      "daysBetweenCommits": 13.36,
      "commitsBetweenForRepo": 87,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,33 +1,34 @@\n   public NodesInfo getNodes(@QueryParam(RMWSConsts.STATES) String states) {\n-    init();\n+    initForReadableEndpoints();\n+\n     ResourceScheduler sched \u003d this.rm.getResourceScheduler();\n     if (sched \u003d\u003d null) {\n       throw new NotFoundException(\"Null ResourceScheduler instance\");\n     }\n \n     EnumSet\u003cNodeState\u003e acceptedStates;\n     if (states \u003d\u003d null) {\n       acceptedStates \u003d EnumSet.allOf(NodeState.class);\n     } else {\n       acceptedStates \u003d EnumSet.noneOf(NodeState.class);\n       for (String stateStr : states.split(\",\")) {\n         acceptedStates\n             .add(NodeState.valueOf(StringUtils.toUpperCase(stateStr)));\n       }\n     }\n \n     Collection\u003cRMNode\u003e rmNodes \u003d\n         RMServerUtils.queryRMNodes(this.rm.getRMContext(), acceptedStates);\n     NodesInfo nodesInfo \u003d new NodesInfo();\n     for (RMNode rmNode : rmNodes) {\n       NodeInfo nodeInfo \u003d new NodeInfo(rmNode, sched);\n       if (EnumSet\n           .of(NodeState.LOST, NodeState.DECOMMISSIONED, NodeState.REBOOTED)\n           .contains(rmNode.getState())) {\n         nodeInfo.setNodeHTTPAddress(RMWSConsts.EMPTY);\n       }\n       nodesInfo.add(nodeInfo);\n     }\n \n     return nodesInfo;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public NodesInfo getNodes(@QueryParam(RMWSConsts.STATES) String states) {\n    initForReadableEndpoints();\n\n    ResourceScheduler sched \u003d this.rm.getResourceScheduler();\n    if (sched \u003d\u003d null) {\n      throw new NotFoundException(\"Null ResourceScheduler instance\");\n    }\n\n    EnumSet\u003cNodeState\u003e acceptedStates;\n    if (states \u003d\u003d null) {\n      acceptedStates \u003d EnumSet.allOf(NodeState.class);\n    } else {\n      acceptedStates \u003d EnumSet.noneOf(NodeState.class);\n      for (String stateStr : states.split(\",\")) {\n        acceptedStates\n            .add(NodeState.valueOf(StringUtils.toUpperCase(stateStr)));\n      }\n    }\n\n    Collection\u003cRMNode\u003e rmNodes \u003d\n        RMServerUtils.queryRMNodes(this.rm.getRMContext(), acceptedStates);\n    NodesInfo nodesInfo \u003d new NodesInfo();\n    for (RMNode rmNode : rmNodes) {\n      NodeInfo nodeInfo \u003d new NodeInfo(rmNode, sched);\n      if (EnumSet\n          .of(NodeState.LOST, NodeState.DECOMMISSIONED, NodeState.REBOOTED)\n          .contains(rmNode.getState())) {\n        nodeInfo.setNodeHTTPAddress(RMWSConsts.EMPTY);\n      }\n      nodesInfo.add(nodeInfo);\n    }\n\n    return nodesInfo;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/webapp/RMWebServices.java",
      "extendedDetails": {}
    },
    "547cb53e8ae2f19b55f9de7670b91b009d8f3bdd": {
      "type": "Ymultichange(Ybodychange,Yparametermetachange)",
      "commitMessage": "YARN-6634. [API] Refactor ResourceManager WebServices to make API explicit. (Giovanni Matteo Fumarola via curino)\n",
      "commitDate": "07/06/17 1:41 PM",
      "commitName": "547cb53e8ae2f19b55f9de7670b91b009d8f3bdd",
      "commitAuthor": "Carlo Curino",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-6634. [API] Refactor ResourceManager WebServices to make API explicit. (Giovanni Matteo Fumarola via curino)\n",
          "commitDate": "07/06/17 1:41 PM",
          "commitName": "547cb53e8ae2f19b55f9de7670b91b009d8f3bdd",
          "commitAuthor": "Carlo Curino",
          "commitDateOld": "08/12/16 2:23 AM",
          "commitNameOld": "74d0066d3392169bec872f438a0818e2f5323010",
          "commitAuthorOld": "Sunil G",
          "daysBetweenCommits": 181.43,
          "commitsBetweenForRepo": 954,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,32 +1,33 @@\n-  public NodesInfo getNodes(@QueryParam(\"states\") String states) {\n+  public NodesInfo getNodes(@QueryParam(RMWSConsts.STATES) String states) {\n     init();\n     ResourceScheduler sched \u003d this.rm.getResourceScheduler();\n     if (sched \u003d\u003d null) {\n       throw new NotFoundException(\"Null ResourceScheduler instance\");\n     }\n-    \n+\n     EnumSet\u003cNodeState\u003e acceptedStates;\n     if (states \u003d\u003d null) {\n       acceptedStates \u003d EnumSet.allOf(NodeState.class);\n     } else {\n       acceptedStates \u003d EnumSet.noneOf(NodeState.class);\n       for (String stateStr : states.split(\",\")) {\n-        acceptedStates.add(\n-            NodeState.valueOf(StringUtils.toUpperCase(stateStr)));\n+        acceptedStates\n+            .add(NodeState.valueOf(StringUtils.toUpperCase(stateStr)));\n       }\n     }\n-    \n-    Collection\u003cRMNode\u003e rmNodes \u003d RMServerUtils.queryRMNodes(\n-        this.rm.getRMContext(), acceptedStates);\n+\n+    Collection\u003cRMNode\u003e rmNodes \u003d\n+        RMServerUtils.queryRMNodes(this.rm.getRMContext(), acceptedStates);\n     NodesInfo nodesInfo \u003d new NodesInfo();\n     for (RMNode rmNode : rmNodes) {\n       NodeInfo nodeInfo \u003d new NodeInfo(rmNode, sched);\n-      if (EnumSet.of(NodeState.LOST, NodeState.DECOMMISSIONED, NodeState.REBOOTED)\n+      if (EnumSet\n+          .of(NodeState.LOST, NodeState.DECOMMISSIONED, NodeState.REBOOTED)\n           .contains(rmNode.getState())) {\n-        nodeInfo.setNodeHTTPAddress(EMPTY);\n+        nodeInfo.setNodeHTTPAddress(RMWSConsts.EMPTY);\n       }\n       nodesInfo.add(nodeInfo);\n     }\n-    \n+\n     return nodesInfo;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public NodesInfo getNodes(@QueryParam(RMWSConsts.STATES) String states) {\n    init();\n    ResourceScheduler sched \u003d this.rm.getResourceScheduler();\n    if (sched \u003d\u003d null) {\n      throw new NotFoundException(\"Null ResourceScheduler instance\");\n    }\n\n    EnumSet\u003cNodeState\u003e acceptedStates;\n    if (states \u003d\u003d null) {\n      acceptedStates \u003d EnumSet.allOf(NodeState.class);\n    } else {\n      acceptedStates \u003d EnumSet.noneOf(NodeState.class);\n      for (String stateStr : states.split(\",\")) {\n        acceptedStates\n            .add(NodeState.valueOf(StringUtils.toUpperCase(stateStr)));\n      }\n    }\n\n    Collection\u003cRMNode\u003e rmNodes \u003d\n        RMServerUtils.queryRMNodes(this.rm.getRMContext(), acceptedStates);\n    NodesInfo nodesInfo \u003d new NodesInfo();\n    for (RMNode rmNode : rmNodes) {\n      NodeInfo nodeInfo \u003d new NodeInfo(rmNode, sched);\n      if (EnumSet\n          .of(NodeState.LOST, NodeState.DECOMMISSIONED, NodeState.REBOOTED)\n          .contains(rmNode.getState())) {\n        nodeInfo.setNodeHTTPAddress(RMWSConsts.EMPTY);\n      }\n      nodesInfo.add(nodeInfo);\n    }\n\n    return nodesInfo;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/webapp/RMWebServices.java",
          "extendedDetails": {}
        },
        {
          "type": "Yparametermetachange",
          "commitMessage": "YARN-6634. [API] Refactor ResourceManager WebServices to make API explicit. (Giovanni Matteo Fumarola via curino)\n",
          "commitDate": "07/06/17 1:41 PM",
          "commitName": "547cb53e8ae2f19b55f9de7670b91b009d8f3bdd",
          "commitAuthor": "Carlo Curino",
          "commitDateOld": "08/12/16 2:23 AM",
          "commitNameOld": "74d0066d3392169bec872f438a0818e2f5323010",
          "commitAuthorOld": "Sunil G",
          "daysBetweenCommits": 181.43,
          "commitsBetweenForRepo": 954,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,32 +1,33 @@\n-  public NodesInfo getNodes(@QueryParam(\"states\") String states) {\n+  public NodesInfo getNodes(@QueryParam(RMWSConsts.STATES) String states) {\n     init();\n     ResourceScheduler sched \u003d this.rm.getResourceScheduler();\n     if (sched \u003d\u003d null) {\n       throw new NotFoundException(\"Null ResourceScheduler instance\");\n     }\n-    \n+\n     EnumSet\u003cNodeState\u003e acceptedStates;\n     if (states \u003d\u003d null) {\n       acceptedStates \u003d EnumSet.allOf(NodeState.class);\n     } else {\n       acceptedStates \u003d EnumSet.noneOf(NodeState.class);\n       for (String stateStr : states.split(\",\")) {\n-        acceptedStates.add(\n-            NodeState.valueOf(StringUtils.toUpperCase(stateStr)));\n+        acceptedStates\n+            .add(NodeState.valueOf(StringUtils.toUpperCase(stateStr)));\n       }\n     }\n-    \n-    Collection\u003cRMNode\u003e rmNodes \u003d RMServerUtils.queryRMNodes(\n-        this.rm.getRMContext(), acceptedStates);\n+\n+    Collection\u003cRMNode\u003e rmNodes \u003d\n+        RMServerUtils.queryRMNodes(this.rm.getRMContext(), acceptedStates);\n     NodesInfo nodesInfo \u003d new NodesInfo();\n     for (RMNode rmNode : rmNodes) {\n       NodeInfo nodeInfo \u003d new NodeInfo(rmNode, sched);\n-      if (EnumSet.of(NodeState.LOST, NodeState.DECOMMISSIONED, NodeState.REBOOTED)\n+      if (EnumSet\n+          .of(NodeState.LOST, NodeState.DECOMMISSIONED, NodeState.REBOOTED)\n           .contains(rmNode.getState())) {\n-        nodeInfo.setNodeHTTPAddress(EMPTY);\n+        nodeInfo.setNodeHTTPAddress(RMWSConsts.EMPTY);\n       }\n       nodesInfo.add(nodeInfo);\n     }\n-    \n+\n     return nodesInfo;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public NodesInfo getNodes(@QueryParam(RMWSConsts.STATES) String states) {\n    init();\n    ResourceScheduler sched \u003d this.rm.getResourceScheduler();\n    if (sched \u003d\u003d null) {\n      throw new NotFoundException(\"Null ResourceScheduler instance\");\n    }\n\n    EnumSet\u003cNodeState\u003e acceptedStates;\n    if (states \u003d\u003d null) {\n      acceptedStates \u003d EnumSet.allOf(NodeState.class);\n    } else {\n      acceptedStates \u003d EnumSet.noneOf(NodeState.class);\n      for (String stateStr : states.split(\",\")) {\n        acceptedStates\n            .add(NodeState.valueOf(StringUtils.toUpperCase(stateStr)));\n      }\n    }\n\n    Collection\u003cRMNode\u003e rmNodes \u003d\n        RMServerUtils.queryRMNodes(this.rm.getRMContext(), acceptedStates);\n    NodesInfo nodesInfo \u003d new NodesInfo();\n    for (RMNode rmNode : rmNodes) {\n      NodeInfo nodeInfo \u003d new NodeInfo(rmNode, sched);\n      if (EnumSet\n          .of(NodeState.LOST, NodeState.DECOMMISSIONED, NodeState.REBOOTED)\n          .contains(rmNode.getState())) {\n        nodeInfo.setNodeHTTPAddress(RMWSConsts.EMPTY);\n      }\n      nodesInfo.add(nodeInfo);\n    }\n\n    return nodesInfo;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/webapp/RMWebServices.java",
          "extendedDetails": {
            "oldValue": "[states-String(annotations-@QueryParam(\"states\"))]",
            "newValue": "[states-String(annotations-@QueryParam(RMWSConsts.STATES))]"
          }
        }
      ]
    },
    "d1c6accb6f87b08975175580e15f1ff1fe29ab04": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11602. Fix toUpperCase/toLowerCase to use Locale.ENGLISH. (ozawa)\n",
      "commitDate": "02/03/15 9:17 PM",
      "commitName": "d1c6accb6f87b08975175580e15f1ff1fe29ab04",
      "commitAuthor": "Tsuyoshi Ozawa",
      "commitDateOld": "27/02/15 4:13 PM",
      "commitNameOld": "edcecedc1c39d54db0f86a1325b4db26c38d2d4d",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 3.21,
      "commitsBetweenForRepo": 21,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,31 +1,32 @@\n   public NodesInfo getNodes(@QueryParam(\"states\") String states) {\n     init();\n     ResourceScheduler sched \u003d this.rm.getResourceScheduler();\n     if (sched \u003d\u003d null) {\n       throw new NotFoundException(\"Null ResourceScheduler instance\");\n     }\n     \n     EnumSet\u003cNodeState\u003e acceptedStates;\n     if (states \u003d\u003d null) {\n       acceptedStates \u003d EnumSet.allOf(NodeState.class);\n     } else {\n       acceptedStates \u003d EnumSet.noneOf(NodeState.class);\n       for (String stateStr : states.split(\",\")) {\n-        acceptedStates.add(NodeState.valueOf(stateStr.toUpperCase()));\n+        acceptedStates.add(\n+            NodeState.valueOf(StringUtils.toUpperCase(stateStr)));\n       }\n     }\n     \n     Collection\u003cRMNode\u003e rmNodes \u003d RMServerUtils.queryRMNodes(this.rm.getRMContext(),\n         acceptedStates);\n     NodesInfo nodesInfo \u003d new NodesInfo();\n     for (RMNode rmNode : rmNodes) {\n       NodeInfo nodeInfo \u003d new NodeInfo(rmNode, sched);\n       if (EnumSet.of(NodeState.LOST, NodeState.DECOMMISSIONED, NodeState.REBOOTED)\n           .contains(rmNode.getState())) {\n         nodeInfo.setNodeHTTPAddress(EMPTY);\n       }\n       nodesInfo.add(nodeInfo);\n     }\n     \n     return nodesInfo;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public NodesInfo getNodes(@QueryParam(\"states\") String states) {\n    init();\n    ResourceScheduler sched \u003d this.rm.getResourceScheduler();\n    if (sched \u003d\u003d null) {\n      throw new NotFoundException(\"Null ResourceScheduler instance\");\n    }\n    \n    EnumSet\u003cNodeState\u003e acceptedStates;\n    if (states \u003d\u003d null) {\n      acceptedStates \u003d EnumSet.allOf(NodeState.class);\n    } else {\n      acceptedStates \u003d EnumSet.noneOf(NodeState.class);\n      for (String stateStr : states.split(\",\")) {\n        acceptedStates.add(\n            NodeState.valueOf(StringUtils.toUpperCase(stateStr)));\n      }\n    }\n    \n    Collection\u003cRMNode\u003e rmNodes \u003d RMServerUtils.queryRMNodes(this.rm.getRMContext(),\n        acceptedStates);\n    NodesInfo nodesInfo \u003d new NodesInfo();\n    for (RMNode rmNode : rmNodes) {\n      NodeInfo nodeInfo \u003d new NodeInfo(rmNode, sched);\n      if (EnumSet.of(NodeState.LOST, NodeState.DECOMMISSIONED, NodeState.REBOOTED)\n          .contains(rmNode.getState())) {\n        nodeInfo.setNodeHTTPAddress(EMPTY);\n      }\n      nodesInfo.add(nodeInfo);\n    }\n    \n    return nodesInfo;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/webapp/RMWebServices.java",
      "extendedDetails": {}
    },
    "9cedad11d8d2197a54732667a15344983de5c437": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HADOOP-11602. Fix toUpperCase/toLowerCase to use Locale.ENGLISH. (ozawa)\"\n\nThis reverts commit 946456c6d88780abe0251b098dd771e9e1e93ab3.\n\nConflicts:\n\thadoop-common-project/hadoop-common/CHANGES.txt\n\thadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/QuotaByStorageTypeEntry.java\n",
      "commitDate": "24/02/15 7:32 AM",
      "commitName": "9cedad11d8d2197a54732667a15344983de5c437",
      "commitAuthor": "Tsuyoshi Ozawa",
      "commitDateOld": "18/02/15 8:06 PM",
      "commitNameOld": "946456c6d88780abe0251b098dd771e9e1e93ab3",
      "commitAuthorOld": "Tsuyoshi Ozawa",
      "daysBetweenCommits": 5.48,
      "commitsBetweenForRepo": 31,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,32 +1,31 @@\n   public NodesInfo getNodes(@QueryParam(\"states\") String states) {\n     init();\n     ResourceScheduler sched \u003d this.rm.getResourceScheduler();\n     if (sched \u003d\u003d null) {\n       throw new NotFoundException(\"Null ResourceScheduler instance\");\n     }\n     \n     EnumSet\u003cNodeState\u003e acceptedStates;\n     if (states \u003d\u003d null) {\n       acceptedStates \u003d EnumSet.allOf(NodeState.class);\n     } else {\n       acceptedStates \u003d EnumSet.noneOf(NodeState.class);\n       for (String stateStr : states.split(\",\")) {\n-        acceptedStates.add(NodeState.valueOf(\n-            stateStr.toUpperCase(Locale.ENGLISH)));\n+        acceptedStates.add(NodeState.valueOf(stateStr.toUpperCase()));\n       }\n     }\n     \n     Collection\u003cRMNode\u003e rmNodes \u003d RMServerUtils.queryRMNodes(this.rm.getRMContext(),\n         acceptedStates);\n     NodesInfo nodesInfo \u003d new NodesInfo();\n     for (RMNode rmNode : rmNodes) {\n       NodeInfo nodeInfo \u003d new NodeInfo(rmNode, sched);\n       if (EnumSet.of(NodeState.LOST, NodeState.DECOMMISSIONED, NodeState.REBOOTED)\n           .contains(rmNode.getState())) {\n         nodeInfo.setNodeHTTPAddress(EMPTY);\n       }\n       nodesInfo.add(nodeInfo);\n     }\n     \n     return nodesInfo;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public NodesInfo getNodes(@QueryParam(\"states\") String states) {\n    init();\n    ResourceScheduler sched \u003d this.rm.getResourceScheduler();\n    if (sched \u003d\u003d null) {\n      throw new NotFoundException(\"Null ResourceScheduler instance\");\n    }\n    \n    EnumSet\u003cNodeState\u003e acceptedStates;\n    if (states \u003d\u003d null) {\n      acceptedStates \u003d EnumSet.allOf(NodeState.class);\n    } else {\n      acceptedStates \u003d EnumSet.noneOf(NodeState.class);\n      for (String stateStr : states.split(\",\")) {\n        acceptedStates.add(NodeState.valueOf(stateStr.toUpperCase()));\n      }\n    }\n    \n    Collection\u003cRMNode\u003e rmNodes \u003d RMServerUtils.queryRMNodes(this.rm.getRMContext(),\n        acceptedStates);\n    NodesInfo nodesInfo \u003d new NodesInfo();\n    for (RMNode rmNode : rmNodes) {\n      NodeInfo nodeInfo \u003d new NodeInfo(rmNode, sched);\n      if (EnumSet.of(NodeState.LOST, NodeState.DECOMMISSIONED, NodeState.REBOOTED)\n          .contains(rmNode.getState())) {\n        nodeInfo.setNodeHTTPAddress(EMPTY);\n      }\n      nodesInfo.add(nodeInfo);\n    }\n    \n    return nodesInfo;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/webapp/RMWebServices.java",
      "extendedDetails": {}
    },
    "946456c6d88780abe0251b098dd771e9e1e93ab3": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11602. Fix toUpperCase/toLowerCase to use Locale.ENGLISH. (ozawa)\n",
      "commitDate": "18/02/15 8:06 PM",
      "commitName": "946456c6d88780abe0251b098dd771e9e1e93ab3",
      "commitAuthor": "Tsuyoshi Ozawa",
      "commitDateOld": "06/02/15 1:47 PM",
      "commitNameOld": "da2fb2bc46bddf42d79c6d7664cbf0311973709e",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 12.26,
      "commitsBetweenForRepo": 148,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,31 +1,32 @@\n   public NodesInfo getNodes(@QueryParam(\"states\") String states) {\n     init();\n     ResourceScheduler sched \u003d this.rm.getResourceScheduler();\n     if (sched \u003d\u003d null) {\n       throw new NotFoundException(\"Null ResourceScheduler instance\");\n     }\n     \n     EnumSet\u003cNodeState\u003e acceptedStates;\n     if (states \u003d\u003d null) {\n       acceptedStates \u003d EnumSet.allOf(NodeState.class);\n     } else {\n       acceptedStates \u003d EnumSet.noneOf(NodeState.class);\n       for (String stateStr : states.split(\",\")) {\n-        acceptedStates.add(NodeState.valueOf(stateStr.toUpperCase()));\n+        acceptedStates.add(NodeState.valueOf(\n+            stateStr.toUpperCase(Locale.ENGLISH)));\n       }\n     }\n     \n     Collection\u003cRMNode\u003e rmNodes \u003d RMServerUtils.queryRMNodes(this.rm.getRMContext(),\n         acceptedStates);\n     NodesInfo nodesInfo \u003d new NodesInfo();\n     for (RMNode rmNode : rmNodes) {\n       NodeInfo nodeInfo \u003d new NodeInfo(rmNode, sched);\n       if (EnumSet.of(NodeState.LOST, NodeState.DECOMMISSIONED, NodeState.REBOOTED)\n           .contains(rmNode.getState())) {\n         nodeInfo.setNodeHTTPAddress(EMPTY);\n       }\n       nodesInfo.add(nodeInfo);\n     }\n     \n     return nodesInfo;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public NodesInfo getNodes(@QueryParam(\"states\") String states) {\n    init();\n    ResourceScheduler sched \u003d this.rm.getResourceScheduler();\n    if (sched \u003d\u003d null) {\n      throw new NotFoundException(\"Null ResourceScheduler instance\");\n    }\n    \n    EnumSet\u003cNodeState\u003e acceptedStates;\n    if (states \u003d\u003d null) {\n      acceptedStates \u003d EnumSet.allOf(NodeState.class);\n    } else {\n      acceptedStates \u003d EnumSet.noneOf(NodeState.class);\n      for (String stateStr : states.split(\",\")) {\n        acceptedStates.add(NodeState.valueOf(\n            stateStr.toUpperCase(Locale.ENGLISH)));\n      }\n    }\n    \n    Collection\u003cRMNode\u003e rmNodes \u003d RMServerUtils.queryRMNodes(this.rm.getRMContext(),\n        acceptedStates);\n    NodesInfo nodesInfo \u003d new NodesInfo();\n    for (RMNode rmNode : rmNodes) {\n      NodeInfo nodeInfo \u003d new NodeInfo(rmNode, sched);\n      if (EnumSet.of(NodeState.LOST, NodeState.DECOMMISSIONED, NodeState.REBOOTED)\n          .contains(rmNode.getState())) {\n        nodeInfo.setNodeHTTPAddress(EMPTY);\n      }\n      nodesInfo.add(nodeInfo);\n    }\n    \n    return nodesInfo;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/webapp/RMWebServices.java",
      "extendedDetails": {}
    },
    "5e4f6ad1d9aa6df96af837600674af4467c1e99c": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-791. Changed RM APIs and web-services related to nodes to ensure that both are consistent with each other. Contributed by Sandy Ryza.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1500994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/07/13 3:30 PM",
      "commitName": "5e4f6ad1d9aa6df96af837600674af4467c1e99c",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-791. Changed RM APIs and web-services related to nodes to ensure that both are consistent with each other. Contributed by Sandy Ryza.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1500994 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "08/07/13 3:30 PM",
          "commitName": "5e4f6ad1d9aa6df96af837600674af4467c1e99c",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "07/06/13 5:54 PM",
          "commitNameOld": "0b0be8d4dd88738dd213763742fc8eccba68531f",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 30.9,
          "commitsBetweenForRepo": 176,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,44 +1,31 @@\n-  public NodesInfo getNodes(@QueryParam(\"state\") String state) {\n+  public NodesInfo getNodes(@QueryParam(\"states\") String states) {\n     init();\n     ResourceScheduler sched \u003d this.rm.getResourceScheduler();\n     if (sched \u003d\u003d null) {\n       throw new NotFoundException(\"Null ResourceScheduler instance\");\n     }\n     \n-    NodeState acceptedState \u003d null;\n-    boolean all \u003d false;\n-    \n-    if (state !\u003d null \u0026\u0026 !state.isEmpty()) {\n-      if (state.equalsIgnoreCase(\"all\")) {\n-        all \u003d true;\n-      } else {\n-        acceptedState \u003d NodeState.valueOf(state.toUpperCase());\n+    EnumSet\u003cNodeState\u003e acceptedStates;\n+    if (states \u003d\u003d null) {\n+      acceptedStates \u003d EnumSet.allOf(NodeState.class);\n+    } else {\n+      acceptedStates \u003d EnumSet.noneOf(NodeState.class);\n+      for (String stateStr : states.split(\",\")) {\n+        acceptedStates.add(NodeState.valueOf(stateStr.toUpperCase()));\n       }\n     }\n     \n-    // getRMNodes() contains nodes that are NEW, RUNNING OR UNHEALTHY\n-    NodesInfo allNodes \u003d new NodesInfo();\n-    for (RMNode ni : this.rm.getRMContext().getRMNodes().values()) {\n-      if (all || (acceptedState \u003d\u003d null \u0026\u0026 ni.getState() !\u003d NodeState.UNHEALTHY)\n-          || acceptedState \u003d\u003d ni.getState()) {\n-        NodeInfo nodeInfo \u003d new NodeInfo(ni, sched);\n-        allNodes.add(nodeInfo);\n+    Collection\u003cRMNode\u003e rmNodes \u003d RMServerUtils.queryRMNodes(this.rm.getRMContext(),\n+        acceptedStates);\n+    NodesInfo nodesInfo \u003d new NodesInfo();\n+    for (RMNode rmNode : rmNodes) {\n+      NodeInfo nodeInfo \u003d new NodeInfo(rmNode, sched);\n+      if (EnumSet.of(NodeState.LOST, NodeState.DECOMMISSIONED, NodeState.REBOOTED)\n+          .contains(rmNode.getState())) {\n+        nodeInfo.setNodeHTTPAddress(EMPTY);\n       }\n+      nodesInfo.add(nodeInfo);\n     }\n     \n-    // getInactiveNodes() contains nodes that are DECOMMISSIONED, LOST, OR REBOOTED\n-    if (all || (acceptedState !\u003d null \u0026\u0026\n-        (acceptedState \u003d\u003d NodeState.DECOMMISSIONED ||\n-         acceptedState \u003d\u003d NodeState.LOST ||\n-         acceptedState \u003d\u003d NodeState.REBOOTED))) {\n-      for (RMNode ni : this.rm.getRMContext().getInactiveRMNodes().values()) {\n-        if (all || acceptedState \u003d\u003d ni.getState()) {\n-          NodeInfo nodeInfo \u003d new NodeInfo(ni, sched);\n-          nodeInfo.setNodeHTTPAddress(EMPTY);\n-          allNodes.add(nodeInfo);\n-        }\n-      }\n-    }\n-    \n-    return allNodes;\n+    return nodesInfo;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public NodesInfo getNodes(@QueryParam(\"states\") String states) {\n    init();\n    ResourceScheduler sched \u003d this.rm.getResourceScheduler();\n    if (sched \u003d\u003d null) {\n      throw new NotFoundException(\"Null ResourceScheduler instance\");\n    }\n    \n    EnumSet\u003cNodeState\u003e acceptedStates;\n    if (states \u003d\u003d null) {\n      acceptedStates \u003d EnumSet.allOf(NodeState.class);\n    } else {\n      acceptedStates \u003d EnumSet.noneOf(NodeState.class);\n      for (String stateStr : states.split(\",\")) {\n        acceptedStates.add(NodeState.valueOf(stateStr.toUpperCase()));\n      }\n    }\n    \n    Collection\u003cRMNode\u003e rmNodes \u003d RMServerUtils.queryRMNodes(this.rm.getRMContext(),\n        acceptedStates);\n    NodesInfo nodesInfo \u003d new NodesInfo();\n    for (RMNode rmNode : rmNodes) {\n      NodeInfo nodeInfo \u003d new NodeInfo(rmNode, sched);\n      if (EnumSet.of(NodeState.LOST, NodeState.DECOMMISSIONED, NodeState.REBOOTED)\n          .contains(rmNode.getState())) {\n        nodeInfo.setNodeHTTPAddress(EMPTY);\n      }\n      nodesInfo.add(nodeInfo);\n    }\n    \n    return nodesInfo;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/webapp/RMWebServices.java",
          "extendedDetails": {
            "oldValue": "[state-String(annotations-@QueryParam(\"state\"))]",
            "newValue": "[states-String(annotations-@QueryParam(\"states\"))]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-791. Changed RM APIs and web-services related to nodes to ensure that both are consistent with each other. Contributed by Sandy Ryza.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1500994 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "08/07/13 3:30 PM",
          "commitName": "5e4f6ad1d9aa6df96af837600674af4467c1e99c",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "07/06/13 5:54 PM",
          "commitNameOld": "0b0be8d4dd88738dd213763742fc8eccba68531f",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 30.9,
          "commitsBetweenForRepo": 176,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,44 +1,31 @@\n-  public NodesInfo getNodes(@QueryParam(\"state\") String state) {\n+  public NodesInfo getNodes(@QueryParam(\"states\") String states) {\n     init();\n     ResourceScheduler sched \u003d this.rm.getResourceScheduler();\n     if (sched \u003d\u003d null) {\n       throw new NotFoundException(\"Null ResourceScheduler instance\");\n     }\n     \n-    NodeState acceptedState \u003d null;\n-    boolean all \u003d false;\n-    \n-    if (state !\u003d null \u0026\u0026 !state.isEmpty()) {\n-      if (state.equalsIgnoreCase(\"all\")) {\n-        all \u003d true;\n-      } else {\n-        acceptedState \u003d NodeState.valueOf(state.toUpperCase());\n+    EnumSet\u003cNodeState\u003e acceptedStates;\n+    if (states \u003d\u003d null) {\n+      acceptedStates \u003d EnumSet.allOf(NodeState.class);\n+    } else {\n+      acceptedStates \u003d EnumSet.noneOf(NodeState.class);\n+      for (String stateStr : states.split(\",\")) {\n+        acceptedStates.add(NodeState.valueOf(stateStr.toUpperCase()));\n       }\n     }\n     \n-    // getRMNodes() contains nodes that are NEW, RUNNING OR UNHEALTHY\n-    NodesInfo allNodes \u003d new NodesInfo();\n-    for (RMNode ni : this.rm.getRMContext().getRMNodes().values()) {\n-      if (all || (acceptedState \u003d\u003d null \u0026\u0026 ni.getState() !\u003d NodeState.UNHEALTHY)\n-          || acceptedState \u003d\u003d ni.getState()) {\n-        NodeInfo nodeInfo \u003d new NodeInfo(ni, sched);\n-        allNodes.add(nodeInfo);\n+    Collection\u003cRMNode\u003e rmNodes \u003d RMServerUtils.queryRMNodes(this.rm.getRMContext(),\n+        acceptedStates);\n+    NodesInfo nodesInfo \u003d new NodesInfo();\n+    for (RMNode rmNode : rmNodes) {\n+      NodeInfo nodeInfo \u003d new NodeInfo(rmNode, sched);\n+      if (EnumSet.of(NodeState.LOST, NodeState.DECOMMISSIONED, NodeState.REBOOTED)\n+          .contains(rmNode.getState())) {\n+        nodeInfo.setNodeHTTPAddress(EMPTY);\n       }\n+      nodesInfo.add(nodeInfo);\n     }\n     \n-    // getInactiveNodes() contains nodes that are DECOMMISSIONED, LOST, OR REBOOTED\n-    if (all || (acceptedState !\u003d null \u0026\u0026\n-        (acceptedState \u003d\u003d NodeState.DECOMMISSIONED ||\n-         acceptedState \u003d\u003d NodeState.LOST ||\n-         acceptedState \u003d\u003d NodeState.REBOOTED))) {\n-      for (RMNode ni : this.rm.getRMContext().getInactiveRMNodes().values()) {\n-        if (all || acceptedState \u003d\u003d ni.getState()) {\n-          NodeInfo nodeInfo \u003d new NodeInfo(ni, sched);\n-          nodeInfo.setNodeHTTPAddress(EMPTY);\n-          allNodes.add(nodeInfo);\n-        }\n-      }\n-    }\n-    \n-    return allNodes;\n+    return nodesInfo;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public NodesInfo getNodes(@QueryParam(\"states\") String states) {\n    init();\n    ResourceScheduler sched \u003d this.rm.getResourceScheduler();\n    if (sched \u003d\u003d null) {\n      throw new NotFoundException(\"Null ResourceScheduler instance\");\n    }\n    \n    EnumSet\u003cNodeState\u003e acceptedStates;\n    if (states \u003d\u003d null) {\n      acceptedStates \u003d EnumSet.allOf(NodeState.class);\n    } else {\n      acceptedStates \u003d EnumSet.noneOf(NodeState.class);\n      for (String stateStr : states.split(\",\")) {\n        acceptedStates.add(NodeState.valueOf(stateStr.toUpperCase()));\n      }\n    }\n    \n    Collection\u003cRMNode\u003e rmNodes \u003d RMServerUtils.queryRMNodes(this.rm.getRMContext(),\n        acceptedStates);\n    NodesInfo nodesInfo \u003d new NodesInfo();\n    for (RMNode rmNode : rmNodes) {\n      NodeInfo nodeInfo \u003d new NodeInfo(rmNode, sched);\n      if (EnumSet.of(NodeState.LOST, NodeState.DECOMMISSIONED, NodeState.REBOOTED)\n          .contains(rmNode.getState())) {\n        nodeInfo.setNodeHTTPAddress(EMPTY);\n      }\n      nodesInfo.add(nodeInfo);\n    }\n    \n    return nodesInfo;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/webapp/RMWebServices.java",
          "extendedDetails": {}
        }
      ]
    },
    "0b0be8d4dd88738dd213763742fc8eccba68531f": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-642. Removed health parameter from ResourceManager /nodes web-service and cleaned the behaviour of the status parameter. Contributed by Sandy Ryza.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1490890 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/06/13 5:54 PM",
      "commitName": "0b0be8d4dd88738dd213763742fc8eccba68531f",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-642. Removed health parameter from ResourceManager /nodes web-service and cleaned the behaviour of the status parameter. Contributed by Sandy Ryza.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1490890 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "07/06/13 5:54 PM",
          "commitName": "0b0be8d4dd88738dd213763742fc8eccba68531f",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "07/06/13 1:59 PM",
          "commitNameOld": "af8514eef297574240652672d048748100c97733",
          "commitAuthorOld": "Alejandro Abdelnur",
          "daysBetweenCommits": 0.16,
          "commitsBetweenForRepo": 3,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,53 +1,44 @@\n-  public NodesInfo getNodes(@QueryParam(\"state\") String filterState,\n-      @QueryParam(\"healthy\") String healthState) {\n+  public NodesInfo getNodes(@QueryParam(\"state\") String state) {\n     init();\n     ResourceScheduler sched \u003d this.rm.getResourceScheduler();\n     if (sched \u003d\u003d null) {\n       throw new NotFoundException(\"Null ResourceScheduler instance\");\n     }\n-    Collection\u003cRMNode\u003e rmNodes \u003d this.rm.getRMContext().getRMNodes().values();\n-    boolean isInactive \u003d false;\n-    if (filterState !\u003d null \u0026\u0026 !filterState.isEmpty()) {\n-      NodeState nodeState \u003d NodeState.valueOf(filterState.toUpperCase());\n-      switch (nodeState) {\n-      case DECOMMISSIONED:\n-      case LOST:\n-      case REBOOTED:\n-        rmNodes \u003d this.rm.getRMContext().getInactiveRMNodes().values();\n-        isInactive \u003d true;\n-        break;\n-      }\n-    }\n-    NodesInfo allNodes \u003d new NodesInfo();\n-    for (RMNode ni : rmNodes) {\n-      NodeInfo nodeInfo \u003d new NodeInfo(ni, sched);\n-      if (filterState !\u003d null) {\n-        if (!(nodeInfo.getState().equalsIgnoreCase(filterState))) {\n-          continue;\n-        }\n+    \n+    NodeState acceptedState \u003d null;\n+    boolean all \u003d false;\n+    \n+    if (state !\u003d null \u0026\u0026 !state.isEmpty()) {\n+      if (state.equalsIgnoreCase(\"all\")) {\n+        all \u003d true;\n       } else {\n-        // No filter. User is asking for all nodes. Make sure you skip the\n-        // unhealthy nodes.\n-        if (ni.getState() \u003d\u003d NodeState.UNHEALTHY) {\n-          continue;\n-        }\n+        acceptedState \u003d NodeState.valueOf(state.toUpperCase());\n       }\n-      if ((healthState !\u003d null) \u0026\u0026 (!healthState.isEmpty())) {\n-        LOG.info(\"heatlh state is : \" + healthState);\n-        if (!healthState.equalsIgnoreCase(\"true\")\n-            \u0026\u0026 !healthState.equalsIgnoreCase(\"false\")) {\n-          String msg \u003d \"Error: You must specify either true or false to query on health\";\n-          throw new BadRequestException(msg);\n-        }\n-        if ((ni.getState() !\u003d NodeState.UNHEALTHY)\n-            !\u003d Boolean.parseBoolean(healthState)) {\n-          continue;\n-        }\n-      }\n-      if (isInactive) {\n-        nodeInfo.setNodeHTTPAddress(EMPTY);\n-      }\n-      allNodes.add(nodeInfo);\n     }\n+    \n+    // getRMNodes() contains nodes that are NEW, RUNNING OR UNHEALTHY\n+    NodesInfo allNodes \u003d new NodesInfo();\n+    for (RMNode ni : this.rm.getRMContext().getRMNodes().values()) {\n+      if (all || (acceptedState \u003d\u003d null \u0026\u0026 ni.getState() !\u003d NodeState.UNHEALTHY)\n+          || acceptedState \u003d\u003d ni.getState()) {\n+        NodeInfo nodeInfo \u003d new NodeInfo(ni, sched);\n+        allNodes.add(nodeInfo);\n+      }\n+    }\n+    \n+    // getInactiveNodes() contains nodes that are DECOMMISSIONED, LOST, OR REBOOTED\n+    if (all || (acceptedState !\u003d null \u0026\u0026\n+        (acceptedState \u003d\u003d NodeState.DECOMMISSIONED ||\n+         acceptedState \u003d\u003d NodeState.LOST ||\n+         acceptedState \u003d\u003d NodeState.REBOOTED))) {\n+      for (RMNode ni : this.rm.getRMContext().getInactiveRMNodes().values()) {\n+        if (all || acceptedState \u003d\u003d ni.getState()) {\n+          NodeInfo nodeInfo \u003d new NodeInfo(ni, sched);\n+          nodeInfo.setNodeHTTPAddress(EMPTY);\n+          allNodes.add(nodeInfo);\n+        }\n+      }\n+    }\n+    \n     return allNodes;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public NodesInfo getNodes(@QueryParam(\"state\") String state) {\n    init();\n    ResourceScheduler sched \u003d this.rm.getResourceScheduler();\n    if (sched \u003d\u003d null) {\n      throw new NotFoundException(\"Null ResourceScheduler instance\");\n    }\n    \n    NodeState acceptedState \u003d null;\n    boolean all \u003d false;\n    \n    if (state !\u003d null \u0026\u0026 !state.isEmpty()) {\n      if (state.equalsIgnoreCase(\"all\")) {\n        all \u003d true;\n      } else {\n        acceptedState \u003d NodeState.valueOf(state.toUpperCase());\n      }\n    }\n    \n    // getRMNodes() contains nodes that are NEW, RUNNING OR UNHEALTHY\n    NodesInfo allNodes \u003d new NodesInfo();\n    for (RMNode ni : this.rm.getRMContext().getRMNodes().values()) {\n      if (all || (acceptedState \u003d\u003d null \u0026\u0026 ni.getState() !\u003d NodeState.UNHEALTHY)\n          || acceptedState \u003d\u003d ni.getState()) {\n        NodeInfo nodeInfo \u003d new NodeInfo(ni, sched);\n        allNodes.add(nodeInfo);\n      }\n    }\n    \n    // getInactiveNodes() contains nodes that are DECOMMISSIONED, LOST, OR REBOOTED\n    if (all || (acceptedState !\u003d null \u0026\u0026\n        (acceptedState \u003d\u003d NodeState.DECOMMISSIONED ||\n         acceptedState \u003d\u003d NodeState.LOST ||\n         acceptedState \u003d\u003d NodeState.REBOOTED))) {\n      for (RMNode ni : this.rm.getRMContext().getInactiveRMNodes().values()) {\n        if (all || acceptedState \u003d\u003d ni.getState()) {\n          NodeInfo nodeInfo \u003d new NodeInfo(ni, sched);\n          nodeInfo.setNodeHTTPAddress(EMPTY);\n          allNodes.add(nodeInfo);\n        }\n      }\n    }\n    \n    return allNodes;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/webapp/RMWebServices.java",
          "extendedDetails": {
            "oldValue": "[filterState-String(annotations-@QueryParam(\"state\")), healthState-String(annotations-@QueryParam(\"healthy\"))]",
            "newValue": "[state-String(annotations-@QueryParam(\"state\"))]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-642. Removed health parameter from ResourceManager /nodes web-service and cleaned the behaviour of the status parameter. Contributed by Sandy Ryza.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1490890 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "07/06/13 5:54 PM",
          "commitName": "0b0be8d4dd88738dd213763742fc8eccba68531f",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "07/06/13 1:59 PM",
          "commitNameOld": "af8514eef297574240652672d048748100c97733",
          "commitAuthorOld": "Alejandro Abdelnur",
          "daysBetweenCommits": 0.16,
          "commitsBetweenForRepo": 3,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,53 +1,44 @@\n-  public NodesInfo getNodes(@QueryParam(\"state\") String filterState,\n-      @QueryParam(\"healthy\") String healthState) {\n+  public NodesInfo getNodes(@QueryParam(\"state\") String state) {\n     init();\n     ResourceScheduler sched \u003d this.rm.getResourceScheduler();\n     if (sched \u003d\u003d null) {\n       throw new NotFoundException(\"Null ResourceScheduler instance\");\n     }\n-    Collection\u003cRMNode\u003e rmNodes \u003d this.rm.getRMContext().getRMNodes().values();\n-    boolean isInactive \u003d false;\n-    if (filterState !\u003d null \u0026\u0026 !filterState.isEmpty()) {\n-      NodeState nodeState \u003d NodeState.valueOf(filterState.toUpperCase());\n-      switch (nodeState) {\n-      case DECOMMISSIONED:\n-      case LOST:\n-      case REBOOTED:\n-        rmNodes \u003d this.rm.getRMContext().getInactiveRMNodes().values();\n-        isInactive \u003d true;\n-        break;\n-      }\n-    }\n-    NodesInfo allNodes \u003d new NodesInfo();\n-    for (RMNode ni : rmNodes) {\n-      NodeInfo nodeInfo \u003d new NodeInfo(ni, sched);\n-      if (filterState !\u003d null) {\n-        if (!(nodeInfo.getState().equalsIgnoreCase(filterState))) {\n-          continue;\n-        }\n+    \n+    NodeState acceptedState \u003d null;\n+    boolean all \u003d false;\n+    \n+    if (state !\u003d null \u0026\u0026 !state.isEmpty()) {\n+      if (state.equalsIgnoreCase(\"all\")) {\n+        all \u003d true;\n       } else {\n-        // No filter. User is asking for all nodes. Make sure you skip the\n-        // unhealthy nodes.\n-        if (ni.getState() \u003d\u003d NodeState.UNHEALTHY) {\n-          continue;\n-        }\n+        acceptedState \u003d NodeState.valueOf(state.toUpperCase());\n       }\n-      if ((healthState !\u003d null) \u0026\u0026 (!healthState.isEmpty())) {\n-        LOG.info(\"heatlh state is : \" + healthState);\n-        if (!healthState.equalsIgnoreCase(\"true\")\n-            \u0026\u0026 !healthState.equalsIgnoreCase(\"false\")) {\n-          String msg \u003d \"Error: You must specify either true or false to query on health\";\n-          throw new BadRequestException(msg);\n-        }\n-        if ((ni.getState() !\u003d NodeState.UNHEALTHY)\n-            !\u003d Boolean.parseBoolean(healthState)) {\n-          continue;\n-        }\n-      }\n-      if (isInactive) {\n-        nodeInfo.setNodeHTTPAddress(EMPTY);\n-      }\n-      allNodes.add(nodeInfo);\n     }\n+    \n+    // getRMNodes() contains nodes that are NEW, RUNNING OR UNHEALTHY\n+    NodesInfo allNodes \u003d new NodesInfo();\n+    for (RMNode ni : this.rm.getRMContext().getRMNodes().values()) {\n+      if (all || (acceptedState \u003d\u003d null \u0026\u0026 ni.getState() !\u003d NodeState.UNHEALTHY)\n+          || acceptedState \u003d\u003d ni.getState()) {\n+        NodeInfo nodeInfo \u003d new NodeInfo(ni, sched);\n+        allNodes.add(nodeInfo);\n+      }\n+    }\n+    \n+    // getInactiveNodes() contains nodes that are DECOMMISSIONED, LOST, OR REBOOTED\n+    if (all || (acceptedState !\u003d null \u0026\u0026\n+        (acceptedState \u003d\u003d NodeState.DECOMMISSIONED ||\n+         acceptedState \u003d\u003d NodeState.LOST ||\n+         acceptedState \u003d\u003d NodeState.REBOOTED))) {\n+      for (RMNode ni : this.rm.getRMContext().getInactiveRMNodes().values()) {\n+        if (all || acceptedState \u003d\u003d ni.getState()) {\n+          NodeInfo nodeInfo \u003d new NodeInfo(ni, sched);\n+          nodeInfo.setNodeHTTPAddress(EMPTY);\n+          allNodes.add(nodeInfo);\n+        }\n+      }\n+    }\n+    \n     return allNodes;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public NodesInfo getNodes(@QueryParam(\"state\") String state) {\n    init();\n    ResourceScheduler sched \u003d this.rm.getResourceScheduler();\n    if (sched \u003d\u003d null) {\n      throw new NotFoundException(\"Null ResourceScheduler instance\");\n    }\n    \n    NodeState acceptedState \u003d null;\n    boolean all \u003d false;\n    \n    if (state !\u003d null \u0026\u0026 !state.isEmpty()) {\n      if (state.equalsIgnoreCase(\"all\")) {\n        all \u003d true;\n      } else {\n        acceptedState \u003d NodeState.valueOf(state.toUpperCase());\n      }\n    }\n    \n    // getRMNodes() contains nodes that are NEW, RUNNING OR UNHEALTHY\n    NodesInfo allNodes \u003d new NodesInfo();\n    for (RMNode ni : this.rm.getRMContext().getRMNodes().values()) {\n      if (all || (acceptedState \u003d\u003d null \u0026\u0026 ni.getState() !\u003d NodeState.UNHEALTHY)\n          || acceptedState \u003d\u003d ni.getState()) {\n        NodeInfo nodeInfo \u003d new NodeInfo(ni, sched);\n        allNodes.add(nodeInfo);\n      }\n    }\n    \n    // getInactiveNodes() contains nodes that are DECOMMISSIONED, LOST, OR REBOOTED\n    if (all || (acceptedState !\u003d null \u0026\u0026\n        (acceptedState \u003d\u003d NodeState.DECOMMISSIONED ||\n         acceptedState \u003d\u003d NodeState.LOST ||\n         acceptedState \u003d\u003d NodeState.REBOOTED))) {\n      for (RMNode ni : this.rm.getRMContext().getInactiveRMNodes().values()) {\n        if (all || acceptedState \u003d\u003d ni.getState()) {\n          NodeInfo nodeInfo \u003d new NodeInfo(ni, sched);\n          nodeInfo.setNodeHTTPAddress(EMPTY);\n          allNodes.add(nodeInfo);\n        }\n      }\n    }\n    \n    return allNodes;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/webapp/RMWebServices.java",
          "extendedDetails": {}
        }
      ]
    },
    "af8514eef297574240652672d048748100c97733": {
      "type": "Ybodychange",
      "commitMessage": "YARN-686. Flatten NodeReport. (sandyr via tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1490827 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/06/13 1:59 PM",
      "commitName": "af8514eef297574240652672d048748100c97733",
      "commitAuthor": "Alejandro Abdelnur",
      "commitDateOld": "23/05/13 8:22 PM",
      "commitNameOld": "259edf8dca44de54033e96f7eb65a83aaa6096f2",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 14.73,
      "commitsBetweenForRepo": 103,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,53 @@\n   public NodesInfo getNodes(@QueryParam(\"state\") String filterState,\n       @QueryParam(\"healthy\") String healthState) {\n     init();\n     ResourceScheduler sched \u003d this.rm.getResourceScheduler();\n     if (sched \u003d\u003d null) {\n       throw new NotFoundException(\"Null ResourceScheduler instance\");\n     }\n     Collection\u003cRMNode\u003e rmNodes \u003d this.rm.getRMContext().getRMNodes().values();\n     boolean isInactive \u003d false;\n     if (filterState !\u003d null \u0026\u0026 !filterState.isEmpty()) {\n       NodeState nodeState \u003d NodeState.valueOf(filterState.toUpperCase());\n       switch (nodeState) {\n       case DECOMMISSIONED:\n       case LOST:\n       case REBOOTED:\n         rmNodes \u003d this.rm.getRMContext().getInactiveRMNodes().values();\n         isInactive \u003d true;\n         break;\n       }\n     }\n     NodesInfo allNodes \u003d new NodesInfo();\n     for (RMNode ni : rmNodes) {\n       NodeInfo nodeInfo \u003d new NodeInfo(ni, sched);\n       if (filterState !\u003d null) {\n         if (!(nodeInfo.getState().equalsIgnoreCase(filterState))) {\n           continue;\n         }\n       } else {\n         // No filter. User is asking for all nodes. Make sure you skip the\n         // unhealthy nodes.\n         if (ni.getState() \u003d\u003d NodeState.UNHEALTHY) {\n           continue;\n         }\n       }\n       if ((healthState !\u003d null) \u0026\u0026 (!healthState.isEmpty())) {\n         LOG.info(\"heatlh state is : \" + healthState);\n         if (!healthState.equalsIgnoreCase(\"true\")\n             \u0026\u0026 !healthState.equalsIgnoreCase(\"false\")) {\n           String msg \u003d \"Error: You must specify either true or false to query on health\";\n           throw new BadRequestException(msg);\n         }\n-        if (nodeInfo.isHealthy() !\u003d Boolean.parseBoolean(healthState)) {\n+        if ((ni.getState() !\u003d NodeState.UNHEALTHY)\n+            !\u003d Boolean.parseBoolean(healthState)) {\n           continue;\n         }\n       }\n       if (isInactive) {\n         nodeInfo.setNodeHTTPAddress(EMPTY);\n       }\n       allNodes.add(nodeInfo);\n     }\n     return allNodes;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public NodesInfo getNodes(@QueryParam(\"state\") String filterState,\n      @QueryParam(\"healthy\") String healthState) {\n    init();\n    ResourceScheduler sched \u003d this.rm.getResourceScheduler();\n    if (sched \u003d\u003d null) {\n      throw new NotFoundException(\"Null ResourceScheduler instance\");\n    }\n    Collection\u003cRMNode\u003e rmNodes \u003d this.rm.getRMContext().getRMNodes().values();\n    boolean isInactive \u003d false;\n    if (filterState !\u003d null \u0026\u0026 !filterState.isEmpty()) {\n      NodeState nodeState \u003d NodeState.valueOf(filterState.toUpperCase());\n      switch (nodeState) {\n      case DECOMMISSIONED:\n      case LOST:\n      case REBOOTED:\n        rmNodes \u003d this.rm.getRMContext().getInactiveRMNodes().values();\n        isInactive \u003d true;\n        break;\n      }\n    }\n    NodesInfo allNodes \u003d new NodesInfo();\n    for (RMNode ni : rmNodes) {\n      NodeInfo nodeInfo \u003d new NodeInfo(ni, sched);\n      if (filterState !\u003d null) {\n        if (!(nodeInfo.getState().equalsIgnoreCase(filterState))) {\n          continue;\n        }\n      } else {\n        // No filter. User is asking for all nodes. Make sure you skip the\n        // unhealthy nodes.\n        if (ni.getState() \u003d\u003d NodeState.UNHEALTHY) {\n          continue;\n        }\n      }\n      if ((healthState !\u003d null) \u0026\u0026 (!healthState.isEmpty())) {\n        LOG.info(\"heatlh state is : \" + healthState);\n        if (!healthState.equalsIgnoreCase(\"true\")\n            \u0026\u0026 !healthState.equalsIgnoreCase(\"false\")) {\n          String msg \u003d \"Error: You must specify either true or false to query on health\";\n          throw new BadRequestException(msg);\n        }\n        if ((ni.getState() !\u003d NodeState.UNHEALTHY)\n            !\u003d Boolean.parseBoolean(healthState)) {\n          continue;\n        }\n      }\n      if (isInactive) {\n        nodeInfo.setNodeHTTPAddress(EMPTY);\n      }\n      allNodes.add(nodeInfo);\n    }\n    return allNodes;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/webapp/RMWebServices.java",
      "extendedDetails": {}
    },
    "e1fdf62123625e4ba399af02f8aad500637d29d1": {
      "type": "Yfilerename",
      "commitMessage": "YARN-1. Promote YARN to be a sub-project of Apache Hadoop.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1370666 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/08/12 10:22 PM",
      "commitName": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "07/08/12 7:53 PM",
      "commitNameOld": "34554d1e11ee1d5b564d7d9ed3e6d55931d72749",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public NodesInfo getNodes(@QueryParam(\"state\") String filterState,\n      @QueryParam(\"healthy\") String healthState) {\n    init();\n    ResourceScheduler sched \u003d this.rm.getResourceScheduler();\n    if (sched \u003d\u003d null) {\n      throw new NotFoundException(\"Null ResourceScheduler instance\");\n    }\n    Collection\u003cRMNode\u003e rmNodes \u003d this.rm.getRMContext().getRMNodes().values();\n    boolean isInactive \u003d false;\n    if (filterState !\u003d null \u0026\u0026 !filterState.isEmpty()) {\n      NodeState nodeState \u003d NodeState.valueOf(filterState.toUpperCase());\n      switch (nodeState) {\n      case DECOMMISSIONED:\n      case LOST:\n      case REBOOTED:\n        rmNodes \u003d this.rm.getRMContext().getInactiveRMNodes().values();\n        isInactive \u003d true;\n        break;\n      }\n    }\n    NodesInfo allNodes \u003d new NodesInfo();\n    for (RMNode ni : rmNodes) {\n      NodeInfo nodeInfo \u003d new NodeInfo(ni, sched);\n      if (filterState !\u003d null) {\n        if (!(nodeInfo.getState().equalsIgnoreCase(filterState))) {\n          continue;\n        }\n      } else {\n        // No filter. User is asking for all nodes. Make sure you skip the\n        // unhealthy nodes.\n        if (ni.getState() \u003d\u003d NodeState.UNHEALTHY) {\n          continue;\n        }\n      }\n      if ((healthState !\u003d null) \u0026\u0026 (!healthState.isEmpty())) {\n        LOG.info(\"heatlh state is : \" + healthState);\n        if (!healthState.equalsIgnoreCase(\"true\")\n            \u0026\u0026 !healthState.equalsIgnoreCase(\"false\")) {\n          String msg \u003d \"Error: You must specify either true or false to query on health\";\n          throw new BadRequestException(msg);\n        }\n        if (nodeInfo.isHealthy() !\u003d Boolean.parseBoolean(healthState)) {\n          continue;\n        }\n      }\n      if (isInactive) {\n        nodeInfo.setNodeHTTPAddress(EMPTY);\n      }\n      allNodes.add(nodeInfo);\n    }\n    return allNodes;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/webapp/RMWebServices.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/webapp/RMWebServices.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/webapp/RMWebServices.java"
      }
    },
    "407cfa3b56a0645d64d2d9af305f6ef24307e775": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3958. RM: Remove RMNodeState and replace it with NodeState (Bikas Saha via bobby)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1334043 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/05/12 8:47 AM",
      "commitName": "407cfa3b56a0645d64d2d9af305f6ef24307e775",
      "commitAuthor": "Robert Joseph Evans",
      "commitDateOld": "25/04/12 2:13 PM",
      "commitNameOld": "e7583d816a69677bbaa4280deb58ea73dbc42cef",
      "commitAuthorOld": "Thomas Graves",
      "daysBetweenCommits": 8.77,
      "commitsBetweenForRepo": 60,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,52 @@\n   public NodesInfo getNodes(@QueryParam(\"state\") String filterState,\n       @QueryParam(\"healthy\") String healthState) {\n     init();\n     ResourceScheduler sched \u003d this.rm.getResourceScheduler();\n     if (sched \u003d\u003d null) {\n       throw new NotFoundException(\"Null ResourceScheduler instance\");\n     }\n     Collection\u003cRMNode\u003e rmNodes \u003d this.rm.getRMContext().getRMNodes().values();\n     boolean isInactive \u003d false;\n     if (filterState !\u003d null \u0026\u0026 !filterState.isEmpty()) {\n-      RMNodeState nodeState \u003d RMNodeState.valueOf(filterState.toUpperCase());\n+      NodeState nodeState \u003d NodeState.valueOf(filterState.toUpperCase());\n       switch (nodeState) {\n       case DECOMMISSIONED:\n       case LOST:\n       case REBOOTED:\n         rmNodes \u003d this.rm.getRMContext().getInactiveRMNodes().values();\n         isInactive \u003d true;\n         break;\n       }\n     }\n     NodesInfo allNodes \u003d new NodesInfo();\n     for (RMNode ni : rmNodes) {\n       NodeInfo nodeInfo \u003d new NodeInfo(ni, sched);\n       if (filterState !\u003d null) {\n         if (!(nodeInfo.getState().equalsIgnoreCase(filterState))) {\n           continue;\n         }\n       } else {\n         // No filter. User is asking for all nodes. Make sure you skip the\n         // unhealthy nodes.\n-        if (ni.getState() \u003d\u003d RMNodeState.UNHEALTHY) {\n+        if (ni.getState() \u003d\u003d NodeState.UNHEALTHY) {\n           continue;\n         }\n       }\n       if ((healthState !\u003d null) \u0026\u0026 (!healthState.isEmpty())) {\n         LOG.info(\"heatlh state is : \" + healthState);\n         if (!healthState.equalsIgnoreCase(\"true\")\n             \u0026\u0026 !healthState.equalsIgnoreCase(\"false\")) {\n           String msg \u003d \"Error: You must specify either true or false to query on health\";\n           throw new BadRequestException(msg);\n         }\n         if (nodeInfo.isHealthy() !\u003d Boolean.parseBoolean(healthState)) {\n           continue;\n         }\n       }\n       if (isInactive) {\n         nodeInfo.setNodeHTTPAddress(EMPTY);\n       }\n       allNodes.add(nodeInfo);\n     }\n     return allNodes;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public NodesInfo getNodes(@QueryParam(\"state\") String filterState,\n      @QueryParam(\"healthy\") String healthState) {\n    init();\n    ResourceScheduler sched \u003d this.rm.getResourceScheduler();\n    if (sched \u003d\u003d null) {\n      throw new NotFoundException(\"Null ResourceScheduler instance\");\n    }\n    Collection\u003cRMNode\u003e rmNodes \u003d this.rm.getRMContext().getRMNodes().values();\n    boolean isInactive \u003d false;\n    if (filterState !\u003d null \u0026\u0026 !filterState.isEmpty()) {\n      NodeState nodeState \u003d NodeState.valueOf(filterState.toUpperCase());\n      switch (nodeState) {\n      case DECOMMISSIONED:\n      case LOST:\n      case REBOOTED:\n        rmNodes \u003d this.rm.getRMContext().getInactiveRMNodes().values();\n        isInactive \u003d true;\n        break;\n      }\n    }\n    NodesInfo allNodes \u003d new NodesInfo();\n    for (RMNode ni : rmNodes) {\n      NodeInfo nodeInfo \u003d new NodeInfo(ni, sched);\n      if (filterState !\u003d null) {\n        if (!(nodeInfo.getState().equalsIgnoreCase(filterState))) {\n          continue;\n        }\n      } else {\n        // No filter. User is asking for all nodes. Make sure you skip the\n        // unhealthy nodes.\n        if (ni.getState() \u003d\u003d NodeState.UNHEALTHY) {\n          continue;\n        }\n      }\n      if ((healthState !\u003d null) \u0026\u0026 (!healthState.isEmpty())) {\n        LOG.info(\"heatlh state is : \" + healthState);\n        if (!healthState.equalsIgnoreCase(\"true\")\n            \u0026\u0026 !healthState.equalsIgnoreCase(\"false\")) {\n          String msg \u003d \"Error: You must specify either true or false to query on health\";\n          throw new BadRequestException(msg);\n        }\n        if (nodeInfo.isHealthy() !\u003d Boolean.parseBoolean(healthState)) {\n          continue;\n        }\n      }\n      if (isInactive) {\n        nodeInfo.setNodeHTTPAddress(EMPTY);\n      }\n      allNodes.add(nodeInfo);\n    }\n    return allNodes;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/webapp/RMWebServices.java",
      "extendedDetails": {}
    },
    "e7583d816a69677bbaa4280deb58ea73dbc42cef": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3613. web service calls header contains 2 content types (tgraves)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1330560 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/04/12 2:13 PM",
      "commitName": "e7583d816a69677bbaa4280deb58ea73dbc42cef",
      "commitAuthor": "Thomas Graves",
      "commitDateOld": "02/04/12 2:06 PM",
      "commitNameOld": "01ce7ba3a4af867763e437ce46a4f5e1d6e5a6bf",
      "commitAuthorOld": "Robert Joseph Evans",
      "daysBetweenCommits": 23.0,
      "commitsBetweenForRepo": 193,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,51 +1,52 @@\n   public NodesInfo getNodes(@QueryParam(\"state\") String filterState,\n       @QueryParam(\"healthy\") String healthState) {\n+    init();\n     ResourceScheduler sched \u003d this.rm.getResourceScheduler();\n     if (sched \u003d\u003d null) {\n       throw new NotFoundException(\"Null ResourceScheduler instance\");\n     }\n     Collection\u003cRMNode\u003e rmNodes \u003d this.rm.getRMContext().getRMNodes().values();\n     boolean isInactive \u003d false;\n     if (filterState !\u003d null \u0026\u0026 !filterState.isEmpty()) {\n       RMNodeState nodeState \u003d RMNodeState.valueOf(filterState.toUpperCase());\n       switch (nodeState) {\n       case DECOMMISSIONED:\n       case LOST:\n       case REBOOTED:\n         rmNodes \u003d this.rm.getRMContext().getInactiveRMNodes().values();\n         isInactive \u003d true;\n         break;\n       }\n     }\n     NodesInfo allNodes \u003d new NodesInfo();\n     for (RMNode ni : rmNodes) {\n       NodeInfo nodeInfo \u003d new NodeInfo(ni, sched);\n       if (filterState !\u003d null) {\n         if (!(nodeInfo.getState().equalsIgnoreCase(filterState))) {\n           continue;\n         }\n       } else {\n         // No filter. User is asking for all nodes. Make sure you skip the\n         // unhealthy nodes.\n         if (ni.getState() \u003d\u003d RMNodeState.UNHEALTHY) {\n           continue;\n         }\n       }\n       if ((healthState !\u003d null) \u0026\u0026 (!healthState.isEmpty())) {\n         LOG.info(\"heatlh state is : \" + healthState);\n         if (!healthState.equalsIgnoreCase(\"true\")\n             \u0026\u0026 !healthState.equalsIgnoreCase(\"false\")) {\n           String msg \u003d \"Error: You must specify either true or false to query on health\";\n           throw new BadRequestException(msg);\n         }\n         if (nodeInfo.isHealthy() !\u003d Boolean.parseBoolean(healthState)) {\n           continue;\n         }\n       }\n       if (isInactive) {\n         nodeInfo.setNodeHTTPAddress(EMPTY);\n       }\n       allNodes.add(nodeInfo);\n     }\n     return allNodes;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public NodesInfo getNodes(@QueryParam(\"state\") String filterState,\n      @QueryParam(\"healthy\") String healthState) {\n    init();\n    ResourceScheduler sched \u003d this.rm.getResourceScheduler();\n    if (sched \u003d\u003d null) {\n      throw new NotFoundException(\"Null ResourceScheduler instance\");\n    }\n    Collection\u003cRMNode\u003e rmNodes \u003d this.rm.getRMContext().getRMNodes().values();\n    boolean isInactive \u003d false;\n    if (filterState !\u003d null \u0026\u0026 !filterState.isEmpty()) {\n      RMNodeState nodeState \u003d RMNodeState.valueOf(filterState.toUpperCase());\n      switch (nodeState) {\n      case DECOMMISSIONED:\n      case LOST:\n      case REBOOTED:\n        rmNodes \u003d this.rm.getRMContext().getInactiveRMNodes().values();\n        isInactive \u003d true;\n        break;\n      }\n    }\n    NodesInfo allNodes \u003d new NodesInfo();\n    for (RMNode ni : rmNodes) {\n      NodeInfo nodeInfo \u003d new NodeInfo(ni, sched);\n      if (filterState !\u003d null) {\n        if (!(nodeInfo.getState().equalsIgnoreCase(filterState))) {\n          continue;\n        }\n      } else {\n        // No filter. User is asking for all nodes. Make sure you skip the\n        // unhealthy nodes.\n        if (ni.getState() \u003d\u003d RMNodeState.UNHEALTHY) {\n          continue;\n        }\n      }\n      if ((healthState !\u003d null) \u0026\u0026 (!healthState.isEmpty())) {\n        LOG.info(\"heatlh state is : \" + healthState);\n        if (!healthState.equalsIgnoreCase(\"true\")\n            \u0026\u0026 !healthState.equalsIgnoreCase(\"false\")) {\n          String msg \u003d \"Error: You must specify either true or false to query on health\";\n          throw new BadRequestException(msg);\n        }\n        if (nodeInfo.isHealthy() !\u003d Boolean.parseBoolean(healthState)) {\n          continue;\n        }\n      }\n      if (isInactive) {\n        nodeInfo.setNodeHTTPAddress(EMPTY);\n      }\n      allNodes.add(nodeInfo);\n    }\n    return allNodes;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/webapp/RMWebServices.java",
      "extendedDetails": {}
    },
    "3343494d6c39883485d29c7439831ab3c1c7248d": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3760. Changed active nodes list to not contain unhealthy nodes on the webUI and metrics. (vinodkv)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1240421 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/02/12 5:03 PM",
      "commitName": "3343494d6c39883485d29c7439831ab3c1c7248d",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "26/01/12 2:56 PM",
      "commitNameOld": "3cdc100369ce920701fdddae12d7f7247332b3f3",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 8.09,
      "commitsBetweenForRepo": 63,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,45 +1,51 @@\n   public NodesInfo getNodes(@QueryParam(\"state\") String filterState,\n       @QueryParam(\"healthy\") String healthState) {\n     ResourceScheduler sched \u003d this.rm.getResourceScheduler();\n     if (sched \u003d\u003d null) {\n       throw new NotFoundException(\"Null ResourceScheduler instance\");\n     }\n     Collection\u003cRMNode\u003e rmNodes \u003d this.rm.getRMContext().getRMNodes().values();\n     boolean isInactive \u003d false;\n     if (filterState !\u003d null \u0026\u0026 !filterState.isEmpty()) {\n       RMNodeState nodeState \u003d RMNodeState.valueOf(filterState.toUpperCase());\n       switch (nodeState) {\n       case DECOMMISSIONED:\n       case LOST:\n       case REBOOTED:\n         rmNodes \u003d this.rm.getRMContext().getInactiveRMNodes().values();\n         isInactive \u003d true;\n         break;\n       }\n     }\n     NodesInfo allNodes \u003d new NodesInfo();\n     for (RMNode ni : rmNodes) {\n       NodeInfo nodeInfo \u003d new NodeInfo(ni, sched);\n       if (filterState !\u003d null) {\n         if (!(nodeInfo.getState().equalsIgnoreCase(filterState))) {\n           continue;\n         }\n+      } else {\n+        // No filter. User is asking for all nodes. Make sure you skip the\n+        // unhealthy nodes.\n+        if (ni.getState() \u003d\u003d RMNodeState.UNHEALTHY) {\n+          continue;\n+        }\n       }\n       if ((healthState !\u003d null) \u0026\u0026 (!healthState.isEmpty())) {\n         LOG.info(\"heatlh state is : \" + healthState);\n         if (!healthState.equalsIgnoreCase(\"true\")\n             \u0026\u0026 !healthState.equalsIgnoreCase(\"false\")) {\n           String msg \u003d \"Error: You must specify either true or false to query on health\";\n           throw new BadRequestException(msg);\n         }\n         if (nodeInfo.isHealthy() !\u003d Boolean.parseBoolean(healthState)) {\n           continue;\n         }\n       }\n       if (isInactive) {\n         nodeInfo.setNodeHTTPAddress(EMPTY);\n       }\n       allNodes.add(nodeInfo);\n     }\n     return allNodes;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public NodesInfo getNodes(@QueryParam(\"state\") String filterState,\n      @QueryParam(\"healthy\") String healthState) {\n    ResourceScheduler sched \u003d this.rm.getResourceScheduler();\n    if (sched \u003d\u003d null) {\n      throw new NotFoundException(\"Null ResourceScheduler instance\");\n    }\n    Collection\u003cRMNode\u003e rmNodes \u003d this.rm.getRMContext().getRMNodes().values();\n    boolean isInactive \u003d false;\n    if (filterState !\u003d null \u0026\u0026 !filterState.isEmpty()) {\n      RMNodeState nodeState \u003d RMNodeState.valueOf(filterState.toUpperCase());\n      switch (nodeState) {\n      case DECOMMISSIONED:\n      case LOST:\n      case REBOOTED:\n        rmNodes \u003d this.rm.getRMContext().getInactiveRMNodes().values();\n        isInactive \u003d true;\n        break;\n      }\n    }\n    NodesInfo allNodes \u003d new NodesInfo();\n    for (RMNode ni : rmNodes) {\n      NodeInfo nodeInfo \u003d new NodeInfo(ni, sched);\n      if (filterState !\u003d null) {\n        if (!(nodeInfo.getState().equalsIgnoreCase(filterState))) {\n          continue;\n        }\n      } else {\n        // No filter. User is asking for all nodes. Make sure you skip the\n        // unhealthy nodes.\n        if (ni.getState() \u003d\u003d RMNodeState.UNHEALTHY) {\n          continue;\n        }\n      }\n      if ((healthState !\u003d null) \u0026\u0026 (!healthState.isEmpty())) {\n        LOG.info(\"heatlh state is : \" + healthState);\n        if (!healthState.equalsIgnoreCase(\"true\")\n            \u0026\u0026 !healthState.equalsIgnoreCase(\"false\")) {\n          String msg \u003d \"Error: You must specify either true or false to query on health\";\n          throw new BadRequestException(msg);\n        }\n        if (nodeInfo.isHealthy() !\u003d Boolean.parseBoolean(healthState)) {\n          continue;\n        }\n      }\n      if (isInactive) {\n        nodeInfo.setNodeHTTPAddress(EMPTY);\n      }\n      allNodes.add(nodeInfo);\n    }\n    return allNodes;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/webapp/RMWebServices.java",
      "extendedDetails": {}
    },
    "3cdc100369ce920701fdddae12d7f7247332b3f3": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3360. Added information about lost/rebooted/decommissioned nodes on the webapps. Contributed by Bhallamudi Venkata Siva Kamesh and Jason Lowe.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1236433 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "26/01/12 2:56 PM",
      "commitName": "3cdc100369ce920701fdddae12d7f7247332b3f3",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "13/12/11 3:05 PM",
      "commitNameOld": "0ea8570be578be60e2f32849900a1c50506d78d3",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 43.99,
      "commitsBetweenForRepo": 201,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,31 +1,45 @@\n   public NodesInfo getNodes(@QueryParam(\"state\") String filterState,\n       @QueryParam(\"healthy\") String healthState) {\n     ResourceScheduler sched \u003d this.rm.getResourceScheduler();\n     if (sched \u003d\u003d null) {\n       throw new NotFoundException(\"Null ResourceScheduler instance\");\n     }\n-\n+    Collection\u003cRMNode\u003e rmNodes \u003d this.rm.getRMContext().getRMNodes().values();\n+    boolean isInactive \u003d false;\n+    if (filterState !\u003d null \u0026\u0026 !filterState.isEmpty()) {\n+      RMNodeState nodeState \u003d RMNodeState.valueOf(filterState.toUpperCase());\n+      switch (nodeState) {\n+      case DECOMMISSIONED:\n+      case LOST:\n+      case REBOOTED:\n+        rmNodes \u003d this.rm.getRMContext().getInactiveRMNodes().values();\n+        isInactive \u003d true;\n+        break;\n+      }\n+    }\n     NodesInfo allNodes \u003d new NodesInfo();\n-    for (RMNode ni : this.rm.getRMContext().getRMNodes().values()) {\n+    for (RMNode ni : rmNodes) {\n       NodeInfo nodeInfo \u003d new NodeInfo(ni, sched);\n       if (filterState !\u003d null) {\n-        RMNodeState.valueOf(filterState);\n         if (!(nodeInfo.getState().equalsIgnoreCase(filterState))) {\n           continue;\n         }\n       }\n       if ((healthState !\u003d null) \u0026\u0026 (!healthState.isEmpty())) {\n         LOG.info(\"heatlh state is : \" + healthState);\n         if (!healthState.equalsIgnoreCase(\"true\")\n             \u0026\u0026 !healthState.equalsIgnoreCase(\"false\")) {\n           String msg \u003d \"Error: You must specify either true or false to query on health\";\n           throw new BadRequestException(msg);\n         }\n         if (nodeInfo.isHealthy() !\u003d Boolean.parseBoolean(healthState)) {\n           continue;\n         }\n       }\n+      if (isInactive) {\n+        nodeInfo.setNodeHTTPAddress(EMPTY);\n+      }\n       allNodes.add(nodeInfo);\n     }\n     return allNodes;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public NodesInfo getNodes(@QueryParam(\"state\") String filterState,\n      @QueryParam(\"healthy\") String healthState) {\n    ResourceScheduler sched \u003d this.rm.getResourceScheduler();\n    if (sched \u003d\u003d null) {\n      throw new NotFoundException(\"Null ResourceScheduler instance\");\n    }\n    Collection\u003cRMNode\u003e rmNodes \u003d this.rm.getRMContext().getRMNodes().values();\n    boolean isInactive \u003d false;\n    if (filterState !\u003d null \u0026\u0026 !filterState.isEmpty()) {\n      RMNodeState nodeState \u003d RMNodeState.valueOf(filterState.toUpperCase());\n      switch (nodeState) {\n      case DECOMMISSIONED:\n      case LOST:\n      case REBOOTED:\n        rmNodes \u003d this.rm.getRMContext().getInactiveRMNodes().values();\n        isInactive \u003d true;\n        break;\n      }\n    }\n    NodesInfo allNodes \u003d new NodesInfo();\n    for (RMNode ni : rmNodes) {\n      NodeInfo nodeInfo \u003d new NodeInfo(ni, sched);\n      if (filterState !\u003d null) {\n        if (!(nodeInfo.getState().equalsIgnoreCase(filterState))) {\n          continue;\n        }\n      }\n      if ((healthState !\u003d null) \u0026\u0026 (!healthState.isEmpty())) {\n        LOG.info(\"heatlh state is : \" + healthState);\n        if (!healthState.equalsIgnoreCase(\"true\")\n            \u0026\u0026 !healthState.equalsIgnoreCase(\"false\")) {\n          String msg \u003d \"Error: You must specify either true or false to query on health\";\n          throw new BadRequestException(msg);\n        }\n        if (nodeInfo.isHealthy() !\u003d Boolean.parseBoolean(healthState)) {\n          continue;\n        }\n      }\n      if (isInactive) {\n        nodeInfo.setNodeHTTPAddress(EMPTY);\n      }\n      allNodes.add(nodeInfo);\n    }\n    return allNodes;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/webapp/RMWebServices.java",
      "extendedDetails": {}
    },
    "0ea8570be578be60e2f32849900a1c50506d78d3": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-2863. Support web services for YARN and MR components. (Thomas Graves via vinodkv)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1213975 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "13/12/11 3:05 PM",
      "commitName": "0ea8570be578be60e2f32849900a1c50506d78d3",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,31 @@\n+  public NodesInfo getNodes(@QueryParam(\"state\") String filterState,\n+      @QueryParam(\"healthy\") String healthState) {\n+    ResourceScheduler sched \u003d this.rm.getResourceScheduler();\n+    if (sched \u003d\u003d null) {\n+      throw new NotFoundException(\"Null ResourceScheduler instance\");\n+    }\n+\n+    NodesInfo allNodes \u003d new NodesInfo();\n+    for (RMNode ni : this.rm.getRMContext().getRMNodes().values()) {\n+      NodeInfo nodeInfo \u003d new NodeInfo(ni, sched);\n+      if (filterState !\u003d null) {\n+        RMNodeState.valueOf(filterState);\n+        if (!(nodeInfo.getState().equalsIgnoreCase(filterState))) {\n+          continue;\n+        }\n+      }\n+      if ((healthState !\u003d null) \u0026\u0026 (!healthState.isEmpty())) {\n+        LOG.info(\"heatlh state is : \" + healthState);\n+        if (!healthState.equalsIgnoreCase(\"true\")\n+            \u0026\u0026 !healthState.equalsIgnoreCase(\"false\")) {\n+          String msg \u003d \"Error: You must specify either true or false to query on health\";\n+          throw new BadRequestException(msg);\n+        }\n+        if (nodeInfo.isHealthy() !\u003d Boolean.parseBoolean(healthState)) {\n+          continue;\n+        }\n+      }\n+      allNodes.add(nodeInfo);\n+    }\n+    return allNodes;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public NodesInfo getNodes(@QueryParam(\"state\") String filterState,\n      @QueryParam(\"healthy\") String healthState) {\n    ResourceScheduler sched \u003d this.rm.getResourceScheduler();\n    if (sched \u003d\u003d null) {\n      throw new NotFoundException(\"Null ResourceScheduler instance\");\n    }\n\n    NodesInfo allNodes \u003d new NodesInfo();\n    for (RMNode ni : this.rm.getRMContext().getRMNodes().values()) {\n      NodeInfo nodeInfo \u003d new NodeInfo(ni, sched);\n      if (filterState !\u003d null) {\n        RMNodeState.valueOf(filterState);\n        if (!(nodeInfo.getState().equalsIgnoreCase(filterState))) {\n          continue;\n        }\n      }\n      if ((healthState !\u003d null) \u0026\u0026 (!healthState.isEmpty())) {\n        LOG.info(\"heatlh state is : \" + healthState);\n        if (!healthState.equalsIgnoreCase(\"true\")\n            \u0026\u0026 !healthState.equalsIgnoreCase(\"false\")) {\n          String msg \u003d \"Error: You must specify either true or false to query on health\";\n          throw new BadRequestException(msg);\n        }\n        if (nodeInfo.isHealthy() !\u003d Boolean.parseBoolean(healthState)) {\n          continue;\n        }\n      }\n      allNodes.add(nodeInfo);\n    }\n    return allNodes;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/webapp/RMWebServices.java"
    }
  }
}