{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FSImageHandler.java",
  "functionName": "channelRead0",
  "functionId": "channelRead0___ctx-ChannelHandlerContext__request-HttpRequest",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/offlineImageViewer/FSImageHandler.java",
  "functionStartLine": 77,
  "functionEndLine": 132,
  "numCommitsSeen": 16,
  "timeTaken": 2924,
  "changeHistory": [
    "6aa63452b358cf0ba8687ec89b5d6c3a99649bc5",
    "88da9f6b6782423acd8ab7eb7d938720de7f3c0f",
    "40f815131e822f5b7a8e6a6827f4b85b31220c43",
    "bc433908d35758ff0a7225cd6f5662959ef4d294",
    "ada233b7cd7db39e609bb57e487fee8cec59cd48",
    "b9f6d0c956f0278c8b9b83e05b523a442a730ebb",
    "675bca2968700d3627449700b827c3771827cef8"
  ],
  "changeHistoryShort": {
    "6aa63452b358cf0ba8687ec89b5d6c3a99649bc5": "Ybodychange",
    "88da9f6b6782423acd8ab7eb7d938720de7f3c0f": "Ybodychange",
    "40f815131e822f5b7a8e6a6827f4b85b31220c43": "Ybodychange",
    "bc433908d35758ff0a7225cd6f5662959ef4d294": "Ybodychange",
    "ada233b7cd7db39e609bb57e487fee8cec59cd48": "Ybodychange",
    "b9f6d0c956f0278c8b9b83e05b523a442a730ebb": "Ybodychange",
    "675bca2968700d3627449700b827c3771827cef8": "Yintroduced"
  },
  "changeHistoryDetails": {
    "6aa63452b358cf0ba8687ec89b5d6c3a99649bc5": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14242. OIV WebImageViewer: NPE when param op is not specified. Contributed by Siyao Meng.\n\nSigned-off-by: Wei-Chiu Chuang \u003cweichiu@apache.org\u003e\n",
      "commitDate": "06/02/19 12:19 PM",
      "commitName": "6aa63452b358cf0ba8687ec89b5d6c3a99649bc5",
      "commitAuthor": "Siyao Meng",
      "commitDateOld": "06/09/18 2:48 PM",
      "commitNameOld": "eca1a4bfe952fc184fe90dde50bac9b0e5293568",
      "commitAuthorOld": "Giovanni Matteo Fumarola",
      "daysBetweenCommits": 152.94,
      "commitsBetweenForRepo": 1224,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,51 +1,56 @@\n   public void channelRead0(ChannelHandlerContext ctx, HttpRequest request)\n       throws Exception {\n     if (request.getMethod() !\u003d HttpMethod.GET) {\n       DefaultHttpResponse resp \u003d new DefaultHttpResponse(HTTP_1_1,\n           METHOD_NOT_ALLOWED);\n       resp.headers().set(CONNECTION, CLOSE);\n       ctx.write(resp).addListener(ChannelFutureListener.CLOSE);\n       return;\n     }\n \n     QueryStringDecoder decoder \u003d new QueryStringDecoder(request.getUri());\n+    // check path. throw exception if path doesn\u0027t start with WEBHDFS_PREFIX\n+    String path \u003d getPath(decoder);\n     final String op \u003d getOp(decoder);\n+    // check null op\n+    if (op \u003d\u003d null) {\n+      throw new IllegalArgumentException(\"Param op must be specified.\");\n+    }\n \n     final String content;\n-    String path \u003d getPath(decoder);\n     switch (op) {\n     case \"GETFILESTATUS\":\n       content \u003d image.getFileStatus(path);\n       break;\n     case \"LISTSTATUS\":\n       content \u003d image.listStatus(path);\n       break;\n     case \"GETACLSTATUS\":\n       content \u003d image.getAclStatus(path);\n       break;\n     case \"GETXATTRS\":\n       List\u003cString\u003e names \u003d getXattrNames(decoder);\n       String encoder \u003d getEncoder(decoder);\n       content \u003d image.getXAttrs(path, names, encoder);\n       break;\n     case \"LISTXATTRS\":\n       content \u003d image.listXAttrs(path);\n       break;\n     case \"GETCONTENTSUMMARY\":\n       content \u003d image.getContentSummary(path);\n       break;\n     default:\n       throw new IllegalArgumentException(\"Invalid value for webhdfs parameter\"\n           + \" \\\"op\\\"\");\n     }\n \n     LOG.info(\"op\u003d\" + op + \" target\u003d\" + path);\n \n     DefaultFullHttpResponse resp \u003d new DefaultFullHttpResponse(HTTP_1_1,\n         HttpResponseStatus.OK, Unpooled.wrappedBuffer(content\n             .getBytes(Charsets.UTF_8)));\n     resp.headers().set(CONTENT_TYPE, APPLICATION_JSON_UTF8);\n     resp.headers().set(CONTENT_LENGTH, resp.content().readableBytes());\n     resp.headers().set(CONNECTION, CLOSE);\n     ctx.write(resp).addListener(ChannelFutureListener.CLOSE);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void channelRead0(ChannelHandlerContext ctx, HttpRequest request)\n      throws Exception {\n    if (request.getMethod() !\u003d HttpMethod.GET) {\n      DefaultHttpResponse resp \u003d new DefaultHttpResponse(HTTP_1_1,\n          METHOD_NOT_ALLOWED);\n      resp.headers().set(CONNECTION, CLOSE);\n      ctx.write(resp).addListener(ChannelFutureListener.CLOSE);\n      return;\n    }\n\n    QueryStringDecoder decoder \u003d new QueryStringDecoder(request.getUri());\n    // check path. throw exception if path doesn\u0027t start with WEBHDFS_PREFIX\n    String path \u003d getPath(decoder);\n    final String op \u003d getOp(decoder);\n    // check null op\n    if (op \u003d\u003d null) {\n      throw new IllegalArgumentException(\"Param op must be specified.\");\n    }\n\n    final String content;\n    switch (op) {\n    case \"GETFILESTATUS\":\n      content \u003d image.getFileStatus(path);\n      break;\n    case \"LISTSTATUS\":\n      content \u003d image.listStatus(path);\n      break;\n    case \"GETACLSTATUS\":\n      content \u003d image.getAclStatus(path);\n      break;\n    case \"GETXATTRS\":\n      List\u003cString\u003e names \u003d getXattrNames(decoder);\n      String encoder \u003d getEncoder(decoder);\n      content \u003d image.getXAttrs(path, names, encoder);\n      break;\n    case \"LISTXATTRS\":\n      content \u003d image.listXAttrs(path);\n      break;\n    case \"GETCONTENTSUMMARY\":\n      content \u003d image.getContentSummary(path);\n      break;\n    default:\n      throw new IllegalArgumentException(\"Invalid value for webhdfs parameter\"\n          + \" \\\"op\\\"\");\n    }\n\n    LOG.info(\"op\u003d\" + op + \" target\u003d\" + path);\n\n    DefaultFullHttpResponse resp \u003d new DefaultFullHttpResponse(HTTP_1_1,\n        HttpResponseStatus.OK, Unpooled.wrappedBuffer(content\n            .getBytes(Charsets.UTF_8)));\n    resp.headers().set(CONTENT_TYPE, APPLICATION_JSON_UTF8);\n    resp.headers().set(CONTENT_LENGTH, resp.content().readableBytes());\n    resp.headers().set(CONNECTION, CLOSE);\n    ctx.write(resp).addListener(ChannelFutureListener.CLOSE);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/offlineImageViewer/FSImageHandler.java",
      "extendedDetails": {}
    },
    "88da9f6b6782423acd8ab7eb7d938720de7f3c0f": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HDFS-8377. Support HTTP/2 in datanode. Contributed by Duo Zhang.\"\n\nThis reverts commit ada233b7cd7db39e609bb57e487fee8cec59cd48.\n",
      "commitDate": "26/01/17 1:42 PM",
      "commitName": "88da9f6b6782423acd8ab7eb7d938720de7f3c0f",
      "commitAuthor": "Xiao Chen",
      "commitDateOld": "12/08/15 7:31 PM",
      "commitNameOld": "40f815131e822f5b7a8e6a6827f4b85b31220c43",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 532.8,
      "commitsBetweenForRepo": 3659,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,51 +1,51 @@\n   public void channelRead0(ChannelHandlerContext ctx, HttpRequest request)\n       throws Exception {\n-    if (request.method() !\u003d HttpMethod.GET) {\n+    if (request.getMethod() !\u003d HttpMethod.GET) {\n       DefaultHttpResponse resp \u003d new DefaultHttpResponse(HTTP_1_1,\n           METHOD_NOT_ALLOWED);\n       resp.headers().set(CONNECTION, CLOSE);\n       ctx.write(resp).addListener(ChannelFutureListener.CLOSE);\n       return;\n     }\n \n-    QueryStringDecoder decoder \u003d new QueryStringDecoder(request.uri());\n+    QueryStringDecoder decoder \u003d new QueryStringDecoder(request.getUri());\n     final String op \u003d getOp(decoder);\n \n     final String content;\n     String path \u003d getPath(decoder);\n     switch (op) {\n     case \"GETFILESTATUS\":\n       content \u003d image.getFileStatus(path);\n       break;\n     case \"LISTSTATUS\":\n       content \u003d image.listStatus(path);\n       break;\n     case \"GETACLSTATUS\":\n       content \u003d image.getAclStatus(path);\n       break;\n     case \"GETXATTRS\":\n       List\u003cString\u003e names \u003d getXattrNames(decoder);\n       String encoder \u003d getEncoder(decoder);\n       content \u003d image.getXAttrs(path, names, encoder);\n       break;\n     case \"LISTXATTRS\":\n       content \u003d image.listXAttrs(path);\n       break;\n     case \"GETCONTENTSUMMARY\":\n       content \u003d image.getContentSummary(path);\n       break;\n     default:\n       throw new IllegalArgumentException(\"Invalid value for webhdfs parameter\"\n           + \" \\\"op\\\"\");\n     }\n \n     LOG.info(\"op\u003d\" + op + \" target\u003d\" + path);\n \n     DefaultFullHttpResponse resp \u003d new DefaultFullHttpResponse(HTTP_1_1,\n         HttpResponseStatus.OK, Unpooled.wrappedBuffer(content\n             .getBytes(Charsets.UTF_8)));\n     resp.headers().set(CONTENT_TYPE, APPLICATION_JSON_UTF8);\n     resp.headers().set(CONTENT_LENGTH, resp.content().readableBytes());\n     resp.headers().set(CONNECTION, CLOSE);\n     ctx.write(resp).addListener(ChannelFutureListener.CLOSE);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void channelRead0(ChannelHandlerContext ctx, HttpRequest request)\n      throws Exception {\n    if (request.getMethod() !\u003d HttpMethod.GET) {\n      DefaultHttpResponse resp \u003d new DefaultHttpResponse(HTTP_1_1,\n          METHOD_NOT_ALLOWED);\n      resp.headers().set(CONNECTION, CLOSE);\n      ctx.write(resp).addListener(ChannelFutureListener.CLOSE);\n      return;\n    }\n\n    QueryStringDecoder decoder \u003d new QueryStringDecoder(request.getUri());\n    final String op \u003d getOp(decoder);\n\n    final String content;\n    String path \u003d getPath(decoder);\n    switch (op) {\n    case \"GETFILESTATUS\":\n      content \u003d image.getFileStatus(path);\n      break;\n    case \"LISTSTATUS\":\n      content \u003d image.listStatus(path);\n      break;\n    case \"GETACLSTATUS\":\n      content \u003d image.getAclStatus(path);\n      break;\n    case \"GETXATTRS\":\n      List\u003cString\u003e names \u003d getXattrNames(decoder);\n      String encoder \u003d getEncoder(decoder);\n      content \u003d image.getXAttrs(path, names, encoder);\n      break;\n    case \"LISTXATTRS\":\n      content \u003d image.listXAttrs(path);\n      break;\n    case \"GETCONTENTSUMMARY\":\n      content \u003d image.getContentSummary(path);\n      break;\n    default:\n      throw new IllegalArgumentException(\"Invalid value for webhdfs parameter\"\n          + \" \\\"op\\\"\");\n    }\n\n    LOG.info(\"op\u003d\" + op + \" target\u003d\" + path);\n\n    DefaultFullHttpResponse resp \u003d new DefaultFullHttpResponse(HTTP_1_1,\n        HttpResponseStatus.OK, Unpooled.wrappedBuffer(content\n            .getBytes(Charsets.UTF_8)));\n    resp.headers().set(CONTENT_TYPE, APPLICATION_JSON_UTF8);\n    resp.headers().set(CONTENT_LENGTH, resp.content().readableBytes());\n    resp.headers().set(CONNECTION, CLOSE);\n    ctx.write(resp).addListener(ChannelFutureListener.CLOSE);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/offlineImageViewer/FSImageHandler.java",
      "extendedDetails": {}
    },
    "40f815131e822f5b7a8e6a6827f4b85b31220c43": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8622. Implement GETCONTENTSUMMARY operation for WebImageViewer. Contributed by Jagadesh Kiran N.\n",
      "commitDate": "12/08/15 7:31 PM",
      "commitName": "40f815131e822f5b7a8e6a6827f4b85b31220c43",
      "commitAuthor": "Akira Ajisaka",
      "commitDateOld": "25/06/15 8:20 AM",
      "commitNameOld": "bc433908d35758ff0a7225cd6f5662959ef4d294",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 48.47,
      "commitsBetweenForRepo": 279,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,48 +1,51 @@\n   public void channelRead0(ChannelHandlerContext ctx, HttpRequest request)\n       throws Exception {\n     if (request.method() !\u003d HttpMethod.GET) {\n       DefaultHttpResponse resp \u003d new DefaultHttpResponse(HTTP_1_1,\n           METHOD_NOT_ALLOWED);\n       resp.headers().set(CONNECTION, CLOSE);\n       ctx.write(resp).addListener(ChannelFutureListener.CLOSE);\n       return;\n     }\n \n     QueryStringDecoder decoder \u003d new QueryStringDecoder(request.uri());\n     final String op \u003d getOp(decoder);\n \n     final String content;\n     String path \u003d getPath(decoder);\n     switch (op) {\n     case \"GETFILESTATUS\":\n       content \u003d image.getFileStatus(path);\n       break;\n     case \"LISTSTATUS\":\n       content \u003d image.listStatus(path);\n       break;\n     case \"GETACLSTATUS\":\n       content \u003d image.getAclStatus(path);\n       break;\n     case \"GETXATTRS\":\n       List\u003cString\u003e names \u003d getXattrNames(decoder);\n       String encoder \u003d getEncoder(decoder);\n       content \u003d image.getXAttrs(path, names, encoder);\n       break;\n     case \"LISTXATTRS\":\n       content \u003d image.listXAttrs(path);\n       break;\n+    case \"GETCONTENTSUMMARY\":\n+      content \u003d image.getContentSummary(path);\n+      break;\n     default:\n       throw new IllegalArgumentException(\"Invalid value for webhdfs parameter\"\n           + \" \\\"op\\\"\");\n     }\n \n     LOG.info(\"op\u003d\" + op + \" target\u003d\" + path);\n \n     DefaultFullHttpResponse resp \u003d new DefaultFullHttpResponse(HTTP_1_1,\n         HttpResponseStatus.OK, Unpooled.wrappedBuffer(content\n             .getBytes(Charsets.UTF_8)));\n     resp.headers().set(CONTENT_TYPE, APPLICATION_JSON_UTF8);\n     resp.headers().set(CONTENT_LENGTH, resp.content().readableBytes());\n     resp.headers().set(CONNECTION, CLOSE);\n     ctx.write(resp).addListener(ChannelFutureListener.CLOSE);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void channelRead0(ChannelHandlerContext ctx, HttpRequest request)\n      throws Exception {\n    if (request.method() !\u003d HttpMethod.GET) {\n      DefaultHttpResponse resp \u003d new DefaultHttpResponse(HTTP_1_1,\n          METHOD_NOT_ALLOWED);\n      resp.headers().set(CONNECTION, CLOSE);\n      ctx.write(resp).addListener(ChannelFutureListener.CLOSE);\n      return;\n    }\n\n    QueryStringDecoder decoder \u003d new QueryStringDecoder(request.uri());\n    final String op \u003d getOp(decoder);\n\n    final String content;\n    String path \u003d getPath(decoder);\n    switch (op) {\n    case \"GETFILESTATUS\":\n      content \u003d image.getFileStatus(path);\n      break;\n    case \"LISTSTATUS\":\n      content \u003d image.listStatus(path);\n      break;\n    case \"GETACLSTATUS\":\n      content \u003d image.getAclStatus(path);\n      break;\n    case \"GETXATTRS\":\n      List\u003cString\u003e names \u003d getXattrNames(decoder);\n      String encoder \u003d getEncoder(decoder);\n      content \u003d image.getXAttrs(path, names, encoder);\n      break;\n    case \"LISTXATTRS\":\n      content \u003d image.listXAttrs(path);\n      break;\n    case \"GETCONTENTSUMMARY\":\n      content \u003d image.getContentSummary(path);\n      break;\n    default:\n      throw new IllegalArgumentException(\"Invalid value for webhdfs parameter\"\n          + \" \\\"op\\\"\");\n    }\n\n    LOG.info(\"op\u003d\" + op + \" target\u003d\" + path);\n\n    DefaultFullHttpResponse resp \u003d new DefaultFullHttpResponse(HTTP_1_1,\n        HttpResponseStatus.OK, Unpooled.wrappedBuffer(content\n            .getBytes(Charsets.UTF_8)));\n    resp.headers().set(CONTENT_TYPE, APPLICATION_JSON_UTF8);\n    resp.headers().set(CONTENT_LENGTH, resp.content().readableBytes());\n    resp.headers().set(CONNECTION, CLOSE);\n    ctx.write(resp).addListener(ChannelFutureListener.CLOSE);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/offlineImageViewer/FSImageHandler.java",
      "extendedDetails": {}
    },
    "bc433908d35758ff0a7225cd6f5662959ef4d294": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8462. Implement GETXATTRS and LISTXATTRS operations for WebImageViewer. Contributed by Jagadesh Kiran N.\n",
      "commitDate": "25/06/15 8:20 AM",
      "commitName": "bc433908d35758ff0a7225cd6f5662959ef4d294",
      "commitAuthor": "Akira Ajisaka",
      "commitDateOld": "24/05/15 10:30 PM",
      "commitNameOld": "ada233b7cd7db39e609bb57e487fee8cec59cd48",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 31.41,
      "commitsBetweenForRepo": 220,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,48 @@\n   public void channelRead0(ChannelHandlerContext ctx, HttpRequest request)\n-          throws Exception {\n+      throws Exception {\n     if (request.method() !\u003d HttpMethod.GET) {\n       DefaultHttpResponse resp \u003d new DefaultHttpResponse(HTTP_1_1,\n-        METHOD_NOT_ALLOWED);\n+          METHOD_NOT_ALLOWED);\n       resp.headers().set(CONNECTION, CLOSE);\n       ctx.write(resp).addListener(ChannelFutureListener.CLOSE);\n       return;\n     }\n \n     QueryStringDecoder decoder \u003d new QueryStringDecoder(request.uri());\n     final String op \u003d getOp(decoder);\n \n     final String content;\n     String path \u003d getPath(decoder);\n     switch (op) {\n-      case \"GETFILESTATUS\":\n-        content \u003d image.getFileStatus(path);\n-        break;\n-      case \"LISTSTATUS\":\n-        content \u003d image.listStatus(path);\n-        break;\n-      case \"GETACLSTATUS\":\n-        content \u003d image.getAclStatus(path);\n-        break;\n-      default:\n-        throw new IllegalArgumentException(\n-            \"Invalid value for webhdfs parameter\" + \" \\\"op\\\"\");\n+    case \"GETFILESTATUS\":\n+      content \u003d image.getFileStatus(path);\n+      break;\n+    case \"LISTSTATUS\":\n+      content \u003d image.listStatus(path);\n+      break;\n+    case \"GETACLSTATUS\":\n+      content \u003d image.getAclStatus(path);\n+      break;\n+    case \"GETXATTRS\":\n+      List\u003cString\u003e names \u003d getXattrNames(decoder);\n+      String encoder \u003d getEncoder(decoder);\n+      content \u003d image.getXAttrs(path, names, encoder);\n+      break;\n+    case \"LISTXATTRS\":\n+      content \u003d image.listXAttrs(path);\n+      break;\n+    default:\n+      throw new IllegalArgumentException(\"Invalid value for webhdfs parameter\"\n+          + \" \\\"op\\\"\");\n     }\n \n     LOG.info(\"op\u003d\" + op + \" target\u003d\" + path);\n \n-    DefaultFullHttpResponse resp \u003d new DefaultFullHttpResponse(\n-            HTTP_1_1, HttpResponseStatus.OK,\n-            Unpooled.wrappedBuffer(content.getBytes(Charsets.UTF_8)));\n+    DefaultFullHttpResponse resp \u003d new DefaultFullHttpResponse(HTTP_1_1,\n+        HttpResponseStatus.OK, Unpooled.wrappedBuffer(content\n+            .getBytes(Charsets.UTF_8)));\n     resp.headers().set(CONTENT_TYPE, APPLICATION_JSON_UTF8);\n     resp.headers().set(CONTENT_LENGTH, resp.content().readableBytes());\n     resp.headers().set(CONNECTION, CLOSE);\n     ctx.write(resp).addListener(ChannelFutureListener.CLOSE);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void channelRead0(ChannelHandlerContext ctx, HttpRequest request)\n      throws Exception {\n    if (request.method() !\u003d HttpMethod.GET) {\n      DefaultHttpResponse resp \u003d new DefaultHttpResponse(HTTP_1_1,\n          METHOD_NOT_ALLOWED);\n      resp.headers().set(CONNECTION, CLOSE);\n      ctx.write(resp).addListener(ChannelFutureListener.CLOSE);\n      return;\n    }\n\n    QueryStringDecoder decoder \u003d new QueryStringDecoder(request.uri());\n    final String op \u003d getOp(decoder);\n\n    final String content;\n    String path \u003d getPath(decoder);\n    switch (op) {\n    case \"GETFILESTATUS\":\n      content \u003d image.getFileStatus(path);\n      break;\n    case \"LISTSTATUS\":\n      content \u003d image.listStatus(path);\n      break;\n    case \"GETACLSTATUS\":\n      content \u003d image.getAclStatus(path);\n      break;\n    case \"GETXATTRS\":\n      List\u003cString\u003e names \u003d getXattrNames(decoder);\n      String encoder \u003d getEncoder(decoder);\n      content \u003d image.getXAttrs(path, names, encoder);\n      break;\n    case \"LISTXATTRS\":\n      content \u003d image.listXAttrs(path);\n      break;\n    default:\n      throw new IllegalArgumentException(\"Invalid value for webhdfs parameter\"\n          + \" \\\"op\\\"\");\n    }\n\n    LOG.info(\"op\u003d\" + op + \" target\u003d\" + path);\n\n    DefaultFullHttpResponse resp \u003d new DefaultFullHttpResponse(HTTP_1_1,\n        HttpResponseStatus.OK, Unpooled.wrappedBuffer(content\n            .getBytes(Charsets.UTF_8)));\n    resp.headers().set(CONTENT_TYPE, APPLICATION_JSON_UTF8);\n    resp.headers().set(CONTENT_LENGTH, resp.content().readableBytes());\n    resp.headers().set(CONNECTION, CLOSE);\n    ctx.write(resp).addListener(ChannelFutureListener.CLOSE);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/offlineImageViewer/FSImageHandler.java",
      "extendedDetails": {}
    },
    "ada233b7cd7db39e609bb57e487fee8cec59cd48": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8377. Support HTTP/2 in datanode. Contributed by Duo Zhang.\n",
      "commitDate": "24/05/15 10:30 PM",
      "commitName": "ada233b7cd7db39e609bb57e487fee8cec59cd48",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "02/03/15 9:17 PM",
      "commitNameOld": "d1c6accb6f87b08975175580e15f1ff1fe29ab04",
      "commitAuthorOld": "Tsuyoshi Ozawa",
      "daysBetweenCommits": 83.01,
      "commitsBetweenForRepo": 791,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,40 @@\n   public void channelRead0(ChannelHandlerContext ctx, HttpRequest request)\n           throws Exception {\n-    if (request.getMethod() !\u003d HttpMethod.GET) {\n+    if (request.method() !\u003d HttpMethod.GET) {\n       DefaultHttpResponse resp \u003d new DefaultHttpResponse(HTTP_1_1,\n         METHOD_NOT_ALLOWED);\n       resp.headers().set(CONNECTION, CLOSE);\n       ctx.write(resp).addListener(ChannelFutureListener.CLOSE);\n       return;\n     }\n \n-    QueryStringDecoder decoder \u003d new QueryStringDecoder(request.getUri());\n+    QueryStringDecoder decoder \u003d new QueryStringDecoder(request.uri());\n     final String op \u003d getOp(decoder);\n \n     final String content;\n     String path \u003d getPath(decoder);\n     switch (op) {\n       case \"GETFILESTATUS\":\n         content \u003d image.getFileStatus(path);\n         break;\n       case \"LISTSTATUS\":\n         content \u003d image.listStatus(path);\n         break;\n       case \"GETACLSTATUS\":\n         content \u003d image.getAclStatus(path);\n         break;\n       default:\n         throw new IllegalArgumentException(\n             \"Invalid value for webhdfs parameter\" + \" \\\"op\\\"\");\n     }\n \n     LOG.info(\"op\u003d\" + op + \" target\u003d\" + path);\n \n     DefaultFullHttpResponse resp \u003d new DefaultFullHttpResponse(\n             HTTP_1_1, HttpResponseStatus.OK,\n             Unpooled.wrappedBuffer(content.getBytes(Charsets.UTF_8)));\n     resp.headers().set(CONTENT_TYPE, APPLICATION_JSON_UTF8);\n     resp.headers().set(CONTENT_LENGTH, resp.content().readableBytes());\n     resp.headers().set(CONNECTION, CLOSE);\n     ctx.write(resp).addListener(ChannelFutureListener.CLOSE);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void channelRead0(ChannelHandlerContext ctx, HttpRequest request)\n          throws Exception {\n    if (request.method() !\u003d HttpMethod.GET) {\n      DefaultHttpResponse resp \u003d new DefaultHttpResponse(HTTP_1_1,\n        METHOD_NOT_ALLOWED);\n      resp.headers().set(CONNECTION, CLOSE);\n      ctx.write(resp).addListener(ChannelFutureListener.CLOSE);\n      return;\n    }\n\n    QueryStringDecoder decoder \u003d new QueryStringDecoder(request.uri());\n    final String op \u003d getOp(decoder);\n\n    final String content;\n    String path \u003d getPath(decoder);\n    switch (op) {\n      case \"GETFILESTATUS\":\n        content \u003d image.getFileStatus(path);\n        break;\n      case \"LISTSTATUS\":\n        content \u003d image.listStatus(path);\n        break;\n      case \"GETACLSTATUS\":\n        content \u003d image.getAclStatus(path);\n        break;\n      default:\n        throw new IllegalArgumentException(\n            \"Invalid value for webhdfs parameter\" + \" \\\"op\\\"\");\n    }\n\n    LOG.info(\"op\u003d\" + op + \" target\u003d\" + path);\n\n    DefaultFullHttpResponse resp \u003d new DefaultFullHttpResponse(\n            HTTP_1_1, HttpResponseStatus.OK,\n            Unpooled.wrappedBuffer(content.getBytes(Charsets.UTF_8)));\n    resp.headers().set(CONTENT_TYPE, APPLICATION_JSON_UTF8);\n    resp.headers().set(CONTENT_LENGTH, resp.content().readableBytes());\n    resp.headers().set(CONNECTION, CLOSE);\n    ctx.write(resp).addListener(ChannelFutureListener.CLOSE);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/offlineImageViewer/FSImageHandler.java",
      "extendedDetails": {}
    },
    "b9f6d0c956f0278c8b9b83e05b523a442a730ebb": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7515. Fix new findbugs warnings in hadoop-hdfs. Contributed by Haohui Mai.\n",
      "commitDate": "11/12/14 12:36 PM",
      "commitName": "b9f6d0c956f0278c8b9b83e05b523a442a730ebb",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "28/10/14 4:53 PM",
      "commitNameOld": "675bca2968700d3627449700b827c3771827cef8",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 43.86,
      "commitsBetweenForRepo": 364,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,40 @@\n   public void channelRead0(ChannelHandlerContext ctx, HttpRequest request)\n           throws Exception {\n     if (request.getMethod() !\u003d HttpMethod.GET) {\n       DefaultHttpResponse resp \u003d new DefaultHttpResponse(HTTP_1_1,\n         METHOD_NOT_ALLOWED);\n-      resp.headers().set(\"Connection\", \"close\");\n+      resp.headers().set(CONNECTION, CLOSE);\n       ctx.write(resp).addListener(ChannelFutureListener.CLOSE);\n       return;\n     }\n \n     QueryStringDecoder decoder \u003d new QueryStringDecoder(request.getUri());\n     final String op \u003d getOp(decoder);\n \n     final String content;\n     String path \u003d getPath(decoder);\n-    if (\"GETFILESTATUS\".equals(op)) {\n-      content \u003d image.getFileStatus(path);\n-    } else if (\"LISTSTATUS\".equals(op)) {\n-      content \u003d image.listStatus(path);\n-    } else if (\"GETACLSTATUS\".equals(op)) {\n-      content \u003d image.getAclStatus(path);\n-    } else {\n-      throw new IllegalArgumentException(\"Invalid value for webhdfs parameter\" + \" \\\"op\\\"\");\n+    switch (op) {\n+      case \"GETFILESTATUS\":\n+        content \u003d image.getFileStatus(path);\n+        break;\n+      case \"LISTSTATUS\":\n+        content \u003d image.listStatus(path);\n+        break;\n+      case \"GETACLSTATUS\":\n+        content \u003d image.getAclStatus(path);\n+        break;\n+      default:\n+        throw new IllegalArgumentException(\n+            \"Invalid value for webhdfs parameter\" + \" \\\"op\\\"\");\n     }\n \n     LOG.info(\"op\u003d\" + op + \" target\u003d\" + path);\n \n     DefaultFullHttpResponse resp \u003d new DefaultFullHttpResponse(\n             HTTP_1_1, HttpResponseStatus.OK,\n-            Unpooled.wrappedBuffer(content.getBytes()));\n-    resp.headers().set(\"Content-Type\", \"application/json\");\n-    resp.headers().set(\"Content-Length\", resp.content().readableBytes());\n-    resp.headers().set(\"Connection\", \"close\");\n+            Unpooled.wrappedBuffer(content.getBytes(Charsets.UTF_8)));\n+    resp.headers().set(CONTENT_TYPE, APPLICATION_JSON_UTF8);\n+    resp.headers().set(CONTENT_LENGTH, resp.content().readableBytes());\n+    resp.headers().set(CONNECTION, CLOSE);\n     ctx.write(resp).addListener(ChannelFutureListener.CLOSE);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void channelRead0(ChannelHandlerContext ctx, HttpRequest request)\n          throws Exception {\n    if (request.getMethod() !\u003d HttpMethod.GET) {\n      DefaultHttpResponse resp \u003d new DefaultHttpResponse(HTTP_1_1,\n        METHOD_NOT_ALLOWED);\n      resp.headers().set(CONNECTION, CLOSE);\n      ctx.write(resp).addListener(ChannelFutureListener.CLOSE);\n      return;\n    }\n\n    QueryStringDecoder decoder \u003d new QueryStringDecoder(request.getUri());\n    final String op \u003d getOp(decoder);\n\n    final String content;\n    String path \u003d getPath(decoder);\n    switch (op) {\n      case \"GETFILESTATUS\":\n        content \u003d image.getFileStatus(path);\n        break;\n      case \"LISTSTATUS\":\n        content \u003d image.listStatus(path);\n        break;\n      case \"GETACLSTATUS\":\n        content \u003d image.getAclStatus(path);\n        break;\n      default:\n        throw new IllegalArgumentException(\n            \"Invalid value for webhdfs parameter\" + \" \\\"op\\\"\");\n    }\n\n    LOG.info(\"op\u003d\" + op + \" target\u003d\" + path);\n\n    DefaultFullHttpResponse resp \u003d new DefaultFullHttpResponse(\n            HTTP_1_1, HttpResponseStatus.OK,\n            Unpooled.wrappedBuffer(content.getBytes(Charsets.UTF_8)));\n    resp.headers().set(CONTENT_TYPE, APPLICATION_JSON_UTF8);\n    resp.headers().set(CONTENT_LENGTH, resp.content().readableBytes());\n    resp.headers().set(CONNECTION, CLOSE);\n    ctx.write(resp).addListener(ChannelFutureListener.CLOSE);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/offlineImageViewer/FSImageHandler.java",
      "extendedDetails": {}
    },
    "675bca2968700d3627449700b827c3771827cef8": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-7280. Use netty 4 in WebImageViewer. Contributed by Haohui Mai.\n",
      "commitDate": "28/10/14 4:53 PM",
      "commitName": "675bca2968700d3627449700b827c3771827cef8",
      "commitAuthor": "Haohui Mai",
      "diff": "@@ -0,0 +1,35 @@\n+  public void channelRead0(ChannelHandlerContext ctx, HttpRequest request)\n+          throws Exception {\n+    if (request.getMethod() !\u003d HttpMethod.GET) {\n+      DefaultHttpResponse resp \u003d new DefaultHttpResponse(HTTP_1_1,\n+        METHOD_NOT_ALLOWED);\n+      resp.headers().set(\"Connection\", \"close\");\n+      ctx.write(resp).addListener(ChannelFutureListener.CLOSE);\n+      return;\n+    }\n+\n+    QueryStringDecoder decoder \u003d new QueryStringDecoder(request.getUri());\n+    final String op \u003d getOp(decoder);\n+\n+    final String content;\n+    String path \u003d getPath(decoder);\n+    if (\"GETFILESTATUS\".equals(op)) {\n+      content \u003d image.getFileStatus(path);\n+    } else if (\"LISTSTATUS\".equals(op)) {\n+      content \u003d image.listStatus(path);\n+    } else if (\"GETACLSTATUS\".equals(op)) {\n+      content \u003d image.getAclStatus(path);\n+    } else {\n+      throw new IllegalArgumentException(\"Invalid value for webhdfs parameter\" + \" \\\"op\\\"\");\n+    }\n+\n+    LOG.info(\"op\u003d\" + op + \" target\u003d\" + path);\n+\n+    DefaultFullHttpResponse resp \u003d new DefaultFullHttpResponse(\n+            HTTP_1_1, HttpResponseStatus.OK,\n+            Unpooled.wrappedBuffer(content.getBytes()));\n+    resp.headers().set(\"Content-Type\", \"application/json\");\n+    resp.headers().set(\"Content-Length\", resp.content().readableBytes());\n+    resp.headers().set(\"Connection\", \"close\");\n+    ctx.write(resp).addListener(ChannelFutureListener.CLOSE);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void channelRead0(ChannelHandlerContext ctx, HttpRequest request)\n          throws Exception {\n    if (request.getMethod() !\u003d HttpMethod.GET) {\n      DefaultHttpResponse resp \u003d new DefaultHttpResponse(HTTP_1_1,\n        METHOD_NOT_ALLOWED);\n      resp.headers().set(\"Connection\", \"close\");\n      ctx.write(resp).addListener(ChannelFutureListener.CLOSE);\n      return;\n    }\n\n    QueryStringDecoder decoder \u003d new QueryStringDecoder(request.getUri());\n    final String op \u003d getOp(decoder);\n\n    final String content;\n    String path \u003d getPath(decoder);\n    if (\"GETFILESTATUS\".equals(op)) {\n      content \u003d image.getFileStatus(path);\n    } else if (\"LISTSTATUS\".equals(op)) {\n      content \u003d image.listStatus(path);\n    } else if (\"GETACLSTATUS\".equals(op)) {\n      content \u003d image.getAclStatus(path);\n    } else {\n      throw new IllegalArgumentException(\"Invalid value for webhdfs parameter\" + \" \\\"op\\\"\");\n    }\n\n    LOG.info(\"op\u003d\" + op + \" target\u003d\" + path);\n\n    DefaultFullHttpResponse resp \u003d new DefaultFullHttpResponse(\n            HTTP_1_1, HttpResponseStatus.OK,\n            Unpooled.wrappedBuffer(content.getBytes()));\n    resp.headers().set(\"Content-Type\", \"application/json\");\n    resp.headers().set(\"Content-Length\", resp.content().readableBytes());\n    resp.headers().set(\"Connection\", \"close\");\n    ctx.write(resp).addListener(ChannelFutureListener.CLOSE);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/offlineImageViewer/FSImageHandler.java"
    }
  }
}