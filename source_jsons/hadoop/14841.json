{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "DFSck.java",
  "functionName": "doWork",
  "functionId": "doWork___args-String[](modifiers-final)",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DFSck.java",
  "functionStartLine": 275,
  "functionEndLine": 398,
  "numCommitsSeen": 39,
  "timeTaken": 9967,
  "changeHistory": [
    "ffc9c50e074aeca804674c6e1e6b0f1eb629e230",
    "113af12cfb240ea9a7189bb2701693466eb8e993",
    "78ae2aed8f84d2d3983f81a5219e8b1f1ec59dca",
    "2f8e9b7e4b1721ed5c7db8882eff70f83164e320",
    "c18590fce283378edb09acd4e764706a9a4a8b5f",
    "7d521a29eed62c4329b16034375bd5fb747a92a9",
    "677a936bf759515ac94d9accb9bf5364f688d051",
    "8ddbb8dd433862509bd9b222dddafe2c3a74778a",
    "cbb492578ef09300821b7199de54c6508f9d7fe8",
    "d140d76a43c88e326b9c2818578f22bd3563b969",
    "7fe0f25ad21f006eb41b832a181eb2a812a6f7b7",
    "371a3b87ed346732ed58a4faab0c6c1db57c86ed",
    "c477a166e18e122b101c372b1c0a2f362e53866d",
    "045dc880e13271737b3cf316296e92fb95806663",
    "b6d483b1221296be408df66bc56b37765ce196de",
    "d8a23834614581a292aad214dddcbcc4bbe86d27",
    "28e87740c5797e87a9038d7f151c8b21a5b04592",
    "231a52a7dfa73f7f302cc3bf671d433312373873",
    "f026d8bb1ba6f9b059db5526f1fb1261f818ffd0",
    "4bca22005f48f426b9bc7cf36d435ead470a2590",
    "5dbbe0e0a5d31689d3425e490865f95057dc051c",
    "1a75ec82885e45baf4d5cd56d6c738d8e68d8bc7",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "d86f3183d93714ba078416af4f609d26376eadb0",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc"
  ],
  "changeHistoryShort": {
    "ffc9c50e074aeca804674c6e1e6b0f1eb629e230": "Ybodychange",
    "113af12cfb240ea9a7189bb2701693466eb8e993": "Ybodychange",
    "78ae2aed8f84d2d3983f81a5219e8b1f1ec59dca": "Ybodychange",
    "2f8e9b7e4b1721ed5c7db8882eff70f83164e320": "Ybodychange",
    "c18590fce283378edb09acd4e764706a9a4a8b5f": "Ybodychange",
    "7d521a29eed62c4329b16034375bd5fb747a92a9": "Ybodychange",
    "677a936bf759515ac94d9accb9bf5364f688d051": "Ybodychange",
    "8ddbb8dd433862509bd9b222dddafe2c3a74778a": "Ybodychange",
    "cbb492578ef09300821b7199de54c6508f9d7fe8": "Ybodychange",
    "d140d76a43c88e326b9c2818578f22bd3563b969": "Ybodychange",
    "7fe0f25ad21f006eb41b832a181eb2a812a6f7b7": "Ybodychange",
    "371a3b87ed346732ed58a4faab0c6c1db57c86ed": "Ybodychange",
    "c477a166e18e122b101c372b1c0a2f362e53866d": "Ybodychange",
    "045dc880e13271737b3cf316296e92fb95806663": "Ybodychange",
    "b6d483b1221296be408df66bc56b37765ce196de": "Ybodychange",
    "d8a23834614581a292aad214dddcbcc4bbe86d27": "Ybodychange",
    "28e87740c5797e87a9038d7f151c8b21a5b04592": "Ybodychange",
    "231a52a7dfa73f7f302cc3bf671d433312373873": "Ybodychange",
    "f026d8bb1ba6f9b059db5526f1fb1261f818ffd0": "Ybodychange",
    "4bca22005f48f426b9bc7cf36d435ead470a2590": "Ybodychange",
    "5dbbe0e0a5d31689d3425e490865f95057dc051c": "Ybodychange",
    "1a75ec82885e45baf4d5cd56d6c738d8e68d8bc7": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "d86f3183d93714ba078416af4f609d26376eadb0": "Yfilerename",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yintroduced"
  },
  "changeHistoryDetails": {
    "ffc9c50e074aeca804674c6e1e6b0f1eb629e230": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14053. Provide ability for NN to re-replicate based on topology changes. Contributed by Hrishikesh Gadre.\n",
      "commitDate": "05/11/18 9:38 PM",
      "commitName": "ffc9c50e074aeca804674c6e1e6b0f1eb629e230",
      "commitAuthor": "Xiao Chen",
      "commitDateOld": "30/10/18 10:43 PM",
      "commitNameOld": "fac9f91b2944cee641049fffcafa6b65e0cf68f2",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 6.0,
      "commitsBetweenForRepo": 34,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,122 +1,124 @@\n   private int doWork(final String[] args) throws IOException {\n     final StringBuilder url \u003d new StringBuilder();\n     \n     url.append(\"/fsck?ugi\u003d\").append(ugi.getShortUserName());\n     String dir \u003d null;\n     boolean doListCorruptFileBlocks \u003d false;\n     for (int idx \u003d 0; idx \u003c args.length; idx++) {\n       if (args[idx].equals(\"-move\")) { url.append(\"\u0026move\u003d1\"); }\n       else if (args[idx].equals(\"-delete\")) { url.append(\"\u0026delete\u003d1\"); }\n       else if (args[idx].equals(\"-files\")) { url.append(\"\u0026files\u003d1\"); }\n       else if (args[idx].equals(\"-openforwrite\")) { url.append(\"\u0026openforwrite\u003d1\"); }\n       else if (args[idx].equals(\"-blocks\")) { url.append(\"\u0026blocks\u003d1\"); }\n       else if (args[idx].equals(\"-locations\")) { url.append(\"\u0026locations\u003d1\"); }\n       else if (args[idx].equals(\"-racks\")) { url.append(\"\u0026racks\u003d1\"); }\n       else if (args[idx].equals(\"-replicaDetails\")) {\n         url.append(\"\u0026replicadetails\u003d1\");\n       } else if (args[idx].equals(\"-upgradedomains\")) {\n         url.append(\"\u0026upgradedomains\u003d1\");\n       } else if (args[idx].equals(\"-storagepolicies\")) {\n         url.append(\"\u0026storagepolicies\u003d1\");\n       } else if (args[idx].equals(\"-showprogress\")) {\n         url.append(\"\u0026showprogress\u003d1\");\n       } else if (args[idx].equals(\"-list-corruptfileblocks\")) {\n         url.append(\"\u0026listcorruptfileblocks\u003d1\");\n         doListCorruptFileBlocks \u003d true;\n       } else if (args[idx].equals(\"-includeSnapshots\")) {\n         url.append(\"\u0026includeSnapshots\u003d1\");\n       } else if (args[idx].equals(\"-maintenance\")) {\n         url.append(\"\u0026maintenance\u003d1\");\n       } else if (args[idx].equals(\"-blockId\")) {\n         StringBuilder sb \u003d new StringBuilder();\n         idx++;\n         while(idx \u003c args.length \u0026\u0026 !args[idx].startsWith(\"-\")){\n           sb.append(args[idx]);\n           sb.append(\" \");\n           idx++;\n         }\n         url.append(\"\u0026blockId\u003d\").append(URLEncoder.encode(sb.toString(), \"UTF-8\"));\n+      } else if (args[idx].equals(\"-replicate\")) {\n+        url.append(\"\u0026replicate\u003d1\");\n       } else if (!args[idx].startsWith(\"-\")) {\n         if (null \u003d\u003d dir) {\n           dir \u003d args[idx];\n         } else {\n           System.err.println(\"fsck: can only operate on one path at a time \u0027\"\n               + args[idx] + \"\u0027\");\n           printUsage(System.err);\n           return -1;\n         }\n \n       } else {\n         System.err.println(\"fsck: Illegal option \u0027\" + args[idx] + \"\u0027\");\n         printUsage(System.err);\n         return -1;\n       }\n     }\n     if (null \u003d\u003d dir) {\n       dir \u003d \"/\";\n     }\n \n     Path dirpath \u003d null;\n     URI namenodeAddress \u003d null;\n     try {\n       dirpath \u003d getResolvedPath(dir);\n       namenodeAddress \u003d getCurrentNamenodeAddress(dirpath);\n     } catch (IOException ioe) {\n       System.err.println(\"FileSystem is inaccessible due to:\\n\"\n           + ioe.toString());\n     }\n \n     if (namenodeAddress \u003d\u003d null) {\n       //Error message already output in {@link #getCurrentNamenodeAddress()}\n       System.err.println(\"DFSck exiting.\");\n       return 0;\n     }\n \n     url.insert(0, namenodeAddress.toString());\n     url.append(\"\u0026path\u003d\").append(URLEncoder.encode(\n         Path.getPathWithoutSchemeAndAuthority(dirpath).toString(), \"UTF-8\"));\n     System.err.println(\"Connecting to namenode via \" + url.toString());\n \n     if (doListCorruptFileBlocks) {\n       return listCorruptFileBlocks(dir, url.toString());\n     }\n     URL path \u003d new URL(url.toString());\n     URLConnection connection;\n     try {\n       connection \u003d connectionFactory.openConnection(path, isSpnegoEnabled);\n     } catch (AuthenticationException e) {\n       throw new IOException(e);\n     }\n     InputStream stream \u003d connection.getInputStream();\n     BufferedReader input \u003d new BufferedReader(new InputStreamReader(\n                                               stream, \"UTF-8\"));\n     String line \u003d null;\n     String lastLine \u003d NamenodeFsck.CORRUPT_STATUS;\n     int errCode \u003d -1;\n     try {\n       while ((line \u003d input.readLine()) !\u003d null) {\n         out.println(line);\n         lastLine \u003d line;\n       }\n     } finally {\n       input.close();\n     }\n     if (lastLine.endsWith(NamenodeFsck.HEALTHY_STATUS)) {\n       errCode \u003d 0;\n     } else if (lastLine.endsWith(NamenodeFsck.CORRUPT_STATUS)) {\n       errCode \u003d 1;\n     } else if (lastLine.endsWith(NamenodeFsck.NONEXISTENT_STATUS)) {\n       errCode \u003d 0;\n     } else if (lastLine.contains(\"Incorrect blockId format:\")) {\n       errCode \u003d 0;\n     } else if (lastLine.endsWith(NamenodeFsck.DECOMMISSIONED_STATUS)) {\n       errCode \u003d 2;\n     } else if (lastLine.endsWith(NamenodeFsck.DECOMMISSIONING_STATUS)) {\n       errCode \u003d 3;\n     } else if (lastLine.endsWith(NamenodeFsck.IN_MAINTENANCE_STATUS))  {\n       errCode \u003d 4;\n     } else if (lastLine.endsWith(NamenodeFsck.ENTERING_MAINTENANCE_STATUS)) {\n       errCode \u003d 5;\n     }\n     return errCode;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int doWork(final String[] args) throws IOException {\n    final StringBuilder url \u003d new StringBuilder();\n    \n    url.append(\"/fsck?ugi\u003d\").append(ugi.getShortUserName());\n    String dir \u003d null;\n    boolean doListCorruptFileBlocks \u003d false;\n    for (int idx \u003d 0; idx \u003c args.length; idx++) {\n      if (args[idx].equals(\"-move\")) { url.append(\"\u0026move\u003d1\"); }\n      else if (args[idx].equals(\"-delete\")) { url.append(\"\u0026delete\u003d1\"); }\n      else if (args[idx].equals(\"-files\")) { url.append(\"\u0026files\u003d1\"); }\n      else if (args[idx].equals(\"-openforwrite\")) { url.append(\"\u0026openforwrite\u003d1\"); }\n      else if (args[idx].equals(\"-blocks\")) { url.append(\"\u0026blocks\u003d1\"); }\n      else if (args[idx].equals(\"-locations\")) { url.append(\"\u0026locations\u003d1\"); }\n      else if (args[idx].equals(\"-racks\")) { url.append(\"\u0026racks\u003d1\"); }\n      else if (args[idx].equals(\"-replicaDetails\")) {\n        url.append(\"\u0026replicadetails\u003d1\");\n      } else if (args[idx].equals(\"-upgradedomains\")) {\n        url.append(\"\u0026upgradedomains\u003d1\");\n      } else if (args[idx].equals(\"-storagepolicies\")) {\n        url.append(\"\u0026storagepolicies\u003d1\");\n      } else if (args[idx].equals(\"-showprogress\")) {\n        url.append(\"\u0026showprogress\u003d1\");\n      } else if (args[idx].equals(\"-list-corruptfileblocks\")) {\n        url.append(\"\u0026listcorruptfileblocks\u003d1\");\n        doListCorruptFileBlocks \u003d true;\n      } else if (args[idx].equals(\"-includeSnapshots\")) {\n        url.append(\"\u0026includeSnapshots\u003d1\");\n      } else if (args[idx].equals(\"-maintenance\")) {\n        url.append(\"\u0026maintenance\u003d1\");\n      } else if (args[idx].equals(\"-blockId\")) {\n        StringBuilder sb \u003d new StringBuilder();\n        idx++;\n        while(idx \u003c args.length \u0026\u0026 !args[idx].startsWith(\"-\")){\n          sb.append(args[idx]);\n          sb.append(\" \");\n          idx++;\n        }\n        url.append(\"\u0026blockId\u003d\").append(URLEncoder.encode(sb.toString(), \"UTF-8\"));\n      } else if (args[idx].equals(\"-replicate\")) {\n        url.append(\"\u0026replicate\u003d1\");\n      } else if (!args[idx].startsWith(\"-\")) {\n        if (null \u003d\u003d dir) {\n          dir \u003d args[idx];\n        } else {\n          System.err.println(\"fsck: can only operate on one path at a time \u0027\"\n              + args[idx] + \"\u0027\");\n          printUsage(System.err);\n          return -1;\n        }\n\n      } else {\n        System.err.println(\"fsck: Illegal option \u0027\" + args[idx] + \"\u0027\");\n        printUsage(System.err);\n        return -1;\n      }\n    }\n    if (null \u003d\u003d dir) {\n      dir \u003d \"/\";\n    }\n\n    Path dirpath \u003d null;\n    URI namenodeAddress \u003d null;\n    try {\n      dirpath \u003d getResolvedPath(dir);\n      namenodeAddress \u003d getCurrentNamenodeAddress(dirpath);\n    } catch (IOException ioe) {\n      System.err.println(\"FileSystem is inaccessible due to:\\n\"\n          + ioe.toString());\n    }\n\n    if (namenodeAddress \u003d\u003d null) {\n      //Error message already output in {@link #getCurrentNamenodeAddress()}\n      System.err.println(\"DFSck exiting.\");\n      return 0;\n    }\n\n    url.insert(0, namenodeAddress.toString());\n    url.append(\"\u0026path\u003d\").append(URLEncoder.encode(\n        Path.getPathWithoutSchemeAndAuthority(dirpath).toString(), \"UTF-8\"));\n    System.err.println(\"Connecting to namenode via \" + url.toString());\n\n    if (doListCorruptFileBlocks) {\n      return listCorruptFileBlocks(dir, url.toString());\n    }\n    URL path \u003d new URL(url.toString());\n    URLConnection connection;\n    try {\n      connection \u003d connectionFactory.openConnection(path, isSpnegoEnabled);\n    } catch (AuthenticationException e) {\n      throw new IOException(e);\n    }\n    InputStream stream \u003d connection.getInputStream();\n    BufferedReader input \u003d new BufferedReader(new InputStreamReader(\n                                              stream, \"UTF-8\"));\n    String line \u003d null;\n    String lastLine \u003d NamenodeFsck.CORRUPT_STATUS;\n    int errCode \u003d -1;\n    try {\n      while ((line \u003d input.readLine()) !\u003d null) {\n        out.println(line);\n        lastLine \u003d line;\n      }\n    } finally {\n      input.close();\n    }\n    if (lastLine.endsWith(NamenodeFsck.HEALTHY_STATUS)) {\n      errCode \u003d 0;\n    } else if (lastLine.endsWith(NamenodeFsck.CORRUPT_STATUS)) {\n      errCode \u003d 1;\n    } else if (lastLine.endsWith(NamenodeFsck.NONEXISTENT_STATUS)) {\n      errCode \u003d 0;\n    } else if (lastLine.contains(\"Incorrect blockId format:\")) {\n      errCode \u003d 0;\n    } else if (lastLine.endsWith(NamenodeFsck.DECOMMISSIONED_STATUS)) {\n      errCode \u003d 2;\n    } else if (lastLine.endsWith(NamenodeFsck.DECOMMISSIONING_STATUS)) {\n      errCode \u003d 3;\n    } else if (lastLine.endsWith(NamenodeFsck.IN_MAINTENANCE_STATUS))  {\n      errCode \u003d 4;\n    } else if (lastLine.endsWith(NamenodeFsck.ENTERING_MAINTENANCE_STATUS)) {\n      errCode \u003d 5;\n    }\n    return errCode;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DFSck.java",
      "extendedDetails": {}
    },
    "113af12cfb240ea9a7189bb2701693466eb8e993": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7101. Potential null dereference in DFSck#doWork(). Contributed by skrho and Ted Yu.\n",
      "commitDate": "12/04/18 1:47 AM",
      "commitName": "113af12cfb240ea9a7189bb2701693466eb8e993",
      "commitAuthor": "Akira Ajisaka",
      "commitDateOld": "19/01/17 12:28 AM",
      "commitNameOld": "78ae2aed8f84d2d3983f81a5219e8b1f1ec59dca",
      "commitAuthorOld": "Lei Xu",
      "daysBetweenCommits": 448.01,
      "commitsBetweenForRepo": 3027,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,122 +1,122 @@\n   private int doWork(final String[] args) throws IOException {\n     final StringBuilder url \u003d new StringBuilder();\n     \n     url.append(\"/fsck?ugi\u003d\").append(ugi.getShortUserName());\n     String dir \u003d null;\n     boolean doListCorruptFileBlocks \u003d false;\n     for (int idx \u003d 0; idx \u003c args.length; idx++) {\n       if (args[idx].equals(\"-move\")) { url.append(\"\u0026move\u003d1\"); }\n       else if (args[idx].equals(\"-delete\")) { url.append(\"\u0026delete\u003d1\"); }\n       else if (args[idx].equals(\"-files\")) { url.append(\"\u0026files\u003d1\"); }\n       else if (args[idx].equals(\"-openforwrite\")) { url.append(\"\u0026openforwrite\u003d1\"); }\n       else if (args[idx].equals(\"-blocks\")) { url.append(\"\u0026blocks\u003d1\"); }\n       else if (args[idx].equals(\"-locations\")) { url.append(\"\u0026locations\u003d1\"); }\n       else if (args[idx].equals(\"-racks\")) { url.append(\"\u0026racks\u003d1\"); }\n       else if (args[idx].equals(\"-replicaDetails\")) {\n         url.append(\"\u0026replicadetails\u003d1\");\n       } else if (args[idx].equals(\"-upgradedomains\")) {\n         url.append(\"\u0026upgradedomains\u003d1\");\n       } else if (args[idx].equals(\"-storagepolicies\")) {\n         url.append(\"\u0026storagepolicies\u003d1\");\n       } else if (args[idx].equals(\"-showprogress\")) {\n         url.append(\"\u0026showprogress\u003d1\");\n       } else if (args[idx].equals(\"-list-corruptfileblocks\")) {\n         url.append(\"\u0026listcorruptfileblocks\u003d1\");\n         doListCorruptFileBlocks \u003d true;\n       } else if (args[idx].equals(\"-includeSnapshots\")) {\n         url.append(\"\u0026includeSnapshots\u003d1\");\n       } else if (args[idx].equals(\"-maintenance\")) {\n         url.append(\"\u0026maintenance\u003d1\");\n       } else if (args[idx].equals(\"-blockId\")) {\n         StringBuilder sb \u003d new StringBuilder();\n         idx++;\n         while(idx \u003c args.length \u0026\u0026 !args[idx].startsWith(\"-\")){\n           sb.append(args[idx]);\n           sb.append(\" \");\n           idx++;\n         }\n         url.append(\"\u0026blockId\u003d\").append(URLEncoder.encode(sb.toString(), \"UTF-8\"));\n       } else if (!args[idx].startsWith(\"-\")) {\n         if (null \u003d\u003d dir) {\n           dir \u003d args[idx];\n         } else {\n           System.err.println(\"fsck: can only operate on one path at a time \u0027\"\n               + args[idx] + \"\u0027\");\n           printUsage(System.err);\n           return -1;\n         }\n \n       } else {\n         System.err.println(\"fsck: Illegal option \u0027\" + args[idx] + \"\u0027\");\n         printUsage(System.err);\n         return -1;\n       }\n     }\n     if (null \u003d\u003d dir) {\n       dir \u003d \"/\";\n     }\n \n     Path dirpath \u003d null;\n     URI namenodeAddress \u003d null;\n     try {\n       dirpath \u003d getResolvedPath(dir);\n       namenodeAddress \u003d getCurrentNamenodeAddress(dirpath);\n     } catch (IOException ioe) {\n       System.err.println(\"FileSystem is inaccessible due to:\\n\"\n           + ioe.toString());\n     }\n \n     if (namenodeAddress \u003d\u003d null) {\n       //Error message already output in {@link #getCurrentNamenodeAddress()}\n       System.err.println(\"DFSck exiting.\");\n       return 0;\n     }\n \n     url.insert(0, namenodeAddress.toString());\n     url.append(\"\u0026path\u003d\").append(URLEncoder.encode(\n         Path.getPathWithoutSchemeAndAuthority(dirpath).toString(), \"UTF-8\"));\n     System.err.println(\"Connecting to namenode via \" + url.toString());\n \n     if (doListCorruptFileBlocks) {\n       return listCorruptFileBlocks(dir, url.toString());\n     }\n     URL path \u003d new URL(url.toString());\n     URLConnection connection;\n     try {\n       connection \u003d connectionFactory.openConnection(path, isSpnegoEnabled);\n     } catch (AuthenticationException e) {\n       throw new IOException(e);\n     }\n     InputStream stream \u003d connection.getInputStream();\n     BufferedReader input \u003d new BufferedReader(new InputStreamReader(\n                                               stream, \"UTF-8\"));\n     String line \u003d null;\n-    String lastLine \u003d null;\n+    String lastLine \u003d NamenodeFsck.CORRUPT_STATUS;\n     int errCode \u003d -1;\n     try {\n       while ((line \u003d input.readLine()) !\u003d null) {\n         out.println(line);\n         lastLine \u003d line;\n       }\n     } finally {\n       input.close();\n     }\n     if (lastLine.endsWith(NamenodeFsck.HEALTHY_STATUS)) {\n       errCode \u003d 0;\n     } else if (lastLine.endsWith(NamenodeFsck.CORRUPT_STATUS)) {\n       errCode \u003d 1;\n     } else if (lastLine.endsWith(NamenodeFsck.NONEXISTENT_STATUS)) {\n       errCode \u003d 0;\n     } else if (lastLine.contains(\"Incorrect blockId format:\")) {\n       errCode \u003d 0;\n     } else if (lastLine.endsWith(NamenodeFsck.DECOMMISSIONED_STATUS)) {\n       errCode \u003d 2;\n     } else if (lastLine.endsWith(NamenodeFsck.DECOMMISSIONING_STATUS)) {\n       errCode \u003d 3;\n     } else if (lastLine.endsWith(NamenodeFsck.IN_MAINTENANCE_STATUS))  {\n       errCode \u003d 4;\n     } else if (lastLine.endsWith(NamenodeFsck.ENTERING_MAINTENANCE_STATUS)) {\n       errCode \u003d 5;\n     }\n     return errCode;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int doWork(final String[] args) throws IOException {\n    final StringBuilder url \u003d new StringBuilder();\n    \n    url.append(\"/fsck?ugi\u003d\").append(ugi.getShortUserName());\n    String dir \u003d null;\n    boolean doListCorruptFileBlocks \u003d false;\n    for (int idx \u003d 0; idx \u003c args.length; idx++) {\n      if (args[idx].equals(\"-move\")) { url.append(\"\u0026move\u003d1\"); }\n      else if (args[idx].equals(\"-delete\")) { url.append(\"\u0026delete\u003d1\"); }\n      else if (args[idx].equals(\"-files\")) { url.append(\"\u0026files\u003d1\"); }\n      else if (args[idx].equals(\"-openforwrite\")) { url.append(\"\u0026openforwrite\u003d1\"); }\n      else if (args[idx].equals(\"-blocks\")) { url.append(\"\u0026blocks\u003d1\"); }\n      else if (args[idx].equals(\"-locations\")) { url.append(\"\u0026locations\u003d1\"); }\n      else if (args[idx].equals(\"-racks\")) { url.append(\"\u0026racks\u003d1\"); }\n      else if (args[idx].equals(\"-replicaDetails\")) {\n        url.append(\"\u0026replicadetails\u003d1\");\n      } else if (args[idx].equals(\"-upgradedomains\")) {\n        url.append(\"\u0026upgradedomains\u003d1\");\n      } else if (args[idx].equals(\"-storagepolicies\")) {\n        url.append(\"\u0026storagepolicies\u003d1\");\n      } else if (args[idx].equals(\"-showprogress\")) {\n        url.append(\"\u0026showprogress\u003d1\");\n      } else if (args[idx].equals(\"-list-corruptfileblocks\")) {\n        url.append(\"\u0026listcorruptfileblocks\u003d1\");\n        doListCorruptFileBlocks \u003d true;\n      } else if (args[idx].equals(\"-includeSnapshots\")) {\n        url.append(\"\u0026includeSnapshots\u003d1\");\n      } else if (args[idx].equals(\"-maintenance\")) {\n        url.append(\"\u0026maintenance\u003d1\");\n      } else if (args[idx].equals(\"-blockId\")) {\n        StringBuilder sb \u003d new StringBuilder();\n        idx++;\n        while(idx \u003c args.length \u0026\u0026 !args[idx].startsWith(\"-\")){\n          sb.append(args[idx]);\n          sb.append(\" \");\n          idx++;\n        }\n        url.append(\"\u0026blockId\u003d\").append(URLEncoder.encode(sb.toString(), \"UTF-8\"));\n      } else if (!args[idx].startsWith(\"-\")) {\n        if (null \u003d\u003d dir) {\n          dir \u003d args[idx];\n        } else {\n          System.err.println(\"fsck: can only operate on one path at a time \u0027\"\n              + args[idx] + \"\u0027\");\n          printUsage(System.err);\n          return -1;\n        }\n\n      } else {\n        System.err.println(\"fsck: Illegal option \u0027\" + args[idx] + \"\u0027\");\n        printUsage(System.err);\n        return -1;\n      }\n    }\n    if (null \u003d\u003d dir) {\n      dir \u003d \"/\";\n    }\n\n    Path dirpath \u003d null;\n    URI namenodeAddress \u003d null;\n    try {\n      dirpath \u003d getResolvedPath(dir);\n      namenodeAddress \u003d getCurrentNamenodeAddress(dirpath);\n    } catch (IOException ioe) {\n      System.err.println(\"FileSystem is inaccessible due to:\\n\"\n          + ioe.toString());\n    }\n\n    if (namenodeAddress \u003d\u003d null) {\n      //Error message already output in {@link #getCurrentNamenodeAddress()}\n      System.err.println(\"DFSck exiting.\");\n      return 0;\n    }\n\n    url.insert(0, namenodeAddress.toString());\n    url.append(\"\u0026path\u003d\").append(URLEncoder.encode(\n        Path.getPathWithoutSchemeAndAuthority(dirpath).toString(), \"UTF-8\"));\n    System.err.println(\"Connecting to namenode via \" + url.toString());\n\n    if (doListCorruptFileBlocks) {\n      return listCorruptFileBlocks(dir, url.toString());\n    }\n    URL path \u003d new URL(url.toString());\n    URLConnection connection;\n    try {\n      connection \u003d connectionFactory.openConnection(path, isSpnegoEnabled);\n    } catch (AuthenticationException e) {\n      throw new IOException(e);\n    }\n    InputStream stream \u003d connection.getInputStream();\n    BufferedReader input \u003d new BufferedReader(new InputStreamReader(\n                                              stream, \"UTF-8\"));\n    String line \u003d null;\n    String lastLine \u003d NamenodeFsck.CORRUPT_STATUS;\n    int errCode \u003d -1;\n    try {\n      while ((line \u003d input.readLine()) !\u003d null) {\n        out.println(line);\n        lastLine \u003d line;\n      }\n    } finally {\n      input.close();\n    }\n    if (lastLine.endsWith(NamenodeFsck.HEALTHY_STATUS)) {\n      errCode \u003d 0;\n    } else if (lastLine.endsWith(NamenodeFsck.CORRUPT_STATUS)) {\n      errCode \u003d 1;\n    } else if (lastLine.endsWith(NamenodeFsck.NONEXISTENT_STATUS)) {\n      errCode \u003d 0;\n    } else if (lastLine.contains(\"Incorrect blockId format:\")) {\n      errCode \u003d 0;\n    } else if (lastLine.endsWith(NamenodeFsck.DECOMMISSIONED_STATUS)) {\n      errCode \u003d 2;\n    } else if (lastLine.endsWith(NamenodeFsck.DECOMMISSIONING_STATUS)) {\n      errCode \u003d 3;\n    } else if (lastLine.endsWith(NamenodeFsck.IN_MAINTENANCE_STATUS))  {\n      errCode \u003d 4;\n    } else if (lastLine.endsWith(NamenodeFsck.ENTERING_MAINTENANCE_STATUS)) {\n      errCode \u003d 5;\n    }\n    return errCode;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DFSck.java",
      "extendedDetails": {}
    },
    "78ae2aed8f84d2d3983f81a5219e8b1f1ec59dca": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11259. Update fsck to display maintenance state info. (Manoj Govindassamy via lei)\n",
      "commitDate": "19/01/17 12:28 AM",
      "commitName": "78ae2aed8f84d2d3983f81a5219e8b1f1ec59dca",
      "commitAuthor": "Lei Xu",
      "commitDateOld": "15/01/17 11:11 PM",
      "commitNameOld": "2f8e9b7e4b1721ed5c7db8882eff70f83164e320",
      "commitAuthorOld": "Lei Xu",
      "daysBetweenCommits": 3.05,
      "commitsBetweenForRepo": 30,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,116 +1,122 @@\n   private int doWork(final String[] args) throws IOException {\n     final StringBuilder url \u003d new StringBuilder();\n     \n     url.append(\"/fsck?ugi\u003d\").append(ugi.getShortUserName());\n     String dir \u003d null;\n     boolean doListCorruptFileBlocks \u003d false;\n     for (int idx \u003d 0; idx \u003c args.length; idx++) {\n       if (args[idx].equals(\"-move\")) { url.append(\"\u0026move\u003d1\"); }\n       else if (args[idx].equals(\"-delete\")) { url.append(\"\u0026delete\u003d1\"); }\n       else if (args[idx].equals(\"-files\")) { url.append(\"\u0026files\u003d1\"); }\n       else if (args[idx].equals(\"-openforwrite\")) { url.append(\"\u0026openforwrite\u003d1\"); }\n       else if (args[idx].equals(\"-blocks\")) { url.append(\"\u0026blocks\u003d1\"); }\n       else if (args[idx].equals(\"-locations\")) { url.append(\"\u0026locations\u003d1\"); }\n       else if (args[idx].equals(\"-racks\")) { url.append(\"\u0026racks\u003d1\"); }\n       else if (args[idx].equals(\"-replicaDetails\")) {\n         url.append(\"\u0026replicadetails\u003d1\");\n       } else if (args[idx].equals(\"-upgradedomains\")) {\n         url.append(\"\u0026upgradedomains\u003d1\");\n       } else if (args[idx].equals(\"-storagepolicies\")) {\n         url.append(\"\u0026storagepolicies\u003d1\");\n       } else if (args[idx].equals(\"-showprogress\")) {\n         url.append(\"\u0026showprogress\u003d1\");\n       } else if (args[idx].equals(\"-list-corruptfileblocks\")) {\n         url.append(\"\u0026listcorruptfileblocks\u003d1\");\n         doListCorruptFileBlocks \u003d true;\n       } else if (args[idx].equals(\"-includeSnapshots\")) {\n         url.append(\"\u0026includeSnapshots\u003d1\");\n+      } else if (args[idx].equals(\"-maintenance\")) {\n+        url.append(\"\u0026maintenance\u003d1\");\n       } else if (args[idx].equals(\"-blockId\")) {\n         StringBuilder sb \u003d new StringBuilder();\n         idx++;\n         while(idx \u003c args.length \u0026\u0026 !args[idx].startsWith(\"-\")){\n           sb.append(args[idx]);\n           sb.append(\" \");\n           idx++;\n         }\n         url.append(\"\u0026blockId\u003d\").append(URLEncoder.encode(sb.toString(), \"UTF-8\"));\n       } else if (!args[idx].startsWith(\"-\")) {\n         if (null \u003d\u003d dir) {\n           dir \u003d args[idx];\n         } else {\n           System.err.println(\"fsck: can only operate on one path at a time \u0027\"\n               + args[idx] + \"\u0027\");\n           printUsage(System.err);\n           return -1;\n         }\n \n       } else {\n         System.err.println(\"fsck: Illegal option \u0027\" + args[idx] + \"\u0027\");\n         printUsage(System.err);\n         return -1;\n       }\n     }\n     if (null \u003d\u003d dir) {\n       dir \u003d \"/\";\n     }\n \n     Path dirpath \u003d null;\n     URI namenodeAddress \u003d null;\n     try {\n       dirpath \u003d getResolvedPath(dir);\n       namenodeAddress \u003d getCurrentNamenodeAddress(dirpath);\n     } catch (IOException ioe) {\n       System.err.println(\"FileSystem is inaccessible due to:\\n\"\n           + ioe.toString());\n     }\n \n     if (namenodeAddress \u003d\u003d null) {\n       //Error message already output in {@link #getCurrentNamenodeAddress()}\n       System.err.println(\"DFSck exiting.\");\n       return 0;\n     }\n \n     url.insert(0, namenodeAddress.toString());\n     url.append(\"\u0026path\u003d\").append(URLEncoder.encode(\n         Path.getPathWithoutSchemeAndAuthority(dirpath).toString(), \"UTF-8\"));\n     System.err.println(\"Connecting to namenode via \" + url.toString());\n \n     if (doListCorruptFileBlocks) {\n       return listCorruptFileBlocks(dir, url.toString());\n     }\n     URL path \u003d new URL(url.toString());\n     URLConnection connection;\n     try {\n       connection \u003d connectionFactory.openConnection(path, isSpnegoEnabled);\n     } catch (AuthenticationException e) {\n       throw new IOException(e);\n     }\n     InputStream stream \u003d connection.getInputStream();\n     BufferedReader input \u003d new BufferedReader(new InputStreamReader(\n                                               stream, \"UTF-8\"));\n     String line \u003d null;\n     String lastLine \u003d null;\n     int errCode \u003d -1;\n     try {\n       while ((line \u003d input.readLine()) !\u003d null) {\n         out.println(line);\n         lastLine \u003d line;\n       }\n     } finally {\n       input.close();\n     }\n     if (lastLine.endsWith(NamenodeFsck.HEALTHY_STATUS)) {\n       errCode \u003d 0;\n     } else if (lastLine.endsWith(NamenodeFsck.CORRUPT_STATUS)) {\n       errCode \u003d 1;\n     } else if (lastLine.endsWith(NamenodeFsck.NONEXISTENT_STATUS)) {\n       errCode \u003d 0;\n     } else if (lastLine.contains(\"Incorrect blockId format:\")) {\n       errCode \u003d 0;\n     } else if (lastLine.endsWith(NamenodeFsck.DECOMMISSIONED_STATUS)) {\n       errCode \u003d 2;\n     } else if (lastLine.endsWith(NamenodeFsck.DECOMMISSIONING_STATUS)) {\n       errCode \u003d 3;\n+    } else if (lastLine.endsWith(NamenodeFsck.IN_MAINTENANCE_STATUS))  {\n+      errCode \u003d 4;\n+    } else if (lastLine.endsWith(NamenodeFsck.ENTERING_MAINTENANCE_STATUS)) {\n+      errCode \u003d 5;\n     }\n     return errCode;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int doWork(final String[] args) throws IOException {\n    final StringBuilder url \u003d new StringBuilder();\n    \n    url.append(\"/fsck?ugi\u003d\").append(ugi.getShortUserName());\n    String dir \u003d null;\n    boolean doListCorruptFileBlocks \u003d false;\n    for (int idx \u003d 0; idx \u003c args.length; idx++) {\n      if (args[idx].equals(\"-move\")) { url.append(\"\u0026move\u003d1\"); }\n      else if (args[idx].equals(\"-delete\")) { url.append(\"\u0026delete\u003d1\"); }\n      else if (args[idx].equals(\"-files\")) { url.append(\"\u0026files\u003d1\"); }\n      else if (args[idx].equals(\"-openforwrite\")) { url.append(\"\u0026openforwrite\u003d1\"); }\n      else if (args[idx].equals(\"-blocks\")) { url.append(\"\u0026blocks\u003d1\"); }\n      else if (args[idx].equals(\"-locations\")) { url.append(\"\u0026locations\u003d1\"); }\n      else if (args[idx].equals(\"-racks\")) { url.append(\"\u0026racks\u003d1\"); }\n      else if (args[idx].equals(\"-replicaDetails\")) {\n        url.append(\"\u0026replicadetails\u003d1\");\n      } else if (args[idx].equals(\"-upgradedomains\")) {\n        url.append(\"\u0026upgradedomains\u003d1\");\n      } else if (args[idx].equals(\"-storagepolicies\")) {\n        url.append(\"\u0026storagepolicies\u003d1\");\n      } else if (args[idx].equals(\"-showprogress\")) {\n        url.append(\"\u0026showprogress\u003d1\");\n      } else if (args[idx].equals(\"-list-corruptfileblocks\")) {\n        url.append(\"\u0026listcorruptfileblocks\u003d1\");\n        doListCorruptFileBlocks \u003d true;\n      } else if (args[idx].equals(\"-includeSnapshots\")) {\n        url.append(\"\u0026includeSnapshots\u003d1\");\n      } else if (args[idx].equals(\"-maintenance\")) {\n        url.append(\"\u0026maintenance\u003d1\");\n      } else if (args[idx].equals(\"-blockId\")) {\n        StringBuilder sb \u003d new StringBuilder();\n        idx++;\n        while(idx \u003c args.length \u0026\u0026 !args[idx].startsWith(\"-\")){\n          sb.append(args[idx]);\n          sb.append(\" \");\n          idx++;\n        }\n        url.append(\"\u0026blockId\u003d\").append(URLEncoder.encode(sb.toString(), \"UTF-8\"));\n      } else if (!args[idx].startsWith(\"-\")) {\n        if (null \u003d\u003d dir) {\n          dir \u003d args[idx];\n        } else {\n          System.err.println(\"fsck: can only operate on one path at a time \u0027\"\n              + args[idx] + \"\u0027\");\n          printUsage(System.err);\n          return -1;\n        }\n\n      } else {\n        System.err.println(\"fsck: Illegal option \u0027\" + args[idx] + \"\u0027\");\n        printUsage(System.err);\n        return -1;\n      }\n    }\n    if (null \u003d\u003d dir) {\n      dir \u003d \"/\";\n    }\n\n    Path dirpath \u003d null;\n    URI namenodeAddress \u003d null;\n    try {\n      dirpath \u003d getResolvedPath(dir);\n      namenodeAddress \u003d getCurrentNamenodeAddress(dirpath);\n    } catch (IOException ioe) {\n      System.err.println(\"FileSystem is inaccessible due to:\\n\"\n          + ioe.toString());\n    }\n\n    if (namenodeAddress \u003d\u003d null) {\n      //Error message already output in {@link #getCurrentNamenodeAddress()}\n      System.err.println(\"DFSck exiting.\");\n      return 0;\n    }\n\n    url.insert(0, namenodeAddress.toString());\n    url.append(\"\u0026path\u003d\").append(URLEncoder.encode(\n        Path.getPathWithoutSchemeAndAuthority(dirpath).toString(), \"UTF-8\"));\n    System.err.println(\"Connecting to namenode via \" + url.toString());\n\n    if (doListCorruptFileBlocks) {\n      return listCorruptFileBlocks(dir, url.toString());\n    }\n    URL path \u003d new URL(url.toString());\n    URLConnection connection;\n    try {\n      connection \u003d connectionFactory.openConnection(path, isSpnegoEnabled);\n    } catch (AuthenticationException e) {\n      throw new IOException(e);\n    }\n    InputStream stream \u003d connection.getInputStream();\n    BufferedReader input \u003d new BufferedReader(new InputStreamReader(\n                                              stream, \"UTF-8\"));\n    String line \u003d null;\n    String lastLine \u003d null;\n    int errCode \u003d -1;\n    try {\n      while ((line \u003d input.readLine()) !\u003d null) {\n        out.println(line);\n        lastLine \u003d line;\n      }\n    } finally {\n      input.close();\n    }\n    if (lastLine.endsWith(NamenodeFsck.HEALTHY_STATUS)) {\n      errCode \u003d 0;\n    } else if (lastLine.endsWith(NamenodeFsck.CORRUPT_STATUS)) {\n      errCode \u003d 1;\n    } else if (lastLine.endsWith(NamenodeFsck.NONEXISTENT_STATUS)) {\n      errCode \u003d 0;\n    } else if (lastLine.contains(\"Incorrect blockId format:\")) {\n      errCode \u003d 0;\n    } else if (lastLine.endsWith(NamenodeFsck.DECOMMISSIONED_STATUS)) {\n      errCode \u003d 2;\n    } else if (lastLine.endsWith(NamenodeFsck.DECOMMISSIONING_STATUS)) {\n      errCode \u003d 3;\n    } else if (lastLine.endsWith(NamenodeFsck.IN_MAINTENANCE_STATUS))  {\n      errCode \u003d 4;\n    } else if (lastLine.endsWith(NamenodeFsck.ENTERING_MAINTENANCE_STATUS)) {\n      errCode \u003d 5;\n    }\n    return errCode;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DFSck.java",
      "extendedDetails": {}
    },
    "2f8e9b7e4b1721ed5c7db8882eff70f83164e320": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HDFS-11259. Update fsck to display maintenance state info. (Manoj Govindassamy via lei)\"\n\nThis reverts commit c18590fce283378edb09acd4e764706a9a4a8b5f.\n",
      "commitDate": "15/01/17 11:11 PM",
      "commitName": "2f8e9b7e4b1721ed5c7db8882eff70f83164e320",
      "commitAuthor": "Lei Xu",
      "commitDateOld": "10/01/17 3:37 AM",
      "commitNameOld": "c18590fce283378edb09acd4e764706a9a4a8b5f",
      "commitAuthorOld": "Lei Xu",
      "daysBetweenCommits": 5.82,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,120 +1,116 @@\n   private int doWork(final String[] args) throws IOException {\n     final StringBuilder url \u003d new StringBuilder();\n     \n     url.append(\"/fsck?ugi\u003d\").append(ugi.getShortUserName());\n     String dir \u003d null;\n     boolean doListCorruptFileBlocks \u003d false;\n     for (int idx \u003d 0; idx \u003c args.length; idx++) {\n       if (args[idx].equals(\"-move\")) { url.append(\"\u0026move\u003d1\"); }\n       else if (args[idx].equals(\"-delete\")) { url.append(\"\u0026delete\u003d1\"); }\n       else if (args[idx].equals(\"-files\")) { url.append(\"\u0026files\u003d1\"); }\n       else if (args[idx].equals(\"-openforwrite\")) { url.append(\"\u0026openforwrite\u003d1\"); }\n       else if (args[idx].equals(\"-blocks\")) { url.append(\"\u0026blocks\u003d1\"); }\n       else if (args[idx].equals(\"-locations\")) { url.append(\"\u0026locations\u003d1\"); }\n       else if (args[idx].equals(\"-racks\")) { url.append(\"\u0026racks\u003d1\"); }\n       else if (args[idx].equals(\"-replicaDetails\")) {\n         url.append(\"\u0026replicadetails\u003d1\");\n       } else if (args[idx].equals(\"-upgradedomains\")) {\n         url.append(\"\u0026upgradedomains\u003d1\");\n       } else if (args[idx].equals(\"-storagepolicies\")) {\n         url.append(\"\u0026storagepolicies\u003d1\");\n       } else if (args[idx].equals(\"-showprogress\")) {\n         url.append(\"\u0026showprogress\u003d1\");\n       } else if (args[idx].equals(\"-list-corruptfileblocks\")) {\n         url.append(\"\u0026listcorruptfileblocks\u003d1\");\n         doListCorruptFileBlocks \u003d true;\n       } else if (args[idx].equals(\"-includeSnapshots\")) {\n         url.append(\"\u0026includeSnapshots\u003d1\");\n       } else if (args[idx].equals(\"-blockId\")) {\n         StringBuilder sb \u003d new StringBuilder();\n         idx++;\n         while(idx \u003c args.length \u0026\u0026 !args[idx].startsWith(\"-\")){\n           sb.append(args[idx]);\n           sb.append(\" \");\n           idx++;\n         }\n         url.append(\"\u0026blockId\u003d\").append(URLEncoder.encode(sb.toString(), \"UTF-8\"));\n       } else if (!args[idx].startsWith(\"-\")) {\n         if (null \u003d\u003d dir) {\n           dir \u003d args[idx];\n         } else {\n           System.err.println(\"fsck: can only operate on one path at a time \u0027\"\n               + args[idx] + \"\u0027\");\n           printUsage(System.err);\n           return -1;\n         }\n \n       } else {\n         System.err.println(\"fsck: Illegal option \u0027\" + args[idx] + \"\u0027\");\n         printUsage(System.err);\n         return -1;\n       }\n     }\n     if (null \u003d\u003d dir) {\n       dir \u003d \"/\";\n     }\n \n     Path dirpath \u003d null;\n     URI namenodeAddress \u003d null;\n     try {\n       dirpath \u003d getResolvedPath(dir);\n       namenodeAddress \u003d getCurrentNamenodeAddress(dirpath);\n     } catch (IOException ioe) {\n       System.err.println(\"FileSystem is inaccessible due to:\\n\"\n           + ioe.toString());\n     }\n \n     if (namenodeAddress \u003d\u003d null) {\n       //Error message already output in {@link #getCurrentNamenodeAddress()}\n       System.err.println(\"DFSck exiting.\");\n       return 0;\n     }\n \n     url.insert(0, namenodeAddress.toString());\n     url.append(\"\u0026path\u003d\").append(URLEncoder.encode(\n         Path.getPathWithoutSchemeAndAuthority(dirpath).toString(), \"UTF-8\"));\n     System.err.println(\"Connecting to namenode via \" + url.toString());\n \n     if (doListCorruptFileBlocks) {\n       return listCorruptFileBlocks(dir, url.toString());\n     }\n     URL path \u003d new URL(url.toString());\n     URLConnection connection;\n     try {\n       connection \u003d connectionFactory.openConnection(path, isSpnegoEnabled);\n     } catch (AuthenticationException e) {\n       throw new IOException(e);\n     }\n     InputStream stream \u003d connection.getInputStream();\n     BufferedReader input \u003d new BufferedReader(new InputStreamReader(\n                                               stream, \"UTF-8\"));\n     String line \u003d null;\n     String lastLine \u003d null;\n     int errCode \u003d -1;\n     try {\n       while ((line \u003d input.readLine()) !\u003d null) {\n         out.println(line);\n         lastLine \u003d line;\n       }\n     } finally {\n       input.close();\n     }\n     if (lastLine.endsWith(NamenodeFsck.HEALTHY_STATUS)) {\n       errCode \u003d 0;\n     } else if (lastLine.endsWith(NamenodeFsck.CORRUPT_STATUS)) {\n       errCode \u003d 1;\n     } else if (lastLine.endsWith(NamenodeFsck.NONEXISTENT_STATUS)) {\n       errCode \u003d 0;\n     } else if (lastLine.contains(\"Incorrect blockId format:\")) {\n       errCode \u003d 0;\n     } else if (lastLine.endsWith(NamenodeFsck.DECOMMISSIONED_STATUS)) {\n       errCode \u003d 2;\n     } else if (lastLine.endsWith(NamenodeFsck.DECOMMISSIONING_STATUS)) {\n       errCode \u003d 3;\n-    } else if (lastLine.endsWith(NamenodeFsck.IN_MAINTENANCE_STATUS))  {\n-      errCode \u003d 4;\n-    } else if (lastLine.endsWith(NamenodeFsck.ENTERING_MAINTENANCE_STATUS)) {\n-      errCode \u003d 5;\n     }\n     return errCode;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int doWork(final String[] args) throws IOException {\n    final StringBuilder url \u003d new StringBuilder();\n    \n    url.append(\"/fsck?ugi\u003d\").append(ugi.getShortUserName());\n    String dir \u003d null;\n    boolean doListCorruptFileBlocks \u003d false;\n    for (int idx \u003d 0; idx \u003c args.length; idx++) {\n      if (args[idx].equals(\"-move\")) { url.append(\"\u0026move\u003d1\"); }\n      else if (args[idx].equals(\"-delete\")) { url.append(\"\u0026delete\u003d1\"); }\n      else if (args[idx].equals(\"-files\")) { url.append(\"\u0026files\u003d1\"); }\n      else if (args[idx].equals(\"-openforwrite\")) { url.append(\"\u0026openforwrite\u003d1\"); }\n      else if (args[idx].equals(\"-blocks\")) { url.append(\"\u0026blocks\u003d1\"); }\n      else if (args[idx].equals(\"-locations\")) { url.append(\"\u0026locations\u003d1\"); }\n      else if (args[idx].equals(\"-racks\")) { url.append(\"\u0026racks\u003d1\"); }\n      else if (args[idx].equals(\"-replicaDetails\")) {\n        url.append(\"\u0026replicadetails\u003d1\");\n      } else if (args[idx].equals(\"-upgradedomains\")) {\n        url.append(\"\u0026upgradedomains\u003d1\");\n      } else if (args[idx].equals(\"-storagepolicies\")) {\n        url.append(\"\u0026storagepolicies\u003d1\");\n      } else if (args[idx].equals(\"-showprogress\")) {\n        url.append(\"\u0026showprogress\u003d1\");\n      } else if (args[idx].equals(\"-list-corruptfileblocks\")) {\n        url.append(\"\u0026listcorruptfileblocks\u003d1\");\n        doListCorruptFileBlocks \u003d true;\n      } else if (args[idx].equals(\"-includeSnapshots\")) {\n        url.append(\"\u0026includeSnapshots\u003d1\");\n      } else if (args[idx].equals(\"-blockId\")) {\n        StringBuilder sb \u003d new StringBuilder();\n        idx++;\n        while(idx \u003c args.length \u0026\u0026 !args[idx].startsWith(\"-\")){\n          sb.append(args[idx]);\n          sb.append(\" \");\n          idx++;\n        }\n        url.append(\"\u0026blockId\u003d\").append(URLEncoder.encode(sb.toString(), \"UTF-8\"));\n      } else if (!args[idx].startsWith(\"-\")) {\n        if (null \u003d\u003d dir) {\n          dir \u003d args[idx];\n        } else {\n          System.err.println(\"fsck: can only operate on one path at a time \u0027\"\n              + args[idx] + \"\u0027\");\n          printUsage(System.err);\n          return -1;\n        }\n\n      } else {\n        System.err.println(\"fsck: Illegal option \u0027\" + args[idx] + \"\u0027\");\n        printUsage(System.err);\n        return -1;\n      }\n    }\n    if (null \u003d\u003d dir) {\n      dir \u003d \"/\";\n    }\n\n    Path dirpath \u003d null;\n    URI namenodeAddress \u003d null;\n    try {\n      dirpath \u003d getResolvedPath(dir);\n      namenodeAddress \u003d getCurrentNamenodeAddress(dirpath);\n    } catch (IOException ioe) {\n      System.err.println(\"FileSystem is inaccessible due to:\\n\"\n          + ioe.toString());\n    }\n\n    if (namenodeAddress \u003d\u003d null) {\n      //Error message already output in {@link #getCurrentNamenodeAddress()}\n      System.err.println(\"DFSck exiting.\");\n      return 0;\n    }\n\n    url.insert(0, namenodeAddress.toString());\n    url.append(\"\u0026path\u003d\").append(URLEncoder.encode(\n        Path.getPathWithoutSchemeAndAuthority(dirpath).toString(), \"UTF-8\"));\n    System.err.println(\"Connecting to namenode via \" + url.toString());\n\n    if (doListCorruptFileBlocks) {\n      return listCorruptFileBlocks(dir, url.toString());\n    }\n    URL path \u003d new URL(url.toString());\n    URLConnection connection;\n    try {\n      connection \u003d connectionFactory.openConnection(path, isSpnegoEnabled);\n    } catch (AuthenticationException e) {\n      throw new IOException(e);\n    }\n    InputStream stream \u003d connection.getInputStream();\n    BufferedReader input \u003d new BufferedReader(new InputStreamReader(\n                                              stream, \"UTF-8\"));\n    String line \u003d null;\n    String lastLine \u003d null;\n    int errCode \u003d -1;\n    try {\n      while ((line \u003d input.readLine()) !\u003d null) {\n        out.println(line);\n        lastLine \u003d line;\n      }\n    } finally {\n      input.close();\n    }\n    if (lastLine.endsWith(NamenodeFsck.HEALTHY_STATUS)) {\n      errCode \u003d 0;\n    } else if (lastLine.endsWith(NamenodeFsck.CORRUPT_STATUS)) {\n      errCode \u003d 1;\n    } else if (lastLine.endsWith(NamenodeFsck.NONEXISTENT_STATUS)) {\n      errCode \u003d 0;\n    } else if (lastLine.contains(\"Incorrect blockId format:\")) {\n      errCode \u003d 0;\n    } else if (lastLine.endsWith(NamenodeFsck.DECOMMISSIONED_STATUS)) {\n      errCode \u003d 2;\n    } else if (lastLine.endsWith(NamenodeFsck.DECOMMISSIONING_STATUS)) {\n      errCode \u003d 3;\n    }\n    return errCode;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DFSck.java",
      "extendedDetails": {}
    },
    "c18590fce283378edb09acd4e764706a9a4a8b5f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11259. Update fsck to display maintenance state info. (Manoj Govindassamy via lei)\n",
      "commitDate": "10/01/17 3:37 AM",
      "commitName": "c18590fce283378edb09acd4e764706a9a4a8b5f",
      "commitAuthor": "Lei Xu",
      "commitDateOld": "14/06/16 8:05 PM",
      "commitNameOld": "7d521a29eed62c4329b16034375bd5fb747a92a9",
      "commitAuthorOld": "Ming Ma",
      "daysBetweenCommits": 209.36,
      "commitsBetweenForRepo": 1529,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,116 +1,120 @@\n   private int doWork(final String[] args) throws IOException {\n     final StringBuilder url \u003d new StringBuilder();\n     \n     url.append(\"/fsck?ugi\u003d\").append(ugi.getShortUserName());\n     String dir \u003d null;\n     boolean doListCorruptFileBlocks \u003d false;\n     for (int idx \u003d 0; idx \u003c args.length; idx++) {\n       if (args[idx].equals(\"-move\")) { url.append(\"\u0026move\u003d1\"); }\n       else if (args[idx].equals(\"-delete\")) { url.append(\"\u0026delete\u003d1\"); }\n       else if (args[idx].equals(\"-files\")) { url.append(\"\u0026files\u003d1\"); }\n       else if (args[idx].equals(\"-openforwrite\")) { url.append(\"\u0026openforwrite\u003d1\"); }\n       else if (args[idx].equals(\"-blocks\")) { url.append(\"\u0026blocks\u003d1\"); }\n       else if (args[idx].equals(\"-locations\")) { url.append(\"\u0026locations\u003d1\"); }\n       else if (args[idx].equals(\"-racks\")) { url.append(\"\u0026racks\u003d1\"); }\n       else if (args[idx].equals(\"-replicaDetails\")) {\n         url.append(\"\u0026replicadetails\u003d1\");\n       } else if (args[idx].equals(\"-upgradedomains\")) {\n         url.append(\"\u0026upgradedomains\u003d1\");\n       } else if (args[idx].equals(\"-storagepolicies\")) {\n         url.append(\"\u0026storagepolicies\u003d1\");\n       } else if (args[idx].equals(\"-showprogress\")) {\n         url.append(\"\u0026showprogress\u003d1\");\n       } else if (args[idx].equals(\"-list-corruptfileblocks\")) {\n         url.append(\"\u0026listcorruptfileblocks\u003d1\");\n         doListCorruptFileBlocks \u003d true;\n       } else if (args[idx].equals(\"-includeSnapshots\")) {\n         url.append(\"\u0026includeSnapshots\u003d1\");\n       } else if (args[idx].equals(\"-blockId\")) {\n         StringBuilder sb \u003d new StringBuilder();\n         idx++;\n         while(idx \u003c args.length \u0026\u0026 !args[idx].startsWith(\"-\")){\n           sb.append(args[idx]);\n           sb.append(\" \");\n           idx++;\n         }\n         url.append(\"\u0026blockId\u003d\").append(URLEncoder.encode(sb.toString(), \"UTF-8\"));\n       } else if (!args[idx].startsWith(\"-\")) {\n         if (null \u003d\u003d dir) {\n           dir \u003d args[idx];\n         } else {\n           System.err.println(\"fsck: can only operate on one path at a time \u0027\"\n               + args[idx] + \"\u0027\");\n           printUsage(System.err);\n           return -1;\n         }\n \n       } else {\n         System.err.println(\"fsck: Illegal option \u0027\" + args[idx] + \"\u0027\");\n         printUsage(System.err);\n         return -1;\n       }\n     }\n     if (null \u003d\u003d dir) {\n       dir \u003d \"/\";\n     }\n \n     Path dirpath \u003d null;\n     URI namenodeAddress \u003d null;\n     try {\n       dirpath \u003d getResolvedPath(dir);\n       namenodeAddress \u003d getCurrentNamenodeAddress(dirpath);\n     } catch (IOException ioe) {\n       System.err.println(\"FileSystem is inaccessible due to:\\n\"\n           + ioe.toString());\n     }\n \n     if (namenodeAddress \u003d\u003d null) {\n       //Error message already output in {@link #getCurrentNamenodeAddress()}\n       System.err.println(\"DFSck exiting.\");\n       return 0;\n     }\n \n     url.insert(0, namenodeAddress.toString());\n     url.append(\"\u0026path\u003d\").append(URLEncoder.encode(\n         Path.getPathWithoutSchemeAndAuthority(dirpath).toString(), \"UTF-8\"));\n     System.err.println(\"Connecting to namenode via \" + url.toString());\n \n     if (doListCorruptFileBlocks) {\n       return listCorruptFileBlocks(dir, url.toString());\n     }\n     URL path \u003d new URL(url.toString());\n     URLConnection connection;\n     try {\n       connection \u003d connectionFactory.openConnection(path, isSpnegoEnabled);\n     } catch (AuthenticationException e) {\n       throw new IOException(e);\n     }\n     InputStream stream \u003d connection.getInputStream();\n     BufferedReader input \u003d new BufferedReader(new InputStreamReader(\n                                               stream, \"UTF-8\"));\n     String line \u003d null;\n     String lastLine \u003d null;\n     int errCode \u003d -1;\n     try {\n       while ((line \u003d input.readLine()) !\u003d null) {\n         out.println(line);\n         lastLine \u003d line;\n       }\n     } finally {\n       input.close();\n     }\n     if (lastLine.endsWith(NamenodeFsck.HEALTHY_STATUS)) {\n       errCode \u003d 0;\n     } else if (lastLine.endsWith(NamenodeFsck.CORRUPT_STATUS)) {\n       errCode \u003d 1;\n     } else if (lastLine.endsWith(NamenodeFsck.NONEXISTENT_STATUS)) {\n       errCode \u003d 0;\n     } else if (lastLine.contains(\"Incorrect blockId format:\")) {\n       errCode \u003d 0;\n     } else if (lastLine.endsWith(NamenodeFsck.DECOMMISSIONED_STATUS)) {\n       errCode \u003d 2;\n     } else if (lastLine.endsWith(NamenodeFsck.DECOMMISSIONING_STATUS)) {\n       errCode \u003d 3;\n+    } else if (lastLine.endsWith(NamenodeFsck.IN_MAINTENANCE_STATUS))  {\n+      errCode \u003d 4;\n+    } else if (lastLine.endsWith(NamenodeFsck.ENTERING_MAINTENANCE_STATUS)) {\n+      errCode \u003d 5;\n     }\n     return errCode;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int doWork(final String[] args) throws IOException {\n    final StringBuilder url \u003d new StringBuilder();\n    \n    url.append(\"/fsck?ugi\u003d\").append(ugi.getShortUserName());\n    String dir \u003d null;\n    boolean doListCorruptFileBlocks \u003d false;\n    for (int idx \u003d 0; idx \u003c args.length; idx++) {\n      if (args[idx].equals(\"-move\")) { url.append(\"\u0026move\u003d1\"); }\n      else if (args[idx].equals(\"-delete\")) { url.append(\"\u0026delete\u003d1\"); }\n      else if (args[idx].equals(\"-files\")) { url.append(\"\u0026files\u003d1\"); }\n      else if (args[idx].equals(\"-openforwrite\")) { url.append(\"\u0026openforwrite\u003d1\"); }\n      else if (args[idx].equals(\"-blocks\")) { url.append(\"\u0026blocks\u003d1\"); }\n      else if (args[idx].equals(\"-locations\")) { url.append(\"\u0026locations\u003d1\"); }\n      else if (args[idx].equals(\"-racks\")) { url.append(\"\u0026racks\u003d1\"); }\n      else if (args[idx].equals(\"-replicaDetails\")) {\n        url.append(\"\u0026replicadetails\u003d1\");\n      } else if (args[idx].equals(\"-upgradedomains\")) {\n        url.append(\"\u0026upgradedomains\u003d1\");\n      } else if (args[idx].equals(\"-storagepolicies\")) {\n        url.append(\"\u0026storagepolicies\u003d1\");\n      } else if (args[idx].equals(\"-showprogress\")) {\n        url.append(\"\u0026showprogress\u003d1\");\n      } else if (args[idx].equals(\"-list-corruptfileblocks\")) {\n        url.append(\"\u0026listcorruptfileblocks\u003d1\");\n        doListCorruptFileBlocks \u003d true;\n      } else if (args[idx].equals(\"-includeSnapshots\")) {\n        url.append(\"\u0026includeSnapshots\u003d1\");\n      } else if (args[idx].equals(\"-blockId\")) {\n        StringBuilder sb \u003d new StringBuilder();\n        idx++;\n        while(idx \u003c args.length \u0026\u0026 !args[idx].startsWith(\"-\")){\n          sb.append(args[idx]);\n          sb.append(\" \");\n          idx++;\n        }\n        url.append(\"\u0026blockId\u003d\").append(URLEncoder.encode(sb.toString(), \"UTF-8\"));\n      } else if (!args[idx].startsWith(\"-\")) {\n        if (null \u003d\u003d dir) {\n          dir \u003d args[idx];\n        } else {\n          System.err.println(\"fsck: can only operate on one path at a time \u0027\"\n              + args[idx] + \"\u0027\");\n          printUsage(System.err);\n          return -1;\n        }\n\n      } else {\n        System.err.println(\"fsck: Illegal option \u0027\" + args[idx] + \"\u0027\");\n        printUsage(System.err);\n        return -1;\n      }\n    }\n    if (null \u003d\u003d dir) {\n      dir \u003d \"/\";\n    }\n\n    Path dirpath \u003d null;\n    URI namenodeAddress \u003d null;\n    try {\n      dirpath \u003d getResolvedPath(dir);\n      namenodeAddress \u003d getCurrentNamenodeAddress(dirpath);\n    } catch (IOException ioe) {\n      System.err.println(\"FileSystem is inaccessible due to:\\n\"\n          + ioe.toString());\n    }\n\n    if (namenodeAddress \u003d\u003d null) {\n      //Error message already output in {@link #getCurrentNamenodeAddress()}\n      System.err.println(\"DFSck exiting.\");\n      return 0;\n    }\n\n    url.insert(0, namenodeAddress.toString());\n    url.append(\"\u0026path\u003d\").append(URLEncoder.encode(\n        Path.getPathWithoutSchemeAndAuthority(dirpath).toString(), \"UTF-8\"));\n    System.err.println(\"Connecting to namenode via \" + url.toString());\n\n    if (doListCorruptFileBlocks) {\n      return listCorruptFileBlocks(dir, url.toString());\n    }\n    URL path \u003d new URL(url.toString());\n    URLConnection connection;\n    try {\n      connection \u003d connectionFactory.openConnection(path, isSpnegoEnabled);\n    } catch (AuthenticationException e) {\n      throw new IOException(e);\n    }\n    InputStream stream \u003d connection.getInputStream();\n    BufferedReader input \u003d new BufferedReader(new InputStreamReader(\n                                              stream, \"UTF-8\"));\n    String line \u003d null;\n    String lastLine \u003d null;\n    int errCode \u003d -1;\n    try {\n      while ((line \u003d input.readLine()) !\u003d null) {\n        out.println(line);\n        lastLine \u003d line;\n      }\n    } finally {\n      input.close();\n    }\n    if (lastLine.endsWith(NamenodeFsck.HEALTHY_STATUS)) {\n      errCode \u003d 0;\n    } else if (lastLine.endsWith(NamenodeFsck.CORRUPT_STATUS)) {\n      errCode \u003d 1;\n    } else if (lastLine.endsWith(NamenodeFsck.NONEXISTENT_STATUS)) {\n      errCode \u003d 0;\n    } else if (lastLine.contains(\"Incorrect blockId format:\")) {\n      errCode \u003d 0;\n    } else if (lastLine.endsWith(NamenodeFsck.DECOMMISSIONED_STATUS)) {\n      errCode \u003d 2;\n    } else if (lastLine.endsWith(NamenodeFsck.DECOMMISSIONING_STATUS)) {\n      errCode \u003d 3;\n    } else if (lastLine.endsWith(NamenodeFsck.IN_MAINTENANCE_STATUS))  {\n      errCode \u003d 4;\n    } else if (lastLine.endsWith(NamenodeFsck.ENTERING_MAINTENANCE_STATUS)) {\n      errCode \u003d 5;\n    }\n    return errCode;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DFSck.java",
      "extendedDetails": {}
    },
    "7d521a29eed62c4329b16034375bd5fb747a92a9": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9016. Display upgrade domain information in fsck. (mingma)\n",
      "commitDate": "14/06/16 8:05 PM",
      "commitName": "7d521a29eed62c4329b16034375bd5fb747a92a9",
      "commitAuthor": "Ming Ma",
      "commitDateOld": "26/10/15 3:15 PM",
      "commitNameOld": "677a936bf759515ac94d9accb9bf5364f688d051",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 232.2,
      "commitsBetweenForRepo": 1504,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,113 +1,116 @@\n   private int doWork(final String[] args) throws IOException {\n     final StringBuilder url \u003d new StringBuilder();\n     \n     url.append(\"/fsck?ugi\u003d\").append(ugi.getShortUserName());\n     String dir \u003d null;\n     boolean doListCorruptFileBlocks \u003d false;\n     for (int idx \u003d 0; idx \u003c args.length; idx++) {\n       if (args[idx].equals(\"-move\")) { url.append(\"\u0026move\u003d1\"); }\n       else if (args[idx].equals(\"-delete\")) { url.append(\"\u0026delete\u003d1\"); }\n       else if (args[idx].equals(\"-files\")) { url.append(\"\u0026files\u003d1\"); }\n       else if (args[idx].equals(\"-openforwrite\")) { url.append(\"\u0026openforwrite\u003d1\"); }\n       else if (args[idx].equals(\"-blocks\")) { url.append(\"\u0026blocks\u003d1\"); }\n       else if (args[idx].equals(\"-locations\")) { url.append(\"\u0026locations\u003d1\"); }\n       else if (args[idx].equals(\"-racks\")) { url.append(\"\u0026racks\u003d1\"); }\n       else if (args[idx].equals(\"-replicaDetails\")) {\n         url.append(\"\u0026replicadetails\u003d1\");\n-      }\n-      else if (args[idx].equals(\"-storagepolicies\")) { url.append(\"\u0026storagepolicies\u003d1\"); }\n-      else if (args[idx].equals(\"-showprogress\")) { url.append(\"\u0026showprogress\u003d1\"); }\n-      else if (args[idx].equals(\"-list-corruptfileblocks\")) {\n+      } else if (args[idx].equals(\"-upgradedomains\")) {\n+        url.append(\"\u0026upgradedomains\u003d1\");\n+      } else if (args[idx].equals(\"-storagepolicies\")) {\n+        url.append(\"\u0026storagepolicies\u003d1\");\n+      } else if (args[idx].equals(\"-showprogress\")) {\n+        url.append(\"\u0026showprogress\u003d1\");\n+      } else if (args[idx].equals(\"-list-corruptfileblocks\")) {\n         url.append(\"\u0026listcorruptfileblocks\u003d1\");\n         doListCorruptFileBlocks \u003d true;\n       } else if (args[idx].equals(\"-includeSnapshots\")) {\n         url.append(\"\u0026includeSnapshots\u003d1\");\n       } else if (args[idx].equals(\"-blockId\")) {\n         StringBuilder sb \u003d new StringBuilder();\n         idx++;\n         while(idx \u003c args.length \u0026\u0026 !args[idx].startsWith(\"-\")){\n           sb.append(args[idx]);\n           sb.append(\" \");\n           idx++;\n         }\n         url.append(\"\u0026blockId\u003d\").append(URLEncoder.encode(sb.toString(), \"UTF-8\"));\n       } else if (!args[idx].startsWith(\"-\")) {\n         if (null \u003d\u003d dir) {\n           dir \u003d args[idx];\n         } else {\n           System.err.println(\"fsck: can only operate on one path at a time \u0027\"\n               + args[idx] + \"\u0027\");\n           printUsage(System.err);\n           return -1;\n         }\n \n       } else {\n         System.err.println(\"fsck: Illegal option \u0027\" + args[idx] + \"\u0027\");\n         printUsage(System.err);\n         return -1;\n       }\n     }\n     if (null \u003d\u003d dir) {\n       dir \u003d \"/\";\n     }\n \n     Path dirpath \u003d null;\n     URI namenodeAddress \u003d null;\n     try {\n       dirpath \u003d getResolvedPath(dir);\n       namenodeAddress \u003d getCurrentNamenodeAddress(dirpath);\n     } catch (IOException ioe) {\n       System.err.println(\"FileSystem is inaccessible due to:\\n\"\n           + ioe.toString());\n     }\n \n     if (namenodeAddress \u003d\u003d null) {\n       //Error message already output in {@link #getCurrentNamenodeAddress()}\n       System.err.println(\"DFSck exiting.\");\n       return 0;\n     }\n \n     url.insert(0, namenodeAddress.toString());\n     url.append(\"\u0026path\u003d\").append(URLEncoder.encode(\n         Path.getPathWithoutSchemeAndAuthority(dirpath).toString(), \"UTF-8\"));\n     System.err.println(\"Connecting to namenode via \" + url.toString());\n \n     if (doListCorruptFileBlocks) {\n       return listCorruptFileBlocks(dir, url.toString());\n     }\n     URL path \u003d new URL(url.toString());\n     URLConnection connection;\n     try {\n       connection \u003d connectionFactory.openConnection(path, isSpnegoEnabled);\n     } catch (AuthenticationException e) {\n       throw new IOException(e);\n     }\n     InputStream stream \u003d connection.getInputStream();\n     BufferedReader input \u003d new BufferedReader(new InputStreamReader(\n                                               stream, \"UTF-8\"));\n     String line \u003d null;\n     String lastLine \u003d null;\n     int errCode \u003d -1;\n     try {\n       while ((line \u003d input.readLine()) !\u003d null) {\n         out.println(line);\n         lastLine \u003d line;\n       }\n     } finally {\n       input.close();\n     }\n     if (lastLine.endsWith(NamenodeFsck.HEALTHY_STATUS)) {\n       errCode \u003d 0;\n     } else if (lastLine.endsWith(NamenodeFsck.CORRUPT_STATUS)) {\n       errCode \u003d 1;\n     } else if (lastLine.endsWith(NamenodeFsck.NONEXISTENT_STATUS)) {\n       errCode \u003d 0;\n     } else if (lastLine.contains(\"Incorrect blockId format:\")) {\n       errCode \u003d 0;\n     } else if (lastLine.endsWith(NamenodeFsck.DECOMMISSIONED_STATUS)) {\n       errCode \u003d 2;\n     } else if (lastLine.endsWith(NamenodeFsck.DECOMMISSIONING_STATUS)) {\n       errCode \u003d 3;\n     }\n     return errCode;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int doWork(final String[] args) throws IOException {\n    final StringBuilder url \u003d new StringBuilder();\n    \n    url.append(\"/fsck?ugi\u003d\").append(ugi.getShortUserName());\n    String dir \u003d null;\n    boolean doListCorruptFileBlocks \u003d false;\n    for (int idx \u003d 0; idx \u003c args.length; idx++) {\n      if (args[idx].equals(\"-move\")) { url.append(\"\u0026move\u003d1\"); }\n      else if (args[idx].equals(\"-delete\")) { url.append(\"\u0026delete\u003d1\"); }\n      else if (args[idx].equals(\"-files\")) { url.append(\"\u0026files\u003d1\"); }\n      else if (args[idx].equals(\"-openforwrite\")) { url.append(\"\u0026openforwrite\u003d1\"); }\n      else if (args[idx].equals(\"-blocks\")) { url.append(\"\u0026blocks\u003d1\"); }\n      else if (args[idx].equals(\"-locations\")) { url.append(\"\u0026locations\u003d1\"); }\n      else if (args[idx].equals(\"-racks\")) { url.append(\"\u0026racks\u003d1\"); }\n      else if (args[idx].equals(\"-replicaDetails\")) {\n        url.append(\"\u0026replicadetails\u003d1\");\n      } else if (args[idx].equals(\"-upgradedomains\")) {\n        url.append(\"\u0026upgradedomains\u003d1\");\n      } else if (args[idx].equals(\"-storagepolicies\")) {\n        url.append(\"\u0026storagepolicies\u003d1\");\n      } else if (args[idx].equals(\"-showprogress\")) {\n        url.append(\"\u0026showprogress\u003d1\");\n      } else if (args[idx].equals(\"-list-corruptfileblocks\")) {\n        url.append(\"\u0026listcorruptfileblocks\u003d1\");\n        doListCorruptFileBlocks \u003d true;\n      } else if (args[idx].equals(\"-includeSnapshots\")) {\n        url.append(\"\u0026includeSnapshots\u003d1\");\n      } else if (args[idx].equals(\"-blockId\")) {\n        StringBuilder sb \u003d new StringBuilder();\n        idx++;\n        while(idx \u003c args.length \u0026\u0026 !args[idx].startsWith(\"-\")){\n          sb.append(args[idx]);\n          sb.append(\" \");\n          idx++;\n        }\n        url.append(\"\u0026blockId\u003d\").append(URLEncoder.encode(sb.toString(), \"UTF-8\"));\n      } else if (!args[idx].startsWith(\"-\")) {\n        if (null \u003d\u003d dir) {\n          dir \u003d args[idx];\n        } else {\n          System.err.println(\"fsck: can only operate on one path at a time \u0027\"\n              + args[idx] + \"\u0027\");\n          printUsage(System.err);\n          return -1;\n        }\n\n      } else {\n        System.err.println(\"fsck: Illegal option \u0027\" + args[idx] + \"\u0027\");\n        printUsage(System.err);\n        return -1;\n      }\n    }\n    if (null \u003d\u003d dir) {\n      dir \u003d \"/\";\n    }\n\n    Path dirpath \u003d null;\n    URI namenodeAddress \u003d null;\n    try {\n      dirpath \u003d getResolvedPath(dir);\n      namenodeAddress \u003d getCurrentNamenodeAddress(dirpath);\n    } catch (IOException ioe) {\n      System.err.println(\"FileSystem is inaccessible due to:\\n\"\n          + ioe.toString());\n    }\n\n    if (namenodeAddress \u003d\u003d null) {\n      //Error message already output in {@link #getCurrentNamenodeAddress()}\n      System.err.println(\"DFSck exiting.\");\n      return 0;\n    }\n\n    url.insert(0, namenodeAddress.toString());\n    url.append(\"\u0026path\u003d\").append(URLEncoder.encode(\n        Path.getPathWithoutSchemeAndAuthority(dirpath).toString(), \"UTF-8\"));\n    System.err.println(\"Connecting to namenode via \" + url.toString());\n\n    if (doListCorruptFileBlocks) {\n      return listCorruptFileBlocks(dir, url.toString());\n    }\n    URL path \u003d new URL(url.toString());\n    URLConnection connection;\n    try {\n      connection \u003d connectionFactory.openConnection(path, isSpnegoEnabled);\n    } catch (AuthenticationException e) {\n      throw new IOException(e);\n    }\n    InputStream stream \u003d connection.getInputStream();\n    BufferedReader input \u003d new BufferedReader(new InputStreamReader(\n                                              stream, \"UTF-8\"));\n    String line \u003d null;\n    String lastLine \u003d null;\n    int errCode \u003d -1;\n    try {\n      while ((line \u003d input.readLine()) !\u003d null) {\n        out.println(line);\n        lastLine \u003d line;\n      }\n    } finally {\n      input.close();\n    }\n    if (lastLine.endsWith(NamenodeFsck.HEALTHY_STATUS)) {\n      errCode \u003d 0;\n    } else if (lastLine.endsWith(NamenodeFsck.CORRUPT_STATUS)) {\n      errCode \u003d 1;\n    } else if (lastLine.endsWith(NamenodeFsck.NONEXISTENT_STATUS)) {\n      errCode \u003d 0;\n    } else if (lastLine.contains(\"Incorrect blockId format:\")) {\n      errCode \u003d 0;\n    } else if (lastLine.endsWith(NamenodeFsck.DECOMMISSIONED_STATUS)) {\n      errCode \u003d 2;\n    } else if (lastLine.endsWith(NamenodeFsck.DECOMMISSIONING_STATUS)) {\n      errCode \u003d 3;\n    }\n    return errCode;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DFSck.java",
      "extendedDetails": {}
    },
    "677a936bf759515ac94d9accb9bf5364f688d051": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9284. fsck command should not print exception trace when file not found. Contributed by Jagadesh Kiran N.\n",
      "commitDate": "26/10/15 3:15 PM",
      "commitName": "677a936bf759515ac94d9accb9bf5364f688d051",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "29/06/15 2:56 PM",
      "commitNameOld": "8e333720e13428a4d0d0f65692102f8f2e5da98d",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 119.01,
      "commitsBetweenForRepo": 808,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,113 +1,113 @@\n   private int doWork(final String[] args) throws IOException {\n     final StringBuilder url \u003d new StringBuilder();\n     \n     url.append(\"/fsck?ugi\u003d\").append(ugi.getShortUserName());\n     String dir \u003d null;\n     boolean doListCorruptFileBlocks \u003d false;\n     for (int idx \u003d 0; idx \u003c args.length; idx++) {\n       if (args[idx].equals(\"-move\")) { url.append(\"\u0026move\u003d1\"); }\n       else if (args[idx].equals(\"-delete\")) { url.append(\"\u0026delete\u003d1\"); }\n       else if (args[idx].equals(\"-files\")) { url.append(\"\u0026files\u003d1\"); }\n       else if (args[idx].equals(\"-openforwrite\")) { url.append(\"\u0026openforwrite\u003d1\"); }\n       else if (args[idx].equals(\"-blocks\")) { url.append(\"\u0026blocks\u003d1\"); }\n       else if (args[idx].equals(\"-locations\")) { url.append(\"\u0026locations\u003d1\"); }\n       else if (args[idx].equals(\"-racks\")) { url.append(\"\u0026racks\u003d1\"); }\n       else if (args[idx].equals(\"-replicaDetails\")) {\n         url.append(\"\u0026replicadetails\u003d1\");\n       }\n       else if (args[idx].equals(\"-storagepolicies\")) { url.append(\"\u0026storagepolicies\u003d1\"); }\n       else if (args[idx].equals(\"-showprogress\")) { url.append(\"\u0026showprogress\u003d1\"); }\n       else if (args[idx].equals(\"-list-corruptfileblocks\")) {\n         url.append(\"\u0026listcorruptfileblocks\u003d1\");\n         doListCorruptFileBlocks \u003d true;\n       } else if (args[idx].equals(\"-includeSnapshots\")) {\n         url.append(\"\u0026includeSnapshots\u003d1\");\n       } else if (args[idx].equals(\"-blockId\")) {\n         StringBuilder sb \u003d new StringBuilder();\n         idx++;\n         while(idx \u003c args.length \u0026\u0026 !args[idx].startsWith(\"-\")){\n           sb.append(args[idx]);\n           sb.append(\" \");\n           idx++;\n         }\n         url.append(\"\u0026blockId\u003d\").append(URLEncoder.encode(sb.toString(), \"UTF-8\"));\n       } else if (!args[idx].startsWith(\"-\")) {\n         if (null \u003d\u003d dir) {\n           dir \u003d args[idx];\n         } else {\n           System.err.println(\"fsck: can only operate on one path at a time \u0027\"\n               + args[idx] + \"\u0027\");\n           printUsage(System.err);\n           return -1;\n         }\n \n       } else {\n         System.err.println(\"fsck: Illegal option \u0027\" + args[idx] + \"\u0027\");\n         printUsage(System.err);\n         return -1;\n       }\n     }\n     if (null \u003d\u003d dir) {\n       dir \u003d \"/\";\n     }\n \n     Path dirpath \u003d null;\n     URI namenodeAddress \u003d null;\n     try {\n       dirpath \u003d getResolvedPath(dir);\n       namenodeAddress \u003d getCurrentNamenodeAddress(dirpath);\n     } catch (IOException ioe) {\n       System.err.println(\"FileSystem is inaccessible due to:\\n\"\n-          + StringUtils.stringifyException(ioe));\n+          + ioe.toString());\n     }\n \n     if (namenodeAddress \u003d\u003d null) {\n       //Error message already output in {@link #getCurrentNamenodeAddress()}\n       System.err.println(\"DFSck exiting.\");\n       return 0;\n     }\n \n     url.insert(0, namenodeAddress.toString());\n     url.append(\"\u0026path\u003d\").append(URLEncoder.encode(\n         Path.getPathWithoutSchemeAndAuthority(dirpath).toString(), \"UTF-8\"));\n     System.err.println(\"Connecting to namenode via \" + url.toString());\n \n     if (doListCorruptFileBlocks) {\n       return listCorruptFileBlocks(dir, url.toString());\n     }\n     URL path \u003d new URL(url.toString());\n     URLConnection connection;\n     try {\n       connection \u003d connectionFactory.openConnection(path, isSpnegoEnabled);\n     } catch (AuthenticationException e) {\n       throw new IOException(e);\n     }\n     InputStream stream \u003d connection.getInputStream();\n     BufferedReader input \u003d new BufferedReader(new InputStreamReader(\n                                               stream, \"UTF-8\"));\n     String line \u003d null;\n     String lastLine \u003d null;\n     int errCode \u003d -1;\n     try {\n       while ((line \u003d input.readLine()) !\u003d null) {\n         out.println(line);\n         lastLine \u003d line;\n       }\n     } finally {\n       input.close();\n     }\n     if (lastLine.endsWith(NamenodeFsck.HEALTHY_STATUS)) {\n       errCode \u003d 0;\n     } else if (lastLine.endsWith(NamenodeFsck.CORRUPT_STATUS)) {\n       errCode \u003d 1;\n     } else if (lastLine.endsWith(NamenodeFsck.NONEXISTENT_STATUS)) {\n       errCode \u003d 0;\n     } else if (lastLine.contains(\"Incorrect blockId format:\")) {\n       errCode \u003d 0;\n     } else if (lastLine.endsWith(NamenodeFsck.DECOMMISSIONED_STATUS)) {\n       errCode \u003d 2;\n     } else if (lastLine.endsWith(NamenodeFsck.DECOMMISSIONING_STATUS)) {\n       errCode \u003d 3;\n     }\n     return errCode;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int doWork(final String[] args) throws IOException {\n    final StringBuilder url \u003d new StringBuilder();\n    \n    url.append(\"/fsck?ugi\u003d\").append(ugi.getShortUserName());\n    String dir \u003d null;\n    boolean doListCorruptFileBlocks \u003d false;\n    for (int idx \u003d 0; idx \u003c args.length; idx++) {\n      if (args[idx].equals(\"-move\")) { url.append(\"\u0026move\u003d1\"); }\n      else if (args[idx].equals(\"-delete\")) { url.append(\"\u0026delete\u003d1\"); }\n      else if (args[idx].equals(\"-files\")) { url.append(\"\u0026files\u003d1\"); }\n      else if (args[idx].equals(\"-openforwrite\")) { url.append(\"\u0026openforwrite\u003d1\"); }\n      else if (args[idx].equals(\"-blocks\")) { url.append(\"\u0026blocks\u003d1\"); }\n      else if (args[idx].equals(\"-locations\")) { url.append(\"\u0026locations\u003d1\"); }\n      else if (args[idx].equals(\"-racks\")) { url.append(\"\u0026racks\u003d1\"); }\n      else if (args[idx].equals(\"-replicaDetails\")) {\n        url.append(\"\u0026replicadetails\u003d1\");\n      }\n      else if (args[idx].equals(\"-storagepolicies\")) { url.append(\"\u0026storagepolicies\u003d1\"); }\n      else if (args[idx].equals(\"-showprogress\")) { url.append(\"\u0026showprogress\u003d1\"); }\n      else if (args[idx].equals(\"-list-corruptfileblocks\")) {\n        url.append(\"\u0026listcorruptfileblocks\u003d1\");\n        doListCorruptFileBlocks \u003d true;\n      } else if (args[idx].equals(\"-includeSnapshots\")) {\n        url.append(\"\u0026includeSnapshots\u003d1\");\n      } else if (args[idx].equals(\"-blockId\")) {\n        StringBuilder sb \u003d new StringBuilder();\n        idx++;\n        while(idx \u003c args.length \u0026\u0026 !args[idx].startsWith(\"-\")){\n          sb.append(args[idx]);\n          sb.append(\" \");\n          idx++;\n        }\n        url.append(\"\u0026blockId\u003d\").append(URLEncoder.encode(sb.toString(), \"UTF-8\"));\n      } else if (!args[idx].startsWith(\"-\")) {\n        if (null \u003d\u003d dir) {\n          dir \u003d args[idx];\n        } else {\n          System.err.println(\"fsck: can only operate on one path at a time \u0027\"\n              + args[idx] + \"\u0027\");\n          printUsage(System.err);\n          return -1;\n        }\n\n      } else {\n        System.err.println(\"fsck: Illegal option \u0027\" + args[idx] + \"\u0027\");\n        printUsage(System.err);\n        return -1;\n      }\n    }\n    if (null \u003d\u003d dir) {\n      dir \u003d \"/\";\n    }\n\n    Path dirpath \u003d null;\n    URI namenodeAddress \u003d null;\n    try {\n      dirpath \u003d getResolvedPath(dir);\n      namenodeAddress \u003d getCurrentNamenodeAddress(dirpath);\n    } catch (IOException ioe) {\n      System.err.println(\"FileSystem is inaccessible due to:\\n\"\n          + ioe.toString());\n    }\n\n    if (namenodeAddress \u003d\u003d null) {\n      //Error message already output in {@link #getCurrentNamenodeAddress()}\n      System.err.println(\"DFSck exiting.\");\n      return 0;\n    }\n\n    url.insert(0, namenodeAddress.toString());\n    url.append(\"\u0026path\u003d\").append(URLEncoder.encode(\n        Path.getPathWithoutSchemeAndAuthority(dirpath).toString(), \"UTF-8\"));\n    System.err.println(\"Connecting to namenode via \" + url.toString());\n\n    if (doListCorruptFileBlocks) {\n      return listCorruptFileBlocks(dir, url.toString());\n    }\n    URL path \u003d new URL(url.toString());\n    URLConnection connection;\n    try {\n      connection \u003d connectionFactory.openConnection(path, isSpnegoEnabled);\n    } catch (AuthenticationException e) {\n      throw new IOException(e);\n    }\n    InputStream stream \u003d connection.getInputStream();\n    BufferedReader input \u003d new BufferedReader(new InputStreamReader(\n                                              stream, \"UTF-8\"));\n    String line \u003d null;\n    String lastLine \u003d null;\n    int errCode \u003d -1;\n    try {\n      while ((line \u003d input.readLine()) !\u003d null) {\n        out.println(line);\n        lastLine \u003d line;\n      }\n    } finally {\n      input.close();\n    }\n    if (lastLine.endsWith(NamenodeFsck.HEALTHY_STATUS)) {\n      errCode \u003d 0;\n    } else if (lastLine.endsWith(NamenodeFsck.CORRUPT_STATUS)) {\n      errCode \u003d 1;\n    } else if (lastLine.endsWith(NamenodeFsck.NONEXISTENT_STATUS)) {\n      errCode \u003d 0;\n    } else if (lastLine.contains(\"Incorrect blockId format:\")) {\n      errCode \u003d 0;\n    } else if (lastLine.endsWith(NamenodeFsck.DECOMMISSIONED_STATUS)) {\n      errCode \u003d 2;\n    } else if (lastLine.endsWith(NamenodeFsck.DECOMMISSIONING_STATUS)) {\n      errCode \u003d 3;\n    }\n    return errCode;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DFSck.java",
      "extendedDetails": {}
    },
    "8ddbb8dd433862509bd9b222dddafe2c3a74778a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7993. Provide each Replica details in fsck (Contributed by J.Andreina)\n",
      "commitDate": "21/04/15 2:54 AM",
      "commitName": "8ddbb8dd433862509bd9b222dddafe2c3a74778a",
      "commitAuthor": "Vinayakumar B",
      "commitDateOld": "02/03/15 12:55 AM",
      "commitNameOld": "cbb492578ef09300821b7199de54c6508f9d7fe8",
      "commitAuthorOld": "Gera Shegalov",
      "daysBetweenCommits": 50.04,
      "commitsBetweenForRepo": 423,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,110 +1,113 @@\n   private int doWork(final String[] args) throws IOException {\n     final StringBuilder url \u003d new StringBuilder();\n     \n     url.append(\"/fsck?ugi\u003d\").append(ugi.getShortUserName());\n     String dir \u003d null;\n     boolean doListCorruptFileBlocks \u003d false;\n     for (int idx \u003d 0; idx \u003c args.length; idx++) {\n       if (args[idx].equals(\"-move\")) { url.append(\"\u0026move\u003d1\"); }\n       else if (args[idx].equals(\"-delete\")) { url.append(\"\u0026delete\u003d1\"); }\n       else if (args[idx].equals(\"-files\")) { url.append(\"\u0026files\u003d1\"); }\n       else if (args[idx].equals(\"-openforwrite\")) { url.append(\"\u0026openforwrite\u003d1\"); }\n       else if (args[idx].equals(\"-blocks\")) { url.append(\"\u0026blocks\u003d1\"); }\n       else if (args[idx].equals(\"-locations\")) { url.append(\"\u0026locations\u003d1\"); }\n       else if (args[idx].equals(\"-racks\")) { url.append(\"\u0026racks\u003d1\"); }\n+      else if (args[idx].equals(\"-replicaDetails\")) {\n+        url.append(\"\u0026replicadetails\u003d1\");\n+      }\n       else if (args[idx].equals(\"-storagepolicies\")) { url.append(\"\u0026storagepolicies\u003d1\"); }\n       else if (args[idx].equals(\"-showprogress\")) { url.append(\"\u0026showprogress\u003d1\"); }\n       else if (args[idx].equals(\"-list-corruptfileblocks\")) {\n         url.append(\"\u0026listcorruptfileblocks\u003d1\");\n         doListCorruptFileBlocks \u003d true;\n       } else if (args[idx].equals(\"-includeSnapshots\")) {\n         url.append(\"\u0026includeSnapshots\u003d1\");\n       } else if (args[idx].equals(\"-blockId\")) {\n         StringBuilder sb \u003d new StringBuilder();\n         idx++;\n         while(idx \u003c args.length \u0026\u0026 !args[idx].startsWith(\"-\")){\n           sb.append(args[idx]);\n           sb.append(\" \");\n           idx++;\n         }\n         url.append(\"\u0026blockId\u003d\").append(URLEncoder.encode(sb.toString(), \"UTF-8\"));\n       } else if (!args[idx].startsWith(\"-\")) {\n         if (null \u003d\u003d dir) {\n           dir \u003d args[idx];\n         } else {\n           System.err.println(\"fsck: can only operate on one path at a time \u0027\"\n               + args[idx] + \"\u0027\");\n           printUsage(System.err);\n           return -1;\n         }\n \n       } else {\n         System.err.println(\"fsck: Illegal option \u0027\" + args[idx] + \"\u0027\");\n         printUsage(System.err);\n         return -1;\n       }\n     }\n     if (null \u003d\u003d dir) {\n       dir \u003d \"/\";\n     }\n \n     Path dirpath \u003d null;\n     URI namenodeAddress \u003d null;\n     try {\n       dirpath \u003d getResolvedPath(dir);\n       namenodeAddress \u003d getCurrentNamenodeAddress(dirpath);\n     } catch (IOException ioe) {\n       System.err.println(\"FileSystem is inaccessible due to:\\n\"\n           + StringUtils.stringifyException(ioe));\n     }\n \n     if (namenodeAddress \u003d\u003d null) {\n       //Error message already output in {@link #getCurrentNamenodeAddress()}\n       System.err.println(\"DFSck exiting.\");\n       return 0;\n     }\n \n     url.insert(0, namenodeAddress.toString());\n     url.append(\"\u0026path\u003d\").append(URLEncoder.encode(\n         Path.getPathWithoutSchemeAndAuthority(dirpath).toString(), \"UTF-8\"));\n     System.err.println(\"Connecting to namenode via \" + url.toString());\n \n     if (doListCorruptFileBlocks) {\n       return listCorruptFileBlocks(dir, url.toString());\n     }\n     URL path \u003d new URL(url.toString());\n     URLConnection connection;\n     try {\n       connection \u003d connectionFactory.openConnection(path, isSpnegoEnabled);\n     } catch (AuthenticationException e) {\n       throw new IOException(e);\n     }\n     InputStream stream \u003d connection.getInputStream();\n     BufferedReader input \u003d new BufferedReader(new InputStreamReader(\n                                               stream, \"UTF-8\"));\n     String line \u003d null;\n     String lastLine \u003d null;\n     int errCode \u003d -1;\n     try {\n       while ((line \u003d input.readLine()) !\u003d null) {\n         out.println(line);\n         lastLine \u003d line;\n       }\n     } finally {\n       input.close();\n     }\n     if (lastLine.endsWith(NamenodeFsck.HEALTHY_STATUS)) {\n       errCode \u003d 0;\n     } else if (lastLine.endsWith(NamenodeFsck.CORRUPT_STATUS)) {\n       errCode \u003d 1;\n     } else if (lastLine.endsWith(NamenodeFsck.NONEXISTENT_STATUS)) {\n       errCode \u003d 0;\n     } else if (lastLine.contains(\"Incorrect blockId format:\")) {\n       errCode \u003d 0;\n     } else if (lastLine.endsWith(NamenodeFsck.DECOMMISSIONED_STATUS)) {\n       errCode \u003d 2;\n     } else if (lastLine.endsWith(NamenodeFsck.DECOMMISSIONING_STATUS)) {\n       errCode \u003d 3;\n     }\n     return errCode;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int doWork(final String[] args) throws IOException {\n    final StringBuilder url \u003d new StringBuilder();\n    \n    url.append(\"/fsck?ugi\u003d\").append(ugi.getShortUserName());\n    String dir \u003d null;\n    boolean doListCorruptFileBlocks \u003d false;\n    for (int idx \u003d 0; idx \u003c args.length; idx++) {\n      if (args[idx].equals(\"-move\")) { url.append(\"\u0026move\u003d1\"); }\n      else if (args[idx].equals(\"-delete\")) { url.append(\"\u0026delete\u003d1\"); }\n      else if (args[idx].equals(\"-files\")) { url.append(\"\u0026files\u003d1\"); }\n      else if (args[idx].equals(\"-openforwrite\")) { url.append(\"\u0026openforwrite\u003d1\"); }\n      else if (args[idx].equals(\"-blocks\")) { url.append(\"\u0026blocks\u003d1\"); }\n      else if (args[idx].equals(\"-locations\")) { url.append(\"\u0026locations\u003d1\"); }\n      else if (args[idx].equals(\"-racks\")) { url.append(\"\u0026racks\u003d1\"); }\n      else if (args[idx].equals(\"-replicaDetails\")) {\n        url.append(\"\u0026replicadetails\u003d1\");\n      }\n      else if (args[idx].equals(\"-storagepolicies\")) { url.append(\"\u0026storagepolicies\u003d1\"); }\n      else if (args[idx].equals(\"-showprogress\")) { url.append(\"\u0026showprogress\u003d1\"); }\n      else if (args[idx].equals(\"-list-corruptfileblocks\")) {\n        url.append(\"\u0026listcorruptfileblocks\u003d1\");\n        doListCorruptFileBlocks \u003d true;\n      } else if (args[idx].equals(\"-includeSnapshots\")) {\n        url.append(\"\u0026includeSnapshots\u003d1\");\n      } else if (args[idx].equals(\"-blockId\")) {\n        StringBuilder sb \u003d new StringBuilder();\n        idx++;\n        while(idx \u003c args.length \u0026\u0026 !args[idx].startsWith(\"-\")){\n          sb.append(args[idx]);\n          sb.append(\" \");\n          idx++;\n        }\n        url.append(\"\u0026blockId\u003d\").append(URLEncoder.encode(sb.toString(), \"UTF-8\"));\n      } else if (!args[idx].startsWith(\"-\")) {\n        if (null \u003d\u003d dir) {\n          dir \u003d args[idx];\n        } else {\n          System.err.println(\"fsck: can only operate on one path at a time \u0027\"\n              + args[idx] + \"\u0027\");\n          printUsage(System.err);\n          return -1;\n        }\n\n      } else {\n        System.err.println(\"fsck: Illegal option \u0027\" + args[idx] + \"\u0027\");\n        printUsage(System.err);\n        return -1;\n      }\n    }\n    if (null \u003d\u003d dir) {\n      dir \u003d \"/\";\n    }\n\n    Path dirpath \u003d null;\n    URI namenodeAddress \u003d null;\n    try {\n      dirpath \u003d getResolvedPath(dir);\n      namenodeAddress \u003d getCurrentNamenodeAddress(dirpath);\n    } catch (IOException ioe) {\n      System.err.println(\"FileSystem is inaccessible due to:\\n\"\n          + StringUtils.stringifyException(ioe));\n    }\n\n    if (namenodeAddress \u003d\u003d null) {\n      //Error message already output in {@link #getCurrentNamenodeAddress()}\n      System.err.println(\"DFSck exiting.\");\n      return 0;\n    }\n\n    url.insert(0, namenodeAddress.toString());\n    url.append(\"\u0026path\u003d\").append(URLEncoder.encode(\n        Path.getPathWithoutSchemeAndAuthority(dirpath).toString(), \"UTF-8\"));\n    System.err.println(\"Connecting to namenode via \" + url.toString());\n\n    if (doListCorruptFileBlocks) {\n      return listCorruptFileBlocks(dir, url.toString());\n    }\n    URL path \u003d new URL(url.toString());\n    URLConnection connection;\n    try {\n      connection \u003d connectionFactory.openConnection(path, isSpnegoEnabled);\n    } catch (AuthenticationException e) {\n      throw new IOException(e);\n    }\n    InputStream stream \u003d connection.getInputStream();\n    BufferedReader input \u003d new BufferedReader(new InputStreamReader(\n                                              stream, \"UTF-8\"));\n    String line \u003d null;\n    String lastLine \u003d null;\n    int errCode \u003d -1;\n    try {\n      while ((line \u003d input.readLine()) !\u003d null) {\n        out.println(line);\n        lastLine \u003d line;\n      }\n    } finally {\n      input.close();\n    }\n    if (lastLine.endsWith(NamenodeFsck.HEALTHY_STATUS)) {\n      errCode \u003d 0;\n    } else if (lastLine.endsWith(NamenodeFsck.CORRUPT_STATUS)) {\n      errCode \u003d 1;\n    } else if (lastLine.endsWith(NamenodeFsck.NONEXISTENT_STATUS)) {\n      errCode \u003d 0;\n    } else if (lastLine.contains(\"Incorrect blockId format:\")) {\n      errCode \u003d 0;\n    } else if (lastLine.endsWith(NamenodeFsck.DECOMMISSIONED_STATUS)) {\n      errCode \u003d 2;\n    } else if (lastLine.endsWith(NamenodeFsck.DECOMMISSIONING_STATUS)) {\n      errCode \u003d 3;\n    }\n    return errCode;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DFSck.java",
      "extendedDetails": {}
    },
    "cbb492578ef09300821b7199de54c6508f9d7fe8": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7789. DFSck should resolve the path to support cross-FS symlinks. (gera)\n",
      "commitDate": "02/03/15 12:55 AM",
      "commitName": "cbb492578ef09300821b7199de54c6508f9d7fe8",
      "commitAuthor": "Gera Shegalov",
      "commitDateOld": "25/02/15 4:19 PM",
      "commitNameOld": "d140d76a43c88e326b9c2818578f22bd3563b969",
      "commitAuthorOld": "Benoy Antony",
      "daysBetweenCommits": 4.36,
      "commitsBetweenForRepo": 34,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,102 +1,110 @@\n   private int doWork(final String[] args) throws IOException {\n     final StringBuilder url \u003d new StringBuilder();\n     \n     url.append(\"/fsck?ugi\u003d\").append(ugi.getShortUserName());\n     String dir \u003d null;\n     boolean doListCorruptFileBlocks \u003d false;\n     for (int idx \u003d 0; idx \u003c args.length; idx++) {\n       if (args[idx].equals(\"-move\")) { url.append(\"\u0026move\u003d1\"); }\n       else if (args[idx].equals(\"-delete\")) { url.append(\"\u0026delete\u003d1\"); }\n       else if (args[idx].equals(\"-files\")) { url.append(\"\u0026files\u003d1\"); }\n       else if (args[idx].equals(\"-openforwrite\")) { url.append(\"\u0026openforwrite\u003d1\"); }\n       else if (args[idx].equals(\"-blocks\")) { url.append(\"\u0026blocks\u003d1\"); }\n       else if (args[idx].equals(\"-locations\")) { url.append(\"\u0026locations\u003d1\"); }\n       else if (args[idx].equals(\"-racks\")) { url.append(\"\u0026racks\u003d1\"); }\n       else if (args[idx].equals(\"-storagepolicies\")) { url.append(\"\u0026storagepolicies\u003d1\"); }\n       else if (args[idx].equals(\"-showprogress\")) { url.append(\"\u0026showprogress\u003d1\"); }\n       else if (args[idx].equals(\"-list-corruptfileblocks\")) {\n         url.append(\"\u0026listcorruptfileblocks\u003d1\");\n         doListCorruptFileBlocks \u003d true;\n       } else if (args[idx].equals(\"-includeSnapshots\")) {\n         url.append(\"\u0026includeSnapshots\u003d1\");\n       } else if (args[idx].equals(\"-blockId\")) {\n         StringBuilder sb \u003d new StringBuilder();\n         idx++;\n         while(idx \u003c args.length \u0026\u0026 !args[idx].startsWith(\"-\")){\n           sb.append(args[idx]);\n           sb.append(\" \");\n           idx++;\n         }\n         url.append(\"\u0026blockId\u003d\").append(URLEncoder.encode(sb.toString(), \"UTF-8\"));\n       } else if (!args[idx].startsWith(\"-\")) {\n         if (null \u003d\u003d dir) {\n           dir \u003d args[idx];\n         } else {\n           System.err.println(\"fsck: can only operate on one path at a time \u0027\"\n               + args[idx] + \"\u0027\");\n           printUsage(System.err);\n           return -1;\n         }\n \n       } else {\n         System.err.println(\"fsck: Illegal option \u0027\" + args[idx] + \"\u0027\");\n         printUsage(System.err);\n         return -1;\n       }\n     }\n     if (null \u003d\u003d dir) {\n       dir \u003d \"/\";\n     }\n \n-    final Path dirpath \u003d new Path(dir);\n-    final URI namenodeAddress \u003d getCurrentNamenodeAddress(dirpath);\n+    Path dirpath \u003d null;\n+    URI namenodeAddress \u003d null;\n+    try {\n+      dirpath \u003d getResolvedPath(dir);\n+      namenodeAddress \u003d getCurrentNamenodeAddress(dirpath);\n+    } catch (IOException ioe) {\n+      System.err.println(\"FileSystem is inaccessible due to:\\n\"\n+          + StringUtils.stringifyException(ioe));\n+    }\n+\n     if (namenodeAddress \u003d\u003d null) {\n       //Error message already output in {@link #getCurrentNamenodeAddress()}\n       System.err.println(\"DFSck exiting.\");\n       return 0;\n     }\n \n     url.insert(0, namenodeAddress.toString());\n     url.append(\"\u0026path\u003d\").append(URLEncoder.encode(\n         Path.getPathWithoutSchemeAndAuthority(dirpath).toString(), \"UTF-8\"));\n     System.err.println(\"Connecting to namenode via \" + url.toString());\n \n     if (doListCorruptFileBlocks) {\n       return listCorruptFileBlocks(dir, url.toString());\n     }\n     URL path \u003d new URL(url.toString());\n     URLConnection connection;\n     try {\n       connection \u003d connectionFactory.openConnection(path, isSpnegoEnabled);\n     } catch (AuthenticationException e) {\n       throw new IOException(e);\n     }\n     InputStream stream \u003d connection.getInputStream();\n     BufferedReader input \u003d new BufferedReader(new InputStreamReader(\n                                               stream, \"UTF-8\"));\n     String line \u003d null;\n     String lastLine \u003d null;\n     int errCode \u003d -1;\n     try {\n       while ((line \u003d input.readLine()) !\u003d null) {\n         out.println(line);\n         lastLine \u003d line;\n       }\n     } finally {\n       input.close();\n     }\n     if (lastLine.endsWith(NamenodeFsck.HEALTHY_STATUS)) {\n       errCode \u003d 0;\n     } else if (lastLine.endsWith(NamenodeFsck.CORRUPT_STATUS)) {\n       errCode \u003d 1;\n     } else if (lastLine.endsWith(NamenodeFsck.NONEXISTENT_STATUS)) {\n       errCode \u003d 0;\n     } else if (lastLine.contains(\"Incorrect blockId format:\")) {\n       errCode \u003d 0;\n     } else if (lastLine.endsWith(NamenodeFsck.DECOMMISSIONED_STATUS)) {\n       errCode \u003d 2;\n     } else if (lastLine.endsWith(NamenodeFsck.DECOMMISSIONING_STATUS)) {\n       errCode \u003d 3;\n     }\n     return errCode;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int doWork(final String[] args) throws IOException {\n    final StringBuilder url \u003d new StringBuilder();\n    \n    url.append(\"/fsck?ugi\u003d\").append(ugi.getShortUserName());\n    String dir \u003d null;\n    boolean doListCorruptFileBlocks \u003d false;\n    for (int idx \u003d 0; idx \u003c args.length; idx++) {\n      if (args[idx].equals(\"-move\")) { url.append(\"\u0026move\u003d1\"); }\n      else if (args[idx].equals(\"-delete\")) { url.append(\"\u0026delete\u003d1\"); }\n      else if (args[idx].equals(\"-files\")) { url.append(\"\u0026files\u003d1\"); }\n      else if (args[idx].equals(\"-openforwrite\")) { url.append(\"\u0026openforwrite\u003d1\"); }\n      else if (args[idx].equals(\"-blocks\")) { url.append(\"\u0026blocks\u003d1\"); }\n      else if (args[idx].equals(\"-locations\")) { url.append(\"\u0026locations\u003d1\"); }\n      else if (args[idx].equals(\"-racks\")) { url.append(\"\u0026racks\u003d1\"); }\n      else if (args[idx].equals(\"-storagepolicies\")) { url.append(\"\u0026storagepolicies\u003d1\"); }\n      else if (args[idx].equals(\"-showprogress\")) { url.append(\"\u0026showprogress\u003d1\"); }\n      else if (args[idx].equals(\"-list-corruptfileblocks\")) {\n        url.append(\"\u0026listcorruptfileblocks\u003d1\");\n        doListCorruptFileBlocks \u003d true;\n      } else if (args[idx].equals(\"-includeSnapshots\")) {\n        url.append(\"\u0026includeSnapshots\u003d1\");\n      } else if (args[idx].equals(\"-blockId\")) {\n        StringBuilder sb \u003d new StringBuilder();\n        idx++;\n        while(idx \u003c args.length \u0026\u0026 !args[idx].startsWith(\"-\")){\n          sb.append(args[idx]);\n          sb.append(\" \");\n          idx++;\n        }\n        url.append(\"\u0026blockId\u003d\").append(URLEncoder.encode(sb.toString(), \"UTF-8\"));\n      } else if (!args[idx].startsWith(\"-\")) {\n        if (null \u003d\u003d dir) {\n          dir \u003d args[idx];\n        } else {\n          System.err.println(\"fsck: can only operate on one path at a time \u0027\"\n              + args[idx] + \"\u0027\");\n          printUsage(System.err);\n          return -1;\n        }\n\n      } else {\n        System.err.println(\"fsck: Illegal option \u0027\" + args[idx] + \"\u0027\");\n        printUsage(System.err);\n        return -1;\n      }\n    }\n    if (null \u003d\u003d dir) {\n      dir \u003d \"/\";\n    }\n\n    Path dirpath \u003d null;\n    URI namenodeAddress \u003d null;\n    try {\n      dirpath \u003d getResolvedPath(dir);\n      namenodeAddress \u003d getCurrentNamenodeAddress(dirpath);\n    } catch (IOException ioe) {\n      System.err.println(\"FileSystem is inaccessible due to:\\n\"\n          + StringUtils.stringifyException(ioe));\n    }\n\n    if (namenodeAddress \u003d\u003d null) {\n      //Error message already output in {@link #getCurrentNamenodeAddress()}\n      System.err.println(\"DFSck exiting.\");\n      return 0;\n    }\n\n    url.insert(0, namenodeAddress.toString());\n    url.append(\"\u0026path\u003d\").append(URLEncoder.encode(\n        Path.getPathWithoutSchemeAndAuthority(dirpath).toString(), \"UTF-8\"));\n    System.err.println(\"Connecting to namenode via \" + url.toString());\n\n    if (doListCorruptFileBlocks) {\n      return listCorruptFileBlocks(dir, url.toString());\n    }\n    URL path \u003d new URL(url.toString());\n    URLConnection connection;\n    try {\n      connection \u003d connectionFactory.openConnection(path, isSpnegoEnabled);\n    } catch (AuthenticationException e) {\n      throw new IOException(e);\n    }\n    InputStream stream \u003d connection.getInputStream();\n    BufferedReader input \u003d new BufferedReader(new InputStreamReader(\n                                              stream, \"UTF-8\"));\n    String line \u003d null;\n    String lastLine \u003d null;\n    int errCode \u003d -1;\n    try {\n      while ((line \u003d input.readLine()) !\u003d null) {\n        out.println(line);\n        lastLine \u003d line;\n      }\n    } finally {\n      input.close();\n    }\n    if (lastLine.endsWith(NamenodeFsck.HEALTHY_STATUS)) {\n      errCode \u003d 0;\n    } else if (lastLine.endsWith(NamenodeFsck.CORRUPT_STATUS)) {\n      errCode \u003d 1;\n    } else if (lastLine.endsWith(NamenodeFsck.NONEXISTENT_STATUS)) {\n      errCode \u003d 0;\n    } else if (lastLine.contains(\"Incorrect blockId format:\")) {\n      errCode \u003d 0;\n    } else if (lastLine.endsWith(NamenodeFsck.DECOMMISSIONED_STATUS)) {\n      errCode \u003d 2;\n    } else if (lastLine.endsWith(NamenodeFsck.DECOMMISSIONING_STATUS)) {\n      errCode \u003d 3;\n    }\n    return errCode;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DFSck.java",
      "extendedDetails": {}
    },
    "d140d76a43c88e326b9c2818578f22bd3563b969": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7467. Provide storage tier information for a directory via fsck. (Benoy Antony)\n",
      "commitDate": "25/02/15 4:19 PM",
      "commitName": "d140d76a43c88e326b9c2818578f22bd3563b969",
      "commitAuthor": "Benoy Antony",
      "commitDateOld": "11/02/15 11:21 AM",
      "commitNameOld": "f80c9888fa0c1a11967560be3c37dfc1e30da2c3",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 14.21,
      "commitsBetweenForRepo": 141,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,101 +1,102 @@\n   private int doWork(final String[] args) throws IOException {\n     final StringBuilder url \u003d new StringBuilder();\n     \n     url.append(\"/fsck?ugi\u003d\").append(ugi.getShortUserName());\n     String dir \u003d null;\n     boolean doListCorruptFileBlocks \u003d false;\n     for (int idx \u003d 0; idx \u003c args.length; idx++) {\n       if (args[idx].equals(\"-move\")) { url.append(\"\u0026move\u003d1\"); }\n       else if (args[idx].equals(\"-delete\")) { url.append(\"\u0026delete\u003d1\"); }\n       else if (args[idx].equals(\"-files\")) { url.append(\"\u0026files\u003d1\"); }\n       else if (args[idx].equals(\"-openforwrite\")) { url.append(\"\u0026openforwrite\u003d1\"); }\n       else if (args[idx].equals(\"-blocks\")) { url.append(\"\u0026blocks\u003d1\"); }\n       else if (args[idx].equals(\"-locations\")) { url.append(\"\u0026locations\u003d1\"); }\n       else if (args[idx].equals(\"-racks\")) { url.append(\"\u0026racks\u003d1\"); }\n+      else if (args[idx].equals(\"-storagepolicies\")) { url.append(\"\u0026storagepolicies\u003d1\"); }\n       else if (args[idx].equals(\"-showprogress\")) { url.append(\"\u0026showprogress\u003d1\"); }\n       else if (args[idx].equals(\"-list-corruptfileblocks\")) {\n         url.append(\"\u0026listcorruptfileblocks\u003d1\");\n         doListCorruptFileBlocks \u003d true;\n       } else if (args[idx].equals(\"-includeSnapshots\")) {\n         url.append(\"\u0026includeSnapshots\u003d1\");\n       } else if (args[idx].equals(\"-blockId\")) {\n         StringBuilder sb \u003d new StringBuilder();\n         idx++;\n         while(idx \u003c args.length \u0026\u0026 !args[idx].startsWith(\"-\")){\n           sb.append(args[idx]);\n           sb.append(\" \");\n           idx++;\n         }\n         url.append(\"\u0026blockId\u003d\").append(URLEncoder.encode(sb.toString(), \"UTF-8\"));\n       } else if (!args[idx].startsWith(\"-\")) {\n         if (null \u003d\u003d dir) {\n           dir \u003d args[idx];\n         } else {\n           System.err.println(\"fsck: can only operate on one path at a time \u0027\"\n               + args[idx] + \"\u0027\");\n           printUsage(System.err);\n           return -1;\n         }\n \n       } else {\n         System.err.println(\"fsck: Illegal option \u0027\" + args[idx] + \"\u0027\");\n         printUsage(System.err);\n         return -1;\n       }\n     }\n     if (null \u003d\u003d dir) {\n       dir \u003d \"/\";\n     }\n \n     final Path dirpath \u003d new Path(dir);\n     final URI namenodeAddress \u003d getCurrentNamenodeAddress(dirpath);\n     if (namenodeAddress \u003d\u003d null) {\n       //Error message already output in {@link #getCurrentNamenodeAddress()}\n       System.err.println(\"DFSck exiting.\");\n       return 0;\n     }\n \n     url.insert(0, namenodeAddress.toString());\n     url.append(\"\u0026path\u003d\").append(URLEncoder.encode(\n         Path.getPathWithoutSchemeAndAuthority(dirpath).toString(), \"UTF-8\"));\n     System.err.println(\"Connecting to namenode via \" + url.toString());\n \n     if (doListCorruptFileBlocks) {\n       return listCorruptFileBlocks(dir, url.toString());\n     }\n     URL path \u003d new URL(url.toString());\n     URLConnection connection;\n     try {\n       connection \u003d connectionFactory.openConnection(path, isSpnegoEnabled);\n     } catch (AuthenticationException e) {\n       throw new IOException(e);\n     }\n     InputStream stream \u003d connection.getInputStream();\n     BufferedReader input \u003d new BufferedReader(new InputStreamReader(\n                                               stream, \"UTF-8\"));\n     String line \u003d null;\n     String lastLine \u003d null;\n     int errCode \u003d -1;\n     try {\n       while ((line \u003d input.readLine()) !\u003d null) {\n         out.println(line);\n         lastLine \u003d line;\n       }\n     } finally {\n       input.close();\n     }\n     if (lastLine.endsWith(NamenodeFsck.HEALTHY_STATUS)) {\n       errCode \u003d 0;\n     } else if (lastLine.endsWith(NamenodeFsck.CORRUPT_STATUS)) {\n       errCode \u003d 1;\n     } else if (lastLine.endsWith(NamenodeFsck.NONEXISTENT_STATUS)) {\n       errCode \u003d 0;\n     } else if (lastLine.contains(\"Incorrect blockId format:\")) {\n       errCode \u003d 0;\n     } else if (lastLine.endsWith(NamenodeFsck.DECOMMISSIONED_STATUS)) {\n       errCode \u003d 2;\n     } else if (lastLine.endsWith(NamenodeFsck.DECOMMISSIONING_STATUS)) {\n       errCode \u003d 3;\n     }\n     return errCode;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int doWork(final String[] args) throws IOException {\n    final StringBuilder url \u003d new StringBuilder();\n    \n    url.append(\"/fsck?ugi\u003d\").append(ugi.getShortUserName());\n    String dir \u003d null;\n    boolean doListCorruptFileBlocks \u003d false;\n    for (int idx \u003d 0; idx \u003c args.length; idx++) {\n      if (args[idx].equals(\"-move\")) { url.append(\"\u0026move\u003d1\"); }\n      else if (args[idx].equals(\"-delete\")) { url.append(\"\u0026delete\u003d1\"); }\n      else if (args[idx].equals(\"-files\")) { url.append(\"\u0026files\u003d1\"); }\n      else if (args[idx].equals(\"-openforwrite\")) { url.append(\"\u0026openforwrite\u003d1\"); }\n      else if (args[idx].equals(\"-blocks\")) { url.append(\"\u0026blocks\u003d1\"); }\n      else if (args[idx].equals(\"-locations\")) { url.append(\"\u0026locations\u003d1\"); }\n      else if (args[idx].equals(\"-racks\")) { url.append(\"\u0026racks\u003d1\"); }\n      else if (args[idx].equals(\"-storagepolicies\")) { url.append(\"\u0026storagepolicies\u003d1\"); }\n      else if (args[idx].equals(\"-showprogress\")) { url.append(\"\u0026showprogress\u003d1\"); }\n      else if (args[idx].equals(\"-list-corruptfileblocks\")) {\n        url.append(\"\u0026listcorruptfileblocks\u003d1\");\n        doListCorruptFileBlocks \u003d true;\n      } else if (args[idx].equals(\"-includeSnapshots\")) {\n        url.append(\"\u0026includeSnapshots\u003d1\");\n      } else if (args[idx].equals(\"-blockId\")) {\n        StringBuilder sb \u003d new StringBuilder();\n        idx++;\n        while(idx \u003c args.length \u0026\u0026 !args[idx].startsWith(\"-\")){\n          sb.append(args[idx]);\n          sb.append(\" \");\n          idx++;\n        }\n        url.append(\"\u0026blockId\u003d\").append(URLEncoder.encode(sb.toString(), \"UTF-8\"));\n      } else if (!args[idx].startsWith(\"-\")) {\n        if (null \u003d\u003d dir) {\n          dir \u003d args[idx];\n        } else {\n          System.err.println(\"fsck: can only operate on one path at a time \u0027\"\n              + args[idx] + \"\u0027\");\n          printUsage(System.err);\n          return -1;\n        }\n\n      } else {\n        System.err.println(\"fsck: Illegal option \u0027\" + args[idx] + \"\u0027\");\n        printUsage(System.err);\n        return -1;\n      }\n    }\n    if (null \u003d\u003d dir) {\n      dir \u003d \"/\";\n    }\n\n    final Path dirpath \u003d new Path(dir);\n    final URI namenodeAddress \u003d getCurrentNamenodeAddress(dirpath);\n    if (namenodeAddress \u003d\u003d null) {\n      //Error message already output in {@link #getCurrentNamenodeAddress()}\n      System.err.println(\"DFSck exiting.\");\n      return 0;\n    }\n\n    url.insert(0, namenodeAddress.toString());\n    url.append(\"\u0026path\u003d\").append(URLEncoder.encode(\n        Path.getPathWithoutSchemeAndAuthority(dirpath).toString(), \"UTF-8\"));\n    System.err.println(\"Connecting to namenode via \" + url.toString());\n\n    if (doListCorruptFileBlocks) {\n      return listCorruptFileBlocks(dir, url.toString());\n    }\n    URL path \u003d new URL(url.toString());\n    URLConnection connection;\n    try {\n      connection \u003d connectionFactory.openConnection(path, isSpnegoEnabled);\n    } catch (AuthenticationException e) {\n      throw new IOException(e);\n    }\n    InputStream stream \u003d connection.getInputStream();\n    BufferedReader input \u003d new BufferedReader(new InputStreamReader(\n                                              stream, \"UTF-8\"));\n    String line \u003d null;\n    String lastLine \u003d null;\n    int errCode \u003d -1;\n    try {\n      while ((line \u003d input.readLine()) !\u003d null) {\n        out.println(line);\n        lastLine \u003d line;\n      }\n    } finally {\n      input.close();\n    }\n    if (lastLine.endsWith(NamenodeFsck.HEALTHY_STATUS)) {\n      errCode \u003d 0;\n    } else if (lastLine.endsWith(NamenodeFsck.CORRUPT_STATUS)) {\n      errCode \u003d 1;\n    } else if (lastLine.endsWith(NamenodeFsck.NONEXISTENT_STATUS)) {\n      errCode \u003d 0;\n    } else if (lastLine.contains(\"Incorrect blockId format:\")) {\n      errCode \u003d 0;\n    } else if (lastLine.endsWith(NamenodeFsck.DECOMMISSIONED_STATUS)) {\n      errCode \u003d 2;\n    } else if (lastLine.endsWith(NamenodeFsck.DECOMMISSIONING_STATUS)) {\n      errCode \u003d 3;\n    }\n    return errCode;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DFSck.java",
      "extendedDetails": {}
    },
    "7fe0f25ad21f006eb41b832a181eb2a812a6f7b7": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2219. Change fsck to support fully qualified paths so that a particular namenode in a federated cluster with multiple namenodes can be specified in the path parameter.\n",
      "commitDate": "14/01/15 11:31 AM",
      "commitName": "7fe0f25ad21f006eb41b832a181eb2a812a6f7b7",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "commitDateOld": "28/10/14 12:26 PM",
      "commitNameOld": "371a3b87ed346732ed58a4faab0c6c1db57c86ed",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 78.0,
      "commitsBetweenForRepo": 541,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,98 +1,101 @@\n   private int doWork(final String[] args) throws IOException {\n     final StringBuilder url \u003d new StringBuilder();\n     \n-    URI namenodeAddress \u003d getCurrentNamenodeAddress();\n-    if (namenodeAddress \u003d\u003d null) {\n-      //Error message already output in {@link #getCurrentNamenodeAddress()}\n-      System.err.println(\"DFSck exiting.\");\n-      return 0;\n-    }\n-\n-    url.append(namenodeAddress.toString());\n-    System.err.println(\"Connecting to namenode via \" + url.toString());\n-    \n     url.append(\"/fsck?ugi\u003d\").append(ugi.getShortUserName());\n     String dir \u003d null;\n     boolean doListCorruptFileBlocks \u003d false;\n     for (int idx \u003d 0; idx \u003c args.length; idx++) {\n       if (args[idx].equals(\"-move\")) { url.append(\"\u0026move\u003d1\"); }\n       else if (args[idx].equals(\"-delete\")) { url.append(\"\u0026delete\u003d1\"); }\n       else if (args[idx].equals(\"-files\")) { url.append(\"\u0026files\u003d1\"); }\n       else if (args[idx].equals(\"-openforwrite\")) { url.append(\"\u0026openforwrite\u003d1\"); }\n       else if (args[idx].equals(\"-blocks\")) { url.append(\"\u0026blocks\u003d1\"); }\n       else if (args[idx].equals(\"-locations\")) { url.append(\"\u0026locations\u003d1\"); }\n       else if (args[idx].equals(\"-racks\")) { url.append(\"\u0026racks\u003d1\"); }\n       else if (args[idx].equals(\"-showprogress\")) { url.append(\"\u0026showprogress\u003d1\"); }\n       else if (args[idx].equals(\"-list-corruptfileblocks\")) {\n         url.append(\"\u0026listcorruptfileblocks\u003d1\");\n         doListCorruptFileBlocks \u003d true;\n       } else if (args[idx].equals(\"-includeSnapshots\")) {\n         url.append(\"\u0026includeSnapshots\u003d1\");\n       } else if (args[idx].equals(\"-blockId\")) {\n         StringBuilder sb \u003d new StringBuilder();\n         idx++;\n         while(idx \u003c args.length \u0026\u0026 !args[idx].startsWith(\"-\")){\n           sb.append(args[idx]);\n           sb.append(\" \");\n           idx++;\n         }\n         url.append(\"\u0026blockId\u003d\").append(URLEncoder.encode(sb.toString(), \"UTF-8\"));\n       } else if (!args[idx].startsWith(\"-\")) {\n         if (null \u003d\u003d dir) {\n           dir \u003d args[idx];\n         } else {\n           System.err.println(\"fsck: can only operate on one path at a time \u0027\"\n               + args[idx] + \"\u0027\");\n           printUsage(System.err);\n           return -1;\n         }\n \n       } else {\n         System.err.println(\"fsck: Illegal option \u0027\" + args[idx] + \"\u0027\");\n         printUsage(System.err);\n         return -1;\n       }\n     }\n     if (null \u003d\u003d dir) {\n       dir \u003d \"/\";\n     }\n-    url.append(\"\u0026path\u003d\").append(URLEncoder.encode(dir, \"UTF-8\"));\n+\n+    final Path dirpath \u003d new Path(dir);\n+    final URI namenodeAddress \u003d getCurrentNamenodeAddress(dirpath);\n+    if (namenodeAddress \u003d\u003d null) {\n+      //Error message already output in {@link #getCurrentNamenodeAddress()}\n+      System.err.println(\"DFSck exiting.\");\n+      return 0;\n+    }\n+\n+    url.insert(0, namenodeAddress.toString());\n+    url.append(\"\u0026path\u003d\").append(URLEncoder.encode(\n+        Path.getPathWithoutSchemeAndAuthority(dirpath).toString(), \"UTF-8\"));\n+    System.err.println(\"Connecting to namenode via \" + url.toString());\n+\n     if (doListCorruptFileBlocks) {\n       return listCorruptFileBlocks(dir, url.toString());\n     }\n     URL path \u003d new URL(url.toString());\n     URLConnection connection;\n     try {\n       connection \u003d connectionFactory.openConnection(path, isSpnegoEnabled);\n     } catch (AuthenticationException e) {\n       throw new IOException(e);\n     }\n     InputStream stream \u003d connection.getInputStream();\n     BufferedReader input \u003d new BufferedReader(new InputStreamReader(\n                                               stream, \"UTF-8\"));\n     String line \u003d null;\n     String lastLine \u003d null;\n     int errCode \u003d -1;\n     try {\n       while ((line \u003d input.readLine()) !\u003d null) {\n         out.println(line);\n         lastLine \u003d line;\n       }\n     } finally {\n       input.close();\n     }\n     if (lastLine.endsWith(NamenodeFsck.HEALTHY_STATUS)) {\n       errCode \u003d 0;\n     } else if (lastLine.endsWith(NamenodeFsck.CORRUPT_STATUS)) {\n       errCode \u003d 1;\n     } else if (lastLine.endsWith(NamenodeFsck.NONEXISTENT_STATUS)) {\n       errCode \u003d 0;\n     } else if (lastLine.contains(\"Incorrect blockId format:\")) {\n       errCode \u003d 0;\n     } else if (lastLine.endsWith(NamenodeFsck.DECOMMISSIONED_STATUS)) {\n       errCode \u003d 2;\n     } else if (lastLine.endsWith(NamenodeFsck.DECOMMISSIONING_STATUS)) {\n       errCode \u003d 3;\n     }\n     return errCode;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int doWork(final String[] args) throws IOException {\n    final StringBuilder url \u003d new StringBuilder();\n    \n    url.append(\"/fsck?ugi\u003d\").append(ugi.getShortUserName());\n    String dir \u003d null;\n    boolean doListCorruptFileBlocks \u003d false;\n    for (int idx \u003d 0; idx \u003c args.length; idx++) {\n      if (args[idx].equals(\"-move\")) { url.append(\"\u0026move\u003d1\"); }\n      else if (args[idx].equals(\"-delete\")) { url.append(\"\u0026delete\u003d1\"); }\n      else if (args[idx].equals(\"-files\")) { url.append(\"\u0026files\u003d1\"); }\n      else if (args[idx].equals(\"-openforwrite\")) { url.append(\"\u0026openforwrite\u003d1\"); }\n      else if (args[idx].equals(\"-blocks\")) { url.append(\"\u0026blocks\u003d1\"); }\n      else if (args[idx].equals(\"-locations\")) { url.append(\"\u0026locations\u003d1\"); }\n      else if (args[idx].equals(\"-racks\")) { url.append(\"\u0026racks\u003d1\"); }\n      else if (args[idx].equals(\"-showprogress\")) { url.append(\"\u0026showprogress\u003d1\"); }\n      else if (args[idx].equals(\"-list-corruptfileblocks\")) {\n        url.append(\"\u0026listcorruptfileblocks\u003d1\");\n        doListCorruptFileBlocks \u003d true;\n      } else if (args[idx].equals(\"-includeSnapshots\")) {\n        url.append(\"\u0026includeSnapshots\u003d1\");\n      } else if (args[idx].equals(\"-blockId\")) {\n        StringBuilder sb \u003d new StringBuilder();\n        idx++;\n        while(idx \u003c args.length \u0026\u0026 !args[idx].startsWith(\"-\")){\n          sb.append(args[idx]);\n          sb.append(\" \");\n          idx++;\n        }\n        url.append(\"\u0026blockId\u003d\").append(URLEncoder.encode(sb.toString(), \"UTF-8\"));\n      } else if (!args[idx].startsWith(\"-\")) {\n        if (null \u003d\u003d dir) {\n          dir \u003d args[idx];\n        } else {\n          System.err.println(\"fsck: can only operate on one path at a time \u0027\"\n              + args[idx] + \"\u0027\");\n          printUsage(System.err);\n          return -1;\n        }\n\n      } else {\n        System.err.println(\"fsck: Illegal option \u0027\" + args[idx] + \"\u0027\");\n        printUsage(System.err);\n        return -1;\n      }\n    }\n    if (null \u003d\u003d dir) {\n      dir \u003d \"/\";\n    }\n\n    final Path dirpath \u003d new Path(dir);\n    final URI namenodeAddress \u003d getCurrentNamenodeAddress(dirpath);\n    if (namenodeAddress \u003d\u003d null) {\n      //Error message already output in {@link #getCurrentNamenodeAddress()}\n      System.err.println(\"DFSck exiting.\");\n      return 0;\n    }\n\n    url.insert(0, namenodeAddress.toString());\n    url.append(\"\u0026path\u003d\").append(URLEncoder.encode(\n        Path.getPathWithoutSchemeAndAuthority(dirpath).toString(), \"UTF-8\"));\n    System.err.println(\"Connecting to namenode via \" + url.toString());\n\n    if (doListCorruptFileBlocks) {\n      return listCorruptFileBlocks(dir, url.toString());\n    }\n    URL path \u003d new URL(url.toString());\n    URLConnection connection;\n    try {\n      connection \u003d connectionFactory.openConnection(path, isSpnegoEnabled);\n    } catch (AuthenticationException e) {\n      throw new IOException(e);\n    }\n    InputStream stream \u003d connection.getInputStream();\n    BufferedReader input \u003d new BufferedReader(new InputStreamReader(\n                                              stream, \"UTF-8\"));\n    String line \u003d null;\n    String lastLine \u003d null;\n    int errCode \u003d -1;\n    try {\n      while ((line \u003d input.readLine()) !\u003d null) {\n        out.println(line);\n        lastLine \u003d line;\n      }\n    } finally {\n      input.close();\n    }\n    if (lastLine.endsWith(NamenodeFsck.HEALTHY_STATUS)) {\n      errCode \u003d 0;\n    } else if (lastLine.endsWith(NamenodeFsck.CORRUPT_STATUS)) {\n      errCode \u003d 1;\n    } else if (lastLine.endsWith(NamenodeFsck.NONEXISTENT_STATUS)) {\n      errCode \u003d 0;\n    } else if (lastLine.contains(\"Incorrect blockId format:\")) {\n      errCode \u003d 0;\n    } else if (lastLine.endsWith(NamenodeFsck.DECOMMISSIONED_STATUS)) {\n      errCode \u003d 2;\n    } else if (lastLine.endsWith(NamenodeFsck.DECOMMISSIONING_STATUS)) {\n      errCode \u003d 3;\n    }\n    return errCode;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DFSck.java",
      "extendedDetails": {}
    },
    "371a3b87ed346732ed58a4faab0c6c1db57c86ed": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6663. Admin command to track file and locations from block id.\nContributed by Chen He.\n",
      "commitDate": "28/10/14 12:26 PM",
      "commitName": "371a3b87ed346732ed58a4faab0c6c1db57c86ed",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "27/09/14 9:04 PM",
      "commitNameOld": "400e1bb4eff78333005144c58d33f10d4697ff70",
      "commitAuthorOld": "Konstantin V Shvachko",
      "daysBetweenCommits": 30.64,
      "commitsBetweenForRepo": 272,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,82 +1,98 @@\n   private int doWork(final String[] args) throws IOException {\n     final StringBuilder url \u003d new StringBuilder();\n     \n     URI namenodeAddress \u003d getCurrentNamenodeAddress();\n     if (namenodeAddress \u003d\u003d null) {\n       //Error message already output in {@link #getCurrentNamenodeAddress()}\n       System.err.println(\"DFSck exiting.\");\n       return 0;\n     }\n \n     url.append(namenodeAddress.toString());\n     System.err.println(\"Connecting to namenode via \" + url.toString());\n     \n     url.append(\"/fsck?ugi\u003d\").append(ugi.getShortUserName());\n     String dir \u003d null;\n     boolean doListCorruptFileBlocks \u003d false;\n     for (int idx \u003d 0; idx \u003c args.length; idx++) {\n       if (args[idx].equals(\"-move\")) { url.append(\"\u0026move\u003d1\"); }\n       else if (args[idx].equals(\"-delete\")) { url.append(\"\u0026delete\u003d1\"); }\n       else if (args[idx].equals(\"-files\")) { url.append(\"\u0026files\u003d1\"); }\n       else if (args[idx].equals(\"-openforwrite\")) { url.append(\"\u0026openforwrite\u003d1\"); }\n       else if (args[idx].equals(\"-blocks\")) { url.append(\"\u0026blocks\u003d1\"); }\n       else if (args[idx].equals(\"-locations\")) { url.append(\"\u0026locations\u003d1\"); }\n       else if (args[idx].equals(\"-racks\")) { url.append(\"\u0026racks\u003d1\"); }\n       else if (args[idx].equals(\"-showprogress\")) { url.append(\"\u0026showprogress\u003d1\"); }\n       else if (args[idx].equals(\"-list-corruptfileblocks\")) {\n         url.append(\"\u0026listcorruptfileblocks\u003d1\");\n         doListCorruptFileBlocks \u003d true;\n       } else if (args[idx].equals(\"-includeSnapshots\")) {\n         url.append(\"\u0026includeSnapshots\u003d1\");\n+      } else if (args[idx].equals(\"-blockId\")) {\n+        StringBuilder sb \u003d new StringBuilder();\n+        idx++;\n+        while(idx \u003c args.length \u0026\u0026 !args[idx].startsWith(\"-\")){\n+          sb.append(args[idx]);\n+          sb.append(\" \");\n+          idx++;\n+        }\n+        url.append(\"\u0026blockId\u003d\").append(URLEncoder.encode(sb.toString(), \"UTF-8\"));\n       } else if (!args[idx].startsWith(\"-\")) {\n         if (null \u003d\u003d dir) {\n           dir \u003d args[idx];\n         } else {\n           System.err.println(\"fsck: can only operate on one path at a time \u0027\"\n               + args[idx] + \"\u0027\");\n           printUsage(System.err);\n           return -1;\n         }\n+\n       } else {\n         System.err.println(\"fsck: Illegal option \u0027\" + args[idx] + \"\u0027\");\n         printUsage(System.err);\n         return -1;\n       }\n     }\n     if (null \u003d\u003d dir) {\n       dir \u003d \"/\";\n     }\n     url.append(\"\u0026path\u003d\").append(URLEncoder.encode(dir, \"UTF-8\"));\n     if (doListCorruptFileBlocks) {\n       return listCorruptFileBlocks(dir, url.toString());\n     }\n     URL path \u003d new URL(url.toString());\n     URLConnection connection;\n     try {\n       connection \u003d connectionFactory.openConnection(path, isSpnegoEnabled);\n     } catch (AuthenticationException e) {\n       throw new IOException(e);\n     }\n     InputStream stream \u003d connection.getInputStream();\n     BufferedReader input \u003d new BufferedReader(new InputStreamReader(\n                                               stream, \"UTF-8\"));\n     String line \u003d null;\n     String lastLine \u003d null;\n     int errCode \u003d -1;\n     try {\n       while ((line \u003d input.readLine()) !\u003d null) {\n         out.println(line);\n         lastLine \u003d line;\n       }\n     } finally {\n       input.close();\n     }\n     if (lastLine.endsWith(NamenodeFsck.HEALTHY_STATUS)) {\n       errCode \u003d 0;\n     } else if (lastLine.endsWith(NamenodeFsck.CORRUPT_STATUS)) {\n       errCode \u003d 1;\n     } else if (lastLine.endsWith(NamenodeFsck.NONEXISTENT_STATUS)) {\n       errCode \u003d 0;\n+    } else if (lastLine.contains(\"Incorrect blockId format:\")) {\n+      errCode \u003d 0;\n+    } else if (lastLine.endsWith(NamenodeFsck.DECOMMISSIONED_STATUS)) {\n+      errCode \u003d 2;\n+    } else if (lastLine.endsWith(NamenodeFsck.DECOMMISSIONING_STATUS)) {\n+      errCode \u003d 3;\n     }\n     return errCode;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int doWork(final String[] args) throws IOException {\n    final StringBuilder url \u003d new StringBuilder();\n    \n    URI namenodeAddress \u003d getCurrentNamenodeAddress();\n    if (namenodeAddress \u003d\u003d null) {\n      //Error message already output in {@link #getCurrentNamenodeAddress()}\n      System.err.println(\"DFSck exiting.\");\n      return 0;\n    }\n\n    url.append(namenodeAddress.toString());\n    System.err.println(\"Connecting to namenode via \" + url.toString());\n    \n    url.append(\"/fsck?ugi\u003d\").append(ugi.getShortUserName());\n    String dir \u003d null;\n    boolean doListCorruptFileBlocks \u003d false;\n    for (int idx \u003d 0; idx \u003c args.length; idx++) {\n      if (args[idx].equals(\"-move\")) { url.append(\"\u0026move\u003d1\"); }\n      else if (args[idx].equals(\"-delete\")) { url.append(\"\u0026delete\u003d1\"); }\n      else if (args[idx].equals(\"-files\")) { url.append(\"\u0026files\u003d1\"); }\n      else if (args[idx].equals(\"-openforwrite\")) { url.append(\"\u0026openforwrite\u003d1\"); }\n      else if (args[idx].equals(\"-blocks\")) { url.append(\"\u0026blocks\u003d1\"); }\n      else if (args[idx].equals(\"-locations\")) { url.append(\"\u0026locations\u003d1\"); }\n      else if (args[idx].equals(\"-racks\")) { url.append(\"\u0026racks\u003d1\"); }\n      else if (args[idx].equals(\"-showprogress\")) { url.append(\"\u0026showprogress\u003d1\"); }\n      else if (args[idx].equals(\"-list-corruptfileblocks\")) {\n        url.append(\"\u0026listcorruptfileblocks\u003d1\");\n        doListCorruptFileBlocks \u003d true;\n      } else if (args[idx].equals(\"-includeSnapshots\")) {\n        url.append(\"\u0026includeSnapshots\u003d1\");\n      } else if (args[idx].equals(\"-blockId\")) {\n        StringBuilder sb \u003d new StringBuilder();\n        idx++;\n        while(idx \u003c args.length \u0026\u0026 !args[idx].startsWith(\"-\")){\n          sb.append(args[idx]);\n          sb.append(\" \");\n          idx++;\n        }\n        url.append(\"\u0026blockId\u003d\").append(URLEncoder.encode(sb.toString(), \"UTF-8\"));\n      } else if (!args[idx].startsWith(\"-\")) {\n        if (null \u003d\u003d dir) {\n          dir \u003d args[idx];\n        } else {\n          System.err.println(\"fsck: can only operate on one path at a time \u0027\"\n              + args[idx] + \"\u0027\");\n          printUsage(System.err);\n          return -1;\n        }\n\n      } else {\n        System.err.println(\"fsck: Illegal option \u0027\" + args[idx] + \"\u0027\");\n        printUsage(System.err);\n        return -1;\n      }\n    }\n    if (null \u003d\u003d dir) {\n      dir \u003d \"/\";\n    }\n    url.append(\"\u0026path\u003d\").append(URLEncoder.encode(dir, \"UTF-8\"));\n    if (doListCorruptFileBlocks) {\n      return listCorruptFileBlocks(dir, url.toString());\n    }\n    URL path \u003d new URL(url.toString());\n    URLConnection connection;\n    try {\n      connection \u003d connectionFactory.openConnection(path, isSpnegoEnabled);\n    } catch (AuthenticationException e) {\n      throw new IOException(e);\n    }\n    InputStream stream \u003d connection.getInputStream();\n    BufferedReader input \u003d new BufferedReader(new InputStreamReader(\n                                              stream, \"UTF-8\"));\n    String line \u003d null;\n    String lastLine \u003d null;\n    int errCode \u003d -1;\n    try {\n      while ((line \u003d input.readLine()) !\u003d null) {\n        out.println(line);\n        lastLine \u003d line;\n      }\n    } finally {\n      input.close();\n    }\n    if (lastLine.endsWith(NamenodeFsck.HEALTHY_STATUS)) {\n      errCode \u003d 0;\n    } else if (lastLine.endsWith(NamenodeFsck.CORRUPT_STATUS)) {\n      errCode \u003d 1;\n    } else if (lastLine.endsWith(NamenodeFsck.NONEXISTENT_STATUS)) {\n      errCode \u003d 0;\n    } else if (lastLine.contains(\"Incorrect blockId format:\")) {\n      errCode \u003d 0;\n    } else if (lastLine.endsWith(NamenodeFsck.DECOMMISSIONED_STATUS)) {\n      errCode \u003d 2;\n    } else if (lastLine.endsWith(NamenodeFsck.DECOMMISSIONING_STATUS)) {\n      errCode \u003d 3;\n    }\n    return errCode;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DFSck.java",
      "extendedDetails": {}
    },
    "c477a166e18e122b101c372b1c0a2f362e53866d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2538. option to disable fsck dots. Contributed by Mohammad Kamrul Islam.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1611220 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/07/14 4:55 PM",
      "commitName": "c477a166e18e122b101c372b1c0a2f362e53866d",
      "commitAuthor": "Allen Wittenauer",
      "commitDateOld": "23/04/14 1:13 PM",
      "commitNameOld": "876fd8ab7913a259ff9f69c16cc2d9af46ad3f9b",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 84.15,
      "commitsBetweenForRepo": 506,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,81 +1,82 @@\n   private int doWork(final String[] args) throws IOException {\n     final StringBuilder url \u003d new StringBuilder();\n     \n     URI namenodeAddress \u003d getCurrentNamenodeAddress();\n     if (namenodeAddress \u003d\u003d null) {\n       //Error message already output in {@link #getCurrentNamenodeAddress()}\n       System.err.println(\"DFSck exiting.\");\n       return 0;\n     }\n \n     url.append(namenodeAddress.toString());\n     System.err.println(\"Connecting to namenode via \" + url.toString());\n     \n     url.append(\"/fsck?ugi\u003d\").append(ugi.getShortUserName());\n     String dir \u003d null;\n     boolean doListCorruptFileBlocks \u003d false;\n     for (int idx \u003d 0; idx \u003c args.length; idx++) {\n       if (args[idx].equals(\"-move\")) { url.append(\"\u0026move\u003d1\"); }\n       else if (args[idx].equals(\"-delete\")) { url.append(\"\u0026delete\u003d1\"); }\n       else if (args[idx].equals(\"-files\")) { url.append(\"\u0026files\u003d1\"); }\n       else if (args[idx].equals(\"-openforwrite\")) { url.append(\"\u0026openforwrite\u003d1\"); }\n       else if (args[idx].equals(\"-blocks\")) { url.append(\"\u0026blocks\u003d1\"); }\n       else if (args[idx].equals(\"-locations\")) { url.append(\"\u0026locations\u003d1\"); }\n       else if (args[idx].equals(\"-racks\")) { url.append(\"\u0026racks\u003d1\"); }\n+      else if (args[idx].equals(\"-showprogress\")) { url.append(\"\u0026showprogress\u003d1\"); }\n       else if (args[idx].equals(\"-list-corruptfileblocks\")) {\n         url.append(\"\u0026listcorruptfileblocks\u003d1\");\n         doListCorruptFileBlocks \u003d true;\n       } else if (args[idx].equals(\"-includeSnapshots\")) {\n         url.append(\"\u0026includeSnapshots\u003d1\");\n       } else if (!args[idx].startsWith(\"-\")) {\n         if (null \u003d\u003d dir) {\n           dir \u003d args[idx];\n         } else {\n           System.err.println(\"fsck: can only operate on one path at a time \u0027\"\n               + args[idx] + \"\u0027\");\n           printUsage(System.err);\n           return -1;\n         }\n       } else {\n         System.err.println(\"fsck: Illegal option \u0027\" + args[idx] + \"\u0027\");\n         printUsage(System.err);\n         return -1;\n       }\n     }\n     if (null \u003d\u003d dir) {\n       dir \u003d \"/\";\n     }\n     url.append(\"\u0026path\u003d\").append(URLEncoder.encode(dir, \"UTF-8\"));\n     if (doListCorruptFileBlocks) {\n       return listCorruptFileBlocks(dir, url.toString());\n     }\n     URL path \u003d new URL(url.toString());\n     URLConnection connection;\n     try {\n       connection \u003d connectionFactory.openConnection(path, isSpnegoEnabled);\n     } catch (AuthenticationException e) {\n       throw new IOException(e);\n     }\n     InputStream stream \u003d connection.getInputStream();\n     BufferedReader input \u003d new BufferedReader(new InputStreamReader(\n                                               stream, \"UTF-8\"));\n     String line \u003d null;\n     String lastLine \u003d null;\n     int errCode \u003d -1;\n     try {\n       while ((line \u003d input.readLine()) !\u003d null) {\n         out.println(line);\n         lastLine \u003d line;\n       }\n     } finally {\n       input.close();\n     }\n     if (lastLine.endsWith(NamenodeFsck.HEALTHY_STATUS)) {\n       errCode \u003d 0;\n     } else if (lastLine.endsWith(NamenodeFsck.CORRUPT_STATUS)) {\n       errCode \u003d 1;\n     } else if (lastLine.endsWith(NamenodeFsck.NONEXISTENT_STATUS)) {\n       errCode \u003d 0;\n     }\n     return errCode;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int doWork(final String[] args) throws IOException {\n    final StringBuilder url \u003d new StringBuilder();\n    \n    URI namenodeAddress \u003d getCurrentNamenodeAddress();\n    if (namenodeAddress \u003d\u003d null) {\n      //Error message already output in {@link #getCurrentNamenodeAddress()}\n      System.err.println(\"DFSck exiting.\");\n      return 0;\n    }\n\n    url.append(namenodeAddress.toString());\n    System.err.println(\"Connecting to namenode via \" + url.toString());\n    \n    url.append(\"/fsck?ugi\u003d\").append(ugi.getShortUserName());\n    String dir \u003d null;\n    boolean doListCorruptFileBlocks \u003d false;\n    for (int idx \u003d 0; idx \u003c args.length; idx++) {\n      if (args[idx].equals(\"-move\")) { url.append(\"\u0026move\u003d1\"); }\n      else if (args[idx].equals(\"-delete\")) { url.append(\"\u0026delete\u003d1\"); }\n      else if (args[idx].equals(\"-files\")) { url.append(\"\u0026files\u003d1\"); }\n      else if (args[idx].equals(\"-openforwrite\")) { url.append(\"\u0026openforwrite\u003d1\"); }\n      else if (args[idx].equals(\"-blocks\")) { url.append(\"\u0026blocks\u003d1\"); }\n      else if (args[idx].equals(\"-locations\")) { url.append(\"\u0026locations\u003d1\"); }\n      else if (args[idx].equals(\"-racks\")) { url.append(\"\u0026racks\u003d1\"); }\n      else if (args[idx].equals(\"-showprogress\")) { url.append(\"\u0026showprogress\u003d1\"); }\n      else if (args[idx].equals(\"-list-corruptfileblocks\")) {\n        url.append(\"\u0026listcorruptfileblocks\u003d1\");\n        doListCorruptFileBlocks \u003d true;\n      } else if (args[idx].equals(\"-includeSnapshots\")) {\n        url.append(\"\u0026includeSnapshots\u003d1\");\n      } else if (!args[idx].startsWith(\"-\")) {\n        if (null \u003d\u003d dir) {\n          dir \u003d args[idx];\n        } else {\n          System.err.println(\"fsck: can only operate on one path at a time \u0027\"\n              + args[idx] + \"\u0027\");\n          printUsage(System.err);\n          return -1;\n        }\n      } else {\n        System.err.println(\"fsck: Illegal option \u0027\" + args[idx] + \"\u0027\");\n        printUsage(System.err);\n        return -1;\n      }\n    }\n    if (null \u003d\u003d dir) {\n      dir \u003d \"/\";\n    }\n    url.append(\"\u0026path\u003d\").append(URLEncoder.encode(dir, \"UTF-8\"));\n    if (doListCorruptFileBlocks) {\n      return listCorruptFileBlocks(dir, url.toString());\n    }\n    URL path \u003d new URL(url.toString());\n    URLConnection connection;\n    try {\n      connection \u003d connectionFactory.openConnection(path, isSpnegoEnabled);\n    } catch (AuthenticationException e) {\n      throw new IOException(e);\n    }\n    InputStream stream \u003d connection.getInputStream();\n    BufferedReader input \u003d new BufferedReader(new InputStreamReader(\n                                              stream, \"UTF-8\"));\n    String line \u003d null;\n    String lastLine \u003d null;\n    int errCode \u003d -1;\n    try {\n      while ((line \u003d input.readLine()) !\u003d null) {\n        out.println(line);\n        lastLine \u003d line;\n      }\n    } finally {\n      input.close();\n    }\n    if (lastLine.endsWith(NamenodeFsck.HEALTHY_STATUS)) {\n      errCode \u003d 0;\n    } else if (lastLine.endsWith(NamenodeFsck.CORRUPT_STATUS)) {\n      errCode \u003d 1;\n    } else if (lastLine.endsWith(NamenodeFsck.NONEXISTENT_STATUS)) {\n      errCode \u003d 0;\n    }\n    return errCode;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DFSck.java",
      "extendedDetails": {}
    },
    "045dc880e13271737b3cf316296e92fb95806663": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5312. Generate HTTP/HTTPS URL in DFSUtil#getInfoServer() based on the configured http policy. Contributed by Haohui Mai.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1548629 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "06/12/13 10:01 AM",
      "commitName": "045dc880e13271737b3cf316296e92fb95806663",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "27/11/13 2:59 AM",
      "commitNameOld": "b6d483b1221296be408df66bc56b37765ce196de",
      "commitAuthorOld": "Uma Maheswara Rao G",
      "daysBetweenCommits": 9.29,
      "commitsBetweenForRepo": 54,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,80 +1,81 @@\n   private int doWork(final String[] args) throws IOException {\n-    final StringBuilder url \u003d new StringBuilder(HttpConfig.getSchemePrefix());\n+    final StringBuilder url \u003d new StringBuilder();\n     \n-    String namenodeAddress \u003d getCurrentNamenodeAddress();\n+    URI namenodeAddress \u003d getCurrentNamenodeAddress();\n     if (namenodeAddress \u003d\u003d null) {\n       //Error message already output in {@link #getCurrentNamenodeAddress()}\n       System.err.println(\"DFSck exiting.\");\n       return 0;\n     }\n-    url.append(namenodeAddress);\n+\n+    url.append(namenodeAddress.toString());\n     System.err.println(\"Connecting to namenode via \" + url.toString());\n     \n     url.append(\"/fsck?ugi\u003d\").append(ugi.getShortUserName());\n     String dir \u003d null;\n     boolean doListCorruptFileBlocks \u003d false;\n     for (int idx \u003d 0; idx \u003c args.length; idx++) {\n       if (args[idx].equals(\"-move\")) { url.append(\"\u0026move\u003d1\"); }\n       else if (args[idx].equals(\"-delete\")) { url.append(\"\u0026delete\u003d1\"); }\n       else if (args[idx].equals(\"-files\")) { url.append(\"\u0026files\u003d1\"); }\n       else if (args[idx].equals(\"-openforwrite\")) { url.append(\"\u0026openforwrite\u003d1\"); }\n       else if (args[idx].equals(\"-blocks\")) { url.append(\"\u0026blocks\u003d1\"); }\n       else if (args[idx].equals(\"-locations\")) { url.append(\"\u0026locations\u003d1\"); }\n       else if (args[idx].equals(\"-racks\")) { url.append(\"\u0026racks\u003d1\"); }\n       else if (args[idx].equals(\"-list-corruptfileblocks\")) {\n         url.append(\"\u0026listcorruptfileblocks\u003d1\");\n         doListCorruptFileBlocks \u003d true;\n       } else if (args[idx].equals(\"-includeSnapshots\")) {\n         url.append(\"\u0026includeSnapshots\u003d1\");\n       } else if (!args[idx].startsWith(\"-\")) {\n         if (null \u003d\u003d dir) {\n           dir \u003d args[idx];\n         } else {\n           System.err.println(\"fsck: can only operate on one path at a time \u0027\"\n               + args[idx] + \"\u0027\");\n           printUsage(System.err);\n           return -1;\n         }\n       } else {\n         System.err.println(\"fsck: Illegal option \u0027\" + args[idx] + \"\u0027\");\n         printUsage(System.err);\n         return -1;\n       }\n     }\n     if (null \u003d\u003d dir) {\n       dir \u003d \"/\";\n     }\n     url.append(\"\u0026path\u003d\").append(URLEncoder.encode(dir, \"UTF-8\"));\n     if (doListCorruptFileBlocks) {\n       return listCorruptFileBlocks(dir, url.toString());\n     }\n     URL path \u003d new URL(url.toString());\n     URLConnection connection;\n     try {\n       connection \u003d connectionFactory.openConnection(path, isSpnegoEnabled);\n     } catch (AuthenticationException e) {\n       throw new IOException(e);\n     }\n     InputStream stream \u003d connection.getInputStream();\n     BufferedReader input \u003d new BufferedReader(new InputStreamReader(\n                                               stream, \"UTF-8\"));\n     String line \u003d null;\n     String lastLine \u003d null;\n     int errCode \u003d -1;\n     try {\n       while ((line \u003d input.readLine()) !\u003d null) {\n         out.println(line);\n         lastLine \u003d line;\n       }\n     } finally {\n       input.close();\n     }\n     if (lastLine.endsWith(NamenodeFsck.HEALTHY_STATUS)) {\n       errCode \u003d 0;\n     } else if (lastLine.endsWith(NamenodeFsck.CORRUPT_STATUS)) {\n       errCode \u003d 1;\n     } else if (lastLine.endsWith(NamenodeFsck.NONEXISTENT_STATUS)) {\n       errCode \u003d 0;\n     }\n     return errCode;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int doWork(final String[] args) throws IOException {\n    final StringBuilder url \u003d new StringBuilder();\n    \n    URI namenodeAddress \u003d getCurrentNamenodeAddress();\n    if (namenodeAddress \u003d\u003d null) {\n      //Error message already output in {@link #getCurrentNamenodeAddress()}\n      System.err.println(\"DFSck exiting.\");\n      return 0;\n    }\n\n    url.append(namenodeAddress.toString());\n    System.err.println(\"Connecting to namenode via \" + url.toString());\n    \n    url.append(\"/fsck?ugi\u003d\").append(ugi.getShortUserName());\n    String dir \u003d null;\n    boolean doListCorruptFileBlocks \u003d false;\n    for (int idx \u003d 0; idx \u003c args.length; idx++) {\n      if (args[idx].equals(\"-move\")) { url.append(\"\u0026move\u003d1\"); }\n      else if (args[idx].equals(\"-delete\")) { url.append(\"\u0026delete\u003d1\"); }\n      else if (args[idx].equals(\"-files\")) { url.append(\"\u0026files\u003d1\"); }\n      else if (args[idx].equals(\"-openforwrite\")) { url.append(\"\u0026openforwrite\u003d1\"); }\n      else if (args[idx].equals(\"-blocks\")) { url.append(\"\u0026blocks\u003d1\"); }\n      else if (args[idx].equals(\"-locations\")) { url.append(\"\u0026locations\u003d1\"); }\n      else if (args[idx].equals(\"-racks\")) { url.append(\"\u0026racks\u003d1\"); }\n      else if (args[idx].equals(\"-list-corruptfileblocks\")) {\n        url.append(\"\u0026listcorruptfileblocks\u003d1\");\n        doListCorruptFileBlocks \u003d true;\n      } else if (args[idx].equals(\"-includeSnapshots\")) {\n        url.append(\"\u0026includeSnapshots\u003d1\");\n      } else if (!args[idx].startsWith(\"-\")) {\n        if (null \u003d\u003d dir) {\n          dir \u003d args[idx];\n        } else {\n          System.err.println(\"fsck: can only operate on one path at a time \u0027\"\n              + args[idx] + \"\u0027\");\n          printUsage(System.err);\n          return -1;\n        }\n      } else {\n        System.err.println(\"fsck: Illegal option \u0027\" + args[idx] + \"\u0027\");\n        printUsage(System.err);\n        return -1;\n      }\n    }\n    if (null \u003d\u003d dir) {\n      dir \u003d \"/\";\n    }\n    url.append(\"\u0026path\u003d\").append(URLEncoder.encode(dir, \"UTF-8\"));\n    if (doListCorruptFileBlocks) {\n      return listCorruptFileBlocks(dir, url.toString());\n    }\n    URL path \u003d new URL(url.toString());\n    URLConnection connection;\n    try {\n      connection \u003d connectionFactory.openConnection(path, isSpnegoEnabled);\n    } catch (AuthenticationException e) {\n      throw new IOException(e);\n    }\n    InputStream stream \u003d connection.getInputStream();\n    BufferedReader input \u003d new BufferedReader(new InputStreamReader(\n                                              stream, \"UTF-8\"));\n    String line \u003d null;\n    String lastLine \u003d null;\n    int errCode \u003d -1;\n    try {\n      while ((line \u003d input.readLine()) !\u003d null) {\n        out.println(line);\n        lastLine \u003d line;\n      }\n    } finally {\n      input.close();\n    }\n    if (lastLine.endsWith(NamenodeFsck.HEALTHY_STATUS)) {\n      errCode \u003d 0;\n    } else if (lastLine.endsWith(NamenodeFsck.CORRUPT_STATUS)) {\n      errCode \u003d 1;\n    } else if (lastLine.endsWith(NamenodeFsck.NONEXISTENT_STATUS)) {\n      errCode \u003d 0;\n    }\n    return errCode;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DFSck.java",
      "extendedDetails": {}
    },
    "b6d483b1221296be408df66bc56b37765ce196de": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5568. Support includeSnapshots option with Fsck command. Contributed by Vinay\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1545987 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/11/13 2:59 AM",
      "commitName": "b6d483b1221296be408df66bc56b37765ce196de",
      "commitAuthor": "Uma Maheswara Rao G",
      "commitDateOld": "25/11/13 5:16 PM",
      "commitNameOld": "d8a23834614581a292aad214dddcbcc4bbe86d27",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 1.4,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,78 +1,80 @@\n   private int doWork(final String[] args) throws IOException {\n     final StringBuilder url \u003d new StringBuilder(HttpConfig.getSchemePrefix());\n     \n     String namenodeAddress \u003d getCurrentNamenodeAddress();\n     if (namenodeAddress \u003d\u003d null) {\n       //Error message already output in {@link #getCurrentNamenodeAddress()}\n       System.err.println(\"DFSck exiting.\");\n       return 0;\n     }\n     url.append(namenodeAddress);\n     System.err.println(\"Connecting to namenode via \" + url.toString());\n     \n     url.append(\"/fsck?ugi\u003d\").append(ugi.getShortUserName());\n     String dir \u003d null;\n     boolean doListCorruptFileBlocks \u003d false;\n     for (int idx \u003d 0; idx \u003c args.length; idx++) {\n       if (args[idx].equals(\"-move\")) { url.append(\"\u0026move\u003d1\"); }\n       else if (args[idx].equals(\"-delete\")) { url.append(\"\u0026delete\u003d1\"); }\n       else if (args[idx].equals(\"-files\")) { url.append(\"\u0026files\u003d1\"); }\n       else if (args[idx].equals(\"-openforwrite\")) { url.append(\"\u0026openforwrite\u003d1\"); }\n       else if (args[idx].equals(\"-blocks\")) { url.append(\"\u0026blocks\u003d1\"); }\n       else if (args[idx].equals(\"-locations\")) { url.append(\"\u0026locations\u003d1\"); }\n       else if (args[idx].equals(\"-racks\")) { url.append(\"\u0026racks\u003d1\"); }\n       else if (args[idx].equals(\"-list-corruptfileblocks\")) {\n         url.append(\"\u0026listcorruptfileblocks\u003d1\");\n         doListCorruptFileBlocks \u003d true;\n+      } else if (args[idx].equals(\"-includeSnapshots\")) {\n+        url.append(\"\u0026includeSnapshots\u003d1\");\n       } else if (!args[idx].startsWith(\"-\")) {\n         if (null \u003d\u003d dir) {\n           dir \u003d args[idx];\n         } else {\n           System.err.println(\"fsck: can only operate on one path at a time \u0027\"\n               + args[idx] + \"\u0027\");\n           printUsage(System.err);\n           return -1;\n         }\n       } else {\n         System.err.println(\"fsck: Illegal option \u0027\" + args[idx] + \"\u0027\");\n         printUsage(System.err);\n         return -1;\n       }\n     }\n     if (null \u003d\u003d dir) {\n       dir \u003d \"/\";\n     }\n     url.append(\"\u0026path\u003d\").append(URLEncoder.encode(dir, \"UTF-8\"));\n     if (doListCorruptFileBlocks) {\n       return listCorruptFileBlocks(dir, url.toString());\n     }\n     URL path \u003d new URL(url.toString());\n     URLConnection connection;\n     try {\n       connection \u003d connectionFactory.openConnection(path, isSpnegoEnabled);\n     } catch (AuthenticationException e) {\n       throw new IOException(e);\n     }\n     InputStream stream \u003d connection.getInputStream();\n     BufferedReader input \u003d new BufferedReader(new InputStreamReader(\n                                               stream, \"UTF-8\"));\n     String line \u003d null;\n     String lastLine \u003d null;\n     int errCode \u003d -1;\n     try {\n       while ((line \u003d input.readLine()) !\u003d null) {\n         out.println(line);\n         lastLine \u003d line;\n       }\n     } finally {\n       input.close();\n     }\n     if (lastLine.endsWith(NamenodeFsck.HEALTHY_STATUS)) {\n       errCode \u003d 0;\n     } else if (lastLine.endsWith(NamenodeFsck.CORRUPT_STATUS)) {\n       errCode \u003d 1;\n     } else if (lastLine.endsWith(NamenodeFsck.NONEXISTENT_STATUS)) {\n       errCode \u003d 0;\n     }\n     return errCode;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int doWork(final String[] args) throws IOException {\n    final StringBuilder url \u003d new StringBuilder(HttpConfig.getSchemePrefix());\n    \n    String namenodeAddress \u003d getCurrentNamenodeAddress();\n    if (namenodeAddress \u003d\u003d null) {\n      //Error message already output in {@link #getCurrentNamenodeAddress()}\n      System.err.println(\"DFSck exiting.\");\n      return 0;\n    }\n    url.append(namenodeAddress);\n    System.err.println(\"Connecting to namenode via \" + url.toString());\n    \n    url.append(\"/fsck?ugi\u003d\").append(ugi.getShortUserName());\n    String dir \u003d null;\n    boolean doListCorruptFileBlocks \u003d false;\n    for (int idx \u003d 0; idx \u003c args.length; idx++) {\n      if (args[idx].equals(\"-move\")) { url.append(\"\u0026move\u003d1\"); }\n      else if (args[idx].equals(\"-delete\")) { url.append(\"\u0026delete\u003d1\"); }\n      else if (args[idx].equals(\"-files\")) { url.append(\"\u0026files\u003d1\"); }\n      else if (args[idx].equals(\"-openforwrite\")) { url.append(\"\u0026openforwrite\u003d1\"); }\n      else if (args[idx].equals(\"-blocks\")) { url.append(\"\u0026blocks\u003d1\"); }\n      else if (args[idx].equals(\"-locations\")) { url.append(\"\u0026locations\u003d1\"); }\n      else if (args[idx].equals(\"-racks\")) { url.append(\"\u0026racks\u003d1\"); }\n      else if (args[idx].equals(\"-list-corruptfileblocks\")) {\n        url.append(\"\u0026listcorruptfileblocks\u003d1\");\n        doListCorruptFileBlocks \u003d true;\n      } else if (args[idx].equals(\"-includeSnapshots\")) {\n        url.append(\"\u0026includeSnapshots\u003d1\");\n      } else if (!args[idx].startsWith(\"-\")) {\n        if (null \u003d\u003d dir) {\n          dir \u003d args[idx];\n        } else {\n          System.err.println(\"fsck: can only operate on one path at a time \u0027\"\n              + args[idx] + \"\u0027\");\n          printUsage(System.err);\n          return -1;\n        }\n      } else {\n        System.err.println(\"fsck: Illegal option \u0027\" + args[idx] + \"\u0027\");\n        printUsage(System.err);\n        return -1;\n      }\n    }\n    if (null \u003d\u003d dir) {\n      dir \u003d \"/\";\n    }\n    url.append(\"\u0026path\u003d\").append(URLEncoder.encode(dir, \"UTF-8\"));\n    if (doListCorruptFileBlocks) {\n      return listCorruptFileBlocks(dir, url.toString());\n    }\n    URL path \u003d new URL(url.toString());\n    URLConnection connection;\n    try {\n      connection \u003d connectionFactory.openConnection(path, isSpnegoEnabled);\n    } catch (AuthenticationException e) {\n      throw new IOException(e);\n    }\n    InputStream stream \u003d connection.getInputStream();\n    BufferedReader input \u003d new BufferedReader(new InputStreamReader(\n                                              stream, \"UTF-8\"));\n    String line \u003d null;\n    String lastLine \u003d null;\n    int errCode \u003d -1;\n    try {\n      while ((line \u003d input.readLine()) !\u003d null) {\n        out.println(line);\n        lastLine \u003d line;\n      }\n    } finally {\n      input.close();\n    }\n    if (lastLine.endsWith(NamenodeFsck.HEALTHY_STATUS)) {\n      errCode \u003d 0;\n    } else if (lastLine.endsWith(NamenodeFsck.CORRUPT_STATUS)) {\n      errCode \u003d 1;\n    } else if (lastLine.endsWith(NamenodeFsck.NONEXISTENT_STATUS)) {\n      errCode \u003d 0;\n    }\n    return errCode;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DFSck.java",
      "extendedDetails": {}
    },
    "d8a23834614581a292aad214dddcbcc4bbe86d27": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5538. URLConnectionFactory should pick up the SSL related configuration by default. Contributed by Haohui Mai.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1545491 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/11/13 5:16 PM",
      "commitName": "d8a23834614581a292aad214dddcbcc4bbe86d27",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "14/08/12 5:28 PM",
      "commitNameOld": "28e87740c5797e87a9038d7f151c8b21a5b04592",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 468.03,
      "commitsBetweenForRepo": 2787,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,73 +1,78 @@\n   private int doWork(final String[] args) throws IOException {\n     final StringBuilder url \u003d new StringBuilder(HttpConfig.getSchemePrefix());\n     \n     String namenodeAddress \u003d getCurrentNamenodeAddress();\n     if (namenodeAddress \u003d\u003d null) {\n       //Error message already output in {@link #getCurrentNamenodeAddress()}\n       System.err.println(\"DFSck exiting.\");\n       return 0;\n     }\n     url.append(namenodeAddress);\n     System.err.println(\"Connecting to namenode via \" + url.toString());\n     \n     url.append(\"/fsck?ugi\u003d\").append(ugi.getShortUserName());\n     String dir \u003d null;\n     boolean doListCorruptFileBlocks \u003d false;\n     for (int idx \u003d 0; idx \u003c args.length; idx++) {\n       if (args[idx].equals(\"-move\")) { url.append(\"\u0026move\u003d1\"); }\n       else if (args[idx].equals(\"-delete\")) { url.append(\"\u0026delete\u003d1\"); }\n       else if (args[idx].equals(\"-files\")) { url.append(\"\u0026files\u003d1\"); }\n       else if (args[idx].equals(\"-openforwrite\")) { url.append(\"\u0026openforwrite\u003d1\"); }\n       else if (args[idx].equals(\"-blocks\")) { url.append(\"\u0026blocks\u003d1\"); }\n       else if (args[idx].equals(\"-locations\")) { url.append(\"\u0026locations\u003d1\"); }\n       else if (args[idx].equals(\"-racks\")) { url.append(\"\u0026racks\u003d1\"); }\n       else if (args[idx].equals(\"-list-corruptfileblocks\")) {\n         url.append(\"\u0026listcorruptfileblocks\u003d1\");\n         doListCorruptFileBlocks \u003d true;\n       } else if (!args[idx].startsWith(\"-\")) {\n         if (null \u003d\u003d dir) {\n           dir \u003d args[idx];\n         } else {\n           System.err.println(\"fsck: can only operate on one path at a time \u0027\"\n               + args[idx] + \"\u0027\");\n           printUsage(System.err);\n           return -1;\n         }\n       } else {\n         System.err.println(\"fsck: Illegal option \u0027\" + args[idx] + \"\u0027\");\n         printUsage(System.err);\n         return -1;\n       }\n     }\n     if (null \u003d\u003d dir) {\n       dir \u003d \"/\";\n     }\n     url.append(\"\u0026path\u003d\").append(URLEncoder.encode(dir, \"UTF-8\"));\n     if (doListCorruptFileBlocks) {\n       return listCorruptFileBlocks(dir, url.toString());\n     }\n     URL path \u003d new URL(url.toString());\n-    URLConnection connection \u003d SecurityUtil.openSecureHttpConnection(path);\n+    URLConnection connection;\n+    try {\n+      connection \u003d connectionFactory.openConnection(path, isSpnegoEnabled);\n+    } catch (AuthenticationException e) {\n+      throw new IOException(e);\n+    }\n     InputStream stream \u003d connection.getInputStream();\n     BufferedReader input \u003d new BufferedReader(new InputStreamReader(\n                                               stream, \"UTF-8\"));\n     String line \u003d null;\n     String lastLine \u003d null;\n     int errCode \u003d -1;\n     try {\n       while ((line \u003d input.readLine()) !\u003d null) {\n         out.println(line);\n         lastLine \u003d line;\n       }\n     } finally {\n       input.close();\n     }\n     if (lastLine.endsWith(NamenodeFsck.HEALTHY_STATUS)) {\n       errCode \u003d 0;\n     } else if (lastLine.endsWith(NamenodeFsck.CORRUPT_STATUS)) {\n       errCode \u003d 1;\n     } else if (lastLine.endsWith(NamenodeFsck.NONEXISTENT_STATUS)) {\n       errCode \u003d 0;\n     }\n     return errCode;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int doWork(final String[] args) throws IOException {\n    final StringBuilder url \u003d new StringBuilder(HttpConfig.getSchemePrefix());\n    \n    String namenodeAddress \u003d getCurrentNamenodeAddress();\n    if (namenodeAddress \u003d\u003d null) {\n      //Error message already output in {@link #getCurrentNamenodeAddress()}\n      System.err.println(\"DFSck exiting.\");\n      return 0;\n    }\n    url.append(namenodeAddress);\n    System.err.println(\"Connecting to namenode via \" + url.toString());\n    \n    url.append(\"/fsck?ugi\u003d\").append(ugi.getShortUserName());\n    String dir \u003d null;\n    boolean doListCorruptFileBlocks \u003d false;\n    for (int idx \u003d 0; idx \u003c args.length; idx++) {\n      if (args[idx].equals(\"-move\")) { url.append(\"\u0026move\u003d1\"); }\n      else if (args[idx].equals(\"-delete\")) { url.append(\"\u0026delete\u003d1\"); }\n      else if (args[idx].equals(\"-files\")) { url.append(\"\u0026files\u003d1\"); }\n      else if (args[idx].equals(\"-openforwrite\")) { url.append(\"\u0026openforwrite\u003d1\"); }\n      else if (args[idx].equals(\"-blocks\")) { url.append(\"\u0026blocks\u003d1\"); }\n      else if (args[idx].equals(\"-locations\")) { url.append(\"\u0026locations\u003d1\"); }\n      else if (args[idx].equals(\"-racks\")) { url.append(\"\u0026racks\u003d1\"); }\n      else if (args[idx].equals(\"-list-corruptfileblocks\")) {\n        url.append(\"\u0026listcorruptfileblocks\u003d1\");\n        doListCorruptFileBlocks \u003d true;\n      } else if (!args[idx].startsWith(\"-\")) {\n        if (null \u003d\u003d dir) {\n          dir \u003d args[idx];\n        } else {\n          System.err.println(\"fsck: can only operate on one path at a time \u0027\"\n              + args[idx] + \"\u0027\");\n          printUsage(System.err);\n          return -1;\n        }\n      } else {\n        System.err.println(\"fsck: Illegal option \u0027\" + args[idx] + \"\u0027\");\n        printUsage(System.err);\n        return -1;\n      }\n    }\n    if (null \u003d\u003d dir) {\n      dir \u003d \"/\";\n    }\n    url.append(\"\u0026path\u003d\").append(URLEncoder.encode(dir, \"UTF-8\"));\n    if (doListCorruptFileBlocks) {\n      return listCorruptFileBlocks(dir, url.toString());\n    }\n    URL path \u003d new URL(url.toString());\n    URLConnection connection;\n    try {\n      connection \u003d connectionFactory.openConnection(path, isSpnegoEnabled);\n    } catch (AuthenticationException e) {\n      throw new IOException(e);\n    }\n    InputStream stream \u003d connection.getInputStream();\n    BufferedReader input \u003d new BufferedReader(new InputStreamReader(\n                                              stream, \"UTF-8\"));\n    String line \u003d null;\n    String lastLine \u003d null;\n    int errCode \u003d -1;\n    try {\n      while ((line \u003d input.readLine()) !\u003d null) {\n        out.println(line);\n        lastLine \u003d line;\n      }\n    } finally {\n      input.close();\n    }\n    if (lastLine.endsWith(NamenodeFsck.HEALTHY_STATUS)) {\n      errCode \u003d 0;\n    } else if (lastLine.endsWith(NamenodeFsck.CORRUPT_STATUS)) {\n      errCode \u003d 1;\n    } else if (lastLine.endsWith(NamenodeFsck.NONEXISTENT_STATUS)) {\n      errCode \u003d 0;\n    }\n    return errCode;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DFSck.java",
      "extendedDetails": {}
    },
    "28e87740c5797e87a9038d7f151c8b21a5b04592": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3723. Add support -h, -help to all the commands. Contributed by Jing Zhao\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1373173 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/08/12 5:28 PM",
      "commitName": "28e87740c5797e87a9038d7f151c8b21a5b04592",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "14/08/12 5:25 PM",
      "commitNameOld": "231a52a7dfa73f7f302cc3bf671d433312373873",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,73 +1,73 @@\n   private int doWork(final String[] args) throws IOException {\n     final StringBuilder url \u003d new StringBuilder(HttpConfig.getSchemePrefix());\n     \n     String namenodeAddress \u003d getCurrentNamenodeAddress();\n     if (namenodeAddress \u003d\u003d null) {\n       //Error message already output in {@link #getCurrentNamenodeAddress()}\n       System.err.println(\"DFSck exiting.\");\n       return 0;\n     }\n     url.append(namenodeAddress);\n     System.err.println(\"Connecting to namenode via \" + url.toString());\n     \n     url.append(\"/fsck?ugi\u003d\").append(ugi.getShortUserName());\n     String dir \u003d null;\n     boolean doListCorruptFileBlocks \u003d false;\n     for (int idx \u003d 0; idx \u003c args.length; idx++) {\n       if (args[idx].equals(\"-move\")) { url.append(\"\u0026move\u003d1\"); }\n       else if (args[idx].equals(\"-delete\")) { url.append(\"\u0026delete\u003d1\"); }\n       else if (args[idx].equals(\"-files\")) { url.append(\"\u0026files\u003d1\"); }\n       else if (args[idx].equals(\"-openforwrite\")) { url.append(\"\u0026openforwrite\u003d1\"); }\n       else if (args[idx].equals(\"-blocks\")) { url.append(\"\u0026blocks\u003d1\"); }\n       else if (args[idx].equals(\"-locations\")) { url.append(\"\u0026locations\u003d1\"); }\n       else if (args[idx].equals(\"-racks\")) { url.append(\"\u0026racks\u003d1\"); }\n       else if (args[idx].equals(\"-list-corruptfileblocks\")) {\n         url.append(\"\u0026listcorruptfileblocks\u003d1\");\n         doListCorruptFileBlocks \u003d true;\n       } else if (!args[idx].startsWith(\"-\")) {\n         if (null \u003d\u003d dir) {\n           dir \u003d args[idx];\n         } else {\n           System.err.println(\"fsck: can only operate on one path at a time \u0027\"\n               + args[idx] + \"\u0027\");\n-          printUsage();\n+          printUsage(System.err);\n           return -1;\n         }\n       } else {\n         System.err.println(\"fsck: Illegal option \u0027\" + args[idx] + \"\u0027\");\n-        printUsage();\n+        printUsage(System.err);\n         return -1;\n       }\n     }\n     if (null \u003d\u003d dir) {\n       dir \u003d \"/\";\n     }\n     url.append(\"\u0026path\u003d\").append(URLEncoder.encode(dir, \"UTF-8\"));\n     if (doListCorruptFileBlocks) {\n       return listCorruptFileBlocks(dir, url.toString());\n     }\n     URL path \u003d new URL(url.toString());\n     URLConnection connection \u003d SecurityUtil.openSecureHttpConnection(path);\n     InputStream stream \u003d connection.getInputStream();\n     BufferedReader input \u003d new BufferedReader(new InputStreamReader(\n                                               stream, \"UTF-8\"));\n     String line \u003d null;\n     String lastLine \u003d null;\n     int errCode \u003d -1;\n     try {\n       while ((line \u003d input.readLine()) !\u003d null) {\n         out.println(line);\n         lastLine \u003d line;\n       }\n     } finally {\n       input.close();\n     }\n     if (lastLine.endsWith(NamenodeFsck.HEALTHY_STATUS)) {\n       errCode \u003d 0;\n     } else if (lastLine.endsWith(NamenodeFsck.CORRUPT_STATUS)) {\n       errCode \u003d 1;\n     } else if (lastLine.endsWith(NamenodeFsck.NONEXISTENT_STATUS)) {\n       errCode \u003d 0;\n     }\n     return errCode;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int doWork(final String[] args) throws IOException {\n    final StringBuilder url \u003d new StringBuilder(HttpConfig.getSchemePrefix());\n    \n    String namenodeAddress \u003d getCurrentNamenodeAddress();\n    if (namenodeAddress \u003d\u003d null) {\n      //Error message already output in {@link #getCurrentNamenodeAddress()}\n      System.err.println(\"DFSck exiting.\");\n      return 0;\n    }\n    url.append(namenodeAddress);\n    System.err.println(\"Connecting to namenode via \" + url.toString());\n    \n    url.append(\"/fsck?ugi\u003d\").append(ugi.getShortUserName());\n    String dir \u003d null;\n    boolean doListCorruptFileBlocks \u003d false;\n    for (int idx \u003d 0; idx \u003c args.length; idx++) {\n      if (args[idx].equals(\"-move\")) { url.append(\"\u0026move\u003d1\"); }\n      else if (args[idx].equals(\"-delete\")) { url.append(\"\u0026delete\u003d1\"); }\n      else if (args[idx].equals(\"-files\")) { url.append(\"\u0026files\u003d1\"); }\n      else if (args[idx].equals(\"-openforwrite\")) { url.append(\"\u0026openforwrite\u003d1\"); }\n      else if (args[idx].equals(\"-blocks\")) { url.append(\"\u0026blocks\u003d1\"); }\n      else if (args[idx].equals(\"-locations\")) { url.append(\"\u0026locations\u003d1\"); }\n      else if (args[idx].equals(\"-racks\")) { url.append(\"\u0026racks\u003d1\"); }\n      else if (args[idx].equals(\"-list-corruptfileblocks\")) {\n        url.append(\"\u0026listcorruptfileblocks\u003d1\");\n        doListCorruptFileBlocks \u003d true;\n      } else if (!args[idx].startsWith(\"-\")) {\n        if (null \u003d\u003d dir) {\n          dir \u003d args[idx];\n        } else {\n          System.err.println(\"fsck: can only operate on one path at a time \u0027\"\n              + args[idx] + \"\u0027\");\n          printUsage(System.err);\n          return -1;\n        }\n      } else {\n        System.err.println(\"fsck: Illegal option \u0027\" + args[idx] + \"\u0027\");\n        printUsage(System.err);\n        return -1;\n      }\n    }\n    if (null \u003d\u003d dir) {\n      dir \u003d \"/\";\n    }\n    url.append(\"\u0026path\u003d\").append(URLEncoder.encode(dir, \"UTF-8\"));\n    if (doListCorruptFileBlocks) {\n      return listCorruptFileBlocks(dir, url.toString());\n    }\n    URL path \u003d new URL(url.toString());\n    URLConnection connection \u003d SecurityUtil.openSecureHttpConnection(path);\n    InputStream stream \u003d connection.getInputStream();\n    BufferedReader input \u003d new BufferedReader(new InputStreamReader(\n                                              stream, \"UTF-8\"));\n    String line \u003d null;\n    String lastLine \u003d null;\n    int errCode \u003d -1;\n    try {\n      while ((line \u003d input.readLine()) !\u003d null) {\n        out.println(line);\n        lastLine \u003d line;\n      }\n    } finally {\n      input.close();\n    }\n    if (lastLine.endsWith(NamenodeFsck.HEALTHY_STATUS)) {\n      errCode \u003d 0;\n    } else if (lastLine.endsWith(NamenodeFsck.CORRUPT_STATUS)) {\n      errCode \u003d 1;\n    } else if (lastLine.endsWith(NamenodeFsck.NONEXISTENT_STATUS)) {\n      errCode \u003d 0;\n    }\n    return errCode;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DFSck.java",
      "extendedDetails": {}
    },
    "231a52a7dfa73f7f302cc3bf671d433312373873": {
      "type": "Ybodychange",
      "commitMessage": "Reverting previous incomplete change r1373170 for HDFS-3723\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1373172 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/08/12 5:25 PM",
      "commitName": "231a52a7dfa73f7f302cc3bf671d433312373873",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "14/08/12 5:03 PM",
      "commitNameOld": "f026d8bb1ba6f9b059db5526f1fb1261f818ffd0",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,73 +1,73 @@\n   private int doWork(final String[] args) throws IOException {\n     final StringBuilder url \u003d new StringBuilder(HttpConfig.getSchemePrefix());\n     \n     String namenodeAddress \u003d getCurrentNamenodeAddress();\n     if (namenodeAddress \u003d\u003d null) {\n       //Error message already output in {@link #getCurrentNamenodeAddress()}\n       System.err.println(\"DFSck exiting.\");\n       return 0;\n     }\n     url.append(namenodeAddress);\n     System.err.println(\"Connecting to namenode via \" + url.toString());\n     \n     url.append(\"/fsck?ugi\u003d\").append(ugi.getShortUserName());\n     String dir \u003d null;\n     boolean doListCorruptFileBlocks \u003d false;\n     for (int idx \u003d 0; idx \u003c args.length; idx++) {\n       if (args[idx].equals(\"-move\")) { url.append(\"\u0026move\u003d1\"); }\n       else if (args[idx].equals(\"-delete\")) { url.append(\"\u0026delete\u003d1\"); }\n       else if (args[idx].equals(\"-files\")) { url.append(\"\u0026files\u003d1\"); }\n       else if (args[idx].equals(\"-openforwrite\")) { url.append(\"\u0026openforwrite\u003d1\"); }\n       else if (args[idx].equals(\"-blocks\")) { url.append(\"\u0026blocks\u003d1\"); }\n       else if (args[idx].equals(\"-locations\")) { url.append(\"\u0026locations\u003d1\"); }\n       else if (args[idx].equals(\"-racks\")) { url.append(\"\u0026racks\u003d1\"); }\n       else if (args[idx].equals(\"-list-corruptfileblocks\")) {\n         url.append(\"\u0026listcorruptfileblocks\u003d1\");\n         doListCorruptFileBlocks \u003d true;\n       } else if (!args[idx].startsWith(\"-\")) {\n         if (null \u003d\u003d dir) {\n           dir \u003d args[idx];\n         } else {\n           System.err.println(\"fsck: can only operate on one path at a time \u0027\"\n               + args[idx] + \"\u0027\");\n-          printUsage(System.err);\n+          printUsage();\n           return -1;\n         }\n       } else {\n         System.err.println(\"fsck: Illegal option \u0027\" + args[idx] + \"\u0027\");\n-        printUsage(System.err);\n+        printUsage();\n         return -1;\n       }\n     }\n     if (null \u003d\u003d dir) {\n       dir \u003d \"/\";\n     }\n     url.append(\"\u0026path\u003d\").append(URLEncoder.encode(dir, \"UTF-8\"));\n     if (doListCorruptFileBlocks) {\n       return listCorruptFileBlocks(dir, url.toString());\n     }\n     URL path \u003d new URL(url.toString());\n     URLConnection connection \u003d SecurityUtil.openSecureHttpConnection(path);\n     InputStream stream \u003d connection.getInputStream();\n     BufferedReader input \u003d new BufferedReader(new InputStreamReader(\n                                               stream, \"UTF-8\"));\n     String line \u003d null;\n     String lastLine \u003d null;\n     int errCode \u003d -1;\n     try {\n       while ((line \u003d input.readLine()) !\u003d null) {\n         out.println(line);\n         lastLine \u003d line;\n       }\n     } finally {\n       input.close();\n     }\n     if (lastLine.endsWith(NamenodeFsck.HEALTHY_STATUS)) {\n       errCode \u003d 0;\n     } else if (lastLine.endsWith(NamenodeFsck.CORRUPT_STATUS)) {\n       errCode \u003d 1;\n     } else if (lastLine.endsWith(NamenodeFsck.NONEXISTENT_STATUS)) {\n       errCode \u003d 0;\n     }\n     return errCode;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int doWork(final String[] args) throws IOException {\n    final StringBuilder url \u003d new StringBuilder(HttpConfig.getSchemePrefix());\n    \n    String namenodeAddress \u003d getCurrentNamenodeAddress();\n    if (namenodeAddress \u003d\u003d null) {\n      //Error message already output in {@link #getCurrentNamenodeAddress()}\n      System.err.println(\"DFSck exiting.\");\n      return 0;\n    }\n    url.append(namenodeAddress);\n    System.err.println(\"Connecting to namenode via \" + url.toString());\n    \n    url.append(\"/fsck?ugi\u003d\").append(ugi.getShortUserName());\n    String dir \u003d null;\n    boolean doListCorruptFileBlocks \u003d false;\n    for (int idx \u003d 0; idx \u003c args.length; idx++) {\n      if (args[idx].equals(\"-move\")) { url.append(\"\u0026move\u003d1\"); }\n      else if (args[idx].equals(\"-delete\")) { url.append(\"\u0026delete\u003d1\"); }\n      else if (args[idx].equals(\"-files\")) { url.append(\"\u0026files\u003d1\"); }\n      else if (args[idx].equals(\"-openforwrite\")) { url.append(\"\u0026openforwrite\u003d1\"); }\n      else if (args[idx].equals(\"-blocks\")) { url.append(\"\u0026blocks\u003d1\"); }\n      else if (args[idx].equals(\"-locations\")) { url.append(\"\u0026locations\u003d1\"); }\n      else if (args[idx].equals(\"-racks\")) { url.append(\"\u0026racks\u003d1\"); }\n      else if (args[idx].equals(\"-list-corruptfileblocks\")) {\n        url.append(\"\u0026listcorruptfileblocks\u003d1\");\n        doListCorruptFileBlocks \u003d true;\n      } else if (!args[idx].startsWith(\"-\")) {\n        if (null \u003d\u003d dir) {\n          dir \u003d args[idx];\n        } else {\n          System.err.println(\"fsck: can only operate on one path at a time \u0027\"\n              + args[idx] + \"\u0027\");\n          printUsage();\n          return -1;\n        }\n      } else {\n        System.err.println(\"fsck: Illegal option \u0027\" + args[idx] + \"\u0027\");\n        printUsage();\n        return -1;\n      }\n    }\n    if (null \u003d\u003d dir) {\n      dir \u003d \"/\";\n    }\n    url.append(\"\u0026path\u003d\").append(URLEncoder.encode(dir, \"UTF-8\"));\n    if (doListCorruptFileBlocks) {\n      return listCorruptFileBlocks(dir, url.toString());\n    }\n    URL path \u003d new URL(url.toString());\n    URLConnection connection \u003d SecurityUtil.openSecureHttpConnection(path);\n    InputStream stream \u003d connection.getInputStream();\n    BufferedReader input \u003d new BufferedReader(new InputStreamReader(\n                                              stream, \"UTF-8\"));\n    String line \u003d null;\n    String lastLine \u003d null;\n    int errCode \u003d -1;\n    try {\n      while ((line \u003d input.readLine()) !\u003d null) {\n        out.println(line);\n        lastLine \u003d line;\n      }\n    } finally {\n      input.close();\n    }\n    if (lastLine.endsWith(NamenodeFsck.HEALTHY_STATUS)) {\n      errCode \u003d 0;\n    } else if (lastLine.endsWith(NamenodeFsck.CORRUPT_STATUS)) {\n      errCode \u003d 1;\n    } else if (lastLine.endsWith(NamenodeFsck.NONEXISTENT_STATUS)) {\n      errCode \u003d 0;\n    }\n    return errCode;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DFSck.java",
      "extendedDetails": {}
    },
    "f026d8bb1ba6f9b059db5526f1fb1261f818ffd0": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3723. Add support -h, -help to all the commands. Contributed by Jing Zhao.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1373170 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/08/12 5:03 PM",
      "commitName": "f026d8bb1ba6f9b059db5526f1fb1261f818ffd0",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "09/08/12 3:52 PM",
      "commitNameOld": "4bca22005f48f426b9bc7cf36d435ead470a2590",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 5.05,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,73 +1,73 @@\n   private int doWork(final String[] args) throws IOException {\n     final StringBuilder url \u003d new StringBuilder(HttpConfig.getSchemePrefix());\n     \n     String namenodeAddress \u003d getCurrentNamenodeAddress();\n     if (namenodeAddress \u003d\u003d null) {\n       //Error message already output in {@link #getCurrentNamenodeAddress()}\n       System.err.println(\"DFSck exiting.\");\n       return 0;\n     }\n     url.append(namenodeAddress);\n     System.err.println(\"Connecting to namenode via \" + url.toString());\n     \n     url.append(\"/fsck?ugi\u003d\").append(ugi.getShortUserName());\n     String dir \u003d null;\n     boolean doListCorruptFileBlocks \u003d false;\n     for (int idx \u003d 0; idx \u003c args.length; idx++) {\n       if (args[idx].equals(\"-move\")) { url.append(\"\u0026move\u003d1\"); }\n       else if (args[idx].equals(\"-delete\")) { url.append(\"\u0026delete\u003d1\"); }\n       else if (args[idx].equals(\"-files\")) { url.append(\"\u0026files\u003d1\"); }\n       else if (args[idx].equals(\"-openforwrite\")) { url.append(\"\u0026openforwrite\u003d1\"); }\n       else if (args[idx].equals(\"-blocks\")) { url.append(\"\u0026blocks\u003d1\"); }\n       else if (args[idx].equals(\"-locations\")) { url.append(\"\u0026locations\u003d1\"); }\n       else if (args[idx].equals(\"-racks\")) { url.append(\"\u0026racks\u003d1\"); }\n       else if (args[idx].equals(\"-list-corruptfileblocks\")) {\n         url.append(\"\u0026listcorruptfileblocks\u003d1\");\n         doListCorruptFileBlocks \u003d true;\n       } else if (!args[idx].startsWith(\"-\")) {\n         if (null \u003d\u003d dir) {\n           dir \u003d args[idx];\n         } else {\n           System.err.println(\"fsck: can only operate on one path at a time \u0027\"\n               + args[idx] + \"\u0027\");\n-          printUsage();\n+          printUsage(System.err);\n           return -1;\n         }\n       } else {\n         System.err.println(\"fsck: Illegal option \u0027\" + args[idx] + \"\u0027\");\n-        printUsage();\n+        printUsage(System.err);\n         return -1;\n       }\n     }\n     if (null \u003d\u003d dir) {\n       dir \u003d \"/\";\n     }\n     url.append(\"\u0026path\u003d\").append(URLEncoder.encode(dir, \"UTF-8\"));\n     if (doListCorruptFileBlocks) {\n       return listCorruptFileBlocks(dir, url.toString());\n     }\n     URL path \u003d new URL(url.toString());\n     URLConnection connection \u003d SecurityUtil.openSecureHttpConnection(path);\n     InputStream stream \u003d connection.getInputStream();\n     BufferedReader input \u003d new BufferedReader(new InputStreamReader(\n                                               stream, \"UTF-8\"));\n     String line \u003d null;\n     String lastLine \u003d null;\n     int errCode \u003d -1;\n     try {\n       while ((line \u003d input.readLine()) !\u003d null) {\n         out.println(line);\n         lastLine \u003d line;\n       }\n     } finally {\n       input.close();\n     }\n     if (lastLine.endsWith(NamenodeFsck.HEALTHY_STATUS)) {\n       errCode \u003d 0;\n     } else if (lastLine.endsWith(NamenodeFsck.CORRUPT_STATUS)) {\n       errCode \u003d 1;\n     } else if (lastLine.endsWith(NamenodeFsck.NONEXISTENT_STATUS)) {\n       errCode \u003d 0;\n     }\n     return errCode;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int doWork(final String[] args) throws IOException {\n    final StringBuilder url \u003d new StringBuilder(HttpConfig.getSchemePrefix());\n    \n    String namenodeAddress \u003d getCurrentNamenodeAddress();\n    if (namenodeAddress \u003d\u003d null) {\n      //Error message already output in {@link #getCurrentNamenodeAddress()}\n      System.err.println(\"DFSck exiting.\");\n      return 0;\n    }\n    url.append(namenodeAddress);\n    System.err.println(\"Connecting to namenode via \" + url.toString());\n    \n    url.append(\"/fsck?ugi\u003d\").append(ugi.getShortUserName());\n    String dir \u003d null;\n    boolean doListCorruptFileBlocks \u003d false;\n    for (int idx \u003d 0; idx \u003c args.length; idx++) {\n      if (args[idx].equals(\"-move\")) { url.append(\"\u0026move\u003d1\"); }\n      else if (args[idx].equals(\"-delete\")) { url.append(\"\u0026delete\u003d1\"); }\n      else if (args[idx].equals(\"-files\")) { url.append(\"\u0026files\u003d1\"); }\n      else if (args[idx].equals(\"-openforwrite\")) { url.append(\"\u0026openforwrite\u003d1\"); }\n      else if (args[idx].equals(\"-blocks\")) { url.append(\"\u0026blocks\u003d1\"); }\n      else if (args[idx].equals(\"-locations\")) { url.append(\"\u0026locations\u003d1\"); }\n      else if (args[idx].equals(\"-racks\")) { url.append(\"\u0026racks\u003d1\"); }\n      else if (args[idx].equals(\"-list-corruptfileblocks\")) {\n        url.append(\"\u0026listcorruptfileblocks\u003d1\");\n        doListCorruptFileBlocks \u003d true;\n      } else if (!args[idx].startsWith(\"-\")) {\n        if (null \u003d\u003d dir) {\n          dir \u003d args[idx];\n        } else {\n          System.err.println(\"fsck: can only operate on one path at a time \u0027\"\n              + args[idx] + \"\u0027\");\n          printUsage(System.err);\n          return -1;\n        }\n      } else {\n        System.err.println(\"fsck: Illegal option \u0027\" + args[idx] + \"\u0027\");\n        printUsage(System.err);\n        return -1;\n      }\n    }\n    if (null \u003d\u003d dir) {\n      dir \u003d \"/\";\n    }\n    url.append(\"\u0026path\u003d\").append(URLEncoder.encode(dir, \"UTF-8\"));\n    if (doListCorruptFileBlocks) {\n      return listCorruptFileBlocks(dir, url.toString());\n    }\n    URL path \u003d new URL(url.toString());\n    URLConnection connection \u003d SecurityUtil.openSecureHttpConnection(path);\n    InputStream stream \u003d connection.getInputStream();\n    BufferedReader input \u003d new BufferedReader(new InputStreamReader(\n                                              stream, \"UTF-8\"));\n    String line \u003d null;\n    String lastLine \u003d null;\n    int errCode \u003d -1;\n    try {\n      while ((line \u003d input.readLine()) !\u003d null) {\n        out.println(line);\n        lastLine \u003d line;\n      }\n    } finally {\n      input.close();\n    }\n    if (lastLine.endsWith(NamenodeFsck.HEALTHY_STATUS)) {\n      errCode \u003d 0;\n    } else if (lastLine.endsWith(NamenodeFsck.CORRUPT_STATUS)) {\n      errCode \u003d 1;\n    } else if (lastLine.endsWith(NamenodeFsck.NONEXISTENT_STATUS)) {\n      errCode \u003d 0;\n    }\n    return errCode;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DFSck.java",
      "extendedDetails": {}
    },
    "4bca22005f48f426b9bc7cf36d435ead470a2590": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-8681. add support for HTTPS to the web UIs. (tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1371525 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/08/12 3:52 PM",
      "commitName": "4bca22005f48f426b9bc7cf36d435ead470a2590",
      "commitAuthor": "Alejandro Abdelnur",
      "commitDateOld": "15/07/12 7:58 PM",
      "commitNameOld": "0e8e499ff482c165d21c8e4f5ff9c33f306ca0d9",
      "commitAuthorOld": "Harsh J",
      "daysBetweenCommits": 24.83,
      "commitsBetweenForRepo": 124,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,73 +1,73 @@\n   private int doWork(final String[] args) throws IOException {\n-    final StringBuilder url \u003d new StringBuilder(\"http://\");\n+    final StringBuilder url \u003d new StringBuilder(HttpConfig.getSchemePrefix());\n     \n     String namenodeAddress \u003d getCurrentNamenodeAddress();\n     if (namenodeAddress \u003d\u003d null) {\n       //Error message already output in {@link #getCurrentNamenodeAddress()}\n       System.err.println(\"DFSck exiting.\");\n       return 0;\n     }\n     url.append(namenodeAddress);\n     System.err.println(\"Connecting to namenode via \" + url.toString());\n     \n     url.append(\"/fsck?ugi\u003d\").append(ugi.getShortUserName());\n     String dir \u003d null;\n     boolean doListCorruptFileBlocks \u003d false;\n     for (int idx \u003d 0; idx \u003c args.length; idx++) {\n       if (args[idx].equals(\"-move\")) { url.append(\"\u0026move\u003d1\"); }\n       else if (args[idx].equals(\"-delete\")) { url.append(\"\u0026delete\u003d1\"); }\n       else if (args[idx].equals(\"-files\")) { url.append(\"\u0026files\u003d1\"); }\n       else if (args[idx].equals(\"-openforwrite\")) { url.append(\"\u0026openforwrite\u003d1\"); }\n       else if (args[idx].equals(\"-blocks\")) { url.append(\"\u0026blocks\u003d1\"); }\n       else if (args[idx].equals(\"-locations\")) { url.append(\"\u0026locations\u003d1\"); }\n       else if (args[idx].equals(\"-racks\")) { url.append(\"\u0026racks\u003d1\"); }\n       else if (args[idx].equals(\"-list-corruptfileblocks\")) {\n         url.append(\"\u0026listcorruptfileblocks\u003d1\");\n         doListCorruptFileBlocks \u003d true;\n       } else if (!args[idx].startsWith(\"-\")) {\n         if (null \u003d\u003d dir) {\n           dir \u003d args[idx];\n         } else {\n           System.err.println(\"fsck: can only operate on one path at a time \u0027\"\n               + args[idx] + \"\u0027\");\n           printUsage();\n           return -1;\n         }\n       } else {\n         System.err.println(\"fsck: Illegal option \u0027\" + args[idx] + \"\u0027\");\n         printUsage();\n         return -1;\n       }\n     }\n     if (null \u003d\u003d dir) {\n       dir \u003d \"/\";\n     }\n     url.append(\"\u0026path\u003d\").append(URLEncoder.encode(dir, \"UTF-8\"));\n     if (doListCorruptFileBlocks) {\n       return listCorruptFileBlocks(dir, url.toString());\n     }\n     URL path \u003d new URL(url.toString());\n     URLConnection connection \u003d SecurityUtil.openSecureHttpConnection(path);\n     InputStream stream \u003d connection.getInputStream();\n     BufferedReader input \u003d new BufferedReader(new InputStreamReader(\n                                               stream, \"UTF-8\"));\n     String line \u003d null;\n     String lastLine \u003d null;\n     int errCode \u003d -1;\n     try {\n       while ((line \u003d input.readLine()) !\u003d null) {\n         out.println(line);\n         lastLine \u003d line;\n       }\n     } finally {\n       input.close();\n     }\n     if (lastLine.endsWith(NamenodeFsck.HEALTHY_STATUS)) {\n       errCode \u003d 0;\n     } else if (lastLine.endsWith(NamenodeFsck.CORRUPT_STATUS)) {\n       errCode \u003d 1;\n     } else if (lastLine.endsWith(NamenodeFsck.NONEXISTENT_STATUS)) {\n       errCode \u003d 0;\n     }\n     return errCode;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int doWork(final String[] args) throws IOException {\n    final StringBuilder url \u003d new StringBuilder(HttpConfig.getSchemePrefix());\n    \n    String namenodeAddress \u003d getCurrentNamenodeAddress();\n    if (namenodeAddress \u003d\u003d null) {\n      //Error message already output in {@link #getCurrentNamenodeAddress()}\n      System.err.println(\"DFSck exiting.\");\n      return 0;\n    }\n    url.append(namenodeAddress);\n    System.err.println(\"Connecting to namenode via \" + url.toString());\n    \n    url.append(\"/fsck?ugi\u003d\").append(ugi.getShortUserName());\n    String dir \u003d null;\n    boolean doListCorruptFileBlocks \u003d false;\n    for (int idx \u003d 0; idx \u003c args.length; idx++) {\n      if (args[idx].equals(\"-move\")) { url.append(\"\u0026move\u003d1\"); }\n      else if (args[idx].equals(\"-delete\")) { url.append(\"\u0026delete\u003d1\"); }\n      else if (args[idx].equals(\"-files\")) { url.append(\"\u0026files\u003d1\"); }\n      else if (args[idx].equals(\"-openforwrite\")) { url.append(\"\u0026openforwrite\u003d1\"); }\n      else if (args[idx].equals(\"-blocks\")) { url.append(\"\u0026blocks\u003d1\"); }\n      else if (args[idx].equals(\"-locations\")) { url.append(\"\u0026locations\u003d1\"); }\n      else if (args[idx].equals(\"-racks\")) { url.append(\"\u0026racks\u003d1\"); }\n      else if (args[idx].equals(\"-list-corruptfileblocks\")) {\n        url.append(\"\u0026listcorruptfileblocks\u003d1\");\n        doListCorruptFileBlocks \u003d true;\n      } else if (!args[idx].startsWith(\"-\")) {\n        if (null \u003d\u003d dir) {\n          dir \u003d args[idx];\n        } else {\n          System.err.println(\"fsck: can only operate on one path at a time \u0027\"\n              + args[idx] + \"\u0027\");\n          printUsage();\n          return -1;\n        }\n      } else {\n        System.err.println(\"fsck: Illegal option \u0027\" + args[idx] + \"\u0027\");\n        printUsage();\n        return -1;\n      }\n    }\n    if (null \u003d\u003d dir) {\n      dir \u003d \"/\";\n    }\n    url.append(\"\u0026path\u003d\").append(URLEncoder.encode(dir, \"UTF-8\"));\n    if (doListCorruptFileBlocks) {\n      return listCorruptFileBlocks(dir, url.toString());\n    }\n    URL path \u003d new URL(url.toString());\n    URLConnection connection \u003d SecurityUtil.openSecureHttpConnection(path);\n    InputStream stream \u003d connection.getInputStream();\n    BufferedReader input \u003d new BufferedReader(new InputStreamReader(\n                                              stream, \"UTF-8\"));\n    String line \u003d null;\n    String lastLine \u003d null;\n    int errCode \u003d -1;\n    try {\n      while ((line \u003d input.readLine()) !\u003d null) {\n        out.println(line);\n        lastLine \u003d line;\n      }\n    } finally {\n      input.close();\n    }\n    if (lastLine.endsWith(NamenodeFsck.HEALTHY_STATUS)) {\n      errCode \u003d 0;\n    } else if (lastLine.endsWith(NamenodeFsck.CORRUPT_STATUS)) {\n      errCode \u003d 1;\n    } else if (lastLine.endsWith(NamenodeFsck.NONEXISTENT_STATUS)) {\n      errCode \u003d 0;\n    }\n    return errCode;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DFSck.java",
      "extendedDetails": {}
    },
    "5dbbe0e0a5d31689d3425e490865f95057dc051c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2617. Replaced Kerberized SSL for image transfer and fsck with SPNEGO-based solution. Contributed by Jakob Homan, Alejandro Abdelnur, and Aaron T. Myers\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1334216 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/05/12 2:58 PM",
      "commitName": "5dbbe0e0a5d31689d3425e490865f95057dc051c",
      "commitAuthor": "Eli Collins",
      "commitDateOld": "26/03/12 10:02 AM",
      "commitNameOld": "ce1a7ec9755f17527c29b0db713d7e01750e10c9",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 39.21,
      "commitsBetweenForRepo": 316,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,79 +1,73 @@\n   private int doWork(final String[] args) throws IOException {\n-    String proto \u003d \"http://\";\n-    if (UserGroupInformation.isSecurityEnabled()) {\n-      SecurityUtil.initKrb5CipherSuites();\n-      proto \u003d \"https://\";\n-    }\n-    final StringBuilder url \u003d new StringBuilder(proto);\n+    final StringBuilder url \u003d new StringBuilder(\"http://\");\n     \n     String namenodeAddress \u003d getCurrentNamenodeAddress();\n     if (namenodeAddress \u003d\u003d null) {\n       //Error message already output in {@link #getCurrentNamenodeAddress()}\n       System.err.println(\"DFSck exiting.\");\n       return 0;\n     }\n     url.append(namenodeAddress);\n     System.err.println(\"Connecting to namenode via \" + url.toString());\n     \n     url.append(\"/fsck?ugi\u003d\").append(ugi.getShortUserName());\n     String dir \u003d null;\n     boolean doListCorruptFileBlocks \u003d false;\n     for (int idx \u003d 0; idx \u003c args.length; idx++) {\n       if (args[idx].equals(\"-move\")) { url.append(\"\u0026move\u003d1\"); }\n       else if (args[idx].equals(\"-delete\")) { url.append(\"\u0026delete\u003d1\"); }\n       else if (args[idx].equals(\"-files\")) { url.append(\"\u0026files\u003d1\"); }\n       else if (args[idx].equals(\"-openforwrite\")) { url.append(\"\u0026openforwrite\u003d1\"); }\n       else if (args[idx].equals(\"-blocks\")) { url.append(\"\u0026blocks\u003d1\"); }\n       else if (args[idx].equals(\"-locations\")) { url.append(\"\u0026locations\u003d1\"); }\n       else if (args[idx].equals(\"-racks\")) { url.append(\"\u0026racks\u003d1\"); }\n       else if (args[idx].equals(\"-list-corruptfileblocks\")) {\n         url.append(\"\u0026listcorruptfileblocks\u003d1\");\n         doListCorruptFileBlocks \u003d true;\n       } else if (!args[idx].startsWith(\"-\")) {\n         if (null \u003d\u003d dir) {\n           dir \u003d args[idx];\n         } else {\n           System.err.println(\"fsck: can only operate on one path at a time \u0027\"\n               + args[idx] + \"\u0027\");\n           printUsage();\n           return -1;\n         }\n       } else {\n         System.err.println(\"fsck: Illegal option \u0027\" + args[idx] + \"\u0027\");\n         printUsage();\n         return -1;\n       }\n     }\n     if (null \u003d\u003d dir) {\n       dir \u003d \"/\";\n     }\n     url.append(\"\u0026path\u003d\").append(URLEncoder.encode(dir, \"UTF-8\"));\n     if (doListCorruptFileBlocks) {\n       return listCorruptFileBlocks(dir, url.toString());\n     }\n     URL path \u003d new URL(url.toString());\n-    SecurityUtil.fetchServiceTicket(path);\n-    URLConnection connection \u003d path.openConnection();\n+    URLConnection connection \u003d SecurityUtil.openSecureHttpConnection(path);\n     InputStream stream \u003d connection.getInputStream();\n     BufferedReader input \u003d new BufferedReader(new InputStreamReader(\n                                               stream, \"UTF-8\"));\n     String line \u003d null;\n     String lastLine \u003d null;\n     int errCode \u003d -1;\n     try {\n       while ((line \u003d input.readLine()) !\u003d null) {\n         out.println(line);\n         lastLine \u003d line;\n       }\n     } finally {\n       input.close();\n     }\n     if (lastLine.endsWith(NamenodeFsck.HEALTHY_STATUS)) {\n       errCode \u003d 0;\n     } else if (lastLine.endsWith(NamenodeFsck.CORRUPT_STATUS)) {\n       errCode \u003d 1;\n     } else if (lastLine.endsWith(NamenodeFsck.NONEXISTENT_STATUS)) {\n       errCode \u003d 0;\n     }\n     return errCode;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int doWork(final String[] args) throws IOException {\n    final StringBuilder url \u003d new StringBuilder(\"http://\");\n    \n    String namenodeAddress \u003d getCurrentNamenodeAddress();\n    if (namenodeAddress \u003d\u003d null) {\n      //Error message already output in {@link #getCurrentNamenodeAddress()}\n      System.err.println(\"DFSck exiting.\");\n      return 0;\n    }\n    url.append(namenodeAddress);\n    System.err.println(\"Connecting to namenode via \" + url.toString());\n    \n    url.append(\"/fsck?ugi\u003d\").append(ugi.getShortUserName());\n    String dir \u003d null;\n    boolean doListCorruptFileBlocks \u003d false;\n    for (int idx \u003d 0; idx \u003c args.length; idx++) {\n      if (args[idx].equals(\"-move\")) { url.append(\"\u0026move\u003d1\"); }\n      else if (args[idx].equals(\"-delete\")) { url.append(\"\u0026delete\u003d1\"); }\n      else if (args[idx].equals(\"-files\")) { url.append(\"\u0026files\u003d1\"); }\n      else if (args[idx].equals(\"-openforwrite\")) { url.append(\"\u0026openforwrite\u003d1\"); }\n      else if (args[idx].equals(\"-blocks\")) { url.append(\"\u0026blocks\u003d1\"); }\n      else if (args[idx].equals(\"-locations\")) { url.append(\"\u0026locations\u003d1\"); }\n      else if (args[idx].equals(\"-racks\")) { url.append(\"\u0026racks\u003d1\"); }\n      else if (args[idx].equals(\"-list-corruptfileblocks\")) {\n        url.append(\"\u0026listcorruptfileblocks\u003d1\");\n        doListCorruptFileBlocks \u003d true;\n      } else if (!args[idx].startsWith(\"-\")) {\n        if (null \u003d\u003d dir) {\n          dir \u003d args[idx];\n        } else {\n          System.err.println(\"fsck: can only operate on one path at a time \u0027\"\n              + args[idx] + \"\u0027\");\n          printUsage();\n          return -1;\n        }\n      } else {\n        System.err.println(\"fsck: Illegal option \u0027\" + args[idx] + \"\u0027\");\n        printUsage();\n        return -1;\n      }\n    }\n    if (null \u003d\u003d dir) {\n      dir \u003d \"/\";\n    }\n    url.append(\"\u0026path\u003d\").append(URLEncoder.encode(dir, \"UTF-8\"));\n    if (doListCorruptFileBlocks) {\n      return listCorruptFileBlocks(dir, url.toString());\n    }\n    URL path \u003d new URL(url.toString());\n    URLConnection connection \u003d SecurityUtil.openSecureHttpConnection(path);\n    InputStream stream \u003d connection.getInputStream();\n    BufferedReader input \u003d new BufferedReader(new InputStreamReader(\n                                              stream, \"UTF-8\"));\n    String line \u003d null;\n    String lastLine \u003d null;\n    int errCode \u003d -1;\n    try {\n      while ((line \u003d input.readLine()) !\u003d null) {\n        out.println(line);\n        lastLine \u003d line;\n      }\n    } finally {\n      input.close();\n    }\n    if (lastLine.endsWith(NamenodeFsck.HEALTHY_STATUS)) {\n      errCode \u003d 0;\n    } else if (lastLine.endsWith(NamenodeFsck.CORRUPT_STATUS)) {\n      errCode \u003d 1;\n    } else if (lastLine.endsWith(NamenodeFsck.NONEXISTENT_STATUS)) {\n      errCode \u003d 0;\n    }\n    return errCode;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DFSck.java",
      "extendedDetails": {}
    },
    "1a75ec82885e45baf4d5cd56d6c738d8e68d8bc7": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2731. Add command to bootstrap the Standby Node\u0027s name directories from the Active NameNode. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1299807 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/03/12 12:41 PM",
      "commitName": "1a75ec82885e45baf4d5cd56d6c738d8e68d8bc7",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "03/02/12 7:10 PM",
      "commitNameOld": "ec6961b39c6e05a1ed0016e815c2e17c052d2462",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 37.69,
      "commitsBetweenForRepo": 301,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,80 +1,79 @@\n   private int doWork(final String[] args) throws IOException {\n     String proto \u003d \"http://\";\n     if (UserGroupInformation.isSecurityEnabled()) {\n-      System.setProperty(\"https.cipherSuites\",\n-          Krb5AndCertsSslSocketConnector.KRB5_CIPHER_SUITES.get(0));\n+      SecurityUtil.initKrb5CipherSuites();\n       proto \u003d \"https://\";\n     }\n     final StringBuilder url \u003d new StringBuilder(proto);\n     \n     String namenodeAddress \u003d getCurrentNamenodeAddress();\n     if (namenodeAddress \u003d\u003d null) {\n       //Error message already output in {@link #getCurrentNamenodeAddress()}\n       System.err.println(\"DFSck exiting.\");\n       return 0;\n     }\n     url.append(namenodeAddress);\n     System.err.println(\"Connecting to namenode via \" + url.toString());\n     \n     url.append(\"/fsck?ugi\u003d\").append(ugi.getShortUserName());\n     String dir \u003d null;\n     boolean doListCorruptFileBlocks \u003d false;\n     for (int idx \u003d 0; idx \u003c args.length; idx++) {\n       if (args[idx].equals(\"-move\")) { url.append(\"\u0026move\u003d1\"); }\n       else if (args[idx].equals(\"-delete\")) { url.append(\"\u0026delete\u003d1\"); }\n       else if (args[idx].equals(\"-files\")) { url.append(\"\u0026files\u003d1\"); }\n       else if (args[idx].equals(\"-openforwrite\")) { url.append(\"\u0026openforwrite\u003d1\"); }\n       else if (args[idx].equals(\"-blocks\")) { url.append(\"\u0026blocks\u003d1\"); }\n       else if (args[idx].equals(\"-locations\")) { url.append(\"\u0026locations\u003d1\"); }\n       else if (args[idx].equals(\"-racks\")) { url.append(\"\u0026racks\u003d1\"); }\n       else if (args[idx].equals(\"-list-corruptfileblocks\")) {\n         url.append(\"\u0026listcorruptfileblocks\u003d1\");\n         doListCorruptFileBlocks \u003d true;\n       } else if (!args[idx].startsWith(\"-\")) {\n         if (null \u003d\u003d dir) {\n           dir \u003d args[idx];\n         } else {\n           System.err.println(\"fsck: can only operate on one path at a time \u0027\"\n               + args[idx] + \"\u0027\");\n           printUsage();\n           return -1;\n         }\n       } else {\n         System.err.println(\"fsck: Illegal option \u0027\" + args[idx] + \"\u0027\");\n         printUsage();\n         return -1;\n       }\n     }\n     if (null \u003d\u003d dir) {\n       dir \u003d \"/\";\n     }\n     url.append(\"\u0026path\u003d\").append(URLEncoder.encode(dir, \"UTF-8\"));\n     if (doListCorruptFileBlocks) {\n       return listCorruptFileBlocks(dir, url.toString());\n     }\n     URL path \u003d new URL(url.toString());\n     SecurityUtil.fetchServiceTicket(path);\n     URLConnection connection \u003d path.openConnection();\n     InputStream stream \u003d connection.getInputStream();\n     BufferedReader input \u003d new BufferedReader(new InputStreamReader(\n                                               stream, \"UTF-8\"));\n     String line \u003d null;\n     String lastLine \u003d null;\n     int errCode \u003d -1;\n     try {\n       while ((line \u003d input.readLine()) !\u003d null) {\n         out.println(line);\n         lastLine \u003d line;\n       }\n     } finally {\n       input.close();\n     }\n     if (lastLine.endsWith(NamenodeFsck.HEALTHY_STATUS)) {\n       errCode \u003d 0;\n     } else if (lastLine.endsWith(NamenodeFsck.CORRUPT_STATUS)) {\n       errCode \u003d 1;\n     } else if (lastLine.endsWith(NamenodeFsck.NONEXISTENT_STATUS)) {\n       errCode \u003d 0;\n     }\n     return errCode;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int doWork(final String[] args) throws IOException {\n    String proto \u003d \"http://\";\n    if (UserGroupInformation.isSecurityEnabled()) {\n      SecurityUtil.initKrb5CipherSuites();\n      proto \u003d \"https://\";\n    }\n    final StringBuilder url \u003d new StringBuilder(proto);\n    \n    String namenodeAddress \u003d getCurrentNamenodeAddress();\n    if (namenodeAddress \u003d\u003d null) {\n      //Error message already output in {@link #getCurrentNamenodeAddress()}\n      System.err.println(\"DFSck exiting.\");\n      return 0;\n    }\n    url.append(namenodeAddress);\n    System.err.println(\"Connecting to namenode via \" + url.toString());\n    \n    url.append(\"/fsck?ugi\u003d\").append(ugi.getShortUserName());\n    String dir \u003d null;\n    boolean doListCorruptFileBlocks \u003d false;\n    for (int idx \u003d 0; idx \u003c args.length; idx++) {\n      if (args[idx].equals(\"-move\")) { url.append(\"\u0026move\u003d1\"); }\n      else if (args[idx].equals(\"-delete\")) { url.append(\"\u0026delete\u003d1\"); }\n      else if (args[idx].equals(\"-files\")) { url.append(\"\u0026files\u003d1\"); }\n      else if (args[idx].equals(\"-openforwrite\")) { url.append(\"\u0026openforwrite\u003d1\"); }\n      else if (args[idx].equals(\"-blocks\")) { url.append(\"\u0026blocks\u003d1\"); }\n      else if (args[idx].equals(\"-locations\")) { url.append(\"\u0026locations\u003d1\"); }\n      else if (args[idx].equals(\"-racks\")) { url.append(\"\u0026racks\u003d1\"); }\n      else if (args[idx].equals(\"-list-corruptfileblocks\")) {\n        url.append(\"\u0026listcorruptfileblocks\u003d1\");\n        doListCorruptFileBlocks \u003d true;\n      } else if (!args[idx].startsWith(\"-\")) {\n        if (null \u003d\u003d dir) {\n          dir \u003d args[idx];\n        } else {\n          System.err.println(\"fsck: can only operate on one path at a time \u0027\"\n              + args[idx] + \"\u0027\");\n          printUsage();\n          return -1;\n        }\n      } else {\n        System.err.println(\"fsck: Illegal option \u0027\" + args[idx] + \"\u0027\");\n        printUsage();\n        return -1;\n      }\n    }\n    if (null \u003d\u003d dir) {\n      dir \u003d \"/\";\n    }\n    url.append(\"\u0026path\u003d\").append(URLEncoder.encode(dir, \"UTF-8\"));\n    if (doListCorruptFileBlocks) {\n      return listCorruptFileBlocks(dir, url.toString());\n    }\n    URL path \u003d new URL(url.toString());\n    SecurityUtil.fetchServiceTicket(path);\n    URLConnection connection \u003d path.openConnection();\n    InputStream stream \u003d connection.getInputStream();\n    BufferedReader input \u003d new BufferedReader(new InputStreamReader(\n                                              stream, \"UTF-8\"));\n    String line \u003d null;\n    String lastLine \u003d null;\n    int errCode \u003d -1;\n    try {\n      while ((line \u003d input.readLine()) !\u003d null) {\n        out.println(line);\n        lastLine \u003d line;\n      }\n    } finally {\n      input.close();\n    }\n    if (lastLine.endsWith(NamenodeFsck.HEALTHY_STATUS)) {\n      errCode \u003d 0;\n    } else if (lastLine.endsWith(NamenodeFsck.CORRUPT_STATUS)) {\n      errCode \u003d 1;\n    } else if (lastLine.endsWith(NamenodeFsck.NONEXISTENT_STATUS)) {\n      errCode \u003d 0;\n    }\n    return errCode;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DFSck.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private int doWork(final String[] args) throws IOException {\n    String proto \u003d \"http://\";\n    if (UserGroupInformation.isSecurityEnabled()) {\n      System.setProperty(\"https.cipherSuites\",\n          Krb5AndCertsSslSocketConnector.KRB5_CIPHER_SUITES.get(0));\n      proto \u003d \"https://\";\n    }\n    final StringBuilder url \u003d new StringBuilder(proto);\n    \n    String namenodeAddress \u003d getCurrentNamenodeAddress();\n    if (namenodeAddress \u003d\u003d null) {\n      //Error message already output in {@link #getCurrentNamenodeAddress()}\n      System.err.println(\"DFSck exiting.\");\n      return 0;\n    }\n    url.append(namenodeAddress);\n    System.err.println(\"Connecting to namenode via \" + url.toString());\n    \n    url.append(\"/fsck?ugi\u003d\").append(ugi.getShortUserName());\n    String dir \u003d null;\n    boolean doListCorruptFileBlocks \u003d false;\n    for (int idx \u003d 0; idx \u003c args.length; idx++) {\n      if (args[idx].equals(\"-move\")) { url.append(\"\u0026move\u003d1\"); }\n      else if (args[idx].equals(\"-delete\")) { url.append(\"\u0026delete\u003d1\"); }\n      else if (args[idx].equals(\"-files\")) { url.append(\"\u0026files\u003d1\"); }\n      else if (args[idx].equals(\"-openforwrite\")) { url.append(\"\u0026openforwrite\u003d1\"); }\n      else if (args[idx].equals(\"-blocks\")) { url.append(\"\u0026blocks\u003d1\"); }\n      else if (args[idx].equals(\"-locations\")) { url.append(\"\u0026locations\u003d1\"); }\n      else if (args[idx].equals(\"-racks\")) { url.append(\"\u0026racks\u003d1\"); }\n      else if (args[idx].equals(\"-list-corruptfileblocks\")) {\n        url.append(\"\u0026listcorruptfileblocks\u003d1\");\n        doListCorruptFileBlocks \u003d true;\n      } else if (!args[idx].startsWith(\"-\")) {\n        if (null \u003d\u003d dir) {\n          dir \u003d args[idx];\n        } else {\n          System.err.println(\"fsck: can only operate on one path at a time \u0027\"\n              + args[idx] + \"\u0027\");\n          printUsage();\n          return -1;\n        }\n      } else {\n        System.err.println(\"fsck: Illegal option \u0027\" + args[idx] + \"\u0027\");\n        printUsage();\n        return -1;\n      }\n    }\n    if (null \u003d\u003d dir) {\n      dir \u003d \"/\";\n    }\n    url.append(\"\u0026path\u003d\").append(URLEncoder.encode(dir, \"UTF-8\"));\n    if (doListCorruptFileBlocks) {\n      return listCorruptFileBlocks(dir, url.toString());\n    }\n    URL path \u003d new URL(url.toString());\n    SecurityUtil.fetchServiceTicket(path);\n    URLConnection connection \u003d path.openConnection();\n    InputStream stream \u003d connection.getInputStream();\n    BufferedReader input \u003d new BufferedReader(new InputStreamReader(\n                                              stream, \"UTF-8\"));\n    String line \u003d null;\n    String lastLine \u003d null;\n    int errCode \u003d -1;\n    try {\n      while ((line \u003d input.readLine()) !\u003d null) {\n        out.println(line);\n        lastLine \u003d line;\n      }\n    } finally {\n      input.close();\n    }\n    if (lastLine.endsWith(NamenodeFsck.HEALTHY_STATUS)) {\n      errCode \u003d 0;\n    } else if (lastLine.endsWith(NamenodeFsck.CORRUPT_STATUS)) {\n      errCode \u003d 1;\n    } else if (lastLine.endsWith(NamenodeFsck.NONEXISTENT_STATUS)) {\n      errCode \u003d 0;\n    }\n    return errCode;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DFSck.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DFSck.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DFSck.java"
      }
    },
    "d86f3183d93714ba078416af4f609d26376eadb0": {
      "type": "Yfilerename",
      "commitMessage": "HDFS-2096. Mavenization of hadoop-hdfs. Contributed by Alejandro Abdelnur.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159702 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/08/11 10:36 AM",
      "commitName": "d86f3183d93714ba078416af4f609d26376eadb0",
      "commitAuthor": "Thomas White",
      "commitDateOld": "19/08/11 10:26 AM",
      "commitNameOld": "6ee5a73e0e91a2ef27753a32c576835e951d8119",
      "commitAuthorOld": "Thomas White",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private int doWork(final String[] args) throws IOException {\n    String proto \u003d \"http://\";\n    if (UserGroupInformation.isSecurityEnabled()) {\n      System.setProperty(\"https.cipherSuites\",\n          Krb5AndCertsSslSocketConnector.KRB5_CIPHER_SUITES.get(0));\n      proto \u003d \"https://\";\n    }\n    final StringBuilder url \u003d new StringBuilder(proto);\n    \n    String namenodeAddress \u003d getCurrentNamenodeAddress();\n    if (namenodeAddress \u003d\u003d null) {\n      //Error message already output in {@link #getCurrentNamenodeAddress()}\n      System.err.println(\"DFSck exiting.\");\n      return 0;\n    }\n    url.append(namenodeAddress);\n    System.err.println(\"Connecting to namenode via \" + url.toString());\n    \n    url.append(\"/fsck?ugi\u003d\").append(ugi.getShortUserName());\n    String dir \u003d null;\n    boolean doListCorruptFileBlocks \u003d false;\n    for (int idx \u003d 0; idx \u003c args.length; idx++) {\n      if (args[idx].equals(\"-move\")) { url.append(\"\u0026move\u003d1\"); }\n      else if (args[idx].equals(\"-delete\")) { url.append(\"\u0026delete\u003d1\"); }\n      else if (args[idx].equals(\"-files\")) { url.append(\"\u0026files\u003d1\"); }\n      else if (args[idx].equals(\"-openforwrite\")) { url.append(\"\u0026openforwrite\u003d1\"); }\n      else if (args[idx].equals(\"-blocks\")) { url.append(\"\u0026blocks\u003d1\"); }\n      else if (args[idx].equals(\"-locations\")) { url.append(\"\u0026locations\u003d1\"); }\n      else if (args[idx].equals(\"-racks\")) { url.append(\"\u0026racks\u003d1\"); }\n      else if (args[idx].equals(\"-list-corruptfileblocks\")) {\n        url.append(\"\u0026listcorruptfileblocks\u003d1\");\n        doListCorruptFileBlocks \u003d true;\n      } else if (!args[idx].startsWith(\"-\")) {\n        if (null \u003d\u003d dir) {\n          dir \u003d args[idx];\n        } else {\n          System.err.println(\"fsck: can only operate on one path at a time \u0027\"\n              + args[idx] + \"\u0027\");\n          printUsage();\n          return -1;\n        }\n      } else {\n        System.err.println(\"fsck: Illegal option \u0027\" + args[idx] + \"\u0027\");\n        printUsage();\n        return -1;\n      }\n    }\n    if (null \u003d\u003d dir) {\n      dir \u003d \"/\";\n    }\n    url.append(\"\u0026path\u003d\").append(URLEncoder.encode(dir, \"UTF-8\"));\n    if (doListCorruptFileBlocks) {\n      return listCorruptFileBlocks(dir, url.toString());\n    }\n    URL path \u003d new URL(url.toString());\n    SecurityUtil.fetchServiceTicket(path);\n    URLConnection connection \u003d path.openConnection();\n    InputStream stream \u003d connection.getInputStream();\n    BufferedReader input \u003d new BufferedReader(new InputStreamReader(\n                                              stream, \"UTF-8\"));\n    String line \u003d null;\n    String lastLine \u003d null;\n    int errCode \u003d -1;\n    try {\n      while ((line \u003d input.readLine()) !\u003d null) {\n        out.println(line);\n        lastLine \u003d line;\n      }\n    } finally {\n      input.close();\n    }\n    if (lastLine.endsWith(NamenodeFsck.HEALTHY_STATUS)) {\n      errCode \u003d 0;\n    } else if (lastLine.endsWith(NamenodeFsck.CORRUPT_STATUS)) {\n      errCode \u003d 1;\n    } else if (lastLine.endsWith(NamenodeFsck.NONEXISTENT_STATUS)) {\n      errCode \u003d 0;\n    }\n    return errCode;\n  }",
      "path": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DFSck.java",
      "extendedDetails": {
        "oldPath": "hdfs/src/java/org/apache/hadoop/hdfs/tools/DFSck.java",
        "newPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/DFSck.java"
      }
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "diff": "@@ -0,0 +1,80 @@\n+  private int doWork(final String[] args) throws IOException {\n+    String proto \u003d \"http://\";\n+    if (UserGroupInformation.isSecurityEnabled()) {\n+      System.setProperty(\"https.cipherSuites\",\n+          Krb5AndCertsSslSocketConnector.KRB5_CIPHER_SUITES.get(0));\n+      proto \u003d \"https://\";\n+    }\n+    final StringBuilder url \u003d new StringBuilder(proto);\n+    \n+    String namenodeAddress \u003d getCurrentNamenodeAddress();\n+    if (namenodeAddress \u003d\u003d null) {\n+      //Error message already output in {@link #getCurrentNamenodeAddress()}\n+      System.err.println(\"DFSck exiting.\");\n+      return 0;\n+    }\n+    url.append(namenodeAddress);\n+    System.err.println(\"Connecting to namenode via \" + url.toString());\n+    \n+    url.append(\"/fsck?ugi\u003d\").append(ugi.getShortUserName());\n+    String dir \u003d null;\n+    boolean doListCorruptFileBlocks \u003d false;\n+    for (int idx \u003d 0; idx \u003c args.length; idx++) {\n+      if (args[idx].equals(\"-move\")) { url.append(\"\u0026move\u003d1\"); }\n+      else if (args[idx].equals(\"-delete\")) { url.append(\"\u0026delete\u003d1\"); }\n+      else if (args[idx].equals(\"-files\")) { url.append(\"\u0026files\u003d1\"); }\n+      else if (args[idx].equals(\"-openforwrite\")) { url.append(\"\u0026openforwrite\u003d1\"); }\n+      else if (args[idx].equals(\"-blocks\")) { url.append(\"\u0026blocks\u003d1\"); }\n+      else if (args[idx].equals(\"-locations\")) { url.append(\"\u0026locations\u003d1\"); }\n+      else if (args[idx].equals(\"-racks\")) { url.append(\"\u0026racks\u003d1\"); }\n+      else if (args[idx].equals(\"-list-corruptfileblocks\")) {\n+        url.append(\"\u0026listcorruptfileblocks\u003d1\");\n+        doListCorruptFileBlocks \u003d true;\n+      } else if (!args[idx].startsWith(\"-\")) {\n+        if (null \u003d\u003d dir) {\n+          dir \u003d args[idx];\n+        } else {\n+          System.err.println(\"fsck: can only operate on one path at a time \u0027\"\n+              + args[idx] + \"\u0027\");\n+          printUsage();\n+          return -1;\n+        }\n+      } else {\n+        System.err.println(\"fsck: Illegal option \u0027\" + args[idx] + \"\u0027\");\n+        printUsage();\n+        return -1;\n+      }\n+    }\n+    if (null \u003d\u003d dir) {\n+      dir \u003d \"/\";\n+    }\n+    url.append(\"\u0026path\u003d\").append(URLEncoder.encode(dir, \"UTF-8\"));\n+    if (doListCorruptFileBlocks) {\n+      return listCorruptFileBlocks(dir, url.toString());\n+    }\n+    URL path \u003d new URL(url.toString());\n+    SecurityUtil.fetchServiceTicket(path);\n+    URLConnection connection \u003d path.openConnection();\n+    InputStream stream \u003d connection.getInputStream();\n+    BufferedReader input \u003d new BufferedReader(new InputStreamReader(\n+                                              stream, \"UTF-8\"));\n+    String line \u003d null;\n+    String lastLine \u003d null;\n+    int errCode \u003d -1;\n+    try {\n+      while ((line \u003d input.readLine()) !\u003d null) {\n+        out.println(line);\n+        lastLine \u003d line;\n+      }\n+    } finally {\n+      input.close();\n+    }\n+    if (lastLine.endsWith(NamenodeFsck.HEALTHY_STATUS)) {\n+      errCode \u003d 0;\n+    } else if (lastLine.endsWith(NamenodeFsck.CORRUPT_STATUS)) {\n+      errCode \u003d 1;\n+    } else if (lastLine.endsWith(NamenodeFsck.NONEXISTENT_STATUS)) {\n+      errCode \u003d 0;\n+    }\n+    return errCode;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private int doWork(final String[] args) throws IOException {\n    String proto \u003d \"http://\";\n    if (UserGroupInformation.isSecurityEnabled()) {\n      System.setProperty(\"https.cipherSuites\",\n          Krb5AndCertsSslSocketConnector.KRB5_CIPHER_SUITES.get(0));\n      proto \u003d \"https://\";\n    }\n    final StringBuilder url \u003d new StringBuilder(proto);\n    \n    String namenodeAddress \u003d getCurrentNamenodeAddress();\n    if (namenodeAddress \u003d\u003d null) {\n      //Error message already output in {@link #getCurrentNamenodeAddress()}\n      System.err.println(\"DFSck exiting.\");\n      return 0;\n    }\n    url.append(namenodeAddress);\n    System.err.println(\"Connecting to namenode via \" + url.toString());\n    \n    url.append(\"/fsck?ugi\u003d\").append(ugi.getShortUserName());\n    String dir \u003d null;\n    boolean doListCorruptFileBlocks \u003d false;\n    for (int idx \u003d 0; idx \u003c args.length; idx++) {\n      if (args[idx].equals(\"-move\")) { url.append(\"\u0026move\u003d1\"); }\n      else if (args[idx].equals(\"-delete\")) { url.append(\"\u0026delete\u003d1\"); }\n      else if (args[idx].equals(\"-files\")) { url.append(\"\u0026files\u003d1\"); }\n      else if (args[idx].equals(\"-openforwrite\")) { url.append(\"\u0026openforwrite\u003d1\"); }\n      else if (args[idx].equals(\"-blocks\")) { url.append(\"\u0026blocks\u003d1\"); }\n      else if (args[idx].equals(\"-locations\")) { url.append(\"\u0026locations\u003d1\"); }\n      else if (args[idx].equals(\"-racks\")) { url.append(\"\u0026racks\u003d1\"); }\n      else if (args[idx].equals(\"-list-corruptfileblocks\")) {\n        url.append(\"\u0026listcorruptfileblocks\u003d1\");\n        doListCorruptFileBlocks \u003d true;\n      } else if (!args[idx].startsWith(\"-\")) {\n        if (null \u003d\u003d dir) {\n          dir \u003d args[idx];\n        } else {\n          System.err.println(\"fsck: can only operate on one path at a time \u0027\"\n              + args[idx] + \"\u0027\");\n          printUsage();\n          return -1;\n        }\n      } else {\n        System.err.println(\"fsck: Illegal option \u0027\" + args[idx] + \"\u0027\");\n        printUsage();\n        return -1;\n      }\n    }\n    if (null \u003d\u003d dir) {\n      dir \u003d \"/\";\n    }\n    url.append(\"\u0026path\u003d\").append(URLEncoder.encode(dir, \"UTF-8\"));\n    if (doListCorruptFileBlocks) {\n      return listCorruptFileBlocks(dir, url.toString());\n    }\n    URL path \u003d new URL(url.toString());\n    SecurityUtil.fetchServiceTicket(path);\n    URLConnection connection \u003d path.openConnection();\n    InputStream stream \u003d connection.getInputStream();\n    BufferedReader input \u003d new BufferedReader(new InputStreamReader(\n                                              stream, \"UTF-8\"));\n    String line \u003d null;\n    String lastLine \u003d null;\n    int errCode \u003d -1;\n    try {\n      while ((line \u003d input.readLine()) !\u003d null) {\n        out.println(line);\n        lastLine \u003d line;\n      }\n    } finally {\n      input.close();\n    }\n    if (lastLine.endsWith(NamenodeFsck.HEALTHY_STATUS)) {\n      errCode \u003d 0;\n    } else if (lastLine.endsWith(NamenodeFsck.CORRUPT_STATUS)) {\n      errCode \u003d 1;\n    } else if (lastLine.endsWith(NamenodeFsck.NONEXISTENT_STATUS)) {\n      errCode \u003d 0;\n    }\n    return errCode;\n  }",
      "path": "hdfs/src/java/org/apache/hadoop/hdfs/tools/DFSck.java"
    }
  }
}