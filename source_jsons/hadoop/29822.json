{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "InMemorySCMStore.java",
  "functionName": "getInitialCachedResources",
  "functionId": "getInitialCachedResources___fs-FileSystem__conf-Configuration",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-sharedcachemanager/src/main/java/org/apache/hadoop/yarn/server/sharedcachemanager/store/InMemorySCMStore.java",
  "functionStartLine": 187,
  "functionEndLine": 243,
  "numCommitsSeen": 6,
  "timeTaken": 1135,
  "changeHistory": [
    "5af572b6443715b7a741296c1bd520a1840f9a7c",
    "c51e53d7aad46059f52d4046a5fedfdfd3c37955",
    "4f426fe2232ed90d8fdf8619fbdeae28d788b5c8"
  ],
  "changeHistoryShort": {
    "5af572b6443715b7a741296c1bd520a1840f9a7c": "Ybodychange",
    "c51e53d7aad46059f52d4046a5fedfdfd3c37955": "Ybodychange",
    "4f426fe2232ed90d8fdf8619fbdeae28d788b5c8": "Yintroduced"
  },
  "changeHistoryDetails": {
    "5af572b6443715b7a741296c1bd520a1840f9a7c": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13427. Eliminate needless uses of FileSystem#{exists(), isFile(), isDirectory()}. Contributed by Steve Loughran and Mingliang Liu\n",
      "commitDate": "15/11/16 10:57 AM",
      "commitName": "5af572b6443715b7a741296c1bd520a1840f9a7c",
      "commitAuthor": "Mingliang Liu",
      "commitDateOld": "10/02/16 10:36 PM",
      "commitNameOld": "fa00d3e20560bee412b49e5792595749a247a8ab",
      "commitAuthorOld": "Varun Vasudev",
      "daysBetweenCommits": 278.51,
      "commitsBetweenForRepo": 2024,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,57 @@\n   Map\u003cString, String\u003e getInitialCachedResources(FileSystem fs,\n       Configuration conf) throws IOException {\n     // get the root directory for the shared cache\n     String location \u003d\n         conf.get(YarnConfiguration.SHARED_CACHE_ROOT,\n             YarnConfiguration.DEFAULT_SHARED_CACHE_ROOT);\n     Path root \u003d new Path(location);\n-    if (!fs.exists(root)) {\n+    try {\n+      fs.getFileStatus(root);\n+    } catch (FileNotFoundException e) {\n       String message \u003d\n           \"The shared cache root directory \" + location + \" was not found\";\n       LOG.error(message);\n-      throw new IOException(message);\n+      throw (IOException)new FileNotFoundException(message)\n+          .initCause(e);\n     }\n \n     int nestedLevel \u003d SharedCacheUtil.getCacheDepth(conf);\n     // now traverse individual directories and process them\n     // the directory structure is specified by the nested level parameter\n     // (e.g. 9/c/d/\u003cchecksum\u003e/file)\n     String pattern \u003d SharedCacheUtil.getCacheEntryGlobPattern(nestedLevel+1);\n \n     LOG.info(\"Querying for all individual cached resource files\");\n     FileStatus[] entries \u003d fs.globStatus(new Path(root, pattern));\n     int numEntries \u003d entries \u003d\u003d null ? 0 : entries.length;\n     LOG.info(\"Found \" + numEntries + \" files: processing for one resource per \"\n         + \"key\");\n \n     Map\u003cString, String\u003e initialCachedEntries \u003d new HashMap\u003cString, String\u003e();\n     if (entries !\u003d null) {\n       for (FileStatus entry : entries) {\n         Path file \u003d entry.getPath();\n         String fileName \u003d file.getName();\n         if (entry.isFile()) {\n           // get the parent to get the checksum\n           Path parent \u003d file.getParent();\n           if (parent !\u003d null) {\n             // the name of the immediate parent directory is the checksum\n             String key \u003d parent.getName();\n             // make sure we insert only one file per checksum whichever comes\n             // first\n             if (initialCachedEntries.containsKey(key)) {\n               LOG.warn(\"Key \" + key + \" is already mapped to file \"\n                   + initialCachedEntries.get(key) + \"; file \" + fileName\n                   + \" will not be added\");\n             } else {\n               initialCachedEntries.put(key, fileName);\n             }\n           }\n         }\n       }\n     }\n     LOG.info(\"A total of \" + initialCachedEntries.size()\n         + \" files are now mapped\");\n     return initialCachedEntries;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  Map\u003cString, String\u003e getInitialCachedResources(FileSystem fs,\n      Configuration conf) throws IOException {\n    // get the root directory for the shared cache\n    String location \u003d\n        conf.get(YarnConfiguration.SHARED_CACHE_ROOT,\n            YarnConfiguration.DEFAULT_SHARED_CACHE_ROOT);\n    Path root \u003d new Path(location);\n    try {\n      fs.getFileStatus(root);\n    } catch (FileNotFoundException e) {\n      String message \u003d\n          \"The shared cache root directory \" + location + \" was not found\";\n      LOG.error(message);\n      throw (IOException)new FileNotFoundException(message)\n          .initCause(e);\n    }\n\n    int nestedLevel \u003d SharedCacheUtil.getCacheDepth(conf);\n    // now traverse individual directories and process them\n    // the directory structure is specified by the nested level parameter\n    // (e.g. 9/c/d/\u003cchecksum\u003e/file)\n    String pattern \u003d SharedCacheUtil.getCacheEntryGlobPattern(nestedLevel+1);\n\n    LOG.info(\"Querying for all individual cached resource files\");\n    FileStatus[] entries \u003d fs.globStatus(new Path(root, pattern));\n    int numEntries \u003d entries \u003d\u003d null ? 0 : entries.length;\n    LOG.info(\"Found \" + numEntries + \" files: processing for one resource per \"\n        + \"key\");\n\n    Map\u003cString, String\u003e initialCachedEntries \u003d new HashMap\u003cString, String\u003e();\n    if (entries !\u003d null) {\n      for (FileStatus entry : entries) {\n        Path file \u003d entry.getPath();\n        String fileName \u003d file.getName();\n        if (entry.isFile()) {\n          // get the parent to get the checksum\n          Path parent \u003d file.getParent();\n          if (parent !\u003d null) {\n            // the name of the immediate parent directory is the checksum\n            String key \u003d parent.getName();\n            // make sure we insert only one file per checksum whichever comes\n            // first\n            if (initialCachedEntries.containsKey(key)) {\n              LOG.warn(\"Key \" + key + \" is already mapped to file \"\n                  + initialCachedEntries.get(key) + \"; file \" + fileName\n                  + \" will not be added\");\n            } else {\n              initialCachedEntries.put(key, fileName);\n            }\n          }\n        }\n      }\n    }\n    LOG.info(\"A total of \" + initialCachedEntries.size()\n        + \" files are now mapped\");\n    return initialCachedEntries;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-sharedcachemanager/src/main/java/org/apache/hadoop/yarn/server/sharedcachemanager/store/InMemorySCMStore.java",
      "extendedDetails": {}
    },
    "c51e53d7aad46059f52d4046a5fedfdfd3c37955": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2183. [YARN-1492] Cleaner service for cache manager. (Chris Trezzo and Sangjin Lee via kasha)\n",
      "commitDate": "25/10/14 10:31 AM",
      "commitName": "c51e53d7aad46059f52d4046a5fedfdfd3c37955",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "09/10/14 5:16 PM",
      "commitNameOld": "4f426fe2232ed90d8fdf8619fbdeae28d788b5c8",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 15.72,
      "commitsBetweenForRepo": 124,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,58 +1,54 @@\n   Map\u003cString, String\u003e getInitialCachedResources(FileSystem fs,\n       Configuration conf) throws IOException {\n     // get the root directory for the shared cache\n     String location \u003d\n         conf.get(YarnConfiguration.SHARED_CACHE_ROOT,\n             YarnConfiguration.DEFAULT_SHARED_CACHE_ROOT);\n     Path root \u003d new Path(location);\n     if (!fs.exists(root)) {\n       String message \u003d\n           \"The shared cache root directory \" + location + \" was not found\";\n       LOG.error(message);\n       throw new IOException(message);\n     }\n \n     int nestedLevel \u003d SharedCacheUtil.getCacheDepth(conf);\n     // now traverse individual directories and process them\n     // the directory structure is specified by the nested level parameter\n     // (e.g. 9/c/d/\u003cchecksum\u003e/file)\n-    StringBuilder pattern \u003d new StringBuilder();\n-    for (int i \u003d 0; i \u003c nestedLevel + 1; i++) {\n-      pattern.append(\"*/\");\n-    }\n-    pattern.append(\"*\");\n+    String pattern \u003d SharedCacheUtil.getCacheEntryGlobPattern(nestedLevel+1);\n \n     LOG.info(\"Querying for all individual cached resource files\");\n-    FileStatus[] entries \u003d fs.globStatus(new Path(root, pattern.toString()));\n+    FileStatus[] entries \u003d fs.globStatus(new Path(root, pattern));\n     int numEntries \u003d entries \u003d\u003d null ? 0 : entries.length;\n     LOG.info(\"Found \" + numEntries + \" files: processing for one resource per \"\n         + \"key\");\n \n     Map\u003cString, String\u003e initialCachedEntries \u003d new HashMap\u003cString, String\u003e();\n     if (entries !\u003d null) {\n       for (FileStatus entry : entries) {\n         Path file \u003d entry.getPath();\n         String fileName \u003d file.getName();\n         if (entry.isFile()) {\n           // get the parent to get the checksum\n           Path parent \u003d file.getParent();\n           if (parent !\u003d null) {\n             // the name of the immediate parent directory is the checksum\n             String key \u003d parent.getName();\n             // make sure we insert only one file per checksum whichever comes\n             // first\n             if (initialCachedEntries.containsKey(key)) {\n               LOG.warn(\"Key \" + key + \" is already mapped to file \"\n                   + initialCachedEntries.get(key) + \"; file \" + fileName\n                   + \" will not be added\");\n             } else {\n               initialCachedEntries.put(key, fileName);\n             }\n           }\n         }\n       }\n     }\n     LOG.info(\"A total of \" + initialCachedEntries.size()\n         + \" files are now mapped\");\n     return initialCachedEntries;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  Map\u003cString, String\u003e getInitialCachedResources(FileSystem fs,\n      Configuration conf) throws IOException {\n    // get the root directory for the shared cache\n    String location \u003d\n        conf.get(YarnConfiguration.SHARED_CACHE_ROOT,\n            YarnConfiguration.DEFAULT_SHARED_CACHE_ROOT);\n    Path root \u003d new Path(location);\n    if (!fs.exists(root)) {\n      String message \u003d\n          \"The shared cache root directory \" + location + \" was not found\";\n      LOG.error(message);\n      throw new IOException(message);\n    }\n\n    int nestedLevel \u003d SharedCacheUtil.getCacheDepth(conf);\n    // now traverse individual directories and process them\n    // the directory structure is specified by the nested level parameter\n    // (e.g. 9/c/d/\u003cchecksum\u003e/file)\n    String pattern \u003d SharedCacheUtil.getCacheEntryGlobPattern(nestedLevel+1);\n\n    LOG.info(\"Querying for all individual cached resource files\");\n    FileStatus[] entries \u003d fs.globStatus(new Path(root, pattern));\n    int numEntries \u003d entries \u003d\u003d null ? 0 : entries.length;\n    LOG.info(\"Found \" + numEntries + \" files: processing for one resource per \"\n        + \"key\");\n\n    Map\u003cString, String\u003e initialCachedEntries \u003d new HashMap\u003cString, String\u003e();\n    if (entries !\u003d null) {\n      for (FileStatus entry : entries) {\n        Path file \u003d entry.getPath();\n        String fileName \u003d file.getName();\n        if (entry.isFile()) {\n          // get the parent to get the checksum\n          Path parent \u003d file.getParent();\n          if (parent !\u003d null) {\n            // the name of the immediate parent directory is the checksum\n            String key \u003d parent.getName();\n            // make sure we insert only one file per checksum whichever comes\n            // first\n            if (initialCachedEntries.containsKey(key)) {\n              LOG.warn(\"Key \" + key + \" is already mapped to file \"\n                  + initialCachedEntries.get(key) + \"; file \" + fileName\n                  + \" will not be added\");\n            } else {\n              initialCachedEntries.put(key, fileName);\n            }\n          }\n        }\n      }\n    }\n    LOG.info(\"A total of \" + initialCachedEntries.size()\n        + \" files are now mapped\");\n    return initialCachedEntries;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-sharedcachemanager/src/main/java/org/apache/hadoop/yarn/server/sharedcachemanager/store/InMemorySCMStore.java",
      "extendedDetails": {}
    },
    "4f426fe2232ed90d8fdf8619fbdeae28d788b5c8": {
      "type": "Yintroduced",
      "commitMessage": "YARN-2180. [YARN-1492] In-memory backing store for cache manager. (Chris Trezzo via kasha)\n",
      "commitDate": "09/10/14 5:16 PM",
      "commitName": "4f426fe2232ed90d8fdf8619fbdeae28d788b5c8",
      "commitAuthor": "Karthik Kambatla",
      "diff": "@@ -0,0 +1,58 @@\n+  Map\u003cString, String\u003e getInitialCachedResources(FileSystem fs,\n+      Configuration conf) throws IOException {\n+    // get the root directory for the shared cache\n+    String location \u003d\n+        conf.get(YarnConfiguration.SHARED_CACHE_ROOT,\n+            YarnConfiguration.DEFAULT_SHARED_CACHE_ROOT);\n+    Path root \u003d new Path(location);\n+    if (!fs.exists(root)) {\n+      String message \u003d\n+          \"The shared cache root directory \" + location + \" was not found\";\n+      LOG.error(message);\n+      throw new IOException(message);\n+    }\n+\n+    int nestedLevel \u003d SharedCacheUtil.getCacheDepth(conf);\n+    // now traverse individual directories and process them\n+    // the directory structure is specified by the nested level parameter\n+    // (e.g. 9/c/d/\u003cchecksum\u003e/file)\n+    StringBuilder pattern \u003d new StringBuilder();\n+    for (int i \u003d 0; i \u003c nestedLevel + 1; i++) {\n+      pattern.append(\"*/\");\n+    }\n+    pattern.append(\"*\");\n+\n+    LOG.info(\"Querying for all individual cached resource files\");\n+    FileStatus[] entries \u003d fs.globStatus(new Path(root, pattern.toString()));\n+    int numEntries \u003d entries \u003d\u003d null ? 0 : entries.length;\n+    LOG.info(\"Found \" + numEntries + \" files: processing for one resource per \"\n+        + \"key\");\n+\n+    Map\u003cString, String\u003e initialCachedEntries \u003d new HashMap\u003cString, String\u003e();\n+    if (entries !\u003d null) {\n+      for (FileStatus entry : entries) {\n+        Path file \u003d entry.getPath();\n+        String fileName \u003d file.getName();\n+        if (entry.isFile()) {\n+          // get the parent to get the checksum\n+          Path parent \u003d file.getParent();\n+          if (parent !\u003d null) {\n+            // the name of the immediate parent directory is the checksum\n+            String key \u003d parent.getName();\n+            // make sure we insert only one file per checksum whichever comes\n+            // first\n+            if (initialCachedEntries.containsKey(key)) {\n+              LOG.warn(\"Key \" + key + \" is already mapped to file \"\n+                  + initialCachedEntries.get(key) + \"; file \" + fileName\n+                  + \" will not be added\");\n+            } else {\n+              initialCachedEntries.put(key, fileName);\n+            }\n+          }\n+        }\n+      }\n+    }\n+    LOG.info(\"A total of \" + initialCachedEntries.size()\n+        + \" files are now mapped\");\n+    return initialCachedEntries;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  Map\u003cString, String\u003e getInitialCachedResources(FileSystem fs,\n      Configuration conf) throws IOException {\n    // get the root directory for the shared cache\n    String location \u003d\n        conf.get(YarnConfiguration.SHARED_CACHE_ROOT,\n            YarnConfiguration.DEFAULT_SHARED_CACHE_ROOT);\n    Path root \u003d new Path(location);\n    if (!fs.exists(root)) {\n      String message \u003d\n          \"The shared cache root directory \" + location + \" was not found\";\n      LOG.error(message);\n      throw new IOException(message);\n    }\n\n    int nestedLevel \u003d SharedCacheUtil.getCacheDepth(conf);\n    // now traverse individual directories and process them\n    // the directory structure is specified by the nested level parameter\n    // (e.g. 9/c/d/\u003cchecksum\u003e/file)\n    StringBuilder pattern \u003d new StringBuilder();\n    for (int i \u003d 0; i \u003c nestedLevel + 1; i++) {\n      pattern.append(\"*/\");\n    }\n    pattern.append(\"*\");\n\n    LOG.info(\"Querying for all individual cached resource files\");\n    FileStatus[] entries \u003d fs.globStatus(new Path(root, pattern.toString()));\n    int numEntries \u003d entries \u003d\u003d null ? 0 : entries.length;\n    LOG.info(\"Found \" + numEntries + \" files: processing for one resource per \"\n        + \"key\");\n\n    Map\u003cString, String\u003e initialCachedEntries \u003d new HashMap\u003cString, String\u003e();\n    if (entries !\u003d null) {\n      for (FileStatus entry : entries) {\n        Path file \u003d entry.getPath();\n        String fileName \u003d file.getName();\n        if (entry.isFile()) {\n          // get the parent to get the checksum\n          Path parent \u003d file.getParent();\n          if (parent !\u003d null) {\n            // the name of the immediate parent directory is the checksum\n            String key \u003d parent.getName();\n            // make sure we insert only one file per checksum whichever comes\n            // first\n            if (initialCachedEntries.containsKey(key)) {\n              LOG.warn(\"Key \" + key + \" is already mapped to file \"\n                  + initialCachedEntries.get(key) + \"; file \" + fileName\n                  + \" will not be added\");\n            } else {\n              initialCachedEntries.put(key, fileName);\n            }\n          }\n        }\n      }\n    }\n    LOG.info(\"A total of \" + initialCachedEntries.size()\n        + \" files are now mapped\");\n    return initialCachedEntries;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-sharedcachemanager/src/main/java/org/apache/hadoop/yarn/server/sharedcachemanager/store/InMemorySCMStore.java"
    }
  }
}