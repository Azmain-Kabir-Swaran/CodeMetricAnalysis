{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "MountTable.java",
  "functionName": "newInstance",
  "functionId": "newInstance___src-String(modifiers-final)__destinations-Map__String,String__(modifiers-final)",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/store/records/MountTable.java",
  "functionStartLine": 130,
  "functionEndLine": 169,
  "numCommitsSeen": 17,
  "timeTaken": 6261,
  "changeHistory": [
    "17a87977f29ced49724f561a68565217c8cb4e94",
    "0c93d43f3d624a4fd17b3b050443d9e7e20d4f0a",
    "6e2b5fa493ff8e8c2bb28e6f6f4c19347bc9b99d",
    "9afb8025d6549f0ade0ae7d36f5e67cd20c500f4",
    "d98a2e6e2383f8b66def346409b0517aa32d298d",
    "ee028bfdf1c88a27cd925bed93ebb599a164dd2e",
    "6f0de2731806628b5b01bd1350225692147590da",
    "2761bbc91a7b0a36c42b1b6569c5ecd4f236281b"
  ],
  "changeHistoryShort": {
    "17a87977f29ced49724f561a68565217c8cb4e94": "Ybodychange",
    "0c93d43f3d624a4fd17b3b050443d9e7e20d4f0a": "Ybodychange",
    "6e2b5fa493ff8e8c2bb28e6f6f4c19347bc9b99d": "Yfilerename",
    "9afb8025d6549f0ade0ae7d36f5e67cd20c500f4": "Ybodychange",
    "d98a2e6e2383f8b66def346409b0517aa32d298d": "Ybodychange",
    "ee028bfdf1c88a27cd925bed93ebb599a164dd2e": "Ybodychange",
    "6f0de2731806628b5b01bd1350225692147590da": "Ymultichange(Ymovefromfile,Yreturntypechange,Ymodifierchange,Yexceptionschange,Ybodychange,Yparameterchange)",
    "2761bbc91a7b0a36c42b1b6569c5ecd4f236281b": "Yintroduced"
  },
  "changeHistoryDetails": {
    "17a87977f29ced49724f561a68565217c8cb4e94": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13583. RBF: Router admin clrQuota is not synchronized with nameservice. Contributed by Dibyendu Karmakar.\n",
      "commitDate": "23/07/18 8:15 PM",
      "commitName": "17a87977f29ced49724f561a68565217c8cb4e94",
      "commitAuthor": "Yiqun Lin",
      "commitDateOld": "18/06/18 10:17 AM",
      "commitNameOld": "fba9d7cd746cd7b659d2fd9d2bfa23266be9009b",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 35.42,
      "commitsBetweenForRepo": 200,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,40 @@\n   public static MountTable newInstance(final String src,\n       final Map\u003cString, String\u003e destinations) throws IOException {\n     MountTable record \u003d newInstance();\n \n     // Normalize the mount path\n     record.setSourcePath(normalizeFileSystemPath(src));\n \n     // Build a list of remote locations\n     final List\u003cRemoteLocation\u003e locations \u003d new LinkedList\u003c\u003e();\n     for (Entry\u003cString, String\u003e entry : destinations.entrySet()) {\n       String nsId \u003d entry.getKey();\n       String path \u003d normalizeFileSystemPath(entry.getValue());\n       RemoteLocation location \u003d new RemoteLocation(nsId, path, src);\n       locations.add(location);\n     }\n \n     // Set the serialized dest string\n     record.setDestinations(locations);\n \n     // Set permission fields\n     UserGroupInformation ugi \u003d NameNode.getRemoteUser();\n     record.setOwnerName(ugi.getShortUserName());\n     String group \u003d ugi.getGroups().isEmpty() ? ugi.getShortUserName()\n         : ugi.getPrimaryGroupName();\n     record.setGroupName(group);\n     record.setMode(new FsPermission(\n         RouterPermissionChecker.MOUNT_TABLE_PERMISSION_DEFAULT));\n \n     // Set quota for mount table\n     RouterQuotaUsage quota \u003d new RouterQuotaUsage.Builder()\n         .fileAndDirectoryCount(RouterQuotaUsage.QUOTA_USAGE_COUNT_DEFAULT)\n-        .quota(HdfsConstants.QUOTA_DONT_SET)\n+        .quota(HdfsConstants.QUOTA_RESET)\n         .spaceConsumed(RouterQuotaUsage.QUOTA_USAGE_COUNT_DEFAULT)\n-        .spaceQuota(HdfsConstants.QUOTA_DONT_SET).build();\n+        .spaceQuota(HdfsConstants.QUOTA_RESET).build();\n     record.setQuota(quota);\n \n     // Validate\n     record.validate();\n     return record;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static MountTable newInstance(final String src,\n      final Map\u003cString, String\u003e destinations) throws IOException {\n    MountTable record \u003d newInstance();\n\n    // Normalize the mount path\n    record.setSourcePath(normalizeFileSystemPath(src));\n\n    // Build a list of remote locations\n    final List\u003cRemoteLocation\u003e locations \u003d new LinkedList\u003c\u003e();\n    for (Entry\u003cString, String\u003e entry : destinations.entrySet()) {\n      String nsId \u003d entry.getKey();\n      String path \u003d normalizeFileSystemPath(entry.getValue());\n      RemoteLocation location \u003d new RemoteLocation(nsId, path, src);\n      locations.add(location);\n    }\n\n    // Set the serialized dest string\n    record.setDestinations(locations);\n\n    // Set permission fields\n    UserGroupInformation ugi \u003d NameNode.getRemoteUser();\n    record.setOwnerName(ugi.getShortUserName());\n    String group \u003d ugi.getGroups().isEmpty() ? ugi.getShortUserName()\n        : ugi.getPrimaryGroupName();\n    record.setGroupName(group);\n    record.setMode(new FsPermission(\n        RouterPermissionChecker.MOUNT_TABLE_PERMISSION_DEFAULT));\n\n    // Set quota for mount table\n    RouterQuotaUsage quota \u003d new RouterQuotaUsage.Builder()\n        .fileAndDirectoryCount(RouterQuotaUsage.QUOTA_USAGE_COUNT_DEFAULT)\n        .quota(HdfsConstants.QUOTA_RESET)\n        .spaceConsumed(RouterQuotaUsage.QUOTA_USAGE_COUNT_DEFAULT)\n        .spaceQuota(HdfsConstants.QUOTA_RESET).build();\n    record.setQuota(quota);\n\n    // Validate\n    record.validate();\n    return record;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/store/records/MountTable.java",
      "extendedDetails": {}
    },
    "0c93d43f3d624a4fd17b3b050443d9e7e20d4f0a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13045. RBF: Improve error message returned from subcluster. Contributed by Inigo Goiri.\n",
      "commitDate": "11/04/18 8:37 AM",
      "commitName": "0c93d43f3d624a4fd17b3b050443d9e7e20d4f0a",
      "commitAuthor": "Wei Yan",
      "commitDateOld": "26/03/18 3:33 AM",
      "commitNameOld": "cfc3a1c8f06fba4f4bd5ffe8bb2a6944d066948e",
      "commitAuthorOld": "Yiqun Lin",
      "daysBetweenCommits": 16.21,
      "commitsBetweenForRepo": 99,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,40 @@\n   public static MountTable newInstance(final String src,\n       final Map\u003cString, String\u003e destinations) throws IOException {\n     MountTable record \u003d newInstance();\n \n     // Normalize the mount path\n     record.setSourcePath(normalizeFileSystemPath(src));\n \n     // Build a list of remote locations\n     final List\u003cRemoteLocation\u003e locations \u003d new LinkedList\u003c\u003e();\n     for (Entry\u003cString, String\u003e entry : destinations.entrySet()) {\n       String nsId \u003d entry.getKey();\n       String path \u003d normalizeFileSystemPath(entry.getValue());\n-      RemoteLocation location \u003d new RemoteLocation(nsId, path);\n+      RemoteLocation location \u003d new RemoteLocation(nsId, path, src);\n       locations.add(location);\n     }\n \n     // Set the serialized dest string\n     record.setDestinations(locations);\n \n     // Set permission fields\n     UserGroupInformation ugi \u003d NameNode.getRemoteUser();\n     record.setOwnerName(ugi.getShortUserName());\n     String group \u003d ugi.getGroups().isEmpty() ? ugi.getShortUserName()\n         : ugi.getPrimaryGroupName();\n     record.setGroupName(group);\n     record.setMode(new FsPermission(\n         RouterPermissionChecker.MOUNT_TABLE_PERMISSION_DEFAULT));\n \n     // Set quota for mount table\n     RouterQuotaUsage quota \u003d new RouterQuotaUsage.Builder()\n         .fileAndDirectoryCount(RouterQuotaUsage.QUOTA_USAGE_COUNT_DEFAULT)\n         .quota(HdfsConstants.QUOTA_DONT_SET)\n         .spaceConsumed(RouterQuotaUsage.QUOTA_USAGE_COUNT_DEFAULT)\n         .spaceQuota(HdfsConstants.QUOTA_DONT_SET).build();\n     record.setQuota(quota);\n \n     // Validate\n     record.validate();\n     return record;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static MountTable newInstance(final String src,\n      final Map\u003cString, String\u003e destinations) throws IOException {\n    MountTable record \u003d newInstance();\n\n    // Normalize the mount path\n    record.setSourcePath(normalizeFileSystemPath(src));\n\n    // Build a list of remote locations\n    final List\u003cRemoteLocation\u003e locations \u003d new LinkedList\u003c\u003e();\n    for (Entry\u003cString, String\u003e entry : destinations.entrySet()) {\n      String nsId \u003d entry.getKey();\n      String path \u003d normalizeFileSystemPath(entry.getValue());\n      RemoteLocation location \u003d new RemoteLocation(nsId, path, src);\n      locations.add(location);\n    }\n\n    // Set the serialized dest string\n    record.setDestinations(locations);\n\n    // Set permission fields\n    UserGroupInformation ugi \u003d NameNode.getRemoteUser();\n    record.setOwnerName(ugi.getShortUserName());\n    String group \u003d ugi.getGroups().isEmpty() ? ugi.getShortUserName()\n        : ugi.getPrimaryGroupName();\n    record.setGroupName(group);\n    record.setMode(new FsPermission(\n        RouterPermissionChecker.MOUNT_TABLE_PERMISSION_DEFAULT));\n\n    // Set quota for mount table\n    RouterQuotaUsage quota \u003d new RouterQuotaUsage.Builder()\n        .fileAndDirectoryCount(RouterQuotaUsage.QUOTA_USAGE_COUNT_DEFAULT)\n        .quota(HdfsConstants.QUOTA_DONT_SET)\n        .spaceConsumed(RouterQuotaUsage.QUOTA_USAGE_COUNT_DEFAULT)\n        .spaceQuota(HdfsConstants.QUOTA_DONT_SET).build();\n    record.setQuota(quota);\n\n    // Validate\n    record.validate();\n    return record;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/store/records/MountTable.java",
      "extendedDetails": {}
    },
    "6e2b5fa493ff8e8c2bb28e6f6f4c19347bc9b99d": {
      "type": "Yfilerename",
      "commitMessage": "HDFS-13215. RBF: Move Router to its own module. Contributed by Wei Yan\n",
      "commitDate": "19/03/18 10:13 PM",
      "commitName": "6e2b5fa493ff8e8c2bb28e6f6f4c19347bc9b99d",
      "commitAuthor": "weiy",
      "commitDateOld": "19/03/18 5:19 PM",
      "commitNameOld": "e65ff1c8be48ef4f04ed96f96ac4caef4974944d",
      "commitAuthorOld": "Inigo Goiri",
      "daysBetweenCommits": 0.2,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public static MountTable newInstance(final String src,\n      final Map\u003cString, String\u003e destinations) throws IOException {\n    MountTable record \u003d newInstance();\n\n    // Normalize the mount path\n    record.setSourcePath(normalizeFileSystemPath(src));\n\n    // Build a list of remote locations\n    final List\u003cRemoteLocation\u003e locations \u003d new LinkedList\u003c\u003e();\n    for (Entry\u003cString, String\u003e entry : destinations.entrySet()) {\n      String nsId \u003d entry.getKey();\n      String path \u003d normalizeFileSystemPath(entry.getValue());\n      RemoteLocation location \u003d new RemoteLocation(nsId, path);\n      locations.add(location);\n    }\n\n    // Set the serialized dest string\n    record.setDestinations(locations);\n\n    // Set permission fields\n    UserGroupInformation ugi \u003d NameNode.getRemoteUser();\n    record.setOwnerName(ugi.getShortUserName());\n    String group \u003d ugi.getGroups().isEmpty() ? ugi.getShortUserName()\n        : ugi.getPrimaryGroupName();\n    record.setGroupName(group);\n    record.setMode(new FsPermission(\n        RouterPermissionChecker.MOUNT_TABLE_PERMISSION_DEFAULT));\n\n    // Set quota for mount table\n    RouterQuotaUsage quota \u003d new RouterQuotaUsage.Builder()\n        .fileAndDirectoryCount(RouterQuotaUsage.QUOTA_USAGE_COUNT_DEFAULT)\n        .quota(HdfsConstants.QUOTA_DONT_SET)\n        .spaceConsumed(RouterQuotaUsage.QUOTA_USAGE_COUNT_DEFAULT)\n        .spaceQuota(HdfsConstants.QUOTA_DONT_SET).build();\n    record.setQuota(quota);\n\n    // Validate\n    record.validate();\n    return record;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/store/records/MountTable.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/federation/store/records/MountTable.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/store/records/MountTable.java"
      }
    },
    "9afb8025d6549f0ade0ae7d36f5e67cd20c500f4": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12972. RBF: Display mount table quota info in Web UI and admin command. Contributed by Yiqun Lin.\n",
      "commitDate": "12/01/18 9:16 PM",
      "commitName": "9afb8025d6549f0ade0ae7d36f5e67cd20c500f4",
      "commitAuthor": "Yiqun Lin",
      "commitDateOld": "09/01/18 9:59 PM",
      "commitNameOld": "d98a2e6e2383f8b66def346409b0517aa32d298d",
      "commitAuthorOld": "Yiqun Lin",
      "daysBetweenCommits": 2.97,
      "commitsBetweenForRepo": 18,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,40 @@\n   public static MountTable newInstance(final String src,\n       final Map\u003cString, String\u003e destinations) throws IOException {\n     MountTable record \u003d newInstance();\n \n     // Normalize the mount path\n     record.setSourcePath(normalizeFileSystemPath(src));\n \n     // Build a list of remote locations\n     final List\u003cRemoteLocation\u003e locations \u003d new LinkedList\u003c\u003e();\n     for (Entry\u003cString, String\u003e entry : destinations.entrySet()) {\n       String nsId \u003d entry.getKey();\n       String path \u003d normalizeFileSystemPath(entry.getValue());\n       RemoteLocation location \u003d new RemoteLocation(nsId, path);\n       locations.add(location);\n     }\n \n     // Set the serialized dest string\n     record.setDestinations(locations);\n \n     // Set permission fields\n     UserGroupInformation ugi \u003d NameNode.getRemoteUser();\n     record.setOwnerName(ugi.getShortUserName());\n     String group \u003d ugi.getGroups().isEmpty() ? ugi.getShortUserName()\n         : ugi.getPrimaryGroupName();\n     record.setGroupName(group);\n     record.setMode(new FsPermission(\n         RouterPermissionChecker.MOUNT_TABLE_PERMISSION_DEFAULT));\n \n     // Set quota for mount table\n     RouterQuotaUsage quota \u003d new RouterQuotaUsage.Builder()\n-        .fileAndDirectoryCount(0).quota(HdfsConstants.QUOTA_DONT_SET)\n-        .spaceConsumed(0).spaceQuota(HdfsConstants.QUOTA_DONT_SET).build();\n+        .fileAndDirectoryCount(RouterQuotaUsage.QUOTA_USAGE_COUNT_DEFAULT)\n+        .quota(HdfsConstants.QUOTA_DONT_SET)\n+        .spaceConsumed(RouterQuotaUsage.QUOTA_USAGE_COUNT_DEFAULT)\n+        .spaceQuota(HdfsConstants.QUOTA_DONT_SET).build();\n     record.setQuota(quota);\n \n     // Validate\n     record.validate();\n     return record;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static MountTable newInstance(final String src,\n      final Map\u003cString, String\u003e destinations) throws IOException {\n    MountTable record \u003d newInstance();\n\n    // Normalize the mount path\n    record.setSourcePath(normalizeFileSystemPath(src));\n\n    // Build a list of remote locations\n    final List\u003cRemoteLocation\u003e locations \u003d new LinkedList\u003c\u003e();\n    for (Entry\u003cString, String\u003e entry : destinations.entrySet()) {\n      String nsId \u003d entry.getKey();\n      String path \u003d normalizeFileSystemPath(entry.getValue());\n      RemoteLocation location \u003d new RemoteLocation(nsId, path);\n      locations.add(location);\n    }\n\n    // Set the serialized dest string\n    record.setDestinations(locations);\n\n    // Set permission fields\n    UserGroupInformation ugi \u003d NameNode.getRemoteUser();\n    record.setOwnerName(ugi.getShortUserName());\n    String group \u003d ugi.getGroups().isEmpty() ? ugi.getShortUserName()\n        : ugi.getPrimaryGroupName();\n    record.setGroupName(group);\n    record.setMode(new FsPermission(\n        RouterPermissionChecker.MOUNT_TABLE_PERMISSION_DEFAULT));\n\n    // Set quota for mount table\n    RouterQuotaUsage quota \u003d new RouterQuotaUsage.Builder()\n        .fileAndDirectoryCount(RouterQuotaUsage.QUOTA_USAGE_COUNT_DEFAULT)\n        .quota(HdfsConstants.QUOTA_DONT_SET)\n        .spaceConsumed(RouterQuotaUsage.QUOTA_USAGE_COUNT_DEFAULT)\n        .spaceQuota(HdfsConstants.QUOTA_DONT_SET).build();\n    record.setQuota(quota);\n\n    // Validate\n    record.validate();\n    return record;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/federation/store/records/MountTable.java",
      "extendedDetails": {}
    },
    "d98a2e6e2383f8b66def346409b0517aa32d298d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12934. RBF: Federation supports global quota. Contributed by Yiqun Lin.\n",
      "commitDate": "09/01/18 9:59 PM",
      "commitName": "d98a2e6e2383f8b66def346409b0517aa32d298d",
      "commitAuthor": "Yiqun Lin",
      "commitDateOld": "14/12/17 10:09 PM",
      "commitNameOld": "ee028bfdf1c88a27cd925bed93ebb599a164dd2e",
      "commitAuthorOld": "Yiqun Lin",
      "daysBetweenCommits": 25.99,
      "commitsBetweenForRepo": 133,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,32 +1,38 @@\n   public static MountTable newInstance(final String src,\n       final Map\u003cString, String\u003e destinations) throws IOException {\n     MountTable record \u003d newInstance();\n \n     // Normalize the mount path\n     record.setSourcePath(normalizeFileSystemPath(src));\n \n     // Build a list of remote locations\n     final List\u003cRemoteLocation\u003e locations \u003d new LinkedList\u003c\u003e();\n     for (Entry\u003cString, String\u003e entry : destinations.entrySet()) {\n       String nsId \u003d entry.getKey();\n       String path \u003d normalizeFileSystemPath(entry.getValue());\n       RemoteLocation location \u003d new RemoteLocation(nsId, path);\n       locations.add(location);\n     }\n \n     // Set the serialized dest string\n     record.setDestinations(locations);\n \n     // Set permission fields\n     UserGroupInformation ugi \u003d NameNode.getRemoteUser();\n     record.setOwnerName(ugi.getShortUserName());\n     String group \u003d ugi.getGroups().isEmpty() ? ugi.getShortUserName()\n         : ugi.getPrimaryGroupName();\n     record.setGroupName(group);\n     record.setMode(new FsPermission(\n         RouterPermissionChecker.MOUNT_TABLE_PERMISSION_DEFAULT));\n \n+    // Set quota for mount table\n+    RouterQuotaUsage quota \u003d new RouterQuotaUsage.Builder()\n+        .fileAndDirectoryCount(0).quota(HdfsConstants.QUOTA_DONT_SET)\n+        .spaceConsumed(0).spaceQuota(HdfsConstants.QUOTA_DONT_SET).build();\n+    record.setQuota(quota);\n+\n     // Validate\n     record.validate();\n     return record;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static MountTable newInstance(final String src,\n      final Map\u003cString, String\u003e destinations) throws IOException {\n    MountTable record \u003d newInstance();\n\n    // Normalize the mount path\n    record.setSourcePath(normalizeFileSystemPath(src));\n\n    // Build a list of remote locations\n    final List\u003cRemoteLocation\u003e locations \u003d new LinkedList\u003c\u003e();\n    for (Entry\u003cString, String\u003e entry : destinations.entrySet()) {\n      String nsId \u003d entry.getKey();\n      String path \u003d normalizeFileSystemPath(entry.getValue());\n      RemoteLocation location \u003d new RemoteLocation(nsId, path);\n      locations.add(location);\n    }\n\n    // Set the serialized dest string\n    record.setDestinations(locations);\n\n    // Set permission fields\n    UserGroupInformation ugi \u003d NameNode.getRemoteUser();\n    record.setOwnerName(ugi.getShortUserName());\n    String group \u003d ugi.getGroups().isEmpty() ? ugi.getShortUserName()\n        : ugi.getPrimaryGroupName();\n    record.setGroupName(group);\n    record.setMode(new FsPermission(\n        RouterPermissionChecker.MOUNT_TABLE_PERMISSION_DEFAULT));\n\n    // Set quota for mount table\n    RouterQuotaUsage quota \u003d new RouterQuotaUsage.Builder()\n        .fileAndDirectoryCount(0).quota(HdfsConstants.QUOTA_DONT_SET)\n        .spaceConsumed(0).spaceQuota(HdfsConstants.QUOTA_DONT_SET).build();\n    record.setQuota(quota);\n\n    // Validate\n    record.validate();\n    return record;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/federation/store/records/MountTable.java",
      "extendedDetails": {}
    },
    "ee028bfdf1c88a27cd925bed93ebb599a164dd2e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12895. RBF: Add ACL support for mount table. Contributed by Yiqun Lin.\n",
      "commitDate": "14/12/17 10:09 PM",
      "commitName": "ee028bfdf1c88a27cd925bed93ebb599a164dd2e",
      "commitAuthor": "Yiqun Lin",
      "commitDateOld": "06/10/17 6:50 PM",
      "commitNameOld": "bc9e588a19c0aaf518de8dab719362be4a8d6a54",
      "commitAuthorOld": "Inigo Goiri",
      "daysBetweenCommits": 69.18,
      "commitsBetweenForRepo": 521,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,23 +1,32 @@\n   public static MountTable newInstance(final String src,\n       final Map\u003cString, String\u003e destinations) throws IOException {\n     MountTable record \u003d newInstance();\n \n     // Normalize the mount path\n     record.setSourcePath(normalizeFileSystemPath(src));\n \n     // Build a list of remote locations\n     final List\u003cRemoteLocation\u003e locations \u003d new LinkedList\u003c\u003e();\n     for (Entry\u003cString, String\u003e entry : destinations.entrySet()) {\n       String nsId \u003d entry.getKey();\n       String path \u003d normalizeFileSystemPath(entry.getValue());\n       RemoteLocation location \u003d new RemoteLocation(nsId, path);\n       locations.add(location);\n     }\n \n     // Set the serialized dest string\n     record.setDestinations(locations);\n \n+    // Set permission fields\n+    UserGroupInformation ugi \u003d NameNode.getRemoteUser();\n+    record.setOwnerName(ugi.getShortUserName());\n+    String group \u003d ugi.getGroups().isEmpty() ? ugi.getShortUserName()\n+        : ugi.getPrimaryGroupName();\n+    record.setGroupName(group);\n+    record.setMode(new FsPermission(\n+        RouterPermissionChecker.MOUNT_TABLE_PERMISSION_DEFAULT));\n+\n     // Validate\n     record.validate();\n     return record;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static MountTable newInstance(final String src,\n      final Map\u003cString, String\u003e destinations) throws IOException {\n    MountTable record \u003d newInstance();\n\n    // Normalize the mount path\n    record.setSourcePath(normalizeFileSystemPath(src));\n\n    // Build a list of remote locations\n    final List\u003cRemoteLocation\u003e locations \u003d new LinkedList\u003c\u003e();\n    for (Entry\u003cString, String\u003e entry : destinations.entrySet()) {\n      String nsId \u003d entry.getKey();\n      String path \u003d normalizeFileSystemPath(entry.getValue());\n      RemoteLocation location \u003d new RemoteLocation(nsId, path);\n      locations.add(location);\n    }\n\n    // Set the serialized dest string\n    record.setDestinations(locations);\n\n    // Set permission fields\n    UserGroupInformation ugi \u003d NameNode.getRemoteUser();\n    record.setOwnerName(ugi.getShortUserName());\n    String group \u003d ugi.getGroups().isEmpty() ? ugi.getShortUserName()\n        : ugi.getPrimaryGroupName();\n    record.setGroupName(group);\n    record.setMode(new FsPermission(\n        RouterPermissionChecker.MOUNT_TABLE_PERMISSION_DEFAULT));\n\n    // Validate\n    record.validate();\n    return record;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/federation/store/records/MountTable.java",
      "extendedDetails": {}
    },
    "6f0de2731806628b5b01bd1350225692147590da": {
      "type": "Ymultichange(Ymovefromfile,Yreturntypechange,Ymodifierchange,Yexceptionschange,Ybodychange,Yparameterchange)",
      "commitMessage": "HDFS-10880. Federation Mount Table State Store internal API. Contributed by Jason Kace and Inigo Goiri.\n\n(cherry picked from commit 58b97df661441150d35abd44b3a8606206b46441)\n",
      "commitDate": "06/10/17 6:50 PM",
      "commitName": "6f0de2731806628b5b01bd1350225692147590da",
      "commitAuthor": "Inigo Goiri",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "HDFS-10880. Federation Mount Table State Store internal API. Contributed by Jason Kace and Inigo Goiri.\n\n(cherry picked from commit 58b97df661441150d35abd44b3a8606206b46441)\n",
          "commitDate": "06/10/17 6:50 PM",
          "commitName": "6f0de2731806628b5b01bd1350225692147590da",
          "commitAuthor": "Inigo Goiri",
          "commitDateOld": "06/10/17 6:50 PM",
          "commitNameOld": "d8c81073320320a019fb3868be4f06f46aebea43",
          "commitAuthorOld": "Inigo Goiri",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,31 +1,23 @@\n-  private static \u003cT, R\u003e T newInstance(final Configuration conf,\n-      final R context, final Class\u003cR\u003e contextClass,\n-      final String configKeyName, final String defaultClassName,\n-      final Class\u003cT\u003e clazz) {\n+  public static MountTable newInstance(final String src,\n+      final Map\u003cString, String\u003e destinations) throws IOException {\n+    MountTable record \u003d newInstance();\n \n-    String className \u003d conf.get(configKeyName, defaultClassName);\n-    try {\n-      Class\u003c?\u003e instance \u003d conf.getClassByName(className);\n-      if (clazz.isAssignableFrom(instance)) {\n-        if (contextClass \u003d\u003d null) {\n-          // Default constructor if no context\n-          @SuppressWarnings(\"unchecked\")\n-          Constructor\u003cT\u003e constructor \u003d\n-              (Constructor\u003cT\u003e) instance.getConstructor();\n-          return constructor.newInstance();\n-        } else {\n-          // Constructor with context\n-          @SuppressWarnings(\"unchecked\")\n-          Constructor\u003cT\u003e constructor \u003d (Constructor\u003cT\u003e) instance.getConstructor(\n-              Configuration.class, contextClass);\n-          return constructor.newInstance(conf, context);\n-        }\n-      } else {\n-        throw new RuntimeException(\"Class \" + className + \" not instance of \"\n-            + clazz.getCanonicalName());\n-      }\n-    } catch (ReflectiveOperationException e) {\n-      LOG.error(\"Could not instantiate: \" + className, e);\n-      return null;\n+    // Normalize the mount path\n+    record.setSourcePath(normalizeFileSystemPath(src));\n+\n+    // Build a list of remote locations\n+    final List\u003cRemoteLocation\u003e locations \u003d new LinkedList\u003c\u003e();\n+    for (Entry\u003cString, String\u003e entry : destinations.entrySet()) {\n+      String nsId \u003d entry.getKey();\n+      String path \u003d normalizeFileSystemPath(entry.getValue());\n+      RemoteLocation location \u003d new RemoteLocation(nsId, path);\n+      locations.add(location);\n     }\n+\n+    // Set the serialized dest string\n+    record.setDestinations(locations);\n+\n+    // Validate\n+    record.validate();\n+    return record;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static MountTable newInstance(final String src,\n      final Map\u003cString, String\u003e destinations) throws IOException {\n    MountTable record \u003d newInstance();\n\n    // Normalize the mount path\n    record.setSourcePath(normalizeFileSystemPath(src));\n\n    // Build a list of remote locations\n    final List\u003cRemoteLocation\u003e locations \u003d new LinkedList\u003c\u003e();\n    for (Entry\u003cString, String\u003e entry : destinations.entrySet()) {\n      String nsId \u003d entry.getKey();\n      String path \u003d normalizeFileSystemPath(entry.getValue());\n      RemoteLocation location \u003d new RemoteLocation(nsId, path);\n      locations.add(location);\n    }\n\n    // Set the serialized dest string\n    record.setDestinations(locations);\n\n    // Validate\n    record.validate();\n    return record;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/federation/store/records/MountTable.java",
          "extendedDetails": {
            "oldPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/federation/router/FederationUtil.java",
            "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/federation/store/records/MountTable.java",
            "oldMethodName": "newInstance",
            "newMethodName": "newInstance"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "HDFS-10880. Federation Mount Table State Store internal API. Contributed by Jason Kace and Inigo Goiri.\n\n(cherry picked from commit 58b97df661441150d35abd44b3a8606206b46441)\n",
          "commitDate": "06/10/17 6:50 PM",
          "commitName": "6f0de2731806628b5b01bd1350225692147590da",
          "commitAuthor": "Inigo Goiri",
          "commitDateOld": "06/10/17 6:50 PM",
          "commitNameOld": "d8c81073320320a019fb3868be4f06f46aebea43",
          "commitAuthorOld": "Inigo Goiri",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,31 +1,23 @@\n-  private static \u003cT, R\u003e T newInstance(final Configuration conf,\n-      final R context, final Class\u003cR\u003e contextClass,\n-      final String configKeyName, final String defaultClassName,\n-      final Class\u003cT\u003e clazz) {\n+  public static MountTable newInstance(final String src,\n+      final Map\u003cString, String\u003e destinations) throws IOException {\n+    MountTable record \u003d newInstance();\n \n-    String className \u003d conf.get(configKeyName, defaultClassName);\n-    try {\n-      Class\u003c?\u003e instance \u003d conf.getClassByName(className);\n-      if (clazz.isAssignableFrom(instance)) {\n-        if (contextClass \u003d\u003d null) {\n-          // Default constructor if no context\n-          @SuppressWarnings(\"unchecked\")\n-          Constructor\u003cT\u003e constructor \u003d\n-              (Constructor\u003cT\u003e) instance.getConstructor();\n-          return constructor.newInstance();\n-        } else {\n-          // Constructor with context\n-          @SuppressWarnings(\"unchecked\")\n-          Constructor\u003cT\u003e constructor \u003d (Constructor\u003cT\u003e) instance.getConstructor(\n-              Configuration.class, contextClass);\n-          return constructor.newInstance(conf, context);\n-        }\n-      } else {\n-        throw new RuntimeException(\"Class \" + className + \" not instance of \"\n-            + clazz.getCanonicalName());\n-      }\n-    } catch (ReflectiveOperationException e) {\n-      LOG.error(\"Could not instantiate: \" + className, e);\n-      return null;\n+    // Normalize the mount path\n+    record.setSourcePath(normalizeFileSystemPath(src));\n+\n+    // Build a list of remote locations\n+    final List\u003cRemoteLocation\u003e locations \u003d new LinkedList\u003c\u003e();\n+    for (Entry\u003cString, String\u003e entry : destinations.entrySet()) {\n+      String nsId \u003d entry.getKey();\n+      String path \u003d normalizeFileSystemPath(entry.getValue());\n+      RemoteLocation location \u003d new RemoteLocation(nsId, path);\n+      locations.add(location);\n     }\n+\n+    // Set the serialized dest string\n+    record.setDestinations(locations);\n+\n+    // Validate\n+    record.validate();\n+    return record;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static MountTable newInstance(final String src,\n      final Map\u003cString, String\u003e destinations) throws IOException {\n    MountTable record \u003d newInstance();\n\n    // Normalize the mount path\n    record.setSourcePath(normalizeFileSystemPath(src));\n\n    // Build a list of remote locations\n    final List\u003cRemoteLocation\u003e locations \u003d new LinkedList\u003c\u003e();\n    for (Entry\u003cString, String\u003e entry : destinations.entrySet()) {\n      String nsId \u003d entry.getKey();\n      String path \u003d normalizeFileSystemPath(entry.getValue());\n      RemoteLocation location \u003d new RemoteLocation(nsId, path);\n      locations.add(location);\n    }\n\n    // Set the serialized dest string\n    record.setDestinations(locations);\n\n    // Validate\n    record.validate();\n    return record;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/federation/store/records/MountTable.java",
          "extendedDetails": {
            "oldValue": "T",
            "newValue": "MountTable"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "HDFS-10880. Federation Mount Table State Store internal API. Contributed by Jason Kace and Inigo Goiri.\n\n(cherry picked from commit 58b97df661441150d35abd44b3a8606206b46441)\n",
          "commitDate": "06/10/17 6:50 PM",
          "commitName": "6f0de2731806628b5b01bd1350225692147590da",
          "commitAuthor": "Inigo Goiri",
          "commitDateOld": "06/10/17 6:50 PM",
          "commitNameOld": "d8c81073320320a019fb3868be4f06f46aebea43",
          "commitAuthorOld": "Inigo Goiri",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,31 +1,23 @@\n-  private static \u003cT, R\u003e T newInstance(final Configuration conf,\n-      final R context, final Class\u003cR\u003e contextClass,\n-      final String configKeyName, final String defaultClassName,\n-      final Class\u003cT\u003e clazz) {\n+  public static MountTable newInstance(final String src,\n+      final Map\u003cString, String\u003e destinations) throws IOException {\n+    MountTable record \u003d newInstance();\n \n-    String className \u003d conf.get(configKeyName, defaultClassName);\n-    try {\n-      Class\u003c?\u003e instance \u003d conf.getClassByName(className);\n-      if (clazz.isAssignableFrom(instance)) {\n-        if (contextClass \u003d\u003d null) {\n-          // Default constructor if no context\n-          @SuppressWarnings(\"unchecked\")\n-          Constructor\u003cT\u003e constructor \u003d\n-              (Constructor\u003cT\u003e) instance.getConstructor();\n-          return constructor.newInstance();\n-        } else {\n-          // Constructor with context\n-          @SuppressWarnings(\"unchecked\")\n-          Constructor\u003cT\u003e constructor \u003d (Constructor\u003cT\u003e) instance.getConstructor(\n-              Configuration.class, contextClass);\n-          return constructor.newInstance(conf, context);\n-        }\n-      } else {\n-        throw new RuntimeException(\"Class \" + className + \" not instance of \"\n-            + clazz.getCanonicalName());\n-      }\n-    } catch (ReflectiveOperationException e) {\n-      LOG.error(\"Could not instantiate: \" + className, e);\n-      return null;\n+    // Normalize the mount path\n+    record.setSourcePath(normalizeFileSystemPath(src));\n+\n+    // Build a list of remote locations\n+    final List\u003cRemoteLocation\u003e locations \u003d new LinkedList\u003c\u003e();\n+    for (Entry\u003cString, String\u003e entry : destinations.entrySet()) {\n+      String nsId \u003d entry.getKey();\n+      String path \u003d normalizeFileSystemPath(entry.getValue());\n+      RemoteLocation location \u003d new RemoteLocation(nsId, path);\n+      locations.add(location);\n     }\n+\n+    // Set the serialized dest string\n+    record.setDestinations(locations);\n+\n+    // Validate\n+    record.validate();\n+    return record;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static MountTable newInstance(final String src,\n      final Map\u003cString, String\u003e destinations) throws IOException {\n    MountTable record \u003d newInstance();\n\n    // Normalize the mount path\n    record.setSourcePath(normalizeFileSystemPath(src));\n\n    // Build a list of remote locations\n    final List\u003cRemoteLocation\u003e locations \u003d new LinkedList\u003c\u003e();\n    for (Entry\u003cString, String\u003e entry : destinations.entrySet()) {\n      String nsId \u003d entry.getKey();\n      String path \u003d normalizeFileSystemPath(entry.getValue());\n      RemoteLocation location \u003d new RemoteLocation(nsId, path);\n      locations.add(location);\n    }\n\n    // Set the serialized dest string\n    record.setDestinations(locations);\n\n    // Validate\n    record.validate();\n    return record;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/federation/store/records/MountTable.java",
          "extendedDetails": {
            "oldValue": "[private, static]",
            "newValue": "[public, static]"
          }
        },
        {
          "type": "Yexceptionschange",
          "commitMessage": "HDFS-10880. Federation Mount Table State Store internal API. Contributed by Jason Kace and Inigo Goiri.\n\n(cherry picked from commit 58b97df661441150d35abd44b3a8606206b46441)\n",
          "commitDate": "06/10/17 6:50 PM",
          "commitName": "6f0de2731806628b5b01bd1350225692147590da",
          "commitAuthor": "Inigo Goiri",
          "commitDateOld": "06/10/17 6:50 PM",
          "commitNameOld": "d8c81073320320a019fb3868be4f06f46aebea43",
          "commitAuthorOld": "Inigo Goiri",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,31 +1,23 @@\n-  private static \u003cT, R\u003e T newInstance(final Configuration conf,\n-      final R context, final Class\u003cR\u003e contextClass,\n-      final String configKeyName, final String defaultClassName,\n-      final Class\u003cT\u003e clazz) {\n+  public static MountTable newInstance(final String src,\n+      final Map\u003cString, String\u003e destinations) throws IOException {\n+    MountTable record \u003d newInstance();\n \n-    String className \u003d conf.get(configKeyName, defaultClassName);\n-    try {\n-      Class\u003c?\u003e instance \u003d conf.getClassByName(className);\n-      if (clazz.isAssignableFrom(instance)) {\n-        if (contextClass \u003d\u003d null) {\n-          // Default constructor if no context\n-          @SuppressWarnings(\"unchecked\")\n-          Constructor\u003cT\u003e constructor \u003d\n-              (Constructor\u003cT\u003e) instance.getConstructor();\n-          return constructor.newInstance();\n-        } else {\n-          // Constructor with context\n-          @SuppressWarnings(\"unchecked\")\n-          Constructor\u003cT\u003e constructor \u003d (Constructor\u003cT\u003e) instance.getConstructor(\n-              Configuration.class, contextClass);\n-          return constructor.newInstance(conf, context);\n-        }\n-      } else {\n-        throw new RuntimeException(\"Class \" + className + \" not instance of \"\n-            + clazz.getCanonicalName());\n-      }\n-    } catch (ReflectiveOperationException e) {\n-      LOG.error(\"Could not instantiate: \" + className, e);\n-      return null;\n+    // Normalize the mount path\n+    record.setSourcePath(normalizeFileSystemPath(src));\n+\n+    // Build a list of remote locations\n+    final List\u003cRemoteLocation\u003e locations \u003d new LinkedList\u003c\u003e();\n+    for (Entry\u003cString, String\u003e entry : destinations.entrySet()) {\n+      String nsId \u003d entry.getKey();\n+      String path \u003d normalizeFileSystemPath(entry.getValue());\n+      RemoteLocation location \u003d new RemoteLocation(nsId, path);\n+      locations.add(location);\n     }\n+\n+    // Set the serialized dest string\n+    record.setDestinations(locations);\n+\n+    // Validate\n+    record.validate();\n+    return record;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static MountTable newInstance(final String src,\n      final Map\u003cString, String\u003e destinations) throws IOException {\n    MountTable record \u003d newInstance();\n\n    // Normalize the mount path\n    record.setSourcePath(normalizeFileSystemPath(src));\n\n    // Build a list of remote locations\n    final List\u003cRemoteLocation\u003e locations \u003d new LinkedList\u003c\u003e();\n    for (Entry\u003cString, String\u003e entry : destinations.entrySet()) {\n      String nsId \u003d entry.getKey();\n      String path \u003d normalizeFileSystemPath(entry.getValue());\n      RemoteLocation location \u003d new RemoteLocation(nsId, path);\n      locations.add(location);\n    }\n\n    // Set the serialized dest string\n    record.setDestinations(locations);\n\n    // Validate\n    record.validate();\n    return record;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/federation/store/records/MountTable.java",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[IOException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-10880. Federation Mount Table State Store internal API. Contributed by Jason Kace and Inigo Goiri.\n\n(cherry picked from commit 58b97df661441150d35abd44b3a8606206b46441)\n",
          "commitDate": "06/10/17 6:50 PM",
          "commitName": "6f0de2731806628b5b01bd1350225692147590da",
          "commitAuthor": "Inigo Goiri",
          "commitDateOld": "06/10/17 6:50 PM",
          "commitNameOld": "d8c81073320320a019fb3868be4f06f46aebea43",
          "commitAuthorOld": "Inigo Goiri",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,31 +1,23 @@\n-  private static \u003cT, R\u003e T newInstance(final Configuration conf,\n-      final R context, final Class\u003cR\u003e contextClass,\n-      final String configKeyName, final String defaultClassName,\n-      final Class\u003cT\u003e clazz) {\n+  public static MountTable newInstance(final String src,\n+      final Map\u003cString, String\u003e destinations) throws IOException {\n+    MountTable record \u003d newInstance();\n \n-    String className \u003d conf.get(configKeyName, defaultClassName);\n-    try {\n-      Class\u003c?\u003e instance \u003d conf.getClassByName(className);\n-      if (clazz.isAssignableFrom(instance)) {\n-        if (contextClass \u003d\u003d null) {\n-          // Default constructor if no context\n-          @SuppressWarnings(\"unchecked\")\n-          Constructor\u003cT\u003e constructor \u003d\n-              (Constructor\u003cT\u003e) instance.getConstructor();\n-          return constructor.newInstance();\n-        } else {\n-          // Constructor with context\n-          @SuppressWarnings(\"unchecked\")\n-          Constructor\u003cT\u003e constructor \u003d (Constructor\u003cT\u003e) instance.getConstructor(\n-              Configuration.class, contextClass);\n-          return constructor.newInstance(conf, context);\n-        }\n-      } else {\n-        throw new RuntimeException(\"Class \" + className + \" not instance of \"\n-            + clazz.getCanonicalName());\n-      }\n-    } catch (ReflectiveOperationException e) {\n-      LOG.error(\"Could not instantiate: \" + className, e);\n-      return null;\n+    // Normalize the mount path\n+    record.setSourcePath(normalizeFileSystemPath(src));\n+\n+    // Build a list of remote locations\n+    final List\u003cRemoteLocation\u003e locations \u003d new LinkedList\u003c\u003e();\n+    for (Entry\u003cString, String\u003e entry : destinations.entrySet()) {\n+      String nsId \u003d entry.getKey();\n+      String path \u003d normalizeFileSystemPath(entry.getValue());\n+      RemoteLocation location \u003d new RemoteLocation(nsId, path);\n+      locations.add(location);\n     }\n+\n+    // Set the serialized dest string\n+    record.setDestinations(locations);\n+\n+    // Validate\n+    record.validate();\n+    return record;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static MountTable newInstance(final String src,\n      final Map\u003cString, String\u003e destinations) throws IOException {\n    MountTable record \u003d newInstance();\n\n    // Normalize the mount path\n    record.setSourcePath(normalizeFileSystemPath(src));\n\n    // Build a list of remote locations\n    final List\u003cRemoteLocation\u003e locations \u003d new LinkedList\u003c\u003e();\n    for (Entry\u003cString, String\u003e entry : destinations.entrySet()) {\n      String nsId \u003d entry.getKey();\n      String path \u003d normalizeFileSystemPath(entry.getValue());\n      RemoteLocation location \u003d new RemoteLocation(nsId, path);\n      locations.add(location);\n    }\n\n    // Set the serialized dest string\n    record.setDestinations(locations);\n\n    // Validate\n    record.validate();\n    return record;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/federation/store/records/MountTable.java",
          "extendedDetails": {}
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-10880. Federation Mount Table State Store internal API. Contributed by Jason Kace and Inigo Goiri.\n\n(cherry picked from commit 58b97df661441150d35abd44b3a8606206b46441)\n",
          "commitDate": "06/10/17 6:50 PM",
          "commitName": "6f0de2731806628b5b01bd1350225692147590da",
          "commitAuthor": "Inigo Goiri",
          "commitDateOld": "06/10/17 6:50 PM",
          "commitNameOld": "d8c81073320320a019fb3868be4f06f46aebea43",
          "commitAuthorOld": "Inigo Goiri",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,31 +1,23 @@\n-  private static \u003cT, R\u003e T newInstance(final Configuration conf,\n-      final R context, final Class\u003cR\u003e contextClass,\n-      final String configKeyName, final String defaultClassName,\n-      final Class\u003cT\u003e clazz) {\n+  public static MountTable newInstance(final String src,\n+      final Map\u003cString, String\u003e destinations) throws IOException {\n+    MountTable record \u003d newInstance();\n \n-    String className \u003d conf.get(configKeyName, defaultClassName);\n-    try {\n-      Class\u003c?\u003e instance \u003d conf.getClassByName(className);\n-      if (clazz.isAssignableFrom(instance)) {\n-        if (contextClass \u003d\u003d null) {\n-          // Default constructor if no context\n-          @SuppressWarnings(\"unchecked\")\n-          Constructor\u003cT\u003e constructor \u003d\n-              (Constructor\u003cT\u003e) instance.getConstructor();\n-          return constructor.newInstance();\n-        } else {\n-          // Constructor with context\n-          @SuppressWarnings(\"unchecked\")\n-          Constructor\u003cT\u003e constructor \u003d (Constructor\u003cT\u003e) instance.getConstructor(\n-              Configuration.class, contextClass);\n-          return constructor.newInstance(conf, context);\n-        }\n-      } else {\n-        throw new RuntimeException(\"Class \" + className + \" not instance of \"\n-            + clazz.getCanonicalName());\n-      }\n-    } catch (ReflectiveOperationException e) {\n-      LOG.error(\"Could not instantiate: \" + className, e);\n-      return null;\n+    // Normalize the mount path\n+    record.setSourcePath(normalizeFileSystemPath(src));\n+\n+    // Build a list of remote locations\n+    final List\u003cRemoteLocation\u003e locations \u003d new LinkedList\u003c\u003e();\n+    for (Entry\u003cString, String\u003e entry : destinations.entrySet()) {\n+      String nsId \u003d entry.getKey();\n+      String path \u003d normalizeFileSystemPath(entry.getValue());\n+      RemoteLocation location \u003d new RemoteLocation(nsId, path);\n+      locations.add(location);\n     }\n+\n+    // Set the serialized dest string\n+    record.setDestinations(locations);\n+\n+    // Validate\n+    record.validate();\n+    return record;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static MountTable newInstance(final String src,\n      final Map\u003cString, String\u003e destinations) throws IOException {\n    MountTable record \u003d newInstance();\n\n    // Normalize the mount path\n    record.setSourcePath(normalizeFileSystemPath(src));\n\n    // Build a list of remote locations\n    final List\u003cRemoteLocation\u003e locations \u003d new LinkedList\u003c\u003e();\n    for (Entry\u003cString, String\u003e entry : destinations.entrySet()) {\n      String nsId \u003d entry.getKey();\n      String path \u003d normalizeFileSystemPath(entry.getValue());\n      RemoteLocation location \u003d new RemoteLocation(nsId, path);\n      locations.add(location);\n    }\n\n    // Set the serialized dest string\n    record.setDestinations(locations);\n\n    // Validate\n    record.validate();\n    return record;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/federation/store/records/MountTable.java",
          "extendedDetails": {
            "oldValue": "[conf-Configuration(modifiers-final), context-R(modifiers-final), contextClass-Class\u003cR\u003e(modifiers-final), configKeyName-String(modifiers-final), defaultClassName-String(modifiers-final), clazz-Class\u003cT\u003e(modifiers-final)]",
            "newValue": "[src-String(modifiers-final), destinations-Map\u003cString,String\u003e(modifiers-final)]"
          }
        }
      ]
    },
    "2761bbc91a7b0a36c42b1b6569c5ecd4f236281b": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-10629. Federation Roter. Contributed by Jason Kace and Inigo Goiri.\n\n(cherry picked from commit 6821e801724ac38e9737538b2164c9ae88792282)\n",
      "commitDate": "06/10/17 6:50 PM",
      "commitName": "2761bbc91a7b0a36c42b1b6569c5ecd4f236281b",
      "commitAuthor": "Inigo",
      "diff": "@@ -0,0 +1,31 @@\n+  private static \u003cT, R\u003e T newInstance(final Configuration conf,\n+      final R context, final Class\u003cR\u003e contextClass,\n+      final String configKeyName, final String defaultClassName,\n+      final Class\u003cT\u003e clazz) {\n+\n+    String className \u003d conf.get(configKeyName, defaultClassName);\n+    try {\n+      Class\u003c?\u003e instance \u003d conf.getClassByName(className);\n+      if (clazz.isAssignableFrom(instance)) {\n+        if (contextClass \u003d\u003d null) {\n+          // Default constructor if no context\n+          @SuppressWarnings(\"unchecked\")\n+          Constructor\u003cT\u003e constructor \u003d\n+              (Constructor\u003cT\u003e) instance.getConstructor();\n+          return constructor.newInstance();\n+        } else {\n+          // Constructor with context\n+          @SuppressWarnings(\"unchecked\")\n+          Constructor\u003cT\u003e constructor \u003d (Constructor\u003cT\u003e) instance.getConstructor(\n+              Configuration.class, contextClass);\n+          return constructor.newInstance(conf, context);\n+        }\n+      } else {\n+        throw new RuntimeException(\"Class \" + className + \" not instance of \"\n+            + clazz.getCanonicalName());\n+      }\n+    } catch (ReflectiveOperationException e) {\n+      LOG.error(\"Could not instantiate: \" + className, e);\n+      return null;\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private static \u003cT, R\u003e T newInstance(final Configuration conf,\n      final R context, final Class\u003cR\u003e contextClass,\n      final String configKeyName, final String defaultClassName,\n      final Class\u003cT\u003e clazz) {\n\n    String className \u003d conf.get(configKeyName, defaultClassName);\n    try {\n      Class\u003c?\u003e instance \u003d conf.getClassByName(className);\n      if (clazz.isAssignableFrom(instance)) {\n        if (contextClass \u003d\u003d null) {\n          // Default constructor if no context\n          @SuppressWarnings(\"unchecked\")\n          Constructor\u003cT\u003e constructor \u003d\n              (Constructor\u003cT\u003e) instance.getConstructor();\n          return constructor.newInstance();\n        } else {\n          // Constructor with context\n          @SuppressWarnings(\"unchecked\")\n          Constructor\u003cT\u003e constructor \u003d (Constructor\u003cT\u003e) instance.getConstructor(\n              Configuration.class, contextClass);\n          return constructor.newInstance(conf, context);\n        }\n      } else {\n        throw new RuntimeException(\"Class \" + className + \" not instance of \"\n            + clazz.getCanonicalName());\n      }\n    } catch (ReflectiveOperationException e) {\n      LOG.error(\"Could not instantiate: \" + className, e);\n      return null;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/federation/router/FederationUtil.java"
    }
  }
}