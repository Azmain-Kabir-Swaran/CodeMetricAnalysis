{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FileUtil.java",
  "functionName": "runCommandOnStream",
  "functionId": "runCommandOnStream___inputStream-InputStream__command-String",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/FileUtil.java",
  "functionStartLine": 718,
  "functionEndLine": 806,
  "numCommitsSeen": 52,
  "timeTaken": 906,
  "changeHistory": [
    "7288b08330001102f944124d18e02bf0585d3e96"
  ],
  "changeHistoryShort": {
    "7288b08330001102f944124d18e02bf0585d3e96": "Yintroduced"
  },
  "changeHistoryDetails": {
    "7288b08330001102f944124d18e02bf0585d3e96": {
      "type": "Yintroduced",
      "commitMessage": "YARN-2185. Use pipes when localizing archives. Contributed by Miklos Szegedi\n",
      "commitDate": "31/01/18 7:39 AM",
      "commitName": "7288b08330001102f944124d18e02bf0585d3e96",
      "commitAuthor": "Jason Lowe",
      "diff": "@@ -0,0 +1,89 @@\n+  private static void runCommandOnStream(\n+      InputStream inputStream, String command)\n+      throws IOException, InterruptedException, ExecutionException {\n+    ExecutorService executor \u003d null;\n+    ProcessBuilder builder \u003d new ProcessBuilder();\n+    builder.command(\n+        Shell.WINDOWS ? \"cmd\" : \"bash\",\n+        Shell.WINDOWS ? \"/c\" : \"-c\",\n+        command);\n+    Process process \u003d builder.start();\n+    int exitCode;\n+    try {\n+      // Consume stdout and stderr, to avoid blocking the command\n+      executor \u003d Executors.newFixedThreadPool(2);\n+      Future output \u003d executor.submit(() -\u003e {\n+        try {\n+          // Read until the output stream receives an EOF and closed.\n+          if (LOG.isDebugEnabled()) {\n+            // Log directly to avoid out of memory errors\n+            try (BufferedReader reader \u003d\n+                     new BufferedReader(\n+                         new InputStreamReader(process.getInputStream(),\n+                             Charset.forName(\"UTF-8\")))) {\n+              String line;\n+              while((line \u003d reader.readLine()) !\u003d null) {\n+                LOG.debug(line);\n+              }\n+            }\n+          } else {\n+            org.apache.commons.io.IOUtils.copy(\n+                process.getInputStream(),\n+                new IOUtils.NullOutputStream());\n+          }\n+        } catch (IOException e) {\n+          LOG.debug(e.getMessage());\n+        }\n+      });\n+      Future error \u003d executor.submit(() -\u003e {\n+        try {\n+          // Read until the error stream receives an EOF and closed.\n+          if (LOG.isDebugEnabled()) {\n+            // Log directly to avoid out of memory errors\n+            try (BufferedReader reader \u003d\n+                     new BufferedReader(\n+                         new InputStreamReader(process.getErrorStream(),\n+                             Charset.forName(\"UTF-8\")))) {\n+              String line;\n+              while((line \u003d reader.readLine()) !\u003d null) {\n+                LOG.debug(line);\n+              }\n+            }\n+          } else {\n+            org.apache.commons.io.IOUtils.copy(\n+                process.getErrorStream(),\n+                new IOUtils.NullOutputStream());\n+          }\n+        } catch (IOException e) {\n+          LOG.debug(e.getMessage());\n+        }\n+      });\n+\n+      // Pass the input stream to the command to process\n+      try {\n+        org.apache.commons.io.IOUtils.copy(\n+            inputStream, process.getOutputStream());\n+      } finally {\n+        process.getOutputStream().close();\n+      }\n+\n+      // Wait for both stdout and stderr futures to finish\n+      error.get();\n+      output.get();\n+    } finally {\n+      // Clean up the threads\n+      if (executor !\u003d null) {\n+        executor.shutdown();\n+      }\n+      // Wait to avoid leaking the child process\n+      exitCode \u003d process.waitFor();\n+    }\n+\n+    if (exitCode !\u003d 0) {\n+      throw new IOException(\n+          String.format(\n+              \"Error executing command. %s \" +\n+                  \"Process exited with exit code %d.\",\n+              command, exitCode));\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private static void runCommandOnStream(\n      InputStream inputStream, String command)\n      throws IOException, InterruptedException, ExecutionException {\n    ExecutorService executor \u003d null;\n    ProcessBuilder builder \u003d new ProcessBuilder();\n    builder.command(\n        Shell.WINDOWS ? \"cmd\" : \"bash\",\n        Shell.WINDOWS ? \"/c\" : \"-c\",\n        command);\n    Process process \u003d builder.start();\n    int exitCode;\n    try {\n      // Consume stdout and stderr, to avoid blocking the command\n      executor \u003d Executors.newFixedThreadPool(2);\n      Future output \u003d executor.submit(() -\u003e {\n        try {\n          // Read until the output stream receives an EOF and closed.\n          if (LOG.isDebugEnabled()) {\n            // Log directly to avoid out of memory errors\n            try (BufferedReader reader \u003d\n                     new BufferedReader(\n                         new InputStreamReader(process.getInputStream(),\n                             Charset.forName(\"UTF-8\")))) {\n              String line;\n              while((line \u003d reader.readLine()) !\u003d null) {\n                LOG.debug(line);\n              }\n            }\n          } else {\n            org.apache.commons.io.IOUtils.copy(\n                process.getInputStream(),\n                new IOUtils.NullOutputStream());\n          }\n        } catch (IOException e) {\n          LOG.debug(e.getMessage());\n        }\n      });\n      Future error \u003d executor.submit(() -\u003e {\n        try {\n          // Read until the error stream receives an EOF and closed.\n          if (LOG.isDebugEnabled()) {\n            // Log directly to avoid out of memory errors\n            try (BufferedReader reader \u003d\n                     new BufferedReader(\n                         new InputStreamReader(process.getErrorStream(),\n                             Charset.forName(\"UTF-8\")))) {\n              String line;\n              while((line \u003d reader.readLine()) !\u003d null) {\n                LOG.debug(line);\n              }\n            }\n          } else {\n            org.apache.commons.io.IOUtils.copy(\n                process.getErrorStream(),\n                new IOUtils.NullOutputStream());\n          }\n        } catch (IOException e) {\n          LOG.debug(e.getMessage());\n        }\n      });\n\n      // Pass the input stream to the command to process\n      try {\n        org.apache.commons.io.IOUtils.copy(\n            inputStream, process.getOutputStream());\n      } finally {\n        process.getOutputStream().close();\n      }\n\n      // Wait for both stdout and stderr futures to finish\n      error.get();\n      output.get();\n    } finally {\n      // Clean up the threads\n      if (executor !\u003d null) {\n        executor.shutdown();\n      }\n      // Wait to avoid leaking the child process\n      exitCode \u003d process.waitFor();\n    }\n\n    if (exitCode !\u003d 0) {\n      throw new IOException(\n          String.format(\n              \"Error executing command. %s \" +\n                  \"Process exited with exit code %d.\",\n              command, exitCode));\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/FileUtil.java"
    }
  }
}