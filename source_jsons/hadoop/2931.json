{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "DelegationTokenSelector.java",
  "functionName": "selectToken",
  "functionId": "selectToken___nnUri-URI(modifiers-final)__tokens-Collection__Token__?______conf-Configuration(modifiers-final)",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/security/token/delegation/DelegationTokenSelector.java",
  "functionStartLine": 50,
  "functionEndLine": 69,
  "numCommitsSeen": 12,
  "timeTaken": 1994,
  "changeHistory": [
    "0d6aa5d60948a7966da0ca1c3344a37c1d32f2e9",
    "f105784d6a28d2a0cedb619f0951de93d995e9da",
    "44389399d434bd534047993ac970b7f54eb1d637",
    "c80dbe5e09ab1eb3c1b0277055f28717895d6dd9",
    "32cad9affe159ff7c6e4c7e31f57174967ef210a"
  ],
  "changeHistoryShort": {
    "0d6aa5d60948a7966da0ca1c3344a37c1d32f2e9": "Ymultichange(Yfilerename,Ybodychange)",
    "f105784d6a28d2a0cedb619f0951de93d995e9da": "Ybodychange",
    "44389399d434bd534047993ac970b7f54eb1d637": "Ybodychange",
    "c80dbe5e09ab1eb3c1b0277055f28717895d6dd9": "Ymultichange(Yrename,Yparameterchange,Ymodifierchange,Ybodychange)",
    "32cad9affe159ff7c6e4c7e31f57174967ef210a": "Yintroduced"
  },
  "changeHistoryDetails": {
    "0d6aa5d60948a7966da0ca1c3344a37c1d32f2e9": {
      "type": "Ymultichange(Yfilerename,Ybodychange)",
      "commitMessage": "HDFS-8237. Move all protocol classes used by ClientProtocol to hdfs-client. Contributed by Haohui Mai.\n",
      "commitDate": "04/05/15 3:00 PM",
      "commitName": "0d6aa5d60948a7966da0ca1c3344a37c1d32f2e9",
      "commitAuthor": "Haohui Mai",
      "subchanges": [
        {
          "type": "Yfilerename",
          "commitMessage": "HDFS-8237. Move all protocol classes used by ClientProtocol to hdfs-client. Contributed by Haohui Mai.\n",
          "commitDate": "04/05/15 3:00 PM",
          "commitName": "0d6aa5d60948a7966da0ca1c3344a37c1d32f2e9",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "04/05/15 1:39 PM",
          "commitNameOld": "bf70c5ae2824a9139c1aa9d7c14020018881cec2",
          "commitAuthorOld": "Jason Lowe",
          "daysBetweenCommits": 0.06,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,20 +1,20 @@\n   public Token\u003cDelegationTokenIdentifier\u003e selectToken(\n       final URI nnUri, Collection\u003cToken\u003c?\u003e\u003e tokens,\n       final Configuration conf) {\n     // this guesses the remote cluster\u0027s rpc service port.\n     // the current token design assumes it\u0027s the same as the local cluster\u0027s\n     // rpc port unless a config key is set.  there should be a way to automatic\n     // and correctly determine the value\n     Text serviceName \u003d SecurityUtil.buildTokenService(nnUri);\n     final String nnServiceName \u003d conf.get(SERVICE_NAME_KEY + serviceName);\n     \n-    int nnRpcPort \u003d NameNode.DEFAULT_PORT;\n+    int nnRpcPort \u003d HdfsClientConfigKeys.DFS_NAMENODE_RPC_PORT_DEFAULT;\n     if (nnServiceName !\u003d null) {\n       nnRpcPort \u003d NetUtils.createSocketAddr(nnServiceName, nnRpcPort).getPort(); \n     }\n     // use original hostname from the uri to avoid unintentional host resolving\n     serviceName \u003d SecurityUtil.buildTokenService(\n     \t\tNetUtils.createSocketAddrForHost(nnUri.getHost(), nnRpcPort));\n     \n     return selectToken(serviceName, tokens);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Token\u003cDelegationTokenIdentifier\u003e selectToken(\n      final URI nnUri, Collection\u003cToken\u003c?\u003e\u003e tokens,\n      final Configuration conf) {\n    // this guesses the remote cluster\u0027s rpc service port.\n    // the current token design assumes it\u0027s the same as the local cluster\u0027s\n    // rpc port unless a config key is set.  there should be a way to automatic\n    // and correctly determine the value\n    Text serviceName \u003d SecurityUtil.buildTokenService(nnUri);\n    final String nnServiceName \u003d conf.get(SERVICE_NAME_KEY + serviceName);\n    \n    int nnRpcPort \u003d HdfsClientConfigKeys.DFS_NAMENODE_RPC_PORT_DEFAULT;\n    if (nnServiceName !\u003d null) {\n      nnRpcPort \u003d NetUtils.createSocketAddr(nnServiceName, nnRpcPort).getPort(); \n    }\n    // use original hostname from the uri to avoid unintentional host resolving\n    serviceName \u003d SecurityUtil.buildTokenService(\n    \t\tNetUtils.createSocketAddrForHost(nnUri.getHost(), nnRpcPort));\n    \n    return selectToken(serviceName, tokens);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/security/token/delegation/DelegationTokenSelector.java",
          "extendedDetails": {
            "oldPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/security/token/delegation/DelegationTokenSelector.java",
            "newPath": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/security/token/delegation/DelegationTokenSelector.java"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-8237. Move all protocol classes used by ClientProtocol to hdfs-client. Contributed by Haohui Mai.\n",
          "commitDate": "04/05/15 3:00 PM",
          "commitName": "0d6aa5d60948a7966da0ca1c3344a37c1d32f2e9",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "04/05/15 1:39 PM",
          "commitNameOld": "bf70c5ae2824a9139c1aa9d7c14020018881cec2",
          "commitAuthorOld": "Jason Lowe",
          "daysBetweenCommits": 0.06,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,20 +1,20 @@\n   public Token\u003cDelegationTokenIdentifier\u003e selectToken(\n       final URI nnUri, Collection\u003cToken\u003c?\u003e\u003e tokens,\n       final Configuration conf) {\n     // this guesses the remote cluster\u0027s rpc service port.\n     // the current token design assumes it\u0027s the same as the local cluster\u0027s\n     // rpc port unless a config key is set.  there should be a way to automatic\n     // and correctly determine the value\n     Text serviceName \u003d SecurityUtil.buildTokenService(nnUri);\n     final String nnServiceName \u003d conf.get(SERVICE_NAME_KEY + serviceName);\n     \n-    int nnRpcPort \u003d NameNode.DEFAULT_PORT;\n+    int nnRpcPort \u003d HdfsClientConfigKeys.DFS_NAMENODE_RPC_PORT_DEFAULT;\n     if (nnServiceName !\u003d null) {\n       nnRpcPort \u003d NetUtils.createSocketAddr(nnServiceName, nnRpcPort).getPort(); \n     }\n     // use original hostname from the uri to avoid unintentional host resolving\n     serviceName \u003d SecurityUtil.buildTokenService(\n     \t\tNetUtils.createSocketAddrForHost(nnUri.getHost(), nnRpcPort));\n     \n     return selectToken(serviceName, tokens);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Token\u003cDelegationTokenIdentifier\u003e selectToken(\n      final URI nnUri, Collection\u003cToken\u003c?\u003e\u003e tokens,\n      final Configuration conf) {\n    // this guesses the remote cluster\u0027s rpc service port.\n    // the current token design assumes it\u0027s the same as the local cluster\u0027s\n    // rpc port unless a config key is set.  there should be a way to automatic\n    // and correctly determine the value\n    Text serviceName \u003d SecurityUtil.buildTokenService(nnUri);\n    final String nnServiceName \u003d conf.get(SERVICE_NAME_KEY + serviceName);\n    \n    int nnRpcPort \u003d HdfsClientConfigKeys.DFS_NAMENODE_RPC_PORT_DEFAULT;\n    if (nnServiceName !\u003d null) {\n      nnRpcPort \u003d NetUtils.createSocketAddr(nnServiceName, nnRpcPort).getPort(); \n    }\n    // use original hostname from the uri to avoid unintentional host resolving\n    serviceName \u003d SecurityUtil.buildTokenService(\n    \t\tNetUtils.createSocketAddrForHost(nnUri.getHost(), nnRpcPort));\n    \n    return selectToken(serviceName, tokens);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/security/token/delegation/DelegationTokenSelector.java",
          "extendedDetails": {}
        }
      ]
    },
    "f105784d6a28d2a0cedb619f0951de93d995e9da": {
      "type": "Ybodychange",
      "commitMessage": "svn merge -c -1354790 for reverting HDFS-3576 since it requires more changes.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1354792 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/06/12 6:25 PM",
      "commitName": "f105784d6a28d2a0cedb619f0951de93d995e9da",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "27/06/12 6:11 PM",
      "commitNameOld": "44389399d434bd534047993ac970b7f54eb1d637",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,20 +1,20 @@\n   public Token\u003cDelegationTokenIdentifier\u003e selectToken(\n       final URI nnUri, Collection\u003cToken\u003c?\u003e\u003e tokens,\n       final Configuration conf) {\n     // this guesses the remote cluster\u0027s rpc service port.\n     // the current token design assumes it\u0027s the same as the local cluster\u0027s\n     // rpc port unless a config key is set.  there should be a way to automatic\n     // and correctly determine the value\n     Text serviceName \u003d SecurityUtil.buildTokenService(nnUri);\n     final String nnServiceName \u003d conf.get(SERVICE_NAME_KEY + serviceName);\n     \n-    int nnRpcPort \u003d DFSConfigKeys.DFS_NAMENODE_RPC_PORT_DEFAULT;\n+    int nnRpcPort \u003d NameNode.DEFAULT_PORT;\n     if (nnServiceName !\u003d null) {\n       nnRpcPort \u003d NetUtils.createSocketAddr(nnServiceName, nnRpcPort).getPort(); \n     }\n     // use original hostname from the uri to avoid unintentional host resolving\n     serviceName \u003d SecurityUtil.buildTokenService(\n     \t\tNetUtils.createSocketAddrForHost(nnUri.getHost(), nnRpcPort));\n     \n     return selectToken(serviceName, tokens);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Token\u003cDelegationTokenIdentifier\u003e selectToken(\n      final URI nnUri, Collection\u003cToken\u003c?\u003e\u003e tokens,\n      final Configuration conf) {\n    // this guesses the remote cluster\u0027s rpc service port.\n    // the current token design assumes it\u0027s the same as the local cluster\u0027s\n    // rpc port unless a config key is set.  there should be a way to automatic\n    // and correctly determine the value\n    Text serviceName \u003d SecurityUtil.buildTokenService(nnUri);\n    final String nnServiceName \u003d conf.get(SERVICE_NAME_KEY + serviceName);\n    \n    int nnRpcPort \u003d NameNode.DEFAULT_PORT;\n    if (nnServiceName !\u003d null) {\n      nnRpcPort \u003d NetUtils.createSocketAddr(nnServiceName, nnRpcPort).getPort(); \n    }\n    // use original hostname from the uri to avoid unintentional host resolving\n    serviceName \u003d SecurityUtil.buildTokenService(\n    \t\tNetUtils.createSocketAddrForHost(nnUri.getHost(), nnRpcPort));\n    \n    return selectToken(serviceName, tokens);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/security/token/delegation/DelegationTokenSelector.java",
      "extendedDetails": {}
    },
    "44389399d434bd534047993ac970b7f54eb1d637": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3576. Move the definition of the constant NameNode.DEFAULT_PORT to DFSConfigKeys.DFS_NAMENODE_RPC_PORT_DEFAULT.  Contributed by Brandon Li\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1354790 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/06/12 6:11 PM",
      "commitName": "44389399d434bd534047993ac970b7f54eb1d637",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "17/04/12 3:21 PM",
      "commitNameOld": "c80dbe5e09ab1eb3c1b0277055f28717895d6dd9",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 71.12,
      "commitsBetweenForRepo": 373,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,20 +1,20 @@\n   public Token\u003cDelegationTokenIdentifier\u003e selectToken(\n       final URI nnUri, Collection\u003cToken\u003c?\u003e\u003e tokens,\n       final Configuration conf) {\n     // this guesses the remote cluster\u0027s rpc service port.\n     // the current token design assumes it\u0027s the same as the local cluster\u0027s\n     // rpc port unless a config key is set.  there should be a way to automatic\n     // and correctly determine the value\n     Text serviceName \u003d SecurityUtil.buildTokenService(nnUri);\n     final String nnServiceName \u003d conf.get(SERVICE_NAME_KEY + serviceName);\n     \n-    int nnRpcPort \u003d NameNode.DEFAULT_PORT;\n+    int nnRpcPort \u003d DFSConfigKeys.DFS_NAMENODE_RPC_PORT_DEFAULT;\n     if (nnServiceName !\u003d null) {\n       nnRpcPort \u003d NetUtils.createSocketAddr(nnServiceName, nnRpcPort).getPort(); \n     }\n     // use original hostname from the uri to avoid unintentional host resolving\n     serviceName \u003d SecurityUtil.buildTokenService(\n     \t\tNetUtils.createSocketAddrForHost(nnUri.getHost(), nnRpcPort));\n     \n     return selectToken(serviceName, tokens);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Token\u003cDelegationTokenIdentifier\u003e selectToken(\n      final URI nnUri, Collection\u003cToken\u003c?\u003e\u003e tokens,\n      final Configuration conf) {\n    // this guesses the remote cluster\u0027s rpc service port.\n    // the current token design assumes it\u0027s the same as the local cluster\u0027s\n    // rpc port unless a config key is set.  there should be a way to automatic\n    // and correctly determine the value\n    Text serviceName \u003d SecurityUtil.buildTokenService(nnUri);\n    final String nnServiceName \u003d conf.get(SERVICE_NAME_KEY + serviceName);\n    \n    int nnRpcPort \u003d DFSConfigKeys.DFS_NAMENODE_RPC_PORT_DEFAULT;\n    if (nnServiceName !\u003d null) {\n      nnRpcPort \u003d NetUtils.createSocketAddr(nnServiceName, nnRpcPort).getPort(); \n    }\n    // use original hostname from the uri to avoid unintentional host resolving\n    serviceName \u003d SecurityUtil.buildTokenService(\n    \t\tNetUtils.createSocketAddrForHost(nnUri.getHost(), nnRpcPort));\n    \n    return selectToken(serviceName, tokens);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/security/token/delegation/DelegationTokenSelector.java",
      "extendedDetails": {}
    },
    "c80dbe5e09ab1eb3c1b0277055f28717895d6dd9": {
      "type": "Ymultichange(Yrename,Yparameterchange,Ymodifierchange,Ybodychange)",
      "commitMessage": "HDFS-2652. Add support for host-based delegation tokens.  Contributed by Daryn Sharp\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1327309 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/04/12 3:21 PM",
      "commitName": "c80dbe5e09ab1eb3c1b0277055f28717895d6dd9",
      "commitAuthor": "Tsz-wo Sze",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "HDFS-2652. Add support for host-based delegation tokens.  Contributed by Daryn Sharp\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1327309 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "17/04/12 3:21 PM",
          "commitName": "c80dbe5e09ab1eb3c1b0277055f28717895d6dd9",
          "commitAuthor": "Tsz-wo Sze",
          "commitDateOld": "24/02/12 4:03 PM",
          "commitNameOld": "481f84597bf842df45b068cc24c328112e8bcf40",
          "commitAuthorOld": "Todd Lipcon",
          "daysBetweenCommits": 52.93,
          "commitsBetweenForRepo": 395,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,19 +1,20 @@\n-  public static Token\u003cDelegationTokenIdentifier\u003e selectHdfsDelegationToken(\n-      final InetSocketAddress nnAddr, final UserGroupInformation ugi,\n+  public Token\u003cDelegationTokenIdentifier\u003e selectToken(\n+      final URI nnUri, Collection\u003cToken\u003c?\u003e\u003e tokens,\n       final Configuration conf) {\n     // this guesses the remote cluster\u0027s rpc service port.\n     // the current token design assumes it\u0027s the same as the local cluster\u0027s\n     // rpc port unless a config key is set.  there should be a way to automatic\n     // and correctly determine the value\n-    final String key \u003d SERVICE_NAME_KEY + SecurityUtil.buildTokenService(nnAddr);\n-    final String nnServiceName \u003d conf.get(key);\n+    Text serviceName \u003d SecurityUtil.buildTokenService(nnUri);\n+    final String nnServiceName \u003d conf.get(SERVICE_NAME_KEY + serviceName);\n     \n     int nnRpcPort \u003d NameNode.DEFAULT_PORT;\n     if (nnServiceName !\u003d null) {\n       nnRpcPort \u003d NetUtils.createSocketAddr(nnServiceName, nnRpcPort).getPort(); \n     }\n+    // use original hostname from the uri to avoid unintentional host resolving\n+    serviceName \u003d SecurityUtil.buildTokenService(\n+    \t\tNetUtils.createSocketAddrForHost(nnUri.getHost(), nnRpcPort));\n     \n-    final Text serviceName \u003d SecurityUtil.buildTokenService(\n-        new InetSocketAddress(nnAddr.getHostName(), nnRpcPort));\n-    return INSTANCE.selectToken(serviceName, ugi.getTokens());\n+    return selectToken(serviceName, tokens);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Token\u003cDelegationTokenIdentifier\u003e selectToken(\n      final URI nnUri, Collection\u003cToken\u003c?\u003e\u003e tokens,\n      final Configuration conf) {\n    // this guesses the remote cluster\u0027s rpc service port.\n    // the current token design assumes it\u0027s the same as the local cluster\u0027s\n    // rpc port unless a config key is set.  there should be a way to automatic\n    // and correctly determine the value\n    Text serviceName \u003d SecurityUtil.buildTokenService(nnUri);\n    final String nnServiceName \u003d conf.get(SERVICE_NAME_KEY + serviceName);\n    \n    int nnRpcPort \u003d NameNode.DEFAULT_PORT;\n    if (nnServiceName !\u003d null) {\n      nnRpcPort \u003d NetUtils.createSocketAddr(nnServiceName, nnRpcPort).getPort(); \n    }\n    // use original hostname from the uri to avoid unintentional host resolving\n    serviceName \u003d SecurityUtil.buildTokenService(\n    \t\tNetUtils.createSocketAddrForHost(nnUri.getHost(), nnRpcPort));\n    \n    return selectToken(serviceName, tokens);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/security/token/delegation/DelegationTokenSelector.java",
          "extendedDetails": {
            "oldValue": "selectHdfsDelegationToken",
            "newValue": "selectToken"
          }
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-2652. Add support for host-based delegation tokens.  Contributed by Daryn Sharp\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1327309 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "17/04/12 3:21 PM",
          "commitName": "c80dbe5e09ab1eb3c1b0277055f28717895d6dd9",
          "commitAuthor": "Tsz-wo Sze",
          "commitDateOld": "24/02/12 4:03 PM",
          "commitNameOld": "481f84597bf842df45b068cc24c328112e8bcf40",
          "commitAuthorOld": "Todd Lipcon",
          "daysBetweenCommits": 52.93,
          "commitsBetweenForRepo": 395,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,19 +1,20 @@\n-  public static Token\u003cDelegationTokenIdentifier\u003e selectHdfsDelegationToken(\n-      final InetSocketAddress nnAddr, final UserGroupInformation ugi,\n+  public Token\u003cDelegationTokenIdentifier\u003e selectToken(\n+      final URI nnUri, Collection\u003cToken\u003c?\u003e\u003e tokens,\n       final Configuration conf) {\n     // this guesses the remote cluster\u0027s rpc service port.\n     // the current token design assumes it\u0027s the same as the local cluster\u0027s\n     // rpc port unless a config key is set.  there should be a way to automatic\n     // and correctly determine the value\n-    final String key \u003d SERVICE_NAME_KEY + SecurityUtil.buildTokenService(nnAddr);\n-    final String nnServiceName \u003d conf.get(key);\n+    Text serviceName \u003d SecurityUtil.buildTokenService(nnUri);\n+    final String nnServiceName \u003d conf.get(SERVICE_NAME_KEY + serviceName);\n     \n     int nnRpcPort \u003d NameNode.DEFAULT_PORT;\n     if (nnServiceName !\u003d null) {\n       nnRpcPort \u003d NetUtils.createSocketAddr(nnServiceName, nnRpcPort).getPort(); \n     }\n+    // use original hostname from the uri to avoid unintentional host resolving\n+    serviceName \u003d SecurityUtil.buildTokenService(\n+    \t\tNetUtils.createSocketAddrForHost(nnUri.getHost(), nnRpcPort));\n     \n-    final Text serviceName \u003d SecurityUtil.buildTokenService(\n-        new InetSocketAddress(nnAddr.getHostName(), nnRpcPort));\n-    return INSTANCE.selectToken(serviceName, ugi.getTokens());\n+    return selectToken(serviceName, tokens);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Token\u003cDelegationTokenIdentifier\u003e selectToken(\n      final URI nnUri, Collection\u003cToken\u003c?\u003e\u003e tokens,\n      final Configuration conf) {\n    // this guesses the remote cluster\u0027s rpc service port.\n    // the current token design assumes it\u0027s the same as the local cluster\u0027s\n    // rpc port unless a config key is set.  there should be a way to automatic\n    // and correctly determine the value\n    Text serviceName \u003d SecurityUtil.buildTokenService(nnUri);\n    final String nnServiceName \u003d conf.get(SERVICE_NAME_KEY + serviceName);\n    \n    int nnRpcPort \u003d NameNode.DEFAULT_PORT;\n    if (nnServiceName !\u003d null) {\n      nnRpcPort \u003d NetUtils.createSocketAddr(nnServiceName, nnRpcPort).getPort(); \n    }\n    // use original hostname from the uri to avoid unintentional host resolving\n    serviceName \u003d SecurityUtil.buildTokenService(\n    \t\tNetUtils.createSocketAddrForHost(nnUri.getHost(), nnRpcPort));\n    \n    return selectToken(serviceName, tokens);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/security/token/delegation/DelegationTokenSelector.java",
          "extendedDetails": {
            "oldValue": "[nnAddr-InetSocketAddress(modifiers-final), ugi-UserGroupInformation(modifiers-final), conf-Configuration(modifiers-final)]",
            "newValue": "[nnUri-URI(modifiers-final), tokens-Collection\u003cToken\u003c?\u003e\u003e, conf-Configuration(modifiers-final)]"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "HDFS-2652. Add support for host-based delegation tokens.  Contributed by Daryn Sharp\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1327309 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "17/04/12 3:21 PM",
          "commitName": "c80dbe5e09ab1eb3c1b0277055f28717895d6dd9",
          "commitAuthor": "Tsz-wo Sze",
          "commitDateOld": "24/02/12 4:03 PM",
          "commitNameOld": "481f84597bf842df45b068cc24c328112e8bcf40",
          "commitAuthorOld": "Todd Lipcon",
          "daysBetweenCommits": 52.93,
          "commitsBetweenForRepo": 395,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,19 +1,20 @@\n-  public static Token\u003cDelegationTokenIdentifier\u003e selectHdfsDelegationToken(\n-      final InetSocketAddress nnAddr, final UserGroupInformation ugi,\n+  public Token\u003cDelegationTokenIdentifier\u003e selectToken(\n+      final URI nnUri, Collection\u003cToken\u003c?\u003e\u003e tokens,\n       final Configuration conf) {\n     // this guesses the remote cluster\u0027s rpc service port.\n     // the current token design assumes it\u0027s the same as the local cluster\u0027s\n     // rpc port unless a config key is set.  there should be a way to automatic\n     // and correctly determine the value\n-    final String key \u003d SERVICE_NAME_KEY + SecurityUtil.buildTokenService(nnAddr);\n-    final String nnServiceName \u003d conf.get(key);\n+    Text serviceName \u003d SecurityUtil.buildTokenService(nnUri);\n+    final String nnServiceName \u003d conf.get(SERVICE_NAME_KEY + serviceName);\n     \n     int nnRpcPort \u003d NameNode.DEFAULT_PORT;\n     if (nnServiceName !\u003d null) {\n       nnRpcPort \u003d NetUtils.createSocketAddr(nnServiceName, nnRpcPort).getPort(); \n     }\n+    // use original hostname from the uri to avoid unintentional host resolving\n+    serviceName \u003d SecurityUtil.buildTokenService(\n+    \t\tNetUtils.createSocketAddrForHost(nnUri.getHost(), nnRpcPort));\n     \n-    final Text serviceName \u003d SecurityUtil.buildTokenService(\n-        new InetSocketAddress(nnAddr.getHostName(), nnRpcPort));\n-    return INSTANCE.selectToken(serviceName, ugi.getTokens());\n+    return selectToken(serviceName, tokens);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Token\u003cDelegationTokenIdentifier\u003e selectToken(\n      final URI nnUri, Collection\u003cToken\u003c?\u003e\u003e tokens,\n      final Configuration conf) {\n    // this guesses the remote cluster\u0027s rpc service port.\n    // the current token design assumes it\u0027s the same as the local cluster\u0027s\n    // rpc port unless a config key is set.  there should be a way to automatic\n    // and correctly determine the value\n    Text serviceName \u003d SecurityUtil.buildTokenService(nnUri);\n    final String nnServiceName \u003d conf.get(SERVICE_NAME_KEY + serviceName);\n    \n    int nnRpcPort \u003d NameNode.DEFAULT_PORT;\n    if (nnServiceName !\u003d null) {\n      nnRpcPort \u003d NetUtils.createSocketAddr(nnServiceName, nnRpcPort).getPort(); \n    }\n    // use original hostname from the uri to avoid unintentional host resolving\n    serviceName \u003d SecurityUtil.buildTokenService(\n    \t\tNetUtils.createSocketAddrForHost(nnUri.getHost(), nnRpcPort));\n    \n    return selectToken(serviceName, tokens);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/security/token/delegation/DelegationTokenSelector.java",
          "extendedDetails": {
            "oldValue": "[public, static]",
            "newValue": "[public]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-2652. Add support for host-based delegation tokens.  Contributed by Daryn Sharp\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1327309 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "17/04/12 3:21 PM",
          "commitName": "c80dbe5e09ab1eb3c1b0277055f28717895d6dd9",
          "commitAuthor": "Tsz-wo Sze",
          "commitDateOld": "24/02/12 4:03 PM",
          "commitNameOld": "481f84597bf842df45b068cc24c328112e8bcf40",
          "commitAuthorOld": "Todd Lipcon",
          "daysBetweenCommits": 52.93,
          "commitsBetweenForRepo": 395,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,19 +1,20 @@\n-  public static Token\u003cDelegationTokenIdentifier\u003e selectHdfsDelegationToken(\n-      final InetSocketAddress nnAddr, final UserGroupInformation ugi,\n+  public Token\u003cDelegationTokenIdentifier\u003e selectToken(\n+      final URI nnUri, Collection\u003cToken\u003c?\u003e\u003e tokens,\n       final Configuration conf) {\n     // this guesses the remote cluster\u0027s rpc service port.\n     // the current token design assumes it\u0027s the same as the local cluster\u0027s\n     // rpc port unless a config key is set.  there should be a way to automatic\n     // and correctly determine the value\n-    final String key \u003d SERVICE_NAME_KEY + SecurityUtil.buildTokenService(nnAddr);\n-    final String nnServiceName \u003d conf.get(key);\n+    Text serviceName \u003d SecurityUtil.buildTokenService(nnUri);\n+    final String nnServiceName \u003d conf.get(SERVICE_NAME_KEY + serviceName);\n     \n     int nnRpcPort \u003d NameNode.DEFAULT_PORT;\n     if (nnServiceName !\u003d null) {\n       nnRpcPort \u003d NetUtils.createSocketAddr(nnServiceName, nnRpcPort).getPort(); \n     }\n+    // use original hostname from the uri to avoid unintentional host resolving\n+    serviceName \u003d SecurityUtil.buildTokenService(\n+    \t\tNetUtils.createSocketAddrForHost(nnUri.getHost(), nnRpcPort));\n     \n-    final Text serviceName \u003d SecurityUtil.buildTokenService(\n-        new InetSocketAddress(nnAddr.getHostName(), nnRpcPort));\n-    return INSTANCE.selectToken(serviceName, ugi.getTokens());\n+    return selectToken(serviceName, tokens);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Token\u003cDelegationTokenIdentifier\u003e selectToken(\n      final URI nnUri, Collection\u003cToken\u003c?\u003e\u003e tokens,\n      final Configuration conf) {\n    // this guesses the remote cluster\u0027s rpc service port.\n    // the current token design assumes it\u0027s the same as the local cluster\u0027s\n    // rpc port unless a config key is set.  there should be a way to automatic\n    // and correctly determine the value\n    Text serviceName \u003d SecurityUtil.buildTokenService(nnUri);\n    final String nnServiceName \u003d conf.get(SERVICE_NAME_KEY + serviceName);\n    \n    int nnRpcPort \u003d NameNode.DEFAULT_PORT;\n    if (nnServiceName !\u003d null) {\n      nnRpcPort \u003d NetUtils.createSocketAddr(nnServiceName, nnRpcPort).getPort(); \n    }\n    // use original hostname from the uri to avoid unintentional host resolving\n    serviceName \u003d SecurityUtil.buildTokenService(\n    \t\tNetUtils.createSocketAddrForHost(nnUri.getHost(), nnRpcPort));\n    \n    return selectToken(serviceName, tokens);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/security/token/delegation/DelegationTokenSelector.java",
          "extendedDetails": {}
        }
      ]
    },
    "32cad9affe159ff7c6e4c7e31f57174967ef210a": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-2385. Support renew and cancel delegation tokens in webhdfs.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1195656 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "31/10/11 1:37 PM",
      "commitName": "32cad9affe159ff7c6e4c7e31f57174967ef210a",
      "commitAuthor": "Tsz-wo Sze",
      "diff": "@@ -0,0 +1,19 @@\n+  public static Token\u003cDelegationTokenIdentifier\u003e selectHdfsDelegationToken(\n+      final InetSocketAddress nnAddr, final UserGroupInformation ugi,\n+      final Configuration conf) {\n+    // this guesses the remote cluster\u0027s rpc service port.\n+    // the current token design assumes it\u0027s the same as the local cluster\u0027s\n+    // rpc port unless a config key is set.  there should be a way to automatic\n+    // and correctly determine the value\n+    final String key \u003d SERVICE_NAME_KEY + SecurityUtil.buildTokenService(nnAddr);\n+    final String nnServiceName \u003d conf.get(key);\n+    \n+    int nnRpcPort \u003d NameNode.DEFAULT_PORT;\n+    if (nnServiceName !\u003d null) {\n+      nnRpcPort \u003d NetUtils.createSocketAddr(nnServiceName, nnRpcPort).getPort(); \n+    }\n+    \n+    final Text serviceName \u003d SecurityUtil.buildTokenService(\n+        new InetSocketAddress(nnAddr.getHostName(), nnRpcPort));\n+    return INSTANCE.selectToken(serviceName, ugi.getTokens());\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public static Token\u003cDelegationTokenIdentifier\u003e selectHdfsDelegationToken(\n      final InetSocketAddress nnAddr, final UserGroupInformation ugi,\n      final Configuration conf) {\n    // this guesses the remote cluster\u0027s rpc service port.\n    // the current token design assumes it\u0027s the same as the local cluster\u0027s\n    // rpc port unless a config key is set.  there should be a way to automatic\n    // and correctly determine the value\n    final String key \u003d SERVICE_NAME_KEY + SecurityUtil.buildTokenService(nnAddr);\n    final String nnServiceName \u003d conf.get(key);\n    \n    int nnRpcPort \u003d NameNode.DEFAULT_PORT;\n    if (nnServiceName !\u003d null) {\n      nnRpcPort \u003d NetUtils.createSocketAddr(nnServiceName, nnRpcPort).getPort(); \n    }\n    \n    final Text serviceName \u003d SecurityUtil.buildTokenService(\n        new InetSocketAddress(nnAddr.getHostName(), nnRpcPort));\n    return INSTANCE.selectToken(serviceName, ugi.getTokens());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/security/token/delegation/DelegationTokenSelector.java"
    }
  }
}