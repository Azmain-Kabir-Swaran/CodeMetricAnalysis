{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "TempQueuePerPartition.java",
  "functionName": "offer",
  "functionId": "offer___avail-Resource__rc-ResourceCalculator__clusterResource-Resource__considersReservedResource-boolean__allowQueueBalanceAfterAllSafisfied-boolean",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/TempQueuePerPartition.java",
  "functionStartLine": 140,
  "functionEndLine": 202,
  "numCommitsSeen": 54,
  "timeTaken": 7186,
  "changeHistory": [
    "291194302cc1a875d6d94ea93cf1184a3f1fc2cc",
    "8d5509c68156faaa6641f4e747fc9ff80adccf88",
    "514794e1a5a39ca61de3981d53a05547ae17f5e4",
    "ce832059db077fa95922198b066a737ed4f609fe",
    "d3170f9eba9bc5c38b5fa50c24e37ca2bd5636c2",
    "90dd3a8148468ac37a3f2173ad8d45e38bfcb0c9",
    "bb62e0592566b2fcae7136b30972aad2d3ac55b0",
    "60e4116bf1d00afed91010e57357fe54057e4e39",
    "27e8ea820fab8dce59f4db9814e73bd60c1d4ef1",
    "45b42676f9333ed4fa05355ccb4e1f91a9556525",
    "85f0efb68f9d1d9ee3466e3939c4fc2f985ccf61"
  ],
  "changeHistoryShort": {
    "291194302cc1a875d6d94ea93cf1184a3f1fc2cc": "Ymultichange(Yparameterchange,Ybodychange)",
    "8d5509c68156faaa6641f4e747fc9ff80adccf88": "Ybodychange",
    "514794e1a5a39ca61de3981d53a05547ae17f5e4": "Ybodychange",
    "ce832059db077fa95922198b066a737ed4f609fe": "Ybodychange",
    "d3170f9eba9bc5c38b5fa50c24e37ca2bd5636c2": "Ybodychange",
    "90dd3a8148468ac37a3f2173ad8d45e38bfcb0c9": "Ybodychange",
    "bb62e0592566b2fcae7136b30972aad2d3ac55b0": "Ymultichange(Yparameterchange,Ybodychange)",
    "60e4116bf1d00afed91010e57357fe54057e4e39": "Ymovefromfile",
    "27e8ea820fab8dce59f4db9814e73bd60c1d4ef1": "Ybodychange",
    "45b42676f9333ed4fa05355ccb4e1f91a9556525": "Ybodychange",
    "85f0efb68f9d1d9ee3466e3939c4fc2f985ccf61": "Yintroduced"
  },
  "changeHistoryDetails": {
    "291194302cc1a875d6d94ea93cf1184a3f1fc2cc": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-8379. Improve balancing resources in already satisfied queues by using Capacity Scheduler preemption. Contributed by Zian Chen.\n",
      "commitDate": "28/06/18 10:23 AM",
      "commitName": "291194302cc1a875d6d94ea93cf1184a3f1fc2cc",
      "commitAuthor": "Sunil G",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-8379. Improve balancing resources in already satisfied queues by using Capacity Scheduler preemption. Contributed by Zian Chen.\n",
          "commitDate": "28/06/18 10:23 AM",
          "commitName": "291194302cc1a875d6d94ea93cf1184a3f1fc2cc",
          "commitAuthor": "Sunil G",
          "commitDateOld": "25/05/18 9:06 AM",
          "commitNameOld": "8d5509c68156faaa6641f4e747fc9ff80adccf88",
          "commitAuthorOld": "Eric E Payne",
          "daysBetweenCommits": 34.05,
          "commitsBetweenForRepo": 228,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,59 +1,63 @@\n   Resource offer(Resource avail, ResourceCalculator rc,\n-      Resource clusterResource, boolean considersReservedResource) {\n+      Resource clusterResource, boolean considersReservedResource,\n+      boolean allowQueueBalanceAfterAllSafisfied) {\n     Resource absMaxCapIdealAssignedDelta \u003d Resources.componentwiseMax(\n         Resources.subtract(getMax(), idealAssigned),\n         Resource.newInstance(0, 0));\n     // accepted \u003d min{avail,\n     //               max - assigned,\n     //               current + pending - assigned,\n     //               # Make sure a queue will not get more than max of its\n     //               # used/guaranteed, this is to make sure preemption won\u0027t\n     //               # happen if all active queues are beyond their guaranteed\n     //               # This is for leaf queue only.\n     //               max(guaranteed, used) - assigned}\n     // remain \u003d avail - accepted\n     Resource accepted \u003d Resources.componentwiseMin(\n         absMaxCapIdealAssignedDelta,\n         Resources.min(rc, clusterResource, avail, Resources\n             /*\n              * When we\u0027re using FifoPreemptionSelector (considerReservedResource\n              * \u003d false).\n              *\n              * We should deduct reserved resource from pending to avoid excessive\n              * preemption:\n              *\n              * For example, if an under-utilized queue has used \u003d reserved \u003d 20.\n              * Preemption policy will try to preempt 20 containers (which is not\n              * satisfied) from different hosts.\n              *\n              * In FifoPreemptionSelector, there\u0027s no guarantee that preempted\n              * resource can be used by pending request, so policy will preempt\n              * resources repeatly.\n              */\n             .subtract(Resources.add(getUsed(),\n                 (considersReservedResource ? pending : pendingDeductReserved)),\n                 idealAssigned)));\n \n     // For leaf queue: accept \u003d min(accept, max(guaranteed, used) - assigned)\n     // Why only for leaf queue?\n     // Because for a satisfied parent queue, it could have some under-utilized\n     // leaf queues. Such under-utilized leaf queue could preemption resources\n     // from over-utilized leaf queue located at other hierarchies.\n \n-    accepted \u003d filterByMaxDeductAssigned(rc, clusterResource, accepted);\n+    // Allow queues can continue grow and balance even if all queues are satisfied.\n+    if (!allowQueueBalanceAfterAllSafisfied) {\n+      accepted \u003d filterByMaxDeductAssigned(rc, clusterResource, accepted);\n+    }\n \n     // accepted so far contains the \"quota acceptable\" amount, we now filter by\n     // locality acceptable\n \n     accepted \u003d acceptedByLocality(rc, accepted);\n \n     // accept should never be \u003c 0\n     accepted \u003d Resources.componentwiseMax(accepted, Resources.none());\n \n     // or more than offered\n     accepted \u003d Resources.componentwiseMin(accepted, avail);\n \n     Resource remain \u003d Resources.subtract(avail, accepted);\n     Resources.addTo(idealAssigned, accepted);\n     return remain;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  Resource offer(Resource avail, ResourceCalculator rc,\n      Resource clusterResource, boolean considersReservedResource,\n      boolean allowQueueBalanceAfterAllSafisfied) {\n    Resource absMaxCapIdealAssignedDelta \u003d Resources.componentwiseMax(\n        Resources.subtract(getMax(), idealAssigned),\n        Resource.newInstance(0, 0));\n    // accepted \u003d min{avail,\n    //               max - assigned,\n    //               current + pending - assigned,\n    //               # Make sure a queue will not get more than max of its\n    //               # used/guaranteed, this is to make sure preemption won\u0027t\n    //               # happen if all active queues are beyond their guaranteed\n    //               # This is for leaf queue only.\n    //               max(guaranteed, used) - assigned}\n    // remain \u003d avail - accepted\n    Resource accepted \u003d Resources.componentwiseMin(\n        absMaxCapIdealAssignedDelta,\n        Resources.min(rc, clusterResource, avail, Resources\n            /*\n             * When we\u0027re using FifoPreemptionSelector (considerReservedResource\n             * \u003d false).\n             *\n             * We should deduct reserved resource from pending to avoid excessive\n             * preemption:\n             *\n             * For example, if an under-utilized queue has used \u003d reserved \u003d 20.\n             * Preemption policy will try to preempt 20 containers (which is not\n             * satisfied) from different hosts.\n             *\n             * In FifoPreemptionSelector, there\u0027s no guarantee that preempted\n             * resource can be used by pending request, so policy will preempt\n             * resources repeatly.\n             */\n            .subtract(Resources.add(getUsed(),\n                (considersReservedResource ? pending : pendingDeductReserved)),\n                idealAssigned)));\n\n    // For leaf queue: accept \u003d min(accept, max(guaranteed, used) - assigned)\n    // Why only for leaf queue?\n    // Because for a satisfied parent queue, it could have some under-utilized\n    // leaf queues. Such under-utilized leaf queue could preemption resources\n    // from over-utilized leaf queue located at other hierarchies.\n\n    // Allow queues can continue grow and balance even if all queues are satisfied.\n    if (!allowQueueBalanceAfterAllSafisfied) {\n      accepted \u003d filterByMaxDeductAssigned(rc, clusterResource, accepted);\n    }\n\n    // accepted so far contains the \"quota acceptable\" amount, we now filter by\n    // locality acceptable\n\n    accepted \u003d acceptedByLocality(rc, accepted);\n\n    // accept should never be \u003c 0\n    accepted \u003d Resources.componentwiseMax(accepted, Resources.none());\n\n    // or more than offered\n    accepted \u003d Resources.componentwiseMin(accepted, avail);\n\n    Resource remain \u003d Resources.subtract(avail, accepted);\n    Resources.addTo(idealAssigned, accepted);\n    return remain;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/TempQueuePerPartition.java",
          "extendedDetails": {
            "oldValue": "[avail-Resource, rc-ResourceCalculator, clusterResource-Resource, considersReservedResource-boolean]",
            "newValue": "[avail-Resource, rc-ResourceCalculator, clusterResource-Resource, considersReservedResource-boolean, allowQueueBalanceAfterAllSafisfied-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-8379. Improve balancing resources in already satisfied queues by using Capacity Scheduler preemption. Contributed by Zian Chen.\n",
          "commitDate": "28/06/18 10:23 AM",
          "commitName": "291194302cc1a875d6d94ea93cf1184a3f1fc2cc",
          "commitAuthor": "Sunil G",
          "commitDateOld": "25/05/18 9:06 AM",
          "commitNameOld": "8d5509c68156faaa6641f4e747fc9ff80adccf88",
          "commitAuthorOld": "Eric E Payne",
          "daysBetweenCommits": 34.05,
          "commitsBetweenForRepo": 228,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,59 +1,63 @@\n   Resource offer(Resource avail, ResourceCalculator rc,\n-      Resource clusterResource, boolean considersReservedResource) {\n+      Resource clusterResource, boolean considersReservedResource,\n+      boolean allowQueueBalanceAfterAllSafisfied) {\n     Resource absMaxCapIdealAssignedDelta \u003d Resources.componentwiseMax(\n         Resources.subtract(getMax(), idealAssigned),\n         Resource.newInstance(0, 0));\n     // accepted \u003d min{avail,\n     //               max - assigned,\n     //               current + pending - assigned,\n     //               # Make sure a queue will not get more than max of its\n     //               # used/guaranteed, this is to make sure preemption won\u0027t\n     //               # happen if all active queues are beyond their guaranteed\n     //               # This is for leaf queue only.\n     //               max(guaranteed, used) - assigned}\n     // remain \u003d avail - accepted\n     Resource accepted \u003d Resources.componentwiseMin(\n         absMaxCapIdealAssignedDelta,\n         Resources.min(rc, clusterResource, avail, Resources\n             /*\n              * When we\u0027re using FifoPreemptionSelector (considerReservedResource\n              * \u003d false).\n              *\n              * We should deduct reserved resource from pending to avoid excessive\n              * preemption:\n              *\n              * For example, if an under-utilized queue has used \u003d reserved \u003d 20.\n              * Preemption policy will try to preempt 20 containers (which is not\n              * satisfied) from different hosts.\n              *\n              * In FifoPreemptionSelector, there\u0027s no guarantee that preempted\n              * resource can be used by pending request, so policy will preempt\n              * resources repeatly.\n              */\n             .subtract(Resources.add(getUsed(),\n                 (considersReservedResource ? pending : pendingDeductReserved)),\n                 idealAssigned)));\n \n     // For leaf queue: accept \u003d min(accept, max(guaranteed, used) - assigned)\n     // Why only for leaf queue?\n     // Because for a satisfied parent queue, it could have some under-utilized\n     // leaf queues. Such under-utilized leaf queue could preemption resources\n     // from over-utilized leaf queue located at other hierarchies.\n \n-    accepted \u003d filterByMaxDeductAssigned(rc, clusterResource, accepted);\n+    // Allow queues can continue grow and balance even if all queues are satisfied.\n+    if (!allowQueueBalanceAfterAllSafisfied) {\n+      accepted \u003d filterByMaxDeductAssigned(rc, clusterResource, accepted);\n+    }\n \n     // accepted so far contains the \"quota acceptable\" amount, we now filter by\n     // locality acceptable\n \n     accepted \u003d acceptedByLocality(rc, accepted);\n \n     // accept should never be \u003c 0\n     accepted \u003d Resources.componentwiseMax(accepted, Resources.none());\n \n     // or more than offered\n     accepted \u003d Resources.componentwiseMin(accepted, avail);\n \n     Resource remain \u003d Resources.subtract(avail, accepted);\n     Resources.addTo(idealAssigned, accepted);\n     return remain;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  Resource offer(Resource avail, ResourceCalculator rc,\n      Resource clusterResource, boolean considersReservedResource,\n      boolean allowQueueBalanceAfterAllSafisfied) {\n    Resource absMaxCapIdealAssignedDelta \u003d Resources.componentwiseMax(\n        Resources.subtract(getMax(), idealAssigned),\n        Resource.newInstance(0, 0));\n    // accepted \u003d min{avail,\n    //               max - assigned,\n    //               current + pending - assigned,\n    //               # Make sure a queue will not get more than max of its\n    //               # used/guaranteed, this is to make sure preemption won\u0027t\n    //               # happen if all active queues are beyond their guaranteed\n    //               # This is for leaf queue only.\n    //               max(guaranteed, used) - assigned}\n    // remain \u003d avail - accepted\n    Resource accepted \u003d Resources.componentwiseMin(\n        absMaxCapIdealAssignedDelta,\n        Resources.min(rc, clusterResource, avail, Resources\n            /*\n             * When we\u0027re using FifoPreemptionSelector (considerReservedResource\n             * \u003d false).\n             *\n             * We should deduct reserved resource from pending to avoid excessive\n             * preemption:\n             *\n             * For example, if an under-utilized queue has used \u003d reserved \u003d 20.\n             * Preemption policy will try to preempt 20 containers (which is not\n             * satisfied) from different hosts.\n             *\n             * In FifoPreemptionSelector, there\u0027s no guarantee that preempted\n             * resource can be used by pending request, so policy will preempt\n             * resources repeatly.\n             */\n            .subtract(Resources.add(getUsed(),\n                (considersReservedResource ? pending : pendingDeductReserved)),\n                idealAssigned)));\n\n    // For leaf queue: accept \u003d min(accept, max(guaranteed, used) - assigned)\n    // Why only for leaf queue?\n    // Because for a satisfied parent queue, it could have some under-utilized\n    // leaf queues. Such under-utilized leaf queue could preemption resources\n    // from over-utilized leaf queue located at other hierarchies.\n\n    // Allow queues can continue grow and balance even if all queues are satisfied.\n    if (!allowQueueBalanceAfterAllSafisfied) {\n      accepted \u003d filterByMaxDeductAssigned(rc, clusterResource, accepted);\n    }\n\n    // accepted so far contains the \"quota acceptable\" amount, we now filter by\n    // locality acceptable\n\n    accepted \u003d acceptedByLocality(rc, accepted);\n\n    // accept should never be \u003c 0\n    accepted \u003d Resources.componentwiseMax(accepted, Resources.none());\n\n    // or more than offered\n    accepted \u003d Resources.componentwiseMin(accepted, avail);\n\n    Resource remain \u003d Resources.subtract(avail, accepted);\n    Resources.addTo(idealAssigned, accepted);\n    return remain;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/TempQueuePerPartition.java",
          "extendedDetails": {}
        }
      ]
    },
    "8d5509c68156faaa6641f4e747fc9ff80adccf88": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8292: Fix the dominant resource preemption cannot happen when some of the resource vector becomes negative. Contributed by Wangda Tan.\n",
      "commitDate": "25/05/18 9:06 AM",
      "commitName": "8d5509c68156faaa6641f4e747fc9ff80adccf88",
      "commitAuthor": "Eric E Payne",
      "commitDateOld": "22/02/18 6:12 PM",
      "commitNameOld": "514794e1a5a39ca61de3981d53a05547ae17f5e4",
      "commitAuthorOld": "Carlo Curino",
      "daysBetweenCommits": 91.58,
      "commitsBetweenForRepo": 1293,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,59 @@\n   Resource offer(Resource avail, ResourceCalculator rc,\n       Resource clusterResource, boolean considersReservedResource) {\n     Resource absMaxCapIdealAssignedDelta \u003d Resources.componentwiseMax(\n         Resources.subtract(getMax(), idealAssigned),\n         Resource.newInstance(0, 0));\n     // accepted \u003d min{avail,\n     //               max - assigned,\n     //               current + pending - assigned,\n     //               # Make sure a queue will not get more than max of its\n     //               # used/guaranteed, this is to make sure preemption won\u0027t\n     //               # happen if all active queues are beyond their guaranteed\n     //               # This is for leaf queue only.\n     //               max(guaranteed, used) - assigned}\n     // remain \u003d avail - accepted\n-    Resource accepted \u003d Resources.min(rc, clusterResource,\n+    Resource accepted \u003d Resources.componentwiseMin(\n         absMaxCapIdealAssignedDelta,\n         Resources.min(rc, clusterResource, avail, Resources\n             /*\n              * When we\u0027re using FifoPreemptionSelector (considerReservedResource\n              * \u003d false).\n              *\n              * We should deduct reserved resource from pending to avoid excessive\n              * preemption:\n              *\n              * For example, if an under-utilized queue has used \u003d reserved \u003d 20.\n              * Preemption policy will try to preempt 20 containers (which is not\n              * satisfied) from different hosts.\n              *\n              * In FifoPreemptionSelector, there\u0027s no guarantee that preempted\n              * resource can be used by pending request, so policy will preempt\n              * resources repeatly.\n              */\n             .subtract(Resources.add(getUsed(),\n                 (considersReservedResource ? pending : pendingDeductReserved)),\n                 idealAssigned)));\n \n     // For leaf queue: accept \u003d min(accept, max(guaranteed, used) - assigned)\n     // Why only for leaf queue?\n     // Because for a satisfied parent queue, it could have some under-utilized\n     // leaf queues. Such under-utilized leaf queue could preemption resources\n     // from over-utilized leaf queue located at other hierarchies.\n \n     accepted \u003d filterByMaxDeductAssigned(rc, clusterResource, accepted);\n \n     // accepted so far contains the \"quota acceptable\" amount, we now filter by\n     // locality acceptable\n \n     accepted \u003d acceptedByLocality(rc, accepted);\n \n+    // accept should never be \u003c 0\n+    accepted \u003d Resources.componentwiseMax(accepted, Resources.none());\n+\n+    // or more than offered\n+    accepted \u003d Resources.componentwiseMin(accepted, avail);\n+\n     Resource remain \u003d Resources.subtract(avail, accepted);\n     Resources.addTo(idealAssigned, accepted);\n     return remain;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  Resource offer(Resource avail, ResourceCalculator rc,\n      Resource clusterResource, boolean considersReservedResource) {\n    Resource absMaxCapIdealAssignedDelta \u003d Resources.componentwiseMax(\n        Resources.subtract(getMax(), idealAssigned),\n        Resource.newInstance(0, 0));\n    // accepted \u003d min{avail,\n    //               max - assigned,\n    //               current + pending - assigned,\n    //               # Make sure a queue will not get more than max of its\n    //               # used/guaranteed, this is to make sure preemption won\u0027t\n    //               # happen if all active queues are beyond their guaranteed\n    //               # This is for leaf queue only.\n    //               max(guaranteed, used) - assigned}\n    // remain \u003d avail - accepted\n    Resource accepted \u003d Resources.componentwiseMin(\n        absMaxCapIdealAssignedDelta,\n        Resources.min(rc, clusterResource, avail, Resources\n            /*\n             * When we\u0027re using FifoPreemptionSelector (considerReservedResource\n             * \u003d false).\n             *\n             * We should deduct reserved resource from pending to avoid excessive\n             * preemption:\n             *\n             * For example, if an under-utilized queue has used \u003d reserved \u003d 20.\n             * Preemption policy will try to preempt 20 containers (which is not\n             * satisfied) from different hosts.\n             *\n             * In FifoPreemptionSelector, there\u0027s no guarantee that preempted\n             * resource can be used by pending request, so policy will preempt\n             * resources repeatly.\n             */\n            .subtract(Resources.add(getUsed(),\n                (considersReservedResource ? pending : pendingDeductReserved)),\n                idealAssigned)));\n\n    // For leaf queue: accept \u003d min(accept, max(guaranteed, used) - assigned)\n    // Why only for leaf queue?\n    // Because for a satisfied parent queue, it could have some under-utilized\n    // leaf queues. Such under-utilized leaf queue could preemption resources\n    // from over-utilized leaf queue located at other hierarchies.\n\n    accepted \u003d filterByMaxDeductAssigned(rc, clusterResource, accepted);\n\n    // accepted so far contains the \"quota acceptable\" amount, we now filter by\n    // locality acceptable\n\n    accepted \u003d acceptedByLocality(rc, accepted);\n\n    // accept should never be \u003c 0\n    accepted \u003d Resources.componentwiseMax(accepted, Resources.none());\n\n    // or more than offered\n    accepted \u003d Resources.componentwiseMin(accepted, avail);\n\n    Resource remain \u003d Resources.subtract(avail, accepted);\n    Resources.addTo(idealAssigned, accepted);\n    return remain;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/TempQueuePerPartition.java",
      "extendedDetails": {}
    },
    "514794e1a5a39ca61de3981d53a05547ae17f5e4": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7934. [GQ] Refactor preemption calculators to allow overriding for Federation Global Algos. (Contributed by curino)\n",
      "commitDate": "22/02/18 6:12 PM",
      "commitName": "514794e1a5a39ca61de3981d53a05547ae17f5e4",
      "commitAuthor": "Carlo Curino",
      "commitDateOld": "08/12/17 3:10 PM",
      "commitNameOld": "b38643c9a8dd2c53024ae830b9565a550d0ec39c",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 76.13,
      "commitsBetweenForRepo": 438,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,53 @@\n   Resource offer(Resource avail, ResourceCalculator rc,\n       Resource clusterResource, boolean considersReservedResource) {\n     Resource absMaxCapIdealAssignedDelta \u003d Resources.componentwiseMax(\n         Resources.subtract(getMax(), idealAssigned),\n         Resource.newInstance(0, 0));\n     // accepted \u003d min{avail,\n     //               max - assigned,\n     //               current + pending - assigned,\n     //               # Make sure a queue will not get more than max of its\n     //               # used/guaranteed, this is to make sure preemption won\u0027t\n     //               # happen if all active queues are beyond their guaranteed\n     //               # This is for leaf queue only.\n     //               max(guaranteed, used) - assigned}\n     // remain \u003d avail - accepted\n     Resource accepted \u003d Resources.min(rc, clusterResource,\n         absMaxCapIdealAssignedDelta,\n         Resources.min(rc, clusterResource, avail, Resources\n             /*\n              * When we\u0027re using FifoPreemptionSelector (considerReservedResource\n              * \u003d false).\n              *\n              * We should deduct reserved resource from pending to avoid excessive\n              * preemption:\n              *\n              * For example, if an under-utilized queue has used \u003d reserved \u003d 20.\n              * Preemption policy will try to preempt 20 containers (which is not\n              * satisfied) from different hosts.\n              *\n              * In FifoPreemptionSelector, there\u0027s no guarantee that preempted\n              * resource can be used by pending request, so policy will preempt\n              * resources repeatly.\n              */\n             .subtract(Resources.add(getUsed(),\n                 (considersReservedResource ? pending : pendingDeductReserved)),\n                 idealAssigned)));\n \n     // For leaf queue: accept \u003d min(accept, max(guaranteed, used) - assigned)\n     // Why only for leaf queue?\n     // Because for a satisfied parent queue, it could have some under-utilized\n     // leaf queues. Such under-utilized leaf queue could preemption resources\n     // from over-utilized leaf queue located at other hierarchies.\n-    if (null \u003d\u003d children || children.isEmpty()) {\n-      Resource maxOfGuranteedAndUsedDeductAssigned \u003d Resources.subtract(\n-          Resources.max(rc, clusterResource, getUsed(), getGuaranteed()),\n-          idealAssigned);\n-      maxOfGuranteedAndUsedDeductAssigned \u003d Resources.max(rc, clusterResource,\n-          maxOfGuranteedAndUsedDeductAssigned, Resources.none());\n-      accepted \u003d Resources.min(rc, clusterResource, accepted,\n-          maxOfGuranteedAndUsedDeductAssigned);\n-    }\n+\n+    accepted \u003d filterByMaxDeductAssigned(rc, clusterResource, accepted);\n+\n+    // accepted so far contains the \"quota acceptable\" amount, we now filter by\n+    // locality acceptable\n+\n+    accepted \u003d acceptedByLocality(rc, accepted);\n+\n     Resource remain \u003d Resources.subtract(avail, accepted);\n     Resources.addTo(idealAssigned, accepted);\n     return remain;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  Resource offer(Resource avail, ResourceCalculator rc,\n      Resource clusterResource, boolean considersReservedResource) {\n    Resource absMaxCapIdealAssignedDelta \u003d Resources.componentwiseMax(\n        Resources.subtract(getMax(), idealAssigned),\n        Resource.newInstance(0, 0));\n    // accepted \u003d min{avail,\n    //               max - assigned,\n    //               current + pending - assigned,\n    //               # Make sure a queue will not get more than max of its\n    //               # used/guaranteed, this is to make sure preemption won\u0027t\n    //               # happen if all active queues are beyond their guaranteed\n    //               # This is for leaf queue only.\n    //               max(guaranteed, used) - assigned}\n    // remain \u003d avail - accepted\n    Resource accepted \u003d Resources.min(rc, clusterResource,\n        absMaxCapIdealAssignedDelta,\n        Resources.min(rc, clusterResource, avail, Resources\n            /*\n             * When we\u0027re using FifoPreemptionSelector (considerReservedResource\n             * \u003d false).\n             *\n             * We should deduct reserved resource from pending to avoid excessive\n             * preemption:\n             *\n             * For example, if an under-utilized queue has used \u003d reserved \u003d 20.\n             * Preemption policy will try to preempt 20 containers (which is not\n             * satisfied) from different hosts.\n             *\n             * In FifoPreemptionSelector, there\u0027s no guarantee that preempted\n             * resource can be used by pending request, so policy will preempt\n             * resources repeatly.\n             */\n            .subtract(Resources.add(getUsed(),\n                (considersReservedResource ? pending : pendingDeductReserved)),\n                idealAssigned)));\n\n    // For leaf queue: accept \u003d min(accept, max(guaranteed, used) - assigned)\n    // Why only for leaf queue?\n    // Because for a satisfied parent queue, it could have some under-utilized\n    // leaf queues. Such under-utilized leaf queue could preemption resources\n    // from over-utilized leaf queue located at other hierarchies.\n\n    accepted \u003d filterByMaxDeductAssigned(rc, clusterResource, accepted);\n\n    // accepted so far contains the \"quota acceptable\" amount, we now filter by\n    // locality acceptable\n\n    accepted \u003d acceptedByLocality(rc, accepted);\n\n    Resource remain \u003d Resources.subtract(avail, accepted);\n    Resources.addTo(idealAssigned, accepted);\n    return remain;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/TempQueuePerPartition.java",
      "extendedDetails": {}
    },
    "ce832059db077fa95922198b066a737ed4f609fe": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5864. Capacity Scheduler - Queue Priorities. (wangda)\n",
      "commitDate": "23/01/17 10:52 AM",
      "commitName": "ce832059db077fa95922198b066a737ed4f609fe",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "13/01/17 4:52 AM",
      "commitNameOld": "d3170f9eba9bc5c38b5fa50c24e37ca2bd5636c2",
      "commitAuthorOld": "Sunil G",
      "daysBetweenCommits": 10.25,
      "commitsBetweenForRepo": 55,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,32 +1,54 @@\n   Resource offer(Resource avail, ResourceCalculator rc,\n       Resource clusterResource, boolean considersReservedResource) {\n     Resource absMaxCapIdealAssignedDelta \u003d Resources.componentwiseMax(\n         Resources.subtract(getMax(), idealAssigned),\n         Resource.newInstance(0, 0));\n-    // remain \u003d avail - min(avail, (max - assigned), (current + pending -\n-    // assigned))\n+    // accepted \u003d min{avail,\n+    //               max - assigned,\n+    //               current + pending - assigned,\n+    //               # Make sure a queue will not get more than max of its\n+    //               # used/guaranteed, this is to make sure preemption won\u0027t\n+    //               # happen if all active queues are beyond their guaranteed\n+    //               # This is for leaf queue only.\n+    //               max(guaranteed, used) - assigned}\n+    // remain \u003d avail - accepted\n     Resource accepted \u003d Resources.min(rc, clusterResource,\n         absMaxCapIdealAssignedDelta,\n         Resources.min(rc, clusterResource, avail, Resources\n             /*\n              * When we\u0027re using FifoPreemptionSelector (considerReservedResource\n              * \u003d false).\n              *\n              * We should deduct reserved resource from pending to avoid excessive\n              * preemption:\n              *\n              * For example, if an under-utilized queue has used \u003d reserved \u003d 20.\n              * Preemption policy will try to preempt 20 containers (which is not\n              * satisfied) from different hosts.\n              *\n              * In FifoPreemptionSelector, there\u0027s no guarantee that preempted\n              * resource can be used by pending request, so policy will preempt\n              * resources repeatly.\n              */\n             .subtract(Resources.add(getUsed(),\n                 (considersReservedResource ? pending : pendingDeductReserved)),\n                 idealAssigned)));\n+\n+    // For leaf queue: accept \u003d min(accept, max(guaranteed, used) - assigned)\n+    // Why only for leaf queue?\n+    // Because for a satisfied parent queue, it could have some under-utilized\n+    // leaf queues. Such under-utilized leaf queue could preemption resources\n+    // from over-utilized leaf queue located at other hierarchies.\n+    if (null \u003d\u003d children || children.isEmpty()) {\n+      Resource maxOfGuranteedAndUsedDeductAssigned \u003d Resources.subtract(\n+          Resources.max(rc, clusterResource, getUsed(), getGuaranteed()),\n+          idealAssigned);\n+      maxOfGuranteedAndUsedDeductAssigned \u003d Resources.max(rc, clusterResource,\n+          maxOfGuranteedAndUsedDeductAssigned, Resources.none());\n+      accepted \u003d Resources.min(rc, clusterResource, accepted,\n+          maxOfGuranteedAndUsedDeductAssigned);\n+    }\n     Resource remain \u003d Resources.subtract(avail, accepted);\n     Resources.addTo(idealAssigned, accepted);\n     return remain;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  Resource offer(Resource avail, ResourceCalculator rc,\n      Resource clusterResource, boolean considersReservedResource) {\n    Resource absMaxCapIdealAssignedDelta \u003d Resources.componentwiseMax(\n        Resources.subtract(getMax(), idealAssigned),\n        Resource.newInstance(0, 0));\n    // accepted \u003d min{avail,\n    //               max - assigned,\n    //               current + pending - assigned,\n    //               # Make sure a queue will not get more than max of its\n    //               # used/guaranteed, this is to make sure preemption won\u0027t\n    //               # happen if all active queues are beyond their guaranteed\n    //               # This is for leaf queue only.\n    //               max(guaranteed, used) - assigned}\n    // remain \u003d avail - accepted\n    Resource accepted \u003d Resources.min(rc, clusterResource,\n        absMaxCapIdealAssignedDelta,\n        Resources.min(rc, clusterResource, avail, Resources\n            /*\n             * When we\u0027re using FifoPreemptionSelector (considerReservedResource\n             * \u003d false).\n             *\n             * We should deduct reserved resource from pending to avoid excessive\n             * preemption:\n             *\n             * For example, if an under-utilized queue has used \u003d reserved \u003d 20.\n             * Preemption policy will try to preempt 20 containers (which is not\n             * satisfied) from different hosts.\n             *\n             * In FifoPreemptionSelector, there\u0027s no guarantee that preempted\n             * resource can be used by pending request, so policy will preempt\n             * resources repeatly.\n             */\n            .subtract(Resources.add(getUsed(),\n                (considersReservedResource ? pending : pendingDeductReserved)),\n                idealAssigned)));\n\n    // For leaf queue: accept \u003d min(accept, max(guaranteed, used) - assigned)\n    // Why only for leaf queue?\n    // Because for a satisfied parent queue, it could have some under-utilized\n    // leaf queues. Such under-utilized leaf queue could preemption resources\n    // from over-utilized leaf queue located at other hierarchies.\n    if (null \u003d\u003d children || children.isEmpty()) {\n      Resource maxOfGuranteedAndUsedDeductAssigned \u003d Resources.subtract(\n          Resources.max(rc, clusterResource, getUsed(), getGuaranteed()),\n          idealAssigned);\n      maxOfGuranteedAndUsedDeductAssigned \u003d Resources.max(rc, clusterResource,\n          maxOfGuranteedAndUsedDeductAssigned, Resources.none());\n      accepted \u003d Resources.min(rc, clusterResource, accepted,\n          maxOfGuranteedAndUsedDeductAssigned);\n    }\n    Resource remain \u003d Resources.subtract(avail, accepted);\n    Resources.addTo(idealAssigned, accepted);\n    return remain;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/TempQueuePerPartition.java",
      "extendedDetails": {}
    },
    "d3170f9eba9bc5c38b5fa50c24e37ca2bd5636c2": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6081. LeafQueue#getTotalPendingResourcesConsideringUserLimit should deduct reserved from pending to avoid unnecessary preemption of reserved container. Contributed by Wangda Tan.\n",
      "commitDate": "13/01/17 4:52 AM",
      "commitName": "d3170f9eba9bc5c38b5fa50c24e37ca2bd5636c2",
      "commitAuthor": "Sunil G",
      "commitDateOld": "31/10/16 3:18 PM",
      "commitNameOld": "90dd3a8148468ac37a3f2173ad8d45e38bfcb0c9",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 73.61,
      "commitsBetweenForRepo": 446,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,33 +1,32 @@\n   Resource offer(Resource avail, ResourceCalculator rc,\n       Resource clusterResource, boolean considersReservedResource) {\n     Resource absMaxCapIdealAssignedDelta \u003d Resources.componentwiseMax(\n         Resources.subtract(getMax(), idealAssigned),\n         Resource.newInstance(0, 0));\n     // remain \u003d avail - min(avail, (max - assigned), (current + pending -\n     // assigned))\n     Resource accepted \u003d Resources.min(rc, clusterResource,\n         absMaxCapIdealAssignedDelta,\n         Resources.min(rc, clusterResource, avail, Resources\n             /*\n              * When we\u0027re using FifoPreemptionSelector (considerReservedResource\n              * \u003d false).\n              *\n-             * We should deduct reserved resource to avoid excessive preemption:\n+             * We should deduct reserved resource from pending to avoid excessive\n+             * preemption:\n              *\n              * For example, if an under-utilized queue has used \u003d reserved \u003d 20.\n              * Preemption policy will try to preempt 20 containers (which is not\n              * satisfied) from different hosts.\n              *\n              * In FifoPreemptionSelector, there\u0027s no guarantee that preempted\n              * resource can be used by pending request, so policy will preempt\n              * resources repeatly.\n              */\n-            .subtract(\n-                Resources.add((considersReservedResource\n-                    ? getUsed()\n-                    : getUsedDeductReservd()), pending),\n+            .subtract(Resources.add(getUsed(),\n+                (considersReservedResource ? pending : pendingDeductReserved)),\n                 idealAssigned)));\n     Resource remain \u003d Resources.subtract(avail, accepted);\n     Resources.addTo(idealAssigned, accepted);\n     return remain;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  Resource offer(Resource avail, ResourceCalculator rc,\n      Resource clusterResource, boolean considersReservedResource) {\n    Resource absMaxCapIdealAssignedDelta \u003d Resources.componentwiseMax(\n        Resources.subtract(getMax(), idealAssigned),\n        Resource.newInstance(0, 0));\n    // remain \u003d avail - min(avail, (max - assigned), (current + pending -\n    // assigned))\n    Resource accepted \u003d Resources.min(rc, clusterResource,\n        absMaxCapIdealAssignedDelta,\n        Resources.min(rc, clusterResource, avail, Resources\n            /*\n             * When we\u0027re using FifoPreemptionSelector (considerReservedResource\n             * \u003d false).\n             *\n             * We should deduct reserved resource from pending to avoid excessive\n             * preemption:\n             *\n             * For example, if an under-utilized queue has used \u003d reserved \u003d 20.\n             * Preemption policy will try to preempt 20 containers (which is not\n             * satisfied) from different hosts.\n             *\n             * In FifoPreemptionSelector, there\u0027s no guarantee that preempted\n             * resource can be used by pending request, so policy will preempt\n             * resources repeatly.\n             */\n            .subtract(Resources.add(getUsed(),\n                (considersReservedResource ? pending : pendingDeductReserved)),\n                idealAssigned)));\n    Resource remain \u003d Resources.subtract(avail, accepted);\n    Resources.addTo(idealAssigned, accepted);\n    return remain;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/TempQueuePerPartition.java",
      "extendedDetails": {}
    },
    "90dd3a8148468ac37a3f2173ad8d45e38bfcb0c9": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2009. CapacityScheduler: Add intra-queue preemption for app priority support. (Sunil G via wangda)\n",
      "commitDate": "31/10/16 3:18 PM",
      "commitName": "90dd3a8148468ac37a3f2173ad8d45e38bfcb0c9",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "29/05/16 8:54 AM",
      "commitNameOld": "42f90ab885d9693fcc1e52f9637f7de4111110ae",
      "commitAuthorOld": "Varun Vasudev",
      "daysBetweenCommits": 155.27,
      "commitsBetweenForRepo": 1196,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,31 +1,33 @@\n   Resource offer(Resource avail, ResourceCalculator rc,\n       Resource clusterResource, boolean considersReservedResource) {\n     Resource absMaxCapIdealAssignedDelta \u003d Resources.componentwiseMax(\n         Resources.subtract(getMax(), idealAssigned),\n         Resource.newInstance(0, 0));\n-    // remain \u003d avail - min(avail, (max - assigned), (current + pending - assigned))\n+    // remain \u003d avail - min(avail, (max - assigned), (current + pending -\n+    // assigned))\n     Resource accepted \u003d Resources.min(rc, clusterResource,\n-        absMaxCapIdealAssignedDelta, Resources.min(rc, clusterResource, avail,\n-            Resources\n-                /*\n-                 * When we\u0027re using FifoPreemptionSelector\n-                 * (considerReservedResource \u003d false).\n-                 *\n-                 * We should deduct reserved resource to avoid excessive preemption:\n-                 *\n-                 * For example, if an under-utilized queue has used \u003d reserved \u003d 20.\n-                 * Preemption policy will try to preempt 20 containers\n-                 * (which is not satisfied) from different hosts.\n-                 *\n-                 * In FifoPreemptionSelector, there\u0027s no guarantee that preempted\n-                 * resource can be used by pending request, so policy will preempt\n-                 * resources repeatly.\n-                 */\n-                .subtract(Resources.add(\n-                    (considersReservedResource ? getUsed() :\n-                      getUsedDeductReservd()),\n-                    pending), idealAssigned)));\n+        absMaxCapIdealAssignedDelta,\n+        Resources.min(rc, clusterResource, avail, Resources\n+            /*\n+             * When we\u0027re using FifoPreemptionSelector (considerReservedResource\n+             * \u003d false).\n+             *\n+             * We should deduct reserved resource to avoid excessive preemption:\n+             *\n+             * For example, if an under-utilized queue has used \u003d reserved \u003d 20.\n+             * Preemption policy will try to preempt 20 containers (which is not\n+             * satisfied) from different hosts.\n+             *\n+             * In FifoPreemptionSelector, there\u0027s no guarantee that preempted\n+             * resource can be used by pending request, so policy will preempt\n+             * resources repeatly.\n+             */\n+            .subtract(\n+                Resources.add((considersReservedResource\n+                    ? getUsed()\n+                    : getUsedDeductReservd()), pending),\n+                idealAssigned)));\n     Resource remain \u003d Resources.subtract(avail, accepted);\n     Resources.addTo(idealAssigned, accepted);\n     return remain;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  Resource offer(Resource avail, ResourceCalculator rc,\n      Resource clusterResource, boolean considersReservedResource) {\n    Resource absMaxCapIdealAssignedDelta \u003d Resources.componentwiseMax(\n        Resources.subtract(getMax(), idealAssigned),\n        Resource.newInstance(0, 0));\n    // remain \u003d avail - min(avail, (max - assigned), (current + pending -\n    // assigned))\n    Resource accepted \u003d Resources.min(rc, clusterResource,\n        absMaxCapIdealAssignedDelta,\n        Resources.min(rc, clusterResource, avail, Resources\n            /*\n             * When we\u0027re using FifoPreemptionSelector (considerReservedResource\n             * \u003d false).\n             *\n             * We should deduct reserved resource to avoid excessive preemption:\n             *\n             * For example, if an under-utilized queue has used \u003d reserved \u003d 20.\n             * Preemption policy will try to preempt 20 containers (which is not\n             * satisfied) from different hosts.\n             *\n             * In FifoPreemptionSelector, there\u0027s no guarantee that preempted\n             * resource can be used by pending request, so policy will preempt\n             * resources repeatly.\n             */\n            .subtract(\n                Resources.add((considersReservedResource\n                    ? getUsed()\n                    : getUsedDeductReservd()), pending),\n                idealAssigned)));\n    Resource remain \u003d Resources.subtract(avail, accepted);\n    Resources.addTo(idealAssigned, accepted);\n    return remain;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/TempQueuePerPartition.java",
      "extendedDetails": {}
    },
    "bb62e0592566b2fcae7136b30972aad2d3ac55b0": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-4390. Do surgical preemption based on reserved container in CapacityScheduler. Contributed by Wangda Tan\n",
      "commitDate": "05/05/16 12:56 PM",
      "commitName": "bb62e0592566b2fcae7136b30972aad2d3ac55b0",
      "commitAuthor": "Jian He",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-4390. Do surgical preemption based on reserved container in CapacityScheduler. Contributed by Wangda Tan\n",
          "commitDate": "05/05/16 12:56 PM",
          "commitName": "bb62e0592566b2fcae7136b30972aad2d3ac55b0",
          "commitAuthor": "Jian He",
          "commitDateOld": "30/03/16 12:43 PM",
          "commitNameOld": "60e4116bf1d00afed91010e57357fe54057e4e39",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 36.01,
          "commitsBetweenForRepo": 225,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,15 +1,31 @@\n   Resource offer(Resource avail, ResourceCalculator rc,\n-      Resource clusterResource) {\n+      Resource clusterResource, boolean considersReservedResource) {\n     Resource absMaxCapIdealAssignedDelta \u003d Resources.componentwiseMax(\n-        Resources.subtract(maxCapacity, idealAssigned),\n+        Resources.subtract(getMax(), idealAssigned),\n         Resource.newInstance(0, 0));\n     // remain \u003d avail - min(avail, (max - assigned), (current + pending - assigned))\n-    Resource accepted \u003d\n-        Resources.min(rc, clusterResource,\n-            absMaxCapIdealAssignedDelta,\n-            Resources.min(rc, clusterResource, avail, Resources.subtract(\n-                Resources.add(current, pending), idealAssigned)));\n+    Resource accepted \u003d Resources.min(rc, clusterResource,\n+        absMaxCapIdealAssignedDelta, Resources.min(rc, clusterResource, avail,\n+            Resources\n+                /*\n+                 * When we\u0027re using FifoPreemptionSelector\n+                 * (considerReservedResource \u003d false).\n+                 *\n+                 * We should deduct reserved resource to avoid excessive preemption:\n+                 *\n+                 * For example, if an under-utilized queue has used \u003d reserved \u003d 20.\n+                 * Preemption policy will try to preempt 20 containers\n+                 * (which is not satisfied) from different hosts.\n+                 *\n+                 * In FifoPreemptionSelector, there\u0027s no guarantee that preempted\n+                 * resource can be used by pending request, so policy will preempt\n+                 * resources repeatly.\n+                 */\n+                .subtract(Resources.add(\n+                    (considersReservedResource ? getUsed() :\n+                      getUsedDeductReservd()),\n+                    pending), idealAssigned)));\n     Resource remain \u003d Resources.subtract(avail, accepted);\n     Resources.addTo(idealAssigned, accepted);\n     return remain;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  Resource offer(Resource avail, ResourceCalculator rc,\n      Resource clusterResource, boolean considersReservedResource) {\n    Resource absMaxCapIdealAssignedDelta \u003d Resources.componentwiseMax(\n        Resources.subtract(getMax(), idealAssigned),\n        Resource.newInstance(0, 0));\n    // remain \u003d avail - min(avail, (max - assigned), (current + pending - assigned))\n    Resource accepted \u003d Resources.min(rc, clusterResource,\n        absMaxCapIdealAssignedDelta, Resources.min(rc, clusterResource, avail,\n            Resources\n                /*\n                 * When we\u0027re using FifoPreemptionSelector\n                 * (considerReservedResource \u003d false).\n                 *\n                 * We should deduct reserved resource to avoid excessive preemption:\n                 *\n                 * For example, if an under-utilized queue has used \u003d reserved \u003d 20.\n                 * Preemption policy will try to preempt 20 containers\n                 * (which is not satisfied) from different hosts.\n                 *\n                 * In FifoPreemptionSelector, there\u0027s no guarantee that preempted\n                 * resource can be used by pending request, so policy will preempt\n                 * resources repeatly.\n                 */\n                .subtract(Resources.add(\n                    (considersReservedResource ? getUsed() :\n                      getUsedDeductReservd()),\n                    pending), idealAssigned)));\n    Resource remain \u003d Resources.subtract(avail, accepted);\n    Resources.addTo(idealAssigned, accepted);\n    return remain;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/TempQueuePerPartition.java",
          "extendedDetails": {
            "oldValue": "[avail-Resource, rc-ResourceCalculator, clusterResource-Resource]",
            "newValue": "[avail-Resource, rc-ResourceCalculator, clusterResource-Resource, considersReservedResource-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-4390. Do surgical preemption based on reserved container in CapacityScheduler. Contributed by Wangda Tan\n",
          "commitDate": "05/05/16 12:56 PM",
          "commitName": "bb62e0592566b2fcae7136b30972aad2d3ac55b0",
          "commitAuthor": "Jian He",
          "commitDateOld": "30/03/16 12:43 PM",
          "commitNameOld": "60e4116bf1d00afed91010e57357fe54057e4e39",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 36.01,
          "commitsBetweenForRepo": 225,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,15 +1,31 @@\n   Resource offer(Resource avail, ResourceCalculator rc,\n-      Resource clusterResource) {\n+      Resource clusterResource, boolean considersReservedResource) {\n     Resource absMaxCapIdealAssignedDelta \u003d Resources.componentwiseMax(\n-        Resources.subtract(maxCapacity, idealAssigned),\n+        Resources.subtract(getMax(), idealAssigned),\n         Resource.newInstance(0, 0));\n     // remain \u003d avail - min(avail, (max - assigned), (current + pending - assigned))\n-    Resource accepted \u003d\n-        Resources.min(rc, clusterResource,\n-            absMaxCapIdealAssignedDelta,\n-            Resources.min(rc, clusterResource, avail, Resources.subtract(\n-                Resources.add(current, pending), idealAssigned)));\n+    Resource accepted \u003d Resources.min(rc, clusterResource,\n+        absMaxCapIdealAssignedDelta, Resources.min(rc, clusterResource, avail,\n+            Resources\n+                /*\n+                 * When we\u0027re using FifoPreemptionSelector\n+                 * (considerReservedResource \u003d false).\n+                 *\n+                 * We should deduct reserved resource to avoid excessive preemption:\n+                 *\n+                 * For example, if an under-utilized queue has used \u003d reserved \u003d 20.\n+                 * Preemption policy will try to preempt 20 containers\n+                 * (which is not satisfied) from different hosts.\n+                 *\n+                 * In FifoPreemptionSelector, there\u0027s no guarantee that preempted\n+                 * resource can be used by pending request, so policy will preempt\n+                 * resources repeatly.\n+                 */\n+                .subtract(Resources.add(\n+                    (considersReservedResource ? getUsed() :\n+                      getUsedDeductReservd()),\n+                    pending), idealAssigned)));\n     Resource remain \u003d Resources.subtract(avail, accepted);\n     Resources.addTo(idealAssigned, accepted);\n     return remain;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  Resource offer(Resource avail, ResourceCalculator rc,\n      Resource clusterResource, boolean considersReservedResource) {\n    Resource absMaxCapIdealAssignedDelta \u003d Resources.componentwiseMax(\n        Resources.subtract(getMax(), idealAssigned),\n        Resource.newInstance(0, 0));\n    // remain \u003d avail - min(avail, (max - assigned), (current + pending - assigned))\n    Resource accepted \u003d Resources.min(rc, clusterResource,\n        absMaxCapIdealAssignedDelta, Resources.min(rc, clusterResource, avail,\n            Resources\n                /*\n                 * When we\u0027re using FifoPreemptionSelector\n                 * (considerReservedResource \u003d false).\n                 *\n                 * We should deduct reserved resource to avoid excessive preemption:\n                 *\n                 * For example, if an under-utilized queue has used \u003d reserved \u003d 20.\n                 * Preemption policy will try to preempt 20 containers\n                 * (which is not satisfied) from different hosts.\n                 *\n                 * In FifoPreemptionSelector, there\u0027s no guarantee that preempted\n                 * resource can be used by pending request, so policy will preempt\n                 * resources repeatly.\n                 */\n                .subtract(Resources.add(\n                    (considersReservedResource ? getUsed() :\n                      getUsedDeductReservd()),\n                    pending), idealAssigned)));\n    Resource remain \u003d Resources.subtract(avail, accepted);\n    Resources.addTo(idealAssigned, accepted);\n    return remain;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/TempQueuePerPartition.java",
          "extendedDetails": {}
        }
      ]
    },
    "60e4116bf1d00afed91010e57357fe54057e4e39": {
      "type": "Ymovefromfile",
      "commitMessage": "YARN-4822. Refactor existing Preemption Policy of CS for easier adding new approach to select preemption candidates. Contributed by Wangda Tan\n",
      "commitDate": "30/03/16 12:43 PM",
      "commitName": "60e4116bf1d00afed91010e57357fe54057e4e39",
      "commitAuthor": "Jian He",
      "commitDateOld": "29/03/16 11:22 PM",
      "commitNameOld": "09d63d5a192b5d6b172f94ff6c94da348fd49ea6",
      "commitAuthorOld": "Vinayakumar B",
      "daysBetweenCommits": 0.56,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,15 +1,15 @@\n-    Resource offer(Resource avail, ResourceCalculator rc,\n-        Resource clusterResource) {\n-      Resource absMaxCapIdealAssignedDelta \u003d Resources.componentwiseMax(\n-                      Resources.subtract(maxCapacity, idealAssigned),\n-                      Resource.newInstance(0, 0));\n-      // remain \u003d avail - min(avail, (max - assigned), (current + pending - assigned))\n-      Resource accepted \u003d \n-          Resources.min(rc, clusterResource, \n-              absMaxCapIdealAssignedDelta,\n-          Resources.min(rc, clusterResource, avail, Resources.subtract(\n-              Resources.add(current, pending), idealAssigned)));\n-      Resource remain \u003d Resources.subtract(avail, accepted);\n-      Resources.addTo(idealAssigned, accepted);\n-      return remain;\n-    }\n\\ No newline at end of file\n+  Resource offer(Resource avail, ResourceCalculator rc,\n+      Resource clusterResource) {\n+    Resource absMaxCapIdealAssignedDelta \u003d Resources.componentwiseMax(\n+        Resources.subtract(maxCapacity, idealAssigned),\n+        Resource.newInstance(0, 0));\n+    // remain \u003d avail - min(avail, (max - assigned), (current + pending - assigned))\n+    Resource accepted \u003d\n+        Resources.min(rc, clusterResource,\n+            absMaxCapIdealAssignedDelta,\n+            Resources.min(rc, clusterResource, avail, Resources.subtract(\n+                Resources.add(current, pending), idealAssigned)));\n+    Resource remain \u003d Resources.subtract(avail, accepted);\n+    Resources.addTo(idealAssigned, accepted);\n+    return remain;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  Resource offer(Resource avail, ResourceCalculator rc,\n      Resource clusterResource) {\n    Resource absMaxCapIdealAssignedDelta \u003d Resources.componentwiseMax(\n        Resources.subtract(maxCapacity, idealAssigned),\n        Resource.newInstance(0, 0));\n    // remain \u003d avail - min(avail, (max - assigned), (current + pending - assigned))\n    Resource accepted \u003d\n        Resources.min(rc, clusterResource,\n            absMaxCapIdealAssignedDelta,\n            Resources.min(rc, clusterResource, avail, Resources.subtract(\n                Resources.add(current, pending), idealAssigned)));\n    Resource remain \u003d Resources.subtract(avail, accepted);\n    Resources.addTo(idealAssigned, accepted);\n    return remain;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/TempQueuePerPartition.java",
      "extendedDetails": {
        "oldPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/TempQueuePerPartition.java",
        "oldMethodName": "offer",
        "newMethodName": "offer"
      }
    },
    "27e8ea820fab8dce59f4db9814e73bd60c1d4ef1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3275. CapacityScheduler: Preemption happening on non-preemptable queues. Contributed by Eric Payne\n",
      "commitDate": "06/03/15 2:37 PM",
      "commitName": "27e8ea820fab8dce59f4db9814e73bd60c1d4ef1",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "27/01/15 3:36 PM",
      "commitNameOld": "18741adf97f4fda5f8743318b59c440928e51297",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 37.96,
      "commitsBetweenForRepo": 378,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,12 +1,15 @@\n     Resource offer(Resource avail, ResourceCalculator rc,\n         Resource clusterResource) {\n+      Resource absMaxCapIdealAssignedDelta \u003d Resources.componentwiseMax(\n+                      Resources.subtract(maxCapacity, idealAssigned),\n+                      Resource.newInstance(0, 0));\n       // remain \u003d avail - min(avail, (max - assigned), (current + pending - assigned))\n       Resource accepted \u003d \n           Resources.min(rc, clusterResource, \n-              Resources.subtract(maxCapacity, idealAssigned),\n+              absMaxCapIdealAssignedDelta,\n           Resources.min(rc, clusterResource, avail, Resources.subtract(\n               Resources.add(current, pending), idealAssigned)));\n       Resource remain \u003d Resources.subtract(avail, accepted);\n       Resources.addTo(idealAssigned, accepted);\n       return remain;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    Resource offer(Resource avail, ResourceCalculator rc,\n        Resource clusterResource) {\n      Resource absMaxCapIdealAssignedDelta \u003d Resources.componentwiseMax(\n                      Resources.subtract(maxCapacity, idealAssigned),\n                      Resource.newInstance(0, 0));\n      // remain \u003d avail - min(avail, (max - assigned), (current + pending - assigned))\n      Resource accepted \u003d \n          Resources.min(rc, clusterResource, \n              absMaxCapIdealAssignedDelta,\n          Resources.min(rc, clusterResource, avail, Resources.subtract(\n              Resources.add(current, pending), idealAssigned)));\n      Resource remain \u003d Resources.subtract(avail, accepted);\n      Resources.addTo(idealAssigned, accepted);\n      return remain;\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java",
      "extendedDetails": {}
    },
    "45b42676f9333ed4fa05355ccb4e1f91a9556525": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1957. Consider the max capacity of the queue when computing the ideal\ncapacity for preemption. Contributed by Carlo Curino\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1594414 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "13/05/14 4:15 PM",
      "commitName": "45b42676f9333ed4fa05355ccb4e1f91a9556525",
      "commitAuthor": "Christopher Douglas",
      "commitDateOld": "10/07/13 6:20 PM",
      "commitNameOld": "85f0efb68f9d1d9ee3466e3939c4fc2f985ccf61",
      "commitAuthorOld": "Christopher Douglas",
      "daysBetweenCommits": 306.91,
      "commitsBetweenForRepo": 2071,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,12 +1,12 @@\n     Resource offer(Resource avail, ResourceCalculator rc,\n         Resource clusterResource) {\n-      // remain \u003d avail - min(avail, current + pending - assigned)\n-      Resource accepted \u003d Resources.min(rc, clusterResource,\n-          avail,\n-          Resources.subtract(\n-              Resources.add(current, pending),\n-              idealAssigned));\n+      // remain \u003d avail - min(avail, (max - assigned), (current + pending - assigned))\n+      Resource accepted \u003d \n+          Resources.min(rc, clusterResource, \n+              Resources.subtract(maxCapacity, idealAssigned),\n+          Resources.min(rc, clusterResource, avail, Resources.subtract(\n+              Resources.add(current, pending), idealAssigned)));\n       Resource remain \u003d Resources.subtract(avail, accepted);\n       Resources.addTo(idealAssigned, accepted);\n       return remain;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    Resource offer(Resource avail, ResourceCalculator rc,\n        Resource clusterResource) {\n      // remain \u003d avail - min(avail, (max - assigned), (current + pending - assigned))\n      Resource accepted \u003d \n          Resources.min(rc, clusterResource, \n              Resources.subtract(maxCapacity, idealAssigned),\n          Resources.min(rc, clusterResource, avail, Resources.subtract(\n              Resources.add(current, pending), idealAssigned)));\n      Resource remain \u003d Resources.subtract(avail, accepted);\n      Resources.addTo(idealAssigned, accepted);\n      return remain;\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java",
      "extendedDetails": {}
    },
    "85f0efb68f9d1d9ee3466e3939c4fc2f985ccf61": {
      "type": "Yintroduced",
      "commitMessage": "YARN-569. Add support for requesting and enforcing preemption requests via\na capacity monitor. Contributed by Carlo Curino, Chris Douglas\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1502083 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/07/13 6:20 PM",
      "commitName": "85f0efb68f9d1d9ee3466e3939c4fc2f985ccf61",
      "commitAuthor": "Christopher Douglas",
      "diff": "@@ -0,0 +1,12 @@\n+    Resource offer(Resource avail, ResourceCalculator rc,\n+        Resource clusterResource) {\n+      // remain \u003d avail - min(avail, current + pending - assigned)\n+      Resource accepted \u003d Resources.min(rc, clusterResource,\n+          avail,\n+          Resources.subtract(\n+              Resources.add(current, pending),\n+              idealAssigned));\n+      Resource remain \u003d Resources.subtract(avail, accepted);\n+      Resources.addTo(idealAssigned, accepted);\n+      return remain;\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    Resource offer(Resource avail, ResourceCalculator rc,\n        Resource clusterResource) {\n      // remain \u003d avail - min(avail, current + pending - assigned)\n      Resource accepted \u003d Resources.min(rc, clusterResource,\n          avail,\n          Resources.subtract(\n              Resources.add(current, pending),\n              idealAssigned));\n      Resource remain \u003d Resources.subtract(avail, accepted);\n      Resources.addTo(idealAssigned, accepted);\n      return remain;\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ProportionalCapacityPreemptionPolicy.java"
    }
  }
}