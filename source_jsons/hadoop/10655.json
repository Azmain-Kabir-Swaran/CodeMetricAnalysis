{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "AbstractFuture.java",
  "functionName": "get",
  "functionId": "get___timeout-long__unit-TimeUnit",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/checker/AbstractFuture.java",
  "functionStartLine": 414,
  "functionEndLine": 485,
  "numCommitsSeen": 4,
  "timeTaken": 765,
  "changeHistory": [
    "d69a82c89c1e857a2a86ff614ae11fb5df993614"
  ],
  "changeHistoryShort": {
    "d69a82c89c1e857a2a86ff614ae11fb5df993614": "Yintroduced"
  },
  "changeHistoryDetails": {
    "d69a82c89c1e857a2a86ff614ae11fb5df993614": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-11511. Support Timeout when checking single disk. Contributed by Hanisha Koneru.\n",
      "commitDate": "15/03/17 6:01 PM",
      "commitName": "d69a82c89c1e857a2a86ff614ae11fb5df993614",
      "commitAuthor": "Hanisha Koneru",
      "diff": "@@ -0,0 +1,72 @@\n+  public V get(long timeout, TimeUnit unit)\n+      throws InterruptedException, TimeoutException, ExecutionException {\n+    // NOTE: if timeout \u003c 0, remainingNanos will be \u003c 0 and we will fall into\n+    // the while(true) loop at the bottom and throw a timeoutexception.\n+    long remainingNanos \u003d unit\n+        .toNanos(timeout); // we rely on the implicit null check on unit.\n+    if (Thread.interrupted()) {\n+      throw new InterruptedException();\n+    }\n+    Object localValue \u003d value;\n+    if (localValue !\u003d null \u0026 !(localValue instanceof SetFuture)) {\n+      return getDoneValue(localValue);\n+    }\n+    // we delay calling nanoTime until we know we will need to either park or\n+    // spin\n+    final long endNanos \u003d remainingNanos \u003e 0 ? System\n+        .nanoTime() + remainingNanos : 0;\n+    long_wait_loop:\n+    if (remainingNanos \u003e\u003d SPIN_THRESHOLD_NANOS) {\n+      Waiter oldHead \u003d waiters;\n+      if (oldHead !\u003d Waiter.TOMBSTONE) {\n+        Waiter node \u003d new Waiter();\n+        do {\n+          node.setNext(oldHead);\n+          if (ATOMIC_HELPER.casWaiters(this, oldHead, node)) {\n+            while (true) {\n+              LockSupport.parkNanos(this, remainingNanos);\n+              // Check interruption first, if we woke up due to interruption\n+              // we need to honor that.\n+              if (Thread.interrupted()) {\n+                removeWaiter(node);\n+                throw new InterruptedException();\n+              }\n+\n+              // Otherwise re-read and check doneness. If we loop then it must\n+              // have been a spurious wakeup\n+              localValue \u003d value;\n+              if (localValue !\u003d null \u0026 !(localValue instanceof SetFuture)) {\n+                return getDoneValue(localValue);\n+              }\n+\n+              // timed out?\n+              remainingNanos \u003d endNanos - System.nanoTime();\n+              if (remainingNanos \u003c SPIN_THRESHOLD_NANOS) {\n+                // Remove the waiter, one way or another we are done parking\n+                // this thread.\n+                removeWaiter(node);\n+                break long_wait_loop; // jump down to the busy wait loop\n+              }\n+            }\n+          }\n+          oldHead \u003d waiters; // re-read and loop.\n+        } while (oldHead !\u003d Waiter.TOMBSTONE);\n+      }\n+      // re-read value, if we get here then we must have observed a TOMBSTONE\n+      // while trying to add a waiter.\n+      return getDoneValue(value);\n+    }\n+    // If we get here then we have remainingNanos \u003c SPIN_THRESHOLD_NANOS and\n+    // there is no node on the waiters list\n+    while (remainingNanos \u003e 0) {\n+      localValue \u003d value;\n+      if (localValue !\u003d null \u0026 !(localValue instanceof SetFuture)) {\n+        return getDoneValue(localValue);\n+      }\n+      if (Thread.interrupted()) {\n+        throw new InterruptedException();\n+      }\n+      remainingNanos \u003d endNanos - System.nanoTime();\n+    }\n+    throw new TimeoutException();\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public V get(long timeout, TimeUnit unit)\n      throws InterruptedException, TimeoutException, ExecutionException {\n    // NOTE: if timeout \u003c 0, remainingNanos will be \u003c 0 and we will fall into\n    // the while(true) loop at the bottom and throw a timeoutexception.\n    long remainingNanos \u003d unit\n        .toNanos(timeout); // we rely on the implicit null check on unit.\n    if (Thread.interrupted()) {\n      throw new InterruptedException();\n    }\n    Object localValue \u003d value;\n    if (localValue !\u003d null \u0026 !(localValue instanceof SetFuture)) {\n      return getDoneValue(localValue);\n    }\n    // we delay calling nanoTime until we know we will need to either park or\n    // spin\n    final long endNanos \u003d remainingNanos \u003e 0 ? System\n        .nanoTime() + remainingNanos : 0;\n    long_wait_loop:\n    if (remainingNanos \u003e\u003d SPIN_THRESHOLD_NANOS) {\n      Waiter oldHead \u003d waiters;\n      if (oldHead !\u003d Waiter.TOMBSTONE) {\n        Waiter node \u003d new Waiter();\n        do {\n          node.setNext(oldHead);\n          if (ATOMIC_HELPER.casWaiters(this, oldHead, node)) {\n            while (true) {\n              LockSupport.parkNanos(this, remainingNanos);\n              // Check interruption first, if we woke up due to interruption\n              // we need to honor that.\n              if (Thread.interrupted()) {\n                removeWaiter(node);\n                throw new InterruptedException();\n              }\n\n              // Otherwise re-read and check doneness. If we loop then it must\n              // have been a spurious wakeup\n              localValue \u003d value;\n              if (localValue !\u003d null \u0026 !(localValue instanceof SetFuture)) {\n                return getDoneValue(localValue);\n              }\n\n              // timed out?\n              remainingNanos \u003d endNanos - System.nanoTime();\n              if (remainingNanos \u003c SPIN_THRESHOLD_NANOS) {\n                // Remove the waiter, one way or another we are done parking\n                // this thread.\n                removeWaiter(node);\n                break long_wait_loop; // jump down to the busy wait loop\n              }\n            }\n          }\n          oldHead \u003d waiters; // re-read and loop.\n        } while (oldHead !\u003d Waiter.TOMBSTONE);\n      }\n      // re-read value, if we get here then we must have observed a TOMBSTONE\n      // while trying to add a waiter.\n      return getDoneValue(value);\n    }\n    // If we get here then we have remainingNanos \u003c SPIN_THRESHOLD_NANOS and\n    // there is no node on the waiters list\n    while (remainingNanos \u003e 0) {\n      localValue \u003d value;\n      if (localValue !\u003d null \u0026 !(localValue instanceof SetFuture)) {\n        return getDoneValue(localValue);\n      }\n      if (Thread.interrupted()) {\n        throw new InterruptedException();\n      }\n      remainingNanos \u003d endNanos - System.nanoTime();\n    }\n    throw new TimeoutException();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/checker/AbstractFuture.java"
    }
  }
}