{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "InodeTree.java",
  "functionName": "resolve",
  "functionId": "resolve___p-String(modifiers-final)__resolveLastComponent-boolean(modifiers-final)",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/viewfs/InodeTree.java",
  "functionStartLine": 643,
  "functionEndLine": 733,
  "numCommitsSeen": 13,
  "timeTaken": 2250,
  "changeHistory": [
    "133d7ca76e3d4b60292d57429d4259e80bec650a",
    "b91305119b434d23b99ae7e755aea6639f48b6ab",
    "0f4afc81009129bbee89d5b6cf22c8dda612d223",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
    "f1c74df922058e88791ed6971bbb96b53f6770f1"
  ],
  "changeHistoryShort": {
    "133d7ca76e3d4b60292d57429d4259e80bec650a": "Ybodychange",
    "b91305119b434d23b99ae7e755aea6639f48b6ab": "Ybodychange",
    "0f4afc81009129bbee89d5b6cf22c8dda612d223": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52": "Yfilerename",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yfilerename",
    "f1c74df922058e88791ed6971bbb96b53f6770f1": "Yintroduced"
  },
  "changeHistoryDetails": {
    "133d7ca76e3d4b60292d57429d4259e80bec650a": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13055. Implement linkMergeSlash and linkFallback for ViewFileSystem\n",
      "commitDate": "13/10/17 5:43 PM",
      "commitName": "133d7ca76e3d4b60292d57429d4259e80bec650a",
      "commitAuthor": "Manoj Govindassamy",
      "commitDateOld": "03/10/17 11:23 AM",
      "commitNameOld": "b91305119b434d23b99ae7e755aea6639f48b6ab",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 10.26,
      "commitsBetweenForRepo": 105,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,65 +1,91 @@\n   ResolveResult\u003cT\u003e resolve(final String p, final boolean resolveLastComponent)\n       throws FileNotFoundException {\n     String[] path \u003d breakIntoPathComponents(p);\n     if (path.length \u003c\u003d 1) { // special case for when path is \"/\"\n-      ResolveResult\u003cT\u003e res \u003d\n-          new ResolveResult\u003cT\u003e(ResultKind.INTERNAL_DIR,\n-              root.InodeDirFs, root.fullPath, SlashPath);\n+      T targetFs \u003d root.isInternalDir() ?\n+          getRootDir().getInternalDirFs() : getRootLink().getTargetFileSystem();\n+      ResolveResult\u003cT\u003e res \u003d new ResolveResult\u003cT\u003e(ResultKind.INTERNAL_DIR,\n+          targetFs, root.fullPath, SlashPath);\n       return res;\n     }\n \n-    INodeDir\u003cT\u003e curInode \u003d root;\n+    /**\n+     * linkMergeSlash has been configured. The root of this mount table has\n+     * been linked to the root directory of a file system.\n+     * The first non-slash path component should be name of the mount table.\n+     */\n+    if (root.isLink()) {\n+      Path remainingPath;\n+      StringBuilder remainingPathStr \u003d new StringBuilder();\n+      // ignore first slash\n+      for (int i \u003d 1; i \u003c path.length; i++) {\n+        remainingPathStr.append(\"/\").append(path[i]);\n+      }\n+      remainingPath \u003d new Path(remainingPathStr.toString());\n+      ResolveResult\u003cT\u003e res \u003d new ResolveResult\u003cT\u003e(ResultKind.EXTERNAL_DIR,\n+          getRootLink().getTargetFileSystem(), root.fullPath, remainingPath);\n+      return res;\n+    }\n+    Preconditions.checkState(root.isInternalDir());\n+    INodeDir\u003cT\u003e curInode \u003d getRootDir();\n+\n     int i;\n     // ignore first slash\n     for (i \u003d 1; i \u003c path.length - (resolveLastComponent ? 0 : 1); i++) {\n       INode\u003cT\u003e nextInode \u003d curInode.resolveInternal(path[i]);\n       if (nextInode \u003d\u003d null) {\n-        StringBuilder failedAt \u003d new StringBuilder(path[0]);\n-        for (int j \u003d 1; j \u003c\u003d i; ++j) {\n-          failedAt.append(\u0027/\u0027).append(path[j]);\n+        if (hasFallbackLink()) {\n+          return new ResolveResult\u003cT\u003e(ResultKind.EXTERNAL_DIR,\n+              getRootFallbackLink().getTargetFileSystem(),\n+              root.fullPath, new Path(p));\n+        } else {\n+          StringBuilder failedAt \u003d new StringBuilder(path[0]);\n+          for (int j \u003d 1; j \u003c\u003d i; ++j) {\n+            failedAt.append(\u0027/\u0027).append(path[j]);\n+          }\n+          throw (new FileNotFoundException(\n+              \"File/Directory does not exist: \" + failedAt.toString()));\n         }\n-        throw (new FileNotFoundException(\"File/Directory does not exist: \"\n-            + failedAt.toString()));\n       }\n \n-      if (nextInode instanceof INodeLink) {\n+      if (nextInode.isLink()) {\n         final INodeLink\u003cT\u003e link \u003d (INodeLink\u003cT\u003e) nextInode;\n         final Path remainingPath;\n         if (i \u003e\u003d path.length - 1) {\n           remainingPath \u003d SlashPath;\n         } else {\n           StringBuilder remainingPathStr \u003d new StringBuilder(\"/\" + path[i + 1]);\n           for (int j \u003d i + 2; j \u003c path.length; ++j) {\n             remainingPathStr.append(\u0027/\u0027).append(path[j]);\n           }\n           remainingPath \u003d new Path(remainingPathStr.toString());\n         }\n         final ResolveResult\u003cT\u003e res \u003d\n             new ResolveResult\u003cT\u003e(ResultKind.EXTERNAL_DIR,\n-                link.targetFileSystem, nextInode.fullPath, remainingPath);\n+                link.getTargetFileSystem(), nextInode.fullPath, remainingPath);\n         return res;\n-      } else if (nextInode instanceof INodeDir) {\n+      } else if (nextInode.isInternalDir()) {\n         curInode \u003d (INodeDir\u003cT\u003e) nextInode;\n       }\n     }\n \n     // We have resolved to an internal dir in mount table.\n     Path remainingPath;\n     if (resolveLastComponent) {\n       remainingPath \u003d SlashPath;\n     } else {\n       // note we have taken care of when path is \"/\" above\n       // for internal dirs rem-path does not start with / since the lookup\n       // that follows will do a children.get(remaningPath) and will have to\n       // strip-out the initial /\n       StringBuilder remainingPathStr \u003d new StringBuilder(\"/\" + path[i]);\n       for (int j \u003d i + 1; j \u003c path.length; ++j) {\n         remainingPathStr.append(\u0027/\u0027).append(path[j]);\n       }\n       remainingPath \u003d new Path(remainingPathStr.toString());\n     }\n     final ResolveResult\u003cT\u003e res \u003d\n         new ResolveResult\u003cT\u003e(ResultKind.INTERNAL_DIR,\n-            curInode.InodeDirFs, curInode.fullPath, remainingPath);\n+            curInode.getInternalDirFs(), curInode.fullPath, remainingPath);\n     return res;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  ResolveResult\u003cT\u003e resolve(final String p, final boolean resolveLastComponent)\n      throws FileNotFoundException {\n    String[] path \u003d breakIntoPathComponents(p);\n    if (path.length \u003c\u003d 1) { // special case for when path is \"/\"\n      T targetFs \u003d root.isInternalDir() ?\n          getRootDir().getInternalDirFs() : getRootLink().getTargetFileSystem();\n      ResolveResult\u003cT\u003e res \u003d new ResolveResult\u003cT\u003e(ResultKind.INTERNAL_DIR,\n          targetFs, root.fullPath, SlashPath);\n      return res;\n    }\n\n    /**\n     * linkMergeSlash has been configured. The root of this mount table has\n     * been linked to the root directory of a file system.\n     * The first non-slash path component should be name of the mount table.\n     */\n    if (root.isLink()) {\n      Path remainingPath;\n      StringBuilder remainingPathStr \u003d new StringBuilder();\n      // ignore first slash\n      for (int i \u003d 1; i \u003c path.length; i++) {\n        remainingPathStr.append(\"/\").append(path[i]);\n      }\n      remainingPath \u003d new Path(remainingPathStr.toString());\n      ResolveResult\u003cT\u003e res \u003d new ResolveResult\u003cT\u003e(ResultKind.EXTERNAL_DIR,\n          getRootLink().getTargetFileSystem(), root.fullPath, remainingPath);\n      return res;\n    }\n    Preconditions.checkState(root.isInternalDir());\n    INodeDir\u003cT\u003e curInode \u003d getRootDir();\n\n    int i;\n    // ignore first slash\n    for (i \u003d 1; i \u003c path.length - (resolveLastComponent ? 0 : 1); i++) {\n      INode\u003cT\u003e nextInode \u003d curInode.resolveInternal(path[i]);\n      if (nextInode \u003d\u003d null) {\n        if (hasFallbackLink()) {\n          return new ResolveResult\u003cT\u003e(ResultKind.EXTERNAL_DIR,\n              getRootFallbackLink().getTargetFileSystem(),\n              root.fullPath, new Path(p));\n        } else {\n          StringBuilder failedAt \u003d new StringBuilder(path[0]);\n          for (int j \u003d 1; j \u003c\u003d i; ++j) {\n            failedAt.append(\u0027/\u0027).append(path[j]);\n          }\n          throw (new FileNotFoundException(\n              \"File/Directory does not exist: \" + failedAt.toString()));\n        }\n      }\n\n      if (nextInode.isLink()) {\n        final INodeLink\u003cT\u003e link \u003d (INodeLink\u003cT\u003e) nextInode;\n        final Path remainingPath;\n        if (i \u003e\u003d path.length - 1) {\n          remainingPath \u003d SlashPath;\n        } else {\n          StringBuilder remainingPathStr \u003d new StringBuilder(\"/\" + path[i + 1]);\n          for (int j \u003d i + 2; j \u003c path.length; ++j) {\n            remainingPathStr.append(\u0027/\u0027).append(path[j]);\n          }\n          remainingPath \u003d new Path(remainingPathStr.toString());\n        }\n        final ResolveResult\u003cT\u003e res \u003d\n            new ResolveResult\u003cT\u003e(ResultKind.EXTERNAL_DIR,\n                link.getTargetFileSystem(), nextInode.fullPath, remainingPath);\n        return res;\n      } else if (nextInode.isInternalDir()) {\n        curInode \u003d (INodeDir\u003cT\u003e) nextInode;\n      }\n    }\n\n    // We have resolved to an internal dir in mount table.\n    Path remainingPath;\n    if (resolveLastComponent) {\n      remainingPath \u003d SlashPath;\n    } else {\n      // note we have taken care of when path is \"/\" above\n      // for internal dirs rem-path does not start with / since the lookup\n      // that follows will do a children.get(remaningPath) and will have to\n      // strip-out the initial /\n      StringBuilder remainingPathStr \u003d new StringBuilder(\"/\" + path[i]);\n      for (int j \u003d i + 1; j \u003c path.length; ++j) {\n        remainingPathStr.append(\u0027/\u0027).append(path[j]);\n      }\n      remainingPath \u003d new Path(remainingPathStr.toString());\n    }\n    final ResolveResult\u003cT\u003e res \u003d\n        new ResolveResult\u003cT\u003e(ResultKind.INTERNAL_DIR,\n            curInode.getInternalDirFs(), curInode.fullPath, remainingPath);\n    return res;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/viewfs/InodeTree.java",
      "extendedDetails": {}
    },
    "b91305119b434d23b99ae7e755aea6639f48b6ab": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11968. ViewFS: StoragePolicies commands fail with HDFS federation. Contributed by Mukul Kumar Singh.\n",
      "commitDate": "03/10/17 11:23 AM",
      "commitName": "b91305119b434d23b99ae7e755aea6639f48b6ab",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "05/09/17 11:51 PM",
      "commitNameOld": "1f3bc63e6772be81bc9a6a7d93ed81d2a9e066c0",
      "commitAuthorOld": "Chris Douglas",
      "daysBetweenCommits": 27.48,
      "commitsBetweenForRepo": 256,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,65 @@\n   ResolveResult\u003cT\u003e resolve(final String p, final boolean resolveLastComponent)\n       throws FileNotFoundException {\n     String[] path \u003d breakIntoPathComponents(p);\n     if (path.length \u003c\u003d 1) { // special case for when path is \"/\"\n       ResolveResult\u003cT\u003e res \u003d\n           new ResolveResult\u003cT\u003e(ResultKind.INTERNAL_DIR,\n               root.InodeDirFs, root.fullPath, SlashPath);\n       return res;\n     }\n \n     INodeDir\u003cT\u003e curInode \u003d root;\n     int i;\n     // ignore first slash\n     for (i \u003d 1; i \u003c path.length - (resolveLastComponent ? 0 : 1); i++) {\n       INode\u003cT\u003e nextInode \u003d curInode.resolveInternal(path[i]);\n       if (nextInode \u003d\u003d null) {\n         StringBuilder failedAt \u003d new StringBuilder(path[0]);\n         for (int j \u003d 1; j \u003c\u003d i; ++j) {\n           failedAt.append(\u0027/\u0027).append(path[j]);\n         }\n-        throw (new FileNotFoundException(failedAt.toString()));\n+        throw (new FileNotFoundException(\"File/Directory does not exist: \"\n+            + failedAt.toString()));\n       }\n \n       if (nextInode instanceof INodeLink) {\n         final INodeLink\u003cT\u003e link \u003d (INodeLink\u003cT\u003e) nextInode;\n         final Path remainingPath;\n         if (i \u003e\u003d path.length - 1) {\n           remainingPath \u003d SlashPath;\n         } else {\n           StringBuilder remainingPathStr \u003d new StringBuilder(\"/\" + path[i + 1]);\n           for (int j \u003d i + 2; j \u003c path.length; ++j) {\n             remainingPathStr.append(\u0027/\u0027).append(path[j]);\n           }\n           remainingPath \u003d new Path(remainingPathStr.toString());\n         }\n         final ResolveResult\u003cT\u003e res \u003d\n             new ResolveResult\u003cT\u003e(ResultKind.EXTERNAL_DIR,\n                 link.targetFileSystem, nextInode.fullPath, remainingPath);\n         return res;\n       } else if (nextInode instanceof INodeDir) {\n         curInode \u003d (INodeDir\u003cT\u003e) nextInode;\n       }\n     }\n \n     // We have resolved to an internal dir in mount table.\n     Path remainingPath;\n     if (resolveLastComponent) {\n       remainingPath \u003d SlashPath;\n     } else {\n       // note we have taken care of when path is \"/\" above\n       // for internal dirs rem-path does not start with / since the lookup\n       // that follows will do a children.get(remaningPath) and will have to\n       // strip-out the initial /\n       StringBuilder remainingPathStr \u003d new StringBuilder(\"/\" + path[i]);\n       for (int j \u003d i + 1; j \u003c path.length; ++j) {\n         remainingPathStr.append(\u0027/\u0027).append(path[j]);\n       }\n       remainingPath \u003d new Path(remainingPathStr.toString());\n     }\n     final ResolveResult\u003cT\u003e res \u003d\n         new ResolveResult\u003cT\u003e(ResultKind.INTERNAL_DIR,\n             curInode.InodeDirFs, curInode.fullPath, remainingPath);\n     return res;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  ResolveResult\u003cT\u003e resolve(final String p, final boolean resolveLastComponent)\n      throws FileNotFoundException {\n    String[] path \u003d breakIntoPathComponents(p);\n    if (path.length \u003c\u003d 1) { // special case for when path is \"/\"\n      ResolveResult\u003cT\u003e res \u003d\n          new ResolveResult\u003cT\u003e(ResultKind.INTERNAL_DIR,\n              root.InodeDirFs, root.fullPath, SlashPath);\n      return res;\n    }\n\n    INodeDir\u003cT\u003e curInode \u003d root;\n    int i;\n    // ignore first slash\n    for (i \u003d 1; i \u003c path.length - (resolveLastComponent ? 0 : 1); i++) {\n      INode\u003cT\u003e nextInode \u003d curInode.resolveInternal(path[i]);\n      if (nextInode \u003d\u003d null) {\n        StringBuilder failedAt \u003d new StringBuilder(path[0]);\n        for (int j \u003d 1; j \u003c\u003d i; ++j) {\n          failedAt.append(\u0027/\u0027).append(path[j]);\n        }\n        throw (new FileNotFoundException(\"File/Directory does not exist: \"\n            + failedAt.toString()));\n      }\n\n      if (nextInode instanceof INodeLink) {\n        final INodeLink\u003cT\u003e link \u003d (INodeLink\u003cT\u003e) nextInode;\n        final Path remainingPath;\n        if (i \u003e\u003d path.length - 1) {\n          remainingPath \u003d SlashPath;\n        } else {\n          StringBuilder remainingPathStr \u003d new StringBuilder(\"/\" + path[i + 1]);\n          for (int j \u003d i + 2; j \u003c path.length; ++j) {\n            remainingPathStr.append(\u0027/\u0027).append(path[j]);\n          }\n          remainingPath \u003d new Path(remainingPathStr.toString());\n        }\n        final ResolveResult\u003cT\u003e res \u003d\n            new ResolveResult\u003cT\u003e(ResultKind.EXTERNAL_DIR,\n                link.targetFileSystem, nextInode.fullPath, remainingPath);\n        return res;\n      } else if (nextInode instanceof INodeDir) {\n        curInode \u003d (INodeDir\u003cT\u003e) nextInode;\n      }\n    }\n\n    // We have resolved to an internal dir in mount table.\n    Path remainingPath;\n    if (resolveLastComponent) {\n      remainingPath \u003d SlashPath;\n    } else {\n      // note we have taken care of when path is \"/\" above\n      // for internal dirs rem-path does not start with / since the lookup\n      // that follows will do a children.get(remaningPath) and will have to\n      // strip-out the initial /\n      StringBuilder remainingPathStr \u003d new StringBuilder(\"/\" + path[i]);\n      for (int j \u003d i + 1; j \u003c path.length; ++j) {\n        remainingPathStr.append(\u0027/\u0027).append(path[j]);\n      }\n      remainingPath \u003d new Path(remainingPathStr.toString());\n    }\n    final ResolveResult\u003cT\u003e res \u003d\n        new ResolveResult\u003cT\u003e(ResultKind.INTERNAL_DIR,\n            curInode.InodeDirFs, curInode.fullPath, remainingPath);\n    return res;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/viewfs/InodeTree.java",
      "extendedDetails": {}
    },
    "0f4afc81009129bbee89d5b6cf22c8dda612d223": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13722. Code cleanup -- ViewFileSystem and InodeTree. Contributed by Manoj Govindassamy.\n",
      "commitDate": "17/10/16 1:15 PM",
      "commitName": "0f4afc81009129bbee89d5b6cf22c8dda612d223",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "21/04/15 1:57 PM",
      "commitNameOld": "6d2cf9fbbd02482315a091ab07af26e40cc5134f",
      "commitAuthorOld": "Gera Shegalov",
      "daysBetweenCommits": 544.97,
      "commitsBetweenForRepo": 4050,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,65 +1,64 @@\n   ResolveResult\u003cT\u003e resolve(final String p, final boolean resolveLastComponent)\n-    throws FileNotFoundException {\n-    // TO DO: - more efficient to not split the path, but simply compare\n-    String[] path \u003d breakIntoPathComponents(p); \n+      throws FileNotFoundException {\n+    String[] path \u003d breakIntoPathComponents(p);\n     if (path.length \u003c\u003d 1) { // special case for when path is \"/\"\n-      ResolveResult\u003cT\u003e res \u003d \n-        new ResolveResult\u003cT\u003e(ResultKind.isInternalDir, \n+      ResolveResult\u003cT\u003e res \u003d\n+          new ResolveResult\u003cT\u003e(ResultKind.INTERNAL_DIR,\n               root.InodeDirFs, root.fullPath, SlashPath);\n       return res;\n     }\n-    \n+\n     INodeDir\u003cT\u003e curInode \u003d root;\n     int i;\n     // ignore first slash\n     for (i \u003d 1; i \u003c path.length - (resolveLastComponent ? 0 : 1); i++) {\n       INode\u003cT\u003e nextInode \u003d curInode.resolveInternal(path[i]);\n       if (nextInode \u003d\u003d null) {\n         StringBuilder failedAt \u003d new StringBuilder(path[0]);\n-        for ( int j \u003d 1; j \u003c\u003di; ++j) {\n+        for (int j \u003d 1; j \u003c\u003d i; ++j) {\n           failedAt.append(\u0027/\u0027).append(path[j]);\n         }\n-        throw (new FileNotFoundException(failedAt.toString()));      \n+        throw (new FileNotFoundException(failedAt.toString()));\n       }\n \n       if (nextInode instanceof INodeLink) {\n         final INodeLink\u003cT\u003e link \u003d (INodeLink\u003cT\u003e) nextInode;\n         final Path remainingPath;\n-        if (i \u003e\u003d path.length-1) {\n+        if (i \u003e\u003d path.length - 1) {\n           remainingPath \u003d SlashPath;\n         } else {\n-          StringBuilder remainingPathStr \u003d new StringBuilder(\"/\" + path[i+1]);\n-          for (int j \u003d i+2; j\u003c path.length; ++j) {\n+          StringBuilder remainingPathStr \u003d new StringBuilder(\"/\" + path[i + 1]);\n+          for (int j \u003d i + 2; j \u003c path.length; ++j) {\n             remainingPathStr.append(\u0027/\u0027).append(path[j]);\n           }\n           remainingPath \u003d new Path(remainingPathStr.toString());\n         }\n-        final ResolveResult\u003cT\u003e res \u003d \n-          new ResolveResult\u003cT\u003e(ResultKind.isExternalDir,\n-              link.targetFileSystem, nextInode.fullPath, remainingPath);\n+        final ResolveResult\u003cT\u003e res \u003d\n+            new ResolveResult\u003cT\u003e(ResultKind.EXTERNAL_DIR,\n+                link.targetFileSystem, nextInode.fullPath, remainingPath);\n         return res;\n       } else if (nextInode instanceof INodeDir) {\n         curInode \u003d (INodeDir\u003cT\u003e) nextInode;\n       }\n     }\n \n     // We have resolved to an internal dir in mount table.\n     Path remainingPath;\n     if (resolveLastComponent) {\n       remainingPath \u003d SlashPath;\n     } else {\n       // note we have taken care of when path is \"/\" above\n       // for internal dirs rem-path does not start with / since the lookup\n       // that follows will do a children.get(remaningPath) and will have to\n       // strip-out the initial /\n       StringBuilder remainingPathStr \u003d new StringBuilder(\"/\" + path[i]);\n-      for (int j \u003d i+1; j\u003c path.length; ++j) {\n+      for (int j \u003d i + 1; j \u003c path.length; ++j) {\n         remainingPathStr.append(\u0027/\u0027).append(path[j]);\n       }\n       remainingPath \u003d new Path(remainingPathStr.toString());\n     }\n-    final ResolveResult\u003cT\u003e res \u003d \n-       new ResolveResult\u003cT\u003e(ResultKind.isInternalDir,\n-           curInode.InodeDirFs, curInode.fullPath, remainingPath); \n+    final ResolveResult\u003cT\u003e res \u003d\n+        new ResolveResult\u003cT\u003e(ResultKind.INTERNAL_DIR,\n+            curInode.InodeDirFs, curInode.fullPath, remainingPath);\n     return res;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  ResolveResult\u003cT\u003e resolve(final String p, final boolean resolveLastComponent)\n      throws FileNotFoundException {\n    String[] path \u003d breakIntoPathComponents(p);\n    if (path.length \u003c\u003d 1) { // special case for when path is \"/\"\n      ResolveResult\u003cT\u003e res \u003d\n          new ResolveResult\u003cT\u003e(ResultKind.INTERNAL_DIR,\n              root.InodeDirFs, root.fullPath, SlashPath);\n      return res;\n    }\n\n    INodeDir\u003cT\u003e curInode \u003d root;\n    int i;\n    // ignore first slash\n    for (i \u003d 1; i \u003c path.length - (resolveLastComponent ? 0 : 1); i++) {\n      INode\u003cT\u003e nextInode \u003d curInode.resolveInternal(path[i]);\n      if (nextInode \u003d\u003d null) {\n        StringBuilder failedAt \u003d new StringBuilder(path[0]);\n        for (int j \u003d 1; j \u003c\u003d i; ++j) {\n          failedAt.append(\u0027/\u0027).append(path[j]);\n        }\n        throw (new FileNotFoundException(failedAt.toString()));\n      }\n\n      if (nextInode instanceof INodeLink) {\n        final INodeLink\u003cT\u003e link \u003d (INodeLink\u003cT\u003e) nextInode;\n        final Path remainingPath;\n        if (i \u003e\u003d path.length - 1) {\n          remainingPath \u003d SlashPath;\n        } else {\n          StringBuilder remainingPathStr \u003d new StringBuilder(\"/\" + path[i + 1]);\n          for (int j \u003d i + 2; j \u003c path.length; ++j) {\n            remainingPathStr.append(\u0027/\u0027).append(path[j]);\n          }\n          remainingPath \u003d new Path(remainingPathStr.toString());\n        }\n        final ResolveResult\u003cT\u003e res \u003d\n            new ResolveResult\u003cT\u003e(ResultKind.EXTERNAL_DIR,\n                link.targetFileSystem, nextInode.fullPath, remainingPath);\n        return res;\n      } else if (nextInode instanceof INodeDir) {\n        curInode \u003d (INodeDir\u003cT\u003e) nextInode;\n      }\n    }\n\n    // We have resolved to an internal dir in mount table.\n    Path remainingPath;\n    if (resolveLastComponent) {\n      remainingPath \u003d SlashPath;\n    } else {\n      // note we have taken care of when path is \"/\" above\n      // for internal dirs rem-path does not start with / since the lookup\n      // that follows will do a children.get(remaningPath) and will have to\n      // strip-out the initial /\n      StringBuilder remainingPathStr \u003d new StringBuilder(\"/\" + path[i]);\n      for (int j \u003d i + 1; j \u003c path.length; ++j) {\n        remainingPathStr.append(\u0027/\u0027).append(path[j]);\n      }\n      remainingPath \u003d new Path(remainingPathStr.toString());\n    }\n    final ResolveResult\u003cT\u003e res \u003d\n        new ResolveResult\u003cT\u003e(ResultKind.INTERNAL_DIR,\n            curInode.InodeDirFs, curInode.fullPath, remainingPath);\n    return res;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/viewfs/InodeTree.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  ResolveResult\u003cT\u003e resolve(final String p, final boolean resolveLastComponent)\n    throws FileNotFoundException {\n    // TO DO: - more efficient to not split the path, but simply compare\n    String[] path \u003d breakIntoPathComponents(p); \n    if (path.length \u003c\u003d 1) { // special case for when path is \"/\"\n      ResolveResult\u003cT\u003e res \u003d \n        new ResolveResult\u003cT\u003e(ResultKind.isInternalDir, \n              root.InodeDirFs, root.fullPath, SlashPath);\n      return res;\n    }\n    \n    INodeDir\u003cT\u003e curInode \u003d root;\n    int i;\n    // ignore first slash\n    for (i \u003d 1; i \u003c path.length - (resolveLastComponent ? 0 : 1); i++) {\n      INode\u003cT\u003e nextInode \u003d curInode.resolveInternal(path[i]);\n      if (nextInode \u003d\u003d null) {\n        StringBuilder failedAt \u003d new StringBuilder(path[0]);\n        for ( int j \u003d 1; j \u003c\u003di; ++j) {\n          failedAt.append(\u0027/\u0027).append(path[j]);\n        }\n        throw (new FileNotFoundException(failedAt.toString()));      \n      }\n\n      if (nextInode instanceof INodeLink) {\n        final INodeLink\u003cT\u003e link \u003d (INodeLink\u003cT\u003e) nextInode;\n        final Path remainingPath;\n        if (i \u003e\u003d path.length-1) {\n          remainingPath \u003d SlashPath;\n        } else {\n          StringBuilder remainingPathStr \u003d new StringBuilder(\"/\" + path[i+1]);\n          for (int j \u003d i+2; j\u003c path.length; ++j) {\n            remainingPathStr.append(\u0027/\u0027).append(path[j]);\n          }\n          remainingPath \u003d new Path(remainingPathStr.toString());\n        }\n        final ResolveResult\u003cT\u003e res \u003d \n          new ResolveResult\u003cT\u003e(ResultKind.isExternalDir,\n              link.targetFileSystem, nextInode.fullPath, remainingPath);\n        return res;\n      } else if (nextInode instanceof INodeDir) {\n        curInode \u003d (INodeDir\u003cT\u003e) nextInode;\n      }\n    }\n\n    // We have resolved to an internal dir in mount table.\n    Path remainingPath;\n    if (resolveLastComponent) {\n      remainingPath \u003d SlashPath;\n    } else {\n      // note we have taken care of when path is \"/\" above\n      // for internal dirs rem-path does not start with / since the lookup\n      // that follows will do a children.get(remaningPath) and will have to\n      // strip-out the initial /\n      StringBuilder remainingPathStr \u003d new StringBuilder(\"/\" + path[i]);\n      for (int j \u003d i+1; j\u003c path.length; ++j) {\n        remainingPathStr.append(\u0027/\u0027).append(path[j]);\n      }\n      remainingPath \u003d new Path(remainingPathStr.toString());\n    }\n    final ResolveResult\u003cT\u003e res \u003d \n       new ResolveResult\u003cT\u003e(ResultKind.isInternalDir,\n           curInode.InodeDirFs, curInode.fullPath, remainingPath); \n    return res;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/viewfs/InodeTree.java",
      "extendedDetails": {
        "oldPath": "hadoop-common/src/main/java/org/apache/hadoop/fs/viewfs/InodeTree.java",
        "newPath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/viewfs/InodeTree.java"
      }
    },
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-6671. Use maven for hadoop common builds. Contributed by Alejandro Abdelnur.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1153184 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/08/11 9:37 AM",
      "commitName": "0f6dfeeacbab65a31a33927a4eb84871d371fe52",
      "commitAuthor": "Thomas White",
      "commitDateOld": "01/08/11 3:53 PM",
      "commitNameOld": "9bac807cedbcff34e1a144fb475eff267e5ed86d",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.74,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  ResolveResult\u003cT\u003e resolve(final String p, final boolean resolveLastComponent)\n    throws FileNotFoundException {\n    // TO DO: - more efficient to not split the path, but simply compare\n    String[] path \u003d breakIntoPathComponents(p); \n    if (path.length \u003c\u003d 1) { // special case for when path is \"/\"\n      ResolveResult\u003cT\u003e res \u003d \n        new ResolveResult\u003cT\u003e(ResultKind.isInternalDir, \n              root.InodeDirFs, root.fullPath, SlashPath);\n      return res;\n    }\n    \n    INodeDir\u003cT\u003e curInode \u003d root;\n    int i;\n    // ignore first slash\n    for (i \u003d 1; i \u003c path.length - (resolveLastComponent ? 0 : 1); i++) {\n      INode\u003cT\u003e nextInode \u003d curInode.resolveInternal(path[i]);\n      if (nextInode \u003d\u003d null) {\n        StringBuilder failedAt \u003d new StringBuilder(path[0]);\n        for ( int j \u003d 1; j \u003c\u003di; ++j) {\n          failedAt.append(\u0027/\u0027).append(path[j]);\n        }\n        throw (new FileNotFoundException(failedAt.toString()));      \n      }\n\n      if (nextInode instanceof INodeLink) {\n        final INodeLink\u003cT\u003e link \u003d (INodeLink\u003cT\u003e) nextInode;\n        final Path remainingPath;\n        if (i \u003e\u003d path.length-1) {\n          remainingPath \u003d SlashPath;\n        } else {\n          StringBuilder remainingPathStr \u003d new StringBuilder(\"/\" + path[i+1]);\n          for (int j \u003d i+2; j\u003c path.length; ++j) {\n            remainingPathStr.append(\u0027/\u0027).append(path[j]);\n          }\n          remainingPath \u003d new Path(remainingPathStr.toString());\n        }\n        final ResolveResult\u003cT\u003e res \u003d \n          new ResolveResult\u003cT\u003e(ResultKind.isExternalDir,\n              link.targetFileSystem, nextInode.fullPath, remainingPath);\n        return res;\n      } else if (nextInode instanceof INodeDir) {\n        curInode \u003d (INodeDir\u003cT\u003e) nextInode;\n      }\n    }\n\n    // We have resolved to an internal dir in mount table.\n    Path remainingPath;\n    if (resolveLastComponent) {\n      remainingPath \u003d SlashPath;\n    } else {\n      // note we have taken care of when path is \"/\" above\n      // for internal dirs rem-path does not start with / since the lookup\n      // that follows will do a children.get(remaningPath) and will have to\n      // strip-out the initial /\n      StringBuilder remainingPathStr \u003d new StringBuilder(\"/\" + path[i]);\n      for (int j \u003d i+1; j\u003c path.length; ++j) {\n        remainingPathStr.append(\u0027/\u0027).append(path[j]);\n      }\n      remainingPath \u003d new Path(remainingPathStr.toString());\n    }\n    final ResolveResult\u003cT\u003e res \u003d \n       new ResolveResult\u003cT\u003e(ResultKind.isInternalDir,\n           curInode.InodeDirFs, curInode.fullPath, remainingPath); \n    return res;\n  }",
      "path": "hadoop-common/src/main/java/org/apache/hadoop/fs/viewfs/InodeTree.java",
      "extendedDetails": {
        "oldPath": "common/src/java/org/apache/hadoop/fs/viewfs/InodeTree.java",
        "newPath": "hadoop-common/src/main/java/org/apache/hadoop/fs/viewfs/InodeTree.java"
      }
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "11/06/11 9:13 PM",
      "commitNameOld": "a285fb5effe9ba3be4ec5f942afaf5ddd1186151",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 0.74,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  ResolveResult\u003cT\u003e resolve(final String p, final boolean resolveLastComponent)\n    throws FileNotFoundException {\n    // TO DO: - more efficient to not split the path, but simply compare\n    String[] path \u003d breakIntoPathComponents(p); \n    if (path.length \u003c\u003d 1) { // special case for when path is \"/\"\n      ResolveResult\u003cT\u003e res \u003d \n        new ResolveResult\u003cT\u003e(ResultKind.isInternalDir, \n              root.InodeDirFs, root.fullPath, SlashPath);\n      return res;\n    }\n    \n    INodeDir\u003cT\u003e curInode \u003d root;\n    int i;\n    // ignore first slash\n    for (i \u003d 1; i \u003c path.length - (resolveLastComponent ? 0 : 1); i++) {\n      INode\u003cT\u003e nextInode \u003d curInode.resolveInternal(path[i]);\n      if (nextInode \u003d\u003d null) {\n        StringBuilder failedAt \u003d new StringBuilder(path[0]);\n        for ( int j \u003d 1; j \u003c\u003di; ++j) {\n          failedAt.append(\u0027/\u0027).append(path[j]);\n        }\n        throw (new FileNotFoundException(failedAt.toString()));      \n      }\n\n      if (nextInode instanceof INodeLink) {\n        final INodeLink\u003cT\u003e link \u003d (INodeLink\u003cT\u003e) nextInode;\n        final Path remainingPath;\n        if (i \u003e\u003d path.length-1) {\n          remainingPath \u003d SlashPath;\n        } else {\n          StringBuilder remainingPathStr \u003d new StringBuilder(\"/\" + path[i+1]);\n          for (int j \u003d i+2; j\u003c path.length; ++j) {\n            remainingPathStr.append(\u0027/\u0027).append(path[j]);\n          }\n          remainingPath \u003d new Path(remainingPathStr.toString());\n        }\n        final ResolveResult\u003cT\u003e res \u003d \n          new ResolveResult\u003cT\u003e(ResultKind.isExternalDir,\n              link.targetFileSystem, nextInode.fullPath, remainingPath);\n        return res;\n      } else if (nextInode instanceof INodeDir) {\n        curInode \u003d (INodeDir\u003cT\u003e) nextInode;\n      }\n    }\n\n    // We have resolved to an internal dir in mount table.\n    Path remainingPath;\n    if (resolveLastComponent) {\n      remainingPath \u003d SlashPath;\n    } else {\n      // note we have taken care of when path is \"/\" above\n      // for internal dirs rem-path does not start with / since the lookup\n      // that follows will do a children.get(remaningPath) and will have to\n      // strip-out the initial /\n      StringBuilder remainingPathStr \u003d new StringBuilder(\"/\" + path[i]);\n      for (int j \u003d i+1; j\u003c path.length; ++j) {\n        remainingPathStr.append(\u0027/\u0027).append(path[j]);\n      }\n      remainingPath \u003d new Path(remainingPathStr.toString());\n    }\n    final ResolveResult\u003cT\u003e res \u003d \n       new ResolveResult\u003cT\u003e(ResultKind.isInternalDir,\n           curInode.InodeDirFs, curInode.fullPath, remainingPath); \n    return res;\n  }",
      "path": "common/src/java/org/apache/hadoop/fs/viewfs/InodeTree.java",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/hadoop/fs/viewfs/InodeTree.java",
        "newPath": "common/src/java/org/apache/hadoop/fs/viewfs/InodeTree.java"
      }
    },
    "f1c74df922058e88791ed6971bbb96b53f6770f1": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-7257 Client side mount tables (sanjay)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1100026 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "05/05/11 7:11 PM",
      "commitName": "f1c74df922058e88791ed6971bbb96b53f6770f1",
      "commitAuthor": "Sanjay Radia",
      "diff": "@@ -0,0 +1,65 @@\n+  ResolveResult\u003cT\u003e resolve(final String p, final boolean resolveLastComponent)\n+    throws FileNotFoundException {\n+    // TO DO: - more efficient to not split the path, but simply compare\n+    String[] path \u003d breakIntoPathComponents(p); \n+    if (path.length \u003c\u003d 1) { // special case for when path is \"/\"\n+      ResolveResult\u003cT\u003e res \u003d \n+        new ResolveResult\u003cT\u003e(ResultKind.isInternalDir, \n+              root.InodeDirFs, root.fullPath, SlashPath);\n+      return res;\n+    }\n+    \n+    INodeDir\u003cT\u003e curInode \u003d root;\n+    int i;\n+    // ignore first slash\n+    for (i \u003d 1; i \u003c path.length - (resolveLastComponent ? 0 : 1); i++) {\n+      INode\u003cT\u003e nextInode \u003d curInode.resolveInternal(path[i]);\n+      if (nextInode \u003d\u003d null) {\n+        StringBuilder failedAt \u003d new StringBuilder(path[0]);\n+        for ( int j \u003d 1; j \u003c\u003di; ++j) {\n+          failedAt.append(\u0027/\u0027).append(path[j]);\n+        }\n+        throw (new FileNotFoundException(failedAt.toString()));      \n+      }\n+\n+      if (nextInode instanceof INodeLink) {\n+        final INodeLink\u003cT\u003e link \u003d (INodeLink\u003cT\u003e) nextInode;\n+        final Path remainingPath;\n+        if (i \u003e\u003d path.length-1) {\n+          remainingPath \u003d SlashPath;\n+        } else {\n+          StringBuilder remainingPathStr \u003d new StringBuilder(\"/\" + path[i+1]);\n+          for (int j \u003d i+2; j\u003c path.length; ++j) {\n+            remainingPathStr.append(\u0027/\u0027).append(path[j]);\n+          }\n+          remainingPath \u003d new Path(remainingPathStr.toString());\n+        }\n+        final ResolveResult\u003cT\u003e res \u003d \n+          new ResolveResult\u003cT\u003e(ResultKind.isExternalDir,\n+              link.targetFileSystem, nextInode.fullPath, remainingPath);\n+        return res;\n+      } else if (nextInode instanceof INodeDir) {\n+        curInode \u003d (INodeDir\u003cT\u003e) nextInode;\n+      }\n+    }\n+\n+    // We have resolved to an internal dir in mount table.\n+    Path remainingPath;\n+    if (resolveLastComponent) {\n+      remainingPath \u003d SlashPath;\n+    } else {\n+      // note we have taken care of when path is \"/\" above\n+      // for internal dirs rem-path does not start with / since the lookup\n+      // that follows will do a children.get(remaningPath) and will have to\n+      // strip-out the initial /\n+      StringBuilder remainingPathStr \u003d new StringBuilder(\"/\" + path[i]);\n+      for (int j \u003d i+1; j\u003c path.length; ++j) {\n+        remainingPathStr.append(\u0027/\u0027).append(path[j]);\n+      }\n+      remainingPath \u003d new Path(remainingPathStr.toString());\n+    }\n+    final ResolveResult\u003cT\u003e res \u003d \n+       new ResolveResult\u003cT\u003e(ResultKind.isInternalDir,\n+           curInode.InodeDirFs, curInode.fullPath, remainingPath); \n+    return res;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  ResolveResult\u003cT\u003e resolve(final String p, final boolean resolveLastComponent)\n    throws FileNotFoundException {\n    // TO DO: - more efficient to not split the path, but simply compare\n    String[] path \u003d breakIntoPathComponents(p); \n    if (path.length \u003c\u003d 1) { // special case for when path is \"/\"\n      ResolveResult\u003cT\u003e res \u003d \n        new ResolveResult\u003cT\u003e(ResultKind.isInternalDir, \n              root.InodeDirFs, root.fullPath, SlashPath);\n      return res;\n    }\n    \n    INodeDir\u003cT\u003e curInode \u003d root;\n    int i;\n    // ignore first slash\n    for (i \u003d 1; i \u003c path.length - (resolveLastComponent ? 0 : 1); i++) {\n      INode\u003cT\u003e nextInode \u003d curInode.resolveInternal(path[i]);\n      if (nextInode \u003d\u003d null) {\n        StringBuilder failedAt \u003d new StringBuilder(path[0]);\n        for ( int j \u003d 1; j \u003c\u003di; ++j) {\n          failedAt.append(\u0027/\u0027).append(path[j]);\n        }\n        throw (new FileNotFoundException(failedAt.toString()));      \n      }\n\n      if (nextInode instanceof INodeLink) {\n        final INodeLink\u003cT\u003e link \u003d (INodeLink\u003cT\u003e) nextInode;\n        final Path remainingPath;\n        if (i \u003e\u003d path.length-1) {\n          remainingPath \u003d SlashPath;\n        } else {\n          StringBuilder remainingPathStr \u003d new StringBuilder(\"/\" + path[i+1]);\n          for (int j \u003d i+2; j\u003c path.length; ++j) {\n            remainingPathStr.append(\u0027/\u0027).append(path[j]);\n          }\n          remainingPath \u003d new Path(remainingPathStr.toString());\n        }\n        final ResolveResult\u003cT\u003e res \u003d \n          new ResolveResult\u003cT\u003e(ResultKind.isExternalDir,\n              link.targetFileSystem, nextInode.fullPath, remainingPath);\n        return res;\n      } else if (nextInode instanceof INodeDir) {\n        curInode \u003d (INodeDir\u003cT\u003e) nextInode;\n      }\n    }\n\n    // We have resolved to an internal dir in mount table.\n    Path remainingPath;\n    if (resolveLastComponent) {\n      remainingPath \u003d SlashPath;\n    } else {\n      // note we have taken care of when path is \"/\" above\n      // for internal dirs rem-path does not start with / since the lookup\n      // that follows will do a children.get(remaningPath) and will have to\n      // strip-out the initial /\n      StringBuilder remainingPathStr \u003d new StringBuilder(\"/\" + path[i]);\n      for (int j \u003d i+1; j\u003c path.length; ++j) {\n        remainingPathStr.append(\u0027/\u0027).append(path[j]);\n      }\n      remainingPath \u003d new Path(remainingPathStr.toString());\n    }\n    final ResolveResult\u003cT\u003e res \u003d \n       new ResolveResult\u003cT\u003e(ResultKind.isInternalDir,\n           curInode.InodeDirFs, curInode.fullPath, remainingPath); \n    return res;\n  }",
      "path": "src/java/org/apache/hadoop/fs/viewfs/InodeTree.java"
    }
  }
}