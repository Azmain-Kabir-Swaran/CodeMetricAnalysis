{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "NativeAzureFileSystem.java",
  "functionName": "listStatus",
  "functionId": "listStatus___f-Path",
  "sourceFilePath": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
  "functionStartLine": 2783,
  "functionEndLine": 2871,
  "numCommitsSeen": 66,
  "timeTaken": 5393,
  "changeHistory": [
    "45d9568aaaf532a6da11bd7c1844ff81bf66bab1",
    "f34744603ee93e082e7ba148df1400af5ac7c30c",
    "b415c6fe743242acf1d1d3eb7ea7091d90d2c0d4",
    "0cab57223e3f54be17a5f27cefdb6d1da1b073e5",
    "686823529be09bea2a6cecb3503ef722017475bc",
    "52d7d5aa1a303cf70519a61487641211f4267c6f",
    "6b7cd62b8cf12616b13142f2eb2cfc2f25796f0f",
    "8bc93db2e7c64830b6a662f28c8917a9eef4e7c9",
    "0e76f1fceaaaeb66bdb4818f43b9a55fc092bf79",
    "5f6edb30c2bb648d5564c951edc25645e17e6636",
    "2217e2f8ff418b88eac6ad36cafe3a9795a11f40",
    "81bc395deb3ba00567dc067d6ca71bacf9e3bc82"
  ],
  "changeHistoryShort": {
    "45d9568aaaf532a6da11bd7c1844ff81bf66bab1": "Ybodychange",
    "f34744603ee93e082e7ba148df1400af5ac7c30c": "Ybodychange",
    "b415c6fe743242acf1d1d3eb7ea7091d90d2c0d4": "Ybodychange",
    "0cab57223e3f54be17a5f27cefdb6d1da1b073e5": "Ybodychange",
    "686823529be09bea2a6cecb3503ef722017475bc": "Ybodychange",
    "52d7d5aa1a303cf70519a61487641211f4267c6f": "Ybodychange",
    "6b7cd62b8cf12616b13142f2eb2cfc2f25796f0f": "Ybodychange",
    "8bc93db2e7c64830b6a662f28c8917a9eef4e7c9": "Ybodychange",
    "0e76f1fceaaaeb66bdb4818f43b9a55fc092bf79": "Ymultichange(Yexceptionschange,Ybodychange)",
    "5f6edb30c2bb648d5564c951edc25645e17e6636": "Ybodychange",
    "2217e2f8ff418b88eac6ad36cafe3a9795a11f40": "Ybodychange",
    "81bc395deb3ba00567dc067d6ca71bacf9e3bc82": "Yintroduced"
  },
  "changeHistoryDetails": {
    "45d9568aaaf532a6da11bd7c1844ff81bf66bab1": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15547/ WASB: improve listStatus performance.\nContributed by Thomas Marquardt.\n\n(cherry picked from commit 749fff577ed9afb4ef8a54b8948f74be083cc620)\n",
      "commitDate": "19/07/18 12:31 PM",
      "commitName": "45d9568aaaf532a6da11bd7c1844ff81bf66bab1",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "27/06/18 10:37 PM",
      "commitNameOld": "2b2399d623539ab68e71a38fa9fbfc9a405bddb8",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 21.58,
      "commitsBetweenForRepo": 124,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,113 +1,89 @@\n   public FileStatus[] listStatus(Path f) throws FileNotFoundException, IOException {\n \n     LOG.debug(\"Listing status for {}\", f.toString());\n \n     Path absolutePath \u003d makeAbsolute(f);\n \n     performAuthCheck(absolutePath, WasbAuthorizationOperations.READ, \"liststatus\", absolutePath);\n \n     String key \u003d pathToKey(absolutePath);\n-    Set\u003cFileStatus\u003e status \u003d new TreeSet\u003cFileStatus\u003e();\n+\n     FileMetadata meta \u003d null;\n     try {\n       meta \u003d store.retrieveMetadata(key);\n     } catch (IOException ex) {\n \n       Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n \n       if (innerException instanceof StorageException\n           \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n \n         throw new FileNotFoundException(String.format(\"%s is not found\", f));\n       }\n \n       throw ex;\n     }\n \n-    if (meta !\u003d null) {\n-      if (!meta.isDir()) {\n+    if (meta \u003d\u003d null) {\n+      // There is no metadata found for the path.\n+      LOG.debug(\"Did not find any metadata for path: {}\", key);\n+      throw new FileNotFoundException(f + \" is not found\");\n+    }\n \n-        LOG.debug(\"Found path as a file\");\n+    if (!meta.isDirectory()) {\n+      LOG.debug(\"Found path as a file\");\n+      return new FileStatus[] { updateFileStatusPath(meta, absolutePath) };\n+    }\n \n-        return new FileStatus[] { newFile(meta, absolutePath) };\n-      }\n+    FileMetadata[] listing;\n \n-      String partialKey \u003d null;\n-      PartialListing listing \u003d null;\n+    listing \u003d listWithErrorHandling(key, AZURE_LIST_ALL, 1);\n \n-      try {\n-        listing  \u003d store.list(key, AZURE_LIST_ALL, 1, partialKey);\n-      } catch (IOException ex) {\n+    // NOTE: We don\u0027t check for Null condition as the Store API should return\n+    // an empty list if there are not listing.\n \n-        Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n+    // For any -RenamePending.json files in the listing,\n+    // push the rename forward.\n+    boolean renamed \u003d conditionalRedoFolderRenames(listing);\n \n-        if (innerException instanceof StorageException\n-            \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n+    // If any renames were redone, get another listing,\n+    // since the current one may have changed due to the redo.\n+    if (renamed) {\n+      listing \u003d listWithErrorHandling(key, AZURE_LIST_ALL, 1);\n+    }\n \n-            throw new FileNotFoundException(String.format(\"%s is not found\", key));\n-        }\n+    // We only need to check for AZURE_TEMP_FOLDER if the key is the root,\n+    // and if it is not the root we also know the exact size of the array\n+    // of FileStatus.\n \n-        throw ex;\n-      }\n-      // NOTE: We don\u0027t check for Null condition as the Store API should return\n-      // an empty list if there are not listing.\n+    FileMetadata[] result \u003d null;\n \n-      // For any -RenamePending.json files in the listing,\n-      // push the rename forward.\n-      boolean renamed \u003d conditionalRedoFolderRenames(listing);\n+    if (key.equals(\"/\")) {\n+      ArrayList\u003cFileMetadata\u003e status \u003d new ArrayList\u003c\u003e(listing.length);\n \n-      // If any renames were redone, get another listing,\n-      // since the current one may have changed due to the redo.\n-      if (renamed) {\n-       listing \u003d null;\n-       try {\n-         listing \u003d store.list(key, AZURE_LIST_ALL, 1, partialKey);\n-       } catch (IOException ex) {\n-         Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n-\n-         if (innerException instanceof StorageException\n-             \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n-\n-           throw new FileNotFoundException(String.format(\"%s is not found\", key));\n-         }\n-\n-         throw ex;\n-       }\n-      }\n-\n-      // NOTE: We don\u0027t check for Null condition as the Store API should return\n-      // and empty list if there are not listing.\n-\n-      for (FileMetadata fileMetadata : listing.getFiles()) {\n-        Path subpath \u003d keyToPath(fileMetadata.getKey());\n-\n-        // Test whether the metadata represents a file or directory and\n-        // add the appropriate metadata object.\n-        //\n-        // Note: There was a very old bug here where directories were added\n-        // to the status set as files flattening out recursive listings\n-        // using \"-lsr\" down the file system hierarchy.\n-        if (fileMetadata.isDir()) {\n+      for (FileMetadata fileMetadata : listing) {\n+        if (fileMetadata.isDirectory()) {\n           // Make sure we hide the temp upload folder\n           if (fileMetadata.getKey().equals(AZURE_TEMP_FOLDER)) {\n             // Don\u0027t expose that.\n             continue;\n           }\n-          status.add(newDirectory(fileMetadata, subpath));\n+          status.add(updateFileStatusPath(fileMetadata, fileMetadata.getPath()));\n         } else {\n-          status.add(newFile(fileMetadata, subpath));\n+          status.add(updateFileStatusPath(fileMetadata, fileMetadata.getPath()));\n         }\n       }\n-\n-      LOG.debug(\"Found path as a directory with {}\"\n-          + \" files in it.\", status.size());\n-\n+      result \u003d status.toArray(new FileMetadata[0]);\n     } else {\n-      // There is no metadata found for the path.\n-      LOG.debug(\"Did not find any metadata for path: {}\", key);\n-\n-      throw new FileNotFoundException(f + \" is not found\");\n+      for (int i \u003d 0; i \u003c listing.length; i++) {\n+        FileMetadata fileMetadata \u003d listing[i];\n+          listing[i] \u003d updateFileStatusPath(fileMetadata, fileMetadata.getPath());\n+      }\n+      result \u003d listing;\n     }\n \n-    return status.toArray(new FileStatus[0]);\n+    LOG.debug(\"Found path as a directory with {}\"\n+        + \" files in it.\", result.length);\n+\n+    return result;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FileStatus[] listStatus(Path f) throws FileNotFoundException, IOException {\n\n    LOG.debug(\"Listing status for {}\", f.toString());\n\n    Path absolutePath \u003d makeAbsolute(f);\n\n    performAuthCheck(absolutePath, WasbAuthorizationOperations.READ, \"liststatus\", absolutePath);\n\n    String key \u003d pathToKey(absolutePath);\n\n    FileMetadata meta \u003d null;\n    try {\n      meta \u003d store.retrieveMetadata(key);\n    } catch (IOException ex) {\n\n      Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n\n      if (innerException instanceof StorageException\n          \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n\n        throw new FileNotFoundException(String.format(\"%s is not found\", f));\n      }\n\n      throw ex;\n    }\n\n    if (meta \u003d\u003d null) {\n      // There is no metadata found for the path.\n      LOG.debug(\"Did not find any metadata for path: {}\", key);\n      throw new FileNotFoundException(f + \" is not found\");\n    }\n\n    if (!meta.isDirectory()) {\n      LOG.debug(\"Found path as a file\");\n      return new FileStatus[] { updateFileStatusPath(meta, absolutePath) };\n    }\n\n    FileMetadata[] listing;\n\n    listing \u003d listWithErrorHandling(key, AZURE_LIST_ALL, 1);\n\n    // NOTE: We don\u0027t check for Null condition as the Store API should return\n    // an empty list if there are not listing.\n\n    // For any -RenamePending.json files in the listing,\n    // push the rename forward.\n    boolean renamed \u003d conditionalRedoFolderRenames(listing);\n\n    // If any renames were redone, get another listing,\n    // since the current one may have changed due to the redo.\n    if (renamed) {\n      listing \u003d listWithErrorHandling(key, AZURE_LIST_ALL, 1);\n    }\n\n    // We only need to check for AZURE_TEMP_FOLDER if the key is the root,\n    // and if it is not the root we also know the exact size of the array\n    // of FileStatus.\n\n    FileMetadata[] result \u003d null;\n\n    if (key.equals(\"/\")) {\n      ArrayList\u003cFileMetadata\u003e status \u003d new ArrayList\u003c\u003e(listing.length);\n\n      for (FileMetadata fileMetadata : listing) {\n        if (fileMetadata.isDirectory()) {\n          // Make sure we hide the temp upload folder\n          if (fileMetadata.getKey().equals(AZURE_TEMP_FOLDER)) {\n            // Don\u0027t expose that.\n            continue;\n          }\n          status.add(updateFileStatusPath(fileMetadata, fileMetadata.getPath()));\n        } else {\n          status.add(updateFileStatusPath(fileMetadata, fileMetadata.getPath()));\n        }\n      }\n      result \u003d status.toArray(new FileMetadata[0]);\n    } else {\n      for (int i \u003d 0; i \u003c listing.length; i++) {\n        FileMetadata fileMetadata \u003d listing[i];\n          listing[i] \u003d updateFileStatusPath(fileMetadata, fileMetadata.getPath());\n      }\n      result \u003d listing;\n    }\n\n    LOG.debug(\"Found path as a directory with {}\"\n        + \" files in it.\", result.length);\n\n    return result;\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
      "extendedDetails": {}
    },
    "f34744603ee93e082e7ba148df1400af5ac7c30c": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15533. Make WASB listStatus messages consistent. Contributed by Esfandiar Manii\n",
      "commitDate": "17/06/18 11:12 PM",
      "commitName": "f34744603ee93e082e7ba148df1400af5ac7c30c",
      "commitAuthor": "Chris Douglas",
      "commitDateOld": "28/03/18 11:58 AM",
      "commitNameOld": "081c3501885c543bb1f159929d456d1ba2e3650c",
      "commitAuthorOld": "Chris Douglas",
      "daysBetweenCommits": 81.47,
      "commitsBetweenForRepo": 1093,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,113 +1,113 @@\n   public FileStatus[] listStatus(Path f) throws FileNotFoundException, IOException {\n \n     LOG.debug(\"Listing status for {}\", f.toString());\n \n     Path absolutePath \u003d makeAbsolute(f);\n \n     performAuthCheck(absolutePath, WasbAuthorizationOperations.READ, \"liststatus\", absolutePath);\n \n     String key \u003d pathToKey(absolutePath);\n     Set\u003cFileStatus\u003e status \u003d new TreeSet\u003cFileStatus\u003e();\n     FileMetadata meta \u003d null;\n     try {\n       meta \u003d store.retrieveMetadata(key);\n     } catch (IOException ex) {\n \n       Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n \n       if (innerException instanceof StorageException\n           \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n \n         throw new FileNotFoundException(String.format(\"%s is not found\", f));\n       }\n \n       throw ex;\n     }\n \n     if (meta !\u003d null) {\n       if (!meta.isDir()) {\n \n         LOG.debug(\"Found path as a file\");\n \n         return new FileStatus[] { newFile(meta, absolutePath) };\n       }\n \n       String partialKey \u003d null;\n       PartialListing listing \u003d null;\n \n       try {\n         listing  \u003d store.list(key, AZURE_LIST_ALL, 1, partialKey);\n       } catch (IOException ex) {\n \n         Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n \n         if (innerException instanceof StorageException\n             \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n \n             throw new FileNotFoundException(String.format(\"%s is not found\", key));\n         }\n \n         throw ex;\n       }\n       // NOTE: We don\u0027t check for Null condition as the Store API should return\n       // an empty list if there are not listing.\n \n       // For any -RenamePending.json files in the listing,\n       // push the rename forward.\n       boolean renamed \u003d conditionalRedoFolderRenames(listing);\n \n       // If any renames were redone, get another listing,\n       // since the current one may have changed due to the redo.\n       if (renamed) {\n        listing \u003d null;\n        try {\n          listing \u003d store.list(key, AZURE_LIST_ALL, 1, partialKey);\n        } catch (IOException ex) {\n          Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n \n          if (innerException instanceof StorageException\n              \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n \n            throw new FileNotFoundException(String.format(\"%s is not found\", key));\n          }\n \n          throw ex;\n        }\n       }\n \n       // NOTE: We don\u0027t check for Null condition as the Store API should return\n       // and empty list if there are not listing.\n \n       for (FileMetadata fileMetadata : listing.getFiles()) {\n         Path subpath \u003d keyToPath(fileMetadata.getKey());\n \n         // Test whether the metadata represents a file or directory and\n         // add the appropriate metadata object.\n         //\n         // Note: There was a very old bug here where directories were added\n         // to the status set as files flattening out recursive listings\n         // using \"-lsr\" down the file system hierarchy.\n         if (fileMetadata.isDir()) {\n           // Make sure we hide the temp upload folder\n           if (fileMetadata.getKey().equals(AZURE_TEMP_FOLDER)) {\n             // Don\u0027t expose that.\n             continue;\n           }\n           status.add(newDirectory(fileMetadata, subpath));\n         } else {\n           status.add(newFile(fileMetadata, subpath));\n         }\n       }\n \n       LOG.debug(\"Found path as a directory with {}\"\n           + \" files in it.\", status.size());\n \n     } else {\n       // There is no metadata found for the path.\n       LOG.debug(\"Did not find any metadata for path: {}\", key);\n \n-      throw new FileNotFoundException(\"File\" + f + \" does not exist.\");\n+      throw new FileNotFoundException(f + \" is not found\");\n     }\n \n     return status.toArray(new FileStatus[0]);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FileStatus[] listStatus(Path f) throws FileNotFoundException, IOException {\n\n    LOG.debug(\"Listing status for {}\", f.toString());\n\n    Path absolutePath \u003d makeAbsolute(f);\n\n    performAuthCheck(absolutePath, WasbAuthorizationOperations.READ, \"liststatus\", absolutePath);\n\n    String key \u003d pathToKey(absolutePath);\n    Set\u003cFileStatus\u003e status \u003d new TreeSet\u003cFileStatus\u003e();\n    FileMetadata meta \u003d null;\n    try {\n      meta \u003d store.retrieveMetadata(key);\n    } catch (IOException ex) {\n\n      Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n\n      if (innerException instanceof StorageException\n          \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n\n        throw new FileNotFoundException(String.format(\"%s is not found\", f));\n      }\n\n      throw ex;\n    }\n\n    if (meta !\u003d null) {\n      if (!meta.isDir()) {\n\n        LOG.debug(\"Found path as a file\");\n\n        return new FileStatus[] { newFile(meta, absolutePath) };\n      }\n\n      String partialKey \u003d null;\n      PartialListing listing \u003d null;\n\n      try {\n        listing  \u003d store.list(key, AZURE_LIST_ALL, 1, partialKey);\n      } catch (IOException ex) {\n\n        Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n\n        if (innerException instanceof StorageException\n            \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n\n            throw new FileNotFoundException(String.format(\"%s is not found\", key));\n        }\n\n        throw ex;\n      }\n      // NOTE: We don\u0027t check for Null condition as the Store API should return\n      // an empty list if there are not listing.\n\n      // For any -RenamePending.json files in the listing,\n      // push the rename forward.\n      boolean renamed \u003d conditionalRedoFolderRenames(listing);\n\n      // If any renames were redone, get another listing,\n      // since the current one may have changed due to the redo.\n      if (renamed) {\n       listing \u003d null;\n       try {\n         listing \u003d store.list(key, AZURE_LIST_ALL, 1, partialKey);\n       } catch (IOException ex) {\n         Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n\n         if (innerException instanceof StorageException\n             \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n\n           throw new FileNotFoundException(String.format(\"%s is not found\", key));\n         }\n\n         throw ex;\n       }\n      }\n\n      // NOTE: We don\u0027t check for Null condition as the Store API should return\n      // and empty list if there are not listing.\n\n      for (FileMetadata fileMetadata : listing.getFiles()) {\n        Path subpath \u003d keyToPath(fileMetadata.getKey());\n\n        // Test whether the metadata represents a file or directory and\n        // add the appropriate metadata object.\n        //\n        // Note: There was a very old bug here where directories were added\n        // to the status set as files flattening out recursive listings\n        // using \"-lsr\" down the file system hierarchy.\n        if (fileMetadata.isDir()) {\n          // Make sure we hide the temp upload folder\n          if (fileMetadata.getKey().equals(AZURE_TEMP_FOLDER)) {\n            // Don\u0027t expose that.\n            continue;\n          }\n          status.add(newDirectory(fileMetadata, subpath));\n        } else {\n          status.add(newFile(fileMetadata, subpath));\n        }\n      }\n\n      LOG.debug(\"Found path as a directory with {}\"\n          + \" files in it.\", status.size());\n\n    } else {\n      // There is no metadata found for the path.\n      LOG.debug(\"Did not find any metadata for path: {}\", key);\n\n      throw new FileNotFoundException(f + \" is not found\");\n    }\n\n    return status.toArray(new FileStatus[0]);\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
      "extendedDetails": {}
    },
    "b415c6fe743242acf1d1d3eb7ea7091d90d2c0d4": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14416. Path starting with \u0027wasb:///\u0027 not resolved correctly while authorizing with WASB-Ranger. Contributed by Sivaguru Sankaridurg\n",
      "commitDate": "16/05/17 11:22 AM",
      "commitName": "b415c6fe743242acf1d1d3eb7ea7091d90d2c0d4",
      "commitAuthor": "Mingliang Liu",
      "commitDateOld": "10/05/17 3:05 PM",
      "commitNameOld": "eed731496f63537350206274af09d2118b116a17",
      "commitAuthorOld": "Mingliang Liu",
      "daysBetweenCommits": 5.85,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,113 +1,113 @@\n   public FileStatus[] listStatus(Path f) throws FileNotFoundException, IOException {\n \n     LOG.debug(\"Listing status for {}\", f.toString());\n \n     Path absolutePath \u003d makeAbsolute(f);\n \n-    performAuthCheck(absolutePath.toString(), WasbAuthorizationOperations.READ, \"liststatus\", absolutePath.toString());\n+    performAuthCheck(absolutePath, WasbAuthorizationOperations.READ, \"liststatus\", absolutePath);\n \n     String key \u003d pathToKey(absolutePath);\n     Set\u003cFileStatus\u003e status \u003d new TreeSet\u003cFileStatus\u003e();\n     FileMetadata meta \u003d null;\n     try {\n       meta \u003d store.retrieveMetadata(key);\n     } catch (IOException ex) {\n \n       Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n \n       if (innerException instanceof StorageException\n           \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n \n         throw new FileNotFoundException(String.format(\"%s is not found\", f));\n       }\n \n       throw ex;\n     }\n \n     if (meta !\u003d null) {\n       if (!meta.isDir()) {\n \n         LOG.debug(\"Found path as a file\");\n \n         return new FileStatus[] { newFile(meta, absolutePath) };\n       }\n \n       String partialKey \u003d null;\n       PartialListing listing \u003d null;\n \n       try {\n         listing  \u003d store.list(key, AZURE_LIST_ALL, 1, partialKey);\n       } catch (IOException ex) {\n \n         Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n \n         if (innerException instanceof StorageException\n             \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n \n             throw new FileNotFoundException(String.format(\"%s is not found\", key));\n         }\n \n         throw ex;\n       }\n       // NOTE: We don\u0027t check for Null condition as the Store API should return\n       // an empty list if there are not listing.\n \n       // For any -RenamePending.json files in the listing,\n       // push the rename forward.\n       boolean renamed \u003d conditionalRedoFolderRenames(listing);\n \n       // If any renames were redone, get another listing,\n       // since the current one may have changed due to the redo.\n       if (renamed) {\n        listing \u003d null;\n        try {\n          listing \u003d store.list(key, AZURE_LIST_ALL, 1, partialKey);\n        } catch (IOException ex) {\n          Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n \n          if (innerException instanceof StorageException\n              \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n \n            throw new FileNotFoundException(String.format(\"%s is not found\", key));\n          }\n \n          throw ex;\n        }\n       }\n \n       // NOTE: We don\u0027t check for Null condition as the Store API should return\n       // and empty list if there are not listing.\n \n       for (FileMetadata fileMetadata : listing.getFiles()) {\n         Path subpath \u003d keyToPath(fileMetadata.getKey());\n \n         // Test whether the metadata represents a file or directory and\n         // add the appropriate metadata object.\n         //\n         // Note: There was a very old bug here where directories were added\n         // to the status set as files flattening out recursive listings\n         // using \"-lsr\" down the file system hierarchy.\n         if (fileMetadata.isDir()) {\n           // Make sure we hide the temp upload folder\n           if (fileMetadata.getKey().equals(AZURE_TEMP_FOLDER)) {\n             // Don\u0027t expose that.\n             continue;\n           }\n           status.add(newDirectory(fileMetadata, subpath));\n         } else {\n           status.add(newFile(fileMetadata, subpath));\n         }\n       }\n \n       LOG.debug(\"Found path as a directory with {}\"\n           + \" files in it.\", status.size());\n \n     } else {\n       // There is no metadata found for the path.\n       LOG.debug(\"Did not find any metadata for path: {}\", key);\n \n       throw new FileNotFoundException(\"File\" + f + \" does not exist.\");\n     }\n \n     return status.toArray(new FileStatus[0]);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FileStatus[] listStatus(Path f) throws FileNotFoundException, IOException {\n\n    LOG.debug(\"Listing status for {}\", f.toString());\n\n    Path absolutePath \u003d makeAbsolute(f);\n\n    performAuthCheck(absolutePath, WasbAuthorizationOperations.READ, \"liststatus\", absolutePath);\n\n    String key \u003d pathToKey(absolutePath);\n    Set\u003cFileStatus\u003e status \u003d new TreeSet\u003cFileStatus\u003e();\n    FileMetadata meta \u003d null;\n    try {\n      meta \u003d store.retrieveMetadata(key);\n    } catch (IOException ex) {\n\n      Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n\n      if (innerException instanceof StorageException\n          \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n\n        throw new FileNotFoundException(String.format(\"%s is not found\", f));\n      }\n\n      throw ex;\n    }\n\n    if (meta !\u003d null) {\n      if (!meta.isDir()) {\n\n        LOG.debug(\"Found path as a file\");\n\n        return new FileStatus[] { newFile(meta, absolutePath) };\n      }\n\n      String partialKey \u003d null;\n      PartialListing listing \u003d null;\n\n      try {\n        listing  \u003d store.list(key, AZURE_LIST_ALL, 1, partialKey);\n      } catch (IOException ex) {\n\n        Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n\n        if (innerException instanceof StorageException\n            \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n\n            throw new FileNotFoundException(String.format(\"%s is not found\", key));\n        }\n\n        throw ex;\n      }\n      // NOTE: We don\u0027t check for Null condition as the Store API should return\n      // an empty list if there are not listing.\n\n      // For any -RenamePending.json files in the listing,\n      // push the rename forward.\n      boolean renamed \u003d conditionalRedoFolderRenames(listing);\n\n      // If any renames were redone, get another listing,\n      // since the current one may have changed due to the redo.\n      if (renamed) {\n       listing \u003d null;\n       try {\n         listing \u003d store.list(key, AZURE_LIST_ALL, 1, partialKey);\n       } catch (IOException ex) {\n         Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n\n         if (innerException instanceof StorageException\n             \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n\n           throw new FileNotFoundException(String.format(\"%s is not found\", key));\n         }\n\n         throw ex;\n       }\n      }\n\n      // NOTE: We don\u0027t check for Null condition as the Store API should return\n      // and empty list if there are not listing.\n\n      for (FileMetadata fileMetadata : listing.getFiles()) {\n        Path subpath \u003d keyToPath(fileMetadata.getKey());\n\n        // Test whether the metadata represents a file or directory and\n        // add the appropriate metadata object.\n        //\n        // Note: There was a very old bug here where directories were added\n        // to the status set as files flattening out recursive listings\n        // using \"-lsr\" down the file system hierarchy.\n        if (fileMetadata.isDir()) {\n          // Make sure we hide the temp upload folder\n          if (fileMetadata.getKey().equals(AZURE_TEMP_FOLDER)) {\n            // Don\u0027t expose that.\n            continue;\n          }\n          status.add(newDirectory(fileMetadata, subpath));\n        } else {\n          status.add(newFile(fileMetadata, subpath));\n        }\n      }\n\n      LOG.debug(\"Found path as a directory with {}\"\n          + \" files in it.\", status.size());\n\n    } else {\n      // There is no metadata found for the path.\n      LOG.debug(\"Did not find any metadata for path: {}\", key);\n\n      throw new FileNotFoundException(\"File\" + f + \" does not exist.\");\n    }\n\n    return status.toArray(new FileStatus[0]);\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
      "extendedDetails": {}
    },
    "0cab57223e3f54be17a5f27cefdb6d1da1b073e5": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14274. Azure: Simplify Ranger-WASB policy model. Contributed by Sivaguru Sankaridurg\n",
      "commitDate": "12/04/17 4:07 PM",
      "commitName": "0cab57223e3f54be17a5f27cefdb6d1da1b073e5",
      "commitAuthor": "Mingliang Liu",
      "commitDateOld": "04/04/17 11:10 AM",
      "commitNameOld": "56ab02eed9b61e1c80605104dfc4c87fc6abac96",
      "commitAuthorOld": "Mingliang Liu",
      "daysBetweenCommits": 8.21,
      "commitsBetweenForRepo": 67,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,114 +1,113 @@\n   public FileStatus[] listStatus(Path f) throws FileNotFoundException, IOException {\n \n     LOG.debug(\"Listing status for {}\", f.toString());\n \n     Path absolutePath \u003d makeAbsolute(f);\n \n-    performAuthCheck(absolutePath.toString(),\n-        WasbAuthorizationOperations.EXECUTE.toString(), \"list\");\n+    performAuthCheck(absolutePath.toString(), WasbAuthorizationOperations.READ, \"liststatus\", absolutePath.toString());\n \n     String key \u003d pathToKey(absolutePath);\n     Set\u003cFileStatus\u003e status \u003d new TreeSet\u003cFileStatus\u003e();\n     FileMetadata meta \u003d null;\n     try {\n       meta \u003d store.retrieveMetadata(key);\n     } catch (IOException ex) {\n \n       Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n \n       if (innerException instanceof StorageException\n           \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n \n         throw new FileNotFoundException(String.format(\"%s is not found\", f));\n       }\n \n       throw ex;\n     }\n \n     if (meta !\u003d null) {\n       if (!meta.isDir()) {\n \n         LOG.debug(\"Found path as a file\");\n \n         return new FileStatus[] { newFile(meta, absolutePath) };\n       }\n \n       String partialKey \u003d null;\n       PartialListing listing \u003d null;\n \n       try {\n         listing  \u003d store.list(key, AZURE_LIST_ALL, 1, partialKey);\n       } catch (IOException ex) {\n \n         Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n \n         if (innerException instanceof StorageException\n             \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n \n             throw new FileNotFoundException(String.format(\"%s is not found\", key));\n         }\n \n         throw ex;\n       }\n       // NOTE: We don\u0027t check for Null condition as the Store API should return\n       // an empty list if there are not listing.\n \n       // For any -RenamePending.json files in the listing,\n       // push the rename forward.\n       boolean renamed \u003d conditionalRedoFolderRenames(listing);\n \n       // If any renames were redone, get another listing,\n       // since the current one may have changed due to the redo.\n       if (renamed) {\n        listing \u003d null;\n        try {\n          listing \u003d store.list(key, AZURE_LIST_ALL, 1, partialKey);\n        } catch (IOException ex) {\n          Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n \n          if (innerException instanceof StorageException\n              \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n \n            throw new FileNotFoundException(String.format(\"%s is not found\", key));\n          }\n \n          throw ex;\n        }\n       }\n \n       // NOTE: We don\u0027t check for Null condition as the Store API should return\n       // and empty list if there are not listing.\n \n       for (FileMetadata fileMetadata : listing.getFiles()) {\n         Path subpath \u003d keyToPath(fileMetadata.getKey());\n \n         // Test whether the metadata represents a file or directory and\n         // add the appropriate metadata object.\n         //\n         // Note: There was a very old bug here where directories were added\n         // to the status set as files flattening out recursive listings\n         // using \"-lsr\" down the file system hierarchy.\n         if (fileMetadata.isDir()) {\n           // Make sure we hide the temp upload folder\n           if (fileMetadata.getKey().equals(AZURE_TEMP_FOLDER)) {\n             // Don\u0027t expose that.\n             continue;\n           }\n           status.add(newDirectory(fileMetadata, subpath));\n         } else {\n           status.add(newFile(fileMetadata, subpath));\n         }\n       }\n \n       LOG.debug(\"Found path as a directory with {}\"\n           + \" files in it.\", status.size());\n \n     } else {\n       // There is no metadata found for the path.\n       LOG.debug(\"Did not find any metadata for path: {}\", key);\n \n       throw new FileNotFoundException(\"File\" + f + \" does not exist.\");\n     }\n \n     return status.toArray(new FileStatus[0]);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FileStatus[] listStatus(Path f) throws FileNotFoundException, IOException {\n\n    LOG.debug(\"Listing status for {}\", f.toString());\n\n    Path absolutePath \u003d makeAbsolute(f);\n\n    performAuthCheck(absolutePath.toString(), WasbAuthorizationOperations.READ, \"liststatus\", absolutePath.toString());\n\n    String key \u003d pathToKey(absolutePath);\n    Set\u003cFileStatus\u003e status \u003d new TreeSet\u003cFileStatus\u003e();\n    FileMetadata meta \u003d null;\n    try {\n      meta \u003d store.retrieveMetadata(key);\n    } catch (IOException ex) {\n\n      Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n\n      if (innerException instanceof StorageException\n          \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n\n        throw new FileNotFoundException(String.format(\"%s is not found\", f));\n      }\n\n      throw ex;\n    }\n\n    if (meta !\u003d null) {\n      if (!meta.isDir()) {\n\n        LOG.debug(\"Found path as a file\");\n\n        return new FileStatus[] { newFile(meta, absolutePath) };\n      }\n\n      String partialKey \u003d null;\n      PartialListing listing \u003d null;\n\n      try {\n        listing  \u003d store.list(key, AZURE_LIST_ALL, 1, partialKey);\n      } catch (IOException ex) {\n\n        Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n\n        if (innerException instanceof StorageException\n            \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n\n            throw new FileNotFoundException(String.format(\"%s is not found\", key));\n        }\n\n        throw ex;\n      }\n      // NOTE: We don\u0027t check for Null condition as the Store API should return\n      // an empty list if there are not listing.\n\n      // For any -RenamePending.json files in the listing,\n      // push the rename forward.\n      boolean renamed \u003d conditionalRedoFolderRenames(listing);\n\n      // If any renames were redone, get another listing,\n      // since the current one may have changed due to the redo.\n      if (renamed) {\n       listing \u003d null;\n       try {\n         listing \u003d store.list(key, AZURE_LIST_ALL, 1, partialKey);\n       } catch (IOException ex) {\n         Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n\n         if (innerException instanceof StorageException\n             \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n\n           throw new FileNotFoundException(String.format(\"%s is not found\", key));\n         }\n\n         throw ex;\n       }\n      }\n\n      // NOTE: We don\u0027t check for Null condition as the Store API should return\n      // and empty list if there are not listing.\n\n      for (FileMetadata fileMetadata : listing.getFiles()) {\n        Path subpath \u003d keyToPath(fileMetadata.getKey());\n\n        // Test whether the metadata represents a file or directory and\n        // add the appropriate metadata object.\n        //\n        // Note: There was a very old bug here where directories were added\n        // to the status set as files flattening out recursive listings\n        // using \"-lsr\" down the file system hierarchy.\n        if (fileMetadata.isDir()) {\n          // Make sure we hide the temp upload folder\n          if (fileMetadata.getKey().equals(AZURE_TEMP_FOLDER)) {\n            // Don\u0027t expose that.\n            continue;\n          }\n          status.add(newDirectory(fileMetadata, subpath));\n        } else {\n          status.add(newFile(fileMetadata, subpath));\n        }\n      }\n\n      LOG.debug(\"Found path as a directory with {}\"\n          + \" files in it.\", status.size());\n\n    } else {\n      // There is no metadata found for the path.\n      LOG.debug(\"Did not find any metadata for path: {}\", key);\n\n      throw new FileNotFoundException(\"File\" + f + \" does not exist.\");\n    }\n\n    return status.toArray(new FileStatus[0]);\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
      "extendedDetails": {}
    },
    "686823529be09bea2a6cecb3503ef722017475bc": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13930. Azure: Add Authorization support to WASB. Contributed by Sivaguru Sankaridurg and Dushyanth\n",
      "commitDate": "06/03/17 5:16 PM",
      "commitName": "686823529be09bea2a6cecb3503ef722017475bc",
      "commitAuthor": "Mingliang Liu",
      "commitDateOld": "06/03/17 5:10 PM",
      "commitNameOld": "52d7d5aa1a303cf70519a61487641211f4267c6f",
      "commitAuthorOld": "Mingliang Liu",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,110 +1,114 @@\n   public FileStatus[] listStatus(Path f) throws FileNotFoundException, IOException {\n \n     LOG.debug(\"Listing status for {}\", f.toString());\n \n     Path absolutePath \u003d makeAbsolute(f);\n+\n+    performAuthCheck(absolutePath.toString(),\n+        WasbAuthorizationOperations.EXECUTE.toString(), \"list\");\n+\n     String key \u003d pathToKey(absolutePath);\n     Set\u003cFileStatus\u003e status \u003d new TreeSet\u003cFileStatus\u003e();\n     FileMetadata meta \u003d null;\n     try {\n       meta \u003d store.retrieveMetadata(key);\n     } catch (IOException ex) {\n \n       Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n \n       if (innerException instanceof StorageException\n           \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n \n         throw new FileNotFoundException(String.format(\"%s is not found\", f));\n       }\n \n       throw ex;\n     }\n \n     if (meta !\u003d null) {\n       if (!meta.isDir()) {\n \n         LOG.debug(\"Found path as a file\");\n \n         return new FileStatus[] { newFile(meta, absolutePath) };\n       }\n \n       String partialKey \u003d null;\n       PartialListing listing \u003d null;\n \n       try {\n         listing  \u003d store.list(key, AZURE_LIST_ALL, 1, partialKey);\n       } catch (IOException ex) {\n \n         Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n \n         if (innerException instanceof StorageException\n             \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n \n             throw new FileNotFoundException(String.format(\"%s is not found\", key));\n         }\n \n         throw ex;\n       }\n       // NOTE: We don\u0027t check for Null condition as the Store API should return\n       // an empty list if there are not listing.\n \n       // For any -RenamePending.json files in the listing,\n       // push the rename forward.\n       boolean renamed \u003d conditionalRedoFolderRenames(listing);\n \n       // If any renames were redone, get another listing,\n       // since the current one may have changed due to the redo.\n       if (renamed) {\n        listing \u003d null;\n        try {\n          listing \u003d store.list(key, AZURE_LIST_ALL, 1, partialKey);\n        } catch (IOException ex) {\n          Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n \n          if (innerException instanceof StorageException\n              \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n \n            throw new FileNotFoundException(String.format(\"%s is not found\", key));\n          }\n \n          throw ex;\n        }\n       }\n \n       // NOTE: We don\u0027t check for Null condition as the Store API should return\n       // and empty list if there are not listing.\n \n       for (FileMetadata fileMetadata : listing.getFiles()) {\n         Path subpath \u003d keyToPath(fileMetadata.getKey());\n \n         // Test whether the metadata represents a file or directory and\n         // add the appropriate metadata object.\n         //\n         // Note: There was a very old bug here where directories were added\n         // to the status set as files flattening out recursive listings\n         // using \"-lsr\" down the file system hierarchy.\n         if (fileMetadata.isDir()) {\n           // Make sure we hide the temp upload folder\n           if (fileMetadata.getKey().equals(AZURE_TEMP_FOLDER)) {\n             // Don\u0027t expose that.\n             continue;\n           }\n           status.add(newDirectory(fileMetadata, subpath));\n         } else {\n           status.add(newFile(fileMetadata, subpath));\n         }\n       }\n \n       LOG.debug(\"Found path as a directory with {}\"\n           + \" files in it.\", status.size());\n \n     } else {\n       // There is no metadata found for the path.\n       LOG.debug(\"Did not find any metadata for path: {}\", key);\n \n       throw new FileNotFoundException(\"File\" + f + \" does not exist.\");\n     }\n \n     return status.toArray(new FileStatus[0]);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FileStatus[] listStatus(Path f) throws FileNotFoundException, IOException {\n\n    LOG.debug(\"Listing status for {}\", f.toString());\n\n    Path absolutePath \u003d makeAbsolute(f);\n\n    performAuthCheck(absolutePath.toString(),\n        WasbAuthorizationOperations.EXECUTE.toString(), \"list\");\n\n    String key \u003d pathToKey(absolutePath);\n    Set\u003cFileStatus\u003e status \u003d new TreeSet\u003cFileStatus\u003e();\n    FileMetadata meta \u003d null;\n    try {\n      meta \u003d store.retrieveMetadata(key);\n    } catch (IOException ex) {\n\n      Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n\n      if (innerException instanceof StorageException\n          \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n\n        throw new FileNotFoundException(String.format(\"%s is not found\", f));\n      }\n\n      throw ex;\n    }\n\n    if (meta !\u003d null) {\n      if (!meta.isDir()) {\n\n        LOG.debug(\"Found path as a file\");\n\n        return new FileStatus[] { newFile(meta, absolutePath) };\n      }\n\n      String partialKey \u003d null;\n      PartialListing listing \u003d null;\n\n      try {\n        listing  \u003d store.list(key, AZURE_LIST_ALL, 1, partialKey);\n      } catch (IOException ex) {\n\n        Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n\n        if (innerException instanceof StorageException\n            \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n\n            throw new FileNotFoundException(String.format(\"%s is not found\", key));\n        }\n\n        throw ex;\n      }\n      // NOTE: We don\u0027t check for Null condition as the Store API should return\n      // an empty list if there are not listing.\n\n      // For any -RenamePending.json files in the listing,\n      // push the rename forward.\n      boolean renamed \u003d conditionalRedoFolderRenames(listing);\n\n      // If any renames were redone, get another listing,\n      // since the current one may have changed due to the redo.\n      if (renamed) {\n       listing \u003d null;\n       try {\n         listing \u003d store.list(key, AZURE_LIST_ALL, 1, partialKey);\n       } catch (IOException ex) {\n         Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n\n         if (innerException instanceof StorageException\n             \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n\n           throw new FileNotFoundException(String.format(\"%s is not found\", key));\n         }\n\n         throw ex;\n       }\n      }\n\n      // NOTE: We don\u0027t check for Null condition as the Store API should return\n      // and empty list if there are not listing.\n\n      for (FileMetadata fileMetadata : listing.getFiles()) {\n        Path subpath \u003d keyToPath(fileMetadata.getKey());\n\n        // Test whether the metadata represents a file or directory and\n        // add the appropriate metadata object.\n        //\n        // Note: There was a very old bug here where directories were added\n        // to the status set as files flattening out recursive listings\n        // using \"-lsr\" down the file system hierarchy.\n        if (fileMetadata.isDir()) {\n          // Make sure we hide the temp upload folder\n          if (fileMetadata.getKey().equals(AZURE_TEMP_FOLDER)) {\n            // Don\u0027t expose that.\n            continue;\n          }\n          status.add(newDirectory(fileMetadata, subpath));\n        } else {\n          status.add(newFile(fileMetadata, subpath));\n        }\n      }\n\n      LOG.debug(\"Found path as a directory with {}\"\n          + \" files in it.\", status.size());\n\n    } else {\n      // There is no metadata found for the path.\n      LOG.debug(\"Did not find any metadata for path: {}\", key);\n\n      throw new FileNotFoundException(\"File\" + f + \" does not exist.\");\n    }\n\n    return status.toArray(new FileStatus[0]);\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
      "extendedDetails": {}
    },
    "52d7d5aa1a303cf70519a61487641211f4267c6f": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HADOOP-13930. Azure: Add Authorization support to WASB. Contributed by Sivaguru Sankaridurg and Dushyanth\"\n\nThis reverts commit 6b7cd62b8cf12616b13142f2eb2cfc2f25796f0f.\n",
      "commitDate": "06/03/17 5:10 PM",
      "commitName": "52d7d5aa1a303cf70519a61487641211f4267c6f",
      "commitAuthor": "Mingliang Liu",
      "commitDateOld": "06/03/17 5:00 PM",
      "commitNameOld": "c571cda5c7d929477961dfff4176d7de4944d874",
      "commitAuthorOld": "Mingliang Liu",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,114 +1,110 @@\n   public FileStatus[] listStatus(Path f) throws FileNotFoundException, IOException {\n \n     LOG.debug(\"Listing status for {}\", f.toString());\n \n     Path absolutePath \u003d makeAbsolute(f);\n-\n-    performAuthCheck(absolutePath.toString(),\n-        WasbAuthorizationOperations.EXECUTE.toString(), \"list\");\n-\n     String key \u003d pathToKey(absolutePath);\n     Set\u003cFileStatus\u003e status \u003d new TreeSet\u003cFileStatus\u003e();\n     FileMetadata meta \u003d null;\n     try {\n       meta \u003d store.retrieveMetadata(key);\n     } catch (IOException ex) {\n \n       Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n \n       if (innerException instanceof StorageException\n           \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n \n         throw new FileNotFoundException(String.format(\"%s is not found\", f));\n       }\n \n       throw ex;\n     }\n \n     if (meta !\u003d null) {\n       if (!meta.isDir()) {\n \n         LOG.debug(\"Found path as a file\");\n \n         return new FileStatus[] { newFile(meta, absolutePath) };\n       }\n \n       String partialKey \u003d null;\n       PartialListing listing \u003d null;\n \n       try {\n         listing  \u003d store.list(key, AZURE_LIST_ALL, 1, partialKey);\n       } catch (IOException ex) {\n \n         Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n \n         if (innerException instanceof StorageException\n             \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n \n             throw new FileNotFoundException(String.format(\"%s is not found\", key));\n         }\n \n         throw ex;\n       }\n       // NOTE: We don\u0027t check for Null condition as the Store API should return\n       // an empty list if there are not listing.\n \n       // For any -RenamePending.json files in the listing,\n       // push the rename forward.\n       boolean renamed \u003d conditionalRedoFolderRenames(listing);\n \n       // If any renames were redone, get another listing,\n       // since the current one may have changed due to the redo.\n       if (renamed) {\n        listing \u003d null;\n        try {\n          listing \u003d store.list(key, AZURE_LIST_ALL, 1, partialKey);\n        } catch (IOException ex) {\n          Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n \n          if (innerException instanceof StorageException\n              \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n \n            throw new FileNotFoundException(String.format(\"%s is not found\", key));\n          }\n \n          throw ex;\n        }\n       }\n \n       // NOTE: We don\u0027t check for Null condition as the Store API should return\n       // and empty list if there are not listing.\n \n       for (FileMetadata fileMetadata : listing.getFiles()) {\n         Path subpath \u003d keyToPath(fileMetadata.getKey());\n \n         // Test whether the metadata represents a file or directory and\n         // add the appropriate metadata object.\n         //\n         // Note: There was a very old bug here where directories were added\n         // to the status set as files flattening out recursive listings\n         // using \"-lsr\" down the file system hierarchy.\n         if (fileMetadata.isDir()) {\n           // Make sure we hide the temp upload folder\n           if (fileMetadata.getKey().equals(AZURE_TEMP_FOLDER)) {\n             // Don\u0027t expose that.\n             continue;\n           }\n           status.add(newDirectory(fileMetadata, subpath));\n         } else {\n           status.add(newFile(fileMetadata, subpath));\n         }\n       }\n \n       LOG.debug(\"Found path as a directory with {}\"\n           + \" files in it.\", status.size());\n \n     } else {\n       // There is no metadata found for the path.\n       LOG.debug(\"Did not find any metadata for path: {}\", key);\n \n       throw new FileNotFoundException(\"File\" + f + \" does not exist.\");\n     }\n \n     return status.toArray(new FileStatus[0]);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FileStatus[] listStatus(Path f) throws FileNotFoundException, IOException {\n\n    LOG.debug(\"Listing status for {}\", f.toString());\n\n    Path absolutePath \u003d makeAbsolute(f);\n    String key \u003d pathToKey(absolutePath);\n    Set\u003cFileStatus\u003e status \u003d new TreeSet\u003cFileStatus\u003e();\n    FileMetadata meta \u003d null;\n    try {\n      meta \u003d store.retrieveMetadata(key);\n    } catch (IOException ex) {\n\n      Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n\n      if (innerException instanceof StorageException\n          \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n\n        throw new FileNotFoundException(String.format(\"%s is not found\", f));\n      }\n\n      throw ex;\n    }\n\n    if (meta !\u003d null) {\n      if (!meta.isDir()) {\n\n        LOG.debug(\"Found path as a file\");\n\n        return new FileStatus[] { newFile(meta, absolutePath) };\n      }\n\n      String partialKey \u003d null;\n      PartialListing listing \u003d null;\n\n      try {\n        listing  \u003d store.list(key, AZURE_LIST_ALL, 1, partialKey);\n      } catch (IOException ex) {\n\n        Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n\n        if (innerException instanceof StorageException\n            \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n\n            throw new FileNotFoundException(String.format(\"%s is not found\", key));\n        }\n\n        throw ex;\n      }\n      // NOTE: We don\u0027t check for Null condition as the Store API should return\n      // an empty list if there are not listing.\n\n      // For any -RenamePending.json files in the listing,\n      // push the rename forward.\n      boolean renamed \u003d conditionalRedoFolderRenames(listing);\n\n      // If any renames were redone, get another listing,\n      // since the current one may have changed due to the redo.\n      if (renamed) {\n       listing \u003d null;\n       try {\n         listing \u003d store.list(key, AZURE_LIST_ALL, 1, partialKey);\n       } catch (IOException ex) {\n         Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n\n         if (innerException instanceof StorageException\n             \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n\n           throw new FileNotFoundException(String.format(\"%s is not found\", key));\n         }\n\n         throw ex;\n       }\n      }\n\n      // NOTE: We don\u0027t check for Null condition as the Store API should return\n      // and empty list if there are not listing.\n\n      for (FileMetadata fileMetadata : listing.getFiles()) {\n        Path subpath \u003d keyToPath(fileMetadata.getKey());\n\n        // Test whether the metadata represents a file or directory and\n        // add the appropriate metadata object.\n        //\n        // Note: There was a very old bug here where directories were added\n        // to the status set as files flattening out recursive listings\n        // using \"-lsr\" down the file system hierarchy.\n        if (fileMetadata.isDir()) {\n          // Make sure we hide the temp upload folder\n          if (fileMetadata.getKey().equals(AZURE_TEMP_FOLDER)) {\n            // Don\u0027t expose that.\n            continue;\n          }\n          status.add(newDirectory(fileMetadata, subpath));\n        } else {\n          status.add(newFile(fileMetadata, subpath));\n        }\n      }\n\n      LOG.debug(\"Found path as a directory with {}\"\n          + \" files in it.\", status.size());\n\n    } else {\n      // There is no metadata found for the path.\n      LOG.debug(\"Did not find any metadata for path: {}\", key);\n\n      throw new FileNotFoundException(\"File\" + f + \" does not exist.\");\n    }\n\n    return status.toArray(new FileStatus[0]);\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
      "extendedDetails": {}
    },
    "6b7cd62b8cf12616b13142f2eb2cfc2f25796f0f": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13930. Azure: Add Authorization support to WASB. Contributed by Sivaguru Sankaridurg and Dushyanth\n",
      "commitDate": "03/03/17 5:09 PM",
      "commitName": "6b7cd62b8cf12616b13142f2eb2cfc2f25796f0f",
      "commitAuthor": "Mingliang Liu",
      "commitDateOld": "29/12/16 4:24 PM",
      "commitNameOld": "c6a5b689db573046819f0e9193cb042e6c7298f4",
      "commitAuthorOld": "Mingliang Liu",
      "daysBetweenCommits": 64.03,
      "commitsBetweenForRepo": 324,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,110 +1,114 @@\n   public FileStatus[] listStatus(Path f) throws FileNotFoundException, IOException {\n \n     LOG.debug(\"Listing status for {}\", f.toString());\n \n     Path absolutePath \u003d makeAbsolute(f);\n+\n+    performAuthCheck(absolutePath.toString(),\n+        WasbAuthorizationOperations.EXECUTE.toString(), \"list\");\n+\n     String key \u003d pathToKey(absolutePath);\n     Set\u003cFileStatus\u003e status \u003d new TreeSet\u003cFileStatus\u003e();\n     FileMetadata meta \u003d null;\n     try {\n       meta \u003d store.retrieveMetadata(key);\n     } catch (IOException ex) {\n \n       Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n \n       if (innerException instanceof StorageException\n           \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n \n         throw new FileNotFoundException(String.format(\"%s is not found\", f));\n       }\n \n       throw ex;\n     }\n \n     if (meta !\u003d null) {\n       if (!meta.isDir()) {\n \n         LOG.debug(\"Found path as a file\");\n \n         return new FileStatus[] { newFile(meta, absolutePath) };\n       }\n \n       String partialKey \u003d null;\n       PartialListing listing \u003d null;\n \n       try {\n         listing  \u003d store.list(key, AZURE_LIST_ALL, 1, partialKey);\n       } catch (IOException ex) {\n \n         Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n \n         if (innerException instanceof StorageException\n             \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n \n             throw new FileNotFoundException(String.format(\"%s is not found\", key));\n         }\n \n         throw ex;\n       }\n       // NOTE: We don\u0027t check for Null condition as the Store API should return\n       // an empty list if there are not listing.\n \n       // For any -RenamePending.json files in the listing,\n       // push the rename forward.\n       boolean renamed \u003d conditionalRedoFolderRenames(listing);\n \n       // If any renames were redone, get another listing,\n       // since the current one may have changed due to the redo.\n       if (renamed) {\n        listing \u003d null;\n        try {\n          listing \u003d store.list(key, AZURE_LIST_ALL, 1, partialKey);\n        } catch (IOException ex) {\n          Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n \n          if (innerException instanceof StorageException\n              \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n \n            throw new FileNotFoundException(String.format(\"%s is not found\", key));\n          }\n \n          throw ex;\n        }\n       }\n \n       // NOTE: We don\u0027t check for Null condition as the Store API should return\n       // and empty list if there are not listing.\n \n       for (FileMetadata fileMetadata : listing.getFiles()) {\n         Path subpath \u003d keyToPath(fileMetadata.getKey());\n \n         // Test whether the metadata represents a file or directory and\n         // add the appropriate metadata object.\n         //\n         // Note: There was a very old bug here where directories were added\n         // to the status set as files flattening out recursive listings\n         // using \"-lsr\" down the file system hierarchy.\n         if (fileMetadata.isDir()) {\n           // Make sure we hide the temp upload folder\n           if (fileMetadata.getKey().equals(AZURE_TEMP_FOLDER)) {\n             // Don\u0027t expose that.\n             continue;\n           }\n           status.add(newDirectory(fileMetadata, subpath));\n         } else {\n           status.add(newFile(fileMetadata, subpath));\n         }\n       }\n \n       LOG.debug(\"Found path as a directory with {}\"\n           + \" files in it.\", status.size());\n \n     } else {\n       // There is no metadata found for the path.\n       LOG.debug(\"Did not find any metadata for path: {}\", key);\n \n       throw new FileNotFoundException(\"File\" + f + \" does not exist.\");\n     }\n \n     return status.toArray(new FileStatus[0]);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FileStatus[] listStatus(Path f) throws FileNotFoundException, IOException {\n\n    LOG.debug(\"Listing status for {}\", f.toString());\n\n    Path absolutePath \u003d makeAbsolute(f);\n\n    performAuthCheck(absolutePath.toString(),\n        WasbAuthorizationOperations.EXECUTE.toString(), \"list\");\n\n    String key \u003d pathToKey(absolutePath);\n    Set\u003cFileStatus\u003e status \u003d new TreeSet\u003cFileStatus\u003e();\n    FileMetadata meta \u003d null;\n    try {\n      meta \u003d store.retrieveMetadata(key);\n    } catch (IOException ex) {\n\n      Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n\n      if (innerException instanceof StorageException\n          \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n\n        throw new FileNotFoundException(String.format(\"%s is not found\", f));\n      }\n\n      throw ex;\n    }\n\n    if (meta !\u003d null) {\n      if (!meta.isDir()) {\n\n        LOG.debug(\"Found path as a file\");\n\n        return new FileStatus[] { newFile(meta, absolutePath) };\n      }\n\n      String partialKey \u003d null;\n      PartialListing listing \u003d null;\n\n      try {\n        listing  \u003d store.list(key, AZURE_LIST_ALL, 1, partialKey);\n      } catch (IOException ex) {\n\n        Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n\n        if (innerException instanceof StorageException\n            \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n\n            throw new FileNotFoundException(String.format(\"%s is not found\", key));\n        }\n\n        throw ex;\n      }\n      // NOTE: We don\u0027t check for Null condition as the Store API should return\n      // an empty list if there are not listing.\n\n      // For any -RenamePending.json files in the listing,\n      // push the rename forward.\n      boolean renamed \u003d conditionalRedoFolderRenames(listing);\n\n      // If any renames were redone, get another listing,\n      // since the current one may have changed due to the redo.\n      if (renamed) {\n       listing \u003d null;\n       try {\n         listing \u003d store.list(key, AZURE_LIST_ALL, 1, partialKey);\n       } catch (IOException ex) {\n         Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n\n         if (innerException instanceof StorageException\n             \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n\n           throw new FileNotFoundException(String.format(\"%s is not found\", key));\n         }\n\n         throw ex;\n       }\n      }\n\n      // NOTE: We don\u0027t check for Null condition as the Store API should return\n      // and empty list if there are not listing.\n\n      for (FileMetadata fileMetadata : listing.getFiles()) {\n        Path subpath \u003d keyToPath(fileMetadata.getKey());\n\n        // Test whether the metadata represents a file or directory and\n        // add the appropriate metadata object.\n        //\n        // Note: There was a very old bug here where directories were added\n        // to the status set as files flattening out recursive listings\n        // using \"-lsr\" down the file system hierarchy.\n        if (fileMetadata.isDir()) {\n          // Make sure we hide the temp upload folder\n          if (fileMetadata.getKey().equals(AZURE_TEMP_FOLDER)) {\n            // Don\u0027t expose that.\n            continue;\n          }\n          status.add(newDirectory(fileMetadata, subpath));\n        } else {\n          status.add(newFile(fileMetadata, subpath));\n        }\n      }\n\n      LOG.debug(\"Found path as a directory with {}\"\n          + \" files in it.\", status.size());\n\n    } else {\n      // There is no metadata found for the path.\n      LOG.debug(\"Did not find any metadata for path: {}\", key);\n\n      throw new FileNotFoundException(\"File\" + f + \" does not exist.\");\n    }\n\n    return status.toArray(new FileStatus[0]);\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
      "extendedDetails": {}
    },
    "8bc93db2e7c64830b6a662f28c8917a9eef4e7c9": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-12635. Adding Append API support for WASB. Contributed by Dushyanth.\n",
      "commitDate": "18/01/16 9:08 AM",
      "commitName": "8bc93db2e7c64830b6a662f28c8917a9eef4e7c9",
      "commitAuthor": "cnauroth",
      "commitDateOld": "09/01/16 10:18 PM",
      "commitNameOld": "0e76f1fceaaaeb66bdb4818f43b9a55fc092bf79",
      "commitAuthorOld": "cnauroth",
      "daysBetweenCommits": 8.45,
      "commitsBetweenForRepo": 64,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,110 +1,110 @@\n   public FileStatus[] listStatus(Path f) throws FileNotFoundException, IOException {\n \n     LOG.debug(\"Listing status for {}\", f.toString());\n \n     Path absolutePath \u003d makeAbsolute(f);\n     String key \u003d pathToKey(absolutePath);\n     Set\u003cFileStatus\u003e status \u003d new TreeSet\u003cFileStatus\u003e();\n     FileMetadata meta \u003d null;\n     try {\n       meta \u003d store.retrieveMetadata(key);\n     } catch (IOException ex) {\n \n-      Throwable innerException \u003d NativeAzureFileSystem.checkForAzureStorageException(ex);\n+      Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n \n       if (innerException instanceof StorageException\n-          \u0026\u0026 NativeAzureFileSystem.isFileNotFoundException((StorageException) innerException)) {\n+          \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n \n         throw new FileNotFoundException(String.format(\"%s is not found\", f));\n       }\n \n       throw ex;\n     }\n \n     if (meta !\u003d null) {\n       if (!meta.isDir()) {\n \n         LOG.debug(\"Found path as a file\");\n \n         return new FileStatus[] { newFile(meta, absolutePath) };\n       }\n \n       String partialKey \u003d null;\n       PartialListing listing \u003d null;\n \n       try {\n         listing  \u003d store.list(key, AZURE_LIST_ALL, 1, partialKey);\n       } catch (IOException ex) {\n \n-        Throwable innerException \u003d NativeAzureFileSystem.checkForAzureStorageException(ex);\n+        Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n \n         if (innerException instanceof StorageException\n-            \u0026\u0026 NativeAzureFileSystem.isFileNotFoundException((StorageException) innerException)) {\n+            \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n \n             throw new FileNotFoundException(String.format(\"%s is not found\", key));\n         }\n \n         throw ex;\n       }\n       // NOTE: We don\u0027t check for Null condition as the Store API should return\n       // an empty list if there are not listing.\n \n       // For any -RenamePending.json files in the listing,\n       // push the rename forward.\n       boolean renamed \u003d conditionalRedoFolderRenames(listing);\n \n       // If any renames were redone, get another listing,\n       // since the current one may have changed due to the redo.\n       if (renamed) {\n        listing \u003d null;\n        try {\n          listing \u003d store.list(key, AZURE_LIST_ALL, 1, partialKey);\n        } catch (IOException ex) {\n-         Throwable innerException \u003d NativeAzureFileSystem.checkForAzureStorageException(ex);\n+         Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n \n          if (innerException instanceof StorageException\n-             \u0026\u0026 NativeAzureFileSystem.isFileNotFoundException((StorageException) innerException)) {\n+             \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n \n            throw new FileNotFoundException(String.format(\"%s is not found\", key));\n          }\n \n          throw ex;\n        }\n       }\n \n       // NOTE: We don\u0027t check for Null condition as the Store API should return\n       // and empty list if there are not listing.\n \n       for (FileMetadata fileMetadata : listing.getFiles()) {\n         Path subpath \u003d keyToPath(fileMetadata.getKey());\n \n         // Test whether the metadata represents a file or directory and\n         // add the appropriate metadata object.\n         //\n         // Note: There was a very old bug here where directories were added\n         // to the status set as files flattening out recursive listings\n         // using \"-lsr\" down the file system hierarchy.\n         if (fileMetadata.isDir()) {\n           // Make sure we hide the temp upload folder\n           if (fileMetadata.getKey().equals(AZURE_TEMP_FOLDER)) {\n             // Don\u0027t expose that.\n             continue;\n           }\n           status.add(newDirectory(fileMetadata, subpath));\n         } else {\n           status.add(newFile(fileMetadata, subpath));\n         }\n       }\n \n       LOG.debug(\"Found path as a directory with {}\"\n           + \" files in it.\", status.size());\n \n     } else {\n       // There is no metadata found for the path.\n       LOG.debug(\"Did not find any metadata for path: {}\", key);\n \n       throw new FileNotFoundException(\"File\" + f + \" does not exist.\");\n     }\n \n     return status.toArray(new FileStatus[0]);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FileStatus[] listStatus(Path f) throws FileNotFoundException, IOException {\n\n    LOG.debug(\"Listing status for {}\", f.toString());\n\n    Path absolutePath \u003d makeAbsolute(f);\n    String key \u003d pathToKey(absolutePath);\n    Set\u003cFileStatus\u003e status \u003d new TreeSet\u003cFileStatus\u003e();\n    FileMetadata meta \u003d null;\n    try {\n      meta \u003d store.retrieveMetadata(key);\n    } catch (IOException ex) {\n\n      Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n\n      if (innerException instanceof StorageException\n          \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n\n        throw new FileNotFoundException(String.format(\"%s is not found\", f));\n      }\n\n      throw ex;\n    }\n\n    if (meta !\u003d null) {\n      if (!meta.isDir()) {\n\n        LOG.debug(\"Found path as a file\");\n\n        return new FileStatus[] { newFile(meta, absolutePath) };\n      }\n\n      String partialKey \u003d null;\n      PartialListing listing \u003d null;\n\n      try {\n        listing  \u003d store.list(key, AZURE_LIST_ALL, 1, partialKey);\n      } catch (IOException ex) {\n\n        Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n\n        if (innerException instanceof StorageException\n            \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n\n            throw new FileNotFoundException(String.format(\"%s is not found\", key));\n        }\n\n        throw ex;\n      }\n      // NOTE: We don\u0027t check for Null condition as the Store API should return\n      // an empty list if there are not listing.\n\n      // For any -RenamePending.json files in the listing,\n      // push the rename forward.\n      boolean renamed \u003d conditionalRedoFolderRenames(listing);\n\n      // If any renames were redone, get another listing,\n      // since the current one may have changed due to the redo.\n      if (renamed) {\n       listing \u003d null;\n       try {\n         listing \u003d store.list(key, AZURE_LIST_ALL, 1, partialKey);\n       } catch (IOException ex) {\n         Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(ex);\n\n         if (innerException instanceof StorageException\n             \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n\n           throw new FileNotFoundException(String.format(\"%s is not found\", key));\n         }\n\n         throw ex;\n       }\n      }\n\n      // NOTE: We don\u0027t check for Null condition as the Store API should return\n      // and empty list if there are not listing.\n\n      for (FileMetadata fileMetadata : listing.getFiles()) {\n        Path subpath \u003d keyToPath(fileMetadata.getKey());\n\n        // Test whether the metadata represents a file or directory and\n        // add the appropriate metadata object.\n        //\n        // Note: There was a very old bug here where directories were added\n        // to the status set as files flattening out recursive listings\n        // using \"-lsr\" down the file system hierarchy.\n        if (fileMetadata.isDir()) {\n          // Make sure we hide the temp upload folder\n          if (fileMetadata.getKey().equals(AZURE_TEMP_FOLDER)) {\n            // Don\u0027t expose that.\n            continue;\n          }\n          status.add(newDirectory(fileMetadata, subpath));\n        } else {\n          status.add(newFile(fileMetadata, subpath));\n        }\n      }\n\n      LOG.debug(\"Found path as a directory with {}\"\n          + \" files in it.\", status.size());\n\n    } else {\n      // There is no metadata found for the path.\n      LOG.debug(\"Did not find any metadata for path: {}\", key);\n\n      throw new FileNotFoundException(\"File\" + f + \" does not exist.\");\n    }\n\n    return status.toArray(new FileStatus[0]);\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
      "extendedDetails": {}
    },
    "0e76f1fceaaaeb66bdb4818f43b9a55fc092bf79": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "HADOOP-12551. Introduce FileNotFoundException for WASB FileSystem API. Contributed by Dushyanth.\n",
      "commitDate": "09/01/16 10:18 PM",
      "commitName": "0e76f1fceaaaeb66bdb4818f43b9a55fc092bf79",
      "commitAuthor": "cnauroth",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "HADOOP-12551. Introduce FileNotFoundException for WASB FileSystem API. Contributed by Dushyanth.\n",
          "commitDate": "09/01/16 10:18 PM",
          "commitName": "0e76f1fceaaaeb66bdb4818f43b9a55fc092bf79",
          "commitAuthor": "cnauroth",
          "commitDateOld": "08/01/16 8:18 PM",
          "commitNameOld": "f0fa6d869b9abb5a900ea1c9eb4eb19ec9831dc4",
          "commitAuthorOld": "cnauroth",
          "daysBetweenCommits": 1.08,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,62 +1,110 @@\n-  public FileStatus[] listStatus(Path f) throws IOException {\n+  public FileStatus[] listStatus(Path f) throws FileNotFoundException, IOException {\n \n     LOG.debug(\"Listing status for {}\", f.toString());\n \n     Path absolutePath \u003d makeAbsolute(f);\n     String key \u003d pathToKey(absolutePath);\n     Set\u003cFileStatus\u003e status \u003d new TreeSet\u003cFileStatus\u003e();\n-    FileMetadata meta \u003d store.retrieveMetadata(key);\n+    FileMetadata meta \u003d null;\n+    try {\n+      meta \u003d store.retrieveMetadata(key);\n+    } catch (IOException ex) {\n+\n+      Throwable innerException \u003d NativeAzureFileSystem.checkForAzureStorageException(ex);\n+\n+      if (innerException instanceof StorageException\n+          \u0026\u0026 NativeAzureFileSystem.isFileNotFoundException((StorageException) innerException)) {\n+\n+        throw new FileNotFoundException(String.format(\"%s is not found\", f));\n+      }\n+\n+      throw ex;\n+    }\n \n     if (meta !\u003d null) {\n       if (!meta.isDir()) {\n \n         LOG.debug(\"Found path as a file\");\n \n         return new FileStatus[] { newFile(meta, absolutePath) };\n       }\n+\n       String partialKey \u003d null;\n-      PartialListing listing \u003d store.list(key, AZURE_LIST_ALL, 1, partialKey);\n+      PartialListing listing \u003d null;\n+\n+      try {\n+        listing  \u003d store.list(key, AZURE_LIST_ALL, 1, partialKey);\n+      } catch (IOException ex) {\n+\n+        Throwable innerException \u003d NativeAzureFileSystem.checkForAzureStorageException(ex);\n+\n+        if (innerException instanceof StorageException\n+            \u0026\u0026 NativeAzureFileSystem.isFileNotFoundException((StorageException) innerException)) {\n+\n+            throw new FileNotFoundException(String.format(\"%s is not found\", key));\n+        }\n+\n+        throw ex;\n+      }\n+      // NOTE: We don\u0027t check for Null condition as the Store API should return\n+      // an empty list if there are not listing.\n \n       // For any -RenamePending.json files in the listing,\n       // push the rename forward.\n       boolean renamed \u003d conditionalRedoFolderRenames(listing);\n \n       // If any renames were redone, get another listing,\n       // since the current one may have changed due to the redo.\n       if (renamed) {\n-        listing \u003d store.list(key, AZURE_LIST_ALL, 1, partialKey);\n+       listing \u003d null;\n+       try {\n+         listing \u003d store.list(key, AZURE_LIST_ALL, 1, partialKey);\n+       } catch (IOException ex) {\n+         Throwable innerException \u003d NativeAzureFileSystem.checkForAzureStorageException(ex);\n+\n+         if (innerException instanceof StorageException\n+             \u0026\u0026 NativeAzureFileSystem.isFileNotFoundException((StorageException) innerException)) {\n+\n+           throw new FileNotFoundException(String.format(\"%s is not found\", key));\n+         }\n+\n+         throw ex;\n+       }\n       }\n \n+      // NOTE: We don\u0027t check for Null condition as the Store API should return\n+      // and empty list if there are not listing.\n+\n       for (FileMetadata fileMetadata : listing.getFiles()) {\n         Path subpath \u003d keyToPath(fileMetadata.getKey());\n \n         // Test whether the metadata represents a file or directory and\n         // add the appropriate metadata object.\n         //\n         // Note: There was a very old bug here where directories were added\n         // to the status set as files flattening out recursive listings\n         // using \"-lsr\" down the file system hierarchy.\n         if (fileMetadata.isDir()) {\n           // Make sure we hide the temp upload folder\n           if (fileMetadata.getKey().equals(AZURE_TEMP_FOLDER)) {\n             // Don\u0027t expose that.\n             continue;\n           }\n           status.add(newDirectory(fileMetadata, subpath));\n         } else {\n           status.add(newFile(fileMetadata, subpath));\n         }\n       }\n \n       LOG.debug(\"Found path as a directory with {}\"\n           + \" files in it.\", status.size());\n \n     } else {\n       // There is no metadata found for the path.\n       LOG.debug(\"Did not find any metadata for path: {}\", key);\n \n       throw new FileNotFoundException(\"File\" + f + \" does not exist.\");\n     }\n \n     return status.toArray(new FileStatus[0]);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public FileStatus[] listStatus(Path f) throws FileNotFoundException, IOException {\n\n    LOG.debug(\"Listing status for {}\", f.toString());\n\n    Path absolutePath \u003d makeAbsolute(f);\n    String key \u003d pathToKey(absolutePath);\n    Set\u003cFileStatus\u003e status \u003d new TreeSet\u003cFileStatus\u003e();\n    FileMetadata meta \u003d null;\n    try {\n      meta \u003d store.retrieveMetadata(key);\n    } catch (IOException ex) {\n\n      Throwable innerException \u003d NativeAzureFileSystem.checkForAzureStorageException(ex);\n\n      if (innerException instanceof StorageException\n          \u0026\u0026 NativeAzureFileSystem.isFileNotFoundException((StorageException) innerException)) {\n\n        throw new FileNotFoundException(String.format(\"%s is not found\", f));\n      }\n\n      throw ex;\n    }\n\n    if (meta !\u003d null) {\n      if (!meta.isDir()) {\n\n        LOG.debug(\"Found path as a file\");\n\n        return new FileStatus[] { newFile(meta, absolutePath) };\n      }\n\n      String partialKey \u003d null;\n      PartialListing listing \u003d null;\n\n      try {\n        listing  \u003d store.list(key, AZURE_LIST_ALL, 1, partialKey);\n      } catch (IOException ex) {\n\n        Throwable innerException \u003d NativeAzureFileSystem.checkForAzureStorageException(ex);\n\n        if (innerException instanceof StorageException\n            \u0026\u0026 NativeAzureFileSystem.isFileNotFoundException((StorageException) innerException)) {\n\n            throw new FileNotFoundException(String.format(\"%s is not found\", key));\n        }\n\n        throw ex;\n      }\n      // NOTE: We don\u0027t check for Null condition as the Store API should return\n      // an empty list if there are not listing.\n\n      // For any -RenamePending.json files in the listing,\n      // push the rename forward.\n      boolean renamed \u003d conditionalRedoFolderRenames(listing);\n\n      // If any renames were redone, get another listing,\n      // since the current one may have changed due to the redo.\n      if (renamed) {\n       listing \u003d null;\n       try {\n         listing \u003d store.list(key, AZURE_LIST_ALL, 1, partialKey);\n       } catch (IOException ex) {\n         Throwable innerException \u003d NativeAzureFileSystem.checkForAzureStorageException(ex);\n\n         if (innerException instanceof StorageException\n             \u0026\u0026 NativeAzureFileSystem.isFileNotFoundException((StorageException) innerException)) {\n\n           throw new FileNotFoundException(String.format(\"%s is not found\", key));\n         }\n\n         throw ex;\n       }\n      }\n\n      // NOTE: We don\u0027t check for Null condition as the Store API should return\n      // and empty list if there are not listing.\n\n      for (FileMetadata fileMetadata : listing.getFiles()) {\n        Path subpath \u003d keyToPath(fileMetadata.getKey());\n\n        // Test whether the metadata represents a file or directory and\n        // add the appropriate metadata object.\n        //\n        // Note: There was a very old bug here where directories were added\n        // to the status set as files flattening out recursive listings\n        // using \"-lsr\" down the file system hierarchy.\n        if (fileMetadata.isDir()) {\n          // Make sure we hide the temp upload folder\n          if (fileMetadata.getKey().equals(AZURE_TEMP_FOLDER)) {\n            // Don\u0027t expose that.\n            continue;\n          }\n          status.add(newDirectory(fileMetadata, subpath));\n        } else {\n          status.add(newFile(fileMetadata, subpath));\n        }\n      }\n\n      LOG.debug(\"Found path as a directory with {}\"\n          + \" files in it.\", status.size());\n\n    } else {\n      // There is no metadata found for the path.\n      LOG.debug(\"Did not find any metadata for path: {}\", key);\n\n      throw new FileNotFoundException(\"File\" + f + \" does not exist.\");\n    }\n\n    return status.toArray(new FileStatus[0]);\n  }",
          "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
          "extendedDetails": {
            "oldValue": "[IOException]",
            "newValue": "[FileNotFoundException, IOException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-12551. Introduce FileNotFoundException for WASB FileSystem API. Contributed by Dushyanth.\n",
          "commitDate": "09/01/16 10:18 PM",
          "commitName": "0e76f1fceaaaeb66bdb4818f43b9a55fc092bf79",
          "commitAuthor": "cnauroth",
          "commitDateOld": "08/01/16 8:18 PM",
          "commitNameOld": "f0fa6d869b9abb5a900ea1c9eb4eb19ec9831dc4",
          "commitAuthorOld": "cnauroth",
          "daysBetweenCommits": 1.08,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,62 +1,110 @@\n-  public FileStatus[] listStatus(Path f) throws IOException {\n+  public FileStatus[] listStatus(Path f) throws FileNotFoundException, IOException {\n \n     LOG.debug(\"Listing status for {}\", f.toString());\n \n     Path absolutePath \u003d makeAbsolute(f);\n     String key \u003d pathToKey(absolutePath);\n     Set\u003cFileStatus\u003e status \u003d new TreeSet\u003cFileStatus\u003e();\n-    FileMetadata meta \u003d store.retrieveMetadata(key);\n+    FileMetadata meta \u003d null;\n+    try {\n+      meta \u003d store.retrieveMetadata(key);\n+    } catch (IOException ex) {\n+\n+      Throwable innerException \u003d NativeAzureFileSystem.checkForAzureStorageException(ex);\n+\n+      if (innerException instanceof StorageException\n+          \u0026\u0026 NativeAzureFileSystem.isFileNotFoundException((StorageException) innerException)) {\n+\n+        throw new FileNotFoundException(String.format(\"%s is not found\", f));\n+      }\n+\n+      throw ex;\n+    }\n \n     if (meta !\u003d null) {\n       if (!meta.isDir()) {\n \n         LOG.debug(\"Found path as a file\");\n \n         return new FileStatus[] { newFile(meta, absolutePath) };\n       }\n+\n       String partialKey \u003d null;\n-      PartialListing listing \u003d store.list(key, AZURE_LIST_ALL, 1, partialKey);\n+      PartialListing listing \u003d null;\n+\n+      try {\n+        listing  \u003d store.list(key, AZURE_LIST_ALL, 1, partialKey);\n+      } catch (IOException ex) {\n+\n+        Throwable innerException \u003d NativeAzureFileSystem.checkForAzureStorageException(ex);\n+\n+        if (innerException instanceof StorageException\n+            \u0026\u0026 NativeAzureFileSystem.isFileNotFoundException((StorageException) innerException)) {\n+\n+            throw new FileNotFoundException(String.format(\"%s is not found\", key));\n+        }\n+\n+        throw ex;\n+      }\n+      // NOTE: We don\u0027t check for Null condition as the Store API should return\n+      // an empty list if there are not listing.\n \n       // For any -RenamePending.json files in the listing,\n       // push the rename forward.\n       boolean renamed \u003d conditionalRedoFolderRenames(listing);\n \n       // If any renames were redone, get another listing,\n       // since the current one may have changed due to the redo.\n       if (renamed) {\n-        listing \u003d store.list(key, AZURE_LIST_ALL, 1, partialKey);\n+       listing \u003d null;\n+       try {\n+         listing \u003d store.list(key, AZURE_LIST_ALL, 1, partialKey);\n+       } catch (IOException ex) {\n+         Throwable innerException \u003d NativeAzureFileSystem.checkForAzureStorageException(ex);\n+\n+         if (innerException instanceof StorageException\n+             \u0026\u0026 NativeAzureFileSystem.isFileNotFoundException((StorageException) innerException)) {\n+\n+           throw new FileNotFoundException(String.format(\"%s is not found\", key));\n+         }\n+\n+         throw ex;\n+       }\n       }\n \n+      // NOTE: We don\u0027t check for Null condition as the Store API should return\n+      // and empty list if there are not listing.\n+\n       for (FileMetadata fileMetadata : listing.getFiles()) {\n         Path subpath \u003d keyToPath(fileMetadata.getKey());\n \n         // Test whether the metadata represents a file or directory and\n         // add the appropriate metadata object.\n         //\n         // Note: There was a very old bug here where directories were added\n         // to the status set as files flattening out recursive listings\n         // using \"-lsr\" down the file system hierarchy.\n         if (fileMetadata.isDir()) {\n           // Make sure we hide the temp upload folder\n           if (fileMetadata.getKey().equals(AZURE_TEMP_FOLDER)) {\n             // Don\u0027t expose that.\n             continue;\n           }\n           status.add(newDirectory(fileMetadata, subpath));\n         } else {\n           status.add(newFile(fileMetadata, subpath));\n         }\n       }\n \n       LOG.debug(\"Found path as a directory with {}\"\n           + \" files in it.\", status.size());\n \n     } else {\n       // There is no metadata found for the path.\n       LOG.debug(\"Did not find any metadata for path: {}\", key);\n \n       throw new FileNotFoundException(\"File\" + f + \" does not exist.\");\n     }\n \n     return status.toArray(new FileStatus[0]);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public FileStatus[] listStatus(Path f) throws FileNotFoundException, IOException {\n\n    LOG.debug(\"Listing status for {}\", f.toString());\n\n    Path absolutePath \u003d makeAbsolute(f);\n    String key \u003d pathToKey(absolutePath);\n    Set\u003cFileStatus\u003e status \u003d new TreeSet\u003cFileStatus\u003e();\n    FileMetadata meta \u003d null;\n    try {\n      meta \u003d store.retrieveMetadata(key);\n    } catch (IOException ex) {\n\n      Throwable innerException \u003d NativeAzureFileSystem.checkForAzureStorageException(ex);\n\n      if (innerException instanceof StorageException\n          \u0026\u0026 NativeAzureFileSystem.isFileNotFoundException((StorageException) innerException)) {\n\n        throw new FileNotFoundException(String.format(\"%s is not found\", f));\n      }\n\n      throw ex;\n    }\n\n    if (meta !\u003d null) {\n      if (!meta.isDir()) {\n\n        LOG.debug(\"Found path as a file\");\n\n        return new FileStatus[] { newFile(meta, absolutePath) };\n      }\n\n      String partialKey \u003d null;\n      PartialListing listing \u003d null;\n\n      try {\n        listing  \u003d store.list(key, AZURE_LIST_ALL, 1, partialKey);\n      } catch (IOException ex) {\n\n        Throwable innerException \u003d NativeAzureFileSystem.checkForAzureStorageException(ex);\n\n        if (innerException instanceof StorageException\n            \u0026\u0026 NativeAzureFileSystem.isFileNotFoundException((StorageException) innerException)) {\n\n            throw new FileNotFoundException(String.format(\"%s is not found\", key));\n        }\n\n        throw ex;\n      }\n      // NOTE: We don\u0027t check for Null condition as the Store API should return\n      // an empty list if there are not listing.\n\n      // For any -RenamePending.json files in the listing,\n      // push the rename forward.\n      boolean renamed \u003d conditionalRedoFolderRenames(listing);\n\n      // If any renames were redone, get another listing,\n      // since the current one may have changed due to the redo.\n      if (renamed) {\n       listing \u003d null;\n       try {\n         listing \u003d store.list(key, AZURE_LIST_ALL, 1, partialKey);\n       } catch (IOException ex) {\n         Throwable innerException \u003d NativeAzureFileSystem.checkForAzureStorageException(ex);\n\n         if (innerException instanceof StorageException\n             \u0026\u0026 NativeAzureFileSystem.isFileNotFoundException((StorageException) innerException)) {\n\n           throw new FileNotFoundException(String.format(\"%s is not found\", key));\n         }\n\n         throw ex;\n       }\n      }\n\n      // NOTE: We don\u0027t check for Null condition as the Store API should return\n      // and empty list if there are not listing.\n\n      for (FileMetadata fileMetadata : listing.getFiles()) {\n        Path subpath \u003d keyToPath(fileMetadata.getKey());\n\n        // Test whether the metadata represents a file or directory and\n        // add the appropriate metadata object.\n        //\n        // Note: There was a very old bug here where directories were added\n        // to the status set as files flattening out recursive listings\n        // using \"-lsr\" down the file system hierarchy.\n        if (fileMetadata.isDir()) {\n          // Make sure we hide the temp upload folder\n          if (fileMetadata.getKey().equals(AZURE_TEMP_FOLDER)) {\n            // Don\u0027t expose that.\n            continue;\n          }\n          status.add(newDirectory(fileMetadata, subpath));\n        } else {\n          status.add(newFile(fileMetadata, subpath));\n        }\n      }\n\n      LOG.debug(\"Found path as a directory with {}\"\n          + \" files in it.\", status.size());\n\n    } else {\n      // There is no metadata found for the path.\n      LOG.debug(\"Did not find any metadata for path: {}\", key);\n\n      throw new FileNotFoundException(\"File\" + f + \" does not exist.\");\n    }\n\n    return status.toArray(new FileStatus[0]);\n  }",
          "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
          "extendedDetails": {}
        }
      ]
    },
    "5f6edb30c2bb648d5564c951edc25645e17e6636": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-12350. WASB Logging: Improve WASB Logging around deletes, reads and writes. Contributed by Dushyanth.\n",
      "commitDate": "05/10/15 8:11 PM",
      "commitName": "5f6edb30c2bb648d5564c951edc25645e17e6636",
      "commitAuthor": "cnauroth",
      "commitDateOld": "28/09/15 3:31 PM",
      "commitNameOld": "3abbdc929bde05f8819f5410cef1eaeb8940203f",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 7.19,
      "commitsBetweenForRepo": 44,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,66 +1,62 @@\n   public FileStatus[] listStatus(Path f) throws IOException {\n \n-    if (LOG.isDebugEnabled()) {\n-      LOG.debug(\"Listing status for \" + f.toString());\n-    }\n+    LOG.debug(\"Listing status for {}\", f.toString());\n \n     Path absolutePath \u003d makeAbsolute(f);\n     String key \u003d pathToKey(absolutePath);\n     Set\u003cFileStatus\u003e status \u003d new TreeSet\u003cFileStatus\u003e();\n     FileMetadata meta \u003d store.retrieveMetadata(key);\n \n     if (meta !\u003d null) {\n       if (!meta.isDir()) {\n-        if (LOG.isDebugEnabled()) {\n-          LOG.debug(\"Found path as a file\");\n-        }\n+\n+        LOG.debug(\"Found path as a file\");\n+\n         return new FileStatus[] { newFile(meta, absolutePath) };\n       }\n       String partialKey \u003d null;\n       PartialListing listing \u003d store.list(key, AZURE_LIST_ALL, 1, partialKey);\n \n       // For any -RenamePending.json files in the listing,\n       // push the rename forward.\n       boolean renamed \u003d conditionalRedoFolderRenames(listing);\n \n       // If any renames were redone, get another listing,\n       // since the current one may have changed due to the redo.\n       if (renamed) {\n         listing \u003d store.list(key, AZURE_LIST_ALL, 1, partialKey);\n       }\n \n       for (FileMetadata fileMetadata : listing.getFiles()) {\n         Path subpath \u003d keyToPath(fileMetadata.getKey());\n \n         // Test whether the metadata represents a file or directory and\n         // add the appropriate metadata object.\n         //\n         // Note: There was a very old bug here where directories were added\n         // to the status set as files flattening out recursive listings\n         // using \"-lsr\" down the file system hierarchy.\n         if (fileMetadata.isDir()) {\n           // Make sure we hide the temp upload folder\n           if (fileMetadata.getKey().equals(AZURE_TEMP_FOLDER)) {\n             // Don\u0027t expose that.\n             continue;\n           }\n           status.add(newDirectory(fileMetadata, subpath));\n         } else {\n           status.add(newFile(fileMetadata, subpath));\n         }\n       }\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"Found path as a directory with \" + status.size()\n-            + \" files in it.\");\n-      }\n+\n+      LOG.debug(\"Found path as a directory with {}\"\n+          + \" files in it.\", status.size());\n+\n     } else {\n       // There is no metadata found for the path.\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"Did not find any metadata for path: \" + key);\n-      }\n+      LOG.debug(\"Did not find any metadata for path: {}\", key);\n \n       throw new FileNotFoundException(\"File\" + f + \" does not exist.\");\n     }\n \n     return status.toArray(new FileStatus[0]);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FileStatus[] listStatus(Path f) throws IOException {\n\n    LOG.debug(\"Listing status for {}\", f.toString());\n\n    Path absolutePath \u003d makeAbsolute(f);\n    String key \u003d pathToKey(absolutePath);\n    Set\u003cFileStatus\u003e status \u003d new TreeSet\u003cFileStatus\u003e();\n    FileMetadata meta \u003d store.retrieveMetadata(key);\n\n    if (meta !\u003d null) {\n      if (!meta.isDir()) {\n\n        LOG.debug(\"Found path as a file\");\n\n        return new FileStatus[] { newFile(meta, absolutePath) };\n      }\n      String partialKey \u003d null;\n      PartialListing listing \u003d store.list(key, AZURE_LIST_ALL, 1, partialKey);\n\n      // For any -RenamePending.json files in the listing,\n      // push the rename forward.\n      boolean renamed \u003d conditionalRedoFolderRenames(listing);\n\n      // If any renames were redone, get another listing,\n      // since the current one may have changed due to the redo.\n      if (renamed) {\n        listing \u003d store.list(key, AZURE_LIST_ALL, 1, partialKey);\n      }\n\n      for (FileMetadata fileMetadata : listing.getFiles()) {\n        Path subpath \u003d keyToPath(fileMetadata.getKey());\n\n        // Test whether the metadata represents a file or directory and\n        // add the appropriate metadata object.\n        //\n        // Note: There was a very old bug here where directories were added\n        // to the status set as files flattening out recursive listings\n        // using \"-lsr\" down the file system hierarchy.\n        if (fileMetadata.isDir()) {\n          // Make sure we hide the temp upload folder\n          if (fileMetadata.getKey().equals(AZURE_TEMP_FOLDER)) {\n            // Don\u0027t expose that.\n            continue;\n          }\n          status.add(newDirectory(fileMetadata, subpath));\n        } else {\n          status.add(newFile(fileMetadata, subpath));\n        }\n      }\n\n      LOG.debug(\"Found path as a directory with {}\"\n          + \" files in it.\", status.size());\n\n    } else {\n      // There is no metadata found for the path.\n      LOG.debug(\"Did not find any metadata for path: {}\", key);\n\n      throw new FileNotFoundException(\"File\" + f + \" does not exist.\");\n    }\n\n    return status.toArray(new FileStatus[0]);\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
      "extendedDetails": {}
    },
    "2217e2f8ff418b88eac6ad36cafe3a9795a11f40": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10809. hadoop-azure: page blob support. Contributed by Dexter Bradshaw, Mostafa Elhemali, Eric Hanson, and Mike Liddell.\n",
      "commitDate": "08/10/14 2:20 PM",
      "commitName": "2217e2f8ff418b88eac6ad36cafe3a9795a11f40",
      "commitAuthor": "cnauroth",
      "commitDateOld": "19/09/14 11:33 AM",
      "commitNameOld": "9f03a7c018bb2c497cd0ef758f1a3e08e8163d06",
      "commitAuthorOld": "Allen Wittenauer",
      "daysBetweenCommits": 19.12,
      "commitsBetweenForRepo": 199,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,55 +1,66 @@\n   public FileStatus[] listStatus(Path f) throws IOException {\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Listing status for \" + f.toString());\n     }\n \n     Path absolutePath \u003d makeAbsolute(f);\n     String key \u003d pathToKey(absolutePath);\n     Set\u003cFileStatus\u003e status \u003d new TreeSet\u003cFileStatus\u003e();\n     FileMetadata meta \u003d store.retrieveMetadata(key);\n \n     if (meta !\u003d null) {\n       if (!meta.isDir()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Found path as a file\");\n         }\n         return new FileStatus[] { newFile(meta, absolutePath) };\n       }\n       String partialKey \u003d null;\n       PartialListing listing \u003d store.list(key, AZURE_LIST_ALL, 1, partialKey);\n+\n+      // For any -RenamePending.json files in the listing,\n+      // push the rename forward.\n+      boolean renamed \u003d conditionalRedoFolderRenames(listing);\n+\n+      // If any renames were redone, get another listing,\n+      // since the current one may have changed due to the redo.\n+      if (renamed) {\n+        listing \u003d store.list(key, AZURE_LIST_ALL, 1, partialKey);\n+      }\n+\n       for (FileMetadata fileMetadata : listing.getFiles()) {\n         Path subpath \u003d keyToPath(fileMetadata.getKey());\n \n         // Test whether the metadata represents a file or directory and\n         // add the appropriate metadata object.\n         //\n         // Note: There was a very old bug here where directories were added\n         // to the status set as files flattening out recursive listings\n         // using \"-lsr\" down the file system hierarchy.\n         if (fileMetadata.isDir()) {\n           // Make sure we hide the temp upload folder\n           if (fileMetadata.getKey().equals(AZURE_TEMP_FOLDER)) {\n             // Don\u0027t expose that.\n             continue;\n           }\n           status.add(newDirectory(fileMetadata, subpath));\n         } else {\n           status.add(newFile(fileMetadata, subpath));\n         }\n       }\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Found path as a directory with \" + status.size()\n             + \" files in it.\");\n       }\n     } else {\n       // There is no metadata found for the path.\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Did not find any metadata for path: \" + key);\n       }\n \n       throw new FileNotFoundException(\"File\" + f + \" does not exist.\");\n     }\n \n     return status.toArray(new FileStatus[0]);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FileStatus[] listStatus(Path f) throws IOException {\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Listing status for \" + f.toString());\n    }\n\n    Path absolutePath \u003d makeAbsolute(f);\n    String key \u003d pathToKey(absolutePath);\n    Set\u003cFileStatus\u003e status \u003d new TreeSet\u003cFileStatus\u003e();\n    FileMetadata meta \u003d store.retrieveMetadata(key);\n\n    if (meta !\u003d null) {\n      if (!meta.isDir()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Found path as a file\");\n        }\n        return new FileStatus[] { newFile(meta, absolutePath) };\n      }\n      String partialKey \u003d null;\n      PartialListing listing \u003d store.list(key, AZURE_LIST_ALL, 1, partialKey);\n\n      // For any -RenamePending.json files in the listing,\n      // push the rename forward.\n      boolean renamed \u003d conditionalRedoFolderRenames(listing);\n\n      // If any renames were redone, get another listing,\n      // since the current one may have changed due to the redo.\n      if (renamed) {\n        listing \u003d store.list(key, AZURE_LIST_ALL, 1, partialKey);\n      }\n\n      for (FileMetadata fileMetadata : listing.getFiles()) {\n        Path subpath \u003d keyToPath(fileMetadata.getKey());\n\n        // Test whether the metadata represents a file or directory and\n        // add the appropriate metadata object.\n        //\n        // Note: There was a very old bug here where directories were added\n        // to the status set as files flattening out recursive listings\n        // using \"-lsr\" down the file system hierarchy.\n        if (fileMetadata.isDir()) {\n          // Make sure we hide the temp upload folder\n          if (fileMetadata.getKey().equals(AZURE_TEMP_FOLDER)) {\n            // Don\u0027t expose that.\n            continue;\n          }\n          status.add(newDirectory(fileMetadata, subpath));\n        } else {\n          status.add(newFile(fileMetadata, subpath));\n        }\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Found path as a directory with \" + status.size()\n            + \" files in it.\");\n      }\n    } else {\n      // There is no metadata found for the path.\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Did not find any metadata for path: \" + key);\n      }\n\n      throw new FileNotFoundException(\"File\" + f + \" does not exist.\");\n    }\n\n    return status.toArray(new FileStatus[0]);\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
      "extendedDetails": {}
    },
    "81bc395deb3ba00567dc067d6ca71bacf9e3bc82": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-9629. Support Windows Azure Storage - Blob as a file system in Hadoop. Contributed by Dexter Bradshaw, Mostafa Elhemali, Xi Fang, Johannes Klein, David Lao, Mike Liddell, Chuan Liu, Lengning Liu, Ivan Mitic, Michael Rys, Alexander Stojanovic, Brian Swan, and Min Wei.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1601781 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/06/14 3:26 PM",
      "commitName": "81bc395deb3ba00567dc067d6ca71bacf9e3bc82",
      "commitAuthor": "Chris Nauroth",
      "diff": "@@ -0,0 +1,55 @@\n+  public FileStatus[] listStatus(Path f) throws IOException {\n+\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(\"Listing status for \" + f.toString());\n+    }\n+\n+    Path absolutePath \u003d makeAbsolute(f);\n+    String key \u003d pathToKey(absolutePath);\n+    Set\u003cFileStatus\u003e status \u003d new TreeSet\u003cFileStatus\u003e();\n+    FileMetadata meta \u003d store.retrieveMetadata(key);\n+\n+    if (meta !\u003d null) {\n+      if (!meta.isDir()) {\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"Found path as a file\");\n+        }\n+        return new FileStatus[] { newFile(meta, absolutePath) };\n+      }\n+      String partialKey \u003d null;\n+      PartialListing listing \u003d store.list(key, AZURE_LIST_ALL, 1, partialKey);\n+      for (FileMetadata fileMetadata : listing.getFiles()) {\n+        Path subpath \u003d keyToPath(fileMetadata.getKey());\n+\n+        // Test whether the metadata represents a file or directory and\n+        // add the appropriate metadata object.\n+        //\n+        // Note: There was a very old bug here where directories were added\n+        // to the status set as files flattening out recursive listings\n+        // using \"-lsr\" down the file system hierarchy.\n+        if (fileMetadata.isDir()) {\n+          // Make sure we hide the temp upload folder\n+          if (fileMetadata.getKey().equals(AZURE_TEMP_FOLDER)) {\n+            // Don\u0027t expose that.\n+            continue;\n+          }\n+          status.add(newDirectory(fileMetadata, subpath));\n+        } else {\n+          status.add(newFile(fileMetadata, subpath));\n+        }\n+      }\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Found path as a directory with \" + status.size()\n+            + \" files in it.\");\n+      }\n+    } else {\n+      // There is no metadata found for the path.\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Did not find any metadata for path: \" + key);\n+      }\n+\n+      throw new FileNotFoundException(\"File\" + f + \" does not exist.\");\n+    }\n+\n+    return status.toArray(new FileStatus[0]);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public FileStatus[] listStatus(Path f) throws IOException {\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Listing status for \" + f.toString());\n    }\n\n    Path absolutePath \u003d makeAbsolute(f);\n    String key \u003d pathToKey(absolutePath);\n    Set\u003cFileStatus\u003e status \u003d new TreeSet\u003cFileStatus\u003e();\n    FileMetadata meta \u003d store.retrieveMetadata(key);\n\n    if (meta !\u003d null) {\n      if (!meta.isDir()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Found path as a file\");\n        }\n        return new FileStatus[] { newFile(meta, absolutePath) };\n      }\n      String partialKey \u003d null;\n      PartialListing listing \u003d store.list(key, AZURE_LIST_ALL, 1, partialKey);\n      for (FileMetadata fileMetadata : listing.getFiles()) {\n        Path subpath \u003d keyToPath(fileMetadata.getKey());\n\n        // Test whether the metadata represents a file or directory and\n        // add the appropriate metadata object.\n        //\n        // Note: There was a very old bug here where directories were added\n        // to the status set as files flattening out recursive listings\n        // using \"-lsr\" down the file system hierarchy.\n        if (fileMetadata.isDir()) {\n          // Make sure we hide the temp upload folder\n          if (fileMetadata.getKey().equals(AZURE_TEMP_FOLDER)) {\n            // Don\u0027t expose that.\n            continue;\n          }\n          status.add(newDirectory(fileMetadata, subpath));\n        } else {\n          status.add(newFile(fileMetadata, subpath));\n        }\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Found path as a directory with \" + status.size()\n            + \" files in it.\");\n      }\n    } else {\n      // There is no metadata found for the path.\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Did not find any metadata for path: \" + key);\n      }\n\n      throw new FileNotFoundException(\"File\" + f + \" does not exist.\");\n    }\n\n    return status.toArray(new FileStatus[0]);\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java"
    }
  }
}