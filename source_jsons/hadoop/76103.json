{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "CBZip2OutputStream.java",
  "functionName": "hbMakeCodeLengths",
  "functionId": "hbMakeCodeLengths___len-char[]__freq-int[]__alphaSize-int__maxLen-int",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/compress/bzip2/CBZip2OutputStream.java",
  "functionStartLine": 217,
  "functionEndLine": 365,
  "numCommitsSeen": 7,
  "timeTaken": 1081,
  "changeHistory": [
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
    "5128a9a453d64bfe1ed978cf9ffed27985eeef36"
  ],
  "changeHistoryShort": {
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52": "Yfilerename",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yfilerename",
    "5128a9a453d64bfe1ed978cf9ffed27985eeef36": "Yintroduced"
  },
  "changeHistoryDetails": {
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  protected static void hbMakeCodeLengths(char[] len, int[] freq,\n      int alphaSize, int maxLen) {\n    /*\n    * Nodes and heap entries run from 1. Entry 0 for both the heap and\n    * nodes is a sentinel.\n    */\n    final int[] heap \u003d new int[MAX_ALPHA_SIZE * 2];\n    final int[] weight \u003d new int[MAX_ALPHA_SIZE * 2];\n    final int[] parent \u003d new int[MAX_ALPHA_SIZE * 2];\n\n    for (int i \u003d alphaSize; --i \u003e\u003d 0;) {\n      weight[i + 1] \u003d (freq[i] \u003d\u003d 0 ? 1 : freq[i]) \u003c\u003c 8;\n    }\n\n    for (boolean tooLong \u003d true; tooLong;) {\n      tooLong \u003d false;\n\n      int nNodes \u003d alphaSize;\n      int nHeap \u003d 0;\n      heap[0] \u003d 0;\n      weight[0] \u003d 0;\n      parent[0] \u003d -2;\n\n      for (int i \u003d 1; i \u003c\u003d alphaSize; i++) {\n        parent[i] \u003d -1;\n        nHeap++;\n        heap[nHeap] \u003d i;\n\n        int zz \u003d nHeap;\n        int tmp \u003d heap[zz];\n        while (weight[tmp] \u003c weight[heap[zz \u003e\u003e 1]]) {\n          heap[zz] \u003d heap[zz \u003e\u003e 1];\n          zz \u003e\u003e\u003d 1;\n        }\n        heap[zz] \u003d tmp;\n      }\n\n      // assert (nHeap \u003c (MAX_ALPHA_SIZE + 2)) : nHeap;\n\n      while (nHeap \u003e 1) {\n        int n1 \u003d heap[1];\n        heap[1] \u003d heap[nHeap];\n        nHeap--;\n\n        int yy \u003d 0;\n        int zz \u003d 1;\n        int tmp \u003d heap[1];\n\n        while (true) {\n          yy \u003d zz \u003c\u003c 1;\n\n          if (yy \u003e nHeap) {\n            break;\n          }\n\n          if ((yy \u003c nHeap)\n              \u0026\u0026 (weight[heap[yy + 1]] \u003c weight[heap[yy]])) {\n            yy++;\n          }\n\n          if (weight[tmp] \u003c weight[heap[yy]]) {\n            break;\n          }\n\n          heap[zz] \u003d heap[yy];\n          zz \u003d yy;\n        }\n\n        heap[zz] \u003d tmp;\n\n        int n2 \u003d heap[1];\n        heap[1] \u003d heap[nHeap];\n        nHeap--;\n\n        yy \u003d 0;\n        zz \u003d 1;\n        tmp \u003d heap[1];\n\n        while (true) {\n          yy \u003d zz \u003c\u003c 1;\n\n          if (yy \u003e nHeap) {\n            break;\n          }\n\n          if ((yy \u003c nHeap)\n              \u0026\u0026 (weight[heap[yy + 1]] \u003c weight[heap[yy]])) {\n            yy++;\n          }\n\n          if (weight[tmp] \u003c weight[heap[yy]]) {\n            break;\n          }\n\n          heap[zz] \u003d heap[yy];\n          zz \u003d yy;\n        }\n\n        heap[zz] \u003d tmp;\n        nNodes++;\n        parent[n1] \u003d parent[n2] \u003d nNodes;\n\n        final int weight_n1 \u003d weight[n1];\n        final int weight_n2 \u003d weight[n2];\n        weight[nNodes] \u003d (((weight_n1 \u0026 0xffffff00) + (weight_n2 \u0026 0xffffff00)) | (1 + (((weight_n1 \u0026 0x000000ff) \u003e (weight_n2 \u0026 0x000000ff)) ? (weight_n1 \u0026 0x000000ff)\n            : (weight_n2 \u0026 0x000000ff))));\n\n        parent[nNodes] \u003d -1;\n        nHeap++;\n        heap[nHeap] \u003d nNodes;\n\n        tmp \u003d 0;\n        zz \u003d nHeap;\n        tmp \u003d heap[zz];\n        final int weight_tmp \u003d weight[tmp];\n        while (weight_tmp \u003c weight[heap[zz \u003e\u003e 1]]) {\n          heap[zz] \u003d heap[zz \u003e\u003e 1];\n          zz \u003e\u003e\u003d 1;\n        }\n        heap[zz] \u003d tmp;\n\n      }\n\n      // assert (nNodes \u003c (MAX_ALPHA_SIZE * 2)) : nNodes;\n\n      for (int i \u003d 1; i \u003c\u003d alphaSize; i++) {\n        int j \u003d 0;\n        int k \u003d i;\n\n        for (int parent_k; (parent_k \u003d parent[k]) \u003e\u003d 0;) {\n          k \u003d parent_k;\n          j++;\n        }\n\n        len[i - 1] \u003d (char) j;\n        if (j \u003e maxLen) {\n          tooLong \u003d true;\n        }\n      }\n\n      if (tooLong) {\n        for (int i \u003d 1; i \u003c alphaSize; i++) {\n          int j \u003d weight[i] \u003e\u003e 8;\n          j \u003d 1 + (j \u003e\u003e 1);\n          weight[i] \u003d j \u003c\u003c 8;\n        }\n      }\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/compress/bzip2/CBZip2OutputStream.java",
      "extendedDetails": {
        "oldPath": "hadoop-common/src/main/java/org/apache/hadoop/io/compress/bzip2/CBZip2OutputStream.java",
        "newPath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/compress/bzip2/CBZip2OutputStream.java"
      }
    },
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-6671. Use maven for hadoop common builds. Contributed by Alejandro Abdelnur.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1153184 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/08/11 9:37 AM",
      "commitName": "0f6dfeeacbab65a31a33927a4eb84871d371fe52",
      "commitAuthor": "Thomas White",
      "commitDateOld": "01/08/11 3:53 PM",
      "commitNameOld": "9bac807cedbcff34e1a144fb475eff267e5ed86d",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.74,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  protected static void hbMakeCodeLengths(char[] len, int[] freq,\n      int alphaSize, int maxLen) {\n    /*\n    * Nodes and heap entries run from 1. Entry 0 for both the heap and\n    * nodes is a sentinel.\n    */\n    final int[] heap \u003d new int[MAX_ALPHA_SIZE * 2];\n    final int[] weight \u003d new int[MAX_ALPHA_SIZE * 2];\n    final int[] parent \u003d new int[MAX_ALPHA_SIZE * 2];\n\n    for (int i \u003d alphaSize; --i \u003e\u003d 0;) {\n      weight[i + 1] \u003d (freq[i] \u003d\u003d 0 ? 1 : freq[i]) \u003c\u003c 8;\n    }\n\n    for (boolean tooLong \u003d true; tooLong;) {\n      tooLong \u003d false;\n\n      int nNodes \u003d alphaSize;\n      int nHeap \u003d 0;\n      heap[0] \u003d 0;\n      weight[0] \u003d 0;\n      parent[0] \u003d -2;\n\n      for (int i \u003d 1; i \u003c\u003d alphaSize; i++) {\n        parent[i] \u003d -1;\n        nHeap++;\n        heap[nHeap] \u003d i;\n\n        int zz \u003d nHeap;\n        int tmp \u003d heap[zz];\n        while (weight[tmp] \u003c weight[heap[zz \u003e\u003e 1]]) {\n          heap[zz] \u003d heap[zz \u003e\u003e 1];\n          zz \u003e\u003e\u003d 1;\n        }\n        heap[zz] \u003d tmp;\n      }\n\n      // assert (nHeap \u003c (MAX_ALPHA_SIZE + 2)) : nHeap;\n\n      while (nHeap \u003e 1) {\n        int n1 \u003d heap[1];\n        heap[1] \u003d heap[nHeap];\n        nHeap--;\n\n        int yy \u003d 0;\n        int zz \u003d 1;\n        int tmp \u003d heap[1];\n\n        while (true) {\n          yy \u003d zz \u003c\u003c 1;\n\n          if (yy \u003e nHeap) {\n            break;\n          }\n\n          if ((yy \u003c nHeap)\n              \u0026\u0026 (weight[heap[yy + 1]] \u003c weight[heap[yy]])) {\n            yy++;\n          }\n\n          if (weight[tmp] \u003c weight[heap[yy]]) {\n            break;\n          }\n\n          heap[zz] \u003d heap[yy];\n          zz \u003d yy;\n        }\n\n        heap[zz] \u003d tmp;\n\n        int n2 \u003d heap[1];\n        heap[1] \u003d heap[nHeap];\n        nHeap--;\n\n        yy \u003d 0;\n        zz \u003d 1;\n        tmp \u003d heap[1];\n\n        while (true) {\n          yy \u003d zz \u003c\u003c 1;\n\n          if (yy \u003e nHeap) {\n            break;\n          }\n\n          if ((yy \u003c nHeap)\n              \u0026\u0026 (weight[heap[yy + 1]] \u003c weight[heap[yy]])) {\n            yy++;\n          }\n\n          if (weight[tmp] \u003c weight[heap[yy]]) {\n            break;\n          }\n\n          heap[zz] \u003d heap[yy];\n          zz \u003d yy;\n        }\n\n        heap[zz] \u003d tmp;\n        nNodes++;\n        parent[n1] \u003d parent[n2] \u003d nNodes;\n\n        final int weight_n1 \u003d weight[n1];\n        final int weight_n2 \u003d weight[n2];\n        weight[nNodes] \u003d (((weight_n1 \u0026 0xffffff00) + (weight_n2 \u0026 0xffffff00)) | (1 + (((weight_n1 \u0026 0x000000ff) \u003e (weight_n2 \u0026 0x000000ff)) ? (weight_n1 \u0026 0x000000ff)\n            : (weight_n2 \u0026 0x000000ff))));\n\n        parent[nNodes] \u003d -1;\n        nHeap++;\n        heap[nHeap] \u003d nNodes;\n\n        tmp \u003d 0;\n        zz \u003d nHeap;\n        tmp \u003d heap[zz];\n        final int weight_tmp \u003d weight[tmp];\n        while (weight_tmp \u003c weight[heap[zz \u003e\u003e 1]]) {\n          heap[zz] \u003d heap[zz \u003e\u003e 1];\n          zz \u003e\u003e\u003d 1;\n        }\n        heap[zz] \u003d tmp;\n\n      }\n\n      // assert (nNodes \u003c (MAX_ALPHA_SIZE * 2)) : nNodes;\n\n      for (int i \u003d 1; i \u003c\u003d alphaSize; i++) {\n        int j \u003d 0;\n        int k \u003d i;\n\n        for (int parent_k; (parent_k \u003d parent[k]) \u003e\u003d 0;) {\n          k \u003d parent_k;\n          j++;\n        }\n\n        len[i - 1] \u003d (char) j;\n        if (j \u003e maxLen) {\n          tooLong \u003d true;\n        }\n      }\n\n      if (tooLong) {\n        for (int i \u003d 1; i \u003c alphaSize; i++) {\n          int j \u003d weight[i] \u003e\u003e 8;\n          j \u003d 1 + (j \u003e\u003e 1);\n          weight[i] \u003d j \u003c\u003c 8;\n        }\n      }\n    }\n  }",
      "path": "hadoop-common/src/main/java/org/apache/hadoop/io/compress/bzip2/CBZip2OutputStream.java",
      "extendedDetails": {
        "oldPath": "common/src/java/org/apache/hadoop/io/compress/bzip2/CBZip2OutputStream.java",
        "newPath": "hadoop-common/src/main/java/org/apache/hadoop/io/compress/bzip2/CBZip2OutputStream.java"
      }
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "11/06/11 9:13 PM",
      "commitNameOld": "a285fb5effe9ba3be4ec5f942afaf5ddd1186151",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 0.74,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  protected static void hbMakeCodeLengths(char[] len, int[] freq,\n      int alphaSize, int maxLen) {\n    /*\n    * Nodes and heap entries run from 1. Entry 0 for both the heap and\n    * nodes is a sentinel.\n    */\n    final int[] heap \u003d new int[MAX_ALPHA_SIZE * 2];\n    final int[] weight \u003d new int[MAX_ALPHA_SIZE * 2];\n    final int[] parent \u003d new int[MAX_ALPHA_SIZE * 2];\n\n    for (int i \u003d alphaSize; --i \u003e\u003d 0;) {\n      weight[i + 1] \u003d (freq[i] \u003d\u003d 0 ? 1 : freq[i]) \u003c\u003c 8;\n    }\n\n    for (boolean tooLong \u003d true; tooLong;) {\n      tooLong \u003d false;\n\n      int nNodes \u003d alphaSize;\n      int nHeap \u003d 0;\n      heap[0] \u003d 0;\n      weight[0] \u003d 0;\n      parent[0] \u003d -2;\n\n      for (int i \u003d 1; i \u003c\u003d alphaSize; i++) {\n        parent[i] \u003d -1;\n        nHeap++;\n        heap[nHeap] \u003d i;\n\n        int zz \u003d nHeap;\n        int tmp \u003d heap[zz];\n        while (weight[tmp] \u003c weight[heap[zz \u003e\u003e 1]]) {\n          heap[zz] \u003d heap[zz \u003e\u003e 1];\n          zz \u003e\u003e\u003d 1;\n        }\n        heap[zz] \u003d tmp;\n      }\n\n      // assert (nHeap \u003c (MAX_ALPHA_SIZE + 2)) : nHeap;\n\n      while (nHeap \u003e 1) {\n        int n1 \u003d heap[1];\n        heap[1] \u003d heap[nHeap];\n        nHeap--;\n\n        int yy \u003d 0;\n        int zz \u003d 1;\n        int tmp \u003d heap[1];\n\n        while (true) {\n          yy \u003d zz \u003c\u003c 1;\n\n          if (yy \u003e nHeap) {\n            break;\n          }\n\n          if ((yy \u003c nHeap)\n              \u0026\u0026 (weight[heap[yy + 1]] \u003c weight[heap[yy]])) {\n            yy++;\n          }\n\n          if (weight[tmp] \u003c weight[heap[yy]]) {\n            break;\n          }\n\n          heap[zz] \u003d heap[yy];\n          zz \u003d yy;\n        }\n\n        heap[zz] \u003d tmp;\n\n        int n2 \u003d heap[1];\n        heap[1] \u003d heap[nHeap];\n        nHeap--;\n\n        yy \u003d 0;\n        zz \u003d 1;\n        tmp \u003d heap[1];\n\n        while (true) {\n          yy \u003d zz \u003c\u003c 1;\n\n          if (yy \u003e nHeap) {\n            break;\n          }\n\n          if ((yy \u003c nHeap)\n              \u0026\u0026 (weight[heap[yy + 1]] \u003c weight[heap[yy]])) {\n            yy++;\n          }\n\n          if (weight[tmp] \u003c weight[heap[yy]]) {\n            break;\n          }\n\n          heap[zz] \u003d heap[yy];\n          zz \u003d yy;\n        }\n\n        heap[zz] \u003d tmp;\n        nNodes++;\n        parent[n1] \u003d parent[n2] \u003d nNodes;\n\n        final int weight_n1 \u003d weight[n1];\n        final int weight_n2 \u003d weight[n2];\n        weight[nNodes] \u003d (((weight_n1 \u0026 0xffffff00) + (weight_n2 \u0026 0xffffff00)) | (1 + (((weight_n1 \u0026 0x000000ff) \u003e (weight_n2 \u0026 0x000000ff)) ? (weight_n1 \u0026 0x000000ff)\n            : (weight_n2 \u0026 0x000000ff))));\n\n        parent[nNodes] \u003d -1;\n        nHeap++;\n        heap[nHeap] \u003d nNodes;\n\n        tmp \u003d 0;\n        zz \u003d nHeap;\n        tmp \u003d heap[zz];\n        final int weight_tmp \u003d weight[tmp];\n        while (weight_tmp \u003c weight[heap[zz \u003e\u003e 1]]) {\n          heap[zz] \u003d heap[zz \u003e\u003e 1];\n          zz \u003e\u003e\u003d 1;\n        }\n        heap[zz] \u003d tmp;\n\n      }\n\n      // assert (nNodes \u003c (MAX_ALPHA_SIZE * 2)) : nNodes;\n\n      for (int i \u003d 1; i \u003c\u003d alphaSize; i++) {\n        int j \u003d 0;\n        int k \u003d i;\n\n        for (int parent_k; (parent_k \u003d parent[k]) \u003e\u003d 0;) {\n          k \u003d parent_k;\n          j++;\n        }\n\n        len[i - 1] \u003d (char) j;\n        if (j \u003e maxLen) {\n          tooLong \u003d true;\n        }\n      }\n\n      if (tooLong) {\n        for (int i \u003d 1; i \u003c alphaSize; i++) {\n          int j \u003d weight[i] \u003e\u003e 8;\n          j \u003d 1 + (j \u003e\u003e 1);\n          weight[i] \u003d j \u003c\u003c 8;\n        }\n      }\n    }\n  }",
      "path": "common/src/java/org/apache/hadoop/io/compress/bzip2/CBZip2OutputStream.java",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/hadoop/io/compress/bzip2/CBZip2OutputStream.java",
        "newPath": "common/src/java/org/apache/hadoop/io/compress/bzip2/CBZip2OutputStream.java"
      }
    },
    "5128a9a453d64bfe1ed978cf9ffed27985eeef36": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-4687 Moving src directories on branch\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/core/branches/HADOOP-4687/core@776174 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/05/09 9:20 PM",
      "commitName": "5128a9a453d64bfe1ed978cf9ffed27985eeef36",
      "commitAuthor": "Owen O\u0027Malley",
      "diff": "@@ -0,0 +1,149 @@\n+  protected static void hbMakeCodeLengths(char[] len, int[] freq,\n+      int alphaSize, int maxLen) {\n+    /*\n+    * Nodes and heap entries run from 1. Entry 0 for both the heap and\n+    * nodes is a sentinel.\n+    */\n+    final int[] heap \u003d new int[MAX_ALPHA_SIZE * 2];\n+    final int[] weight \u003d new int[MAX_ALPHA_SIZE * 2];\n+    final int[] parent \u003d new int[MAX_ALPHA_SIZE * 2];\n+\n+    for (int i \u003d alphaSize; --i \u003e\u003d 0;) {\n+      weight[i + 1] \u003d (freq[i] \u003d\u003d 0 ? 1 : freq[i]) \u003c\u003c 8;\n+    }\n+\n+    for (boolean tooLong \u003d true; tooLong;) {\n+      tooLong \u003d false;\n+\n+      int nNodes \u003d alphaSize;\n+      int nHeap \u003d 0;\n+      heap[0] \u003d 0;\n+      weight[0] \u003d 0;\n+      parent[0] \u003d -2;\n+\n+      for (int i \u003d 1; i \u003c\u003d alphaSize; i++) {\n+        parent[i] \u003d -1;\n+        nHeap++;\n+        heap[nHeap] \u003d i;\n+\n+        int zz \u003d nHeap;\n+        int tmp \u003d heap[zz];\n+        while (weight[tmp] \u003c weight[heap[zz \u003e\u003e 1]]) {\n+          heap[zz] \u003d heap[zz \u003e\u003e 1];\n+          zz \u003e\u003e\u003d 1;\n+        }\n+        heap[zz] \u003d tmp;\n+      }\n+\n+      // assert (nHeap \u003c (MAX_ALPHA_SIZE + 2)) : nHeap;\n+\n+      while (nHeap \u003e 1) {\n+        int n1 \u003d heap[1];\n+        heap[1] \u003d heap[nHeap];\n+        nHeap--;\n+\n+        int yy \u003d 0;\n+        int zz \u003d 1;\n+        int tmp \u003d heap[1];\n+\n+        while (true) {\n+          yy \u003d zz \u003c\u003c 1;\n+\n+          if (yy \u003e nHeap) {\n+            break;\n+          }\n+\n+          if ((yy \u003c nHeap)\n+              \u0026\u0026 (weight[heap[yy + 1]] \u003c weight[heap[yy]])) {\n+            yy++;\n+          }\n+\n+          if (weight[tmp] \u003c weight[heap[yy]]) {\n+            break;\n+          }\n+\n+          heap[zz] \u003d heap[yy];\n+          zz \u003d yy;\n+        }\n+\n+        heap[zz] \u003d tmp;\n+\n+        int n2 \u003d heap[1];\n+        heap[1] \u003d heap[nHeap];\n+        nHeap--;\n+\n+        yy \u003d 0;\n+        zz \u003d 1;\n+        tmp \u003d heap[1];\n+\n+        while (true) {\n+          yy \u003d zz \u003c\u003c 1;\n+\n+          if (yy \u003e nHeap) {\n+            break;\n+          }\n+\n+          if ((yy \u003c nHeap)\n+              \u0026\u0026 (weight[heap[yy + 1]] \u003c weight[heap[yy]])) {\n+            yy++;\n+          }\n+\n+          if (weight[tmp] \u003c weight[heap[yy]]) {\n+            break;\n+          }\n+\n+          heap[zz] \u003d heap[yy];\n+          zz \u003d yy;\n+        }\n+\n+        heap[zz] \u003d tmp;\n+        nNodes++;\n+        parent[n1] \u003d parent[n2] \u003d nNodes;\n+\n+        final int weight_n1 \u003d weight[n1];\n+        final int weight_n2 \u003d weight[n2];\n+        weight[nNodes] \u003d (((weight_n1 \u0026 0xffffff00) + (weight_n2 \u0026 0xffffff00)) | (1 + (((weight_n1 \u0026 0x000000ff) \u003e (weight_n2 \u0026 0x000000ff)) ? (weight_n1 \u0026 0x000000ff)\n+            : (weight_n2 \u0026 0x000000ff))));\n+\n+        parent[nNodes] \u003d -1;\n+        nHeap++;\n+        heap[nHeap] \u003d nNodes;\n+\n+        tmp \u003d 0;\n+        zz \u003d nHeap;\n+        tmp \u003d heap[zz];\n+        final int weight_tmp \u003d weight[tmp];\n+        while (weight_tmp \u003c weight[heap[zz \u003e\u003e 1]]) {\n+          heap[zz] \u003d heap[zz \u003e\u003e 1];\n+          zz \u003e\u003e\u003d 1;\n+        }\n+        heap[zz] \u003d tmp;\n+\n+      }\n+\n+      // assert (nNodes \u003c (MAX_ALPHA_SIZE * 2)) : nNodes;\n+\n+      for (int i \u003d 1; i \u003c\u003d alphaSize; i++) {\n+        int j \u003d 0;\n+        int k \u003d i;\n+\n+        for (int parent_k; (parent_k \u003d parent[k]) \u003e\u003d 0;) {\n+          k \u003d parent_k;\n+          j++;\n+        }\n+\n+        len[i - 1] \u003d (char) j;\n+        if (j \u003e maxLen) {\n+          tooLong \u003d true;\n+        }\n+      }\n+\n+      if (tooLong) {\n+        for (int i \u003d 1; i \u003c alphaSize; i++) {\n+          int j \u003d weight[i] \u003e\u003e 8;\n+          j \u003d 1 + (j \u003e\u003e 1);\n+          weight[i] \u003d j \u003c\u003c 8;\n+        }\n+      }\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  protected static void hbMakeCodeLengths(char[] len, int[] freq,\n      int alphaSize, int maxLen) {\n    /*\n    * Nodes and heap entries run from 1. Entry 0 for both the heap and\n    * nodes is a sentinel.\n    */\n    final int[] heap \u003d new int[MAX_ALPHA_SIZE * 2];\n    final int[] weight \u003d new int[MAX_ALPHA_SIZE * 2];\n    final int[] parent \u003d new int[MAX_ALPHA_SIZE * 2];\n\n    for (int i \u003d alphaSize; --i \u003e\u003d 0;) {\n      weight[i + 1] \u003d (freq[i] \u003d\u003d 0 ? 1 : freq[i]) \u003c\u003c 8;\n    }\n\n    for (boolean tooLong \u003d true; tooLong;) {\n      tooLong \u003d false;\n\n      int nNodes \u003d alphaSize;\n      int nHeap \u003d 0;\n      heap[0] \u003d 0;\n      weight[0] \u003d 0;\n      parent[0] \u003d -2;\n\n      for (int i \u003d 1; i \u003c\u003d alphaSize; i++) {\n        parent[i] \u003d -1;\n        nHeap++;\n        heap[nHeap] \u003d i;\n\n        int zz \u003d nHeap;\n        int tmp \u003d heap[zz];\n        while (weight[tmp] \u003c weight[heap[zz \u003e\u003e 1]]) {\n          heap[zz] \u003d heap[zz \u003e\u003e 1];\n          zz \u003e\u003e\u003d 1;\n        }\n        heap[zz] \u003d tmp;\n      }\n\n      // assert (nHeap \u003c (MAX_ALPHA_SIZE + 2)) : nHeap;\n\n      while (nHeap \u003e 1) {\n        int n1 \u003d heap[1];\n        heap[1] \u003d heap[nHeap];\n        nHeap--;\n\n        int yy \u003d 0;\n        int zz \u003d 1;\n        int tmp \u003d heap[1];\n\n        while (true) {\n          yy \u003d zz \u003c\u003c 1;\n\n          if (yy \u003e nHeap) {\n            break;\n          }\n\n          if ((yy \u003c nHeap)\n              \u0026\u0026 (weight[heap[yy + 1]] \u003c weight[heap[yy]])) {\n            yy++;\n          }\n\n          if (weight[tmp] \u003c weight[heap[yy]]) {\n            break;\n          }\n\n          heap[zz] \u003d heap[yy];\n          zz \u003d yy;\n        }\n\n        heap[zz] \u003d tmp;\n\n        int n2 \u003d heap[1];\n        heap[1] \u003d heap[nHeap];\n        nHeap--;\n\n        yy \u003d 0;\n        zz \u003d 1;\n        tmp \u003d heap[1];\n\n        while (true) {\n          yy \u003d zz \u003c\u003c 1;\n\n          if (yy \u003e nHeap) {\n            break;\n          }\n\n          if ((yy \u003c nHeap)\n              \u0026\u0026 (weight[heap[yy + 1]] \u003c weight[heap[yy]])) {\n            yy++;\n          }\n\n          if (weight[tmp] \u003c weight[heap[yy]]) {\n            break;\n          }\n\n          heap[zz] \u003d heap[yy];\n          zz \u003d yy;\n        }\n\n        heap[zz] \u003d tmp;\n        nNodes++;\n        parent[n1] \u003d parent[n2] \u003d nNodes;\n\n        final int weight_n1 \u003d weight[n1];\n        final int weight_n2 \u003d weight[n2];\n        weight[nNodes] \u003d (((weight_n1 \u0026 0xffffff00) + (weight_n2 \u0026 0xffffff00)) | (1 + (((weight_n1 \u0026 0x000000ff) \u003e (weight_n2 \u0026 0x000000ff)) ? (weight_n1 \u0026 0x000000ff)\n            : (weight_n2 \u0026 0x000000ff))));\n\n        parent[nNodes] \u003d -1;\n        nHeap++;\n        heap[nHeap] \u003d nNodes;\n\n        tmp \u003d 0;\n        zz \u003d nHeap;\n        tmp \u003d heap[zz];\n        final int weight_tmp \u003d weight[tmp];\n        while (weight_tmp \u003c weight[heap[zz \u003e\u003e 1]]) {\n          heap[zz] \u003d heap[zz \u003e\u003e 1];\n          zz \u003e\u003e\u003d 1;\n        }\n        heap[zz] \u003d tmp;\n\n      }\n\n      // assert (nNodes \u003c (MAX_ALPHA_SIZE * 2)) : nNodes;\n\n      for (int i \u003d 1; i \u003c\u003d alphaSize; i++) {\n        int j \u003d 0;\n        int k \u003d i;\n\n        for (int parent_k; (parent_k \u003d parent[k]) \u003e\u003d 0;) {\n          k \u003d parent_k;\n          j++;\n        }\n\n        len[i - 1] \u003d (char) j;\n        if (j \u003e maxLen) {\n          tooLong \u003d true;\n        }\n      }\n\n      if (tooLong) {\n        for (int i \u003d 1; i \u003c alphaSize; i++) {\n          int j \u003d weight[i] \u003e\u003e 8;\n          j \u003d 1 + (j \u003e\u003e 1);\n          weight[i] \u003d j \u003c\u003c 8;\n        }\n      }\n    }\n  }",
      "path": "src/java/org/apache/hadoop/io/compress/bzip2/CBZip2OutputStream.java"
    }
  }
}