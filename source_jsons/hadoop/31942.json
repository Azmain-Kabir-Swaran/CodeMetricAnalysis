{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FlowScanner.java",
  "functionName": "collectCells",
  "functionId": "collectCells___currentColumnCells-SortedSet__Cell____currentAggOp-AggregationOperation__cell-Cell__alreadySeenAggDim-Set__String____converter-ValueConverter__scannerContext-ScannerContext",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice-hbase/hadoop-yarn-server-timelineservice-hbase-server/hadoop-yarn-server-timelineservice-hbase-server-2/src/main/java/org/apache/hadoop/yarn/server/timelineservice/storage/flow/FlowScanner.java",
  "functionStartLine": 262,
  "functionEndLine": 334,
  "numCommitsSeen": 4,
  "timeTaken": 756,
  "changeHistory": [
    "55ba49dd071b66e72c47a1c41e88b9a5feddf53b"
  ],
  "changeHistoryShort": {
    "55ba49dd071b66e72c47a1c41e88b9a5feddf53b": "Yintroduced"
  },
  "changeHistoryDetails": {
    "55ba49dd071b66e72c47a1c41e88b9a5feddf53b": {
      "type": "Yintroduced",
      "commitMessage": "YARN-7346. Add a profile to allow optional compilation for ATSv2 with HBase-2.0. Contributed by Haibo Chen and Rohith.\n",
      "commitDate": "05/03/18 10:25 PM",
      "commitName": "55ba49dd071b66e72c47a1c41e88b9a5feddf53b",
      "commitAuthor": "Rohith Sharma K S",
      "diff": "@@ -0,0 +1,73 @@\n+  private void collectCells(SortedSet\u003cCell\u003e currentColumnCells,\n+      AggregationOperation currentAggOp, Cell cell,\n+      Set\u003cString\u003e alreadySeenAggDim, ValueConverter converter,\n+      ScannerContext scannerContext) throws IOException {\n+\n+    if (currentAggOp \u003d\u003d null) {\n+      // not a min/max/metric cell, so just return it as is\n+      currentColumnCells.add(cell);\n+      return;\n+    }\n+\n+    switch (currentAggOp) {\n+    case GLOBAL_MIN:\n+      if (currentColumnCells.size() \u003d\u003d 0) {\n+        currentColumnCells.add(cell);\n+      } else {\n+        Cell currentMinCell \u003d currentColumnCells.first();\n+        Cell newMinCell \u003d compareCellValues(currentMinCell, cell, currentAggOp,\n+            (NumericValueConverter) converter);\n+        if (!currentMinCell.equals(newMinCell)) {\n+          currentColumnCells.remove(currentMinCell);\n+          currentColumnCells.add(newMinCell);\n+        }\n+      }\n+      break;\n+    case GLOBAL_MAX:\n+      if (currentColumnCells.size() \u003d\u003d 0) {\n+        currentColumnCells.add(cell);\n+      } else {\n+        Cell currentMaxCell \u003d currentColumnCells.first();\n+        Cell newMaxCell \u003d compareCellValues(currentMaxCell, cell, currentAggOp,\n+            (NumericValueConverter) converter);\n+        if (!currentMaxCell.equals(newMaxCell)) {\n+          currentColumnCells.remove(currentMaxCell);\n+          currentColumnCells.add(newMaxCell);\n+        }\n+      }\n+      break;\n+    case SUM:\n+    case SUM_FINAL:\n+      if (LOG.isTraceEnabled()) {\n+        LOG.trace(\"In collect cells \"\n+            + \" FlowSannerOperation\u003d\"\n+            + this.action\n+            + \" currentAggOp\u003d\"\n+            + currentAggOp\n+            + \" cell qualifier\u003d\"\n+            + Bytes.toString(CellUtil.cloneQualifier(cell))\n+            + \" cell value\u003d \"\n+            + converter.decodeValue(CellUtil.cloneValue(cell))\n+            + \" timestamp\u003d\" + cell.getTimestamp());\n+      }\n+\n+      // only if this app has not been seen yet, add to current column cells\n+      List\u003cTag\u003e tags \u003d HBaseTimelineServerUtils.convertCellAsTagList(cell);\n+      String aggDim \u003d HBaseTimelineServerUtils\n+          .getAggregationCompactionDimension(tags);\n+      if (!alreadySeenAggDim.contains(aggDim)) {\n+        // if this agg dimension has already been seen,\n+        // since they show up in sorted order\n+        // we drop the rest which are older\n+        // in other words, this cell is older than previously seen cells\n+        // for that agg dim\n+        // but when this agg dim is not seen,\n+        // consider this cell in our working set\n+        currentColumnCells.add(cell);\n+        alreadySeenAggDim.add(aggDim);\n+      }\n+      break;\n+    default:\n+      break;\n+    } // end of switch case\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void collectCells(SortedSet\u003cCell\u003e currentColumnCells,\n      AggregationOperation currentAggOp, Cell cell,\n      Set\u003cString\u003e alreadySeenAggDim, ValueConverter converter,\n      ScannerContext scannerContext) throws IOException {\n\n    if (currentAggOp \u003d\u003d null) {\n      // not a min/max/metric cell, so just return it as is\n      currentColumnCells.add(cell);\n      return;\n    }\n\n    switch (currentAggOp) {\n    case GLOBAL_MIN:\n      if (currentColumnCells.size() \u003d\u003d 0) {\n        currentColumnCells.add(cell);\n      } else {\n        Cell currentMinCell \u003d currentColumnCells.first();\n        Cell newMinCell \u003d compareCellValues(currentMinCell, cell, currentAggOp,\n            (NumericValueConverter) converter);\n        if (!currentMinCell.equals(newMinCell)) {\n          currentColumnCells.remove(currentMinCell);\n          currentColumnCells.add(newMinCell);\n        }\n      }\n      break;\n    case GLOBAL_MAX:\n      if (currentColumnCells.size() \u003d\u003d 0) {\n        currentColumnCells.add(cell);\n      } else {\n        Cell currentMaxCell \u003d currentColumnCells.first();\n        Cell newMaxCell \u003d compareCellValues(currentMaxCell, cell, currentAggOp,\n            (NumericValueConverter) converter);\n        if (!currentMaxCell.equals(newMaxCell)) {\n          currentColumnCells.remove(currentMaxCell);\n          currentColumnCells.add(newMaxCell);\n        }\n      }\n      break;\n    case SUM:\n    case SUM_FINAL:\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(\"In collect cells \"\n            + \" FlowSannerOperation\u003d\"\n            + this.action\n            + \" currentAggOp\u003d\"\n            + currentAggOp\n            + \" cell qualifier\u003d\"\n            + Bytes.toString(CellUtil.cloneQualifier(cell))\n            + \" cell value\u003d \"\n            + converter.decodeValue(CellUtil.cloneValue(cell))\n            + \" timestamp\u003d\" + cell.getTimestamp());\n      }\n\n      // only if this app has not been seen yet, add to current column cells\n      List\u003cTag\u003e tags \u003d HBaseTimelineServerUtils.convertCellAsTagList(cell);\n      String aggDim \u003d HBaseTimelineServerUtils\n          .getAggregationCompactionDimension(tags);\n      if (!alreadySeenAggDim.contains(aggDim)) {\n        // if this agg dimension has already been seen,\n        // since they show up in sorted order\n        // we drop the rest which are older\n        // in other words, this cell is older than previously seen cells\n        // for that agg dim\n        // but when this agg dim is not seen,\n        // consider this cell in our working set\n        currentColumnCells.add(cell);\n        alreadySeenAggDim.add(aggDim);\n      }\n      break;\n    default:\n      break;\n    } // end of switch case\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice-hbase/hadoop-yarn-server-timelineservice-hbase-server/hadoop-yarn-server-timelineservice-hbase-server-2/src/main/java/org/apache/hadoop/yarn/server/timelineservice/storage/flow/FlowScanner.java"
    }
  }
}