{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "StripedBlockWriter.java",
  "functionName": "init",
  "functionId": "init",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/erasurecode/StripedBlockWriter.java",
  "functionStartLine": 104,
  "functionEndLine": 159,
  "numCommitsSeen": 7,
  "timeTaken": 2440,
  "changeHistory": [
    "a3954ccab148bddc290cb96528e63ff19799bcc9",
    "2f73396b5901fd5fe29f6cd76fc1b3134b854b37",
    "ed0bebabaaf27cd730f7f8eb002d92c9c7db327d",
    "e4a25456202feeee9880d822a8e6f9c19cbcf24a",
    "3c18a53cbd2efabb2ad108d63a0b0b558424115f"
  ],
  "changeHistoryShort": {
    "a3954ccab148bddc290cb96528e63ff19799bcc9": "Ybodychange",
    "2f73396b5901fd5fe29f6cd76fc1b3134b854b37": "Ybodychange",
    "ed0bebabaaf27cd730f7f8eb002d92c9c7db327d": "Ybodychange",
    "e4a25456202feeee9880d822a8e6f9c19cbcf24a": "Ybodychange",
    "3c18a53cbd2efabb2ad108d63a0b0b558424115f": "Yintroduced"
  },
  "changeHistoryDetails": {
    "a3954ccab148bddc290cb96528e63ff19799bcc9": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9807. Add an optional StorageID to writes. Contributed by Ewan Higgs\n",
      "commitDate": "05/05/17 12:01 PM",
      "commitName": "a3954ccab148bddc290cb96528e63ff19799bcc9",
      "commitAuthor": "Chris Douglas",
      "commitDateOld": "25/04/17 11:57 PM",
      "commitNameOld": "2f73396b5901fd5fe29f6cd76fc1b3134b854b37",
      "commitAuthorOld": "Chris Douglas",
      "daysBetweenCommits": 9.5,
      "commitsBetweenForRepo": 64,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,56 +1,56 @@\n   private void init() throws IOException {\n     Socket socket \u003d null;\n     DataOutputStream out \u003d null;\n     DataInputStream in \u003d null;\n     boolean success \u003d false;\n     try {\n       InetSocketAddress targetAddr \u003d\n           stripedWriter.getSocketAddress4Transfer(target);\n       socket \u003d datanode.newSocket();\n       NetUtils.connect(socket, targetAddr,\n           datanode.getDnConf().getSocketTimeout());\n       socket.setTcpNoDelay(\n           datanode.getDnConf().getDataTransferServerTcpNoDelay());\n       socket.setSoTimeout(datanode.getDnConf().getSocketTimeout());\n \n       Token\u003cBlockTokenIdentifier\u003e blockToken \u003d\n           datanode.getBlockAccessToken(block,\n               EnumSet.of(BlockTokenIdentifier.AccessMode.WRITE),\n-              new StorageType[]{storageType});\n+              new StorageType[]{storageType}, new String[]{storageId});\n \n       long writeTimeout \u003d datanode.getDnConf().getSocketWriteTimeout();\n       OutputStream unbufOut \u003d NetUtils.getOutputStream(socket, writeTimeout);\n       InputStream unbufIn \u003d NetUtils.getInputStream(socket);\n       DataEncryptionKeyFactory keyFactory \u003d\n           datanode.getDataEncryptionKeyFactoryForBlock(block);\n       IOStreamPair saslStreams \u003d datanode.getSaslClient().socketSend(\n           socket, unbufOut, unbufIn, keyFactory, blockToken, target);\n \n       unbufOut \u003d saslStreams.out;\n       unbufIn \u003d saslStreams.in;\n \n       out \u003d new DataOutputStream(new BufferedOutputStream(unbufOut,\n           DFSUtilClient.getSmallBufferSize(conf)));\n       in \u003d new DataInputStream(unbufIn);\n \n       DatanodeInfo source \u003d new DatanodeInfoBuilder()\n           .setNodeID(datanode.getDatanodeId()).build();\n       new Sender(out).writeBlock(block, storageType,\n           blockToken, \"\", new DatanodeInfo[]{target},\n           new StorageType[]{storageType}, source,\n           BlockConstructionStage.PIPELINE_SETUP_CREATE, 0, 0, 0, 0,\n           stripedWriter.getChecksum(), stripedWriter.getCachingStrategy(),\n-          false, false, null);\n+          false, false, null, storageId, new String[]{storageId});\n \n       targetSocket \u003d socket;\n       targetOutputStream \u003d out;\n       targetInputStream \u003d in;\n       success \u003d true;\n     } finally {\n       if (!success) {\n         IOUtils.closeStream(out);\n         IOUtils.closeStream(in);\n         IOUtils.closeStream(socket);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void init() throws IOException {\n    Socket socket \u003d null;\n    DataOutputStream out \u003d null;\n    DataInputStream in \u003d null;\n    boolean success \u003d false;\n    try {\n      InetSocketAddress targetAddr \u003d\n          stripedWriter.getSocketAddress4Transfer(target);\n      socket \u003d datanode.newSocket();\n      NetUtils.connect(socket, targetAddr,\n          datanode.getDnConf().getSocketTimeout());\n      socket.setTcpNoDelay(\n          datanode.getDnConf().getDataTransferServerTcpNoDelay());\n      socket.setSoTimeout(datanode.getDnConf().getSocketTimeout());\n\n      Token\u003cBlockTokenIdentifier\u003e blockToken \u003d\n          datanode.getBlockAccessToken(block,\n              EnumSet.of(BlockTokenIdentifier.AccessMode.WRITE),\n              new StorageType[]{storageType}, new String[]{storageId});\n\n      long writeTimeout \u003d datanode.getDnConf().getSocketWriteTimeout();\n      OutputStream unbufOut \u003d NetUtils.getOutputStream(socket, writeTimeout);\n      InputStream unbufIn \u003d NetUtils.getInputStream(socket);\n      DataEncryptionKeyFactory keyFactory \u003d\n          datanode.getDataEncryptionKeyFactoryForBlock(block);\n      IOStreamPair saslStreams \u003d datanode.getSaslClient().socketSend(\n          socket, unbufOut, unbufIn, keyFactory, blockToken, target);\n\n      unbufOut \u003d saslStreams.out;\n      unbufIn \u003d saslStreams.in;\n\n      out \u003d new DataOutputStream(new BufferedOutputStream(unbufOut,\n          DFSUtilClient.getSmallBufferSize(conf)));\n      in \u003d new DataInputStream(unbufIn);\n\n      DatanodeInfo source \u003d new DatanodeInfoBuilder()\n          .setNodeID(datanode.getDatanodeId()).build();\n      new Sender(out).writeBlock(block, storageType,\n          blockToken, \"\", new DatanodeInfo[]{target},\n          new StorageType[]{storageType}, source,\n          BlockConstructionStage.PIPELINE_SETUP_CREATE, 0, 0, 0, 0,\n          stripedWriter.getChecksum(), stripedWriter.getCachingStrategy(),\n          false, false, null, storageId, new String[]{storageId});\n\n      targetSocket \u003d socket;\n      targetOutputStream \u003d out;\n      targetInputStream \u003d in;\n      success \u003d true;\n    } finally {\n      if (!success) {\n        IOUtils.closeStream(out);\n        IOUtils.closeStream(in);\n        IOUtils.closeStream(socket);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/erasurecode/StripedBlockWriter.java",
      "extendedDetails": {}
    },
    "2f73396b5901fd5fe29f6cd76fc1b3134b854b37": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6708. StorageType should be encoded in the block token. Contributed by Ewan Higgs\n",
      "commitDate": "25/04/17 11:57 PM",
      "commitName": "2f73396b5901fd5fe29f6cd76fc1b3134b854b37",
      "commitAuthor": "Chris Douglas",
      "commitDateOld": "13/12/16 10:50 PM",
      "commitNameOld": "1f14f6d038aecad55a5398c6fa4137c9d2f44729",
      "commitAuthorOld": "Kai Zheng",
      "daysBetweenCommits": 133.0,
      "commitsBetweenForRepo": 691,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,55 +1,56 @@\n   private void init() throws IOException {\n     Socket socket \u003d null;\n     DataOutputStream out \u003d null;\n     DataInputStream in \u003d null;\n     boolean success \u003d false;\n     try {\n       InetSocketAddress targetAddr \u003d\n           stripedWriter.getSocketAddress4Transfer(target);\n       socket \u003d datanode.newSocket();\n       NetUtils.connect(socket, targetAddr,\n           datanode.getDnConf().getSocketTimeout());\n       socket.setTcpNoDelay(\n           datanode.getDnConf().getDataTransferServerTcpNoDelay());\n       socket.setSoTimeout(datanode.getDnConf().getSocketTimeout());\n \n       Token\u003cBlockTokenIdentifier\u003e blockToken \u003d\n           datanode.getBlockAccessToken(block,\n-              EnumSet.of(BlockTokenIdentifier.AccessMode.WRITE));\n+              EnumSet.of(BlockTokenIdentifier.AccessMode.WRITE),\n+              new StorageType[]{storageType});\n \n       long writeTimeout \u003d datanode.getDnConf().getSocketWriteTimeout();\n       OutputStream unbufOut \u003d NetUtils.getOutputStream(socket, writeTimeout);\n       InputStream unbufIn \u003d NetUtils.getInputStream(socket);\n       DataEncryptionKeyFactory keyFactory \u003d\n           datanode.getDataEncryptionKeyFactoryForBlock(block);\n       IOStreamPair saslStreams \u003d datanode.getSaslClient().socketSend(\n           socket, unbufOut, unbufIn, keyFactory, blockToken, target);\n \n       unbufOut \u003d saslStreams.out;\n       unbufIn \u003d saslStreams.in;\n \n       out \u003d new DataOutputStream(new BufferedOutputStream(unbufOut,\n           DFSUtilClient.getSmallBufferSize(conf)));\n       in \u003d new DataInputStream(unbufIn);\n \n       DatanodeInfo source \u003d new DatanodeInfoBuilder()\n           .setNodeID(datanode.getDatanodeId()).build();\n       new Sender(out).writeBlock(block, storageType,\n           blockToken, \"\", new DatanodeInfo[]{target},\n           new StorageType[]{storageType}, source,\n           BlockConstructionStage.PIPELINE_SETUP_CREATE, 0, 0, 0, 0,\n           stripedWriter.getChecksum(), stripedWriter.getCachingStrategy(),\n           false, false, null);\n \n       targetSocket \u003d socket;\n       targetOutputStream \u003d out;\n       targetInputStream \u003d in;\n       success \u003d true;\n     } finally {\n       if (!success) {\n         IOUtils.closeStream(out);\n         IOUtils.closeStream(in);\n         IOUtils.closeStream(socket);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void init() throws IOException {\n    Socket socket \u003d null;\n    DataOutputStream out \u003d null;\n    DataInputStream in \u003d null;\n    boolean success \u003d false;\n    try {\n      InetSocketAddress targetAddr \u003d\n          stripedWriter.getSocketAddress4Transfer(target);\n      socket \u003d datanode.newSocket();\n      NetUtils.connect(socket, targetAddr,\n          datanode.getDnConf().getSocketTimeout());\n      socket.setTcpNoDelay(\n          datanode.getDnConf().getDataTransferServerTcpNoDelay());\n      socket.setSoTimeout(datanode.getDnConf().getSocketTimeout());\n\n      Token\u003cBlockTokenIdentifier\u003e blockToken \u003d\n          datanode.getBlockAccessToken(block,\n              EnumSet.of(BlockTokenIdentifier.AccessMode.WRITE),\n              new StorageType[]{storageType});\n\n      long writeTimeout \u003d datanode.getDnConf().getSocketWriteTimeout();\n      OutputStream unbufOut \u003d NetUtils.getOutputStream(socket, writeTimeout);\n      InputStream unbufIn \u003d NetUtils.getInputStream(socket);\n      DataEncryptionKeyFactory keyFactory \u003d\n          datanode.getDataEncryptionKeyFactoryForBlock(block);\n      IOStreamPair saslStreams \u003d datanode.getSaslClient().socketSend(\n          socket, unbufOut, unbufIn, keyFactory, blockToken, target);\n\n      unbufOut \u003d saslStreams.out;\n      unbufIn \u003d saslStreams.in;\n\n      out \u003d new DataOutputStream(new BufferedOutputStream(unbufOut,\n          DFSUtilClient.getSmallBufferSize(conf)));\n      in \u003d new DataInputStream(unbufIn);\n\n      DatanodeInfo source \u003d new DatanodeInfoBuilder()\n          .setNodeID(datanode.getDatanodeId()).build();\n      new Sender(out).writeBlock(block, storageType,\n          blockToken, \"\", new DatanodeInfo[]{target},\n          new StorageType[]{storageType}, source,\n          BlockConstructionStage.PIPELINE_SETUP_CREATE, 0, 0, 0, 0,\n          stripedWriter.getChecksum(), stripedWriter.getCachingStrategy(),\n          false, false, null);\n\n      targetSocket \u003d socket;\n      targetOutputStream \u003d out;\n      targetInputStream \u003d in;\n      success \u003d true;\n    } finally {\n      if (!success) {\n        IOUtils.closeStream(out);\n        IOUtils.closeStream(in);\n        IOUtils.closeStream(socket);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/erasurecode/StripedBlockWriter.java",
      "extendedDetails": {}
    },
    "ed0bebabaaf27cd730f7f8eb002d92c9c7db327d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9482. Replace DatanodeInfo constructors with a builder pattern. Contributed by Brahma Reddy Battula.\n",
      "commitDate": "08/11/16 6:17 PM",
      "commitName": "ed0bebabaaf27cd730f7f8eb002d92c9c7db327d",
      "commitAuthor": "Brahma Reddy Battula",
      "commitDateOld": "12/08/16 10:52 PM",
      "commitNameOld": "b5af9be72c72734d668f817c99d889031922a951",
      "commitAuthorOld": "Kai Zheng",
      "daysBetweenCommits": 87.85,
      "commitsBetweenForRepo": 661,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,55 @@\n   private void init() throws IOException {\n     Socket socket \u003d null;\n     DataOutputStream out \u003d null;\n     DataInputStream in \u003d null;\n     boolean success \u003d false;\n     try {\n       InetSocketAddress targetAddr \u003d\n           stripedWriter.getSocketAddress4Transfer(target);\n       socket \u003d datanode.newSocket();\n       NetUtils.connect(socket, targetAddr,\n           datanode.getDnConf().getSocketTimeout());\n       socket.setTcpNoDelay(\n           datanode.getDnConf().getDataTransferServerTcpNoDelay());\n       socket.setSoTimeout(datanode.getDnConf().getSocketTimeout());\n \n       Token\u003cBlockTokenIdentifier\u003e blockToken \u003d\n           datanode.getBlockAccessToken(block,\n               EnumSet.of(BlockTokenIdentifier.AccessMode.WRITE));\n \n       long writeTimeout \u003d datanode.getDnConf().getSocketWriteTimeout();\n       OutputStream unbufOut \u003d NetUtils.getOutputStream(socket, writeTimeout);\n       InputStream unbufIn \u003d NetUtils.getInputStream(socket);\n       DataEncryptionKeyFactory keyFactory \u003d\n           datanode.getDataEncryptionKeyFactoryForBlock(block);\n       IOStreamPair saslStreams \u003d datanode.getSaslClient().socketSend(\n           socket, unbufOut, unbufIn, keyFactory, blockToken, target);\n \n       unbufOut \u003d saslStreams.out;\n       unbufIn \u003d saslStreams.in;\n \n       out \u003d new DataOutputStream(new BufferedOutputStream(unbufOut,\n           DFSUtilClient.getSmallBufferSize(conf)));\n       in \u003d new DataInputStream(unbufIn);\n \n-      DatanodeInfo source \u003d new DatanodeInfo(datanode.getDatanodeId());\n+      DatanodeInfo source \u003d new DatanodeInfoBuilder()\n+          .setNodeID(datanode.getDatanodeId()).build();\n       new Sender(out).writeBlock(block, storageType,\n           blockToken, \"\", new DatanodeInfo[]{target},\n           new StorageType[]{storageType}, source,\n           BlockConstructionStage.PIPELINE_SETUP_CREATE, 0, 0, 0, 0,\n           stripedWriter.getChecksum(), stripedWriter.getCachingStrategy(),\n           false, false, null);\n \n       targetSocket \u003d socket;\n       targetOutputStream \u003d out;\n       targetInputStream \u003d in;\n       success \u003d true;\n     } finally {\n       if (!success) {\n         IOUtils.closeStream(out);\n         IOUtils.closeStream(in);\n         IOUtils.closeStream(socket);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void init() throws IOException {\n    Socket socket \u003d null;\n    DataOutputStream out \u003d null;\n    DataInputStream in \u003d null;\n    boolean success \u003d false;\n    try {\n      InetSocketAddress targetAddr \u003d\n          stripedWriter.getSocketAddress4Transfer(target);\n      socket \u003d datanode.newSocket();\n      NetUtils.connect(socket, targetAddr,\n          datanode.getDnConf().getSocketTimeout());\n      socket.setTcpNoDelay(\n          datanode.getDnConf().getDataTransferServerTcpNoDelay());\n      socket.setSoTimeout(datanode.getDnConf().getSocketTimeout());\n\n      Token\u003cBlockTokenIdentifier\u003e blockToken \u003d\n          datanode.getBlockAccessToken(block,\n              EnumSet.of(BlockTokenIdentifier.AccessMode.WRITE));\n\n      long writeTimeout \u003d datanode.getDnConf().getSocketWriteTimeout();\n      OutputStream unbufOut \u003d NetUtils.getOutputStream(socket, writeTimeout);\n      InputStream unbufIn \u003d NetUtils.getInputStream(socket);\n      DataEncryptionKeyFactory keyFactory \u003d\n          datanode.getDataEncryptionKeyFactoryForBlock(block);\n      IOStreamPair saslStreams \u003d datanode.getSaslClient().socketSend(\n          socket, unbufOut, unbufIn, keyFactory, blockToken, target);\n\n      unbufOut \u003d saslStreams.out;\n      unbufIn \u003d saslStreams.in;\n\n      out \u003d new DataOutputStream(new BufferedOutputStream(unbufOut,\n          DFSUtilClient.getSmallBufferSize(conf)));\n      in \u003d new DataInputStream(unbufIn);\n\n      DatanodeInfo source \u003d new DatanodeInfoBuilder()\n          .setNodeID(datanode.getDatanodeId()).build();\n      new Sender(out).writeBlock(block, storageType,\n          blockToken, \"\", new DatanodeInfo[]{target},\n          new StorageType[]{storageType}, source,\n          BlockConstructionStage.PIPELINE_SETUP_CREATE, 0, 0, 0, 0,\n          stripedWriter.getChecksum(), stripedWriter.getCachingStrategy(),\n          false, false, null);\n\n      targetSocket \u003d socket;\n      targetOutputStream \u003d out;\n      targetInputStream \u003d in;\n      success \u003d true;\n    } finally {\n      if (!success) {\n        IOUtils.closeStream(out);\n        IOUtils.closeStream(in);\n        IOUtils.closeStream(socket);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/erasurecode/StripedBlockWriter.java",
      "extendedDetails": {}
    },
    "e4a25456202feeee9880d822a8e6f9c19cbcf24a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9805. Add server-side configuration for enabling TCP_NODELAY for DataTransferProtocol and default it to true (Gary Helmling via cmccabe)\n",
      "commitDate": "29/06/16 12:41 PM",
      "commitName": "e4a25456202feeee9880d822a8e6f9c19cbcf24a",
      "commitAuthor": "Colin Patrick Mccabe",
      "commitDateOld": "06/04/16 10:50 PM",
      "commitNameOld": "3c18a53cbd2efabb2ad108d63a0b0b558424115f",
      "commitAuthorOld": "Uma Maheswara Rao G",
      "daysBetweenCommits": 83.58,
      "commitsBetweenForRepo": 575,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,54 @@\n   private void init() throws IOException {\n     Socket socket \u003d null;\n     DataOutputStream out \u003d null;\n     DataInputStream in \u003d null;\n     boolean success \u003d false;\n     try {\n       InetSocketAddress targetAddr \u003d\n           stripedWriter.getSocketAddress4Transfer(target);\n       socket \u003d datanode.newSocket();\n       NetUtils.connect(socket, targetAddr,\n           datanode.getDnConf().getSocketTimeout());\n+      socket.setTcpNoDelay(\n+          datanode.getDnConf().getDataTransferServerTcpNoDelay());\n       socket.setSoTimeout(datanode.getDnConf().getSocketTimeout());\n \n       Token\u003cBlockTokenIdentifier\u003e blockToken \u003d\n           datanode.getBlockAccessToken(block,\n               EnumSet.of(BlockTokenIdentifier.AccessMode.WRITE));\n \n       long writeTimeout \u003d datanode.getDnConf().getSocketWriteTimeout();\n       OutputStream unbufOut \u003d NetUtils.getOutputStream(socket, writeTimeout);\n       InputStream unbufIn \u003d NetUtils.getInputStream(socket);\n       DataEncryptionKeyFactory keyFactory \u003d\n           datanode.getDataEncryptionKeyFactoryForBlock(block);\n       IOStreamPair saslStreams \u003d datanode.getSaslClient().socketSend(\n           socket, unbufOut, unbufIn, keyFactory, blockToken, target);\n \n       unbufOut \u003d saslStreams.out;\n       unbufIn \u003d saslStreams.in;\n \n       out \u003d new DataOutputStream(new BufferedOutputStream(unbufOut,\n           DFSUtilClient.getSmallBufferSize(conf)));\n       in \u003d new DataInputStream(unbufIn);\n \n       DatanodeInfo source \u003d new DatanodeInfo(datanode.getDatanodeId());\n       new Sender(out).writeBlock(block, storageType,\n           blockToken, \"\", new DatanodeInfo[]{target},\n           new StorageType[]{storageType}, source,\n           BlockConstructionStage.PIPELINE_SETUP_CREATE, 0, 0, 0, 0,\n           stripedWriter.getChecksum(), stripedWriter.getCachingStrategy(),\n           false, false, null);\n \n       targetSocket \u003d socket;\n       targetOutputStream \u003d out;\n       targetInputStream \u003d in;\n       success \u003d true;\n     } finally {\n       if (!success) {\n         IOUtils.closeStream(out);\n         IOUtils.closeStream(in);\n         IOUtils.closeStream(socket);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void init() throws IOException {\n    Socket socket \u003d null;\n    DataOutputStream out \u003d null;\n    DataInputStream in \u003d null;\n    boolean success \u003d false;\n    try {\n      InetSocketAddress targetAddr \u003d\n          stripedWriter.getSocketAddress4Transfer(target);\n      socket \u003d datanode.newSocket();\n      NetUtils.connect(socket, targetAddr,\n          datanode.getDnConf().getSocketTimeout());\n      socket.setTcpNoDelay(\n          datanode.getDnConf().getDataTransferServerTcpNoDelay());\n      socket.setSoTimeout(datanode.getDnConf().getSocketTimeout());\n\n      Token\u003cBlockTokenIdentifier\u003e blockToken \u003d\n          datanode.getBlockAccessToken(block,\n              EnumSet.of(BlockTokenIdentifier.AccessMode.WRITE));\n\n      long writeTimeout \u003d datanode.getDnConf().getSocketWriteTimeout();\n      OutputStream unbufOut \u003d NetUtils.getOutputStream(socket, writeTimeout);\n      InputStream unbufIn \u003d NetUtils.getInputStream(socket);\n      DataEncryptionKeyFactory keyFactory \u003d\n          datanode.getDataEncryptionKeyFactoryForBlock(block);\n      IOStreamPair saslStreams \u003d datanode.getSaslClient().socketSend(\n          socket, unbufOut, unbufIn, keyFactory, blockToken, target);\n\n      unbufOut \u003d saslStreams.out;\n      unbufIn \u003d saslStreams.in;\n\n      out \u003d new DataOutputStream(new BufferedOutputStream(unbufOut,\n          DFSUtilClient.getSmallBufferSize(conf)));\n      in \u003d new DataInputStream(unbufIn);\n\n      DatanodeInfo source \u003d new DatanodeInfo(datanode.getDatanodeId());\n      new Sender(out).writeBlock(block, storageType,\n          blockToken, \"\", new DatanodeInfo[]{target},\n          new StorageType[]{storageType}, source,\n          BlockConstructionStage.PIPELINE_SETUP_CREATE, 0, 0, 0, 0,\n          stripedWriter.getChecksum(), stripedWriter.getCachingStrategy(),\n          false, false, null);\n\n      targetSocket \u003d socket;\n      targetOutputStream \u003d out;\n      targetInputStream \u003d in;\n      success \u003d true;\n    } finally {\n      if (!success) {\n        IOUtils.closeStream(out);\n        IOUtils.closeStream(in);\n        IOUtils.closeStream(socket);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/erasurecode/StripedBlockWriter.java",
      "extendedDetails": {}
    },
    "3c18a53cbd2efabb2ad108d63a0b0b558424115f": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-9719. Refactoring ErasureCodingWorker into smaller reusable constructs. Contributed by Kai Zheng.\n",
      "commitDate": "06/04/16 10:50 PM",
      "commitName": "3c18a53cbd2efabb2ad108d63a0b0b558424115f",
      "commitAuthor": "Uma Maheswara Rao G",
      "diff": "@@ -0,0 +1,52 @@\n+  private void init() throws IOException {\n+    Socket socket \u003d null;\n+    DataOutputStream out \u003d null;\n+    DataInputStream in \u003d null;\n+    boolean success \u003d false;\n+    try {\n+      InetSocketAddress targetAddr \u003d\n+          stripedWriter.getSocketAddress4Transfer(target);\n+      socket \u003d datanode.newSocket();\n+      NetUtils.connect(socket, targetAddr,\n+          datanode.getDnConf().getSocketTimeout());\n+      socket.setSoTimeout(datanode.getDnConf().getSocketTimeout());\n+\n+      Token\u003cBlockTokenIdentifier\u003e blockToken \u003d\n+          datanode.getBlockAccessToken(block,\n+              EnumSet.of(BlockTokenIdentifier.AccessMode.WRITE));\n+\n+      long writeTimeout \u003d datanode.getDnConf().getSocketWriteTimeout();\n+      OutputStream unbufOut \u003d NetUtils.getOutputStream(socket, writeTimeout);\n+      InputStream unbufIn \u003d NetUtils.getInputStream(socket);\n+      DataEncryptionKeyFactory keyFactory \u003d\n+          datanode.getDataEncryptionKeyFactoryForBlock(block);\n+      IOStreamPair saslStreams \u003d datanode.getSaslClient().socketSend(\n+          socket, unbufOut, unbufIn, keyFactory, blockToken, target);\n+\n+      unbufOut \u003d saslStreams.out;\n+      unbufIn \u003d saslStreams.in;\n+\n+      out \u003d new DataOutputStream(new BufferedOutputStream(unbufOut,\n+          DFSUtilClient.getSmallBufferSize(conf)));\n+      in \u003d new DataInputStream(unbufIn);\n+\n+      DatanodeInfo source \u003d new DatanodeInfo(datanode.getDatanodeId());\n+      new Sender(out).writeBlock(block, storageType,\n+          blockToken, \"\", new DatanodeInfo[]{target},\n+          new StorageType[]{storageType}, source,\n+          BlockConstructionStage.PIPELINE_SETUP_CREATE, 0, 0, 0, 0,\n+          stripedWriter.getChecksum(), stripedWriter.getCachingStrategy(),\n+          false, false, null);\n+\n+      targetSocket \u003d socket;\n+      targetOutputStream \u003d out;\n+      targetInputStream \u003d in;\n+      success \u003d true;\n+    } finally {\n+      if (!success) {\n+        IOUtils.closeStream(out);\n+        IOUtils.closeStream(in);\n+        IOUtils.closeStream(socket);\n+      }\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void init() throws IOException {\n    Socket socket \u003d null;\n    DataOutputStream out \u003d null;\n    DataInputStream in \u003d null;\n    boolean success \u003d false;\n    try {\n      InetSocketAddress targetAddr \u003d\n          stripedWriter.getSocketAddress4Transfer(target);\n      socket \u003d datanode.newSocket();\n      NetUtils.connect(socket, targetAddr,\n          datanode.getDnConf().getSocketTimeout());\n      socket.setSoTimeout(datanode.getDnConf().getSocketTimeout());\n\n      Token\u003cBlockTokenIdentifier\u003e blockToken \u003d\n          datanode.getBlockAccessToken(block,\n              EnumSet.of(BlockTokenIdentifier.AccessMode.WRITE));\n\n      long writeTimeout \u003d datanode.getDnConf().getSocketWriteTimeout();\n      OutputStream unbufOut \u003d NetUtils.getOutputStream(socket, writeTimeout);\n      InputStream unbufIn \u003d NetUtils.getInputStream(socket);\n      DataEncryptionKeyFactory keyFactory \u003d\n          datanode.getDataEncryptionKeyFactoryForBlock(block);\n      IOStreamPair saslStreams \u003d datanode.getSaslClient().socketSend(\n          socket, unbufOut, unbufIn, keyFactory, blockToken, target);\n\n      unbufOut \u003d saslStreams.out;\n      unbufIn \u003d saslStreams.in;\n\n      out \u003d new DataOutputStream(new BufferedOutputStream(unbufOut,\n          DFSUtilClient.getSmallBufferSize(conf)));\n      in \u003d new DataInputStream(unbufIn);\n\n      DatanodeInfo source \u003d new DatanodeInfo(datanode.getDatanodeId());\n      new Sender(out).writeBlock(block, storageType,\n          blockToken, \"\", new DatanodeInfo[]{target},\n          new StorageType[]{storageType}, source,\n          BlockConstructionStage.PIPELINE_SETUP_CREATE, 0, 0, 0, 0,\n          stripedWriter.getChecksum(), stripedWriter.getCachingStrategy(),\n          false, false, null);\n\n      targetSocket \u003d socket;\n      targetOutputStream \u003d out;\n      targetInputStream \u003d in;\n      success \u003d true;\n    } finally {\n      if (!success) {\n        IOUtils.closeStream(out);\n        IOUtils.closeStream(in);\n        IOUtils.closeStream(socket);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/erasurecode/StripedBlockWriter.java"
    }
  }
}