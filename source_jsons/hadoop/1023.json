{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FileChecksumHelper.java",
  "functionName": "tryDatanode",
  "functionId": "tryDatanode___blockGroup-LocatedStripedBlock__stripedBlockInfo-StripedBlockInfo__datanode-DatanodeInfo__requestedNumBytes-long",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/FileChecksumHelper.java",
  "functionStartLine": 691,
  "functionEndLine": 721,
  "numCommitsSeen": 14,
  "timeTaken": 1910,
  "changeHistory": [
    "7c9cdad6d04c98db5a83e2108219bf6e6c903daf",
    "e6cb07520f935efde3e881de8f84ee7f6e0a746f",
    "3a4ff7776e8fab6cc87932b9aa8fb48f7b69c720"
  ],
  "changeHistoryShort": {
    "7c9cdad6d04c98db5a83e2108219bf6e6c903daf": "Ybodychange",
    "e6cb07520f935efde3e881de8f84ee7f6e0a746f": "Ymultichange(Yparameterchange,Ybodychange)",
    "3a4ff7776e8fab6cc87932b9aa8fb48f7b69c720": "Yintroduced"
  },
  "changeHistoryDetails": {
    "7c9cdad6d04c98db5a83e2108219bf6e6c903daf": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13056. Expose file-level composite CRCs in HDFS which are comparable across different instances/layouts. Contributed by Dennis Huo.\n",
      "commitDate": "10/04/18 9:31 PM",
      "commitName": "7c9cdad6d04c98db5a83e2108219bf6e6c903daf",
      "commitAuthor": "Xiao Chen",
      "commitDateOld": "03/01/18 2:54 PM",
      "commitNameOld": "3ba985997d1dc37e5ba017dd0ab1d36083b5f77b",
      "commitAuthorOld": "Xiaoyu Yao",
      "daysBetweenCommits": 97.23,
      "commitsBetweenForRepo": 742,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,73 +1,31 @@\n     private void tryDatanode(LocatedStripedBlock blockGroup,\n                              StripedBlockInfo stripedBlockInfo,\n                              DatanodeInfo datanode,\n                              long requestedNumBytes) throws IOException {\n-\n       try (IOStreamPair pair \u003d getClient().connectToDN(datanode,\n           getTimeout(), blockGroup.getBlockToken())) {\n \n         LOG.debug(\"write to {}: {}, blockGroup\u003d{}\",\n             datanode, Op.BLOCK_GROUP_CHECKSUM, blockGroup);\n \n-        // get block MD5\n-        createSender(pair).blockGroupChecksum(stripedBlockInfo,\n-            blockGroup.getBlockToken(), requestedNumBytes);\n+        // get block group checksum\n+        createSender(pair).blockGroupChecksum(\n+            stripedBlockInfo,\n+            blockGroup.getBlockToken(),\n+            requestedNumBytes,\n+            new BlockChecksumOptions(getBlockChecksumType()));\n \n         BlockOpResponseProto reply \u003d BlockOpResponseProto.parseFrom(\n             PBHelperClient.vintPrefixed(pair.in));\n \n         String logInfo \u003d \"for blockGroup \" + blockGroup +\n             \" from datanode \" + datanode;\n         DataTransferProtoUtil.checkBlockOpStatus(reply, logInfo);\n \n         OpBlockChecksumResponseProto checksumData \u003d reply.getChecksumResponse();\n-\n-        //read byte-per-checksum\n-        final int bpc \u003d checksumData.getBytesPerCrc();\n-        if (bgIdx \u003d\u003d 0) { //first block\n-          setBytesPerCRC(bpc);\n-        } else {\n-          if (bpc !\u003d getBytesPerCRC()) {\n-            throw new IOException(\"Byte-per-checksum not matched: bpc\u003d\" + bpc\n-                + \" but bytesPerCRC\u003d\" + getBytesPerCRC());\n-          }\n-        }\n-\n-        //read crc-per-block\n-        final long cpb \u003d checksumData.getCrcPerBlock();\n-        if (getLocatedBlocks().size() \u003e 1 \u0026\u0026 bgIdx \u003d\u003d 0) { // first block\n-          setCrcPerBlock(cpb);\n-        }\n-\n-        //read md5\n-        final MD5Hash md5 \u003d new MD5Hash(\n-            checksumData.getMd5().toByteArray());\n-        md5.write(getMd5out());\n-\n-        // read crc-type\n-        final DataChecksum.Type ct;\n-        if (checksumData.hasCrcType()) {\n-          ct \u003d PBHelperClient.convert(checksumData.getCrcType());\n-        } else {\n-          LOG.debug(\"Retrieving checksum from an earlier-version DataNode: \" +\n-              \"inferring checksum by reading first byte\");\n-          ct \u003d getClient().inferChecksumTypeByReading(blockGroup, datanode);\n-        }\n-\n-        if (bgIdx \u003d\u003d 0) {\n-          setCrcType(ct);\n-        } else if (getCrcType() !\u003d DataChecksum.Type.MIXED \u0026\u0026\n-            getCrcType() !\u003d ct) {\n-          // if crc types are mixed in a file\n-          setCrcType(DataChecksum.Type.MIXED);\n-        }\n-\n-        if (LOG.isDebugEnabled()) {\n-          if (bgIdx \u003d\u003d 0) {\n-            LOG.debug(\"set bytesPerCRC\u003d\" + getBytesPerCRC()\n-                + \", crcPerBlock\u003d\" + getCrcPerBlock());\n-          }\n-          LOG.debug(\"got reply from \" + datanode + \": md5\u003d\" + md5);\n-        }\n+        extractChecksumProperties(checksumData, blockGroup, datanode, bgIdx);\n+        String blockChecksumForDebug \u003d populateBlockChecksumBuf(checksumData);\n+        LOG.debug(\"got reply from {}: blockChecksum\u003d{}, blockChecksumType\u003d{}\",\n+            datanode, blockChecksumForDebug, getBlockChecksumType());\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void tryDatanode(LocatedStripedBlock blockGroup,\n                             StripedBlockInfo stripedBlockInfo,\n                             DatanodeInfo datanode,\n                             long requestedNumBytes) throws IOException {\n      try (IOStreamPair pair \u003d getClient().connectToDN(datanode,\n          getTimeout(), blockGroup.getBlockToken())) {\n\n        LOG.debug(\"write to {}: {}, blockGroup\u003d{}\",\n            datanode, Op.BLOCK_GROUP_CHECKSUM, blockGroup);\n\n        // get block group checksum\n        createSender(pair).blockGroupChecksum(\n            stripedBlockInfo,\n            blockGroup.getBlockToken(),\n            requestedNumBytes,\n            new BlockChecksumOptions(getBlockChecksumType()));\n\n        BlockOpResponseProto reply \u003d BlockOpResponseProto.parseFrom(\n            PBHelperClient.vintPrefixed(pair.in));\n\n        String logInfo \u003d \"for blockGroup \" + blockGroup +\n            \" from datanode \" + datanode;\n        DataTransferProtoUtil.checkBlockOpStatus(reply, logInfo);\n\n        OpBlockChecksumResponseProto checksumData \u003d reply.getChecksumResponse();\n        extractChecksumProperties(checksumData, blockGroup, datanode, bgIdx);\n        String blockChecksumForDebug \u003d populateBlockChecksumBuf(checksumData);\n        LOG.debug(\"got reply from {}: blockChecksum\u003d{}, blockChecksumType\u003d{}\",\n            datanode, blockChecksumForDebug, getBlockChecksumType());\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/FileChecksumHelper.java",
      "extendedDetails": {}
    },
    "e6cb07520f935efde3e881de8f84ee7f6e0a746f": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-10460. Recompute block checksum for a particular range less than file size on the fly by reconstructing missed block. Contributed by Rakesh R\n",
      "commitDate": "24/06/16 2:39 AM",
      "commitName": "e6cb07520f935efde3e881de8f84ee7f6e0a746f",
      "commitAuthor": "Kai Zheng",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-10460. Recompute block checksum for a particular range less than file size on the fly by reconstructing missed block. Contributed by Rakesh R\n",
          "commitDate": "24/06/16 2:39 AM",
          "commitName": "e6cb07520f935efde3e881de8f84ee7f6e0a746f",
          "commitAuthor": "Kai Zheng",
          "commitDateOld": "01/06/16 9:56 PM",
          "commitNameOld": "d749cf65e1ab0e0daf5be86931507183f189e855",
          "commitAuthorOld": "Kai Zheng",
          "daysBetweenCommits": 22.2,
          "commitsBetweenForRepo": 141,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,72 +1,73 @@\n     private void tryDatanode(LocatedStripedBlock blockGroup,\n                              StripedBlockInfo stripedBlockInfo,\n-                             DatanodeInfo datanode) throws IOException {\n+                             DatanodeInfo datanode,\n+                             long requestedNumBytes) throws IOException {\n \n       try (IOStreamPair pair \u003d getClient().connectToDN(datanode,\n           getTimeout(), blockGroup.getBlockToken())) {\n \n         LOG.debug(\"write to {}: {}, blockGroup\u003d{}\",\n             datanode, Op.BLOCK_GROUP_CHECKSUM, blockGroup);\n \n         // get block MD5\n         createSender(pair).blockGroupChecksum(stripedBlockInfo,\n-            blockGroup.getBlockToken());\n+            blockGroup.getBlockToken(), requestedNumBytes);\n \n         BlockOpResponseProto reply \u003d BlockOpResponseProto.parseFrom(\n             PBHelperClient.vintPrefixed(pair.in));\n \n         String logInfo \u003d \"for blockGroup \" + blockGroup +\n             \" from datanode \" + datanode;\n         DataTransferProtoUtil.checkBlockOpStatus(reply, logInfo);\n \n         OpBlockChecksumResponseProto checksumData \u003d reply.getChecksumResponse();\n \n         //read byte-per-checksum\n         final int bpc \u003d checksumData.getBytesPerCrc();\n         if (bgIdx \u003d\u003d 0) { //first block\n           setBytesPerCRC(bpc);\n         } else {\n           if (bpc !\u003d getBytesPerCRC()) {\n             throw new IOException(\"Byte-per-checksum not matched: bpc\u003d\" + bpc\n                 + \" but bytesPerCRC\u003d\" + getBytesPerCRC());\n           }\n         }\n \n         //read crc-per-block\n         final long cpb \u003d checksumData.getCrcPerBlock();\n         if (getLocatedBlocks().size() \u003e 1 \u0026\u0026 bgIdx \u003d\u003d 0) { // first block\n           setCrcPerBlock(cpb);\n         }\n \n         //read md5\n         final MD5Hash md5 \u003d new MD5Hash(\n             checksumData.getMd5().toByteArray());\n         md5.write(getMd5out());\n \n         // read crc-type\n         final DataChecksum.Type ct;\n         if (checksumData.hasCrcType()) {\n           ct \u003d PBHelperClient.convert(checksumData.getCrcType());\n         } else {\n           LOG.debug(\"Retrieving checksum from an earlier-version DataNode: \" +\n               \"inferring checksum by reading first byte\");\n           ct \u003d getClient().inferChecksumTypeByReading(blockGroup, datanode);\n         }\n \n         if (bgIdx \u003d\u003d 0) {\n           setCrcType(ct);\n         } else if (getCrcType() !\u003d DataChecksum.Type.MIXED \u0026\u0026\n             getCrcType() !\u003d ct) {\n           // if crc types are mixed in a file\n           setCrcType(DataChecksum.Type.MIXED);\n         }\n \n         if (LOG.isDebugEnabled()) {\n           if (bgIdx \u003d\u003d 0) {\n             LOG.debug(\"set bytesPerCRC\u003d\" + getBytesPerCRC()\n                 + \", crcPerBlock\u003d\" + getCrcPerBlock());\n           }\n           LOG.debug(\"got reply from \" + datanode + \": md5\u003d\" + md5);\n         }\n       }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private void tryDatanode(LocatedStripedBlock blockGroup,\n                             StripedBlockInfo stripedBlockInfo,\n                             DatanodeInfo datanode,\n                             long requestedNumBytes) throws IOException {\n\n      try (IOStreamPair pair \u003d getClient().connectToDN(datanode,\n          getTimeout(), blockGroup.getBlockToken())) {\n\n        LOG.debug(\"write to {}: {}, blockGroup\u003d{}\",\n            datanode, Op.BLOCK_GROUP_CHECKSUM, blockGroup);\n\n        // get block MD5\n        createSender(pair).blockGroupChecksum(stripedBlockInfo,\n            blockGroup.getBlockToken(), requestedNumBytes);\n\n        BlockOpResponseProto reply \u003d BlockOpResponseProto.parseFrom(\n            PBHelperClient.vintPrefixed(pair.in));\n\n        String logInfo \u003d \"for blockGroup \" + blockGroup +\n            \" from datanode \" + datanode;\n        DataTransferProtoUtil.checkBlockOpStatus(reply, logInfo);\n\n        OpBlockChecksumResponseProto checksumData \u003d reply.getChecksumResponse();\n\n        //read byte-per-checksum\n        final int bpc \u003d checksumData.getBytesPerCrc();\n        if (bgIdx \u003d\u003d 0) { //first block\n          setBytesPerCRC(bpc);\n        } else {\n          if (bpc !\u003d getBytesPerCRC()) {\n            throw new IOException(\"Byte-per-checksum not matched: bpc\u003d\" + bpc\n                + \" but bytesPerCRC\u003d\" + getBytesPerCRC());\n          }\n        }\n\n        //read crc-per-block\n        final long cpb \u003d checksumData.getCrcPerBlock();\n        if (getLocatedBlocks().size() \u003e 1 \u0026\u0026 bgIdx \u003d\u003d 0) { // first block\n          setCrcPerBlock(cpb);\n        }\n\n        //read md5\n        final MD5Hash md5 \u003d new MD5Hash(\n            checksumData.getMd5().toByteArray());\n        md5.write(getMd5out());\n\n        // read crc-type\n        final DataChecksum.Type ct;\n        if (checksumData.hasCrcType()) {\n          ct \u003d PBHelperClient.convert(checksumData.getCrcType());\n        } else {\n          LOG.debug(\"Retrieving checksum from an earlier-version DataNode: \" +\n              \"inferring checksum by reading first byte\");\n          ct \u003d getClient().inferChecksumTypeByReading(blockGroup, datanode);\n        }\n\n        if (bgIdx \u003d\u003d 0) {\n          setCrcType(ct);\n        } else if (getCrcType() !\u003d DataChecksum.Type.MIXED \u0026\u0026\n            getCrcType() !\u003d ct) {\n          // if crc types are mixed in a file\n          setCrcType(DataChecksum.Type.MIXED);\n        }\n\n        if (LOG.isDebugEnabled()) {\n          if (bgIdx \u003d\u003d 0) {\n            LOG.debug(\"set bytesPerCRC\u003d\" + getBytesPerCRC()\n                + \", crcPerBlock\u003d\" + getCrcPerBlock());\n          }\n          LOG.debug(\"got reply from \" + datanode + \": md5\u003d\" + md5);\n        }\n      }\n    }",
          "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/FileChecksumHelper.java",
          "extendedDetails": {
            "oldValue": "[blockGroup-LocatedStripedBlock, stripedBlockInfo-StripedBlockInfo, datanode-DatanodeInfo]",
            "newValue": "[blockGroup-LocatedStripedBlock, stripedBlockInfo-StripedBlockInfo, datanode-DatanodeInfo, requestedNumBytes-long]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-10460. Recompute block checksum for a particular range less than file size on the fly by reconstructing missed block. Contributed by Rakesh R\n",
          "commitDate": "24/06/16 2:39 AM",
          "commitName": "e6cb07520f935efde3e881de8f84ee7f6e0a746f",
          "commitAuthor": "Kai Zheng",
          "commitDateOld": "01/06/16 9:56 PM",
          "commitNameOld": "d749cf65e1ab0e0daf5be86931507183f189e855",
          "commitAuthorOld": "Kai Zheng",
          "daysBetweenCommits": 22.2,
          "commitsBetweenForRepo": 141,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,72 +1,73 @@\n     private void tryDatanode(LocatedStripedBlock blockGroup,\n                              StripedBlockInfo stripedBlockInfo,\n-                             DatanodeInfo datanode) throws IOException {\n+                             DatanodeInfo datanode,\n+                             long requestedNumBytes) throws IOException {\n \n       try (IOStreamPair pair \u003d getClient().connectToDN(datanode,\n           getTimeout(), blockGroup.getBlockToken())) {\n \n         LOG.debug(\"write to {}: {}, blockGroup\u003d{}\",\n             datanode, Op.BLOCK_GROUP_CHECKSUM, blockGroup);\n \n         // get block MD5\n         createSender(pair).blockGroupChecksum(stripedBlockInfo,\n-            blockGroup.getBlockToken());\n+            blockGroup.getBlockToken(), requestedNumBytes);\n \n         BlockOpResponseProto reply \u003d BlockOpResponseProto.parseFrom(\n             PBHelperClient.vintPrefixed(pair.in));\n \n         String logInfo \u003d \"for blockGroup \" + blockGroup +\n             \" from datanode \" + datanode;\n         DataTransferProtoUtil.checkBlockOpStatus(reply, logInfo);\n \n         OpBlockChecksumResponseProto checksumData \u003d reply.getChecksumResponse();\n \n         //read byte-per-checksum\n         final int bpc \u003d checksumData.getBytesPerCrc();\n         if (bgIdx \u003d\u003d 0) { //first block\n           setBytesPerCRC(bpc);\n         } else {\n           if (bpc !\u003d getBytesPerCRC()) {\n             throw new IOException(\"Byte-per-checksum not matched: bpc\u003d\" + bpc\n                 + \" but bytesPerCRC\u003d\" + getBytesPerCRC());\n           }\n         }\n \n         //read crc-per-block\n         final long cpb \u003d checksumData.getCrcPerBlock();\n         if (getLocatedBlocks().size() \u003e 1 \u0026\u0026 bgIdx \u003d\u003d 0) { // first block\n           setCrcPerBlock(cpb);\n         }\n \n         //read md5\n         final MD5Hash md5 \u003d new MD5Hash(\n             checksumData.getMd5().toByteArray());\n         md5.write(getMd5out());\n \n         // read crc-type\n         final DataChecksum.Type ct;\n         if (checksumData.hasCrcType()) {\n           ct \u003d PBHelperClient.convert(checksumData.getCrcType());\n         } else {\n           LOG.debug(\"Retrieving checksum from an earlier-version DataNode: \" +\n               \"inferring checksum by reading first byte\");\n           ct \u003d getClient().inferChecksumTypeByReading(blockGroup, datanode);\n         }\n \n         if (bgIdx \u003d\u003d 0) {\n           setCrcType(ct);\n         } else if (getCrcType() !\u003d DataChecksum.Type.MIXED \u0026\u0026\n             getCrcType() !\u003d ct) {\n           // if crc types are mixed in a file\n           setCrcType(DataChecksum.Type.MIXED);\n         }\n \n         if (LOG.isDebugEnabled()) {\n           if (bgIdx \u003d\u003d 0) {\n             LOG.debug(\"set bytesPerCRC\u003d\" + getBytesPerCRC()\n                 + \", crcPerBlock\u003d\" + getCrcPerBlock());\n           }\n           LOG.debug(\"got reply from \" + datanode + \": md5\u003d\" + md5);\n         }\n       }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private void tryDatanode(LocatedStripedBlock blockGroup,\n                             StripedBlockInfo stripedBlockInfo,\n                             DatanodeInfo datanode,\n                             long requestedNumBytes) throws IOException {\n\n      try (IOStreamPair pair \u003d getClient().connectToDN(datanode,\n          getTimeout(), blockGroup.getBlockToken())) {\n\n        LOG.debug(\"write to {}: {}, blockGroup\u003d{}\",\n            datanode, Op.BLOCK_GROUP_CHECKSUM, blockGroup);\n\n        // get block MD5\n        createSender(pair).blockGroupChecksum(stripedBlockInfo,\n            blockGroup.getBlockToken(), requestedNumBytes);\n\n        BlockOpResponseProto reply \u003d BlockOpResponseProto.parseFrom(\n            PBHelperClient.vintPrefixed(pair.in));\n\n        String logInfo \u003d \"for blockGroup \" + blockGroup +\n            \" from datanode \" + datanode;\n        DataTransferProtoUtil.checkBlockOpStatus(reply, logInfo);\n\n        OpBlockChecksumResponseProto checksumData \u003d reply.getChecksumResponse();\n\n        //read byte-per-checksum\n        final int bpc \u003d checksumData.getBytesPerCrc();\n        if (bgIdx \u003d\u003d 0) { //first block\n          setBytesPerCRC(bpc);\n        } else {\n          if (bpc !\u003d getBytesPerCRC()) {\n            throw new IOException(\"Byte-per-checksum not matched: bpc\u003d\" + bpc\n                + \" but bytesPerCRC\u003d\" + getBytesPerCRC());\n          }\n        }\n\n        //read crc-per-block\n        final long cpb \u003d checksumData.getCrcPerBlock();\n        if (getLocatedBlocks().size() \u003e 1 \u0026\u0026 bgIdx \u003d\u003d 0) { // first block\n          setCrcPerBlock(cpb);\n        }\n\n        //read md5\n        final MD5Hash md5 \u003d new MD5Hash(\n            checksumData.getMd5().toByteArray());\n        md5.write(getMd5out());\n\n        // read crc-type\n        final DataChecksum.Type ct;\n        if (checksumData.hasCrcType()) {\n          ct \u003d PBHelperClient.convert(checksumData.getCrcType());\n        } else {\n          LOG.debug(\"Retrieving checksum from an earlier-version DataNode: \" +\n              \"inferring checksum by reading first byte\");\n          ct \u003d getClient().inferChecksumTypeByReading(blockGroup, datanode);\n        }\n\n        if (bgIdx \u003d\u003d 0) {\n          setCrcType(ct);\n        } else if (getCrcType() !\u003d DataChecksum.Type.MIXED \u0026\u0026\n            getCrcType() !\u003d ct) {\n          // if crc types are mixed in a file\n          setCrcType(DataChecksum.Type.MIXED);\n        }\n\n        if (LOG.isDebugEnabled()) {\n          if (bgIdx \u003d\u003d 0) {\n            LOG.debug(\"set bytesPerCRC\u003d\" + getBytesPerCRC()\n                + \", crcPerBlock\u003d\" + getCrcPerBlock());\n          }\n          LOG.debug(\"got reply from \" + datanode + \": md5\u003d\" + md5);\n        }\n      }\n    }",
          "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/FileChecksumHelper.java",
          "extendedDetails": {}
        }
      ]
    },
    "3a4ff7776e8fab6cc87932b9aa8fb48f7b69c720": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-9694. Make existing DFSClient#getFileChecksum() work for striped blocks. Contributed by Kai Zheng\n",
      "commitDate": "26/03/16 7:58 PM",
      "commitName": "3a4ff7776e8fab6cc87932b9aa8fb48f7b69c720",
      "commitAuthor": "Uma Maheswara Rao G",
      "diff": "@@ -0,0 +1,72 @@\n+    private void tryDatanode(LocatedStripedBlock blockGroup,\n+                             StripedBlockInfo stripedBlockInfo,\n+                             DatanodeInfo datanode) throws IOException {\n+\n+      try (IOStreamPair pair \u003d getClient().connectToDN(datanode,\n+          getTimeout(), blockGroup.getBlockToken())) {\n+\n+        LOG.debug(\"write to {}: {}, blockGroup\u003d{}\",\n+            datanode, Op.BLOCK_GROUP_CHECKSUM, blockGroup);\n+\n+        // get block MD5\n+        createSender(pair).blockGroupChecksum(stripedBlockInfo,\n+            blockGroup.getBlockToken());\n+\n+        BlockOpResponseProto reply \u003d BlockOpResponseProto.parseFrom(\n+            PBHelperClient.vintPrefixed(pair.in));\n+\n+        String logInfo \u003d \"for blockGroup \" + blockGroup +\n+            \" from datanode \" + datanode;\n+        DataTransferProtoUtil.checkBlockOpStatus(reply, logInfo);\n+\n+        OpBlockChecksumResponseProto checksumData \u003d reply.getChecksumResponse();\n+\n+        //read byte-per-checksum\n+        final int bpc \u003d checksumData.getBytesPerCrc();\n+        if (bgIdx \u003d\u003d 0) { //first block\n+          setBytesPerCRC(bpc);\n+        } else {\n+          if (bpc !\u003d getBytesPerCRC()) {\n+            throw new IOException(\"Byte-per-checksum not matched: bpc\u003d\" + bpc\n+                + \" but bytesPerCRC\u003d\" + getBytesPerCRC());\n+          }\n+        }\n+\n+        //read crc-per-block\n+        final long cpb \u003d checksumData.getCrcPerBlock();\n+        if (getLocatedBlocks().size() \u003e 1 \u0026\u0026 bgIdx \u003d\u003d 0) { // first block\n+          setCrcPerBlock(cpb);\n+        }\n+\n+        //read md5\n+        final MD5Hash md5 \u003d new MD5Hash(\n+            checksumData.getMd5().toByteArray());\n+        md5.write(getMd5out());\n+\n+        // read crc-type\n+        final DataChecksum.Type ct;\n+        if (checksumData.hasCrcType()) {\n+          ct \u003d PBHelperClient.convert(checksumData.getCrcType());\n+        } else {\n+          LOG.debug(\"Retrieving checksum from an earlier-version DataNode: \" +\n+              \"inferring checksum by reading first byte\");\n+          ct \u003d getClient().inferChecksumTypeByReading(blockGroup, datanode);\n+        }\n+\n+        if (bgIdx \u003d\u003d 0) {\n+          setCrcType(ct);\n+        } else if (getCrcType() !\u003d DataChecksum.Type.MIXED \u0026\u0026\n+            getCrcType() !\u003d ct) {\n+          // if crc types are mixed in a file\n+          setCrcType(DataChecksum.Type.MIXED);\n+        }\n+\n+        if (LOG.isDebugEnabled()) {\n+          if (bgIdx \u003d\u003d 0) {\n+            LOG.debug(\"set bytesPerCRC\u003d\" + getBytesPerCRC()\n+                + \", crcPerBlock\u003d\" + getCrcPerBlock());\n+          }\n+          LOG.debug(\"got reply from \" + datanode + \": md5\u003d\" + md5);\n+        }\n+      }\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    private void tryDatanode(LocatedStripedBlock blockGroup,\n                             StripedBlockInfo stripedBlockInfo,\n                             DatanodeInfo datanode) throws IOException {\n\n      try (IOStreamPair pair \u003d getClient().connectToDN(datanode,\n          getTimeout(), blockGroup.getBlockToken())) {\n\n        LOG.debug(\"write to {}: {}, blockGroup\u003d{}\",\n            datanode, Op.BLOCK_GROUP_CHECKSUM, blockGroup);\n\n        // get block MD5\n        createSender(pair).blockGroupChecksum(stripedBlockInfo,\n            blockGroup.getBlockToken());\n\n        BlockOpResponseProto reply \u003d BlockOpResponseProto.parseFrom(\n            PBHelperClient.vintPrefixed(pair.in));\n\n        String logInfo \u003d \"for blockGroup \" + blockGroup +\n            \" from datanode \" + datanode;\n        DataTransferProtoUtil.checkBlockOpStatus(reply, logInfo);\n\n        OpBlockChecksumResponseProto checksumData \u003d reply.getChecksumResponse();\n\n        //read byte-per-checksum\n        final int bpc \u003d checksumData.getBytesPerCrc();\n        if (bgIdx \u003d\u003d 0) { //first block\n          setBytesPerCRC(bpc);\n        } else {\n          if (bpc !\u003d getBytesPerCRC()) {\n            throw new IOException(\"Byte-per-checksum not matched: bpc\u003d\" + bpc\n                + \" but bytesPerCRC\u003d\" + getBytesPerCRC());\n          }\n        }\n\n        //read crc-per-block\n        final long cpb \u003d checksumData.getCrcPerBlock();\n        if (getLocatedBlocks().size() \u003e 1 \u0026\u0026 bgIdx \u003d\u003d 0) { // first block\n          setCrcPerBlock(cpb);\n        }\n\n        //read md5\n        final MD5Hash md5 \u003d new MD5Hash(\n            checksumData.getMd5().toByteArray());\n        md5.write(getMd5out());\n\n        // read crc-type\n        final DataChecksum.Type ct;\n        if (checksumData.hasCrcType()) {\n          ct \u003d PBHelperClient.convert(checksumData.getCrcType());\n        } else {\n          LOG.debug(\"Retrieving checksum from an earlier-version DataNode: \" +\n              \"inferring checksum by reading first byte\");\n          ct \u003d getClient().inferChecksumTypeByReading(blockGroup, datanode);\n        }\n\n        if (bgIdx \u003d\u003d 0) {\n          setCrcType(ct);\n        } else if (getCrcType() !\u003d DataChecksum.Type.MIXED \u0026\u0026\n            getCrcType() !\u003d ct) {\n          // if crc types are mixed in a file\n          setCrcType(DataChecksum.Type.MIXED);\n        }\n\n        if (LOG.isDebugEnabled()) {\n          if (bgIdx \u003d\u003d 0) {\n            LOG.debug(\"set bytesPerCRC\u003d\" + getBytesPerCRC()\n                + \", crcPerBlock\u003d\" + getCrcPerBlock());\n          }\n          LOG.debug(\"got reply from \" + datanode + \": md5\u003d\" + md5);\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/FileChecksumHelper.java"
    }
  }
}