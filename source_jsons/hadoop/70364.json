{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "NativeAzureFileSystem.java",
  "functionName": "deleteWithoutAuth",
  "functionId": "deleteWithoutAuth___f-Path__recursive-boolean__skipParentFolderLastModifiedTimeUpdate-boolean",
  "sourceFilePath": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
  "functionStartLine": 2182,
  "functionEndLine": 2415,
  "numCommitsSeen": 66,
  "timeTaken": 1860,
  "changeHistory": [
    "45d9568aaaf532a6da11bd7c1844ff81bf66bab1",
    "a530e7ab3b3f5bd71143a91266b46787962ac532"
  ],
  "changeHistoryShort": {
    "45d9568aaaf532a6da11bd7c1844ff81bf66bab1": "Ybodychange",
    "a530e7ab3b3f5bd71143a91266b46787962ac532": "Yintroduced"
  },
  "changeHistoryDetails": {
    "45d9568aaaf532a6da11bd7c1844ff81bf66bab1": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15547/ WASB: improve listStatus performance.\nContributed by Thomas Marquardt.\n\n(cherry picked from commit 749fff577ed9afb4ef8a54b8948f74be083cc620)\n",
      "commitDate": "19/07/18 12:31 PM",
      "commitName": "45d9568aaaf532a6da11bd7c1844ff81bf66bab1",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "27/06/18 10:37 PM",
      "commitNameOld": "2b2399d623539ab68e71a38fa9fbfc9a405bddb8",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 21.58,
      "commitsBetweenForRepo": 124,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,245 +1,234 @@\n   private boolean deleteWithoutAuth(Path f, boolean recursive,\n       boolean skipParentFolderLastModifiedTimeUpdate) throws IOException {\n \n     LOG.debug(\"Deleting file: {}\", f);\n \n     Path absolutePath \u003d makeAbsolute(f);\n     Path parentPath \u003d absolutePath.getParent();\n \n     String key \u003d pathToKey(absolutePath);\n \n     // Capture the metadata for the path.\n     //\n     FileMetadata metaFile \u003d null;\n     try {\n       metaFile \u003d store.retrieveMetadata(key);\n     } catch (IOException e) {\n \n       Throwable innerException \u003d checkForAzureStorageException(e);\n \n       if (innerException instanceof StorageException\n           \u0026\u0026 isFileNotFoundException((StorageException) innerException)) {\n \n         return false;\n       }\n       throw e;\n     }\n \n     if (null \u003d\u003d metaFile) {\n       // The path to be deleted does not exist.\n       return false;\n     }\n \n     // The path exists, determine if it is a folder containing objects,\n     // an empty folder, or a simple file and take the appropriate actions.\n-    if (!metaFile.isDir()) {\n+    if (!metaFile.isDirectory()) {\n       // The path specifies a file. We need to check the parent path\n       // to make sure it\u0027s a proper materialized directory before we\n       // delete the file. Otherwise we may get into a situation where\n       // the file we were deleting was the last one in an implicit directory\n       // (e.g. the blob store only contains the blob a/b and there\u0027s no\n       // corresponding directory blob a) and that would implicitly delete\n       // the directory as well, which is not correct.\n \n       if (parentPath.getParent() !\u003d null) {// Not root\n         String parentKey \u003d pathToKey(parentPath);\n \n         FileMetadata parentMetadata \u003d null;\n         try {\n           parentMetadata \u003d store.retrieveMetadata(parentKey);\n         } catch (IOException e) {\n \n           Throwable innerException \u003d checkForAzureStorageException(e);\n \n           if (innerException instanceof StorageException) {\n             // Invalid State.\n             // A FileNotFoundException is not thrown here as the API returns false\n             // if the file not present. But not retrieving metadata here is an\n             // unrecoverable state and can only happen if there is a race condition\n             // hence throwing a IOException\n             if (isFileNotFoundException((StorageException) innerException)) {\n               throw new IOException(\"File \" + f + \" has a parent directory \"\n                   + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n             }\n           }\n           throw e;\n         }\n \n         // Invalid State.\n         // A FileNotFoundException is not thrown here as the API returns false\n         // if the file not present. But not retrieving metadata here is an\n         // unrecoverable state and can only happen if there is a race condition\n         // hence throwing a IOException\n         if (parentMetadata \u003d\u003d null) {\n           throw new IOException(\"File \" + f + \" has a parent directory \"\n               + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n         }\n \n-        if (!parentMetadata.isDir()) {\n+        if (!parentMetadata.isDirectory()) {\n           // Invalid state: the parent path is actually a file. Throw.\n           throw new AzureException(\"File \" + f + \" has a parent directory \"\n               + parentPath + \" which is also a file. Can\u0027t resolve.\");\n         }\n \n         if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n           LOG.debug(\"Found an implicit parent directory while trying to\"\n               + \" delete the file {}. Creating the directory blob for\"\n               + \" it in {}.\", f, parentKey);\n \n           store.storeEmptyFolder(parentKey,\n               createPermissionStatus(FsPermission.getDefault()));\n         } else {\n           if (!skipParentFolderLastModifiedTimeUpdate) {\n             updateParentFolderLastModifiedTime(key);\n           }\n         }\n       }\n \n       try {\n         if (store.delete(key)) {\n           instrumentation.fileDeleted();\n         } else {\n           return false;\n         }\n       } catch(IOException e) {\n \n         Throwable innerException \u003d checkForAzureStorageException(e);\n \n         if (innerException instanceof StorageException\n             \u0026\u0026 isFileNotFoundException((StorageException) innerException)) {\n           return false;\n         }\n \n        throw e;\n       }\n     } else {\n       // The path specifies a folder. Recursively delete all entries under the\n       // folder.\n       LOG.debug(\"Directory Delete encountered: {}\", f);\n       if (parentPath.getParent() !\u003d null) {\n         String parentKey \u003d pathToKey(parentPath);\n         FileMetadata parentMetadata \u003d null;\n \n         try {\n           parentMetadata \u003d store.retrieveMetadata(parentKey);\n         } catch (IOException e) {\n \n           Throwable innerException \u003d checkForAzureStorageException(e);\n \n           if (innerException instanceof StorageException) {\n             // Invalid State.\n             // A FileNotFoundException is not thrown here as the API returns false\n             // if the file not present. But not retrieving metadata here is an\n             // unrecoverable state and can only happen if there is a race condition\n             // hence throwing a IOException\n             if (isFileNotFoundException((StorageException) innerException)) {\n               throw new IOException(\"File \" + f + \" has a parent directory \"\n                   + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n             }\n           }\n           throw e;\n         }\n \n         // Invalid State.\n         // A FileNotFoundException is not thrown here as the API returns false\n         // if the file not present. But not retrieving metadata here is an\n         // unrecoverable state and can only happen if there is a race condition\n         // hence throwing a IOException\n         if (parentMetadata \u003d\u003d null) {\n           throw new IOException(\"File \" + f + \" has a parent directory \"\n               + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n         }\n \n         if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n           LOG.debug(\"Found an implicit parent directory while trying to\"\n               + \" delete the directory {}. Creating the directory blob for\"\n               + \" it in {}. \", f, parentKey);\n \n           store.storeEmptyFolder(parentKey,\n               createPermissionStatus(FsPermission.getDefault()));\n         }\n       }\n \n-      // List all the blobs in the current folder.\n-      String priorLastKey \u003d null;\n-\n       // Start time for list operation\n       long start \u003d Time.monotonicNow();\n-      ArrayList\u003cFileMetadata\u003e fileMetadataList \u003d new ArrayList\u003cFileMetadata\u003e();\n+      final FileMetadata[] contents;\n \n       // List all the files in the folder with AZURE_UNBOUNDED_DEPTH depth.\n-      do {\n-        try {\n-          PartialListing listing \u003d store.listAll(key, AZURE_LIST_ALL,\n-            AZURE_UNBOUNDED_DEPTH, priorLastKey);\n-          for(FileMetadata file : listing.getFiles()) {\n-            fileMetadataList.add(file);\n-          }\n-          priorLastKey \u003d listing.getPriorLastKey();\n-        } catch (IOException e) {\n-          Throwable innerException \u003d checkForAzureStorageException(e);\n+      try {\n+        contents \u003d store.list(key, AZURE_LIST_ALL,\n+            AZURE_UNBOUNDED_DEPTH);\n+      } catch (IOException e) {\n+        Throwable innerException \u003d checkForAzureStorageException(e);\n \n-          if (innerException instanceof StorageException\n-              \u0026\u0026 isFileNotFoundException((StorageException) innerException)) {\n-            return false;\n-          }\n-\n-          throw e;\n+        if (innerException instanceof StorageException\n+            \u0026\u0026 isFileNotFoundException((StorageException) innerException)) {\n+          return false;\n         }\n-      } while (priorLastKey !\u003d null);\n+\n+        throw e;\n+      }\n \n       long end \u003d Time.monotonicNow();\n-      LOG.debug(\"Time taken to list {} blobs for delete operation: {} ms\", fileMetadataList.size(), (end - start));\n-\n-      final FileMetadata[] contents \u003d fileMetadataList.toArray(new FileMetadata[fileMetadataList.size()]);\n+      LOG.debug(\"Time taken to list {} blobs for delete operation: {} ms\", contents.length, (end - start));\n \n       if (contents.length \u003e 0) {\n         if (!recursive) {\n           // The folder is non-empty and recursive delete was not specified.\n           // Throw an exception indicating that a non-recursive delete was\n           // specified for a non-empty folder.\n           throw new IOException(\"Non-recursive delete of non-empty directory \"+ f);\n         }\n       }\n \n       // Delete all files / folders in current directory stored as list in \u0027contents\u0027.\n       AzureFileSystemThreadTask task \u003d new AzureFileSystemThreadTask() {\n         @Override\n         public boolean execute(FileMetadata file) throws IOException{\n-          if (!deleteFile(file.getKey(), file.isDir())) {\n+          if (!deleteFile(file.getKey(), file.isDirectory())) {\n             LOG.warn(\"Attempt to delete non-existent {} {}\",\n-                file.isDir() ? \"directory\" : \"file\",\n+                file.isDirectory() ? \"directory\" : \"file\",\n                 file.getKey());\n           }\n           return true;\n         }\n       };\n \n       AzureFileSystemThreadPoolExecutor executor \u003d getThreadPoolExecutor(this.deleteThreadCount,\n           \"AzureBlobDeleteThread\", \"Delete\", key, AZURE_DELETE_THREADS);\n \n       if (!executor.executeParallel(contents, task)) {\n         LOG.error(\"Failed to delete files / subfolders in blob {}\", key);\n         return false;\n       }\n \n       // Delete the current directory\n       if (store.retrieveMetadata(metaFile.getKey()) !\u003d null\n-          \u0026\u0026 !deleteFile(metaFile.getKey(), metaFile.isDir())) {\n+          \u0026\u0026 !deleteFile(metaFile.getKey(), metaFile.isDirectory())) {\n         LOG.error(\"Failed delete directory : {}\", f);\n         return false;\n       }\n \n       // Update parent directory last modified time\n       Path parent \u003d absolutePath.getParent();\n       if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) { // not root\n         if (!skipParentFolderLastModifiedTimeUpdate) {\n           updateParentFolderLastModifiedTime(key);\n         }\n       }\n     }\n \n     // File or directory was successfully deleted.\n     LOG.debug(\"Delete Successful for : {}\", f);\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean deleteWithoutAuth(Path f, boolean recursive,\n      boolean skipParentFolderLastModifiedTimeUpdate) throws IOException {\n\n    LOG.debug(\"Deleting file: {}\", f);\n\n    Path absolutePath \u003d makeAbsolute(f);\n    Path parentPath \u003d absolutePath.getParent();\n\n    String key \u003d pathToKey(absolutePath);\n\n    // Capture the metadata for the path.\n    //\n    FileMetadata metaFile \u003d null;\n    try {\n      metaFile \u003d store.retrieveMetadata(key);\n    } catch (IOException e) {\n\n      Throwable innerException \u003d checkForAzureStorageException(e);\n\n      if (innerException instanceof StorageException\n          \u0026\u0026 isFileNotFoundException((StorageException) innerException)) {\n\n        return false;\n      }\n      throw e;\n    }\n\n    if (null \u003d\u003d metaFile) {\n      // The path to be deleted does not exist.\n      return false;\n    }\n\n    // The path exists, determine if it is a folder containing objects,\n    // an empty folder, or a simple file and take the appropriate actions.\n    if (!metaFile.isDirectory()) {\n      // The path specifies a file. We need to check the parent path\n      // to make sure it\u0027s a proper materialized directory before we\n      // delete the file. Otherwise we may get into a situation where\n      // the file we were deleting was the last one in an implicit directory\n      // (e.g. the blob store only contains the blob a/b and there\u0027s no\n      // corresponding directory blob a) and that would implicitly delete\n      // the directory as well, which is not correct.\n\n      if (parentPath.getParent() !\u003d null) {// Not root\n        String parentKey \u003d pathToKey(parentPath);\n\n        FileMetadata parentMetadata \u003d null;\n        try {\n          parentMetadata \u003d store.retrieveMetadata(parentKey);\n        } catch (IOException e) {\n\n          Throwable innerException \u003d checkForAzureStorageException(e);\n\n          if (innerException instanceof StorageException) {\n            // Invalid State.\n            // A FileNotFoundException is not thrown here as the API returns false\n            // if the file not present. But not retrieving metadata here is an\n            // unrecoverable state and can only happen if there is a race condition\n            // hence throwing a IOException\n            if (isFileNotFoundException((StorageException) innerException)) {\n              throw new IOException(\"File \" + f + \" has a parent directory \"\n                  + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n            }\n          }\n          throw e;\n        }\n\n        // Invalid State.\n        // A FileNotFoundException is not thrown here as the API returns false\n        // if the file not present. But not retrieving metadata here is an\n        // unrecoverable state and can only happen if there is a race condition\n        // hence throwing a IOException\n        if (parentMetadata \u003d\u003d null) {\n          throw new IOException(\"File \" + f + \" has a parent directory \"\n              + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n        }\n\n        if (!parentMetadata.isDirectory()) {\n          // Invalid state: the parent path is actually a file. Throw.\n          throw new AzureException(\"File \" + f + \" has a parent directory \"\n              + parentPath + \" which is also a file. Can\u0027t resolve.\");\n        }\n\n        if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n          LOG.debug(\"Found an implicit parent directory while trying to\"\n              + \" delete the file {}. Creating the directory blob for\"\n              + \" it in {}.\", f, parentKey);\n\n          store.storeEmptyFolder(parentKey,\n              createPermissionStatus(FsPermission.getDefault()));\n        } else {\n          if (!skipParentFolderLastModifiedTimeUpdate) {\n            updateParentFolderLastModifiedTime(key);\n          }\n        }\n      }\n\n      try {\n        if (store.delete(key)) {\n          instrumentation.fileDeleted();\n        } else {\n          return false;\n        }\n      } catch(IOException e) {\n\n        Throwable innerException \u003d checkForAzureStorageException(e);\n\n        if (innerException instanceof StorageException\n            \u0026\u0026 isFileNotFoundException((StorageException) innerException)) {\n          return false;\n        }\n\n       throw e;\n      }\n    } else {\n      // The path specifies a folder. Recursively delete all entries under the\n      // folder.\n      LOG.debug(\"Directory Delete encountered: {}\", f);\n      if (parentPath.getParent() !\u003d null) {\n        String parentKey \u003d pathToKey(parentPath);\n        FileMetadata parentMetadata \u003d null;\n\n        try {\n          parentMetadata \u003d store.retrieveMetadata(parentKey);\n        } catch (IOException e) {\n\n          Throwable innerException \u003d checkForAzureStorageException(e);\n\n          if (innerException instanceof StorageException) {\n            // Invalid State.\n            // A FileNotFoundException is not thrown here as the API returns false\n            // if the file not present. But not retrieving metadata here is an\n            // unrecoverable state and can only happen if there is a race condition\n            // hence throwing a IOException\n            if (isFileNotFoundException((StorageException) innerException)) {\n              throw new IOException(\"File \" + f + \" has a parent directory \"\n                  + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n            }\n          }\n          throw e;\n        }\n\n        // Invalid State.\n        // A FileNotFoundException is not thrown here as the API returns false\n        // if the file not present. But not retrieving metadata here is an\n        // unrecoverable state and can only happen if there is a race condition\n        // hence throwing a IOException\n        if (parentMetadata \u003d\u003d null) {\n          throw new IOException(\"File \" + f + \" has a parent directory \"\n              + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n        }\n\n        if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n          LOG.debug(\"Found an implicit parent directory while trying to\"\n              + \" delete the directory {}. Creating the directory blob for\"\n              + \" it in {}. \", f, parentKey);\n\n          store.storeEmptyFolder(parentKey,\n              createPermissionStatus(FsPermission.getDefault()));\n        }\n      }\n\n      // Start time for list operation\n      long start \u003d Time.monotonicNow();\n      final FileMetadata[] contents;\n\n      // List all the files in the folder with AZURE_UNBOUNDED_DEPTH depth.\n      try {\n        contents \u003d store.list(key, AZURE_LIST_ALL,\n            AZURE_UNBOUNDED_DEPTH);\n      } catch (IOException e) {\n        Throwable innerException \u003d checkForAzureStorageException(e);\n\n        if (innerException instanceof StorageException\n            \u0026\u0026 isFileNotFoundException((StorageException) innerException)) {\n          return false;\n        }\n\n        throw e;\n      }\n\n      long end \u003d Time.monotonicNow();\n      LOG.debug(\"Time taken to list {} blobs for delete operation: {} ms\", contents.length, (end - start));\n\n      if (contents.length \u003e 0) {\n        if (!recursive) {\n          // The folder is non-empty and recursive delete was not specified.\n          // Throw an exception indicating that a non-recursive delete was\n          // specified for a non-empty folder.\n          throw new IOException(\"Non-recursive delete of non-empty directory \"+ f);\n        }\n      }\n\n      // Delete all files / folders in current directory stored as list in \u0027contents\u0027.\n      AzureFileSystemThreadTask task \u003d new AzureFileSystemThreadTask() {\n        @Override\n        public boolean execute(FileMetadata file) throws IOException{\n          if (!deleteFile(file.getKey(), file.isDirectory())) {\n            LOG.warn(\"Attempt to delete non-existent {} {}\",\n                file.isDirectory() ? \"directory\" : \"file\",\n                file.getKey());\n          }\n          return true;\n        }\n      };\n\n      AzureFileSystemThreadPoolExecutor executor \u003d getThreadPoolExecutor(this.deleteThreadCount,\n          \"AzureBlobDeleteThread\", \"Delete\", key, AZURE_DELETE_THREADS);\n\n      if (!executor.executeParallel(contents, task)) {\n        LOG.error(\"Failed to delete files / subfolders in blob {}\", key);\n        return false;\n      }\n\n      // Delete the current directory\n      if (store.retrieveMetadata(metaFile.getKey()) !\u003d null\n          \u0026\u0026 !deleteFile(metaFile.getKey(), metaFile.isDirectory())) {\n        LOG.error(\"Failed delete directory : {}\", f);\n        return false;\n      }\n\n      // Update parent directory last modified time\n      Path parent \u003d absolutePath.getParent();\n      if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) { // not root\n        if (!skipParentFolderLastModifiedTimeUpdate) {\n          updateParentFolderLastModifiedTime(key);\n        }\n      }\n    }\n\n    // File or directory was successfully deleted.\n    LOG.debug(\"Delete Successful for : {}\", f);\n    return true;\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
      "extendedDetails": {}
    },
    "a530e7ab3b3f5bd71143a91266b46787962ac532": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-14768. Honoring sticky bit during Deletion when authorization is enabled in WASB\nContributed by Varada Hemeswari\n",
      "commitDate": "28/09/17 11:52 AM",
      "commitName": "a530e7ab3b3f5bd71143a91266b46787962ac532",
      "commitAuthor": "Steve Loughran",
      "diff": "@@ -0,0 +1,245 @@\n+  private boolean deleteWithoutAuth(Path f, boolean recursive,\n+      boolean skipParentFolderLastModifiedTimeUpdate) throws IOException {\n+\n+    LOG.debug(\"Deleting file: {}\", f);\n+\n+    Path absolutePath \u003d makeAbsolute(f);\n+    Path parentPath \u003d absolutePath.getParent();\n+\n+    String key \u003d pathToKey(absolutePath);\n+\n+    // Capture the metadata for the path.\n+    //\n+    FileMetadata metaFile \u003d null;\n+    try {\n+      metaFile \u003d store.retrieveMetadata(key);\n+    } catch (IOException e) {\n+\n+      Throwable innerException \u003d checkForAzureStorageException(e);\n+\n+      if (innerException instanceof StorageException\n+          \u0026\u0026 isFileNotFoundException((StorageException) innerException)) {\n+\n+        return false;\n+      }\n+      throw e;\n+    }\n+\n+    if (null \u003d\u003d metaFile) {\n+      // The path to be deleted does not exist.\n+      return false;\n+    }\n+\n+    // The path exists, determine if it is a folder containing objects,\n+    // an empty folder, or a simple file and take the appropriate actions.\n+    if (!metaFile.isDir()) {\n+      // The path specifies a file. We need to check the parent path\n+      // to make sure it\u0027s a proper materialized directory before we\n+      // delete the file. Otherwise we may get into a situation where\n+      // the file we were deleting was the last one in an implicit directory\n+      // (e.g. the blob store only contains the blob a/b and there\u0027s no\n+      // corresponding directory blob a) and that would implicitly delete\n+      // the directory as well, which is not correct.\n+\n+      if (parentPath.getParent() !\u003d null) {// Not root\n+        String parentKey \u003d pathToKey(parentPath);\n+\n+        FileMetadata parentMetadata \u003d null;\n+        try {\n+          parentMetadata \u003d store.retrieveMetadata(parentKey);\n+        } catch (IOException e) {\n+\n+          Throwable innerException \u003d checkForAzureStorageException(e);\n+\n+          if (innerException instanceof StorageException) {\n+            // Invalid State.\n+            // A FileNotFoundException is not thrown here as the API returns false\n+            // if the file not present. But not retrieving metadata here is an\n+            // unrecoverable state and can only happen if there is a race condition\n+            // hence throwing a IOException\n+            if (isFileNotFoundException((StorageException) innerException)) {\n+              throw new IOException(\"File \" + f + \" has a parent directory \"\n+                  + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n+            }\n+          }\n+          throw e;\n+        }\n+\n+        // Invalid State.\n+        // A FileNotFoundException is not thrown here as the API returns false\n+        // if the file not present. But not retrieving metadata here is an\n+        // unrecoverable state and can only happen if there is a race condition\n+        // hence throwing a IOException\n+        if (parentMetadata \u003d\u003d null) {\n+          throw new IOException(\"File \" + f + \" has a parent directory \"\n+              + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n+        }\n+\n+        if (!parentMetadata.isDir()) {\n+          // Invalid state: the parent path is actually a file. Throw.\n+          throw new AzureException(\"File \" + f + \" has a parent directory \"\n+              + parentPath + \" which is also a file. Can\u0027t resolve.\");\n+        }\n+\n+        if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n+          LOG.debug(\"Found an implicit parent directory while trying to\"\n+              + \" delete the file {}. Creating the directory blob for\"\n+              + \" it in {}.\", f, parentKey);\n+\n+          store.storeEmptyFolder(parentKey,\n+              createPermissionStatus(FsPermission.getDefault()));\n+        } else {\n+          if (!skipParentFolderLastModifiedTimeUpdate) {\n+            updateParentFolderLastModifiedTime(key);\n+          }\n+        }\n+      }\n+\n+      try {\n+        if (store.delete(key)) {\n+          instrumentation.fileDeleted();\n+        } else {\n+          return false;\n+        }\n+      } catch(IOException e) {\n+\n+        Throwable innerException \u003d checkForAzureStorageException(e);\n+\n+        if (innerException instanceof StorageException\n+            \u0026\u0026 isFileNotFoundException((StorageException) innerException)) {\n+          return false;\n+        }\n+\n+       throw e;\n+      }\n+    } else {\n+      // The path specifies a folder. Recursively delete all entries under the\n+      // folder.\n+      LOG.debug(\"Directory Delete encountered: {}\", f);\n+      if (parentPath.getParent() !\u003d null) {\n+        String parentKey \u003d pathToKey(parentPath);\n+        FileMetadata parentMetadata \u003d null;\n+\n+        try {\n+          parentMetadata \u003d store.retrieveMetadata(parentKey);\n+        } catch (IOException e) {\n+\n+          Throwable innerException \u003d checkForAzureStorageException(e);\n+\n+          if (innerException instanceof StorageException) {\n+            // Invalid State.\n+            // A FileNotFoundException is not thrown here as the API returns false\n+            // if the file not present. But not retrieving metadata here is an\n+            // unrecoverable state and can only happen if there is a race condition\n+            // hence throwing a IOException\n+            if (isFileNotFoundException((StorageException) innerException)) {\n+              throw new IOException(\"File \" + f + \" has a parent directory \"\n+                  + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n+            }\n+          }\n+          throw e;\n+        }\n+\n+        // Invalid State.\n+        // A FileNotFoundException is not thrown here as the API returns false\n+        // if the file not present. But not retrieving metadata here is an\n+        // unrecoverable state and can only happen if there is a race condition\n+        // hence throwing a IOException\n+        if (parentMetadata \u003d\u003d null) {\n+          throw new IOException(\"File \" + f + \" has a parent directory \"\n+              + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n+        }\n+\n+        if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n+          LOG.debug(\"Found an implicit parent directory while trying to\"\n+              + \" delete the directory {}. Creating the directory blob for\"\n+              + \" it in {}. \", f, parentKey);\n+\n+          store.storeEmptyFolder(parentKey,\n+              createPermissionStatus(FsPermission.getDefault()));\n+        }\n+      }\n+\n+      // List all the blobs in the current folder.\n+      String priorLastKey \u003d null;\n+\n+      // Start time for list operation\n+      long start \u003d Time.monotonicNow();\n+      ArrayList\u003cFileMetadata\u003e fileMetadataList \u003d new ArrayList\u003cFileMetadata\u003e();\n+\n+      // List all the files in the folder with AZURE_UNBOUNDED_DEPTH depth.\n+      do {\n+        try {\n+          PartialListing listing \u003d store.listAll(key, AZURE_LIST_ALL,\n+            AZURE_UNBOUNDED_DEPTH, priorLastKey);\n+          for(FileMetadata file : listing.getFiles()) {\n+            fileMetadataList.add(file);\n+          }\n+          priorLastKey \u003d listing.getPriorLastKey();\n+        } catch (IOException e) {\n+          Throwable innerException \u003d checkForAzureStorageException(e);\n+\n+          if (innerException instanceof StorageException\n+              \u0026\u0026 isFileNotFoundException((StorageException) innerException)) {\n+            return false;\n+          }\n+\n+          throw e;\n+        }\n+      } while (priorLastKey !\u003d null);\n+\n+      long end \u003d Time.monotonicNow();\n+      LOG.debug(\"Time taken to list {} blobs for delete operation: {} ms\", fileMetadataList.size(), (end - start));\n+\n+      final FileMetadata[] contents \u003d fileMetadataList.toArray(new FileMetadata[fileMetadataList.size()]);\n+\n+      if (contents.length \u003e 0) {\n+        if (!recursive) {\n+          // The folder is non-empty and recursive delete was not specified.\n+          // Throw an exception indicating that a non-recursive delete was\n+          // specified for a non-empty folder.\n+          throw new IOException(\"Non-recursive delete of non-empty directory \"+ f);\n+        }\n+      }\n+\n+      // Delete all files / folders in current directory stored as list in \u0027contents\u0027.\n+      AzureFileSystemThreadTask task \u003d new AzureFileSystemThreadTask() {\n+        @Override\n+        public boolean execute(FileMetadata file) throws IOException{\n+          if (!deleteFile(file.getKey(), file.isDir())) {\n+            LOG.warn(\"Attempt to delete non-existent {} {}\",\n+                file.isDir() ? \"directory\" : \"file\",\n+                file.getKey());\n+          }\n+          return true;\n+        }\n+      };\n+\n+      AzureFileSystemThreadPoolExecutor executor \u003d getThreadPoolExecutor(this.deleteThreadCount,\n+          \"AzureBlobDeleteThread\", \"Delete\", key, AZURE_DELETE_THREADS);\n+\n+      if (!executor.executeParallel(contents, task)) {\n+        LOG.error(\"Failed to delete files / subfolders in blob {}\", key);\n+        return false;\n+      }\n+\n+      // Delete the current directory\n+      if (store.retrieveMetadata(metaFile.getKey()) !\u003d null\n+          \u0026\u0026 !deleteFile(metaFile.getKey(), metaFile.isDir())) {\n+        LOG.error(\"Failed delete directory : {}\", f);\n+        return false;\n+      }\n+\n+      // Update parent directory last modified time\n+      Path parent \u003d absolutePath.getParent();\n+      if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) { // not root\n+        if (!skipParentFolderLastModifiedTimeUpdate) {\n+          updateParentFolderLastModifiedTime(key);\n+        }\n+      }\n+    }\n+\n+    // File or directory was successfully deleted.\n+    LOG.debug(\"Delete Successful for : {}\", f);\n+    return true;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean deleteWithoutAuth(Path f, boolean recursive,\n      boolean skipParentFolderLastModifiedTimeUpdate) throws IOException {\n\n    LOG.debug(\"Deleting file: {}\", f);\n\n    Path absolutePath \u003d makeAbsolute(f);\n    Path parentPath \u003d absolutePath.getParent();\n\n    String key \u003d pathToKey(absolutePath);\n\n    // Capture the metadata for the path.\n    //\n    FileMetadata metaFile \u003d null;\n    try {\n      metaFile \u003d store.retrieveMetadata(key);\n    } catch (IOException e) {\n\n      Throwable innerException \u003d checkForAzureStorageException(e);\n\n      if (innerException instanceof StorageException\n          \u0026\u0026 isFileNotFoundException((StorageException) innerException)) {\n\n        return false;\n      }\n      throw e;\n    }\n\n    if (null \u003d\u003d metaFile) {\n      // The path to be deleted does not exist.\n      return false;\n    }\n\n    // The path exists, determine if it is a folder containing objects,\n    // an empty folder, or a simple file and take the appropriate actions.\n    if (!metaFile.isDir()) {\n      // The path specifies a file. We need to check the parent path\n      // to make sure it\u0027s a proper materialized directory before we\n      // delete the file. Otherwise we may get into a situation where\n      // the file we were deleting was the last one in an implicit directory\n      // (e.g. the blob store only contains the blob a/b and there\u0027s no\n      // corresponding directory blob a) and that would implicitly delete\n      // the directory as well, which is not correct.\n\n      if (parentPath.getParent() !\u003d null) {// Not root\n        String parentKey \u003d pathToKey(parentPath);\n\n        FileMetadata parentMetadata \u003d null;\n        try {\n          parentMetadata \u003d store.retrieveMetadata(parentKey);\n        } catch (IOException e) {\n\n          Throwable innerException \u003d checkForAzureStorageException(e);\n\n          if (innerException instanceof StorageException) {\n            // Invalid State.\n            // A FileNotFoundException is not thrown here as the API returns false\n            // if the file not present. But not retrieving metadata here is an\n            // unrecoverable state and can only happen if there is a race condition\n            // hence throwing a IOException\n            if (isFileNotFoundException((StorageException) innerException)) {\n              throw new IOException(\"File \" + f + \" has a parent directory \"\n                  + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n            }\n          }\n          throw e;\n        }\n\n        // Invalid State.\n        // A FileNotFoundException is not thrown here as the API returns false\n        // if the file not present. But not retrieving metadata here is an\n        // unrecoverable state and can only happen if there is a race condition\n        // hence throwing a IOException\n        if (parentMetadata \u003d\u003d null) {\n          throw new IOException(\"File \" + f + \" has a parent directory \"\n              + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n        }\n\n        if (!parentMetadata.isDir()) {\n          // Invalid state: the parent path is actually a file. Throw.\n          throw new AzureException(\"File \" + f + \" has a parent directory \"\n              + parentPath + \" which is also a file. Can\u0027t resolve.\");\n        }\n\n        if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n          LOG.debug(\"Found an implicit parent directory while trying to\"\n              + \" delete the file {}. Creating the directory blob for\"\n              + \" it in {}.\", f, parentKey);\n\n          store.storeEmptyFolder(parentKey,\n              createPermissionStatus(FsPermission.getDefault()));\n        } else {\n          if (!skipParentFolderLastModifiedTimeUpdate) {\n            updateParentFolderLastModifiedTime(key);\n          }\n        }\n      }\n\n      try {\n        if (store.delete(key)) {\n          instrumentation.fileDeleted();\n        } else {\n          return false;\n        }\n      } catch(IOException e) {\n\n        Throwable innerException \u003d checkForAzureStorageException(e);\n\n        if (innerException instanceof StorageException\n            \u0026\u0026 isFileNotFoundException((StorageException) innerException)) {\n          return false;\n        }\n\n       throw e;\n      }\n    } else {\n      // The path specifies a folder. Recursively delete all entries under the\n      // folder.\n      LOG.debug(\"Directory Delete encountered: {}\", f);\n      if (parentPath.getParent() !\u003d null) {\n        String parentKey \u003d pathToKey(parentPath);\n        FileMetadata parentMetadata \u003d null;\n\n        try {\n          parentMetadata \u003d store.retrieveMetadata(parentKey);\n        } catch (IOException e) {\n\n          Throwable innerException \u003d checkForAzureStorageException(e);\n\n          if (innerException instanceof StorageException) {\n            // Invalid State.\n            // A FileNotFoundException is not thrown here as the API returns false\n            // if the file not present. But not retrieving metadata here is an\n            // unrecoverable state and can only happen if there is a race condition\n            // hence throwing a IOException\n            if (isFileNotFoundException((StorageException) innerException)) {\n              throw new IOException(\"File \" + f + \" has a parent directory \"\n                  + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n            }\n          }\n          throw e;\n        }\n\n        // Invalid State.\n        // A FileNotFoundException is not thrown here as the API returns false\n        // if the file not present. But not retrieving metadata here is an\n        // unrecoverable state and can only happen if there is a race condition\n        // hence throwing a IOException\n        if (parentMetadata \u003d\u003d null) {\n          throw new IOException(\"File \" + f + \" has a parent directory \"\n              + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n        }\n\n        if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n          LOG.debug(\"Found an implicit parent directory while trying to\"\n              + \" delete the directory {}. Creating the directory blob for\"\n              + \" it in {}. \", f, parentKey);\n\n          store.storeEmptyFolder(parentKey,\n              createPermissionStatus(FsPermission.getDefault()));\n        }\n      }\n\n      // List all the blobs in the current folder.\n      String priorLastKey \u003d null;\n\n      // Start time for list operation\n      long start \u003d Time.monotonicNow();\n      ArrayList\u003cFileMetadata\u003e fileMetadataList \u003d new ArrayList\u003cFileMetadata\u003e();\n\n      // List all the files in the folder with AZURE_UNBOUNDED_DEPTH depth.\n      do {\n        try {\n          PartialListing listing \u003d store.listAll(key, AZURE_LIST_ALL,\n            AZURE_UNBOUNDED_DEPTH, priorLastKey);\n          for(FileMetadata file : listing.getFiles()) {\n            fileMetadataList.add(file);\n          }\n          priorLastKey \u003d listing.getPriorLastKey();\n        } catch (IOException e) {\n          Throwable innerException \u003d checkForAzureStorageException(e);\n\n          if (innerException instanceof StorageException\n              \u0026\u0026 isFileNotFoundException((StorageException) innerException)) {\n            return false;\n          }\n\n          throw e;\n        }\n      } while (priorLastKey !\u003d null);\n\n      long end \u003d Time.monotonicNow();\n      LOG.debug(\"Time taken to list {} blobs for delete operation: {} ms\", fileMetadataList.size(), (end - start));\n\n      final FileMetadata[] contents \u003d fileMetadataList.toArray(new FileMetadata[fileMetadataList.size()]);\n\n      if (contents.length \u003e 0) {\n        if (!recursive) {\n          // The folder is non-empty and recursive delete was not specified.\n          // Throw an exception indicating that a non-recursive delete was\n          // specified for a non-empty folder.\n          throw new IOException(\"Non-recursive delete of non-empty directory \"+ f);\n        }\n      }\n\n      // Delete all files / folders in current directory stored as list in \u0027contents\u0027.\n      AzureFileSystemThreadTask task \u003d new AzureFileSystemThreadTask() {\n        @Override\n        public boolean execute(FileMetadata file) throws IOException{\n          if (!deleteFile(file.getKey(), file.isDir())) {\n            LOG.warn(\"Attempt to delete non-existent {} {}\",\n                file.isDir() ? \"directory\" : \"file\",\n                file.getKey());\n          }\n          return true;\n        }\n      };\n\n      AzureFileSystemThreadPoolExecutor executor \u003d getThreadPoolExecutor(this.deleteThreadCount,\n          \"AzureBlobDeleteThread\", \"Delete\", key, AZURE_DELETE_THREADS);\n\n      if (!executor.executeParallel(contents, task)) {\n        LOG.error(\"Failed to delete files / subfolders in blob {}\", key);\n        return false;\n      }\n\n      // Delete the current directory\n      if (store.retrieveMetadata(metaFile.getKey()) !\u003d null\n          \u0026\u0026 !deleteFile(metaFile.getKey(), metaFile.isDir())) {\n        LOG.error(\"Failed delete directory : {}\", f);\n        return false;\n      }\n\n      // Update parent directory last modified time\n      Path parent \u003d absolutePath.getParent();\n      if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) { // not root\n        if (!skipParentFolderLastModifiedTimeUpdate) {\n          updateParentFolderLastModifiedTime(key);\n        }\n      }\n    }\n\n    // File or directory was successfully deleted.\n    LOG.debug(\"Delete Successful for : {}\", f);\n    return true;\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java"
    }
  }
}