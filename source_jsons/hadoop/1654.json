{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "SaslDataTransferClient.java",
  "functionName": "doSaslHandshake",
  "functionId": "doSaslHandshake___addr-InetAddress__underlyingOut-OutputStream__underlyingIn-InputStream__userName-String__saslProps-Map__String,String____callbackHandler-CallbackHandler__accessToken-Token__BlockTokenIdentifier__",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/protocol/datatransfer/sasl/SaslDataTransferClient.java",
  "functionStartLine": 501,
  "functionEndLine": 604,
  "numCommitsSeen": 19,
  "timeTaken": 4596,
  "changeHistory": [
    "8fb5ca3f405550828a17e689b9c60ddf7fb95ec1",
    "626fec652b9f3dae10c9af78fd220b1240f19fc7",
    "d1dd248b756e5a323ac885eefd3f81a639d6b86f",
    "ed78b14ebc9a21bb57ccd088e8b49bfa457a396f",
    "5573b3476a5a6fce0ac99c654a9a9ec90f744a20",
    "58c0bb9ed9f4a2491395b63c68046562a73526c9",
    "3b54223c0f32d42a84436c670d80b791a8e9696d"
  ],
  "changeHistoryShort": {
    "8fb5ca3f405550828a17e689b9c60ddf7fb95ec1": "Ybodychange",
    "626fec652b9f3dae10c9af78fd220b1240f19fc7": "Ymultichange(Yparameterchange,Ybodychange)",
    "d1dd248b756e5a323ac885eefd3f81a639d6b86f": "Ymultichange(Yparameterchange,Ybodychange)",
    "ed78b14ebc9a21bb57ccd088e8b49bfa457a396f": "Yfilerename",
    "5573b3476a5a6fce0ac99c654a9a9ec90f744a20": "Ybodychange",
    "58c0bb9ed9f4a2491395b63c68046562a73526c9": "Ybodychange",
    "3b54223c0f32d42a84436c670d80b791a8e9696d": "Yintroduced"
  },
  "changeHistoryDetails": {
    "8fb5ca3f405550828a17e689b9c60ddf7fb95ec1": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14611. Move handshake secret field from Token to BlockAccessToken. Contributed by Chen Liang.\n",
      "commitDate": "11/07/19 1:23 PM",
      "commitName": "8fb5ca3f405550828a17e689b9c60ddf7fb95ec1",
      "commitAuthor": "Chen Liang",
      "commitDateOld": "03/05/19 10:14 AM",
      "commitNameOld": "1d59cc490cb46e99d1d72fe3bd0c2a396d98f2c8",
      "commitAuthorOld": "Chen Liang",
      "daysBetweenCommits": 69.13,
      "commitsBetweenForRepo": 498,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,95 +1,104 @@\n   private IOStreamPair doSaslHandshake(InetAddress addr,\n       OutputStream underlyingOut, InputStream underlyingIn, String userName,\n       Map\u003cString, String\u003e saslProps, CallbackHandler callbackHandler,\n       Token\u003cBlockTokenIdentifier\u003e accessToken) throws IOException {\n \n     DataOutputStream out \u003d new DataOutputStream(underlyingOut);\n     DataInputStream in \u003d new DataInputStream(underlyingIn);\n \n     SaslParticipant sasl\u003d SaslParticipant.createClientSaslParticipant(userName,\n         saslProps, callbackHandler);\n \n     out.writeInt(SASL_TRANSFER_MAGIC_NUMBER);\n     out.flush();\n \n     try {\n       // Start of handshake - \"initial response\" in SASL terminology.\n       // The handshake secret can be null, this happens when client is running\n-      // a new version but the cluster does not have this feature. In which case\n-      // there will be no encrypted secret sent from NN.\n-      byte[] handshakeSecret \u003d accessToken.getDnHandshakeSecret();\n-      if (handshakeSecret \u003d\u003d null || handshakeSecret.length \u003d\u003d 0) {\n-        LOG.debug(\"Handshake secret is null, sending without \"\n-            + \"handshake secret.\");\n-        sendSaslMessage(out, new byte[0]);\n+      // a new version but the cluster does not have this feature.\n+      // In which case there will be no encrypted secret sent from NN.\n+      BlockTokenIdentifier blockTokenIdentifier \u003d\n+          accessToken.decodeIdentifier();\n+      if (blockTokenIdentifier !\u003d null) {\n+        byte[] handshakeSecret \u003d\n+            accessToken.decodeIdentifier().getHandshakeMsg();\n+        if (handshakeSecret \u003d\u003d null || handshakeSecret.length \u003d\u003d 0) {\n+          LOG.debug(\"Handshake secret is null, \"\n+              + \"sending without handshake secret.\");\n+          sendSaslMessage(out, new byte[0]);\n+        } else {\n+          LOG.debug(\"Sending handshake secret.\");\n+          BlockTokenIdentifier identifier \u003d new BlockTokenIdentifier();\n+          identifier.readFields(new DataInputStream(\n+              new ByteArrayInputStream(accessToken.getIdentifier())));\n+          String bpid \u003d identifier.getBlockPoolId();\n+          sendSaslMessageHandshakeSecret(out, new byte[0],\n+              handshakeSecret, bpid);\n+        }\n       } else {\n-        LOG.debug(\"Sending handshake secret.\");\n-        BlockTokenIdentifier identifier \u003d new BlockTokenIdentifier();\n-        identifier.readFields(new DataInputStream(\n-            new ByteArrayInputStream(accessToken.getIdentifier())));\n-        String bpid \u003d identifier.getBlockPoolId();\n-        sendSaslMessageHandshakeSecret(out, new byte[0], handshakeSecret, bpid);\n+        LOG.debug(\"Block token id is null, sending without handshake secret.\");\n+        sendSaslMessage(out, new byte[0]);\n       }\n \n       // step 1\n       byte[] remoteResponse \u003d readSaslMessage(in);\n       byte[] localResponse \u003d sasl.evaluateChallengeOrResponse(remoteResponse);\n       List\u003cCipherOption\u003e cipherOptions \u003d null;\n       String cipherSuites \u003d conf.get(\n           DFS_ENCRYPT_DATA_TRANSFER_CIPHER_SUITES_KEY);\n       if (requestedQopContainsPrivacy(saslProps)) {\n         // Negotiate cipher suites if configured.  Currently, the only supported\n         // cipher suite is AES/CTR/NoPadding, but the protocol allows multiple\n         // values for future expansion.\n         if (cipherSuites !\u003d null \u0026\u0026 !cipherSuites.isEmpty()) {\n           if (!cipherSuites.equals(CipherSuite.AES_CTR_NOPADDING.getName())) {\n             throw new IOException(String.format(\"Invalid cipher suite, %s\u003d%s\",\n                 DFS_ENCRYPT_DATA_TRANSFER_CIPHER_SUITES_KEY, cipherSuites));\n           }\n           CipherOption option \u003d new CipherOption(CipherSuite.AES_CTR_NOPADDING);\n           cipherOptions \u003d Lists.newArrayListWithCapacity(1);\n           cipherOptions.add(option);\n         }\n       }\n       sendSaslMessageAndNegotiationCipherOptions(out, localResponse,\n           cipherOptions);\n \n       // step 2 (client-side only)\n       SaslResponseWithNegotiatedCipherOption response \u003d\n           readSaslMessageAndNegotiatedCipherOption(in);\n       localResponse \u003d sasl.evaluateChallengeOrResponse(response.payload);\n       assert localResponse \u003d\u003d null;\n \n       // SASL handshake is complete\n       checkSaslComplete(sasl, saslProps);\n \n       CipherOption cipherOption \u003d null;\n       if (sasl.isNegotiatedQopPrivacy()) {\n         // Unwrap the negotiated cipher option\n         cipherOption \u003d unwrap(response.cipherOption, sasl);\n         if (LOG.isDebugEnabled()) {\n           if (cipherOption \u003d\u003d null) {\n             // No cipher suite is negotiated\n             if (cipherSuites !\u003d null \u0026\u0026 !cipherSuites.isEmpty()) {\n               // the client accepts some cipher suites, but the server does not.\n               LOG.debug(\"Client accepts cipher suites {}, \"\n                       + \"but server {} does not accept any of them\",\n                   cipherSuites, addr.toString());\n             }\n           } else {\n             LOG.debug(\"Client using cipher suite {} with server {}\",\n                 cipherOption.getCipherSuite().getName(), addr.toString());\n           }\n         }\n       }\n \n       // If negotiated cipher option is not null, we will use it to create\n       // stream pair.\n       return cipherOption !\u003d null ? createStreamPair(\n           conf, cipherOption, underlyingOut, underlyingIn, false) :\n           sasl.createStreamPair(out, in);\n     } catch (IOException ioe) {\n       sendGenericSaslErrorMessage(out, ioe.getMessage());\n       throw ioe;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private IOStreamPair doSaslHandshake(InetAddress addr,\n      OutputStream underlyingOut, InputStream underlyingIn, String userName,\n      Map\u003cString, String\u003e saslProps, CallbackHandler callbackHandler,\n      Token\u003cBlockTokenIdentifier\u003e accessToken) throws IOException {\n\n    DataOutputStream out \u003d new DataOutputStream(underlyingOut);\n    DataInputStream in \u003d new DataInputStream(underlyingIn);\n\n    SaslParticipant sasl\u003d SaslParticipant.createClientSaslParticipant(userName,\n        saslProps, callbackHandler);\n\n    out.writeInt(SASL_TRANSFER_MAGIC_NUMBER);\n    out.flush();\n\n    try {\n      // Start of handshake - \"initial response\" in SASL terminology.\n      // The handshake secret can be null, this happens when client is running\n      // a new version but the cluster does not have this feature.\n      // In which case there will be no encrypted secret sent from NN.\n      BlockTokenIdentifier blockTokenIdentifier \u003d\n          accessToken.decodeIdentifier();\n      if (blockTokenIdentifier !\u003d null) {\n        byte[] handshakeSecret \u003d\n            accessToken.decodeIdentifier().getHandshakeMsg();\n        if (handshakeSecret \u003d\u003d null || handshakeSecret.length \u003d\u003d 0) {\n          LOG.debug(\"Handshake secret is null, \"\n              + \"sending without handshake secret.\");\n          sendSaslMessage(out, new byte[0]);\n        } else {\n          LOG.debug(\"Sending handshake secret.\");\n          BlockTokenIdentifier identifier \u003d new BlockTokenIdentifier();\n          identifier.readFields(new DataInputStream(\n              new ByteArrayInputStream(accessToken.getIdentifier())));\n          String bpid \u003d identifier.getBlockPoolId();\n          sendSaslMessageHandshakeSecret(out, new byte[0],\n              handshakeSecret, bpid);\n        }\n      } else {\n        LOG.debug(\"Block token id is null, sending without handshake secret.\");\n        sendSaslMessage(out, new byte[0]);\n      }\n\n      // step 1\n      byte[] remoteResponse \u003d readSaslMessage(in);\n      byte[] localResponse \u003d sasl.evaluateChallengeOrResponse(remoteResponse);\n      List\u003cCipherOption\u003e cipherOptions \u003d null;\n      String cipherSuites \u003d conf.get(\n          DFS_ENCRYPT_DATA_TRANSFER_CIPHER_SUITES_KEY);\n      if (requestedQopContainsPrivacy(saslProps)) {\n        // Negotiate cipher suites if configured.  Currently, the only supported\n        // cipher suite is AES/CTR/NoPadding, but the protocol allows multiple\n        // values for future expansion.\n        if (cipherSuites !\u003d null \u0026\u0026 !cipherSuites.isEmpty()) {\n          if (!cipherSuites.equals(CipherSuite.AES_CTR_NOPADDING.getName())) {\n            throw new IOException(String.format(\"Invalid cipher suite, %s\u003d%s\",\n                DFS_ENCRYPT_DATA_TRANSFER_CIPHER_SUITES_KEY, cipherSuites));\n          }\n          CipherOption option \u003d new CipherOption(CipherSuite.AES_CTR_NOPADDING);\n          cipherOptions \u003d Lists.newArrayListWithCapacity(1);\n          cipherOptions.add(option);\n        }\n      }\n      sendSaslMessageAndNegotiationCipherOptions(out, localResponse,\n          cipherOptions);\n\n      // step 2 (client-side only)\n      SaslResponseWithNegotiatedCipherOption response \u003d\n          readSaslMessageAndNegotiatedCipherOption(in);\n      localResponse \u003d sasl.evaluateChallengeOrResponse(response.payload);\n      assert localResponse \u003d\u003d null;\n\n      // SASL handshake is complete\n      checkSaslComplete(sasl, saslProps);\n\n      CipherOption cipherOption \u003d null;\n      if (sasl.isNegotiatedQopPrivacy()) {\n        // Unwrap the negotiated cipher option\n        cipherOption \u003d unwrap(response.cipherOption, sasl);\n        if (LOG.isDebugEnabled()) {\n          if (cipherOption \u003d\u003d null) {\n            // No cipher suite is negotiated\n            if (cipherSuites !\u003d null \u0026\u0026 !cipherSuites.isEmpty()) {\n              // the client accepts some cipher suites, but the server does not.\n              LOG.debug(\"Client accepts cipher suites {}, \"\n                      + \"but server {} does not accept any of them\",\n                  cipherSuites, addr.toString());\n            }\n          } else {\n            LOG.debug(\"Client using cipher suite {} with server {}\",\n                cipherOption.getCipherSuite().getName(), addr.toString());\n          }\n        }\n      }\n\n      // If negotiated cipher option is not null, we will use it to create\n      // stream pair.\n      return cipherOption !\u003d null ? createStreamPair(\n          conf, cipherOption, underlyingOut, underlyingIn, false) :\n          sasl.createStreamPair(out, in);\n    } catch (IOException ioe) {\n      sendGenericSaslErrorMessage(out, ioe.getMessage());\n      throw ioe;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/protocol/datatransfer/sasl/SaslDataTransferClient.java",
      "extendedDetails": {}
    },
    "626fec652b9f3dae10c9af78fd220b1240f19fc7": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-13699. Add DFSClient sending handshake token to DataNode, and allow DataNode overwrite downstream QOP. Contributed by Chen Liang.\n",
      "commitDate": "12/04/19 5:37 PM",
      "commitName": "626fec652b9f3dae10c9af78fd220b1240f19fc7",
      "commitAuthor": "Chen Liang",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-13699. Add DFSClient sending handshake token to DataNode, and allow DataNode overwrite downstream QOP. Contributed by Chen Liang.\n",
          "commitDate": "12/04/19 5:37 PM",
          "commitName": "626fec652b9f3dae10c9af78fd220b1240f19fc7",
          "commitAuthor": "Chen Liang",
          "commitDateOld": "31/01/18 10:47 AM",
          "commitNameOld": "37b753656849d0864ed3c8858edf3b85515cbf39",
          "commitAuthorOld": "Xiaoyu Yao",
          "daysBetweenCommits": 436.24,
          "commitsBetweenForRepo": 3917,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,80 +1,95 @@\n   private IOStreamPair doSaslHandshake(InetAddress addr,\n       OutputStream underlyingOut, InputStream underlyingIn, String userName,\n-      Map\u003cString, String\u003e saslProps,\n-      CallbackHandler callbackHandler) throws IOException {\n+      Map\u003cString, String\u003e saslProps, CallbackHandler callbackHandler,\n+      Token\u003cBlockTokenIdentifier\u003e accessToken) throws IOException {\n \n     DataOutputStream out \u003d new DataOutputStream(underlyingOut);\n     DataInputStream in \u003d new DataInputStream(underlyingIn);\n \n     SaslParticipant sasl\u003d SaslParticipant.createClientSaslParticipant(userName,\n         saslProps, callbackHandler);\n \n     out.writeInt(SASL_TRANSFER_MAGIC_NUMBER);\n     out.flush();\n \n     try {\n       // Start of handshake - \"initial response\" in SASL terminology.\n-      sendSaslMessage(out, new byte[0]);\n+      // The handshake secret can be null, this happens when client is running\n+      // a new version but the cluster does not have this feature. In which case\n+      // there will be no encrypted secret sent from NN.\n+      byte[] handshakeSecret \u003d accessToken.getDnHandshakeSecret();\n+      if (handshakeSecret \u003d\u003d null || handshakeSecret.length \u003d\u003d 0) {\n+        LOG.debug(\"Handshake secret is null, sending without \"\n+            + \"handshake secret.\");\n+        sendSaslMessage(out, new byte[0]);\n+      } else {\n+        LOG.debug(\"Sending handshake secret.\");\n+        BlockTokenIdentifier identifier \u003d new BlockTokenIdentifier();\n+        identifier.readFields(new DataInputStream(\n+            new ByteArrayInputStream(accessToken.getIdentifier())));\n+        String bpid \u003d identifier.getBlockPoolId();\n+        sendSaslMessageHandshakeSecret(out, new byte[0], handshakeSecret, bpid);\n+      }\n \n       // step 1\n       byte[] remoteResponse \u003d readSaslMessage(in);\n       byte[] localResponse \u003d sasl.evaluateChallengeOrResponse(remoteResponse);\n       List\u003cCipherOption\u003e cipherOptions \u003d null;\n       String cipherSuites \u003d conf.get(\n           DFS_ENCRYPT_DATA_TRANSFER_CIPHER_SUITES_KEY);\n       if (requestedQopContainsPrivacy(saslProps)) {\n         // Negotiate cipher suites if configured.  Currently, the only supported\n         // cipher suite is AES/CTR/NoPadding, but the protocol allows multiple\n         // values for future expansion.\n         if (cipherSuites !\u003d null \u0026\u0026 !cipherSuites.isEmpty()) {\n           if (!cipherSuites.equals(CipherSuite.AES_CTR_NOPADDING.getName())) {\n             throw new IOException(String.format(\"Invalid cipher suite, %s\u003d%s\",\n                 DFS_ENCRYPT_DATA_TRANSFER_CIPHER_SUITES_KEY, cipherSuites));\n           }\n           CipherOption option \u003d new CipherOption(CipherSuite.AES_CTR_NOPADDING);\n           cipherOptions \u003d Lists.newArrayListWithCapacity(1);\n           cipherOptions.add(option);\n         }\n       }\n       sendSaslMessageAndNegotiationCipherOptions(out, localResponse,\n           cipherOptions);\n \n       // step 2 (client-side only)\n       SaslResponseWithNegotiatedCipherOption response \u003d\n           readSaslMessageAndNegotiatedCipherOption(in);\n       localResponse \u003d sasl.evaluateChallengeOrResponse(response.payload);\n       assert localResponse \u003d\u003d null;\n \n       // SASL handshake is complete\n       checkSaslComplete(sasl, saslProps);\n \n       CipherOption cipherOption \u003d null;\n       if (sasl.isNegotiatedQopPrivacy()) {\n         // Unwrap the negotiated cipher option\n         cipherOption \u003d unwrap(response.cipherOption, sasl);\n         if (LOG.isDebugEnabled()) {\n           if (cipherOption \u003d\u003d null) {\n             // No cipher suite is negotiated\n             if (cipherSuites !\u003d null \u0026\u0026 !cipherSuites.isEmpty()) {\n               // the client accepts some cipher suites, but the server does not.\n               LOG.debug(\"Client accepts cipher suites {}, \"\n                       + \"but server {} does not accept any of them\",\n                   cipherSuites, addr.toString());\n             }\n           } else {\n             LOG.debug(\"Client using cipher suite {} with server {}\",\n                 cipherOption.getCipherSuite().getName(), addr.toString());\n           }\n         }\n       }\n \n       // If negotiated cipher option is not null, we will use it to create\n       // stream pair.\n       return cipherOption !\u003d null ? createStreamPair(\n           conf, cipherOption, underlyingOut, underlyingIn, false) :\n           sasl.createStreamPair(out, in);\n     } catch (IOException ioe) {\n       sendGenericSaslErrorMessage(out, ioe.getMessage());\n       throw ioe;\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private IOStreamPair doSaslHandshake(InetAddress addr,\n      OutputStream underlyingOut, InputStream underlyingIn, String userName,\n      Map\u003cString, String\u003e saslProps, CallbackHandler callbackHandler,\n      Token\u003cBlockTokenIdentifier\u003e accessToken) throws IOException {\n\n    DataOutputStream out \u003d new DataOutputStream(underlyingOut);\n    DataInputStream in \u003d new DataInputStream(underlyingIn);\n\n    SaslParticipant sasl\u003d SaslParticipant.createClientSaslParticipant(userName,\n        saslProps, callbackHandler);\n\n    out.writeInt(SASL_TRANSFER_MAGIC_NUMBER);\n    out.flush();\n\n    try {\n      // Start of handshake - \"initial response\" in SASL terminology.\n      // The handshake secret can be null, this happens when client is running\n      // a new version but the cluster does not have this feature. In which case\n      // there will be no encrypted secret sent from NN.\n      byte[] handshakeSecret \u003d accessToken.getDnHandshakeSecret();\n      if (handshakeSecret \u003d\u003d null || handshakeSecret.length \u003d\u003d 0) {\n        LOG.debug(\"Handshake secret is null, sending without \"\n            + \"handshake secret.\");\n        sendSaslMessage(out, new byte[0]);\n      } else {\n        LOG.debug(\"Sending handshake secret.\");\n        BlockTokenIdentifier identifier \u003d new BlockTokenIdentifier();\n        identifier.readFields(new DataInputStream(\n            new ByteArrayInputStream(accessToken.getIdentifier())));\n        String bpid \u003d identifier.getBlockPoolId();\n        sendSaslMessageHandshakeSecret(out, new byte[0], handshakeSecret, bpid);\n      }\n\n      // step 1\n      byte[] remoteResponse \u003d readSaslMessage(in);\n      byte[] localResponse \u003d sasl.evaluateChallengeOrResponse(remoteResponse);\n      List\u003cCipherOption\u003e cipherOptions \u003d null;\n      String cipherSuites \u003d conf.get(\n          DFS_ENCRYPT_DATA_TRANSFER_CIPHER_SUITES_KEY);\n      if (requestedQopContainsPrivacy(saslProps)) {\n        // Negotiate cipher suites if configured.  Currently, the only supported\n        // cipher suite is AES/CTR/NoPadding, but the protocol allows multiple\n        // values for future expansion.\n        if (cipherSuites !\u003d null \u0026\u0026 !cipherSuites.isEmpty()) {\n          if (!cipherSuites.equals(CipherSuite.AES_CTR_NOPADDING.getName())) {\n            throw new IOException(String.format(\"Invalid cipher suite, %s\u003d%s\",\n                DFS_ENCRYPT_DATA_TRANSFER_CIPHER_SUITES_KEY, cipherSuites));\n          }\n          CipherOption option \u003d new CipherOption(CipherSuite.AES_CTR_NOPADDING);\n          cipherOptions \u003d Lists.newArrayListWithCapacity(1);\n          cipherOptions.add(option);\n        }\n      }\n      sendSaslMessageAndNegotiationCipherOptions(out, localResponse,\n          cipherOptions);\n\n      // step 2 (client-side only)\n      SaslResponseWithNegotiatedCipherOption response \u003d\n          readSaslMessageAndNegotiatedCipherOption(in);\n      localResponse \u003d sasl.evaluateChallengeOrResponse(response.payload);\n      assert localResponse \u003d\u003d null;\n\n      // SASL handshake is complete\n      checkSaslComplete(sasl, saslProps);\n\n      CipherOption cipherOption \u003d null;\n      if (sasl.isNegotiatedQopPrivacy()) {\n        // Unwrap the negotiated cipher option\n        cipherOption \u003d unwrap(response.cipherOption, sasl);\n        if (LOG.isDebugEnabled()) {\n          if (cipherOption \u003d\u003d null) {\n            // No cipher suite is negotiated\n            if (cipherSuites !\u003d null \u0026\u0026 !cipherSuites.isEmpty()) {\n              // the client accepts some cipher suites, but the server does not.\n              LOG.debug(\"Client accepts cipher suites {}, \"\n                      + \"but server {} does not accept any of them\",\n                  cipherSuites, addr.toString());\n            }\n          } else {\n            LOG.debug(\"Client using cipher suite {} with server {}\",\n                cipherOption.getCipherSuite().getName(), addr.toString());\n          }\n        }\n      }\n\n      // If negotiated cipher option is not null, we will use it to create\n      // stream pair.\n      return cipherOption !\u003d null ? createStreamPair(\n          conf, cipherOption, underlyingOut, underlyingIn, false) :\n          sasl.createStreamPair(out, in);\n    } catch (IOException ioe) {\n      sendGenericSaslErrorMessage(out, ioe.getMessage());\n      throw ioe;\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/protocol/datatransfer/sasl/SaslDataTransferClient.java",
          "extendedDetails": {
            "oldValue": "[addr-InetAddress, underlyingOut-OutputStream, underlyingIn-InputStream, userName-String, saslProps-Map\u003cString,String\u003e, callbackHandler-CallbackHandler]",
            "newValue": "[addr-InetAddress, underlyingOut-OutputStream, underlyingIn-InputStream, userName-String, saslProps-Map\u003cString,String\u003e, callbackHandler-CallbackHandler, accessToken-Token\u003cBlockTokenIdentifier\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-13699. Add DFSClient sending handshake token to DataNode, and allow DataNode overwrite downstream QOP. Contributed by Chen Liang.\n",
          "commitDate": "12/04/19 5:37 PM",
          "commitName": "626fec652b9f3dae10c9af78fd220b1240f19fc7",
          "commitAuthor": "Chen Liang",
          "commitDateOld": "31/01/18 10:47 AM",
          "commitNameOld": "37b753656849d0864ed3c8858edf3b85515cbf39",
          "commitAuthorOld": "Xiaoyu Yao",
          "daysBetweenCommits": 436.24,
          "commitsBetweenForRepo": 3917,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,80 +1,95 @@\n   private IOStreamPair doSaslHandshake(InetAddress addr,\n       OutputStream underlyingOut, InputStream underlyingIn, String userName,\n-      Map\u003cString, String\u003e saslProps,\n-      CallbackHandler callbackHandler) throws IOException {\n+      Map\u003cString, String\u003e saslProps, CallbackHandler callbackHandler,\n+      Token\u003cBlockTokenIdentifier\u003e accessToken) throws IOException {\n \n     DataOutputStream out \u003d new DataOutputStream(underlyingOut);\n     DataInputStream in \u003d new DataInputStream(underlyingIn);\n \n     SaslParticipant sasl\u003d SaslParticipant.createClientSaslParticipant(userName,\n         saslProps, callbackHandler);\n \n     out.writeInt(SASL_TRANSFER_MAGIC_NUMBER);\n     out.flush();\n \n     try {\n       // Start of handshake - \"initial response\" in SASL terminology.\n-      sendSaslMessage(out, new byte[0]);\n+      // The handshake secret can be null, this happens when client is running\n+      // a new version but the cluster does not have this feature. In which case\n+      // there will be no encrypted secret sent from NN.\n+      byte[] handshakeSecret \u003d accessToken.getDnHandshakeSecret();\n+      if (handshakeSecret \u003d\u003d null || handshakeSecret.length \u003d\u003d 0) {\n+        LOG.debug(\"Handshake secret is null, sending without \"\n+            + \"handshake secret.\");\n+        sendSaslMessage(out, new byte[0]);\n+      } else {\n+        LOG.debug(\"Sending handshake secret.\");\n+        BlockTokenIdentifier identifier \u003d new BlockTokenIdentifier();\n+        identifier.readFields(new DataInputStream(\n+            new ByteArrayInputStream(accessToken.getIdentifier())));\n+        String bpid \u003d identifier.getBlockPoolId();\n+        sendSaslMessageHandshakeSecret(out, new byte[0], handshakeSecret, bpid);\n+      }\n \n       // step 1\n       byte[] remoteResponse \u003d readSaslMessage(in);\n       byte[] localResponse \u003d sasl.evaluateChallengeOrResponse(remoteResponse);\n       List\u003cCipherOption\u003e cipherOptions \u003d null;\n       String cipherSuites \u003d conf.get(\n           DFS_ENCRYPT_DATA_TRANSFER_CIPHER_SUITES_KEY);\n       if (requestedQopContainsPrivacy(saslProps)) {\n         // Negotiate cipher suites if configured.  Currently, the only supported\n         // cipher suite is AES/CTR/NoPadding, but the protocol allows multiple\n         // values for future expansion.\n         if (cipherSuites !\u003d null \u0026\u0026 !cipherSuites.isEmpty()) {\n           if (!cipherSuites.equals(CipherSuite.AES_CTR_NOPADDING.getName())) {\n             throw new IOException(String.format(\"Invalid cipher suite, %s\u003d%s\",\n                 DFS_ENCRYPT_DATA_TRANSFER_CIPHER_SUITES_KEY, cipherSuites));\n           }\n           CipherOption option \u003d new CipherOption(CipherSuite.AES_CTR_NOPADDING);\n           cipherOptions \u003d Lists.newArrayListWithCapacity(1);\n           cipherOptions.add(option);\n         }\n       }\n       sendSaslMessageAndNegotiationCipherOptions(out, localResponse,\n           cipherOptions);\n \n       // step 2 (client-side only)\n       SaslResponseWithNegotiatedCipherOption response \u003d\n           readSaslMessageAndNegotiatedCipherOption(in);\n       localResponse \u003d sasl.evaluateChallengeOrResponse(response.payload);\n       assert localResponse \u003d\u003d null;\n \n       // SASL handshake is complete\n       checkSaslComplete(sasl, saslProps);\n \n       CipherOption cipherOption \u003d null;\n       if (sasl.isNegotiatedQopPrivacy()) {\n         // Unwrap the negotiated cipher option\n         cipherOption \u003d unwrap(response.cipherOption, sasl);\n         if (LOG.isDebugEnabled()) {\n           if (cipherOption \u003d\u003d null) {\n             // No cipher suite is negotiated\n             if (cipherSuites !\u003d null \u0026\u0026 !cipherSuites.isEmpty()) {\n               // the client accepts some cipher suites, but the server does not.\n               LOG.debug(\"Client accepts cipher suites {}, \"\n                       + \"but server {} does not accept any of them\",\n                   cipherSuites, addr.toString());\n             }\n           } else {\n             LOG.debug(\"Client using cipher suite {} with server {}\",\n                 cipherOption.getCipherSuite().getName(), addr.toString());\n           }\n         }\n       }\n \n       // If negotiated cipher option is not null, we will use it to create\n       // stream pair.\n       return cipherOption !\u003d null ? createStreamPair(\n           conf, cipherOption, underlyingOut, underlyingIn, false) :\n           sasl.createStreamPair(out, in);\n     } catch (IOException ioe) {\n       sendGenericSaslErrorMessage(out, ioe.getMessage());\n       throw ioe;\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private IOStreamPair doSaslHandshake(InetAddress addr,\n      OutputStream underlyingOut, InputStream underlyingIn, String userName,\n      Map\u003cString, String\u003e saslProps, CallbackHandler callbackHandler,\n      Token\u003cBlockTokenIdentifier\u003e accessToken) throws IOException {\n\n    DataOutputStream out \u003d new DataOutputStream(underlyingOut);\n    DataInputStream in \u003d new DataInputStream(underlyingIn);\n\n    SaslParticipant sasl\u003d SaslParticipant.createClientSaslParticipant(userName,\n        saslProps, callbackHandler);\n\n    out.writeInt(SASL_TRANSFER_MAGIC_NUMBER);\n    out.flush();\n\n    try {\n      // Start of handshake - \"initial response\" in SASL terminology.\n      // The handshake secret can be null, this happens when client is running\n      // a new version but the cluster does not have this feature. In which case\n      // there will be no encrypted secret sent from NN.\n      byte[] handshakeSecret \u003d accessToken.getDnHandshakeSecret();\n      if (handshakeSecret \u003d\u003d null || handshakeSecret.length \u003d\u003d 0) {\n        LOG.debug(\"Handshake secret is null, sending without \"\n            + \"handshake secret.\");\n        sendSaslMessage(out, new byte[0]);\n      } else {\n        LOG.debug(\"Sending handshake secret.\");\n        BlockTokenIdentifier identifier \u003d new BlockTokenIdentifier();\n        identifier.readFields(new DataInputStream(\n            new ByteArrayInputStream(accessToken.getIdentifier())));\n        String bpid \u003d identifier.getBlockPoolId();\n        sendSaslMessageHandshakeSecret(out, new byte[0], handshakeSecret, bpid);\n      }\n\n      // step 1\n      byte[] remoteResponse \u003d readSaslMessage(in);\n      byte[] localResponse \u003d sasl.evaluateChallengeOrResponse(remoteResponse);\n      List\u003cCipherOption\u003e cipherOptions \u003d null;\n      String cipherSuites \u003d conf.get(\n          DFS_ENCRYPT_DATA_TRANSFER_CIPHER_SUITES_KEY);\n      if (requestedQopContainsPrivacy(saslProps)) {\n        // Negotiate cipher suites if configured.  Currently, the only supported\n        // cipher suite is AES/CTR/NoPadding, but the protocol allows multiple\n        // values for future expansion.\n        if (cipherSuites !\u003d null \u0026\u0026 !cipherSuites.isEmpty()) {\n          if (!cipherSuites.equals(CipherSuite.AES_CTR_NOPADDING.getName())) {\n            throw new IOException(String.format(\"Invalid cipher suite, %s\u003d%s\",\n                DFS_ENCRYPT_DATA_TRANSFER_CIPHER_SUITES_KEY, cipherSuites));\n          }\n          CipherOption option \u003d new CipherOption(CipherSuite.AES_CTR_NOPADDING);\n          cipherOptions \u003d Lists.newArrayListWithCapacity(1);\n          cipherOptions.add(option);\n        }\n      }\n      sendSaslMessageAndNegotiationCipherOptions(out, localResponse,\n          cipherOptions);\n\n      // step 2 (client-side only)\n      SaslResponseWithNegotiatedCipherOption response \u003d\n          readSaslMessageAndNegotiatedCipherOption(in);\n      localResponse \u003d sasl.evaluateChallengeOrResponse(response.payload);\n      assert localResponse \u003d\u003d null;\n\n      // SASL handshake is complete\n      checkSaslComplete(sasl, saslProps);\n\n      CipherOption cipherOption \u003d null;\n      if (sasl.isNegotiatedQopPrivacy()) {\n        // Unwrap the negotiated cipher option\n        cipherOption \u003d unwrap(response.cipherOption, sasl);\n        if (LOG.isDebugEnabled()) {\n          if (cipherOption \u003d\u003d null) {\n            // No cipher suite is negotiated\n            if (cipherSuites !\u003d null \u0026\u0026 !cipherSuites.isEmpty()) {\n              // the client accepts some cipher suites, but the server does not.\n              LOG.debug(\"Client accepts cipher suites {}, \"\n                      + \"but server {} does not accept any of them\",\n                  cipherSuites, addr.toString());\n            }\n          } else {\n            LOG.debug(\"Client using cipher suite {} with server {}\",\n                cipherOption.getCipherSuite().getName(), addr.toString());\n          }\n        }\n      }\n\n      // If negotiated cipher option is not null, we will use it to create\n      // stream pair.\n      return cipherOption !\u003d null ? createStreamPair(\n          conf, cipherOption, underlyingOut, underlyingIn, false) :\n          sasl.createStreamPair(out, in);\n    } catch (IOException ioe) {\n      sendGenericSaslErrorMessage(out, ioe.getMessage());\n      throw ioe;\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/protocol/datatransfer/sasl/SaslDataTransferClient.java",
          "extendedDetails": {}
        }
      ]
    },
    "d1dd248b756e5a323ac885eefd3f81a639d6b86f": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-9854. Log cipher suite negotiation more verbosely. Contributed by Wei-Chiu Chuang.\n",
      "commitDate": "24/02/16 12:11 PM",
      "commitName": "d1dd248b756e5a323ac885eefd3f81a639d6b86f",
      "commitAuthor": "cnauroth",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-9854. Log cipher suite negotiation more verbosely. Contributed by Wei-Chiu Chuang.\n",
          "commitDate": "24/02/16 12:11 PM",
          "commitName": "d1dd248b756e5a323ac885eefd3f81a639d6b86f",
          "commitAuthor": "cnauroth",
          "commitDateOld": "03/10/15 11:38 AM",
          "commitNameOld": "7136e8c5582dc4061b566cb9f11a0d6a6d08bb93",
          "commitAuthorOld": "Haohui Mai",
          "daysBetweenCommits": 144.06,
          "commitsBetweenForRepo": 987,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,65 +1,80 @@\n-  private IOStreamPair doSaslHandshake(OutputStream underlyingOut,\n-      InputStream underlyingIn, String userName, Map\u003cString, String\u003e saslProps,\n+  private IOStreamPair doSaslHandshake(InetAddress addr,\n+      OutputStream underlyingOut, InputStream underlyingIn, String userName,\n+      Map\u003cString, String\u003e saslProps,\n       CallbackHandler callbackHandler) throws IOException {\n \n     DataOutputStream out \u003d new DataOutputStream(underlyingOut);\n     DataInputStream in \u003d new DataInputStream(underlyingIn);\n \n     SaslParticipant sasl\u003d SaslParticipant.createClientSaslParticipant(userName,\n         saslProps, callbackHandler);\n \n     out.writeInt(SASL_TRANSFER_MAGIC_NUMBER);\n     out.flush();\n \n     try {\n       // Start of handshake - \"initial response\" in SASL terminology.\n       sendSaslMessage(out, new byte[0]);\n \n       // step 1\n       byte[] remoteResponse \u003d readSaslMessage(in);\n       byte[] localResponse \u003d sasl.evaluateChallengeOrResponse(remoteResponse);\n       List\u003cCipherOption\u003e cipherOptions \u003d null;\n+      String cipherSuites \u003d conf.get(\n+          DFS_ENCRYPT_DATA_TRANSFER_CIPHER_SUITES_KEY);\n       if (requestedQopContainsPrivacy(saslProps)) {\n         // Negotiate cipher suites if configured.  Currently, the only supported\n         // cipher suite is AES/CTR/NoPadding, but the protocol allows multiple\n         // values for future expansion.\n-        String cipherSuites \u003d conf.get(\n-            DFS_ENCRYPT_DATA_TRANSFER_CIPHER_SUITES_KEY);\n         if (cipherSuites !\u003d null \u0026\u0026 !cipherSuites.isEmpty()) {\n           if (!cipherSuites.equals(CipherSuite.AES_CTR_NOPADDING.getName())) {\n             throw new IOException(String.format(\"Invalid cipher suite, %s\u003d%s\",\n                 DFS_ENCRYPT_DATA_TRANSFER_CIPHER_SUITES_KEY, cipherSuites));\n           }\n           CipherOption option \u003d new CipherOption(CipherSuite.AES_CTR_NOPADDING);\n           cipherOptions \u003d Lists.newArrayListWithCapacity(1);\n           cipherOptions.add(option);\n         }\n       }\n       sendSaslMessageAndNegotiationCipherOptions(out, localResponse,\n           cipherOptions);\n \n       // step 2 (client-side only)\n       SaslResponseWithNegotiatedCipherOption response \u003d\n           readSaslMessageAndNegotiatedCipherOption(in);\n       localResponse \u003d sasl.evaluateChallengeOrResponse(response.payload);\n       assert localResponse \u003d\u003d null;\n \n       // SASL handshake is complete\n       checkSaslComplete(sasl, saslProps);\n \n       CipherOption cipherOption \u003d null;\n       if (sasl.isNegotiatedQopPrivacy()) {\n         // Unwrap the negotiated cipher option\n         cipherOption \u003d unwrap(response.cipherOption, sasl);\n+        if (LOG.isDebugEnabled()) {\n+          if (cipherOption \u003d\u003d null) {\n+            // No cipher suite is negotiated\n+            if (cipherSuites !\u003d null \u0026\u0026 !cipherSuites.isEmpty()) {\n+              // the client accepts some cipher suites, but the server does not.\n+              LOG.debug(\"Client accepts cipher suites {}, \"\n+                      + \"but server {} does not accept any of them\",\n+                  cipherSuites, addr.toString());\n+            }\n+          } else {\n+            LOG.debug(\"Client using cipher suite {} with server {}\",\n+                cipherOption.getCipherSuite().getName(), addr.toString());\n+          }\n+        }\n       }\n \n       // If negotiated cipher option is not null, we will use it to create\n       // stream pair.\n       return cipherOption !\u003d null ? createStreamPair(\n           conf, cipherOption, underlyingOut, underlyingIn, false) :\n           sasl.createStreamPair(out, in);\n     } catch (IOException ioe) {\n       sendGenericSaslErrorMessage(out, ioe.getMessage());\n       throw ioe;\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private IOStreamPair doSaslHandshake(InetAddress addr,\n      OutputStream underlyingOut, InputStream underlyingIn, String userName,\n      Map\u003cString, String\u003e saslProps,\n      CallbackHandler callbackHandler) throws IOException {\n\n    DataOutputStream out \u003d new DataOutputStream(underlyingOut);\n    DataInputStream in \u003d new DataInputStream(underlyingIn);\n\n    SaslParticipant sasl\u003d SaslParticipant.createClientSaslParticipant(userName,\n        saslProps, callbackHandler);\n\n    out.writeInt(SASL_TRANSFER_MAGIC_NUMBER);\n    out.flush();\n\n    try {\n      // Start of handshake - \"initial response\" in SASL terminology.\n      sendSaslMessage(out, new byte[0]);\n\n      // step 1\n      byte[] remoteResponse \u003d readSaslMessage(in);\n      byte[] localResponse \u003d sasl.evaluateChallengeOrResponse(remoteResponse);\n      List\u003cCipherOption\u003e cipherOptions \u003d null;\n      String cipherSuites \u003d conf.get(\n          DFS_ENCRYPT_DATA_TRANSFER_CIPHER_SUITES_KEY);\n      if (requestedQopContainsPrivacy(saslProps)) {\n        // Negotiate cipher suites if configured.  Currently, the only supported\n        // cipher suite is AES/CTR/NoPadding, but the protocol allows multiple\n        // values for future expansion.\n        if (cipherSuites !\u003d null \u0026\u0026 !cipherSuites.isEmpty()) {\n          if (!cipherSuites.equals(CipherSuite.AES_CTR_NOPADDING.getName())) {\n            throw new IOException(String.format(\"Invalid cipher suite, %s\u003d%s\",\n                DFS_ENCRYPT_DATA_TRANSFER_CIPHER_SUITES_KEY, cipherSuites));\n          }\n          CipherOption option \u003d new CipherOption(CipherSuite.AES_CTR_NOPADDING);\n          cipherOptions \u003d Lists.newArrayListWithCapacity(1);\n          cipherOptions.add(option);\n        }\n      }\n      sendSaslMessageAndNegotiationCipherOptions(out, localResponse,\n          cipherOptions);\n\n      // step 2 (client-side only)\n      SaslResponseWithNegotiatedCipherOption response \u003d\n          readSaslMessageAndNegotiatedCipherOption(in);\n      localResponse \u003d sasl.evaluateChallengeOrResponse(response.payload);\n      assert localResponse \u003d\u003d null;\n\n      // SASL handshake is complete\n      checkSaslComplete(sasl, saslProps);\n\n      CipherOption cipherOption \u003d null;\n      if (sasl.isNegotiatedQopPrivacy()) {\n        // Unwrap the negotiated cipher option\n        cipherOption \u003d unwrap(response.cipherOption, sasl);\n        if (LOG.isDebugEnabled()) {\n          if (cipherOption \u003d\u003d null) {\n            // No cipher suite is negotiated\n            if (cipherSuites !\u003d null \u0026\u0026 !cipherSuites.isEmpty()) {\n              // the client accepts some cipher suites, but the server does not.\n              LOG.debug(\"Client accepts cipher suites {}, \"\n                      + \"but server {} does not accept any of them\",\n                  cipherSuites, addr.toString());\n            }\n          } else {\n            LOG.debug(\"Client using cipher suite {} with server {}\",\n                cipherOption.getCipherSuite().getName(), addr.toString());\n          }\n        }\n      }\n\n      // If negotiated cipher option is not null, we will use it to create\n      // stream pair.\n      return cipherOption !\u003d null ? createStreamPair(\n          conf, cipherOption, underlyingOut, underlyingIn, false) :\n          sasl.createStreamPair(out, in);\n    } catch (IOException ioe) {\n      sendGenericSaslErrorMessage(out, ioe.getMessage());\n      throw ioe;\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/protocol/datatransfer/sasl/SaslDataTransferClient.java",
          "extendedDetails": {
            "oldValue": "[underlyingOut-OutputStream, underlyingIn-InputStream, userName-String, saslProps-Map\u003cString,String\u003e, callbackHandler-CallbackHandler]",
            "newValue": "[addr-InetAddress, underlyingOut-OutputStream, underlyingIn-InputStream, userName-String, saslProps-Map\u003cString,String\u003e, callbackHandler-CallbackHandler]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-9854. Log cipher suite negotiation more verbosely. Contributed by Wei-Chiu Chuang.\n",
          "commitDate": "24/02/16 12:11 PM",
          "commitName": "d1dd248b756e5a323ac885eefd3f81a639d6b86f",
          "commitAuthor": "cnauroth",
          "commitDateOld": "03/10/15 11:38 AM",
          "commitNameOld": "7136e8c5582dc4061b566cb9f11a0d6a6d08bb93",
          "commitAuthorOld": "Haohui Mai",
          "daysBetweenCommits": 144.06,
          "commitsBetweenForRepo": 987,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,65 +1,80 @@\n-  private IOStreamPair doSaslHandshake(OutputStream underlyingOut,\n-      InputStream underlyingIn, String userName, Map\u003cString, String\u003e saslProps,\n+  private IOStreamPair doSaslHandshake(InetAddress addr,\n+      OutputStream underlyingOut, InputStream underlyingIn, String userName,\n+      Map\u003cString, String\u003e saslProps,\n       CallbackHandler callbackHandler) throws IOException {\n \n     DataOutputStream out \u003d new DataOutputStream(underlyingOut);\n     DataInputStream in \u003d new DataInputStream(underlyingIn);\n \n     SaslParticipant sasl\u003d SaslParticipant.createClientSaslParticipant(userName,\n         saslProps, callbackHandler);\n \n     out.writeInt(SASL_TRANSFER_MAGIC_NUMBER);\n     out.flush();\n \n     try {\n       // Start of handshake - \"initial response\" in SASL terminology.\n       sendSaslMessage(out, new byte[0]);\n \n       // step 1\n       byte[] remoteResponse \u003d readSaslMessage(in);\n       byte[] localResponse \u003d sasl.evaluateChallengeOrResponse(remoteResponse);\n       List\u003cCipherOption\u003e cipherOptions \u003d null;\n+      String cipherSuites \u003d conf.get(\n+          DFS_ENCRYPT_DATA_TRANSFER_CIPHER_SUITES_KEY);\n       if (requestedQopContainsPrivacy(saslProps)) {\n         // Negotiate cipher suites if configured.  Currently, the only supported\n         // cipher suite is AES/CTR/NoPadding, but the protocol allows multiple\n         // values for future expansion.\n-        String cipherSuites \u003d conf.get(\n-            DFS_ENCRYPT_DATA_TRANSFER_CIPHER_SUITES_KEY);\n         if (cipherSuites !\u003d null \u0026\u0026 !cipherSuites.isEmpty()) {\n           if (!cipherSuites.equals(CipherSuite.AES_CTR_NOPADDING.getName())) {\n             throw new IOException(String.format(\"Invalid cipher suite, %s\u003d%s\",\n                 DFS_ENCRYPT_DATA_TRANSFER_CIPHER_SUITES_KEY, cipherSuites));\n           }\n           CipherOption option \u003d new CipherOption(CipherSuite.AES_CTR_NOPADDING);\n           cipherOptions \u003d Lists.newArrayListWithCapacity(1);\n           cipherOptions.add(option);\n         }\n       }\n       sendSaslMessageAndNegotiationCipherOptions(out, localResponse,\n           cipherOptions);\n \n       // step 2 (client-side only)\n       SaslResponseWithNegotiatedCipherOption response \u003d\n           readSaslMessageAndNegotiatedCipherOption(in);\n       localResponse \u003d sasl.evaluateChallengeOrResponse(response.payload);\n       assert localResponse \u003d\u003d null;\n \n       // SASL handshake is complete\n       checkSaslComplete(sasl, saslProps);\n \n       CipherOption cipherOption \u003d null;\n       if (sasl.isNegotiatedQopPrivacy()) {\n         // Unwrap the negotiated cipher option\n         cipherOption \u003d unwrap(response.cipherOption, sasl);\n+        if (LOG.isDebugEnabled()) {\n+          if (cipherOption \u003d\u003d null) {\n+            // No cipher suite is negotiated\n+            if (cipherSuites !\u003d null \u0026\u0026 !cipherSuites.isEmpty()) {\n+              // the client accepts some cipher suites, but the server does not.\n+              LOG.debug(\"Client accepts cipher suites {}, \"\n+                      + \"but server {} does not accept any of them\",\n+                  cipherSuites, addr.toString());\n+            }\n+          } else {\n+            LOG.debug(\"Client using cipher suite {} with server {}\",\n+                cipherOption.getCipherSuite().getName(), addr.toString());\n+          }\n+        }\n       }\n \n       // If negotiated cipher option is not null, we will use it to create\n       // stream pair.\n       return cipherOption !\u003d null ? createStreamPair(\n           conf, cipherOption, underlyingOut, underlyingIn, false) :\n           sasl.createStreamPair(out, in);\n     } catch (IOException ioe) {\n       sendGenericSaslErrorMessage(out, ioe.getMessage());\n       throw ioe;\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private IOStreamPair doSaslHandshake(InetAddress addr,\n      OutputStream underlyingOut, InputStream underlyingIn, String userName,\n      Map\u003cString, String\u003e saslProps,\n      CallbackHandler callbackHandler) throws IOException {\n\n    DataOutputStream out \u003d new DataOutputStream(underlyingOut);\n    DataInputStream in \u003d new DataInputStream(underlyingIn);\n\n    SaslParticipant sasl\u003d SaslParticipant.createClientSaslParticipant(userName,\n        saslProps, callbackHandler);\n\n    out.writeInt(SASL_TRANSFER_MAGIC_NUMBER);\n    out.flush();\n\n    try {\n      // Start of handshake - \"initial response\" in SASL terminology.\n      sendSaslMessage(out, new byte[0]);\n\n      // step 1\n      byte[] remoteResponse \u003d readSaslMessage(in);\n      byte[] localResponse \u003d sasl.evaluateChallengeOrResponse(remoteResponse);\n      List\u003cCipherOption\u003e cipherOptions \u003d null;\n      String cipherSuites \u003d conf.get(\n          DFS_ENCRYPT_DATA_TRANSFER_CIPHER_SUITES_KEY);\n      if (requestedQopContainsPrivacy(saslProps)) {\n        // Negotiate cipher suites if configured.  Currently, the only supported\n        // cipher suite is AES/CTR/NoPadding, but the protocol allows multiple\n        // values for future expansion.\n        if (cipherSuites !\u003d null \u0026\u0026 !cipherSuites.isEmpty()) {\n          if (!cipherSuites.equals(CipherSuite.AES_CTR_NOPADDING.getName())) {\n            throw new IOException(String.format(\"Invalid cipher suite, %s\u003d%s\",\n                DFS_ENCRYPT_DATA_TRANSFER_CIPHER_SUITES_KEY, cipherSuites));\n          }\n          CipherOption option \u003d new CipherOption(CipherSuite.AES_CTR_NOPADDING);\n          cipherOptions \u003d Lists.newArrayListWithCapacity(1);\n          cipherOptions.add(option);\n        }\n      }\n      sendSaslMessageAndNegotiationCipherOptions(out, localResponse,\n          cipherOptions);\n\n      // step 2 (client-side only)\n      SaslResponseWithNegotiatedCipherOption response \u003d\n          readSaslMessageAndNegotiatedCipherOption(in);\n      localResponse \u003d sasl.evaluateChallengeOrResponse(response.payload);\n      assert localResponse \u003d\u003d null;\n\n      // SASL handshake is complete\n      checkSaslComplete(sasl, saslProps);\n\n      CipherOption cipherOption \u003d null;\n      if (sasl.isNegotiatedQopPrivacy()) {\n        // Unwrap the negotiated cipher option\n        cipherOption \u003d unwrap(response.cipherOption, sasl);\n        if (LOG.isDebugEnabled()) {\n          if (cipherOption \u003d\u003d null) {\n            // No cipher suite is negotiated\n            if (cipherSuites !\u003d null \u0026\u0026 !cipherSuites.isEmpty()) {\n              // the client accepts some cipher suites, but the server does not.\n              LOG.debug(\"Client accepts cipher suites {}, \"\n                      + \"but server {} does not accept any of them\",\n                  cipherSuites, addr.toString());\n            }\n          } else {\n            LOG.debug(\"Client using cipher suite {} with server {}\",\n                cipherOption.getCipherSuite().getName(), addr.toString());\n          }\n        }\n      }\n\n      // If negotiated cipher option is not null, we will use it to create\n      // stream pair.\n      return cipherOption !\u003d null ? createStreamPair(\n          conf, cipherOption, underlyingOut, underlyingIn, false) :\n          sasl.createStreamPair(out, in);\n    } catch (IOException ioe) {\n      sendGenericSaslErrorMessage(out, ioe.getMessage());\n      throw ioe;\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/protocol/datatransfer/sasl/SaslDataTransferClient.java",
          "extendedDetails": {}
        }
      ]
    },
    "ed78b14ebc9a21bb57ccd088e8b49bfa457a396f": {
      "type": "Yfilerename",
      "commitMessage": "HDFS-9002. Move o.a.h.hdfs.net/*Peer classes to hdfs-client. Contributed by Mingliang Liu.\n",
      "commitDate": "03/09/15 3:32 PM",
      "commitName": "ed78b14ebc9a21bb57ccd088e8b49bfa457a396f",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "03/09/15 1:26 PM",
      "commitNameOld": "c2d2c1802a11e3e11a953b23b0eccbf4d107de59",
      "commitAuthorOld": "Jakob Homan",
      "daysBetweenCommits": 0.09,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private IOStreamPair doSaslHandshake(OutputStream underlyingOut,\n      InputStream underlyingIn, String userName, Map\u003cString, String\u003e saslProps,\n      CallbackHandler callbackHandler) throws IOException {\n\n    DataOutputStream out \u003d new DataOutputStream(underlyingOut);\n    DataInputStream in \u003d new DataInputStream(underlyingIn);\n\n    SaslParticipant sasl\u003d SaslParticipant.createClientSaslParticipant(userName,\n      saslProps, callbackHandler);\n\n    out.writeInt(SASL_TRANSFER_MAGIC_NUMBER);\n    out.flush();\n\n    try {\n      // Start of handshake - \"initial response\" in SASL terminology.\n      sendSaslMessage(out, new byte[0]);\n\n      // step 1\n      byte[] remoteResponse \u003d readSaslMessage(in);\n      byte[] localResponse \u003d sasl.evaluateChallengeOrResponse(remoteResponse);\n      List\u003cCipherOption\u003e cipherOptions \u003d null;\n      if (requestedQopContainsPrivacy(saslProps)) {\n        // Negotiate cipher suites if configured.  Currently, the only supported\n        // cipher suite is AES/CTR/NoPadding, but the protocol allows multiple\n        // values for future expansion.\n        String cipherSuites \u003d conf.get(\n            DFS_ENCRYPT_DATA_TRANSFER_CIPHER_SUITES_KEY);\n        if (cipherSuites !\u003d null \u0026\u0026 !cipherSuites.isEmpty()) {\n          if (!cipherSuites.equals(CipherSuite.AES_CTR_NOPADDING.getName())) {\n            throw new IOException(String.format(\"Invalid cipher suite, %s\u003d%s\",\n                DFS_ENCRYPT_DATA_TRANSFER_CIPHER_SUITES_KEY, cipherSuites));\n          }\n          CipherOption option \u003d new CipherOption(CipherSuite.AES_CTR_NOPADDING);\n          cipherOptions \u003d Lists.newArrayListWithCapacity(1);\n          cipherOptions.add(option);\n        }\n      }\n      sendSaslMessageAndNegotiationCipherOptions(out, localResponse, \n          cipherOptions);\n\n      // step 2 (client-side only)\n      SaslResponseWithNegotiatedCipherOption response \u003d \n          readSaslMessageAndNegotiatedCipherOption(in);\n      localResponse \u003d sasl.evaluateChallengeOrResponse(response.payload);\n      assert localResponse \u003d\u003d null;\n\n      // SASL handshake is complete\n      checkSaslComplete(sasl, saslProps);\n\n      CipherOption cipherOption \u003d null;\n      if (sasl.isNegotiatedQopPrivacy()) {\n        // Unwrap the negotiated cipher option\n        cipherOption \u003d unwrap(response.cipherOption, sasl);\n      }\n\n      // If negotiated cipher option is not null, we will use it to create \n      // stream pair.\n      return cipherOption !\u003d null ? createStreamPair(\n          conf, cipherOption, underlyingOut, underlyingIn, false) : \n            sasl.createStreamPair(out, in);\n    } catch (IOException ioe) {\n      sendGenericSaslErrorMessage(out, ioe.getMessage());\n      throw ioe;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/protocol/datatransfer/sasl/SaslDataTransferClient.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/protocol/datatransfer/sasl/SaslDataTransferClient.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/protocol/datatransfer/sasl/SaslDataTransferClient.java"
      }
    },
    "5573b3476a5a6fce0ac99c654a9a9ec90f744a20": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7313. Support optional configuration of AES cipher suite on DataTransferProtocol. Contributed by Chris Nauroth.\n",
      "commitDate": "30/10/14 10:48 PM",
      "commitName": "5573b3476a5a6fce0ac99c654a9a9ec90f744a20",
      "commitAuthor": "cnauroth",
      "commitDateOld": "28/10/14 6:11 AM",
      "commitNameOld": "58c0bb9ed9f4a2491395b63c68046562a73526c9",
      "commitAuthorOld": "yliu",
      "daysBetweenCommits": 2.69,
      "commitsBetweenForRepo": 42,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,55 +1,65 @@\n   private IOStreamPair doSaslHandshake(OutputStream underlyingOut,\n       InputStream underlyingIn, String userName, Map\u003cString, String\u003e saslProps,\n       CallbackHandler callbackHandler) throws IOException {\n \n     DataOutputStream out \u003d new DataOutputStream(underlyingOut);\n     DataInputStream in \u003d new DataInputStream(underlyingIn);\n \n     SaslParticipant sasl\u003d SaslParticipant.createClientSaslParticipant(userName,\n       saslProps, callbackHandler);\n \n     out.writeInt(SASL_TRANSFER_MAGIC_NUMBER);\n     out.flush();\n \n     try {\n       // Start of handshake - \"initial response\" in SASL terminology.\n       sendSaslMessage(out, new byte[0]);\n \n       // step 1\n       byte[] remoteResponse \u003d readSaslMessage(in);\n       byte[] localResponse \u003d sasl.evaluateChallengeOrResponse(remoteResponse);\n       List\u003cCipherOption\u003e cipherOptions \u003d null;\n       if (requestedQopContainsPrivacy(saslProps)) {\n-        // Negotiation cipher options\n-        CipherOption option \u003d new CipherOption(CipherSuite.AES_CTR_NOPADDING);\n-        cipherOptions \u003d Lists.newArrayListWithCapacity(1);\n-        cipherOptions.add(option);\n+        // Negotiate cipher suites if configured.  Currently, the only supported\n+        // cipher suite is AES/CTR/NoPadding, but the protocol allows multiple\n+        // values for future expansion.\n+        String cipherSuites \u003d conf.get(\n+            DFS_ENCRYPT_DATA_TRANSFER_CIPHER_SUITES_KEY);\n+        if (cipherSuites !\u003d null \u0026\u0026 !cipherSuites.isEmpty()) {\n+          if (!cipherSuites.equals(CipherSuite.AES_CTR_NOPADDING.getName())) {\n+            throw new IOException(String.format(\"Invalid cipher suite, %s\u003d%s\",\n+                DFS_ENCRYPT_DATA_TRANSFER_CIPHER_SUITES_KEY, cipherSuites));\n+          }\n+          CipherOption option \u003d new CipherOption(CipherSuite.AES_CTR_NOPADDING);\n+          cipherOptions \u003d Lists.newArrayListWithCapacity(1);\n+          cipherOptions.add(option);\n+        }\n       }\n       sendSaslMessageAndNegotiationCipherOptions(out, localResponse, \n           cipherOptions);\n \n       // step 2 (client-side only)\n       SaslResponseWithNegotiatedCipherOption response \u003d \n           readSaslMessageAndNegotiatedCipherOption(in);\n       localResponse \u003d sasl.evaluateChallengeOrResponse(response.payload);\n       assert localResponse \u003d\u003d null;\n \n       // SASL handshake is complete\n       checkSaslComplete(sasl, saslProps);\n \n       CipherOption cipherOption \u003d null;\n       if (sasl.isNegotiatedQopPrivacy()) {\n         // Unwrap the negotiated cipher option\n         cipherOption \u003d unwrap(response.cipherOption, sasl);\n       }\n \n       // If negotiated cipher option is not null, we will use it to create \n       // stream pair.\n       return cipherOption !\u003d null ? createStreamPair(\n           conf, cipherOption, underlyingOut, underlyingIn, false) : \n             sasl.createStreamPair(out, in);\n     } catch (IOException ioe) {\n       sendGenericSaslErrorMessage(out, ioe.getMessage());\n       throw ioe;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private IOStreamPair doSaslHandshake(OutputStream underlyingOut,\n      InputStream underlyingIn, String userName, Map\u003cString, String\u003e saslProps,\n      CallbackHandler callbackHandler) throws IOException {\n\n    DataOutputStream out \u003d new DataOutputStream(underlyingOut);\n    DataInputStream in \u003d new DataInputStream(underlyingIn);\n\n    SaslParticipant sasl\u003d SaslParticipant.createClientSaslParticipant(userName,\n      saslProps, callbackHandler);\n\n    out.writeInt(SASL_TRANSFER_MAGIC_NUMBER);\n    out.flush();\n\n    try {\n      // Start of handshake - \"initial response\" in SASL terminology.\n      sendSaslMessage(out, new byte[0]);\n\n      // step 1\n      byte[] remoteResponse \u003d readSaslMessage(in);\n      byte[] localResponse \u003d sasl.evaluateChallengeOrResponse(remoteResponse);\n      List\u003cCipherOption\u003e cipherOptions \u003d null;\n      if (requestedQopContainsPrivacy(saslProps)) {\n        // Negotiate cipher suites if configured.  Currently, the only supported\n        // cipher suite is AES/CTR/NoPadding, but the protocol allows multiple\n        // values for future expansion.\n        String cipherSuites \u003d conf.get(\n            DFS_ENCRYPT_DATA_TRANSFER_CIPHER_SUITES_KEY);\n        if (cipherSuites !\u003d null \u0026\u0026 !cipherSuites.isEmpty()) {\n          if (!cipherSuites.equals(CipherSuite.AES_CTR_NOPADDING.getName())) {\n            throw new IOException(String.format(\"Invalid cipher suite, %s\u003d%s\",\n                DFS_ENCRYPT_DATA_TRANSFER_CIPHER_SUITES_KEY, cipherSuites));\n          }\n          CipherOption option \u003d new CipherOption(CipherSuite.AES_CTR_NOPADDING);\n          cipherOptions \u003d Lists.newArrayListWithCapacity(1);\n          cipherOptions.add(option);\n        }\n      }\n      sendSaslMessageAndNegotiationCipherOptions(out, localResponse, \n          cipherOptions);\n\n      // step 2 (client-side only)\n      SaslResponseWithNegotiatedCipherOption response \u003d \n          readSaslMessageAndNegotiatedCipherOption(in);\n      localResponse \u003d sasl.evaluateChallengeOrResponse(response.payload);\n      assert localResponse \u003d\u003d null;\n\n      // SASL handshake is complete\n      checkSaslComplete(sasl, saslProps);\n\n      CipherOption cipherOption \u003d null;\n      if (sasl.isNegotiatedQopPrivacy()) {\n        // Unwrap the negotiated cipher option\n        cipherOption \u003d unwrap(response.cipherOption, sasl);\n      }\n\n      // If negotiated cipher option is not null, we will use it to create \n      // stream pair.\n      return cipherOption !\u003d null ? createStreamPair(\n          conf, cipherOption, underlyingOut, underlyingIn, false) : \n            sasl.createStreamPair(out, in);\n    } catch (IOException ioe) {\n      sendGenericSaslErrorMessage(out, ioe.getMessage());\n      throw ioe;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/protocol/datatransfer/sasl/SaslDataTransferClient.java",
      "extendedDetails": {}
    },
    "58c0bb9ed9f4a2491395b63c68046562a73526c9": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6606. Optimize HDFS Encrypted Transport performance. (yliu)\n",
      "commitDate": "28/10/14 6:11 AM",
      "commitName": "58c0bb9ed9f4a2491395b63c68046562a73526c9",
      "commitAuthor": "yliu",
      "commitDateOld": "19/09/14 9:23 PM",
      "commitNameOld": "f85cc14eb49a46e81d2edcdc1ffe4d0852f193a5",
      "commitAuthorOld": "cnauroth",
      "daysBetweenCommits": 38.37,
      "commitsBetweenForRepo": 354,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,55 @@\n   private IOStreamPair doSaslHandshake(OutputStream underlyingOut,\n       InputStream underlyingIn, String userName, Map\u003cString, String\u003e saslProps,\n       CallbackHandler callbackHandler) throws IOException {\n \n     DataOutputStream out \u003d new DataOutputStream(underlyingOut);\n     DataInputStream in \u003d new DataInputStream(underlyingIn);\n \n     SaslParticipant sasl\u003d SaslParticipant.createClientSaslParticipant(userName,\n       saslProps, callbackHandler);\n \n     out.writeInt(SASL_TRANSFER_MAGIC_NUMBER);\n     out.flush();\n \n     try {\n       // Start of handshake - \"initial response\" in SASL terminology.\n       sendSaslMessage(out, new byte[0]);\n \n       // step 1\n-      performSaslStep1(out, in, sasl);\n-\n-      // step 2 (client-side only)\n       byte[] remoteResponse \u003d readSaslMessage(in);\n       byte[] localResponse \u003d sasl.evaluateChallengeOrResponse(remoteResponse);\n+      List\u003cCipherOption\u003e cipherOptions \u003d null;\n+      if (requestedQopContainsPrivacy(saslProps)) {\n+        // Negotiation cipher options\n+        CipherOption option \u003d new CipherOption(CipherSuite.AES_CTR_NOPADDING);\n+        cipherOptions \u003d Lists.newArrayListWithCapacity(1);\n+        cipherOptions.add(option);\n+      }\n+      sendSaslMessageAndNegotiationCipherOptions(out, localResponse, \n+          cipherOptions);\n+\n+      // step 2 (client-side only)\n+      SaslResponseWithNegotiatedCipherOption response \u003d \n+          readSaslMessageAndNegotiatedCipherOption(in);\n+      localResponse \u003d sasl.evaluateChallengeOrResponse(response.payload);\n       assert localResponse \u003d\u003d null;\n \n       // SASL handshake is complete\n       checkSaslComplete(sasl, saslProps);\n \n-      return sasl.createStreamPair(out, in);\n+      CipherOption cipherOption \u003d null;\n+      if (sasl.isNegotiatedQopPrivacy()) {\n+        // Unwrap the negotiated cipher option\n+        cipherOption \u003d unwrap(response.cipherOption, sasl);\n+      }\n+\n+      // If negotiated cipher option is not null, we will use it to create \n+      // stream pair.\n+      return cipherOption !\u003d null ? createStreamPair(\n+          conf, cipherOption, underlyingOut, underlyingIn, false) : \n+            sasl.createStreamPair(out, in);\n     } catch (IOException ioe) {\n       sendGenericSaslErrorMessage(out, ioe.getMessage());\n       throw ioe;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private IOStreamPair doSaslHandshake(OutputStream underlyingOut,\n      InputStream underlyingIn, String userName, Map\u003cString, String\u003e saslProps,\n      CallbackHandler callbackHandler) throws IOException {\n\n    DataOutputStream out \u003d new DataOutputStream(underlyingOut);\n    DataInputStream in \u003d new DataInputStream(underlyingIn);\n\n    SaslParticipant sasl\u003d SaslParticipant.createClientSaslParticipant(userName,\n      saslProps, callbackHandler);\n\n    out.writeInt(SASL_TRANSFER_MAGIC_NUMBER);\n    out.flush();\n\n    try {\n      // Start of handshake - \"initial response\" in SASL terminology.\n      sendSaslMessage(out, new byte[0]);\n\n      // step 1\n      byte[] remoteResponse \u003d readSaslMessage(in);\n      byte[] localResponse \u003d sasl.evaluateChallengeOrResponse(remoteResponse);\n      List\u003cCipherOption\u003e cipherOptions \u003d null;\n      if (requestedQopContainsPrivacy(saslProps)) {\n        // Negotiation cipher options\n        CipherOption option \u003d new CipherOption(CipherSuite.AES_CTR_NOPADDING);\n        cipherOptions \u003d Lists.newArrayListWithCapacity(1);\n        cipherOptions.add(option);\n      }\n      sendSaslMessageAndNegotiationCipherOptions(out, localResponse, \n          cipherOptions);\n\n      // step 2 (client-side only)\n      SaslResponseWithNegotiatedCipherOption response \u003d \n          readSaslMessageAndNegotiatedCipherOption(in);\n      localResponse \u003d sasl.evaluateChallengeOrResponse(response.payload);\n      assert localResponse \u003d\u003d null;\n\n      // SASL handshake is complete\n      checkSaslComplete(sasl, saslProps);\n\n      CipherOption cipherOption \u003d null;\n      if (sasl.isNegotiatedQopPrivacy()) {\n        // Unwrap the negotiated cipher option\n        cipherOption \u003d unwrap(response.cipherOption, sasl);\n      }\n\n      // If negotiated cipher option is not null, we will use it to create \n      // stream pair.\n      return cipherOption !\u003d null ? createStreamPair(\n          conf, cipherOption, underlyingOut, underlyingIn, false) : \n            sasl.createStreamPair(out, in);\n    } catch (IOException ioe) {\n      sendGenericSaslErrorMessage(out, ioe.getMessage());\n      throw ioe;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/protocol/datatransfer/sasl/SaslDataTransferClient.java",
      "extendedDetails": {}
    },
    "3b54223c0f32d42a84436c670d80b791a8e9696d": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-2856. Fix block protocol so that Datanodes don\u0027t require root or jsvc. Contributed by Chris Nauroth.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1610474 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/07/14 11:10 AM",
      "commitName": "3b54223c0f32d42a84436c670d80b791a8e9696d",
      "commitAuthor": "Chris Nauroth",
      "diff": "@@ -0,0 +1,34 @@\n+  private IOStreamPair doSaslHandshake(OutputStream underlyingOut,\n+      InputStream underlyingIn, String userName, Map\u003cString, String\u003e saslProps,\n+      CallbackHandler callbackHandler) throws IOException {\n+\n+    DataOutputStream out \u003d new DataOutputStream(underlyingOut);\n+    DataInputStream in \u003d new DataInputStream(underlyingIn);\n+\n+    SaslParticipant sasl\u003d SaslParticipant.createClientSaslParticipant(userName,\n+      saslProps, callbackHandler);\n+\n+    out.writeInt(SASL_TRANSFER_MAGIC_NUMBER);\n+    out.flush();\n+\n+    try {\n+      // Start of handshake - \"initial response\" in SASL terminology.\n+      sendSaslMessage(out, new byte[0]);\n+\n+      // step 1\n+      performSaslStep1(out, in, sasl);\n+\n+      // step 2 (client-side only)\n+      byte[] remoteResponse \u003d readSaslMessage(in);\n+      byte[] localResponse \u003d sasl.evaluateChallengeOrResponse(remoteResponse);\n+      assert localResponse \u003d\u003d null;\n+\n+      // SASL handshake is complete\n+      checkSaslComplete(sasl, saslProps);\n+\n+      return sasl.createStreamPair(out, in);\n+    } catch (IOException ioe) {\n+      sendGenericSaslErrorMessage(out, ioe.getMessage());\n+      throw ioe;\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private IOStreamPair doSaslHandshake(OutputStream underlyingOut,\n      InputStream underlyingIn, String userName, Map\u003cString, String\u003e saslProps,\n      CallbackHandler callbackHandler) throws IOException {\n\n    DataOutputStream out \u003d new DataOutputStream(underlyingOut);\n    DataInputStream in \u003d new DataInputStream(underlyingIn);\n\n    SaslParticipant sasl\u003d SaslParticipant.createClientSaslParticipant(userName,\n      saslProps, callbackHandler);\n\n    out.writeInt(SASL_TRANSFER_MAGIC_NUMBER);\n    out.flush();\n\n    try {\n      // Start of handshake - \"initial response\" in SASL terminology.\n      sendSaslMessage(out, new byte[0]);\n\n      // step 1\n      performSaslStep1(out, in, sasl);\n\n      // step 2 (client-side only)\n      byte[] remoteResponse \u003d readSaslMessage(in);\n      byte[] localResponse \u003d sasl.evaluateChallengeOrResponse(remoteResponse);\n      assert localResponse \u003d\u003d null;\n\n      // SASL handshake is complete\n      checkSaslComplete(sasl, saslProps);\n\n      return sasl.createStreamPair(out, in);\n    } catch (IOException ioe) {\n      sendGenericSaslErrorMessage(out, ioe.getMessage());\n      throw ioe;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/protocol/datatransfer/sasl/SaslDataTransferClient.java"
    }
  }
}