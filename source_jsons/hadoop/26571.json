{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "TaskAttemptImpl.java",
  "functionName": "updateProgressSplits",
  "functionId": "updateProgressSplits",
  "sourceFilePath": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/job/impl/TaskAttemptImpl.java",
  "functionStartLine": 1756,
  "functionEndLine": 1793,
  "numCommitsSeen": 109,
  "timeTaken": 8503,
  "changeHistory": [
    "9d8d02b68b5ffc18e8f9f00db1750a80d3fc9061",
    "e8645636ce1721aa6dc3674fbc553a7bb3522fbe",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517"
  ],
  "changeHistoryShort": {
    "9d8d02b68b5ffc18e8f9f00db1750a80d3fc9061": "Ybodychange",
    "e8645636ce1721aa6dc3674fbc553a7bb3522fbe": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": "Yintroduced"
  },
  "changeHistoryDetails": {
    "9d8d02b68b5ffc18e8f9f00db1750a80d3fc9061": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-4025.  AM can crash if task attempt reports bogus progress value (Jason Lowe via bobby)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1302645 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/03/12 1:31 PM",
      "commitName": "9d8d02b68b5ffc18e8f9f00db1750a80d3fc9061",
      "commitAuthor": "Robert Joseph Evans",
      "commitDateOld": "06/03/12 3:21 PM",
      "commitNameOld": "c3a4de0ec0389064f5468180d1b9024f64b00f40",
      "commitAuthorOld": "Robert Joseph Evans",
      "daysBetweenCommits": 12.88,
      "commitsBetweenForRepo": 65,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,37 +1,38 @@\n   private void updateProgressSplits() {\n     double newProgress \u003d reportedStatus.progress;\n+    newProgress \u003d Math.max(Math.min(newProgress, 1.0D), 0.0D);\n     Counters counters \u003d reportedStatus.counters;\n     if (counters \u003d\u003d null)\n       return;\n \n     WrappedProgressSplitsBlock splitsBlock \u003d getProgressSplitBlock();\n     if (splitsBlock !\u003d null) {\n       long now \u003d clock.getTime();\n       long start \u003d getLaunchTime(); // TODO Ensure not 0\n \n       if (start !\u003d 0 \u0026\u0026 now - start \u003c\u003d Integer.MAX_VALUE) {\n         splitsBlock.getProgressWallclockTime().extend(newProgress,\n             (int) (now - start));\n       }\n \n       Counter cpuCounter \u003d counters.findCounter(TaskCounter.CPU_MILLISECONDS);\n       if (cpuCounter !\u003d null \u0026\u0026 cpuCounter.getValue() \u003c\u003d Integer.MAX_VALUE) {\n         splitsBlock.getProgressCPUTime().extend(newProgress,\n             (int) cpuCounter.getValue()); // long to int? TODO: FIX. Same below\n       }\n \n       Counter virtualBytes \u003d counters\n         .findCounter(TaskCounter.VIRTUAL_MEMORY_BYTES);\n       if (virtualBytes !\u003d null) {\n         splitsBlock.getProgressVirtualMemoryKbytes().extend(newProgress,\n             (int) (virtualBytes.getValue() / (MEMORY_SPLITS_RESOLUTION)));\n       }\n \n       Counter physicalBytes \u003d counters\n         .findCounter(TaskCounter.PHYSICAL_MEMORY_BYTES);\n       if (physicalBytes !\u003d null) {\n         splitsBlock.getProgressPhysicalMemoryKbytes().extend(newProgress,\n             (int) (physicalBytes.getValue() / (MEMORY_SPLITS_RESOLUTION)));\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void updateProgressSplits() {\n    double newProgress \u003d reportedStatus.progress;\n    newProgress \u003d Math.max(Math.min(newProgress, 1.0D), 0.0D);\n    Counters counters \u003d reportedStatus.counters;\n    if (counters \u003d\u003d null)\n      return;\n\n    WrappedProgressSplitsBlock splitsBlock \u003d getProgressSplitBlock();\n    if (splitsBlock !\u003d null) {\n      long now \u003d clock.getTime();\n      long start \u003d getLaunchTime(); // TODO Ensure not 0\n\n      if (start !\u003d 0 \u0026\u0026 now - start \u003c\u003d Integer.MAX_VALUE) {\n        splitsBlock.getProgressWallclockTime().extend(newProgress,\n            (int) (now - start));\n      }\n\n      Counter cpuCounter \u003d counters.findCounter(TaskCounter.CPU_MILLISECONDS);\n      if (cpuCounter !\u003d null \u0026\u0026 cpuCounter.getValue() \u003c\u003d Integer.MAX_VALUE) {\n        splitsBlock.getProgressCPUTime().extend(newProgress,\n            (int) cpuCounter.getValue()); // long to int? TODO: FIX. Same below\n      }\n\n      Counter virtualBytes \u003d counters\n        .findCounter(TaskCounter.VIRTUAL_MEMORY_BYTES);\n      if (virtualBytes !\u003d null) {\n        splitsBlock.getProgressVirtualMemoryKbytes().extend(newProgress,\n            (int) (virtualBytes.getValue() / (MEMORY_SPLITS_RESOLUTION)));\n      }\n\n      Counter physicalBytes \u003d counters\n        .findCounter(TaskCounter.PHYSICAL_MEMORY_BYTES);\n      if (physicalBytes !\u003d null) {\n        splitsBlock.getProgressPhysicalMemoryKbytes().extend(newProgress,\n            (int) (physicalBytes.getValue() / (MEMORY_SPLITS_RESOLUTION)));\n      }\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/job/impl/TaskAttemptImpl.java",
      "extendedDetails": {}
    },
    "e8645636ce1721aa6dc3674fbc553a7bb3522fbe": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3511. Removed a multitude of cloned/duplicate counters in the AM thereby reducing the AM heap size and preventing full GCs. (vinodkv)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1229347 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/01/12 1:04 PM",
      "commitName": "e8645636ce1721aa6dc3674fbc553a7bb3522fbe",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "04/01/12 9:19 PM",
      "commitNameOld": "03d46dc571bc5b0f1b3c0cb5daa52e7ee324dd54",
      "commitAuthorOld": "Siddharth Seth",
      "daysBetweenCommits": 4.66,
      "commitsBetweenForRepo": 18,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,37 @@\n   private void updateProgressSplits() {\n     double newProgress \u003d reportedStatus.progress;\n     Counters counters \u003d reportedStatus.counters;\n     if (counters \u003d\u003d null)\n       return;\n \n     WrappedProgressSplitsBlock splitsBlock \u003d getProgressSplitBlock();\n     if (splitsBlock !\u003d null) {\n       long now \u003d clock.getTime();\n       long start \u003d getLaunchTime(); // TODO Ensure not 0\n \n       if (start !\u003d 0 \u0026\u0026 now - start \u003c\u003d Integer.MAX_VALUE) {\n         splitsBlock.getProgressWallclockTime().extend(newProgress,\n             (int) (now - start));\n       }\n \n-      Counter cpuCounter \u003d counters.getCounter(\n-          TaskCounter.CPU_MILLISECONDS);\n+      Counter cpuCounter \u003d counters.findCounter(TaskCounter.CPU_MILLISECONDS);\n       if (cpuCounter !\u003d null \u0026\u0026 cpuCounter.getValue() \u003c\u003d Integer.MAX_VALUE) {\n         splitsBlock.getProgressCPUTime().extend(newProgress,\n-            (int) cpuCounter.getValue());\n+            (int) cpuCounter.getValue()); // long to int? TODO: FIX. Same below\n       }\n \n-      Counter virtualBytes \u003d counters.getCounter(\n-          TaskCounter.VIRTUAL_MEMORY_BYTES);\n+      Counter virtualBytes \u003d counters\n+        .findCounter(TaskCounter.VIRTUAL_MEMORY_BYTES);\n       if (virtualBytes !\u003d null) {\n         splitsBlock.getProgressVirtualMemoryKbytes().extend(newProgress,\n             (int) (virtualBytes.getValue() / (MEMORY_SPLITS_RESOLUTION)));\n       }\n \n-      Counter physicalBytes \u003d counters.getCounter(\n-          TaskCounter.PHYSICAL_MEMORY_BYTES);\n+      Counter physicalBytes \u003d counters\n+        .findCounter(TaskCounter.PHYSICAL_MEMORY_BYTES);\n       if (physicalBytes !\u003d null) {\n         splitsBlock.getProgressPhysicalMemoryKbytes().extend(newProgress,\n             (int) (physicalBytes.getValue() / (MEMORY_SPLITS_RESOLUTION)));\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void updateProgressSplits() {\n    double newProgress \u003d reportedStatus.progress;\n    Counters counters \u003d reportedStatus.counters;\n    if (counters \u003d\u003d null)\n      return;\n\n    WrappedProgressSplitsBlock splitsBlock \u003d getProgressSplitBlock();\n    if (splitsBlock !\u003d null) {\n      long now \u003d clock.getTime();\n      long start \u003d getLaunchTime(); // TODO Ensure not 0\n\n      if (start !\u003d 0 \u0026\u0026 now - start \u003c\u003d Integer.MAX_VALUE) {\n        splitsBlock.getProgressWallclockTime().extend(newProgress,\n            (int) (now - start));\n      }\n\n      Counter cpuCounter \u003d counters.findCounter(TaskCounter.CPU_MILLISECONDS);\n      if (cpuCounter !\u003d null \u0026\u0026 cpuCounter.getValue() \u003c\u003d Integer.MAX_VALUE) {\n        splitsBlock.getProgressCPUTime().extend(newProgress,\n            (int) cpuCounter.getValue()); // long to int? TODO: FIX. Same below\n      }\n\n      Counter virtualBytes \u003d counters\n        .findCounter(TaskCounter.VIRTUAL_MEMORY_BYTES);\n      if (virtualBytes !\u003d null) {\n        splitsBlock.getProgressVirtualMemoryKbytes().extend(newProgress,\n            (int) (virtualBytes.getValue() / (MEMORY_SPLITS_RESOLUTION)));\n      }\n\n      Counter physicalBytes \u003d counters\n        .findCounter(TaskCounter.PHYSICAL_MEMORY_BYTES);\n      if (physicalBytes !\u003d null) {\n        splitsBlock.getProgressPhysicalMemoryKbytes().extend(newProgress,\n            (int) (physicalBytes.getValue() / (MEMORY_SPLITS_RESOLUTION)));\n      }\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/job/impl/TaskAttemptImpl.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private void updateProgressSplits() {\n    double newProgress \u003d reportedStatus.progress;\n    Counters counters \u003d reportedStatus.counters;\n    if (counters \u003d\u003d null)\n      return;\n\n    WrappedProgressSplitsBlock splitsBlock \u003d getProgressSplitBlock();\n    if (splitsBlock !\u003d null) {\n      long now \u003d clock.getTime();\n      long start \u003d getLaunchTime(); // TODO Ensure not 0\n\n      if (start !\u003d 0 \u0026\u0026 now - start \u003c\u003d Integer.MAX_VALUE) {\n        splitsBlock.getProgressWallclockTime().extend(newProgress,\n            (int) (now - start));\n      }\n\n      Counter cpuCounter \u003d counters.getCounter(\n          TaskCounter.CPU_MILLISECONDS);\n      if (cpuCounter !\u003d null \u0026\u0026 cpuCounter.getValue() \u003c\u003d Integer.MAX_VALUE) {\n        splitsBlock.getProgressCPUTime().extend(newProgress,\n            (int) cpuCounter.getValue());\n      }\n\n      Counter virtualBytes \u003d counters.getCounter(\n          TaskCounter.VIRTUAL_MEMORY_BYTES);\n      if (virtualBytes !\u003d null) {\n        splitsBlock.getProgressVirtualMemoryKbytes().extend(newProgress,\n            (int) (virtualBytes.getValue() / (MEMORY_SPLITS_RESOLUTION)));\n      }\n\n      Counter physicalBytes \u003d counters.getCounter(\n          TaskCounter.PHYSICAL_MEMORY_BYTES);\n      if (physicalBytes !\u003d null) {\n        splitsBlock.getProgressPhysicalMemoryKbytes().extend(newProgress,\n            (int) (physicalBytes.getValue() / (MEMORY_SPLITS_RESOLUTION)));\n      }\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/job/impl/TaskAttemptImpl.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce/hadoop-mr-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/job/impl/TaskAttemptImpl.java",
        "newPath": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/job/impl/TaskAttemptImpl.java"
      }
    },
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-279. MapReduce 2.0. Merging MR-279 branch into trunk. Contributed by Arun C Murthy, Christopher Douglas, Devaraj Das, Greg Roelofs, Jeffrey Naisbitt, Josh Wills, Jonathan Eagles, Krishna Ramachandran, Luke Lu, Mahadev Konar, Robert Evans, Sharad Agarwal, Siddharth Seth, Thomas Graves, and Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159166 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/08/11 4:07 AM",
      "commitName": "dbecbe5dfe50f834fc3b8401709079e9470cc517",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,38 @@\n+  private void updateProgressSplits() {\n+    double newProgress \u003d reportedStatus.progress;\n+    Counters counters \u003d reportedStatus.counters;\n+    if (counters \u003d\u003d null)\n+      return;\n+\n+    WrappedProgressSplitsBlock splitsBlock \u003d getProgressSplitBlock();\n+    if (splitsBlock !\u003d null) {\n+      long now \u003d clock.getTime();\n+      long start \u003d getLaunchTime(); // TODO Ensure not 0\n+\n+      if (start !\u003d 0 \u0026\u0026 now - start \u003c\u003d Integer.MAX_VALUE) {\n+        splitsBlock.getProgressWallclockTime().extend(newProgress,\n+            (int) (now - start));\n+      }\n+\n+      Counter cpuCounter \u003d counters.getCounter(\n+          TaskCounter.CPU_MILLISECONDS);\n+      if (cpuCounter !\u003d null \u0026\u0026 cpuCounter.getValue() \u003c\u003d Integer.MAX_VALUE) {\n+        splitsBlock.getProgressCPUTime().extend(newProgress,\n+            (int) cpuCounter.getValue());\n+      }\n+\n+      Counter virtualBytes \u003d counters.getCounter(\n+          TaskCounter.VIRTUAL_MEMORY_BYTES);\n+      if (virtualBytes !\u003d null) {\n+        splitsBlock.getProgressVirtualMemoryKbytes().extend(newProgress,\n+            (int) (virtualBytes.getValue() / (MEMORY_SPLITS_RESOLUTION)));\n+      }\n+\n+      Counter physicalBytes \u003d counters.getCounter(\n+          TaskCounter.PHYSICAL_MEMORY_BYTES);\n+      if (physicalBytes !\u003d null) {\n+        splitsBlock.getProgressPhysicalMemoryKbytes().extend(newProgress,\n+            (int) (physicalBytes.getValue() / (MEMORY_SPLITS_RESOLUTION)));\n+      }\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void updateProgressSplits() {\n    double newProgress \u003d reportedStatus.progress;\n    Counters counters \u003d reportedStatus.counters;\n    if (counters \u003d\u003d null)\n      return;\n\n    WrappedProgressSplitsBlock splitsBlock \u003d getProgressSplitBlock();\n    if (splitsBlock !\u003d null) {\n      long now \u003d clock.getTime();\n      long start \u003d getLaunchTime(); // TODO Ensure not 0\n\n      if (start !\u003d 0 \u0026\u0026 now - start \u003c\u003d Integer.MAX_VALUE) {\n        splitsBlock.getProgressWallclockTime().extend(newProgress,\n            (int) (now - start));\n      }\n\n      Counter cpuCounter \u003d counters.getCounter(\n          TaskCounter.CPU_MILLISECONDS);\n      if (cpuCounter !\u003d null \u0026\u0026 cpuCounter.getValue() \u003c\u003d Integer.MAX_VALUE) {\n        splitsBlock.getProgressCPUTime().extend(newProgress,\n            (int) cpuCounter.getValue());\n      }\n\n      Counter virtualBytes \u003d counters.getCounter(\n          TaskCounter.VIRTUAL_MEMORY_BYTES);\n      if (virtualBytes !\u003d null) {\n        splitsBlock.getProgressVirtualMemoryKbytes().extend(newProgress,\n            (int) (virtualBytes.getValue() / (MEMORY_SPLITS_RESOLUTION)));\n      }\n\n      Counter physicalBytes \u003d counters.getCounter(\n          TaskCounter.PHYSICAL_MEMORY_BYTES);\n      if (physicalBytes !\u003d null) {\n        splitsBlock.getProgressPhysicalMemoryKbytes().extend(newProgress,\n            (int) (physicalBytes.getValue() / (MEMORY_SPLITS_RESOLUTION)));\n      }\n    }\n  }",
      "path": "hadoop-mapreduce/hadoop-mr-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/job/impl/TaskAttemptImpl.java"
    }
  }
}