{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "CleanerTask.java",
  "functionName": "process",
  "functionId": "process",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-sharedcachemanager/src/main/java/org/apache/hadoop/yarn/server/sharedcachemanager/CleanerTask.java",
  "functionStartLine": 140,
  "functionEndLine": 184,
  "numCommitsSeen": 2,
  "timeTaken": 664,
  "changeHistory": [
    "c51e53d7aad46059f52d4046a5fedfdfd3c37955"
  ],
  "changeHistoryShort": {
    "c51e53d7aad46059f52d4046a5fedfdfd3c37955": "Yintroduced"
  },
  "changeHistoryDetails": {
    "c51e53d7aad46059f52d4046a5fedfdfd3c37955": {
      "type": "Yintroduced",
      "commitMessage": "YARN-2183. [YARN-1492] Cleaner service for cache manager. (Chris Trezzo and Sangjin Lee via kasha)\n",
      "commitDate": "25/10/14 10:31 AM",
      "commitName": "c51e53d7aad46059f52d4046a5fedfdfd3c37955",
      "commitAuthor": "Karthik Kambatla",
      "diff": "@@ -0,0 +1,45 @@\n+  void process() {\n+    // mark the beginning of the run in the metrics\n+    metrics.reportCleaningStart();\n+    try {\n+      // now traverse individual directories and process them\n+      // the directory structure is specified by the nested level parameter\n+      // (e.g. 9/c/d/\u003cchecksum\u003e)\n+      String pattern \u003d SharedCacheUtil.getCacheEntryGlobPattern(nestedLevel);\n+      FileStatus[] resources \u003d\n+          fs.globStatus(new Path(root, pattern));\n+      int numResources \u003d resources \u003d\u003d null ? 0 : resources.length;\n+      LOG.info(\"Processing \" + numResources + \" resources in the shared cache\");\n+      long beginMs \u003d System.currentTimeMillis();\n+      if (resources !\u003d null) {\n+        for (FileStatus resource : resources) {\n+          // check for interruption so it can abort in a timely manner in case\n+          // of shutdown\n+          if (Thread.currentThread().isInterrupted()) {\n+            LOG.warn(\"The cleaner task was interrupted. Aborting.\");\n+            break;\n+          }\n+\n+          if (resource.isDirectory()) {\n+            processSingleResource(resource);\n+          } else {\n+            LOG.warn(\"Invalid file at path \" + resource.getPath().toString()\n+                +\n+                \" when a directory was expected\");\n+          }\n+          // add sleep time between cleaning each directory if it is non-zero\n+          if (sleepTime \u003e 0) {\n+            Thread.sleep(sleepTime);\n+          }\n+        }\n+      }\n+      long endMs \u003d System.currentTimeMillis();\n+      long durationMs \u003d endMs - beginMs;\n+      LOG.info(\"Processed \" + numResources + \" resource(s) in \" + durationMs +\n+          \" ms.\");\n+    } catch (IOException e1) {\n+      LOG.error(\"Unable to complete the cleaner task\", e1);\n+    } catch (InterruptedException e2) {\n+      Thread.currentThread().interrupt(); // restore the interrupt\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  void process() {\n    // mark the beginning of the run in the metrics\n    metrics.reportCleaningStart();\n    try {\n      // now traverse individual directories and process them\n      // the directory structure is specified by the nested level parameter\n      // (e.g. 9/c/d/\u003cchecksum\u003e)\n      String pattern \u003d SharedCacheUtil.getCacheEntryGlobPattern(nestedLevel);\n      FileStatus[] resources \u003d\n          fs.globStatus(new Path(root, pattern));\n      int numResources \u003d resources \u003d\u003d null ? 0 : resources.length;\n      LOG.info(\"Processing \" + numResources + \" resources in the shared cache\");\n      long beginMs \u003d System.currentTimeMillis();\n      if (resources !\u003d null) {\n        for (FileStatus resource : resources) {\n          // check for interruption so it can abort in a timely manner in case\n          // of shutdown\n          if (Thread.currentThread().isInterrupted()) {\n            LOG.warn(\"The cleaner task was interrupted. Aborting.\");\n            break;\n          }\n\n          if (resource.isDirectory()) {\n            processSingleResource(resource);\n          } else {\n            LOG.warn(\"Invalid file at path \" + resource.getPath().toString()\n                +\n                \" when a directory was expected\");\n          }\n          // add sleep time between cleaning each directory if it is non-zero\n          if (sleepTime \u003e 0) {\n            Thread.sleep(sleepTime);\n          }\n        }\n      }\n      long endMs \u003d System.currentTimeMillis();\n      long durationMs \u003d endMs - beginMs;\n      LOG.info(\"Processed \" + numResources + \" resource(s) in \" + durationMs +\n          \" ms.\");\n    } catch (IOException e1) {\n      LOG.error(\"Unable to complete the cleaner task\", e1);\n    } catch (InterruptedException e2) {\n      Thread.currentThread().interrupt(); // restore the interrupt\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-sharedcachemanager/src/main/java/org/apache/hadoop/yarn/server/sharedcachemanager/CleanerTask.java"
    }
  }
}