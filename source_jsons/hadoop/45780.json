{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "LogAggregationTFileController.java",
  "functionName": "readAggregatedLogsMeta",
  "functionId": "readAggregatedLogsMeta___logRequest-ContainerLogsRequest",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/filecontroller/tfile/LogAggregationTFileController.java",
  "functionStartLine": 262,
  "functionEndLine": 337,
  "numCommitsSeen": 12,
  "timeTaken": 2876,
  "changeHistory": [
    "71b2c2ffe962ff4f5799e1f55961db687cb55842",
    "460ba7fb14114f44e14a660f533f32c54e504478",
    "2b39ad26984d641bad57db2cfcc0b7515ef95f46",
    "ec2ae3060a807c8754826af2135a68c08b2e4f13",
    "91cc070d67533ebb3325b982eba2135e0d175a82"
  ],
  "changeHistoryShort": {
    "71b2c2ffe962ff4f5799e1f55961db687cb55842": "Ybodychange",
    "460ba7fb14114f44e14a660f533f32c54e504478": "Ybodychange",
    "2b39ad26984d641bad57db2cfcc0b7515ef95f46": "Ybodychange",
    "ec2ae3060a807c8754826af2135a68c08b2e4f13": "Ybodychange",
    "91cc070d67533ebb3325b982eba2135e0d175a82": "Yintroduced"
  },
  "changeHistoryDetails": {
    "71b2c2ffe962ff4f5799e1f55961db687cb55842": {
      "type": "Ybodychange",
      "commitMessage": "YARN-10101. Support listing of aggregated logs for containers belonging to an application attempt. Contributed by Adam Antal\n",
      "commitDate": "06/02/20 3:25 AM",
      "commitName": "71b2c2ffe962ff4f5799e1f55961db687cb55842",
      "commitAuthor": "Szilard Nemeth",
      "commitDateOld": "23/05/19 3:38 PM",
      "commitNameOld": "460ba7fb14114f44e14a660f533f32c54e504478",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 258.53,
      "commitsBetweenForRepo": 1615,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,72 +1,76 @@\n   public List\u003cContainerLogMeta\u003e readAggregatedLogsMeta(\n       ContainerLogsRequest logRequest) throws IOException {\n     List\u003cContainerLogMeta\u003e containersLogMeta \u003d new ArrayList\u003c\u003e();\n     String containerIdStr \u003d logRequest.getContainerId();\n     String nodeId \u003d logRequest.getNodeId();\n     ApplicationId appId \u003d logRequest.getAppId();\n     String appOwner \u003d logRequest.getAppOwner();\n-    boolean getAllContainers \u003d (containerIdStr \u003d\u003d null);\n+    ApplicationAttemptId appAttemptId \u003d logRequest.getAppAttemptId();\n+    boolean getAllContainers \u003d (containerIdStr \u003d\u003d null \u0026\u0026\n+        appAttemptId \u003d\u003d null);\n+    boolean getOnlyOneContainer \u003d containerIdStr !\u003d null;\n     String nodeIdStr \u003d (nodeId \u003d\u003d null) ? null\n         : LogAggregationUtils.getNodeString(nodeId);\n     RemoteIterator\u003cFileStatus\u003e nodeFiles \u003d LogAggregationUtils\n         .getRemoteNodeFileDir(conf, appId, appOwner,\n         remoteRootLogDir, remoteRootLogDirSuffix);\n     if (nodeFiles \u003d\u003d null) {\n       throw new IOException(\"There is no available log file for \"\n           + \"application:\" + appId);\n     }\n     while (nodeFiles.hasNext()) {\n       FileStatus thisNodeFile \u003d nodeFiles.next();\n       if (thisNodeFile.getPath().getName().equals(appId + \".har\")) {\n         Path p \u003d new Path(\"har:///\"\n             + thisNodeFile.getPath().toUri().getRawPath());\n         nodeFiles \u003d HarFs.get(p.toUri(), conf).listStatusIterator(p);\n         continue;\n       }\n       if (nodeIdStr !\u003d null) {\n         if (!thisNodeFile.getPath().getName().contains(nodeIdStr)) {\n           continue;\n         }\n       }\n       if (!thisNodeFile.getPath().getName()\n           .endsWith(LogAggregationUtils.TMP_FILE_SUFFIX)) {\n         AggregatedLogFormat.LogReader reader \u003d\n             new AggregatedLogFormat.LogReader(conf,\n             thisNodeFile.getPath());\n         try {\n           DataInputStream valueStream;\n           LogKey key \u003d new LogKey();\n           valueStream \u003d reader.next(key);\n           while (valueStream !\u003d null) {\n-            if (getAllContainers || (key.toString().equals(containerIdStr))) {\n+            if (getAllContainers || (key.toString().equals(containerIdStr)) ||\n+                belongsToAppAttempt(appAttemptId, key.toString())) {\n               ContainerLogMeta containerLogMeta \u003d new ContainerLogMeta(\n                   key.toString(), thisNodeFile.getPath().getName());\n               while (true) {\n                 try {\n                   Pair\u003cString, String\u003e logMeta \u003d\n                       LogReader.readContainerMetaDataAndSkipData(\n                           valueStream);\n                   containerLogMeta.addLogMeta(\n                       logMeta.getFirst(),\n                       logMeta.getSecond(),\n                       Times.format(thisNodeFile.getModificationTime()));\n                 } catch (EOFException eof) {\n                   break;\n                 }\n               }\n               containersLogMeta.add(containerLogMeta);\n-              if (!getAllContainers) {\n+              if (getOnlyOneContainer) {\n                 break;\n               }\n             }\n             // Next container\n             key \u003d new LogKey();\n             valueStream \u003d reader.next(key);\n           }\n         } finally {\n           reader.close();\n         }\n       }\n     }\n     return containersLogMeta;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public List\u003cContainerLogMeta\u003e readAggregatedLogsMeta(\n      ContainerLogsRequest logRequest) throws IOException {\n    List\u003cContainerLogMeta\u003e containersLogMeta \u003d new ArrayList\u003c\u003e();\n    String containerIdStr \u003d logRequest.getContainerId();\n    String nodeId \u003d logRequest.getNodeId();\n    ApplicationId appId \u003d logRequest.getAppId();\n    String appOwner \u003d logRequest.getAppOwner();\n    ApplicationAttemptId appAttemptId \u003d logRequest.getAppAttemptId();\n    boolean getAllContainers \u003d (containerIdStr \u003d\u003d null \u0026\u0026\n        appAttemptId \u003d\u003d null);\n    boolean getOnlyOneContainer \u003d containerIdStr !\u003d null;\n    String nodeIdStr \u003d (nodeId \u003d\u003d null) ? null\n        : LogAggregationUtils.getNodeString(nodeId);\n    RemoteIterator\u003cFileStatus\u003e nodeFiles \u003d LogAggregationUtils\n        .getRemoteNodeFileDir(conf, appId, appOwner,\n        remoteRootLogDir, remoteRootLogDirSuffix);\n    if (nodeFiles \u003d\u003d null) {\n      throw new IOException(\"There is no available log file for \"\n          + \"application:\" + appId);\n    }\n    while (nodeFiles.hasNext()) {\n      FileStatus thisNodeFile \u003d nodeFiles.next();\n      if (thisNodeFile.getPath().getName().equals(appId + \".har\")) {\n        Path p \u003d new Path(\"har:///\"\n            + thisNodeFile.getPath().toUri().getRawPath());\n        nodeFiles \u003d HarFs.get(p.toUri(), conf).listStatusIterator(p);\n        continue;\n      }\n      if (nodeIdStr !\u003d null) {\n        if (!thisNodeFile.getPath().getName().contains(nodeIdStr)) {\n          continue;\n        }\n      }\n      if (!thisNodeFile.getPath().getName()\n          .endsWith(LogAggregationUtils.TMP_FILE_SUFFIX)) {\n        AggregatedLogFormat.LogReader reader \u003d\n            new AggregatedLogFormat.LogReader(conf,\n            thisNodeFile.getPath());\n        try {\n          DataInputStream valueStream;\n          LogKey key \u003d new LogKey();\n          valueStream \u003d reader.next(key);\n          while (valueStream !\u003d null) {\n            if (getAllContainers || (key.toString().equals(containerIdStr)) ||\n                belongsToAppAttempt(appAttemptId, key.toString())) {\n              ContainerLogMeta containerLogMeta \u003d new ContainerLogMeta(\n                  key.toString(), thisNodeFile.getPath().getName());\n              while (true) {\n                try {\n                  Pair\u003cString, String\u003e logMeta \u003d\n                      LogReader.readContainerMetaDataAndSkipData(\n                          valueStream);\n                  containerLogMeta.addLogMeta(\n                      logMeta.getFirst(),\n                      logMeta.getSecond(),\n                      Times.format(thisNodeFile.getModificationTime()));\n                } catch (EOFException eof) {\n                  break;\n                }\n              }\n              containersLogMeta.add(containerLogMeta);\n              if (getOnlyOneContainer) {\n                break;\n              }\n            }\n            // Next container\n            key \u003d new LogKey();\n            valueStream \u003d reader.next(key);\n          }\n        } finally {\n          reader.close();\n        }\n      }\n    }\n    return containersLogMeta;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/filecontroller/tfile/LogAggregationTFileController.java",
      "extendedDetails": {}
    },
    "460ba7fb14114f44e14a660f533f32c54e504478": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9558.  Fixed LogAggregation test cases.\n            Contributed by Prabhu Joseph\n",
      "commitDate": "23/05/19 3:38 PM",
      "commitName": "460ba7fb14114f44e14a660f533f32c54e504478",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "14/05/19 10:48 AM",
      "commitNameOld": "7d831eca645f93d064975ebae35a7cbea3bbad31",
      "commitAuthorOld": "Sunil G",
      "daysBetweenCommits": 9.2,
      "commitsBetweenForRepo": 56,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,71 +1,72 @@\n   public List\u003cContainerLogMeta\u003e readAggregatedLogsMeta(\n       ContainerLogsRequest logRequest) throws IOException {\n     List\u003cContainerLogMeta\u003e containersLogMeta \u003d new ArrayList\u003c\u003e();\n     String containerIdStr \u003d logRequest.getContainerId();\n     String nodeId \u003d logRequest.getNodeId();\n     ApplicationId appId \u003d logRequest.getAppId();\n     String appOwner \u003d logRequest.getAppOwner();\n     boolean getAllContainers \u003d (containerIdStr \u003d\u003d null);\n     String nodeIdStr \u003d (nodeId \u003d\u003d null) ? null\n         : LogAggregationUtils.getNodeString(nodeId);\n     RemoteIterator\u003cFileStatus\u003e nodeFiles \u003d LogAggregationUtils\n-        .getRemoteNodeFileDir(conf, appId, appOwner);\n+        .getRemoteNodeFileDir(conf, appId, appOwner,\n+        remoteRootLogDir, remoteRootLogDirSuffix);\n     if (nodeFiles \u003d\u003d null) {\n       throw new IOException(\"There is no available log file for \"\n           + \"application:\" + appId);\n     }\n     while (nodeFiles.hasNext()) {\n       FileStatus thisNodeFile \u003d nodeFiles.next();\n       if (thisNodeFile.getPath().getName().equals(appId + \".har\")) {\n         Path p \u003d new Path(\"har:///\"\n             + thisNodeFile.getPath().toUri().getRawPath());\n         nodeFiles \u003d HarFs.get(p.toUri(), conf).listStatusIterator(p);\n         continue;\n       }\n       if (nodeIdStr !\u003d null) {\n         if (!thisNodeFile.getPath().getName().contains(nodeIdStr)) {\n           continue;\n         }\n       }\n       if (!thisNodeFile.getPath().getName()\n           .endsWith(LogAggregationUtils.TMP_FILE_SUFFIX)) {\n         AggregatedLogFormat.LogReader reader \u003d\n             new AggregatedLogFormat.LogReader(conf,\n             thisNodeFile.getPath());\n         try {\n           DataInputStream valueStream;\n           LogKey key \u003d new LogKey();\n           valueStream \u003d reader.next(key);\n           while (valueStream !\u003d null) {\n             if (getAllContainers || (key.toString().equals(containerIdStr))) {\n               ContainerLogMeta containerLogMeta \u003d new ContainerLogMeta(\n                   key.toString(), thisNodeFile.getPath().getName());\n               while (true) {\n                 try {\n                   Pair\u003cString, String\u003e logMeta \u003d\n                       LogReader.readContainerMetaDataAndSkipData(\n                           valueStream);\n                   containerLogMeta.addLogMeta(\n                       logMeta.getFirst(),\n                       logMeta.getSecond(),\n                       Times.format(thisNodeFile.getModificationTime()));\n                 } catch (EOFException eof) {\n                   break;\n                 }\n               }\n               containersLogMeta.add(containerLogMeta);\n               if (!getAllContainers) {\n                 break;\n               }\n             }\n             // Next container\n             key \u003d new LogKey();\n             valueStream \u003d reader.next(key);\n           }\n         } finally {\n           reader.close();\n         }\n       }\n     }\n     return containersLogMeta;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public List\u003cContainerLogMeta\u003e readAggregatedLogsMeta(\n      ContainerLogsRequest logRequest) throws IOException {\n    List\u003cContainerLogMeta\u003e containersLogMeta \u003d new ArrayList\u003c\u003e();\n    String containerIdStr \u003d logRequest.getContainerId();\n    String nodeId \u003d logRequest.getNodeId();\n    ApplicationId appId \u003d logRequest.getAppId();\n    String appOwner \u003d logRequest.getAppOwner();\n    boolean getAllContainers \u003d (containerIdStr \u003d\u003d null);\n    String nodeIdStr \u003d (nodeId \u003d\u003d null) ? null\n        : LogAggregationUtils.getNodeString(nodeId);\n    RemoteIterator\u003cFileStatus\u003e nodeFiles \u003d LogAggregationUtils\n        .getRemoteNodeFileDir(conf, appId, appOwner,\n        remoteRootLogDir, remoteRootLogDirSuffix);\n    if (nodeFiles \u003d\u003d null) {\n      throw new IOException(\"There is no available log file for \"\n          + \"application:\" + appId);\n    }\n    while (nodeFiles.hasNext()) {\n      FileStatus thisNodeFile \u003d nodeFiles.next();\n      if (thisNodeFile.getPath().getName().equals(appId + \".har\")) {\n        Path p \u003d new Path(\"har:///\"\n            + thisNodeFile.getPath().toUri().getRawPath());\n        nodeFiles \u003d HarFs.get(p.toUri(), conf).listStatusIterator(p);\n        continue;\n      }\n      if (nodeIdStr !\u003d null) {\n        if (!thisNodeFile.getPath().getName().contains(nodeIdStr)) {\n          continue;\n        }\n      }\n      if (!thisNodeFile.getPath().getName()\n          .endsWith(LogAggregationUtils.TMP_FILE_SUFFIX)) {\n        AggregatedLogFormat.LogReader reader \u003d\n            new AggregatedLogFormat.LogReader(conf,\n            thisNodeFile.getPath());\n        try {\n          DataInputStream valueStream;\n          LogKey key \u003d new LogKey();\n          valueStream \u003d reader.next(key);\n          while (valueStream !\u003d null) {\n            if (getAllContainers || (key.toString().equals(containerIdStr))) {\n              ContainerLogMeta containerLogMeta \u003d new ContainerLogMeta(\n                  key.toString(), thisNodeFile.getPath().getName());\n              while (true) {\n                try {\n                  Pair\u003cString, String\u003e logMeta \u003d\n                      LogReader.readContainerMetaDataAndSkipData(\n                          valueStream);\n                  containerLogMeta.addLogMeta(\n                      logMeta.getFirst(),\n                      logMeta.getSecond(),\n                      Times.format(thisNodeFile.getModificationTime()));\n                } catch (EOFException eof) {\n                  break;\n                }\n              }\n              containersLogMeta.add(containerLogMeta);\n              if (!getAllContainers) {\n                break;\n              }\n            }\n            // Next container\n            key \u003d new LogKey();\n            valueStream \u003d reader.next(key);\n          }\n        } finally {\n          reader.close();\n        }\n      }\n    }\n    return containersLogMeta;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/filecontroller/tfile/LogAggregationTFileController.java",
      "extendedDetails": {}
    },
    "2b39ad26984d641bad57db2cfcc0b7515ef95f46": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8584. Several typos in Log Aggregation related classes. Contributed by Szilard Nemeth.\n",
      "commitDate": "30/07/18 10:55 AM",
      "commitName": "2b39ad26984d641bad57db2cfcc0b7515ef95f46",
      "commitAuthor": "bibinchundatt",
      "commitDateOld": "22/05/18 2:24 PM",
      "commitNameOld": "b22f56c4719e63bd4f6edc2a075e0bcdb9442255",
      "commitAuthorOld": "Robert Kanter",
      "daysBetweenCommits": 68.85,
      "commitsBetweenForRepo": 474,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,71 +1,71 @@\n   public List\u003cContainerLogMeta\u003e readAggregatedLogsMeta(\n       ContainerLogsRequest logRequest) throws IOException {\n     List\u003cContainerLogMeta\u003e containersLogMeta \u003d new ArrayList\u003c\u003e();\n     String containerIdStr \u003d logRequest.getContainerId();\n     String nodeId \u003d logRequest.getNodeId();\n     ApplicationId appId \u003d logRequest.getAppId();\n     String appOwner \u003d logRequest.getAppOwner();\n     boolean getAllContainers \u003d (containerIdStr \u003d\u003d null);\n     String nodeIdStr \u003d (nodeId \u003d\u003d null) ? null\n         : LogAggregationUtils.getNodeString(nodeId);\n     RemoteIterator\u003cFileStatus\u003e nodeFiles \u003d LogAggregationUtils\n         .getRemoteNodeFileDir(conf, appId, appOwner);\n     if (nodeFiles \u003d\u003d null) {\n-      throw new IOException(\"There is no available log fils for \"\n+      throw new IOException(\"There is no available log file for \"\n           + \"application:\" + appId);\n     }\n     while (nodeFiles.hasNext()) {\n       FileStatus thisNodeFile \u003d nodeFiles.next();\n       if (thisNodeFile.getPath().getName().equals(appId + \".har\")) {\n         Path p \u003d new Path(\"har:///\"\n             + thisNodeFile.getPath().toUri().getRawPath());\n         nodeFiles \u003d HarFs.get(p.toUri(), conf).listStatusIterator(p);\n         continue;\n       }\n       if (nodeIdStr !\u003d null) {\n         if (!thisNodeFile.getPath().getName().contains(nodeIdStr)) {\n           continue;\n         }\n       }\n       if (!thisNodeFile.getPath().getName()\n           .endsWith(LogAggregationUtils.TMP_FILE_SUFFIX)) {\n         AggregatedLogFormat.LogReader reader \u003d\n             new AggregatedLogFormat.LogReader(conf,\n             thisNodeFile.getPath());\n         try {\n           DataInputStream valueStream;\n           LogKey key \u003d new LogKey();\n           valueStream \u003d reader.next(key);\n           while (valueStream !\u003d null) {\n             if (getAllContainers || (key.toString().equals(containerIdStr))) {\n               ContainerLogMeta containerLogMeta \u003d new ContainerLogMeta(\n                   key.toString(), thisNodeFile.getPath().getName());\n               while (true) {\n                 try {\n                   Pair\u003cString, String\u003e logMeta \u003d\n                       LogReader.readContainerMetaDataAndSkipData(\n                           valueStream);\n                   containerLogMeta.addLogMeta(\n                       logMeta.getFirst(),\n                       logMeta.getSecond(),\n                       Times.format(thisNodeFile.getModificationTime()));\n                 } catch (EOFException eof) {\n                   break;\n                 }\n               }\n               containersLogMeta.add(containerLogMeta);\n               if (!getAllContainers) {\n                 break;\n               }\n             }\n             // Next container\n             key \u003d new LogKey();\n             valueStream \u003d reader.next(key);\n           }\n         } finally {\n           reader.close();\n         }\n       }\n     }\n     return containersLogMeta;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public List\u003cContainerLogMeta\u003e readAggregatedLogsMeta(\n      ContainerLogsRequest logRequest) throws IOException {\n    List\u003cContainerLogMeta\u003e containersLogMeta \u003d new ArrayList\u003c\u003e();\n    String containerIdStr \u003d logRequest.getContainerId();\n    String nodeId \u003d logRequest.getNodeId();\n    ApplicationId appId \u003d logRequest.getAppId();\n    String appOwner \u003d logRequest.getAppOwner();\n    boolean getAllContainers \u003d (containerIdStr \u003d\u003d null);\n    String nodeIdStr \u003d (nodeId \u003d\u003d null) ? null\n        : LogAggregationUtils.getNodeString(nodeId);\n    RemoteIterator\u003cFileStatus\u003e nodeFiles \u003d LogAggregationUtils\n        .getRemoteNodeFileDir(conf, appId, appOwner);\n    if (nodeFiles \u003d\u003d null) {\n      throw new IOException(\"There is no available log file for \"\n          + \"application:\" + appId);\n    }\n    while (nodeFiles.hasNext()) {\n      FileStatus thisNodeFile \u003d nodeFiles.next();\n      if (thisNodeFile.getPath().getName().equals(appId + \".har\")) {\n        Path p \u003d new Path(\"har:///\"\n            + thisNodeFile.getPath().toUri().getRawPath());\n        nodeFiles \u003d HarFs.get(p.toUri(), conf).listStatusIterator(p);\n        continue;\n      }\n      if (nodeIdStr !\u003d null) {\n        if (!thisNodeFile.getPath().getName().contains(nodeIdStr)) {\n          continue;\n        }\n      }\n      if (!thisNodeFile.getPath().getName()\n          .endsWith(LogAggregationUtils.TMP_FILE_SUFFIX)) {\n        AggregatedLogFormat.LogReader reader \u003d\n            new AggregatedLogFormat.LogReader(conf,\n            thisNodeFile.getPath());\n        try {\n          DataInputStream valueStream;\n          LogKey key \u003d new LogKey();\n          valueStream \u003d reader.next(key);\n          while (valueStream !\u003d null) {\n            if (getAllContainers || (key.toString().equals(containerIdStr))) {\n              ContainerLogMeta containerLogMeta \u003d new ContainerLogMeta(\n                  key.toString(), thisNodeFile.getPath().getName());\n              while (true) {\n                try {\n                  Pair\u003cString, String\u003e logMeta \u003d\n                      LogReader.readContainerMetaDataAndSkipData(\n                          valueStream);\n                  containerLogMeta.addLogMeta(\n                      logMeta.getFirst(),\n                      logMeta.getSecond(),\n                      Times.format(thisNodeFile.getModificationTime()));\n                } catch (EOFException eof) {\n                  break;\n                }\n              }\n              containersLogMeta.add(containerLogMeta);\n              if (!getAllContainers) {\n                break;\n              }\n            }\n            // Next container\n            key \u003d new LogKey();\n            valueStream \u003d reader.next(key);\n          }\n        } finally {\n          reader.close();\n        }\n      }\n    }\n    return containersLogMeta;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/filecontroller/tfile/LogAggregationTFileController.java",
      "extendedDetails": {}
    },
    "ec2ae3060a807c8754826af2135a68c08b2e4f13": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6509. Add a size threshold beyond which yarn logs will require a force option. (Xuan Gong via wangda)\n\nChange-Id: I755fe903337d4ff9ec35dae5b9cce638794e1d0f\n",
      "commitDate": "29/09/17 4:42 PM",
      "commitName": "ec2ae3060a807c8754826af2135a68c08b2e4f13",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "08/09/17 3:16 PM",
      "commitNameOld": "3fddabc2fe4fbdb8ef3f9ce7558955c4f0794dcc",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 21.06,
      "commitsBetweenForRepo": 205,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,65 +1,71 @@\n   public List\u003cContainerLogMeta\u003e readAggregatedLogsMeta(\n       ContainerLogsRequest logRequest) throws IOException {\n     List\u003cContainerLogMeta\u003e containersLogMeta \u003d new ArrayList\u003c\u003e();\n     String containerIdStr \u003d logRequest.getContainerId();\n     String nodeId \u003d logRequest.getNodeId();\n     ApplicationId appId \u003d logRequest.getAppId();\n     String appOwner \u003d logRequest.getAppOwner();\n     boolean getAllContainers \u003d (containerIdStr \u003d\u003d null);\n     String nodeIdStr \u003d (nodeId \u003d\u003d null) ? null\n         : LogAggregationUtils.getNodeString(nodeId);\n     RemoteIterator\u003cFileStatus\u003e nodeFiles \u003d LogAggregationUtils\n         .getRemoteNodeFileDir(conf, appId, appOwner);\n     if (nodeFiles \u003d\u003d null) {\n       throw new IOException(\"There is no available log fils for \"\n           + \"application:\" + appId);\n     }\n     while (nodeFiles.hasNext()) {\n       FileStatus thisNodeFile \u003d nodeFiles.next();\n+      if (thisNodeFile.getPath().getName().equals(appId + \".har\")) {\n+        Path p \u003d new Path(\"har:///\"\n+            + thisNodeFile.getPath().toUri().getRawPath());\n+        nodeFiles \u003d HarFs.get(p.toUri(), conf).listStatusIterator(p);\n+        continue;\n+      }\n       if (nodeIdStr !\u003d null) {\n         if (!thisNodeFile.getPath().getName().contains(nodeIdStr)) {\n           continue;\n         }\n       }\n       if (!thisNodeFile.getPath().getName()\n           .endsWith(LogAggregationUtils.TMP_FILE_SUFFIX)) {\n         AggregatedLogFormat.LogReader reader \u003d\n             new AggregatedLogFormat.LogReader(conf,\n             thisNodeFile.getPath());\n         try {\n           DataInputStream valueStream;\n           LogKey key \u003d new LogKey();\n           valueStream \u003d reader.next(key);\n           while (valueStream !\u003d null) {\n             if (getAllContainers || (key.toString().equals(containerIdStr))) {\n               ContainerLogMeta containerLogMeta \u003d new ContainerLogMeta(\n                   key.toString(), thisNodeFile.getPath().getName());\n               while (true) {\n                 try {\n                   Pair\u003cString, String\u003e logMeta \u003d\n                       LogReader.readContainerMetaDataAndSkipData(\n                           valueStream);\n                   containerLogMeta.addLogMeta(\n                       logMeta.getFirst(),\n                       logMeta.getSecond(),\n                       Times.format(thisNodeFile.getModificationTime()));\n                 } catch (EOFException eof) {\n                   break;\n                 }\n               }\n               containersLogMeta.add(containerLogMeta);\n               if (!getAllContainers) {\n                 break;\n               }\n             }\n             // Next container\n             key \u003d new LogKey();\n             valueStream \u003d reader.next(key);\n           }\n         } finally {\n           reader.close();\n         }\n       }\n     }\n     return containersLogMeta;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public List\u003cContainerLogMeta\u003e readAggregatedLogsMeta(\n      ContainerLogsRequest logRequest) throws IOException {\n    List\u003cContainerLogMeta\u003e containersLogMeta \u003d new ArrayList\u003c\u003e();\n    String containerIdStr \u003d logRequest.getContainerId();\n    String nodeId \u003d logRequest.getNodeId();\n    ApplicationId appId \u003d logRequest.getAppId();\n    String appOwner \u003d logRequest.getAppOwner();\n    boolean getAllContainers \u003d (containerIdStr \u003d\u003d null);\n    String nodeIdStr \u003d (nodeId \u003d\u003d null) ? null\n        : LogAggregationUtils.getNodeString(nodeId);\n    RemoteIterator\u003cFileStatus\u003e nodeFiles \u003d LogAggregationUtils\n        .getRemoteNodeFileDir(conf, appId, appOwner);\n    if (nodeFiles \u003d\u003d null) {\n      throw new IOException(\"There is no available log fils for \"\n          + \"application:\" + appId);\n    }\n    while (nodeFiles.hasNext()) {\n      FileStatus thisNodeFile \u003d nodeFiles.next();\n      if (thisNodeFile.getPath().getName().equals(appId + \".har\")) {\n        Path p \u003d new Path(\"har:///\"\n            + thisNodeFile.getPath().toUri().getRawPath());\n        nodeFiles \u003d HarFs.get(p.toUri(), conf).listStatusIterator(p);\n        continue;\n      }\n      if (nodeIdStr !\u003d null) {\n        if (!thisNodeFile.getPath().getName().contains(nodeIdStr)) {\n          continue;\n        }\n      }\n      if (!thisNodeFile.getPath().getName()\n          .endsWith(LogAggregationUtils.TMP_FILE_SUFFIX)) {\n        AggregatedLogFormat.LogReader reader \u003d\n            new AggregatedLogFormat.LogReader(conf,\n            thisNodeFile.getPath());\n        try {\n          DataInputStream valueStream;\n          LogKey key \u003d new LogKey();\n          valueStream \u003d reader.next(key);\n          while (valueStream !\u003d null) {\n            if (getAllContainers || (key.toString().equals(containerIdStr))) {\n              ContainerLogMeta containerLogMeta \u003d new ContainerLogMeta(\n                  key.toString(), thisNodeFile.getPath().getName());\n              while (true) {\n                try {\n                  Pair\u003cString, String\u003e logMeta \u003d\n                      LogReader.readContainerMetaDataAndSkipData(\n                          valueStream);\n                  containerLogMeta.addLogMeta(\n                      logMeta.getFirst(),\n                      logMeta.getSecond(),\n                      Times.format(thisNodeFile.getModificationTime()));\n                } catch (EOFException eof) {\n                  break;\n                }\n              }\n              containersLogMeta.add(containerLogMeta);\n              if (!getAllContainers) {\n                break;\n              }\n            }\n            // Next container\n            key \u003d new LogKey();\n            valueStream \u003d reader.next(key);\n          }\n        } finally {\n          reader.close();\n        }\n      }\n    }\n    return containersLogMeta;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/filecontroller/tfile/LogAggregationTFileController.java",
      "extendedDetails": {}
    },
    "91cc070d67533ebb3325b982eba2135e0d175a82": {
      "type": "Yintroduced",
      "commitMessage": "YARN-6877. Create an abstract log reader for extendability. Contributed by Xuan Gong.\n",
      "commitDate": "31/08/17 4:41 PM",
      "commitName": "91cc070d67533ebb3325b982eba2135e0d175a82",
      "commitAuthor": "Junping Du",
      "diff": "@@ -0,0 +1,65 @@\n+  public List\u003cContainerLogMeta\u003e readAggregatedLogsMeta(\n+      ContainerLogsRequest logRequest) throws IOException {\n+    List\u003cContainerLogMeta\u003e containersLogMeta \u003d new ArrayList\u003c\u003e();\n+    String containerIdStr \u003d logRequest.getContainerId();\n+    String nodeId \u003d logRequest.getNodeId();\n+    ApplicationId appId \u003d logRequest.getAppId();\n+    String appOwner \u003d logRequest.getAppOwner();\n+    boolean getAllContainers \u003d (containerIdStr \u003d\u003d null);\n+    String nodeIdStr \u003d (nodeId \u003d\u003d null) ? null\n+        : LogAggregationUtils.getNodeString(nodeId);\n+    RemoteIterator\u003cFileStatus\u003e nodeFiles \u003d LogAggregationUtils\n+        .getRemoteNodeFileDir(conf, appId, appOwner);\n+    if (nodeFiles \u003d\u003d null) {\n+      throw new IOException(\"There is no available log fils for \"\n+          + \"application:\" + appId);\n+    }\n+    while (nodeFiles.hasNext()) {\n+      FileStatus thisNodeFile \u003d nodeFiles.next();\n+      if (nodeIdStr !\u003d null) {\n+        if (!thisNodeFile.getPath().getName().contains(nodeIdStr)) {\n+          continue;\n+        }\n+      }\n+      if (!thisNodeFile.getPath().getName()\n+          .endsWith(LogAggregationUtils.TMP_FILE_SUFFIX)) {\n+        AggregatedLogFormat.LogReader reader \u003d\n+            new AggregatedLogFormat.LogReader(conf,\n+            thisNodeFile.getPath());\n+        try {\n+          DataInputStream valueStream;\n+          LogKey key \u003d new LogKey();\n+          valueStream \u003d reader.next(key);\n+          while (valueStream !\u003d null) {\n+            if (getAllContainers || (key.toString().equals(containerIdStr))) {\n+              ContainerLogMeta containerLogMeta \u003d new ContainerLogMeta(\n+                  key.toString(), thisNodeFile.getPath().getName());\n+              while (true) {\n+                try {\n+                  Pair\u003cString, String\u003e logMeta \u003d\n+                      LogReader.readContainerMetaDataAndSkipData(\n+                          valueStream);\n+                  containerLogMeta.addLogMeta(\n+                      logMeta.getFirst(),\n+                      logMeta.getSecond(),\n+                      Times.format(thisNodeFile.getModificationTime()));\n+                } catch (EOFException eof) {\n+                  break;\n+                }\n+              }\n+              containersLogMeta.add(containerLogMeta);\n+              if (!getAllContainers) {\n+                break;\n+              }\n+            }\n+            // Next container\n+            key \u003d new LogKey();\n+            valueStream \u003d reader.next(key);\n+          }\n+        } finally {\n+          reader.close();\n+        }\n+      }\n+    }\n+    return containersLogMeta;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public List\u003cContainerLogMeta\u003e readAggregatedLogsMeta(\n      ContainerLogsRequest logRequest) throws IOException {\n    List\u003cContainerLogMeta\u003e containersLogMeta \u003d new ArrayList\u003c\u003e();\n    String containerIdStr \u003d logRequest.getContainerId();\n    String nodeId \u003d logRequest.getNodeId();\n    ApplicationId appId \u003d logRequest.getAppId();\n    String appOwner \u003d logRequest.getAppOwner();\n    boolean getAllContainers \u003d (containerIdStr \u003d\u003d null);\n    String nodeIdStr \u003d (nodeId \u003d\u003d null) ? null\n        : LogAggregationUtils.getNodeString(nodeId);\n    RemoteIterator\u003cFileStatus\u003e nodeFiles \u003d LogAggregationUtils\n        .getRemoteNodeFileDir(conf, appId, appOwner);\n    if (nodeFiles \u003d\u003d null) {\n      throw new IOException(\"There is no available log fils for \"\n          + \"application:\" + appId);\n    }\n    while (nodeFiles.hasNext()) {\n      FileStatus thisNodeFile \u003d nodeFiles.next();\n      if (nodeIdStr !\u003d null) {\n        if (!thisNodeFile.getPath().getName().contains(nodeIdStr)) {\n          continue;\n        }\n      }\n      if (!thisNodeFile.getPath().getName()\n          .endsWith(LogAggregationUtils.TMP_FILE_SUFFIX)) {\n        AggregatedLogFormat.LogReader reader \u003d\n            new AggregatedLogFormat.LogReader(conf,\n            thisNodeFile.getPath());\n        try {\n          DataInputStream valueStream;\n          LogKey key \u003d new LogKey();\n          valueStream \u003d reader.next(key);\n          while (valueStream !\u003d null) {\n            if (getAllContainers || (key.toString().equals(containerIdStr))) {\n              ContainerLogMeta containerLogMeta \u003d new ContainerLogMeta(\n                  key.toString(), thisNodeFile.getPath().getName());\n              while (true) {\n                try {\n                  Pair\u003cString, String\u003e logMeta \u003d\n                      LogReader.readContainerMetaDataAndSkipData(\n                          valueStream);\n                  containerLogMeta.addLogMeta(\n                      logMeta.getFirst(),\n                      logMeta.getSecond(),\n                      Times.format(thisNodeFile.getModificationTime()));\n                } catch (EOFException eof) {\n                  break;\n                }\n              }\n              containersLogMeta.add(containerLogMeta);\n              if (!getAllContainers) {\n                break;\n              }\n            }\n            // Next container\n            key \u003d new LogKey();\n            valueStream \u003d reader.next(key);\n          }\n        } finally {\n          reader.close();\n        }\n      }\n    }\n    return containersLogMeta;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/filecontroller/tfile/LogAggregationTFileController.java"
    }
  }
}