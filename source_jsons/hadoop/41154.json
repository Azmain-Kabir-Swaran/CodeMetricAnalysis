{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "QueueManager.java",
  "functionName": "createNewQueues",
  "functionId": "createNewQueues___queueType-FSQueueType__topParent-FSParentQueue__newQueueNames-List__String__",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/QueueManager.java",
  "functionStartLine": 341,
  "functionEndLine": 386,
  "numCommitsSeen": 52,
  "timeTaken": 3143,
  "changeHistory": [
    "10d0e4be6eade7c1685b9c6962bc9b18e33122a8",
    "11be3f70e029c2324b167563168c8a254d234aef",
    "e224c9623493d6c4c2f3ff731fd3c72c0f448b19",
    "f6ea9be5473ab66798b0536317d2f32c5348eb57",
    "20f0eb871c57cc4c5a6d19aae0e3745b6175509b"
  ],
  "changeHistoryShort": {
    "10d0e4be6eade7c1685b9c6962bc9b18e33122a8": "Ybodychange",
    "11be3f70e029c2324b167563168c8a254d234aef": "Ybodychange",
    "e224c9623493d6c4c2f3ff731fd3c72c0f448b19": "Ybodychange",
    "f6ea9be5473ab66798b0536317d2f32c5348eb57": "Ybodychange",
    "20f0eb871c57cc4c5a6d19aae0e3745b6175509b": "Yintroduced"
  },
  "changeHistoryDetails": {
    "10d0e4be6eade7c1685b9c6962bc9b18e33122a8": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8325. Miscellaneous QueueManager code clean up. (Szilard Nemeth via Haibo Chen)\n",
      "commitDate": "12/06/18 10:11 AM",
      "commitName": "10d0e4be6eade7c1685b9c6962bc9b18e33122a8",
      "commitAuthor": "Haibo Chen",
      "commitDateOld": "24/05/18 5:12 PM",
      "commitNameOld": "86bc6425d425913899f1d951498bd040e453b3d0",
      "commitAuthorOld": "Haibo Chen",
      "daysBetweenCommits": 18.71,
      "commitsBetweenForRepo": 140,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,45 +1,46 @@\n   private FSQueue createNewQueues(FSQueueType queueType,\n       FSParentQueue topParent, List\u003cString\u003e newQueueNames) {\n     AllocationConfiguration queueConf \u003d scheduler.getAllocationConfiguration();\n     Iterator\u003cString\u003e i \u003d newQueueNames.iterator();\n     FSParentQueue parent \u003d topParent;\n     FSQueue queue \u003d null;\n \n     while (i.hasNext()) {\n       FSParentQueue newParent \u003d null;\n       String queueName \u003d i.next();\n \n       // Check if child policy is allowed\n       SchedulingPolicy childPolicy \u003d scheduler.getAllocationConfiguration().\n           getSchedulingPolicy(queueName);\n       if (!parent.getPolicy().isChildPolicyAllowed(childPolicy)) {\n-        LOG.error(\"Can\u0027t create queue \u0027\" + queueName + \"\u0027.\");\n+        LOG.error(\"Can\u0027t create queue \u0027\" + queueName + \"\u0027,\" +\n+                \"the child scheduling policy is not allowed by parent queue!\");\n         return null;\n       }\n \n       // Only create a leaf queue at the very end\n       if (!i.hasNext() \u0026\u0026 (queueType !\u003d FSQueueType.PARENT)) {\n         FSLeafQueue leafQueue \u003d new FSLeafQueue(queueName, scheduler, parent);\n         leafQueues.add(leafQueue);\n         queue \u003d leafQueue;\n       } else {\n         if (childPolicy instanceof FifoPolicy) {\n           LOG.error(\"Can\u0027t create queue \u0027\" + queueName + \"\u0027, since \"\n               + FifoPolicy.NAME + \" is only for leaf queues.\");\n           return null;\n         }\n         newParent \u003d new FSParentQueue(queueName, scheduler, parent);\n         queue \u003d newParent;\n       }\n \n       parent.addChildQueue(queue);\n       setChildResourceLimits(parent, queue, queueConf);\n       queues.put(queue.getName(), queue);\n \n       // If we just created a leaf node, the newParent is null, but that\u0027s OK\n       // because we only create a leaf node in the very last iteration.\n       parent \u003d newParent;\n     }\n \n     return queue;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private FSQueue createNewQueues(FSQueueType queueType,\n      FSParentQueue topParent, List\u003cString\u003e newQueueNames) {\n    AllocationConfiguration queueConf \u003d scheduler.getAllocationConfiguration();\n    Iterator\u003cString\u003e i \u003d newQueueNames.iterator();\n    FSParentQueue parent \u003d topParent;\n    FSQueue queue \u003d null;\n\n    while (i.hasNext()) {\n      FSParentQueue newParent \u003d null;\n      String queueName \u003d i.next();\n\n      // Check if child policy is allowed\n      SchedulingPolicy childPolicy \u003d scheduler.getAllocationConfiguration().\n          getSchedulingPolicy(queueName);\n      if (!parent.getPolicy().isChildPolicyAllowed(childPolicy)) {\n        LOG.error(\"Can\u0027t create queue \u0027\" + queueName + \"\u0027,\" +\n                \"the child scheduling policy is not allowed by parent queue!\");\n        return null;\n      }\n\n      // Only create a leaf queue at the very end\n      if (!i.hasNext() \u0026\u0026 (queueType !\u003d FSQueueType.PARENT)) {\n        FSLeafQueue leafQueue \u003d new FSLeafQueue(queueName, scheduler, parent);\n        leafQueues.add(leafQueue);\n        queue \u003d leafQueue;\n      } else {\n        if (childPolicy instanceof FifoPolicy) {\n          LOG.error(\"Can\u0027t create queue \u0027\" + queueName + \"\u0027, since \"\n              + FifoPolicy.NAME + \" is only for leaf queues.\");\n          return null;\n        }\n        newParent \u003d new FSParentQueue(queueName, scheduler, parent);\n        queue \u003d newParent;\n      }\n\n      parent.addChildQueue(queue);\n      setChildResourceLimits(parent, queue, queueConf);\n      queues.put(queue.getName(), queue);\n\n      // If we just created a leaf node, the newParent is null, but that\u0027s OK\n      // because we only create a leaf node in the very last iteration.\n      parent \u003d newParent;\n    }\n\n    return queue;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/QueueManager.java",
      "extendedDetails": {}
    },
    "11be3f70e029c2324b167563168c8a254d234aef": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4212. FairScheduler: Can\u0027t create a DRF queue under a FAIR policy queue. (Yufei Gu via kasha)\n",
      "commitDate": "15/02/17 11:51 PM",
      "commitName": "11be3f70e029c2324b167563168c8a254d234aef",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "17/01/17 5:01 PM",
      "commitNameOld": "e224c9623493d6c4c2f3ff731fd3c72c0f448b19",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 29.28,
      "commitsBetweenForRepo": 143,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,32 +1,45 @@\n   private FSQueue createNewQueues(FSQueueType queueType,\n       FSParentQueue topParent, List\u003cString\u003e newQueueNames) {\n     AllocationConfiguration queueConf \u003d scheduler.getAllocationConfiguration();\n     Iterator\u003cString\u003e i \u003d newQueueNames.iterator();\n     FSParentQueue parent \u003d topParent;\n     FSQueue queue \u003d null;\n \n     while (i.hasNext()) {\n       FSParentQueue newParent \u003d null;\n       String queueName \u003d i.next();\n \n+      // Check if child policy is allowed\n+      SchedulingPolicy childPolicy \u003d scheduler.getAllocationConfiguration().\n+          getSchedulingPolicy(queueName);\n+      if (!parent.getPolicy().isChildPolicyAllowed(childPolicy)) {\n+        LOG.error(\"Can\u0027t create queue \u0027\" + queueName + \"\u0027.\");\n+        return null;\n+      }\n+\n       // Only create a leaf queue at the very end\n       if (!i.hasNext() \u0026\u0026 (queueType !\u003d FSQueueType.PARENT)) {\n         FSLeafQueue leafQueue \u003d new FSLeafQueue(queueName, scheduler, parent);\n         leafQueues.add(leafQueue);\n         queue \u003d leafQueue;\n       } else {\n+        if (childPolicy instanceof FifoPolicy) {\n+          LOG.error(\"Can\u0027t create queue \u0027\" + queueName + \"\u0027, since \"\n+              + FifoPolicy.NAME + \" is only for leaf queues.\");\n+          return null;\n+        }\n         newParent \u003d new FSParentQueue(queueName, scheduler, parent);\n         queue \u003d newParent;\n       }\n \n       parent.addChildQueue(queue);\n       setChildResourceLimits(parent, queue, queueConf);\n       queues.put(queue.getName(), queue);\n \n       // If we just created a leaf node, the newParent is null, but that\u0027s OK\n       // because we only create a leaf node in the very last iteration.\n       parent \u003d newParent;\n     }\n \n     return queue;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private FSQueue createNewQueues(FSQueueType queueType,\n      FSParentQueue topParent, List\u003cString\u003e newQueueNames) {\n    AllocationConfiguration queueConf \u003d scheduler.getAllocationConfiguration();\n    Iterator\u003cString\u003e i \u003d newQueueNames.iterator();\n    FSParentQueue parent \u003d topParent;\n    FSQueue queue \u003d null;\n\n    while (i.hasNext()) {\n      FSParentQueue newParent \u003d null;\n      String queueName \u003d i.next();\n\n      // Check if child policy is allowed\n      SchedulingPolicy childPolicy \u003d scheduler.getAllocationConfiguration().\n          getSchedulingPolicy(queueName);\n      if (!parent.getPolicy().isChildPolicyAllowed(childPolicy)) {\n        LOG.error(\"Can\u0027t create queue \u0027\" + queueName + \"\u0027.\");\n        return null;\n      }\n\n      // Only create a leaf queue at the very end\n      if (!i.hasNext() \u0026\u0026 (queueType !\u003d FSQueueType.PARENT)) {\n        FSLeafQueue leafQueue \u003d new FSLeafQueue(queueName, scheduler, parent);\n        leafQueues.add(leafQueue);\n        queue \u003d leafQueue;\n      } else {\n        if (childPolicy instanceof FifoPolicy) {\n          LOG.error(\"Can\u0027t create queue \u0027\" + queueName + \"\u0027, since \"\n              + FifoPolicy.NAME + \" is only for leaf queues.\");\n          return null;\n        }\n        newParent \u003d new FSParentQueue(queueName, scheduler, parent);\n        queue \u003d newParent;\n      }\n\n      parent.addChildQueue(queue);\n      setChildResourceLimits(parent, queue, queueConf);\n      queues.put(queue.getName(), queue);\n\n      // If we just created a leaf node, the newParent is null, but that\u0027s OK\n      // because we only create a leaf node in the very last iteration.\n      parent \u003d newParent;\n    }\n\n    return queue;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/QueueManager.java",
      "extendedDetails": {}
    },
    "e224c9623493d6c4c2f3ff731fd3c72c0f448b19": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5831. FairScheduler: Propagate allowPreemptionFrom flag all the way down to the app. (Yufei Gu via kasha)\n",
      "commitDate": "17/01/17 5:01 PM",
      "commitName": "e224c9623493d6c4c2f3ff731fd3c72c0f448b19",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "02/09/16 2:56 PM",
      "commitNameOld": "f6ea9be5473ab66798b0536317d2f32c5348eb57",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 137.13,
      "commitsBetweenForRepo": 894,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,32 @@\n   private FSQueue createNewQueues(FSQueueType queueType,\n       FSParentQueue topParent, List\u003cString\u003e newQueueNames) {\n     AllocationConfiguration queueConf \u003d scheduler.getAllocationConfiguration();\n     Iterator\u003cString\u003e i \u003d newQueueNames.iterator();\n     FSParentQueue parent \u003d topParent;\n     FSQueue queue \u003d null;\n \n     while (i.hasNext()) {\n       FSParentQueue newParent \u003d null;\n       String queueName \u003d i.next();\n \n       // Only create a leaf queue at the very end\n       if (!i.hasNext() \u0026\u0026 (queueType !\u003d FSQueueType.PARENT)) {\n         FSLeafQueue leafQueue \u003d new FSLeafQueue(queueName, scheduler, parent);\n         leafQueues.add(leafQueue);\n         queue \u003d leafQueue;\n       } else {\n         newParent \u003d new FSParentQueue(queueName, scheduler, parent);\n         queue \u003d newParent;\n       }\n \n-      queue.init();\n       parent.addChildQueue(queue);\n       setChildResourceLimits(parent, queue, queueConf);\n       queues.put(queue.getName(), queue);\n-      queue.updatePreemptionVariables();\n \n       // If we just created a leaf node, the newParent is null, but that\u0027s OK\n       // because we only create a leaf node in the very last iteration.\n       parent \u003d newParent;\n     }\n \n     return queue;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private FSQueue createNewQueues(FSQueueType queueType,\n      FSParentQueue topParent, List\u003cString\u003e newQueueNames) {\n    AllocationConfiguration queueConf \u003d scheduler.getAllocationConfiguration();\n    Iterator\u003cString\u003e i \u003d newQueueNames.iterator();\n    FSParentQueue parent \u003d topParent;\n    FSQueue queue \u003d null;\n\n    while (i.hasNext()) {\n      FSParentQueue newParent \u003d null;\n      String queueName \u003d i.next();\n\n      // Only create a leaf queue at the very end\n      if (!i.hasNext() \u0026\u0026 (queueType !\u003d FSQueueType.PARENT)) {\n        FSLeafQueue leafQueue \u003d new FSLeafQueue(queueName, scheduler, parent);\n        leafQueues.add(leafQueue);\n        queue \u003d leafQueue;\n      } else {\n        newParent \u003d new FSParentQueue(queueName, scheduler, parent);\n        queue \u003d newParent;\n      }\n\n      parent.addChildQueue(queue);\n      setChildResourceLimits(parent, queue, queueConf);\n      queues.put(queue.getName(), queue);\n\n      // If we just created a leaf node, the newParent is null, but that\u0027s OK\n      // because we only create a leaf node in the very last iteration.\n      parent \u003d newParent;\n    }\n\n    return queue;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/QueueManager.java",
      "extendedDetails": {}
    },
    "f6ea9be5473ab66798b0536317d2f32c5348eb57": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5264. Store all queue-specific information in FSQueue. (Yufei Gu via kasha)\n",
      "commitDate": "02/09/16 2:56 PM",
      "commitName": "f6ea9be5473ab66798b0536317d2f32c5348eb57",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "17/08/16 5:40 PM",
      "commitNameOld": "20f0eb871c57cc4c5a6d19aae0e3745b6175509b",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 15.89,
      "commitsBetweenForRepo": 103,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,51 +1,34 @@\n   private FSQueue createNewQueues(FSQueueType queueType,\n       FSParentQueue topParent, List\u003cString\u003e newQueueNames) {\n     AllocationConfiguration queueConf \u003d scheduler.getAllocationConfiguration();\n     Iterator\u003cString\u003e i \u003d newQueueNames.iterator();\n     FSParentQueue parent \u003d topParent;\n     FSQueue queue \u003d null;\n \n     while (i.hasNext()) {\n       FSParentQueue newParent \u003d null;\n       String queueName \u003d i.next();\n \n       // Only create a leaf queue at the very end\n       if (!i.hasNext() \u0026\u0026 (queueType !\u003d FSQueueType.PARENT)) {\n         FSLeafQueue leafQueue \u003d new FSLeafQueue(queueName, scheduler, parent);\n-\n-        try {\n-          leafQueue.setPolicy(queueConf.getDefaultSchedulingPolicy());\n-        } catch (AllocationConfigurationException ex) {\n-          LOG.warn(\"Failed to set default scheduling policy \"\n-              + queueConf.getDefaultSchedulingPolicy()\n-              + \" on new leaf queue.\", ex);\n-        }\n-\n         leafQueues.add(leafQueue);\n         queue \u003d leafQueue;\n       } else {\n         newParent \u003d new FSParentQueue(queueName, scheduler, parent);\n-\n-        try {\n-          newParent.setPolicy(queueConf.getDefaultSchedulingPolicy());\n-        } catch (AllocationConfigurationException ex) {\n-          LOG.warn(\"Failed to set default scheduling policy \"\n-              + queueConf.getDefaultSchedulingPolicy()\n-              + \" on new parent queue.\", ex);\n-        }\n-\n         queue \u003d newParent;\n       }\n \n+      queue.init();\n       parent.addChildQueue(queue);\n       setChildResourceLimits(parent, queue, queueConf);\n       queues.put(queue.getName(), queue);\n       queue.updatePreemptionVariables();\n \n       // If we just created a leaf node, the newParent is null, but that\u0027s OK\n       // because we only create a leaf node in the very last iteration.\n       parent \u003d newParent;\n     }\n \n     return queue;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private FSQueue createNewQueues(FSQueueType queueType,\n      FSParentQueue topParent, List\u003cString\u003e newQueueNames) {\n    AllocationConfiguration queueConf \u003d scheduler.getAllocationConfiguration();\n    Iterator\u003cString\u003e i \u003d newQueueNames.iterator();\n    FSParentQueue parent \u003d topParent;\n    FSQueue queue \u003d null;\n\n    while (i.hasNext()) {\n      FSParentQueue newParent \u003d null;\n      String queueName \u003d i.next();\n\n      // Only create a leaf queue at the very end\n      if (!i.hasNext() \u0026\u0026 (queueType !\u003d FSQueueType.PARENT)) {\n        FSLeafQueue leafQueue \u003d new FSLeafQueue(queueName, scheduler, parent);\n        leafQueues.add(leafQueue);\n        queue \u003d leafQueue;\n      } else {\n        newParent \u003d new FSParentQueue(queueName, scheduler, parent);\n        queue \u003d newParent;\n      }\n\n      queue.init();\n      parent.addChildQueue(queue);\n      setChildResourceLimits(parent, queue, queueConf);\n      queues.put(queue.getName(), queue);\n      queue.updatePreemptionVariables();\n\n      // If we just created a leaf node, the newParent is null, but that\u0027s OK\n      // because we only create a leaf node in the very last iteration.\n      parent \u003d newParent;\n    }\n\n    return queue;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/QueueManager.java",
      "extendedDetails": {}
    },
    "20f0eb871c57cc4c5a6d19aae0e3745b6175509b": {
      "type": "Yintroduced",
      "commitMessage": "YARN-4702. FairScheduler: Allow setting maxResources for ad hoc queues. (Daniel Templeton via kasha)\n",
      "commitDate": "17/08/16 5:40 PM",
      "commitName": "20f0eb871c57cc4c5a6d19aae0e3745b6175509b",
      "commitAuthor": "Karthik Kambatla",
      "diff": "@@ -0,0 +1,51 @@\n+  private FSQueue createNewQueues(FSQueueType queueType,\n+      FSParentQueue topParent, List\u003cString\u003e newQueueNames) {\n+    AllocationConfiguration queueConf \u003d scheduler.getAllocationConfiguration();\n+    Iterator\u003cString\u003e i \u003d newQueueNames.iterator();\n+    FSParentQueue parent \u003d topParent;\n+    FSQueue queue \u003d null;\n+\n+    while (i.hasNext()) {\n+      FSParentQueue newParent \u003d null;\n+      String queueName \u003d i.next();\n+\n+      // Only create a leaf queue at the very end\n+      if (!i.hasNext() \u0026\u0026 (queueType !\u003d FSQueueType.PARENT)) {\n+        FSLeafQueue leafQueue \u003d new FSLeafQueue(queueName, scheduler, parent);\n+\n+        try {\n+          leafQueue.setPolicy(queueConf.getDefaultSchedulingPolicy());\n+        } catch (AllocationConfigurationException ex) {\n+          LOG.warn(\"Failed to set default scheduling policy \"\n+              + queueConf.getDefaultSchedulingPolicy()\n+              + \" on new leaf queue.\", ex);\n+        }\n+\n+        leafQueues.add(leafQueue);\n+        queue \u003d leafQueue;\n+      } else {\n+        newParent \u003d new FSParentQueue(queueName, scheduler, parent);\n+\n+        try {\n+          newParent.setPolicy(queueConf.getDefaultSchedulingPolicy());\n+        } catch (AllocationConfigurationException ex) {\n+          LOG.warn(\"Failed to set default scheduling policy \"\n+              + queueConf.getDefaultSchedulingPolicy()\n+              + \" on new parent queue.\", ex);\n+        }\n+\n+        queue \u003d newParent;\n+      }\n+\n+      parent.addChildQueue(queue);\n+      setChildResourceLimits(parent, queue, queueConf);\n+      queues.put(queue.getName(), queue);\n+      queue.updatePreemptionVariables();\n+\n+      // If we just created a leaf node, the newParent is null, but that\u0027s OK\n+      // because we only create a leaf node in the very last iteration.\n+      parent \u003d newParent;\n+    }\n+\n+    return queue;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private FSQueue createNewQueues(FSQueueType queueType,\n      FSParentQueue topParent, List\u003cString\u003e newQueueNames) {\n    AllocationConfiguration queueConf \u003d scheduler.getAllocationConfiguration();\n    Iterator\u003cString\u003e i \u003d newQueueNames.iterator();\n    FSParentQueue parent \u003d topParent;\n    FSQueue queue \u003d null;\n\n    while (i.hasNext()) {\n      FSParentQueue newParent \u003d null;\n      String queueName \u003d i.next();\n\n      // Only create a leaf queue at the very end\n      if (!i.hasNext() \u0026\u0026 (queueType !\u003d FSQueueType.PARENT)) {\n        FSLeafQueue leafQueue \u003d new FSLeafQueue(queueName, scheduler, parent);\n\n        try {\n          leafQueue.setPolicy(queueConf.getDefaultSchedulingPolicy());\n        } catch (AllocationConfigurationException ex) {\n          LOG.warn(\"Failed to set default scheduling policy \"\n              + queueConf.getDefaultSchedulingPolicy()\n              + \" on new leaf queue.\", ex);\n        }\n\n        leafQueues.add(leafQueue);\n        queue \u003d leafQueue;\n      } else {\n        newParent \u003d new FSParentQueue(queueName, scheduler, parent);\n\n        try {\n          newParent.setPolicy(queueConf.getDefaultSchedulingPolicy());\n        } catch (AllocationConfigurationException ex) {\n          LOG.warn(\"Failed to set default scheduling policy \"\n              + queueConf.getDefaultSchedulingPolicy()\n              + \" on new parent queue.\", ex);\n        }\n\n        queue \u003d newParent;\n      }\n\n      parent.addChildQueue(queue);\n      setChildResourceLimits(parent, queue, queueConf);\n      queues.put(queue.getName(), queue);\n      queue.updatePreemptionVariables();\n\n      // If we just created a leaf node, the newParent is null, but that\u0027s OK\n      // because we only create a leaf node in the very last iteration.\n      parent \u003d newParent;\n    }\n\n    return queue;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/QueueManager.java"
    }
  }
}