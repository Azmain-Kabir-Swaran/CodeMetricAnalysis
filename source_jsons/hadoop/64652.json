{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "S3AFileSystem.java",
  "functionName": "innerMkdirs",
  "functionId": "innerMkdirs___p-Path__permission-FsPermission",
  "sourceFilePath": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
  "functionStartLine": 2720,
  "functionEndLine": 2760,
  "numCommitsSeen": 235,
  "timeTaken": 8655,
  "changeHistory": [
    "ae2eb2dd4261e5fef964384efd168d9867eb94af",
    "a0c71dcc33ca7c5539d0ab61c4a276c4f39e5744",
    "ef450df443f1dea1c52082cf281f25db7141972f",
    "621b43e254afaff708cd6fc4698b29628f6abc33",
    "6aeda55bb8f741d9dafd41f6dfbf1a88acdd4003",
    "b053fdc547ddbb6322674142a14010683006d123",
    "be9e46b42dd1ed0b2295bd36a7d81d5ee6dffc25",
    "c58a59f7081d55dd2108545ebf9ee48cf43ca944",
    "587061103097160d8aceb60dbef6958cafdd30ae",
    "39ec1515a205952eda7e171408a8b83eceb4abde",
    "27c4e90efce04e1b1302f668b5eb22412e00d033",
    "6ba52d88ec11444cbac946ffadbc645acd0657de",
    "24d920b80eb3626073925a1d0b6dcf148add8cc0"
  ],
  "changeHistoryShort": {
    "ae2eb2dd4261e5fef964384efd168d9867eb94af": "Ybodychange",
    "a0c71dcc33ca7c5539d0ab61c4a276c4f39e5744": "Ybodychange",
    "ef450df443f1dea1c52082cf281f25db7141972f": "Ybodychange",
    "621b43e254afaff708cd6fc4698b29628f6abc33": "Ymultichange(Yparameterchange,Ybodychange)",
    "6aeda55bb8f741d9dafd41f6dfbf1a88acdd4003": "Ybodychange",
    "b053fdc547ddbb6322674142a14010683006d123": "Ybodychange",
    "be9e46b42dd1ed0b2295bd36a7d81d5ee6dffc25": "Ybodychange",
    "c58a59f7081d55dd2108545ebf9ee48cf43ca944": "Ybodychange",
    "587061103097160d8aceb60dbef6958cafdd30ae": "Ybodychange",
    "39ec1515a205952eda7e171408a8b83eceb4abde": "Ymultichange(Yrename,Ymodifierchange,Yexceptionschange)",
    "27c4e90efce04e1b1302f668b5eb22412e00d033": "Ybodychange",
    "6ba52d88ec11444cbac946ffadbc645acd0657de": "Ybodychange",
    "24d920b80eb3626073925a1d0b6dcf148add8cc0": "Yintroduced"
  },
  "changeHistoryDetails": {
    "ae2eb2dd4261e5fef964384efd168d9867eb94af": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16201: S3AFileSystem#innerMkdirs builds needless lists (#636)\n\n",
      "commitDate": "22/03/19 4:42 AM",
      "commitName": "ae2eb2dd4261e5fef964384efd168d9867eb94af",
      "commitAuthor": "Lokesh Jain",
      "commitDateOld": "13/03/19 1:37 PM",
      "commitNameOld": "6fa229891e06eea62cb9634efde755f40247e816",
      "commitAuthorOld": "Ben Roling",
      "daysBetweenCommits": 8.63,
      "commitsBetweenForRepo": 63,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,41 @@\n   private boolean innerMkdirs(Path p, FsPermission permission)\n       throws IOException, FileAlreadyExistsException, AmazonClientException {\n     Path f \u003d qualify(p);\n     LOG.debug(\"Making directory: {}\", f);\n     entryPoint(INVOCATION_MKDIRS);\n     FileStatus fileStatus;\n-    List\u003cPath\u003e metadataStoreDirs \u003d null;\n-    if (hasMetadataStore()) {\n-      metadataStoreDirs \u003d new ArrayList\u003c\u003e();\n-    }\n \n     try {\n       fileStatus \u003d getFileStatus(f);\n \n       if (fileStatus.isDirectory()) {\n         return true;\n       } else {\n         throw new FileAlreadyExistsException(\"Path is a file: \" + f);\n       }\n     } catch (FileNotFoundException e) {\n       // Walk path to root, ensuring closest ancestor is a directory, not file\n       Path fPart \u003d f.getParent();\n-      if (metadataStoreDirs !\u003d null) {\n-        metadataStoreDirs.add(f);\n-      }\n       while (fPart !\u003d null) {\n         try {\n           fileStatus \u003d getFileStatus(fPart);\n           if (fileStatus.isDirectory()) {\n             break;\n           }\n           if (fileStatus.isFile()) {\n             throw new FileAlreadyExistsException(String.format(\n                 \"Can\u0027t make directory for path \u0027%s\u0027 since it is a file.\",\n                 fPart));\n           }\n         } catch (FileNotFoundException fnfe) {\n           instrumentation.errorIgnored();\n-          // We create all missing directories in MetadataStore; it does not\n-          // infer directories exist by prefix like S3.\n-          if (metadataStoreDirs !\u003d null) {\n-            metadataStoreDirs.add(fPart);\n-          }\n         }\n         fPart \u003d fPart.getParent();\n       }\n       String key \u003d pathToKey(f);\n       // this will create the marker file, delete the parent entries\n       // and update S3Guard\n       createFakeDirectory(key);\n       return true;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean innerMkdirs(Path p, FsPermission permission)\n      throws IOException, FileAlreadyExistsException, AmazonClientException {\n    Path f \u003d qualify(p);\n    LOG.debug(\"Making directory: {}\", f);\n    entryPoint(INVOCATION_MKDIRS);\n    FileStatus fileStatus;\n\n    try {\n      fileStatus \u003d getFileStatus(f);\n\n      if (fileStatus.isDirectory()) {\n        return true;\n      } else {\n        throw new FileAlreadyExistsException(\"Path is a file: \" + f);\n      }\n    } catch (FileNotFoundException e) {\n      // Walk path to root, ensuring closest ancestor is a directory, not file\n      Path fPart \u003d f.getParent();\n      while (fPart !\u003d null) {\n        try {\n          fileStatus \u003d getFileStatus(fPart);\n          if (fileStatus.isDirectory()) {\n            break;\n          }\n          if (fileStatus.isFile()) {\n            throw new FileAlreadyExistsException(String.format(\n                \"Can\u0027t make directory for path \u0027%s\u0027 since it is a file.\",\n                fPart));\n          }\n        } catch (FileNotFoundException fnfe) {\n          instrumentation.errorIgnored();\n        }\n        fPart \u003d fPart.getParent();\n      }\n      String key \u003d pathToKey(f);\n      // this will create the marker file, delete the parent entries\n      // and update S3Guard\n      createFakeDirectory(key);\n      return true;\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "a0c71dcc33ca7c5539d0ab61c4a276c4f39e5744": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15079. ITestS3AFileOperationCost#testFakeDirectoryDeletion failing\nafter OutputCommitter patch.\nContributed by Steve Loughran\n",
      "commitDate": "15/01/18 3:33 AM",
      "commitName": "a0c71dcc33ca7c5539d0ab61c4a276c4f39e5744",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "09/01/18 10:46 AM",
      "commitNameOld": "b62a5ece95a6b5bbb17f273debd55bcbf0c5f28c",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 5.7,
      "commitsBetweenForRepo": 27,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,55 +1,53 @@\n   private boolean innerMkdirs(Path p, FsPermission permission)\n       throws IOException, FileAlreadyExistsException, AmazonClientException {\n     Path f \u003d qualify(p);\n     LOG.debug(\"Making directory: {}\", f);\n     entryPoint(INVOCATION_MKDIRS);\n     FileStatus fileStatus;\n     List\u003cPath\u003e metadataStoreDirs \u003d null;\n     if (hasMetadataStore()) {\n       metadataStoreDirs \u003d new ArrayList\u003c\u003e();\n     }\n \n     try {\n       fileStatus \u003d getFileStatus(f);\n \n       if (fileStatus.isDirectory()) {\n         return true;\n       } else {\n         throw new FileAlreadyExistsException(\"Path is a file: \" + f);\n       }\n     } catch (FileNotFoundException e) {\n       // Walk path to root, ensuring closest ancestor is a directory, not file\n       Path fPart \u003d f.getParent();\n       if (metadataStoreDirs !\u003d null) {\n         metadataStoreDirs.add(f);\n       }\n       while (fPart !\u003d null) {\n         try {\n           fileStatus \u003d getFileStatus(fPart);\n           if (fileStatus.isDirectory()) {\n             break;\n           }\n           if (fileStatus.isFile()) {\n             throw new FileAlreadyExistsException(String.format(\n                 \"Can\u0027t make directory for path \u0027%s\u0027 since it is a file.\",\n                 fPart));\n           }\n         } catch (FileNotFoundException fnfe) {\n           instrumentation.errorIgnored();\n           // We create all missing directories in MetadataStore; it does not\n           // infer directories exist by prefix like S3.\n           if (metadataStoreDirs !\u003d null) {\n             metadataStoreDirs.add(fPart);\n           }\n         }\n         fPart \u003d fPart.getParent();\n       }\n       String key \u003d pathToKey(f);\n+      // this will create the marker file, delete the parent entries\n+      // and update S3Guard\n       createFakeDirectory(key);\n-      S3Guard.makeDirsOrdered(metadataStore, metadataStoreDirs, username, true);\n-      // this is complicated because getParent(a/b/c/) returns a/b/c, but\n-      // we want a/b. See HADOOP-14428 for more details.\n-      deleteUnnecessaryFakeDirectories(new Path(f.toString()).getParent());\n       return true;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean innerMkdirs(Path p, FsPermission permission)\n      throws IOException, FileAlreadyExistsException, AmazonClientException {\n    Path f \u003d qualify(p);\n    LOG.debug(\"Making directory: {}\", f);\n    entryPoint(INVOCATION_MKDIRS);\n    FileStatus fileStatus;\n    List\u003cPath\u003e metadataStoreDirs \u003d null;\n    if (hasMetadataStore()) {\n      metadataStoreDirs \u003d new ArrayList\u003c\u003e();\n    }\n\n    try {\n      fileStatus \u003d getFileStatus(f);\n\n      if (fileStatus.isDirectory()) {\n        return true;\n      } else {\n        throw new FileAlreadyExistsException(\"Path is a file: \" + f);\n      }\n    } catch (FileNotFoundException e) {\n      // Walk path to root, ensuring closest ancestor is a directory, not file\n      Path fPart \u003d f.getParent();\n      if (metadataStoreDirs !\u003d null) {\n        metadataStoreDirs.add(f);\n      }\n      while (fPart !\u003d null) {\n        try {\n          fileStatus \u003d getFileStatus(fPart);\n          if (fileStatus.isDirectory()) {\n            break;\n          }\n          if (fileStatus.isFile()) {\n            throw new FileAlreadyExistsException(String.format(\n                \"Can\u0027t make directory for path \u0027%s\u0027 since it is a file.\",\n                fPart));\n          }\n        } catch (FileNotFoundException fnfe) {\n          instrumentation.errorIgnored();\n          // We create all missing directories in MetadataStore; it does not\n          // infer directories exist by prefix like S3.\n          if (metadataStoreDirs !\u003d null) {\n            metadataStoreDirs.add(fPart);\n          }\n        }\n        fPart \u003d fPart.getParent();\n      }\n      String key \u003d pathToKey(f);\n      // this will create the marker file, delete the parent entries\n      // and update S3Guard\n      createFakeDirectory(key);\n      return true;\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "ef450df443f1dea1c52082cf281f25db7141972f": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15113. NPE in S3A getFileStatus: null instrumentation on using closed instance.\nContributed by Steve Loughran.\n",
      "commitDate": "21/12/17 6:15 AM",
      "commitName": "ef450df443f1dea1c52082cf281f25db7141972f",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "18/12/17 1:19 PM",
      "commitNameOld": "35ad9b1dd279b769381ea1625d9bf776c309c5cb",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 2.71,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,55 +1,55 @@\n   private boolean innerMkdirs(Path p, FsPermission permission)\n       throws IOException, FileAlreadyExistsException, AmazonClientException {\n     Path f \u003d qualify(p);\n     LOG.debug(\"Making directory: {}\", f);\n-    incrementStatistic(INVOCATION_MKDIRS);\n+    entryPoint(INVOCATION_MKDIRS);\n     FileStatus fileStatus;\n     List\u003cPath\u003e metadataStoreDirs \u003d null;\n     if (hasMetadataStore()) {\n       metadataStoreDirs \u003d new ArrayList\u003c\u003e();\n     }\n \n     try {\n       fileStatus \u003d getFileStatus(f);\n \n       if (fileStatus.isDirectory()) {\n         return true;\n       } else {\n         throw new FileAlreadyExistsException(\"Path is a file: \" + f);\n       }\n     } catch (FileNotFoundException e) {\n       // Walk path to root, ensuring closest ancestor is a directory, not file\n       Path fPart \u003d f.getParent();\n       if (metadataStoreDirs !\u003d null) {\n         metadataStoreDirs.add(f);\n       }\n       while (fPart !\u003d null) {\n         try {\n           fileStatus \u003d getFileStatus(fPart);\n           if (fileStatus.isDirectory()) {\n             break;\n           }\n           if (fileStatus.isFile()) {\n             throw new FileAlreadyExistsException(String.format(\n                 \"Can\u0027t make directory for path \u0027%s\u0027 since it is a file.\",\n                 fPart));\n           }\n         } catch (FileNotFoundException fnfe) {\n           instrumentation.errorIgnored();\n           // We create all missing directories in MetadataStore; it does not\n           // infer directories exist by prefix like S3.\n           if (metadataStoreDirs !\u003d null) {\n             metadataStoreDirs.add(fPart);\n           }\n         }\n         fPart \u003d fPart.getParent();\n       }\n       String key \u003d pathToKey(f);\n       createFakeDirectory(key);\n       S3Guard.makeDirsOrdered(metadataStore, metadataStoreDirs, username, true);\n       // this is complicated because getParent(a/b/c/) returns a/b/c, but\n       // we want a/b. See HADOOP-14428 for more details.\n       deleteUnnecessaryFakeDirectories(new Path(f.toString()).getParent());\n       return true;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean innerMkdirs(Path p, FsPermission permission)\n      throws IOException, FileAlreadyExistsException, AmazonClientException {\n    Path f \u003d qualify(p);\n    LOG.debug(\"Making directory: {}\", f);\n    entryPoint(INVOCATION_MKDIRS);\n    FileStatus fileStatus;\n    List\u003cPath\u003e metadataStoreDirs \u003d null;\n    if (hasMetadataStore()) {\n      metadataStoreDirs \u003d new ArrayList\u003c\u003e();\n    }\n\n    try {\n      fileStatus \u003d getFileStatus(f);\n\n      if (fileStatus.isDirectory()) {\n        return true;\n      } else {\n        throw new FileAlreadyExistsException(\"Path is a file: \" + f);\n      }\n    } catch (FileNotFoundException e) {\n      // Walk path to root, ensuring closest ancestor is a directory, not file\n      Path fPart \u003d f.getParent();\n      if (metadataStoreDirs !\u003d null) {\n        metadataStoreDirs.add(f);\n      }\n      while (fPart !\u003d null) {\n        try {\n          fileStatus \u003d getFileStatus(fPart);\n          if (fileStatus.isDirectory()) {\n            break;\n          }\n          if (fileStatus.isFile()) {\n            throw new FileAlreadyExistsException(String.format(\n                \"Can\u0027t make directory for path \u0027%s\u0027 since it is a file.\",\n                fPart));\n          }\n        } catch (FileNotFoundException fnfe) {\n          instrumentation.errorIgnored();\n          // We create all missing directories in MetadataStore; it does not\n          // infer directories exist by prefix like S3.\n          if (metadataStoreDirs !\u003d null) {\n            metadataStoreDirs.add(fPart);\n          }\n        }\n        fPart \u003d fPart.getParent();\n      }\n      String key \u003d pathToKey(f);\n      createFakeDirectory(key);\n      S3Guard.makeDirsOrdered(metadataStore, metadataStoreDirs, username, true);\n      // this is complicated because getParent(a/b/c/) returns a/b/c, but\n      // we want a/b. See HADOOP-14428 for more details.\n      deleteUnnecessaryFakeDirectories(new Path(f.toString()).getParent());\n      return true;\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "621b43e254afaff708cd6fc4698b29628f6abc33": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HADOOP-13345 HS3Guard: Improved Consistency for S3A.\nContributed by: Chris Nauroth, Aaron Fabbri, Mingliang Liu, Lei (Eddy) Xu,\nSean Mackrory, Steve Loughran and others.\n",
      "commitDate": "01/09/17 6:13 AM",
      "commitName": "621b43e254afaff708cd6fc4698b29628f6abc33",
      "commitAuthor": "Steve Loughran",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-13345 HS3Guard: Improved Consistency for S3A.\nContributed by: Chris Nauroth, Aaron Fabbri, Mingliang Liu, Lei (Eddy) Xu,\nSean Mackrory, Steve Loughran and others.\n",
          "commitDate": "01/09/17 6:13 AM",
          "commitName": "621b43e254afaff708cd6fc4698b29628f6abc33",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "05/06/17 11:26 AM",
          "commitNameOld": "6aeda55bb8f741d9dafd41f6dfbf1a88acdd4003",
          "commitAuthorOld": "Mingliang Liu",
          "daysBetweenCommits": 87.78,
          "commitsBetweenForRepo": 591,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,40 +1,55 @@\n-  private boolean innerMkdirs(Path f, FsPermission permission)\n+  private boolean innerMkdirs(Path p, FsPermission permission)\n       throws IOException, FileAlreadyExistsException, AmazonClientException {\n+    Path f \u003d qualify(p);\n     LOG.debug(\"Making directory: {}\", f);\n     incrementStatistic(INVOCATION_MKDIRS);\n     FileStatus fileStatus;\n+    List\u003cPath\u003e metadataStoreDirs \u003d null;\n+    if (hasMetadataStore()) {\n+      metadataStoreDirs \u003d new ArrayList\u003c\u003e();\n+    }\n+\n     try {\n       fileStatus \u003d getFileStatus(f);\n \n       if (fileStatus.isDirectory()) {\n         return true;\n       } else {\n         throw new FileAlreadyExistsException(\"Path is a file: \" + f);\n       }\n     } catch (FileNotFoundException e) {\n+      // Walk path to root, ensuring closest ancestor is a directory, not file\n       Path fPart \u003d f.getParent();\n-      do {\n+      if (metadataStoreDirs !\u003d null) {\n+        metadataStoreDirs.add(f);\n+      }\n+      while (fPart !\u003d null) {\n         try {\n           fileStatus \u003d getFileStatus(fPart);\n           if (fileStatus.isDirectory()) {\n             break;\n           }\n           if (fileStatus.isFile()) {\n             throw new FileAlreadyExistsException(String.format(\n                 \"Can\u0027t make directory for path \u0027%s\u0027 since it is a file.\",\n                 fPart));\n           }\n         } catch (FileNotFoundException fnfe) {\n           instrumentation.errorIgnored();\n+          // We create all missing directories in MetadataStore; it does not\n+          // infer directories exist by prefix like S3.\n+          if (metadataStoreDirs !\u003d null) {\n+            metadataStoreDirs.add(fPart);\n+          }\n         }\n         fPart \u003d fPart.getParent();\n-      } while (fPart !\u003d null);\n-\n+      }\n       String key \u003d pathToKey(f);\n       createFakeDirectory(key);\n+      S3Guard.makeDirsOrdered(metadataStore, metadataStoreDirs, username, true);\n       // this is complicated because getParent(a/b/c/) returns a/b/c, but\n       // we want a/b. See HADOOP-14428 for more details.\n       deleteUnnecessaryFakeDirectories(new Path(f.toString()).getParent());\n       return true;\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private boolean innerMkdirs(Path p, FsPermission permission)\n      throws IOException, FileAlreadyExistsException, AmazonClientException {\n    Path f \u003d qualify(p);\n    LOG.debug(\"Making directory: {}\", f);\n    incrementStatistic(INVOCATION_MKDIRS);\n    FileStatus fileStatus;\n    List\u003cPath\u003e metadataStoreDirs \u003d null;\n    if (hasMetadataStore()) {\n      metadataStoreDirs \u003d new ArrayList\u003c\u003e();\n    }\n\n    try {\n      fileStatus \u003d getFileStatus(f);\n\n      if (fileStatus.isDirectory()) {\n        return true;\n      } else {\n        throw new FileAlreadyExistsException(\"Path is a file: \" + f);\n      }\n    } catch (FileNotFoundException e) {\n      // Walk path to root, ensuring closest ancestor is a directory, not file\n      Path fPart \u003d f.getParent();\n      if (metadataStoreDirs !\u003d null) {\n        metadataStoreDirs.add(f);\n      }\n      while (fPart !\u003d null) {\n        try {\n          fileStatus \u003d getFileStatus(fPart);\n          if (fileStatus.isDirectory()) {\n            break;\n          }\n          if (fileStatus.isFile()) {\n            throw new FileAlreadyExistsException(String.format(\n                \"Can\u0027t make directory for path \u0027%s\u0027 since it is a file.\",\n                fPart));\n          }\n        } catch (FileNotFoundException fnfe) {\n          instrumentation.errorIgnored();\n          // We create all missing directories in MetadataStore; it does not\n          // infer directories exist by prefix like S3.\n          if (metadataStoreDirs !\u003d null) {\n            metadataStoreDirs.add(fPart);\n          }\n        }\n        fPart \u003d fPart.getParent();\n      }\n      String key \u003d pathToKey(f);\n      createFakeDirectory(key);\n      S3Guard.makeDirsOrdered(metadataStore, metadataStoreDirs, username, true);\n      // this is complicated because getParent(a/b/c/) returns a/b/c, but\n      // we want a/b. See HADOOP-14428 for more details.\n      deleteUnnecessaryFakeDirectories(new Path(f.toString()).getParent());\n      return true;\n    }\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
          "extendedDetails": {
            "oldValue": "[f-Path, permission-FsPermission]",
            "newValue": "[p-Path, permission-FsPermission]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-13345 HS3Guard: Improved Consistency for S3A.\nContributed by: Chris Nauroth, Aaron Fabbri, Mingliang Liu, Lei (Eddy) Xu,\nSean Mackrory, Steve Loughran and others.\n",
          "commitDate": "01/09/17 6:13 AM",
          "commitName": "621b43e254afaff708cd6fc4698b29628f6abc33",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "05/06/17 11:26 AM",
          "commitNameOld": "6aeda55bb8f741d9dafd41f6dfbf1a88acdd4003",
          "commitAuthorOld": "Mingliang Liu",
          "daysBetweenCommits": 87.78,
          "commitsBetweenForRepo": 591,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,40 +1,55 @@\n-  private boolean innerMkdirs(Path f, FsPermission permission)\n+  private boolean innerMkdirs(Path p, FsPermission permission)\n       throws IOException, FileAlreadyExistsException, AmazonClientException {\n+    Path f \u003d qualify(p);\n     LOG.debug(\"Making directory: {}\", f);\n     incrementStatistic(INVOCATION_MKDIRS);\n     FileStatus fileStatus;\n+    List\u003cPath\u003e metadataStoreDirs \u003d null;\n+    if (hasMetadataStore()) {\n+      metadataStoreDirs \u003d new ArrayList\u003c\u003e();\n+    }\n+\n     try {\n       fileStatus \u003d getFileStatus(f);\n \n       if (fileStatus.isDirectory()) {\n         return true;\n       } else {\n         throw new FileAlreadyExistsException(\"Path is a file: \" + f);\n       }\n     } catch (FileNotFoundException e) {\n+      // Walk path to root, ensuring closest ancestor is a directory, not file\n       Path fPart \u003d f.getParent();\n-      do {\n+      if (metadataStoreDirs !\u003d null) {\n+        metadataStoreDirs.add(f);\n+      }\n+      while (fPart !\u003d null) {\n         try {\n           fileStatus \u003d getFileStatus(fPart);\n           if (fileStatus.isDirectory()) {\n             break;\n           }\n           if (fileStatus.isFile()) {\n             throw new FileAlreadyExistsException(String.format(\n                 \"Can\u0027t make directory for path \u0027%s\u0027 since it is a file.\",\n                 fPart));\n           }\n         } catch (FileNotFoundException fnfe) {\n           instrumentation.errorIgnored();\n+          // We create all missing directories in MetadataStore; it does not\n+          // infer directories exist by prefix like S3.\n+          if (metadataStoreDirs !\u003d null) {\n+            metadataStoreDirs.add(fPart);\n+          }\n         }\n         fPart \u003d fPart.getParent();\n-      } while (fPart !\u003d null);\n-\n+      }\n       String key \u003d pathToKey(f);\n       createFakeDirectory(key);\n+      S3Guard.makeDirsOrdered(metadataStore, metadataStoreDirs, username, true);\n       // this is complicated because getParent(a/b/c/) returns a/b/c, but\n       // we want a/b. See HADOOP-14428 for more details.\n       deleteUnnecessaryFakeDirectories(new Path(f.toString()).getParent());\n       return true;\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private boolean innerMkdirs(Path p, FsPermission permission)\n      throws IOException, FileAlreadyExistsException, AmazonClientException {\n    Path f \u003d qualify(p);\n    LOG.debug(\"Making directory: {}\", f);\n    incrementStatistic(INVOCATION_MKDIRS);\n    FileStatus fileStatus;\n    List\u003cPath\u003e metadataStoreDirs \u003d null;\n    if (hasMetadataStore()) {\n      metadataStoreDirs \u003d new ArrayList\u003c\u003e();\n    }\n\n    try {\n      fileStatus \u003d getFileStatus(f);\n\n      if (fileStatus.isDirectory()) {\n        return true;\n      } else {\n        throw new FileAlreadyExistsException(\"Path is a file: \" + f);\n      }\n    } catch (FileNotFoundException e) {\n      // Walk path to root, ensuring closest ancestor is a directory, not file\n      Path fPart \u003d f.getParent();\n      if (metadataStoreDirs !\u003d null) {\n        metadataStoreDirs.add(f);\n      }\n      while (fPart !\u003d null) {\n        try {\n          fileStatus \u003d getFileStatus(fPart);\n          if (fileStatus.isDirectory()) {\n            break;\n          }\n          if (fileStatus.isFile()) {\n            throw new FileAlreadyExistsException(String.format(\n                \"Can\u0027t make directory for path \u0027%s\u0027 since it is a file.\",\n                fPart));\n          }\n        } catch (FileNotFoundException fnfe) {\n          instrumentation.errorIgnored();\n          // We create all missing directories in MetadataStore; it does not\n          // infer directories exist by prefix like S3.\n          if (metadataStoreDirs !\u003d null) {\n            metadataStoreDirs.add(fPart);\n          }\n        }\n        fPart \u003d fPart.getParent();\n      }\n      String key \u003d pathToKey(f);\n      createFakeDirectory(key);\n      S3Guard.makeDirsOrdered(metadataStore, metadataStoreDirs, username, true);\n      // this is complicated because getParent(a/b/c/) returns a/b/c, but\n      // we want a/b. See HADOOP-14428 for more details.\n      deleteUnnecessaryFakeDirectories(new Path(f.toString()).getParent());\n      return true;\n    }\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
          "extendedDetails": {}
        }
      ]
    },
    "6aeda55bb8f741d9dafd41f6dfbf1a88acdd4003": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14428. s3a: mkdir appears to be broken. Contributed by Mingliang Liu\n",
      "commitDate": "05/06/17 11:26 AM",
      "commitName": "6aeda55bb8f741d9dafd41f6dfbf1a88acdd4003",
      "commitAuthor": "Mingliang Liu",
      "commitDateOld": "19/05/17 11:51 AM",
      "commitNameOld": "6672810eeac1c94fd764aaf2a709ace9d4b5aa76",
      "commitAuthorOld": "Mingliang Liu",
      "daysBetweenCommits": 16.98,
      "commitsBetweenForRepo": 78,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,40 @@\n   private boolean innerMkdirs(Path f, FsPermission permission)\n       throws IOException, FileAlreadyExistsException, AmazonClientException {\n     LOG.debug(\"Making directory: {}\", f);\n     incrementStatistic(INVOCATION_MKDIRS);\n     FileStatus fileStatus;\n     try {\n       fileStatus \u003d getFileStatus(f);\n \n       if (fileStatus.isDirectory()) {\n         return true;\n       } else {\n         throw new FileAlreadyExistsException(\"Path is a file: \" + f);\n       }\n     } catch (FileNotFoundException e) {\n       Path fPart \u003d f.getParent();\n       do {\n         try {\n           fileStatus \u003d getFileStatus(fPart);\n           if (fileStatus.isDirectory()) {\n             break;\n           }\n           if (fileStatus.isFile()) {\n             throw new FileAlreadyExistsException(String.format(\n                 \"Can\u0027t make directory for path \u0027%s\u0027 since it is a file.\",\n                 fPart));\n           }\n         } catch (FileNotFoundException fnfe) {\n           instrumentation.errorIgnored();\n         }\n         fPart \u003d fPart.getParent();\n       } while (fPart !\u003d null);\n \n       String key \u003d pathToKey(f);\n       createFakeDirectory(key);\n-      deleteUnnecessaryFakeDirectories(f.getParent());\n+      // this is complicated because getParent(a/b/c/) returns a/b/c, but\n+      // we want a/b. See HADOOP-14428 for more details.\n+      deleteUnnecessaryFakeDirectories(new Path(f.toString()).getParent());\n       return true;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean innerMkdirs(Path f, FsPermission permission)\n      throws IOException, FileAlreadyExistsException, AmazonClientException {\n    LOG.debug(\"Making directory: {}\", f);\n    incrementStatistic(INVOCATION_MKDIRS);\n    FileStatus fileStatus;\n    try {\n      fileStatus \u003d getFileStatus(f);\n\n      if (fileStatus.isDirectory()) {\n        return true;\n      } else {\n        throw new FileAlreadyExistsException(\"Path is a file: \" + f);\n      }\n    } catch (FileNotFoundException e) {\n      Path fPart \u003d f.getParent();\n      do {\n        try {\n          fileStatus \u003d getFileStatus(fPart);\n          if (fileStatus.isDirectory()) {\n            break;\n          }\n          if (fileStatus.isFile()) {\n            throw new FileAlreadyExistsException(String.format(\n                \"Can\u0027t make directory for path \u0027%s\u0027 since it is a file.\",\n                fPart));\n          }\n        } catch (FileNotFoundException fnfe) {\n          instrumentation.errorIgnored();\n        }\n        fPart \u003d fPart.getParent();\n      } while (fPart !\u003d null);\n\n      String key \u003d pathToKey(f);\n      createFakeDirectory(key);\n      // this is complicated because getParent(a/b/c/) returns a/b/c, but\n      // we want a/b. See HADOOP-14428 for more details.\n      deleteUnnecessaryFakeDirectories(new Path(f.toString()).getParent());\n      return true;\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "b053fdc547ddbb6322674142a14010683006d123": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14255. S3A to delete unnecessary fake directory objects in mkdirs(). Contributed by Mingliang Liu\n",
      "commitDate": "12/04/17 2:30 PM",
      "commitName": "b053fdc547ddbb6322674142a14010683006d123",
      "commitAuthor": "Mingliang Liu",
      "commitDateOld": "23/03/17 11:33 AM",
      "commitNameOld": "2e30aa72e01de7b5774fcb312406a393221e0908",
      "commitAuthorOld": "Mingliang Liu",
      "daysBetweenCommits": 20.12,
      "commitsBetweenForRepo": 140,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,37 +1,38 @@\n   private boolean innerMkdirs(Path f, FsPermission permission)\n       throws IOException, FileAlreadyExistsException, AmazonClientException {\n     LOG.debug(\"Making directory: {}\", f);\n     incrementStatistic(INVOCATION_MKDIRS);\n     FileStatus fileStatus;\n     try {\n       fileStatus \u003d getFileStatus(f);\n \n       if (fileStatus.isDirectory()) {\n         return true;\n       } else {\n         throw new FileAlreadyExistsException(\"Path is a file: \" + f);\n       }\n     } catch (FileNotFoundException e) {\n       Path fPart \u003d f.getParent();\n       do {\n         try {\n           fileStatus \u003d getFileStatus(fPart);\n           if (fileStatus.isDirectory()) {\n             break;\n           }\n           if (fileStatus.isFile()) {\n             throw new FileAlreadyExistsException(String.format(\n                 \"Can\u0027t make directory for path \u0027%s\u0027 since it is a file.\",\n                 fPart));\n           }\n         } catch (FileNotFoundException fnfe) {\n           instrumentation.errorIgnored();\n         }\n         fPart \u003d fPart.getParent();\n       } while (fPart !\u003d null);\n \n       String key \u003d pathToKey(f);\n       createFakeDirectory(key);\n+      deleteUnnecessaryFakeDirectories(f.getParent());\n       return true;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean innerMkdirs(Path f, FsPermission permission)\n      throws IOException, FileAlreadyExistsException, AmazonClientException {\n    LOG.debug(\"Making directory: {}\", f);\n    incrementStatistic(INVOCATION_MKDIRS);\n    FileStatus fileStatus;\n    try {\n      fileStatus \u003d getFileStatus(f);\n\n      if (fileStatus.isDirectory()) {\n        return true;\n      } else {\n        throw new FileAlreadyExistsException(\"Path is a file: \" + f);\n      }\n    } catch (FileNotFoundException e) {\n      Path fPart \u003d f.getParent();\n      do {\n        try {\n          fileStatus \u003d getFileStatus(fPart);\n          if (fileStatus.isDirectory()) {\n            break;\n          }\n          if (fileStatus.isFile()) {\n            throw new FileAlreadyExistsException(String.format(\n                \"Can\u0027t make directory for path \u0027%s\u0027 since it is a file.\",\n                fPart));\n          }\n        } catch (FileNotFoundException fnfe) {\n          instrumentation.errorIgnored();\n        }\n        fPart \u003d fPart.getParent();\n      } while (fPart !\u003d null);\n\n      String key \u003d pathToKey(f);\n      createFakeDirectory(key);\n      deleteUnnecessaryFakeDirectories(f.getParent());\n      return true;\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "be9e46b42dd1ed0b2295bd36a7d81d5ee6dffc25": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13406 S3AFileSystem: Consider reusing filestatus in delete() and mkdirs(). Contributed by Rajesh Balamohan\n",
      "commitDate": "25/07/16 6:45 AM",
      "commitName": "be9e46b42dd1ed0b2295bd36a7d81d5ee6dffc25",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "20/07/16 5:42 AM",
      "commitNameOld": "37362c2f922b8d038002e61132b110ae4dd6d5ba",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 5.04,
      "commitsBetweenForRepo": 22,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,36 +1,37 @@\n   private boolean innerMkdirs(Path f, FsPermission permission)\n       throws IOException, FileAlreadyExistsException, AmazonClientException {\n     LOG.debug(\"Making directory: {}\", f);\n     incrementStatistic(INVOCATION_MKDIRS);\n+    FileStatus fileStatus;\n     try {\n-      FileStatus fileStatus \u003d getFileStatus(f);\n+      fileStatus \u003d getFileStatus(f);\n \n       if (fileStatus.isDirectory()) {\n         return true;\n       } else {\n         throw new FileAlreadyExistsException(\"Path is a file: \" + f);\n       }\n     } catch (FileNotFoundException e) {\n-      Path fPart \u003d f;\n+      Path fPart \u003d f.getParent();\n       do {\n         try {\n-          FileStatus fileStatus \u003d getFileStatus(fPart);\n+          fileStatus \u003d getFileStatus(fPart);\n           if (fileStatus.isDirectory()) {\n             break;\n           }\n           if (fileStatus.isFile()) {\n             throw new FileAlreadyExistsException(String.format(\n                 \"Can\u0027t make directory for path \u0027%s\u0027 since it is a file.\",\n                 fPart));\n           }\n         } catch (FileNotFoundException fnfe) {\n           instrumentation.errorIgnored();\n         }\n         fPart \u003d fPart.getParent();\n       } while (fPart !\u003d null);\n \n       String key \u003d pathToKey(f);\n       createFakeDirectory(key);\n       return true;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean innerMkdirs(Path f, FsPermission permission)\n      throws IOException, FileAlreadyExistsException, AmazonClientException {\n    LOG.debug(\"Making directory: {}\", f);\n    incrementStatistic(INVOCATION_MKDIRS);\n    FileStatus fileStatus;\n    try {\n      fileStatus \u003d getFileStatus(f);\n\n      if (fileStatus.isDirectory()) {\n        return true;\n      } else {\n        throw new FileAlreadyExistsException(\"Path is a file: \" + f);\n      }\n    } catch (FileNotFoundException e) {\n      Path fPart \u003d f.getParent();\n      do {\n        try {\n          fileStatus \u003d getFileStatus(fPart);\n          if (fileStatus.isDirectory()) {\n            break;\n          }\n          if (fileStatus.isFile()) {\n            throw new FileAlreadyExistsException(String.format(\n                \"Can\u0027t make directory for path \u0027%s\u0027 since it is a file.\",\n                fPart));\n          }\n        } catch (FileNotFoundException fnfe) {\n          instrumentation.errorIgnored();\n        }\n        fPart \u003d fPart.getParent();\n      } while (fPart !\u003d null);\n\n      String key \u003d pathToKey(f);\n      createFakeDirectory(key);\n      return true;\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "c58a59f7081d55dd2108545ebf9ee48cf43ca944": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13171. Add StorageStatistics to S3A; instrument some more operations. Contributed by Steve Loughran.\n",
      "commitDate": "03/06/16 8:55 AM",
      "commitName": "c58a59f7081d55dd2108545ebf9ee48cf43ca944",
      "commitAuthor": "Chris Nauroth",
      "commitDateOld": "01/06/16 2:49 PM",
      "commitNameOld": "16b1cc7af9bd63b65ef50e1056f275a7baf111a2",
      "commitAuthorOld": "Chris Nauroth",
      "daysBetweenCommits": 1.75,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,36 +1,36 @@\n   private boolean innerMkdirs(Path f, FsPermission permission)\n       throws IOException, FileAlreadyExistsException, AmazonClientException {\n     LOG.debug(\"Making directory: {}\", f);\n-\n+    incrementStatistic(INVOCATION_MKDIRS);\n     try {\n       FileStatus fileStatus \u003d getFileStatus(f);\n \n       if (fileStatus.isDirectory()) {\n         return true;\n       } else {\n         throw new FileAlreadyExistsException(\"Path is a file: \" + f);\n       }\n     } catch (FileNotFoundException e) {\n       Path fPart \u003d f;\n       do {\n         try {\n           FileStatus fileStatus \u003d getFileStatus(fPart);\n           if (fileStatus.isDirectory()) {\n             break;\n           }\n           if (fileStatus.isFile()) {\n             throw new FileAlreadyExistsException(String.format(\n                 \"Can\u0027t make directory for path \u0027%s\u0027 since it is a file.\",\n                 fPart));\n           }\n         } catch (FileNotFoundException fnfe) {\n           instrumentation.errorIgnored();\n         }\n         fPart \u003d fPart.getParent();\n       } while (fPart !\u003d null);\n \n       String key \u003d pathToKey(f);\n-      createFakeDirectory(bucket, key);\n+      createFakeDirectory(key);\n       return true;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean innerMkdirs(Path f, FsPermission permission)\n      throws IOException, FileAlreadyExistsException, AmazonClientException {\n    LOG.debug(\"Making directory: {}\", f);\n    incrementStatistic(INVOCATION_MKDIRS);\n    try {\n      FileStatus fileStatus \u003d getFileStatus(f);\n\n      if (fileStatus.isDirectory()) {\n        return true;\n      } else {\n        throw new FileAlreadyExistsException(\"Path is a file: \" + f);\n      }\n    } catch (FileNotFoundException e) {\n      Path fPart \u003d f;\n      do {\n        try {\n          FileStatus fileStatus \u003d getFileStatus(fPart);\n          if (fileStatus.isDirectory()) {\n            break;\n          }\n          if (fileStatus.isFile()) {\n            throw new FileAlreadyExistsException(String.format(\n                \"Can\u0027t make directory for path \u0027%s\u0027 since it is a file.\",\n                fPart));\n          }\n        } catch (FileNotFoundException fnfe) {\n          instrumentation.errorIgnored();\n        }\n        fPart \u003d fPart.getParent();\n      } while (fPart !\u003d null);\n\n      String key \u003d pathToKey(f);\n      createFakeDirectory(key);\n      return true;\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "587061103097160d8aceb60dbef6958cafdd30ae": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13162. Consider reducing number of getFileStatus calls in S3AFileSystem.mkdirs. (Rajesh Balamohan via stevel)\n",
      "commitDate": "01/06/16 6:18 AM",
      "commitName": "587061103097160d8aceb60dbef6958cafdd30ae",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "21/05/16 8:39 AM",
      "commitNameOld": "39ec1515a205952eda7e171408a8b83eceb4abde",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 10.9,
      "commitsBetweenForRepo": 64,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,33 +1,36 @@\n   private boolean innerMkdirs(Path f, FsPermission permission)\n       throws IOException, FileAlreadyExistsException, AmazonClientException {\n     LOG.debug(\"Making directory: {}\", f);\n \n     try {\n       FileStatus fileStatus \u003d getFileStatus(f);\n \n       if (fileStatus.isDirectory()) {\n         return true;\n       } else {\n         throw new FileAlreadyExistsException(\"Path is a file: \" + f);\n       }\n     } catch (FileNotFoundException e) {\n       Path fPart \u003d f;\n       do {\n         try {\n           FileStatus fileStatus \u003d getFileStatus(fPart);\n+          if (fileStatus.isDirectory()) {\n+            break;\n+          }\n           if (fileStatus.isFile()) {\n             throw new FileAlreadyExistsException(String.format(\n                 \"Can\u0027t make directory for path \u0027%s\u0027 since it is a file.\",\n                 fPart));\n           }\n         } catch (FileNotFoundException fnfe) {\n           instrumentation.errorIgnored();\n         }\n         fPart \u003d fPart.getParent();\n       } while (fPart !\u003d null);\n \n       String key \u003d pathToKey(f);\n       createFakeDirectory(bucket, key);\n       return true;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean innerMkdirs(Path f, FsPermission permission)\n      throws IOException, FileAlreadyExistsException, AmazonClientException {\n    LOG.debug(\"Making directory: {}\", f);\n\n    try {\n      FileStatus fileStatus \u003d getFileStatus(f);\n\n      if (fileStatus.isDirectory()) {\n        return true;\n      } else {\n        throw new FileAlreadyExistsException(\"Path is a file: \" + f);\n      }\n    } catch (FileNotFoundException e) {\n      Path fPart \u003d f;\n      do {\n        try {\n          FileStatus fileStatus \u003d getFileStatus(fPart);\n          if (fileStatus.isDirectory()) {\n            break;\n          }\n          if (fileStatus.isFile()) {\n            throw new FileAlreadyExistsException(String.format(\n                \"Can\u0027t make directory for path \u0027%s\u0027 since it is a file.\",\n                fPart));\n          }\n        } catch (FileNotFoundException fnfe) {\n          instrumentation.errorIgnored();\n        }\n        fPart \u003d fPart.getParent();\n      } while (fPart !\u003d null);\n\n      String key \u003d pathToKey(f);\n      createFakeDirectory(bucket, key);\n      return true;\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "39ec1515a205952eda7e171408a8b83eceb4abde": {
      "type": "Ymultichange(Yrename,Ymodifierchange,Yexceptionschange)",
      "commitMessage": "HADOOP-13130. s3a failures can surface as RTEs, not IOEs. (Steve Loughran)\n",
      "commitDate": "21/05/16 8:39 AM",
      "commitName": "39ec1515a205952eda7e171408a8b83eceb4abde",
      "commitAuthor": "Steve Loughran",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "HADOOP-13130. s3a failures can surface as RTEs, not IOEs. (Steve Loughran)\n",
          "commitDate": "21/05/16 8:39 AM",
          "commitName": "39ec1515a205952eda7e171408a8b83eceb4abde",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "20/05/16 5:52 AM",
          "commitNameOld": "757050ff355d40bc28f9dbfd0c0083c5f337d270",
          "commitAuthorOld": "Steve Loughran",
          "daysBetweenCommits": 1.12,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,32 +1,33 @@\n-  public boolean mkdirs(Path f, FsPermission permission) throws IOException {\n+  private boolean innerMkdirs(Path f, FsPermission permission)\n+      throws IOException, FileAlreadyExistsException, AmazonClientException {\n     LOG.debug(\"Making directory: {}\", f);\n \n     try {\n       FileStatus fileStatus \u003d getFileStatus(f);\n \n       if (fileStatus.isDirectory()) {\n         return true;\n       } else {\n         throw new FileAlreadyExistsException(\"Path is a file: \" + f);\n       }\n     } catch (FileNotFoundException e) {\n       Path fPart \u003d f;\n       do {\n         try {\n           FileStatus fileStatus \u003d getFileStatus(fPart);\n           if (fileStatus.isFile()) {\n             throw new FileAlreadyExistsException(String.format(\n                 \"Can\u0027t make directory for path \u0027%s\u0027 since it is a file.\",\n                 fPart));\n           }\n         } catch (FileNotFoundException fnfe) {\n           instrumentation.errorIgnored();\n         }\n         fPart \u003d fPart.getParent();\n       } while (fPart !\u003d null);\n \n       String key \u003d pathToKey(f);\n       createFakeDirectory(bucket, key);\n       return true;\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private boolean innerMkdirs(Path f, FsPermission permission)\n      throws IOException, FileAlreadyExistsException, AmazonClientException {\n    LOG.debug(\"Making directory: {}\", f);\n\n    try {\n      FileStatus fileStatus \u003d getFileStatus(f);\n\n      if (fileStatus.isDirectory()) {\n        return true;\n      } else {\n        throw new FileAlreadyExistsException(\"Path is a file: \" + f);\n      }\n    } catch (FileNotFoundException e) {\n      Path fPart \u003d f;\n      do {\n        try {\n          FileStatus fileStatus \u003d getFileStatus(fPart);\n          if (fileStatus.isFile()) {\n            throw new FileAlreadyExistsException(String.format(\n                \"Can\u0027t make directory for path \u0027%s\u0027 since it is a file.\",\n                fPart));\n          }\n        } catch (FileNotFoundException fnfe) {\n          instrumentation.errorIgnored();\n        }\n        fPart \u003d fPart.getParent();\n      } while (fPart !\u003d null);\n\n      String key \u003d pathToKey(f);\n      createFakeDirectory(bucket, key);\n      return true;\n    }\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
          "extendedDetails": {
            "oldValue": "mkdirs",
            "newValue": "innerMkdirs"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "HADOOP-13130. s3a failures can surface as RTEs, not IOEs. (Steve Loughran)\n",
          "commitDate": "21/05/16 8:39 AM",
          "commitName": "39ec1515a205952eda7e171408a8b83eceb4abde",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "20/05/16 5:52 AM",
          "commitNameOld": "757050ff355d40bc28f9dbfd0c0083c5f337d270",
          "commitAuthorOld": "Steve Loughran",
          "daysBetweenCommits": 1.12,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,32 +1,33 @@\n-  public boolean mkdirs(Path f, FsPermission permission) throws IOException {\n+  private boolean innerMkdirs(Path f, FsPermission permission)\n+      throws IOException, FileAlreadyExistsException, AmazonClientException {\n     LOG.debug(\"Making directory: {}\", f);\n \n     try {\n       FileStatus fileStatus \u003d getFileStatus(f);\n \n       if (fileStatus.isDirectory()) {\n         return true;\n       } else {\n         throw new FileAlreadyExistsException(\"Path is a file: \" + f);\n       }\n     } catch (FileNotFoundException e) {\n       Path fPart \u003d f;\n       do {\n         try {\n           FileStatus fileStatus \u003d getFileStatus(fPart);\n           if (fileStatus.isFile()) {\n             throw new FileAlreadyExistsException(String.format(\n                 \"Can\u0027t make directory for path \u0027%s\u0027 since it is a file.\",\n                 fPart));\n           }\n         } catch (FileNotFoundException fnfe) {\n           instrumentation.errorIgnored();\n         }\n         fPart \u003d fPart.getParent();\n       } while (fPart !\u003d null);\n \n       String key \u003d pathToKey(f);\n       createFakeDirectory(bucket, key);\n       return true;\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private boolean innerMkdirs(Path f, FsPermission permission)\n      throws IOException, FileAlreadyExistsException, AmazonClientException {\n    LOG.debug(\"Making directory: {}\", f);\n\n    try {\n      FileStatus fileStatus \u003d getFileStatus(f);\n\n      if (fileStatus.isDirectory()) {\n        return true;\n      } else {\n        throw new FileAlreadyExistsException(\"Path is a file: \" + f);\n      }\n    } catch (FileNotFoundException e) {\n      Path fPart \u003d f;\n      do {\n        try {\n          FileStatus fileStatus \u003d getFileStatus(fPart);\n          if (fileStatus.isFile()) {\n            throw new FileAlreadyExistsException(String.format(\n                \"Can\u0027t make directory for path \u0027%s\u0027 since it is a file.\",\n                fPart));\n          }\n        } catch (FileNotFoundException fnfe) {\n          instrumentation.errorIgnored();\n        }\n        fPart \u003d fPart.getParent();\n      } while (fPart !\u003d null);\n\n      String key \u003d pathToKey(f);\n      createFakeDirectory(bucket, key);\n      return true;\n    }\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
          "extendedDetails": {
            "oldValue": "[public]",
            "newValue": "[private]"
          }
        },
        {
          "type": "Yexceptionschange",
          "commitMessage": "HADOOP-13130. s3a failures can surface as RTEs, not IOEs. (Steve Loughran)\n",
          "commitDate": "21/05/16 8:39 AM",
          "commitName": "39ec1515a205952eda7e171408a8b83eceb4abde",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "20/05/16 5:52 AM",
          "commitNameOld": "757050ff355d40bc28f9dbfd0c0083c5f337d270",
          "commitAuthorOld": "Steve Loughran",
          "daysBetweenCommits": 1.12,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,32 +1,33 @@\n-  public boolean mkdirs(Path f, FsPermission permission) throws IOException {\n+  private boolean innerMkdirs(Path f, FsPermission permission)\n+      throws IOException, FileAlreadyExistsException, AmazonClientException {\n     LOG.debug(\"Making directory: {}\", f);\n \n     try {\n       FileStatus fileStatus \u003d getFileStatus(f);\n \n       if (fileStatus.isDirectory()) {\n         return true;\n       } else {\n         throw new FileAlreadyExistsException(\"Path is a file: \" + f);\n       }\n     } catch (FileNotFoundException e) {\n       Path fPart \u003d f;\n       do {\n         try {\n           FileStatus fileStatus \u003d getFileStatus(fPart);\n           if (fileStatus.isFile()) {\n             throw new FileAlreadyExistsException(String.format(\n                 \"Can\u0027t make directory for path \u0027%s\u0027 since it is a file.\",\n                 fPart));\n           }\n         } catch (FileNotFoundException fnfe) {\n           instrumentation.errorIgnored();\n         }\n         fPart \u003d fPart.getParent();\n       } while (fPart !\u003d null);\n \n       String key \u003d pathToKey(f);\n       createFakeDirectory(bucket, key);\n       return true;\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private boolean innerMkdirs(Path f, FsPermission permission)\n      throws IOException, FileAlreadyExistsException, AmazonClientException {\n    LOG.debug(\"Making directory: {}\", f);\n\n    try {\n      FileStatus fileStatus \u003d getFileStatus(f);\n\n      if (fileStatus.isDirectory()) {\n        return true;\n      } else {\n        throw new FileAlreadyExistsException(\"Path is a file: \" + f);\n      }\n    } catch (FileNotFoundException e) {\n      Path fPart \u003d f;\n      do {\n        try {\n          FileStatus fileStatus \u003d getFileStatus(fPart);\n          if (fileStatus.isFile()) {\n            throw new FileAlreadyExistsException(String.format(\n                \"Can\u0027t make directory for path \u0027%s\u0027 since it is a file.\",\n                fPart));\n          }\n        } catch (FileNotFoundException fnfe) {\n          instrumentation.errorIgnored();\n        }\n        fPart \u003d fPart.getParent();\n      } while (fPart !\u003d null);\n\n      String key \u003d pathToKey(f);\n      createFakeDirectory(bucket, key);\n      return true;\n    }\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
          "extendedDetails": {
            "oldValue": "[IOException]",
            "newValue": "[IOException, FileAlreadyExistsException, AmazonClientException]"
          }
        }
      ]
    },
    "27c4e90efce04e1b1302f668b5eb22412e00d033": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13028 add low level counter metrics for S3A; use in read performance tests. contributed by: stevel\npatch includes\nHADOOP-12844 Recover when S3A fails on IOException in read()\nHADOOP-13058 S3A FS fails during init against a read-only FS if multipart purge\nHADOOP-13047 S3a Forward seek in stream length to be configurable\n",
      "commitDate": "12/05/16 11:24 AM",
      "commitName": "27c4e90efce04e1b1302f668b5eb22412e00d033",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "12/05/16 5:57 AM",
      "commitNameOld": "def2a6d3856452d5c804f04e5bf485541a3bc53a",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 0.23,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,32 @@\n   public boolean mkdirs(Path f, FsPermission permission) throws IOException {\n-    if (LOG.isDebugEnabled()) {\n-      LOG.debug(\"Making directory: \" + f);\n-    }\n-\n+    LOG.debug(\"Making directory: {}\", f);\n \n     try {\n       FileStatus fileStatus \u003d getFileStatus(f);\n \n       if (fileStatus.isDirectory()) {\n         return true;\n       } else {\n         throw new FileAlreadyExistsException(\"Path is a file: \" + f);\n       }\n     } catch (FileNotFoundException e) {\n       Path fPart \u003d f;\n       do {\n         try {\n           FileStatus fileStatus \u003d getFileStatus(fPart);\n           if (fileStatus.isFile()) {\n             throw new FileAlreadyExistsException(String.format(\n                 \"Can\u0027t make directory for path \u0027%s\u0027 since it is a file.\",\n                 fPart));\n           }\n         } catch (FileNotFoundException fnfe) {\n+          instrumentation.errorIgnored();\n         }\n         fPart \u003d fPart.getParent();\n       } while (fPart !\u003d null);\n \n       String key \u003d pathToKey(f);\n       createFakeDirectory(bucket, key);\n       return true;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean mkdirs(Path f, FsPermission permission) throws IOException {\n    LOG.debug(\"Making directory: {}\", f);\n\n    try {\n      FileStatus fileStatus \u003d getFileStatus(f);\n\n      if (fileStatus.isDirectory()) {\n        return true;\n      } else {\n        throw new FileAlreadyExistsException(\"Path is a file: \" + f);\n      }\n    } catch (FileNotFoundException e) {\n      Path fPart \u003d f;\n      do {\n        try {\n          FileStatus fileStatus \u003d getFileStatus(fPart);\n          if (fileStatus.isFile()) {\n            throw new FileAlreadyExistsException(String.format(\n                \"Can\u0027t make directory for path \u0027%s\u0027 since it is a file.\",\n                fPart));\n          }\n        } catch (FileNotFoundException fnfe) {\n          instrumentation.errorIgnored();\n        }\n        fPart \u003d fPart.getParent();\n      } while (fPart !\u003d null);\n\n      String key \u003d pathToKey(f);\n      createFakeDirectory(bucket, key);\n      return true;\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "6ba52d88ec11444cbac946ffadbc645acd0657de": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10714. AmazonS3Client.deleteObjects() need to be limited to 1000 entries per call. Contributed by Juan Yu.\n",
      "commitDate": "05/11/14 5:17 PM",
      "commitName": "6ba52d88ec11444cbac946ffadbc645acd0657de",
      "commitAuthor": "Aaron T. Myers",
      "commitDateOld": "15/09/14 4:49 PM",
      "commitNameOld": "0ac760a58d96b36ab30e9d60679bbea6365ef120",
      "commitAuthorOld": "Colin Patrick Mccabe",
      "daysBetweenCommits": 51.06,
      "commitsBetweenForRepo": 536,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,31 +1,34 @@\n   public boolean mkdirs(Path f, FsPermission permission) throws IOException {\n-    LOG.info(\"Making directory: \" + f);\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(\"Making directory: \" + f);\n+    }\n+\n \n     try {\n       FileStatus fileStatus \u003d getFileStatus(f);\n \n       if (fileStatus.isDirectory()) {\n         return true;\n       } else {\n         throw new FileAlreadyExistsException(\"Path is a file: \" + f);\n       }\n     } catch (FileNotFoundException e) {\n       Path fPart \u003d f;\n       do {\n         try {\n           FileStatus fileStatus \u003d getFileStatus(fPart);\n           if (fileStatus.isFile()) {\n             throw new FileAlreadyExistsException(String.format(\n                 \"Can\u0027t make directory for path \u0027%s\u0027 since it is a file.\", \n                 fPart));\n           }\n         } catch (FileNotFoundException fnfe) {\n         }\n         fPart \u003d fPart.getParent();\n       } while (fPart !\u003d null);\n \n       String key \u003d pathToKey(f);\n       createFakeDirectory(bucket, key);\n       return true;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean mkdirs(Path f, FsPermission permission) throws IOException {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Making directory: \" + f);\n    }\n\n\n    try {\n      FileStatus fileStatus \u003d getFileStatus(f);\n\n      if (fileStatus.isDirectory()) {\n        return true;\n      } else {\n        throw new FileAlreadyExistsException(\"Path is a file: \" + f);\n      }\n    } catch (FileNotFoundException e) {\n      Path fPart \u003d f;\n      do {\n        try {\n          FileStatus fileStatus \u003d getFileStatus(fPart);\n          if (fileStatus.isFile()) {\n            throw new FileAlreadyExistsException(String.format(\n                \"Can\u0027t make directory for path \u0027%s\u0027 since it is a file.\", \n                fPart));\n          }\n        } catch (FileNotFoundException fnfe) {\n        }\n        fPart \u003d fPart.getParent();\n      } while (fPart !\u003d null);\n\n      String key \u003d pathToKey(f);\n      createFakeDirectory(bucket, key);\n      return true;\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "24d920b80eb3626073925a1d0b6dcf148add8cc0": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-10400. Incorporate new S3A FileSystem implementation. Contributed by Jordan Mendelson and Dave Wang.\n",
      "commitDate": "15/09/14 8:27 AM",
      "commitName": "24d920b80eb3626073925a1d0b6dcf148add8cc0",
      "commitAuthor": "Aaron T. Myers",
      "diff": "@@ -0,0 +1,31 @@\n+  public boolean mkdirs(Path f, FsPermission permission) throws IOException {\n+    LOG.info(\"Making directory: \" + f);\n+\n+    try {\n+      FileStatus fileStatus \u003d getFileStatus(f);\n+\n+      if (fileStatus.isDirectory()) {\n+        return true;\n+      } else {\n+        throw new FileAlreadyExistsException(\"Path is a file: \" + f);\n+      }\n+    } catch (FileNotFoundException e) {\n+      Path fPart \u003d f;\n+      do {\n+        try {\n+          FileStatus fileStatus \u003d getFileStatus(fPart);\n+          if (fileStatus.isFile()) {\n+            throw new FileAlreadyExistsException(String.format(\n+                \"Can\u0027t make directory for path \u0027%s\u0027 since it is a file.\", \n+                fPart));\n+          }\n+        } catch (FileNotFoundException fnfe) {\n+        }\n+        fPart \u003d fPart.getParent();\n+      } while (fPart !\u003d null);\n+\n+      String key \u003d pathToKey(f);\n+      createFakeDirectory(bucket, key);\n+      return true;\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean mkdirs(Path f, FsPermission permission) throws IOException {\n    LOG.info(\"Making directory: \" + f);\n\n    try {\n      FileStatus fileStatus \u003d getFileStatus(f);\n\n      if (fileStatus.isDirectory()) {\n        return true;\n      } else {\n        throw new FileAlreadyExistsException(\"Path is a file: \" + f);\n      }\n    } catch (FileNotFoundException e) {\n      Path fPart \u003d f;\n      do {\n        try {\n          FileStatus fileStatus \u003d getFileStatus(fPart);\n          if (fileStatus.isFile()) {\n            throw new FileAlreadyExistsException(String.format(\n                \"Can\u0027t make directory for path \u0027%s\u0027 since it is a file.\", \n                fPart));\n          }\n        } catch (FileNotFoundException fnfe) {\n        }\n        fPart \u003d fPart.getParent();\n      } while (fPart !\u003d null);\n\n      String key \u003d pathToKey(f);\n      createFakeDirectory(bucket, key);\n      return true;\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java"
    }
  }
}