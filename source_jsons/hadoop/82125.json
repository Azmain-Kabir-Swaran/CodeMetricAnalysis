{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ConfTest.java",
  "functionName": "parseConf",
  "functionId": "parseConf___in-InputStream",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/util/ConfTest.java",
  "functionStartLine": 81,
  "functionEndLine": 135,
  "numCommitsSeen": 4,
  "timeTaken": 975,
  "changeHistory": [
    "fe649bb3051f5647073c840d7334a90265ea3f06",
    "5df1fadf874f3f0176f6b36b8ff7317edd63770f"
  ],
  "changeHistoryShort": {
    "fe649bb3051f5647073c840d7334a90265ea3f06": "Ybodychange",
    "5df1fadf874f3f0176f6b36b8ff7317edd63770f": "Yintroduced"
  },
  "changeHistoryDetails": {
    "fe649bb3051f5647073c840d7334a90265ea3f06": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-12071. conftest is not documented.\nContributed by Kengo Seki.\n",
      "commitDate": "02/05/18 5:33 AM",
      "commitName": "fe649bb3051f5647073c840d7334a90265ea3f06",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "13/03/17 12:15 AM",
      "commitNameOld": "04a5f5a6dc88769cca8b1a15057a0756712b5013",
      "commitAuthorOld": "Andrey Dyatlov",
      "daysBetweenCommits": 415.22,
      "commitsBetweenForRepo": 3393,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,55 +1,55 @@\n   private static List\u003cNodeInfo\u003e parseConf(InputStream in)\n       throws XMLStreamException {\n     QName configuration \u003d new QName(\"configuration\");\n     QName property \u003d new QName(\"property\");\n \n     List\u003cNodeInfo\u003e nodes \u003d new ArrayList\u003cNodeInfo\u003e();\n-    Stack\u003cNodeInfo\u003e parsed \u003d new Stack\u003cNodeInfo\u003e();\n+    Stack\u003cNodeInfo\u003e parsed \u003d new Stack\u003c\u003e();\n \n     XMLInputFactory factory \u003d XMLInputFactory.newInstance();\n     XMLEventReader reader \u003d factory.createXMLEventReader(in);\n \n     while (reader.hasNext()) {\n       XMLEvent event \u003d reader.nextEvent();\n       if (event.isStartElement()) {\n         StartElement currentElement \u003d event.asStartElement();\n         NodeInfo currentNode \u003d new NodeInfo(currentElement);\n         if (parsed.isEmpty()) {\n           if (!currentElement.getName().equals(configuration)) {\n             return null;\n           }\n         } else {\n           NodeInfo parentNode \u003d parsed.peek();\n           QName parentName \u003d parentNode.getStartElement().getName();\n           if (parentName.equals(configuration)\n               \u0026\u0026 currentNode.getStartElement().getName().equals(property)) {\n             @SuppressWarnings(\"unchecked\")\n             Iterator\u003cAttribute\u003e it \u003d currentElement.getAttributes();\n             while (it.hasNext()) {\n               currentNode.addAttribute(it.next());\n             }\n           } else if (parentName.equals(property)) {\n             parentNode.addElement(currentElement);\n           }\n         }\n         parsed.push(currentNode);\n       } else if (event.isEndElement()) {\n         NodeInfo node \u003d parsed.pop();\n         if (parsed.size() \u003d\u003d 1) {\n           nodes.add(node);\n         }\n       } else if (event.isCharacters()) {\n         if (2 \u003c parsed.size()) {\n           NodeInfo parentNode \u003d parsed.pop();\n           StartElement parentElement \u003d parentNode.getStartElement();\n           NodeInfo grandparentNode \u003d parsed.peek();\n           if (grandparentNode.getElement(parentElement) \u003d\u003d null) {\n             grandparentNode.setElement(parentElement, event.asCharacters());\n           }\n           parsed.push(parentNode);\n         }\n       }\n     }\n \n     return nodes;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static List\u003cNodeInfo\u003e parseConf(InputStream in)\n      throws XMLStreamException {\n    QName configuration \u003d new QName(\"configuration\");\n    QName property \u003d new QName(\"property\");\n\n    List\u003cNodeInfo\u003e nodes \u003d new ArrayList\u003cNodeInfo\u003e();\n    Stack\u003cNodeInfo\u003e parsed \u003d new Stack\u003c\u003e();\n\n    XMLInputFactory factory \u003d XMLInputFactory.newInstance();\n    XMLEventReader reader \u003d factory.createXMLEventReader(in);\n\n    while (reader.hasNext()) {\n      XMLEvent event \u003d reader.nextEvent();\n      if (event.isStartElement()) {\n        StartElement currentElement \u003d event.asStartElement();\n        NodeInfo currentNode \u003d new NodeInfo(currentElement);\n        if (parsed.isEmpty()) {\n          if (!currentElement.getName().equals(configuration)) {\n            return null;\n          }\n        } else {\n          NodeInfo parentNode \u003d parsed.peek();\n          QName parentName \u003d parentNode.getStartElement().getName();\n          if (parentName.equals(configuration)\n              \u0026\u0026 currentNode.getStartElement().getName().equals(property)) {\n            @SuppressWarnings(\"unchecked\")\n            Iterator\u003cAttribute\u003e it \u003d currentElement.getAttributes();\n            while (it.hasNext()) {\n              currentNode.addAttribute(it.next());\n            }\n          } else if (parentName.equals(property)) {\n            parentNode.addElement(currentElement);\n          }\n        }\n        parsed.push(currentNode);\n      } else if (event.isEndElement()) {\n        NodeInfo node \u003d parsed.pop();\n        if (parsed.size() \u003d\u003d 1) {\n          nodes.add(node);\n        }\n      } else if (event.isCharacters()) {\n        if (2 \u003c parsed.size()) {\n          NodeInfo parentNode \u003d parsed.pop();\n          StartElement parentElement \u003d parentNode.getStartElement();\n          NodeInfo grandparentNode \u003d parsed.peek();\n          if (grandparentNode.getElement(parentElement) \u003d\u003d null) {\n            grandparentNode.setElement(parentElement, event.asCharacters());\n          }\n          parsed.push(parentNode);\n        }\n      }\n    }\n\n    return nodes;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/util/ConfTest.java",
      "extendedDetails": {}
    },
    "5df1fadf874f3f0176f6b36b8ff7317edd63770f": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-7947. Validate XMLs if a relevant tool is available, when using scripts (Kengo Seki via aw)\n",
      "commitDate": "28/05/15 11:01 AM",
      "commitName": "5df1fadf874f3f0176f6b36b8ff7317edd63770f",
      "commitAuthor": "Allen Wittenauer",
      "diff": "@@ -0,0 +1,55 @@\n+  private static List\u003cNodeInfo\u003e parseConf(InputStream in)\n+      throws XMLStreamException {\n+    QName configuration \u003d new QName(\"configuration\");\n+    QName property \u003d new QName(\"property\");\n+\n+    List\u003cNodeInfo\u003e nodes \u003d new ArrayList\u003cNodeInfo\u003e();\n+    Stack\u003cNodeInfo\u003e parsed \u003d new Stack\u003cNodeInfo\u003e();\n+\n+    XMLInputFactory factory \u003d XMLInputFactory.newInstance();\n+    XMLEventReader reader \u003d factory.createXMLEventReader(in);\n+\n+    while (reader.hasNext()) {\n+      XMLEvent event \u003d reader.nextEvent();\n+      if (event.isStartElement()) {\n+        StartElement currentElement \u003d event.asStartElement();\n+        NodeInfo currentNode \u003d new NodeInfo(currentElement);\n+        if (parsed.isEmpty()) {\n+          if (!currentElement.getName().equals(configuration)) {\n+            return null;\n+          }\n+        } else {\n+          NodeInfo parentNode \u003d parsed.peek();\n+          QName parentName \u003d parentNode.getStartElement().getName();\n+          if (parentName.equals(configuration)\n+              \u0026\u0026 currentNode.getStartElement().getName().equals(property)) {\n+            @SuppressWarnings(\"unchecked\")\n+            Iterator\u003cAttribute\u003e it \u003d currentElement.getAttributes();\n+            while (it.hasNext()) {\n+              currentNode.addAttribute(it.next());\n+            }\n+          } else if (parentName.equals(property)) {\n+            parentNode.addElement(currentElement);\n+          }\n+        }\n+        parsed.push(currentNode);\n+      } else if (event.isEndElement()) {\n+        NodeInfo node \u003d parsed.pop();\n+        if (parsed.size() \u003d\u003d 1) {\n+          nodes.add(node);\n+        }\n+      } else if (event.isCharacters()) {\n+        if (2 \u003c parsed.size()) {\n+          NodeInfo parentNode \u003d parsed.pop();\n+          StartElement parentElement \u003d parentNode.getStartElement();\n+          NodeInfo grandparentNode \u003d parsed.peek();\n+          if (grandparentNode.getElement(parentElement) \u003d\u003d null) {\n+            grandparentNode.setElement(parentElement, event.asCharacters());\n+          }\n+          parsed.push(parentNode);\n+        }\n+      }\n+    }\n+\n+    return nodes;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private static List\u003cNodeInfo\u003e parseConf(InputStream in)\n      throws XMLStreamException {\n    QName configuration \u003d new QName(\"configuration\");\n    QName property \u003d new QName(\"property\");\n\n    List\u003cNodeInfo\u003e nodes \u003d new ArrayList\u003cNodeInfo\u003e();\n    Stack\u003cNodeInfo\u003e parsed \u003d new Stack\u003cNodeInfo\u003e();\n\n    XMLInputFactory factory \u003d XMLInputFactory.newInstance();\n    XMLEventReader reader \u003d factory.createXMLEventReader(in);\n\n    while (reader.hasNext()) {\n      XMLEvent event \u003d reader.nextEvent();\n      if (event.isStartElement()) {\n        StartElement currentElement \u003d event.asStartElement();\n        NodeInfo currentNode \u003d new NodeInfo(currentElement);\n        if (parsed.isEmpty()) {\n          if (!currentElement.getName().equals(configuration)) {\n            return null;\n          }\n        } else {\n          NodeInfo parentNode \u003d parsed.peek();\n          QName parentName \u003d parentNode.getStartElement().getName();\n          if (parentName.equals(configuration)\n              \u0026\u0026 currentNode.getStartElement().getName().equals(property)) {\n            @SuppressWarnings(\"unchecked\")\n            Iterator\u003cAttribute\u003e it \u003d currentElement.getAttributes();\n            while (it.hasNext()) {\n              currentNode.addAttribute(it.next());\n            }\n          } else if (parentName.equals(property)) {\n            parentNode.addElement(currentElement);\n          }\n        }\n        parsed.push(currentNode);\n      } else if (event.isEndElement()) {\n        NodeInfo node \u003d parsed.pop();\n        if (parsed.size() \u003d\u003d 1) {\n          nodes.add(node);\n        }\n      } else if (event.isCharacters()) {\n        if (2 \u003c parsed.size()) {\n          NodeInfo parentNode \u003d parsed.pop();\n          StartElement parentElement \u003d parentNode.getStartElement();\n          NodeInfo grandparentNode \u003d parsed.peek();\n          if (grandparentNode.getElement(parentElement) \u003d\u003d null) {\n            grandparentNode.setElement(parentElement, event.asCharacters());\n          }\n          parsed.push(parentNode);\n        }\n      }\n    }\n\n    return nodes;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/util/ConfTest.java"
    }
  }
}