{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "AggregatedLogFormat.java",
  "functionName": "write",
  "functionId": "write___out-DataOutputStream__pendingUploadFiles-Set__File__",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/AggregatedLogFormat.java",
  "functionStartLine": 231,
  "functionEndLine": 290,
  "numCommitsSeen": 69,
  "timeTaken": 10801,
  "changeHistory": [
    "22de9449f8aa72c5b0bb586b8253390773502189",
    "c2cb7ea1ef6532020b69031dbd18b0f9b8369f0f",
    "a696fbb001b946ae75f3b8e962839c2fd3decfa1",
    "58e9f24e0f06efede21085b7ffe36af042fa7b38",
    "caecd9fffe7c6216be31f3ab65349182045451fa",
    "f81dc3f995579c1b94b11d60e9fc6da56c8a9496",
    "e31f0a6558b106662c83e1f797216e412b6689a9",
    "34cdcaad71cad76c0874a4e5266b4074009d2ffc",
    "2d89dcb121dd81a53484dbbff5f727e65b938112",
    "2826a35469acd262c76fa26e730a21843ac6e856",
    "5420f287ccc83df69b6725942754c82b89e46b3e",
    "e1fdf62123625e4ba399af02f8aad500637d29d1",
    "cda16311a90134a50c57585831218c7b43827693",
    "c27601fefebd0af887a12d684bfc6f90d9fc0321",
    "6165875dc6bf67d72fc3ce1d96dfc80ba312d4a1",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517"
  ],
  "changeHistoryShort": {
    "22de9449f8aa72c5b0bb586b8253390773502189": "Ybodychange",
    "c2cb7ea1ef6532020b69031dbd18b0f9b8369f0f": "Ybodychange",
    "a696fbb001b946ae75f3b8e962839c2fd3decfa1": "Ybodychange",
    "58e9f24e0f06efede21085b7ffe36af042fa7b38": "Ybodychange",
    "caecd9fffe7c6216be31f3ab65349182045451fa": "Ybodychange",
    "f81dc3f995579c1b94b11d60e9fc6da56c8a9496": "Ybodychange",
    "e31f0a6558b106662c83e1f797216e412b6689a9": "Ybodychange",
    "34cdcaad71cad76c0874a4e5266b4074009d2ffc": "Ymultichange(Yparameterchange,Ybodychange)",
    "2d89dcb121dd81a53484dbbff5f727e65b938112": "Ybodychange",
    "2826a35469acd262c76fa26e730a21843ac6e856": "Ybodychange",
    "5420f287ccc83df69b6725942754c82b89e46b3e": "Ybodychange",
    "e1fdf62123625e4ba399af02f8aad500637d29d1": "Yfilerename",
    "cda16311a90134a50c57585831218c7b43827693": "Ybodychange",
    "c27601fefebd0af887a12d684bfc6f90d9fc0321": "Yfilerename",
    "6165875dc6bf67d72fc3ce1d96dfc80ba312d4a1": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": "Yintroduced"
  },
  "changeHistoryDetails": {
    "22de9449f8aa72c5b0bb586b8253390773502189": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7144. Log Aggregation controller should not swallow the exceptions when it calls closeWriter and closeReader. Contributed by Xuan Gong.\n",
      "commitDate": "06/09/17 2:53 PM",
      "commitName": "22de9449f8aa72c5b0bb586b8253390773502189",
      "commitAuthor": "Junping Du",
      "commitDateOld": "06/09/17 1:19 PM",
      "commitNameOld": "63231a2a3008794c5ebcbc9d3855638fc5f28216",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 0.07,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,60 +1,60 @@\n     public void write(DataOutputStream out, Set\u003cFile\u003e pendingUploadFiles)\n         throws IOException {\n       List\u003cFile\u003e fileList \u003d new ArrayList\u003cFile\u003e(pendingUploadFiles);\n       Collections.sort(fileList);\n \n       for (File logFile : fileList) {\n         // We only aggregate top level files.\n         // Ignore anything inside sub-folders.\n         if (logFile.isDirectory()) {\n           LOG.warn(logFile.getAbsolutePath() + \" is a directory. Ignore it.\");\n           continue;\n         }\n \n         FileInputStream in \u003d null;\n         try {\n           in \u003d secureOpenFile(logFile);\n         } catch (IOException e) {\n           logErrorMessage(logFile, e);\n-          IOUtils.closeQuietly(in);\n+          IOUtils.cleanupWithLogger(LOG, in);\n           continue;\n         }\n \n         final long fileLength \u003d logFile.length();\n         // Write the logFile Type\n         out.writeUTF(logFile.getName());\n \n         // Write the log length as UTF so that it is printable\n         out.writeUTF(String.valueOf(fileLength));\n \n         // Write the log itself\n         try {\n           byte[] buf \u003d new byte[65535];\n           int len \u003d 0;\n           long bytesLeft \u003d fileLength;\n           while ((len \u003d in.read(buf)) !\u003d -1) {\n             //If buffer contents within fileLength, write\n             if (len \u003c bytesLeft) {\n               out.write(buf, 0, len);\n               bytesLeft-\u003dlen;\n             }\n             //else only write contents within fileLength, then exit early\n             else {\n               out.write(buf, 0, (int)bytesLeft);\n               break;\n             }\n           }\n           long newLength \u003d logFile.length();\n           if(fileLength \u003c newLength) {\n             LOG.warn(\"Aggregated logs truncated by approximately \"+\n                 (newLength-fileLength) +\" bytes.\");\n           }\n           this.uploadedFiles.add(logFile);\n         } catch (IOException e) {\n           String message \u003d logErrorMessage(logFile, e);\n           out.write(message.getBytes(Charset.forName(\"UTF-8\")));\n         } finally {\n-          IOUtils.closeQuietly(in);\n+          IOUtils.cleanupWithLogger(LOG, in);\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void write(DataOutputStream out, Set\u003cFile\u003e pendingUploadFiles)\n        throws IOException {\n      List\u003cFile\u003e fileList \u003d new ArrayList\u003cFile\u003e(pendingUploadFiles);\n      Collections.sort(fileList);\n\n      for (File logFile : fileList) {\n        // We only aggregate top level files.\n        // Ignore anything inside sub-folders.\n        if (logFile.isDirectory()) {\n          LOG.warn(logFile.getAbsolutePath() + \" is a directory. Ignore it.\");\n          continue;\n        }\n\n        FileInputStream in \u003d null;\n        try {\n          in \u003d secureOpenFile(logFile);\n        } catch (IOException e) {\n          logErrorMessage(logFile, e);\n          IOUtils.cleanupWithLogger(LOG, in);\n          continue;\n        }\n\n        final long fileLength \u003d logFile.length();\n        // Write the logFile Type\n        out.writeUTF(logFile.getName());\n\n        // Write the log length as UTF so that it is printable\n        out.writeUTF(String.valueOf(fileLength));\n\n        // Write the log itself\n        try {\n          byte[] buf \u003d new byte[65535];\n          int len \u003d 0;\n          long bytesLeft \u003d fileLength;\n          while ((len \u003d in.read(buf)) !\u003d -1) {\n            //If buffer contents within fileLength, write\n            if (len \u003c bytesLeft) {\n              out.write(buf, 0, len);\n              bytesLeft-\u003dlen;\n            }\n            //else only write contents within fileLength, then exit early\n            else {\n              out.write(buf, 0, (int)bytesLeft);\n              break;\n            }\n          }\n          long newLength \u003d logFile.length();\n          if(fileLength \u003c newLength) {\n            LOG.warn(\"Aggregated logs truncated by approximately \"+\n                (newLength-fileLength) +\" bytes.\");\n          }\n          this.uploadedFiles.add(logFile);\n        } catch (IOException e) {\n          String message \u003d logErrorMessage(logFile, e);\n          out.write(message.getBytes(Charset.forName(\"UTF-8\")));\n        } finally {\n          IOUtils.cleanupWithLogger(LOG, in);\n        }\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/AggregatedLogFormat.java",
      "extendedDetails": {}
    },
    "c2cb7ea1ef6532020b69031dbd18b0f9b8369f0f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6876. Create an abstract log writer for extendability. Contributed by Xuan Gong.\n",
      "commitDate": "24/08/17 1:36 PM",
      "commitName": "c2cb7ea1ef6532020b69031dbd18b0f9b8369f0f",
      "commitAuthor": "Junping Du",
      "commitDateOld": "18/06/17 7:23 AM",
      "commitNameOld": "7582dedad1c73eabdc3eeece0a3a860e7bb33c1a",
      "commitAuthorOld": "Naganarasimha",
      "daysBetweenCommits": 67.26,
      "commitsBetweenForRepo": 421,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,60 +1,60 @@\n     public void write(DataOutputStream out, Set\u003cFile\u003e pendingUploadFiles)\n         throws IOException {\n       List\u003cFile\u003e fileList \u003d new ArrayList\u003cFile\u003e(pendingUploadFiles);\n       Collections.sort(fileList);\n \n       for (File logFile : fileList) {\n         // We only aggregate top level files.\n         // Ignore anything inside sub-folders.\n         if (logFile.isDirectory()) {\n           LOG.warn(logFile.getAbsolutePath() + \" is a directory. Ignore it.\");\n           continue;\n         }\n \n         FileInputStream in \u003d null;\n         try {\n           in \u003d secureOpenFile(logFile);\n         } catch (IOException e) {\n           logErrorMessage(logFile, e);\n-          IOUtils.cleanup(LOG, in);\n+          IOUtils.closeQuietly(in);\n           continue;\n         }\n \n         final long fileLength \u003d logFile.length();\n         // Write the logFile Type\n         out.writeUTF(logFile.getName());\n \n         // Write the log length as UTF so that it is printable\n         out.writeUTF(String.valueOf(fileLength));\n \n         // Write the log itself\n         try {\n           byte[] buf \u003d new byte[65535];\n           int len \u003d 0;\n           long bytesLeft \u003d fileLength;\n           while ((len \u003d in.read(buf)) !\u003d -1) {\n             //If buffer contents within fileLength, write\n             if (len \u003c bytesLeft) {\n               out.write(buf, 0, len);\n               bytesLeft-\u003dlen;\n             }\n             //else only write contents within fileLength, then exit early\n             else {\n               out.write(buf, 0, (int)bytesLeft);\n               break;\n             }\n           }\n           long newLength \u003d logFile.length();\n           if(fileLength \u003c newLength) {\n             LOG.warn(\"Aggregated logs truncated by approximately \"+\n                 (newLength-fileLength) +\" bytes.\");\n           }\n           this.uploadedFiles.add(logFile);\n         } catch (IOException e) {\n           String message \u003d logErrorMessage(logFile, e);\n           out.write(message.getBytes(Charset.forName(\"UTF-8\")));\n         } finally {\n-          IOUtils.cleanup(LOG, in);\n+          IOUtils.closeQuietly(in);\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void write(DataOutputStream out, Set\u003cFile\u003e pendingUploadFiles)\n        throws IOException {\n      List\u003cFile\u003e fileList \u003d new ArrayList\u003cFile\u003e(pendingUploadFiles);\n      Collections.sort(fileList);\n\n      for (File logFile : fileList) {\n        // We only aggregate top level files.\n        // Ignore anything inside sub-folders.\n        if (logFile.isDirectory()) {\n          LOG.warn(logFile.getAbsolutePath() + \" is a directory. Ignore it.\");\n          continue;\n        }\n\n        FileInputStream in \u003d null;\n        try {\n          in \u003d secureOpenFile(logFile);\n        } catch (IOException e) {\n          logErrorMessage(logFile, e);\n          IOUtils.closeQuietly(in);\n          continue;\n        }\n\n        final long fileLength \u003d logFile.length();\n        // Write the logFile Type\n        out.writeUTF(logFile.getName());\n\n        // Write the log length as UTF so that it is printable\n        out.writeUTF(String.valueOf(fileLength));\n\n        // Write the log itself\n        try {\n          byte[] buf \u003d new byte[65535];\n          int len \u003d 0;\n          long bytesLeft \u003d fileLength;\n          while ((len \u003d in.read(buf)) !\u003d -1) {\n            //If buffer contents within fileLength, write\n            if (len \u003c bytesLeft) {\n              out.write(buf, 0, len);\n              bytesLeft-\u003dlen;\n            }\n            //else only write contents within fileLength, then exit early\n            else {\n              out.write(buf, 0, (int)bytesLeft);\n              break;\n            }\n          }\n          long newLength \u003d logFile.length();\n          if(fileLength \u003c newLength) {\n            LOG.warn(\"Aggregated logs truncated by approximately \"+\n                (newLength-fileLength) +\" bytes.\");\n          }\n          this.uploadedFiles.add(logFile);\n        } catch (IOException e) {\n          String message \u003d logErrorMessage(logFile, e);\n          out.write(message.getBytes(Charset.forName(\"UTF-8\")));\n        } finally {\n          IOUtils.closeQuietly(in);\n        }\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/AggregatedLogFormat.java",
      "extendedDetails": {}
    },
    "a696fbb001b946ae75f3b8e962839c2fd3decfa1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2939. Fix new findbugs warnings in hadoop-yarn-common. (Li Lu via junping_du)\n",
      "commitDate": "22/12/14 3:06 AM",
      "commitName": "a696fbb001b946ae75f3b8e962839c2fd3decfa1",
      "commitAuthor": "Junping Du",
      "commitDateOld": "01/12/14 2:29 PM",
      "commitNameOld": "0f9528b99addbb0fd9a19d84db22a8c8e934b05f",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 20.53,
      "commitsBetweenForRepo": 172,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,60 +1,60 @@\n     public void write(DataOutputStream out, Set\u003cFile\u003e pendingUploadFiles)\n         throws IOException {\n       List\u003cFile\u003e fileList \u003d new ArrayList\u003cFile\u003e(pendingUploadFiles);\n       Collections.sort(fileList);\n \n       for (File logFile : fileList) {\n         // We only aggregate top level files.\n         // Ignore anything inside sub-folders.\n         if (logFile.isDirectory()) {\n           LOG.warn(logFile.getAbsolutePath() + \" is a directory. Ignore it.\");\n           continue;\n         }\n \n         FileInputStream in \u003d null;\n         try {\n           in \u003d secureOpenFile(logFile);\n         } catch (IOException e) {\n           logErrorMessage(logFile, e);\n           IOUtils.cleanup(LOG, in);\n           continue;\n         }\n \n         final long fileLength \u003d logFile.length();\n         // Write the logFile Type\n         out.writeUTF(logFile.getName());\n \n         // Write the log length as UTF so that it is printable\n         out.writeUTF(String.valueOf(fileLength));\n \n         // Write the log itself\n         try {\n           byte[] buf \u003d new byte[65535];\n           int len \u003d 0;\n           long bytesLeft \u003d fileLength;\n           while ((len \u003d in.read(buf)) !\u003d -1) {\n             //If buffer contents within fileLength, write\n             if (len \u003c bytesLeft) {\n               out.write(buf, 0, len);\n               bytesLeft-\u003dlen;\n             }\n             //else only write contents within fileLength, then exit early\n             else {\n               out.write(buf, 0, (int)bytesLeft);\n               break;\n             }\n           }\n           long newLength \u003d logFile.length();\n           if(fileLength \u003c newLength) {\n             LOG.warn(\"Aggregated logs truncated by approximately \"+\n                 (newLength-fileLength) +\" bytes.\");\n           }\n           this.uploadedFiles.add(logFile);\n         } catch (IOException e) {\n           String message \u003d logErrorMessage(logFile, e);\n-          out.write(message.getBytes());\n+          out.write(message.getBytes(Charset.forName(\"UTF-8\")));\n         } finally {\n           IOUtils.cleanup(LOG, in);\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void write(DataOutputStream out, Set\u003cFile\u003e pendingUploadFiles)\n        throws IOException {\n      List\u003cFile\u003e fileList \u003d new ArrayList\u003cFile\u003e(pendingUploadFiles);\n      Collections.sort(fileList);\n\n      for (File logFile : fileList) {\n        // We only aggregate top level files.\n        // Ignore anything inside sub-folders.\n        if (logFile.isDirectory()) {\n          LOG.warn(logFile.getAbsolutePath() + \" is a directory. Ignore it.\");\n          continue;\n        }\n\n        FileInputStream in \u003d null;\n        try {\n          in \u003d secureOpenFile(logFile);\n        } catch (IOException e) {\n          logErrorMessage(logFile, e);\n          IOUtils.cleanup(LOG, in);\n          continue;\n        }\n\n        final long fileLength \u003d logFile.length();\n        // Write the logFile Type\n        out.writeUTF(logFile.getName());\n\n        // Write the log length as UTF so that it is printable\n        out.writeUTF(String.valueOf(fileLength));\n\n        // Write the log itself\n        try {\n          byte[] buf \u003d new byte[65535];\n          int len \u003d 0;\n          long bytesLeft \u003d fileLength;\n          while ((len \u003d in.read(buf)) !\u003d -1) {\n            //If buffer contents within fileLength, write\n            if (len \u003c bytesLeft) {\n              out.write(buf, 0, len);\n              bytesLeft-\u003dlen;\n            }\n            //else only write contents within fileLength, then exit early\n            else {\n              out.write(buf, 0, (int)bytesLeft);\n              break;\n            }\n          }\n          long newLength \u003d logFile.length();\n          if(fileLength \u003c newLength) {\n            LOG.warn(\"Aggregated logs truncated by approximately \"+\n                (newLength-fileLength) +\" bytes.\");\n          }\n          this.uploadedFiles.add(logFile);\n        } catch (IOException e) {\n          String message \u003d logErrorMessage(logFile, e);\n          out.write(message.getBytes(Charset.forName(\"UTF-8\")));\n        } finally {\n          IOUtils.cleanup(LOG, in);\n        }\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/AggregatedLogFormat.java",
      "extendedDetails": {}
    },
    "58e9f24e0f06efede21085b7ffe36af042fa7b38": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2788. Fixed backwards compatiblity issues with log-aggregation feature that were caused when adding log-upload-time via YARN-2703. Contributed by Xuan Gong.\n",
      "commitDate": "03/11/14 1:16 PM",
      "commitName": "58e9f24e0f06efede21085b7ffe36af042fa7b38",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "26/10/14 12:57 PM",
      "commitNameOld": "caecd9fffe7c6216be31f3ab65349182045451fa",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 8.05,
      "commitsBetweenForRepo": 84,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,63 +1,60 @@\n     public void write(DataOutputStream out, Set\u003cFile\u003e pendingUploadFiles)\n         throws IOException {\n       List\u003cFile\u003e fileList \u003d new ArrayList\u003cFile\u003e(pendingUploadFiles);\n       Collections.sort(fileList);\n \n       for (File logFile : fileList) {\n         // We only aggregate top level files.\n         // Ignore anything inside sub-folders.\n         if (logFile.isDirectory()) {\n           LOG.warn(logFile.getAbsolutePath() + \" is a directory. Ignore it.\");\n           continue;\n         }\n \n         FileInputStream in \u003d null;\n         try {\n           in \u003d secureOpenFile(logFile);\n         } catch (IOException e) {\n           logErrorMessage(logFile, e);\n           IOUtils.cleanup(LOG, in);\n           continue;\n         }\n \n         final long fileLength \u003d logFile.length();\n         // Write the logFile Type\n         out.writeUTF(logFile.getName());\n \n-        // Write the uploaded TimeStamp\n-        out.writeLong(System.currentTimeMillis());\n-\n         // Write the log length as UTF so that it is printable\n         out.writeUTF(String.valueOf(fileLength));\n \n         // Write the log itself\n         try {\n           byte[] buf \u003d new byte[65535];\n           int len \u003d 0;\n           long bytesLeft \u003d fileLength;\n           while ((len \u003d in.read(buf)) !\u003d -1) {\n             //If buffer contents within fileLength, write\n             if (len \u003c bytesLeft) {\n               out.write(buf, 0, len);\n               bytesLeft-\u003dlen;\n             }\n             //else only write contents within fileLength, then exit early\n             else {\n               out.write(buf, 0, (int)bytesLeft);\n               break;\n             }\n           }\n           long newLength \u003d logFile.length();\n           if(fileLength \u003c newLength) {\n             LOG.warn(\"Aggregated logs truncated by approximately \"+\n                 (newLength-fileLength) +\" bytes.\");\n           }\n           this.uploadedFiles.add(logFile);\n         } catch (IOException e) {\n           String message \u003d logErrorMessage(logFile, e);\n           out.write(message.getBytes());\n         } finally {\n           IOUtils.cleanup(LOG, in);\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void write(DataOutputStream out, Set\u003cFile\u003e pendingUploadFiles)\n        throws IOException {\n      List\u003cFile\u003e fileList \u003d new ArrayList\u003cFile\u003e(pendingUploadFiles);\n      Collections.sort(fileList);\n\n      for (File logFile : fileList) {\n        // We only aggregate top level files.\n        // Ignore anything inside sub-folders.\n        if (logFile.isDirectory()) {\n          LOG.warn(logFile.getAbsolutePath() + \" is a directory. Ignore it.\");\n          continue;\n        }\n\n        FileInputStream in \u003d null;\n        try {\n          in \u003d secureOpenFile(logFile);\n        } catch (IOException e) {\n          logErrorMessage(logFile, e);\n          IOUtils.cleanup(LOG, in);\n          continue;\n        }\n\n        final long fileLength \u003d logFile.length();\n        // Write the logFile Type\n        out.writeUTF(logFile.getName());\n\n        // Write the log length as UTF so that it is printable\n        out.writeUTF(String.valueOf(fileLength));\n\n        // Write the log itself\n        try {\n          byte[] buf \u003d new byte[65535];\n          int len \u003d 0;\n          long bytesLeft \u003d fileLength;\n          while ((len \u003d in.read(buf)) !\u003d -1) {\n            //If buffer contents within fileLength, write\n            if (len \u003c bytesLeft) {\n              out.write(buf, 0, len);\n              bytesLeft-\u003dlen;\n            }\n            //else only write contents within fileLength, then exit early\n            else {\n              out.write(buf, 0, (int)bytesLeft);\n              break;\n            }\n          }\n          long newLength \u003d logFile.length();\n          if(fileLength \u003c newLength) {\n            LOG.warn(\"Aggregated logs truncated by approximately \"+\n                (newLength-fileLength) +\" bytes.\");\n          }\n          this.uploadedFiles.add(logFile);\n        } catch (IOException e) {\n          String message \u003d logErrorMessage(logFile, e);\n          out.write(message.getBytes());\n        } finally {\n          IOUtils.cleanup(LOG, in);\n        }\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/AggregatedLogFormat.java",
      "extendedDetails": {}
    },
    "caecd9fffe7c6216be31f3ab65349182045451fa": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2734. Skipped sub-folders in the local log dir when aggregating logs. Contributed by Xuan Gong.\n",
      "commitDate": "26/10/14 12:57 PM",
      "commitName": "caecd9fffe7c6216be31f3ab65349182045451fa",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "24/10/14 2:10 PM",
      "commitNameOld": "f81dc3f995579c1b94b11d60e9fc6da56c8a9496",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 1.95,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,57 +1,63 @@\n     public void write(DataOutputStream out, Set\u003cFile\u003e pendingUploadFiles)\n         throws IOException {\n       List\u003cFile\u003e fileList \u003d new ArrayList\u003cFile\u003e(pendingUploadFiles);\n       Collections.sort(fileList);\n \n       for (File logFile : fileList) {\n+        // We only aggregate top level files.\n+        // Ignore anything inside sub-folders.\n+        if (logFile.isDirectory()) {\n+          LOG.warn(logFile.getAbsolutePath() + \" is a directory. Ignore it.\");\n+          continue;\n+        }\n \n         FileInputStream in \u003d null;\n         try {\n           in \u003d secureOpenFile(logFile);\n         } catch (IOException e) {\n           logErrorMessage(logFile, e);\n           IOUtils.cleanup(LOG, in);\n           continue;\n         }\n \n         final long fileLength \u003d logFile.length();\n         // Write the logFile Type\n         out.writeUTF(logFile.getName());\n \n         // Write the uploaded TimeStamp\n         out.writeLong(System.currentTimeMillis());\n \n         // Write the log length as UTF so that it is printable\n         out.writeUTF(String.valueOf(fileLength));\n \n         // Write the log itself\n         try {\n           byte[] buf \u003d new byte[65535];\n           int len \u003d 0;\n           long bytesLeft \u003d fileLength;\n           while ((len \u003d in.read(buf)) !\u003d -1) {\n             //If buffer contents within fileLength, write\n             if (len \u003c bytesLeft) {\n               out.write(buf, 0, len);\n               bytesLeft-\u003dlen;\n             }\n             //else only write contents within fileLength, then exit early\n             else {\n               out.write(buf, 0, (int)bytesLeft);\n               break;\n             }\n           }\n           long newLength \u003d logFile.length();\n           if(fileLength \u003c newLength) {\n             LOG.warn(\"Aggregated logs truncated by approximately \"+\n                 (newLength-fileLength) +\" bytes.\");\n           }\n           this.uploadedFiles.add(logFile);\n         } catch (IOException e) {\n           String message \u003d logErrorMessage(logFile, e);\n           out.write(message.getBytes());\n         } finally {\n           IOUtils.cleanup(LOG, in);\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void write(DataOutputStream out, Set\u003cFile\u003e pendingUploadFiles)\n        throws IOException {\n      List\u003cFile\u003e fileList \u003d new ArrayList\u003cFile\u003e(pendingUploadFiles);\n      Collections.sort(fileList);\n\n      for (File logFile : fileList) {\n        // We only aggregate top level files.\n        // Ignore anything inside sub-folders.\n        if (logFile.isDirectory()) {\n          LOG.warn(logFile.getAbsolutePath() + \" is a directory. Ignore it.\");\n          continue;\n        }\n\n        FileInputStream in \u003d null;\n        try {\n          in \u003d secureOpenFile(logFile);\n        } catch (IOException e) {\n          logErrorMessage(logFile, e);\n          IOUtils.cleanup(LOG, in);\n          continue;\n        }\n\n        final long fileLength \u003d logFile.length();\n        // Write the logFile Type\n        out.writeUTF(logFile.getName());\n\n        // Write the uploaded TimeStamp\n        out.writeLong(System.currentTimeMillis());\n\n        // Write the log length as UTF so that it is printable\n        out.writeUTF(String.valueOf(fileLength));\n\n        // Write the log itself\n        try {\n          byte[] buf \u003d new byte[65535];\n          int len \u003d 0;\n          long bytesLeft \u003d fileLength;\n          while ((len \u003d in.read(buf)) !\u003d -1) {\n            //If buffer contents within fileLength, write\n            if (len \u003c bytesLeft) {\n              out.write(buf, 0, len);\n              bytesLeft-\u003dlen;\n            }\n            //else only write contents within fileLength, then exit early\n            else {\n              out.write(buf, 0, (int)bytesLeft);\n              break;\n            }\n          }\n          long newLength \u003d logFile.length();\n          if(fileLength \u003c newLength) {\n            LOG.warn(\"Aggregated logs truncated by approximately \"+\n                (newLength-fileLength) +\" bytes.\");\n          }\n          this.uploadedFiles.add(logFile);\n        } catch (IOException e) {\n          String message \u003d logErrorMessage(logFile, e);\n          out.write(message.getBytes());\n        } finally {\n          IOUtils.cleanup(LOG, in);\n        }\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/AggregatedLogFormat.java",
      "extendedDetails": {}
    },
    "f81dc3f995579c1b94b11d60e9fc6da56c8a9496": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2703. Added logUploadedTime into LogValue for better display. Contributed by Xuan Gong.\n",
      "commitDate": "24/10/14 2:10 PM",
      "commitName": "f81dc3f995579c1b94b11d60e9fc6da56c8a9496",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "24/10/14 11:13 AM",
      "commitNameOld": "e31f0a6558b106662c83e1f797216e412b6689a9",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 0.12,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,57 @@\n     public void write(DataOutputStream out, Set\u003cFile\u003e pendingUploadFiles)\n         throws IOException {\n       List\u003cFile\u003e fileList \u003d new ArrayList\u003cFile\u003e(pendingUploadFiles);\n       Collections.sort(fileList);\n \n       for (File logFile : fileList) {\n \n         FileInputStream in \u003d null;\n         try {\n           in \u003d secureOpenFile(logFile);\n         } catch (IOException e) {\n           logErrorMessage(logFile, e);\n           IOUtils.cleanup(LOG, in);\n           continue;\n         }\n \n         final long fileLength \u003d logFile.length();\n         // Write the logFile Type\n         out.writeUTF(logFile.getName());\n \n+        // Write the uploaded TimeStamp\n+        out.writeLong(System.currentTimeMillis());\n+\n         // Write the log length as UTF so that it is printable\n         out.writeUTF(String.valueOf(fileLength));\n \n         // Write the log itself\n         try {\n           byte[] buf \u003d new byte[65535];\n           int len \u003d 0;\n           long bytesLeft \u003d fileLength;\n           while ((len \u003d in.read(buf)) !\u003d -1) {\n             //If buffer contents within fileLength, write\n             if (len \u003c bytesLeft) {\n               out.write(buf, 0, len);\n               bytesLeft-\u003dlen;\n             }\n             //else only write contents within fileLength, then exit early\n             else {\n               out.write(buf, 0, (int)bytesLeft);\n               break;\n             }\n           }\n           long newLength \u003d logFile.length();\n           if(fileLength \u003c newLength) {\n             LOG.warn(\"Aggregated logs truncated by approximately \"+\n                 (newLength-fileLength) +\" bytes.\");\n           }\n           this.uploadedFiles.add(logFile);\n         } catch (IOException e) {\n           String message \u003d logErrorMessage(logFile, e);\n           out.write(message.getBytes());\n         } finally {\n           IOUtils.cleanup(LOG, in);\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void write(DataOutputStream out, Set\u003cFile\u003e pendingUploadFiles)\n        throws IOException {\n      List\u003cFile\u003e fileList \u003d new ArrayList\u003cFile\u003e(pendingUploadFiles);\n      Collections.sort(fileList);\n\n      for (File logFile : fileList) {\n\n        FileInputStream in \u003d null;\n        try {\n          in \u003d secureOpenFile(logFile);\n        } catch (IOException e) {\n          logErrorMessage(logFile, e);\n          IOUtils.cleanup(LOG, in);\n          continue;\n        }\n\n        final long fileLength \u003d logFile.length();\n        // Write the logFile Type\n        out.writeUTF(logFile.getName());\n\n        // Write the uploaded TimeStamp\n        out.writeLong(System.currentTimeMillis());\n\n        // Write the log length as UTF so that it is printable\n        out.writeUTF(String.valueOf(fileLength));\n\n        // Write the log itself\n        try {\n          byte[] buf \u003d new byte[65535];\n          int len \u003d 0;\n          long bytesLeft \u003d fileLength;\n          while ((len \u003d in.read(buf)) !\u003d -1) {\n            //If buffer contents within fileLength, write\n            if (len \u003c bytesLeft) {\n              out.write(buf, 0, len);\n              bytesLeft-\u003dlen;\n            }\n            //else only write contents within fileLength, then exit early\n            else {\n              out.write(buf, 0, (int)bytesLeft);\n              break;\n            }\n          }\n          long newLength \u003d logFile.length();\n          if(fileLength \u003c newLength) {\n            LOG.warn(\"Aggregated logs truncated by approximately \"+\n                (newLength-fileLength) +\" bytes.\");\n          }\n          this.uploadedFiles.add(logFile);\n        } catch (IOException e) {\n          String message \u003d logErrorMessage(logFile, e);\n          out.write(message.getBytes());\n        } finally {\n          IOUtils.cleanup(LOG, in);\n        }\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/AggregatedLogFormat.java",
      "extendedDetails": {}
    },
    "e31f0a6558b106662c83e1f797216e412b6689a9": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2724. Skipped uploading a local log file to HDFS if exception is raised when opening it. Contributed by Xuan Gong.\n",
      "commitDate": "24/10/14 11:13 AM",
      "commitName": "e31f0a6558b106662c83e1f797216e412b6689a9",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "03/10/14 12:15 PM",
      "commitNameOld": "34cdcaad71cad76c0874a4e5266b4074009d2ffc",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 20.96,
      "commitsBetweenForRepo": 169,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,50 +1,54 @@\n     public void write(DataOutputStream out, Set\u003cFile\u003e pendingUploadFiles)\n         throws IOException {\n       List\u003cFile\u003e fileList \u003d new ArrayList\u003cFile\u003e(pendingUploadFiles);\n       Collections.sort(fileList);\n \n       for (File logFile : fileList) {\n+\n+        FileInputStream in \u003d null;\n+        try {\n+          in \u003d secureOpenFile(logFile);\n+        } catch (IOException e) {\n+          logErrorMessage(logFile, e);\n+          IOUtils.cleanup(LOG, in);\n+          continue;\n+        }\n+\n         final long fileLength \u003d logFile.length();\n         // Write the logFile Type\n         out.writeUTF(logFile.getName());\n \n         // Write the log length as UTF so that it is printable\n         out.writeUTF(String.valueOf(fileLength));\n \n         // Write the log itself\n-        FileInputStream in \u003d null;\n         try {\n-          in \u003d SecureIOUtils.openForRead(logFile, getUser(), null);\n           byte[] buf \u003d new byte[65535];\n           int len \u003d 0;\n           long bytesLeft \u003d fileLength;\n           while ((len \u003d in.read(buf)) !\u003d -1) {\n             //If buffer contents within fileLength, write\n             if (len \u003c bytesLeft) {\n               out.write(buf, 0, len);\n               bytesLeft-\u003dlen;\n             }\n             //else only write contents within fileLength, then exit early\n             else {\n               out.write(buf, 0, (int)bytesLeft);\n               break;\n             }\n           }\n           long newLength \u003d logFile.length();\n           if(fileLength \u003c newLength) {\n             LOG.warn(\"Aggregated logs truncated by approximately \"+\n                 (newLength-fileLength) +\" bytes.\");\n           }\n           this.uploadedFiles.add(logFile);\n         } catch (IOException e) {\n-          String message \u003d \"Error aggregating log file. Log file : \"\n-              + logFile.getAbsolutePath() + e.getMessage();\n-          LOG.error(message, e);\n+          String message \u003d logErrorMessage(logFile, e);\n           out.write(message.getBytes());\n         } finally {\n-          if (in !\u003d null) {\n-            in.close();\n-          }\n+          IOUtils.cleanup(LOG, in);\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void write(DataOutputStream out, Set\u003cFile\u003e pendingUploadFiles)\n        throws IOException {\n      List\u003cFile\u003e fileList \u003d new ArrayList\u003cFile\u003e(pendingUploadFiles);\n      Collections.sort(fileList);\n\n      for (File logFile : fileList) {\n\n        FileInputStream in \u003d null;\n        try {\n          in \u003d secureOpenFile(logFile);\n        } catch (IOException e) {\n          logErrorMessage(logFile, e);\n          IOUtils.cleanup(LOG, in);\n          continue;\n        }\n\n        final long fileLength \u003d logFile.length();\n        // Write the logFile Type\n        out.writeUTF(logFile.getName());\n\n        // Write the log length as UTF so that it is printable\n        out.writeUTF(String.valueOf(fileLength));\n\n        // Write the log itself\n        try {\n          byte[] buf \u003d new byte[65535];\n          int len \u003d 0;\n          long bytesLeft \u003d fileLength;\n          while ((len \u003d in.read(buf)) !\u003d -1) {\n            //If buffer contents within fileLength, write\n            if (len \u003c bytesLeft) {\n              out.write(buf, 0, len);\n              bytesLeft-\u003dlen;\n            }\n            //else only write contents within fileLength, then exit early\n            else {\n              out.write(buf, 0, (int)bytesLeft);\n              break;\n            }\n          }\n          long newLength \u003d logFile.length();\n          if(fileLength \u003c newLength) {\n            LOG.warn(\"Aggregated logs truncated by approximately \"+\n                (newLength-fileLength) +\" bytes.\");\n          }\n          this.uploadedFiles.add(logFile);\n        } catch (IOException e) {\n          String message \u003d logErrorMessage(logFile, e);\n          out.write(message.getBytes());\n        } finally {\n          IOUtils.cleanup(LOG, in);\n        }\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/AggregatedLogFormat.java",
      "extendedDetails": {}
    },
    "34cdcaad71cad76c0874a4e5266b4074009d2ffc": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-2468. Enhanced NodeManager to support log handling APIs (YARN-2569) for use by long running services. Contributed by Xuan Gong.\n",
      "commitDate": "03/10/14 12:15 PM",
      "commitName": "34cdcaad71cad76c0874a4e5266b4074009d2ffc",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-2468. Enhanced NodeManager to support log handling APIs (YARN-2569) for use by long running services. Contributed by Xuan Gong.\n",
          "commitDate": "03/10/14 12:15 PM",
          "commitName": "34cdcaad71cad76c0874a4e5266b4074009d2ffc",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "24/03/14 11:11 AM",
          "commitNameOld": "2d89dcb121dd81a53484dbbff5f727e65b938112",
          "commitAuthorOld": "Jonathan Turner Eagles",
          "daysBetweenCommits": 193.04,
          "commitsBetweenForRepo": 1547,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,65 +1,50 @@\n-    public void write(DataOutputStream out) throws IOException {\n-      for (String rootLogDir : this.rootLogDirs) {\n-        File appLogDir \u003d\n-            new File(rootLogDir, \n-                ConverterUtils.toString(\n-                    this.containerId.getApplicationAttemptId().\n-                        getApplicationId())\n-                );\n-        File containerLogDir \u003d\n-            new File(appLogDir, ConverterUtils.toString(this.containerId));\n+    public void write(DataOutputStream out, Set\u003cFile\u003e pendingUploadFiles)\n+        throws IOException {\n+      List\u003cFile\u003e fileList \u003d new ArrayList\u003cFile\u003e(pendingUploadFiles);\n+      Collections.sort(fileList);\n \n-        if (!containerLogDir.isDirectory()) {\n-          continue; // ContainerDir may have been deleted by the user.\n-        }\n+      for (File logFile : fileList) {\n+        final long fileLength \u003d logFile.length();\n+        // Write the logFile Type\n+        out.writeUTF(logFile.getName());\n \n-        // Write out log files in lexical order\n-        File[] logFiles \u003d containerLogDir.listFiles();\n-        Arrays.sort(logFiles);\n-        for (File logFile : logFiles) {\n+        // Write the log length as UTF so that it is printable\n+        out.writeUTF(String.valueOf(fileLength));\n \n-          final long fileLength \u003d logFile.length();\n-\n-          // Write the logFile Type\n-          out.writeUTF(logFile.getName());\n-\n-          // Write the log length as UTF so that it is printable\n-          out.writeUTF(String.valueOf(fileLength));\n-\n-          // Write the log itself\n-          FileInputStream in \u003d null;\n-          try {\n-            in \u003d SecureIOUtils.openForRead(logFile, getUser(), null);\n-            byte[] buf \u003d new byte[65535];\n-            int len \u003d 0;\n-            long bytesLeft \u003d fileLength;\n-            while ((len \u003d in.read(buf)) !\u003d -1) {\n-              //If buffer contents within fileLength, write\n-              if (len \u003c bytesLeft) {\n-                out.write(buf, 0, len);\n-                bytesLeft-\u003dlen;\n-              }\n-              //else only write contents within fileLength, then exit early\n-              else {\n-                out.write(buf, 0, (int)bytesLeft);\n-                break;\n-              }\n+        // Write the log itself\n+        FileInputStream in \u003d null;\n+        try {\n+          in \u003d SecureIOUtils.openForRead(logFile, getUser(), null);\n+          byte[] buf \u003d new byte[65535];\n+          int len \u003d 0;\n+          long bytesLeft \u003d fileLength;\n+          while ((len \u003d in.read(buf)) !\u003d -1) {\n+            //If buffer contents within fileLength, write\n+            if (len \u003c bytesLeft) {\n+              out.write(buf, 0, len);\n+              bytesLeft-\u003dlen;\n             }\n-            long newLength \u003d logFile.length();\n-            if(fileLength \u003c newLength) {\n-              LOG.warn(\"Aggregated logs truncated by approximately \"+\n-                  (newLength-fileLength) +\" bytes.\");\n+            //else only write contents within fileLength, then exit early\n+            else {\n+              out.write(buf, 0, (int)bytesLeft);\n+              break;\n             }\n-          } catch (IOException e) {\n-            String message \u003d \"Error aggregating log file. Log file : \"\n-                + logFile.getAbsolutePath() + e.getMessage(); \n-            LOG.error(message, e);\n-            out.write(message.getBytes());\n-          } finally {\n-            if (in !\u003d null) {\n-              in.close();\n-            }\n+          }\n+          long newLength \u003d logFile.length();\n+          if(fileLength \u003c newLength) {\n+            LOG.warn(\"Aggregated logs truncated by approximately \"+\n+                (newLength-fileLength) +\" bytes.\");\n+          }\n+          this.uploadedFiles.add(logFile);\n+        } catch (IOException e) {\n+          String message \u003d \"Error aggregating log file. Log file : \"\n+              + logFile.getAbsolutePath() + e.getMessage();\n+          LOG.error(message, e);\n+          out.write(message.getBytes());\n+        } finally {\n+          if (in !\u003d null) {\n+            in.close();\n           }\n         }\n       }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    public void write(DataOutputStream out, Set\u003cFile\u003e pendingUploadFiles)\n        throws IOException {\n      List\u003cFile\u003e fileList \u003d new ArrayList\u003cFile\u003e(pendingUploadFiles);\n      Collections.sort(fileList);\n\n      for (File logFile : fileList) {\n        final long fileLength \u003d logFile.length();\n        // Write the logFile Type\n        out.writeUTF(logFile.getName());\n\n        // Write the log length as UTF so that it is printable\n        out.writeUTF(String.valueOf(fileLength));\n\n        // Write the log itself\n        FileInputStream in \u003d null;\n        try {\n          in \u003d SecureIOUtils.openForRead(logFile, getUser(), null);\n          byte[] buf \u003d new byte[65535];\n          int len \u003d 0;\n          long bytesLeft \u003d fileLength;\n          while ((len \u003d in.read(buf)) !\u003d -1) {\n            //If buffer contents within fileLength, write\n            if (len \u003c bytesLeft) {\n              out.write(buf, 0, len);\n              bytesLeft-\u003dlen;\n            }\n            //else only write contents within fileLength, then exit early\n            else {\n              out.write(buf, 0, (int)bytesLeft);\n              break;\n            }\n          }\n          long newLength \u003d logFile.length();\n          if(fileLength \u003c newLength) {\n            LOG.warn(\"Aggregated logs truncated by approximately \"+\n                (newLength-fileLength) +\" bytes.\");\n          }\n          this.uploadedFiles.add(logFile);\n        } catch (IOException e) {\n          String message \u003d \"Error aggregating log file. Log file : \"\n              + logFile.getAbsolutePath() + e.getMessage();\n          LOG.error(message, e);\n          out.write(message.getBytes());\n        } finally {\n          if (in !\u003d null) {\n            in.close();\n          }\n        }\n      }\n    }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/AggregatedLogFormat.java",
          "extendedDetails": {
            "oldValue": "[out-DataOutputStream]",
            "newValue": "[out-DataOutputStream, pendingUploadFiles-Set\u003cFile\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-2468. Enhanced NodeManager to support log handling APIs (YARN-2569) for use by long running services. Contributed by Xuan Gong.\n",
          "commitDate": "03/10/14 12:15 PM",
          "commitName": "34cdcaad71cad76c0874a4e5266b4074009d2ffc",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "24/03/14 11:11 AM",
          "commitNameOld": "2d89dcb121dd81a53484dbbff5f727e65b938112",
          "commitAuthorOld": "Jonathan Turner Eagles",
          "daysBetweenCommits": 193.04,
          "commitsBetweenForRepo": 1547,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,65 +1,50 @@\n-    public void write(DataOutputStream out) throws IOException {\n-      for (String rootLogDir : this.rootLogDirs) {\n-        File appLogDir \u003d\n-            new File(rootLogDir, \n-                ConverterUtils.toString(\n-                    this.containerId.getApplicationAttemptId().\n-                        getApplicationId())\n-                );\n-        File containerLogDir \u003d\n-            new File(appLogDir, ConverterUtils.toString(this.containerId));\n+    public void write(DataOutputStream out, Set\u003cFile\u003e pendingUploadFiles)\n+        throws IOException {\n+      List\u003cFile\u003e fileList \u003d new ArrayList\u003cFile\u003e(pendingUploadFiles);\n+      Collections.sort(fileList);\n \n-        if (!containerLogDir.isDirectory()) {\n-          continue; // ContainerDir may have been deleted by the user.\n-        }\n+      for (File logFile : fileList) {\n+        final long fileLength \u003d logFile.length();\n+        // Write the logFile Type\n+        out.writeUTF(logFile.getName());\n \n-        // Write out log files in lexical order\n-        File[] logFiles \u003d containerLogDir.listFiles();\n-        Arrays.sort(logFiles);\n-        for (File logFile : logFiles) {\n+        // Write the log length as UTF so that it is printable\n+        out.writeUTF(String.valueOf(fileLength));\n \n-          final long fileLength \u003d logFile.length();\n-\n-          // Write the logFile Type\n-          out.writeUTF(logFile.getName());\n-\n-          // Write the log length as UTF so that it is printable\n-          out.writeUTF(String.valueOf(fileLength));\n-\n-          // Write the log itself\n-          FileInputStream in \u003d null;\n-          try {\n-            in \u003d SecureIOUtils.openForRead(logFile, getUser(), null);\n-            byte[] buf \u003d new byte[65535];\n-            int len \u003d 0;\n-            long bytesLeft \u003d fileLength;\n-            while ((len \u003d in.read(buf)) !\u003d -1) {\n-              //If buffer contents within fileLength, write\n-              if (len \u003c bytesLeft) {\n-                out.write(buf, 0, len);\n-                bytesLeft-\u003dlen;\n-              }\n-              //else only write contents within fileLength, then exit early\n-              else {\n-                out.write(buf, 0, (int)bytesLeft);\n-                break;\n-              }\n+        // Write the log itself\n+        FileInputStream in \u003d null;\n+        try {\n+          in \u003d SecureIOUtils.openForRead(logFile, getUser(), null);\n+          byte[] buf \u003d new byte[65535];\n+          int len \u003d 0;\n+          long bytesLeft \u003d fileLength;\n+          while ((len \u003d in.read(buf)) !\u003d -1) {\n+            //If buffer contents within fileLength, write\n+            if (len \u003c bytesLeft) {\n+              out.write(buf, 0, len);\n+              bytesLeft-\u003dlen;\n             }\n-            long newLength \u003d logFile.length();\n-            if(fileLength \u003c newLength) {\n-              LOG.warn(\"Aggregated logs truncated by approximately \"+\n-                  (newLength-fileLength) +\" bytes.\");\n+            //else only write contents within fileLength, then exit early\n+            else {\n+              out.write(buf, 0, (int)bytesLeft);\n+              break;\n             }\n-          } catch (IOException e) {\n-            String message \u003d \"Error aggregating log file. Log file : \"\n-                + logFile.getAbsolutePath() + e.getMessage(); \n-            LOG.error(message, e);\n-            out.write(message.getBytes());\n-          } finally {\n-            if (in !\u003d null) {\n-              in.close();\n-            }\n+          }\n+          long newLength \u003d logFile.length();\n+          if(fileLength \u003c newLength) {\n+            LOG.warn(\"Aggregated logs truncated by approximately \"+\n+                (newLength-fileLength) +\" bytes.\");\n+          }\n+          this.uploadedFiles.add(logFile);\n+        } catch (IOException e) {\n+          String message \u003d \"Error aggregating log file. Log file : \"\n+              + logFile.getAbsolutePath() + e.getMessage();\n+          LOG.error(message, e);\n+          out.write(message.getBytes());\n+        } finally {\n+          if (in !\u003d null) {\n+            in.close();\n           }\n         }\n       }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    public void write(DataOutputStream out, Set\u003cFile\u003e pendingUploadFiles)\n        throws IOException {\n      List\u003cFile\u003e fileList \u003d new ArrayList\u003cFile\u003e(pendingUploadFiles);\n      Collections.sort(fileList);\n\n      for (File logFile : fileList) {\n        final long fileLength \u003d logFile.length();\n        // Write the logFile Type\n        out.writeUTF(logFile.getName());\n\n        // Write the log length as UTF so that it is printable\n        out.writeUTF(String.valueOf(fileLength));\n\n        // Write the log itself\n        FileInputStream in \u003d null;\n        try {\n          in \u003d SecureIOUtils.openForRead(logFile, getUser(), null);\n          byte[] buf \u003d new byte[65535];\n          int len \u003d 0;\n          long bytesLeft \u003d fileLength;\n          while ((len \u003d in.read(buf)) !\u003d -1) {\n            //If buffer contents within fileLength, write\n            if (len \u003c bytesLeft) {\n              out.write(buf, 0, len);\n              bytesLeft-\u003dlen;\n            }\n            //else only write contents within fileLength, then exit early\n            else {\n              out.write(buf, 0, (int)bytesLeft);\n              break;\n            }\n          }\n          long newLength \u003d logFile.length();\n          if(fileLength \u003c newLength) {\n            LOG.warn(\"Aggregated logs truncated by approximately \"+\n                (newLength-fileLength) +\" bytes.\");\n          }\n          this.uploadedFiles.add(logFile);\n        } catch (IOException e) {\n          String message \u003d \"Error aggregating log file. Log file : \"\n              + logFile.getAbsolutePath() + e.getMessage();\n          LOG.error(message, e);\n          out.write(message.getBytes());\n        } finally {\n          if (in !\u003d null) {\n            in.close();\n          }\n        }\n      }\n    }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/AggregatedLogFormat.java",
          "extendedDetails": {}
        }
      ]
    },
    "2d89dcb121dd81a53484dbbff5f727e65b938112": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1670. aggregated log writer can write more log data then it says is the log length (Mit Desai via jeagles)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1580957 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/03/14 11:11 AM",
      "commitName": "2d89dcb121dd81a53484dbbff5f727e65b938112",
      "commitAuthor": "Jonathan Turner Eagles",
      "commitDateOld": "21/03/14 11:35 AM",
      "commitNameOld": "2826a35469acd262c76fa26e730a21843ac6e856",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 2.98,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,57 +1,65 @@\n     public void write(DataOutputStream out) throws IOException {\n       for (String rootLogDir : this.rootLogDirs) {\n         File appLogDir \u003d\n             new File(rootLogDir, \n                 ConverterUtils.toString(\n                     this.containerId.getApplicationAttemptId().\n                         getApplicationId())\n                 );\n         File containerLogDir \u003d\n             new File(appLogDir, ConverterUtils.toString(this.containerId));\n \n         if (!containerLogDir.isDirectory()) {\n           continue; // ContainerDir may have been deleted by the user.\n         }\n \n         // Write out log files in lexical order\n         File[] logFiles \u003d containerLogDir.listFiles();\n         Arrays.sort(logFiles);\n         for (File logFile : logFiles) {\n \n-          long fileLength \u003d 0;\n+          final long fileLength \u003d logFile.length();\n \n           // Write the logFile Type\n           out.writeUTF(logFile.getName());\n \n           // Write the log length as UTF so that it is printable\n-          out.writeUTF(String.valueOf(fileLength \u003d logFile.length()));\n+          out.writeUTF(String.valueOf(fileLength));\n \n           // Write the log itself\n           FileInputStream in \u003d null;\n           try {\n             in \u003d SecureIOUtils.openForRead(logFile, getUser(), null);\n             byte[] buf \u003d new byte[65535];\n-            long curRead \u003d 0;\n             int len \u003d 0;\n-            while ( ((len \u003d in.read(buf)) !\u003d -1) \u0026\u0026 (curRead \u003c fileLength) ) {\n-              out.write(buf, 0, len);\n-              curRead +\u003d len;\n+            long bytesLeft \u003d fileLength;\n+            while ((len \u003d in.read(buf)) !\u003d -1) {\n+              //If buffer contents within fileLength, write\n+              if (len \u003c bytesLeft) {\n+                out.write(buf, 0, len);\n+                bytesLeft-\u003dlen;\n+              }\n+              //else only write contents within fileLength, then exit early\n+              else {\n+                out.write(buf, 0, (int)bytesLeft);\n+                break;\n+              }\n             }\n             long newLength \u003d logFile.length();\n             if(fileLength \u003c newLength) {\n-              LOG.warn(\"Aggregated Logs Truncated by \"+\n+              LOG.warn(\"Aggregated logs truncated by approximately \"+\n                   (newLength-fileLength) +\" bytes.\");\n             }\n           } catch (IOException e) {\n             String message \u003d \"Error aggregating log file. Log file : \"\n                 + logFile.getAbsolutePath() + e.getMessage(); \n             LOG.error(message, e);\n             out.write(message.getBytes());\n           } finally {\n             if (in !\u003d null) {\n               in.close();\n             }\n           }\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void write(DataOutputStream out) throws IOException {\n      for (String rootLogDir : this.rootLogDirs) {\n        File appLogDir \u003d\n            new File(rootLogDir, \n                ConverterUtils.toString(\n                    this.containerId.getApplicationAttemptId().\n                        getApplicationId())\n                );\n        File containerLogDir \u003d\n            new File(appLogDir, ConverterUtils.toString(this.containerId));\n\n        if (!containerLogDir.isDirectory()) {\n          continue; // ContainerDir may have been deleted by the user.\n        }\n\n        // Write out log files in lexical order\n        File[] logFiles \u003d containerLogDir.listFiles();\n        Arrays.sort(logFiles);\n        for (File logFile : logFiles) {\n\n          final long fileLength \u003d logFile.length();\n\n          // Write the logFile Type\n          out.writeUTF(logFile.getName());\n\n          // Write the log length as UTF so that it is printable\n          out.writeUTF(String.valueOf(fileLength));\n\n          // Write the log itself\n          FileInputStream in \u003d null;\n          try {\n            in \u003d SecureIOUtils.openForRead(logFile, getUser(), null);\n            byte[] buf \u003d new byte[65535];\n            int len \u003d 0;\n            long bytesLeft \u003d fileLength;\n            while ((len \u003d in.read(buf)) !\u003d -1) {\n              //If buffer contents within fileLength, write\n              if (len \u003c bytesLeft) {\n                out.write(buf, 0, len);\n                bytesLeft-\u003dlen;\n              }\n              //else only write contents within fileLength, then exit early\n              else {\n                out.write(buf, 0, (int)bytesLeft);\n                break;\n              }\n            }\n            long newLength \u003d logFile.length();\n            if(fileLength \u003c newLength) {\n              LOG.warn(\"Aggregated logs truncated by approximately \"+\n                  (newLength-fileLength) +\" bytes.\");\n            }\n          } catch (IOException e) {\n            String message \u003d \"Error aggregating log file. Log file : \"\n                + logFile.getAbsolutePath() + e.getMessage(); \n            LOG.error(message, e);\n            out.write(message.getBytes());\n          } finally {\n            if (in !\u003d null) {\n              in.close();\n            }\n          }\n        }\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/AggregatedLogFormat.java",
      "extendedDetails": {}
    },
    "2826a35469acd262c76fa26e730a21843ac6e856": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1670. Fixed a bug in log-aggregation that can cause the writer to write more log-data than the log-length that it records. Contributed by Mit Desai.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1580005 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/03/14 11:35 AM",
      "commitName": "2826a35469acd262c76fa26e730a21843ac6e856",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "16/12/13 11:27 AM",
      "commitNameOld": "5a1b33507b935f91d6dee6056fe840e778fb198e",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 94.96,
      "commitsBetweenForRepo": 707,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,48 +1,57 @@\n     public void write(DataOutputStream out) throws IOException {\n       for (String rootLogDir : this.rootLogDirs) {\n         File appLogDir \u003d\n             new File(rootLogDir, \n                 ConverterUtils.toString(\n                     this.containerId.getApplicationAttemptId().\n                         getApplicationId())\n                 );\n         File containerLogDir \u003d\n             new File(appLogDir, ConverterUtils.toString(this.containerId));\n \n         if (!containerLogDir.isDirectory()) {\n           continue; // ContainerDir may have been deleted by the user.\n         }\n \n         // Write out log files in lexical order\n         File[] logFiles \u003d containerLogDir.listFiles();\n         Arrays.sort(logFiles);\n         for (File logFile : logFiles) {\n \n+          long fileLength \u003d 0;\n+\n           // Write the logFile Type\n           out.writeUTF(logFile.getName());\n \n           // Write the log length as UTF so that it is printable\n-          out.writeUTF(String.valueOf(logFile.length()));\n+          out.writeUTF(String.valueOf(fileLength \u003d logFile.length()));\n \n           // Write the log itself\n           FileInputStream in \u003d null;\n           try {\n             in \u003d SecureIOUtils.openForRead(logFile, getUser(), null);\n             byte[] buf \u003d new byte[65535];\n+            long curRead \u003d 0;\n             int len \u003d 0;\n-            while ((len \u003d in.read(buf)) !\u003d -1) {\n+            while ( ((len \u003d in.read(buf)) !\u003d -1) \u0026\u0026 (curRead \u003c fileLength) ) {\n               out.write(buf, 0, len);\n+              curRead +\u003d len;\n+            }\n+            long newLength \u003d logFile.length();\n+            if(fileLength \u003c newLength) {\n+              LOG.warn(\"Aggregated Logs Truncated by \"+\n+                  (newLength-fileLength) +\" bytes.\");\n             }\n           } catch (IOException e) {\n             String message \u003d \"Error aggregating log file. Log file : \"\n                 + logFile.getAbsolutePath() + e.getMessage(); \n             LOG.error(message, e);\n             out.write(message.getBytes());\n           } finally {\n             if (in !\u003d null) {\n               in.close();\n             }\n           }\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void write(DataOutputStream out) throws IOException {\n      for (String rootLogDir : this.rootLogDirs) {\n        File appLogDir \u003d\n            new File(rootLogDir, \n                ConverterUtils.toString(\n                    this.containerId.getApplicationAttemptId().\n                        getApplicationId())\n                );\n        File containerLogDir \u003d\n            new File(appLogDir, ConverterUtils.toString(this.containerId));\n\n        if (!containerLogDir.isDirectory()) {\n          continue; // ContainerDir may have been deleted by the user.\n        }\n\n        // Write out log files in lexical order\n        File[] logFiles \u003d containerLogDir.listFiles();\n        Arrays.sort(logFiles);\n        for (File logFile : logFiles) {\n\n          long fileLength \u003d 0;\n\n          // Write the logFile Type\n          out.writeUTF(logFile.getName());\n\n          // Write the log length as UTF so that it is printable\n          out.writeUTF(String.valueOf(fileLength \u003d logFile.length()));\n\n          // Write the log itself\n          FileInputStream in \u003d null;\n          try {\n            in \u003d SecureIOUtils.openForRead(logFile, getUser(), null);\n            byte[] buf \u003d new byte[65535];\n            long curRead \u003d 0;\n            int len \u003d 0;\n            while ( ((len \u003d in.read(buf)) !\u003d -1) \u0026\u0026 (curRead \u003c fileLength) ) {\n              out.write(buf, 0, len);\n              curRead +\u003d len;\n            }\n            long newLength \u003d logFile.length();\n            if(fileLength \u003c newLength) {\n              LOG.warn(\"Aggregated Logs Truncated by \"+\n                  (newLength-fileLength) +\" bytes.\");\n            }\n          } catch (IOException e) {\n            String message \u003d \"Error aggregating log file. Log file : \"\n                + logFile.getAbsolutePath() + e.getMessage(); \n            LOG.error(message, e);\n            out.write(message.getBytes());\n          } finally {\n            if (in !\u003d null) {\n              in.close();\n            }\n          }\n        }\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/AggregatedLogFormat.java",
      "extendedDetails": {}
    },
    "5420f287ccc83df69b6725942754c82b89e46b3e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-578. Fixed NM to use SecureIOUtils for reading and aggregating logs. Contributed by Omkar Vinit Joshi.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1487672 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/05/13 4:14 PM",
      "commitName": "5420f287ccc83df69b6725942754c82b89e46b3e",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "19/03/13 12:29 PM",
      "commitNameOld": "67699c2d187a8480a46acf5031652ff19196823d",
      "commitAuthorOld": "Jason Darrell Lowe",
      "daysBetweenCommits": 71.16,
      "commitsBetweenForRepo": 419,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,48 @@\n     public void write(DataOutputStream out) throws IOException {\n       for (String rootLogDir : this.rootLogDirs) {\n         File appLogDir \u003d\n             new File(rootLogDir, \n                 ConverterUtils.toString(\n                     this.containerId.getApplicationAttemptId().\n                         getApplicationId())\n                 );\n         File containerLogDir \u003d\n             new File(appLogDir, ConverterUtils.toString(this.containerId));\n \n         if (!containerLogDir.isDirectory()) {\n           continue; // ContainerDir may have been deleted by the user.\n         }\n \n         // Write out log files in lexical order\n         File[] logFiles \u003d containerLogDir.listFiles();\n         Arrays.sort(logFiles);\n         for (File logFile : logFiles) {\n \n           // Write the logFile Type\n           out.writeUTF(logFile.getName());\n \n           // Write the log length as UTF so that it is printable\n           out.writeUTF(String.valueOf(logFile.length()));\n \n           // Write the log itself\n           FileInputStream in \u003d null;\n           try {\n-            in \u003d new FileInputStream(logFile);\n+            in \u003d SecureIOUtils.openForRead(logFile, getUser(), null);\n             byte[] buf \u003d new byte[65535];\n             int len \u003d 0;\n             while ((len \u003d in.read(buf)) !\u003d -1) {\n               out.write(buf, 0, len);\n             }\n+          } catch (IOException e) {\n+            String message \u003d \"Error aggregating log file. Log file : \"\n+                + logFile.getAbsolutePath() + e.getMessage(); \n+            LOG.error(message, e);\n+            out.write(message.getBytes());\n           } finally {\n-            in.close();\n+            if (in !\u003d null) {\n+              in.close();\n+            }\n           }\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void write(DataOutputStream out) throws IOException {\n      for (String rootLogDir : this.rootLogDirs) {\n        File appLogDir \u003d\n            new File(rootLogDir, \n                ConverterUtils.toString(\n                    this.containerId.getApplicationAttemptId().\n                        getApplicationId())\n                );\n        File containerLogDir \u003d\n            new File(appLogDir, ConverterUtils.toString(this.containerId));\n\n        if (!containerLogDir.isDirectory()) {\n          continue; // ContainerDir may have been deleted by the user.\n        }\n\n        // Write out log files in lexical order\n        File[] logFiles \u003d containerLogDir.listFiles();\n        Arrays.sort(logFiles);\n        for (File logFile : logFiles) {\n\n          // Write the logFile Type\n          out.writeUTF(logFile.getName());\n\n          // Write the log length as UTF so that it is printable\n          out.writeUTF(String.valueOf(logFile.length()));\n\n          // Write the log itself\n          FileInputStream in \u003d null;\n          try {\n            in \u003d SecureIOUtils.openForRead(logFile, getUser(), null);\n            byte[] buf \u003d new byte[65535];\n            int len \u003d 0;\n            while ((len \u003d in.read(buf)) !\u003d -1) {\n              out.write(buf, 0, len);\n            }\n          } catch (IOException e) {\n            String message \u003d \"Error aggregating log file. Log file : \"\n                + logFile.getAbsolutePath() + e.getMessage(); \n            LOG.error(message, e);\n            out.write(message.getBytes());\n          } finally {\n            if (in !\u003d null) {\n              in.close();\n            }\n          }\n        }\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/AggregatedLogFormat.java",
      "extendedDetails": {}
    },
    "e1fdf62123625e4ba399af02f8aad500637d29d1": {
      "type": "Yfilerename",
      "commitMessage": "YARN-1. Promote YARN to be a sub-project of Apache Hadoop.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1370666 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/08/12 10:22 PM",
      "commitName": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "07/08/12 7:53 PM",
      "commitNameOld": "34554d1e11ee1d5b564d7d9ed3e6d55931d72749",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    public void write(DataOutputStream out) throws IOException {\n      for (String rootLogDir : this.rootLogDirs) {\n        File appLogDir \u003d\n            new File(rootLogDir, \n                ConverterUtils.toString(\n                    this.containerId.getApplicationAttemptId().\n                        getApplicationId())\n                );\n        File containerLogDir \u003d\n            new File(appLogDir, ConverterUtils.toString(this.containerId));\n\n        if (!containerLogDir.isDirectory()) {\n          continue; // ContainerDir may have been deleted by the user.\n        }\n\n        // Write out log files in lexical order\n        File[] logFiles \u003d containerLogDir.listFiles();\n        Arrays.sort(logFiles);\n        for (File logFile : logFiles) {\n\n          // Write the logFile Type\n          out.writeUTF(logFile.getName());\n\n          // Write the log length as UTF so that it is printable\n          out.writeUTF(String.valueOf(logFile.length()));\n\n          // Write the log itself\n          FileInputStream in \u003d null;\n          try {\n            in \u003d new FileInputStream(logFile);\n            byte[] buf \u003d new byte[65535];\n            int len \u003d 0;\n            while ((len \u003d in.read(buf)) !\u003d -1) {\n              out.write(buf, 0, len);\n            }\n          } finally {\n            in.close();\n          }\n        }\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/AggregatedLogFormat.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/AggregatedLogFormat.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/AggregatedLogFormat.java"
      }
    },
    "cda16311a90134a50c57585831218c7b43827693": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-4169. Container Logs appear in unsorted order (Jonathan Eagles via bobby)\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1331012 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "26/04/12 11:27 AM",
      "commitName": "cda16311a90134a50c57585831218c7b43827693",
      "commitAuthor": "Robert Joseph Evans",
      "commitDateOld": "16/03/12 1:10 PM",
      "commitNameOld": "f58e3c8b121859194185fa12bfbd0ff57e6bcc7f",
      "commitAuthorOld": "Thomas Graves",
      "daysBetweenCommits": 40.93,
      "commitsBetweenForRepo": 300,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,41 @@\n     public void write(DataOutputStream out) throws IOException {\n       for (String rootLogDir : this.rootLogDirs) {\n         File appLogDir \u003d\n             new File(rootLogDir, \n                 ConverterUtils.toString(\n                     this.containerId.getApplicationAttemptId().\n                         getApplicationId())\n                 );\n         File containerLogDir \u003d\n             new File(appLogDir, ConverterUtils.toString(this.containerId));\n \n         if (!containerLogDir.isDirectory()) {\n           continue; // ContainerDir may have been deleted by the user.\n         }\n \n-        for (File logFile : containerLogDir.listFiles()) {\n+        // Write out log files in lexical order\n+        File[] logFiles \u003d containerLogDir.listFiles();\n+        Arrays.sort(logFiles);\n+        for (File logFile : logFiles) {\n \n           // Write the logFile Type\n           out.writeUTF(logFile.getName());\n \n           // Write the log length as UTF so that it is printable\n           out.writeUTF(String.valueOf(logFile.length()));\n \n           // Write the log itself\n           FileInputStream in \u003d null;\n           try {\n             in \u003d new FileInputStream(logFile);\n             byte[] buf \u003d new byte[65535];\n             int len \u003d 0;\n             while ((len \u003d in.read(buf)) !\u003d -1) {\n               out.write(buf, 0, len);\n             }\n           } finally {\n             in.close();\n           }\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void write(DataOutputStream out) throws IOException {\n      for (String rootLogDir : this.rootLogDirs) {\n        File appLogDir \u003d\n            new File(rootLogDir, \n                ConverterUtils.toString(\n                    this.containerId.getApplicationAttemptId().\n                        getApplicationId())\n                );\n        File containerLogDir \u003d\n            new File(appLogDir, ConverterUtils.toString(this.containerId));\n\n        if (!containerLogDir.isDirectory()) {\n          continue; // ContainerDir may have been deleted by the user.\n        }\n\n        // Write out log files in lexical order\n        File[] logFiles \u003d containerLogDir.listFiles();\n        Arrays.sort(logFiles);\n        for (File logFile : logFiles) {\n\n          // Write the logFile Type\n          out.writeUTF(logFile.getName());\n\n          // Write the log length as UTF so that it is printable\n          out.writeUTF(String.valueOf(logFile.length()));\n\n          // Write the log itself\n          FileInputStream in \u003d null;\n          try {\n            in \u003d new FileInputStream(logFile);\n            byte[] buf \u003d new byte[65535];\n            int len \u003d 0;\n            while ((len \u003d in.read(buf)) !\u003d -1) {\n              out.write(buf, 0, len);\n            }\n          } finally {\n            in.close();\n          }\n        }\n      }\n    }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/AggregatedLogFormat.java",
      "extendedDetails": {}
    },
    "c27601fefebd0af887a12d684bfc6f90d9fc0321": {
      "type": "Yfilerename",
      "commitMessage": "MAPREDUCE-3297. Moved log related components into yarn-common so that HistoryServer and clients can use them without depending on the yarn-server-nodemanager module. Contributed by Siddharth Seth.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1196986 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/11/11 1:02 AM",
      "commitName": "c27601fefebd0af887a12d684bfc6f90d9fc0321",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "03/11/11 12:06 AM",
      "commitNameOld": "0df4878033b797b9313c887ca9d75f8ea104d029",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    public void write(DataOutputStream out) throws IOException {\n      for (String rootLogDir : this.rootLogDirs) {\n        File appLogDir \u003d\n            new File(rootLogDir, \n                ConverterUtils.toString(\n                    this.containerId.getApplicationAttemptId().\n                        getApplicationId())\n                );\n        File containerLogDir \u003d\n            new File(appLogDir, ConverterUtils.toString(this.containerId));\n\n        if (!containerLogDir.isDirectory()) {\n          continue; // ContainerDir may have been deleted by the user.\n        }\n\n        for (File logFile : containerLogDir.listFiles()) {\n\n          // Write the logFile Type\n          out.writeUTF(logFile.getName());\n\n          // Write the log length as UTF so that it is printable\n          out.writeUTF(String.valueOf(logFile.length()));\n\n          // Write the log itself\n          FileInputStream in \u003d null;\n          try {\n            in \u003d new FileInputStream(logFile);\n            byte[] buf \u003d new byte[65535];\n            int len \u003d 0;\n            while ((len \u003d in.read(buf)) !\u003d -1) {\n              out.write(buf, 0, len);\n            }\n          } finally {\n            in.close();\n          }\n        }\n      }\n    }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/AggregatedLogFormat.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AggregatedLogFormat.java",
        "newPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/AggregatedLogFormat.java"
      }
    },
    "6165875dc6bf67d72fc3ce1d96dfc80ba312d4a1": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2896. Simplify all apis to in org.apache.hadoop.yarn.api.records.* to be get/set only. Added javadocs to all public records.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1169980 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/09/11 5:05 PM",
      "commitName": "6165875dc6bf67d72fc3ce1d96dfc80ba312d4a1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "08/09/11 6:44 PM",
      "commitNameOld": "fafe8cd28e726566509c679e19d7da622f29f90d",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 3.93,
      "commitsBetweenForRepo": 25,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,38 @@\n     public void write(DataOutputStream out) throws IOException {\n       for (String rootLogDir : this.rootLogDirs) {\n         File appLogDir \u003d\n-            new File(rootLogDir, ConverterUtils.toString(this.containerId\n-                .getAppId()));\n+            new File(rootLogDir, \n+                ConverterUtils.toString(\n+                    this.containerId.getApplicationAttemptId().\n+                        getApplicationId())\n+                );\n         File containerLogDir \u003d\n             new File(appLogDir, ConverterUtils.toString(this.containerId));\n \n         if (!containerLogDir.isDirectory()) {\n           continue; // ContainerDir may have been deleted by the user.\n         }\n \n         for (File logFile : containerLogDir.listFiles()) {\n \n           // Write the logFile Type\n           out.writeUTF(logFile.getName());\n \n           // Write the log length as UTF so that it is printable\n           out.writeUTF(String.valueOf(logFile.length()));\n \n           // Write the log itself\n           FileInputStream in \u003d null;\n           try {\n             in \u003d new FileInputStream(logFile);\n             byte[] buf \u003d new byte[65535];\n             int len \u003d 0;\n             while ((len \u003d in.read(buf)) !\u003d -1) {\n               out.write(buf, 0, len);\n             }\n           } finally {\n             in.close();\n           }\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void write(DataOutputStream out) throws IOException {\n      for (String rootLogDir : this.rootLogDirs) {\n        File appLogDir \u003d\n            new File(rootLogDir, \n                ConverterUtils.toString(\n                    this.containerId.getApplicationAttemptId().\n                        getApplicationId())\n                );\n        File containerLogDir \u003d\n            new File(appLogDir, ConverterUtils.toString(this.containerId));\n\n        if (!containerLogDir.isDirectory()) {\n          continue; // ContainerDir may have been deleted by the user.\n        }\n\n        for (File logFile : containerLogDir.listFiles()) {\n\n          // Write the logFile Type\n          out.writeUTF(logFile.getName());\n\n          // Write the log length as UTF so that it is printable\n          out.writeUTF(String.valueOf(logFile.length()));\n\n          // Write the log itself\n          FileInputStream in \u003d null;\n          try {\n            in \u003d new FileInputStream(logFile);\n            byte[] buf \u003d new byte[65535];\n            int len \u003d 0;\n            while ((len \u003d in.read(buf)) !\u003d -1) {\n              out.write(buf, 0, len);\n            }\n          } finally {\n            in.close();\n          }\n        }\n      }\n    }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AggregatedLogFormat.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    public void write(DataOutputStream out) throws IOException {\n      for (String rootLogDir : this.rootLogDirs) {\n        File appLogDir \u003d\n            new File(rootLogDir, ConverterUtils.toString(this.containerId\n                .getAppId()));\n        File containerLogDir \u003d\n            new File(appLogDir, ConverterUtils.toString(this.containerId));\n\n        if (!containerLogDir.isDirectory()) {\n          continue; // ContainerDir may have been deleted by the user.\n        }\n\n        for (File logFile : containerLogDir.listFiles()) {\n\n          // Write the logFile Type\n          out.writeUTF(logFile.getName());\n\n          // Write the log length as UTF so that it is printable\n          out.writeUTF(String.valueOf(logFile.length()));\n\n          // Write the log itself\n          FileInputStream in \u003d null;\n          try {\n            in \u003d new FileInputStream(logFile);\n            byte[] buf \u003d new byte[65535];\n            int len \u003d 0;\n            while ((len \u003d in.read(buf)) !\u003d -1) {\n              out.write(buf, 0, len);\n            }\n          } finally {\n            in.close();\n          }\n        }\n      }\n    }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AggregatedLogFormat.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AggregatedLogFormat.java",
        "newPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AggregatedLogFormat.java"
      }
    },
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-279. MapReduce 2.0. Merging MR-279 branch into trunk. Contributed by Arun C Murthy, Christopher Douglas, Devaraj Das, Greg Roelofs, Jeffrey Naisbitt, Josh Wills, Jonathan Eagles, Krishna Ramachandran, Luke Lu, Mahadev Konar, Robert Evans, Sharad Agarwal, Siddharth Seth, Thomas Graves, and Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159166 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/08/11 4:07 AM",
      "commitName": "dbecbe5dfe50f834fc3b8401709079e9470cc517",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,35 @@\n+    public void write(DataOutputStream out) throws IOException {\n+      for (String rootLogDir : this.rootLogDirs) {\n+        File appLogDir \u003d\n+            new File(rootLogDir, ConverterUtils.toString(this.containerId\n+                .getAppId()));\n+        File containerLogDir \u003d\n+            new File(appLogDir, ConverterUtils.toString(this.containerId));\n+\n+        if (!containerLogDir.isDirectory()) {\n+          continue; // ContainerDir may have been deleted by the user.\n+        }\n+\n+        for (File logFile : containerLogDir.listFiles()) {\n+\n+          // Write the logFile Type\n+          out.writeUTF(logFile.getName());\n+\n+          // Write the log length as UTF so that it is printable\n+          out.writeUTF(String.valueOf(logFile.length()));\n+\n+          // Write the log itself\n+          FileInputStream in \u003d null;\n+          try {\n+            in \u003d new FileInputStream(logFile);\n+            byte[] buf \u003d new byte[65535];\n+            int len \u003d 0;\n+            while ((len \u003d in.read(buf)) !\u003d -1) {\n+              out.write(buf, 0, len);\n+            }\n+          } finally {\n+            in.close();\n+          }\n+        }\n+      }\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    public void write(DataOutputStream out) throws IOException {\n      for (String rootLogDir : this.rootLogDirs) {\n        File appLogDir \u003d\n            new File(rootLogDir, ConverterUtils.toString(this.containerId\n                .getAppId()));\n        File containerLogDir \u003d\n            new File(appLogDir, ConverterUtils.toString(this.containerId));\n\n        if (!containerLogDir.isDirectory()) {\n          continue; // ContainerDir may have been deleted by the user.\n        }\n\n        for (File logFile : containerLogDir.listFiles()) {\n\n          // Write the logFile Type\n          out.writeUTF(logFile.getName());\n\n          // Write the log length as UTF so that it is printable\n          out.writeUTF(String.valueOf(logFile.length()));\n\n          // Write the log itself\n          FileInputStream in \u003d null;\n          try {\n            in \u003d new FileInputStream(logFile);\n            byte[] buf \u003d new byte[65535];\n            int len \u003d 0;\n            while ((len \u003d in.read(buf)) !\u003d -1) {\n              out.write(buf, 0, len);\n            }\n          } finally {\n            in.close();\n          }\n        }\n      }\n    }",
      "path": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/logaggregation/AggregatedLogFormat.java"
    }
  }
}