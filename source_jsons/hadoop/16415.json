{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "RouterClientProtocol.java",
  "functionName": "getMountPointStatus",
  "functionId": "getMountPointStatus___name-String__childrenNum-int__date-long",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/RouterClientProtocol.java",
  "functionStartLine": 1977,
  "functionEndLine": 2041,
  "numCommitsSeen": 64,
  "timeTaken": 5341,
  "changeHistory": [
    "4a76ab777fdd2b72c438c73d45ffbe2f6bb8bb0d",
    "d2225c8ca8f9bdc5cef7266697518394d8763c88",
    "f9029c4070e8eb046b403f5cb6d0a132c5d58448",
    "6c42d4050461ab71c88f123569649793dc53aebd",
    "b320caecb32e0eb739ad925a4646bef1a85caebd",
    "b3fee1d2bfe5d289b8f279071589f21ace99e04c",
    "6425ed27ea638da75f656204d6df4adad1d91fe1",
    "fb5b3dce6192265bce9b9d93ab663bdc5be8048e"
  ],
  "changeHistoryShort": {
    "4a76ab777fdd2b72c438c73d45ffbe2f6bb8bb0d": "Ybodychange",
    "d2225c8ca8f9bdc5cef7266697518394d8763c88": "Ybodychange",
    "f9029c4070e8eb046b403f5cb6d0a132c5d58448": "Ybodychange",
    "6c42d4050461ab71c88f123569649793dc53aebd": "Ybodychange",
    "b320caecb32e0eb739ad925a4646bef1a85caebd": "Ybodychange",
    "b3fee1d2bfe5d289b8f279071589f21ace99e04c": "Ybodychange",
    "6425ed27ea638da75f656204d6df4adad1d91fe1": "Ymultichange(Ymovefromfile,Ybodychange)",
    "fb5b3dce6192265bce9b9d93ab663bdc5be8048e": "Yintroduced"
  },
  "changeHistoryDetails": {
    "4a76ab777fdd2b72c438c73d45ffbe2f6bb8bb0d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-15090. RBF: MountPoint Listing Should Return Flag Values Of Destination. Contributed by Ayush Saxena.\n",
      "commitDate": "06/01/20 1:09 AM",
      "commitName": "4a76ab777fdd2b72c438c73d45ffbe2f6bb8bb0d",
      "commitAuthor": "Takanobu Asanuma",
      "commitDateOld": "13/12/19 10:51 AM",
      "commitNameOld": "7fe924b1c03a2fa45188027bdc0a36cb6c8b4ba4",
      "commitAuthorOld": "Inigo Goiri",
      "daysBetweenCommits": 23.6,
      "commitsBetweenForRepo": 52,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,59 +1,65 @@\n   private HdfsFileStatus getMountPointStatus(\n       String name, int childrenNum, long date) {\n     long modTime \u003d date;\n     long accessTime \u003d date;\n     FsPermission permission \u003d FsPermission.getDirDefault();\n     String owner \u003d this.superUser;\n     String group \u003d this.superGroup;\n+    EnumSet\u003cHdfsFileStatus.Flags\u003e flags \u003d\n+        EnumSet.noneOf(HdfsFileStatus.Flags.class);\n     if (subclusterResolver instanceof MountTableResolver) {\n       try {\n         String mName \u003d name.startsWith(\"/\") ? name : \"/\" + name;\n         MountTableResolver mountTable \u003d (MountTableResolver) subclusterResolver;\n         MountTable entry \u003d mountTable.getMountPoint(mName);\n         if (entry !\u003d null) {\n           permission \u003d entry.getMode();\n           owner \u003d entry.getOwnerName();\n           group \u003d entry.getGroupName();\n \n           RemoteMethod method \u003d new RemoteMethod(\"getFileInfo\",\n               new Class\u003c?\u003e[] {String.class}, new RemoteParam());\n           HdfsFileStatus fInfo \u003d getFileInfoAll(\n               entry.getDestinations(), method, mountStatusTimeOut);\n           if (fInfo !\u003d null) {\n             permission \u003d fInfo.getPermission();\n             owner \u003d fInfo.getOwner();\n             group \u003d fInfo.getGroup();\n             childrenNum \u003d fInfo.getChildrenNum();\n+            flags \u003d DFSUtil\n+                .getFlags(fInfo.isEncrypted(), fInfo.isErasureCoded(),\n+                    fInfo.isSnapshotEnabled(), fInfo.hasAcl());\n           }\n         }\n       } catch (IOException e) {\n         LOG.error(\"Cannot get mount point: {}\", e.getMessage());\n       }\n     } else {\n       try {\n         UserGroupInformation ugi \u003d RouterRpcServer.getRemoteUser();\n         owner \u003d ugi.getUserName();\n         group \u003d ugi.getPrimaryGroupName();\n       } catch (IOException e) {\n         String msg \u003d \"Cannot get remote user: \" + e.getMessage();\n         if (UserGroupInformation.isSecurityEnabled()) {\n           LOG.error(msg);\n         } else {\n           LOG.debug(msg);\n         }\n       }\n     }\n     long inodeId \u003d 0;\n     return new HdfsFileStatus.Builder()\n         .isdir(true)\n         .mtime(modTime)\n         .atime(accessTime)\n         .perm(permission)\n         .owner(owner)\n         .group(group)\n         .symlink(new byte[0])\n         .path(DFSUtil.string2Bytes(name))\n         .fileId(inodeId)\n         .children(childrenNum)\n+        .flags(flags)\n         .build();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private HdfsFileStatus getMountPointStatus(\n      String name, int childrenNum, long date) {\n    long modTime \u003d date;\n    long accessTime \u003d date;\n    FsPermission permission \u003d FsPermission.getDirDefault();\n    String owner \u003d this.superUser;\n    String group \u003d this.superGroup;\n    EnumSet\u003cHdfsFileStatus.Flags\u003e flags \u003d\n        EnumSet.noneOf(HdfsFileStatus.Flags.class);\n    if (subclusterResolver instanceof MountTableResolver) {\n      try {\n        String mName \u003d name.startsWith(\"/\") ? name : \"/\" + name;\n        MountTableResolver mountTable \u003d (MountTableResolver) subclusterResolver;\n        MountTable entry \u003d mountTable.getMountPoint(mName);\n        if (entry !\u003d null) {\n          permission \u003d entry.getMode();\n          owner \u003d entry.getOwnerName();\n          group \u003d entry.getGroupName();\n\n          RemoteMethod method \u003d new RemoteMethod(\"getFileInfo\",\n              new Class\u003c?\u003e[] {String.class}, new RemoteParam());\n          HdfsFileStatus fInfo \u003d getFileInfoAll(\n              entry.getDestinations(), method, mountStatusTimeOut);\n          if (fInfo !\u003d null) {\n            permission \u003d fInfo.getPermission();\n            owner \u003d fInfo.getOwner();\n            group \u003d fInfo.getGroup();\n            childrenNum \u003d fInfo.getChildrenNum();\n            flags \u003d DFSUtil\n                .getFlags(fInfo.isEncrypted(), fInfo.isErasureCoded(),\n                    fInfo.isSnapshotEnabled(), fInfo.hasAcl());\n          }\n        }\n      } catch (IOException e) {\n        LOG.error(\"Cannot get mount point: {}\", e.getMessage());\n      }\n    } else {\n      try {\n        UserGroupInformation ugi \u003d RouterRpcServer.getRemoteUser();\n        owner \u003d ugi.getUserName();\n        group \u003d ugi.getPrimaryGroupName();\n      } catch (IOException e) {\n        String msg \u003d \"Cannot get remote user: \" + e.getMessage();\n        if (UserGroupInformation.isSecurityEnabled()) {\n          LOG.error(msg);\n        } else {\n          LOG.debug(msg);\n        }\n      }\n    }\n    long inodeId \u003d 0;\n    return new HdfsFileStatus.Builder()\n        .isdir(true)\n        .mtime(modTime)\n        .atime(accessTime)\n        .perm(permission)\n        .owner(owner)\n        .group(group)\n        .symlink(new byte[0])\n        .path(DFSUtil.string2Bytes(name))\n        .fileId(inodeId)\n        .children(childrenNum)\n        .flags(flags)\n        .build();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/RouterClientProtocol.java",
      "extendedDetails": {}
    },
    "d2225c8ca8f9bdc5cef7266697518394d8763c88": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14722. RBF: GetMountPointStatus should return mountTable information when getFileInfoAll throw IOException. Contributed by xuzq.\n",
      "commitDate": "23/08/19 8:17 PM",
      "commitName": "d2225c8ca8f9bdc5cef7266697518394d8763c88",
      "commitAuthor": "Ayush Saxena",
      "commitDateOld": "23/08/19 6:38 AM",
      "commitNameOld": "c92de8209d1c7da9e7ce607abeecb777c4a52c6a",
      "commitAuthorOld": "Ayush Saxena",
      "daysBetweenCommits": 0.57,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,59 +1,59 @@\n   private HdfsFileStatus getMountPointStatus(\n       String name, int childrenNum, long date) {\n     long modTime \u003d date;\n     long accessTime \u003d date;\n     FsPermission permission \u003d FsPermission.getDirDefault();\n     String owner \u003d this.superUser;\n     String group \u003d this.superGroup;\n     if (subclusterResolver instanceof MountTableResolver) {\n       try {\n         String mName \u003d name.startsWith(\"/\") ? name : \"/\" + name;\n         MountTableResolver mountTable \u003d (MountTableResolver) subclusterResolver;\n         MountTable entry \u003d mountTable.getMountPoint(mName);\n         if (entry !\u003d null) {\n+          permission \u003d entry.getMode();\n+          owner \u003d entry.getOwnerName();\n+          group \u003d entry.getGroupName();\n+\n           RemoteMethod method \u003d new RemoteMethod(\"getFileInfo\",\n               new Class\u003c?\u003e[] {String.class}, new RemoteParam());\n           HdfsFileStatus fInfo \u003d getFileInfoAll(\n               entry.getDestinations(), method, mountStatusTimeOut);\n           if (fInfo !\u003d null) {\n             permission \u003d fInfo.getPermission();\n             owner \u003d fInfo.getOwner();\n             group \u003d fInfo.getGroup();\n             childrenNum \u003d fInfo.getChildrenNum();\n-          } else {\n-            permission \u003d entry.getMode();\n-            owner \u003d entry.getOwnerName();\n-            group \u003d entry.getGroupName();\n           }\n         }\n       } catch (IOException e) {\n         LOG.error(\"Cannot get mount point: {}\", e.getMessage());\n       }\n     } else {\n       try {\n         UserGroupInformation ugi \u003d RouterRpcServer.getRemoteUser();\n         owner \u003d ugi.getUserName();\n         group \u003d ugi.getPrimaryGroupName();\n       } catch (IOException e) {\n         String msg \u003d \"Cannot get remote user: \" + e.getMessage();\n         if (UserGroupInformation.isSecurityEnabled()) {\n           LOG.error(msg);\n         } else {\n           LOG.debug(msg);\n         }\n       }\n     }\n     long inodeId \u003d 0;\n     return new HdfsFileStatus.Builder()\n         .isdir(true)\n         .mtime(modTime)\n         .atime(accessTime)\n         .perm(permission)\n         .owner(owner)\n         .group(group)\n         .symlink(new byte[0])\n         .path(DFSUtil.string2Bytes(name))\n         .fileId(inodeId)\n         .children(childrenNum)\n         .build();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private HdfsFileStatus getMountPointStatus(\n      String name, int childrenNum, long date) {\n    long modTime \u003d date;\n    long accessTime \u003d date;\n    FsPermission permission \u003d FsPermission.getDirDefault();\n    String owner \u003d this.superUser;\n    String group \u003d this.superGroup;\n    if (subclusterResolver instanceof MountTableResolver) {\n      try {\n        String mName \u003d name.startsWith(\"/\") ? name : \"/\" + name;\n        MountTableResolver mountTable \u003d (MountTableResolver) subclusterResolver;\n        MountTable entry \u003d mountTable.getMountPoint(mName);\n        if (entry !\u003d null) {\n          permission \u003d entry.getMode();\n          owner \u003d entry.getOwnerName();\n          group \u003d entry.getGroupName();\n\n          RemoteMethod method \u003d new RemoteMethod(\"getFileInfo\",\n              new Class\u003c?\u003e[] {String.class}, new RemoteParam());\n          HdfsFileStatus fInfo \u003d getFileInfoAll(\n              entry.getDestinations(), method, mountStatusTimeOut);\n          if (fInfo !\u003d null) {\n            permission \u003d fInfo.getPermission();\n            owner \u003d fInfo.getOwner();\n            group \u003d fInfo.getGroup();\n            childrenNum \u003d fInfo.getChildrenNum();\n          }\n        }\n      } catch (IOException e) {\n        LOG.error(\"Cannot get mount point: {}\", e.getMessage());\n      }\n    } else {\n      try {\n        UserGroupInformation ugi \u003d RouterRpcServer.getRemoteUser();\n        owner \u003d ugi.getUserName();\n        group \u003d ugi.getPrimaryGroupName();\n      } catch (IOException e) {\n        String msg \u003d \"Cannot get remote user: \" + e.getMessage();\n        if (UserGroupInformation.isSecurityEnabled()) {\n          LOG.error(msg);\n        } else {\n          LOG.debug(msg);\n        }\n      }\n    }\n    long inodeId \u003d 0;\n    return new HdfsFileStatus.Builder()\n        .isdir(true)\n        .mtime(modTime)\n        .atime(accessTime)\n        .perm(permission)\n        .owner(owner)\n        .group(group)\n        .symlink(new byte[0])\n        .path(DFSUtil.string2Bytes(name))\n        .fileId(inodeId)\n        .children(childrenNum)\n        .build();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/RouterClientProtocol.java",
      "extendedDetails": {}
    },
    "f9029c4070e8eb046b403f5cb6d0a132c5d58448": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14744. RBF: Non secured routers should not log in error mode when UGI is default. Contributed by CR Hota.\n",
      "commitDate": "21/08/19 2:10 PM",
      "commitName": "f9029c4070e8eb046b403f5cb6d0a132c5d58448",
      "commitAuthor": "Ayush Saxena",
      "commitDateOld": "21/08/19 9:38 AM",
      "commitNameOld": "5eeb6da2d44335a27dc79e59e6ca561247b46a31",
      "commitAuthorOld": "Inigo Goiri",
      "daysBetweenCommits": 0.19,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,59 @@\n   private HdfsFileStatus getMountPointStatus(\n       String name, int childrenNum, long date) {\n     long modTime \u003d date;\n     long accessTime \u003d date;\n     FsPermission permission \u003d FsPermission.getDirDefault();\n     String owner \u003d this.superUser;\n     String group \u003d this.superGroup;\n     if (subclusterResolver instanceof MountTableResolver) {\n       try {\n         String mName \u003d name.startsWith(\"/\") ? name : \"/\" + name;\n         MountTableResolver mountTable \u003d (MountTableResolver) subclusterResolver;\n         MountTable entry \u003d mountTable.getMountPoint(mName);\n         if (entry !\u003d null) {\n           RemoteMethod method \u003d new RemoteMethod(\"getFileInfo\",\n               new Class\u003c?\u003e[] {String.class}, new RemoteParam());\n           HdfsFileStatus fInfo \u003d getFileInfoAll(\n               entry.getDestinations(), method, mountStatusTimeOut);\n           if (fInfo !\u003d null) {\n             permission \u003d fInfo.getPermission();\n             owner \u003d fInfo.getOwner();\n             group \u003d fInfo.getGroup();\n             childrenNum \u003d fInfo.getChildrenNum();\n           } else {\n             permission \u003d entry.getMode();\n             owner \u003d entry.getOwnerName();\n             group \u003d entry.getGroupName();\n           }\n         }\n       } catch (IOException e) {\n         LOG.error(\"Cannot get mount point: {}\", e.getMessage());\n       }\n     } else {\n       try {\n         UserGroupInformation ugi \u003d RouterRpcServer.getRemoteUser();\n         owner \u003d ugi.getUserName();\n         group \u003d ugi.getPrimaryGroupName();\n       } catch (IOException e) {\n-        LOG.error(\"Cannot get remote user: {}\", e.getMessage());\n+        String msg \u003d \"Cannot get remote user: \" + e.getMessage();\n+        if (UserGroupInformation.isSecurityEnabled()) {\n+          LOG.error(msg);\n+        } else {\n+          LOG.debug(msg);\n+        }\n       }\n     }\n     long inodeId \u003d 0;\n     return new HdfsFileStatus.Builder()\n         .isdir(true)\n         .mtime(modTime)\n         .atime(accessTime)\n         .perm(permission)\n         .owner(owner)\n         .group(group)\n         .symlink(new byte[0])\n         .path(DFSUtil.string2Bytes(name))\n         .fileId(inodeId)\n         .children(childrenNum)\n         .build();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private HdfsFileStatus getMountPointStatus(\n      String name, int childrenNum, long date) {\n    long modTime \u003d date;\n    long accessTime \u003d date;\n    FsPermission permission \u003d FsPermission.getDirDefault();\n    String owner \u003d this.superUser;\n    String group \u003d this.superGroup;\n    if (subclusterResolver instanceof MountTableResolver) {\n      try {\n        String mName \u003d name.startsWith(\"/\") ? name : \"/\" + name;\n        MountTableResolver mountTable \u003d (MountTableResolver) subclusterResolver;\n        MountTable entry \u003d mountTable.getMountPoint(mName);\n        if (entry !\u003d null) {\n          RemoteMethod method \u003d new RemoteMethod(\"getFileInfo\",\n              new Class\u003c?\u003e[] {String.class}, new RemoteParam());\n          HdfsFileStatus fInfo \u003d getFileInfoAll(\n              entry.getDestinations(), method, mountStatusTimeOut);\n          if (fInfo !\u003d null) {\n            permission \u003d fInfo.getPermission();\n            owner \u003d fInfo.getOwner();\n            group \u003d fInfo.getGroup();\n            childrenNum \u003d fInfo.getChildrenNum();\n          } else {\n            permission \u003d entry.getMode();\n            owner \u003d entry.getOwnerName();\n            group \u003d entry.getGroupName();\n          }\n        }\n      } catch (IOException e) {\n        LOG.error(\"Cannot get mount point: {}\", e.getMessage());\n      }\n    } else {\n      try {\n        UserGroupInformation ugi \u003d RouterRpcServer.getRemoteUser();\n        owner \u003d ugi.getUserName();\n        group \u003d ugi.getPrimaryGroupName();\n      } catch (IOException e) {\n        String msg \u003d \"Cannot get remote user: \" + e.getMessage();\n        if (UserGroupInformation.isSecurityEnabled()) {\n          LOG.error(msg);\n        } else {\n          LOG.debug(msg);\n        }\n      }\n    }\n    long inodeId \u003d 0;\n    return new HdfsFileStatus.Builder()\n        .isdir(true)\n        .mtime(modTime)\n        .atime(accessTime)\n        .perm(permission)\n        .owner(owner)\n        .group(group)\n        .symlink(new byte[0])\n        .path(DFSUtil.string2Bytes(name))\n        .fileId(inodeId)\n        .children(childrenNum)\n        .build();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/RouterClientProtocol.java",
      "extendedDetails": {}
    },
    "6c42d4050461ab71c88f123569649793dc53aebd": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14316. RBF: Support unavailable subclusters for mount points with multiple destinations. Contributed by Inigo Goiri.\n",
      "commitDate": "24/06/19 9:33 AM",
      "commitName": "6c42d4050461ab71c88f123569649793dc53aebd",
      "commitAuthor": "Ayush Saxena",
      "commitDateOld": "24/06/19 9:33 AM",
      "commitNameOld": "f539e2a4ee93c4ee479fe25e8062c8ab4c7f8ba8",
      "commitAuthorOld": "Giovanni Matteo Fumarola",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,54 @@\n   private HdfsFileStatus getMountPointStatus(\n       String name, int childrenNum, long date) {\n     long modTime \u003d date;\n     long accessTime \u003d date;\n     FsPermission permission \u003d FsPermission.getDirDefault();\n     String owner \u003d this.superUser;\n     String group \u003d this.superGroup;\n     if (subclusterResolver instanceof MountTableResolver) {\n       try {\n         String mName \u003d name.startsWith(\"/\") ? name : \"/\" + name;\n         MountTableResolver mountTable \u003d (MountTableResolver) subclusterResolver;\n         MountTable entry \u003d mountTable.getMountPoint(mName);\n         if (entry !\u003d null) {\n-          HdfsFileStatus fInfo \u003d getFileInfoAll(entry.getDestinations(),\n-              new RemoteMethod(\"getFileInfo\", new Class\u003c?\u003e[] {String.class},\n-                  new RemoteParam()));\n+          RemoteMethod method \u003d new RemoteMethod(\"getFileInfo\",\n+              new Class\u003c?\u003e[] {String.class}, new RemoteParam());\n+          HdfsFileStatus fInfo \u003d getFileInfoAll(\n+              entry.getDestinations(), method, mountStatusTimeOut);\n           if (fInfo !\u003d null) {\n             permission \u003d fInfo.getPermission();\n             owner \u003d fInfo.getOwner();\n             group \u003d fInfo.getGroup();\n             childrenNum \u003d fInfo.getChildrenNum();\n           } else {\n             permission \u003d entry.getMode();\n             owner \u003d entry.getOwnerName();\n             group \u003d entry.getGroupName();\n           }\n         }\n       } catch (IOException e) {\n         LOG.error(\"Cannot get mount point: {}\", e.getMessage());\n       }\n     } else {\n       try {\n         UserGroupInformation ugi \u003d RouterRpcServer.getRemoteUser();\n         owner \u003d ugi.getUserName();\n         group \u003d ugi.getPrimaryGroupName();\n       } catch (IOException e) {\n         LOG.error(\"Cannot get remote user: {}\", e.getMessage());\n       }\n     }\n     long inodeId \u003d 0;\n     return new HdfsFileStatus.Builder()\n         .isdir(true)\n         .mtime(modTime)\n         .atime(accessTime)\n         .perm(permission)\n         .owner(owner)\n         .group(group)\n         .symlink(new byte[0])\n         .path(DFSUtil.string2Bytes(name))\n         .fileId(inodeId)\n         .children(childrenNum)\n         .build();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private HdfsFileStatus getMountPointStatus(\n      String name, int childrenNum, long date) {\n    long modTime \u003d date;\n    long accessTime \u003d date;\n    FsPermission permission \u003d FsPermission.getDirDefault();\n    String owner \u003d this.superUser;\n    String group \u003d this.superGroup;\n    if (subclusterResolver instanceof MountTableResolver) {\n      try {\n        String mName \u003d name.startsWith(\"/\") ? name : \"/\" + name;\n        MountTableResolver mountTable \u003d (MountTableResolver) subclusterResolver;\n        MountTable entry \u003d mountTable.getMountPoint(mName);\n        if (entry !\u003d null) {\n          RemoteMethod method \u003d new RemoteMethod(\"getFileInfo\",\n              new Class\u003c?\u003e[] {String.class}, new RemoteParam());\n          HdfsFileStatus fInfo \u003d getFileInfoAll(\n              entry.getDestinations(), method, mountStatusTimeOut);\n          if (fInfo !\u003d null) {\n            permission \u003d fInfo.getPermission();\n            owner \u003d fInfo.getOwner();\n            group \u003d fInfo.getGroup();\n            childrenNum \u003d fInfo.getChildrenNum();\n          } else {\n            permission \u003d entry.getMode();\n            owner \u003d entry.getOwnerName();\n            group \u003d entry.getGroupName();\n          }\n        }\n      } catch (IOException e) {\n        LOG.error(\"Cannot get mount point: {}\", e.getMessage());\n      }\n    } else {\n      try {\n        UserGroupInformation ugi \u003d RouterRpcServer.getRemoteUser();\n        owner \u003d ugi.getUserName();\n        group \u003d ugi.getPrimaryGroupName();\n      } catch (IOException e) {\n        LOG.error(\"Cannot get remote user: {}\", e.getMessage());\n      }\n    }\n    long inodeId \u003d 0;\n    return new HdfsFileStatus.Builder()\n        .isdir(true)\n        .mtime(modTime)\n        .atime(accessTime)\n        .perm(permission)\n        .owner(owner)\n        .group(group)\n        .symlink(new byte[0])\n        .path(DFSUtil.string2Bytes(name))\n        .fileId(inodeId)\n        .children(childrenNum)\n        .build();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/RouterClientProtocol.java",
      "extendedDetails": {}
    },
    "b320caecb32e0eb739ad925a4646bef1a85caebd": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14085. RBF: LS command for root shows wrong owner and permission information. Contributed by Ayush Saxena.\n",
      "commitDate": "24/06/19 9:33 AM",
      "commitName": "b320caecb32e0eb739ad925a4646bef1a85caebd",
      "commitAuthor": "Surendra Singh Lilhore",
      "commitDateOld": "24/06/19 9:33 AM",
      "commitNameOld": "f2355c706361594b7b2ef8b65b37060eab1d66df",
      "commitAuthorOld": "Brahma Reddy Battula",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,53 @@\n   private HdfsFileStatus getMountPointStatus(\n       String name, int childrenNum, long date) {\n     long modTime \u003d date;\n     long accessTime \u003d date;\n     FsPermission permission \u003d FsPermission.getDirDefault();\n     String owner \u003d this.superUser;\n     String group \u003d this.superGroup;\n     if (subclusterResolver instanceof MountTableResolver) {\n       try {\n+        String mName \u003d name.startsWith(\"/\") ? name : \"/\" + name;\n         MountTableResolver mountTable \u003d (MountTableResolver) subclusterResolver;\n-        MountTable entry \u003d mountTable.getMountPoint(name);\n+        MountTable entry \u003d mountTable.getMountPoint(mName);\n         if (entry !\u003d null) {\n-          permission \u003d entry.getMode();\n-          owner \u003d entry.getOwnerName();\n-          group \u003d entry.getGroupName();\n+          HdfsFileStatus fInfo \u003d getFileInfoAll(entry.getDestinations(),\n+              new RemoteMethod(\"getFileInfo\", new Class\u003c?\u003e[] {String.class},\n+                  new RemoteParam()));\n+          if (fInfo !\u003d null) {\n+            permission \u003d fInfo.getPermission();\n+            owner \u003d fInfo.getOwner();\n+            group \u003d fInfo.getGroup();\n+            childrenNum \u003d fInfo.getChildrenNum();\n+          } else {\n+            permission \u003d entry.getMode();\n+            owner \u003d entry.getOwnerName();\n+            group \u003d entry.getGroupName();\n+          }\n         }\n       } catch (IOException e) {\n         LOG.error(\"Cannot get mount point: {}\", e.getMessage());\n       }\n     } else {\n       try {\n         UserGroupInformation ugi \u003d RouterRpcServer.getRemoteUser();\n         owner \u003d ugi.getUserName();\n         group \u003d ugi.getPrimaryGroupName();\n       } catch (IOException e) {\n         LOG.error(\"Cannot get remote user: {}\", e.getMessage());\n       }\n     }\n     long inodeId \u003d 0;\n     return new HdfsFileStatus.Builder()\n         .isdir(true)\n         .mtime(modTime)\n         .atime(accessTime)\n         .perm(permission)\n         .owner(owner)\n         .group(group)\n         .symlink(new byte[0])\n         .path(DFSUtil.string2Bytes(name))\n         .fileId(inodeId)\n         .children(childrenNum)\n         .build();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private HdfsFileStatus getMountPointStatus(\n      String name, int childrenNum, long date) {\n    long modTime \u003d date;\n    long accessTime \u003d date;\n    FsPermission permission \u003d FsPermission.getDirDefault();\n    String owner \u003d this.superUser;\n    String group \u003d this.superGroup;\n    if (subclusterResolver instanceof MountTableResolver) {\n      try {\n        String mName \u003d name.startsWith(\"/\") ? name : \"/\" + name;\n        MountTableResolver mountTable \u003d (MountTableResolver) subclusterResolver;\n        MountTable entry \u003d mountTable.getMountPoint(mName);\n        if (entry !\u003d null) {\n          HdfsFileStatus fInfo \u003d getFileInfoAll(entry.getDestinations(),\n              new RemoteMethod(\"getFileInfo\", new Class\u003c?\u003e[] {String.class},\n                  new RemoteParam()));\n          if (fInfo !\u003d null) {\n            permission \u003d fInfo.getPermission();\n            owner \u003d fInfo.getOwner();\n            group \u003d fInfo.getGroup();\n            childrenNum \u003d fInfo.getChildrenNum();\n          } else {\n            permission \u003d entry.getMode();\n            owner \u003d entry.getOwnerName();\n            group \u003d entry.getGroupName();\n          }\n        }\n      } catch (IOException e) {\n        LOG.error(\"Cannot get mount point: {}\", e.getMessage());\n      }\n    } else {\n      try {\n        UserGroupInformation ugi \u003d RouterRpcServer.getRemoteUser();\n        owner \u003d ugi.getUserName();\n        group \u003d ugi.getPrimaryGroupName();\n      } catch (IOException e) {\n        LOG.error(\"Cannot get remote user: {}\", e.getMessage());\n      }\n    }\n    long inodeId \u003d 0;\n    return new HdfsFileStatus.Builder()\n        .isdir(true)\n        .mtime(modTime)\n        .atime(accessTime)\n        .perm(permission)\n        .owner(owner)\n        .group(group)\n        .symlink(new byte[0])\n        .path(DFSUtil.string2Bytes(name))\n        .fileId(inodeId)\n        .children(childrenNum)\n        .build();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/RouterClientProtocol.java",
      "extendedDetails": {}
    },
    "b3fee1d2bfe5d289b8f279071589f21ace99e04c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14011. RBF: Add more information to HdfsFileStatus for a mount point. Contributed by Akira Ajisaka.\n",
      "commitDate": "24/06/19 9:33 AM",
      "commitName": "b3fee1d2bfe5d289b8f279071589f21ace99e04c",
      "commitAuthor": "Yiqun Lin",
      "commitDateOld": "20/03/19 11:20 AM",
      "commitNameOld": "399563fec607a8c2ddc5d1a46b94a60389bef68c",
      "commitAuthorOld": "Ajay Kumar",
      "daysBetweenCommits": 95.93,
      "commitsBetweenForRepo": 613,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,42 @@\n   private HdfsFileStatus getMountPointStatus(\n       String name, int childrenNum, long date) {\n     long modTime \u003d date;\n     long accessTime \u003d date;\n     FsPermission permission \u003d FsPermission.getDirDefault();\n     String owner \u003d this.superUser;\n     String group \u003d this.superGroup;\n-    try {\n-      // TODO support users, it should be the user for the pointed folder\n-      UserGroupInformation ugi \u003d RouterRpcServer.getRemoteUser();\n-      owner \u003d ugi.getUserName();\n-      group \u003d ugi.getPrimaryGroupName();\n-    } catch (IOException e) {\n-      LOG.error(\"Cannot get the remote user: {}\", e.getMessage());\n+    if (subclusterResolver instanceof MountTableResolver) {\n+      try {\n+        MountTableResolver mountTable \u003d (MountTableResolver) subclusterResolver;\n+        MountTable entry \u003d mountTable.getMountPoint(name);\n+        if (entry !\u003d null) {\n+          permission \u003d entry.getMode();\n+          owner \u003d entry.getOwnerName();\n+          group \u003d entry.getGroupName();\n+        }\n+      } catch (IOException e) {\n+        LOG.error(\"Cannot get mount point: {}\", e.getMessage());\n+      }\n+    } else {\n+      try {\n+        UserGroupInformation ugi \u003d RouterRpcServer.getRemoteUser();\n+        owner \u003d ugi.getUserName();\n+        group \u003d ugi.getPrimaryGroupName();\n+      } catch (IOException e) {\n+        LOG.error(\"Cannot get remote user: {}\", e.getMessage());\n+      }\n     }\n     long inodeId \u003d 0;\n     return new HdfsFileStatus.Builder()\n         .isdir(true)\n         .mtime(modTime)\n         .atime(accessTime)\n         .perm(permission)\n         .owner(owner)\n         .group(group)\n         .symlink(new byte[0])\n         .path(DFSUtil.string2Bytes(name))\n         .fileId(inodeId)\n         .children(childrenNum)\n         .build();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private HdfsFileStatus getMountPointStatus(\n      String name, int childrenNum, long date) {\n    long modTime \u003d date;\n    long accessTime \u003d date;\n    FsPermission permission \u003d FsPermission.getDirDefault();\n    String owner \u003d this.superUser;\n    String group \u003d this.superGroup;\n    if (subclusterResolver instanceof MountTableResolver) {\n      try {\n        MountTableResolver mountTable \u003d (MountTableResolver) subclusterResolver;\n        MountTable entry \u003d mountTable.getMountPoint(name);\n        if (entry !\u003d null) {\n          permission \u003d entry.getMode();\n          owner \u003d entry.getOwnerName();\n          group \u003d entry.getGroupName();\n        }\n      } catch (IOException e) {\n        LOG.error(\"Cannot get mount point: {}\", e.getMessage());\n      }\n    } else {\n      try {\n        UserGroupInformation ugi \u003d RouterRpcServer.getRemoteUser();\n        owner \u003d ugi.getUserName();\n        group \u003d ugi.getPrimaryGroupName();\n      } catch (IOException e) {\n        LOG.error(\"Cannot get remote user: {}\", e.getMessage());\n      }\n    }\n    long inodeId \u003d 0;\n    return new HdfsFileStatus.Builder()\n        .isdir(true)\n        .mtime(modTime)\n        .atime(accessTime)\n        .perm(permission)\n        .owner(owner)\n        .group(group)\n        .symlink(new byte[0])\n        .path(DFSUtil.string2Bytes(name))\n        .fileId(inodeId)\n        .children(childrenNum)\n        .build();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/RouterClientProtocol.java",
      "extendedDetails": {}
    },
    "6425ed27ea638da75f656204d6df4adad1d91fe1": {
      "type": "Ymultichange(Ymovefromfile,Ybodychange)",
      "commitMessage": "HDFS-13790. RBF: Move ClientProtocol APIs to its own module. Contributed by Chao Sun.\n",
      "commitDate": "19/08/18 11:50 PM",
      "commitName": "6425ed27ea638da75f656204d6df4adad1d91fe1",
      "commitAuthor": "Brahma Reddy Battula",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "HDFS-13790. RBF: Move ClientProtocol APIs to its own module. Contributed by Chao Sun.\n",
          "commitDate": "19/08/18 11:50 PM",
          "commitName": "6425ed27ea638da75f656204d6df4adad1d91fe1",
          "commitAuthor": "Brahma Reddy Battula",
          "commitDateOld": "17/08/18 9:56 PM",
          "commitNameOld": "4aacbfff605262aaf3dbd926258afcadc86c72c0",
          "commitAuthorOld": "Rohith Sharma K S",
          "daysBetweenCommits": 2.08,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,29 +1,29 @@\n   private HdfsFileStatus getMountPointStatus(\n       String name, int childrenNum, long date) {\n     long modTime \u003d date;\n     long accessTime \u003d date;\n     FsPermission permission \u003d FsPermission.getDirDefault();\n     String owner \u003d this.superUser;\n     String group \u003d this.superGroup;\n     try {\n       // TODO support users, it should be the user for the pointed folder\n-      UserGroupInformation ugi \u003d getRemoteUser();\n+      UserGroupInformation ugi \u003d RouterRpcServer.getRemoteUser();\n       owner \u003d ugi.getUserName();\n       group \u003d ugi.getPrimaryGroupName();\n     } catch (IOException e) {\n       LOG.error(\"Cannot get the remote user: {}\", e.getMessage());\n     }\n     long inodeId \u003d 0;\n     return new HdfsFileStatus.Builder()\n-      .isdir(true)\n-      .mtime(modTime)\n-      .atime(accessTime)\n-      .perm(permission)\n-      .owner(owner)\n-      .group(group)\n-      .symlink(new byte[0])\n-      .path(DFSUtil.string2Bytes(name))\n-      .fileId(inodeId)\n-      .children(childrenNum)\n-      .build();\n+        .isdir(true)\n+        .mtime(modTime)\n+        .atime(accessTime)\n+        .perm(permission)\n+        .owner(owner)\n+        .group(group)\n+        .symlink(new byte[0])\n+        .path(DFSUtil.string2Bytes(name))\n+        .fileId(inodeId)\n+        .children(childrenNum)\n+        .build();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private HdfsFileStatus getMountPointStatus(\n      String name, int childrenNum, long date) {\n    long modTime \u003d date;\n    long accessTime \u003d date;\n    FsPermission permission \u003d FsPermission.getDirDefault();\n    String owner \u003d this.superUser;\n    String group \u003d this.superGroup;\n    try {\n      // TODO support users, it should be the user for the pointed folder\n      UserGroupInformation ugi \u003d RouterRpcServer.getRemoteUser();\n      owner \u003d ugi.getUserName();\n      group \u003d ugi.getPrimaryGroupName();\n    } catch (IOException e) {\n      LOG.error(\"Cannot get the remote user: {}\", e.getMessage());\n    }\n    long inodeId \u003d 0;\n    return new HdfsFileStatus.Builder()\n        .isdir(true)\n        .mtime(modTime)\n        .atime(accessTime)\n        .perm(permission)\n        .owner(owner)\n        .group(group)\n        .symlink(new byte[0])\n        .path(DFSUtil.string2Bytes(name))\n        .fileId(inodeId)\n        .children(childrenNum)\n        .build();\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/RouterClientProtocol.java",
          "extendedDetails": {
            "oldPath": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/RouterRpcServer.java",
            "newPath": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/RouterClientProtocol.java",
            "oldMethodName": "getMountPointStatus",
            "newMethodName": "getMountPointStatus"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-13790. RBF: Move ClientProtocol APIs to its own module. Contributed by Chao Sun.\n",
          "commitDate": "19/08/18 11:50 PM",
          "commitName": "6425ed27ea638da75f656204d6df4adad1d91fe1",
          "commitAuthor": "Brahma Reddy Battula",
          "commitDateOld": "17/08/18 9:56 PM",
          "commitNameOld": "4aacbfff605262aaf3dbd926258afcadc86c72c0",
          "commitAuthorOld": "Rohith Sharma K S",
          "daysBetweenCommits": 2.08,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,29 +1,29 @@\n   private HdfsFileStatus getMountPointStatus(\n       String name, int childrenNum, long date) {\n     long modTime \u003d date;\n     long accessTime \u003d date;\n     FsPermission permission \u003d FsPermission.getDirDefault();\n     String owner \u003d this.superUser;\n     String group \u003d this.superGroup;\n     try {\n       // TODO support users, it should be the user for the pointed folder\n-      UserGroupInformation ugi \u003d getRemoteUser();\n+      UserGroupInformation ugi \u003d RouterRpcServer.getRemoteUser();\n       owner \u003d ugi.getUserName();\n       group \u003d ugi.getPrimaryGroupName();\n     } catch (IOException e) {\n       LOG.error(\"Cannot get the remote user: {}\", e.getMessage());\n     }\n     long inodeId \u003d 0;\n     return new HdfsFileStatus.Builder()\n-      .isdir(true)\n-      .mtime(modTime)\n-      .atime(accessTime)\n-      .perm(permission)\n-      .owner(owner)\n-      .group(group)\n-      .symlink(new byte[0])\n-      .path(DFSUtil.string2Bytes(name))\n-      .fileId(inodeId)\n-      .children(childrenNum)\n-      .build();\n+        .isdir(true)\n+        .mtime(modTime)\n+        .atime(accessTime)\n+        .perm(permission)\n+        .owner(owner)\n+        .group(group)\n+        .symlink(new byte[0])\n+        .path(DFSUtil.string2Bytes(name))\n+        .fileId(inodeId)\n+        .children(childrenNum)\n+        .build();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private HdfsFileStatus getMountPointStatus(\n      String name, int childrenNum, long date) {\n    long modTime \u003d date;\n    long accessTime \u003d date;\n    FsPermission permission \u003d FsPermission.getDirDefault();\n    String owner \u003d this.superUser;\n    String group \u003d this.superGroup;\n    try {\n      // TODO support users, it should be the user for the pointed folder\n      UserGroupInformation ugi \u003d RouterRpcServer.getRemoteUser();\n      owner \u003d ugi.getUserName();\n      group \u003d ugi.getPrimaryGroupName();\n    } catch (IOException e) {\n      LOG.error(\"Cannot get the remote user: {}\", e.getMessage());\n    }\n    long inodeId \u003d 0;\n    return new HdfsFileStatus.Builder()\n        .isdir(true)\n        .mtime(modTime)\n        .atime(accessTime)\n        .perm(permission)\n        .owner(owner)\n        .group(group)\n        .symlink(new byte[0])\n        .path(DFSUtil.string2Bytes(name))\n        .fileId(inodeId)\n        .children(childrenNum)\n        .build();\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/RouterClientProtocol.java",
          "extendedDetails": {}
        }
      ]
    },
    "fb5b3dce6192265bce9b9d93ab663bdc5be8048e": {
      "type": "Yintroduced",
      "commitMessage": "Revert \"HDFS-13790. RBF: Move ClientProtocol APIs to its own module. Contributed by Chao Sun.\"\n\nThis reverts commit fa121eb66bc42e9cb5586f8c2e268cfdc2ed187a.\n",
      "commitDate": "17/08/18 8:01 AM",
      "commitName": "fb5b3dce6192265bce9b9d93ab663bdc5be8048e",
      "commitAuthor": "Xiaoyu Yao",
      "diff": "@@ -0,0 +1,29 @@\n+  private HdfsFileStatus getMountPointStatus(\n+      String name, int childrenNum, long date) {\n+    long modTime \u003d date;\n+    long accessTime \u003d date;\n+    FsPermission permission \u003d FsPermission.getDirDefault();\n+    String owner \u003d this.superUser;\n+    String group \u003d this.superGroup;\n+    try {\n+      // TODO support users, it should be the user for the pointed folder\n+      UserGroupInformation ugi \u003d getRemoteUser();\n+      owner \u003d ugi.getUserName();\n+      group \u003d ugi.getPrimaryGroupName();\n+    } catch (IOException e) {\n+      LOG.error(\"Cannot get the remote user: {}\", e.getMessage());\n+    }\n+    long inodeId \u003d 0;\n+    return new HdfsFileStatus.Builder()\n+      .isdir(true)\n+      .mtime(modTime)\n+      .atime(accessTime)\n+      .perm(permission)\n+      .owner(owner)\n+      .group(group)\n+      .symlink(new byte[0])\n+      .path(DFSUtil.string2Bytes(name))\n+      .fileId(inodeId)\n+      .children(childrenNum)\n+      .build();\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private HdfsFileStatus getMountPointStatus(\n      String name, int childrenNum, long date) {\n    long modTime \u003d date;\n    long accessTime \u003d date;\n    FsPermission permission \u003d FsPermission.getDirDefault();\n    String owner \u003d this.superUser;\n    String group \u003d this.superGroup;\n    try {\n      // TODO support users, it should be the user for the pointed folder\n      UserGroupInformation ugi \u003d getRemoteUser();\n      owner \u003d ugi.getUserName();\n      group \u003d ugi.getPrimaryGroupName();\n    } catch (IOException e) {\n      LOG.error(\"Cannot get the remote user: {}\", e.getMessage());\n    }\n    long inodeId \u003d 0;\n    return new HdfsFileStatus.Builder()\n      .isdir(true)\n      .mtime(modTime)\n      .atime(accessTime)\n      .perm(permission)\n      .owner(owner)\n      .group(group)\n      .symlink(new byte[0])\n      .path(DFSUtil.string2Bytes(name))\n      .fileId(inodeId)\n      .children(childrenNum)\n      .build();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/RouterRpcServer.java"
    }
  }
}