{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "RMAppImpl.java",
  "functionName": "transition",
  "functionId": "transition___app-RMAppImpl__event-RMAppEvent",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java",
  "functionStartLine": 1359,
  "functionEndLine": 1362,
  "numCommitsSeen": 196,
  "timeTaken": 11385,
  "changeHistory": [
    "52adf719143c20f4f2af369c6c40dd98677e7410",
    "e30668106dc246f68db36fbd1f2db6ec08cd96f2",
    "52734134116eb4b18686e308d00e71e7e903383e",
    "d03dcb9635dbd79a45d229d1cab5fd28e5e49f49",
    "3651fe1b089851b38be351c00a9899817166bf3e",
    "9582a50176800433ad3fa8829a50c28b859812a3",
    "0a641496c706fc175e7bf66d69ebf71c7d078e84",
    "14e2639fd0d53f7e0b58f2f4744af44983d4e867",
    "b717d44b52a7ddc6586f9dd2b830422b984b5b0f",
    "d16470025aa0c51a04c530863a96108895d72ddf",
    "1393581bceda234c88cafec00dbfc0ef2a402e83",
    "9f4d4e27fb1760b352cc5b301cd65a50d2d43ff6",
    "07573640147bb4cf3568078acae7b245e9299cf7",
    "6cd0736cc57849e4f7c5d38a3986432a9717fe39",
    "e1fdf62123625e4ba399af02f8aad500637d29d1",
    "ae6cc14611a5898ed637a2e0f9df559f6c29093e",
    "a5c9ede1433871fcf4e2e802ee2a65950ecd1e72",
    "f2b91a8367a762091482074505618b570a520b19",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517"
  ],
  "changeHistoryShort": {
    "52adf719143c20f4f2af369c6c40dd98677e7410": "Ybodychange",
    "e30668106dc246f68db36fbd1f2db6ec08cd96f2": "Ybodychange",
    "52734134116eb4b18686e308d00e71e7e903383e": "Ybodychange",
    "d03dcb9635dbd79a45d229d1cab5fd28e5e49f49": "Ybodychange",
    "3651fe1b089851b38be351c00a9899817166bf3e": "Ybodychange",
    "9582a50176800433ad3fa8829a50c28b859812a3": "Ybodychange",
    "0a641496c706fc175e7bf66d69ebf71c7d078e84": "Ybodychange",
    "14e2639fd0d53f7e0b58f2f4744af44983d4e867": "Ybodychange",
    "b717d44b52a7ddc6586f9dd2b830422b984b5b0f": "Ybodychange",
    "d16470025aa0c51a04c530863a96108895d72ddf": "Ybodychange",
    "1393581bceda234c88cafec00dbfc0ef2a402e83": "Ybodychange",
    "9f4d4e27fb1760b352cc5b301cd65a50d2d43ff6": "Ybodychange",
    "07573640147bb4cf3568078acae7b245e9299cf7": "Ybodychange",
    "6cd0736cc57849e4f7c5d38a3986432a9717fe39": "Ybodychange",
    "e1fdf62123625e4ba399af02f8aad500637d29d1": "Yfilerename",
    "ae6cc14611a5898ed637a2e0f9df559f6c29093e": "Ybodychange",
    "a5c9ede1433871fcf4e2e802ee2a65950ecd1e72": "Ybodychange",
    "f2b91a8367a762091482074505618b570a520b19": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": "Yintroduced"
  },
  "changeHistoryDetails": {
    "52adf719143c20f4f2af369c6c40dd98677e7410": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5617. AMs only intended to run one attempt can be run more than once? Contributed by Jason Lowe.\n",
      "commitDate": "24/04/17 10:03 AM",
      "commitName": "52adf719143c20f4f2af369c6c40dd98677e7410",
      "commitAuthor": "Eric Payne",
      "commitDateOld": "27/03/17 5:23 PM",
      "commitNameOld": "9bae6720cb8432efd78c909dc624c00e367cedf5",
      "commitAuthorOld": "Robert Kanter",
      "daysBetweenCommits": 27.69,
      "commitsBetweenForRepo": 151,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,48 +1,56 @@\n     public RMAppState transition(RMAppImpl app, RMAppEvent event) {\n       int numberOfFailure \u003d app.getNumFailedAppAttempts();\n-      LOG.info(\"The number of failed attempts\"\n-          + (app.attemptFailuresValidityInterval \u003e 0 ? \" in previous \"\n-              + app.attemptFailuresValidityInterval + \" milliseconds \" : \" \")\n-          + \"is \" + numberOfFailure + \". The max attempts is \"\n-          + app.maxAppAttempts);\n+      if (app.maxAppAttempts \u003d\u003d 1) {\n+        // If the user explicitly set the attempts to 1 then there are likely\n+        // correctness issues if the AM restarts for any reason.\n+        LOG.info(\"Max app attempts is 1 for \" + app.applicationId\n+            + \", preventing further attempts.\");\n+        numberOfFailure \u003d app.maxAppAttempts;\n+      } else {\n+        LOG.info(\"The number of failed attempts\"\n+            + (app.attemptFailuresValidityInterval \u003e 0 ? \" in previous \"\n+            + app.attemptFailuresValidityInterval + \" milliseconds \" : \" \")\n+            + \"is \" + numberOfFailure + \". The max attempts is \"\n+            + app.maxAppAttempts);\n \n-      if (app.attemptFailuresValidityInterval \u003e 0) {\n-        removeExcessAttempts(app);\n+        if (app.attemptFailuresValidityInterval \u003e 0) {\n+          removeExcessAttempts(app);\n+        }\n       }\n \n       if (!app.submissionContext.getUnmanagedAM()\n           \u0026\u0026 numberOfFailure \u003c app.maxAppAttempts) {\n         if (initialState.equals(RMAppState.KILLING)) {\n           // If this is not last attempt, app should be killed instead of\n           // launching a new attempt\n           app.rememberTargetTransitionsAndStoreState(event,\n             new AppKilledTransition(), RMAppState.KILLED, RMAppState.KILLED);\n           return RMAppState.FINAL_SAVING;\n         }\n \n         boolean transferStateFromPreviousAttempt;\n         RMAppFailedAttemptEvent failedEvent \u003d (RMAppFailedAttemptEvent) event;\n         transferStateFromPreviousAttempt \u003d\n             failedEvent.getTransferStateFromPreviousAttempt();\n \n         RMAppAttempt oldAttempt \u003d app.currentAttempt;\n         app.createAndStartNewAttempt(transferStateFromPreviousAttempt);\n         // Transfer the state from the previous attempt to the current attempt.\n         // Note that the previous failed attempt may still be collecting the\n         // container events from the scheduler and update its data structures\n         // before the new attempt is created. We always transferState for\n         // finished containers so that they can be acked to NM,\n         // but when pulling finished container we will check this flag again.\n         ((RMAppAttemptImpl) app.currentAttempt)\n           .transferStateFromAttempt(oldAttempt);\n         return initialState;\n       } else {\n         if (numberOfFailure \u003e\u003d app.maxAppAttempts) {\n           app.isNumAttemptsBeyondThreshold \u003d true;\n         }\n         app.rememberTargetTransitionsAndStoreState(event,\n           new AttemptFailedFinalStateSavedTransition(), RMAppState.FAILED,\n           RMAppState.FAILED);\n         return RMAppState.FINAL_SAVING;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public RMAppState transition(RMAppImpl app, RMAppEvent event) {\n      int numberOfFailure \u003d app.getNumFailedAppAttempts();\n      if (app.maxAppAttempts \u003d\u003d 1) {\n        // If the user explicitly set the attempts to 1 then there are likely\n        // correctness issues if the AM restarts for any reason.\n        LOG.info(\"Max app attempts is 1 for \" + app.applicationId\n            + \", preventing further attempts.\");\n        numberOfFailure \u003d app.maxAppAttempts;\n      } else {\n        LOG.info(\"The number of failed attempts\"\n            + (app.attemptFailuresValidityInterval \u003e 0 ? \" in previous \"\n            + app.attemptFailuresValidityInterval + \" milliseconds \" : \" \")\n            + \"is \" + numberOfFailure + \". The max attempts is \"\n            + app.maxAppAttempts);\n\n        if (app.attemptFailuresValidityInterval \u003e 0) {\n          removeExcessAttempts(app);\n        }\n      }\n\n      if (!app.submissionContext.getUnmanagedAM()\n          \u0026\u0026 numberOfFailure \u003c app.maxAppAttempts) {\n        if (initialState.equals(RMAppState.KILLING)) {\n          // If this is not last attempt, app should be killed instead of\n          // launching a new attempt\n          app.rememberTargetTransitionsAndStoreState(event,\n            new AppKilledTransition(), RMAppState.KILLED, RMAppState.KILLED);\n          return RMAppState.FINAL_SAVING;\n        }\n\n        boolean transferStateFromPreviousAttempt;\n        RMAppFailedAttemptEvent failedEvent \u003d (RMAppFailedAttemptEvent) event;\n        transferStateFromPreviousAttempt \u003d\n            failedEvent.getTransferStateFromPreviousAttempt();\n\n        RMAppAttempt oldAttempt \u003d app.currentAttempt;\n        app.createAndStartNewAttempt(transferStateFromPreviousAttempt);\n        // Transfer the state from the previous attempt to the current attempt.\n        // Note that the previous failed attempt may still be collecting the\n        // container events from the scheduler and update its data structures\n        // before the new attempt is created. We always transferState for\n        // finished containers so that they can be acked to NM,\n        // but when pulling finished container we will check this flag again.\n        ((RMAppAttemptImpl) app.currentAttempt)\n          .transferStateFromAttempt(oldAttempt);\n        return initialState;\n      } else {\n        if (numberOfFailure \u003e\u003d app.maxAppAttempts) {\n          app.isNumAttemptsBeyondThreshold \u003d true;\n        }\n        app.rememberTargetTransitionsAndStoreState(event,\n          new AttemptFailedFinalStateSavedTransition(), RMAppState.FAILED,\n          RMAppState.FAILED);\n        return RMAppState.FINAL_SAVING;\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java",
      "extendedDetails": {}
    },
    "e30668106dc246f68db36fbd1f2db6ec08cd96f2": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4584. RM startup failure when AM attempts greater than max-attempts. (Bibin A Chundatt via rohithsharmaks)\n",
      "commitDate": "21/01/16 8:44 PM",
      "commitName": "e30668106dc246f68db36fbd1f2db6ec08cd96f2",
      "commitAuthor": "Rohith Sharma K S",
      "commitDateOld": "18/01/16 1:58 AM",
      "commitNameOld": "d40859fab1ad977636457a6cc96b6a4f9b903afc",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 3.78,
      "commitsBetweenForRepo": 32,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,48 @@\n     public RMAppState transition(RMAppImpl app, RMAppEvent event) {\n       int numberOfFailure \u003d app.getNumFailedAppAttempts();\n       LOG.info(\"The number of failed attempts\"\n           + (app.attemptFailuresValidityInterval \u003e 0 ? \" in previous \"\n               + app.attemptFailuresValidityInterval + \" milliseconds \" : \" \")\n           + \"is \" + numberOfFailure + \". The max attempts is \"\n           + app.maxAppAttempts);\n \n-      removeExcessAttempts(app);\n+      if (app.attemptFailuresValidityInterval \u003e 0) {\n+        removeExcessAttempts(app);\n+      }\n \n       if (!app.submissionContext.getUnmanagedAM()\n           \u0026\u0026 numberOfFailure \u003c app.maxAppAttempts) {\n         if (initialState.equals(RMAppState.KILLING)) {\n           // If this is not last attempt, app should be killed instead of\n           // launching a new attempt\n           app.rememberTargetTransitionsAndStoreState(event,\n             new AppKilledTransition(), RMAppState.KILLED, RMAppState.KILLED);\n           return RMAppState.FINAL_SAVING;\n         }\n \n         boolean transferStateFromPreviousAttempt;\n         RMAppFailedAttemptEvent failedEvent \u003d (RMAppFailedAttemptEvent) event;\n         transferStateFromPreviousAttempt \u003d\n             failedEvent.getTransferStateFromPreviousAttempt();\n \n         RMAppAttempt oldAttempt \u003d app.currentAttempt;\n         app.createAndStartNewAttempt(transferStateFromPreviousAttempt);\n         // Transfer the state from the previous attempt to the current attempt.\n         // Note that the previous failed attempt may still be collecting the\n         // container events from the scheduler and update its data structures\n         // before the new attempt is created. We always transferState for\n         // finished containers so that they can be acked to NM,\n         // but when pulling finished container we will check this flag again.\n         ((RMAppAttemptImpl) app.currentAttempt)\n           .transferStateFromAttempt(oldAttempt);\n         return initialState;\n       } else {\n         if (numberOfFailure \u003e\u003d app.maxAppAttempts) {\n           app.isNumAttemptsBeyondThreshold \u003d true;\n         }\n         app.rememberTargetTransitionsAndStoreState(event,\n           new AttemptFailedFinalStateSavedTransition(), RMAppState.FAILED,\n           RMAppState.FAILED);\n         return RMAppState.FINAL_SAVING;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public RMAppState transition(RMAppImpl app, RMAppEvent event) {\n      int numberOfFailure \u003d app.getNumFailedAppAttempts();\n      LOG.info(\"The number of failed attempts\"\n          + (app.attemptFailuresValidityInterval \u003e 0 ? \" in previous \"\n              + app.attemptFailuresValidityInterval + \" milliseconds \" : \" \")\n          + \"is \" + numberOfFailure + \". The max attempts is \"\n          + app.maxAppAttempts);\n\n      if (app.attemptFailuresValidityInterval \u003e 0) {\n        removeExcessAttempts(app);\n      }\n\n      if (!app.submissionContext.getUnmanagedAM()\n          \u0026\u0026 numberOfFailure \u003c app.maxAppAttempts) {\n        if (initialState.equals(RMAppState.KILLING)) {\n          // If this is not last attempt, app should be killed instead of\n          // launching a new attempt\n          app.rememberTargetTransitionsAndStoreState(event,\n            new AppKilledTransition(), RMAppState.KILLED, RMAppState.KILLED);\n          return RMAppState.FINAL_SAVING;\n        }\n\n        boolean transferStateFromPreviousAttempt;\n        RMAppFailedAttemptEvent failedEvent \u003d (RMAppFailedAttemptEvent) event;\n        transferStateFromPreviousAttempt \u003d\n            failedEvent.getTransferStateFromPreviousAttempt();\n\n        RMAppAttempt oldAttempt \u003d app.currentAttempt;\n        app.createAndStartNewAttempt(transferStateFromPreviousAttempt);\n        // Transfer the state from the previous attempt to the current attempt.\n        // Note that the previous failed attempt may still be collecting the\n        // container events from the scheduler and update its data structures\n        // before the new attempt is created. We always transferState for\n        // finished containers so that they can be acked to NM,\n        // but when pulling finished container we will check this flag again.\n        ((RMAppAttemptImpl) app.currentAttempt)\n          .transferStateFromAttempt(oldAttempt);\n        return initialState;\n      } else {\n        if (numberOfFailure \u003e\u003d app.maxAppAttempts) {\n          app.isNumAttemptsBeyondThreshold \u003d true;\n        }\n        app.rememberTargetTransitionsAndStoreState(event,\n          new AttemptFailedFinalStateSavedTransition(), RMAppState.FAILED,\n          RMAppState.FAILED);\n        return RMAppState.FINAL_SAVING;\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java",
      "extendedDetails": {}
    },
    "52734134116eb4b18686e308d00e71e7e903383e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3480. Remove attempts that are beyond max-attempt limit from state store. Contributed by Jun Gong\n",
      "commitDate": "29/12/15 3:58 PM",
      "commitName": "52734134116eb4b18686e308d00e71e7e903383e",
      "commitAuthor": "Jian He",
      "commitDateOld": "14/12/15 10:52 AM",
      "commitNameOld": "6cb0af3c39a5d49cb2f7911ee21363a9542ca2d7",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 15.21,
      "commitsBetweenForRepo": 92,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,43 +1,46 @@\n     public RMAppState transition(RMAppImpl app, RMAppEvent event) {\n       int numberOfFailure \u003d app.getNumFailedAppAttempts();\n       LOG.info(\"The number of failed attempts\"\n           + (app.attemptFailuresValidityInterval \u003e 0 ? \" in previous \"\n               + app.attemptFailuresValidityInterval + \" milliseconds \" : \" \")\n           + \"is \" + numberOfFailure + \". The max attempts is \"\n           + app.maxAppAttempts);\n+\n+      removeExcessAttempts(app);\n+\n       if (!app.submissionContext.getUnmanagedAM()\n           \u0026\u0026 numberOfFailure \u003c app.maxAppAttempts) {\n         if (initialState.equals(RMAppState.KILLING)) {\n           // If this is not last attempt, app should be killed instead of\n           // launching a new attempt\n           app.rememberTargetTransitionsAndStoreState(event,\n             new AppKilledTransition(), RMAppState.KILLED, RMAppState.KILLED);\n           return RMAppState.FINAL_SAVING;\n         }\n \n         boolean transferStateFromPreviousAttempt;\n         RMAppFailedAttemptEvent failedEvent \u003d (RMAppFailedAttemptEvent) event;\n         transferStateFromPreviousAttempt \u003d\n             failedEvent.getTransferStateFromPreviousAttempt();\n \n         RMAppAttempt oldAttempt \u003d app.currentAttempt;\n         app.createAndStartNewAttempt(transferStateFromPreviousAttempt);\n         // Transfer the state from the previous attempt to the current attempt.\n         // Note that the previous failed attempt may still be collecting the\n         // container events from the scheduler and update its data structures\n         // before the new attempt is created. We always transferState for\n         // finished containers so that they can be acked to NM,\n         // but when pulling finished container we will check this flag again.\n         ((RMAppAttemptImpl) app.currentAttempt)\n           .transferStateFromAttempt(oldAttempt);\n         return initialState;\n       } else {\n         if (numberOfFailure \u003e\u003d app.maxAppAttempts) {\n           app.isNumAttemptsBeyondThreshold \u003d true;\n         }\n         app.rememberTargetTransitionsAndStoreState(event,\n           new AttemptFailedFinalStateSavedTransition(), RMAppState.FAILED,\n           RMAppState.FAILED);\n         return RMAppState.FINAL_SAVING;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public RMAppState transition(RMAppImpl app, RMAppEvent event) {\n      int numberOfFailure \u003d app.getNumFailedAppAttempts();\n      LOG.info(\"The number of failed attempts\"\n          + (app.attemptFailuresValidityInterval \u003e 0 ? \" in previous \"\n              + app.attemptFailuresValidityInterval + \" milliseconds \" : \" \")\n          + \"is \" + numberOfFailure + \". The max attempts is \"\n          + app.maxAppAttempts);\n\n      removeExcessAttempts(app);\n\n      if (!app.submissionContext.getUnmanagedAM()\n          \u0026\u0026 numberOfFailure \u003c app.maxAppAttempts) {\n        if (initialState.equals(RMAppState.KILLING)) {\n          // If this is not last attempt, app should be killed instead of\n          // launching a new attempt\n          app.rememberTargetTransitionsAndStoreState(event,\n            new AppKilledTransition(), RMAppState.KILLED, RMAppState.KILLED);\n          return RMAppState.FINAL_SAVING;\n        }\n\n        boolean transferStateFromPreviousAttempt;\n        RMAppFailedAttemptEvent failedEvent \u003d (RMAppFailedAttemptEvent) event;\n        transferStateFromPreviousAttempt \u003d\n            failedEvent.getTransferStateFromPreviousAttempt();\n\n        RMAppAttempt oldAttempt \u003d app.currentAttempt;\n        app.createAndStartNewAttempt(transferStateFromPreviousAttempt);\n        // Transfer the state from the previous attempt to the current attempt.\n        // Note that the previous failed attempt may still be collecting the\n        // container events from the scheduler and update its data structures\n        // before the new attempt is created. We always transferState for\n        // finished containers so that they can be acked to NM,\n        // but when pulling finished container we will check this flag again.\n        ((RMAppAttemptImpl) app.currentAttempt)\n          .transferStateFromAttempt(oldAttempt);\n        return initialState;\n      } else {\n        if (numberOfFailure \u003e\u003d app.maxAppAttempts) {\n          app.isNumAttemptsBeyondThreshold \u003d true;\n        }\n        app.rememberTargetTransitionsAndStoreState(event,\n          new AttemptFailedFinalStateSavedTransition(), RMAppState.FAILED,\n          RMAppState.FAILED);\n        return RMAppState.FINAL_SAVING;\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java",
      "extendedDetails": {}
    },
    "d03dcb9635dbd79a45d229d1cab5fd28e5e49f49": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3387. Previous AM\u0027s container completed status couldn\u0027t pass to current AM if AM and RM restarted during the same time. Contributed by Sandflee\n",
      "commitDate": "24/04/15 12:13 PM",
      "commitName": "d03dcb9635dbd79a45d229d1cab5fd28e5e49f49",
      "commitAuthor": "Jian He",
      "commitDateOld": "17/04/15 1:18 PM",
      "commitNameOld": "1db355a875c3ecc40a244045c6812e00c8d36ef1",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 6.95,
      "commitsBetweenForRepo": 66,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,43 +1,43 @@\n     public RMAppState transition(RMAppImpl app, RMAppEvent event) {\n       int numberOfFailure \u003d app.getNumFailedAppAttempts();\n       LOG.info(\"The number of failed attempts\"\n           + (app.attemptFailuresValidityInterval \u003e 0 ? \" in previous \"\n               + app.attemptFailuresValidityInterval + \" milliseconds \" : \" \")\n           + \"is \" + numberOfFailure + \". The max attempts is \"\n           + app.maxAppAttempts);\n       if (!app.submissionContext.getUnmanagedAM()\n           \u0026\u0026 numberOfFailure \u003c app.maxAppAttempts) {\n         if (initialState.equals(RMAppState.KILLING)) {\n           // If this is not last attempt, app should be killed instead of\n           // launching a new attempt\n           app.rememberTargetTransitionsAndStoreState(event,\n             new AppKilledTransition(), RMAppState.KILLED, RMAppState.KILLED);\n           return RMAppState.FINAL_SAVING;\n         }\n \n         boolean transferStateFromPreviousAttempt;\n         RMAppFailedAttemptEvent failedEvent \u003d (RMAppFailedAttemptEvent) event;\n         transferStateFromPreviousAttempt \u003d\n             failedEvent.getTransferStateFromPreviousAttempt();\n \n         RMAppAttempt oldAttempt \u003d app.currentAttempt;\n         app.createAndStartNewAttempt(transferStateFromPreviousAttempt);\n         // Transfer the state from the previous attempt to the current attempt.\n         // Note that the previous failed attempt may still be collecting the\n         // container events from the scheduler and update its data structures\n         // before the new attempt is created. We always transferState for\n         // finished containers so that they can be acked to NM,\n         // but when pulling finished container we will check this flag again.\n         ((RMAppAttemptImpl) app.currentAttempt)\n-          .transferStateFromPreviousAttempt(oldAttempt);\n+          .transferStateFromAttempt(oldAttempt);\n         return initialState;\n       } else {\n         if (numberOfFailure \u003e\u003d app.maxAppAttempts) {\n           app.isNumAttemptsBeyondThreshold \u003d true;\n         }\n         app.rememberTargetTransitionsAndStoreState(event,\n           new AttemptFailedFinalStateSavedTransition(), RMAppState.FAILED,\n           RMAppState.FAILED);\n         return RMAppState.FINAL_SAVING;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public RMAppState transition(RMAppImpl app, RMAppEvent event) {\n      int numberOfFailure \u003d app.getNumFailedAppAttempts();\n      LOG.info(\"The number of failed attempts\"\n          + (app.attemptFailuresValidityInterval \u003e 0 ? \" in previous \"\n              + app.attemptFailuresValidityInterval + \" milliseconds \" : \" \")\n          + \"is \" + numberOfFailure + \". The max attempts is \"\n          + app.maxAppAttempts);\n      if (!app.submissionContext.getUnmanagedAM()\n          \u0026\u0026 numberOfFailure \u003c app.maxAppAttempts) {\n        if (initialState.equals(RMAppState.KILLING)) {\n          // If this is not last attempt, app should be killed instead of\n          // launching a new attempt\n          app.rememberTargetTransitionsAndStoreState(event,\n            new AppKilledTransition(), RMAppState.KILLED, RMAppState.KILLED);\n          return RMAppState.FINAL_SAVING;\n        }\n\n        boolean transferStateFromPreviousAttempt;\n        RMAppFailedAttemptEvent failedEvent \u003d (RMAppFailedAttemptEvent) event;\n        transferStateFromPreviousAttempt \u003d\n            failedEvent.getTransferStateFromPreviousAttempt();\n\n        RMAppAttempt oldAttempt \u003d app.currentAttempt;\n        app.createAndStartNewAttempt(transferStateFromPreviousAttempt);\n        // Transfer the state from the previous attempt to the current attempt.\n        // Note that the previous failed attempt may still be collecting the\n        // container events from the scheduler and update its data structures\n        // before the new attempt is created. We always transferState for\n        // finished containers so that they can be acked to NM,\n        // but when pulling finished container we will check this flag again.\n        ((RMAppAttemptImpl) app.currentAttempt)\n          .transferStateFromAttempt(oldAttempt);\n        return initialState;\n      } else {\n        if (numberOfFailure \u003e\u003d app.maxAppAttempts) {\n          app.isNumAttemptsBeyondThreshold \u003d true;\n        }\n        app.rememberTargetTransitionsAndStoreState(event,\n          new AttemptFailedFinalStateSavedTransition(), RMAppState.FAILED,\n          RMAppState.FAILED);\n        return RMAppState.FINAL_SAVING;\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java",
      "extendedDetails": {}
    },
    "3651fe1b089851b38be351c00a9899817166bf3e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2853. Fixed a bug in ResourceManager causing apps to hang when the user kill request races with ApplicationMaster finish. Contributed by Jian He.\n",
      "commitDate": "13/11/14 8:13 AM",
      "commitName": "3651fe1b089851b38be351c00a9899817166bf3e",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "09/11/14 6:56 PM",
      "commitNameOld": "e76faebc9589654e83c8244ef9aff88391e56b80",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 3.55,
      "commitsBetweenForRepo": 34,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,43 @@\n     public RMAppState transition(RMAppImpl app, RMAppEvent event) {\n       int numberOfFailure \u003d app.getNumFailedAppAttempts();\n       LOG.info(\"The number of failed attempts\"\n           + (app.attemptFailuresValidityInterval \u003e 0 ? \" in previous \"\n               + app.attemptFailuresValidityInterval + \" milliseconds \" : \" \")\n           + \"is \" + numberOfFailure + \". The max attempts is \"\n           + app.maxAppAttempts);\n       if (!app.submissionContext.getUnmanagedAM()\n           \u0026\u0026 numberOfFailure \u003c app.maxAppAttempts) {\n+        if (initialState.equals(RMAppState.KILLING)) {\n+          // If this is not last attempt, app should be killed instead of\n+          // launching a new attempt\n+          app.rememberTargetTransitionsAndStoreState(event,\n+            new AppKilledTransition(), RMAppState.KILLED, RMAppState.KILLED);\n+          return RMAppState.FINAL_SAVING;\n+        }\n+\n         boolean transferStateFromPreviousAttempt;\n         RMAppFailedAttemptEvent failedEvent \u003d (RMAppFailedAttemptEvent) event;\n         transferStateFromPreviousAttempt \u003d\n             failedEvent.getTransferStateFromPreviousAttempt();\n \n         RMAppAttempt oldAttempt \u003d app.currentAttempt;\n         app.createAndStartNewAttempt(transferStateFromPreviousAttempt);\n         // Transfer the state from the previous attempt to the current attempt.\n         // Note that the previous failed attempt may still be collecting the\n         // container events from the scheduler and update its data structures\n         // before the new attempt is created. We always transferState for\n         // finished containers so that they can be acked to NM,\n         // but when pulling finished container we will check this flag again.\n         ((RMAppAttemptImpl) app.currentAttempt)\n           .transferStateFromPreviousAttempt(oldAttempt);\n         return initialState;\n       } else {\n         if (numberOfFailure \u003e\u003d app.maxAppAttempts) {\n           app.isNumAttemptsBeyondThreshold \u003d true;\n         }\n         app.rememberTargetTransitionsAndStoreState(event,\n           new AttemptFailedFinalStateSavedTransition(), RMAppState.FAILED,\n           RMAppState.FAILED);\n         return RMAppState.FINAL_SAVING;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public RMAppState transition(RMAppImpl app, RMAppEvent event) {\n      int numberOfFailure \u003d app.getNumFailedAppAttempts();\n      LOG.info(\"The number of failed attempts\"\n          + (app.attemptFailuresValidityInterval \u003e 0 ? \" in previous \"\n              + app.attemptFailuresValidityInterval + \" milliseconds \" : \" \")\n          + \"is \" + numberOfFailure + \". The max attempts is \"\n          + app.maxAppAttempts);\n      if (!app.submissionContext.getUnmanagedAM()\n          \u0026\u0026 numberOfFailure \u003c app.maxAppAttempts) {\n        if (initialState.equals(RMAppState.KILLING)) {\n          // If this is not last attempt, app should be killed instead of\n          // launching a new attempt\n          app.rememberTargetTransitionsAndStoreState(event,\n            new AppKilledTransition(), RMAppState.KILLED, RMAppState.KILLED);\n          return RMAppState.FINAL_SAVING;\n        }\n\n        boolean transferStateFromPreviousAttempt;\n        RMAppFailedAttemptEvent failedEvent \u003d (RMAppFailedAttemptEvent) event;\n        transferStateFromPreviousAttempt \u003d\n            failedEvent.getTransferStateFromPreviousAttempt();\n\n        RMAppAttempt oldAttempt \u003d app.currentAttempt;\n        app.createAndStartNewAttempt(transferStateFromPreviousAttempt);\n        // Transfer the state from the previous attempt to the current attempt.\n        // Note that the previous failed attempt may still be collecting the\n        // container events from the scheduler and update its data structures\n        // before the new attempt is created. We always transferState for\n        // finished containers so that they can be acked to NM,\n        // but when pulling finished container we will check this flag again.\n        ((RMAppAttemptImpl) app.currentAttempt)\n          .transferStateFromPreviousAttempt(oldAttempt);\n        return initialState;\n      } else {\n        if (numberOfFailure \u003e\u003d app.maxAppAttempts) {\n          app.isNumAttemptsBeyondThreshold \u003d true;\n        }\n        app.rememberTargetTransitionsAndStoreState(event,\n          new AttemptFailedFinalStateSavedTransition(), RMAppState.FAILED,\n          RMAppState.FAILED);\n        return RMAppState.FINAL_SAVING;\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java",
      "extendedDetails": {}
    },
    "9582a50176800433ad3fa8829a50c28b859812a3": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2627. Added the info logs of attemptFailuresValidityInterval and number of previous failed attempts. Contributed by Xuan Gong.\n",
      "commitDate": "30/09/14 12:57 PM",
      "commitName": "9582a50176800433ad3fa8829a50c28b859812a3",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "22/09/14 10:30 AM",
      "commitNameOld": "0a641496c706fc175e7bf66d69ebf71c7d078e84",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 8.1,
      "commitsBetweenForRepo": 87,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,30 +1,35 @@\n     public RMAppState transition(RMAppImpl app, RMAppEvent event) {\n       int numberOfFailure \u003d app.getNumFailedAppAttempts();\n+      LOG.info(\"The number of failed attempts\"\n+          + (app.attemptFailuresValidityInterval \u003e 0 ? \" in previous \"\n+              + app.attemptFailuresValidityInterval + \" milliseconds \" : \" \")\n+          + \"is \" + numberOfFailure + \". The max attempts is \"\n+          + app.maxAppAttempts);\n       if (!app.submissionContext.getUnmanagedAM()\n           \u0026\u0026 numberOfFailure \u003c app.maxAppAttempts) {\n         boolean transferStateFromPreviousAttempt;\n         RMAppFailedAttemptEvent failedEvent \u003d (RMAppFailedAttemptEvent) event;\n         transferStateFromPreviousAttempt \u003d\n             failedEvent.getTransferStateFromPreviousAttempt();\n \n         RMAppAttempt oldAttempt \u003d app.currentAttempt;\n         app.createAndStartNewAttempt(transferStateFromPreviousAttempt);\n         // Transfer the state from the previous attempt to the current attempt.\n         // Note that the previous failed attempt may still be collecting the\n         // container events from the scheduler and update its data structures\n         // before the new attempt is created. We always transferState for\n         // finished containers so that they can be acked to NM,\n         // but when pulling finished container we will check this flag again.\n         ((RMAppAttemptImpl) app.currentAttempt)\n           .transferStateFromPreviousAttempt(oldAttempt);\n         return initialState;\n       } else {\n         if (numberOfFailure \u003e\u003d app.maxAppAttempts) {\n           app.isNumAttemptsBeyondThreshold \u003d true;\n         }\n         app.rememberTargetTransitionsAndStoreState(event,\n           new AttemptFailedFinalStateSavedTransition(), RMAppState.FAILED,\n           RMAppState.FAILED);\n         return RMAppState.FINAL_SAVING;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public RMAppState transition(RMAppImpl app, RMAppEvent event) {\n      int numberOfFailure \u003d app.getNumFailedAppAttempts();\n      LOG.info(\"The number of failed attempts\"\n          + (app.attemptFailuresValidityInterval \u003e 0 ? \" in previous \"\n              + app.attemptFailuresValidityInterval + \" milliseconds \" : \" \")\n          + \"is \" + numberOfFailure + \". The max attempts is \"\n          + app.maxAppAttempts);\n      if (!app.submissionContext.getUnmanagedAM()\n          \u0026\u0026 numberOfFailure \u003c app.maxAppAttempts) {\n        boolean transferStateFromPreviousAttempt;\n        RMAppFailedAttemptEvent failedEvent \u003d (RMAppFailedAttemptEvent) event;\n        transferStateFromPreviousAttempt \u003d\n            failedEvent.getTransferStateFromPreviousAttempt();\n\n        RMAppAttempt oldAttempt \u003d app.currentAttempt;\n        app.createAndStartNewAttempt(transferStateFromPreviousAttempt);\n        // Transfer the state from the previous attempt to the current attempt.\n        // Note that the previous failed attempt may still be collecting the\n        // container events from the scheduler and update its data structures\n        // before the new attempt is created. We always transferState for\n        // finished containers so that they can be acked to NM,\n        // but when pulling finished container we will check this flag again.\n        ((RMAppAttemptImpl) app.currentAttempt)\n          .transferStateFromPreviousAttempt(oldAttempt);\n        return initialState;\n      } else {\n        if (numberOfFailure \u003e\u003d app.maxAppAttempts) {\n          app.isNumAttemptsBeyondThreshold \u003d true;\n        }\n        app.rememberTargetTransitionsAndStoreState(event,\n          new AttemptFailedFinalStateSavedTransition(), RMAppState.FAILED,\n          RMAppState.FAILED);\n        return RMAppState.FINAL_SAVING;\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java",
      "extendedDetails": {}
    },
    "0a641496c706fc175e7bf66d69ebf71c7d078e84": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1372. Ensure all completed containers are reported to the AMs across RM restart. Contributed by Anubhav Dhoot\n",
      "commitDate": "22/09/14 10:30 AM",
      "commitName": "0a641496c706fc175e7bf66d69ebf71c7d078e84",
      "commitAuthor": "Jian He",
      "commitDateOld": "18/09/14 1:13 PM",
      "commitNameOld": "9ea7b6c063c0bdd4551962e21d0173f671e9df03",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 3.89,
      "commitsBetweenForRepo": 43,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,30 +1,30 @@\n     public RMAppState transition(RMAppImpl app, RMAppEvent event) {\n       int numberOfFailure \u003d app.getNumFailedAppAttempts();\n       if (!app.submissionContext.getUnmanagedAM()\n           \u0026\u0026 numberOfFailure \u003c app.maxAppAttempts) {\n-        boolean transferStateFromPreviousAttempt \u003d false;\n+        boolean transferStateFromPreviousAttempt;\n         RMAppFailedAttemptEvent failedEvent \u003d (RMAppFailedAttemptEvent) event;\n         transferStateFromPreviousAttempt \u003d\n             failedEvent.getTransferStateFromPreviousAttempt();\n \n         RMAppAttempt oldAttempt \u003d app.currentAttempt;\n         app.createAndStartNewAttempt(transferStateFromPreviousAttempt);\n         // Transfer the state from the previous attempt to the current attempt.\n         // Note that the previous failed attempt may still be collecting the\n         // container events from the scheduler and update its data structures\n-        // before the new attempt is created.\n-        if (transferStateFromPreviousAttempt) {\n-          ((RMAppAttemptImpl) app.currentAttempt)\n-            .transferStateFromPreviousAttempt(oldAttempt);\n-        }\n+        // before the new attempt is created. We always transferState for\n+        // finished containers so that they can be acked to NM,\n+        // but when pulling finished container we will check this flag again.\n+        ((RMAppAttemptImpl) app.currentAttempt)\n+          .transferStateFromPreviousAttempt(oldAttempt);\n         return initialState;\n       } else {\n         if (numberOfFailure \u003e\u003d app.maxAppAttempts) {\n           app.isNumAttemptsBeyondThreshold \u003d true;\n         }\n         app.rememberTargetTransitionsAndStoreState(event,\n           new AttemptFailedFinalStateSavedTransition(), RMAppState.FAILED,\n           RMAppState.FAILED);\n         return RMAppState.FINAL_SAVING;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public RMAppState transition(RMAppImpl app, RMAppEvent event) {\n      int numberOfFailure \u003d app.getNumFailedAppAttempts();\n      if (!app.submissionContext.getUnmanagedAM()\n          \u0026\u0026 numberOfFailure \u003c app.maxAppAttempts) {\n        boolean transferStateFromPreviousAttempt;\n        RMAppFailedAttemptEvent failedEvent \u003d (RMAppFailedAttemptEvent) event;\n        transferStateFromPreviousAttempt \u003d\n            failedEvent.getTransferStateFromPreviousAttempt();\n\n        RMAppAttempt oldAttempt \u003d app.currentAttempt;\n        app.createAndStartNewAttempt(transferStateFromPreviousAttempt);\n        // Transfer the state from the previous attempt to the current attempt.\n        // Note that the previous failed attempt may still be collecting the\n        // container events from the scheduler and update its data structures\n        // before the new attempt is created. We always transferState for\n        // finished containers so that they can be acked to NM,\n        // but when pulling finished container we will check this flag again.\n        ((RMAppAttemptImpl) app.currentAttempt)\n          .transferStateFromPreviousAttempt(oldAttempt);\n        return initialState;\n      } else {\n        if (numberOfFailure \u003e\u003d app.maxAppAttempts) {\n          app.isNumAttemptsBeyondThreshold \u003d true;\n        }\n        app.rememberTargetTransitionsAndStoreState(event,\n          new AttemptFailedFinalStateSavedTransition(), RMAppState.FAILED,\n          RMAppState.FAILED);\n        return RMAppState.FINAL_SAVING;\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java",
      "extendedDetails": {}
    },
    "14e2639fd0d53f7e0b58f2f4744af44983d4e867": {
      "type": "Ybodychange",
      "commitMessage": "YARN-611. Added an API to let apps specify an interval beyond which AM failures should be ignored towards counting max-attempts. Contributed by Xuan Gong.\n",
      "commitDate": "13/09/14 6:04 PM",
      "commitName": "14e2639fd0d53f7e0b58f2f4744af44983d4e867",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "11/09/14 7:04 PM",
      "commitNameOld": "6b8b1608e64e300e4e1d23c60476febaca29ca38",
      "commitAuthorOld": "junping_du",
      "daysBetweenCommits": 1.96,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,26 +1,30 @@\n     public RMAppState transition(RMAppImpl app, RMAppEvent event) {\n+      int numberOfFailure \u003d app.getNumFailedAppAttempts();\n       if (!app.submissionContext.getUnmanagedAM()\n-          \u0026\u0026 app.getNumFailedAppAttempts() \u003c app.maxAppAttempts) {\n+          \u0026\u0026 numberOfFailure \u003c app.maxAppAttempts) {\n         boolean transferStateFromPreviousAttempt \u003d false;\n         RMAppFailedAttemptEvent failedEvent \u003d (RMAppFailedAttemptEvent) event;\n         transferStateFromPreviousAttempt \u003d\n             failedEvent.getTransferStateFromPreviousAttempt();\n \n         RMAppAttempt oldAttempt \u003d app.currentAttempt;\n         app.createAndStartNewAttempt(transferStateFromPreviousAttempt);\n         // Transfer the state from the previous attempt to the current attempt.\n         // Note that the previous failed attempt may still be collecting the\n         // container events from the scheduler and update its data structures\n         // before the new attempt is created.\n         if (transferStateFromPreviousAttempt) {\n           ((RMAppAttemptImpl) app.currentAttempt)\n             .transferStateFromPreviousAttempt(oldAttempt);\n         }\n         return initialState;\n       } else {\n+        if (numberOfFailure \u003e\u003d app.maxAppAttempts) {\n+          app.isNumAttemptsBeyondThreshold \u003d true;\n+        }\n         app.rememberTargetTransitionsAndStoreState(event,\n           new AttemptFailedFinalStateSavedTransition(), RMAppState.FAILED,\n           RMAppState.FAILED);\n         return RMAppState.FINAL_SAVING;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public RMAppState transition(RMAppImpl app, RMAppEvent event) {\n      int numberOfFailure \u003d app.getNumFailedAppAttempts();\n      if (!app.submissionContext.getUnmanagedAM()\n          \u0026\u0026 numberOfFailure \u003c app.maxAppAttempts) {\n        boolean transferStateFromPreviousAttempt \u003d false;\n        RMAppFailedAttemptEvent failedEvent \u003d (RMAppFailedAttemptEvent) event;\n        transferStateFromPreviousAttempt \u003d\n            failedEvent.getTransferStateFromPreviousAttempt();\n\n        RMAppAttempt oldAttempt \u003d app.currentAttempt;\n        app.createAndStartNewAttempt(transferStateFromPreviousAttempt);\n        // Transfer the state from the previous attempt to the current attempt.\n        // Note that the previous failed attempt may still be collecting the\n        // container events from the scheduler and update its data structures\n        // before the new attempt is created.\n        if (transferStateFromPreviousAttempt) {\n          ((RMAppAttemptImpl) app.currentAttempt)\n            .transferStateFromPreviousAttempt(oldAttempt);\n        }\n        return initialState;\n      } else {\n        if (numberOfFailure \u003e\u003d app.maxAppAttempts) {\n          app.isNumAttemptsBeyondThreshold \u003d true;\n        }\n        app.rememberTargetTransitionsAndStoreState(event,\n          new AttemptFailedFinalStateSavedTransition(), RMAppState.FAILED,\n          RMAppState.FAILED);\n        return RMAppState.FINAL_SAVING;\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java",
      "extendedDetails": {}
    },
    "b717d44b52a7ddc6586f9dd2b830422b984b5b0f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-614. Changed ResourceManager to not count disk failure, node loss and RM restart towards app failures. Contributed by Xuan Gong\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1606407 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "28/06/14 4:37 PM",
      "commitName": "b717d44b52a7ddc6586f9dd2b830422b984b5b0f",
      "commitAuthor": "Jian He",
      "commitDateOld": "24/06/14 8:15 AM",
      "commitNameOld": "d16470025aa0c51a04c530863a96108895d72ddf",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 4.35,
      "commitsBetweenForRepo": 37,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,27 +1,27 @@\n     public RMAppState transition(RMAppImpl app, RMAppEvent event) {\n \n       if (!app.submissionContext.getUnmanagedAM()\n-          \u0026\u0026 app.getNumNonPreemptedAppAttempts() \u003c app.maxAppAttempts) {\n+          \u0026\u0026 app.getNumFailedAppAttempts() \u003c app.maxAppAttempts) {\n         boolean transferStateFromPreviousAttempt \u003d false;\n         RMAppFailedAttemptEvent failedEvent \u003d (RMAppFailedAttemptEvent) event;\n         transferStateFromPreviousAttempt \u003d\n             failedEvent.getTransferStateFromPreviousAttempt();\n \n         RMAppAttempt oldAttempt \u003d app.currentAttempt;\n         app.createAndStartNewAttempt(transferStateFromPreviousAttempt);\n         // Transfer the state from the previous attempt to the current attempt.\n         // Note that the previous failed attempt may still be collecting the\n         // container events from the scheduler and update its data structures\n         // before the new attempt is created.\n         if (transferStateFromPreviousAttempt) {\n           ((RMAppAttemptImpl) app.currentAttempt)\n             .transferStateFromPreviousAttempt(oldAttempt);\n         }\n         return initialState;\n       } else {\n         app.rememberTargetTransitionsAndStoreState(event,\n           new AttemptFailedFinalStateSavedTransition(), RMAppState.FAILED,\n           RMAppState.FAILED);\n         return RMAppState.FINAL_SAVING;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public RMAppState transition(RMAppImpl app, RMAppEvent event) {\n\n      if (!app.submissionContext.getUnmanagedAM()\n          \u0026\u0026 app.getNumFailedAppAttempts() \u003c app.maxAppAttempts) {\n        boolean transferStateFromPreviousAttempt \u003d false;\n        RMAppFailedAttemptEvent failedEvent \u003d (RMAppFailedAttemptEvent) event;\n        transferStateFromPreviousAttempt \u003d\n            failedEvent.getTransferStateFromPreviousAttempt();\n\n        RMAppAttempt oldAttempt \u003d app.currentAttempt;\n        app.createAndStartNewAttempt(transferStateFromPreviousAttempt);\n        // Transfer the state from the previous attempt to the current attempt.\n        // Note that the previous failed attempt may still be collecting the\n        // container events from the scheduler and update its data structures\n        // before the new attempt is created.\n        if (transferStateFromPreviousAttempt) {\n          ((RMAppAttemptImpl) app.currentAttempt)\n            .transferStateFromPreviousAttempt(oldAttempt);\n        }\n        return initialState;\n      } else {\n        app.rememberTargetTransitionsAndStoreState(event,\n          new AttemptFailedFinalStateSavedTransition(), RMAppState.FAILED,\n          RMAppState.FAILED);\n        return RMAppState.FINAL_SAVING;\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java",
      "extendedDetails": {}
    },
    "d16470025aa0c51a04c530863a96108895d72ddf": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2074. Changed ResourceManager to not count AM preemptions towards app failures. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1605106 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/06/14 8:15 AM",
      "commitName": "d16470025aa0c51a04c530863a96108895d72ddf",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "16/06/14 4:56 PM",
      "commitNameOld": "95897ca14b7abd7fe047fdcf150473a8a2cbb024",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 7.64,
      "commitsBetweenForRepo": 55,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,26 +1,27 @@\n     public RMAppState transition(RMAppImpl app, RMAppEvent event) {\n+\n       if (!app.submissionContext.getUnmanagedAM()\n-          \u0026\u0026 app.attempts.size() \u003c app.maxAppAttempts) {\n+          \u0026\u0026 app.getNumNonPreemptedAppAttempts() \u003c app.maxAppAttempts) {\n         boolean transferStateFromPreviousAttempt \u003d false;\n         RMAppFailedAttemptEvent failedEvent \u003d (RMAppFailedAttemptEvent) event;\n         transferStateFromPreviousAttempt \u003d\n             failedEvent.getTransferStateFromPreviousAttempt();\n \n         RMAppAttempt oldAttempt \u003d app.currentAttempt;\n         app.createAndStartNewAttempt(transferStateFromPreviousAttempt);\n         // Transfer the state from the previous attempt to the current attempt.\n         // Note that the previous failed attempt may still be collecting the\n         // container events from the scheduler and update its data structures\n         // before the new attempt is created.\n         if (transferStateFromPreviousAttempt) {\n           ((RMAppAttemptImpl) app.currentAttempt)\n             .transferStateFromPreviousAttempt(oldAttempt);\n         }\n         return initialState;\n       } else {\n         app.rememberTargetTransitionsAndStoreState(event,\n           new AttemptFailedFinalStateSavedTransition(), RMAppState.FAILED,\n           RMAppState.FAILED);\n         return RMAppState.FINAL_SAVING;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public RMAppState transition(RMAppImpl app, RMAppEvent event) {\n\n      if (!app.submissionContext.getUnmanagedAM()\n          \u0026\u0026 app.getNumNonPreemptedAppAttempts() \u003c app.maxAppAttempts) {\n        boolean transferStateFromPreviousAttempt \u003d false;\n        RMAppFailedAttemptEvent failedEvent \u003d (RMAppFailedAttemptEvent) event;\n        transferStateFromPreviousAttempt \u003d\n            failedEvent.getTransferStateFromPreviousAttempt();\n\n        RMAppAttempt oldAttempt \u003d app.currentAttempt;\n        app.createAndStartNewAttempt(transferStateFromPreviousAttempt);\n        // Transfer the state from the previous attempt to the current attempt.\n        // Note that the previous failed attempt may still be collecting the\n        // container events from the scheduler and update its data structures\n        // before the new attempt is created.\n        if (transferStateFromPreviousAttempt) {\n          ((RMAppAttemptImpl) app.currentAttempt)\n            .transferStateFromPreviousAttempt(oldAttempt);\n        }\n        return initialState;\n      } else {\n        app.rememberTargetTransitionsAndStoreState(event,\n          new AttemptFailedFinalStateSavedTransition(), RMAppState.FAILED,\n          RMAppState.FAILED);\n        return RMAppState.FINAL_SAVING;\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java",
      "extendedDetails": {}
    },
    "1393581bceda234c88cafec00dbfc0ef2a402e83": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1490. Introduced the ability to make ResourceManager optionally not kill all containers when an ApplicationMaster exits. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1557143 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/01/14 7:04 AM",
      "commitName": "1393581bceda234c88cafec00dbfc0ef2a402e83",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "02/01/14 12:19 PM",
      "commitNameOld": "a45017a5f17ec11814db7e206d1e80aaa4dd8d8f",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 7.78,
      "commitsBetweenForRepo": 34,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,12 +1,26 @@\n     public RMAppState transition(RMAppImpl app, RMAppEvent event) {\n       if (!app.submissionContext.getUnmanagedAM()\n           \u0026\u0026 app.attempts.size() \u003c app.maxAppAttempts) {\n-        app.createNewAttempt(true);\n+        boolean transferStateFromPreviousAttempt \u003d false;\n+        RMAppFailedAttemptEvent failedEvent \u003d (RMAppFailedAttemptEvent) event;\n+        transferStateFromPreviousAttempt \u003d\n+            failedEvent.getTransferStateFromPreviousAttempt();\n+\n+        RMAppAttempt oldAttempt \u003d app.currentAttempt;\n+        app.createAndStartNewAttempt(transferStateFromPreviousAttempt);\n+        // Transfer the state from the previous attempt to the current attempt.\n+        // Note that the previous failed attempt may still be collecting the\n+        // container events from the scheduler and update its data structures\n+        // before the new attempt is created.\n+        if (transferStateFromPreviousAttempt) {\n+          ((RMAppAttemptImpl) app.currentAttempt)\n+            .transferStateFromPreviousAttempt(oldAttempt);\n+        }\n         return initialState;\n       } else {\n         app.rememberTargetTransitionsAndStoreState(event,\n           new AttemptFailedFinalStateSavedTransition(), RMAppState.FAILED,\n           RMAppState.FAILED);\n         return RMAppState.FINAL_SAVING;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public RMAppState transition(RMAppImpl app, RMAppEvent event) {\n      if (!app.submissionContext.getUnmanagedAM()\n          \u0026\u0026 app.attempts.size() \u003c app.maxAppAttempts) {\n        boolean transferStateFromPreviousAttempt \u003d false;\n        RMAppFailedAttemptEvent failedEvent \u003d (RMAppFailedAttemptEvent) event;\n        transferStateFromPreviousAttempt \u003d\n            failedEvent.getTransferStateFromPreviousAttempt();\n\n        RMAppAttempt oldAttempt \u003d app.currentAttempt;\n        app.createAndStartNewAttempt(transferStateFromPreviousAttempt);\n        // Transfer the state from the previous attempt to the current attempt.\n        // Note that the previous failed attempt may still be collecting the\n        // container events from the scheduler and update its data structures\n        // before the new attempt is created.\n        if (transferStateFromPreviousAttempt) {\n          ((RMAppAttemptImpl) app.currentAttempt)\n            .transferStateFromPreviousAttempt(oldAttempt);\n        }\n        return initialState;\n      } else {\n        app.rememberTargetTransitionsAndStoreState(event,\n          new AttemptFailedFinalStateSavedTransition(), RMAppState.FAILED,\n          RMAppState.FAILED);\n        return RMAppState.FINAL_SAVING;\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java",
      "extendedDetails": {}
    },
    "9f4d4e27fb1760b352cc5b301cd65a50d2d43ff6": {
      "type": "Ybodychange",
      "commitMessage": "YARN-891. Modified ResourceManager state-store to remember completed applications so that clients can get information about them post RM-restart. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1537560 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "31/10/13 10:25 AM",
      "commitName": "9f4d4e27fb1760b352cc5b301cd65a50d2d43ff6",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "24/09/13 6:07 PM",
      "commitNameOld": "929f96ee14b95494c092f84c92878d3f5cd681fd",
      "commitAuthorOld": "Bikas Saha",
      "daysBetweenCommits": 36.68,
      "commitsBetweenForRepo": 266,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,12 @@\n     public RMAppState transition(RMAppImpl app, RMAppEvent event) {\n-\n-      RMAppFailedAttemptEvent failedEvent \u003d ((RMAppFailedAttemptEvent) event);\n-      boolean retryApp \u003d true;\n-      String msg \u003d null;\n-      if (app.submissionContext.getUnmanagedAM()) {\n-        // RM does not manage the AM. Do not retry\n-        retryApp \u003d false;\n-        msg \u003d \"Unmanaged application \" + app.getApplicationId()\n-            + \" failed due to \" + failedEvent.getDiagnostics()\n-            + \". Failing the application.\";\n-      } else if (app.attempts.size() \u003e\u003d app.maxAppAttempts) {\n-        retryApp \u003d false;\n-        msg \u003d \"Application \" + app.getApplicationId() + \" failed \"\n-            + app.maxAppAttempts + \" times due to \" + failedEvent.getDiagnostics()\n-            + \". Failing the application.\";\n-      }\n-\n-      if (retryApp) {\n+      if (!app.submissionContext.getUnmanagedAM()\n+          \u0026\u0026 app.attempts.size() \u003c app.maxAppAttempts) {\n         app.createNewAttempt(true);\n         return initialState;\n       } else {\n-        LOG.info(msg);\n-        app.diagnostics.append(msg);\n-        // Inform the node for app-finish\n-        FINAL_TRANSITION.transition(app, event);\n-        return RMAppState.FAILED;\n+        app.rememberTargetTransitionsAndStoreState(event,\n+          new AttemptFailedFinalStateSavedTransition(), RMAppState.FAILED,\n+          RMAppState.FAILED);\n+        return RMAppState.FINAL_SAVING;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public RMAppState transition(RMAppImpl app, RMAppEvent event) {\n      if (!app.submissionContext.getUnmanagedAM()\n          \u0026\u0026 app.attempts.size() \u003c app.maxAppAttempts) {\n        app.createNewAttempt(true);\n        return initialState;\n      } else {\n        app.rememberTargetTransitionsAndStoreState(event,\n          new AttemptFailedFinalStateSavedTransition(), RMAppState.FAILED,\n          RMAppState.FAILED);\n        return RMAppState.FINAL_SAVING;\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java",
      "extendedDetails": {}
    },
    "07573640147bb4cf3568078acae7b245e9299cf7": {
      "type": "Ybodychange",
      "commitMessage": "YARN-378. Fix RM to make the AM max attempts/retries to be configurable per application by clients. Contributed by Zhijie Shen.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1460895 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/03/13 2:11 PM",
      "commitName": "07573640147bb4cf3568078acae7b245e9299cf7",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "20/02/13 7:35 AM",
      "commitNameOld": "efaaf586053b3275209e3d992df68d6a04d6181f",
      "commitAuthorOld": "Thomas Graves",
      "daysBetweenCommits": 33.23,
      "commitsBetweenForRepo": 170,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,29 @@\n     public RMAppState transition(RMAppImpl app, RMAppEvent event) {\n \n       RMAppFailedAttemptEvent failedEvent \u003d ((RMAppFailedAttemptEvent) event);\n       boolean retryApp \u003d true;\n       String msg \u003d null;\n       if (app.submissionContext.getUnmanagedAM()) {\n         // RM does not manage the AM. Do not retry\n         retryApp \u003d false;\n         msg \u003d \"Unmanaged application \" + app.getApplicationId()\n             + \" failed due to \" + failedEvent.getDiagnostics()\n             + \". Failing the application.\";\n-      } else if (app.attempts.size() \u003e\u003d app.maxRetries) {\n+      } else if (app.attempts.size() \u003e\u003d app.maxAppAttempts) {\n         retryApp \u003d false;\n         msg \u003d \"Application \" + app.getApplicationId() + \" failed \"\n-            + app.maxRetries + \" times due to \" + failedEvent.getDiagnostics()\n+            + app.maxAppAttempts + \" times due to \" + failedEvent.getDiagnostics()\n             + \". Failing the application.\";\n       }\n \n       if (retryApp) {\n         app.createNewAttempt(true);\n         return initialState;\n       } else {\n         LOG.info(msg);\n         app.diagnostics.append(msg);\n         // Inform the node for app-finish\n         FINAL_TRANSITION.transition(app, event);\n         return RMAppState.FAILED;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public RMAppState transition(RMAppImpl app, RMAppEvent event) {\n\n      RMAppFailedAttemptEvent failedEvent \u003d ((RMAppFailedAttemptEvent) event);\n      boolean retryApp \u003d true;\n      String msg \u003d null;\n      if (app.submissionContext.getUnmanagedAM()) {\n        // RM does not manage the AM. Do not retry\n        retryApp \u003d false;\n        msg \u003d \"Unmanaged application \" + app.getApplicationId()\n            + \" failed due to \" + failedEvent.getDiagnostics()\n            + \". Failing the application.\";\n      } else if (app.attempts.size() \u003e\u003d app.maxAppAttempts) {\n        retryApp \u003d false;\n        msg \u003d \"Application \" + app.getApplicationId() + \" failed \"\n            + app.maxAppAttempts + \" times due to \" + failedEvent.getDiagnostics()\n            + \". Failing the application.\";\n      }\n\n      if (retryApp) {\n        app.createNewAttempt(true);\n        return initialState;\n      } else {\n        LOG.info(msg);\n        app.diagnostics.append(msg);\n        // Inform the node for app-finish\n        FINAL_TRANSITION.transition(app, event);\n        return RMAppState.FAILED;\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java",
      "extendedDetails": {}
    },
    "6cd0736cc57849e4f7c5d38a3986432a9717fe39": {
      "type": "Ybodychange",
      "commitMessage": "YARN-230. RM Restart phase 1 - includes support for saving/restarting all applications on an RM bounce. Contributed by Bikas Saha.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1423758 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/12/12 8:21 PM",
      "commitName": "6cd0736cc57849e4f7c5d38a3986432a9717fe39",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "28/11/12 5:56 PM",
      "commitNameOld": "1943fdbec613715f3cdc3ca60cbd273115f28299",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 20.1,
      "commitsBetweenForRepo": 77,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,29 @@\n     public RMAppState transition(RMAppImpl app, RMAppEvent event) {\n \n       RMAppFailedAttemptEvent failedEvent \u003d ((RMAppFailedAttemptEvent) event);\n       boolean retryApp \u003d true;\n       String msg \u003d null;\n       if (app.submissionContext.getUnmanagedAM()) {\n         // RM does not manage the AM. Do not retry\n         retryApp \u003d false;\n         msg \u003d \"Unmanaged application \" + app.getApplicationId()\n             + \" failed due to \" + failedEvent.getDiagnostics()\n             + \". Failing the application.\";\n-      } else if (app.attempts.size() \u003d\u003d app.maxRetries) {\n+      } else if (app.attempts.size() \u003e\u003d app.maxRetries) {\n         retryApp \u003d false;\n         msg \u003d \"Application \" + app.getApplicationId() + \" failed \"\n             + app.maxRetries + \" times due to \" + failedEvent.getDiagnostics()\n             + \". Failing the application.\";\n       }\n \n       if (retryApp) {\n-        app.createNewAttempt();\n+        app.createNewAttempt(true);\n         return initialState;\n       } else {\n         LOG.info(msg);\n         app.diagnostics.append(msg);\n         // Inform the node for app-finish\n         FINAL_TRANSITION.transition(app, event);\n         return RMAppState.FAILED;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public RMAppState transition(RMAppImpl app, RMAppEvent event) {\n\n      RMAppFailedAttemptEvent failedEvent \u003d ((RMAppFailedAttemptEvent) event);\n      boolean retryApp \u003d true;\n      String msg \u003d null;\n      if (app.submissionContext.getUnmanagedAM()) {\n        // RM does not manage the AM. Do not retry\n        retryApp \u003d false;\n        msg \u003d \"Unmanaged application \" + app.getApplicationId()\n            + \" failed due to \" + failedEvent.getDiagnostics()\n            + \". Failing the application.\";\n      } else if (app.attempts.size() \u003e\u003d app.maxRetries) {\n        retryApp \u003d false;\n        msg \u003d \"Application \" + app.getApplicationId() + \" failed \"\n            + app.maxRetries + \" times due to \" + failedEvent.getDiagnostics()\n            + \". Failing the application.\";\n      }\n\n      if (retryApp) {\n        app.createNewAttempt(true);\n        return initialState;\n      } else {\n        LOG.info(msg);\n        app.diagnostics.append(msg);\n        // Inform the node for app-finish\n        FINAL_TRANSITION.transition(app, event);\n        return RMAppState.FAILED;\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java",
      "extendedDetails": {}
    },
    "e1fdf62123625e4ba399af02f8aad500637d29d1": {
      "type": "Yfilerename",
      "commitMessage": "YARN-1. Promote YARN to be a sub-project of Apache Hadoop.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1370666 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/08/12 10:22 PM",
      "commitName": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "07/08/12 7:53 PM",
      "commitNameOld": "34554d1e11ee1d5b564d7d9ed3e6d55931d72749",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    public RMAppState transition(RMAppImpl app, RMAppEvent event) {\n\n      RMAppFailedAttemptEvent failedEvent \u003d ((RMAppFailedAttemptEvent) event);\n      boolean retryApp \u003d true;\n      String msg \u003d null;\n      if (app.submissionContext.getUnmanagedAM()) {\n        // RM does not manage the AM. Do not retry\n        retryApp \u003d false;\n        msg \u003d \"Unmanaged application \" + app.getApplicationId()\n            + \" failed due to \" + failedEvent.getDiagnostics()\n            + \". Failing the application.\";\n      } else if (app.attempts.size() \u003d\u003d app.maxRetries) {\n        retryApp \u003d false;\n        msg \u003d \"Application \" + app.getApplicationId() + \" failed \"\n            + app.maxRetries + \" times due to \" + failedEvent.getDiagnostics()\n            + \". Failing the application.\";\n      }\n\n      if (retryApp) {\n        app.createNewAttempt();\n        return initialState;\n      } else {\n        LOG.info(msg);\n        app.diagnostics.append(msg);\n        // Inform the node for app-finish\n        FINAL_TRANSITION.transition(app, event);\n        return RMAppState.FAILED;\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java"
      }
    },
    "ae6cc14611a5898ed637a2e0f9df559f6c29093e": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-4427. Added an \u0027unmanaged\u0027 mode for AMs so as to ease development of new applications. Contributed by Bikas Saha.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1361813 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "15/07/12 2:46 PM",
      "commitName": "ae6cc14611a5898ed637a2e0f9df559f6c29093e",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "04/06/12 10:41 AM",
      "commitNameOld": "358eda0bfaaf24f2ff4b2ef9967a370ddcb0a336",
      "commitAuthorOld": "Thomas Graves",
      "daysBetweenCommits": 41.17,
      "commitsBetweenForRepo": 215,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,18 +1,29 @@\n     public RMAppState transition(RMAppImpl app, RMAppEvent event) {\n \n-      RMAppFailedAttemptEvent failedEvent \u003d ((RMAppFailedAttemptEvent)event);\n-      if (app.attempts.size() \u003d\u003d app.maxRetries) {\n-        String msg \u003d \"Application \" + app.getApplicationId()\n-        + \" failed \" + app.maxRetries\n-        + \" times due to \" + failedEvent.getDiagnostics()\n-        + \". Failing the application.\";\n+      RMAppFailedAttemptEvent failedEvent \u003d ((RMAppFailedAttemptEvent) event);\n+      boolean retryApp \u003d true;\n+      String msg \u003d null;\n+      if (app.submissionContext.getUnmanagedAM()) {\n+        // RM does not manage the AM. Do not retry\n+        retryApp \u003d false;\n+        msg \u003d \"Unmanaged application \" + app.getApplicationId()\n+            + \" failed due to \" + failedEvent.getDiagnostics()\n+            + \". Failing the application.\";\n+      } else if (app.attempts.size() \u003d\u003d app.maxRetries) {\n+        retryApp \u003d false;\n+        msg \u003d \"Application \" + app.getApplicationId() + \" failed \"\n+            + app.maxRetries + \" times due to \" + failedEvent.getDiagnostics()\n+            + \". Failing the application.\";\n+      }\n+\n+      if (retryApp) {\n+        app.createNewAttempt();\n+        return initialState;\n+      } else {\n         LOG.info(msg);\n         app.diagnostics.append(msg);\n         // Inform the node for app-finish\n         FINAL_TRANSITION.transition(app, event);\n         return RMAppState.FAILED;\n       }\n-\n-      app.createNewAttempt();\n-      return initialState;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public RMAppState transition(RMAppImpl app, RMAppEvent event) {\n\n      RMAppFailedAttemptEvent failedEvent \u003d ((RMAppFailedAttemptEvent) event);\n      boolean retryApp \u003d true;\n      String msg \u003d null;\n      if (app.submissionContext.getUnmanagedAM()) {\n        // RM does not manage the AM. Do not retry\n        retryApp \u003d false;\n        msg \u003d \"Unmanaged application \" + app.getApplicationId()\n            + \" failed due to \" + failedEvent.getDiagnostics()\n            + \". Failing the application.\";\n      } else if (app.attempts.size() \u003d\u003d app.maxRetries) {\n        retryApp \u003d false;\n        msg \u003d \"Application \" + app.getApplicationId() + \" failed \"\n            + app.maxRetries + \" times due to \" + failedEvent.getDiagnostics()\n            + \". Failing the application.\";\n      }\n\n      if (retryApp) {\n        app.createNewAttempt();\n        return initialState;\n      } else {\n        LOG.info(msg);\n        app.diagnostics.append(msg);\n        // Inform the node for app-finish\n        FINAL_TRANSITION.transition(app, event);\n        return RMAppState.FAILED;\n      }\n    }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java",
      "extendedDetails": {}
    },
    "a5c9ede1433871fcf4e2e802ee2a65950ecd1e72": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2952. Fixed ResourceManager/MR-client to consume diagnostics for AM failures in a couple of corner cases. Contributed by Arun C Murthy.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1175403 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/09/11 7:46 AM",
      "commitName": "a5c9ede1433871fcf4e2e802ee2a65950ecd1e72",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "19/09/11 4:56 PM",
      "commitNameOld": "bbfd81503cfd98aaeb0334ba356076bfdf6bbd9f",
      "commitAuthorOld": "Mahadev Konar",
      "daysBetweenCommits": 5.62,
      "commitsBetweenForRepo": 37,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,16 +1,18 @@\n     public RMAppState transition(RMAppImpl app, RMAppEvent event) {\n-\n+      \n+      RMAppFailedAttemptEvent failedEvent \u003d ((RMAppFailedAttemptEvent)event);\n       if (app.attempts.size() \u003d\u003d app.maxRetries) {\n         String msg \u003d \"Application \" + app.getApplicationId()\n         + \" failed \" + app.maxRetries\n-        + \" times. Failing the application.\";\n+        + \" times due to \" + failedEvent.getDiagnostics()\n+        + \". Failing the application.\";\n         LOG.info(msg);\n         app.diagnostics.append(msg);\n         // Inform the node for app-finish\n         FINAL_TRANSITION.transition(app, event);\n         return RMAppState.FAILED;\n       }\n \n       app.createNewAttempt();     \n       return initialState;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public RMAppState transition(RMAppImpl app, RMAppEvent event) {\n      \n      RMAppFailedAttemptEvent failedEvent \u003d ((RMAppFailedAttemptEvent)event);\n      if (app.attempts.size() \u003d\u003d app.maxRetries) {\n        String msg \u003d \"Application \" + app.getApplicationId()\n        + \" failed \" + app.maxRetries\n        + \" times due to \" + failedEvent.getDiagnostics()\n        + \". Failing the application.\";\n        LOG.info(msg);\n        app.diagnostics.append(msg);\n        // Inform the node for app-finish\n        FINAL_TRANSITION.transition(app, event);\n        return RMAppState.FAILED;\n      }\n\n      app.createNewAttempt();     \n      return initialState;\n    }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java",
      "extendedDetails": {}
    },
    "f2b91a8367a762091482074505618b570a520b19": {
      "type": "Ybodychange",
      "commitMessage": " MAPREDUCE-2807. Fix AM restart and client redirection. Contributed by Sharad Agarwal.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161408 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 11:35 PM",
      "commitName": "f2b91a8367a762091482074505618b570a520b19",
      "commitAuthor": "Sharad Agarwal",
      "commitDateOld": "24/08/11 5:14 PM",
      "commitNameOld": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.26,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,26 +1,16 @@\n     public RMAppState transition(RMAppImpl app, RMAppEvent event) {\n \n       if (app.attempts.size() \u003d\u003d app.maxRetries) {\n-        app.diagnostics.append(\"Application \" + app.getApplicationId()\n-            + \" failed \" + app.maxRetries\n-            + \" times. Failing the application.\");\n+        String msg \u003d \"Application \" + app.getApplicationId()\n+        + \" failed \" + app.maxRetries\n+        + \" times. Failing the application.\";\n+        LOG.info(msg);\n+        app.diagnostics.append(msg);\n         // Inform the node for app-finish\n         FINAL_TRANSITION.transition(app, event);\n         return RMAppState.FAILED;\n       }\n \n-      ApplicationAttemptId appAttemptId \u003d Records\n-          .newRecord(ApplicationAttemptId.class);\n-      appAttemptId.setApplicationId(app.applicationId);\n-      appAttemptId.setAttemptId(app.attempts.size() + 1);\n-\n-      // Create a new attempt.\n-      RMAppAttempt attempt \u003d new RMAppAttemptImpl(appAttemptId,\n-          app.clientTokenStr, app.rmContext, app.scheduler,\n-          app.masterService, app.submissionContext);\n-      app.attempts.put(appAttemptId, attempt);\n-      app.currentAttempt \u003d attempt;\n-      app.dispatcher.getEventHandler().handle(\n-          new RMAppAttemptEvent(appAttemptId, RMAppAttemptEventType.START));\n+      app.createNewAttempt();     \n       return initialState;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public RMAppState transition(RMAppImpl app, RMAppEvent event) {\n\n      if (app.attempts.size() \u003d\u003d app.maxRetries) {\n        String msg \u003d \"Application \" + app.getApplicationId()\n        + \" failed \" + app.maxRetries\n        + \" times. Failing the application.\";\n        LOG.info(msg);\n        app.diagnostics.append(msg);\n        // Inform the node for app-finish\n        FINAL_TRANSITION.transition(app, event);\n        return RMAppState.FAILED;\n      }\n\n      app.createNewAttempt();     \n      return initialState;\n    }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    public RMAppState transition(RMAppImpl app, RMAppEvent event) {\n\n      if (app.attempts.size() \u003d\u003d app.maxRetries) {\n        app.diagnostics.append(\"Application \" + app.getApplicationId()\n            + \" failed \" + app.maxRetries\n            + \" times. Failing the application.\");\n        // Inform the node for app-finish\n        FINAL_TRANSITION.transition(app, event);\n        return RMAppState.FAILED;\n      }\n\n      ApplicationAttemptId appAttemptId \u003d Records\n          .newRecord(ApplicationAttemptId.class);\n      appAttemptId.setApplicationId(app.applicationId);\n      appAttemptId.setAttemptId(app.attempts.size() + 1);\n\n      // Create a new attempt.\n      RMAppAttempt attempt \u003d new RMAppAttemptImpl(appAttemptId,\n          app.clientTokenStr, app.rmContext, app.scheduler,\n          app.masterService, app.submissionContext);\n      app.attempts.put(appAttemptId, attempt);\n      app.currentAttempt \u003d attempt;\n      app.dispatcher.getEventHandler().handle(\n          new RMAppAttemptEvent(appAttemptId, RMAppAttemptEventType.START));\n      return initialState;\n    }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java",
        "newPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java"
      }
    },
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-279. MapReduce 2.0. Merging MR-279 branch into trunk. Contributed by Arun C Murthy, Christopher Douglas, Devaraj Das, Greg Roelofs, Jeffrey Naisbitt, Josh Wills, Jonathan Eagles, Krishna Ramachandran, Luke Lu, Mahadev Konar, Robert Evans, Sharad Agarwal, Siddharth Seth, Thomas Graves, and Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159166 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/08/11 4:07 AM",
      "commitName": "dbecbe5dfe50f834fc3b8401709079e9470cc517",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,26 @@\n+    public RMAppState transition(RMAppImpl app, RMAppEvent event) {\n+\n+      if (app.attempts.size() \u003d\u003d app.maxRetries) {\n+        app.diagnostics.append(\"Application \" + app.getApplicationId()\n+            + \" failed \" + app.maxRetries\n+            + \" times. Failing the application.\");\n+        // Inform the node for app-finish\n+        FINAL_TRANSITION.transition(app, event);\n+        return RMAppState.FAILED;\n+      }\n+\n+      ApplicationAttemptId appAttemptId \u003d Records\n+          .newRecord(ApplicationAttemptId.class);\n+      appAttemptId.setApplicationId(app.applicationId);\n+      appAttemptId.setAttemptId(app.attempts.size() + 1);\n+\n+      // Create a new attempt.\n+      RMAppAttempt attempt \u003d new RMAppAttemptImpl(appAttemptId,\n+          app.clientTokenStr, app.rmContext, app.scheduler,\n+          app.masterService, app.submissionContext);\n+      app.attempts.put(appAttemptId, attempt);\n+      app.currentAttempt \u003d attempt;\n+      app.dispatcher.getEventHandler().handle(\n+          new RMAppAttemptEvent(appAttemptId, RMAppAttemptEventType.START));\n+      return initialState;\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    public RMAppState transition(RMAppImpl app, RMAppEvent event) {\n\n      if (app.attempts.size() \u003d\u003d app.maxRetries) {\n        app.diagnostics.append(\"Application \" + app.getApplicationId()\n            + \" failed \" + app.maxRetries\n            + \" times. Failing the application.\");\n        // Inform the node for app-finish\n        FINAL_TRANSITION.transition(app, event);\n        return RMAppState.FAILED;\n      }\n\n      ApplicationAttemptId appAttemptId \u003d Records\n          .newRecord(ApplicationAttemptId.class);\n      appAttemptId.setApplicationId(app.applicationId);\n      appAttemptId.setAttemptId(app.attempts.size() + 1);\n\n      // Create a new attempt.\n      RMAppAttempt attempt \u003d new RMAppAttemptImpl(appAttemptId,\n          app.clientTokenStr, app.rmContext, app.scheduler,\n          app.masterService, app.submissionContext);\n      app.attempts.put(appAttemptId, attempt);\n      app.currentAttempt \u003d attempt;\n      app.dispatcher.getEventHandler().handle(\n          new RMAppAttemptEvent(appAttemptId, RMAppAttemptEventType.START));\n      return initialState;\n    }",
      "path": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/rmapp/RMAppImpl.java"
    }
  }
}