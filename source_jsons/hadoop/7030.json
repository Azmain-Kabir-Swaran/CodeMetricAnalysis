{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "Checkpointer.java",
  "functionName": "doCheckpoint",
  "functionId": "doCheckpoint",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/Checkpointer.java",
  "functionStartLine": 183,
  "functionEndLine": 288,
  "numCommitsSeen": 37,
  "timeTaken": 7828,
  "changeHistory": [
    "b1fce2b8b14c4ce43f7098a269ac2b95304db0ce",
    "ff0b99eafeda035ebe0dc82cfe689808047a8893",
    "a49cc74b4c72195dee1dfb6f9548e5e411dff553",
    "ab3c4cff4af338caaa23be0ec383fc1fe473714f",
    "6d4eee718a3fe1450a627128eb94728011bd9b68",
    "71de367c5e80ea76d1e8d21f0216cd6b879dcee5",
    "75ead273bea8a7dad61c4f99c3a16cab2697c498",
    "a4e0ff5e052abad498595ee198b49c5310c9ec0d",
    "94a1632fcb677fda6f4d812614026417f1d0a360",
    "dbd22b23c2d68b97b4da47215897906f06f978e3",
    "0f595915a388305edbb3ce928415571811d304e8",
    "e9a17c8ce0656a4e5d47401ca22a575c5f5f66db",
    "e3d2e4c156851de7dac16154521a2e06ea83ec7b",
    "573c41c2666e084f3988a288bb40d2305fc23d8f",
    "5b8dcb20a2fad2e7e9dee56c451f68f9d865b5ae",
    "20a6560bdfd8c4e3b6c3ac9b0f0f62d32e3a2191",
    "64c019cccc266b9896746d45e314cc4a59ba2e6e",
    "06e84a1bca19bd01568a3095e33944d4d6387fd3",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "d86f3183d93714ba078416af4f609d26376eadb0",
    "eb6e44b1ba58ed971360a39ea5d5ce02ae65aa0f",
    "28e6a4e44a3e920dcaf858f9a74a6358226b3a63",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc"
  ],
  "changeHistoryShort": {
    "b1fce2b8b14c4ce43f7098a269ac2b95304db0ce": "Ybodychange",
    "ff0b99eafeda035ebe0dc82cfe689808047a8893": "Ybodychange",
    "a49cc74b4c72195dee1dfb6f9548e5e411dff553": "Ybodychange",
    "ab3c4cff4af338caaa23be0ec383fc1fe473714f": "Ybodychange",
    "6d4eee718a3fe1450a627128eb94728011bd9b68": "Ybodychange",
    "71de367c5e80ea76d1e8d21f0216cd6b879dcee5": "Ybodychange",
    "75ead273bea8a7dad61c4f99c3a16cab2697c498": "Ybodychange",
    "a4e0ff5e052abad498595ee198b49c5310c9ec0d": "Ybodychange",
    "94a1632fcb677fda6f4d812614026417f1d0a360": "Ybodychange",
    "dbd22b23c2d68b97b4da47215897906f06f978e3": "Ybodychange",
    "0f595915a388305edbb3ce928415571811d304e8": "Ybodychange",
    "e9a17c8ce0656a4e5d47401ca22a575c5f5f66db": "Ybodychange",
    "e3d2e4c156851de7dac16154521a2e06ea83ec7b": "Ybodychange",
    "573c41c2666e084f3988a288bb40d2305fc23d8f": "Ybodychange",
    "5b8dcb20a2fad2e7e9dee56c451f68f9d865b5ae": "Ybodychange",
    "20a6560bdfd8c4e3b6c3ac9b0f0f62d32e3a2191": "Ybodychange",
    "64c019cccc266b9896746d45e314cc4a59ba2e6e": "Ybodychange",
    "06e84a1bca19bd01568a3095e33944d4d6387fd3": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "d86f3183d93714ba078416af4f609d26376eadb0": "Yfilerename",
    "eb6e44b1ba58ed971360a39ea5d5ce02ae65aa0f": "Ybodychange",
    "28e6a4e44a3e920dcaf858f9a74a6358226b3a63": "Ybodychange",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yintroduced"
  },
  "changeHistoryDetails": {
    "b1fce2b8b14c4ce43f7098a269ac2b95304db0ce": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11209. SNN can\u0027t checkpoint when rolling upgrade is not finalized. Contributed by Xiaoyu Yao.\n",
      "commitDate": "17/01/17 2:33 PM",
      "commitName": "b1fce2b8b14c4ce43f7098a269ac2b95304db0ce",
      "commitAuthor": "Xiaoyu Yao",
      "commitDateOld": "14/11/16 11:05 AM",
      "commitNameOld": "ff0b99eafeda035ebe0dc82cfe689808047a8893",
      "commitAuthorOld": "Zhe Zhang",
      "daysBetweenCommits": 64.14,
      "commitsBetweenForRepo": 332,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,106 +1,106 @@\n   void doCheckpoint() throws IOException {\n     BackupImage bnImage \u003d getFSImage();\n     NNStorage bnStorage \u003d bnImage.getStorage();\n \n     long startTime \u003d monotonicNow();\n     bnImage.freezeNamespaceAtNextRoll();\n     \n     NamenodeCommand cmd \u003d \n       getRemoteNamenodeProxy().startCheckpoint(backupNode.getRegistration());\n     CheckpointCommand cpCmd \u003d null;\n     switch(cmd.getAction()) {\n       case NamenodeProtocol.ACT_SHUTDOWN:\n         shutdown();\n         throw new IOException(\"Name-node \" + backupNode.nnRpcAddress\n                                            + \" requested shutdown.\");\n       case NamenodeProtocol.ACT_CHECKPOINT:\n         cpCmd \u003d (CheckpointCommand)cmd;\n         break;\n       default:\n         throw new IOException(\"Unsupported NamenodeCommand: \"+cmd.getAction());\n     }\n \n     bnImage.waitUntilNamespaceFrozen();\n     \n     CheckpointSignature sig \u003d cpCmd.getSignature();\n \n     // Make sure we\u0027re talking to the same NN!\n     sig.validateStorageInfo(bnImage);\n \n     long lastApplied \u003d bnImage.getLastAppliedTxId();\n     LOG.debug(\"Doing checkpoint. Last applied: \" + lastApplied);\n     RemoteEditLogManifest manifest \u003d\n       getRemoteNamenodeProxy().getEditLogManifest(bnImage.getLastAppliedTxId() + 1);\n \n     boolean needReloadImage \u003d false;\n     if (!manifest.getLogs().isEmpty()) {\n       RemoteEditLog firstRemoteLog \u003d manifest.getLogs().get(0);\n       // we don\u0027t have enough logs to roll forward using only logs. Need\n       // to download and load the image.\n       if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n         LOG.info(\"Unable to roll forward using only logs. Downloading \" +\n             \"image with txid \" + sig.mostRecentCheckpointTxId);\n         MD5Hash downloadedHash \u003d TransferFsImage.downloadImageToStorage(\n             backupNode.nnHttpAddress, sig.mostRecentCheckpointTxId, bnStorage,\n             true, false);\n         bnImage.saveDigestAndRenameCheckpointImage(NameNodeFile.IMAGE,\n             sig.mostRecentCheckpointTxId, downloadedHash);\n         lastApplied \u003d sig.mostRecentCheckpointTxId;\n         needReloadImage \u003d true;\n       }\n \n       if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n         throw new IOException(\"No logs to roll forward from \" + lastApplied);\n       }\n   \n       // get edits files\n       for (RemoteEditLog log : manifest.getLogs()) {\n         TransferFsImage.downloadEditsToStorage(\n             backupNode.nnHttpAddress, log, bnStorage);\n       }\n \n       if(needReloadImage) {\n         LOG.info(\"Loading image with txid \" + sig.mostRecentCheckpointTxId);\n         File file \u003d bnStorage.findImageFile(NameNodeFile.IMAGE,\n             sig.mostRecentCheckpointTxId);\n         bnImage.reloadFromImageFile(file, backupNode.getNamesystem());\n       }\n       rollForwardByApplyingLogs(manifest, bnImage, backupNode.getNamesystem());\n     }\n     \n     long txid \u003d bnImage.getLastAppliedTxId();\n     \n     backupNode.namesystem.writeLock();\n     try {\n       backupNode.namesystem.setImageLoaded();\n       if(backupNode.namesystem.getBlocksTotal() \u003e 0) {\n         long completeBlocksTotal \u003d\n             backupNode.namesystem.getCompleteBlocksTotal();\n         backupNode.namesystem.getBlockManager().setBlockTotal(\n             completeBlocksTotal);\n       }\n       bnImage.saveFSImageInAllDirs(backupNode.getNamesystem(), txid);\n-      if (!backupNode.namesystem.isRollingUpgrade()) {\n-        bnStorage.writeAll();\n+      if (!backupNode.namenode.isRollingUpgrade()) {\n+        bnImage.updateStorageVersion();\n       }\n     } finally {\n       backupNode.namesystem.writeUnlock(\"doCheckpoint\");\n     }\n \n     if(cpCmd.needToReturnImage()) {\n       TransferFsImage.uploadImageFromStorage(backupNode.nnHttpAddress, conf,\n           bnStorage, NameNodeFile.IMAGE, txid);\n     }\n \n     getRemoteNamenodeProxy().endCheckpoint(backupNode.getRegistration(), sig);\n \n     if (backupNode.getRole() \u003d\u003d NamenodeRole.BACKUP) {\n       bnImage.convergeJournalSpool();\n     }\n     backupNode.setRegistration(); // keep registration up to date\n     \n     long imageSize \u003d bnImage.getStorage().getFsImageName(txid).length();\n     LOG.info(\"Checkpoint completed in \"\n         + (monotonicNow() - startTime)/1000 + \" seconds.\"\n         + \" New Image Size: \" + imageSize);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void doCheckpoint() throws IOException {\n    BackupImage bnImage \u003d getFSImage();\n    NNStorage bnStorage \u003d bnImage.getStorage();\n\n    long startTime \u003d monotonicNow();\n    bnImage.freezeNamespaceAtNextRoll();\n    \n    NamenodeCommand cmd \u003d \n      getRemoteNamenodeProxy().startCheckpoint(backupNode.getRegistration());\n    CheckpointCommand cpCmd \u003d null;\n    switch(cmd.getAction()) {\n      case NamenodeProtocol.ACT_SHUTDOWN:\n        shutdown();\n        throw new IOException(\"Name-node \" + backupNode.nnRpcAddress\n                                           + \" requested shutdown.\");\n      case NamenodeProtocol.ACT_CHECKPOINT:\n        cpCmd \u003d (CheckpointCommand)cmd;\n        break;\n      default:\n        throw new IOException(\"Unsupported NamenodeCommand: \"+cmd.getAction());\n    }\n\n    bnImage.waitUntilNamespaceFrozen();\n    \n    CheckpointSignature sig \u003d cpCmd.getSignature();\n\n    // Make sure we\u0027re talking to the same NN!\n    sig.validateStorageInfo(bnImage);\n\n    long lastApplied \u003d bnImage.getLastAppliedTxId();\n    LOG.debug(\"Doing checkpoint. Last applied: \" + lastApplied);\n    RemoteEditLogManifest manifest \u003d\n      getRemoteNamenodeProxy().getEditLogManifest(bnImage.getLastAppliedTxId() + 1);\n\n    boolean needReloadImage \u003d false;\n    if (!manifest.getLogs().isEmpty()) {\n      RemoteEditLog firstRemoteLog \u003d manifest.getLogs().get(0);\n      // we don\u0027t have enough logs to roll forward using only logs. Need\n      // to download and load the image.\n      if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n        LOG.info(\"Unable to roll forward using only logs. Downloading \" +\n            \"image with txid \" + sig.mostRecentCheckpointTxId);\n        MD5Hash downloadedHash \u003d TransferFsImage.downloadImageToStorage(\n            backupNode.nnHttpAddress, sig.mostRecentCheckpointTxId, bnStorage,\n            true, false);\n        bnImage.saveDigestAndRenameCheckpointImage(NameNodeFile.IMAGE,\n            sig.mostRecentCheckpointTxId, downloadedHash);\n        lastApplied \u003d sig.mostRecentCheckpointTxId;\n        needReloadImage \u003d true;\n      }\n\n      if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n        throw new IOException(\"No logs to roll forward from \" + lastApplied);\n      }\n  \n      // get edits files\n      for (RemoteEditLog log : manifest.getLogs()) {\n        TransferFsImage.downloadEditsToStorage(\n            backupNode.nnHttpAddress, log, bnStorage);\n      }\n\n      if(needReloadImage) {\n        LOG.info(\"Loading image with txid \" + sig.mostRecentCheckpointTxId);\n        File file \u003d bnStorage.findImageFile(NameNodeFile.IMAGE,\n            sig.mostRecentCheckpointTxId);\n        bnImage.reloadFromImageFile(file, backupNode.getNamesystem());\n      }\n      rollForwardByApplyingLogs(manifest, bnImage, backupNode.getNamesystem());\n    }\n    \n    long txid \u003d bnImage.getLastAppliedTxId();\n    \n    backupNode.namesystem.writeLock();\n    try {\n      backupNode.namesystem.setImageLoaded();\n      if(backupNode.namesystem.getBlocksTotal() \u003e 0) {\n        long completeBlocksTotal \u003d\n            backupNode.namesystem.getCompleteBlocksTotal();\n        backupNode.namesystem.getBlockManager().setBlockTotal(\n            completeBlocksTotal);\n      }\n      bnImage.saveFSImageInAllDirs(backupNode.getNamesystem(), txid);\n      if (!backupNode.namenode.isRollingUpgrade()) {\n        bnImage.updateStorageVersion();\n      }\n    } finally {\n      backupNode.namesystem.writeUnlock(\"doCheckpoint\");\n    }\n\n    if(cpCmd.needToReturnImage()) {\n      TransferFsImage.uploadImageFromStorage(backupNode.nnHttpAddress, conf,\n          bnStorage, NameNodeFile.IMAGE, txid);\n    }\n\n    getRemoteNamenodeProxy().endCheckpoint(backupNode.getRegistration(), sig);\n\n    if (backupNode.getRole() \u003d\u003d NamenodeRole.BACKUP) {\n      bnImage.convergeJournalSpool();\n    }\n    backupNode.setRegistration(); // keep registration up to date\n    \n    long imageSize \u003d bnImage.getStorage().getFsImageName(txid).length();\n    LOG.info(\"Checkpoint completed in \"\n        + (monotonicNow() - startTime)/1000 + \" seconds.\"\n        + \" New Image Size: \" + imageSize);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/Checkpointer.java",
      "extendedDetails": {}
    },
    "ff0b99eafeda035ebe0dc82cfe689808047a8893": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10872. Add MutableRate metrics for FSNamesystemLock operations. Contributed by Erik Krogen.\n",
      "commitDate": "14/11/16 11:05 AM",
      "commitName": "ff0b99eafeda035ebe0dc82cfe689808047a8893",
      "commitAuthor": "Zhe Zhang",
      "commitDateOld": "01/12/15 4:09 PM",
      "commitNameOld": "a49cc74b4c72195dee1dfb6f9548e5e411dff553",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 348.79,
      "commitsBetweenForRepo": 2459,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,106 +1,106 @@\n   void doCheckpoint() throws IOException {\n     BackupImage bnImage \u003d getFSImage();\n     NNStorage bnStorage \u003d bnImage.getStorage();\n \n     long startTime \u003d monotonicNow();\n     bnImage.freezeNamespaceAtNextRoll();\n     \n     NamenodeCommand cmd \u003d \n       getRemoteNamenodeProxy().startCheckpoint(backupNode.getRegistration());\n     CheckpointCommand cpCmd \u003d null;\n     switch(cmd.getAction()) {\n       case NamenodeProtocol.ACT_SHUTDOWN:\n         shutdown();\n         throw new IOException(\"Name-node \" + backupNode.nnRpcAddress\n                                            + \" requested shutdown.\");\n       case NamenodeProtocol.ACT_CHECKPOINT:\n         cpCmd \u003d (CheckpointCommand)cmd;\n         break;\n       default:\n         throw new IOException(\"Unsupported NamenodeCommand: \"+cmd.getAction());\n     }\n \n     bnImage.waitUntilNamespaceFrozen();\n     \n     CheckpointSignature sig \u003d cpCmd.getSignature();\n \n     // Make sure we\u0027re talking to the same NN!\n     sig.validateStorageInfo(bnImage);\n \n     long lastApplied \u003d bnImage.getLastAppliedTxId();\n     LOG.debug(\"Doing checkpoint. Last applied: \" + lastApplied);\n     RemoteEditLogManifest manifest \u003d\n       getRemoteNamenodeProxy().getEditLogManifest(bnImage.getLastAppliedTxId() + 1);\n \n     boolean needReloadImage \u003d false;\n     if (!manifest.getLogs().isEmpty()) {\n       RemoteEditLog firstRemoteLog \u003d manifest.getLogs().get(0);\n       // we don\u0027t have enough logs to roll forward using only logs. Need\n       // to download and load the image.\n       if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n         LOG.info(\"Unable to roll forward using only logs. Downloading \" +\n             \"image with txid \" + sig.mostRecentCheckpointTxId);\n         MD5Hash downloadedHash \u003d TransferFsImage.downloadImageToStorage(\n             backupNode.nnHttpAddress, sig.mostRecentCheckpointTxId, bnStorage,\n             true, false);\n         bnImage.saveDigestAndRenameCheckpointImage(NameNodeFile.IMAGE,\n             sig.mostRecentCheckpointTxId, downloadedHash);\n         lastApplied \u003d sig.mostRecentCheckpointTxId;\n         needReloadImage \u003d true;\n       }\n \n       if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n         throw new IOException(\"No logs to roll forward from \" + lastApplied);\n       }\n   \n       // get edits files\n       for (RemoteEditLog log : manifest.getLogs()) {\n         TransferFsImage.downloadEditsToStorage(\n             backupNode.nnHttpAddress, log, bnStorage);\n       }\n \n       if(needReloadImage) {\n         LOG.info(\"Loading image with txid \" + sig.mostRecentCheckpointTxId);\n         File file \u003d bnStorage.findImageFile(NameNodeFile.IMAGE,\n             sig.mostRecentCheckpointTxId);\n         bnImage.reloadFromImageFile(file, backupNode.getNamesystem());\n       }\n       rollForwardByApplyingLogs(manifest, bnImage, backupNode.getNamesystem());\n     }\n     \n     long txid \u003d bnImage.getLastAppliedTxId();\n     \n     backupNode.namesystem.writeLock();\n     try {\n       backupNode.namesystem.setImageLoaded();\n       if(backupNode.namesystem.getBlocksTotal() \u003e 0) {\n         long completeBlocksTotal \u003d\n             backupNode.namesystem.getCompleteBlocksTotal();\n         backupNode.namesystem.getBlockManager().setBlockTotal(\n             completeBlocksTotal);\n       }\n       bnImage.saveFSImageInAllDirs(backupNode.getNamesystem(), txid);\n       if (!backupNode.namesystem.isRollingUpgrade()) {\n         bnStorage.writeAll();\n       }\n     } finally {\n-      backupNode.namesystem.writeUnlock();\n+      backupNode.namesystem.writeUnlock(\"doCheckpoint\");\n     }\n \n     if(cpCmd.needToReturnImage()) {\n       TransferFsImage.uploadImageFromStorage(backupNode.nnHttpAddress, conf,\n           bnStorage, NameNodeFile.IMAGE, txid);\n     }\n \n     getRemoteNamenodeProxy().endCheckpoint(backupNode.getRegistration(), sig);\n \n     if (backupNode.getRole() \u003d\u003d NamenodeRole.BACKUP) {\n       bnImage.convergeJournalSpool();\n     }\n     backupNode.setRegistration(); // keep registration up to date\n     \n     long imageSize \u003d bnImage.getStorage().getFsImageName(txid).length();\n     LOG.info(\"Checkpoint completed in \"\n         + (monotonicNow() - startTime)/1000 + \" seconds.\"\n         + \" New Image Size: \" + imageSize);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void doCheckpoint() throws IOException {\n    BackupImage bnImage \u003d getFSImage();\n    NNStorage bnStorage \u003d bnImage.getStorage();\n\n    long startTime \u003d monotonicNow();\n    bnImage.freezeNamespaceAtNextRoll();\n    \n    NamenodeCommand cmd \u003d \n      getRemoteNamenodeProxy().startCheckpoint(backupNode.getRegistration());\n    CheckpointCommand cpCmd \u003d null;\n    switch(cmd.getAction()) {\n      case NamenodeProtocol.ACT_SHUTDOWN:\n        shutdown();\n        throw new IOException(\"Name-node \" + backupNode.nnRpcAddress\n                                           + \" requested shutdown.\");\n      case NamenodeProtocol.ACT_CHECKPOINT:\n        cpCmd \u003d (CheckpointCommand)cmd;\n        break;\n      default:\n        throw new IOException(\"Unsupported NamenodeCommand: \"+cmd.getAction());\n    }\n\n    bnImage.waitUntilNamespaceFrozen();\n    \n    CheckpointSignature sig \u003d cpCmd.getSignature();\n\n    // Make sure we\u0027re talking to the same NN!\n    sig.validateStorageInfo(bnImage);\n\n    long lastApplied \u003d bnImage.getLastAppliedTxId();\n    LOG.debug(\"Doing checkpoint. Last applied: \" + lastApplied);\n    RemoteEditLogManifest manifest \u003d\n      getRemoteNamenodeProxy().getEditLogManifest(bnImage.getLastAppliedTxId() + 1);\n\n    boolean needReloadImage \u003d false;\n    if (!manifest.getLogs().isEmpty()) {\n      RemoteEditLog firstRemoteLog \u003d manifest.getLogs().get(0);\n      // we don\u0027t have enough logs to roll forward using only logs. Need\n      // to download and load the image.\n      if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n        LOG.info(\"Unable to roll forward using only logs. Downloading \" +\n            \"image with txid \" + sig.mostRecentCheckpointTxId);\n        MD5Hash downloadedHash \u003d TransferFsImage.downloadImageToStorage(\n            backupNode.nnHttpAddress, sig.mostRecentCheckpointTxId, bnStorage,\n            true, false);\n        bnImage.saveDigestAndRenameCheckpointImage(NameNodeFile.IMAGE,\n            sig.mostRecentCheckpointTxId, downloadedHash);\n        lastApplied \u003d sig.mostRecentCheckpointTxId;\n        needReloadImage \u003d true;\n      }\n\n      if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n        throw new IOException(\"No logs to roll forward from \" + lastApplied);\n      }\n  \n      // get edits files\n      for (RemoteEditLog log : manifest.getLogs()) {\n        TransferFsImage.downloadEditsToStorage(\n            backupNode.nnHttpAddress, log, bnStorage);\n      }\n\n      if(needReloadImage) {\n        LOG.info(\"Loading image with txid \" + sig.mostRecentCheckpointTxId);\n        File file \u003d bnStorage.findImageFile(NameNodeFile.IMAGE,\n            sig.mostRecentCheckpointTxId);\n        bnImage.reloadFromImageFile(file, backupNode.getNamesystem());\n      }\n      rollForwardByApplyingLogs(manifest, bnImage, backupNode.getNamesystem());\n    }\n    \n    long txid \u003d bnImage.getLastAppliedTxId();\n    \n    backupNode.namesystem.writeLock();\n    try {\n      backupNode.namesystem.setImageLoaded();\n      if(backupNode.namesystem.getBlocksTotal() \u003e 0) {\n        long completeBlocksTotal \u003d\n            backupNode.namesystem.getCompleteBlocksTotal();\n        backupNode.namesystem.getBlockManager().setBlockTotal(\n            completeBlocksTotal);\n      }\n      bnImage.saveFSImageInAllDirs(backupNode.getNamesystem(), txid);\n      if (!backupNode.namesystem.isRollingUpgrade()) {\n        bnStorage.writeAll();\n      }\n    } finally {\n      backupNode.namesystem.writeUnlock(\"doCheckpoint\");\n    }\n\n    if(cpCmd.needToReturnImage()) {\n      TransferFsImage.uploadImageFromStorage(backupNode.nnHttpAddress, conf,\n          bnStorage, NameNodeFile.IMAGE, txid);\n    }\n\n    getRemoteNamenodeProxy().endCheckpoint(backupNode.getRegistration(), sig);\n\n    if (backupNode.getRole() \u003d\u003d NamenodeRole.BACKUP) {\n      bnImage.convergeJournalSpool();\n    }\n    backupNode.setRegistration(); // keep registration up to date\n    \n    long imageSize \u003d bnImage.getStorage().getFsImageName(txid).length();\n    LOG.info(\"Checkpoint completed in \"\n        + (monotonicNow() - startTime)/1000 + \" seconds.\"\n        + \" New Image Size: \" + imageSize);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/Checkpointer.java",
      "extendedDetails": {}
    },
    "a49cc74b4c72195dee1dfb6f9548e5e411dff553": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9129. Move the safemode block count into BlockManager. Contributed by Mingliang Liu.\n",
      "commitDate": "01/12/15 4:09 PM",
      "commitName": "a49cc74b4c72195dee1dfb6f9548e5e411dff553",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "23/10/15 2:01 PM",
      "commitNameOld": "ab3c4cff4af338caaa23be0ec383fc1fe473714f",
      "commitAuthorOld": "Zhe Zhang",
      "daysBetweenCommits": 39.13,
      "commitsBetweenForRepo": 296,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,105 +1,106 @@\n   void doCheckpoint() throws IOException {\n     BackupImage bnImage \u003d getFSImage();\n     NNStorage bnStorage \u003d bnImage.getStorage();\n \n     long startTime \u003d monotonicNow();\n     bnImage.freezeNamespaceAtNextRoll();\n     \n     NamenodeCommand cmd \u003d \n       getRemoteNamenodeProxy().startCheckpoint(backupNode.getRegistration());\n     CheckpointCommand cpCmd \u003d null;\n     switch(cmd.getAction()) {\n       case NamenodeProtocol.ACT_SHUTDOWN:\n         shutdown();\n         throw new IOException(\"Name-node \" + backupNode.nnRpcAddress\n                                            + \" requested shutdown.\");\n       case NamenodeProtocol.ACT_CHECKPOINT:\n         cpCmd \u003d (CheckpointCommand)cmd;\n         break;\n       default:\n         throw new IOException(\"Unsupported NamenodeCommand: \"+cmd.getAction());\n     }\n \n     bnImage.waitUntilNamespaceFrozen();\n     \n     CheckpointSignature sig \u003d cpCmd.getSignature();\n \n     // Make sure we\u0027re talking to the same NN!\n     sig.validateStorageInfo(bnImage);\n \n     long lastApplied \u003d bnImage.getLastAppliedTxId();\n     LOG.debug(\"Doing checkpoint. Last applied: \" + lastApplied);\n     RemoteEditLogManifest manifest \u003d\n       getRemoteNamenodeProxy().getEditLogManifest(bnImage.getLastAppliedTxId() + 1);\n \n     boolean needReloadImage \u003d false;\n     if (!manifest.getLogs().isEmpty()) {\n       RemoteEditLog firstRemoteLog \u003d manifest.getLogs().get(0);\n       // we don\u0027t have enough logs to roll forward using only logs. Need\n       // to download and load the image.\n       if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n         LOG.info(\"Unable to roll forward using only logs. Downloading \" +\n             \"image with txid \" + sig.mostRecentCheckpointTxId);\n         MD5Hash downloadedHash \u003d TransferFsImage.downloadImageToStorage(\n             backupNode.nnHttpAddress, sig.mostRecentCheckpointTxId, bnStorage,\n             true, false);\n         bnImage.saveDigestAndRenameCheckpointImage(NameNodeFile.IMAGE,\n             sig.mostRecentCheckpointTxId, downloadedHash);\n         lastApplied \u003d sig.mostRecentCheckpointTxId;\n         needReloadImage \u003d true;\n       }\n \n       if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n         throw new IOException(\"No logs to roll forward from \" + lastApplied);\n       }\n   \n       // get edits files\n       for (RemoteEditLog log : manifest.getLogs()) {\n         TransferFsImage.downloadEditsToStorage(\n             backupNode.nnHttpAddress, log, bnStorage);\n       }\n \n       if(needReloadImage) {\n         LOG.info(\"Loading image with txid \" + sig.mostRecentCheckpointTxId);\n         File file \u003d bnStorage.findImageFile(NameNodeFile.IMAGE,\n             sig.mostRecentCheckpointTxId);\n         bnImage.reloadFromImageFile(file, backupNode.getNamesystem());\n       }\n       rollForwardByApplyingLogs(manifest, bnImage, backupNode.getNamesystem());\n     }\n     \n     long txid \u003d bnImage.getLastAppliedTxId();\n     \n     backupNode.namesystem.writeLock();\n     try {\n       backupNode.namesystem.setImageLoaded();\n       if(backupNode.namesystem.getBlocksTotal() \u003e 0) {\n         long completeBlocksTotal \u003d\n             backupNode.namesystem.getCompleteBlocksTotal();\n-        backupNode.namesystem.setBlockTotal(completeBlocksTotal);\n+        backupNode.namesystem.getBlockManager().setBlockTotal(\n+            completeBlocksTotal);\n       }\n       bnImage.saveFSImageInAllDirs(backupNode.getNamesystem(), txid);\n       if (!backupNode.namesystem.isRollingUpgrade()) {\n         bnStorage.writeAll();\n       }\n     } finally {\n       backupNode.namesystem.writeUnlock();\n     }\n \n     if(cpCmd.needToReturnImage()) {\n       TransferFsImage.uploadImageFromStorage(backupNode.nnHttpAddress, conf,\n           bnStorage, NameNodeFile.IMAGE, txid);\n     }\n \n     getRemoteNamenodeProxy().endCheckpoint(backupNode.getRegistration(), sig);\n \n     if (backupNode.getRole() \u003d\u003d NamenodeRole.BACKUP) {\n       bnImage.convergeJournalSpool();\n     }\n     backupNode.setRegistration(); // keep registration up to date\n     \n     long imageSize \u003d bnImage.getStorage().getFsImageName(txid).length();\n     LOG.info(\"Checkpoint completed in \"\n         + (monotonicNow() - startTime)/1000 + \" seconds.\"\n         + \" New Image Size: \" + imageSize);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void doCheckpoint() throws IOException {\n    BackupImage bnImage \u003d getFSImage();\n    NNStorage bnStorage \u003d bnImage.getStorage();\n\n    long startTime \u003d monotonicNow();\n    bnImage.freezeNamespaceAtNextRoll();\n    \n    NamenodeCommand cmd \u003d \n      getRemoteNamenodeProxy().startCheckpoint(backupNode.getRegistration());\n    CheckpointCommand cpCmd \u003d null;\n    switch(cmd.getAction()) {\n      case NamenodeProtocol.ACT_SHUTDOWN:\n        shutdown();\n        throw new IOException(\"Name-node \" + backupNode.nnRpcAddress\n                                           + \" requested shutdown.\");\n      case NamenodeProtocol.ACT_CHECKPOINT:\n        cpCmd \u003d (CheckpointCommand)cmd;\n        break;\n      default:\n        throw new IOException(\"Unsupported NamenodeCommand: \"+cmd.getAction());\n    }\n\n    bnImage.waitUntilNamespaceFrozen();\n    \n    CheckpointSignature sig \u003d cpCmd.getSignature();\n\n    // Make sure we\u0027re talking to the same NN!\n    sig.validateStorageInfo(bnImage);\n\n    long lastApplied \u003d bnImage.getLastAppliedTxId();\n    LOG.debug(\"Doing checkpoint. Last applied: \" + lastApplied);\n    RemoteEditLogManifest manifest \u003d\n      getRemoteNamenodeProxy().getEditLogManifest(bnImage.getLastAppliedTxId() + 1);\n\n    boolean needReloadImage \u003d false;\n    if (!manifest.getLogs().isEmpty()) {\n      RemoteEditLog firstRemoteLog \u003d manifest.getLogs().get(0);\n      // we don\u0027t have enough logs to roll forward using only logs. Need\n      // to download and load the image.\n      if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n        LOG.info(\"Unable to roll forward using only logs. Downloading \" +\n            \"image with txid \" + sig.mostRecentCheckpointTxId);\n        MD5Hash downloadedHash \u003d TransferFsImage.downloadImageToStorage(\n            backupNode.nnHttpAddress, sig.mostRecentCheckpointTxId, bnStorage,\n            true, false);\n        bnImage.saveDigestAndRenameCheckpointImage(NameNodeFile.IMAGE,\n            sig.mostRecentCheckpointTxId, downloadedHash);\n        lastApplied \u003d sig.mostRecentCheckpointTxId;\n        needReloadImage \u003d true;\n      }\n\n      if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n        throw new IOException(\"No logs to roll forward from \" + lastApplied);\n      }\n  \n      // get edits files\n      for (RemoteEditLog log : manifest.getLogs()) {\n        TransferFsImage.downloadEditsToStorage(\n            backupNode.nnHttpAddress, log, bnStorage);\n      }\n\n      if(needReloadImage) {\n        LOG.info(\"Loading image with txid \" + sig.mostRecentCheckpointTxId);\n        File file \u003d bnStorage.findImageFile(NameNodeFile.IMAGE,\n            sig.mostRecentCheckpointTxId);\n        bnImage.reloadFromImageFile(file, backupNode.getNamesystem());\n      }\n      rollForwardByApplyingLogs(manifest, bnImage, backupNode.getNamesystem());\n    }\n    \n    long txid \u003d bnImage.getLastAppliedTxId();\n    \n    backupNode.namesystem.writeLock();\n    try {\n      backupNode.namesystem.setImageLoaded();\n      if(backupNode.namesystem.getBlocksTotal() \u003e 0) {\n        long completeBlocksTotal \u003d\n            backupNode.namesystem.getCompleteBlocksTotal();\n        backupNode.namesystem.getBlockManager().setBlockTotal(\n            completeBlocksTotal);\n      }\n      bnImage.saveFSImageInAllDirs(backupNode.getNamesystem(), txid);\n      if (!backupNode.namesystem.isRollingUpgrade()) {\n        bnStorage.writeAll();\n      }\n    } finally {\n      backupNode.namesystem.writeUnlock();\n    }\n\n    if(cpCmd.needToReturnImage()) {\n      TransferFsImage.uploadImageFromStorage(backupNode.nnHttpAddress, conf,\n          bnStorage, NameNodeFile.IMAGE, txid);\n    }\n\n    getRemoteNamenodeProxy().endCheckpoint(backupNode.getRegistration(), sig);\n\n    if (backupNode.getRole() \u003d\u003d NamenodeRole.BACKUP) {\n      bnImage.convergeJournalSpool();\n    }\n    backupNode.setRegistration(); // keep registration up to date\n    \n    long imageSize \u003d bnImage.getStorage().getFsImageName(txid).length();\n    LOG.info(\"Checkpoint completed in \"\n        + (monotonicNow() - startTime)/1000 + \" seconds.\"\n        + \" New Image Size: \" + imageSize);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/Checkpointer.java",
      "extendedDetails": {}
    },
    "ab3c4cff4af338caaa23be0ec383fc1fe473714f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8808. dfs.image.transfer.bandwidthPerSec should not apply to -bootstrapStandby. Contributed by Zhe Zhang.\n",
      "commitDate": "23/10/15 2:01 PM",
      "commitName": "ab3c4cff4af338caaa23be0ec383fc1fe473714f",
      "commitAuthor": "Zhe Zhang",
      "commitDateOld": "06/08/15 6:51 PM",
      "commitNameOld": "6d4eee718a3fe1450a627128eb94728011bd9b68",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 77.8,
      "commitsBetweenForRepo": 531,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,105 +1,105 @@\n   void doCheckpoint() throws IOException {\n     BackupImage bnImage \u003d getFSImage();\n     NNStorage bnStorage \u003d bnImage.getStorage();\n \n     long startTime \u003d monotonicNow();\n     bnImage.freezeNamespaceAtNextRoll();\n     \n     NamenodeCommand cmd \u003d \n       getRemoteNamenodeProxy().startCheckpoint(backupNode.getRegistration());\n     CheckpointCommand cpCmd \u003d null;\n     switch(cmd.getAction()) {\n       case NamenodeProtocol.ACT_SHUTDOWN:\n         shutdown();\n         throw new IOException(\"Name-node \" + backupNode.nnRpcAddress\n                                            + \" requested shutdown.\");\n       case NamenodeProtocol.ACT_CHECKPOINT:\n         cpCmd \u003d (CheckpointCommand)cmd;\n         break;\n       default:\n         throw new IOException(\"Unsupported NamenodeCommand: \"+cmd.getAction());\n     }\n \n     bnImage.waitUntilNamespaceFrozen();\n     \n     CheckpointSignature sig \u003d cpCmd.getSignature();\n \n     // Make sure we\u0027re talking to the same NN!\n     sig.validateStorageInfo(bnImage);\n \n     long lastApplied \u003d bnImage.getLastAppliedTxId();\n     LOG.debug(\"Doing checkpoint. Last applied: \" + lastApplied);\n     RemoteEditLogManifest manifest \u003d\n       getRemoteNamenodeProxy().getEditLogManifest(bnImage.getLastAppliedTxId() + 1);\n \n     boolean needReloadImage \u003d false;\n     if (!manifest.getLogs().isEmpty()) {\n       RemoteEditLog firstRemoteLog \u003d manifest.getLogs().get(0);\n       // we don\u0027t have enough logs to roll forward using only logs. Need\n       // to download and load the image.\n       if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n         LOG.info(\"Unable to roll forward using only logs. Downloading \" +\n             \"image with txid \" + sig.mostRecentCheckpointTxId);\n         MD5Hash downloadedHash \u003d TransferFsImage.downloadImageToStorage(\n             backupNode.nnHttpAddress, sig.mostRecentCheckpointTxId, bnStorage,\n-            true);\n+            true, false);\n         bnImage.saveDigestAndRenameCheckpointImage(NameNodeFile.IMAGE,\n             sig.mostRecentCheckpointTxId, downloadedHash);\n         lastApplied \u003d sig.mostRecentCheckpointTxId;\n         needReloadImage \u003d true;\n       }\n \n       if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n         throw new IOException(\"No logs to roll forward from \" + lastApplied);\n       }\n   \n       // get edits files\n       for (RemoteEditLog log : manifest.getLogs()) {\n         TransferFsImage.downloadEditsToStorage(\n             backupNode.nnHttpAddress, log, bnStorage);\n       }\n \n       if(needReloadImage) {\n         LOG.info(\"Loading image with txid \" + sig.mostRecentCheckpointTxId);\n         File file \u003d bnStorage.findImageFile(NameNodeFile.IMAGE,\n             sig.mostRecentCheckpointTxId);\n         bnImage.reloadFromImageFile(file, backupNode.getNamesystem());\n       }\n       rollForwardByApplyingLogs(manifest, bnImage, backupNode.getNamesystem());\n     }\n     \n     long txid \u003d bnImage.getLastAppliedTxId();\n     \n     backupNode.namesystem.writeLock();\n     try {\n       backupNode.namesystem.setImageLoaded();\n       if(backupNode.namesystem.getBlocksTotal() \u003e 0) {\n         long completeBlocksTotal \u003d\n             backupNode.namesystem.getCompleteBlocksTotal();\n         backupNode.namesystem.setBlockTotal(completeBlocksTotal);\n       }\n       bnImage.saveFSImageInAllDirs(backupNode.getNamesystem(), txid);\n       if (!backupNode.namesystem.isRollingUpgrade()) {\n         bnStorage.writeAll();\n       }\n     } finally {\n       backupNode.namesystem.writeUnlock();\n     }\n \n     if(cpCmd.needToReturnImage()) {\n       TransferFsImage.uploadImageFromStorage(backupNode.nnHttpAddress, conf,\n           bnStorage, NameNodeFile.IMAGE, txid);\n     }\n \n     getRemoteNamenodeProxy().endCheckpoint(backupNode.getRegistration(), sig);\n \n     if (backupNode.getRole() \u003d\u003d NamenodeRole.BACKUP) {\n       bnImage.convergeJournalSpool();\n     }\n     backupNode.setRegistration(); // keep registration up to date\n     \n     long imageSize \u003d bnImage.getStorage().getFsImageName(txid).length();\n     LOG.info(\"Checkpoint completed in \"\n         + (monotonicNow() - startTime)/1000 + \" seconds.\"\n         + \" New Image Size: \" + imageSize);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void doCheckpoint() throws IOException {\n    BackupImage bnImage \u003d getFSImage();\n    NNStorage bnStorage \u003d bnImage.getStorage();\n\n    long startTime \u003d monotonicNow();\n    bnImage.freezeNamespaceAtNextRoll();\n    \n    NamenodeCommand cmd \u003d \n      getRemoteNamenodeProxy().startCheckpoint(backupNode.getRegistration());\n    CheckpointCommand cpCmd \u003d null;\n    switch(cmd.getAction()) {\n      case NamenodeProtocol.ACT_SHUTDOWN:\n        shutdown();\n        throw new IOException(\"Name-node \" + backupNode.nnRpcAddress\n                                           + \" requested shutdown.\");\n      case NamenodeProtocol.ACT_CHECKPOINT:\n        cpCmd \u003d (CheckpointCommand)cmd;\n        break;\n      default:\n        throw new IOException(\"Unsupported NamenodeCommand: \"+cmd.getAction());\n    }\n\n    bnImage.waitUntilNamespaceFrozen();\n    \n    CheckpointSignature sig \u003d cpCmd.getSignature();\n\n    // Make sure we\u0027re talking to the same NN!\n    sig.validateStorageInfo(bnImage);\n\n    long lastApplied \u003d bnImage.getLastAppliedTxId();\n    LOG.debug(\"Doing checkpoint. Last applied: \" + lastApplied);\n    RemoteEditLogManifest manifest \u003d\n      getRemoteNamenodeProxy().getEditLogManifest(bnImage.getLastAppliedTxId() + 1);\n\n    boolean needReloadImage \u003d false;\n    if (!manifest.getLogs().isEmpty()) {\n      RemoteEditLog firstRemoteLog \u003d manifest.getLogs().get(0);\n      // we don\u0027t have enough logs to roll forward using only logs. Need\n      // to download and load the image.\n      if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n        LOG.info(\"Unable to roll forward using only logs. Downloading \" +\n            \"image with txid \" + sig.mostRecentCheckpointTxId);\n        MD5Hash downloadedHash \u003d TransferFsImage.downloadImageToStorage(\n            backupNode.nnHttpAddress, sig.mostRecentCheckpointTxId, bnStorage,\n            true, false);\n        bnImage.saveDigestAndRenameCheckpointImage(NameNodeFile.IMAGE,\n            sig.mostRecentCheckpointTxId, downloadedHash);\n        lastApplied \u003d sig.mostRecentCheckpointTxId;\n        needReloadImage \u003d true;\n      }\n\n      if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n        throw new IOException(\"No logs to roll forward from \" + lastApplied);\n      }\n  \n      // get edits files\n      for (RemoteEditLog log : manifest.getLogs()) {\n        TransferFsImage.downloadEditsToStorage(\n            backupNode.nnHttpAddress, log, bnStorage);\n      }\n\n      if(needReloadImage) {\n        LOG.info(\"Loading image with txid \" + sig.mostRecentCheckpointTxId);\n        File file \u003d bnStorage.findImageFile(NameNodeFile.IMAGE,\n            sig.mostRecentCheckpointTxId);\n        bnImage.reloadFromImageFile(file, backupNode.getNamesystem());\n      }\n      rollForwardByApplyingLogs(manifest, bnImage, backupNode.getNamesystem());\n    }\n    \n    long txid \u003d bnImage.getLastAppliedTxId();\n    \n    backupNode.namesystem.writeLock();\n    try {\n      backupNode.namesystem.setImageLoaded();\n      if(backupNode.namesystem.getBlocksTotal() \u003e 0) {\n        long completeBlocksTotal \u003d\n            backupNode.namesystem.getCompleteBlocksTotal();\n        backupNode.namesystem.setBlockTotal(completeBlocksTotal);\n      }\n      bnImage.saveFSImageInAllDirs(backupNode.getNamesystem(), txid);\n      if (!backupNode.namesystem.isRollingUpgrade()) {\n        bnStorage.writeAll();\n      }\n    } finally {\n      backupNode.namesystem.writeUnlock();\n    }\n\n    if(cpCmd.needToReturnImage()) {\n      TransferFsImage.uploadImageFromStorage(backupNode.nnHttpAddress, conf,\n          bnStorage, NameNodeFile.IMAGE, txid);\n    }\n\n    getRemoteNamenodeProxy().endCheckpoint(backupNode.getRegistration(), sig);\n\n    if (backupNode.getRole() \u003d\u003d NamenodeRole.BACKUP) {\n      bnImage.convergeJournalSpool();\n    }\n    backupNode.setRegistration(); // keep registration up to date\n    \n    long imageSize \u003d bnImage.getStorage().getFsImageName(txid).length();\n    LOG.info(\"Checkpoint completed in \"\n        + (monotonicNow() - startTime)/1000 + \" seconds.\"\n        + \" New Image Size: \" + imageSize);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/Checkpointer.java",
      "extendedDetails": {}
    },
    "6d4eee718a3fe1450a627128eb94728011bd9b68": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8856. Make LeaseManager#countPath O(1). (Contributed by Arpit Agarwal)\n",
      "commitDate": "06/08/15 6:51 PM",
      "commitName": "6d4eee718a3fe1450a627128eb94728011bd9b68",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "06/06/15 9:43 AM",
      "commitNameOld": "71de367c5e80ea76d1e8d21f0216cd6b879dcee5",
      "commitAuthorOld": "cnauroth",
      "daysBetweenCommits": 61.38,
      "commitsBetweenForRepo": 377,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,103 +1,105 @@\n   void doCheckpoint() throws IOException {\n     BackupImage bnImage \u003d getFSImage();\n     NNStorage bnStorage \u003d bnImage.getStorage();\n \n     long startTime \u003d monotonicNow();\n     bnImage.freezeNamespaceAtNextRoll();\n     \n     NamenodeCommand cmd \u003d \n       getRemoteNamenodeProxy().startCheckpoint(backupNode.getRegistration());\n     CheckpointCommand cpCmd \u003d null;\n     switch(cmd.getAction()) {\n       case NamenodeProtocol.ACT_SHUTDOWN:\n         shutdown();\n         throw new IOException(\"Name-node \" + backupNode.nnRpcAddress\n                                            + \" requested shutdown.\");\n       case NamenodeProtocol.ACT_CHECKPOINT:\n         cpCmd \u003d (CheckpointCommand)cmd;\n         break;\n       default:\n         throw new IOException(\"Unsupported NamenodeCommand: \"+cmd.getAction());\n     }\n \n     bnImage.waitUntilNamespaceFrozen();\n     \n     CheckpointSignature sig \u003d cpCmd.getSignature();\n \n     // Make sure we\u0027re talking to the same NN!\n     sig.validateStorageInfo(bnImage);\n \n     long lastApplied \u003d bnImage.getLastAppliedTxId();\n     LOG.debug(\"Doing checkpoint. Last applied: \" + lastApplied);\n     RemoteEditLogManifest manifest \u003d\n       getRemoteNamenodeProxy().getEditLogManifest(bnImage.getLastAppliedTxId() + 1);\n \n     boolean needReloadImage \u003d false;\n     if (!manifest.getLogs().isEmpty()) {\n       RemoteEditLog firstRemoteLog \u003d manifest.getLogs().get(0);\n       // we don\u0027t have enough logs to roll forward using only logs. Need\n       // to download and load the image.\n       if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n         LOG.info(\"Unable to roll forward using only logs. Downloading \" +\n             \"image with txid \" + sig.mostRecentCheckpointTxId);\n         MD5Hash downloadedHash \u003d TransferFsImage.downloadImageToStorage(\n             backupNode.nnHttpAddress, sig.mostRecentCheckpointTxId, bnStorage,\n             true);\n         bnImage.saveDigestAndRenameCheckpointImage(NameNodeFile.IMAGE,\n             sig.mostRecentCheckpointTxId, downloadedHash);\n         lastApplied \u003d sig.mostRecentCheckpointTxId;\n         needReloadImage \u003d true;\n       }\n \n       if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n         throw new IOException(\"No logs to roll forward from \" + lastApplied);\n       }\n   \n       // get edits files\n       for (RemoteEditLog log : manifest.getLogs()) {\n         TransferFsImage.downloadEditsToStorage(\n             backupNode.nnHttpAddress, log, bnStorage);\n       }\n \n       if(needReloadImage) {\n         LOG.info(\"Loading image with txid \" + sig.mostRecentCheckpointTxId);\n         File file \u003d bnStorage.findImageFile(NameNodeFile.IMAGE,\n             sig.mostRecentCheckpointTxId);\n         bnImage.reloadFromImageFile(file, backupNode.getNamesystem());\n       }\n       rollForwardByApplyingLogs(manifest, bnImage, backupNode.getNamesystem());\n     }\n     \n     long txid \u003d bnImage.getLastAppliedTxId();\n     \n     backupNode.namesystem.writeLock();\n     try {\n       backupNode.namesystem.setImageLoaded();\n       if(backupNode.namesystem.getBlocksTotal() \u003e 0) {\n-        backupNode.namesystem.setBlockTotal();\n+        long completeBlocksTotal \u003d\n+            backupNode.namesystem.getCompleteBlocksTotal();\n+        backupNode.namesystem.setBlockTotal(completeBlocksTotal);\n       }\n       bnImage.saveFSImageInAllDirs(backupNode.getNamesystem(), txid);\n       if (!backupNode.namesystem.isRollingUpgrade()) {\n         bnStorage.writeAll();\n       }\n     } finally {\n       backupNode.namesystem.writeUnlock();\n     }\n \n     if(cpCmd.needToReturnImage()) {\n       TransferFsImage.uploadImageFromStorage(backupNode.nnHttpAddress, conf,\n           bnStorage, NameNodeFile.IMAGE, txid);\n     }\n \n     getRemoteNamenodeProxy().endCheckpoint(backupNode.getRegistration(), sig);\n \n     if (backupNode.getRole() \u003d\u003d NamenodeRole.BACKUP) {\n       bnImage.convergeJournalSpool();\n     }\n     backupNode.setRegistration(); // keep registration up to date\n     \n     long imageSize \u003d bnImage.getStorage().getFsImageName(txid).length();\n     LOG.info(\"Checkpoint completed in \"\n         + (monotonicNow() - startTime)/1000 + \" seconds.\"\n         + \" New Image Size: \" + imageSize);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void doCheckpoint() throws IOException {\n    BackupImage bnImage \u003d getFSImage();\n    NNStorage bnStorage \u003d bnImage.getStorage();\n\n    long startTime \u003d monotonicNow();\n    bnImage.freezeNamespaceAtNextRoll();\n    \n    NamenodeCommand cmd \u003d \n      getRemoteNamenodeProxy().startCheckpoint(backupNode.getRegistration());\n    CheckpointCommand cpCmd \u003d null;\n    switch(cmd.getAction()) {\n      case NamenodeProtocol.ACT_SHUTDOWN:\n        shutdown();\n        throw new IOException(\"Name-node \" + backupNode.nnRpcAddress\n                                           + \" requested shutdown.\");\n      case NamenodeProtocol.ACT_CHECKPOINT:\n        cpCmd \u003d (CheckpointCommand)cmd;\n        break;\n      default:\n        throw new IOException(\"Unsupported NamenodeCommand: \"+cmd.getAction());\n    }\n\n    bnImage.waitUntilNamespaceFrozen();\n    \n    CheckpointSignature sig \u003d cpCmd.getSignature();\n\n    // Make sure we\u0027re talking to the same NN!\n    sig.validateStorageInfo(bnImage);\n\n    long lastApplied \u003d bnImage.getLastAppliedTxId();\n    LOG.debug(\"Doing checkpoint. Last applied: \" + lastApplied);\n    RemoteEditLogManifest manifest \u003d\n      getRemoteNamenodeProxy().getEditLogManifest(bnImage.getLastAppliedTxId() + 1);\n\n    boolean needReloadImage \u003d false;\n    if (!manifest.getLogs().isEmpty()) {\n      RemoteEditLog firstRemoteLog \u003d manifest.getLogs().get(0);\n      // we don\u0027t have enough logs to roll forward using only logs. Need\n      // to download and load the image.\n      if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n        LOG.info(\"Unable to roll forward using only logs. Downloading \" +\n            \"image with txid \" + sig.mostRecentCheckpointTxId);\n        MD5Hash downloadedHash \u003d TransferFsImage.downloadImageToStorage(\n            backupNode.nnHttpAddress, sig.mostRecentCheckpointTxId, bnStorage,\n            true);\n        bnImage.saveDigestAndRenameCheckpointImage(NameNodeFile.IMAGE,\n            sig.mostRecentCheckpointTxId, downloadedHash);\n        lastApplied \u003d sig.mostRecentCheckpointTxId;\n        needReloadImage \u003d true;\n      }\n\n      if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n        throw new IOException(\"No logs to roll forward from \" + lastApplied);\n      }\n  \n      // get edits files\n      for (RemoteEditLog log : manifest.getLogs()) {\n        TransferFsImage.downloadEditsToStorage(\n            backupNode.nnHttpAddress, log, bnStorage);\n      }\n\n      if(needReloadImage) {\n        LOG.info(\"Loading image with txid \" + sig.mostRecentCheckpointTxId);\n        File file \u003d bnStorage.findImageFile(NameNodeFile.IMAGE,\n            sig.mostRecentCheckpointTxId);\n        bnImage.reloadFromImageFile(file, backupNode.getNamesystem());\n      }\n      rollForwardByApplyingLogs(manifest, bnImage, backupNode.getNamesystem());\n    }\n    \n    long txid \u003d bnImage.getLastAppliedTxId();\n    \n    backupNode.namesystem.writeLock();\n    try {\n      backupNode.namesystem.setImageLoaded();\n      if(backupNode.namesystem.getBlocksTotal() \u003e 0) {\n        long completeBlocksTotal \u003d\n            backupNode.namesystem.getCompleteBlocksTotal();\n        backupNode.namesystem.setBlockTotal(completeBlocksTotal);\n      }\n      bnImage.saveFSImageInAllDirs(backupNode.getNamesystem(), txid);\n      if (!backupNode.namesystem.isRollingUpgrade()) {\n        bnStorage.writeAll();\n      }\n    } finally {\n      backupNode.namesystem.writeUnlock();\n    }\n\n    if(cpCmd.needToReturnImage()) {\n      TransferFsImage.uploadImageFromStorage(backupNode.nnHttpAddress, conf,\n          bnStorage, NameNodeFile.IMAGE, txid);\n    }\n\n    getRemoteNamenodeProxy().endCheckpoint(backupNode.getRegistration(), sig);\n\n    if (backupNode.getRole() \u003d\u003d NamenodeRole.BACKUP) {\n      bnImage.convergeJournalSpool();\n    }\n    backupNode.setRegistration(); // keep registration up to date\n    \n    long imageSize \u003d bnImage.getStorage().getFsImageName(txid).length();\n    LOG.info(\"Checkpoint completed in \"\n        + (monotonicNow() - startTime)/1000 + \" seconds.\"\n        + \" New Image Size: \" + imageSize);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/Checkpointer.java",
      "extendedDetails": {}
    },
    "71de367c5e80ea76d1e8d21f0216cd6b879dcee5": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8432. Introduce a minimum compatible layout version to allow downgrade in more rolling upgrade use cases. Contributed by Chris Nauroth.\n",
      "commitDate": "06/06/15 9:43 AM",
      "commitName": "71de367c5e80ea76d1e8d21f0216cd6b879dcee5",
      "commitAuthor": "cnauroth",
      "commitDateOld": "20/03/15 12:02 PM",
      "commitNameOld": "75ead273bea8a7dad61c4f99c3a16cab2697c498",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 77.9,
      "commitsBetweenForRepo": 736,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,101 +1,103 @@\n   void doCheckpoint() throws IOException {\n     BackupImage bnImage \u003d getFSImage();\n     NNStorage bnStorage \u003d bnImage.getStorage();\n \n     long startTime \u003d monotonicNow();\n     bnImage.freezeNamespaceAtNextRoll();\n     \n     NamenodeCommand cmd \u003d \n       getRemoteNamenodeProxy().startCheckpoint(backupNode.getRegistration());\n     CheckpointCommand cpCmd \u003d null;\n     switch(cmd.getAction()) {\n       case NamenodeProtocol.ACT_SHUTDOWN:\n         shutdown();\n         throw new IOException(\"Name-node \" + backupNode.nnRpcAddress\n                                            + \" requested shutdown.\");\n       case NamenodeProtocol.ACT_CHECKPOINT:\n         cpCmd \u003d (CheckpointCommand)cmd;\n         break;\n       default:\n         throw new IOException(\"Unsupported NamenodeCommand: \"+cmd.getAction());\n     }\n \n     bnImage.waitUntilNamespaceFrozen();\n     \n     CheckpointSignature sig \u003d cpCmd.getSignature();\n \n     // Make sure we\u0027re talking to the same NN!\n     sig.validateStorageInfo(bnImage);\n \n     long lastApplied \u003d bnImage.getLastAppliedTxId();\n     LOG.debug(\"Doing checkpoint. Last applied: \" + lastApplied);\n     RemoteEditLogManifest manifest \u003d\n       getRemoteNamenodeProxy().getEditLogManifest(bnImage.getLastAppliedTxId() + 1);\n \n     boolean needReloadImage \u003d false;\n     if (!manifest.getLogs().isEmpty()) {\n       RemoteEditLog firstRemoteLog \u003d manifest.getLogs().get(0);\n       // we don\u0027t have enough logs to roll forward using only logs. Need\n       // to download and load the image.\n       if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n         LOG.info(\"Unable to roll forward using only logs. Downloading \" +\n             \"image with txid \" + sig.mostRecentCheckpointTxId);\n         MD5Hash downloadedHash \u003d TransferFsImage.downloadImageToStorage(\n             backupNode.nnHttpAddress, sig.mostRecentCheckpointTxId, bnStorage,\n             true);\n         bnImage.saveDigestAndRenameCheckpointImage(NameNodeFile.IMAGE,\n             sig.mostRecentCheckpointTxId, downloadedHash);\n         lastApplied \u003d sig.mostRecentCheckpointTxId;\n         needReloadImage \u003d true;\n       }\n \n       if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n         throw new IOException(\"No logs to roll forward from \" + lastApplied);\n       }\n   \n       // get edits files\n       for (RemoteEditLog log : manifest.getLogs()) {\n         TransferFsImage.downloadEditsToStorage(\n             backupNode.nnHttpAddress, log, bnStorage);\n       }\n \n       if(needReloadImage) {\n         LOG.info(\"Loading image with txid \" + sig.mostRecentCheckpointTxId);\n         File file \u003d bnStorage.findImageFile(NameNodeFile.IMAGE,\n             sig.mostRecentCheckpointTxId);\n         bnImage.reloadFromImageFile(file, backupNode.getNamesystem());\n       }\n       rollForwardByApplyingLogs(manifest, bnImage, backupNode.getNamesystem());\n     }\n     \n     long txid \u003d bnImage.getLastAppliedTxId();\n     \n     backupNode.namesystem.writeLock();\n     try {\n       backupNode.namesystem.setImageLoaded();\n       if(backupNode.namesystem.getBlocksTotal() \u003e 0) {\n         backupNode.namesystem.setBlockTotal();\n       }\n       bnImage.saveFSImageInAllDirs(backupNode.getNamesystem(), txid);\n-      bnStorage.writeAll();\n+      if (!backupNode.namesystem.isRollingUpgrade()) {\n+        bnStorage.writeAll();\n+      }\n     } finally {\n       backupNode.namesystem.writeUnlock();\n     }\n \n     if(cpCmd.needToReturnImage()) {\n       TransferFsImage.uploadImageFromStorage(backupNode.nnHttpAddress, conf,\n           bnStorage, NameNodeFile.IMAGE, txid);\n     }\n \n     getRemoteNamenodeProxy().endCheckpoint(backupNode.getRegistration(), sig);\n \n     if (backupNode.getRole() \u003d\u003d NamenodeRole.BACKUP) {\n       bnImage.convergeJournalSpool();\n     }\n     backupNode.setRegistration(); // keep registration up to date\n     \n     long imageSize \u003d bnImage.getStorage().getFsImageName(txid).length();\n     LOG.info(\"Checkpoint completed in \"\n         + (monotonicNow() - startTime)/1000 + \" seconds.\"\n         + \" New Image Size: \" + imageSize);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void doCheckpoint() throws IOException {\n    BackupImage bnImage \u003d getFSImage();\n    NNStorage bnStorage \u003d bnImage.getStorage();\n\n    long startTime \u003d monotonicNow();\n    bnImage.freezeNamespaceAtNextRoll();\n    \n    NamenodeCommand cmd \u003d \n      getRemoteNamenodeProxy().startCheckpoint(backupNode.getRegistration());\n    CheckpointCommand cpCmd \u003d null;\n    switch(cmd.getAction()) {\n      case NamenodeProtocol.ACT_SHUTDOWN:\n        shutdown();\n        throw new IOException(\"Name-node \" + backupNode.nnRpcAddress\n                                           + \" requested shutdown.\");\n      case NamenodeProtocol.ACT_CHECKPOINT:\n        cpCmd \u003d (CheckpointCommand)cmd;\n        break;\n      default:\n        throw new IOException(\"Unsupported NamenodeCommand: \"+cmd.getAction());\n    }\n\n    bnImage.waitUntilNamespaceFrozen();\n    \n    CheckpointSignature sig \u003d cpCmd.getSignature();\n\n    // Make sure we\u0027re talking to the same NN!\n    sig.validateStorageInfo(bnImage);\n\n    long lastApplied \u003d bnImage.getLastAppliedTxId();\n    LOG.debug(\"Doing checkpoint. Last applied: \" + lastApplied);\n    RemoteEditLogManifest manifest \u003d\n      getRemoteNamenodeProxy().getEditLogManifest(bnImage.getLastAppliedTxId() + 1);\n\n    boolean needReloadImage \u003d false;\n    if (!manifest.getLogs().isEmpty()) {\n      RemoteEditLog firstRemoteLog \u003d manifest.getLogs().get(0);\n      // we don\u0027t have enough logs to roll forward using only logs. Need\n      // to download and load the image.\n      if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n        LOG.info(\"Unable to roll forward using only logs. Downloading \" +\n            \"image with txid \" + sig.mostRecentCheckpointTxId);\n        MD5Hash downloadedHash \u003d TransferFsImage.downloadImageToStorage(\n            backupNode.nnHttpAddress, sig.mostRecentCheckpointTxId, bnStorage,\n            true);\n        bnImage.saveDigestAndRenameCheckpointImage(NameNodeFile.IMAGE,\n            sig.mostRecentCheckpointTxId, downloadedHash);\n        lastApplied \u003d sig.mostRecentCheckpointTxId;\n        needReloadImage \u003d true;\n      }\n\n      if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n        throw new IOException(\"No logs to roll forward from \" + lastApplied);\n      }\n  \n      // get edits files\n      for (RemoteEditLog log : manifest.getLogs()) {\n        TransferFsImage.downloadEditsToStorage(\n            backupNode.nnHttpAddress, log, bnStorage);\n      }\n\n      if(needReloadImage) {\n        LOG.info(\"Loading image with txid \" + sig.mostRecentCheckpointTxId);\n        File file \u003d bnStorage.findImageFile(NameNodeFile.IMAGE,\n            sig.mostRecentCheckpointTxId);\n        bnImage.reloadFromImageFile(file, backupNode.getNamesystem());\n      }\n      rollForwardByApplyingLogs(manifest, bnImage, backupNode.getNamesystem());\n    }\n    \n    long txid \u003d bnImage.getLastAppliedTxId();\n    \n    backupNode.namesystem.writeLock();\n    try {\n      backupNode.namesystem.setImageLoaded();\n      if(backupNode.namesystem.getBlocksTotal() \u003e 0) {\n        backupNode.namesystem.setBlockTotal();\n      }\n      bnImage.saveFSImageInAllDirs(backupNode.getNamesystem(), txid);\n      if (!backupNode.namesystem.isRollingUpgrade()) {\n        bnStorage.writeAll();\n      }\n    } finally {\n      backupNode.namesystem.writeUnlock();\n    }\n\n    if(cpCmd.needToReturnImage()) {\n      TransferFsImage.uploadImageFromStorage(backupNode.nnHttpAddress, conf,\n          bnStorage, NameNodeFile.IMAGE, txid);\n    }\n\n    getRemoteNamenodeProxy().endCheckpoint(backupNode.getRegistration(), sig);\n\n    if (backupNode.getRole() \u003d\u003d NamenodeRole.BACKUP) {\n      bnImage.convergeJournalSpool();\n    }\n    backupNode.setRegistration(); // keep registration up to date\n    \n    long imageSize \u003d bnImage.getStorage().getFsImageName(txid).length();\n    LOG.info(\"Checkpoint completed in \"\n        + (monotonicNow() - startTime)/1000 + \" seconds.\"\n        + \" New Image Size: \" + imageSize);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/Checkpointer.java",
      "extendedDetails": {}
    },
    "75ead273bea8a7dad61c4f99c3a16cab2697c498": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6841. Use Time.monotonicNow() wherever applicable instead of Time.now(). Contributed by Vinayakumar B\n",
      "commitDate": "20/03/15 12:02 PM",
      "commitName": "75ead273bea8a7dad61c4f99c3a16cab2697c498",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "18/06/14 9:13 PM",
      "commitNameOld": "a4e0ff5e052abad498595ee198b49c5310c9ec0d",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 274.62,
      "commitsBetweenForRepo": 2359,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,101 +1,101 @@\n   void doCheckpoint() throws IOException {\n     BackupImage bnImage \u003d getFSImage();\n     NNStorage bnStorage \u003d bnImage.getStorage();\n \n-    long startTime \u003d now();\n+    long startTime \u003d monotonicNow();\n     bnImage.freezeNamespaceAtNextRoll();\n     \n     NamenodeCommand cmd \u003d \n       getRemoteNamenodeProxy().startCheckpoint(backupNode.getRegistration());\n     CheckpointCommand cpCmd \u003d null;\n     switch(cmd.getAction()) {\n       case NamenodeProtocol.ACT_SHUTDOWN:\n         shutdown();\n         throw new IOException(\"Name-node \" + backupNode.nnRpcAddress\n                                            + \" requested shutdown.\");\n       case NamenodeProtocol.ACT_CHECKPOINT:\n         cpCmd \u003d (CheckpointCommand)cmd;\n         break;\n       default:\n         throw new IOException(\"Unsupported NamenodeCommand: \"+cmd.getAction());\n     }\n \n     bnImage.waitUntilNamespaceFrozen();\n     \n     CheckpointSignature sig \u003d cpCmd.getSignature();\n \n     // Make sure we\u0027re talking to the same NN!\n     sig.validateStorageInfo(bnImage);\n \n     long lastApplied \u003d bnImage.getLastAppliedTxId();\n     LOG.debug(\"Doing checkpoint. Last applied: \" + lastApplied);\n     RemoteEditLogManifest manifest \u003d\n       getRemoteNamenodeProxy().getEditLogManifest(bnImage.getLastAppliedTxId() + 1);\n \n     boolean needReloadImage \u003d false;\n     if (!manifest.getLogs().isEmpty()) {\n       RemoteEditLog firstRemoteLog \u003d manifest.getLogs().get(0);\n       // we don\u0027t have enough logs to roll forward using only logs. Need\n       // to download and load the image.\n       if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n         LOG.info(\"Unable to roll forward using only logs. Downloading \" +\n             \"image with txid \" + sig.mostRecentCheckpointTxId);\n         MD5Hash downloadedHash \u003d TransferFsImage.downloadImageToStorage(\n             backupNode.nnHttpAddress, sig.mostRecentCheckpointTxId, bnStorage,\n             true);\n         bnImage.saveDigestAndRenameCheckpointImage(NameNodeFile.IMAGE,\n             sig.mostRecentCheckpointTxId, downloadedHash);\n         lastApplied \u003d sig.mostRecentCheckpointTxId;\n         needReloadImage \u003d true;\n       }\n \n       if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n         throw new IOException(\"No logs to roll forward from \" + lastApplied);\n       }\n   \n       // get edits files\n       for (RemoteEditLog log : manifest.getLogs()) {\n         TransferFsImage.downloadEditsToStorage(\n             backupNode.nnHttpAddress, log, bnStorage);\n       }\n \n       if(needReloadImage) {\n         LOG.info(\"Loading image with txid \" + sig.mostRecentCheckpointTxId);\n         File file \u003d bnStorage.findImageFile(NameNodeFile.IMAGE,\n             sig.mostRecentCheckpointTxId);\n         bnImage.reloadFromImageFile(file, backupNode.getNamesystem());\n       }\n       rollForwardByApplyingLogs(manifest, bnImage, backupNode.getNamesystem());\n     }\n     \n     long txid \u003d bnImage.getLastAppliedTxId();\n     \n     backupNode.namesystem.writeLock();\n     try {\n       backupNode.namesystem.setImageLoaded();\n       if(backupNode.namesystem.getBlocksTotal() \u003e 0) {\n         backupNode.namesystem.setBlockTotal();\n       }\n       bnImage.saveFSImageInAllDirs(backupNode.getNamesystem(), txid);\n       bnStorage.writeAll();\n     } finally {\n       backupNode.namesystem.writeUnlock();\n     }\n \n     if(cpCmd.needToReturnImage()) {\n       TransferFsImage.uploadImageFromStorage(backupNode.nnHttpAddress, conf,\n           bnStorage, NameNodeFile.IMAGE, txid);\n     }\n \n     getRemoteNamenodeProxy().endCheckpoint(backupNode.getRegistration(), sig);\n \n     if (backupNode.getRole() \u003d\u003d NamenodeRole.BACKUP) {\n       bnImage.convergeJournalSpool();\n     }\n     backupNode.setRegistration(); // keep registration up to date\n     \n     long imageSize \u003d bnImage.getStorage().getFsImageName(txid).length();\n     LOG.info(\"Checkpoint completed in \"\n-        + (now() - startTime)/1000 + \" seconds.\"\n+        + (monotonicNow() - startTime)/1000 + \" seconds.\"\n         + \" New Image Size: \" + imageSize);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void doCheckpoint() throws IOException {\n    BackupImage bnImage \u003d getFSImage();\n    NNStorage bnStorage \u003d bnImage.getStorage();\n\n    long startTime \u003d monotonicNow();\n    bnImage.freezeNamespaceAtNextRoll();\n    \n    NamenodeCommand cmd \u003d \n      getRemoteNamenodeProxy().startCheckpoint(backupNode.getRegistration());\n    CheckpointCommand cpCmd \u003d null;\n    switch(cmd.getAction()) {\n      case NamenodeProtocol.ACT_SHUTDOWN:\n        shutdown();\n        throw new IOException(\"Name-node \" + backupNode.nnRpcAddress\n                                           + \" requested shutdown.\");\n      case NamenodeProtocol.ACT_CHECKPOINT:\n        cpCmd \u003d (CheckpointCommand)cmd;\n        break;\n      default:\n        throw new IOException(\"Unsupported NamenodeCommand: \"+cmd.getAction());\n    }\n\n    bnImage.waitUntilNamespaceFrozen();\n    \n    CheckpointSignature sig \u003d cpCmd.getSignature();\n\n    // Make sure we\u0027re talking to the same NN!\n    sig.validateStorageInfo(bnImage);\n\n    long lastApplied \u003d bnImage.getLastAppliedTxId();\n    LOG.debug(\"Doing checkpoint. Last applied: \" + lastApplied);\n    RemoteEditLogManifest manifest \u003d\n      getRemoteNamenodeProxy().getEditLogManifest(bnImage.getLastAppliedTxId() + 1);\n\n    boolean needReloadImage \u003d false;\n    if (!manifest.getLogs().isEmpty()) {\n      RemoteEditLog firstRemoteLog \u003d manifest.getLogs().get(0);\n      // we don\u0027t have enough logs to roll forward using only logs. Need\n      // to download and load the image.\n      if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n        LOG.info(\"Unable to roll forward using only logs. Downloading \" +\n            \"image with txid \" + sig.mostRecentCheckpointTxId);\n        MD5Hash downloadedHash \u003d TransferFsImage.downloadImageToStorage(\n            backupNode.nnHttpAddress, sig.mostRecentCheckpointTxId, bnStorage,\n            true);\n        bnImage.saveDigestAndRenameCheckpointImage(NameNodeFile.IMAGE,\n            sig.mostRecentCheckpointTxId, downloadedHash);\n        lastApplied \u003d sig.mostRecentCheckpointTxId;\n        needReloadImage \u003d true;\n      }\n\n      if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n        throw new IOException(\"No logs to roll forward from \" + lastApplied);\n      }\n  \n      // get edits files\n      for (RemoteEditLog log : manifest.getLogs()) {\n        TransferFsImage.downloadEditsToStorage(\n            backupNode.nnHttpAddress, log, bnStorage);\n      }\n\n      if(needReloadImage) {\n        LOG.info(\"Loading image with txid \" + sig.mostRecentCheckpointTxId);\n        File file \u003d bnStorage.findImageFile(NameNodeFile.IMAGE,\n            sig.mostRecentCheckpointTxId);\n        bnImage.reloadFromImageFile(file, backupNode.getNamesystem());\n      }\n      rollForwardByApplyingLogs(manifest, bnImage, backupNode.getNamesystem());\n    }\n    \n    long txid \u003d bnImage.getLastAppliedTxId();\n    \n    backupNode.namesystem.writeLock();\n    try {\n      backupNode.namesystem.setImageLoaded();\n      if(backupNode.namesystem.getBlocksTotal() \u003e 0) {\n        backupNode.namesystem.setBlockTotal();\n      }\n      bnImage.saveFSImageInAllDirs(backupNode.getNamesystem(), txid);\n      bnStorage.writeAll();\n    } finally {\n      backupNode.namesystem.writeUnlock();\n    }\n\n    if(cpCmd.needToReturnImage()) {\n      TransferFsImage.uploadImageFromStorage(backupNode.nnHttpAddress, conf,\n          bnStorage, NameNodeFile.IMAGE, txid);\n    }\n\n    getRemoteNamenodeProxy().endCheckpoint(backupNode.getRegistration(), sig);\n\n    if (backupNode.getRole() \u003d\u003d NamenodeRole.BACKUP) {\n      bnImage.convergeJournalSpool();\n    }\n    backupNode.setRegistration(); // keep registration up to date\n    \n    long imageSize \u003d bnImage.getStorage().getFsImageName(txid).length();\n    LOG.info(\"Checkpoint completed in \"\n        + (monotonicNow() - startTime)/1000 + \" seconds.\"\n        + \" New Image Size: \" + imageSize);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/Checkpointer.java",
      "extendedDetails": {}
    },
    "a4e0ff5e052abad498595ee198b49c5310c9ec0d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6480. Move waitForReady() from FSDirectory to FSNamesystem. Contributed by Haohui Mai.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1603705 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/06/14 9:13 PM",
      "commitName": "a4e0ff5e052abad498595ee198b49c5310c9ec0d",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "24/03/14 4:32 PM",
      "commitNameOld": "c2ef7e239eb0e81cf8a3e971378e9e696202de67",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 86.2,
      "commitsBetweenForRepo": 513,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,101 +1,101 @@\n   void doCheckpoint() throws IOException {\n     BackupImage bnImage \u003d getFSImage();\n     NNStorage bnStorage \u003d bnImage.getStorage();\n \n     long startTime \u003d now();\n     bnImage.freezeNamespaceAtNextRoll();\n     \n     NamenodeCommand cmd \u003d \n       getRemoteNamenodeProxy().startCheckpoint(backupNode.getRegistration());\n     CheckpointCommand cpCmd \u003d null;\n     switch(cmd.getAction()) {\n       case NamenodeProtocol.ACT_SHUTDOWN:\n         shutdown();\n         throw new IOException(\"Name-node \" + backupNode.nnRpcAddress\n                                            + \" requested shutdown.\");\n       case NamenodeProtocol.ACT_CHECKPOINT:\n         cpCmd \u003d (CheckpointCommand)cmd;\n         break;\n       default:\n         throw new IOException(\"Unsupported NamenodeCommand: \"+cmd.getAction());\n     }\n \n     bnImage.waitUntilNamespaceFrozen();\n     \n     CheckpointSignature sig \u003d cpCmd.getSignature();\n \n     // Make sure we\u0027re talking to the same NN!\n     sig.validateStorageInfo(bnImage);\n \n     long lastApplied \u003d bnImage.getLastAppliedTxId();\n     LOG.debug(\"Doing checkpoint. Last applied: \" + lastApplied);\n     RemoteEditLogManifest manifest \u003d\n       getRemoteNamenodeProxy().getEditLogManifest(bnImage.getLastAppliedTxId() + 1);\n \n     boolean needReloadImage \u003d false;\n     if (!manifest.getLogs().isEmpty()) {\n       RemoteEditLog firstRemoteLog \u003d manifest.getLogs().get(0);\n       // we don\u0027t have enough logs to roll forward using only logs. Need\n       // to download and load the image.\n       if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n         LOG.info(\"Unable to roll forward using only logs. Downloading \" +\n             \"image with txid \" + sig.mostRecentCheckpointTxId);\n         MD5Hash downloadedHash \u003d TransferFsImage.downloadImageToStorage(\n             backupNode.nnHttpAddress, sig.mostRecentCheckpointTxId, bnStorage,\n             true);\n         bnImage.saveDigestAndRenameCheckpointImage(NameNodeFile.IMAGE,\n             sig.mostRecentCheckpointTxId, downloadedHash);\n         lastApplied \u003d sig.mostRecentCheckpointTxId;\n         needReloadImage \u003d true;\n       }\n \n       if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n         throw new IOException(\"No logs to roll forward from \" + lastApplied);\n       }\n   \n       // get edits files\n       for (RemoteEditLog log : manifest.getLogs()) {\n         TransferFsImage.downloadEditsToStorage(\n             backupNode.nnHttpAddress, log, bnStorage);\n       }\n \n       if(needReloadImage) {\n         LOG.info(\"Loading image with txid \" + sig.mostRecentCheckpointTxId);\n         File file \u003d bnStorage.findImageFile(NameNodeFile.IMAGE,\n             sig.mostRecentCheckpointTxId);\n         bnImage.reloadFromImageFile(file, backupNode.getNamesystem());\n       }\n       rollForwardByApplyingLogs(manifest, bnImage, backupNode.getNamesystem());\n     }\n     \n     long txid \u003d bnImage.getLastAppliedTxId();\n     \n     backupNode.namesystem.writeLock();\n     try {\n-      backupNode.namesystem.dir.setReady();\n+      backupNode.namesystem.setImageLoaded();\n       if(backupNode.namesystem.getBlocksTotal() \u003e 0) {\n         backupNode.namesystem.setBlockTotal();\n       }\n       bnImage.saveFSImageInAllDirs(backupNode.getNamesystem(), txid);\n       bnStorage.writeAll();\n     } finally {\n       backupNode.namesystem.writeUnlock();\n     }\n \n     if(cpCmd.needToReturnImage()) {\n       TransferFsImage.uploadImageFromStorage(backupNode.nnHttpAddress, conf,\n           bnStorage, NameNodeFile.IMAGE, txid);\n     }\n \n     getRemoteNamenodeProxy().endCheckpoint(backupNode.getRegistration(), sig);\n \n     if (backupNode.getRole() \u003d\u003d NamenodeRole.BACKUP) {\n       bnImage.convergeJournalSpool();\n     }\n     backupNode.setRegistration(); // keep registration up to date\n     \n     long imageSize \u003d bnImage.getStorage().getFsImageName(txid).length();\n     LOG.info(\"Checkpoint completed in \"\n         + (now() - startTime)/1000 + \" seconds.\"\n         + \" New Image Size: \" + imageSize);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void doCheckpoint() throws IOException {\n    BackupImage bnImage \u003d getFSImage();\n    NNStorage bnStorage \u003d bnImage.getStorage();\n\n    long startTime \u003d now();\n    bnImage.freezeNamespaceAtNextRoll();\n    \n    NamenodeCommand cmd \u003d \n      getRemoteNamenodeProxy().startCheckpoint(backupNode.getRegistration());\n    CheckpointCommand cpCmd \u003d null;\n    switch(cmd.getAction()) {\n      case NamenodeProtocol.ACT_SHUTDOWN:\n        shutdown();\n        throw new IOException(\"Name-node \" + backupNode.nnRpcAddress\n                                           + \" requested shutdown.\");\n      case NamenodeProtocol.ACT_CHECKPOINT:\n        cpCmd \u003d (CheckpointCommand)cmd;\n        break;\n      default:\n        throw new IOException(\"Unsupported NamenodeCommand: \"+cmd.getAction());\n    }\n\n    bnImage.waitUntilNamespaceFrozen();\n    \n    CheckpointSignature sig \u003d cpCmd.getSignature();\n\n    // Make sure we\u0027re talking to the same NN!\n    sig.validateStorageInfo(bnImage);\n\n    long lastApplied \u003d bnImage.getLastAppliedTxId();\n    LOG.debug(\"Doing checkpoint. Last applied: \" + lastApplied);\n    RemoteEditLogManifest manifest \u003d\n      getRemoteNamenodeProxy().getEditLogManifest(bnImage.getLastAppliedTxId() + 1);\n\n    boolean needReloadImage \u003d false;\n    if (!manifest.getLogs().isEmpty()) {\n      RemoteEditLog firstRemoteLog \u003d manifest.getLogs().get(0);\n      // we don\u0027t have enough logs to roll forward using only logs. Need\n      // to download and load the image.\n      if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n        LOG.info(\"Unable to roll forward using only logs. Downloading \" +\n            \"image with txid \" + sig.mostRecentCheckpointTxId);\n        MD5Hash downloadedHash \u003d TransferFsImage.downloadImageToStorage(\n            backupNode.nnHttpAddress, sig.mostRecentCheckpointTxId, bnStorage,\n            true);\n        bnImage.saveDigestAndRenameCheckpointImage(NameNodeFile.IMAGE,\n            sig.mostRecentCheckpointTxId, downloadedHash);\n        lastApplied \u003d sig.mostRecentCheckpointTxId;\n        needReloadImage \u003d true;\n      }\n\n      if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n        throw new IOException(\"No logs to roll forward from \" + lastApplied);\n      }\n  \n      // get edits files\n      for (RemoteEditLog log : manifest.getLogs()) {\n        TransferFsImage.downloadEditsToStorage(\n            backupNode.nnHttpAddress, log, bnStorage);\n      }\n\n      if(needReloadImage) {\n        LOG.info(\"Loading image with txid \" + sig.mostRecentCheckpointTxId);\n        File file \u003d bnStorage.findImageFile(NameNodeFile.IMAGE,\n            sig.mostRecentCheckpointTxId);\n        bnImage.reloadFromImageFile(file, backupNode.getNamesystem());\n      }\n      rollForwardByApplyingLogs(manifest, bnImage, backupNode.getNamesystem());\n    }\n    \n    long txid \u003d bnImage.getLastAppliedTxId();\n    \n    backupNode.namesystem.writeLock();\n    try {\n      backupNode.namesystem.setImageLoaded();\n      if(backupNode.namesystem.getBlocksTotal() \u003e 0) {\n        backupNode.namesystem.setBlockTotal();\n      }\n      bnImage.saveFSImageInAllDirs(backupNode.getNamesystem(), txid);\n      bnStorage.writeAll();\n    } finally {\n      backupNode.namesystem.writeUnlock();\n    }\n\n    if(cpCmd.needToReturnImage()) {\n      TransferFsImage.uploadImageFromStorage(backupNode.nnHttpAddress, conf,\n          bnStorage, NameNodeFile.IMAGE, txid);\n    }\n\n    getRemoteNamenodeProxy().endCheckpoint(backupNode.getRegistration(), sig);\n\n    if (backupNode.getRole() \u003d\u003d NamenodeRole.BACKUP) {\n      bnImage.convergeJournalSpool();\n    }\n    backupNode.setRegistration(); // keep registration up to date\n    \n    long imageSize \u003d bnImage.getStorage().getFsImageName(txid).length();\n    LOG.info(\"Checkpoint completed in \"\n        + (now() - startTime)/1000 + \" seconds.\"\n        + \" New Image Size: \" + imageSize);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/Checkpointer.java",
      "extendedDetails": {}
    },
    "94a1632fcb677fda6f4d812614026417f1d0a360": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3405. Checkpointing should use HTTP POST or PUT instead of GET-GET to send merged fsimages. Contributed by Vinayakumar B.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1575611 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/03/14 1:25 PM",
      "commitName": "94a1632fcb677fda6f4d812614026417f1d0a360",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "08/03/14 1:15 PM",
      "commitNameOld": "dbd22b23c2d68b97b4da47215897906f06f978e3",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,102 +1,101 @@\n   void doCheckpoint() throws IOException {\n     BackupImage bnImage \u003d getFSImage();\n     NNStorage bnStorage \u003d bnImage.getStorage();\n \n     long startTime \u003d now();\n     bnImage.freezeNamespaceAtNextRoll();\n     \n     NamenodeCommand cmd \u003d \n       getRemoteNamenodeProxy().startCheckpoint(backupNode.getRegistration());\n     CheckpointCommand cpCmd \u003d null;\n     switch(cmd.getAction()) {\n       case NamenodeProtocol.ACT_SHUTDOWN:\n         shutdown();\n         throw new IOException(\"Name-node \" + backupNode.nnRpcAddress\n                                            + \" requested shutdown.\");\n       case NamenodeProtocol.ACT_CHECKPOINT:\n         cpCmd \u003d (CheckpointCommand)cmd;\n         break;\n       default:\n         throw new IOException(\"Unsupported NamenodeCommand: \"+cmd.getAction());\n     }\n \n     bnImage.waitUntilNamespaceFrozen();\n     \n     CheckpointSignature sig \u003d cpCmd.getSignature();\n \n     // Make sure we\u0027re talking to the same NN!\n     sig.validateStorageInfo(bnImage);\n \n     long lastApplied \u003d bnImage.getLastAppliedTxId();\n     LOG.debug(\"Doing checkpoint. Last applied: \" + lastApplied);\n     RemoteEditLogManifest manifest \u003d\n       getRemoteNamenodeProxy().getEditLogManifest(bnImage.getLastAppliedTxId() + 1);\n \n     boolean needReloadImage \u003d false;\n     if (!manifest.getLogs().isEmpty()) {\n       RemoteEditLog firstRemoteLog \u003d manifest.getLogs().get(0);\n       // we don\u0027t have enough logs to roll forward using only logs. Need\n       // to download and load the image.\n       if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n         LOG.info(\"Unable to roll forward using only logs. Downloading \" +\n             \"image with txid \" + sig.mostRecentCheckpointTxId);\n         MD5Hash downloadedHash \u003d TransferFsImage.downloadImageToStorage(\n             backupNode.nnHttpAddress, sig.mostRecentCheckpointTxId, bnStorage,\n             true);\n         bnImage.saveDigestAndRenameCheckpointImage(NameNodeFile.IMAGE,\n             sig.mostRecentCheckpointTxId, downloadedHash);\n         lastApplied \u003d sig.mostRecentCheckpointTxId;\n         needReloadImage \u003d true;\n       }\n \n       if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n         throw new IOException(\"No logs to roll forward from \" + lastApplied);\n       }\n   \n       // get edits files\n       for (RemoteEditLog log : manifest.getLogs()) {\n         TransferFsImage.downloadEditsToStorage(\n             backupNode.nnHttpAddress, log, bnStorage);\n       }\n \n       if(needReloadImage) {\n         LOG.info(\"Loading image with txid \" + sig.mostRecentCheckpointTxId);\n         File file \u003d bnStorage.findImageFile(NameNodeFile.IMAGE,\n             sig.mostRecentCheckpointTxId);\n         bnImage.reloadFromImageFile(file, backupNode.getNamesystem());\n       }\n       rollForwardByApplyingLogs(manifest, bnImage, backupNode.getNamesystem());\n     }\n     \n     long txid \u003d bnImage.getLastAppliedTxId();\n     \n     backupNode.namesystem.writeLock();\n     try {\n       backupNode.namesystem.dir.setReady();\n       if(backupNode.namesystem.getBlocksTotal() \u003e 0) {\n         backupNode.namesystem.setBlockTotal();\n       }\n       bnImage.saveFSImageInAllDirs(backupNode.getNamesystem(), txid);\n       bnStorage.writeAll();\n     } finally {\n       backupNode.namesystem.writeUnlock();\n     }\n \n     if(cpCmd.needToReturnImage()) {\n-      TransferFsImage.uploadImageFromStorage(\n-          backupNode.nnHttpAddress, getImageListenAddress(),\n+      TransferFsImage.uploadImageFromStorage(backupNode.nnHttpAddress, conf,\n           bnStorage, NameNodeFile.IMAGE, txid);\n     }\n \n     getRemoteNamenodeProxy().endCheckpoint(backupNode.getRegistration(), sig);\n \n     if (backupNode.getRole() \u003d\u003d NamenodeRole.BACKUP) {\n       bnImage.convergeJournalSpool();\n     }\n     backupNode.setRegistration(); // keep registration up to date\n     \n     long imageSize \u003d bnImage.getStorage().getFsImageName(txid).length();\n     LOG.info(\"Checkpoint completed in \"\n         + (now() - startTime)/1000 + \" seconds.\"\n         + \" New Image Size: \" + imageSize);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void doCheckpoint() throws IOException {\n    BackupImage bnImage \u003d getFSImage();\n    NNStorage bnStorage \u003d bnImage.getStorage();\n\n    long startTime \u003d now();\n    bnImage.freezeNamespaceAtNextRoll();\n    \n    NamenodeCommand cmd \u003d \n      getRemoteNamenodeProxy().startCheckpoint(backupNode.getRegistration());\n    CheckpointCommand cpCmd \u003d null;\n    switch(cmd.getAction()) {\n      case NamenodeProtocol.ACT_SHUTDOWN:\n        shutdown();\n        throw new IOException(\"Name-node \" + backupNode.nnRpcAddress\n                                           + \" requested shutdown.\");\n      case NamenodeProtocol.ACT_CHECKPOINT:\n        cpCmd \u003d (CheckpointCommand)cmd;\n        break;\n      default:\n        throw new IOException(\"Unsupported NamenodeCommand: \"+cmd.getAction());\n    }\n\n    bnImage.waitUntilNamespaceFrozen();\n    \n    CheckpointSignature sig \u003d cpCmd.getSignature();\n\n    // Make sure we\u0027re talking to the same NN!\n    sig.validateStorageInfo(bnImage);\n\n    long lastApplied \u003d bnImage.getLastAppliedTxId();\n    LOG.debug(\"Doing checkpoint. Last applied: \" + lastApplied);\n    RemoteEditLogManifest manifest \u003d\n      getRemoteNamenodeProxy().getEditLogManifest(bnImage.getLastAppliedTxId() + 1);\n\n    boolean needReloadImage \u003d false;\n    if (!manifest.getLogs().isEmpty()) {\n      RemoteEditLog firstRemoteLog \u003d manifest.getLogs().get(0);\n      // we don\u0027t have enough logs to roll forward using only logs. Need\n      // to download and load the image.\n      if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n        LOG.info(\"Unable to roll forward using only logs. Downloading \" +\n            \"image with txid \" + sig.mostRecentCheckpointTxId);\n        MD5Hash downloadedHash \u003d TransferFsImage.downloadImageToStorage(\n            backupNode.nnHttpAddress, sig.mostRecentCheckpointTxId, bnStorage,\n            true);\n        bnImage.saveDigestAndRenameCheckpointImage(NameNodeFile.IMAGE,\n            sig.mostRecentCheckpointTxId, downloadedHash);\n        lastApplied \u003d sig.mostRecentCheckpointTxId;\n        needReloadImage \u003d true;\n      }\n\n      if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n        throw new IOException(\"No logs to roll forward from \" + lastApplied);\n      }\n  \n      // get edits files\n      for (RemoteEditLog log : manifest.getLogs()) {\n        TransferFsImage.downloadEditsToStorage(\n            backupNode.nnHttpAddress, log, bnStorage);\n      }\n\n      if(needReloadImage) {\n        LOG.info(\"Loading image with txid \" + sig.mostRecentCheckpointTxId);\n        File file \u003d bnStorage.findImageFile(NameNodeFile.IMAGE,\n            sig.mostRecentCheckpointTxId);\n        bnImage.reloadFromImageFile(file, backupNode.getNamesystem());\n      }\n      rollForwardByApplyingLogs(manifest, bnImage, backupNode.getNamesystem());\n    }\n    \n    long txid \u003d bnImage.getLastAppliedTxId();\n    \n    backupNode.namesystem.writeLock();\n    try {\n      backupNode.namesystem.dir.setReady();\n      if(backupNode.namesystem.getBlocksTotal() \u003e 0) {\n        backupNode.namesystem.setBlockTotal();\n      }\n      bnImage.saveFSImageInAllDirs(backupNode.getNamesystem(), txid);\n      bnStorage.writeAll();\n    } finally {\n      backupNode.namesystem.writeUnlock();\n    }\n\n    if(cpCmd.needToReturnImage()) {\n      TransferFsImage.uploadImageFromStorage(backupNode.nnHttpAddress, conf,\n          bnStorage, NameNodeFile.IMAGE, txid);\n    }\n\n    getRemoteNamenodeProxy().endCheckpoint(backupNode.getRegistration(), sig);\n\n    if (backupNode.getRole() \u003d\u003d NamenodeRole.BACKUP) {\n      bnImage.convergeJournalSpool();\n    }\n    backupNode.setRegistration(); // keep registration up to date\n    \n    long imageSize \u003d bnImage.getStorage().getFsImageName(txid).length();\n    LOG.info(\"Checkpoint completed in \"\n        + (now() - startTime)/1000 + \" seconds.\"\n        + \" New Image Size: \" + imageSize);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/Checkpointer.java",
      "extendedDetails": {}
    },
    "dbd22b23c2d68b97b4da47215897906f06f978e3": {
      "type": "Ybodychange",
      "commitMessage": "Revert HDFS-3405 for recommit with correct renamed files\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1575610 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/03/14 1:15 PM",
      "commitName": "dbd22b23c2d68b97b4da47215897906f06f978e3",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "07/03/14 4:39 PM",
      "commitNameOld": "0f595915a388305edbb3ce928415571811d304e8",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 0.86,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,101 +1,102 @@\n   void doCheckpoint() throws IOException {\n     BackupImage bnImage \u003d getFSImage();\n     NNStorage bnStorage \u003d bnImage.getStorage();\n \n     long startTime \u003d now();\n     bnImage.freezeNamespaceAtNextRoll();\n     \n     NamenodeCommand cmd \u003d \n       getRemoteNamenodeProxy().startCheckpoint(backupNode.getRegistration());\n     CheckpointCommand cpCmd \u003d null;\n     switch(cmd.getAction()) {\n       case NamenodeProtocol.ACT_SHUTDOWN:\n         shutdown();\n         throw new IOException(\"Name-node \" + backupNode.nnRpcAddress\n                                            + \" requested shutdown.\");\n       case NamenodeProtocol.ACT_CHECKPOINT:\n         cpCmd \u003d (CheckpointCommand)cmd;\n         break;\n       default:\n         throw new IOException(\"Unsupported NamenodeCommand: \"+cmd.getAction());\n     }\n \n     bnImage.waitUntilNamespaceFrozen();\n     \n     CheckpointSignature sig \u003d cpCmd.getSignature();\n \n     // Make sure we\u0027re talking to the same NN!\n     sig.validateStorageInfo(bnImage);\n \n     long lastApplied \u003d bnImage.getLastAppliedTxId();\n     LOG.debug(\"Doing checkpoint. Last applied: \" + lastApplied);\n     RemoteEditLogManifest manifest \u003d\n       getRemoteNamenodeProxy().getEditLogManifest(bnImage.getLastAppliedTxId() + 1);\n \n     boolean needReloadImage \u003d false;\n     if (!manifest.getLogs().isEmpty()) {\n       RemoteEditLog firstRemoteLog \u003d manifest.getLogs().get(0);\n       // we don\u0027t have enough logs to roll forward using only logs. Need\n       // to download and load the image.\n       if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n         LOG.info(\"Unable to roll forward using only logs. Downloading \" +\n             \"image with txid \" + sig.mostRecentCheckpointTxId);\n         MD5Hash downloadedHash \u003d TransferFsImage.downloadImageToStorage(\n             backupNode.nnHttpAddress, sig.mostRecentCheckpointTxId, bnStorage,\n             true);\n         bnImage.saveDigestAndRenameCheckpointImage(NameNodeFile.IMAGE,\n             sig.mostRecentCheckpointTxId, downloadedHash);\n         lastApplied \u003d sig.mostRecentCheckpointTxId;\n         needReloadImage \u003d true;\n       }\n \n       if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n         throw new IOException(\"No logs to roll forward from \" + lastApplied);\n       }\n   \n       // get edits files\n       for (RemoteEditLog log : manifest.getLogs()) {\n         TransferFsImage.downloadEditsToStorage(\n             backupNode.nnHttpAddress, log, bnStorage);\n       }\n \n       if(needReloadImage) {\n         LOG.info(\"Loading image with txid \" + sig.mostRecentCheckpointTxId);\n         File file \u003d bnStorage.findImageFile(NameNodeFile.IMAGE,\n             sig.mostRecentCheckpointTxId);\n         bnImage.reloadFromImageFile(file, backupNode.getNamesystem());\n       }\n       rollForwardByApplyingLogs(manifest, bnImage, backupNode.getNamesystem());\n     }\n     \n     long txid \u003d bnImage.getLastAppliedTxId();\n     \n     backupNode.namesystem.writeLock();\n     try {\n       backupNode.namesystem.dir.setReady();\n       if(backupNode.namesystem.getBlocksTotal() \u003e 0) {\n         backupNode.namesystem.setBlockTotal();\n       }\n       bnImage.saveFSImageInAllDirs(backupNode.getNamesystem(), txid);\n       bnStorage.writeAll();\n     } finally {\n       backupNode.namesystem.writeUnlock();\n     }\n \n     if(cpCmd.needToReturnImage()) {\n-      TransferFsImage.uploadImageFromStorage(backupNode.nnHttpAddress, conf,\n+      TransferFsImage.uploadImageFromStorage(\n+          backupNode.nnHttpAddress, getImageListenAddress(),\n           bnStorage, NameNodeFile.IMAGE, txid);\n     }\n \n     getRemoteNamenodeProxy().endCheckpoint(backupNode.getRegistration(), sig);\n \n     if (backupNode.getRole() \u003d\u003d NamenodeRole.BACKUP) {\n       bnImage.convergeJournalSpool();\n     }\n     backupNode.setRegistration(); // keep registration up to date\n     \n     long imageSize \u003d bnImage.getStorage().getFsImageName(txid).length();\n     LOG.info(\"Checkpoint completed in \"\n         + (now() - startTime)/1000 + \" seconds.\"\n         + \" New Image Size: \" + imageSize);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void doCheckpoint() throws IOException {\n    BackupImage bnImage \u003d getFSImage();\n    NNStorage bnStorage \u003d bnImage.getStorage();\n\n    long startTime \u003d now();\n    bnImage.freezeNamespaceAtNextRoll();\n    \n    NamenodeCommand cmd \u003d \n      getRemoteNamenodeProxy().startCheckpoint(backupNode.getRegistration());\n    CheckpointCommand cpCmd \u003d null;\n    switch(cmd.getAction()) {\n      case NamenodeProtocol.ACT_SHUTDOWN:\n        shutdown();\n        throw new IOException(\"Name-node \" + backupNode.nnRpcAddress\n                                           + \" requested shutdown.\");\n      case NamenodeProtocol.ACT_CHECKPOINT:\n        cpCmd \u003d (CheckpointCommand)cmd;\n        break;\n      default:\n        throw new IOException(\"Unsupported NamenodeCommand: \"+cmd.getAction());\n    }\n\n    bnImage.waitUntilNamespaceFrozen();\n    \n    CheckpointSignature sig \u003d cpCmd.getSignature();\n\n    // Make sure we\u0027re talking to the same NN!\n    sig.validateStorageInfo(bnImage);\n\n    long lastApplied \u003d bnImage.getLastAppliedTxId();\n    LOG.debug(\"Doing checkpoint. Last applied: \" + lastApplied);\n    RemoteEditLogManifest manifest \u003d\n      getRemoteNamenodeProxy().getEditLogManifest(bnImage.getLastAppliedTxId() + 1);\n\n    boolean needReloadImage \u003d false;\n    if (!manifest.getLogs().isEmpty()) {\n      RemoteEditLog firstRemoteLog \u003d manifest.getLogs().get(0);\n      // we don\u0027t have enough logs to roll forward using only logs. Need\n      // to download and load the image.\n      if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n        LOG.info(\"Unable to roll forward using only logs. Downloading \" +\n            \"image with txid \" + sig.mostRecentCheckpointTxId);\n        MD5Hash downloadedHash \u003d TransferFsImage.downloadImageToStorage(\n            backupNode.nnHttpAddress, sig.mostRecentCheckpointTxId, bnStorage,\n            true);\n        bnImage.saveDigestAndRenameCheckpointImage(NameNodeFile.IMAGE,\n            sig.mostRecentCheckpointTxId, downloadedHash);\n        lastApplied \u003d sig.mostRecentCheckpointTxId;\n        needReloadImage \u003d true;\n      }\n\n      if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n        throw new IOException(\"No logs to roll forward from \" + lastApplied);\n      }\n  \n      // get edits files\n      for (RemoteEditLog log : manifest.getLogs()) {\n        TransferFsImage.downloadEditsToStorage(\n            backupNode.nnHttpAddress, log, bnStorage);\n      }\n\n      if(needReloadImage) {\n        LOG.info(\"Loading image with txid \" + sig.mostRecentCheckpointTxId);\n        File file \u003d bnStorage.findImageFile(NameNodeFile.IMAGE,\n            sig.mostRecentCheckpointTxId);\n        bnImage.reloadFromImageFile(file, backupNode.getNamesystem());\n      }\n      rollForwardByApplyingLogs(manifest, bnImage, backupNode.getNamesystem());\n    }\n    \n    long txid \u003d bnImage.getLastAppliedTxId();\n    \n    backupNode.namesystem.writeLock();\n    try {\n      backupNode.namesystem.dir.setReady();\n      if(backupNode.namesystem.getBlocksTotal() \u003e 0) {\n        backupNode.namesystem.setBlockTotal();\n      }\n      bnImage.saveFSImageInAllDirs(backupNode.getNamesystem(), txid);\n      bnStorage.writeAll();\n    } finally {\n      backupNode.namesystem.writeUnlock();\n    }\n\n    if(cpCmd.needToReturnImage()) {\n      TransferFsImage.uploadImageFromStorage(\n          backupNode.nnHttpAddress, getImageListenAddress(),\n          bnStorage, NameNodeFile.IMAGE, txid);\n    }\n\n    getRemoteNamenodeProxy().endCheckpoint(backupNode.getRegistration(), sig);\n\n    if (backupNode.getRole() \u003d\u003d NamenodeRole.BACKUP) {\n      bnImage.convergeJournalSpool();\n    }\n    backupNode.setRegistration(); // keep registration up to date\n    \n    long imageSize \u003d bnImage.getStorage().getFsImageName(txid).length();\n    LOG.info(\"Checkpoint completed in \"\n        + (now() - startTime)/1000 + \" seconds.\"\n        + \" New Image Size: \" + imageSize);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/Checkpointer.java",
      "extendedDetails": {}
    },
    "0f595915a388305edbb3ce928415571811d304e8": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3405. Checkpointing should use HTTP POST or PUT instead of GET-GET to send merged fsimages. Contributed by Vinayakumar B.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1575457 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/03/14 4:39 PM",
      "commitName": "0f595915a388305edbb3ce928415571811d304e8",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "27/02/14 5:21 PM",
      "commitNameOld": "e9a17c8ce0656a4e5d47401ca22a575c5f5f66db",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 7.97,
      "commitsBetweenForRepo": 73,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,102 +1,101 @@\n   void doCheckpoint() throws IOException {\n     BackupImage bnImage \u003d getFSImage();\n     NNStorage bnStorage \u003d bnImage.getStorage();\n \n     long startTime \u003d now();\n     bnImage.freezeNamespaceAtNextRoll();\n     \n     NamenodeCommand cmd \u003d \n       getRemoteNamenodeProxy().startCheckpoint(backupNode.getRegistration());\n     CheckpointCommand cpCmd \u003d null;\n     switch(cmd.getAction()) {\n       case NamenodeProtocol.ACT_SHUTDOWN:\n         shutdown();\n         throw new IOException(\"Name-node \" + backupNode.nnRpcAddress\n                                            + \" requested shutdown.\");\n       case NamenodeProtocol.ACT_CHECKPOINT:\n         cpCmd \u003d (CheckpointCommand)cmd;\n         break;\n       default:\n         throw new IOException(\"Unsupported NamenodeCommand: \"+cmd.getAction());\n     }\n \n     bnImage.waitUntilNamespaceFrozen();\n     \n     CheckpointSignature sig \u003d cpCmd.getSignature();\n \n     // Make sure we\u0027re talking to the same NN!\n     sig.validateStorageInfo(bnImage);\n \n     long lastApplied \u003d bnImage.getLastAppliedTxId();\n     LOG.debug(\"Doing checkpoint. Last applied: \" + lastApplied);\n     RemoteEditLogManifest manifest \u003d\n       getRemoteNamenodeProxy().getEditLogManifest(bnImage.getLastAppliedTxId() + 1);\n \n     boolean needReloadImage \u003d false;\n     if (!manifest.getLogs().isEmpty()) {\n       RemoteEditLog firstRemoteLog \u003d manifest.getLogs().get(0);\n       // we don\u0027t have enough logs to roll forward using only logs. Need\n       // to download and load the image.\n       if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n         LOG.info(\"Unable to roll forward using only logs. Downloading \" +\n             \"image with txid \" + sig.mostRecentCheckpointTxId);\n         MD5Hash downloadedHash \u003d TransferFsImage.downloadImageToStorage(\n             backupNode.nnHttpAddress, sig.mostRecentCheckpointTxId, bnStorage,\n             true);\n         bnImage.saveDigestAndRenameCheckpointImage(NameNodeFile.IMAGE,\n             sig.mostRecentCheckpointTxId, downloadedHash);\n         lastApplied \u003d sig.mostRecentCheckpointTxId;\n         needReloadImage \u003d true;\n       }\n \n       if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n         throw new IOException(\"No logs to roll forward from \" + lastApplied);\n       }\n   \n       // get edits files\n       for (RemoteEditLog log : manifest.getLogs()) {\n         TransferFsImage.downloadEditsToStorage(\n             backupNode.nnHttpAddress, log, bnStorage);\n       }\n \n       if(needReloadImage) {\n         LOG.info(\"Loading image with txid \" + sig.mostRecentCheckpointTxId);\n         File file \u003d bnStorage.findImageFile(NameNodeFile.IMAGE,\n             sig.mostRecentCheckpointTxId);\n         bnImage.reloadFromImageFile(file, backupNode.getNamesystem());\n       }\n       rollForwardByApplyingLogs(manifest, bnImage, backupNode.getNamesystem());\n     }\n     \n     long txid \u003d bnImage.getLastAppliedTxId();\n     \n     backupNode.namesystem.writeLock();\n     try {\n       backupNode.namesystem.dir.setReady();\n       if(backupNode.namesystem.getBlocksTotal() \u003e 0) {\n         backupNode.namesystem.setBlockTotal();\n       }\n       bnImage.saveFSImageInAllDirs(backupNode.getNamesystem(), txid);\n       bnStorage.writeAll();\n     } finally {\n       backupNode.namesystem.writeUnlock();\n     }\n \n     if(cpCmd.needToReturnImage()) {\n-      TransferFsImage.uploadImageFromStorage(\n-          backupNode.nnHttpAddress, getImageListenAddress(),\n+      TransferFsImage.uploadImageFromStorage(backupNode.nnHttpAddress, conf,\n           bnStorage, NameNodeFile.IMAGE, txid);\n     }\n \n     getRemoteNamenodeProxy().endCheckpoint(backupNode.getRegistration(), sig);\n \n     if (backupNode.getRole() \u003d\u003d NamenodeRole.BACKUP) {\n       bnImage.convergeJournalSpool();\n     }\n     backupNode.setRegistration(); // keep registration up to date\n     \n     long imageSize \u003d bnImage.getStorage().getFsImageName(txid).length();\n     LOG.info(\"Checkpoint completed in \"\n         + (now() - startTime)/1000 + \" seconds.\"\n         + \" New Image Size: \" + imageSize);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void doCheckpoint() throws IOException {\n    BackupImage bnImage \u003d getFSImage();\n    NNStorage bnStorage \u003d bnImage.getStorage();\n\n    long startTime \u003d now();\n    bnImage.freezeNamespaceAtNextRoll();\n    \n    NamenodeCommand cmd \u003d \n      getRemoteNamenodeProxy().startCheckpoint(backupNode.getRegistration());\n    CheckpointCommand cpCmd \u003d null;\n    switch(cmd.getAction()) {\n      case NamenodeProtocol.ACT_SHUTDOWN:\n        shutdown();\n        throw new IOException(\"Name-node \" + backupNode.nnRpcAddress\n                                           + \" requested shutdown.\");\n      case NamenodeProtocol.ACT_CHECKPOINT:\n        cpCmd \u003d (CheckpointCommand)cmd;\n        break;\n      default:\n        throw new IOException(\"Unsupported NamenodeCommand: \"+cmd.getAction());\n    }\n\n    bnImage.waitUntilNamespaceFrozen();\n    \n    CheckpointSignature sig \u003d cpCmd.getSignature();\n\n    // Make sure we\u0027re talking to the same NN!\n    sig.validateStorageInfo(bnImage);\n\n    long lastApplied \u003d bnImage.getLastAppliedTxId();\n    LOG.debug(\"Doing checkpoint. Last applied: \" + lastApplied);\n    RemoteEditLogManifest manifest \u003d\n      getRemoteNamenodeProxy().getEditLogManifest(bnImage.getLastAppliedTxId() + 1);\n\n    boolean needReloadImage \u003d false;\n    if (!manifest.getLogs().isEmpty()) {\n      RemoteEditLog firstRemoteLog \u003d manifest.getLogs().get(0);\n      // we don\u0027t have enough logs to roll forward using only logs. Need\n      // to download and load the image.\n      if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n        LOG.info(\"Unable to roll forward using only logs. Downloading \" +\n            \"image with txid \" + sig.mostRecentCheckpointTxId);\n        MD5Hash downloadedHash \u003d TransferFsImage.downloadImageToStorage(\n            backupNode.nnHttpAddress, sig.mostRecentCheckpointTxId, bnStorage,\n            true);\n        bnImage.saveDigestAndRenameCheckpointImage(NameNodeFile.IMAGE,\n            sig.mostRecentCheckpointTxId, downloadedHash);\n        lastApplied \u003d sig.mostRecentCheckpointTxId;\n        needReloadImage \u003d true;\n      }\n\n      if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n        throw new IOException(\"No logs to roll forward from \" + lastApplied);\n      }\n  \n      // get edits files\n      for (RemoteEditLog log : manifest.getLogs()) {\n        TransferFsImage.downloadEditsToStorage(\n            backupNode.nnHttpAddress, log, bnStorage);\n      }\n\n      if(needReloadImage) {\n        LOG.info(\"Loading image with txid \" + sig.mostRecentCheckpointTxId);\n        File file \u003d bnStorage.findImageFile(NameNodeFile.IMAGE,\n            sig.mostRecentCheckpointTxId);\n        bnImage.reloadFromImageFile(file, backupNode.getNamesystem());\n      }\n      rollForwardByApplyingLogs(manifest, bnImage, backupNode.getNamesystem());\n    }\n    \n    long txid \u003d bnImage.getLastAppliedTxId();\n    \n    backupNode.namesystem.writeLock();\n    try {\n      backupNode.namesystem.dir.setReady();\n      if(backupNode.namesystem.getBlocksTotal() \u003e 0) {\n        backupNode.namesystem.setBlockTotal();\n      }\n      bnImage.saveFSImageInAllDirs(backupNode.getNamesystem(), txid);\n      bnStorage.writeAll();\n    } finally {\n      backupNode.namesystem.writeUnlock();\n    }\n\n    if(cpCmd.needToReturnImage()) {\n      TransferFsImage.uploadImageFromStorage(backupNode.nnHttpAddress, conf,\n          bnStorage, NameNodeFile.IMAGE, txid);\n    }\n\n    getRemoteNamenodeProxy().endCheckpoint(backupNode.getRegistration(), sig);\n\n    if (backupNode.getRole() \u003d\u003d NamenodeRole.BACKUP) {\n      bnImage.convergeJournalSpool();\n    }\n    backupNode.setRegistration(); // keep registration up to date\n    \n    long imageSize \u003d bnImage.getStorage().getFsImageName(txid).length();\n    LOG.info(\"Checkpoint completed in \"\n        + (now() - startTime)/1000 + \" seconds.\"\n        + \" New Image Size: \" + imageSize);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/Checkpointer.java",
      "extendedDetails": {}
    },
    "e9a17c8ce0656a4e5d47401ca22a575c5f5f66db": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6029. Secondary NN fails to checkpoint after -rollingUpgrade prepare. Contributed by Jing Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-5535@1572800 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/02/14 5:21 PM",
      "commitName": "e9a17c8ce0656a4e5d47401ca22a575c5f5f66db",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "25/02/14 1:58 PM",
      "commitNameOld": "e3d2e4c156851de7dac16154521a2e06ea83ec7b",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 2.14,
      "commitsBetweenForRepo": 27,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,102 +1,102 @@\n   void doCheckpoint() throws IOException {\n     BackupImage bnImage \u003d getFSImage();\n     NNStorage bnStorage \u003d bnImage.getStorage();\n \n     long startTime \u003d now();\n     bnImage.freezeNamespaceAtNextRoll();\n     \n     NamenodeCommand cmd \u003d \n       getRemoteNamenodeProxy().startCheckpoint(backupNode.getRegistration());\n     CheckpointCommand cpCmd \u003d null;\n     switch(cmd.getAction()) {\n       case NamenodeProtocol.ACT_SHUTDOWN:\n         shutdown();\n         throw new IOException(\"Name-node \" + backupNode.nnRpcAddress\n                                            + \" requested shutdown.\");\n       case NamenodeProtocol.ACT_CHECKPOINT:\n         cpCmd \u003d (CheckpointCommand)cmd;\n         break;\n       default:\n         throw new IOException(\"Unsupported NamenodeCommand: \"+cmd.getAction());\n     }\n \n     bnImage.waitUntilNamespaceFrozen();\n     \n     CheckpointSignature sig \u003d cpCmd.getSignature();\n \n     // Make sure we\u0027re talking to the same NN!\n     sig.validateStorageInfo(bnImage);\n \n     long lastApplied \u003d bnImage.getLastAppliedTxId();\n     LOG.debug(\"Doing checkpoint. Last applied: \" + lastApplied);\n     RemoteEditLogManifest manifest \u003d\n       getRemoteNamenodeProxy().getEditLogManifest(bnImage.getLastAppliedTxId() + 1);\n \n     boolean needReloadImage \u003d false;\n     if (!manifest.getLogs().isEmpty()) {\n       RemoteEditLog firstRemoteLog \u003d manifest.getLogs().get(0);\n       // we don\u0027t have enough logs to roll forward using only logs. Need\n       // to download and load the image.\n       if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n         LOG.info(\"Unable to roll forward using only logs. Downloading \" +\n             \"image with txid \" + sig.mostRecentCheckpointTxId);\n         MD5Hash downloadedHash \u003d TransferFsImage.downloadImageToStorage(\n-            backupNode.nnHttpAddress, NameNodeFile.IMAGE,\n-            sig.mostRecentCheckpointTxId, bnStorage, true);\n+            backupNode.nnHttpAddress, sig.mostRecentCheckpointTxId, bnStorage,\n+            true);\n         bnImage.saveDigestAndRenameCheckpointImage(NameNodeFile.IMAGE,\n             sig.mostRecentCheckpointTxId, downloadedHash);\n         lastApplied \u003d sig.mostRecentCheckpointTxId;\n         needReloadImage \u003d true;\n       }\n \n       if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n         throw new IOException(\"No logs to roll forward from \" + lastApplied);\n       }\n   \n       // get edits files\n       for (RemoteEditLog log : manifest.getLogs()) {\n         TransferFsImage.downloadEditsToStorage(\n             backupNode.nnHttpAddress, log, bnStorage);\n       }\n \n       if(needReloadImage) {\n         LOG.info(\"Loading image with txid \" + sig.mostRecentCheckpointTxId);\n         File file \u003d bnStorage.findImageFile(NameNodeFile.IMAGE,\n             sig.mostRecentCheckpointTxId);\n         bnImage.reloadFromImageFile(file, backupNode.getNamesystem());\n       }\n       rollForwardByApplyingLogs(manifest, bnImage, backupNode.getNamesystem());\n     }\n     \n     long txid \u003d bnImage.getLastAppliedTxId();\n     \n     backupNode.namesystem.writeLock();\n     try {\n       backupNode.namesystem.dir.setReady();\n       if(backupNode.namesystem.getBlocksTotal() \u003e 0) {\n         backupNode.namesystem.setBlockTotal();\n       }\n       bnImage.saveFSImageInAllDirs(backupNode.getNamesystem(), txid);\n       bnStorage.writeAll();\n     } finally {\n       backupNode.namesystem.writeUnlock();\n     }\n \n     if(cpCmd.needToReturnImage()) {\n       TransferFsImage.uploadImageFromStorage(\n           backupNode.nnHttpAddress, getImageListenAddress(),\n           bnStorage, NameNodeFile.IMAGE, txid);\n     }\n \n     getRemoteNamenodeProxy().endCheckpoint(backupNode.getRegistration(), sig);\n \n     if (backupNode.getRole() \u003d\u003d NamenodeRole.BACKUP) {\n       bnImage.convergeJournalSpool();\n     }\n     backupNode.setRegistration(); // keep registration up to date\n     \n     long imageSize \u003d bnImage.getStorage().getFsImageName(txid).length();\n     LOG.info(\"Checkpoint completed in \"\n         + (now() - startTime)/1000 + \" seconds.\"\n         + \" New Image Size: \" + imageSize);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void doCheckpoint() throws IOException {\n    BackupImage bnImage \u003d getFSImage();\n    NNStorage bnStorage \u003d bnImage.getStorage();\n\n    long startTime \u003d now();\n    bnImage.freezeNamespaceAtNextRoll();\n    \n    NamenodeCommand cmd \u003d \n      getRemoteNamenodeProxy().startCheckpoint(backupNode.getRegistration());\n    CheckpointCommand cpCmd \u003d null;\n    switch(cmd.getAction()) {\n      case NamenodeProtocol.ACT_SHUTDOWN:\n        shutdown();\n        throw new IOException(\"Name-node \" + backupNode.nnRpcAddress\n                                           + \" requested shutdown.\");\n      case NamenodeProtocol.ACT_CHECKPOINT:\n        cpCmd \u003d (CheckpointCommand)cmd;\n        break;\n      default:\n        throw new IOException(\"Unsupported NamenodeCommand: \"+cmd.getAction());\n    }\n\n    bnImage.waitUntilNamespaceFrozen();\n    \n    CheckpointSignature sig \u003d cpCmd.getSignature();\n\n    // Make sure we\u0027re talking to the same NN!\n    sig.validateStorageInfo(bnImage);\n\n    long lastApplied \u003d bnImage.getLastAppliedTxId();\n    LOG.debug(\"Doing checkpoint. Last applied: \" + lastApplied);\n    RemoteEditLogManifest manifest \u003d\n      getRemoteNamenodeProxy().getEditLogManifest(bnImage.getLastAppliedTxId() + 1);\n\n    boolean needReloadImage \u003d false;\n    if (!manifest.getLogs().isEmpty()) {\n      RemoteEditLog firstRemoteLog \u003d manifest.getLogs().get(0);\n      // we don\u0027t have enough logs to roll forward using only logs. Need\n      // to download and load the image.\n      if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n        LOG.info(\"Unable to roll forward using only logs. Downloading \" +\n            \"image with txid \" + sig.mostRecentCheckpointTxId);\n        MD5Hash downloadedHash \u003d TransferFsImage.downloadImageToStorage(\n            backupNode.nnHttpAddress, sig.mostRecentCheckpointTxId, bnStorage,\n            true);\n        bnImage.saveDigestAndRenameCheckpointImage(NameNodeFile.IMAGE,\n            sig.mostRecentCheckpointTxId, downloadedHash);\n        lastApplied \u003d sig.mostRecentCheckpointTxId;\n        needReloadImage \u003d true;\n      }\n\n      if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n        throw new IOException(\"No logs to roll forward from \" + lastApplied);\n      }\n  \n      // get edits files\n      for (RemoteEditLog log : manifest.getLogs()) {\n        TransferFsImage.downloadEditsToStorage(\n            backupNode.nnHttpAddress, log, bnStorage);\n      }\n\n      if(needReloadImage) {\n        LOG.info(\"Loading image with txid \" + sig.mostRecentCheckpointTxId);\n        File file \u003d bnStorage.findImageFile(NameNodeFile.IMAGE,\n            sig.mostRecentCheckpointTxId);\n        bnImage.reloadFromImageFile(file, backupNode.getNamesystem());\n      }\n      rollForwardByApplyingLogs(manifest, bnImage, backupNode.getNamesystem());\n    }\n    \n    long txid \u003d bnImage.getLastAppliedTxId();\n    \n    backupNode.namesystem.writeLock();\n    try {\n      backupNode.namesystem.dir.setReady();\n      if(backupNode.namesystem.getBlocksTotal() \u003e 0) {\n        backupNode.namesystem.setBlockTotal();\n      }\n      bnImage.saveFSImageInAllDirs(backupNode.getNamesystem(), txid);\n      bnStorage.writeAll();\n    } finally {\n      backupNode.namesystem.writeUnlock();\n    }\n\n    if(cpCmd.needToReturnImage()) {\n      TransferFsImage.uploadImageFromStorage(\n          backupNode.nnHttpAddress, getImageListenAddress(),\n          bnStorage, NameNodeFile.IMAGE, txid);\n    }\n\n    getRemoteNamenodeProxy().endCheckpoint(backupNode.getRegistration(), sig);\n\n    if (backupNode.getRole() \u003d\u003d NamenodeRole.BACKUP) {\n      bnImage.convergeJournalSpool();\n    }\n    backupNode.setRegistration(); // keep registration up to date\n    \n    long imageSize \u003d bnImage.getStorage().getFsImageName(txid).length();\n    LOG.info(\"Checkpoint completed in \"\n        + (now() - startTime)/1000 + \" seconds.\"\n        + \" New Image Size: \" + imageSize);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/Checkpointer.java",
      "extendedDetails": {}
    },
    "e3d2e4c156851de7dac16154521a2e06ea83ec7b": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6000. Avoid saving namespace when starting rolling upgrade. Contributed by Jing Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-5535@1571840 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/02/14 1:58 PM",
      "commitName": "e3d2e4c156851de7dac16154521a2e06ea83ec7b",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "20/01/14 6:38 PM",
      "commitNameOld": "d8bc523754181b4c1321bcfab886ebf228d9c98f",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 35.81,
      "commitsBetweenForRepo": 323,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,101 +1,102 @@\n   void doCheckpoint() throws IOException {\n     BackupImage bnImage \u003d getFSImage();\n     NNStorage bnStorage \u003d bnImage.getStorage();\n \n     long startTime \u003d now();\n     bnImage.freezeNamespaceAtNextRoll();\n     \n     NamenodeCommand cmd \u003d \n       getRemoteNamenodeProxy().startCheckpoint(backupNode.getRegistration());\n     CheckpointCommand cpCmd \u003d null;\n     switch(cmd.getAction()) {\n       case NamenodeProtocol.ACT_SHUTDOWN:\n         shutdown();\n         throw new IOException(\"Name-node \" + backupNode.nnRpcAddress\n                                            + \" requested shutdown.\");\n       case NamenodeProtocol.ACT_CHECKPOINT:\n         cpCmd \u003d (CheckpointCommand)cmd;\n         break;\n       default:\n         throw new IOException(\"Unsupported NamenodeCommand: \"+cmd.getAction());\n     }\n \n     bnImage.waitUntilNamespaceFrozen();\n     \n     CheckpointSignature sig \u003d cpCmd.getSignature();\n \n     // Make sure we\u0027re talking to the same NN!\n     sig.validateStorageInfo(bnImage);\n \n     long lastApplied \u003d bnImage.getLastAppliedTxId();\n     LOG.debug(\"Doing checkpoint. Last applied: \" + lastApplied);\n     RemoteEditLogManifest manifest \u003d\n       getRemoteNamenodeProxy().getEditLogManifest(bnImage.getLastAppliedTxId() + 1);\n \n     boolean needReloadImage \u003d false;\n     if (!manifest.getLogs().isEmpty()) {\n       RemoteEditLog firstRemoteLog \u003d manifest.getLogs().get(0);\n       // we don\u0027t have enough logs to roll forward using only logs. Need\n       // to download and load the image.\n       if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n         LOG.info(\"Unable to roll forward using only logs. Downloading \" +\n             \"image with txid \" + sig.mostRecentCheckpointTxId);\n         MD5Hash downloadedHash \u003d TransferFsImage.downloadImageToStorage(\n-            backupNode.nnHttpAddress, sig.mostRecentCheckpointTxId,\n-            bnStorage, true);\n-        bnImage.saveDigestAndRenameCheckpointImage(\n+            backupNode.nnHttpAddress, NameNodeFile.IMAGE,\n+            sig.mostRecentCheckpointTxId, bnStorage, true);\n+        bnImage.saveDigestAndRenameCheckpointImage(NameNodeFile.IMAGE,\n             sig.mostRecentCheckpointTxId, downloadedHash);\n         lastApplied \u003d sig.mostRecentCheckpointTxId;\n         needReloadImage \u003d true;\n       }\n \n       if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n         throw new IOException(\"No logs to roll forward from \" + lastApplied);\n       }\n   \n       // get edits files\n       for (RemoteEditLog log : manifest.getLogs()) {\n         TransferFsImage.downloadEditsToStorage(\n             backupNode.nnHttpAddress, log, bnStorage);\n       }\n \n       if(needReloadImage) {\n         LOG.info(\"Loading image with txid \" + sig.mostRecentCheckpointTxId);\n-        File file \u003d bnStorage.findImageFile(sig.mostRecentCheckpointTxId);\n+        File file \u003d bnStorage.findImageFile(NameNodeFile.IMAGE,\n+            sig.mostRecentCheckpointTxId);\n         bnImage.reloadFromImageFile(file, backupNode.getNamesystem());\n       }\n       rollForwardByApplyingLogs(manifest, bnImage, backupNode.getNamesystem());\n     }\n     \n     long txid \u003d bnImage.getLastAppliedTxId();\n     \n     backupNode.namesystem.writeLock();\n     try {\n       backupNode.namesystem.dir.setReady();\n       if(backupNode.namesystem.getBlocksTotal() \u003e 0) {\n         backupNode.namesystem.setBlockTotal();\n       }\n       bnImage.saveFSImageInAllDirs(backupNode.getNamesystem(), txid);\n       bnStorage.writeAll();\n     } finally {\n       backupNode.namesystem.writeUnlock();\n     }\n \n     if(cpCmd.needToReturnImage()) {\n       TransferFsImage.uploadImageFromStorage(\n           backupNode.nnHttpAddress, getImageListenAddress(),\n-          bnStorage, txid);\n+          bnStorage, NameNodeFile.IMAGE, txid);\n     }\n \n     getRemoteNamenodeProxy().endCheckpoint(backupNode.getRegistration(), sig);\n \n     if (backupNode.getRole() \u003d\u003d NamenodeRole.BACKUP) {\n       bnImage.convergeJournalSpool();\n     }\n     backupNode.setRegistration(); // keep registration up to date\n     \n     long imageSize \u003d bnImage.getStorage().getFsImageName(txid).length();\n     LOG.info(\"Checkpoint completed in \"\n         + (now() - startTime)/1000 + \" seconds.\"\n         + \" New Image Size: \" + imageSize);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void doCheckpoint() throws IOException {\n    BackupImage bnImage \u003d getFSImage();\n    NNStorage bnStorage \u003d bnImage.getStorage();\n\n    long startTime \u003d now();\n    bnImage.freezeNamespaceAtNextRoll();\n    \n    NamenodeCommand cmd \u003d \n      getRemoteNamenodeProxy().startCheckpoint(backupNode.getRegistration());\n    CheckpointCommand cpCmd \u003d null;\n    switch(cmd.getAction()) {\n      case NamenodeProtocol.ACT_SHUTDOWN:\n        shutdown();\n        throw new IOException(\"Name-node \" + backupNode.nnRpcAddress\n                                           + \" requested shutdown.\");\n      case NamenodeProtocol.ACT_CHECKPOINT:\n        cpCmd \u003d (CheckpointCommand)cmd;\n        break;\n      default:\n        throw new IOException(\"Unsupported NamenodeCommand: \"+cmd.getAction());\n    }\n\n    bnImage.waitUntilNamespaceFrozen();\n    \n    CheckpointSignature sig \u003d cpCmd.getSignature();\n\n    // Make sure we\u0027re talking to the same NN!\n    sig.validateStorageInfo(bnImage);\n\n    long lastApplied \u003d bnImage.getLastAppliedTxId();\n    LOG.debug(\"Doing checkpoint. Last applied: \" + lastApplied);\n    RemoteEditLogManifest manifest \u003d\n      getRemoteNamenodeProxy().getEditLogManifest(bnImage.getLastAppliedTxId() + 1);\n\n    boolean needReloadImage \u003d false;\n    if (!manifest.getLogs().isEmpty()) {\n      RemoteEditLog firstRemoteLog \u003d manifest.getLogs().get(0);\n      // we don\u0027t have enough logs to roll forward using only logs. Need\n      // to download and load the image.\n      if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n        LOG.info(\"Unable to roll forward using only logs. Downloading \" +\n            \"image with txid \" + sig.mostRecentCheckpointTxId);\n        MD5Hash downloadedHash \u003d TransferFsImage.downloadImageToStorage(\n            backupNode.nnHttpAddress, NameNodeFile.IMAGE,\n            sig.mostRecentCheckpointTxId, bnStorage, true);\n        bnImage.saveDigestAndRenameCheckpointImage(NameNodeFile.IMAGE,\n            sig.mostRecentCheckpointTxId, downloadedHash);\n        lastApplied \u003d sig.mostRecentCheckpointTxId;\n        needReloadImage \u003d true;\n      }\n\n      if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n        throw new IOException(\"No logs to roll forward from \" + lastApplied);\n      }\n  \n      // get edits files\n      for (RemoteEditLog log : manifest.getLogs()) {\n        TransferFsImage.downloadEditsToStorage(\n            backupNode.nnHttpAddress, log, bnStorage);\n      }\n\n      if(needReloadImage) {\n        LOG.info(\"Loading image with txid \" + sig.mostRecentCheckpointTxId);\n        File file \u003d bnStorage.findImageFile(NameNodeFile.IMAGE,\n            sig.mostRecentCheckpointTxId);\n        bnImage.reloadFromImageFile(file, backupNode.getNamesystem());\n      }\n      rollForwardByApplyingLogs(manifest, bnImage, backupNode.getNamesystem());\n    }\n    \n    long txid \u003d bnImage.getLastAppliedTxId();\n    \n    backupNode.namesystem.writeLock();\n    try {\n      backupNode.namesystem.dir.setReady();\n      if(backupNode.namesystem.getBlocksTotal() \u003e 0) {\n        backupNode.namesystem.setBlockTotal();\n      }\n      bnImage.saveFSImageInAllDirs(backupNode.getNamesystem(), txid);\n      bnStorage.writeAll();\n    } finally {\n      backupNode.namesystem.writeUnlock();\n    }\n\n    if(cpCmd.needToReturnImage()) {\n      TransferFsImage.uploadImageFromStorage(\n          backupNode.nnHttpAddress, getImageListenAddress(),\n          bnStorage, NameNodeFile.IMAGE, txid);\n    }\n\n    getRemoteNamenodeProxy().endCheckpoint(backupNode.getRegistration(), sig);\n\n    if (backupNode.getRole() \u003d\u003d NamenodeRole.BACKUP) {\n      bnImage.convergeJournalSpool();\n    }\n    backupNode.setRegistration(); // keep registration up to date\n    \n    long imageSize \u003d bnImage.getStorage().getFsImageName(txid).length();\n    LOG.info(\"Checkpoint completed in \"\n        + (now() - startTime)/1000 + \" seconds.\"\n        + \" New Image Size: \" + imageSize);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/Checkpointer.java",
      "extendedDetails": {}
    },
    "573c41c2666e084f3988a288bb40d2305fc23d8f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4179. BackupNode: allow reads, fix checkpointing, safeMode. (shv)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1411508 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/11/12 6:00 PM",
      "commitName": "573c41c2666e084f3988a288bb40d2305fc23d8f",
      "commitAuthor": "Konstantin Shvachko",
      "commitDateOld": "15/07/12 7:58 PM",
      "commitNameOld": "0e8e499ff482c165d21c8e4f5ff9c33f306ca0d9",
      "commitAuthorOld": "Harsh J",
      "daysBetweenCommits": 126.96,
      "commitsBetweenForRepo": 755,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,97 +1,101 @@\n   void doCheckpoint() throws IOException {\n     BackupImage bnImage \u003d getFSImage();\n     NNStorage bnStorage \u003d bnImage.getStorage();\n \n     long startTime \u003d now();\n     bnImage.freezeNamespaceAtNextRoll();\n     \n     NamenodeCommand cmd \u003d \n       getRemoteNamenodeProxy().startCheckpoint(backupNode.getRegistration());\n     CheckpointCommand cpCmd \u003d null;\n     switch(cmd.getAction()) {\n       case NamenodeProtocol.ACT_SHUTDOWN:\n         shutdown();\n         throw new IOException(\"Name-node \" + backupNode.nnRpcAddress\n                                            + \" requested shutdown.\");\n       case NamenodeProtocol.ACT_CHECKPOINT:\n         cpCmd \u003d (CheckpointCommand)cmd;\n         break;\n       default:\n         throw new IOException(\"Unsupported NamenodeCommand: \"+cmd.getAction());\n     }\n \n     bnImage.waitUntilNamespaceFrozen();\n     \n     CheckpointSignature sig \u003d cpCmd.getSignature();\n \n     // Make sure we\u0027re talking to the same NN!\n     sig.validateStorageInfo(bnImage);\n \n     long lastApplied \u003d bnImage.getLastAppliedTxId();\n     LOG.debug(\"Doing checkpoint. Last applied: \" + lastApplied);\n     RemoteEditLogManifest manifest \u003d\n       getRemoteNamenodeProxy().getEditLogManifest(bnImage.getLastAppliedTxId() + 1);\n \n+    boolean needReloadImage \u003d false;\n     if (!manifest.getLogs().isEmpty()) {\n       RemoteEditLog firstRemoteLog \u003d manifest.getLogs().get(0);\n       // we don\u0027t have enough logs to roll forward using only logs. Need\n       // to download and load the image.\n       if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n         LOG.info(\"Unable to roll forward using only logs. Downloading \" +\n             \"image with txid \" + sig.mostRecentCheckpointTxId);\n         MD5Hash downloadedHash \u003d TransferFsImage.downloadImageToStorage(\n             backupNode.nnHttpAddress, sig.mostRecentCheckpointTxId,\n             bnStorage, true);\n         bnImage.saveDigestAndRenameCheckpointImage(\n             sig.mostRecentCheckpointTxId, downloadedHash);\n-        \n-        LOG.info(\"Loading image with txid \" + sig.mostRecentCheckpointTxId);\n-        File file \u003d bnStorage.findImageFile(sig.mostRecentCheckpointTxId);\n-        bnImage.reloadFromImageFile(file, backupNode.getNamesystem());\n+        lastApplied \u003d sig.mostRecentCheckpointTxId;\n+        needReloadImage \u003d true;\n       }\n-      \n-      lastApplied \u003d bnImage.getLastAppliedTxId();\n+\n       if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n         throw new IOException(\"No logs to roll forward from \" + lastApplied);\n       }\n   \n       // get edits files\n       for (RemoteEditLog log : manifest.getLogs()) {\n         TransferFsImage.downloadEditsToStorage(\n             backupNode.nnHttpAddress, log, bnStorage);\n       }\n-  \n+\n+      if(needReloadImage) {\n+        LOG.info(\"Loading image with txid \" + sig.mostRecentCheckpointTxId);\n+        File file \u003d bnStorage.findImageFile(sig.mostRecentCheckpointTxId);\n+        bnImage.reloadFromImageFile(file, backupNode.getNamesystem());\n+      }\n       rollForwardByApplyingLogs(manifest, bnImage, backupNode.getNamesystem());\n     }\n     \n     long txid \u003d bnImage.getLastAppliedTxId();\n     \n     backupNode.namesystem.writeLock();\n     try {\n       backupNode.namesystem.dir.setReady();\n-      backupNode.namesystem.setBlockTotal();\n-      \n+      if(backupNode.namesystem.getBlocksTotal() \u003e 0) {\n+        backupNode.namesystem.setBlockTotal();\n+      }\n       bnImage.saveFSImageInAllDirs(backupNode.getNamesystem(), txid);\n       bnStorage.writeAll();\n     } finally {\n       backupNode.namesystem.writeUnlock();\n     }\n \n     if(cpCmd.needToReturnImage()) {\n       TransferFsImage.uploadImageFromStorage(\n           backupNode.nnHttpAddress, getImageListenAddress(),\n           bnStorage, txid);\n     }\n \n     getRemoteNamenodeProxy().endCheckpoint(backupNode.getRegistration(), sig);\n \n     if (backupNode.getRole() \u003d\u003d NamenodeRole.BACKUP) {\n       bnImage.convergeJournalSpool();\n     }\n     backupNode.setRegistration(); // keep registration up to date\n     \n     long imageSize \u003d bnImage.getStorage().getFsImageName(txid).length();\n     LOG.info(\"Checkpoint completed in \"\n         + (now() - startTime)/1000 + \" seconds.\"\n         + \" New Image Size: \" + imageSize);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void doCheckpoint() throws IOException {\n    BackupImage bnImage \u003d getFSImage();\n    NNStorage bnStorage \u003d bnImage.getStorage();\n\n    long startTime \u003d now();\n    bnImage.freezeNamespaceAtNextRoll();\n    \n    NamenodeCommand cmd \u003d \n      getRemoteNamenodeProxy().startCheckpoint(backupNode.getRegistration());\n    CheckpointCommand cpCmd \u003d null;\n    switch(cmd.getAction()) {\n      case NamenodeProtocol.ACT_SHUTDOWN:\n        shutdown();\n        throw new IOException(\"Name-node \" + backupNode.nnRpcAddress\n                                           + \" requested shutdown.\");\n      case NamenodeProtocol.ACT_CHECKPOINT:\n        cpCmd \u003d (CheckpointCommand)cmd;\n        break;\n      default:\n        throw new IOException(\"Unsupported NamenodeCommand: \"+cmd.getAction());\n    }\n\n    bnImage.waitUntilNamespaceFrozen();\n    \n    CheckpointSignature sig \u003d cpCmd.getSignature();\n\n    // Make sure we\u0027re talking to the same NN!\n    sig.validateStorageInfo(bnImage);\n\n    long lastApplied \u003d bnImage.getLastAppliedTxId();\n    LOG.debug(\"Doing checkpoint. Last applied: \" + lastApplied);\n    RemoteEditLogManifest manifest \u003d\n      getRemoteNamenodeProxy().getEditLogManifest(bnImage.getLastAppliedTxId() + 1);\n\n    boolean needReloadImage \u003d false;\n    if (!manifest.getLogs().isEmpty()) {\n      RemoteEditLog firstRemoteLog \u003d manifest.getLogs().get(0);\n      // we don\u0027t have enough logs to roll forward using only logs. Need\n      // to download and load the image.\n      if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n        LOG.info(\"Unable to roll forward using only logs. Downloading \" +\n            \"image with txid \" + sig.mostRecentCheckpointTxId);\n        MD5Hash downloadedHash \u003d TransferFsImage.downloadImageToStorage(\n            backupNode.nnHttpAddress, sig.mostRecentCheckpointTxId,\n            bnStorage, true);\n        bnImage.saveDigestAndRenameCheckpointImage(\n            sig.mostRecentCheckpointTxId, downloadedHash);\n        lastApplied \u003d sig.mostRecentCheckpointTxId;\n        needReloadImage \u003d true;\n      }\n\n      if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n        throw new IOException(\"No logs to roll forward from \" + lastApplied);\n      }\n  \n      // get edits files\n      for (RemoteEditLog log : manifest.getLogs()) {\n        TransferFsImage.downloadEditsToStorage(\n            backupNode.nnHttpAddress, log, bnStorage);\n      }\n\n      if(needReloadImage) {\n        LOG.info(\"Loading image with txid \" + sig.mostRecentCheckpointTxId);\n        File file \u003d bnStorage.findImageFile(sig.mostRecentCheckpointTxId);\n        bnImage.reloadFromImageFile(file, backupNode.getNamesystem());\n      }\n      rollForwardByApplyingLogs(manifest, bnImage, backupNode.getNamesystem());\n    }\n    \n    long txid \u003d bnImage.getLastAppliedTxId();\n    \n    backupNode.namesystem.writeLock();\n    try {\n      backupNode.namesystem.dir.setReady();\n      if(backupNode.namesystem.getBlocksTotal() \u003e 0) {\n        backupNode.namesystem.setBlockTotal();\n      }\n      bnImage.saveFSImageInAllDirs(backupNode.getNamesystem(), txid);\n      bnStorage.writeAll();\n    } finally {\n      backupNode.namesystem.writeUnlock();\n    }\n\n    if(cpCmd.needToReturnImage()) {\n      TransferFsImage.uploadImageFromStorage(\n          backupNode.nnHttpAddress, getImageListenAddress(),\n          bnStorage, txid);\n    }\n\n    getRemoteNamenodeProxy().endCheckpoint(backupNode.getRegistration(), sig);\n\n    if (backupNode.getRole() \u003d\u003d NamenodeRole.BACKUP) {\n      bnImage.convergeJournalSpool();\n    }\n    backupNode.setRegistration(); // keep registration up to date\n    \n    long imageSize \u003d bnImage.getStorage().getFsImageName(txid).length();\n    LOG.info(\"Checkpoint completed in \"\n        + (now() - startTime)/1000 + \" seconds.\"\n        + \" New Image Size: \" + imageSize);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/Checkpointer.java",
      "extendedDetails": {}
    },
    "5b8dcb20a2fad2e7e9dee56c451f68f9d865b5ae": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2291. Allow the StandbyNode to make checkpoints in an HA setup. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1227411 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/01/12 4:22 PM",
      "commitName": "5b8dcb20a2fad2e7e9dee56c451f68f9d865b5ae",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "29/12/11 4:30 PM",
      "commitNameOld": "20a6560bdfd8c4e3b6c3ac9b0f0f62d32e3a2191",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 5.99,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,97 +1,97 @@\n   void doCheckpoint() throws IOException {\n     BackupImage bnImage \u003d getFSImage();\n     NNStorage bnStorage \u003d bnImage.getStorage();\n \n     long startTime \u003d now();\n     bnImage.freezeNamespaceAtNextRoll();\n     \n     NamenodeCommand cmd \u003d \n-      getNamenode().startCheckpoint(backupNode.getRegistration());\n+      getRemoteNamenodeProxy().startCheckpoint(backupNode.getRegistration());\n     CheckpointCommand cpCmd \u003d null;\n     switch(cmd.getAction()) {\n       case NamenodeProtocol.ACT_SHUTDOWN:\n         shutdown();\n         throw new IOException(\"Name-node \" + backupNode.nnRpcAddress\n                                            + \" requested shutdown.\");\n       case NamenodeProtocol.ACT_CHECKPOINT:\n         cpCmd \u003d (CheckpointCommand)cmd;\n         break;\n       default:\n         throw new IOException(\"Unsupported NamenodeCommand: \"+cmd.getAction());\n     }\n \n     bnImage.waitUntilNamespaceFrozen();\n     \n     CheckpointSignature sig \u003d cpCmd.getSignature();\n \n     // Make sure we\u0027re talking to the same NN!\n     sig.validateStorageInfo(bnImage);\n \n     long lastApplied \u003d bnImage.getLastAppliedTxId();\n     LOG.debug(\"Doing checkpoint. Last applied: \" + lastApplied);\n     RemoteEditLogManifest manifest \u003d\n-      getNamenode().getEditLogManifest(bnImage.getLastAppliedTxId() + 1);\n+      getRemoteNamenodeProxy().getEditLogManifest(bnImage.getLastAppliedTxId() + 1);\n \n     if (!manifest.getLogs().isEmpty()) {\n       RemoteEditLog firstRemoteLog \u003d manifest.getLogs().get(0);\n       // we don\u0027t have enough logs to roll forward using only logs. Need\n       // to download and load the image.\n       if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n         LOG.info(\"Unable to roll forward using only logs. Downloading \" +\n             \"image with txid \" + sig.mostRecentCheckpointTxId);\n         MD5Hash downloadedHash \u003d TransferFsImage.downloadImageToStorage(\n             backupNode.nnHttpAddress, sig.mostRecentCheckpointTxId,\n             bnStorage, true);\n         bnImage.saveDigestAndRenameCheckpointImage(\n             sig.mostRecentCheckpointTxId, downloadedHash);\n         \n         LOG.info(\"Loading image with txid \" + sig.mostRecentCheckpointTxId);\n         File file \u003d bnStorage.findImageFile(sig.mostRecentCheckpointTxId);\n         bnImage.reloadFromImageFile(file, backupNode.getNamesystem());\n       }\n       \n       lastApplied \u003d bnImage.getLastAppliedTxId();\n       if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n         throw new IOException(\"No logs to roll forward from \" + lastApplied);\n       }\n   \n       // get edits files\n       for (RemoteEditLog log : manifest.getLogs()) {\n         TransferFsImage.downloadEditsToStorage(\n             backupNode.nnHttpAddress, log, bnStorage);\n       }\n   \n       rollForwardByApplyingLogs(manifest, bnImage, backupNode.getNamesystem());\n     }\n     \n     long txid \u003d bnImage.getLastAppliedTxId();\n     \n     backupNode.namesystem.writeLock();\n     try {\n       backupNode.namesystem.dir.setReady();\n       backupNode.namesystem.setBlockTotal();\n       \n       bnImage.saveFSImageInAllDirs(backupNode.getNamesystem(), txid);\n       bnStorage.writeAll();\n     } finally {\n       backupNode.namesystem.writeUnlock();\n     }\n \n     if(cpCmd.needToReturnImage()) {\n       TransferFsImage.uploadImageFromStorage(\n           backupNode.nnHttpAddress, getImageListenAddress(),\n           bnStorage, txid);\n     }\n \n-    getNamenode().endCheckpoint(backupNode.getRegistration(), sig);\n+    getRemoteNamenodeProxy().endCheckpoint(backupNode.getRegistration(), sig);\n \n     if (backupNode.getRole() \u003d\u003d NamenodeRole.BACKUP) {\n       bnImage.convergeJournalSpool();\n     }\n     backupNode.setRegistration(); // keep registration up to date\n     \n     long imageSize \u003d bnImage.getStorage().getFsImageName(txid).length();\n     LOG.info(\"Checkpoint completed in \"\n         + (now() - startTime)/1000 + \" seconds.\"\n         + \" New Image Size: \" + imageSize);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void doCheckpoint() throws IOException {\n    BackupImage bnImage \u003d getFSImage();\n    NNStorage bnStorage \u003d bnImage.getStorage();\n\n    long startTime \u003d now();\n    bnImage.freezeNamespaceAtNextRoll();\n    \n    NamenodeCommand cmd \u003d \n      getRemoteNamenodeProxy().startCheckpoint(backupNode.getRegistration());\n    CheckpointCommand cpCmd \u003d null;\n    switch(cmd.getAction()) {\n      case NamenodeProtocol.ACT_SHUTDOWN:\n        shutdown();\n        throw new IOException(\"Name-node \" + backupNode.nnRpcAddress\n                                           + \" requested shutdown.\");\n      case NamenodeProtocol.ACT_CHECKPOINT:\n        cpCmd \u003d (CheckpointCommand)cmd;\n        break;\n      default:\n        throw new IOException(\"Unsupported NamenodeCommand: \"+cmd.getAction());\n    }\n\n    bnImage.waitUntilNamespaceFrozen();\n    \n    CheckpointSignature sig \u003d cpCmd.getSignature();\n\n    // Make sure we\u0027re talking to the same NN!\n    sig.validateStorageInfo(bnImage);\n\n    long lastApplied \u003d bnImage.getLastAppliedTxId();\n    LOG.debug(\"Doing checkpoint. Last applied: \" + lastApplied);\n    RemoteEditLogManifest manifest \u003d\n      getRemoteNamenodeProxy().getEditLogManifest(bnImage.getLastAppliedTxId() + 1);\n\n    if (!manifest.getLogs().isEmpty()) {\n      RemoteEditLog firstRemoteLog \u003d manifest.getLogs().get(0);\n      // we don\u0027t have enough logs to roll forward using only logs. Need\n      // to download and load the image.\n      if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n        LOG.info(\"Unable to roll forward using only logs. Downloading \" +\n            \"image with txid \" + sig.mostRecentCheckpointTxId);\n        MD5Hash downloadedHash \u003d TransferFsImage.downloadImageToStorage(\n            backupNode.nnHttpAddress, sig.mostRecentCheckpointTxId,\n            bnStorage, true);\n        bnImage.saveDigestAndRenameCheckpointImage(\n            sig.mostRecentCheckpointTxId, downloadedHash);\n        \n        LOG.info(\"Loading image with txid \" + sig.mostRecentCheckpointTxId);\n        File file \u003d bnStorage.findImageFile(sig.mostRecentCheckpointTxId);\n        bnImage.reloadFromImageFile(file, backupNode.getNamesystem());\n      }\n      \n      lastApplied \u003d bnImage.getLastAppliedTxId();\n      if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n        throw new IOException(\"No logs to roll forward from \" + lastApplied);\n      }\n  \n      // get edits files\n      for (RemoteEditLog log : manifest.getLogs()) {\n        TransferFsImage.downloadEditsToStorage(\n            backupNode.nnHttpAddress, log, bnStorage);\n      }\n  \n      rollForwardByApplyingLogs(manifest, bnImage, backupNode.getNamesystem());\n    }\n    \n    long txid \u003d bnImage.getLastAppliedTxId();\n    \n    backupNode.namesystem.writeLock();\n    try {\n      backupNode.namesystem.dir.setReady();\n      backupNode.namesystem.setBlockTotal();\n      \n      bnImage.saveFSImageInAllDirs(backupNode.getNamesystem(), txid);\n      bnStorage.writeAll();\n    } finally {\n      backupNode.namesystem.writeUnlock();\n    }\n\n    if(cpCmd.needToReturnImage()) {\n      TransferFsImage.uploadImageFromStorage(\n          backupNode.nnHttpAddress, getImageListenAddress(),\n          bnStorage, txid);\n    }\n\n    getRemoteNamenodeProxy().endCheckpoint(backupNode.getRegistration(), sig);\n\n    if (backupNode.getRole() \u003d\u003d NamenodeRole.BACKUP) {\n      bnImage.convergeJournalSpool();\n    }\n    backupNode.setRegistration(); // keep registration up to date\n    \n    long imageSize \u003d bnImage.getStorage().getFsImageName(txid).length();\n    LOG.info(\"Checkpoint completed in \"\n        + (now() - startTime)/1000 + \" seconds.\"\n        + \" New Image Size: \" + imageSize);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/Checkpointer.java",
      "extendedDetails": {}
    },
    "20a6560bdfd8c4e3b6c3ac9b0f0f62d32e3a2191": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2692. Fix bugs related to failover from/into safe mode. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1225709 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/12/11 4:30 PM",
      "commitName": "20a6560bdfd8c4e3b6c3ac9b0f0f62d32e3a2191",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "30/11/11 1:46 PM",
      "commitNameOld": "f87a4b40bc99e76602a75906df31747cfdbff78a",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 29.11,
      "commitsBetweenForRepo": 187,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,92 +1,97 @@\n   void doCheckpoint() throws IOException {\n     BackupImage bnImage \u003d getFSImage();\n     NNStorage bnStorage \u003d bnImage.getStorage();\n \n     long startTime \u003d now();\n     bnImage.freezeNamespaceAtNextRoll();\n     \n     NamenodeCommand cmd \u003d \n       getNamenode().startCheckpoint(backupNode.getRegistration());\n     CheckpointCommand cpCmd \u003d null;\n     switch(cmd.getAction()) {\n       case NamenodeProtocol.ACT_SHUTDOWN:\n         shutdown();\n         throw new IOException(\"Name-node \" + backupNode.nnRpcAddress\n                                            + \" requested shutdown.\");\n       case NamenodeProtocol.ACT_CHECKPOINT:\n         cpCmd \u003d (CheckpointCommand)cmd;\n         break;\n       default:\n         throw new IOException(\"Unsupported NamenodeCommand: \"+cmd.getAction());\n     }\n \n     bnImage.waitUntilNamespaceFrozen();\n     \n     CheckpointSignature sig \u003d cpCmd.getSignature();\n \n     // Make sure we\u0027re talking to the same NN!\n     sig.validateStorageInfo(bnImage);\n \n     long lastApplied \u003d bnImage.getLastAppliedTxId();\n     LOG.debug(\"Doing checkpoint. Last applied: \" + lastApplied);\n     RemoteEditLogManifest manifest \u003d\n       getNamenode().getEditLogManifest(bnImage.getLastAppliedTxId() + 1);\n \n     if (!manifest.getLogs().isEmpty()) {\n       RemoteEditLog firstRemoteLog \u003d manifest.getLogs().get(0);\n       // we don\u0027t have enough logs to roll forward using only logs. Need\n       // to download and load the image.\n       if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n         LOG.info(\"Unable to roll forward using only logs. Downloading \" +\n             \"image with txid \" + sig.mostRecentCheckpointTxId);\n         MD5Hash downloadedHash \u003d TransferFsImage.downloadImageToStorage(\n             backupNode.nnHttpAddress, sig.mostRecentCheckpointTxId,\n             bnStorage, true);\n         bnImage.saveDigestAndRenameCheckpointImage(\n             sig.mostRecentCheckpointTxId, downloadedHash);\n         \n         LOG.info(\"Loading image with txid \" + sig.mostRecentCheckpointTxId);\n         File file \u003d bnStorage.findImageFile(sig.mostRecentCheckpointTxId);\n         bnImage.reloadFromImageFile(file, backupNode.getNamesystem());\n       }\n       \n       lastApplied \u003d bnImage.getLastAppliedTxId();\n       if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n         throw new IOException(\"No logs to roll forward from \" + lastApplied);\n       }\n   \n       // get edits files\n       for (RemoteEditLog log : manifest.getLogs()) {\n         TransferFsImage.downloadEditsToStorage(\n             backupNode.nnHttpAddress, log, bnStorage);\n       }\n   \n       rollForwardByApplyingLogs(manifest, bnImage, backupNode.getNamesystem());\n     }\n     \n     long txid \u003d bnImage.getLastAppliedTxId();\n     \n-    backupNode.namesystem.dir.setReady();\n-    backupNode.namesystem.setBlockTotal();\n-    \n-    bnImage.saveFSImageInAllDirs(backupNode.getNamesystem(), txid);\n-    bnStorage.writeAll();\n+    backupNode.namesystem.writeLock();\n+    try {\n+      backupNode.namesystem.dir.setReady();\n+      backupNode.namesystem.setBlockTotal();\n+      \n+      bnImage.saveFSImageInAllDirs(backupNode.getNamesystem(), txid);\n+      bnStorage.writeAll();\n+    } finally {\n+      backupNode.namesystem.writeUnlock();\n+    }\n \n     if(cpCmd.needToReturnImage()) {\n       TransferFsImage.uploadImageFromStorage(\n           backupNode.nnHttpAddress, getImageListenAddress(),\n           bnStorage, txid);\n     }\n \n     getNamenode().endCheckpoint(backupNode.getRegistration(), sig);\n \n     if (backupNode.getRole() \u003d\u003d NamenodeRole.BACKUP) {\n       bnImage.convergeJournalSpool();\n     }\n     backupNode.setRegistration(); // keep registration up to date\n     \n     long imageSize \u003d bnImage.getStorage().getFsImageName(txid).length();\n     LOG.info(\"Checkpoint completed in \"\n         + (now() - startTime)/1000 + \" seconds.\"\n         + \" New Image Size: \" + imageSize);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void doCheckpoint() throws IOException {\n    BackupImage bnImage \u003d getFSImage();\n    NNStorage bnStorage \u003d bnImage.getStorage();\n\n    long startTime \u003d now();\n    bnImage.freezeNamespaceAtNextRoll();\n    \n    NamenodeCommand cmd \u003d \n      getNamenode().startCheckpoint(backupNode.getRegistration());\n    CheckpointCommand cpCmd \u003d null;\n    switch(cmd.getAction()) {\n      case NamenodeProtocol.ACT_SHUTDOWN:\n        shutdown();\n        throw new IOException(\"Name-node \" + backupNode.nnRpcAddress\n                                           + \" requested shutdown.\");\n      case NamenodeProtocol.ACT_CHECKPOINT:\n        cpCmd \u003d (CheckpointCommand)cmd;\n        break;\n      default:\n        throw new IOException(\"Unsupported NamenodeCommand: \"+cmd.getAction());\n    }\n\n    bnImage.waitUntilNamespaceFrozen();\n    \n    CheckpointSignature sig \u003d cpCmd.getSignature();\n\n    // Make sure we\u0027re talking to the same NN!\n    sig.validateStorageInfo(bnImage);\n\n    long lastApplied \u003d bnImage.getLastAppliedTxId();\n    LOG.debug(\"Doing checkpoint. Last applied: \" + lastApplied);\n    RemoteEditLogManifest manifest \u003d\n      getNamenode().getEditLogManifest(bnImage.getLastAppliedTxId() + 1);\n\n    if (!manifest.getLogs().isEmpty()) {\n      RemoteEditLog firstRemoteLog \u003d manifest.getLogs().get(0);\n      // we don\u0027t have enough logs to roll forward using only logs. Need\n      // to download and load the image.\n      if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n        LOG.info(\"Unable to roll forward using only logs. Downloading \" +\n            \"image with txid \" + sig.mostRecentCheckpointTxId);\n        MD5Hash downloadedHash \u003d TransferFsImage.downloadImageToStorage(\n            backupNode.nnHttpAddress, sig.mostRecentCheckpointTxId,\n            bnStorage, true);\n        bnImage.saveDigestAndRenameCheckpointImage(\n            sig.mostRecentCheckpointTxId, downloadedHash);\n        \n        LOG.info(\"Loading image with txid \" + sig.mostRecentCheckpointTxId);\n        File file \u003d bnStorage.findImageFile(sig.mostRecentCheckpointTxId);\n        bnImage.reloadFromImageFile(file, backupNode.getNamesystem());\n      }\n      \n      lastApplied \u003d bnImage.getLastAppliedTxId();\n      if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n        throw new IOException(\"No logs to roll forward from \" + lastApplied);\n      }\n  \n      // get edits files\n      for (RemoteEditLog log : manifest.getLogs()) {\n        TransferFsImage.downloadEditsToStorage(\n            backupNode.nnHttpAddress, log, bnStorage);\n      }\n  \n      rollForwardByApplyingLogs(manifest, bnImage, backupNode.getNamesystem());\n    }\n    \n    long txid \u003d bnImage.getLastAppliedTxId();\n    \n    backupNode.namesystem.writeLock();\n    try {\n      backupNode.namesystem.dir.setReady();\n      backupNode.namesystem.setBlockTotal();\n      \n      bnImage.saveFSImageInAllDirs(backupNode.getNamesystem(), txid);\n      bnStorage.writeAll();\n    } finally {\n      backupNode.namesystem.writeUnlock();\n    }\n\n    if(cpCmd.needToReturnImage()) {\n      TransferFsImage.uploadImageFromStorage(\n          backupNode.nnHttpAddress, getImageListenAddress(),\n          bnStorage, txid);\n    }\n\n    getNamenode().endCheckpoint(backupNode.getRegistration(), sig);\n\n    if (backupNode.getRole() \u003d\u003d NamenodeRole.BACKUP) {\n      bnImage.convergeJournalSpool();\n    }\n    backupNode.setRegistration(); // keep registration up to date\n    \n    long imageSize \u003d bnImage.getStorage().getFsImageName(txid).length();\n    LOG.info(\"Checkpoint completed in \"\n        + (now() - startTime)/1000 + \" seconds.\"\n        + \" New Image Size: \" + imageSize);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/Checkpointer.java",
      "extendedDetails": {}
    },
    "64c019cccc266b9896746d45e314cc4a59ba2e6e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2285. BackupNode should reject requests to modify namespace. Contributed by Konstantin Shvachko and Uma Maheswara Rao G.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1195013 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/10/11 1:11 PM",
      "commitName": "64c019cccc266b9896746d45e314cc4a59ba2e6e",
      "commitAuthor": "Konstantin Shvachko",
      "commitDateOld": "19/09/11 5:26 PM",
      "commitNameOld": "9d14f100c803be4dda557b586269a50301e8bd2a",
      "commitAuthorOld": "Matthew Foley",
      "daysBetweenCommits": 39.82,
      "commitsBetweenForRepo": 343,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,88 +1,92 @@\n   void doCheckpoint() throws IOException {\n     BackupImage bnImage \u003d getFSImage();\n     NNStorage bnStorage \u003d bnImage.getStorage();\n \n     long startTime \u003d now();\n     bnImage.freezeNamespaceAtNextRoll();\n     \n     NamenodeCommand cmd \u003d \n       getNamenode().startCheckpoint(backupNode.getRegistration());\n     CheckpointCommand cpCmd \u003d null;\n     switch(cmd.getAction()) {\n       case NamenodeProtocol.ACT_SHUTDOWN:\n         shutdown();\n         throw new IOException(\"Name-node \" + backupNode.nnRpcAddress\n                                            + \" requested shutdown.\");\n       case NamenodeProtocol.ACT_CHECKPOINT:\n         cpCmd \u003d (CheckpointCommand)cmd;\n         break;\n       default:\n         throw new IOException(\"Unsupported NamenodeCommand: \"+cmd.getAction());\n     }\n \n     bnImage.waitUntilNamespaceFrozen();\n     \n     CheckpointSignature sig \u003d cpCmd.getSignature();\n \n     // Make sure we\u0027re talking to the same NN!\n     sig.validateStorageInfo(bnImage);\n \n     long lastApplied \u003d bnImage.getLastAppliedTxId();\n     LOG.debug(\"Doing checkpoint. Last applied: \" + lastApplied);\n     RemoteEditLogManifest manifest \u003d\n       getNamenode().getEditLogManifest(bnImage.getLastAppliedTxId() + 1);\n \n     if (!manifest.getLogs().isEmpty()) {\n       RemoteEditLog firstRemoteLog \u003d manifest.getLogs().get(0);\n       // we don\u0027t have enough logs to roll forward using only logs. Need\n       // to download and load the image.\n       if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n         LOG.info(\"Unable to roll forward using only logs. Downloading \" +\n             \"image with txid \" + sig.mostRecentCheckpointTxId);\n         MD5Hash downloadedHash \u003d TransferFsImage.downloadImageToStorage(\n             backupNode.nnHttpAddress, sig.mostRecentCheckpointTxId,\n             bnStorage, true);\n         bnImage.saveDigestAndRenameCheckpointImage(\n             sig.mostRecentCheckpointTxId, downloadedHash);\n         \n         LOG.info(\"Loading image with txid \" + sig.mostRecentCheckpointTxId);\n         File file \u003d bnStorage.findImageFile(sig.mostRecentCheckpointTxId);\n         bnImage.reloadFromImageFile(file, backupNode.getNamesystem());\n       }\n       \n       lastApplied \u003d bnImage.getLastAppliedTxId();\n       if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n         throw new IOException(\"No logs to roll forward from \" + lastApplied);\n       }\n   \n       // get edits files\n       for (RemoteEditLog log : manifest.getLogs()) {\n         TransferFsImage.downloadEditsToStorage(\n             backupNode.nnHttpAddress, log, bnStorage);\n       }\n   \n       rollForwardByApplyingLogs(manifest, bnImage, backupNode.getNamesystem());\n     }\n-\n+    \n     long txid \u003d bnImage.getLastAppliedTxId();\n+    \n+    backupNode.namesystem.dir.setReady();\n+    backupNode.namesystem.setBlockTotal();\n+    \n     bnImage.saveFSImageInAllDirs(backupNode.getNamesystem(), txid);\n     bnStorage.writeAll();\n \n     if(cpCmd.needToReturnImage()) {\n       TransferFsImage.uploadImageFromStorage(\n           backupNode.nnHttpAddress, getImageListenAddress(),\n           bnStorage, txid);\n     }\n \n     getNamenode().endCheckpoint(backupNode.getRegistration(), sig);\n \n     if (backupNode.getRole() \u003d\u003d NamenodeRole.BACKUP) {\n       bnImage.convergeJournalSpool();\n     }\n     backupNode.setRegistration(); // keep registration up to date\n     \n     long imageSize \u003d bnImage.getStorage().getFsImageName(txid).length();\n     LOG.info(\"Checkpoint completed in \"\n         + (now() - startTime)/1000 + \" seconds.\"\n         + \" New Image Size: \" + imageSize);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void doCheckpoint() throws IOException {\n    BackupImage bnImage \u003d getFSImage();\n    NNStorage bnStorage \u003d bnImage.getStorage();\n\n    long startTime \u003d now();\n    bnImage.freezeNamespaceAtNextRoll();\n    \n    NamenodeCommand cmd \u003d \n      getNamenode().startCheckpoint(backupNode.getRegistration());\n    CheckpointCommand cpCmd \u003d null;\n    switch(cmd.getAction()) {\n      case NamenodeProtocol.ACT_SHUTDOWN:\n        shutdown();\n        throw new IOException(\"Name-node \" + backupNode.nnRpcAddress\n                                           + \" requested shutdown.\");\n      case NamenodeProtocol.ACT_CHECKPOINT:\n        cpCmd \u003d (CheckpointCommand)cmd;\n        break;\n      default:\n        throw new IOException(\"Unsupported NamenodeCommand: \"+cmd.getAction());\n    }\n\n    bnImage.waitUntilNamespaceFrozen();\n    \n    CheckpointSignature sig \u003d cpCmd.getSignature();\n\n    // Make sure we\u0027re talking to the same NN!\n    sig.validateStorageInfo(bnImage);\n\n    long lastApplied \u003d bnImage.getLastAppliedTxId();\n    LOG.debug(\"Doing checkpoint. Last applied: \" + lastApplied);\n    RemoteEditLogManifest manifest \u003d\n      getNamenode().getEditLogManifest(bnImage.getLastAppliedTxId() + 1);\n\n    if (!manifest.getLogs().isEmpty()) {\n      RemoteEditLog firstRemoteLog \u003d manifest.getLogs().get(0);\n      // we don\u0027t have enough logs to roll forward using only logs. Need\n      // to download and load the image.\n      if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n        LOG.info(\"Unable to roll forward using only logs. Downloading \" +\n            \"image with txid \" + sig.mostRecentCheckpointTxId);\n        MD5Hash downloadedHash \u003d TransferFsImage.downloadImageToStorage(\n            backupNode.nnHttpAddress, sig.mostRecentCheckpointTxId,\n            bnStorage, true);\n        bnImage.saveDigestAndRenameCheckpointImage(\n            sig.mostRecentCheckpointTxId, downloadedHash);\n        \n        LOG.info(\"Loading image with txid \" + sig.mostRecentCheckpointTxId);\n        File file \u003d bnStorage.findImageFile(sig.mostRecentCheckpointTxId);\n        bnImage.reloadFromImageFile(file, backupNode.getNamesystem());\n      }\n      \n      lastApplied \u003d bnImage.getLastAppliedTxId();\n      if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n        throw new IOException(\"No logs to roll forward from \" + lastApplied);\n      }\n  \n      // get edits files\n      for (RemoteEditLog log : manifest.getLogs()) {\n        TransferFsImage.downloadEditsToStorage(\n            backupNode.nnHttpAddress, log, bnStorage);\n      }\n  \n      rollForwardByApplyingLogs(manifest, bnImage, backupNode.getNamesystem());\n    }\n    \n    long txid \u003d bnImage.getLastAppliedTxId();\n    \n    backupNode.namesystem.dir.setReady();\n    backupNode.namesystem.setBlockTotal();\n    \n    bnImage.saveFSImageInAllDirs(backupNode.getNamesystem(), txid);\n    bnStorage.writeAll();\n\n    if(cpCmd.needToReturnImage()) {\n      TransferFsImage.uploadImageFromStorage(\n          backupNode.nnHttpAddress, getImageListenAddress(),\n          bnStorage, txid);\n    }\n\n    getNamenode().endCheckpoint(backupNode.getRegistration(), sig);\n\n    if (backupNode.getRole() \u003d\u003d NamenodeRole.BACKUP) {\n      bnImage.convergeJournalSpool();\n    }\n    backupNode.setRegistration(); // keep registration up to date\n    \n    long imageSize \u003d bnImage.getStorage().getFsImageName(txid).length();\n    LOG.info(\"Checkpoint completed in \"\n        + (now() - startTime)/1000 + \" seconds.\"\n        + \" New Image Size: \" + imageSize);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/Checkpointer.java",
      "extendedDetails": {}
    },
    "06e84a1bca19bd01568a3095e33944d4d6387fd3": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2223. Untangle depencencies between NN components. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1166466 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/09/11 4:23 PM",
      "commitName": "06e84a1bca19bd01568a3095e33944d4d6387fd3",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "06/09/11 1:27 PM",
      "commitNameOld": "bdc3720d5b67a1c8fc2dfb29be16e4155c0e7f15",
      "commitAuthorOld": "Jitendra Nath Pandey",
      "daysBetweenCommits": 1.12,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,88 +1,88 @@\n   void doCheckpoint() throws IOException {\n     BackupImage bnImage \u003d getFSImage();\n     NNStorage bnStorage \u003d bnImage.getStorage();\n \n     long startTime \u003d now();\n     bnImage.freezeNamespaceAtNextRoll();\n     \n     NamenodeCommand cmd \u003d \n       getNamenode().startCheckpoint(backupNode.getRegistration());\n     CheckpointCommand cpCmd \u003d null;\n     switch(cmd.getAction()) {\n       case NamenodeProtocol.ACT_SHUTDOWN:\n         shutdown();\n         throw new IOException(\"Name-node \" + backupNode.nnRpcAddress\n                                            + \" requested shutdown.\");\n       case NamenodeProtocol.ACT_CHECKPOINT:\n         cpCmd \u003d (CheckpointCommand)cmd;\n         break;\n       default:\n         throw new IOException(\"Unsupported NamenodeCommand: \"+cmd.getAction());\n     }\n \n     bnImage.waitUntilNamespaceFrozen();\n     \n     CheckpointSignature sig \u003d cpCmd.getSignature();\n \n     // Make sure we\u0027re talking to the same NN!\n     sig.validateStorageInfo(bnImage);\n \n     long lastApplied \u003d bnImage.getLastAppliedTxId();\n     LOG.debug(\"Doing checkpoint. Last applied: \" + lastApplied);\n     RemoteEditLogManifest manifest \u003d\n       getNamenode().getEditLogManifest(bnImage.getLastAppliedTxId() + 1);\n \n     if (!manifest.getLogs().isEmpty()) {\n       RemoteEditLog firstRemoteLog \u003d manifest.getLogs().get(0);\n       // we don\u0027t have enough logs to roll forward using only logs. Need\n       // to download and load the image.\n       if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n         LOG.info(\"Unable to roll forward using only logs. Downloading \" +\n             \"image with txid \" + sig.mostRecentCheckpointTxId);\n         MD5Hash downloadedHash \u003d TransferFsImage.downloadImageToStorage(\n             backupNode.nnHttpAddress, sig.mostRecentCheckpointTxId,\n             bnStorage, true);\n         bnImage.saveDigestAndRenameCheckpointImage(\n             sig.mostRecentCheckpointTxId, downloadedHash);\n         \n         LOG.info(\"Loading image with txid \" + sig.mostRecentCheckpointTxId);\n         File file \u003d bnStorage.findImageFile(sig.mostRecentCheckpointTxId);\n-        bnImage.reloadFromImageFile(file);\n+        bnImage.reloadFromImageFile(file, backupNode.getNamesystem());\n       }\n       \n       lastApplied \u003d bnImage.getLastAppliedTxId();\n       if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n         throw new IOException(\"No logs to roll forward from \" + lastApplied);\n       }\n   \n       // get edits files\n       for (RemoteEditLog log : manifest.getLogs()) {\n         TransferFsImage.downloadEditsToStorage(\n             backupNode.nnHttpAddress, log, bnStorage);\n       }\n   \n-      rollForwardByApplyingLogs(manifest, bnImage);\n+      rollForwardByApplyingLogs(manifest, bnImage, backupNode.getNamesystem());\n     }\n \n     long txid \u003d bnImage.getLastAppliedTxId();\n-    bnImage.saveFSImageInAllDirs(txid);\n+    bnImage.saveFSImageInAllDirs(backupNode.getNamesystem(), txid);\n     bnStorage.writeAll();\n \n     if(cpCmd.needToReturnImage()) {\n       TransferFsImage.uploadImageFromStorage(\n           backupNode.nnHttpAddress, getImageListenAddress(),\n           bnStorage, txid);\n     }\n \n     getNamenode().endCheckpoint(backupNode.getRegistration(), sig);\n \n     if (backupNode.getRole() \u003d\u003d NamenodeRole.BACKUP) {\n       bnImage.convergeJournalSpool();\n     }\n     backupNode.setRegistration(); // keep registration up to date\n     \n     long imageSize \u003d bnImage.getStorage().getFsImageName(txid).length();\n     LOG.info(\"Checkpoint completed in \"\n         + (now() - startTime)/1000 + \" seconds.\"\n         + \" New Image Size: \" + imageSize);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void doCheckpoint() throws IOException {\n    BackupImage bnImage \u003d getFSImage();\n    NNStorage bnStorage \u003d bnImage.getStorage();\n\n    long startTime \u003d now();\n    bnImage.freezeNamespaceAtNextRoll();\n    \n    NamenodeCommand cmd \u003d \n      getNamenode().startCheckpoint(backupNode.getRegistration());\n    CheckpointCommand cpCmd \u003d null;\n    switch(cmd.getAction()) {\n      case NamenodeProtocol.ACT_SHUTDOWN:\n        shutdown();\n        throw new IOException(\"Name-node \" + backupNode.nnRpcAddress\n                                           + \" requested shutdown.\");\n      case NamenodeProtocol.ACT_CHECKPOINT:\n        cpCmd \u003d (CheckpointCommand)cmd;\n        break;\n      default:\n        throw new IOException(\"Unsupported NamenodeCommand: \"+cmd.getAction());\n    }\n\n    bnImage.waitUntilNamespaceFrozen();\n    \n    CheckpointSignature sig \u003d cpCmd.getSignature();\n\n    // Make sure we\u0027re talking to the same NN!\n    sig.validateStorageInfo(bnImage);\n\n    long lastApplied \u003d bnImage.getLastAppliedTxId();\n    LOG.debug(\"Doing checkpoint. Last applied: \" + lastApplied);\n    RemoteEditLogManifest manifest \u003d\n      getNamenode().getEditLogManifest(bnImage.getLastAppliedTxId() + 1);\n\n    if (!manifest.getLogs().isEmpty()) {\n      RemoteEditLog firstRemoteLog \u003d manifest.getLogs().get(0);\n      // we don\u0027t have enough logs to roll forward using only logs. Need\n      // to download and load the image.\n      if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n        LOG.info(\"Unable to roll forward using only logs. Downloading \" +\n            \"image with txid \" + sig.mostRecentCheckpointTxId);\n        MD5Hash downloadedHash \u003d TransferFsImage.downloadImageToStorage(\n            backupNode.nnHttpAddress, sig.mostRecentCheckpointTxId,\n            bnStorage, true);\n        bnImage.saveDigestAndRenameCheckpointImage(\n            sig.mostRecentCheckpointTxId, downloadedHash);\n        \n        LOG.info(\"Loading image with txid \" + sig.mostRecentCheckpointTxId);\n        File file \u003d bnStorage.findImageFile(sig.mostRecentCheckpointTxId);\n        bnImage.reloadFromImageFile(file, backupNode.getNamesystem());\n      }\n      \n      lastApplied \u003d bnImage.getLastAppliedTxId();\n      if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n        throw new IOException(\"No logs to roll forward from \" + lastApplied);\n      }\n  \n      // get edits files\n      for (RemoteEditLog log : manifest.getLogs()) {\n        TransferFsImage.downloadEditsToStorage(\n            backupNode.nnHttpAddress, log, bnStorage);\n      }\n  \n      rollForwardByApplyingLogs(manifest, bnImage, backupNode.getNamesystem());\n    }\n\n    long txid \u003d bnImage.getLastAppliedTxId();\n    bnImage.saveFSImageInAllDirs(backupNode.getNamesystem(), txid);\n    bnStorage.writeAll();\n\n    if(cpCmd.needToReturnImage()) {\n      TransferFsImage.uploadImageFromStorage(\n          backupNode.nnHttpAddress, getImageListenAddress(),\n          bnStorage, txid);\n    }\n\n    getNamenode().endCheckpoint(backupNode.getRegistration(), sig);\n\n    if (backupNode.getRole() \u003d\u003d NamenodeRole.BACKUP) {\n      bnImage.convergeJournalSpool();\n    }\n    backupNode.setRegistration(); // keep registration up to date\n    \n    long imageSize \u003d bnImage.getStorage().getFsImageName(txid).length();\n    LOG.info(\"Checkpoint completed in \"\n        + (now() - startTime)/1000 + \" seconds.\"\n        + \" New Image Size: \" + imageSize);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/Checkpointer.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  void doCheckpoint() throws IOException {\n    BackupImage bnImage \u003d getFSImage();\n    NNStorage bnStorage \u003d bnImage.getStorage();\n\n    long startTime \u003d now();\n    bnImage.freezeNamespaceAtNextRoll();\n    \n    NamenodeCommand cmd \u003d \n      getNamenode().startCheckpoint(backupNode.getRegistration());\n    CheckpointCommand cpCmd \u003d null;\n    switch(cmd.getAction()) {\n      case NamenodeProtocol.ACT_SHUTDOWN:\n        shutdown();\n        throw new IOException(\"Name-node \" + backupNode.nnRpcAddress\n                                           + \" requested shutdown.\");\n      case NamenodeProtocol.ACT_CHECKPOINT:\n        cpCmd \u003d (CheckpointCommand)cmd;\n        break;\n      default:\n        throw new IOException(\"Unsupported NamenodeCommand: \"+cmd.getAction());\n    }\n\n    bnImage.waitUntilNamespaceFrozen();\n    \n    CheckpointSignature sig \u003d cpCmd.getSignature();\n\n    // Make sure we\u0027re talking to the same NN!\n    sig.validateStorageInfo(bnImage);\n\n    long lastApplied \u003d bnImage.getLastAppliedTxId();\n    LOG.debug(\"Doing checkpoint. Last applied: \" + lastApplied);\n    RemoteEditLogManifest manifest \u003d\n      getNamenode().getEditLogManifest(bnImage.getLastAppliedTxId() + 1);\n\n    if (!manifest.getLogs().isEmpty()) {\n      RemoteEditLog firstRemoteLog \u003d manifest.getLogs().get(0);\n      // we don\u0027t have enough logs to roll forward using only logs. Need\n      // to download and load the image.\n      if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n        LOG.info(\"Unable to roll forward using only logs. Downloading \" +\n            \"image with txid \" + sig.mostRecentCheckpointTxId);\n        MD5Hash downloadedHash \u003d TransferFsImage.downloadImageToStorage(\n            backupNode.nnHttpAddress, sig.mostRecentCheckpointTxId,\n            bnStorage, true);\n        bnImage.saveDigestAndRenameCheckpointImage(\n            sig.mostRecentCheckpointTxId, downloadedHash);\n        \n        LOG.info(\"Loading image with txid \" + sig.mostRecentCheckpointTxId);\n        File file \u003d bnStorage.findImageFile(sig.mostRecentCheckpointTxId);\n        bnImage.reloadFromImageFile(file);\n      }\n      \n      lastApplied \u003d bnImage.getLastAppliedTxId();\n      if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n        throw new IOException(\"No logs to roll forward from \" + lastApplied);\n      }\n  \n      // get edits files\n      for (RemoteEditLog log : manifest.getLogs()) {\n        TransferFsImage.downloadEditsToStorage(\n            backupNode.nnHttpAddress, log, bnStorage);\n      }\n  \n      rollForwardByApplyingLogs(manifest, bnImage);\n    }\n\n    long txid \u003d bnImage.getLastAppliedTxId();\n    bnImage.saveFSImageInAllDirs(txid);\n    bnStorage.writeAll();\n\n    if(cpCmd.needToReturnImage()) {\n      TransferFsImage.uploadImageFromStorage(\n          backupNode.nnHttpAddress, getImageListenAddress(),\n          bnStorage, txid);\n    }\n\n    getNamenode().endCheckpoint(backupNode.getRegistration(), sig);\n\n    if (backupNode.getRole() \u003d\u003d NamenodeRole.BACKUP) {\n      bnImage.convergeJournalSpool();\n    }\n    backupNode.setRegistration(); // keep registration up to date\n    \n    long imageSize \u003d bnImage.getStorage().getFsImageName(txid).length();\n    LOG.info(\"Checkpoint completed in \"\n        + (now() - startTime)/1000 + \" seconds.\"\n        + \" New Image Size: \" + imageSize);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/Checkpointer.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/Checkpointer.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/Checkpointer.java"
      }
    },
    "d86f3183d93714ba078416af4f609d26376eadb0": {
      "type": "Yfilerename",
      "commitMessage": "HDFS-2096. Mavenization of hadoop-hdfs. Contributed by Alejandro Abdelnur.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159702 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/08/11 10:36 AM",
      "commitName": "d86f3183d93714ba078416af4f609d26376eadb0",
      "commitAuthor": "Thomas White",
      "commitDateOld": "19/08/11 10:26 AM",
      "commitNameOld": "6ee5a73e0e91a2ef27753a32c576835e951d8119",
      "commitAuthorOld": "Thomas White",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  void doCheckpoint() throws IOException {\n    BackupImage bnImage \u003d getFSImage();\n    NNStorage bnStorage \u003d bnImage.getStorage();\n\n    long startTime \u003d now();\n    bnImage.freezeNamespaceAtNextRoll();\n    \n    NamenodeCommand cmd \u003d \n      getNamenode().startCheckpoint(backupNode.getRegistration());\n    CheckpointCommand cpCmd \u003d null;\n    switch(cmd.getAction()) {\n      case NamenodeProtocol.ACT_SHUTDOWN:\n        shutdown();\n        throw new IOException(\"Name-node \" + backupNode.nnRpcAddress\n                                           + \" requested shutdown.\");\n      case NamenodeProtocol.ACT_CHECKPOINT:\n        cpCmd \u003d (CheckpointCommand)cmd;\n        break;\n      default:\n        throw new IOException(\"Unsupported NamenodeCommand: \"+cmd.getAction());\n    }\n\n    bnImage.waitUntilNamespaceFrozen();\n    \n    CheckpointSignature sig \u003d cpCmd.getSignature();\n\n    // Make sure we\u0027re talking to the same NN!\n    sig.validateStorageInfo(bnImage);\n\n    long lastApplied \u003d bnImage.getLastAppliedTxId();\n    LOG.debug(\"Doing checkpoint. Last applied: \" + lastApplied);\n    RemoteEditLogManifest manifest \u003d\n      getNamenode().getEditLogManifest(bnImage.getLastAppliedTxId() + 1);\n\n    if (!manifest.getLogs().isEmpty()) {\n      RemoteEditLog firstRemoteLog \u003d manifest.getLogs().get(0);\n      // we don\u0027t have enough logs to roll forward using only logs. Need\n      // to download and load the image.\n      if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n        LOG.info(\"Unable to roll forward using only logs. Downloading \" +\n            \"image with txid \" + sig.mostRecentCheckpointTxId);\n        MD5Hash downloadedHash \u003d TransferFsImage.downloadImageToStorage(\n            backupNode.nnHttpAddress, sig.mostRecentCheckpointTxId,\n            bnStorage, true);\n        bnImage.saveDigestAndRenameCheckpointImage(\n            sig.mostRecentCheckpointTxId, downloadedHash);\n        \n        LOG.info(\"Loading image with txid \" + sig.mostRecentCheckpointTxId);\n        File file \u003d bnStorage.findImageFile(sig.mostRecentCheckpointTxId);\n        bnImage.reloadFromImageFile(file);\n      }\n      \n      lastApplied \u003d bnImage.getLastAppliedTxId();\n      if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n        throw new IOException(\"No logs to roll forward from \" + lastApplied);\n      }\n  \n      // get edits files\n      for (RemoteEditLog log : manifest.getLogs()) {\n        TransferFsImage.downloadEditsToStorage(\n            backupNode.nnHttpAddress, log, bnStorage);\n      }\n  \n      rollForwardByApplyingLogs(manifest, bnImage);\n    }\n\n    long txid \u003d bnImage.getLastAppliedTxId();\n    bnImage.saveFSImageInAllDirs(txid);\n    bnStorage.writeAll();\n\n    if(cpCmd.needToReturnImage()) {\n      TransferFsImage.uploadImageFromStorage(\n          backupNode.nnHttpAddress, getImageListenAddress(),\n          bnStorage, txid);\n    }\n\n    getNamenode().endCheckpoint(backupNode.getRegistration(), sig);\n\n    if (backupNode.getRole() \u003d\u003d NamenodeRole.BACKUP) {\n      bnImage.convergeJournalSpool();\n    }\n    backupNode.setRegistration(); // keep registration up to date\n    \n    long imageSize \u003d bnImage.getStorage().getFsImageName(txid).length();\n    LOG.info(\"Checkpoint completed in \"\n        + (now() - startTime)/1000 + \" seconds.\"\n        + \" New Image Size: \" + imageSize);\n  }",
      "path": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/Checkpointer.java",
      "extendedDetails": {
        "oldPath": "hdfs/src/java/org/apache/hadoop/hdfs/server/namenode/Checkpointer.java",
        "newPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/Checkpointer.java"
      }
    },
    "eb6e44b1ba58ed971360a39ea5d5ce02ae65aa0f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2227. getRemoteEditLogManifest should pull its information from FileJournalManager during checkpoint process. Contributed by Ivan Kelly and Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1155977 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/08/11 5:01 PM",
      "commitName": "eb6e44b1ba58ed971360a39ea5d5ce02ae65aa0f",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "29/07/11 9:28 AM",
      "commitNameOld": "28e6a4e44a3e920dcaf858f9a74a6358226b3a63",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 11.31,
      "commitsBetweenForRepo": 34,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,88 +1,88 @@\n   void doCheckpoint() throws IOException {\n     BackupImage bnImage \u003d getFSImage();\n     NNStorage bnStorage \u003d bnImage.getStorage();\n \n     long startTime \u003d now();\n     bnImage.freezeNamespaceAtNextRoll();\n     \n     NamenodeCommand cmd \u003d \n       getNamenode().startCheckpoint(backupNode.getRegistration());\n     CheckpointCommand cpCmd \u003d null;\n     switch(cmd.getAction()) {\n       case NamenodeProtocol.ACT_SHUTDOWN:\n         shutdown();\n         throw new IOException(\"Name-node \" + backupNode.nnRpcAddress\n                                            + \" requested shutdown.\");\n       case NamenodeProtocol.ACT_CHECKPOINT:\n         cpCmd \u003d (CheckpointCommand)cmd;\n         break;\n       default:\n         throw new IOException(\"Unsupported NamenodeCommand: \"+cmd.getAction());\n     }\n \n     bnImage.waitUntilNamespaceFrozen();\n     \n     CheckpointSignature sig \u003d cpCmd.getSignature();\n \n     // Make sure we\u0027re talking to the same NN!\n     sig.validateStorageInfo(bnImage);\n \n     long lastApplied \u003d bnImage.getLastAppliedTxId();\n     LOG.debug(\"Doing checkpoint. Last applied: \" + lastApplied);\n     RemoteEditLogManifest manifest \u003d\n-      getNamenode().getEditLogManifest(bnImage.getLastAppliedTxId());\n+      getNamenode().getEditLogManifest(bnImage.getLastAppliedTxId() + 1);\n \n     if (!manifest.getLogs().isEmpty()) {\n       RemoteEditLog firstRemoteLog \u003d manifest.getLogs().get(0);\n       // we don\u0027t have enough logs to roll forward using only logs. Need\n       // to download and load the image.\n       if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n         LOG.info(\"Unable to roll forward using only logs. Downloading \" +\n             \"image with txid \" + sig.mostRecentCheckpointTxId);\n         MD5Hash downloadedHash \u003d TransferFsImage.downloadImageToStorage(\n             backupNode.nnHttpAddress, sig.mostRecentCheckpointTxId,\n             bnStorage, true);\n         bnImage.saveDigestAndRenameCheckpointImage(\n             sig.mostRecentCheckpointTxId, downloadedHash);\n         \n         LOG.info(\"Loading image with txid \" + sig.mostRecentCheckpointTxId);\n         File file \u003d bnStorage.findImageFile(sig.mostRecentCheckpointTxId);\n         bnImage.reloadFromImageFile(file);\n       }\n       \n       lastApplied \u003d bnImage.getLastAppliedTxId();\n       if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n         throw new IOException(\"No logs to roll forward from \" + lastApplied);\n       }\n   \n       // get edits files\n       for (RemoteEditLog log : manifest.getLogs()) {\n         TransferFsImage.downloadEditsToStorage(\n             backupNode.nnHttpAddress, log, bnStorage);\n       }\n   \n       rollForwardByApplyingLogs(manifest, bnImage);\n     }\n \n     long txid \u003d bnImage.getLastAppliedTxId();\n     bnImage.saveFSImageInAllDirs(txid);\n     bnStorage.writeAll();\n \n     if(cpCmd.needToReturnImage()) {\n       TransferFsImage.uploadImageFromStorage(\n           backupNode.nnHttpAddress, getImageListenAddress(),\n           bnStorage, txid);\n     }\n \n     getNamenode().endCheckpoint(backupNode.getRegistration(), sig);\n \n     if (backupNode.getRole() \u003d\u003d NamenodeRole.BACKUP) {\n       bnImage.convergeJournalSpool();\n     }\n     backupNode.setRegistration(); // keep registration up to date\n     \n     long imageSize \u003d bnImage.getStorage().getFsImageName(txid).length();\n     LOG.info(\"Checkpoint completed in \"\n         + (now() - startTime)/1000 + \" seconds.\"\n         + \" New Image Size: \" + imageSize);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void doCheckpoint() throws IOException {\n    BackupImage bnImage \u003d getFSImage();\n    NNStorage bnStorage \u003d bnImage.getStorage();\n\n    long startTime \u003d now();\n    bnImage.freezeNamespaceAtNextRoll();\n    \n    NamenodeCommand cmd \u003d \n      getNamenode().startCheckpoint(backupNode.getRegistration());\n    CheckpointCommand cpCmd \u003d null;\n    switch(cmd.getAction()) {\n      case NamenodeProtocol.ACT_SHUTDOWN:\n        shutdown();\n        throw new IOException(\"Name-node \" + backupNode.nnRpcAddress\n                                           + \" requested shutdown.\");\n      case NamenodeProtocol.ACT_CHECKPOINT:\n        cpCmd \u003d (CheckpointCommand)cmd;\n        break;\n      default:\n        throw new IOException(\"Unsupported NamenodeCommand: \"+cmd.getAction());\n    }\n\n    bnImage.waitUntilNamespaceFrozen();\n    \n    CheckpointSignature sig \u003d cpCmd.getSignature();\n\n    // Make sure we\u0027re talking to the same NN!\n    sig.validateStorageInfo(bnImage);\n\n    long lastApplied \u003d bnImage.getLastAppliedTxId();\n    LOG.debug(\"Doing checkpoint. Last applied: \" + lastApplied);\n    RemoteEditLogManifest manifest \u003d\n      getNamenode().getEditLogManifest(bnImage.getLastAppliedTxId() + 1);\n\n    if (!manifest.getLogs().isEmpty()) {\n      RemoteEditLog firstRemoteLog \u003d manifest.getLogs().get(0);\n      // we don\u0027t have enough logs to roll forward using only logs. Need\n      // to download and load the image.\n      if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n        LOG.info(\"Unable to roll forward using only logs. Downloading \" +\n            \"image with txid \" + sig.mostRecentCheckpointTxId);\n        MD5Hash downloadedHash \u003d TransferFsImage.downloadImageToStorage(\n            backupNode.nnHttpAddress, sig.mostRecentCheckpointTxId,\n            bnStorage, true);\n        bnImage.saveDigestAndRenameCheckpointImage(\n            sig.mostRecentCheckpointTxId, downloadedHash);\n        \n        LOG.info(\"Loading image with txid \" + sig.mostRecentCheckpointTxId);\n        File file \u003d bnStorage.findImageFile(sig.mostRecentCheckpointTxId);\n        bnImage.reloadFromImageFile(file);\n      }\n      \n      lastApplied \u003d bnImage.getLastAppliedTxId();\n      if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n        throw new IOException(\"No logs to roll forward from \" + lastApplied);\n      }\n  \n      // get edits files\n      for (RemoteEditLog log : manifest.getLogs()) {\n        TransferFsImage.downloadEditsToStorage(\n            backupNode.nnHttpAddress, log, bnStorage);\n      }\n  \n      rollForwardByApplyingLogs(manifest, bnImage);\n    }\n\n    long txid \u003d bnImage.getLastAppliedTxId();\n    bnImage.saveFSImageInAllDirs(txid);\n    bnStorage.writeAll();\n\n    if(cpCmd.needToReturnImage()) {\n      TransferFsImage.uploadImageFromStorage(\n          backupNode.nnHttpAddress, getImageListenAddress(),\n          bnStorage, txid);\n    }\n\n    getNamenode().endCheckpoint(backupNode.getRegistration(), sig);\n\n    if (backupNode.getRole() \u003d\u003d NamenodeRole.BACKUP) {\n      bnImage.convergeJournalSpool();\n    }\n    backupNode.setRegistration(); // keep registration up to date\n    \n    long imageSize \u003d bnImage.getStorage().getFsImageName(txid).length();\n    LOG.info(\"Checkpoint completed in \"\n        + (now() - startTime)/1000 + \" seconds.\"\n        + \" New Image Size: \" + imageSize);\n  }",
      "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/namenode/Checkpointer.java",
      "extendedDetails": {}
    },
    "28e6a4e44a3e920dcaf858f9a74a6358226b3a63": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-1073. Redesign the NameNode\u0027s storage layout for image checkpoints and edit logs to introduce transaction IDs and be more robust. Contributed by Todd Lipcon and Ivan Kelly.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1152295 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/07/11 9:28 AM",
      "commitName": "28e6a4e44a3e920dcaf858f9a74a6358226b3a63",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "25/07/11 5:04 PM",
      "commitNameOld": "01cd616d170d5d26a539e51e731e8e73b789b360",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 3.68,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,50 +1,88 @@\n   void doCheckpoint() throws IOException {\n+    BackupImage bnImage \u003d getFSImage();\n+    NNStorage bnStorage \u003d bnImage.getStorage();\n+\n     long startTime \u003d now();\n+    bnImage.freezeNamespaceAtNextRoll();\n+    \n     NamenodeCommand cmd \u003d \n       getNamenode().startCheckpoint(backupNode.getRegistration());\n     CheckpointCommand cpCmd \u003d null;\n     switch(cmd.getAction()) {\n       case NamenodeProtocol.ACT_SHUTDOWN:\n         shutdown();\n         throw new IOException(\"Name-node \" + backupNode.nnRpcAddress\n                                            + \" requested shutdown.\");\n       case NamenodeProtocol.ACT_CHECKPOINT:\n         cpCmd \u003d (CheckpointCommand)cmd;\n         break;\n       default:\n         throw new IOException(\"Unsupported NamenodeCommand: \"+cmd.getAction());\n     }\n \n+    bnImage.waitUntilNamespaceFrozen();\n+    \n     CheckpointSignature sig \u003d cpCmd.getSignature();\n-    assert FSConstants.LAYOUT_VERSION \u003d\u003d sig.getLayoutVersion() :\n-      \"Signature should have current layout version. Expected: \"\n-      + FSConstants.LAYOUT_VERSION + \" actual \"+ sig.getLayoutVersion();\n-    assert !backupNode.isRole(NamenodeRole.CHECKPOINT) ||\n-      cpCmd.isImageObsolete() : \"checkpoint node should always download image.\";\n-    backupNode.setCheckpointState(CheckpointStates.UPLOAD_START);\n-    if(cpCmd.isImageObsolete()) {\n-      // First reset storage on disk and memory state\n-      backupNode.resetNamespace();\n-      downloadCheckpoint(sig);\n+\n+    // Make sure we\u0027re talking to the same NN!\n+    sig.validateStorageInfo(bnImage);\n+\n+    long lastApplied \u003d bnImage.getLastAppliedTxId();\n+    LOG.debug(\"Doing checkpoint. Last applied: \" + lastApplied);\n+    RemoteEditLogManifest manifest \u003d\n+      getNamenode().getEditLogManifest(bnImage.getLastAppliedTxId());\n+\n+    if (!manifest.getLogs().isEmpty()) {\n+      RemoteEditLog firstRemoteLog \u003d manifest.getLogs().get(0);\n+      // we don\u0027t have enough logs to roll forward using only logs. Need\n+      // to download and load the image.\n+      if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n+        LOG.info(\"Unable to roll forward using only logs. Downloading \" +\n+            \"image with txid \" + sig.mostRecentCheckpointTxId);\n+        MD5Hash downloadedHash \u003d TransferFsImage.downloadImageToStorage(\n+            backupNode.nnHttpAddress, sig.mostRecentCheckpointTxId,\n+            bnStorage, true);\n+        bnImage.saveDigestAndRenameCheckpointImage(\n+            sig.mostRecentCheckpointTxId, downloadedHash);\n+        \n+        LOG.info(\"Loading image with txid \" + sig.mostRecentCheckpointTxId);\n+        File file \u003d bnStorage.findImageFile(sig.mostRecentCheckpointTxId);\n+        bnImage.reloadFromImageFile(file);\n+      }\n+      \n+      lastApplied \u003d bnImage.getLastAppliedTxId();\n+      if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n+        throw new IOException(\"No logs to roll forward from \" + lastApplied);\n+      }\n+  \n+      // get edits files\n+      for (RemoteEditLog log : manifest.getLogs()) {\n+        TransferFsImage.downloadEditsToStorage(\n+            backupNode.nnHttpAddress, log, bnStorage);\n+      }\n+  \n+      rollForwardByApplyingLogs(manifest, bnImage);\n     }\n \n-    BackupImage bnImage \u003d getFSImage();\n-    bnImage.getStorage().setBlockPoolID(backupNode.getBlockPoolId());\n-    bnImage.getStorage().setClusterID(backupNode.getClusterId());\n-    bnImage.loadCheckpoint(sig);\n-    sig.validateStorageInfo(bnImage);\n-    bnImage.saveCheckpoint();\n+    long txid \u003d bnImage.getLastAppliedTxId();\n+    bnImage.saveFSImageInAllDirs(txid);\n+    bnStorage.writeAll();\n \n-    if(cpCmd.needToReturnImage())\n-      uploadCheckpoint(sig);\n+    if(cpCmd.needToReturnImage()) {\n+      TransferFsImage.uploadImageFromStorage(\n+          backupNode.nnHttpAddress, getImageListenAddress(),\n+          bnStorage, txid);\n+    }\n \n     getNamenode().endCheckpoint(backupNode.getRegistration(), sig);\n \n-    bnImage.convergeJournalSpool();\n+    if (backupNode.getRole() \u003d\u003d NamenodeRole.BACKUP) {\n+      bnImage.convergeJournalSpool();\n+    }\n     backupNode.setRegistration(); // keep registration up to date\n-    if(backupNode.isRole(NamenodeRole.CHECKPOINT))\n-        getFSImage().getEditLog().close();\n+    \n+    long imageSize \u003d bnImage.getStorage().getFsImageName(txid).length();\n     LOG.info(\"Checkpoint completed in \"\n         + (now() - startTime)/1000 + \" seconds.\"\n-        + \" New Image Size: \" + bnImage.getStorage().getFsImageName().length());\n+        + \" New Image Size: \" + imageSize);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void doCheckpoint() throws IOException {\n    BackupImage bnImage \u003d getFSImage();\n    NNStorage bnStorage \u003d bnImage.getStorage();\n\n    long startTime \u003d now();\n    bnImage.freezeNamespaceAtNextRoll();\n    \n    NamenodeCommand cmd \u003d \n      getNamenode().startCheckpoint(backupNode.getRegistration());\n    CheckpointCommand cpCmd \u003d null;\n    switch(cmd.getAction()) {\n      case NamenodeProtocol.ACT_SHUTDOWN:\n        shutdown();\n        throw new IOException(\"Name-node \" + backupNode.nnRpcAddress\n                                           + \" requested shutdown.\");\n      case NamenodeProtocol.ACT_CHECKPOINT:\n        cpCmd \u003d (CheckpointCommand)cmd;\n        break;\n      default:\n        throw new IOException(\"Unsupported NamenodeCommand: \"+cmd.getAction());\n    }\n\n    bnImage.waitUntilNamespaceFrozen();\n    \n    CheckpointSignature sig \u003d cpCmd.getSignature();\n\n    // Make sure we\u0027re talking to the same NN!\n    sig.validateStorageInfo(bnImage);\n\n    long lastApplied \u003d bnImage.getLastAppliedTxId();\n    LOG.debug(\"Doing checkpoint. Last applied: \" + lastApplied);\n    RemoteEditLogManifest manifest \u003d\n      getNamenode().getEditLogManifest(bnImage.getLastAppliedTxId());\n\n    if (!manifest.getLogs().isEmpty()) {\n      RemoteEditLog firstRemoteLog \u003d manifest.getLogs().get(0);\n      // we don\u0027t have enough logs to roll forward using only logs. Need\n      // to download and load the image.\n      if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n        LOG.info(\"Unable to roll forward using only logs. Downloading \" +\n            \"image with txid \" + sig.mostRecentCheckpointTxId);\n        MD5Hash downloadedHash \u003d TransferFsImage.downloadImageToStorage(\n            backupNode.nnHttpAddress, sig.mostRecentCheckpointTxId,\n            bnStorage, true);\n        bnImage.saveDigestAndRenameCheckpointImage(\n            sig.mostRecentCheckpointTxId, downloadedHash);\n        \n        LOG.info(\"Loading image with txid \" + sig.mostRecentCheckpointTxId);\n        File file \u003d bnStorage.findImageFile(sig.mostRecentCheckpointTxId);\n        bnImage.reloadFromImageFile(file);\n      }\n      \n      lastApplied \u003d bnImage.getLastAppliedTxId();\n      if (firstRemoteLog.getStartTxId() \u003e lastApplied + 1) {\n        throw new IOException(\"No logs to roll forward from \" + lastApplied);\n      }\n  \n      // get edits files\n      for (RemoteEditLog log : manifest.getLogs()) {\n        TransferFsImage.downloadEditsToStorage(\n            backupNode.nnHttpAddress, log, bnStorage);\n      }\n  \n      rollForwardByApplyingLogs(manifest, bnImage);\n    }\n\n    long txid \u003d bnImage.getLastAppliedTxId();\n    bnImage.saveFSImageInAllDirs(txid);\n    bnStorage.writeAll();\n\n    if(cpCmd.needToReturnImage()) {\n      TransferFsImage.uploadImageFromStorage(\n          backupNode.nnHttpAddress, getImageListenAddress(),\n          bnStorage, txid);\n    }\n\n    getNamenode().endCheckpoint(backupNode.getRegistration(), sig);\n\n    if (backupNode.getRole() \u003d\u003d NamenodeRole.BACKUP) {\n      bnImage.convergeJournalSpool();\n    }\n    backupNode.setRegistration(); // keep registration up to date\n    \n    long imageSize \u003d bnImage.getStorage().getFsImageName(txid).length();\n    LOG.info(\"Checkpoint completed in \"\n        + (now() - startTime)/1000 + \" seconds.\"\n        + \" New Image Size: \" + imageSize);\n  }",
      "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/namenode/Checkpointer.java",
      "extendedDetails": {}
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "diff": "@@ -0,0 +1,50 @@\n+  void doCheckpoint() throws IOException {\n+    long startTime \u003d now();\n+    NamenodeCommand cmd \u003d \n+      getNamenode().startCheckpoint(backupNode.getRegistration());\n+    CheckpointCommand cpCmd \u003d null;\n+    switch(cmd.getAction()) {\n+      case NamenodeProtocol.ACT_SHUTDOWN:\n+        shutdown();\n+        throw new IOException(\"Name-node \" + backupNode.nnRpcAddress\n+                                           + \" requested shutdown.\");\n+      case NamenodeProtocol.ACT_CHECKPOINT:\n+        cpCmd \u003d (CheckpointCommand)cmd;\n+        break;\n+      default:\n+        throw new IOException(\"Unsupported NamenodeCommand: \"+cmd.getAction());\n+    }\n+\n+    CheckpointSignature sig \u003d cpCmd.getSignature();\n+    assert FSConstants.LAYOUT_VERSION \u003d\u003d sig.getLayoutVersion() :\n+      \"Signature should have current layout version. Expected: \"\n+      + FSConstants.LAYOUT_VERSION + \" actual \"+ sig.getLayoutVersion();\n+    assert !backupNode.isRole(NamenodeRole.CHECKPOINT) ||\n+      cpCmd.isImageObsolete() : \"checkpoint node should always download image.\";\n+    backupNode.setCheckpointState(CheckpointStates.UPLOAD_START);\n+    if(cpCmd.isImageObsolete()) {\n+      // First reset storage on disk and memory state\n+      backupNode.resetNamespace();\n+      downloadCheckpoint(sig);\n+    }\n+\n+    BackupImage bnImage \u003d getFSImage();\n+    bnImage.getStorage().setBlockPoolID(backupNode.getBlockPoolId());\n+    bnImage.getStorage().setClusterID(backupNode.getClusterId());\n+    bnImage.loadCheckpoint(sig);\n+    sig.validateStorageInfo(bnImage);\n+    bnImage.saveCheckpoint();\n+\n+    if(cpCmd.needToReturnImage())\n+      uploadCheckpoint(sig);\n+\n+    getNamenode().endCheckpoint(backupNode.getRegistration(), sig);\n+\n+    bnImage.convergeJournalSpool();\n+    backupNode.setRegistration(); // keep registration up to date\n+    if(backupNode.isRole(NamenodeRole.CHECKPOINT))\n+        getFSImage().getEditLog().close();\n+    LOG.info(\"Checkpoint completed in \"\n+        + (now() - startTime)/1000 + \" seconds.\"\n+        + \" New Image Size: \" + bnImage.getStorage().getFsImageName().length());\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  void doCheckpoint() throws IOException {\n    long startTime \u003d now();\n    NamenodeCommand cmd \u003d \n      getNamenode().startCheckpoint(backupNode.getRegistration());\n    CheckpointCommand cpCmd \u003d null;\n    switch(cmd.getAction()) {\n      case NamenodeProtocol.ACT_SHUTDOWN:\n        shutdown();\n        throw new IOException(\"Name-node \" + backupNode.nnRpcAddress\n                                           + \" requested shutdown.\");\n      case NamenodeProtocol.ACT_CHECKPOINT:\n        cpCmd \u003d (CheckpointCommand)cmd;\n        break;\n      default:\n        throw new IOException(\"Unsupported NamenodeCommand: \"+cmd.getAction());\n    }\n\n    CheckpointSignature sig \u003d cpCmd.getSignature();\n    assert FSConstants.LAYOUT_VERSION \u003d\u003d sig.getLayoutVersion() :\n      \"Signature should have current layout version. Expected: \"\n      + FSConstants.LAYOUT_VERSION + \" actual \"+ sig.getLayoutVersion();\n    assert !backupNode.isRole(NamenodeRole.CHECKPOINT) ||\n      cpCmd.isImageObsolete() : \"checkpoint node should always download image.\";\n    backupNode.setCheckpointState(CheckpointStates.UPLOAD_START);\n    if(cpCmd.isImageObsolete()) {\n      // First reset storage on disk and memory state\n      backupNode.resetNamespace();\n      downloadCheckpoint(sig);\n    }\n\n    BackupImage bnImage \u003d getFSImage();\n    bnImage.getStorage().setBlockPoolID(backupNode.getBlockPoolId());\n    bnImage.getStorage().setClusterID(backupNode.getClusterId());\n    bnImage.loadCheckpoint(sig);\n    sig.validateStorageInfo(bnImage);\n    bnImage.saveCheckpoint();\n\n    if(cpCmd.needToReturnImage())\n      uploadCheckpoint(sig);\n\n    getNamenode().endCheckpoint(backupNode.getRegistration(), sig);\n\n    bnImage.convergeJournalSpool();\n    backupNode.setRegistration(); // keep registration up to date\n    if(backupNode.isRole(NamenodeRole.CHECKPOINT))\n        getFSImage().getEditLog().close();\n    LOG.info(\"Checkpoint completed in \"\n        + (now() - startTime)/1000 + \" seconds.\"\n        + \" New Image Size: \" + bnImage.getStorage().getFsImageName().length());\n  }",
      "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/namenode/Checkpointer.java"
    }
  }
}