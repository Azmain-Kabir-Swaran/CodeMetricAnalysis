{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "DFSStripedOutputStream.java",
  "functionName": "getAckedLength",
  "functionId": "getAckedLength",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/DFSStripedOutputStream.java",
  "functionStartLine": 903,
  "functionEndLine": 992,
  "numCommitsSeen": 38,
  "timeTaken": 836,
  "changeHistory": [
    "ccd2ac60ecc5fccce56debf21a068e663c1d5f11"
  ],
  "changeHistoryShort": {
    "ccd2ac60ecc5fccce56debf21a068e663c1d5f11": "Yintroduced"
  },
  "changeHistoryDetails": {
    "ccd2ac60ecc5fccce56debf21a068e663c1d5f11": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-11882. Precisely calculate acked length of striped block groups in updatePipeline.\n",
      "commitDate": "05/09/17 2:16 PM",
      "commitName": "ccd2ac60ecc5fccce56debf21a068e663c1d5f11",
      "commitAuthor": "Andrew Wang",
      "diff": "@@ -0,0 +1,90 @@\n+  private long getAckedLength() {\n+    // Determine the number of full stripes that are sufficiently durable\n+    final long sentBytes \u003d currentBlockGroup.getNumBytes();\n+    final long numFullStripes \u003d sentBytes / numDataBlocks / cellSize;\n+    final long fullStripeLength \u003d numFullStripes * numDataBlocks * cellSize;\n+    assert fullStripeLength \u003c\u003d sentBytes : \"Full stripe length can\u0027t be \" +\n+        \"greater than the block group length\";\n+\n+    long ackedLength \u003d 0;\n+\n+    // Determine the length contained by at least `numDataBlocks` blocks.\n+    // Since it\u0027s sorted, all the blocks after `offset` are at least as long,\n+    // and there are at least `numDataBlocks` at or after `offset`.\n+    List\u003cLong\u003e blockLengths \u003d Collections.unmodifiableList(getBlockLengths());\n+    List\u003cLong\u003e sortedBlockLengths \u003d new ArrayList\u003c\u003e(blockLengths);\n+    Collections.sort(sortedBlockLengths);\n+    if (numFullStripes \u003e 0) {\n+      final int offset \u003d sortedBlockLengths.size() - numDataBlocks;\n+      ackedLength \u003d sortedBlockLengths.get(offset) * numDataBlocks;\n+    }\n+\n+    // If the acked length is less than the expected full stripe length, then\n+    // we\u0027re missing a full stripe. Return the acked length.\n+    if (ackedLength \u003c fullStripeLength) {\n+      return ackedLength;\n+    }\n+    // If the expected length is exactly a stripe boundary, then we\u0027re also done\n+    if (ackedLength \u003d\u003d sentBytes) {\n+      return ackedLength;\n+    }\n+\n+    /*\n+    Otherwise, we\u0027re potentially dealing with a partial stripe.\n+    The partial stripe is laid out as follows:\n+\n+      0 or more full data cells, `cellSize` in length.\n+      0 or 1 partial data cells.\n+      0 or more empty data cells.\n+      `numParityBlocks` parity cells, the length of the longest data cell.\n+\n+    If the partial stripe is sufficiently acked, we\u0027ll update the ackedLength.\n+    */\n+\n+    // How many full and empty data cells do we expect?\n+    final int numFullDataCells \u003d (int)\n+        ((sentBytes - fullStripeLength) / cellSize);\n+    final int partialLength \u003d (int) (sentBytes - fullStripeLength) % cellSize;\n+    final int numPartialDataCells \u003d partialLength \u003d\u003d 0 ? 0 : 1;\n+    final int numEmptyDataCells \u003d numDataBlocks - numFullDataCells -\n+        numPartialDataCells;\n+    // Calculate the expected length of the parity blocks.\n+    final int parityLength \u003d numFullDataCells \u003e 0 ? cellSize : partialLength;\n+\n+    final long fullStripeBlockOffset \u003d fullStripeLength / numDataBlocks;\n+\n+    // Iterate through each type of streamers, checking the expected length.\n+    long[] expectedBlockLengths \u003d new long[numAllBlocks];\n+    int idx \u003d 0;\n+    // Full cells\n+    for (; idx \u003c numFullDataCells; idx++) {\n+      expectedBlockLengths[idx] \u003d fullStripeBlockOffset + cellSize;\n+    }\n+    // Partial cell\n+    for (; idx \u003c numFullDataCells + numPartialDataCells; idx++) {\n+      expectedBlockLengths[idx] \u003d fullStripeBlockOffset + partialLength;\n+    }\n+    // Empty cells\n+    for (; idx \u003c numFullDataCells + numPartialDataCells + numEmptyDataCells;\n+         idx++) {\n+      expectedBlockLengths[idx] \u003d fullStripeBlockOffset;\n+    }\n+    // Parity cells\n+    for (; idx \u003c numAllBlocks; idx++) {\n+      expectedBlockLengths[idx] \u003d fullStripeBlockOffset + parityLength;\n+    }\n+\n+    // Check expected lengths against actual streamer lengths.\n+    // Update if we have sufficient durability.\n+    int numBlocksWithCorrectLength \u003d 0;\n+    for (int i \u003d 0; i \u003c numAllBlocks; i++) {\n+      if (blockLengths.get(i) \u003d\u003d expectedBlockLengths[i]) {\n+        numBlocksWithCorrectLength++;\n+      }\n+    }\n+    if (numBlocksWithCorrectLength \u003e\u003d numDataBlocks) {\n+      ackedLength \u003d sentBytes;\n+    }\n+\n+    return ackedLength;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private long getAckedLength() {\n    // Determine the number of full stripes that are sufficiently durable\n    final long sentBytes \u003d currentBlockGroup.getNumBytes();\n    final long numFullStripes \u003d sentBytes / numDataBlocks / cellSize;\n    final long fullStripeLength \u003d numFullStripes * numDataBlocks * cellSize;\n    assert fullStripeLength \u003c\u003d sentBytes : \"Full stripe length can\u0027t be \" +\n        \"greater than the block group length\";\n\n    long ackedLength \u003d 0;\n\n    // Determine the length contained by at least `numDataBlocks` blocks.\n    // Since it\u0027s sorted, all the blocks after `offset` are at least as long,\n    // and there are at least `numDataBlocks` at or after `offset`.\n    List\u003cLong\u003e blockLengths \u003d Collections.unmodifiableList(getBlockLengths());\n    List\u003cLong\u003e sortedBlockLengths \u003d new ArrayList\u003c\u003e(blockLengths);\n    Collections.sort(sortedBlockLengths);\n    if (numFullStripes \u003e 0) {\n      final int offset \u003d sortedBlockLengths.size() - numDataBlocks;\n      ackedLength \u003d sortedBlockLengths.get(offset) * numDataBlocks;\n    }\n\n    // If the acked length is less than the expected full stripe length, then\n    // we\u0027re missing a full stripe. Return the acked length.\n    if (ackedLength \u003c fullStripeLength) {\n      return ackedLength;\n    }\n    // If the expected length is exactly a stripe boundary, then we\u0027re also done\n    if (ackedLength \u003d\u003d sentBytes) {\n      return ackedLength;\n    }\n\n    /*\n    Otherwise, we\u0027re potentially dealing with a partial stripe.\n    The partial stripe is laid out as follows:\n\n      0 or more full data cells, `cellSize` in length.\n      0 or 1 partial data cells.\n      0 or more empty data cells.\n      `numParityBlocks` parity cells, the length of the longest data cell.\n\n    If the partial stripe is sufficiently acked, we\u0027ll update the ackedLength.\n    */\n\n    // How many full and empty data cells do we expect?\n    final int numFullDataCells \u003d (int)\n        ((sentBytes - fullStripeLength) / cellSize);\n    final int partialLength \u003d (int) (sentBytes - fullStripeLength) % cellSize;\n    final int numPartialDataCells \u003d partialLength \u003d\u003d 0 ? 0 : 1;\n    final int numEmptyDataCells \u003d numDataBlocks - numFullDataCells -\n        numPartialDataCells;\n    // Calculate the expected length of the parity blocks.\n    final int parityLength \u003d numFullDataCells \u003e 0 ? cellSize : partialLength;\n\n    final long fullStripeBlockOffset \u003d fullStripeLength / numDataBlocks;\n\n    // Iterate through each type of streamers, checking the expected length.\n    long[] expectedBlockLengths \u003d new long[numAllBlocks];\n    int idx \u003d 0;\n    // Full cells\n    for (; idx \u003c numFullDataCells; idx++) {\n      expectedBlockLengths[idx] \u003d fullStripeBlockOffset + cellSize;\n    }\n    // Partial cell\n    for (; idx \u003c numFullDataCells + numPartialDataCells; idx++) {\n      expectedBlockLengths[idx] \u003d fullStripeBlockOffset + partialLength;\n    }\n    // Empty cells\n    for (; idx \u003c numFullDataCells + numPartialDataCells + numEmptyDataCells;\n         idx++) {\n      expectedBlockLengths[idx] \u003d fullStripeBlockOffset;\n    }\n    // Parity cells\n    for (; idx \u003c numAllBlocks; idx++) {\n      expectedBlockLengths[idx] \u003d fullStripeBlockOffset + parityLength;\n    }\n\n    // Check expected lengths against actual streamer lengths.\n    // Update if we have sufficient durability.\n    int numBlocksWithCorrectLength \u003d 0;\n    for (int i \u003d 0; i \u003c numAllBlocks; i++) {\n      if (blockLengths.get(i) \u003d\u003d expectedBlockLengths[i]) {\n        numBlocksWithCorrectLength++;\n      }\n    }\n    if (numBlocksWithCorrectLength \u003e\u003d numDataBlocks) {\n      ackedLength \u003d sentBytes;\n    }\n\n    return ackedLength;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/DFSStripedOutputStream.java"
    }
  }
}