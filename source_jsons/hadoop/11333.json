{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "AvailableSpaceVolumeChoosingPolicy.java",
  "functionName": "doChooseVolume",
  "functionId": "doChooseVolume___volumes-List__V__(modifiers-final)__replicaSize-long__storageId-String",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/AvailableSpaceVolumeChoosingPolicy.java",
  "functionStartLine": 133,
  "functionEndLine": 187,
  "numCommitsSeen": 21,
  "timeTaken": 2683,
  "changeHistory": [
    "a3954ccab148bddc290cb96528e63ff19799bcc9",
    "3a23dc683c058d3a5262ae9dca2d1c8c588a6a3e"
  ],
  "changeHistoryShort": {
    "a3954ccab148bddc290cb96528e63ff19799bcc9": "Ymultichange(Yparameterchange,Ybodychange)",
    "3a23dc683c058d3a5262ae9dca2d1c8c588a6a3e": "Yintroduced"
  },
  "changeHistoryDetails": {
    "a3954ccab148bddc290cb96528e63ff19799bcc9": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-9807. Add an optional StorageID to writes. Contributed by Ewan Higgs\n",
      "commitDate": "05/05/17 12:01 PM",
      "commitName": "a3954ccab148bddc290cb96528e63ff19799bcc9",
      "commitAuthor": "Chris Douglas",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-9807. Add an optional StorageID to writes. Contributed by Ewan Higgs\n",
          "commitDate": "05/05/17 12:01 PM",
          "commitName": "a3954ccab148bddc290cb96528e63ff19799bcc9",
          "commitAuthor": "Chris Douglas",
          "commitDateOld": "17/02/16 11:29 AM",
          "commitNameOld": "3a23dc683c058d3a5262ae9dca2d1c8c588a6a3e",
          "commitAuthorOld": "Andrew Wang",
          "daysBetweenCommits": 442.98,
          "commitsBetweenForRepo": 2921,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,54 +1,55 @@\n-  private V doChooseVolume(final List\u003cV\u003e volumes,\n-                         long replicaSize) throws IOException {\n+  private V doChooseVolume(final List\u003cV\u003e volumes, long replicaSize,\n+      String storageId) throws IOException {\n     AvailableSpaceVolumeList volumesWithSpaces \u003d\n         new AvailableSpaceVolumeList(volumes);\n     \n     if (volumesWithSpaces.areAllVolumesWithinFreeSpaceThreshold()) {\n       // If they\u0027re actually not too far out of whack, fall back on pure round\n       // robin.\n-      V volume \u003d roundRobinPolicyBalanced.chooseVolume(volumes, replicaSize);\n+      V volume \u003d roundRobinPolicyBalanced.chooseVolume(volumes, replicaSize,\n+          storageId);\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"All volumes are within the configured free space balance \" +\n             \"threshold. Selecting \" + volume + \" for write of block size \" +\n             replicaSize);\n       }\n       return volume;\n     } else {\n       V volume \u003d null;\n       // If none of the volumes with low free space have enough space for the\n       // replica, always try to choose a volume with a lot of free space.\n       long mostAvailableAmongLowVolumes \u003d volumesWithSpaces\n           .getMostAvailableSpaceAmongVolumesWithLowAvailableSpace();\n       \n       List\u003cV\u003e highAvailableVolumes \u003d extractVolumesFromPairs(\n           volumesWithSpaces.getVolumesWithHighAvailableSpace());\n       List\u003cV\u003e lowAvailableVolumes \u003d extractVolumesFromPairs(\n           volumesWithSpaces.getVolumesWithLowAvailableSpace());\n       \n       float preferencePercentScaler \u003d\n           (highAvailableVolumes.size() * balancedPreferencePercent) +\n           (lowAvailableVolumes.size() * (1 - balancedPreferencePercent));\n       float scaledPreferencePercent \u003d\n           (highAvailableVolumes.size() * balancedPreferencePercent) /\n           preferencePercentScaler;\n       if (mostAvailableAmongLowVolumes \u003c replicaSize ||\n           random.nextFloat() \u003c scaledPreferencePercent) {\n         volume \u003d roundRobinPolicyHighAvailable.chooseVolume(\n-            highAvailableVolumes, replicaSize);\n+            highAvailableVolumes, replicaSize, storageId);\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Volumes are imbalanced. Selecting \" + volume +\n               \" from high available space volumes for write of block size \"\n               + replicaSize);\n         }\n       } else {\n         volume \u003d roundRobinPolicyLowAvailable.chooseVolume(\n-            lowAvailableVolumes, replicaSize);\n+            lowAvailableVolumes, replicaSize, storageId);\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Volumes are imbalanced. Selecting \" + volume +\n               \" from low available space volumes for write of block size \"\n               + replicaSize);\n         }\n       }\n       return volume;\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private V doChooseVolume(final List\u003cV\u003e volumes, long replicaSize,\n      String storageId) throws IOException {\n    AvailableSpaceVolumeList volumesWithSpaces \u003d\n        new AvailableSpaceVolumeList(volumes);\n    \n    if (volumesWithSpaces.areAllVolumesWithinFreeSpaceThreshold()) {\n      // If they\u0027re actually not too far out of whack, fall back on pure round\n      // robin.\n      V volume \u003d roundRobinPolicyBalanced.chooseVolume(volumes, replicaSize,\n          storageId);\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"All volumes are within the configured free space balance \" +\n            \"threshold. Selecting \" + volume + \" for write of block size \" +\n            replicaSize);\n      }\n      return volume;\n    } else {\n      V volume \u003d null;\n      // If none of the volumes with low free space have enough space for the\n      // replica, always try to choose a volume with a lot of free space.\n      long mostAvailableAmongLowVolumes \u003d volumesWithSpaces\n          .getMostAvailableSpaceAmongVolumesWithLowAvailableSpace();\n      \n      List\u003cV\u003e highAvailableVolumes \u003d extractVolumesFromPairs(\n          volumesWithSpaces.getVolumesWithHighAvailableSpace());\n      List\u003cV\u003e lowAvailableVolumes \u003d extractVolumesFromPairs(\n          volumesWithSpaces.getVolumesWithLowAvailableSpace());\n      \n      float preferencePercentScaler \u003d\n          (highAvailableVolumes.size() * balancedPreferencePercent) +\n          (lowAvailableVolumes.size() * (1 - balancedPreferencePercent));\n      float scaledPreferencePercent \u003d\n          (highAvailableVolumes.size() * balancedPreferencePercent) /\n          preferencePercentScaler;\n      if (mostAvailableAmongLowVolumes \u003c replicaSize ||\n          random.nextFloat() \u003c scaledPreferencePercent) {\n        volume \u003d roundRobinPolicyHighAvailable.chooseVolume(\n            highAvailableVolumes, replicaSize, storageId);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Volumes are imbalanced. Selecting \" + volume +\n              \" from high available space volumes for write of block size \"\n              + replicaSize);\n        }\n      } else {\n        volume \u003d roundRobinPolicyLowAvailable.chooseVolume(\n            lowAvailableVolumes, replicaSize, storageId);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Volumes are imbalanced. Selecting \" + volume +\n              \" from low available space volumes for write of block size \"\n              + replicaSize);\n        }\n      }\n      return volume;\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/AvailableSpaceVolumeChoosingPolicy.java",
          "extendedDetails": {
            "oldValue": "[volumes-List\u003cV\u003e(modifiers-final), replicaSize-long]",
            "newValue": "[volumes-List\u003cV\u003e(modifiers-final), replicaSize-long, storageId-String]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-9807. Add an optional StorageID to writes. Contributed by Ewan Higgs\n",
          "commitDate": "05/05/17 12:01 PM",
          "commitName": "a3954ccab148bddc290cb96528e63ff19799bcc9",
          "commitAuthor": "Chris Douglas",
          "commitDateOld": "17/02/16 11:29 AM",
          "commitNameOld": "3a23dc683c058d3a5262ae9dca2d1c8c588a6a3e",
          "commitAuthorOld": "Andrew Wang",
          "daysBetweenCommits": 442.98,
          "commitsBetweenForRepo": 2921,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,54 +1,55 @@\n-  private V doChooseVolume(final List\u003cV\u003e volumes,\n-                         long replicaSize) throws IOException {\n+  private V doChooseVolume(final List\u003cV\u003e volumes, long replicaSize,\n+      String storageId) throws IOException {\n     AvailableSpaceVolumeList volumesWithSpaces \u003d\n         new AvailableSpaceVolumeList(volumes);\n     \n     if (volumesWithSpaces.areAllVolumesWithinFreeSpaceThreshold()) {\n       // If they\u0027re actually not too far out of whack, fall back on pure round\n       // robin.\n-      V volume \u003d roundRobinPolicyBalanced.chooseVolume(volumes, replicaSize);\n+      V volume \u003d roundRobinPolicyBalanced.chooseVolume(volumes, replicaSize,\n+          storageId);\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"All volumes are within the configured free space balance \" +\n             \"threshold. Selecting \" + volume + \" for write of block size \" +\n             replicaSize);\n       }\n       return volume;\n     } else {\n       V volume \u003d null;\n       // If none of the volumes with low free space have enough space for the\n       // replica, always try to choose a volume with a lot of free space.\n       long mostAvailableAmongLowVolumes \u003d volumesWithSpaces\n           .getMostAvailableSpaceAmongVolumesWithLowAvailableSpace();\n       \n       List\u003cV\u003e highAvailableVolumes \u003d extractVolumesFromPairs(\n           volumesWithSpaces.getVolumesWithHighAvailableSpace());\n       List\u003cV\u003e lowAvailableVolumes \u003d extractVolumesFromPairs(\n           volumesWithSpaces.getVolumesWithLowAvailableSpace());\n       \n       float preferencePercentScaler \u003d\n           (highAvailableVolumes.size() * balancedPreferencePercent) +\n           (lowAvailableVolumes.size() * (1 - balancedPreferencePercent));\n       float scaledPreferencePercent \u003d\n           (highAvailableVolumes.size() * balancedPreferencePercent) /\n           preferencePercentScaler;\n       if (mostAvailableAmongLowVolumes \u003c replicaSize ||\n           random.nextFloat() \u003c scaledPreferencePercent) {\n         volume \u003d roundRobinPolicyHighAvailable.chooseVolume(\n-            highAvailableVolumes, replicaSize);\n+            highAvailableVolumes, replicaSize, storageId);\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Volumes are imbalanced. Selecting \" + volume +\n               \" from high available space volumes for write of block size \"\n               + replicaSize);\n         }\n       } else {\n         volume \u003d roundRobinPolicyLowAvailable.chooseVolume(\n-            lowAvailableVolumes, replicaSize);\n+            lowAvailableVolumes, replicaSize, storageId);\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Volumes are imbalanced. Selecting \" + volume +\n               \" from low available space volumes for write of block size \"\n               + replicaSize);\n         }\n       }\n       return volume;\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private V doChooseVolume(final List\u003cV\u003e volumes, long replicaSize,\n      String storageId) throws IOException {\n    AvailableSpaceVolumeList volumesWithSpaces \u003d\n        new AvailableSpaceVolumeList(volumes);\n    \n    if (volumesWithSpaces.areAllVolumesWithinFreeSpaceThreshold()) {\n      // If they\u0027re actually not too far out of whack, fall back on pure round\n      // robin.\n      V volume \u003d roundRobinPolicyBalanced.chooseVolume(volumes, replicaSize,\n          storageId);\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"All volumes are within the configured free space balance \" +\n            \"threshold. Selecting \" + volume + \" for write of block size \" +\n            replicaSize);\n      }\n      return volume;\n    } else {\n      V volume \u003d null;\n      // If none of the volumes with low free space have enough space for the\n      // replica, always try to choose a volume with a lot of free space.\n      long mostAvailableAmongLowVolumes \u003d volumesWithSpaces\n          .getMostAvailableSpaceAmongVolumesWithLowAvailableSpace();\n      \n      List\u003cV\u003e highAvailableVolumes \u003d extractVolumesFromPairs(\n          volumesWithSpaces.getVolumesWithHighAvailableSpace());\n      List\u003cV\u003e lowAvailableVolumes \u003d extractVolumesFromPairs(\n          volumesWithSpaces.getVolumesWithLowAvailableSpace());\n      \n      float preferencePercentScaler \u003d\n          (highAvailableVolumes.size() * balancedPreferencePercent) +\n          (lowAvailableVolumes.size() * (1 - balancedPreferencePercent));\n      float scaledPreferencePercent \u003d\n          (highAvailableVolumes.size() * balancedPreferencePercent) /\n          preferencePercentScaler;\n      if (mostAvailableAmongLowVolumes \u003c replicaSize ||\n          random.nextFloat() \u003c scaledPreferencePercent) {\n        volume \u003d roundRobinPolicyHighAvailable.chooseVolume(\n            highAvailableVolumes, replicaSize, storageId);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Volumes are imbalanced. Selecting \" + volume +\n              \" from high available space volumes for write of block size \"\n              + replicaSize);\n        }\n      } else {\n        volume \u003d roundRobinPolicyLowAvailable.chooseVolume(\n            lowAvailableVolumes, replicaSize, storageId);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Volumes are imbalanced. Selecting \" + volume +\n              \" from low available space volumes for write of block size \"\n              + replicaSize);\n        }\n      }\n      return volume;\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/AvailableSpaceVolumeChoosingPolicy.java",
          "extendedDetails": {}
        }
      ]
    },
    "3a23dc683c058d3a5262ae9dca2d1c8c588a6a3e": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-9608. Disk IO imbalance in HDFS with heterogeneous storages. Contributed by Wei Zhou.\n",
      "commitDate": "17/02/16 11:29 AM",
      "commitName": "3a23dc683c058d3a5262ae9dca2d1c8c588a6a3e",
      "commitAuthor": "Andrew Wang",
      "diff": "@@ -0,0 +1,54 @@\n+  private V doChooseVolume(final List\u003cV\u003e volumes,\n+                         long replicaSize) throws IOException {\n+    AvailableSpaceVolumeList volumesWithSpaces \u003d\n+        new AvailableSpaceVolumeList(volumes);\n+    \n+    if (volumesWithSpaces.areAllVolumesWithinFreeSpaceThreshold()) {\n+      // If they\u0027re actually not too far out of whack, fall back on pure round\n+      // robin.\n+      V volume \u003d roundRobinPolicyBalanced.chooseVolume(volumes, replicaSize);\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"All volumes are within the configured free space balance \" +\n+            \"threshold. Selecting \" + volume + \" for write of block size \" +\n+            replicaSize);\n+      }\n+      return volume;\n+    } else {\n+      V volume \u003d null;\n+      // If none of the volumes with low free space have enough space for the\n+      // replica, always try to choose a volume with a lot of free space.\n+      long mostAvailableAmongLowVolumes \u003d volumesWithSpaces\n+          .getMostAvailableSpaceAmongVolumesWithLowAvailableSpace();\n+      \n+      List\u003cV\u003e highAvailableVolumes \u003d extractVolumesFromPairs(\n+          volumesWithSpaces.getVolumesWithHighAvailableSpace());\n+      List\u003cV\u003e lowAvailableVolumes \u003d extractVolumesFromPairs(\n+          volumesWithSpaces.getVolumesWithLowAvailableSpace());\n+      \n+      float preferencePercentScaler \u003d\n+          (highAvailableVolumes.size() * balancedPreferencePercent) +\n+          (lowAvailableVolumes.size() * (1 - balancedPreferencePercent));\n+      float scaledPreferencePercent \u003d\n+          (highAvailableVolumes.size() * balancedPreferencePercent) /\n+          preferencePercentScaler;\n+      if (mostAvailableAmongLowVolumes \u003c replicaSize ||\n+          random.nextFloat() \u003c scaledPreferencePercent) {\n+        volume \u003d roundRobinPolicyHighAvailable.chooseVolume(\n+            highAvailableVolumes, replicaSize);\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"Volumes are imbalanced. Selecting \" + volume +\n+              \" from high available space volumes for write of block size \"\n+              + replicaSize);\n+        }\n+      } else {\n+        volume \u003d roundRobinPolicyLowAvailable.chooseVolume(\n+            lowAvailableVolumes, replicaSize);\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"Volumes are imbalanced. Selecting \" + volume +\n+              \" from low available space volumes for write of block size \"\n+              + replicaSize);\n+        }\n+      }\n+      return volume;\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private V doChooseVolume(final List\u003cV\u003e volumes,\n                         long replicaSize) throws IOException {\n    AvailableSpaceVolumeList volumesWithSpaces \u003d\n        new AvailableSpaceVolumeList(volumes);\n    \n    if (volumesWithSpaces.areAllVolumesWithinFreeSpaceThreshold()) {\n      // If they\u0027re actually not too far out of whack, fall back on pure round\n      // robin.\n      V volume \u003d roundRobinPolicyBalanced.chooseVolume(volumes, replicaSize);\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"All volumes are within the configured free space balance \" +\n            \"threshold. Selecting \" + volume + \" for write of block size \" +\n            replicaSize);\n      }\n      return volume;\n    } else {\n      V volume \u003d null;\n      // If none of the volumes with low free space have enough space for the\n      // replica, always try to choose a volume with a lot of free space.\n      long mostAvailableAmongLowVolumes \u003d volumesWithSpaces\n          .getMostAvailableSpaceAmongVolumesWithLowAvailableSpace();\n      \n      List\u003cV\u003e highAvailableVolumes \u003d extractVolumesFromPairs(\n          volumesWithSpaces.getVolumesWithHighAvailableSpace());\n      List\u003cV\u003e lowAvailableVolumes \u003d extractVolumesFromPairs(\n          volumesWithSpaces.getVolumesWithLowAvailableSpace());\n      \n      float preferencePercentScaler \u003d\n          (highAvailableVolumes.size() * balancedPreferencePercent) +\n          (lowAvailableVolumes.size() * (1 - balancedPreferencePercent));\n      float scaledPreferencePercent \u003d\n          (highAvailableVolumes.size() * balancedPreferencePercent) /\n          preferencePercentScaler;\n      if (mostAvailableAmongLowVolumes \u003c replicaSize ||\n          random.nextFloat() \u003c scaledPreferencePercent) {\n        volume \u003d roundRobinPolicyHighAvailable.chooseVolume(\n            highAvailableVolumes, replicaSize);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Volumes are imbalanced. Selecting \" + volume +\n              \" from high available space volumes for write of block size \"\n              + replicaSize);\n        }\n      } else {\n        volume \u003d roundRobinPolicyLowAvailable.chooseVolume(\n            lowAvailableVolumes, replicaSize);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Volumes are imbalanced. Selecting \" + volume +\n              \" from low available space volumes for write of block size \"\n              + replicaSize);\n        }\n      }\n      return volume;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/AvailableSpaceVolumeChoosingPolicy.java"
    }
  }
}