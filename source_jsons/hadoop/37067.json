{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "InMemoryPlan.java",
  "functionName": "getReservations",
  "functionId": "getReservations___reservationID-ReservationId__interval-ReservationInterval__user-String",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/InMemoryPlan.java",
  "functionStartLine": 601,
  "functionEndLine": 678,
  "numCommitsSeen": 19,
  "timeTaken": 3481,
  "changeHistory": [
    "25932da6d1ee56299c8f9911576a42792c435407",
    "b6e7d1369690eaf50ce9ea7968f91a72ecb74de0",
    "e3345e985bff93c6c74a76747e45376c6027f42c",
    "7996eca7dcfaa1bdf970e32022274f2699bef8a1",
    "9875325d5c63f343809907d06bf48a298035a611"
  ],
  "changeHistoryShort": {
    "25932da6d1ee56299c8f9911576a42792c435407": "Ybodychange",
    "b6e7d1369690eaf50ce9ea7968f91a72ecb74de0": "Ybodychange",
    "e3345e985bff93c6c74a76747e45376c6027f42c": "Ybodychange",
    "7996eca7dcfaa1bdf970e32022274f2699bef8a1": "Ybodychange",
    "9875325d5c63f343809907d06bf48a298035a611": "Yintroduced"
  },
  "changeHistoryDetails": {
    "25932da6d1ee56299c8f9911576a42792c435407": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5516. Add REST API for supporting recurring reservations. (Sean Po via Subru).\n",
      "commitDate": "26/10/17 12:10 PM",
      "commitName": "25932da6d1ee56299c8f9911576a42792c435407",
      "commitAuthor": "Subru Krishnan",
      "commitDateOld": "04/10/17 7:28 PM",
      "commitNameOld": "e6e614e380ed1d746973b50f666a9c40d272073e",
      "commitAuthorOld": "Subru Krishnan",
      "daysBetweenCommits": 21.7,
      "commitsBetweenForRepo": 163,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,78 @@\n   public Set\u003cReservationAllocation\u003e getReservations(ReservationId reservationID,\n       ReservationInterval interval, String user) {\n     if (reservationID !\u003d null) {\n       ReservationAllocation allocation \u003d getReservationById(reservationID);\n       if (allocation \u003d\u003d null) {\n         return Collections.emptySet();\n       }\n       return Collections.singleton(allocation);\n     }\n \n     long startTime \u003d interval \u003d\u003d null ? 0 : interval.getStartTime();\n     long endTime \u003d interval \u003d\u003d null ? Long.MAX_VALUE : interval.getEndTime();\n \n     ReservationInterval searchInterval \u003d\n         new ReservationInterval(endTime, Long.MAX_VALUE);\n     readLock.lock();\n     try {\n       SortedMap\u003cReservationInterval, Set\u003cInMemoryReservationAllocation\u003e\u003e res \u003d\n           currentReservations.headMap(searchInterval, true);\n       if (!res.isEmpty()) {\n         Set\u003cReservationAllocation\u003e flattenedReservations \u003d new HashSet\u003c\u003e();\n         for (Set\u003cInMemoryReservationAllocation\u003e resEntries : res.values()) {\n           for (InMemoryReservationAllocation reservation : resEntries) {\n             // validate user\n             if (user !\u003d null \u0026\u0026 !user.isEmpty()\n                 \u0026\u0026 !reservation.getUser().equals(user)) {\n               continue;\n             }\n             // handle periodic reservations\n             long period \u003d reservation.getPeriodicity();\n             if (period \u003e 0) {\n-              long t \u003d endTime % period;\n-              // check for both contained and wrap-around reservations\n-              if ((t - startTime) * (t - endTime)\n-                  * (startTime - endTime) \u003e\u003d 0) {\n+              // The shift is used to remove the wrap around for the\n+              // reservation interval. The wrap around will still\n+              // exist for the search interval.\n+              long shift \u003d reservation.getStartTime() % period;\n+              // This is the duration of the reservation since\n+              // duration \u003c period.\n+              long periodicReservationEnd \u003d\n+                  (reservation.getEndTime() -shift) % period;\n+              long periodicSearchStart \u003d (startTime - shift) % period;\n+              long periodicSearchEnd \u003d (endTime - shift) % period;\n+              long searchDuration \u003d endTime - startTime;\n+\n+              // 1. If the searchDuration is greater than the period, then\n+              // the reservation is within the interval. This will allow\n+              // us to ignore cases where search end \u003e search start \u003e\n+              // reservation end.\n+              // 2/3. If the search end is less than the reservation end, or if\n+              // the search start is less than the reservation end, then the\n+              // reservation will be in the reservation since\n+              // periodic reservation start is always zero. Note that neither\n+              // of those values will ever be negative.\n+              // 4. If the search end is less than the search start, then\n+              // there is a wrap around, and both values are implicitly\n+              // greater than the reservation end because of condition 2/3,\n+              // so the reservation is within the search interval.\n+              if (searchDuration \u003e period\n+                  || periodicSearchEnd \u003c periodicReservationEnd\n+                  || periodicSearchStart \u003c periodicReservationEnd\n+                  || periodicSearchStart \u003e periodicSearchEnd) {\n                 flattenedReservations.add(reservation);\n               }\n             } else {\n               // check for non-periodic reservations\n               if (reservation.getEndTime() \u003e startTime) {\n                 flattenedReservations.add(reservation);\n               }\n             }\n           }\n         }\n         return Collections.unmodifiableSet(flattenedReservations);\n       } else {\n         return Collections.emptySet();\n       }\n     } finally {\n       readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Set\u003cReservationAllocation\u003e getReservations(ReservationId reservationID,\n      ReservationInterval interval, String user) {\n    if (reservationID !\u003d null) {\n      ReservationAllocation allocation \u003d getReservationById(reservationID);\n      if (allocation \u003d\u003d null) {\n        return Collections.emptySet();\n      }\n      return Collections.singleton(allocation);\n    }\n\n    long startTime \u003d interval \u003d\u003d null ? 0 : interval.getStartTime();\n    long endTime \u003d interval \u003d\u003d null ? Long.MAX_VALUE : interval.getEndTime();\n\n    ReservationInterval searchInterval \u003d\n        new ReservationInterval(endTime, Long.MAX_VALUE);\n    readLock.lock();\n    try {\n      SortedMap\u003cReservationInterval, Set\u003cInMemoryReservationAllocation\u003e\u003e res \u003d\n          currentReservations.headMap(searchInterval, true);\n      if (!res.isEmpty()) {\n        Set\u003cReservationAllocation\u003e flattenedReservations \u003d new HashSet\u003c\u003e();\n        for (Set\u003cInMemoryReservationAllocation\u003e resEntries : res.values()) {\n          for (InMemoryReservationAllocation reservation : resEntries) {\n            // validate user\n            if (user !\u003d null \u0026\u0026 !user.isEmpty()\n                \u0026\u0026 !reservation.getUser().equals(user)) {\n              continue;\n            }\n            // handle periodic reservations\n            long period \u003d reservation.getPeriodicity();\n            if (period \u003e 0) {\n              // The shift is used to remove the wrap around for the\n              // reservation interval. The wrap around will still\n              // exist for the search interval.\n              long shift \u003d reservation.getStartTime() % period;\n              // This is the duration of the reservation since\n              // duration \u003c period.\n              long periodicReservationEnd \u003d\n                  (reservation.getEndTime() -shift) % period;\n              long periodicSearchStart \u003d (startTime - shift) % period;\n              long periodicSearchEnd \u003d (endTime - shift) % period;\n              long searchDuration \u003d endTime - startTime;\n\n              // 1. If the searchDuration is greater than the period, then\n              // the reservation is within the interval. This will allow\n              // us to ignore cases where search end \u003e search start \u003e\n              // reservation end.\n              // 2/3. If the search end is less than the reservation end, or if\n              // the search start is less than the reservation end, then the\n              // reservation will be in the reservation since\n              // periodic reservation start is always zero. Note that neither\n              // of those values will ever be negative.\n              // 4. If the search end is less than the search start, then\n              // there is a wrap around, and both values are implicitly\n              // greater than the reservation end because of condition 2/3,\n              // so the reservation is within the search interval.\n              if (searchDuration \u003e period\n                  || periodicSearchEnd \u003c periodicReservationEnd\n                  || periodicSearchStart \u003c periodicReservationEnd\n                  || periodicSearchStart \u003e periodicSearchEnd) {\n                flattenedReservations.add(reservation);\n              }\n            } else {\n              // check for non-periodic reservations\n              if (reservation.getEndTime() \u003e startTime) {\n                flattenedReservations.add(reservation);\n              }\n            }\n          }\n        }\n        return Collections.unmodifiableSet(flattenedReservations);\n      } else {\n        return Collections.emptySet();\n      }\n    } finally {\n      readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/InMemoryPlan.java",
      "extendedDetails": {}
    },
    "b6e7d1369690eaf50ce9ea7968f91a72ecb74de0": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5328. Plan/ResourceAllocation data structure enhancements required to support recurring reservations in ReservationSystem.\n",
      "commitDate": "06/09/17 4:46 PM",
      "commitName": "b6e7d1369690eaf50ce9ea7968f91a72ecb74de0",
      "commitAuthor": "Subru Krishnan",
      "commitDateOld": "06/09/17 4:39 PM",
      "commitNameOld": "e3345e985bff93c6c74a76747e45376c6027f42c",
      "commitAuthorOld": "Subru Krishnan",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,53 @@\n-  public Set\u003cReservationAllocation\u003e getReservations(ReservationId\n-                    reservationID, ReservationInterval interval, String user) {\n+  public Set\u003cReservationAllocation\u003e getReservations(ReservationId reservationID,\n+      ReservationInterval interval, String user) {\n     if (reservationID !\u003d null) {\n       ReservationAllocation allocation \u003d getReservationById(reservationID);\n-      if (allocation \u003d\u003d null){\n+      if (allocation \u003d\u003d null) {\n         return Collections.emptySet();\n       }\n       return Collections.singleton(allocation);\n     }\n \n-    long startTime \u003d interval \u003d\u003d null? 0 : interval.getStartTime();\n-    long endTime \u003d interval \u003d\u003d null? Long.MAX_VALUE : interval.getEndTime();\n+    long startTime \u003d interval \u003d\u003d null ? 0 : interval.getStartTime();\n+    long endTime \u003d interval \u003d\u003d null ? Long.MAX_VALUE : interval.getEndTime();\n \n     ReservationInterval searchInterval \u003d\n-            new ReservationInterval(endTime, Long.MAX_VALUE);\n+        new ReservationInterval(endTime, Long.MAX_VALUE);\n     readLock.lock();\n     try {\n-      SortedMap\u003cReservationInterval, Set\u003cInMemoryReservationAllocation\u003e\u003e\n-            reservations \u003d currentReservations.headMap(searchInterval, true);\n-      if (!reservations.isEmpty()) {\n-        Set\u003cReservationAllocation\u003e flattenedReservations \u003d\n-                new HashSet\u003c\u003e();\n-        for (Set\u003cInMemoryReservationAllocation\u003e reservationEntries :\n-                reservations.values()) {\n-          for (InMemoryReservationAllocation res : reservationEntries) {\n-            if (res.getEndTime() \u003e startTime) {\n-              if (user !\u003d null \u0026\u0026 !user.isEmpty()\n-                      \u0026\u0026 !res.getUser().equals(user)) {\n-                continue;\n+      SortedMap\u003cReservationInterval, Set\u003cInMemoryReservationAllocation\u003e\u003e res \u003d\n+          currentReservations.headMap(searchInterval, true);\n+      if (!res.isEmpty()) {\n+        Set\u003cReservationAllocation\u003e flattenedReservations \u003d new HashSet\u003c\u003e();\n+        for (Set\u003cInMemoryReservationAllocation\u003e resEntries : res.values()) {\n+          for (InMemoryReservationAllocation reservation : resEntries) {\n+            // validate user\n+            if (user !\u003d null \u0026\u0026 !user.isEmpty()\n+                \u0026\u0026 !reservation.getUser().equals(user)) {\n+              continue;\n+            }\n+            // handle periodic reservations\n+            long period \u003d reservation.getPeriodicity();\n+            if (period \u003e 0) {\n+              long t \u003d endTime % period;\n+              // check for both contained and wrap-around reservations\n+              if ((t - startTime) * (t - endTime)\n+                  * (startTime - endTime) \u003e\u003d 0) {\n+                flattenedReservations.add(reservation);\n               }\n-              flattenedReservations.add(res);\n+            } else {\n+              // check for non-periodic reservations\n+              if (reservation.getEndTime() \u003e startTime) {\n+                flattenedReservations.add(reservation);\n+              }\n             }\n           }\n         }\n         return Collections.unmodifiableSet(flattenedReservations);\n       } else {\n         return Collections.emptySet();\n       }\n     } finally {\n       readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Set\u003cReservationAllocation\u003e getReservations(ReservationId reservationID,\n      ReservationInterval interval, String user) {\n    if (reservationID !\u003d null) {\n      ReservationAllocation allocation \u003d getReservationById(reservationID);\n      if (allocation \u003d\u003d null) {\n        return Collections.emptySet();\n      }\n      return Collections.singleton(allocation);\n    }\n\n    long startTime \u003d interval \u003d\u003d null ? 0 : interval.getStartTime();\n    long endTime \u003d interval \u003d\u003d null ? Long.MAX_VALUE : interval.getEndTime();\n\n    ReservationInterval searchInterval \u003d\n        new ReservationInterval(endTime, Long.MAX_VALUE);\n    readLock.lock();\n    try {\n      SortedMap\u003cReservationInterval, Set\u003cInMemoryReservationAllocation\u003e\u003e res \u003d\n          currentReservations.headMap(searchInterval, true);\n      if (!res.isEmpty()) {\n        Set\u003cReservationAllocation\u003e flattenedReservations \u003d new HashSet\u003c\u003e();\n        for (Set\u003cInMemoryReservationAllocation\u003e resEntries : res.values()) {\n          for (InMemoryReservationAllocation reservation : resEntries) {\n            // validate user\n            if (user !\u003d null \u0026\u0026 !user.isEmpty()\n                \u0026\u0026 !reservation.getUser().equals(user)) {\n              continue;\n            }\n            // handle periodic reservations\n            long period \u003d reservation.getPeriodicity();\n            if (period \u003e 0) {\n              long t \u003d endTime % period;\n              // check for both contained and wrap-around reservations\n              if ((t - startTime) * (t - endTime)\n                  * (startTime - endTime) \u003e\u003d 0) {\n                flattenedReservations.add(reservation);\n              }\n            } else {\n              // check for non-periodic reservations\n              if (reservation.getEndTime() \u003e startTime) {\n                flattenedReservations.add(reservation);\n              }\n            }\n          }\n        }\n        return Collections.unmodifiableSet(flattenedReservations);\n      } else {\n        return Collections.emptySet();\n      }\n    } finally {\n      readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/InMemoryPlan.java",
      "extendedDetails": {}
    },
    "e3345e985bff93c6c74a76747e45376c6027f42c": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"Plan/ResourceAllocation data structure enhancements required to support recurring reservations in ReservationSystem.\"\n\nThis reverts commit 7996eca7dcfaa1bdf970e32022274f2699bef8a1.\n",
      "commitDate": "06/09/17 4:39 PM",
      "commitName": "e3345e985bff93c6c74a76747e45376c6027f42c",
      "commitAuthor": "Subru Krishnan",
      "commitDateOld": "01/09/17 3:16 PM",
      "commitNameOld": "7996eca7dcfaa1bdf970e32022274f2699bef8a1",
      "commitAuthorOld": "Subru Krishnan",
      "daysBetweenCommits": 5.06,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,42 @@\n-  public Set\u003cReservationAllocation\u003e getReservations(ReservationId reservationID,\n-      ReservationInterval interval, String user) {\n+  public Set\u003cReservationAllocation\u003e getReservations(ReservationId\n+                    reservationID, ReservationInterval interval, String user) {\n     if (reservationID !\u003d null) {\n       ReservationAllocation allocation \u003d getReservationById(reservationID);\n-      if (allocation \u003d\u003d null) {\n+      if (allocation \u003d\u003d null){\n         return Collections.emptySet();\n       }\n       return Collections.singleton(allocation);\n     }\n \n-    long startTime \u003d interval \u003d\u003d null ? 0 : interval.getStartTime();\n-    long endTime \u003d interval \u003d\u003d null ? Long.MAX_VALUE : interval.getEndTime();\n+    long startTime \u003d interval \u003d\u003d null? 0 : interval.getStartTime();\n+    long endTime \u003d interval \u003d\u003d null? Long.MAX_VALUE : interval.getEndTime();\n \n     ReservationInterval searchInterval \u003d\n-        new ReservationInterval(endTime, Long.MAX_VALUE);\n+            new ReservationInterval(endTime, Long.MAX_VALUE);\n     readLock.lock();\n     try {\n-      SortedMap\u003cReservationInterval, Set\u003cInMemoryReservationAllocation\u003e\u003e res \u003d\n-          currentReservations.headMap(searchInterval, true);\n-      if (!res.isEmpty()) {\n-        Set\u003cReservationAllocation\u003e flattenedReservations \u003d new HashSet\u003c\u003e();\n-        for (Set\u003cInMemoryReservationAllocation\u003e resEntries : res.values()) {\n-          for (InMemoryReservationAllocation reservation : resEntries) {\n-            // validate user\n-            if (user !\u003d null \u0026\u0026 !user.isEmpty()\n-                \u0026\u0026 !reservation.getUser().equals(user)) {\n-              continue;\n-            }\n-            // handle periodic reservations\n-            long period \u003d reservation.getPeriodicity();\n-            if (period \u003e 0) {\n-              long t \u003d endTime % period;\n-              // check for both contained and wrap-around reservations\n-              if ((t - startTime) * (t - endTime)\n-                  * (startTime - endTime) \u003e\u003d 0) {\n-                flattenedReservations.add(reservation);\n+      SortedMap\u003cReservationInterval, Set\u003cInMemoryReservationAllocation\u003e\u003e\n+            reservations \u003d currentReservations.headMap(searchInterval, true);\n+      if (!reservations.isEmpty()) {\n+        Set\u003cReservationAllocation\u003e flattenedReservations \u003d\n+                new HashSet\u003c\u003e();\n+        for (Set\u003cInMemoryReservationAllocation\u003e reservationEntries :\n+                reservations.values()) {\n+          for (InMemoryReservationAllocation res : reservationEntries) {\n+            if (res.getEndTime() \u003e startTime) {\n+              if (user !\u003d null \u0026\u0026 !user.isEmpty()\n+                      \u0026\u0026 !res.getUser().equals(user)) {\n+                continue;\n               }\n-            } else {\n-              // check for non-periodic reservations\n-              if (reservation.getEndTime() \u003e startTime) {\n-                flattenedReservations.add(reservation);\n-              }\n+              flattenedReservations.add(res);\n             }\n           }\n         }\n         return Collections.unmodifiableSet(flattenedReservations);\n       } else {\n         return Collections.emptySet();\n       }\n     } finally {\n       readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Set\u003cReservationAllocation\u003e getReservations(ReservationId\n                    reservationID, ReservationInterval interval, String user) {\n    if (reservationID !\u003d null) {\n      ReservationAllocation allocation \u003d getReservationById(reservationID);\n      if (allocation \u003d\u003d null){\n        return Collections.emptySet();\n      }\n      return Collections.singleton(allocation);\n    }\n\n    long startTime \u003d interval \u003d\u003d null? 0 : interval.getStartTime();\n    long endTime \u003d interval \u003d\u003d null? Long.MAX_VALUE : interval.getEndTime();\n\n    ReservationInterval searchInterval \u003d\n            new ReservationInterval(endTime, Long.MAX_VALUE);\n    readLock.lock();\n    try {\n      SortedMap\u003cReservationInterval, Set\u003cInMemoryReservationAllocation\u003e\u003e\n            reservations \u003d currentReservations.headMap(searchInterval, true);\n      if (!reservations.isEmpty()) {\n        Set\u003cReservationAllocation\u003e flattenedReservations \u003d\n                new HashSet\u003c\u003e();\n        for (Set\u003cInMemoryReservationAllocation\u003e reservationEntries :\n                reservations.values()) {\n          for (InMemoryReservationAllocation res : reservationEntries) {\n            if (res.getEndTime() \u003e startTime) {\n              if (user !\u003d null \u0026\u0026 !user.isEmpty()\n                      \u0026\u0026 !res.getUser().equals(user)) {\n                continue;\n              }\n              flattenedReservations.add(res);\n            }\n          }\n        }\n        return Collections.unmodifiableSet(flattenedReservations);\n      } else {\n        return Collections.emptySet();\n      }\n    } finally {\n      readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/InMemoryPlan.java",
      "extendedDetails": {}
    },
    "7996eca7dcfaa1bdf970e32022274f2699bef8a1": {
      "type": "Ybodychange",
      "commitMessage": "Plan/ResourceAllocation data structure enhancements required to support recurring reservations in ReservationSystem.\n",
      "commitDate": "01/09/17 3:16 PM",
      "commitName": "7996eca7dcfaa1bdf970e32022274f2699bef8a1",
      "commitAuthor": "Subru Krishnan",
      "commitDateOld": "01/05/17 4:01 PM",
      "commitNameOld": "a3a615eeab8c14ccdc548311097e62a916963dc5",
      "commitAuthorOld": "Subru Krishnan",
      "daysBetweenCommits": 122.97,
      "commitsBetweenForRepo": 775,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,53 @@\n-  public Set\u003cReservationAllocation\u003e getReservations(ReservationId\n-                    reservationID, ReservationInterval interval, String user) {\n+  public Set\u003cReservationAllocation\u003e getReservations(ReservationId reservationID,\n+      ReservationInterval interval, String user) {\n     if (reservationID !\u003d null) {\n       ReservationAllocation allocation \u003d getReservationById(reservationID);\n-      if (allocation \u003d\u003d null){\n+      if (allocation \u003d\u003d null) {\n         return Collections.emptySet();\n       }\n       return Collections.singleton(allocation);\n     }\n \n-    long startTime \u003d interval \u003d\u003d null? 0 : interval.getStartTime();\n-    long endTime \u003d interval \u003d\u003d null? Long.MAX_VALUE : interval.getEndTime();\n+    long startTime \u003d interval \u003d\u003d null ? 0 : interval.getStartTime();\n+    long endTime \u003d interval \u003d\u003d null ? Long.MAX_VALUE : interval.getEndTime();\n \n     ReservationInterval searchInterval \u003d\n-            new ReservationInterval(endTime, Long.MAX_VALUE);\n+        new ReservationInterval(endTime, Long.MAX_VALUE);\n     readLock.lock();\n     try {\n-      SortedMap\u003cReservationInterval, Set\u003cInMemoryReservationAllocation\u003e\u003e\n-            reservations \u003d currentReservations.headMap(searchInterval, true);\n-      if (!reservations.isEmpty()) {\n-        Set\u003cReservationAllocation\u003e flattenedReservations \u003d\n-                new HashSet\u003c\u003e();\n-        for (Set\u003cInMemoryReservationAllocation\u003e reservationEntries :\n-                reservations.values()) {\n-          for (InMemoryReservationAllocation res : reservationEntries) {\n-            if (res.getEndTime() \u003e startTime) {\n-              if (user !\u003d null \u0026\u0026 !user.isEmpty()\n-                      \u0026\u0026 !res.getUser().equals(user)) {\n-                continue;\n+      SortedMap\u003cReservationInterval, Set\u003cInMemoryReservationAllocation\u003e\u003e res \u003d\n+          currentReservations.headMap(searchInterval, true);\n+      if (!res.isEmpty()) {\n+        Set\u003cReservationAllocation\u003e flattenedReservations \u003d new HashSet\u003c\u003e();\n+        for (Set\u003cInMemoryReservationAllocation\u003e resEntries : res.values()) {\n+          for (InMemoryReservationAllocation reservation : resEntries) {\n+            // validate user\n+            if (user !\u003d null \u0026\u0026 !user.isEmpty()\n+                \u0026\u0026 !reservation.getUser().equals(user)) {\n+              continue;\n+            }\n+            // handle periodic reservations\n+            long period \u003d reservation.getPeriodicity();\n+            if (period \u003e 0) {\n+              long t \u003d endTime % period;\n+              // check for both contained and wrap-around reservations\n+              if ((t - startTime) * (t - endTime)\n+                  * (startTime - endTime) \u003e\u003d 0) {\n+                flattenedReservations.add(reservation);\n               }\n-              flattenedReservations.add(res);\n+            } else {\n+              // check for non-periodic reservations\n+              if (reservation.getEndTime() \u003e startTime) {\n+                flattenedReservations.add(reservation);\n+              }\n             }\n           }\n         }\n         return Collections.unmodifiableSet(flattenedReservations);\n       } else {\n         return Collections.emptySet();\n       }\n     } finally {\n       readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Set\u003cReservationAllocation\u003e getReservations(ReservationId reservationID,\n      ReservationInterval interval, String user) {\n    if (reservationID !\u003d null) {\n      ReservationAllocation allocation \u003d getReservationById(reservationID);\n      if (allocation \u003d\u003d null) {\n        return Collections.emptySet();\n      }\n      return Collections.singleton(allocation);\n    }\n\n    long startTime \u003d interval \u003d\u003d null ? 0 : interval.getStartTime();\n    long endTime \u003d interval \u003d\u003d null ? Long.MAX_VALUE : interval.getEndTime();\n\n    ReservationInterval searchInterval \u003d\n        new ReservationInterval(endTime, Long.MAX_VALUE);\n    readLock.lock();\n    try {\n      SortedMap\u003cReservationInterval, Set\u003cInMemoryReservationAllocation\u003e\u003e res \u003d\n          currentReservations.headMap(searchInterval, true);\n      if (!res.isEmpty()) {\n        Set\u003cReservationAllocation\u003e flattenedReservations \u003d new HashSet\u003c\u003e();\n        for (Set\u003cInMemoryReservationAllocation\u003e resEntries : res.values()) {\n          for (InMemoryReservationAllocation reservation : resEntries) {\n            // validate user\n            if (user !\u003d null \u0026\u0026 !user.isEmpty()\n                \u0026\u0026 !reservation.getUser().equals(user)) {\n              continue;\n            }\n            // handle periodic reservations\n            long period \u003d reservation.getPeriodicity();\n            if (period \u003e 0) {\n              long t \u003d endTime % period;\n              // check for both contained and wrap-around reservations\n              if ((t - startTime) * (t - endTime)\n                  * (startTime - endTime) \u003e\u003d 0) {\n                flattenedReservations.add(reservation);\n              }\n            } else {\n              // check for non-periodic reservations\n              if (reservation.getEndTime() \u003e startTime) {\n                flattenedReservations.add(reservation);\n              }\n            }\n          }\n        }\n        return Collections.unmodifiableSet(flattenedReservations);\n      } else {\n        return Collections.emptySet();\n      }\n    } finally {\n      readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/InMemoryPlan.java",
      "extendedDetails": {}
    },
    "9875325d5c63f343809907d06bf48a298035a611": {
      "type": "Yintroduced",
      "commitMessage": "YARN-4340. Add list API to reservation system. (Sean Po via wangda)\n",
      "commitDate": "01/02/16 6:17 PM",
      "commitName": "9875325d5c63f343809907d06bf48a298035a611",
      "commitAuthor": "Wangda Tan",
      "diff": "@@ -0,0 +1,42 @@\n+    public Set\u003cReservationAllocation\u003e getReservations(ReservationId\n+                    reservationID, ReservationInterval interval, String user) {\n+    if (reservationID !\u003d null) {\n+      ReservationAllocation allocation \u003d getReservationById(reservationID);\n+      if (allocation \u003d\u003d null){\n+        return Collections.emptySet();\n+      }\n+      return Collections.singleton(allocation);\n+    }\n+\n+    long startTime \u003d interval \u003d\u003d null? 0 : interval.getStartTime();\n+    long endTime \u003d interval \u003d\u003d null? Long.MAX_VALUE : interval.getEndTime();\n+\n+    ReservationInterval searchInterval \u003d\n+            new ReservationInterval(endTime, Long.MAX_VALUE);\n+    readLock.lock();\n+    try {\n+      SortedMap\u003cReservationInterval, Set\u003cInMemoryReservationAllocation\u003e\u003e\n+            reservations \u003d currentReservations.headMap(searchInterval, true);\n+      if (!reservations.isEmpty()) {\n+        Set\u003cReservationAllocation\u003e flattenedReservations \u003d\n+                new HashSet\u003c\u003e();\n+        for (Set\u003cInMemoryReservationAllocation\u003e reservationEntries :\n+                reservations.values()) {\n+          for (InMemoryReservationAllocation res : reservationEntries) {\n+            if (res.getEndTime() \u003e startTime) {\n+              if (user !\u003d null \u0026\u0026 !user.isEmpty()\n+                      \u0026\u0026 !res.getUser().equals(user)) {\n+                continue;\n+              }\n+              flattenedReservations.add(res);\n+            }\n+          }\n+        }\n+        return Collections.unmodifiableSet(flattenedReservations);\n+      } else {\n+        return Collections.emptySet();\n+      }\n+    } finally {\n+      readLock.unlock();\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "    public Set\u003cReservationAllocation\u003e getReservations(ReservationId\n                    reservationID, ReservationInterval interval, String user) {\n    if (reservationID !\u003d null) {\n      ReservationAllocation allocation \u003d getReservationById(reservationID);\n      if (allocation \u003d\u003d null){\n        return Collections.emptySet();\n      }\n      return Collections.singleton(allocation);\n    }\n\n    long startTime \u003d interval \u003d\u003d null? 0 : interval.getStartTime();\n    long endTime \u003d interval \u003d\u003d null? Long.MAX_VALUE : interval.getEndTime();\n\n    ReservationInterval searchInterval \u003d\n            new ReservationInterval(endTime, Long.MAX_VALUE);\n    readLock.lock();\n    try {\n      SortedMap\u003cReservationInterval, Set\u003cInMemoryReservationAllocation\u003e\u003e\n            reservations \u003d currentReservations.headMap(searchInterval, true);\n      if (!reservations.isEmpty()) {\n        Set\u003cReservationAllocation\u003e flattenedReservations \u003d\n                new HashSet\u003c\u003e();\n        for (Set\u003cInMemoryReservationAllocation\u003e reservationEntries :\n                reservations.values()) {\n          for (InMemoryReservationAllocation res : reservationEntries) {\n            if (res.getEndTime() \u003e startTime) {\n              if (user !\u003d null \u0026\u0026 !user.isEmpty()\n                      \u0026\u0026 !res.getUser().equals(user)) {\n                continue;\n              }\n              flattenedReservations.add(res);\n            }\n          }\n        }\n        return Collections.unmodifiableSet(flattenedReservations);\n      } else {\n        return Collections.emptySet();\n      }\n    } finally {\n      readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/InMemoryPlan.java"
    }
  }
}