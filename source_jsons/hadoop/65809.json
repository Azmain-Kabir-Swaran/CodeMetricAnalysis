{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "DynamoDBMetadataStore.java",
  "functionName": "completeAncestry",
  "functionId": "completeAncestry___pathsToCreate-Collection__DDBPathMetadata__(modifiers-final)__ancestorState-AncestorState(modifiers-final)",
  "sourceFilePath": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
  "functionStartLine": 889,
  "functionEndLine": 983,
  "numCommitsSeen": 111,
  "timeTaken": 8558,
  "changeHistory": [
    "7f40e6688a5716fca53e1090d8347a43064d6d43",
    "49df83899543586bbcaf80f01399ade031cf68b0",
    "c58e11bf521d746842ce16724211a2a0339d7b61",
    "b15ef7dc3d91c6d50fa515158104fba29f43e6b0",
    "e02eb24e0a9139418120027b694492e0738df20a",
    "a36274d69947648dbe82721220cc5240ec5d396d",
    "d7232857d8d1e10cdac171acdc931187e45fd6be",
    "621b43e254afaff708cd6fc4698b29628f6abc33"
  ],
  "changeHistoryShort": {
    "7f40e6688a5716fca53e1090d8347a43064d6d43": "Ybodychange",
    "49df83899543586bbcaf80f01399ade031cf68b0": "Ymultichange(Yexceptionschange,Ybodychange)",
    "c58e11bf521d746842ce16724211a2a0339d7b61": "Yparameterchange",
    "b15ef7dc3d91c6d50fa515158104fba29f43e6b0": "Ybodychange",
    "e02eb24e0a9139418120027b694492e0738df20a": "Ymultichange(Yparameterchange,Ymodifierchange,Yexceptionschange,Ybodychange,Yparametermetachange)",
    "a36274d69947648dbe82721220cc5240ec5d396d": "Ybodychange",
    "d7232857d8d1e10cdac171acdc931187e45fd6be": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
    "621b43e254afaff708cd6fc4698b29628f6abc33": "Yintroduced"
  },
  "changeHistoryDetails": {
    "7f40e6688a5716fca53e1090d8347a43064d6d43": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16746. mkdirs and s3guard Authoritative mode.\n\nContributed by Steve Loughran.\n\nThis fixes two problems with S3Guard authoritative mode and\nthe auth directory flags which are stored in DynamoDB.\n\n1. mkdirs was creating dir markers without the auth bit,\n   forcing needless scans on newly created directories and\n   files subsequently added; it was only with the first listStatus call\n   on that directory that the dir would be marked as authoritative -even\n   though it would be complete already.\n\n2. listStatus(path) would reset the authoritative status bit of all\n   child directories even if they were already marked as authoritative.\n\nIssue #2 is possibly the most expensive, as any treewalk using listStatus\n(e.g globfiles) would clear the auth bit for all child directories before\nlisting them. And this would happen every single time...\nessentially you weren\u0027t getting authoritative directory listings.\n\nFor the curious, that the major bug was actually found during testing\n-we\u0027d all missed it during reviews.\n\nA lesson there: the better the tests the fewer the bugs.\n\nMaybe also: something obvious and significant can get by code reviews.\n\n\tmodified:   hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java\n\tmodified:   hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/BulkOperationState.java\n\tmodified:   hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java\n\tmodified:   hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/LocalMetadataStore.java\n\tmodified:   hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/MetadataStore.java\n\tmodified:   hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/NullMetadataStore.java\n\tmodified:   hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/S3Guard.java\n\tmodified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/ITestS3GuardWriteBack.java\n\tmodified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/auth/ITestRestrictedReadAccess.java\n\tmodified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/impl/TestPartialDeleteFailures.java\n\tmodified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/s3guard/ITestDynamoDBMetadataStore.java\n\tmodified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/s3guard/ITestDynamoDBMetadataStoreAuthoritativeMode.java\n\tmodified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/s3guard/ITestDynamoDBMetadataStoreScale.java\n\tmodified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/s3guard/ITestS3GuardFsck.java\n\tmodified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/s3guard/MetadataStoreTestBase.java\n\tmodified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/s3guard/TestS3Guard.java\n\nChange-Id: Ic3ffda13f2af2430afedd50fd657b595c83e90a7\n",
      "commitDate": "25/01/20 10:35 AM",
      "commitName": "7f40e6688a5716fca53e1090d8347a43064d6d43",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "23/01/20 5:21 AM",
      "commitNameOld": "6c1fa24ac02b82b5e267dc966e34fb7d4f9556db",
      "commitAuthorOld": "Mingliang Liu",
      "daysBetweenCommits": 2.22,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,87 +1,95 @@\n   private Collection\u003cDDBPathMetadata\u003e completeAncestry(\n       final Collection\u003cDDBPathMetadata\u003e pathsToCreate,\n       final AncestorState ancestorState) throws IOException {\n     // Key on path to allow fast lookup\n     Map\u003cPath, Pair\u003cEntryOrigin, DDBPathMetadata\u003e\u003e ancestry \u003d new HashMap\u003c\u003e();\n     LOG.debug(\"Completing ancestry for {} paths\", pathsToCreate.size());\n     // we sort the inputs to guarantee that the topmost entries come first.\n     // that way if the put request contains both parents and children\n     // then the existing parents will not be re-created -they will just\n     // be added to the ancestor list first.\n     List\u003cDDBPathMetadata\u003e sortedPaths \u003d new ArrayList\u003c\u003e(pathsToCreate);\n     sortedPaths.sort(PathOrderComparators.TOPMOST_PM_FIRST);\n     // iterate through the paths.\n-    for (DDBPathMetadata meta : sortedPaths) {\n-      Preconditions.checkArgument(meta !\u003d null);\n-      Path path \u003d meta.getFileStatus().getPath();\n+    for (DDBPathMetadata entry : sortedPaths) {\n+      Preconditions.checkArgument(entry !\u003d null);\n+      Path path \u003d entry.getFileStatus().getPath();\n       LOG.debug(\"Adding entry {}\", path);\n       if (path.isRoot()) {\n         // this is a root entry: do not add it.\n         break;\n       }\n-      // create the new entry\n-      DDBPathMetadata entry \u003d new DDBPathMetadata(meta);\n       // add it to the ancestor state, failing if it is already there and\n       // of a different type.\n       DDBPathMetadata oldEntry \u003d ancestorState.put(path, entry);\n+      boolean addAncestors \u003d true;\n       if (oldEntry !\u003d null) {\n         if (!oldEntry.getFileStatus().isDirectory()\n             || !entry.getFileStatus().isDirectory()) {\n           // check for and warn if the existing bulk operation overwrote it.\n           // this should never occur outside tests explicitly creating it\n           LOG.warn(\"Overwriting a S3Guard file created in the operation: {}\",\n               oldEntry);\n           LOG.warn(\"With new entry: {}\", entry);\n           // restore the old state\n           ancestorState.put(path, oldEntry);\n           // then raise an exception\n           throw new PathIOException(path.toString(), E_INCONSISTENT_UPDATE);\n         } else {\n           // a directory is already present. Log and continue.\n           LOG.debug(\"Directory at {} being updated with value {}\",\n               path, entry);\n+          // and we skip the the subsequent parent scan as we\u0027ve already been\n+          // here\n+          addAncestors \u003d false;\n         }\n       }\n       // add the entry to the ancestry map as an explicitly requested entry.\n       ancestry.put(path, Pair.of(EntryOrigin.Requested, entry));\n+      // now scan up the ancestor tree to see if there are any\n+      // immediately missing entries.\n       Path parent \u003d path.getParent();\n-      while (!parent.isRoot() \u0026\u0026 !ancestry.containsKey(parent)) {\n+      while (addAncestors\n+          \u0026\u0026 !parent.isRoot() \u0026\u0026 !ancestry.containsKey(parent)) {\n         if (!ancestorState.findEntry(parent, true)) {\n           // there is no entry in the ancestor state.\n           // look in the store\n           DDBPathMetadata md;\n           Pair\u003cEntryOrigin, DDBPathMetadata\u003e newEntry;\n           final Item item \u003d getConsistentItem(parent);\n           if (item !\u003d null \u0026\u0026 !itemToPathMetadata(item, username).isDeleted()) {\n             // This is an undeleted entry found in the database.\n             // register it in ancestor state and in the map of entries to create\n             // as a retrieved entry\n             md \u003d itemToPathMetadata(item, username);\n             LOG.debug(\"Found existing entry for parent: {}\", md);\n             newEntry \u003d Pair.of(EntryOrigin.Retrieved, md);\n+            // and we break, assuming that if there is an entry, its parents\n+            // are valid too.\n+            addAncestors \u003d false;\n           } else {\n             // A directory entry was not found in the DB. Create one.\n             LOG.debug(\"auto-create ancestor path {} for child path {}\",\n                 parent, path);\n             final S3AFileStatus status \u003d makeDirStatus(parent, username);\n             md \u003d new DDBPathMetadata(status, Tristate.FALSE,\n                 false, false, ttlTimeProvider.getNow());\n             // declare to be a generated entry\n             newEntry \u003d  Pair.of(EntryOrigin.Generated, md);\n           }\n           // insert into the ancestor state to avoid further checks\n           ancestorState.put(parent, md);\n           ancestry.put(parent, newEntry);\n         }\n         parent \u003d parent.getParent();\n       }\n     }\n     // we now have a list of entries which were not in the operation state.\n     // Filter out those which were retrieved, to produce a list of those\n     // which must be written to the database.\n     // TODO sort in reverse order of existence\n     return ancestry.values().stream()\n         .filter(p -\u003e p.getLeft() !\u003d EntryOrigin.Retrieved)\n         .map(Pair::getRight)\n         .collect(Collectors.toList());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Collection\u003cDDBPathMetadata\u003e completeAncestry(\n      final Collection\u003cDDBPathMetadata\u003e pathsToCreate,\n      final AncestorState ancestorState) throws IOException {\n    // Key on path to allow fast lookup\n    Map\u003cPath, Pair\u003cEntryOrigin, DDBPathMetadata\u003e\u003e ancestry \u003d new HashMap\u003c\u003e();\n    LOG.debug(\"Completing ancestry for {} paths\", pathsToCreate.size());\n    // we sort the inputs to guarantee that the topmost entries come first.\n    // that way if the put request contains both parents and children\n    // then the existing parents will not be re-created -they will just\n    // be added to the ancestor list first.\n    List\u003cDDBPathMetadata\u003e sortedPaths \u003d new ArrayList\u003c\u003e(pathsToCreate);\n    sortedPaths.sort(PathOrderComparators.TOPMOST_PM_FIRST);\n    // iterate through the paths.\n    for (DDBPathMetadata entry : sortedPaths) {\n      Preconditions.checkArgument(entry !\u003d null);\n      Path path \u003d entry.getFileStatus().getPath();\n      LOG.debug(\"Adding entry {}\", path);\n      if (path.isRoot()) {\n        // this is a root entry: do not add it.\n        break;\n      }\n      // add it to the ancestor state, failing if it is already there and\n      // of a different type.\n      DDBPathMetadata oldEntry \u003d ancestorState.put(path, entry);\n      boolean addAncestors \u003d true;\n      if (oldEntry !\u003d null) {\n        if (!oldEntry.getFileStatus().isDirectory()\n            || !entry.getFileStatus().isDirectory()) {\n          // check for and warn if the existing bulk operation overwrote it.\n          // this should never occur outside tests explicitly creating it\n          LOG.warn(\"Overwriting a S3Guard file created in the operation: {}\",\n              oldEntry);\n          LOG.warn(\"With new entry: {}\", entry);\n          // restore the old state\n          ancestorState.put(path, oldEntry);\n          // then raise an exception\n          throw new PathIOException(path.toString(), E_INCONSISTENT_UPDATE);\n        } else {\n          // a directory is already present. Log and continue.\n          LOG.debug(\"Directory at {} being updated with value {}\",\n              path, entry);\n          // and we skip the the subsequent parent scan as we\u0027ve already been\n          // here\n          addAncestors \u003d false;\n        }\n      }\n      // add the entry to the ancestry map as an explicitly requested entry.\n      ancestry.put(path, Pair.of(EntryOrigin.Requested, entry));\n      // now scan up the ancestor tree to see if there are any\n      // immediately missing entries.\n      Path parent \u003d path.getParent();\n      while (addAncestors\n          \u0026\u0026 !parent.isRoot() \u0026\u0026 !ancestry.containsKey(parent)) {\n        if (!ancestorState.findEntry(parent, true)) {\n          // there is no entry in the ancestor state.\n          // look in the store\n          DDBPathMetadata md;\n          Pair\u003cEntryOrigin, DDBPathMetadata\u003e newEntry;\n          final Item item \u003d getConsistentItem(parent);\n          if (item !\u003d null \u0026\u0026 !itemToPathMetadata(item, username).isDeleted()) {\n            // This is an undeleted entry found in the database.\n            // register it in ancestor state and in the map of entries to create\n            // as a retrieved entry\n            md \u003d itemToPathMetadata(item, username);\n            LOG.debug(\"Found existing entry for parent: {}\", md);\n            newEntry \u003d Pair.of(EntryOrigin.Retrieved, md);\n            // and we break, assuming that if there is an entry, its parents\n            // are valid too.\n            addAncestors \u003d false;\n          } else {\n            // A directory entry was not found in the DB. Create one.\n            LOG.debug(\"auto-create ancestor path {} for child path {}\",\n                parent, path);\n            final S3AFileStatus status \u003d makeDirStatus(parent, username);\n            md \u003d new DDBPathMetadata(status, Tristate.FALSE,\n                false, false, ttlTimeProvider.getNow());\n            // declare to be a generated entry\n            newEntry \u003d  Pair.of(EntryOrigin.Generated, md);\n          }\n          // insert into the ancestor state to avoid further checks\n          ancestorState.put(parent, md);\n          ancestry.put(parent, newEntry);\n        }\n        parent \u003d parent.getParent();\n      }\n    }\n    // we now have a list of entries which were not in the operation state.\n    // Filter out those which were retrieved, to produce a list of those\n    // which must be written to the database.\n    // TODO sort in reverse order of existence\n    return ancestry.values().stream()\n        .filter(p -\u003e p.getLeft() !\u003d EntryOrigin.Retrieved)\n        .map(Pair::getRight)\n        .collect(Collectors.toList());\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
      "extendedDetails": {}
    },
    "49df83899543586bbcaf80f01399ade031cf68b0": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "HADOOP-16697. Tune/audit S3A authoritative mode.\n\nContains:\n\nHADOOP-16474. S3Guard ProgressiveRenameTracker to mark destination\n              dirirectory as authoritative on success.\nHADOOP-16684. S3guard bucket info to list a bit more about\n              authoritative paths.\nHADOOP-16722. S3GuardTool to support FilterFileSystem.\n\nThis patch improves the marking of newly created/import directory\ntrees in S3Guard DynamoDB tables as authoritative.\n\nSpecific changes:\n\n * Renamed directories are marked as authoritative if the entire\n   operation succeeded (HADOOP-16474).\n * When updating parent table entries as part of any table write,\n   there\u0027s no overwriting of their authoritative flag.\n\ns3guard import changes:\n\n* new -verbose flag to print out what is going on.\n\n* The \"s3guard import\" command lets you declare that a directory tree\nis to be marked as authoritative\n\n  hadoop s3guard import -authoritative -verbose s3a://bucket/path\n\nWhen importing a listing and a file is found, the import tool queries\nthe metastore and only updates the entry if the file is different from\nbefore, where different \u003d\u003d new timestamp, etag, or length. S3Guard can get\ntimestamp differences due to clock skew in PUT operations.\n\nAs the recursive list performed by the import command doesn\u0027t retrieve the\nversionID, the existing entry may in fact be more complete.\nWhen updating an existing due to clock skew the existing version ID\nis propagated to the new entry (note: the etags must match; this is needed\nto deal with inconsistent listings).\n\nThere is a new s3guard command to audit a s3guard bucket/path\u0027s\nauthoritative state:\n\n  hadoop s3guard authoritative -check-config s3a://bucket/path\n\nThis is primarily for testing/auditing.\n\nThe s3guard bucket-info command also provides some more details on the\nauthoritative state of a store (HADOOP-16684).\n\nChange-Id: I58001341c04f6f3597fcb4fcb1581ccefeb77d91\n",
      "commitDate": "10/01/20 3:11 AM",
      "commitName": "49df83899543586bbcaf80f01399ade031cf68b0",
      "commitAuthor": "Steve Loughran",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "HADOOP-16697. Tune/audit S3A authoritative mode.\n\nContains:\n\nHADOOP-16474. S3Guard ProgressiveRenameTracker to mark destination\n              dirirectory as authoritative on success.\nHADOOP-16684. S3guard bucket info to list a bit more about\n              authoritative paths.\nHADOOP-16722. S3GuardTool to support FilterFileSystem.\n\nThis patch improves the marking of newly created/import directory\ntrees in S3Guard DynamoDB tables as authoritative.\n\nSpecific changes:\n\n * Renamed directories are marked as authoritative if the entire\n   operation succeeded (HADOOP-16474).\n * When updating parent table entries as part of any table write,\n   there\u0027s no overwriting of their authoritative flag.\n\ns3guard import changes:\n\n* new -verbose flag to print out what is going on.\n\n* The \"s3guard import\" command lets you declare that a directory tree\nis to be marked as authoritative\n\n  hadoop s3guard import -authoritative -verbose s3a://bucket/path\n\nWhen importing a listing and a file is found, the import tool queries\nthe metastore and only updates the entry if the file is different from\nbefore, where different \u003d\u003d new timestamp, etag, or length. S3Guard can get\ntimestamp differences due to clock skew in PUT operations.\n\nAs the recursive list performed by the import command doesn\u0027t retrieve the\nversionID, the existing entry may in fact be more complete.\nWhen updating an existing due to clock skew the existing version ID\nis propagated to the new entry (note: the etags must match; this is needed\nto deal with inconsistent listings).\n\nThere is a new s3guard command to audit a s3guard bucket/path\u0027s\nauthoritative state:\n\n  hadoop s3guard authoritative -check-config s3a://bucket/path\n\nThis is primarily for testing/auditing.\n\nThe s3guard bucket-info command also provides some more details on the\nauthoritative state of a store (HADOOP-16684).\n\nChange-Id: I58001341c04f6f3597fcb4fcb1581ccefeb77d91\n",
          "commitDate": "10/01/20 3:11 AM",
          "commitName": "49df83899543586bbcaf80f01399ade031cf68b0",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "26/11/19 7:36 AM",
          "commitNameOld": "ea25f4de236611d388e14a710ebe5d6872c421b6",
          "commitAuthorOld": "Gabor Bota",
          "daysBetweenCommits": 44.82,
          "commitsBetweenForRepo": 155,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,62 +1,87 @@\n   private Collection\u003cDDBPathMetadata\u003e completeAncestry(\n       final Collection\u003cDDBPathMetadata\u003e pathsToCreate,\n-      final AncestorState ancestorState) throws PathIOException {\n+      final AncestorState ancestorState) throws IOException {\n     // Key on path to allow fast lookup\n-    Map\u003cPath, DDBPathMetadata\u003e ancestry \u003d new HashMap\u003c\u003e();\n+    Map\u003cPath, Pair\u003cEntryOrigin, DDBPathMetadata\u003e\u003e ancestry \u003d new HashMap\u003c\u003e();\n     LOG.debug(\"Completing ancestry for {} paths\", pathsToCreate.size());\n     // we sort the inputs to guarantee that the topmost entries come first.\n     // that way if the put request contains both parents and children\n     // then the existing parents will not be re-created -they will just\n     // be added to the ancestor list first.\n     List\u003cDDBPathMetadata\u003e sortedPaths \u003d new ArrayList\u003c\u003e(pathsToCreate);\n     sortedPaths.sort(PathOrderComparators.TOPMOST_PM_FIRST);\n     // iterate through the paths.\n     for (DDBPathMetadata meta : sortedPaths) {\n       Preconditions.checkArgument(meta !\u003d null);\n       Path path \u003d meta.getFileStatus().getPath();\n       LOG.debug(\"Adding entry {}\", path);\n       if (path.isRoot()) {\n         // this is a root entry: do not add it.\n         break;\n       }\n       // create the new entry\n       DDBPathMetadata entry \u003d new DDBPathMetadata(meta);\n       // add it to the ancestor state, failing if it is already there and\n       // of a different type.\n       DDBPathMetadata oldEntry \u003d ancestorState.put(path, entry);\n       if (oldEntry !\u003d null) {\n         if (!oldEntry.getFileStatus().isDirectory()\n             || !entry.getFileStatus().isDirectory()) {\n           // check for and warn if the existing bulk operation overwrote it.\n           // this should never occur outside tests explicitly creating it\n           LOG.warn(\"Overwriting a S3Guard file created in the operation: {}\",\n               oldEntry);\n           LOG.warn(\"With new entry: {}\", entry);\n           // restore the old state\n           ancestorState.put(path, oldEntry);\n           // then raise an exception\n           throw new PathIOException(path.toString(), E_INCONSISTENT_UPDATE);\n         } else {\n           // a directory is already present. Log and continue.\n           LOG.debug(\"Directory at {} being updated with value {}\",\n               path, entry);\n         }\n       }\n-      ancestry.put(path, entry);\n+      // add the entry to the ancestry map as an explicitly requested entry.\n+      ancestry.put(path, Pair.of(EntryOrigin.Requested, entry));\n       Path parent \u003d path.getParent();\n       while (!parent.isRoot() \u0026\u0026 !ancestry.containsKey(parent)) {\n         if (!ancestorState.findEntry(parent, true)) {\n-          // don\u0027t add this entry, but carry on with the parents\n-          LOG.debug(\"auto-create ancestor path {} for child path {}\",\n-              parent, path);\n-          final S3AFileStatus status \u003d makeDirStatus(parent, username);\n-          DDBPathMetadata md \u003d new DDBPathMetadata(status, Tristate.FALSE,\n-              false, false, ttlTimeProvider.getNow());\n+          // there is no entry in the ancestor state.\n+          // look in the store\n+          DDBPathMetadata md;\n+          Pair\u003cEntryOrigin, DDBPathMetadata\u003e newEntry;\n+          final Item item \u003d getConsistentItem(parent);\n+          if (item !\u003d null \u0026\u0026 !itemToPathMetadata(item, username).isDeleted()) {\n+            // This is an undeleted entry found in the database.\n+            // register it in ancestor state and in the map of entries to create\n+            // as a retrieved entry\n+            md \u003d itemToPathMetadata(item, username);\n+            LOG.debug(\"Found existing entry for parent: {}\", md);\n+            newEntry \u003d Pair.of(EntryOrigin.Retrieved, md);\n+          } else {\n+            // A directory entry was not found in the DB. Create one.\n+            LOG.debug(\"auto-create ancestor path {} for child path {}\",\n+                parent, path);\n+            final S3AFileStatus status \u003d makeDirStatus(parent, username);\n+            md \u003d new DDBPathMetadata(status, Tristate.FALSE,\n+                false, false, ttlTimeProvider.getNow());\n+            // declare to be a generated entry\n+            newEntry \u003d  Pair.of(EntryOrigin.Generated, md);\n+          }\n+          // insert into the ancestor state to avoid further checks\n           ancestorState.put(parent, md);\n-          ancestry.put(parent, md);\n+          ancestry.put(parent, newEntry);\n         }\n         parent \u003d parent.getParent();\n       }\n     }\n-    return ancestry.values();\n+    // we now have a list of entries which were not in the operation state.\n+    // Filter out those which were retrieved, to produce a list of those\n+    // which must be written to the database.\n+    // TODO sort in reverse order of existence\n+    return ancestry.values().stream()\n+        .filter(p -\u003e p.getLeft() !\u003d EntryOrigin.Retrieved)\n+        .map(Pair::getRight)\n+        .collect(Collectors.toList());\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private Collection\u003cDDBPathMetadata\u003e completeAncestry(\n      final Collection\u003cDDBPathMetadata\u003e pathsToCreate,\n      final AncestorState ancestorState) throws IOException {\n    // Key on path to allow fast lookup\n    Map\u003cPath, Pair\u003cEntryOrigin, DDBPathMetadata\u003e\u003e ancestry \u003d new HashMap\u003c\u003e();\n    LOG.debug(\"Completing ancestry for {} paths\", pathsToCreate.size());\n    // we sort the inputs to guarantee that the topmost entries come first.\n    // that way if the put request contains both parents and children\n    // then the existing parents will not be re-created -they will just\n    // be added to the ancestor list first.\n    List\u003cDDBPathMetadata\u003e sortedPaths \u003d new ArrayList\u003c\u003e(pathsToCreate);\n    sortedPaths.sort(PathOrderComparators.TOPMOST_PM_FIRST);\n    // iterate through the paths.\n    for (DDBPathMetadata meta : sortedPaths) {\n      Preconditions.checkArgument(meta !\u003d null);\n      Path path \u003d meta.getFileStatus().getPath();\n      LOG.debug(\"Adding entry {}\", path);\n      if (path.isRoot()) {\n        // this is a root entry: do not add it.\n        break;\n      }\n      // create the new entry\n      DDBPathMetadata entry \u003d new DDBPathMetadata(meta);\n      // add it to the ancestor state, failing if it is already there and\n      // of a different type.\n      DDBPathMetadata oldEntry \u003d ancestorState.put(path, entry);\n      if (oldEntry !\u003d null) {\n        if (!oldEntry.getFileStatus().isDirectory()\n            || !entry.getFileStatus().isDirectory()) {\n          // check for and warn if the existing bulk operation overwrote it.\n          // this should never occur outside tests explicitly creating it\n          LOG.warn(\"Overwriting a S3Guard file created in the operation: {}\",\n              oldEntry);\n          LOG.warn(\"With new entry: {}\", entry);\n          // restore the old state\n          ancestorState.put(path, oldEntry);\n          // then raise an exception\n          throw new PathIOException(path.toString(), E_INCONSISTENT_UPDATE);\n        } else {\n          // a directory is already present. Log and continue.\n          LOG.debug(\"Directory at {} being updated with value {}\",\n              path, entry);\n        }\n      }\n      // add the entry to the ancestry map as an explicitly requested entry.\n      ancestry.put(path, Pair.of(EntryOrigin.Requested, entry));\n      Path parent \u003d path.getParent();\n      while (!parent.isRoot() \u0026\u0026 !ancestry.containsKey(parent)) {\n        if (!ancestorState.findEntry(parent, true)) {\n          // there is no entry in the ancestor state.\n          // look in the store\n          DDBPathMetadata md;\n          Pair\u003cEntryOrigin, DDBPathMetadata\u003e newEntry;\n          final Item item \u003d getConsistentItem(parent);\n          if (item !\u003d null \u0026\u0026 !itemToPathMetadata(item, username).isDeleted()) {\n            // This is an undeleted entry found in the database.\n            // register it in ancestor state and in the map of entries to create\n            // as a retrieved entry\n            md \u003d itemToPathMetadata(item, username);\n            LOG.debug(\"Found existing entry for parent: {}\", md);\n            newEntry \u003d Pair.of(EntryOrigin.Retrieved, md);\n          } else {\n            // A directory entry was not found in the DB. Create one.\n            LOG.debug(\"auto-create ancestor path {} for child path {}\",\n                parent, path);\n            final S3AFileStatus status \u003d makeDirStatus(parent, username);\n            md \u003d new DDBPathMetadata(status, Tristate.FALSE,\n                false, false, ttlTimeProvider.getNow());\n            // declare to be a generated entry\n            newEntry \u003d  Pair.of(EntryOrigin.Generated, md);\n          }\n          // insert into the ancestor state to avoid further checks\n          ancestorState.put(parent, md);\n          ancestry.put(parent, newEntry);\n        }\n        parent \u003d parent.getParent();\n      }\n    }\n    // we now have a list of entries which were not in the operation state.\n    // Filter out those which were retrieved, to produce a list of those\n    // which must be written to the database.\n    // TODO sort in reverse order of existence\n    return ancestry.values().stream()\n        .filter(p -\u003e p.getLeft() !\u003d EntryOrigin.Retrieved)\n        .map(Pair::getRight)\n        .collect(Collectors.toList());\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
          "extendedDetails": {
            "oldValue": "[PathIOException]",
            "newValue": "[IOException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-16697. Tune/audit S3A authoritative mode.\n\nContains:\n\nHADOOP-16474. S3Guard ProgressiveRenameTracker to mark destination\n              dirirectory as authoritative on success.\nHADOOP-16684. S3guard bucket info to list a bit more about\n              authoritative paths.\nHADOOP-16722. S3GuardTool to support FilterFileSystem.\n\nThis patch improves the marking of newly created/import directory\ntrees in S3Guard DynamoDB tables as authoritative.\n\nSpecific changes:\n\n * Renamed directories are marked as authoritative if the entire\n   operation succeeded (HADOOP-16474).\n * When updating parent table entries as part of any table write,\n   there\u0027s no overwriting of their authoritative flag.\n\ns3guard import changes:\n\n* new -verbose flag to print out what is going on.\n\n* The \"s3guard import\" command lets you declare that a directory tree\nis to be marked as authoritative\n\n  hadoop s3guard import -authoritative -verbose s3a://bucket/path\n\nWhen importing a listing and a file is found, the import tool queries\nthe metastore and only updates the entry if the file is different from\nbefore, where different \u003d\u003d new timestamp, etag, or length. S3Guard can get\ntimestamp differences due to clock skew in PUT operations.\n\nAs the recursive list performed by the import command doesn\u0027t retrieve the\nversionID, the existing entry may in fact be more complete.\nWhen updating an existing due to clock skew the existing version ID\nis propagated to the new entry (note: the etags must match; this is needed\nto deal with inconsistent listings).\n\nThere is a new s3guard command to audit a s3guard bucket/path\u0027s\nauthoritative state:\n\n  hadoop s3guard authoritative -check-config s3a://bucket/path\n\nThis is primarily for testing/auditing.\n\nThe s3guard bucket-info command also provides some more details on the\nauthoritative state of a store (HADOOP-16684).\n\nChange-Id: I58001341c04f6f3597fcb4fcb1581ccefeb77d91\n",
          "commitDate": "10/01/20 3:11 AM",
          "commitName": "49df83899543586bbcaf80f01399ade031cf68b0",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "26/11/19 7:36 AM",
          "commitNameOld": "ea25f4de236611d388e14a710ebe5d6872c421b6",
          "commitAuthorOld": "Gabor Bota",
          "daysBetweenCommits": 44.82,
          "commitsBetweenForRepo": 155,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,62 +1,87 @@\n   private Collection\u003cDDBPathMetadata\u003e completeAncestry(\n       final Collection\u003cDDBPathMetadata\u003e pathsToCreate,\n-      final AncestorState ancestorState) throws PathIOException {\n+      final AncestorState ancestorState) throws IOException {\n     // Key on path to allow fast lookup\n-    Map\u003cPath, DDBPathMetadata\u003e ancestry \u003d new HashMap\u003c\u003e();\n+    Map\u003cPath, Pair\u003cEntryOrigin, DDBPathMetadata\u003e\u003e ancestry \u003d new HashMap\u003c\u003e();\n     LOG.debug(\"Completing ancestry for {} paths\", pathsToCreate.size());\n     // we sort the inputs to guarantee that the topmost entries come first.\n     // that way if the put request contains both parents and children\n     // then the existing parents will not be re-created -they will just\n     // be added to the ancestor list first.\n     List\u003cDDBPathMetadata\u003e sortedPaths \u003d new ArrayList\u003c\u003e(pathsToCreate);\n     sortedPaths.sort(PathOrderComparators.TOPMOST_PM_FIRST);\n     // iterate through the paths.\n     for (DDBPathMetadata meta : sortedPaths) {\n       Preconditions.checkArgument(meta !\u003d null);\n       Path path \u003d meta.getFileStatus().getPath();\n       LOG.debug(\"Adding entry {}\", path);\n       if (path.isRoot()) {\n         // this is a root entry: do not add it.\n         break;\n       }\n       // create the new entry\n       DDBPathMetadata entry \u003d new DDBPathMetadata(meta);\n       // add it to the ancestor state, failing if it is already there and\n       // of a different type.\n       DDBPathMetadata oldEntry \u003d ancestorState.put(path, entry);\n       if (oldEntry !\u003d null) {\n         if (!oldEntry.getFileStatus().isDirectory()\n             || !entry.getFileStatus().isDirectory()) {\n           // check for and warn if the existing bulk operation overwrote it.\n           // this should never occur outside tests explicitly creating it\n           LOG.warn(\"Overwriting a S3Guard file created in the operation: {}\",\n               oldEntry);\n           LOG.warn(\"With new entry: {}\", entry);\n           // restore the old state\n           ancestorState.put(path, oldEntry);\n           // then raise an exception\n           throw new PathIOException(path.toString(), E_INCONSISTENT_UPDATE);\n         } else {\n           // a directory is already present. Log and continue.\n           LOG.debug(\"Directory at {} being updated with value {}\",\n               path, entry);\n         }\n       }\n-      ancestry.put(path, entry);\n+      // add the entry to the ancestry map as an explicitly requested entry.\n+      ancestry.put(path, Pair.of(EntryOrigin.Requested, entry));\n       Path parent \u003d path.getParent();\n       while (!parent.isRoot() \u0026\u0026 !ancestry.containsKey(parent)) {\n         if (!ancestorState.findEntry(parent, true)) {\n-          // don\u0027t add this entry, but carry on with the parents\n-          LOG.debug(\"auto-create ancestor path {} for child path {}\",\n-              parent, path);\n-          final S3AFileStatus status \u003d makeDirStatus(parent, username);\n-          DDBPathMetadata md \u003d new DDBPathMetadata(status, Tristate.FALSE,\n-              false, false, ttlTimeProvider.getNow());\n+          // there is no entry in the ancestor state.\n+          // look in the store\n+          DDBPathMetadata md;\n+          Pair\u003cEntryOrigin, DDBPathMetadata\u003e newEntry;\n+          final Item item \u003d getConsistentItem(parent);\n+          if (item !\u003d null \u0026\u0026 !itemToPathMetadata(item, username).isDeleted()) {\n+            // This is an undeleted entry found in the database.\n+            // register it in ancestor state and in the map of entries to create\n+            // as a retrieved entry\n+            md \u003d itemToPathMetadata(item, username);\n+            LOG.debug(\"Found existing entry for parent: {}\", md);\n+            newEntry \u003d Pair.of(EntryOrigin.Retrieved, md);\n+          } else {\n+            // A directory entry was not found in the DB. Create one.\n+            LOG.debug(\"auto-create ancestor path {} for child path {}\",\n+                parent, path);\n+            final S3AFileStatus status \u003d makeDirStatus(parent, username);\n+            md \u003d new DDBPathMetadata(status, Tristate.FALSE,\n+                false, false, ttlTimeProvider.getNow());\n+            // declare to be a generated entry\n+            newEntry \u003d  Pair.of(EntryOrigin.Generated, md);\n+          }\n+          // insert into the ancestor state to avoid further checks\n           ancestorState.put(parent, md);\n-          ancestry.put(parent, md);\n+          ancestry.put(parent, newEntry);\n         }\n         parent \u003d parent.getParent();\n       }\n     }\n-    return ancestry.values();\n+    // we now have a list of entries which were not in the operation state.\n+    // Filter out those which were retrieved, to produce a list of those\n+    // which must be written to the database.\n+    // TODO sort in reverse order of existence\n+    return ancestry.values().stream()\n+        .filter(p -\u003e p.getLeft() !\u003d EntryOrigin.Retrieved)\n+        .map(Pair::getRight)\n+        .collect(Collectors.toList());\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private Collection\u003cDDBPathMetadata\u003e completeAncestry(\n      final Collection\u003cDDBPathMetadata\u003e pathsToCreate,\n      final AncestorState ancestorState) throws IOException {\n    // Key on path to allow fast lookup\n    Map\u003cPath, Pair\u003cEntryOrigin, DDBPathMetadata\u003e\u003e ancestry \u003d new HashMap\u003c\u003e();\n    LOG.debug(\"Completing ancestry for {} paths\", pathsToCreate.size());\n    // we sort the inputs to guarantee that the topmost entries come first.\n    // that way if the put request contains both parents and children\n    // then the existing parents will not be re-created -they will just\n    // be added to the ancestor list first.\n    List\u003cDDBPathMetadata\u003e sortedPaths \u003d new ArrayList\u003c\u003e(pathsToCreate);\n    sortedPaths.sort(PathOrderComparators.TOPMOST_PM_FIRST);\n    // iterate through the paths.\n    for (DDBPathMetadata meta : sortedPaths) {\n      Preconditions.checkArgument(meta !\u003d null);\n      Path path \u003d meta.getFileStatus().getPath();\n      LOG.debug(\"Adding entry {}\", path);\n      if (path.isRoot()) {\n        // this is a root entry: do not add it.\n        break;\n      }\n      // create the new entry\n      DDBPathMetadata entry \u003d new DDBPathMetadata(meta);\n      // add it to the ancestor state, failing if it is already there and\n      // of a different type.\n      DDBPathMetadata oldEntry \u003d ancestorState.put(path, entry);\n      if (oldEntry !\u003d null) {\n        if (!oldEntry.getFileStatus().isDirectory()\n            || !entry.getFileStatus().isDirectory()) {\n          // check for and warn if the existing bulk operation overwrote it.\n          // this should never occur outside tests explicitly creating it\n          LOG.warn(\"Overwriting a S3Guard file created in the operation: {}\",\n              oldEntry);\n          LOG.warn(\"With new entry: {}\", entry);\n          // restore the old state\n          ancestorState.put(path, oldEntry);\n          // then raise an exception\n          throw new PathIOException(path.toString(), E_INCONSISTENT_UPDATE);\n        } else {\n          // a directory is already present. Log and continue.\n          LOG.debug(\"Directory at {} being updated with value {}\",\n              path, entry);\n        }\n      }\n      // add the entry to the ancestry map as an explicitly requested entry.\n      ancestry.put(path, Pair.of(EntryOrigin.Requested, entry));\n      Path parent \u003d path.getParent();\n      while (!parent.isRoot() \u0026\u0026 !ancestry.containsKey(parent)) {\n        if (!ancestorState.findEntry(parent, true)) {\n          // there is no entry in the ancestor state.\n          // look in the store\n          DDBPathMetadata md;\n          Pair\u003cEntryOrigin, DDBPathMetadata\u003e newEntry;\n          final Item item \u003d getConsistentItem(parent);\n          if (item !\u003d null \u0026\u0026 !itemToPathMetadata(item, username).isDeleted()) {\n            // This is an undeleted entry found in the database.\n            // register it in ancestor state and in the map of entries to create\n            // as a retrieved entry\n            md \u003d itemToPathMetadata(item, username);\n            LOG.debug(\"Found existing entry for parent: {}\", md);\n            newEntry \u003d Pair.of(EntryOrigin.Retrieved, md);\n          } else {\n            // A directory entry was not found in the DB. Create one.\n            LOG.debug(\"auto-create ancestor path {} for child path {}\",\n                parent, path);\n            final S3AFileStatus status \u003d makeDirStatus(parent, username);\n            md \u003d new DDBPathMetadata(status, Tristate.FALSE,\n                false, false, ttlTimeProvider.getNow());\n            // declare to be a generated entry\n            newEntry \u003d  Pair.of(EntryOrigin.Generated, md);\n          }\n          // insert into the ancestor state to avoid further checks\n          ancestorState.put(parent, md);\n          ancestry.put(parent, newEntry);\n        }\n        parent \u003d parent.getParent();\n      }\n    }\n    // we now have a list of entries which were not in the operation state.\n    // Filter out those which were retrieved, to produce a list of those\n    // which must be written to the database.\n    // TODO sort in reverse order of existence\n    return ancestry.values().stream()\n        .filter(p -\u003e p.getLeft() !\u003d EntryOrigin.Retrieved)\n        .map(Pair::getRight)\n        .collect(Collectors.toList());\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
          "extendedDetails": {}
        }
      ]
    },
    "c58e11bf521d746842ce16724211a2a0339d7b61": {
      "type": "Yparameterchange",
      "commitMessage": "HADOOP-16383. Pass ITtlTimeProvider instance in initialize method in MetadataStore interface.  Contributed by Gabor Bota. (#1009) \n\n\r\n",
      "commitDate": "17/07/19 7:24 AM",
      "commitName": "c58e11bf521d746842ce16724211a2a0339d7b61",
      "commitAuthor": "Gabor Bota",
      "commitDateOld": "12/07/19 5:02 AM",
      "commitNameOld": "b15ef7dc3d91c6d50fa515158104fba29f43e6b0",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 5.1,
      "commitsBetweenForRepo": 35,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,63 +1,62 @@\n   private Collection\u003cDDBPathMetadata\u003e completeAncestry(\n       final Collection\u003cDDBPathMetadata\u003e pathsToCreate,\n-      final AncestorState ancestorState,\n-      final ITtlTimeProvider ttlTimeProvider) throws PathIOException {\n+      final AncestorState ancestorState) throws PathIOException {\n     // Key on path to allow fast lookup\n     Map\u003cPath, DDBPathMetadata\u003e ancestry \u003d new HashMap\u003c\u003e();\n     LOG.debug(\"Completing ancestry for {} paths\", pathsToCreate.size());\n     // we sort the inputs to guarantee that the topmost entries come first.\n     // that way if the put request contains both parents and children\n     // then the existing parents will not be re-created -they will just\n     // be added to the ancestor list first.\n     List\u003cDDBPathMetadata\u003e sortedPaths \u003d new ArrayList\u003c\u003e(pathsToCreate);\n     sortedPaths.sort(PathOrderComparators.TOPMOST_PM_FIRST);\n     // iterate through the paths.\n     for (DDBPathMetadata meta : sortedPaths) {\n       Preconditions.checkArgument(meta !\u003d null);\n       Path path \u003d meta.getFileStatus().getPath();\n       LOG.debug(\"Adding entry {}\", path);\n       if (path.isRoot()) {\n         // this is a root entry: do not add it.\n         break;\n       }\n       // create the new entry\n       DDBPathMetadata entry \u003d new DDBPathMetadata(meta);\n       // add it to the ancestor state, failing if it is already there and\n       // of a different type.\n       DDBPathMetadata oldEntry \u003d ancestorState.put(path, entry);\n       if (oldEntry !\u003d null) {\n         if (!oldEntry.getFileStatus().isDirectory()\n             || !entry.getFileStatus().isDirectory()) {\n           // check for and warn if the existing bulk operation overwrote it.\n           // this should never occur outside tests explicitly creating it\n           LOG.warn(\"Overwriting a S3Guard file created in the operation: {}\",\n               oldEntry);\n           LOG.warn(\"With new entry: {}\", entry);\n           // restore the old state\n           ancestorState.put(path, oldEntry);\n           // then raise an exception\n           throw new PathIOException(path.toString(), E_INCONSISTENT_UPDATE);\n         } else {\n           // a directory is already present. Log and continue.\n           LOG.debug(\"Directory at {} being updated with value {}\",\n               path, entry);\n         }\n       }\n       ancestry.put(path, entry);\n       Path parent \u003d path.getParent();\n       while (!parent.isRoot() \u0026\u0026 !ancestry.containsKey(parent)) {\n         if (!ancestorState.findEntry(parent, true)) {\n           // don\u0027t add this entry, but carry on with the parents\n           LOG.debug(\"auto-create ancestor path {} for child path {}\",\n               parent, path);\n           final S3AFileStatus status \u003d makeDirStatus(parent, username);\n           DDBPathMetadata md \u003d new DDBPathMetadata(status, Tristate.FALSE,\n               false, false, ttlTimeProvider.getNow());\n           ancestorState.put(parent, md);\n           ancestry.put(parent, md);\n         }\n         parent \u003d parent.getParent();\n       }\n     }\n     return ancestry.values();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Collection\u003cDDBPathMetadata\u003e completeAncestry(\n      final Collection\u003cDDBPathMetadata\u003e pathsToCreate,\n      final AncestorState ancestorState) throws PathIOException {\n    // Key on path to allow fast lookup\n    Map\u003cPath, DDBPathMetadata\u003e ancestry \u003d new HashMap\u003c\u003e();\n    LOG.debug(\"Completing ancestry for {} paths\", pathsToCreate.size());\n    // we sort the inputs to guarantee that the topmost entries come first.\n    // that way if the put request contains both parents and children\n    // then the existing parents will not be re-created -they will just\n    // be added to the ancestor list first.\n    List\u003cDDBPathMetadata\u003e sortedPaths \u003d new ArrayList\u003c\u003e(pathsToCreate);\n    sortedPaths.sort(PathOrderComparators.TOPMOST_PM_FIRST);\n    // iterate through the paths.\n    for (DDBPathMetadata meta : sortedPaths) {\n      Preconditions.checkArgument(meta !\u003d null);\n      Path path \u003d meta.getFileStatus().getPath();\n      LOG.debug(\"Adding entry {}\", path);\n      if (path.isRoot()) {\n        // this is a root entry: do not add it.\n        break;\n      }\n      // create the new entry\n      DDBPathMetadata entry \u003d new DDBPathMetadata(meta);\n      // add it to the ancestor state, failing if it is already there and\n      // of a different type.\n      DDBPathMetadata oldEntry \u003d ancestorState.put(path, entry);\n      if (oldEntry !\u003d null) {\n        if (!oldEntry.getFileStatus().isDirectory()\n            || !entry.getFileStatus().isDirectory()) {\n          // check for and warn if the existing bulk operation overwrote it.\n          // this should never occur outside tests explicitly creating it\n          LOG.warn(\"Overwriting a S3Guard file created in the operation: {}\",\n              oldEntry);\n          LOG.warn(\"With new entry: {}\", entry);\n          // restore the old state\n          ancestorState.put(path, oldEntry);\n          // then raise an exception\n          throw new PathIOException(path.toString(), E_INCONSISTENT_UPDATE);\n        } else {\n          // a directory is already present. Log and continue.\n          LOG.debug(\"Directory at {} being updated with value {}\",\n              path, entry);\n        }\n      }\n      ancestry.put(path, entry);\n      Path parent \u003d path.getParent();\n      while (!parent.isRoot() \u0026\u0026 !ancestry.containsKey(parent)) {\n        if (!ancestorState.findEntry(parent, true)) {\n          // don\u0027t add this entry, but carry on with the parents\n          LOG.debug(\"auto-create ancestor path {} for child path {}\",\n              parent, path);\n          final S3AFileStatus status \u003d makeDirStatus(parent, username);\n          DDBPathMetadata md \u003d new DDBPathMetadata(status, Tristate.FALSE,\n              false, false, ttlTimeProvider.getNow());\n          ancestorState.put(parent, md);\n          ancestry.put(parent, md);\n        }\n        parent \u003d parent.getParent();\n      }\n    }\n    return ancestry.values();\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
      "extendedDetails": {
        "oldValue": "[pathsToCreate-Collection\u003cDDBPathMetadata\u003e(modifiers-final), ancestorState-AncestorState(modifiers-final), ttlTimeProvider-ITtlTimeProvider(modifiers-final)]",
        "newValue": "[pathsToCreate-Collection\u003cDDBPathMetadata\u003e(modifiers-final), ancestorState-AncestorState(modifiers-final)]"
      }
    },
    "b15ef7dc3d91c6d50fa515158104fba29f43e6b0": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16384: S3A: Avoid inconsistencies between DDB and S3.\n\nContributed by Steve Loughran\n\nContains\n\n- HADOOP-16397. Hadoop S3Guard Prune command to support a -tombstone option.\n- HADOOP-16406. ITestDynamoDBMetadataStore.testProvisionTable times out intermittently\n\nThis patch doesn\u0027t fix the underlying problem but it\n\n* changes some tests to clean up better\n* does a lot more in logging operations in against DDB, if enabled\n* adds an entry point to dump the state of the metastore and s3 tables (precursor to fsck)\n* adds a purge entry point to help clean up after a test run has got a store into a mess\n* s3guard prune command adds -tombstone option to only clear tombstones\n\nThe outcome is that tests should pass consistently and if problems occur we have better diagnostics.\n\nChange-Id: I3eca3f5529d7f6fec398c0ff0472919f08f054eb\n",
      "commitDate": "12/07/19 5:02 AM",
      "commitName": "b15ef7dc3d91c6d50fa515158104fba29f43e6b0",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "08/07/19 10:27 AM",
      "commitNameOld": "de6b7bc67ace7744adb0320ee7de79cf28259d2d",
      "commitAuthorOld": "Sean Mackrory",
      "daysBetweenCommits": 3.77,
      "commitsBetweenForRepo": 38,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,62 +1,63 @@\n   private Collection\u003cDDBPathMetadata\u003e completeAncestry(\n       final Collection\u003cDDBPathMetadata\u003e pathsToCreate,\n       final AncestorState ancestorState,\n       final ITtlTimeProvider ttlTimeProvider) throws PathIOException {\n-    List\u003cDDBPathMetadata\u003e ancestorsToAdd \u003d new ArrayList\u003c\u003e(0);\n+    // Key on path to allow fast lookup\n+    Map\u003cPath, DDBPathMetadata\u003e ancestry \u003d new HashMap\u003c\u003e();\n     LOG.debug(\"Completing ancestry for {} paths\", pathsToCreate.size());\n     // we sort the inputs to guarantee that the topmost entries come first.\n     // that way if the put request contains both parents and children\n     // then the existing parents will not be re-created -they will just\n     // be added to the ancestor list first.\n     List\u003cDDBPathMetadata\u003e sortedPaths \u003d new ArrayList\u003c\u003e(pathsToCreate);\n     sortedPaths.sort(PathOrderComparators.TOPMOST_PM_FIRST);\n     // iterate through the paths.\n     for (DDBPathMetadata meta : sortedPaths) {\n       Preconditions.checkArgument(meta !\u003d null);\n       Path path \u003d meta.getFileStatus().getPath();\n       LOG.debug(\"Adding entry {}\", path);\n       if (path.isRoot()) {\n         // this is a root entry: do not add it.\n         break;\n       }\n       // create the new entry\n       DDBPathMetadata entry \u003d new DDBPathMetadata(meta);\n       // add it to the ancestor state, failing if it is already there and\n       // of a different type.\n       DDBPathMetadata oldEntry \u003d ancestorState.put(path, entry);\n       if (oldEntry !\u003d null) {\n         if (!oldEntry.getFileStatus().isDirectory()\n             || !entry.getFileStatus().isDirectory()) {\n           // check for and warn if the existing bulk operation overwrote it.\n-          // this should never occur outside tests explicitly crating it\n+          // this should never occur outside tests explicitly creating it\n           LOG.warn(\"Overwriting a S3Guard file created in the operation: {}\",\n               oldEntry);\n           LOG.warn(\"With new entry: {}\", entry);\n           // restore the old state\n           ancestorState.put(path, oldEntry);\n           // then raise an exception\n           throw new PathIOException(path.toString(), E_INCONSISTENT_UPDATE);\n         } else {\n           // a directory is already present. Log and continue.\n           LOG.debug(\"Directory at {} being updated with value {}\",\n               path, entry);\n         }\n       }\n-      ancestorsToAdd.add(entry);\n+      ancestry.put(path, entry);\n       Path parent \u003d path.getParent();\n-      while (!parent.isRoot()) {\n+      while (!parent.isRoot() \u0026\u0026 !ancestry.containsKey(parent)) {\n         if (!ancestorState.findEntry(parent, true)) {\n           // don\u0027t add this entry, but carry on with the parents\n           LOG.debug(\"auto-create ancestor path {} for child path {}\",\n               parent, path);\n           final S3AFileStatus status \u003d makeDirStatus(parent, username);\n           DDBPathMetadata md \u003d new DDBPathMetadata(status, Tristate.FALSE,\n               false, false, ttlTimeProvider.getNow());\n           ancestorState.put(parent, md);\n-          ancestorsToAdd.add(md);\n+          ancestry.put(parent, md);\n         }\n         parent \u003d parent.getParent();\n       }\n     }\n-    return ancestorsToAdd;\n+    return ancestry.values();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Collection\u003cDDBPathMetadata\u003e completeAncestry(\n      final Collection\u003cDDBPathMetadata\u003e pathsToCreate,\n      final AncestorState ancestorState,\n      final ITtlTimeProvider ttlTimeProvider) throws PathIOException {\n    // Key on path to allow fast lookup\n    Map\u003cPath, DDBPathMetadata\u003e ancestry \u003d new HashMap\u003c\u003e();\n    LOG.debug(\"Completing ancestry for {} paths\", pathsToCreate.size());\n    // we sort the inputs to guarantee that the topmost entries come first.\n    // that way if the put request contains both parents and children\n    // then the existing parents will not be re-created -they will just\n    // be added to the ancestor list first.\n    List\u003cDDBPathMetadata\u003e sortedPaths \u003d new ArrayList\u003c\u003e(pathsToCreate);\n    sortedPaths.sort(PathOrderComparators.TOPMOST_PM_FIRST);\n    // iterate through the paths.\n    for (DDBPathMetadata meta : sortedPaths) {\n      Preconditions.checkArgument(meta !\u003d null);\n      Path path \u003d meta.getFileStatus().getPath();\n      LOG.debug(\"Adding entry {}\", path);\n      if (path.isRoot()) {\n        // this is a root entry: do not add it.\n        break;\n      }\n      // create the new entry\n      DDBPathMetadata entry \u003d new DDBPathMetadata(meta);\n      // add it to the ancestor state, failing if it is already there and\n      // of a different type.\n      DDBPathMetadata oldEntry \u003d ancestorState.put(path, entry);\n      if (oldEntry !\u003d null) {\n        if (!oldEntry.getFileStatus().isDirectory()\n            || !entry.getFileStatus().isDirectory()) {\n          // check for and warn if the existing bulk operation overwrote it.\n          // this should never occur outside tests explicitly creating it\n          LOG.warn(\"Overwriting a S3Guard file created in the operation: {}\",\n              oldEntry);\n          LOG.warn(\"With new entry: {}\", entry);\n          // restore the old state\n          ancestorState.put(path, oldEntry);\n          // then raise an exception\n          throw new PathIOException(path.toString(), E_INCONSISTENT_UPDATE);\n        } else {\n          // a directory is already present. Log and continue.\n          LOG.debug(\"Directory at {} being updated with value {}\",\n              path, entry);\n        }\n      }\n      ancestry.put(path, entry);\n      Path parent \u003d path.getParent();\n      while (!parent.isRoot() \u0026\u0026 !ancestry.containsKey(parent)) {\n        if (!ancestorState.findEntry(parent, true)) {\n          // don\u0027t add this entry, but carry on with the parents\n          LOG.debug(\"auto-create ancestor path {} for child path {}\",\n              parent, path);\n          final S3AFileStatus status \u003d makeDirStatus(parent, username);\n          DDBPathMetadata md \u003d new DDBPathMetadata(status, Tristate.FALSE,\n              false, false, ttlTimeProvider.getNow());\n          ancestorState.put(parent, md);\n          ancestry.put(parent, md);\n        }\n        parent \u003d parent.getParent();\n      }\n    }\n    return ancestry.values();\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
      "extendedDetails": {}
    },
    "e02eb24e0a9139418120027b694492e0738df20a": {
      "type": "Ymultichange(Yparameterchange,Ymodifierchange,Yexceptionschange,Ybodychange,Yparametermetachange)",
      "commitMessage": "HADOOP-15183. S3Guard store becomes inconsistent after partial failure of rename.\n\nContributed by Steve Loughran.\n\nChange-Id: I825b0bc36be960475d2d259b1cdab45ae1bb78eb\n",
      "commitDate": "20/06/19 1:56 AM",
      "commitName": "e02eb24e0a9139418120027b694492e0738df20a",
      "commitAuthor": "Steve Loughran",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-15183. S3Guard store becomes inconsistent after partial failure of rename.\n\nContributed by Steve Loughran.\n\nChange-Id: I825b0bc36be960475d2d259b1cdab45ae1bb78eb\n",
          "commitDate": "20/06/19 1:56 AM",
          "commitName": "e02eb24e0a9139418120027b694492e0738df20a",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "16/06/19 9:05 AM",
          "commitNameOld": "f9cc9e162175444efe9d5b07ecb9a795f750ca3c",
          "commitAuthorOld": "Gabor Bota",
          "daysBetweenCommits": 3.7,
          "commitsBetweenForRepo": 44,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,24 +1,62 @@\n-  Collection\u003cDDBPathMetadata\u003e completeAncestry(\n-      Collection\u003cDDBPathMetadata\u003e pathsToCreate) {\n-    // Key on path to allow fast lookup\n-    Map\u003cPath, DDBPathMetadata\u003e ancestry \u003d new HashMap\u003c\u003e();\n-\n-    for (DDBPathMetadata meta : pathsToCreate) {\n+  private Collection\u003cDDBPathMetadata\u003e completeAncestry(\n+      final Collection\u003cDDBPathMetadata\u003e pathsToCreate,\n+      final AncestorState ancestorState,\n+      final ITtlTimeProvider ttlTimeProvider) throws PathIOException {\n+    List\u003cDDBPathMetadata\u003e ancestorsToAdd \u003d new ArrayList\u003c\u003e(0);\n+    LOG.debug(\"Completing ancestry for {} paths\", pathsToCreate.size());\n+    // we sort the inputs to guarantee that the topmost entries come first.\n+    // that way if the put request contains both parents and children\n+    // then the existing parents will not be re-created -they will just\n+    // be added to the ancestor list first.\n+    List\u003cDDBPathMetadata\u003e sortedPaths \u003d new ArrayList\u003c\u003e(pathsToCreate);\n+    sortedPaths.sort(PathOrderComparators.TOPMOST_PM_FIRST);\n+    // iterate through the paths.\n+    for (DDBPathMetadata meta : sortedPaths) {\n       Preconditions.checkArgument(meta !\u003d null);\n       Path path \u003d meta.getFileStatus().getPath();\n+      LOG.debug(\"Adding entry {}\", path);\n       if (path.isRoot()) {\n+        // this is a root entry: do not add it.\n         break;\n       }\n-      ancestry.put(path, new DDBPathMetadata(meta));\n+      // create the new entry\n+      DDBPathMetadata entry \u003d new DDBPathMetadata(meta);\n+      // add it to the ancestor state, failing if it is already there and\n+      // of a different type.\n+      DDBPathMetadata oldEntry \u003d ancestorState.put(path, entry);\n+      if (oldEntry !\u003d null) {\n+        if (!oldEntry.getFileStatus().isDirectory()\n+            || !entry.getFileStatus().isDirectory()) {\n+          // check for and warn if the existing bulk operation overwrote it.\n+          // this should never occur outside tests explicitly crating it\n+          LOG.warn(\"Overwriting a S3Guard file created in the operation: {}\",\n+              oldEntry);\n+          LOG.warn(\"With new entry: {}\", entry);\n+          // restore the old state\n+          ancestorState.put(path, oldEntry);\n+          // then raise an exception\n+          throw new PathIOException(path.toString(), E_INCONSISTENT_UPDATE);\n+        } else {\n+          // a directory is already present. Log and continue.\n+          LOG.debug(\"Directory at {} being updated with value {}\",\n+              path, entry);\n+        }\n+      }\n+      ancestorsToAdd.add(entry);\n       Path parent \u003d path.getParent();\n-      while (!parent.isRoot() \u0026\u0026 !ancestry.containsKey(parent)) {\n-        LOG.debug(\"auto-create ancestor path {} for child path {}\",\n-            parent, path);\n-        final S3AFileStatus status \u003d makeDirStatus(parent, username);\n-        ancestry.put(parent, new DDBPathMetadata(status, Tristate.FALSE,\n-            false));\n+      while (!parent.isRoot()) {\n+        if (!ancestorState.findEntry(parent, true)) {\n+          // don\u0027t add this entry, but carry on with the parents\n+          LOG.debug(\"auto-create ancestor path {} for child path {}\",\n+              parent, path);\n+          final S3AFileStatus status \u003d makeDirStatus(parent, username);\n+          DDBPathMetadata md \u003d new DDBPathMetadata(status, Tristate.FALSE,\n+              false, false, ttlTimeProvider.getNow());\n+          ancestorState.put(parent, md);\n+          ancestorsToAdd.add(md);\n+        }\n         parent \u003d parent.getParent();\n       }\n     }\n-    return ancestry.values();\n+    return ancestorsToAdd;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private Collection\u003cDDBPathMetadata\u003e completeAncestry(\n      final Collection\u003cDDBPathMetadata\u003e pathsToCreate,\n      final AncestorState ancestorState,\n      final ITtlTimeProvider ttlTimeProvider) throws PathIOException {\n    List\u003cDDBPathMetadata\u003e ancestorsToAdd \u003d new ArrayList\u003c\u003e(0);\n    LOG.debug(\"Completing ancestry for {} paths\", pathsToCreate.size());\n    // we sort the inputs to guarantee that the topmost entries come first.\n    // that way if the put request contains both parents and children\n    // then the existing parents will not be re-created -they will just\n    // be added to the ancestor list first.\n    List\u003cDDBPathMetadata\u003e sortedPaths \u003d new ArrayList\u003c\u003e(pathsToCreate);\n    sortedPaths.sort(PathOrderComparators.TOPMOST_PM_FIRST);\n    // iterate through the paths.\n    for (DDBPathMetadata meta : sortedPaths) {\n      Preconditions.checkArgument(meta !\u003d null);\n      Path path \u003d meta.getFileStatus().getPath();\n      LOG.debug(\"Adding entry {}\", path);\n      if (path.isRoot()) {\n        // this is a root entry: do not add it.\n        break;\n      }\n      // create the new entry\n      DDBPathMetadata entry \u003d new DDBPathMetadata(meta);\n      // add it to the ancestor state, failing if it is already there and\n      // of a different type.\n      DDBPathMetadata oldEntry \u003d ancestorState.put(path, entry);\n      if (oldEntry !\u003d null) {\n        if (!oldEntry.getFileStatus().isDirectory()\n            || !entry.getFileStatus().isDirectory()) {\n          // check for and warn if the existing bulk operation overwrote it.\n          // this should never occur outside tests explicitly crating it\n          LOG.warn(\"Overwriting a S3Guard file created in the operation: {}\",\n              oldEntry);\n          LOG.warn(\"With new entry: {}\", entry);\n          // restore the old state\n          ancestorState.put(path, oldEntry);\n          // then raise an exception\n          throw new PathIOException(path.toString(), E_INCONSISTENT_UPDATE);\n        } else {\n          // a directory is already present. Log and continue.\n          LOG.debug(\"Directory at {} being updated with value {}\",\n              path, entry);\n        }\n      }\n      ancestorsToAdd.add(entry);\n      Path parent \u003d path.getParent();\n      while (!parent.isRoot()) {\n        if (!ancestorState.findEntry(parent, true)) {\n          // don\u0027t add this entry, but carry on with the parents\n          LOG.debug(\"auto-create ancestor path {} for child path {}\",\n              parent, path);\n          final S3AFileStatus status \u003d makeDirStatus(parent, username);\n          DDBPathMetadata md \u003d new DDBPathMetadata(status, Tristate.FALSE,\n              false, false, ttlTimeProvider.getNow());\n          ancestorState.put(parent, md);\n          ancestorsToAdd.add(md);\n        }\n        parent \u003d parent.getParent();\n      }\n    }\n    return ancestorsToAdd;\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
          "extendedDetails": {
            "oldValue": "[pathsToCreate-Collection\u003cDDBPathMetadata\u003e]",
            "newValue": "[pathsToCreate-Collection\u003cDDBPathMetadata\u003e(modifiers-final), ancestorState-AncestorState(modifiers-final), ttlTimeProvider-ITtlTimeProvider(modifiers-final)]"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "HADOOP-15183. S3Guard store becomes inconsistent after partial failure of rename.\n\nContributed by Steve Loughran.\n\nChange-Id: I825b0bc36be960475d2d259b1cdab45ae1bb78eb\n",
          "commitDate": "20/06/19 1:56 AM",
          "commitName": "e02eb24e0a9139418120027b694492e0738df20a",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "16/06/19 9:05 AM",
          "commitNameOld": "f9cc9e162175444efe9d5b07ecb9a795f750ca3c",
          "commitAuthorOld": "Gabor Bota",
          "daysBetweenCommits": 3.7,
          "commitsBetweenForRepo": 44,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,24 +1,62 @@\n-  Collection\u003cDDBPathMetadata\u003e completeAncestry(\n-      Collection\u003cDDBPathMetadata\u003e pathsToCreate) {\n-    // Key on path to allow fast lookup\n-    Map\u003cPath, DDBPathMetadata\u003e ancestry \u003d new HashMap\u003c\u003e();\n-\n-    for (DDBPathMetadata meta : pathsToCreate) {\n+  private Collection\u003cDDBPathMetadata\u003e completeAncestry(\n+      final Collection\u003cDDBPathMetadata\u003e pathsToCreate,\n+      final AncestorState ancestorState,\n+      final ITtlTimeProvider ttlTimeProvider) throws PathIOException {\n+    List\u003cDDBPathMetadata\u003e ancestorsToAdd \u003d new ArrayList\u003c\u003e(0);\n+    LOG.debug(\"Completing ancestry for {} paths\", pathsToCreate.size());\n+    // we sort the inputs to guarantee that the topmost entries come first.\n+    // that way if the put request contains both parents and children\n+    // then the existing parents will not be re-created -they will just\n+    // be added to the ancestor list first.\n+    List\u003cDDBPathMetadata\u003e sortedPaths \u003d new ArrayList\u003c\u003e(pathsToCreate);\n+    sortedPaths.sort(PathOrderComparators.TOPMOST_PM_FIRST);\n+    // iterate through the paths.\n+    for (DDBPathMetadata meta : sortedPaths) {\n       Preconditions.checkArgument(meta !\u003d null);\n       Path path \u003d meta.getFileStatus().getPath();\n+      LOG.debug(\"Adding entry {}\", path);\n       if (path.isRoot()) {\n+        // this is a root entry: do not add it.\n         break;\n       }\n-      ancestry.put(path, new DDBPathMetadata(meta));\n+      // create the new entry\n+      DDBPathMetadata entry \u003d new DDBPathMetadata(meta);\n+      // add it to the ancestor state, failing if it is already there and\n+      // of a different type.\n+      DDBPathMetadata oldEntry \u003d ancestorState.put(path, entry);\n+      if (oldEntry !\u003d null) {\n+        if (!oldEntry.getFileStatus().isDirectory()\n+            || !entry.getFileStatus().isDirectory()) {\n+          // check for and warn if the existing bulk operation overwrote it.\n+          // this should never occur outside tests explicitly crating it\n+          LOG.warn(\"Overwriting a S3Guard file created in the operation: {}\",\n+              oldEntry);\n+          LOG.warn(\"With new entry: {}\", entry);\n+          // restore the old state\n+          ancestorState.put(path, oldEntry);\n+          // then raise an exception\n+          throw new PathIOException(path.toString(), E_INCONSISTENT_UPDATE);\n+        } else {\n+          // a directory is already present. Log and continue.\n+          LOG.debug(\"Directory at {} being updated with value {}\",\n+              path, entry);\n+        }\n+      }\n+      ancestorsToAdd.add(entry);\n       Path parent \u003d path.getParent();\n-      while (!parent.isRoot() \u0026\u0026 !ancestry.containsKey(parent)) {\n-        LOG.debug(\"auto-create ancestor path {} for child path {}\",\n-            parent, path);\n-        final S3AFileStatus status \u003d makeDirStatus(parent, username);\n-        ancestry.put(parent, new DDBPathMetadata(status, Tristate.FALSE,\n-            false));\n+      while (!parent.isRoot()) {\n+        if (!ancestorState.findEntry(parent, true)) {\n+          // don\u0027t add this entry, but carry on with the parents\n+          LOG.debug(\"auto-create ancestor path {} for child path {}\",\n+              parent, path);\n+          final S3AFileStatus status \u003d makeDirStatus(parent, username);\n+          DDBPathMetadata md \u003d new DDBPathMetadata(status, Tristate.FALSE,\n+              false, false, ttlTimeProvider.getNow());\n+          ancestorState.put(parent, md);\n+          ancestorsToAdd.add(md);\n+        }\n         parent \u003d parent.getParent();\n       }\n     }\n-    return ancestry.values();\n+    return ancestorsToAdd;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private Collection\u003cDDBPathMetadata\u003e completeAncestry(\n      final Collection\u003cDDBPathMetadata\u003e pathsToCreate,\n      final AncestorState ancestorState,\n      final ITtlTimeProvider ttlTimeProvider) throws PathIOException {\n    List\u003cDDBPathMetadata\u003e ancestorsToAdd \u003d new ArrayList\u003c\u003e(0);\n    LOG.debug(\"Completing ancestry for {} paths\", pathsToCreate.size());\n    // we sort the inputs to guarantee that the topmost entries come first.\n    // that way if the put request contains both parents and children\n    // then the existing parents will not be re-created -they will just\n    // be added to the ancestor list first.\n    List\u003cDDBPathMetadata\u003e sortedPaths \u003d new ArrayList\u003c\u003e(pathsToCreate);\n    sortedPaths.sort(PathOrderComparators.TOPMOST_PM_FIRST);\n    // iterate through the paths.\n    for (DDBPathMetadata meta : sortedPaths) {\n      Preconditions.checkArgument(meta !\u003d null);\n      Path path \u003d meta.getFileStatus().getPath();\n      LOG.debug(\"Adding entry {}\", path);\n      if (path.isRoot()) {\n        // this is a root entry: do not add it.\n        break;\n      }\n      // create the new entry\n      DDBPathMetadata entry \u003d new DDBPathMetadata(meta);\n      // add it to the ancestor state, failing if it is already there and\n      // of a different type.\n      DDBPathMetadata oldEntry \u003d ancestorState.put(path, entry);\n      if (oldEntry !\u003d null) {\n        if (!oldEntry.getFileStatus().isDirectory()\n            || !entry.getFileStatus().isDirectory()) {\n          // check for and warn if the existing bulk operation overwrote it.\n          // this should never occur outside tests explicitly crating it\n          LOG.warn(\"Overwriting a S3Guard file created in the operation: {}\",\n              oldEntry);\n          LOG.warn(\"With new entry: {}\", entry);\n          // restore the old state\n          ancestorState.put(path, oldEntry);\n          // then raise an exception\n          throw new PathIOException(path.toString(), E_INCONSISTENT_UPDATE);\n        } else {\n          // a directory is already present. Log and continue.\n          LOG.debug(\"Directory at {} being updated with value {}\",\n              path, entry);\n        }\n      }\n      ancestorsToAdd.add(entry);\n      Path parent \u003d path.getParent();\n      while (!parent.isRoot()) {\n        if (!ancestorState.findEntry(parent, true)) {\n          // don\u0027t add this entry, but carry on with the parents\n          LOG.debug(\"auto-create ancestor path {} for child path {}\",\n              parent, path);\n          final S3AFileStatus status \u003d makeDirStatus(parent, username);\n          DDBPathMetadata md \u003d new DDBPathMetadata(status, Tristate.FALSE,\n              false, false, ttlTimeProvider.getNow());\n          ancestorState.put(parent, md);\n          ancestorsToAdd.add(md);\n        }\n        parent \u003d parent.getParent();\n      }\n    }\n    return ancestorsToAdd;\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[private]"
          }
        },
        {
          "type": "Yexceptionschange",
          "commitMessage": "HADOOP-15183. S3Guard store becomes inconsistent after partial failure of rename.\n\nContributed by Steve Loughran.\n\nChange-Id: I825b0bc36be960475d2d259b1cdab45ae1bb78eb\n",
          "commitDate": "20/06/19 1:56 AM",
          "commitName": "e02eb24e0a9139418120027b694492e0738df20a",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "16/06/19 9:05 AM",
          "commitNameOld": "f9cc9e162175444efe9d5b07ecb9a795f750ca3c",
          "commitAuthorOld": "Gabor Bota",
          "daysBetweenCommits": 3.7,
          "commitsBetweenForRepo": 44,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,24 +1,62 @@\n-  Collection\u003cDDBPathMetadata\u003e completeAncestry(\n-      Collection\u003cDDBPathMetadata\u003e pathsToCreate) {\n-    // Key on path to allow fast lookup\n-    Map\u003cPath, DDBPathMetadata\u003e ancestry \u003d new HashMap\u003c\u003e();\n-\n-    for (DDBPathMetadata meta : pathsToCreate) {\n+  private Collection\u003cDDBPathMetadata\u003e completeAncestry(\n+      final Collection\u003cDDBPathMetadata\u003e pathsToCreate,\n+      final AncestorState ancestorState,\n+      final ITtlTimeProvider ttlTimeProvider) throws PathIOException {\n+    List\u003cDDBPathMetadata\u003e ancestorsToAdd \u003d new ArrayList\u003c\u003e(0);\n+    LOG.debug(\"Completing ancestry for {} paths\", pathsToCreate.size());\n+    // we sort the inputs to guarantee that the topmost entries come first.\n+    // that way if the put request contains both parents and children\n+    // then the existing parents will not be re-created -they will just\n+    // be added to the ancestor list first.\n+    List\u003cDDBPathMetadata\u003e sortedPaths \u003d new ArrayList\u003c\u003e(pathsToCreate);\n+    sortedPaths.sort(PathOrderComparators.TOPMOST_PM_FIRST);\n+    // iterate through the paths.\n+    for (DDBPathMetadata meta : sortedPaths) {\n       Preconditions.checkArgument(meta !\u003d null);\n       Path path \u003d meta.getFileStatus().getPath();\n+      LOG.debug(\"Adding entry {}\", path);\n       if (path.isRoot()) {\n+        // this is a root entry: do not add it.\n         break;\n       }\n-      ancestry.put(path, new DDBPathMetadata(meta));\n+      // create the new entry\n+      DDBPathMetadata entry \u003d new DDBPathMetadata(meta);\n+      // add it to the ancestor state, failing if it is already there and\n+      // of a different type.\n+      DDBPathMetadata oldEntry \u003d ancestorState.put(path, entry);\n+      if (oldEntry !\u003d null) {\n+        if (!oldEntry.getFileStatus().isDirectory()\n+            || !entry.getFileStatus().isDirectory()) {\n+          // check for and warn if the existing bulk operation overwrote it.\n+          // this should never occur outside tests explicitly crating it\n+          LOG.warn(\"Overwriting a S3Guard file created in the operation: {}\",\n+              oldEntry);\n+          LOG.warn(\"With new entry: {}\", entry);\n+          // restore the old state\n+          ancestorState.put(path, oldEntry);\n+          // then raise an exception\n+          throw new PathIOException(path.toString(), E_INCONSISTENT_UPDATE);\n+        } else {\n+          // a directory is already present. Log and continue.\n+          LOG.debug(\"Directory at {} being updated with value {}\",\n+              path, entry);\n+        }\n+      }\n+      ancestorsToAdd.add(entry);\n       Path parent \u003d path.getParent();\n-      while (!parent.isRoot() \u0026\u0026 !ancestry.containsKey(parent)) {\n-        LOG.debug(\"auto-create ancestor path {} for child path {}\",\n-            parent, path);\n-        final S3AFileStatus status \u003d makeDirStatus(parent, username);\n-        ancestry.put(parent, new DDBPathMetadata(status, Tristate.FALSE,\n-            false));\n+      while (!parent.isRoot()) {\n+        if (!ancestorState.findEntry(parent, true)) {\n+          // don\u0027t add this entry, but carry on with the parents\n+          LOG.debug(\"auto-create ancestor path {} for child path {}\",\n+              parent, path);\n+          final S3AFileStatus status \u003d makeDirStatus(parent, username);\n+          DDBPathMetadata md \u003d new DDBPathMetadata(status, Tristate.FALSE,\n+              false, false, ttlTimeProvider.getNow());\n+          ancestorState.put(parent, md);\n+          ancestorsToAdd.add(md);\n+        }\n         parent \u003d parent.getParent();\n       }\n     }\n-    return ancestry.values();\n+    return ancestorsToAdd;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private Collection\u003cDDBPathMetadata\u003e completeAncestry(\n      final Collection\u003cDDBPathMetadata\u003e pathsToCreate,\n      final AncestorState ancestorState,\n      final ITtlTimeProvider ttlTimeProvider) throws PathIOException {\n    List\u003cDDBPathMetadata\u003e ancestorsToAdd \u003d new ArrayList\u003c\u003e(0);\n    LOG.debug(\"Completing ancestry for {} paths\", pathsToCreate.size());\n    // we sort the inputs to guarantee that the topmost entries come first.\n    // that way if the put request contains both parents and children\n    // then the existing parents will not be re-created -they will just\n    // be added to the ancestor list first.\n    List\u003cDDBPathMetadata\u003e sortedPaths \u003d new ArrayList\u003c\u003e(pathsToCreate);\n    sortedPaths.sort(PathOrderComparators.TOPMOST_PM_FIRST);\n    // iterate through the paths.\n    for (DDBPathMetadata meta : sortedPaths) {\n      Preconditions.checkArgument(meta !\u003d null);\n      Path path \u003d meta.getFileStatus().getPath();\n      LOG.debug(\"Adding entry {}\", path);\n      if (path.isRoot()) {\n        // this is a root entry: do not add it.\n        break;\n      }\n      // create the new entry\n      DDBPathMetadata entry \u003d new DDBPathMetadata(meta);\n      // add it to the ancestor state, failing if it is already there and\n      // of a different type.\n      DDBPathMetadata oldEntry \u003d ancestorState.put(path, entry);\n      if (oldEntry !\u003d null) {\n        if (!oldEntry.getFileStatus().isDirectory()\n            || !entry.getFileStatus().isDirectory()) {\n          // check for and warn if the existing bulk operation overwrote it.\n          // this should never occur outside tests explicitly crating it\n          LOG.warn(\"Overwriting a S3Guard file created in the operation: {}\",\n              oldEntry);\n          LOG.warn(\"With new entry: {}\", entry);\n          // restore the old state\n          ancestorState.put(path, oldEntry);\n          // then raise an exception\n          throw new PathIOException(path.toString(), E_INCONSISTENT_UPDATE);\n        } else {\n          // a directory is already present. Log and continue.\n          LOG.debug(\"Directory at {} being updated with value {}\",\n              path, entry);\n        }\n      }\n      ancestorsToAdd.add(entry);\n      Path parent \u003d path.getParent();\n      while (!parent.isRoot()) {\n        if (!ancestorState.findEntry(parent, true)) {\n          // don\u0027t add this entry, but carry on with the parents\n          LOG.debug(\"auto-create ancestor path {} for child path {}\",\n              parent, path);\n          final S3AFileStatus status \u003d makeDirStatus(parent, username);\n          DDBPathMetadata md \u003d new DDBPathMetadata(status, Tristate.FALSE,\n              false, false, ttlTimeProvider.getNow());\n          ancestorState.put(parent, md);\n          ancestorsToAdd.add(md);\n        }\n        parent \u003d parent.getParent();\n      }\n    }\n    return ancestorsToAdd;\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[PathIOException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-15183. S3Guard store becomes inconsistent after partial failure of rename.\n\nContributed by Steve Loughran.\n\nChange-Id: I825b0bc36be960475d2d259b1cdab45ae1bb78eb\n",
          "commitDate": "20/06/19 1:56 AM",
          "commitName": "e02eb24e0a9139418120027b694492e0738df20a",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "16/06/19 9:05 AM",
          "commitNameOld": "f9cc9e162175444efe9d5b07ecb9a795f750ca3c",
          "commitAuthorOld": "Gabor Bota",
          "daysBetweenCommits": 3.7,
          "commitsBetweenForRepo": 44,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,24 +1,62 @@\n-  Collection\u003cDDBPathMetadata\u003e completeAncestry(\n-      Collection\u003cDDBPathMetadata\u003e pathsToCreate) {\n-    // Key on path to allow fast lookup\n-    Map\u003cPath, DDBPathMetadata\u003e ancestry \u003d new HashMap\u003c\u003e();\n-\n-    for (DDBPathMetadata meta : pathsToCreate) {\n+  private Collection\u003cDDBPathMetadata\u003e completeAncestry(\n+      final Collection\u003cDDBPathMetadata\u003e pathsToCreate,\n+      final AncestorState ancestorState,\n+      final ITtlTimeProvider ttlTimeProvider) throws PathIOException {\n+    List\u003cDDBPathMetadata\u003e ancestorsToAdd \u003d new ArrayList\u003c\u003e(0);\n+    LOG.debug(\"Completing ancestry for {} paths\", pathsToCreate.size());\n+    // we sort the inputs to guarantee that the topmost entries come first.\n+    // that way if the put request contains both parents and children\n+    // then the existing parents will not be re-created -they will just\n+    // be added to the ancestor list first.\n+    List\u003cDDBPathMetadata\u003e sortedPaths \u003d new ArrayList\u003c\u003e(pathsToCreate);\n+    sortedPaths.sort(PathOrderComparators.TOPMOST_PM_FIRST);\n+    // iterate through the paths.\n+    for (DDBPathMetadata meta : sortedPaths) {\n       Preconditions.checkArgument(meta !\u003d null);\n       Path path \u003d meta.getFileStatus().getPath();\n+      LOG.debug(\"Adding entry {}\", path);\n       if (path.isRoot()) {\n+        // this is a root entry: do not add it.\n         break;\n       }\n-      ancestry.put(path, new DDBPathMetadata(meta));\n+      // create the new entry\n+      DDBPathMetadata entry \u003d new DDBPathMetadata(meta);\n+      // add it to the ancestor state, failing if it is already there and\n+      // of a different type.\n+      DDBPathMetadata oldEntry \u003d ancestorState.put(path, entry);\n+      if (oldEntry !\u003d null) {\n+        if (!oldEntry.getFileStatus().isDirectory()\n+            || !entry.getFileStatus().isDirectory()) {\n+          // check for and warn if the existing bulk operation overwrote it.\n+          // this should never occur outside tests explicitly crating it\n+          LOG.warn(\"Overwriting a S3Guard file created in the operation: {}\",\n+              oldEntry);\n+          LOG.warn(\"With new entry: {}\", entry);\n+          // restore the old state\n+          ancestorState.put(path, oldEntry);\n+          // then raise an exception\n+          throw new PathIOException(path.toString(), E_INCONSISTENT_UPDATE);\n+        } else {\n+          // a directory is already present. Log and continue.\n+          LOG.debug(\"Directory at {} being updated with value {}\",\n+              path, entry);\n+        }\n+      }\n+      ancestorsToAdd.add(entry);\n       Path parent \u003d path.getParent();\n-      while (!parent.isRoot() \u0026\u0026 !ancestry.containsKey(parent)) {\n-        LOG.debug(\"auto-create ancestor path {} for child path {}\",\n-            parent, path);\n-        final S3AFileStatus status \u003d makeDirStatus(parent, username);\n-        ancestry.put(parent, new DDBPathMetadata(status, Tristate.FALSE,\n-            false));\n+      while (!parent.isRoot()) {\n+        if (!ancestorState.findEntry(parent, true)) {\n+          // don\u0027t add this entry, but carry on with the parents\n+          LOG.debug(\"auto-create ancestor path {} for child path {}\",\n+              parent, path);\n+          final S3AFileStatus status \u003d makeDirStatus(parent, username);\n+          DDBPathMetadata md \u003d new DDBPathMetadata(status, Tristate.FALSE,\n+              false, false, ttlTimeProvider.getNow());\n+          ancestorState.put(parent, md);\n+          ancestorsToAdd.add(md);\n+        }\n         parent \u003d parent.getParent();\n       }\n     }\n-    return ancestry.values();\n+    return ancestorsToAdd;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private Collection\u003cDDBPathMetadata\u003e completeAncestry(\n      final Collection\u003cDDBPathMetadata\u003e pathsToCreate,\n      final AncestorState ancestorState,\n      final ITtlTimeProvider ttlTimeProvider) throws PathIOException {\n    List\u003cDDBPathMetadata\u003e ancestorsToAdd \u003d new ArrayList\u003c\u003e(0);\n    LOG.debug(\"Completing ancestry for {} paths\", pathsToCreate.size());\n    // we sort the inputs to guarantee that the topmost entries come first.\n    // that way if the put request contains both parents and children\n    // then the existing parents will not be re-created -they will just\n    // be added to the ancestor list first.\n    List\u003cDDBPathMetadata\u003e sortedPaths \u003d new ArrayList\u003c\u003e(pathsToCreate);\n    sortedPaths.sort(PathOrderComparators.TOPMOST_PM_FIRST);\n    // iterate through the paths.\n    for (DDBPathMetadata meta : sortedPaths) {\n      Preconditions.checkArgument(meta !\u003d null);\n      Path path \u003d meta.getFileStatus().getPath();\n      LOG.debug(\"Adding entry {}\", path);\n      if (path.isRoot()) {\n        // this is a root entry: do not add it.\n        break;\n      }\n      // create the new entry\n      DDBPathMetadata entry \u003d new DDBPathMetadata(meta);\n      // add it to the ancestor state, failing if it is already there and\n      // of a different type.\n      DDBPathMetadata oldEntry \u003d ancestorState.put(path, entry);\n      if (oldEntry !\u003d null) {\n        if (!oldEntry.getFileStatus().isDirectory()\n            || !entry.getFileStatus().isDirectory()) {\n          // check for and warn if the existing bulk operation overwrote it.\n          // this should never occur outside tests explicitly crating it\n          LOG.warn(\"Overwriting a S3Guard file created in the operation: {}\",\n              oldEntry);\n          LOG.warn(\"With new entry: {}\", entry);\n          // restore the old state\n          ancestorState.put(path, oldEntry);\n          // then raise an exception\n          throw new PathIOException(path.toString(), E_INCONSISTENT_UPDATE);\n        } else {\n          // a directory is already present. Log and continue.\n          LOG.debug(\"Directory at {} being updated with value {}\",\n              path, entry);\n        }\n      }\n      ancestorsToAdd.add(entry);\n      Path parent \u003d path.getParent();\n      while (!parent.isRoot()) {\n        if (!ancestorState.findEntry(parent, true)) {\n          // don\u0027t add this entry, but carry on with the parents\n          LOG.debug(\"auto-create ancestor path {} for child path {}\",\n              parent, path);\n          final S3AFileStatus status \u003d makeDirStatus(parent, username);\n          DDBPathMetadata md \u003d new DDBPathMetadata(status, Tristate.FALSE,\n              false, false, ttlTimeProvider.getNow());\n          ancestorState.put(parent, md);\n          ancestorsToAdd.add(md);\n        }\n        parent \u003d parent.getParent();\n      }\n    }\n    return ancestorsToAdd;\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
          "extendedDetails": {}
        },
        {
          "type": "Yparametermetachange",
          "commitMessage": "HADOOP-15183. S3Guard store becomes inconsistent after partial failure of rename.\n\nContributed by Steve Loughran.\n\nChange-Id: I825b0bc36be960475d2d259b1cdab45ae1bb78eb\n",
          "commitDate": "20/06/19 1:56 AM",
          "commitName": "e02eb24e0a9139418120027b694492e0738df20a",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "16/06/19 9:05 AM",
          "commitNameOld": "f9cc9e162175444efe9d5b07ecb9a795f750ca3c",
          "commitAuthorOld": "Gabor Bota",
          "daysBetweenCommits": 3.7,
          "commitsBetweenForRepo": 44,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,24 +1,62 @@\n-  Collection\u003cDDBPathMetadata\u003e completeAncestry(\n-      Collection\u003cDDBPathMetadata\u003e pathsToCreate) {\n-    // Key on path to allow fast lookup\n-    Map\u003cPath, DDBPathMetadata\u003e ancestry \u003d new HashMap\u003c\u003e();\n-\n-    for (DDBPathMetadata meta : pathsToCreate) {\n+  private Collection\u003cDDBPathMetadata\u003e completeAncestry(\n+      final Collection\u003cDDBPathMetadata\u003e pathsToCreate,\n+      final AncestorState ancestorState,\n+      final ITtlTimeProvider ttlTimeProvider) throws PathIOException {\n+    List\u003cDDBPathMetadata\u003e ancestorsToAdd \u003d new ArrayList\u003c\u003e(0);\n+    LOG.debug(\"Completing ancestry for {} paths\", pathsToCreate.size());\n+    // we sort the inputs to guarantee that the topmost entries come first.\n+    // that way if the put request contains both parents and children\n+    // then the existing parents will not be re-created -they will just\n+    // be added to the ancestor list first.\n+    List\u003cDDBPathMetadata\u003e sortedPaths \u003d new ArrayList\u003c\u003e(pathsToCreate);\n+    sortedPaths.sort(PathOrderComparators.TOPMOST_PM_FIRST);\n+    // iterate through the paths.\n+    for (DDBPathMetadata meta : sortedPaths) {\n       Preconditions.checkArgument(meta !\u003d null);\n       Path path \u003d meta.getFileStatus().getPath();\n+      LOG.debug(\"Adding entry {}\", path);\n       if (path.isRoot()) {\n+        // this is a root entry: do not add it.\n         break;\n       }\n-      ancestry.put(path, new DDBPathMetadata(meta));\n+      // create the new entry\n+      DDBPathMetadata entry \u003d new DDBPathMetadata(meta);\n+      // add it to the ancestor state, failing if it is already there and\n+      // of a different type.\n+      DDBPathMetadata oldEntry \u003d ancestorState.put(path, entry);\n+      if (oldEntry !\u003d null) {\n+        if (!oldEntry.getFileStatus().isDirectory()\n+            || !entry.getFileStatus().isDirectory()) {\n+          // check for and warn if the existing bulk operation overwrote it.\n+          // this should never occur outside tests explicitly crating it\n+          LOG.warn(\"Overwriting a S3Guard file created in the operation: {}\",\n+              oldEntry);\n+          LOG.warn(\"With new entry: {}\", entry);\n+          // restore the old state\n+          ancestorState.put(path, oldEntry);\n+          // then raise an exception\n+          throw new PathIOException(path.toString(), E_INCONSISTENT_UPDATE);\n+        } else {\n+          // a directory is already present. Log and continue.\n+          LOG.debug(\"Directory at {} being updated with value {}\",\n+              path, entry);\n+        }\n+      }\n+      ancestorsToAdd.add(entry);\n       Path parent \u003d path.getParent();\n-      while (!parent.isRoot() \u0026\u0026 !ancestry.containsKey(parent)) {\n-        LOG.debug(\"auto-create ancestor path {} for child path {}\",\n-            parent, path);\n-        final S3AFileStatus status \u003d makeDirStatus(parent, username);\n-        ancestry.put(parent, new DDBPathMetadata(status, Tristate.FALSE,\n-            false));\n+      while (!parent.isRoot()) {\n+        if (!ancestorState.findEntry(parent, true)) {\n+          // don\u0027t add this entry, but carry on with the parents\n+          LOG.debug(\"auto-create ancestor path {} for child path {}\",\n+              parent, path);\n+          final S3AFileStatus status \u003d makeDirStatus(parent, username);\n+          DDBPathMetadata md \u003d new DDBPathMetadata(status, Tristate.FALSE,\n+              false, false, ttlTimeProvider.getNow());\n+          ancestorState.put(parent, md);\n+          ancestorsToAdd.add(md);\n+        }\n         parent \u003d parent.getParent();\n       }\n     }\n-    return ancestry.values();\n+    return ancestorsToAdd;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private Collection\u003cDDBPathMetadata\u003e completeAncestry(\n      final Collection\u003cDDBPathMetadata\u003e pathsToCreate,\n      final AncestorState ancestorState,\n      final ITtlTimeProvider ttlTimeProvider) throws PathIOException {\n    List\u003cDDBPathMetadata\u003e ancestorsToAdd \u003d new ArrayList\u003c\u003e(0);\n    LOG.debug(\"Completing ancestry for {} paths\", pathsToCreate.size());\n    // we sort the inputs to guarantee that the topmost entries come first.\n    // that way if the put request contains both parents and children\n    // then the existing parents will not be re-created -they will just\n    // be added to the ancestor list first.\n    List\u003cDDBPathMetadata\u003e sortedPaths \u003d new ArrayList\u003c\u003e(pathsToCreate);\n    sortedPaths.sort(PathOrderComparators.TOPMOST_PM_FIRST);\n    // iterate through the paths.\n    for (DDBPathMetadata meta : sortedPaths) {\n      Preconditions.checkArgument(meta !\u003d null);\n      Path path \u003d meta.getFileStatus().getPath();\n      LOG.debug(\"Adding entry {}\", path);\n      if (path.isRoot()) {\n        // this is a root entry: do not add it.\n        break;\n      }\n      // create the new entry\n      DDBPathMetadata entry \u003d new DDBPathMetadata(meta);\n      // add it to the ancestor state, failing if it is already there and\n      // of a different type.\n      DDBPathMetadata oldEntry \u003d ancestorState.put(path, entry);\n      if (oldEntry !\u003d null) {\n        if (!oldEntry.getFileStatus().isDirectory()\n            || !entry.getFileStatus().isDirectory()) {\n          // check for and warn if the existing bulk operation overwrote it.\n          // this should never occur outside tests explicitly crating it\n          LOG.warn(\"Overwriting a S3Guard file created in the operation: {}\",\n              oldEntry);\n          LOG.warn(\"With new entry: {}\", entry);\n          // restore the old state\n          ancestorState.put(path, oldEntry);\n          // then raise an exception\n          throw new PathIOException(path.toString(), E_INCONSISTENT_UPDATE);\n        } else {\n          // a directory is already present. Log and continue.\n          LOG.debug(\"Directory at {} being updated with value {}\",\n              path, entry);\n        }\n      }\n      ancestorsToAdd.add(entry);\n      Path parent \u003d path.getParent();\n      while (!parent.isRoot()) {\n        if (!ancestorState.findEntry(parent, true)) {\n          // don\u0027t add this entry, but carry on with the parents\n          LOG.debug(\"auto-create ancestor path {} for child path {}\",\n              parent, path);\n          final S3AFileStatus status \u003d makeDirStatus(parent, username);\n          DDBPathMetadata md \u003d new DDBPathMetadata(status, Tristate.FALSE,\n              false, false, ttlTimeProvider.getNow());\n          ancestorState.put(parent, md);\n          ancestorsToAdd.add(md);\n        }\n        parent \u003d parent.getParent();\n      }\n    }\n    return ancestorsToAdd;\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
          "extendedDetails": {
            "oldValue": "[pathsToCreate-Collection\u003cDDBPathMetadata\u003e]",
            "newValue": "[pathsToCreate-Collection\u003cDDBPathMetadata\u003e(modifiers-final), ancestorState-AncestorState(modifiers-final), ttlTimeProvider-ITtlTimeProvider(modifiers-final)]"
          }
        }
      ]
    },
    "a36274d69947648dbe82721220cc5240ec5d396d": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16085. S3Guard: use object version or etags to protect against inconsistent read after replace/overwrite.\n\nContributed by Ben Roling.\n\nS3Guard will now track the etag of uploaded files and, if an S3\nbucket is versioned, the object version.\n\nYou can then control how to react to a mismatch between the data\nin the DynamoDB table and that in the store: warn, fail, or, when\nusing versions, return the original value.\n\nThis adds two new columns to the table: etag and version.\nThis is transparent to older S3A clients -but when such clients\nadd/update data to the S3Guard table, they will not add these values.\nAs a result, the etag/version checks will not work with files uploaded by older clients.\n\nFor a consistent experience, upgrade all clients to use the latest hadoop version.\n",
      "commitDate": "19/05/19 2:29 PM",
      "commitName": "a36274d69947648dbe82721220cc5240ec5d396d",
      "commitAuthor": "Ben Roling",
      "commitDateOld": "11/04/19 5:12 PM",
      "commitNameOld": "cf4efcab3b66271745b7be5db30fdc5ae656d06c",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 37.89,
      "commitsBetweenForRepo": 188,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,24 +1,24 @@\n   Collection\u003cDDBPathMetadata\u003e completeAncestry(\n       Collection\u003cDDBPathMetadata\u003e pathsToCreate) {\n     // Key on path to allow fast lookup\n     Map\u003cPath, DDBPathMetadata\u003e ancestry \u003d new HashMap\u003c\u003e();\n \n     for (DDBPathMetadata meta : pathsToCreate) {\n       Preconditions.checkArgument(meta !\u003d null);\n       Path path \u003d meta.getFileStatus().getPath();\n       if (path.isRoot()) {\n         break;\n       }\n       ancestry.put(path, new DDBPathMetadata(meta));\n       Path parent \u003d path.getParent();\n       while (!parent.isRoot() \u0026\u0026 !ancestry.containsKey(parent)) {\n         LOG.debug(\"auto-create ancestor path {} for child path {}\",\n             parent, path);\n-        final FileStatus status \u003d makeDirStatus(parent, username);\n+        final S3AFileStatus status \u003d makeDirStatus(parent, username);\n         ancestry.put(parent, new DDBPathMetadata(status, Tristate.FALSE,\n             false));\n         parent \u003d parent.getParent();\n       }\n     }\n     return ancestry.values();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  Collection\u003cDDBPathMetadata\u003e completeAncestry(\n      Collection\u003cDDBPathMetadata\u003e pathsToCreate) {\n    // Key on path to allow fast lookup\n    Map\u003cPath, DDBPathMetadata\u003e ancestry \u003d new HashMap\u003c\u003e();\n\n    for (DDBPathMetadata meta : pathsToCreate) {\n      Preconditions.checkArgument(meta !\u003d null);\n      Path path \u003d meta.getFileStatus().getPath();\n      if (path.isRoot()) {\n        break;\n      }\n      ancestry.put(path, new DDBPathMetadata(meta));\n      Path parent \u003d path.getParent();\n      while (!parent.isRoot() \u0026\u0026 !ancestry.containsKey(parent)) {\n        LOG.debug(\"auto-create ancestor path {} for child path {}\",\n            parent, path);\n        final S3AFileStatus status \u003d makeDirStatus(parent, username);\n        ancestry.put(parent, new DDBPathMetadata(status, Tristate.FALSE,\n            false));\n        parent \u003d parent.getParent();\n      }\n    }\n    return ancestry.values();\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
      "extendedDetails": {}
    },
    "d7232857d8d1e10cdac171acdc931187e45fd6be": {
      "type": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
      "commitMessage": "HADOOP-14154 Persist isAuthoritative bit in DynamoDBMetaStore (Contributed by Gabor Bota)\n",
      "commitDate": "17/08/18 10:15 AM",
      "commitName": "d7232857d8d1e10cdac171acdc931187e45fd6be",
      "commitAuthor": "Aaron Fabbri",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-14154 Persist isAuthoritative bit in DynamoDBMetaStore (Contributed by Gabor Bota)\n",
          "commitDate": "17/08/18 10:15 AM",
          "commitName": "d7232857d8d1e10cdac171acdc931187e45fd6be",
          "commitAuthor": "Aaron Fabbri",
          "commitDateOld": "08/08/18 10:57 PM",
          "commitNameOld": "da9a39eed138210de29b59b90c449b28da1c04f9",
          "commitAuthorOld": "Steve Loughran",
          "daysBetweenCommits": 8.47,
          "commitsBetweenForRepo": 126,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,23 +1,24 @@\n-  Collection\u003cPathMetadata\u003e completeAncestry(\n-      Collection\u003cPathMetadata\u003e pathsToCreate) {\n+  Collection\u003cDDBPathMetadata\u003e completeAncestry(\n+      Collection\u003cDDBPathMetadata\u003e pathsToCreate) {\n     // Key on path to allow fast lookup\n-    Map\u003cPath, PathMetadata\u003e ancestry \u003d new HashMap\u003c\u003e();\n+    Map\u003cPath, DDBPathMetadata\u003e ancestry \u003d new HashMap\u003c\u003e();\n \n-    for (PathMetadata meta : pathsToCreate) {\n+    for (DDBPathMetadata meta : pathsToCreate) {\n       Preconditions.checkArgument(meta !\u003d null);\n       Path path \u003d meta.getFileStatus().getPath();\n       if (path.isRoot()) {\n         break;\n       }\n-      ancestry.put(path, meta);\n+      ancestry.put(path, new DDBPathMetadata(meta));\n       Path parent \u003d path.getParent();\n       while (!parent.isRoot() \u0026\u0026 !ancestry.containsKey(parent)) {\n         LOG.debug(\"auto-create ancestor path {} for child path {}\",\n             parent, path);\n         final FileStatus status \u003d makeDirStatus(parent, username);\n-        ancestry.put(parent, new PathMetadata(status, Tristate.FALSE, false));\n+        ancestry.put(parent, new DDBPathMetadata(status, Tristate.FALSE,\n+            false));\n         parent \u003d parent.getParent();\n       }\n     }\n     return ancestry.values();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  Collection\u003cDDBPathMetadata\u003e completeAncestry(\n      Collection\u003cDDBPathMetadata\u003e pathsToCreate) {\n    // Key on path to allow fast lookup\n    Map\u003cPath, DDBPathMetadata\u003e ancestry \u003d new HashMap\u003c\u003e();\n\n    for (DDBPathMetadata meta : pathsToCreate) {\n      Preconditions.checkArgument(meta !\u003d null);\n      Path path \u003d meta.getFileStatus().getPath();\n      if (path.isRoot()) {\n        break;\n      }\n      ancestry.put(path, new DDBPathMetadata(meta));\n      Path parent \u003d path.getParent();\n      while (!parent.isRoot() \u0026\u0026 !ancestry.containsKey(parent)) {\n        LOG.debug(\"auto-create ancestor path {} for child path {}\",\n            parent, path);\n        final FileStatus status \u003d makeDirStatus(parent, username);\n        ancestry.put(parent, new DDBPathMetadata(status, Tristate.FALSE,\n            false));\n        parent \u003d parent.getParent();\n      }\n    }\n    return ancestry.values();\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
          "extendedDetails": {
            "oldValue": "[pathsToCreate-Collection\u003cPathMetadata\u003e]",
            "newValue": "[pathsToCreate-Collection\u003cDDBPathMetadata\u003e]"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "HADOOP-14154 Persist isAuthoritative bit in DynamoDBMetaStore (Contributed by Gabor Bota)\n",
          "commitDate": "17/08/18 10:15 AM",
          "commitName": "d7232857d8d1e10cdac171acdc931187e45fd6be",
          "commitAuthor": "Aaron Fabbri",
          "commitDateOld": "08/08/18 10:57 PM",
          "commitNameOld": "da9a39eed138210de29b59b90c449b28da1c04f9",
          "commitAuthorOld": "Steve Loughran",
          "daysBetweenCommits": 8.47,
          "commitsBetweenForRepo": 126,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,23 +1,24 @@\n-  Collection\u003cPathMetadata\u003e completeAncestry(\n-      Collection\u003cPathMetadata\u003e pathsToCreate) {\n+  Collection\u003cDDBPathMetadata\u003e completeAncestry(\n+      Collection\u003cDDBPathMetadata\u003e pathsToCreate) {\n     // Key on path to allow fast lookup\n-    Map\u003cPath, PathMetadata\u003e ancestry \u003d new HashMap\u003c\u003e();\n+    Map\u003cPath, DDBPathMetadata\u003e ancestry \u003d new HashMap\u003c\u003e();\n \n-    for (PathMetadata meta : pathsToCreate) {\n+    for (DDBPathMetadata meta : pathsToCreate) {\n       Preconditions.checkArgument(meta !\u003d null);\n       Path path \u003d meta.getFileStatus().getPath();\n       if (path.isRoot()) {\n         break;\n       }\n-      ancestry.put(path, meta);\n+      ancestry.put(path, new DDBPathMetadata(meta));\n       Path parent \u003d path.getParent();\n       while (!parent.isRoot() \u0026\u0026 !ancestry.containsKey(parent)) {\n         LOG.debug(\"auto-create ancestor path {} for child path {}\",\n             parent, path);\n         final FileStatus status \u003d makeDirStatus(parent, username);\n-        ancestry.put(parent, new PathMetadata(status, Tristate.FALSE, false));\n+        ancestry.put(parent, new DDBPathMetadata(status, Tristate.FALSE,\n+            false));\n         parent \u003d parent.getParent();\n       }\n     }\n     return ancestry.values();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  Collection\u003cDDBPathMetadata\u003e completeAncestry(\n      Collection\u003cDDBPathMetadata\u003e pathsToCreate) {\n    // Key on path to allow fast lookup\n    Map\u003cPath, DDBPathMetadata\u003e ancestry \u003d new HashMap\u003c\u003e();\n\n    for (DDBPathMetadata meta : pathsToCreate) {\n      Preconditions.checkArgument(meta !\u003d null);\n      Path path \u003d meta.getFileStatus().getPath();\n      if (path.isRoot()) {\n        break;\n      }\n      ancestry.put(path, new DDBPathMetadata(meta));\n      Path parent \u003d path.getParent();\n      while (!parent.isRoot() \u0026\u0026 !ancestry.containsKey(parent)) {\n        LOG.debug(\"auto-create ancestor path {} for child path {}\",\n            parent, path);\n        final FileStatus status \u003d makeDirStatus(parent, username);\n        ancestry.put(parent, new DDBPathMetadata(status, Tristate.FALSE,\n            false));\n        parent \u003d parent.getParent();\n      }\n    }\n    return ancestry.values();\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
          "extendedDetails": {
            "oldValue": "Collection\u003cPathMetadata\u003e",
            "newValue": "Collection\u003cDDBPathMetadata\u003e"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-14154 Persist isAuthoritative bit in DynamoDBMetaStore (Contributed by Gabor Bota)\n",
          "commitDate": "17/08/18 10:15 AM",
          "commitName": "d7232857d8d1e10cdac171acdc931187e45fd6be",
          "commitAuthor": "Aaron Fabbri",
          "commitDateOld": "08/08/18 10:57 PM",
          "commitNameOld": "da9a39eed138210de29b59b90c449b28da1c04f9",
          "commitAuthorOld": "Steve Loughran",
          "daysBetweenCommits": 8.47,
          "commitsBetweenForRepo": 126,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,23 +1,24 @@\n-  Collection\u003cPathMetadata\u003e completeAncestry(\n-      Collection\u003cPathMetadata\u003e pathsToCreate) {\n+  Collection\u003cDDBPathMetadata\u003e completeAncestry(\n+      Collection\u003cDDBPathMetadata\u003e pathsToCreate) {\n     // Key on path to allow fast lookup\n-    Map\u003cPath, PathMetadata\u003e ancestry \u003d new HashMap\u003c\u003e();\n+    Map\u003cPath, DDBPathMetadata\u003e ancestry \u003d new HashMap\u003c\u003e();\n \n-    for (PathMetadata meta : pathsToCreate) {\n+    for (DDBPathMetadata meta : pathsToCreate) {\n       Preconditions.checkArgument(meta !\u003d null);\n       Path path \u003d meta.getFileStatus().getPath();\n       if (path.isRoot()) {\n         break;\n       }\n-      ancestry.put(path, meta);\n+      ancestry.put(path, new DDBPathMetadata(meta));\n       Path parent \u003d path.getParent();\n       while (!parent.isRoot() \u0026\u0026 !ancestry.containsKey(parent)) {\n         LOG.debug(\"auto-create ancestor path {} for child path {}\",\n             parent, path);\n         final FileStatus status \u003d makeDirStatus(parent, username);\n-        ancestry.put(parent, new PathMetadata(status, Tristate.FALSE, false));\n+        ancestry.put(parent, new DDBPathMetadata(status, Tristate.FALSE,\n+            false));\n         parent \u003d parent.getParent();\n       }\n     }\n     return ancestry.values();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  Collection\u003cDDBPathMetadata\u003e completeAncestry(\n      Collection\u003cDDBPathMetadata\u003e pathsToCreate) {\n    // Key on path to allow fast lookup\n    Map\u003cPath, DDBPathMetadata\u003e ancestry \u003d new HashMap\u003c\u003e();\n\n    for (DDBPathMetadata meta : pathsToCreate) {\n      Preconditions.checkArgument(meta !\u003d null);\n      Path path \u003d meta.getFileStatus().getPath();\n      if (path.isRoot()) {\n        break;\n      }\n      ancestry.put(path, new DDBPathMetadata(meta));\n      Path parent \u003d path.getParent();\n      while (!parent.isRoot() \u0026\u0026 !ancestry.containsKey(parent)) {\n        LOG.debug(\"auto-create ancestor path {} for child path {}\",\n            parent, path);\n        final FileStatus status \u003d makeDirStatus(parent, username);\n        ancestry.put(parent, new DDBPathMetadata(status, Tristate.FALSE,\n            false));\n        parent \u003d parent.getParent();\n      }\n    }\n    return ancestry.values();\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
          "extendedDetails": {}
        }
      ]
    },
    "621b43e254afaff708cd6fc4698b29628f6abc33": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-13345 HS3Guard: Improved Consistency for S3A.\nContributed by: Chris Nauroth, Aaron Fabbri, Mingliang Liu, Lei (Eddy) Xu,\nSean Mackrory, Steve Loughran and others.\n",
      "commitDate": "01/09/17 6:13 AM",
      "commitName": "621b43e254afaff708cd6fc4698b29628f6abc33",
      "commitAuthor": "Steve Loughran",
      "diff": "@@ -0,0 +1,23 @@\n+  Collection\u003cPathMetadata\u003e completeAncestry(\n+      Collection\u003cPathMetadata\u003e pathsToCreate) {\n+    // Key on path to allow fast lookup\n+    Map\u003cPath, PathMetadata\u003e ancestry \u003d new HashMap\u003c\u003e();\n+\n+    for (PathMetadata meta : pathsToCreate) {\n+      Preconditions.checkArgument(meta !\u003d null);\n+      Path path \u003d meta.getFileStatus().getPath();\n+      if (path.isRoot()) {\n+        break;\n+      }\n+      ancestry.put(path, meta);\n+      Path parent \u003d path.getParent();\n+      while (!parent.isRoot() \u0026\u0026 !ancestry.containsKey(parent)) {\n+        LOG.debug(\"auto-create ancestor path {} for child path {}\",\n+            parent, path);\n+        final FileStatus status \u003d makeDirStatus(parent, username);\n+        ancestry.put(parent, new PathMetadata(status, Tristate.FALSE, false));\n+        parent \u003d parent.getParent();\n+      }\n+    }\n+    return ancestry.values();\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  Collection\u003cPathMetadata\u003e completeAncestry(\n      Collection\u003cPathMetadata\u003e pathsToCreate) {\n    // Key on path to allow fast lookup\n    Map\u003cPath, PathMetadata\u003e ancestry \u003d new HashMap\u003c\u003e();\n\n    for (PathMetadata meta : pathsToCreate) {\n      Preconditions.checkArgument(meta !\u003d null);\n      Path path \u003d meta.getFileStatus().getPath();\n      if (path.isRoot()) {\n        break;\n      }\n      ancestry.put(path, meta);\n      Path parent \u003d path.getParent();\n      while (!parent.isRoot() \u0026\u0026 !ancestry.containsKey(parent)) {\n        LOG.debug(\"auto-create ancestor path {} for child path {}\",\n            parent, path);\n        final FileStatus status \u003d makeDirStatus(parent, username);\n        ancestry.put(parent, new PathMetadata(status, Tristate.FALSE, false));\n        parent \u003d parent.getParent();\n      }\n    }\n    return ancestry.values();\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java"
    }
  }
}