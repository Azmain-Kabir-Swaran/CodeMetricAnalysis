{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "UserGroupInformation.java",
  "functionName": "spawnAutoRenewalThreadForUserCreds",
  "functionId": "spawnAutoRenewalThreadForUserCreds___force-boolean",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/UserGroupInformation.java",
  "functionStartLine": 863,
  "functionEndLine": 877,
  "numCommitsSeen": 104,
  "timeTaken": 1899,
  "changeHistory": [
    "bfb9adc2b9e6e97f1036bcf8ea4cee6893a782b2",
    "77721f39e26b630352a1f4087524a3fbd21ff06e",
    "bff3d7b0cf073ccc061db30af6d52fa4a9f21c05"
  ],
  "changeHistoryShort": {
    "bfb9adc2b9e6e97f1036bcf8ea4cee6893a782b2": "Ybodychange",
    "77721f39e26b630352a1f4087524a3fbd21ff06e": "Ybodychange",
    "bff3d7b0cf073ccc061db30af6d52fa4a9f21c05": "Ybodychange"
  },
  "changeHistoryDetails": {
    "bfb9adc2b9e6e97f1036bcf8ea4cee6893a782b2": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9567. Provide auto-renewal for keytab based logins. Contributed by Hrishikesh Gadre, Gary Helmling  and Harsh J.\n\nSigned-off-by: Wei-Chiu Chuang \u003cweichiu@apache.org\u003e\n",
      "commitDate": "27/10/18 8:59 AM",
      "commitName": "bfb9adc2b9e6e97f1036bcf8ea4cee6893a782b2",
      "commitAuthor": "Hrishikesh Gadre",
      "commitDateOld": "11/10/18 3:35 PM",
      "commitNameOld": "d91d47bc739f23ca22a7e44fc83d449db57ab130",
      "commitAuthorOld": "Robert Kanter",
      "daysBetweenCommits": 15.73,
      "commitsBetweenForRepo": 180,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,18 +1,15 @@\n   void spawnAutoRenewalThreadForUserCreds(boolean force) {\n     if (!force \u0026\u0026 (!shouldRelogin() || isFromKeytab())) {\n       return;\n     }\n \n     //spawn thread only if we have kerb credentials\n     KerberosTicket tgt \u003d getTGT();\n     if (tgt \u003d\u003d null) {\n       return;\n     }\n     String cmd \u003d conf.get(\"hadoop.kerberos.kinit.command\", \"kinit\");\n     long nextRefresh \u003d getRefreshTime(tgt);\n-    Thread t \u003d\n-        new Thread(new AutoRenewalForUserCredsRunnable(tgt, cmd, nextRefresh));\n-    t.setDaemon(true);\n-    t.setName(\"TGT Renewer for \" + getUserName());\n-    t.start();\n+    executeAutoRenewalTask(getUserName(),\n+            new TicketCacheRenewalRunnable(tgt, cmd, nextRefresh));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void spawnAutoRenewalThreadForUserCreds(boolean force) {\n    if (!force \u0026\u0026 (!shouldRelogin() || isFromKeytab())) {\n      return;\n    }\n\n    //spawn thread only if we have kerb credentials\n    KerberosTicket tgt \u003d getTGT();\n    if (tgt \u003d\u003d null) {\n      return;\n    }\n    String cmd \u003d conf.get(\"hadoop.kerberos.kinit.command\", \"kinit\");\n    long nextRefresh \u003d getRefreshTime(tgt);\n    executeAutoRenewalTask(getUserName(),\n            new TicketCacheRenewalRunnable(tgt, cmd, nextRefresh));\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/UserGroupInformation.java",
      "extendedDetails": {}
    },
    "77721f39e26b630352a1f4087524a3fbd21ff06e": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15593.  Fixed NPE in UGI spawnAutoRenewalThreadForUserCreds.\n               Contributed by Gabor Bota\n",
      "commitDate": "26/07/18 3:35 PM",
      "commitName": "77721f39e26b630352a1f4087524a3fbd21ff06e",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "20/06/18 3:58 PM",
      "commitNameOld": "32f867a6a907c05a312657139d295a92756d98ef",
      "commitAuthorOld": "Xiao Chen",
      "daysBetweenCommits": 35.98,
      "commitsBetweenForRepo": 217,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,82 +1,18 @@\n   void spawnAutoRenewalThreadForUserCreds(boolean force) {\n     if (!force \u0026\u0026 (!shouldRelogin() || isFromKeytab())) {\n       return;\n     }\n \n     //spawn thread only if we have kerb credentials\n-    Thread t \u003d new Thread(new Runnable() {\n-\n-      @Override\n-      public void run() {\n-        String cmd \u003d conf.get(\"hadoop.kerberos.kinit.command\", \"kinit\");\n-        KerberosTicket tgt \u003d getTGT();\n-        if (tgt \u003d\u003d null) {\n-          return;\n-        }\n-        long nextRefresh \u003d getRefreshTime(tgt);\n-        RetryPolicy rp \u003d null;\n-        while (true) {\n-          try {\n-            long now \u003d Time.now();\n-            if (LOG.isDebugEnabled()) {\n-              LOG.debug(\"Current time is \" + now);\n-              LOG.debug(\"Next refresh is \" + nextRefresh);\n-            }\n-            if (now \u003c nextRefresh) {\n-              Thread.sleep(nextRefresh - now);\n-            }\n-            String output \u003d Shell.execCommand(cmd, \"-R\");\n-            if (LOG.isDebugEnabled()) {\n-              LOG.debug(\"Renewed ticket. kinit output: {}\", output);\n-            }\n-            reloginFromTicketCache();\n-            tgt \u003d getTGT();\n-            if (tgt \u003d\u003d null) {\n-              LOG.warn(\"No TGT after renewal. Aborting renew thread for \" +\n-                  getUserName());\n-              return;\n-            }\n-            nextRefresh \u003d Math.max(getRefreshTime(tgt),\n-              now + kerberosMinSecondsBeforeRelogin);\n-            metrics.renewalFailures.set(0);\n-            rp \u003d null;\n-          } catch (InterruptedException ie) {\n-            LOG.warn(\"Terminating renewal thread\");\n-            return;\n-          } catch (IOException ie) {\n-            metrics.renewalFailuresTotal.incr();\n-            final long tgtEndTime \u003d tgt.getEndTime().getTime();\n-            LOG.warn(\"Exception encountered while running the renewal \"\n-                    + \"command for {}. (TGT end time:{}, renewalFailures: {},\"\n-                    + \"renewalFailuresTotal: {})\", getUserName(), tgtEndTime,\n-                metrics.renewalFailures, metrics.renewalFailuresTotal, ie);\n-            final long now \u003d Time.now();\n-            if (rp \u003d\u003d null) {\n-              // Use a dummy maxRetries to create the policy. The policy will\n-              // only be used to get next retry time with exponential back-off.\n-              // The final retry time will be later limited within the\n-              // tgt endTime in getNextTgtRenewalTime.\n-              rp \u003d RetryPolicies.exponentialBackoffRetry(Long.SIZE - 2,\n-                  kerberosMinSecondsBeforeRelogin, TimeUnit.MILLISECONDS);\n-            }\n-            try {\n-              nextRefresh \u003d getNextTgtRenewalTime(tgtEndTime, now, rp);\n-            } catch (Exception e) {\n-              LOG.error(\"Exception when calculating next tgt renewal time\", e);\n-              return;\n-            }\n-            metrics.renewalFailures.incr();\n-            // retry until close enough to tgt endTime.\n-            if (now \u003e nextRefresh) {\n-              LOG.error(\"TGT is expired. Aborting renew thread for {}.\",\n-                  getUserName());\n-              return;\n-            }\n-          }\n-        }\n-      }\n-    });\n+    KerberosTicket tgt \u003d getTGT();\n+    if (tgt \u003d\u003d null) {\n+      return;\n+    }\n+    String cmd \u003d conf.get(\"hadoop.kerberos.kinit.command\", \"kinit\");\n+    long nextRefresh \u003d getRefreshTime(tgt);\n+    Thread t \u003d\n+        new Thread(new AutoRenewalForUserCredsRunnable(tgt, cmd, nextRefresh));\n     t.setDaemon(true);\n     t.setName(\"TGT Renewer for \" + getUserName());\n     t.start();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void spawnAutoRenewalThreadForUserCreds(boolean force) {\n    if (!force \u0026\u0026 (!shouldRelogin() || isFromKeytab())) {\n      return;\n    }\n\n    //spawn thread only if we have kerb credentials\n    KerberosTicket tgt \u003d getTGT();\n    if (tgt \u003d\u003d null) {\n      return;\n    }\n    String cmd \u003d conf.get(\"hadoop.kerberos.kinit.command\", \"kinit\");\n    long nextRefresh \u003d getRefreshTime(tgt);\n    Thread t \u003d\n        new Thread(new AutoRenewalForUserCredsRunnable(tgt, cmd, nextRefresh));\n    t.setDaemon(true);\n    t.setName(\"TGT Renewer for \" + getUserName());\n    t.start();\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/UserGroupInformation.java",
      "extendedDetails": {}
    },
    "bff3d7b0cf073ccc061db30af6d52fa4a9f21c05": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15382. Log kinit output in credential renewal thread. Contributed by Gabor Bota.\n",
      "commitDate": "27/04/18 10:05 AM",
      "commitName": "bff3d7b0cf073ccc061db30af6d52fa4a9f21c05",
      "commitAuthor": "Wei-Chiu Chuang",
      "commitDateOld": "26/04/18 1:54 PM",
      "commitNameOld": "bbc8dfcb8b5acd92aa3a2d945a1d51403cdde874",
      "commitAuthorOld": "Daryn Sharp",
      "daysBetweenCommits": 0.84,
      "commitsBetweenForRepo": 21,
      "commitsBetweenForFile": 0,
      "diff": "@@ -1,82 +1,82 @@\n   void spawnAutoRenewalThreadForUserCreds(boolean force) {\n     if (!force \u0026\u0026 (!shouldRelogin() || isFromKeytab())) {\n       return;\n     }\n \n     //spawn thread only if we have kerb credentials\n     Thread t \u003d new Thread(new Runnable() {\n \n       @Override\n       public void run() {\n         String cmd \u003d conf.get(\"hadoop.kerberos.kinit.command\", \"kinit\");\n         KerberosTicket tgt \u003d getTGT();\n         if (tgt \u003d\u003d null) {\n           return;\n         }\n         long nextRefresh \u003d getRefreshTime(tgt);\n         RetryPolicy rp \u003d null;\n         while (true) {\n           try {\n             long now \u003d Time.now();\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"Current time is \" + now);\n               LOG.debug(\"Next refresh is \" + nextRefresh);\n             }\n             if (now \u003c nextRefresh) {\n               Thread.sleep(nextRefresh - now);\n             }\n-            Shell.execCommand(cmd, \"-R\");\n+            String output \u003d Shell.execCommand(cmd, \"-R\");\n             if (LOG.isDebugEnabled()) {\n-              LOG.debug(\"renewed ticket\");\n+              LOG.debug(\"Renewed ticket. kinit output: {}\", output);\n             }\n             reloginFromTicketCache();\n             tgt \u003d getTGT();\n             if (tgt \u003d\u003d null) {\n               LOG.warn(\"No TGT after renewal. Aborting renew thread for \" +\n                   getUserName());\n               return;\n             }\n             nextRefresh \u003d Math.max(getRefreshTime(tgt),\n               now + kerberosMinSecondsBeforeRelogin);\n             metrics.renewalFailures.set(0);\n             rp \u003d null;\n           } catch (InterruptedException ie) {\n             LOG.warn(\"Terminating renewal thread\");\n             return;\n           } catch (IOException ie) {\n             metrics.renewalFailuresTotal.incr();\n             final long tgtEndTime \u003d tgt.getEndTime().getTime();\n             LOG.warn(\"Exception encountered while running the renewal \"\n                     + \"command for {}. (TGT end time:{}, renewalFailures: {},\"\n                     + \"renewalFailuresTotal: {})\", getUserName(), tgtEndTime,\n                 metrics.renewalFailures, metrics.renewalFailuresTotal, ie);\n             final long now \u003d Time.now();\n             if (rp \u003d\u003d null) {\n               // Use a dummy maxRetries to create the policy. The policy will\n               // only be used to get next retry time with exponential back-off.\n               // The final retry time will be later limited within the\n               // tgt endTime in getNextTgtRenewalTime.\n               rp \u003d RetryPolicies.exponentialBackoffRetry(Long.SIZE - 2,\n                   kerberosMinSecondsBeforeRelogin, TimeUnit.MILLISECONDS);\n             }\n             try {\n               nextRefresh \u003d getNextTgtRenewalTime(tgtEndTime, now, rp);\n             } catch (Exception e) {\n               LOG.error(\"Exception when calculating next tgt renewal time\", e);\n               return;\n             }\n             metrics.renewalFailures.incr();\n             // retry until close enough to tgt endTime.\n             if (now \u003e nextRefresh) {\n               LOG.error(\"TGT is expired. Aborting renew thread for {}.\",\n                   getUserName());\n               return;\n             }\n           }\n         }\n       }\n     });\n     t.setDaemon(true);\n     t.setName(\"TGT Renewer for \" + getUserName());\n     t.start();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void spawnAutoRenewalThreadForUserCreds(boolean force) {\n    if (!force \u0026\u0026 (!shouldRelogin() || isFromKeytab())) {\n      return;\n    }\n\n    //spawn thread only if we have kerb credentials\n    Thread t \u003d new Thread(new Runnable() {\n\n      @Override\n      public void run() {\n        String cmd \u003d conf.get(\"hadoop.kerberos.kinit.command\", \"kinit\");\n        KerberosTicket tgt \u003d getTGT();\n        if (tgt \u003d\u003d null) {\n          return;\n        }\n        long nextRefresh \u003d getRefreshTime(tgt);\n        RetryPolicy rp \u003d null;\n        while (true) {\n          try {\n            long now \u003d Time.now();\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Current time is \" + now);\n              LOG.debug(\"Next refresh is \" + nextRefresh);\n            }\n            if (now \u003c nextRefresh) {\n              Thread.sleep(nextRefresh - now);\n            }\n            String output \u003d Shell.execCommand(cmd, \"-R\");\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Renewed ticket. kinit output: {}\", output);\n            }\n            reloginFromTicketCache();\n            tgt \u003d getTGT();\n            if (tgt \u003d\u003d null) {\n              LOG.warn(\"No TGT after renewal. Aborting renew thread for \" +\n                  getUserName());\n              return;\n            }\n            nextRefresh \u003d Math.max(getRefreshTime(tgt),\n              now + kerberosMinSecondsBeforeRelogin);\n            metrics.renewalFailures.set(0);\n            rp \u003d null;\n          } catch (InterruptedException ie) {\n            LOG.warn(\"Terminating renewal thread\");\n            return;\n          } catch (IOException ie) {\n            metrics.renewalFailuresTotal.incr();\n            final long tgtEndTime \u003d tgt.getEndTime().getTime();\n            LOG.warn(\"Exception encountered while running the renewal \"\n                    + \"command for {}. (TGT end time:{}, renewalFailures: {},\"\n                    + \"renewalFailuresTotal: {})\", getUserName(), tgtEndTime,\n                metrics.renewalFailures, metrics.renewalFailuresTotal, ie);\n            final long now \u003d Time.now();\n            if (rp \u003d\u003d null) {\n              // Use a dummy maxRetries to create the policy. The policy will\n              // only be used to get next retry time with exponential back-off.\n              // The final retry time will be later limited within the\n              // tgt endTime in getNextTgtRenewalTime.\n              rp \u003d RetryPolicies.exponentialBackoffRetry(Long.SIZE - 2,\n                  kerberosMinSecondsBeforeRelogin, TimeUnit.MILLISECONDS);\n            }\n            try {\n              nextRefresh \u003d getNextTgtRenewalTime(tgtEndTime, now, rp);\n            } catch (Exception e) {\n              LOG.error(\"Exception when calculating next tgt renewal time\", e);\n              return;\n            }\n            metrics.renewalFailures.incr();\n            // retry until close enough to tgt endTime.\n            if (now \u003e nextRefresh) {\n              LOG.error(\"TGT is expired. Aborting renew thread for {}.\",\n                  getUserName());\n              return;\n            }\n          }\n        }\n      }\n    });\n    t.setDaemon(true);\n    t.setName(\"TGT Renewer for \" + getUserName());\n    t.start();\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/UserGroupInformation.java",
      "extendedDetails": {}
    }
  }
}