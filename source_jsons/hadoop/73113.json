{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "CryptoInputStream.java",
  "functionName": "decrypt",
  "functionId": "decrypt___position-long__buffer-byte[]__offset-int__length-int",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/crypto/CryptoInputStream.java",
  "functionStartLine": 391,
  "functionEndLine": 421,
  "numCommitsSeen": 19,
  "timeTaken": 1616,
  "changeHistory": [
    "4877f0aa518832c37a06e6d3bd2c9552fc3141dc",
    "9c2848e076a5c72bda3ec928de1790137c70fbbc",
    "2e5ae1aad74575cd35f47bd5f0f789d7056ef77d",
    "b20180ffa6c89396d9fcfec8b029b9c600503c3d"
  ],
  "changeHistoryShort": {
    "4877f0aa518832c37a06e6d3bd2c9552fc3141dc": "Ybodychange",
    "9c2848e076a5c72bda3ec928de1790137c70fbbc": "Ybodychange",
    "2e5ae1aad74575cd35f47bd5f0f789d7056ef77d": "Ybodychange",
    "b20180ffa6c89396d9fcfec8b029b9c600503c3d": "Yintroduced"
  },
  "changeHistoryDetails": {
    "4877f0aa518832c37a06e6d3bd2c9552fc3141dc": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3246: pRead equivalent for direct read path (#597)\n\nHDFS-3246: pRead equivalent for direct read path\r\n\r\nContributed by Sahil Takiar",
      "commitDate": "30/04/19 2:52 PM",
      "commitName": "4877f0aa518832c37a06e6d3bd2c9552fc3141dc",
      "commitAuthor": "Sahil Takiar",
      "commitDateOld": "06/03/19 3:04 PM",
      "commitNameOld": "618e009ac0ab14b24c0c19153778173ee3142292",
      "commitAuthorOld": "Sahil Takiar",
      "daysBetweenCommits": 54.95,
      "commitsBetweenForRepo": 370,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,31 @@\n   private void decrypt(long position, byte[] buffer, int offset, int length) \n       throws IOException {\n-    ByteBuffer inBuffer \u003d getBuffer();\n-    ByteBuffer outBuffer \u003d getBuffer();\n+    ByteBuffer localInBuffer \u003d null;\n+    ByteBuffer localOutBuffer \u003d null;\n     Decryptor decryptor \u003d null;\n     try {\n+      localInBuffer \u003d getBuffer();\n+      localOutBuffer \u003d getBuffer();\n       decryptor \u003d getDecryptor();\n       byte[] iv \u003d initIV.clone();\n       updateDecryptor(decryptor, position, iv);\n       byte padding \u003d getPadding(position);\n-      inBuffer.position(padding); // Set proper position for input data.\n+      localInBuffer.position(padding); // Set proper position for input data.\n       \n       int n \u003d 0;\n       while (n \u003c length) {\n-        int toDecrypt \u003d Math.min(length - n, inBuffer.remaining());\n-        inBuffer.put(buffer, offset + n, toDecrypt);\n+        int toDecrypt \u003d Math.min(length - n, localInBuffer.remaining());\n+        localInBuffer.put(buffer, offset + n, toDecrypt);\n         // Do decryption\n-        decrypt(decryptor, inBuffer, outBuffer, padding);\n+        decrypt(decryptor, localInBuffer, localOutBuffer, padding);\n         \n-        outBuffer.get(buffer, offset + n, toDecrypt);\n+        localOutBuffer.get(buffer, offset + n, toDecrypt);\n         n +\u003d toDecrypt;\n-        padding \u003d afterDecryption(decryptor, inBuffer, position + n, iv);\n+        padding \u003d afterDecryption(decryptor, localInBuffer, position + n, iv);\n       }\n     } finally {\n-      returnBuffer(inBuffer);\n-      returnBuffer(outBuffer);\n+      returnBuffer(localInBuffer);\n+      returnBuffer(localOutBuffer);\n       returnDecryptor(decryptor);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void decrypt(long position, byte[] buffer, int offset, int length) \n      throws IOException {\n    ByteBuffer localInBuffer \u003d null;\n    ByteBuffer localOutBuffer \u003d null;\n    Decryptor decryptor \u003d null;\n    try {\n      localInBuffer \u003d getBuffer();\n      localOutBuffer \u003d getBuffer();\n      decryptor \u003d getDecryptor();\n      byte[] iv \u003d initIV.clone();\n      updateDecryptor(decryptor, position, iv);\n      byte padding \u003d getPadding(position);\n      localInBuffer.position(padding); // Set proper position for input data.\n      \n      int n \u003d 0;\n      while (n \u003c length) {\n        int toDecrypt \u003d Math.min(length - n, localInBuffer.remaining());\n        localInBuffer.put(buffer, offset + n, toDecrypt);\n        // Do decryption\n        decrypt(decryptor, localInBuffer, localOutBuffer, padding);\n        \n        localOutBuffer.get(buffer, offset + n, toDecrypt);\n        n +\u003d toDecrypt;\n        padding \u003d afterDecryption(decryptor, localInBuffer, position + n, iv);\n      }\n    } finally {\n      returnBuffer(localInBuffer);\n      returnBuffer(localOutBuffer);\n      returnDecryptor(decryptor);\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/crypto/CryptoInputStream.java",
      "extendedDetails": {}
    },
    "9c2848e076a5c72bda3ec928de1790137c70fbbc": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10632. Minor improvements to Crypto input and output streams. Contributed by Yi Liu\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/fs-encryption@1598485 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/05/14 1:08 AM",
      "commitName": "9c2848e076a5c72bda3ec928de1790137c70fbbc",
      "commitAuthor": "Yi Liu",
      "commitDateOld": "29/05/14 3:09 PM",
      "commitNameOld": "2e5ae1aad74575cd35f47bd5f0f789d7056ef77d",
      "commitAuthorOld": "Charles Lamb",
      "daysBetweenCommits": 0.42,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,28 +1,29 @@\n   private void decrypt(long position, byte[] buffer, int offset, int length) \n       throws IOException {\n-    final byte[] tmp \u003d getTmpBuf();\n-    int unread \u003d outBuffer.remaining();\n-    if (unread \u003e 0) { // Cache outBuffer\n-      outBuffer.get(tmp, 0, unread);\n-    }\n-    final long curOffset \u003d streamOffset;\n-    resetStreamOffset(position);\n-    \n-    int n \u003d 0;\n-    while (n \u003c length) {\n-      final int toDecrypt \u003d Math.min(length - n, inBuffer.remaining());\n-      inBuffer.put(buffer, offset + n, toDecrypt);\n-      // Do decryption\n-      decrypt();\n-      outBuffer.get(buffer, offset + n, toDecrypt);\n-      n +\u003d toDecrypt;\n-    }\n-    \n-    // After decryption\n-    resetStreamOffset(curOffset);\n-    if (unread \u003e 0) { // Restore outBuffer\n-      outBuffer.clear();\n-      outBuffer.put(tmp, 0, unread);\n-      outBuffer.flip();\n+    ByteBuffer inBuffer \u003d getBuffer();\n+    ByteBuffer outBuffer \u003d getBuffer();\n+    Decryptor decryptor \u003d null;\n+    try {\n+      decryptor \u003d getDecryptor();\n+      byte[] iv \u003d initIV.clone();\n+      updateDecryptor(decryptor, position, iv);\n+      byte padding \u003d getPadding(position);\n+      inBuffer.position(padding); // Set proper position for input data.\n+      \n+      int n \u003d 0;\n+      while (n \u003c length) {\n+        int toDecrypt \u003d Math.min(length - n, inBuffer.remaining());\n+        inBuffer.put(buffer, offset + n, toDecrypt);\n+        // Do decryption\n+        decrypt(decryptor, inBuffer, outBuffer, padding);\n+        \n+        outBuffer.get(buffer, offset + n, toDecrypt);\n+        n +\u003d toDecrypt;\n+        padding \u003d afterDecryption(decryptor, inBuffer, position + n, iv);\n+      }\n+    } finally {\n+      returnBuffer(inBuffer);\n+      returnBuffer(outBuffer);\n+      returnDecryptor(decryptor);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void decrypt(long position, byte[] buffer, int offset, int length) \n      throws IOException {\n    ByteBuffer inBuffer \u003d getBuffer();\n    ByteBuffer outBuffer \u003d getBuffer();\n    Decryptor decryptor \u003d null;\n    try {\n      decryptor \u003d getDecryptor();\n      byte[] iv \u003d initIV.clone();\n      updateDecryptor(decryptor, position, iv);\n      byte padding \u003d getPadding(position);\n      inBuffer.position(padding); // Set proper position for input data.\n      \n      int n \u003d 0;\n      while (n \u003c length) {\n        int toDecrypt \u003d Math.min(length - n, inBuffer.remaining());\n        inBuffer.put(buffer, offset + n, toDecrypt);\n        // Do decryption\n        decrypt(decryptor, inBuffer, outBuffer, padding);\n        \n        outBuffer.get(buffer, offset + n, toDecrypt);\n        n +\u003d toDecrypt;\n        padding \u003d afterDecryption(decryptor, inBuffer, position + n, iv);\n      }\n    } finally {\n      returnBuffer(inBuffer);\n      returnBuffer(outBuffer);\n      returnDecryptor(decryptor);\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/crypto/CryptoInputStream.java",
      "extendedDetails": {}
    },
    "2e5ae1aad74575cd35f47bd5f0f789d7056ef77d": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10628. Javadoc and few code style improvement for Crypto input and output streams. (yliu via clamb)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/fs-encryption@1598429 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/05/14 3:09 PM",
      "commitName": "2e5ae1aad74575cd35f47bd5f0f789d7056ef77d",
      "commitAuthor": "Charles Lamb",
      "commitDateOld": "23/05/14 6:19 PM",
      "commitNameOld": "b20180ffa6c89396d9fcfec8b029b9c600503c3d",
      "commitAuthorOld": "Yi Liu",
      "daysBetweenCommits": 5.87,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,28 @@\n   private void decrypt(long position, byte[] buffer, int offset, int length) \n       throws IOException {\n-    \n-    byte[] tmp \u003d getTmpBuf();\n+    final byte[] tmp \u003d getTmpBuf();\n     int unread \u003d outBuffer.remaining();\n     if (unread \u003e 0) { // Cache outBuffer\n       outBuffer.get(tmp, 0, unread);\n     }\n-    long curOffset \u003d streamOffset;\n+    final long curOffset \u003d streamOffset;\n     resetStreamOffset(position);\n     \n     int n \u003d 0;\n     while (n \u003c length) {\n-      int toDecrypt \u003d Math.min(length - n, inBuffer.remaining());\n+      final int toDecrypt \u003d Math.min(length - n, inBuffer.remaining());\n       inBuffer.put(buffer, offset + n, toDecrypt);\n       // Do decryption\n       decrypt();\n       outBuffer.get(buffer, offset + n, toDecrypt);\n       n +\u003d toDecrypt;\n     }\n     \n     // After decryption\n     resetStreamOffset(curOffset);\n     if (unread \u003e 0) { // Restore outBuffer\n       outBuffer.clear();\n       outBuffer.put(tmp, 0, unread);\n       outBuffer.flip();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void decrypt(long position, byte[] buffer, int offset, int length) \n      throws IOException {\n    final byte[] tmp \u003d getTmpBuf();\n    int unread \u003d outBuffer.remaining();\n    if (unread \u003e 0) { // Cache outBuffer\n      outBuffer.get(tmp, 0, unread);\n    }\n    final long curOffset \u003d streamOffset;\n    resetStreamOffset(position);\n    \n    int n \u003d 0;\n    while (n \u003c length) {\n      final int toDecrypt \u003d Math.min(length - n, inBuffer.remaining());\n      inBuffer.put(buffer, offset + n, toDecrypt);\n      // Do decryption\n      decrypt();\n      outBuffer.get(buffer, offset + n, toDecrypt);\n      n +\u003d toDecrypt;\n    }\n    \n    // After decryption\n    resetStreamOffset(curOffset);\n    if (unread \u003e 0) { // Restore outBuffer\n      outBuffer.clear();\n      outBuffer.put(tmp, 0, unread);\n      outBuffer.flip();\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/crypto/CryptoInputStream.java",
      "extendedDetails": {}
    },
    "b20180ffa6c89396d9fcfec8b029b9c600503c3d": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-10603. Crypto input and output streams implementing Hadoop stream interfaces. Contributed by Yi Liu and Charles Lamb.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/fs-encryption@1597230 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/05/14 6:19 PM",
      "commitName": "b20180ffa6c89396d9fcfec8b029b9c600503c3d",
      "commitAuthor": "Yi Liu",
      "diff": "@@ -0,0 +1,29 @@\n+  private void decrypt(long position, byte[] buffer, int offset, int length) \n+      throws IOException {\n+    \n+    byte[] tmp \u003d getTmpBuf();\n+    int unread \u003d outBuffer.remaining();\n+    if (unread \u003e 0) { // Cache outBuffer\n+      outBuffer.get(tmp, 0, unread);\n+    }\n+    long curOffset \u003d streamOffset;\n+    resetStreamOffset(position);\n+    \n+    int n \u003d 0;\n+    while (n \u003c length) {\n+      int toDecrypt \u003d Math.min(length - n, inBuffer.remaining());\n+      inBuffer.put(buffer, offset + n, toDecrypt);\n+      // Do decryption\n+      decrypt();\n+      outBuffer.get(buffer, offset + n, toDecrypt);\n+      n +\u003d toDecrypt;\n+    }\n+    \n+    // After decryption\n+    resetStreamOffset(curOffset);\n+    if (unread \u003e 0) { // Restore outBuffer\n+      outBuffer.clear();\n+      outBuffer.put(tmp, 0, unread);\n+      outBuffer.flip();\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void decrypt(long position, byte[] buffer, int offset, int length) \n      throws IOException {\n    \n    byte[] tmp \u003d getTmpBuf();\n    int unread \u003d outBuffer.remaining();\n    if (unread \u003e 0) { // Cache outBuffer\n      outBuffer.get(tmp, 0, unread);\n    }\n    long curOffset \u003d streamOffset;\n    resetStreamOffset(position);\n    \n    int n \u003d 0;\n    while (n \u003c length) {\n      int toDecrypt \u003d Math.min(length - n, inBuffer.remaining());\n      inBuffer.put(buffer, offset + n, toDecrypt);\n      // Do decryption\n      decrypt();\n      outBuffer.get(buffer, offset + n, toDecrypt);\n      n +\u003d toDecrypt;\n    }\n    \n    // After decryption\n    resetStreamOffset(curOffset);\n    if (unread \u003e 0) { // Restore outBuffer\n      outBuffer.clear();\n      outBuffer.put(tmp, 0, unread);\n      outBuffer.flip();\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/crypto/CryptoInputStream.java"
    }
  }
}