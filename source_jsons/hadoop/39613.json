{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "LeafQueue.java",
  "functionName": "setupQueueConfigs",
  "functionId": "setupQueueConfigs___clusterResource-Resource",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
  "functionStartLine": 157,
  "functionEndLine": 160,
  "numCommitsSeen": 634,
  "timeTaken": 23511,
  "changeHistory": [
    "b38643c9a8dd2c53024ae830b9565a550d0ec39c",
    "56d93d2e39ead89bb79c4f4096554820dc77e84b",
    "ca13b224b2feb9c44de861da9cbba8dd2a12cb35",
    "7999318af12a75b35815461c601d4c25750e8340",
    "5fb723bb77722d41df6959eee23e1b0cfeb5584e",
    "ce832059db077fa95922198b066a737ed4f609fe",
    "287d3d6804a869723ae36605a3c2d2b3eae3941e",
    "0840b4329b2428b20b862f70d72cbdcd6d1618ed",
    "503e73e849cbdd1194cc0d16b4969c60929aca11",
    "2b66d9ec5bdaec7e6b278926fbb6f222c4e3afaa",
    "4174b9756c8c7877797545c4356b1f40df603ec5",
    "ac954486c5102b8fbbc4229a0d3a512bcc7013c0",
    "f4a57d4a531e793373fe3118d644871a3b9ae0b1",
    "109e528ef5d8df07443373751266b4417acc981a",
    "91828fef6b9314f72d1f973f00e81404dc6bba91",
    "9b856d9787be5ec88ef34574b9b98755d7b669ea",
    "796638d9bc86235b9f3e5d1a3a9a25bbf5c04d1c",
    "cf9d3c925608e8bc650d43975382ed3014081057",
    "c39ca541f498712133890961598bbff50d89d68b",
    "f489a4ec969f3727d03c8e85d51af1018fc0b2a1",
    "189a63a719c63b67a1783a280bfc2f72dcb55277",
    "44872b76fcc0ddfbc7b0a4e54eef50fe8708e0f5",
    "487374b7fe0c92fc7eb1406c568952722b5d5b15",
    "14dd647c556016d351f425ee956ccf800ccb9ce2",
    "18a594257e052e8f10a03e5594e6cc6901dc56be",
    "23bf6c72071782e3fd5a628e21495d6b974c7a9e",
    "69c8a7f45be5c0aa6787b07f328d74f1e2ba5628",
    "18741adf97f4fda5f8743318b59c440928e51297",
    "c53420f58364b11fbda1dace7679d45534533382",
    "dd57c2047bfd21910acc38c98153eedf1db75169",
    "f2ea555ac6c06a3f2f6559731f48711fff05d3f1",
    "c8212bacb1b2a7e6ee83cc56f72297465ce99390",
    "9c22065109a77681bc2534063eabe8692fbcb3cd",
    "5b3bb05fbeb7ed4671f4d3a59677788f7fda43d0",
    "18757c126761d1813dfffb57d5032d6b5b3c96de",
    "453926397182078c65a4428eb5de5a90d6af6448",
    "cc523683cfa76c1255667a3aedc48b08e5daabc7",
    "e1fdf62123625e4ba399af02f8aad500637d29d1",
    "97ed48e0357094ac43533c9e6bd05067b15010c6",
    "6d80dc2a84bb9a7d15c51e79c624211a20a74b23",
    "ffdf980b2056b2a1b31ccb19746f23c31f7d08ef",
    "c7007a8a3508a24a6f023302516fe8fbe270eab1",
    "a5c46c91655acebccd1367706b05946eff90f744",
    "9d1621da52fd7f4ee68f80fdbf420180a42b5b1d",
    "9a153334ac5a83a49a44ead02466453f3127120f",
    "41b1e3ffec808db440778bebc258c10c76834513",
    "58bfa24ae4858d336e5322a10c9e4147b1d14d8b",
    "6b608aad7d52b524fa94955a538e8b3524d42d93",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517"
  ],
  "changeHistoryShort": {
    "b38643c9a8dd2c53024ae830b9565a550d0ec39c": "Ybodychange",
    "56d93d2e39ead89bb79c4f4096554820dc77e84b": "Ybodychange",
    "ca13b224b2feb9c44de861da9cbba8dd2a12cb35": "Ybodychange",
    "7999318af12a75b35815461c601d4c25750e8340": "Ybodychange",
    "5fb723bb77722d41df6959eee23e1b0cfeb5584e": "Ybodychange",
    "ce832059db077fa95922198b066a737ed4f609fe": "Ybodychange",
    "287d3d6804a869723ae36605a3c2d2b3eae3941e": "Ybodychange",
    "0840b4329b2428b20b862f70d72cbdcd6d1618ed": "Ybodychange",
    "503e73e849cbdd1194cc0d16b4969c60929aca11": "Ybodychange",
    "2b66d9ec5bdaec7e6b278926fbb6f222c4e3afaa": "Ymultichange(Ymodifierchange,Ybodychange)",
    "4174b9756c8c7877797545c4356b1f40df603ec5": "Ybodychange",
    "ac954486c5102b8fbbc4229a0d3a512bcc7013c0": "Ybodychange",
    "f4a57d4a531e793373fe3118d644871a3b9ae0b1": "Ybodychange",
    "109e528ef5d8df07443373751266b4417acc981a": "Ybodychange",
    "91828fef6b9314f72d1f973f00e81404dc6bba91": "Ybodychange",
    "9b856d9787be5ec88ef34574b9b98755d7b669ea": "Ybodychange",
    "796638d9bc86235b9f3e5d1a3a9a25bbf5c04d1c": "Ybodychange",
    "cf9d3c925608e8bc650d43975382ed3014081057": "Ybodychange",
    "c39ca541f498712133890961598bbff50d89d68b": "Ybodychange",
    "f489a4ec969f3727d03c8e85d51af1018fc0b2a1": "Ybodychange",
    "189a63a719c63b67a1783a280bfc2f72dcb55277": "Ybodychange",
    "44872b76fcc0ddfbc7b0a4e54eef50fe8708e0f5": "Ybodychange",
    "487374b7fe0c92fc7eb1406c568952722b5d5b15": "Ybodychange",
    "14dd647c556016d351f425ee956ccf800ccb9ce2": "Ybodychange",
    "18a594257e052e8f10a03e5594e6cc6901dc56be": "Ymultichange(Yparameterchange,Ybodychange)",
    "23bf6c72071782e3fd5a628e21495d6b974c7a9e": "Ymultichange(Yparameterchange,Ybodychange)",
    "69c8a7f45be5c0aa6787b07f328d74f1e2ba5628": "Ymultichange(Yparameterchange,Ybodychange)",
    "18741adf97f4fda5f8743318b59c440928e51297": "Ybodychange",
    "c53420f58364b11fbda1dace7679d45534533382": "Ymultichange(Yparameterchange,Ybodychange)",
    "dd57c2047bfd21910acc38c98153eedf1db75169": "Ybodychange",
    "f2ea555ac6c06a3f2f6559731f48711fff05d3f1": "Ymultichange(Yparameterchange,Yexceptionschange,Ybodychange)",
    "c8212bacb1b2a7e6ee83cc56f72297465ce99390": "Ymodifierchange",
    "9c22065109a77681bc2534063eabe8692fbcb3cd": "Ymultichange(Yparameterchange,Ybodychange)",
    "5b3bb05fbeb7ed4671f4d3a59677788f7fda43d0": "Ymultichange(Yparameterchange,Ybodychange)",
    "18757c126761d1813dfffb57d5032d6b5b3c96de": "Ymultichange(Yparameterchange,Ybodychange)",
    "453926397182078c65a4428eb5de5a90d6af6448": "Ybodychange",
    "cc523683cfa76c1255667a3aedc48b08e5daabc7": "Ybodychange",
    "e1fdf62123625e4ba399af02f8aad500637d29d1": "Yfilerename",
    "97ed48e0357094ac43533c9e6bd05067b15010c6": "Ybodychange",
    "6d80dc2a84bb9a7d15c51e79c624211a20a74b23": "Ybodychange",
    "ffdf980b2056b2a1b31ccb19746f23c31f7d08ef": "Ybodychange",
    "c7007a8a3508a24a6f023302516fe8fbe270eab1": "Ymultichange(Yparameterchange,Ybodychange)",
    "a5c46c91655acebccd1367706b05946eff90f744": "Ybodychange",
    "9d1621da52fd7f4ee68f80fdbf420180a42b5b1d": "Ybodychange",
    "9a153334ac5a83a49a44ead02466453f3127120f": "Ybodychange",
    "41b1e3ffec808db440778bebc258c10c76834513": "Ymultichange(Yparameterchange,Ybodychange)",
    "58bfa24ae4858d336e5322a10c9e4147b1d14d8b": "Ybodychange",
    "6b608aad7d52b524fa94955a538e8b3524d42d93": "Ymultichange(Yparameterchange,Ybodychange)",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": "Yintroduced"
  },
  "changeHistoryDetails": {
    "b38643c9a8dd2c53024ae830b9565a550d0ec39c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7473. Implement Framework and policy for capacity management of auto created queues. (Suma Shivaprasad via wangda)\n\nChange-Id: Icca7805fe12f6f7fb335effff4b121b6f7f6337b\n",
      "commitDate": "08/12/17 3:10 PM",
      "commitName": "b38643c9a8dd2c53024ae830b9565a550d0ec39c",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "07/12/17 6:56 PM",
      "commitNameOld": "d52627a7cbddfd981db973e223aefffde1ebf82d",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 0.84,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,163 +1,4 @@\n   protected void setupQueueConfigs(Resource clusterResource)\n       throws IOException {\n-    try {\n-      writeLock.lock();\n-      super.setupQueueConfigs(clusterResource);\n-\n-      this.lastClusterResource \u003d clusterResource;\n-\n-      this.cachedResourceLimitsForHeadroom \u003d new ResourceLimits(\n-          clusterResource);\n-\n-      // Initialize headroom info, also used for calculating application\n-      // master resource limits.  Since this happens during queue initialization\n-      // and all queues may not be realized yet, we\u0027ll use (optimistic)\n-      // absoluteMaxCapacity (it will be replaced with the more accurate\n-      // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n-      setQueueResourceLimitsInfo(clusterResource);\n-\n-      CapacitySchedulerConfiguration conf \u003d csContext.getConfiguration();\n-\n-      setOrderingPolicy(\n-          conf.\u003cFiCaSchedulerApp\u003egetAppOrderingPolicy(getQueuePath()));\n-\n-      usersManager.setUserLimit(conf.getUserLimit(getQueuePath()));\n-      usersManager.setUserLimitFactor(conf.getUserLimitFactor(getQueuePath()));\n-\n-      maxApplications \u003d conf.getMaximumApplicationsPerQueue(getQueuePath());\n-      if (maxApplications \u003c 0) {\n-        int maxGlobalPerQueueApps \u003d conf.getGlobalMaximumApplicationsPerQueue();\n-        if (maxGlobalPerQueueApps \u003e 0) {\n-          maxApplications \u003d maxGlobalPerQueueApps;\n-        } else {\n-          int maxSystemApps \u003d conf.getMaximumSystemApplications();\n-          maxApplications \u003d\n-              (int) (maxSystemApps * queueCapacities.getAbsoluteCapacity());\n-        }\n-      }\n-      maxApplicationsPerUser \u003d Math.min(maxApplications,\n-          (int) (maxApplications * (usersManager.getUserLimit() / 100.0f)\n-              * usersManager.getUserLimitFactor()));\n-\n-      maxAMResourcePerQueuePercent \u003d\n-          conf.getMaximumApplicationMasterResourcePerQueuePercent(\n-              getQueuePath());\n-\n-      priorityAcls \u003d conf.getPriorityAcls(getQueuePath(),\n-          scheduler.getMaxClusterLevelAppPriority());\n-\n-      if (!SchedulerUtils.checkQueueLabelExpression(this.accessibleLabels,\n-          this.defaultLabelExpression, null)) {\n-        throw new IOException(\n-            \"Invalid default label expression of \" + \" queue\u003d\" + getQueueName()\n-                + \" doesn\u0027t have permission to access all labels \"\n-                + \"in default label expression. labelExpression of resource request\u003d\"\n-                + (this.defaultLabelExpression \u003d\u003d null ?\n-                \"\" :\n-                this.defaultLabelExpression) + \". Queue labels\u003d\" + (\n-                getAccessibleNodeLabels() \u003d\u003d null ?\n-                    \"\" :\n-                    StringUtils\n-                        .join(getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n-      }\n-\n-      nodeLocalityDelay \u003d conf.getNodeLocalityDelay();\n-      rackLocalityAdditionalDelay \u003d conf.getRackLocalityAdditionalDelay();\n-      rackLocalityFullReset \u003d conf.getRackLocalityFullReset();\n-\n-      // re-init this since max allocation could have changed\n-      this.minimumAllocationFactor \u003d Resources.ratio(resourceCalculator,\n-          Resources.subtract(maximumAllocation, minimumAllocation),\n-          maximumAllocation);\n-\n-      StringBuilder aclsString \u003d new StringBuilder();\n-      for (Map.Entry\u003cAccessType, AccessControlList\u003e e : acls.entrySet()) {\n-        aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n-      }\n-\n-      StringBuilder labelStrBuilder \u003d new StringBuilder();\n-      if (accessibleLabels !\u003d null) {\n-        for (String s : accessibleLabels) {\n-          labelStrBuilder.append(s);\n-          labelStrBuilder.append(\",\");\n-        }\n-      }\n-\n-      defaultAppPriorityPerQueue \u003d Priority.newInstance(\n-          conf.getDefaultApplicationPriorityConfPerQueue(getQueuePath()));\n-\n-      maxApplicationLifetime \u003d\n-          conf.getMaximumLifetimePerQueue((getQueuePath()));\n-      defaultApplicationLifetime \u003d\n-          conf.getDefaultLifetimePerQueue((getQueuePath()));\n-      if (defaultApplicationLifetime \u003e maxApplicationLifetime) {\n-        throw new YarnRuntimeException(\n-            \"Default lifetime\" + defaultApplicationLifetime\n-                + \" can\u0027t exceed maximum lifetime \" + maxApplicationLifetime);\n-      }\n-      defaultApplicationLifetime \u003d defaultApplicationLifetime \u003e 0\n-          ? defaultApplicationLifetime : maxApplicationLifetime;\n-\n-      // Validate leaf queue\u0027s user\u0027s weights.\n-      int queueUL \u003d Math.min(100, conf.getUserLimit(getQueuePath()));\n-      for (Entry\u003cString, Float\u003e e : getUserWeights().entrySet()) {\n-        float val \u003d e.getValue().floatValue();\n-        if (val \u003c 0.0f || val \u003e (100.0f / queueUL)) {\n-          throw new IOException(\"Weight (\" + val + \") for user \\\"\" + e.getKey()\n-              + \"\\\" must be between 0 and\" + \" 100 / \" + queueUL + \" (\u003d \" +\n-              100.0f/queueUL + \", the number of concurrent active users in \"\n-              + getQueuePath() + \")\");\n-        }\n-      }\n-\n-      usersManager.updateUserWeights();\n-\n-      LOG.info(\n-          \"Initializing \" + queueName + \"\\n\" + \"capacity \u003d \" + queueCapacities\n-              .getCapacity() + \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\"\n-              + \"absoluteCapacity \u003d \" + queueCapacities.getAbsoluteCapacity()\n-              + \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\"\n-              + \"maxCapacity \u003d \" + queueCapacities.getMaximumCapacity()\n-              + \" [\u003d configuredMaxCapacity ]\" + \"\\n\" + \"absoluteMaxCapacity \u003d \"\n-              + queueCapacities.getAbsoluteMaximumCapacity()\n-              + \" [\u003d 1.0 maximumCapacity undefined, \"\n-              + \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\"\n-              + \"\\n\" + \"userLimit \u003d \" + usersManager.getUserLimit()\n-              + \" [\u003d configuredUserLimit ]\" + \"\\n\" + \"userLimitFactor \u003d \"\n-              + usersManager.getUserLimitFactor()\n-              + \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" + \"maxApplications \u003d \"\n-              + maxApplications\n-              + \" [\u003d configuredMaximumSystemApplicationsPerQueue or\"\n-              + \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\"\n-              + \"\\n\" + \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser\n-              + \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \"\n-              + \"userLimitFactor) ]\" + \"\\n\" + \"usedCapacity \u003d \"\n-              + queueCapacities.getUsedCapacity() + \" [\u003d usedResourcesMemory / \"\n-              + \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\"\n-              + \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity\n-              + \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\"\n-              + \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent\n-              + \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\"\n-              + \"minimumAllocationFactor \u003d \" + minimumAllocationFactor\n-              + \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \"\n-              + \"maximumAllocationMemory ]\" + \"\\n\" + \"maximumAllocation \u003d \"\n-              + maximumAllocation + \" [\u003d configuredMaxAllocation ]\" + \"\\n\"\n-              + \"numContainers \u003d \" + numContainers\n-              + \" [\u003d currentNumContainers ]\" + \"\\n\" + \"state \u003d \" + getState()\n-              + \" [\u003d configuredState ]\" + \"\\n\" + \"acls \u003d \" + aclsString\n-              + \" [\u003d configuredAcls ]\" + \"\\n\"\n-              + \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\"\n-              + \"rackLocalityAdditionalDelay \u003d \"\n-              + rackLocalityAdditionalDelay + \"\\n\"\n-              + \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\"\n-              + \"reservationsContinueLooking \u003d \"\n-              + reservationsContinueLooking + \"\\n\" + \"preemptionDisabled \u003d \"\n-              + getPreemptionDisabled() + \"\\n\" + \"defaultAppPriorityPerQueue \u003d \"\n-              + defaultAppPriorityPerQueue + \"\\npriority \u003d \" + priority\n-              + \"\\nmaxLifetime \u003d \" + maxApplicationLifetime + \" seconds\"\n-              + \"\\ndefaultLifetime \u003d \"\n-              + defaultApplicationLifetime + \" seconds\");\n-    } finally {\n-      writeLock.unlock();\n-    }\n+    setupQueueConfigs(clusterResource, csContext.getConfiguration());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void setupQueueConfigs(Resource clusterResource)\n      throws IOException {\n    setupQueueConfigs(clusterResource, csContext.getConfiguration());\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "56d93d2e39ead89bb79c4f4096554820dc77e84b": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6600. Introduce default and max lifetime of application at LeafQueue level. Contributed by Rohith Sharma K S.\n",
      "commitDate": "07/09/17 6:45 PM",
      "commitName": "56d93d2e39ead89bb79c4f4096554820dc77e84b",
      "commitAuthor": "Sunil G",
      "commitDateOld": "14/08/17 1:31 PM",
      "commitNameOld": "5558792894169425bff054364a1ab4c48b347fb9",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 24.22,
      "commitsBetweenForRepo": 210,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,148 +1,163 @@\n   protected void setupQueueConfigs(Resource clusterResource)\n       throws IOException {\n     try {\n       writeLock.lock();\n       super.setupQueueConfigs(clusterResource);\n \n       this.lastClusterResource \u003d clusterResource;\n \n       this.cachedResourceLimitsForHeadroom \u003d new ResourceLimits(\n           clusterResource);\n \n       // Initialize headroom info, also used for calculating application\n       // master resource limits.  Since this happens during queue initialization\n       // and all queues may not be realized yet, we\u0027ll use (optimistic)\n       // absoluteMaxCapacity (it will be replaced with the more accurate\n       // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n       setQueueResourceLimitsInfo(clusterResource);\n \n       CapacitySchedulerConfiguration conf \u003d csContext.getConfiguration();\n \n       setOrderingPolicy(\n           conf.\u003cFiCaSchedulerApp\u003egetAppOrderingPolicy(getQueuePath()));\n \n       usersManager.setUserLimit(conf.getUserLimit(getQueuePath()));\n       usersManager.setUserLimitFactor(conf.getUserLimitFactor(getQueuePath()));\n \n       maxApplications \u003d conf.getMaximumApplicationsPerQueue(getQueuePath());\n       if (maxApplications \u003c 0) {\n         int maxGlobalPerQueueApps \u003d conf.getGlobalMaximumApplicationsPerQueue();\n         if (maxGlobalPerQueueApps \u003e 0) {\n           maxApplications \u003d maxGlobalPerQueueApps;\n         } else {\n           int maxSystemApps \u003d conf.getMaximumSystemApplications();\n           maxApplications \u003d\n               (int) (maxSystemApps * queueCapacities.getAbsoluteCapacity());\n         }\n       }\n       maxApplicationsPerUser \u003d Math.min(maxApplications,\n           (int) (maxApplications * (usersManager.getUserLimit() / 100.0f)\n               * usersManager.getUserLimitFactor()));\n \n       maxAMResourcePerQueuePercent \u003d\n           conf.getMaximumApplicationMasterResourcePerQueuePercent(\n               getQueuePath());\n \n       priorityAcls \u003d conf.getPriorityAcls(getQueuePath(),\n           scheduler.getMaxClusterLevelAppPriority());\n \n       if (!SchedulerUtils.checkQueueLabelExpression(this.accessibleLabels,\n           this.defaultLabelExpression, null)) {\n         throw new IOException(\n             \"Invalid default label expression of \" + \" queue\u003d\" + getQueueName()\n                 + \" doesn\u0027t have permission to access all labels \"\n                 + \"in default label expression. labelExpression of resource request\u003d\"\n                 + (this.defaultLabelExpression \u003d\u003d null ?\n                 \"\" :\n                 this.defaultLabelExpression) + \". Queue labels\u003d\" + (\n                 getAccessibleNodeLabels() \u003d\u003d null ?\n                     \"\" :\n                     StringUtils\n                         .join(getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n       }\n \n       nodeLocalityDelay \u003d conf.getNodeLocalityDelay();\n       rackLocalityAdditionalDelay \u003d conf.getRackLocalityAdditionalDelay();\n       rackLocalityFullReset \u003d conf.getRackLocalityFullReset();\n \n       // re-init this since max allocation could have changed\n       this.minimumAllocationFactor \u003d Resources.ratio(resourceCalculator,\n           Resources.subtract(maximumAllocation, minimumAllocation),\n           maximumAllocation);\n \n       StringBuilder aclsString \u003d new StringBuilder();\n       for (Map.Entry\u003cAccessType, AccessControlList\u003e e : acls.entrySet()) {\n         aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n       }\n \n       StringBuilder labelStrBuilder \u003d new StringBuilder();\n       if (accessibleLabels !\u003d null) {\n         for (String s : accessibleLabels) {\n           labelStrBuilder.append(s);\n           labelStrBuilder.append(\",\");\n         }\n       }\n \n       defaultAppPriorityPerQueue \u003d Priority.newInstance(\n           conf.getDefaultApplicationPriorityConfPerQueue(getQueuePath()));\n \n+      maxApplicationLifetime \u003d\n+          conf.getMaximumLifetimePerQueue((getQueuePath()));\n+      defaultApplicationLifetime \u003d\n+          conf.getDefaultLifetimePerQueue((getQueuePath()));\n+      if (defaultApplicationLifetime \u003e maxApplicationLifetime) {\n+        throw new YarnRuntimeException(\n+            \"Default lifetime\" + defaultApplicationLifetime\n+                + \" can\u0027t exceed maximum lifetime \" + maxApplicationLifetime);\n+      }\n+      defaultApplicationLifetime \u003d defaultApplicationLifetime \u003e 0\n+          ? defaultApplicationLifetime : maxApplicationLifetime;\n+\n       // Validate leaf queue\u0027s user\u0027s weights.\n       int queueUL \u003d Math.min(100, conf.getUserLimit(getQueuePath()));\n       for (Entry\u003cString, Float\u003e e : getUserWeights().entrySet()) {\n         float val \u003d e.getValue().floatValue();\n         if (val \u003c 0.0f || val \u003e (100.0f / queueUL)) {\n           throw new IOException(\"Weight (\" + val + \") for user \\\"\" + e.getKey()\n               + \"\\\" must be between 0 and\" + \" 100 / \" + queueUL + \" (\u003d \" +\n               100.0f/queueUL + \", the number of concurrent active users in \"\n               + getQueuePath() + \")\");\n         }\n       }\n \n       usersManager.updateUserWeights();\n \n       LOG.info(\n           \"Initializing \" + queueName + \"\\n\" + \"capacity \u003d \" + queueCapacities\n               .getCapacity() + \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\"\n               + \"absoluteCapacity \u003d \" + queueCapacities.getAbsoluteCapacity()\n               + \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\"\n               + \"maxCapacity \u003d \" + queueCapacities.getMaximumCapacity()\n               + \" [\u003d configuredMaxCapacity ]\" + \"\\n\" + \"absoluteMaxCapacity \u003d \"\n               + queueCapacities.getAbsoluteMaximumCapacity()\n               + \" [\u003d 1.0 maximumCapacity undefined, \"\n               + \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\"\n               + \"\\n\" + \"userLimit \u003d \" + usersManager.getUserLimit()\n               + \" [\u003d configuredUserLimit ]\" + \"\\n\" + \"userLimitFactor \u003d \"\n               + usersManager.getUserLimitFactor()\n               + \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" + \"maxApplications \u003d \"\n               + maxApplications\n               + \" [\u003d configuredMaximumSystemApplicationsPerQueue or\"\n               + \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\"\n               + \"\\n\" + \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser\n               + \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \"\n               + \"userLimitFactor) ]\" + \"\\n\" + \"usedCapacity \u003d \"\n               + queueCapacities.getUsedCapacity() + \" [\u003d usedResourcesMemory / \"\n               + \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\"\n               + \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity\n               + \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\"\n               + \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent\n               + \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\"\n               + \"minimumAllocationFactor \u003d \" + minimumAllocationFactor\n               + \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \"\n               + \"maximumAllocationMemory ]\" + \"\\n\" + \"maximumAllocation \u003d \"\n               + maximumAllocation + \" [\u003d configuredMaxAllocation ]\" + \"\\n\"\n               + \"numContainers \u003d \" + numContainers\n               + \" [\u003d currentNumContainers ]\" + \"\\n\" + \"state \u003d \" + getState()\n               + \" [\u003d configuredState ]\" + \"\\n\" + \"acls \u003d \" + aclsString\n               + \" [\u003d configuredAcls ]\" + \"\\n\"\n               + \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\"\n               + \"rackLocalityAdditionalDelay \u003d \"\n               + rackLocalityAdditionalDelay + \"\\n\"\n               + \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\"\n               + \"reservationsContinueLooking \u003d \"\n               + reservationsContinueLooking + \"\\n\" + \"preemptionDisabled \u003d \"\n               + getPreemptionDisabled() + \"\\n\" + \"defaultAppPriorityPerQueue \u003d \"\n-              + defaultAppPriorityPerQueue + \"\\npriority \u003d \" + priority);\n+              + defaultAppPriorityPerQueue + \"\\npriority \u003d \" + priority\n+              + \"\\nmaxLifetime \u003d \" + maxApplicationLifetime + \" seconds\"\n+              + \"\\ndefaultLifetime \u003d \"\n+              + defaultApplicationLifetime + \" seconds\");\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void setupQueueConfigs(Resource clusterResource)\n      throws IOException {\n    try {\n      writeLock.lock();\n      super.setupQueueConfigs(clusterResource);\n\n      this.lastClusterResource \u003d clusterResource;\n\n      this.cachedResourceLimitsForHeadroom \u003d new ResourceLimits(\n          clusterResource);\n\n      // Initialize headroom info, also used for calculating application\n      // master resource limits.  Since this happens during queue initialization\n      // and all queues may not be realized yet, we\u0027ll use (optimistic)\n      // absoluteMaxCapacity (it will be replaced with the more accurate\n      // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n      setQueueResourceLimitsInfo(clusterResource);\n\n      CapacitySchedulerConfiguration conf \u003d csContext.getConfiguration();\n\n      setOrderingPolicy(\n          conf.\u003cFiCaSchedulerApp\u003egetAppOrderingPolicy(getQueuePath()));\n\n      usersManager.setUserLimit(conf.getUserLimit(getQueuePath()));\n      usersManager.setUserLimitFactor(conf.getUserLimitFactor(getQueuePath()));\n\n      maxApplications \u003d conf.getMaximumApplicationsPerQueue(getQueuePath());\n      if (maxApplications \u003c 0) {\n        int maxGlobalPerQueueApps \u003d conf.getGlobalMaximumApplicationsPerQueue();\n        if (maxGlobalPerQueueApps \u003e 0) {\n          maxApplications \u003d maxGlobalPerQueueApps;\n        } else {\n          int maxSystemApps \u003d conf.getMaximumSystemApplications();\n          maxApplications \u003d\n              (int) (maxSystemApps * queueCapacities.getAbsoluteCapacity());\n        }\n      }\n      maxApplicationsPerUser \u003d Math.min(maxApplications,\n          (int) (maxApplications * (usersManager.getUserLimit() / 100.0f)\n              * usersManager.getUserLimitFactor()));\n\n      maxAMResourcePerQueuePercent \u003d\n          conf.getMaximumApplicationMasterResourcePerQueuePercent(\n              getQueuePath());\n\n      priorityAcls \u003d conf.getPriorityAcls(getQueuePath(),\n          scheduler.getMaxClusterLevelAppPriority());\n\n      if (!SchedulerUtils.checkQueueLabelExpression(this.accessibleLabels,\n          this.defaultLabelExpression, null)) {\n        throw new IOException(\n            \"Invalid default label expression of \" + \" queue\u003d\" + getQueueName()\n                + \" doesn\u0027t have permission to access all labels \"\n                + \"in default label expression. labelExpression of resource request\u003d\"\n                + (this.defaultLabelExpression \u003d\u003d null ?\n                \"\" :\n                this.defaultLabelExpression) + \". Queue labels\u003d\" + (\n                getAccessibleNodeLabels() \u003d\u003d null ?\n                    \"\" :\n                    StringUtils\n                        .join(getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n      }\n\n      nodeLocalityDelay \u003d conf.getNodeLocalityDelay();\n      rackLocalityAdditionalDelay \u003d conf.getRackLocalityAdditionalDelay();\n      rackLocalityFullReset \u003d conf.getRackLocalityFullReset();\n\n      // re-init this since max allocation could have changed\n      this.minimumAllocationFactor \u003d Resources.ratio(resourceCalculator,\n          Resources.subtract(maximumAllocation, minimumAllocation),\n          maximumAllocation);\n\n      StringBuilder aclsString \u003d new StringBuilder();\n      for (Map.Entry\u003cAccessType, AccessControlList\u003e e : acls.entrySet()) {\n        aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n      }\n\n      StringBuilder labelStrBuilder \u003d new StringBuilder();\n      if (accessibleLabels !\u003d null) {\n        for (String s : accessibleLabels) {\n          labelStrBuilder.append(s);\n          labelStrBuilder.append(\",\");\n        }\n      }\n\n      defaultAppPriorityPerQueue \u003d Priority.newInstance(\n          conf.getDefaultApplicationPriorityConfPerQueue(getQueuePath()));\n\n      maxApplicationLifetime \u003d\n          conf.getMaximumLifetimePerQueue((getQueuePath()));\n      defaultApplicationLifetime \u003d\n          conf.getDefaultLifetimePerQueue((getQueuePath()));\n      if (defaultApplicationLifetime \u003e maxApplicationLifetime) {\n        throw new YarnRuntimeException(\n            \"Default lifetime\" + defaultApplicationLifetime\n                + \" can\u0027t exceed maximum lifetime \" + maxApplicationLifetime);\n      }\n      defaultApplicationLifetime \u003d defaultApplicationLifetime \u003e 0\n          ? defaultApplicationLifetime : maxApplicationLifetime;\n\n      // Validate leaf queue\u0027s user\u0027s weights.\n      int queueUL \u003d Math.min(100, conf.getUserLimit(getQueuePath()));\n      for (Entry\u003cString, Float\u003e e : getUserWeights().entrySet()) {\n        float val \u003d e.getValue().floatValue();\n        if (val \u003c 0.0f || val \u003e (100.0f / queueUL)) {\n          throw new IOException(\"Weight (\" + val + \") for user \\\"\" + e.getKey()\n              + \"\\\" must be between 0 and\" + \" 100 / \" + queueUL + \" (\u003d \" +\n              100.0f/queueUL + \", the number of concurrent active users in \"\n              + getQueuePath() + \")\");\n        }\n      }\n\n      usersManager.updateUserWeights();\n\n      LOG.info(\n          \"Initializing \" + queueName + \"\\n\" + \"capacity \u003d \" + queueCapacities\n              .getCapacity() + \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\"\n              + \"absoluteCapacity \u003d \" + queueCapacities.getAbsoluteCapacity()\n              + \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\"\n              + \"maxCapacity \u003d \" + queueCapacities.getMaximumCapacity()\n              + \" [\u003d configuredMaxCapacity ]\" + \"\\n\" + \"absoluteMaxCapacity \u003d \"\n              + queueCapacities.getAbsoluteMaximumCapacity()\n              + \" [\u003d 1.0 maximumCapacity undefined, \"\n              + \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\"\n              + \"\\n\" + \"userLimit \u003d \" + usersManager.getUserLimit()\n              + \" [\u003d configuredUserLimit ]\" + \"\\n\" + \"userLimitFactor \u003d \"\n              + usersManager.getUserLimitFactor()\n              + \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" + \"maxApplications \u003d \"\n              + maxApplications\n              + \" [\u003d configuredMaximumSystemApplicationsPerQueue or\"\n              + \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\"\n              + \"\\n\" + \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser\n              + \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \"\n              + \"userLimitFactor) ]\" + \"\\n\" + \"usedCapacity \u003d \"\n              + queueCapacities.getUsedCapacity() + \" [\u003d usedResourcesMemory / \"\n              + \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\"\n              + \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity\n              + \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\"\n              + \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent\n              + \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\"\n              + \"minimumAllocationFactor \u003d \" + minimumAllocationFactor\n              + \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \"\n              + \"maximumAllocationMemory ]\" + \"\\n\" + \"maximumAllocation \u003d \"\n              + maximumAllocation + \" [\u003d configuredMaxAllocation ]\" + \"\\n\"\n              + \"numContainers \u003d \" + numContainers\n              + \" [\u003d currentNumContainers ]\" + \"\\n\" + \"state \u003d \" + getState()\n              + \" [\u003d configuredState ]\" + \"\\n\" + \"acls \u003d \" + aclsString\n              + \" [\u003d configuredAcls ]\" + \"\\n\"\n              + \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\"\n              + \"rackLocalityAdditionalDelay \u003d \"\n              + rackLocalityAdditionalDelay + \"\\n\"\n              + \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\"\n              + \"reservationsContinueLooking \u003d \"\n              + reservationsContinueLooking + \"\\n\" + \"preemptionDisabled \u003d \"\n              + getPreemptionDisabled() + \"\\n\" + \"defaultAppPriorityPerQueue \u003d \"\n              + defaultAppPriorityPerQueue + \"\\npriority \u003d \" + priority\n              + \"\\nmaxLifetime \u003d \" + maxApplicationLifetime + \" seconds\"\n              + \"\\ndefaultLifetime \u003d \"\n              + defaultApplicationLifetime + \" seconds\");\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "ca13b224b2feb9c44de861da9cbba8dd2a12cb35": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5892. Support user-specific minimum user limit percentage in Capacity Scheduler. Contributed by Eric Payne.\n",
      "commitDate": "22/06/17 11:50 PM",
      "commitName": "ca13b224b2feb9c44de861da9cbba8dd2a12cb35",
      "commitAuthor": "Sunil G",
      "commitDateOld": "19/06/17 9:01 AM",
      "commitNameOld": "e9c2aa1bc383cb08784846534415bf17667d6e41",
      "commitAuthorOld": "Naganarasimha",
      "daysBetweenCommits": 3.62,
      "commitsBetweenForRepo": 29,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,134 +1,148 @@\n   protected void setupQueueConfigs(Resource clusterResource)\n       throws IOException {\n     try {\n       writeLock.lock();\n       super.setupQueueConfigs(clusterResource);\n \n       this.lastClusterResource \u003d clusterResource;\n \n       this.cachedResourceLimitsForHeadroom \u003d new ResourceLimits(\n           clusterResource);\n \n       // Initialize headroom info, also used for calculating application\n       // master resource limits.  Since this happens during queue initialization\n       // and all queues may not be realized yet, we\u0027ll use (optimistic)\n       // absoluteMaxCapacity (it will be replaced with the more accurate\n       // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n       setQueueResourceLimitsInfo(clusterResource);\n \n       CapacitySchedulerConfiguration conf \u003d csContext.getConfiguration();\n \n       setOrderingPolicy(\n           conf.\u003cFiCaSchedulerApp\u003egetAppOrderingPolicy(getQueuePath()));\n \n       usersManager.setUserLimit(conf.getUserLimit(getQueuePath()));\n       usersManager.setUserLimitFactor(conf.getUserLimitFactor(getQueuePath()));\n \n       maxApplications \u003d conf.getMaximumApplicationsPerQueue(getQueuePath());\n       if (maxApplications \u003c 0) {\n         int maxGlobalPerQueueApps \u003d conf.getGlobalMaximumApplicationsPerQueue();\n         if (maxGlobalPerQueueApps \u003e 0) {\n           maxApplications \u003d maxGlobalPerQueueApps;\n         } else {\n           int maxSystemApps \u003d conf.getMaximumSystemApplications();\n           maxApplications \u003d\n               (int) (maxSystemApps * queueCapacities.getAbsoluteCapacity());\n         }\n       }\n       maxApplicationsPerUser \u003d Math.min(maxApplications,\n           (int) (maxApplications * (usersManager.getUserLimit() / 100.0f)\n               * usersManager.getUserLimitFactor()));\n \n       maxAMResourcePerQueuePercent \u003d\n           conf.getMaximumApplicationMasterResourcePerQueuePercent(\n               getQueuePath());\n \n       priorityAcls \u003d conf.getPriorityAcls(getQueuePath(),\n           scheduler.getMaxClusterLevelAppPriority());\n \n       if (!SchedulerUtils.checkQueueLabelExpression(this.accessibleLabels,\n           this.defaultLabelExpression, null)) {\n         throw new IOException(\n             \"Invalid default label expression of \" + \" queue\u003d\" + getQueueName()\n                 + \" doesn\u0027t have permission to access all labels \"\n                 + \"in default label expression. labelExpression of resource request\u003d\"\n                 + (this.defaultLabelExpression \u003d\u003d null ?\n                 \"\" :\n                 this.defaultLabelExpression) + \". Queue labels\u003d\" + (\n                 getAccessibleNodeLabels() \u003d\u003d null ?\n                     \"\" :\n                     StringUtils\n                         .join(getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n       }\n \n       nodeLocalityDelay \u003d conf.getNodeLocalityDelay();\n       rackLocalityAdditionalDelay \u003d conf.getRackLocalityAdditionalDelay();\n       rackLocalityFullReset \u003d conf.getRackLocalityFullReset();\n \n       // re-init this since max allocation could have changed\n       this.minimumAllocationFactor \u003d Resources.ratio(resourceCalculator,\n           Resources.subtract(maximumAllocation, minimumAllocation),\n           maximumAllocation);\n \n       StringBuilder aclsString \u003d new StringBuilder();\n       for (Map.Entry\u003cAccessType, AccessControlList\u003e e : acls.entrySet()) {\n         aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n       }\n \n       StringBuilder labelStrBuilder \u003d new StringBuilder();\n       if (accessibleLabels !\u003d null) {\n         for (String s : accessibleLabels) {\n           labelStrBuilder.append(s);\n           labelStrBuilder.append(\",\");\n         }\n       }\n \n       defaultAppPriorityPerQueue \u003d Priority.newInstance(\n           conf.getDefaultApplicationPriorityConfPerQueue(getQueuePath()));\n \n+      // Validate leaf queue\u0027s user\u0027s weights.\n+      int queueUL \u003d Math.min(100, conf.getUserLimit(getQueuePath()));\n+      for (Entry\u003cString, Float\u003e e : getUserWeights().entrySet()) {\n+        float val \u003d e.getValue().floatValue();\n+        if (val \u003c 0.0f || val \u003e (100.0f / queueUL)) {\n+          throw new IOException(\"Weight (\" + val + \") for user \\\"\" + e.getKey()\n+              + \"\\\" must be between 0 and\" + \" 100 / \" + queueUL + \" (\u003d \" +\n+              100.0f/queueUL + \", the number of concurrent active users in \"\n+              + getQueuePath() + \")\");\n+        }\n+      }\n+\n+      usersManager.updateUserWeights();\n+\n       LOG.info(\n           \"Initializing \" + queueName + \"\\n\" + \"capacity \u003d \" + queueCapacities\n               .getCapacity() + \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\"\n               + \"absoluteCapacity \u003d \" + queueCapacities.getAbsoluteCapacity()\n               + \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\"\n               + \"maxCapacity \u003d \" + queueCapacities.getMaximumCapacity()\n               + \" [\u003d configuredMaxCapacity ]\" + \"\\n\" + \"absoluteMaxCapacity \u003d \"\n               + queueCapacities.getAbsoluteMaximumCapacity()\n               + \" [\u003d 1.0 maximumCapacity undefined, \"\n               + \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\"\n               + \"\\n\" + \"userLimit \u003d \" + usersManager.getUserLimit()\n               + \" [\u003d configuredUserLimit ]\" + \"\\n\" + \"userLimitFactor \u003d \"\n               + usersManager.getUserLimitFactor()\n               + \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" + \"maxApplications \u003d \"\n               + maxApplications\n               + \" [\u003d configuredMaximumSystemApplicationsPerQueue or\"\n               + \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\"\n               + \"\\n\" + \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser\n               + \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \"\n               + \"userLimitFactor) ]\" + \"\\n\" + \"usedCapacity \u003d \"\n               + queueCapacities.getUsedCapacity() + \" [\u003d usedResourcesMemory / \"\n               + \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\"\n               + \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity\n               + \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\"\n               + \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent\n               + \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\"\n               + \"minimumAllocationFactor \u003d \" + minimumAllocationFactor\n               + \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \"\n               + \"maximumAllocationMemory ]\" + \"\\n\" + \"maximumAllocation \u003d \"\n               + maximumAllocation + \" [\u003d configuredMaxAllocation ]\" + \"\\n\"\n               + \"numContainers \u003d \" + numContainers\n               + \" [\u003d currentNumContainers ]\" + \"\\n\" + \"state \u003d \" + getState()\n               + \" [\u003d configuredState ]\" + \"\\n\" + \"acls \u003d \" + aclsString\n               + \" [\u003d configuredAcls ]\" + \"\\n\"\n               + \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\"\n               + \"rackLocalityAdditionalDelay \u003d \"\n               + rackLocalityAdditionalDelay + \"\\n\"\n               + \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\"\n               + \"reservationsContinueLooking \u003d \"\n               + reservationsContinueLooking + \"\\n\" + \"preemptionDisabled \u003d \"\n               + getPreemptionDisabled() + \"\\n\" + \"defaultAppPriorityPerQueue \u003d \"\n               + defaultAppPriorityPerQueue + \"\\npriority \u003d \" + priority);\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void setupQueueConfigs(Resource clusterResource)\n      throws IOException {\n    try {\n      writeLock.lock();\n      super.setupQueueConfigs(clusterResource);\n\n      this.lastClusterResource \u003d clusterResource;\n\n      this.cachedResourceLimitsForHeadroom \u003d new ResourceLimits(\n          clusterResource);\n\n      // Initialize headroom info, also used for calculating application\n      // master resource limits.  Since this happens during queue initialization\n      // and all queues may not be realized yet, we\u0027ll use (optimistic)\n      // absoluteMaxCapacity (it will be replaced with the more accurate\n      // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n      setQueueResourceLimitsInfo(clusterResource);\n\n      CapacitySchedulerConfiguration conf \u003d csContext.getConfiguration();\n\n      setOrderingPolicy(\n          conf.\u003cFiCaSchedulerApp\u003egetAppOrderingPolicy(getQueuePath()));\n\n      usersManager.setUserLimit(conf.getUserLimit(getQueuePath()));\n      usersManager.setUserLimitFactor(conf.getUserLimitFactor(getQueuePath()));\n\n      maxApplications \u003d conf.getMaximumApplicationsPerQueue(getQueuePath());\n      if (maxApplications \u003c 0) {\n        int maxGlobalPerQueueApps \u003d conf.getGlobalMaximumApplicationsPerQueue();\n        if (maxGlobalPerQueueApps \u003e 0) {\n          maxApplications \u003d maxGlobalPerQueueApps;\n        } else {\n          int maxSystemApps \u003d conf.getMaximumSystemApplications();\n          maxApplications \u003d\n              (int) (maxSystemApps * queueCapacities.getAbsoluteCapacity());\n        }\n      }\n      maxApplicationsPerUser \u003d Math.min(maxApplications,\n          (int) (maxApplications * (usersManager.getUserLimit() / 100.0f)\n              * usersManager.getUserLimitFactor()));\n\n      maxAMResourcePerQueuePercent \u003d\n          conf.getMaximumApplicationMasterResourcePerQueuePercent(\n              getQueuePath());\n\n      priorityAcls \u003d conf.getPriorityAcls(getQueuePath(),\n          scheduler.getMaxClusterLevelAppPriority());\n\n      if (!SchedulerUtils.checkQueueLabelExpression(this.accessibleLabels,\n          this.defaultLabelExpression, null)) {\n        throw new IOException(\n            \"Invalid default label expression of \" + \" queue\u003d\" + getQueueName()\n                + \" doesn\u0027t have permission to access all labels \"\n                + \"in default label expression. labelExpression of resource request\u003d\"\n                + (this.defaultLabelExpression \u003d\u003d null ?\n                \"\" :\n                this.defaultLabelExpression) + \". Queue labels\u003d\" + (\n                getAccessibleNodeLabels() \u003d\u003d null ?\n                    \"\" :\n                    StringUtils\n                        .join(getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n      }\n\n      nodeLocalityDelay \u003d conf.getNodeLocalityDelay();\n      rackLocalityAdditionalDelay \u003d conf.getRackLocalityAdditionalDelay();\n      rackLocalityFullReset \u003d conf.getRackLocalityFullReset();\n\n      // re-init this since max allocation could have changed\n      this.minimumAllocationFactor \u003d Resources.ratio(resourceCalculator,\n          Resources.subtract(maximumAllocation, minimumAllocation),\n          maximumAllocation);\n\n      StringBuilder aclsString \u003d new StringBuilder();\n      for (Map.Entry\u003cAccessType, AccessControlList\u003e e : acls.entrySet()) {\n        aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n      }\n\n      StringBuilder labelStrBuilder \u003d new StringBuilder();\n      if (accessibleLabels !\u003d null) {\n        for (String s : accessibleLabels) {\n          labelStrBuilder.append(s);\n          labelStrBuilder.append(\",\");\n        }\n      }\n\n      defaultAppPriorityPerQueue \u003d Priority.newInstance(\n          conf.getDefaultApplicationPriorityConfPerQueue(getQueuePath()));\n\n      // Validate leaf queue\u0027s user\u0027s weights.\n      int queueUL \u003d Math.min(100, conf.getUserLimit(getQueuePath()));\n      for (Entry\u003cString, Float\u003e e : getUserWeights().entrySet()) {\n        float val \u003d e.getValue().floatValue();\n        if (val \u003c 0.0f || val \u003e (100.0f / queueUL)) {\n          throw new IOException(\"Weight (\" + val + \") for user \\\"\" + e.getKey()\n              + \"\\\" must be between 0 and\" + \" 100 / \" + queueUL + \" (\u003d \" +\n              100.0f/queueUL + \", the number of concurrent active users in \"\n              + getQueuePath() + \")\");\n        }\n      }\n\n      usersManager.updateUserWeights();\n\n      LOG.info(\n          \"Initializing \" + queueName + \"\\n\" + \"capacity \u003d \" + queueCapacities\n              .getCapacity() + \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\"\n              + \"absoluteCapacity \u003d \" + queueCapacities.getAbsoluteCapacity()\n              + \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\"\n              + \"maxCapacity \u003d \" + queueCapacities.getMaximumCapacity()\n              + \" [\u003d configuredMaxCapacity ]\" + \"\\n\" + \"absoluteMaxCapacity \u003d \"\n              + queueCapacities.getAbsoluteMaximumCapacity()\n              + \" [\u003d 1.0 maximumCapacity undefined, \"\n              + \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\"\n              + \"\\n\" + \"userLimit \u003d \" + usersManager.getUserLimit()\n              + \" [\u003d configuredUserLimit ]\" + \"\\n\" + \"userLimitFactor \u003d \"\n              + usersManager.getUserLimitFactor()\n              + \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" + \"maxApplications \u003d \"\n              + maxApplications\n              + \" [\u003d configuredMaximumSystemApplicationsPerQueue or\"\n              + \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\"\n              + \"\\n\" + \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser\n              + \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \"\n              + \"userLimitFactor) ]\" + \"\\n\" + \"usedCapacity \u003d \"\n              + queueCapacities.getUsedCapacity() + \" [\u003d usedResourcesMemory / \"\n              + \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\"\n              + \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity\n              + \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\"\n              + \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent\n              + \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\"\n              + \"minimumAllocationFactor \u003d \" + minimumAllocationFactor\n              + \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \"\n              + \"maximumAllocationMemory ]\" + \"\\n\" + \"maximumAllocation \u003d \"\n              + maximumAllocation + \" [\u003d configuredMaxAllocation ]\" + \"\\n\"\n              + \"numContainers \u003d \" + numContainers\n              + \" [\u003d currentNumContainers ]\" + \"\\n\" + \"state \u003d \" + getState()\n              + \" [\u003d configuredState ]\" + \"\\n\" + \"acls \u003d \" + aclsString\n              + \" [\u003d configuredAcls ]\" + \"\\n\"\n              + \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\"\n              + \"rackLocalityAdditionalDelay \u003d \"\n              + rackLocalityAdditionalDelay + \"\\n\"\n              + \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\"\n              + \"reservationsContinueLooking \u003d \"\n              + reservationsContinueLooking + \"\\n\" + \"preemptionDisabled \u003d \"\n              + getPreemptionDisabled() + \"\\n\" + \"defaultAppPriorityPerQueue \u003d \"\n              + defaultAppPriorityPerQueue + \"\\npriority \u003d \" + priority);\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "7999318af12a75b35815461c601d4c25750e8340": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6344. Add parameter for rack locality delay in CapacityScheduler. (kkaranasos)\n",
      "commitDate": "10/04/17 3:34 PM",
      "commitName": "7999318af12a75b35815461c601d4c25750e8340",
      "commitAuthor": "Konstantinos Karanasos",
      "commitDateOld": "28/02/17 10:35 AM",
      "commitNameOld": "eac6b4c35c50e555c2f1b5f913bb2c4d839f1ff4",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 41.17,
      "commitsBetweenForRepo": 254,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,130 +1,134 @@\n   protected void setupQueueConfigs(Resource clusterResource)\n       throws IOException {\n     try {\n       writeLock.lock();\n       super.setupQueueConfigs(clusterResource);\n \n       this.lastClusterResource \u003d clusterResource;\n \n       this.cachedResourceLimitsForHeadroom \u003d new ResourceLimits(\n           clusterResource);\n \n       // Initialize headroom info, also used for calculating application\n       // master resource limits.  Since this happens during queue initialization\n       // and all queues may not be realized yet, we\u0027ll use (optimistic)\n       // absoluteMaxCapacity (it will be replaced with the more accurate\n       // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n       setQueueResourceLimitsInfo(clusterResource);\n \n       CapacitySchedulerConfiguration conf \u003d csContext.getConfiguration();\n \n       setOrderingPolicy(\n           conf.\u003cFiCaSchedulerApp\u003egetAppOrderingPolicy(getQueuePath()));\n \n       usersManager.setUserLimit(conf.getUserLimit(getQueuePath()));\n       usersManager.setUserLimitFactor(conf.getUserLimitFactor(getQueuePath()));\n \n       maxApplications \u003d conf.getMaximumApplicationsPerQueue(getQueuePath());\n       if (maxApplications \u003c 0) {\n         int maxGlobalPerQueueApps \u003d conf.getGlobalMaximumApplicationsPerQueue();\n         if (maxGlobalPerQueueApps \u003e 0) {\n           maxApplications \u003d maxGlobalPerQueueApps;\n         } else {\n           int maxSystemApps \u003d conf.getMaximumSystemApplications();\n           maxApplications \u003d\n               (int) (maxSystemApps * queueCapacities.getAbsoluteCapacity());\n         }\n       }\n       maxApplicationsPerUser \u003d Math.min(maxApplications,\n           (int) (maxApplications * (usersManager.getUserLimit() / 100.0f)\n               * usersManager.getUserLimitFactor()));\n \n       maxAMResourcePerQueuePercent \u003d\n           conf.getMaximumApplicationMasterResourcePerQueuePercent(\n               getQueuePath());\n \n       priorityAcls \u003d conf.getPriorityAcls(getQueuePath(),\n           scheduler.getMaxClusterLevelAppPriority());\n \n       if (!SchedulerUtils.checkQueueLabelExpression(this.accessibleLabels,\n           this.defaultLabelExpression, null)) {\n         throw new IOException(\n             \"Invalid default label expression of \" + \" queue\u003d\" + getQueueName()\n                 + \" doesn\u0027t have permission to access all labels \"\n                 + \"in default label expression. labelExpression of resource request\u003d\"\n                 + (this.defaultLabelExpression \u003d\u003d null ?\n                 \"\" :\n                 this.defaultLabelExpression) + \". Queue labels\u003d\" + (\n                 getAccessibleNodeLabels() \u003d\u003d null ?\n                     \"\" :\n                     StringUtils\n                         .join(getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n       }\n \n       nodeLocalityDelay \u003d conf.getNodeLocalityDelay();\n+      rackLocalityAdditionalDelay \u003d conf.getRackLocalityAdditionalDelay();\n       rackLocalityFullReset \u003d conf.getRackLocalityFullReset();\n \n       // re-init this since max allocation could have changed\n       this.minimumAllocationFactor \u003d Resources.ratio(resourceCalculator,\n           Resources.subtract(maximumAllocation, minimumAllocation),\n           maximumAllocation);\n \n       StringBuilder aclsString \u003d new StringBuilder();\n       for (Map.Entry\u003cAccessType, AccessControlList\u003e e : acls.entrySet()) {\n         aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n       }\n \n       StringBuilder labelStrBuilder \u003d new StringBuilder();\n       if (accessibleLabels !\u003d null) {\n         for (String s : accessibleLabels) {\n           labelStrBuilder.append(s);\n           labelStrBuilder.append(\",\");\n         }\n       }\n \n       defaultAppPriorityPerQueue \u003d Priority.newInstance(\n           conf.getDefaultApplicationPriorityConfPerQueue(getQueuePath()));\n \n       LOG.info(\n           \"Initializing \" + queueName + \"\\n\" + \"capacity \u003d \" + queueCapacities\n               .getCapacity() + \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\"\n               + \"absoluteCapacity \u003d \" + queueCapacities.getAbsoluteCapacity()\n               + \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\"\n               + \"maxCapacity \u003d \" + queueCapacities.getMaximumCapacity()\n               + \" [\u003d configuredMaxCapacity ]\" + \"\\n\" + \"absoluteMaxCapacity \u003d \"\n               + queueCapacities.getAbsoluteMaximumCapacity()\n               + \" [\u003d 1.0 maximumCapacity undefined, \"\n               + \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\"\n               + \"\\n\" + \"userLimit \u003d \" + usersManager.getUserLimit()\n               + \" [\u003d configuredUserLimit ]\" + \"\\n\" + \"userLimitFactor \u003d \"\n               + usersManager.getUserLimitFactor()\n               + \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" + \"maxApplications \u003d \"\n               + maxApplications\n               + \" [\u003d configuredMaximumSystemApplicationsPerQueue or\"\n               + \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\"\n               + \"\\n\" + \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser\n               + \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \"\n               + \"userLimitFactor) ]\" + \"\\n\" + \"usedCapacity \u003d \"\n               + queueCapacities.getUsedCapacity() + \" [\u003d usedResourcesMemory / \"\n               + \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\"\n               + \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity\n               + \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\"\n               + \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent\n               + \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\"\n               + \"minimumAllocationFactor \u003d \" + minimumAllocationFactor\n               + \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \"\n               + \"maximumAllocationMemory ]\" + \"\\n\" + \"maximumAllocation \u003d \"\n               + maximumAllocation + \" [\u003d configuredMaxAllocation ]\" + \"\\n\"\n               + \"numContainers \u003d \" + numContainers\n               + \" [\u003d currentNumContainers ]\" + \"\\n\" + \"state \u003d \" + getState()\n               + \" [\u003d configuredState ]\" + \"\\n\" + \"acls \u003d \" + aclsString\n-              + \" [\u003d configuredAcls ]\" + \"\\n\" + \"nodeLocalityDelay \u003d \"\n-              + nodeLocalityDelay + \"\\n\" + \"labels\u003d\" + labelStrBuilder\n-              .toString() + \"\\n\" + \"reservationsContinueLooking \u003d \"\n+              + \" [\u003d configuredAcls ]\" + \"\\n\"\n+              + \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\"\n+              + \"rackLocalityAdditionalDelay \u003d \"\n+              + rackLocalityAdditionalDelay + \"\\n\"\n+              + \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\"\n+              + \"reservationsContinueLooking \u003d \"\n               + reservationsContinueLooking + \"\\n\" + \"preemptionDisabled \u003d \"\n               + getPreemptionDisabled() + \"\\n\" + \"defaultAppPriorityPerQueue \u003d \"\n               + defaultAppPriorityPerQueue + \"\\npriority \u003d \" + priority);\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void setupQueueConfigs(Resource clusterResource)\n      throws IOException {\n    try {\n      writeLock.lock();\n      super.setupQueueConfigs(clusterResource);\n\n      this.lastClusterResource \u003d clusterResource;\n\n      this.cachedResourceLimitsForHeadroom \u003d new ResourceLimits(\n          clusterResource);\n\n      // Initialize headroom info, also used for calculating application\n      // master resource limits.  Since this happens during queue initialization\n      // and all queues may not be realized yet, we\u0027ll use (optimistic)\n      // absoluteMaxCapacity (it will be replaced with the more accurate\n      // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n      setQueueResourceLimitsInfo(clusterResource);\n\n      CapacitySchedulerConfiguration conf \u003d csContext.getConfiguration();\n\n      setOrderingPolicy(\n          conf.\u003cFiCaSchedulerApp\u003egetAppOrderingPolicy(getQueuePath()));\n\n      usersManager.setUserLimit(conf.getUserLimit(getQueuePath()));\n      usersManager.setUserLimitFactor(conf.getUserLimitFactor(getQueuePath()));\n\n      maxApplications \u003d conf.getMaximumApplicationsPerQueue(getQueuePath());\n      if (maxApplications \u003c 0) {\n        int maxGlobalPerQueueApps \u003d conf.getGlobalMaximumApplicationsPerQueue();\n        if (maxGlobalPerQueueApps \u003e 0) {\n          maxApplications \u003d maxGlobalPerQueueApps;\n        } else {\n          int maxSystemApps \u003d conf.getMaximumSystemApplications();\n          maxApplications \u003d\n              (int) (maxSystemApps * queueCapacities.getAbsoluteCapacity());\n        }\n      }\n      maxApplicationsPerUser \u003d Math.min(maxApplications,\n          (int) (maxApplications * (usersManager.getUserLimit() / 100.0f)\n              * usersManager.getUserLimitFactor()));\n\n      maxAMResourcePerQueuePercent \u003d\n          conf.getMaximumApplicationMasterResourcePerQueuePercent(\n              getQueuePath());\n\n      priorityAcls \u003d conf.getPriorityAcls(getQueuePath(),\n          scheduler.getMaxClusterLevelAppPriority());\n\n      if (!SchedulerUtils.checkQueueLabelExpression(this.accessibleLabels,\n          this.defaultLabelExpression, null)) {\n        throw new IOException(\n            \"Invalid default label expression of \" + \" queue\u003d\" + getQueueName()\n                + \" doesn\u0027t have permission to access all labels \"\n                + \"in default label expression. labelExpression of resource request\u003d\"\n                + (this.defaultLabelExpression \u003d\u003d null ?\n                \"\" :\n                this.defaultLabelExpression) + \". Queue labels\u003d\" + (\n                getAccessibleNodeLabels() \u003d\u003d null ?\n                    \"\" :\n                    StringUtils\n                        .join(getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n      }\n\n      nodeLocalityDelay \u003d conf.getNodeLocalityDelay();\n      rackLocalityAdditionalDelay \u003d conf.getRackLocalityAdditionalDelay();\n      rackLocalityFullReset \u003d conf.getRackLocalityFullReset();\n\n      // re-init this since max allocation could have changed\n      this.minimumAllocationFactor \u003d Resources.ratio(resourceCalculator,\n          Resources.subtract(maximumAllocation, minimumAllocation),\n          maximumAllocation);\n\n      StringBuilder aclsString \u003d new StringBuilder();\n      for (Map.Entry\u003cAccessType, AccessControlList\u003e e : acls.entrySet()) {\n        aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n      }\n\n      StringBuilder labelStrBuilder \u003d new StringBuilder();\n      if (accessibleLabels !\u003d null) {\n        for (String s : accessibleLabels) {\n          labelStrBuilder.append(s);\n          labelStrBuilder.append(\",\");\n        }\n      }\n\n      defaultAppPriorityPerQueue \u003d Priority.newInstance(\n          conf.getDefaultApplicationPriorityConfPerQueue(getQueuePath()));\n\n      LOG.info(\n          \"Initializing \" + queueName + \"\\n\" + \"capacity \u003d \" + queueCapacities\n              .getCapacity() + \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\"\n              + \"absoluteCapacity \u003d \" + queueCapacities.getAbsoluteCapacity()\n              + \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\"\n              + \"maxCapacity \u003d \" + queueCapacities.getMaximumCapacity()\n              + \" [\u003d configuredMaxCapacity ]\" + \"\\n\" + \"absoluteMaxCapacity \u003d \"\n              + queueCapacities.getAbsoluteMaximumCapacity()\n              + \" [\u003d 1.0 maximumCapacity undefined, \"\n              + \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\"\n              + \"\\n\" + \"userLimit \u003d \" + usersManager.getUserLimit()\n              + \" [\u003d configuredUserLimit ]\" + \"\\n\" + \"userLimitFactor \u003d \"\n              + usersManager.getUserLimitFactor()\n              + \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" + \"maxApplications \u003d \"\n              + maxApplications\n              + \" [\u003d configuredMaximumSystemApplicationsPerQueue or\"\n              + \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\"\n              + \"\\n\" + \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser\n              + \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \"\n              + \"userLimitFactor) ]\" + \"\\n\" + \"usedCapacity \u003d \"\n              + queueCapacities.getUsedCapacity() + \" [\u003d usedResourcesMemory / \"\n              + \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\"\n              + \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity\n              + \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\"\n              + \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent\n              + \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\"\n              + \"minimumAllocationFactor \u003d \" + minimumAllocationFactor\n              + \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \"\n              + \"maximumAllocationMemory ]\" + \"\\n\" + \"maximumAllocation \u003d \"\n              + maximumAllocation + \" [\u003d configuredMaxAllocation ]\" + \"\\n\"\n              + \"numContainers \u003d \" + numContainers\n              + \" [\u003d currentNumContainers ]\" + \"\\n\" + \"state \u003d \" + getState()\n              + \" [\u003d configuredState ]\" + \"\\n\" + \"acls \u003d \" + aclsString\n              + \" [\u003d configuredAcls ]\" + \"\\n\"\n              + \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\"\n              + \"rackLocalityAdditionalDelay \u003d \"\n              + rackLocalityAdditionalDelay + \"\\n\"\n              + \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\"\n              + \"reservationsContinueLooking \u003d \"\n              + reservationsContinueLooking + \"\\n\" + \"preemptionDisabled \u003d \"\n              + getPreemptionDisabled() + \"\\n\" + \"defaultAppPriorityPerQueue \u003d \"\n              + defaultAppPriorityPerQueue + \"\\npriority \u003d \" + priority);\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "5fb723bb77722d41df6959eee23e1b0cfeb5584e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5889. Improve and refactor user-limit calculation in Capacity Scheduler. (Sunil G via wangda)\n",
      "commitDate": "09/02/17 10:23 AM",
      "commitName": "5fb723bb77722d41df6959eee23e1b0cfeb5584e",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "23/01/17 10:52 AM",
      "commitNameOld": "ce832059db077fa95922198b066a737ed4f609fe",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 16.98,
      "commitsBetweenForRepo": 67,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,128 +1,130 @@\n   protected void setupQueueConfigs(Resource clusterResource)\n       throws IOException {\n     try {\n       writeLock.lock();\n       super.setupQueueConfigs(clusterResource);\n \n       this.lastClusterResource \u003d clusterResource;\n \n       this.cachedResourceLimitsForHeadroom \u003d new ResourceLimits(\n           clusterResource);\n \n       // Initialize headroom info, also used for calculating application\n       // master resource limits.  Since this happens during queue initialization\n       // and all queues may not be realized yet, we\u0027ll use (optimistic)\n       // absoluteMaxCapacity (it will be replaced with the more accurate\n       // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n       setQueueResourceLimitsInfo(clusterResource);\n \n       CapacitySchedulerConfiguration conf \u003d csContext.getConfiguration();\n \n       setOrderingPolicy(\n           conf.\u003cFiCaSchedulerApp\u003egetAppOrderingPolicy(getQueuePath()));\n \n-      userLimit \u003d conf.getUserLimit(getQueuePath());\n-      userLimitFactor \u003d conf.getUserLimitFactor(getQueuePath());\n+      usersManager.setUserLimit(conf.getUserLimit(getQueuePath()));\n+      usersManager.setUserLimitFactor(conf.getUserLimitFactor(getQueuePath()));\n \n       maxApplications \u003d conf.getMaximumApplicationsPerQueue(getQueuePath());\n       if (maxApplications \u003c 0) {\n         int maxGlobalPerQueueApps \u003d conf.getGlobalMaximumApplicationsPerQueue();\n         if (maxGlobalPerQueueApps \u003e 0) {\n           maxApplications \u003d maxGlobalPerQueueApps;\n         } else {\n           int maxSystemApps \u003d conf.getMaximumSystemApplications();\n           maxApplications \u003d\n               (int) (maxSystemApps * queueCapacities.getAbsoluteCapacity());\n         }\n       }\n       maxApplicationsPerUser \u003d Math.min(maxApplications,\n-          (int) (maxApplications * (userLimit / 100.0f) * userLimitFactor));\n+          (int) (maxApplications * (usersManager.getUserLimit() / 100.0f)\n+              * usersManager.getUserLimitFactor()));\n \n       maxAMResourcePerQueuePercent \u003d\n           conf.getMaximumApplicationMasterResourcePerQueuePercent(\n               getQueuePath());\n \n       priorityAcls \u003d conf.getPriorityAcls(getQueuePath(),\n           scheduler.getMaxClusterLevelAppPriority());\n \n       if (!SchedulerUtils.checkQueueLabelExpression(this.accessibleLabels,\n           this.defaultLabelExpression, null)) {\n         throw new IOException(\n             \"Invalid default label expression of \" + \" queue\u003d\" + getQueueName()\n                 + \" doesn\u0027t have permission to access all labels \"\n                 + \"in default label expression. labelExpression of resource request\u003d\"\n                 + (this.defaultLabelExpression \u003d\u003d null ?\n                 \"\" :\n                 this.defaultLabelExpression) + \". Queue labels\u003d\" + (\n                 getAccessibleNodeLabels() \u003d\u003d null ?\n                     \"\" :\n                     StringUtils\n                         .join(getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n       }\n \n       nodeLocalityDelay \u003d conf.getNodeLocalityDelay();\n       rackLocalityFullReset \u003d conf.getRackLocalityFullReset();\n \n       // re-init this since max allocation could have changed\n       this.minimumAllocationFactor \u003d Resources.ratio(resourceCalculator,\n           Resources.subtract(maximumAllocation, minimumAllocation),\n           maximumAllocation);\n \n       StringBuilder aclsString \u003d new StringBuilder();\n       for (Map.Entry\u003cAccessType, AccessControlList\u003e e : acls.entrySet()) {\n         aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n       }\n \n       StringBuilder labelStrBuilder \u003d new StringBuilder();\n       if (accessibleLabels !\u003d null) {\n         for (String s : accessibleLabels) {\n           labelStrBuilder.append(s);\n           labelStrBuilder.append(\",\");\n         }\n       }\n \n       defaultAppPriorityPerQueue \u003d Priority.newInstance(\n           conf.getDefaultApplicationPriorityConfPerQueue(getQueuePath()));\n \n       LOG.info(\n           \"Initializing \" + queueName + \"\\n\" + \"capacity \u003d \" + queueCapacities\n               .getCapacity() + \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\"\n               + \"absoluteCapacity \u003d \" + queueCapacities.getAbsoluteCapacity()\n               + \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\"\n               + \"maxCapacity \u003d \" + queueCapacities.getMaximumCapacity()\n               + \" [\u003d configuredMaxCapacity ]\" + \"\\n\" + \"absoluteMaxCapacity \u003d \"\n               + queueCapacities.getAbsoluteMaximumCapacity()\n               + \" [\u003d 1.0 maximumCapacity undefined, \"\n               + \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\"\n-              + \"\\n\" + \"userLimit \u003d \" + userLimit + \" [\u003d configuredUserLimit ]\"\n-              + \"\\n\" + \"userLimitFactor \u003d \" + userLimitFactor\n+              + \"\\n\" + \"userLimit \u003d \" + usersManager.getUserLimit()\n+              + \" [\u003d configuredUserLimit ]\" + \"\\n\" + \"userLimitFactor \u003d \"\n+              + usersManager.getUserLimitFactor()\n               + \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" + \"maxApplications \u003d \"\n               + maxApplications\n               + \" [\u003d configuredMaximumSystemApplicationsPerQueue or\"\n               + \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\"\n               + \"\\n\" + \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser\n               + \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \"\n               + \"userLimitFactor) ]\" + \"\\n\" + \"usedCapacity \u003d \"\n               + queueCapacities.getUsedCapacity() + \" [\u003d usedResourcesMemory / \"\n               + \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\"\n               + \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity\n               + \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\"\n               + \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent\n               + \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\"\n               + \"minimumAllocationFactor \u003d \" + minimumAllocationFactor\n               + \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \"\n               + \"maximumAllocationMemory ]\" + \"\\n\" + \"maximumAllocation \u003d \"\n               + maximumAllocation + \" [\u003d configuredMaxAllocation ]\" + \"\\n\"\n               + \"numContainers \u003d \" + numContainers\n               + \" [\u003d currentNumContainers ]\" + \"\\n\" + \"state \u003d \" + getState()\n               + \" [\u003d configuredState ]\" + \"\\n\" + \"acls \u003d \" + aclsString\n               + \" [\u003d configuredAcls ]\" + \"\\n\" + \"nodeLocalityDelay \u003d \"\n               + nodeLocalityDelay + \"\\n\" + \"labels\u003d\" + labelStrBuilder\n               .toString() + \"\\n\" + \"reservationsContinueLooking \u003d \"\n               + reservationsContinueLooking + \"\\n\" + \"preemptionDisabled \u003d \"\n               + getPreemptionDisabled() + \"\\n\" + \"defaultAppPriorityPerQueue \u003d \"\n               + defaultAppPriorityPerQueue + \"\\npriority \u003d \" + priority);\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void setupQueueConfigs(Resource clusterResource)\n      throws IOException {\n    try {\n      writeLock.lock();\n      super.setupQueueConfigs(clusterResource);\n\n      this.lastClusterResource \u003d clusterResource;\n\n      this.cachedResourceLimitsForHeadroom \u003d new ResourceLimits(\n          clusterResource);\n\n      // Initialize headroom info, also used for calculating application\n      // master resource limits.  Since this happens during queue initialization\n      // and all queues may not be realized yet, we\u0027ll use (optimistic)\n      // absoluteMaxCapacity (it will be replaced with the more accurate\n      // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n      setQueueResourceLimitsInfo(clusterResource);\n\n      CapacitySchedulerConfiguration conf \u003d csContext.getConfiguration();\n\n      setOrderingPolicy(\n          conf.\u003cFiCaSchedulerApp\u003egetAppOrderingPolicy(getQueuePath()));\n\n      usersManager.setUserLimit(conf.getUserLimit(getQueuePath()));\n      usersManager.setUserLimitFactor(conf.getUserLimitFactor(getQueuePath()));\n\n      maxApplications \u003d conf.getMaximumApplicationsPerQueue(getQueuePath());\n      if (maxApplications \u003c 0) {\n        int maxGlobalPerQueueApps \u003d conf.getGlobalMaximumApplicationsPerQueue();\n        if (maxGlobalPerQueueApps \u003e 0) {\n          maxApplications \u003d maxGlobalPerQueueApps;\n        } else {\n          int maxSystemApps \u003d conf.getMaximumSystemApplications();\n          maxApplications \u003d\n              (int) (maxSystemApps * queueCapacities.getAbsoluteCapacity());\n        }\n      }\n      maxApplicationsPerUser \u003d Math.min(maxApplications,\n          (int) (maxApplications * (usersManager.getUserLimit() / 100.0f)\n              * usersManager.getUserLimitFactor()));\n\n      maxAMResourcePerQueuePercent \u003d\n          conf.getMaximumApplicationMasterResourcePerQueuePercent(\n              getQueuePath());\n\n      priorityAcls \u003d conf.getPriorityAcls(getQueuePath(),\n          scheduler.getMaxClusterLevelAppPriority());\n\n      if (!SchedulerUtils.checkQueueLabelExpression(this.accessibleLabels,\n          this.defaultLabelExpression, null)) {\n        throw new IOException(\n            \"Invalid default label expression of \" + \" queue\u003d\" + getQueueName()\n                + \" doesn\u0027t have permission to access all labels \"\n                + \"in default label expression. labelExpression of resource request\u003d\"\n                + (this.defaultLabelExpression \u003d\u003d null ?\n                \"\" :\n                this.defaultLabelExpression) + \". Queue labels\u003d\" + (\n                getAccessibleNodeLabels() \u003d\u003d null ?\n                    \"\" :\n                    StringUtils\n                        .join(getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n      }\n\n      nodeLocalityDelay \u003d conf.getNodeLocalityDelay();\n      rackLocalityFullReset \u003d conf.getRackLocalityFullReset();\n\n      // re-init this since max allocation could have changed\n      this.minimumAllocationFactor \u003d Resources.ratio(resourceCalculator,\n          Resources.subtract(maximumAllocation, minimumAllocation),\n          maximumAllocation);\n\n      StringBuilder aclsString \u003d new StringBuilder();\n      for (Map.Entry\u003cAccessType, AccessControlList\u003e e : acls.entrySet()) {\n        aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n      }\n\n      StringBuilder labelStrBuilder \u003d new StringBuilder();\n      if (accessibleLabels !\u003d null) {\n        for (String s : accessibleLabels) {\n          labelStrBuilder.append(s);\n          labelStrBuilder.append(\",\");\n        }\n      }\n\n      defaultAppPriorityPerQueue \u003d Priority.newInstance(\n          conf.getDefaultApplicationPriorityConfPerQueue(getQueuePath()));\n\n      LOG.info(\n          \"Initializing \" + queueName + \"\\n\" + \"capacity \u003d \" + queueCapacities\n              .getCapacity() + \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\"\n              + \"absoluteCapacity \u003d \" + queueCapacities.getAbsoluteCapacity()\n              + \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\"\n              + \"maxCapacity \u003d \" + queueCapacities.getMaximumCapacity()\n              + \" [\u003d configuredMaxCapacity ]\" + \"\\n\" + \"absoluteMaxCapacity \u003d \"\n              + queueCapacities.getAbsoluteMaximumCapacity()\n              + \" [\u003d 1.0 maximumCapacity undefined, \"\n              + \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\"\n              + \"\\n\" + \"userLimit \u003d \" + usersManager.getUserLimit()\n              + \" [\u003d configuredUserLimit ]\" + \"\\n\" + \"userLimitFactor \u003d \"\n              + usersManager.getUserLimitFactor()\n              + \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" + \"maxApplications \u003d \"\n              + maxApplications\n              + \" [\u003d configuredMaximumSystemApplicationsPerQueue or\"\n              + \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\"\n              + \"\\n\" + \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser\n              + \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \"\n              + \"userLimitFactor) ]\" + \"\\n\" + \"usedCapacity \u003d \"\n              + queueCapacities.getUsedCapacity() + \" [\u003d usedResourcesMemory / \"\n              + \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\"\n              + \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity\n              + \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\"\n              + \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent\n              + \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\"\n              + \"minimumAllocationFactor \u003d \" + minimumAllocationFactor\n              + \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \"\n              + \"maximumAllocationMemory ]\" + \"\\n\" + \"maximumAllocation \u003d \"\n              + maximumAllocation + \" [\u003d configuredMaxAllocation ]\" + \"\\n\"\n              + \"numContainers \u003d \" + numContainers\n              + \" [\u003d currentNumContainers ]\" + \"\\n\" + \"state \u003d \" + getState()\n              + \" [\u003d configuredState ]\" + \"\\n\" + \"acls \u003d \" + aclsString\n              + \" [\u003d configuredAcls ]\" + \"\\n\" + \"nodeLocalityDelay \u003d \"\n              + nodeLocalityDelay + \"\\n\" + \"labels\u003d\" + labelStrBuilder\n              .toString() + \"\\n\" + \"reservationsContinueLooking \u003d \"\n              + reservationsContinueLooking + \"\\n\" + \"preemptionDisabled \u003d \"\n              + getPreemptionDisabled() + \"\\n\" + \"defaultAppPriorityPerQueue \u003d \"\n              + defaultAppPriorityPerQueue + \"\\npriority \u003d \" + priority);\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "ce832059db077fa95922198b066a737ed4f609fe": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5864. Capacity Scheduler - Queue Priorities. (wangda)\n",
      "commitDate": "23/01/17 10:52 AM",
      "commitName": "ce832059db077fa95922198b066a737ed4f609fe",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "13/01/17 4:52 AM",
      "commitNameOld": "d3170f9eba9bc5c38b5fa50c24e37ca2bd5636c2",
      "commitAuthorOld": "Sunil G",
      "daysBetweenCommits": 10.25,
      "commitsBetweenForRepo": 55,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,128 +1,128 @@\n   protected void setupQueueConfigs(Resource clusterResource)\n       throws IOException {\n     try {\n       writeLock.lock();\n       super.setupQueueConfigs(clusterResource);\n \n       this.lastClusterResource \u003d clusterResource;\n \n       this.cachedResourceLimitsForHeadroom \u003d new ResourceLimits(\n           clusterResource);\n \n       // Initialize headroom info, also used for calculating application\n       // master resource limits.  Since this happens during queue initialization\n       // and all queues may not be realized yet, we\u0027ll use (optimistic)\n       // absoluteMaxCapacity (it will be replaced with the more accurate\n       // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n       setQueueResourceLimitsInfo(clusterResource);\n \n       CapacitySchedulerConfiguration conf \u003d csContext.getConfiguration();\n \n       setOrderingPolicy(\n-          conf.\u003cFiCaSchedulerApp\u003egetOrderingPolicy(getQueuePath()));\n+          conf.\u003cFiCaSchedulerApp\u003egetAppOrderingPolicy(getQueuePath()));\n \n       userLimit \u003d conf.getUserLimit(getQueuePath());\n       userLimitFactor \u003d conf.getUserLimitFactor(getQueuePath());\n \n       maxApplications \u003d conf.getMaximumApplicationsPerQueue(getQueuePath());\n       if (maxApplications \u003c 0) {\n         int maxGlobalPerQueueApps \u003d conf.getGlobalMaximumApplicationsPerQueue();\n         if (maxGlobalPerQueueApps \u003e 0) {\n           maxApplications \u003d maxGlobalPerQueueApps;\n         } else {\n           int maxSystemApps \u003d conf.getMaximumSystemApplications();\n           maxApplications \u003d\n               (int) (maxSystemApps * queueCapacities.getAbsoluteCapacity());\n         }\n       }\n       maxApplicationsPerUser \u003d Math.min(maxApplications,\n           (int) (maxApplications * (userLimit / 100.0f) * userLimitFactor));\n \n       maxAMResourcePerQueuePercent \u003d\n           conf.getMaximumApplicationMasterResourcePerQueuePercent(\n               getQueuePath());\n \n       priorityAcls \u003d conf.getPriorityAcls(getQueuePath(),\n           scheduler.getMaxClusterLevelAppPriority());\n \n       if (!SchedulerUtils.checkQueueLabelExpression(this.accessibleLabels,\n           this.defaultLabelExpression, null)) {\n         throw new IOException(\n             \"Invalid default label expression of \" + \" queue\u003d\" + getQueueName()\n                 + \" doesn\u0027t have permission to access all labels \"\n                 + \"in default label expression. labelExpression of resource request\u003d\"\n                 + (this.defaultLabelExpression \u003d\u003d null ?\n                 \"\" :\n                 this.defaultLabelExpression) + \". Queue labels\u003d\" + (\n                 getAccessibleNodeLabels() \u003d\u003d null ?\n                     \"\" :\n                     StringUtils\n                         .join(getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n       }\n \n       nodeLocalityDelay \u003d conf.getNodeLocalityDelay();\n       rackLocalityFullReset \u003d conf.getRackLocalityFullReset();\n \n       // re-init this since max allocation could have changed\n       this.minimumAllocationFactor \u003d Resources.ratio(resourceCalculator,\n           Resources.subtract(maximumAllocation, minimumAllocation),\n           maximumAllocation);\n \n       StringBuilder aclsString \u003d new StringBuilder();\n       for (Map.Entry\u003cAccessType, AccessControlList\u003e e : acls.entrySet()) {\n         aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n       }\n \n       StringBuilder labelStrBuilder \u003d new StringBuilder();\n       if (accessibleLabels !\u003d null) {\n         for (String s : accessibleLabels) {\n           labelStrBuilder.append(s);\n           labelStrBuilder.append(\",\");\n         }\n       }\n \n       defaultAppPriorityPerQueue \u003d Priority.newInstance(\n           conf.getDefaultApplicationPriorityConfPerQueue(getQueuePath()));\n \n       LOG.info(\n           \"Initializing \" + queueName + \"\\n\" + \"capacity \u003d \" + queueCapacities\n               .getCapacity() + \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\"\n               + \"absoluteCapacity \u003d \" + queueCapacities.getAbsoluteCapacity()\n               + \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\"\n               + \"maxCapacity \u003d \" + queueCapacities.getMaximumCapacity()\n               + \" [\u003d configuredMaxCapacity ]\" + \"\\n\" + \"absoluteMaxCapacity \u003d \"\n               + queueCapacities.getAbsoluteMaximumCapacity()\n               + \" [\u003d 1.0 maximumCapacity undefined, \"\n               + \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\"\n               + \"\\n\" + \"userLimit \u003d \" + userLimit + \" [\u003d configuredUserLimit ]\"\n               + \"\\n\" + \"userLimitFactor \u003d \" + userLimitFactor\n               + \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" + \"maxApplications \u003d \"\n               + maxApplications\n               + \" [\u003d configuredMaximumSystemApplicationsPerQueue or\"\n               + \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\"\n               + \"\\n\" + \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser\n               + \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \"\n               + \"userLimitFactor) ]\" + \"\\n\" + \"usedCapacity \u003d \"\n               + queueCapacities.getUsedCapacity() + \" [\u003d usedResourcesMemory / \"\n               + \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\"\n               + \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity\n               + \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\"\n               + \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent\n               + \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\"\n               + \"minimumAllocationFactor \u003d \" + minimumAllocationFactor\n               + \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \"\n               + \"maximumAllocationMemory ]\" + \"\\n\" + \"maximumAllocation \u003d \"\n               + maximumAllocation + \" [\u003d configuredMaxAllocation ]\" + \"\\n\"\n               + \"numContainers \u003d \" + numContainers\n               + \" [\u003d currentNumContainers ]\" + \"\\n\" + \"state \u003d \" + getState()\n               + \" [\u003d configuredState ]\" + \"\\n\" + \"acls \u003d \" + aclsString\n               + \" [\u003d configuredAcls ]\" + \"\\n\" + \"nodeLocalityDelay \u003d \"\n               + nodeLocalityDelay + \"\\n\" + \"labels\u003d\" + labelStrBuilder\n               .toString() + \"\\n\" + \"reservationsContinueLooking \u003d \"\n               + reservationsContinueLooking + \"\\n\" + \"preemptionDisabled \u003d \"\n               + getPreemptionDisabled() + \"\\n\" + \"defaultAppPriorityPerQueue \u003d \"\n-              + defaultAppPriorityPerQueue);\n+              + defaultAppPriorityPerQueue + \"\\npriority \u003d \" + priority);\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void setupQueueConfigs(Resource clusterResource)\n      throws IOException {\n    try {\n      writeLock.lock();\n      super.setupQueueConfigs(clusterResource);\n\n      this.lastClusterResource \u003d clusterResource;\n\n      this.cachedResourceLimitsForHeadroom \u003d new ResourceLimits(\n          clusterResource);\n\n      // Initialize headroom info, also used for calculating application\n      // master resource limits.  Since this happens during queue initialization\n      // and all queues may not be realized yet, we\u0027ll use (optimistic)\n      // absoluteMaxCapacity (it will be replaced with the more accurate\n      // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n      setQueueResourceLimitsInfo(clusterResource);\n\n      CapacitySchedulerConfiguration conf \u003d csContext.getConfiguration();\n\n      setOrderingPolicy(\n          conf.\u003cFiCaSchedulerApp\u003egetAppOrderingPolicy(getQueuePath()));\n\n      userLimit \u003d conf.getUserLimit(getQueuePath());\n      userLimitFactor \u003d conf.getUserLimitFactor(getQueuePath());\n\n      maxApplications \u003d conf.getMaximumApplicationsPerQueue(getQueuePath());\n      if (maxApplications \u003c 0) {\n        int maxGlobalPerQueueApps \u003d conf.getGlobalMaximumApplicationsPerQueue();\n        if (maxGlobalPerQueueApps \u003e 0) {\n          maxApplications \u003d maxGlobalPerQueueApps;\n        } else {\n          int maxSystemApps \u003d conf.getMaximumSystemApplications();\n          maxApplications \u003d\n              (int) (maxSystemApps * queueCapacities.getAbsoluteCapacity());\n        }\n      }\n      maxApplicationsPerUser \u003d Math.min(maxApplications,\n          (int) (maxApplications * (userLimit / 100.0f) * userLimitFactor));\n\n      maxAMResourcePerQueuePercent \u003d\n          conf.getMaximumApplicationMasterResourcePerQueuePercent(\n              getQueuePath());\n\n      priorityAcls \u003d conf.getPriorityAcls(getQueuePath(),\n          scheduler.getMaxClusterLevelAppPriority());\n\n      if (!SchedulerUtils.checkQueueLabelExpression(this.accessibleLabels,\n          this.defaultLabelExpression, null)) {\n        throw new IOException(\n            \"Invalid default label expression of \" + \" queue\u003d\" + getQueueName()\n                + \" doesn\u0027t have permission to access all labels \"\n                + \"in default label expression. labelExpression of resource request\u003d\"\n                + (this.defaultLabelExpression \u003d\u003d null ?\n                \"\" :\n                this.defaultLabelExpression) + \". Queue labels\u003d\" + (\n                getAccessibleNodeLabels() \u003d\u003d null ?\n                    \"\" :\n                    StringUtils\n                        .join(getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n      }\n\n      nodeLocalityDelay \u003d conf.getNodeLocalityDelay();\n      rackLocalityFullReset \u003d conf.getRackLocalityFullReset();\n\n      // re-init this since max allocation could have changed\n      this.minimumAllocationFactor \u003d Resources.ratio(resourceCalculator,\n          Resources.subtract(maximumAllocation, minimumAllocation),\n          maximumAllocation);\n\n      StringBuilder aclsString \u003d new StringBuilder();\n      for (Map.Entry\u003cAccessType, AccessControlList\u003e e : acls.entrySet()) {\n        aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n      }\n\n      StringBuilder labelStrBuilder \u003d new StringBuilder();\n      if (accessibleLabels !\u003d null) {\n        for (String s : accessibleLabels) {\n          labelStrBuilder.append(s);\n          labelStrBuilder.append(\",\");\n        }\n      }\n\n      defaultAppPriorityPerQueue \u003d Priority.newInstance(\n          conf.getDefaultApplicationPriorityConfPerQueue(getQueuePath()));\n\n      LOG.info(\n          \"Initializing \" + queueName + \"\\n\" + \"capacity \u003d \" + queueCapacities\n              .getCapacity() + \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\"\n              + \"absoluteCapacity \u003d \" + queueCapacities.getAbsoluteCapacity()\n              + \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\"\n              + \"maxCapacity \u003d \" + queueCapacities.getMaximumCapacity()\n              + \" [\u003d configuredMaxCapacity ]\" + \"\\n\" + \"absoluteMaxCapacity \u003d \"\n              + queueCapacities.getAbsoluteMaximumCapacity()\n              + \" [\u003d 1.0 maximumCapacity undefined, \"\n              + \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\"\n              + \"\\n\" + \"userLimit \u003d \" + userLimit + \" [\u003d configuredUserLimit ]\"\n              + \"\\n\" + \"userLimitFactor \u003d \" + userLimitFactor\n              + \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" + \"maxApplications \u003d \"\n              + maxApplications\n              + \" [\u003d configuredMaximumSystemApplicationsPerQueue or\"\n              + \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\"\n              + \"\\n\" + \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser\n              + \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \"\n              + \"userLimitFactor) ]\" + \"\\n\" + \"usedCapacity \u003d \"\n              + queueCapacities.getUsedCapacity() + \" [\u003d usedResourcesMemory / \"\n              + \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\"\n              + \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity\n              + \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\"\n              + \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent\n              + \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\"\n              + \"minimumAllocationFactor \u003d \" + minimumAllocationFactor\n              + \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \"\n              + \"maximumAllocationMemory ]\" + \"\\n\" + \"maximumAllocation \u003d \"\n              + maximumAllocation + \" [\u003d configuredMaxAllocation ]\" + \"\\n\"\n              + \"numContainers \u003d \" + numContainers\n              + \" [\u003d currentNumContainers ]\" + \"\\n\" + \"state \u003d \" + getState()\n              + \" [\u003d configuredState ]\" + \"\\n\" + \"acls \u003d \" + aclsString\n              + \" [\u003d configuredAcls ]\" + \"\\n\" + \"nodeLocalityDelay \u003d \"\n              + nodeLocalityDelay + \"\\n\" + \"labels\u003d\" + labelStrBuilder\n              .toString() + \"\\n\" + \"reservationsContinueLooking \u003d \"\n              + reservationsContinueLooking + \"\\n\" + \"preemptionDisabled \u003d \"\n              + getPreemptionDisabled() + \"\\n\" + \"defaultAppPriorityPerQueue \u003d \"\n              + defaultAppPriorityPerQueue + \"\\npriority \u003d \" + priority);\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "287d3d6804a869723ae36605a3c2d2b3eae3941e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3955. Support for application priority ACLs in queues of CapacityScheduler. (Sunil G via wangda)\n",
      "commitDate": "09/01/17 8:40 AM",
      "commitName": "287d3d6804a869723ae36605a3c2d2b3eae3941e",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "27/12/16 9:18 PM",
      "commitNameOld": "0840b4329b2428b20b862f70d72cbdcd6d1618ed",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 12.47,
      "commitsBetweenForRepo": 49,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,125 +1,128 @@\n   protected void setupQueueConfigs(Resource clusterResource)\n       throws IOException {\n     try {\n       writeLock.lock();\n       super.setupQueueConfigs(clusterResource);\n \n       this.lastClusterResource \u003d clusterResource;\n \n       this.cachedResourceLimitsForHeadroom \u003d new ResourceLimits(\n           clusterResource);\n \n       // Initialize headroom info, also used for calculating application\n       // master resource limits.  Since this happens during queue initialization\n       // and all queues may not be realized yet, we\u0027ll use (optimistic)\n       // absoluteMaxCapacity (it will be replaced with the more accurate\n       // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n       setQueueResourceLimitsInfo(clusterResource);\n \n       CapacitySchedulerConfiguration conf \u003d csContext.getConfiguration();\n \n       setOrderingPolicy(\n           conf.\u003cFiCaSchedulerApp\u003egetOrderingPolicy(getQueuePath()));\n \n       userLimit \u003d conf.getUserLimit(getQueuePath());\n       userLimitFactor \u003d conf.getUserLimitFactor(getQueuePath());\n \n       maxApplications \u003d conf.getMaximumApplicationsPerQueue(getQueuePath());\n       if (maxApplications \u003c 0) {\n         int maxGlobalPerQueueApps \u003d conf.getGlobalMaximumApplicationsPerQueue();\n         if (maxGlobalPerQueueApps \u003e 0) {\n           maxApplications \u003d maxGlobalPerQueueApps;\n         } else {\n           int maxSystemApps \u003d conf.getMaximumSystemApplications();\n           maxApplications \u003d\n               (int) (maxSystemApps * queueCapacities.getAbsoluteCapacity());\n         }\n       }\n       maxApplicationsPerUser \u003d Math.min(maxApplications,\n           (int) (maxApplications * (userLimit / 100.0f) * userLimitFactor));\n \n       maxAMResourcePerQueuePercent \u003d\n           conf.getMaximumApplicationMasterResourcePerQueuePercent(\n               getQueuePath());\n \n+      priorityAcls \u003d conf.getPriorityAcls(getQueuePath(),\n+          scheduler.getMaxClusterLevelAppPriority());\n+\n       if (!SchedulerUtils.checkQueueLabelExpression(this.accessibleLabels,\n           this.defaultLabelExpression, null)) {\n         throw new IOException(\n             \"Invalid default label expression of \" + \" queue\u003d\" + getQueueName()\n                 + \" doesn\u0027t have permission to access all labels \"\n                 + \"in default label expression. labelExpression of resource request\u003d\"\n                 + (this.defaultLabelExpression \u003d\u003d null ?\n                 \"\" :\n                 this.defaultLabelExpression) + \". Queue labels\u003d\" + (\n                 getAccessibleNodeLabels() \u003d\u003d null ?\n                     \"\" :\n                     StringUtils\n                         .join(getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n       }\n \n       nodeLocalityDelay \u003d conf.getNodeLocalityDelay();\n       rackLocalityFullReset \u003d conf.getRackLocalityFullReset();\n \n       // re-init this since max allocation could have changed\n       this.minimumAllocationFactor \u003d Resources.ratio(resourceCalculator,\n           Resources.subtract(maximumAllocation, minimumAllocation),\n           maximumAllocation);\n \n       StringBuilder aclsString \u003d new StringBuilder();\n       for (Map.Entry\u003cAccessType, AccessControlList\u003e e : acls.entrySet()) {\n         aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n       }\n \n       StringBuilder labelStrBuilder \u003d new StringBuilder();\n       if (accessibleLabels !\u003d null) {\n         for (String s : accessibleLabels) {\n           labelStrBuilder.append(s);\n           labelStrBuilder.append(\",\");\n         }\n       }\n \n       defaultAppPriorityPerQueue \u003d Priority.newInstance(\n           conf.getDefaultApplicationPriorityConfPerQueue(getQueuePath()));\n \n       LOG.info(\n           \"Initializing \" + queueName + \"\\n\" + \"capacity \u003d \" + queueCapacities\n               .getCapacity() + \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\"\n               + \"absoluteCapacity \u003d \" + queueCapacities.getAbsoluteCapacity()\n               + \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\"\n               + \"maxCapacity \u003d \" + queueCapacities.getMaximumCapacity()\n               + \" [\u003d configuredMaxCapacity ]\" + \"\\n\" + \"absoluteMaxCapacity \u003d \"\n               + queueCapacities.getAbsoluteMaximumCapacity()\n               + \" [\u003d 1.0 maximumCapacity undefined, \"\n               + \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\"\n               + \"\\n\" + \"userLimit \u003d \" + userLimit + \" [\u003d configuredUserLimit ]\"\n               + \"\\n\" + \"userLimitFactor \u003d \" + userLimitFactor\n               + \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" + \"maxApplications \u003d \"\n               + maxApplications\n               + \" [\u003d configuredMaximumSystemApplicationsPerQueue or\"\n               + \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\"\n               + \"\\n\" + \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser\n               + \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \"\n               + \"userLimitFactor) ]\" + \"\\n\" + \"usedCapacity \u003d \"\n               + queueCapacities.getUsedCapacity() + \" [\u003d usedResourcesMemory / \"\n               + \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\"\n               + \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity\n               + \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\"\n               + \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent\n               + \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\"\n               + \"minimumAllocationFactor \u003d \" + minimumAllocationFactor\n               + \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \"\n               + \"maximumAllocationMemory ]\" + \"\\n\" + \"maximumAllocation \u003d \"\n               + maximumAllocation + \" [\u003d configuredMaxAllocation ]\" + \"\\n\"\n               + \"numContainers \u003d \" + numContainers\n               + \" [\u003d currentNumContainers ]\" + \"\\n\" + \"state \u003d \" + getState()\n               + \" [\u003d configuredState ]\" + \"\\n\" + \"acls \u003d \" + aclsString\n               + \" [\u003d configuredAcls ]\" + \"\\n\" + \"nodeLocalityDelay \u003d \"\n               + nodeLocalityDelay + \"\\n\" + \"labels\u003d\" + labelStrBuilder\n               .toString() + \"\\n\" + \"reservationsContinueLooking \u003d \"\n               + reservationsContinueLooking + \"\\n\" + \"preemptionDisabled \u003d \"\n               + getPreemptionDisabled() + \"\\n\" + \"defaultAppPriorityPerQueue \u003d \"\n               + defaultAppPriorityPerQueue);\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void setupQueueConfigs(Resource clusterResource)\n      throws IOException {\n    try {\n      writeLock.lock();\n      super.setupQueueConfigs(clusterResource);\n\n      this.lastClusterResource \u003d clusterResource;\n\n      this.cachedResourceLimitsForHeadroom \u003d new ResourceLimits(\n          clusterResource);\n\n      // Initialize headroom info, also used for calculating application\n      // master resource limits.  Since this happens during queue initialization\n      // and all queues may not be realized yet, we\u0027ll use (optimistic)\n      // absoluteMaxCapacity (it will be replaced with the more accurate\n      // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n      setQueueResourceLimitsInfo(clusterResource);\n\n      CapacitySchedulerConfiguration conf \u003d csContext.getConfiguration();\n\n      setOrderingPolicy(\n          conf.\u003cFiCaSchedulerApp\u003egetOrderingPolicy(getQueuePath()));\n\n      userLimit \u003d conf.getUserLimit(getQueuePath());\n      userLimitFactor \u003d conf.getUserLimitFactor(getQueuePath());\n\n      maxApplications \u003d conf.getMaximumApplicationsPerQueue(getQueuePath());\n      if (maxApplications \u003c 0) {\n        int maxGlobalPerQueueApps \u003d conf.getGlobalMaximumApplicationsPerQueue();\n        if (maxGlobalPerQueueApps \u003e 0) {\n          maxApplications \u003d maxGlobalPerQueueApps;\n        } else {\n          int maxSystemApps \u003d conf.getMaximumSystemApplications();\n          maxApplications \u003d\n              (int) (maxSystemApps * queueCapacities.getAbsoluteCapacity());\n        }\n      }\n      maxApplicationsPerUser \u003d Math.min(maxApplications,\n          (int) (maxApplications * (userLimit / 100.0f) * userLimitFactor));\n\n      maxAMResourcePerQueuePercent \u003d\n          conf.getMaximumApplicationMasterResourcePerQueuePercent(\n              getQueuePath());\n\n      priorityAcls \u003d conf.getPriorityAcls(getQueuePath(),\n          scheduler.getMaxClusterLevelAppPriority());\n\n      if (!SchedulerUtils.checkQueueLabelExpression(this.accessibleLabels,\n          this.defaultLabelExpression, null)) {\n        throw new IOException(\n            \"Invalid default label expression of \" + \" queue\u003d\" + getQueueName()\n                + \" doesn\u0027t have permission to access all labels \"\n                + \"in default label expression. labelExpression of resource request\u003d\"\n                + (this.defaultLabelExpression \u003d\u003d null ?\n                \"\" :\n                this.defaultLabelExpression) + \". Queue labels\u003d\" + (\n                getAccessibleNodeLabels() \u003d\u003d null ?\n                    \"\" :\n                    StringUtils\n                        .join(getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n      }\n\n      nodeLocalityDelay \u003d conf.getNodeLocalityDelay();\n      rackLocalityFullReset \u003d conf.getRackLocalityFullReset();\n\n      // re-init this since max allocation could have changed\n      this.minimumAllocationFactor \u003d Resources.ratio(resourceCalculator,\n          Resources.subtract(maximumAllocation, minimumAllocation),\n          maximumAllocation);\n\n      StringBuilder aclsString \u003d new StringBuilder();\n      for (Map.Entry\u003cAccessType, AccessControlList\u003e e : acls.entrySet()) {\n        aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n      }\n\n      StringBuilder labelStrBuilder \u003d new StringBuilder();\n      if (accessibleLabels !\u003d null) {\n        for (String s : accessibleLabels) {\n          labelStrBuilder.append(s);\n          labelStrBuilder.append(\",\");\n        }\n      }\n\n      defaultAppPriorityPerQueue \u003d Priority.newInstance(\n          conf.getDefaultApplicationPriorityConfPerQueue(getQueuePath()));\n\n      LOG.info(\n          \"Initializing \" + queueName + \"\\n\" + \"capacity \u003d \" + queueCapacities\n              .getCapacity() + \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\"\n              + \"absoluteCapacity \u003d \" + queueCapacities.getAbsoluteCapacity()\n              + \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\"\n              + \"maxCapacity \u003d \" + queueCapacities.getMaximumCapacity()\n              + \" [\u003d configuredMaxCapacity ]\" + \"\\n\" + \"absoluteMaxCapacity \u003d \"\n              + queueCapacities.getAbsoluteMaximumCapacity()\n              + \" [\u003d 1.0 maximumCapacity undefined, \"\n              + \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\"\n              + \"\\n\" + \"userLimit \u003d \" + userLimit + \" [\u003d configuredUserLimit ]\"\n              + \"\\n\" + \"userLimitFactor \u003d \" + userLimitFactor\n              + \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" + \"maxApplications \u003d \"\n              + maxApplications\n              + \" [\u003d configuredMaximumSystemApplicationsPerQueue or\"\n              + \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\"\n              + \"\\n\" + \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser\n              + \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \"\n              + \"userLimitFactor) ]\" + \"\\n\" + \"usedCapacity \u003d \"\n              + queueCapacities.getUsedCapacity() + \" [\u003d usedResourcesMemory / \"\n              + \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\"\n              + \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity\n              + \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\"\n              + \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent\n              + \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\"\n              + \"minimumAllocationFactor \u003d \" + minimumAllocationFactor\n              + \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \"\n              + \"maximumAllocationMemory ]\" + \"\\n\" + \"maximumAllocation \u003d \"\n              + maximumAllocation + \" [\u003d configuredMaxAllocation ]\" + \"\\n\"\n              + \"numContainers \u003d \" + numContainers\n              + \" [\u003d currentNumContainers ]\" + \"\\n\" + \"state \u003d \" + getState()\n              + \" [\u003d configuredState ]\" + \"\\n\" + \"acls \u003d \" + aclsString\n              + \" [\u003d configuredAcls ]\" + \"\\n\" + \"nodeLocalityDelay \u003d \"\n              + nodeLocalityDelay + \"\\n\" + \"labels\u003d\" + labelStrBuilder\n              .toString() + \"\\n\" + \"reservationsContinueLooking \u003d \"\n              + reservationsContinueLooking + \"\\n\" + \"preemptionDisabled \u003d \"\n              + getPreemptionDisabled() + \"\\n\" + \"defaultAppPriorityPerQueue \u003d \"\n              + defaultAppPriorityPerQueue);\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "0840b4329b2428b20b862f70d72cbdcd6d1618ed": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5756. Add state-machine implementation for scheduler queues. (Xuan Gong via wangda)\n",
      "commitDate": "27/12/16 9:18 PM",
      "commitName": "0840b4329b2428b20b862f70d72cbdcd6d1618ed",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "27/12/16 12:40 PM",
      "commitNameOld": "ac1e5d4f77e3b9df8dcacb0b1f72eecc27931eb8",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 0.36,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,125 +1,125 @@\n   protected void setupQueueConfigs(Resource clusterResource)\n       throws IOException {\n     try {\n       writeLock.lock();\n       super.setupQueueConfigs(clusterResource);\n \n       this.lastClusterResource \u003d clusterResource;\n \n       this.cachedResourceLimitsForHeadroom \u003d new ResourceLimits(\n           clusterResource);\n \n       // Initialize headroom info, also used for calculating application\n       // master resource limits.  Since this happens during queue initialization\n       // and all queues may not be realized yet, we\u0027ll use (optimistic)\n       // absoluteMaxCapacity (it will be replaced with the more accurate\n       // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n       setQueueResourceLimitsInfo(clusterResource);\n \n       CapacitySchedulerConfiguration conf \u003d csContext.getConfiguration();\n \n       setOrderingPolicy(\n           conf.\u003cFiCaSchedulerApp\u003egetOrderingPolicy(getQueuePath()));\n \n       userLimit \u003d conf.getUserLimit(getQueuePath());\n       userLimitFactor \u003d conf.getUserLimitFactor(getQueuePath());\n \n       maxApplications \u003d conf.getMaximumApplicationsPerQueue(getQueuePath());\n       if (maxApplications \u003c 0) {\n         int maxGlobalPerQueueApps \u003d conf.getGlobalMaximumApplicationsPerQueue();\n         if (maxGlobalPerQueueApps \u003e 0) {\n           maxApplications \u003d maxGlobalPerQueueApps;\n         } else {\n           int maxSystemApps \u003d conf.getMaximumSystemApplications();\n           maxApplications \u003d\n               (int) (maxSystemApps * queueCapacities.getAbsoluteCapacity());\n         }\n       }\n       maxApplicationsPerUser \u003d Math.min(maxApplications,\n           (int) (maxApplications * (userLimit / 100.0f) * userLimitFactor));\n \n       maxAMResourcePerQueuePercent \u003d\n           conf.getMaximumApplicationMasterResourcePerQueuePercent(\n               getQueuePath());\n \n       if (!SchedulerUtils.checkQueueLabelExpression(this.accessibleLabels,\n           this.defaultLabelExpression, null)) {\n         throw new IOException(\n             \"Invalid default label expression of \" + \" queue\u003d\" + getQueueName()\n                 + \" doesn\u0027t have permission to access all labels \"\n                 + \"in default label expression. labelExpression of resource request\u003d\"\n                 + (this.defaultLabelExpression \u003d\u003d null ?\n                 \"\" :\n                 this.defaultLabelExpression) + \". Queue labels\u003d\" + (\n                 getAccessibleNodeLabels() \u003d\u003d null ?\n                     \"\" :\n                     StringUtils\n                         .join(getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n       }\n \n       nodeLocalityDelay \u003d conf.getNodeLocalityDelay();\n       rackLocalityFullReset \u003d conf.getRackLocalityFullReset();\n \n       // re-init this since max allocation could have changed\n       this.minimumAllocationFactor \u003d Resources.ratio(resourceCalculator,\n           Resources.subtract(maximumAllocation, minimumAllocation),\n           maximumAllocation);\n \n       StringBuilder aclsString \u003d new StringBuilder();\n       for (Map.Entry\u003cAccessType, AccessControlList\u003e e : acls.entrySet()) {\n         aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n       }\n \n       StringBuilder labelStrBuilder \u003d new StringBuilder();\n       if (accessibleLabels !\u003d null) {\n         for (String s : accessibleLabels) {\n           labelStrBuilder.append(s);\n           labelStrBuilder.append(\",\");\n         }\n       }\n \n       defaultAppPriorityPerQueue \u003d Priority.newInstance(\n           conf.getDefaultApplicationPriorityConfPerQueue(getQueuePath()));\n \n       LOG.info(\n           \"Initializing \" + queueName + \"\\n\" + \"capacity \u003d \" + queueCapacities\n               .getCapacity() + \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\"\n               + \"absoluteCapacity \u003d \" + queueCapacities.getAbsoluteCapacity()\n               + \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\"\n               + \"maxCapacity \u003d \" + queueCapacities.getMaximumCapacity()\n               + \" [\u003d configuredMaxCapacity ]\" + \"\\n\" + \"absoluteMaxCapacity \u003d \"\n               + queueCapacities.getAbsoluteMaximumCapacity()\n               + \" [\u003d 1.0 maximumCapacity undefined, \"\n               + \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\"\n               + \"\\n\" + \"userLimit \u003d \" + userLimit + \" [\u003d configuredUserLimit ]\"\n               + \"\\n\" + \"userLimitFactor \u003d \" + userLimitFactor\n               + \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" + \"maxApplications \u003d \"\n               + maxApplications\n               + \" [\u003d configuredMaximumSystemApplicationsPerQueue or\"\n               + \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\"\n               + \"\\n\" + \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser\n               + \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \"\n               + \"userLimitFactor) ]\" + \"\\n\" + \"usedCapacity \u003d \"\n               + queueCapacities.getUsedCapacity() + \" [\u003d usedResourcesMemory / \"\n               + \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\"\n               + \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity\n               + \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\"\n               + \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent\n               + \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\"\n               + \"minimumAllocationFactor \u003d \" + minimumAllocationFactor\n               + \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \"\n               + \"maximumAllocationMemory ]\" + \"\\n\" + \"maximumAllocation \u003d \"\n               + maximumAllocation + \" [\u003d configuredMaxAllocation ]\" + \"\\n\"\n               + \"numContainers \u003d \" + numContainers\n-              + \" [\u003d currentNumContainers ]\" + \"\\n\" + \"state \u003d \" + state\n+              + \" [\u003d currentNumContainers ]\" + \"\\n\" + \"state \u003d \" + getState()\n               + \" [\u003d configuredState ]\" + \"\\n\" + \"acls \u003d \" + aclsString\n               + \" [\u003d configuredAcls ]\" + \"\\n\" + \"nodeLocalityDelay \u003d \"\n               + nodeLocalityDelay + \"\\n\" + \"labels\u003d\" + labelStrBuilder\n               .toString() + \"\\n\" + \"reservationsContinueLooking \u003d \"\n               + reservationsContinueLooking + \"\\n\" + \"preemptionDisabled \u003d \"\n               + getPreemptionDisabled() + \"\\n\" + \"defaultAppPriorityPerQueue \u003d \"\n               + defaultAppPriorityPerQueue);\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void setupQueueConfigs(Resource clusterResource)\n      throws IOException {\n    try {\n      writeLock.lock();\n      super.setupQueueConfigs(clusterResource);\n\n      this.lastClusterResource \u003d clusterResource;\n\n      this.cachedResourceLimitsForHeadroom \u003d new ResourceLimits(\n          clusterResource);\n\n      // Initialize headroom info, also used for calculating application\n      // master resource limits.  Since this happens during queue initialization\n      // and all queues may not be realized yet, we\u0027ll use (optimistic)\n      // absoluteMaxCapacity (it will be replaced with the more accurate\n      // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n      setQueueResourceLimitsInfo(clusterResource);\n\n      CapacitySchedulerConfiguration conf \u003d csContext.getConfiguration();\n\n      setOrderingPolicy(\n          conf.\u003cFiCaSchedulerApp\u003egetOrderingPolicy(getQueuePath()));\n\n      userLimit \u003d conf.getUserLimit(getQueuePath());\n      userLimitFactor \u003d conf.getUserLimitFactor(getQueuePath());\n\n      maxApplications \u003d conf.getMaximumApplicationsPerQueue(getQueuePath());\n      if (maxApplications \u003c 0) {\n        int maxGlobalPerQueueApps \u003d conf.getGlobalMaximumApplicationsPerQueue();\n        if (maxGlobalPerQueueApps \u003e 0) {\n          maxApplications \u003d maxGlobalPerQueueApps;\n        } else {\n          int maxSystemApps \u003d conf.getMaximumSystemApplications();\n          maxApplications \u003d\n              (int) (maxSystemApps * queueCapacities.getAbsoluteCapacity());\n        }\n      }\n      maxApplicationsPerUser \u003d Math.min(maxApplications,\n          (int) (maxApplications * (userLimit / 100.0f) * userLimitFactor));\n\n      maxAMResourcePerQueuePercent \u003d\n          conf.getMaximumApplicationMasterResourcePerQueuePercent(\n              getQueuePath());\n\n      if (!SchedulerUtils.checkQueueLabelExpression(this.accessibleLabels,\n          this.defaultLabelExpression, null)) {\n        throw new IOException(\n            \"Invalid default label expression of \" + \" queue\u003d\" + getQueueName()\n                + \" doesn\u0027t have permission to access all labels \"\n                + \"in default label expression. labelExpression of resource request\u003d\"\n                + (this.defaultLabelExpression \u003d\u003d null ?\n                \"\" :\n                this.defaultLabelExpression) + \". Queue labels\u003d\" + (\n                getAccessibleNodeLabels() \u003d\u003d null ?\n                    \"\" :\n                    StringUtils\n                        .join(getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n      }\n\n      nodeLocalityDelay \u003d conf.getNodeLocalityDelay();\n      rackLocalityFullReset \u003d conf.getRackLocalityFullReset();\n\n      // re-init this since max allocation could have changed\n      this.minimumAllocationFactor \u003d Resources.ratio(resourceCalculator,\n          Resources.subtract(maximumAllocation, minimumAllocation),\n          maximumAllocation);\n\n      StringBuilder aclsString \u003d new StringBuilder();\n      for (Map.Entry\u003cAccessType, AccessControlList\u003e e : acls.entrySet()) {\n        aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n      }\n\n      StringBuilder labelStrBuilder \u003d new StringBuilder();\n      if (accessibleLabels !\u003d null) {\n        for (String s : accessibleLabels) {\n          labelStrBuilder.append(s);\n          labelStrBuilder.append(\",\");\n        }\n      }\n\n      defaultAppPriorityPerQueue \u003d Priority.newInstance(\n          conf.getDefaultApplicationPriorityConfPerQueue(getQueuePath()));\n\n      LOG.info(\n          \"Initializing \" + queueName + \"\\n\" + \"capacity \u003d \" + queueCapacities\n              .getCapacity() + \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\"\n              + \"absoluteCapacity \u003d \" + queueCapacities.getAbsoluteCapacity()\n              + \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\"\n              + \"maxCapacity \u003d \" + queueCapacities.getMaximumCapacity()\n              + \" [\u003d configuredMaxCapacity ]\" + \"\\n\" + \"absoluteMaxCapacity \u003d \"\n              + queueCapacities.getAbsoluteMaximumCapacity()\n              + \" [\u003d 1.0 maximumCapacity undefined, \"\n              + \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\"\n              + \"\\n\" + \"userLimit \u003d \" + userLimit + \" [\u003d configuredUserLimit ]\"\n              + \"\\n\" + \"userLimitFactor \u003d \" + userLimitFactor\n              + \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" + \"maxApplications \u003d \"\n              + maxApplications\n              + \" [\u003d configuredMaximumSystemApplicationsPerQueue or\"\n              + \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\"\n              + \"\\n\" + \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser\n              + \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \"\n              + \"userLimitFactor) ]\" + \"\\n\" + \"usedCapacity \u003d \"\n              + queueCapacities.getUsedCapacity() + \" [\u003d usedResourcesMemory / \"\n              + \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\"\n              + \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity\n              + \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\"\n              + \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent\n              + \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\"\n              + \"minimumAllocationFactor \u003d \" + minimumAllocationFactor\n              + \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \"\n              + \"maximumAllocationMemory ]\" + \"\\n\" + \"maximumAllocation \u003d \"\n              + maximumAllocation + \" [\u003d configuredMaxAllocation ]\" + \"\\n\"\n              + \"numContainers \u003d \" + numContainers\n              + \" [\u003d currentNumContainers ]\" + \"\\n\" + \"state \u003d \" + getState()\n              + \" [\u003d configuredState ]\" + \"\\n\" + \"acls \u003d \" + aclsString\n              + \" [\u003d configuredAcls ]\" + \"\\n\" + \"nodeLocalityDelay \u003d \"\n              + nodeLocalityDelay + \"\\n\" + \"labels\u003d\" + labelStrBuilder\n              .toString() + \"\\n\" + \"reservationsContinueLooking \u003d \"\n              + reservationsContinueLooking + \"\\n\" + \"preemptionDisabled \u003d \"\n              + getPreemptionDisabled() + \"\\n\" + \"defaultAppPriorityPerQueue \u003d \"\n              + defaultAppPriorityPerQueue);\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "503e73e849cbdd1194cc0d16b4969c60929aca11": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5545. Fix issues related to Max App in capacity scheduler. Contributed by Bibin A Chundatt\n",
      "commitDate": "11/11/16 7:18 AM",
      "commitName": "503e73e849cbdd1194cc0d16b4969c60929aca11",
      "commitAuthor": "Naganarasimha",
      "commitDateOld": "07/11/16 10:14 AM",
      "commitNameOld": "de3b4aac561258ad242a3c5ed1c919428893fd4c",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 3.88,
      "commitsBetweenForRepo": 36,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,120 +1,125 @@\n   protected void setupQueueConfigs(Resource clusterResource)\n       throws IOException {\n     try {\n       writeLock.lock();\n       super.setupQueueConfigs(clusterResource);\n \n       this.lastClusterResource \u003d clusterResource;\n \n       this.cachedResourceLimitsForHeadroom \u003d new ResourceLimits(\n           clusterResource);\n \n       // Initialize headroom info, also used for calculating application\n       // master resource limits.  Since this happens during queue initialization\n       // and all queues may not be realized yet, we\u0027ll use (optimistic)\n       // absoluteMaxCapacity (it will be replaced with the more accurate\n       // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n       setQueueResourceLimitsInfo(clusterResource);\n \n       CapacitySchedulerConfiguration conf \u003d csContext.getConfiguration();\n \n       setOrderingPolicy(\n           conf.\u003cFiCaSchedulerApp\u003egetOrderingPolicy(getQueuePath()));\n \n       userLimit \u003d conf.getUserLimit(getQueuePath());\n       userLimitFactor \u003d conf.getUserLimitFactor(getQueuePath());\n \n       maxApplications \u003d conf.getMaximumApplicationsPerQueue(getQueuePath());\n       if (maxApplications \u003c 0) {\n-        int maxSystemApps \u003d conf.getMaximumSystemApplications();\n-        maxApplications \u003d\n-            (int) (maxSystemApps * queueCapacities.getAbsoluteCapacity());\n+        int maxGlobalPerQueueApps \u003d conf.getGlobalMaximumApplicationsPerQueue();\n+        if (maxGlobalPerQueueApps \u003e 0) {\n+          maxApplications \u003d maxGlobalPerQueueApps;\n+        } else {\n+          int maxSystemApps \u003d conf.getMaximumSystemApplications();\n+          maxApplications \u003d\n+              (int) (maxSystemApps * queueCapacities.getAbsoluteCapacity());\n+        }\n       }\n       maxApplicationsPerUser \u003d Math.min(maxApplications,\n           (int) (maxApplications * (userLimit / 100.0f) * userLimitFactor));\n \n       maxAMResourcePerQueuePercent \u003d\n           conf.getMaximumApplicationMasterResourcePerQueuePercent(\n               getQueuePath());\n \n       if (!SchedulerUtils.checkQueueLabelExpression(this.accessibleLabels,\n           this.defaultLabelExpression, null)) {\n         throw new IOException(\n             \"Invalid default label expression of \" + \" queue\u003d\" + getQueueName()\n                 + \" doesn\u0027t have permission to access all labels \"\n                 + \"in default label expression. labelExpression of resource request\u003d\"\n                 + (this.defaultLabelExpression \u003d\u003d null ?\n                 \"\" :\n                 this.defaultLabelExpression) + \". Queue labels\u003d\" + (\n                 getAccessibleNodeLabels() \u003d\u003d null ?\n                     \"\" :\n                     StringUtils\n                         .join(getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n       }\n \n       nodeLocalityDelay \u003d conf.getNodeLocalityDelay();\n       rackLocalityFullReset \u003d conf.getRackLocalityFullReset();\n \n       // re-init this since max allocation could have changed\n       this.minimumAllocationFactor \u003d Resources.ratio(resourceCalculator,\n           Resources.subtract(maximumAllocation, minimumAllocation),\n           maximumAllocation);\n \n       StringBuilder aclsString \u003d new StringBuilder();\n       for (Map.Entry\u003cAccessType, AccessControlList\u003e e : acls.entrySet()) {\n         aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n       }\n \n       StringBuilder labelStrBuilder \u003d new StringBuilder();\n       if (accessibleLabels !\u003d null) {\n         for (String s : accessibleLabels) {\n           labelStrBuilder.append(s);\n           labelStrBuilder.append(\",\");\n         }\n       }\n \n       defaultAppPriorityPerQueue \u003d Priority.newInstance(\n           conf.getDefaultApplicationPriorityConfPerQueue(getQueuePath()));\n \n       LOG.info(\n           \"Initializing \" + queueName + \"\\n\" + \"capacity \u003d \" + queueCapacities\n               .getCapacity() + \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\"\n               + \"absoluteCapacity \u003d \" + queueCapacities.getAbsoluteCapacity()\n               + \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\"\n               + \"maxCapacity \u003d \" + queueCapacities.getMaximumCapacity()\n               + \" [\u003d configuredMaxCapacity ]\" + \"\\n\" + \"absoluteMaxCapacity \u003d \"\n               + queueCapacities.getAbsoluteMaximumCapacity()\n               + \" [\u003d 1.0 maximumCapacity undefined, \"\n               + \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\"\n               + \"\\n\" + \"userLimit \u003d \" + userLimit + \" [\u003d configuredUserLimit ]\"\n               + \"\\n\" + \"userLimitFactor \u003d \" + userLimitFactor\n               + \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" + \"maxApplications \u003d \"\n               + maxApplications\n               + \" [\u003d configuredMaximumSystemApplicationsPerQueue or\"\n               + \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\"\n               + \"\\n\" + \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser\n               + \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \"\n               + \"userLimitFactor) ]\" + \"\\n\" + \"usedCapacity \u003d \"\n               + queueCapacities.getUsedCapacity() + \" [\u003d usedResourcesMemory / \"\n               + \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\"\n               + \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity\n               + \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\"\n               + \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent\n               + \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\"\n               + \"minimumAllocationFactor \u003d \" + minimumAllocationFactor\n               + \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \"\n               + \"maximumAllocationMemory ]\" + \"\\n\" + \"maximumAllocation \u003d \"\n               + maximumAllocation + \" [\u003d configuredMaxAllocation ]\" + \"\\n\"\n               + \"numContainers \u003d \" + numContainers\n               + \" [\u003d currentNumContainers ]\" + \"\\n\" + \"state \u003d \" + state\n               + \" [\u003d configuredState ]\" + \"\\n\" + \"acls \u003d \" + aclsString\n               + \" [\u003d configuredAcls ]\" + \"\\n\" + \"nodeLocalityDelay \u003d \"\n               + nodeLocalityDelay + \"\\n\" + \"labels\u003d\" + labelStrBuilder\n               .toString() + \"\\n\" + \"reservationsContinueLooking \u003d \"\n               + reservationsContinueLooking + \"\\n\" + \"preemptionDisabled \u003d \"\n               + getPreemptionDisabled() + \"\\n\" + \"defaultAppPriorityPerQueue \u003d \"\n               + defaultAppPriorityPerQueue);\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void setupQueueConfigs(Resource clusterResource)\n      throws IOException {\n    try {\n      writeLock.lock();\n      super.setupQueueConfigs(clusterResource);\n\n      this.lastClusterResource \u003d clusterResource;\n\n      this.cachedResourceLimitsForHeadroom \u003d new ResourceLimits(\n          clusterResource);\n\n      // Initialize headroom info, also used for calculating application\n      // master resource limits.  Since this happens during queue initialization\n      // and all queues may not be realized yet, we\u0027ll use (optimistic)\n      // absoluteMaxCapacity (it will be replaced with the more accurate\n      // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n      setQueueResourceLimitsInfo(clusterResource);\n\n      CapacitySchedulerConfiguration conf \u003d csContext.getConfiguration();\n\n      setOrderingPolicy(\n          conf.\u003cFiCaSchedulerApp\u003egetOrderingPolicy(getQueuePath()));\n\n      userLimit \u003d conf.getUserLimit(getQueuePath());\n      userLimitFactor \u003d conf.getUserLimitFactor(getQueuePath());\n\n      maxApplications \u003d conf.getMaximumApplicationsPerQueue(getQueuePath());\n      if (maxApplications \u003c 0) {\n        int maxGlobalPerQueueApps \u003d conf.getGlobalMaximumApplicationsPerQueue();\n        if (maxGlobalPerQueueApps \u003e 0) {\n          maxApplications \u003d maxGlobalPerQueueApps;\n        } else {\n          int maxSystemApps \u003d conf.getMaximumSystemApplications();\n          maxApplications \u003d\n              (int) (maxSystemApps * queueCapacities.getAbsoluteCapacity());\n        }\n      }\n      maxApplicationsPerUser \u003d Math.min(maxApplications,\n          (int) (maxApplications * (userLimit / 100.0f) * userLimitFactor));\n\n      maxAMResourcePerQueuePercent \u003d\n          conf.getMaximumApplicationMasterResourcePerQueuePercent(\n              getQueuePath());\n\n      if (!SchedulerUtils.checkQueueLabelExpression(this.accessibleLabels,\n          this.defaultLabelExpression, null)) {\n        throw new IOException(\n            \"Invalid default label expression of \" + \" queue\u003d\" + getQueueName()\n                + \" doesn\u0027t have permission to access all labels \"\n                + \"in default label expression. labelExpression of resource request\u003d\"\n                + (this.defaultLabelExpression \u003d\u003d null ?\n                \"\" :\n                this.defaultLabelExpression) + \". Queue labels\u003d\" + (\n                getAccessibleNodeLabels() \u003d\u003d null ?\n                    \"\" :\n                    StringUtils\n                        .join(getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n      }\n\n      nodeLocalityDelay \u003d conf.getNodeLocalityDelay();\n      rackLocalityFullReset \u003d conf.getRackLocalityFullReset();\n\n      // re-init this since max allocation could have changed\n      this.minimumAllocationFactor \u003d Resources.ratio(resourceCalculator,\n          Resources.subtract(maximumAllocation, minimumAllocation),\n          maximumAllocation);\n\n      StringBuilder aclsString \u003d new StringBuilder();\n      for (Map.Entry\u003cAccessType, AccessControlList\u003e e : acls.entrySet()) {\n        aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n      }\n\n      StringBuilder labelStrBuilder \u003d new StringBuilder();\n      if (accessibleLabels !\u003d null) {\n        for (String s : accessibleLabels) {\n          labelStrBuilder.append(s);\n          labelStrBuilder.append(\",\");\n        }\n      }\n\n      defaultAppPriorityPerQueue \u003d Priority.newInstance(\n          conf.getDefaultApplicationPriorityConfPerQueue(getQueuePath()));\n\n      LOG.info(\n          \"Initializing \" + queueName + \"\\n\" + \"capacity \u003d \" + queueCapacities\n              .getCapacity() + \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\"\n              + \"absoluteCapacity \u003d \" + queueCapacities.getAbsoluteCapacity()\n              + \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\"\n              + \"maxCapacity \u003d \" + queueCapacities.getMaximumCapacity()\n              + \" [\u003d configuredMaxCapacity ]\" + \"\\n\" + \"absoluteMaxCapacity \u003d \"\n              + queueCapacities.getAbsoluteMaximumCapacity()\n              + \" [\u003d 1.0 maximumCapacity undefined, \"\n              + \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\"\n              + \"\\n\" + \"userLimit \u003d \" + userLimit + \" [\u003d configuredUserLimit ]\"\n              + \"\\n\" + \"userLimitFactor \u003d \" + userLimitFactor\n              + \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" + \"maxApplications \u003d \"\n              + maxApplications\n              + \" [\u003d configuredMaximumSystemApplicationsPerQueue or\"\n              + \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\"\n              + \"\\n\" + \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser\n              + \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \"\n              + \"userLimitFactor) ]\" + \"\\n\" + \"usedCapacity \u003d \"\n              + queueCapacities.getUsedCapacity() + \" [\u003d usedResourcesMemory / \"\n              + \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\"\n              + \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity\n              + \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\"\n              + \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent\n              + \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\"\n              + \"minimumAllocationFactor \u003d \" + minimumAllocationFactor\n              + \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \"\n              + \"maximumAllocationMemory ]\" + \"\\n\" + \"maximumAllocation \u003d \"\n              + maximumAllocation + \" [\u003d configuredMaxAllocation ]\" + \"\\n\"\n              + \"numContainers \u003d \" + numContainers\n              + \" [\u003d currentNumContainers ]\" + \"\\n\" + \"state \u003d \" + state\n              + \" [\u003d configuredState ]\" + \"\\n\" + \"acls \u003d \" + aclsString\n              + \" [\u003d configuredAcls ]\" + \"\\n\" + \"nodeLocalityDelay \u003d \"\n              + nodeLocalityDelay + \"\\n\" + \"labels\u003d\" + labelStrBuilder\n              .toString() + \"\\n\" + \"reservationsContinueLooking \u003d \"\n              + reservationsContinueLooking + \"\\n\" + \"preemptionDisabled \u003d \"\n              + getPreemptionDisabled() + \"\\n\" + \"defaultAppPriorityPerQueue \u003d \"\n              + defaultAppPriorityPerQueue);\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "2b66d9ec5bdaec7e6b278926fbb6f222c4e3afaa": {
      "type": "Ymultichange(Ymodifierchange,Ybodychange)",
      "commitMessage": "YARN-3140. Improve locks in AbstractCSQueue/LeafQueue/ParentQueue. Contributed by Wangda Tan\n",
      "commitDate": "20/09/16 12:03 AM",
      "commitName": "2b66d9ec5bdaec7e6b278926fbb6f222c4e3afaa",
      "commitAuthor": "Jian He",
      "subchanges": [
        {
          "type": "Ymodifierchange",
          "commitMessage": "YARN-3140. Improve locks in AbstractCSQueue/LeafQueue/ParentQueue. Contributed by Wangda Tan\n",
          "commitDate": "20/09/16 12:03 AM",
          "commitName": "2b66d9ec5bdaec7e6b278926fbb6f222c4e3afaa",
          "commitAuthor": "Jian He",
          "commitDateOld": "16/09/16 10:05 PM",
          "commitNameOld": "4174b9756c8c7877797545c4356b1f40df603ec5",
          "commitAuthorOld": "Naganarasimha",
          "daysBetweenCommits": 3.08,
          "commitsBetweenForRepo": 11,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,120 +1,120 @@\n-  protected synchronized void setupQueueConfigs(Resource clusterResource)\n+  protected void setupQueueConfigs(Resource clusterResource)\n       throws IOException {\n-    super.setupQueueConfigs(clusterResource);\n-    \n-    this.lastClusterResource \u003d clusterResource;\n-    \n-    this.cachedResourceLimitsForHeadroom \u003d new ResourceLimits(clusterResource);\n-    \n-    // Initialize headroom info, also used for calculating application \n-    // master resource limits.  Since this happens during queue initialization\n-    // and all queues may not be realized yet, we\u0027ll use (optimistic) \n-    // absoluteMaxCapacity (it will be replaced with the more accurate \n-    // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n-    setQueueResourceLimitsInfo(clusterResource);\n+    try {\n+      writeLock.lock();\n+      super.setupQueueConfigs(clusterResource);\n \n-    CapacitySchedulerConfiguration conf \u003d csContext.getConfiguration();\n+      this.lastClusterResource \u003d clusterResource;\n \n-    setOrderingPolicy(conf.\u003cFiCaSchedulerApp\u003egetOrderingPolicy(getQueuePath()));\n+      this.cachedResourceLimitsForHeadroom \u003d new ResourceLimits(\n+          clusterResource);\n \n-    userLimit \u003d conf.getUserLimit(getQueuePath());\n-    userLimitFactor \u003d conf.getUserLimitFactor(getQueuePath());\n+      // Initialize headroom info, also used for calculating application\n+      // master resource limits.  Since this happens during queue initialization\n+      // and all queues may not be realized yet, we\u0027ll use (optimistic)\n+      // absoluteMaxCapacity (it will be replaced with the more accurate\n+      // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n+      setQueueResourceLimitsInfo(clusterResource);\n \n-    maxApplications \u003d conf.getMaximumApplicationsPerQueue(getQueuePath());\n-    if (maxApplications \u003c 0) {\n-      int maxSystemApps \u003d conf.getMaximumSystemApplications();\n-      maxApplications \u003d\n-          (int) (maxSystemApps * queueCapacities.getAbsoluteCapacity());\n-    }\n-    maxApplicationsPerUser \u003d Math.min(maxApplications,\n-        (int)(maxApplications * (userLimit / 100.0f) * userLimitFactor));\n-    \n-    maxAMResourcePerQueuePercent \u003d\n-        conf.getMaximumApplicationMasterResourcePerQueuePercent(getQueuePath());\n+      CapacitySchedulerConfiguration conf \u003d csContext.getConfiguration();\n \n-    if (!SchedulerUtils.checkQueueLabelExpression(\n-        this.accessibleLabels, this.defaultLabelExpression, null)) {\n-      throw new IOException(\"Invalid default label expression of \"\n-          + \" queue\u003d\"\n-          + getQueueName()\n-          + \" doesn\u0027t have permission to access all labels \"\n-          + \"in default label expression. labelExpression of resource request\u003d\"\n-          + (this.defaultLabelExpression \u003d\u003d null ? \"\"\n-              : this.defaultLabelExpression)\n-          + \". Queue labels\u003d\"\n-          + (getAccessibleNodeLabels() \u003d\u003d null ? \"\" : StringUtils.join(\n-              getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n-    }\n-    \n-    nodeLocalityDelay \u003d conf.getNodeLocalityDelay();\n-    rackLocalityFullReset \u003d conf.getRackLocalityFullReset();\n+      setOrderingPolicy(\n+          conf.\u003cFiCaSchedulerApp\u003egetOrderingPolicy(getQueuePath()));\n \n-    // re-init this since max allocation could have changed\n-    this.minimumAllocationFactor \u003d\n-        Resources.ratio(resourceCalculator,\n-            Resources.subtract(maximumAllocation, minimumAllocation),\n-            maximumAllocation);\n+      userLimit \u003d conf.getUserLimit(getQueuePath());\n+      userLimitFactor \u003d conf.getUserLimitFactor(getQueuePath());\n \n-    StringBuilder aclsString \u003d new StringBuilder();\n-    for (Map.Entry\u003cAccessType, AccessControlList\u003e e : acls.entrySet()) {\n-      aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n-    }\n-\n-    StringBuilder labelStrBuilder \u003d new StringBuilder(); \n-    if (accessibleLabels !\u003d null) {\n-      for (String s : accessibleLabels) {\n-        labelStrBuilder.append(s);\n-        labelStrBuilder.append(\",\");\n+      maxApplications \u003d conf.getMaximumApplicationsPerQueue(getQueuePath());\n+      if (maxApplications \u003c 0) {\n+        int maxSystemApps \u003d conf.getMaximumSystemApplications();\n+        maxApplications \u003d\n+            (int) (maxSystemApps * queueCapacities.getAbsoluteCapacity());\n       }\n+      maxApplicationsPerUser \u003d Math.min(maxApplications,\n+          (int) (maxApplications * (userLimit / 100.0f) * userLimitFactor));\n+\n+      maxAMResourcePerQueuePercent \u003d\n+          conf.getMaximumApplicationMasterResourcePerQueuePercent(\n+              getQueuePath());\n+\n+      if (!SchedulerUtils.checkQueueLabelExpression(this.accessibleLabels,\n+          this.defaultLabelExpression, null)) {\n+        throw new IOException(\n+            \"Invalid default label expression of \" + \" queue\u003d\" + getQueueName()\n+                + \" doesn\u0027t have permission to access all labels \"\n+                + \"in default label expression. labelExpression of resource request\u003d\"\n+                + (this.defaultLabelExpression \u003d\u003d null ?\n+                \"\" :\n+                this.defaultLabelExpression) + \". Queue labels\u003d\" + (\n+                getAccessibleNodeLabels() \u003d\u003d null ?\n+                    \"\" :\n+                    StringUtils\n+                        .join(getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n+      }\n+\n+      nodeLocalityDelay \u003d conf.getNodeLocalityDelay();\n+      rackLocalityFullReset \u003d conf.getRackLocalityFullReset();\n+\n+      // re-init this since max allocation could have changed\n+      this.minimumAllocationFactor \u003d Resources.ratio(resourceCalculator,\n+          Resources.subtract(maximumAllocation, minimumAllocation),\n+          maximumAllocation);\n+\n+      StringBuilder aclsString \u003d new StringBuilder();\n+      for (Map.Entry\u003cAccessType, AccessControlList\u003e e : acls.entrySet()) {\n+        aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n+      }\n+\n+      StringBuilder labelStrBuilder \u003d new StringBuilder();\n+      if (accessibleLabels !\u003d null) {\n+        for (String s : accessibleLabels) {\n+          labelStrBuilder.append(s);\n+          labelStrBuilder.append(\",\");\n+        }\n+      }\n+\n+      defaultAppPriorityPerQueue \u003d Priority.newInstance(\n+          conf.getDefaultApplicationPriorityConfPerQueue(getQueuePath()));\n+\n+      LOG.info(\n+          \"Initializing \" + queueName + \"\\n\" + \"capacity \u003d \" + queueCapacities\n+              .getCapacity() + \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\"\n+              + \"absoluteCapacity \u003d \" + queueCapacities.getAbsoluteCapacity()\n+              + \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\"\n+              + \"maxCapacity \u003d \" + queueCapacities.getMaximumCapacity()\n+              + \" [\u003d configuredMaxCapacity ]\" + \"\\n\" + \"absoluteMaxCapacity \u003d \"\n+              + queueCapacities.getAbsoluteMaximumCapacity()\n+              + \" [\u003d 1.0 maximumCapacity undefined, \"\n+              + \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\"\n+              + \"\\n\" + \"userLimit \u003d \" + userLimit + \" [\u003d configuredUserLimit ]\"\n+              + \"\\n\" + \"userLimitFactor \u003d \" + userLimitFactor\n+              + \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" + \"maxApplications \u003d \"\n+              + maxApplications\n+              + \" [\u003d configuredMaximumSystemApplicationsPerQueue or\"\n+              + \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\"\n+              + \"\\n\" + \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser\n+              + \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \"\n+              + \"userLimitFactor) ]\" + \"\\n\" + \"usedCapacity \u003d \"\n+              + queueCapacities.getUsedCapacity() + \" [\u003d usedResourcesMemory / \"\n+              + \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\"\n+              + \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity\n+              + \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\"\n+              + \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent\n+              + \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\"\n+              + \"minimumAllocationFactor \u003d \" + minimumAllocationFactor\n+              + \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \"\n+              + \"maximumAllocationMemory ]\" + \"\\n\" + \"maximumAllocation \u003d \"\n+              + maximumAllocation + \" [\u003d configuredMaxAllocation ]\" + \"\\n\"\n+              + \"numContainers \u003d \" + numContainers\n+              + \" [\u003d currentNumContainers ]\" + \"\\n\" + \"state \u003d \" + state\n+              + \" [\u003d configuredState ]\" + \"\\n\" + \"acls \u003d \" + aclsString\n+              + \" [\u003d configuredAcls ]\" + \"\\n\" + \"nodeLocalityDelay \u003d \"\n+              + nodeLocalityDelay + \"\\n\" + \"labels\u003d\" + labelStrBuilder\n+              .toString() + \"\\n\" + \"reservationsContinueLooking \u003d \"\n+              + reservationsContinueLooking + \"\\n\" + \"preemptionDisabled \u003d \"\n+              + getPreemptionDisabled() + \"\\n\" + \"defaultAppPriorityPerQueue \u003d \"\n+              + defaultAppPriorityPerQueue);\n+    } finally {\n+      writeLock.unlock();\n     }\n-\n-    defaultAppPriorityPerQueue \u003d Priority.newInstance(conf\n-        .getDefaultApplicationPriorityConfPerQueue(getQueuePath()));\n-\n-    LOG.info(\"Initializing \" + queueName + \"\\n\" +\n-        \"capacity \u003d \" + queueCapacities.getCapacity() +\n-        \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n-        \"absoluteCapacity \u003d \" + queueCapacities.getAbsoluteCapacity() +\n-        \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n-        \"maxCapacity \u003d \" + queueCapacities.getMaximumCapacity() +\n-        \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n-        \"absoluteMaxCapacity \u003d \" + queueCapacities.getAbsoluteMaximumCapacity() +\n-        \" [\u003d 1.0 maximumCapacity undefined, \" +\n-        \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n-        \"\\n\" +\n-        \"userLimit \u003d \" + userLimit +\n-        \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n-        \"userLimitFactor \u003d \" + userLimitFactor +\n-        \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n-        \"maxApplications \u003d \" + maxApplications +\n-        \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n-        \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n-        \"\\n\" +\n-        \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n-        \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n-        \"userLimitFactor) ]\" + \"\\n\" +\n-        \"usedCapacity \u003d \" + queueCapacities.getUsedCapacity() +\n-        \" [\u003d usedResourcesMemory / \" +\n-        \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n-        \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n-        \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n-        \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n-        \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n-        \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n-        \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n-        \"maximumAllocationMemory ]\" + \"\\n\" +\n-        \"maximumAllocation \u003d \" + maximumAllocation +\n-        \" [\u003d configuredMaxAllocation ]\" + \"\\n\" +\n-        \"numContainers \u003d \" + numContainers +\n-        \" [\u003d currentNumContainers ]\" + \"\\n\" +\n-        \"state \u003d \" + state +\n-        \" [\u003d configuredState ]\" + \"\\n\" +\n-        \"acls \u003d \" + aclsString +\n-        \" [\u003d configuredAcls ]\" + \"\\n\" + \n-        \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\" +\n-        \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\" +\n-        \"reservationsContinueLooking \u003d \" +\n-        reservationsContinueLooking + \"\\n\" +\n-        \"preemptionDisabled \u003d \" + getPreemptionDisabled() + \"\\n\" +\n-        \"defaultAppPriorityPerQueue \u003d \" + defaultAppPriorityPerQueue);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected void setupQueueConfigs(Resource clusterResource)\n      throws IOException {\n    try {\n      writeLock.lock();\n      super.setupQueueConfigs(clusterResource);\n\n      this.lastClusterResource \u003d clusterResource;\n\n      this.cachedResourceLimitsForHeadroom \u003d new ResourceLimits(\n          clusterResource);\n\n      // Initialize headroom info, also used for calculating application\n      // master resource limits.  Since this happens during queue initialization\n      // and all queues may not be realized yet, we\u0027ll use (optimistic)\n      // absoluteMaxCapacity (it will be replaced with the more accurate\n      // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n      setQueueResourceLimitsInfo(clusterResource);\n\n      CapacitySchedulerConfiguration conf \u003d csContext.getConfiguration();\n\n      setOrderingPolicy(\n          conf.\u003cFiCaSchedulerApp\u003egetOrderingPolicy(getQueuePath()));\n\n      userLimit \u003d conf.getUserLimit(getQueuePath());\n      userLimitFactor \u003d conf.getUserLimitFactor(getQueuePath());\n\n      maxApplications \u003d conf.getMaximumApplicationsPerQueue(getQueuePath());\n      if (maxApplications \u003c 0) {\n        int maxSystemApps \u003d conf.getMaximumSystemApplications();\n        maxApplications \u003d\n            (int) (maxSystemApps * queueCapacities.getAbsoluteCapacity());\n      }\n      maxApplicationsPerUser \u003d Math.min(maxApplications,\n          (int) (maxApplications * (userLimit / 100.0f) * userLimitFactor));\n\n      maxAMResourcePerQueuePercent \u003d\n          conf.getMaximumApplicationMasterResourcePerQueuePercent(\n              getQueuePath());\n\n      if (!SchedulerUtils.checkQueueLabelExpression(this.accessibleLabels,\n          this.defaultLabelExpression, null)) {\n        throw new IOException(\n            \"Invalid default label expression of \" + \" queue\u003d\" + getQueueName()\n                + \" doesn\u0027t have permission to access all labels \"\n                + \"in default label expression. labelExpression of resource request\u003d\"\n                + (this.defaultLabelExpression \u003d\u003d null ?\n                \"\" :\n                this.defaultLabelExpression) + \". Queue labels\u003d\" + (\n                getAccessibleNodeLabels() \u003d\u003d null ?\n                    \"\" :\n                    StringUtils\n                        .join(getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n      }\n\n      nodeLocalityDelay \u003d conf.getNodeLocalityDelay();\n      rackLocalityFullReset \u003d conf.getRackLocalityFullReset();\n\n      // re-init this since max allocation could have changed\n      this.minimumAllocationFactor \u003d Resources.ratio(resourceCalculator,\n          Resources.subtract(maximumAllocation, minimumAllocation),\n          maximumAllocation);\n\n      StringBuilder aclsString \u003d new StringBuilder();\n      for (Map.Entry\u003cAccessType, AccessControlList\u003e e : acls.entrySet()) {\n        aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n      }\n\n      StringBuilder labelStrBuilder \u003d new StringBuilder();\n      if (accessibleLabels !\u003d null) {\n        for (String s : accessibleLabels) {\n          labelStrBuilder.append(s);\n          labelStrBuilder.append(\",\");\n        }\n      }\n\n      defaultAppPriorityPerQueue \u003d Priority.newInstance(\n          conf.getDefaultApplicationPriorityConfPerQueue(getQueuePath()));\n\n      LOG.info(\n          \"Initializing \" + queueName + \"\\n\" + \"capacity \u003d \" + queueCapacities\n              .getCapacity() + \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\"\n              + \"absoluteCapacity \u003d \" + queueCapacities.getAbsoluteCapacity()\n              + \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\"\n              + \"maxCapacity \u003d \" + queueCapacities.getMaximumCapacity()\n              + \" [\u003d configuredMaxCapacity ]\" + \"\\n\" + \"absoluteMaxCapacity \u003d \"\n              + queueCapacities.getAbsoluteMaximumCapacity()\n              + \" [\u003d 1.0 maximumCapacity undefined, \"\n              + \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\"\n              + \"\\n\" + \"userLimit \u003d \" + userLimit + \" [\u003d configuredUserLimit ]\"\n              + \"\\n\" + \"userLimitFactor \u003d \" + userLimitFactor\n              + \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" + \"maxApplications \u003d \"\n              + maxApplications\n              + \" [\u003d configuredMaximumSystemApplicationsPerQueue or\"\n              + \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\"\n              + \"\\n\" + \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser\n              + \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \"\n              + \"userLimitFactor) ]\" + \"\\n\" + \"usedCapacity \u003d \"\n              + queueCapacities.getUsedCapacity() + \" [\u003d usedResourcesMemory / \"\n              + \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\"\n              + \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity\n              + \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\"\n              + \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent\n              + \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\"\n              + \"minimumAllocationFactor \u003d \" + minimumAllocationFactor\n              + \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \"\n              + \"maximumAllocationMemory ]\" + \"\\n\" + \"maximumAllocation \u003d \"\n              + maximumAllocation + \" [\u003d configuredMaxAllocation ]\" + \"\\n\"\n              + \"numContainers \u003d \" + numContainers\n              + \" [\u003d currentNumContainers ]\" + \"\\n\" + \"state \u003d \" + state\n              + \" [\u003d configuredState ]\" + \"\\n\" + \"acls \u003d \" + aclsString\n              + \" [\u003d configuredAcls ]\" + \"\\n\" + \"nodeLocalityDelay \u003d \"\n              + nodeLocalityDelay + \"\\n\" + \"labels\u003d\" + labelStrBuilder\n              .toString() + \"\\n\" + \"reservationsContinueLooking \u003d \"\n              + reservationsContinueLooking + \"\\n\" + \"preemptionDisabled \u003d \"\n              + getPreemptionDisabled() + \"\\n\" + \"defaultAppPriorityPerQueue \u003d \"\n              + defaultAppPriorityPerQueue);\n    } finally {\n      writeLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {
            "oldValue": "[protected, synchronized]",
            "newValue": "[protected]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-3140. Improve locks in AbstractCSQueue/LeafQueue/ParentQueue. Contributed by Wangda Tan\n",
          "commitDate": "20/09/16 12:03 AM",
          "commitName": "2b66d9ec5bdaec7e6b278926fbb6f222c4e3afaa",
          "commitAuthor": "Jian He",
          "commitDateOld": "16/09/16 10:05 PM",
          "commitNameOld": "4174b9756c8c7877797545c4356b1f40df603ec5",
          "commitAuthorOld": "Naganarasimha",
          "daysBetweenCommits": 3.08,
          "commitsBetweenForRepo": 11,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,120 +1,120 @@\n-  protected synchronized void setupQueueConfigs(Resource clusterResource)\n+  protected void setupQueueConfigs(Resource clusterResource)\n       throws IOException {\n-    super.setupQueueConfigs(clusterResource);\n-    \n-    this.lastClusterResource \u003d clusterResource;\n-    \n-    this.cachedResourceLimitsForHeadroom \u003d new ResourceLimits(clusterResource);\n-    \n-    // Initialize headroom info, also used for calculating application \n-    // master resource limits.  Since this happens during queue initialization\n-    // and all queues may not be realized yet, we\u0027ll use (optimistic) \n-    // absoluteMaxCapacity (it will be replaced with the more accurate \n-    // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n-    setQueueResourceLimitsInfo(clusterResource);\n+    try {\n+      writeLock.lock();\n+      super.setupQueueConfigs(clusterResource);\n \n-    CapacitySchedulerConfiguration conf \u003d csContext.getConfiguration();\n+      this.lastClusterResource \u003d clusterResource;\n \n-    setOrderingPolicy(conf.\u003cFiCaSchedulerApp\u003egetOrderingPolicy(getQueuePath()));\n+      this.cachedResourceLimitsForHeadroom \u003d new ResourceLimits(\n+          clusterResource);\n \n-    userLimit \u003d conf.getUserLimit(getQueuePath());\n-    userLimitFactor \u003d conf.getUserLimitFactor(getQueuePath());\n+      // Initialize headroom info, also used for calculating application\n+      // master resource limits.  Since this happens during queue initialization\n+      // and all queues may not be realized yet, we\u0027ll use (optimistic)\n+      // absoluteMaxCapacity (it will be replaced with the more accurate\n+      // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n+      setQueueResourceLimitsInfo(clusterResource);\n \n-    maxApplications \u003d conf.getMaximumApplicationsPerQueue(getQueuePath());\n-    if (maxApplications \u003c 0) {\n-      int maxSystemApps \u003d conf.getMaximumSystemApplications();\n-      maxApplications \u003d\n-          (int) (maxSystemApps * queueCapacities.getAbsoluteCapacity());\n-    }\n-    maxApplicationsPerUser \u003d Math.min(maxApplications,\n-        (int)(maxApplications * (userLimit / 100.0f) * userLimitFactor));\n-    \n-    maxAMResourcePerQueuePercent \u003d\n-        conf.getMaximumApplicationMasterResourcePerQueuePercent(getQueuePath());\n+      CapacitySchedulerConfiguration conf \u003d csContext.getConfiguration();\n \n-    if (!SchedulerUtils.checkQueueLabelExpression(\n-        this.accessibleLabels, this.defaultLabelExpression, null)) {\n-      throw new IOException(\"Invalid default label expression of \"\n-          + \" queue\u003d\"\n-          + getQueueName()\n-          + \" doesn\u0027t have permission to access all labels \"\n-          + \"in default label expression. labelExpression of resource request\u003d\"\n-          + (this.defaultLabelExpression \u003d\u003d null ? \"\"\n-              : this.defaultLabelExpression)\n-          + \". Queue labels\u003d\"\n-          + (getAccessibleNodeLabels() \u003d\u003d null ? \"\" : StringUtils.join(\n-              getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n-    }\n-    \n-    nodeLocalityDelay \u003d conf.getNodeLocalityDelay();\n-    rackLocalityFullReset \u003d conf.getRackLocalityFullReset();\n+      setOrderingPolicy(\n+          conf.\u003cFiCaSchedulerApp\u003egetOrderingPolicy(getQueuePath()));\n \n-    // re-init this since max allocation could have changed\n-    this.minimumAllocationFactor \u003d\n-        Resources.ratio(resourceCalculator,\n-            Resources.subtract(maximumAllocation, minimumAllocation),\n-            maximumAllocation);\n+      userLimit \u003d conf.getUserLimit(getQueuePath());\n+      userLimitFactor \u003d conf.getUserLimitFactor(getQueuePath());\n \n-    StringBuilder aclsString \u003d new StringBuilder();\n-    for (Map.Entry\u003cAccessType, AccessControlList\u003e e : acls.entrySet()) {\n-      aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n-    }\n-\n-    StringBuilder labelStrBuilder \u003d new StringBuilder(); \n-    if (accessibleLabels !\u003d null) {\n-      for (String s : accessibleLabels) {\n-        labelStrBuilder.append(s);\n-        labelStrBuilder.append(\",\");\n+      maxApplications \u003d conf.getMaximumApplicationsPerQueue(getQueuePath());\n+      if (maxApplications \u003c 0) {\n+        int maxSystemApps \u003d conf.getMaximumSystemApplications();\n+        maxApplications \u003d\n+            (int) (maxSystemApps * queueCapacities.getAbsoluteCapacity());\n       }\n+      maxApplicationsPerUser \u003d Math.min(maxApplications,\n+          (int) (maxApplications * (userLimit / 100.0f) * userLimitFactor));\n+\n+      maxAMResourcePerQueuePercent \u003d\n+          conf.getMaximumApplicationMasterResourcePerQueuePercent(\n+              getQueuePath());\n+\n+      if (!SchedulerUtils.checkQueueLabelExpression(this.accessibleLabels,\n+          this.defaultLabelExpression, null)) {\n+        throw new IOException(\n+            \"Invalid default label expression of \" + \" queue\u003d\" + getQueueName()\n+                + \" doesn\u0027t have permission to access all labels \"\n+                + \"in default label expression. labelExpression of resource request\u003d\"\n+                + (this.defaultLabelExpression \u003d\u003d null ?\n+                \"\" :\n+                this.defaultLabelExpression) + \". Queue labels\u003d\" + (\n+                getAccessibleNodeLabels() \u003d\u003d null ?\n+                    \"\" :\n+                    StringUtils\n+                        .join(getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n+      }\n+\n+      nodeLocalityDelay \u003d conf.getNodeLocalityDelay();\n+      rackLocalityFullReset \u003d conf.getRackLocalityFullReset();\n+\n+      // re-init this since max allocation could have changed\n+      this.minimumAllocationFactor \u003d Resources.ratio(resourceCalculator,\n+          Resources.subtract(maximumAllocation, minimumAllocation),\n+          maximumAllocation);\n+\n+      StringBuilder aclsString \u003d new StringBuilder();\n+      for (Map.Entry\u003cAccessType, AccessControlList\u003e e : acls.entrySet()) {\n+        aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n+      }\n+\n+      StringBuilder labelStrBuilder \u003d new StringBuilder();\n+      if (accessibleLabels !\u003d null) {\n+        for (String s : accessibleLabels) {\n+          labelStrBuilder.append(s);\n+          labelStrBuilder.append(\",\");\n+        }\n+      }\n+\n+      defaultAppPriorityPerQueue \u003d Priority.newInstance(\n+          conf.getDefaultApplicationPriorityConfPerQueue(getQueuePath()));\n+\n+      LOG.info(\n+          \"Initializing \" + queueName + \"\\n\" + \"capacity \u003d \" + queueCapacities\n+              .getCapacity() + \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\"\n+              + \"absoluteCapacity \u003d \" + queueCapacities.getAbsoluteCapacity()\n+              + \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\"\n+              + \"maxCapacity \u003d \" + queueCapacities.getMaximumCapacity()\n+              + \" [\u003d configuredMaxCapacity ]\" + \"\\n\" + \"absoluteMaxCapacity \u003d \"\n+              + queueCapacities.getAbsoluteMaximumCapacity()\n+              + \" [\u003d 1.0 maximumCapacity undefined, \"\n+              + \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\"\n+              + \"\\n\" + \"userLimit \u003d \" + userLimit + \" [\u003d configuredUserLimit ]\"\n+              + \"\\n\" + \"userLimitFactor \u003d \" + userLimitFactor\n+              + \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" + \"maxApplications \u003d \"\n+              + maxApplications\n+              + \" [\u003d configuredMaximumSystemApplicationsPerQueue or\"\n+              + \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\"\n+              + \"\\n\" + \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser\n+              + \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \"\n+              + \"userLimitFactor) ]\" + \"\\n\" + \"usedCapacity \u003d \"\n+              + queueCapacities.getUsedCapacity() + \" [\u003d usedResourcesMemory / \"\n+              + \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\"\n+              + \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity\n+              + \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\"\n+              + \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent\n+              + \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\"\n+              + \"minimumAllocationFactor \u003d \" + minimumAllocationFactor\n+              + \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \"\n+              + \"maximumAllocationMemory ]\" + \"\\n\" + \"maximumAllocation \u003d \"\n+              + maximumAllocation + \" [\u003d configuredMaxAllocation ]\" + \"\\n\"\n+              + \"numContainers \u003d \" + numContainers\n+              + \" [\u003d currentNumContainers ]\" + \"\\n\" + \"state \u003d \" + state\n+              + \" [\u003d configuredState ]\" + \"\\n\" + \"acls \u003d \" + aclsString\n+              + \" [\u003d configuredAcls ]\" + \"\\n\" + \"nodeLocalityDelay \u003d \"\n+              + nodeLocalityDelay + \"\\n\" + \"labels\u003d\" + labelStrBuilder\n+              .toString() + \"\\n\" + \"reservationsContinueLooking \u003d \"\n+              + reservationsContinueLooking + \"\\n\" + \"preemptionDisabled \u003d \"\n+              + getPreemptionDisabled() + \"\\n\" + \"defaultAppPriorityPerQueue \u003d \"\n+              + defaultAppPriorityPerQueue);\n+    } finally {\n+      writeLock.unlock();\n     }\n-\n-    defaultAppPriorityPerQueue \u003d Priority.newInstance(conf\n-        .getDefaultApplicationPriorityConfPerQueue(getQueuePath()));\n-\n-    LOG.info(\"Initializing \" + queueName + \"\\n\" +\n-        \"capacity \u003d \" + queueCapacities.getCapacity() +\n-        \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n-        \"absoluteCapacity \u003d \" + queueCapacities.getAbsoluteCapacity() +\n-        \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n-        \"maxCapacity \u003d \" + queueCapacities.getMaximumCapacity() +\n-        \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n-        \"absoluteMaxCapacity \u003d \" + queueCapacities.getAbsoluteMaximumCapacity() +\n-        \" [\u003d 1.0 maximumCapacity undefined, \" +\n-        \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n-        \"\\n\" +\n-        \"userLimit \u003d \" + userLimit +\n-        \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n-        \"userLimitFactor \u003d \" + userLimitFactor +\n-        \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n-        \"maxApplications \u003d \" + maxApplications +\n-        \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n-        \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n-        \"\\n\" +\n-        \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n-        \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n-        \"userLimitFactor) ]\" + \"\\n\" +\n-        \"usedCapacity \u003d \" + queueCapacities.getUsedCapacity() +\n-        \" [\u003d usedResourcesMemory / \" +\n-        \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n-        \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n-        \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n-        \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n-        \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n-        \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n-        \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n-        \"maximumAllocationMemory ]\" + \"\\n\" +\n-        \"maximumAllocation \u003d \" + maximumAllocation +\n-        \" [\u003d configuredMaxAllocation ]\" + \"\\n\" +\n-        \"numContainers \u003d \" + numContainers +\n-        \" [\u003d currentNumContainers ]\" + \"\\n\" +\n-        \"state \u003d \" + state +\n-        \" [\u003d configuredState ]\" + \"\\n\" +\n-        \"acls \u003d \" + aclsString +\n-        \" [\u003d configuredAcls ]\" + \"\\n\" + \n-        \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\" +\n-        \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\" +\n-        \"reservationsContinueLooking \u003d \" +\n-        reservationsContinueLooking + \"\\n\" +\n-        \"preemptionDisabled \u003d \" + getPreemptionDisabled() + \"\\n\" +\n-        \"defaultAppPriorityPerQueue \u003d \" + defaultAppPriorityPerQueue);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected void setupQueueConfigs(Resource clusterResource)\n      throws IOException {\n    try {\n      writeLock.lock();\n      super.setupQueueConfigs(clusterResource);\n\n      this.lastClusterResource \u003d clusterResource;\n\n      this.cachedResourceLimitsForHeadroom \u003d new ResourceLimits(\n          clusterResource);\n\n      // Initialize headroom info, also used for calculating application\n      // master resource limits.  Since this happens during queue initialization\n      // and all queues may not be realized yet, we\u0027ll use (optimistic)\n      // absoluteMaxCapacity (it will be replaced with the more accurate\n      // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n      setQueueResourceLimitsInfo(clusterResource);\n\n      CapacitySchedulerConfiguration conf \u003d csContext.getConfiguration();\n\n      setOrderingPolicy(\n          conf.\u003cFiCaSchedulerApp\u003egetOrderingPolicy(getQueuePath()));\n\n      userLimit \u003d conf.getUserLimit(getQueuePath());\n      userLimitFactor \u003d conf.getUserLimitFactor(getQueuePath());\n\n      maxApplications \u003d conf.getMaximumApplicationsPerQueue(getQueuePath());\n      if (maxApplications \u003c 0) {\n        int maxSystemApps \u003d conf.getMaximumSystemApplications();\n        maxApplications \u003d\n            (int) (maxSystemApps * queueCapacities.getAbsoluteCapacity());\n      }\n      maxApplicationsPerUser \u003d Math.min(maxApplications,\n          (int) (maxApplications * (userLimit / 100.0f) * userLimitFactor));\n\n      maxAMResourcePerQueuePercent \u003d\n          conf.getMaximumApplicationMasterResourcePerQueuePercent(\n              getQueuePath());\n\n      if (!SchedulerUtils.checkQueueLabelExpression(this.accessibleLabels,\n          this.defaultLabelExpression, null)) {\n        throw new IOException(\n            \"Invalid default label expression of \" + \" queue\u003d\" + getQueueName()\n                + \" doesn\u0027t have permission to access all labels \"\n                + \"in default label expression. labelExpression of resource request\u003d\"\n                + (this.defaultLabelExpression \u003d\u003d null ?\n                \"\" :\n                this.defaultLabelExpression) + \". Queue labels\u003d\" + (\n                getAccessibleNodeLabels() \u003d\u003d null ?\n                    \"\" :\n                    StringUtils\n                        .join(getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n      }\n\n      nodeLocalityDelay \u003d conf.getNodeLocalityDelay();\n      rackLocalityFullReset \u003d conf.getRackLocalityFullReset();\n\n      // re-init this since max allocation could have changed\n      this.minimumAllocationFactor \u003d Resources.ratio(resourceCalculator,\n          Resources.subtract(maximumAllocation, minimumAllocation),\n          maximumAllocation);\n\n      StringBuilder aclsString \u003d new StringBuilder();\n      for (Map.Entry\u003cAccessType, AccessControlList\u003e e : acls.entrySet()) {\n        aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n      }\n\n      StringBuilder labelStrBuilder \u003d new StringBuilder();\n      if (accessibleLabels !\u003d null) {\n        for (String s : accessibleLabels) {\n          labelStrBuilder.append(s);\n          labelStrBuilder.append(\",\");\n        }\n      }\n\n      defaultAppPriorityPerQueue \u003d Priority.newInstance(\n          conf.getDefaultApplicationPriorityConfPerQueue(getQueuePath()));\n\n      LOG.info(\n          \"Initializing \" + queueName + \"\\n\" + \"capacity \u003d \" + queueCapacities\n              .getCapacity() + \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\"\n              + \"absoluteCapacity \u003d \" + queueCapacities.getAbsoluteCapacity()\n              + \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\"\n              + \"maxCapacity \u003d \" + queueCapacities.getMaximumCapacity()\n              + \" [\u003d configuredMaxCapacity ]\" + \"\\n\" + \"absoluteMaxCapacity \u003d \"\n              + queueCapacities.getAbsoluteMaximumCapacity()\n              + \" [\u003d 1.0 maximumCapacity undefined, \"\n              + \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\"\n              + \"\\n\" + \"userLimit \u003d \" + userLimit + \" [\u003d configuredUserLimit ]\"\n              + \"\\n\" + \"userLimitFactor \u003d \" + userLimitFactor\n              + \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" + \"maxApplications \u003d \"\n              + maxApplications\n              + \" [\u003d configuredMaximumSystemApplicationsPerQueue or\"\n              + \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\"\n              + \"\\n\" + \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser\n              + \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \"\n              + \"userLimitFactor) ]\" + \"\\n\" + \"usedCapacity \u003d \"\n              + queueCapacities.getUsedCapacity() + \" [\u003d usedResourcesMemory / \"\n              + \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\"\n              + \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity\n              + \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\"\n              + \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent\n              + \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\"\n              + \"minimumAllocationFactor \u003d \" + minimumAllocationFactor\n              + \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \"\n              + \"maximumAllocationMemory ]\" + \"\\n\" + \"maximumAllocation \u003d \"\n              + maximumAllocation + \" [\u003d configuredMaxAllocation ]\" + \"\\n\"\n              + \"numContainers \u003d \" + numContainers\n              + \" [\u003d currentNumContainers ]\" + \"\\n\" + \"state \u003d \" + state\n              + \" [\u003d configuredState ]\" + \"\\n\" + \"acls \u003d \" + aclsString\n              + \" [\u003d configuredAcls ]\" + \"\\n\" + \"nodeLocalityDelay \u003d \"\n              + nodeLocalityDelay + \"\\n\" + \"labels\u003d\" + labelStrBuilder\n              .toString() + \"\\n\" + \"reservationsContinueLooking \u003d \"\n              + reservationsContinueLooking + \"\\n\" + \"preemptionDisabled \u003d \"\n              + getPreemptionDisabled() + \"\\n\" + \"defaultAppPriorityPerQueue \u003d \"\n              + defaultAppPriorityPerQueue);\n    } finally {\n      writeLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {}
        }
      ]
    },
    "4174b9756c8c7877797545c4356b1f40df603ec5": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5642. Typos in 9 log messages. Contributed by Mehran Hassani\n",
      "commitDate": "16/09/16 10:05 PM",
      "commitName": "4174b9756c8c7877797545c4356b1f40df603ec5",
      "commitAuthor": "Naganarasimha",
      "commitDateOld": "19/08/16 4:28 PM",
      "commitNameOld": "444b2ea7afebf9f6c3d356154b71abfd0ea95b23",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 28.23,
      "commitsBetweenForRepo": 154,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,120 +1,120 @@\n   protected synchronized void setupQueueConfigs(Resource clusterResource)\n       throws IOException {\n     super.setupQueueConfigs(clusterResource);\n     \n     this.lastClusterResource \u003d clusterResource;\n     \n     this.cachedResourceLimitsForHeadroom \u003d new ResourceLimits(clusterResource);\n     \n     // Initialize headroom info, also used for calculating application \n     // master resource limits.  Since this happens during queue initialization\n     // and all queues may not be realized yet, we\u0027ll use (optimistic) \n     // absoluteMaxCapacity (it will be replaced with the more accurate \n     // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n     setQueueResourceLimitsInfo(clusterResource);\n \n     CapacitySchedulerConfiguration conf \u003d csContext.getConfiguration();\n \n     setOrderingPolicy(conf.\u003cFiCaSchedulerApp\u003egetOrderingPolicy(getQueuePath()));\n \n     userLimit \u003d conf.getUserLimit(getQueuePath());\n     userLimitFactor \u003d conf.getUserLimitFactor(getQueuePath());\n \n     maxApplications \u003d conf.getMaximumApplicationsPerQueue(getQueuePath());\n     if (maxApplications \u003c 0) {\n       int maxSystemApps \u003d conf.getMaximumSystemApplications();\n       maxApplications \u003d\n           (int) (maxSystemApps * queueCapacities.getAbsoluteCapacity());\n     }\n     maxApplicationsPerUser \u003d Math.min(maxApplications,\n         (int)(maxApplications * (userLimit / 100.0f) * userLimitFactor));\n     \n     maxAMResourcePerQueuePercent \u003d\n         conf.getMaximumApplicationMasterResourcePerQueuePercent(getQueuePath());\n \n     if (!SchedulerUtils.checkQueueLabelExpression(\n         this.accessibleLabels, this.defaultLabelExpression, null)) {\n       throw new IOException(\"Invalid default label expression of \"\n           + \" queue\u003d\"\n           + getQueueName()\n           + \" doesn\u0027t have permission to access all labels \"\n           + \"in default label expression. labelExpression of resource request\u003d\"\n           + (this.defaultLabelExpression \u003d\u003d null ? \"\"\n               : this.defaultLabelExpression)\n           + \". Queue labels\u003d\"\n           + (getAccessibleNodeLabels() \u003d\u003d null ? \"\" : StringUtils.join(\n               getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n     }\n     \n     nodeLocalityDelay \u003d conf.getNodeLocalityDelay();\n     rackLocalityFullReset \u003d conf.getRackLocalityFullReset();\n \n     // re-init this since max allocation could have changed\n     this.minimumAllocationFactor \u003d\n         Resources.ratio(resourceCalculator,\n             Resources.subtract(maximumAllocation, minimumAllocation),\n             maximumAllocation);\n \n     StringBuilder aclsString \u003d new StringBuilder();\n     for (Map.Entry\u003cAccessType, AccessControlList\u003e e : acls.entrySet()) {\n       aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n     }\n \n     StringBuilder labelStrBuilder \u003d new StringBuilder(); \n     if (accessibleLabels !\u003d null) {\n       for (String s : accessibleLabels) {\n         labelStrBuilder.append(s);\n         labelStrBuilder.append(\",\");\n       }\n     }\n \n     defaultAppPriorityPerQueue \u003d Priority.newInstance(conf\n         .getDefaultApplicationPriorityConfPerQueue(getQueuePath()));\n \n     LOG.info(\"Initializing \" + queueName + \"\\n\" +\n         \"capacity \u003d \" + queueCapacities.getCapacity() +\n         \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n-        \"asboluteCapacity \u003d \" + queueCapacities.getAbsoluteCapacity() +\n+        \"absoluteCapacity \u003d \" + queueCapacities.getAbsoluteCapacity() +\n         \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n         \"maxCapacity \u003d \" + queueCapacities.getMaximumCapacity() +\n         \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n         \"absoluteMaxCapacity \u003d \" + queueCapacities.getAbsoluteMaximumCapacity() +\n         \" [\u003d 1.0 maximumCapacity undefined, \" +\n         \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n         \"\\n\" +\n         \"userLimit \u003d \" + userLimit +\n         \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n         \"userLimitFactor \u003d \" + userLimitFactor +\n         \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n         \"maxApplications \u003d \" + maxApplications +\n         \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n         \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n         \"\\n\" +\n         \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n         \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n         \"userLimitFactor) ]\" + \"\\n\" +\n         \"usedCapacity \u003d \" + queueCapacities.getUsedCapacity() +\n         \" [\u003d usedResourcesMemory / \" +\n         \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n         \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n         \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n         \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n         \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n         \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n         \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n         \"maximumAllocationMemory ]\" + \"\\n\" +\n         \"maximumAllocation \u003d \" + maximumAllocation +\n         \" [\u003d configuredMaxAllocation ]\" + \"\\n\" +\n         \"numContainers \u003d \" + numContainers +\n         \" [\u003d currentNumContainers ]\" + \"\\n\" +\n         \"state \u003d \" + state +\n         \" [\u003d configuredState ]\" + \"\\n\" +\n         \"acls \u003d \" + aclsString +\n         \" [\u003d configuredAcls ]\" + \"\\n\" + \n         \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\" +\n         \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\" +\n         \"reservationsContinueLooking \u003d \" +\n         reservationsContinueLooking + \"\\n\" +\n         \"preemptionDisabled \u003d \" + getPreemptionDisabled() + \"\\n\" +\n         \"defaultAppPriorityPerQueue \u003d \" + defaultAppPriorityPerQueue);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void setupQueueConfigs(Resource clusterResource)\n      throws IOException {\n    super.setupQueueConfigs(clusterResource);\n    \n    this.lastClusterResource \u003d clusterResource;\n    \n    this.cachedResourceLimitsForHeadroom \u003d new ResourceLimits(clusterResource);\n    \n    // Initialize headroom info, also used for calculating application \n    // master resource limits.  Since this happens during queue initialization\n    // and all queues may not be realized yet, we\u0027ll use (optimistic) \n    // absoluteMaxCapacity (it will be replaced with the more accurate \n    // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n    setQueueResourceLimitsInfo(clusterResource);\n\n    CapacitySchedulerConfiguration conf \u003d csContext.getConfiguration();\n\n    setOrderingPolicy(conf.\u003cFiCaSchedulerApp\u003egetOrderingPolicy(getQueuePath()));\n\n    userLimit \u003d conf.getUserLimit(getQueuePath());\n    userLimitFactor \u003d conf.getUserLimitFactor(getQueuePath());\n\n    maxApplications \u003d conf.getMaximumApplicationsPerQueue(getQueuePath());\n    if (maxApplications \u003c 0) {\n      int maxSystemApps \u003d conf.getMaximumSystemApplications();\n      maxApplications \u003d\n          (int) (maxSystemApps * queueCapacities.getAbsoluteCapacity());\n    }\n    maxApplicationsPerUser \u003d Math.min(maxApplications,\n        (int)(maxApplications * (userLimit / 100.0f) * userLimitFactor));\n    \n    maxAMResourcePerQueuePercent \u003d\n        conf.getMaximumApplicationMasterResourcePerQueuePercent(getQueuePath());\n\n    if (!SchedulerUtils.checkQueueLabelExpression(\n        this.accessibleLabels, this.defaultLabelExpression, null)) {\n      throw new IOException(\"Invalid default label expression of \"\n          + \" queue\u003d\"\n          + getQueueName()\n          + \" doesn\u0027t have permission to access all labels \"\n          + \"in default label expression. labelExpression of resource request\u003d\"\n          + (this.defaultLabelExpression \u003d\u003d null ? \"\"\n              : this.defaultLabelExpression)\n          + \". Queue labels\u003d\"\n          + (getAccessibleNodeLabels() \u003d\u003d null ? \"\" : StringUtils.join(\n              getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n    }\n    \n    nodeLocalityDelay \u003d conf.getNodeLocalityDelay();\n    rackLocalityFullReset \u003d conf.getRackLocalityFullReset();\n\n    // re-init this since max allocation could have changed\n    this.minimumAllocationFactor \u003d\n        Resources.ratio(resourceCalculator,\n            Resources.subtract(maximumAllocation, minimumAllocation),\n            maximumAllocation);\n\n    StringBuilder aclsString \u003d new StringBuilder();\n    for (Map.Entry\u003cAccessType, AccessControlList\u003e e : acls.entrySet()) {\n      aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n    }\n\n    StringBuilder labelStrBuilder \u003d new StringBuilder(); \n    if (accessibleLabels !\u003d null) {\n      for (String s : accessibleLabels) {\n        labelStrBuilder.append(s);\n        labelStrBuilder.append(\",\");\n      }\n    }\n\n    defaultAppPriorityPerQueue \u003d Priority.newInstance(conf\n        .getDefaultApplicationPriorityConfPerQueue(getQueuePath()));\n\n    LOG.info(\"Initializing \" + queueName + \"\\n\" +\n        \"capacity \u003d \" + queueCapacities.getCapacity() +\n        \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n        \"absoluteCapacity \u003d \" + queueCapacities.getAbsoluteCapacity() +\n        \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n        \"maxCapacity \u003d \" + queueCapacities.getMaximumCapacity() +\n        \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n        \"absoluteMaxCapacity \u003d \" + queueCapacities.getAbsoluteMaximumCapacity() +\n        \" [\u003d 1.0 maximumCapacity undefined, \" +\n        \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n        \"\\n\" +\n        \"userLimit \u003d \" + userLimit +\n        \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n        \"userLimitFactor \u003d \" + userLimitFactor +\n        \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n        \"maxApplications \u003d \" + maxApplications +\n        \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n        \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n        \"\\n\" +\n        \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n        \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n        \"userLimitFactor) ]\" + \"\\n\" +\n        \"usedCapacity \u003d \" + queueCapacities.getUsedCapacity() +\n        \" [\u003d usedResourcesMemory / \" +\n        \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n        \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n        \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n        \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n        \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n        \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n        \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n        \"maximumAllocationMemory ]\" + \"\\n\" +\n        \"maximumAllocation \u003d \" + maximumAllocation +\n        \" [\u003d configuredMaxAllocation ]\" + \"\\n\" +\n        \"numContainers \u003d \" + numContainers +\n        \" [\u003d currentNumContainers ]\" + \"\\n\" +\n        \"state \u003d \" + state +\n        \" [\u003d configuredState ]\" + \"\\n\" +\n        \"acls \u003d \" + aclsString +\n        \" [\u003d configuredAcls ]\" + \"\\n\" + \n        \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\" +\n        \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\" +\n        \"reservationsContinueLooking \u003d \" +\n        reservationsContinueLooking + \"\\n\" +\n        \"preemptionDisabled \u003d \" + getPreemptionDisabled() + \"\\n\" +\n        \"defaultAppPriorityPerQueue \u003d \" + defaultAppPriorityPerQueue);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "ac954486c5102b8fbbc4229a0d3a512bcc7013c0": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5055. max apps per user can be larger than max per queue. Contributed by Eric Badger\n",
      "commitDate": "23/05/16 8:54 AM",
      "commitName": "ac954486c5102b8fbbc4229a0d3a512bcc7013c0",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "16/04/16 10:47 PM",
      "commitNameOld": "fdc46bfb37776d8c41b68f6c33a2379d0f329994",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 36.42,
      "commitsBetweenForRepo": 233,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,120 +1,120 @@\n   protected synchronized void setupQueueConfigs(Resource clusterResource)\n       throws IOException {\n     super.setupQueueConfigs(clusterResource);\n     \n     this.lastClusterResource \u003d clusterResource;\n     \n     this.cachedResourceLimitsForHeadroom \u003d new ResourceLimits(clusterResource);\n     \n     // Initialize headroom info, also used for calculating application \n     // master resource limits.  Since this happens during queue initialization\n     // and all queues may not be realized yet, we\u0027ll use (optimistic) \n     // absoluteMaxCapacity (it will be replaced with the more accurate \n     // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n     setQueueResourceLimitsInfo(clusterResource);\n \n     CapacitySchedulerConfiguration conf \u003d csContext.getConfiguration();\n     \n     setOrderingPolicy(conf.\u003cFiCaSchedulerApp\u003egetOrderingPolicy(getQueuePath()));\n \n     userLimit \u003d conf.getUserLimit(getQueuePath());\n     userLimitFactor \u003d conf.getUserLimitFactor(getQueuePath());\n \n     maxApplications \u003d conf.getMaximumApplicationsPerQueue(getQueuePath());\n     if (maxApplications \u003c 0) {\n       int maxSystemApps \u003d conf.getMaximumSystemApplications();\n       maxApplications \u003d\n           (int) (maxSystemApps * queueCapacities.getAbsoluteCapacity());\n     }\n-    maxApplicationsPerUser \u003d \n-      (int)(maxApplications * (userLimit / 100.0f) * userLimitFactor);\n+    maxApplicationsPerUser \u003d Math.min(maxApplications,\n+        (int)(maxApplications * (userLimit / 100.0f) * userLimitFactor));\n     \n     maxAMResourcePerQueuePercent \u003d\n         conf.getMaximumApplicationMasterResourcePerQueuePercent(getQueuePath());\n \n     if (!SchedulerUtils.checkQueueLabelExpression(\n         this.accessibleLabels, this.defaultLabelExpression, null)) {\n       throw new IOException(\"Invalid default label expression of \"\n           + \" queue\u003d\"\n           + getQueueName()\n           + \" doesn\u0027t have permission to access all labels \"\n           + \"in default label expression. labelExpression of resource request\u003d\"\n           + (this.defaultLabelExpression \u003d\u003d null ? \"\"\n               : this.defaultLabelExpression)\n           + \". Queue labels\u003d\"\n           + (getAccessibleNodeLabels() \u003d\u003d null ? \"\" : StringUtils.join(\n               getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n     }\n     \n     nodeLocalityDelay \u003d conf.getNodeLocalityDelay();\n     rackLocalityFullReset \u003d conf.getRackLocalityFullReset();\n \n     // re-init this since max allocation could have changed\n     this.minimumAllocationFactor \u003d\n         Resources.ratio(resourceCalculator,\n             Resources.subtract(maximumAllocation, minimumAllocation),\n             maximumAllocation);\n \n     StringBuilder aclsString \u003d new StringBuilder();\n     for (Map.Entry\u003cAccessType, AccessControlList\u003e e : acls.entrySet()) {\n       aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n     }\n \n     StringBuilder labelStrBuilder \u003d new StringBuilder(); \n     if (accessibleLabels !\u003d null) {\n       for (String s : accessibleLabels) {\n         labelStrBuilder.append(s);\n         labelStrBuilder.append(\",\");\n       }\n     }\n \n     defaultAppPriorityPerQueue \u003d Priority.newInstance(conf\n         .getDefaultApplicationPriorityConfPerQueue(getQueuePath()));\n \n     LOG.info(\"Initializing \" + queueName + \"\\n\" +\n         \"capacity \u003d \" + queueCapacities.getCapacity() +\n         \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n         \"asboluteCapacity \u003d \" + queueCapacities.getAbsoluteCapacity() +\n         \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n         \"maxCapacity \u003d \" + queueCapacities.getMaximumCapacity() +\n         \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n         \"absoluteMaxCapacity \u003d \" + queueCapacities.getAbsoluteMaximumCapacity() +\n         \" [\u003d 1.0 maximumCapacity undefined, \" +\n         \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n         \"\\n\" +\n         \"userLimit \u003d \" + userLimit +\n         \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n         \"userLimitFactor \u003d \" + userLimitFactor +\n         \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n         \"maxApplications \u003d \" + maxApplications +\n         \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n         \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n         \"\\n\" +\n         \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n         \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n         \"userLimitFactor) ]\" + \"\\n\" +\n         \"usedCapacity \u003d \" + queueCapacities.getUsedCapacity() +\n         \" [\u003d usedResourcesMemory / \" +\n         \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n         \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n         \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n         \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n         \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n         \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n         \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n         \"maximumAllocationMemory ]\" + \"\\n\" +\n         \"maximumAllocation \u003d \" + maximumAllocation +\n         \" [\u003d configuredMaxAllocation ]\" + \"\\n\" +\n         \"numContainers \u003d \" + numContainers +\n         \" [\u003d currentNumContainers ]\" + \"\\n\" +\n         \"state \u003d \" + state +\n         \" [\u003d configuredState ]\" + \"\\n\" +\n         \"acls \u003d \" + aclsString +\n         \" [\u003d configuredAcls ]\" + \"\\n\" + \n         \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\" +\n         \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\" +\n         \"reservationsContinueLooking \u003d \" +\n         reservationsContinueLooking + \"\\n\" +\n         \"preemptionDisabled \u003d \" + getPreemptionDisabled() + \"\\n\" +\n         \"defaultAppPriorityPerQueue \u003d \" + defaultAppPriorityPerQueue);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void setupQueueConfigs(Resource clusterResource)\n      throws IOException {\n    super.setupQueueConfigs(clusterResource);\n    \n    this.lastClusterResource \u003d clusterResource;\n    \n    this.cachedResourceLimitsForHeadroom \u003d new ResourceLimits(clusterResource);\n    \n    // Initialize headroom info, also used for calculating application \n    // master resource limits.  Since this happens during queue initialization\n    // and all queues may not be realized yet, we\u0027ll use (optimistic) \n    // absoluteMaxCapacity (it will be replaced with the more accurate \n    // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n    setQueueResourceLimitsInfo(clusterResource);\n\n    CapacitySchedulerConfiguration conf \u003d csContext.getConfiguration();\n    \n    setOrderingPolicy(conf.\u003cFiCaSchedulerApp\u003egetOrderingPolicy(getQueuePath()));\n\n    userLimit \u003d conf.getUserLimit(getQueuePath());\n    userLimitFactor \u003d conf.getUserLimitFactor(getQueuePath());\n\n    maxApplications \u003d conf.getMaximumApplicationsPerQueue(getQueuePath());\n    if (maxApplications \u003c 0) {\n      int maxSystemApps \u003d conf.getMaximumSystemApplications();\n      maxApplications \u003d\n          (int) (maxSystemApps * queueCapacities.getAbsoluteCapacity());\n    }\n    maxApplicationsPerUser \u003d Math.min(maxApplications,\n        (int)(maxApplications * (userLimit / 100.0f) * userLimitFactor));\n    \n    maxAMResourcePerQueuePercent \u003d\n        conf.getMaximumApplicationMasterResourcePerQueuePercent(getQueuePath());\n\n    if (!SchedulerUtils.checkQueueLabelExpression(\n        this.accessibleLabels, this.defaultLabelExpression, null)) {\n      throw new IOException(\"Invalid default label expression of \"\n          + \" queue\u003d\"\n          + getQueueName()\n          + \" doesn\u0027t have permission to access all labels \"\n          + \"in default label expression. labelExpression of resource request\u003d\"\n          + (this.defaultLabelExpression \u003d\u003d null ? \"\"\n              : this.defaultLabelExpression)\n          + \". Queue labels\u003d\"\n          + (getAccessibleNodeLabels() \u003d\u003d null ? \"\" : StringUtils.join(\n              getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n    }\n    \n    nodeLocalityDelay \u003d conf.getNodeLocalityDelay();\n    rackLocalityFullReset \u003d conf.getRackLocalityFullReset();\n\n    // re-init this since max allocation could have changed\n    this.minimumAllocationFactor \u003d\n        Resources.ratio(resourceCalculator,\n            Resources.subtract(maximumAllocation, minimumAllocation),\n            maximumAllocation);\n\n    StringBuilder aclsString \u003d new StringBuilder();\n    for (Map.Entry\u003cAccessType, AccessControlList\u003e e : acls.entrySet()) {\n      aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n    }\n\n    StringBuilder labelStrBuilder \u003d new StringBuilder(); \n    if (accessibleLabels !\u003d null) {\n      for (String s : accessibleLabels) {\n        labelStrBuilder.append(s);\n        labelStrBuilder.append(\",\");\n      }\n    }\n\n    defaultAppPriorityPerQueue \u003d Priority.newInstance(conf\n        .getDefaultApplicationPriorityConfPerQueue(getQueuePath()));\n\n    LOG.info(\"Initializing \" + queueName + \"\\n\" +\n        \"capacity \u003d \" + queueCapacities.getCapacity() +\n        \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n        \"asboluteCapacity \u003d \" + queueCapacities.getAbsoluteCapacity() +\n        \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n        \"maxCapacity \u003d \" + queueCapacities.getMaximumCapacity() +\n        \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n        \"absoluteMaxCapacity \u003d \" + queueCapacities.getAbsoluteMaximumCapacity() +\n        \" [\u003d 1.0 maximumCapacity undefined, \" +\n        \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n        \"\\n\" +\n        \"userLimit \u003d \" + userLimit +\n        \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n        \"userLimitFactor \u003d \" + userLimitFactor +\n        \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n        \"maxApplications \u003d \" + maxApplications +\n        \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n        \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n        \"\\n\" +\n        \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n        \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n        \"userLimitFactor) ]\" + \"\\n\" +\n        \"usedCapacity \u003d \" + queueCapacities.getUsedCapacity() +\n        \" [\u003d usedResourcesMemory / \" +\n        \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n        \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n        \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n        \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n        \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n        \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n        \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n        \"maximumAllocationMemory ]\" + \"\\n\" +\n        \"maximumAllocation \u003d \" + maximumAllocation +\n        \" [\u003d configuredMaxAllocation ]\" + \"\\n\" +\n        \"numContainers \u003d \" + numContainers +\n        \" [\u003d currentNumContainers ]\" + \"\\n\" +\n        \"state \u003d \" + state +\n        \" [\u003d configuredState ]\" + \"\\n\" +\n        \"acls \u003d \" + aclsString +\n        \" [\u003d configuredAcls ]\" + \"\\n\" + \n        \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\" +\n        \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\" +\n        \"reservationsContinueLooking \u003d \" +\n        reservationsContinueLooking + \"\\n\" +\n        \"preemptionDisabled \u003d \" + getPreemptionDisabled() + \"\\n\" +\n        \"defaultAppPriorityPerQueue \u003d \" + defaultAppPriorityPerQueue);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "f4a57d4a531e793373fe3118d644871a3b9ae0b1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4617. LeafQueue#pendingOrderingPolicy should always use fixed ordering policy instead of using same as active applications ordering policy. Contributed by Rohith Sharma K S\n",
      "commitDate": "29/01/16 12:22 PM",
      "commitName": "f4a57d4a531e793373fe3118d644871a3b9ae0b1",
      "commitAuthor": "Jian He",
      "commitDateOld": "28/01/16 2:51 PM",
      "commitNameOld": "7f46636495e23693d588b0915f464fa7afd9102e",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 0.9,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,124 +1,120 @@\n   protected synchronized void setupQueueConfigs(Resource clusterResource)\n       throws IOException {\n     super.setupQueueConfigs(clusterResource);\n     \n     this.lastClusterResource \u003d clusterResource;\n     \n     this.cachedResourceLimitsForHeadroom \u003d new ResourceLimits(clusterResource);\n     \n     // Initialize headroom info, also used for calculating application \n     // master resource limits.  Since this happens during queue initialization\n     // and all queues may not be realized yet, we\u0027ll use (optimistic) \n     // absoluteMaxCapacity (it will be replaced with the more accurate \n     // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n     setQueueResourceLimitsInfo(clusterResource);\n \n     CapacitySchedulerConfiguration conf \u003d csContext.getConfiguration();\n     \n     setOrderingPolicy(conf.\u003cFiCaSchedulerApp\u003egetOrderingPolicy(getQueuePath()));\n-    setPendingAppsOrderingPolicy(conf\n-        .\u003cFiCaSchedulerApp\u003e getOrderingPolicy(getQueuePath()));\n-    setPendingAppsOrderingPolicyRecovery(conf\n-        .\u003cFiCaSchedulerApp\u003e getOrderingPolicy(getQueuePath()));\n-    \n+\n     userLimit \u003d conf.getUserLimit(getQueuePath());\n     userLimitFactor \u003d conf.getUserLimitFactor(getQueuePath());\n \n     maxApplications \u003d conf.getMaximumApplicationsPerQueue(getQueuePath());\n     if (maxApplications \u003c 0) {\n       int maxSystemApps \u003d conf.getMaximumSystemApplications();\n       maxApplications \u003d\n           (int) (maxSystemApps * queueCapacities.getAbsoluteCapacity());\n     }\n     maxApplicationsPerUser \u003d \n       (int)(maxApplications * (userLimit / 100.0f) * userLimitFactor);\n     \n     maxAMResourcePerQueuePercent \u003d\n         conf.getMaximumApplicationMasterResourcePerQueuePercent(getQueuePath());\n \n     if (!SchedulerUtils.checkQueueLabelExpression(\n         this.accessibleLabels, this.defaultLabelExpression, null)) {\n       throw new IOException(\"Invalid default label expression of \"\n           + \" queue\u003d\"\n           + getQueueName()\n           + \" doesn\u0027t have permission to access all labels \"\n           + \"in default label expression. labelExpression of resource request\u003d\"\n           + (this.defaultLabelExpression \u003d\u003d null ? \"\"\n               : this.defaultLabelExpression)\n           + \". Queue labels\u003d\"\n           + (getAccessibleNodeLabels() \u003d\u003d null ? \"\" : StringUtils.join(\n               getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n     }\n     \n     nodeLocalityDelay \u003d conf.getNodeLocalityDelay();\n     rackLocalityFullReset \u003d conf.getRackLocalityFullReset();\n \n     // re-init this since max allocation could have changed\n     this.minimumAllocationFactor \u003d\n         Resources.ratio(resourceCalculator,\n             Resources.subtract(maximumAllocation, minimumAllocation),\n             maximumAllocation);\n \n     StringBuilder aclsString \u003d new StringBuilder();\n     for (Map.Entry\u003cAccessType, AccessControlList\u003e e : acls.entrySet()) {\n       aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n     }\n \n     StringBuilder labelStrBuilder \u003d new StringBuilder(); \n     if (accessibleLabels !\u003d null) {\n       for (String s : accessibleLabels) {\n         labelStrBuilder.append(s);\n         labelStrBuilder.append(\",\");\n       }\n     }\n \n     defaultAppPriorityPerQueue \u003d Priority.newInstance(conf\n         .getDefaultApplicationPriorityConfPerQueue(getQueuePath()));\n \n     LOG.info(\"Initializing \" + queueName + \"\\n\" +\n         \"capacity \u003d \" + queueCapacities.getCapacity() +\n         \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n         \"asboluteCapacity \u003d \" + queueCapacities.getAbsoluteCapacity() +\n         \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n         \"maxCapacity \u003d \" + queueCapacities.getMaximumCapacity() +\n         \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n         \"absoluteMaxCapacity \u003d \" + queueCapacities.getAbsoluteMaximumCapacity() +\n         \" [\u003d 1.0 maximumCapacity undefined, \" +\n         \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n         \"\\n\" +\n         \"userLimit \u003d \" + userLimit +\n         \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n         \"userLimitFactor \u003d \" + userLimitFactor +\n         \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n         \"maxApplications \u003d \" + maxApplications +\n         \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n         \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n         \"\\n\" +\n         \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n         \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n         \"userLimitFactor) ]\" + \"\\n\" +\n         \"usedCapacity \u003d \" + queueCapacities.getUsedCapacity() +\n         \" [\u003d usedResourcesMemory / \" +\n         \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n         \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n         \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n         \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n         \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n         \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n         \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n         \"maximumAllocationMemory ]\" + \"\\n\" +\n         \"maximumAllocation \u003d \" + maximumAllocation +\n         \" [\u003d configuredMaxAllocation ]\" + \"\\n\" +\n         \"numContainers \u003d \" + numContainers +\n         \" [\u003d currentNumContainers ]\" + \"\\n\" +\n         \"state \u003d \" + state +\n         \" [\u003d configuredState ]\" + \"\\n\" +\n         \"acls \u003d \" + aclsString +\n         \" [\u003d configuredAcls ]\" + \"\\n\" + \n         \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\" +\n         \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\" +\n         \"reservationsContinueLooking \u003d \" +\n         reservationsContinueLooking + \"\\n\" +\n         \"preemptionDisabled \u003d \" + getPreemptionDisabled() + \"\\n\" +\n         \"defaultAppPriorityPerQueue \u003d \" + defaultAppPriorityPerQueue);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void setupQueueConfigs(Resource clusterResource)\n      throws IOException {\n    super.setupQueueConfigs(clusterResource);\n    \n    this.lastClusterResource \u003d clusterResource;\n    \n    this.cachedResourceLimitsForHeadroom \u003d new ResourceLimits(clusterResource);\n    \n    // Initialize headroom info, also used for calculating application \n    // master resource limits.  Since this happens during queue initialization\n    // and all queues may not be realized yet, we\u0027ll use (optimistic) \n    // absoluteMaxCapacity (it will be replaced with the more accurate \n    // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n    setQueueResourceLimitsInfo(clusterResource);\n\n    CapacitySchedulerConfiguration conf \u003d csContext.getConfiguration();\n    \n    setOrderingPolicy(conf.\u003cFiCaSchedulerApp\u003egetOrderingPolicy(getQueuePath()));\n\n    userLimit \u003d conf.getUserLimit(getQueuePath());\n    userLimitFactor \u003d conf.getUserLimitFactor(getQueuePath());\n\n    maxApplications \u003d conf.getMaximumApplicationsPerQueue(getQueuePath());\n    if (maxApplications \u003c 0) {\n      int maxSystemApps \u003d conf.getMaximumSystemApplications();\n      maxApplications \u003d\n          (int) (maxSystemApps * queueCapacities.getAbsoluteCapacity());\n    }\n    maxApplicationsPerUser \u003d \n      (int)(maxApplications * (userLimit / 100.0f) * userLimitFactor);\n    \n    maxAMResourcePerQueuePercent \u003d\n        conf.getMaximumApplicationMasterResourcePerQueuePercent(getQueuePath());\n\n    if (!SchedulerUtils.checkQueueLabelExpression(\n        this.accessibleLabels, this.defaultLabelExpression, null)) {\n      throw new IOException(\"Invalid default label expression of \"\n          + \" queue\u003d\"\n          + getQueueName()\n          + \" doesn\u0027t have permission to access all labels \"\n          + \"in default label expression. labelExpression of resource request\u003d\"\n          + (this.defaultLabelExpression \u003d\u003d null ? \"\"\n              : this.defaultLabelExpression)\n          + \". Queue labels\u003d\"\n          + (getAccessibleNodeLabels() \u003d\u003d null ? \"\" : StringUtils.join(\n              getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n    }\n    \n    nodeLocalityDelay \u003d conf.getNodeLocalityDelay();\n    rackLocalityFullReset \u003d conf.getRackLocalityFullReset();\n\n    // re-init this since max allocation could have changed\n    this.minimumAllocationFactor \u003d\n        Resources.ratio(resourceCalculator,\n            Resources.subtract(maximumAllocation, minimumAllocation),\n            maximumAllocation);\n\n    StringBuilder aclsString \u003d new StringBuilder();\n    for (Map.Entry\u003cAccessType, AccessControlList\u003e e : acls.entrySet()) {\n      aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n    }\n\n    StringBuilder labelStrBuilder \u003d new StringBuilder(); \n    if (accessibleLabels !\u003d null) {\n      for (String s : accessibleLabels) {\n        labelStrBuilder.append(s);\n        labelStrBuilder.append(\",\");\n      }\n    }\n\n    defaultAppPriorityPerQueue \u003d Priority.newInstance(conf\n        .getDefaultApplicationPriorityConfPerQueue(getQueuePath()));\n\n    LOG.info(\"Initializing \" + queueName + \"\\n\" +\n        \"capacity \u003d \" + queueCapacities.getCapacity() +\n        \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n        \"asboluteCapacity \u003d \" + queueCapacities.getAbsoluteCapacity() +\n        \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n        \"maxCapacity \u003d \" + queueCapacities.getMaximumCapacity() +\n        \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n        \"absoluteMaxCapacity \u003d \" + queueCapacities.getAbsoluteMaximumCapacity() +\n        \" [\u003d 1.0 maximumCapacity undefined, \" +\n        \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n        \"\\n\" +\n        \"userLimit \u003d \" + userLimit +\n        \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n        \"userLimitFactor \u003d \" + userLimitFactor +\n        \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n        \"maxApplications \u003d \" + maxApplications +\n        \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n        \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n        \"\\n\" +\n        \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n        \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n        \"userLimitFactor) ]\" + \"\\n\" +\n        \"usedCapacity \u003d \" + queueCapacities.getUsedCapacity() +\n        \" [\u003d usedResourcesMemory / \" +\n        \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n        \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n        \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n        \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n        \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n        \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n        \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n        \"maximumAllocationMemory ]\" + \"\\n\" +\n        \"maximumAllocation \u003d \" + maximumAllocation +\n        \" [\u003d configuredMaxAllocation ]\" + \"\\n\" +\n        \"numContainers \u003d \" + numContainers +\n        \" [\u003d currentNumContainers ]\" + \"\\n\" +\n        \"state \u003d \" + state +\n        \" [\u003d configuredState ]\" + \"\\n\" +\n        \"acls \u003d \" + aclsString +\n        \" [\u003d configuredAcls ]\" + \"\\n\" + \n        \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\" +\n        \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\" +\n        \"reservationsContinueLooking \u003d \" +\n        reservationsContinueLooking + \"\\n\" +\n        \"preemptionDisabled \u003d \" + getPreemptionDisabled() + \"\\n\" +\n        \"defaultAppPriorityPerQueue \u003d \" + defaultAppPriorityPerQueue);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "109e528ef5d8df07443373751266b4417acc981a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4479. Change CS LeafQueue pendingOrderingPolicy to hornor recovered apps. Contributed by Rohith Sharma K S\n",
      "commitDate": "08/01/16 3:51 PM",
      "commitName": "109e528ef5d8df07443373751266b4417acc981a",
      "commitAuthor": "Jian He",
      "commitDateOld": "30/12/15 3:30 PM",
      "commitNameOld": "8310b2e9ff3d6804bad703c4c15458b0dfeeb4af",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 9.01,
      "commitsBetweenForRepo": 41,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,122 +1,124 @@\n   protected synchronized void setupQueueConfigs(Resource clusterResource)\n       throws IOException {\n     super.setupQueueConfigs(clusterResource);\n     \n     this.lastClusterResource \u003d clusterResource;\n     \n     this.cachedResourceLimitsForHeadroom \u003d new ResourceLimits(clusterResource);\n     \n     // Initialize headroom info, also used for calculating application \n     // master resource limits.  Since this happens during queue initialization\n     // and all queues may not be realized yet, we\u0027ll use (optimistic) \n     // absoluteMaxCapacity (it will be replaced with the more accurate \n     // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n     setQueueResourceLimitsInfo(clusterResource);\n \n     CapacitySchedulerConfiguration conf \u003d csContext.getConfiguration();\n     \n     setOrderingPolicy(conf.\u003cFiCaSchedulerApp\u003egetOrderingPolicy(getQueuePath()));\n     setPendingAppsOrderingPolicy(conf\n         .\u003cFiCaSchedulerApp\u003e getOrderingPolicy(getQueuePath()));\n+    setPendingAppsOrderingPolicyRecovery(conf\n+        .\u003cFiCaSchedulerApp\u003e getOrderingPolicy(getQueuePath()));\n     \n     userLimit \u003d conf.getUserLimit(getQueuePath());\n     userLimitFactor \u003d conf.getUserLimitFactor(getQueuePath());\n \n     maxApplications \u003d conf.getMaximumApplicationsPerQueue(getQueuePath());\n     if (maxApplications \u003c 0) {\n       int maxSystemApps \u003d conf.getMaximumSystemApplications();\n       maxApplications \u003d\n           (int) (maxSystemApps * queueCapacities.getAbsoluteCapacity());\n     }\n     maxApplicationsPerUser \u003d \n       (int)(maxApplications * (userLimit / 100.0f) * userLimitFactor);\n     \n     maxAMResourcePerQueuePercent \u003d\n         conf.getMaximumApplicationMasterResourcePerQueuePercent(getQueuePath());\n \n     if (!SchedulerUtils.checkQueueLabelExpression(\n         this.accessibleLabels, this.defaultLabelExpression, null)) {\n       throw new IOException(\"Invalid default label expression of \"\n           + \" queue\u003d\"\n           + getQueueName()\n           + \" doesn\u0027t have permission to access all labels \"\n           + \"in default label expression. labelExpression of resource request\u003d\"\n           + (this.defaultLabelExpression \u003d\u003d null ? \"\"\n               : this.defaultLabelExpression)\n           + \". Queue labels\u003d\"\n           + (getAccessibleNodeLabels() \u003d\u003d null ? \"\" : StringUtils.join(\n               getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n     }\n     \n     nodeLocalityDelay \u003d conf.getNodeLocalityDelay();\n     rackLocalityFullReset \u003d conf.getRackLocalityFullReset();\n \n     // re-init this since max allocation could have changed\n     this.minimumAllocationFactor \u003d\n         Resources.ratio(resourceCalculator,\n             Resources.subtract(maximumAllocation, minimumAllocation),\n             maximumAllocation);\n \n     StringBuilder aclsString \u003d new StringBuilder();\n     for (Map.Entry\u003cAccessType, AccessControlList\u003e e : acls.entrySet()) {\n       aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n     }\n \n     StringBuilder labelStrBuilder \u003d new StringBuilder(); \n     if (accessibleLabels !\u003d null) {\n       for (String s : accessibleLabels) {\n         labelStrBuilder.append(s);\n         labelStrBuilder.append(\",\");\n       }\n     }\n \n     defaultAppPriorityPerQueue \u003d Priority.newInstance(conf\n         .getDefaultApplicationPriorityConfPerQueue(getQueuePath()));\n \n     LOG.info(\"Initializing \" + queueName + \"\\n\" +\n         \"capacity \u003d \" + queueCapacities.getCapacity() +\n         \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n         \"asboluteCapacity \u003d \" + queueCapacities.getAbsoluteCapacity() +\n         \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n         \"maxCapacity \u003d \" + queueCapacities.getMaximumCapacity() +\n         \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n         \"absoluteMaxCapacity \u003d \" + queueCapacities.getAbsoluteMaximumCapacity() +\n         \" [\u003d 1.0 maximumCapacity undefined, \" +\n         \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n         \"\\n\" +\n         \"userLimit \u003d \" + userLimit +\n         \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n         \"userLimitFactor \u003d \" + userLimitFactor +\n         \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n         \"maxApplications \u003d \" + maxApplications +\n         \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n         \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n         \"\\n\" +\n         \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n         \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n         \"userLimitFactor) ]\" + \"\\n\" +\n         \"usedCapacity \u003d \" + queueCapacities.getUsedCapacity() +\n         \" [\u003d usedResourcesMemory / \" +\n         \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n         \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n         \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n         \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n         \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n         \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n         \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n         \"maximumAllocationMemory ]\" + \"\\n\" +\n         \"maximumAllocation \u003d \" + maximumAllocation +\n         \" [\u003d configuredMaxAllocation ]\" + \"\\n\" +\n         \"numContainers \u003d \" + numContainers +\n         \" [\u003d currentNumContainers ]\" + \"\\n\" +\n         \"state \u003d \" + state +\n         \" [\u003d configuredState ]\" + \"\\n\" +\n         \"acls \u003d \" + aclsString +\n         \" [\u003d configuredAcls ]\" + \"\\n\" + \n         \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\" +\n         \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\" +\n         \"reservationsContinueLooking \u003d \" +\n         reservationsContinueLooking + \"\\n\" +\n         \"preemptionDisabled \u003d \" + getPreemptionDisabled() + \"\\n\" +\n         \"defaultAppPriorityPerQueue \u003d \" + defaultAppPriorityPerQueue);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void setupQueueConfigs(Resource clusterResource)\n      throws IOException {\n    super.setupQueueConfigs(clusterResource);\n    \n    this.lastClusterResource \u003d clusterResource;\n    \n    this.cachedResourceLimitsForHeadroom \u003d new ResourceLimits(clusterResource);\n    \n    // Initialize headroom info, also used for calculating application \n    // master resource limits.  Since this happens during queue initialization\n    // and all queues may not be realized yet, we\u0027ll use (optimistic) \n    // absoluteMaxCapacity (it will be replaced with the more accurate \n    // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n    setQueueResourceLimitsInfo(clusterResource);\n\n    CapacitySchedulerConfiguration conf \u003d csContext.getConfiguration();\n    \n    setOrderingPolicy(conf.\u003cFiCaSchedulerApp\u003egetOrderingPolicy(getQueuePath()));\n    setPendingAppsOrderingPolicy(conf\n        .\u003cFiCaSchedulerApp\u003e getOrderingPolicy(getQueuePath()));\n    setPendingAppsOrderingPolicyRecovery(conf\n        .\u003cFiCaSchedulerApp\u003e getOrderingPolicy(getQueuePath()));\n    \n    userLimit \u003d conf.getUserLimit(getQueuePath());\n    userLimitFactor \u003d conf.getUserLimitFactor(getQueuePath());\n\n    maxApplications \u003d conf.getMaximumApplicationsPerQueue(getQueuePath());\n    if (maxApplications \u003c 0) {\n      int maxSystemApps \u003d conf.getMaximumSystemApplications();\n      maxApplications \u003d\n          (int) (maxSystemApps * queueCapacities.getAbsoluteCapacity());\n    }\n    maxApplicationsPerUser \u003d \n      (int)(maxApplications * (userLimit / 100.0f) * userLimitFactor);\n    \n    maxAMResourcePerQueuePercent \u003d\n        conf.getMaximumApplicationMasterResourcePerQueuePercent(getQueuePath());\n\n    if (!SchedulerUtils.checkQueueLabelExpression(\n        this.accessibleLabels, this.defaultLabelExpression, null)) {\n      throw new IOException(\"Invalid default label expression of \"\n          + \" queue\u003d\"\n          + getQueueName()\n          + \" doesn\u0027t have permission to access all labels \"\n          + \"in default label expression. labelExpression of resource request\u003d\"\n          + (this.defaultLabelExpression \u003d\u003d null ? \"\"\n              : this.defaultLabelExpression)\n          + \". Queue labels\u003d\"\n          + (getAccessibleNodeLabels() \u003d\u003d null ? \"\" : StringUtils.join(\n              getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n    }\n    \n    nodeLocalityDelay \u003d conf.getNodeLocalityDelay();\n    rackLocalityFullReset \u003d conf.getRackLocalityFullReset();\n\n    // re-init this since max allocation could have changed\n    this.minimumAllocationFactor \u003d\n        Resources.ratio(resourceCalculator,\n            Resources.subtract(maximumAllocation, minimumAllocation),\n            maximumAllocation);\n\n    StringBuilder aclsString \u003d new StringBuilder();\n    for (Map.Entry\u003cAccessType, AccessControlList\u003e e : acls.entrySet()) {\n      aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n    }\n\n    StringBuilder labelStrBuilder \u003d new StringBuilder(); \n    if (accessibleLabels !\u003d null) {\n      for (String s : accessibleLabels) {\n        labelStrBuilder.append(s);\n        labelStrBuilder.append(\",\");\n      }\n    }\n\n    defaultAppPriorityPerQueue \u003d Priority.newInstance(conf\n        .getDefaultApplicationPriorityConfPerQueue(getQueuePath()));\n\n    LOG.info(\"Initializing \" + queueName + \"\\n\" +\n        \"capacity \u003d \" + queueCapacities.getCapacity() +\n        \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n        \"asboluteCapacity \u003d \" + queueCapacities.getAbsoluteCapacity() +\n        \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n        \"maxCapacity \u003d \" + queueCapacities.getMaximumCapacity() +\n        \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n        \"absoluteMaxCapacity \u003d \" + queueCapacities.getAbsoluteMaximumCapacity() +\n        \" [\u003d 1.0 maximumCapacity undefined, \" +\n        \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n        \"\\n\" +\n        \"userLimit \u003d \" + userLimit +\n        \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n        \"userLimitFactor \u003d \" + userLimitFactor +\n        \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n        \"maxApplications \u003d \" + maxApplications +\n        \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n        \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n        \"\\n\" +\n        \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n        \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n        \"userLimitFactor) ]\" + \"\\n\" +\n        \"usedCapacity \u003d \" + queueCapacities.getUsedCapacity() +\n        \" [\u003d usedResourcesMemory / \" +\n        \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n        \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n        \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n        \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n        \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n        \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n        \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n        \"maximumAllocationMemory ]\" + \"\\n\" +\n        \"maximumAllocation \u003d \" + maximumAllocation +\n        \" [\u003d configuredMaxAllocation ]\" + \"\\n\" +\n        \"numContainers \u003d \" + numContainers +\n        \" [\u003d currentNumContainers ]\" + \"\\n\" +\n        \"state \u003d \" + state +\n        \" [\u003d configuredState ]\" + \"\\n\" +\n        \"acls \u003d \" + aclsString +\n        \" [\u003d configuredAcls ]\" + \"\\n\" + \n        \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\" +\n        \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\" +\n        \"reservationsContinueLooking \u003d \" +\n        reservationsContinueLooking + \"\\n\" +\n        \"preemptionDisabled \u003d \" + getPreemptionDisabled() + \"\\n\" +\n        \"defaultAppPriorityPerQueue \u003d \" + defaultAppPriorityPerQueue);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "91828fef6b9314f72d1f973f00e81404dc6bba91": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4461. Redundant nodeLocalityDelay log in LeafQueue. Contributed by Eric Payne\n",
      "commitDate": "16/12/15 3:22 PM",
      "commitName": "91828fef6b9314f72d1f973f00e81404dc6bba91",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "16/12/15 1:22 PM",
      "commitNameOld": "9b856d9787be5ec88ef34574b9b98755d7b669ea",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 0.08,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,123 +1,122 @@\n   protected synchronized void setupQueueConfigs(Resource clusterResource)\n       throws IOException {\n     super.setupQueueConfigs(clusterResource);\n     \n     this.lastClusterResource \u003d clusterResource;\n     \n     this.cachedResourceLimitsForHeadroom \u003d new ResourceLimits(clusterResource);\n     \n     // Initialize headroom info, also used for calculating application \n     // master resource limits.  Since this happens during queue initialization\n     // and all queues may not be realized yet, we\u0027ll use (optimistic) \n     // absoluteMaxCapacity (it will be replaced with the more accurate \n     // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n     setQueueResourceLimitsInfo(clusterResource);\n \n     CapacitySchedulerConfiguration conf \u003d csContext.getConfiguration();\n     \n     setOrderingPolicy(conf.\u003cFiCaSchedulerApp\u003egetOrderingPolicy(getQueuePath()));\n     setPendingAppsOrderingPolicy(conf\n         .\u003cFiCaSchedulerApp\u003e getOrderingPolicy(getQueuePath()));\n     \n     userLimit \u003d conf.getUserLimit(getQueuePath());\n     userLimitFactor \u003d conf.getUserLimitFactor(getQueuePath());\n \n     maxApplications \u003d conf.getMaximumApplicationsPerQueue(getQueuePath());\n     if (maxApplications \u003c 0) {\n       int maxSystemApps \u003d conf.getMaximumSystemApplications();\n       maxApplications \u003d\n           (int) (maxSystemApps * queueCapacities.getAbsoluteCapacity());\n     }\n     maxApplicationsPerUser \u003d \n       (int)(maxApplications * (userLimit / 100.0f) * userLimitFactor);\n     \n     maxAMResourcePerQueuePercent \u003d\n         conf.getMaximumApplicationMasterResourcePerQueuePercent(getQueuePath());\n \n     if (!SchedulerUtils.checkQueueLabelExpression(\n         this.accessibleLabels, this.defaultLabelExpression, null)) {\n       throw new IOException(\"Invalid default label expression of \"\n           + \" queue\u003d\"\n           + getQueueName()\n           + \" doesn\u0027t have permission to access all labels \"\n           + \"in default label expression. labelExpression of resource request\u003d\"\n           + (this.defaultLabelExpression \u003d\u003d null ? \"\"\n               : this.defaultLabelExpression)\n           + \". Queue labels\u003d\"\n           + (getAccessibleNodeLabels() \u003d\u003d null ? \"\" : StringUtils.join(\n               getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n     }\n     \n     nodeLocalityDelay \u003d conf.getNodeLocalityDelay();\n     rackLocalityFullReset \u003d conf.getRackLocalityFullReset();\n \n     // re-init this since max allocation could have changed\n     this.minimumAllocationFactor \u003d\n         Resources.ratio(resourceCalculator,\n             Resources.subtract(maximumAllocation, minimumAllocation),\n             maximumAllocation);\n \n     StringBuilder aclsString \u003d new StringBuilder();\n     for (Map.Entry\u003cAccessType, AccessControlList\u003e e : acls.entrySet()) {\n       aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n     }\n \n     StringBuilder labelStrBuilder \u003d new StringBuilder(); \n     if (accessibleLabels !\u003d null) {\n       for (String s : accessibleLabels) {\n         labelStrBuilder.append(s);\n         labelStrBuilder.append(\",\");\n       }\n     }\n \n     defaultAppPriorityPerQueue \u003d Priority.newInstance(conf\n         .getDefaultApplicationPriorityConfPerQueue(getQueuePath()));\n \n     LOG.info(\"Initializing \" + queueName + \"\\n\" +\n         \"capacity \u003d \" + queueCapacities.getCapacity() +\n         \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n         \"asboluteCapacity \u003d \" + queueCapacities.getAbsoluteCapacity() +\n         \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n         \"maxCapacity \u003d \" + queueCapacities.getMaximumCapacity() +\n         \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n         \"absoluteMaxCapacity \u003d \" + queueCapacities.getAbsoluteMaximumCapacity() +\n         \" [\u003d 1.0 maximumCapacity undefined, \" +\n         \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n         \"\\n\" +\n         \"userLimit \u003d \" + userLimit +\n         \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n         \"userLimitFactor \u003d \" + userLimitFactor +\n         \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n         \"maxApplications \u003d \" + maxApplications +\n         \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n         \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n         \"\\n\" +\n         \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n         \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n         \"userLimitFactor) ]\" + \"\\n\" +\n         \"usedCapacity \u003d \" + queueCapacities.getUsedCapacity() +\n         \" [\u003d usedResourcesMemory / \" +\n         \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n         \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n         \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n         \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n         \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n         \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n         \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n         \"maximumAllocationMemory ]\" + \"\\n\" +\n         \"maximumAllocation \u003d \" + maximumAllocation +\n         \" [\u003d configuredMaxAllocation ]\" + \"\\n\" +\n         \"numContainers \u003d \" + numContainers +\n         \" [\u003d currentNumContainers ]\" + \"\\n\" +\n         \"state \u003d \" + state +\n         \" [\u003d configuredState ]\" + \"\\n\" +\n         \"acls \u003d \" + aclsString +\n         \" [\u003d configuredAcls ]\" + \"\\n\" + \n         \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\" +\n         \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\" +\n-        \"nodeLocalityDelay \u003d \" +  nodeLocalityDelay + \"\\n\" +\n         \"reservationsContinueLooking \u003d \" +\n         reservationsContinueLooking + \"\\n\" +\n         \"preemptionDisabled \u003d \" + getPreemptionDisabled() + \"\\n\" +\n         \"defaultAppPriorityPerQueue \u003d \" + defaultAppPriorityPerQueue);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void setupQueueConfigs(Resource clusterResource)\n      throws IOException {\n    super.setupQueueConfigs(clusterResource);\n    \n    this.lastClusterResource \u003d clusterResource;\n    \n    this.cachedResourceLimitsForHeadroom \u003d new ResourceLimits(clusterResource);\n    \n    // Initialize headroom info, also used for calculating application \n    // master resource limits.  Since this happens during queue initialization\n    // and all queues may not be realized yet, we\u0027ll use (optimistic) \n    // absoluteMaxCapacity (it will be replaced with the more accurate \n    // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n    setQueueResourceLimitsInfo(clusterResource);\n\n    CapacitySchedulerConfiguration conf \u003d csContext.getConfiguration();\n    \n    setOrderingPolicy(conf.\u003cFiCaSchedulerApp\u003egetOrderingPolicy(getQueuePath()));\n    setPendingAppsOrderingPolicy(conf\n        .\u003cFiCaSchedulerApp\u003e getOrderingPolicy(getQueuePath()));\n    \n    userLimit \u003d conf.getUserLimit(getQueuePath());\n    userLimitFactor \u003d conf.getUserLimitFactor(getQueuePath());\n\n    maxApplications \u003d conf.getMaximumApplicationsPerQueue(getQueuePath());\n    if (maxApplications \u003c 0) {\n      int maxSystemApps \u003d conf.getMaximumSystemApplications();\n      maxApplications \u003d\n          (int) (maxSystemApps * queueCapacities.getAbsoluteCapacity());\n    }\n    maxApplicationsPerUser \u003d \n      (int)(maxApplications * (userLimit / 100.0f) * userLimitFactor);\n    \n    maxAMResourcePerQueuePercent \u003d\n        conf.getMaximumApplicationMasterResourcePerQueuePercent(getQueuePath());\n\n    if (!SchedulerUtils.checkQueueLabelExpression(\n        this.accessibleLabels, this.defaultLabelExpression, null)) {\n      throw new IOException(\"Invalid default label expression of \"\n          + \" queue\u003d\"\n          + getQueueName()\n          + \" doesn\u0027t have permission to access all labels \"\n          + \"in default label expression. labelExpression of resource request\u003d\"\n          + (this.defaultLabelExpression \u003d\u003d null ? \"\"\n              : this.defaultLabelExpression)\n          + \". Queue labels\u003d\"\n          + (getAccessibleNodeLabels() \u003d\u003d null ? \"\" : StringUtils.join(\n              getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n    }\n    \n    nodeLocalityDelay \u003d conf.getNodeLocalityDelay();\n    rackLocalityFullReset \u003d conf.getRackLocalityFullReset();\n\n    // re-init this since max allocation could have changed\n    this.minimumAllocationFactor \u003d\n        Resources.ratio(resourceCalculator,\n            Resources.subtract(maximumAllocation, minimumAllocation),\n            maximumAllocation);\n\n    StringBuilder aclsString \u003d new StringBuilder();\n    for (Map.Entry\u003cAccessType, AccessControlList\u003e e : acls.entrySet()) {\n      aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n    }\n\n    StringBuilder labelStrBuilder \u003d new StringBuilder(); \n    if (accessibleLabels !\u003d null) {\n      for (String s : accessibleLabels) {\n        labelStrBuilder.append(s);\n        labelStrBuilder.append(\",\");\n      }\n    }\n\n    defaultAppPriorityPerQueue \u003d Priority.newInstance(conf\n        .getDefaultApplicationPriorityConfPerQueue(getQueuePath()));\n\n    LOG.info(\"Initializing \" + queueName + \"\\n\" +\n        \"capacity \u003d \" + queueCapacities.getCapacity() +\n        \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n        \"asboluteCapacity \u003d \" + queueCapacities.getAbsoluteCapacity() +\n        \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n        \"maxCapacity \u003d \" + queueCapacities.getMaximumCapacity() +\n        \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n        \"absoluteMaxCapacity \u003d \" + queueCapacities.getAbsoluteMaximumCapacity() +\n        \" [\u003d 1.0 maximumCapacity undefined, \" +\n        \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n        \"\\n\" +\n        \"userLimit \u003d \" + userLimit +\n        \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n        \"userLimitFactor \u003d \" + userLimitFactor +\n        \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n        \"maxApplications \u003d \" + maxApplications +\n        \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n        \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n        \"\\n\" +\n        \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n        \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n        \"userLimitFactor) ]\" + \"\\n\" +\n        \"usedCapacity \u003d \" + queueCapacities.getUsedCapacity() +\n        \" [\u003d usedResourcesMemory / \" +\n        \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n        \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n        \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n        \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n        \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n        \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n        \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n        \"maximumAllocationMemory ]\" + \"\\n\" +\n        \"maximumAllocation \u003d \" + maximumAllocation +\n        \" [\u003d configuredMaxAllocation ]\" + \"\\n\" +\n        \"numContainers \u003d \" + numContainers +\n        \" [\u003d currentNumContainers ]\" + \"\\n\" +\n        \"state \u003d \" + state +\n        \" [\u003d configuredState ]\" + \"\\n\" +\n        \"acls \u003d \" + aclsString +\n        \" [\u003d configuredAcls ]\" + \"\\n\" + \n        \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\" +\n        \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\" +\n        \"reservationsContinueLooking \u003d \" +\n        reservationsContinueLooking + \"\\n\" +\n        \"preemptionDisabled \u003d \" + getPreemptionDisabled() + \"\\n\" +\n        \"defaultAppPriorityPerQueue \u003d \" + defaultAppPriorityPerQueue);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "9b856d9787be5ec88ef34574b9b98755d7b669ea": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4416. Deadlock due to synchronised get Methods in AbstractCSQueue. (Naganarasimha G R via wangda)\n",
      "commitDate": "16/12/15 1:22 PM",
      "commitName": "9b856d9787be5ec88ef34574b9b98755d7b669ea",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "14/12/15 11:24 AM",
      "commitNameOld": "07b0fb996a32020678bd2ce482b672f0434651f0",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 2.08,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,124 +1,123 @@\n   protected synchronized void setupQueueConfigs(Resource clusterResource)\n       throws IOException {\n     super.setupQueueConfigs(clusterResource);\n     \n     this.lastClusterResource \u003d clusterResource;\n-    updateAbsoluteCapacityResource(clusterResource);\n     \n     this.cachedResourceLimitsForHeadroom \u003d new ResourceLimits(clusterResource);\n     \n     // Initialize headroom info, also used for calculating application \n     // master resource limits.  Since this happens during queue initialization\n     // and all queues may not be realized yet, we\u0027ll use (optimistic) \n     // absoluteMaxCapacity (it will be replaced with the more accurate \n     // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n     setQueueResourceLimitsInfo(clusterResource);\n \n     CapacitySchedulerConfiguration conf \u003d csContext.getConfiguration();\n     \n     setOrderingPolicy(conf.\u003cFiCaSchedulerApp\u003egetOrderingPolicy(getQueuePath()));\n     setPendingAppsOrderingPolicy(conf\n         .\u003cFiCaSchedulerApp\u003e getOrderingPolicy(getQueuePath()));\n     \n     userLimit \u003d conf.getUserLimit(getQueuePath());\n     userLimitFactor \u003d conf.getUserLimitFactor(getQueuePath());\n \n     maxApplications \u003d conf.getMaximumApplicationsPerQueue(getQueuePath());\n     if (maxApplications \u003c 0) {\n       int maxSystemApps \u003d conf.getMaximumSystemApplications();\n       maxApplications \u003d\n           (int) (maxSystemApps * queueCapacities.getAbsoluteCapacity());\n     }\n     maxApplicationsPerUser \u003d \n       (int)(maxApplications * (userLimit / 100.0f) * userLimitFactor);\n     \n     maxAMResourcePerQueuePercent \u003d\n         conf.getMaximumApplicationMasterResourcePerQueuePercent(getQueuePath());\n \n     if (!SchedulerUtils.checkQueueLabelExpression(\n         this.accessibleLabels, this.defaultLabelExpression, null)) {\n       throw new IOException(\"Invalid default label expression of \"\n           + \" queue\u003d\"\n           + getQueueName()\n           + \" doesn\u0027t have permission to access all labels \"\n           + \"in default label expression. labelExpression of resource request\u003d\"\n           + (this.defaultLabelExpression \u003d\u003d null ? \"\"\n               : this.defaultLabelExpression)\n           + \". Queue labels\u003d\"\n           + (getAccessibleNodeLabels() \u003d\u003d null ? \"\" : StringUtils.join(\n               getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n     }\n     \n     nodeLocalityDelay \u003d conf.getNodeLocalityDelay();\n     rackLocalityFullReset \u003d conf.getRackLocalityFullReset();\n \n     // re-init this since max allocation could have changed\n     this.minimumAllocationFactor \u003d\n         Resources.ratio(resourceCalculator,\n             Resources.subtract(maximumAllocation, minimumAllocation),\n             maximumAllocation);\n \n     StringBuilder aclsString \u003d new StringBuilder();\n     for (Map.Entry\u003cAccessType, AccessControlList\u003e e : acls.entrySet()) {\n       aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n     }\n \n     StringBuilder labelStrBuilder \u003d new StringBuilder(); \n     if (accessibleLabels !\u003d null) {\n       for (String s : accessibleLabels) {\n         labelStrBuilder.append(s);\n         labelStrBuilder.append(\",\");\n       }\n     }\n \n     defaultAppPriorityPerQueue \u003d Priority.newInstance(conf\n         .getDefaultApplicationPriorityConfPerQueue(getQueuePath()));\n \n     LOG.info(\"Initializing \" + queueName + \"\\n\" +\n         \"capacity \u003d \" + queueCapacities.getCapacity() +\n         \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n         \"asboluteCapacity \u003d \" + queueCapacities.getAbsoluteCapacity() +\n         \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n         \"maxCapacity \u003d \" + queueCapacities.getMaximumCapacity() +\n         \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n         \"absoluteMaxCapacity \u003d \" + queueCapacities.getAbsoluteMaximumCapacity() +\n         \" [\u003d 1.0 maximumCapacity undefined, \" +\n         \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n         \"\\n\" +\n         \"userLimit \u003d \" + userLimit +\n         \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n         \"userLimitFactor \u003d \" + userLimitFactor +\n         \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n         \"maxApplications \u003d \" + maxApplications +\n         \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n         \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n         \"\\n\" +\n         \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n         \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n         \"userLimitFactor) ]\" + \"\\n\" +\n         \"usedCapacity \u003d \" + queueCapacities.getUsedCapacity() +\n         \" [\u003d usedResourcesMemory / \" +\n         \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n         \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n         \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n         \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n         \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n         \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n         \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n         \"maximumAllocationMemory ]\" + \"\\n\" +\n         \"maximumAllocation \u003d \" + maximumAllocation +\n         \" [\u003d configuredMaxAllocation ]\" + \"\\n\" +\n         \"numContainers \u003d \" + numContainers +\n         \" [\u003d currentNumContainers ]\" + \"\\n\" +\n         \"state \u003d \" + state +\n         \" [\u003d configuredState ]\" + \"\\n\" +\n         \"acls \u003d \" + aclsString +\n         \" [\u003d configuredAcls ]\" + \"\\n\" + \n         \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\" +\n         \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\" +\n         \"nodeLocalityDelay \u003d \" +  nodeLocalityDelay + \"\\n\" +\n         \"reservationsContinueLooking \u003d \" +\n         reservationsContinueLooking + \"\\n\" +\n         \"preemptionDisabled \u003d \" + getPreemptionDisabled() + \"\\n\" +\n         \"defaultAppPriorityPerQueue \u003d \" + defaultAppPriorityPerQueue);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void setupQueueConfigs(Resource clusterResource)\n      throws IOException {\n    super.setupQueueConfigs(clusterResource);\n    \n    this.lastClusterResource \u003d clusterResource;\n    \n    this.cachedResourceLimitsForHeadroom \u003d new ResourceLimits(clusterResource);\n    \n    // Initialize headroom info, also used for calculating application \n    // master resource limits.  Since this happens during queue initialization\n    // and all queues may not be realized yet, we\u0027ll use (optimistic) \n    // absoluteMaxCapacity (it will be replaced with the more accurate \n    // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n    setQueueResourceLimitsInfo(clusterResource);\n\n    CapacitySchedulerConfiguration conf \u003d csContext.getConfiguration();\n    \n    setOrderingPolicy(conf.\u003cFiCaSchedulerApp\u003egetOrderingPolicy(getQueuePath()));\n    setPendingAppsOrderingPolicy(conf\n        .\u003cFiCaSchedulerApp\u003e getOrderingPolicy(getQueuePath()));\n    \n    userLimit \u003d conf.getUserLimit(getQueuePath());\n    userLimitFactor \u003d conf.getUserLimitFactor(getQueuePath());\n\n    maxApplications \u003d conf.getMaximumApplicationsPerQueue(getQueuePath());\n    if (maxApplications \u003c 0) {\n      int maxSystemApps \u003d conf.getMaximumSystemApplications();\n      maxApplications \u003d\n          (int) (maxSystemApps * queueCapacities.getAbsoluteCapacity());\n    }\n    maxApplicationsPerUser \u003d \n      (int)(maxApplications * (userLimit / 100.0f) * userLimitFactor);\n    \n    maxAMResourcePerQueuePercent \u003d\n        conf.getMaximumApplicationMasterResourcePerQueuePercent(getQueuePath());\n\n    if (!SchedulerUtils.checkQueueLabelExpression(\n        this.accessibleLabels, this.defaultLabelExpression, null)) {\n      throw new IOException(\"Invalid default label expression of \"\n          + \" queue\u003d\"\n          + getQueueName()\n          + \" doesn\u0027t have permission to access all labels \"\n          + \"in default label expression. labelExpression of resource request\u003d\"\n          + (this.defaultLabelExpression \u003d\u003d null ? \"\"\n              : this.defaultLabelExpression)\n          + \". Queue labels\u003d\"\n          + (getAccessibleNodeLabels() \u003d\u003d null ? \"\" : StringUtils.join(\n              getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n    }\n    \n    nodeLocalityDelay \u003d conf.getNodeLocalityDelay();\n    rackLocalityFullReset \u003d conf.getRackLocalityFullReset();\n\n    // re-init this since max allocation could have changed\n    this.minimumAllocationFactor \u003d\n        Resources.ratio(resourceCalculator,\n            Resources.subtract(maximumAllocation, minimumAllocation),\n            maximumAllocation);\n\n    StringBuilder aclsString \u003d new StringBuilder();\n    for (Map.Entry\u003cAccessType, AccessControlList\u003e e : acls.entrySet()) {\n      aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n    }\n\n    StringBuilder labelStrBuilder \u003d new StringBuilder(); \n    if (accessibleLabels !\u003d null) {\n      for (String s : accessibleLabels) {\n        labelStrBuilder.append(s);\n        labelStrBuilder.append(\",\");\n      }\n    }\n\n    defaultAppPriorityPerQueue \u003d Priority.newInstance(conf\n        .getDefaultApplicationPriorityConfPerQueue(getQueuePath()));\n\n    LOG.info(\"Initializing \" + queueName + \"\\n\" +\n        \"capacity \u003d \" + queueCapacities.getCapacity() +\n        \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n        \"asboluteCapacity \u003d \" + queueCapacities.getAbsoluteCapacity() +\n        \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n        \"maxCapacity \u003d \" + queueCapacities.getMaximumCapacity() +\n        \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n        \"absoluteMaxCapacity \u003d \" + queueCapacities.getAbsoluteMaximumCapacity() +\n        \" [\u003d 1.0 maximumCapacity undefined, \" +\n        \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n        \"\\n\" +\n        \"userLimit \u003d \" + userLimit +\n        \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n        \"userLimitFactor \u003d \" + userLimitFactor +\n        \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n        \"maxApplications \u003d \" + maxApplications +\n        \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n        \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n        \"\\n\" +\n        \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n        \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n        \"userLimitFactor) ]\" + \"\\n\" +\n        \"usedCapacity \u003d \" + queueCapacities.getUsedCapacity() +\n        \" [\u003d usedResourcesMemory / \" +\n        \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n        \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n        \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n        \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n        \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n        \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n        \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n        \"maximumAllocationMemory ]\" + \"\\n\" +\n        \"maximumAllocation \u003d \" + maximumAllocation +\n        \" [\u003d configuredMaxAllocation ]\" + \"\\n\" +\n        \"numContainers \u003d \" + numContainers +\n        \" [\u003d currentNumContainers ]\" + \"\\n\" +\n        \"state \u003d \" + state +\n        \" [\u003d configuredState ]\" + \"\\n\" +\n        \"acls \u003d \" + aclsString +\n        \" [\u003d configuredAcls ]\" + \"\\n\" + \n        \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\" +\n        \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\" +\n        \"nodeLocalityDelay \u003d \" +  nodeLocalityDelay + \"\\n\" +\n        \"reservationsContinueLooking \u003d \" +\n        reservationsContinueLooking + \"\\n\" +\n        \"preemptionDisabled \u003d \" + getPreemptionDisabled() + \"\\n\" +\n        \"defaultAppPriorityPerQueue \u003d \" + defaultAppPriorityPerQueue);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "796638d9bc86235b9f3e5d1a3a9a25bbf5c04d1c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4287. Capacity Scheduler: Rack Locality improvement (Nathan Roberts via wangda)\n",
      "commitDate": "12/11/15 11:09 AM",
      "commitName": "796638d9bc86235b9f3e5d1a3a9a25bbf5c04d1c",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "26/10/15 4:44 PM",
      "commitNameOld": "56e4f6237ae8b1852e82b186e08db3934f79a9db",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 16.81,
      "commitsBetweenForRepo": 139,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,123 +1,124 @@\n   protected synchronized void setupQueueConfigs(Resource clusterResource)\n       throws IOException {\n     super.setupQueueConfigs(clusterResource);\n     \n     this.lastClusterResource \u003d clusterResource;\n     updateAbsoluteCapacityResource(clusterResource);\n     \n     this.cachedResourceLimitsForHeadroom \u003d new ResourceLimits(clusterResource);\n     \n     // Initialize headroom info, also used for calculating application \n     // master resource limits.  Since this happens during queue initialization\n     // and all queues may not be realized yet, we\u0027ll use (optimistic) \n     // absoluteMaxCapacity (it will be replaced with the more accurate \n     // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n     setQueueResourceLimitsInfo(clusterResource);\n \n     CapacitySchedulerConfiguration conf \u003d csContext.getConfiguration();\n     \n     setOrderingPolicy(conf.\u003cFiCaSchedulerApp\u003egetOrderingPolicy(getQueuePath()));\n     setPendingAppsOrderingPolicy(conf\n         .\u003cFiCaSchedulerApp\u003e getOrderingPolicy(getQueuePath()));\n     \n     userLimit \u003d conf.getUserLimit(getQueuePath());\n     userLimitFactor \u003d conf.getUserLimitFactor(getQueuePath());\n \n     maxApplications \u003d conf.getMaximumApplicationsPerQueue(getQueuePath());\n     if (maxApplications \u003c 0) {\n       int maxSystemApps \u003d conf.getMaximumSystemApplications();\n       maxApplications \u003d\n           (int) (maxSystemApps * queueCapacities.getAbsoluteCapacity());\n     }\n     maxApplicationsPerUser \u003d \n       (int)(maxApplications * (userLimit / 100.0f) * userLimitFactor);\n     \n     maxAMResourcePerQueuePercent \u003d\n         conf.getMaximumApplicationMasterResourcePerQueuePercent(getQueuePath());\n \n     if (!SchedulerUtils.checkQueueLabelExpression(\n         this.accessibleLabels, this.defaultLabelExpression, null)) {\n       throw new IOException(\"Invalid default label expression of \"\n           + \" queue\u003d\"\n           + getQueueName()\n           + \" doesn\u0027t have permission to access all labels \"\n           + \"in default label expression. labelExpression of resource request\u003d\"\n           + (this.defaultLabelExpression \u003d\u003d null ? \"\"\n               : this.defaultLabelExpression)\n           + \". Queue labels\u003d\"\n           + (getAccessibleNodeLabels() \u003d\u003d null ? \"\" : StringUtils.join(\n               getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n     }\n     \n     nodeLocalityDelay \u003d conf.getNodeLocalityDelay();\n+    rackLocalityFullReset \u003d conf.getRackLocalityFullReset();\n \n     // re-init this since max allocation could have changed\n     this.minimumAllocationFactor \u003d\n         Resources.ratio(resourceCalculator,\n             Resources.subtract(maximumAllocation, minimumAllocation),\n             maximumAllocation);\n \n     StringBuilder aclsString \u003d new StringBuilder();\n     for (Map.Entry\u003cAccessType, AccessControlList\u003e e : acls.entrySet()) {\n       aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n     }\n \n     StringBuilder labelStrBuilder \u003d new StringBuilder(); \n     if (accessibleLabels !\u003d null) {\n       for (String s : accessibleLabels) {\n         labelStrBuilder.append(s);\n         labelStrBuilder.append(\",\");\n       }\n     }\n \n     defaultAppPriorityPerQueue \u003d Priority.newInstance(conf\n         .getDefaultApplicationPriorityConfPerQueue(getQueuePath()));\n \n     LOG.info(\"Initializing \" + queueName + \"\\n\" +\n         \"capacity \u003d \" + queueCapacities.getCapacity() +\n         \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n         \"asboluteCapacity \u003d \" + queueCapacities.getAbsoluteCapacity() +\n         \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n         \"maxCapacity \u003d \" + queueCapacities.getMaximumCapacity() +\n         \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n         \"absoluteMaxCapacity \u003d \" + queueCapacities.getAbsoluteMaximumCapacity() +\n         \" [\u003d 1.0 maximumCapacity undefined, \" +\n         \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n         \"\\n\" +\n         \"userLimit \u003d \" + userLimit +\n         \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n         \"userLimitFactor \u003d \" + userLimitFactor +\n         \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n         \"maxApplications \u003d \" + maxApplications +\n         \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n         \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n         \"\\n\" +\n         \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n         \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n         \"userLimitFactor) ]\" + \"\\n\" +\n         \"usedCapacity \u003d \" + queueCapacities.getUsedCapacity() +\n         \" [\u003d usedResourcesMemory / \" +\n         \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n         \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n         \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n         \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n         \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n         \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n         \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n         \"maximumAllocationMemory ]\" + \"\\n\" +\n         \"maximumAllocation \u003d \" + maximumAllocation +\n         \" [\u003d configuredMaxAllocation ]\" + \"\\n\" +\n         \"numContainers \u003d \" + numContainers +\n         \" [\u003d currentNumContainers ]\" + \"\\n\" +\n         \"state \u003d \" + state +\n         \" [\u003d configuredState ]\" + \"\\n\" +\n         \"acls \u003d \" + aclsString +\n         \" [\u003d configuredAcls ]\" + \"\\n\" + \n         \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\" +\n         \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\" +\n         \"nodeLocalityDelay \u003d \" +  nodeLocalityDelay + \"\\n\" +\n         \"reservationsContinueLooking \u003d \" +\n         reservationsContinueLooking + \"\\n\" +\n         \"preemptionDisabled \u003d \" + getPreemptionDisabled() + \"\\n\" +\n         \"defaultAppPriorityPerQueue \u003d \" + defaultAppPriorityPerQueue);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void setupQueueConfigs(Resource clusterResource)\n      throws IOException {\n    super.setupQueueConfigs(clusterResource);\n    \n    this.lastClusterResource \u003d clusterResource;\n    updateAbsoluteCapacityResource(clusterResource);\n    \n    this.cachedResourceLimitsForHeadroom \u003d new ResourceLimits(clusterResource);\n    \n    // Initialize headroom info, also used for calculating application \n    // master resource limits.  Since this happens during queue initialization\n    // and all queues may not be realized yet, we\u0027ll use (optimistic) \n    // absoluteMaxCapacity (it will be replaced with the more accurate \n    // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n    setQueueResourceLimitsInfo(clusterResource);\n\n    CapacitySchedulerConfiguration conf \u003d csContext.getConfiguration();\n    \n    setOrderingPolicy(conf.\u003cFiCaSchedulerApp\u003egetOrderingPolicy(getQueuePath()));\n    setPendingAppsOrderingPolicy(conf\n        .\u003cFiCaSchedulerApp\u003e getOrderingPolicy(getQueuePath()));\n    \n    userLimit \u003d conf.getUserLimit(getQueuePath());\n    userLimitFactor \u003d conf.getUserLimitFactor(getQueuePath());\n\n    maxApplications \u003d conf.getMaximumApplicationsPerQueue(getQueuePath());\n    if (maxApplications \u003c 0) {\n      int maxSystemApps \u003d conf.getMaximumSystemApplications();\n      maxApplications \u003d\n          (int) (maxSystemApps * queueCapacities.getAbsoluteCapacity());\n    }\n    maxApplicationsPerUser \u003d \n      (int)(maxApplications * (userLimit / 100.0f) * userLimitFactor);\n    \n    maxAMResourcePerQueuePercent \u003d\n        conf.getMaximumApplicationMasterResourcePerQueuePercent(getQueuePath());\n\n    if (!SchedulerUtils.checkQueueLabelExpression(\n        this.accessibleLabels, this.defaultLabelExpression, null)) {\n      throw new IOException(\"Invalid default label expression of \"\n          + \" queue\u003d\"\n          + getQueueName()\n          + \" doesn\u0027t have permission to access all labels \"\n          + \"in default label expression. labelExpression of resource request\u003d\"\n          + (this.defaultLabelExpression \u003d\u003d null ? \"\"\n              : this.defaultLabelExpression)\n          + \". Queue labels\u003d\"\n          + (getAccessibleNodeLabels() \u003d\u003d null ? \"\" : StringUtils.join(\n              getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n    }\n    \n    nodeLocalityDelay \u003d conf.getNodeLocalityDelay();\n    rackLocalityFullReset \u003d conf.getRackLocalityFullReset();\n\n    // re-init this since max allocation could have changed\n    this.minimumAllocationFactor \u003d\n        Resources.ratio(resourceCalculator,\n            Resources.subtract(maximumAllocation, minimumAllocation),\n            maximumAllocation);\n\n    StringBuilder aclsString \u003d new StringBuilder();\n    for (Map.Entry\u003cAccessType, AccessControlList\u003e e : acls.entrySet()) {\n      aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n    }\n\n    StringBuilder labelStrBuilder \u003d new StringBuilder(); \n    if (accessibleLabels !\u003d null) {\n      for (String s : accessibleLabels) {\n        labelStrBuilder.append(s);\n        labelStrBuilder.append(\",\");\n      }\n    }\n\n    defaultAppPriorityPerQueue \u003d Priority.newInstance(conf\n        .getDefaultApplicationPriorityConfPerQueue(getQueuePath()));\n\n    LOG.info(\"Initializing \" + queueName + \"\\n\" +\n        \"capacity \u003d \" + queueCapacities.getCapacity() +\n        \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n        \"asboluteCapacity \u003d \" + queueCapacities.getAbsoluteCapacity() +\n        \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n        \"maxCapacity \u003d \" + queueCapacities.getMaximumCapacity() +\n        \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n        \"absoluteMaxCapacity \u003d \" + queueCapacities.getAbsoluteMaximumCapacity() +\n        \" [\u003d 1.0 maximumCapacity undefined, \" +\n        \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n        \"\\n\" +\n        \"userLimit \u003d \" + userLimit +\n        \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n        \"userLimitFactor \u003d \" + userLimitFactor +\n        \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n        \"maxApplications \u003d \" + maxApplications +\n        \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n        \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n        \"\\n\" +\n        \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n        \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n        \"userLimitFactor) ]\" + \"\\n\" +\n        \"usedCapacity \u003d \" + queueCapacities.getUsedCapacity() +\n        \" [\u003d usedResourcesMemory / \" +\n        \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n        \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n        \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n        \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n        \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n        \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n        \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n        \"maximumAllocationMemory ]\" + \"\\n\" +\n        \"maximumAllocation \u003d \" + maximumAllocation +\n        \" [\u003d configuredMaxAllocation ]\" + \"\\n\" +\n        \"numContainers \u003d \" + numContainers +\n        \" [\u003d currentNumContainers ]\" + \"\\n\" +\n        \"state \u003d \" + state +\n        \" [\u003d configuredState ]\" + \"\\n\" +\n        \"acls \u003d \" + aclsString +\n        \" [\u003d configuredAcls ]\" + \"\\n\" + \n        \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\" +\n        \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\" +\n        \"nodeLocalityDelay \u003d \" +  nodeLocalityDelay + \"\\n\" +\n        \"reservationsContinueLooking \u003d \" +\n        reservationsContinueLooking + \"\\n\" +\n        \"preemptionDisabled \u003d \" + getPreemptionDisabled() + \"\\n\" +\n        \"defaultAppPriorityPerQueue \u003d \" + defaultAppPriorityPerQueue);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "cf9d3c925608e8bc650d43975382ed3014081057": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3873. PendingApplications in LeafQueue should also use OrderingPolicy. (Sunil G via wangda)\n",
      "commitDate": "10/08/15 2:54 PM",
      "commitName": "cf9d3c925608e8bc650d43975382ed3014081057",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "07/08/15 9:46 AM",
      "commitNameOld": "4bc42d76e7fa53cb268cab0f9fe1fd8d8dbb17fd",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 3.21,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,121 +1,123 @@\n   protected synchronized void setupQueueConfigs(Resource clusterResource)\n       throws IOException {\n     super.setupQueueConfigs(clusterResource);\n     \n     this.lastClusterResource \u003d clusterResource;\n     updateAbsoluteCapacityResource(clusterResource);\n     \n     this.cachedResourceLimitsForHeadroom \u003d new ResourceLimits(clusterResource);\n     \n     // Initialize headroom info, also used for calculating application \n     // master resource limits.  Since this happens during queue initialization\n     // and all queues may not be realized yet, we\u0027ll use (optimistic) \n     // absoluteMaxCapacity (it will be replaced with the more accurate \n     // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n     setQueueResourceLimitsInfo(clusterResource);\n \n     CapacitySchedulerConfiguration conf \u003d csContext.getConfiguration();\n     \n     setOrderingPolicy(conf.\u003cFiCaSchedulerApp\u003egetOrderingPolicy(getQueuePath()));\n+    setPendingAppsOrderingPolicy(conf\n+        .\u003cFiCaSchedulerApp\u003e getOrderingPolicy(getQueuePath()));\n     \n     userLimit \u003d conf.getUserLimit(getQueuePath());\n     userLimitFactor \u003d conf.getUserLimitFactor(getQueuePath());\n \n     maxApplications \u003d conf.getMaximumApplicationsPerQueue(getQueuePath());\n     if (maxApplications \u003c 0) {\n       int maxSystemApps \u003d conf.getMaximumSystemApplications();\n       maxApplications \u003d\n           (int) (maxSystemApps * queueCapacities.getAbsoluteCapacity());\n     }\n     maxApplicationsPerUser \u003d \n       (int)(maxApplications * (userLimit / 100.0f) * userLimitFactor);\n     \n     maxAMResourcePerQueuePercent \u003d\n         conf.getMaximumApplicationMasterResourcePerQueuePercent(getQueuePath());\n \n     if (!SchedulerUtils.checkQueueLabelExpression(\n         this.accessibleLabels, this.defaultLabelExpression, null)) {\n       throw new IOException(\"Invalid default label expression of \"\n           + \" queue\u003d\"\n           + getQueueName()\n           + \" doesn\u0027t have permission to access all labels \"\n           + \"in default label expression. labelExpression of resource request\u003d\"\n           + (this.defaultLabelExpression \u003d\u003d null ? \"\"\n               : this.defaultLabelExpression)\n           + \". Queue labels\u003d\"\n           + (getAccessibleNodeLabels() \u003d\u003d null ? \"\" : StringUtils.join(\n               getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n     }\n     \n     nodeLocalityDelay \u003d conf.getNodeLocalityDelay();\n \n     // re-init this since max allocation could have changed\n     this.minimumAllocationFactor \u003d\n         Resources.ratio(resourceCalculator,\n             Resources.subtract(maximumAllocation, minimumAllocation),\n             maximumAllocation);\n \n     StringBuilder aclsString \u003d new StringBuilder();\n     for (Map.Entry\u003cAccessType, AccessControlList\u003e e : acls.entrySet()) {\n       aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n     }\n \n     StringBuilder labelStrBuilder \u003d new StringBuilder(); \n     if (accessibleLabels !\u003d null) {\n       for (String s : accessibleLabels) {\n         labelStrBuilder.append(s);\n         labelStrBuilder.append(\",\");\n       }\n     }\n \n     defaultAppPriorityPerQueue \u003d Priority.newInstance(conf\n         .getDefaultApplicationPriorityConfPerQueue(getQueuePath()));\n \n     LOG.info(\"Initializing \" + queueName + \"\\n\" +\n         \"capacity \u003d \" + queueCapacities.getCapacity() +\n         \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n         \"asboluteCapacity \u003d \" + queueCapacities.getAbsoluteCapacity() +\n         \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n         \"maxCapacity \u003d \" + queueCapacities.getMaximumCapacity() +\n         \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n         \"absoluteMaxCapacity \u003d \" + queueCapacities.getAbsoluteMaximumCapacity() +\n         \" [\u003d 1.0 maximumCapacity undefined, \" +\n         \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n         \"\\n\" +\n         \"userLimit \u003d \" + userLimit +\n         \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n         \"userLimitFactor \u003d \" + userLimitFactor +\n         \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n         \"maxApplications \u003d \" + maxApplications +\n         \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n         \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n         \"\\n\" +\n         \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n         \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n         \"userLimitFactor) ]\" + \"\\n\" +\n         \"usedCapacity \u003d \" + queueCapacities.getUsedCapacity() +\n         \" [\u003d usedResourcesMemory / \" +\n         \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n         \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n         \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n         \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n         \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n         \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n         \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n         \"maximumAllocationMemory ]\" + \"\\n\" +\n         \"maximumAllocation \u003d \" + maximumAllocation +\n         \" [\u003d configuredMaxAllocation ]\" + \"\\n\" +\n         \"numContainers \u003d \" + numContainers +\n         \" [\u003d currentNumContainers ]\" + \"\\n\" +\n         \"state \u003d \" + state +\n         \" [\u003d configuredState ]\" + \"\\n\" +\n         \"acls \u003d \" + aclsString +\n         \" [\u003d configuredAcls ]\" + \"\\n\" + \n         \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\" +\n         \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\" +\n         \"nodeLocalityDelay \u003d \" +  nodeLocalityDelay + \"\\n\" +\n         \"reservationsContinueLooking \u003d \" +\n         reservationsContinueLooking + \"\\n\" +\n         \"preemptionDisabled \u003d \" + getPreemptionDisabled() + \"\\n\" +\n         \"defaultAppPriorityPerQueue \u003d \" + defaultAppPriorityPerQueue);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void setupQueueConfigs(Resource clusterResource)\n      throws IOException {\n    super.setupQueueConfigs(clusterResource);\n    \n    this.lastClusterResource \u003d clusterResource;\n    updateAbsoluteCapacityResource(clusterResource);\n    \n    this.cachedResourceLimitsForHeadroom \u003d new ResourceLimits(clusterResource);\n    \n    // Initialize headroom info, also used for calculating application \n    // master resource limits.  Since this happens during queue initialization\n    // and all queues may not be realized yet, we\u0027ll use (optimistic) \n    // absoluteMaxCapacity (it will be replaced with the more accurate \n    // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n    setQueueResourceLimitsInfo(clusterResource);\n\n    CapacitySchedulerConfiguration conf \u003d csContext.getConfiguration();\n    \n    setOrderingPolicy(conf.\u003cFiCaSchedulerApp\u003egetOrderingPolicy(getQueuePath()));\n    setPendingAppsOrderingPolicy(conf\n        .\u003cFiCaSchedulerApp\u003e getOrderingPolicy(getQueuePath()));\n    \n    userLimit \u003d conf.getUserLimit(getQueuePath());\n    userLimitFactor \u003d conf.getUserLimitFactor(getQueuePath());\n\n    maxApplications \u003d conf.getMaximumApplicationsPerQueue(getQueuePath());\n    if (maxApplications \u003c 0) {\n      int maxSystemApps \u003d conf.getMaximumSystemApplications();\n      maxApplications \u003d\n          (int) (maxSystemApps * queueCapacities.getAbsoluteCapacity());\n    }\n    maxApplicationsPerUser \u003d \n      (int)(maxApplications * (userLimit / 100.0f) * userLimitFactor);\n    \n    maxAMResourcePerQueuePercent \u003d\n        conf.getMaximumApplicationMasterResourcePerQueuePercent(getQueuePath());\n\n    if (!SchedulerUtils.checkQueueLabelExpression(\n        this.accessibleLabels, this.defaultLabelExpression, null)) {\n      throw new IOException(\"Invalid default label expression of \"\n          + \" queue\u003d\"\n          + getQueueName()\n          + \" doesn\u0027t have permission to access all labels \"\n          + \"in default label expression. labelExpression of resource request\u003d\"\n          + (this.defaultLabelExpression \u003d\u003d null ? \"\"\n              : this.defaultLabelExpression)\n          + \". Queue labels\u003d\"\n          + (getAccessibleNodeLabels() \u003d\u003d null ? \"\" : StringUtils.join(\n              getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n    }\n    \n    nodeLocalityDelay \u003d conf.getNodeLocalityDelay();\n\n    // re-init this since max allocation could have changed\n    this.minimumAllocationFactor \u003d\n        Resources.ratio(resourceCalculator,\n            Resources.subtract(maximumAllocation, minimumAllocation),\n            maximumAllocation);\n\n    StringBuilder aclsString \u003d new StringBuilder();\n    for (Map.Entry\u003cAccessType, AccessControlList\u003e e : acls.entrySet()) {\n      aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n    }\n\n    StringBuilder labelStrBuilder \u003d new StringBuilder(); \n    if (accessibleLabels !\u003d null) {\n      for (String s : accessibleLabels) {\n        labelStrBuilder.append(s);\n        labelStrBuilder.append(\",\");\n      }\n    }\n\n    defaultAppPriorityPerQueue \u003d Priority.newInstance(conf\n        .getDefaultApplicationPriorityConfPerQueue(getQueuePath()));\n\n    LOG.info(\"Initializing \" + queueName + \"\\n\" +\n        \"capacity \u003d \" + queueCapacities.getCapacity() +\n        \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n        \"asboluteCapacity \u003d \" + queueCapacities.getAbsoluteCapacity() +\n        \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n        \"maxCapacity \u003d \" + queueCapacities.getMaximumCapacity() +\n        \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n        \"absoluteMaxCapacity \u003d \" + queueCapacities.getAbsoluteMaximumCapacity() +\n        \" [\u003d 1.0 maximumCapacity undefined, \" +\n        \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n        \"\\n\" +\n        \"userLimit \u003d \" + userLimit +\n        \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n        \"userLimitFactor \u003d \" + userLimitFactor +\n        \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n        \"maxApplications \u003d \" + maxApplications +\n        \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n        \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n        \"\\n\" +\n        \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n        \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n        \"userLimitFactor) ]\" + \"\\n\" +\n        \"usedCapacity \u003d \" + queueCapacities.getUsedCapacity() +\n        \" [\u003d usedResourcesMemory / \" +\n        \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n        \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n        \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n        \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n        \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n        \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n        \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n        \"maximumAllocationMemory ]\" + \"\\n\" +\n        \"maximumAllocation \u003d \" + maximumAllocation +\n        \" [\u003d configuredMaxAllocation ]\" + \"\\n\" +\n        \"numContainers \u003d \" + numContainers +\n        \" [\u003d currentNumContainers ]\" + \"\\n\" +\n        \"state \u003d \" + state +\n        \" [\u003d configuredState ]\" + \"\\n\" +\n        \"acls \u003d \" + aclsString +\n        \" [\u003d configuredAcls ]\" + \"\\n\" + \n        \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\" +\n        \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\" +\n        \"nodeLocalityDelay \u003d \" +  nodeLocalityDelay + \"\\n\" +\n        \"reservationsContinueLooking \u003d \" +\n        reservationsContinueLooking + \"\\n\" +\n        \"preemptionDisabled \u003d \" + getPreemptionDisabled() + \"\\n\" +\n        \"defaultAppPriorityPerQueue \u003d \" + defaultAppPriorityPerQueue);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "c39ca541f498712133890961598bbff50d89d68b": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2003. Support for Application priority : Changes in RM and Capacity Scheduler. (Sunil G via wangda)\n",
      "commitDate": "21/07/15 9:57 AM",
      "commitName": "c39ca541f498712133890961598bbff50d89d68b",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "10/07/15 6:58 PM",
      "commitNameOld": "1ea36299a47af302379ae0750b571ec021eb54ad",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 10.62,
      "commitsBetweenForRepo": 51,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,117 +1,121 @@\n   protected synchronized void setupQueueConfigs(Resource clusterResource)\n       throws IOException {\n     super.setupQueueConfigs(clusterResource);\n     \n     this.lastClusterResource \u003d clusterResource;\n     updateAbsoluteCapacityResource(clusterResource);\n     \n     this.cachedResourceLimitsForHeadroom \u003d new ResourceLimits(clusterResource);\n     \n     // Initialize headroom info, also used for calculating application \n     // master resource limits.  Since this happens during queue initialization\n     // and all queues may not be realized yet, we\u0027ll use (optimistic) \n     // absoluteMaxCapacity (it will be replaced with the more accurate \n     // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n     setQueueResourceLimitsInfo(clusterResource);\n \n     CapacitySchedulerConfiguration conf \u003d csContext.getConfiguration();\n     \n     setOrderingPolicy(conf.\u003cFiCaSchedulerApp\u003egetOrderingPolicy(getQueuePath()));\n     \n     userLimit \u003d conf.getUserLimit(getQueuePath());\n     userLimitFactor \u003d conf.getUserLimitFactor(getQueuePath());\n \n     maxApplications \u003d conf.getMaximumApplicationsPerQueue(getQueuePath());\n     if (maxApplications \u003c 0) {\n       int maxSystemApps \u003d conf.getMaximumSystemApplications();\n       maxApplications \u003d\n           (int) (maxSystemApps * queueCapacities.getAbsoluteCapacity());\n     }\n     maxApplicationsPerUser \u003d \n       (int)(maxApplications * (userLimit / 100.0f) * userLimitFactor);\n     \n     maxAMResourcePerQueuePercent \u003d\n         conf.getMaximumApplicationMasterResourcePerQueuePercent(getQueuePath());\n \n     if (!SchedulerUtils.checkQueueLabelExpression(\n         this.accessibleLabels, this.defaultLabelExpression, null)) {\n       throw new IOException(\"Invalid default label expression of \"\n           + \" queue\u003d\"\n           + getQueueName()\n           + \" doesn\u0027t have permission to access all labels \"\n           + \"in default label expression. labelExpression of resource request\u003d\"\n           + (this.defaultLabelExpression \u003d\u003d null ? \"\"\n               : this.defaultLabelExpression)\n           + \". Queue labels\u003d\"\n           + (getAccessibleNodeLabels() \u003d\u003d null ? \"\" : StringUtils.join(\n               getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n     }\n     \n     nodeLocalityDelay \u003d conf.getNodeLocalityDelay();\n \n     // re-init this since max allocation could have changed\n     this.minimumAllocationFactor \u003d\n         Resources.ratio(resourceCalculator,\n             Resources.subtract(maximumAllocation, minimumAllocation),\n             maximumAllocation);\n \n     StringBuilder aclsString \u003d new StringBuilder();\n     for (Map.Entry\u003cAccessType, AccessControlList\u003e e : acls.entrySet()) {\n       aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n     }\n \n     StringBuilder labelStrBuilder \u003d new StringBuilder(); \n     if (accessibleLabels !\u003d null) {\n       for (String s : accessibleLabels) {\n         labelStrBuilder.append(s);\n         labelStrBuilder.append(\",\");\n       }\n     }\n \n+    defaultAppPriorityPerQueue \u003d Priority.newInstance(conf\n+        .getDefaultApplicationPriorityConfPerQueue(getQueuePath()));\n+\n     LOG.info(\"Initializing \" + queueName + \"\\n\" +\n         \"capacity \u003d \" + queueCapacities.getCapacity() +\n         \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n         \"asboluteCapacity \u003d \" + queueCapacities.getAbsoluteCapacity() +\n         \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n         \"maxCapacity \u003d \" + queueCapacities.getMaximumCapacity() +\n         \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n         \"absoluteMaxCapacity \u003d \" + queueCapacities.getAbsoluteMaximumCapacity() +\n         \" [\u003d 1.0 maximumCapacity undefined, \" +\n         \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n         \"\\n\" +\n         \"userLimit \u003d \" + userLimit +\n         \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n         \"userLimitFactor \u003d \" + userLimitFactor +\n         \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n         \"maxApplications \u003d \" + maxApplications +\n         \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n         \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n         \"\\n\" +\n         \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n         \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n         \"userLimitFactor) ]\" + \"\\n\" +\n         \"usedCapacity \u003d \" + queueCapacities.getUsedCapacity() +\n         \" [\u003d usedResourcesMemory / \" +\n         \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n         \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n         \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n         \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n         \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n         \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n         \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n         \"maximumAllocationMemory ]\" + \"\\n\" +\n         \"maximumAllocation \u003d \" + maximumAllocation +\n         \" [\u003d configuredMaxAllocation ]\" + \"\\n\" +\n         \"numContainers \u003d \" + numContainers +\n         \" [\u003d currentNumContainers ]\" + \"\\n\" +\n         \"state \u003d \" + state +\n         \" [\u003d configuredState ]\" + \"\\n\" +\n         \"acls \u003d \" + aclsString +\n         \" [\u003d configuredAcls ]\" + \"\\n\" + \n         \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\" +\n         \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\" +\n         \"nodeLocalityDelay \u003d \" +  nodeLocalityDelay + \"\\n\" +\n         \"reservationsContinueLooking \u003d \" +\n         reservationsContinueLooking + \"\\n\" +\n-        \"preemptionDisabled \u003d \" + getPreemptionDisabled() + \"\\n\");\n+        \"preemptionDisabled \u003d \" + getPreemptionDisabled() + \"\\n\" +\n+        \"defaultAppPriorityPerQueue \u003d \" + defaultAppPriorityPerQueue);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void setupQueueConfigs(Resource clusterResource)\n      throws IOException {\n    super.setupQueueConfigs(clusterResource);\n    \n    this.lastClusterResource \u003d clusterResource;\n    updateAbsoluteCapacityResource(clusterResource);\n    \n    this.cachedResourceLimitsForHeadroom \u003d new ResourceLimits(clusterResource);\n    \n    // Initialize headroom info, also used for calculating application \n    // master resource limits.  Since this happens during queue initialization\n    // and all queues may not be realized yet, we\u0027ll use (optimistic) \n    // absoluteMaxCapacity (it will be replaced with the more accurate \n    // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n    setQueueResourceLimitsInfo(clusterResource);\n\n    CapacitySchedulerConfiguration conf \u003d csContext.getConfiguration();\n    \n    setOrderingPolicy(conf.\u003cFiCaSchedulerApp\u003egetOrderingPolicy(getQueuePath()));\n    \n    userLimit \u003d conf.getUserLimit(getQueuePath());\n    userLimitFactor \u003d conf.getUserLimitFactor(getQueuePath());\n\n    maxApplications \u003d conf.getMaximumApplicationsPerQueue(getQueuePath());\n    if (maxApplications \u003c 0) {\n      int maxSystemApps \u003d conf.getMaximumSystemApplications();\n      maxApplications \u003d\n          (int) (maxSystemApps * queueCapacities.getAbsoluteCapacity());\n    }\n    maxApplicationsPerUser \u003d \n      (int)(maxApplications * (userLimit / 100.0f) * userLimitFactor);\n    \n    maxAMResourcePerQueuePercent \u003d\n        conf.getMaximumApplicationMasterResourcePerQueuePercent(getQueuePath());\n\n    if (!SchedulerUtils.checkQueueLabelExpression(\n        this.accessibleLabels, this.defaultLabelExpression, null)) {\n      throw new IOException(\"Invalid default label expression of \"\n          + \" queue\u003d\"\n          + getQueueName()\n          + \" doesn\u0027t have permission to access all labels \"\n          + \"in default label expression. labelExpression of resource request\u003d\"\n          + (this.defaultLabelExpression \u003d\u003d null ? \"\"\n              : this.defaultLabelExpression)\n          + \". Queue labels\u003d\"\n          + (getAccessibleNodeLabels() \u003d\u003d null ? \"\" : StringUtils.join(\n              getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n    }\n    \n    nodeLocalityDelay \u003d conf.getNodeLocalityDelay();\n\n    // re-init this since max allocation could have changed\n    this.minimumAllocationFactor \u003d\n        Resources.ratio(resourceCalculator,\n            Resources.subtract(maximumAllocation, minimumAllocation),\n            maximumAllocation);\n\n    StringBuilder aclsString \u003d new StringBuilder();\n    for (Map.Entry\u003cAccessType, AccessControlList\u003e e : acls.entrySet()) {\n      aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n    }\n\n    StringBuilder labelStrBuilder \u003d new StringBuilder(); \n    if (accessibleLabels !\u003d null) {\n      for (String s : accessibleLabels) {\n        labelStrBuilder.append(s);\n        labelStrBuilder.append(\",\");\n      }\n    }\n\n    defaultAppPriorityPerQueue \u003d Priority.newInstance(conf\n        .getDefaultApplicationPriorityConfPerQueue(getQueuePath()));\n\n    LOG.info(\"Initializing \" + queueName + \"\\n\" +\n        \"capacity \u003d \" + queueCapacities.getCapacity() +\n        \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n        \"asboluteCapacity \u003d \" + queueCapacities.getAbsoluteCapacity() +\n        \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n        \"maxCapacity \u003d \" + queueCapacities.getMaximumCapacity() +\n        \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n        \"absoluteMaxCapacity \u003d \" + queueCapacities.getAbsoluteMaximumCapacity() +\n        \" [\u003d 1.0 maximumCapacity undefined, \" +\n        \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n        \"\\n\" +\n        \"userLimit \u003d \" + userLimit +\n        \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n        \"userLimitFactor \u003d \" + userLimitFactor +\n        \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n        \"maxApplications \u003d \" + maxApplications +\n        \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n        \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n        \"\\n\" +\n        \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n        \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n        \"userLimitFactor) ]\" + \"\\n\" +\n        \"usedCapacity \u003d \" + queueCapacities.getUsedCapacity() +\n        \" [\u003d usedResourcesMemory / \" +\n        \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n        \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n        \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n        \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n        \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n        \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n        \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n        \"maximumAllocationMemory ]\" + \"\\n\" +\n        \"maximumAllocation \u003d \" + maximumAllocation +\n        \" [\u003d configuredMaxAllocation ]\" + \"\\n\" +\n        \"numContainers \u003d \" + numContainers +\n        \" [\u003d currentNumContainers ]\" + \"\\n\" +\n        \"state \u003d \" + state +\n        \" [\u003d configuredState ]\" + \"\\n\" +\n        \"acls \u003d \" + aclsString +\n        \" [\u003d configuredAcls ]\" + \"\\n\" + \n        \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\" +\n        \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\" +\n        \"nodeLocalityDelay \u003d \" +  nodeLocalityDelay + \"\\n\" +\n        \"reservationsContinueLooking \u003d \" +\n        reservationsContinueLooking + \"\\n\" +\n        \"preemptionDisabled \u003d \" + getPreemptionDisabled() + \"\\n\" +\n        \"defaultAppPriorityPerQueue \u003d \" + defaultAppPriorityPerQueue);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "f489a4ec969f3727d03c8e85d51af1018fc0b2a1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2918. RM should not fail on startup if queue\u0027s configured labels do not exist in cluster-node-labels. Contributed by Wangda Tan\n",
      "commitDate": "07/05/15 5:35 PM",
      "commitName": "f489a4ec969f3727d03c8e85d51af1018fc0b2a1",
      "commitAuthor": "Jian He",
      "commitDateOld": "24/04/15 5:03 PM",
      "commitNameOld": "d497f6ea2be559aa31ed76f37ae949dbfabe2a51",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 13.02,
      "commitsBetweenForRepo": 117,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,117 +1,117 @@\n   protected synchronized void setupQueueConfigs(Resource clusterResource)\n       throws IOException {\n     super.setupQueueConfigs(clusterResource);\n     \n     this.lastClusterResource \u003d clusterResource;\n     updateAbsoluteCapacityResource(clusterResource);\n     \n     this.cachedResourceLimitsForHeadroom \u003d new ResourceLimits(clusterResource);\n     \n     // Initialize headroom info, also used for calculating application \n     // master resource limits.  Since this happens during queue initialization\n     // and all queues may not be realized yet, we\u0027ll use (optimistic) \n     // absoluteMaxCapacity (it will be replaced with the more accurate \n     // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n     setQueueResourceLimitsInfo(clusterResource);\n \n     CapacitySchedulerConfiguration conf \u003d csContext.getConfiguration();\n     \n     setOrderingPolicy(conf.\u003cFiCaSchedulerApp\u003egetOrderingPolicy(getQueuePath()));\n     \n     userLimit \u003d conf.getUserLimit(getQueuePath());\n     userLimitFactor \u003d conf.getUserLimitFactor(getQueuePath());\n \n     maxApplications \u003d conf.getMaximumApplicationsPerQueue(getQueuePath());\n     if (maxApplications \u003c 0) {\n       int maxSystemApps \u003d conf.getMaximumSystemApplications();\n       maxApplications \u003d\n           (int) (maxSystemApps * queueCapacities.getAbsoluteCapacity());\n     }\n     maxApplicationsPerUser \u003d \n       (int)(maxApplications * (userLimit / 100.0f) * userLimitFactor);\n     \n     maxAMResourcePerQueuePercent \u003d\n         conf.getMaximumApplicationMasterResourcePerQueuePercent(getQueuePath());\n \n-    if (!SchedulerUtils.checkQueueLabelExpression(this.accessibleLabels,\n-        this.defaultLabelExpression)) {\n+    if (!SchedulerUtils.checkQueueLabelExpression(\n+        this.accessibleLabels, this.defaultLabelExpression, null)) {\n       throw new IOException(\"Invalid default label expression of \"\n           + \" queue\u003d\"\n           + getQueueName()\n           + \" doesn\u0027t have permission to access all labels \"\n           + \"in default label expression. labelExpression of resource request\u003d\"\n           + (this.defaultLabelExpression \u003d\u003d null ? \"\"\n               : this.defaultLabelExpression)\n           + \". Queue labels\u003d\"\n           + (getAccessibleNodeLabels() \u003d\u003d null ? \"\" : StringUtils.join(\n               getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n     }\n     \n     nodeLocalityDelay \u003d conf.getNodeLocalityDelay();\n \n     // re-init this since max allocation could have changed\n     this.minimumAllocationFactor \u003d\n         Resources.ratio(resourceCalculator,\n             Resources.subtract(maximumAllocation, minimumAllocation),\n             maximumAllocation);\n \n     StringBuilder aclsString \u003d new StringBuilder();\n     for (Map.Entry\u003cAccessType, AccessControlList\u003e e : acls.entrySet()) {\n       aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n     }\n \n     StringBuilder labelStrBuilder \u003d new StringBuilder(); \n     if (accessibleLabels !\u003d null) {\n       for (String s : accessibleLabels) {\n         labelStrBuilder.append(s);\n         labelStrBuilder.append(\",\");\n       }\n     }\n \n     LOG.info(\"Initializing \" + queueName + \"\\n\" +\n         \"capacity \u003d \" + queueCapacities.getCapacity() +\n         \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n         \"asboluteCapacity \u003d \" + queueCapacities.getAbsoluteCapacity() +\n         \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n         \"maxCapacity \u003d \" + queueCapacities.getMaximumCapacity() +\n         \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n         \"absoluteMaxCapacity \u003d \" + queueCapacities.getAbsoluteMaximumCapacity() +\n         \" [\u003d 1.0 maximumCapacity undefined, \" +\n         \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n         \"\\n\" +\n         \"userLimit \u003d \" + userLimit +\n         \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n         \"userLimitFactor \u003d \" + userLimitFactor +\n         \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n         \"maxApplications \u003d \" + maxApplications +\n         \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n         \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n         \"\\n\" +\n         \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n         \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n         \"userLimitFactor) ]\" + \"\\n\" +\n         \"usedCapacity \u003d \" + queueCapacities.getUsedCapacity() +\n         \" [\u003d usedResourcesMemory / \" +\n         \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n         \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n         \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n         \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n         \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n         \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n         \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n         \"maximumAllocationMemory ]\" + \"\\n\" +\n         \"maximumAllocation \u003d \" + maximumAllocation +\n         \" [\u003d configuredMaxAllocation ]\" + \"\\n\" +\n         \"numContainers \u003d \" + numContainers +\n         \" [\u003d currentNumContainers ]\" + \"\\n\" +\n         \"state \u003d \" + state +\n         \" [\u003d configuredState ]\" + \"\\n\" +\n         \"acls \u003d \" + aclsString +\n         \" [\u003d configuredAcls ]\" + \"\\n\" + \n         \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\" +\n         \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\" +\n         \"nodeLocalityDelay \u003d \" +  nodeLocalityDelay + \"\\n\" +\n         \"reservationsContinueLooking \u003d \" +\n         reservationsContinueLooking + \"\\n\" +\n         \"preemptionDisabled \u003d \" + getPreemptionDisabled() + \"\\n\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void setupQueueConfigs(Resource clusterResource)\n      throws IOException {\n    super.setupQueueConfigs(clusterResource);\n    \n    this.lastClusterResource \u003d clusterResource;\n    updateAbsoluteCapacityResource(clusterResource);\n    \n    this.cachedResourceLimitsForHeadroom \u003d new ResourceLimits(clusterResource);\n    \n    // Initialize headroom info, also used for calculating application \n    // master resource limits.  Since this happens during queue initialization\n    // and all queues may not be realized yet, we\u0027ll use (optimistic) \n    // absoluteMaxCapacity (it will be replaced with the more accurate \n    // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n    setQueueResourceLimitsInfo(clusterResource);\n\n    CapacitySchedulerConfiguration conf \u003d csContext.getConfiguration();\n    \n    setOrderingPolicy(conf.\u003cFiCaSchedulerApp\u003egetOrderingPolicy(getQueuePath()));\n    \n    userLimit \u003d conf.getUserLimit(getQueuePath());\n    userLimitFactor \u003d conf.getUserLimitFactor(getQueuePath());\n\n    maxApplications \u003d conf.getMaximumApplicationsPerQueue(getQueuePath());\n    if (maxApplications \u003c 0) {\n      int maxSystemApps \u003d conf.getMaximumSystemApplications();\n      maxApplications \u003d\n          (int) (maxSystemApps * queueCapacities.getAbsoluteCapacity());\n    }\n    maxApplicationsPerUser \u003d \n      (int)(maxApplications * (userLimit / 100.0f) * userLimitFactor);\n    \n    maxAMResourcePerQueuePercent \u003d\n        conf.getMaximumApplicationMasterResourcePerQueuePercent(getQueuePath());\n\n    if (!SchedulerUtils.checkQueueLabelExpression(\n        this.accessibleLabels, this.defaultLabelExpression, null)) {\n      throw new IOException(\"Invalid default label expression of \"\n          + \" queue\u003d\"\n          + getQueueName()\n          + \" doesn\u0027t have permission to access all labels \"\n          + \"in default label expression. labelExpression of resource request\u003d\"\n          + (this.defaultLabelExpression \u003d\u003d null ? \"\"\n              : this.defaultLabelExpression)\n          + \". Queue labels\u003d\"\n          + (getAccessibleNodeLabels() \u003d\u003d null ? \"\" : StringUtils.join(\n              getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n    }\n    \n    nodeLocalityDelay \u003d conf.getNodeLocalityDelay();\n\n    // re-init this since max allocation could have changed\n    this.minimumAllocationFactor \u003d\n        Resources.ratio(resourceCalculator,\n            Resources.subtract(maximumAllocation, minimumAllocation),\n            maximumAllocation);\n\n    StringBuilder aclsString \u003d new StringBuilder();\n    for (Map.Entry\u003cAccessType, AccessControlList\u003e e : acls.entrySet()) {\n      aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n    }\n\n    StringBuilder labelStrBuilder \u003d new StringBuilder(); \n    if (accessibleLabels !\u003d null) {\n      for (String s : accessibleLabels) {\n        labelStrBuilder.append(s);\n        labelStrBuilder.append(\",\");\n      }\n    }\n\n    LOG.info(\"Initializing \" + queueName + \"\\n\" +\n        \"capacity \u003d \" + queueCapacities.getCapacity() +\n        \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n        \"asboluteCapacity \u003d \" + queueCapacities.getAbsoluteCapacity() +\n        \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n        \"maxCapacity \u003d \" + queueCapacities.getMaximumCapacity() +\n        \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n        \"absoluteMaxCapacity \u003d \" + queueCapacities.getAbsoluteMaximumCapacity() +\n        \" [\u003d 1.0 maximumCapacity undefined, \" +\n        \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n        \"\\n\" +\n        \"userLimit \u003d \" + userLimit +\n        \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n        \"userLimitFactor \u003d \" + userLimitFactor +\n        \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n        \"maxApplications \u003d \" + maxApplications +\n        \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n        \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n        \"\\n\" +\n        \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n        \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n        \"userLimitFactor) ]\" + \"\\n\" +\n        \"usedCapacity \u003d \" + queueCapacities.getUsedCapacity() +\n        \" [\u003d usedResourcesMemory / \" +\n        \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n        \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n        \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n        \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n        \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n        \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n        \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n        \"maximumAllocationMemory ]\" + \"\\n\" +\n        \"maximumAllocation \u003d \" + maximumAllocation +\n        \" [\u003d configuredMaxAllocation ]\" + \"\\n\" +\n        \"numContainers \u003d \" + numContainers +\n        \" [\u003d currentNumContainers ]\" + \"\\n\" +\n        \"state \u003d \" + state +\n        \" [\u003d configuredState ]\" + \"\\n\" +\n        \"acls \u003d \" + aclsString +\n        \" [\u003d configuredAcls ]\" + \"\\n\" + \n        \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\" +\n        \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\" +\n        \"nodeLocalityDelay \u003d \" +  nodeLocalityDelay + \"\\n\" +\n        \"reservationsContinueLooking \u003d \" +\n        reservationsContinueLooking + \"\\n\" +\n        \"preemptionDisabled \u003d \" + getPreemptionDisabled() + \"\\n\");\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "189a63a719c63b67a1783a280bfc2f72dcb55277": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3434. Interaction between reservations and userlimit can result in significant ULF violation\n",
      "commitDate": "23/04/15 7:39 AM",
      "commitName": "189a63a719c63b67a1783a280bfc2f72dcb55277",
      "commitAuthor": "tgraves",
      "commitDateOld": "21/04/15 8:06 PM",
      "commitNameOld": "bdd90110e6904b59746812d9a093924a65e72280",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 1.48,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,117 +1,117 @@\n   protected synchronized void setupQueueConfigs(Resource clusterResource)\n       throws IOException {\n     super.setupQueueConfigs(clusterResource);\n     \n     this.lastClusterResource \u003d clusterResource;\n     updateAbsoluteCapacityResource(clusterResource);\n     \n-    this.currentResourceLimits \u003d new ResourceLimits(clusterResource);\n+    this.cachedResourceLimitsForHeadroom \u003d new ResourceLimits(clusterResource);\n     \n     // Initialize headroom info, also used for calculating application \n     // master resource limits.  Since this happens during queue initialization\n     // and all queues may not be realized yet, we\u0027ll use (optimistic) \n     // absoluteMaxCapacity (it will be replaced with the more accurate \n     // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n     setQueueResourceLimitsInfo(clusterResource);\n \n     CapacitySchedulerConfiguration conf \u003d csContext.getConfiguration();\n     \n     setOrderingPolicy(conf.\u003cFiCaSchedulerApp\u003egetOrderingPolicy(getQueuePath()));\n     \n     userLimit \u003d conf.getUserLimit(getQueuePath());\n     userLimitFactor \u003d conf.getUserLimitFactor(getQueuePath());\n \n     maxApplications \u003d conf.getMaximumApplicationsPerQueue(getQueuePath());\n     if (maxApplications \u003c 0) {\n       int maxSystemApps \u003d conf.getMaximumSystemApplications();\n       maxApplications \u003d\n           (int) (maxSystemApps * queueCapacities.getAbsoluteCapacity());\n     }\n     maxApplicationsPerUser \u003d \n       (int)(maxApplications * (userLimit / 100.0f) * userLimitFactor);\n     \n     maxAMResourcePerQueuePercent \u003d\n         conf.getMaximumApplicationMasterResourcePerQueuePercent(getQueuePath());\n \n     if (!SchedulerUtils.checkQueueLabelExpression(this.accessibleLabels,\n         this.defaultLabelExpression)) {\n       throw new IOException(\"Invalid default label expression of \"\n           + \" queue\u003d\"\n           + getQueueName()\n           + \" doesn\u0027t have permission to access all labels \"\n           + \"in default label expression. labelExpression of resource request\u003d\"\n           + (this.defaultLabelExpression \u003d\u003d null ? \"\"\n               : this.defaultLabelExpression)\n           + \". Queue labels\u003d\"\n           + (getAccessibleNodeLabels() \u003d\u003d null ? \"\" : StringUtils.join(\n               getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n     }\n     \n     nodeLocalityDelay \u003d conf.getNodeLocalityDelay();\n \n     // re-init this since max allocation could have changed\n     this.minimumAllocationFactor \u003d\n         Resources.ratio(resourceCalculator,\n             Resources.subtract(maximumAllocation, minimumAllocation),\n             maximumAllocation);\n \n     StringBuilder aclsString \u003d new StringBuilder();\n     for (Map.Entry\u003cAccessType, AccessControlList\u003e e : acls.entrySet()) {\n       aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n     }\n \n     StringBuilder labelStrBuilder \u003d new StringBuilder(); \n     if (accessibleLabels !\u003d null) {\n       for (String s : accessibleLabels) {\n         labelStrBuilder.append(s);\n         labelStrBuilder.append(\",\");\n       }\n     }\n \n     LOG.info(\"Initializing \" + queueName + \"\\n\" +\n         \"capacity \u003d \" + queueCapacities.getCapacity() +\n         \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n         \"asboluteCapacity \u003d \" + queueCapacities.getAbsoluteCapacity() +\n         \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n         \"maxCapacity \u003d \" + queueCapacities.getMaximumCapacity() +\n         \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n         \"absoluteMaxCapacity \u003d \" + queueCapacities.getAbsoluteMaximumCapacity() +\n         \" [\u003d 1.0 maximumCapacity undefined, \" +\n         \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n         \"\\n\" +\n         \"userLimit \u003d \" + userLimit +\n         \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n         \"userLimitFactor \u003d \" + userLimitFactor +\n         \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n         \"maxApplications \u003d \" + maxApplications +\n         \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n         \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n         \"\\n\" +\n         \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n         \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n         \"userLimitFactor) ]\" + \"\\n\" +\n         \"usedCapacity \u003d \" + queueCapacities.getUsedCapacity() +\n         \" [\u003d usedResourcesMemory / \" +\n         \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n         \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n         \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n         \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n         \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n         \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n         \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n         \"maximumAllocationMemory ]\" + \"\\n\" +\n         \"maximumAllocation \u003d \" + maximumAllocation +\n         \" [\u003d configuredMaxAllocation ]\" + \"\\n\" +\n         \"numContainers \u003d \" + numContainers +\n         \" [\u003d currentNumContainers ]\" + \"\\n\" +\n         \"state \u003d \" + state +\n         \" [\u003d configuredState ]\" + \"\\n\" +\n         \"acls \u003d \" + aclsString +\n         \" [\u003d configuredAcls ]\" + \"\\n\" + \n         \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\" +\n         \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\" +\n         \"nodeLocalityDelay \u003d \" +  nodeLocalityDelay + \"\\n\" +\n         \"reservationsContinueLooking \u003d \" +\n         reservationsContinueLooking + \"\\n\" +\n         \"preemptionDisabled \u003d \" + getPreemptionDisabled() + \"\\n\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void setupQueueConfigs(Resource clusterResource)\n      throws IOException {\n    super.setupQueueConfigs(clusterResource);\n    \n    this.lastClusterResource \u003d clusterResource;\n    updateAbsoluteCapacityResource(clusterResource);\n    \n    this.cachedResourceLimitsForHeadroom \u003d new ResourceLimits(clusterResource);\n    \n    // Initialize headroom info, also used for calculating application \n    // master resource limits.  Since this happens during queue initialization\n    // and all queues may not be realized yet, we\u0027ll use (optimistic) \n    // absoluteMaxCapacity (it will be replaced with the more accurate \n    // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n    setQueueResourceLimitsInfo(clusterResource);\n\n    CapacitySchedulerConfiguration conf \u003d csContext.getConfiguration();\n    \n    setOrderingPolicy(conf.\u003cFiCaSchedulerApp\u003egetOrderingPolicy(getQueuePath()));\n    \n    userLimit \u003d conf.getUserLimit(getQueuePath());\n    userLimitFactor \u003d conf.getUserLimitFactor(getQueuePath());\n\n    maxApplications \u003d conf.getMaximumApplicationsPerQueue(getQueuePath());\n    if (maxApplications \u003c 0) {\n      int maxSystemApps \u003d conf.getMaximumSystemApplications();\n      maxApplications \u003d\n          (int) (maxSystemApps * queueCapacities.getAbsoluteCapacity());\n    }\n    maxApplicationsPerUser \u003d \n      (int)(maxApplications * (userLimit / 100.0f) * userLimitFactor);\n    \n    maxAMResourcePerQueuePercent \u003d\n        conf.getMaximumApplicationMasterResourcePerQueuePercent(getQueuePath());\n\n    if (!SchedulerUtils.checkQueueLabelExpression(this.accessibleLabels,\n        this.defaultLabelExpression)) {\n      throw new IOException(\"Invalid default label expression of \"\n          + \" queue\u003d\"\n          + getQueueName()\n          + \" doesn\u0027t have permission to access all labels \"\n          + \"in default label expression. labelExpression of resource request\u003d\"\n          + (this.defaultLabelExpression \u003d\u003d null ? \"\"\n              : this.defaultLabelExpression)\n          + \". Queue labels\u003d\"\n          + (getAccessibleNodeLabels() \u003d\u003d null ? \"\" : StringUtils.join(\n              getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n    }\n    \n    nodeLocalityDelay \u003d conf.getNodeLocalityDelay();\n\n    // re-init this since max allocation could have changed\n    this.minimumAllocationFactor \u003d\n        Resources.ratio(resourceCalculator,\n            Resources.subtract(maximumAllocation, minimumAllocation),\n            maximumAllocation);\n\n    StringBuilder aclsString \u003d new StringBuilder();\n    for (Map.Entry\u003cAccessType, AccessControlList\u003e e : acls.entrySet()) {\n      aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n    }\n\n    StringBuilder labelStrBuilder \u003d new StringBuilder(); \n    if (accessibleLabels !\u003d null) {\n      for (String s : accessibleLabels) {\n        labelStrBuilder.append(s);\n        labelStrBuilder.append(\",\");\n      }\n    }\n\n    LOG.info(\"Initializing \" + queueName + \"\\n\" +\n        \"capacity \u003d \" + queueCapacities.getCapacity() +\n        \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n        \"asboluteCapacity \u003d \" + queueCapacities.getAbsoluteCapacity() +\n        \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n        \"maxCapacity \u003d \" + queueCapacities.getMaximumCapacity() +\n        \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n        \"absoluteMaxCapacity \u003d \" + queueCapacities.getAbsoluteMaximumCapacity() +\n        \" [\u003d 1.0 maximumCapacity undefined, \" +\n        \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n        \"\\n\" +\n        \"userLimit \u003d \" + userLimit +\n        \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n        \"userLimitFactor \u003d \" + userLimitFactor +\n        \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n        \"maxApplications \u003d \" + maxApplications +\n        \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n        \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n        \"\\n\" +\n        \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n        \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n        \"userLimitFactor) ]\" + \"\\n\" +\n        \"usedCapacity \u003d \" + queueCapacities.getUsedCapacity() +\n        \" [\u003d usedResourcesMemory / \" +\n        \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n        \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n        \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n        \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n        \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n        \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n        \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n        \"maximumAllocationMemory ]\" + \"\\n\" +\n        \"maximumAllocation \u003d \" + maximumAllocation +\n        \" [\u003d configuredMaxAllocation ]\" + \"\\n\" +\n        \"numContainers \u003d \" + numContainers +\n        \" [\u003d currentNumContainers ]\" + \"\\n\" +\n        \"state \u003d \" + state +\n        \" [\u003d configuredState ]\" + \"\\n\" +\n        \"acls \u003d \" + aclsString +\n        \" [\u003d configuredAcls ]\" + \"\\n\" + \n        \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\" +\n        \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\" +\n        \"nodeLocalityDelay \u003d \" +  nodeLocalityDelay + \"\\n\" +\n        \"reservationsContinueLooking \u003d \" +\n        reservationsContinueLooking + \"\\n\" +\n        \"preemptionDisabled \u003d \" + getPreemptionDisabled() + \"\\n\");\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "44872b76fcc0ddfbc7b0a4e54eef50fe8708e0f5": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3463. Integrate OrderingPolicy Framework with CapacityScheduler. (Craig Welch via wangda)\n",
      "commitDate": "20/04/15 5:12 PM",
      "commitName": "44872b76fcc0ddfbc7b0a4e54eef50fe8708e0f5",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "17/04/15 1:36 PM",
      "commitNameOld": "d573f09fb93dbb711d504620af5d73840ea063a6",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 3.15,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,114 +1,117 @@\n   protected synchronized void setupQueueConfigs(Resource clusterResource)\n       throws IOException {\n     super.setupQueueConfigs(clusterResource);\n     \n     this.lastClusterResource \u003d clusterResource;\n     updateAbsoluteCapacityResource(clusterResource);\n     \n     this.currentResourceLimits \u003d new ResourceLimits(clusterResource);\n     \n     // Initialize headroom info, also used for calculating application \n     // master resource limits.  Since this happens during queue initialization\n     // and all queues may not be realized yet, we\u0027ll use (optimistic) \n     // absoluteMaxCapacity (it will be replaced with the more accurate \n     // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n     setQueueResourceLimitsInfo(clusterResource);\n \n     CapacitySchedulerConfiguration conf \u003d csContext.getConfiguration();\n+    \n+    setOrderingPolicy(conf.\u003cFiCaSchedulerApp\u003egetOrderingPolicy(getQueuePath()));\n+    \n     userLimit \u003d conf.getUserLimit(getQueuePath());\n     userLimitFactor \u003d conf.getUserLimitFactor(getQueuePath());\n \n     maxApplications \u003d conf.getMaximumApplicationsPerQueue(getQueuePath());\n     if (maxApplications \u003c 0) {\n       int maxSystemApps \u003d conf.getMaximumSystemApplications();\n       maxApplications \u003d\n           (int) (maxSystemApps * queueCapacities.getAbsoluteCapacity());\n     }\n     maxApplicationsPerUser \u003d \n       (int)(maxApplications * (userLimit / 100.0f) * userLimitFactor);\n     \n     maxAMResourcePerQueuePercent \u003d\n         conf.getMaximumApplicationMasterResourcePerQueuePercent(getQueuePath());\n \n     if (!SchedulerUtils.checkQueueLabelExpression(this.accessibleLabels,\n         this.defaultLabelExpression)) {\n       throw new IOException(\"Invalid default label expression of \"\n           + \" queue\u003d\"\n           + getQueueName()\n           + \" doesn\u0027t have permission to access all labels \"\n           + \"in default label expression. labelExpression of resource request\u003d\"\n           + (this.defaultLabelExpression \u003d\u003d null ? \"\"\n               : this.defaultLabelExpression)\n           + \". Queue labels\u003d\"\n           + (getAccessibleNodeLabels() \u003d\u003d null ? \"\" : StringUtils.join(\n               getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n     }\n     \n     nodeLocalityDelay \u003d conf.getNodeLocalityDelay();\n \n     // re-init this since max allocation could have changed\n     this.minimumAllocationFactor \u003d\n         Resources.ratio(resourceCalculator,\n             Resources.subtract(maximumAllocation, minimumAllocation),\n             maximumAllocation);\n \n     StringBuilder aclsString \u003d new StringBuilder();\n     for (Map.Entry\u003cAccessType, AccessControlList\u003e e : acls.entrySet()) {\n       aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n     }\n \n     StringBuilder labelStrBuilder \u003d new StringBuilder(); \n     if (accessibleLabels !\u003d null) {\n       for (String s : accessibleLabels) {\n         labelStrBuilder.append(s);\n         labelStrBuilder.append(\",\");\n       }\n     }\n \n     LOG.info(\"Initializing \" + queueName + \"\\n\" +\n         \"capacity \u003d \" + queueCapacities.getCapacity() +\n         \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n         \"asboluteCapacity \u003d \" + queueCapacities.getAbsoluteCapacity() +\n         \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n         \"maxCapacity \u003d \" + queueCapacities.getMaximumCapacity() +\n         \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n         \"absoluteMaxCapacity \u003d \" + queueCapacities.getAbsoluteMaximumCapacity() +\n         \" [\u003d 1.0 maximumCapacity undefined, \" +\n         \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n         \"\\n\" +\n         \"userLimit \u003d \" + userLimit +\n         \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n         \"userLimitFactor \u003d \" + userLimitFactor +\n         \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n         \"maxApplications \u003d \" + maxApplications +\n         \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n         \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n         \"\\n\" +\n         \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n         \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n         \"userLimitFactor) ]\" + \"\\n\" +\n         \"usedCapacity \u003d \" + queueCapacities.getUsedCapacity() +\n         \" [\u003d usedResourcesMemory / \" +\n         \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n         \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n         \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n         \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n         \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n         \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n         \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n         \"maximumAllocationMemory ]\" + \"\\n\" +\n         \"maximumAllocation \u003d \" + maximumAllocation +\n         \" [\u003d configuredMaxAllocation ]\" + \"\\n\" +\n         \"numContainers \u003d \" + numContainers +\n         \" [\u003d currentNumContainers ]\" + \"\\n\" +\n         \"state \u003d \" + state +\n         \" [\u003d configuredState ]\" + \"\\n\" +\n         \"acls \u003d \" + aclsString +\n         \" [\u003d configuredAcls ]\" + \"\\n\" + \n         \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\" +\n         \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\" +\n         \"nodeLocalityDelay \u003d \" +  nodeLocalityDelay + \"\\n\" +\n         \"reservationsContinueLooking \u003d \" +\n         reservationsContinueLooking + \"\\n\" +\n         \"preemptionDisabled \u003d \" + getPreemptionDisabled() + \"\\n\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void setupQueueConfigs(Resource clusterResource)\n      throws IOException {\n    super.setupQueueConfigs(clusterResource);\n    \n    this.lastClusterResource \u003d clusterResource;\n    updateAbsoluteCapacityResource(clusterResource);\n    \n    this.currentResourceLimits \u003d new ResourceLimits(clusterResource);\n    \n    // Initialize headroom info, also used for calculating application \n    // master resource limits.  Since this happens during queue initialization\n    // and all queues may not be realized yet, we\u0027ll use (optimistic) \n    // absoluteMaxCapacity (it will be replaced with the more accurate \n    // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n    setQueueResourceLimitsInfo(clusterResource);\n\n    CapacitySchedulerConfiguration conf \u003d csContext.getConfiguration();\n    \n    setOrderingPolicy(conf.\u003cFiCaSchedulerApp\u003egetOrderingPolicy(getQueuePath()));\n    \n    userLimit \u003d conf.getUserLimit(getQueuePath());\n    userLimitFactor \u003d conf.getUserLimitFactor(getQueuePath());\n\n    maxApplications \u003d conf.getMaximumApplicationsPerQueue(getQueuePath());\n    if (maxApplications \u003c 0) {\n      int maxSystemApps \u003d conf.getMaximumSystemApplications();\n      maxApplications \u003d\n          (int) (maxSystemApps * queueCapacities.getAbsoluteCapacity());\n    }\n    maxApplicationsPerUser \u003d \n      (int)(maxApplications * (userLimit / 100.0f) * userLimitFactor);\n    \n    maxAMResourcePerQueuePercent \u003d\n        conf.getMaximumApplicationMasterResourcePerQueuePercent(getQueuePath());\n\n    if (!SchedulerUtils.checkQueueLabelExpression(this.accessibleLabels,\n        this.defaultLabelExpression)) {\n      throw new IOException(\"Invalid default label expression of \"\n          + \" queue\u003d\"\n          + getQueueName()\n          + \" doesn\u0027t have permission to access all labels \"\n          + \"in default label expression. labelExpression of resource request\u003d\"\n          + (this.defaultLabelExpression \u003d\u003d null ? \"\"\n              : this.defaultLabelExpression)\n          + \". Queue labels\u003d\"\n          + (getAccessibleNodeLabels() \u003d\u003d null ? \"\" : StringUtils.join(\n              getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n    }\n    \n    nodeLocalityDelay \u003d conf.getNodeLocalityDelay();\n\n    // re-init this since max allocation could have changed\n    this.minimumAllocationFactor \u003d\n        Resources.ratio(resourceCalculator,\n            Resources.subtract(maximumAllocation, minimumAllocation),\n            maximumAllocation);\n\n    StringBuilder aclsString \u003d new StringBuilder();\n    for (Map.Entry\u003cAccessType, AccessControlList\u003e e : acls.entrySet()) {\n      aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n    }\n\n    StringBuilder labelStrBuilder \u003d new StringBuilder(); \n    if (accessibleLabels !\u003d null) {\n      for (String s : accessibleLabels) {\n        labelStrBuilder.append(s);\n        labelStrBuilder.append(\",\");\n      }\n    }\n\n    LOG.info(\"Initializing \" + queueName + \"\\n\" +\n        \"capacity \u003d \" + queueCapacities.getCapacity() +\n        \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n        \"asboluteCapacity \u003d \" + queueCapacities.getAbsoluteCapacity() +\n        \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n        \"maxCapacity \u003d \" + queueCapacities.getMaximumCapacity() +\n        \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n        \"absoluteMaxCapacity \u003d \" + queueCapacities.getAbsoluteMaximumCapacity() +\n        \" [\u003d 1.0 maximumCapacity undefined, \" +\n        \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n        \"\\n\" +\n        \"userLimit \u003d \" + userLimit +\n        \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n        \"userLimitFactor \u003d \" + userLimitFactor +\n        \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n        \"maxApplications \u003d \" + maxApplications +\n        \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n        \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n        \"\\n\" +\n        \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n        \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n        \"userLimitFactor) ]\" + \"\\n\" +\n        \"usedCapacity \u003d \" + queueCapacities.getUsedCapacity() +\n        \" [\u003d usedResourcesMemory / \" +\n        \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n        \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n        \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n        \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n        \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n        \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n        \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n        \"maximumAllocationMemory ]\" + \"\\n\" +\n        \"maximumAllocation \u003d \" + maximumAllocation +\n        \" [\u003d configuredMaxAllocation ]\" + \"\\n\" +\n        \"numContainers \u003d \" + numContainers +\n        \" [\u003d currentNumContainers ]\" + \"\\n\" +\n        \"state \u003d \" + state +\n        \" [\u003d configuredState ]\" + \"\\n\" +\n        \"acls \u003d \" + aclsString +\n        \" [\u003d configuredAcls ]\" + \"\\n\" + \n        \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\" +\n        \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\" +\n        \"nodeLocalityDelay \u003d \" +  nodeLocalityDelay + \"\\n\" +\n        \"reservationsContinueLooking \u003d \" +\n        reservationsContinueLooking + \"\\n\" +\n        \"preemptionDisabled \u003d \" + getPreemptionDisabled() + \"\\n\");\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "487374b7fe0c92fc7eb1406c568952722b5d5b15": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3243. CapacityScheduler should pass headroom from parent to children to make sure ParentQueue obey its capacity limits. Contributed by Wangda Tan.\n",
      "commitDate": "17/03/15 10:24 AM",
      "commitName": "487374b7fe0c92fc7eb1406c568952722b5d5b15",
      "commitAuthor": "Jian He",
      "commitDateOld": "03/03/15 11:49 AM",
      "commitNameOld": "e17e5ba9d7e2bd45ba6884f59f8045817594b284",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 13.9,
      "commitsBetweenForRepo": 109,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,114 +1,114 @@\n   protected synchronized void setupQueueConfigs(Resource clusterResource)\n       throws IOException {\n     super.setupQueueConfigs(clusterResource);\n     \n     this.lastClusterResource \u003d clusterResource;\n     updateAbsoluteCapacityResource(clusterResource);\n     \n     this.currentResourceLimits \u003d new ResourceLimits(clusterResource);\n     \n     // Initialize headroom info, also used for calculating application \n     // master resource limits.  Since this happens during queue initialization\n     // and all queues may not be realized yet, we\u0027ll use (optimistic) \n     // absoluteMaxCapacity (it will be replaced with the more accurate \n     // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n-    computeQueueCurrentLimitAndSetHeadroomInfo(clusterResource);\n+    setQueueResourceLimitsInfo(clusterResource);\n \n     CapacitySchedulerConfiguration conf \u003d csContext.getConfiguration();\n     userLimit \u003d conf.getUserLimit(getQueuePath());\n     userLimitFactor \u003d conf.getUserLimitFactor(getQueuePath());\n \n     maxApplications \u003d conf.getMaximumApplicationsPerQueue(getQueuePath());\n     if (maxApplications \u003c 0) {\n       int maxSystemApps \u003d conf.getMaximumSystemApplications();\n       maxApplications \u003d\n           (int) (maxSystemApps * queueCapacities.getAbsoluteCapacity());\n     }\n     maxApplicationsPerUser \u003d \n       (int)(maxApplications * (userLimit / 100.0f) * userLimitFactor);\n     \n     maxAMResourcePerQueuePercent \u003d\n         conf.getMaximumApplicationMasterResourcePerQueuePercent(getQueuePath());\n \n     if (!SchedulerUtils.checkQueueLabelExpression(this.accessibleLabels,\n         this.defaultLabelExpression)) {\n       throw new IOException(\"Invalid default label expression of \"\n           + \" queue\u003d\"\n           + getQueueName()\n           + \" doesn\u0027t have permission to access all labels \"\n           + \"in default label expression. labelExpression of resource request\u003d\"\n           + (this.defaultLabelExpression \u003d\u003d null ? \"\"\n               : this.defaultLabelExpression)\n           + \". Queue labels\u003d\"\n           + (getAccessibleNodeLabels() \u003d\u003d null ? \"\" : StringUtils.join(\n               getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n     }\n     \n     nodeLocalityDelay \u003d conf.getNodeLocalityDelay();\n \n     // re-init this since max allocation could have changed\n     this.minimumAllocationFactor \u003d\n         Resources.ratio(resourceCalculator,\n             Resources.subtract(maximumAllocation, minimumAllocation),\n             maximumAllocation);\n \n     StringBuilder aclsString \u003d new StringBuilder();\n     for (Map.Entry\u003cAccessType, AccessControlList\u003e e : acls.entrySet()) {\n       aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n     }\n \n     StringBuilder labelStrBuilder \u003d new StringBuilder(); \n     if (accessibleLabels !\u003d null) {\n       for (String s : accessibleLabels) {\n         labelStrBuilder.append(s);\n         labelStrBuilder.append(\",\");\n       }\n     }\n \n     LOG.info(\"Initializing \" + queueName + \"\\n\" +\n         \"capacity \u003d \" + queueCapacities.getCapacity() +\n         \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n         \"asboluteCapacity \u003d \" + queueCapacities.getAbsoluteCapacity() +\n         \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n         \"maxCapacity \u003d \" + queueCapacities.getMaximumCapacity() +\n         \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n         \"absoluteMaxCapacity \u003d \" + queueCapacities.getAbsoluteMaximumCapacity() +\n         \" [\u003d 1.0 maximumCapacity undefined, \" +\n         \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n         \"\\n\" +\n         \"userLimit \u003d \" + userLimit +\n         \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n         \"userLimitFactor \u003d \" + userLimitFactor +\n         \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n         \"maxApplications \u003d \" + maxApplications +\n         \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n         \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n         \"\\n\" +\n         \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n         \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n         \"userLimitFactor) ]\" + \"\\n\" +\n         \"usedCapacity \u003d \" + queueCapacities.getUsedCapacity() +\n         \" [\u003d usedResourcesMemory / \" +\n         \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n         \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n         \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n         \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n         \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n         \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n         \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n         \"maximumAllocationMemory ]\" + \"\\n\" +\n         \"maximumAllocation \u003d \" + maximumAllocation +\n         \" [\u003d configuredMaxAllocation ]\" + \"\\n\" +\n         \"numContainers \u003d \" + numContainers +\n         \" [\u003d currentNumContainers ]\" + \"\\n\" +\n         \"state \u003d \" + state +\n         \" [\u003d configuredState ]\" + \"\\n\" +\n         \"acls \u003d \" + aclsString +\n         \" [\u003d configuredAcls ]\" + \"\\n\" + \n         \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\" +\n         \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\" +\n         \"nodeLocalityDelay \u003d \" +  nodeLocalityDelay + \"\\n\" +\n         \"reservationsContinueLooking \u003d \" +\n         reservationsContinueLooking + \"\\n\" +\n         \"preemptionDisabled \u003d \" + getPreemptionDisabled() + \"\\n\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void setupQueueConfigs(Resource clusterResource)\n      throws IOException {\n    super.setupQueueConfigs(clusterResource);\n    \n    this.lastClusterResource \u003d clusterResource;\n    updateAbsoluteCapacityResource(clusterResource);\n    \n    this.currentResourceLimits \u003d new ResourceLimits(clusterResource);\n    \n    // Initialize headroom info, also used for calculating application \n    // master resource limits.  Since this happens during queue initialization\n    // and all queues may not be realized yet, we\u0027ll use (optimistic) \n    // absoluteMaxCapacity (it will be replaced with the more accurate \n    // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n    setQueueResourceLimitsInfo(clusterResource);\n\n    CapacitySchedulerConfiguration conf \u003d csContext.getConfiguration();\n    userLimit \u003d conf.getUserLimit(getQueuePath());\n    userLimitFactor \u003d conf.getUserLimitFactor(getQueuePath());\n\n    maxApplications \u003d conf.getMaximumApplicationsPerQueue(getQueuePath());\n    if (maxApplications \u003c 0) {\n      int maxSystemApps \u003d conf.getMaximumSystemApplications();\n      maxApplications \u003d\n          (int) (maxSystemApps * queueCapacities.getAbsoluteCapacity());\n    }\n    maxApplicationsPerUser \u003d \n      (int)(maxApplications * (userLimit / 100.0f) * userLimitFactor);\n    \n    maxAMResourcePerQueuePercent \u003d\n        conf.getMaximumApplicationMasterResourcePerQueuePercent(getQueuePath());\n\n    if (!SchedulerUtils.checkQueueLabelExpression(this.accessibleLabels,\n        this.defaultLabelExpression)) {\n      throw new IOException(\"Invalid default label expression of \"\n          + \" queue\u003d\"\n          + getQueueName()\n          + \" doesn\u0027t have permission to access all labels \"\n          + \"in default label expression. labelExpression of resource request\u003d\"\n          + (this.defaultLabelExpression \u003d\u003d null ? \"\"\n              : this.defaultLabelExpression)\n          + \". Queue labels\u003d\"\n          + (getAccessibleNodeLabels() \u003d\u003d null ? \"\" : StringUtils.join(\n              getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n    }\n    \n    nodeLocalityDelay \u003d conf.getNodeLocalityDelay();\n\n    // re-init this since max allocation could have changed\n    this.minimumAllocationFactor \u003d\n        Resources.ratio(resourceCalculator,\n            Resources.subtract(maximumAllocation, minimumAllocation),\n            maximumAllocation);\n\n    StringBuilder aclsString \u003d new StringBuilder();\n    for (Map.Entry\u003cAccessType, AccessControlList\u003e e : acls.entrySet()) {\n      aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n    }\n\n    StringBuilder labelStrBuilder \u003d new StringBuilder(); \n    if (accessibleLabels !\u003d null) {\n      for (String s : accessibleLabels) {\n        labelStrBuilder.append(s);\n        labelStrBuilder.append(\",\");\n      }\n    }\n\n    LOG.info(\"Initializing \" + queueName + \"\\n\" +\n        \"capacity \u003d \" + queueCapacities.getCapacity() +\n        \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n        \"asboluteCapacity \u003d \" + queueCapacities.getAbsoluteCapacity() +\n        \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n        \"maxCapacity \u003d \" + queueCapacities.getMaximumCapacity() +\n        \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n        \"absoluteMaxCapacity \u003d \" + queueCapacities.getAbsoluteMaximumCapacity() +\n        \" [\u003d 1.0 maximumCapacity undefined, \" +\n        \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n        \"\\n\" +\n        \"userLimit \u003d \" + userLimit +\n        \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n        \"userLimitFactor \u003d \" + userLimitFactor +\n        \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n        \"maxApplications \u003d \" + maxApplications +\n        \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n        \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n        \"\\n\" +\n        \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n        \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n        \"userLimitFactor) ]\" + \"\\n\" +\n        \"usedCapacity \u003d \" + queueCapacities.getUsedCapacity() +\n        \" [\u003d usedResourcesMemory / \" +\n        \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n        \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n        \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n        \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n        \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n        \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n        \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n        \"maximumAllocationMemory ]\" + \"\\n\" +\n        \"maximumAllocation \u003d \" + maximumAllocation +\n        \" [\u003d configuredMaxAllocation ]\" + \"\\n\" +\n        \"numContainers \u003d \" + numContainers +\n        \" [\u003d currentNumContainers ]\" + \"\\n\" +\n        \"state \u003d \" + state +\n        \" [\u003d configuredState ]\" + \"\\n\" +\n        \"acls \u003d \" + aclsString +\n        \" [\u003d configuredAcls ]\" + \"\\n\" + \n        \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\" +\n        \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\" +\n        \"nodeLocalityDelay \u003d \" +  nodeLocalityDelay + \"\\n\" +\n        \"reservationsContinueLooking \u003d \" +\n        reservationsContinueLooking + \"\\n\" +\n        \"preemptionDisabled \u003d \" + getPreemptionDisabled() + \"\\n\");\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "14dd647c556016d351f425ee956ccf800ccb9ce2": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3265. Fixed a deadlock in CapacityScheduler by always passing a queue\u0027s available resource-limit from the parent queue. Contributed by Wangda Tan.\n",
      "commitDate": "02/03/15 5:52 PM",
      "commitName": "14dd647c556016d351f425ee956ccf800ccb9ce2",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "12/02/15 2:58 PM",
      "commitNameOld": "18a594257e052e8f10a03e5594e6cc6901dc56be",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 18.12,
      "commitsBetweenForRepo": 155,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,113 +1,114 @@\n   protected synchronized void setupQueueConfigs(Resource clusterResource)\n       throws IOException {\n     super.setupQueueConfigs(clusterResource);\n     \n     this.lastClusterResource \u003d clusterResource;\n     updateAbsoluteCapacityResource(clusterResource);\n     \n+    this.currentResourceLimits \u003d new ResourceLimits(clusterResource);\n+    \n     // Initialize headroom info, also used for calculating application \n     // master resource limits.  Since this happens during queue initialization\n     // and all queues may not be realized yet, we\u0027ll use (optimistic) \n     // absoluteMaxCapacity (it will be replaced with the more accurate \n     // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n-    updateHeadroomInfo(clusterResource,\n-        queueCapacities.getAbsoluteMaximumCapacity());\n+    computeQueueCurrentLimitAndSetHeadroomInfo(clusterResource);\n \n     CapacitySchedulerConfiguration conf \u003d csContext.getConfiguration();\n     userLimit \u003d conf.getUserLimit(getQueuePath());\n     userLimitFactor \u003d conf.getUserLimitFactor(getQueuePath());\n \n     maxApplications \u003d conf.getMaximumApplicationsPerQueue(getQueuePath());\n     if (maxApplications \u003c 0) {\n       int maxSystemApps \u003d conf.getMaximumSystemApplications();\n       maxApplications \u003d\n           (int) (maxSystemApps * queueCapacities.getAbsoluteCapacity());\n     }\n     maxApplicationsPerUser \u003d \n       (int)(maxApplications * (userLimit / 100.0f) * userLimitFactor);\n     \n     maxAMResourcePerQueuePercent \u003d\n         conf.getMaximumApplicationMasterResourcePerQueuePercent(getQueuePath());\n \n     if (!SchedulerUtils.checkQueueLabelExpression(this.accessibleLabels,\n         this.defaultLabelExpression)) {\n       throw new IOException(\"Invalid default label expression of \"\n           + \" queue\u003d\"\n           + getQueueName()\n           + \" doesn\u0027t have permission to access all labels \"\n           + \"in default label expression. labelExpression of resource request\u003d\"\n           + (this.defaultLabelExpression \u003d\u003d null ? \"\"\n               : this.defaultLabelExpression)\n           + \". Queue labels\u003d\"\n           + (getAccessibleNodeLabels() \u003d\u003d null ? \"\" : StringUtils.join(\n               getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n     }\n     \n     nodeLocalityDelay \u003d conf.getNodeLocalityDelay();\n \n     // re-init this since max allocation could have changed\n     this.minimumAllocationFactor \u003d\n         Resources.ratio(resourceCalculator,\n             Resources.subtract(maximumAllocation, minimumAllocation),\n             maximumAllocation);\n \n     StringBuilder aclsString \u003d new StringBuilder();\n     for (Map.Entry\u003cAccessType, AccessControlList\u003e e : acls.entrySet()) {\n       aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n     }\n \n     StringBuilder labelStrBuilder \u003d new StringBuilder(); \n     if (accessibleLabels !\u003d null) {\n       for (String s : accessibleLabels) {\n         labelStrBuilder.append(s);\n         labelStrBuilder.append(\",\");\n       }\n     }\n \n     LOG.info(\"Initializing \" + queueName + \"\\n\" +\n         \"capacity \u003d \" + queueCapacities.getCapacity() +\n         \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n         \"asboluteCapacity \u003d \" + queueCapacities.getAbsoluteCapacity() +\n         \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n         \"maxCapacity \u003d \" + queueCapacities.getMaximumCapacity() +\n         \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n         \"absoluteMaxCapacity \u003d \" + queueCapacities.getAbsoluteMaximumCapacity() +\n         \" [\u003d 1.0 maximumCapacity undefined, \" +\n         \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n         \"\\n\" +\n         \"userLimit \u003d \" + userLimit +\n         \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n         \"userLimitFactor \u003d \" + userLimitFactor +\n         \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n         \"maxApplications \u003d \" + maxApplications +\n         \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n         \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n         \"\\n\" +\n         \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n         \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n         \"userLimitFactor) ]\" + \"\\n\" +\n         \"usedCapacity \u003d \" + queueCapacities.getUsedCapacity() +\n         \" [\u003d usedResourcesMemory / \" +\n         \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n         \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n         \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n         \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n         \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n         \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n         \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n         \"maximumAllocationMemory ]\" + \"\\n\" +\n         \"maximumAllocation \u003d \" + maximumAllocation +\n         \" [\u003d configuredMaxAllocation ]\" + \"\\n\" +\n         \"numContainers \u003d \" + numContainers +\n         \" [\u003d currentNumContainers ]\" + \"\\n\" +\n         \"state \u003d \" + state +\n         \" [\u003d configuredState ]\" + \"\\n\" +\n         \"acls \u003d \" + aclsString +\n         \" [\u003d configuredAcls ]\" + \"\\n\" + \n         \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\" +\n         \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\" +\n         \"nodeLocalityDelay \u003d \" +  nodeLocalityDelay + \"\\n\" +\n         \"reservationsContinueLooking \u003d \" +\n         reservationsContinueLooking + \"\\n\" +\n         \"preemptionDisabled \u003d \" + getPreemptionDisabled() + \"\\n\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void setupQueueConfigs(Resource clusterResource)\n      throws IOException {\n    super.setupQueueConfigs(clusterResource);\n    \n    this.lastClusterResource \u003d clusterResource;\n    updateAbsoluteCapacityResource(clusterResource);\n    \n    this.currentResourceLimits \u003d new ResourceLimits(clusterResource);\n    \n    // Initialize headroom info, also used for calculating application \n    // master resource limits.  Since this happens during queue initialization\n    // and all queues may not be realized yet, we\u0027ll use (optimistic) \n    // absoluteMaxCapacity (it will be replaced with the more accurate \n    // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n    computeQueueCurrentLimitAndSetHeadroomInfo(clusterResource);\n\n    CapacitySchedulerConfiguration conf \u003d csContext.getConfiguration();\n    userLimit \u003d conf.getUserLimit(getQueuePath());\n    userLimitFactor \u003d conf.getUserLimitFactor(getQueuePath());\n\n    maxApplications \u003d conf.getMaximumApplicationsPerQueue(getQueuePath());\n    if (maxApplications \u003c 0) {\n      int maxSystemApps \u003d conf.getMaximumSystemApplications();\n      maxApplications \u003d\n          (int) (maxSystemApps * queueCapacities.getAbsoluteCapacity());\n    }\n    maxApplicationsPerUser \u003d \n      (int)(maxApplications * (userLimit / 100.0f) * userLimitFactor);\n    \n    maxAMResourcePerQueuePercent \u003d\n        conf.getMaximumApplicationMasterResourcePerQueuePercent(getQueuePath());\n\n    if (!SchedulerUtils.checkQueueLabelExpression(this.accessibleLabels,\n        this.defaultLabelExpression)) {\n      throw new IOException(\"Invalid default label expression of \"\n          + \" queue\u003d\"\n          + getQueueName()\n          + \" doesn\u0027t have permission to access all labels \"\n          + \"in default label expression. labelExpression of resource request\u003d\"\n          + (this.defaultLabelExpression \u003d\u003d null ? \"\"\n              : this.defaultLabelExpression)\n          + \". Queue labels\u003d\"\n          + (getAccessibleNodeLabels() \u003d\u003d null ? \"\" : StringUtils.join(\n              getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n    }\n    \n    nodeLocalityDelay \u003d conf.getNodeLocalityDelay();\n\n    // re-init this since max allocation could have changed\n    this.minimumAllocationFactor \u003d\n        Resources.ratio(resourceCalculator,\n            Resources.subtract(maximumAllocation, minimumAllocation),\n            maximumAllocation);\n\n    StringBuilder aclsString \u003d new StringBuilder();\n    for (Map.Entry\u003cAccessType, AccessControlList\u003e e : acls.entrySet()) {\n      aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n    }\n\n    StringBuilder labelStrBuilder \u003d new StringBuilder(); \n    if (accessibleLabels !\u003d null) {\n      for (String s : accessibleLabels) {\n        labelStrBuilder.append(s);\n        labelStrBuilder.append(\",\");\n      }\n    }\n\n    LOG.info(\"Initializing \" + queueName + \"\\n\" +\n        \"capacity \u003d \" + queueCapacities.getCapacity() +\n        \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n        \"asboluteCapacity \u003d \" + queueCapacities.getAbsoluteCapacity() +\n        \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n        \"maxCapacity \u003d \" + queueCapacities.getMaximumCapacity() +\n        \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n        \"absoluteMaxCapacity \u003d \" + queueCapacities.getAbsoluteMaximumCapacity() +\n        \" [\u003d 1.0 maximumCapacity undefined, \" +\n        \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n        \"\\n\" +\n        \"userLimit \u003d \" + userLimit +\n        \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n        \"userLimitFactor \u003d \" + userLimitFactor +\n        \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n        \"maxApplications \u003d \" + maxApplications +\n        \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n        \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n        \"\\n\" +\n        \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n        \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n        \"userLimitFactor) ]\" + \"\\n\" +\n        \"usedCapacity \u003d \" + queueCapacities.getUsedCapacity() +\n        \" [\u003d usedResourcesMemory / \" +\n        \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n        \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n        \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n        \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n        \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n        \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n        \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n        \"maximumAllocationMemory ]\" + \"\\n\" +\n        \"maximumAllocation \u003d \" + maximumAllocation +\n        \" [\u003d configuredMaxAllocation ]\" + \"\\n\" +\n        \"numContainers \u003d \" + numContainers +\n        \" [\u003d currentNumContainers ]\" + \"\\n\" +\n        \"state \u003d \" + state +\n        \" [\u003d configuredState ]\" + \"\\n\" +\n        \"acls \u003d \" + aclsString +\n        \" [\u003d configuredAcls ]\" + \"\\n\" + \n        \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\" +\n        \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\" +\n        \"nodeLocalityDelay \u003d \" +  nodeLocalityDelay + \"\\n\" +\n        \"reservationsContinueLooking \u003d \" +\n        reservationsContinueLooking + \"\\n\" +\n        \"preemptionDisabled \u003d \" + getPreemptionDisabled() + \"\\n\");\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "18a594257e052e8f10a03e5594e6cc6901dc56be": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-3124. Fixed CS LeafQueue/ParentQueue to use QueueCapacities to track capacities-by-label. Contributed by Wangda Tan\n",
      "commitDate": "12/02/15 2:58 PM",
      "commitName": "18a594257e052e8f10a03e5594e6cc6901dc56be",
      "commitAuthor": "Jian He",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-3124. Fixed CS LeafQueue/ParentQueue to use QueueCapacities to track capacities-by-label. Contributed by Wangda Tan\n",
          "commitDate": "12/02/15 2:58 PM",
          "commitName": "18a594257e052e8f10a03e5594e6cc6901dc56be",
          "commitAuthor": "Jian He",
          "commitDateOld": "09/02/15 8:34 PM",
          "commitNameOld": "23bf6c72071782e3fd5a628e21495d6b974c7a9e",
          "commitAuthorOld": "Zhijie Shen",
          "daysBetweenCommits": 2.77,
          "commitsBetweenForRepo": 56,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,124 +1,113 @@\n-  protected synchronized void setupQueueConfigs(\n-      Resource clusterResource,\n-      float capacity, float absoluteCapacity, \n-      float maximumCapacity, float absoluteMaxCapacity,\n-      int userLimit, float userLimitFactor,\n-      int maxApplications, float maxAMResourcePerQueuePercent,\n-      int maxApplicationsPerUser, QueueState state,\n-      Map\u003cAccessType, AccessControlList\u003e acls, int nodeLocalityDelay,\n-      Set\u003cString\u003e labels, String defaultLabelExpression,\n-      Map\u003cString, Float\u003e capacitieByLabel,\n-      Map\u003cString, Float\u003e maximumCapacitiesByLabel, \n-      boolean revervationContinueLooking,\n-      Resource maxAllocation) throws IOException {\n-    super.setupQueueConfigs(clusterResource, capacity, absoluteCapacity,\n-        maximumCapacity, absoluteMaxCapacity, state, acls, labels,\n-        defaultLabelExpression, capacitieByLabel, maximumCapacitiesByLabel,\n-        revervationContinueLooking, maxAllocation);\n-    // Sanity check\n-    CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n-    float absCapacity \u003d getParent().getAbsoluteCapacity() * capacity;\n-    CSQueueUtils.checkAbsoluteCapacity(getQueueName(), absCapacity,\n-        absoluteMaxCapacity);\n+  protected synchronized void setupQueueConfigs(Resource clusterResource)\n+      throws IOException {\n+    super.setupQueueConfigs(clusterResource);\n     \n     this.lastClusterResource \u003d clusterResource;\n     updateAbsoluteCapacityResource(clusterResource);\n     \n     // Initialize headroom info, also used for calculating application \n     // master resource limits.  Since this happens during queue initialization\n     // and all queues may not be realized yet, we\u0027ll use (optimistic) \n     // absoluteMaxCapacity (it will be replaced with the more accurate \n     // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n-    updateHeadroomInfo(clusterResource, absoluteMaxCapacity);\n+    updateHeadroomInfo(clusterResource,\n+        queueCapacities.getAbsoluteMaximumCapacity());\n \n-    this.absoluteCapacity \u003d absCapacity;\n+    CapacitySchedulerConfiguration conf \u003d csContext.getConfiguration();\n+    userLimit \u003d conf.getUserLimit(getQueuePath());\n+    userLimitFactor \u003d conf.getUserLimitFactor(getQueuePath());\n \n-    this.userLimit \u003d userLimit;\n-    this.userLimitFactor \u003d userLimitFactor;\n-\n-    this.maxApplications \u003d maxApplications;\n-    this.maxAMResourcePerQueuePercent \u003d maxAMResourcePerQueuePercent;\n-    this.maxApplicationsPerUser \u003d maxApplicationsPerUser;\n+    maxApplications \u003d conf.getMaximumApplicationsPerQueue(getQueuePath());\n+    if (maxApplications \u003c 0) {\n+      int maxSystemApps \u003d conf.getMaximumSystemApplications();\n+      maxApplications \u003d\n+          (int) (maxSystemApps * queueCapacities.getAbsoluteCapacity());\n+    }\n+    maxApplicationsPerUser \u003d \n+      (int)(maxApplications * (userLimit / 100.0f) * userLimitFactor);\n+    \n+    maxAMResourcePerQueuePercent \u003d\n+        conf.getMaximumApplicationMasterResourcePerQueuePercent(getQueuePath());\n \n     if (!SchedulerUtils.checkQueueLabelExpression(this.accessibleLabels,\n         this.defaultLabelExpression)) {\n       throw new IOException(\"Invalid default label expression of \"\n           + \" queue\u003d\"\n           + getQueueName()\n           + \" doesn\u0027t have permission to access all labels \"\n           + \"in default label expression. labelExpression of resource request\u003d\"\n           + (this.defaultLabelExpression \u003d\u003d null ? \"\"\n               : this.defaultLabelExpression)\n           + \". Queue labels\u003d\"\n           + (getAccessibleNodeLabels() \u003d\u003d null ? \"\" : StringUtils.join(\n               getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n     }\n     \n-    this.nodeLocalityDelay \u003d nodeLocalityDelay;\n+    nodeLocalityDelay \u003d conf.getNodeLocalityDelay();\n \n     // re-init this since max allocation could have changed\n     this.minimumAllocationFactor \u003d\n         Resources.ratio(resourceCalculator,\n             Resources.subtract(maximumAllocation, minimumAllocation),\n             maximumAllocation);\n \n     StringBuilder aclsString \u003d new StringBuilder();\n     for (Map.Entry\u003cAccessType, AccessControlList\u003e e : acls.entrySet()) {\n       aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n     }\n \n     StringBuilder labelStrBuilder \u003d new StringBuilder(); \n-    if (labels !\u003d null) {\n-      for (String s : labels) {\n+    if (accessibleLabels !\u003d null) {\n+      for (String s : accessibleLabels) {\n         labelStrBuilder.append(s);\n         labelStrBuilder.append(\",\");\n       }\n     }\n \n     LOG.info(\"Initializing \" + queueName + \"\\n\" +\n-        \"capacity \u003d \" + capacity +\n+        \"capacity \u003d \" + queueCapacities.getCapacity() +\n         \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n-        \"asboluteCapacity \u003d \" + absoluteCapacity +\n+        \"asboluteCapacity \u003d \" + queueCapacities.getAbsoluteCapacity() +\n         \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n-        \"maxCapacity \u003d \" + maximumCapacity +\n+        \"maxCapacity \u003d \" + queueCapacities.getMaximumCapacity() +\n         \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n-        \"absoluteMaxCapacity \u003d \" + absoluteMaxCapacity +\n+        \"absoluteMaxCapacity \u003d \" + queueCapacities.getAbsoluteMaximumCapacity() +\n         \" [\u003d 1.0 maximumCapacity undefined, \" +\n         \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n         \"\\n\" +\n         \"userLimit \u003d \" + userLimit +\n         \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n         \"userLimitFactor \u003d \" + userLimitFactor +\n         \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n         \"maxApplications \u003d \" + maxApplications +\n         \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n         \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n         \"\\n\" +\n         \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n         \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n         \"userLimitFactor) ]\" + \"\\n\" +\n-        \"usedCapacity \u003d \" + usedCapacity +\n+        \"usedCapacity \u003d \" + queueCapacities.getUsedCapacity() +\n         \" [\u003d usedResourcesMemory / \" +\n         \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n         \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n         \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n         \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n         \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n         \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n         \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n         \"maximumAllocationMemory ]\" + \"\\n\" +\n         \"maximumAllocation \u003d \" + maximumAllocation +\n         \" [\u003d configuredMaxAllocation ]\" + \"\\n\" +\n         \"numContainers \u003d \" + numContainers +\n         \" [\u003d currentNumContainers ]\" + \"\\n\" +\n         \"state \u003d \" + state +\n         \" [\u003d configuredState ]\" + \"\\n\" +\n         \"acls \u003d \" + aclsString +\n         \" [\u003d configuredAcls ]\" + \"\\n\" + \n         \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\" +\n         \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\" +\n         \"nodeLocalityDelay \u003d \" +  nodeLocalityDelay + \"\\n\" +\n         \"reservationsContinueLooking \u003d \" +\n         reservationsContinueLooking + \"\\n\" +\n         \"preemptionDisabled \u003d \" + getPreemptionDisabled() + \"\\n\");\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected synchronized void setupQueueConfigs(Resource clusterResource)\n      throws IOException {\n    super.setupQueueConfigs(clusterResource);\n    \n    this.lastClusterResource \u003d clusterResource;\n    updateAbsoluteCapacityResource(clusterResource);\n    \n    // Initialize headroom info, also used for calculating application \n    // master resource limits.  Since this happens during queue initialization\n    // and all queues may not be realized yet, we\u0027ll use (optimistic) \n    // absoluteMaxCapacity (it will be replaced with the more accurate \n    // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n    updateHeadroomInfo(clusterResource,\n        queueCapacities.getAbsoluteMaximumCapacity());\n\n    CapacitySchedulerConfiguration conf \u003d csContext.getConfiguration();\n    userLimit \u003d conf.getUserLimit(getQueuePath());\n    userLimitFactor \u003d conf.getUserLimitFactor(getQueuePath());\n\n    maxApplications \u003d conf.getMaximumApplicationsPerQueue(getQueuePath());\n    if (maxApplications \u003c 0) {\n      int maxSystemApps \u003d conf.getMaximumSystemApplications();\n      maxApplications \u003d\n          (int) (maxSystemApps * queueCapacities.getAbsoluteCapacity());\n    }\n    maxApplicationsPerUser \u003d \n      (int)(maxApplications * (userLimit / 100.0f) * userLimitFactor);\n    \n    maxAMResourcePerQueuePercent \u003d\n        conf.getMaximumApplicationMasterResourcePerQueuePercent(getQueuePath());\n\n    if (!SchedulerUtils.checkQueueLabelExpression(this.accessibleLabels,\n        this.defaultLabelExpression)) {\n      throw new IOException(\"Invalid default label expression of \"\n          + \" queue\u003d\"\n          + getQueueName()\n          + \" doesn\u0027t have permission to access all labels \"\n          + \"in default label expression. labelExpression of resource request\u003d\"\n          + (this.defaultLabelExpression \u003d\u003d null ? \"\"\n              : this.defaultLabelExpression)\n          + \". Queue labels\u003d\"\n          + (getAccessibleNodeLabels() \u003d\u003d null ? \"\" : StringUtils.join(\n              getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n    }\n    \n    nodeLocalityDelay \u003d conf.getNodeLocalityDelay();\n\n    // re-init this since max allocation could have changed\n    this.minimumAllocationFactor \u003d\n        Resources.ratio(resourceCalculator,\n            Resources.subtract(maximumAllocation, minimumAllocation),\n            maximumAllocation);\n\n    StringBuilder aclsString \u003d new StringBuilder();\n    for (Map.Entry\u003cAccessType, AccessControlList\u003e e : acls.entrySet()) {\n      aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n    }\n\n    StringBuilder labelStrBuilder \u003d new StringBuilder(); \n    if (accessibleLabels !\u003d null) {\n      for (String s : accessibleLabels) {\n        labelStrBuilder.append(s);\n        labelStrBuilder.append(\",\");\n      }\n    }\n\n    LOG.info(\"Initializing \" + queueName + \"\\n\" +\n        \"capacity \u003d \" + queueCapacities.getCapacity() +\n        \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n        \"asboluteCapacity \u003d \" + queueCapacities.getAbsoluteCapacity() +\n        \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n        \"maxCapacity \u003d \" + queueCapacities.getMaximumCapacity() +\n        \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n        \"absoluteMaxCapacity \u003d \" + queueCapacities.getAbsoluteMaximumCapacity() +\n        \" [\u003d 1.0 maximumCapacity undefined, \" +\n        \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n        \"\\n\" +\n        \"userLimit \u003d \" + userLimit +\n        \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n        \"userLimitFactor \u003d \" + userLimitFactor +\n        \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n        \"maxApplications \u003d \" + maxApplications +\n        \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n        \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n        \"\\n\" +\n        \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n        \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n        \"userLimitFactor) ]\" + \"\\n\" +\n        \"usedCapacity \u003d \" + queueCapacities.getUsedCapacity() +\n        \" [\u003d usedResourcesMemory / \" +\n        \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n        \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n        \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n        \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n        \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n        \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n        \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n        \"maximumAllocationMemory ]\" + \"\\n\" +\n        \"maximumAllocation \u003d \" + maximumAllocation +\n        \" [\u003d configuredMaxAllocation ]\" + \"\\n\" +\n        \"numContainers \u003d \" + numContainers +\n        \" [\u003d currentNumContainers ]\" + \"\\n\" +\n        \"state \u003d \" + state +\n        \" [\u003d configuredState ]\" + \"\\n\" +\n        \"acls \u003d \" + aclsString +\n        \" [\u003d configuredAcls ]\" + \"\\n\" + \n        \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\" +\n        \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\" +\n        \"nodeLocalityDelay \u003d \" +  nodeLocalityDelay + \"\\n\" +\n        \"reservationsContinueLooking \u003d \" +\n        reservationsContinueLooking + \"\\n\" +\n        \"preemptionDisabled \u003d \" + getPreemptionDisabled() + \"\\n\");\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {
            "oldValue": "[clusterResource-Resource, capacity-float, absoluteCapacity-float, maximumCapacity-float, absoluteMaxCapacity-float, userLimit-int, userLimitFactor-float, maxApplications-int, maxAMResourcePerQueuePercent-float, maxApplicationsPerUser-int, state-QueueState, acls-Map\u003cAccessType,AccessControlList\u003e, nodeLocalityDelay-int, labels-Set\u003cString\u003e, defaultLabelExpression-String, capacitieByLabel-Map\u003cString,Float\u003e, maximumCapacitiesByLabel-Map\u003cString,Float\u003e, revervationContinueLooking-boolean, maxAllocation-Resource]",
            "newValue": "[clusterResource-Resource]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-3124. Fixed CS LeafQueue/ParentQueue to use QueueCapacities to track capacities-by-label. Contributed by Wangda Tan\n",
          "commitDate": "12/02/15 2:58 PM",
          "commitName": "18a594257e052e8f10a03e5594e6cc6901dc56be",
          "commitAuthor": "Jian He",
          "commitDateOld": "09/02/15 8:34 PM",
          "commitNameOld": "23bf6c72071782e3fd5a628e21495d6b974c7a9e",
          "commitAuthorOld": "Zhijie Shen",
          "daysBetweenCommits": 2.77,
          "commitsBetweenForRepo": 56,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,124 +1,113 @@\n-  protected synchronized void setupQueueConfigs(\n-      Resource clusterResource,\n-      float capacity, float absoluteCapacity, \n-      float maximumCapacity, float absoluteMaxCapacity,\n-      int userLimit, float userLimitFactor,\n-      int maxApplications, float maxAMResourcePerQueuePercent,\n-      int maxApplicationsPerUser, QueueState state,\n-      Map\u003cAccessType, AccessControlList\u003e acls, int nodeLocalityDelay,\n-      Set\u003cString\u003e labels, String defaultLabelExpression,\n-      Map\u003cString, Float\u003e capacitieByLabel,\n-      Map\u003cString, Float\u003e maximumCapacitiesByLabel, \n-      boolean revervationContinueLooking,\n-      Resource maxAllocation) throws IOException {\n-    super.setupQueueConfigs(clusterResource, capacity, absoluteCapacity,\n-        maximumCapacity, absoluteMaxCapacity, state, acls, labels,\n-        defaultLabelExpression, capacitieByLabel, maximumCapacitiesByLabel,\n-        revervationContinueLooking, maxAllocation);\n-    // Sanity check\n-    CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n-    float absCapacity \u003d getParent().getAbsoluteCapacity() * capacity;\n-    CSQueueUtils.checkAbsoluteCapacity(getQueueName(), absCapacity,\n-        absoluteMaxCapacity);\n+  protected synchronized void setupQueueConfigs(Resource clusterResource)\n+      throws IOException {\n+    super.setupQueueConfigs(clusterResource);\n     \n     this.lastClusterResource \u003d clusterResource;\n     updateAbsoluteCapacityResource(clusterResource);\n     \n     // Initialize headroom info, also used for calculating application \n     // master resource limits.  Since this happens during queue initialization\n     // and all queues may not be realized yet, we\u0027ll use (optimistic) \n     // absoluteMaxCapacity (it will be replaced with the more accurate \n     // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n-    updateHeadroomInfo(clusterResource, absoluteMaxCapacity);\n+    updateHeadroomInfo(clusterResource,\n+        queueCapacities.getAbsoluteMaximumCapacity());\n \n-    this.absoluteCapacity \u003d absCapacity;\n+    CapacitySchedulerConfiguration conf \u003d csContext.getConfiguration();\n+    userLimit \u003d conf.getUserLimit(getQueuePath());\n+    userLimitFactor \u003d conf.getUserLimitFactor(getQueuePath());\n \n-    this.userLimit \u003d userLimit;\n-    this.userLimitFactor \u003d userLimitFactor;\n-\n-    this.maxApplications \u003d maxApplications;\n-    this.maxAMResourcePerQueuePercent \u003d maxAMResourcePerQueuePercent;\n-    this.maxApplicationsPerUser \u003d maxApplicationsPerUser;\n+    maxApplications \u003d conf.getMaximumApplicationsPerQueue(getQueuePath());\n+    if (maxApplications \u003c 0) {\n+      int maxSystemApps \u003d conf.getMaximumSystemApplications();\n+      maxApplications \u003d\n+          (int) (maxSystemApps * queueCapacities.getAbsoluteCapacity());\n+    }\n+    maxApplicationsPerUser \u003d \n+      (int)(maxApplications * (userLimit / 100.0f) * userLimitFactor);\n+    \n+    maxAMResourcePerQueuePercent \u003d\n+        conf.getMaximumApplicationMasterResourcePerQueuePercent(getQueuePath());\n \n     if (!SchedulerUtils.checkQueueLabelExpression(this.accessibleLabels,\n         this.defaultLabelExpression)) {\n       throw new IOException(\"Invalid default label expression of \"\n           + \" queue\u003d\"\n           + getQueueName()\n           + \" doesn\u0027t have permission to access all labels \"\n           + \"in default label expression. labelExpression of resource request\u003d\"\n           + (this.defaultLabelExpression \u003d\u003d null ? \"\"\n               : this.defaultLabelExpression)\n           + \". Queue labels\u003d\"\n           + (getAccessibleNodeLabels() \u003d\u003d null ? \"\" : StringUtils.join(\n               getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n     }\n     \n-    this.nodeLocalityDelay \u003d nodeLocalityDelay;\n+    nodeLocalityDelay \u003d conf.getNodeLocalityDelay();\n \n     // re-init this since max allocation could have changed\n     this.minimumAllocationFactor \u003d\n         Resources.ratio(resourceCalculator,\n             Resources.subtract(maximumAllocation, minimumAllocation),\n             maximumAllocation);\n \n     StringBuilder aclsString \u003d new StringBuilder();\n     for (Map.Entry\u003cAccessType, AccessControlList\u003e e : acls.entrySet()) {\n       aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n     }\n \n     StringBuilder labelStrBuilder \u003d new StringBuilder(); \n-    if (labels !\u003d null) {\n-      for (String s : labels) {\n+    if (accessibleLabels !\u003d null) {\n+      for (String s : accessibleLabels) {\n         labelStrBuilder.append(s);\n         labelStrBuilder.append(\",\");\n       }\n     }\n \n     LOG.info(\"Initializing \" + queueName + \"\\n\" +\n-        \"capacity \u003d \" + capacity +\n+        \"capacity \u003d \" + queueCapacities.getCapacity() +\n         \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n-        \"asboluteCapacity \u003d \" + absoluteCapacity +\n+        \"asboluteCapacity \u003d \" + queueCapacities.getAbsoluteCapacity() +\n         \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n-        \"maxCapacity \u003d \" + maximumCapacity +\n+        \"maxCapacity \u003d \" + queueCapacities.getMaximumCapacity() +\n         \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n-        \"absoluteMaxCapacity \u003d \" + absoluteMaxCapacity +\n+        \"absoluteMaxCapacity \u003d \" + queueCapacities.getAbsoluteMaximumCapacity() +\n         \" [\u003d 1.0 maximumCapacity undefined, \" +\n         \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n         \"\\n\" +\n         \"userLimit \u003d \" + userLimit +\n         \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n         \"userLimitFactor \u003d \" + userLimitFactor +\n         \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n         \"maxApplications \u003d \" + maxApplications +\n         \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n         \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n         \"\\n\" +\n         \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n         \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n         \"userLimitFactor) ]\" + \"\\n\" +\n-        \"usedCapacity \u003d \" + usedCapacity +\n+        \"usedCapacity \u003d \" + queueCapacities.getUsedCapacity() +\n         \" [\u003d usedResourcesMemory / \" +\n         \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n         \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n         \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n         \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n         \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n         \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n         \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n         \"maximumAllocationMemory ]\" + \"\\n\" +\n         \"maximumAllocation \u003d \" + maximumAllocation +\n         \" [\u003d configuredMaxAllocation ]\" + \"\\n\" +\n         \"numContainers \u003d \" + numContainers +\n         \" [\u003d currentNumContainers ]\" + \"\\n\" +\n         \"state \u003d \" + state +\n         \" [\u003d configuredState ]\" + \"\\n\" +\n         \"acls \u003d \" + aclsString +\n         \" [\u003d configuredAcls ]\" + \"\\n\" + \n         \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\" +\n         \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\" +\n         \"nodeLocalityDelay \u003d \" +  nodeLocalityDelay + \"\\n\" +\n         \"reservationsContinueLooking \u003d \" +\n         reservationsContinueLooking + \"\\n\" +\n         \"preemptionDisabled \u003d \" + getPreemptionDisabled() + \"\\n\");\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected synchronized void setupQueueConfigs(Resource clusterResource)\n      throws IOException {\n    super.setupQueueConfigs(clusterResource);\n    \n    this.lastClusterResource \u003d clusterResource;\n    updateAbsoluteCapacityResource(clusterResource);\n    \n    // Initialize headroom info, also used for calculating application \n    // master resource limits.  Since this happens during queue initialization\n    // and all queues may not be realized yet, we\u0027ll use (optimistic) \n    // absoluteMaxCapacity (it will be replaced with the more accurate \n    // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n    updateHeadroomInfo(clusterResource,\n        queueCapacities.getAbsoluteMaximumCapacity());\n\n    CapacitySchedulerConfiguration conf \u003d csContext.getConfiguration();\n    userLimit \u003d conf.getUserLimit(getQueuePath());\n    userLimitFactor \u003d conf.getUserLimitFactor(getQueuePath());\n\n    maxApplications \u003d conf.getMaximumApplicationsPerQueue(getQueuePath());\n    if (maxApplications \u003c 0) {\n      int maxSystemApps \u003d conf.getMaximumSystemApplications();\n      maxApplications \u003d\n          (int) (maxSystemApps * queueCapacities.getAbsoluteCapacity());\n    }\n    maxApplicationsPerUser \u003d \n      (int)(maxApplications * (userLimit / 100.0f) * userLimitFactor);\n    \n    maxAMResourcePerQueuePercent \u003d\n        conf.getMaximumApplicationMasterResourcePerQueuePercent(getQueuePath());\n\n    if (!SchedulerUtils.checkQueueLabelExpression(this.accessibleLabels,\n        this.defaultLabelExpression)) {\n      throw new IOException(\"Invalid default label expression of \"\n          + \" queue\u003d\"\n          + getQueueName()\n          + \" doesn\u0027t have permission to access all labels \"\n          + \"in default label expression. labelExpression of resource request\u003d\"\n          + (this.defaultLabelExpression \u003d\u003d null ? \"\"\n              : this.defaultLabelExpression)\n          + \". Queue labels\u003d\"\n          + (getAccessibleNodeLabels() \u003d\u003d null ? \"\" : StringUtils.join(\n              getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n    }\n    \n    nodeLocalityDelay \u003d conf.getNodeLocalityDelay();\n\n    // re-init this since max allocation could have changed\n    this.minimumAllocationFactor \u003d\n        Resources.ratio(resourceCalculator,\n            Resources.subtract(maximumAllocation, minimumAllocation),\n            maximumAllocation);\n\n    StringBuilder aclsString \u003d new StringBuilder();\n    for (Map.Entry\u003cAccessType, AccessControlList\u003e e : acls.entrySet()) {\n      aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n    }\n\n    StringBuilder labelStrBuilder \u003d new StringBuilder(); \n    if (accessibleLabels !\u003d null) {\n      for (String s : accessibleLabels) {\n        labelStrBuilder.append(s);\n        labelStrBuilder.append(\",\");\n      }\n    }\n\n    LOG.info(\"Initializing \" + queueName + \"\\n\" +\n        \"capacity \u003d \" + queueCapacities.getCapacity() +\n        \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n        \"asboluteCapacity \u003d \" + queueCapacities.getAbsoluteCapacity() +\n        \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n        \"maxCapacity \u003d \" + queueCapacities.getMaximumCapacity() +\n        \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n        \"absoluteMaxCapacity \u003d \" + queueCapacities.getAbsoluteMaximumCapacity() +\n        \" [\u003d 1.0 maximumCapacity undefined, \" +\n        \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n        \"\\n\" +\n        \"userLimit \u003d \" + userLimit +\n        \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n        \"userLimitFactor \u003d \" + userLimitFactor +\n        \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n        \"maxApplications \u003d \" + maxApplications +\n        \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n        \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n        \"\\n\" +\n        \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n        \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n        \"userLimitFactor) ]\" + \"\\n\" +\n        \"usedCapacity \u003d \" + queueCapacities.getUsedCapacity() +\n        \" [\u003d usedResourcesMemory / \" +\n        \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n        \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n        \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n        \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n        \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n        \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n        \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n        \"maximumAllocationMemory ]\" + \"\\n\" +\n        \"maximumAllocation \u003d \" + maximumAllocation +\n        \" [\u003d configuredMaxAllocation ]\" + \"\\n\" +\n        \"numContainers \u003d \" + numContainers +\n        \" [\u003d currentNumContainers ]\" + \"\\n\" +\n        \"state \u003d \" + state +\n        \" [\u003d configuredState ]\" + \"\\n\" +\n        \"acls \u003d \" + aclsString +\n        \" [\u003d configuredAcls ]\" + \"\\n\" + \n        \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\" +\n        \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\" +\n        \"nodeLocalityDelay \u003d \" +  nodeLocalityDelay + \"\\n\" +\n        \"reservationsContinueLooking \u003d \" +\n        reservationsContinueLooking + \"\\n\" +\n        \"preemptionDisabled \u003d \" + getPreemptionDisabled() + \"\\n\");\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {}
        }
      ]
    },
    "23bf6c72071782e3fd5a628e21495d6b974c7a9e": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-3100. Made YARN authorization pluggable. Contributed by Jian He.\n",
      "commitDate": "09/02/15 8:34 PM",
      "commitName": "23bf6c72071782e3fd5a628e21495d6b974c7a9e",
      "commitAuthor": "Zhijie Shen",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-3100. Made YARN authorization pluggable. Contributed by Jian He.\n",
          "commitDate": "09/02/15 8:34 PM",
          "commitName": "23bf6c72071782e3fd5a628e21495d6b974c7a9e",
          "commitAuthor": "Zhijie Shen",
          "commitDateOld": "05/02/15 11:28 AM",
          "commitNameOld": "69c8a7f45be5c0aa6787b07f328d74f1e2ba5628",
          "commitAuthorOld": "Jason Lowe",
          "daysBetweenCommits": 4.38,
          "commitsBetweenForRepo": 39,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,124 +1,124 @@\n   protected synchronized void setupQueueConfigs(\n       Resource clusterResource,\n       float capacity, float absoluteCapacity, \n       float maximumCapacity, float absoluteMaxCapacity,\n       int userLimit, float userLimitFactor,\n       int maxApplications, float maxAMResourcePerQueuePercent,\n       int maxApplicationsPerUser, QueueState state,\n-      Map\u003cQueueACL, AccessControlList\u003e acls, int nodeLocalityDelay,\n+      Map\u003cAccessType, AccessControlList\u003e acls, int nodeLocalityDelay,\n       Set\u003cString\u003e labels, String defaultLabelExpression,\n       Map\u003cString, Float\u003e capacitieByLabel,\n       Map\u003cString, Float\u003e maximumCapacitiesByLabel, \n       boolean revervationContinueLooking,\n       Resource maxAllocation) throws IOException {\n     super.setupQueueConfigs(clusterResource, capacity, absoluteCapacity,\n         maximumCapacity, absoluteMaxCapacity, state, acls, labels,\n         defaultLabelExpression, capacitieByLabel, maximumCapacitiesByLabel,\n         revervationContinueLooking, maxAllocation);\n     // Sanity check\n     CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n     float absCapacity \u003d getParent().getAbsoluteCapacity() * capacity;\n     CSQueueUtils.checkAbsoluteCapacity(getQueueName(), absCapacity,\n         absoluteMaxCapacity);\n     \n     this.lastClusterResource \u003d clusterResource;\n     updateAbsoluteCapacityResource(clusterResource);\n     \n     // Initialize headroom info, also used for calculating application \n     // master resource limits.  Since this happens during queue initialization\n     // and all queues may not be realized yet, we\u0027ll use (optimistic) \n     // absoluteMaxCapacity (it will be replaced with the more accurate \n     // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n     updateHeadroomInfo(clusterResource, absoluteMaxCapacity);\n \n     this.absoluteCapacity \u003d absCapacity;\n \n     this.userLimit \u003d userLimit;\n     this.userLimitFactor \u003d userLimitFactor;\n \n     this.maxApplications \u003d maxApplications;\n     this.maxAMResourcePerQueuePercent \u003d maxAMResourcePerQueuePercent;\n     this.maxApplicationsPerUser \u003d maxApplicationsPerUser;\n \n     if (!SchedulerUtils.checkQueueLabelExpression(this.accessibleLabels,\n         this.defaultLabelExpression)) {\n       throw new IOException(\"Invalid default label expression of \"\n           + \" queue\u003d\"\n           + getQueueName()\n           + \" doesn\u0027t have permission to access all labels \"\n           + \"in default label expression. labelExpression of resource request\u003d\"\n           + (this.defaultLabelExpression \u003d\u003d null ? \"\"\n               : this.defaultLabelExpression)\n           + \". Queue labels\u003d\"\n           + (getAccessibleNodeLabels() \u003d\u003d null ? \"\" : StringUtils.join(\n               getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n     }\n     \n     this.nodeLocalityDelay \u003d nodeLocalityDelay;\n \n     // re-init this since max allocation could have changed\n     this.minimumAllocationFactor \u003d\n         Resources.ratio(resourceCalculator,\n             Resources.subtract(maximumAllocation, minimumAllocation),\n             maximumAllocation);\n \n     StringBuilder aclsString \u003d new StringBuilder();\n-    for (Map.Entry\u003cQueueACL, AccessControlList\u003e e : acls.entrySet()) {\n+    for (Map.Entry\u003cAccessType, AccessControlList\u003e e : acls.entrySet()) {\n       aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n     }\n \n     StringBuilder labelStrBuilder \u003d new StringBuilder(); \n     if (labels !\u003d null) {\n       for (String s : labels) {\n         labelStrBuilder.append(s);\n         labelStrBuilder.append(\",\");\n       }\n     }\n \n     LOG.info(\"Initializing \" + queueName + \"\\n\" +\n         \"capacity \u003d \" + capacity +\n         \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n         \"asboluteCapacity \u003d \" + absoluteCapacity +\n         \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n         \"maxCapacity \u003d \" + maximumCapacity +\n         \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n         \"absoluteMaxCapacity \u003d \" + absoluteMaxCapacity +\n         \" [\u003d 1.0 maximumCapacity undefined, \" +\n         \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n         \"\\n\" +\n         \"userLimit \u003d \" + userLimit +\n         \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n         \"userLimitFactor \u003d \" + userLimitFactor +\n         \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n         \"maxApplications \u003d \" + maxApplications +\n         \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n         \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n         \"\\n\" +\n         \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n         \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n         \"userLimitFactor) ]\" + \"\\n\" +\n         \"usedCapacity \u003d \" + usedCapacity +\n         \" [\u003d usedResourcesMemory / \" +\n         \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n         \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n         \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n         \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n         \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n         \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n         \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n         \"maximumAllocationMemory ]\" + \"\\n\" +\n         \"maximumAllocation \u003d \" + maximumAllocation +\n         \" [\u003d configuredMaxAllocation ]\" + \"\\n\" +\n         \"numContainers \u003d \" + numContainers +\n         \" [\u003d currentNumContainers ]\" + \"\\n\" +\n         \"state \u003d \" + state +\n         \" [\u003d configuredState ]\" + \"\\n\" +\n         \"acls \u003d \" + aclsString +\n         \" [\u003d configuredAcls ]\" + \"\\n\" + \n         \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\" +\n         \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\" +\n         \"nodeLocalityDelay \u003d \" +  nodeLocalityDelay + \"\\n\" +\n         \"reservationsContinueLooking \u003d \" +\n         reservationsContinueLooking + \"\\n\" +\n         \"preemptionDisabled \u003d \" + getPreemptionDisabled() + \"\\n\");\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected synchronized void setupQueueConfigs(\n      Resource clusterResource,\n      float capacity, float absoluteCapacity, \n      float maximumCapacity, float absoluteMaxCapacity,\n      int userLimit, float userLimitFactor,\n      int maxApplications, float maxAMResourcePerQueuePercent,\n      int maxApplicationsPerUser, QueueState state,\n      Map\u003cAccessType, AccessControlList\u003e acls, int nodeLocalityDelay,\n      Set\u003cString\u003e labels, String defaultLabelExpression,\n      Map\u003cString, Float\u003e capacitieByLabel,\n      Map\u003cString, Float\u003e maximumCapacitiesByLabel, \n      boolean revervationContinueLooking,\n      Resource maxAllocation) throws IOException {\n    super.setupQueueConfigs(clusterResource, capacity, absoluteCapacity,\n        maximumCapacity, absoluteMaxCapacity, state, acls, labels,\n        defaultLabelExpression, capacitieByLabel, maximumCapacitiesByLabel,\n        revervationContinueLooking, maxAllocation);\n    // Sanity check\n    CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n    float absCapacity \u003d getParent().getAbsoluteCapacity() * capacity;\n    CSQueueUtils.checkAbsoluteCapacity(getQueueName(), absCapacity,\n        absoluteMaxCapacity);\n    \n    this.lastClusterResource \u003d clusterResource;\n    updateAbsoluteCapacityResource(clusterResource);\n    \n    // Initialize headroom info, also used for calculating application \n    // master resource limits.  Since this happens during queue initialization\n    // and all queues may not be realized yet, we\u0027ll use (optimistic) \n    // absoluteMaxCapacity (it will be replaced with the more accurate \n    // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n    updateHeadroomInfo(clusterResource, absoluteMaxCapacity);\n\n    this.absoluteCapacity \u003d absCapacity;\n\n    this.userLimit \u003d userLimit;\n    this.userLimitFactor \u003d userLimitFactor;\n\n    this.maxApplications \u003d maxApplications;\n    this.maxAMResourcePerQueuePercent \u003d maxAMResourcePerQueuePercent;\n    this.maxApplicationsPerUser \u003d maxApplicationsPerUser;\n\n    if (!SchedulerUtils.checkQueueLabelExpression(this.accessibleLabels,\n        this.defaultLabelExpression)) {\n      throw new IOException(\"Invalid default label expression of \"\n          + \" queue\u003d\"\n          + getQueueName()\n          + \" doesn\u0027t have permission to access all labels \"\n          + \"in default label expression. labelExpression of resource request\u003d\"\n          + (this.defaultLabelExpression \u003d\u003d null ? \"\"\n              : this.defaultLabelExpression)\n          + \". Queue labels\u003d\"\n          + (getAccessibleNodeLabels() \u003d\u003d null ? \"\" : StringUtils.join(\n              getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n    }\n    \n    this.nodeLocalityDelay \u003d nodeLocalityDelay;\n\n    // re-init this since max allocation could have changed\n    this.minimumAllocationFactor \u003d\n        Resources.ratio(resourceCalculator,\n            Resources.subtract(maximumAllocation, minimumAllocation),\n            maximumAllocation);\n\n    StringBuilder aclsString \u003d new StringBuilder();\n    for (Map.Entry\u003cAccessType, AccessControlList\u003e e : acls.entrySet()) {\n      aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n    }\n\n    StringBuilder labelStrBuilder \u003d new StringBuilder(); \n    if (labels !\u003d null) {\n      for (String s : labels) {\n        labelStrBuilder.append(s);\n        labelStrBuilder.append(\",\");\n      }\n    }\n\n    LOG.info(\"Initializing \" + queueName + \"\\n\" +\n        \"capacity \u003d \" + capacity +\n        \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n        \"asboluteCapacity \u003d \" + absoluteCapacity +\n        \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n        \"maxCapacity \u003d \" + maximumCapacity +\n        \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n        \"absoluteMaxCapacity \u003d \" + absoluteMaxCapacity +\n        \" [\u003d 1.0 maximumCapacity undefined, \" +\n        \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n        \"\\n\" +\n        \"userLimit \u003d \" + userLimit +\n        \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n        \"userLimitFactor \u003d \" + userLimitFactor +\n        \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n        \"maxApplications \u003d \" + maxApplications +\n        \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n        \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n        \"\\n\" +\n        \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n        \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n        \"userLimitFactor) ]\" + \"\\n\" +\n        \"usedCapacity \u003d \" + usedCapacity +\n        \" [\u003d usedResourcesMemory / \" +\n        \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n        \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n        \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n        \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n        \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n        \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n        \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n        \"maximumAllocationMemory ]\" + \"\\n\" +\n        \"maximumAllocation \u003d \" + maximumAllocation +\n        \" [\u003d configuredMaxAllocation ]\" + \"\\n\" +\n        \"numContainers \u003d \" + numContainers +\n        \" [\u003d currentNumContainers ]\" + \"\\n\" +\n        \"state \u003d \" + state +\n        \" [\u003d configuredState ]\" + \"\\n\" +\n        \"acls \u003d \" + aclsString +\n        \" [\u003d configuredAcls ]\" + \"\\n\" + \n        \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\" +\n        \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\" +\n        \"nodeLocalityDelay \u003d \" +  nodeLocalityDelay + \"\\n\" +\n        \"reservationsContinueLooking \u003d \" +\n        reservationsContinueLooking + \"\\n\" +\n        \"preemptionDisabled \u003d \" + getPreemptionDisabled() + \"\\n\");\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {
            "oldValue": "[clusterResource-Resource, capacity-float, absoluteCapacity-float, maximumCapacity-float, absoluteMaxCapacity-float, userLimit-int, userLimitFactor-float, maxApplications-int, maxAMResourcePerQueuePercent-float, maxApplicationsPerUser-int, state-QueueState, acls-Map\u003cQueueACL,AccessControlList\u003e, nodeLocalityDelay-int, labels-Set\u003cString\u003e, defaultLabelExpression-String, capacitieByLabel-Map\u003cString,Float\u003e, maximumCapacitiesByLabel-Map\u003cString,Float\u003e, revervationContinueLooking-boolean, maxAllocation-Resource]",
            "newValue": "[clusterResource-Resource, capacity-float, absoluteCapacity-float, maximumCapacity-float, absoluteMaxCapacity-float, userLimit-int, userLimitFactor-float, maxApplications-int, maxAMResourcePerQueuePercent-float, maxApplicationsPerUser-int, state-QueueState, acls-Map\u003cAccessType,AccessControlList\u003e, nodeLocalityDelay-int, labels-Set\u003cString\u003e, defaultLabelExpression-String, capacitieByLabel-Map\u003cString,Float\u003e, maximumCapacitiesByLabel-Map\u003cString,Float\u003e, revervationContinueLooking-boolean, maxAllocation-Resource]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-3100. Made YARN authorization pluggable. Contributed by Jian He.\n",
          "commitDate": "09/02/15 8:34 PM",
          "commitName": "23bf6c72071782e3fd5a628e21495d6b974c7a9e",
          "commitAuthor": "Zhijie Shen",
          "commitDateOld": "05/02/15 11:28 AM",
          "commitNameOld": "69c8a7f45be5c0aa6787b07f328d74f1e2ba5628",
          "commitAuthorOld": "Jason Lowe",
          "daysBetweenCommits": 4.38,
          "commitsBetweenForRepo": 39,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,124 +1,124 @@\n   protected synchronized void setupQueueConfigs(\n       Resource clusterResource,\n       float capacity, float absoluteCapacity, \n       float maximumCapacity, float absoluteMaxCapacity,\n       int userLimit, float userLimitFactor,\n       int maxApplications, float maxAMResourcePerQueuePercent,\n       int maxApplicationsPerUser, QueueState state,\n-      Map\u003cQueueACL, AccessControlList\u003e acls, int nodeLocalityDelay,\n+      Map\u003cAccessType, AccessControlList\u003e acls, int nodeLocalityDelay,\n       Set\u003cString\u003e labels, String defaultLabelExpression,\n       Map\u003cString, Float\u003e capacitieByLabel,\n       Map\u003cString, Float\u003e maximumCapacitiesByLabel, \n       boolean revervationContinueLooking,\n       Resource maxAllocation) throws IOException {\n     super.setupQueueConfigs(clusterResource, capacity, absoluteCapacity,\n         maximumCapacity, absoluteMaxCapacity, state, acls, labels,\n         defaultLabelExpression, capacitieByLabel, maximumCapacitiesByLabel,\n         revervationContinueLooking, maxAllocation);\n     // Sanity check\n     CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n     float absCapacity \u003d getParent().getAbsoluteCapacity() * capacity;\n     CSQueueUtils.checkAbsoluteCapacity(getQueueName(), absCapacity,\n         absoluteMaxCapacity);\n     \n     this.lastClusterResource \u003d clusterResource;\n     updateAbsoluteCapacityResource(clusterResource);\n     \n     // Initialize headroom info, also used for calculating application \n     // master resource limits.  Since this happens during queue initialization\n     // and all queues may not be realized yet, we\u0027ll use (optimistic) \n     // absoluteMaxCapacity (it will be replaced with the more accurate \n     // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n     updateHeadroomInfo(clusterResource, absoluteMaxCapacity);\n \n     this.absoluteCapacity \u003d absCapacity;\n \n     this.userLimit \u003d userLimit;\n     this.userLimitFactor \u003d userLimitFactor;\n \n     this.maxApplications \u003d maxApplications;\n     this.maxAMResourcePerQueuePercent \u003d maxAMResourcePerQueuePercent;\n     this.maxApplicationsPerUser \u003d maxApplicationsPerUser;\n \n     if (!SchedulerUtils.checkQueueLabelExpression(this.accessibleLabels,\n         this.defaultLabelExpression)) {\n       throw new IOException(\"Invalid default label expression of \"\n           + \" queue\u003d\"\n           + getQueueName()\n           + \" doesn\u0027t have permission to access all labels \"\n           + \"in default label expression. labelExpression of resource request\u003d\"\n           + (this.defaultLabelExpression \u003d\u003d null ? \"\"\n               : this.defaultLabelExpression)\n           + \". Queue labels\u003d\"\n           + (getAccessibleNodeLabels() \u003d\u003d null ? \"\" : StringUtils.join(\n               getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n     }\n     \n     this.nodeLocalityDelay \u003d nodeLocalityDelay;\n \n     // re-init this since max allocation could have changed\n     this.minimumAllocationFactor \u003d\n         Resources.ratio(resourceCalculator,\n             Resources.subtract(maximumAllocation, minimumAllocation),\n             maximumAllocation);\n \n     StringBuilder aclsString \u003d new StringBuilder();\n-    for (Map.Entry\u003cQueueACL, AccessControlList\u003e e : acls.entrySet()) {\n+    for (Map.Entry\u003cAccessType, AccessControlList\u003e e : acls.entrySet()) {\n       aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n     }\n \n     StringBuilder labelStrBuilder \u003d new StringBuilder(); \n     if (labels !\u003d null) {\n       for (String s : labels) {\n         labelStrBuilder.append(s);\n         labelStrBuilder.append(\",\");\n       }\n     }\n \n     LOG.info(\"Initializing \" + queueName + \"\\n\" +\n         \"capacity \u003d \" + capacity +\n         \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n         \"asboluteCapacity \u003d \" + absoluteCapacity +\n         \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n         \"maxCapacity \u003d \" + maximumCapacity +\n         \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n         \"absoluteMaxCapacity \u003d \" + absoluteMaxCapacity +\n         \" [\u003d 1.0 maximumCapacity undefined, \" +\n         \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n         \"\\n\" +\n         \"userLimit \u003d \" + userLimit +\n         \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n         \"userLimitFactor \u003d \" + userLimitFactor +\n         \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n         \"maxApplications \u003d \" + maxApplications +\n         \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n         \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n         \"\\n\" +\n         \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n         \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n         \"userLimitFactor) ]\" + \"\\n\" +\n         \"usedCapacity \u003d \" + usedCapacity +\n         \" [\u003d usedResourcesMemory / \" +\n         \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n         \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n         \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n         \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n         \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n         \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n         \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n         \"maximumAllocationMemory ]\" + \"\\n\" +\n         \"maximumAllocation \u003d \" + maximumAllocation +\n         \" [\u003d configuredMaxAllocation ]\" + \"\\n\" +\n         \"numContainers \u003d \" + numContainers +\n         \" [\u003d currentNumContainers ]\" + \"\\n\" +\n         \"state \u003d \" + state +\n         \" [\u003d configuredState ]\" + \"\\n\" +\n         \"acls \u003d \" + aclsString +\n         \" [\u003d configuredAcls ]\" + \"\\n\" + \n         \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\" +\n         \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\" +\n         \"nodeLocalityDelay \u003d \" +  nodeLocalityDelay + \"\\n\" +\n         \"reservationsContinueLooking \u003d \" +\n         reservationsContinueLooking + \"\\n\" +\n         \"preemptionDisabled \u003d \" + getPreemptionDisabled() + \"\\n\");\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected synchronized void setupQueueConfigs(\n      Resource clusterResource,\n      float capacity, float absoluteCapacity, \n      float maximumCapacity, float absoluteMaxCapacity,\n      int userLimit, float userLimitFactor,\n      int maxApplications, float maxAMResourcePerQueuePercent,\n      int maxApplicationsPerUser, QueueState state,\n      Map\u003cAccessType, AccessControlList\u003e acls, int nodeLocalityDelay,\n      Set\u003cString\u003e labels, String defaultLabelExpression,\n      Map\u003cString, Float\u003e capacitieByLabel,\n      Map\u003cString, Float\u003e maximumCapacitiesByLabel, \n      boolean revervationContinueLooking,\n      Resource maxAllocation) throws IOException {\n    super.setupQueueConfigs(clusterResource, capacity, absoluteCapacity,\n        maximumCapacity, absoluteMaxCapacity, state, acls, labels,\n        defaultLabelExpression, capacitieByLabel, maximumCapacitiesByLabel,\n        revervationContinueLooking, maxAllocation);\n    // Sanity check\n    CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n    float absCapacity \u003d getParent().getAbsoluteCapacity() * capacity;\n    CSQueueUtils.checkAbsoluteCapacity(getQueueName(), absCapacity,\n        absoluteMaxCapacity);\n    \n    this.lastClusterResource \u003d clusterResource;\n    updateAbsoluteCapacityResource(clusterResource);\n    \n    // Initialize headroom info, also used for calculating application \n    // master resource limits.  Since this happens during queue initialization\n    // and all queues may not be realized yet, we\u0027ll use (optimistic) \n    // absoluteMaxCapacity (it will be replaced with the more accurate \n    // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n    updateHeadroomInfo(clusterResource, absoluteMaxCapacity);\n\n    this.absoluteCapacity \u003d absCapacity;\n\n    this.userLimit \u003d userLimit;\n    this.userLimitFactor \u003d userLimitFactor;\n\n    this.maxApplications \u003d maxApplications;\n    this.maxAMResourcePerQueuePercent \u003d maxAMResourcePerQueuePercent;\n    this.maxApplicationsPerUser \u003d maxApplicationsPerUser;\n\n    if (!SchedulerUtils.checkQueueLabelExpression(this.accessibleLabels,\n        this.defaultLabelExpression)) {\n      throw new IOException(\"Invalid default label expression of \"\n          + \" queue\u003d\"\n          + getQueueName()\n          + \" doesn\u0027t have permission to access all labels \"\n          + \"in default label expression. labelExpression of resource request\u003d\"\n          + (this.defaultLabelExpression \u003d\u003d null ? \"\"\n              : this.defaultLabelExpression)\n          + \". Queue labels\u003d\"\n          + (getAccessibleNodeLabels() \u003d\u003d null ? \"\" : StringUtils.join(\n              getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n    }\n    \n    this.nodeLocalityDelay \u003d nodeLocalityDelay;\n\n    // re-init this since max allocation could have changed\n    this.minimumAllocationFactor \u003d\n        Resources.ratio(resourceCalculator,\n            Resources.subtract(maximumAllocation, minimumAllocation),\n            maximumAllocation);\n\n    StringBuilder aclsString \u003d new StringBuilder();\n    for (Map.Entry\u003cAccessType, AccessControlList\u003e e : acls.entrySet()) {\n      aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n    }\n\n    StringBuilder labelStrBuilder \u003d new StringBuilder(); \n    if (labels !\u003d null) {\n      for (String s : labels) {\n        labelStrBuilder.append(s);\n        labelStrBuilder.append(\",\");\n      }\n    }\n\n    LOG.info(\"Initializing \" + queueName + \"\\n\" +\n        \"capacity \u003d \" + capacity +\n        \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n        \"asboluteCapacity \u003d \" + absoluteCapacity +\n        \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n        \"maxCapacity \u003d \" + maximumCapacity +\n        \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n        \"absoluteMaxCapacity \u003d \" + absoluteMaxCapacity +\n        \" [\u003d 1.0 maximumCapacity undefined, \" +\n        \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n        \"\\n\" +\n        \"userLimit \u003d \" + userLimit +\n        \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n        \"userLimitFactor \u003d \" + userLimitFactor +\n        \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n        \"maxApplications \u003d \" + maxApplications +\n        \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n        \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n        \"\\n\" +\n        \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n        \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n        \"userLimitFactor) ]\" + \"\\n\" +\n        \"usedCapacity \u003d \" + usedCapacity +\n        \" [\u003d usedResourcesMemory / \" +\n        \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n        \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n        \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n        \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n        \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n        \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n        \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n        \"maximumAllocationMemory ]\" + \"\\n\" +\n        \"maximumAllocation \u003d \" + maximumAllocation +\n        \" [\u003d configuredMaxAllocation ]\" + \"\\n\" +\n        \"numContainers \u003d \" + numContainers +\n        \" [\u003d currentNumContainers ]\" + \"\\n\" +\n        \"state \u003d \" + state +\n        \" [\u003d configuredState ]\" + \"\\n\" +\n        \"acls \u003d \" + aclsString +\n        \" [\u003d configuredAcls ]\" + \"\\n\" + \n        \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\" +\n        \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\" +\n        \"nodeLocalityDelay \u003d \" +  nodeLocalityDelay + \"\\n\" +\n        \"reservationsContinueLooking \u003d \" +\n        reservationsContinueLooking + \"\\n\" +\n        \"preemptionDisabled \u003d \" + getPreemptionDisabled() + \"\\n\");\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {}
        }
      ]
    },
    "69c8a7f45be5c0aa6787b07f328d74f1e2ba5628": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-1582. Capacity Scheduler: add a maximum-allocation-mb setting per queue. Contributed by Thomas Graves\n",
      "commitDate": "05/02/15 11:28 AM",
      "commitName": "69c8a7f45be5c0aa6787b07f328d74f1e2ba5628",
      "commitAuthor": "Jason Lowe",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-1582. Capacity Scheduler: add a maximum-allocation-mb setting per queue. Contributed by Thomas Graves\n",
          "commitDate": "05/02/15 11:28 AM",
          "commitName": "69c8a7f45be5c0aa6787b07f328d74f1e2ba5628",
          "commitAuthor": "Jason Lowe",
          "commitDateOld": "30/01/15 3:15 PM",
          "commitNameOld": "86358221fc85a7743052a0b4c1647353508bf308",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 5.84,
          "commitsBetweenForRepo": 56,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,115 +1,124 @@\n   protected synchronized void setupQueueConfigs(\n       Resource clusterResource,\n       float capacity, float absoluteCapacity, \n       float maximumCapacity, float absoluteMaxCapacity,\n       int userLimit, float userLimitFactor,\n       int maxApplications, float maxAMResourcePerQueuePercent,\n       int maxApplicationsPerUser, QueueState state,\n       Map\u003cQueueACL, AccessControlList\u003e acls, int nodeLocalityDelay,\n       Set\u003cString\u003e labels, String defaultLabelExpression,\n       Map\u003cString, Float\u003e capacitieByLabel,\n       Map\u003cString, Float\u003e maximumCapacitiesByLabel, \n-      boolean revervationContinueLooking) throws IOException {\n+      boolean revervationContinueLooking,\n+      Resource maxAllocation) throws IOException {\n     super.setupQueueConfigs(clusterResource, capacity, absoluteCapacity,\n         maximumCapacity, absoluteMaxCapacity, state, acls, labels,\n         defaultLabelExpression, capacitieByLabel, maximumCapacitiesByLabel,\n-        revervationContinueLooking);\n+        revervationContinueLooking, maxAllocation);\n     // Sanity check\n     CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n     float absCapacity \u003d getParent().getAbsoluteCapacity() * capacity;\n     CSQueueUtils.checkAbsoluteCapacity(getQueueName(), absCapacity,\n         absoluteMaxCapacity);\n     \n     this.lastClusterResource \u003d clusterResource;\n     updateAbsoluteCapacityResource(clusterResource);\n     \n     // Initialize headroom info, also used for calculating application \n     // master resource limits.  Since this happens during queue initialization\n     // and all queues may not be realized yet, we\u0027ll use (optimistic) \n     // absoluteMaxCapacity (it will be replaced with the more accurate \n     // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n     updateHeadroomInfo(clusterResource, absoluteMaxCapacity);\n \n     this.absoluteCapacity \u003d absCapacity;\n \n     this.userLimit \u003d userLimit;\n     this.userLimitFactor \u003d userLimitFactor;\n \n     this.maxApplications \u003d maxApplications;\n     this.maxAMResourcePerQueuePercent \u003d maxAMResourcePerQueuePercent;\n     this.maxApplicationsPerUser \u003d maxApplicationsPerUser;\n \n     if (!SchedulerUtils.checkQueueLabelExpression(this.accessibleLabels,\n         this.defaultLabelExpression)) {\n       throw new IOException(\"Invalid default label expression of \"\n           + \" queue\u003d\"\n           + getQueueName()\n           + \" doesn\u0027t have permission to access all labels \"\n           + \"in default label expression. labelExpression of resource request\u003d\"\n           + (this.defaultLabelExpression \u003d\u003d null ? \"\"\n               : this.defaultLabelExpression)\n           + \". Queue labels\u003d\"\n           + (getAccessibleNodeLabels() \u003d\u003d null ? \"\" : StringUtils.join(\n               getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n     }\n     \n     this.nodeLocalityDelay \u003d nodeLocalityDelay;\n \n+    // re-init this since max allocation could have changed\n+    this.minimumAllocationFactor \u003d\n+        Resources.ratio(resourceCalculator,\n+            Resources.subtract(maximumAllocation, minimumAllocation),\n+            maximumAllocation);\n+\n     StringBuilder aclsString \u003d new StringBuilder();\n     for (Map.Entry\u003cQueueACL, AccessControlList\u003e e : acls.entrySet()) {\n       aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n     }\n \n     StringBuilder labelStrBuilder \u003d new StringBuilder(); \n     if (labels !\u003d null) {\n       for (String s : labels) {\n         labelStrBuilder.append(s);\n         labelStrBuilder.append(\",\");\n       }\n     }\n \n     LOG.info(\"Initializing \" + queueName + \"\\n\" +\n         \"capacity \u003d \" + capacity +\n         \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n         \"asboluteCapacity \u003d \" + absoluteCapacity +\n         \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n         \"maxCapacity \u003d \" + maximumCapacity +\n         \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n         \"absoluteMaxCapacity \u003d \" + absoluteMaxCapacity +\n         \" [\u003d 1.0 maximumCapacity undefined, \" +\n         \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n         \"\\n\" +\n         \"userLimit \u003d \" + userLimit +\n         \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n         \"userLimitFactor \u003d \" + userLimitFactor +\n         \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n         \"maxApplications \u003d \" + maxApplications +\n         \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n         \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n         \"\\n\" +\n         \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n         \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n         \"userLimitFactor) ]\" + \"\\n\" +\n         \"usedCapacity \u003d \" + usedCapacity +\n         \" [\u003d usedResourcesMemory / \" +\n         \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n         \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n         \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n         \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n         \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n         \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n         \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n         \"maximumAllocationMemory ]\" + \"\\n\" +\n+        \"maximumAllocation \u003d \" + maximumAllocation +\n+        \" [\u003d configuredMaxAllocation ]\" + \"\\n\" +\n         \"numContainers \u003d \" + numContainers +\n         \" [\u003d currentNumContainers ]\" + \"\\n\" +\n         \"state \u003d \" + state +\n         \" [\u003d configuredState ]\" + \"\\n\" +\n         \"acls \u003d \" + aclsString +\n         \" [\u003d configuredAcls ]\" + \"\\n\" + \n         \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\" +\n         \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\" +\n         \"nodeLocalityDelay \u003d \" +  nodeLocalityDelay + \"\\n\" +\n         \"reservationsContinueLooking \u003d \" +\n         reservationsContinueLooking + \"\\n\" +\n         \"preemptionDisabled \u003d \" + getPreemptionDisabled() + \"\\n\");\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected synchronized void setupQueueConfigs(\n      Resource clusterResource,\n      float capacity, float absoluteCapacity, \n      float maximumCapacity, float absoluteMaxCapacity,\n      int userLimit, float userLimitFactor,\n      int maxApplications, float maxAMResourcePerQueuePercent,\n      int maxApplicationsPerUser, QueueState state,\n      Map\u003cQueueACL, AccessControlList\u003e acls, int nodeLocalityDelay,\n      Set\u003cString\u003e labels, String defaultLabelExpression,\n      Map\u003cString, Float\u003e capacitieByLabel,\n      Map\u003cString, Float\u003e maximumCapacitiesByLabel, \n      boolean revervationContinueLooking,\n      Resource maxAllocation) throws IOException {\n    super.setupQueueConfigs(clusterResource, capacity, absoluteCapacity,\n        maximumCapacity, absoluteMaxCapacity, state, acls, labels,\n        defaultLabelExpression, capacitieByLabel, maximumCapacitiesByLabel,\n        revervationContinueLooking, maxAllocation);\n    // Sanity check\n    CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n    float absCapacity \u003d getParent().getAbsoluteCapacity() * capacity;\n    CSQueueUtils.checkAbsoluteCapacity(getQueueName(), absCapacity,\n        absoluteMaxCapacity);\n    \n    this.lastClusterResource \u003d clusterResource;\n    updateAbsoluteCapacityResource(clusterResource);\n    \n    // Initialize headroom info, also used for calculating application \n    // master resource limits.  Since this happens during queue initialization\n    // and all queues may not be realized yet, we\u0027ll use (optimistic) \n    // absoluteMaxCapacity (it will be replaced with the more accurate \n    // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n    updateHeadroomInfo(clusterResource, absoluteMaxCapacity);\n\n    this.absoluteCapacity \u003d absCapacity;\n\n    this.userLimit \u003d userLimit;\n    this.userLimitFactor \u003d userLimitFactor;\n\n    this.maxApplications \u003d maxApplications;\n    this.maxAMResourcePerQueuePercent \u003d maxAMResourcePerQueuePercent;\n    this.maxApplicationsPerUser \u003d maxApplicationsPerUser;\n\n    if (!SchedulerUtils.checkQueueLabelExpression(this.accessibleLabels,\n        this.defaultLabelExpression)) {\n      throw new IOException(\"Invalid default label expression of \"\n          + \" queue\u003d\"\n          + getQueueName()\n          + \" doesn\u0027t have permission to access all labels \"\n          + \"in default label expression. labelExpression of resource request\u003d\"\n          + (this.defaultLabelExpression \u003d\u003d null ? \"\"\n              : this.defaultLabelExpression)\n          + \". Queue labels\u003d\"\n          + (getAccessibleNodeLabels() \u003d\u003d null ? \"\" : StringUtils.join(\n              getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n    }\n    \n    this.nodeLocalityDelay \u003d nodeLocalityDelay;\n\n    // re-init this since max allocation could have changed\n    this.minimumAllocationFactor \u003d\n        Resources.ratio(resourceCalculator,\n            Resources.subtract(maximumAllocation, minimumAllocation),\n            maximumAllocation);\n\n    StringBuilder aclsString \u003d new StringBuilder();\n    for (Map.Entry\u003cQueueACL, AccessControlList\u003e e : acls.entrySet()) {\n      aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n    }\n\n    StringBuilder labelStrBuilder \u003d new StringBuilder(); \n    if (labels !\u003d null) {\n      for (String s : labels) {\n        labelStrBuilder.append(s);\n        labelStrBuilder.append(\",\");\n      }\n    }\n\n    LOG.info(\"Initializing \" + queueName + \"\\n\" +\n        \"capacity \u003d \" + capacity +\n        \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n        \"asboluteCapacity \u003d \" + absoluteCapacity +\n        \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n        \"maxCapacity \u003d \" + maximumCapacity +\n        \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n        \"absoluteMaxCapacity \u003d \" + absoluteMaxCapacity +\n        \" [\u003d 1.0 maximumCapacity undefined, \" +\n        \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n        \"\\n\" +\n        \"userLimit \u003d \" + userLimit +\n        \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n        \"userLimitFactor \u003d \" + userLimitFactor +\n        \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n        \"maxApplications \u003d \" + maxApplications +\n        \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n        \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n        \"\\n\" +\n        \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n        \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n        \"userLimitFactor) ]\" + \"\\n\" +\n        \"usedCapacity \u003d \" + usedCapacity +\n        \" [\u003d usedResourcesMemory / \" +\n        \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n        \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n        \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n        \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n        \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n        \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n        \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n        \"maximumAllocationMemory ]\" + \"\\n\" +\n        \"maximumAllocation \u003d \" + maximumAllocation +\n        \" [\u003d configuredMaxAllocation ]\" + \"\\n\" +\n        \"numContainers \u003d \" + numContainers +\n        \" [\u003d currentNumContainers ]\" + \"\\n\" +\n        \"state \u003d \" + state +\n        \" [\u003d configuredState ]\" + \"\\n\" +\n        \"acls \u003d \" + aclsString +\n        \" [\u003d configuredAcls ]\" + \"\\n\" + \n        \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\" +\n        \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\" +\n        \"nodeLocalityDelay \u003d \" +  nodeLocalityDelay + \"\\n\" +\n        \"reservationsContinueLooking \u003d \" +\n        reservationsContinueLooking + \"\\n\" +\n        \"preemptionDisabled \u003d \" + getPreemptionDisabled() + \"\\n\");\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {
            "oldValue": "[clusterResource-Resource, capacity-float, absoluteCapacity-float, maximumCapacity-float, absoluteMaxCapacity-float, userLimit-int, userLimitFactor-float, maxApplications-int, maxAMResourcePerQueuePercent-float, maxApplicationsPerUser-int, state-QueueState, acls-Map\u003cQueueACL,AccessControlList\u003e, nodeLocalityDelay-int, labels-Set\u003cString\u003e, defaultLabelExpression-String, capacitieByLabel-Map\u003cString,Float\u003e, maximumCapacitiesByLabel-Map\u003cString,Float\u003e, revervationContinueLooking-boolean]",
            "newValue": "[clusterResource-Resource, capacity-float, absoluteCapacity-float, maximumCapacity-float, absoluteMaxCapacity-float, userLimit-int, userLimitFactor-float, maxApplications-int, maxAMResourcePerQueuePercent-float, maxApplicationsPerUser-int, state-QueueState, acls-Map\u003cQueueACL,AccessControlList\u003e, nodeLocalityDelay-int, labels-Set\u003cString\u003e, defaultLabelExpression-String, capacitieByLabel-Map\u003cString,Float\u003e, maximumCapacitiesByLabel-Map\u003cString,Float\u003e, revervationContinueLooking-boolean, maxAllocation-Resource]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-1582. Capacity Scheduler: add a maximum-allocation-mb setting per queue. Contributed by Thomas Graves\n",
          "commitDate": "05/02/15 11:28 AM",
          "commitName": "69c8a7f45be5c0aa6787b07f328d74f1e2ba5628",
          "commitAuthor": "Jason Lowe",
          "commitDateOld": "30/01/15 3:15 PM",
          "commitNameOld": "86358221fc85a7743052a0b4c1647353508bf308",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 5.84,
          "commitsBetweenForRepo": 56,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,115 +1,124 @@\n   protected synchronized void setupQueueConfigs(\n       Resource clusterResource,\n       float capacity, float absoluteCapacity, \n       float maximumCapacity, float absoluteMaxCapacity,\n       int userLimit, float userLimitFactor,\n       int maxApplications, float maxAMResourcePerQueuePercent,\n       int maxApplicationsPerUser, QueueState state,\n       Map\u003cQueueACL, AccessControlList\u003e acls, int nodeLocalityDelay,\n       Set\u003cString\u003e labels, String defaultLabelExpression,\n       Map\u003cString, Float\u003e capacitieByLabel,\n       Map\u003cString, Float\u003e maximumCapacitiesByLabel, \n-      boolean revervationContinueLooking) throws IOException {\n+      boolean revervationContinueLooking,\n+      Resource maxAllocation) throws IOException {\n     super.setupQueueConfigs(clusterResource, capacity, absoluteCapacity,\n         maximumCapacity, absoluteMaxCapacity, state, acls, labels,\n         defaultLabelExpression, capacitieByLabel, maximumCapacitiesByLabel,\n-        revervationContinueLooking);\n+        revervationContinueLooking, maxAllocation);\n     // Sanity check\n     CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n     float absCapacity \u003d getParent().getAbsoluteCapacity() * capacity;\n     CSQueueUtils.checkAbsoluteCapacity(getQueueName(), absCapacity,\n         absoluteMaxCapacity);\n     \n     this.lastClusterResource \u003d clusterResource;\n     updateAbsoluteCapacityResource(clusterResource);\n     \n     // Initialize headroom info, also used for calculating application \n     // master resource limits.  Since this happens during queue initialization\n     // and all queues may not be realized yet, we\u0027ll use (optimistic) \n     // absoluteMaxCapacity (it will be replaced with the more accurate \n     // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n     updateHeadroomInfo(clusterResource, absoluteMaxCapacity);\n \n     this.absoluteCapacity \u003d absCapacity;\n \n     this.userLimit \u003d userLimit;\n     this.userLimitFactor \u003d userLimitFactor;\n \n     this.maxApplications \u003d maxApplications;\n     this.maxAMResourcePerQueuePercent \u003d maxAMResourcePerQueuePercent;\n     this.maxApplicationsPerUser \u003d maxApplicationsPerUser;\n \n     if (!SchedulerUtils.checkQueueLabelExpression(this.accessibleLabels,\n         this.defaultLabelExpression)) {\n       throw new IOException(\"Invalid default label expression of \"\n           + \" queue\u003d\"\n           + getQueueName()\n           + \" doesn\u0027t have permission to access all labels \"\n           + \"in default label expression. labelExpression of resource request\u003d\"\n           + (this.defaultLabelExpression \u003d\u003d null ? \"\"\n               : this.defaultLabelExpression)\n           + \". Queue labels\u003d\"\n           + (getAccessibleNodeLabels() \u003d\u003d null ? \"\" : StringUtils.join(\n               getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n     }\n     \n     this.nodeLocalityDelay \u003d nodeLocalityDelay;\n \n+    // re-init this since max allocation could have changed\n+    this.minimumAllocationFactor \u003d\n+        Resources.ratio(resourceCalculator,\n+            Resources.subtract(maximumAllocation, minimumAllocation),\n+            maximumAllocation);\n+\n     StringBuilder aclsString \u003d new StringBuilder();\n     for (Map.Entry\u003cQueueACL, AccessControlList\u003e e : acls.entrySet()) {\n       aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n     }\n \n     StringBuilder labelStrBuilder \u003d new StringBuilder(); \n     if (labels !\u003d null) {\n       for (String s : labels) {\n         labelStrBuilder.append(s);\n         labelStrBuilder.append(\",\");\n       }\n     }\n \n     LOG.info(\"Initializing \" + queueName + \"\\n\" +\n         \"capacity \u003d \" + capacity +\n         \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n         \"asboluteCapacity \u003d \" + absoluteCapacity +\n         \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n         \"maxCapacity \u003d \" + maximumCapacity +\n         \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n         \"absoluteMaxCapacity \u003d \" + absoluteMaxCapacity +\n         \" [\u003d 1.0 maximumCapacity undefined, \" +\n         \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n         \"\\n\" +\n         \"userLimit \u003d \" + userLimit +\n         \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n         \"userLimitFactor \u003d \" + userLimitFactor +\n         \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n         \"maxApplications \u003d \" + maxApplications +\n         \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n         \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n         \"\\n\" +\n         \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n         \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n         \"userLimitFactor) ]\" + \"\\n\" +\n         \"usedCapacity \u003d \" + usedCapacity +\n         \" [\u003d usedResourcesMemory / \" +\n         \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n         \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n         \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n         \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n         \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n         \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n         \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n         \"maximumAllocationMemory ]\" + \"\\n\" +\n+        \"maximumAllocation \u003d \" + maximumAllocation +\n+        \" [\u003d configuredMaxAllocation ]\" + \"\\n\" +\n         \"numContainers \u003d \" + numContainers +\n         \" [\u003d currentNumContainers ]\" + \"\\n\" +\n         \"state \u003d \" + state +\n         \" [\u003d configuredState ]\" + \"\\n\" +\n         \"acls \u003d \" + aclsString +\n         \" [\u003d configuredAcls ]\" + \"\\n\" + \n         \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\" +\n         \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\" +\n         \"nodeLocalityDelay \u003d \" +  nodeLocalityDelay + \"\\n\" +\n         \"reservationsContinueLooking \u003d \" +\n         reservationsContinueLooking + \"\\n\" +\n         \"preemptionDisabled \u003d \" + getPreemptionDisabled() + \"\\n\");\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected synchronized void setupQueueConfigs(\n      Resource clusterResource,\n      float capacity, float absoluteCapacity, \n      float maximumCapacity, float absoluteMaxCapacity,\n      int userLimit, float userLimitFactor,\n      int maxApplications, float maxAMResourcePerQueuePercent,\n      int maxApplicationsPerUser, QueueState state,\n      Map\u003cQueueACL, AccessControlList\u003e acls, int nodeLocalityDelay,\n      Set\u003cString\u003e labels, String defaultLabelExpression,\n      Map\u003cString, Float\u003e capacitieByLabel,\n      Map\u003cString, Float\u003e maximumCapacitiesByLabel, \n      boolean revervationContinueLooking,\n      Resource maxAllocation) throws IOException {\n    super.setupQueueConfigs(clusterResource, capacity, absoluteCapacity,\n        maximumCapacity, absoluteMaxCapacity, state, acls, labels,\n        defaultLabelExpression, capacitieByLabel, maximumCapacitiesByLabel,\n        revervationContinueLooking, maxAllocation);\n    // Sanity check\n    CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n    float absCapacity \u003d getParent().getAbsoluteCapacity() * capacity;\n    CSQueueUtils.checkAbsoluteCapacity(getQueueName(), absCapacity,\n        absoluteMaxCapacity);\n    \n    this.lastClusterResource \u003d clusterResource;\n    updateAbsoluteCapacityResource(clusterResource);\n    \n    // Initialize headroom info, also used for calculating application \n    // master resource limits.  Since this happens during queue initialization\n    // and all queues may not be realized yet, we\u0027ll use (optimistic) \n    // absoluteMaxCapacity (it will be replaced with the more accurate \n    // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n    updateHeadroomInfo(clusterResource, absoluteMaxCapacity);\n\n    this.absoluteCapacity \u003d absCapacity;\n\n    this.userLimit \u003d userLimit;\n    this.userLimitFactor \u003d userLimitFactor;\n\n    this.maxApplications \u003d maxApplications;\n    this.maxAMResourcePerQueuePercent \u003d maxAMResourcePerQueuePercent;\n    this.maxApplicationsPerUser \u003d maxApplicationsPerUser;\n\n    if (!SchedulerUtils.checkQueueLabelExpression(this.accessibleLabels,\n        this.defaultLabelExpression)) {\n      throw new IOException(\"Invalid default label expression of \"\n          + \" queue\u003d\"\n          + getQueueName()\n          + \" doesn\u0027t have permission to access all labels \"\n          + \"in default label expression. labelExpression of resource request\u003d\"\n          + (this.defaultLabelExpression \u003d\u003d null ? \"\"\n              : this.defaultLabelExpression)\n          + \". Queue labels\u003d\"\n          + (getAccessibleNodeLabels() \u003d\u003d null ? \"\" : StringUtils.join(\n              getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n    }\n    \n    this.nodeLocalityDelay \u003d nodeLocalityDelay;\n\n    // re-init this since max allocation could have changed\n    this.minimumAllocationFactor \u003d\n        Resources.ratio(resourceCalculator,\n            Resources.subtract(maximumAllocation, minimumAllocation),\n            maximumAllocation);\n\n    StringBuilder aclsString \u003d new StringBuilder();\n    for (Map.Entry\u003cQueueACL, AccessControlList\u003e e : acls.entrySet()) {\n      aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n    }\n\n    StringBuilder labelStrBuilder \u003d new StringBuilder(); \n    if (labels !\u003d null) {\n      for (String s : labels) {\n        labelStrBuilder.append(s);\n        labelStrBuilder.append(\",\");\n      }\n    }\n\n    LOG.info(\"Initializing \" + queueName + \"\\n\" +\n        \"capacity \u003d \" + capacity +\n        \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n        \"asboluteCapacity \u003d \" + absoluteCapacity +\n        \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n        \"maxCapacity \u003d \" + maximumCapacity +\n        \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n        \"absoluteMaxCapacity \u003d \" + absoluteMaxCapacity +\n        \" [\u003d 1.0 maximumCapacity undefined, \" +\n        \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n        \"\\n\" +\n        \"userLimit \u003d \" + userLimit +\n        \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n        \"userLimitFactor \u003d \" + userLimitFactor +\n        \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n        \"maxApplications \u003d \" + maxApplications +\n        \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n        \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n        \"\\n\" +\n        \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n        \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n        \"userLimitFactor) ]\" + \"\\n\" +\n        \"usedCapacity \u003d \" + usedCapacity +\n        \" [\u003d usedResourcesMemory / \" +\n        \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n        \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n        \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n        \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n        \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n        \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n        \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n        \"maximumAllocationMemory ]\" + \"\\n\" +\n        \"maximumAllocation \u003d \" + maximumAllocation +\n        \" [\u003d configuredMaxAllocation ]\" + \"\\n\" +\n        \"numContainers \u003d \" + numContainers +\n        \" [\u003d currentNumContainers ]\" + \"\\n\" +\n        \"state \u003d \" + state +\n        \" [\u003d configuredState ]\" + \"\\n\" +\n        \"acls \u003d \" + aclsString +\n        \" [\u003d configuredAcls ]\" + \"\\n\" + \n        \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\" +\n        \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\" +\n        \"nodeLocalityDelay \u003d \" +  nodeLocalityDelay + \"\\n\" +\n        \"reservationsContinueLooking \u003d \" +\n        reservationsContinueLooking + \"\\n\" +\n        \"preemptionDisabled \u003d \" + getPreemptionDisabled() + \"\\n\");\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {}
        }
      ]
    },
    "18741adf97f4fda5f8743318b59c440928e51297": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2932. Add entry for preemptable status (enabled/disabled) to scheduler web UI and queue initialize/refresh logging. (Eric Payne via wangda)\n",
      "commitDate": "27/01/15 3:36 PM",
      "commitName": "18741adf97f4fda5f8743318b59c440928e51297",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "13/01/15 5:32 PM",
      "commitNameOld": "c53420f58364b11fbda1dace7679d45534533382",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 13.92,
      "commitsBetweenForRepo": 104,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,114 +1,115 @@\n   protected synchronized void setupQueueConfigs(\n       Resource clusterResource,\n       float capacity, float absoluteCapacity, \n       float maximumCapacity, float absoluteMaxCapacity,\n       int userLimit, float userLimitFactor,\n       int maxApplications, float maxAMResourcePerQueuePercent,\n       int maxApplicationsPerUser, QueueState state,\n       Map\u003cQueueACL, AccessControlList\u003e acls, int nodeLocalityDelay,\n       Set\u003cString\u003e labels, String defaultLabelExpression,\n       Map\u003cString, Float\u003e capacitieByLabel,\n       Map\u003cString, Float\u003e maximumCapacitiesByLabel, \n       boolean revervationContinueLooking) throws IOException {\n     super.setupQueueConfigs(clusterResource, capacity, absoluteCapacity,\n         maximumCapacity, absoluteMaxCapacity, state, acls, labels,\n         defaultLabelExpression, capacitieByLabel, maximumCapacitiesByLabel,\n         revervationContinueLooking);\n     // Sanity check\n     CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n     float absCapacity \u003d getParent().getAbsoluteCapacity() * capacity;\n     CSQueueUtils.checkAbsoluteCapacity(getQueueName(), absCapacity,\n         absoluteMaxCapacity);\n     \n     this.lastClusterResource \u003d clusterResource;\n     updateAbsoluteCapacityResource(clusterResource);\n     \n     // Initialize headroom info, also used for calculating application \n     // master resource limits.  Since this happens during queue initialization\n     // and all queues may not be realized yet, we\u0027ll use (optimistic) \n     // absoluteMaxCapacity (it will be replaced with the more accurate \n     // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n     updateHeadroomInfo(clusterResource, absoluteMaxCapacity);\n \n     this.absoluteCapacity \u003d absCapacity;\n \n     this.userLimit \u003d userLimit;\n     this.userLimitFactor \u003d userLimitFactor;\n \n     this.maxApplications \u003d maxApplications;\n     this.maxAMResourcePerQueuePercent \u003d maxAMResourcePerQueuePercent;\n     this.maxApplicationsPerUser \u003d maxApplicationsPerUser;\n \n     if (!SchedulerUtils.checkQueueLabelExpression(this.accessibleLabels,\n         this.defaultLabelExpression)) {\n       throw new IOException(\"Invalid default label expression of \"\n           + \" queue\u003d\"\n           + getQueueName()\n           + \" doesn\u0027t have permission to access all labels \"\n           + \"in default label expression. labelExpression of resource request\u003d\"\n           + (this.defaultLabelExpression \u003d\u003d null ? \"\"\n               : this.defaultLabelExpression)\n           + \". Queue labels\u003d\"\n           + (getAccessibleNodeLabels() \u003d\u003d null ? \"\" : StringUtils.join(\n               getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n     }\n     \n     this.nodeLocalityDelay \u003d nodeLocalityDelay;\n \n     StringBuilder aclsString \u003d new StringBuilder();\n     for (Map.Entry\u003cQueueACL, AccessControlList\u003e e : acls.entrySet()) {\n       aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n     }\n \n     StringBuilder labelStrBuilder \u003d new StringBuilder(); \n     if (labels !\u003d null) {\n       for (String s : labels) {\n         labelStrBuilder.append(s);\n         labelStrBuilder.append(\",\");\n       }\n     }\n \n     LOG.info(\"Initializing \" + queueName + \"\\n\" +\n         \"capacity \u003d \" + capacity +\n         \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n         \"asboluteCapacity \u003d \" + absoluteCapacity +\n         \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n         \"maxCapacity \u003d \" + maximumCapacity +\n         \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n         \"absoluteMaxCapacity \u003d \" + absoluteMaxCapacity +\n         \" [\u003d 1.0 maximumCapacity undefined, \" +\n         \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n         \"\\n\" +\n         \"userLimit \u003d \" + userLimit +\n         \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n         \"userLimitFactor \u003d \" + userLimitFactor +\n         \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n         \"maxApplications \u003d \" + maxApplications +\n         \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n         \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n         \"\\n\" +\n         \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n         \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n         \"userLimitFactor) ]\" + \"\\n\" +\n         \"usedCapacity \u003d \" + usedCapacity +\n         \" [\u003d usedResourcesMemory / \" +\n         \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n         \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n         \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n         \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n         \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n         \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n         \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n         \"maximumAllocationMemory ]\" + \"\\n\" +\n         \"numContainers \u003d \" + numContainers +\n         \" [\u003d currentNumContainers ]\" + \"\\n\" +\n         \"state \u003d \" + state +\n         \" [\u003d configuredState ]\" + \"\\n\" +\n         \"acls \u003d \" + aclsString +\n         \" [\u003d configuredAcls ]\" + \"\\n\" + \n         \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\" +\n         \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\" +\n         \"nodeLocalityDelay \u003d \" +  nodeLocalityDelay + \"\\n\" +\n         \"reservationsContinueLooking \u003d \" +\n-        reservationsContinueLooking + \"\\n\");\n+        reservationsContinueLooking + \"\\n\" +\n+        \"preemptionDisabled \u003d \" + getPreemptionDisabled() + \"\\n\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void setupQueueConfigs(\n      Resource clusterResource,\n      float capacity, float absoluteCapacity, \n      float maximumCapacity, float absoluteMaxCapacity,\n      int userLimit, float userLimitFactor,\n      int maxApplications, float maxAMResourcePerQueuePercent,\n      int maxApplicationsPerUser, QueueState state,\n      Map\u003cQueueACL, AccessControlList\u003e acls, int nodeLocalityDelay,\n      Set\u003cString\u003e labels, String defaultLabelExpression,\n      Map\u003cString, Float\u003e capacitieByLabel,\n      Map\u003cString, Float\u003e maximumCapacitiesByLabel, \n      boolean revervationContinueLooking) throws IOException {\n    super.setupQueueConfigs(clusterResource, capacity, absoluteCapacity,\n        maximumCapacity, absoluteMaxCapacity, state, acls, labels,\n        defaultLabelExpression, capacitieByLabel, maximumCapacitiesByLabel,\n        revervationContinueLooking);\n    // Sanity check\n    CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n    float absCapacity \u003d getParent().getAbsoluteCapacity() * capacity;\n    CSQueueUtils.checkAbsoluteCapacity(getQueueName(), absCapacity,\n        absoluteMaxCapacity);\n    \n    this.lastClusterResource \u003d clusterResource;\n    updateAbsoluteCapacityResource(clusterResource);\n    \n    // Initialize headroom info, also used for calculating application \n    // master resource limits.  Since this happens during queue initialization\n    // and all queues may not be realized yet, we\u0027ll use (optimistic) \n    // absoluteMaxCapacity (it will be replaced with the more accurate \n    // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n    updateHeadroomInfo(clusterResource, absoluteMaxCapacity);\n\n    this.absoluteCapacity \u003d absCapacity;\n\n    this.userLimit \u003d userLimit;\n    this.userLimitFactor \u003d userLimitFactor;\n\n    this.maxApplications \u003d maxApplications;\n    this.maxAMResourcePerQueuePercent \u003d maxAMResourcePerQueuePercent;\n    this.maxApplicationsPerUser \u003d maxApplicationsPerUser;\n\n    if (!SchedulerUtils.checkQueueLabelExpression(this.accessibleLabels,\n        this.defaultLabelExpression)) {\n      throw new IOException(\"Invalid default label expression of \"\n          + \" queue\u003d\"\n          + getQueueName()\n          + \" doesn\u0027t have permission to access all labels \"\n          + \"in default label expression. labelExpression of resource request\u003d\"\n          + (this.defaultLabelExpression \u003d\u003d null ? \"\"\n              : this.defaultLabelExpression)\n          + \". Queue labels\u003d\"\n          + (getAccessibleNodeLabels() \u003d\u003d null ? \"\" : StringUtils.join(\n              getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n    }\n    \n    this.nodeLocalityDelay \u003d nodeLocalityDelay;\n\n    StringBuilder aclsString \u003d new StringBuilder();\n    for (Map.Entry\u003cQueueACL, AccessControlList\u003e e : acls.entrySet()) {\n      aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n    }\n\n    StringBuilder labelStrBuilder \u003d new StringBuilder(); \n    if (labels !\u003d null) {\n      for (String s : labels) {\n        labelStrBuilder.append(s);\n        labelStrBuilder.append(\",\");\n      }\n    }\n\n    LOG.info(\"Initializing \" + queueName + \"\\n\" +\n        \"capacity \u003d \" + capacity +\n        \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n        \"asboluteCapacity \u003d \" + absoluteCapacity +\n        \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n        \"maxCapacity \u003d \" + maximumCapacity +\n        \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n        \"absoluteMaxCapacity \u003d \" + absoluteMaxCapacity +\n        \" [\u003d 1.0 maximumCapacity undefined, \" +\n        \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n        \"\\n\" +\n        \"userLimit \u003d \" + userLimit +\n        \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n        \"userLimitFactor \u003d \" + userLimitFactor +\n        \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n        \"maxApplications \u003d \" + maxApplications +\n        \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n        \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n        \"\\n\" +\n        \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n        \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n        \"userLimitFactor) ]\" + \"\\n\" +\n        \"usedCapacity \u003d \" + usedCapacity +\n        \" [\u003d usedResourcesMemory / \" +\n        \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n        \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n        \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n        \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n        \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n        \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n        \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n        \"maximumAllocationMemory ]\" + \"\\n\" +\n        \"numContainers \u003d \" + numContainers +\n        \" [\u003d currentNumContainers ]\" + \"\\n\" +\n        \"state \u003d \" + state +\n        \" [\u003d configuredState ]\" + \"\\n\" +\n        \"acls \u003d \" + aclsString +\n        \" [\u003d configuredAcls ]\" + \"\\n\" + \n        \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\" +\n        \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\" +\n        \"nodeLocalityDelay \u003d \" +  nodeLocalityDelay + \"\\n\" +\n        \"reservationsContinueLooking \u003d \" +\n        reservationsContinueLooking + \"\\n\" +\n        \"preemptionDisabled \u003d \" + getPreemptionDisabled() + \"\\n\");\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "c53420f58364b11fbda1dace7679d45534533382": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-2637. Fixed max-am-resource-percent calculation in CapacityScheduler when activating applications. Contributed by Craig Welch\n",
      "commitDate": "13/01/15 5:32 PM",
      "commitName": "c53420f58364b11fbda1dace7679d45534533382",
      "commitAuthor": "Jian He",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-2637. Fixed max-am-resource-percent calculation in CapacityScheduler when activating applications. Contributed by Craig Welch\n",
          "commitDate": "13/01/15 5:32 PM",
          "commitName": "c53420f58364b11fbda1dace7679d45534533382",
          "commitAuthor": "Jian He",
          "commitDateOld": "06/01/15 2:15 PM",
          "commitNameOld": "dd57c2047bfd21910acc38c98153eedf1db75169",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 7.14,
          "commitsBetweenForRepo": 42,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,123 +1,114 @@\n   protected synchronized void setupQueueConfigs(\n       Resource clusterResource,\n       float capacity, float absoluteCapacity, \n       float maximumCapacity, float absoluteMaxCapacity,\n       int userLimit, float userLimitFactor,\n       int maxApplications, float maxAMResourcePerQueuePercent,\n-      int maxApplicationsPerUser, int maxActiveApplications,\n-      int maxActiveApplicationsPerUser, QueueState state,\n+      int maxApplicationsPerUser, QueueState state,\n       Map\u003cQueueACL, AccessControlList\u003e acls, int nodeLocalityDelay,\n       Set\u003cString\u003e labels, String defaultLabelExpression,\n       Map\u003cString, Float\u003e capacitieByLabel,\n       Map\u003cString, Float\u003e maximumCapacitiesByLabel, \n       boolean revervationContinueLooking) throws IOException {\n     super.setupQueueConfigs(clusterResource, capacity, absoluteCapacity,\n         maximumCapacity, absoluteMaxCapacity, state, acls, labels,\n         defaultLabelExpression, capacitieByLabel, maximumCapacitiesByLabel,\n         revervationContinueLooking);\n     // Sanity check\n     CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n     float absCapacity \u003d getParent().getAbsoluteCapacity() * capacity;\n     CSQueueUtils.checkAbsoluteCapacity(getQueueName(), absCapacity,\n         absoluteMaxCapacity);\n+    \n+    this.lastClusterResource \u003d clusterResource;\n+    updateAbsoluteCapacityResource(clusterResource);\n+    \n+    // Initialize headroom info, also used for calculating application \n+    // master resource limits.  Since this happens during queue initialization\n+    // and all queues may not be realized yet, we\u0027ll use (optimistic) \n+    // absoluteMaxCapacity (it will be replaced with the more accurate \n+    // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n+    updateHeadroomInfo(clusterResource, absoluteMaxCapacity);\n \n     this.absoluteCapacity \u003d absCapacity;\n \n     this.userLimit \u003d userLimit;\n     this.userLimitFactor \u003d userLimitFactor;\n \n     this.maxApplications \u003d maxApplications;\n     this.maxAMResourcePerQueuePercent \u003d maxAMResourcePerQueuePercent;\n     this.maxApplicationsPerUser \u003d maxApplicationsPerUser;\n \n-    this.maxActiveApplications \u003d maxActiveApplications;\n-    this.maxActiveApplicationsPerUser \u003d maxActiveApplicationsPerUser;\n-\n     if (!SchedulerUtils.checkQueueLabelExpression(this.accessibleLabels,\n         this.defaultLabelExpression)) {\n       throw new IOException(\"Invalid default label expression of \"\n           + \" queue\u003d\"\n           + getQueueName()\n           + \" doesn\u0027t have permission to access all labels \"\n           + \"in default label expression. labelExpression of resource request\u003d\"\n           + (this.defaultLabelExpression \u003d\u003d null ? \"\"\n               : this.defaultLabelExpression)\n           + \". Queue labels\u003d\"\n           + (getAccessibleNodeLabels() \u003d\u003d null ? \"\" : StringUtils.join(\n               getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n     }\n     \n     this.nodeLocalityDelay \u003d nodeLocalityDelay;\n \n     StringBuilder aclsString \u003d new StringBuilder();\n     for (Map.Entry\u003cQueueACL, AccessControlList\u003e e : acls.entrySet()) {\n       aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n     }\n \n     StringBuilder labelStrBuilder \u003d new StringBuilder(); \n     if (labels !\u003d null) {\n       for (String s : labels) {\n         labelStrBuilder.append(s);\n         labelStrBuilder.append(\",\");\n       }\n     }\n \n     LOG.info(\"Initializing \" + queueName + \"\\n\" +\n         \"capacity \u003d \" + capacity +\n         \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n         \"asboluteCapacity \u003d \" + absoluteCapacity +\n         \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n         \"maxCapacity \u003d \" + maximumCapacity +\n         \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n         \"absoluteMaxCapacity \u003d \" + absoluteMaxCapacity +\n         \" [\u003d 1.0 maximumCapacity undefined, \" +\n         \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n         \"\\n\" +\n         \"userLimit \u003d \" + userLimit +\n         \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n         \"userLimitFactor \u003d \" + userLimitFactor +\n         \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n         \"maxApplications \u003d \" + maxApplications +\n         \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n         \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n         \"\\n\" +\n         \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n         \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n         \"userLimitFactor) ]\" + \"\\n\" +\n-        \"maxActiveApplications \u003d \" + maxActiveApplications +\n-        \" [\u003d max(\" + \n-        \"(int)ceil((clusterResourceMemory / minimumAllocation) * \" + \n-        \"maxAMResourcePerQueuePercent * absoluteMaxCapacity),\" + \n-        \"1) ]\" + \"\\n\" +\n-        \"maxActiveAppsUsingAbsCap \u003d \" + maxActiveAppsUsingAbsCap +\n-        \" [\u003d max(\" + \n-        \"(int)ceil((clusterResourceMemory / minimumAllocation) *\" + \n-        \"maxAMResourcePercent * absoluteCapacity),\" + \n-        \"1) ]\" + \"\\n\" +\n-        \"maxActiveApplicationsPerUser \u003d \" + maxActiveApplicationsPerUser +\n-        \" [\u003d max(\" +\n-        \"(int)(maxActiveApplications * (userLimit / 100.0f) * \" +\n-        \"userLimitFactor),\" +\n-        \"1) ]\" + \"\\n\" +\n         \"usedCapacity \u003d \" + usedCapacity +\n         \" [\u003d usedResourcesMemory / \" +\n         \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n         \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n         \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n         \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n         \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n         \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n         \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n         \"maximumAllocationMemory ]\" + \"\\n\" +\n         \"numContainers \u003d \" + numContainers +\n         \" [\u003d currentNumContainers ]\" + \"\\n\" +\n         \"state \u003d \" + state +\n         \" [\u003d configuredState ]\" + \"\\n\" +\n         \"acls \u003d \" + aclsString +\n         \" [\u003d configuredAcls ]\" + \"\\n\" + \n         \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\" +\n         \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\" +\n         \"nodeLocalityDelay \u003d \" +  nodeLocalityDelay + \"\\n\" +\n         \"reservationsContinueLooking \u003d \" +\n         reservationsContinueLooking + \"\\n\");\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected synchronized void setupQueueConfigs(\n      Resource clusterResource,\n      float capacity, float absoluteCapacity, \n      float maximumCapacity, float absoluteMaxCapacity,\n      int userLimit, float userLimitFactor,\n      int maxApplications, float maxAMResourcePerQueuePercent,\n      int maxApplicationsPerUser, QueueState state,\n      Map\u003cQueueACL, AccessControlList\u003e acls, int nodeLocalityDelay,\n      Set\u003cString\u003e labels, String defaultLabelExpression,\n      Map\u003cString, Float\u003e capacitieByLabel,\n      Map\u003cString, Float\u003e maximumCapacitiesByLabel, \n      boolean revervationContinueLooking) throws IOException {\n    super.setupQueueConfigs(clusterResource, capacity, absoluteCapacity,\n        maximumCapacity, absoluteMaxCapacity, state, acls, labels,\n        defaultLabelExpression, capacitieByLabel, maximumCapacitiesByLabel,\n        revervationContinueLooking);\n    // Sanity check\n    CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n    float absCapacity \u003d getParent().getAbsoluteCapacity() * capacity;\n    CSQueueUtils.checkAbsoluteCapacity(getQueueName(), absCapacity,\n        absoluteMaxCapacity);\n    \n    this.lastClusterResource \u003d clusterResource;\n    updateAbsoluteCapacityResource(clusterResource);\n    \n    // Initialize headroom info, also used for calculating application \n    // master resource limits.  Since this happens during queue initialization\n    // and all queues may not be realized yet, we\u0027ll use (optimistic) \n    // absoluteMaxCapacity (it will be replaced with the more accurate \n    // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n    updateHeadroomInfo(clusterResource, absoluteMaxCapacity);\n\n    this.absoluteCapacity \u003d absCapacity;\n\n    this.userLimit \u003d userLimit;\n    this.userLimitFactor \u003d userLimitFactor;\n\n    this.maxApplications \u003d maxApplications;\n    this.maxAMResourcePerQueuePercent \u003d maxAMResourcePerQueuePercent;\n    this.maxApplicationsPerUser \u003d maxApplicationsPerUser;\n\n    if (!SchedulerUtils.checkQueueLabelExpression(this.accessibleLabels,\n        this.defaultLabelExpression)) {\n      throw new IOException(\"Invalid default label expression of \"\n          + \" queue\u003d\"\n          + getQueueName()\n          + \" doesn\u0027t have permission to access all labels \"\n          + \"in default label expression. labelExpression of resource request\u003d\"\n          + (this.defaultLabelExpression \u003d\u003d null ? \"\"\n              : this.defaultLabelExpression)\n          + \". Queue labels\u003d\"\n          + (getAccessibleNodeLabels() \u003d\u003d null ? \"\" : StringUtils.join(\n              getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n    }\n    \n    this.nodeLocalityDelay \u003d nodeLocalityDelay;\n\n    StringBuilder aclsString \u003d new StringBuilder();\n    for (Map.Entry\u003cQueueACL, AccessControlList\u003e e : acls.entrySet()) {\n      aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n    }\n\n    StringBuilder labelStrBuilder \u003d new StringBuilder(); \n    if (labels !\u003d null) {\n      for (String s : labels) {\n        labelStrBuilder.append(s);\n        labelStrBuilder.append(\",\");\n      }\n    }\n\n    LOG.info(\"Initializing \" + queueName + \"\\n\" +\n        \"capacity \u003d \" + capacity +\n        \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n        \"asboluteCapacity \u003d \" + absoluteCapacity +\n        \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n        \"maxCapacity \u003d \" + maximumCapacity +\n        \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n        \"absoluteMaxCapacity \u003d \" + absoluteMaxCapacity +\n        \" [\u003d 1.0 maximumCapacity undefined, \" +\n        \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n        \"\\n\" +\n        \"userLimit \u003d \" + userLimit +\n        \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n        \"userLimitFactor \u003d \" + userLimitFactor +\n        \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n        \"maxApplications \u003d \" + maxApplications +\n        \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n        \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n        \"\\n\" +\n        \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n        \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n        \"userLimitFactor) ]\" + \"\\n\" +\n        \"usedCapacity \u003d \" + usedCapacity +\n        \" [\u003d usedResourcesMemory / \" +\n        \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n        \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n        \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n        \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n        \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n        \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n        \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n        \"maximumAllocationMemory ]\" + \"\\n\" +\n        \"numContainers \u003d \" + numContainers +\n        \" [\u003d currentNumContainers ]\" + \"\\n\" +\n        \"state \u003d \" + state +\n        \" [\u003d configuredState ]\" + \"\\n\" +\n        \"acls \u003d \" + aclsString +\n        \" [\u003d configuredAcls ]\" + \"\\n\" + \n        \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\" +\n        \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\" +\n        \"nodeLocalityDelay \u003d \" +  nodeLocalityDelay + \"\\n\" +\n        \"reservationsContinueLooking \u003d \" +\n        reservationsContinueLooking + \"\\n\");\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {
            "oldValue": "[clusterResource-Resource, capacity-float, absoluteCapacity-float, maximumCapacity-float, absoluteMaxCapacity-float, userLimit-int, userLimitFactor-float, maxApplications-int, maxAMResourcePerQueuePercent-float, maxApplicationsPerUser-int, maxActiveApplications-int, maxActiveApplicationsPerUser-int, state-QueueState, acls-Map\u003cQueueACL,AccessControlList\u003e, nodeLocalityDelay-int, labels-Set\u003cString\u003e, defaultLabelExpression-String, capacitieByLabel-Map\u003cString,Float\u003e, maximumCapacitiesByLabel-Map\u003cString,Float\u003e, revervationContinueLooking-boolean]",
            "newValue": "[clusterResource-Resource, capacity-float, absoluteCapacity-float, maximumCapacity-float, absoluteMaxCapacity-float, userLimit-int, userLimitFactor-float, maxApplications-int, maxAMResourcePerQueuePercent-float, maxApplicationsPerUser-int, state-QueueState, acls-Map\u003cQueueACL,AccessControlList\u003e, nodeLocalityDelay-int, labels-Set\u003cString\u003e, defaultLabelExpression-String, capacitieByLabel-Map\u003cString,Float\u003e, maximumCapacitiesByLabel-Map\u003cString,Float\u003e, revervationContinueLooking-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-2637. Fixed max-am-resource-percent calculation in CapacityScheduler when activating applications. Contributed by Craig Welch\n",
          "commitDate": "13/01/15 5:32 PM",
          "commitName": "c53420f58364b11fbda1dace7679d45534533382",
          "commitAuthor": "Jian He",
          "commitDateOld": "06/01/15 2:15 PM",
          "commitNameOld": "dd57c2047bfd21910acc38c98153eedf1db75169",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 7.14,
          "commitsBetweenForRepo": 42,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,123 +1,114 @@\n   protected synchronized void setupQueueConfigs(\n       Resource clusterResource,\n       float capacity, float absoluteCapacity, \n       float maximumCapacity, float absoluteMaxCapacity,\n       int userLimit, float userLimitFactor,\n       int maxApplications, float maxAMResourcePerQueuePercent,\n-      int maxApplicationsPerUser, int maxActiveApplications,\n-      int maxActiveApplicationsPerUser, QueueState state,\n+      int maxApplicationsPerUser, QueueState state,\n       Map\u003cQueueACL, AccessControlList\u003e acls, int nodeLocalityDelay,\n       Set\u003cString\u003e labels, String defaultLabelExpression,\n       Map\u003cString, Float\u003e capacitieByLabel,\n       Map\u003cString, Float\u003e maximumCapacitiesByLabel, \n       boolean revervationContinueLooking) throws IOException {\n     super.setupQueueConfigs(clusterResource, capacity, absoluteCapacity,\n         maximumCapacity, absoluteMaxCapacity, state, acls, labels,\n         defaultLabelExpression, capacitieByLabel, maximumCapacitiesByLabel,\n         revervationContinueLooking);\n     // Sanity check\n     CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n     float absCapacity \u003d getParent().getAbsoluteCapacity() * capacity;\n     CSQueueUtils.checkAbsoluteCapacity(getQueueName(), absCapacity,\n         absoluteMaxCapacity);\n+    \n+    this.lastClusterResource \u003d clusterResource;\n+    updateAbsoluteCapacityResource(clusterResource);\n+    \n+    // Initialize headroom info, also used for calculating application \n+    // master resource limits.  Since this happens during queue initialization\n+    // and all queues may not be realized yet, we\u0027ll use (optimistic) \n+    // absoluteMaxCapacity (it will be replaced with the more accurate \n+    // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n+    updateHeadroomInfo(clusterResource, absoluteMaxCapacity);\n \n     this.absoluteCapacity \u003d absCapacity;\n \n     this.userLimit \u003d userLimit;\n     this.userLimitFactor \u003d userLimitFactor;\n \n     this.maxApplications \u003d maxApplications;\n     this.maxAMResourcePerQueuePercent \u003d maxAMResourcePerQueuePercent;\n     this.maxApplicationsPerUser \u003d maxApplicationsPerUser;\n \n-    this.maxActiveApplications \u003d maxActiveApplications;\n-    this.maxActiveApplicationsPerUser \u003d maxActiveApplicationsPerUser;\n-\n     if (!SchedulerUtils.checkQueueLabelExpression(this.accessibleLabels,\n         this.defaultLabelExpression)) {\n       throw new IOException(\"Invalid default label expression of \"\n           + \" queue\u003d\"\n           + getQueueName()\n           + \" doesn\u0027t have permission to access all labels \"\n           + \"in default label expression. labelExpression of resource request\u003d\"\n           + (this.defaultLabelExpression \u003d\u003d null ? \"\"\n               : this.defaultLabelExpression)\n           + \". Queue labels\u003d\"\n           + (getAccessibleNodeLabels() \u003d\u003d null ? \"\" : StringUtils.join(\n               getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n     }\n     \n     this.nodeLocalityDelay \u003d nodeLocalityDelay;\n \n     StringBuilder aclsString \u003d new StringBuilder();\n     for (Map.Entry\u003cQueueACL, AccessControlList\u003e e : acls.entrySet()) {\n       aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n     }\n \n     StringBuilder labelStrBuilder \u003d new StringBuilder(); \n     if (labels !\u003d null) {\n       for (String s : labels) {\n         labelStrBuilder.append(s);\n         labelStrBuilder.append(\",\");\n       }\n     }\n \n     LOG.info(\"Initializing \" + queueName + \"\\n\" +\n         \"capacity \u003d \" + capacity +\n         \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n         \"asboluteCapacity \u003d \" + absoluteCapacity +\n         \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n         \"maxCapacity \u003d \" + maximumCapacity +\n         \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n         \"absoluteMaxCapacity \u003d \" + absoluteMaxCapacity +\n         \" [\u003d 1.0 maximumCapacity undefined, \" +\n         \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n         \"\\n\" +\n         \"userLimit \u003d \" + userLimit +\n         \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n         \"userLimitFactor \u003d \" + userLimitFactor +\n         \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n         \"maxApplications \u003d \" + maxApplications +\n         \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n         \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n         \"\\n\" +\n         \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n         \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n         \"userLimitFactor) ]\" + \"\\n\" +\n-        \"maxActiveApplications \u003d \" + maxActiveApplications +\n-        \" [\u003d max(\" + \n-        \"(int)ceil((clusterResourceMemory / minimumAllocation) * \" + \n-        \"maxAMResourcePerQueuePercent * absoluteMaxCapacity),\" + \n-        \"1) ]\" + \"\\n\" +\n-        \"maxActiveAppsUsingAbsCap \u003d \" + maxActiveAppsUsingAbsCap +\n-        \" [\u003d max(\" + \n-        \"(int)ceil((clusterResourceMemory / minimumAllocation) *\" + \n-        \"maxAMResourcePercent * absoluteCapacity),\" + \n-        \"1) ]\" + \"\\n\" +\n-        \"maxActiveApplicationsPerUser \u003d \" + maxActiveApplicationsPerUser +\n-        \" [\u003d max(\" +\n-        \"(int)(maxActiveApplications * (userLimit / 100.0f) * \" +\n-        \"userLimitFactor),\" +\n-        \"1) ]\" + \"\\n\" +\n         \"usedCapacity \u003d \" + usedCapacity +\n         \" [\u003d usedResourcesMemory / \" +\n         \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n         \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n         \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n         \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n         \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n         \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n         \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n         \"maximumAllocationMemory ]\" + \"\\n\" +\n         \"numContainers \u003d \" + numContainers +\n         \" [\u003d currentNumContainers ]\" + \"\\n\" +\n         \"state \u003d \" + state +\n         \" [\u003d configuredState ]\" + \"\\n\" +\n         \"acls \u003d \" + aclsString +\n         \" [\u003d configuredAcls ]\" + \"\\n\" + \n         \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\" +\n         \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\" +\n         \"nodeLocalityDelay \u003d \" +  nodeLocalityDelay + \"\\n\" +\n         \"reservationsContinueLooking \u003d \" +\n         reservationsContinueLooking + \"\\n\");\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected synchronized void setupQueueConfigs(\n      Resource clusterResource,\n      float capacity, float absoluteCapacity, \n      float maximumCapacity, float absoluteMaxCapacity,\n      int userLimit, float userLimitFactor,\n      int maxApplications, float maxAMResourcePerQueuePercent,\n      int maxApplicationsPerUser, QueueState state,\n      Map\u003cQueueACL, AccessControlList\u003e acls, int nodeLocalityDelay,\n      Set\u003cString\u003e labels, String defaultLabelExpression,\n      Map\u003cString, Float\u003e capacitieByLabel,\n      Map\u003cString, Float\u003e maximumCapacitiesByLabel, \n      boolean revervationContinueLooking) throws IOException {\n    super.setupQueueConfigs(clusterResource, capacity, absoluteCapacity,\n        maximumCapacity, absoluteMaxCapacity, state, acls, labels,\n        defaultLabelExpression, capacitieByLabel, maximumCapacitiesByLabel,\n        revervationContinueLooking);\n    // Sanity check\n    CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n    float absCapacity \u003d getParent().getAbsoluteCapacity() * capacity;\n    CSQueueUtils.checkAbsoluteCapacity(getQueueName(), absCapacity,\n        absoluteMaxCapacity);\n    \n    this.lastClusterResource \u003d clusterResource;\n    updateAbsoluteCapacityResource(clusterResource);\n    \n    // Initialize headroom info, also used for calculating application \n    // master resource limits.  Since this happens during queue initialization\n    // and all queues may not be realized yet, we\u0027ll use (optimistic) \n    // absoluteMaxCapacity (it will be replaced with the more accurate \n    // absoluteMaxAvailCapacity during headroom/userlimit/allocation events)\n    updateHeadroomInfo(clusterResource, absoluteMaxCapacity);\n\n    this.absoluteCapacity \u003d absCapacity;\n\n    this.userLimit \u003d userLimit;\n    this.userLimitFactor \u003d userLimitFactor;\n\n    this.maxApplications \u003d maxApplications;\n    this.maxAMResourcePerQueuePercent \u003d maxAMResourcePerQueuePercent;\n    this.maxApplicationsPerUser \u003d maxApplicationsPerUser;\n\n    if (!SchedulerUtils.checkQueueLabelExpression(this.accessibleLabels,\n        this.defaultLabelExpression)) {\n      throw new IOException(\"Invalid default label expression of \"\n          + \" queue\u003d\"\n          + getQueueName()\n          + \" doesn\u0027t have permission to access all labels \"\n          + \"in default label expression. labelExpression of resource request\u003d\"\n          + (this.defaultLabelExpression \u003d\u003d null ? \"\"\n              : this.defaultLabelExpression)\n          + \". Queue labels\u003d\"\n          + (getAccessibleNodeLabels() \u003d\u003d null ? \"\" : StringUtils.join(\n              getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n    }\n    \n    this.nodeLocalityDelay \u003d nodeLocalityDelay;\n\n    StringBuilder aclsString \u003d new StringBuilder();\n    for (Map.Entry\u003cQueueACL, AccessControlList\u003e e : acls.entrySet()) {\n      aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n    }\n\n    StringBuilder labelStrBuilder \u003d new StringBuilder(); \n    if (labels !\u003d null) {\n      for (String s : labels) {\n        labelStrBuilder.append(s);\n        labelStrBuilder.append(\",\");\n      }\n    }\n\n    LOG.info(\"Initializing \" + queueName + \"\\n\" +\n        \"capacity \u003d \" + capacity +\n        \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n        \"asboluteCapacity \u003d \" + absoluteCapacity +\n        \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n        \"maxCapacity \u003d \" + maximumCapacity +\n        \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n        \"absoluteMaxCapacity \u003d \" + absoluteMaxCapacity +\n        \" [\u003d 1.0 maximumCapacity undefined, \" +\n        \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n        \"\\n\" +\n        \"userLimit \u003d \" + userLimit +\n        \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n        \"userLimitFactor \u003d \" + userLimitFactor +\n        \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n        \"maxApplications \u003d \" + maxApplications +\n        \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n        \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n        \"\\n\" +\n        \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n        \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n        \"userLimitFactor) ]\" + \"\\n\" +\n        \"usedCapacity \u003d \" + usedCapacity +\n        \" [\u003d usedResourcesMemory / \" +\n        \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n        \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n        \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n        \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n        \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n        \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n        \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n        \"maximumAllocationMemory ]\" + \"\\n\" +\n        \"numContainers \u003d \" + numContainers +\n        \" [\u003d currentNumContainers ]\" + \"\\n\" +\n        \"state \u003d \" + state +\n        \" [\u003d configuredState ]\" + \"\\n\" +\n        \"acls \u003d \" + aclsString +\n        \" [\u003d configuredAcls ]\" + \"\\n\" + \n        \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\" +\n        \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\" +\n        \"nodeLocalityDelay \u003d \" +  nodeLocalityDelay + \"\\n\" +\n        \"reservationsContinueLooking \u003d \" +\n        reservationsContinueLooking + \"\\n\");\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {}
        }
      ]
    },
    "dd57c2047bfd21910acc38c98153eedf1db75169": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2978. Fixed potential NPE while getting queue info. Contributed by Varun Saxena\n",
      "commitDate": "06/01/15 2:15 PM",
      "commitName": "dd57c2047bfd21910acc38c98153eedf1db75169",
      "commitAuthor": "Jian He",
      "commitDateOld": "04/01/15 7:08 AM",
      "commitNameOld": "ddc5be48fc35868abf7f59088f747c636e76a42a",
      "commitAuthorOld": "Tsuyoshi Ozawa",
      "daysBetweenCommits": 2.3,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,123 +1,123 @@\n   protected synchronized void setupQueueConfigs(\n       Resource clusterResource,\n       float capacity, float absoluteCapacity, \n       float maximumCapacity, float absoluteMaxCapacity,\n       int userLimit, float userLimitFactor,\n       int maxApplications, float maxAMResourcePerQueuePercent,\n       int maxApplicationsPerUser, int maxActiveApplications,\n       int maxActiveApplicationsPerUser, QueueState state,\n       Map\u003cQueueACL, AccessControlList\u003e acls, int nodeLocalityDelay,\n       Set\u003cString\u003e labels, String defaultLabelExpression,\n       Map\u003cString, Float\u003e capacitieByLabel,\n       Map\u003cString, Float\u003e maximumCapacitiesByLabel, \n       boolean revervationContinueLooking) throws IOException {\n     super.setupQueueConfigs(clusterResource, capacity, absoluteCapacity,\n         maximumCapacity, absoluteMaxCapacity, state, acls, labels,\n         defaultLabelExpression, capacitieByLabel, maximumCapacitiesByLabel,\n         revervationContinueLooking);\n     // Sanity check\n     CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n     float absCapacity \u003d getParent().getAbsoluteCapacity() * capacity;\n     CSQueueUtils.checkAbsoluteCapacity(getQueueName(), absCapacity,\n         absoluteMaxCapacity);\n \n     this.absoluteCapacity \u003d absCapacity;\n \n     this.userLimit \u003d userLimit;\n     this.userLimitFactor \u003d userLimitFactor;\n \n     this.maxApplications \u003d maxApplications;\n     this.maxAMResourcePerQueuePercent \u003d maxAMResourcePerQueuePercent;\n     this.maxApplicationsPerUser \u003d maxApplicationsPerUser;\n \n     this.maxActiveApplications \u003d maxActiveApplications;\n     this.maxActiveApplicationsPerUser \u003d maxActiveApplicationsPerUser;\n \n     if (!SchedulerUtils.checkQueueLabelExpression(this.accessibleLabels,\n         this.defaultLabelExpression)) {\n       throw new IOException(\"Invalid default label expression of \"\n           + \" queue\u003d\"\n-          + queueInfo.getQueueName()\n+          + getQueueName()\n           + \" doesn\u0027t have permission to access all labels \"\n           + \"in default label expression. labelExpression of resource request\u003d\"\n           + (this.defaultLabelExpression \u003d\u003d null ? \"\"\n               : this.defaultLabelExpression)\n           + \". Queue labels\u003d\"\n-          + (queueInfo.getAccessibleNodeLabels() \u003d\u003d null ? \"\" : StringUtils.join(queueInfo\n-              .getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n+          + (getAccessibleNodeLabels() \u003d\u003d null ? \"\" : StringUtils.join(\n+              getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n     }\n     \n     this.nodeLocalityDelay \u003d nodeLocalityDelay;\n \n     StringBuilder aclsString \u003d new StringBuilder();\n     for (Map.Entry\u003cQueueACL, AccessControlList\u003e e : acls.entrySet()) {\n       aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n     }\n \n     StringBuilder labelStrBuilder \u003d new StringBuilder(); \n     if (labels !\u003d null) {\n       for (String s : labels) {\n         labelStrBuilder.append(s);\n         labelStrBuilder.append(\",\");\n       }\n     }\n \n     LOG.info(\"Initializing \" + queueName + \"\\n\" +\n         \"capacity \u003d \" + capacity +\n         \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n         \"asboluteCapacity \u003d \" + absoluteCapacity +\n         \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n         \"maxCapacity \u003d \" + maximumCapacity +\n         \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n         \"absoluteMaxCapacity \u003d \" + absoluteMaxCapacity +\n         \" [\u003d 1.0 maximumCapacity undefined, \" +\n         \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n         \"\\n\" +\n         \"userLimit \u003d \" + userLimit +\n         \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n         \"userLimitFactor \u003d \" + userLimitFactor +\n         \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n         \"maxApplications \u003d \" + maxApplications +\n         \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n         \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n         \"\\n\" +\n         \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n         \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n         \"userLimitFactor) ]\" + \"\\n\" +\n         \"maxActiveApplications \u003d \" + maxActiveApplications +\n         \" [\u003d max(\" + \n         \"(int)ceil((clusterResourceMemory / minimumAllocation) * \" + \n         \"maxAMResourcePerQueuePercent * absoluteMaxCapacity),\" + \n         \"1) ]\" + \"\\n\" +\n         \"maxActiveAppsUsingAbsCap \u003d \" + maxActiveAppsUsingAbsCap +\n         \" [\u003d max(\" + \n         \"(int)ceil((clusterResourceMemory / minimumAllocation) *\" + \n         \"maxAMResourcePercent * absoluteCapacity),\" + \n         \"1) ]\" + \"\\n\" +\n         \"maxActiveApplicationsPerUser \u003d \" + maxActiveApplicationsPerUser +\n         \" [\u003d max(\" +\n         \"(int)(maxActiveApplications * (userLimit / 100.0f) * \" +\n         \"userLimitFactor),\" +\n         \"1) ]\" + \"\\n\" +\n         \"usedCapacity \u003d \" + usedCapacity +\n         \" [\u003d usedResourcesMemory / \" +\n         \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n         \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n         \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n         \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n         \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n         \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n         \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n         \"maximumAllocationMemory ]\" + \"\\n\" +\n         \"numContainers \u003d \" + numContainers +\n         \" [\u003d currentNumContainers ]\" + \"\\n\" +\n         \"state \u003d \" + state +\n         \" [\u003d configuredState ]\" + \"\\n\" +\n         \"acls \u003d \" + aclsString +\n         \" [\u003d configuredAcls ]\" + \"\\n\" + \n         \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\" +\n         \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\" +\n         \"nodeLocalityDelay \u003d \" +  nodeLocalityDelay + \"\\n\" +\n         \"reservationsContinueLooking \u003d \" +\n         reservationsContinueLooking + \"\\n\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void setupQueueConfigs(\n      Resource clusterResource,\n      float capacity, float absoluteCapacity, \n      float maximumCapacity, float absoluteMaxCapacity,\n      int userLimit, float userLimitFactor,\n      int maxApplications, float maxAMResourcePerQueuePercent,\n      int maxApplicationsPerUser, int maxActiveApplications,\n      int maxActiveApplicationsPerUser, QueueState state,\n      Map\u003cQueueACL, AccessControlList\u003e acls, int nodeLocalityDelay,\n      Set\u003cString\u003e labels, String defaultLabelExpression,\n      Map\u003cString, Float\u003e capacitieByLabel,\n      Map\u003cString, Float\u003e maximumCapacitiesByLabel, \n      boolean revervationContinueLooking) throws IOException {\n    super.setupQueueConfigs(clusterResource, capacity, absoluteCapacity,\n        maximumCapacity, absoluteMaxCapacity, state, acls, labels,\n        defaultLabelExpression, capacitieByLabel, maximumCapacitiesByLabel,\n        revervationContinueLooking);\n    // Sanity check\n    CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n    float absCapacity \u003d getParent().getAbsoluteCapacity() * capacity;\n    CSQueueUtils.checkAbsoluteCapacity(getQueueName(), absCapacity,\n        absoluteMaxCapacity);\n\n    this.absoluteCapacity \u003d absCapacity;\n\n    this.userLimit \u003d userLimit;\n    this.userLimitFactor \u003d userLimitFactor;\n\n    this.maxApplications \u003d maxApplications;\n    this.maxAMResourcePerQueuePercent \u003d maxAMResourcePerQueuePercent;\n    this.maxApplicationsPerUser \u003d maxApplicationsPerUser;\n\n    this.maxActiveApplications \u003d maxActiveApplications;\n    this.maxActiveApplicationsPerUser \u003d maxActiveApplicationsPerUser;\n\n    if (!SchedulerUtils.checkQueueLabelExpression(this.accessibleLabels,\n        this.defaultLabelExpression)) {\n      throw new IOException(\"Invalid default label expression of \"\n          + \" queue\u003d\"\n          + getQueueName()\n          + \" doesn\u0027t have permission to access all labels \"\n          + \"in default label expression. labelExpression of resource request\u003d\"\n          + (this.defaultLabelExpression \u003d\u003d null ? \"\"\n              : this.defaultLabelExpression)\n          + \". Queue labels\u003d\"\n          + (getAccessibleNodeLabels() \u003d\u003d null ? \"\" : StringUtils.join(\n              getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n    }\n    \n    this.nodeLocalityDelay \u003d nodeLocalityDelay;\n\n    StringBuilder aclsString \u003d new StringBuilder();\n    for (Map.Entry\u003cQueueACL, AccessControlList\u003e e : acls.entrySet()) {\n      aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n    }\n\n    StringBuilder labelStrBuilder \u003d new StringBuilder(); \n    if (labels !\u003d null) {\n      for (String s : labels) {\n        labelStrBuilder.append(s);\n        labelStrBuilder.append(\",\");\n      }\n    }\n\n    LOG.info(\"Initializing \" + queueName + \"\\n\" +\n        \"capacity \u003d \" + capacity +\n        \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n        \"asboluteCapacity \u003d \" + absoluteCapacity +\n        \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n        \"maxCapacity \u003d \" + maximumCapacity +\n        \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n        \"absoluteMaxCapacity \u003d \" + absoluteMaxCapacity +\n        \" [\u003d 1.0 maximumCapacity undefined, \" +\n        \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n        \"\\n\" +\n        \"userLimit \u003d \" + userLimit +\n        \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n        \"userLimitFactor \u003d \" + userLimitFactor +\n        \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n        \"maxApplications \u003d \" + maxApplications +\n        \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n        \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n        \"\\n\" +\n        \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n        \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n        \"userLimitFactor) ]\" + \"\\n\" +\n        \"maxActiveApplications \u003d \" + maxActiveApplications +\n        \" [\u003d max(\" + \n        \"(int)ceil((clusterResourceMemory / minimumAllocation) * \" + \n        \"maxAMResourcePerQueuePercent * absoluteMaxCapacity),\" + \n        \"1) ]\" + \"\\n\" +\n        \"maxActiveAppsUsingAbsCap \u003d \" + maxActiveAppsUsingAbsCap +\n        \" [\u003d max(\" + \n        \"(int)ceil((clusterResourceMemory / minimumAllocation) *\" + \n        \"maxAMResourcePercent * absoluteCapacity),\" + \n        \"1) ]\" + \"\\n\" +\n        \"maxActiveApplicationsPerUser \u003d \" + maxActiveApplicationsPerUser +\n        \" [\u003d max(\" +\n        \"(int)(maxActiveApplications * (userLimit / 100.0f) * \" +\n        \"userLimitFactor),\" +\n        \"1) ]\" + \"\\n\" +\n        \"usedCapacity \u003d \" + usedCapacity +\n        \" [\u003d usedResourcesMemory / \" +\n        \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n        \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n        \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n        \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n        \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n        \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n        \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n        \"maximumAllocationMemory ]\" + \"\\n\" +\n        \"numContainers \u003d \" + numContainers +\n        \" [\u003d currentNumContainers ]\" + \"\\n\" +\n        \"state \u003d \" + state +\n        \" [\u003d configuredState ]\" + \"\\n\" +\n        \"acls \u003d \" + aclsString +\n        \" [\u003d configuredAcls ]\" + \"\\n\" + \n        \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\" +\n        \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\" +\n        \"nodeLocalityDelay \u003d \" +  nodeLocalityDelay + \"\\n\" +\n        \"reservationsContinueLooking \u003d \" +\n        reservationsContinueLooking + \"\\n\");\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "f2ea555ac6c06a3f2f6559731f48711fff05d3f1": {
      "type": "Ymultichange(Yparameterchange,Yexceptionschange,Ybodychange)",
      "commitMessage": "YARN-2496. Enhanced Capacity Scheduler to have basic support for allocating resources based on node-labels. Contributed by Wangda Tan.\nYARN-2500. Ehnaced ResourceManager to support schedulers allocating resources based on node-labels. Contributed by Wangda Tan.\n",
      "commitDate": "15/10/14 6:33 PM",
      "commitName": "f2ea555ac6c06a3f2f6559731f48711fff05d3f1",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-2496. Enhanced Capacity Scheduler to have basic support for allocating resources based on node-labels. Contributed by Wangda Tan.\nYARN-2500. Ehnaced ResourceManager to support schedulers allocating resources based on node-labels. Contributed by Wangda Tan.\n",
          "commitDate": "15/10/14 6:33 PM",
          "commitName": "f2ea555ac6c06a3f2f6559731f48711fff05d3f1",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "07/10/14 1:45 PM",
          "commitNameOld": "30d56fdbb40d06c4e267d6c314c8c767a7adc6a3",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 8.2,
          "commitsBetweenForRepo": 71,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,110 +1,123 @@\n   protected synchronized void setupQueueConfigs(\n       Resource clusterResource,\n       float capacity, float absoluteCapacity, \n       float maximumCapacity, float absoluteMaxCapacity,\n       int userLimit, float userLimitFactor,\n       int maxApplications, float maxAMResourcePerQueuePercent,\n       int maxApplicationsPerUser, int maxActiveApplications,\n       int maxActiveApplicationsPerUser, QueueState state,\n       Map\u003cQueueACL, AccessControlList\u003e acls, int nodeLocalityDelay,\n-      boolean continueLooking)\n-  {\n+      Set\u003cString\u003e labels, String defaultLabelExpression,\n+      Map\u003cString, Float\u003e capacitieByLabel,\n+      Map\u003cString, Float\u003e maximumCapacitiesByLabel, \n+      boolean revervationContinueLooking) throws IOException {\n+    super.setupQueueConfigs(clusterResource, capacity, absoluteCapacity,\n+        maximumCapacity, absoluteMaxCapacity, state, acls, labels,\n+        defaultLabelExpression, capacitieByLabel, maximumCapacitiesByLabel,\n+        revervationContinueLooking);\n     // Sanity check\n     CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n     float absCapacity \u003d getParent().getAbsoluteCapacity() * capacity;\n-    CSQueueUtils.checkAbsoluteCapacities(getQueueName(), absCapacity, absoluteMaxCapacity);\n+    CSQueueUtils.checkAbsoluteCapacity(getQueueName(), absCapacity,\n+        absoluteMaxCapacity);\n \n-    this.capacity \u003d capacity; \n     this.absoluteCapacity \u003d absCapacity;\n \n-    this.maximumCapacity \u003d maximumCapacity;\n-    this.absoluteMaxCapacity \u003d absoluteMaxCapacity;\n-\n     this.userLimit \u003d userLimit;\n     this.userLimitFactor \u003d userLimitFactor;\n \n     this.maxApplications \u003d maxApplications;\n     this.maxAMResourcePerQueuePercent \u003d maxAMResourcePerQueuePercent;\n     this.maxApplicationsPerUser \u003d maxApplicationsPerUser;\n \n     this.maxActiveApplications \u003d maxActiveApplications;\n     this.maxActiveApplicationsPerUser \u003d maxActiveApplicationsPerUser;\n-    \n-    this.state \u003d state;\n \n-    this.acls \u003d acls;\n-\n-    this.queueInfo.setCapacity(this.capacity);\n-    this.queueInfo.setMaximumCapacity(this.maximumCapacity);\n-    this.queueInfo.setQueueState(this.state);\n+    if (!SchedulerUtils.checkQueueLabelExpression(this.accessibleLabels,\n+        this.defaultLabelExpression)) {\n+      throw new IOException(\"Invalid default label expression of \"\n+          + \" queue\u003d\"\n+          + queueInfo.getQueueName()\n+          + \" doesn\u0027t have permission to access all labels \"\n+          + \"in default label expression. labelExpression of resource request\u003d\"\n+          + (this.defaultLabelExpression \u003d\u003d null ? \"\"\n+              : this.defaultLabelExpression)\n+          + \". Queue labels\u003d\"\n+          + (queueInfo.getAccessibleNodeLabels() \u003d\u003d null ? \"\" : StringUtils.join(queueInfo\n+              .getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n+    }\n     \n     this.nodeLocalityDelay \u003d nodeLocalityDelay;\n-    this.reservationsContinueLooking \u003d continueLooking;\n \n     StringBuilder aclsString \u003d new StringBuilder();\n     for (Map.Entry\u003cQueueACL, AccessControlList\u003e e : acls.entrySet()) {\n       aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n     }\n-    \n-    // Update metrics\n-    CSQueueUtils.updateQueueStatistics(\n-        resourceCalculator, this, getParent(), clusterResource, \n-        minimumAllocation);\n+\n+    StringBuilder labelStrBuilder \u003d new StringBuilder(); \n+    if (labels !\u003d null) {\n+      for (String s : labels) {\n+        labelStrBuilder.append(s);\n+        labelStrBuilder.append(\",\");\n+      }\n+    }\n \n     LOG.info(\"Initializing \" + queueName + \"\\n\" +\n         \"capacity \u003d \" + capacity +\n         \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n         \"asboluteCapacity \u003d \" + absoluteCapacity +\n         \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n         \"maxCapacity \u003d \" + maximumCapacity +\n         \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n         \"absoluteMaxCapacity \u003d \" + absoluteMaxCapacity +\n         \" [\u003d 1.0 maximumCapacity undefined, \" +\n         \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n         \"\\n\" +\n         \"userLimit \u003d \" + userLimit +\n         \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n         \"userLimitFactor \u003d \" + userLimitFactor +\n         \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n         \"maxApplications \u003d \" + maxApplications +\n         \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n         \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n         \"\\n\" +\n         \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n         \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n         \"userLimitFactor) ]\" + \"\\n\" +\n         \"maxActiveApplications \u003d \" + maxActiveApplications +\n         \" [\u003d max(\" + \n         \"(int)ceil((clusterResourceMemory / minimumAllocation) * \" + \n         \"maxAMResourcePerQueuePercent * absoluteMaxCapacity),\" + \n         \"1) ]\" + \"\\n\" +\n         \"maxActiveAppsUsingAbsCap \u003d \" + maxActiveAppsUsingAbsCap +\n         \" [\u003d max(\" + \n         \"(int)ceil((clusterResourceMemory / minimumAllocation) *\" + \n         \"maxAMResourcePercent * absoluteCapacity),\" + \n         \"1) ]\" + \"\\n\" +\n         \"maxActiveApplicationsPerUser \u003d \" + maxActiveApplicationsPerUser +\n         \" [\u003d max(\" +\n         \"(int)(maxActiveApplications * (userLimit / 100.0f) * \" +\n         \"userLimitFactor),\" +\n         \"1) ]\" + \"\\n\" +\n         \"usedCapacity \u003d \" + usedCapacity +\n         \" [\u003d usedResourcesMemory / \" +\n         \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n         \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n         \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n         \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n         \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n         \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n         \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n         \"maximumAllocationMemory ]\" + \"\\n\" +\n         \"numContainers \u003d \" + numContainers +\n         \" [\u003d currentNumContainers ]\" + \"\\n\" +\n         \"state \u003d \" + state +\n         \" [\u003d configuredState ]\" + \"\\n\" +\n         \"acls \u003d \" + aclsString +\n         \" [\u003d configuredAcls ]\" + \"\\n\" + \n+        \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\" +\n+        \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\" +\n         \"nodeLocalityDelay \u003d \" +  nodeLocalityDelay + \"\\n\" +\n         \"reservationsContinueLooking \u003d \" +\n         reservationsContinueLooking + \"\\n\");\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected synchronized void setupQueueConfigs(\n      Resource clusterResource,\n      float capacity, float absoluteCapacity, \n      float maximumCapacity, float absoluteMaxCapacity,\n      int userLimit, float userLimitFactor,\n      int maxApplications, float maxAMResourcePerQueuePercent,\n      int maxApplicationsPerUser, int maxActiveApplications,\n      int maxActiveApplicationsPerUser, QueueState state,\n      Map\u003cQueueACL, AccessControlList\u003e acls, int nodeLocalityDelay,\n      Set\u003cString\u003e labels, String defaultLabelExpression,\n      Map\u003cString, Float\u003e capacitieByLabel,\n      Map\u003cString, Float\u003e maximumCapacitiesByLabel, \n      boolean revervationContinueLooking) throws IOException {\n    super.setupQueueConfigs(clusterResource, capacity, absoluteCapacity,\n        maximumCapacity, absoluteMaxCapacity, state, acls, labels,\n        defaultLabelExpression, capacitieByLabel, maximumCapacitiesByLabel,\n        revervationContinueLooking);\n    // Sanity check\n    CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n    float absCapacity \u003d getParent().getAbsoluteCapacity() * capacity;\n    CSQueueUtils.checkAbsoluteCapacity(getQueueName(), absCapacity,\n        absoluteMaxCapacity);\n\n    this.absoluteCapacity \u003d absCapacity;\n\n    this.userLimit \u003d userLimit;\n    this.userLimitFactor \u003d userLimitFactor;\n\n    this.maxApplications \u003d maxApplications;\n    this.maxAMResourcePerQueuePercent \u003d maxAMResourcePerQueuePercent;\n    this.maxApplicationsPerUser \u003d maxApplicationsPerUser;\n\n    this.maxActiveApplications \u003d maxActiveApplications;\n    this.maxActiveApplicationsPerUser \u003d maxActiveApplicationsPerUser;\n\n    if (!SchedulerUtils.checkQueueLabelExpression(this.accessibleLabels,\n        this.defaultLabelExpression)) {\n      throw new IOException(\"Invalid default label expression of \"\n          + \" queue\u003d\"\n          + queueInfo.getQueueName()\n          + \" doesn\u0027t have permission to access all labels \"\n          + \"in default label expression. labelExpression of resource request\u003d\"\n          + (this.defaultLabelExpression \u003d\u003d null ? \"\"\n              : this.defaultLabelExpression)\n          + \". Queue labels\u003d\"\n          + (queueInfo.getAccessibleNodeLabels() \u003d\u003d null ? \"\" : StringUtils.join(queueInfo\n              .getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n    }\n    \n    this.nodeLocalityDelay \u003d nodeLocalityDelay;\n\n    StringBuilder aclsString \u003d new StringBuilder();\n    for (Map.Entry\u003cQueueACL, AccessControlList\u003e e : acls.entrySet()) {\n      aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n    }\n\n    StringBuilder labelStrBuilder \u003d new StringBuilder(); \n    if (labels !\u003d null) {\n      for (String s : labels) {\n        labelStrBuilder.append(s);\n        labelStrBuilder.append(\",\");\n      }\n    }\n\n    LOG.info(\"Initializing \" + queueName + \"\\n\" +\n        \"capacity \u003d \" + capacity +\n        \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n        \"asboluteCapacity \u003d \" + absoluteCapacity +\n        \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n        \"maxCapacity \u003d \" + maximumCapacity +\n        \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n        \"absoluteMaxCapacity \u003d \" + absoluteMaxCapacity +\n        \" [\u003d 1.0 maximumCapacity undefined, \" +\n        \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n        \"\\n\" +\n        \"userLimit \u003d \" + userLimit +\n        \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n        \"userLimitFactor \u003d \" + userLimitFactor +\n        \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n        \"maxApplications \u003d \" + maxApplications +\n        \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n        \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n        \"\\n\" +\n        \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n        \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n        \"userLimitFactor) ]\" + \"\\n\" +\n        \"maxActiveApplications \u003d \" + maxActiveApplications +\n        \" [\u003d max(\" + \n        \"(int)ceil((clusterResourceMemory / minimumAllocation) * \" + \n        \"maxAMResourcePerQueuePercent * absoluteMaxCapacity),\" + \n        \"1) ]\" + \"\\n\" +\n        \"maxActiveAppsUsingAbsCap \u003d \" + maxActiveAppsUsingAbsCap +\n        \" [\u003d max(\" + \n        \"(int)ceil((clusterResourceMemory / minimumAllocation) *\" + \n        \"maxAMResourcePercent * absoluteCapacity),\" + \n        \"1) ]\" + \"\\n\" +\n        \"maxActiveApplicationsPerUser \u003d \" + maxActiveApplicationsPerUser +\n        \" [\u003d max(\" +\n        \"(int)(maxActiveApplications * (userLimit / 100.0f) * \" +\n        \"userLimitFactor),\" +\n        \"1) ]\" + \"\\n\" +\n        \"usedCapacity \u003d \" + usedCapacity +\n        \" [\u003d usedResourcesMemory / \" +\n        \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n        \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n        \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n        \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n        \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n        \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n        \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n        \"maximumAllocationMemory ]\" + \"\\n\" +\n        \"numContainers \u003d \" + numContainers +\n        \" [\u003d currentNumContainers ]\" + \"\\n\" +\n        \"state \u003d \" + state +\n        \" [\u003d configuredState ]\" + \"\\n\" +\n        \"acls \u003d \" + aclsString +\n        \" [\u003d configuredAcls ]\" + \"\\n\" + \n        \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\" +\n        \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\" +\n        \"nodeLocalityDelay \u003d \" +  nodeLocalityDelay + \"\\n\" +\n        \"reservationsContinueLooking \u003d \" +\n        reservationsContinueLooking + \"\\n\");\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {
            "oldValue": "[clusterResource-Resource, capacity-float, absoluteCapacity-float, maximumCapacity-float, absoluteMaxCapacity-float, userLimit-int, userLimitFactor-float, maxApplications-int, maxAMResourcePerQueuePercent-float, maxApplicationsPerUser-int, maxActiveApplications-int, maxActiveApplicationsPerUser-int, state-QueueState, acls-Map\u003cQueueACL,AccessControlList\u003e, nodeLocalityDelay-int, continueLooking-boolean]",
            "newValue": "[clusterResource-Resource, capacity-float, absoluteCapacity-float, maximumCapacity-float, absoluteMaxCapacity-float, userLimit-int, userLimitFactor-float, maxApplications-int, maxAMResourcePerQueuePercent-float, maxApplicationsPerUser-int, maxActiveApplications-int, maxActiveApplicationsPerUser-int, state-QueueState, acls-Map\u003cQueueACL,AccessControlList\u003e, nodeLocalityDelay-int, labels-Set\u003cString\u003e, defaultLabelExpression-String, capacitieByLabel-Map\u003cString,Float\u003e, maximumCapacitiesByLabel-Map\u003cString,Float\u003e, revervationContinueLooking-boolean]"
          }
        },
        {
          "type": "Yexceptionschange",
          "commitMessage": "YARN-2496. Enhanced Capacity Scheduler to have basic support for allocating resources based on node-labels. Contributed by Wangda Tan.\nYARN-2500. Ehnaced ResourceManager to support schedulers allocating resources based on node-labels. Contributed by Wangda Tan.\n",
          "commitDate": "15/10/14 6:33 PM",
          "commitName": "f2ea555ac6c06a3f2f6559731f48711fff05d3f1",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "07/10/14 1:45 PM",
          "commitNameOld": "30d56fdbb40d06c4e267d6c314c8c767a7adc6a3",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 8.2,
          "commitsBetweenForRepo": 71,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,110 +1,123 @@\n   protected synchronized void setupQueueConfigs(\n       Resource clusterResource,\n       float capacity, float absoluteCapacity, \n       float maximumCapacity, float absoluteMaxCapacity,\n       int userLimit, float userLimitFactor,\n       int maxApplications, float maxAMResourcePerQueuePercent,\n       int maxApplicationsPerUser, int maxActiveApplications,\n       int maxActiveApplicationsPerUser, QueueState state,\n       Map\u003cQueueACL, AccessControlList\u003e acls, int nodeLocalityDelay,\n-      boolean continueLooking)\n-  {\n+      Set\u003cString\u003e labels, String defaultLabelExpression,\n+      Map\u003cString, Float\u003e capacitieByLabel,\n+      Map\u003cString, Float\u003e maximumCapacitiesByLabel, \n+      boolean revervationContinueLooking) throws IOException {\n+    super.setupQueueConfigs(clusterResource, capacity, absoluteCapacity,\n+        maximumCapacity, absoluteMaxCapacity, state, acls, labels,\n+        defaultLabelExpression, capacitieByLabel, maximumCapacitiesByLabel,\n+        revervationContinueLooking);\n     // Sanity check\n     CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n     float absCapacity \u003d getParent().getAbsoluteCapacity() * capacity;\n-    CSQueueUtils.checkAbsoluteCapacities(getQueueName(), absCapacity, absoluteMaxCapacity);\n+    CSQueueUtils.checkAbsoluteCapacity(getQueueName(), absCapacity,\n+        absoluteMaxCapacity);\n \n-    this.capacity \u003d capacity; \n     this.absoluteCapacity \u003d absCapacity;\n \n-    this.maximumCapacity \u003d maximumCapacity;\n-    this.absoluteMaxCapacity \u003d absoluteMaxCapacity;\n-\n     this.userLimit \u003d userLimit;\n     this.userLimitFactor \u003d userLimitFactor;\n \n     this.maxApplications \u003d maxApplications;\n     this.maxAMResourcePerQueuePercent \u003d maxAMResourcePerQueuePercent;\n     this.maxApplicationsPerUser \u003d maxApplicationsPerUser;\n \n     this.maxActiveApplications \u003d maxActiveApplications;\n     this.maxActiveApplicationsPerUser \u003d maxActiveApplicationsPerUser;\n-    \n-    this.state \u003d state;\n \n-    this.acls \u003d acls;\n-\n-    this.queueInfo.setCapacity(this.capacity);\n-    this.queueInfo.setMaximumCapacity(this.maximumCapacity);\n-    this.queueInfo.setQueueState(this.state);\n+    if (!SchedulerUtils.checkQueueLabelExpression(this.accessibleLabels,\n+        this.defaultLabelExpression)) {\n+      throw new IOException(\"Invalid default label expression of \"\n+          + \" queue\u003d\"\n+          + queueInfo.getQueueName()\n+          + \" doesn\u0027t have permission to access all labels \"\n+          + \"in default label expression. labelExpression of resource request\u003d\"\n+          + (this.defaultLabelExpression \u003d\u003d null ? \"\"\n+              : this.defaultLabelExpression)\n+          + \". Queue labels\u003d\"\n+          + (queueInfo.getAccessibleNodeLabels() \u003d\u003d null ? \"\" : StringUtils.join(queueInfo\n+              .getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n+    }\n     \n     this.nodeLocalityDelay \u003d nodeLocalityDelay;\n-    this.reservationsContinueLooking \u003d continueLooking;\n \n     StringBuilder aclsString \u003d new StringBuilder();\n     for (Map.Entry\u003cQueueACL, AccessControlList\u003e e : acls.entrySet()) {\n       aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n     }\n-    \n-    // Update metrics\n-    CSQueueUtils.updateQueueStatistics(\n-        resourceCalculator, this, getParent(), clusterResource, \n-        minimumAllocation);\n+\n+    StringBuilder labelStrBuilder \u003d new StringBuilder(); \n+    if (labels !\u003d null) {\n+      for (String s : labels) {\n+        labelStrBuilder.append(s);\n+        labelStrBuilder.append(\",\");\n+      }\n+    }\n \n     LOG.info(\"Initializing \" + queueName + \"\\n\" +\n         \"capacity \u003d \" + capacity +\n         \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n         \"asboluteCapacity \u003d \" + absoluteCapacity +\n         \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n         \"maxCapacity \u003d \" + maximumCapacity +\n         \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n         \"absoluteMaxCapacity \u003d \" + absoluteMaxCapacity +\n         \" [\u003d 1.0 maximumCapacity undefined, \" +\n         \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n         \"\\n\" +\n         \"userLimit \u003d \" + userLimit +\n         \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n         \"userLimitFactor \u003d \" + userLimitFactor +\n         \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n         \"maxApplications \u003d \" + maxApplications +\n         \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n         \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n         \"\\n\" +\n         \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n         \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n         \"userLimitFactor) ]\" + \"\\n\" +\n         \"maxActiveApplications \u003d \" + maxActiveApplications +\n         \" [\u003d max(\" + \n         \"(int)ceil((clusterResourceMemory / minimumAllocation) * \" + \n         \"maxAMResourcePerQueuePercent * absoluteMaxCapacity),\" + \n         \"1) ]\" + \"\\n\" +\n         \"maxActiveAppsUsingAbsCap \u003d \" + maxActiveAppsUsingAbsCap +\n         \" [\u003d max(\" + \n         \"(int)ceil((clusterResourceMemory / minimumAllocation) *\" + \n         \"maxAMResourcePercent * absoluteCapacity),\" + \n         \"1) ]\" + \"\\n\" +\n         \"maxActiveApplicationsPerUser \u003d \" + maxActiveApplicationsPerUser +\n         \" [\u003d max(\" +\n         \"(int)(maxActiveApplications * (userLimit / 100.0f) * \" +\n         \"userLimitFactor),\" +\n         \"1) ]\" + \"\\n\" +\n         \"usedCapacity \u003d \" + usedCapacity +\n         \" [\u003d usedResourcesMemory / \" +\n         \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n         \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n         \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n         \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n         \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n         \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n         \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n         \"maximumAllocationMemory ]\" + \"\\n\" +\n         \"numContainers \u003d \" + numContainers +\n         \" [\u003d currentNumContainers ]\" + \"\\n\" +\n         \"state \u003d \" + state +\n         \" [\u003d configuredState ]\" + \"\\n\" +\n         \"acls \u003d \" + aclsString +\n         \" [\u003d configuredAcls ]\" + \"\\n\" + \n+        \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\" +\n+        \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\" +\n         \"nodeLocalityDelay \u003d \" +  nodeLocalityDelay + \"\\n\" +\n         \"reservationsContinueLooking \u003d \" +\n         reservationsContinueLooking + \"\\n\");\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected synchronized void setupQueueConfigs(\n      Resource clusterResource,\n      float capacity, float absoluteCapacity, \n      float maximumCapacity, float absoluteMaxCapacity,\n      int userLimit, float userLimitFactor,\n      int maxApplications, float maxAMResourcePerQueuePercent,\n      int maxApplicationsPerUser, int maxActiveApplications,\n      int maxActiveApplicationsPerUser, QueueState state,\n      Map\u003cQueueACL, AccessControlList\u003e acls, int nodeLocalityDelay,\n      Set\u003cString\u003e labels, String defaultLabelExpression,\n      Map\u003cString, Float\u003e capacitieByLabel,\n      Map\u003cString, Float\u003e maximumCapacitiesByLabel, \n      boolean revervationContinueLooking) throws IOException {\n    super.setupQueueConfigs(clusterResource, capacity, absoluteCapacity,\n        maximumCapacity, absoluteMaxCapacity, state, acls, labels,\n        defaultLabelExpression, capacitieByLabel, maximumCapacitiesByLabel,\n        revervationContinueLooking);\n    // Sanity check\n    CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n    float absCapacity \u003d getParent().getAbsoluteCapacity() * capacity;\n    CSQueueUtils.checkAbsoluteCapacity(getQueueName(), absCapacity,\n        absoluteMaxCapacity);\n\n    this.absoluteCapacity \u003d absCapacity;\n\n    this.userLimit \u003d userLimit;\n    this.userLimitFactor \u003d userLimitFactor;\n\n    this.maxApplications \u003d maxApplications;\n    this.maxAMResourcePerQueuePercent \u003d maxAMResourcePerQueuePercent;\n    this.maxApplicationsPerUser \u003d maxApplicationsPerUser;\n\n    this.maxActiveApplications \u003d maxActiveApplications;\n    this.maxActiveApplicationsPerUser \u003d maxActiveApplicationsPerUser;\n\n    if (!SchedulerUtils.checkQueueLabelExpression(this.accessibleLabels,\n        this.defaultLabelExpression)) {\n      throw new IOException(\"Invalid default label expression of \"\n          + \" queue\u003d\"\n          + queueInfo.getQueueName()\n          + \" doesn\u0027t have permission to access all labels \"\n          + \"in default label expression. labelExpression of resource request\u003d\"\n          + (this.defaultLabelExpression \u003d\u003d null ? \"\"\n              : this.defaultLabelExpression)\n          + \". Queue labels\u003d\"\n          + (queueInfo.getAccessibleNodeLabels() \u003d\u003d null ? \"\" : StringUtils.join(queueInfo\n              .getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n    }\n    \n    this.nodeLocalityDelay \u003d nodeLocalityDelay;\n\n    StringBuilder aclsString \u003d new StringBuilder();\n    for (Map.Entry\u003cQueueACL, AccessControlList\u003e e : acls.entrySet()) {\n      aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n    }\n\n    StringBuilder labelStrBuilder \u003d new StringBuilder(); \n    if (labels !\u003d null) {\n      for (String s : labels) {\n        labelStrBuilder.append(s);\n        labelStrBuilder.append(\",\");\n      }\n    }\n\n    LOG.info(\"Initializing \" + queueName + \"\\n\" +\n        \"capacity \u003d \" + capacity +\n        \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n        \"asboluteCapacity \u003d \" + absoluteCapacity +\n        \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n        \"maxCapacity \u003d \" + maximumCapacity +\n        \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n        \"absoluteMaxCapacity \u003d \" + absoluteMaxCapacity +\n        \" [\u003d 1.0 maximumCapacity undefined, \" +\n        \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n        \"\\n\" +\n        \"userLimit \u003d \" + userLimit +\n        \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n        \"userLimitFactor \u003d \" + userLimitFactor +\n        \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n        \"maxApplications \u003d \" + maxApplications +\n        \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n        \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n        \"\\n\" +\n        \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n        \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n        \"userLimitFactor) ]\" + \"\\n\" +\n        \"maxActiveApplications \u003d \" + maxActiveApplications +\n        \" [\u003d max(\" + \n        \"(int)ceil((clusterResourceMemory / minimumAllocation) * \" + \n        \"maxAMResourcePerQueuePercent * absoluteMaxCapacity),\" + \n        \"1) ]\" + \"\\n\" +\n        \"maxActiveAppsUsingAbsCap \u003d \" + maxActiveAppsUsingAbsCap +\n        \" [\u003d max(\" + \n        \"(int)ceil((clusterResourceMemory / minimumAllocation) *\" + \n        \"maxAMResourcePercent * absoluteCapacity),\" + \n        \"1) ]\" + \"\\n\" +\n        \"maxActiveApplicationsPerUser \u003d \" + maxActiveApplicationsPerUser +\n        \" [\u003d max(\" +\n        \"(int)(maxActiveApplications * (userLimit / 100.0f) * \" +\n        \"userLimitFactor),\" +\n        \"1) ]\" + \"\\n\" +\n        \"usedCapacity \u003d \" + usedCapacity +\n        \" [\u003d usedResourcesMemory / \" +\n        \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n        \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n        \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n        \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n        \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n        \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n        \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n        \"maximumAllocationMemory ]\" + \"\\n\" +\n        \"numContainers \u003d \" + numContainers +\n        \" [\u003d currentNumContainers ]\" + \"\\n\" +\n        \"state \u003d \" + state +\n        \" [\u003d configuredState ]\" + \"\\n\" +\n        \"acls \u003d \" + aclsString +\n        \" [\u003d configuredAcls ]\" + \"\\n\" + \n        \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\" +\n        \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\" +\n        \"nodeLocalityDelay \u003d \" +  nodeLocalityDelay + \"\\n\" +\n        \"reservationsContinueLooking \u003d \" +\n        reservationsContinueLooking + \"\\n\");\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[IOException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-2496. Enhanced Capacity Scheduler to have basic support for allocating resources based on node-labels. Contributed by Wangda Tan.\nYARN-2500. Ehnaced ResourceManager to support schedulers allocating resources based on node-labels. Contributed by Wangda Tan.\n",
          "commitDate": "15/10/14 6:33 PM",
          "commitName": "f2ea555ac6c06a3f2f6559731f48711fff05d3f1",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "07/10/14 1:45 PM",
          "commitNameOld": "30d56fdbb40d06c4e267d6c314c8c767a7adc6a3",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 8.2,
          "commitsBetweenForRepo": 71,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,110 +1,123 @@\n   protected synchronized void setupQueueConfigs(\n       Resource clusterResource,\n       float capacity, float absoluteCapacity, \n       float maximumCapacity, float absoluteMaxCapacity,\n       int userLimit, float userLimitFactor,\n       int maxApplications, float maxAMResourcePerQueuePercent,\n       int maxApplicationsPerUser, int maxActiveApplications,\n       int maxActiveApplicationsPerUser, QueueState state,\n       Map\u003cQueueACL, AccessControlList\u003e acls, int nodeLocalityDelay,\n-      boolean continueLooking)\n-  {\n+      Set\u003cString\u003e labels, String defaultLabelExpression,\n+      Map\u003cString, Float\u003e capacitieByLabel,\n+      Map\u003cString, Float\u003e maximumCapacitiesByLabel, \n+      boolean revervationContinueLooking) throws IOException {\n+    super.setupQueueConfigs(clusterResource, capacity, absoluteCapacity,\n+        maximumCapacity, absoluteMaxCapacity, state, acls, labels,\n+        defaultLabelExpression, capacitieByLabel, maximumCapacitiesByLabel,\n+        revervationContinueLooking);\n     // Sanity check\n     CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n     float absCapacity \u003d getParent().getAbsoluteCapacity() * capacity;\n-    CSQueueUtils.checkAbsoluteCapacities(getQueueName(), absCapacity, absoluteMaxCapacity);\n+    CSQueueUtils.checkAbsoluteCapacity(getQueueName(), absCapacity,\n+        absoluteMaxCapacity);\n \n-    this.capacity \u003d capacity; \n     this.absoluteCapacity \u003d absCapacity;\n \n-    this.maximumCapacity \u003d maximumCapacity;\n-    this.absoluteMaxCapacity \u003d absoluteMaxCapacity;\n-\n     this.userLimit \u003d userLimit;\n     this.userLimitFactor \u003d userLimitFactor;\n \n     this.maxApplications \u003d maxApplications;\n     this.maxAMResourcePerQueuePercent \u003d maxAMResourcePerQueuePercent;\n     this.maxApplicationsPerUser \u003d maxApplicationsPerUser;\n \n     this.maxActiveApplications \u003d maxActiveApplications;\n     this.maxActiveApplicationsPerUser \u003d maxActiveApplicationsPerUser;\n-    \n-    this.state \u003d state;\n \n-    this.acls \u003d acls;\n-\n-    this.queueInfo.setCapacity(this.capacity);\n-    this.queueInfo.setMaximumCapacity(this.maximumCapacity);\n-    this.queueInfo.setQueueState(this.state);\n+    if (!SchedulerUtils.checkQueueLabelExpression(this.accessibleLabels,\n+        this.defaultLabelExpression)) {\n+      throw new IOException(\"Invalid default label expression of \"\n+          + \" queue\u003d\"\n+          + queueInfo.getQueueName()\n+          + \" doesn\u0027t have permission to access all labels \"\n+          + \"in default label expression. labelExpression of resource request\u003d\"\n+          + (this.defaultLabelExpression \u003d\u003d null ? \"\"\n+              : this.defaultLabelExpression)\n+          + \". Queue labels\u003d\"\n+          + (queueInfo.getAccessibleNodeLabels() \u003d\u003d null ? \"\" : StringUtils.join(queueInfo\n+              .getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n+    }\n     \n     this.nodeLocalityDelay \u003d nodeLocalityDelay;\n-    this.reservationsContinueLooking \u003d continueLooking;\n \n     StringBuilder aclsString \u003d new StringBuilder();\n     for (Map.Entry\u003cQueueACL, AccessControlList\u003e e : acls.entrySet()) {\n       aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n     }\n-    \n-    // Update metrics\n-    CSQueueUtils.updateQueueStatistics(\n-        resourceCalculator, this, getParent(), clusterResource, \n-        minimumAllocation);\n+\n+    StringBuilder labelStrBuilder \u003d new StringBuilder(); \n+    if (labels !\u003d null) {\n+      for (String s : labels) {\n+        labelStrBuilder.append(s);\n+        labelStrBuilder.append(\",\");\n+      }\n+    }\n \n     LOG.info(\"Initializing \" + queueName + \"\\n\" +\n         \"capacity \u003d \" + capacity +\n         \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n         \"asboluteCapacity \u003d \" + absoluteCapacity +\n         \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n         \"maxCapacity \u003d \" + maximumCapacity +\n         \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n         \"absoluteMaxCapacity \u003d \" + absoluteMaxCapacity +\n         \" [\u003d 1.0 maximumCapacity undefined, \" +\n         \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n         \"\\n\" +\n         \"userLimit \u003d \" + userLimit +\n         \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n         \"userLimitFactor \u003d \" + userLimitFactor +\n         \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n         \"maxApplications \u003d \" + maxApplications +\n         \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n         \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n         \"\\n\" +\n         \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n         \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n         \"userLimitFactor) ]\" + \"\\n\" +\n         \"maxActiveApplications \u003d \" + maxActiveApplications +\n         \" [\u003d max(\" + \n         \"(int)ceil((clusterResourceMemory / minimumAllocation) * \" + \n         \"maxAMResourcePerQueuePercent * absoluteMaxCapacity),\" + \n         \"1) ]\" + \"\\n\" +\n         \"maxActiveAppsUsingAbsCap \u003d \" + maxActiveAppsUsingAbsCap +\n         \" [\u003d max(\" + \n         \"(int)ceil((clusterResourceMemory / minimumAllocation) *\" + \n         \"maxAMResourcePercent * absoluteCapacity),\" + \n         \"1) ]\" + \"\\n\" +\n         \"maxActiveApplicationsPerUser \u003d \" + maxActiveApplicationsPerUser +\n         \" [\u003d max(\" +\n         \"(int)(maxActiveApplications * (userLimit / 100.0f) * \" +\n         \"userLimitFactor),\" +\n         \"1) ]\" + \"\\n\" +\n         \"usedCapacity \u003d \" + usedCapacity +\n         \" [\u003d usedResourcesMemory / \" +\n         \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n         \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n         \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n         \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n         \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n         \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n         \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n         \"maximumAllocationMemory ]\" + \"\\n\" +\n         \"numContainers \u003d \" + numContainers +\n         \" [\u003d currentNumContainers ]\" + \"\\n\" +\n         \"state \u003d \" + state +\n         \" [\u003d configuredState ]\" + \"\\n\" +\n         \"acls \u003d \" + aclsString +\n         \" [\u003d configuredAcls ]\" + \"\\n\" + \n+        \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\" +\n+        \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\" +\n         \"nodeLocalityDelay \u003d \" +  nodeLocalityDelay + \"\\n\" +\n         \"reservationsContinueLooking \u003d \" +\n         reservationsContinueLooking + \"\\n\");\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected synchronized void setupQueueConfigs(\n      Resource clusterResource,\n      float capacity, float absoluteCapacity, \n      float maximumCapacity, float absoluteMaxCapacity,\n      int userLimit, float userLimitFactor,\n      int maxApplications, float maxAMResourcePerQueuePercent,\n      int maxApplicationsPerUser, int maxActiveApplications,\n      int maxActiveApplicationsPerUser, QueueState state,\n      Map\u003cQueueACL, AccessControlList\u003e acls, int nodeLocalityDelay,\n      Set\u003cString\u003e labels, String defaultLabelExpression,\n      Map\u003cString, Float\u003e capacitieByLabel,\n      Map\u003cString, Float\u003e maximumCapacitiesByLabel, \n      boolean revervationContinueLooking) throws IOException {\n    super.setupQueueConfigs(clusterResource, capacity, absoluteCapacity,\n        maximumCapacity, absoluteMaxCapacity, state, acls, labels,\n        defaultLabelExpression, capacitieByLabel, maximumCapacitiesByLabel,\n        revervationContinueLooking);\n    // Sanity check\n    CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n    float absCapacity \u003d getParent().getAbsoluteCapacity() * capacity;\n    CSQueueUtils.checkAbsoluteCapacity(getQueueName(), absCapacity,\n        absoluteMaxCapacity);\n\n    this.absoluteCapacity \u003d absCapacity;\n\n    this.userLimit \u003d userLimit;\n    this.userLimitFactor \u003d userLimitFactor;\n\n    this.maxApplications \u003d maxApplications;\n    this.maxAMResourcePerQueuePercent \u003d maxAMResourcePerQueuePercent;\n    this.maxApplicationsPerUser \u003d maxApplicationsPerUser;\n\n    this.maxActiveApplications \u003d maxActiveApplications;\n    this.maxActiveApplicationsPerUser \u003d maxActiveApplicationsPerUser;\n\n    if (!SchedulerUtils.checkQueueLabelExpression(this.accessibleLabels,\n        this.defaultLabelExpression)) {\n      throw new IOException(\"Invalid default label expression of \"\n          + \" queue\u003d\"\n          + queueInfo.getQueueName()\n          + \" doesn\u0027t have permission to access all labels \"\n          + \"in default label expression. labelExpression of resource request\u003d\"\n          + (this.defaultLabelExpression \u003d\u003d null ? \"\"\n              : this.defaultLabelExpression)\n          + \". Queue labels\u003d\"\n          + (queueInfo.getAccessibleNodeLabels() \u003d\u003d null ? \"\" : StringUtils.join(queueInfo\n              .getAccessibleNodeLabels().iterator(), \u0027,\u0027)));\n    }\n    \n    this.nodeLocalityDelay \u003d nodeLocalityDelay;\n\n    StringBuilder aclsString \u003d new StringBuilder();\n    for (Map.Entry\u003cQueueACL, AccessControlList\u003e e : acls.entrySet()) {\n      aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n    }\n\n    StringBuilder labelStrBuilder \u003d new StringBuilder(); \n    if (labels !\u003d null) {\n      for (String s : labels) {\n        labelStrBuilder.append(s);\n        labelStrBuilder.append(\",\");\n      }\n    }\n\n    LOG.info(\"Initializing \" + queueName + \"\\n\" +\n        \"capacity \u003d \" + capacity +\n        \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n        \"asboluteCapacity \u003d \" + absoluteCapacity +\n        \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n        \"maxCapacity \u003d \" + maximumCapacity +\n        \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n        \"absoluteMaxCapacity \u003d \" + absoluteMaxCapacity +\n        \" [\u003d 1.0 maximumCapacity undefined, \" +\n        \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n        \"\\n\" +\n        \"userLimit \u003d \" + userLimit +\n        \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n        \"userLimitFactor \u003d \" + userLimitFactor +\n        \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n        \"maxApplications \u003d \" + maxApplications +\n        \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n        \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n        \"\\n\" +\n        \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n        \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n        \"userLimitFactor) ]\" + \"\\n\" +\n        \"maxActiveApplications \u003d \" + maxActiveApplications +\n        \" [\u003d max(\" + \n        \"(int)ceil((clusterResourceMemory / minimumAllocation) * \" + \n        \"maxAMResourcePerQueuePercent * absoluteMaxCapacity),\" + \n        \"1) ]\" + \"\\n\" +\n        \"maxActiveAppsUsingAbsCap \u003d \" + maxActiveAppsUsingAbsCap +\n        \" [\u003d max(\" + \n        \"(int)ceil((clusterResourceMemory / minimumAllocation) *\" + \n        \"maxAMResourcePercent * absoluteCapacity),\" + \n        \"1) ]\" + \"\\n\" +\n        \"maxActiveApplicationsPerUser \u003d \" + maxActiveApplicationsPerUser +\n        \" [\u003d max(\" +\n        \"(int)(maxActiveApplications * (userLimit / 100.0f) * \" +\n        \"userLimitFactor),\" +\n        \"1) ]\" + \"\\n\" +\n        \"usedCapacity \u003d \" + usedCapacity +\n        \" [\u003d usedResourcesMemory / \" +\n        \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n        \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n        \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n        \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n        \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n        \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n        \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n        \"maximumAllocationMemory ]\" + \"\\n\" +\n        \"numContainers \u003d \" + numContainers +\n        \" [\u003d currentNumContainers ]\" + \"\\n\" +\n        \"state \u003d \" + state +\n        \" [\u003d configuredState ]\" + \"\\n\" +\n        \"acls \u003d \" + aclsString +\n        \" [\u003d configuredAcls ]\" + \"\\n\" + \n        \"nodeLocalityDelay \u003d \" + nodeLocalityDelay + \"\\n\" +\n        \"labels\u003d\" + labelStrBuilder.toString() + \"\\n\" +\n        \"nodeLocalityDelay \u003d \" +  nodeLocalityDelay + \"\\n\" +\n        \"reservationsContinueLooking \u003d \" +\n        reservationsContinueLooking + \"\\n\");\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {}
        }
      ]
    },
    "c8212bacb1b2a7e6ee83cc56f72297465ce99390": {
      "type": "Ymodifierchange",
      "commitMessage": "YARN-1051. Add a system for creating reservations of cluster capacity.\nContributed by Subru Krishnan and Carlo Curino.\n",
      "commitDate": "03/10/14 5:09 PM",
      "commitName": "c8212bacb1b2a7e6ee83cc56f72297465ce99390",
      "commitAuthor": "Chris Douglas",
      "commitDateOld": "03/10/14 3:41 PM",
      "commitNameOld": "eb3e40b833b9d82c1556843f960194dc42e482f3",
      "commitAuthorOld": "carlo curino",
      "daysBetweenCommits": 0.06,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,110 +1,110 @@\n-  private synchronized void setupQueueConfigs(\n+  protected synchronized void setupQueueConfigs(\n       Resource clusterResource,\n       float capacity, float absoluteCapacity, \n       float maximumCapacity, float absoluteMaxCapacity,\n       int userLimit, float userLimitFactor,\n       int maxApplications, float maxAMResourcePerQueuePercent,\n       int maxApplicationsPerUser, int maxActiveApplications,\n       int maxActiveApplicationsPerUser, QueueState state,\n       Map\u003cQueueACL, AccessControlList\u003e acls, int nodeLocalityDelay,\n       boolean continueLooking)\n   {\n     // Sanity check\n     CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n     float absCapacity \u003d getParent().getAbsoluteCapacity() * capacity;\n     CSQueueUtils.checkAbsoluteCapacities(getQueueName(), absCapacity, absoluteMaxCapacity);\n \n     this.capacity \u003d capacity; \n     this.absoluteCapacity \u003d absCapacity;\n \n     this.maximumCapacity \u003d maximumCapacity;\n     this.absoluteMaxCapacity \u003d absoluteMaxCapacity;\n \n     this.userLimit \u003d userLimit;\n     this.userLimitFactor \u003d userLimitFactor;\n \n     this.maxApplications \u003d maxApplications;\n     this.maxAMResourcePerQueuePercent \u003d maxAMResourcePerQueuePercent;\n     this.maxApplicationsPerUser \u003d maxApplicationsPerUser;\n \n     this.maxActiveApplications \u003d maxActiveApplications;\n     this.maxActiveApplicationsPerUser \u003d maxActiveApplicationsPerUser;\n     \n     this.state \u003d state;\n \n     this.acls \u003d acls;\n \n     this.queueInfo.setCapacity(this.capacity);\n     this.queueInfo.setMaximumCapacity(this.maximumCapacity);\n     this.queueInfo.setQueueState(this.state);\n     \n     this.nodeLocalityDelay \u003d nodeLocalityDelay;\n     this.reservationsContinueLooking \u003d continueLooking;\n \n     StringBuilder aclsString \u003d new StringBuilder();\n     for (Map.Entry\u003cQueueACL, AccessControlList\u003e e : acls.entrySet()) {\n       aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n     }\n     \n     // Update metrics\n     CSQueueUtils.updateQueueStatistics(\n         resourceCalculator, this, getParent(), clusterResource, \n         minimumAllocation);\n \n     LOG.info(\"Initializing \" + queueName + \"\\n\" +\n         \"capacity \u003d \" + capacity +\n         \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n         \"asboluteCapacity \u003d \" + absoluteCapacity +\n         \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n         \"maxCapacity \u003d \" + maximumCapacity +\n         \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n         \"absoluteMaxCapacity \u003d \" + absoluteMaxCapacity +\n         \" [\u003d 1.0 maximumCapacity undefined, \" +\n         \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n         \"\\n\" +\n         \"userLimit \u003d \" + userLimit +\n         \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n         \"userLimitFactor \u003d \" + userLimitFactor +\n         \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n         \"maxApplications \u003d \" + maxApplications +\n         \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n         \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n         \"\\n\" +\n         \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n         \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n         \"userLimitFactor) ]\" + \"\\n\" +\n         \"maxActiveApplications \u003d \" + maxActiveApplications +\n         \" [\u003d max(\" + \n         \"(int)ceil((clusterResourceMemory / minimumAllocation) * \" + \n         \"maxAMResourcePerQueuePercent * absoluteMaxCapacity),\" + \n         \"1) ]\" + \"\\n\" +\n         \"maxActiveAppsUsingAbsCap \u003d \" + maxActiveAppsUsingAbsCap +\n         \" [\u003d max(\" + \n         \"(int)ceil((clusterResourceMemory / minimumAllocation) *\" + \n         \"maxAMResourcePercent * absoluteCapacity),\" + \n         \"1) ]\" + \"\\n\" +\n         \"maxActiveApplicationsPerUser \u003d \" + maxActiveApplicationsPerUser +\n         \" [\u003d max(\" +\n         \"(int)(maxActiveApplications * (userLimit / 100.0f) * \" +\n         \"userLimitFactor),\" +\n         \"1) ]\" + \"\\n\" +\n         \"usedCapacity \u003d \" + usedCapacity +\n         \" [\u003d usedResourcesMemory / \" +\n         \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n         \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n         \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n         \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n         \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n         \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n         \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n         \"maximumAllocationMemory ]\" + \"\\n\" +\n         \"numContainers \u003d \" + numContainers +\n         \" [\u003d currentNumContainers ]\" + \"\\n\" +\n         \"state \u003d \" + state +\n         \" [\u003d configuredState ]\" + \"\\n\" +\n         \"acls \u003d \" + aclsString +\n         \" [\u003d configuredAcls ]\" + \"\\n\" + \n         \"nodeLocalityDelay \u003d \" +  nodeLocalityDelay + \"\\n\" +\n         \"reservationsContinueLooking \u003d \" +\n         reservationsContinueLooking + \"\\n\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void setupQueueConfigs(\n      Resource clusterResource,\n      float capacity, float absoluteCapacity, \n      float maximumCapacity, float absoluteMaxCapacity,\n      int userLimit, float userLimitFactor,\n      int maxApplications, float maxAMResourcePerQueuePercent,\n      int maxApplicationsPerUser, int maxActiveApplications,\n      int maxActiveApplicationsPerUser, QueueState state,\n      Map\u003cQueueACL, AccessControlList\u003e acls, int nodeLocalityDelay,\n      boolean continueLooking)\n  {\n    // Sanity check\n    CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n    float absCapacity \u003d getParent().getAbsoluteCapacity() * capacity;\n    CSQueueUtils.checkAbsoluteCapacities(getQueueName(), absCapacity, absoluteMaxCapacity);\n\n    this.capacity \u003d capacity; \n    this.absoluteCapacity \u003d absCapacity;\n\n    this.maximumCapacity \u003d maximumCapacity;\n    this.absoluteMaxCapacity \u003d absoluteMaxCapacity;\n\n    this.userLimit \u003d userLimit;\n    this.userLimitFactor \u003d userLimitFactor;\n\n    this.maxApplications \u003d maxApplications;\n    this.maxAMResourcePerQueuePercent \u003d maxAMResourcePerQueuePercent;\n    this.maxApplicationsPerUser \u003d maxApplicationsPerUser;\n\n    this.maxActiveApplications \u003d maxActiveApplications;\n    this.maxActiveApplicationsPerUser \u003d maxActiveApplicationsPerUser;\n    \n    this.state \u003d state;\n\n    this.acls \u003d acls;\n\n    this.queueInfo.setCapacity(this.capacity);\n    this.queueInfo.setMaximumCapacity(this.maximumCapacity);\n    this.queueInfo.setQueueState(this.state);\n    \n    this.nodeLocalityDelay \u003d nodeLocalityDelay;\n    this.reservationsContinueLooking \u003d continueLooking;\n\n    StringBuilder aclsString \u003d new StringBuilder();\n    for (Map.Entry\u003cQueueACL, AccessControlList\u003e e : acls.entrySet()) {\n      aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n    }\n    \n    // Update metrics\n    CSQueueUtils.updateQueueStatistics(\n        resourceCalculator, this, getParent(), clusterResource, \n        minimumAllocation);\n\n    LOG.info(\"Initializing \" + queueName + \"\\n\" +\n        \"capacity \u003d \" + capacity +\n        \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n        \"asboluteCapacity \u003d \" + absoluteCapacity +\n        \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n        \"maxCapacity \u003d \" + maximumCapacity +\n        \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n        \"absoluteMaxCapacity \u003d \" + absoluteMaxCapacity +\n        \" [\u003d 1.0 maximumCapacity undefined, \" +\n        \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n        \"\\n\" +\n        \"userLimit \u003d \" + userLimit +\n        \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n        \"userLimitFactor \u003d \" + userLimitFactor +\n        \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n        \"maxApplications \u003d \" + maxApplications +\n        \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n        \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n        \"\\n\" +\n        \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n        \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n        \"userLimitFactor) ]\" + \"\\n\" +\n        \"maxActiveApplications \u003d \" + maxActiveApplications +\n        \" [\u003d max(\" + \n        \"(int)ceil((clusterResourceMemory / minimumAllocation) * \" + \n        \"maxAMResourcePerQueuePercent * absoluteMaxCapacity),\" + \n        \"1) ]\" + \"\\n\" +\n        \"maxActiveAppsUsingAbsCap \u003d \" + maxActiveAppsUsingAbsCap +\n        \" [\u003d max(\" + \n        \"(int)ceil((clusterResourceMemory / minimumAllocation) *\" + \n        \"maxAMResourcePercent * absoluteCapacity),\" + \n        \"1) ]\" + \"\\n\" +\n        \"maxActiveApplicationsPerUser \u003d \" + maxActiveApplicationsPerUser +\n        \" [\u003d max(\" +\n        \"(int)(maxActiveApplications * (userLimit / 100.0f) * \" +\n        \"userLimitFactor),\" +\n        \"1) ]\" + \"\\n\" +\n        \"usedCapacity \u003d \" + usedCapacity +\n        \" [\u003d usedResourcesMemory / \" +\n        \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n        \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n        \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n        \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n        \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n        \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n        \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n        \"maximumAllocationMemory ]\" + \"\\n\" +\n        \"numContainers \u003d \" + numContainers +\n        \" [\u003d currentNumContainers ]\" + \"\\n\" +\n        \"state \u003d \" + state +\n        \" [\u003d configuredState ]\" + \"\\n\" +\n        \"acls \u003d \" + aclsString +\n        \" [\u003d configuredAcls ]\" + \"\\n\" + \n        \"nodeLocalityDelay \u003d \" +  nodeLocalityDelay + \"\\n\" +\n        \"reservationsContinueLooking \u003d \" +\n        reservationsContinueLooking + \"\\n\");\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {
        "oldValue": "[private, synchronized]",
        "newValue": "[protected, synchronized]"
      }
    },
    "9c22065109a77681bc2534063eabe8692fbcb3cd": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-1769. CapacityScheduler: Improve reservations. Contributed by Thomas Graves\n",
      "commitDate": "29/09/14 7:12 AM",
      "commitName": "9c22065109a77681bc2534063eabe8692fbcb3cd",
      "commitAuthor": "Jason Lowe",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-1769. CapacityScheduler: Improve reservations. Contributed by Thomas Graves\n",
          "commitDate": "29/09/14 7:12 AM",
          "commitName": "9c22065109a77681bc2534063eabe8692fbcb3cd",
          "commitAuthor": "Jason Lowe",
          "commitDateOld": "14/08/14 11:00 PM",
          "commitNameOld": "7360cec692be5dcc3377ae5082fe22870caac96b",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 45.34,
          "commitsBetweenForRepo": 409,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,106 +1,110 @@\n   private synchronized void setupQueueConfigs(\n       Resource clusterResource,\n       float capacity, float absoluteCapacity, \n       float maximumCapacity, float absoluteMaxCapacity,\n       int userLimit, float userLimitFactor,\n       int maxApplications, float maxAMResourcePerQueuePercent,\n       int maxApplicationsPerUser, int maxActiveApplications,\n       int maxActiveApplicationsPerUser, QueueState state,\n-      Map\u003cQueueACL, AccessControlList\u003e acls, int nodeLocalityDelay)\n+      Map\u003cQueueACL, AccessControlList\u003e acls, int nodeLocalityDelay,\n+      boolean continueLooking)\n   {\n     // Sanity check\n     CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n     float absCapacity \u003d getParent().getAbsoluteCapacity() * capacity;\n     CSQueueUtils.checkAbsoluteCapacities(getQueueName(), absCapacity, absoluteMaxCapacity);\n \n     this.capacity \u003d capacity; \n     this.absoluteCapacity \u003d absCapacity;\n \n     this.maximumCapacity \u003d maximumCapacity;\n     this.absoluteMaxCapacity \u003d absoluteMaxCapacity;\n \n     this.userLimit \u003d userLimit;\n     this.userLimitFactor \u003d userLimitFactor;\n \n     this.maxApplications \u003d maxApplications;\n     this.maxAMResourcePerQueuePercent \u003d maxAMResourcePerQueuePercent;\n     this.maxApplicationsPerUser \u003d maxApplicationsPerUser;\n \n     this.maxActiveApplications \u003d maxActiveApplications;\n     this.maxActiveApplicationsPerUser \u003d maxActiveApplicationsPerUser;\n     \n     this.state \u003d state;\n \n     this.acls \u003d acls;\n \n     this.queueInfo.setCapacity(this.capacity);\n     this.queueInfo.setMaximumCapacity(this.maximumCapacity);\n     this.queueInfo.setQueueState(this.state);\n     \n     this.nodeLocalityDelay \u003d nodeLocalityDelay;\n+    this.reservationsContinueLooking \u003d continueLooking;\n \n     StringBuilder aclsString \u003d new StringBuilder();\n     for (Map.Entry\u003cQueueACL, AccessControlList\u003e e : acls.entrySet()) {\n       aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n     }\n     \n     // Update metrics\n     CSQueueUtils.updateQueueStatistics(\n         resourceCalculator, this, getParent(), clusterResource, \n         minimumAllocation);\n \n     LOG.info(\"Initializing \" + queueName + \"\\n\" +\n         \"capacity \u003d \" + capacity +\n         \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n         \"asboluteCapacity \u003d \" + absoluteCapacity +\n         \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n         \"maxCapacity \u003d \" + maximumCapacity +\n         \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n         \"absoluteMaxCapacity \u003d \" + absoluteMaxCapacity +\n         \" [\u003d 1.0 maximumCapacity undefined, \" +\n         \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n         \"\\n\" +\n         \"userLimit \u003d \" + userLimit +\n         \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n         \"userLimitFactor \u003d \" + userLimitFactor +\n         \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n         \"maxApplications \u003d \" + maxApplications +\n         \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n         \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n         \"\\n\" +\n         \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n         \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n         \"userLimitFactor) ]\" + \"\\n\" +\n         \"maxActiveApplications \u003d \" + maxActiveApplications +\n         \" [\u003d max(\" + \n         \"(int)ceil((clusterResourceMemory / minimumAllocation) * \" + \n         \"maxAMResourcePerQueuePercent * absoluteMaxCapacity),\" + \n         \"1) ]\" + \"\\n\" +\n         \"maxActiveAppsUsingAbsCap \u003d \" + maxActiveAppsUsingAbsCap +\n         \" [\u003d max(\" + \n         \"(int)ceil((clusterResourceMemory / minimumAllocation) *\" + \n         \"maxAMResourcePercent * absoluteCapacity),\" + \n         \"1) ]\" + \"\\n\" +\n         \"maxActiveApplicationsPerUser \u003d \" + maxActiveApplicationsPerUser +\n         \" [\u003d max(\" +\n         \"(int)(maxActiveApplications * (userLimit / 100.0f) * \" +\n         \"userLimitFactor),\" +\n         \"1) ]\" + \"\\n\" +\n         \"usedCapacity \u003d \" + usedCapacity +\n         \" [\u003d usedResourcesMemory / \" +\n         \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n         \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n         \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n         \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n         \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n         \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n         \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n         \"maximumAllocationMemory ]\" + \"\\n\" +\n         \"numContainers \u003d \" + numContainers +\n         \" [\u003d currentNumContainers ]\" + \"\\n\" +\n         \"state \u003d \" + state +\n         \" [\u003d configuredState ]\" + \"\\n\" +\n         \"acls \u003d \" + aclsString +\n         \" [\u003d configuredAcls ]\" + \"\\n\" + \n-        \"nodeLocalityDelay \u003d \" +  nodeLocalityDelay + \"\\n\");\n+        \"nodeLocalityDelay \u003d \" +  nodeLocalityDelay + \"\\n\" +\n+        \"reservationsContinueLooking \u003d \" +\n+        reservationsContinueLooking + \"\\n\");\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private synchronized void setupQueueConfigs(\n      Resource clusterResource,\n      float capacity, float absoluteCapacity, \n      float maximumCapacity, float absoluteMaxCapacity,\n      int userLimit, float userLimitFactor,\n      int maxApplications, float maxAMResourcePerQueuePercent,\n      int maxApplicationsPerUser, int maxActiveApplications,\n      int maxActiveApplicationsPerUser, QueueState state,\n      Map\u003cQueueACL, AccessControlList\u003e acls, int nodeLocalityDelay,\n      boolean continueLooking)\n  {\n    // Sanity check\n    CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n    float absCapacity \u003d getParent().getAbsoluteCapacity() * capacity;\n    CSQueueUtils.checkAbsoluteCapacities(getQueueName(), absCapacity, absoluteMaxCapacity);\n\n    this.capacity \u003d capacity; \n    this.absoluteCapacity \u003d absCapacity;\n\n    this.maximumCapacity \u003d maximumCapacity;\n    this.absoluteMaxCapacity \u003d absoluteMaxCapacity;\n\n    this.userLimit \u003d userLimit;\n    this.userLimitFactor \u003d userLimitFactor;\n\n    this.maxApplications \u003d maxApplications;\n    this.maxAMResourcePerQueuePercent \u003d maxAMResourcePerQueuePercent;\n    this.maxApplicationsPerUser \u003d maxApplicationsPerUser;\n\n    this.maxActiveApplications \u003d maxActiveApplications;\n    this.maxActiveApplicationsPerUser \u003d maxActiveApplicationsPerUser;\n    \n    this.state \u003d state;\n\n    this.acls \u003d acls;\n\n    this.queueInfo.setCapacity(this.capacity);\n    this.queueInfo.setMaximumCapacity(this.maximumCapacity);\n    this.queueInfo.setQueueState(this.state);\n    \n    this.nodeLocalityDelay \u003d nodeLocalityDelay;\n    this.reservationsContinueLooking \u003d continueLooking;\n\n    StringBuilder aclsString \u003d new StringBuilder();\n    for (Map.Entry\u003cQueueACL, AccessControlList\u003e e : acls.entrySet()) {\n      aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n    }\n    \n    // Update metrics\n    CSQueueUtils.updateQueueStatistics(\n        resourceCalculator, this, getParent(), clusterResource, \n        minimumAllocation);\n\n    LOG.info(\"Initializing \" + queueName + \"\\n\" +\n        \"capacity \u003d \" + capacity +\n        \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n        \"asboluteCapacity \u003d \" + absoluteCapacity +\n        \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n        \"maxCapacity \u003d \" + maximumCapacity +\n        \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n        \"absoluteMaxCapacity \u003d \" + absoluteMaxCapacity +\n        \" [\u003d 1.0 maximumCapacity undefined, \" +\n        \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n        \"\\n\" +\n        \"userLimit \u003d \" + userLimit +\n        \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n        \"userLimitFactor \u003d \" + userLimitFactor +\n        \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n        \"maxApplications \u003d \" + maxApplications +\n        \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n        \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n        \"\\n\" +\n        \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n        \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n        \"userLimitFactor) ]\" + \"\\n\" +\n        \"maxActiveApplications \u003d \" + maxActiveApplications +\n        \" [\u003d max(\" + \n        \"(int)ceil((clusterResourceMemory / minimumAllocation) * \" + \n        \"maxAMResourcePerQueuePercent * absoluteMaxCapacity),\" + \n        \"1) ]\" + \"\\n\" +\n        \"maxActiveAppsUsingAbsCap \u003d \" + maxActiveAppsUsingAbsCap +\n        \" [\u003d max(\" + \n        \"(int)ceil((clusterResourceMemory / minimumAllocation) *\" + \n        \"maxAMResourcePercent * absoluteCapacity),\" + \n        \"1) ]\" + \"\\n\" +\n        \"maxActiveApplicationsPerUser \u003d \" + maxActiveApplicationsPerUser +\n        \" [\u003d max(\" +\n        \"(int)(maxActiveApplications * (userLimit / 100.0f) * \" +\n        \"userLimitFactor),\" +\n        \"1) ]\" + \"\\n\" +\n        \"usedCapacity \u003d \" + usedCapacity +\n        \" [\u003d usedResourcesMemory / \" +\n        \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n        \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n        \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n        \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n        \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n        \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n        \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n        \"maximumAllocationMemory ]\" + \"\\n\" +\n        \"numContainers \u003d \" + numContainers +\n        \" [\u003d currentNumContainers ]\" + \"\\n\" +\n        \"state \u003d \" + state +\n        \" [\u003d configuredState ]\" + \"\\n\" +\n        \"acls \u003d \" + aclsString +\n        \" [\u003d configuredAcls ]\" + \"\\n\" + \n        \"nodeLocalityDelay \u003d \" +  nodeLocalityDelay + \"\\n\" +\n        \"reservationsContinueLooking \u003d \" +\n        reservationsContinueLooking + \"\\n\");\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {
            "oldValue": "[clusterResource-Resource, capacity-float, absoluteCapacity-float, maximumCapacity-float, absoluteMaxCapacity-float, userLimit-int, userLimitFactor-float, maxApplications-int, maxAMResourcePerQueuePercent-float, maxApplicationsPerUser-int, maxActiveApplications-int, maxActiveApplicationsPerUser-int, state-QueueState, acls-Map\u003cQueueACL,AccessControlList\u003e, nodeLocalityDelay-int]",
            "newValue": "[clusterResource-Resource, capacity-float, absoluteCapacity-float, maximumCapacity-float, absoluteMaxCapacity-float, userLimit-int, userLimitFactor-float, maxApplications-int, maxAMResourcePerQueuePercent-float, maxApplicationsPerUser-int, maxActiveApplications-int, maxActiveApplicationsPerUser-int, state-QueueState, acls-Map\u003cQueueACL,AccessControlList\u003e, nodeLocalityDelay-int, continueLooking-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-1769. CapacityScheduler: Improve reservations. Contributed by Thomas Graves\n",
          "commitDate": "29/09/14 7:12 AM",
          "commitName": "9c22065109a77681bc2534063eabe8692fbcb3cd",
          "commitAuthor": "Jason Lowe",
          "commitDateOld": "14/08/14 11:00 PM",
          "commitNameOld": "7360cec692be5dcc3377ae5082fe22870caac96b",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 45.34,
          "commitsBetweenForRepo": 409,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,106 +1,110 @@\n   private synchronized void setupQueueConfigs(\n       Resource clusterResource,\n       float capacity, float absoluteCapacity, \n       float maximumCapacity, float absoluteMaxCapacity,\n       int userLimit, float userLimitFactor,\n       int maxApplications, float maxAMResourcePerQueuePercent,\n       int maxApplicationsPerUser, int maxActiveApplications,\n       int maxActiveApplicationsPerUser, QueueState state,\n-      Map\u003cQueueACL, AccessControlList\u003e acls, int nodeLocalityDelay)\n+      Map\u003cQueueACL, AccessControlList\u003e acls, int nodeLocalityDelay,\n+      boolean continueLooking)\n   {\n     // Sanity check\n     CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n     float absCapacity \u003d getParent().getAbsoluteCapacity() * capacity;\n     CSQueueUtils.checkAbsoluteCapacities(getQueueName(), absCapacity, absoluteMaxCapacity);\n \n     this.capacity \u003d capacity; \n     this.absoluteCapacity \u003d absCapacity;\n \n     this.maximumCapacity \u003d maximumCapacity;\n     this.absoluteMaxCapacity \u003d absoluteMaxCapacity;\n \n     this.userLimit \u003d userLimit;\n     this.userLimitFactor \u003d userLimitFactor;\n \n     this.maxApplications \u003d maxApplications;\n     this.maxAMResourcePerQueuePercent \u003d maxAMResourcePerQueuePercent;\n     this.maxApplicationsPerUser \u003d maxApplicationsPerUser;\n \n     this.maxActiveApplications \u003d maxActiveApplications;\n     this.maxActiveApplicationsPerUser \u003d maxActiveApplicationsPerUser;\n     \n     this.state \u003d state;\n \n     this.acls \u003d acls;\n \n     this.queueInfo.setCapacity(this.capacity);\n     this.queueInfo.setMaximumCapacity(this.maximumCapacity);\n     this.queueInfo.setQueueState(this.state);\n     \n     this.nodeLocalityDelay \u003d nodeLocalityDelay;\n+    this.reservationsContinueLooking \u003d continueLooking;\n \n     StringBuilder aclsString \u003d new StringBuilder();\n     for (Map.Entry\u003cQueueACL, AccessControlList\u003e e : acls.entrySet()) {\n       aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n     }\n     \n     // Update metrics\n     CSQueueUtils.updateQueueStatistics(\n         resourceCalculator, this, getParent(), clusterResource, \n         minimumAllocation);\n \n     LOG.info(\"Initializing \" + queueName + \"\\n\" +\n         \"capacity \u003d \" + capacity +\n         \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n         \"asboluteCapacity \u003d \" + absoluteCapacity +\n         \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n         \"maxCapacity \u003d \" + maximumCapacity +\n         \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n         \"absoluteMaxCapacity \u003d \" + absoluteMaxCapacity +\n         \" [\u003d 1.0 maximumCapacity undefined, \" +\n         \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n         \"\\n\" +\n         \"userLimit \u003d \" + userLimit +\n         \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n         \"userLimitFactor \u003d \" + userLimitFactor +\n         \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n         \"maxApplications \u003d \" + maxApplications +\n         \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n         \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n         \"\\n\" +\n         \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n         \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n         \"userLimitFactor) ]\" + \"\\n\" +\n         \"maxActiveApplications \u003d \" + maxActiveApplications +\n         \" [\u003d max(\" + \n         \"(int)ceil((clusterResourceMemory / minimumAllocation) * \" + \n         \"maxAMResourcePerQueuePercent * absoluteMaxCapacity),\" + \n         \"1) ]\" + \"\\n\" +\n         \"maxActiveAppsUsingAbsCap \u003d \" + maxActiveAppsUsingAbsCap +\n         \" [\u003d max(\" + \n         \"(int)ceil((clusterResourceMemory / minimumAllocation) *\" + \n         \"maxAMResourcePercent * absoluteCapacity),\" + \n         \"1) ]\" + \"\\n\" +\n         \"maxActiveApplicationsPerUser \u003d \" + maxActiveApplicationsPerUser +\n         \" [\u003d max(\" +\n         \"(int)(maxActiveApplications * (userLimit / 100.0f) * \" +\n         \"userLimitFactor),\" +\n         \"1) ]\" + \"\\n\" +\n         \"usedCapacity \u003d \" + usedCapacity +\n         \" [\u003d usedResourcesMemory / \" +\n         \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n         \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n         \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n         \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n         \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n         \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n         \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n         \"maximumAllocationMemory ]\" + \"\\n\" +\n         \"numContainers \u003d \" + numContainers +\n         \" [\u003d currentNumContainers ]\" + \"\\n\" +\n         \"state \u003d \" + state +\n         \" [\u003d configuredState ]\" + \"\\n\" +\n         \"acls \u003d \" + aclsString +\n         \" [\u003d configuredAcls ]\" + \"\\n\" + \n-        \"nodeLocalityDelay \u003d \" +  nodeLocalityDelay + \"\\n\");\n+        \"nodeLocalityDelay \u003d \" +  nodeLocalityDelay + \"\\n\" +\n+        \"reservationsContinueLooking \u003d \" +\n+        reservationsContinueLooking + \"\\n\");\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private synchronized void setupQueueConfigs(\n      Resource clusterResource,\n      float capacity, float absoluteCapacity, \n      float maximumCapacity, float absoluteMaxCapacity,\n      int userLimit, float userLimitFactor,\n      int maxApplications, float maxAMResourcePerQueuePercent,\n      int maxApplicationsPerUser, int maxActiveApplications,\n      int maxActiveApplicationsPerUser, QueueState state,\n      Map\u003cQueueACL, AccessControlList\u003e acls, int nodeLocalityDelay,\n      boolean continueLooking)\n  {\n    // Sanity check\n    CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n    float absCapacity \u003d getParent().getAbsoluteCapacity() * capacity;\n    CSQueueUtils.checkAbsoluteCapacities(getQueueName(), absCapacity, absoluteMaxCapacity);\n\n    this.capacity \u003d capacity; \n    this.absoluteCapacity \u003d absCapacity;\n\n    this.maximumCapacity \u003d maximumCapacity;\n    this.absoluteMaxCapacity \u003d absoluteMaxCapacity;\n\n    this.userLimit \u003d userLimit;\n    this.userLimitFactor \u003d userLimitFactor;\n\n    this.maxApplications \u003d maxApplications;\n    this.maxAMResourcePerQueuePercent \u003d maxAMResourcePerQueuePercent;\n    this.maxApplicationsPerUser \u003d maxApplicationsPerUser;\n\n    this.maxActiveApplications \u003d maxActiveApplications;\n    this.maxActiveApplicationsPerUser \u003d maxActiveApplicationsPerUser;\n    \n    this.state \u003d state;\n\n    this.acls \u003d acls;\n\n    this.queueInfo.setCapacity(this.capacity);\n    this.queueInfo.setMaximumCapacity(this.maximumCapacity);\n    this.queueInfo.setQueueState(this.state);\n    \n    this.nodeLocalityDelay \u003d nodeLocalityDelay;\n    this.reservationsContinueLooking \u003d continueLooking;\n\n    StringBuilder aclsString \u003d new StringBuilder();\n    for (Map.Entry\u003cQueueACL, AccessControlList\u003e e : acls.entrySet()) {\n      aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n    }\n    \n    // Update metrics\n    CSQueueUtils.updateQueueStatistics(\n        resourceCalculator, this, getParent(), clusterResource, \n        minimumAllocation);\n\n    LOG.info(\"Initializing \" + queueName + \"\\n\" +\n        \"capacity \u003d \" + capacity +\n        \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n        \"asboluteCapacity \u003d \" + absoluteCapacity +\n        \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n        \"maxCapacity \u003d \" + maximumCapacity +\n        \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n        \"absoluteMaxCapacity \u003d \" + absoluteMaxCapacity +\n        \" [\u003d 1.0 maximumCapacity undefined, \" +\n        \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n        \"\\n\" +\n        \"userLimit \u003d \" + userLimit +\n        \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n        \"userLimitFactor \u003d \" + userLimitFactor +\n        \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n        \"maxApplications \u003d \" + maxApplications +\n        \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n        \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n        \"\\n\" +\n        \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n        \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n        \"userLimitFactor) ]\" + \"\\n\" +\n        \"maxActiveApplications \u003d \" + maxActiveApplications +\n        \" [\u003d max(\" + \n        \"(int)ceil((clusterResourceMemory / minimumAllocation) * \" + \n        \"maxAMResourcePerQueuePercent * absoluteMaxCapacity),\" + \n        \"1) ]\" + \"\\n\" +\n        \"maxActiveAppsUsingAbsCap \u003d \" + maxActiveAppsUsingAbsCap +\n        \" [\u003d max(\" + \n        \"(int)ceil((clusterResourceMemory / minimumAllocation) *\" + \n        \"maxAMResourcePercent * absoluteCapacity),\" + \n        \"1) ]\" + \"\\n\" +\n        \"maxActiveApplicationsPerUser \u003d \" + maxActiveApplicationsPerUser +\n        \" [\u003d max(\" +\n        \"(int)(maxActiveApplications * (userLimit / 100.0f) * \" +\n        \"userLimitFactor),\" +\n        \"1) ]\" + \"\\n\" +\n        \"usedCapacity \u003d \" + usedCapacity +\n        \" [\u003d usedResourcesMemory / \" +\n        \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n        \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n        \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n        \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n        \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n        \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n        \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n        \"maximumAllocationMemory ]\" + \"\\n\" +\n        \"numContainers \u003d \" + numContainers +\n        \" [\u003d currentNumContainers ]\" + \"\\n\" +\n        \"state \u003d \" + state +\n        \" [\u003d configuredState ]\" + \"\\n\" +\n        \"acls \u003d \" + aclsString +\n        \" [\u003d configuredAcls ]\" + \"\\n\" + \n        \"nodeLocalityDelay \u003d \" +  nodeLocalityDelay + \"\\n\" +\n        \"reservationsContinueLooking \u003d \" +\n        reservationsContinueLooking + \"\\n\");\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {}
        }
      ]
    },
    "5b3bb05fbeb7ed4671f4d3a59677788f7fda43d0": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-853. Fixed CapacityScheduler\u0027s maximum-am-resource-percent to properly work beyond refreshing queues. Contributed by Devaraj K.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1505855 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "22/07/13 4:49 PM",
      "commitName": "5b3bb05fbeb7ed4671f4d3a59677788f7fda43d0",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-853. Fixed CapacityScheduler\u0027s maximum-am-resource-percent to properly work beyond refreshing queues. Contributed by Devaraj K.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1505855 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "22/07/13 4:49 PM",
          "commitName": "5b3bb05fbeb7ed4671f4d3a59677788f7fda43d0",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "20/07/13 7:59 AM",
          "commitNameOld": "5b99672658ce24bfd1002b880583cbecfa47f9b3",
          "commitAuthorOld": "Arun Murthy",
          "daysBetweenCommits": 2.37,
          "commitsBetweenForRepo": 10,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,105 +1,106 @@\n   private synchronized void setupQueueConfigs(\n       Resource clusterResource,\n       float capacity, float absoluteCapacity, \n       float maximumCapacity, float absoluteMaxCapacity,\n       int userLimit, float userLimitFactor,\n-      int maxApplications, int maxApplicationsPerUser,\n-      int maxActiveApplications, int maxActiveApplicationsPerUser,\n-      QueueState state, Map\u003cQueueACL, AccessControlList\u003e acls, \n-      int nodeLocalityDelay)\n+      int maxApplications, float maxAMResourcePerQueuePercent,\n+      int maxApplicationsPerUser, int maxActiveApplications,\n+      int maxActiveApplicationsPerUser, QueueState state,\n+      Map\u003cQueueACL, AccessControlList\u003e acls, int nodeLocalityDelay)\n   {\n     // Sanity check\n     CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n     float absCapacity \u003d getParent().getAbsoluteCapacity() * capacity;\n     CSQueueUtils.checkAbsoluteCapacities(getQueueName(), absCapacity, absoluteMaxCapacity);\n \n     this.capacity \u003d capacity; \n     this.absoluteCapacity \u003d absCapacity;\n \n     this.maximumCapacity \u003d maximumCapacity;\n     this.absoluteMaxCapacity \u003d absoluteMaxCapacity;\n \n     this.userLimit \u003d userLimit;\n     this.userLimitFactor \u003d userLimitFactor;\n \n     this.maxApplications \u003d maxApplications;\n+    this.maxAMResourcePerQueuePercent \u003d maxAMResourcePerQueuePercent;\n     this.maxApplicationsPerUser \u003d maxApplicationsPerUser;\n \n     this.maxActiveApplications \u003d maxActiveApplications;\n     this.maxActiveApplicationsPerUser \u003d maxActiveApplicationsPerUser;\n     \n     this.state \u003d state;\n \n     this.acls \u003d acls;\n \n     this.queueInfo.setCapacity(this.capacity);\n     this.queueInfo.setMaximumCapacity(this.maximumCapacity);\n     this.queueInfo.setQueueState(this.state);\n     \n     this.nodeLocalityDelay \u003d nodeLocalityDelay;\n \n     StringBuilder aclsString \u003d new StringBuilder();\n     for (Map.Entry\u003cQueueACL, AccessControlList\u003e e : acls.entrySet()) {\n       aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n     }\n     \n     // Update metrics\n     CSQueueUtils.updateQueueStatistics(\n         resourceCalculator, this, getParent(), clusterResource, \n         minimumAllocation);\n \n     LOG.info(\"Initializing \" + queueName + \"\\n\" +\n         \"capacity \u003d \" + capacity +\n         \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n         \"asboluteCapacity \u003d \" + absoluteCapacity +\n         \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n         \"maxCapacity \u003d \" + maximumCapacity +\n         \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n         \"absoluteMaxCapacity \u003d \" + absoluteMaxCapacity +\n         \" [\u003d 1.0 maximumCapacity undefined, \" +\n         \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n         \"\\n\" +\n         \"userLimit \u003d \" + userLimit +\n         \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n         \"userLimitFactor \u003d \" + userLimitFactor +\n         \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n         \"maxApplications \u003d \" + maxApplications +\n         \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n         \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n         \"\\n\" +\n         \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n         \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n         \"userLimitFactor) ]\" + \"\\n\" +\n         \"maxActiveApplications \u003d \" + maxActiveApplications +\n         \" [\u003d max(\" + \n         \"(int)ceil((clusterResourceMemory / minimumAllocation) * \" + \n         \"maxAMResourcePerQueuePercent * absoluteMaxCapacity),\" + \n         \"1) ]\" + \"\\n\" +\n         \"maxActiveAppsUsingAbsCap \u003d \" + maxActiveAppsUsingAbsCap +\n         \" [\u003d max(\" + \n         \"(int)ceil((clusterResourceMemory / minimumAllocation) *\" + \n         \"maxAMResourcePercent * absoluteCapacity),\" + \n         \"1) ]\" + \"\\n\" +\n         \"maxActiveApplicationsPerUser \u003d \" + maxActiveApplicationsPerUser +\n         \" [\u003d max(\" +\n         \"(int)(maxActiveApplications * (userLimit / 100.0f) * \" +\n         \"userLimitFactor),\" +\n         \"1) ]\" + \"\\n\" +\n         \"usedCapacity \u003d \" + usedCapacity +\n         \" [\u003d usedResourcesMemory / \" +\n         \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n         \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n         \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n         \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n         \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n         \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n         \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n         \"maximumAllocationMemory ]\" + \"\\n\" +\n         \"numContainers \u003d \" + numContainers +\n         \" [\u003d currentNumContainers ]\" + \"\\n\" +\n         \"state \u003d \" + state +\n         \" [\u003d configuredState ]\" + \"\\n\" +\n         \"acls \u003d \" + aclsString +\n         \" [\u003d configuredAcls ]\" + \"\\n\" + \n         \"nodeLocalityDelay \u003d \" +  nodeLocalityDelay + \"\\n\");\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private synchronized void setupQueueConfigs(\n      Resource clusterResource,\n      float capacity, float absoluteCapacity, \n      float maximumCapacity, float absoluteMaxCapacity,\n      int userLimit, float userLimitFactor,\n      int maxApplications, float maxAMResourcePerQueuePercent,\n      int maxApplicationsPerUser, int maxActiveApplications,\n      int maxActiveApplicationsPerUser, QueueState state,\n      Map\u003cQueueACL, AccessControlList\u003e acls, int nodeLocalityDelay)\n  {\n    // Sanity check\n    CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n    float absCapacity \u003d getParent().getAbsoluteCapacity() * capacity;\n    CSQueueUtils.checkAbsoluteCapacities(getQueueName(), absCapacity, absoluteMaxCapacity);\n\n    this.capacity \u003d capacity; \n    this.absoluteCapacity \u003d absCapacity;\n\n    this.maximumCapacity \u003d maximumCapacity;\n    this.absoluteMaxCapacity \u003d absoluteMaxCapacity;\n\n    this.userLimit \u003d userLimit;\n    this.userLimitFactor \u003d userLimitFactor;\n\n    this.maxApplications \u003d maxApplications;\n    this.maxAMResourcePerQueuePercent \u003d maxAMResourcePerQueuePercent;\n    this.maxApplicationsPerUser \u003d maxApplicationsPerUser;\n\n    this.maxActiveApplications \u003d maxActiveApplications;\n    this.maxActiveApplicationsPerUser \u003d maxActiveApplicationsPerUser;\n    \n    this.state \u003d state;\n\n    this.acls \u003d acls;\n\n    this.queueInfo.setCapacity(this.capacity);\n    this.queueInfo.setMaximumCapacity(this.maximumCapacity);\n    this.queueInfo.setQueueState(this.state);\n    \n    this.nodeLocalityDelay \u003d nodeLocalityDelay;\n\n    StringBuilder aclsString \u003d new StringBuilder();\n    for (Map.Entry\u003cQueueACL, AccessControlList\u003e e : acls.entrySet()) {\n      aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n    }\n    \n    // Update metrics\n    CSQueueUtils.updateQueueStatistics(\n        resourceCalculator, this, getParent(), clusterResource, \n        minimumAllocation);\n\n    LOG.info(\"Initializing \" + queueName + \"\\n\" +\n        \"capacity \u003d \" + capacity +\n        \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n        \"asboluteCapacity \u003d \" + absoluteCapacity +\n        \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n        \"maxCapacity \u003d \" + maximumCapacity +\n        \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n        \"absoluteMaxCapacity \u003d \" + absoluteMaxCapacity +\n        \" [\u003d 1.0 maximumCapacity undefined, \" +\n        \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n        \"\\n\" +\n        \"userLimit \u003d \" + userLimit +\n        \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n        \"userLimitFactor \u003d \" + userLimitFactor +\n        \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n        \"maxApplications \u003d \" + maxApplications +\n        \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n        \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n        \"\\n\" +\n        \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n        \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n        \"userLimitFactor) ]\" + \"\\n\" +\n        \"maxActiveApplications \u003d \" + maxActiveApplications +\n        \" [\u003d max(\" + \n        \"(int)ceil((clusterResourceMemory / minimumAllocation) * \" + \n        \"maxAMResourcePerQueuePercent * absoluteMaxCapacity),\" + \n        \"1) ]\" + \"\\n\" +\n        \"maxActiveAppsUsingAbsCap \u003d \" + maxActiveAppsUsingAbsCap +\n        \" [\u003d max(\" + \n        \"(int)ceil((clusterResourceMemory / minimumAllocation) *\" + \n        \"maxAMResourcePercent * absoluteCapacity),\" + \n        \"1) ]\" + \"\\n\" +\n        \"maxActiveApplicationsPerUser \u003d \" + maxActiveApplicationsPerUser +\n        \" [\u003d max(\" +\n        \"(int)(maxActiveApplications * (userLimit / 100.0f) * \" +\n        \"userLimitFactor),\" +\n        \"1) ]\" + \"\\n\" +\n        \"usedCapacity \u003d \" + usedCapacity +\n        \" [\u003d usedResourcesMemory / \" +\n        \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n        \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n        \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n        \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n        \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n        \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n        \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n        \"maximumAllocationMemory ]\" + \"\\n\" +\n        \"numContainers \u003d \" + numContainers +\n        \" [\u003d currentNumContainers ]\" + \"\\n\" +\n        \"state \u003d \" + state +\n        \" [\u003d configuredState ]\" + \"\\n\" +\n        \"acls \u003d \" + aclsString +\n        \" [\u003d configuredAcls ]\" + \"\\n\" + \n        \"nodeLocalityDelay \u003d \" +  nodeLocalityDelay + \"\\n\");\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {
            "oldValue": "[clusterResource-Resource, capacity-float, absoluteCapacity-float, maximumCapacity-float, absoluteMaxCapacity-float, userLimit-int, userLimitFactor-float, maxApplications-int, maxApplicationsPerUser-int, maxActiveApplications-int, maxActiveApplicationsPerUser-int, state-QueueState, acls-Map\u003cQueueACL,AccessControlList\u003e, nodeLocalityDelay-int]",
            "newValue": "[clusterResource-Resource, capacity-float, absoluteCapacity-float, maximumCapacity-float, absoluteMaxCapacity-float, userLimit-int, userLimitFactor-float, maxApplications-int, maxAMResourcePerQueuePercent-float, maxApplicationsPerUser-int, maxActiveApplications-int, maxActiveApplicationsPerUser-int, state-QueueState, acls-Map\u003cQueueACL,AccessControlList\u003e, nodeLocalityDelay-int]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-853. Fixed CapacityScheduler\u0027s maximum-am-resource-percent to properly work beyond refreshing queues. Contributed by Devaraj K.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1505855 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "22/07/13 4:49 PM",
          "commitName": "5b3bb05fbeb7ed4671f4d3a59677788f7fda43d0",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "20/07/13 7:59 AM",
          "commitNameOld": "5b99672658ce24bfd1002b880583cbecfa47f9b3",
          "commitAuthorOld": "Arun Murthy",
          "daysBetweenCommits": 2.37,
          "commitsBetweenForRepo": 10,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,105 +1,106 @@\n   private synchronized void setupQueueConfigs(\n       Resource clusterResource,\n       float capacity, float absoluteCapacity, \n       float maximumCapacity, float absoluteMaxCapacity,\n       int userLimit, float userLimitFactor,\n-      int maxApplications, int maxApplicationsPerUser,\n-      int maxActiveApplications, int maxActiveApplicationsPerUser,\n-      QueueState state, Map\u003cQueueACL, AccessControlList\u003e acls, \n-      int nodeLocalityDelay)\n+      int maxApplications, float maxAMResourcePerQueuePercent,\n+      int maxApplicationsPerUser, int maxActiveApplications,\n+      int maxActiveApplicationsPerUser, QueueState state,\n+      Map\u003cQueueACL, AccessControlList\u003e acls, int nodeLocalityDelay)\n   {\n     // Sanity check\n     CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n     float absCapacity \u003d getParent().getAbsoluteCapacity() * capacity;\n     CSQueueUtils.checkAbsoluteCapacities(getQueueName(), absCapacity, absoluteMaxCapacity);\n \n     this.capacity \u003d capacity; \n     this.absoluteCapacity \u003d absCapacity;\n \n     this.maximumCapacity \u003d maximumCapacity;\n     this.absoluteMaxCapacity \u003d absoluteMaxCapacity;\n \n     this.userLimit \u003d userLimit;\n     this.userLimitFactor \u003d userLimitFactor;\n \n     this.maxApplications \u003d maxApplications;\n+    this.maxAMResourcePerQueuePercent \u003d maxAMResourcePerQueuePercent;\n     this.maxApplicationsPerUser \u003d maxApplicationsPerUser;\n \n     this.maxActiveApplications \u003d maxActiveApplications;\n     this.maxActiveApplicationsPerUser \u003d maxActiveApplicationsPerUser;\n     \n     this.state \u003d state;\n \n     this.acls \u003d acls;\n \n     this.queueInfo.setCapacity(this.capacity);\n     this.queueInfo.setMaximumCapacity(this.maximumCapacity);\n     this.queueInfo.setQueueState(this.state);\n     \n     this.nodeLocalityDelay \u003d nodeLocalityDelay;\n \n     StringBuilder aclsString \u003d new StringBuilder();\n     for (Map.Entry\u003cQueueACL, AccessControlList\u003e e : acls.entrySet()) {\n       aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n     }\n     \n     // Update metrics\n     CSQueueUtils.updateQueueStatistics(\n         resourceCalculator, this, getParent(), clusterResource, \n         minimumAllocation);\n \n     LOG.info(\"Initializing \" + queueName + \"\\n\" +\n         \"capacity \u003d \" + capacity +\n         \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n         \"asboluteCapacity \u003d \" + absoluteCapacity +\n         \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n         \"maxCapacity \u003d \" + maximumCapacity +\n         \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n         \"absoluteMaxCapacity \u003d \" + absoluteMaxCapacity +\n         \" [\u003d 1.0 maximumCapacity undefined, \" +\n         \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n         \"\\n\" +\n         \"userLimit \u003d \" + userLimit +\n         \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n         \"userLimitFactor \u003d \" + userLimitFactor +\n         \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n         \"maxApplications \u003d \" + maxApplications +\n         \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n         \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n         \"\\n\" +\n         \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n         \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n         \"userLimitFactor) ]\" + \"\\n\" +\n         \"maxActiveApplications \u003d \" + maxActiveApplications +\n         \" [\u003d max(\" + \n         \"(int)ceil((clusterResourceMemory / minimumAllocation) * \" + \n         \"maxAMResourcePerQueuePercent * absoluteMaxCapacity),\" + \n         \"1) ]\" + \"\\n\" +\n         \"maxActiveAppsUsingAbsCap \u003d \" + maxActiveAppsUsingAbsCap +\n         \" [\u003d max(\" + \n         \"(int)ceil((clusterResourceMemory / minimumAllocation) *\" + \n         \"maxAMResourcePercent * absoluteCapacity),\" + \n         \"1) ]\" + \"\\n\" +\n         \"maxActiveApplicationsPerUser \u003d \" + maxActiveApplicationsPerUser +\n         \" [\u003d max(\" +\n         \"(int)(maxActiveApplications * (userLimit / 100.0f) * \" +\n         \"userLimitFactor),\" +\n         \"1) ]\" + \"\\n\" +\n         \"usedCapacity \u003d \" + usedCapacity +\n         \" [\u003d usedResourcesMemory / \" +\n         \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n         \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n         \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n         \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n         \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n         \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n         \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n         \"maximumAllocationMemory ]\" + \"\\n\" +\n         \"numContainers \u003d \" + numContainers +\n         \" [\u003d currentNumContainers ]\" + \"\\n\" +\n         \"state \u003d \" + state +\n         \" [\u003d configuredState ]\" + \"\\n\" +\n         \"acls \u003d \" + aclsString +\n         \" [\u003d configuredAcls ]\" + \"\\n\" + \n         \"nodeLocalityDelay \u003d \" +  nodeLocalityDelay + \"\\n\");\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private synchronized void setupQueueConfigs(\n      Resource clusterResource,\n      float capacity, float absoluteCapacity, \n      float maximumCapacity, float absoluteMaxCapacity,\n      int userLimit, float userLimitFactor,\n      int maxApplications, float maxAMResourcePerQueuePercent,\n      int maxApplicationsPerUser, int maxActiveApplications,\n      int maxActiveApplicationsPerUser, QueueState state,\n      Map\u003cQueueACL, AccessControlList\u003e acls, int nodeLocalityDelay)\n  {\n    // Sanity check\n    CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n    float absCapacity \u003d getParent().getAbsoluteCapacity() * capacity;\n    CSQueueUtils.checkAbsoluteCapacities(getQueueName(), absCapacity, absoluteMaxCapacity);\n\n    this.capacity \u003d capacity; \n    this.absoluteCapacity \u003d absCapacity;\n\n    this.maximumCapacity \u003d maximumCapacity;\n    this.absoluteMaxCapacity \u003d absoluteMaxCapacity;\n\n    this.userLimit \u003d userLimit;\n    this.userLimitFactor \u003d userLimitFactor;\n\n    this.maxApplications \u003d maxApplications;\n    this.maxAMResourcePerQueuePercent \u003d maxAMResourcePerQueuePercent;\n    this.maxApplicationsPerUser \u003d maxApplicationsPerUser;\n\n    this.maxActiveApplications \u003d maxActiveApplications;\n    this.maxActiveApplicationsPerUser \u003d maxActiveApplicationsPerUser;\n    \n    this.state \u003d state;\n\n    this.acls \u003d acls;\n\n    this.queueInfo.setCapacity(this.capacity);\n    this.queueInfo.setMaximumCapacity(this.maximumCapacity);\n    this.queueInfo.setQueueState(this.state);\n    \n    this.nodeLocalityDelay \u003d nodeLocalityDelay;\n\n    StringBuilder aclsString \u003d new StringBuilder();\n    for (Map.Entry\u003cQueueACL, AccessControlList\u003e e : acls.entrySet()) {\n      aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n    }\n    \n    // Update metrics\n    CSQueueUtils.updateQueueStatistics(\n        resourceCalculator, this, getParent(), clusterResource, \n        minimumAllocation);\n\n    LOG.info(\"Initializing \" + queueName + \"\\n\" +\n        \"capacity \u003d \" + capacity +\n        \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n        \"asboluteCapacity \u003d \" + absoluteCapacity +\n        \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n        \"maxCapacity \u003d \" + maximumCapacity +\n        \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n        \"absoluteMaxCapacity \u003d \" + absoluteMaxCapacity +\n        \" [\u003d 1.0 maximumCapacity undefined, \" +\n        \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n        \"\\n\" +\n        \"userLimit \u003d \" + userLimit +\n        \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n        \"userLimitFactor \u003d \" + userLimitFactor +\n        \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n        \"maxApplications \u003d \" + maxApplications +\n        \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n        \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n        \"\\n\" +\n        \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n        \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n        \"userLimitFactor) ]\" + \"\\n\" +\n        \"maxActiveApplications \u003d \" + maxActiveApplications +\n        \" [\u003d max(\" + \n        \"(int)ceil((clusterResourceMemory / minimumAllocation) * \" + \n        \"maxAMResourcePerQueuePercent * absoluteMaxCapacity),\" + \n        \"1) ]\" + \"\\n\" +\n        \"maxActiveAppsUsingAbsCap \u003d \" + maxActiveAppsUsingAbsCap +\n        \" [\u003d max(\" + \n        \"(int)ceil((clusterResourceMemory / minimumAllocation) *\" + \n        \"maxAMResourcePercent * absoluteCapacity),\" + \n        \"1) ]\" + \"\\n\" +\n        \"maxActiveApplicationsPerUser \u003d \" + maxActiveApplicationsPerUser +\n        \" [\u003d max(\" +\n        \"(int)(maxActiveApplications * (userLimit / 100.0f) * \" +\n        \"userLimitFactor),\" +\n        \"1) ]\" + \"\\n\" +\n        \"usedCapacity \u003d \" + usedCapacity +\n        \" [\u003d usedResourcesMemory / \" +\n        \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n        \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n        \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n        \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n        \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n        \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n        \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n        \"maximumAllocationMemory ]\" + \"\\n\" +\n        \"numContainers \u003d \" + numContainers +\n        \" [\u003d currentNumContainers ]\" + \"\\n\" +\n        \"state \u003d \" + state +\n        \" [\u003d configuredState ]\" + \"\\n\" +\n        \"acls \u003d \" + aclsString +\n        \" [\u003d configuredAcls ]\" + \"\\n\" + \n        \"nodeLocalityDelay \u003d \" +  nodeLocalityDelay + \"\\n\");\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {}
        }
      ]
    },
    "18757c126761d1813dfffb57d5032d6b5b3c96de": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-525. make CS node-locality-delay refreshable. Contributed by Thomas Graves\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1465009 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "05/04/13 8:30 AM",
      "commitName": "18757c126761d1813dfffb57d5032d6b5b3c96de",
      "commitAuthor": "Jason Darrell Lowe",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-525. make CS node-locality-delay refreshable. Contributed by Thomas Graves\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1465009 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "05/04/13 8:30 AM",
          "commitName": "18757c126761d1813dfffb57d5032d6b5b3c96de",
          "commitAuthor": "Jason Darrell Lowe",
          "commitDateOld": "28/03/13 12:44 PM",
          "commitNameOld": "520033b1cd81c76b38fcdcfcfeed16158db4bbba",
          "commitAuthorOld": "Bikas Saha",
          "daysBetweenCommits": 7.82,
          "commitsBetweenForRepo": 39,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,101 +1,105 @@\n   private synchronized void setupQueueConfigs(\n       Resource clusterResource,\n       float capacity, float absoluteCapacity, \n       float maximumCapacity, float absoluteMaxCapacity,\n       int userLimit, float userLimitFactor,\n       int maxApplications, int maxApplicationsPerUser,\n       int maxActiveApplications, int maxActiveApplicationsPerUser,\n-      QueueState state, Map\u003cQueueACL, AccessControlList\u003e acls)\n+      QueueState state, Map\u003cQueueACL, AccessControlList\u003e acls, \n+      int nodeLocalityDelay)\n   {\n     // Sanity check\n     CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n     float absCapacity \u003d getParent().getAbsoluteCapacity() * capacity;\n     CSQueueUtils.checkAbsoluteCapacities(getQueueName(), absCapacity, absoluteMaxCapacity);\n \n     this.capacity \u003d capacity; \n     this.absoluteCapacity \u003d absCapacity;\n \n     this.maximumCapacity \u003d maximumCapacity;\n     this.absoluteMaxCapacity \u003d absoluteMaxCapacity;\n \n     this.userLimit \u003d userLimit;\n     this.userLimitFactor \u003d userLimitFactor;\n \n     this.maxApplications \u003d maxApplications;\n     this.maxApplicationsPerUser \u003d maxApplicationsPerUser;\n \n     this.maxActiveApplications \u003d maxActiveApplications;\n     this.maxActiveApplicationsPerUser \u003d maxActiveApplicationsPerUser;\n     \n     this.state \u003d state;\n \n     this.acls \u003d acls;\n \n     this.queueInfo.setCapacity(this.capacity);\n     this.queueInfo.setMaximumCapacity(this.maximumCapacity);\n     this.queueInfo.setQueueState(this.state);\n+    \n+    this.nodeLocalityDelay \u003d nodeLocalityDelay;\n \n     StringBuilder aclsString \u003d new StringBuilder();\n     for (Map.Entry\u003cQueueACL, AccessControlList\u003e e : acls.entrySet()) {\n       aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n     }\n     \n     // Update metrics\n     CSQueueUtils.updateQueueStatistics(\n         resourceCalculator, this, getParent(), clusterResource, \n         minimumAllocation);\n \n     LOG.info(\"Initializing \" + queueName + \"\\n\" +\n         \"capacity \u003d \" + capacity +\n         \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n         \"asboluteCapacity \u003d \" + absoluteCapacity +\n         \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n         \"maxCapacity \u003d \" + maximumCapacity +\n         \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n         \"absoluteMaxCapacity \u003d \" + absoluteMaxCapacity +\n         \" [\u003d 1.0 maximumCapacity undefined, \" +\n         \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n         \"\\n\" +\n         \"userLimit \u003d \" + userLimit +\n         \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n         \"userLimitFactor \u003d \" + userLimitFactor +\n         \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n         \"maxApplications \u003d \" + maxApplications +\n         \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n         \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n         \"\\n\" +\n         \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n         \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n         \"userLimitFactor) ]\" + \"\\n\" +\n         \"maxActiveApplications \u003d \" + maxActiveApplications +\n         \" [\u003d max(\" + \n         \"(int)ceil((clusterResourceMemory / minimumAllocation) * \" + \n         \"maxAMResourcePerQueuePercent * absoluteMaxCapacity),\" + \n         \"1) ]\" + \"\\n\" +\n         \"maxActiveAppsUsingAbsCap \u003d \" + maxActiveAppsUsingAbsCap +\n         \" [\u003d max(\" + \n         \"(int)ceil((clusterResourceMemory / minimumAllocation) *\" + \n         \"maxAMResourcePercent * absoluteCapacity),\" + \n         \"1) ]\" + \"\\n\" +\n         \"maxActiveApplicationsPerUser \u003d \" + maxActiveApplicationsPerUser +\n         \" [\u003d max(\" +\n         \"(int)(maxActiveApplications * (userLimit / 100.0f) * \" +\n         \"userLimitFactor),\" +\n         \"1) ]\" + \"\\n\" +\n         \"usedCapacity \u003d \" + usedCapacity +\n         \" [\u003d usedResourcesMemory / \" +\n         \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n         \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n         \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n         \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n         \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n         \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n         \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n         \"maximumAllocationMemory ]\" + \"\\n\" +\n         \"numContainers \u003d \" + numContainers +\n         \" [\u003d currentNumContainers ]\" + \"\\n\" +\n         \"state \u003d \" + state +\n         \" [\u003d configuredState ]\" + \"\\n\" +\n         \"acls \u003d \" + aclsString +\n-        \" [\u003d configuredAcls ]\" + \"\\n\");\n+        \" [\u003d configuredAcls ]\" + \"\\n\" + \n+        \"nodeLocalityDelay \u003d \" +  nodeLocalityDelay + \"\\n\");\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private synchronized void setupQueueConfigs(\n      Resource clusterResource,\n      float capacity, float absoluteCapacity, \n      float maximumCapacity, float absoluteMaxCapacity,\n      int userLimit, float userLimitFactor,\n      int maxApplications, int maxApplicationsPerUser,\n      int maxActiveApplications, int maxActiveApplicationsPerUser,\n      QueueState state, Map\u003cQueueACL, AccessControlList\u003e acls, \n      int nodeLocalityDelay)\n  {\n    // Sanity check\n    CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n    float absCapacity \u003d getParent().getAbsoluteCapacity() * capacity;\n    CSQueueUtils.checkAbsoluteCapacities(getQueueName(), absCapacity, absoluteMaxCapacity);\n\n    this.capacity \u003d capacity; \n    this.absoluteCapacity \u003d absCapacity;\n\n    this.maximumCapacity \u003d maximumCapacity;\n    this.absoluteMaxCapacity \u003d absoluteMaxCapacity;\n\n    this.userLimit \u003d userLimit;\n    this.userLimitFactor \u003d userLimitFactor;\n\n    this.maxApplications \u003d maxApplications;\n    this.maxApplicationsPerUser \u003d maxApplicationsPerUser;\n\n    this.maxActiveApplications \u003d maxActiveApplications;\n    this.maxActiveApplicationsPerUser \u003d maxActiveApplicationsPerUser;\n    \n    this.state \u003d state;\n\n    this.acls \u003d acls;\n\n    this.queueInfo.setCapacity(this.capacity);\n    this.queueInfo.setMaximumCapacity(this.maximumCapacity);\n    this.queueInfo.setQueueState(this.state);\n    \n    this.nodeLocalityDelay \u003d nodeLocalityDelay;\n\n    StringBuilder aclsString \u003d new StringBuilder();\n    for (Map.Entry\u003cQueueACL, AccessControlList\u003e e : acls.entrySet()) {\n      aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n    }\n    \n    // Update metrics\n    CSQueueUtils.updateQueueStatistics(\n        resourceCalculator, this, getParent(), clusterResource, \n        minimumAllocation);\n\n    LOG.info(\"Initializing \" + queueName + \"\\n\" +\n        \"capacity \u003d \" + capacity +\n        \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n        \"asboluteCapacity \u003d \" + absoluteCapacity +\n        \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n        \"maxCapacity \u003d \" + maximumCapacity +\n        \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n        \"absoluteMaxCapacity \u003d \" + absoluteMaxCapacity +\n        \" [\u003d 1.0 maximumCapacity undefined, \" +\n        \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n        \"\\n\" +\n        \"userLimit \u003d \" + userLimit +\n        \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n        \"userLimitFactor \u003d \" + userLimitFactor +\n        \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n        \"maxApplications \u003d \" + maxApplications +\n        \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n        \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n        \"\\n\" +\n        \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n        \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n        \"userLimitFactor) ]\" + \"\\n\" +\n        \"maxActiveApplications \u003d \" + maxActiveApplications +\n        \" [\u003d max(\" + \n        \"(int)ceil((clusterResourceMemory / minimumAllocation) * \" + \n        \"maxAMResourcePerQueuePercent * absoluteMaxCapacity),\" + \n        \"1) ]\" + \"\\n\" +\n        \"maxActiveAppsUsingAbsCap \u003d \" + maxActiveAppsUsingAbsCap +\n        \" [\u003d max(\" + \n        \"(int)ceil((clusterResourceMemory / minimumAllocation) *\" + \n        \"maxAMResourcePercent * absoluteCapacity),\" + \n        \"1) ]\" + \"\\n\" +\n        \"maxActiveApplicationsPerUser \u003d \" + maxActiveApplicationsPerUser +\n        \" [\u003d max(\" +\n        \"(int)(maxActiveApplications * (userLimit / 100.0f) * \" +\n        \"userLimitFactor),\" +\n        \"1) ]\" + \"\\n\" +\n        \"usedCapacity \u003d \" + usedCapacity +\n        \" [\u003d usedResourcesMemory / \" +\n        \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n        \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n        \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n        \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n        \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n        \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n        \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n        \"maximumAllocationMemory ]\" + \"\\n\" +\n        \"numContainers \u003d \" + numContainers +\n        \" [\u003d currentNumContainers ]\" + \"\\n\" +\n        \"state \u003d \" + state +\n        \" [\u003d configuredState ]\" + \"\\n\" +\n        \"acls \u003d \" + aclsString +\n        \" [\u003d configuredAcls ]\" + \"\\n\" + \n        \"nodeLocalityDelay \u003d \" +  nodeLocalityDelay + \"\\n\");\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {
            "oldValue": "[clusterResource-Resource, capacity-float, absoluteCapacity-float, maximumCapacity-float, absoluteMaxCapacity-float, userLimit-int, userLimitFactor-float, maxApplications-int, maxApplicationsPerUser-int, maxActiveApplications-int, maxActiveApplicationsPerUser-int, state-QueueState, acls-Map\u003cQueueACL,AccessControlList\u003e]",
            "newValue": "[clusterResource-Resource, capacity-float, absoluteCapacity-float, maximumCapacity-float, absoluteMaxCapacity-float, userLimit-int, userLimitFactor-float, maxApplications-int, maxApplicationsPerUser-int, maxActiveApplications-int, maxActiveApplicationsPerUser-int, state-QueueState, acls-Map\u003cQueueACL,AccessControlList\u003e, nodeLocalityDelay-int]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-525. make CS node-locality-delay refreshable. Contributed by Thomas Graves\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1465009 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "05/04/13 8:30 AM",
          "commitName": "18757c126761d1813dfffb57d5032d6b5b3c96de",
          "commitAuthor": "Jason Darrell Lowe",
          "commitDateOld": "28/03/13 12:44 PM",
          "commitNameOld": "520033b1cd81c76b38fcdcfcfeed16158db4bbba",
          "commitAuthorOld": "Bikas Saha",
          "daysBetweenCommits": 7.82,
          "commitsBetweenForRepo": 39,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,101 +1,105 @@\n   private synchronized void setupQueueConfigs(\n       Resource clusterResource,\n       float capacity, float absoluteCapacity, \n       float maximumCapacity, float absoluteMaxCapacity,\n       int userLimit, float userLimitFactor,\n       int maxApplications, int maxApplicationsPerUser,\n       int maxActiveApplications, int maxActiveApplicationsPerUser,\n-      QueueState state, Map\u003cQueueACL, AccessControlList\u003e acls)\n+      QueueState state, Map\u003cQueueACL, AccessControlList\u003e acls, \n+      int nodeLocalityDelay)\n   {\n     // Sanity check\n     CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n     float absCapacity \u003d getParent().getAbsoluteCapacity() * capacity;\n     CSQueueUtils.checkAbsoluteCapacities(getQueueName(), absCapacity, absoluteMaxCapacity);\n \n     this.capacity \u003d capacity; \n     this.absoluteCapacity \u003d absCapacity;\n \n     this.maximumCapacity \u003d maximumCapacity;\n     this.absoluteMaxCapacity \u003d absoluteMaxCapacity;\n \n     this.userLimit \u003d userLimit;\n     this.userLimitFactor \u003d userLimitFactor;\n \n     this.maxApplications \u003d maxApplications;\n     this.maxApplicationsPerUser \u003d maxApplicationsPerUser;\n \n     this.maxActiveApplications \u003d maxActiveApplications;\n     this.maxActiveApplicationsPerUser \u003d maxActiveApplicationsPerUser;\n     \n     this.state \u003d state;\n \n     this.acls \u003d acls;\n \n     this.queueInfo.setCapacity(this.capacity);\n     this.queueInfo.setMaximumCapacity(this.maximumCapacity);\n     this.queueInfo.setQueueState(this.state);\n+    \n+    this.nodeLocalityDelay \u003d nodeLocalityDelay;\n \n     StringBuilder aclsString \u003d new StringBuilder();\n     for (Map.Entry\u003cQueueACL, AccessControlList\u003e e : acls.entrySet()) {\n       aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n     }\n     \n     // Update metrics\n     CSQueueUtils.updateQueueStatistics(\n         resourceCalculator, this, getParent(), clusterResource, \n         minimumAllocation);\n \n     LOG.info(\"Initializing \" + queueName + \"\\n\" +\n         \"capacity \u003d \" + capacity +\n         \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n         \"asboluteCapacity \u003d \" + absoluteCapacity +\n         \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n         \"maxCapacity \u003d \" + maximumCapacity +\n         \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n         \"absoluteMaxCapacity \u003d \" + absoluteMaxCapacity +\n         \" [\u003d 1.0 maximumCapacity undefined, \" +\n         \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n         \"\\n\" +\n         \"userLimit \u003d \" + userLimit +\n         \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n         \"userLimitFactor \u003d \" + userLimitFactor +\n         \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n         \"maxApplications \u003d \" + maxApplications +\n         \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n         \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n         \"\\n\" +\n         \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n         \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n         \"userLimitFactor) ]\" + \"\\n\" +\n         \"maxActiveApplications \u003d \" + maxActiveApplications +\n         \" [\u003d max(\" + \n         \"(int)ceil((clusterResourceMemory / minimumAllocation) * \" + \n         \"maxAMResourcePerQueuePercent * absoluteMaxCapacity),\" + \n         \"1) ]\" + \"\\n\" +\n         \"maxActiveAppsUsingAbsCap \u003d \" + maxActiveAppsUsingAbsCap +\n         \" [\u003d max(\" + \n         \"(int)ceil((clusterResourceMemory / minimumAllocation) *\" + \n         \"maxAMResourcePercent * absoluteCapacity),\" + \n         \"1) ]\" + \"\\n\" +\n         \"maxActiveApplicationsPerUser \u003d \" + maxActiveApplicationsPerUser +\n         \" [\u003d max(\" +\n         \"(int)(maxActiveApplications * (userLimit / 100.0f) * \" +\n         \"userLimitFactor),\" +\n         \"1) ]\" + \"\\n\" +\n         \"usedCapacity \u003d \" + usedCapacity +\n         \" [\u003d usedResourcesMemory / \" +\n         \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n         \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n         \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n         \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n         \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n         \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n         \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n         \"maximumAllocationMemory ]\" + \"\\n\" +\n         \"numContainers \u003d \" + numContainers +\n         \" [\u003d currentNumContainers ]\" + \"\\n\" +\n         \"state \u003d \" + state +\n         \" [\u003d configuredState ]\" + \"\\n\" +\n         \"acls \u003d \" + aclsString +\n-        \" [\u003d configuredAcls ]\" + \"\\n\");\n+        \" [\u003d configuredAcls ]\" + \"\\n\" + \n+        \"nodeLocalityDelay \u003d \" +  nodeLocalityDelay + \"\\n\");\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private synchronized void setupQueueConfigs(\n      Resource clusterResource,\n      float capacity, float absoluteCapacity, \n      float maximumCapacity, float absoluteMaxCapacity,\n      int userLimit, float userLimitFactor,\n      int maxApplications, int maxApplicationsPerUser,\n      int maxActiveApplications, int maxActiveApplicationsPerUser,\n      QueueState state, Map\u003cQueueACL, AccessControlList\u003e acls, \n      int nodeLocalityDelay)\n  {\n    // Sanity check\n    CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n    float absCapacity \u003d getParent().getAbsoluteCapacity() * capacity;\n    CSQueueUtils.checkAbsoluteCapacities(getQueueName(), absCapacity, absoluteMaxCapacity);\n\n    this.capacity \u003d capacity; \n    this.absoluteCapacity \u003d absCapacity;\n\n    this.maximumCapacity \u003d maximumCapacity;\n    this.absoluteMaxCapacity \u003d absoluteMaxCapacity;\n\n    this.userLimit \u003d userLimit;\n    this.userLimitFactor \u003d userLimitFactor;\n\n    this.maxApplications \u003d maxApplications;\n    this.maxApplicationsPerUser \u003d maxApplicationsPerUser;\n\n    this.maxActiveApplications \u003d maxActiveApplications;\n    this.maxActiveApplicationsPerUser \u003d maxActiveApplicationsPerUser;\n    \n    this.state \u003d state;\n\n    this.acls \u003d acls;\n\n    this.queueInfo.setCapacity(this.capacity);\n    this.queueInfo.setMaximumCapacity(this.maximumCapacity);\n    this.queueInfo.setQueueState(this.state);\n    \n    this.nodeLocalityDelay \u003d nodeLocalityDelay;\n\n    StringBuilder aclsString \u003d new StringBuilder();\n    for (Map.Entry\u003cQueueACL, AccessControlList\u003e e : acls.entrySet()) {\n      aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n    }\n    \n    // Update metrics\n    CSQueueUtils.updateQueueStatistics(\n        resourceCalculator, this, getParent(), clusterResource, \n        minimumAllocation);\n\n    LOG.info(\"Initializing \" + queueName + \"\\n\" +\n        \"capacity \u003d \" + capacity +\n        \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n        \"asboluteCapacity \u003d \" + absoluteCapacity +\n        \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n        \"maxCapacity \u003d \" + maximumCapacity +\n        \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n        \"absoluteMaxCapacity \u003d \" + absoluteMaxCapacity +\n        \" [\u003d 1.0 maximumCapacity undefined, \" +\n        \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n        \"\\n\" +\n        \"userLimit \u003d \" + userLimit +\n        \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n        \"userLimitFactor \u003d \" + userLimitFactor +\n        \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n        \"maxApplications \u003d \" + maxApplications +\n        \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n        \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n        \"\\n\" +\n        \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n        \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n        \"userLimitFactor) ]\" + \"\\n\" +\n        \"maxActiveApplications \u003d \" + maxActiveApplications +\n        \" [\u003d max(\" + \n        \"(int)ceil((clusterResourceMemory / minimumAllocation) * \" + \n        \"maxAMResourcePerQueuePercent * absoluteMaxCapacity),\" + \n        \"1) ]\" + \"\\n\" +\n        \"maxActiveAppsUsingAbsCap \u003d \" + maxActiveAppsUsingAbsCap +\n        \" [\u003d max(\" + \n        \"(int)ceil((clusterResourceMemory / minimumAllocation) *\" + \n        \"maxAMResourcePercent * absoluteCapacity),\" + \n        \"1) ]\" + \"\\n\" +\n        \"maxActiveApplicationsPerUser \u003d \" + maxActiveApplicationsPerUser +\n        \" [\u003d max(\" +\n        \"(int)(maxActiveApplications * (userLimit / 100.0f) * \" +\n        \"userLimitFactor),\" +\n        \"1) ]\" + \"\\n\" +\n        \"usedCapacity \u003d \" + usedCapacity +\n        \" [\u003d usedResourcesMemory / \" +\n        \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n        \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n        \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n        \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n        \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n        \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n        \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n        \"maximumAllocationMemory ]\" + \"\\n\" +\n        \"numContainers \u003d \" + numContainers +\n        \" [\u003d currentNumContainers ]\" + \"\\n\" +\n        \"state \u003d \" + state +\n        \" [\u003d configuredState ]\" + \"\\n\" +\n        \"acls \u003d \" + aclsString +\n        \" [\u003d configuredAcls ]\" + \"\\n\" + \n        \"nodeLocalityDelay \u003d \" +  nodeLocalityDelay + \"\\n\");\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {}
        }
      ]
    },
    "453926397182078c65a4428eb5de5a90d6af6448": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2. Enhanced CapacityScheduler to account for CPU alongwith memory for multi-dimensional resource scheduling. Contributed by Arun C. Murthy.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1430682 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/01/13 9:08 PM",
      "commitName": "453926397182078c65a4428eb5de5a90d6af6448",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "07/11/12 1:56 PM",
      "commitNameOld": "fb5b96dfc324f999e8b3698288c110a1c3b71c30",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 62.3,
      "commitsBetweenForRepo": 257,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,100 +1,101 @@\n   private synchronized void setupQueueConfigs(\n       Resource clusterResource,\n       float capacity, float absoluteCapacity, \n       float maximumCapacity, float absoluteMaxCapacity,\n       int userLimit, float userLimitFactor,\n       int maxApplications, int maxApplicationsPerUser,\n       int maxActiveApplications, int maxActiveApplicationsPerUser,\n       QueueState state, Map\u003cQueueACL, AccessControlList\u003e acls)\n   {\n     // Sanity check\n     CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n     float absCapacity \u003d getParent().getAbsoluteCapacity() * capacity;\n     CSQueueUtils.checkAbsoluteCapacities(getQueueName(), absCapacity, absoluteMaxCapacity);\n \n     this.capacity \u003d capacity; \n     this.absoluteCapacity \u003d absCapacity;\n \n     this.maximumCapacity \u003d maximumCapacity;\n     this.absoluteMaxCapacity \u003d absoluteMaxCapacity;\n \n     this.userLimit \u003d userLimit;\n     this.userLimitFactor \u003d userLimitFactor;\n \n     this.maxApplications \u003d maxApplications;\n     this.maxApplicationsPerUser \u003d maxApplicationsPerUser;\n \n     this.maxActiveApplications \u003d maxActiveApplications;\n     this.maxActiveApplicationsPerUser \u003d maxActiveApplicationsPerUser;\n     \n     this.state \u003d state;\n \n     this.acls \u003d acls;\n \n     this.queueInfo.setCapacity(this.capacity);\n     this.queueInfo.setMaximumCapacity(this.maximumCapacity);\n     this.queueInfo.setQueueState(this.state);\n \n     StringBuilder aclsString \u003d new StringBuilder();\n     for (Map.Entry\u003cQueueACL, AccessControlList\u003e e : acls.entrySet()) {\n       aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n     }\n     \n     // Update metrics\n     CSQueueUtils.updateQueueStatistics(\n-        this, getParent(), clusterResource, minimumAllocation);\n+        resourceCalculator, this, getParent(), clusterResource, \n+        minimumAllocation);\n \n     LOG.info(\"Initializing \" + queueName + \"\\n\" +\n         \"capacity \u003d \" + capacity +\n         \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n         \"asboluteCapacity \u003d \" + absoluteCapacity +\n         \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n         \"maxCapacity \u003d \" + maximumCapacity +\n         \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n         \"absoluteMaxCapacity \u003d \" + absoluteMaxCapacity +\n         \" [\u003d 1.0 maximumCapacity undefined, \" +\n         \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n         \"\\n\" +\n         \"userLimit \u003d \" + userLimit +\n         \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n         \"userLimitFactor \u003d \" + userLimitFactor +\n         \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n         \"maxApplications \u003d \" + maxApplications +\n         \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n         \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n         \"\\n\" +\n         \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n         \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n         \"userLimitFactor) ]\" + \"\\n\" +\n         \"maxActiveApplications \u003d \" + maxActiveApplications +\n         \" [\u003d max(\" + \n         \"(int)ceil((clusterResourceMemory / minimumAllocation) * \" + \n         \"maxAMResourcePerQueuePercent * absoluteMaxCapacity),\" + \n         \"1) ]\" + \"\\n\" +\n         \"maxActiveAppsUsingAbsCap \u003d \" + maxActiveAppsUsingAbsCap +\n         \" [\u003d max(\" + \n         \"(int)ceil((clusterResourceMemory / minimumAllocation) *\" + \n         \"maxAMResourcePercent * absoluteCapacity),\" + \n         \"1) ]\" + \"\\n\" +\n         \"maxActiveApplicationsPerUser \u003d \" + maxActiveApplicationsPerUser +\n         \" [\u003d max(\" +\n         \"(int)(maxActiveApplications * (userLimit / 100.0f) * \" +\n         \"userLimitFactor),\" +\n         \"1) ]\" + \"\\n\" +\n         \"usedCapacity \u003d \" + usedCapacity +\n         \" [\u003d usedResourcesMemory / \" +\n         \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n         \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n         \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n         \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n         \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n         \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n         \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n         \"maximumAllocationMemory ]\" + \"\\n\" +\n         \"numContainers \u003d \" + numContainers +\n         \" [\u003d currentNumContainers ]\" + \"\\n\" +\n         \"state \u003d \" + state +\n         \" [\u003d configuredState ]\" + \"\\n\" +\n         \"acls \u003d \" + aclsString +\n         \" [\u003d configuredAcls ]\" + \"\\n\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void setupQueueConfigs(\n      Resource clusterResource,\n      float capacity, float absoluteCapacity, \n      float maximumCapacity, float absoluteMaxCapacity,\n      int userLimit, float userLimitFactor,\n      int maxApplications, int maxApplicationsPerUser,\n      int maxActiveApplications, int maxActiveApplicationsPerUser,\n      QueueState state, Map\u003cQueueACL, AccessControlList\u003e acls)\n  {\n    // Sanity check\n    CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n    float absCapacity \u003d getParent().getAbsoluteCapacity() * capacity;\n    CSQueueUtils.checkAbsoluteCapacities(getQueueName(), absCapacity, absoluteMaxCapacity);\n\n    this.capacity \u003d capacity; \n    this.absoluteCapacity \u003d absCapacity;\n\n    this.maximumCapacity \u003d maximumCapacity;\n    this.absoluteMaxCapacity \u003d absoluteMaxCapacity;\n\n    this.userLimit \u003d userLimit;\n    this.userLimitFactor \u003d userLimitFactor;\n\n    this.maxApplications \u003d maxApplications;\n    this.maxApplicationsPerUser \u003d maxApplicationsPerUser;\n\n    this.maxActiveApplications \u003d maxActiveApplications;\n    this.maxActiveApplicationsPerUser \u003d maxActiveApplicationsPerUser;\n    \n    this.state \u003d state;\n\n    this.acls \u003d acls;\n\n    this.queueInfo.setCapacity(this.capacity);\n    this.queueInfo.setMaximumCapacity(this.maximumCapacity);\n    this.queueInfo.setQueueState(this.state);\n\n    StringBuilder aclsString \u003d new StringBuilder();\n    for (Map.Entry\u003cQueueACL, AccessControlList\u003e e : acls.entrySet()) {\n      aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n    }\n    \n    // Update metrics\n    CSQueueUtils.updateQueueStatistics(\n        resourceCalculator, this, getParent(), clusterResource, \n        minimumAllocation);\n\n    LOG.info(\"Initializing \" + queueName + \"\\n\" +\n        \"capacity \u003d \" + capacity +\n        \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n        \"asboluteCapacity \u003d \" + absoluteCapacity +\n        \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n        \"maxCapacity \u003d \" + maximumCapacity +\n        \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n        \"absoluteMaxCapacity \u003d \" + absoluteMaxCapacity +\n        \" [\u003d 1.0 maximumCapacity undefined, \" +\n        \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n        \"\\n\" +\n        \"userLimit \u003d \" + userLimit +\n        \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n        \"userLimitFactor \u003d \" + userLimitFactor +\n        \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n        \"maxApplications \u003d \" + maxApplications +\n        \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n        \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n        \"\\n\" +\n        \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n        \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n        \"userLimitFactor) ]\" + \"\\n\" +\n        \"maxActiveApplications \u003d \" + maxActiveApplications +\n        \" [\u003d max(\" + \n        \"(int)ceil((clusterResourceMemory / minimumAllocation) * \" + \n        \"maxAMResourcePerQueuePercent * absoluteMaxCapacity),\" + \n        \"1) ]\" + \"\\n\" +\n        \"maxActiveAppsUsingAbsCap \u003d \" + maxActiveAppsUsingAbsCap +\n        \" [\u003d max(\" + \n        \"(int)ceil((clusterResourceMemory / minimumAllocation) *\" + \n        \"maxAMResourcePercent * absoluteCapacity),\" + \n        \"1) ]\" + \"\\n\" +\n        \"maxActiveApplicationsPerUser \u003d \" + maxActiveApplicationsPerUser +\n        \" [\u003d max(\" +\n        \"(int)(maxActiveApplications * (userLimit / 100.0f) * \" +\n        \"userLimitFactor),\" +\n        \"1) ]\" + \"\\n\" +\n        \"usedCapacity \u003d \" + usedCapacity +\n        \" [\u003d usedResourcesMemory / \" +\n        \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n        \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n        \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n        \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n        \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n        \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n        \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n        \"maximumAllocationMemory ]\" + \"\\n\" +\n        \"numContainers \u003d \" + numContainers +\n        \" [\u003d currentNumContainers ]\" + \"\\n\" +\n        \"state \u003d \" + state +\n        \" [\u003d configuredState ]\" + \"\\n\" +\n        \"acls \u003d \" + aclsString +\n        \" [\u003d configuredAcls ]\" + \"\\n\");\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "cc523683cfa76c1255667a3aedc48b08e5daabc7": {
      "type": "Ybodychange",
      "commitMessage": "YARN-177. CapacityScheduler - adding a queue while the RM is running has wacky results (acmurthy vai tgraves)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1401668 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/10/12 6:21 AM",
      "commitName": "cc523683cfa76c1255667a3aedc48b08e5daabc7",
      "commitAuthor": "Thomas Graves",
      "commitDateOld": "26/09/12 8:43 PM",
      "commitNameOld": "40062e1aaa09628c6f45d20298fd66d799fd1f3f",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 27.4,
      "commitsBetweenForRepo": 163,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,100 +1,100 @@\n   private synchronized void setupQueueConfigs(\n       Resource clusterResource,\n       float capacity, float absoluteCapacity, \n       float maximumCapacity, float absoluteMaxCapacity,\n       int userLimit, float userLimitFactor,\n       int maxApplications, int maxApplicationsPerUser,\n       int maxActiveApplications, int maxActiveApplicationsPerUser,\n       QueueState state, Map\u003cQueueACL, AccessControlList\u003e acls)\n   {\n     // Sanity check\n     CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n-    float absCapacity \u003d parent.getAbsoluteCapacity() * capacity;\n+    float absCapacity \u003d getParent().getAbsoluteCapacity() * capacity;\n     CSQueueUtils.checkAbsoluteCapacities(getQueueName(), absCapacity, absoluteMaxCapacity);\n \n     this.capacity \u003d capacity; \n     this.absoluteCapacity \u003d absCapacity;\n \n     this.maximumCapacity \u003d maximumCapacity;\n     this.absoluteMaxCapacity \u003d absoluteMaxCapacity;\n \n     this.userLimit \u003d userLimit;\n     this.userLimitFactor \u003d userLimitFactor;\n \n     this.maxApplications \u003d maxApplications;\n     this.maxApplicationsPerUser \u003d maxApplicationsPerUser;\n \n     this.maxActiveApplications \u003d maxActiveApplications;\n     this.maxActiveApplicationsPerUser \u003d maxActiveApplicationsPerUser;\n     \n     this.state \u003d state;\n \n     this.acls \u003d acls;\n \n     this.queueInfo.setCapacity(this.capacity);\n     this.queueInfo.setMaximumCapacity(this.maximumCapacity);\n     this.queueInfo.setQueueState(this.state);\n \n     StringBuilder aclsString \u003d new StringBuilder();\n     for (Map.Entry\u003cQueueACL, AccessControlList\u003e e : acls.entrySet()) {\n       aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n     }\n     \n     // Update metrics\n     CSQueueUtils.updateQueueStatistics(\n-        this, parent, clusterResource, minimumAllocation);\n+        this, getParent(), clusterResource, minimumAllocation);\n \n     LOG.info(\"Initializing \" + queueName + \"\\n\" +\n         \"capacity \u003d \" + capacity +\n         \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n         \"asboluteCapacity \u003d \" + absoluteCapacity +\n         \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n         \"maxCapacity \u003d \" + maximumCapacity +\n         \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n         \"absoluteMaxCapacity \u003d \" + absoluteMaxCapacity +\n         \" [\u003d 1.0 maximumCapacity undefined, \" +\n         \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n         \"\\n\" +\n         \"userLimit \u003d \" + userLimit +\n         \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n         \"userLimitFactor \u003d \" + userLimitFactor +\n         \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n         \"maxApplications \u003d \" + maxApplications +\n         \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n         \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n         \"\\n\" +\n         \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n         \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n         \"userLimitFactor) ]\" + \"\\n\" +\n         \"maxActiveApplications \u003d \" + maxActiveApplications +\n         \" [\u003d max(\" + \n         \"(int)ceil((clusterResourceMemory / minimumAllocation) * \" + \n         \"maxAMResourcePerQueuePercent * absoluteMaxCapacity),\" + \n         \"1) ]\" + \"\\n\" +\n         \"maxActiveAppsUsingAbsCap \u003d \" + maxActiveAppsUsingAbsCap +\n         \" [\u003d max(\" + \n         \"(int)ceil((clusterResourceMemory / minimumAllocation) *\" + \n         \"maxAMResourcePercent * absoluteCapacity),\" + \n         \"1) ]\" + \"\\n\" +\n         \"maxActiveApplicationsPerUser \u003d \" + maxActiveApplicationsPerUser +\n         \" [\u003d max(\" +\n         \"(int)(maxActiveApplications * (userLimit / 100.0f) * \" +\n         \"userLimitFactor),\" +\n         \"1) ]\" + \"\\n\" +\n         \"usedCapacity \u003d \" + usedCapacity +\n         \" [\u003d usedResourcesMemory / \" +\n         \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n         \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n         \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n         \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n         \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n         \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n         \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n         \"maximumAllocationMemory ]\" + \"\\n\" +\n         \"numContainers \u003d \" + numContainers +\n         \" [\u003d currentNumContainers ]\" + \"\\n\" +\n         \"state \u003d \" + state +\n         \" [\u003d configuredState ]\" + \"\\n\" +\n         \"acls \u003d \" + aclsString +\n         \" [\u003d configuredAcls ]\" + \"\\n\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void setupQueueConfigs(\n      Resource clusterResource,\n      float capacity, float absoluteCapacity, \n      float maximumCapacity, float absoluteMaxCapacity,\n      int userLimit, float userLimitFactor,\n      int maxApplications, int maxApplicationsPerUser,\n      int maxActiveApplications, int maxActiveApplicationsPerUser,\n      QueueState state, Map\u003cQueueACL, AccessControlList\u003e acls)\n  {\n    // Sanity check\n    CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n    float absCapacity \u003d getParent().getAbsoluteCapacity() * capacity;\n    CSQueueUtils.checkAbsoluteCapacities(getQueueName(), absCapacity, absoluteMaxCapacity);\n\n    this.capacity \u003d capacity; \n    this.absoluteCapacity \u003d absCapacity;\n\n    this.maximumCapacity \u003d maximumCapacity;\n    this.absoluteMaxCapacity \u003d absoluteMaxCapacity;\n\n    this.userLimit \u003d userLimit;\n    this.userLimitFactor \u003d userLimitFactor;\n\n    this.maxApplications \u003d maxApplications;\n    this.maxApplicationsPerUser \u003d maxApplicationsPerUser;\n\n    this.maxActiveApplications \u003d maxActiveApplications;\n    this.maxActiveApplicationsPerUser \u003d maxActiveApplicationsPerUser;\n    \n    this.state \u003d state;\n\n    this.acls \u003d acls;\n\n    this.queueInfo.setCapacity(this.capacity);\n    this.queueInfo.setMaximumCapacity(this.maximumCapacity);\n    this.queueInfo.setQueueState(this.state);\n\n    StringBuilder aclsString \u003d new StringBuilder();\n    for (Map.Entry\u003cQueueACL, AccessControlList\u003e e : acls.entrySet()) {\n      aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n    }\n    \n    // Update metrics\n    CSQueueUtils.updateQueueStatistics(\n        this, getParent(), clusterResource, minimumAllocation);\n\n    LOG.info(\"Initializing \" + queueName + \"\\n\" +\n        \"capacity \u003d \" + capacity +\n        \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n        \"asboluteCapacity \u003d \" + absoluteCapacity +\n        \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n        \"maxCapacity \u003d \" + maximumCapacity +\n        \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n        \"absoluteMaxCapacity \u003d \" + absoluteMaxCapacity +\n        \" [\u003d 1.0 maximumCapacity undefined, \" +\n        \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n        \"\\n\" +\n        \"userLimit \u003d \" + userLimit +\n        \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n        \"userLimitFactor \u003d \" + userLimitFactor +\n        \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n        \"maxApplications \u003d \" + maxApplications +\n        \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n        \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n        \"\\n\" +\n        \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n        \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n        \"userLimitFactor) ]\" + \"\\n\" +\n        \"maxActiveApplications \u003d \" + maxActiveApplications +\n        \" [\u003d max(\" + \n        \"(int)ceil((clusterResourceMemory / minimumAllocation) * \" + \n        \"maxAMResourcePerQueuePercent * absoluteMaxCapacity),\" + \n        \"1) ]\" + \"\\n\" +\n        \"maxActiveAppsUsingAbsCap \u003d \" + maxActiveAppsUsingAbsCap +\n        \" [\u003d max(\" + \n        \"(int)ceil((clusterResourceMemory / minimumAllocation) *\" + \n        \"maxAMResourcePercent * absoluteCapacity),\" + \n        \"1) ]\" + \"\\n\" +\n        \"maxActiveApplicationsPerUser \u003d \" + maxActiveApplicationsPerUser +\n        \" [\u003d max(\" +\n        \"(int)(maxActiveApplications * (userLimit / 100.0f) * \" +\n        \"userLimitFactor),\" +\n        \"1) ]\" + \"\\n\" +\n        \"usedCapacity \u003d \" + usedCapacity +\n        \" [\u003d usedResourcesMemory / \" +\n        \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n        \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n        \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n        \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n        \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n        \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n        \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n        \"maximumAllocationMemory ]\" + \"\\n\" +\n        \"numContainers \u003d \" + numContainers +\n        \" [\u003d currentNumContainers ]\" + \"\\n\" +\n        \"state \u003d \" + state +\n        \" [\u003d configuredState ]\" + \"\\n\" +\n        \"acls \u003d \" + aclsString +\n        \" [\u003d configuredAcls ]\" + \"\\n\");\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "e1fdf62123625e4ba399af02f8aad500637d29d1": {
      "type": "Yfilerename",
      "commitMessage": "YARN-1. Promote YARN to be a sub-project of Apache Hadoop.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1370666 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/08/12 10:22 PM",
      "commitName": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "07/08/12 7:53 PM",
      "commitNameOld": "34554d1e11ee1d5b564d7d9ed3e6d55931d72749",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private synchronized void setupQueueConfigs(\n      Resource clusterResource,\n      float capacity, float absoluteCapacity, \n      float maximumCapacity, float absoluteMaxCapacity,\n      int userLimit, float userLimitFactor,\n      int maxApplications, int maxApplicationsPerUser,\n      int maxActiveApplications, int maxActiveApplicationsPerUser,\n      QueueState state, Map\u003cQueueACL, AccessControlList\u003e acls)\n  {\n    // Sanity check\n    CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n    float absCapacity \u003d parent.getAbsoluteCapacity() * capacity;\n    CSQueueUtils.checkAbsoluteCapacities(getQueueName(), absCapacity, absoluteMaxCapacity);\n\n    this.capacity \u003d capacity; \n    this.absoluteCapacity \u003d absCapacity;\n\n    this.maximumCapacity \u003d maximumCapacity;\n    this.absoluteMaxCapacity \u003d absoluteMaxCapacity;\n\n    this.userLimit \u003d userLimit;\n    this.userLimitFactor \u003d userLimitFactor;\n\n    this.maxApplications \u003d maxApplications;\n    this.maxApplicationsPerUser \u003d maxApplicationsPerUser;\n\n    this.maxActiveApplications \u003d maxActiveApplications;\n    this.maxActiveApplicationsPerUser \u003d maxActiveApplicationsPerUser;\n    \n    this.state \u003d state;\n\n    this.acls \u003d acls;\n\n    this.queueInfo.setCapacity(this.capacity);\n    this.queueInfo.setMaximumCapacity(this.maximumCapacity);\n    this.queueInfo.setQueueState(this.state);\n\n    StringBuilder aclsString \u003d new StringBuilder();\n    for (Map.Entry\u003cQueueACL, AccessControlList\u003e e : acls.entrySet()) {\n      aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n    }\n    \n    // Update metrics\n    CSQueueUtils.updateQueueStatistics(\n        this, parent, clusterResource, minimumAllocation);\n\n    LOG.info(\"Initializing \" + queueName + \"\\n\" +\n        \"capacity \u003d \" + capacity +\n        \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n        \"asboluteCapacity \u003d \" + absoluteCapacity +\n        \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n        \"maxCapacity \u003d \" + maximumCapacity +\n        \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n        \"absoluteMaxCapacity \u003d \" + absoluteMaxCapacity +\n        \" [\u003d 1.0 maximumCapacity undefined, \" +\n        \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n        \"\\n\" +\n        \"userLimit \u003d \" + userLimit +\n        \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n        \"userLimitFactor \u003d \" + userLimitFactor +\n        \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n        \"maxApplications \u003d \" + maxApplications +\n        \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n        \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n        \"\\n\" +\n        \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n        \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n        \"userLimitFactor) ]\" + \"\\n\" +\n        \"maxActiveApplications \u003d \" + maxActiveApplications +\n        \" [\u003d max(\" + \n        \"(int)ceil((clusterResourceMemory / minimumAllocation) * \" + \n        \"maxAMResourcePerQueuePercent * absoluteMaxCapacity),\" + \n        \"1) ]\" + \"\\n\" +\n        \"maxActiveAppsUsingAbsCap \u003d \" + maxActiveAppsUsingAbsCap +\n        \" [\u003d max(\" + \n        \"(int)ceil((clusterResourceMemory / minimumAllocation) *\" + \n        \"maxAMResourcePercent * absoluteCapacity),\" + \n        \"1) ]\" + \"\\n\" +\n        \"maxActiveApplicationsPerUser \u003d \" + maxActiveApplicationsPerUser +\n        \" [\u003d max(\" +\n        \"(int)(maxActiveApplications * (userLimit / 100.0f) * \" +\n        \"userLimitFactor),\" +\n        \"1) ]\" + \"\\n\" +\n        \"usedCapacity \u003d \" + usedCapacity +\n        \" [\u003d usedResourcesMemory / \" +\n        \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n        \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n        \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n        \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n        \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n        \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n        \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n        \"maximumAllocationMemory ]\" + \"\\n\" +\n        \"numContainers \u003d \" + numContainers +\n        \" [\u003d currentNumContainers ]\" + \"\\n\" +\n        \"state \u003d \" + state +\n        \" [\u003d configuredState ]\" + \"\\n\" +\n        \"acls \u003d \" + aclsString +\n        \" [\u003d configuredAcls ]\" + \"\\n\");\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java"
      }
    },
    "97ed48e0357094ac43533c9e6bd05067b15010c6": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3893. allow capacity scheduler configs max-apps and max-am-pct per queue (tgraves via bobby)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1364764 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/07/12 12:31 PM",
      "commitName": "97ed48e0357094ac43533c9e6bd05067b15010c6",
      "commitAuthor": "Robert Joseph Evans",
      "commitDateOld": "16/07/12 6:43 PM",
      "commitNameOld": "7f2b1eadc1b0807ec1302a0c3488bf6e7a59bc76",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 6.74,
      "commitsBetweenForRepo": 31,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,99 +1,100 @@\n   private synchronized void setupQueueConfigs(\n       Resource clusterResource,\n       float capacity, float absoluteCapacity, \n       float maximumCapacity, float absoluteMaxCapacity,\n       int userLimit, float userLimitFactor,\n       int maxApplications, int maxApplicationsPerUser,\n       int maxActiveApplications, int maxActiveApplicationsPerUser,\n       QueueState state, Map\u003cQueueACL, AccessControlList\u003e acls)\n   {\n     // Sanity check\n     CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n     float absCapacity \u003d parent.getAbsoluteCapacity() * capacity;\n     CSQueueUtils.checkAbsoluteCapacities(getQueueName(), absCapacity, absoluteMaxCapacity);\n \n     this.capacity \u003d capacity; \n     this.absoluteCapacity \u003d absCapacity;\n \n     this.maximumCapacity \u003d maximumCapacity;\n     this.absoluteMaxCapacity \u003d absoluteMaxCapacity;\n \n     this.userLimit \u003d userLimit;\n     this.userLimitFactor \u003d userLimitFactor;\n \n     this.maxApplications \u003d maxApplications;\n     this.maxApplicationsPerUser \u003d maxApplicationsPerUser;\n \n     this.maxActiveApplications \u003d maxActiveApplications;\n     this.maxActiveApplicationsPerUser \u003d maxActiveApplicationsPerUser;\n     \n     this.state \u003d state;\n \n     this.acls \u003d acls;\n \n     this.queueInfo.setCapacity(this.capacity);\n     this.queueInfo.setMaximumCapacity(this.maximumCapacity);\n     this.queueInfo.setQueueState(this.state);\n \n     StringBuilder aclsString \u003d new StringBuilder();\n     for (Map.Entry\u003cQueueACL, AccessControlList\u003e e : acls.entrySet()) {\n       aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n     }\n     \n     // Update metrics\n     CSQueueUtils.updateQueueStatistics(\n         this, parent, clusterResource, minimumAllocation);\n \n     LOG.info(\"Initializing \" + queueName + \"\\n\" +\n         \"capacity \u003d \" + capacity +\n         \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n         \"asboluteCapacity \u003d \" + absoluteCapacity +\n         \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n         \"maxCapacity \u003d \" + maximumCapacity +\n         \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n         \"absoluteMaxCapacity \u003d \" + absoluteMaxCapacity +\n         \" [\u003d 1.0 maximumCapacity undefined, \" +\n         \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n         \"\\n\" +\n         \"userLimit \u003d \" + userLimit +\n         \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n         \"userLimitFactor \u003d \" + userLimitFactor +\n         \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n         \"maxApplications \u003d \" + maxApplications +\n-        \" [\u003d (int)(configuredMaximumSystemApplications * absoluteCapacity) ]\" + \n+        \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n+        \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n         \"\\n\" +\n         \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n         \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n         \"userLimitFactor) ]\" + \"\\n\" +\n         \"maxActiveApplications \u003d \" + maxActiveApplications +\n         \" [\u003d max(\" + \n-        \"(int)ceil((clusterResourceMemory / minimumAllocation) *\" + \n-        \"maxAMResourcePercent * absoluteMaxCapacity),\" + \n+        \"(int)ceil((clusterResourceMemory / minimumAllocation) * \" + \n+        \"maxAMResourcePerQueuePercent * absoluteMaxCapacity),\" + \n         \"1) ]\" + \"\\n\" +\n         \"maxActiveAppsUsingAbsCap \u003d \" + maxActiveAppsUsingAbsCap +\n         \" [\u003d max(\" + \n         \"(int)ceil((clusterResourceMemory / minimumAllocation) *\" + \n         \"maxAMResourcePercent * absoluteCapacity),\" + \n         \"1) ]\" + \"\\n\" +\n         \"maxActiveApplicationsPerUser \u003d \" + maxActiveApplicationsPerUser +\n         \" [\u003d max(\" +\n         \"(int)(maxActiveApplications * (userLimit / 100.0f) * \" +\n         \"userLimitFactor),\" +\n         \"1) ]\" + \"\\n\" +\n         \"usedCapacity \u003d \" + usedCapacity +\n         \" [\u003d usedResourcesMemory / \" +\n         \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n         \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n         \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n-        \"maxAMResourcePercent \u003d \" + maxAMResourcePercent +\n+        \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n         \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n         \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n         \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n         \"maximumAllocationMemory ]\" + \"\\n\" +\n         \"numContainers \u003d \" + numContainers +\n         \" [\u003d currentNumContainers ]\" + \"\\n\" +\n         \"state \u003d \" + state +\n         \" [\u003d configuredState ]\" + \"\\n\" +\n         \"acls \u003d \" + aclsString +\n         \" [\u003d configuredAcls ]\" + \"\\n\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void setupQueueConfigs(\n      Resource clusterResource,\n      float capacity, float absoluteCapacity, \n      float maximumCapacity, float absoluteMaxCapacity,\n      int userLimit, float userLimitFactor,\n      int maxApplications, int maxApplicationsPerUser,\n      int maxActiveApplications, int maxActiveApplicationsPerUser,\n      QueueState state, Map\u003cQueueACL, AccessControlList\u003e acls)\n  {\n    // Sanity check\n    CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n    float absCapacity \u003d parent.getAbsoluteCapacity() * capacity;\n    CSQueueUtils.checkAbsoluteCapacities(getQueueName(), absCapacity, absoluteMaxCapacity);\n\n    this.capacity \u003d capacity; \n    this.absoluteCapacity \u003d absCapacity;\n\n    this.maximumCapacity \u003d maximumCapacity;\n    this.absoluteMaxCapacity \u003d absoluteMaxCapacity;\n\n    this.userLimit \u003d userLimit;\n    this.userLimitFactor \u003d userLimitFactor;\n\n    this.maxApplications \u003d maxApplications;\n    this.maxApplicationsPerUser \u003d maxApplicationsPerUser;\n\n    this.maxActiveApplications \u003d maxActiveApplications;\n    this.maxActiveApplicationsPerUser \u003d maxActiveApplicationsPerUser;\n    \n    this.state \u003d state;\n\n    this.acls \u003d acls;\n\n    this.queueInfo.setCapacity(this.capacity);\n    this.queueInfo.setMaximumCapacity(this.maximumCapacity);\n    this.queueInfo.setQueueState(this.state);\n\n    StringBuilder aclsString \u003d new StringBuilder();\n    for (Map.Entry\u003cQueueACL, AccessControlList\u003e e : acls.entrySet()) {\n      aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n    }\n    \n    // Update metrics\n    CSQueueUtils.updateQueueStatistics(\n        this, parent, clusterResource, minimumAllocation);\n\n    LOG.info(\"Initializing \" + queueName + \"\\n\" +\n        \"capacity \u003d \" + capacity +\n        \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n        \"asboluteCapacity \u003d \" + absoluteCapacity +\n        \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n        \"maxCapacity \u003d \" + maximumCapacity +\n        \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n        \"absoluteMaxCapacity \u003d \" + absoluteMaxCapacity +\n        \" [\u003d 1.0 maximumCapacity undefined, \" +\n        \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n        \"\\n\" +\n        \"userLimit \u003d \" + userLimit +\n        \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n        \"userLimitFactor \u003d \" + userLimitFactor +\n        \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n        \"maxApplications \u003d \" + maxApplications +\n        \" [\u003d configuredMaximumSystemApplicationsPerQueue or\" + \n        \" (int)(configuredMaximumSystemApplications * absoluteCapacity)]\" + \n        \"\\n\" +\n        \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n        \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n        \"userLimitFactor) ]\" + \"\\n\" +\n        \"maxActiveApplications \u003d \" + maxActiveApplications +\n        \" [\u003d max(\" + \n        \"(int)ceil((clusterResourceMemory / minimumAllocation) * \" + \n        \"maxAMResourcePerQueuePercent * absoluteMaxCapacity),\" + \n        \"1) ]\" + \"\\n\" +\n        \"maxActiveAppsUsingAbsCap \u003d \" + maxActiveAppsUsingAbsCap +\n        \" [\u003d max(\" + \n        \"(int)ceil((clusterResourceMemory / minimumAllocation) *\" + \n        \"maxAMResourcePercent * absoluteCapacity),\" + \n        \"1) ]\" + \"\\n\" +\n        \"maxActiveApplicationsPerUser \u003d \" + maxActiveApplicationsPerUser +\n        \" [\u003d max(\" +\n        \"(int)(maxActiveApplications * (userLimit / 100.0f) * \" +\n        \"userLimitFactor),\" +\n        \"1) ]\" + \"\\n\" +\n        \"usedCapacity \u003d \" + usedCapacity +\n        \" [\u003d usedResourcesMemory / \" +\n        \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n        \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n        \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n        \"maxAMResourcePerQueuePercent \u003d \" + maxAMResourcePerQueuePercent +\n        \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n        \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n        \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n        \"maximumAllocationMemory ]\" + \"\\n\" +\n        \"numContainers \u003d \" + numContainers +\n        \" [\u003d currentNumContainers ]\" + \"\\n\" +\n        \"state \u003d \" + state +\n        \" [\u003d configuredState ]\" + \"\\n\" +\n        \"acls \u003d \" + aclsString +\n        \" [\u003d configuredAcls ]\" + \"\\n\");\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "6d80dc2a84bb9a7d15c51e79c624211a20a74b23": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3897. Fixed computation of maxActiveAppsPerUser for queues by using capacity and not max-capacity since we are already scaling it by userLimitFactor. Contributed by Eric Payne.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1296898 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/03/12 3:44 PM",
      "commitName": "6d80dc2a84bb9a7d15c51e79c624211a20a74b23",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "28/02/12 12:06 PM",
      "commitNameOld": "ffdf980b2056b2a1b31ccb19746f23c31f7d08ef",
      "commitAuthorOld": "Robert Joseph Evans",
      "daysBetweenCommits": 5.15,
      "commitsBetweenForRepo": 49,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,94 +1,99 @@\n   private synchronized void setupQueueConfigs(\n       Resource clusterResource,\n       float capacity, float absoluteCapacity, \n       float maximumCapacity, float absoluteMaxCapacity,\n       int userLimit, float userLimitFactor,\n       int maxApplications, int maxApplicationsPerUser,\n       int maxActiveApplications, int maxActiveApplicationsPerUser,\n       QueueState state, Map\u003cQueueACL, AccessControlList\u003e acls)\n   {\n     // Sanity check\n     CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n     float absCapacity \u003d parent.getAbsoluteCapacity() * capacity;\n     CSQueueUtils.checkAbsoluteCapacities(getQueueName(), absCapacity, absoluteMaxCapacity);\n \n     this.capacity \u003d capacity; \n     this.absoluteCapacity \u003d absCapacity;\n \n     this.maximumCapacity \u003d maximumCapacity;\n     this.absoluteMaxCapacity \u003d absoluteMaxCapacity;\n \n     this.userLimit \u003d userLimit;\n     this.userLimitFactor \u003d userLimitFactor;\n \n     this.maxApplications \u003d maxApplications;\n     this.maxApplicationsPerUser \u003d maxApplicationsPerUser;\n \n     this.maxActiveApplications \u003d maxActiveApplications;\n     this.maxActiveApplicationsPerUser \u003d maxActiveApplicationsPerUser;\n     \n     this.state \u003d state;\n \n     this.acls \u003d acls;\n \n     this.queueInfo.setCapacity(this.capacity);\n     this.queueInfo.setMaximumCapacity(this.maximumCapacity);\n     this.queueInfo.setQueueState(this.state);\n \n     StringBuilder aclsString \u003d new StringBuilder();\n     for (Map.Entry\u003cQueueACL, AccessControlList\u003e e : acls.entrySet()) {\n       aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n     }\n     \n     // Update metrics\n     CSQueueUtils.updateQueueStatistics(\n         this, parent, clusterResource, minimumAllocation);\n \n     LOG.info(\"Initializing \" + queueName + \"\\n\" +\n         \"capacity \u003d \" + capacity +\n         \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n         \"asboluteCapacity \u003d \" + absoluteCapacity +\n         \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n         \"maxCapacity \u003d \" + maximumCapacity +\n         \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n         \"absoluteMaxCapacity \u003d \" + absoluteMaxCapacity +\n         \" [\u003d 1.0 maximumCapacity undefined, \" +\n         \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n         \"\\n\" +\n         \"userLimit \u003d \" + userLimit +\n         \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n         \"userLimitFactor \u003d \" + userLimitFactor +\n         \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n         \"maxApplications \u003d \" + maxApplications +\n         \" [\u003d (int)(configuredMaximumSystemApplications * absoluteCapacity) ]\" + \n         \"\\n\" +\n         \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n         \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n         \"userLimitFactor) ]\" + \"\\n\" +\n         \"maxActiveApplications \u003d \" + maxActiveApplications +\n         \" [\u003d max(\" + \n         \"(int)ceil((clusterResourceMemory / minimumAllocation) *\" + \n         \"maxAMResourcePercent * absoluteMaxCapacity),\" + \n         \"1) ]\" + \"\\n\" +\n+        \"maxActiveAppsUsingAbsCap \u003d \" + maxActiveAppsUsingAbsCap +\n+        \" [\u003d max(\" + \n+        \"(int)ceil((clusterResourceMemory / minimumAllocation) *\" + \n+        \"maxAMResourcePercent * absoluteCapacity),\" + \n+        \"1) ]\" + \"\\n\" +\n         \"maxActiveApplicationsPerUser \u003d \" + maxActiveApplicationsPerUser +\n         \" [\u003d max(\" +\n         \"(int)(maxActiveApplications * (userLimit / 100.0f) * \" +\n         \"userLimitFactor),\" +\n         \"1) ]\" + \"\\n\" +\n         \"usedCapacity \u003d \" + usedCapacity +\n         \" [\u003d usedResourcesMemory / \" +\n         \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n         \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n         \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n         \"maxAMResourcePercent \u003d \" + maxAMResourcePercent +\n         \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n         \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n         \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n         \"maximumAllocationMemory ]\" + \"\\n\" +\n         \"numContainers \u003d \" + numContainers +\n         \" [\u003d currentNumContainers ]\" + \"\\n\" +\n         \"state \u003d \" + state +\n         \" [\u003d configuredState ]\" + \"\\n\" +\n         \"acls \u003d \" + aclsString +\n         \" [\u003d configuredAcls ]\" + \"\\n\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void setupQueueConfigs(\n      Resource clusterResource,\n      float capacity, float absoluteCapacity, \n      float maximumCapacity, float absoluteMaxCapacity,\n      int userLimit, float userLimitFactor,\n      int maxApplications, int maxApplicationsPerUser,\n      int maxActiveApplications, int maxActiveApplicationsPerUser,\n      QueueState state, Map\u003cQueueACL, AccessControlList\u003e acls)\n  {\n    // Sanity check\n    CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n    float absCapacity \u003d parent.getAbsoluteCapacity() * capacity;\n    CSQueueUtils.checkAbsoluteCapacities(getQueueName(), absCapacity, absoluteMaxCapacity);\n\n    this.capacity \u003d capacity; \n    this.absoluteCapacity \u003d absCapacity;\n\n    this.maximumCapacity \u003d maximumCapacity;\n    this.absoluteMaxCapacity \u003d absoluteMaxCapacity;\n\n    this.userLimit \u003d userLimit;\n    this.userLimitFactor \u003d userLimitFactor;\n\n    this.maxApplications \u003d maxApplications;\n    this.maxApplicationsPerUser \u003d maxApplicationsPerUser;\n\n    this.maxActiveApplications \u003d maxActiveApplications;\n    this.maxActiveApplicationsPerUser \u003d maxActiveApplicationsPerUser;\n    \n    this.state \u003d state;\n\n    this.acls \u003d acls;\n\n    this.queueInfo.setCapacity(this.capacity);\n    this.queueInfo.setMaximumCapacity(this.maximumCapacity);\n    this.queueInfo.setQueueState(this.state);\n\n    StringBuilder aclsString \u003d new StringBuilder();\n    for (Map.Entry\u003cQueueACL, AccessControlList\u003e e : acls.entrySet()) {\n      aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n    }\n    \n    // Update metrics\n    CSQueueUtils.updateQueueStatistics(\n        this, parent, clusterResource, minimumAllocation);\n\n    LOG.info(\"Initializing \" + queueName + \"\\n\" +\n        \"capacity \u003d \" + capacity +\n        \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n        \"asboluteCapacity \u003d \" + absoluteCapacity +\n        \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n        \"maxCapacity \u003d \" + maximumCapacity +\n        \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n        \"absoluteMaxCapacity \u003d \" + absoluteMaxCapacity +\n        \" [\u003d 1.0 maximumCapacity undefined, \" +\n        \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n        \"\\n\" +\n        \"userLimit \u003d \" + userLimit +\n        \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n        \"userLimitFactor \u003d \" + userLimitFactor +\n        \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n        \"maxApplications \u003d \" + maxApplications +\n        \" [\u003d (int)(configuredMaximumSystemApplications * absoluteCapacity) ]\" + \n        \"\\n\" +\n        \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n        \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n        \"userLimitFactor) ]\" + \"\\n\" +\n        \"maxActiveApplications \u003d \" + maxActiveApplications +\n        \" [\u003d max(\" + \n        \"(int)ceil((clusterResourceMemory / minimumAllocation) *\" + \n        \"maxAMResourcePercent * absoluteMaxCapacity),\" + \n        \"1) ]\" + \"\\n\" +\n        \"maxActiveAppsUsingAbsCap \u003d \" + maxActiveAppsUsingAbsCap +\n        \" [\u003d max(\" + \n        \"(int)ceil((clusterResourceMemory / minimumAllocation) *\" + \n        \"maxAMResourcePercent * absoluteCapacity),\" + \n        \"1) ]\" + \"\\n\" +\n        \"maxActiveApplicationsPerUser \u003d \" + maxActiveApplicationsPerUser +\n        \" [\u003d max(\" +\n        \"(int)(maxActiveApplications * (userLimit / 100.0f) * \" +\n        \"userLimitFactor),\" +\n        \"1) ]\" + \"\\n\" +\n        \"usedCapacity \u003d \" + usedCapacity +\n        \" [\u003d usedResourcesMemory / \" +\n        \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n        \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n        \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n        \"maxAMResourcePercent \u003d \" + maxAMResourcePercent +\n        \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n        \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n        \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n        \"maximumAllocationMemory ]\" + \"\\n\" +\n        \"numContainers \u003d \" + numContainers +\n        \" [\u003d currentNumContainers ]\" + \"\\n\" +\n        \"state \u003d \" + state +\n        \" [\u003d configuredState ]\" + \"\\n\" +\n        \"acls \u003d \" + aclsString +\n        \" [\u003d configuredAcls ]\" + \"\\n\");\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "ffdf980b2056b2a1b31ccb19746f23c31f7d08ef": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3816 capacity scheduler web ui bar graphs for used capacity wrong (tgraves via bobby)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1294808 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "28/02/12 12:06 PM",
      "commitName": "ffdf980b2056b2a1b31ccb19746f23c31f7d08ef",
      "commitAuthor": "Robert Joseph Evans",
      "commitDateOld": "25/02/12 10:49 PM",
      "commitNameOld": "f3cc8911485385713395a04a5b292ae375ff83a3",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 2.55,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,93 +1,94 @@\n   private synchronized void setupQueueConfigs(\n       Resource clusterResource,\n       float capacity, float absoluteCapacity, \n       float maximumCapacity, float absoluteMaxCapacity,\n       int userLimit, float userLimitFactor,\n       int maxApplications, int maxApplicationsPerUser,\n       int maxActiveApplications, int maxActiveApplicationsPerUser,\n       QueueState state, Map\u003cQueueACL, AccessControlList\u003e acls)\n   {\n     // Sanity check\n     CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n+    float absCapacity \u003d parent.getAbsoluteCapacity() * capacity;\n+    CSQueueUtils.checkAbsoluteCapacities(getQueueName(), absCapacity, absoluteMaxCapacity);\n \n     this.capacity \u003d capacity; \n-    this.absoluteCapacity \u003d parent.getAbsoluteCapacity() * capacity;\n+    this.absoluteCapacity \u003d absCapacity;\n \n     this.maximumCapacity \u003d maximumCapacity;\n     this.absoluteMaxCapacity \u003d absoluteMaxCapacity;\n \n     this.userLimit \u003d userLimit;\n     this.userLimitFactor \u003d userLimitFactor;\n \n     this.maxApplications \u003d maxApplications;\n     this.maxApplicationsPerUser \u003d maxApplicationsPerUser;\n \n     this.maxActiveApplications \u003d maxActiveApplications;\n     this.maxActiveApplicationsPerUser \u003d maxActiveApplicationsPerUser;\n     \n     this.state \u003d state;\n \n     this.acls \u003d acls;\n \n     this.queueInfo.setCapacity(this.capacity);\n     this.queueInfo.setMaximumCapacity(this.maximumCapacity);\n     this.queueInfo.setQueueState(this.state);\n \n     StringBuilder aclsString \u003d new StringBuilder();\n     for (Map.Entry\u003cQueueACL, AccessControlList\u003e e : acls.entrySet()) {\n       aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n     }\n     \n     // Update metrics\n     CSQueueUtils.updateQueueStatistics(\n         this, parent, clusterResource, minimumAllocation);\n \n     LOG.info(\"Initializing \" + queueName + \"\\n\" +\n         \"capacity \u003d \" + capacity +\n         \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n         \"asboluteCapacity \u003d \" + absoluteCapacity +\n         \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n         \"maxCapacity \u003d \" + maximumCapacity +\n         \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n         \"absoluteMaxCapacity \u003d \" + absoluteMaxCapacity +\n         \" [\u003d 1.0 maximumCapacity undefined, \" +\n         \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n         \"\\n\" +\n         \"userLimit \u003d \" + userLimit +\n         \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n         \"userLimitFactor \u003d \" + userLimitFactor +\n         \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n         \"maxApplications \u003d \" + maxApplications +\n         \" [\u003d (int)(configuredMaximumSystemApplications * absoluteCapacity) ]\" + \n         \"\\n\" +\n         \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n         \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n         \"userLimitFactor) ]\" + \"\\n\" +\n         \"maxActiveApplications \u003d \" + maxActiveApplications +\n         \" [\u003d max(\" + \n         \"(int)ceil((clusterResourceMemory / minimumAllocation) *\" + \n         \"maxAMResourcePercent * absoluteMaxCapacity),\" + \n         \"1) ]\" + \"\\n\" +\n         \"maxActiveApplicationsPerUser \u003d \" + maxActiveApplicationsPerUser +\n         \" [\u003d max(\" +\n         \"(int)(maxActiveApplications * (userLimit / 100.0f) * \" +\n         \"userLimitFactor),\" +\n         \"1) ]\" + \"\\n\" +\n-        \"utilization \u003d \" + utilization +\n-        \" [\u003d usedResourcesMemory / \" +\n-        \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n         \"usedCapacity \u003d \" + usedCapacity +\n         \" [\u003d usedResourcesMemory / \" +\n-        \"(clusterResourceMemory * parent.absoluteCapacity)]\" + \"\\n\" +\n+        \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n+        \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n+        \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n         \"maxAMResourcePercent \u003d \" + maxAMResourcePercent +\n         \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n         \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n         \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n         \"maximumAllocationMemory ]\" + \"\\n\" +\n         \"numContainers \u003d \" + numContainers +\n         \" [\u003d currentNumContainers ]\" + \"\\n\" +\n         \"state \u003d \" + state +\n         \" [\u003d configuredState ]\" + \"\\n\" +\n         \"acls \u003d \" + aclsString +\n         \" [\u003d configuredAcls ]\" + \"\\n\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void setupQueueConfigs(\n      Resource clusterResource,\n      float capacity, float absoluteCapacity, \n      float maximumCapacity, float absoluteMaxCapacity,\n      int userLimit, float userLimitFactor,\n      int maxApplications, int maxApplicationsPerUser,\n      int maxActiveApplications, int maxActiveApplicationsPerUser,\n      QueueState state, Map\u003cQueueACL, AccessControlList\u003e acls)\n  {\n    // Sanity check\n    CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n    float absCapacity \u003d parent.getAbsoluteCapacity() * capacity;\n    CSQueueUtils.checkAbsoluteCapacities(getQueueName(), absCapacity, absoluteMaxCapacity);\n\n    this.capacity \u003d capacity; \n    this.absoluteCapacity \u003d absCapacity;\n\n    this.maximumCapacity \u003d maximumCapacity;\n    this.absoluteMaxCapacity \u003d absoluteMaxCapacity;\n\n    this.userLimit \u003d userLimit;\n    this.userLimitFactor \u003d userLimitFactor;\n\n    this.maxApplications \u003d maxApplications;\n    this.maxApplicationsPerUser \u003d maxApplicationsPerUser;\n\n    this.maxActiveApplications \u003d maxActiveApplications;\n    this.maxActiveApplicationsPerUser \u003d maxActiveApplicationsPerUser;\n    \n    this.state \u003d state;\n\n    this.acls \u003d acls;\n\n    this.queueInfo.setCapacity(this.capacity);\n    this.queueInfo.setMaximumCapacity(this.maximumCapacity);\n    this.queueInfo.setQueueState(this.state);\n\n    StringBuilder aclsString \u003d new StringBuilder();\n    for (Map.Entry\u003cQueueACL, AccessControlList\u003e e : acls.entrySet()) {\n      aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n    }\n    \n    // Update metrics\n    CSQueueUtils.updateQueueStatistics(\n        this, parent, clusterResource, minimumAllocation);\n\n    LOG.info(\"Initializing \" + queueName + \"\\n\" +\n        \"capacity \u003d \" + capacity +\n        \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n        \"asboluteCapacity \u003d \" + absoluteCapacity +\n        \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n        \"maxCapacity \u003d \" + maximumCapacity +\n        \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n        \"absoluteMaxCapacity \u003d \" + absoluteMaxCapacity +\n        \" [\u003d 1.0 maximumCapacity undefined, \" +\n        \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n        \"\\n\" +\n        \"userLimit \u003d \" + userLimit +\n        \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n        \"userLimitFactor \u003d \" + userLimitFactor +\n        \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n        \"maxApplications \u003d \" + maxApplications +\n        \" [\u003d (int)(configuredMaximumSystemApplications * absoluteCapacity) ]\" + \n        \"\\n\" +\n        \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n        \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n        \"userLimitFactor) ]\" + \"\\n\" +\n        \"maxActiveApplications \u003d \" + maxActiveApplications +\n        \" [\u003d max(\" + \n        \"(int)ceil((clusterResourceMemory / minimumAllocation) *\" + \n        \"maxAMResourcePercent * absoluteMaxCapacity),\" + \n        \"1) ]\" + \"\\n\" +\n        \"maxActiveApplicationsPerUser \u003d \" + maxActiveApplicationsPerUser +\n        \" [\u003d max(\" +\n        \"(int)(maxActiveApplications * (userLimit / 100.0f) * \" +\n        \"userLimitFactor),\" +\n        \"1) ]\" + \"\\n\" +\n        \"usedCapacity \u003d \" + usedCapacity +\n        \" [\u003d usedResourcesMemory / \" +\n        \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n        \"absoluteUsedCapacity \u003d \" + absoluteUsedCapacity +\n        \" [\u003d usedResourcesMemory / clusterResourceMemory]\" + \"\\n\" +\n        \"maxAMResourcePercent \u003d \" + maxAMResourcePercent +\n        \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n        \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n        \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n        \"maximumAllocationMemory ]\" + \"\\n\" +\n        \"numContainers \u003d \" + numContainers +\n        \" [\u003d currentNumContainers ]\" + \"\\n\" +\n        \"state \u003d \" + state +\n        \" [\u003d configuredState ]\" + \"\\n\" +\n        \"acls \u003d \" + aclsString +\n        \" [\u003d configuredAcls ]\" + \"\\n\");\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "c7007a8a3508a24a6f023302516fe8fbe270eab1": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "MAPREDUCE-3747. Initialize queue metrics upfront and added start/finish time to RM Web-UI. \n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1240886 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "05/02/12 7:38 PM",
      "commitName": "c7007a8a3508a24a6f023302516fe8fbe270eab1",
      "commitAuthor": "Arun Murthy",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "MAPREDUCE-3747. Initialize queue metrics upfront and added start/finish time to RM Web-UI. \n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1240886 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "05/02/12 7:38 PM",
          "commitName": "c7007a8a3508a24a6f023302516fe8fbe270eab1",
          "commitAuthor": "Arun Murthy",
          "commitDateOld": "02/02/12 5:16 PM",
          "commitNameOld": "a5c46c91655acebccd1367706b05946eff90f744",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 3.1,
          "commitsBetweenForRepo": 19,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,88 +1,93 @@\n   private synchronized void setupQueueConfigs(\n+      Resource clusterResource,\n       float capacity, float absoluteCapacity, \n       float maximumCapacity, float absoluteMaxCapacity,\n       int userLimit, float userLimitFactor,\n       int maxApplications, int maxApplicationsPerUser,\n       int maxActiveApplications, int maxActiveApplicationsPerUser,\n       QueueState state, Map\u003cQueueACL, AccessControlList\u003e acls)\n   {\n     // Sanity check\n     CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n \n     this.capacity \u003d capacity; \n     this.absoluteCapacity \u003d parent.getAbsoluteCapacity() * capacity;\n \n     this.maximumCapacity \u003d maximumCapacity;\n     this.absoluteMaxCapacity \u003d absoluteMaxCapacity;\n \n     this.userLimit \u003d userLimit;\n     this.userLimitFactor \u003d userLimitFactor;\n \n     this.maxApplications \u003d maxApplications;\n     this.maxApplicationsPerUser \u003d maxApplicationsPerUser;\n \n     this.maxActiveApplications \u003d maxActiveApplications;\n     this.maxActiveApplicationsPerUser \u003d maxActiveApplicationsPerUser;\n     \n     this.state \u003d state;\n \n     this.acls \u003d acls;\n \n     this.queueInfo.setCapacity(this.capacity);\n     this.queueInfo.setMaximumCapacity(this.maximumCapacity);\n     this.queueInfo.setQueueState(this.state);\n \n     StringBuilder aclsString \u003d new StringBuilder();\n     for (Map.Entry\u003cQueueACL, AccessControlList\u003e e : acls.entrySet()) {\n       aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n     }\n+    \n+    // Update metrics\n+    CSQueueUtils.updateQueueStatistics(\n+        this, parent, clusterResource, minimumAllocation);\n \n     LOG.info(\"Initializing \" + queueName + \"\\n\" +\n         \"capacity \u003d \" + capacity +\n         \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n         \"asboluteCapacity \u003d \" + absoluteCapacity +\n         \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n         \"maxCapacity \u003d \" + maximumCapacity +\n         \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n         \"absoluteMaxCapacity \u003d \" + absoluteMaxCapacity +\n         \" [\u003d 1.0 maximumCapacity undefined, \" +\n         \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n         \"\\n\" +\n         \"userLimit \u003d \" + userLimit +\n         \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n         \"userLimitFactor \u003d \" + userLimitFactor +\n         \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n         \"maxApplications \u003d \" + maxApplications +\n         \" [\u003d (int)(configuredMaximumSystemApplications * absoluteCapacity) ]\" + \n         \"\\n\" +\n         \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n         \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n         \"userLimitFactor) ]\" + \"\\n\" +\n         \"maxActiveApplications \u003d \" + maxActiveApplications +\n         \" [\u003d max(\" + \n         \"(int)ceil((clusterResourceMemory / minimumAllocation) *\" + \n         \"maxAMResourcePercent * absoluteMaxCapacity),\" + \n         \"1) ]\" + \"\\n\" +\n         \"maxActiveApplicationsPerUser \u003d \" + maxActiveApplicationsPerUser +\n         \" [\u003d max(\" +\n         \"(int)(maxActiveApplications * (userLimit / 100.0f) * \" +\n         \"userLimitFactor),\" +\n         \"1) ]\" + \"\\n\" +\n         \"utilization \u003d \" + utilization +\n         \" [\u003d usedResourcesMemory / \" +\n         \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n         \"usedCapacity \u003d \" + usedCapacity +\n         \" [\u003d usedResourcesMemory / \" +\n         \"(clusterResourceMemory * parent.absoluteCapacity)]\" + \"\\n\" +\n         \"maxAMResourcePercent \u003d \" + maxAMResourcePercent +\n         \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n         \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n         \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n         \"maximumAllocationMemory ]\" + \"\\n\" +\n         \"numContainers \u003d \" + numContainers +\n         \" [\u003d currentNumContainers ]\" + \"\\n\" +\n         \"state \u003d \" + state +\n         \" [\u003d configuredState ]\" + \"\\n\" +\n         \"acls \u003d \" + aclsString +\n         \" [\u003d configuredAcls ]\" + \"\\n\");\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private synchronized void setupQueueConfigs(\n      Resource clusterResource,\n      float capacity, float absoluteCapacity, \n      float maximumCapacity, float absoluteMaxCapacity,\n      int userLimit, float userLimitFactor,\n      int maxApplications, int maxApplicationsPerUser,\n      int maxActiveApplications, int maxActiveApplicationsPerUser,\n      QueueState state, Map\u003cQueueACL, AccessControlList\u003e acls)\n  {\n    // Sanity check\n    CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n\n    this.capacity \u003d capacity; \n    this.absoluteCapacity \u003d parent.getAbsoluteCapacity() * capacity;\n\n    this.maximumCapacity \u003d maximumCapacity;\n    this.absoluteMaxCapacity \u003d absoluteMaxCapacity;\n\n    this.userLimit \u003d userLimit;\n    this.userLimitFactor \u003d userLimitFactor;\n\n    this.maxApplications \u003d maxApplications;\n    this.maxApplicationsPerUser \u003d maxApplicationsPerUser;\n\n    this.maxActiveApplications \u003d maxActiveApplications;\n    this.maxActiveApplicationsPerUser \u003d maxActiveApplicationsPerUser;\n    \n    this.state \u003d state;\n\n    this.acls \u003d acls;\n\n    this.queueInfo.setCapacity(this.capacity);\n    this.queueInfo.setMaximumCapacity(this.maximumCapacity);\n    this.queueInfo.setQueueState(this.state);\n\n    StringBuilder aclsString \u003d new StringBuilder();\n    for (Map.Entry\u003cQueueACL, AccessControlList\u003e e : acls.entrySet()) {\n      aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n    }\n    \n    // Update metrics\n    CSQueueUtils.updateQueueStatistics(\n        this, parent, clusterResource, minimumAllocation);\n\n    LOG.info(\"Initializing \" + queueName + \"\\n\" +\n        \"capacity \u003d \" + capacity +\n        \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n        \"asboluteCapacity \u003d \" + absoluteCapacity +\n        \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n        \"maxCapacity \u003d \" + maximumCapacity +\n        \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n        \"absoluteMaxCapacity \u003d \" + absoluteMaxCapacity +\n        \" [\u003d 1.0 maximumCapacity undefined, \" +\n        \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n        \"\\n\" +\n        \"userLimit \u003d \" + userLimit +\n        \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n        \"userLimitFactor \u003d \" + userLimitFactor +\n        \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n        \"maxApplications \u003d \" + maxApplications +\n        \" [\u003d (int)(configuredMaximumSystemApplications * absoluteCapacity) ]\" + \n        \"\\n\" +\n        \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n        \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n        \"userLimitFactor) ]\" + \"\\n\" +\n        \"maxActiveApplications \u003d \" + maxActiveApplications +\n        \" [\u003d max(\" + \n        \"(int)ceil((clusterResourceMemory / minimumAllocation) *\" + \n        \"maxAMResourcePercent * absoluteMaxCapacity),\" + \n        \"1) ]\" + \"\\n\" +\n        \"maxActiveApplicationsPerUser \u003d \" + maxActiveApplicationsPerUser +\n        \" [\u003d max(\" +\n        \"(int)(maxActiveApplications * (userLimit / 100.0f) * \" +\n        \"userLimitFactor),\" +\n        \"1) ]\" + \"\\n\" +\n        \"utilization \u003d \" + utilization +\n        \" [\u003d usedResourcesMemory / \" +\n        \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n        \"usedCapacity \u003d \" + usedCapacity +\n        \" [\u003d usedResourcesMemory / \" +\n        \"(clusterResourceMemory * parent.absoluteCapacity)]\" + \"\\n\" +\n        \"maxAMResourcePercent \u003d \" + maxAMResourcePercent +\n        \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n        \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n        \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n        \"maximumAllocationMemory ]\" + \"\\n\" +\n        \"numContainers \u003d \" + numContainers +\n        \" [\u003d currentNumContainers ]\" + \"\\n\" +\n        \"state \u003d \" + state +\n        \" [\u003d configuredState ]\" + \"\\n\" +\n        \"acls \u003d \" + aclsString +\n        \" [\u003d configuredAcls ]\" + \"\\n\");\n  }",
          "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {
            "oldValue": "[capacity-float, absoluteCapacity-float, maximumCapacity-float, absoluteMaxCapacity-float, userLimit-int, userLimitFactor-float, maxApplications-int, maxApplicationsPerUser-int, maxActiveApplications-int, maxActiveApplicationsPerUser-int, state-QueueState, acls-Map\u003cQueueACL,AccessControlList\u003e]",
            "newValue": "[clusterResource-Resource, capacity-float, absoluteCapacity-float, maximumCapacity-float, absoluteMaxCapacity-float, userLimit-int, userLimitFactor-float, maxApplications-int, maxApplicationsPerUser-int, maxActiveApplications-int, maxActiveApplicationsPerUser-int, state-QueueState, acls-Map\u003cQueueACL,AccessControlList\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "MAPREDUCE-3747. Initialize queue metrics upfront and added start/finish time to RM Web-UI. \n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1240886 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "05/02/12 7:38 PM",
          "commitName": "c7007a8a3508a24a6f023302516fe8fbe270eab1",
          "commitAuthor": "Arun Murthy",
          "commitDateOld": "02/02/12 5:16 PM",
          "commitNameOld": "a5c46c91655acebccd1367706b05946eff90f744",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 3.1,
          "commitsBetweenForRepo": 19,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,88 +1,93 @@\n   private synchronized void setupQueueConfigs(\n+      Resource clusterResource,\n       float capacity, float absoluteCapacity, \n       float maximumCapacity, float absoluteMaxCapacity,\n       int userLimit, float userLimitFactor,\n       int maxApplications, int maxApplicationsPerUser,\n       int maxActiveApplications, int maxActiveApplicationsPerUser,\n       QueueState state, Map\u003cQueueACL, AccessControlList\u003e acls)\n   {\n     // Sanity check\n     CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n \n     this.capacity \u003d capacity; \n     this.absoluteCapacity \u003d parent.getAbsoluteCapacity() * capacity;\n \n     this.maximumCapacity \u003d maximumCapacity;\n     this.absoluteMaxCapacity \u003d absoluteMaxCapacity;\n \n     this.userLimit \u003d userLimit;\n     this.userLimitFactor \u003d userLimitFactor;\n \n     this.maxApplications \u003d maxApplications;\n     this.maxApplicationsPerUser \u003d maxApplicationsPerUser;\n \n     this.maxActiveApplications \u003d maxActiveApplications;\n     this.maxActiveApplicationsPerUser \u003d maxActiveApplicationsPerUser;\n     \n     this.state \u003d state;\n \n     this.acls \u003d acls;\n \n     this.queueInfo.setCapacity(this.capacity);\n     this.queueInfo.setMaximumCapacity(this.maximumCapacity);\n     this.queueInfo.setQueueState(this.state);\n \n     StringBuilder aclsString \u003d new StringBuilder();\n     for (Map.Entry\u003cQueueACL, AccessControlList\u003e e : acls.entrySet()) {\n       aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n     }\n+    \n+    // Update metrics\n+    CSQueueUtils.updateQueueStatistics(\n+        this, parent, clusterResource, minimumAllocation);\n \n     LOG.info(\"Initializing \" + queueName + \"\\n\" +\n         \"capacity \u003d \" + capacity +\n         \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n         \"asboluteCapacity \u003d \" + absoluteCapacity +\n         \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n         \"maxCapacity \u003d \" + maximumCapacity +\n         \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n         \"absoluteMaxCapacity \u003d \" + absoluteMaxCapacity +\n         \" [\u003d 1.0 maximumCapacity undefined, \" +\n         \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n         \"\\n\" +\n         \"userLimit \u003d \" + userLimit +\n         \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n         \"userLimitFactor \u003d \" + userLimitFactor +\n         \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n         \"maxApplications \u003d \" + maxApplications +\n         \" [\u003d (int)(configuredMaximumSystemApplications * absoluteCapacity) ]\" + \n         \"\\n\" +\n         \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n         \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n         \"userLimitFactor) ]\" + \"\\n\" +\n         \"maxActiveApplications \u003d \" + maxActiveApplications +\n         \" [\u003d max(\" + \n         \"(int)ceil((clusterResourceMemory / minimumAllocation) *\" + \n         \"maxAMResourcePercent * absoluteMaxCapacity),\" + \n         \"1) ]\" + \"\\n\" +\n         \"maxActiveApplicationsPerUser \u003d \" + maxActiveApplicationsPerUser +\n         \" [\u003d max(\" +\n         \"(int)(maxActiveApplications * (userLimit / 100.0f) * \" +\n         \"userLimitFactor),\" +\n         \"1) ]\" + \"\\n\" +\n         \"utilization \u003d \" + utilization +\n         \" [\u003d usedResourcesMemory / \" +\n         \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n         \"usedCapacity \u003d \" + usedCapacity +\n         \" [\u003d usedResourcesMemory / \" +\n         \"(clusterResourceMemory * parent.absoluteCapacity)]\" + \"\\n\" +\n         \"maxAMResourcePercent \u003d \" + maxAMResourcePercent +\n         \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n         \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n         \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n         \"maximumAllocationMemory ]\" + \"\\n\" +\n         \"numContainers \u003d \" + numContainers +\n         \" [\u003d currentNumContainers ]\" + \"\\n\" +\n         \"state \u003d \" + state +\n         \" [\u003d configuredState ]\" + \"\\n\" +\n         \"acls \u003d \" + aclsString +\n         \" [\u003d configuredAcls ]\" + \"\\n\");\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private synchronized void setupQueueConfigs(\n      Resource clusterResource,\n      float capacity, float absoluteCapacity, \n      float maximumCapacity, float absoluteMaxCapacity,\n      int userLimit, float userLimitFactor,\n      int maxApplications, int maxApplicationsPerUser,\n      int maxActiveApplications, int maxActiveApplicationsPerUser,\n      QueueState state, Map\u003cQueueACL, AccessControlList\u003e acls)\n  {\n    // Sanity check\n    CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n\n    this.capacity \u003d capacity; \n    this.absoluteCapacity \u003d parent.getAbsoluteCapacity() * capacity;\n\n    this.maximumCapacity \u003d maximumCapacity;\n    this.absoluteMaxCapacity \u003d absoluteMaxCapacity;\n\n    this.userLimit \u003d userLimit;\n    this.userLimitFactor \u003d userLimitFactor;\n\n    this.maxApplications \u003d maxApplications;\n    this.maxApplicationsPerUser \u003d maxApplicationsPerUser;\n\n    this.maxActiveApplications \u003d maxActiveApplications;\n    this.maxActiveApplicationsPerUser \u003d maxActiveApplicationsPerUser;\n    \n    this.state \u003d state;\n\n    this.acls \u003d acls;\n\n    this.queueInfo.setCapacity(this.capacity);\n    this.queueInfo.setMaximumCapacity(this.maximumCapacity);\n    this.queueInfo.setQueueState(this.state);\n\n    StringBuilder aclsString \u003d new StringBuilder();\n    for (Map.Entry\u003cQueueACL, AccessControlList\u003e e : acls.entrySet()) {\n      aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n    }\n    \n    // Update metrics\n    CSQueueUtils.updateQueueStatistics(\n        this, parent, clusterResource, minimumAllocation);\n\n    LOG.info(\"Initializing \" + queueName + \"\\n\" +\n        \"capacity \u003d \" + capacity +\n        \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n        \"asboluteCapacity \u003d \" + absoluteCapacity +\n        \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n        \"maxCapacity \u003d \" + maximumCapacity +\n        \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n        \"absoluteMaxCapacity \u003d \" + absoluteMaxCapacity +\n        \" [\u003d 1.0 maximumCapacity undefined, \" +\n        \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n        \"\\n\" +\n        \"userLimit \u003d \" + userLimit +\n        \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n        \"userLimitFactor \u003d \" + userLimitFactor +\n        \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n        \"maxApplications \u003d \" + maxApplications +\n        \" [\u003d (int)(configuredMaximumSystemApplications * absoluteCapacity) ]\" + \n        \"\\n\" +\n        \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n        \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n        \"userLimitFactor) ]\" + \"\\n\" +\n        \"maxActiveApplications \u003d \" + maxActiveApplications +\n        \" [\u003d max(\" + \n        \"(int)ceil((clusterResourceMemory / minimumAllocation) *\" + \n        \"maxAMResourcePercent * absoluteMaxCapacity),\" + \n        \"1) ]\" + \"\\n\" +\n        \"maxActiveApplicationsPerUser \u003d \" + maxActiveApplicationsPerUser +\n        \" [\u003d max(\" +\n        \"(int)(maxActiveApplications * (userLimit / 100.0f) * \" +\n        \"userLimitFactor),\" +\n        \"1) ]\" + \"\\n\" +\n        \"utilization \u003d \" + utilization +\n        \" [\u003d usedResourcesMemory / \" +\n        \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n        \"usedCapacity \u003d \" + usedCapacity +\n        \" [\u003d usedResourcesMemory / \" +\n        \"(clusterResourceMemory * parent.absoluteCapacity)]\" + \"\\n\" +\n        \"maxAMResourcePercent \u003d \" + maxAMResourcePercent +\n        \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n        \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n        \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n        \"maximumAllocationMemory ]\" + \"\\n\" +\n        \"numContainers \u003d \" + numContainers +\n        \" [\u003d currentNumContainers ]\" + \"\\n\" +\n        \"state \u003d \" + state +\n        \" [\u003d configuredState ]\" + \"\\n\" +\n        \"acls \u003d \" + aclsString +\n        \" [\u003d configuredAcls ]\" + \"\\n\");\n  }",
          "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {}
        }
      ]
    },
    "a5c46c91655acebccd1367706b05946eff90f744": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3784. Fixed CapacityScheduler so that maxActiveApplications and maxActiveApplicationsPerUser per queue are not too low for small clusters. Contributed by Arun C Murthy.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1239971 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/02/12 5:16 PM",
      "commitName": "a5c46c91655acebccd1367706b05946eff90f744",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "02/02/12 4:33 PM",
      "commitNameOld": "72d34e6594371112bb4e9835817b382bd4161a6d",
      "commitAuthorOld": "Mahadev Konar",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,79 +1,88 @@\n   private synchronized void setupQueueConfigs(\n       float capacity, float absoluteCapacity, \n       float maximumCapacity, float absoluteMaxCapacity,\n       int userLimit, float userLimitFactor,\n       int maxApplications, int maxApplicationsPerUser,\n       int maxActiveApplications, int maxActiveApplicationsPerUser,\n       QueueState state, Map\u003cQueueACL, AccessControlList\u003e acls)\n   {\n     // Sanity check\n     CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n \n     this.capacity \u003d capacity; \n     this.absoluteCapacity \u003d parent.getAbsoluteCapacity() * capacity;\n \n     this.maximumCapacity \u003d maximumCapacity;\n     this.absoluteMaxCapacity \u003d absoluteMaxCapacity;\n \n     this.userLimit \u003d userLimit;\n     this.userLimitFactor \u003d userLimitFactor;\n \n     this.maxApplications \u003d maxApplications;\n     this.maxApplicationsPerUser \u003d maxApplicationsPerUser;\n \n     this.maxActiveApplications \u003d maxActiveApplications;\n     this.maxActiveApplicationsPerUser \u003d maxActiveApplicationsPerUser;\n     \n     this.state \u003d state;\n \n     this.acls \u003d acls;\n \n     this.queueInfo.setCapacity(this.capacity);\n     this.queueInfo.setMaximumCapacity(this.maximumCapacity);\n     this.queueInfo.setQueueState(this.state);\n \n     StringBuilder aclsString \u003d new StringBuilder();\n     for (Map.Entry\u003cQueueACL, AccessControlList\u003e e : acls.entrySet()) {\n       aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n     }\n \n     LOG.info(\"Initializing \" + queueName + \"\\n\" +\n         \"capacity \u003d \" + capacity +\n         \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n         \"asboluteCapacity \u003d \" + absoluteCapacity +\n         \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n         \"maxCapacity \u003d \" + maximumCapacity +\n         \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n         \"absoluteMaxCapacity \u003d \" + absoluteMaxCapacity +\n         \" [\u003d 1.0 maximumCapacity undefined, \" +\n-        \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \"\\n\" +\n+        \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n+        \"\\n\" +\n         \"userLimit \u003d \" + userLimit +\n         \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n         \"userLimitFactor \u003d \" + userLimitFactor +\n         \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n         \"maxApplications \u003d \" + maxApplications +\n-        \" [\u003d (int)(configuredMaximumSystemApplications * absoluteCapacity) ]\" + \"\\n\" +\n+        \" [\u003d (int)(configuredMaximumSystemApplications * absoluteCapacity) ]\" + \n+        \"\\n\" +\n         \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n-        \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * userLimitFactor) ]\" + \"\\n\" +\n+        \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n+        \"userLimitFactor) ]\" + \"\\n\" +\n         \"maxActiveApplications \u003d \" + maxActiveApplications +\n         \" [\u003d max(\" + \n-        \"(int)((clusterResourceMemory / (float)DEFAULT_AM_RESOURCE) *\" + \n-        \"maxAMResourcePercent * absoluteCapacity),\" + \n+        \"(int)ceil((clusterResourceMemory / minimumAllocation) *\" + \n+        \"maxAMResourcePercent * absoluteMaxCapacity),\" + \n         \"1) ]\" + \"\\n\" +\n         \"maxActiveApplicationsPerUser \u003d \" + maxActiveApplicationsPerUser +\n-        \" [\u003d (int)(maxActiveApplications * (userLimit / 100.0f) * userLimitFactor) ]\" + \"\\n\" +\n+        \" [\u003d max(\" +\n+        \"(int)(maxActiveApplications * (userLimit / 100.0f) * \" +\n+        \"userLimitFactor),\" +\n+        \"1) ]\" + \"\\n\" +\n         \"utilization \u003d \" + utilization +\n-        \" [\u003d usedResourcesMemory /  (clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n+        \" [\u003d usedResourcesMemory / \" +\n+        \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n         \"usedCapacity \u003d \" + usedCapacity +\n-        \" [\u003d usedResourcesMemory / (clusterResourceMemory * parent.absoluteCapacity)]\" + \"\\n\" +\n+        \" [\u003d usedResourcesMemory / \" +\n+        \"(clusterResourceMemory * parent.absoluteCapacity)]\" + \"\\n\" +\n         \"maxAMResourcePercent \u003d \" + maxAMResourcePercent +\n         \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n         \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n-        \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / maximumAllocationMemory ]\" + \"\\n\" +\n+        \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n+        \"maximumAllocationMemory ]\" + \"\\n\" +\n         \"numContainers \u003d \" + numContainers +\n         \" [\u003d currentNumContainers ]\" + \"\\n\" +\n         \"state \u003d \" + state +\n         \" [\u003d configuredState ]\" + \"\\n\" +\n         \"acls \u003d \" + aclsString +\n         \" [\u003d configuredAcls ]\" + \"\\n\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void setupQueueConfigs(\n      float capacity, float absoluteCapacity, \n      float maximumCapacity, float absoluteMaxCapacity,\n      int userLimit, float userLimitFactor,\n      int maxApplications, int maxApplicationsPerUser,\n      int maxActiveApplications, int maxActiveApplicationsPerUser,\n      QueueState state, Map\u003cQueueACL, AccessControlList\u003e acls)\n  {\n    // Sanity check\n    CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n\n    this.capacity \u003d capacity; \n    this.absoluteCapacity \u003d parent.getAbsoluteCapacity() * capacity;\n\n    this.maximumCapacity \u003d maximumCapacity;\n    this.absoluteMaxCapacity \u003d absoluteMaxCapacity;\n\n    this.userLimit \u003d userLimit;\n    this.userLimitFactor \u003d userLimitFactor;\n\n    this.maxApplications \u003d maxApplications;\n    this.maxApplicationsPerUser \u003d maxApplicationsPerUser;\n\n    this.maxActiveApplications \u003d maxActiveApplications;\n    this.maxActiveApplicationsPerUser \u003d maxActiveApplicationsPerUser;\n    \n    this.state \u003d state;\n\n    this.acls \u003d acls;\n\n    this.queueInfo.setCapacity(this.capacity);\n    this.queueInfo.setMaximumCapacity(this.maximumCapacity);\n    this.queueInfo.setQueueState(this.state);\n\n    StringBuilder aclsString \u003d new StringBuilder();\n    for (Map.Entry\u003cQueueACL, AccessControlList\u003e e : acls.entrySet()) {\n      aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n    }\n\n    LOG.info(\"Initializing \" + queueName + \"\\n\" +\n        \"capacity \u003d \" + capacity +\n        \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n        \"asboluteCapacity \u003d \" + absoluteCapacity +\n        \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n        \"maxCapacity \u003d \" + maximumCapacity +\n        \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n        \"absoluteMaxCapacity \u003d \" + absoluteMaxCapacity +\n        \" [\u003d 1.0 maximumCapacity undefined, \" +\n        \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \n        \"\\n\" +\n        \"userLimit \u003d \" + userLimit +\n        \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n        \"userLimitFactor \u003d \" + userLimitFactor +\n        \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n        \"maxApplications \u003d \" + maxApplications +\n        \" [\u003d (int)(configuredMaximumSystemApplications * absoluteCapacity) ]\" + \n        \"\\n\" +\n        \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n        \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * \" +\n        \"userLimitFactor) ]\" + \"\\n\" +\n        \"maxActiveApplications \u003d \" + maxActiveApplications +\n        \" [\u003d max(\" + \n        \"(int)ceil((clusterResourceMemory / minimumAllocation) *\" + \n        \"maxAMResourcePercent * absoluteMaxCapacity),\" + \n        \"1) ]\" + \"\\n\" +\n        \"maxActiveApplicationsPerUser \u003d \" + maxActiveApplicationsPerUser +\n        \" [\u003d max(\" +\n        \"(int)(maxActiveApplications * (userLimit / 100.0f) * \" +\n        \"userLimitFactor),\" +\n        \"1) ]\" + \"\\n\" +\n        \"utilization \u003d \" + utilization +\n        \" [\u003d usedResourcesMemory / \" +\n        \"(clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n        \"usedCapacity \u003d \" + usedCapacity +\n        \" [\u003d usedResourcesMemory / \" +\n        \"(clusterResourceMemory * parent.absoluteCapacity)]\" + \"\\n\" +\n        \"maxAMResourcePercent \u003d \" + maxAMResourcePercent +\n        \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n        \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n        \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / \" +\n        \"maximumAllocationMemory ]\" + \"\\n\" +\n        \"numContainers \u003d \" + numContainers +\n        \" [\u003d currentNumContainers ]\" + \"\\n\" +\n        \"state \u003d \" + state +\n        \" [\u003d configuredState ]\" + \"\\n\" +\n        \"acls \u003d \" + aclsString +\n        \" [\u003d configuredAcls ]\" + \"\\n\");\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "9d1621da52fd7f4ee68f80fdbf420180a42b5b1d": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3683. Fixed maxCapacity of queues to be product of parent maxCapacities. \n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1235858 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/01/12 10:17 AM",
      "commitName": "9d1621da52fd7f4ee68f80fdbf420180a42b5b1d",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "23/01/12 5:00 PM",
      "commitNameOld": "9a153334ac5a83a49a44ead02466453f3127120f",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 1.72,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,79 +1,79 @@\n   private synchronized void setupQueueConfigs(\n       float capacity, float absoluteCapacity, \n       float maximumCapacity, float absoluteMaxCapacity,\n       int userLimit, float userLimitFactor,\n       int maxApplications, int maxApplicationsPerUser,\n       int maxActiveApplications, int maxActiveApplicationsPerUser,\n       QueueState state, Map\u003cQueueACL, AccessControlList\u003e acls)\n   {\n     // Sanity check\n     CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n \n     this.capacity \u003d capacity; \n     this.absoluteCapacity \u003d parent.getAbsoluteCapacity() * capacity;\n \n     this.maximumCapacity \u003d maximumCapacity;\n     this.absoluteMaxCapacity \u003d absoluteMaxCapacity;\n \n     this.userLimit \u003d userLimit;\n     this.userLimitFactor \u003d userLimitFactor;\n \n     this.maxApplications \u003d maxApplications;\n     this.maxApplicationsPerUser \u003d maxApplicationsPerUser;\n \n     this.maxActiveApplications \u003d maxActiveApplications;\n     this.maxActiveApplicationsPerUser \u003d maxActiveApplicationsPerUser;\n     \n     this.state \u003d state;\n \n     this.acls \u003d acls;\n \n     this.queueInfo.setCapacity(this.capacity);\n     this.queueInfo.setMaximumCapacity(this.maximumCapacity);\n     this.queueInfo.setQueueState(this.state);\n \n     StringBuilder aclsString \u003d new StringBuilder();\n     for (Map.Entry\u003cQueueACL, AccessControlList\u003e e : acls.entrySet()) {\n       aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n     }\n \n     LOG.info(\"Initializing \" + queueName + \"\\n\" +\n         \"capacity \u003d \" + capacity +\n         \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n         \"asboluteCapacity \u003d \" + absoluteCapacity +\n         \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n         \"maxCapacity \u003d \" + maximumCapacity +\n         \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n         \"absoluteMaxCapacity \u003d \" + absoluteMaxCapacity +\n-        \" [\u003d Float.MAX_VALUE if maximumCapacity undefined, \" +\n-        \"(parentAbsoluteCapacity * maximumCapacity) / 100 otherwise ]\" + \"\\n\" +\n+        \" [\u003d 1.0 maximumCapacity undefined, \" +\n+        \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \"\\n\" +\n         \"userLimit \u003d \" + userLimit +\n         \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n         \"userLimitFactor \u003d \" + userLimitFactor +\n         \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n         \"maxApplications \u003d \" + maxApplications +\n         \" [\u003d (int)(configuredMaximumSystemApplications * absoluteCapacity) ]\" + \"\\n\" +\n         \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n         \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * userLimitFactor) ]\" + \"\\n\" +\n         \"maxActiveApplications \u003d \" + maxActiveApplications +\n         \" [\u003d max(\" + \n         \"(int)((clusterResourceMemory / (float)DEFAULT_AM_RESOURCE) *\" + \n         \"maxAMResourcePercent * absoluteCapacity),\" + \n         \"1) ]\" + \"\\n\" +\n         \"maxActiveApplicationsPerUser \u003d \" + maxActiveApplicationsPerUser +\n         \" [\u003d (int)(maxActiveApplications * (userLimit / 100.0f) * userLimitFactor) ]\" + \"\\n\" +\n         \"utilization \u003d \" + utilization +\n         \" [\u003d usedResourcesMemory /  (clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n         \"usedCapacity \u003d \" + usedCapacity +\n         \" [\u003d usedResourcesMemory / (clusterResourceMemory * parent.absoluteCapacity)]\" + \"\\n\" +\n         \"maxAMResourcePercent \u003d \" + maxAMResourcePercent +\n         \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n         \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n         \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / maximumAllocationMemory ]\" + \"\\n\" +\n         \"numContainers \u003d \" + numContainers +\n         \" [\u003d currentNumContainers ]\" + \"\\n\" +\n         \"state \u003d \" + state +\n         \" [\u003d configuredState ]\" + \"\\n\" +\n         \"acls \u003d \" + aclsString +\n         \" [\u003d configuredAcls ]\" + \"\\n\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void setupQueueConfigs(\n      float capacity, float absoluteCapacity, \n      float maximumCapacity, float absoluteMaxCapacity,\n      int userLimit, float userLimitFactor,\n      int maxApplications, int maxApplicationsPerUser,\n      int maxActiveApplications, int maxActiveApplicationsPerUser,\n      QueueState state, Map\u003cQueueACL, AccessControlList\u003e acls)\n  {\n    // Sanity check\n    CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n\n    this.capacity \u003d capacity; \n    this.absoluteCapacity \u003d parent.getAbsoluteCapacity() * capacity;\n\n    this.maximumCapacity \u003d maximumCapacity;\n    this.absoluteMaxCapacity \u003d absoluteMaxCapacity;\n\n    this.userLimit \u003d userLimit;\n    this.userLimitFactor \u003d userLimitFactor;\n\n    this.maxApplications \u003d maxApplications;\n    this.maxApplicationsPerUser \u003d maxApplicationsPerUser;\n\n    this.maxActiveApplications \u003d maxActiveApplications;\n    this.maxActiveApplicationsPerUser \u003d maxActiveApplicationsPerUser;\n    \n    this.state \u003d state;\n\n    this.acls \u003d acls;\n\n    this.queueInfo.setCapacity(this.capacity);\n    this.queueInfo.setMaximumCapacity(this.maximumCapacity);\n    this.queueInfo.setQueueState(this.state);\n\n    StringBuilder aclsString \u003d new StringBuilder();\n    for (Map.Entry\u003cQueueACL, AccessControlList\u003e e : acls.entrySet()) {\n      aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n    }\n\n    LOG.info(\"Initializing \" + queueName + \"\\n\" +\n        \"capacity \u003d \" + capacity +\n        \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n        \"asboluteCapacity \u003d \" + absoluteCapacity +\n        \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n        \"maxCapacity \u003d \" + maximumCapacity +\n        \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n        \"absoluteMaxCapacity \u003d \" + absoluteMaxCapacity +\n        \" [\u003d 1.0 maximumCapacity undefined, \" +\n        \"(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]\" + \"\\n\" +\n        \"userLimit \u003d \" + userLimit +\n        \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n        \"userLimitFactor \u003d \" + userLimitFactor +\n        \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n        \"maxApplications \u003d \" + maxApplications +\n        \" [\u003d (int)(configuredMaximumSystemApplications * absoluteCapacity) ]\" + \"\\n\" +\n        \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n        \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * userLimitFactor) ]\" + \"\\n\" +\n        \"maxActiveApplications \u003d \" + maxActiveApplications +\n        \" [\u003d max(\" + \n        \"(int)((clusterResourceMemory / (float)DEFAULT_AM_RESOURCE) *\" + \n        \"maxAMResourcePercent * absoluteCapacity),\" + \n        \"1) ]\" + \"\\n\" +\n        \"maxActiveApplicationsPerUser \u003d \" + maxActiveApplicationsPerUser +\n        \" [\u003d (int)(maxActiveApplications * (userLimit / 100.0f) * userLimitFactor) ]\" + \"\\n\" +\n        \"utilization \u003d \" + utilization +\n        \" [\u003d usedResourcesMemory /  (clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n        \"usedCapacity \u003d \" + usedCapacity +\n        \" [\u003d usedResourcesMemory / (clusterResourceMemory * parent.absoluteCapacity)]\" + \"\\n\" +\n        \"maxAMResourcePercent \u003d \" + maxAMResourcePercent +\n        \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n        \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n        \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / maximumAllocationMemory ]\" + \"\\n\" +\n        \"numContainers \u003d \" + numContainers +\n        \" [\u003d currentNumContainers ]\" + \"\\n\" +\n        \"state \u003d \" + state +\n        \" [\u003d configuredState ]\" + \"\\n\" +\n        \"acls \u003d \" + aclsString +\n        \" [\u003d configuredAcls ]\" + \"\\n\");\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "9a153334ac5a83a49a44ead02466453f3127120f": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3681. Fixed computation of queue\u0027s usedCapacity.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1235103 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/01/12 5:00 PM",
      "commitName": "9a153334ac5a83a49a44ead02466453f3127120f",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "16/01/12 1:56 PM",
      "commitNameOld": "4a343c9d4ab4c993b545f0c1062c6b5449b065f0",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 7.13,
      "commitsBetweenForRepo": 28,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,79 +1,79 @@\n   private synchronized void setupQueueConfigs(\n       float capacity, float absoluteCapacity, \n       float maximumCapacity, float absoluteMaxCapacity,\n       int userLimit, float userLimitFactor,\n       int maxApplications, int maxApplicationsPerUser,\n       int maxActiveApplications, int maxActiveApplicationsPerUser,\n       QueueState state, Map\u003cQueueACL, AccessControlList\u003e acls)\n   {\n     // Sanity check\n     CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n \n     this.capacity \u003d capacity; \n     this.absoluteCapacity \u003d parent.getAbsoluteCapacity() * capacity;\n \n     this.maximumCapacity \u003d maximumCapacity;\n     this.absoluteMaxCapacity \u003d absoluteMaxCapacity;\n \n     this.userLimit \u003d userLimit;\n     this.userLimitFactor \u003d userLimitFactor;\n \n     this.maxApplications \u003d maxApplications;\n     this.maxApplicationsPerUser \u003d maxApplicationsPerUser;\n \n     this.maxActiveApplications \u003d maxActiveApplications;\n     this.maxActiveApplicationsPerUser \u003d maxActiveApplicationsPerUser;\n     \n     this.state \u003d state;\n \n     this.acls \u003d acls;\n \n     this.queueInfo.setCapacity(this.capacity);\n     this.queueInfo.setMaximumCapacity(this.maximumCapacity);\n     this.queueInfo.setQueueState(this.state);\n \n     StringBuilder aclsString \u003d new StringBuilder();\n     for (Map.Entry\u003cQueueACL, AccessControlList\u003e e : acls.entrySet()) {\n       aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n     }\n \n     LOG.info(\"Initializing \" + queueName + \"\\n\" +\n         \"capacity \u003d \" + capacity +\n         \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n         \"asboluteCapacity \u003d \" + absoluteCapacity +\n         \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n         \"maxCapacity \u003d \" + maximumCapacity +\n         \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n         \"absoluteMaxCapacity \u003d \" + absoluteMaxCapacity +\n         \" [\u003d Float.MAX_VALUE if maximumCapacity undefined, \" +\n         \"(parentAbsoluteCapacity * maximumCapacity) / 100 otherwise ]\" + \"\\n\" +\n         \"userLimit \u003d \" + userLimit +\n         \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n         \"userLimitFactor \u003d \" + userLimitFactor +\n         \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n         \"maxApplications \u003d \" + maxApplications +\n         \" [\u003d (int)(configuredMaximumSystemApplications * absoluteCapacity) ]\" + \"\\n\" +\n         \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n         \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * userLimitFactor) ]\" + \"\\n\" +\n         \"maxActiveApplications \u003d \" + maxActiveApplications +\n         \" [\u003d max(\" + \n         \"(int)((clusterResourceMemory / (float)DEFAULT_AM_RESOURCE) *\" + \n         \"maxAMResourcePercent * absoluteCapacity),\" + \n         \"1) ]\" + \"\\n\" +\n         \"maxActiveApplicationsPerUser \u003d \" + maxActiveApplicationsPerUser +\n         \" [\u003d (int)(maxActiveApplications * (userLimit / 100.0f) * userLimitFactor) ]\" + \"\\n\" +\n         \"utilization \u003d \" + utilization +\n-        \" [\u003d usedResourcesMemory / queueLimit ]\" + \"\\n\" +\n+        \" [\u003d usedResourcesMemory /  (clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n         \"usedCapacity \u003d \" + usedCapacity +\n-        \" [\u003d usedResourcesMemory / (clusterResourceMemory * capacity) ]\" + \"\\n\" +\n+        \" [\u003d usedResourcesMemory / (clusterResourceMemory * parent.absoluteCapacity)]\" + \"\\n\" +\n         \"maxAMResourcePercent \u003d \" + maxAMResourcePercent +\n         \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n         \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n         \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / maximumAllocationMemory ]\" + \"\\n\" +\n         \"numContainers \u003d \" + numContainers +\n         \" [\u003d currentNumContainers ]\" + \"\\n\" +\n         \"state \u003d \" + state +\n         \" [\u003d configuredState ]\" + \"\\n\" +\n         \"acls \u003d \" + aclsString +\n         \" [\u003d configuredAcls ]\" + \"\\n\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void setupQueueConfigs(\n      float capacity, float absoluteCapacity, \n      float maximumCapacity, float absoluteMaxCapacity,\n      int userLimit, float userLimitFactor,\n      int maxApplications, int maxApplicationsPerUser,\n      int maxActiveApplications, int maxActiveApplicationsPerUser,\n      QueueState state, Map\u003cQueueACL, AccessControlList\u003e acls)\n  {\n    // Sanity check\n    CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n\n    this.capacity \u003d capacity; \n    this.absoluteCapacity \u003d parent.getAbsoluteCapacity() * capacity;\n\n    this.maximumCapacity \u003d maximumCapacity;\n    this.absoluteMaxCapacity \u003d absoluteMaxCapacity;\n\n    this.userLimit \u003d userLimit;\n    this.userLimitFactor \u003d userLimitFactor;\n\n    this.maxApplications \u003d maxApplications;\n    this.maxApplicationsPerUser \u003d maxApplicationsPerUser;\n\n    this.maxActiveApplications \u003d maxActiveApplications;\n    this.maxActiveApplicationsPerUser \u003d maxActiveApplicationsPerUser;\n    \n    this.state \u003d state;\n\n    this.acls \u003d acls;\n\n    this.queueInfo.setCapacity(this.capacity);\n    this.queueInfo.setMaximumCapacity(this.maximumCapacity);\n    this.queueInfo.setQueueState(this.state);\n\n    StringBuilder aclsString \u003d new StringBuilder();\n    for (Map.Entry\u003cQueueACL, AccessControlList\u003e e : acls.entrySet()) {\n      aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n    }\n\n    LOG.info(\"Initializing \" + queueName + \"\\n\" +\n        \"capacity \u003d \" + capacity +\n        \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n        \"asboluteCapacity \u003d \" + absoluteCapacity +\n        \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n        \"maxCapacity \u003d \" + maximumCapacity +\n        \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n        \"absoluteMaxCapacity \u003d \" + absoluteMaxCapacity +\n        \" [\u003d Float.MAX_VALUE if maximumCapacity undefined, \" +\n        \"(parentAbsoluteCapacity * maximumCapacity) / 100 otherwise ]\" + \"\\n\" +\n        \"userLimit \u003d \" + userLimit +\n        \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n        \"userLimitFactor \u003d \" + userLimitFactor +\n        \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n        \"maxApplications \u003d \" + maxApplications +\n        \" [\u003d (int)(configuredMaximumSystemApplications * absoluteCapacity) ]\" + \"\\n\" +\n        \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n        \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * userLimitFactor) ]\" + \"\\n\" +\n        \"maxActiveApplications \u003d \" + maxActiveApplications +\n        \" [\u003d max(\" + \n        \"(int)((clusterResourceMemory / (float)DEFAULT_AM_RESOURCE) *\" + \n        \"maxAMResourcePercent * absoluteCapacity),\" + \n        \"1) ]\" + \"\\n\" +\n        \"maxActiveApplicationsPerUser \u003d \" + maxActiveApplicationsPerUser +\n        \" [\u003d (int)(maxActiveApplications * (userLimit / 100.0f) * userLimitFactor) ]\" + \"\\n\" +\n        \"utilization \u003d \" + utilization +\n        \" [\u003d usedResourcesMemory /  (clusterResourceMemory * absoluteCapacity)]\" + \"\\n\" +\n        \"usedCapacity \u003d \" + usedCapacity +\n        \" [\u003d usedResourcesMemory / (clusterResourceMemory * parent.absoluteCapacity)]\" + \"\\n\" +\n        \"maxAMResourcePercent \u003d \" + maxAMResourcePercent +\n        \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n        \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n        \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / maximumAllocationMemory ]\" + \"\\n\" +\n        \"numContainers \u003d \" + numContainers +\n        \" [\u003d currentNumContainers ]\" + \"\\n\" +\n        \"state \u003d \" + state +\n        \" [\u003d configuredState ]\" + \"\\n\" +\n        \"acls \u003d \" + aclsString +\n        \" [\u003d configuredAcls ]\" + \"\\n\");\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "41b1e3ffec808db440778bebc258c10c76834513": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "MAPREDUCE-3329. Fixed CapacityScheduler to ensure maximum-capacity cannot be lesser than capacity for any queue.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1205260 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "22/11/11 5:42 PM",
      "commitName": "41b1e3ffec808db440778bebc258c10c76834513",
      "commitAuthor": "Arun Murthy",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "MAPREDUCE-3329. Fixed CapacityScheduler to ensure maximum-capacity cannot be lesser than capacity for any queue.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1205260 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "22/11/11 5:42 PM",
          "commitName": "41b1e3ffec808db440778bebc258c10c76834513",
          "commitAuthor": "Arun Murthy",
          "commitDateOld": "14/11/11 2:38 PM",
          "commitNameOld": "58bfa24ae4858d336e5322a10c9e4147b1d14d8b",
          "commitAuthorOld": "Mahadev Konar",
          "daysBetweenCommits": 8.13,
          "commitsBetweenForRepo": 56,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,76 +1,79 @@\n   private synchronized void setupQueueConfigs(\n       float capacity, float absoluteCapacity, \n-      float maxCapacity, float absoluteMaxCapacity,\n+      float maximumCapacity, float absoluteMaxCapacity,\n       int userLimit, float userLimitFactor,\n       int maxApplications, int maxApplicationsPerUser,\n       int maxActiveApplications, int maxActiveApplicationsPerUser,\n       QueueState state, Map\u003cQueueACL, AccessControlList\u003e acls)\n   {\n+    // Sanity check\n+    CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n+\n     this.capacity \u003d capacity; \n     this.absoluteCapacity \u003d parent.getAbsoluteCapacity() * capacity;\n \n-    this.maximumCapacity \u003d maxCapacity;\n+    this.maximumCapacity \u003d maximumCapacity;\n     this.absoluteMaxCapacity \u003d absoluteMaxCapacity;\n \n     this.userLimit \u003d userLimit;\n     this.userLimitFactor \u003d userLimitFactor;\n \n     this.maxApplications \u003d maxApplications;\n     this.maxApplicationsPerUser \u003d maxApplicationsPerUser;\n \n     this.maxActiveApplications \u003d maxActiveApplications;\n     this.maxActiveApplicationsPerUser \u003d maxActiveApplicationsPerUser;\n     \n     this.state \u003d state;\n \n     this.acls \u003d acls;\n \n-    this.queueInfo.setCapacity(capacity);\n-    this.queueInfo.setMaximumCapacity(maximumCapacity);\n-    this.queueInfo.setQueueState(state);\n+    this.queueInfo.setCapacity(this.capacity);\n+    this.queueInfo.setMaximumCapacity(this.maximumCapacity);\n+    this.queueInfo.setQueueState(this.state);\n \n     StringBuilder aclsString \u003d new StringBuilder();\n     for (Map.Entry\u003cQueueACL, AccessControlList\u003e e : acls.entrySet()) {\n       aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n     }\n \n     LOG.info(\"Initializing \" + queueName + \"\\n\" +\n         \"capacity \u003d \" + capacity +\n         \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n         \"asboluteCapacity \u003d \" + absoluteCapacity +\n         \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n-        \"maxCapacity \u003d \" + maxCapacity +\n+        \"maxCapacity \u003d \" + maximumCapacity +\n         \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n         \"absoluteMaxCapacity \u003d \" + absoluteMaxCapacity +\n         \" [\u003d Float.MAX_VALUE if maximumCapacity undefined, \" +\n         \"(parentAbsoluteCapacity * maximumCapacity) / 100 otherwise ]\" + \"\\n\" +\n         \"userLimit \u003d \" + userLimit +\n         \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n         \"userLimitFactor \u003d \" + userLimitFactor +\n         \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n         \"maxApplications \u003d \" + maxApplications +\n         \" [\u003d (int)(configuredMaximumSystemApplications * absoluteCapacity) ]\" + \"\\n\" +\n         \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n         \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * userLimitFactor) ]\" + \"\\n\" +\n         \"maxActiveApplications \u003d \" + maxActiveApplications +\n         \" [\u003d max(\" + \n         \"(int)((clusterResourceMemory / (float)DEFAULT_AM_RESOURCE) *\" + \n         \"maxAMResourcePercent * absoluteCapacity),\" + \n         \"1) ]\" + \"\\n\" +\n         \"maxActiveApplicationsPerUser \u003d \" + maxActiveApplicationsPerUser +\n         \" [\u003d (int)(maxActiveApplications * (userLimit / 100.0f) * userLimitFactor) ]\" + \"\\n\" +\n         \"utilization \u003d \" + utilization +\n         \" [\u003d usedResourcesMemory / queueLimit ]\" + \"\\n\" +\n         \"usedCapacity \u003d \" + usedCapacity +\n         \" [\u003d usedResourcesMemory / (clusterResourceMemory * capacity) ]\" + \"\\n\" +\n         \"maxAMResourcePercent \u003d \" + maxAMResourcePercent +\n         \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n         \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n         \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / maximumAllocationMemory ]\" + \"\\n\" +\n         \"numContainers \u003d \" + numContainers +\n         \" [\u003d currentNumContainers ]\" + \"\\n\" +\n         \"state \u003d \" + state +\n         \" [\u003d configuredState ]\" + \"\\n\" +\n         \"acls \u003d \" + aclsString +\n         \" [\u003d configuredAcls ]\" + \"\\n\");\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private synchronized void setupQueueConfigs(\n      float capacity, float absoluteCapacity, \n      float maximumCapacity, float absoluteMaxCapacity,\n      int userLimit, float userLimitFactor,\n      int maxApplications, int maxApplicationsPerUser,\n      int maxActiveApplications, int maxActiveApplicationsPerUser,\n      QueueState state, Map\u003cQueueACL, AccessControlList\u003e acls)\n  {\n    // Sanity check\n    CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n\n    this.capacity \u003d capacity; \n    this.absoluteCapacity \u003d parent.getAbsoluteCapacity() * capacity;\n\n    this.maximumCapacity \u003d maximumCapacity;\n    this.absoluteMaxCapacity \u003d absoluteMaxCapacity;\n\n    this.userLimit \u003d userLimit;\n    this.userLimitFactor \u003d userLimitFactor;\n\n    this.maxApplications \u003d maxApplications;\n    this.maxApplicationsPerUser \u003d maxApplicationsPerUser;\n\n    this.maxActiveApplications \u003d maxActiveApplications;\n    this.maxActiveApplicationsPerUser \u003d maxActiveApplicationsPerUser;\n    \n    this.state \u003d state;\n\n    this.acls \u003d acls;\n\n    this.queueInfo.setCapacity(this.capacity);\n    this.queueInfo.setMaximumCapacity(this.maximumCapacity);\n    this.queueInfo.setQueueState(this.state);\n\n    StringBuilder aclsString \u003d new StringBuilder();\n    for (Map.Entry\u003cQueueACL, AccessControlList\u003e e : acls.entrySet()) {\n      aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n    }\n\n    LOG.info(\"Initializing \" + queueName + \"\\n\" +\n        \"capacity \u003d \" + capacity +\n        \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n        \"asboluteCapacity \u003d \" + absoluteCapacity +\n        \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n        \"maxCapacity \u003d \" + maximumCapacity +\n        \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n        \"absoluteMaxCapacity \u003d \" + absoluteMaxCapacity +\n        \" [\u003d Float.MAX_VALUE if maximumCapacity undefined, \" +\n        \"(parentAbsoluteCapacity * maximumCapacity) / 100 otherwise ]\" + \"\\n\" +\n        \"userLimit \u003d \" + userLimit +\n        \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n        \"userLimitFactor \u003d \" + userLimitFactor +\n        \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n        \"maxApplications \u003d \" + maxApplications +\n        \" [\u003d (int)(configuredMaximumSystemApplications * absoluteCapacity) ]\" + \"\\n\" +\n        \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n        \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * userLimitFactor) ]\" + \"\\n\" +\n        \"maxActiveApplications \u003d \" + maxActiveApplications +\n        \" [\u003d max(\" + \n        \"(int)((clusterResourceMemory / (float)DEFAULT_AM_RESOURCE) *\" + \n        \"maxAMResourcePercent * absoluteCapacity),\" + \n        \"1) ]\" + \"\\n\" +\n        \"maxActiveApplicationsPerUser \u003d \" + maxActiveApplicationsPerUser +\n        \" [\u003d (int)(maxActiveApplications * (userLimit / 100.0f) * userLimitFactor) ]\" + \"\\n\" +\n        \"utilization \u003d \" + utilization +\n        \" [\u003d usedResourcesMemory / queueLimit ]\" + \"\\n\" +\n        \"usedCapacity \u003d \" + usedCapacity +\n        \" [\u003d usedResourcesMemory / (clusterResourceMemory * capacity) ]\" + \"\\n\" +\n        \"maxAMResourcePercent \u003d \" + maxAMResourcePercent +\n        \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n        \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n        \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / maximumAllocationMemory ]\" + \"\\n\" +\n        \"numContainers \u003d \" + numContainers +\n        \" [\u003d currentNumContainers ]\" + \"\\n\" +\n        \"state \u003d \" + state +\n        \" [\u003d configuredState ]\" + \"\\n\" +\n        \"acls \u003d \" + aclsString +\n        \" [\u003d configuredAcls ]\" + \"\\n\");\n  }",
          "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {
            "oldValue": "[capacity-float, absoluteCapacity-float, maxCapacity-float, absoluteMaxCapacity-float, userLimit-int, userLimitFactor-float, maxApplications-int, maxApplicationsPerUser-int, maxActiveApplications-int, maxActiveApplicationsPerUser-int, state-QueueState, acls-Map\u003cQueueACL,AccessControlList\u003e]",
            "newValue": "[capacity-float, absoluteCapacity-float, maximumCapacity-float, absoluteMaxCapacity-float, userLimit-int, userLimitFactor-float, maxApplications-int, maxApplicationsPerUser-int, maxActiveApplications-int, maxActiveApplicationsPerUser-int, state-QueueState, acls-Map\u003cQueueACL,AccessControlList\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "MAPREDUCE-3329. Fixed CapacityScheduler to ensure maximum-capacity cannot be lesser than capacity for any queue.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1205260 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "22/11/11 5:42 PM",
          "commitName": "41b1e3ffec808db440778bebc258c10c76834513",
          "commitAuthor": "Arun Murthy",
          "commitDateOld": "14/11/11 2:38 PM",
          "commitNameOld": "58bfa24ae4858d336e5322a10c9e4147b1d14d8b",
          "commitAuthorOld": "Mahadev Konar",
          "daysBetweenCommits": 8.13,
          "commitsBetweenForRepo": 56,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,76 +1,79 @@\n   private synchronized void setupQueueConfigs(\n       float capacity, float absoluteCapacity, \n-      float maxCapacity, float absoluteMaxCapacity,\n+      float maximumCapacity, float absoluteMaxCapacity,\n       int userLimit, float userLimitFactor,\n       int maxApplications, int maxApplicationsPerUser,\n       int maxActiveApplications, int maxActiveApplicationsPerUser,\n       QueueState state, Map\u003cQueueACL, AccessControlList\u003e acls)\n   {\n+    // Sanity check\n+    CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n+\n     this.capacity \u003d capacity; \n     this.absoluteCapacity \u003d parent.getAbsoluteCapacity() * capacity;\n \n-    this.maximumCapacity \u003d maxCapacity;\n+    this.maximumCapacity \u003d maximumCapacity;\n     this.absoluteMaxCapacity \u003d absoluteMaxCapacity;\n \n     this.userLimit \u003d userLimit;\n     this.userLimitFactor \u003d userLimitFactor;\n \n     this.maxApplications \u003d maxApplications;\n     this.maxApplicationsPerUser \u003d maxApplicationsPerUser;\n \n     this.maxActiveApplications \u003d maxActiveApplications;\n     this.maxActiveApplicationsPerUser \u003d maxActiveApplicationsPerUser;\n     \n     this.state \u003d state;\n \n     this.acls \u003d acls;\n \n-    this.queueInfo.setCapacity(capacity);\n-    this.queueInfo.setMaximumCapacity(maximumCapacity);\n-    this.queueInfo.setQueueState(state);\n+    this.queueInfo.setCapacity(this.capacity);\n+    this.queueInfo.setMaximumCapacity(this.maximumCapacity);\n+    this.queueInfo.setQueueState(this.state);\n \n     StringBuilder aclsString \u003d new StringBuilder();\n     for (Map.Entry\u003cQueueACL, AccessControlList\u003e e : acls.entrySet()) {\n       aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n     }\n \n     LOG.info(\"Initializing \" + queueName + \"\\n\" +\n         \"capacity \u003d \" + capacity +\n         \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n         \"asboluteCapacity \u003d \" + absoluteCapacity +\n         \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n-        \"maxCapacity \u003d \" + maxCapacity +\n+        \"maxCapacity \u003d \" + maximumCapacity +\n         \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n         \"absoluteMaxCapacity \u003d \" + absoluteMaxCapacity +\n         \" [\u003d Float.MAX_VALUE if maximumCapacity undefined, \" +\n         \"(parentAbsoluteCapacity * maximumCapacity) / 100 otherwise ]\" + \"\\n\" +\n         \"userLimit \u003d \" + userLimit +\n         \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n         \"userLimitFactor \u003d \" + userLimitFactor +\n         \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n         \"maxApplications \u003d \" + maxApplications +\n         \" [\u003d (int)(configuredMaximumSystemApplications * absoluteCapacity) ]\" + \"\\n\" +\n         \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n         \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * userLimitFactor) ]\" + \"\\n\" +\n         \"maxActiveApplications \u003d \" + maxActiveApplications +\n         \" [\u003d max(\" + \n         \"(int)((clusterResourceMemory / (float)DEFAULT_AM_RESOURCE) *\" + \n         \"maxAMResourcePercent * absoluteCapacity),\" + \n         \"1) ]\" + \"\\n\" +\n         \"maxActiveApplicationsPerUser \u003d \" + maxActiveApplicationsPerUser +\n         \" [\u003d (int)(maxActiveApplications * (userLimit / 100.0f) * userLimitFactor) ]\" + \"\\n\" +\n         \"utilization \u003d \" + utilization +\n         \" [\u003d usedResourcesMemory / queueLimit ]\" + \"\\n\" +\n         \"usedCapacity \u003d \" + usedCapacity +\n         \" [\u003d usedResourcesMemory / (clusterResourceMemory * capacity) ]\" + \"\\n\" +\n         \"maxAMResourcePercent \u003d \" + maxAMResourcePercent +\n         \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n         \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n         \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / maximumAllocationMemory ]\" + \"\\n\" +\n         \"numContainers \u003d \" + numContainers +\n         \" [\u003d currentNumContainers ]\" + \"\\n\" +\n         \"state \u003d \" + state +\n         \" [\u003d configuredState ]\" + \"\\n\" +\n         \"acls \u003d \" + aclsString +\n         \" [\u003d configuredAcls ]\" + \"\\n\");\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private synchronized void setupQueueConfigs(\n      float capacity, float absoluteCapacity, \n      float maximumCapacity, float absoluteMaxCapacity,\n      int userLimit, float userLimitFactor,\n      int maxApplications, int maxApplicationsPerUser,\n      int maxActiveApplications, int maxActiveApplicationsPerUser,\n      QueueState state, Map\u003cQueueACL, AccessControlList\u003e acls)\n  {\n    // Sanity check\n    CSQueueUtils.checkMaxCapacity(getQueueName(), capacity, maximumCapacity);\n\n    this.capacity \u003d capacity; \n    this.absoluteCapacity \u003d parent.getAbsoluteCapacity() * capacity;\n\n    this.maximumCapacity \u003d maximumCapacity;\n    this.absoluteMaxCapacity \u003d absoluteMaxCapacity;\n\n    this.userLimit \u003d userLimit;\n    this.userLimitFactor \u003d userLimitFactor;\n\n    this.maxApplications \u003d maxApplications;\n    this.maxApplicationsPerUser \u003d maxApplicationsPerUser;\n\n    this.maxActiveApplications \u003d maxActiveApplications;\n    this.maxActiveApplicationsPerUser \u003d maxActiveApplicationsPerUser;\n    \n    this.state \u003d state;\n\n    this.acls \u003d acls;\n\n    this.queueInfo.setCapacity(this.capacity);\n    this.queueInfo.setMaximumCapacity(this.maximumCapacity);\n    this.queueInfo.setQueueState(this.state);\n\n    StringBuilder aclsString \u003d new StringBuilder();\n    for (Map.Entry\u003cQueueACL, AccessControlList\u003e e : acls.entrySet()) {\n      aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n    }\n\n    LOG.info(\"Initializing \" + queueName + \"\\n\" +\n        \"capacity \u003d \" + capacity +\n        \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n        \"asboluteCapacity \u003d \" + absoluteCapacity +\n        \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n        \"maxCapacity \u003d \" + maximumCapacity +\n        \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n        \"absoluteMaxCapacity \u003d \" + absoluteMaxCapacity +\n        \" [\u003d Float.MAX_VALUE if maximumCapacity undefined, \" +\n        \"(parentAbsoluteCapacity * maximumCapacity) / 100 otherwise ]\" + \"\\n\" +\n        \"userLimit \u003d \" + userLimit +\n        \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n        \"userLimitFactor \u003d \" + userLimitFactor +\n        \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n        \"maxApplications \u003d \" + maxApplications +\n        \" [\u003d (int)(configuredMaximumSystemApplications * absoluteCapacity) ]\" + \"\\n\" +\n        \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n        \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * userLimitFactor) ]\" + \"\\n\" +\n        \"maxActiveApplications \u003d \" + maxActiveApplications +\n        \" [\u003d max(\" + \n        \"(int)((clusterResourceMemory / (float)DEFAULT_AM_RESOURCE) *\" + \n        \"maxAMResourcePercent * absoluteCapacity),\" + \n        \"1) ]\" + \"\\n\" +\n        \"maxActiveApplicationsPerUser \u003d \" + maxActiveApplicationsPerUser +\n        \" [\u003d (int)(maxActiveApplications * (userLimit / 100.0f) * userLimitFactor) ]\" + \"\\n\" +\n        \"utilization \u003d \" + utilization +\n        \" [\u003d usedResourcesMemory / queueLimit ]\" + \"\\n\" +\n        \"usedCapacity \u003d \" + usedCapacity +\n        \" [\u003d usedResourcesMemory / (clusterResourceMemory * capacity) ]\" + \"\\n\" +\n        \"maxAMResourcePercent \u003d \" + maxAMResourcePercent +\n        \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n        \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n        \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / maximumAllocationMemory ]\" + \"\\n\" +\n        \"numContainers \u003d \" + numContainers +\n        \" [\u003d currentNumContainers ]\" + \"\\n\" +\n        \"state \u003d \" + state +\n        \" [\u003d configuredState ]\" + \"\\n\" +\n        \"acls \u003d \" + aclsString +\n        \" [\u003d configuredAcls ]\" + \"\\n\");\n  }",
          "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {}
        }
      ]
    },
    "58bfa24ae4858d336e5322a10c9e4147b1d14d8b": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3341. Enhance logging of initalized queue limit values. (Anupam Seth via mahadev)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1201947 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/11/11 2:38 PM",
      "commitName": "58bfa24ae4858d336e5322a10c9e4147b1d14d8b",
      "commitAuthor": "Mahadev Konar",
      "commitDateOld": "20/10/11 4:45 AM",
      "commitNameOld": "df2991c0cbc3f35c2640b93680667507c4f810dd",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 25.45,
      "commitsBetweenForRepo": 191,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,76 @@\n   private synchronized void setupQueueConfigs(\n       float capacity, float absoluteCapacity, \n       float maxCapacity, float absoluteMaxCapacity,\n       int userLimit, float userLimitFactor,\n       int maxApplications, int maxApplicationsPerUser,\n       int maxActiveApplications, int maxActiveApplicationsPerUser,\n       QueueState state, Map\u003cQueueACL, AccessControlList\u003e acls)\n   {\n     this.capacity \u003d capacity; \n     this.absoluteCapacity \u003d parent.getAbsoluteCapacity() * capacity;\n \n     this.maximumCapacity \u003d maxCapacity;\n     this.absoluteMaxCapacity \u003d absoluteMaxCapacity;\n \n     this.userLimit \u003d userLimit;\n     this.userLimitFactor \u003d userLimitFactor;\n \n     this.maxApplications \u003d maxApplications;\n     this.maxApplicationsPerUser \u003d maxApplicationsPerUser;\n \n     this.maxActiveApplications \u003d maxActiveApplications;\n     this.maxActiveApplicationsPerUser \u003d maxActiveApplicationsPerUser;\n     \n     this.state \u003d state;\n \n     this.acls \u003d acls;\n \n     this.queueInfo.setCapacity(capacity);\n     this.queueInfo.setMaximumCapacity(maximumCapacity);\n     this.queueInfo.setQueueState(state);\n \n     StringBuilder aclsString \u003d new StringBuilder();\n     for (Map.Entry\u003cQueueACL, AccessControlList\u003e e : acls.entrySet()) {\n       aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n     }\n \n-    LOG.info(\"Initializing \" + queueName +\n-        \", capacity\u003d\" + capacity + \n-        \", asboluteCapacity\u003d\" + absoluteCapacity + \n-        \", maxCapacity\u003d\" + maxCapacity +\n-        \", asboluteMaxCapacity\u003d\" + absoluteMaxCapacity +\n-        \", userLimit\u003d\" + userLimit + \", userLimitFactor\u003d\" + userLimitFactor + \n-        \", maxApplications\u003d\" + maxApplications + \n-        \", maxApplicationsPerUser\u003d\" + maxApplicationsPerUser + \n-        \", state\u003d\" + state +\n-        \", acls\u003d\" + aclsString);\n+    LOG.info(\"Initializing \" + queueName + \"\\n\" +\n+        \"capacity \u003d \" + capacity +\n+        \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n+        \"asboluteCapacity \u003d \" + absoluteCapacity +\n+        \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n+        \"maxCapacity \u003d \" + maxCapacity +\n+        \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n+        \"absoluteMaxCapacity \u003d \" + absoluteMaxCapacity +\n+        \" [\u003d Float.MAX_VALUE if maximumCapacity undefined, \" +\n+        \"(parentAbsoluteCapacity * maximumCapacity) / 100 otherwise ]\" + \"\\n\" +\n+        \"userLimit \u003d \" + userLimit +\n+        \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n+        \"userLimitFactor \u003d \" + userLimitFactor +\n+        \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n+        \"maxApplications \u003d \" + maxApplications +\n+        \" [\u003d (int)(configuredMaximumSystemApplications * absoluteCapacity) ]\" + \"\\n\" +\n+        \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n+        \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * userLimitFactor) ]\" + \"\\n\" +\n+        \"maxActiveApplications \u003d \" + maxActiveApplications +\n+        \" [\u003d max(\" + \n+        \"(int)((clusterResourceMemory / (float)DEFAULT_AM_RESOURCE) *\" + \n+        \"maxAMResourcePercent * absoluteCapacity),\" + \n+        \"1) ]\" + \"\\n\" +\n+        \"maxActiveApplicationsPerUser \u003d \" + maxActiveApplicationsPerUser +\n+        \" [\u003d (int)(maxActiveApplications * (userLimit / 100.0f) * userLimitFactor) ]\" + \"\\n\" +\n+        \"utilization \u003d \" + utilization +\n+        \" [\u003d usedResourcesMemory / queueLimit ]\" + \"\\n\" +\n+        \"usedCapacity \u003d \" + usedCapacity +\n+        \" [\u003d usedResourcesMemory / (clusterResourceMemory * capacity) ]\" + \"\\n\" +\n+        \"maxAMResourcePercent \u003d \" + maxAMResourcePercent +\n+        \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n+        \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n+        \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / maximumAllocationMemory ]\" + \"\\n\" +\n+        \"numContainers \u003d \" + numContainers +\n+        \" [\u003d currentNumContainers ]\" + \"\\n\" +\n+        \"state \u003d \" + state +\n+        \" [\u003d configuredState ]\" + \"\\n\" +\n+        \"acls \u003d \" + aclsString +\n+        \" [\u003d configuredAcls ]\" + \"\\n\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void setupQueueConfigs(\n      float capacity, float absoluteCapacity, \n      float maxCapacity, float absoluteMaxCapacity,\n      int userLimit, float userLimitFactor,\n      int maxApplications, int maxApplicationsPerUser,\n      int maxActiveApplications, int maxActiveApplicationsPerUser,\n      QueueState state, Map\u003cQueueACL, AccessControlList\u003e acls)\n  {\n    this.capacity \u003d capacity; \n    this.absoluteCapacity \u003d parent.getAbsoluteCapacity() * capacity;\n\n    this.maximumCapacity \u003d maxCapacity;\n    this.absoluteMaxCapacity \u003d absoluteMaxCapacity;\n\n    this.userLimit \u003d userLimit;\n    this.userLimitFactor \u003d userLimitFactor;\n\n    this.maxApplications \u003d maxApplications;\n    this.maxApplicationsPerUser \u003d maxApplicationsPerUser;\n\n    this.maxActiveApplications \u003d maxActiveApplications;\n    this.maxActiveApplicationsPerUser \u003d maxActiveApplicationsPerUser;\n    \n    this.state \u003d state;\n\n    this.acls \u003d acls;\n\n    this.queueInfo.setCapacity(capacity);\n    this.queueInfo.setMaximumCapacity(maximumCapacity);\n    this.queueInfo.setQueueState(state);\n\n    StringBuilder aclsString \u003d new StringBuilder();\n    for (Map.Entry\u003cQueueACL, AccessControlList\u003e e : acls.entrySet()) {\n      aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n    }\n\n    LOG.info(\"Initializing \" + queueName + \"\\n\" +\n        \"capacity \u003d \" + capacity +\n        \" [\u003d (float) configuredCapacity / 100 ]\" + \"\\n\" + \n        \"asboluteCapacity \u003d \" + absoluteCapacity +\n        \" [\u003d parentAbsoluteCapacity * capacity ]\" + \"\\n\" +\n        \"maxCapacity \u003d \" + maxCapacity +\n        \" [\u003d configuredMaxCapacity ]\" + \"\\n\" +\n        \"absoluteMaxCapacity \u003d \" + absoluteMaxCapacity +\n        \" [\u003d Float.MAX_VALUE if maximumCapacity undefined, \" +\n        \"(parentAbsoluteCapacity * maximumCapacity) / 100 otherwise ]\" + \"\\n\" +\n        \"userLimit \u003d \" + userLimit +\n        \" [\u003d configuredUserLimit ]\" + \"\\n\" +\n        \"userLimitFactor \u003d \" + userLimitFactor +\n        \" [\u003d configuredUserLimitFactor ]\" + \"\\n\" +\n        \"maxApplications \u003d \" + maxApplications +\n        \" [\u003d (int)(configuredMaximumSystemApplications * absoluteCapacity) ]\" + \"\\n\" +\n        \"maxApplicationsPerUser \u003d \" + maxApplicationsPerUser +\n        \" [\u003d (int)(maxApplications * (userLimit / 100.0f) * userLimitFactor) ]\" + \"\\n\" +\n        \"maxActiveApplications \u003d \" + maxActiveApplications +\n        \" [\u003d max(\" + \n        \"(int)((clusterResourceMemory / (float)DEFAULT_AM_RESOURCE) *\" + \n        \"maxAMResourcePercent * absoluteCapacity),\" + \n        \"1) ]\" + \"\\n\" +\n        \"maxActiveApplicationsPerUser \u003d \" + maxActiveApplicationsPerUser +\n        \" [\u003d (int)(maxActiveApplications * (userLimit / 100.0f) * userLimitFactor) ]\" + \"\\n\" +\n        \"utilization \u003d \" + utilization +\n        \" [\u003d usedResourcesMemory / queueLimit ]\" + \"\\n\" +\n        \"usedCapacity \u003d \" + usedCapacity +\n        \" [\u003d usedResourcesMemory / (clusterResourceMemory * capacity) ]\" + \"\\n\" +\n        \"maxAMResourcePercent \u003d \" + maxAMResourcePercent +\n        \" [\u003d configuredMaximumAMResourcePercent ]\" + \"\\n\" +\n        \"minimumAllocationFactor \u003d \" + minimumAllocationFactor +\n        \" [\u003d (float)(maximumAllocationMemory - minimumAllocationMemory) / maximumAllocationMemory ]\" + \"\\n\" +\n        \"numContainers \u003d \" + numContainers +\n        \" [\u003d currentNumContainers ]\" + \"\\n\" +\n        \"state \u003d \" + state +\n        \" [\u003d configuredState ]\" + \"\\n\" +\n        \"acls \u003d \" + aclsString +\n        \" [\u003d configuredAcls ]\" + \"\\n\");\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {}
    },
    "6b608aad7d52b524fa94955a538e8b3524d42d93": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "MAPREDUCE-2697. Enhance CapacityScheduler to cap concurrently running applications per-queue \u0026 per-user.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1165403 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "05/09/11 12:49 PM",
      "commitName": "6b608aad7d52b524fa94955a538e8b3524d42d93",
      "commitAuthor": "Arun Murthy",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "MAPREDUCE-2697. Enhance CapacityScheduler to cap concurrently running applications per-queue \u0026 per-user.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1165403 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "05/09/11 12:49 PM",
          "commitName": "6b608aad7d52b524fa94955a538e8b3524d42d93",
          "commitAuthor": "Arun Murthy",
          "commitDateOld": "31/08/11 12:52 PM",
          "commitNameOld": "b9a5fd51904a074a7a33f38266378f0f6f97b531",
          "commitAuthorOld": "Arun Murthy",
          "daysBetweenCommits": 5.0,
          "commitsBetweenForRepo": 17,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,43 +1,47 @@\n   private synchronized void setupQueueConfigs(\n       float capacity, float absoluteCapacity, \n       float maxCapacity, float absoluteMaxCapacity,\n       int userLimit, float userLimitFactor,\n       int maxApplications, int maxApplicationsPerUser,\n+      int maxActiveApplications, int maxActiveApplicationsPerUser,\n       QueueState state, Map\u003cQueueACL, AccessControlList\u003e acls)\n   {\n     this.capacity \u003d capacity; \n     this.absoluteCapacity \u003d parent.getAbsoluteCapacity() * capacity;\n \n     this.maximumCapacity \u003d maxCapacity;\n     this.absoluteMaxCapacity \u003d absoluteMaxCapacity;\n \n     this.userLimit \u003d userLimit;\n     this.userLimitFactor \u003d userLimitFactor;\n \n     this.maxApplications \u003d maxApplications;\n     this.maxApplicationsPerUser \u003d maxApplicationsPerUser;\n \n+    this.maxActiveApplications \u003d maxActiveApplications;\n+    this.maxActiveApplicationsPerUser \u003d maxActiveApplicationsPerUser;\n+    \n     this.state \u003d state;\n \n     this.acls \u003d acls;\n \n     this.queueInfo.setCapacity(capacity);\n     this.queueInfo.setMaximumCapacity(maximumCapacity);\n     this.queueInfo.setQueueState(state);\n \n     StringBuilder aclsString \u003d new StringBuilder();\n     for (Map.Entry\u003cQueueACL, AccessControlList\u003e e : acls.entrySet()) {\n       aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n     }\n \n     LOG.info(\"Initializing \" + queueName +\n         \", capacity\u003d\" + capacity + \n         \", asboluteCapacity\u003d\" + absoluteCapacity + \n         \", maxCapacity\u003d\" + maxCapacity +\n         \", asboluteMaxCapacity\u003d\" + absoluteMaxCapacity +\n         \", userLimit\u003d\" + userLimit + \", userLimitFactor\u003d\" + userLimitFactor + \n         \", maxApplications\u003d\" + maxApplications + \n         \", maxApplicationsPerUser\u003d\" + maxApplicationsPerUser + \n         \", state\u003d\" + state +\n         \", acls\u003d\" + aclsString);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private synchronized void setupQueueConfigs(\n      float capacity, float absoluteCapacity, \n      float maxCapacity, float absoluteMaxCapacity,\n      int userLimit, float userLimitFactor,\n      int maxApplications, int maxApplicationsPerUser,\n      int maxActiveApplications, int maxActiveApplicationsPerUser,\n      QueueState state, Map\u003cQueueACL, AccessControlList\u003e acls)\n  {\n    this.capacity \u003d capacity; \n    this.absoluteCapacity \u003d parent.getAbsoluteCapacity() * capacity;\n\n    this.maximumCapacity \u003d maxCapacity;\n    this.absoluteMaxCapacity \u003d absoluteMaxCapacity;\n\n    this.userLimit \u003d userLimit;\n    this.userLimitFactor \u003d userLimitFactor;\n\n    this.maxApplications \u003d maxApplications;\n    this.maxApplicationsPerUser \u003d maxApplicationsPerUser;\n\n    this.maxActiveApplications \u003d maxActiveApplications;\n    this.maxActiveApplicationsPerUser \u003d maxActiveApplicationsPerUser;\n    \n    this.state \u003d state;\n\n    this.acls \u003d acls;\n\n    this.queueInfo.setCapacity(capacity);\n    this.queueInfo.setMaximumCapacity(maximumCapacity);\n    this.queueInfo.setQueueState(state);\n\n    StringBuilder aclsString \u003d new StringBuilder();\n    for (Map.Entry\u003cQueueACL, AccessControlList\u003e e : acls.entrySet()) {\n      aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n    }\n\n    LOG.info(\"Initializing \" + queueName +\n        \", capacity\u003d\" + capacity + \n        \", asboluteCapacity\u003d\" + absoluteCapacity + \n        \", maxCapacity\u003d\" + maxCapacity +\n        \", asboluteMaxCapacity\u003d\" + absoluteMaxCapacity +\n        \", userLimit\u003d\" + userLimit + \", userLimitFactor\u003d\" + userLimitFactor + \n        \", maxApplications\u003d\" + maxApplications + \n        \", maxApplicationsPerUser\u003d\" + maxApplicationsPerUser + \n        \", state\u003d\" + state +\n        \", acls\u003d\" + aclsString);\n  }",
          "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {
            "oldValue": "[capacity-float, absoluteCapacity-float, maxCapacity-float, absoluteMaxCapacity-float, userLimit-int, userLimitFactor-float, maxApplications-int, maxApplicationsPerUser-int, state-QueueState, acls-Map\u003cQueueACL,AccessControlList\u003e]",
            "newValue": "[capacity-float, absoluteCapacity-float, maxCapacity-float, absoluteMaxCapacity-float, userLimit-int, userLimitFactor-float, maxApplications-int, maxApplicationsPerUser-int, maxActiveApplications-int, maxActiveApplicationsPerUser-int, state-QueueState, acls-Map\u003cQueueACL,AccessControlList\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "MAPREDUCE-2697. Enhance CapacityScheduler to cap concurrently running applications per-queue \u0026 per-user.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1165403 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "05/09/11 12:49 PM",
          "commitName": "6b608aad7d52b524fa94955a538e8b3524d42d93",
          "commitAuthor": "Arun Murthy",
          "commitDateOld": "31/08/11 12:52 PM",
          "commitNameOld": "b9a5fd51904a074a7a33f38266378f0f6f97b531",
          "commitAuthorOld": "Arun Murthy",
          "daysBetweenCommits": 5.0,
          "commitsBetweenForRepo": 17,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,43 +1,47 @@\n   private synchronized void setupQueueConfigs(\n       float capacity, float absoluteCapacity, \n       float maxCapacity, float absoluteMaxCapacity,\n       int userLimit, float userLimitFactor,\n       int maxApplications, int maxApplicationsPerUser,\n+      int maxActiveApplications, int maxActiveApplicationsPerUser,\n       QueueState state, Map\u003cQueueACL, AccessControlList\u003e acls)\n   {\n     this.capacity \u003d capacity; \n     this.absoluteCapacity \u003d parent.getAbsoluteCapacity() * capacity;\n \n     this.maximumCapacity \u003d maxCapacity;\n     this.absoluteMaxCapacity \u003d absoluteMaxCapacity;\n \n     this.userLimit \u003d userLimit;\n     this.userLimitFactor \u003d userLimitFactor;\n \n     this.maxApplications \u003d maxApplications;\n     this.maxApplicationsPerUser \u003d maxApplicationsPerUser;\n \n+    this.maxActiveApplications \u003d maxActiveApplications;\n+    this.maxActiveApplicationsPerUser \u003d maxActiveApplicationsPerUser;\n+    \n     this.state \u003d state;\n \n     this.acls \u003d acls;\n \n     this.queueInfo.setCapacity(capacity);\n     this.queueInfo.setMaximumCapacity(maximumCapacity);\n     this.queueInfo.setQueueState(state);\n \n     StringBuilder aclsString \u003d new StringBuilder();\n     for (Map.Entry\u003cQueueACL, AccessControlList\u003e e : acls.entrySet()) {\n       aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n     }\n \n     LOG.info(\"Initializing \" + queueName +\n         \", capacity\u003d\" + capacity + \n         \", asboluteCapacity\u003d\" + absoluteCapacity + \n         \", maxCapacity\u003d\" + maxCapacity +\n         \", asboluteMaxCapacity\u003d\" + absoluteMaxCapacity +\n         \", userLimit\u003d\" + userLimit + \", userLimitFactor\u003d\" + userLimitFactor + \n         \", maxApplications\u003d\" + maxApplications + \n         \", maxApplicationsPerUser\u003d\" + maxApplicationsPerUser + \n         \", state\u003d\" + state +\n         \", acls\u003d\" + aclsString);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private synchronized void setupQueueConfigs(\n      float capacity, float absoluteCapacity, \n      float maxCapacity, float absoluteMaxCapacity,\n      int userLimit, float userLimitFactor,\n      int maxApplications, int maxApplicationsPerUser,\n      int maxActiveApplications, int maxActiveApplicationsPerUser,\n      QueueState state, Map\u003cQueueACL, AccessControlList\u003e acls)\n  {\n    this.capacity \u003d capacity; \n    this.absoluteCapacity \u003d parent.getAbsoluteCapacity() * capacity;\n\n    this.maximumCapacity \u003d maxCapacity;\n    this.absoluteMaxCapacity \u003d absoluteMaxCapacity;\n\n    this.userLimit \u003d userLimit;\n    this.userLimitFactor \u003d userLimitFactor;\n\n    this.maxApplications \u003d maxApplications;\n    this.maxApplicationsPerUser \u003d maxApplicationsPerUser;\n\n    this.maxActiveApplications \u003d maxActiveApplications;\n    this.maxActiveApplicationsPerUser \u003d maxActiveApplicationsPerUser;\n    \n    this.state \u003d state;\n\n    this.acls \u003d acls;\n\n    this.queueInfo.setCapacity(capacity);\n    this.queueInfo.setMaximumCapacity(maximumCapacity);\n    this.queueInfo.setQueueState(state);\n\n    StringBuilder aclsString \u003d new StringBuilder();\n    for (Map.Entry\u003cQueueACL, AccessControlList\u003e e : acls.entrySet()) {\n      aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n    }\n\n    LOG.info(\"Initializing \" + queueName +\n        \", capacity\u003d\" + capacity + \n        \", asboluteCapacity\u003d\" + absoluteCapacity + \n        \", maxCapacity\u003d\" + maxCapacity +\n        \", asboluteMaxCapacity\u003d\" + absoluteMaxCapacity +\n        \", userLimit\u003d\" + userLimit + \", userLimitFactor\u003d\" + userLimitFactor + \n        \", maxApplications\u003d\" + maxApplications + \n        \", maxApplicationsPerUser\u003d\" + maxApplicationsPerUser + \n        \", state\u003d\" + state +\n        \", acls\u003d\" + aclsString);\n  }",
          "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
          "extendedDetails": {}
        }
      ]
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private synchronized void setupQueueConfigs(\n      float capacity, float absoluteCapacity, \n      float maxCapacity, float absoluteMaxCapacity,\n      int userLimit, float userLimitFactor,\n      int maxApplications, int maxApplicationsPerUser,\n      QueueState state, Map\u003cQueueACL, AccessControlList\u003e acls)\n  {\n    this.capacity \u003d capacity; \n    this.absoluteCapacity \u003d parent.getAbsoluteCapacity() * capacity;\n\n    this.maximumCapacity \u003d maxCapacity;\n    this.absoluteMaxCapacity \u003d absoluteMaxCapacity;\n\n    this.userLimit \u003d userLimit;\n    this.userLimitFactor \u003d userLimitFactor;\n\n    this.maxApplications \u003d maxApplications;\n    this.maxApplicationsPerUser \u003d maxApplicationsPerUser;\n\n    this.state \u003d state;\n\n    this.acls \u003d acls;\n\n    this.queueInfo.setCapacity(capacity);\n    this.queueInfo.setMaximumCapacity(maximumCapacity);\n    this.queueInfo.setQueueState(state);\n\n    StringBuilder aclsString \u003d new StringBuilder();\n    for (Map.Entry\u003cQueueACL, AccessControlList\u003e e : acls.entrySet()) {\n      aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n    }\n\n    LOG.info(\"Initializing \" + queueName +\n        \", capacity\u003d\" + capacity + \n        \", asboluteCapacity\u003d\" + absoluteCapacity + \n        \", maxCapacity\u003d\" + maxCapacity +\n        \", asboluteMaxCapacity\u003d\" + absoluteMaxCapacity +\n        \", userLimit\u003d\" + userLimit + \", userLimitFactor\u003d\" + userLimitFactor + \n        \", maxApplications\u003d\" + maxApplications + \n        \", maxApplicationsPerUser\u003d\" + maxApplicationsPerUser + \n        \", state\u003d\" + state +\n        \", acls\u003d\" + aclsString);\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java",
        "newPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java"
      }
    },
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-279. MapReduce 2.0. Merging MR-279 branch into trunk. Contributed by Arun C Murthy, Christopher Douglas, Devaraj Das, Greg Roelofs, Jeffrey Naisbitt, Josh Wills, Jonathan Eagles, Krishna Ramachandran, Luke Lu, Mahadev Konar, Robert Evans, Sharad Agarwal, Siddharth Seth, Thomas Graves, and Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159166 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/08/11 4:07 AM",
      "commitName": "dbecbe5dfe50f834fc3b8401709079e9470cc517",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,43 @@\n+  private synchronized void setupQueueConfigs(\n+      float capacity, float absoluteCapacity, \n+      float maxCapacity, float absoluteMaxCapacity,\n+      int userLimit, float userLimitFactor,\n+      int maxApplications, int maxApplicationsPerUser,\n+      QueueState state, Map\u003cQueueACL, AccessControlList\u003e acls)\n+  {\n+    this.capacity \u003d capacity; \n+    this.absoluteCapacity \u003d parent.getAbsoluteCapacity() * capacity;\n+\n+    this.maximumCapacity \u003d maxCapacity;\n+    this.absoluteMaxCapacity \u003d absoluteMaxCapacity;\n+\n+    this.userLimit \u003d userLimit;\n+    this.userLimitFactor \u003d userLimitFactor;\n+\n+    this.maxApplications \u003d maxApplications;\n+    this.maxApplicationsPerUser \u003d maxApplicationsPerUser;\n+\n+    this.state \u003d state;\n+\n+    this.acls \u003d acls;\n+\n+    this.queueInfo.setCapacity(capacity);\n+    this.queueInfo.setMaximumCapacity(maximumCapacity);\n+    this.queueInfo.setQueueState(state);\n+\n+    StringBuilder aclsString \u003d new StringBuilder();\n+    for (Map.Entry\u003cQueueACL, AccessControlList\u003e e : acls.entrySet()) {\n+      aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n+    }\n+\n+    LOG.info(\"Initializing \" + queueName +\n+        \", capacity\u003d\" + capacity + \n+        \", asboluteCapacity\u003d\" + absoluteCapacity + \n+        \", maxCapacity\u003d\" + maxCapacity +\n+        \", asboluteMaxCapacity\u003d\" + absoluteMaxCapacity +\n+        \", userLimit\u003d\" + userLimit + \", userLimitFactor\u003d\" + userLimitFactor + \n+        \", maxApplications\u003d\" + maxApplications + \n+        \", maxApplicationsPerUser\u003d\" + maxApplicationsPerUser + \n+        \", state\u003d\" + state +\n+        \", acls\u003d\" + aclsString);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void setupQueueConfigs(\n      float capacity, float absoluteCapacity, \n      float maxCapacity, float absoluteMaxCapacity,\n      int userLimit, float userLimitFactor,\n      int maxApplications, int maxApplicationsPerUser,\n      QueueState state, Map\u003cQueueACL, AccessControlList\u003e acls)\n  {\n    this.capacity \u003d capacity; \n    this.absoluteCapacity \u003d parent.getAbsoluteCapacity() * capacity;\n\n    this.maximumCapacity \u003d maxCapacity;\n    this.absoluteMaxCapacity \u003d absoluteMaxCapacity;\n\n    this.userLimit \u003d userLimit;\n    this.userLimitFactor \u003d userLimitFactor;\n\n    this.maxApplications \u003d maxApplications;\n    this.maxApplicationsPerUser \u003d maxApplicationsPerUser;\n\n    this.state \u003d state;\n\n    this.acls \u003d acls;\n\n    this.queueInfo.setCapacity(capacity);\n    this.queueInfo.setMaximumCapacity(maximumCapacity);\n    this.queueInfo.setQueueState(state);\n\n    StringBuilder aclsString \u003d new StringBuilder();\n    for (Map.Entry\u003cQueueACL, AccessControlList\u003e e : acls.entrySet()) {\n      aclsString.append(e.getKey() + \":\" + e.getValue().getAclString());\n    }\n\n    LOG.info(\"Initializing \" + queueName +\n        \", capacity\u003d\" + capacity + \n        \", asboluteCapacity\u003d\" + absoluteCapacity + \n        \", maxCapacity\u003d\" + maxCapacity +\n        \", asboluteMaxCapacity\u003d\" + absoluteMaxCapacity +\n        \", userLimit\u003d\" + userLimit + \", userLimitFactor\u003d\" + userLimitFactor + \n        \", maxApplications\u003d\" + maxApplications + \n        \", maxApplicationsPerUser\u003d\" + maxApplicationsPerUser + \n        \", state\u003d\" + state +\n        \", acls\u003d\" + aclsString);\n  }",
      "path": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/LeafQueue.java"
    }
  }
}