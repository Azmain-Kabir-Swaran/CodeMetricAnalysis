{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "SwiftNativeFileSystemStore.java",
  "functionName": "listDirectory",
  "functionId": "listDirectory___path-SwiftObjectPath__listDeep-boolean__newest-boolean",
  "sourceFilePath": "hadoop-tools/hadoop-openstack/src/main/java/org/apache/hadoop/fs/swift/snative/SwiftNativeFileSystemStore.java",
  "functionStartLine": 311,
  "functionEndLine": 386,
  "numCommitsSeen": 11,
  "timeTaken": 914,
  "changeHistory": [
    "2e98ad34ce64a9e5184c53447004de20a637f927",
    "3caca924bc72fe4a0e5b1ea89adb098cc1eb7874"
  ],
  "changeHistoryShort": {
    "2e98ad34ce64a9e5184c53447004de20a637f927": "Ybodychange",
    "3caca924bc72fe4a0e5b1ea89adb098cc1eb7874": "Yintroduced"
  },
  "changeHistoryDetails": {
    "2e98ad34ce64a9e5184c53447004de20a637f927": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11381. Fix findbugs warnings in hadoop-distcp, hadoop-aws, hadoop-azure, and hadoop-openstack. Contributed by Li Lu.\n",
      "commitDate": "09/12/14 8:45 PM",
      "commitName": "2e98ad34ce64a9e5184c53447004de20a637f927",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "03/07/14 5:10 AM",
      "commitNameOld": "becc23fb65a5c2b632034b8b2c4c08832d47fd96",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 159.69,
      "commitsBetweenForRepo": 1469,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,76 +1,76 @@\n   private List\u003cFileStatus\u003e listDirectory(SwiftObjectPath path,\n                                          boolean listDeep,\n                                          boolean newest) throws IOException {\n     final byte[] bytes;\n     final ArrayList\u003cFileStatus\u003e files \u003d new ArrayList\u003cFileStatus\u003e();\n     final Path correctSwiftPath \u003d getCorrectSwiftPath(path);\n     try {\n       bytes \u003d swiftRestClient.listDeepObjectsInDirectory(path, listDeep);\n     } catch (FileNotFoundException e) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"\" +\n                 \"File/Directory not found \" + path);\n       }\n       if (SwiftUtils.isRootDir(path)) {\n         return Collections.emptyList();\n       } else {\n         throw e;\n       }\n     } catch (SwiftInvalidResponseException e) {\n       //bad HTTP error code\n       if (e.getStatusCode() \u003d\u003d HttpStatus.SC_NO_CONTENT) {\n         //this can come back on a root list if the container is empty\n         if (SwiftUtils.isRootDir(path)) {\n           return Collections.emptyList();\n         } else {\n           //NO_CONTENT returned on something other than the root directory;\n           //see if it is there, and convert to empty list or not found\n           //depending on whether the entry exists.\n           FileStatus stat \u003d getObjectMetadata(correctSwiftPath, newest);\n \n           if (stat.isDirectory()) {\n             //it\u0027s an empty directory. state that\n             return Collections.emptyList();\n           } else {\n             //it\u0027s a file -return that as the status\n             files.add(stat);\n             return files;\n           }\n         }\n       } else {\n         //a different status code: rethrow immediately\n         throw e;\n       }\n     }\n \n     final CollectionType collectionType \u003d JSONUtil.getJsonMapper().getTypeFactory().\n             constructCollectionType(List.class, SwiftObjectFileStatus.class);\n \n-    final List\u003cSwiftObjectFileStatus\u003e fileStatusList \u003d\n-            JSONUtil.toObject(new String(bytes), collectionType);\n+    final List\u003cSwiftObjectFileStatus\u003e fileStatusList \u003d JSONUtil.toObject(\n+        new String(bytes, Charset.forName(\"UTF-8\")), collectionType);\n \n     //this can happen if user lists file /data/files/file\n     //in this case swift will return empty array\n     if (fileStatusList.isEmpty()) {\n       SwiftFileStatus objectMetadata \u003d getObjectMetadata(correctSwiftPath,\n                                                          newest);\n       if (objectMetadata.isFile()) {\n         files.add(objectMetadata);\n       }\n \n       return files;\n     }\n \n     for (SwiftObjectFileStatus status : fileStatusList) {\n       if (status.getName() !\u003d null) {\n           files.add(new SwiftFileStatus(status.getBytes(),\n                   status.getBytes() \u003d\u003d 0,\n                   1,\n                   getBlocksize(),\n                   status.getLast_modified().getTime(),\n                   getCorrectSwiftPath(new Path(status.getName()))));\n       }\n     }\n \n     return files;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private List\u003cFileStatus\u003e listDirectory(SwiftObjectPath path,\n                                         boolean listDeep,\n                                         boolean newest) throws IOException {\n    final byte[] bytes;\n    final ArrayList\u003cFileStatus\u003e files \u003d new ArrayList\u003cFileStatus\u003e();\n    final Path correctSwiftPath \u003d getCorrectSwiftPath(path);\n    try {\n      bytes \u003d swiftRestClient.listDeepObjectsInDirectory(path, listDeep);\n    } catch (FileNotFoundException e) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"\" +\n                \"File/Directory not found \" + path);\n      }\n      if (SwiftUtils.isRootDir(path)) {\n        return Collections.emptyList();\n      } else {\n        throw e;\n      }\n    } catch (SwiftInvalidResponseException e) {\n      //bad HTTP error code\n      if (e.getStatusCode() \u003d\u003d HttpStatus.SC_NO_CONTENT) {\n        //this can come back on a root list if the container is empty\n        if (SwiftUtils.isRootDir(path)) {\n          return Collections.emptyList();\n        } else {\n          //NO_CONTENT returned on something other than the root directory;\n          //see if it is there, and convert to empty list or not found\n          //depending on whether the entry exists.\n          FileStatus stat \u003d getObjectMetadata(correctSwiftPath, newest);\n\n          if (stat.isDirectory()) {\n            //it\u0027s an empty directory. state that\n            return Collections.emptyList();\n          } else {\n            //it\u0027s a file -return that as the status\n            files.add(stat);\n            return files;\n          }\n        }\n      } else {\n        //a different status code: rethrow immediately\n        throw e;\n      }\n    }\n\n    final CollectionType collectionType \u003d JSONUtil.getJsonMapper().getTypeFactory().\n            constructCollectionType(List.class, SwiftObjectFileStatus.class);\n\n    final List\u003cSwiftObjectFileStatus\u003e fileStatusList \u003d JSONUtil.toObject(\n        new String(bytes, Charset.forName(\"UTF-8\")), collectionType);\n\n    //this can happen if user lists file /data/files/file\n    //in this case swift will return empty array\n    if (fileStatusList.isEmpty()) {\n      SwiftFileStatus objectMetadata \u003d getObjectMetadata(correctSwiftPath,\n                                                         newest);\n      if (objectMetadata.isFile()) {\n        files.add(objectMetadata);\n      }\n\n      return files;\n    }\n\n    for (SwiftObjectFileStatus status : fileStatusList) {\n      if (status.getName() !\u003d null) {\n          files.add(new SwiftFileStatus(status.getBytes(),\n                  status.getBytes() \u003d\u003d 0,\n                  1,\n                  getBlocksize(),\n                  status.getLast_modified().getTime(),\n                  getCorrectSwiftPath(new Path(status.getName()))));\n      }\n    }\n\n    return files;\n  }",
      "path": "hadoop-tools/hadoop-openstack/src/main/java/org/apache/hadoop/fs/swift/snative/SwiftNativeFileSystemStore.java",
      "extendedDetails": {}
    },
    "3caca924bc72fe4a0e5b1ea89adb098cc1eb7874": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-8545. Filesystem Implementation for OpenStack Swift\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1526854 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/09/13 4:32 AM",
      "commitName": "3caca924bc72fe4a0e5b1ea89adb098cc1eb7874",
      "commitAuthor": "Steve Loughran",
      "diff": "@@ -0,0 +1,76 @@\n+  private List\u003cFileStatus\u003e listDirectory(SwiftObjectPath path,\n+                                         boolean listDeep,\n+                                         boolean newest) throws IOException {\n+    final byte[] bytes;\n+    final ArrayList\u003cFileStatus\u003e files \u003d new ArrayList\u003cFileStatus\u003e();\n+    final Path correctSwiftPath \u003d getCorrectSwiftPath(path);\n+    try {\n+      bytes \u003d swiftRestClient.listDeepObjectsInDirectory(path, listDeep);\n+    } catch (FileNotFoundException e) {\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"\" +\n+                \"File/Directory not found \" + path);\n+      }\n+      if (SwiftUtils.isRootDir(path)) {\n+        return Collections.emptyList();\n+      } else {\n+        throw e;\n+      }\n+    } catch (SwiftInvalidResponseException e) {\n+      //bad HTTP error code\n+      if (e.getStatusCode() \u003d\u003d HttpStatus.SC_NO_CONTENT) {\n+        //this can come back on a root list if the container is empty\n+        if (SwiftUtils.isRootDir(path)) {\n+          return Collections.emptyList();\n+        } else {\n+          //NO_CONTENT returned on something other than the root directory;\n+          //see if it is there, and convert to empty list or not found\n+          //depending on whether the entry exists.\n+          FileStatus stat \u003d getObjectMetadata(correctSwiftPath, newest);\n+\n+          if (stat.isDirectory()) {\n+            //it\u0027s an empty directory. state that\n+            return Collections.emptyList();\n+          } else {\n+            //it\u0027s a file -return that as the status\n+            files.add(stat);\n+            return files;\n+          }\n+        }\n+      } else {\n+        //a different status code: rethrow immediately\n+        throw e;\n+      }\n+    }\n+\n+    final CollectionType collectionType \u003d JSONUtil.getJsonMapper().getTypeFactory().\n+            constructCollectionType(List.class, SwiftObjectFileStatus.class);\n+\n+    final List\u003cSwiftObjectFileStatus\u003e fileStatusList \u003d\n+            JSONUtil.toObject(new String(bytes), collectionType);\n+\n+    //this can happen if user lists file /data/files/file\n+    //in this case swift will return empty array\n+    if (fileStatusList.isEmpty()) {\n+      SwiftFileStatus objectMetadata \u003d getObjectMetadata(correctSwiftPath,\n+                                                         newest);\n+      if (objectMetadata.isFile()) {\n+        files.add(objectMetadata);\n+      }\n+\n+      return files;\n+    }\n+\n+    for (SwiftObjectFileStatus status : fileStatusList) {\n+      if (status.getName() !\u003d null) {\n+          files.add(new SwiftFileStatus(status.getBytes(),\n+                  status.getBytes() \u003d\u003d 0,\n+                  1,\n+                  getBlocksize(),\n+                  status.getLast_modified().getTime(),\n+                  getCorrectSwiftPath(new Path(status.getName()))));\n+      }\n+    }\n+\n+    return files;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private List\u003cFileStatus\u003e listDirectory(SwiftObjectPath path,\n                                         boolean listDeep,\n                                         boolean newest) throws IOException {\n    final byte[] bytes;\n    final ArrayList\u003cFileStatus\u003e files \u003d new ArrayList\u003cFileStatus\u003e();\n    final Path correctSwiftPath \u003d getCorrectSwiftPath(path);\n    try {\n      bytes \u003d swiftRestClient.listDeepObjectsInDirectory(path, listDeep);\n    } catch (FileNotFoundException e) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"\" +\n                \"File/Directory not found \" + path);\n      }\n      if (SwiftUtils.isRootDir(path)) {\n        return Collections.emptyList();\n      } else {\n        throw e;\n      }\n    } catch (SwiftInvalidResponseException e) {\n      //bad HTTP error code\n      if (e.getStatusCode() \u003d\u003d HttpStatus.SC_NO_CONTENT) {\n        //this can come back on a root list if the container is empty\n        if (SwiftUtils.isRootDir(path)) {\n          return Collections.emptyList();\n        } else {\n          //NO_CONTENT returned on something other than the root directory;\n          //see if it is there, and convert to empty list or not found\n          //depending on whether the entry exists.\n          FileStatus stat \u003d getObjectMetadata(correctSwiftPath, newest);\n\n          if (stat.isDirectory()) {\n            //it\u0027s an empty directory. state that\n            return Collections.emptyList();\n          } else {\n            //it\u0027s a file -return that as the status\n            files.add(stat);\n            return files;\n          }\n        }\n      } else {\n        //a different status code: rethrow immediately\n        throw e;\n      }\n    }\n\n    final CollectionType collectionType \u003d JSONUtil.getJsonMapper().getTypeFactory().\n            constructCollectionType(List.class, SwiftObjectFileStatus.class);\n\n    final List\u003cSwiftObjectFileStatus\u003e fileStatusList \u003d\n            JSONUtil.toObject(new String(bytes), collectionType);\n\n    //this can happen if user lists file /data/files/file\n    //in this case swift will return empty array\n    if (fileStatusList.isEmpty()) {\n      SwiftFileStatus objectMetadata \u003d getObjectMetadata(correctSwiftPath,\n                                                         newest);\n      if (objectMetadata.isFile()) {\n        files.add(objectMetadata);\n      }\n\n      return files;\n    }\n\n    for (SwiftObjectFileStatus status : fileStatusList) {\n      if (status.getName() !\u003d null) {\n          files.add(new SwiftFileStatus(status.getBytes(),\n                  status.getBytes() \u003d\u003d 0,\n                  1,\n                  getBlocksize(),\n                  status.getLast_modified().getTime(),\n                  getCorrectSwiftPath(new Path(status.getName()))));\n      }\n    }\n\n    return files;\n  }",
      "path": "hadoop-tools/hadoop-openstack/src/main/java/org/apache/hadoop/fs/swift/snative/SwiftNativeFileSystemStore.java"
    }
  }
}