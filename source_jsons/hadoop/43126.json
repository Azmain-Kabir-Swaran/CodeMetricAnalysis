{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ApiServer.java",
  "functionName": "updateService",
  "functionId": "updateService___request-HttpServletRequest(annotations-@Context)__appName-String(annotations-@PathParam(SERVICE_NAME))__updateServiceData-Service",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-services/hadoop-yarn-services-api/src/main/java/org/apache/hadoop/yarn/service/webapp/ApiServer.java",
  "functionStartLine": 424,
  "functionEndLine": 499,
  "numCommitsSeen": 40,
  "timeTaken": 4128,
  "changeHistory": [
    "4c465f5535054dad2ef0b18128fb115129f6939e",
    "913f87dada27776c539dfb352400ecf8d40e7943",
    "e557c6bd8de2811a561210f672f47b4d07a9d5c6",
    "a23ff8d88001ad8e4ac4c36fc1f7691d193dc1d0",
    "4a7369b09547a78f532af66c763c6994a38b5d68",
    "d553799030a5a64df328319aceb35734d0b2de20",
    "27d60a16342fd39973d43b61008f54a8815a6237",
    "e307edcb472207a39d1cbe4be6f7fcddc7b4fd6d",
    "836e3c45e8232fc4c8c795c0f93d2f3d7353f392",
    "438c1d333ebc0a3071bb556532ed959a4bd1e6d6",
    "68acd88dcbfe03a0134c60b5398dfaa31ad2b786",
    "40ab068eabe50875449d601471619a4e82fff86d"
  ],
  "changeHistoryShort": {
    "4c465f5535054dad2ef0b18128fb115129f6939e": "Ybodychange",
    "913f87dada27776c539dfb352400ecf8d40e7943": "Ybodychange",
    "e557c6bd8de2811a561210f672f47b4d07a9d5c6": "Ybodychange",
    "a23ff8d88001ad8e4ac4c36fc1f7691d193dc1d0": "Yfilerename",
    "4a7369b09547a78f532af66c763c6994a38b5d68": "Ybodychange",
    "d553799030a5a64df328319aceb35734d0b2de20": "Ybodychange",
    "27d60a16342fd39973d43b61008f54a8815a6237": "Ybodychange",
    "e307edcb472207a39d1cbe4be6f7fcddc7b4fd6d": "Ymultichange(Yparameterchange,Ybodychange)",
    "836e3c45e8232fc4c8c795c0f93d2f3d7353f392": "Ybodychange",
    "438c1d333ebc0a3071bb556532ed959a4bd1e6d6": "Ybodychange",
    "68acd88dcbfe03a0134c60b5398dfaa31ad2b786": "Ybodychange",
    "40ab068eabe50875449d601471619a4e82fff86d": "Yintroduced"
  },
  "changeHistoryDetails": {
    "4c465f5535054dad2ef0b18128fb115129f6939e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8761. Service AM support for decommissioning component instances.\n           Contributed by Billie Rinaldi\n",
      "commitDate": "12/11/18 4:53 PM",
      "commitName": "4c465f5535054dad2ef0b18128fb115129f6939e",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "22/10/18 12:59 PM",
      "commitNameOld": "292c9e017fb3fdf972f2b7a11de5223bfe07603b",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 21.2,
      "commitsBetweenForRepo": 152,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,70 +1,76 @@\n   public Response updateService(@Context HttpServletRequest request,\n       @PathParam(SERVICE_NAME) String appName,\n       Service updateServiceData) {\n     try {\n       UserGroupInformation ugi \u003d getProxyUser(request);\n       LOG.info(\"PUT: updateService for app \u003d {} with data \u003d {} user \u003d {}\",\n           appName, updateServiceData, ugi);\n       // Ignore the app name provided in updateServiceData and always use\n       // appName path param\n       updateServiceData.setName(appName);\n \n       if (updateServiceData.getState() !\u003d null\n           \u0026\u0026 updateServiceData.getState() \u003d\u003d ServiceState.FLEX) {\n         return flexService(updateServiceData, ugi);\n       }\n       // For STOP the app should be running. If already stopped then this\n       // operation will be a no-op. For START it should be in stopped state.\n       // If already running then this operation will be a no-op.\n       if (updateServiceData.getState() !\u003d null\n           \u0026\u0026 updateServiceData.getState() \u003d\u003d ServiceState.STOPPED) {\n         return stopService(appName, false, ugi);\n       }\n \n       // If a START is requested\n       if (updateServiceData.getState() !\u003d null\n           \u0026\u0026 updateServiceData.getState() \u003d\u003d ServiceState.STARTED) {\n         return startService(appName, ugi);\n       }\n \n       // If an UPGRADE is requested\n       if (updateServiceData.getState() !\u003d null \u0026\u0026 (\n           updateServiceData.getState() \u003d\u003d ServiceState.UPGRADING ||\n               updateServiceData.getState() \u003d\u003d\n                   ServiceState.UPGRADING_AUTO_FINALIZE) ||\n           updateServiceData.getState() \u003d\u003d ServiceState.EXPRESS_UPGRADING) {\n         return upgradeService(updateServiceData, ugi);\n       }\n \n       // If CANCEL_UPGRADING is requested\n       if (updateServiceData.getState() !\u003d null \u0026\u0026\n           updateServiceData.getState() \u003d\u003d CANCEL_UPGRADING) {\n         return cancelUpgradeService(appName, ugi);\n       }\n \n       // If new lifetime value specified then update it\n       if (updateServiceData.getLifetime() !\u003d null\n           \u0026\u0026 updateServiceData.getLifetime() \u003e 0) {\n         return updateLifetime(appName, updateServiceData, ugi);\n       }\n+\n+      for (Component c : updateServiceData.getComponents()) {\n+        if (c.getDecommissionedInstances().size() \u003e 0) {\n+          return decommissionInstances(updateServiceData, ugi);\n+        }\n+      }\n     } catch (UndeclaredThrowableException e) {\n       return formatResponse(Status.BAD_REQUEST,\n           e.getCause().getMessage());\n     } catch (AccessControlException e) {\n       return formatResponse(Status.FORBIDDEN, e.getMessage());\n     } catch (FileNotFoundException e) {\n       String message \u003d \"Application is not found app: \" + appName;\n       LOG.error(message, e);\n       return formatResponse(Status.NOT_FOUND, e.getMessage());\n     } catch (YarnException e) {\n       LOG.error(e.getMessage(), e);\n       return formatResponse(Status.NOT_FOUND, e.getMessage());\n     } catch (Exception e) {\n       String message \u003d \"Error while performing operation for app: \" + appName;\n       LOG.error(message, e);\n       return formatResponse(Status.INTERNAL_SERVER_ERROR, e.getMessage());\n     }\n \n     // If nothing happens consider it a no-op\n     return Response.status(Status.NO_CONTENT).build();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Response updateService(@Context HttpServletRequest request,\n      @PathParam(SERVICE_NAME) String appName,\n      Service updateServiceData) {\n    try {\n      UserGroupInformation ugi \u003d getProxyUser(request);\n      LOG.info(\"PUT: updateService for app \u003d {} with data \u003d {} user \u003d {}\",\n          appName, updateServiceData, ugi);\n      // Ignore the app name provided in updateServiceData and always use\n      // appName path param\n      updateServiceData.setName(appName);\n\n      if (updateServiceData.getState() !\u003d null\n          \u0026\u0026 updateServiceData.getState() \u003d\u003d ServiceState.FLEX) {\n        return flexService(updateServiceData, ugi);\n      }\n      // For STOP the app should be running. If already stopped then this\n      // operation will be a no-op. For START it should be in stopped state.\n      // If already running then this operation will be a no-op.\n      if (updateServiceData.getState() !\u003d null\n          \u0026\u0026 updateServiceData.getState() \u003d\u003d ServiceState.STOPPED) {\n        return stopService(appName, false, ugi);\n      }\n\n      // If a START is requested\n      if (updateServiceData.getState() !\u003d null\n          \u0026\u0026 updateServiceData.getState() \u003d\u003d ServiceState.STARTED) {\n        return startService(appName, ugi);\n      }\n\n      // If an UPGRADE is requested\n      if (updateServiceData.getState() !\u003d null \u0026\u0026 (\n          updateServiceData.getState() \u003d\u003d ServiceState.UPGRADING ||\n              updateServiceData.getState() \u003d\u003d\n                  ServiceState.UPGRADING_AUTO_FINALIZE) ||\n          updateServiceData.getState() \u003d\u003d ServiceState.EXPRESS_UPGRADING) {\n        return upgradeService(updateServiceData, ugi);\n      }\n\n      // If CANCEL_UPGRADING is requested\n      if (updateServiceData.getState() !\u003d null \u0026\u0026\n          updateServiceData.getState() \u003d\u003d CANCEL_UPGRADING) {\n        return cancelUpgradeService(appName, ugi);\n      }\n\n      // If new lifetime value specified then update it\n      if (updateServiceData.getLifetime() !\u003d null\n          \u0026\u0026 updateServiceData.getLifetime() \u003e 0) {\n        return updateLifetime(appName, updateServiceData, ugi);\n      }\n\n      for (Component c : updateServiceData.getComponents()) {\n        if (c.getDecommissionedInstances().size() \u003e 0) {\n          return decommissionInstances(updateServiceData, ugi);\n        }\n      }\n    } catch (UndeclaredThrowableException e) {\n      return formatResponse(Status.BAD_REQUEST,\n          e.getCause().getMessage());\n    } catch (AccessControlException e) {\n      return formatResponse(Status.FORBIDDEN, e.getMessage());\n    } catch (FileNotFoundException e) {\n      String message \u003d \"Application is not found app: \" + appName;\n      LOG.error(message, e);\n      return formatResponse(Status.NOT_FOUND, e.getMessage());\n    } catch (YarnException e) {\n      LOG.error(e.getMessage(), e);\n      return formatResponse(Status.NOT_FOUND, e.getMessage());\n    } catch (Exception e) {\n      String message \u003d \"Error while performing operation for app: \" + appName;\n      LOG.error(message, e);\n      return formatResponse(Status.INTERNAL_SERVER_ERROR, e.getMessage());\n    }\n\n    // If nothing happens consider it a no-op\n    return Response.status(Status.NO_CONTENT).build();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-services/hadoop-yarn-services-api/src/main/java/org/apache/hadoop/yarn/service/webapp/ApiServer.java",
      "extendedDetails": {}
    },
    "913f87dada27776c539dfb352400ecf8d40e7943": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8665.  Added Yarn service cancel upgrade option.\n            Contributed by Chandni Singh\n",
      "commitDate": "26/09/18 11:51 AM",
      "commitName": "913f87dada27776c539dfb352400ecf8d40e7943",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "21/08/18 4:49 PM",
      "commitNameOld": "e557c6bd8de2811a561210f672f47b4d07a9d5c6",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 35.79,
      "commitsBetweenForRepo": 332,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,65 +1,70 @@\n   public Response updateService(@Context HttpServletRequest request,\n       @PathParam(SERVICE_NAME) String appName,\n       Service updateServiceData) {\n     try {\n       UserGroupInformation ugi \u003d getProxyUser(request);\n       LOG.info(\"PUT: updateService for app \u003d {} with data \u003d {} user \u003d {}\",\n           appName, updateServiceData, ugi);\n       // Ignore the app name provided in updateServiceData and always use\n       // appName path param\n       updateServiceData.setName(appName);\n \n       if (updateServiceData.getState() !\u003d null\n           \u0026\u0026 updateServiceData.getState() \u003d\u003d ServiceState.FLEX) {\n         return flexService(updateServiceData, ugi);\n       }\n       // For STOP the app should be running. If already stopped then this\n       // operation will be a no-op. For START it should be in stopped state.\n       // If already running then this operation will be a no-op.\n       if (updateServiceData.getState() !\u003d null\n           \u0026\u0026 updateServiceData.getState() \u003d\u003d ServiceState.STOPPED) {\n         return stopService(appName, false, ugi);\n       }\n \n       // If a START is requested\n       if (updateServiceData.getState() !\u003d null\n           \u0026\u0026 updateServiceData.getState() \u003d\u003d ServiceState.STARTED) {\n         return startService(appName, ugi);\n       }\n \n       // If an UPGRADE is requested\n       if (updateServiceData.getState() !\u003d null \u0026\u0026 (\n           updateServiceData.getState() \u003d\u003d ServiceState.UPGRADING ||\n               updateServiceData.getState() \u003d\u003d\n                   ServiceState.UPGRADING_AUTO_FINALIZE) ||\n           updateServiceData.getState() \u003d\u003d ServiceState.EXPRESS_UPGRADING) {\n         return upgradeService(updateServiceData, ugi);\n       }\n \n+      // If CANCEL_UPGRADING is requested\n+      if (updateServiceData.getState() !\u003d null \u0026\u0026\n+          updateServiceData.getState() \u003d\u003d CANCEL_UPGRADING) {\n+        return cancelUpgradeService(appName, ugi);\n+      }\n+\n       // If new lifetime value specified then update it\n       if (updateServiceData.getLifetime() !\u003d null\n           \u0026\u0026 updateServiceData.getLifetime() \u003e 0) {\n         return updateLifetime(appName, updateServiceData, ugi);\n       }\n     } catch (UndeclaredThrowableException e) {\n       return formatResponse(Status.BAD_REQUEST,\n           e.getCause().getMessage());\n     } catch (AccessControlException e) {\n       return formatResponse(Status.FORBIDDEN, e.getMessage());\n     } catch (FileNotFoundException e) {\n       String message \u003d \"Application is not found app: \" + appName;\n       LOG.error(message, e);\n       return formatResponse(Status.NOT_FOUND, e.getMessage());\n     } catch (YarnException e) {\n-      String message \u003d \"Service is not found in hdfs: \" + appName;\n-      LOG.error(message, e);\n+      LOG.error(e.getMessage(), e);\n       return formatResponse(Status.NOT_FOUND, e.getMessage());\n     } catch (Exception e) {\n       String message \u003d \"Error while performing operation for app: \" + appName;\n       LOG.error(message, e);\n       return formatResponse(Status.INTERNAL_SERVER_ERROR, e.getMessage());\n     }\n \n     // If nothing happens consider it a no-op\n     return Response.status(Status.NO_CONTENT).build();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Response updateService(@Context HttpServletRequest request,\n      @PathParam(SERVICE_NAME) String appName,\n      Service updateServiceData) {\n    try {\n      UserGroupInformation ugi \u003d getProxyUser(request);\n      LOG.info(\"PUT: updateService for app \u003d {} with data \u003d {} user \u003d {}\",\n          appName, updateServiceData, ugi);\n      // Ignore the app name provided in updateServiceData and always use\n      // appName path param\n      updateServiceData.setName(appName);\n\n      if (updateServiceData.getState() !\u003d null\n          \u0026\u0026 updateServiceData.getState() \u003d\u003d ServiceState.FLEX) {\n        return flexService(updateServiceData, ugi);\n      }\n      // For STOP the app should be running. If already stopped then this\n      // operation will be a no-op. For START it should be in stopped state.\n      // If already running then this operation will be a no-op.\n      if (updateServiceData.getState() !\u003d null\n          \u0026\u0026 updateServiceData.getState() \u003d\u003d ServiceState.STOPPED) {\n        return stopService(appName, false, ugi);\n      }\n\n      // If a START is requested\n      if (updateServiceData.getState() !\u003d null\n          \u0026\u0026 updateServiceData.getState() \u003d\u003d ServiceState.STARTED) {\n        return startService(appName, ugi);\n      }\n\n      // If an UPGRADE is requested\n      if (updateServiceData.getState() !\u003d null \u0026\u0026 (\n          updateServiceData.getState() \u003d\u003d ServiceState.UPGRADING ||\n              updateServiceData.getState() \u003d\u003d\n                  ServiceState.UPGRADING_AUTO_FINALIZE) ||\n          updateServiceData.getState() \u003d\u003d ServiceState.EXPRESS_UPGRADING) {\n        return upgradeService(updateServiceData, ugi);\n      }\n\n      // If CANCEL_UPGRADING is requested\n      if (updateServiceData.getState() !\u003d null \u0026\u0026\n          updateServiceData.getState() \u003d\u003d CANCEL_UPGRADING) {\n        return cancelUpgradeService(appName, ugi);\n      }\n\n      // If new lifetime value specified then update it\n      if (updateServiceData.getLifetime() !\u003d null\n          \u0026\u0026 updateServiceData.getLifetime() \u003e 0) {\n        return updateLifetime(appName, updateServiceData, ugi);\n      }\n    } catch (UndeclaredThrowableException e) {\n      return formatResponse(Status.BAD_REQUEST,\n          e.getCause().getMessage());\n    } catch (AccessControlException e) {\n      return formatResponse(Status.FORBIDDEN, e.getMessage());\n    } catch (FileNotFoundException e) {\n      String message \u003d \"Application is not found app: \" + appName;\n      LOG.error(message, e);\n      return formatResponse(Status.NOT_FOUND, e.getMessage());\n    } catch (YarnException e) {\n      LOG.error(e.getMessage(), e);\n      return formatResponse(Status.NOT_FOUND, e.getMessage());\n    } catch (Exception e) {\n      String message \u003d \"Error while performing operation for app: \" + appName;\n      LOG.error(message, e);\n      return formatResponse(Status.INTERNAL_SERVER_ERROR, e.getMessage());\n    }\n\n    // If nothing happens consider it a no-op\n    return Response.status(Status.NO_CONTENT).build();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-services/hadoop-yarn-services-api/src/main/java/org/apache/hadoop/yarn/service/webapp/ApiServer.java",
      "extendedDetails": {}
    },
    "e557c6bd8de2811a561210f672f47b4d07a9d5c6": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8298.  Added express upgrade for YARN service.\n            Contributed by Chandni Singh\n",
      "commitDate": "21/08/18 4:49 PM",
      "commitName": "e557c6bd8de2811a561210f672f47b4d07a9d5c6",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "16/07/18 2:41 PM",
      "commitNameOld": "121865c3f96166e2190ed54b433ebcf8d053b91c",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 36.09,
      "commitsBetweenForRepo": 296,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,65 @@\n   public Response updateService(@Context HttpServletRequest request,\n       @PathParam(SERVICE_NAME) String appName,\n       Service updateServiceData) {\n     try {\n       UserGroupInformation ugi \u003d getProxyUser(request);\n       LOG.info(\"PUT: updateService for app \u003d {} with data \u003d {} user \u003d {}\",\n           appName, updateServiceData, ugi);\n       // Ignore the app name provided in updateServiceData and always use\n       // appName path param\n       updateServiceData.setName(appName);\n \n       if (updateServiceData.getState() !\u003d null\n           \u0026\u0026 updateServiceData.getState() \u003d\u003d ServiceState.FLEX) {\n         return flexService(updateServiceData, ugi);\n       }\n       // For STOP the app should be running. If already stopped then this\n       // operation will be a no-op. For START it should be in stopped state.\n       // If already running then this operation will be a no-op.\n       if (updateServiceData.getState() !\u003d null\n           \u0026\u0026 updateServiceData.getState() \u003d\u003d ServiceState.STOPPED) {\n         return stopService(appName, false, ugi);\n       }\n \n       // If a START is requested\n       if (updateServiceData.getState() !\u003d null\n           \u0026\u0026 updateServiceData.getState() \u003d\u003d ServiceState.STARTED) {\n         return startService(appName, ugi);\n       }\n \n       // If an UPGRADE is requested\n       if (updateServiceData.getState() !\u003d null \u0026\u0026 (\n           updateServiceData.getState() \u003d\u003d ServiceState.UPGRADING ||\n               updateServiceData.getState() \u003d\u003d\n-                  ServiceState.UPGRADING_AUTO_FINALIZE)) {\n+                  ServiceState.UPGRADING_AUTO_FINALIZE) ||\n+          updateServiceData.getState() \u003d\u003d ServiceState.EXPRESS_UPGRADING) {\n         return upgradeService(updateServiceData, ugi);\n       }\n \n       // If new lifetime value specified then update it\n       if (updateServiceData.getLifetime() !\u003d null\n           \u0026\u0026 updateServiceData.getLifetime() \u003e 0) {\n         return updateLifetime(appName, updateServiceData, ugi);\n       }\n     } catch (UndeclaredThrowableException e) {\n       return formatResponse(Status.BAD_REQUEST,\n           e.getCause().getMessage());\n     } catch (AccessControlException e) {\n       return formatResponse(Status.FORBIDDEN, e.getMessage());\n     } catch (FileNotFoundException e) {\n       String message \u003d \"Application is not found app: \" + appName;\n       LOG.error(message, e);\n       return formatResponse(Status.NOT_FOUND, e.getMessage());\n     } catch (YarnException e) {\n       String message \u003d \"Service is not found in hdfs: \" + appName;\n       LOG.error(message, e);\n       return formatResponse(Status.NOT_FOUND, e.getMessage());\n     } catch (Exception e) {\n       String message \u003d \"Error while performing operation for app: \" + appName;\n       LOG.error(message, e);\n       return formatResponse(Status.INTERNAL_SERVER_ERROR, e.getMessage());\n     }\n \n     // If nothing happens consider it a no-op\n     return Response.status(Status.NO_CONTENT).build();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Response updateService(@Context HttpServletRequest request,\n      @PathParam(SERVICE_NAME) String appName,\n      Service updateServiceData) {\n    try {\n      UserGroupInformation ugi \u003d getProxyUser(request);\n      LOG.info(\"PUT: updateService for app \u003d {} with data \u003d {} user \u003d {}\",\n          appName, updateServiceData, ugi);\n      // Ignore the app name provided in updateServiceData and always use\n      // appName path param\n      updateServiceData.setName(appName);\n\n      if (updateServiceData.getState() !\u003d null\n          \u0026\u0026 updateServiceData.getState() \u003d\u003d ServiceState.FLEX) {\n        return flexService(updateServiceData, ugi);\n      }\n      // For STOP the app should be running. If already stopped then this\n      // operation will be a no-op. For START it should be in stopped state.\n      // If already running then this operation will be a no-op.\n      if (updateServiceData.getState() !\u003d null\n          \u0026\u0026 updateServiceData.getState() \u003d\u003d ServiceState.STOPPED) {\n        return stopService(appName, false, ugi);\n      }\n\n      // If a START is requested\n      if (updateServiceData.getState() !\u003d null\n          \u0026\u0026 updateServiceData.getState() \u003d\u003d ServiceState.STARTED) {\n        return startService(appName, ugi);\n      }\n\n      // If an UPGRADE is requested\n      if (updateServiceData.getState() !\u003d null \u0026\u0026 (\n          updateServiceData.getState() \u003d\u003d ServiceState.UPGRADING ||\n              updateServiceData.getState() \u003d\u003d\n                  ServiceState.UPGRADING_AUTO_FINALIZE) ||\n          updateServiceData.getState() \u003d\u003d ServiceState.EXPRESS_UPGRADING) {\n        return upgradeService(updateServiceData, ugi);\n      }\n\n      // If new lifetime value specified then update it\n      if (updateServiceData.getLifetime() !\u003d null\n          \u0026\u0026 updateServiceData.getLifetime() \u003e 0) {\n        return updateLifetime(appName, updateServiceData, ugi);\n      }\n    } catch (UndeclaredThrowableException e) {\n      return formatResponse(Status.BAD_REQUEST,\n          e.getCause().getMessage());\n    } catch (AccessControlException e) {\n      return formatResponse(Status.FORBIDDEN, e.getMessage());\n    } catch (FileNotFoundException e) {\n      String message \u003d \"Application is not found app: \" + appName;\n      LOG.error(message, e);\n      return formatResponse(Status.NOT_FOUND, e.getMessage());\n    } catch (YarnException e) {\n      String message \u003d \"Service is not found in hdfs: \" + appName;\n      LOG.error(message, e);\n      return formatResponse(Status.NOT_FOUND, e.getMessage());\n    } catch (Exception e) {\n      String message \u003d \"Error while performing operation for app: \" + appName;\n      LOG.error(message, e);\n      return formatResponse(Status.INTERNAL_SERVER_ERROR, e.getMessage());\n    }\n\n    // If nothing happens consider it a no-op\n    return Response.status(Status.NO_CONTENT).build();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-services/hadoop-yarn-services-api/src/main/java/org/apache/hadoop/yarn/service/webapp/ApiServer.java",
      "extendedDetails": {}
    },
    "a23ff8d88001ad8e4ac4c36fc1f7691d193dc1d0": {
      "type": "Yfilerename",
      "commitMessage": "YARN-7530.  Refactored YARN service API project location.\n            Contributed by Chandni Singh\n",
      "commitDate": "18/05/18 2:29 PM",
      "commitName": "a23ff8d88001ad8e4ac4c36fc1f7691d193dc1d0",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "18/05/18 11:29 AM",
      "commitNameOld": "89f59113927dd886f09d8fe2c05ff2cd5d1390c1",
      "commitAuthorOld": "Xiao Chen",
      "daysBetweenCommits": 0.12,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public Response updateService(@Context HttpServletRequest request,\n      @PathParam(SERVICE_NAME) String appName,\n      Service updateServiceData) {\n    try {\n      UserGroupInformation ugi \u003d getProxyUser(request);\n      LOG.info(\"PUT: updateService for app \u003d {} with data \u003d {} user \u003d {}\",\n          appName, updateServiceData, ugi);\n      // Ignore the app name provided in updateServiceData and always use\n      // appName path param\n      updateServiceData.setName(appName);\n\n      if (updateServiceData.getState() !\u003d null\n          \u0026\u0026 updateServiceData.getState() \u003d\u003d ServiceState.FLEX) {\n        return flexService(updateServiceData, ugi);\n      }\n      // For STOP the app should be running. If already stopped then this\n      // operation will be a no-op. For START it should be in stopped state.\n      // If already running then this operation will be a no-op.\n      if (updateServiceData.getState() !\u003d null\n          \u0026\u0026 updateServiceData.getState() \u003d\u003d ServiceState.STOPPED) {\n        return stopService(appName, false, ugi);\n      }\n\n      // If a START is requested\n      if (updateServiceData.getState() !\u003d null\n          \u0026\u0026 updateServiceData.getState() \u003d\u003d ServiceState.STARTED) {\n        return startService(appName, ugi);\n      }\n\n      // If an UPGRADE is requested\n      if (updateServiceData.getState() !\u003d null \u0026\u0026 (\n          updateServiceData.getState() \u003d\u003d ServiceState.UPGRADING ||\n              updateServiceData.getState() \u003d\u003d\n                  ServiceState.UPGRADING_AUTO_FINALIZE)) {\n        return upgradeService(updateServiceData, ugi);\n      }\n\n      // If new lifetime value specified then update it\n      if (updateServiceData.getLifetime() !\u003d null\n          \u0026\u0026 updateServiceData.getLifetime() \u003e 0) {\n        return updateLifetime(appName, updateServiceData, ugi);\n      }\n    } catch (UndeclaredThrowableException e) {\n      return formatResponse(Status.BAD_REQUEST,\n          e.getCause().getMessage());\n    } catch (AccessControlException e) {\n      return formatResponse(Status.FORBIDDEN, e.getMessage());\n    } catch (FileNotFoundException e) {\n      String message \u003d \"Application is not found app: \" + appName;\n      LOG.error(message, e);\n      return formatResponse(Status.NOT_FOUND, e.getMessage());\n    } catch (YarnException e) {\n      String message \u003d \"Service is not found in hdfs: \" + appName;\n      LOG.error(message, e);\n      return formatResponse(Status.NOT_FOUND, e.getMessage());\n    } catch (Exception e) {\n      String message \u003d \"Error while performing operation for app: \" + appName;\n      LOG.error(message, e);\n      return formatResponse(Status.INTERNAL_SERVER_ERROR, e.getMessage());\n    }\n\n    // If nothing happens consider it a no-op\n    return Response.status(Status.NO_CONTENT).build();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-services/hadoop-yarn-services-api/src/main/java/org/apache/hadoop/yarn/service/webapp/ApiServer.java",
      "extendedDetails": {
        "oldPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-services-api/src/main/java/org/apache/hadoop/yarn/service/webapp/ApiServer.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-services/hadoop-yarn-services-api/src/main/java/org/apache/hadoop/yarn/service/webapp/ApiServer.java"
      }
    },
    "4a7369b09547a78f532af66c763c6994a38b5d68": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7939.  Added support to upgrade a component instance.\n            Contributed by Chandni Singh\n",
      "commitDate": "26/04/18 1:54 PM",
      "commitName": "4a7369b09547a78f532af66c763c6994a38b5d68",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "10/04/18 2:40 PM",
      "commitNameOld": "d553799030a5a64df328319aceb35734d0b2de20",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 15.97,
      "commitsBetweenForRepo": 622,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,62 +1,64 @@\n   public Response updateService(@Context HttpServletRequest request,\n       @PathParam(SERVICE_NAME) String appName,\n       Service updateServiceData) {\n     try {\n       UserGroupInformation ugi \u003d getProxyUser(request);\n       LOG.info(\"PUT: updateService for app \u003d {} with data \u003d {} user \u003d {}\",\n           appName, updateServiceData, ugi);\n       // Ignore the app name provided in updateServiceData and always use\n       // appName path param\n       updateServiceData.setName(appName);\n \n       if (updateServiceData.getState() !\u003d null\n           \u0026\u0026 updateServiceData.getState() \u003d\u003d ServiceState.FLEX) {\n         return flexService(updateServiceData, ugi);\n       }\n       // For STOP the app should be running. If already stopped then this\n       // operation will be a no-op. For START it should be in stopped state.\n       // If already running then this operation will be a no-op.\n       if (updateServiceData.getState() !\u003d null\n           \u0026\u0026 updateServiceData.getState() \u003d\u003d ServiceState.STOPPED) {\n         return stopService(appName, false, ugi);\n       }\n \n       // If a START is requested\n       if (updateServiceData.getState() !\u003d null\n           \u0026\u0026 updateServiceData.getState() \u003d\u003d ServiceState.STARTED) {\n         return startService(appName, ugi);\n       }\n \n+      // If an UPGRADE is requested\n+      if (updateServiceData.getState() !\u003d null \u0026\u0026 (\n+          updateServiceData.getState() \u003d\u003d ServiceState.UPGRADING ||\n+              updateServiceData.getState() \u003d\u003d\n+                  ServiceState.UPGRADING_AUTO_FINALIZE)) {\n+        return upgradeService(updateServiceData, ugi);\n+      }\n+\n       // If new lifetime value specified then update it\n       if (updateServiceData.getLifetime() !\u003d null\n           \u0026\u0026 updateServiceData.getLifetime() \u003e 0) {\n         return updateLifetime(appName, updateServiceData, ugi);\n       }\n-\n-      // If an UPGRADE is requested\n-      if (updateServiceData.getState() !\u003d null \u0026\u0026\n-          updateServiceData.getState() \u003d\u003d ServiceState.UPGRADING) {\n-        return upgradeService(updateServiceData, ugi);\n-      }\n     } catch (UndeclaredThrowableException e) {\n       return formatResponse(Status.BAD_REQUEST,\n           e.getCause().getMessage());\n     } catch (AccessControlException e) {\n       return formatResponse(Status.FORBIDDEN, e.getMessage());\n     } catch (FileNotFoundException e) {\n       String message \u003d \"Application is not found app: \" + appName;\n       LOG.error(message, e);\n       return formatResponse(Status.NOT_FOUND, e.getMessage());\n     } catch (YarnException e) {\n       String message \u003d \"Service is not found in hdfs: \" + appName;\n       LOG.error(message, e);\n       return formatResponse(Status.NOT_FOUND, e.getMessage());\n     } catch (Exception e) {\n       String message \u003d \"Error while performing operation for app: \" + appName;\n       LOG.error(message, e);\n       return formatResponse(Status.INTERNAL_SERVER_ERROR, e.getMessage());\n     }\n \n     // If nothing happens consider it a no-op\n     return Response.status(Status.NO_CONTENT).build();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Response updateService(@Context HttpServletRequest request,\n      @PathParam(SERVICE_NAME) String appName,\n      Service updateServiceData) {\n    try {\n      UserGroupInformation ugi \u003d getProxyUser(request);\n      LOG.info(\"PUT: updateService for app \u003d {} with data \u003d {} user \u003d {}\",\n          appName, updateServiceData, ugi);\n      // Ignore the app name provided in updateServiceData and always use\n      // appName path param\n      updateServiceData.setName(appName);\n\n      if (updateServiceData.getState() !\u003d null\n          \u0026\u0026 updateServiceData.getState() \u003d\u003d ServiceState.FLEX) {\n        return flexService(updateServiceData, ugi);\n      }\n      // For STOP the app should be running. If already stopped then this\n      // operation will be a no-op. For START it should be in stopped state.\n      // If already running then this operation will be a no-op.\n      if (updateServiceData.getState() !\u003d null\n          \u0026\u0026 updateServiceData.getState() \u003d\u003d ServiceState.STOPPED) {\n        return stopService(appName, false, ugi);\n      }\n\n      // If a START is requested\n      if (updateServiceData.getState() !\u003d null\n          \u0026\u0026 updateServiceData.getState() \u003d\u003d ServiceState.STARTED) {\n        return startService(appName, ugi);\n      }\n\n      // If an UPGRADE is requested\n      if (updateServiceData.getState() !\u003d null \u0026\u0026 (\n          updateServiceData.getState() \u003d\u003d ServiceState.UPGRADING ||\n              updateServiceData.getState() \u003d\u003d\n                  ServiceState.UPGRADING_AUTO_FINALIZE)) {\n        return upgradeService(updateServiceData, ugi);\n      }\n\n      // If new lifetime value specified then update it\n      if (updateServiceData.getLifetime() !\u003d null\n          \u0026\u0026 updateServiceData.getLifetime() \u003e 0) {\n        return updateLifetime(appName, updateServiceData, ugi);\n      }\n    } catch (UndeclaredThrowableException e) {\n      return formatResponse(Status.BAD_REQUEST,\n          e.getCause().getMessage());\n    } catch (AccessControlException e) {\n      return formatResponse(Status.FORBIDDEN, e.getMessage());\n    } catch (FileNotFoundException e) {\n      String message \u003d \"Application is not found app: \" + appName;\n      LOG.error(message, e);\n      return formatResponse(Status.NOT_FOUND, e.getMessage());\n    } catch (YarnException e) {\n      String message \u003d \"Service is not found in hdfs: \" + appName;\n      LOG.error(message, e);\n      return formatResponse(Status.NOT_FOUND, e.getMessage());\n    } catch (Exception e) {\n      String message \u003d \"Error while performing operation for app: \" + appName;\n      LOG.error(message, e);\n      return formatResponse(Status.INTERNAL_SERVER_ERROR, e.getMessage());\n    }\n\n    // If nothing happens consider it a no-op\n    return Response.status(Status.NO_CONTENT).build();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-services-api/src/main/java/org/apache/hadoop/yarn/service/webapp/ApiServer.java",
      "extendedDetails": {}
    },
    "d553799030a5a64df328319aceb35734d0b2de20": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7984. Improved YARN service stop/destroy and clean up.\n           Contributed by Billie Rinaldi\n",
      "commitDate": "10/04/18 2:40 PM",
      "commitName": "d553799030a5a64df328319aceb35734d0b2de20",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "26/03/18 3:46 PM",
      "commitNameOld": "27d60a16342fd39973d43b61008f54a8815a6237",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 14.95,
      "commitsBetweenForRepo": 77,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,62 +1,62 @@\n   public Response updateService(@Context HttpServletRequest request,\n       @PathParam(SERVICE_NAME) String appName,\n       Service updateServiceData) {\n     try {\n       UserGroupInformation ugi \u003d getProxyUser(request);\n       LOG.info(\"PUT: updateService for app \u003d {} with data \u003d {} user \u003d {}\",\n           appName, updateServiceData, ugi);\n       // Ignore the app name provided in updateServiceData and always use\n       // appName path param\n       updateServiceData.setName(appName);\n \n       if (updateServiceData.getState() !\u003d null\n           \u0026\u0026 updateServiceData.getState() \u003d\u003d ServiceState.FLEX) {\n         return flexService(updateServiceData, ugi);\n       }\n       // For STOP the app should be running. If already stopped then this\n       // operation will be a no-op. For START it should be in stopped state.\n       // If already running then this operation will be a no-op.\n       if (updateServiceData.getState() !\u003d null\n           \u0026\u0026 updateServiceData.getState() \u003d\u003d ServiceState.STOPPED) {\n         return stopService(appName, false, ugi);\n       }\n \n       // If a START is requested\n       if (updateServiceData.getState() !\u003d null\n           \u0026\u0026 updateServiceData.getState() \u003d\u003d ServiceState.STARTED) {\n         return startService(appName, ugi);\n       }\n \n       // If new lifetime value specified then update it\n       if (updateServiceData.getLifetime() !\u003d null\n           \u0026\u0026 updateServiceData.getLifetime() \u003e 0) {\n         return updateLifetime(appName, updateServiceData, ugi);\n       }\n \n       // If an UPGRADE is requested\n       if (updateServiceData.getState() !\u003d null \u0026\u0026\n           updateServiceData.getState() \u003d\u003d ServiceState.UPGRADING) {\n         return upgradeService(updateServiceData, ugi);\n       }\n     } catch (UndeclaredThrowableException e) {\n       return formatResponse(Status.BAD_REQUEST,\n           e.getCause().getMessage());\n     } catch (AccessControlException e) {\n       return formatResponse(Status.FORBIDDEN, e.getMessage());\n     } catch (FileNotFoundException e) {\n       String message \u003d \"Application is not found app: \" + appName;\n       LOG.error(message, e);\n       return formatResponse(Status.NOT_FOUND, e.getMessage());\n     } catch (YarnException e) {\n       String message \u003d \"Service is not found in hdfs: \" + appName;\n       LOG.error(message, e);\n       return formatResponse(Status.NOT_FOUND, e.getMessage());\n-    } catch (IOException | InterruptedException e) {\n+    } catch (Exception e) {\n       String message \u003d \"Error while performing operation for app: \" + appName;\n       LOG.error(message, e);\n       return formatResponse(Status.INTERNAL_SERVER_ERROR, e.getMessage());\n     }\n \n     // If nothing happens consider it a no-op\n     return Response.status(Status.NO_CONTENT).build();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Response updateService(@Context HttpServletRequest request,\n      @PathParam(SERVICE_NAME) String appName,\n      Service updateServiceData) {\n    try {\n      UserGroupInformation ugi \u003d getProxyUser(request);\n      LOG.info(\"PUT: updateService for app \u003d {} with data \u003d {} user \u003d {}\",\n          appName, updateServiceData, ugi);\n      // Ignore the app name provided in updateServiceData and always use\n      // appName path param\n      updateServiceData.setName(appName);\n\n      if (updateServiceData.getState() !\u003d null\n          \u0026\u0026 updateServiceData.getState() \u003d\u003d ServiceState.FLEX) {\n        return flexService(updateServiceData, ugi);\n      }\n      // For STOP the app should be running. If already stopped then this\n      // operation will be a no-op. For START it should be in stopped state.\n      // If already running then this operation will be a no-op.\n      if (updateServiceData.getState() !\u003d null\n          \u0026\u0026 updateServiceData.getState() \u003d\u003d ServiceState.STOPPED) {\n        return stopService(appName, false, ugi);\n      }\n\n      // If a START is requested\n      if (updateServiceData.getState() !\u003d null\n          \u0026\u0026 updateServiceData.getState() \u003d\u003d ServiceState.STARTED) {\n        return startService(appName, ugi);\n      }\n\n      // If new lifetime value specified then update it\n      if (updateServiceData.getLifetime() !\u003d null\n          \u0026\u0026 updateServiceData.getLifetime() \u003e 0) {\n        return updateLifetime(appName, updateServiceData, ugi);\n      }\n\n      // If an UPGRADE is requested\n      if (updateServiceData.getState() !\u003d null \u0026\u0026\n          updateServiceData.getState() \u003d\u003d ServiceState.UPGRADING) {\n        return upgradeService(updateServiceData, ugi);\n      }\n    } catch (UndeclaredThrowableException e) {\n      return formatResponse(Status.BAD_REQUEST,\n          e.getCause().getMessage());\n    } catch (AccessControlException e) {\n      return formatResponse(Status.FORBIDDEN, e.getMessage());\n    } catch (FileNotFoundException e) {\n      String message \u003d \"Application is not found app: \" + appName;\n      LOG.error(message, e);\n      return formatResponse(Status.NOT_FOUND, e.getMessage());\n    } catch (YarnException e) {\n      String message \u003d \"Service is not found in hdfs: \" + appName;\n      LOG.error(message, e);\n      return formatResponse(Status.NOT_FOUND, e.getMessage());\n    } catch (Exception e) {\n      String message \u003d \"Error while performing operation for app: \" + appName;\n      LOG.error(message, e);\n      return formatResponse(Status.INTERNAL_SERVER_ERROR, e.getMessage());\n    }\n\n    // If nothing happens consider it a no-op\n    return Response.status(Status.NO_CONTENT).build();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-services-api/src/main/java/org/apache/hadoop/yarn/service/webapp/ApiServer.java",
      "extendedDetails": {}
    },
    "27d60a16342fd39973d43b61008f54a8815a6237": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8018.  Added support for initiating yarn service upgrade.\n            Contributed by Chandni Singh\n",
      "commitDate": "26/03/18 3:46 PM",
      "commitName": "27d60a16342fd39973d43b61008f54a8815a6237",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "10/03/18 7:49 AM",
      "commitNameOld": "e1f5251f3c0d6e74af1b52eda6633b728804fe2a",
      "commitAuthorOld": "Billie Rinaldi",
      "daysBetweenCommits": 16.29,
      "commitsBetweenForRepo": 242,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,56 +1,62 @@\n   public Response updateService(@Context HttpServletRequest request,\n       @PathParam(SERVICE_NAME) String appName,\n       Service updateServiceData) {\n     try {\n       UserGroupInformation ugi \u003d getProxyUser(request);\n       LOG.info(\"PUT: updateService for app \u003d {} with data \u003d {} user \u003d {}\",\n           appName, updateServiceData, ugi);\n       // Ignore the app name provided in updateServiceData and always use\n       // appName path param\n       updateServiceData.setName(appName);\n \n       if (updateServiceData.getState() !\u003d null\n           \u0026\u0026 updateServiceData.getState() \u003d\u003d ServiceState.FLEX) {\n         return flexService(updateServiceData, ugi);\n       }\n       // For STOP the app should be running. If already stopped then this\n       // operation will be a no-op. For START it should be in stopped state.\n       // If already running then this operation will be a no-op.\n       if (updateServiceData.getState() !\u003d null\n           \u0026\u0026 updateServiceData.getState() \u003d\u003d ServiceState.STOPPED) {\n         return stopService(appName, false, ugi);\n       }\n \n       // If a START is requested\n       if (updateServiceData.getState() !\u003d null\n           \u0026\u0026 updateServiceData.getState() \u003d\u003d ServiceState.STARTED) {\n         return startService(appName, ugi);\n       }\n \n       // If new lifetime value specified then update it\n       if (updateServiceData.getLifetime() !\u003d null\n           \u0026\u0026 updateServiceData.getLifetime() \u003e 0) {\n         return updateLifetime(appName, updateServiceData, ugi);\n       }\n+\n+      // If an UPGRADE is requested\n+      if (updateServiceData.getState() !\u003d null \u0026\u0026\n+          updateServiceData.getState() \u003d\u003d ServiceState.UPGRADING) {\n+        return upgradeService(updateServiceData, ugi);\n+      }\n     } catch (UndeclaredThrowableException e) {\n       return formatResponse(Status.BAD_REQUEST,\n           e.getCause().getMessage());\n     } catch (AccessControlException e) {\n       return formatResponse(Status.FORBIDDEN, e.getMessage());\n     } catch (FileNotFoundException e) {\n       String message \u003d \"Application is not found app: \" + appName;\n       LOG.error(message, e);\n       return formatResponse(Status.NOT_FOUND, e.getMessage());\n     } catch (YarnException e) {\n       String message \u003d \"Service is not found in hdfs: \" + appName;\n       LOG.error(message, e);\n       return formatResponse(Status.NOT_FOUND, e.getMessage());\n     } catch (IOException | InterruptedException e) {\n       String message \u003d \"Error while performing operation for app: \" + appName;\n       LOG.error(message, e);\n       return formatResponse(Status.INTERNAL_SERVER_ERROR, e.getMessage());\n     }\n \n     // If nothing happens consider it a no-op\n     return Response.status(Status.NO_CONTENT).build();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Response updateService(@Context HttpServletRequest request,\n      @PathParam(SERVICE_NAME) String appName,\n      Service updateServiceData) {\n    try {\n      UserGroupInformation ugi \u003d getProxyUser(request);\n      LOG.info(\"PUT: updateService for app \u003d {} with data \u003d {} user \u003d {}\",\n          appName, updateServiceData, ugi);\n      // Ignore the app name provided in updateServiceData and always use\n      // appName path param\n      updateServiceData.setName(appName);\n\n      if (updateServiceData.getState() !\u003d null\n          \u0026\u0026 updateServiceData.getState() \u003d\u003d ServiceState.FLEX) {\n        return flexService(updateServiceData, ugi);\n      }\n      // For STOP the app should be running. If already stopped then this\n      // operation will be a no-op. For START it should be in stopped state.\n      // If already running then this operation will be a no-op.\n      if (updateServiceData.getState() !\u003d null\n          \u0026\u0026 updateServiceData.getState() \u003d\u003d ServiceState.STOPPED) {\n        return stopService(appName, false, ugi);\n      }\n\n      // If a START is requested\n      if (updateServiceData.getState() !\u003d null\n          \u0026\u0026 updateServiceData.getState() \u003d\u003d ServiceState.STARTED) {\n        return startService(appName, ugi);\n      }\n\n      // If new lifetime value specified then update it\n      if (updateServiceData.getLifetime() !\u003d null\n          \u0026\u0026 updateServiceData.getLifetime() \u003e 0) {\n        return updateLifetime(appName, updateServiceData, ugi);\n      }\n\n      // If an UPGRADE is requested\n      if (updateServiceData.getState() !\u003d null \u0026\u0026\n          updateServiceData.getState() \u003d\u003d ServiceState.UPGRADING) {\n        return upgradeService(updateServiceData, ugi);\n      }\n    } catch (UndeclaredThrowableException e) {\n      return formatResponse(Status.BAD_REQUEST,\n          e.getCause().getMessage());\n    } catch (AccessControlException e) {\n      return formatResponse(Status.FORBIDDEN, e.getMessage());\n    } catch (FileNotFoundException e) {\n      String message \u003d \"Application is not found app: \" + appName;\n      LOG.error(message, e);\n      return formatResponse(Status.NOT_FOUND, e.getMessage());\n    } catch (YarnException e) {\n      String message \u003d \"Service is not found in hdfs: \" + appName;\n      LOG.error(message, e);\n      return formatResponse(Status.NOT_FOUND, e.getMessage());\n    } catch (IOException | InterruptedException e) {\n      String message \u003d \"Error while performing operation for app: \" + appName;\n      LOG.error(message, e);\n      return formatResponse(Status.INTERNAL_SERVER_ERROR, e.getMessage());\n    }\n\n    // If nothing happens consider it a no-op\n    return Response.status(Status.NO_CONTENT).build();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-services-api/src/main/java/org/apache/hadoop/yarn/service/webapp/ApiServer.java",
      "extendedDetails": {}
    },
    "e307edcb472207a39d1cbe4be6f7fcddc7b4fd6d": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-7540 and YARN-7605. Convert yarn app cli to call yarn api services and implement doAs for Api Service REST API. Contributed by Eric Yang and Jian He\n",
      "commitDate": "23/01/18 5:54 PM",
      "commitName": "e307edcb472207a39d1cbe4be6f7fcddc7b4fd6d",
      "commitAuthor": "Billie Rinaldi",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-7540 and YARN-7605. Convert yarn app cli to call yarn api services and implement doAs for Api Service REST API. Contributed by Eric Yang and Jian He\n",
          "commitDate": "23/01/18 5:54 PM",
          "commitName": "e307edcb472207a39d1cbe4be6f7fcddc7b4fd6d",
          "commitAuthor": "Billie Rinaldi",
          "commitDateOld": "05/01/18 6:25 PM",
          "commitNameOld": "836e3c45e8232fc4c8c795c0f93d2f3d7353f392",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 17.98,
          "commitsBetweenForRepo": 84,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,32 +1,56 @@\n-  public Response updateService(@PathParam(SERVICE_NAME) String appName,\n+  public Response updateService(@Context HttpServletRequest request,\n+      @PathParam(SERVICE_NAME) String appName,\n       Service updateServiceData) {\n-    LOG.info(\"PUT: updateService for app \u003d {} with data \u003d {}\", appName,\n-        updateServiceData);\n+    try {\n+      UserGroupInformation ugi \u003d getProxyUser(request);\n+      LOG.info(\"PUT: updateService for app \u003d {} with data \u003d {} user \u003d {}\",\n+          appName, updateServiceData, ugi);\n+      // Ignore the app name provided in updateServiceData and always use\n+      // appName path param\n+      updateServiceData.setName(appName);\n \n-    // Ignore the app name provided in updateServiceData and always use appName\n-    // path param\n-    updateServiceData.setName(appName);\n+      if (updateServiceData.getState() !\u003d null\n+          \u0026\u0026 updateServiceData.getState() \u003d\u003d ServiceState.FLEX) {\n+        return flexService(updateServiceData, ugi);\n+      }\n+      // For STOP the app should be running. If already stopped then this\n+      // operation will be a no-op. For START it should be in stopped state.\n+      // If already running then this operation will be a no-op.\n+      if (updateServiceData.getState() !\u003d null\n+          \u0026\u0026 updateServiceData.getState() \u003d\u003d ServiceState.STOPPED) {\n+        return stopService(appName, false, ugi);\n+      }\n \n-    // For STOP the app should be running. If already stopped then this\n-    // operation will be a no-op. For START it should be in stopped state.\n-    // If already running then this operation will be a no-op.\n-    if (updateServiceData.getState() !\u003d null\n-        \u0026\u0026 updateServiceData.getState() \u003d\u003d ServiceState.STOPPED) {\n-      return stopService(appName, false);\n-    }\n+      // If a START is requested\n+      if (updateServiceData.getState() !\u003d null\n+          \u0026\u0026 updateServiceData.getState() \u003d\u003d ServiceState.STARTED) {\n+        return startService(appName, ugi);\n+      }\n \n-    // If a START is requested\n-    if (updateServiceData.getState() !\u003d null\n-        \u0026\u0026 updateServiceData.getState() \u003d\u003d ServiceState.STARTED) {\n-      return startService(appName);\n-    }\n-\n-    // If new lifetime value specified then update it\n-    if (updateServiceData.getLifetime() !\u003d null\n-        \u0026\u0026 updateServiceData.getLifetime() \u003e 0) {\n-      return updateLifetime(appName, updateServiceData);\n+      // If new lifetime value specified then update it\n+      if (updateServiceData.getLifetime() !\u003d null\n+          \u0026\u0026 updateServiceData.getLifetime() \u003e 0) {\n+        return updateLifetime(appName, updateServiceData, ugi);\n+      }\n+    } catch (UndeclaredThrowableException e) {\n+      return formatResponse(Status.BAD_REQUEST,\n+          e.getCause().getMessage());\n+    } catch (AccessControlException e) {\n+      return formatResponse(Status.FORBIDDEN, e.getMessage());\n+    } catch (FileNotFoundException e) {\n+      String message \u003d \"Application is not found app: \" + appName;\n+      LOG.error(message, e);\n+      return formatResponse(Status.NOT_FOUND, e.getMessage());\n+    } catch (YarnException e) {\n+      String message \u003d \"Service is not found in hdfs: \" + appName;\n+      LOG.error(message, e);\n+      return formatResponse(Status.NOT_FOUND, e.getMessage());\n+    } catch (IOException | InterruptedException e) {\n+      String message \u003d \"Error while performing operation for app: \" + appName;\n+      LOG.error(message, e);\n+      return formatResponse(Status.INTERNAL_SERVER_ERROR, e.getMessage());\n     }\n \n     // If nothing happens consider it a no-op\n     return Response.status(Status.NO_CONTENT).build();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Response updateService(@Context HttpServletRequest request,\n      @PathParam(SERVICE_NAME) String appName,\n      Service updateServiceData) {\n    try {\n      UserGroupInformation ugi \u003d getProxyUser(request);\n      LOG.info(\"PUT: updateService for app \u003d {} with data \u003d {} user \u003d {}\",\n          appName, updateServiceData, ugi);\n      // Ignore the app name provided in updateServiceData and always use\n      // appName path param\n      updateServiceData.setName(appName);\n\n      if (updateServiceData.getState() !\u003d null\n          \u0026\u0026 updateServiceData.getState() \u003d\u003d ServiceState.FLEX) {\n        return flexService(updateServiceData, ugi);\n      }\n      // For STOP the app should be running. If already stopped then this\n      // operation will be a no-op. For START it should be in stopped state.\n      // If already running then this operation will be a no-op.\n      if (updateServiceData.getState() !\u003d null\n          \u0026\u0026 updateServiceData.getState() \u003d\u003d ServiceState.STOPPED) {\n        return stopService(appName, false, ugi);\n      }\n\n      // If a START is requested\n      if (updateServiceData.getState() !\u003d null\n          \u0026\u0026 updateServiceData.getState() \u003d\u003d ServiceState.STARTED) {\n        return startService(appName, ugi);\n      }\n\n      // If new lifetime value specified then update it\n      if (updateServiceData.getLifetime() !\u003d null\n          \u0026\u0026 updateServiceData.getLifetime() \u003e 0) {\n        return updateLifetime(appName, updateServiceData, ugi);\n      }\n    } catch (UndeclaredThrowableException e) {\n      return formatResponse(Status.BAD_REQUEST,\n          e.getCause().getMessage());\n    } catch (AccessControlException e) {\n      return formatResponse(Status.FORBIDDEN, e.getMessage());\n    } catch (FileNotFoundException e) {\n      String message \u003d \"Application is not found app: \" + appName;\n      LOG.error(message, e);\n      return formatResponse(Status.NOT_FOUND, e.getMessage());\n    } catch (YarnException e) {\n      String message \u003d \"Service is not found in hdfs: \" + appName;\n      LOG.error(message, e);\n      return formatResponse(Status.NOT_FOUND, e.getMessage());\n    } catch (IOException | InterruptedException e) {\n      String message \u003d \"Error while performing operation for app: \" + appName;\n      LOG.error(message, e);\n      return formatResponse(Status.INTERNAL_SERVER_ERROR, e.getMessage());\n    }\n\n    // If nothing happens consider it a no-op\n    return Response.status(Status.NO_CONTENT).build();\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-services-api/src/main/java/org/apache/hadoop/yarn/service/webapp/ApiServer.java",
          "extendedDetails": {
            "oldValue": "[appName-String(annotations-@PathParam(SERVICE_NAME)), updateServiceData-Service]",
            "newValue": "[request-HttpServletRequest(annotations-@Context), appName-String(annotations-@PathParam(SERVICE_NAME)), updateServiceData-Service]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-7540 and YARN-7605. Convert yarn app cli to call yarn api services and implement doAs for Api Service REST API. Contributed by Eric Yang and Jian He\n",
          "commitDate": "23/01/18 5:54 PM",
          "commitName": "e307edcb472207a39d1cbe4be6f7fcddc7b4fd6d",
          "commitAuthor": "Billie Rinaldi",
          "commitDateOld": "05/01/18 6:25 PM",
          "commitNameOld": "836e3c45e8232fc4c8c795c0f93d2f3d7353f392",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 17.98,
          "commitsBetweenForRepo": 84,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,32 +1,56 @@\n-  public Response updateService(@PathParam(SERVICE_NAME) String appName,\n+  public Response updateService(@Context HttpServletRequest request,\n+      @PathParam(SERVICE_NAME) String appName,\n       Service updateServiceData) {\n-    LOG.info(\"PUT: updateService for app \u003d {} with data \u003d {}\", appName,\n-        updateServiceData);\n+    try {\n+      UserGroupInformation ugi \u003d getProxyUser(request);\n+      LOG.info(\"PUT: updateService for app \u003d {} with data \u003d {} user \u003d {}\",\n+          appName, updateServiceData, ugi);\n+      // Ignore the app name provided in updateServiceData and always use\n+      // appName path param\n+      updateServiceData.setName(appName);\n \n-    // Ignore the app name provided in updateServiceData and always use appName\n-    // path param\n-    updateServiceData.setName(appName);\n+      if (updateServiceData.getState() !\u003d null\n+          \u0026\u0026 updateServiceData.getState() \u003d\u003d ServiceState.FLEX) {\n+        return flexService(updateServiceData, ugi);\n+      }\n+      // For STOP the app should be running. If already stopped then this\n+      // operation will be a no-op. For START it should be in stopped state.\n+      // If already running then this operation will be a no-op.\n+      if (updateServiceData.getState() !\u003d null\n+          \u0026\u0026 updateServiceData.getState() \u003d\u003d ServiceState.STOPPED) {\n+        return stopService(appName, false, ugi);\n+      }\n \n-    // For STOP the app should be running. If already stopped then this\n-    // operation will be a no-op. For START it should be in stopped state.\n-    // If already running then this operation will be a no-op.\n-    if (updateServiceData.getState() !\u003d null\n-        \u0026\u0026 updateServiceData.getState() \u003d\u003d ServiceState.STOPPED) {\n-      return stopService(appName, false);\n-    }\n+      // If a START is requested\n+      if (updateServiceData.getState() !\u003d null\n+          \u0026\u0026 updateServiceData.getState() \u003d\u003d ServiceState.STARTED) {\n+        return startService(appName, ugi);\n+      }\n \n-    // If a START is requested\n-    if (updateServiceData.getState() !\u003d null\n-        \u0026\u0026 updateServiceData.getState() \u003d\u003d ServiceState.STARTED) {\n-      return startService(appName);\n-    }\n-\n-    // If new lifetime value specified then update it\n-    if (updateServiceData.getLifetime() !\u003d null\n-        \u0026\u0026 updateServiceData.getLifetime() \u003e 0) {\n-      return updateLifetime(appName, updateServiceData);\n+      // If new lifetime value specified then update it\n+      if (updateServiceData.getLifetime() !\u003d null\n+          \u0026\u0026 updateServiceData.getLifetime() \u003e 0) {\n+        return updateLifetime(appName, updateServiceData, ugi);\n+      }\n+    } catch (UndeclaredThrowableException e) {\n+      return formatResponse(Status.BAD_REQUEST,\n+          e.getCause().getMessage());\n+    } catch (AccessControlException e) {\n+      return formatResponse(Status.FORBIDDEN, e.getMessage());\n+    } catch (FileNotFoundException e) {\n+      String message \u003d \"Application is not found app: \" + appName;\n+      LOG.error(message, e);\n+      return formatResponse(Status.NOT_FOUND, e.getMessage());\n+    } catch (YarnException e) {\n+      String message \u003d \"Service is not found in hdfs: \" + appName;\n+      LOG.error(message, e);\n+      return formatResponse(Status.NOT_FOUND, e.getMessage());\n+    } catch (IOException | InterruptedException e) {\n+      String message \u003d \"Error while performing operation for app: \" + appName;\n+      LOG.error(message, e);\n+      return formatResponse(Status.INTERNAL_SERVER_ERROR, e.getMessage());\n     }\n \n     // If nothing happens consider it a no-op\n     return Response.status(Status.NO_CONTENT).build();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Response updateService(@Context HttpServletRequest request,\n      @PathParam(SERVICE_NAME) String appName,\n      Service updateServiceData) {\n    try {\n      UserGroupInformation ugi \u003d getProxyUser(request);\n      LOG.info(\"PUT: updateService for app \u003d {} with data \u003d {} user \u003d {}\",\n          appName, updateServiceData, ugi);\n      // Ignore the app name provided in updateServiceData and always use\n      // appName path param\n      updateServiceData.setName(appName);\n\n      if (updateServiceData.getState() !\u003d null\n          \u0026\u0026 updateServiceData.getState() \u003d\u003d ServiceState.FLEX) {\n        return flexService(updateServiceData, ugi);\n      }\n      // For STOP the app should be running. If already stopped then this\n      // operation will be a no-op. For START it should be in stopped state.\n      // If already running then this operation will be a no-op.\n      if (updateServiceData.getState() !\u003d null\n          \u0026\u0026 updateServiceData.getState() \u003d\u003d ServiceState.STOPPED) {\n        return stopService(appName, false, ugi);\n      }\n\n      // If a START is requested\n      if (updateServiceData.getState() !\u003d null\n          \u0026\u0026 updateServiceData.getState() \u003d\u003d ServiceState.STARTED) {\n        return startService(appName, ugi);\n      }\n\n      // If new lifetime value specified then update it\n      if (updateServiceData.getLifetime() !\u003d null\n          \u0026\u0026 updateServiceData.getLifetime() \u003e 0) {\n        return updateLifetime(appName, updateServiceData, ugi);\n      }\n    } catch (UndeclaredThrowableException e) {\n      return formatResponse(Status.BAD_REQUEST,\n          e.getCause().getMessage());\n    } catch (AccessControlException e) {\n      return formatResponse(Status.FORBIDDEN, e.getMessage());\n    } catch (FileNotFoundException e) {\n      String message \u003d \"Application is not found app: \" + appName;\n      LOG.error(message, e);\n      return formatResponse(Status.NOT_FOUND, e.getMessage());\n    } catch (YarnException e) {\n      String message \u003d \"Service is not found in hdfs: \" + appName;\n      LOG.error(message, e);\n      return formatResponse(Status.NOT_FOUND, e.getMessage());\n    } catch (IOException | InterruptedException e) {\n      String message \u003d \"Error while performing operation for app: \" + appName;\n      LOG.error(message, e);\n      return formatResponse(Status.INTERNAL_SERVER_ERROR, e.getMessage());\n    }\n\n    // If nothing happens consider it a no-op\n    return Response.status(Status.NO_CONTENT).build();\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-services-api/src/main/java/org/apache/hadoop/yarn/service/webapp/ApiServer.java",
          "extendedDetails": {}
        }
      ]
    },
    "836e3c45e8232fc4c8c795c0f93d2f3d7353f392": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"YARN-7540.  Route YARN service CLI function through YARN Service API. (Contributed by Eric Yang)\"\n\nThis reverts commit 438c1d333ebc0a3071bb556532ed959a4bd1e6d6.\n",
      "commitDate": "05/01/18 6:25 PM",
      "commitName": "836e3c45e8232fc4c8c795c0f93d2f3d7353f392",
      "commitAuthor": "Jian He",
      "commitDateOld": "13/12/17 4:29 PM",
      "commitNameOld": "438c1d333ebc0a3071bb556532ed959a4bd1e6d6",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 23.08,
      "commitsBetweenForRepo": 127,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,55 +1,32 @@\n   public Response updateService(@PathParam(SERVICE_NAME) String appName,\n       Service updateServiceData) {\n     LOG.info(\"PUT: updateService for app \u003d {} with data \u003d {}\", appName,\n         updateServiceData);\n \n     // Ignore the app name provided in updateServiceData and always use appName\n     // path param\n     updateServiceData.setName(appName);\n \n-    if (updateServiceData.getState() \u003d\u003d ServiceState.FLEX) {\n-      Map\u003cString, String\u003e componentCountStrings \u003d new HashMap\u003cString, String\u003e();\n-      for (Component c : updateServiceData.getComponents()) {\n-        componentCountStrings.put(c.getName(), c.getNumberOfContainers().toString());\n-      }\n-      ServiceStatus status \u003d new ServiceStatus();\n-      try {\n-        int result \u003d SERVICE_CLIENT\n-            .actionFlex(appName, componentCountStrings);\n-        if (result \u003d\u003d EXIT_SUCCESS) {\n-          LOG.info(\"Successfully flex service \" + appName);\n-          status.setDiagnostics(\"Service \" + appName +\n-              \" is successfully flexed.\");\n-          status.setState(ServiceState.ACCEPTED);\n-        }\n-      } catch (YarnException | IOException e) {\n-        String message \u003d \"Failed to flex service \" + appName;\n-        LOG.info(message, e);\n-        status.setDiagnostics(message);\n-        return Response.status(Status.INTERNAL_SERVER_ERROR)\n-            .entity(status).build();\n-      }\n-    }\n     // For STOP the app should be running. If already stopped then this\n     // operation will be a no-op. For START it should be in stopped state.\n     // If already running then this operation will be a no-op.\n     if (updateServiceData.getState() !\u003d null\n         \u0026\u0026 updateServiceData.getState() \u003d\u003d ServiceState.STOPPED) {\n       return stopService(appName, false);\n     }\n \n     // If a START is requested\n     if (updateServiceData.getState() !\u003d null\n         \u0026\u0026 updateServiceData.getState() \u003d\u003d ServiceState.STARTED) {\n       return startService(appName);\n     }\n \n     // If new lifetime value specified then update it\n     if (updateServiceData.getLifetime() !\u003d null\n         \u0026\u0026 updateServiceData.getLifetime() \u003e 0) {\n       return updateLifetime(appName, updateServiceData);\n     }\n \n     // If nothing happens consider it a no-op\n     return Response.status(Status.NO_CONTENT).build();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Response updateService(@PathParam(SERVICE_NAME) String appName,\n      Service updateServiceData) {\n    LOG.info(\"PUT: updateService for app \u003d {} with data \u003d {}\", appName,\n        updateServiceData);\n\n    // Ignore the app name provided in updateServiceData and always use appName\n    // path param\n    updateServiceData.setName(appName);\n\n    // For STOP the app should be running. If already stopped then this\n    // operation will be a no-op. For START it should be in stopped state.\n    // If already running then this operation will be a no-op.\n    if (updateServiceData.getState() !\u003d null\n        \u0026\u0026 updateServiceData.getState() \u003d\u003d ServiceState.STOPPED) {\n      return stopService(appName, false);\n    }\n\n    // If a START is requested\n    if (updateServiceData.getState() !\u003d null\n        \u0026\u0026 updateServiceData.getState() \u003d\u003d ServiceState.STARTED) {\n      return startService(appName);\n    }\n\n    // If new lifetime value specified then update it\n    if (updateServiceData.getLifetime() !\u003d null\n        \u0026\u0026 updateServiceData.getLifetime() \u003e 0) {\n      return updateLifetime(appName, updateServiceData);\n    }\n\n    // If nothing happens consider it a no-op\n    return Response.status(Status.NO_CONTENT).build();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-services-api/src/main/java/org/apache/hadoop/yarn/service/webapp/ApiServer.java",
      "extendedDetails": {}
    },
    "438c1d333ebc0a3071bb556532ed959a4bd1e6d6": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7540.  Route YARN service CLI function through YARN Service API. (Contributed by Eric Yang)\n",
      "commitDate": "13/12/17 4:29 PM",
      "commitName": "438c1d333ebc0a3071bb556532ed959a4bd1e6d6",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "04/12/17 12:11 PM",
      "commitNameOld": "d30d57828fddaa8667de49af879cde999907c7f6",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 9.18,
      "commitsBetweenForRepo": 66,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,32 +1,55 @@\n   public Response updateService(@PathParam(SERVICE_NAME) String appName,\n       Service updateServiceData) {\n     LOG.info(\"PUT: updateService for app \u003d {} with data \u003d {}\", appName,\n         updateServiceData);\n \n     // Ignore the app name provided in updateServiceData and always use appName\n     // path param\n     updateServiceData.setName(appName);\n \n+    if (updateServiceData.getState() \u003d\u003d ServiceState.FLEX) {\n+      Map\u003cString, String\u003e componentCountStrings \u003d new HashMap\u003cString, String\u003e();\n+      for (Component c : updateServiceData.getComponents()) {\n+        componentCountStrings.put(c.getName(), c.getNumberOfContainers().toString());\n+      }\n+      ServiceStatus status \u003d new ServiceStatus();\n+      try {\n+        int result \u003d SERVICE_CLIENT\n+            .actionFlex(appName, componentCountStrings);\n+        if (result \u003d\u003d EXIT_SUCCESS) {\n+          LOG.info(\"Successfully flex service \" + appName);\n+          status.setDiagnostics(\"Service \" + appName +\n+              \" is successfully flexed.\");\n+          status.setState(ServiceState.ACCEPTED);\n+        }\n+      } catch (YarnException | IOException e) {\n+        String message \u003d \"Failed to flex service \" + appName;\n+        LOG.info(message, e);\n+        status.setDiagnostics(message);\n+        return Response.status(Status.INTERNAL_SERVER_ERROR)\n+            .entity(status).build();\n+      }\n+    }\n     // For STOP the app should be running. If already stopped then this\n     // operation will be a no-op. For START it should be in stopped state.\n     // If already running then this operation will be a no-op.\n     if (updateServiceData.getState() !\u003d null\n         \u0026\u0026 updateServiceData.getState() \u003d\u003d ServiceState.STOPPED) {\n       return stopService(appName, false);\n     }\n \n     // If a START is requested\n     if (updateServiceData.getState() !\u003d null\n         \u0026\u0026 updateServiceData.getState() \u003d\u003d ServiceState.STARTED) {\n       return startService(appName);\n     }\n \n     // If new lifetime value specified then update it\n     if (updateServiceData.getLifetime() !\u003d null\n         \u0026\u0026 updateServiceData.getLifetime() \u003e 0) {\n       return updateLifetime(appName, updateServiceData);\n     }\n \n     // If nothing happens consider it a no-op\n     return Response.status(Status.NO_CONTENT).build();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Response updateService(@PathParam(SERVICE_NAME) String appName,\n      Service updateServiceData) {\n    LOG.info(\"PUT: updateService for app \u003d {} with data \u003d {}\", appName,\n        updateServiceData);\n\n    // Ignore the app name provided in updateServiceData and always use appName\n    // path param\n    updateServiceData.setName(appName);\n\n    if (updateServiceData.getState() \u003d\u003d ServiceState.FLEX) {\n      Map\u003cString, String\u003e componentCountStrings \u003d new HashMap\u003cString, String\u003e();\n      for (Component c : updateServiceData.getComponents()) {\n        componentCountStrings.put(c.getName(), c.getNumberOfContainers().toString());\n      }\n      ServiceStatus status \u003d new ServiceStatus();\n      try {\n        int result \u003d SERVICE_CLIENT\n            .actionFlex(appName, componentCountStrings);\n        if (result \u003d\u003d EXIT_SUCCESS) {\n          LOG.info(\"Successfully flex service \" + appName);\n          status.setDiagnostics(\"Service \" + appName +\n              \" is successfully flexed.\");\n          status.setState(ServiceState.ACCEPTED);\n        }\n      } catch (YarnException | IOException e) {\n        String message \u003d \"Failed to flex service \" + appName;\n        LOG.info(message, e);\n        status.setDiagnostics(message);\n        return Response.status(Status.INTERNAL_SERVER_ERROR)\n            .entity(status).build();\n      }\n    }\n    // For STOP the app should be running. If already stopped then this\n    // operation will be a no-op. For START it should be in stopped state.\n    // If already running then this operation will be a no-op.\n    if (updateServiceData.getState() !\u003d null\n        \u0026\u0026 updateServiceData.getState() \u003d\u003d ServiceState.STOPPED) {\n      return stopService(appName, false);\n    }\n\n    // If a START is requested\n    if (updateServiceData.getState() !\u003d null\n        \u0026\u0026 updateServiceData.getState() \u003d\u003d ServiceState.STARTED) {\n      return startService(appName);\n    }\n\n    // If new lifetime value specified then update it\n    if (updateServiceData.getLifetime() !\u003d null\n        \u0026\u0026 updateServiceData.getLifetime() \u003e 0) {\n      return updateLifetime(appName, updateServiceData);\n    }\n\n    // If nothing happens consider it a no-op\n    return Response.status(Status.NO_CONTENT).build();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-services-api/src/main/java/org/apache/hadoop/yarn/service/webapp/ApiServer.java",
      "extendedDetails": {}
    },
    "68acd88dcbfe03a0134c60b5398dfaa31ad2b786": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7323. Data structure update in service REST API. Contributed by Jian He\n",
      "commitDate": "06/11/17 1:30 PM",
      "commitName": "68acd88dcbfe03a0134c60b5398dfaa31ad2b786",
      "commitAuthor": "Billie Rinaldi",
      "commitDateOld": "06/11/17 1:30 PM",
      "commitNameOld": "b57144a1726e0b02abbdc3e8f37769d3f7c039c8",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,32 @@\n   public Response updateService(@PathParam(SERVICE_NAME) String appName,\n       Service updateServiceData) {\n     LOG.info(\"PUT: updateService for app \u003d {} with data \u003d {}\", appName,\n         updateServiceData);\n \n     // Ignore the app name provided in updateServiceData and always use appName\n     // path param\n     updateServiceData.setName(appName);\n \n     // For STOP the app should be running. If already stopped then this\n     // operation will be a no-op. For START it should be in stopped state.\n     // If already running then this operation will be a no-op.\n     if (updateServiceData.getState() !\u003d null\n         \u0026\u0026 updateServiceData.getState() \u003d\u003d ServiceState.STOPPED) {\n       return stopService(appName, false);\n     }\n \n     // If a START is requested\n     if (updateServiceData.getState() !\u003d null\n         \u0026\u0026 updateServiceData.getState() \u003d\u003d ServiceState.STARTED) {\n       return startService(appName);\n     }\n \n     // If new lifetime value specified then update it\n     if (updateServiceData.getLifetime() !\u003d null\n         \u0026\u0026 updateServiceData.getLifetime() \u003e 0) {\n       return updateLifetime(appName, updateServiceData);\n     }\n \n-    // flex a single component app\n-    if (updateServiceData.getNumberOfContainers() !\u003d null \u0026\u0026 !ServiceApiUtil\n-        .hasComponent(updateServiceData)) {\n-      Component defaultComp \u003d ServiceApiUtil\n-          .createDefaultComponent(updateServiceData);\n-      return updateComponent(updateServiceData.getName(), defaultComp.getName(),\n-          defaultComp);\n-    }\n-\n     // If nothing happens consider it a no-op\n     return Response.status(Status.NO_CONTENT).build();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Response updateService(@PathParam(SERVICE_NAME) String appName,\n      Service updateServiceData) {\n    LOG.info(\"PUT: updateService for app \u003d {} with data \u003d {}\", appName,\n        updateServiceData);\n\n    // Ignore the app name provided in updateServiceData and always use appName\n    // path param\n    updateServiceData.setName(appName);\n\n    // For STOP the app should be running. If already stopped then this\n    // operation will be a no-op. For START it should be in stopped state.\n    // If already running then this operation will be a no-op.\n    if (updateServiceData.getState() !\u003d null\n        \u0026\u0026 updateServiceData.getState() \u003d\u003d ServiceState.STOPPED) {\n      return stopService(appName, false);\n    }\n\n    // If a START is requested\n    if (updateServiceData.getState() !\u003d null\n        \u0026\u0026 updateServiceData.getState() \u003d\u003d ServiceState.STARTED) {\n      return startService(appName);\n    }\n\n    // If new lifetime value specified then update it\n    if (updateServiceData.getLifetime() !\u003d null\n        \u0026\u0026 updateServiceData.getLifetime() \u003e 0) {\n      return updateLifetime(appName, updateServiceData);\n    }\n\n    // If nothing happens consider it a no-op\n    return Response.status(Status.NO_CONTENT).build();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-services-api/src/main/java/org/apache/hadoop/yarn/service/webapp/ApiServer.java",
      "extendedDetails": {}
    },
    "40ab068eabe50875449d601471619a4e82fff86d": {
      "type": "Yintroduced",
      "commitMessage": "YARN-7091. Rename application to service in yarn-native-services. Contributed by Jian He\n",
      "commitDate": "06/11/17 1:30 PM",
      "commitName": "40ab068eabe50875449d601471619a4e82fff86d",
      "commitAuthor": "Billie Rinaldi",
      "diff": "@@ -0,0 +1,40 @@\n+  public Response updateService(@PathParam(SERVICE_NAME) String appName,\n+      Service updateServiceData) {\n+    LOG.info(\"PUT: updateService for app \u003d {} with data \u003d {}\", appName,\n+        updateServiceData);\n+\n+    // Ignore the app name provided in updateServiceData and always use appName\n+    // path param\n+    updateServiceData.setName(appName);\n+\n+    // For STOP the app should be running. If already stopped then this\n+    // operation will be a no-op. For START it should be in stopped state.\n+    // If already running then this operation will be a no-op.\n+    if (updateServiceData.getState() !\u003d null\n+        \u0026\u0026 updateServiceData.getState() \u003d\u003d ServiceState.STOPPED) {\n+      return stopService(appName, false);\n+    }\n+\n+    // If a START is requested\n+    if (updateServiceData.getState() !\u003d null\n+        \u0026\u0026 updateServiceData.getState() \u003d\u003d ServiceState.STARTED) {\n+      return startService(appName);\n+    }\n+\n+    // If new lifetime value specified then update it\n+    if (updateServiceData.getLifetime() !\u003d null\n+        \u0026\u0026 updateServiceData.getLifetime() \u003e 0) {\n+      return updateLifetime(appName, updateServiceData);\n+    }\n+\n+    // flex a single component app\n+    if (updateServiceData.getNumberOfContainers() !\u003d null \u0026\u0026 !ServiceApiUtil\n+        .hasComponent(updateServiceData)) {\n+      Component defaultComp \u003d ServiceApiUtil.createDefaultComponent(updateServiceData);\n+      return updateComponent(updateServiceData.getName(), defaultComp.getName(),\n+          defaultComp);\n+    }\n+\n+    // If nothing happens consider it a no-op\n+    return Response.status(Status.NO_CONTENT).build();\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public Response updateService(@PathParam(SERVICE_NAME) String appName,\n      Service updateServiceData) {\n    LOG.info(\"PUT: updateService for app \u003d {} with data \u003d {}\", appName,\n        updateServiceData);\n\n    // Ignore the app name provided in updateServiceData and always use appName\n    // path param\n    updateServiceData.setName(appName);\n\n    // For STOP the app should be running. If already stopped then this\n    // operation will be a no-op. For START it should be in stopped state.\n    // If already running then this operation will be a no-op.\n    if (updateServiceData.getState() !\u003d null\n        \u0026\u0026 updateServiceData.getState() \u003d\u003d ServiceState.STOPPED) {\n      return stopService(appName, false);\n    }\n\n    // If a START is requested\n    if (updateServiceData.getState() !\u003d null\n        \u0026\u0026 updateServiceData.getState() \u003d\u003d ServiceState.STARTED) {\n      return startService(appName);\n    }\n\n    // If new lifetime value specified then update it\n    if (updateServiceData.getLifetime() !\u003d null\n        \u0026\u0026 updateServiceData.getLifetime() \u003e 0) {\n      return updateLifetime(appName, updateServiceData);\n    }\n\n    // flex a single component app\n    if (updateServiceData.getNumberOfContainers() !\u003d null \u0026\u0026 !ServiceApiUtil\n        .hasComponent(updateServiceData)) {\n      Component defaultComp \u003d ServiceApiUtil.createDefaultComponent(updateServiceData);\n      return updateComponent(updateServiceData.getName(), defaultComp.getName(),\n          defaultComp);\n    }\n\n    // If nothing happens consider it a no-op\n    return Response.status(Status.NO_CONTENT).build();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-services-api/src/main/java/org/apache/hadoop/yarn/service/webapp/ApiServer.java"
    }
  }
}