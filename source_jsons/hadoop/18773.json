{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FrameworkUploader.java",
  "functionName": "endUpload",
  "functionId": "endUpload",
  "sourceFilePath": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-uploader/src/main/java/org/apache/hadoop/mapred/uploader/FrameworkUploader.java",
  "functionStartLine": 293,
  "functionEndLine": 325,
  "numCommitsSeen": 12,
  "timeTaken": 2502,
  "changeHistory": [
    "da9aa9c90964a60bef320e8786f3f767ca3e443d",
    "304e75a48b727f702a9ede8501af01cf9c0585d3",
    "8d82c441029522f447df1ab2b6d770ca15653207",
    "836643d793c68bf1bee883abece84f024591da7c",
    "d716084f4503bf826ef10424d7025ea1ff4ee104"
  ],
  "changeHistoryShort": {
    "da9aa9c90964a60bef320e8786f3f767ca3e443d": "Ybodychange",
    "304e75a48b727f702a9ede8501af01cf9c0585d3": "Ybodychange",
    "8d82c441029522f447df1ab2b6d770ca15653207": "Ybodychange",
    "836643d793c68bf1bee883abece84f024591da7c": "Ybodychange",
    "d716084f4503bf826ef10424d7025ea1ff4ee104": "Yintroduced"
  },
  "changeHistoryDetails": {
    "da9aa9c90964a60bef320e8786f3f767ca3e443d": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-7250. FrameworkUploader skip replication check if timeout is 0.\n\nContributed by Peter Bacsko.\n",
      "commitDate": "04/12/19 11:02 PM",
      "commitName": "da9aa9c90964a60bef320e8786f3f767ca3e443d",
      "commitAuthor": "prabhujoseph",
      "commitDateOld": "04/12/19 11:01 PM",
      "commitNameOld": "304e75a48b727f702a9ede8501af01cf9c0585d3",
      "commitAuthorOld": "prabhujoseph",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,33 @@\n   private void endUpload()\n       throws IOException, InterruptedException {\n     FileSystem fileSystem \u003d targetPath.getFileSystem(conf);\n     if (fileSystem instanceof DistributedFileSystem) {\n       fileSystem.setReplication(targetPath, finalReplication);\n       LOG.info(\"Set replication to \" +\n           finalReplication + \" for path: \" + targetPath);\n-      long startTime \u003d System.currentTimeMillis();\n-      long endTime \u003d startTime;\n-      long currentReplication \u003d 0;\n-      while(endTime - startTime \u003c timeout * 1000 \u0026\u0026\n-           currentReplication \u003c acceptableReplication) {\n-        Thread.sleep(1000);\n-        endTime \u003d System.currentTimeMillis();\n-        currentReplication \u003d getSmallestReplicatedBlockCount();\n-      }\n-      if (endTime - startTime \u003e\u003d timeout * 1000) {\n-        LOG.error(String.format(\n-            \"Timed out after %d seconds while waiting for acceptable\" +\n-                \" replication of %d (current replication is %d)\",\n-            timeout, acceptableReplication, currentReplication));\n+      if (timeout \u003d\u003d 0) {\n+        LOG.info(\"Timeout is set to 0. Skipping replication check.\");\n+      } else {\n+        long startTime \u003d System.currentTimeMillis();\n+        long endTime \u003d startTime;\n+        long currentReplication \u003d 0;\n+        while(endTime - startTime \u003c timeout * 1000 \u0026\u0026\n+             currentReplication \u003c acceptableReplication) {\n+          Thread.sleep(1000);\n+          endTime \u003d System.currentTimeMillis();\n+          currentReplication \u003d getSmallestReplicatedBlockCount();\n+        }\n+        if (endTime - startTime \u003e\u003d timeout * 1000) {\n+          LOG.error(String.format(\n+              \"Timed out after %d seconds while waiting for acceptable\" +\n+                  \" replication of %d (current replication is %d)\",\n+              timeout, acceptableReplication, currentReplication));\n+        }\n       }\n     } else {\n       LOG.info(\"Cannot set replication to \" +\n           finalReplication + \" for path: \" + targetPath +\n           \" on a non-distributed fileystem \" +\n           fileSystem.getClass().getName());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void endUpload()\n      throws IOException, InterruptedException {\n    FileSystem fileSystem \u003d targetPath.getFileSystem(conf);\n    if (fileSystem instanceof DistributedFileSystem) {\n      fileSystem.setReplication(targetPath, finalReplication);\n      LOG.info(\"Set replication to \" +\n          finalReplication + \" for path: \" + targetPath);\n      if (timeout \u003d\u003d 0) {\n        LOG.info(\"Timeout is set to 0. Skipping replication check.\");\n      } else {\n        long startTime \u003d System.currentTimeMillis();\n        long endTime \u003d startTime;\n        long currentReplication \u003d 0;\n        while(endTime - startTime \u003c timeout * 1000 \u0026\u0026\n             currentReplication \u003c acceptableReplication) {\n          Thread.sleep(1000);\n          endTime \u003d System.currentTimeMillis();\n          currentReplication \u003d getSmallestReplicatedBlockCount();\n        }\n        if (endTime - startTime \u003e\u003d timeout * 1000) {\n          LOG.error(String.format(\n              \"Timed out after %d seconds while waiting for acceptable\" +\n                  \" replication of %d (current replication is %d)\",\n              timeout, acceptableReplication, currentReplication));\n        }\n      }\n    } else {\n      LOG.info(\"Cannot set replication to \" +\n          finalReplication + \" for path: \" + targetPath +\n          \" on a non-distributed fileystem \" +\n          fileSystem.getClass().getName());\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-uploader/src/main/java/org/apache/hadoop/mapred/uploader/FrameworkUploader.java",
      "extendedDetails": {}
    },
    "304e75a48b727f702a9ede8501af01cf9c0585d3": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"MAPREDUCE-7250. FrameworkUploader skip replication check if timeout is 0.\"\n\nThis reverts commit 8d82c441029522f447df1ab2b6d770ca15653207.\n",
      "commitDate": "04/12/19 11:01 PM",
      "commitName": "304e75a48b727f702a9ede8501af01cf9c0585d3",
      "commitAuthor": "prabhujoseph",
      "commitDateOld": "04/12/19 6:50 AM",
      "commitNameOld": "8d82c441029522f447df1ab2b6d770ca15653207",
      "commitAuthorOld": "prabhujoseph",
      "daysBetweenCommits": 0.67,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,33 +1,29 @@\n   private void endUpload()\n       throws IOException, InterruptedException {\n     FileSystem fileSystem \u003d targetPath.getFileSystem(conf);\n     if (fileSystem instanceof DistributedFileSystem) {\n       fileSystem.setReplication(targetPath, finalReplication);\n       LOG.info(\"Set replication to \" +\n           finalReplication + \" for path: \" + targetPath);\n-      if (timeout \u003d\u003d 0) {\n-        LOG.info(\"Timeout is set to 0. Skipping replication check.\");\n-      } else {\n-        long startTime \u003d System.currentTimeMillis();\n-        long endTime \u003d startTime;\n-        long currentReplication \u003d 0;\n-        while(endTime - startTime \u003c timeout * 1000 \u0026\u0026\n-             currentReplication \u003c acceptableReplication) {\n-          Thread.sleep(1000);\n-          endTime \u003d System.currentTimeMillis();\n-          currentReplication \u003d getSmallestReplicatedBlockCount();\n-        }\n-        if (endTime - startTime \u003e\u003d timeout * 1000) {\n-          LOG.error(String.format(\n-              \"Timed out after %d seconds while waiting for acceptable\" +\n-                  \" replication of %d (current replication is %d)\",\n-              timeout, acceptableReplication, currentReplication));\n-        }\n+      long startTime \u003d System.currentTimeMillis();\n+      long endTime \u003d startTime;\n+      long currentReplication \u003d 0;\n+      while(endTime - startTime \u003c timeout * 1000 \u0026\u0026\n+           currentReplication \u003c acceptableReplication) {\n+        Thread.sleep(1000);\n+        endTime \u003d System.currentTimeMillis();\n+        currentReplication \u003d getSmallestReplicatedBlockCount();\n+      }\n+      if (endTime - startTime \u003e\u003d timeout * 1000) {\n+        LOG.error(String.format(\n+            \"Timed out after %d seconds while waiting for acceptable\" +\n+                \" replication of %d (current replication is %d)\",\n+            timeout, acceptableReplication, currentReplication));\n       }\n     } else {\n       LOG.info(\"Cannot set replication to \" +\n           finalReplication + \" for path: \" + targetPath +\n           \" on a non-distributed fileystem \" +\n           fileSystem.getClass().getName());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void endUpload()\n      throws IOException, InterruptedException {\n    FileSystem fileSystem \u003d targetPath.getFileSystem(conf);\n    if (fileSystem instanceof DistributedFileSystem) {\n      fileSystem.setReplication(targetPath, finalReplication);\n      LOG.info(\"Set replication to \" +\n          finalReplication + \" for path: \" + targetPath);\n      long startTime \u003d System.currentTimeMillis();\n      long endTime \u003d startTime;\n      long currentReplication \u003d 0;\n      while(endTime - startTime \u003c timeout * 1000 \u0026\u0026\n           currentReplication \u003c acceptableReplication) {\n        Thread.sleep(1000);\n        endTime \u003d System.currentTimeMillis();\n        currentReplication \u003d getSmallestReplicatedBlockCount();\n      }\n      if (endTime - startTime \u003e\u003d timeout * 1000) {\n        LOG.error(String.format(\n            \"Timed out after %d seconds while waiting for acceptable\" +\n                \" replication of %d (current replication is %d)\",\n            timeout, acceptableReplication, currentReplication));\n      }\n    } else {\n      LOG.info(\"Cannot set replication to \" +\n          finalReplication + \" for path: \" + targetPath +\n          \" on a non-distributed fileystem \" +\n          fileSystem.getClass().getName());\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-uploader/src/main/java/org/apache/hadoop/mapred/uploader/FrameworkUploader.java",
      "extendedDetails": {}
    },
    "8d82c441029522f447df1ab2b6d770ca15653207": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-7250. FrameworkUploader skip replication check if timeout is 0.\n\nContributed by Peter Bacsko.\n",
      "commitDate": "04/12/19 6:50 AM",
      "commitName": "8d82c441029522f447df1ab2b6d770ca15653207",
      "commitAuthor": "prabhujoseph",
      "commitDateOld": "06/12/18 12:48 PM",
      "commitNameOld": "9886c27c71147a2bcef87b42ff21c2bbe98c8ab4",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 362.75,
      "commitsBetweenForRepo": 2549,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,33 @@\n   private void endUpload()\n       throws IOException, InterruptedException {\n     FileSystem fileSystem \u003d targetPath.getFileSystem(conf);\n     if (fileSystem instanceof DistributedFileSystem) {\n       fileSystem.setReplication(targetPath, finalReplication);\n       LOG.info(\"Set replication to \" +\n           finalReplication + \" for path: \" + targetPath);\n-      long startTime \u003d System.currentTimeMillis();\n-      long endTime \u003d startTime;\n-      long currentReplication \u003d 0;\n-      while(endTime - startTime \u003c timeout * 1000 \u0026\u0026\n-           currentReplication \u003c acceptableReplication) {\n-        Thread.sleep(1000);\n-        endTime \u003d System.currentTimeMillis();\n-        currentReplication \u003d getSmallestReplicatedBlockCount();\n-      }\n-      if (endTime - startTime \u003e\u003d timeout * 1000) {\n-        LOG.error(String.format(\n-            \"Timed out after %d seconds while waiting for acceptable\" +\n-                \" replication of %d (current replication is %d)\",\n-            timeout, acceptableReplication, currentReplication));\n+      if (timeout \u003d\u003d 0) {\n+        LOG.info(\"Timeout is set to 0. Skipping replication check.\");\n+      } else {\n+        long startTime \u003d System.currentTimeMillis();\n+        long endTime \u003d startTime;\n+        long currentReplication \u003d 0;\n+        while(endTime - startTime \u003c timeout * 1000 \u0026\u0026\n+             currentReplication \u003c acceptableReplication) {\n+          Thread.sleep(1000);\n+          endTime \u003d System.currentTimeMillis();\n+          currentReplication \u003d getSmallestReplicatedBlockCount();\n+        }\n+        if (endTime - startTime \u003e\u003d timeout * 1000) {\n+          LOG.error(String.format(\n+              \"Timed out after %d seconds while waiting for acceptable\" +\n+                  \" replication of %d (current replication is %d)\",\n+              timeout, acceptableReplication, currentReplication));\n+        }\n       }\n     } else {\n       LOG.info(\"Cannot set replication to \" +\n           finalReplication + \" for path: \" + targetPath +\n           \" on a non-distributed fileystem \" +\n           fileSystem.getClass().getName());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void endUpload()\n      throws IOException, InterruptedException {\n    FileSystem fileSystem \u003d targetPath.getFileSystem(conf);\n    if (fileSystem instanceof DistributedFileSystem) {\n      fileSystem.setReplication(targetPath, finalReplication);\n      LOG.info(\"Set replication to \" +\n          finalReplication + \" for path: \" + targetPath);\n      if (timeout \u003d\u003d 0) {\n        LOG.info(\"Timeout is set to 0. Skipping replication check.\");\n      } else {\n        long startTime \u003d System.currentTimeMillis();\n        long endTime \u003d startTime;\n        long currentReplication \u003d 0;\n        while(endTime - startTime \u003c timeout * 1000 \u0026\u0026\n             currentReplication \u003c acceptableReplication) {\n          Thread.sleep(1000);\n          endTime \u003d System.currentTimeMillis();\n          currentReplication \u003d getSmallestReplicatedBlockCount();\n        }\n        if (endTime - startTime \u003e\u003d timeout * 1000) {\n          LOG.error(String.format(\n              \"Timed out after %d seconds while waiting for acceptable\" +\n                  \" replication of %d (current replication is %d)\",\n              timeout, acceptableReplication, currentReplication));\n        }\n      }\n    } else {\n      LOG.info(\"Cannot set replication to \" +\n          finalReplication + \" for path: \" + targetPath +\n          \" on a non-distributed fileystem \" +\n          fileSystem.getClass().getName());\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-uploader/src/main/java/org/apache/hadoop/mapred/uploader/FrameworkUploader.java",
      "extendedDetails": {}
    },
    "836643d793c68bf1bee883abece84f024591da7c": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-6995. Uploader tool for Distributed Cache Deploy documentation (miklos.szegedi@cloudera.com via rkanter)\n",
      "commitDate": "19/01/18 5:57 PM",
      "commitName": "836643d793c68bf1bee883abece84f024591da7c",
      "commitAuthor": "Robert Kanter",
      "commitDateOld": "16/01/18 10:45 AM",
      "commitNameOld": "d716084f4503bf826ef10424d7025ea1ff4ee104",
      "commitAuthorOld": "Robert Kanter",
      "daysBetweenCommits": 3.3,
      "commitsBetweenForRepo": 29,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,29 @@\n   private void endUpload()\n       throws IOException, InterruptedException {\n-    FileSystem fileSystem \u003d targetPath.getFileSystem(new Configuration());\n+    FileSystem fileSystem \u003d targetPath.getFileSystem(conf);\n     if (fileSystem instanceof DistributedFileSystem) {\n       fileSystem.setReplication(targetPath, finalReplication);\n       LOG.info(\"Set replication to \" +\n           finalReplication + \" for path: \" + targetPath);\n       long startTime \u003d System.currentTimeMillis();\n       long endTime \u003d startTime;\n       long currentReplication \u003d 0;\n       while(endTime - startTime \u003c timeout * 1000 \u0026\u0026\n            currentReplication \u003c acceptableReplication) {\n         Thread.sleep(1000);\n         endTime \u003d System.currentTimeMillis();\n         currentReplication \u003d getSmallestReplicatedBlockCount();\n       }\n       if (endTime - startTime \u003e\u003d timeout * 1000) {\n         LOG.error(String.format(\n             \"Timed out after %d seconds while waiting for acceptable\" +\n                 \" replication of %d (current replication is %d)\",\n             timeout, acceptableReplication, currentReplication));\n       }\n     } else {\n       LOG.info(\"Cannot set replication to \" +\n           finalReplication + \" for path: \" + targetPath +\n           \" on a non-distributed fileystem \" +\n           fileSystem.getClass().getName());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void endUpload()\n      throws IOException, InterruptedException {\n    FileSystem fileSystem \u003d targetPath.getFileSystem(conf);\n    if (fileSystem instanceof DistributedFileSystem) {\n      fileSystem.setReplication(targetPath, finalReplication);\n      LOG.info(\"Set replication to \" +\n          finalReplication + \" for path: \" + targetPath);\n      long startTime \u003d System.currentTimeMillis();\n      long endTime \u003d startTime;\n      long currentReplication \u003d 0;\n      while(endTime - startTime \u003c timeout * 1000 \u0026\u0026\n           currentReplication \u003c acceptableReplication) {\n        Thread.sleep(1000);\n        endTime \u003d System.currentTimeMillis();\n        currentReplication \u003d getSmallestReplicatedBlockCount();\n      }\n      if (endTime - startTime \u003e\u003d timeout * 1000) {\n        LOG.error(String.format(\n            \"Timed out after %d seconds while waiting for acceptable\" +\n                \" replication of %d (current replication is %d)\",\n            timeout, acceptableReplication, currentReplication));\n      }\n    } else {\n      LOG.info(\"Cannot set replication to \" +\n          finalReplication + \" for path: \" + targetPath +\n          \" on a non-distributed fileystem \" +\n          fileSystem.getClass().getName());\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-uploader/src/main/java/org/apache/hadoop/mapred/uploader/FrameworkUploader.java",
      "extendedDetails": {}
    },
    "d716084f4503bf826ef10424d7025ea1ff4ee104": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-7032. Add the ability to specify a delayed replication count (miklos.szegedi@cloudera.com via rkanter)\n",
      "commitDate": "16/01/18 10:45 AM",
      "commitName": "d716084f4503bf826ef10424d7025ea1ff4ee104",
      "commitAuthor": "Robert Kanter",
      "diff": "@@ -0,0 +1,29 @@\n+  private void endUpload()\n+      throws IOException, InterruptedException {\n+    FileSystem fileSystem \u003d targetPath.getFileSystem(new Configuration());\n+    if (fileSystem instanceof DistributedFileSystem) {\n+      fileSystem.setReplication(targetPath, finalReplication);\n+      LOG.info(\"Set replication to \" +\n+          finalReplication + \" for path: \" + targetPath);\n+      long startTime \u003d System.currentTimeMillis();\n+      long endTime \u003d startTime;\n+      long currentReplication \u003d 0;\n+      while(endTime - startTime \u003c timeout * 1000 \u0026\u0026\n+           currentReplication \u003c acceptableReplication) {\n+        Thread.sleep(1000);\n+        endTime \u003d System.currentTimeMillis();\n+        currentReplication \u003d getSmallestReplicatedBlockCount();\n+      }\n+      if (endTime - startTime \u003e\u003d timeout * 1000) {\n+        LOG.error(String.format(\n+            \"Timed out after %d seconds while waiting for acceptable\" +\n+                \" replication of %d (current replication is %d)\",\n+            timeout, acceptableReplication, currentReplication));\n+      }\n+    } else {\n+      LOG.info(\"Cannot set replication to \" +\n+          finalReplication + \" for path: \" + targetPath +\n+          \" on a non-distributed fileystem \" +\n+          fileSystem.getClass().getName());\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void endUpload()\n      throws IOException, InterruptedException {\n    FileSystem fileSystem \u003d targetPath.getFileSystem(new Configuration());\n    if (fileSystem instanceof DistributedFileSystem) {\n      fileSystem.setReplication(targetPath, finalReplication);\n      LOG.info(\"Set replication to \" +\n          finalReplication + \" for path: \" + targetPath);\n      long startTime \u003d System.currentTimeMillis();\n      long endTime \u003d startTime;\n      long currentReplication \u003d 0;\n      while(endTime - startTime \u003c timeout * 1000 \u0026\u0026\n           currentReplication \u003c acceptableReplication) {\n        Thread.sleep(1000);\n        endTime \u003d System.currentTimeMillis();\n        currentReplication \u003d getSmallestReplicatedBlockCount();\n      }\n      if (endTime - startTime \u003e\u003d timeout * 1000) {\n        LOG.error(String.format(\n            \"Timed out after %d seconds while waiting for acceptable\" +\n                \" replication of %d (current replication is %d)\",\n            timeout, acceptableReplication, currentReplication));\n      }\n    } else {\n      LOG.info(\"Cannot set replication to \" +\n          finalReplication + \" for path: \" + targetPath +\n          \" on a non-distributed fileystem \" +\n          fileSystem.getClass().getName());\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-uploader/src/main/java/org/apache/hadoop/mapred/uploader/FrameworkUploader.java"
    }
  }
}