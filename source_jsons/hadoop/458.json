{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "BlockReaderLocal.java",
  "functionName": "fillBuffer",
  "functionId": "fillBuffer___buf-ByteBuffer__canSkipChecksum-boolean",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/client/impl/BlockReaderLocal.java",
  "functionStartLine": 347,
  "functionEndLine": 392,
  "numCommitsSeen": 73,
  "timeTaken": 4568,
  "changeHistory": [
    "5d748bd056a32f2c6922514cd0c5b31d866a9919",
    "6d116ffad23b470f8e9ca131d8e89cbbbb4378d7",
    "f308561f1d885491b88db73ac63003202056d661",
    "7136e8c5582dc4061b566cb9f11a0d6a6d08bb93",
    "892ade689f9bcce76daae8f66fc00a49bee8548e",
    "e2c9b288b223b9fd82dc12018936e13128413492",
    "463aec11718e47d4aabb86a7a539cb973460aae6",
    "7f6ed7fe365166e8075359f1d0ad035fa876c70f",
    "124e507674c0d396f8494585e64226957199097b",
    "f55a1c08763e5f865fd9193d640c89a06ab49c4a",
    "2ab10e29d9cca5018064be46a40e3c74423615a8"
  ],
  "changeHistoryShort": {
    "5d748bd056a32f2c6922514cd0c5b31d866a9919": "Ybodychange",
    "6d116ffad23b470f8e9ca131d8e89cbbbb4378d7": "Ybodychange",
    "f308561f1d885491b88db73ac63003202056d661": "Yfilerename",
    "7136e8c5582dc4061b566cb9f11a0d6a6d08bb93": "Ybodychange",
    "892ade689f9bcce76daae8f66fc00a49bee8548e": "Ybodychange",
    "e2c9b288b223b9fd82dc12018936e13128413492": "Yfilerename",
    "463aec11718e47d4aabb86a7a539cb973460aae6": "Ybodychange",
    "7f6ed7fe365166e8075359f1d0ad035fa876c70f": "Ybodychange",
    "124e507674c0d396f8494585e64226957199097b": "Ymultichange(Yparameterchange,Ymodifierchange,Ybodychange)",
    "f55a1c08763e5f865fd9193d640c89a06ab49c4a": "Yrename",
    "2ab10e29d9cca5018064be46a40e3c74423615a8": "Yintroduced"
  },
  "changeHistoryDetails": {
    "5d748bd056a32f2c6922514cd0c5b31d866a9919": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13702. Remove HTrace hooks from DFSClient to reduce CPU usage. Contributed by Todd Lipcon.\n",
      "commitDate": "02/07/18 3:11 AM",
      "commitName": "5d748bd056a32f2c6922514cd0c5b31d866a9919",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "22/06/17 1:35 PM",
      "commitNameOld": "6d116ffad23b470f8e9ca131d8e89cbbbb4378d7",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 374.57,
      "commitsBetweenForRepo": 3278,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,49 +1,46 @@\n   private synchronized int fillBuffer(ByteBuffer buf, boolean canSkipChecksum)\n       throws IOException {\n-    try (TraceScope ignored \u003d tracer.newScope(\n-        \"BlockReaderLocal#fillBuffer(\" + block.getBlockId() + \")\")) {\n-      int total \u003d 0;\n-      long startDataPos \u003d dataPos;\n-      int startBufPos \u003d buf.position();\n-      while (buf.hasRemaining()) {\n-        int nRead \u003d blockReaderIoProvider.read(dataIn, buf, dataPos);\n-        if (nRead \u003c 0) {\n-          break;\n-        }\n-        dataPos +\u003d nRead;\n-        total +\u003d nRead;\n+    int total \u003d 0;\n+    long startDataPos \u003d dataPos;\n+    int startBufPos \u003d buf.position();\n+    while (buf.hasRemaining()) {\n+      int nRead \u003d blockReaderIoProvider.read(dataIn, buf, dataPos);\n+      if (nRead \u003c 0) {\n+        break;\n       }\n-      if (canSkipChecksum) {\n-        freeChecksumBufIfExists();\n-        return total;\n-      }\n-      if (total \u003e 0) {\n-        try {\n-          buf.limit(buf.position());\n-          buf.position(startBufPos);\n-          createChecksumBufIfNeeded();\n-          int checksumsNeeded \u003d (total + bytesPerChecksum - 1) /\n-              bytesPerChecksum;\n-          checksumBuf.clear();\n-          checksumBuf.limit(checksumsNeeded * checksumSize);\n-          long checksumPos \u003d BlockMetadataHeader.getHeaderSize()\n-              + ((startDataPos / bytesPerChecksum) * checksumSize);\n-          while (checksumBuf.hasRemaining()) {\n-            int nRead \u003d checksumIn.read(checksumBuf, checksumPos);\n-            if (nRead \u003c 0) {\n-              throw new IOException(\"Got unexpected checksum file EOF at \" +\n-                  checksumPos + \", block file position \" + startDataPos +\n-                  \" for block \" + block + \" of file \" + filename);\n-            }\n-            checksumPos +\u003d nRead;\n-          }\n-          checksumBuf.flip();\n-\n-          checksum.verifyChunkedSums(buf, checksumBuf, filename, startDataPos);\n-        } finally {\n-          buf.position(buf.limit());\n-        }\n-      }\n+      dataPos +\u003d nRead;\n+      total +\u003d nRead;\n+    }\n+    if (canSkipChecksum) {\n+      freeChecksumBufIfExists();\n       return total;\n     }\n+    if (total \u003e 0) {\n+      try {\n+        buf.limit(buf.position());\n+        buf.position(startBufPos);\n+        createChecksumBufIfNeeded();\n+        int checksumsNeeded \u003d (total + bytesPerChecksum - 1) /\n+            bytesPerChecksum;\n+        checksumBuf.clear();\n+        checksumBuf.limit(checksumsNeeded * checksumSize);\n+        long checksumPos \u003d BlockMetadataHeader.getHeaderSize()\n+            + ((startDataPos / bytesPerChecksum) * checksumSize);\n+        while (checksumBuf.hasRemaining()) {\n+          int nRead \u003d checksumIn.read(checksumBuf, checksumPos);\n+          if (nRead \u003c 0) {\n+            throw new IOException(\"Got unexpected checksum file EOF at \" +\n+                checksumPos + \", block file position \" + startDataPos +\n+                \" for block \" + block + \" of file \" + filename);\n+          }\n+          checksumPos +\u003d nRead;\n+        }\n+        checksumBuf.flip();\n+\n+        checksum.verifyChunkedSums(buf, checksumBuf, filename, startDataPos);\n+      } finally {\n+        buf.position(buf.limit());\n+      }\n+    }\n+    return total;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized int fillBuffer(ByteBuffer buf, boolean canSkipChecksum)\n      throws IOException {\n    int total \u003d 0;\n    long startDataPos \u003d dataPos;\n    int startBufPos \u003d buf.position();\n    while (buf.hasRemaining()) {\n      int nRead \u003d blockReaderIoProvider.read(dataIn, buf, dataPos);\n      if (nRead \u003c 0) {\n        break;\n      }\n      dataPos +\u003d nRead;\n      total +\u003d nRead;\n    }\n    if (canSkipChecksum) {\n      freeChecksumBufIfExists();\n      return total;\n    }\n    if (total \u003e 0) {\n      try {\n        buf.limit(buf.position());\n        buf.position(startBufPos);\n        createChecksumBufIfNeeded();\n        int checksumsNeeded \u003d (total + bytesPerChecksum - 1) /\n            bytesPerChecksum;\n        checksumBuf.clear();\n        checksumBuf.limit(checksumsNeeded * checksumSize);\n        long checksumPos \u003d BlockMetadataHeader.getHeaderSize()\n            + ((startDataPos / bytesPerChecksum) * checksumSize);\n        while (checksumBuf.hasRemaining()) {\n          int nRead \u003d checksumIn.read(checksumBuf, checksumPos);\n          if (nRead \u003c 0) {\n            throw new IOException(\"Got unexpected checksum file EOF at \" +\n                checksumPos + \", block file position \" + startDataPos +\n                \" for block \" + block + \" of file \" + filename);\n          }\n          checksumPos +\u003d nRead;\n        }\n        checksumBuf.flip();\n\n        checksum.verifyChunkedSums(buf, checksumBuf, filename, startDataPos);\n      } finally {\n        buf.position(buf.limit());\n      }\n    }\n    return total;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/client/impl/BlockReaderLocal.java",
      "extendedDetails": {}
    },
    "6d116ffad23b470f8e9ca131d8e89cbbbb4378d7": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11789. Maintain Short-Circuit Read Statistics. Contributed by Hanisha Koneru.\n",
      "commitDate": "22/06/17 1:35 PM",
      "commitName": "6d116ffad23b470f8e9ca131d8e89cbbbb4378d7",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "25/04/16 12:01 PM",
      "commitNameOld": "f308561f1d885491b88db73ac63003202056d661",
      "commitAuthorOld": "Tsz-Wo Nicholas Sze",
      "daysBetweenCommits": 423.07,
      "commitsBetweenForRepo": 2737,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,49 +1,49 @@\n   private synchronized int fillBuffer(ByteBuffer buf, boolean canSkipChecksum)\n       throws IOException {\n     try (TraceScope ignored \u003d tracer.newScope(\n         \"BlockReaderLocal#fillBuffer(\" + block.getBlockId() + \")\")) {\n       int total \u003d 0;\n       long startDataPos \u003d dataPos;\n       int startBufPos \u003d buf.position();\n       while (buf.hasRemaining()) {\n-        int nRead \u003d dataIn.read(buf, dataPos);\n+        int nRead \u003d blockReaderIoProvider.read(dataIn, buf, dataPos);\n         if (nRead \u003c 0) {\n           break;\n         }\n         dataPos +\u003d nRead;\n         total +\u003d nRead;\n       }\n       if (canSkipChecksum) {\n         freeChecksumBufIfExists();\n         return total;\n       }\n       if (total \u003e 0) {\n         try {\n           buf.limit(buf.position());\n           buf.position(startBufPos);\n           createChecksumBufIfNeeded();\n           int checksumsNeeded \u003d (total + bytesPerChecksum - 1) /\n               bytesPerChecksum;\n           checksumBuf.clear();\n           checksumBuf.limit(checksumsNeeded * checksumSize);\n           long checksumPos \u003d BlockMetadataHeader.getHeaderSize()\n               + ((startDataPos / bytesPerChecksum) * checksumSize);\n           while (checksumBuf.hasRemaining()) {\n             int nRead \u003d checksumIn.read(checksumBuf, checksumPos);\n             if (nRead \u003c 0) {\n               throw new IOException(\"Got unexpected checksum file EOF at \" +\n                   checksumPos + \", block file position \" + startDataPos +\n                   \" for block \" + block + \" of file \" + filename);\n             }\n             checksumPos +\u003d nRead;\n           }\n           checksumBuf.flip();\n \n           checksum.verifyChunkedSums(buf, checksumBuf, filename, startDataPos);\n         } finally {\n           buf.position(buf.limit());\n         }\n       }\n       return total;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized int fillBuffer(ByteBuffer buf, boolean canSkipChecksum)\n      throws IOException {\n    try (TraceScope ignored \u003d tracer.newScope(\n        \"BlockReaderLocal#fillBuffer(\" + block.getBlockId() + \")\")) {\n      int total \u003d 0;\n      long startDataPos \u003d dataPos;\n      int startBufPos \u003d buf.position();\n      while (buf.hasRemaining()) {\n        int nRead \u003d blockReaderIoProvider.read(dataIn, buf, dataPos);\n        if (nRead \u003c 0) {\n          break;\n        }\n        dataPos +\u003d nRead;\n        total +\u003d nRead;\n      }\n      if (canSkipChecksum) {\n        freeChecksumBufIfExists();\n        return total;\n      }\n      if (total \u003e 0) {\n        try {\n          buf.limit(buf.position());\n          buf.position(startBufPos);\n          createChecksumBufIfNeeded();\n          int checksumsNeeded \u003d (total + bytesPerChecksum - 1) /\n              bytesPerChecksum;\n          checksumBuf.clear();\n          checksumBuf.limit(checksumsNeeded * checksumSize);\n          long checksumPos \u003d BlockMetadataHeader.getHeaderSize()\n              + ((startDataPos / bytesPerChecksum) * checksumSize);\n          while (checksumBuf.hasRemaining()) {\n            int nRead \u003d checksumIn.read(checksumBuf, checksumPos);\n            if (nRead \u003c 0) {\n              throw new IOException(\"Got unexpected checksum file EOF at \" +\n                  checksumPos + \", block file position \" + startDataPos +\n                  \" for block \" + block + \" of file \" + filename);\n            }\n            checksumPos +\u003d nRead;\n          }\n          checksumBuf.flip();\n\n          checksum.verifyChunkedSums(buf, checksumBuf, filename, startDataPos);\n        } finally {\n          buf.position(buf.limit());\n        }\n      }\n      return total;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/client/impl/BlockReaderLocal.java",
      "extendedDetails": {}
    },
    "f308561f1d885491b88db73ac63003202056d661": {
      "type": "Yfilerename",
      "commitMessage": "HDFS-8057 Move BlockReader implementation to the client implementation package.  Contributed by Takanobu Asanuma\n",
      "commitDate": "25/04/16 12:01 PM",
      "commitName": "f308561f1d885491b88db73ac63003202056d661",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "commitDateOld": "25/04/16 9:38 AM",
      "commitNameOld": "10f0f7851a3255caab775777e8fb6c2781d97062",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private synchronized int fillBuffer(ByteBuffer buf, boolean canSkipChecksum)\n      throws IOException {\n    try (TraceScope ignored \u003d tracer.newScope(\n        \"BlockReaderLocal#fillBuffer(\" + block.getBlockId() + \")\")) {\n      int total \u003d 0;\n      long startDataPos \u003d dataPos;\n      int startBufPos \u003d buf.position();\n      while (buf.hasRemaining()) {\n        int nRead \u003d dataIn.read(buf, dataPos);\n        if (nRead \u003c 0) {\n          break;\n        }\n        dataPos +\u003d nRead;\n        total +\u003d nRead;\n      }\n      if (canSkipChecksum) {\n        freeChecksumBufIfExists();\n        return total;\n      }\n      if (total \u003e 0) {\n        try {\n          buf.limit(buf.position());\n          buf.position(startBufPos);\n          createChecksumBufIfNeeded();\n          int checksumsNeeded \u003d (total + bytesPerChecksum - 1) /\n              bytesPerChecksum;\n          checksumBuf.clear();\n          checksumBuf.limit(checksumsNeeded * checksumSize);\n          long checksumPos \u003d BlockMetadataHeader.getHeaderSize()\n              + ((startDataPos / bytesPerChecksum) * checksumSize);\n          while (checksumBuf.hasRemaining()) {\n            int nRead \u003d checksumIn.read(checksumBuf, checksumPos);\n            if (nRead \u003c 0) {\n              throw new IOException(\"Got unexpected checksum file EOF at \" +\n                  checksumPos + \", block file position \" + startDataPos +\n                  \" for block \" + block + \" of file \" + filename);\n            }\n            checksumPos +\u003d nRead;\n          }\n          checksumBuf.flip();\n\n          checksum.verifyChunkedSums(buf, checksumBuf, filename, startDataPos);\n        } finally {\n          buf.position(buf.limit());\n        }\n      }\n      return total;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/client/impl/BlockReaderLocal.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/BlockReaderLocal.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/client/impl/BlockReaderLocal.java"
      }
    },
    "7136e8c5582dc4061b566cb9f11a0d6a6d08bb93": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8979. Clean up checkstyle warnings in hadoop-hdfs-client module. Contributed by Mingliang Liu.\n",
      "commitDate": "03/10/15 11:38 AM",
      "commitName": "7136e8c5582dc4061b566cb9f11a0d6a6d08bb93",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "30/09/15 8:39 AM",
      "commitNameOld": "6c17d315287020368689fa078a40a1eaedf89d5b",
      "commitAuthorOld": "",
      "daysBetweenCommits": 3.12,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,51 +1,49 @@\n   private synchronized int fillBuffer(ByteBuffer buf, boolean canSkipChecksum)\n       throws IOException {\n-    TraceScope scope \u003d tracer.newScope(\n-        \"BlockReaderLocal#fillBuffer(\" + block.getBlockId() + \")\");\n-    try {\n+    try (TraceScope ignored \u003d tracer.newScope(\n+        \"BlockReaderLocal#fillBuffer(\" + block.getBlockId() + \")\")) {\n       int total \u003d 0;\n       long startDataPos \u003d dataPos;\n       int startBufPos \u003d buf.position();\n       while (buf.hasRemaining()) {\n         int nRead \u003d dataIn.read(buf, dataPos);\n         if (nRead \u003c 0) {\n           break;\n         }\n         dataPos +\u003d nRead;\n         total +\u003d nRead;\n       }\n       if (canSkipChecksum) {\n         freeChecksumBufIfExists();\n         return total;\n       }\n       if (total \u003e 0) {\n         try {\n           buf.limit(buf.position());\n           buf.position(startBufPos);\n           createChecksumBufIfNeeded();\n-          int checksumsNeeded \u003d (total + bytesPerChecksum - 1) / bytesPerChecksum;\n+          int checksumsNeeded \u003d (total + bytesPerChecksum - 1) /\n+              bytesPerChecksum;\n           checksumBuf.clear();\n           checksumBuf.limit(checksumsNeeded * checksumSize);\n           long checksumPos \u003d BlockMetadataHeader.getHeaderSize()\n               + ((startDataPos / bytesPerChecksum) * checksumSize);\n           while (checksumBuf.hasRemaining()) {\n             int nRead \u003d checksumIn.read(checksumBuf, checksumPos);\n             if (nRead \u003c 0) {\n               throw new IOException(\"Got unexpected checksum file EOF at \" +\n-                  checksumPos + \", block file position \" + startDataPos + \" for \" +\n-                  \"block \" + block + \" of file \" + filename);\n+                  checksumPos + \", block file position \" + startDataPos +\n+                  \" for block \" + block + \" of file \" + filename);\n             }\n             checksumPos +\u003d nRead;\n           }\n           checksumBuf.flip();\n \n           checksum.verifyChunkedSums(buf, checksumBuf, filename, startDataPos);\n         } finally {\n           buf.position(buf.limit());\n         }\n       }\n       return total;\n-    } finally {\n-      scope.close();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized int fillBuffer(ByteBuffer buf, boolean canSkipChecksum)\n      throws IOException {\n    try (TraceScope ignored \u003d tracer.newScope(\n        \"BlockReaderLocal#fillBuffer(\" + block.getBlockId() + \")\")) {\n      int total \u003d 0;\n      long startDataPos \u003d dataPos;\n      int startBufPos \u003d buf.position();\n      while (buf.hasRemaining()) {\n        int nRead \u003d dataIn.read(buf, dataPos);\n        if (nRead \u003c 0) {\n          break;\n        }\n        dataPos +\u003d nRead;\n        total +\u003d nRead;\n      }\n      if (canSkipChecksum) {\n        freeChecksumBufIfExists();\n        return total;\n      }\n      if (total \u003e 0) {\n        try {\n          buf.limit(buf.position());\n          buf.position(startBufPos);\n          createChecksumBufIfNeeded();\n          int checksumsNeeded \u003d (total + bytesPerChecksum - 1) /\n              bytesPerChecksum;\n          checksumBuf.clear();\n          checksumBuf.limit(checksumsNeeded * checksumSize);\n          long checksumPos \u003d BlockMetadataHeader.getHeaderSize()\n              + ((startDataPos / bytesPerChecksum) * checksumSize);\n          while (checksumBuf.hasRemaining()) {\n            int nRead \u003d checksumIn.read(checksumBuf, checksumPos);\n            if (nRead \u003c 0) {\n              throw new IOException(\"Got unexpected checksum file EOF at \" +\n                  checksumPos + \", block file position \" + startDataPos +\n                  \" for block \" + block + \" of file \" + filename);\n            }\n            checksumPos +\u003d nRead;\n          }\n          checksumBuf.flip();\n\n          checksum.verifyChunkedSums(buf, checksumBuf, filename, startDataPos);\n        } finally {\n          buf.position(buf.limit());\n        }\n      }\n      return total;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/BlockReaderLocal.java",
      "extendedDetails": {}
    },
    "892ade689f9bcce76daae8f66fc00a49bee8548e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9080. Update htrace version to 4.0.1 (cmccabe)\n",
      "commitDate": "28/09/15 7:42 AM",
      "commitName": "892ade689f9bcce76daae8f66fc00a49bee8548e",
      "commitAuthor": "Colin Patrick Mccabe",
      "commitDateOld": "28/08/15 2:38 PM",
      "commitNameOld": "e2c9b288b223b9fd82dc12018936e13128413492",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 30.71,
      "commitsBetweenForRepo": 195,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,51 +1,51 @@\n   private synchronized int fillBuffer(ByteBuffer buf, boolean canSkipChecksum)\n       throws IOException {\n-    TraceScope scope \u003d Trace.startSpan(\"BlockReaderLocal#fillBuffer(\" +\n-        block.getBlockId() + \")\", Sampler.NEVER);\n+    TraceScope scope \u003d tracer.newScope(\n+        \"BlockReaderLocal#fillBuffer(\" + block.getBlockId() + \")\");\n     try {\n       int total \u003d 0;\n       long startDataPos \u003d dataPos;\n       int startBufPos \u003d buf.position();\n       while (buf.hasRemaining()) {\n         int nRead \u003d dataIn.read(buf, dataPos);\n         if (nRead \u003c 0) {\n           break;\n         }\n         dataPos +\u003d nRead;\n         total +\u003d nRead;\n       }\n       if (canSkipChecksum) {\n         freeChecksumBufIfExists();\n         return total;\n       }\n       if (total \u003e 0) {\n         try {\n           buf.limit(buf.position());\n           buf.position(startBufPos);\n           createChecksumBufIfNeeded();\n           int checksumsNeeded \u003d (total + bytesPerChecksum - 1) / bytesPerChecksum;\n           checksumBuf.clear();\n           checksumBuf.limit(checksumsNeeded * checksumSize);\n           long checksumPos \u003d BlockMetadataHeader.getHeaderSize()\n               + ((startDataPos / bytesPerChecksum) * checksumSize);\n           while (checksumBuf.hasRemaining()) {\n             int nRead \u003d checksumIn.read(checksumBuf, checksumPos);\n             if (nRead \u003c 0) {\n               throw new IOException(\"Got unexpected checksum file EOF at \" +\n                   checksumPos + \", block file position \" + startDataPos + \" for \" +\n                   \"block \" + block + \" of file \" + filename);\n             }\n             checksumPos +\u003d nRead;\n           }\n           checksumBuf.flip();\n \n           checksum.verifyChunkedSums(buf, checksumBuf, filename, startDataPos);\n         } finally {\n           buf.position(buf.limit());\n         }\n       }\n       return total;\n     } finally {\n       scope.close();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized int fillBuffer(ByteBuffer buf, boolean canSkipChecksum)\n      throws IOException {\n    TraceScope scope \u003d tracer.newScope(\n        \"BlockReaderLocal#fillBuffer(\" + block.getBlockId() + \")\");\n    try {\n      int total \u003d 0;\n      long startDataPos \u003d dataPos;\n      int startBufPos \u003d buf.position();\n      while (buf.hasRemaining()) {\n        int nRead \u003d dataIn.read(buf, dataPos);\n        if (nRead \u003c 0) {\n          break;\n        }\n        dataPos +\u003d nRead;\n        total +\u003d nRead;\n      }\n      if (canSkipChecksum) {\n        freeChecksumBufIfExists();\n        return total;\n      }\n      if (total \u003e 0) {\n        try {\n          buf.limit(buf.position());\n          buf.position(startBufPos);\n          createChecksumBufIfNeeded();\n          int checksumsNeeded \u003d (total + bytesPerChecksum - 1) / bytesPerChecksum;\n          checksumBuf.clear();\n          checksumBuf.limit(checksumsNeeded * checksumSize);\n          long checksumPos \u003d BlockMetadataHeader.getHeaderSize()\n              + ((startDataPos / bytesPerChecksum) * checksumSize);\n          while (checksumBuf.hasRemaining()) {\n            int nRead \u003d checksumIn.read(checksumBuf, checksumPos);\n            if (nRead \u003c 0) {\n              throw new IOException(\"Got unexpected checksum file EOF at \" +\n                  checksumPos + \", block file position \" + startDataPos + \" for \" +\n                  \"block \" + block + \" of file \" + filename);\n            }\n            checksumPos +\u003d nRead;\n          }\n          checksumBuf.flip();\n\n          checksum.verifyChunkedSums(buf, checksumBuf, filename, startDataPos);\n        } finally {\n          buf.position(buf.limit());\n        }\n      }\n      return total;\n    } finally {\n      scope.close();\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/BlockReaderLocal.java",
      "extendedDetails": {}
    },
    "e2c9b288b223b9fd82dc12018936e13128413492": {
      "type": "Yfilerename",
      "commitMessage": "HDFS-8925. Move BlockReaderLocal to hdfs-client. Contributed by Mingliang Liu.\n",
      "commitDate": "28/08/15 2:38 PM",
      "commitName": "e2c9b288b223b9fd82dc12018936e13128413492",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "28/08/15 2:21 PM",
      "commitNameOld": "b94b56806d3d6e04984e229b479f7ac15b62bbfa",
      "commitAuthorOld": "Colin Patrick Mccabe",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private synchronized int fillBuffer(ByteBuffer buf, boolean canSkipChecksum)\n      throws IOException {\n    TraceScope scope \u003d Trace.startSpan(\"BlockReaderLocal#fillBuffer(\" +\n        block.getBlockId() + \")\", Sampler.NEVER);\n    try {\n      int total \u003d 0;\n      long startDataPos \u003d dataPos;\n      int startBufPos \u003d buf.position();\n      while (buf.hasRemaining()) {\n        int nRead \u003d dataIn.read(buf, dataPos);\n        if (nRead \u003c 0) {\n          break;\n        }\n        dataPos +\u003d nRead;\n        total +\u003d nRead;\n      }\n      if (canSkipChecksum) {\n        freeChecksumBufIfExists();\n        return total;\n      }\n      if (total \u003e 0) {\n        try {\n          buf.limit(buf.position());\n          buf.position(startBufPos);\n          createChecksumBufIfNeeded();\n          int checksumsNeeded \u003d (total + bytesPerChecksum - 1) / bytesPerChecksum;\n          checksumBuf.clear();\n          checksumBuf.limit(checksumsNeeded * checksumSize);\n          long checksumPos \u003d BlockMetadataHeader.getHeaderSize()\n              + ((startDataPos / bytesPerChecksum) * checksumSize);\n          while (checksumBuf.hasRemaining()) {\n            int nRead \u003d checksumIn.read(checksumBuf, checksumPos);\n            if (nRead \u003c 0) {\n              throw new IOException(\"Got unexpected checksum file EOF at \" +\n                  checksumPos + \", block file position \" + startDataPos + \" for \" +\n                  \"block \" + block + \" of file \" + filename);\n            }\n            checksumPos +\u003d nRead;\n          }\n          checksumBuf.flip();\n\n          checksum.verifyChunkedSums(buf, checksumBuf, filename, startDataPos);\n        } finally {\n          buf.position(buf.limit());\n        }\n      }\n      return total;\n    } finally {\n      scope.close();\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/BlockReaderLocal.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/BlockReaderLocal.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/BlockReaderLocal.java"
      }
    },
    "463aec11718e47d4aabb86a7a539cb973460aae6": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6934. Move checksum computation off the hot path when writing to RAM disk. Contributed by Chris Nauroth.\n",
      "commitDate": "27/10/14 9:38 AM",
      "commitName": "463aec11718e47d4aabb86a7a539cb973460aae6",
      "commitAuthor": "cnauroth",
      "commitDateOld": "03/10/14 1:35 PM",
      "commitNameOld": "7f6ed7fe365166e8075359f1d0ad035fa876c70f",
      "commitAuthorOld": "Colin Patrick Mccabe",
      "daysBetweenCommits": 23.84,
      "commitsBetweenForRepo": 188,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,51 +1,51 @@\n   private synchronized int fillBuffer(ByteBuffer buf, boolean canSkipChecksum)\n       throws IOException {\n     TraceScope scope \u003d Trace.startSpan(\"BlockReaderLocal#fillBuffer(\" +\n         block.getBlockId() + \")\", Sampler.NEVER);\n     try {\n       int total \u003d 0;\n       long startDataPos \u003d dataPos;\n       int startBufPos \u003d buf.position();\n       while (buf.hasRemaining()) {\n         int nRead \u003d dataIn.read(buf, dataPos);\n         if (nRead \u003c 0) {\n           break;\n         }\n         dataPos +\u003d nRead;\n         total +\u003d nRead;\n       }\n       if (canSkipChecksum) {\n         freeChecksumBufIfExists();\n         return total;\n       }\n       if (total \u003e 0) {\n         try {\n           buf.limit(buf.position());\n           buf.position(startBufPos);\n           createChecksumBufIfNeeded();\n           int checksumsNeeded \u003d (total + bytesPerChecksum - 1) / bytesPerChecksum;\n           checksumBuf.clear();\n           checksumBuf.limit(checksumsNeeded * checksumSize);\n-          long checksumPos \u003d\n-              7 + ((startDataPos / bytesPerChecksum) * checksumSize);\n+          long checksumPos \u003d BlockMetadataHeader.getHeaderSize()\n+              + ((startDataPos / bytesPerChecksum) * checksumSize);\n           while (checksumBuf.hasRemaining()) {\n             int nRead \u003d checksumIn.read(checksumBuf, checksumPos);\n             if (nRead \u003c 0) {\n               throw new IOException(\"Got unexpected checksum file EOF at \" +\n                   checksumPos + \", block file position \" + startDataPos + \" for \" +\n                   \"block \" + block + \" of file \" + filename);\n             }\n             checksumPos +\u003d nRead;\n           }\n           checksumBuf.flip();\n \n           checksum.verifyChunkedSums(buf, checksumBuf, filename, startDataPos);\n         } finally {\n           buf.position(buf.limit());\n         }\n       }\n       return total;\n     } finally {\n       scope.close();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized int fillBuffer(ByteBuffer buf, boolean canSkipChecksum)\n      throws IOException {\n    TraceScope scope \u003d Trace.startSpan(\"BlockReaderLocal#fillBuffer(\" +\n        block.getBlockId() + \")\", Sampler.NEVER);\n    try {\n      int total \u003d 0;\n      long startDataPos \u003d dataPos;\n      int startBufPos \u003d buf.position();\n      while (buf.hasRemaining()) {\n        int nRead \u003d dataIn.read(buf, dataPos);\n        if (nRead \u003c 0) {\n          break;\n        }\n        dataPos +\u003d nRead;\n        total +\u003d nRead;\n      }\n      if (canSkipChecksum) {\n        freeChecksumBufIfExists();\n        return total;\n      }\n      if (total \u003e 0) {\n        try {\n          buf.limit(buf.position());\n          buf.position(startBufPos);\n          createChecksumBufIfNeeded();\n          int checksumsNeeded \u003d (total + bytesPerChecksum - 1) / bytesPerChecksum;\n          checksumBuf.clear();\n          checksumBuf.limit(checksumsNeeded * checksumSize);\n          long checksumPos \u003d BlockMetadataHeader.getHeaderSize()\n              + ((startDataPos / bytesPerChecksum) * checksumSize);\n          while (checksumBuf.hasRemaining()) {\n            int nRead \u003d checksumIn.read(checksumBuf, checksumPos);\n            if (nRead \u003c 0) {\n              throw new IOException(\"Got unexpected checksum file EOF at \" +\n                  checksumPos + \", block file position \" + startDataPos + \" for \" +\n                  \"block \" + block + \" of file \" + filename);\n            }\n            checksumPos +\u003d nRead;\n          }\n          checksumBuf.flip();\n\n          checksum.verifyChunkedSums(buf, checksumBuf, filename, startDataPos);\n        } finally {\n          buf.position(buf.limit());\n        }\n      }\n      return total;\n    } finally {\n      scope.close();\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/BlockReaderLocal.java",
      "extendedDetails": {}
    },
    "7f6ed7fe365166e8075359f1d0ad035fa876c70f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7055. Add tracing to DFSInputStream (cmccabe)\n",
      "commitDate": "03/10/14 1:35 PM",
      "commitName": "7f6ed7fe365166e8075359f1d0ad035fa876c70f",
      "commitAuthor": "Colin Patrick Mccabe",
      "commitDateOld": "23/07/14 11:22 PM",
      "commitNameOld": "2054453a39efeca86361e26033a65f2715f4785c",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 71.59,
      "commitsBetweenForRepo": 715,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,45 +1,51 @@\n   private synchronized int fillBuffer(ByteBuffer buf, boolean canSkipChecksum)\n       throws IOException {\n-    int total \u003d 0;\n-    long startDataPos \u003d dataPos;\n-    int startBufPos \u003d buf.position();\n-    while (buf.hasRemaining()) {\n-      int nRead \u003d dataIn.read(buf, dataPos);\n-      if (nRead \u003c 0) {\n-        break;\n-      }\n-      dataPos +\u003d nRead;\n-      total +\u003d nRead;\n-    }\n-    if (canSkipChecksum) {\n-      freeChecksumBufIfExists();\n-      return total;\n-    }\n-    if (total \u003e 0) {\n-      try {\n-        buf.limit(buf.position());\n-        buf.position(startBufPos);\n-        createChecksumBufIfNeeded();\n-        int checksumsNeeded \u003d (total + bytesPerChecksum - 1) / bytesPerChecksum;\n-        checksumBuf.clear();\n-        checksumBuf.limit(checksumsNeeded * checksumSize);\n-        long checksumPos \u003d\n-          7 + ((startDataPos / bytesPerChecksum) * checksumSize);\n-        while (checksumBuf.hasRemaining()) {\n-          int nRead \u003d checksumIn.read(checksumBuf, checksumPos);\n-          if (nRead \u003c 0) {\n-            throw new IOException(\"Got unexpected checksum file EOF at \" +\n-                checksumPos + \", block file position \" + startDataPos + \" for \" +\n-                \"block \" + block + \" of file \" + filename);\n-          }\n-          checksumPos +\u003d nRead;\n+    TraceScope scope \u003d Trace.startSpan(\"BlockReaderLocal#fillBuffer(\" +\n+        block.getBlockId() + \")\", Sampler.NEVER);\n+    try {\n+      int total \u003d 0;\n+      long startDataPos \u003d dataPos;\n+      int startBufPos \u003d buf.position();\n+      while (buf.hasRemaining()) {\n+        int nRead \u003d dataIn.read(buf, dataPos);\n+        if (nRead \u003c 0) {\n+          break;\n         }\n-        checksumBuf.flip();\n-  \n-        checksum.verifyChunkedSums(buf, checksumBuf, filename, startDataPos);\n-      } finally {\n-        buf.position(buf.limit());\n+        dataPos +\u003d nRead;\n+        total +\u003d nRead;\n       }\n+      if (canSkipChecksum) {\n+        freeChecksumBufIfExists();\n+        return total;\n+      }\n+      if (total \u003e 0) {\n+        try {\n+          buf.limit(buf.position());\n+          buf.position(startBufPos);\n+          createChecksumBufIfNeeded();\n+          int checksumsNeeded \u003d (total + bytesPerChecksum - 1) / bytesPerChecksum;\n+          checksumBuf.clear();\n+          checksumBuf.limit(checksumsNeeded * checksumSize);\n+          long checksumPos \u003d\n+              7 + ((startDataPos / bytesPerChecksum) * checksumSize);\n+          while (checksumBuf.hasRemaining()) {\n+            int nRead \u003d checksumIn.read(checksumBuf, checksumPos);\n+            if (nRead \u003c 0) {\n+              throw new IOException(\"Got unexpected checksum file EOF at \" +\n+                  checksumPos + \", block file position \" + startDataPos + \" for \" +\n+                  \"block \" + block + \" of file \" + filename);\n+            }\n+            checksumPos +\u003d nRead;\n+          }\n+          checksumBuf.flip();\n+\n+          checksum.verifyChunkedSums(buf, checksumBuf, filename, startDataPos);\n+        } finally {\n+          buf.position(buf.limit());\n+        }\n+      }\n+      return total;\n+    } finally {\n+      scope.close();\n     }\n-    return total;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized int fillBuffer(ByteBuffer buf, boolean canSkipChecksum)\n      throws IOException {\n    TraceScope scope \u003d Trace.startSpan(\"BlockReaderLocal#fillBuffer(\" +\n        block.getBlockId() + \")\", Sampler.NEVER);\n    try {\n      int total \u003d 0;\n      long startDataPos \u003d dataPos;\n      int startBufPos \u003d buf.position();\n      while (buf.hasRemaining()) {\n        int nRead \u003d dataIn.read(buf, dataPos);\n        if (nRead \u003c 0) {\n          break;\n        }\n        dataPos +\u003d nRead;\n        total +\u003d nRead;\n      }\n      if (canSkipChecksum) {\n        freeChecksumBufIfExists();\n        return total;\n      }\n      if (total \u003e 0) {\n        try {\n          buf.limit(buf.position());\n          buf.position(startBufPos);\n          createChecksumBufIfNeeded();\n          int checksumsNeeded \u003d (total + bytesPerChecksum - 1) / bytesPerChecksum;\n          checksumBuf.clear();\n          checksumBuf.limit(checksumsNeeded * checksumSize);\n          long checksumPos \u003d\n              7 + ((startDataPos / bytesPerChecksum) * checksumSize);\n          while (checksumBuf.hasRemaining()) {\n            int nRead \u003d checksumIn.read(checksumBuf, checksumPos);\n            if (nRead \u003c 0) {\n              throw new IOException(\"Got unexpected checksum file EOF at \" +\n                  checksumPos + \", block file position \" + startDataPos + \" for \" +\n                  \"block \" + block + \" of file \" + filename);\n            }\n            checksumPos +\u003d nRead;\n          }\n          checksumBuf.flip();\n\n          checksum.verifyChunkedSums(buf, checksumBuf, filename, startDataPos);\n        } finally {\n          buf.position(buf.limit());\n        }\n      }\n      return total;\n    } finally {\n      scope.close();\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/BlockReaderLocal.java",
      "extendedDetails": {}
    },
    "124e507674c0d396f8494585e64226957199097b": {
      "type": "Ymultichange(Yparameterchange,Ymodifierchange,Ybodychange)",
      "commitMessage": "HDFS-5634. Allow BlockReaderLocal to switch between checksumming and not (cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1551701 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/12/13 12:57 PM",
      "commitName": "124e507674c0d396f8494585e64226957199097b",
      "commitAuthor": "Colin McCabe",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-5634. Allow BlockReaderLocal to switch between checksumming and not (cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1551701 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "17/12/13 12:57 PM",
          "commitName": "124e507674c0d396f8494585e64226957199097b",
          "commitAuthor": "Colin McCabe",
          "commitDateOld": "27/09/13 3:51 PM",
          "commitNameOld": "eccdb9aa8bcdee750583d16a1253f1c5faabd036",
          "commitAuthorOld": "Chris Nauroth",
          "daysBetweenCommits": 80.92,
          "commitsBetweenForRepo": 532,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,17 +1,45 @@\n-  private int fillBuffer(FileInputStream stream, ByteBuffer buf)\n+  private synchronized int fillBuffer(ByteBuffer buf, boolean canSkipChecksum)\n       throws IOException {\n-    int bytesRead \u003d stream.getChannel().read(buf);\n-    if (bytesRead \u003c 0) {\n-      //EOF\n-      return bytesRead;\n-    }\n-    while (buf.remaining() \u003e 0) {\n-      int n \u003d stream.getChannel().read(buf);\n-      if (n \u003c 0) {\n-        //EOF\n-        return bytesRead;\n+    int total \u003d 0;\n+    long startDataPos \u003d dataPos;\n+    int startBufPos \u003d buf.position();\n+    while (buf.hasRemaining()) {\n+      int nRead \u003d dataIn.read(buf, dataPos);\n+      if (nRead \u003c 0) {\n+        break;\n       }\n-      bytesRead +\u003d n;\n+      dataPos +\u003d nRead;\n+      total +\u003d nRead;\n     }\n-    return bytesRead;\n+    if (canSkipChecksum) {\n+      freeChecksumBufIfExists();\n+      return total;\n+    }\n+    if (total \u003e 0) {\n+      try {\n+        buf.limit(buf.position());\n+        buf.position(startBufPos);\n+        createChecksumBufIfNeeded();\n+        int checksumsNeeded \u003d (total + bytesPerChecksum - 1) / bytesPerChecksum;\n+        checksumBuf.clear();\n+        checksumBuf.limit(checksumsNeeded * checksumSize);\n+        long checksumPos \u003d\n+          7 + ((startDataPos / bytesPerChecksum) * checksumSize);\n+        while (checksumBuf.hasRemaining()) {\n+          int nRead \u003d checksumIn.read(checksumBuf, checksumPos);\n+          if (nRead \u003c 0) {\n+            throw new IOException(\"Got unexpected checksum file EOF at \" +\n+                checksumPos + \", block file position \" + startDataPos + \" for \" +\n+                \"block \" + block + \" of file \" + filename);\n+          }\n+          checksumPos +\u003d nRead;\n+        }\n+        checksumBuf.flip();\n+  \n+        checksum.verifyChunkedSums(buf, checksumBuf, filename, startDataPos);\n+      } finally {\n+        buf.position(buf.limit());\n+      }\n+    }\n+    return total;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private synchronized int fillBuffer(ByteBuffer buf, boolean canSkipChecksum)\n      throws IOException {\n    int total \u003d 0;\n    long startDataPos \u003d dataPos;\n    int startBufPos \u003d buf.position();\n    while (buf.hasRemaining()) {\n      int nRead \u003d dataIn.read(buf, dataPos);\n      if (nRead \u003c 0) {\n        break;\n      }\n      dataPos +\u003d nRead;\n      total +\u003d nRead;\n    }\n    if (canSkipChecksum) {\n      freeChecksumBufIfExists();\n      return total;\n    }\n    if (total \u003e 0) {\n      try {\n        buf.limit(buf.position());\n        buf.position(startBufPos);\n        createChecksumBufIfNeeded();\n        int checksumsNeeded \u003d (total + bytesPerChecksum - 1) / bytesPerChecksum;\n        checksumBuf.clear();\n        checksumBuf.limit(checksumsNeeded * checksumSize);\n        long checksumPos \u003d\n          7 + ((startDataPos / bytesPerChecksum) * checksumSize);\n        while (checksumBuf.hasRemaining()) {\n          int nRead \u003d checksumIn.read(checksumBuf, checksumPos);\n          if (nRead \u003c 0) {\n            throw new IOException(\"Got unexpected checksum file EOF at \" +\n                checksumPos + \", block file position \" + startDataPos + \" for \" +\n                \"block \" + block + \" of file \" + filename);\n          }\n          checksumPos +\u003d nRead;\n        }\n        checksumBuf.flip();\n  \n        checksum.verifyChunkedSums(buf, checksumBuf, filename, startDataPos);\n      } finally {\n        buf.position(buf.limit());\n      }\n    }\n    return total;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/BlockReaderLocal.java",
          "extendedDetails": {
            "oldValue": "[stream-FileInputStream, buf-ByteBuffer]",
            "newValue": "[buf-ByteBuffer, canSkipChecksum-boolean]"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "HDFS-5634. Allow BlockReaderLocal to switch between checksumming and not (cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1551701 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "17/12/13 12:57 PM",
          "commitName": "124e507674c0d396f8494585e64226957199097b",
          "commitAuthor": "Colin McCabe",
          "commitDateOld": "27/09/13 3:51 PM",
          "commitNameOld": "eccdb9aa8bcdee750583d16a1253f1c5faabd036",
          "commitAuthorOld": "Chris Nauroth",
          "daysBetweenCommits": 80.92,
          "commitsBetweenForRepo": 532,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,17 +1,45 @@\n-  private int fillBuffer(FileInputStream stream, ByteBuffer buf)\n+  private synchronized int fillBuffer(ByteBuffer buf, boolean canSkipChecksum)\n       throws IOException {\n-    int bytesRead \u003d stream.getChannel().read(buf);\n-    if (bytesRead \u003c 0) {\n-      //EOF\n-      return bytesRead;\n-    }\n-    while (buf.remaining() \u003e 0) {\n-      int n \u003d stream.getChannel().read(buf);\n-      if (n \u003c 0) {\n-        //EOF\n-        return bytesRead;\n+    int total \u003d 0;\n+    long startDataPos \u003d dataPos;\n+    int startBufPos \u003d buf.position();\n+    while (buf.hasRemaining()) {\n+      int nRead \u003d dataIn.read(buf, dataPos);\n+      if (nRead \u003c 0) {\n+        break;\n       }\n-      bytesRead +\u003d n;\n+      dataPos +\u003d nRead;\n+      total +\u003d nRead;\n     }\n-    return bytesRead;\n+    if (canSkipChecksum) {\n+      freeChecksumBufIfExists();\n+      return total;\n+    }\n+    if (total \u003e 0) {\n+      try {\n+        buf.limit(buf.position());\n+        buf.position(startBufPos);\n+        createChecksumBufIfNeeded();\n+        int checksumsNeeded \u003d (total + bytesPerChecksum - 1) / bytesPerChecksum;\n+        checksumBuf.clear();\n+        checksumBuf.limit(checksumsNeeded * checksumSize);\n+        long checksumPos \u003d\n+          7 + ((startDataPos / bytesPerChecksum) * checksumSize);\n+        while (checksumBuf.hasRemaining()) {\n+          int nRead \u003d checksumIn.read(checksumBuf, checksumPos);\n+          if (nRead \u003c 0) {\n+            throw new IOException(\"Got unexpected checksum file EOF at \" +\n+                checksumPos + \", block file position \" + startDataPos + \" for \" +\n+                \"block \" + block + \" of file \" + filename);\n+          }\n+          checksumPos +\u003d nRead;\n+        }\n+        checksumBuf.flip();\n+  \n+        checksum.verifyChunkedSums(buf, checksumBuf, filename, startDataPos);\n+      } finally {\n+        buf.position(buf.limit());\n+      }\n+    }\n+    return total;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private synchronized int fillBuffer(ByteBuffer buf, boolean canSkipChecksum)\n      throws IOException {\n    int total \u003d 0;\n    long startDataPos \u003d dataPos;\n    int startBufPos \u003d buf.position();\n    while (buf.hasRemaining()) {\n      int nRead \u003d dataIn.read(buf, dataPos);\n      if (nRead \u003c 0) {\n        break;\n      }\n      dataPos +\u003d nRead;\n      total +\u003d nRead;\n    }\n    if (canSkipChecksum) {\n      freeChecksumBufIfExists();\n      return total;\n    }\n    if (total \u003e 0) {\n      try {\n        buf.limit(buf.position());\n        buf.position(startBufPos);\n        createChecksumBufIfNeeded();\n        int checksumsNeeded \u003d (total + bytesPerChecksum - 1) / bytesPerChecksum;\n        checksumBuf.clear();\n        checksumBuf.limit(checksumsNeeded * checksumSize);\n        long checksumPos \u003d\n          7 + ((startDataPos / bytesPerChecksum) * checksumSize);\n        while (checksumBuf.hasRemaining()) {\n          int nRead \u003d checksumIn.read(checksumBuf, checksumPos);\n          if (nRead \u003c 0) {\n            throw new IOException(\"Got unexpected checksum file EOF at \" +\n                checksumPos + \", block file position \" + startDataPos + \" for \" +\n                \"block \" + block + \" of file \" + filename);\n          }\n          checksumPos +\u003d nRead;\n        }\n        checksumBuf.flip();\n  \n        checksum.verifyChunkedSums(buf, checksumBuf, filename, startDataPos);\n      } finally {\n        buf.position(buf.limit());\n      }\n    }\n    return total;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/BlockReaderLocal.java",
          "extendedDetails": {
            "oldValue": "[private]",
            "newValue": "[private, synchronized]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-5634. Allow BlockReaderLocal to switch between checksumming and not (cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1551701 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "17/12/13 12:57 PM",
          "commitName": "124e507674c0d396f8494585e64226957199097b",
          "commitAuthor": "Colin McCabe",
          "commitDateOld": "27/09/13 3:51 PM",
          "commitNameOld": "eccdb9aa8bcdee750583d16a1253f1c5faabd036",
          "commitAuthorOld": "Chris Nauroth",
          "daysBetweenCommits": 80.92,
          "commitsBetweenForRepo": 532,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,17 +1,45 @@\n-  private int fillBuffer(FileInputStream stream, ByteBuffer buf)\n+  private synchronized int fillBuffer(ByteBuffer buf, boolean canSkipChecksum)\n       throws IOException {\n-    int bytesRead \u003d stream.getChannel().read(buf);\n-    if (bytesRead \u003c 0) {\n-      //EOF\n-      return bytesRead;\n-    }\n-    while (buf.remaining() \u003e 0) {\n-      int n \u003d stream.getChannel().read(buf);\n-      if (n \u003c 0) {\n-        //EOF\n-        return bytesRead;\n+    int total \u003d 0;\n+    long startDataPos \u003d dataPos;\n+    int startBufPos \u003d buf.position();\n+    while (buf.hasRemaining()) {\n+      int nRead \u003d dataIn.read(buf, dataPos);\n+      if (nRead \u003c 0) {\n+        break;\n       }\n-      bytesRead +\u003d n;\n+      dataPos +\u003d nRead;\n+      total +\u003d nRead;\n     }\n-    return bytesRead;\n+    if (canSkipChecksum) {\n+      freeChecksumBufIfExists();\n+      return total;\n+    }\n+    if (total \u003e 0) {\n+      try {\n+        buf.limit(buf.position());\n+        buf.position(startBufPos);\n+        createChecksumBufIfNeeded();\n+        int checksumsNeeded \u003d (total + bytesPerChecksum - 1) / bytesPerChecksum;\n+        checksumBuf.clear();\n+        checksumBuf.limit(checksumsNeeded * checksumSize);\n+        long checksumPos \u003d\n+          7 + ((startDataPos / bytesPerChecksum) * checksumSize);\n+        while (checksumBuf.hasRemaining()) {\n+          int nRead \u003d checksumIn.read(checksumBuf, checksumPos);\n+          if (nRead \u003c 0) {\n+            throw new IOException(\"Got unexpected checksum file EOF at \" +\n+                checksumPos + \", block file position \" + startDataPos + \" for \" +\n+                \"block \" + block + \" of file \" + filename);\n+          }\n+          checksumPos +\u003d nRead;\n+        }\n+        checksumBuf.flip();\n+  \n+        checksum.verifyChunkedSums(buf, checksumBuf, filename, startDataPos);\n+      } finally {\n+        buf.position(buf.limit());\n+      }\n+    }\n+    return total;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private synchronized int fillBuffer(ByteBuffer buf, boolean canSkipChecksum)\n      throws IOException {\n    int total \u003d 0;\n    long startDataPos \u003d dataPos;\n    int startBufPos \u003d buf.position();\n    while (buf.hasRemaining()) {\n      int nRead \u003d dataIn.read(buf, dataPos);\n      if (nRead \u003c 0) {\n        break;\n      }\n      dataPos +\u003d nRead;\n      total +\u003d nRead;\n    }\n    if (canSkipChecksum) {\n      freeChecksumBufIfExists();\n      return total;\n    }\n    if (total \u003e 0) {\n      try {\n        buf.limit(buf.position());\n        buf.position(startBufPos);\n        createChecksumBufIfNeeded();\n        int checksumsNeeded \u003d (total + bytesPerChecksum - 1) / bytesPerChecksum;\n        checksumBuf.clear();\n        checksumBuf.limit(checksumsNeeded * checksumSize);\n        long checksumPos \u003d\n          7 + ((startDataPos / bytesPerChecksum) * checksumSize);\n        while (checksumBuf.hasRemaining()) {\n          int nRead \u003d checksumIn.read(checksumBuf, checksumPos);\n          if (nRead \u003c 0) {\n            throw new IOException(\"Got unexpected checksum file EOF at \" +\n                checksumPos + \", block file position \" + startDataPos + \" for \" +\n                \"block \" + block + \" of file \" + filename);\n          }\n          checksumPos +\u003d nRead;\n        }\n        checksumBuf.flip();\n  \n        checksum.verifyChunkedSums(buf, checksumBuf, filename, startDataPos);\n      } finally {\n        buf.position(buf.limit());\n      }\n    }\n    return total;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/BlockReaderLocal.java",
          "extendedDetails": {}
        }
      ]
    },
    "f55a1c08763e5f865fd9193d640c89a06ab49c4a": {
      "type": "Yrename",
      "commitMessage": "HDFS-2834. Add a ByteBuffer-based read API to DFSInputStream. Contributed by Henry Robinson.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1303474 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/03/12 10:30 AM",
      "commitName": "f55a1c08763e5f865fd9193d640c89a06ab49c4a",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "16/02/12 10:58 AM",
      "commitNameOld": "b8448dea82c72ff6c1558b9ebf3f24cd1c6e728b",
      "commitAuthorOld": "Jitendra Nath Pandey",
      "daysBetweenCommits": 33.94,
      "commitsBetweenForRepo": 229,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,17 +1,17 @@\n-  private int readIntoBuffer(FileInputStream stream, ByteBuffer buf)\n+  private int fillBuffer(FileInputStream stream, ByteBuffer buf)\n       throws IOException {\n     int bytesRead \u003d stream.getChannel().read(buf);\n     if (bytesRead \u003c 0) {\n       //EOF\n       return bytesRead;\n     }\n     while (buf.remaining() \u003e 0) {\n       int n \u003d stream.getChannel().read(buf);\n       if (n \u003c 0) {\n         //EOF\n         return bytesRead;\n       }\n       bytesRead +\u003d n;\n     }\n     return bytesRead;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int fillBuffer(FileInputStream stream, ByteBuffer buf)\n      throws IOException {\n    int bytesRead \u003d stream.getChannel().read(buf);\n    if (bytesRead \u003c 0) {\n      //EOF\n      return bytesRead;\n    }\n    while (buf.remaining() \u003e 0) {\n      int n \u003d stream.getChannel().read(buf);\n      if (n \u003c 0) {\n        //EOF\n        return bytesRead;\n      }\n      bytesRead +\u003d n;\n    }\n    return bytesRead;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/BlockReaderLocal.java",
      "extendedDetails": {
        "oldValue": "readIntoBuffer",
        "newValue": "fillBuffer"
      }
    },
    "2ab10e29d9cca5018064be46a40e3c74423615a8": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-2246. Enable reading a block directly from local file system for a client on the same node as the block file.  Contributed by Andrew Purtell, Suresh Srinivas and Jitendra Nath Pandey\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1204792 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/11/11 6:57 PM",
      "commitName": "2ab10e29d9cca5018064be46a40e3c74423615a8",
      "commitAuthor": "Tsz-wo Sze",
      "diff": "@@ -0,0 +1,17 @@\n+  private int readIntoBuffer(FileInputStream stream, ByteBuffer buf)\n+      throws IOException {\n+    int bytesRead \u003d stream.getChannel().read(buf);\n+    if (bytesRead \u003c 0) {\n+      //EOF\n+      return bytesRead;\n+    }\n+    while (buf.remaining() \u003e 0) {\n+      int n \u003d stream.getChannel().read(buf);\n+      if (n \u003c 0) {\n+        //EOF\n+        return bytesRead;\n+      }\n+      bytesRead +\u003d n;\n+    }\n+    return bytesRead;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private int readIntoBuffer(FileInputStream stream, ByteBuffer buf)\n      throws IOException {\n    int bytesRead \u003d stream.getChannel().read(buf);\n    if (bytesRead \u003c 0) {\n      //EOF\n      return bytesRead;\n    }\n    while (buf.remaining() \u003e 0) {\n      int n \u003d stream.getChannel().read(buf);\n      if (n \u003c 0) {\n        //EOF\n        return bytesRead;\n      }\n      bytesRead +\u003d n;\n    }\n    return bytesRead;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/BlockReaderLocal.java"
    }
  }
}