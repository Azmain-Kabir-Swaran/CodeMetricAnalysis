{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "S3AUtils.java",
  "functionName": "propagateBucketOptions",
  "functionId": "propagateBucketOptions___source-Configuration__bucket-String",
  "sourceFilePath": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AUtils.java",
  "functionStartLine": 1147,
  "functionEndLine": 1178,
  "numCommitsSeen": 51,
  "timeTaken": 1796,
  "changeHistory": [
    "47011d7dd300b0c74bb6cfe25b918c479d718f4f",
    "e648b6e1382336af69434dfbf9161bced3caa244"
  ],
  "changeHistoryShort": {
    "47011d7dd300b0c74bb6cfe25b918c479d718f4f": "Ybodychange",
    "e648b6e1382336af69434dfbf9161bced3caa244": "Yintroduced"
  },
  "changeHistoryDetails": {
    "47011d7dd300b0c74bb6cfe25b918c479d718f4f": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14220 Enhance S3GuardTool with bucket-info and set-capacity commands, tests. Contributed by Steve Loughran\n",
      "commitDate": "25/09/17 3:59 PM",
      "commitName": "47011d7dd300b0c74bb6cfe25b918c479d718f4f",
      "commitAuthor": "Aaron Fabbri",
      "commitDateOld": "01/09/17 6:13 AM",
      "commitNameOld": "621b43e254afaff708cd6fc4698b29628f6abc33",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 24.41,
      "commitsBetweenForRepo": 233,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,30 +1,32 @@\n   public static Configuration propagateBucketOptions(Configuration source,\n       String bucket) {\n \n     Preconditions.checkArgument(StringUtils.isNotEmpty(bucket), \"bucket\");\n     final String bucketPrefix \u003d FS_S3A_BUCKET_PREFIX + bucket +\u0027.\u0027;\n     LOG.debug(\"Propagating entries under {}\", bucketPrefix);\n     final Configuration dest \u003d new Configuration(source);\n     for (Map.Entry\u003cString, String\u003e entry : source) {\n       final String key \u003d entry.getKey();\n       // get the (unexpanded) value.\n       final String value \u003d entry.getValue();\n       if (!key.startsWith(bucketPrefix) || bucketPrefix.equals(key)) {\n         continue;\n       }\n       // there\u0027s a bucket prefix, so strip it\n       final String stripped \u003d key.substring(bucketPrefix.length());\n       if (stripped.startsWith(\"bucket.\") || \"impl\".equals(stripped)) {\n         //tell user off\n         LOG.debug(\"Ignoring bucket option {}\", key);\n       }  else {\n         // propagate the value, building a new origin field.\n         // to track overwrites, the generic key is overwritten even if\n         // already matches the new one.\n+        String origin \u003d \"[\" + StringUtils.join(\n+            source.getPropertySources(key), \", \") +\"]\";\n         final String generic \u003d FS_S3A_PREFIX + stripped;\n-        LOG.debug(\"Updating {}\", generic);\n-        dest.set(generic, value, key);\n+        LOG.debug(\"Updating {} from {}\", generic, origin);\n+        dest.set(generic, value, key + \" via \" + origin);\n       }\n     }\n     return dest;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static Configuration propagateBucketOptions(Configuration source,\n      String bucket) {\n\n    Preconditions.checkArgument(StringUtils.isNotEmpty(bucket), \"bucket\");\n    final String bucketPrefix \u003d FS_S3A_BUCKET_PREFIX + bucket +\u0027.\u0027;\n    LOG.debug(\"Propagating entries under {}\", bucketPrefix);\n    final Configuration dest \u003d new Configuration(source);\n    for (Map.Entry\u003cString, String\u003e entry : source) {\n      final String key \u003d entry.getKey();\n      // get the (unexpanded) value.\n      final String value \u003d entry.getValue();\n      if (!key.startsWith(bucketPrefix) || bucketPrefix.equals(key)) {\n        continue;\n      }\n      // there\u0027s a bucket prefix, so strip it\n      final String stripped \u003d key.substring(bucketPrefix.length());\n      if (stripped.startsWith(\"bucket.\") || \"impl\".equals(stripped)) {\n        //tell user off\n        LOG.debug(\"Ignoring bucket option {}\", key);\n      }  else {\n        // propagate the value, building a new origin field.\n        // to track overwrites, the generic key is overwritten even if\n        // already matches the new one.\n        String origin \u003d \"[\" + StringUtils.join(\n            source.getPropertySources(key), \", \") +\"]\";\n        final String generic \u003d FS_S3A_PREFIX + stripped;\n        LOG.debug(\"Updating {} from {}\", generic, origin);\n        dest.set(generic, value, key + \" via \" + origin);\n      }\n    }\n    return dest;\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AUtils.java",
      "extendedDetails": {}
    },
    "e648b6e1382336af69434dfbf9161bced3caa244": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-13336 S3A to support per-bucket configuration. Contributed by Steve Loughran\n",
      "commitDate": "11/01/17 9:25 AM",
      "commitName": "e648b6e1382336af69434dfbf9161bced3caa244",
      "commitAuthor": "Steve Loughran",
      "diff": "@@ -0,0 +1,30 @@\n+  public static Configuration propagateBucketOptions(Configuration source,\n+      String bucket) {\n+\n+    Preconditions.checkArgument(StringUtils.isNotEmpty(bucket), \"bucket\");\n+    final String bucketPrefix \u003d FS_S3A_BUCKET_PREFIX + bucket +\u0027.\u0027;\n+    LOG.debug(\"Propagating entries under {}\", bucketPrefix);\n+    final Configuration dest \u003d new Configuration(source);\n+    for (Map.Entry\u003cString, String\u003e entry : source) {\n+      final String key \u003d entry.getKey();\n+      // get the (unexpanded) value.\n+      final String value \u003d entry.getValue();\n+      if (!key.startsWith(bucketPrefix) || bucketPrefix.equals(key)) {\n+        continue;\n+      }\n+      // there\u0027s a bucket prefix, so strip it\n+      final String stripped \u003d key.substring(bucketPrefix.length());\n+      if (stripped.startsWith(\"bucket.\") || \"impl\".equals(stripped)) {\n+        //tell user off\n+        LOG.debug(\"Ignoring bucket option {}\", key);\n+      }  else {\n+        // propagate the value, building a new origin field.\n+        // to track overwrites, the generic key is overwritten even if\n+        // already matches the new one.\n+        final String generic \u003d FS_S3A_PREFIX + stripped;\n+        LOG.debug(\"Updating {}\", generic);\n+        dest.set(generic, value, key);\n+      }\n+    }\n+    return dest;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public static Configuration propagateBucketOptions(Configuration source,\n      String bucket) {\n\n    Preconditions.checkArgument(StringUtils.isNotEmpty(bucket), \"bucket\");\n    final String bucketPrefix \u003d FS_S3A_BUCKET_PREFIX + bucket +\u0027.\u0027;\n    LOG.debug(\"Propagating entries under {}\", bucketPrefix);\n    final Configuration dest \u003d new Configuration(source);\n    for (Map.Entry\u003cString, String\u003e entry : source) {\n      final String key \u003d entry.getKey();\n      // get the (unexpanded) value.\n      final String value \u003d entry.getValue();\n      if (!key.startsWith(bucketPrefix) || bucketPrefix.equals(key)) {\n        continue;\n      }\n      // there\u0027s a bucket prefix, so strip it\n      final String stripped \u003d key.substring(bucketPrefix.length());\n      if (stripped.startsWith(\"bucket.\") || \"impl\".equals(stripped)) {\n        //tell user off\n        LOG.debug(\"Ignoring bucket option {}\", key);\n      }  else {\n        // propagate the value, building a new origin field.\n        // to track overwrites, the generic key is overwritten even if\n        // already matches the new one.\n        final String generic \u003d FS_S3A_PREFIX + stripped;\n        LOG.debug(\"Updating {}\", generic);\n        dest.set(generic, value, key);\n      }\n    }\n    return dest;\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AUtils.java"
    }
  }
}