{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FSEditLogAsync.java",
  "functionName": "enqueueEdit",
  "functionId": "enqueueEdit___edit-Edit",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSEditLogAsync.java",
  "functionStartLine": 180,
  "functionEndLine": 217,
  "numCommitsSeen": 6,
  "timeTaken": 1992,
  "changeHistory": [
    "8e54da1511e78477c1d4655d5ff0a69d0330869f",
    "2151716832ad14932dd65b1a4e47e64d8d6cd767"
  ],
  "changeHistoryShort": {
    "8e54da1511e78477c1d4655d5ff0a69d0330869f": "Ybodychange",
    "2151716832ad14932dd65b1a4e47e64d8d6cd767": "Yintroduced"
  },
  "changeHistoryDetails": {
    "8e54da1511e78477c1d4655d5ff0a69d0330869f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13051. Fix dead lock during async editlog rolling if edit queue is full. Contributed by Daryn Sharp.\n",
      "commitDate": "10/09/18 10:34 PM",
      "commitName": "8e54da1511e78477c1d4655d5ff0a69d0330869f",
      "commitAuthor": "Xiao Chen",
      "commitDateOld": "06/09/18 2:48 PM",
      "commitNameOld": "eca1a4bfe952fc184fe90dde50bac9b0e5293568",
      "commitAuthorOld": "Giovanni Matteo Fumarola",
      "daysBetweenCommits": 4.32,
      "commitsBetweenForRepo": 29,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,15 +1,38 @@\n   private void enqueueEdit(Edit edit) {\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"logEdit \" + edit);\n     }\n     try {\n-      if (!editPendingQ.offer(edit, 1, TimeUnit.SECONDS)) {\n+      // not checking for overflow yet to avoid penalizing performance of\n+      // the common case.  if there is persistent overflow, a mutex will be\n+      // use to throttle contention on the queue.\n+      if (!editPendingQ.offer(edit)) {\n         Preconditions.checkState(\n             isSyncThreadAlive(), \"sync thread is not alive\");\n-        editPendingQ.put(edit);\n+        if (Thread.holdsLock(this)) {\n+          // if queue is full, synchronized caller must immediately relinquish\n+          // the monitor before re-offering to avoid deadlock with sync thread\n+          // which needs the monitor to write transactions.\n+          int permits \u003d overflowMutex.drainPermits();\n+          try {\n+            do {\n+              this.wait(1000); // will be notified by next logSync.\n+            } while (!editPendingQ.offer(edit));\n+          } finally {\n+            overflowMutex.release(permits);\n+          }\n+        } else {\n+          // mutex will throttle contention during persistent overflow.\n+          overflowMutex.acquire();\n+          try {\n+            editPendingQ.put(edit);\n+          } finally {\n+            overflowMutex.release();\n+          }\n+        }\n       }\n     } catch (Throwable t) {\n       // should never happen!  failure to enqueue an edit is fatal\n       terminate(t);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void enqueueEdit(Edit edit) {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"logEdit \" + edit);\n    }\n    try {\n      // not checking for overflow yet to avoid penalizing performance of\n      // the common case.  if there is persistent overflow, a mutex will be\n      // use to throttle contention on the queue.\n      if (!editPendingQ.offer(edit)) {\n        Preconditions.checkState(\n            isSyncThreadAlive(), \"sync thread is not alive\");\n        if (Thread.holdsLock(this)) {\n          // if queue is full, synchronized caller must immediately relinquish\n          // the monitor before re-offering to avoid deadlock with sync thread\n          // which needs the monitor to write transactions.\n          int permits \u003d overflowMutex.drainPermits();\n          try {\n            do {\n              this.wait(1000); // will be notified by next logSync.\n            } while (!editPendingQ.offer(edit));\n          } finally {\n            overflowMutex.release(permits);\n          }\n        } else {\n          // mutex will throttle contention during persistent overflow.\n          overflowMutex.acquire();\n          try {\n            editPendingQ.put(edit);\n          } finally {\n            overflowMutex.release();\n          }\n        }\n      }\n    } catch (Throwable t) {\n      // should never happen!  failure to enqueue an edit is fatal\n      terminate(t);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSEditLogAsync.java",
      "extendedDetails": {}
    },
    "2151716832ad14932dd65b1a4e47e64d8d6cd767": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-7964. Add support for async edit logging. Contributed by Daryn Sharp.\n",
      "commitDate": "29/02/16 3:34 PM",
      "commitName": "2151716832ad14932dd65b1a4e47e64d8d6cd767",
      "commitAuthor": "Jing Zhao",
      "diff": "@@ -0,0 +1,15 @@\n+  private void enqueueEdit(Edit edit) {\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(\"logEdit \" + edit);\n+    }\n+    try {\n+      if (!editPendingQ.offer(edit, 1, TimeUnit.SECONDS)) {\n+        Preconditions.checkState(\n+            isSyncThreadAlive(), \"sync thread is not alive\");\n+        editPendingQ.put(edit);\n+      }\n+    } catch (Throwable t) {\n+      // should never happen!  failure to enqueue an edit is fatal\n+      terminate(t);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void enqueueEdit(Edit edit) {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"logEdit \" + edit);\n    }\n    try {\n      if (!editPendingQ.offer(edit, 1, TimeUnit.SECONDS)) {\n        Preconditions.checkState(\n            isSyncThreadAlive(), \"sync thread is not alive\");\n        editPendingQ.put(edit);\n      }\n    } catch (Throwable t) {\n      // should never happen!  failure to enqueue an edit is fatal\n      terminate(t);\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSEditLogAsync.java"
    }
  }
}