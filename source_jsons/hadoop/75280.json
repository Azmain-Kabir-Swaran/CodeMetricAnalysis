{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ZKFailoverController.java",
  "functionName": "doGracefulFailover",
  "functionId": "doGracefulFailover",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ha/ZKFailoverController.java",
  "functionStartLine": 640,
  "functionEndLine": 718,
  "numCommitsSeen": 35,
  "timeTaken": 1744,
  "changeHistory": [
    "6d92aa7c30439d78deb68cc3186a67557544681f",
    "49dfad942970459297f72632ed8dfd353e0c86de",
    "9d5799553fea81920edfab611e5d485a97841848"
  ],
  "changeHistoryShort": {
    "6d92aa7c30439d78deb68cc3186a67557544681f": "Ybodychange",
    "49dfad942970459297f72632ed8dfd353e0c86de": "Ybodychange",
    "9d5799553fea81920edfab611e5d485a97841848": "Yintroduced"
  },
  "changeHistoryDetails": {
    "6d92aa7c30439d78deb68cc3186a67557544681f": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16579. Upgrade to Curator 4.2.0 and ZooKeeper 3.5.5 (#1656). Contributed by Norbert Kalmár, Mate Szalay-Beko\n\n* HADOOP-16579 - Upgrade to Apache Curator 4.2.0 and ZooKeeper 3.5.5\r\n\r\n- Add a static initializer for the unit tests using ZooKeeper to enable\r\nthe four-letter-words diagnostic telnet commands. (this is an interface\r\nthat become disabled by default, so to keep the ZooKeeper 3.4.x behavior\r\nwe enabled it for the tests)\r\n- Also fix ZKFailoverController to look for relevant fail-over ActiveAttempt\r\nrecords. The new ZooKeeper seems to respond quicker during the fail-over\r\ntests than the ZooKeeper, so we made sure to catch all the relevant records\r\nby adding a new parameter to ZKFailoverontroller.waitForActiveAttempt().\r\n\r\nCo-authored-by: Norbert Kalmár \u003cnkalmar@cloudera.com\u003e",
      "commitDate": "18/10/19 1:26 PM",
      "commitName": "6d92aa7c30439d78deb68cc3186a67557544681f",
      "commitAuthor": "Mate Szalay-Beko",
      "commitDateOld": "25/02/19 2:35 PM",
      "commitNameOld": "a6ab37192a90e5ee868376b42be226e00cce31d8",
      "commitAuthorOld": "Konstantin V Shvachko",
      "daysBetweenCommits": 234.91,
      "commitsBetweenForRepo": 1816,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,78 +1,79 @@\n   private void doGracefulFailover()\n       throws ServiceFailedException, IOException, InterruptedException {\n     int timeout \u003d FailoverController.getGracefulFenceTimeout(conf) * 2;\n     \n     // Phase 1: pre-flight checks\n     checkEligibleForFailover();\n     \n     // Phase 2: determine old/current active node. Check that we\u0027re not\n     // ourselves active, etc.\n     HAServiceTarget oldActive \u003d getCurrentActive();\n     if (oldActive \u003d\u003d null) {\n       // No node is currently active. So, if we aren\u0027t already\n       // active ourselves by means of a normal election, then there\u0027s\n       // probably something preventing us from becoming active.\n       throw new ServiceFailedException(\n           \"No other node is currently active.\");\n     }\n     \n     if (oldActive.getAddress().equals(localTarget.getAddress())) {\n       LOG.info(\"Local node \" + localTarget + \" is already active. \" +\n           \"No need to failover. Returning success.\");\n       return;\n     }\n \n     // Phase 2b: get the other nodes\n     List\u003cHAServiceTarget\u003e otherNodes \u003d getAllOtherNodes();\n     List\u003cZKFCProtocol\u003e otherZkfcs \u003d new ArrayList\u003cZKFCProtocol\u003e(otherNodes.size());\n \n     // Phase 3: ask the other nodes to yield from the election.\n+    long st \u003d System.nanoTime();\n     HAServiceTarget activeNode \u003d null;\n     for (HAServiceTarget remote : otherNodes) {\n       // same location, same node - may not always be \u003d\u003d equality\n       if (remote.getAddress().equals(oldActive.getAddress())) {\n         activeNode \u003d remote;\n         continue;\n       }\n       otherZkfcs.add(cedeRemoteActive(remote, timeout));\n     }\n \n     assert\n       activeNode !\u003d null : \"Active node does not match any known remote node\";\n \n     // Phase 3b: ask the old active to yield\n     otherZkfcs.add(cedeRemoteActive(activeNode, timeout));\n \n     // Phase 4: wait for the normal election to make the local node\n     // active.\n-    ActiveAttemptRecord attempt \u003d waitForActiveAttempt(timeout + 60000);\n+    ActiveAttemptRecord attempt \u003d waitForActiveAttempt(timeout + 60000, st);\n     \n     if (attempt \u003d\u003d null) {\n       // We didn\u0027t even make an attempt to become active.\n       synchronized(this) {\n         if (lastHealthState !\u003d State.SERVICE_HEALTHY) {\n           throw new ServiceFailedException(\"Unable to become active. \" +\n             \"Service became unhealthy while trying to failover.\");          \n         }\n       }\n       \n       throw new ServiceFailedException(\"Unable to become active. \" +\n           \"Local node did not get an opportunity to do so from ZooKeeper, \" +\n           \"or the local node took too long to transition to active.\");\n     }\n \n     // Phase 5. At this point, we made some attempt to become active. So we\n     // can tell the old active to rejoin if it wants. This allows a quick\n     // fail-back if we immediately crash.\n     for (ZKFCProtocol zkfc : otherZkfcs) {\n       zkfc.cedeActive(-1);\n     }\n \n     if (attempt.succeeded) {\n       LOG.info(\"Successfully became active. \" + attempt.status);\n     } else {\n       // Propagate failure\n       String msg \u003d \"Failed to become active. \" + attempt.status;\n       throw new ServiceFailedException(msg);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void doGracefulFailover()\n      throws ServiceFailedException, IOException, InterruptedException {\n    int timeout \u003d FailoverController.getGracefulFenceTimeout(conf) * 2;\n    \n    // Phase 1: pre-flight checks\n    checkEligibleForFailover();\n    \n    // Phase 2: determine old/current active node. Check that we\u0027re not\n    // ourselves active, etc.\n    HAServiceTarget oldActive \u003d getCurrentActive();\n    if (oldActive \u003d\u003d null) {\n      // No node is currently active. So, if we aren\u0027t already\n      // active ourselves by means of a normal election, then there\u0027s\n      // probably something preventing us from becoming active.\n      throw new ServiceFailedException(\n          \"No other node is currently active.\");\n    }\n    \n    if (oldActive.getAddress().equals(localTarget.getAddress())) {\n      LOG.info(\"Local node \" + localTarget + \" is already active. \" +\n          \"No need to failover. Returning success.\");\n      return;\n    }\n\n    // Phase 2b: get the other nodes\n    List\u003cHAServiceTarget\u003e otherNodes \u003d getAllOtherNodes();\n    List\u003cZKFCProtocol\u003e otherZkfcs \u003d new ArrayList\u003cZKFCProtocol\u003e(otherNodes.size());\n\n    // Phase 3: ask the other nodes to yield from the election.\n    long st \u003d System.nanoTime();\n    HAServiceTarget activeNode \u003d null;\n    for (HAServiceTarget remote : otherNodes) {\n      // same location, same node - may not always be \u003d\u003d equality\n      if (remote.getAddress().equals(oldActive.getAddress())) {\n        activeNode \u003d remote;\n        continue;\n      }\n      otherZkfcs.add(cedeRemoteActive(remote, timeout));\n    }\n\n    assert\n      activeNode !\u003d null : \"Active node does not match any known remote node\";\n\n    // Phase 3b: ask the old active to yield\n    otherZkfcs.add(cedeRemoteActive(activeNode, timeout));\n\n    // Phase 4: wait for the normal election to make the local node\n    // active.\n    ActiveAttemptRecord attempt \u003d waitForActiveAttempt(timeout + 60000, st);\n    \n    if (attempt \u003d\u003d null) {\n      // We didn\u0027t even make an attempt to become active.\n      synchronized(this) {\n        if (lastHealthState !\u003d State.SERVICE_HEALTHY) {\n          throw new ServiceFailedException(\"Unable to become active. \" +\n            \"Service became unhealthy while trying to failover.\");          \n        }\n      }\n      \n      throw new ServiceFailedException(\"Unable to become active. \" +\n          \"Local node did not get an opportunity to do so from ZooKeeper, \" +\n          \"or the local node took too long to transition to active.\");\n    }\n\n    // Phase 5. At this point, we made some attempt to become active. So we\n    // can tell the old active to rejoin if it wants. This allows a quick\n    // fail-back if we immediately crash.\n    for (ZKFCProtocol zkfc : otherZkfcs) {\n      zkfc.cedeActive(-1);\n    }\n\n    if (attempt.succeeded) {\n      LOG.info(\"Successfully became active. \" + attempt.status);\n    } else {\n      // Propagate failure\n      String msg \u003d \"Failed to become active. \" + attempt.status;\n      throw new ServiceFailedException(msg);\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ha/ZKFailoverController.java",
      "extendedDetails": {}
    },
    "49dfad942970459297f72632ed8dfd353e0c86de": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6440. Support more than 2 NameNodes. Contributed by Jesse Yates.\n",
      "commitDate": "23/06/15 5:26 PM",
      "commitName": "49dfad942970459297f72632ed8dfd353e0c86de",
      "commitAuthor": "Aaron T. Myers",
      "commitDateOld": "08/06/15 9:57 PM",
      "commitNameOld": "927577c87ca19e8b5b75722f78e2def6d9386576",
      "commitAuthorOld": "Xiaoyu Yao",
      "daysBetweenCommits": 14.81,
      "commitsBetweenForRepo": 87,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,61 +1,78 @@\n   private void doGracefulFailover()\n       throws ServiceFailedException, IOException, InterruptedException {\n     int timeout \u003d FailoverController.getGracefulFenceTimeout(conf) * 2;\n     \n     // Phase 1: pre-flight checks\n     checkEligibleForFailover();\n     \n     // Phase 2: determine old/current active node. Check that we\u0027re not\n     // ourselves active, etc.\n     HAServiceTarget oldActive \u003d getCurrentActive();\n     if (oldActive \u003d\u003d null) {\n       // No node is currently active. So, if we aren\u0027t already\n       // active ourselves by means of a normal election, then there\u0027s\n       // probably something preventing us from becoming active.\n       throw new ServiceFailedException(\n           \"No other node is currently active.\");\n     }\n     \n     if (oldActive.getAddress().equals(localTarget.getAddress())) {\n       LOG.info(\"Local node \" + localTarget + \" is already active. \" +\n           \"No need to failover. Returning success.\");\n       return;\n     }\n-    \n-    // Phase 3: ask the old active to yield from the election.\n-    LOG.info(\"Asking \" + oldActive + \" to cede its active state for \" +\n-        timeout + \"ms\");\n-    ZKFCProtocol oldZkfc \u003d oldActive.getZKFCProxy(conf, timeout);\n-    oldZkfc.cedeActive(timeout);\n+\n+    // Phase 2b: get the other nodes\n+    List\u003cHAServiceTarget\u003e otherNodes \u003d getAllOtherNodes();\n+    List\u003cZKFCProtocol\u003e otherZkfcs \u003d new ArrayList\u003cZKFCProtocol\u003e(otherNodes.size());\n+\n+    // Phase 3: ask the other nodes to yield from the election.\n+    HAServiceTarget activeNode \u003d null;\n+    for (HAServiceTarget remote : otherNodes) {\n+      // same location, same node - may not always be \u003d\u003d equality\n+      if (remote.getAddress().equals(oldActive.getAddress())) {\n+        activeNode \u003d remote;\n+        continue;\n+      }\n+      otherZkfcs.add(cedeRemoteActive(remote, timeout));\n+    }\n+\n+    assert\n+      activeNode !\u003d null : \"Active node does not match any known remote node\";\n+\n+    // Phase 3b: ask the old active to yield\n+    otherZkfcs.add(cedeRemoteActive(activeNode, timeout));\n \n     // Phase 4: wait for the normal election to make the local node\n     // active.\n     ActiveAttemptRecord attempt \u003d waitForActiveAttempt(timeout + 60000);\n     \n     if (attempt \u003d\u003d null) {\n       // We didn\u0027t even make an attempt to become active.\n       synchronized(this) {\n         if (lastHealthState !\u003d State.SERVICE_HEALTHY) {\n           throw new ServiceFailedException(\"Unable to become active. \" +\n             \"Service became unhealthy while trying to failover.\");          \n         }\n       }\n       \n       throw new ServiceFailedException(\"Unable to become active. \" +\n           \"Local node did not get an opportunity to do so from ZooKeeper, \" +\n           \"or the local node took too long to transition to active.\");\n     }\n \n     // Phase 5. At this point, we made some attempt to become active. So we\n     // can tell the old active to rejoin if it wants. This allows a quick\n     // fail-back if we immediately crash.\n-    oldZkfc.cedeActive(-1);\n-    \n+    for (ZKFCProtocol zkfc : otherZkfcs) {\n+      zkfc.cedeActive(-1);\n+    }\n+\n     if (attempt.succeeded) {\n       LOG.info(\"Successfully became active. \" + attempt.status);\n     } else {\n       // Propagate failure\n       String msg \u003d \"Failed to become active. \" + attempt.status;\n       throw new ServiceFailedException(msg);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void doGracefulFailover()\n      throws ServiceFailedException, IOException, InterruptedException {\n    int timeout \u003d FailoverController.getGracefulFenceTimeout(conf) * 2;\n    \n    // Phase 1: pre-flight checks\n    checkEligibleForFailover();\n    \n    // Phase 2: determine old/current active node. Check that we\u0027re not\n    // ourselves active, etc.\n    HAServiceTarget oldActive \u003d getCurrentActive();\n    if (oldActive \u003d\u003d null) {\n      // No node is currently active. So, if we aren\u0027t already\n      // active ourselves by means of a normal election, then there\u0027s\n      // probably something preventing us from becoming active.\n      throw new ServiceFailedException(\n          \"No other node is currently active.\");\n    }\n    \n    if (oldActive.getAddress().equals(localTarget.getAddress())) {\n      LOG.info(\"Local node \" + localTarget + \" is already active. \" +\n          \"No need to failover. Returning success.\");\n      return;\n    }\n\n    // Phase 2b: get the other nodes\n    List\u003cHAServiceTarget\u003e otherNodes \u003d getAllOtherNodes();\n    List\u003cZKFCProtocol\u003e otherZkfcs \u003d new ArrayList\u003cZKFCProtocol\u003e(otherNodes.size());\n\n    // Phase 3: ask the other nodes to yield from the election.\n    HAServiceTarget activeNode \u003d null;\n    for (HAServiceTarget remote : otherNodes) {\n      // same location, same node - may not always be \u003d\u003d equality\n      if (remote.getAddress().equals(oldActive.getAddress())) {\n        activeNode \u003d remote;\n        continue;\n      }\n      otherZkfcs.add(cedeRemoteActive(remote, timeout));\n    }\n\n    assert\n      activeNode !\u003d null : \"Active node does not match any known remote node\";\n\n    // Phase 3b: ask the old active to yield\n    otherZkfcs.add(cedeRemoteActive(activeNode, timeout));\n\n    // Phase 4: wait for the normal election to make the local node\n    // active.\n    ActiveAttemptRecord attempt \u003d waitForActiveAttempt(timeout + 60000);\n    \n    if (attempt \u003d\u003d null) {\n      // We didn\u0027t even make an attempt to become active.\n      synchronized(this) {\n        if (lastHealthState !\u003d State.SERVICE_HEALTHY) {\n          throw new ServiceFailedException(\"Unable to become active. \" +\n            \"Service became unhealthy while trying to failover.\");          \n        }\n      }\n      \n      throw new ServiceFailedException(\"Unable to become active. \" +\n          \"Local node did not get an opportunity to do so from ZooKeeper, \" +\n          \"or the local node took too long to transition to active.\");\n    }\n\n    // Phase 5. At this point, we made some attempt to become active. So we\n    // can tell the old active to rejoin if it wants. This allows a quick\n    // fail-back if we immediately crash.\n    for (ZKFCProtocol zkfc : otherZkfcs) {\n      zkfc.cedeActive(-1);\n    }\n\n    if (attempt.succeeded) {\n      LOG.info(\"Successfully became active. \" + attempt.status);\n    } else {\n      // Propagate failure\n      String msg \u003d \"Failed to become active. \" + attempt.status;\n      throw new ServiceFailedException(msg);\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ha/ZKFailoverController.java",
      "extendedDetails": {}
    },
    "9d5799553fea81920edfab611e5d485a97841848": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-8279. Allow manual failover to be invoked when auto-failover is enabled. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-3042@1333288 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/05/12 6:56 PM",
      "commitName": "9d5799553fea81920edfab611e5d485a97841848",
      "commitAuthor": "Todd Lipcon",
      "diff": "@@ -0,0 +1,61 @@\n+  private void doGracefulFailover()\n+      throws ServiceFailedException, IOException, InterruptedException {\n+    int timeout \u003d FailoverController.getGracefulFenceTimeout(conf) * 2;\n+    \n+    // Phase 1: pre-flight checks\n+    checkEligibleForFailover();\n+    \n+    // Phase 2: determine old/current active node. Check that we\u0027re not\n+    // ourselves active, etc.\n+    HAServiceTarget oldActive \u003d getCurrentActive();\n+    if (oldActive \u003d\u003d null) {\n+      // No node is currently active. So, if we aren\u0027t already\n+      // active ourselves by means of a normal election, then there\u0027s\n+      // probably something preventing us from becoming active.\n+      throw new ServiceFailedException(\n+          \"No other node is currently active.\");\n+    }\n+    \n+    if (oldActive.getAddress().equals(localTarget.getAddress())) {\n+      LOG.info(\"Local node \" + localTarget + \" is already active. \" +\n+          \"No need to failover. Returning success.\");\n+      return;\n+    }\n+    \n+    // Phase 3: ask the old active to yield from the election.\n+    LOG.info(\"Asking \" + oldActive + \" to cede its active state for \" +\n+        timeout + \"ms\");\n+    ZKFCProtocol oldZkfc \u003d oldActive.getZKFCProxy(conf, timeout);\n+    oldZkfc.cedeActive(timeout);\n+\n+    // Phase 4: wait for the normal election to make the local node\n+    // active.\n+    ActiveAttemptRecord attempt \u003d waitForActiveAttempt(timeout + 60000);\n+    \n+    if (attempt \u003d\u003d null) {\n+      // We didn\u0027t even make an attempt to become active.\n+      synchronized(this) {\n+        if (lastHealthState !\u003d State.SERVICE_HEALTHY) {\n+          throw new ServiceFailedException(\"Unable to become active. \" +\n+            \"Service became unhealthy while trying to failover.\");          \n+        }\n+      }\n+      \n+      throw new ServiceFailedException(\"Unable to become active. \" +\n+          \"Local node did not get an opportunity to do so from ZooKeeper, \" +\n+          \"or the local node took too long to transition to active.\");\n+    }\n+\n+    // Phase 5. At this point, we made some attempt to become active. So we\n+    // can tell the old active to rejoin if it wants. This allows a quick\n+    // fail-back if we immediately crash.\n+    oldZkfc.cedeActive(-1);\n+    \n+    if (attempt.succeeded) {\n+      LOG.info(\"Successfully became active. \" + attempt.status);\n+    } else {\n+      // Propagate failure\n+      String msg \u003d \"Failed to become active. \" + attempt.status;\n+      throw new ServiceFailedException(msg);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void doGracefulFailover()\n      throws ServiceFailedException, IOException, InterruptedException {\n    int timeout \u003d FailoverController.getGracefulFenceTimeout(conf) * 2;\n    \n    // Phase 1: pre-flight checks\n    checkEligibleForFailover();\n    \n    // Phase 2: determine old/current active node. Check that we\u0027re not\n    // ourselves active, etc.\n    HAServiceTarget oldActive \u003d getCurrentActive();\n    if (oldActive \u003d\u003d null) {\n      // No node is currently active. So, if we aren\u0027t already\n      // active ourselves by means of a normal election, then there\u0027s\n      // probably something preventing us from becoming active.\n      throw new ServiceFailedException(\n          \"No other node is currently active.\");\n    }\n    \n    if (oldActive.getAddress().equals(localTarget.getAddress())) {\n      LOG.info(\"Local node \" + localTarget + \" is already active. \" +\n          \"No need to failover. Returning success.\");\n      return;\n    }\n    \n    // Phase 3: ask the old active to yield from the election.\n    LOG.info(\"Asking \" + oldActive + \" to cede its active state for \" +\n        timeout + \"ms\");\n    ZKFCProtocol oldZkfc \u003d oldActive.getZKFCProxy(conf, timeout);\n    oldZkfc.cedeActive(timeout);\n\n    // Phase 4: wait for the normal election to make the local node\n    // active.\n    ActiveAttemptRecord attempt \u003d waitForActiveAttempt(timeout + 60000);\n    \n    if (attempt \u003d\u003d null) {\n      // We didn\u0027t even make an attempt to become active.\n      synchronized(this) {\n        if (lastHealthState !\u003d State.SERVICE_HEALTHY) {\n          throw new ServiceFailedException(\"Unable to become active. \" +\n            \"Service became unhealthy while trying to failover.\");          \n        }\n      }\n      \n      throw new ServiceFailedException(\"Unable to become active. \" +\n          \"Local node did not get an opportunity to do so from ZooKeeper, \" +\n          \"or the local node took too long to transition to active.\");\n    }\n\n    // Phase 5. At this point, we made some attempt to become active. So we\n    // can tell the old active to rejoin if it wants. This allows a quick\n    // fail-back if we immediately crash.\n    oldZkfc.cedeActive(-1);\n    \n    if (attempt.succeeded) {\n      LOG.info(\"Successfully became active. \" + attempt.status);\n    } else {\n      // Propagate failure\n      String msg \u003d \"Failed to become active. \" + attempt.status;\n      throw new ServiceFailedException(msg);\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ha/ZKFailoverController.java"
    }
  }
}