{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ContainerImpl.java",
  "functionName": "transition",
  "functionId": "transition___container-ContainerImpl(modifiers-final)__event-ContainerEvent",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/container/ContainerImpl.java",
  "functionStartLine": 1631,
  "functionEndLine": 1671,
  "numCommitsSeen": 103,
  "timeTaken": 5640,
  "changeHistory": [
    "135941e00d762a417c3b4cc524cdc59b0d1810b1",
    "a5b27b3c678ad2f5cb8dbfa1b60ef5cd365f8bde",
    "e411dd6666041a4ea68ab34e734802271497ae6c",
    "3219b7b4ac7d12aee343f6ab2980b3357fc618b6",
    "4815d024c59cb029e2053d94c7aed33eb8053d3e",
    "2f163cd5cfaf8308f50b6a92c21498b78ada6953",
    "fe644bafe7b4fb5b07f7cf08a7d7044abbf55027",
    "3552c2b99dff4f21489ff284f9dcba40e897a1e5",
    "0f25a1bb52bc56661fd020a6ba82df99f8c6ef1f"
  ],
  "changeHistoryShort": {
    "135941e00d762a417c3b4cc524cdc59b0d1810b1": "Ybodychange",
    "a5b27b3c678ad2f5cb8dbfa1b60ef5cd365f8bde": "Ybodychange",
    "e411dd6666041a4ea68ab34e734802271497ae6c": "Ybodychange",
    "3219b7b4ac7d12aee343f6ab2980b3357fc618b6": "Ybodychange",
    "4815d024c59cb029e2053d94c7aed33eb8053d3e": "Ybodychange",
    "2f163cd5cfaf8308f50b6a92c21498b78ada6953": "Ybodychange",
    "fe644bafe7b4fb5b07f7cf08a7d7044abbf55027": "Ybodychange",
    "3552c2b99dff4f21489ff284f9dcba40e897a1e5": "Ybodychange",
    "0f25a1bb52bc56661fd020a6ba82df99f8c6ef1f": "Yintroduced"
  },
  "changeHistoryDetails": {
    "135941e00d762a417c3b4cc524cdc59b0d1810b1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8362.  Bugfix logic in container retries in node manager.\n            Contributed by Chandni Singh\n",
      "commitDate": "29/05/18 1:56 PM",
      "commitName": "135941e00d762a417c3b4cc524cdc59b0d1810b1",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "10/04/18 5:32 PM",
      "commitNameOld": "2bf9cc2c73944c9f7cde56714b8cf6995cfa539b",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 48.85,
      "commitsBetweenForRepo": 881,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,39 +1,41 @@\n     public ContainerState transition(final ContainerImpl container,\n         ContainerEvent event) {\n       ContainerExitEvent exitEvent \u003d (ContainerExitEvent) event;\n       container.exitCode \u003d exitEvent.getExitCode();\n       if (exitEvent.getDiagnosticInfo() !\u003d null) {\n         if (container.containerRetryContext.getRetryPolicy()\n             !\u003d ContainerRetryPolicy.NEVER_RETRY) {\n           container.addDiagnostics(\"Diagnostic message from attempt : \\n\");\n         }\n         container.addDiagnostics(exitEvent.getDiagnosticInfo() + \"\\n\");\n       }\n-\n       if (container.shouldRetry(container.exitCode)) {\n+        // Updates to the retry context should  be protected from concurrent\n+        // writes. It should only be called from this transition.\n+        container.retryPolicy.updateRetryContext(container.windowRetryContext);\n         container.storeRetryContext();\n         doRelaunch(container,\n             container.windowRetryContext.getRemainingRetries(),\n             container.containerRetryContext.getRetryInterval());\n         return ContainerState.RELAUNCHING;\n       } else if (container.canRollback()) {\n         // Rollback is possible only if the previous launch context is\n         // available.\n         container.addDiagnostics(\"Container Re-init Auto Rolled-Back.\");\n         LOG.info(\"Rolling back Container reInitialization for [\" +\n             container.getContainerId() + \"] !!\");\n         container.reInitContext \u003d\n             container.reInitContext.createContextForRollback();\n         container.metrics.rollbackContainerOnFailure();\n         container.metrics.reInitingContainer();\n         NMAuditLogger.logSuccess(container.user,\n             AuditConstants.START_CONTAINER_REINIT, \"ContainerImpl\",\n             container.containerId.getApplicationAttemptId().getApplicationId(),\n             container.containerId);\n         new KilledForReInitializationTransition().transition(container, event);\n         return ContainerState.SCHEDULED;\n       } else {\n         new ExitedWithFailureTransition(true).transition(container, event);\n         return ContainerState.EXITED_WITH_FAILURE;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public ContainerState transition(final ContainerImpl container,\n        ContainerEvent event) {\n      ContainerExitEvent exitEvent \u003d (ContainerExitEvent) event;\n      container.exitCode \u003d exitEvent.getExitCode();\n      if (exitEvent.getDiagnosticInfo() !\u003d null) {\n        if (container.containerRetryContext.getRetryPolicy()\n            !\u003d ContainerRetryPolicy.NEVER_RETRY) {\n          container.addDiagnostics(\"Diagnostic message from attempt : \\n\");\n        }\n        container.addDiagnostics(exitEvent.getDiagnosticInfo() + \"\\n\");\n      }\n      if (container.shouldRetry(container.exitCode)) {\n        // Updates to the retry context should  be protected from concurrent\n        // writes. It should only be called from this transition.\n        container.retryPolicy.updateRetryContext(container.windowRetryContext);\n        container.storeRetryContext();\n        doRelaunch(container,\n            container.windowRetryContext.getRemainingRetries(),\n            container.containerRetryContext.getRetryInterval());\n        return ContainerState.RELAUNCHING;\n      } else if (container.canRollback()) {\n        // Rollback is possible only if the previous launch context is\n        // available.\n        container.addDiagnostics(\"Container Re-init Auto Rolled-Back.\");\n        LOG.info(\"Rolling back Container reInitialization for [\" +\n            container.getContainerId() + \"] !!\");\n        container.reInitContext \u003d\n            container.reInitContext.createContextForRollback();\n        container.metrics.rollbackContainerOnFailure();\n        container.metrics.reInitingContainer();\n        NMAuditLogger.logSuccess(container.user,\n            AuditConstants.START_CONTAINER_REINIT, \"ContainerImpl\",\n            container.containerId.getApplicationAttemptId().getApplicationId(),\n            container.containerId);\n        new KilledForReInitializationTransition().transition(container, event);\n        return ContainerState.SCHEDULED;\n      } else {\n        new ExitedWithFailureTransition(true).transition(container, event);\n        return ContainerState.EXITED_WITH_FAILURE;\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/container/ContainerImpl.java",
      "extendedDetails": {}
    },
    "a5b27b3c678ad2f5cb8dbfa1b60ef5cd365f8bde": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5015. Support sliding window retry capability for container restart. (Chandni Singh via wangda)\n\nChange-Id: I07addd3e4ba8d98456ee2ff1d5c540a38fe61dea\n",
      "commitDate": "13/03/18 5:55 PM",
      "commitName": "a5b27b3c678ad2f5cb8dbfa1b60ef5cd365f8bde",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "31/01/18 1:30 AM",
      "commitNameOld": "a5c1fc881e21ebf43da7ead5f3852808fce25492",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 41.64,
      "commitsBetweenForRepo": 285,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,51 +1,39 @@\n     public ContainerState transition(final ContainerImpl container,\n         ContainerEvent event) {\n       ContainerExitEvent exitEvent \u003d (ContainerExitEvent) event;\n       container.exitCode \u003d exitEvent.getExitCode();\n       if (exitEvent.getDiagnosticInfo() !\u003d null) {\n         if (container.containerRetryContext.getRetryPolicy()\n             !\u003d ContainerRetryPolicy.NEVER_RETRY) {\n-          int n \u003d container.containerRetryContext.getMaxRetries()\n-              - container.remainingRetryAttempts;\n-          container.addDiagnostics(\"Diagnostic message from attempt \"\n-              + n + \" : \", \"\\n\");\n+          container.addDiagnostics(\"Diagnostic message from attempt : \\n\");\n         }\n         container.addDiagnostics(exitEvent.getDiagnosticInfo() + \"\\n\");\n       }\n \n       if (container.shouldRetry(container.exitCode)) {\n-        if (container.remainingRetryAttempts \u003e 0) {\n-          container.remainingRetryAttempts--;\n-          try {\n-            container.stateStore.storeContainerRemainingRetryAttempts(\n-                container.getContainerId(), container.remainingRetryAttempts);\n-          } catch (IOException e) {\n-            LOG.warn(\n-                \"Unable to update remainingRetryAttempts in state store for \"\n-                    + container.getContainerId(), e);\n-          }\n-        }\n-        doRelaunch(container, container.remainingRetryAttempts,\n+        container.storeRetryContext();\n+        doRelaunch(container,\n+            container.windowRetryContext.getRemainingRetries(),\n             container.containerRetryContext.getRetryInterval());\n         return ContainerState.RELAUNCHING;\n       } else if (container.canRollback()) {\n         // Rollback is possible only if the previous launch context is\n         // available.\n         container.addDiagnostics(\"Container Re-init Auto Rolled-Back.\");\n         LOG.info(\"Rolling back Container reInitialization for [\" +\n             container.getContainerId() + \"] !!\");\n         container.reInitContext \u003d\n             container.reInitContext.createContextForRollback();\n         container.metrics.rollbackContainerOnFailure();\n         container.metrics.reInitingContainer();\n         NMAuditLogger.logSuccess(container.user,\n             AuditConstants.START_CONTAINER_REINIT, \"ContainerImpl\",\n             container.containerId.getApplicationAttemptId().getApplicationId(),\n             container.containerId);\n         new KilledForReInitializationTransition().transition(container, event);\n         return ContainerState.SCHEDULED;\n       } else {\n         new ExitedWithFailureTransition(true).transition(container, event);\n         return ContainerState.EXITED_WITH_FAILURE;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public ContainerState transition(final ContainerImpl container,\n        ContainerEvent event) {\n      ContainerExitEvent exitEvent \u003d (ContainerExitEvent) event;\n      container.exitCode \u003d exitEvent.getExitCode();\n      if (exitEvent.getDiagnosticInfo() !\u003d null) {\n        if (container.containerRetryContext.getRetryPolicy()\n            !\u003d ContainerRetryPolicy.NEVER_RETRY) {\n          container.addDiagnostics(\"Diagnostic message from attempt : \\n\");\n        }\n        container.addDiagnostics(exitEvent.getDiagnosticInfo() + \"\\n\");\n      }\n\n      if (container.shouldRetry(container.exitCode)) {\n        container.storeRetryContext();\n        doRelaunch(container,\n            container.windowRetryContext.getRemainingRetries(),\n            container.containerRetryContext.getRetryInterval());\n        return ContainerState.RELAUNCHING;\n      } else if (container.canRollback()) {\n        // Rollback is possible only if the previous launch context is\n        // available.\n        container.addDiagnostics(\"Container Re-init Auto Rolled-Back.\");\n        LOG.info(\"Rolling back Container reInitialization for [\" +\n            container.getContainerId() + \"] !!\");\n        container.reInitContext \u003d\n            container.reInitContext.createContextForRollback();\n        container.metrics.rollbackContainerOnFailure();\n        container.metrics.reInitingContainer();\n        NMAuditLogger.logSuccess(container.user,\n            AuditConstants.START_CONTAINER_REINIT, \"ContainerImpl\",\n            container.containerId.getApplicationAttemptId().getApplicationId(),\n            container.containerId);\n        new KilledForReInitializationTransition().transition(container, event);\n        return ContainerState.SCHEDULED;\n      } else {\n        new ExitedWithFailureTransition(true).transition(container, event);\n        return ContainerState.EXITED_WITH_FAILURE;\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/container/ContainerImpl.java",
      "extendedDetails": {}
    },
    "e411dd6666041a4ea68ab34e734802271497ae6c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7607. Remove the trailing duplicated timestamp in container diagnostics message. Contributed by Weiwei Yang.\n",
      "commitDate": "07/12/17 1:29 AM",
      "commitName": "e411dd6666041a4ea68ab34e734802271497ae6c",
      "commitAuthor": "Weiwei Yang",
      "commitDateOld": "06/11/17 1:30 PM",
      "commitNameOld": "a55d0738f1eba225c45578bbdabd0e5a6d6f5392",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 30.5,
      "commitsBetweenForRepo": 154,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,51 +1,51 @@\n     public ContainerState transition(final ContainerImpl container,\n         ContainerEvent event) {\n       ContainerExitEvent exitEvent \u003d (ContainerExitEvent) event;\n       container.exitCode \u003d exitEvent.getExitCode();\n       if (exitEvent.getDiagnosticInfo() !\u003d null) {\n         if (container.containerRetryContext.getRetryPolicy()\n             !\u003d ContainerRetryPolicy.NEVER_RETRY) {\n           int n \u003d container.containerRetryContext.getMaxRetries()\n               - container.remainingRetryAttempts;\n           container.addDiagnostics(\"Diagnostic message from attempt \"\n               + n + \" : \", \"\\n\");\n         }\n-        container.addDiagnostics(exitEvent.getDiagnosticInfo(), \"\\n\");\n+        container.addDiagnostics(exitEvent.getDiagnosticInfo() + \"\\n\");\n       }\n \n       if (container.shouldRetry(container.exitCode)) {\n         if (container.remainingRetryAttempts \u003e 0) {\n           container.remainingRetryAttempts--;\n           try {\n             container.stateStore.storeContainerRemainingRetryAttempts(\n                 container.getContainerId(), container.remainingRetryAttempts);\n           } catch (IOException e) {\n             LOG.warn(\n                 \"Unable to update remainingRetryAttempts in state store for \"\n                     + container.getContainerId(), e);\n           }\n         }\n         doRelaunch(container, container.remainingRetryAttempts,\n             container.containerRetryContext.getRetryInterval());\n         return ContainerState.RELAUNCHING;\n       } else if (container.canRollback()) {\n         // Rollback is possible only if the previous launch context is\n         // available.\n         container.addDiagnostics(\"Container Re-init Auto Rolled-Back.\");\n         LOG.info(\"Rolling back Container reInitialization for [\" +\n             container.getContainerId() + \"] !!\");\n         container.reInitContext \u003d\n             container.reInitContext.createContextForRollback();\n         container.metrics.rollbackContainerOnFailure();\n         container.metrics.reInitingContainer();\n         NMAuditLogger.logSuccess(container.user,\n             AuditConstants.START_CONTAINER_REINIT, \"ContainerImpl\",\n             container.containerId.getApplicationAttemptId().getApplicationId(),\n             container.containerId);\n         new KilledForReInitializationTransition().transition(container, event);\n         return ContainerState.SCHEDULED;\n       } else {\n         new ExitedWithFailureTransition(true).transition(container, event);\n         return ContainerState.EXITED_WITH_FAILURE;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public ContainerState transition(final ContainerImpl container,\n        ContainerEvent event) {\n      ContainerExitEvent exitEvent \u003d (ContainerExitEvent) event;\n      container.exitCode \u003d exitEvent.getExitCode();\n      if (exitEvent.getDiagnosticInfo() !\u003d null) {\n        if (container.containerRetryContext.getRetryPolicy()\n            !\u003d ContainerRetryPolicy.NEVER_RETRY) {\n          int n \u003d container.containerRetryContext.getMaxRetries()\n              - container.remainingRetryAttempts;\n          container.addDiagnostics(\"Diagnostic message from attempt \"\n              + n + \" : \", \"\\n\");\n        }\n        container.addDiagnostics(exitEvent.getDiagnosticInfo() + \"\\n\");\n      }\n\n      if (container.shouldRetry(container.exitCode)) {\n        if (container.remainingRetryAttempts \u003e 0) {\n          container.remainingRetryAttempts--;\n          try {\n            container.stateStore.storeContainerRemainingRetryAttempts(\n                container.getContainerId(), container.remainingRetryAttempts);\n          } catch (IOException e) {\n            LOG.warn(\n                \"Unable to update remainingRetryAttempts in state store for \"\n                    + container.getContainerId(), e);\n          }\n        }\n        doRelaunch(container, container.remainingRetryAttempts,\n            container.containerRetryContext.getRetryInterval());\n        return ContainerState.RELAUNCHING;\n      } else if (container.canRollback()) {\n        // Rollback is possible only if the previous launch context is\n        // available.\n        container.addDiagnostics(\"Container Re-init Auto Rolled-Back.\");\n        LOG.info(\"Rolling back Container reInitialization for [\" +\n            container.getContainerId() + \"] !!\");\n        container.reInitContext \u003d\n            container.reInitContext.createContextForRollback();\n        container.metrics.rollbackContainerOnFailure();\n        container.metrics.reInitingContainer();\n        NMAuditLogger.logSuccess(container.user,\n            AuditConstants.START_CONTAINER_REINIT, \"ContainerImpl\",\n            container.containerId.getApplicationAttemptId().getApplicationId(),\n            container.containerId);\n        new KilledForReInitializationTransition().transition(container, event);\n        return ContainerState.SCHEDULED;\n      } else {\n        new ExitedWithFailureTransition(true).transition(container, event);\n        return ContainerState.EXITED_WITH_FAILURE;\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/container/ContainerImpl.java",
      "extendedDetails": {}
    },
    "3219b7b4ac7d12aee343f6ab2980b3357fc618b6": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4597. Introduce ContainerScheduler and a SCHEDULED state to NodeManager container lifecycle. (asuresh)\n",
      "commitDate": "15/11/16 7:56 AM",
      "commitName": "3219b7b4ac7d12aee343f6ab2980b3357fc618b6",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "01/11/16 2:21 AM",
      "commitNameOld": "310aa4686eb697f0700a71d33106514c404dab1b",
      "commitAuthorOld": "Varun Saxena",
      "daysBetweenCommits": 14.27,
      "commitsBetweenForRepo": 134,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,51 +1,51 @@\n     public ContainerState transition(final ContainerImpl container,\n         ContainerEvent event) {\n       ContainerExitEvent exitEvent \u003d (ContainerExitEvent) event;\n       container.exitCode \u003d exitEvent.getExitCode();\n       if (exitEvent.getDiagnosticInfo() !\u003d null) {\n         if (container.containerRetryContext.getRetryPolicy()\n             !\u003d ContainerRetryPolicy.NEVER_RETRY) {\n           int n \u003d container.containerRetryContext.getMaxRetries()\n               - container.remainingRetryAttempts;\n           container.addDiagnostics(\"Diagnostic message from attempt \"\n               + n + \" : \", \"\\n\");\n         }\n         container.addDiagnostics(exitEvent.getDiagnosticInfo(), \"\\n\");\n       }\n \n       if (container.shouldRetry(container.exitCode)) {\n         if (container.remainingRetryAttempts \u003e 0) {\n           container.remainingRetryAttempts--;\n           try {\n             container.stateStore.storeContainerRemainingRetryAttempts(\n                 container.getContainerId(), container.remainingRetryAttempts);\n           } catch (IOException e) {\n             LOG.warn(\n                 \"Unable to update remainingRetryAttempts in state store for \"\n                     + container.getContainerId(), e);\n           }\n         }\n         doRelaunch(container, container.remainingRetryAttempts,\n             container.containerRetryContext.getRetryInterval());\n         return ContainerState.RELAUNCHING;\n       } else if (container.canRollback()) {\n         // Rollback is possible only if the previous launch context is\n         // available.\n         container.addDiagnostics(\"Container Re-init Auto Rolled-Back.\");\n         LOG.info(\"Rolling back Container reInitialization for [\" +\n             container.getContainerId() + \"] !!\");\n         container.reInitContext \u003d\n             container.reInitContext.createContextForRollback();\n         container.metrics.rollbackContainerOnFailure();\n         container.metrics.reInitingContainer();\n         NMAuditLogger.logSuccess(container.user,\n             AuditConstants.START_CONTAINER_REINIT, \"ContainerImpl\",\n             container.containerId.getApplicationAttemptId().getApplicationId(),\n             container.containerId);\n         new KilledForReInitializationTransition().transition(container, event);\n-        return ContainerState.LOCALIZED;\n+        return ContainerState.SCHEDULED;\n       } else {\n         new ExitedWithFailureTransition(true).transition(container, event);\n         return ContainerState.EXITED_WITH_FAILURE;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public ContainerState transition(final ContainerImpl container,\n        ContainerEvent event) {\n      ContainerExitEvent exitEvent \u003d (ContainerExitEvent) event;\n      container.exitCode \u003d exitEvent.getExitCode();\n      if (exitEvent.getDiagnosticInfo() !\u003d null) {\n        if (container.containerRetryContext.getRetryPolicy()\n            !\u003d ContainerRetryPolicy.NEVER_RETRY) {\n          int n \u003d container.containerRetryContext.getMaxRetries()\n              - container.remainingRetryAttempts;\n          container.addDiagnostics(\"Diagnostic message from attempt \"\n              + n + \" : \", \"\\n\");\n        }\n        container.addDiagnostics(exitEvent.getDiagnosticInfo(), \"\\n\");\n      }\n\n      if (container.shouldRetry(container.exitCode)) {\n        if (container.remainingRetryAttempts \u003e 0) {\n          container.remainingRetryAttempts--;\n          try {\n            container.stateStore.storeContainerRemainingRetryAttempts(\n                container.getContainerId(), container.remainingRetryAttempts);\n          } catch (IOException e) {\n            LOG.warn(\n                \"Unable to update remainingRetryAttempts in state store for \"\n                    + container.getContainerId(), e);\n          }\n        }\n        doRelaunch(container, container.remainingRetryAttempts,\n            container.containerRetryContext.getRetryInterval());\n        return ContainerState.RELAUNCHING;\n      } else if (container.canRollback()) {\n        // Rollback is possible only if the previous launch context is\n        // available.\n        container.addDiagnostics(\"Container Re-init Auto Rolled-Back.\");\n        LOG.info(\"Rolling back Container reInitialization for [\" +\n            container.getContainerId() + \"] !!\");\n        container.reInitContext \u003d\n            container.reInitContext.createContextForRollback();\n        container.metrics.rollbackContainerOnFailure();\n        container.metrics.reInitingContainer();\n        NMAuditLogger.logSuccess(container.user,\n            AuditConstants.START_CONTAINER_REINIT, \"ContainerImpl\",\n            container.containerId.getApplicationAttemptId().getApplicationId(),\n            container.containerId);\n        new KilledForReInitializationTransition().transition(container, event);\n        return ContainerState.SCHEDULED;\n      } else {\n        new ExitedWithFailureTransition(true).transition(container, event);\n        return ContainerState.EXITED_WITH_FAILURE;\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/container/ContainerImpl.java",
      "extendedDetails": {}
    },
    "4815d024c59cb029e2053d94c7aed33eb8053d3e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5609. Expose upgrade and restart API in ContainerManagementProtocol. Contributed by Arun Suresh\n",
      "commitDate": "26/09/16 8:46 AM",
      "commitName": "4815d024c59cb029e2053d94c7aed33eb8053d3e",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "26/09/16 8:36 AM",
      "commitNameOld": "2f163cd5cfaf8308f50b6a92c21498b78ada6953",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,45 +1,51 @@\n     public ContainerState transition(final ContainerImpl container,\n         ContainerEvent event) {\n       ContainerExitEvent exitEvent \u003d (ContainerExitEvent) event;\n       container.exitCode \u003d exitEvent.getExitCode();\n       if (exitEvent.getDiagnosticInfo() !\u003d null) {\n         if (container.containerRetryContext.getRetryPolicy()\n             !\u003d ContainerRetryPolicy.NEVER_RETRY) {\n           int n \u003d container.containerRetryContext.getMaxRetries()\n               - container.remainingRetryAttempts;\n           container.addDiagnostics(\"Diagnostic message from attempt \"\n               + n + \" : \", \"\\n\");\n         }\n         container.addDiagnostics(exitEvent.getDiagnosticInfo(), \"\\n\");\n       }\n \n       if (container.shouldRetry(container.exitCode)) {\n         if (container.remainingRetryAttempts \u003e 0) {\n           container.remainingRetryAttempts--;\n           try {\n             container.stateStore.storeContainerRemainingRetryAttempts(\n                 container.getContainerId(), container.remainingRetryAttempts);\n           } catch (IOException e) {\n             LOG.warn(\n                 \"Unable to update remainingRetryAttempts in state store for \"\n                     + container.getContainerId(), e);\n           }\n         }\n         doRelaunch(container, container.remainingRetryAttempts,\n             container.containerRetryContext.getRetryInterval());\n         return ContainerState.RELAUNCHING;\n       } else if (container.canRollback()) {\n         // Rollback is possible only if the previous launch context is\n         // available.\n         container.addDiagnostics(\"Container Re-init Auto Rolled-Back.\");\n         LOG.info(\"Rolling back Container reInitialization for [\" +\n             container.getContainerId() + \"] !!\");\n         container.reInitContext \u003d\n             container.reInitContext.createContextForRollback();\n+        container.metrics.rollbackContainerOnFailure();\n+        container.metrics.reInitingContainer();\n+        NMAuditLogger.logSuccess(container.user,\n+            AuditConstants.START_CONTAINER_REINIT, \"ContainerImpl\",\n+            container.containerId.getApplicationAttemptId().getApplicationId(),\n+            container.containerId);\n         new KilledForReInitializationTransition().transition(container, event);\n         return ContainerState.LOCALIZED;\n       } else {\n         new ExitedWithFailureTransition(true).transition(container, event);\n         return ContainerState.EXITED_WITH_FAILURE;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public ContainerState transition(final ContainerImpl container,\n        ContainerEvent event) {\n      ContainerExitEvent exitEvent \u003d (ContainerExitEvent) event;\n      container.exitCode \u003d exitEvent.getExitCode();\n      if (exitEvent.getDiagnosticInfo() !\u003d null) {\n        if (container.containerRetryContext.getRetryPolicy()\n            !\u003d ContainerRetryPolicy.NEVER_RETRY) {\n          int n \u003d container.containerRetryContext.getMaxRetries()\n              - container.remainingRetryAttempts;\n          container.addDiagnostics(\"Diagnostic message from attempt \"\n              + n + \" : \", \"\\n\");\n        }\n        container.addDiagnostics(exitEvent.getDiagnosticInfo(), \"\\n\");\n      }\n\n      if (container.shouldRetry(container.exitCode)) {\n        if (container.remainingRetryAttempts \u003e 0) {\n          container.remainingRetryAttempts--;\n          try {\n            container.stateStore.storeContainerRemainingRetryAttempts(\n                container.getContainerId(), container.remainingRetryAttempts);\n          } catch (IOException e) {\n            LOG.warn(\n                \"Unable to update remainingRetryAttempts in state store for \"\n                    + container.getContainerId(), e);\n          }\n        }\n        doRelaunch(container, container.remainingRetryAttempts,\n            container.containerRetryContext.getRetryInterval());\n        return ContainerState.RELAUNCHING;\n      } else if (container.canRollback()) {\n        // Rollback is possible only if the previous launch context is\n        // available.\n        container.addDiagnostics(\"Container Re-init Auto Rolled-Back.\");\n        LOG.info(\"Rolling back Container reInitialization for [\" +\n            container.getContainerId() + \"] !!\");\n        container.reInitContext \u003d\n            container.reInitContext.createContextForRollback();\n        container.metrics.rollbackContainerOnFailure();\n        container.metrics.reInitingContainer();\n        NMAuditLogger.logSuccess(container.user,\n            AuditConstants.START_CONTAINER_REINIT, \"ContainerImpl\",\n            container.containerId.getApplicationAttemptId().getApplicationId(),\n            container.containerId);\n        new KilledForReInitializationTransition().transition(container, event);\n        return ContainerState.LOCALIZED;\n      } else {\n        new ExitedWithFailureTransition(true).transition(container, event);\n        return ContainerState.EXITED_WITH_FAILURE;\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/container/ContainerImpl.java",
      "extendedDetails": {}
    },
    "2f163cd5cfaf8308f50b6a92c21498b78ada6953": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"YARN-5609. Expose upgrade and restart API in ContainerManagementProtocol. Contributed by Arun Suresh\"\n\nThis reverts commit fe644bafe7b4fb5b07f7cf08a7d7044abbf55027.\n",
      "commitDate": "26/09/16 8:36 AM",
      "commitName": "2f163cd5cfaf8308f50b6a92c21498b78ada6953",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "26/09/16 7:41 AM",
      "commitNameOld": "fe644bafe7b4fb5b07f7cf08a7d7044abbf55027",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,51 +1,45 @@\n     public ContainerState transition(final ContainerImpl container,\n         ContainerEvent event) {\n       ContainerExitEvent exitEvent \u003d (ContainerExitEvent) event;\n       container.exitCode \u003d exitEvent.getExitCode();\n       if (exitEvent.getDiagnosticInfo() !\u003d null) {\n         if (container.containerRetryContext.getRetryPolicy()\n             !\u003d ContainerRetryPolicy.NEVER_RETRY) {\n           int n \u003d container.containerRetryContext.getMaxRetries()\n               - container.remainingRetryAttempts;\n           container.addDiagnostics(\"Diagnostic message from attempt \"\n               + n + \" : \", \"\\n\");\n         }\n         container.addDiagnostics(exitEvent.getDiagnosticInfo(), \"\\n\");\n       }\n \n       if (container.shouldRetry(container.exitCode)) {\n         if (container.remainingRetryAttempts \u003e 0) {\n           container.remainingRetryAttempts--;\n           try {\n             container.stateStore.storeContainerRemainingRetryAttempts(\n                 container.getContainerId(), container.remainingRetryAttempts);\n           } catch (IOException e) {\n             LOG.warn(\n                 \"Unable to update remainingRetryAttempts in state store for \"\n                     + container.getContainerId(), e);\n           }\n         }\n         doRelaunch(container, container.remainingRetryAttempts,\n             container.containerRetryContext.getRetryInterval());\n         return ContainerState.RELAUNCHING;\n       } else if (container.canRollback()) {\n         // Rollback is possible only if the previous launch context is\n         // available.\n         container.addDiagnostics(\"Container Re-init Auto Rolled-Back.\");\n         LOG.info(\"Rolling back Container reInitialization for [\" +\n             container.getContainerId() + \"] !!\");\n         container.reInitContext \u003d\n             container.reInitContext.createContextForRollback();\n-        container.metrics.rollbackContainerOnFailure();\n-        container.metrics.reInitingContainer();\n-        NMAuditLogger.logSuccess(container.user,\n-            AuditConstants.START_CONTAINER_REINIT, \"ContainerImpl\",\n-            container.containerId.getApplicationAttemptId().getApplicationId(),\n-            container.containerId);\n         new KilledForReInitializationTransition().transition(container, event);\n         return ContainerState.LOCALIZED;\n       } else {\n         new ExitedWithFailureTransition(true).transition(container, event);\n         return ContainerState.EXITED_WITH_FAILURE;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public ContainerState transition(final ContainerImpl container,\n        ContainerEvent event) {\n      ContainerExitEvent exitEvent \u003d (ContainerExitEvent) event;\n      container.exitCode \u003d exitEvent.getExitCode();\n      if (exitEvent.getDiagnosticInfo() !\u003d null) {\n        if (container.containerRetryContext.getRetryPolicy()\n            !\u003d ContainerRetryPolicy.NEVER_RETRY) {\n          int n \u003d container.containerRetryContext.getMaxRetries()\n              - container.remainingRetryAttempts;\n          container.addDiagnostics(\"Diagnostic message from attempt \"\n              + n + \" : \", \"\\n\");\n        }\n        container.addDiagnostics(exitEvent.getDiagnosticInfo(), \"\\n\");\n      }\n\n      if (container.shouldRetry(container.exitCode)) {\n        if (container.remainingRetryAttempts \u003e 0) {\n          container.remainingRetryAttempts--;\n          try {\n            container.stateStore.storeContainerRemainingRetryAttempts(\n                container.getContainerId(), container.remainingRetryAttempts);\n          } catch (IOException e) {\n            LOG.warn(\n                \"Unable to update remainingRetryAttempts in state store for \"\n                    + container.getContainerId(), e);\n          }\n        }\n        doRelaunch(container, container.remainingRetryAttempts,\n            container.containerRetryContext.getRetryInterval());\n        return ContainerState.RELAUNCHING;\n      } else if (container.canRollback()) {\n        // Rollback is possible only if the previous launch context is\n        // available.\n        container.addDiagnostics(\"Container Re-init Auto Rolled-Back.\");\n        LOG.info(\"Rolling back Container reInitialization for [\" +\n            container.getContainerId() + \"] !!\");\n        container.reInitContext \u003d\n            container.reInitContext.createContextForRollback();\n        new KilledForReInitializationTransition().transition(container, event);\n        return ContainerState.LOCALIZED;\n      } else {\n        new ExitedWithFailureTransition(true).transition(container, event);\n        return ContainerState.EXITED_WITH_FAILURE;\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/container/ContainerImpl.java",
      "extendedDetails": {}
    },
    "fe644bafe7b4fb5b07f7cf08a7d7044abbf55027": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5609. Expose upgrade and restart API in ContainerManagementProtocol. Contributed by Arun Suresh\n",
      "commitDate": "26/09/16 7:41 AM",
      "commitName": "fe644bafe7b4fb5b07f7cf08a7d7044abbf55027",
      "commitAuthor": "Jian He",
      "commitDateOld": "18/09/16 10:55 AM",
      "commitNameOld": "3552c2b99dff4f21489ff284f9dcba40e897a1e5",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 7.87,
      "commitsBetweenForRepo": 38,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,45 +1,51 @@\n     public ContainerState transition(final ContainerImpl container,\n         ContainerEvent event) {\n       ContainerExitEvent exitEvent \u003d (ContainerExitEvent) event;\n       container.exitCode \u003d exitEvent.getExitCode();\n       if (exitEvent.getDiagnosticInfo() !\u003d null) {\n         if (container.containerRetryContext.getRetryPolicy()\n             !\u003d ContainerRetryPolicy.NEVER_RETRY) {\n           int n \u003d container.containerRetryContext.getMaxRetries()\n               - container.remainingRetryAttempts;\n           container.addDiagnostics(\"Diagnostic message from attempt \"\n               + n + \" : \", \"\\n\");\n         }\n         container.addDiagnostics(exitEvent.getDiagnosticInfo(), \"\\n\");\n       }\n \n       if (container.shouldRetry(container.exitCode)) {\n         if (container.remainingRetryAttempts \u003e 0) {\n           container.remainingRetryAttempts--;\n           try {\n             container.stateStore.storeContainerRemainingRetryAttempts(\n                 container.getContainerId(), container.remainingRetryAttempts);\n           } catch (IOException e) {\n             LOG.warn(\n                 \"Unable to update remainingRetryAttempts in state store for \"\n                     + container.getContainerId(), e);\n           }\n         }\n         doRelaunch(container, container.remainingRetryAttempts,\n             container.containerRetryContext.getRetryInterval());\n         return ContainerState.RELAUNCHING;\n       } else if (container.canRollback()) {\n         // Rollback is possible only if the previous launch context is\n         // available.\n         container.addDiagnostics(\"Container Re-init Auto Rolled-Back.\");\n         LOG.info(\"Rolling back Container reInitialization for [\" +\n             container.getContainerId() + \"] !!\");\n         container.reInitContext \u003d\n             container.reInitContext.createContextForRollback();\n+        container.metrics.rollbackContainerOnFailure();\n+        container.metrics.reInitingContainer();\n+        NMAuditLogger.logSuccess(container.user,\n+            AuditConstants.START_CONTAINER_REINIT, \"ContainerImpl\",\n+            container.containerId.getApplicationAttemptId().getApplicationId(),\n+            container.containerId);\n         new KilledForReInitializationTransition().transition(container, event);\n         return ContainerState.LOCALIZED;\n       } else {\n         new ExitedWithFailureTransition(true).transition(container, event);\n         return ContainerState.EXITED_WITH_FAILURE;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public ContainerState transition(final ContainerImpl container,\n        ContainerEvent event) {\n      ContainerExitEvent exitEvent \u003d (ContainerExitEvent) event;\n      container.exitCode \u003d exitEvent.getExitCode();\n      if (exitEvent.getDiagnosticInfo() !\u003d null) {\n        if (container.containerRetryContext.getRetryPolicy()\n            !\u003d ContainerRetryPolicy.NEVER_RETRY) {\n          int n \u003d container.containerRetryContext.getMaxRetries()\n              - container.remainingRetryAttempts;\n          container.addDiagnostics(\"Diagnostic message from attempt \"\n              + n + \" : \", \"\\n\");\n        }\n        container.addDiagnostics(exitEvent.getDiagnosticInfo(), \"\\n\");\n      }\n\n      if (container.shouldRetry(container.exitCode)) {\n        if (container.remainingRetryAttempts \u003e 0) {\n          container.remainingRetryAttempts--;\n          try {\n            container.stateStore.storeContainerRemainingRetryAttempts(\n                container.getContainerId(), container.remainingRetryAttempts);\n          } catch (IOException e) {\n            LOG.warn(\n                \"Unable to update remainingRetryAttempts in state store for \"\n                    + container.getContainerId(), e);\n          }\n        }\n        doRelaunch(container, container.remainingRetryAttempts,\n            container.containerRetryContext.getRetryInterval());\n        return ContainerState.RELAUNCHING;\n      } else if (container.canRollback()) {\n        // Rollback is possible only if the previous launch context is\n        // available.\n        container.addDiagnostics(\"Container Re-init Auto Rolled-Back.\");\n        LOG.info(\"Rolling back Container reInitialization for [\" +\n            container.getContainerId() + \"] !!\");\n        container.reInitContext \u003d\n            container.reInitContext.createContextForRollback();\n        container.metrics.rollbackContainerOnFailure();\n        container.metrics.reInitingContainer();\n        NMAuditLogger.logSuccess(container.user,\n            AuditConstants.START_CONTAINER_REINIT, \"ContainerImpl\",\n            container.containerId.getApplicationAttemptId().getApplicationId(),\n            container.containerId);\n        new KilledForReInitializationTransition().transition(container, event);\n        return ContainerState.LOCALIZED;\n      } else {\n        new ExitedWithFailureTransition(true).transition(container, event);\n        return ContainerState.EXITED_WITH_FAILURE;\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/container/ContainerImpl.java",
      "extendedDetails": {}
    },
    "3552c2b99dff4f21489ff284f9dcba40e897a1e5": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5637. Changes in NodeManager to support Container rollback and commit. (asuresh)\n",
      "commitDate": "18/09/16 10:55 AM",
      "commitName": "3552c2b99dff4f21489ff284f9dcba40e897a1e5",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "15/09/16 7:15 AM",
      "commitNameOld": "40b5a59b726733df456330a26f03d5174cc0bc1c",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 3.15,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,57 +1,45 @@\n     public ContainerState transition(final ContainerImpl container,\n         ContainerEvent event) {\n       ContainerExitEvent exitEvent \u003d (ContainerExitEvent) event;\n       container.exitCode \u003d exitEvent.getExitCode();\n       if (exitEvent.getDiagnosticInfo() !\u003d null) {\n         if (container.containerRetryContext.getRetryPolicy()\n             !\u003d ContainerRetryPolicy.NEVER_RETRY) {\n           int n \u003d container.containerRetryContext.getMaxRetries()\n               - container.remainingRetryAttempts;\n           container.addDiagnostics(\"Diagnostic message from attempt \"\n               + n + \" : \", \"\\n\");\n         }\n         container.addDiagnostics(exitEvent.getDiagnosticInfo(), \"\\n\");\n       }\n \n       if (container.shouldRetry(container.exitCode)) {\n         if (container.remainingRetryAttempts \u003e 0) {\n           container.remainingRetryAttempts--;\n           try {\n             container.stateStore.storeContainerRemainingRetryAttempts(\n                 container.getContainerId(), container.remainingRetryAttempts);\n           } catch (IOException e) {\n             LOG.warn(\n                 \"Unable to update remainingRetryAttempts in state store for \"\n                     + container.getContainerId(), e);\n           }\n         }\n-        LOG.info(\"Relaunching Container \" + container.getContainerId()\n-            + \". Remaining retry attempts(after relaunch) : \"\n-            + container.remainingRetryAttempts\n-            + \". Interval between retries is \"\n-            + container.containerRetryContext.getRetryInterval() + \"ms\");\n-        container.wasLaunched  \u003d false;\n-        container.metrics.endRunningContainer();\n-        if (container.containerRetryContext.getRetryInterval() \u003d\u003d 0) {\n-          container.sendRelaunchEvent();\n-        } else {\n-          // wait for some time, then send launch event\n-          new Thread() {\n-            @Override\n-            public void run() {\n-              try {\n-                Thread.sleep(\n-                    container.containerRetryContext.getRetryInterval());\n-                container.sendRelaunchEvent();\n-              } catch (InterruptedException e) {\n-                return;\n-              }\n-            }\n-          }.start();\n-        }\n+        doRelaunch(container, container.remainingRetryAttempts,\n+            container.containerRetryContext.getRetryInterval());\n         return ContainerState.RELAUNCHING;\n+      } else if (container.canRollback()) {\n+        // Rollback is possible only if the previous launch context is\n+        // available.\n+        container.addDiagnostics(\"Container Re-init Auto Rolled-Back.\");\n+        LOG.info(\"Rolling back Container reInitialization for [\" +\n+            container.getContainerId() + \"] !!\");\n+        container.reInitContext \u003d\n+            container.reInitContext.createContextForRollback();\n+        new KilledForReInitializationTransition().transition(container, event);\n+        return ContainerState.LOCALIZED;\n       } else {\n         new ExitedWithFailureTransition(true).transition(container, event);\n         return ContainerState.EXITED_WITH_FAILURE;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public ContainerState transition(final ContainerImpl container,\n        ContainerEvent event) {\n      ContainerExitEvent exitEvent \u003d (ContainerExitEvent) event;\n      container.exitCode \u003d exitEvent.getExitCode();\n      if (exitEvent.getDiagnosticInfo() !\u003d null) {\n        if (container.containerRetryContext.getRetryPolicy()\n            !\u003d ContainerRetryPolicy.NEVER_RETRY) {\n          int n \u003d container.containerRetryContext.getMaxRetries()\n              - container.remainingRetryAttempts;\n          container.addDiagnostics(\"Diagnostic message from attempt \"\n              + n + \" : \", \"\\n\");\n        }\n        container.addDiagnostics(exitEvent.getDiagnosticInfo(), \"\\n\");\n      }\n\n      if (container.shouldRetry(container.exitCode)) {\n        if (container.remainingRetryAttempts \u003e 0) {\n          container.remainingRetryAttempts--;\n          try {\n            container.stateStore.storeContainerRemainingRetryAttempts(\n                container.getContainerId(), container.remainingRetryAttempts);\n          } catch (IOException e) {\n            LOG.warn(\n                \"Unable to update remainingRetryAttempts in state store for \"\n                    + container.getContainerId(), e);\n          }\n        }\n        doRelaunch(container, container.remainingRetryAttempts,\n            container.containerRetryContext.getRetryInterval());\n        return ContainerState.RELAUNCHING;\n      } else if (container.canRollback()) {\n        // Rollback is possible only if the previous launch context is\n        // available.\n        container.addDiagnostics(\"Container Re-init Auto Rolled-Back.\");\n        LOG.info(\"Rolling back Container reInitialization for [\" +\n            container.getContainerId() + \"] !!\");\n        container.reInitContext \u003d\n            container.reInitContext.createContextForRollback();\n        new KilledForReInitializationTransition().transition(container, event);\n        return ContainerState.LOCALIZED;\n      } else {\n        new ExitedWithFailureTransition(true).transition(container, event);\n        return ContainerState.EXITED_WITH_FAILURE;\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/container/ContainerImpl.java",
      "extendedDetails": {}
    },
    "0f25a1bb52bc56661fd020a6ba82df99f8c6ef1f": {
      "type": "Yintroduced",
      "commitMessage": "YARN-3998. Add support in the NodeManager to re-launch containers. Contributed by Jun Gong.\n",
      "commitDate": "29/04/16 3:39 AM",
      "commitName": "0f25a1bb52bc56661fd020a6ba82df99f8c6ef1f",
      "commitAuthor": "Varun Vasudev",
      "diff": "@@ -0,0 +1,57 @@\n+    public ContainerState transition(final ContainerImpl container,\n+        ContainerEvent event) {\n+      ContainerExitEvent exitEvent \u003d (ContainerExitEvent) event;\n+      container.exitCode \u003d exitEvent.getExitCode();\n+      if (exitEvent.getDiagnosticInfo() !\u003d null) {\n+        if (container.containerRetryContext.getRetryPolicy()\n+            !\u003d ContainerRetryPolicy.NEVER_RETRY) {\n+          int n \u003d container.containerRetryContext.getMaxRetries()\n+              - container.remainingRetryAttempts;\n+          container.addDiagnostics(\"Diagnostic message from attempt \"\n+              + n + \" : \", \"\\n\");\n+        }\n+        container.addDiagnostics(exitEvent.getDiagnosticInfo(), \"\\n\");\n+      }\n+\n+      if (container.shouldRetry(container.exitCode)) {\n+        if (container.remainingRetryAttempts \u003e 0) {\n+          container.remainingRetryAttempts--;\n+          try {\n+            container.stateStore.storeContainerRemainingRetryAttempts(\n+                container.getContainerId(), container.remainingRetryAttempts);\n+          } catch (IOException e) {\n+            LOG.warn(\n+                \"Unable to update remainingRetryAttempts in state store for \"\n+                + container.getContainerId(), e);\n+          }\n+        }\n+        LOG.info(\"Relaunching Container \" + container.getContainerId()\n+            + \". Remaining retry attempts(after relaunch) : \"\n+            + container.remainingRetryAttempts\n+            + \". Interval between retries is \"\n+            + container.containerRetryContext.getRetryInterval() + \"ms\");\n+        container.wasLaunched  \u003d false;\n+        container.metrics.endRunningContainer();\n+        if (container.containerRetryContext.getRetryInterval() \u003d\u003d 0) {\n+          container.sendRelaunchEvent();\n+        } else {\n+          // wait for some time, then send launch event\n+          new Thread() {\n+            @Override\n+            public void run() {\n+              try {\n+                Thread.sleep(\n+                    container.containerRetryContext.getRetryInterval());\n+                container.sendRelaunchEvent();\n+              } catch (InterruptedException e) {\n+                return;\n+              }\n+            }\n+          }.start();\n+        }\n+        return ContainerState.RELAUNCHING;\n+      } else {\n+        new ExitedWithFailureTransition(true).transition(container, event);\n+        return ContainerState.EXITED_WITH_FAILURE;\n+      }\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    public ContainerState transition(final ContainerImpl container,\n        ContainerEvent event) {\n      ContainerExitEvent exitEvent \u003d (ContainerExitEvent) event;\n      container.exitCode \u003d exitEvent.getExitCode();\n      if (exitEvent.getDiagnosticInfo() !\u003d null) {\n        if (container.containerRetryContext.getRetryPolicy()\n            !\u003d ContainerRetryPolicy.NEVER_RETRY) {\n          int n \u003d container.containerRetryContext.getMaxRetries()\n              - container.remainingRetryAttempts;\n          container.addDiagnostics(\"Diagnostic message from attempt \"\n              + n + \" : \", \"\\n\");\n        }\n        container.addDiagnostics(exitEvent.getDiagnosticInfo(), \"\\n\");\n      }\n\n      if (container.shouldRetry(container.exitCode)) {\n        if (container.remainingRetryAttempts \u003e 0) {\n          container.remainingRetryAttempts--;\n          try {\n            container.stateStore.storeContainerRemainingRetryAttempts(\n                container.getContainerId(), container.remainingRetryAttempts);\n          } catch (IOException e) {\n            LOG.warn(\n                \"Unable to update remainingRetryAttempts in state store for \"\n                + container.getContainerId(), e);\n          }\n        }\n        LOG.info(\"Relaunching Container \" + container.getContainerId()\n            + \". Remaining retry attempts(after relaunch) : \"\n            + container.remainingRetryAttempts\n            + \". Interval between retries is \"\n            + container.containerRetryContext.getRetryInterval() + \"ms\");\n        container.wasLaunched  \u003d false;\n        container.metrics.endRunningContainer();\n        if (container.containerRetryContext.getRetryInterval() \u003d\u003d 0) {\n          container.sendRelaunchEvent();\n        } else {\n          // wait for some time, then send launch event\n          new Thread() {\n            @Override\n            public void run() {\n              try {\n                Thread.sleep(\n                    container.containerRetryContext.getRetryInterval());\n                container.sendRelaunchEvent();\n              } catch (InterruptedException e) {\n                return;\n              }\n            }\n          }.start();\n        }\n        return ContainerState.RELAUNCHING;\n      } else {\n        new ExitedWithFailureTransition(true).transition(container, event);\n        return ContainerState.EXITED_WITH_FAILURE;\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/container/ContainerImpl.java"
    }
  }
}