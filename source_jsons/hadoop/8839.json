{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ErasureCodingPolicyManager.java",
  "functionName": "addPolicy",
  "functionId": "addPolicy___policy-ErasureCodingPolicy",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ErasureCodingPolicyManager.java",
  "functionStartLine": 295,
  "functionEndLine": 347,
  "numCommitsSeen": 34,
  "timeTaken": 6071,
  "changeHistory": [
    "c03024a5305bea1a40c87a4abc0793802bea5c75",
    "8d99648c203004045a9339ad27258092969145d6",
    "e565b5277d5b890dad107fe85e295a3907e4bfc1",
    "ce7cf66e5ed74c124afdb5a6902fbf297211cc04",
    "0f9af246e89e4ad3c4d7ff2c1d7ec9b397494a03",
    "2adf8bed712e6d770a0d53eea198d8911ae1a258",
    "200b11368d3954138a9bce128c8fa763b4a503a1",
    "a62be38a5e5d3a61dfb59054b3f5fd5b1b7053b3",
    "cb672a45a0bbd8950b9b5e304c2e03f516945903"
  ],
  "changeHistoryShort": {
    "c03024a5305bea1a40c87a4abc0793802bea5c75": "Ybodychange",
    "8d99648c203004045a9339ad27258092969145d6": "Ybodychange",
    "e565b5277d5b890dad107fe85e295a3907e4bfc1": "Ybodychange",
    "ce7cf66e5ed74c124afdb5a6902fbf297211cc04": "Ybodychange",
    "0f9af246e89e4ad3c4d7ff2c1d7ec9b397494a03": "Ybodychange",
    "2adf8bed712e6d770a0d53eea198d8911ae1a258": "Ymultichange(Yexceptionschange,Ybodychange)",
    "200b11368d3954138a9bce128c8fa763b4a503a1": "Ybodychange",
    "a62be38a5e5d3a61dfb59054b3f5fd5b1b7053b3": "Ymultichange(Yreturntypechange,Ybodychange)",
    "cb672a45a0bbd8950b9b5e304c2e03f516945903": "Yintroduced"
  },
  "changeHistoryDetails": {
    "c03024a5305bea1a40c87a4abc0793802bea5c75": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14113. EC : Add Configuration to restrict UserDefined Policies. Contributed by Ayush Saxena.\n",
      "commitDate": "06/12/18 4:50 AM",
      "commitName": "c03024a5305bea1a40c87a4abc0793802bea5c75",
      "commitAuthor": "Vinayakumar B",
      "commitDateOld": "03/12/18 10:01 AM",
      "commitNameOld": "dd5e7c6b7239a93f2391beaa11181e442a387db4",
      "commitAuthorOld": "Kitti Nanasi",
      "daysBetweenCommits": 2.78,
      "commitsBetweenForRepo": 21,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,48 +1,53 @@\n   public synchronized ErasureCodingPolicy addPolicy(\n       ErasureCodingPolicy policy) {\n+    if (!userDefinedAllowed) {\n+      throw new HadoopIllegalArgumentException(\n+          \"Addition of user defined erasure coding policy is disabled.\");\n+    }\n+\n     if (!CodecUtil.hasCodec(policy.getCodecName())) {\n       throw new HadoopIllegalArgumentException(\"Codec name \"\n           + policy.getCodecName() + \" is not supported\");\n     }\n \n     if (policy.getCellSize() \u003e maxCellSize) {\n       throw new HadoopIllegalArgumentException(\"Cell size \" +\n           policy.getCellSize() + \" should not exceed maximum \" +\n           maxCellSize + \" bytes\");\n     }\n \n     String assignedNewName \u003d ErasureCodingPolicy.composePolicyName(\n         policy.getSchema(), policy.getCellSize());\n     for (ErasureCodingPolicyInfo info : getPolicies()) {\n       final ErasureCodingPolicy p \u003d info.getPolicy();\n       if (p.getName().equals(assignedNewName)) {\n         LOG.info(\"The policy name \" + assignedNewName + \" already exists\");\n         return p;\n       }\n       if (p.getSchema().equals(policy.getSchema()) \u0026\u0026\n           p.getCellSize() \u003d\u003d policy.getCellSize()) {\n         LOG.info(\"A policy with same schema \"\n             + policy.getSchema().toString() + \" and cell size \"\n             + p.getCellSize() + \" already exists\");\n         return p;\n       }\n     }\n \n     if (getCurrentMaxPolicyID() \u003d\u003d ErasureCodeConstants.MAX_POLICY_ID) {\n       throw new HadoopIllegalArgumentException(\"Adding erasure coding \" +\n           \"policy failed because the number of policies stored in the \" +\n           \"system already reached the threshold, which is \" +\n           ErasureCodeConstants.MAX_POLICY_ID);\n     }\n \n     policy \u003d new ErasureCodingPolicy(assignedNewName, policy.getSchema(),\n         policy.getCellSize(), getNextAvailablePolicyID());\n     final ErasureCodingPolicyInfo pi \u003d new ErasureCodingPolicyInfo(policy);\n     this.policiesByName.put(policy.getName(), pi);\n     this.policiesByID.put(policy.getId(), pi);\n     allPolicies \u003d\n         policiesByName.values().toArray(new ErasureCodingPolicyInfo[0]);\n     allPersistedPolicies.put(policy.getId(),\n         new ErasureCodingPolicyInfo(policy));\n     return policy;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized ErasureCodingPolicy addPolicy(\n      ErasureCodingPolicy policy) {\n    if (!userDefinedAllowed) {\n      throw new HadoopIllegalArgumentException(\n          \"Addition of user defined erasure coding policy is disabled.\");\n    }\n\n    if (!CodecUtil.hasCodec(policy.getCodecName())) {\n      throw new HadoopIllegalArgumentException(\"Codec name \"\n          + policy.getCodecName() + \" is not supported\");\n    }\n\n    if (policy.getCellSize() \u003e maxCellSize) {\n      throw new HadoopIllegalArgumentException(\"Cell size \" +\n          policy.getCellSize() + \" should not exceed maximum \" +\n          maxCellSize + \" bytes\");\n    }\n\n    String assignedNewName \u003d ErasureCodingPolicy.composePolicyName(\n        policy.getSchema(), policy.getCellSize());\n    for (ErasureCodingPolicyInfo info : getPolicies()) {\n      final ErasureCodingPolicy p \u003d info.getPolicy();\n      if (p.getName().equals(assignedNewName)) {\n        LOG.info(\"The policy name \" + assignedNewName + \" already exists\");\n        return p;\n      }\n      if (p.getSchema().equals(policy.getSchema()) \u0026\u0026\n          p.getCellSize() \u003d\u003d policy.getCellSize()) {\n        LOG.info(\"A policy with same schema \"\n            + policy.getSchema().toString() + \" and cell size \"\n            + p.getCellSize() + \" already exists\");\n        return p;\n      }\n    }\n\n    if (getCurrentMaxPolicyID() \u003d\u003d ErasureCodeConstants.MAX_POLICY_ID) {\n      throw new HadoopIllegalArgumentException(\"Adding erasure coding \" +\n          \"policy failed because the number of policies stored in the \" +\n          \"system already reached the threshold, which is \" +\n          ErasureCodeConstants.MAX_POLICY_ID);\n    }\n\n    policy \u003d new ErasureCodingPolicy(assignedNewName, policy.getSchema(),\n        policy.getCellSize(), getNextAvailablePolicyID());\n    final ErasureCodingPolicyInfo pi \u003d new ErasureCodingPolicyInfo(policy);\n    this.policiesByName.put(policy.getName(), pi);\n    this.policiesByID.put(policy.getId(), pi);\n    allPolicies \u003d\n        policiesByName.values().toArray(new ErasureCodingPolicyInfo[0]);\n    allPersistedPolicies.put(policy.getId(),\n        new ErasureCodingPolicyInfo(policy));\n    return policy;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ErasureCodingPolicyManager.java",
      "extendedDetails": {}
    },
    "8d99648c203004045a9339ad27258092969145d6": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14039. ec -listPolicies doesn\u0027t show correct state for the default policy when the default is not RS(6,3). Contributed by Kitti Nanasi.\n\nSigned-off-by: Xiao Chen \u003cxiao@apache.org\u003e\n",
      "commitDate": "08/11/18 10:01 AM",
      "commitName": "8d99648c203004045a9339ad27258092969145d6",
      "commitAuthor": "Kitti Nanasi",
      "commitDateOld": "28/09/18 8:53 AM",
      "commitNameOld": "e2113500df2479dd2d8f1d8a37fdb2bb16463181",
      "commitAuthorOld": "Takanobu Asanuma",
      "daysBetweenCommits": 41.09,
      "commitsBetweenForRepo": 385,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,48 @@\n   public synchronized ErasureCodingPolicy addPolicy(\n       ErasureCodingPolicy policy) {\n     if (!CodecUtil.hasCodec(policy.getCodecName())) {\n       throw new HadoopIllegalArgumentException(\"Codec name \"\n           + policy.getCodecName() + \" is not supported\");\n     }\n \n     if (policy.getCellSize() \u003e maxCellSize) {\n       throw new HadoopIllegalArgumentException(\"Cell size \" +\n           policy.getCellSize() + \" should not exceed maximum \" +\n           maxCellSize + \" bytes\");\n     }\n \n     String assignedNewName \u003d ErasureCodingPolicy.composePolicyName(\n         policy.getSchema(), policy.getCellSize());\n     for (ErasureCodingPolicyInfo info : getPolicies()) {\n       final ErasureCodingPolicy p \u003d info.getPolicy();\n       if (p.getName().equals(assignedNewName)) {\n         LOG.info(\"The policy name \" + assignedNewName + \" already exists\");\n         return p;\n       }\n       if (p.getSchema().equals(policy.getSchema()) \u0026\u0026\n           p.getCellSize() \u003d\u003d policy.getCellSize()) {\n         LOG.info(\"A policy with same schema \"\n             + policy.getSchema().toString() + \" and cell size \"\n             + p.getCellSize() + \" already exists\");\n         return p;\n       }\n     }\n \n     if (getCurrentMaxPolicyID() \u003d\u003d ErasureCodeConstants.MAX_POLICY_ID) {\n       throw new HadoopIllegalArgumentException(\"Adding erasure coding \" +\n           \"policy failed because the number of policies stored in the \" +\n           \"system already reached the threshold, which is \" +\n           ErasureCodeConstants.MAX_POLICY_ID);\n     }\n \n     policy \u003d new ErasureCodingPolicy(assignedNewName, policy.getSchema(),\n         policy.getCellSize(), getNextAvailablePolicyID());\n     final ErasureCodingPolicyInfo pi \u003d new ErasureCodingPolicyInfo(policy);\n     this.policiesByName.put(policy.getName(), pi);\n     this.policiesByID.put(policy.getId(), pi);\n     allPolicies \u003d\n         policiesByName.values().toArray(new ErasureCodingPolicyInfo[0]);\n+    allPersistedPolicies.put(policy.getId(),\n+        new ErasureCodingPolicyInfo(policy));\n     return policy;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized ErasureCodingPolicy addPolicy(\n      ErasureCodingPolicy policy) {\n    if (!CodecUtil.hasCodec(policy.getCodecName())) {\n      throw new HadoopIllegalArgumentException(\"Codec name \"\n          + policy.getCodecName() + \" is not supported\");\n    }\n\n    if (policy.getCellSize() \u003e maxCellSize) {\n      throw new HadoopIllegalArgumentException(\"Cell size \" +\n          policy.getCellSize() + \" should not exceed maximum \" +\n          maxCellSize + \" bytes\");\n    }\n\n    String assignedNewName \u003d ErasureCodingPolicy.composePolicyName(\n        policy.getSchema(), policy.getCellSize());\n    for (ErasureCodingPolicyInfo info : getPolicies()) {\n      final ErasureCodingPolicy p \u003d info.getPolicy();\n      if (p.getName().equals(assignedNewName)) {\n        LOG.info(\"The policy name \" + assignedNewName + \" already exists\");\n        return p;\n      }\n      if (p.getSchema().equals(policy.getSchema()) \u0026\u0026\n          p.getCellSize() \u003d\u003d policy.getCellSize()) {\n        LOG.info(\"A policy with same schema \"\n            + policy.getSchema().toString() + \" and cell size \"\n            + p.getCellSize() + \" already exists\");\n        return p;\n      }\n    }\n\n    if (getCurrentMaxPolicyID() \u003d\u003d ErasureCodeConstants.MAX_POLICY_ID) {\n      throw new HadoopIllegalArgumentException(\"Adding erasure coding \" +\n          \"policy failed because the number of policies stored in the \" +\n          \"system already reached the threshold, which is \" +\n          ErasureCodeConstants.MAX_POLICY_ID);\n    }\n\n    policy \u003d new ErasureCodingPolicy(assignedNewName, policy.getSchema(),\n        policy.getCellSize(), getNextAvailablePolicyID());\n    final ErasureCodingPolicyInfo pi \u003d new ErasureCodingPolicyInfo(policy);\n    this.policiesByName.put(policy.getName(), pi);\n    this.policiesByID.put(policy.getId(), pi);\n    allPolicies \u003d\n        policiesByName.values().toArray(new ErasureCodingPolicyInfo[0]);\n    allPersistedPolicies.put(policy.getId(),\n        new ErasureCodingPolicyInfo(policy));\n    return policy;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ErasureCodingPolicyManager.java",
      "extendedDetails": {}
    },
    "e565b5277d5b890dad107fe85e295a3907e4bfc1": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12682. ECAdmin -listPolicies will always show SystemErasureCodingPolicies state as DISABLED.\n",
      "commitDate": "02/11/17 9:27 PM",
      "commitName": "e565b5277d5b890dad107fe85e295a3907e4bfc1",
      "commitAuthor": "Xiao Chen",
      "commitDateOld": "19/10/17 6:42 PM",
      "commitNameOld": "ce7cf66e5ed74c124afdb5a6902fbf297211cc04",
      "commitAuthorOld": "Kai Zheng",
      "daysBetweenCommits": 14.11,
      "commitsBetweenForRepo": 94,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,46 @@\n   public synchronized ErasureCodingPolicy addPolicy(\n       ErasureCodingPolicy policy) {\n-    // Set policy state into DISABLED when adding into Hadoop.\n-    policy.setState(ErasureCodingPolicyState.DISABLED);\n-\n     if (!CodecUtil.hasCodec(policy.getCodecName())) {\n       throw new HadoopIllegalArgumentException(\"Codec name \"\n           + policy.getCodecName() + \" is not supported\");\n     }\n \n     if (policy.getCellSize() \u003e maxCellSize) {\n       throw new HadoopIllegalArgumentException(\"Cell size \" +\n           policy.getCellSize() + \" should not exceed maximum \" +\n           maxCellSize + \" bytes\");\n     }\n \n     String assignedNewName \u003d ErasureCodingPolicy.composePolicyName(\n         policy.getSchema(), policy.getCellSize());\n-    for (ErasureCodingPolicy p : getPolicies()) {\n+    for (ErasureCodingPolicyInfo info : getPolicies()) {\n+      final ErasureCodingPolicy p \u003d info.getPolicy();\n       if (p.getName().equals(assignedNewName)) {\n         LOG.info(\"The policy name \" + assignedNewName + \" already exists\");\n         return p;\n       }\n       if (p.getSchema().equals(policy.getSchema()) \u0026\u0026\n           p.getCellSize() \u003d\u003d policy.getCellSize()) {\n         LOG.info(\"A policy with same schema \"\n             + policy.getSchema().toString() + \" and cell size \"\n             + p.getCellSize() + \" already exists\");\n         return p;\n       }\n     }\n \n     if (getCurrentMaxPolicyID() \u003d\u003d ErasureCodeConstants.MAX_POLICY_ID) {\n       throw new HadoopIllegalArgumentException(\"Adding erasure coding \" +\n           \"policy failed because the number of policies stored in the \" +\n           \"system already reached the threshold, which is \" +\n           ErasureCodeConstants.MAX_POLICY_ID);\n     }\n \n-    policy.setName(assignedNewName);\n-    policy.setId(getNextAvailablePolicyID());\n-    this.policiesByName.put(policy.getName(), policy);\n-    this.policiesByID.put(policy.getId(), policy);\n-    allPolicies \u003d policiesByName.values().toArray(new ErasureCodingPolicy[0]);\n+    policy \u003d new ErasureCodingPolicy(assignedNewName, policy.getSchema(),\n+        policy.getCellSize(), getNextAvailablePolicyID());\n+    final ErasureCodingPolicyInfo pi \u003d new ErasureCodingPolicyInfo(policy);\n+    this.policiesByName.put(policy.getName(), pi);\n+    this.policiesByID.put(policy.getId(), pi);\n+    allPolicies \u003d\n+        policiesByName.values().toArray(new ErasureCodingPolicyInfo[0]);\n     return policy;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized ErasureCodingPolicy addPolicy(\n      ErasureCodingPolicy policy) {\n    if (!CodecUtil.hasCodec(policy.getCodecName())) {\n      throw new HadoopIllegalArgumentException(\"Codec name \"\n          + policy.getCodecName() + \" is not supported\");\n    }\n\n    if (policy.getCellSize() \u003e maxCellSize) {\n      throw new HadoopIllegalArgumentException(\"Cell size \" +\n          policy.getCellSize() + \" should not exceed maximum \" +\n          maxCellSize + \" bytes\");\n    }\n\n    String assignedNewName \u003d ErasureCodingPolicy.composePolicyName(\n        policy.getSchema(), policy.getCellSize());\n    for (ErasureCodingPolicyInfo info : getPolicies()) {\n      final ErasureCodingPolicy p \u003d info.getPolicy();\n      if (p.getName().equals(assignedNewName)) {\n        LOG.info(\"The policy name \" + assignedNewName + \" already exists\");\n        return p;\n      }\n      if (p.getSchema().equals(policy.getSchema()) \u0026\u0026\n          p.getCellSize() \u003d\u003d policy.getCellSize()) {\n        LOG.info(\"A policy with same schema \"\n            + policy.getSchema().toString() + \" and cell size \"\n            + p.getCellSize() + \" already exists\");\n        return p;\n      }\n    }\n\n    if (getCurrentMaxPolicyID() \u003d\u003d ErasureCodeConstants.MAX_POLICY_ID) {\n      throw new HadoopIllegalArgumentException(\"Adding erasure coding \" +\n          \"policy failed because the number of policies stored in the \" +\n          \"system already reached the threshold, which is \" +\n          ErasureCodeConstants.MAX_POLICY_ID);\n    }\n\n    policy \u003d new ErasureCodingPolicy(assignedNewName, policy.getSchema(),\n        policy.getCellSize(), getNextAvailablePolicyID());\n    final ErasureCodingPolicyInfo pi \u003d new ErasureCodingPolicyInfo(policy);\n    this.policiesByName.put(policy.getName(), pi);\n    this.policiesByID.put(policy.getId(), pi);\n    allPolicies \u003d\n        policiesByName.values().toArray(new ErasureCodingPolicyInfo[0]);\n    return policy;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ErasureCodingPolicyManager.java",
      "extendedDetails": {}
    },
    "ce7cf66e5ed74c124afdb5a6902fbf297211cc04": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12448. Make sure user defined erasure coding policy ID will not overflow. Contributed by Huafeng Wang\n",
      "commitDate": "19/10/17 6:42 PM",
      "commitName": "ce7cf66e5ed74c124afdb5a6902fbf297211cc04",
      "commitAuthor": "Kai Zheng",
      "commitDateOld": "18/09/17 3:07 AM",
      "commitNameOld": "0f9af246e89e4ad3c4d7ff2c1d7ec9b397494a03",
      "commitAuthorOld": "Kai Zheng",
      "daysBetweenCommits": 31.65,
      "commitsBetweenForRepo": 250,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,46 @@\n   public synchronized ErasureCodingPolicy addPolicy(\n       ErasureCodingPolicy policy) {\n     // Set policy state into DISABLED when adding into Hadoop.\n     policy.setState(ErasureCodingPolicyState.DISABLED);\n \n     if (!CodecUtil.hasCodec(policy.getCodecName())) {\n       throw new HadoopIllegalArgumentException(\"Codec name \"\n           + policy.getCodecName() + \" is not supported\");\n     }\n \n     if (policy.getCellSize() \u003e maxCellSize) {\n       throw new HadoopIllegalArgumentException(\"Cell size \" +\n           policy.getCellSize() + \" should not exceed maximum \" +\n           maxCellSize + \" bytes\");\n     }\n \n     String assignedNewName \u003d ErasureCodingPolicy.composePolicyName(\n         policy.getSchema(), policy.getCellSize());\n     for (ErasureCodingPolicy p : getPolicies()) {\n       if (p.getName().equals(assignedNewName)) {\n         LOG.info(\"The policy name \" + assignedNewName + \" already exists\");\n         return p;\n       }\n       if (p.getSchema().equals(policy.getSchema()) \u0026\u0026\n           p.getCellSize() \u003d\u003d policy.getCellSize()) {\n         LOG.info(\"A policy with same schema \"\n             + policy.getSchema().toString() + \" and cell size \"\n             + p.getCellSize() + \" already exists\");\n         return p;\n       }\n     }\n+\n+    if (getCurrentMaxPolicyID() \u003d\u003d ErasureCodeConstants.MAX_POLICY_ID) {\n+      throw new HadoopIllegalArgumentException(\"Adding erasure coding \" +\n+          \"policy failed because the number of policies stored in the \" +\n+          \"system already reached the threshold, which is \" +\n+          ErasureCodeConstants.MAX_POLICY_ID);\n+    }\n+\n     policy.setName(assignedNewName);\n     policy.setId(getNextAvailablePolicyID());\n     this.policiesByName.put(policy.getName(), policy);\n     this.policiesByID.put(policy.getId(), policy);\n     allPolicies \u003d policiesByName.values().toArray(new ErasureCodingPolicy[0]);\n     return policy;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized ErasureCodingPolicy addPolicy(\n      ErasureCodingPolicy policy) {\n    // Set policy state into DISABLED when adding into Hadoop.\n    policy.setState(ErasureCodingPolicyState.DISABLED);\n\n    if (!CodecUtil.hasCodec(policy.getCodecName())) {\n      throw new HadoopIllegalArgumentException(\"Codec name \"\n          + policy.getCodecName() + \" is not supported\");\n    }\n\n    if (policy.getCellSize() \u003e maxCellSize) {\n      throw new HadoopIllegalArgumentException(\"Cell size \" +\n          policy.getCellSize() + \" should not exceed maximum \" +\n          maxCellSize + \" bytes\");\n    }\n\n    String assignedNewName \u003d ErasureCodingPolicy.composePolicyName(\n        policy.getSchema(), policy.getCellSize());\n    for (ErasureCodingPolicy p : getPolicies()) {\n      if (p.getName().equals(assignedNewName)) {\n        LOG.info(\"The policy name \" + assignedNewName + \" already exists\");\n        return p;\n      }\n      if (p.getSchema().equals(policy.getSchema()) \u0026\u0026\n          p.getCellSize() \u003d\u003d policy.getCellSize()) {\n        LOG.info(\"A policy with same schema \"\n            + policy.getSchema().toString() + \" and cell size \"\n            + p.getCellSize() + \" already exists\");\n        return p;\n      }\n    }\n\n    if (getCurrentMaxPolicyID() \u003d\u003d ErasureCodeConstants.MAX_POLICY_ID) {\n      throw new HadoopIllegalArgumentException(\"Adding erasure coding \" +\n          \"policy failed because the number of policies stored in the \" +\n          \"system already reached the threshold, which is \" +\n          ErasureCodeConstants.MAX_POLICY_ID);\n    }\n\n    policy.setName(assignedNewName);\n    policy.setId(getNextAvailablePolicyID());\n    this.policiesByName.put(policy.getName(), policy);\n    this.policiesByID.put(policy.getId(), policy);\n    allPolicies \u003d policiesByName.values().toArray(new ErasureCodingPolicy[0]);\n    return policy;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ErasureCodingPolicyManager.java",
      "extendedDetails": {}
    },
    "0f9af246e89e4ad3c4d7ff2c1d7ec9b397494a03": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12460. Make addErasureCodingPolicy an idempotent operation. Contributed by Sammi Chen\n",
      "commitDate": "18/09/17 3:07 AM",
      "commitName": "0f9af246e89e4ad3c4d7ff2c1d7ec9b397494a03",
      "commitAuthor": "Kai Zheng",
      "commitDateOld": "14/09/17 6:08 PM",
      "commitNameOld": "ae8f55b93243560bd891962d6c64320ddc62a7d7",
      "commitAuthorOld": "Kai Zheng",
      "daysBetweenCommits": 3.37,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,37 +1,38 @@\n   public synchronized ErasureCodingPolicy addPolicy(\n       ErasureCodingPolicy policy) {\n     // Set policy state into DISABLED when adding into Hadoop.\n     policy.setState(ErasureCodingPolicyState.DISABLED);\n \n     if (!CodecUtil.hasCodec(policy.getCodecName())) {\n       throw new HadoopIllegalArgumentException(\"Codec name \"\n           + policy.getCodecName() + \" is not supported\");\n     }\n \n     if (policy.getCellSize() \u003e maxCellSize) {\n       throw new HadoopIllegalArgumentException(\"Cell size \" +\n           policy.getCellSize() + \" should not exceed maximum \" +\n           maxCellSize + \" bytes\");\n     }\n \n     String assignedNewName \u003d ErasureCodingPolicy.composePolicyName(\n         policy.getSchema(), policy.getCellSize());\n     for (ErasureCodingPolicy p : getPolicies()) {\n       if (p.getName().equals(assignedNewName)) {\n-        throw new HadoopIllegalArgumentException(\"The policy name \" +\n-            assignedNewName + \" already exists\");\n+        LOG.info(\"The policy name \" + assignedNewName + \" already exists\");\n+        return p;\n       }\n       if (p.getSchema().equals(policy.getSchema()) \u0026\u0026\n           p.getCellSize() \u003d\u003d policy.getCellSize()) {\n-        throw new HadoopIllegalArgumentException(\"A policy with same schema \"\n+        LOG.info(\"A policy with same schema \"\n             + policy.getSchema().toString() + \" and cell size \"\n             + p.getCellSize() + \" already exists\");\n+        return p;\n       }\n     }\n     policy.setName(assignedNewName);\n     policy.setId(getNextAvailablePolicyID());\n     this.policiesByName.put(policy.getName(), policy);\n     this.policiesByID.put(policy.getId(), policy);\n     allPolicies \u003d policiesByName.values().toArray(new ErasureCodingPolicy[0]);\n     return policy;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized ErasureCodingPolicy addPolicy(\n      ErasureCodingPolicy policy) {\n    // Set policy state into DISABLED when adding into Hadoop.\n    policy.setState(ErasureCodingPolicyState.DISABLED);\n\n    if (!CodecUtil.hasCodec(policy.getCodecName())) {\n      throw new HadoopIllegalArgumentException(\"Codec name \"\n          + policy.getCodecName() + \" is not supported\");\n    }\n\n    if (policy.getCellSize() \u003e maxCellSize) {\n      throw new HadoopIllegalArgumentException(\"Cell size \" +\n          policy.getCellSize() + \" should not exceed maximum \" +\n          maxCellSize + \" bytes\");\n    }\n\n    String assignedNewName \u003d ErasureCodingPolicy.composePolicyName(\n        policy.getSchema(), policy.getCellSize());\n    for (ErasureCodingPolicy p : getPolicies()) {\n      if (p.getName().equals(assignedNewName)) {\n        LOG.info(\"The policy name \" + assignedNewName + \" already exists\");\n        return p;\n      }\n      if (p.getSchema().equals(policy.getSchema()) \u0026\u0026\n          p.getCellSize() \u003d\u003d policy.getCellSize()) {\n        LOG.info(\"A policy with same schema \"\n            + policy.getSchema().toString() + \" and cell size \"\n            + p.getCellSize() + \" already exists\");\n        return p;\n      }\n    }\n    policy.setName(assignedNewName);\n    policy.setId(getNextAvailablePolicyID());\n    this.policiesByName.put(policy.getName(), policy);\n    this.policiesByID.put(policy.getId(), policy);\n    allPolicies \u003d policiesByName.values().toArray(new ErasureCodingPolicy[0]);\n    return policy;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ErasureCodingPolicyManager.java",
      "extendedDetails": {}
    },
    "2adf8bed712e6d770a0d53eea198d8911ae1a258": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "HDFS-12402. Refactor ErasureCodingPolicyManager and related codes. Contributed by Sammi Chen\n",
      "commitDate": "07/09/17 5:38 AM",
      "commitName": "2adf8bed712e6d770a0d53eea198d8911ae1a258",
      "commitAuthor": "Kai Zheng",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "HDFS-12402. Refactor ErasureCodingPolicyManager and related codes. Contributed by Sammi Chen\n",
          "commitDate": "07/09/17 5:38 AM",
          "commitName": "2adf8bed712e6d770a0d53eea198d8911ae1a258",
          "commitAuthor": "Kai Zheng",
          "commitDateOld": "30/08/17 12:28 AM",
          "commitNameOld": "200b11368d3954138a9bce128c8fa763b4a503a1",
          "commitAuthorOld": "Rakesh Radhakrishnan",
          "daysBetweenCommits": 8.21,
          "commitsBetweenForRepo": 53,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,36 +1,37 @@\n-  public synchronized ErasureCodingPolicy addPolicy(ErasureCodingPolicy policy)\n-      throws IllegalECPolicyException {\n+  public synchronized ErasureCodingPolicy addPolicy(\n+      ErasureCodingPolicy policy) {\n     // Set policy state into DISABLED when adding into Hadoop.\n     policy.setState(ErasureCodingPolicyState.DISABLED);\n \n     if (!CodecUtil.hasCodec(policy.getCodecName())) {\n-      throw new IllegalECPolicyException(\"Codec name \"\n+      throw new HadoopIllegalArgumentException(\"Codec name \"\n           + policy.getCodecName() + \" is not supported\");\n     }\n \n     if (policy.getCellSize() \u003e maxCellSize) {\n-      throw new IllegalECPolicyException(\"Cell size \" + policy.getCellSize()\n-          + \" should not exceed maximum \" + maxCellSize + \" byte\");\n+      throw new HadoopIllegalArgumentException(\"Cell size \" +\n+          policy.getCellSize() + \" should not exceed maximum \" +\n+          maxCellSize + \" bytes\");\n     }\n \n     String assignedNewName \u003d ErasureCodingPolicy.composePolicyName(\n         policy.getSchema(), policy.getCellSize());\n     for (ErasureCodingPolicy p : getPolicies()) {\n       if (p.getName().equals(assignedNewName)) {\n-        throw new IllegalECPolicyException(\"The policy name \" + assignedNewName\n-            + \" already exists\");\n+        throw new HadoopIllegalArgumentException(\"The policy name \" +\n+            assignedNewName + \" already exists\");\n       }\n       if (p.getSchema().equals(policy.getSchema()) \u0026\u0026\n           p.getCellSize() \u003d\u003d policy.getCellSize()) {\n-        throw new IllegalECPolicyException(\"A policy with same schema \"\n+        throw new HadoopIllegalArgumentException(\"A policy with same schema \"\n             + policy.getSchema().toString() + \" and cell size \"\n-            + p.getCellSize() + \" is already exists\");\n+            + p.getCellSize() + \" already exists\");\n       }\n     }\n     policy.setName(assignedNewName);\n     policy.setId(getNextAvailablePolicyID());\n     this.policiesByName.put(policy.getName(), policy);\n     this.policiesByID.put(policy.getId(), policy);\n     allPolicies \u003d policiesByName.values().toArray(new ErasureCodingPolicy[0]);\n     return policy;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public synchronized ErasureCodingPolicy addPolicy(\n      ErasureCodingPolicy policy) {\n    // Set policy state into DISABLED when adding into Hadoop.\n    policy.setState(ErasureCodingPolicyState.DISABLED);\n\n    if (!CodecUtil.hasCodec(policy.getCodecName())) {\n      throw new HadoopIllegalArgumentException(\"Codec name \"\n          + policy.getCodecName() + \" is not supported\");\n    }\n\n    if (policy.getCellSize() \u003e maxCellSize) {\n      throw new HadoopIllegalArgumentException(\"Cell size \" +\n          policy.getCellSize() + \" should not exceed maximum \" +\n          maxCellSize + \" bytes\");\n    }\n\n    String assignedNewName \u003d ErasureCodingPolicy.composePolicyName(\n        policy.getSchema(), policy.getCellSize());\n    for (ErasureCodingPolicy p : getPolicies()) {\n      if (p.getName().equals(assignedNewName)) {\n        throw new HadoopIllegalArgumentException(\"The policy name \" +\n            assignedNewName + \" already exists\");\n      }\n      if (p.getSchema().equals(policy.getSchema()) \u0026\u0026\n          p.getCellSize() \u003d\u003d policy.getCellSize()) {\n        throw new HadoopIllegalArgumentException(\"A policy with same schema \"\n            + policy.getSchema().toString() + \" and cell size \"\n            + p.getCellSize() + \" already exists\");\n      }\n    }\n    policy.setName(assignedNewName);\n    policy.setId(getNextAvailablePolicyID());\n    this.policiesByName.put(policy.getName(), policy);\n    this.policiesByID.put(policy.getId(), policy);\n    allPolicies \u003d policiesByName.values().toArray(new ErasureCodingPolicy[0]);\n    return policy;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ErasureCodingPolicyManager.java",
          "extendedDetails": {
            "oldValue": "[IllegalECPolicyException]",
            "newValue": "[]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-12402. Refactor ErasureCodingPolicyManager and related codes. Contributed by Sammi Chen\n",
          "commitDate": "07/09/17 5:38 AM",
          "commitName": "2adf8bed712e6d770a0d53eea198d8911ae1a258",
          "commitAuthor": "Kai Zheng",
          "commitDateOld": "30/08/17 12:28 AM",
          "commitNameOld": "200b11368d3954138a9bce128c8fa763b4a503a1",
          "commitAuthorOld": "Rakesh Radhakrishnan",
          "daysBetweenCommits": 8.21,
          "commitsBetweenForRepo": 53,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,36 +1,37 @@\n-  public synchronized ErasureCodingPolicy addPolicy(ErasureCodingPolicy policy)\n-      throws IllegalECPolicyException {\n+  public synchronized ErasureCodingPolicy addPolicy(\n+      ErasureCodingPolicy policy) {\n     // Set policy state into DISABLED when adding into Hadoop.\n     policy.setState(ErasureCodingPolicyState.DISABLED);\n \n     if (!CodecUtil.hasCodec(policy.getCodecName())) {\n-      throw new IllegalECPolicyException(\"Codec name \"\n+      throw new HadoopIllegalArgumentException(\"Codec name \"\n           + policy.getCodecName() + \" is not supported\");\n     }\n \n     if (policy.getCellSize() \u003e maxCellSize) {\n-      throw new IllegalECPolicyException(\"Cell size \" + policy.getCellSize()\n-          + \" should not exceed maximum \" + maxCellSize + \" byte\");\n+      throw new HadoopIllegalArgumentException(\"Cell size \" +\n+          policy.getCellSize() + \" should not exceed maximum \" +\n+          maxCellSize + \" bytes\");\n     }\n \n     String assignedNewName \u003d ErasureCodingPolicy.composePolicyName(\n         policy.getSchema(), policy.getCellSize());\n     for (ErasureCodingPolicy p : getPolicies()) {\n       if (p.getName().equals(assignedNewName)) {\n-        throw new IllegalECPolicyException(\"The policy name \" + assignedNewName\n-            + \" already exists\");\n+        throw new HadoopIllegalArgumentException(\"The policy name \" +\n+            assignedNewName + \" already exists\");\n       }\n       if (p.getSchema().equals(policy.getSchema()) \u0026\u0026\n           p.getCellSize() \u003d\u003d policy.getCellSize()) {\n-        throw new IllegalECPolicyException(\"A policy with same schema \"\n+        throw new HadoopIllegalArgumentException(\"A policy with same schema \"\n             + policy.getSchema().toString() + \" and cell size \"\n-            + p.getCellSize() + \" is already exists\");\n+            + p.getCellSize() + \" already exists\");\n       }\n     }\n     policy.setName(assignedNewName);\n     policy.setId(getNextAvailablePolicyID());\n     this.policiesByName.put(policy.getName(), policy);\n     this.policiesByID.put(policy.getId(), policy);\n     allPolicies \u003d policiesByName.values().toArray(new ErasureCodingPolicy[0]);\n     return policy;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public synchronized ErasureCodingPolicy addPolicy(\n      ErasureCodingPolicy policy) {\n    // Set policy state into DISABLED when adding into Hadoop.\n    policy.setState(ErasureCodingPolicyState.DISABLED);\n\n    if (!CodecUtil.hasCodec(policy.getCodecName())) {\n      throw new HadoopIllegalArgumentException(\"Codec name \"\n          + policy.getCodecName() + \" is not supported\");\n    }\n\n    if (policy.getCellSize() \u003e maxCellSize) {\n      throw new HadoopIllegalArgumentException(\"Cell size \" +\n          policy.getCellSize() + \" should not exceed maximum \" +\n          maxCellSize + \" bytes\");\n    }\n\n    String assignedNewName \u003d ErasureCodingPolicy.composePolicyName(\n        policy.getSchema(), policy.getCellSize());\n    for (ErasureCodingPolicy p : getPolicies()) {\n      if (p.getName().equals(assignedNewName)) {\n        throw new HadoopIllegalArgumentException(\"The policy name \" +\n            assignedNewName + \" already exists\");\n      }\n      if (p.getSchema().equals(policy.getSchema()) \u0026\u0026\n          p.getCellSize() \u003d\u003d policy.getCellSize()) {\n        throw new HadoopIllegalArgumentException(\"A policy with same schema \"\n            + policy.getSchema().toString() + \" and cell size \"\n            + p.getCellSize() + \" already exists\");\n      }\n    }\n    policy.setName(assignedNewName);\n    policy.setId(getNextAvailablePolicyID());\n    this.policiesByName.put(policy.getName(), policy);\n    this.policiesByID.put(policy.getId(), policy);\n    allPolicies \u003d policiesByName.values().toArray(new ErasureCodingPolicy[0]);\n    return policy;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ErasureCodingPolicyManager.java",
          "extendedDetails": {}
        }
      ]
    },
    "200b11368d3954138a9bce128c8fa763b4a503a1": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12258. ec -listPolicies should list all policies in system, no matter it\u0027s enabled or disabled. Contributed by Wei Zhou.\n",
      "commitDate": "30/08/17 12:28 AM",
      "commitName": "200b11368d3954138a9bce128c8fa763b4a503a1",
      "commitAuthor": "Rakesh Radhakrishnan",
      "commitDateOld": "16/08/17 10:17 PM",
      "commitNameOld": "96b3a6b9721e922d33fadc2459b561a85dbf9b8e",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 13.09,
      "commitsBetweenForRepo": 125,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,32 +1,36 @@\n   public synchronized ErasureCodingPolicy addPolicy(ErasureCodingPolicy policy)\n       throws IllegalECPolicyException {\n+    // Set policy state into DISABLED when adding into Hadoop.\n+    policy.setState(ErasureCodingPolicyState.DISABLED);\n+\n     if (!CodecUtil.hasCodec(policy.getCodecName())) {\n       throw new IllegalECPolicyException(\"Codec name \"\n           + policy.getCodecName() + \" is not supported\");\n     }\n \n     if (policy.getCellSize() \u003e maxCellSize) {\n       throw new IllegalECPolicyException(\"Cell size \" + policy.getCellSize()\n           + \" should not exceed maximum \" + maxCellSize + \" byte\");\n     }\n \n     String assignedNewName \u003d ErasureCodingPolicy.composePolicyName(\n         policy.getSchema(), policy.getCellSize());\n     for (ErasureCodingPolicy p : getPolicies()) {\n       if (p.getName().equals(assignedNewName)) {\n         throw new IllegalECPolicyException(\"The policy name \" + assignedNewName\n             + \" already exists\");\n       }\n       if (p.getSchema().equals(policy.getSchema()) \u0026\u0026\n           p.getCellSize() \u003d\u003d policy.getCellSize()) {\n         throw new IllegalECPolicyException(\"A policy with same schema \"\n             + policy.getSchema().toString() + \" and cell size \"\n             + p.getCellSize() + \" is already exists\");\n       }\n     }\n     policy.setName(assignedNewName);\n     policy.setId(getNextAvailablePolicyID());\n-    this.userPoliciesByName.put(policy.getName(), policy);\n-    this.userPoliciesByID.put(policy.getId(), policy);\n+    this.policiesByName.put(policy.getName(), policy);\n+    this.policiesByID.put(policy.getId(), policy);\n+    allPolicies \u003d policiesByName.values().toArray(new ErasureCodingPolicy[0]);\n     return policy;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized ErasureCodingPolicy addPolicy(ErasureCodingPolicy policy)\n      throws IllegalECPolicyException {\n    // Set policy state into DISABLED when adding into Hadoop.\n    policy.setState(ErasureCodingPolicyState.DISABLED);\n\n    if (!CodecUtil.hasCodec(policy.getCodecName())) {\n      throw new IllegalECPolicyException(\"Codec name \"\n          + policy.getCodecName() + \" is not supported\");\n    }\n\n    if (policy.getCellSize() \u003e maxCellSize) {\n      throw new IllegalECPolicyException(\"Cell size \" + policy.getCellSize()\n          + \" should not exceed maximum \" + maxCellSize + \" byte\");\n    }\n\n    String assignedNewName \u003d ErasureCodingPolicy.composePolicyName(\n        policy.getSchema(), policy.getCellSize());\n    for (ErasureCodingPolicy p : getPolicies()) {\n      if (p.getName().equals(assignedNewName)) {\n        throw new IllegalECPolicyException(\"The policy name \" + assignedNewName\n            + \" already exists\");\n      }\n      if (p.getSchema().equals(policy.getSchema()) \u0026\u0026\n          p.getCellSize() \u003d\u003d policy.getCellSize()) {\n        throw new IllegalECPolicyException(\"A policy with same schema \"\n            + policy.getSchema().toString() + \" and cell size \"\n            + p.getCellSize() + \" is already exists\");\n      }\n    }\n    policy.setName(assignedNewName);\n    policy.setId(getNextAvailablePolicyID());\n    this.policiesByName.put(policy.getName(), policy);\n    this.policiesByID.put(policy.getId(), policy);\n    allPolicies \u003d policiesByName.values().toArray(new ErasureCodingPolicy[0]);\n    return policy;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ErasureCodingPolicyManager.java",
      "extendedDetails": {}
    },
    "a62be38a5e5d3a61dfb59054b3f5fd5b1b7053b3": {
      "type": "Ymultichange(Yreturntypechange,Ybodychange)",
      "commitMessage": "HDFS-11793. Allow to enable user defined erasure coding policy. Contributed by Sammi Chen\n",
      "commitDate": "24/05/17 3:45 AM",
      "commitName": "a62be38a5e5d3a61dfb59054b3f5fd5b1b7053b3",
      "commitAuthor": "Kai Zheng",
      "subchanges": [
        {
          "type": "Yreturntypechange",
          "commitMessage": "HDFS-11793. Allow to enable user defined erasure coding policy. Contributed by Sammi Chen\n",
          "commitDate": "24/05/17 3:45 AM",
          "commitName": "a62be38a5e5d3a61dfb59054b3f5fd5b1b7053b3",
          "commitAuthor": "Kai Zheng",
          "commitDateOld": "27/04/17 10:18 PM",
          "commitNameOld": "cb672a45a0bbd8950b9b5e304c2e03f516945903",
          "commitAuthorOld": "Kai Zheng",
          "daysBetweenCommits": 26.23,
          "commitsBetweenForRepo": 135,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,19 +1,32 @@\n-  public synchronized void addPolicy(ErasureCodingPolicy policy)\n+  public synchronized ErasureCodingPolicy addPolicy(ErasureCodingPolicy policy)\n       throws IllegalECPolicyException {\n+    if (!CodecUtil.hasCodec(policy.getCodecName())) {\n+      throw new IllegalECPolicyException(\"Codec name \"\n+          + policy.getCodecName() + \" is not supported\");\n+    }\n+\n+    if (policy.getCellSize() \u003e maxCellSize) {\n+      throw new IllegalECPolicyException(\"Cell size \" + policy.getCellSize()\n+          + \" should not exceed maximum \" + maxCellSize + \" byte\");\n+    }\n+\n     String assignedNewName \u003d ErasureCodingPolicy.composePolicyName(\n         policy.getSchema(), policy.getCellSize());\n     for (ErasureCodingPolicy p : getPolicies()) {\n       if (p.getName().equals(assignedNewName)) {\n-        throw new IllegalECPolicyException(\"The policy name already exists\");\n+        throw new IllegalECPolicyException(\"The policy name \" + assignedNewName\n+            + \" already exists\");\n       }\n       if (p.getSchema().equals(policy.getSchema()) \u0026\u0026\n           p.getCellSize() \u003d\u003d policy.getCellSize()) {\n-        throw new IllegalECPolicyException(\"A policy with same schema and \" +\n-            \"cell size already exists\");\n+        throw new IllegalECPolicyException(\"A policy with same schema \"\n+            + policy.getSchema().toString() + \" and cell size \"\n+            + p.getCellSize() + \" is already exists\");\n       }\n     }\n     policy.setName(assignedNewName);\n     policy.setId(getNextAvailablePolicyID());\n     this.userPoliciesByName.put(policy.getName(), policy);\n     this.userPoliciesByID.put(policy.getId(), policy);\n+    return policy;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public synchronized ErasureCodingPolicy addPolicy(ErasureCodingPolicy policy)\n      throws IllegalECPolicyException {\n    if (!CodecUtil.hasCodec(policy.getCodecName())) {\n      throw new IllegalECPolicyException(\"Codec name \"\n          + policy.getCodecName() + \" is not supported\");\n    }\n\n    if (policy.getCellSize() \u003e maxCellSize) {\n      throw new IllegalECPolicyException(\"Cell size \" + policy.getCellSize()\n          + \" should not exceed maximum \" + maxCellSize + \" byte\");\n    }\n\n    String assignedNewName \u003d ErasureCodingPolicy.composePolicyName(\n        policy.getSchema(), policy.getCellSize());\n    for (ErasureCodingPolicy p : getPolicies()) {\n      if (p.getName().equals(assignedNewName)) {\n        throw new IllegalECPolicyException(\"The policy name \" + assignedNewName\n            + \" already exists\");\n      }\n      if (p.getSchema().equals(policy.getSchema()) \u0026\u0026\n          p.getCellSize() \u003d\u003d policy.getCellSize()) {\n        throw new IllegalECPolicyException(\"A policy with same schema \"\n            + policy.getSchema().toString() + \" and cell size \"\n            + p.getCellSize() + \" is already exists\");\n      }\n    }\n    policy.setName(assignedNewName);\n    policy.setId(getNextAvailablePolicyID());\n    this.userPoliciesByName.put(policy.getName(), policy);\n    this.userPoliciesByID.put(policy.getId(), policy);\n    return policy;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ErasureCodingPolicyManager.java",
          "extendedDetails": {
            "oldValue": "void",
            "newValue": "ErasureCodingPolicy"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-11793. Allow to enable user defined erasure coding policy. Contributed by Sammi Chen\n",
          "commitDate": "24/05/17 3:45 AM",
          "commitName": "a62be38a5e5d3a61dfb59054b3f5fd5b1b7053b3",
          "commitAuthor": "Kai Zheng",
          "commitDateOld": "27/04/17 10:18 PM",
          "commitNameOld": "cb672a45a0bbd8950b9b5e304c2e03f516945903",
          "commitAuthorOld": "Kai Zheng",
          "daysBetweenCommits": 26.23,
          "commitsBetweenForRepo": 135,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,19 +1,32 @@\n-  public synchronized void addPolicy(ErasureCodingPolicy policy)\n+  public synchronized ErasureCodingPolicy addPolicy(ErasureCodingPolicy policy)\n       throws IllegalECPolicyException {\n+    if (!CodecUtil.hasCodec(policy.getCodecName())) {\n+      throw new IllegalECPolicyException(\"Codec name \"\n+          + policy.getCodecName() + \" is not supported\");\n+    }\n+\n+    if (policy.getCellSize() \u003e maxCellSize) {\n+      throw new IllegalECPolicyException(\"Cell size \" + policy.getCellSize()\n+          + \" should not exceed maximum \" + maxCellSize + \" byte\");\n+    }\n+\n     String assignedNewName \u003d ErasureCodingPolicy.composePolicyName(\n         policy.getSchema(), policy.getCellSize());\n     for (ErasureCodingPolicy p : getPolicies()) {\n       if (p.getName().equals(assignedNewName)) {\n-        throw new IllegalECPolicyException(\"The policy name already exists\");\n+        throw new IllegalECPolicyException(\"The policy name \" + assignedNewName\n+            + \" already exists\");\n       }\n       if (p.getSchema().equals(policy.getSchema()) \u0026\u0026\n           p.getCellSize() \u003d\u003d policy.getCellSize()) {\n-        throw new IllegalECPolicyException(\"A policy with same schema and \" +\n-            \"cell size already exists\");\n+        throw new IllegalECPolicyException(\"A policy with same schema \"\n+            + policy.getSchema().toString() + \" and cell size \"\n+            + p.getCellSize() + \" is already exists\");\n       }\n     }\n     policy.setName(assignedNewName);\n     policy.setId(getNextAvailablePolicyID());\n     this.userPoliciesByName.put(policy.getName(), policy);\n     this.userPoliciesByID.put(policy.getId(), policy);\n+    return policy;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public synchronized ErasureCodingPolicy addPolicy(ErasureCodingPolicy policy)\n      throws IllegalECPolicyException {\n    if (!CodecUtil.hasCodec(policy.getCodecName())) {\n      throw new IllegalECPolicyException(\"Codec name \"\n          + policy.getCodecName() + \" is not supported\");\n    }\n\n    if (policy.getCellSize() \u003e maxCellSize) {\n      throw new IllegalECPolicyException(\"Cell size \" + policy.getCellSize()\n          + \" should not exceed maximum \" + maxCellSize + \" byte\");\n    }\n\n    String assignedNewName \u003d ErasureCodingPolicy.composePolicyName(\n        policy.getSchema(), policy.getCellSize());\n    for (ErasureCodingPolicy p : getPolicies()) {\n      if (p.getName().equals(assignedNewName)) {\n        throw new IllegalECPolicyException(\"The policy name \" + assignedNewName\n            + \" already exists\");\n      }\n      if (p.getSchema().equals(policy.getSchema()) \u0026\u0026\n          p.getCellSize() \u003d\u003d policy.getCellSize()) {\n        throw new IllegalECPolicyException(\"A policy with same schema \"\n            + policy.getSchema().toString() + \" and cell size \"\n            + p.getCellSize() + \" is already exists\");\n      }\n    }\n    policy.setName(assignedNewName);\n    policy.setId(getNextAvailablePolicyID());\n    this.userPoliciesByName.put(policy.getName(), policy);\n    this.userPoliciesByID.put(policy.getId(), policy);\n    return policy;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ErasureCodingPolicyManager.java",
          "extendedDetails": {}
        }
      ]
    },
    "cb672a45a0bbd8950b9b5e304c2e03f516945903": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-11605. Allow user to customize new erasure code policies. Contributed by Huafeng Wang\n",
      "commitDate": "27/04/17 10:18 PM",
      "commitName": "cb672a45a0bbd8950b9b5e304c2e03f516945903",
      "commitAuthor": "Kai Zheng",
      "diff": "@@ -0,0 +1,19 @@\n+  public synchronized void addPolicy(ErasureCodingPolicy policy)\n+      throws IllegalECPolicyException {\n+    String assignedNewName \u003d ErasureCodingPolicy.composePolicyName(\n+        policy.getSchema(), policy.getCellSize());\n+    for (ErasureCodingPolicy p : getPolicies()) {\n+      if (p.getName().equals(assignedNewName)) {\n+        throw new IllegalECPolicyException(\"The policy name already exists\");\n+      }\n+      if (p.getSchema().equals(policy.getSchema()) \u0026\u0026\n+          p.getCellSize() \u003d\u003d policy.getCellSize()) {\n+        throw new IllegalECPolicyException(\"A policy with same schema and \" +\n+            \"cell size already exists\");\n+      }\n+    }\n+    policy.setName(assignedNewName);\n+    policy.setId(getNextAvailablePolicyID());\n+    this.userPoliciesByName.put(policy.getName(), policy);\n+    this.userPoliciesByID.put(policy.getId(), policy);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void addPolicy(ErasureCodingPolicy policy)\n      throws IllegalECPolicyException {\n    String assignedNewName \u003d ErasureCodingPolicy.composePolicyName(\n        policy.getSchema(), policy.getCellSize());\n    for (ErasureCodingPolicy p : getPolicies()) {\n      if (p.getName().equals(assignedNewName)) {\n        throw new IllegalECPolicyException(\"The policy name already exists\");\n      }\n      if (p.getSchema().equals(policy.getSchema()) \u0026\u0026\n          p.getCellSize() \u003d\u003d policy.getCellSize()) {\n        throw new IllegalECPolicyException(\"A policy with same schema and \" +\n            \"cell size already exists\");\n      }\n    }\n    policy.setName(assignedNewName);\n    policy.setId(getNextAvailablePolicyID());\n    this.userPoliciesByName.put(policy.getName(), policy);\n    this.userPoliciesByID.put(policy.getId(), policy);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ErasureCodingPolicyManager.java"
    }
  }
}