{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "BlockReaderFactory.java",
  "functionName": "requestFileDescriptors",
  "functionId": "requestFileDescriptors___peer-DomainPeer__slot-Slot",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/client/impl/BlockReaderFactory.java",
  "functionStartLine": 585,
  "functionEndLine": 665,
  "numCommitsSeen": 82,
  "timeTaken": 7937,
  "changeHistory": [
    "2abcf7762ae74b936e1cedb60d5d2b4cc4ee86ea",
    "4525292d41482330a86f1cc3935e072f9f67c308",
    "86e6aa8eec538e142044e2b6415ec1caff5e9cbd",
    "ea3b0a184405c3feca024a560807ea215b6858b9",
    "eca1a4bfe952fc184fe90dde50bac9b0e5293568",
    "0247cb6318507afe06816e337a19f396afc53efa",
    "2e7331ca264dd366b975f3c8e610cf84eb8cc155",
    "56b88b06705441f6f171eec7fb2fa77946ca204b",
    "f308561f1d885491b88db73ac63003202056d661",
    "39285e6a1978ea5e53bdc1b0aef62421382124a8",
    "6ee0539ede78b640f01c5eac18ded161182a7835",
    "d5a9a3daa0224249221ffa7b8bd5751ab2feca56",
    "bf37d3d80e5179dea27e5bd5aea804a38aa9934c",
    "490bb5ebd6c6d6f9c08fcad167f976687fc3aa42",
    "a8898445dc9b5cdb7230e2e23a57393c9f378ff0",
    "bc9cb3e271b22069a15ca110cd60c860250aaab2",
    "32741cf3d25d85a92e3deb11c302cc2a718d71dd",
    "5aa892ed486d42ae6b94c4866b92cd2b382ea640",
    "dd049a2f6097da189ccce2f5890a2b9bc77fa73f",
    "f0d64a078da7e932b9509734f75170e3e525e68c",
    "beb0d25d2a7ba5004c6aabd105546ba9a9fec9be"
  ],
  "changeHistoryShort": {
    "2abcf7762ae74b936e1cedb60d5d2b4cc4ee86ea": "Ybodychange",
    "4525292d41482330a86f1cc3935e072f9f67c308": "Ybodychange",
    "86e6aa8eec538e142044e2b6415ec1caff5e9cbd": "Ybodychange",
    "ea3b0a184405c3feca024a560807ea215b6858b9": "Ybodychange",
    "eca1a4bfe952fc184fe90dde50bac9b0e5293568": "Ybodychange",
    "0247cb6318507afe06816e337a19f396afc53efa": "Ybodychange",
    "2e7331ca264dd366b975f3c8e610cf84eb8cc155": "Ybodychange",
    "56b88b06705441f6f171eec7fb2fa77946ca204b": "Ybodychange",
    "f308561f1d885491b88db73ac63003202056d661": "Yfilerename",
    "39285e6a1978ea5e53bdc1b0aef62421382124a8": "Ybodychange",
    "6ee0539ede78b640f01c5eac18ded161182a7835": "Ybodychange",
    "d5a9a3daa0224249221ffa7b8bd5751ab2feca56": "Ybodychange",
    "bf37d3d80e5179dea27e5bd5aea804a38aa9934c": "Ymultichange(Yfilerename,Ybodychange)",
    "490bb5ebd6c6d6f9c08fcad167f976687fc3aa42": "Ybodychange",
    "a8898445dc9b5cdb7230e2e23a57393c9f378ff0": "Ybodychange",
    "bc9cb3e271b22069a15ca110cd60c860250aaab2": "Ybodychange",
    "32741cf3d25d85a92e3deb11c302cc2a718d71dd": "Ybodychange",
    "5aa892ed486d42ae6b94c4866b92cd2b382ea640": "Ybodychange",
    "dd049a2f6097da189ccce2f5890a2b9bc77fa73f": "Ymultichange(Yparameterchange,Ybodychange)",
    "f0d64a078da7e932b9509734f75170e3e525e68c": "Ybodychange",
    "beb0d25d2a7ba5004c6aabd105546ba9a9fec9be": "Yintroduced"
  },
  "changeHistoryDetails": {
    "2abcf7762ae74b936e1cedb60d5d2b4cc4ee86ea": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-15202 Boost short circuit cache (rebase PR-1884) (#2016)\n",
      "commitDate": "18/05/20 9:23 AM",
      "commitName": "2abcf7762ae74b936e1cedb60d5d2b4cc4ee86ea",
      "commitAuthor": "Wei-Chiu Chuang",
      "commitDateOld": "18/05/20 9:22 AM",
      "commitNameOld": "4525292d41482330a86f1cc3935e072f9f67c308",
      "commitAuthorOld": "Wei-Chiu Chuang",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,80 +1,81 @@\n   private ShortCircuitReplicaInfo requestFileDescriptors(DomainPeer peer,\n           Slot slot) throws IOException {\n-    ShortCircuitCache cache \u003d clientContext.getShortCircuitCache();\n+    ShortCircuitCache cache \u003d\n+        clientContext.getShortCircuitCache(block.getBlockId());\n     final DataOutputStream out \u003d\n         new DataOutputStream(new BufferedOutputStream(peer.getOutputStream(), SMALL_BUFFER_SIZE));\n     SlotId slotId \u003d slot \u003d\u003d null ? null : slot.getSlotId();\n     new Sender(out).requestShortCircuitFds(block, token, slotId, 1,\n         failureInjector.getSupportsReceiptVerification());\n     DataInputStream in \u003d new DataInputStream(peer.getInputStream());\n     BlockOpResponseProto resp \u003d BlockOpResponseProto.parseFrom(\n         PBHelperClient.vintPrefixed(in));\n     DomainSocket sock \u003d peer.getDomainSocket();\n     failureInjector.injectRequestFileDescriptorsFailure();\n     switch (resp.getStatus()) {\n     case SUCCESS:\n       byte buf[] \u003d new byte[1];\n       FileInputStream[] fis \u003d new FileInputStream[2];\n       sock.recvFileInputStreams(fis, buf, 0, buf.length);\n       ShortCircuitReplica replica \u003d null;\n       try {\n         if (fis[0] \u003d\u003d null || fis[1] \u003d\u003d null) {\n           throw new IOException(\"the datanode \" + datanode + \" failed to \" +\n               \"pass a file descriptor (might have reached open file limit).\");\n         }\n \n         ExtendedBlockId key \u003d\n             new ExtendedBlockId(block.getBlockId(), block.getBlockPoolId());\n         if (buf[0] \u003d\u003d USE_RECEIPT_VERIFICATION.getNumber()) {\n           LOG.trace(\"Sending receipt verification byte for slot {}\", slot);\n           sock.getOutputStream().write(0);\n         }\n         replica \u003d new ShortCircuitReplica(key, fis[0], fis[1], cache,\n             Time.monotonicNow(), slot);\n         return new ShortCircuitReplicaInfo(replica);\n       } catch (IOException e) {\n         // This indicates an error reading from disk, or a format error.  Since\n         // it\u0027s not a socket communication problem, we return null rather than\n         // throwing an exception.\n         LOG.warn(this + \": error creating ShortCircuitReplica.\", e);\n         return null;\n       } finally {\n         if (replica \u003d\u003d null) {\n           IOUtilsClient.cleanupWithLogger(DFSClient.LOG, fis[0], fis[1]);\n         }\n       }\n     case ERROR_UNSUPPORTED:\n       if (!resp.hasShortCircuitAccessVersion()) {\n         LOG.warn(\"short-circuit read access is disabled for \" +\n             \"DataNode \" + datanode + \".  reason: \" + resp.getMessage());\n         clientContext.getDomainSocketFactory()\n             .disableShortCircuitForPath(pathInfo.getPath());\n       } else {\n         LOG.warn(\"short-circuit read access for the file \" +\n             fileName + \" is disabled for DataNode \" + datanode +\n             \".  reason: \" + resp.getMessage());\n       }\n       return null;\n     case ERROR_ACCESS_TOKEN:\n       String msg \u003d \"access control error while \" +\n           \"attempting to set up short-circuit access to \" +\n           fileName + resp.getMessage();\n       LOG.debug(\"{}:{}\", this, msg);\n       return new ShortCircuitReplicaInfo(new InvalidToken(msg));\n     default:\n       final long expiration \u003d\n           clientContext.getDomainSocketFactory().getPathExpireSeconds();\n       String disableMsg \u003d \"disabled temporarily for \" + expiration + \" seconds\";\n       if (expiration \u003d\u003d 0) {\n         disableMsg \u003d \"not disabled\";\n       }\n       LOG.warn(\"{}: unknown response code {} while attempting to set up \"\n               + \"short-circuit access. {}. Short-circuit read for \"\n               + \"DataNode {} is {} based on {}.\",\n           this, resp.getStatus(), resp.getMessage(), datanode,\n           disableMsg, DFS_DOMAIN_SOCKET_DISABLE_INTERVAL_SECOND_KEY);\n       clientContext.getDomainSocketFactory()\n           .disableShortCircuitForPath(pathInfo.getPath());\n       return null;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private ShortCircuitReplicaInfo requestFileDescriptors(DomainPeer peer,\n          Slot slot) throws IOException {\n    ShortCircuitCache cache \u003d\n        clientContext.getShortCircuitCache(block.getBlockId());\n    final DataOutputStream out \u003d\n        new DataOutputStream(new BufferedOutputStream(peer.getOutputStream(), SMALL_BUFFER_SIZE));\n    SlotId slotId \u003d slot \u003d\u003d null ? null : slot.getSlotId();\n    new Sender(out).requestShortCircuitFds(block, token, slotId, 1,\n        failureInjector.getSupportsReceiptVerification());\n    DataInputStream in \u003d new DataInputStream(peer.getInputStream());\n    BlockOpResponseProto resp \u003d BlockOpResponseProto.parseFrom(\n        PBHelperClient.vintPrefixed(in));\n    DomainSocket sock \u003d peer.getDomainSocket();\n    failureInjector.injectRequestFileDescriptorsFailure();\n    switch (resp.getStatus()) {\n    case SUCCESS:\n      byte buf[] \u003d new byte[1];\n      FileInputStream[] fis \u003d new FileInputStream[2];\n      sock.recvFileInputStreams(fis, buf, 0, buf.length);\n      ShortCircuitReplica replica \u003d null;\n      try {\n        if (fis[0] \u003d\u003d null || fis[1] \u003d\u003d null) {\n          throw new IOException(\"the datanode \" + datanode + \" failed to \" +\n              \"pass a file descriptor (might have reached open file limit).\");\n        }\n\n        ExtendedBlockId key \u003d\n            new ExtendedBlockId(block.getBlockId(), block.getBlockPoolId());\n        if (buf[0] \u003d\u003d USE_RECEIPT_VERIFICATION.getNumber()) {\n          LOG.trace(\"Sending receipt verification byte for slot {}\", slot);\n          sock.getOutputStream().write(0);\n        }\n        replica \u003d new ShortCircuitReplica(key, fis[0], fis[1], cache,\n            Time.monotonicNow(), slot);\n        return new ShortCircuitReplicaInfo(replica);\n      } catch (IOException e) {\n        // This indicates an error reading from disk, or a format error.  Since\n        // it\u0027s not a socket communication problem, we return null rather than\n        // throwing an exception.\n        LOG.warn(this + \": error creating ShortCircuitReplica.\", e);\n        return null;\n      } finally {\n        if (replica \u003d\u003d null) {\n          IOUtilsClient.cleanupWithLogger(DFSClient.LOG, fis[0], fis[1]);\n        }\n      }\n    case ERROR_UNSUPPORTED:\n      if (!resp.hasShortCircuitAccessVersion()) {\n        LOG.warn(\"short-circuit read access is disabled for \" +\n            \"DataNode \" + datanode + \".  reason: \" + resp.getMessage());\n        clientContext.getDomainSocketFactory()\n            .disableShortCircuitForPath(pathInfo.getPath());\n      } else {\n        LOG.warn(\"short-circuit read access for the file \" +\n            fileName + \" is disabled for DataNode \" + datanode +\n            \".  reason: \" + resp.getMessage());\n      }\n      return null;\n    case ERROR_ACCESS_TOKEN:\n      String msg \u003d \"access control error while \" +\n          \"attempting to set up short-circuit access to \" +\n          fileName + resp.getMessage();\n      LOG.debug(\"{}:{}\", this, msg);\n      return new ShortCircuitReplicaInfo(new InvalidToken(msg));\n    default:\n      final long expiration \u003d\n          clientContext.getDomainSocketFactory().getPathExpireSeconds();\n      String disableMsg \u003d \"disabled temporarily for \" + expiration + \" seconds\";\n      if (expiration \u003d\u003d 0) {\n        disableMsg \u003d \"not disabled\";\n      }\n      LOG.warn(\"{}: unknown response code {} while attempting to set up \"\n              + \"short-circuit access. {}. Short-circuit read for \"\n              + \"DataNode {} is {} based on {}.\",\n          this, resp.getStatus(), resp.getMessage(), datanode,\n          disableMsg, DFS_DOMAIN_SOCKET_DISABLE_INTERVAL_SECOND_KEY);\n      clientContext.getDomainSocketFactory()\n          .disableShortCircuitForPath(pathInfo.getPath());\n      return null;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/client/impl/BlockReaderFactory.java",
      "extendedDetails": {}
    },
    "4525292d41482330a86f1cc3935e072f9f67c308": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HDFS-15202 Boost short circuit cache (rebase PR-1884) (#2016)\"\n\nThis reverts commit 86e6aa8eec538e142044e2b6415ec1caff5e9cbd.\n",
      "commitDate": "18/05/20 9:22 AM",
      "commitName": "4525292d41482330a86f1cc3935e072f9f67c308",
      "commitAuthor": "Wei-Chiu Chuang",
      "commitDateOld": "18/05/20 7:04 AM",
      "commitNameOld": "86e6aa8eec538e142044e2b6415ec1caff5e9cbd",
      "commitAuthorOld": "pustota2009",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,81 +1,80 @@\n   private ShortCircuitReplicaInfo requestFileDescriptors(DomainPeer peer,\n           Slot slot) throws IOException {\n-    ShortCircuitCache cache \u003d\n-        clientContext.getShortCircuitCache(block.getBlockId());\n+    ShortCircuitCache cache \u003d clientContext.getShortCircuitCache();\n     final DataOutputStream out \u003d\n         new DataOutputStream(new BufferedOutputStream(peer.getOutputStream(), SMALL_BUFFER_SIZE));\n     SlotId slotId \u003d slot \u003d\u003d null ? null : slot.getSlotId();\n     new Sender(out).requestShortCircuitFds(block, token, slotId, 1,\n         failureInjector.getSupportsReceiptVerification());\n     DataInputStream in \u003d new DataInputStream(peer.getInputStream());\n     BlockOpResponseProto resp \u003d BlockOpResponseProto.parseFrom(\n         PBHelperClient.vintPrefixed(in));\n     DomainSocket sock \u003d peer.getDomainSocket();\n     failureInjector.injectRequestFileDescriptorsFailure();\n     switch (resp.getStatus()) {\n     case SUCCESS:\n       byte buf[] \u003d new byte[1];\n       FileInputStream[] fis \u003d new FileInputStream[2];\n       sock.recvFileInputStreams(fis, buf, 0, buf.length);\n       ShortCircuitReplica replica \u003d null;\n       try {\n         if (fis[0] \u003d\u003d null || fis[1] \u003d\u003d null) {\n           throw new IOException(\"the datanode \" + datanode + \" failed to \" +\n               \"pass a file descriptor (might have reached open file limit).\");\n         }\n \n         ExtendedBlockId key \u003d\n             new ExtendedBlockId(block.getBlockId(), block.getBlockPoolId());\n         if (buf[0] \u003d\u003d USE_RECEIPT_VERIFICATION.getNumber()) {\n           LOG.trace(\"Sending receipt verification byte for slot {}\", slot);\n           sock.getOutputStream().write(0);\n         }\n         replica \u003d new ShortCircuitReplica(key, fis[0], fis[1], cache,\n             Time.monotonicNow(), slot);\n         return new ShortCircuitReplicaInfo(replica);\n       } catch (IOException e) {\n         // This indicates an error reading from disk, or a format error.  Since\n         // it\u0027s not a socket communication problem, we return null rather than\n         // throwing an exception.\n         LOG.warn(this + \": error creating ShortCircuitReplica.\", e);\n         return null;\n       } finally {\n         if (replica \u003d\u003d null) {\n           IOUtilsClient.cleanupWithLogger(DFSClient.LOG, fis[0], fis[1]);\n         }\n       }\n     case ERROR_UNSUPPORTED:\n       if (!resp.hasShortCircuitAccessVersion()) {\n         LOG.warn(\"short-circuit read access is disabled for \" +\n             \"DataNode \" + datanode + \".  reason: \" + resp.getMessage());\n         clientContext.getDomainSocketFactory()\n             .disableShortCircuitForPath(pathInfo.getPath());\n       } else {\n         LOG.warn(\"short-circuit read access for the file \" +\n             fileName + \" is disabled for DataNode \" + datanode +\n             \".  reason: \" + resp.getMessage());\n       }\n       return null;\n     case ERROR_ACCESS_TOKEN:\n       String msg \u003d \"access control error while \" +\n           \"attempting to set up short-circuit access to \" +\n           fileName + resp.getMessage();\n       LOG.debug(\"{}:{}\", this, msg);\n       return new ShortCircuitReplicaInfo(new InvalidToken(msg));\n     default:\n       final long expiration \u003d\n           clientContext.getDomainSocketFactory().getPathExpireSeconds();\n       String disableMsg \u003d \"disabled temporarily for \" + expiration + \" seconds\";\n       if (expiration \u003d\u003d 0) {\n         disableMsg \u003d \"not disabled\";\n       }\n       LOG.warn(\"{}: unknown response code {} while attempting to set up \"\n               + \"short-circuit access. {}. Short-circuit read for \"\n               + \"DataNode {} is {} based on {}.\",\n           this, resp.getStatus(), resp.getMessage(), datanode,\n           disableMsg, DFS_DOMAIN_SOCKET_DISABLE_INTERVAL_SECOND_KEY);\n       clientContext.getDomainSocketFactory()\n           .disableShortCircuitForPath(pathInfo.getPath());\n       return null;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private ShortCircuitReplicaInfo requestFileDescriptors(DomainPeer peer,\n          Slot slot) throws IOException {\n    ShortCircuitCache cache \u003d clientContext.getShortCircuitCache();\n    final DataOutputStream out \u003d\n        new DataOutputStream(new BufferedOutputStream(peer.getOutputStream(), SMALL_BUFFER_SIZE));\n    SlotId slotId \u003d slot \u003d\u003d null ? null : slot.getSlotId();\n    new Sender(out).requestShortCircuitFds(block, token, slotId, 1,\n        failureInjector.getSupportsReceiptVerification());\n    DataInputStream in \u003d new DataInputStream(peer.getInputStream());\n    BlockOpResponseProto resp \u003d BlockOpResponseProto.parseFrom(\n        PBHelperClient.vintPrefixed(in));\n    DomainSocket sock \u003d peer.getDomainSocket();\n    failureInjector.injectRequestFileDescriptorsFailure();\n    switch (resp.getStatus()) {\n    case SUCCESS:\n      byte buf[] \u003d new byte[1];\n      FileInputStream[] fis \u003d new FileInputStream[2];\n      sock.recvFileInputStreams(fis, buf, 0, buf.length);\n      ShortCircuitReplica replica \u003d null;\n      try {\n        if (fis[0] \u003d\u003d null || fis[1] \u003d\u003d null) {\n          throw new IOException(\"the datanode \" + datanode + \" failed to \" +\n              \"pass a file descriptor (might have reached open file limit).\");\n        }\n\n        ExtendedBlockId key \u003d\n            new ExtendedBlockId(block.getBlockId(), block.getBlockPoolId());\n        if (buf[0] \u003d\u003d USE_RECEIPT_VERIFICATION.getNumber()) {\n          LOG.trace(\"Sending receipt verification byte for slot {}\", slot);\n          sock.getOutputStream().write(0);\n        }\n        replica \u003d new ShortCircuitReplica(key, fis[0], fis[1], cache,\n            Time.monotonicNow(), slot);\n        return new ShortCircuitReplicaInfo(replica);\n      } catch (IOException e) {\n        // This indicates an error reading from disk, or a format error.  Since\n        // it\u0027s not a socket communication problem, we return null rather than\n        // throwing an exception.\n        LOG.warn(this + \": error creating ShortCircuitReplica.\", e);\n        return null;\n      } finally {\n        if (replica \u003d\u003d null) {\n          IOUtilsClient.cleanupWithLogger(DFSClient.LOG, fis[0], fis[1]);\n        }\n      }\n    case ERROR_UNSUPPORTED:\n      if (!resp.hasShortCircuitAccessVersion()) {\n        LOG.warn(\"short-circuit read access is disabled for \" +\n            \"DataNode \" + datanode + \".  reason: \" + resp.getMessage());\n        clientContext.getDomainSocketFactory()\n            .disableShortCircuitForPath(pathInfo.getPath());\n      } else {\n        LOG.warn(\"short-circuit read access for the file \" +\n            fileName + \" is disabled for DataNode \" + datanode +\n            \".  reason: \" + resp.getMessage());\n      }\n      return null;\n    case ERROR_ACCESS_TOKEN:\n      String msg \u003d \"access control error while \" +\n          \"attempting to set up short-circuit access to \" +\n          fileName + resp.getMessage();\n      LOG.debug(\"{}:{}\", this, msg);\n      return new ShortCircuitReplicaInfo(new InvalidToken(msg));\n    default:\n      final long expiration \u003d\n          clientContext.getDomainSocketFactory().getPathExpireSeconds();\n      String disableMsg \u003d \"disabled temporarily for \" + expiration + \" seconds\";\n      if (expiration \u003d\u003d 0) {\n        disableMsg \u003d \"not disabled\";\n      }\n      LOG.warn(\"{}: unknown response code {} while attempting to set up \"\n              + \"short-circuit access. {}. Short-circuit read for \"\n              + \"DataNode {} is {} based on {}.\",\n          this, resp.getStatus(), resp.getMessage(), datanode,\n          disableMsg, DFS_DOMAIN_SOCKET_DISABLE_INTERVAL_SECOND_KEY);\n      clientContext.getDomainSocketFactory()\n          .disableShortCircuitForPath(pathInfo.getPath());\n      return null;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/client/impl/BlockReaderFactory.java",
      "extendedDetails": {}
    },
    "86e6aa8eec538e142044e2b6415ec1caff5e9cbd": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-15202 Boost short circuit cache (rebase PR-1884) (#2016)\n\nAdded parameter dfs.client.short.circuit.num improving HDFS-client\u0027s massive reading performance by create few instances ShortCircuit caches instead of one. It helps avoid locks and lets CPU do job.",
      "commitDate": "18/05/20 7:04 AM",
      "commitName": "86e6aa8eec538e142044e2b6415ec1caff5e9cbd",
      "commitAuthor": "pustota2009",
      "commitDateOld": "09/05/20 11:13 PM",
      "commitNameOld": "aab9e0b16ecc8fa00228c00c7ab90e55195cf5f4",
      "commitAuthorOld": "Ayush Saxena",
      "daysBetweenCommits": 8.33,
      "commitsBetweenForRepo": 35,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,80 +1,81 @@\n   private ShortCircuitReplicaInfo requestFileDescriptors(DomainPeer peer,\n           Slot slot) throws IOException {\n-    ShortCircuitCache cache \u003d clientContext.getShortCircuitCache();\n+    ShortCircuitCache cache \u003d\n+        clientContext.getShortCircuitCache(block.getBlockId());\n     final DataOutputStream out \u003d\n         new DataOutputStream(new BufferedOutputStream(peer.getOutputStream(), SMALL_BUFFER_SIZE));\n     SlotId slotId \u003d slot \u003d\u003d null ? null : slot.getSlotId();\n     new Sender(out).requestShortCircuitFds(block, token, slotId, 1,\n         failureInjector.getSupportsReceiptVerification());\n     DataInputStream in \u003d new DataInputStream(peer.getInputStream());\n     BlockOpResponseProto resp \u003d BlockOpResponseProto.parseFrom(\n         PBHelperClient.vintPrefixed(in));\n     DomainSocket sock \u003d peer.getDomainSocket();\n     failureInjector.injectRequestFileDescriptorsFailure();\n     switch (resp.getStatus()) {\n     case SUCCESS:\n       byte buf[] \u003d new byte[1];\n       FileInputStream[] fis \u003d new FileInputStream[2];\n       sock.recvFileInputStreams(fis, buf, 0, buf.length);\n       ShortCircuitReplica replica \u003d null;\n       try {\n         if (fis[0] \u003d\u003d null || fis[1] \u003d\u003d null) {\n           throw new IOException(\"the datanode \" + datanode + \" failed to \" +\n               \"pass a file descriptor (might have reached open file limit).\");\n         }\n \n         ExtendedBlockId key \u003d\n             new ExtendedBlockId(block.getBlockId(), block.getBlockPoolId());\n         if (buf[0] \u003d\u003d USE_RECEIPT_VERIFICATION.getNumber()) {\n           LOG.trace(\"Sending receipt verification byte for slot {}\", slot);\n           sock.getOutputStream().write(0);\n         }\n         replica \u003d new ShortCircuitReplica(key, fis[0], fis[1], cache,\n             Time.monotonicNow(), slot);\n         return new ShortCircuitReplicaInfo(replica);\n       } catch (IOException e) {\n         // This indicates an error reading from disk, or a format error.  Since\n         // it\u0027s not a socket communication problem, we return null rather than\n         // throwing an exception.\n         LOG.warn(this + \": error creating ShortCircuitReplica.\", e);\n         return null;\n       } finally {\n         if (replica \u003d\u003d null) {\n           IOUtilsClient.cleanupWithLogger(DFSClient.LOG, fis[0], fis[1]);\n         }\n       }\n     case ERROR_UNSUPPORTED:\n       if (!resp.hasShortCircuitAccessVersion()) {\n         LOG.warn(\"short-circuit read access is disabled for \" +\n             \"DataNode \" + datanode + \".  reason: \" + resp.getMessage());\n         clientContext.getDomainSocketFactory()\n             .disableShortCircuitForPath(pathInfo.getPath());\n       } else {\n         LOG.warn(\"short-circuit read access for the file \" +\n             fileName + \" is disabled for DataNode \" + datanode +\n             \".  reason: \" + resp.getMessage());\n       }\n       return null;\n     case ERROR_ACCESS_TOKEN:\n       String msg \u003d \"access control error while \" +\n           \"attempting to set up short-circuit access to \" +\n           fileName + resp.getMessage();\n       LOG.debug(\"{}:{}\", this, msg);\n       return new ShortCircuitReplicaInfo(new InvalidToken(msg));\n     default:\n       final long expiration \u003d\n           clientContext.getDomainSocketFactory().getPathExpireSeconds();\n       String disableMsg \u003d \"disabled temporarily for \" + expiration + \" seconds\";\n       if (expiration \u003d\u003d 0) {\n         disableMsg \u003d \"not disabled\";\n       }\n       LOG.warn(\"{}: unknown response code {} while attempting to set up \"\n               + \"short-circuit access. {}. Short-circuit read for \"\n               + \"DataNode {} is {} based on {}.\",\n           this, resp.getStatus(), resp.getMessage(), datanode,\n           disableMsg, DFS_DOMAIN_SOCKET_DISABLE_INTERVAL_SECOND_KEY);\n       clientContext.getDomainSocketFactory()\n           .disableShortCircuitForPath(pathInfo.getPath());\n       return null;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private ShortCircuitReplicaInfo requestFileDescriptors(DomainPeer peer,\n          Slot slot) throws IOException {\n    ShortCircuitCache cache \u003d\n        clientContext.getShortCircuitCache(block.getBlockId());\n    final DataOutputStream out \u003d\n        new DataOutputStream(new BufferedOutputStream(peer.getOutputStream(), SMALL_BUFFER_SIZE));\n    SlotId slotId \u003d slot \u003d\u003d null ? null : slot.getSlotId();\n    new Sender(out).requestShortCircuitFds(block, token, slotId, 1,\n        failureInjector.getSupportsReceiptVerification());\n    DataInputStream in \u003d new DataInputStream(peer.getInputStream());\n    BlockOpResponseProto resp \u003d BlockOpResponseProto.parseFrom(\n        PBHelperClient.vintPrefixed(in));\n    DomainSocket sock \u003d peer.getDomainSocket();\n    failureInjector.injectRequestFileDescriptorsFailure();\n    switch (resp.getStatus()) {\n    case SUCCESS:\n      byte buf[] \u003d new byte[1];\n      FileInputStream[] fis \u003d new FileInputStream[2];\n      sock.recvFileInputStreams(fis, buf, 0, buf.length);\n      ShortCircuitReplica replica \u003d null;\n      try {\n        if (fis[0] \u003d\u003d null || fis[1] \u003d\u003d null) {\n          throw new IOException(\"the datanode \" + datanode + \" failed to \" +\n              \"pass a file descriptor (might have reached open file limit).\");\n        }\n\n        ExtendedBlockId key \u003d\n            new ExtendedBlockId(block.getBlockId(), block.getBlockPoolId());\n        if (buf[0] \u003d\u003d USE_RECEIPT_VERIFICATION.getNumber()) {\n          LOG.trace(\"Sending receipt verification byte for slot {}\", slot);\n          sock.getOutputStream().write(0);\n        }\n        replica \u003d new ShortCircuitReplica(key, fis[0], fis[1], cache,\n            Time.monotonicNow(), slot);\n        return new ShortCircuitReplicaInfo(replica);\n      } catch (IOException e) {\n        // This indicates an error reading from disk, or a format error.  Since\n        // it\u0027s not a socket communication problem, we return null rather than\n        // throwing an exception.\n        LOG.warn(this + \": error creating ShortCircuitReplica.\", e);\n        return null;\n      } finally {\n        if (replica \u003d\u003d null) {\n          IOUtilsClient.cleanupWithLogger(DFSClient.LOG, fis[0], fis[1]);\n        }\n      }\n    case ERROR_UNSUPPORTED:\n      if (!resp.hasShortCircuitAccessVersion()) {\n        LOG.warn(\"short-circuit read access is disabled for \" +\n            \"DataNode \" + datanode + \".  reason: \" + resp.getMessage());\n        clientContext.getDomainSocketFactory()\n            .disableShortCircuitForPath(pathInfo.getPath());\n      } else {\n        LOG.warn(\"short-circuit read access for the file \" +\n            fileName + \" is disabled for DataNode \" + datanode +\n            \".  reason: \" + resp.getMessage());\n      }\n      return null;\n    case ERROR_ACCESS_TOKEN:\n      String msg \u003d \"access control error while \" +\n          \"attempting to set up short-circuit access to \" +\n          fileName + resp.getMessage();\n      LOG.debug(\"{}:{}\", this, msg);\n      return new ShortCircuitReplicaInfo(new InvalidToken(msg));\n    default:\n      final long expiration \u003d\n          clientContext.getDomainSocketFactory().getPathExpireSeconds();\n      String disableMsg \u003d \"disabled temporarily for \" + expiration + \" seconds\";\n      if (expiration \u003d\u003d 0) {\n        disableMsg \u003d \"not disabled\";\n      }\n      LOG.warn(\"{}: unknown response code {} while attempting to set up \"\n              + \"short-circuit access. {}. Short-circuit read for \"\n              + \"DataNode {} is {} based on {}.\",\n          this, resp.getStatus(), resp.getMessage(), datanode,\n          disableMsg, DFS_DOMAIN_SOCKET_DISABLE_INTERVAL_SECOND_KEY);\n      clientContext.getDomainSocketFactory()\n          .disableShortCircuitForPath(pathInfo.getPath());\n      return null;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/client/impl/BlockReaderFactory.java",
      "extendedDetails": {}
    },
    "ea3b0a184405c3feca024a560807ea215b6858b9": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14535. The default 8KB buffer in requestFileDescriptors#BufferedOutputStream is causing lots of heap allocation in HBase when using short-circut read\n",
      "commitDate": "04/06/19 8:48 AM",
      "commitName": "ea3b0a184405c3feca024a560807ea215b6858b9",
      "commitAuthor": "huzheng",
      "commitDateOld": "06/09/18 2:48 PM",
      "commitNameOld": "eca1a4bfe952fc184fe90dde50bac9b0e5293568",
      "commitAuthorOld": "Giovanni Matteo Fumarola",
      "daysBetweenCommits": 270.75,
      "commitsBetweenForRepo": 2047,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,80 +1,80 @@\n   private ShortCircuitReplicaInfo requestFileDescriptors(DomainPeer peer,\n           Slot slot) throws IOException {\n     ShortCircuitCache cache \u003d clientContext.getShortCircuitCache();\n     final DataOutputStream out \u003d\n-        new DataOutputStream(new BufferedOutputStream(peer.getOutputStream()));\n+        new DataOutputStream(new BufferedOutputStream(peer.getOutputStream(), SMALL_BUFFER_SIZE));\n     SlotId slotId \u003d slot \u003d\u003d null ? null : slot.getSlotId();\n     new Sender(out).requestShortCircuitFds(block, token, slotId, 1,\n         failureInjector.getSupportsReceiptVerification());\n     DataInputStream in \u003d new DataInputStream(peer.getInputStream());\n     BlockOpResponseProto resp \u003d BlockOpResponseProto.parseFrom(\n         PBHelperClient.vintPrefixed(in));\n     DomainSocket sock \u003d peer.getDomainSocket();\n     failureInjector.injectRequestFileDescriptorsFailure();\n     switch (resp.getStatus()) {\n     case SUCCESS:\n       byte buf[] \u003d new byte[1];\n       FileInputStream[] fis \u003d new FileInputStream[2];\n       sock.recvFileInputStreams(fis, buf, 0, buf.length);\n       ShortCircuitReplica replica \u003d null;\n       try {\n         if (fis[0] \u003d\u003d null || fis[1] \u003d\u003d null) {\n           throw new IOException(\"the datanode \" + datanode + \" failed to \" +\n               \"pass a file descriptor (might have reached open file limit).\");\n         }\n \n         ExtendedBlockId key \u003d\n             new ExtendedBlockId(block.getBlockId(), block.getBlockPoolId());\n         if (buf[0] \u003d\u003d USE_RECEIPT_VERIFICATION.getNumber()) {\n           LOG.trace(\"Sending receipt verification byte for slot {}\", slot);\n           sock.getOutputStream().write(0);\n         }\n         replica \u003d new ShortCircuitReplica(key, fis[0], fis[1], cache,\n             Time.monotonicNow(), slot);\n         return new ShortCircuitReplicaInfo(replica);\n       } catch (IOException e) {\n         // This indicates an error reading from disk, or a format error.  Since\n         // it\u0027s not a socket communication problem, we return null rather than\n         // throwing an exception.\n         LOG.warn(this + \": error creating ShortCircuitReplica.\", e);\n         return null;\n       } finally {\n         if (replica \u003d\u003d null) {\n           IOUtilsClient.cleanupWithLogger(DFSClient.LOG, fis[0], fis[1]);\n         }\n       }\n     case ERROR_UNSUPPORTED:\n       if (!resp.hasShortCircuitAccessVersion()) {\n         LOG.warn(\"short-circuit read access is disabled for \" +\n             \"DataNode \" + datanode + \".  reason: \" + resp.getMessage());\n         clientContext.getDomainSocketFactory()\n             .disableShortCircuitForPath(pathInfo.getPath());\n       } else {\n         LOG.warn(\"short-circuit read access for the file \" +\n             fileName + \" is disabled for DataNode \" + datanode +\n             \".  reason: \" + resp.getMessage());\n       }\n       return null;\n     case ERROR_ACCESS_TOKEN:\n       String msg \u003d \"access control error while \" +\n           \"attempting to set up short-circuit access to \" +\n           fileName + resp.getMessage();\n       LOG.debug(\"{}:{}\", this, msg);\n       return new ShortCircuitReplicaInfo(new InvalidToken(msg));\n     default:\n       final long expiration \u003d\n           clientContext.getDomainSocketFactory().getPathExpireSeconds();\n       String disableMsg \u003d \"disabled temporarily for \" + expiration + \" seconds\";\n       if (expiration \u003d\u003d 0) {\n         disableMsg \u003d \"not disabled\";\n       }\n       LOG.warn(\"{}: unknown response code {} while attempting to set up \"\n               + \"short-circuit access. {}. Short-circuit read for \"\n               + \"DataNode {} is {} based on {}.\",\n           this, resp.getStatus(), resp.getMessage(), datanode,\n           disableMsg, DFS_DOMAIN_SOCKET_DISABLE_INTERVAL_SECOND_KEY);\n       clientContext.getDomainSocketFactory()\n           .disableShortCircuitForPath(pathInfo.getPath());\n       return null;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private ShortCircuitReplicaInfo requestFileDescriptors(DomainPeer peer,\n          Slot slot) throws IOException {\n    ShortCircuitCache cache \u003d clientContext.getShortCircuitCache();\n    final DataOutputStream out \u003d\n        new DataOutputStream(new BufferedOutputStream(peer.getOutputStream(), SMALL_BUFFER_SIZE));\n    SlotId slotId \u003d slot \u003d\u003d null ? null : slot.getSlotId();\n    new Sender(out).requestShortCircuitFds(block, token, slotId, 1,\n        failureInjector.getSupportsReceiptVerification());\n    DataInputStream in \u003d new DataInputStream(peer.getInputStream());\n    BlockOpResponseProto resp \u003d BlockOpResponseProto.parseFrom(\n        PBHelperClient.vintPrefixed(in));\n    DomainSocket sock \u003d peer.getDomainSocket();\n    failureInjector.injectRequestFileDescriptorsFailure();\n    switch (resp.getStatus()) {\n    case SUCCESS:\n      byte buf[] \u003d new byte[1];\n      FileInputStream[] fis \u003d new FileInputStream[2];\n      sock.recvFileInputStreams(fis, buf, 0, buf.length);\n      ShortCircuitReplica replica \u003d null;\n      try {\n        if (fis[0] \u003d\u003d null || fis[1] \u003d\u003d null) {\n          throw new IOException(\"the datanode \" + datanode + \" failed to \" +\n              \"pass a file descriptor (might have reached open file limit).\");\n        }\n\n        ExtendedBlockId key \u003d\n            new ExtendedBlockId(block.getBlockId(), block.getBlockPoolId());\n        if (buf[0] \u003d\u003d USE_RECEIPT_VERIFICATION.getNumber()) {\n          LOG.trace(\"Sending receipt verification byte for slot {}\", slot);\n          sock.getOutputStream().write(0);\n        }\n        replica \u003d new ShortCircuitReplica(key, fis[0], fis[1], cache,\n            Time.monotonicNow(), slot);\n        return new ShortCircuitReplicaInfo(replica);\n      } catch (IOException e) {\n        // This indicates an error reading from disk, or a format error.  Since\n        // it\u0027s not a socket communication problem, we return null rather than\n        // throwing an exception.\n        LOG.warn(this + \": error creating ShortCircuitReplica.\", e);\n        return null;\n      } finally {\n        if (replica \u003d\u003d null) {\n          IOUtilsClient.cleanupWithLogger(DFSClient.LOG, fis[0], fis[1]);\n        }\n      }\n    case ERROR_UNSUPPORTED:\n      if (!resp.hasShortCircuitAccessVersion()) {\n        LOG.warn(\"short-circuit read access is disabled for \" +\n            \"DataNode \" + datanode + \".  reason: \" + resp.getMessage());\n        clientContext.getDomainSocketFactory()\n            .disableShortCircuitForPath(pathInfo.getPath());\n      } else {\n        LOG.warn(\"short-circuit read access for the file \" +\n            fileName + \" is disabled for DataNode \" + datanode +\n            \".  reason: \" + resp.getMessage());\n      }\n      return null;\n    case ERROR_ACCESS_TOKEN:\n      String msg \u003d \"access control error while \" +\n          \"attempting to set up short-circuit access to \" +\n          fileName + resp.getMessage();\n      LOG.debug(\"{}:{}\", this, msg);\n      return new ShortCircuitReplicaInfo(new InvalidToken(msg));\n    default:\n      final long expiration \u003d\n          clientContext.getDomainSocketFactory().getPathExpireSeconds();\n      String disableMsg \u003d \"disabled temporarily for \" + expiration + \" seconds\";\n      if (expiration \u003d\u003d 0) {\n        disableMsg \u003d \"not disabled\";\n      }\n      LOG.warn(\"{}: unknown response code {} while attempting to set up \"\n              + \"short-circuit access. {}. Short-circuit read for \"\n              + \"DataNode {} is {} based on {}.\",\n          this, resp.getStatus(), resp.getMessage(), datanode,\n          disableMsg, DFS_DOMAIN_SOCKET_DISABLE_INTERVAL_SECOND_KEY);\n      clientContext.getDomainSocketFactory()\n          .disableShortCircuitForPath(pathInfo.getPath());\n      return null;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/client/impl/BlockReaderFactory.java",
      "extendedDetails": {}
    },
    "eca1a4bfe952fc184fe90dde50bac9b0e5293568": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13695. Move logging to slf4j in HDFS package. Contributed by Ian Pickering.\n",
      "commitDate": "06/09/18 2:48 PM",
      "commitName": "eca1a4bfe952fc184fe90dde50bac9b0e5293568",
      "commitAuthor": "Giovanni Matteo Fumarola",
      "commitDateOld": "06/07/18 2:59 PM",
      "commitNameOld": "0247cb6318507afe06816e337a19f396afc53efa",
      "commitAuthorOld": "Wei-Chiu Chuang",
      "daysBetweenCommits": 61.99,
      "commitsBetweenForRepo": 453,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,80 +1,80 @@\n   private ShortCircuitReplicaInfo requestFileDescriptors(DomainPeer peer,\n           Slot slot) throws IOException {\n     ShortCircuitCache cache \u003d clientContext.getShortCircuitCache();\n     final DataOutputStream out \u003d\n         new DataOutputStream(new BufferedOutputStream(peer.getOutputStream()));\n     SlotId slotId \u003d slot \u003d\u003d null ? null : slot.getSlotId();\n     new Sender(out).requestShortCircuitFds(block, token, slotId, 1,\n         failureInjector.getSupportsReceiptVerification());\n     DataInputStream in \u003d new DataInputStream(peer.getInputStream());\n     BlockOpResponseProto resp \u003d BlockOpResponseProto.parseFrom(\n         PBHelperClient.vintPrefixed(in));\n     DomainSocket sock \u003d peer.getDomainSocket();\n     failureInjector.injectRequestFileDescriptorsFailure();\n     switch (resp.getStatus()) {\n     case SUCCESS:\n       byte buf[] \u003d new byte[1];\n       FileInputStream[] fis \u003d new FileInputStream[2];\n       sock.recvFileInputStreams(fis, buf, 0, buf.length);\n       ShortCircuitReplica replica \u003d null;\n       try {\n         if (fis[0] \u003d\u003d null || fis[1] \u003d\u003d null) {\n           throw new IOException(\"the datanode \" + datanode + \" failed to \" +\n               \"pass a file descriptor (might have reached open file limit).\");\n         }\n \n         ExtendedBlockId key \u003d\n             new ExtendedBlockId(block.getBlockId(), block.getBlockPoolId());\n         if (buf[0] \u003d\u003d USE_RECEIPT_VERIFICATION.getNumber()) {\n           LOG.trace(\"Sending receipt verification byte for slot {}\", slot);\n           sock.getOutputStream().write(0);\n         }\n         replica \u003d new ShortCircuitReplica(key, fis[0], fis[1], cache,\n             Time.monotonicNow(), slot);\n         return new ShortCircuitReplicaInfo(replica);\n       } catch (IOException e) {\n         // This indicates an error reading from disk, or a format error.  Since\n         // it\u0027s not a socket communication problem, we return null rather than\n         // throwing an exception.\n         LOG.warn(this + \": error creating ShortCircuitReplica.\", e);\n         return null;\n       } finally {\n         if (replica \u003d\u003d null) {\n-          IOUtilsClient.cleanup(DFSClient.LOG, fis[0], fis[1]);\n+          IOUtilsClient.cleanupWithLogger(DFSClient.LOG, fis[0], fis[1]);\n         }\n       }\n     case ERROR_UNSUPPORTED:\n       if (!resp.hasShortCircuitAccessVersion()) {\n         LOG.warn(\"short-circuit read access is disabled for \" +\n             \"DataNode \" + datanode + \".  reason: \" + resp.getMessage());\n         clientContext.getDomainSocketFactory()\n             .disableShortCircuitForPath(pathInfo.getPath());\n       } else {\n         LOG.warn(\"short-circuit read access for the file \" +\n             fileName + \" is disabled for DataNode \" + datanode +\n             \".  reason: \" + resp.getMessage());\n       }\n       return null;\n     case ERROR_ACCESS_TOKEN:\n       String msg \u003d \"access control error while \" +\n           \"attempting to set up short-circuit access to \" +\n           fileName + resp.getMessage();\n       LOG.debug(\"{}:{}\", this, msg);\n       return new ShortCircuitReplicaInfo(new InvalidToken(msg));\n     default:\n       final long expiration \u003d\n           clientContext.getDomainSocketFactory().getPathExpireSeconds();\n       String disableMsg \u003d \"disabled temporarily for \" + expiration + \" seconds\";\n       if (expiration \u003d\u003d 0) {\n         disableMsg \u003d \"not disabled\";\n       }\n       LOG.warn(\"{}: unknown response code {} while attempting to set up \"\n               + \"short-circuit access. {}. Short-circuit read for \"\n               + \"DataNode {} is {} based on {}.\",\n           this, resp.getStatus(), resp.getMessage(), datanode,\n           disableMsg, DFS_DOMAIN_SOCKET_DISABLE_INTERVAL_SECOND_KEY);\n       clientContext.getDomainSocketFactory()\n           .disableShortCircuitForPath(pathInfo.getPath());\n       return null;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private ShortCircuitReplicaInfo requestFileDescriptors(DomainPeer peer,\n          Slot slot) throws IOException {\n    ShortCircuitCache cache \u003d clientContext.getShortCircuitCache();\n    final DataOutputStream out \u003d\n        new DataOutputStream(new BufferedOutputStream(peer.getOutputStream()));\n    SlotId slotId \u003d slot \u003d\u003d null ? null : slot.getSlotId();\n    new Sender(out).requestShortCircuitFds(block, token, slotId, 1,\n        failureInjector.getSupportsReceiptVerification());\n    DataInputStream in \u003d new DataInputStream(peer.getInputStream());\n    BlockOpResponseProto resp \u003d BlockOpResponseProto.parseFrom(\n        PBHelperClient.vintPrefixed(in));\n    DomainSocket sock \u003d peer.getDomainSocket();\n    failureInjector.injectRequestFileDescriptorsFailure();\n    switch (resp.getStatus()) {\n    case SUCCESS:\n      byte buf[] \u003d new byte[1];\n      FileInputStream[] fis \u003d new FileInputStream[2];\n      sock.recvFileInputStreams(fis, buf, 0, buf.length);\n      ShortCircuitReplica replica \u003d null;\n      try {\n        if (fis[0] \u003d\u003d null || fis[1] \u003d\u003d null) {\n          throw new IOException(\"the datanode \" + datanode + \" failed to \" +\n              \"pass a file descriptor (might have reached open file limit).\");\n        }\n\n        ExtendedBlockId key \u003d\n            new ExtendedBlockId(block.getBlockId(), block.getBlockPoolId());\n        if (buf[0] \u003d\u003d USE_RECEIPT_VERIFICATION.getNumber()) {\n          LOG.trace(\"Sending receipt verification byte for slot {}\", slot);\n          sock.getOutputStream().write(0);\n        }\n        replica \u003d new ShortCircuitReplica(key, fis[0], fis[1], cache,\n            Time.monotonicNow(), slot);\n        return new ShortCircuitReplicaInfo(replica);\n      } catch (IOException e) {\n        // This indicates an error reading from disk, or a format error.  Since\n        // it\u0027s not a socket communication problem, we return null rather than\n        // throwing an exception.\n        LOG.warn(this + \": error creating ShortCircuitReplica.\", e);\n        return null;\n      } finally {\n        if (replica \u003d\u003d null) {\n          IOUtilsClient.cleanupWithLogger(DFSClient.LOG, fis[0], fis[1]);\n        }\n      }\n    case ERROR_UNSUPPORTED:\n      if (!resp.hasShortCircuitAccessVersion()) {\n        LOG.warn(\"short-circuit read access is disabled for \" +\n            \"DataNode \" + datanode + \".  reason: \" + resp.getMessage());\n        clientContext.getDomainSocketFactory()\n            .disableShortCircuitForPath(pathInfo.getPath());\n      } else {\n        LOG.warn(\"short-circuit read access for the file \" +\n            fileName + \" is disabled for DataNode \" + datanode +\n            \".  reason: \" + resp.getMessage());\n      }\n      return null;\n    case ERROR_ACCESS_TOKEN:\n      String msg \u003d \"access control error while \" +\n          \"attempting to set up short-circuit access to \" +\n          fileName + resp.getMessage();\n      LOG.debug(\"{}:{}\", this, msg);\n      return new ShortCircuitReplicaInfo(new InvalidToken(msg));\n    default:\n      final long expiration \u003d\n          clientContext.getDomainSocketFactory().getPathExpireSeconds();\n      String disableMsg \u003d \"disabled temporarily for \" + expiration + \" seconds\";\n      if (expiration \u003d\u003d 0) {\n        disableMsg \u003d \"not disabled\";\n      }\n      LOG.warn(\"{}: unknown response code {} while attempting to set up \"\n              + \"short-circuit access. {}. Short-circuit read for \"\n              + \"DataNode {} is {} based on {}.\",\n          this, resp.getStatus(), resp.getMessage(), datanode,\n          disableMsg, DFS_DOMAIN_SOCKET_DISABLE_INTERVAL_SECOND_KEY);\n      clientContext.getDomainSocketFactory()\n          .disableShortCircuitForPath(pathInfo.getPath());\n      return null;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/client/impl/BlockReaderFactory.java",
      "extendedDetails": {}
    },
    "0247cb6318507afe06816e337a19f396afc53efa": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13121. NPE when request file descriptors when SC read. Contributed by Zsolt Venczel.\n",
      "commitDate": "06/07/18 2:59 PM",
      "commitName": "0247cb6318507afe06816e337a19f396afc53efa",
      "commitAuthor": "Wei-Chiu Chuang",
      "commitDateOld": "02/07/18 3:11 AM",
      "commitNameOld": "5d748bd056a32f2c6922514cd0c5b31d866a9919",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 4.49,
      "commitsBetweenForRepo": 27,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,75 +1,80 @@\n   private ShortCircuitReplicaInfo requestFileDescriptors(DomainPeer peer,\n           Slot slot) throws IOException {\n     ShortCircuitCache cache \u003d clientContext.getShortCircuitCache();\n     final DataOutputStream out \u003d\n         new DataOutputStream(new BufferedOutputStream(peer.getOutputStream()));\n     SlotId slotId \u003d slot \u003d\u003d null ? null : slot.getSlotId();\n     new Sender(out).requestShortCircuitFds(block, token, slotId, 1,\n         failureInjector.getSupportsReceiptVerification());\n     DataInputStream in \u003d new DataInputStream(peer.getInputStream());\n     BlockOpResponseProto resp \u003d BlockOpResponseProto.parseFrom(\n         PBHelperClient.vintPrefixed(in));\n     DomainSocket sock \u003d peer.getDomainSocket();\n     failureInjector.injectRequestFileDescriptorsFailure();\n     switch (resp.getStatus()) {\n     case SUCCESS:\n       byte buf[] \u003d new byte[1];\n       FileInputStream[] fis \u003d new FileInputStream[2];\n       sock.recvFileInputStreams(fis, buf, 0, buf.length);\n       ShortCircuitReplica replica \u003d null;\n       try {\n+        if (fis[0] \u003d\u003d null || fis[1] \u003d\u003d null) {\n+          throw new IOException(\"the datanode \" + datanode + \" failed to \" +\n+              \"pass a file descriptor (might have reached open file limit).\");\n+        }\n+\n         ExtendedBlockId key \u003d\n             new ExtendedBlockId(block.getBlockId(), block.getBlockPoolId());\n         if (buf[0] \u003d\u003d USE_RECEIPT_VERIFICATION.getNumber()) {\n           LOG.trace(\"Sending receipt verification byte for slot {}\", slot);\n           sock.getOutputStream().write(0);\n         }\n         replica \u003d new ShortCircuitReplica(key, fis[0], fis[1], cache,\n             Time.monotonicNow(), slot);\n         return new ShortCircuitReplicaInfo(replica);\n       } catch (IOException e) {\n         // This indicates an error reading from disk, or a format error.  Since\n         // it\u0027s not a socket communication problem, we return null rather than\n         // throwing an exception.\n         LOG.warn(this + \": error creating ShortCircuitReplica.\", e);\n         return null;\n       } finally {\n         if (replica \u003d\u003d null) {\n           IOUtilsClient.cleanup(DFSClient.LOG, fis[0], fis[1]);\n         }\n       }\n     case ERROR_UNSUPPORTED:\n       if (!resp.hasShortCircuitAccessVersion()) {\n         LOG.warn(\"short-circuit read access is disabled for \" +\n             \"DataNode \" + datanode + \".  reason: \" + resp.getMessage());\n         clientContext.getDomainSocketFactory()\n             .disableShortCircuitForPath(pathInfo.getPath());\n       } else {\n         LOG.warn(\"short-circuit read access for the file \" +\n             fileName + \" is disabled for DataNode \" + datanode +\n             \".  reason: \" + resp.getMessage());\n       }\n       return null;\n     case ERROR_ACCESS_TOKEN:\n       String msg \u003d \"access control error while \" +\n           \"attempting to set up short-circuit access to \" +\n           fileName + resp.getMessage();\n       LOG.debug(\"{}:{}\", this, msg);\n       return new ShortCircuitReplicaInfo(new InvalidToken(msg));\n     default:\n       final long expiration \u003d\n           clientContext.getDomainSocketFactory().getPathExpireSeconds();\n       String disableMsg \u003d \"disabled temporarily for \" + expiration + \" seconds\";\n       if (expiration \u003d\u003d 0) {\n         disableMsg \u003d \"not disabled\";\n       }\n       LOG.warn(\"{}: unknown response code {} while attempting to set up \"\n               + \"short-circuit access. {}. Short-circuit read for \"\n               + \"DataNode {} is {} based on {}.\",\n           this, resp.getStatus(), resp.getMessage(), datanode,\n           disableMsg, DFS_DOMAIN_SOCKET_DISABLE_INTERVAL_SECOND_KEY);\n       clientContext.getDomainSocketFactory()\n           .disableShortCircuitForPath(pathInfo.getPath());\n       return null;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private ShortCircuitReplicaInfo requestFileDescriptors(DomainPeer peer,\n          Slot slot) throws IOException {\n    ShortCircuitCache cache \u003d clientContext.getShortCircuitCache();\n    final DataOutputStream out \u003d\n        new DataOutputStream(new BufferedOutputStream(peer.getOutputStream()));\n    SlotId slotId \u003d slot \u003d\u003d null ? null : slot.getSlotId();\n    new Sender(out).requestShortCircuitFds(block, token, slotId, 1,\n        failureInjector.getSupportsReceiptVerification());\n    DataInputStream in \u003d new DataInputStream(peer.getInputStream());\n    BlockOpResponseProto resp \u003d BlockOpResponseProto.parseFrom(\n        PBHelperClient.vintPrefixed(in));\n    DomainSocket sock \u003d peer.getDomainSocket();\n    failureInjector.injectRequestFileDescriptorsFailure();\n    switch (resp.getStatus()) {\n    case SUCCESS:\n      byte buf[] \u003d new byte[1];\n      FileInputStream[] fis \u003d new FileInputStream[2];\n      sock.recvFileInputStreams(fis, buf, 0, buf.length);\n      ShortCircuitReplica replica \u003d null;\n      try {\n        if (fis[0] \u003d\u003d null || fis[1] \u003d\u003d null) {\n          throw new IOException(\"the datanode \" + datanode + \" failed to \" +\n              \"pass a file descriptor (might have reached open file limit).\");\n        }\n\n        ExtendedBlockId key \u003d\n            new ExtendedBlockId(block.getBlockId(), block.getBlockPoolId());\n        if (buf[0] \u003d\u003d USE_RECEIPT_VERIFICATION.getNumber()) {\n          LOG.trace(\"Sending receipt verification byte for slot {}\", slot);\n          sock.getOutputStream().write(0);\n        }\n        replica \u003d new ShortCircuitReplica(key, fis[0], fis[1], cache,\n            Time.monotonicNow(), slot);\n        return new ShortCircuitReplicaInfo(replica);\n      } catch (IOException e) {\n        // This indicates an error reading from disk, or a format error.  Since\n        // it\u0027s not a socket communication problem, we return null rather than\n        // throwing an exception.\n        LOG.warn(this + \": error creating ShortCircuitReplica.\", e);\n        return null;\n      } finally {\n        if (replica \u003d\u003d null) {\n          IOUtilsClient.cleanup(DFSClient.LOG, fis[0], fis[1]);\n        }\n      }\n    case ERROR_UNSUPPORTED:\n      if (!resp.hasShortCircuitAccessVersion()) {\n        LOG.warn(\"short-circuit read access is disabled for \" +\n            \"DataNode \" + datanode + \".  reason: \" + resp.getMessage());\n        clientContext.getDomainSocketFactory()\n            .disableShortCircuitForPath(pathInfo.getPath());\n      } else {\n        LOG.warn(\"short-circuit read access for the file \" +\n            fileName + \" is disabled for DataNode \" + datanode +\n            \".  reason: \" + resp.getMessage());\n      }\n      return null;\n    case ERROR_ACCESS_TOKEN:\n      String msg \u003d \"access control error while \" +\n          \"attempting to set up short-circuit access to \" +\n          fileName + resp.getMessage();\n      LOG.debug(\"{}:{}\", this, msg);\n      return new ShortCircuitReplicaInfo(new InvalidToken(msg));\n    default:\n      final long expiration \u003d\n          clientContext.getDomainSocketFactory().getPathExpireSeconds();\n      String disableMsg \u003d \"disabled temporarily for \" + expiration + \" seconds\";\n      if (expiration \u003d\u003d 0) {\n        disableMsg \u003d \"not disabled\";\n      }\n      LOG.warn(\"{}: unknown response code {} while attempting to set up \"\n              + \"short-circuit access. {}. Short-circuit read for \"\n              + \"DataNode {} is {} based on {}.\",\n          this, resp.getStatus(), resp.getMessage(), datanode,\n          disableMsg, DFS_DOMAIN_SOCKET_DISABLE_INTERVAL_SECOND_KEY);\n      clientContext.getDomainSocketFactory()\n          .disableShortCircuitForPath(pathInfo.getPath());\n      return null;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/client/impl/BlockReaderFactory.java",
      "extendedDetails": {}
    },
    "2e7331ca264dd366b975f3c8e610cf84eb8cc155": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12528. Add an option to not disable short-circuit reads on failures. Contributed by Xiao Chen.\n",
      "commitDate": "30/01/18 3:25 PM",
      "commitName": "2e7331ca264dd366b975f3c8e610cf84eb8cc155",
      "commitAuthor": "Weiwei Yang",
      "commitDateOld": "01/11/17 1:41 AM",
      "commitNameOld": "56b88b06705441f6f171eec7fb2fa77946ca204b",
      "commitAuthorOld": "Weiwei Yang",
      "daysBetweenCommits": 90.61,
      "commitsBetweenForRepo": 588,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,68 +1,75 @@\n   private ShortCircuitReplicaInfo requestFileDescriptors(DomainPeer peer,\n           Slot slot) throws IOException {\n     ShortCircuitCache cache \u003d clientContext.getShortCircuitCache();\n     final DataOutputStream out \u003d\n         new DataOutputStream(new BufferedOutputStream(peer.getOutputStream()));\n     SlotId slotId \u003d slot \u003d\u003d null ? null : slot.getSlotId();\n     new Sender(out).requestShortCircuitFds(block, token, slotId, 1,\n         failureInjector.getSupportsReceiptVerification());\n     DataInputStream in \u003d new DataInputStream(peer.getInputStream());\n     BlockOpResponseProto resp \u003d BlockOpResponseProto.parseFrom(\n         PBHelperClient.vintPrefixed(in));\n     DomainSocket sock \u003d peer.getDomainSocket();\n     failureInjector.injectRequestFileDescriptorsFailure();\n     switch (resp.getStatus()) {\n     case SUCCESS:\n       byte buf[] \u003d new byte[1];\n       FileInputStream[] fis \u003d new FileInputStream[2];\n       sock.recvFileInputStreams(fis, buf, 0, buf.length);\n       ShortCircuitReplica replica \u003d null;\n       try {\n         ExtendedBlockId key \u003d\n             new ExtendedBlockId(block.getBlockId(), block.getBlockPoolId());\n         if (buf[0] \u003d\u003d USE_RECEIPT_VERIFICATION.getNumber()) {\n           LOG.trace(\"Sending receipt verification byte for slot {}\", slot);\n           sock.getOutputStream().write(0);\n         }\n         replica \u003d new ShortCircuitReplica(key, fis[0], fis[1], cache,\n             Time.monotonicNow(), slot);\n         return new ShortCircuitReplicaInfo(replica);\n       } catch (IOException e) {\n         // This indicates an error reading from disk, or a format error.  Since\n         // it\u0027s not a socket communication problem, we return null rather than\n         // throwing an exception.\n         LOG.warn(this + \": error creating ShortCircuitReplica.\", e);\n         return null;\n       } finally {\n         if (replica \u003d\u003d null) {\n           IOUtilsClient.cleanup(DFSClient.LOG, fis[0], fis[1]);\n         }\n       }\n     case ERROR_UNSUPPORTED:\n       if (!resp.hasShortCircuitAccessVersion()) {\n         LOG.warn(\"short-circuit read access is disabled for \" +\n             \"DataNode \" + datanode + \".  reason: \" + resp.getMessage());\n         clientContext.getDomainSocketFactory()\n             .disableShortCircuitForPath(pathInfo.getPath());\n       } else {\n         LOG.warn(\"short-circuit read access for the file \" +\n             fileName + \" is disabled for DataNode \" + datanode +\n             \".  reason: \" + resp.getMessage());\n       }\n       return null;\n     case ERROR_ACCESS_TOKEN:\n       String msg \u003d \"access control error while \" +\n           \"attempting to set up short-circuit access to \" +\n           fileName + resp.getMessage();\n       LOG.debug(\"{}:{}\", this, msg);\n       return new ShortCircuitReplicaInfo(new InvalidToken(msg));\n     default:\n-      LOG.warn(this + \": unknown response code \" + resp.getStatus() +\n-          \" while attempting to set up short-circuit access. \" +\n-          resp.getMessage() + \". Disabling short-circuit read for DataNode \"\n-          + datanode + \" temporarily.\");\n+      final long expiration \u003d\n+          clientContext.getDomainSocketFactory().getPathExpireSeconds();\n+      String disableMsg \u003d \"disabled temporarily for \" + expiration + \" seconds\";\n+      if (expiration \u003d\u003d 0) {\n+        disableMsg \u003d \"not disabled\";\n+      }\n+      LOG.warn(\"{}: unknown response code {} while attempting to set up \"\n+              + \"short-circuit access. {}. Short-circuit read for \"\n+              + \"DataNode {} is {} based on {}.\",\n+          this, resp.getStatus(), resp.getMessage(), datanode,\n+          disableMsg, DFS_DOMAIN_SOCKET_DISABLE_INTERVAL_SECOND_KEY);\n       clientContext.getDomainSocketFactory()\n           .disableShortCircuitForPath(pathInfo.getPath());\n       return null;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private ShortCircuitReplicaInfo requestFileDescriptors(DomainPeer peer,\n          Slot slot) throws IOException {\n    ShortCircuitCache cache \u003d clientContext.getShortCircuitCache();\n    final DataOutputStream out \u003d\n        new DataOutputStream(new BufferedOutputStream(peer.getOutputStream()));\n    SlotId slotId \u003d slot \u003d\u003d null ? null : slot.getSlotId();\n    new Sender(out).requestShortCircuitFds(block, token, slotId, 1,\n        failureInjector.getSupportsReceiptVerification());\n    DataInputStream in \u003d new DataInputStream(peer.getInputStream());\n    BlockOpResponseProto resp \u003d BlockOpResponseProto.parseFrom(\n        PBHelperClient.vintPrefixed(in));\n    DomainSocket sock \u003d peer.getDomainSocket();\n    failureInjector.injectRequestFileDescriptorsFailure();\n    switch (resp.getStatus()) {\n    case SUCCESS:\n      byte buf[] \u003d new byte[1];\n      FileInputStream[] fis \u003d new FileInputStream[2];\n      sock.recvFileInputStreams(fis, buf, 0, buf.length);\n      ShortCircuitReplica replica \u003d null;\n      try {\n        ExtendedBlockId key \u003d\n            new ExtendedBlockId(block.getBlockId(), block.getBlockPoolId());\n        if (buf[0] \u003d\u003d USE_RECEIPT_VERIFICATION.getNumber()) {\n          LOG.trace(\"Sending receipt verification byte for slot {}\", slot);\n          sock.getOutputStream().write(0);\n        }\n        replica \u003d new ShortCircuitReplica(key, fis[0], fis[1], cache,\n            Time.monotonicNow(), slot);\n        return new ShortCircuitReplicaInfo(replica);\n      } catch (IOException e) {\n        // This indicates an error reading from disk, or a format error.  Since\n        // it\u0027s not a socket communication problem, we return null rather than\n        // throwing an exception.\n        LOG.warn(this + \": error creating ShortCircuitReplica.\", e);\n        return null;\n      } finally {\n        if (replica \u003d\u003d null) {\n          IOUtilsClient.cleanup(DFSClient.LOG, fis[0], fis[1]);\n        }\n      }\n    case ERROR_UNSUPPORTED:\n      if (!resp.hasShortCircuitAccessVersion()) {\n        LOG.warn(\"short-circuit read access is disabled for \" +\n            \"DataNode \" + datanode + \".  reason: \" + resp.getMessage());\n        clientContext.getDomainSocketFactory()\n            .disableShortCircuitForPath(pathInfo.getPath());\n      } else {\n        LOG.warn(\"short-circuit read access for the file \" +\n            fileName + \" is disabled for DataNode \" + datanode +\n            \".  reason: \" + resp.getMessage());\n      }\n      return null;\n    case ERROR_ACCESS_TOKEN:\n      String msg \u003d \"access control error while \" +\n          \"attempting to set up short-circuit access to \" +\n          fileName + resp.getMessage();\n      LOG.debug(\"{}:{}\", this, msg);\n      return new ShortCircuitReplicaInfo(new InvalidToken(msg));\n    default:\n      final long expiration \u003d\n          clientContext.getDomainSocketFactory().getPathExpireSeconds();\n      String disableMsg \u003d \"disabled temporarily for \" + expiration + \" seconds\";\n      if (expiration \u003d\u003d 0) {\n        disableMsg \u003d \"not disabled\";\n      }\n      LOG.warn(\"{}: unknown response code {} while attempting to set up \"\n              + \"short-circuit access. {}. Short-circuit read for \"\n              + \"DataNode {} is {} based on {}.\",\n          this, resp.getStatus(), resp.getMessage(), datanode,\n          disableMsg, DFS_DOMAIN_SOCKET_DISABLE_INTERVAL_SECOND_KEY);\n      clientContext.getDomainSocketFactory()\n          .disableShortCircuitForPath(pathInfo.getPath());\n      return null;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/client/impl/BlockReaderFactory.java",
      "extendedDetails": {}
    },
    "56b88b06705441f6f171eec7fb2fa77946ca204b": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12744. More logs when short-circuit read is failed and disabled. Contributed by Weiwei Yang.\n",
      "commitDate": "01/11/17 1:41 AM",
      "commitName": "56b88b06705441f6f171eec7fb2fa77946ca204b",
      "commitAuthor": "Weiwei Yang",
      "commitDateOld": "02/07/16 8:56 PM",
      "commitNameOld": "8b281bce85474501868d68f8d5590a6086abb7b7",
      "commitAuthorOld": "Kai Zheng",
      "daysBetweenCommits": 486.2,
      "commitsBetweenForRepo": 3259,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,67 +1,68 @@\n   private ShortCircuitReplicaInfo requestFileDescriptors(DomainPeer peer,\n           Slot slot) throws IOException {\n     ShortCircuitCache cache \u003d clientContext.getShortCircuitCache();\n     final DataOutputStream out \u003d\n         new DataOutputStream(new BufferedOutputStream(peer.getOutputStream()));\n     SlotId slotId \u003d slot \u003d\u003d null ? null : slot.getSlotId();\n     new Sender(out).requestShortCircuitFds(block, token, slotId, 1,\n         failureInjector.getSupportsReceiptVerification());\n     DataInputStream in \u003d new DataInputStream(peer.getInputStream());\n     BlockOpResponseProto resp \u003d BlockOpResponseProto.parseFrom(\n         PBHelperClient.vintPrefixed(in));\n     DomainSocket sock \u003d peer.getDomainSocket();\n     failureInjector.injectRequestFileDescriptorsFailure();\n     switch (resp.getStatus()) {\n     case SUCCESS:\n       byte buf[] \u003d new byte[1];\n       FileInputStream[] fis \u003d new FileInputStream[2];\n       sock.recvFileInputStreams(fis, buf, 0, buf.length);\n       ShortCircuitReplica replica \u003d null;\n       try {\n         ExtendedBlockId key \u003d\n             new ExtendedBlockId(block.getBlockId(), block.getBlockPoolId());\n         if (buf[0] \u003d\u003d USE_RECEIPT_VERIFICATION.getNumber()) {\n           LOG.trace(\"Sending receipt verification byte for slot {}\", slot);\n           sock.getOutputStream().write(0);\n         }\n         replica \u003d new ShortCircuitReplica(key, fis[0], fis[1], cache,\n             Time.monotonicNow(), slot);\n         return new ShortCircuitReplicaInfo(replica);\n       } catch (IOException e) {\n         // This indicates an error reading from disk, or a format error.  Since\n         // it\u0027s not a socket communication problem, we return null rather than\n         // throwing an exception.\n         LOG.warn(this + \": error creating ShortCircuitReplica.\", e);\n         return null;\n       } finally {\n         if (replica \u003d\u003d null) {\n           IOUtilsClient.cleanup(DFSClient.LOG, fis[0], fis[1]);\n         }\n       }\n     case ERROR_UNSUPPORTED:\n       if (!resp.hasShortCircuitAccessVersion()) {\n         LOG.warn(\"short-circuit read access is disabled for \" +\n             \"DataNode \" + datanode + \".  reason: \" + resp.getMessage());\n         clientContext.getDomainSocketFactory()\n             .disableShortCircuitForPath(pathInfo.getPath());\n       } else {\n         LOG.warn(\"short-circuit read access for the file \" +\n             fileName + \" is disabled for DataNode \" + datanode +\n             \".  reason: \" + resp.getMessage());\n       }\n       return null;\n     case ERROR_ACCESS_TOKEN:\n       String msg \u003d \"access control error while \" +\n           \"attempting to set up short-circuit access to \" +\n           fileName + resp.getMessage();\n       LOG.debug(\"{}:{}\", this, msg);\n       return new ShortCircuitReplicaInfo(new InvalidToken(msg));\n     default:\n       LOG.warn(this + \": unknown response code \" + resp.getStatus() +\n           \" while attempting to set up short-circuit access. \" +\n-          resp.getMessage());\n+          resp.getMessage() + \". Disabling short-circuit read for DataNode \"\n+          + datanode + \" temporarily.\");\n       clientContext.getDomainSocketFactory()\n           .disableShortCircuitForPath(pathInfo.getPath());\n       return null;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private ShortCircuitReplicaInfo requestFileDescriptors(DomainPeer peer,\n          Slot slot) throws IOException {\n    ShortCircuitCache cache \u003d clientContext.getShortCircuitCache();\n    final DataOutputStream out \u003d\n        new DataOutputStream(new BufferedOutputStream(peer.getOutputStream()));\n    SlotId slotId \u003d slot \u003d\u003d null ? null : slot.getSlotId();\n    new Sender(out).requestShortCircuitFds(block, token, slotId, 1,\n        failureInjector.getSupportsReceiptVerification());\n    DataInputStream in \u003d new DataInputStream(peer.getInputStream());\n    BlockOpResponseProto resp \u003d BlockOpResponseProto.parseFrom(\n        PBHelperClient.vintPrefixed(in));\n    DomainSocket sock \u003d peer.getDomainSocket();\n    failureInjector.injectRequestFileDescriptorsFailure();\n    switch (resp.getStatus()) {\n    case SUCCESS:\n      byte buf[] \u003d new byte[1];\n      FileInputStream[] fis \u003d new FileInputStream[2];\n      sock.recvFileInputStreams(fis, buf, 0, buf.length);\n      ShortCircuitReplica replica \u003d null;\n      try {\n        ExtendedBlockId key \u003d\n            new ExtendedBlockId(block.getBlockId(), block.getBlockPoolId());\n        if (buf[0] \u003d\u003d USE_RECEIPT_VERIFICATION.getNumber()) {\n          LOG.trace(\"Sending receipt verification byte for slot {}\", slot);\n          sock.getOutputStream().write(0);\n        }\n        replica \u003d new ShortCircuitReplica(key, fis[0], fis[1], cache,\n            Time.monotonicNow(), slot);\n        return new ShortCircuitReplicaInfo(replica);\n      } catch (IOException e) {\n        // This indicates an error reading from disk, or a format error.  Since\n        // it\u0027s not a socket communication problem, we return null rather than\n        // throwing an exception.\n        LOG.warn(this + \": error creating ShortCircuitReplica.\", e);\n        return null;\n      } finally {\n        if (replica \u003d\u003d null) {\n          IOUtilsClient.cleanup(DFSClient.LOG, fis[0], fis[1]);\n        }\n      }\n    case ERROR_UNSUPPORTED:\n      if (!resp.hasShortCircuitAccessVersion()) {\n        LOG.warn(\"short-circuit read access is disabled for \" +\n            \"DataNode \" + datanode + \".  reason: \" + resp.getMessage());\n        clientContext.getDomainSocketFactory()\n            .disableShortCircuitForPath(pathInfo.getPath());\n      } else {\n        LOG.warn(\"short-circuit read access for the file \" +\n            fileName + \" is disabled for DataNode \" + datanode +\n            \".  reason: \" + resp.getMessage());\n      }\n      return null;\n    case ERROR_ACCESS_TOKEN:\n      String msg \u003d \"access control error while \" +\n          \"attempting to set up short-circuit access to \" +\n          fileName + resp.getMessage();\n      LOG.debug(\"{}:{}\", this, msg);\n      return new ShortCircuitReplicaInfo(new InvalidToken(msg));\n    default:\n      LOG.warn(this + \": unknown response code \" + resp.getStatus() +\n          \" while attempting to set up short-circuit access. \" +\n          resp.getMessage() + \". Disabling short-circuit read for DataNode \"\n          + datanode + \" temporarily.\");\n      clientContext.getDomainSocketFactory()\n          .disableShortCircuitForPath(pathInfo.getPath());\n      return null;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/client/impl/BlockReaderFactory.java",
      "extendedDetails": {}
    },
    "f308561f1d885491b88db73ac63003202056d661": {
      "type": "Yfilerename",
      "commitMessage": "HDFS-8057 Move BlockReader implementation to the client implementation package.  Contributed by Takanobu Asanuma\n",
      "commitDate": "25/04/16 12:01 PM",
      "commitName": "f308561f1d885491b88db73ac63003202056d661",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "commitDateOld": "25/04/16 9:38 AM",
      "commitNameOld": "10f0f7851a3255caab775777e8fb6c2781d97062",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private ShortCircuitReplicaInfo requestFileDescriptors(DomainPeer peer,\n          Slot slot) throws IOException {\n    ShortCircuitCache cache \u003d clientContext.getShortCircuitCache();\n    final DataOutputStream out \u003d\n        new DataOutputStream(new BufferedOutputStream(peer.getOutputStream()));\n    SlotId slotId \u003d slot \u003d\u003d null ? null : slot.getSlotId();\n    new Sender(out).requestShortCircuitFds(block, token, slotId, 1,\n        failureInjector.getSupportsReceiptVerification());\n    DataInputStream in \u003d new DataInputStream(peer.getInputStream());\n    BlockOpResponseProto resp \u003d BlockOpResponseProto.parseFrom(\n        PBHelperClient.vintPrefixed(in));\n    DomainSocket sock \u003d peer.getDomainSocket();\n    failureInjector.injectRequestFileDescriptorsFailure();\n    switch (resp.getStatus()) {\n    case SUCCESS:\n      byte buf[] \u003d new byte[1];\n      FileInputStream[] fis \u003d new FileInputStream[2];\n      sock.recvFileInputStreams(fis, buf, 0, buf.length);\n      ShortCircuitReplica replica \u003d null;\n      try {\n        ExtendedBlockId key \u003d\n            new ExtendedBlockId(block.getBlockId(), block.getBlockPoolId());\n        if (buf[0] \u003d\u003d USE_RECEIPT_VERIFICATION.getNumber()) {\n          LOG.trace(\"Sending receipt verification byte for slot {}\", slot);\n          sock.getOutputStream().write(0);\n        }\n        replica \u003d new ShortCircuitReplica(key, fis[0], fis[1], cache,\n            Time.monotonicNow(), slot);\n        return new ShortCircuitReplicaInfo(replica);\n      } catch (IOException e) {\n        // This indicates an error reading from disk, or a format error.  Since\n        // it\u0027s not a socket communication problem, we return null rather than\n        // throwing an exception.\n        LOG.warn(this + \": error creating ShortCircuitReplica.\", e);\n        return null;\n      } finally {\n        if (replica \u003d\u003d null) {\n          IOUtilsClient.cleanup(DFSClient.LOG, fis[0], fis[1]);\n        }\n      }\n    case ERROR_UNSUPPORTED:\n      if (!resp.hasShortCircuitAccessVersion()) {\n        LOG.warn(\"short-circuit read access is disabled for \" +\n            \"DataNode \" + datanode + \".  reason: \" + resp.getMessage());\n        clientContext.getDomainSocketFactory()\n            .disableShortCircuitForPath(pathInfo.getPath());\n      } else {\n        LOG.warn(\"short-circuit read access for the file \" +\n            fileName + \" is disabled for DataNode \" + datanode +\n            \".  reason: \" + resp.getMessage());\n      }\n      return null;\n    case ERROR_ACCESS_TOKEN:\n      String msg \u003d \"access control error while \" +\n          \"attempting to set up short-circuit access to \" +\n          fileName + resp.getMessage();\n      LOG.debug(\"{}:{}\", this, msg);\n      return new ShortCircuitReplicaInfo(new InvalidToken(msg));\n    default:\n      LOG.warn(this + \": unknown response code \" + resp.getStatus() +\n          \" while attempting to set up short-circuit access. \" +\n          resp.getMessage());\n      clientContext.getDomainSocketFactory()\n          .disableShortCircuitForPath(pathInfo.getPath());\n      return null;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/client/impl/BlockReaderFactory.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/BlockReaderFactory.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/client/impl/BlockReaderFactory.java"
      }
    },
    "39285e6a1978ea5e53bdc1b0aef62421382124a8": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8971. Remove guards when calling LOG.debug() and LOG.trace() in client package. Contributed by Mingliang Liu.\n",
      "commitDate": "29/09/15 5:52 PM",
      "commitName": "39285e6a1978ea5e53bdc1b0aef62421382124a8",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "29/09/15 5:51 PM",
      "commitNameOld": "6ee0539ede78b640f01c5eac18ded161182a7835",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,69 +1,67 @@\n   private ShortCircuitReplicaInfo requestFileDescriptors(DomainPeer peer,\n           Slot slot) throws IOException {\n     ShortCircuitCache cache \u003d clientContext.getShortCircuitCache();\n     final DataOutputStream out \u003d\n         new DataOutputStream(new BufferedOutputStream(peer.getOutputStream()));\n     SlotId slotId \u003d slot \u003d\u003d null ? null : slot.getSlotId();\n     new Sender(out).requestShortCircuitFds(block, token, slotId, 1,\n         failureInjector.getSupportsReceiptVerification());\n     DataInputStream in \u003d new DataInputStream(peer.getInputStream());\n     BlockOpResponseProto resp \u003d BlockOpResponseProto.parseFrom(\n         PBHelperClient.vintPrefixed(in));\n     DomainSocket sock \u003d peer.getDomainSocket();\n     failureInjector.injectRequestFileDescriptorsFailure();\n     switch (resp.getStatus()) {\n     case SUCCESS:\n       byte buf[] \u003d new byte[1];\n       FileInputStream fis[] \u003d new FileInputStream[2];\n       sock.recvFileInputStreams(fis, buf, 0, buf.length);\n       ShortCircuitReplica replica \u003d null;\n       try {\n         ExtendedBlockId key \u003d\n             new ExtendedBlockId(block.getBlockId(), block.getBlockPoolId());\n         if (buf[0] \u003d\u003d USE_RECEIPT_VERIFICATION.getNumber()) {\n-          LOG.trace(\"Sending receipt verification byte for slot \" + slot);\n+          LOG.trace(\"Sending receipt verification byte for slot {}\", slot);\n           sock.getOutputStream().write(0);\n         }\n         replica \u003d new ShortCircuitReplica(key, fis[0], fis[1], cache,\n             Time.monotonicNow(), slot);\n         return new ShortCircuitReplicaInfo(replica);\n       } catch (IOException e) {\n         // This indicates an error reading from disk, or a format error.  Since\n         // it\u0027s not a socket communication problem, we return null rather than\n         // throwing an exception.\n         LOG.warn(this + \": error creating ShortCircuitReplica.\", e);\n         return null;\n       } finally {\n         if (replica \u003d\u003d null) {\n           IOUtilsClient.cleanup(DFSClient.LOG, fis[0], fis[1]);\n         }\n       }\n     case ERROR_UNSUPPORTED:\n       if (!resp.hasShortCircuitAccessVersion()) {\n         LOG.warn(\"short-circuit read access is disabled for \" +\n             \"DataNode \" + datanode + \".  reason: \" + resp.getMessage());\n         clientContext.getDomainSocketFactory()\n             .disableShortCircuitForPath(pathInfo.getPath());\n       } else {\n         LOG.warn(\"short-circuit read access for the file \" +\n             fileName + \" is disabled for DataNode \" + datanode +\n             \".  reason: \" + resp.getMessage());\n       }\n       return null;\n     case ERROR_ACCESS_TOKEN:\n       String msg \u003d \"access control error while \" +\n           \"attempting to set up short-circuit access to \" +\n           fileName + resp.getMessage();\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(this + \":\" + msg);\n-      }\n+      LOG.debug(\"{}:{}\", this, msg);\n       return new ShortCircuitReplicaInfo(new InvalidToken(msg));\n     default:\n       LOG.warn(this + \": unknown response code \" + resp.getStatus() +\n           \" while attempting to set up short-circuit access. \" +\n           resp.getMessage());\n       clientContext.getDomainSocketFactory()\n           .disableShortCircuitForPath(pathInfo.getPath());\n       return null;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private ShortCircuitReplicaInfo requestFileDescriptors(DomainPeer peer,\n          Slot slot) throws IOException {\n    ShortCircuitCache cache \u003d clientContext.getShortCircuitCache();\n    final DataOutputStream out \u003d\n        new DataOutputStream(new BufferedOutputStream(peer.getOutputStream()));\n    SlotId slotId \u003d slot \u003d\u003d null ? null : slot.getSlotId();\n    new Sender(out).requestShortCircuitFds(block, token, slotId, 1,\n        failureInjector.getSupportsReceiptVerification());\n    DataInputStream in \u003d new DataInputStream(peer.getInputStream());\n    BlockOpResponseProto resp \u003d BlockOpResponseProto.parseFrom(\n        PBHelperClient.vintPrefixed(in));\n    DomainSocket sock \u003d peer.getDomainSocket();\n    failureInjector.injectRequestFileDescriptorsFailure();\n    switch (resp.getStatus()) {\n    case SUCCESS:\n      byte buf[] \u003d new byte[1];\n      FileInputStream fis[] \u003d new FileInputStream[2];\n      sock.recvFileInputStreams(fis, buf, 0, buf.length);\n      ShortCircuitReplica replica \u003d null;\n      try {\n        ExtendedBlockId key \u003d\n            new ExtendedBlockId(block.getBlockId(), block.getBlockPoolId());\n        if (buf[0] \u003d\u003d USE_RECEIPT_VERIFICATION.getNumber()) {\n          LOG.trace(\"Sending receipt verification byte for slot {}\", slot);\n          sock.getOutputStream().write(0);\n        }\n        replica \u003d new ShortCircuitReplica(key, fis[0], fis[1], cache,\n            Time.monotonicNow(), slot);\n        return new ShortCircuitReplicaInfo(replica);\n      } catch (IOException e) {\n        // This indicates an error reading from disk, or a format error.  Since\n        // it\u0027s not a socket communication problem, we return null rather than\n        // throwing an exception.\n        LOG.warn(this + \": error creating ShortCircuitReplica.\", e);\n        return null;\n      } finally {\n        if (replica \u003d\u003d null) {\n          IOUtilsClient.cleanup(DFSClient.LOG, fis[0], fis[1]);\n        }\n      }\n    case ERROR_UNSUPPORTED:\n      if (!resp.hasShortCircuitAccessVersion()) {\n        LOG.warn(\"short-circuit read access is disabled for \" +\n            \"DataNode \" + datanode + \".  reason: \" + resp.getMessage());\n        clientContext.getDomainSocketFactory()\n            .disableShortCircuitForPath(pathInfo.getPath());\n      } else {\n        LOG.warn(\"short-circuit read access for the file \" +\n            fileName + \" is disabled for DataNode \" + datanode +\n            \".  reason: \" + resp.getMessage());\n      }\n      return null;\n    case ERROR_ACCESS_TOKEN:\n      String msg \u003d \"access control error while \" +\n          \"attempting to set up short-circuit access to \" +\n          fileName + resp.getMessage();\n      LOG.debug(\"{}:{}\", this, msg);\n      return new ShortCircuitReplicaInfo(new InvalidToken(msg));\n    default:\n      LOG.warn(this + \": unknown response code \" + resp.getStatus() +\n          \" while attempting to set up short-circuit access. \" +\n          resp.getMessage());\n      clientContext.getDomainSocketFactory()\n          .disableShortCircuitForPath(pathInfo.getPath());\n      return null;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/BlockReaderFactory.java",
      "extendedDetails": {}
    },
    "6ee0539ede78b640f01c5eac18ded161182a7835": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HDFS-9170. Move libhdfs / fuse-dfs / libwebhdfs to hdfs-client. Contributed by Haohui Mai.\"\n\nThis reverts commit d5a9a3daa0224249221ffa7b8bd5751ab2feca56.\n",
      "commitDate": "29/09/15 5:51 PM",
      "commitName": "6ee0539ede78b640f01c5eac18ded161182a7835",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "29/09/15 5:48 PM",
      "commitNameOld": "d5a9a3daa0224249221ffa7b8bd5751ab2feca56",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,67 +1,69 @@\n   private ShortCircuitReplicaInfo requestFileDescriptors(DomainPeer peer,\n           Slot slot) throws IOException {\n     ShortCircuitCache cache \u003d clientContext.getShortCircuitCache();\n     final DataOutputStream out \u003d\n         new DataOutputStream(new BufferedOutputStream(peer.getOutputStream()));\n     SlotId slotId \u003d slot \u003d\u003d null ? null : slot.getSlotId();\n     new Sender(out).requestShortCircuitFds(block, token, slotId, 1,\n         failureInjector.getSupportsReceiptVerification());\n     DataInputStream in \u003d new DataInputStream(peer.getInputStream());\n     BlockOpResponseProto resp \u003d BlockOpResponseProto.parseFrom(\n         PBHelperClient.vintPrefixed(in));\n     DomainSocket sock \u003d peer.getDomainSocket();\n     failureInjector.injectRequestFileDescriptorsFailure();\n     switch (resp.getStatus()) {\n     case SUCCESS:\n       byte buf[] \u003d new byte[1];\n       FileInputStream fis[] \u003d new FileInputStream[2];\n       sock.recvFileInputStreams(fis, buf, 0, buf.length);\n       ShortCircuitReplica replica \u003d null;\n       try {\n         ExtendedBlockId key \u003d\n             new ExtendedBlockId(block.getBlockId(), block.getBlockPoolId());\n         if (buf[0] \u003d\u003d USE_RECEIPT_VERIFICATION.getNumber()) {\n-          LOG.trace(\"Sending receipt verification byte for slot {}\", slot);\n+          LOG.trace(\"Sending receipt verification byte for slot \" + slot);\n           sock.getOutputStream().write(0);\n         }\n         replica \u003d new ShortCircuitReplica(key, fis[0], fis[1], cache,\n             Time.monotonicNow(), slot);\n         return new ShortCircuitReplicaInfo(replica);\n       } catch (IOException e) {\n         // This indicates an error reading from disk, or a format error.  Since\n         // it\u0027s not a socket communication problem, we return null rather than\n         // throwing an exception.\n         LOG.warn(this + \": error creating ShortCircuitReplica.\", e);\n         return null;\n       } finally {\n         if (replica \u003d\u003d null) {\n           IOUtilsClient.cleanup(DFSClient.LOG, fis[0], fis[1]);\n         }\n       }\n     case ERROR_UNSUPPORTED:\n       if (!resp.hasShortCircuitAccessVersion()) {\n         LOG.warn(\"short-circuit read access is disabled for \" +\n             \"DataNode \" + datanode + \".  reason: \" + resp.getMessage());\n         clientContext.getDomainSocketFactory()\n             .disableShortCircuitForPath(pathInfo.getPath());\n       } else {\n         LOG.warn(\"short-circuit read access for the file \" +\n             fileName + \" is disabled for DataNode \" + datanode +\n             \".  reason: \" + resp.getMessage());\n       }\n       return null;\n     case ERROR_ACCESS_TOKEN:\n       String msg \u003d \"access control error while \" +\n           \"attempting to set up short-circuit access to \" +\n           fileName + resp.getMessage();\n-      LOG.debug(\"{}:{}\", this, msg);\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(this + \":\" + msg);\n+      }\n       return new ShortCircuitReplicaInfo(new InvalidToken(msg));\n     default:\n       LOG.warn(this + \": unknown response code \" + resp.getStatus() +\n           \" while attempting to set up short-circuit access. \" +\n           resp.getMessage());\n       clientContext.getDomainSocketFactory()\n           .disableShortCircuitForPath(pathInfo.getPath());\n       return null;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private ShortCircuitReplicaInfo requestFileDescriptors(DomainPeer peer,\n          Slot slot) throws IOException {\n    ShortCircuitCache cache \u003d clientContext.getShortCircuitCache();\n    final DataOutputStream out \u003d\n        new DataOutputStream(new BufferedOutputStream(peer.getOutputStream()));\n    SlotId slotId \u003d slot \u003d\u003d null ? null : slot.getSlotId();\n    new Sender(out).requestShortCircuitFds(block, token, slotId, 1,\n        failureInjector.getSupportsReceiptVerification());\n    DataInputStream in \u003d new DataInputStream(peer.getInputStream());\n    BlockOpResponseProto resp \u003d BlockOpResponseProto.parseFrom(\n        PBHelperClient.vintPrefixed(in));\n    DomainSocket sock \u003d peer.getDomainSocket();\n    failureInjector.injectRequestFileDescriptorsFailure();\n    switch (resp.getStatus()) {\n    case SUCCESS:\n      byte buf[] \u003d new byte[1];\n      FileInputStream fis[] \u003d new FileInputStream[2];\n      sock.recvFileInputStreams(fis, buf, 0, buf.length);\n      ShortCircuitReplica replica \u003d null;\n      try {\n        ExtendedBlockId key \u003d\n            new ExtendedBlockId(block.getBlockId(), block.getBlockPoolId());\n        if (buf[0] \u003d\u003d USE_RECEIPT_VERIFICATION.getNumber()) {\n          LOG.trace(\"Sending receipt verification byte for slot \" + slot);\n          sock.getOutputStream().write(0);\n        }\n        replica \u003d new ShortCircuitReplica(key, fis[0], fis[1], cache,\n            Time.monotonicNow(), slot);\n        return new ShortCircuitReplicaInfo(replica);\n      } catch (IOException e) {\n        // This indicates an error reading from disk, or a format error.  Since\n        // it\u0027s not a socket communication problem, we return null rather than\n        // throwing an exception.\n        LOG.warn(this + \": error creating ShortCircuitReplica.\", e);\n        return null;\n      } finally {\n        if (replica \u003d\u003d null) {\n          IOUtilsClient.cleanup(DFSClient.LOG, fis[0], fis[1]);\n        }\n      }\n    case ERROR_UNSUPPORTED:\n      if (!resp.hasShortCircuitAccessVersion()) {\n        LOG.warn(\"short-circuit read access is disabled for \" +\n            \"DataNode \" + datanode + \".  reason: \" + resp.getMessage());\n        clientContext.getDomainSocketFactory()\n            .disableShortCircuitForPath(pathInfo.getPath());\n      } else {\n        LOG.warn(\"short-circuit read access for the file \" +\n            fileName + \" is disabled for DataNode \" + datanode +\n            \".  reason: \" + resp.getMessage());\n      }\n      return null;\n    case ERROR_ACCESS_TOKEN:\n      String msg \u003d \"access control error while \" +\n          \"attempting to set up short-circuit access to \" +\n          fileName + resp.getMessage();\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(this + \":\" + msg);\n      }\n      return new ShortCircuitReplicaInfo(new InvalidToken(msg));\n    default:\n      LOG.warn(this + \": unknown response code \" + resp.getStatus() +\n          \" while attempting to set up short-circuit access. \" +\n          resp.getMessage());\n      clientContext.getDomainSocketFactory()\n          .disableShortCircuitForPath(pathInfo.getPath());\n      return null;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/BlockReaderFactory.java",
      "extendedDetails": {}
    },
    "d5a9a3daa0224249221ffa7b8bd5751ab2feca56": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9170. Move libhdfs / fuse-dfs / libwebhdfs to hdfs-client. Contributed by Haohui Mai.\n",
      "commitDate": "29/09/15 5:48 PM",
      "commitName": "d5a9a3daa0224249221ffa7b8bd5751ab2feca56",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "28/09/15 1:39 PM",
      "commitNameOld": "e5992ef4df63fbc6a6b8e357b32c647e7837c662",
      "commitAuthorOld": "Lei Xu",
      "daysBetweenCommits": 1.17,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,69 +1,67 @@\n   private ShortCircuitReplicaInfo requestFileDescriptors(DomainPeer peer,\n           Slot slot) throws IOException {\n     ShortCircuitCache cache \u003d clientContext.getShortCircuitCache();\n     final DataOutputStream out \u003d\n         new DataOutputStream(new BufferedOutputStream(peer.getOutputStream()));\n     SlotId slotId \u003d slot \u003d\u003d null ? null : slot.getSlotId();\n     new Sender(out).requestShortCircuitFds(block, token, slotId, 1,\n         failureInjector.getSupportsReceiptVerification());\n     DataInputStream in \u003d new DataInputStream(peer.getInputStream());\n     BlockOpResponseProto resp \u003d BlockOpResponseProto.parseFrom(\n         PBHelperClient.vintPrefixed(in));\n     DomainSocket sock \u003d peer.getDomainSocket();\n     failureInjector.injectRequestFileDescriptorsFailure();\n     switch (resp.getStatus()) {\n     case SUCCESS:\n       byte buf[] \u003d new byte[1];\n       FileInputStream fis[] \u003d new FileInputStream[2];\n       sock.recvFileInputStreams(fis, buf, 0, buf.length);\n       ShortCircuitReplica replica \u003d null;\n       try {\n         ExtendedBlockId key \u003d\n             new ExtendedBlockId(block.getBlockId(), block.getBlockPoolId());\n         if (buf[0] \u003d\u003d USE_RECEIPT_VERIFICATION.getNumber()) {\n-          LOG.trace(\"Sending receipt verification byte for slot \" + slot);\n+          LOG.trace(\"Sending receipt verification byte for slot {}\", slot);\n           sock.getOutputStream().write(0);\n         }\n         replica \u003d new ShortCircuitReplica(key, fis[0], fis[1], cache,\n             Time.monotonicNow(), slot);\n         return new ShortCircuitReplicaInfo(replica);\n       } catch (IOException e) {\n         // This indicates an error reading from disk, or a format error.  Since\n         // it\u0027s not a socket communication problem, we return null rather than\n         // throwing an exception.\n         LOG.warn(this + \": error creating ShortCircuitReplica.\", e);\n         return null;\n       } finally {\n         if (replica \u003d\u003d null) {\n           IOUtilsClient.cleanup(DFSClient.LOG, fis[0], fis[1]);\n         }\n       }\n     case ERROR_UNSUPPORTED:\n       if (!resp.hasShortCircuitAccessVersion()) {\n         LOG.warn(\"short-circuit read access is disabled for \" +\n             \"DataNode \" + datanode + \".  reason: \" + resp.getMessage());\n         clientContext.getDomainSocketFactory()\n             .disableShortCircuitForPath(pathInfo.getPath());\n       } else {\n         LOG.warn(\"short-circuit read access for the file \" +\n             fileName + \" is disabled for DataNode \" + datanode +\n             \".  reason: \" + resp.getMessage());\n       }\n       return null;\n     case ERROR_ACCESS_TOKEN:\n       String msg \u003d \"access control error while \" +\n           \"attempting to set up short-circuit access to \" +\n           fileName + resp.getMessage();\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(this + \":\" + msg);\n-      }\n+      LOG.debug(\"{}:{}\", this, msg);\n       return new ShortCircuitReplicaInfo(new InvalidToken(msg));\n     default:\n       LOG.warn(this + \": unknown response code \" + resp.getStatus() +\n           \" while attempting to set up short-circuit access. \" +\n           resp.getMessage());\n       clientContext.getDomainSocketFactory()\n           .disableShortCircuitForPath(pathInfo.getPath());\n       return null;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private ShortCircuitReplicaInfo requestFileDescriptors(DomainPeer peer,\n          Slot slot) throws IOException {\n    ShortCircuitCache cache \u003d clientContext.getShortCircuitCache();\n    final DataOutputStream out \u003d\n        new DataOutputStream(new BufferedOutputStream(peer.getOutputStream()));\n    SlotId slotId \u003d slot \u003d\u003d null ? null : slot.getSlotId();\n    new Sender(out).requestShortCircuitFds(block, token, slotId, 1,\n        failureInjector.getSupportsReceiptVerification());\n    DataInputStream in \u003d new DataInputStream(peer.getInputStream());\n    BlockOpResponseProto resp \u003d BlockOpResponseProto.parseFrom(\n        PBHelperClient.vintPrefixed(in));\n    DomainSocket sock \u003d peer.getDomainSocket();\n    failureInjector.injectRequestFileDescriptorsFailure();\n    switch (resp.getStatus()) {\n    case SUCCESS:\n      byte buf[] \u003d new byte[1];\n      FileInputStream fis[] \u003d new FileInputStream[2];\n      sock.recvFileInputStreams(fis, buf, 0, buf.length);\n      ShortCircuitReplica replica \u003d null;\n      try {\n        ExtendedBlockId key \u003d\n            new ExtendedBlockId(block.getBlockId(), block.getBlockPoolId());\n        if (buf[0] \u003d\u003d USE_RECEIPT_VERIFICATION.getNumber()) {\n          LOG.trace(\"Sending receipt verification byte for slot {}\", slot);\n          sock.getOutputStream().write(0);\n        }\n        replica \u003d new ShortCircuitReplica(key, fis[0], fis[1], cache,\n            Time.monotonicNow(), slot);\n        return new ShortCircuitReplicaInfo(replica);\n      } catch (IOException e) {\n        // This indicates an error reading from disk, or a format error.  Since\n        // it\u0027s not a socket communication problem, we return null rather than\n        // throwing an exception.\n        LOG.warn(this + \": error creating ShortCircuitReplica.\", e);\n        return null;\n      } finally {\n        if (replica \u003d\u003d null) {\n          IOUtilsClient.cleanup(DFSClient.LOG, fis[0], fis[1]);\n        }\n      }\n    case ERROR_UNSUPPORTED:\n      if (!resp.hasShortCircuitAccessVersion()) {\n        LOG.warn(\"short-circuit read access is disabled for \" +\n            \"DataNode \" + datanode + \".  reason: \" + resp.getMessage());\n        clientContext.getDomainSocketFactory()\n            .disableShortCircuitForPath(pathInfo.getPath());\n      } else {\n        LOG.warn(\"short-circuit read access for the file \" +\n            fileName + \" is disabled for DataNode \" + datanode +\n            \".  reason: \" + resp.getMessage());\n      }\n      return null;\n    case ERROR_ACCESS_TOKEN:\n      String msg \u003d \"access control error while \" +\n          \"attempting to set up short-circuit access to \" +\n          fileName + resp.getMessage();\n      LOG.debug(\"{}:{}\", this, msg);\n      return new ShortCircuitReplicaInfo(new InvalidToken(msg));\n    default:\n      LOG.warn(this + \": unknown response code \" + resp.getStatus() +\n          \" while attempting to set up short-circuit access. \" +\n          resp.getMessage());\n      clientContext.getDomainSocketFactory()\n          .disableShortCircuitForPath(pathInfo.getPath());\n      return null;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/BlockReaderFactory.java",
      "extendedDetails": {}
    },
    "bf37d3d80e5179dea27e5bd5aea804a38aa9934c": {
      "type": "Ymultichange(Yfilerename,Ybodychange)",
      "commitMessage": "HDFS-8053. Move DFSIn/OutputStream and related classes to hadoop-hdfs-client. Contributed by Mingliang Liu.\n",
      "commitDate": "26/09/15 11:08 AM",
      "commitName": "bf37d3d80e5179dea27e5bd5aea804a38aa9934c",
      "commitAuthor": "Haohui Mai",
      "subchanges": [
        {
          "type": "Yfilerename",
          "commitMessage": "HDFS-8053. Move DFSIn/OutputStream and related classes to hadoop-hdfs-client. Contributed by Mingliang Liu.\n",
          "commitDate": "26/09/15 11:08 AM",
          "commitName": "bf37d3d80e5179dea27e5bd5aea804a38aa9934c",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "26/09/15 9:06 AM",
          "commitNameOld": "861b52db242f238d7e36ad75c158025be959a696",
          "commitAuthorOld": "Vinayakumar B",
          "daysBetweenCommits": 0.08,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,69 +1,69 @@\n   private ShortCircuitReplicaInfo requestFileDescriptors(DomainPeer peer,\n           Slot slot) throws IOException {\n     ShortCircuitCache cache \u003d clientContext.getShortCircuitCache();\n     final DataOutputStream out \u003d\n         new DataOutputStream(new BufferedOutputStream(peer.getOutputStream()));\n     SlotId slotId \u003d slot \u003d\u003d null ? null : slot.getSlotId();\n     new Sender(out).requestShortCircuitFds(block, token, slotId, 1,\n         failureInjector.getSupportsReceiptVerification());\n     DataInputStream in \u003d new DataInputStream(peer.getInputStream());\n     BlockOpResponseProto resp \u003d BlockOpResponseProto.parseFrom(\n         PBHelperClient.vintPrefixed(in));\n     DomainSocket sock \u003d peer.getDomainSocket();\n     failureInjector.injectRequestFileDescriptorsFailure();\n     switch (resp.getStatus()) {\n     case SUCCESS:\n       byte buf[] \u003d new byte[1];\n       FileInputStream fis[] \u003d new FileInputStream[2];\n       sock.recvFileInputStreams(fis, buf, 0, buf.length);\n       ShortCircuitReplica replica \u003d null;\n       try {\n         ExtendedBlockId key \u003d\n             new ExtendedBlockId(block.getBlockId(), block.getBlockPoolId());\n         if (buf[0] \u003d\u003d USE_RECEIPT_VERIFICATION.getNumber()) {\n           LOG.trace(\"Sending receipt verification byte for slot \" + slot);\n           sock.getOutputStream().write(0);\n         }\n         replica \u003d new ShortCircuitReplica(key, fis[0], fis[1], cache,\n             Time.monotonicNow(), slot);\n         return new ShortCircuitReplicaInfo(replica);\n       } catch (IOException e) {\n         // This indicates an error reading from disk, or a format error.  Since\n         // it\u0027s not a socket communication problem, we return null rather than\n         // throwing an exception.\n         LOG.warn(this + \": error creating ShortCircuitReplica.\", e);\n         return null;\n       } finally {\n         if (replica \u003d\u003d null) {\n-          IOUtils.cleanup(DFSClient.LOG, fis[0], fis[1]);\n+          IOUtilsClient.cleanup(DFSClient.LOG, fis[0], fis[1]);\n         }\n       }\n     case ERROR_UNSUPPORTED:\n       if (!resp.hasShortCircuitAccessVersion()) {\n         LOG.warn(\"short-circuit read access is disabled for \" +\n             \"DataNode \" + datanode + \".  reason: \" + resp.getMessage());\n         clientContext.getDomainSocketFactory()\n             .disableShortCircuitForPath(pathInfo.getPath());\n       } else {\n         LOG.warn(\"short-circuit read access for the file \" +\n             fileName + \" is disabled for DataNode \" + datanode +\n             \".  reason: \" + resp.getMessage());\n       }\n       return null;\n     case ERROR_ACCESS_TOKEN:\n       String msg \u003d \"access control error while \" +\n           \"attempting to set up short-circuit access to \" +\n           fileName + resp.getMessage();\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(this + \":\" + msg);\n       }\n       return new ShortCircuitReplicaInfo(new InvalidToken(msg));\n     default:\n       LOG.warn(this + \": unknown response code \" + resp.getStatus() +\n           \" while attempting to set up short-circuit access. \" +\n           resp.getMessage());\n       clientContext.getDomainSocketFactory()\n           .disableShortCircuitForPath(pathInfo.getPath());\n       return null;\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private ShortCircuitReplicaInfo requestFileDescriptors(DomainPeer peer,\n          Slot slot) throws IOException {\n    ShortCircuitCache cache \u003d clientContext.getShortCircuitCache();\n    final DataOutputStream out \u003d\n        new DataOutputStream(new BufferedOutputStream(peer.getOutputStream()));\n    SlotId slotId \u003d slot \u003d\u003d null ? null : slot.getSlotId();\n    new Sender(out).requestShortCircuitFds(block, token, slotId, 1,\n        failureInjector.getSupportsReceiptVerification());\n    DataInputStream in \u003d new DataInputStream(peer.getInputStream());\n    BlockOpResponseProto resp \u003d BlockOpResponseProto.parseFrom(\n        PBHelperClient.vintPrefixed(in));\n    DomainSocket sock \u003d peer.getDomainSocket();\n    failureInjector.injectRequestFileDescriptorsFailure();\n    switch (resp.getStatus()) {\n    case SUCCESS:\n      byte buf[] \u003d new byte[1];\n      FileInputStream fis[] \u003d new FileInputStream[2];\n      sock.recvFileInputStreams(fis, buf, 0, buf.length);\n      ShortCircuitReplica replica \u003d null;\n      try {\n        ExtendedBlockId key \u003d\n            new ExtendedBlockId(block.getBlockId(), block.getBlockPoolId());\n        if (buf[0] \u003d\u003d USE_RECEIPT_VERIFICATION.getNumber()) {\n          LOG.trace(\"Sending receipt verification byte for slot \" + slot);\n          sock.getOutputStream().write(0);\n        }\n        replica \u003d new ShortCircuitReplica(key, fis[0], fis[1], cache,\n            Time.monotonicNow(), slot);\n        return new ShortCircuitReplicaInfo(replica);\n      } catch (IOException e) {\n        // This indicates an error reading from disk, or a format error.  Since\n        // it\u0027s not a socket communication problem, we return null rather than\n        // throwing an exception.\n        LOG.warn(this + \": error creating ShortCircuitReplica.\", e);\n        return null;\n      } finally {\n        if (replica \u003d\u003d null) {\n          IOUtilsClient.cleanup(DFSClient.LOG, fis[0], fis[1]);\n        }\n      }\n    case ERROR_UNSUPPORTED:\n      if (!resp.hasShortCircuitAccessVersion()) {\n        LOG.warn(\"short-circuit read access is disabled for \" +\n            \"DataNode \" + datanode + \".  reason: \" + resp.getMessage());\n        clientContext.getDomainSocketFactory()\n            .disableShortCircuitForPath(pathInfo.getPath());\n      } else {\n        LOG.warn(\"short-circuit read access for the file \" +\n            fileName + \" is disabled for DataNode \" + datanode +\n            \".  reason: \" + resp.getMessage());\n      }\n      return null;\n    case ERROR_ACCESS_TOKEN:\n      String msg \u003d \"access control error while \" +\n          \"attempting to set up short-circuit access to \" +\n          fileName + resp.getMessage();\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(this + \":\" + msg);\n      }\n      return new ShortCircuitReplicaInfo(new InvalidToken(msg));\n    default:\n      LOG.warn(this + \": unknown response code \" + resp.getStatus() +\n          \" while attempting to set up short-circuit access. \" +\n          resp.getMessage());\n      clientContext.getDomainSocketFactory()\n          .disableShortCircuitForPath(pathInfo.getPath());\n      return null;\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/BlockReaderFactory.java",
          "extendedDetails": {
            "oldPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/BlockReaderFactory.java",
            "newPath": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/BlockReaderFactory.java"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-8053. Move DFSIn/OutputStream and related classes to hadoop-hdfs-client. Contributed by Mingliang Liu.\n",
          "commitDate": "26/09/15 11:08 AM",
          "commitName": "bf37d3d80e5179dea27e5bd5aea804a38aa9934c",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "26/09/15 9:06 AM",
          "commitNameOld": "861b52db242f238d7e36ad75c158025be959a696",
          "commitAuthorOld": "Vinayakumar B",
          "daysBetweenCommits": 0.08,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,69 +1,69 @@\n   private ShortCircuitReplicaInfo requestFileDescriptors(DomainPeer peer,\n           Slot slot) throws IOException {\n     ShortCircuitCache cache \u003d clientContext.getShortCircuitCache();\n     final DataOutputStream out \u003d\n         new DataOutputStream(new BufferedOutputStream(peer.getOutputStream()));\n     SlotId slotId \u003d slot \u003d\u003d null ? null : slot.getSlotId();\n     new Sender(out).requestShortCircuitFds(block, token, slotId, 1,\n         failureInjector.getSupportsReceiptVerification());\n     DataInputStream in \u003d new DataInputStream(peer.getInputStream());\n     BlockOpResponseProto resp \u003d BlockOpResponseProto.parseFrom(\n         PBHelperClient.vintPrefixed(in));\n     DomainSocket sock \u003d peer.getDomainSocket();\n     failureInjector.injectRequestFileDescriptorsFailure();\n     switch (resp.getStatus()) {\n     case SUCCESS:\n       byte buf[] \u003d new byte[1];\n       FileInputStream fis[] \u003d new FileInputStream[2];\n       sock.recvFileInputStreams(fis, buf, 0, buf.length);\n       ShortCircuitReplica replica \u003d null;\n       try {\n         ExtendedBlockId key \u003d\n             new ExtendedBlockId(block.getBlockId(), block.getBlockPoolId());\n         if (buf[0] \u003d\u003d USE_RECEIPT_VERIFICATION.getNumber()) {\n           LOG.trace(\"Sending receipt verification byte for slot \" + slot);\n           sock.getOutputStream().write(0);\n         }\n         replica \u003d new ShortCircuitReplica(key, fis[0], fis[1], cache,\n             Time.monotonicNow(), slot);\n         return new ShortCircuitReplicaInfo(replica);\n       } catch (IOException e) {\n         // This indicates an error reading from disk, or a format error.  Since\n         // it\u0027s not a socket communication problem, we return null rather than\n         // throwing an exception.\n         LOG.warn(this + \": error creating ShortCircuitReplica.\", e);\n         return null;\n       } finally {\n         if (replica \u003d\u003d null) {\n-          IOUtils.cleanup(DFSClient.LOG, fis[0], fis[1]);\n+          IOUtilsClient.cleanup(DFSClient.LOG, fis[0], fis[1]);\n         }\n       }\n     case ERROR_UNSUPPORTED:\n       if (!resp.hasShortCircuitAccessVersion()) {\n         LOG.warn(\"short-circuit read access is disabled for \" +\n             \"DataNode \" + datanode + \".  reason: \" + resp.getMessage());\n         clientContext.getDomainSocketFactory()\n             .disableShortCircuitForPath(pathInfo.getPath());\n       } else {\n         LOG.warn(\"short-circuit read access for the file \" +\n             fileName + \" is disabled for DataNode \" + datanode +\n             \".  reason: \" + resp.getMessage());\n       }\n       return null;\n     case ERROR_ACCESS_TOKEN:\n       String msg \u003d \"access control error while \" +\n           \"attempting to set up short-circuit access to \" +\n           fileName + resp.getMessage();\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(this + \":\" + msg);\n       }\n       return new ShortCircuitReplicaInfo(new InvalidToken(msg));\n     default:\n       LOG.warn(this + \": unknown response code \" + resp.getStatus() +\n           \" while attempting to set up short-circuit access. \" +\n           resp.getMessage());\n       clientContext.getDomainSocketFactory()\n           .disableShortCircuitForPath(pathInfo.getPath());\n       return null;\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private ShortCircuitReplicaInfo requestFileDescriptors(DomainPeer peer,\n          Slot slot) throws IOException {\n    ShortCircuitCache cache \u003d clientContext.getShortCircuitCache();\n    final DataOutputStream out \u003d\n        new DataOutputStream(new BufferedOutputStream(peer.getOutputStream()));\n    SlotId slotId \u003d slot \u003d\u003d null ? null : slot.getSlotId();\n    new Sender(out).requestShortCircuitFds(block, token, slotId, 1,\n        failureInjector.getSupportsReceiptVerification());\n    DataInputStream in \u003d new DataInputStream(peer.getInputStream());\n    BlockOpResponseProto resp \u003d BlockOpResponseProto.parseFrom(\n        PBHelperClient.vintPrefixed(in));\n    DomainSocket sock \u003d peer.getDomainSocket();\n    failureInjector.injectRequestFileDescriptorsFailure();\n    switch (resp.getStatus()) {\n    case SUCCESS:\n      byte buf[] \u003d new byte[1];\n      FileInputStream fis[] \u003d new FileInputStream[2];\n      sock.recvFileInputStreams(fis, buf, 0, buf.length);\n      ShortCircuitReplica replica \u003d null;\n      try {\n        ExtendedBlockId key \u003d\n            new ExtendedBlockId(block.getBlockId(), block.getBlockPoolId());\n        if (buf[0] \u003d\u003d USE_RECEIPT_VERIFICATION.getNumber()) {\n          LOG.trace(\"Sending receipt verification byte for slot \" + slot);\n          sock.getOutputStream().write(0);\n        }\n        replica \u003d new ShortCircuitReplica(key, fis[0], fis[1], cache,\n            Time.monotonicNow(), slot);\n        return new ShortCircuitReplicaInfo(replica);\n      } catch (IOException e) {\n        // This indicates an error reading from disk, or a format error.  Since\n        // it\u0027s not a socket communication problem, we return null rather than\n        // throwing an exception.\n        LOG.warn(this + \": error creating ShortCircuitReplica.\", e);\n        return null;\n      } finally {\n        if (replica \u003d\u003d null) {\n          IOUtilsClient.cleanup(DFSClient.LOG, fis[0], fis[1]);\n        }\n      }\n    case ERROR_UNSUPPORTED:\n      if (!resp.hasShortCircuitAccessVersion()) {\n        LOG.warn(\"short-circuit read access is disabled for \" +\n            \"DataNode \" + datanode + \".  reason: \" + resp.getMessage());\n        clientContext.getDomainSocketFactory()\n            .disableShortCircuitForPath(pathInfo.getPath());\n      } else {\n        LOG.warn(\"short-circuit read access for the file \" +\n            fileName + \" is disabled for DataNode \" + datanode +\n            \".  reason: \" + resp.getMessage());\n      }\n      return null;\n    case ERROR_ACCESS_TOKEN:\n      String msg \u003d \"access control error while \" +\n          \"attempting to set up short-circuit access to \" +\n          fileName + resp.getMessage();\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(this + \":\" + msg);\n      }\n      return new ShortCircuitReplicaInfo(new InvalidToken(msg));\n    default:\n      LOG.warn(this + \": unknown response code \" + resp.getStatus() +\n          \" while attempting to set up short-circuit access. \" +\n          resp.getMessage());\n      clientContext.getDomainSocketFactory()\n          .disableShortCircuitForPath(pathInfo.getPath());\n      return null;\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/BlockReaderFactory.java",
          "extendedDetails": {}
        }
      ]
    },
    "490bb5ebd6c6d6f9c08fcad167f976687fc3aa42": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8934. Move ShortCircuitShm to hdfs-client. Contributed by Mingliang Liu.\n",
      "commitDate": "22/08/15 1:31 PM",
      "commitName": "490bb5ebd6c6d6f9c08fcad167f976687fc3aa42",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "21/08/15 5:02 PM",
      "commitNameOld": "7087e700e032dabc174ecc12b62c12e7d49b995f",
      "commitAuthorOld": "Lei Xu",
      "daysBetweenCommits": 0.85,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,69 +1,69 @@\n   private ShortCircuitReplicaInfo requestFileDescriptors(DomainPeer peer,\n           Slot slot) throws IOException {\n     ShortCircuitCache cache \u003d clientContext.getShortCircuitCache();\n     final DataOutputStream out \u003d\n         new DataOutputStream(new BufferedOutputStream(peer.getOutputStream()));\n     SlotId slotId \u003d slot \u003d\u003d null ? null : slot.getSlotId();\n     new Sender(out).requestShortCircuitFds(block, token, slotId, 1,\n         failureInjector.getSupportsReceiptVerification());\n     DataInputStream in \u003d new DataInputStream(peer.getInputStream());\n     BlockOpResponseProto resp \u003d BlockOpResponseProto.parseFrom(\n-        PBHelper.vintPrefixed(in));\n+        PBHelperClient.vintPrefixed(in));\n     DomainSocket sock \u003d peer.getDomainSocket();\n     failureInjector.injectRequestFileDescriptorsFailure();\n     switch (resp.getStatus()) {\n     case SUCCESS:\n       byte buf[] \u003d new byte[1];\n       FileInputStream fis[] \u003d new FileInputStream[2];\n       sock.recvFileInputStreams(fis, buf, 0, buf.length);\n       ShortCircuitReplica replica \u003d null;\n       try {\n         ExtendedBlockId key \u003d\n             new ExtendedBlockId(block.getBlockId(), block.getBlockPoolId());\n         if (buf[0] \u003d\u003d USE_RECEIPT_VERIFICATION.getNumber()) {\n           LOG.trace(\"Sending receipt verification byte for slot \" + slot);\n           sock.getOutputStream().write(0);\n         }\n         replica \u003d new ShortCircuitReplica(key, fis[0], fis[1], cache,\n             Time.monotonicNow(), slot);\n         return new ShortCircuitReplicaInfo(replica);\n       } catch (IOException e) {\n         // This indicates an error reading from disk, or a format error.  Since\n         // it\u0027s not a socket communication problem, we return null rather than\n         // throwing an exception.\n         LOG.warn(this + \": error creating ShortCircuitReplica.\", e);\n         return null;\n       } finally {\n         if (replica \u003d\u003d null) {\n           IOUtils.cleanup(DFSClient.LOG, fis[0], fis[1]);\n         }\n       }\n     case ERROR_UNSUPPORTED:\n       if (!resp.hasShortCircuitAccessVersion()) {\n         LOG.warn(\"short-circuit read access is disabled for \" +\n             \"DataNode \" + datanode + \".  reason: \" + resp.getMessage());\n         clientContext.getDomainSocketFactory()\n             .disableShortCircuitForPath(pathInfo.getPath());\n       } else {\n         LOG.warn(\"short-circuit read access for the file \" +\n             fileName + \" is disabled for DataNode \" + datanode +\n             \".  reason: \" + resp.getMessage());\n       }\n       return null;\n     case ERROR_ACCESS_TOKEN:\n       String msg \u003d \"access control error while \" +\n           \"attempting to set up short-circuit access to \" +\n           fileName + resp.getMessage();\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(this + \":\" + msg);\n       }\n       return new ShortCircuitReplicaInfo(new InvalidToken(msg));\n     default:\n       LOG.warn(this + \": unknown response code \" + resp.getStatus() +\n           \" while attempting to set up short-circuit access. \" +\n           resp.getMessage());\n       clientContext.getDomainSocketFactory()\n           .disableShortCircuitForPath(pathInfo.getPath());\n       return null;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private ShortCircuitReplicaInfo requestFileDescriptors(DomainPeer peer,\n          Slot slot) throws IOException {\n    ShortCircuitCache cache \u003d clientContext.getShortCircuitCache();\n    final DataOutputStream out \u003d\n        new DataOutputStream(new BufferedOutputStream(peer.getOutputStream()));\n    SlotId slotId \u003d slot \u003d\u003d null ? null : slot.getSlotId();\n    new Sender(out).requestShortCircuitFds(block, token, slotId, 1,\n        failureInjector.getSupportsReceiptVerification());\n    DataInputStream in \u003d new DataInputStream(peer.getInputStream());\n    BlockOpResponseProto resp \u003d BlockOpResponseProto.parseFrom(\n        PBHelperClient.vintPrefixed(in));\n    DomainSocket sock \u003d peer.getDomainSocket();\n    failureInjector.injectRequestFileDescriptorsFailure();\n    switch (resp.getStatus()) {\n    case SUCCESS:\n      byte buf[] \u003d new byte[1];\n      FileInputStream fis[] \u003d new FileInputStream[2];\n      sock.recvFileInputStreams(fis, buf, 0, buf.length);\n      ShortCircuitReplica replica \u003d null;\n      try {\n        ExtendedBlockId key \u003d\n            new ExtendedBlockId(block.getBlockId(), block.getBlockPoolId());\n        if (buf[0] \u003d\u003d USE_RECEIPT_VERIFICATION.getNumber()) {\n          LOG.trace(\"Sending receipt verification byte for slot \" + slot);\n          sock.getOutputStream().write(0);\n        }\n        replica \u003d new ShortCircuitReplica(key, fis[0], fis[1], cache,\n            Time.monotonicNow(), slot);\n        return new ShortCircuitReplicaInfo(replica);\n      } catch (IOException e) {\n        // This indicates an error reading from disk, or a format error.  Since\n        // it\u0027s not a socket communication problem, we return null rather than\n        // throwing an exception.\n        LOG.warn(this + \": error creating ShortCircuitReplica.\", e);\n        return null;\n      } finally {\n        if (replica \u003d\u003d null) {\n          IOUtils.cleanup(DFSClient.LOG, fis[0], fis[1]);\n        }\n      }\n    case ERROR_UNSUPPORTED:\n      if (!resp.hasShortCircuitAccessVersion()) {\n        LOG.warn(\"short-circuit read access is disabled for \" +\n            \"DataNode \" + datanode + \".  reason: \" + resp.getMessage());\n        clientContext.getDomainSocketFactory()\n            .disableShortCircuitForPath(pathInfo.getPath());\n      } else {\n        LOG.warn(\"short-circuit read access for the file \" +\n            fileName + \" is disabled for DataNode \" + datanode +\n            \".  reason: \" + resp.getMessage());\n      }\n      return null;\n    case ERROR_ACCESS_TOKEN:\n      String msg \u003d \"access control error while \" +\n          \"attempting to set up short-circuit access to \" +\n          fileName + resp.getMessage();\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(this + \":\" + msg);\n      }\n      return new ShortCircuitReplicaInfo(new InvalidToken(msg));\n    default:\n      LOG.warn(this + \": unknown response code \" + resp.getStatus() +\n          \" while attempting to set up short-circuit access. \" +\n          resp.getMessage());\n      clientContext.getDomainSocketFactory()\n          .disableShortCircuitForPath(pathInfo.getPath());\n      return null;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/BlockReaderFactory.java",
      "extendedDetails": {}
    },
    "a8898445dc9b5cdb7230e2e23a57393c9f378ff0": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8070. Pre-HDFS-7915 DFSClient cannot use short circuit on post-HDFS-7915 DataNode (cmccabe)\n",
      "commitDate": "23/04/15 7:13 PM",
      "commitName": "a8898445dc9b5cdb7230e2e23a57393c9f378ff0",
      "commitAuthor": "Colin Patrick Mccabe",
      "commitDateOld": "10/04/15 2:48 PM",
      "commitNameOld": "2cc9514ad643ae49d30524743420ee9744e571bd",
      "commitAuthorOld": "Tsz-Wo Nicholas Sze",
      "daysBetweenCommits": 13.18,
      "commitsBetweenForRepo": 102,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,68 +1,69 @@\n   private ShortCircuitReplicaInfo requestFileDescriptors(DomainPeer peer,\n           Slot slot) throws IOException {\n     ShortCircuitCache cache \u003d clientContext.getShortCircuitCache();\n     final DataOutputStream out \u003d\n         new DataOutputStream(new BufferedOutputStream(peer.getOutputStream()));\n     SlotId slotId \u003d slot \u003d\u003d null ? null : slot.getSlotId();\n-    new Sender(out).requestShortCircuitFds(block, token, slotId, 1, true);\n+    new Sender(out).requestShortCircuitFds(block, token, slotId, 1,\n+        failureInjector.getSupportsReceiptVerification());\n     DataInputStream in \u003d new DataInputStream(peer.getInputStream());\n     BlockOpResponseProto resp \u003d BlockOpResponseProto.parseFrom(\n         PBHelper.vintPrefixed(in));\n     DomainSocket sock \u003d peer.getDomainSocket();\n     failureInjector.injectRequestFileDescriptorsFailure();\n     switch (resp.getStatus()) {\n     case SUCCESS:\n       byte buf[] \u003d new byte[1];\n       FileInputStream fis[] \u003d new FileInputStream[2];\n       sock.recvFileInputStreams(fis, buf, 0, buf.length);\n       ShortCircuitReplica replica \u003d null;\n       try {\n         ExtendedBlockId key \u003d\n             new ExtendedBlockId(block.getBlockId(), block.getBlockPoolId());\n         if (buf[0] \u003d\u003d USE_RECEIPT_VERIFICATION.getNumber()) {\n           LOG.trace(\"Sending receipt verification byte for slot \" + slot);\n           sock.getOutputStream().write(0);\n         }\n         replica \u003d new ShortCircuitReplica(key, fis[0], fis[1], cache,\n             Time.monotonicNow(), slot);\n         return new ShortCircuitReplicaInfo(replica);\n       } catch (IOException e) {\n         // This indicates an error reading from disk, or a format error.  Since\n         // it\u0027s not a socket communication problem, we return null rather than\n         // throwing an exception.\n         LOG.warn(this + \": error creating ShortCircuitReplica.\", e);\n         return null;\n       } finally {\n         if (replica \u003d\u003d null) {\n           IOUtils.cleanup(DFSClient.LOG, fis[0], fis[1]);\n         }\n       }\n     case ERROR_UNSUPPORTED:\n       if (!resp.hasShortCircuitAccessVersion()) {\n         LOG.warn(\"short-circuit read access is disabled for \" +\n             \"DataNode \" + datanode + \".  reason: \" + resp.getMessage());\n         clientContext.getDomainSocketFactory()\n             .disableShortCircuitForPath(pathInfo.getPath());\n       } else {\n         LOG.warn(\"short-circuit read access for the file \" +\n             fileName + \" is disabled for DataNode \" + datanode +\n             \".  reason: \" + resp.getMessage());\n       }\n       return null;\n     case ERROR_ACCESS_TOKEN:\n       String msg \u003d \"access control error while \" +\n           \"attempting to set up short-circuit access to \" +\n           fileName + resp.getMessage();\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(this + \":\" + msg);\n       }\n       return new ShortCircuitReplicaInfo(new InvalidToken(msg));\n     default:\n       LOG.warn(this + \": unknown response code \" + resp.getStatus() +\n           \" while attempting to set up short-circuit access. \" +\n           resp.getMessage());\n       clientContext.getDomainSocketFactory()\n           .disableShortCircuitForPath(pathInfo.getPath());\n       return null;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private ShortCircuitReplicaInfo requestFileDescriptors(DomainPeer peer,\n          Slot slot) throws IOException {\n    ShortCircuitCache cache \u003d clientContext.getShortCircuitCache();\n    final DataOutputStream out \u003d\n        new DataOutputStream(new BufferedOutputStream(peer.getOutputStream()));\n    SlotId slotId \u003d slot \u003d\u003d null ? null : slot.getSlotId();\n    new Sender(out).requestShortCircuitFds(block, token, slotId, 1,\n        failureInjector.getSupportsReceiptVerification());\n    DataInputStream in \u003d new DataInputStream(peer.getInputStream());\n    BlockOpResponseProto resp \u003d BlockOpResponseProto.parseFrom(\n        PBHelper.vintPrefixed(in));\n    DomainSocket sock \u003d peer.getDomainSocket();\n    failureInjector.injectRequestFileDescriptorsFailure();\n    switch (resp.getStatus()) {\n    case SUCCESS:\n      byte buf[] \u003d new byte[1];\n      FileInputStream fis[] \u003d new FileInputStream[2];\n      sock.recvFileInputStreams(fis, buf, 0, buf.length);\n      ShortCircuitReplica replica \u003d null;\n      try {\n        ExtendedBlockId key \u003d\n            new ExtendedBlockId(block.getBlockId(), block.getBlockPoolId());\n        if (buf[0] \u003d\u003d USE_RECEIPT_VERIFICATION.getNumber()) {\n          LOG.trace(\"Sending receipt verification byte for slot \" + slot);\n          sock.getOutputStream().write(0);\n        }\n        replica \u003d new ShortCircuitReplica(key, fis[0], fis[1], cache,\n            Time.monotonicNow(), slot);\n        return new ShortCircuitReplicaInfo(replica);\n      } catch (IOException e) {\n        // This indicates an error reading from disk, or a format error.  Since\n        // it\u0027s not a socket communication problem, we return null rather than\n        // throwing an exception.\n        LOG.warn(this + \": error creating ShortCircuitReplica.\", e);\n        return null;\n      } finally {\n        if (replica \u003d\u003d null) {\n          IOUtils.cleanup(DFSClient.LOG, fis[0], fis[1]);\n        }\n      }\n    case ERROR_UNSUPPORTED:\n      if (!resp.hasShortCircuitAccessVersion()) {\n        LOG.warn(\"short-circuit read access is disabled for \" +\n            \"DataNode \" + datanode + \".  reason: \" + resp.getMessage());\n        clientContext.getDomainSocketFactory()\n            .disableShortCircuitForPath(pathInfo.getPath());\n      } else {\n        LOG.warn(\"short-circuit read access for the file \" +\n            fileName + \" is disabled for DataNode \" + datanode +\n            \".  reason: \" + resp.getMessage());\n      }\n      return null;\n    case ERROR_ACCESS_TOKEN:\n      String msg \u003d \"access control error while \" +\n          \"attempting to set up short-circuit access to \" +\n          fileName + resp.getMessage();\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(this + \":\" + msg);\n      }\n      return new ShortCircuitReplicaInfo(new InvalidToken(msg));\n    default:\n      LOG.warn(this + \": unknown response code \" + resp.getStatus() +\n          \" while attempting to set up short-circuit access. \" +\n          resp.getMessage());\n      clientContext.getDomainSocketFactory()\n          .disableShortCircuitForPath(pathInfo.getPath());\n      return null;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/BlockReaderFactory.java",
      "extendedDetails": {}
    },
    "bc9cb3e271b22069a15ca110cd60c860250aaab2": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7915. The DataNode can sometimes allocate a ShortCircuitShm slot and fail to tell the DFSClient about it because of a network error (cmccabe)\n",
      "commitDate": "14/03/15 10:36 PM",
      "commitName": "bc9cb3e271b22069a15ca110cd60c860250aaab2",
      "commitAuthor": "Colin Patrick Mccabe",
      "commitDateOld": "13/03/15 6:40 PM",
      "commitNameOld": "32741cf3d25d85a92e3deb11c302cc2a718d71dd",
      "commitAuthorOld": "Colin Patrick Mccabe",
      "daysBetweenCommits": 1.16,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,63 +1,68 @@\n   private ShortCircuitReplicaInfo requestFileDescriptors(DomainPeer peer,\n           Slot slot) throws IOException {\n     ShortCircuitCache cache \u003d clientContext.getShortCircuitCache();\n     final DataOutputStream out \u003d\n         new DataOutputStream(new BufferedOutputStream(peer.getOutputStream()));\n     SlotId slotId \u003d slot \u003d\u003d null ? null : slot.getSlotId();\n-    new Sender(out).requestShortCircuitFds(block, token, slotId, 1);\n+    new Sender(out).requestShortCircuitFds(block, token, slotId, 1, true);\n     DataInputStream in \u003d new DataInputStream(peer.getInputStream());\n     BlockOpResponseProto resp \u003d BlockOpResponseProto.parseFrom(\n         PBHelper.vintPrefixed(in));\n     DomainSocket sock \u003d peer.getDomainSocket();\n+    failureInjector.injectRequestFileDescriptorsFailure();\n     switch (resp.getStatus()) {\n     case SUCCESS:\n       byte buf[] \u003d new byte[1];\n       FileInputStream fis[] \u003d new FileInputStream[2];\n       sock.recvFileInputStreams(fis, buf, 0, buf.length);\n       ShortCircuitReplica replica \u003d null;\n       try {\n         ExtendedBlockId key \u003d\n             new ExtendedBlockId(block.getBlockId(), block.getBlockPoolId());\n+        if (buf[0] \u003d\u003d USE_RECEIPT_VERIFICATION.getNumber()) {\n+          LOG.trace(\"Sending receipt verification byte for slot \" + slot);\n+          sock.getOutputStream().write(0);\n+        }\n         replica \u003d new ShortCircuitReplica(key, fis[0], fis[1], cache,\n             Time.monotonicNow(), slot);\n+        return new ShortCircuitReplicaInfo(replica);\n       } catch (IOException e) {\n         // This indicates an error reading from disk, or a format error.  Since\n         // it\u0027s not a socket communication problem, we return null rather than\n         // throwing an exception.\n         LOG.warn(this + \": error creating ShortCircuitReplica.\", e);\n         return null;\n       } finally {\n         if (replica \u003d\u003d null) {\n           IOUtils.cleanup(DFSClient.LOG, fis[0], fis[1]);\n         }\n       }\n-      return new ShortCircuitReplicaInfo(replica);\n     case ERROR_UNSUPPORTED:\n       if (!resp.hasShortCircuitAccessVersion()) {\n         LOG.warn(\"short-circuit read access is disabled for \" +\n             \"DataNode \" + datanode + \".  reason: \" + resp.getMessage());\n         clientContext.getDomainSocketFactory()\n             .disableShortCircuitForPath(pathInfo.getPath());\n       } else {\n         LOG.warn(\"short-circuit read access for the file \" +\n             fileName + \" is disabled for DataNode \" + datanode +\n             \".  reason: \" + resp.getMessage());\n       }\n       return null;\n     case ERROR_ACCESS_TOKEN:\n       String msg \u003d \"access control error while \" +\n           \"attempting to set up short-circuit access to \" +\n           fileName + resp.getMessage();\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(this + \":\" + msg);\n       }\n       return new ShortCircuitReplicaInfo(new InvalidToken(msg));\n     default:\n       LOG.warn(this + \": unknown response code \" + resp.getStatus() +\n           \" while attempting to set up short-circuit access. \" +\n           resp.getMessage());\n       clientContext.getDomainSocketFactory()\n           .disableShortCircuitForPath(pathInfo.getPath());\n       return null;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private ShortCircuitReplicaInfo requestFileDescriptors(DomainPeer peer,\n          Slot slot) throws IOException {\n    ShortCircuitCache cache \u003d clientContext.getShortCircuitCache();\n    final DataOutputStream out \u003d\n        new DataOutputStream(new BufferedOutputStream(peer.getOutputStream()));\n    SlotId slotId \u003d slot \u003d\u003d null ? null : slot.getSlotId();\n    new Sender(out).requestShortCircuitFds(block, token, slotId, 1, true);\n    DataInputStream in \u003d new DataInputStream(peer.getInputStream());\n    BlockOpResponseProto resp \u003d BlockOpResponseProto.parseFrom(\n        PBHelper.vintPrefixed(in));\n    DomainSocket sock \u003d peer.getDomainSocket();\n    failureInjector.injectRequestFileDescriptorsFailure();\n    switch (resp.getStatus()) {\n    case SUCCESS:\n      byte buf[] \u003d new byte[1];\n      FileInputStream fis[] \u003d new FileInputStream[2];\n      sock.recvFileInputStreams(fis, buf, 0, buf.length);\n      ShortCircuitReplica replica \u003d null;\n      try {\n        ExtendedBlockId key \u003d\n            new ExtendedBlockId(block.getBlockId(), block.getBlockPoolId());\n        if (buf[0] \u003d\u003d USE_RECEIPT_VERIFICATION.getNumber()) {\n          LOG.trace(\"Sending receipt verification byte for slot \" + slot);\n          sock.getOutputStream().write(0);\n        }\n        replica \u003d new ShortCircuitReplica(key, fis[0], fis[1], cache,\n            Time.monotonicNow(), slot);\n        return new ShortCircuitReplicaInfo(replica);\n      } catch (IOException e) {\n        // This indicates an error reading from disk, or a format error.  Since\n        // it\u0027s not a socket communication problem, we return null rather than\n        // throwing an exception.\n        LOG.warn(this + \": error creating ShortCircuitReplica.\", e);\n        return null;\n      } finally {\n        if (replica \u003d\u003d null) {\n          IOUtils.cleanup(DFSClient.LOG, fis[0], fis[1]);\n        }\n      }\n    case ERROR_UNSUPPORTED:\n      if (!resp.hasShortCircuitAccessVersion()) {\n        LOG.warn(\"short-circuit read access is disabled for \" +\n            \"DataNode \" + datanode + \".  reason: \" + resp.getMessage());\n        clientContext.getDomainSocketFactory()\n            .disableShortCircuitForPath(pathInfo.getPath());\n      } else {\n        LOG.warn(\"short-circuit read access for the file \" +\n            fileName + \" is disabled for DataNode \" + datanode +\n            \".  reason: \" + resp.getMessage());\n      }\n      return null;\n    case ERROR_ACCESS_TOKEN:\n      String msg \u003d \"access control error while \" +\n          \"attempting to set up short-circuit access to \" +\n          fileName + resp.getMessage();\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(this + \":\" + msg);\n      }\n      return new ShortCircuitReplicaInfo(new InvalidToken(msg));\n    default:\n      LOG.warn(this + \": unknown response code \" + resp.getStatus() +\n          \" while attempting to set up short-circuit access. \" +\n          resp.getMessage());\n      clientContext.getDomainSocketFactory()\n          .disableShortCircuitForPath(pathInfo.getPath());\n      return null;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/BlockReaderFactory.java",
      "extendedDetails": {}
    },
    "32741cf3d25d85a92e3deb11c302cc2a718d71dd": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HDFS-7915. The DataNode can sometimes allocate a ShortCircuitShm slot and fail to tell the DFSClient about it because of a network error (cmccabe)\" (jenkins didn\u0027t run yet)\n\nThis reverts commit 5aa892ed486d42ae6b94c4866b92cd2b382ea640.\n",
      "commitDate": "13/03/15 6:40 PM",
      "commitName": "32741cf3d25d85a92e3deb11c302cc2a718d71dd",
      "commitAuthor": "Colin Patrick Mccabe",
      "commitDateOld": "13/03/15 6:29 PM",
      "commitNameOld": "5aa892ed486d42ae6b94c4866b92cd2b382ea640",
      "commitAuthorOld": "Colin Patrick Mccabe",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,68 +1,63 @@\n   private ShortCircuitReplicaInfo requestFileDescriptors(DomainPeer peer,\n           Slot slot) throws IOException {\n     ShortCircuitCache cache \u003d clientContext.getShortCircuitCache();\n     final DataOutputStream out \u003d\n         new DataOutputStream(new BufferedOutputStream(peer.getOutputStream()));\n     SlotId slotId \u003d slot \u003d\u003d null ? null : slot.getSlotId();\n-    new Sender(out).requestShortCircuitFds(block, token, slotId, 1, true);\n+    new Sender(out).requestShortCircuitFds(block, token, slotId, 1);\n     DataInputStream in \u003d new DataInputStream(peer.getInputStream());\n     BlockOpResponseProto resp \u003d BlockOpResponseProto.parseFrom(\n         PBHelper.vintPrefixed(in));\n     DomainSocket sock \u003d peer.getDomainSocket();\n-    failureInjector.injectRequestFileDescriptorsFailure();\n     switch (resp.getStatus()) {\n     case SUCCESS:\n       byte buf[] \u003d new byte[1];\n       FileInputStream fis[] \u003d new FileInputStream[2];\n       sock.recvFileInputStreams(fis, buf, 0, buf.length);\n       ShortCircuitReplica replica \u003d null;\n       try {\n         ExtendedBlockId key \u003d\n             new ExtendedBlockId(block.getBlockId(), block.getBlockPoolId());\n-        if (buf[0] \u003d\u003d USE_RECEIPT_VERIFICATION.getNumber()) {\n-          LOG.trace(\"Sending receipt verification byte for slot \" + slot);\n-          sock.getOutputStream().write(0);\n-        }\n         replica \u003d new ShortCircuitReplica(key, fis[0], fis[1], cache,\n             Time.monotonicNow(), slot);\n-        return new ShortCircuitReplicaInfo(replica);\n       } catch (IOException e) {\n         // This indicates an error reading from disk, or a format error.  Since\n         // it\u0027s not a socket communication problem, we return null rather than\n         // throwing an exception.\n         LOG.warn(this + \": error creating ShortCircuitReplica.\", e);\n         return null;\n       } finally {\n         if (replica \u003d\u003d null) {\n           IOUtils.cleanup(DFSClient.LOG, fis[0], fis[1]);\n         }\n       }\n+      return new ShortCircuitReplicaInfo(replica);\n     case ERROR_UNSUPPORTED:\n       if (!resp.hasShortCircuitAccessVersion()) {\n         LOG.warn(\"short-circuit read access is disabled for \" +\n             \"DataNode \" + datanode + \".  reason: \" + resp.getMessage());\n         clientContext.getDomainSocketFactory()\n             .disableShortCircuitForPath(pathInfo.getPath());\n       } else {\n         LOG.warn(\"short-circuit read access for the file \" +\n             fileName + \" is disabled for DataNode \" + datanode +\n             \".  reason: \" + resp.getMessage());\n       }\n       return null;\n     case ERROR_ACCESS_TOKEN:\n       String msg \u003d \"access control error while \" +\n           \"attempting to set up short-circuit access to \" +\n           fileName + resp.getMessage();\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(this + \":\" + msg);\n       }\n       return new ShortCircuitReplicaInfo(new InvalidToken(msg));\n     default:\n       LOG.warn(this + \": unknown response code \" + resp.getStatus() +\n           \" while attempting to set up short-circuit access. \" +\n           resp.getMessage());\n       clientContext.getDomainSocketFactory()\n           .disableShortCircuitForPath(pathInfo.getPath());\n       return null;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private ShortCircuitReplicaInfo requestFileDescriptors(DomainPeer peer,\n          Slot slot) throws IOException {\n    ShortCircuitCache cache \u003d clientContext.getShortCircuitCache();\n    final DataOutputStream out \u003d\n        new DataOutputStream(new BufferedOutputStream(peer.getOutputStream()));\n    SlotId slotId \u003d slot \u003d\u003d null ? null : slot.getSlotId();\n    new Sender(out).requestShortCircuitFds(block, token, slotId, 1);\n    DataInputStream in \u003d new DataInputStream(peer.getInputStream());\n    BlockOpResponseProto resp \u003d BlockOpResponseProto.parseFrom(\n        PBHelper.vintPrefixed(in));\n    DomainSocket sock \u003d peer.getDomainSocket();\n    switch (resp.getStatus()) {\n    case SUCCESS:\n      byte buf[] \u003d new byte[1];\n      FileInputStream fis[] \u003d new FileInputStream[2];\n      sock.recvFileInputStreams(fis, buf, 0, buf.length);\n      ShortCircuitReplica replica \u003d null;\n      try {\n        ExtendedBlockId key \u003d\n            new ExtendedBlockId(block.getBlockId(), block.getBlockPoolId());\n        replica \u003d new ShortCircuitReplica(key, fis[0], fis[1], cache,\n            Time.monotonicNow(), slot);\n      } catch (IOException e) {\n        // This indicates an error reading from disk, or a format error.  Since\n        // it\u0027s not a socket communication problem, we return null rather than\n        // throwing an exception.\n        LOG.warn(this + \": error creating ShortCircuitReplica.\", e);\n        return null;\n      } finally {\n        if (replica \u003d\u003d null) {\n          IOUtils.cleanup(DFSClient.LOG, fis[0], fis[1]);\n        }\n      }\n      return new ShortCircuitReplicaInfo(replica);\n    case ERROR_UNSUPPORTED:\n      if (!resp.hasShortCircuitAccessVersion()) {\n        LOG.warn(\"short-circuit read access is disabled for \" +\n            \"DataNode \" + datanode + \".  reason: \" + resp.getMessage());\n        clientContext.getDomainSocketFactory()\n            .disableShortCircuitForPath(pathInfo.getPath());\n      } else {\n        LOG.warn(\"short-circuit read access for the file \" +\n            fileName + \" is disabled for DataNode \" + datanode +\n            \".  reason: \" + resp.getMessage());\n      }\n      return null;\n    case ERROR_ACCESS_TOKEN:\n      String msg \u003d \"access control error while \" +\n          \"attempting to set up short-circuit access to \" +\n          fileName + resp.getMessage();\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(this + \":\" + msg);\n      }\n      return new ShortCircuitReplicaInfo(new InvalidToken(msg));\n    default:\n      LOG.warn(this + \": unknown response code \" + resp.getStatus() +\n          \" while attempting to set up short-circuit access. \" +\n          resp.getMessage());\n      clientContext.getDomainSocketFactory()\n          .disableShortCircuitForPath(pathInfo.getPath());\n      return null;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/BlockReaderFactory.java",
      "extendedDetails": {}
    },
    "5aa892ed486d42ae6b94c4866b92cd2b382ea640": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7915. The DataNode can sometimes allocate a ShortCircuitShm slot and fail to tell the DFSClient about it because of a network error (cmccabe)\n",
      "commitDate": "13/03/15 6:29 PM",
      "commitName": "5aa892ed486d42ae6b94c4866b92cd2b382ea640",
      "commitAuthor": "Colin Patrick Mccabe",
      "commitDateOld": "21/02/15 3:38 PM",
      "commitNameOld": "8b465b4b8caed31ca9daeaae108f9a868a30a455",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 20.08,
      "commitsBetweenForRepo": 154,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,63 +1,68 @@\n   private ShortCircuitReplicaInfo requestFileDescriptors(DomainPeer peer,\n           Slot slot) throws IOException {\n     ShortCircuitCache cache \u003d clientContext.getShortCircuitCache();\n     final DataOutputStream out \u003d\n         new DataOutputStream(new BufferedOutputStream(peer.getOutputStream()));\n     SlotId slotId \u003d slot \u003d\u003d null ? null : slot.getSlotId();\n-    new Sender(out).requestShortCircuitFds(block, token, slotId, 1);\n+    new Sender(out).requestShortCircuitFds(block, token, slotId, 1, true);\n     DataInputStream in \u003d new DataInputStream(peer.getInputStream());\n     BlockOpResponseProto resp \u003d BlockOpResponseProto.parseFrom(\n         PBHelper.vintPrefixed(in));\n     DomainSocket sock \u003d peer.getDomainSocket();\n+    failureInjector.injectRequestFileDescriptorsFailure();\n     switch (resp.getStatus()) {\n     case SUCCESS:\n       byte buf[] \u003d new byte[1];\n       FileInputStream fis[] \u003d new FileInputStream[2];\n       sock.recvFileInputStreams(fis, buf, 0, buf.length);\n       ShortCircuitReplica replica \u003d null;\n       try {\n         ExtendedBlockId key \u003d\n             new ExtendedBlockId(block.getBlockId(), block.getBlockPoolId());\n+        if (buf[0] \u003d\u003d USE_RECEIPT_VERIFICATION.getNumber()) {\n+          LOG.trace(\"Sending receipt verification byte for slot \" + slot);\n+          sock.getOutputStream().write(0);\n+        }\n         replica \u003d new ShortCircuitReplica(key, fis[0], fis[1], cache,\n             Time.monotonicNow(), slot);\n+        return new ShortCircuitReplicaInfo(replica);\n       } catch (IOException e) {\n         // This indicates an error reading from disk, or a format error.  Since\n         // it\u0027s not a socket communication problem, we return null rather than\n         // throwing an exception.\n         LOG.warn(this + \": error creating ShortCircuitReplica.\", e);\n         return null;\n       } finally {\n         if (replica \u003d\u003d null) {\n           IOUtils.cleanup(DFSClient.LOG, fis[0], fis[1]);\n         }\n       }\n-      return new ShortCircuitReplicaInfo(replica);\n     case ERROR_UNSUPPORTED:\n       if (!resp.hasShortCircuitAccessVersion()) {\n         LOG.warn(\"short-circuit read access is disabled for \" +\n             \"DataNode \" + datanode + \".  reason: \" + resp.getMessage());\n         clientContext.getDomainSocketFactory()\n             .disableShortCircuitForPath(pathInfo.getPath());\n       } else {\n         LOG.warn(\"short-circuit read access for the file \" +\n             fileName + \" is disabled for DataNode \" + datanode +\n             \".  reason: \" + resp.getMessage());\n       }\n       return null;\n     case ERROR_ACCESS_TOKEN:\n       String msg \u003d \"access control error while \" +\n           \"attempting to set up short-circuit access to \" +\n           fileName + resp.getMessage();\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(this + \":\" + msg);\n       }\n       return new ShortCircuitReplicaInfo(new InvalidToken(msg));\n     default:\n       LOG.warn(this + \": unknown response code \" + resp.getStatus() +\n           \" while attempting to set up short-circuit access. \" +\n           resp.getMessage());\n       clientContext.getDomainSocketFactory()\n           .disableShortCircuitForPath(pathInfo.getPath());\n       return null;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private ShortCircuitReplicaInfo requestFileDescriptors(DomainPeer peer,\n          Slot slot) throws IOException {\n    ShortCircuitCache cache \u003d clientContext.getShortCircuitCache();\n    final DataOutputStream out \u003d\n        new DataOutputStream(new BufferedOutputStream(peer.getOutputStream()));\n    SlotId slotId \u003d slot \u003d\u003d null ? null : slot.getSlotId();\n    new Sender(out).requestShortCircuitFds(block, token, slotId, 1, true);\n    DataInputStream in \u003d new DataInputStream(peer.getInputStream());\n    BlockOpResponseProto resp \u003d BlockOpResponseProto.parseFrom(\n        PBHelper.vintPrefixed(in));\n    DomainSocket sock \u003d peer.getDomainSocket();\n    failureInjector.injectRequestFileDescriptorsFailure();\n    switch (resp.getStatus()) {\n    case SUCCESS:\n      byte buf[] \u003d new byte[1];\n      FileInputStream fis[] \u003d new FileInputStream[2];\n      sock.recvFileInputStreams(fis, buf, 0, buf.length);\n      ShortCircuitReplica replica \u003d null;\n      try {\n        ExtendedBlockId key \u003d\n            new ExtendedBlockId(block.getBlockId(), block.getBlockPoolId());\n        if (buf[0] \u003d\u003d USE_RECEIPT_VERIFICATION.getNumber()) {\n          LOG.trace(\"Sending receipt verification byte for slot \" + slot);\n          sock.getOutputStream().write(0);\n        }\n        replica \u003d new ShortCircuitReplica(key, fis[0], fis[1], cache,\n            Time.monotonicNow(), slot);\n        return new ShortCircuitReplicaInfo(replica);\n      } catch (IOException e) {\n        // This indicates an error reading from disk, or a format error.  Since\n        // it\u0027s not a socket communication problem, we return null rather than\n        // throwing an exception.\n        LOG.warn(this + \": error creating ShortCircuitReplica.\", e);\n        return null;\n      } finally {\n        if (replica \u003d\u003d null) {\n          IOUtils.cleanup(DFSClient.LOG, fis[0], fis[1]);\n        }\n      }\n    case ERROR_UNSUPPORTED:\n      if (!resp.hasShortCircuitAccessVersion()) {\n        LOG.warn(\"short-circuit read access is disabled for \" +\n            \"DataNode \" + datanode + \".  reason: \" + resp.getMessage());\n        clientContext.getDomainSocketFactory()\n            .disableShortCircuitForPath(pathInfo.getPath());\n      } else {\n        LOG.warn(\"short-circuit read access for the file \" +\n            fileName + \" is disabled for DataNode \" + datanode +\n            \".  reason: \" + resp.getMessage());\n      }\n      return null;\n    case ERROR_ACCESS_TOKEN:\n      String msg \u003d \"access control error while \" +\n          \"attempting to set up short-circuit access to \" +\n          fileName + resp.getMessage();\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(this + \":\" + msg);\n      }\n      return new ShortCircuitReplicaInfo(new InvalidToken(msg));\n    default:\n      LOG.warn(this + \": unknown response code \" + resp.getStatus() +\n          \" while attempting to set up short-circuit access. \" +\n          resp.getMessage());\n      clientContext.getDomainSocketFactory()\n          .disableShortCircuitForPath(pathInfo.getPath());\n      return null;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/BlockReaderFactory.java",
      "extendedDetails": {}
    },
    "dd049a2f6097da189ccce2f5890a2b9bc77fa73f": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-5950. The DFSClient and DataNode should use shared memory segments to communicate short-circuit information (cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1573433 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/03/14 7:58 PM",
      "commitName": "dd049a2f6097da189ccce2f5890a2b9bc77fa73f",
      "commitAuthor": "Colin McCabe",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-5950. The DFSClient and DataNode should use shared memory segments to communicate short-circuit information (cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1573433 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "02/03/14 7:58 PM",
          "commitName": "dd049a2f6097da189ccce2f5890a2b9bc77fa73f",
          "commitAuthor": "Colin McCabe",
          "commitDateOld": "12/02/14 7:10 PM",
          "commitNameOld": "f0d64a078da7e932b9509734f75170e3e525e68c",
          "commitAuthorOld": "Colin McCabe",
          "daysBetweenCommits": 18.03,
          "commitsBetweenForRepo": 129,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,59 +1,63 @@\n-  private ShortCircuitReplicaInfo requestFileDescriptors(DomainPeer peer)\n-        throws IOException {\n+  private ShortCircuitReplicaInfo requestFileDescriptors(DomainPeer peer,\n+          Slot slot) throws IOException {\n+    ShortCircuitCache cache \u003d clientContext.getShortCircuitCache();\n     final DataOutputStream out \u003d\n         new DataOutputStream(new BufferedOutputStream(peer.getOutputStream()));\n-    new Sender(out).requestShortCircuitFds(block, token, 1);\n+    SlotId slotId \u003d slot \u003d\u003d null ? null : slot.getSlotId();\n+    new Sender(out).requestShortCircuitFds(block, token, slotId, 1);\n     DataInputStream in \u003d new DataInputStream(peer.getInputStream());\n     BlockOpResponseProto resp \u003d BlockOpResponseProto.parseFrom(\n         PBHelper.vintPrefixed(in));\n     DomainSocket sock \u003d peer.getDomainSocket();\n     switch (resp.getStatus()) {\n     case SUCCESS:\n       byte buf[] \u003d new byte[1];\n       FileInputStream fis[] \u003d new FileInputStream[2];\n       sock.recvFileInputStreams(fis, buf, 0, buf.length);\n       ShortCircuitReplica replica \u003d null;\n       try {\n-        ExtendedBlockId key \u003d new ExtendedBlockId(block.getBlockId(), block.getBlockPoolId());\n-        replica \u003d new ShortCircuitReplica(key, fis[0], fis[1],\n-            clientContext.getShortCircuitCache(), Time.monotonicNow());\n+        ExtendedBlockId key \u003d\n+            new ExtendedBlockId(block.getBlockId(), block.getBlockPoolId());\n+        replica \u003d new ShortCircuitReplica(key, fis[0], fis[1], cache,\n+            Time.monotonicNow(), slot);\n       } catch (IOException e) {\n         // This indicates an error reading from disk, or a format error.  Since\n         // it\u0027s not a socket communication problem, we return null rather than\n         // throwing an exception.\n         LOG.warn(this + \": error creating ShortCircuitReplica.\", e);\n         return null;\n       } finally {\n         if (replica \u003d\u003d null) {\n           IOUtils.cleanup(DFSClient.LOG, fis[0], fis[1]);\n         }\n       }\n       return new ShortCircuitReplicaInfo(replica);\n     case ERROR_UNSUPPORTED:\n       if (!resp.hasShortCircuitAccessVersion()) {\n         LOG.warn(\"short-circuit read access is disabled for \" +\n             \"DataNode \" + datanode + \".  reason: \" + resp.getMessage());\n         clientContext.getDomainSocketFactory()\n             .disableShortCircuitForPath(pathInfo.getPath());\n       } else {\n         LOG.warn(\"short-circuit read access for the file \" +\n             fileName + \" is disabled for DataNode \" + datanode +\n             \".  reason: \" + resp.getMessage());\n       }\n       return null;\n     case ERROR_ACCESS_TOKEN:\n       String msg \u003d \"access control error while \" +\n           \"attempting to set up short-circuit access to \" +\n           fileName + resp.getMessage();\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(this + \":\" + msg);\n       }\n       return new ShortCircuitReplicaInfo(new InvalidToken(msg));\n     default:\n-      LOG.warn(this + \"unknown response code \" + resp.getStatus() + \" while \" +\n-          \"attempting to set up short-circuit access. \" + resp.getMessage());\n+      LOG.warn(this + \": unknown response code \" + resp.getStatus() +\n+          \" while attempting to set up short-circuit access. \" +\n+          resp.getMessage());\n       clientContext.getDomainSocketFactory()\n           .disableShortCircuitForPath(pathInfo.getPath());\n       return null;\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private ShortCircuitReplicaInfo requestFileDescriptors(DomainPeer peer,\n          Slot slot) throws IOException {\n    ShortCircuitCache cache \u003d clientContext.getShortCircuitCache();\n    final DataOutputStream out \u003d\n        new DataOutputStream(new BufferedOutputStream(peer.getOutputStream()));\n    SlotId slotId \u003d slot \u003d\u003d null ? null : slot.getSlotId();\n    new Sender(out).requestShortCircuitFds(block, token, slotId, 1);\n    DataInputStream in \u003d new DataInputStream(peer.getInputStream());\n    BlockOpResponseProto resp \u003d BlockOpResponseProto.parseFrom(\n        PBHelper.vintPrefixed(in));\n    DomainSocket sock \u003d peer.getDomainSocket();\n    switch (resp.getStatus()) {\n    case SUCCESS:\n      byte buf[] \u003d new byte[1];\n      FileInputStream fis[] \u003d new FileInputStream[2];\n      sock.recvFileInputStreams(fis, buf, 0, buf.length);\n      ShortCircuitReplica replica \u003d null;\n      try {\n        ExtendedBlockId key \u003d\n            new ExtendedBlockId(block.getBlockId(), block.getBlockPoolId());\n        replica \u003d new ShortCircuitReplica(key, fis[0], fis[1], cache,\n            Time.monotonicNow(), slot);\n      } catch (IOException e) {\n        // This indicates an error reading from disk, or a format error.  Since\n        // it\u0027s not a socket communication problem, we return null rather than\n        // throwing an exception.\n        LOG.warn(this + \": error creating ShortCircuitReplica.\", e);\n        return null;\n      } finally {\n        if (replica \u003d\u003d null) {\n          IOUtils.cleanup(DFSClient.LOG, fis[0], fis[1]);\n        }\n      }\n      return new ShortCircuitReplicaInfo(replica);\n    case ERROR_UNSUPPORTED:\n      if (!resp.hasShortCircuitAccessVersion()) {\n        LOG.warn(\"short-circuit read access is disabled for \" +\n            \"DataNode \" + datanode + \".  reason: \" + resp.getMessage());\n        clientContext.getDomainSocketFactory()\n            .disableShortCircuitForPath(pathInfo.getPath());\n      } else {\n        LOG.warn(\"short-circuit read access for the file \" +\n            fileName + \" is disabled for DataNode \" + datanode +\n            \".  reason: \" + resp.getMessage());\n      }\n      return null;\n    case ERROR_ACCESS_TOKEN:\n      String msg \u003d \"access control error while \" +\n          \"attempting to set up short-circuit access to \" +\n          fileName + resp.getMessage();\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(this + \":\" + msg);\n      }\n      return new ShortCircuitReplicaInfo(new InvalidToken(msg));\n    default:\n      LOG.warn(this + \": unknown response code \" + resp.getStatus() +\n          \" while attempting to set up short-circuit access. \" +\n          resp.getMessage());\n      clientContext.getDomainSocketFactory()\n          .disableShortCircuitForPath(pathInfo.getPath());\n      return null;\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/BlockReaderFactory.java",
          "extendedDetails": {
            "oldValue": "[peer-DomainPeer]",
            "newValue": "[peer-DomainPeer, slot-Slot]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-5950. The DFSClient and DataNode should use shared memory segments to communicate short-circuit information (cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1573433 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "02/03/14 7:58 PM",
          "commitName": "dd049a2f6097da189ccce2f5890a2b9bc77fa73f",
          "commitAuthor": "Colin McCabe",
          "commitDateOld": "12/02/14 7:10 PM",
          "commitNameOld": "f0d64a078da7e932b9509734f75170e3e525e68c",
          "commitAuthorOld": "Colin McCabe",
          "daysBetweenCommits": 18.03,
          "commitsBetweenForRepo": 129,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,59 +1,63 @@\n-  private ShortCircuitReplicaInfo requestFileDescriptors(DomainPeer peer)\n-        throws IOException {\n+  private ShortCircuitReplicaInfo requestFileDescriptors(DomainPeer peer,\n+          Slot slot) throws IOException {\n+    ShortCircuitCache cache \u003d clientContext.getShortCircuitCache();\n     final DataOutputStream out \u003d\n         new DataOutputStream(new BufferedOutputStream(peer.getOutputStream()));\n-    new Sender(out).requestShortCircuitFds(block, token, 1);\n+    SlotId slotId \u003d slot \u003d\u003d null ? null : slot.getSlotId();\n+    new Sender(out).requestShortCircuitFds(block, token, slotId, 1);\n     DataInputStream in \u003d new DataInputStream(peer.getInputStream());\n     BlockOpResponseProto resp \u003d BlockOpResponseProto.parseFrom(\n         PBHelper.vintPrefixed(in));\n     DomainSocket sock \u003d peer.getDomainSocket();\n     switch (resp.getStatus()) {\n     case SUCCESS:\n       byte buf[] \u003d new byte[1];\n       FileInputStream fis[] \u003d new FileInputStream[2];\n       sock.recvFileInputStreams(fis, buf, 0, buf.length);\n       ShortCircuitReplica replica \u003d null;\n       try {\n-        ExtendedBlockId key \u003d new ExtendedBlockId(block.getBlockId(), block.getBlockPoolId());\n-        replica \u003d new ShortCircuitReplica(key, fis[0], fis[1],\n-            clientContext.getShortCircuitCache(), Time.monotonicNow());\n+        ExtendedBlockId key \u003d\n+            new ExtendedBlockId(block.getBlockId(), block.getBlockPoolId());\n+        replica \u003d new ShortCircuitReplica(key, fis[0], fis[1], cache,\n+            Time.monotonicNow(), slot);\n       } catch (IOException e) {\n         // This indicates an error reading from disk, or a format error.  Since\n         // it\u0027s not a socket communication problem, we return null rather than\n         // throwing an exception.\n         LOG.warn(this + \": error creating ShortCircuitReplica.\", e);\n         return null;\n       } finally {\n         if (replica \u003d\u003d null) {\n           IOUtils.cleanup(DFSClient.LOG, fis[0], fis[1]);\n         }\n       }\n       return new ShortCircuitReplicaInfo(replica);\n     case ERROR_UNSUPPORTED:\n       if (!resp.hasShortCircuitAccessVersion()) {\n         LOG.warn(\"short-circuit read access is disabled for \" +\n             \"DataNode \" + datanode + \".  reason: \" + resp.getMessage());\n         clientContext.getDomainSocketFactory()\n             .disableShortCircuitForPath(pathInfo.getPath());\n       } else {\n         LOG.warn(\"short-circuit read access for the file \" +\n             fileName + \" is disabled for DataNode \" + datanode +\n             \".  reason: \" + resp.getMessage());\n       }\n       return null;\n     case ERROR_ACCESS_TOKEN:\n       String msg \u003d \"access control error while \" +\n           \"attempting to set up short-circuit access to \" +\n           fileName + resp.getMessage();\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(this + \":\" + msg);\n       }\n       return new ShortCircuitReplicaInfo(new InvalidToken(msg));\n     default:\n-      LOG.warn(this + \"unknown response code \" + resp.getStatus() + \" while \" +\n-          \"attempting to set up short-circuit access. \" + resp.getMessage());\n+      LOG.warn(this + \": unknown response code \" + resp.getStatus() +\n+          \" while attempting to set up short-circuit access. \" +\n+          resp.getMessage());\n       clientContext.getDomainSocketFactory()\n           .disableShortCircuitForPath(pathInfo.getPath());\n       return null;\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private ShortCircuitReplicaInfo requestFileDescriptors(DomainPeer peer,\n          Slot slot) throws IOException {\n    ShortCircuitCache cache \u003d clientContext.getShortCircuitCache();\n    final DataOutputStream out \u003d\n        new DataOutputStream(new BufferedOutputStream(peer.getOutputStream()));\n    SlotId slotId \u003d slot \u003d\u003d null ? null : slot.getSlotId();\n    new Sender(out).requestShortCircuitFds(block, token, slotId, 1);\n    DataInputStream in \u003d new DataInputStream(peer.getInputStream());\n    BlockOpResponseProto resp \u003d BlockOpResponseProto.parseFrom(\n        PBHelper.vintPrefixed(in));\n    DomainSocket sock \u003d peer.getDomainSocket();\n    switch (resp.getStatus()) {\n    case SUCCESS:\n      byte buf[] \u003d new byte[1];\n      FileInputStream fis[] \u003d new FileInputStream[2];\n      sock.recvFileInputStreams(fis, buf, 0, buf.length);\n      ShortCircuitReplica replica \u003d null;\n      try {\n        ExtendedBlockId key \u003d\n            new ExtendedBlockId(block.getBlockId(), block.getBlockPoolId());\n        replica \u003d new ShortCircuitReplica(key, fis[0], fis[1], cache,\n            Time.monotonicNow(), slot);\n      } catch (IOException e) {\n        // This indicates an error reading from disk, or a format error.  Since\n        // it\u0027s not a socket communication problem, we return null rather than\n        // throwing an exception.\n        LOG.warn(this + \": error creating ShortCircuitReplica.\", e);\n        return null;\n      } finally {\n        if (replica \u003d\u003d null) {\n          IOUtils.cleanup(DFSClient.LOG, fis[0], fis[1]);\n        }\n      }\n      return new ShortCircuitReplicaInfo(replica);\n    case ERROR_UNSUPPORTED:\n      if (!resp.hasShortCircuitAccessVersion()) {\n        LOG.warn(\"short-circuit read access is disabled for \" +\n            \"DataNode \" + datanode + \".  reason: \" + resp.getMessage());\n        clientContext.getDomainSocketFactory()\n            .disableShortCircuitForPath(pathInfo.getPath());\n      } else {\n        LOG.warn(\"short-circuit read access for the file \" +\n            fileName + \" is disabled for DataNode \" + datanode +\n            \".  reason: \" + resp.getMessage());\n      }\n      return null;\n    case ERROR_ACCESS_TOKEN:\n      String msg \u003d \"access control error while \" +\n          \"attempting to set up short-circuit access to \" +\n          fileName + resp.getMessage();\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(this + \":\" + msg);\n      }\n      return new ShortCircuitReplicaInfo(new InvalidToken(msg));\n    default:\n      LOG.warn(this + \": unknown response code \" + resp.getStatus() +\n          \" while attempting to set up short-circuit access. \" +\n          resp.getMessage());\n      clientContext.getDomainSocketFactory()\n          .disableShortCircuitForPath(pathInfo.getPath());\n      return null;\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/BlockReaderFactory.java",
          "extendedDetails": {}
        }
      ]
    },
    "f0d64a078da7e932b9509734f75170e3e525e68c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5940.  Minor cleanups to ShortCircuitReplica, FsDatasetCache, and DomainSocketWatcher (cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1567835 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/02/14 7:10 PM",
      "commitName": "f0d64a078da7e932b9509734f75170e3e525e68c",
      "commitAuthor": "Colin McCabe",
      "commitDateOld": "12/02/14 2:01 PM",
      "commitNameOld": "b3af8edc26191ac708208bc9543847dc62eca763",
      "commitAuthorOld": "Colin McCabe",
      "daysBetweenCommits": 0.21,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,59 +1,59 @@\n   private ShortCircuitReplicaInfo requestFileDescriptors(DomainPeer peer)\n         throws IOException {\n     final DataOutputStream out \u003d\n         new DataOutputStream(new BufferedOutputStream(peer.getOutputStream()));\n     new Sender(out).requestShortCircuitFds(block, token, 1);\n     DataInputStream in \u003d new DataInputStream(peer.getInputStream());\n     BlockOpResponseProto resp \u003d BlockOpResponseProto.parseFrom(\n         PBHelper.vintPrefixed(in));\n     DomainSocket sock \u003d peer.getDomainSocket();\n     switch (resp.getStatus()) {\n     case SUCCESS:\n       byte buf[] \u003d new byte[1];\n       FileInputStream fis[] \u003d new FileInputStream[2];\n       sock.recvFileInputStreams(fis, buf, 0, buf.length);\n       ShortCircuitReplica replica \u003d null;\n       try {\n-        Key key \u003d new Key(block.getBlockId(), block.getBlockPoolId());\n+        ExtendedBlockId key \u003d new ExtendedBlockId(block.getBlockId(), block.getBlockPoolId());\n         replica \u003d new ShortCircuitReplica(key, fis[0], fis[1],\n             clientContext.getShortCircuitCache(), Time.monotonicNow());\n       } catch (IOException e) {\n         // This indicates an error reading from disk, or a format error.  Since\n         // it\u0027s not a socket communication problem, we return null rather than\n         // throwing an exception.\n         LOG.warn(this + \": error creating ShortCircuitReplica.\", e);\n         return null;\n       } finally {\n         if (replica \u003d\u003d null) {\n           IOUtils.cleanup(DFSClient.LOG, fis[0], fis[1]);\n         }\n       }\n       return new ShortCircuitReplicaInfo(replica);\n     case ERROR_UNSUPPORTED:\n       if (!resp.hasShortCircuitAccessVersion()) {\n         LOG.warn(\"short-circuit read access is disabled for \" +\n             \"DataNode \" + datanode + \".  reason: \" + resp.getMessage());\n         clientContext.getDomainSocketFactory()\n             .disableShortCircuitForPath(pathInfo.getPath());\n       } else {\n         LOG.warn(\"short-circuit read access for the file \" +\n             fileName + \" is disabled for DataNode \" + datanode +\n             \".  reason: \" + resp.getMessage());\n       }\n       return null;\n     case ERROR_ACCESS_TOKEN:\n       String msg \u003d \"access control error while \" +\n           \"attempting to set up short-circuit access to \" +\n           fileName + resp.getMessage();\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(this + \":\" + msg);\n       }\n       return new ShortCircuitReplicaInfo(new InvalidToken(msg));\n     default:\n       LOG.warn(this + \"unknown response code \" + resp.getStatus() + \" while \" +\n           \"attempting to set up short-circuit access. \" + resp.getMessage());\n       clientContext.getDomainSocketFactory()\n           .disableShortCircuitForPath(pathInfo.getPath());\n       return null;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private ShortCircuitReplicaInfo requestFileDescriptors(DomainPeer peer)\n        throws IOException {\n    final DataOutputStream out \u003d\n        new DataOutputStream(new BufferedOutputStream(peer.getOutputStream()));\n    new Sender(out).requestShortCircuitFds(block, token, 1);\n    DataInputStream in \u003d new DataInputStream(peer.getInputStream());\n    BlockOpResponseProto resp \u003d BlockOpResponseProto.parseFrom(\n        PBHelper.vintPrefixed(in));\n    DomainSocket sock \u003d peer.getDomainSocket();\n    switch (resp.getStatus()) {\n    case SUCCESS:\n      byte buf[] \u003d new byte[1];\n      FileInputStream fis[] \u003d new FileInputStream[2];\n      sock.recvFileInputStreams(fis, buf, 0, buf.length);\n      ShortCircuitReplica replica \u003d null;\n      try {\n        ExtendedBlockId key \u003d new ExtendedBlockId(block.getBlockId(), block.getBlockPoolId());\n        replica \u003d new ShortCircuitReplica(key, fis[0], fis[1],\n            clientContext.getShortCircuitCache(), Time.monotonicNow());\n      } catch (IOException e) {\n        // This indicates an error reading from disk, or a format error.  Since\n        // it\u0027s not a socket communication problem, we return null rather than\n        // throwing an exception.\n        LOG.warn(this + \": error creating ShortCircuitReplica.\", e);\n        return null;\n      } finally {\n        if (replica \u003d\u003d null) {\n          IOUtils.cleanup(DFSClient.LOG, fis[0], fis[1]);\n        }\n      }\n      return new ShortCircuitReplicaInfo(replica);\n    case ERROR_UNSUPPORTED:\n      if (!resp.hasShortCircuitAccessVersion()) {\n        LOG.warn(\"short-circuit read access is disabled for \" +\n            \"DataNode \" + datanode + \".  reason: \" + resp.getMessage());\n        clientContext.getDomainSocketFactory()\n            .disableShortCircuitForPath(pathInfo.getPath());\n      } else {\n        LOG.warn(\"short-circuit read access for the file \" +\n            fileName + \" is disabled for DataNode \" + datanode +\n            \".  reason: \" + resp.getMessage());\n      }\n      return null;\n    case ERROR_ACCESS_TOKEN:\n      String msg \u003d \"access control error while \" +\n          \"attempting to set up short-circuit access to \" +\n          fileName + resp.getMessage();\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(this + \":\" + msg);\n      }\n      return new ShortCircuitReplicaInfo(new InvalidToken(msg));\n    default:\n      LOG.warn(this + \"unknown response code \" + resp.getStatus() + \" while \" +\n          \"attempting to set up short-circuit access. \" + resp.getMessage());\n      clientContext.getDomainSocketFactory()\n          .disableShortCircuitForPath(pathInfo.getPath());\n      return null;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/BlockReaderFactory.java",
      "extendedDetails": {}
    },
    "beb0d25d2a7ba5004c6aabd105546ba9a9fec9be": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-5810. Unify mmap cache and short-circuit file descriptor cache (cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1567720 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/02/14 11:08 AM",
      "commitName": "beb0d25d2a7ba5004c6aabd105546ba9a9fec9be",
      "commitAuthor": "Colin McCabe",
      "diff": "@@ -0,0 +1,59 @@\n+  private ShortCircuitReplicaInfo requestFileDescriptors(DomainPeer peer)\n+        throws IOException {\n+    final DataOutputStream out \u003d\n+        new DataOutputStream(new BufferedOutputStream(peer.getOutputStream()));\n+    new Sender(out).requestShortCircuitFds(block, token, 1);\n+    DataInputStream in \u003d new DataInputStream(peer.getInputStream());\n+    BlockOpResponseProto resp \u003d BlockOpResponseProto.parseFrom(\n+        PBHelper.vintPrefixed(in));\n+    DomainSocket sock \u003d peer.getDomainSocket();\n+    switch (resp.getStatus()) {\n+    case SUCCESS:\n+      byte buf[] \u003d new byte[1];\n+      FileInputStream fis[] \u003d new FileInputStream[2];\n+      sock.recvFileInputStreams(fis, buf, 0, buf.length);\n+      ShortCircuitReplica replica \u003d null;\n+      try {\n+        Key key \u003d new Key(block.getBlockId(), block.getBlockPoolId());\n+        replica \u003d new ShortCircuitReplica(key, fis[0], fis[1],\n+            clientContext.getShortCircuitCache(), Time.monotonicNow());\n+      } catch (IOException e) {\n+        // This indicates an error reading from disk, or a format error.  Since\n+        // it\u0027s not a socket communication problem, we return null rather than\n+        // throwing an exception.\n+        LOG.warn(this + \": error creating ShortCircuitReplica.\", e);\n+        return null;\n+      } finally {\n+        if (replica \u003d\u003d null) {\n+          IOUtils.cleanup(DFSClient.LOG, fis[0], fis[1]);\n+        }\n+      }\n+      return new ShortCircuitReplicaInfo(replica);\n+    case ERROR_UNSUPPORTED:\n+      if (!resp.hasShortCircuitAccessVersion()) {\n+        LOG.warn(\"short-circuit read access is disabled for \" +\n+            \"DataNode \" + datanode + \".  reason: \" + resp.getMessage());\n+        clientContext.getDomainSocketFactory()\n+            .disableShortCircuitForPath(pathInfo.getPath());\n+      } else {\n+        LOG.warn(\"short-circuit read access for the file \" +\n+            fileName + \" is disabled for DataNode \" + datanode +\n+            \".  reason: \" + resp.getMessage());\n+      }\n+      return null;\n+    case ERROR_ACCESS_TOKEN:\n+      String msg \u003d \"access control error while \" +\n+          \"attempting to set up short-circuit access to \" +\n+          fileName + resp.getMessage();\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(this + \":\" + msg);\n+      }\n+      return new ShortCircuitReplicaInfo(new InvalidToken(msg));\n+    default:\n+      LOG.warn(this + \"unknown response code \" + resp.getStatus() + \" while \" +\n+          \"attempting to set up short-circuit access. \" + resp.getMessage());\n+      clientContext.getDomainSocketFactory()\n+          .disableShortCircuitForPath(pathInfo.getPath());\n+      return null;\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private ShortCircuitReplicaInfo requestFileDescriptors(DomainPeer peer)\n        throws IOException {\n    final DataOutputStream out \u003d\n        new DataOutputStream(new BufferedOutputStream(peer.getOutputStream()));\n    new Sender(out).requestShortCircuitFds(block, token, 1);\n    DataInputStream in \u003d new DataInputStream(peer.getInputStream());\n    BlockOpResponseProto resp \u003d BlockOpResponseProto.parseFrom(\n        PBHelper.vintPrefixed(in));\n    DomainSocket sock \u003d peer.getDomainSocket();\n    switch (resp.getStatus()) {\n    case SUCCESS:\n      byte buf[] \u003d new byte[1];\n      FileInputStream fis[] \u003d new FileInputStream[2];\n      sock.recvFileInputStreams(fis, buf, 0, buf.length);\n      ShortCircuitReplica replica \u003d null;\n      try {\n        Key key \u003d new Key(block.getBlockId(), block.getBlockPoolId());\n        replica \u003d new ShortCircuitReplica(key, fis[0], fis[1],\n            clientContext.getShortCircuitCache(), Time.monotonicNow());\n      } catch (IOException e) {\n        // This indicates an error reading from disk, or a format error.  Since\n        // it\u0027s not a socket communication problem, we return null rather than\n        // throwing an exception.\n        LOG.warn(this + \": error creating ShortCircuitReplica.\", e);\n        return null;\n      } finally {\n        if (replica \u003d\u003d null) {\n          IOUtils.cleanup(DFSClient.LOG, fis[0], fis[1]);\n        }\n      }\n      return new ShortCircuitReplicaInfo(replica);\n    case ERROR_UNSUPPORTED:\n      if (!resp.hasShortCircuitAccessVersion()) {\n        LOG.warn(\"short-circuit read access is disabled for \" +\n            \"DataNode \" + datanode + \".  reason: \" + resp.getMessage());\n        clientContext.getDomainSocketFactory()\n            .disableShortCircuitForPath(pathInfo.getPath());\n      } else {\n        LOG.warn(\"short-circuit read access for the file \" +\n            fileName + \" is disabled for DataNode \" + datanode +\n            \".  reason: \" + resp.getMessage());\n      }\n      return null;\n    case ERROR_ACCESS_TOKEN:\n      String msg \u003d \"access control error while \" +\n          \"attempting to set up short-circuit access to \" +\n          fileName + resp.getMessage();\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(this + \":\" + msg);\n      }\n      return new ShortCircuitReplicaInfo(new InvalidToken(msg));\n    default:\n      LOG.warn(this + \"unknown response code \" + resp.getStatus() + \" while \" +\n          \"attempting to set up short-circuit access. \" + resp.getMessage());\n      clientContext.getDomainSocketFactory()\n          .disableShortCircuitForPath(pathInfo.getPath());\n      return null;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/BlockReaderFactory.java"
    }
  }
}