{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "SingleConstraintAppPlacementAllocator.java",
  "functionName": "internalUpdatePendingAsk",
  "functionId": "internalUpdatePendingAsk___newSchedulingRequest-SchedulingRequest__recoverContainer-boolean",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/placement/SingleConstraintAppPlacementAllocator.java",
  "functionStartLine": 115,
  "functionEndLine": 197,
  "numCommitsSeen": 17,
  "timeTaken": 2627,
  "changeHistory": [
    "38af23796971193fa529c3d08ffde8fcd6e607b6"
  ],
  "changeHistoryShort": {
    "38af23796971193fa529c3d08ffde8fcd6e607b6": "Yintroduced"
  },
  "changeHistoryDetails": {
    "38af23796971193fa529c3d08ffde8fcd6e607b6": {
      "type": "Yintroduced",
      "commitMessage": "YARN-6599. Support anti-affinity constraint via AppPlacementAllocator. (Wangda Tan via asuresh)\n",
      "commitDate": "31/01/18 1:30 AM",
      "commitName": "38af23796971193fa529c3d08ffde8fcd6e607b6",
      "commitAuthor": "Arun Suresh",
      "diff": "@@ -0,0 +1,83 @@\n+  private PendingAskUpdateResult internalUpdatePendingAsk(\n+      SchedulingRequest newSchedulingRequest, boolean recoverContainer) {\n+    // When it is a recover container, there must exists an schedulingRequest.\n+    if (recoverContainer \u0026\u0026 schedulingRequest \u003d\u003d null) {\n+      throw new SchedulerInvalidResoureRequestException(\"Trying to recover a \"\n+          + \"container request\u003d\" + newSchedulingRequest.toString() + \", however\"\n+          + \"there\u0027s no existing scheduling request, this should not happen.\");\n+    }\n+\n+    if (schedulingRequest !\u003d null) {\n+      // If we have an old scheduling request, we will make sure that no changes\n+      // made except sizing.\n+      // To avoid unnecessary copy of the data structure, we do this by\n+      // replacing numAllocations with old numAllocations in the\n+      // newSchedulingRequest#getResourceSizing, and compare the two objects.\n+      ResourceSizing sizing \u003d newSchedulingRequest.getResourceSizing();\n+      int existingNumAllocations \u003d\n+          schedulingRequest.getResourceSizing().getNumAllocations();\n+\n+      // When it is a recovered container request, just set\n+      // #newAllocations \u003d #existingAllocations + 1;\n+      int newNumAllocations;\n+      if (recoverContainer) {\n+        newNumAllocations \u003d existingNumAllocations + 1;\n+      } else {\n+        newNumAllocations \u003d sizing.getNumAllocations();\n+      }\n+      sizing.setNumAllocations(existingNumAllocations);\n+\n+      // Compare two objects\n+      if (!schedulingRequest.equals(newSchedulingRequest)) {\n+        // Rollback #numAllocations\n+        sizing.setNumAllocations(newNumAllocations);\n+        throw new SchedulerInvalidResoureRequestException(\n+            \"Invalid updated SchedulingRequest added to scheduler, \"\n+                + \" we only allows changing numAllocations for the updated \"\n+                + \"SchedulingRequest. Old\u003d\" + schedulingRequest.toString()\n+                + \" new\u003d\" + newSchedulingRequest.toString()\n+                + \", if any fields need to be updated, please cancel the \"\n+                + \"old request (by setting numAllocations to 0) and send a \"\n+                + \"SchedulingRequest with different combination of \"\n+                + \"priority/allocationId\");\n+      } else {\n+        if (newNumAllocations \u003d\u003d existingNumAllocations) {\n+          // No update on pending asks, return null.\n+          return null;\n+        }\n+      }\n+\n+      // Rollback #numAllocations\n+      sizing.setNumAllocations(newNumAllocations);\n+\n+      // Basic sanity check\n+      if (newNumAllocations \u003c 0) {\n+        throw new SchedulerInvalidResoureRequestException(\n+            \"numAllocation in ResourceSizing field must be \u003e\u003d 0, \"\n+                + \"updating schedulingRequest failed.\");\n+      }\n+\n+      PendingAskUpdateResult updateResult \u003d new PendingAskUpdateResult(\n+          new PendingAsk(schedulingRequest.getResourceSizing()),\n+          new PendingAsk(newSchedulingRequest.getResourceSizing()),\n+          targetNodePartition, targetNodePartition);\n+\n+      // Ok, now everything is same except numAllocation, update numAllocation.\n+      this.schedulingRequest.getResourceSizing().setNumAllocations(\n+          newNumAllocations);\n+      LOG.info(\n+          \"Update numAllocation from old\u003d\" + existingNumAllocations + \" to new\u003d\"\n+              + newNumAllocations);\n+\n+      return updateResult;\n+    }\n+\n+    // For a new schedulingRequest, we need to validate if we support its asks.\n+    // This will update internal partitions, etc. after the SchedulingRequest is\n+    // valid.\n+    validateAndSetSchedulingRequest(newSchedulingRequest);\n+\n+    return new PendingAskUpdateResult(null,\n+        new PendingAsk(newSchedulingRequest.getResourceSizing()), null,\n+        targetNodePartition);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private PendingAskUpdateResult internalUpdatePendingAsk(\n      SchedulingRequest newSchedulingRequest, boolean recoverContainer) {\n    // When it is a recover container, there must exists an schedulingRequest.\n    if (recoverContainer \u0026\u0026 schedulingRequest \u003d\u003d null) {\n      throw new SchedulerInvalidResoureRequestException(\"Trying to recover a \"\n          + \"container request\u003d\" + newSchedulingRequest.toString() + \", however\"\n          + \"there\u0027s no existing scheduling request, this should not happen.\");\n    }\n\n    if (schedulingRequest !\u003d null) {\n      // If we have an old scheduling request, we will make sure that no changes\n      // made except sizing.\n      // To avoid unnecessary copy of the data structure, we do this by\n      // replacing numAllocations with old numAllocations in the\n      // newSchedulingRequest#getResourceSizing, and compare the two objects.\n      ResourceSizing sizing \u003d newSchedulingRequest.getResourceSizing();\n      int existingNumAllocations \u003d\n          schedulingRequest.getResourceSizing().getNumAllocations();\n\n      // When it is a recovered container request, just set\n      // #newAllocations \u003d #existingAllocations + 1;\n      int newNumAllocations;\n      if (recoverContainer) {\n        newNumAllocations \u003d existingNumAllocations + 1;\n      } else {\n        newNumAllocations \u003d sizing.getNumAllocations();\n      }\n      sizing.setNumAllocations(existingNumAllocations);\n\n      // Compare two objects\n      if (!schedulingRequest.equals(newSchedulingRequest)) {\n        // Rollback #numAllocations\n        sizing.setNumAllocations(newNumAllocations);\n        throw new SchedulerInvalidResoureRequestException(\n            \"Invalid updated SchedulingRequest added to scheduler, \"\n                + \" we only allows changing numAllocations for the updated \"\n                + \"SchedulingRequest. Old\u003d\" + schedulingRequest.toString()\n                + \" new\u003d\" + newSchedulingRequest.toString()\n                + \", if any fields need to be updated, please cancel the \"\n                + \"old request (by setting numAllocations to 0) and send a \"\n                + \"SchedulingRequest with different combination of \"\n                + \"priority/allocationId\");\n      } else {\n        if (newNumAllocations \u003d\u003d existingNumAllocations) {\n          // No update on pending asks, return null.\n          return null;\n        }\n      }\n\n      // Rollback #numAllocations\n      sizing.setNumAllocations(newNumAllocations);\n\n      // Basic sanity check\n      if (newNumAllocations \u003c 0) {\n        throw new SchedulerInvalidResoureRequestException(\n            \"numAllocation in ResourceSizing field must be \u003e\u003d 0, \"\n                + \"updating schedulingRequest failed.\");\n      }\n\n      PendingAskUpdateResult updateResult \u003d new PendingAskUpdateResult(\n          new PendingAsk(schedulingRequest.getResourceSizing()),\n          new PendingAsk(newSchedulingRequest.getResourceSizing()),\n          targetNodePartition, targetNodePartition);\n\n      // Ok, now everything is same except numAllocation, update numAllocation.\n      this.schedulingRequest.getResourceSizing().setNumAllocations(\n          newNumAllocations);\n      LOG.info(\n          \"Update numAllocation from old\u003d\" + existingNumAllocations + \" to new\u003d\"\n              + newNumAllocations);\n\n      return updateResult;\n    }\n\n    // For a new schedulingRequest, we need to validate if we support its asks.\n    // This will update internal partitions, etc. after the SchedulingRequest is\n    // valid.\n    validateAndSetSchedulingRequest(newSchedulingRequest);\n\n    return new PendingAskUpdateResult(null,\n        new PendingAsk(newSchedulingRequest.getResourceSizing()), null,\n        targetNodePartition);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/placement/SingleConstraintAppPlacementAllocator.java"
    }
  }
}