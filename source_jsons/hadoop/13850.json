{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "BlockManager.java",
  "functionName": "rescanPostponedMisreplicatedBlocks",
  "functionId": "rescanPostponedMisreplicatedBlocks",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
  "functionStartLine": 2824,
  "functionEndLine": 2860,
  "numCommitsSeen": 477,
  "timeTaken": 18970,
  "changeHistory": [
    "a7f085d6bf499edf23e650a4f7211c53a442da0e",
    "96c574927a600d15fab919df1fdc9e07887af6c5",
    "f4ba5ff1d70ef92d59851c09c4bd4b43d6c04971",
    "663eba0ab1c73b45f98e46ffc87ad8fd91584046",
    "bc99aaffe7b0ed13b1efc37b6a32cdbd344c2d75",
    "d62b63d297bff12d93de560dd50ddd48743b851d",
    "de480d6c8945bd8b5b00e8657b7a72ce8dd9b6b5",
    "4928f5473394981829e5ffd4b16ea0801baf5c45",
    "ba9371492036983a9899398907ab41fe548f29b3",
    "0c1da5a0300f015a7e39f2b40a73fb06c65a78c8",
    "470c87dbc6c24dd3b370f1ad9e7ab1f6dabd2080",
    "75ead273bea8a7dad61c4f99c3a16cab2697c498",
    "1382ae525c67bf95d8f3a436b547dbc72cfbb177",
    "b7923a356e9f111619375b94d12749d634069347",
    "43295b9f7b8615f0f5d675f191f4500c35e5e552"
  ],
  "changeHistoryShort": {
    "a7f085d6bf499edf23e650a4f7211c53a442da0e": "Ybodychange",
    "96c574927a600d15fab919df1fdc9e07887af6c5": "Ybodychange",
    "f4ba5ff1d70ef92d59851c09c4bd4b43d6c04971": "Ybodychange",
    "663eba0ab1c73b45f98e46ffc87ad8fd91584046": "Ybodychange",
    "bc99aaffe7b0ed13b1efc37b6a32cdbd344c2d75": "Ybodychange",
    "d62b63d297bff12d93de560dd50ddd48743b851d": "Ybodychange",
    "de480d6c8945bd8b5b00e8657b7a72ce8dd9b6b5": "Ybodychange",
    "4928f5473394981829e5ffd4b16ea0801baf5c45": "Ybodychange",
    "ba9371492036983a9899398907ab41fe548f29b3": "Ybodychange",
    "0c1da5a0300f015a7e39f2b40a73fb06c65a78c8": "Ybodychange",
    "470c87dbc6c24dd3b370f1ad9e7ab1f6dabd2080": "Ybodychange",
    "75ead273bea8a7dad61c4f99c3a16cab2697c498": "Ybodychange",
    "1382ae525c67bf95d8f3a436b547dbc72cfbb177": "Ybodychange",
    "b7923a356e9f111619375b94d12749d634069347": "Ymultichange(Ymodifierchange,Ybodychange)",
    "43295b9f7b8615f0f5d675f191f4500c35e5e552": "Ybodychange"
  },
  "changeHistoryDetails": {
    "a7f085d6bf499edf23e650a4f7211c53a442da0e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11832. Switch leftover logs to slf4j format in BlockManager.java. Contributed by Hui Xu and Chen Liang.\n",
      "commitDate": "29/05/17 1:30 AM",
      "commitName": "a7f085d6bf499edf23e650a4f7211c53a442da0e",
      "commitAuthor": "Akira Ajisaka",
      "commitDateOld": "25/05/17 7:35 AM",
      "commitNameOld": "2e41f8803dd46d1bab16c1b206c71be72ea260a1",
      "commitAuthorOld": "Brahma Reddy Battula",
      "daysBetweenCommits": 3.75,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,37 @@\n   void rescanPostponedMisreplicatedBlocks() {\n     if (getPostponedMisreplicatedBlocksCount() \u003d\u003d 0) {\n       return;\n     }\n     namesystem.writeLock();\n     long startTime \u003d Time.monotonicNow();\n     long startSize \u003d postponedMisreplicatedBlocks.size();\n     try {\n       Iterator\u003cBlock\u003e it \u003d postponedMisreplicatedBlocks.iterator();\n       for (int i\u003d0; i \u003c blocksPerPostpondedRescan \u0026\u0026 it.hasNext(); i++) {\n         Block b \u003d it.next();\n         it.remove();\n \n         BlockInfo bi \u003d getStoredBlock(b);\n         if (bi \u003d\u003d null) {\n-          if (LOG.isDebugEnabled()) {\n-            LOG.debug(\"BLOCK* rescanPostponedMisreplicatedBlocks: \" +\n-                \"Postponed mis-replicated block \" + b + \" no longer found \" +\n-                \"in block map.\");\n-          }\n+          LOG.debug(\"BLOCK* rescanPostponedMisreplicatedBlocks: \" +\n+              \"Postponed mis-replicated block {} no longer found \" +\n+              \"in block map.\", b);\n           continue;\n         }\n         MisReplicationResult res \u003d processMisReplicatedBlock(bi);\n-        if (LOG.isDebugEnabled()) {\n-          LOG.debug(\"BLOCK* rescanPostponedMisreplicatedBlocks: \" +\n-              \"Re-scanned block \" + b + \", result is \" + res);\n-        }\n+        LOG.debug(\"BLOCK* rescanPostponedMisreplicatedBlocks: \" +\n+            \"Re-scanned block {}, result is {}\", b, res);\n         if (res \u003d\u003d MisReplicationResult.POSTPONE) {\n           rescannedMisreplicatedBlocks.add(b);\n         }\n       }\n     } finally {\n       postponedMisreplicatedBlocks.addAll(rescannedMisreplicatedBlocks);\n       rescannedMisreplicatedBlocks.clear();\n       long endSize \u003d postponedMisreplicatedBlocks.size();\n       namesystem.writeUnlock();\n-      LOG.info(\"Rescan of postponedMisreplicatedBlocks completed in \" +\n-          (Time.monotonicNow() - startTime) + \" msecs. \" +\n-          endSize + \" blocks are left. \" +\n-          (startSize - endSize) + \" blocks were removed.\");\n+      LOG.info(\"Rescan of postponedMisreplicatedBlocks completed in {}\" +\n+          \" msecs. {} blocks are left. {} blocks were removed.\",\n+          (Time.monotonicNow() - startTime), endSize, (startSize - endSize));\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void rescanPostponedMisreplicatedBlocks() {\n    if (getPostponedMisreplicatedBlocksCount() \u003d\u003d 0) {\n      return;\n    }\n    namesystem.writeLock();\n    long startTime \u003d Time.monotonicNow();\n    long startSize \u003d postponedMisreplicatedBlocks.size();\n    try {\n      Iterator\u003cBlock\u003e it \u003d postponedMisreplicatedBlocks.iterator();\n      for (int i\u003d0; i \u003c blocksPerPostpondedRescan \u0026\u0026 it.hasNext(); i++) {\n        Block b \u003d it.next();\n        it.remove();\n\n        BlockInfo bi \u003d getStoredBlock(b);\n        if (bi \u003d\u003d null) {\n          LOG.debug(\"BLOCK* rescanPostponedMisreplicatedBlocks: \" +\n              \"Postponed mis-replicated block {} no longer found \" +\n              \"in block map.\", b);\n          continue;\n        }\n        MisReplicationResult res \u003d processMisReplicatedBlock(bi);\n        LOG.debug(\"BLOCK* rescanPostponedMisreplicatedBlocks: \" +\n            \"Re-scanned block {}, result is {}\", b, res);\n        if (res \u003d\u003d MisReplicationResult.POSTPONE) {\n          rescannedMisreplicatedBlocks.add(b);\n        }\n      }\n    } finally {\n      postponedMisreplicatedBlocks.addAll(rescannedMisreplicatedBlocks);\n      rescannedMisreplicatedBlocks.clear();\n      long endSize \u003d postponedMisreplicatedBlocks.size();\n      namesystem.writeUnlock();\n      LOG.info(\"Rescan of postponedMisreplicatedBlocks completed in {}\" +\n          \" msecs. {} blocks are left. {} blocks were removed.\",\n          (Time.monotonicNow() - startTime), endSize, (startSize - endSize));\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "96c574927a600d15fab919df1fdc9e07887af6c5": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8674. Improve performance of postponed block scans. Contributed by Daryn Sharp.\n",
      "commitDate": "01/12/16 10:11 AM",
      "commitName": "96c574927a600d15fab919df1fdc9e07887af6c5",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "23/11/16 4:42 PM",
      "commitNameOld": "de4894936a5b581572f35fa5b8979d9f23da0891",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 7.73,
      "commitsBetweenForRepo": 48,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,70 +1,42 @@\n   void rescanPostponedMisreplicatedBlocks() {\n     if (getPostponedMisreplicatedBlocksCount() \u003d\u003d 0) {\n       return;\n     }\n-    long startTimeRescanPostponedMisReplicatedBlocks \u003d Time.monotonicNow();\n     namesystem.writeLock();\n-    long startPostponedMisReplicatedBlocksCount \u003d\n-        getPostponedMisreplicatedBlocksCount();\n+    long startTime \u003d Time.monotonicNow();\n+    long startSize \u003d postponedMisreplicatedBlocks.size();\n     try {\n-      // blocksPerRescan is the configured number of blocks per rescan.\n-      // Randomly select blocksPerRescan consecutive blocks from the HashSet\n-      // when the number of blocks remaining is larger than blocksPerRescan.\n-      // The reason we don\u0027t always pick the first blocksPerRescan blocks is to\n-      // handle the case if for some reason some datanodes remain in\n-      // content stale state for a long time and only impact the first\n-      // blocksPerRescan blocks.\n-      int i \u003d 0;\n-      long startIndex \u003d 0;\n-      long blocksPerRescan \u003d\n-          datanodeManager.getBlocksPerPostponedMisreplicatedBlocksRescan();\n-      long base \u003d getPostponedMisreplicatedBlocksCount() - blocksPerRescan;\n-      if (base \u003e 0) {\n-        startIndex \u003d ThreadLocalRandom.current().nextLong() % (base+1);\n-        if (startIndex \u003c 0) {\n-          startIndex +\u003d (base+1);\n-        }\n-      }\n       Iterator\u003cBlock\u003e it \u003d postponedMisreplicatedBlocks.iterator();\n-      for (int tmp \u003d 0; tmp \u003c startIndex; tmp++) {\n-        it.next();\n-      }\n-\n-      for (;it.hasNext(); i++) {\n+      for (int i\u003d0; i \u003c blocksPerPostpondedRescan \u0026\u0026 it.hasNext(); i++) {\n         Block b \u003d it.next();\n-        if (i \u003e\u003d blocksPerRescan) {\n-          break;\n-        }\n+        it.remove();\n \n         BlockInfo bi \u003d getStoredBlock(b);\n         if (bi \u003d\u003d null) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"BLOCK* rescanPostponedMisreplicatedBlocks: \" +\n                 \"Postponed mis-replicated block \" + b + \" no longer found \" +\n                 \"in block map.\");\n           }\n-          it.remove();\n-          postponedMisreplicatedBlocksCount.decrementAndGet();\n           continue;\n         }\n         MisReplicationResult res \u003d processMisReplicatedBlock(bi);\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"BLOCK* rescanPostponedMisreplicatedBlocks: \" +\n               \"Re-scanned block \" + b + \", result is \" + res);\n         }\n-        if (res !\u003d MisReplicationResult.POSTPONE) {\n-          it.remove();\n-          postponedMisreplicatedBlocksCount.decrementAndGet();\n+        if (res \u003d\u003d MisReplicationResult.POSTPONE) {\n+          rescannedMisreplicatedBlocks.add(b);\n         }\n       }\n     } finally {\n-      long endPostponedMisReplicatedBlocksCount \u003d\n-          getPostponedMisreplicatedBlocksCount();\n+      postponedMisreplicatedBlocks.addAll(rescannedMisreplicatedBlocks);\n+      rescannedMisreplicatedBlocks.clear();\n+      long endSize \u003d postponedMisreplicatedBlocks.size();\n       namesystem.writeUnlock();\n       LOG.info(\"Rescan of postponedMisreplicatedBlocks completed in \" +\n-          (Time.monotonicNow() - startTimeRescanPostponedMisReplicatedBlocks) +\n-          \" msecs. \" + endPostponedMisReplicatedBlocksCount +\n-          \" blocks are left. \" + (startPostponedMisReplicatedBlocksCount -\n-          endPostponedMisReplicatedBlocksCount) + \" blocks are removed.\");\n+          (Time.monotonicNow() - startTime) + \" msecs. \" +\n+          endSize + \" blocks are left. \" +\n+          (startSize - endSize) + \" blocks were removed.\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void rescanPostponedMisreplicatedBlocks() {\n    if (getPostponedMisreplicatedBlocksCount() \u003d\u003d 0) {\n      return;\n    }\n    namesystem.writeLock();\n    long startTime \u003d Time.monotonicNow();\n    long startSize \u003d postponedMisreplicatedBlocks.size();\n    try {\n      Iterator\u003cBlock\u003e it \u003d postponedMisreplicatedBlocks.iterator();\n      for (int i\u003d0; i \u003c blocksPerPostpondedRescan \u0026\u0026 it.hasNext(); i++) {\n        Block b \u003d it.next();\n        it.remove();\n\n        BlockInfo bi \u003d getStoredBlock(b);\n        if (bi \u003d\u003d null) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"BLOCK* rescanPostponedMisreplicatedBlocks: \" +\n                \"Postponed mis-replicated block \" + b + \" no longer found \" +\n                \"in block map.\");\n          }\n          continue;\n        }\n        MisReplicationResult res \u003d processMisReplicatedBlock(bi);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"BLOCK* rescanPostponedMisreplicatedBlocks: \" +\n              \"Re-scanned block \" + b + \", result is \" + res);\n        }\n        if (res \u003d\u003d MisReplicationResult.POSTPONE) {\n          rescannedMisreplicatedBlocks.add(b);\n        }\n      }\n    } finally {\n      postponedMisreplicatedBlocks.addAll(rescannedMisreplicatedBlocks);\n      rescannedMisreplicatedBlocks.clear();\n      long endSize \u003d postponedMisreplicatedBlocks.size();\n      namesystem.writeUnlock();\n      LOG.info(\"Rescan of postponedMisreplicatedBlocks completed in \" +\n          (Time.monotonicNow() - startTime) + \" msecs. \" +\n          endSize + \" blocks are left. \" +\n          (startSize - endSize) + \" blocks were removed.\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "f4ba5ff1d70ef92d59851c09c4bd4b43d6c04971": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10710. In BlockManager#rescanPostponedMisreplicatedBlocks(), postponed misreplicated block counts should be retrieved within the NN lock protection.Contributed by GAO Rui.\n",
      "commitDate": "03/08/16 12:42 PM",
      "commitName": "f4ba5ff1d70ef92d59851c09c4bd4b43d6c04971",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "01/08/16 10:34 PM",
      "commitNameOld": "c4463f2ef20d2cb634a1249246f83c451975f3dc",
      "commitAuthorOld": "Konstantin V Shvachko",
      "daysBetweenCommits": 1.59,
      "commitsBetweenForRepo": 21,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,70 +1,70 @@\n   void rescanPostponedMisreplicatedBlocks() {\n     if (getPostponedMisreplicatedBlocksCount() \u003d\u003d 0) {\n       return;\n     }\n     long startTimeRescanPostponedMisReplicatedBlocks \u003d Time.monotonicNow();\n+    namesystem.writeLock();\n     long startPostponedMisReplicatedBlocksCount \u003d\n         getPostponedMisreplicatedBlocksCount();\n-    namesystem.writeLock();\n     try {\n       // blocksPerRescan is the configured number of blocks per rescan.\n       // Randomly select blocksPerRescan consecutive blocks from the HashSet\n       // when the number of blocks remaining is larger than blocksPerRescan.\n       // The reason we don\u0027t always pick the first blocksPerRescan blocks is to\n       // handle the case if for some reason some datanodes remain in\n       // content stale state for a long time and only impact the first\n       // blocksPerRescan blocks.\n       int i \u003d 0;\n       long startIndex \u003d 0;\n       long blocksPerRescan \u003d\n           datanodeManager.getBlocksPerPostponedMisreplicatedBlocksRescan();\n       long base \u003d getPostponedMisreplicatedBlocksCount() - blocksPerRescan;\n       if (base \u003e 0) {\n         startIndex \u003d ThreadLocalRandom.current().nextLong() % (base+1);\n         if (startIndex \u003c 0) {\n           startIndex +\u003d (base+1);\n         }\n       }\n       Iterator\u003cBlock\u003e it \u003d postponedMisreplicatedBlocks.iterator();\n       for (int tmp \u003d 0; tmp \u003c startIndex; tmp++) {\n         it.next();\n       }\n \n       for (;it.hasNext(); i++) {\n         Block b \u003d it.next();\n         if (i \u003e\u003d blocksPerRescan) {\n           break;\n         }\n \n         BlockInfo bi \u003d getStoredBlock(b);\n         if (bi \u003d\u003d null) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"BLOCK* rescanPostponedMisreplicatedBlocks: \" +\n                 \"Postponed mis-replicated block \" + b + \" no longer found \" +\n                 \"in block map.\");\n           }\n           it.remove();\n           postponedMisreplicatedBlocksCount.decrementAndGet();\n           continue;\n         }\n         MisReplicationResult res \u003d processMisReplicatedBlock(bi);\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"BLOCK* rescanPostponedMisreplicatedBlocks: \" +\n               \"Re-scanned block \" + b + \", result is \" + res);\n         }\n         if (res !\u003d MisReplicationResult.POSTPONE) {\n           it.remove();\n           postponedMisreplicatedBlocksCount.decrementAndGet();\n         }\n       }\n     } finally {\n-      namesystem.writeUnlock();\n       long endPostponedMisReplicatedBlocksCount \u003d\n           getPostponedMisreplicatedBlocksCount();\n+      namesystem.writeUnlock();\n       LOG.info(\"Rescan of postponedMisreplicatedBlocks completed in \" +\n           (Time.monotonicNow() - startTimeRescanPostponedMisReplicatedBlocks) +\n           \" msecs. \" + endPostponedMisReplicatedBlocksCount +\n           \" blocks are left. \" + (startPostponedMisReplicatedBlocksCount -\n           endPostponedMisReplicatedBlocksCount) + \" blocks are removed.\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void rescanPostponedMisreplicatedBlocks() {\n    if (getPostponedMisreplicatedBlocksCount() \u003d\u003d 0) {\n      return;\n    }\n    long startTimeRescanPostponedMisReplicatedBlocks \u003d Time.monotonicNow();\n    namesystem.writeLock();\n    long startPostponedMisReplicatedBlocksCount \u003d\n        getPostponedMisreplicatedBlocksCount();\n    try {\n      // blocksPerRescan is the configured number of blocks per rescan.\n      // Randomly select blocksPerRescan consecutive blocks from the HashSet\n      // when the number of blocks remaining is larger than blocksPerRescan.\n      // The reason we don\u0027t always pick the first blocksPerRescan blocks is to\n      // handle the case if for some reason some datanodes remain in\n      // content stale state for a long time and only impact the first\n      // blocksPerRescan blocks.\n      int i \u003d 0;\n      long startIndex \u003d 0;\n      long blocksPerRescan \u003d\n          datanodeManager.getBlocksPerPostponedMisreplicatedBlocksRescan();\n      long base \u003d getPostponedMisreplicatedBlocksCount() - blocksPerRescan;\n      if (base \u003e 0) {\n        startIndex \u003d ThreadLocalRandom.current().nextLong() % (base+1);\n        if (startIndex \u003c 0) {\n          startIndex +\u003d (base+1);\n        }\n      }\n      Iterator\u003cBlock\u003e it \u003d postponedMisreplicatedBlocks.iterator();\n      for (int tmp \u003d 0; tmp \u003c startIndex; tmp++) {\n        it.next();\n      }\n\n      for (;it.hasNext(); i++) {\n        Block b \u003d it.next();\n        if (i \u003e\u003d blocksPerRescan) {\n          break;\n        }\n\n        BlockInfo bi \u003d getStoredBlock(b);\n        if (bi \u003d\u003d null) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"BLOCK* rescanPostponedMisreplicatedBlocks: \" +\n                \"Postponed mis-replicated block \" + b + \" no longer found \" +\n                \"in block map.\");\n          }\n          it.remove();\n          postponedMisreplicatedBlocksCount.decrementAndGet();\n          continue;\n        }\n        MisReplicationResult res \u003d processMisReplicatedBlock(bi);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"BLOCK* rescanPostponedMisreplicatedBlocks: \" +\n              \"Re-scanned block \" + b + \", result is \" + res);\n        }\n        if (res !\u003d MisReplicationResult.POSTPONE) {\n          it.remove();\n          postponedMisreplicatedBlocksCount.decrementAndGet();\n        }\n      }\n    } finally {\n      long endPostponedMisReplicatedBlocksCount \u003d\n          getPostponedMisreplicatedBlocksCount();\n      namesystem.writeUnlock();\n      LOG.info(\"Rescan of postponedMisreplicatedBlocks completed in \" +\n          (Time.monotonicNow() - startTimeRescanPostponedMisReplicatedBlocks) +\n          \" msecs. \" + endPostponedMisReplicatedBlocksCount +\n          \" blocks are left. \" + (startPostponedMisReplicatedBlocksCount -\n          endPostponedMisReplicatedBlocksCount) + \" blocks are removed.\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "663eba0ab1c73b45f98e46ffc87ad8fd91584046": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HDFS-8623. Refactor NameNode handling of invalid, corrupt, and under-recovery blocks. Contributed by Zhe Zhang.\"\n\nThis reverts commit de480d6c8945bd8b5b00e8657b7a72ce8dd9b6b5.\n",
      "commitDate": "06/08/15 10:21 AM",
      "commitName": "663eba0ab1c73b45f98e46ffc87ad8fd91584046",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "31/07/15 4:15 PM",
      "commitNameOld": "d311a38a6b32bbb210bd8748cfb65463e9c0740e",
      "commitAuthorOld": "Xiaoyu Yao",
      "daysBetweenCommits": 5.75,
      "commitsBetweenForRepo": 23,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,70 +1,70 @@\n   void rescanPostponedMisreplicatedBlocks() {\n     if (getPostponedMisreplicatedBlocksCount() \u003d\u003d 0) {\n       return;\n     }\n     long startTimeRescanPostponedMisReplicatedBlocks \u003d Time.monotonicNow();\n     long startPostponedMisReplicatedBlocksCount \u003d\n         getPostponedMisreplicatedBlocksCount();\n     namesystem.writeLock();\n     try {\n       // blocksPerRescan is the configured number of blocks per rescan.\n       // Randomly select blocksPerRescan consecutive blocks from the HashSet\n       // when the number of blocks remaining is larger than blocksPerRescan.\n       // The reason we don\u0027t always pick the first blocksPerRescan blocks is to\n       // handle the case if for some reason some datanodes remain in\n       // content stale state for a long time and only impact the first\n       // blocksPerRescan blocks.\n       int i \u003d 0;\n       long startIndex \u003d 0;\n       long blocksPerRescan \u003d\n           datanodeManager.getBlocksPerPostponedMisreplicatedBlocksRescan();\n       long base \u003d getPostponedMisreplicatedBlocksCount() - blocksPerRescan;\n       if (base \u003e 0) {\n         startIndex \u003d ThreadLocalRandom.current().nextLong() % (base+1);\n         if (startIndex \u003c 0) {\n           startIndex +\u003d (base+1);\n         }\n       }\n       Iterator\u003cBlock\u003e it \u003d postponedMisreplicatedBlocks.iterator();\n       for (int tmp \u003d 0; tmp \u003c startIndex; tmp++) {\n         it.next();\n       }\n \n       for (;it.hasNext(); i++) {\n         Block b \u003d it.next();\n         if (i \u003e\u003d blocksPerRescan) {\n           break;\n         }\n \n-        BlockInfo bi \u003d getStoredBlock(b);\n+        BlockInfo bi \u003d blocksMap.getStoredBlock(b);\n         if (bi \u003d\u003d null) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"BLOCK* rescanPostponedMisreplicatedBlocks: \" +\n                 \"Postponed mis-replicated block \" + b + \" no longer found \" +\n                 \"in block map.\");\n           }\n           it.remove();\n           postponedMisreplicatedBlocksCount.decrementAndGet();\n           continue;\n         }\n         MisReplicationResult res \u003d processMisReplicatedBlock(bi);\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"BLOCK* rescanPostponedMisreplicatedBlocks: \" +\n               \"Re-scanned block \" + b + \", result is \" + res);\n         }\n         if (res !\u003d MisReplicationResult.POSTPONE) {\n           it.remove();\n           postponedMisreplicatedBlocksCount.decrementAndGet();\n         }\n       }\n     } finally {\n       namesystem.writeUnlock();\n       long endPostponedMisReplicatedBlocksCount \u003d\n           getPostponedMisreplicatedBlocksCount();\n       LOG.info(\"Rescan of postponedMisreplicatedBlocks completed in \" +\n           (Time.monotonicNow() - startTimeRescanPostponedMisReplicatedBlocks) +\n           \" msecs. \" + endPostponedMisReplicatedBlocksCount +\n           \" blocks are left. \" + (startPostponedMisReplicatedBlocksCount -\n           endPostponedMisReplicatedBlocksCount) + \" blocks are removed.\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void rescanPostponedMisreplicatedBlocks() {\n    if (getPostponedMisreplicatedBlocksCount() \u003d\u003d 0) {\n      return;\n    }\n    long startTimeRescanPostponedMisReplicatedBlocks \u003d Time.monotonicNow();\n    long startPostponedMisReplicatedBlocksCount \u003d\n        getPostponedMisreplicatedBlocksCount();\n    namesystem.writeLock();\n    try {\n      // blocksPerRescan is the configured number of blocks per rescan.\n      // Randomly select blocksPerRescan consecutive blocks from the HashSet\n      // when the number of blocks remaining is larger than blocksPerRescan.\n      // The reason we don\u0027t always pick the first blocksPerRescan blocks is to\n      // handle the case if for some reason some datanodes remain in\n      // content stale state for a long time and only impact the first\n      // blocksPerRescan blocks.\n      int i \u003d 0;\n      long startIndex \u003d 0;\n      long blocksPerRescan \u003d\n          datanodeManager.getBlocksPerPostponedMisreplicatedBlocksRescan();\n      long base \u003d getPostponedMisreplicatedBlocksCount() - blocksPerRescan;\n      if (base \u003e 0) {\n        startIndex \u003d ThreadLocalRandom.current().nextLong() % (base+1);\n        if (startIndex \u003c 0) {\n          startIndex +\u003d (base+1);\n        }\n      }\n      Iterator\u003cBlock\u003e it \u003d postponedMisreplicatedBlocks.iterator();\n      for (int tmp \u003d 0; tmp \u003c startIndex; tmp++) {\n        it.next();\n      }\n\n      for (;it.hasNext(); i++) {\n        Block b \u003d it.next();\n        if (i \u003e\u003d blocksPerRescan) {\n          break;\n        }\n\n        BlockInfo bi \u003d blocksMap.getStoredBlock(b);\n        if (bi \u003d\u003d null) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"BLOCK* rescanPostponedMisreplicatedBlocks: \" +\n                \"Postponed mis-replicated block \" + b + \" no longer found \" +\n                \"in block map.\");\n          }\n          it.remove();\n          postponedMisreplicatedBlocksCount.decrementAndGet();\n          continue;\n        }\n        MisReplicationResult res \u003d processMisReplicatedBlock(bi);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"BLOCK* rescanPostponedMisreplicatedBlocks: \" +\n              \"Re-scanned block \" + b + \", result is \" + res);\n        }\n        if (res !\u003d MisReplicationResult.POSTPONE) {\n          it.remove();\n          postponedMisreplicatedBlocksCount.decrementAndGet();\n        }\n      }\n    } finally {\n      namesystem.writeUnlock();\n      long endPostponedMisReplicatedBlocksCount \u003d\n          getPostponedMisreplicatedBlocksCount();\n      LOG.info(\"Rescan of postponedMisreplicatedBlocks completed in \" +\n          (Time.monotonicNow() - startTimeRescanPostponedMisReplicatedBlocks) +\n          \" msecs. \" + endPostponedMisReplicatedBlocksCount +\n          \" blocks are left. \" + (startPostponedMisReplicatedBlocksCount -\n          endPostponedMisReplicatedBlocksCount) + \" blocks are removed.\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "bc99aaffe7b0ed13b1efc37b6a32cdbd344c2d75": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HDFS-8652. Track BlockInfo instead of Block in CorruptReplicasMap. Contributed by Jing Zhao.\"\n\nThis reverts commit d62b63d297bff12d93de560dd50ddd48743b851d.\n",
      "commitDate": "07/07/15 10:13 AM",
      "commitName": "bc99aaffe7b0ed13b1efc37b6a32cdbd344c2d75",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "06/07/15 3:54 PM",
      "commitNameOld": "d62b63d297bff12d93de560dd50ddd48743b851d",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 0.76,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,70 +1,70 @@\n   void rescanPostponedMisreplicatedBlocks() {\n     if (getPostponedMisreplicatedBlocksCount() \u003d\u003d 0) {\n       return;\n     }\n     long startTimeRescanPostponedMisReplicatedBlocks \u003d Time.monotonicNow();\n     long startPostponedMisReplicatedBlocksCount \u003d\n         getPostponedMisreplicatedBlocksCount();\n     namesystem.writeLock();\n     try {\n       // blocksPerRescan is the configured number of blocks per rescan.\n       // Randomly select blocksPerRescan consecutive blocks from the HashSet\n       // when the number of blocks remaining is larger than blocksPerRescan.\n       // The reason we don\u0027t always pick the first blocksPerRescan blocks is to\n       // handle the case if for some reason some datanodes remain in\n       // content stale state for a long time and only impact the first\n       // blocksPerRescan blocks.\n       int i \u003d 0;\n       long startIndex \u003d 0;\n       long blocksPerRescan \u003d\n           datanodeManager.getBlocksPerPostponedMisreplicatedBlocksRescan();\n       long base \u003d getPostponedMisreplicatedBlocksCount() - blocksPerRescan;\n       if (base \u003e 0) {\n         startIndex \u003d ThreadLocalRandom.current().nextLong() % (base+1);\n         if (startIndex \u003c 0) {\n           startIndex +\u003d (base+1);\n         }\n       }\n-      Iterator\u003cBlockInfo\u003e it \u003d postponedMisreplicatedBlocks.iterator();\n+      Iterator\u003cBlock\u003e it \u003d postponedMisreplicatedBlocks.iterator();\n       for (int tmp \u003d 0; tmp \u003c startIndex; tmp++) {\n         it.next();\n       }\n \n       for (;it.hasNext(); i++) {\n         Block b \u003d it.next();\n         if (i \u003e\u003d blocksPerRescan) {\n           break;\n         }\n \n         BlockInfo bi \u003d getStoredBlock(b);\n         if (bi \u003d\u003d null) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"BLOCK* rescanPostponedMisreplicatedBlocks: \" +\n                 \"Postponed mis-replicated block \" + b + \" no longer found \" +\n                 \"in block map.\");\n           }\n           it.remove();\n           postponedMisreplicatedBlocksCount.decrementAndGet();\n           continue;\n         }\n         MisReplicationResult res \u003d processMisReplicatedBlock(bi);\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"BLOCK* rescanPostponedMisreplicatedBlocks: \" +\n               \"Re-scanned block \" + b + \", result is \" + res);\n         }\n         if (res !\u003d MisReplicationResult.POSTPONE) {\n           it.remove();\n           postponedMisreplicatedBlocksCount.decrementAndGet();\n         }\n       }\n     } finally {\n       namesystem.writeUnlock();\n       long endPostponedMisReplicatedBlocksCount \u003d\n           getPostponedMisreplicatedBlocksCount();\n       LOG.info(\"Rescan of postponedMisreplicatedBlocks completed in \" +\n           (Time.monotonicNow() - startTimeRescanPostponedMisReplicatedBlocks) +\n           \" msecs. \" + endPostponedMisReplicatedBlocksCount +\n           \" blocks are left. \" + (startPostponedMisReplicatedBlocksCount -\n           endPostponedMisReplicatedBlocksCount) + \" blocks are removed.\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void rescanPostponedMisreplicatedBlocks() {\n    if (getPostponedMisreplicatedBlocksCount() \u003d\u003d 0) {\n      return;\n    }\n    long startTimeRescanPostponedMisReplicatedBlocks \u003d Time.monotonicNow();\n    long startPostponedMisReplicatedBlocksCount \u003d\n        getPostponedMisreplicatedBlocksCount();\n    namesystem.writeLock();\n    try {\n      // blocksPerRescan is the configured number of blocks per rescan.\n      // Randomly select blocksPerRescan consecutive blocks from the HashSet\n      // when the number of blocks remaining is larger than blocksPerRescan.\n      // The reason we don\u0027t always pick the first blocksPerRescan blocks is to\n      // handle the case if for some reason some datanodes remain in\n      // content stale state for a long time and only impact the first\n      // blocksPerRescan blocks.\n      int i \u003d 0;\n      long startIndex \u003d 0;\n      long blocksPerRescan \u003d\n          datanodeManager.getBlocksPerPostponedMisreplicatedBlocksRescan();\n      long base \u003d getPostponedMisreplicatedBlocksCount() - blocksPerRescan;\n      if (base \u003e 0) {\n        startIndex \u003d ThreadLocalRandom.current().nextLong() % (base+1);\n        if (startIndex \u003c 0) {\n          startIndex +\u003d (base+1);\n        }\n      }\n      Iterator\u003cBlock\u003e it \u003d postponedMisreplicatedBlocks.iterator();\n      for (int tmp \u003d 0; tmp \u003c startIndex; tmp++) {\n        it.next();\n      }\n\n      for (;it.hasNext(); i++) {\n        Block b \u003d it.next();\n        if (i \u003e\u003d blocksPerRescan) {\n          break;\n        }\n\n        BlockInfo bi \u003d getStoredBlock(b);\n        if (bi \u003d\u003d null) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"BLOCK* rescanPostponedMisreplicatedBlocks: \" +\n                \"Postponed mis-replicated block \" + b + \" no longer found \" +\n                \"in block map.\");\n          }\n          it.remove();\n          postponedMisreplicatedBlocksCount.decrementAndGet();\n          continue;\n        }\n        MisReplicationResult res \u003d processMisReplicatedBlock(bi);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"BLOCK* rescanPostponedMisreplicatedBlocks: \" +\n              \"Re-scanned block \" + b + \", result is \" + res);\n        }\n        if (res !\u003d MisReplicationResult.POSTPONE) {\n          it.remove();\n          postponedMisreplicatedBlocksCount.decrementAndGet();\n        }\n      }\n    } finally {\n      namesystem.writeUnlock();\n      long endPostponedMisReplicatedBlocksCount \u003d\n          getPostponedMisreplicatedBlocksCount();\n      LOG.info(\"Rescan of postponedMisreplicatedBlocks completed in \" +\n          (Time.monotonicNow() - startTimeRescanPostponedMisReplicatedBlocks) +\n          \" msecs. \" + endPostponedMisReplicatedBlocksCount +\n          \" blocks are left. \" + (startPostponedMisReplicatedBlocksCount -\n          endPostponedMisReplicatedBlocksCount) + \" blocks are removed.\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "d62b63d297bff12d93de560dd50ddd48743b851d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8652. Track BlockInfo instead of Block in CorruptReplicasMap. Contributed by Jing Zhao.\n",
      "commitDate": "06/07/15 3:54 PM",
      "commitName": "d62b63d297bff12d93de560dd50ddd48743b851d",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "29/06/15 11:00 AM",
      "commitNameOld": "d3fed8e653ed9e18d3a29a11c4b24a628ac770bb",
      "commitAuthorOld": "Benoy Antony",
      "daysBetweenCommits": 7.2,
      "commitsBetweenForRepo": 50,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,70 +1,70 @@\n   void rescanPostponedMisreplicatedBlocks() {\n     if (getPostponedMisreplicatedBlocksCount() \u003d\u003d 0) {\n       return;\n     }\n     long startTimeRescanPostponedMisReplicatedBlocks \u003d Time.monotonicNow();\n     long startPostponedMisReplicatedBlocksCount \u003d\n         getPostponedMisreplicatedBlocksCount();\n     namesystem.writeLock();\n     try {\n       // blocksPerRescan is the configured number of blocks per rescan.\n       // Randomly select blocksPerRescan consecutive blocks from the HashSet\n       // when the number of blocks remaining is larger than blocksPerRescan.\n       // The reason we don\u0027t always pick the first blocksPerRescan blocks is to\n       // handle the case if for some reason some datanodes remain in\n       // content stale state for a long time and only impact the first\n       // blocksPerRescan blocks.\n       int i \u003d 0;\n       long startIndex \u003d 0;\n       long blocksPerRescan \u003d\n           datanodeManager.getBlocksPerPostponedMisreplicatedBlocksRescan();\n       long base \u003d getPostponedMisreplicatedBlocksCount() - blocksPerRescan;\n       if (base \u003e 0) {\n         startIndex \u003d ThreadLocalRandom.current().nextLong() % (base+1);\n         if (startIndex \u003c 0) {\n           startIndex +\u003d (base+1);\n         }\n       }\n-      Iterator\u003cBlock\u003e it \u003d postponedMisreplicatedBlocks.iterator();\n+      Iterator\u003cBlockInfo\u003e it \u003d postponedMisreplicatedBlocks.iterator();\n       for (int tmp \u003d 0; tmp \u003c startIndex; tmp++) {\n         it.next();\n       }\n \n       for (;it.hasNext(); i++) {\n         Block b \u003d it.next();\n         if (i \u003e\u003d blocksPerRescan) {\n           break;\n         }\n \n         BlockInfo bi \u003d getStoredBlock(b);\n         if (bi \u003d\u003d null) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"BLOCK* rescanPostponedMisreplicatedBlocks: \" +\n                 \"Postponed mis-replicated block \" + b + \" no longer found \" +\n                 \"in block map.\");\n           }\n           it.remove();\n           postponedMisreplicatedBlocksCount.decrementAndGet();\n           continue;\n         }\n         MisReplicationResult res \u003d processMisReplicatedBlock(bi);\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"BLOCK* rescanPostponedMisreplicatedBlocks: \" +\n               \"Re-scanned block \" + b + \", result is \" + res);\n         }\n         if (res !\u003d MisReplicationResult.POSTPONE) {\n           it.remove();\n           postponedMisreplicatedBlocksCount.decrementAndGet();\n         }\n       }\n     } finally {\n       namesystem.writeUnlock();\n       long endPostponedMisReplicatedBlocksCount \u003d\n           getPostponedMisreplicatedBlocksCount();\n       LOG.info(\"Rescan of postponedMisreplicatedBlocks completed in \" +\n           (Time.monotonicNow() - startTimeRescanPostponedMisReplicatedBlocks) +\n           \" msecs. \" + endPostponedMisReplicatedBlocksCount +\n           \" blocks are left. \" + (startPostponedMisReplicatedBlocksCount -\n           endPostponedMisReplicatedBlocksCount) + \" blocks are removed.\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void rescanPostponedMisreplicatedBlocks() {\n    if (getPostponedMisreplicatedBlocksCount() \u003d\u003d 0) {\n      return;\n    }\n    long startTimeRescanPostponedMisReplicatedBlocks \u003d Time.monotonicNow();\n    long startPostponedMisReplicatedBlocksCount \u003d\n        getPostponedMisreplicatedBlocksCount();\n    namesystem.writeLock();\n    try {\n      // blocksPerRescan is the configured number of blocks per rescan.\n      // Randomly select blocksPerRescan consecutive blocks from the HashSet\n      // when the number of blocks remaining is larger than blocksPerRescan.\n      // The reason we don\u0027t always pick the first blocksPerRescan blocks is to\n      // handle the case if for some reason some datanodes remain in\n      // content stale state for a long time and only impact the first\n      // blocksPerRescan blocks.\n      int i \u003d 0;\n      long startIndex \u003d 0;\n      long blocksPerRescan \u003d\n          datanodeManager.getBlocksPerPostponedMisreplicatedBlocksRescan();\n      long base \u003d getPostponedMisreplicatedBlocksCount() - blocksPerRescan;\n      if (base \u003e 0) {\n        startIndex \u003d ThreadLocalRandom.current().nextLong() % (base+1);\n        if (startIndex \u003c 0) {\n          startIndex +\u003d (base+1);\n        }\n      }\n      Iterator\u003cBlockInfo\u003e it \u003d postponedMisreplicatedBlocks.iterator();\n      for (int tmp \u003d 0; tmp \u003c startIndex; tmp++) {\n        it.next();\n      }\n\n      for (;it.hasNext(); i++) {\n        Block b \u003d it.next();\n        if (i \u003e\u003d blocksPerRescan) {\n          break;\n        }\n\n        BlockInfo bi \u003d getStoredBlock(b);\n        if (bi \u003d\u003d null) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"BLOCK* rescanPostponedMisreplicatedBlocks: \" +\n                \"Postponed mis-replicated block \" + b + \" no longer found \" +\n                \"in block map.\");\n          }\n          it.remove();\n          postponedMisreplicatedBlocksCount.decrementAndGet();\n          continue;\n        }\n        MisReplicationResult res \u003d processMisReplicatedBlock(bi);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"BLOCK* rescanPostponedMisreplicatedBlocks: \" +\n              \"Re-scanned block \" + b + \", result is \" + res);\n        }\n        if (res !\u003d MisReplicationResult.POSTPONE) {\n          it.remove();\n          postponedMisreplicatedBlocksCount.decrementAndGet();\n        }\n      }\n    } finally {\n      namesystem.writeUnlock();\n      long endPostponedMisReplicatedBlocksCount \u003d\n          getPostponedMisreplicatedBlocksCount();\n      LOG.info(\"Rescan of postponedMisreplicatedBlocks completed in \" +\n          (Time.monotonicNow() - startTimeRescanPostponedMisReplicatedBlocks) +\n          \" msecs. \" + endPostponedMisReplicatedBlocksCount +\n          \" blocks are left. \" + (startPostponedMisReplicatedBlocksCount -\n          endPostponedMisReplicatedBlocksCount) + \" blocks are removed.\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "de480d6c8945bd8b5b00e8657b7a72ce8dd9b6b5": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8623. Refactor NameNode handling of invalid, corrupt, and under-recovery blocks. Contributed by Zhe Zhang.\n",
      "commitDate": "26/06/15 10:49 AM",
      "commitName": "de480d6c8945bd8b5b00e8657b7a72ce8dd9b6b5",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "24/06/15 2:42 PM",
      "commitNameOld": "afe9ea3c12e1f5a71922400eadb642960bc87ca1",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 1.84,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,70 +1,70 @@\n   void rescanPostponedMisreplicatedBlocks() {\n     if (getPostponedMisreplicatedBlocksCount() \u003d\u003d 0) {\n       return;\n     }\n     long startTimeRescanPostponedMisReplicatedBlocks \u003d Time.monotonicNow();\n     long startPostponedMisReplicatedBlocksCount \u003d\n         getPostponedMisreplicatedBlocksCount();\n     namesystem.writeLock();\n     try {\n       // blocksPerRescan is the configured number of blocks per rescan.\n       // Randomly select blocksPerRescan consecutive blocks from the HashSet\n       // when the number of blocks remaining is larger than blocksPerRescan.\n       // The reason we don\u0027t always pick the first blocksPerRescan blocks is to\n       // handle the case if for some reason some datanodes remain in\n       // content stale state for a long time and only impact the first\n       // blocksPerRescan blocks.\n       int i \u003d 0;\n       long startIndex \u003d 0;\n       long blocksPerRescan \u003d\n           datanodeManager.getBlocksPerPostponedMisreplicatedBlocksRescan();\n       long base \u003d getPostponedMisreplicatedBlocksCount() - blocksPerRescan;\n       if (base \u003e 0) {\n         startIndex \u003d ThreadLocalRandom.current().nextLong() % (base+1);\n         if (startIndex \u003c 0) {\n           startIndex +\u003d (base+1);\n         }\n       }\n       Iterator\u003cBlock\u003e it \u003d postponedMisreplicatedBlocks.iterator();\n       for (int tmp \u003d 0; tmp \u003c startIndex; tmp++) {\n         it.next();\n       }\n \n       for (;it.hasNext(); i++) {\n         Block b \u003d it.next();\n         if (i \u003e\u003d blocksPerRescan) {\n           break;\n         }\n \n-        BlockInfo bi \u003d blocksMap.getStoredBlock(b);\n+        BlockInfo bi \u003d getStoredBlock(b);\n         if (bi \u003d\u003d null) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"BLOCK* rescanPostponedMisreplicatedBlocks: \" +\n                 \"Postponed mis-replicated block \" + b + \" no longer found \" +\n                 \"in block map.\");\n           }\n           it.remove();\n           postponedMisreplicatedBlocksCount.decrementAndGet();\n           continue;\n         }\n         MisReplicationResult res \u003d processMisReplicatedBlock(bi);\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"BLOCK* rescanPostponedMisreplicatedBlocks: \" +\n               \"Re-scanned block \" + b + \", result is \" + res);\n         }\n         if (res !\u003d MisReplicationResult.POSTPONE) {\n           it.remove();\n           postponedMisreplicatedBlocksCount.decrementAndGet();\n         }\n       }\n     } finally {\n       namesystem.writeUnlock();\n       long endPostponedMisReplicatedBlocksCount \u003d\n           getPostponedMisreplicatedBlocksCount();\n       LOG.info(\"Rescan of postponedMisreplicatedBlocks completed in \" +\n           (Time.monotonicNow() - startTimeRescanPostponedMisReplicatedBlocks) +\n           \" msecs. \" + endPostponedMisReplicatedBlocksCount +\n           \" blocks are left. \" + (startPostponedMisReplicatedBlocksCount -\n           endPostponedMisReplicatedBlocksCount) + \" blocks are removed.\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void rescanPostponedMisreplicatedBlocks() {\n    if (getPostponedMisreplicatedBlocksCount() \u003d\u003d 0) {\n      return;\n    }\n    long startTimeRescanPostponedMisReplicatedBlocks \u003d Time.monotonicNow();\n    long startPostponedMisReplicatedBlocksCount \u003d\n        getPostponedMisreplicatedBlocksCount();\n    namesystem.writeLock();\n    try {\n      // blocksPerRescan is the configured number of blocks per rescan.\n      // Randomly select blocksPerRescan consecutive blocks from the HashSet\n      // when the number of blocks remaining is larger than blocksPerRescan.\n      // The reason we don\u0027t always pick the first blocksPerRescan blocks is to\n      // handle the case if for some reason some datanodes remain in\n      // content stale state for a long time and only impact the first\n      // blocksPerRescan blocks.\n      int i \u003d 0;\n      long startIndex \u003d 0;\n      long blocksPerRescan \u003d\n          datanodeManager.getBlocksPerPostponedMisreplicatedBlocksRescan();\n      long base \u003d getPostponedMisreplicatedBlocksCount() - blocksPerRescan;\n      if (base \u003e 0) {\n        startIndex \u003d ThreadLocalRandom.current().nextLong() % (base+1);\n        if (startIndex \u003c 0) {\n          startIndex +\u003d (base+1);\n        }\n      }\n      Iterator\u003cBlock\u003e it \u003d postponedMisreplicatedBlocks.iterator();\n      for (int tmp \u003d 0; tmp \u003c startIndex; tmp++) {\n        it.next();\n      }\n\n      for (;it.hasNext(); i++) {\n        Block b \u003d it.next();\n        if (i \u003e\u003d blocksPerRescan) {\n          break;\n        }\n\n        BlockInfo bi \u003d getStoredBlock(b);\n        if (bi \u003d\u003d null) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"BLOCK* rescanPostponedMisreplicatedBlocks: \" +\n                \"Postponed mis-replicated block \" + b + \" no longer found \" +\n                \"in block map.\");\n          }\n          it.remove();\n          postponedMisreplicatedBlocksCount.decrementAndGet();\n          continue;\n        }\n        MisReplicationResult res \u003d processMisReplicatedBlock(bi);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"BLOCK* rescanPostponedMisreplicatedBlocks: \" +\n              \"Re-scanned block \" + b + \", result is \" + res);\n        }\n        if (res !\u003d MisReplicationResult.POSTPONE) {\n          it.remove();\n          postponedMisreplicatedBlocksCount.decrementAndGet();\n        }\n      }\n    } finally {\n      namesystem.writeUnlock();\n      long endPostponedMisReplicatedBlocksCount \u003d\n          getPostponedMisreplicatedBlocksCount();\n      LOG.info(\"Rescan of postponedMisreplicatedBlocks completed in \" +\n          (Time.monotonicNow() - startTimeRescanPostponedMisReplicatedBlocks) +\n          \" msecs. \" + endPostponedMisReplicatedBlocksCount +\n          \" blocks are left. \" + (startPostponedMisReplicatedBlocksCount -\n          endPostponedMisReplicatedBlocksCount) + \" blocks are removed.\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "4928f5473394981829e5ffd4b16ea0801baf5c45": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8482. Rename BlockInfoContiguous to BlockInfo. Contributed by Zhe Zhang.\n",
      "commitDate": "27/05/15 3:42 PM",
      "commitName": "4928f5473394981829e5ffd4b16ea0801baf5c45",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "19/05/15 11:05 AM",
      "commitNameOld": "8860e352c394372e4eb3ebdf82ea899567f34e4e",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 8.19,
      "commitsBetweenForRepo": 52,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,70 +1,70 @@\n   void rescanPostponedMisreplicatedBlocks() {\n     if (getPostponedMisreplicatedBlocksCount() \u003d\u003d 0) {\n       return;\n     }\n     long startTimeRescanPostponedMisReplicatedBlocks \u003d Time.monotonicNow();\n     long startPostponedMisReplicatedBlocksCount \u003d\n         getPostponedMisreplicatedBlocksCount();\n     namesystem.writeLock();\n     try {\n       // blocksPerRescan is the configured number of blocks per rescan.\n       // Randomly select blocksPerRescan consecutive blocks from the HashSet\n       // when the number of blocks remaining is larger than blocksPerRescan.\n       // The reason we don\u0027t always pick the first blocksPerRescan blocks is to\n       // handle the case if for some reason some datanodes remain in\n       // content stale state for a long time and only impact the first\n       // blocksPerRescan blocks.\n       int i \u003d 0;\n       long startIndex \u003d 0;\n       long blocksPerRescan \u003d\n           datanodeManager.getBlocksPerPostponedMisreplicatedBlocksRescan();\n       long base \u003d getPostponedMisreplicatedBlocksCount() - blocksPerRescan;\n       if (base \u003e 0) {\n         startIndex \u003d ThreadLocalRandom.current().nextLong() % (base+1);\n         if (startIndex \u003c 0) {\n           startIndex +\u003d (base+1);\n         }\n       }\n       Iterator\u003cBlock\u003e it \u003d postponedMisreplicatedBlocks.iterator();\n       for (int tmp \u003d 0; tmp \u003c startIndex; tmp++) {\n         it.next();\n       }\n \n       for (;it.hasNext(); i++) {\n         Block b \u003d it.next();\n         if (i \u003e\u003d blocksPerRescan) {\n           break;\n         }\n \n-        BlockInfoContiguous bi \u003d blocksMap.getStoredBlock(b);\n+        BlockInfo bi \u003d blocksMap.getStoredBlock(b);\n         if (bi \u003d\u003d null) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"BLOCK* rescanPostponedMisreplicatedBlocks: \" +\n                 \"Postponed mis-replicated block \" + b + \" no longer found \" +\n                 \"in block map.\");\n           }\n           it.remove();\n           postponedMisreplicatedBlocksCount.decrementAndGet();\n           continue;\n         }\n         MisReplicationResult res \u003d processMisReplicatedBlock(bi);\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"BLOCK* rescanPostponedMisreplicatedBlocks: \" +\n               \"Re-scanned block \" + b + \", result is \" + res);\n         }\n         if (res !\u003d MisReplicationResult.POSTPONE) {\n           it.remove();\n           postponedMisreplicatedBlocksCount.decrementAndGet();\n         }\n       }\n     } finally {\n       namesystem.writeUnlock();\n       long endPostponedMisReplicatedBlocksCount \u003d\n           getPostponedMisreplicatedBlocksCount();\n       LOG.info(\"Rescan of postponedMisreplicatedBlocks completed in \" +\n           (Time.monotonicNow() - startTimeRescanPostponedMisReplicatedBlocks) +\n           \" msecs. \" + endPostponedMisReplicatedBlocksCount +\n           \" blocks are left. \" + (startPostponedMisReplicatedBlocksCount -\n           endPostponedMisReplicatedBlocksCount) + \" blocks are removed.\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void rescanPostponedMisreplicatedBlocks() {\n    if (getPostponedMisreplicatedBlocksCount() \u003d\u003d 0) {\n      return;\n    }\n    long startTimeRescanPostponedMisReplicatedBlocks \u003d Time.monotonicNow();\n    long startPostponedMisReplicatedBlocksCount \u003d\n        getPostponedMisreplicatedBlocksCount();\n    namesystem.writeLock();\n    try {\n      // blocksPerRescan is the configured number of blocks per rescan.\n      // Randomly select blocksPerRescan consecutive blocks from the HashSet\n      // when the number of blocks remaining is larger than blocksPerRescan.\n      // The reason we don\u0027t always pick the first blocksPerRescan blocks is to\n      // handle the case if for some reason some datanodes remain in\n      // content stale state for a long time and only impact the first\n      // blocksPerRescan blocks.\n      int i \u003d 0;\n      long startIndex \u003d 0;\n      long blocksPerRescan \u003d\n          datanodeManager.getBlocksPerPostponedMisreplicatedBlocksRescan();\n      long base \u003d getPostponedMisreplicatedBlocksCount() - blocksPerRescan;\n      if (base \u003e 0) {\n        startIndex \u003d ThreadLocalRandom.current().nextLong() % (base+1);\n        if (startIndex \u003c 0) {\n          startIndex +\u003d (base+1);\n        }\n      }\n      Iterator\u003cBlock\u003e it \u003d postponedMisreplicatedBlocks.iterator();\n      for (int tmp \u003d 0; tmp \u003c startIndex; tmp++) {\n        it.next();\n      }\n\n      for (;it.hasNext(); i++) {\n        Block b \u003d it.next();\n        if (i \u003e\u003d blocksPerRescan) {\n          break;\n        }\n\n        BlockInfo bi \u003d blocksMap.getStoredBlock(b);\n        if (bi \u003d\u003d null) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"BLOCK* rescanPostponedMisreplicatedBlocks: \" +\n                \"Postponed mis-replicated block \" + b + \" no longer found \" +\n                \"in block map.\");\n          }\n          it.remove();\n          postponedMisreplicatedBlocksCount.decrementAndGet();\n          continue;\n        }\n        MisReplicationResult res \u003d processMisReplicatedBlock(bi);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"BLOCK* rescanPostponedMisreplicatedBlocks: \" +\n              \"Re-scanned block \" + b + \", result is \" + res);\n        }\n        if (res !\u003d MisReplicationResult.POSTPONE) {\n          it.remove();\n          postponedMisreplicatedBlocksCount.decrementAndGet();\n        }\n      }\n    } finally {\n      namesystem.writeUnlock();\n      long endPostponedMisReplicatedBlocksCount \u003d\n          getPostponedMisreplicatedBlocksCount();\n      LOG.info(\"Rescan of postponedMisreplicatedBlocks completed in \" +\n          (Time.monotonicNow() - startTimeRescanPostponedMisReplicatedBlocks) +\n          \" msecs. \" + endPostponedMisReplicatedBlocksCount +\n          \" blocks are left. \" + (startPostponedMisReplicatedBlocksCount -\n          endPostponedMisReplicatedBlocksCount) + \" blocks are removed.\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "ba9371492036983a9899398907ab41fe548f29b3": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7716. Erasure Coding: extend BlockInfo to handle EC info. Contributed by Jing Zhao.\n",
      "commitDate": "26/05/15 11:07 AM",
      "commitName": "ba9371492036983a9899398907ab41fe548f29b3",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "26/05/15 11:03 AM",
      "commitNameOld": "0c1da5a0300f015a7e39f2b40a73fb06c65a78c8",
      "commitAuthorOld": "Zhe Zhang",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,70 +1,70 @@\n   void rescanPostponedMisreplicatedBlocks() {\n     if (getPostponedMisreplicatedBlocksCount() \u003d\u003d 0) {\n       return;\n     }\n     long startTimeRescanPostponedMisReplicatedBlocks \u003d Time.monotonicNow();\n     long startPostponedMisReplicatedBlocksCount \u003d\n         getPostponedMisreplicatedBlocksCount();\n     namesystem.writeLock();\n     try {\n       // blocksPerRescan is the configured number of blocks per rescan.\n       // Randomly select blocksPerRescan consecutive blocks from the HashSet\n       // when the number of blocks remaining is larger than blocksPerRescan.\n       // The reason we don\u0027t always pick the first blocksPerRescan blocks is to\n       // handle the case if for some reason some datanodes remain in\n       // content stale state for a long time and only impact the first\n       // blocksPerRescan blocks.\n       int i \u003d 0;\n       long startIndex \u003d 0;\n       long blocksPerRescan \u003d\n           datanodeManager.getBlocksPerPostponedMisreplicatedBlocksRescan();\n       long base \u003d getPostponedMisreplicatedBlocksCount() - blocksPerRescan;\n       if (base \u003e 0) {\n         startIndex \u003d ThreadLocalRandom.current().nextLong() % (base+1);\n         if (startIndex \u003c 0) {\n           startIndex +\u003d (base+1);\n         }\n       }\n       Iterator\u003cBlock\u003e it \u003d postponedMisreplicatedBlocks.iterator();\n       for (int tmp \u003d 0; tmp \u003c startIndex; tmp++) {\n         it.next();\n       }\n \n       for (;it.hasNext(); i++) {\n         Block b \u003d it.next();\n         if (i \u003e\u003d blocksPerRescan) {\n           break;\n         }\n \n-        BlockInfoContiguous bi \u003d getStoredBlock(b);\n+        BlockInfo bi \u003d getStoredBlock(b);\n         if (bi \u003d\u003d null) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"BLOCK* rescanPostponedMisreplicatedBlocks: \" +\n                 \"Postponed mis-replicated block \" + b + \" no longer found \" +\n                 \"in block map.\");\n           }\n           it.remove();\n           postponedMisreplicatedBlocksCount.decrementAndGet();\n           continue;\n         }\n         MisReplicationResult res \u003d processMisReplicatedBlock(bi);\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"BLOCK* rescanPostponedMisreplicatedBlocks: \" +\n               \"Re-scanned block \" + b + \", result is \" + res);\n         }\n         if (res !\u003d MisReplicationResult.POSTPONE) {\n           it.remove();\n           postponedMisreplicatedBlocksCount.decrementAndGet();\n         }\n       }\n     } finally {\n       namesystem.writeUnlock();\n       long endPostponedMisReplicatedBlocksCount \u003d\n           getPostponedMisreplicatedBlocksCount();\n       LOG.info(\"Rescan of postponedMisreplicatedBlocks completed in \" +\n           (Time.monotonicNow() - startTimeRescanPostponedMisReplicatedBlocks) +\n           \" msecs. \" + endPostponedMisReplicatedBlocksCount +\n           \" blocks are left. \" + (startPostponedMisReplicatedBlocksCount -\n           endPostponedMisReplicatedBlocksCount) + \" blocks are removed.\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void rescanPostponedMisreplicatedBlocks() {\n    if (getPostponedMisreplicatedBlocksCount() \u003d\u003d 0) {\n      return;\n    }\n    long startTimeRescanPostponedMisReplicatedBlocks \u003d Time.monotonicNow();\n    long startPostponedMisReplicatedBlocksCount \u003d\n        getPostponedMisreplicatedBlocksCount();\n    namesystem.writeLock();\n    try {\n      // blocksPerRescan is the configured number of blocks per rescan.\n      // Randomly select blocksPerRescan consecutive blocks from the HashSet\n      // when the number of blocks remaining is larger than blocksPerRescan.\n      // The reason we don\u0027t always pick the first blocksPerRescan blocks is to\n      // handle the case if for some reason some datanodes remain in\n      // content stale state for a long time and only impact the first\n      // blocksPerRescan blocks.\n      int i \u003d 0;\n      long startIndex \u003d 0;\n      long blocksPerRescan \u003d\n          datanodeManager.getBlocksPerPostponedMisreplicatedBlocksRescan();\n      long base \u003d getPostponedMisreplicatedBlocksCount() - blocksPerRescan;\n      if (base \u003e 0) {\n        startIndex \u003d ThreadLocalRandom.current().nextLong() % (base+1);\n        if (startIndex \u003c 0) {\n          startIndex +\u003d (base+1);\n        }\n      }\n      Iterator\u003cBlock\u003e it \u003d postponedMisreplicatedBlocks.iterator();\n      for (int tmp \u003d 0; tmp \u003c startIndex; tmp++) {\n        it.next();\n      }\n\n      for (;it.hasNext(); i++) {\n        Block b \u003d it.next();\n        if (i \u003e\u003d blocksPerRescan) {\n          break;\n        }\n\n        BlockInfo bi \u003d getStoredBlock(b);\n        if (bi \u003d\u003d null) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"BLOCK* rescanPostponedMisreplicatedBlocks: \" +\n                \"Postponed mis-replicated block \" + b + \" no longer found \" +\n                \"in block map.\");\n          }\n          it.remove();\n          postponedMisreplicatedBlocksCount.decrementAndGet();\n          continue;\n        }\n        MisReplicationResult res \u003d processMisReplicatedBlock(bi);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"BLOCK* rescanPostponedMisreplicatedBlocks: \" +\n              \"Re-scanned block \" + b + \", result is \" + res);\n        }\n        if (res !\u003d MisReplicationResult.POSTPONE) {\n          it.remove();\n          postponedMisreplicatedBlocksCount.decrementAndGet();\n        }\n      }\n    } finally {\n      namesystem.writeUnlock();\n      long endPostponedMisReplicatedBlocksCount \u003d\n          getPostponedMisreplicatedBlocksCount();\n      LOG.info(\"Rescan of postponedMisreplicatedBlocks completed in \" +\n          (Time.monotonicNow() - startTimeRescanPostponedMisReplicatedBlocks) +\n          \" msecs. \" + endPostponedMisReplicatedBlocksCount +\n          \" blocks are left. \" + (startPostponedMisReplicatedBlocksCount -\n          endPostponedMisReplicatedBlocksCount) + \" blocks are removed.\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "0c1da5a0300f015a7e39f2b40a73fb06c65a78c8": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7652. Process block reports for erasure coded blocks. Contributed by Zhe Zhang\n",
      "commitDate": "26/05/15 11:03 AM",
      "commitName": "0c1da5a0300f015a7e39f2b40a73fb06c65a78c8",
      "commitAuthor": "Zhe Zhang",
      "commitDateOld": "19/05/15 11:05 AM",
      "commitNameOld": "8860e352c394372e4eb3ebdf82ea899567f34e4e",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 7.0,
      "commitsBetweenForRepo": 43,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,70 +1,70 @@\n   void rescanPostponedMisreplicatedBlocks() {\n     if (getPostponedMisreplicatedBlocksCount() \u003d\u003d 0) {\n       return;\n     }\n     long startTimeRescanPostponedMisReplicatedBlocks \u003d Time.monotonicNow();\n     long startPostponedMisReplicatedBlocksCount \u003d\n         getPostponedMisreplicatedBlocksCount();\n     namesystem.writeLock();\n     try {\n       // blocksPerRescan is the configured number of blocks per rescan.\n       // Randomly select blocksPerRescan consecutive blocks from the HashSet\n       // when the number of blocks remaining is larger than blocksPerRescan.\n       // The reason we don\u0027t always pick the first blocksPerRescan blocks is to\n       // handle the case if for some reason some datanodes remain in\n       // content stale state for a long time and only impact the first\n       // blocksPerRescan blocks.\n       int i \u003d 0;\n       long startIndex \u003d 0;\n       long blocksPerRescan \u003d\n           datanodeManager.getBlocksPerPostponedMisreplicatedBlocksRescan();\n       long base \u003d getPostponedMisreplicatedBlocksCount() - blocksPerRescan;\n       if (base \u003e 0) {\n         startIndex \u003d ThreadLocalRandom.current().nextLong() % (base+1);\n         if (startIndex \u003c 0) {\n           startIndex +\u003d (base+1);\n         }\n       }\n       Iterator\u003cBlock\u003e it \u003d postponedMisreplicatedBlocks.iterator();\n       for (int tmp \u003d 0; tmp \u003c startIndex; tmp++) {\n         it.next();\n       }\n \n       for (;it.hasNext(); i++) {\n         Block b \u003d it.next();\n         if (i \u003e\u003d blocksPerRescan) {\n           break;\n         }\n \n-        BlockInfoContiguous bi \u003d blocksMap.getStoredBlock(b);\n+        BlockInfoContiguous bi \u003d getStoredBlock(b);\n         if (bi \u003d\u003d null) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"BLOCK* rescanPostponedMisreplicatedBlocks: \" +\n                 \"Postponed mis-replicated block \" + b + \" no longer found \" +\n                 \"in block map.\");\n           }\n           it.remove();\n           postponedMisreplicatedBlocksCount.decrementAndGet();\n           continue;\n         }\n         MisReplicationResult res \u003d processMisReplicatedBlock(bi);\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"BLOCK* rescanPostponedMisreplicatedBlocks: \" +\n               \"Re-scanned block \" + b + \", result is \" + res);\n         }\n         if (res !\u003d MisReplicationResult.POSTPONE) {\n           it.remove();\n           postponedMisreplicatedBlocksCount.decrementAndGet();\n         }\n       }\n     } finally {\n       namesystem.writeUnlock();\n       long endPostponedMisReplicatedBlocksCount \u003d\n           getPostponedMisreplicatedBlocksCount();\n       LOG.info(\"Rescan of postponedMisreplicatedBlocks completed in \" +\n           (Time.monotonicNow() - startTimeRescanPostponedMisReplicatedBlocks) +\n           \" msecs. \" + endPostponedMisReplicatedBlocksCount +\n           \" blocks are left. \" + (startPostponedMisReplicatedBlocksCount -\n           endPostponedMisReplicatedBlocksCount) + \" blocks are removed.\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void rescanPostponedMisreplicatedBlocks() {\n    if (getPostponedMisreplicatedBlocksCount() \u003d\u003d 0) {\n      return;\n    }\n    long startTimeRescanPostponedMisReplicatedBlocks \u003d Time.monotonicNow();\n    long startPostponedMisReplicatedBlocksCount \u003d\n        getPostponedMisreplicatedBlocksCount();\n    namesystem.writeLock();\n    try {\n      // blocksPerRescan is the configured number of blocks per rescan.\n      // Randomly select blocksPerRescan consecutive blocks from the HashSet\n      // when the number of blocks remaining is larger than blocksPerRescan.\n      // The reason we don\u0027t always pick the first blocksPerRescan blocks is to\n      // handle the case if for some reason some datanodes remain in\n      // content stale state for a long time and only impact the first\n      // blocksPerRescan blocks.\n      int i \u003d 0;\n      long startIndex \u003d 0;\n      long blocksPerRescan \u003d\n          datanodeManager.getBlocksPerPostponedMisreplicatedBlocksRescan();\n      long base \u003d getPostponedMisreplicatedBlocksCount() - blocksPerRescan;\n      if (base \u003e 0) {\n        startIndex \u003d ThreadLocalRandom.current().nextLong() % (base+1);\n        if (startIndex \u003c 0) {\n          startIndex +\u003d (base+1);\n        }\n      }\n      Iterator\u003cBlock\u003e it \u003d postponedMisreplicatedBlocks.iterator();\n      for (int tmp \u003d 0; tmp \u003c startIndex; tmp++) {\n        it.next();\n      }\n\n      for (;it.hasNext(); i++) {\n        Block b \u003d it.next();\n        if (i \u003e\u003d blocksPerRescan) {\n          break;\n        }\n\n        BlockInfoContiguous bi \u003d getStoredBlock(b);\n        if (bi \u003d\u003d null) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"BLOCK* rescanPostponedMisreplicatedBlocks: \" +\n                \"Postponed mis-replicated block \" + b + \" no longer found \" +\n                \"in block map.\");\n          }\n          it.remove();\n          postponedMisreplicatedBlocksCount.decrementAndGet();\n          continue;\n        }\n        MisReplicationResult res \u003d processMisReplicatedBlock(bi);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"BLOCK* rescanPostponedMisreplicatedBlocks: \" +\n              \"Re-scanned block \" + b + \", result is \" + res);\n        }\n        if (res !\u003d MisReplicationResult.POSTPONE) {\n          it.remove();\n          postponedMisreplicatedBlocksCount.decrementAndGet();\n        }\n      }\n    } finally {\n      namesystem.writeUnlock();\n      long endPostponedMisReplicatedBlocksCount \u003d\n          getPostponedMisreplicatedBlocksCount();\n      LOG.info(\"Rescan of postponedMisreplicatedBlocks completed in \" +\n          (Time.monotonicNow() - startTimeRescanPostponedMisReplicatedBlocks) +\n          \" msecs. \" + endPostponedMisReplicatedBlocksCount +\n          \" blocks are left. \" + (startPostponedMisReplicatedBlocksCount -\n          endPostponedMisReplicatedBlocksCount) + \" blocks are removed.\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "470c87dbc6c24dd3b370f1ad9e7ab1f6dabd2080": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11970. Replace uses of ThreadLocal\u003cRandom\u003e with JDK7 ThreadLocalRandom (Sean Busbey via Colin P. McCabe)\n",
      "commitDate": "19/05/15 10:50 AM",
      "commitName": "470c87dbc6c24dd3b370f1ad9e7ab1f6dabd2080",
      "commitAuthor": "Colin Patrick Mccabe",
      "commitDateOld": "13/05/15 2:29 PM",
      "commitNameOld": "281d47a96937bc329b1b4051ffcb8f5fcac98354",
      "commitAuthorOld": "Colin Patrick Mccabe",
      "daysBetweenCommits": 5.85,
      "commitsBetweenForRepo": 47,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,70 +1,70 @@\n   void rescanPostponedMisreplicatedBlocks() {\n     if (getPostponedMisreplicatedBlocksCount() \u003d\u003d 0) {\n       return;\n     }\n     long startTimeRescanPostponedMisReplicatedBlocks \u003d Time.monotonicNow();\n     long startPostponedMisReplicatedBlocksCount \u003d\n         getPostponedMisreplicatedBlocksCount();\n     namesystem.writeLock();\n     try {\n       // blocksPerRescan is the configured number of blocks per rescan.\n       // Randomly select blocksPerRescan consecutive blocks from the HashSet\n       // when the number of blocks remaining is larger than blocksPerRescan.\n       // The reason we don\u0027t always pick the first blocksPerRescan blocks is to\n       // handle the case if for some reason some datanodes remain in\n       // content stale state for a long time and only impact the first\n       // blocksPerRescan blocks.\n       int i \u003d 0;\n       long startIndex \u003d 0;\n       long blocksPerRescan \u003d\n           datanodeManager.getBlocksPerPostponedMisreplicatedBlocksRescan();\n       long base \u003d getPostponedMisreplicatedBlocksCount() - blocksPerRescan;\n       if (base \u003e 0) {\n-        startIndex \u003d DFSUtil.getRandom().nextLong() % (base+1);\n+        startIndex \u003d ThreadLocalRandom.current().nextLong() % (base+1);\n         if (startIndex \u003c 0) {\n           startIndex +\u003d (base+1);\n         }\n       }\n       Iterator\u003cBlock\u003e it \u003d postponedMisreplicatedBlocks.iterator();\n       for (int tmp \u003d 0; tmp \u003c startIndex; tmp++) {\n         it.next();\n       }\n \n       for (;it.hasNext(); i++) {\n         Block b \u003d it.next();\n         if (i \u003e\u003d blocksPerRescan) {\n           break;\n         }\n \n         BlockInfoContiguous bi \u003d blocksMap.getStoredBlock(b);\n         if (bi \u003d\u003d null) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"BLOCK* rescanPostponedMisreplicatedBlocks: \" +\n                 \"Postponed mis-replicated block \" + b + \" no longer found \" +\n                 \"in block map.\");\n           }\n           it.remove();\n           postponedMisreplicatedBlocksCount.decrementAndGet();\n           continue;\n         }\n         MisReplicationResult res \u003d processMisReplicatedBlock(bi);\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"BLOCK* rescanPostponedMisreplicatedBlocks: \" +\n               \"Re-scanned block \" + b + \", result is \" + res);\n         }\n         if (res !\u003d MisReplicationResult.POSTPONE) {\n           it.remove();\n           postponedMisreplicatedBlocksCount.decrementAndGet();\n         }\n       }\n     } finally {\n       namesystem.writeUnlock();\n       long endPostponedMisReplicatedBlocksCount \u003d\n           getPostponedMisreplicatedBlocksCount();\n       LOG.info(\"Rescan of postponedMisreplicatedBlocks completed in \" +\n           (Time.monotonicNow() - startTimeRescanPostponedMisReplicatedBlocks) +\n           \" msecs. \" + endPostponedMisReplicatedBlocksCount +\n           \" blocks are left. \" + (startPostponedMisReplicatedBlocksCount -\n           endPostponedMisReplicatedBlocksCount) + \" blocks are removed.\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void rescanPostponedMisreplicatedBlocks() {\n    if (getPostponedMisreplicatedBlocksCount() \u003d\u003d 0) {\n      return;\n    }\n    long startTimeRescanPostponedMisReplicatedBlocks \u003d Time.monotonicNow();\n    long startPostponedMisReplicatedBlocksCount \u003d\n        getPostponedMisreplicatedBlocksCount();\n    namesystem.writeLock();\n    try {\n      // blocksPerRescan is the configured number of blocks per rescan.\n      // Randomly select blocksPerRescan consecutive blocks from the HashSet\n      // when the number of blocks remaining is larger than blocksPerRescan.\n      // The reason we don\u0027t always pick the first blocksPerRescan blocks is to\n      // handle the case if for some reason some datanodes remain in\n      // content stale state for a long time and only impact the first\n      // blocksPerRescan blocks.\n      int i \u003d 0;\n      long startIndex \u003d 0;\n      long blocksPerRescan \u003d\n          datanodeManager.getBlocksPerPostponedMisreplicatedBlocksRescan();\n      long base \u003d getPostponedMisreplicatedBlocksCount() - blocksPerRescan;\n      if (base \u003e 0) {\n        startIndex \u003d ThreadLocalRandom.current().nextLong() % (base+1);\n        if (startIndex \u003c 0) {\n          startIndex +\u003d (base+1);\n        }\n      }\n      Iterator\u003cBlock\u003e it \u003d postponedMisreplicatedBlocks.iterator();\n      for (int tmp \u003d 0; tmp \u003c startIndex; tmp++) {\n        it.next();\n      }\n\n      for (;it.hasNext(); i++) {\n        Block b \u003d it.next();\n        if (i \u003e\u003d blocksPerRescan) {\n          break;\n        }\n\n        BlockInfoContiguous bi \u003d blocksMap.getStoredBlock(b);\n        if (bi \u003d\u003d null) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"BLOCK* rescanPostponedMisreplicatedBlocks: \" +\n                \"Postponed mis-replicated block \" + b + \" no longer found \" +\n                \"in block map.\");\n          }\n          it.remove();\n          postponedMisreplicatedBlocksCount.decrementAndGet();\n          continue;\n        }\n        MisReplicationResult res \u003d processMisReplicatedBlock(bi);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"BLOCK* rescanPostponedMisreplicatedBlocks: \" +\n              \"Re-scanned block \" + b + \", result is \" + res);\n        }\n        if (res !\u003d MisReplicationResult.POSTPONE) {\n          it.remove();\n          postponedMisreplicatedBlocksCount.decrementAndGet();\n        }\n      }\n    } finally {\n      namesystem.writeUnlock();\n      long endPostponedMisReplicatedBlocksCount \u003d\n          getPostponedMisreplicatedBlocksCount();\n      LOG.info(\"Rescan of postponedMisreplicatedBlocks completed in \" +\n          (Time.monotonicNow() - startTimeRescanPostponedMisReplicatedBlocks) +\n          \" msecs. \" + endPostponedMisReplicatedBlocksCount +\n          \" blocks are left. \" + (startPostponedMisReplicatedBlocksCount -\n          endPostponedMisReplicatedBlocksCount) + \" blocks are removed.\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "75ead273bea8a7dad61c4f99c3a16cab2697c498": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6841. Use Time.monotonicNow() wherever applicable instead of Time.now(). Contributed by Vinayakumar B\n",
      "commitDate": "20/03/15 12:02 PM",
      "commitName": "75ead273bea8a7dad61c4f99c3a16cab2697c498",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "19/03/15 2:29 PM",
      "commitNameOld": "978ef11f26794c22c7289582653b32268478e23e",
      "commitAuthorOld": "yliu",
      "daysBetweenCommits": 0.9,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,70 +1,70 @@\n   void rescanPostponedMisreplicatedBlocks() {\n     if (getPostponedMisreplicatedBlocksCount() \u003d\u003d 0) {\n       return;\n     }\n-    long startTimeRescanPostponedMisReplicatedBlocks \u003d Time.now();\n+    long startTimeRescanPostponedMisReplicatedBlocks \u003d Time.monotonicNow();\n     long startPostponedMisReplicatedBlocksCount \u003d\n         getPostponedMisreplicatedBlocksCount();\n     namesystem.writeLock();\n     try {\n       // blocksPerRescan is the configured number of blocks per rescan.\n       // Randomly select blocksPerRescan consecutive blocks from the HashSet\n       // when the number of blocks remaining is larger than blocksPerRescan.\n       // The reason we don\u0027t always pick the first blocksPerRescan blocks is to\n       // handle the case if for some reason some datanodes remain in\n       // content stale state for a long time and only impact the first\n       // blocksPerRescan blocks.\n       int i \u003d 0;\n       long startIndex \u003d 0;\n       long blocksPerRescan \u003d\n           datanodeManager.getBlocksPerPostponedMisreplicatedBlocksRescan();\n       long base \u003d getPostponedMisreplicatedBlocksCount() - blocksPerRescan;\n       if (base \u003e 0) {\n         startIndex \u003d DFSUtil.getRandom().nextLong() % (base+1);\n         if (startIndex \u003c 0) {\n           startIndex +\u003d (base+1);\n         }\n       }\n       Iterator\u003cBlock\u003e it \u003d postponedMisreplicatedBlocks.iterator();\n       for (int tmp \u003d 0; tmp \u003c startIndex; tmp++) {\n         it.next();\n       }\n \n       for (;it.hasNext(); i++) {\n         Block b \u003d it.next();\n         if (i \u003e\u003d blocksPerRescan) {\n           break;\n         }\n \n         BlockInfoContiguous bi \u003d blocksMap.getStoredBlock(b);\n         if (bi \u003d\u003d null) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"BLOCK* rescanPostponedMisreplicatedBlocks: \" +\n                 \"Postponed mis-replicated block \" + b + \" no longer found \" +\n                 \"in block map.\");\n           }\n           it.remove();\n           postponedMisreplicatedBlocksCount.decrementAndGet();\n           continue;\n         }\n         MisReplicationResult res \u003d processMisReplicatedBlock(bi);\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"BLOCK* rescanPostponedMisreplicatedBlocks: \" +\n               \"Re-scanned block \" + b + \", result is \" + res);\n         }\n         if (res !\u003d MisReplicationResult.POSTPONE) {\n           it.remove();\n           postponedMisreplicatedBlocksCount.decrementAndGet();\n         }\n       }\n     } finally {\n       namesystem.writeUnlock();\n       long endPostponedMisReplicatedBlocksCount \u003d\n           getPostponedMisreplicatedBlocksCount();\n       LOG.info(\"Rescan of postponedMisreplicatedBlocks completed in \" +\n-          (Time.now() - startTimeRescanPostponedMisReplicatedBlocks) +\n+          (Time.monotonicNow() - startTimeRescanPostponedMisReplicatedBlocks) +\n           \" msecs. \" + endPostponedMisReplicatedBlocksCount +\n           \" blocks are left. \" + (startPostponedMisReplicatedBlocksCount -\n           endPostponedMisReplicatedBlocksCount) + \" blocks are removed.\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void rescanPostponedMisreplicatedBlocks() {\n    if (getPostponedMisreplicatedBlocksCount() \u003d\u003d 0) {\n      return;\n    }\n    long startTimeRescanPostponedMisReplicatedBlocks \u003d Time.monotonicNow();\n    long startPostponedMisReplicatedBlocksCount \u003d\n        getPostponedMisreplicatedBlocksCount();\n    namesystem.writeLock();\n    try {\n      // blocksPerRescan is the configured number of blocks per rescan.\n      // Randomly select blocksPerRescan consecutive blocks from the HashSet\n      // when the number of blocks remaining is larger than blocksPerRescan.\n      // The reason we don\u0027t always pick the first blocksPerRescan blocks is to\n      // handle the case if for some reason some datanodes remain in\n      // content stale state for a long time and only impact the first\n      // blocksPerRescan blocks.\n      int i \u003d 0;\n      long startIndex \u003d 0;\n      long blocksPerRescan \u003d\n          datanodeManager.getBlocksPerPostponedMisreplicatedBlocksRescan();\n      long base \u003d getPostponedMisreplicatedBlocksCount() - blocksPerRescan;\n      if (base \u003e 0) {\n        startIndex \u003d DFSUtil.getRandom().nextLong() % (base+1);\n        if (startIndex \u003c 0) {\n          startIndex +\u003d (base+1);\n        }\n      }\n      Iterator\u003cBlock\u003e it \u003d postponedMisreplicatedBlocks.iterator();\n      for (int tmp \u003d 0; tmp \u003c startIndex; tmp++) {\n        it.next();\n      }\n\n      for (;it.hasNext(); i++) {\n        Block b \u003d it.next();\n        if (i \u003e\u003d blocksPerRescan) {\n          break;\n        }\n\n        BlockInfoContiguous bi \u003d blocksMap.getStoredBlock(b);\n        if (bi \u003d\u003d null) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"BLOCK* rescanPostponedMisreplicatedBlocks: \" +\n                \"Postponed mis-replicated block \" + b + \" no longer found \" +\n                \"in block map.\");\n          }\n          it.remove();\n          postponedMisreplicatedBlocksCount.decrementAndGet();\n          continue;\n        }\n        MisReplicationResult res \u003d processMisReplicatedBlock(bi);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"BLOCK* rescanPostponedMisreplicatedBlocks: \" +\n              \"Re-scanned block \" + b + \", result is \" + res);\n        }\n        if (res !\u003d MisReplicationResult.POSTPONE) {\n          it.remove();\n          postponedMisreplicatedBlocksCount.decrementAndGet();\n        }\n      }\n    } finally {\n      namesystem.writeUnlock();\n      long endPostponedMisReplicatedBlocksCount \u003d\n          getPostponedMisreplicatedBlocksCount();\n      LOG.info(\"Rescan of postponedMisreplicatedBlocks completed in \" +\n          (Time.monotonicNow() - startTimeRescanPostponedMisReplicatedBlocks) +\n          \" msecs. \" + endPostponedMisReplicatedBlocksCount +\n          \" blocks are left. \" + (startPostponedMisReplicatedBlocksCount -\n          endPostponedMisReplicatedBlocksCount) + \" blocks are removed.\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "1382ae525c67bf95d8f3a436b547dbc72cfbb177": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7743. Code cleanup of BlockInfo and rename BlockInfo to BlockInfoContiguous. Contributed by Jing Zhao.\n",
      "commitDate": "08/02/15 11:51 AM",
      "commitName": "1382ae525c67bf95d8f3a436b547dbc72cfbb177",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "04/02/15 11:31 AM",
      "commitNameOld": "9175105eeaecf0a1d60b57989b73ce45cee4689b",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 4.01,
      "commitsBetweenForRepo": 50,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,70 +1,70 @@\n   void rescanPostponedMisreplicatedBlocks() {\n     if (getPostponedMisreplicatedBlocksCount() \u003d\u003d 0) {\n       return;\n     }\n     long startTimeRescanPostponedMisReplicatedBlocks \u003d Time.now();\n     long startPostponedMisReplicatedBlocksCount \u003d\n         getPostponedMisreplicatedBlocksCount();\n     namesystem.writeLock();\n     try {\n       // blocksPerRescan is the configured number of blocks per rescan.\n       // Randomly select blocksPerRescan consecutive blocks from the HashSet\n       // when the number of blocks remaining is larger than blocksPerRescan.\n       // The reason we don\u0027t always pick the first blocksPerRescan blocks is to\n       // handle the case if for some reason some datanodes remain in\n       // content stale state for a long time and only impact the first\n       // blocksPerRescan blocks.\n       int i \u003d 0;\n       long startIndex \u003d 0;\n       long blocksPerRescan \u003d\n           datanodeManager.getBlocksPerPostponedMisreplicatedBlocksRescan();\n       long base \u003d getPostponedMisreplicatedBlocksCount() - blocksPerRescan;\n       if (base \u003e 0) {\n         startIndex \u003d DFSUtil.getRandom().nextLong() % (base+1);\n         if (startIndex \u003c 0) {\n           startIndex +\u003d (base+1);\n         }\n       }\n       Iterator\u003cBlock\u003e it \u003d postponedMisreplicatedBlocks.iterator();\n       for (int tmp \u003d 0; tmp \u003c startIndex; tmp++) {\n         it.next();\n       }\n \n       for (;it.hasNext(); i++) {\n         Block b \u003d it.next();\n         if (i \u003e\u003d blocksPerRescan) {\n           break;\n         }\n \n-        BlockInfo bi \u003d blocksMap.getStoredBlock(b);\n+        BlockInfoContiguous bi \u003d blocksMap.getStoredBlock(b);\n         if (bi \u003d\u003d null) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"BLOCK* rescanPostponedMisreplicatedBlocks: \" +\n                 \"Postponed mis-replicated block \" + b + \" no longer found \" +\n                 \"in block map.\");\n           }\n           it.remove();\n           postponedMisreplicatedBlocksCount.decrementAndGet();\n           continue;\n         }\n         MisReplicationResult res \u003d processMisReplicatedBlock(bi);\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"BLOCK* rescanPostponedMisreplicatedBlocks: \" +\n               \"Re-scanned block \" + b + \", result is \" + res);\n         }\n         if (res !\u003d MisReplicationResult.POSTPONE) {\n           it.remove();\n           postponedMisreplicatedBlocksCount.decrementAndGet();\n         }\n       }\n     } finally {\n       namesystem.writeUnlock();\n       long endPostponedMisReplicatedBlocksCount \u003d\n           getPostponedMisreplicatedBlocksCount();\n       LOG.info(\"Rescan of postponedMisreplicatedBlocks completed in \" +\n           (Time.now() - startTimeRescanPostponedMisReplicatedBlocks) +\n           \" msecs. \" + endPostponedMisReplicatedBlocksCount +\n           \" blocks are left. \" + (startPostponedMisReplicatedBlocksCount -\n           endPostponedMisReplicatedBlocksCount) + \" blocks are removed.\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void rescanPostponedMisreplicatedBlocks() {\n    if (getPostponedMisreplicatedBlocksCount() \u003d\u003d 0) {\n      return;\n    }\n    long startTimeRescanPostponedMisReplicatedBlocks \u003d Time.now();\n    long startPostponedMisReplicatedBlocksCount \u003d\n        getPostponedMisreplicatedBlocksCount();\n    namesystem.writeLock();\n    try {\n      // blocksPerRescan is the configured number of blocks per rescan.\n      // Randomly select blocksPerRescan consecutive blocks from the HashSet\n      // when the number of blocks remaining is larger than blocksPerRescan.\n      // The reason we don\u0027t always pick the first blocksPerRescan blocks is to\n      // handle the case if for some reason some datanodes remain in\n      // content stale state for a long time and only impact the first\n      // blocksPerRescan blocks.\n      int i \u003d 0;\n      long startIndex \u003d 0;\n      long blocksPerRescan \u003d\n          datanodeManager.getBlocksPerPostponedMisreplicatedBlocksRescan();\n      long base \u003d getPostponedMisreplicatedBlocksCount() - blocksPerRescan;\n      if (base \u003e 0) {\n        startIndex \u003d DFSUtil.getRandom().nextLong() % (base+1);\n        if (startIndex \u003c 0) {\n          startIndex +\u003d (base+1);\n        }\n      }\n      Iterator\u003cBlock\u003e it \u003d postponedMisreplicatedBlocks.iterator();\n      for (int tmp \u003d 0; tmp \u003c startIndex; tmp++) {\n        it.next();\n      }\n\n      for (;it.hasNext(); i++) {\n        Block b \u003d it.next();\n        if (i \u003e\u003d blocksPerRescan) {\n          break;\n        }\n\n        BlockInfoContiguous bi \u003d blocksMap.getStoredBlock(b);\n        if (bi \u003d\u003d null) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"BLOCK* rescanPostponedMisreplicatedBlocks: \" +\n                \"Postponed mis-replicated block \" + b + \" no longer found \" +\n                \"in block map.\");\n          }\n          it.remove();\n          postponedMisreplicatedBlocksCount.decrementAndGet();\n          continue;\n        }\n        MisReplicationResult res \u003d processMisReplicatedBlock(bi);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"BLOCK* rescanPostponedMisreplicatedBlocks: \" +\n              \"Re-scanned block \" + b + \", result is \" + res);\n        }\n        if (res !\u003d MisReplicationResult.POSTPONE) {\n          it.remove();\n          postponedMisreplicatedBlocksCount.decrementAndGet();\n        }\n      }\n    } finally {\n      namesystem.writeUnlock();\n      long endPostponedMisReplicatedBlocksCount \u003d\n          getPostponedMisreplicatedBlocksCount();\n      LOG.info(\"Rescan of postponedMisreplicatedBlocks completed in \" +\n          (Time.now() - startTimeRescanPostponedMisReplicatedBlocks) +\n          \" msecs. \" + endPostponedMisReplicatedBlocksCount +\n          \" blocks are left. \" + (startPostponedMisReplicatedBlocksCount -\n          endPostponedMisReplicatedBlocksCount) + \" blocks are removed.\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "b7923a356e9f111619375b94d12749d634069347": {
      "type": "Ymultichange(Ymodifierchange,Ybodychange)",
      "commitMessage": "HDFS-6425. Large postponedMisreplicatedBlocks has impact on blockReport latency. Contributed by Ming Ma.\n",
      "commitDate": "16/12/14 8:30 AM",
      "commitName": "b7923a356e9f111619375b94d12749d634069347",
      "commitAuthor": "Kihwal Lee",
      "subchanges": [
        {
          "type": "Ymodifierchange",
          "commitMessage": "HDFS-6425. Large postponedMisreplicatedBlocks has impact on blockReport latency. Contributed by Ming Ma.\n",
          "commitDate": "16/12/14 8:30 AM",
          "commitName": "b7923a356e9f111619375b94d12749d634069347",
          "commitAuthor": "Kihwal Lee",
          "commitDateOld": "10/12/14 11:44 PM",
          "commitNameOld": "390642acf35f3d599271617d30ba26c2f6406fc1",
          "commitAuthorOld": "arp",
          "daysBetweenCommits": 5.37,
          "commitsBetweenForRepo": 33,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,27 +1,70 @@\n-  private void rescanPostponedMisreplicatedBlocks() {\n-    for (Iterator\u003cBlock\u003e it \u003d postponedMisreplicatedBlocks.iterator();\n-         it.hasNext();) {\n-      Block b \u003d it.next();\n-      \n-      BlockInfo bi \u003d blocksMap.getStoredBlock(b);\n-      if (bi \u003d\u003d null) {\n+  void rescanPostponedMisreplicatedBlocks() {\n+    if (getPostponedMisreplicatedBlocksCount() \u003d\u003d 0) {\n+      return;\n+    }\n+    long startTimeRescanPostponedMisReplicatedBlocks \u003d Time.now();\n+    long startPostponedMisReplicatedBlocksCount \u003d\n+        getPostponedMisreplicatedBlocksCount();\n+    namesystem.writeLock();\n+    try {\n+      // blocksPerRescan is the configured number of blocks per rescan.\n+      // Randomly select blocksPerRescan consecutive blocks from the HashSet\n+      // when the number of blocks remaining is larger than blocksPerRescan.\n+      // The reason we don\u0027t always pick the first blocksPerRescan blocks is to\n+      // handle the case if for some reason some datanodes remain in\n+      // content stale state for a long time and only impact the first\n+      // blocksPerRescan blocks.\n+      int i \u003d 0;\n+      long startIndex \u003d 0;\n+      long blocksPerRescan \u003d\n+          datanodeManager.getBlocksPerPostponedMisreplicatedBlocksRescan();\n+      long base \u003d getPostponedMisreplicatedBlocksCount() - blocksPerRescan;\n+      if (base \u003e 0) {\n+        startIndex \u003d DFSUtil.getRandom().nextLong() % (base+1);\n+        if (startIndex \u003c 0) {\n+          startIndex +\u003d (base+1);\n+        }\n+      }\n+      Iterator\u003cBlock\u003e it \u003d postponedMisreplicatedBlocks.iterator();\n+      for (int tmp \u003d 0; tmp \u003c startIndex; tmp++) {\n+        it.next();\n+      }\n+\n+      for (;it.hasNext(); i++) {\n+        Block b \u003d it.next();\n+        if (i \u003e\u003d blocksPerRescan) {\n+          break;\n+        }\n+\n+        BlockInfo bi \u003d blocksMap.getStoredBlock(b);\n+        if (bi \u003d\u003d null) {\n+          if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"BLOCK* rescanPostponedMisreplicatedBlocks: \" +\n+                \"Postponed mis-replicated block \" + b + \" no longer found \" +\n+                \"in block map.\");\n+          }\n+          it.remove();\n+          postponedMisreplicatedBlocksCount.decrementAndGet();\n+          continue;\n+        }\n+        MisReplicationResult res \u003d processMisReplicatedBlock(bi);\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"BLOCK* rescanPostponedMisreplicatedBlocks: \" +\n-              \"Postponed mis-replicated block \" + b + \" no longer found \" +\n-              \"in block map.\");\n+              \"Re-scanned block \" + b + \", result is \" + res);\n         }\n-        it.remove();\n-        postponedMisreplicatedBlocksCount.decrementAndGet();\n-        continue;\n+        if (res !\u003d MisReplicationResult.POSTPONE) {\n+          it.remove();\n+          postponedMisreplicatedBlocksCount.decrementAndGet();\n+        }\n       }\n-      MisReplicationResult res \u003d processMisReplicatedBlock(bi);\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"BLOCK* rescanPostponedMisreplicatedBlocks: \" +\n-            \"Re-scanned block \" + b + \", result is \" + res);\n-      }\n-      if (res !\u003d MisReplicationResult.POSTPONE) {\n-        it.remove();\n-        postponedMisreplicatedBlocksCount.decrementAndGet();\n-      }\n+    } finally {\n+      namesystem.writeUnlock();\n+      long endPostponedMisReplicatedBlocksCount \u003d\n+          getPostponedMisreplicatedBlocksCount();\n+      LOG.info(\"Rescan of postponedMisreplicatedBlocks completed in \" +\n+          (Time.now() - startTimeRescanPostponedMisReplicatedBlocks) +\n+          \" msecs. \" + endPostponedMisReplicatedBlocksCount +\n+          \" blocks are left. \" + (startPostponedMisReplicatedBlocksCount -\n+          endPostponedMisReplicatedBlocksCount) + \" blocks are removed.\");\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  void rescanPostponedMisreplicatedBlocks() {\n    if (getPostponedMisreplicatedBlocksCount() \u003d\u003d 0) {\n      return;\n    }\n    long startTimeRescanPostponedMisReplicatedBlocks \u003d Time.now();\n    long startPostponedMisReplicatedBlocksCount \u003d\n        getPostponedMisreplicatedBlocksCount();\n    namesystem.writeLock();\n    try {\n      // blocksPerRescan is the configured number of blocks per rescan.\n      // Randomly select blocksPerRescan consecutive blocks from the HashSet\n      // when the number of blocks remaining is larger than blocksPerRescan.\n      // The reason we don\u0027t always pick the first blocksPerRescan blocks is to\n      // handle the case if for some reason some datanodes remain in\n      // content stale state for a long time and only impact the first\n      // blocksPerRescan blocks.\n      int i \u003d 0;\n      long startIndex \u003d 0;\n      long blocksPerRescan \u003d\n          datanodeManager.getBlocksPerPostponedMisreplicatedBlocksRescan();\n      long base \u003d getPostponedMisreplicatedBlocksCount() - blocksPerRescan;\n      if (base \u003e 0) {\n        startIndex \u003d DFSUtil.getRandom().nextLong() % (base+1);\n        if (startIndex \u003c 0) {\n          startIndex +\u003d (base+1);\n        }\n      }\n      Iterator\u003cBlock\u003e it \u003d postponedMisreplicatedBlocks.iterator();\n      for (int tmp \u003d 0; tmp \u003c startIndex; tmp++) {\n        it.next();\n      }\n\n      for (;it.hasNext(); i++) {\n        Block b \u003d it.next();\n        if (i \u003e\u003d blocksPerRescan) {\n          break;\n        }\n\n        BlockInfo bi \u003d blocksMap.getStoredBlock(b);\n        if (bi \u003d\u003d null) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"BLOCK* rescanPostponedMisreplicatedBlocks: \" +\n                \"Postponed mis-replicated block \" + b + \" no longer found \" +\n                \"in block map.\");\n          }\n          it.remove();\n          postponedMisreplicatedBlocksCount.decrementAndGet();\n          continue;\n        }\n        MisReplicationResult res \u003d processMisReplicatedBlock(bi);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"BLOCK* rescanPostponedMisreplicatedBlocks: \" +\n              \"Re-scanned block \" + b + \", result is \" + res);\n        }\n        if (res !\u003d MisReplicationResult.POSTPONE) {\n          it.remove();\n          postponedMisreplicatedBlocksCount.decrementAndGet();\n        }\n      }\n    } finally {\n      namesystem.writeUnlock();\n      long endPostponedMisReplicatedBlocksCount \u003d\n          getPostponedMisreplicatedBlocksCount();\n      LOG.info(\"Rescan of postponedMisreplicatedBlocks completed in \" +\n          (Time.now() - startTimeRescanPostponedMisReplicatedBlocks) +\n          \" msecs. \" + endPostponedMisReplicatedBlocksCount +\n          \" blocks are left. \" + (startPostponedMisReplicatedBlocksCount -\n          endPostponedMisReplicatedBlocksCount) + \" blocks are removed.\");\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
          "extendedDetails": {
            "oldValue": "[private]",
            "newValue": "[]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-6425. Large postponedMisreplicatedBlocks has impact on blockReport latency. Contributed by Ming Ma.\n",
          "commitDate": "16/12/14 8:30 AM",
          "commitName": "b7923a356e9f111619375b94d12749d634069347",
          "commitAuthor": "Kihwal Lee",
          "commitDateOld": "10/12/14 11:44 PM",
          "commitNameOld": "390642acf35f3d599271617d30ba26c2f6406fc1",
          "commitAuthorOld": "arp",
          "daysBetweenCommits": 5.37,
          "commitsBetweenForRepo": 33,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,27 +1,70 @@\n-  private void rescanPostponedMisreplicatedBlocks() {\n-    for (Iterator\u003cBlock\u003e it \u003d postponedMisreplicatedBlocks.iterator();\n-         it.hasNext();) {\n-      Block b \u003d it.next();\n-      \n-      BlockInfo bi \u003d blocksMap.getStoredBlock(b);\n-      if (bi \u003d\u003d null) {\n+  void rescanPostponedMisreplicatedBlocks() {\n+    if (getPostponedMisreplicatedBlocksCount() \u003d\u003d 0) {\n+      return;\n+    }\n+    long startTimeRescanPostponedMisReplicatedBlocks \u003d Time.now();\n+    long startPostponedMisReplicatedBlocksCount \u003d\n+        getPostponedMisreplicatedBlocksCount();\n+    namesystem.writeLock();\n+    try {\n+      // blocksPerRescan is the configured number of blocks per rescan.\n+      // Randomly select blocksPerRescan consecutive blocks from the HashSet\n+      // when the number of blocks remaining is larger than blocksPerRescan.\n+      // The reason we don\u0027t always pick the first blocksPerRescan blocks is to\n+      // handle the case if for some reason some datanodes remain in\n+      // content stale state for a long time and only impact the first\n+      // blocksPerRescan blocks.\n+      int i \u003d 0;\n+      long startIndex \u003d 0;\n+      long blocksPerRescan \u003d\n+          datanodeManager.getBlocksPerPostponedMisreplicatedBlocksRescan();\n+      long base \u003d getPostponedMisreplicatedBlocksCount() - blocksPerRescan;\n+      if (base \u003e 0) {\n+        startIndex \u003d DFSUtil.getRandom().nextLong() % (base+1);\n+        if (startIndex \u003c 0) {\n+          startIndex +\u003d (base+1);\n+        }\n+      }\n+      Iterator\u003cBlock\u003e it \u003d postponedMisreplicatedBlocks.iterator();\n+      for (int tmp \u003d 0; tmp \u003c startIndex; tmp++) {\n+        it.next();\n+      }\n+\n+      for (;it.hasNext(); i++) {\n+        Block b \u003d it.next();\n+        if (i \u003e\u003d blocksPerRescan) {\n+          break;\n+        }\n+\n+        BlockInfo bi \u003d blocksMap.getStoredBlock(b);\n+        if (bi \u003d\u003d null) {\n+          if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"BLOCK* rescanPostponedMisreplicatedBlocks: \" +\n+                \"Postponed mis-replicated block \" + b + \" no longer found \" +\n+                \"in block map.\");\n+          }\n+          it.remove();\n+          postponedMisreplicatedBlocksCount.decrementAndGet();\n+          continue;\n+        }\n+        MisReplicationResult res \u003d processMisReplicatedBlock(bi);\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"BLOCK* rescanPostponedMisreplicatedBlocks: \" +\n-              \"Postponed mis-replicated block \" + b + \" no longer found \" +\n-              \"in block map.\");\n+              \"Re-scanned block \" + b + \", result is \" + res);\n         }\n-        it.remove();\n-        postponedMisreplicatedBlocksCount.decrementAndGet();\n-        continue;\n+        if (res !\u003d MisReplicationResult.POSTPONE) {\n+          it.remove();\n+          postponedMisreplicatedBlocksCount.decrementAndGet();\n+        }\n       }\n-      MisReplicationResult res \u003d processMisReplicatedBlock(bi);\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"BLOCK* rescanPostponedMisreplicatedBlocks: \" +\n-            \"Re-scanned block \" + b + \", result is \" + res);\n-      }\n-      if (res !\u003d MisReplicationResult.POSTPONE) {\n-        it.remove();\n-        postponedMisreplicatedBlocksCount.decrementAndGet();\n-      }\n+    } finally {\n+      namesystem.writeUnlock();\n+      long endPostponedMisReplicatedBlocksCount \u003d\n+          getPostponedMisreplicatedBlocksCount();\n+      LOG.info(\"Rescan of postponedMisreplicatedBlocks completed in \" +\n+          (Time.now() - startTimeRescanPostponedMisReplicatedBlocks) +\n+          \" msecs. \" + endPostponedMisReplicatedBlocksCount +\n+          \" blocks are left. \" + (startPostponedMisReplicatedBlocksCount -\n+          endPostponedMisReplicatedBlocksCount) + \" blocks are removed.\");\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  void rescanPostponedMisreplicatedBlocks() {\n    if (getPostponedMisreplicatedBlocksCount() \u003d\u003d 0) {\n      return;\n    }\n    long startTimeRescanPostponedMisReplicatedBlocks \u003d Time.now();\n    long startPostponedMisReplicatedBlocksCount \u003d\n        getPostponedMisreplicatedBlocksCount();\n    namesystem.writeLock();\n    try {\n      // blocksPerRescan is the configured number of blocks per rescan.\n      // Randomly select blocksPerRescan consecutive blocks from the HashSet\n      // when the number of blocks remaining is larger than blocksPerRescan.\n      // The reason we don\u0027t always pick the first blocksPerRescan blocks is to\n      // handle the case if for some reason some datanodes remain in\n      // content stale state for a long time and only impact the first\n      // blocksPerRescan blocks.\n      int i \u003d 0;\n      long startIndex \u003d 0;\n      long blocksPerRescan \u003d\n          datanodeManager.getBlocksPerPostponedMisreplicatedBlocksRescan();\n      long base \u003d getPostponedMisreplicatedBlocksCount() - blocksPerRescan;\n      if (base \u003e 0) {\n        startIndex \u003d DFSUtil.getRandom().nextLong() % (base+1);\n        if (startIndex \u003c 0) {\n          startIndex +\u003d (base+1);\n        }\n      }\n      Iterator\u003cBlock\u003e it \u003d postponedMisreplicatedBlocks.iterator();\n      for (int tmp \u003d 0; tmp \u003c startIndex; tmp++) {\n        it.next();\n      }\n\n      for (;it.hasNext(); i++) {\n        Block b \u003d it.next();\n        if (i \u003e\u003d blocksPerRescan) {\n          break;\n        }\n\n        BlockInfo bi \u003d blocksMap.getStoredBlock(b);\n        if (bi \u003d\u003d null) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"BLOCK* rescanPostponedMisreplicatedBlocks: \" +\n                \"Postponed mis-replicated block \" + b + \" no longer found \" +\n                \"in block map.\");\n          }\n          it.remove();\n          postponedMisreplicatedBlocksCount.decrementAndGet();\n          continue;\n        }\n        MisReplicationResult res \u003d processMisReplicatedBlock(bi);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"BLOCK* rescanPostponedMisreplicatedBlocks: \" +\n              \"Re-scanned block \" + b + \", result is \" + res);\n        }\n        if (res !\u003d MisReplicationResult.POSTPONE) {\n          it.remove();\n          postponedMisreplicatedBlocksCount.decrementAndGet();\n        }\n      }\n    } finally {\n      namesystem.writeUnlock();\n      long endPostponedMisReplicatedBlocksCount \u003d\n          getPostponedMisreplicatedBlocksCount();\n      LOG.info(\"Rescan of postponedMisreplicatedBlocks completed in \" +\n          (Time.now() - startTimeRescanPostponedMisReplicatedBlocks) +\n          \" msecs. \" + endPostponedMisReplicatedBlocksCount +\n          \" blocks are left. \" + (startPostponedMisReplicatedBlocksCount -\n          endPostponedMisReplicatedBlocksCount) + \" blocks are removed.\");\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
          "extendedDetails": {}
        }
      ]
    },
    "43295b9f7b8615f0f5d675f191f4500c35e5e552": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4030. BlockManager excessBlocksCount and postponedMisreplicatedBlocksCount should be AtomicLongs. Contributed by Eli Collins\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1430462 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/01/13 11:41 AM",
      "commitName": "43295b9f7b8615f0f5d675f191f4500c35e5e552",
      "commitAuthor": "Eli Collins",
      "commitDateOld": "04/01/13 12:09 AM",
      "commitNameOld": "2c15726999c45a53bf8ae1ce6b9d6fdcc5adfc67",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 4.48,
      "commitsBetweenForRepo": 21,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,27 +1,27 @@\n   private void rescanPostponedMisreplicatedBlocks() {\n     for (Iterator\u003cBlock\u003e it \u003d postponedMisreplicatedBlocks.iterator();\n          it.hasNext();) {\n       Block b \u003d it.next();\n       \n       BlockInfo bi \u003d blocksMap.getStoredBlock(b);\n       if (bi \u003d\u003d null) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"BLOCK* rescanPostponedMisreplicatedBlocks: \" +\n               \"Postponed mis-replicated block \" + b + \" no longer found \" +\n               \"in block map.\");\n         }\n         it.remove();\n-        postponedMisreplicatedBlocksCount--;\n+        postponedMisreplicatedBlocksCount.decrementAndGet();\n         continue;\n       }\n       MisReplicationResult res \u003d processMisReplicatedBlock(bi);\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"BLOCK* rescanPostponedMisreplicatedBlocks: \" +\n             \"Re-scanned block \" + b + \", result is \" + res);\n       }\n       if (res !\u003d MisReplicationResult.POSTPONE) {\n         it.remove();\n-        postponedMisreplicatedBlocksCount--;\n+        postponedMisreplicatedBlocksCount.decrementAndGet();\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void rescanPostponedMisreplicatedBlocks() {\n    for (Iterator\u003cBlock\u003e it \u003d postponedMisreplicatedBlocks.iterator();\n         it.hasNext();) {\n      Block b \u003d it.next();\n      \n      BlockInfo bi \u003d blocksMap.getStoredBlock(b);\n      if (bi \u003d\u003d null) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"BLOCK* rescanPostponedMisreplicatedBlocks: \" +\n              \"Postponed mis-replicated block \" + b + \" no longer found \" +\n              \"in block map.\");\n        }\n        it.remove();\n        postponedMisreplicatedBlocksCount.decrementAndGet();\n        continue;\n      }\n      MisReplicationResult res \u003d processMisReplicatedBlock(bi);\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"BLOCK* rescanPostponedMisreplicatedBlocks: \" +\n            \"Re-scanned block \" + b + \", result is \" + res);\n      }\n      if (res !\u003d MisReplicationResult.POSTPONE) {\n        it.remove();\n        postponedMisreplicatedBlocksCount.decrementAndGet();\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    }
  }
}