{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "KMSACLs.java",
  "functionName": "setKeyACLs",
  "functionId": "setKeyACLs___conf-Configuration",
  "sourceFilePath": "hadoop-common-project/hadoop-kms/src/main/java/org/apache/hadoop/crypto/key/kms/server/KMSACLs.java",
  "functionStartLine": 114,
  "functionEndLine": 163,
  "numCommitsSeen": 19,
  "timeTaken": 2183,
  "changeHistory": [
    "9daa9979a1f92fb3230361c10ddfcc1633795c0e",
    "ee1e06a3ab9136a3cd32b44c5535dfd2443bfad6",
    "1812241ee10c0a98844bffb9341f770d54655f52",
    "31b4d2daa14a7f6e8ee73fd3160e126d8db62ffb",
    "b02a4b40610e93eef6559db09a11d287e859446d",
    "d9a03e272adbf3e9fde501610400f18fb4f6b865",
    "80d7f0911cf42eee001fe1a3d6958b82635df671",
    "17d4fbbf0af9b93de9502afb274e91533140d1c6"
  ],
  "changeHistoryShort": {
    "9daa9979a1f92fb3230361c10ddfcc1633795c0e": "Ymultichange(Ymodifierchange,Ybodychange)",
    "ee1e06a3ab9136a3cd32b44c5535dfd2443bfad6": "Ybodychange",
    "1812241ee10c0a98844bffb9341f770d54655f52": "Ybodychange",
    "31b4d2daa14a7f6e8ee73fd3160e126d8db62ffb": "Ybodychange",
    "b02a4b40610e93eef6559db09a11d287e859446d": "Ymultichange(Yrename,Ybodychange)",
    "d9a03e272adbf3e9fde501610400f18fb4f6b865": "Ybodychange",
    "80d7f0911cf42eee001fe1a3d6958b82635df671": "Ybodychange",
    "17d4fbbf0af9b93de9502afb274e91533140d1c6": "Yintroduced"
  },
  "changeHistoryDetails": {
    "9daa9979a1f92fb3230361c10ddfcc1633795c0e": {
      "type": "Ymultichange(Ymodifierchange,Ybodychange)",
      "commitMessage": "HADOOP-13437. KMS should reload whitelist and default key ACLs when hot-reloading. Contributed by Xiao Chen.\n",
      "commitDate": "15/08/16 6:14 PM",
      "commitName": "9daa9979a1f92fb3230361c10ddfcc1633795c0e",
      "commitAuthor": "Xiao Chen",
      "subchanges": [
        {
          "type": "Ymodifierchange",
          "commitMessage": "HADOOP-13437. KMS should reload whitelist and default key ACLs when hot-reloading. Contributed by Xiao Chen.\n",
          "commitDate": "15/08/16 6:14 PM",
          "commitName": "9daa9979a1f92fb3230361c10ddfcc1633795c0e",
          "commitAuthor": "Xiao Chen",
          "commitDateOld": "27/01/15 8:07 AM",
          "commitNameOld": "ee1e06a3ab9136a3cd32b44c5535dfd2443bfad6",
          "commitAuthorOld": "yliu",
          "daysBetweenCommits": 566.38,
          "commitsBetweenForRepo": 4403,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,72 +1,50 @@\n-  private void setKeyACLs(Configuration conf) {\n+  void setKeyACLs(Configuration conf) {\n     Map\u003cString, HashMap\u003cKeyOpType, AccessControlList\u003e\u003e tempKeyAcls \u003d\n         new HashMap\u003cString, HashMap\u003cKeyOpType,AccessControlList\u003e\u003e();\n     Map\u003cString, String\u003e allKeyACLS \u003d\n         conf.getValByRegex(KMSConfiguration.KEY_ACL_PREFIX_REGEX);\n     for (Map.Entry\u003cString, String\u003e keyAcl : allKeyACLS.entrySet()) {\n       String k \u003d keyAcl.getKey();\n       // this should be of type \"key.acl.\u003cKEY_NAME\u003e.\u003cOP_TYPE\u003e\"\n       int keyNameStarts \u003d KMSConfiguration.KEY_ACL_PREFIX.length();\n       int keyNameEnds \u003d k.lastIndexOf(\".\");\n       if (keyNameStarts \u003e\u003d keyNameEnds) {\n         LOG.warn(\"Invalid key name \u0027{}\u0027\", k);\n       } else {\n         String aclStr \u003d keyAcl.getValue();\n         String keyName \u003d k.substring(keyNameStarts, keyNameEnds);\n         String keyOp \u003d k.substring(keyNameEnds + 1);\n         KeyOpType aclType \u003d null;\n         try {\n           aclType \u003d KeyOpType.valueOf(keyOp);\n         } catch (IllegalArgumentException e) {\n           LOG.warn(\"Invalid key Operation \u0027{}\u0027\", keyOp);\n         }\n         if (aclType !\u003d null) {\n           // On the assumption this will be single threaded.. else we need to\n           // ConcurrentHashMap\n           HashMap\u003cKeyOpType,AccessControlList\u003e aclMap \u003d\n               tempKeyAcls.get(keyName);\n           if (aclMap \u003d\u003d null) {\n             aclMap \u003d new HashMap\u003cKeyOpType, AccessControlList\u003e();\n             tempKeyAcls.put(keyName, aclMap);\n           }\n           aclMap.put(aclType, new AccessControlList(aclStr));\n           LOG.info(\"KEY_NAME \u0027{}\u0027 KEY_OP \u0027{}\u0027 ACL \u0027{}\u0027\",\n               keyName, aclType, aclStr);\n         }\n       }\n     }\n-\n     keyAcls \u003d tempKeyAcls;\n+\n+    final Map\u003cKeyOpType, AccessControlList\u003e tempDefaults \u003d new HashMap\u003c\u003e();\n+    final Map\u003cKeyOpType, AccessControlList\u003e tempWhitelists \u003d new HashMap\u003c\u003e();\n     for (KeyOpType keyOp : KeyOpType.values()) {\n-      if (!defaultKeyAcls.containsKey(keyOp)) {\n-        String confKey \u003d KMSConfiguration.DEFAULT_KEY_ACL_PREFIX + keyOp;\n-        String aclStr \u003d conf.get(confKey);\n-        if (aclStr !\u003d null) {\n-          if (keyOp \u003d\u003d KeyOpType.ALL) {\n-            // Ignore All operation for default key acl\n-            LOG.warn(\"Should not configure default key ACL for KEY_OP \u0027{}\u0027\", keyOp);\n-          } else {\n-            if (aclStr.equals(\"*\")) {\n-              LOG.info(\"Default Key ACL for KEY_OP \u0027{}\u0027 is set to \u0027*\u0027\", keyOp);\n-            }\n-            defaultKeyAcls.put(keyOp, new AccessControlList(aclStr));\n-          }\n-        }\n-      }\n-      if (!whitelistKeyAcls.containsKey(keyOp)) {\n-        String confKey \u003d KMSConfiguration.WHITELIST_KEY_ACL_PREFIX + keyOp;\n-        String aclStr \u003d conf.get(confKey);\n-        if (aclStr !\u003d null) {\n-          if (keyOp \u003d\u003d KeyOpType.ALL) {\n-            // Ignore All operation for whitelist key acl\n-            LOG.warn(\"Should not configure whitelist key ACL for KEY_OP \u0027{}\u0027\", keyOp);\n-          } else {\n-            if (aclStr.equals(\"*\")) {\n-              LOG.info(\"Whitelist Key ACL for KEY_OP \u0027{}\u0027 is set to \u0027*\u0027\", keyOp);\n-            }\n-            whitelistKeyAcls.put(keyOp, new AccessControlList(aclStr));\n-          }\n-        }\n-      }\n+      parseAclsWithPrefix(conf, KMSConfiguration.DEFAULT_KEY_ACL_PREFIX,\n+          keyOp, tempDefaults);\n+      parseAclsWithPrefix(conf, KMSConfiguration.WHITELIST_KEY_ACL_PREFIX,\n+          keyOp, tempWhitelists);\n     }\n+    defaultKeyAcls \u003d tempDefaults;\n+    whitelistKeyAcls \u003d tempWhitelists;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  void setKeyACLs(Configuration conf) {\n    Map\u003cString, HashMap\u003cKeyOpType, AccessControlList\u003e\u003e tempKeyAcls \u003d\n        new HashMap\u003cString, HashMap\u003cKeyOpType,AccessControlList\u003e\u003e();\n    Map\u003cString, String\u003e allKeyACLS \u003d\n        conf.getValByRegex(KMSConfiguration.KEY_ACL_PREFIX_REGEX);\n    for (Map.Entry\u003cString, String\u003e keyAcl : allKeyACLS.entrySet()) {\n      String k \u003d keyAcl.getKey();\n      // this should be of type \"key.acl.\u003cKEY_NAME\u003e.\u003cOP_TYPE\u003e\"\n      int keyNameStarts \u003d KMSConfiguration.KEY_ACL_PREFIX.length();\n      int keyNameEnds \u003d k.lastIndexOf(\".\");\n      if (keyNameStarts \u003e\u003d keyNameEnds) {\n        LOG.warn(\"Invalid key name \u0027{}\u0027\", k);\n      } else {\n        String aclStr \u003d keyAcl.getValue();\n        String keyName \u003d k.substring(keyNameStarts, keyNameEnds);\n        String keyOp \u003d k.substring(keyNameEnds + 1);\n        KeyOpType aclType \u003d null;\n        try {\n          aclType \u003d KeyOpType.valueOf(keyOp);\n        } catch (IllegalArgumentException e) {\n          LOG.warn(\"Invalid key Operation \u0027{}\u0027\", keyOp);\n        }\n        if (aclType !\u003d null) {\n          // On the assumption this will be single threaded.. else we need to\n          // ConcurrentHashMap\n          HashMap\u003cKeyOpType,AccessControlList\u003e aclMap \u003d\n              tempKeyAcls.get(keyName);\n          if (aclMap \u003d\u003d null) {\n            aclMap \u003d new HashMap\u003cKeyOpType, AccessControlList\u003e();\n            tempKeyAcls.put(keyName, aclMap);\n          }\n          aclMap.put(aclType, new AccessControlList(aclStr));\n          LOG.info(\"KEY_NAME \u0027{}\u0027 KEY_OP \u0027{}\u0027 ACL \u0027{}\u0027\",\n              keyName, aclType, aclStr);\n        }\n      }\n    }\n    keyAcls \u003d tempKeyAcls;\n\n    final Map\u003cKeyOpType, AccessControlList\u003e tempDefaults \u003d new HashMap\u003c\u003e();\n    final Map\u003cKeyOpType, AccessControlList\u003e tempWhitelists \u003d new HashMap\u003c\u003e();\n    for (KeyOpType keyOp : KeyOpType.values()) {\n      parseAclsWithPrefix(conf, KMSConfiguration.DEFAULT_KEY_ACL_PREFIX,\n          keyOp, tempDefaults);\n      parseAclsWithPrefix(conf, KMSConfiguration.WHITELIST_KEY_ACL_PREFIX,\n          keyOp, tempWhitelists);\n    }\n    defaultKeyAcls \u003d tempDefaults;\n    whitelistKeyAcls \u003d tempWhitelists;\n  }",
          "path": "hadoop-common-project/hadoop-kms/src/main/java/org/apache/hadoop/crypto/key/kms/server/KMSACLs.java",
          "extendedDetails": {
            "oldValue": "[private]",
            "newValue": "[]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-13437. KMS should reload whitelist and default key ACLs when hot-reloading. Contributed by Xiao Chen.\n",
          "commitDate": "15/08/16 6:14 PM",
          "commitName": "9daa9979a1f92fb3230361c10ddfcc1633795c0e",
          "commitAuthor": "Xiao Chen",
          "commitDateOld": "27/01/15 8:07 AM",
          "commitNameOld": "ee1e06a3ab9136a3cd32b44c5535dfd2443bfad6",
          "commitAuthorOld": "yliu",
          "daysBetweenCommits": 566.38,
          "commitsBetweenForRepo": 4403,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,72 +1,50 @@\n-  private void setKeyACLs(Configuration conf) {\n+  void setKeyACLs(Configuration conf) {\n     Map\u003cString, HashMap\u003cKeyOpType, AccessControlList\u003e\u003e tempKeyAcls \u003d\n         new HashMap\u003cString, HashMap\u003cKeyOpType,AccessControlList\u003e\u003e();\n     Map\u003cString, String\u003e allKeyACLS \u003d\n         conf.getValByRegex(KMSConfiguration.KEY_ACL_PREFIX_REGEX);\n     for (Map.Entry\u003cString, String\u003e keyAcl : allKeyACLS.entrySet()) {\n       String k \u003d keyAcl.getKey();\n       // this should be of type \"key.acl.\u003cKEY_NAME\u003e.\u003cOP_TYPE\u003e\"\n       int keyNameStarts \u003d KMSConfiguration.KEY_ACL_PREFIX.length();\n       int keyNameEnds \u003d k.lastIndexOf(\".\");\n       if (keyNameStarts \u003e\u003d keyNameEnds) {\n         LOG.warn(\"Invalid key name \u0027{}\u0027\", k);\n       } else {\n         String aclStr \u003d keyAcl.getValue();\n         String keyName \u003d k.substring(keyNameStarts, keyNameEnds);\n         String keyOp \u003d k.substring(keyNameEnds + 1);\n         KeyOpType aclType \u003d null;\n         try {\n           aclType \u003d KeyOpType.valueOf(keyOp);\n         } catch (IllegalArgumentException e) {\n           LOG.warn(\"Invalid key Operation \u0027{}\u0027\", keyOp);\n         }\n         if (aclType !\u003d null) {\n           // On the assumption this will be single threaded.. else we need to\n           // ConcurrentHashMap\n           HashMap\u003cKeyOpType,AccessControlList\u003e aclMap \u003d\n               tempKeyAcls.get(keyName);\n           if (aclMap \u003d\u003d null) {\n             aclMap \u003d new HashMap\u003cKeyOpType, AccessControlList\u003e();\n             tempKeyAcls.put(keyName, aclMap);\n           }\n           aclMap.put(aclType, new AccessControlList(aclStr));\n           LOG.info(\"KEY_NAME \u0027{}\u0027 KEY_OP \u0027{}\u0027 ACL \u0027{}\u0027\",\n               keyName, aclType, aclStr);\n         }\n       }\n     }\n-\n     keyAcls \u003d tempKeyAcls;\n+\n+    final Map\u003cKeyOpType, AccessControlList\u003e tempDefaults \u003d new HashMap\u003c\u003e();\n+    final Map\u003cKeyOpType, AccessControlList\u003e tempWhitelists \u003d new HashMap\u003c\u003e();\n     for (KeyOpType keyOp : KeyOpType.values()) {\n-      if (!defaultKeyAcls.containsKey(keyOp)) {\n-        String confKey \u003d KMSConfiguration.DEFAULT_KEY_ACL_PREFIX + keyOp;\n-        String aclStr \u003d conf.get(confKey);\n-        if (aclStr !\u003d null) {\n-          if (keyOp \u003d\u003d KeyOpType.ALL) {\n-            // Ignore All operation for default key acl\n-            LOG.warn(\"Should not configure default key ACL for KEY_OP \u0027{}\u0027\", keyOp);\n-          } else {\n-            if (aclStr.equals(\"*\")) {\n-              LOG.info(\"Default Key ACL for KEY_OP \u0027{}\u0027 is set to \u0027*\u0027\", keyOp);\n-            }\n-            defaultKeyAcls.put(keyOp, new AccessControlList(aclStr));\n-          }\n-        }\n-      }\n-      if (!whitelistKeyAcls.containsKey(keyOp)) {\n-        String confKey \u003d KMSConfiguration.WHITELIST_KEY_ACL_PREFIX + keyOp;\n-        String aclStr \u003d conf.get(confKey);\n-        if (aclStr !\u003d null) {\n-          if (keyOp \u003d\u003d KeyOpType.ALL) {\n-            // Ignore All operation for whitelist key acl\n-            LOG.warn(\"Should not configure whitelist key ACL for KEY_OP \u0027{}\u0027\", keyOp);\n-          } else {\n-            if (aclStr.equals(\"*\")) {\n-              LOG.info(\"Whitelist Key ACL for KEY_OP \u0027{}\u0027 is set to \u0027*\u0027\", keyOp);\n-            }\n-            whitelistKeyAcls.put(keyOp, new AccessControlList(aclStr));\n-          }\n-        }\n-      }\n+      parseAclsWithPrefix(conf, KMSConfiguration.DEFAULT_KEY_ACL_PREFIX,\n+          keyOp, tempDefaults);\n+      parseAclsWithPrefix(conf, KMSConfiguration.WHITELIST_KEY_ACL_PREFIX,\n+          keyOp, tempWhitelists);\n     }\n+    defaultKeyAcls \u003d tempDefaults;\n+    whitelistKeyAcls \u003d tempWhitelists;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  void setKeyACLs(Configuration conf) {\n    Map\u003cString, HashMap\u003cKeyOpType, AccessControlList\u003e\u003e tempKeyAcls \u003d\n        new HashMap\u003cString, HashMap\u003cKeyOpType,AccessControlList\u003e\u003e();\n    Map\u003cString, String\u003e allKeyACLS \u003d\n        conf.getValByRegex(KMSConfiguration.KEY_ACL_PREFIX_REGEX);\n    for (Map.Entry\u003cString, String\u003e keyAcl : allKeyACLS.entrySet()) {\n      String k \u003d keyAcl.getKey();\n      // this should be of type \"key.acl.\u003cKEY_NAME\u003e.\u003cOP_TYPE\u003e\"\n      int keyNameStarts \u003d KMSConfiguration.KEY_ACL_PREFIX.length();\n      int keyNameEnds \u003d k.lastIndexOf(\".\");\n      if (keyNameStarts \u003e\u003d keyNameEnds) {\n        LOG.warn(\"Invalid key name \u0027{}\u0027\", k);\n      } else {\n        String aclStr \u003d keyAcl.getValue();\n        String keyName \u003d k.substring(keyNameStarts, keyNameEnds);\n        String keyOp \u003d k.substring(keyNameEnds + 1);\n        KeyOpType aclType \u003d null;\n        try {\n          aclType \u003d KeyOpType.valueOf(keyOp);\n        } catch (IllegalArgumentException e) {\n          LOG.warn(\"Invalid key Operation \u0027{}\u0027\", keyOp);\n        }\n        if (aclType !\u003d null) {\n          // On the assumption this will be single threaded.. else we need to\n          // ConcurrentHashMap\n          HashMap\u003cKeyOpType,AccessControlList\u003e aclMap \u003d\n              tempKeyAcls.get(keyName);\n          if (aclMap \u003d\u003d null) {\n            aclMap \u003d new HashMap\u003cKeyOpType, AccessControlList\u003e();\n            tempKeyAcls.put(keyName, aclMap);\n          }\n          aclMap.put(aclType, new AccessControlList(aclStr));\n          LOG.info(\"KEY_NAME \u0027{}\u0027 KEY_OP \u0027{}\u0027 ACL \u0027{}\u0027\",\n              keyName, aclType, aclStr);\n        }\n      }\n    }\n    keyAcls \u003d tempKeyAcls;\n\n    final Map\u003cKeyOpType, AccessControlList\u003e tempDefaults \u003d new HashMap\u003c\u003e();\n    final Map\u003cKeyOpType, AccessControlList\u003e tempWhitelists \u003d new HashMap\u003c\u003e();\n    for (KeyOpType keyOp : KeyOpType.values()) {\n      parseAclsWithPrefix(conf, KMSConfiguration.DEFAULT_KEY_ACL_PREFIX,\n          keyOp, tempDefaults);\n      parseAclsWithPrefix(conf, KMSConfiguration.WHITELIST_KEY_ACL_PREFIX,\n          keyOp, tempWhitelists);\n    }\n    defaultKeyAcls \u003d tempDefaults;\n    whitelistKeyAcls \u003d tempWhitelists;\n  }",
          "path": "hadoop-common-project/hadoop-kms/src/main/java/org/apache/hadoop/crypto/key/kms/server/KMSACLs.java",
          "extendedDetails": {}
        }
      ]
    },
    "ee1e06a3ab9136a3cd32b44c5535dfd2443bfad6": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11469. KMS should skip default.key.acl and whitelist.key.acl when loading key acl. (Dian Fu via yliu)\n",
      "commitDate": "27/01/15 8:07 AM",
      "commitName": "ee1e06a3ab9136a3cd32b44c5535dfd2443bfad6",
      "commitAuthor": "yliu",
      "commitDateOld": "03/12/14 12:00 PM",
      "commitNameOld": "1812241ee10c0a98844bffb9341f770d54655f52",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 54.84,
      "commitsBetweenForRepo": 339,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,72 +1,72 @@\n   private void setKeyACLs(Configuration conf) {\n     Map\u003cString, HashMap\u003cKeyOpType, AccessControlList\u003e\u003e tempKeyAcls \u003d\n         new HashMap\u003cString, HashMap\u003cKeyOpType,AccessControlList\u003e\u003e();\n     Map\u003cString, String\u003e allKeyACLS \u003d\n-        conf.getValByRegex(Pattern.quote(KMSConfiguration.KEY_ACL_PREFIX));\n+        conf.getValByRegex(KMSConfiguration.KEY_ACL_PREFIX_REGEX);\n     for (Map.Entry\u003cString, String\u003e keyAcl : allKeyACLS.entrySet()) {\n       String k \u003d keyAcl.getKey();\n       // this should be of type \"key.acl.\u003cKEY_NAME\u003e.\u003cOP_TYPE\u003e\"\n       int keyNameStarts \u003d KMSConfiguration.KEY_ACL_PREFIX.length();\n       int keyNameEnds \u003d k.lastIndexOf(\".\");\n       if (keyNameStarts \u003e\u003d keyNameEnds) {\n         LOG.warn(\"Invalid key name \u0027{}\u0027\", k);\n       } else {\n         String aclStr \u003d keyAcl.getValue();\n         String keyName \u003d k.substring(keyNameStarts, keyNameEnds);\n         String keyOp \u003d k.substring(keyNameEnds + 1);\n         KeyOpType aclType \u003d null;\n         try {\n           aclType \u003d KeyOpType.valueOf(keyOp);\n         } catch (IllegalArgumentException e) {\n           LOG.warn(\"Invalid key Operation \u0027{}\u0027\", keyOp);\n         }\n         if (aclType !\u003d null) {\n           // On the assumption this will be single threaded.. else we need to\n           // ConcurrentHashMap\n           HashMap\u003cKeyOpType,AccessControlList\u003e aclMap \u003d\n               tempKeyAcls.get(keyName);\n           if (aclMap \u003d\u003d null) {\n             aclMap \u003d new HashMap\u003cKeyOpType, AccessControlList\u003e();\n             tempKeyAcls.put(keyName, aclMap);\n           }\n           aclMap.put(aclType, new AccessControlList(aclStr));\n           LOG.info(\"KEY_NAME \u0027{}\u0027 KEY_OP \u0027{}\u0027 ACL \u0027{}\u0027\",\n               keyName, aclType, aclStr);\n         }\n       }\n     }\n \n     keyAcls \u003d tempKeyAcls;\n     for (KeyOpType keyOp : KeyOpType.values()) {\n       if (!defaultKeyAcls.containsKey(keyOp)) {\n         String confKey \u003d KMSConfiguration.DEFAULT_KEY_ACL_PREFIX + keyOp;\n         String aclStr \u003d conf.get(confKey);\n         if (aclStr !\u003d null) {\n           if (keyOp \u003d\u003d KeyOpType.ALL) {\n             // Ignore All operation for default key acl\n             LOG.warn(\"Should not configure default key ACL for KEY_OP \u0027{}\u0027\", keyOp);\n           } else {\n             if (aclStr.equals(\"*\")) {\n               LOG.info(\"Default Key ACL for KEY_OP \u0027{}\u0027 is set to \u0027*\u0027\", keyOp);\n             }\n             defaultKeyAcls.put(keyOp, new AccessControlList(aclStr));\n           }\n         }\n       }\n       if (!whitelistKeyAcls.containsKey(keyOp)) {\n         String confKey \u003d KMSConfiguration.WHITELIST_KEY_ACL_PREFIX + keyOp;\n         String aclStr \u003d conf.get(confKey);\n         if (aclStr !\u003d null) {\n           if (keyOp \u003d\u003d KeyOpType.ALL) {\n             // Ignore All operation for whitelist key acl\n             LOG.warn(\"Should not configure whitelist key ACL for KEY_OP \u0027{}\u0027\", keyOp);\n           } else {\n             if (aclStr.equals(\"*\")) {\n               LOG.info(\"Whitelist Key ACL for KEY_OP \u0027{}\u0027 is set to \u0027*\u0027\", keyOp);\n             }\n             whitelistKeyAcls.put(keyOp, new AccessControlList(aclStr));\n           }\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void setKeyACLs(Configuration conf) {\n    Map\u003cString, HashMap\u003cKeyOpType, AccessControlList\u003e\u003e tempKeyAcls \u003d\n        new HashMap\u003cString, HashMap\u003cKeyOpType,AccessControlList\u003e\u003e();\n    Map\u003cString, String\u003e allKeyACLS \u003d\n        conf.getValByRegex(KMSConfiguration.KEY_ACL_PREFIX_REGEX);\n    for (Map.Entry\u003cString, String\u003e keyAcl : allKeyACLS.entrySet()) {\n      String k \u003d keyAcl.getKey();\n      // this should be of type \"key.acl.\u003cKEY_NAME\u003e.\u003cOP_TYPE\u003e\"\n      int keyNameStarts \u003d KMSConfiguration.KEY_ACL_PREFIX.length();\n      int keyNameEnds \u003d k.lastIndexOf(\".\");\n      if (keyNameStarts \u003e\u003d keyNameEnds) {\n        LOG.warn(\"Invalid key name \u0027{}\u0027\", k);\n      } else {\n        String aclStr \u003d keyAcl.getValue();\n        String keyName \u003d k.substring(keyNameStarts, keyNameEnds);\n        String keyOp \u003d k.substring(keyNameEnds + 1);\n        KeyOpType aclType \u003d null;\n        try {\n          aclType \u003d KeyOpType.valueOf(keyOp);\n        } catch (IllegalArgumentException e) {\n          LOG.warn(\"Invalid key Operation \u0027{}\u0027\", keyOp);\n        }\n        if (aclType !\u003d null) {\n          // On the assumption this will be single threaded.. else we need to\n          // ConcurrentHashMap\n          HashMap\u003cKeyOpType,AccessControlList\u003e aclMap \u003d\n              tempKeyAcls.get(keyName);\n          if (aclMap \u003d\u003d null) {\n            aclMap \u003d new HashMap\u003cKeyOpType, AccessControlList\u003e();\n            tempKeyAcls.put(keyName, aclMap);\n          }\n          aclMap.put(aclType, new AccessControlList(aclStr));\n          LOG.info(\"KEY_NAME \u0027{}\u0027 KEY_OP \u0027{}\u0027 ACL \u0027{}\u0027\",\n              keyName, aclType, aclStr);\n        }\n      }\n    }\n\n    keyAcls \u003d tempKeyAcls;\n    for (KeyOpType keyOp : KeyOpType.values()) {\n      if (!defaultKeyAcls.containsKey(keyOp)) {\n        String confKey \u003d KMSConfiguration.DEFAULT_KEY_ACL_PREFIX + keyOp;\n        String aclStr \u003d conf.get(confKey);\n        if (aclStr !\u003d null) {\n          if (keyOp \u003d\u003d KeyOpType.ALL) {\n            // Ignore All operation for default key acl\n            LOG.warn(\"Should not configure default key ACL for KEY_OP \u0027{}\u0027\", keyOp);\n          } else {\n            if (aclStr.equals(\"*\")) {\n              LOG.info(\"Default Key ACL for KEY_OP \u0027{}\u0027 is set to \u0027*\u0027\", keyOp);\n            }\n            defaultKeyAcls.put(keyOp, new AccessControlList(aclStr));\n          }\n        }\n      }\n      if (!whitelistKeyAcls.containsKey(keyOp)) {\n        String confKey \u003d KMSConfiguration.WHITELIST_KEY_ACL_PREFIX + keyOp;\n        String aclStr \u003d conf.get(confKey);\n        if (aclStr !\u003d null) {\n          if (keyOp \u003d\u003d KeyOpType.ALL) {\n            // Ignore All operation for whitelist key acl\n            LOG.warn(\"Should not configure whitelist key ACL for KEY_OP \u0027{}\u0027\", keyOp);\n          } else {\n            if (aclStr.equals(\"*\")) {\n              LOG.info(\"Whitelist Key ACL for KEY_OP \u0027{}\u0027 is set to \u0027*\u0027\", keyOp);\n            }\n            whitelistKeyAcls.put(keyOp, new AccessControlList(aclStr));\n          }\n        }\n      }\n    }\n  }",
      "path": "hadoop-common-project/hadoop-kms/src/main/java/org/apache/hadoop/crypto/key/kms/server/KMSACLs.java",
      "extendedDetails": {}
    },
    "1812241ee10c0a98844bffb9341f770d54655f52": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11342. KMS key ACL should ignore ALL operation for default key ACL and whitelist key ACL. Contributed by Dian Fu.\n",
      "commitDate": "03/12/14 12:00 PM",
      "commitName": "1812241ee10c0a98844bffb9341f770d54655f52",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "01/12/14 9:53 PM",
      "commitNameOld": "31b4d2daa14a7f6e8ee73fd3160e126d8db62ffb",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 1.59,
      "commitsBetweenForRepo": 18,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,62 +1,72 @@\n   private void setKeyACLs(Configuration conf) {\n     Map\u003cString, HashMap\u003cKeyOpType, AccessControlList\u003e\u003e tempKeyAcls \u003d\n         new HashMap\u003cString, HashMap\u003cKeyOpType,AccessControlList\u003e\u003e();\n     Map\u003cString, String\u003e allKeyACLS \u003d\n         conf.getValByRegex(Pattern.quote(KMSConfiguration.KEY_ACL_PREFIX));\n     for (Map.Entry\u003cString, String\u003e keyAcl : allKeyACLS.entrySet()) {\n       String k \u003d keyAcl.getKey();\n       // this should be of type \"key.acl.\u003cKEY_NAME\u003e.\u003cOP_TYPE\u003e\"\n       int keyNameStarts \u003d KMSConfiguration.KEY_ACL_PREFIX.length();\n       int keyNameEnds \u003d k.lastIndexOf(\".\");\n       if (keyNameStarts \u003e\u003d keyNameEnds) {\n         LOG.warn(\"Invalid key name \u0027{}\u0027\", k);\n       } else {\n         String aclStr \u003d keyAcl.getValue();\n         String keyName \u003d k.substring(keyNameStarts, keyNameEnds);\n         String keyOp \u003d k.substring(keyNameEnds + 1);\n         KeyOpType aclType \u003d null;\n         try {\n           aclType \u003d KeyOpType.valueOf(keyOp);\n         } catch (IllegalArgumentException e) {\n           LOG.warn(\"Invalid key Operation \u0027{}\u0027\", keyOp);\n         }\n         if (aclType !\u003d null) {\n           // On the assumption this will be single threaded.. else we need to\n           // ConcurrentHashMap\n           HashMap\u003cKeyOpType,AccessControlList\u003e aclMap \u003d\n               tempKeyAcls.get(keyName);\n           if (aclMap \u003d\u003d null) {\n             aclMap \u003d new HashMap\u003cKeyOpType, AccessControlList\u003e();\n             tempKeyAcls.put(keyName, aclMap);\n           }\n           aclMap.put(aclType, new AccessControlList(aclStr));\n           LOG.info(\"KEY_NAME \u0027{}\u0027 KEY_OP \u0027{}\u0027 ACL \u0027{}\u0027\",\n               keyName, aclType, aclStr);\n         }\n       }\n     }\n \n     keyAcls \u003d tempKeyAcls;\n     for (KeyOpType keyOp : KeyOpType.values()) {\n       if (!defaultKeyAcls.containsKey(keyOp)) {\n         String confKey \u003d KMSConfiguration.DEFAULT_KEY_ACL_PREFIX + keyOp;\n         String aclStr \u003d conf.get(confKey);\n         if (aclStr !\u003d null) {\n-          if (aclStr.equals(\"*\")) {\n-            LOG.info(\"Default Key ACL for KEY_OP \u0027{}\u0027 is set to \u0027*\u0027\", keyOp);\n+          if (keyOp \u003d\u003d KeyOpType.ALL) {\n+            // Ignore All operation for default key acl\n+            LOG.warn(\"Should not configure default key ACL for KEY_OP \u0027{}\u0027\", keyOp);\n+          } else {\n+            if (aclStr.equals(\"*\")) {\n+              LOG.info(\"Default Key ACL for KEY_OP \u0027{}\u0027 is set to \u0027*\u0027\", keyOp);\n+            }\n+            defaultKeyAcls.put(keyOp, new AccessControlList(aclStr));\n           }\n-          defaultKeyAcls.put(keyOp, new AccessControlList(aclStr));\n         }\n       }\n       if (!whitelistKeyAcls.containsKey(keyOp)) {\n         String confKey \u003d KMSConfiguration.WHITELIST_KEY_ACL_PREFIX + keyOp;\n         String aclStr \u003d conf.get(confKey);\n         if (aclStr !\u003d null) {\n-          if (aclStr.equals(\"*\")) {\n-            LOG.info(\"Whitelist Key ACL for KEY_OP \u0027{}\u0027 is set to \u0027*\u0027\", keyOp);\n+          if (keyOp \u003d\u003d KeyOpType.ALL) {\n+            // Ignore All operation for whitelist key acl\n+            LOG.warn(\"Should not configure whitelist key ACL for KEY_OP \u0027{}\u0027\", keyOp);\n+          } else {\n+            if (aclStr.equals(\"*\")) {\n+              LOG.info(\"Whitelist Key ACL for KEY_OP \u0027{}\u0027 is set to \u0027*\u0027\", keyOp);\n+            }\n+            whitelistKeyAcls.put(keyOp, new AccessControlList(aclStr));\n           }\n-          whitelistKeyAcls.put(keyOp, new AccessControlList(aclStr));\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void setKeyACLs(Configuration conf) {\n    Map\u003cString, HashMap\u003cKeyOpType, AccessControlList\u003e\u003e tempKeyAcls \u003d\n        new HashMap\u003cString, HashMap\u003cKeyOpType,AccessControlList\u003e\u003e();\n    Map\u003cString, String\u003e allKeyACLS \u003d\n        conf.getValByRegex(Pattern.quote(KMSConfiguration.KEY_ACL_PREFIX));\n    for (Map.Entry\u003cString, String\u003e keyAcl : allKeyACLS.entrySet()) {\n      String k \u003d keyAcl.getKey();\n      // this should be of type \"key.acl.\u003cKEY_NAME\u003e.\u003cOP_TYPE\u003e\"\n      int keyNameStarts \u003d KMSConfiguration.KEY_ACL_PREFIX.length();\n      int keyNameEnds \u003d k.lastIndexOf(\".\");\n      if (keyNameStarts \u003e\u003d keyNameEnds) {\n        LOG.warn(\"Invalid key name \u0027{}\u0027\", k);\n      } else {\n        String aclStr \u003d keyAcl.getValue();\n        String keyName \u003d k.substring(keyNameStarts, keyNameEnds);\n        String keyOp \u003d k.substring(keyNameEnds + 1);\n        KeyOpType aclType \u003d null;\n        try {\n          aclType \u003d KeyOpType.valueOf(keyOp);\n        } catch (IllegalArgumentException e) {\n          LOG.warn(\"Invalid key Operation \u0027{}\u0027\", keyOp);\n        }\n        if (aclType !\u003d null) {\n          // On the assumption this will be single threaded.. else we need to\n          // ConcurrentHashMap\n          HashMap\u003cKeyOpType,AccessControlList\u003e aclMap \u003d\n              tempKeyAcls.get(keyName);\n          if (aclMap \u003d\u003d null) {\n            aclMap \u003d new HashMap\u003cKeyOpType, AccessControlList\u003e();\n            tempKeyAcls.put(keyName, aclMap);\n          }\n          aclMap.put(aclType, new AccessControlList(aclStr));\n          LOG.info(\"KEY_NAME \u0027{}\u0027 KEY_OP \u0027{}\u0027 ACL \u0027{}\u0027\",\n              keyName, aclType, aclStr);\n        }\n      }\n    }\n\n    keyAcls \u003d tempKeyAcls;\n    for (KeyOpType keyOp : KeyOpType.values()) {\n      if (!defaultKeyAcls.containsKey(keyOp)) {\n        String confKey \u003d KMSConfiguration.DEFAULT_KEY_ACL_PREFIX + keyOp;\n        String aclStr \u003d conf.get(confKey);\n        if (aclStr !\u003d null) {\n          if (keyOp \u003d\u003d KeyOpType.ALL) {\n            // Ignore All operation for default key acl\n            LOG.warn(\"Should not configure default key ACL for KEY_OP \u0027{}\u0027\", keyOp);\n          } else {\n            if (aclStr.equals(\"*\")) {\n              LOG.info(\"Default Key ACL for KEY_OP \u0027{}\u0027 is set to \u0027*\u0027\", keyOp);\n            }\n            defaultKeyAcls.put(keyOp, new AccessControlList(aclStr));\n          }\n        }\n      }\n      if (!whitelistKeyAcls.containsKey(keyOp)) {\n        String confKey \u003d KMSConfiguration.WHITELIST_KEY_ACL_PREFIX + keyOp;\n        String aclStr \u003d conf.get(confKey);\n        if (aclStr !\u003d null) {\n          if (keyOp \u003d\u003d KeyOpType.ALL) {\n            // Ignore All operation for whitelist key acl\n            LOG.warn(\"Should not configure whitelist key ACL for KEY_OP \u0027{}\u0027\", keyOp);\n          } else {\n            if (aclStr.equals(\"*\")) {\n              LOG.info(\"Whitelist Key ACL for KEY_OP \u0027{}\u0027 is set to \u0027*\u0027\", keyOp);\n            }\n            whitelistKeyAcls.put(keyOp, new AccessControlList(aclStr));\n          }\n        }\n      }\n    }\n  }",
      "path": "hadoop-common-project/hadoop-kms/src/main/java/org/apache/hadoop/crypto/key/kms/server/KMSACLs.java",
      "extendedDetails": {}
    },
    "31b4d2daa14a7f6e8ee73fd3160e126d8db62ffb": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11341. KMS support for whitelist key ACLs. Contributed by Arun Suresh.\n",
      "commitDate": "01/12/14 9:53 PM",
      "commitName": "31b4d2daa14a7f6e8ee73fd3160e126d8db62ffb",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "10/09/14 2:26 PM",
      "commitNameOld": "b02a4b40610e93eef6559db09a11d287e859446d",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 82.35,
      "commitsBetweenForRepo": 765,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,62 @@\n   private void setKeyACLs(Configuration conf) {\n     Map\u003cString, HashMap\u003cKeyOpType, AccessControlList\u003e\u003e tempKeyAcls \u003d\n         new HashMap\u003cString, HashMap\u003cKeyOpType,AccessControlList\u003e\u003e();\n     Map\u003cString, String\u003e allKeyACLS \u003d\n         conf.getValByRegex(Pattern.quote(KMSConfiguration.KEY_ACL_PREFIX));\n     for (Map.Entry\u003cString, String\u003e keyAcl : allKeyACLS.entrySet()) {\n       String k \u003d keyAcl.getKey();\n       // this should be of type \"key.acl.\u003cKEY_NAME\u003e.\u003cOP_TYPE\u003e\"\n       int keyNameStarts \u003d KMSConfiguration.KEY_ACL_PREFIX.length();\n       int keyNameEnds \u003d k.lastIndexOf(\".\");\n       if (keyNameStarts \u003e\u003d keyNameEnds) {\n         LOG.warn(\"Invalid key name \u0027{}\u0027\", k);\n       } else {\n         String aclStr \u003d keyAcl.getValue();\n         String keyName \u003d k.substring(keyNameStarts, keyNameEnds);\n         String keyOp \u003d k.substring(keyNameEnds + 1);\n         KeyOpType aclType \u003d null;\n         try {\n           aclType \u003d KeyOpType.valueOf(keyOp);\n         } catch (IllegalArgumentException e) {\n           LOG.warn(\"Invalid key Operation \u0027{}\u0027\", keyOp);\n         }\n         if (aclType !\u003d null) {\n           // On the assumption this will be single threaded.. else we need to\n           // ConcurrentHashMap\n           HashMap\u003cKeyOpType,AccessControlList\u003e aclMap \u003d\n               tempKeyAcls.get(keyName);\n           if (aclMap \u003d\u003d null) {\n             aclMap \u003d new HashMap\u003cKeyOpType, AccessControlList\u003e();\n             tempKeyAcls.put(keyName, aclMap);\n           }\n           aclMap.put(aclType, new AccessControlList(aclStr));\n           LOG.info(\"KEY_NAME \u0027{}\u0027 KEY_OP \u0027{}\u0027 ACL \u0027{}\u0027\",\n               keyName, aclType, aclStr);\n         }\n       }\n     }\n \n     keyAcls \u003d tempKeyAcls;\n     for (KeyOpType keyOp : KeyOpType.values()) {\n       if (!defaultKeyAcls.containsKey(keyOp)) {\n         String confKey \u003d KMSConfiguration.DEFAULT_KEY_ACL_PREFIX + keyOp;\n         String aclStr \u003d conf.get(confKey);\n         if (aclStr !\u003d null) {\n           if (aclStr.equals(\"*\")) {\n-            LOG.info(\"Default Key ACL for  KEY_OP \u0027{}\u0027 is set to \u0027*\u0027\", keyOp);\n+            LOG.info(\"Default Key ACL for KEY_OP \u0027{}\u0027 is set to \u0027*\u0027\", keyOp);\n           }\n           defaultKeyAcls.put(keyOp, new AccessControlList(aclStr));\n         }\n       }\n+      if (!whitelistKeyAcls.containsKey(keyOp)) {\n+        String confKey \u003d KMSConfiguration.WHITELIST_KEY_ACL_PREFIX + keyOp;\n+        String aclStr \u003d conf.get(confKey);\n+        if (aclStr !\u003d null) {\n+          if (aclStr.equals(\"*\")) {\n+            LOG.info(\"Whitelist Key ACL for KEY_OP \u0027{}\u0027 is set to \u0027*\u0027\", keyOp);\n+          }\n+          whitelistKeyAcls.put(keyOp, new AccessControlList(aclStr));\n+        }\n+      }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void setKeyACLs(Configuration conf) {\n    Map\u003cString, HashMap\u003cKeyOpType, AccessControlList\u003e\u003e tempKeyAcls \u003d\n        new HashMap\u003cString, HashMap\u003cKeyOpType,AccessControlList\u003e\u003e();\n    Map\u003cString, String\u003e allKeyACLS \u003d\n        conf.getValByRegex(Pattern.quote(KMSConfiguration.KEY_ACL_PREFIX));\n    for (Map.Entry\u003cString, String\u003e keyAcl : allKeyACLS.entrySet()) {\n      String k \u003d keyAcl.getKey();\n      // this should be of type \"key.acl.\u003cKEY_NAME\u003e.\u003cOP_TYPE\u003e\"\n      int keyNameStarts \u003d KMSConfiguration.KEY_ACL_PREFIX.length();\n      int keyNameEnds \u003d k.lastIndexOf(\".\");\n      if (keyNameStarts \u003e\u003d keyNameEnds) {\n        LOG.warn(\"Invalid key name \u0027{}\u0027\", k);\n      } else {\n        String aclStr \u003d keyAcl.getValue();\n        String keyName \u003d k.substring(keyNameStarts, keyNameEnds);\n        String keyOp \u003d k.substring(keyNameEnds + 1);\n        KeyOpType aclType \u003d null;\n        try {\n          aclType \u003d KeyOpType.valueOf(keyOp);\n        } catch (IllegalArgumentException e) {\n          LOG.warn(\"Invalid key Operation \u0027{}\u0027\", keyOp);\n        }\n        if (aclType !\u003d null) {\n          // On the assumption this will be single threaded.. else we need to\n          // ConcurrentHashMap\n          HashMap\u003cKeyOpType,AccessControlList\u003e aclMap \u003d\n              tempKeyAcls.get(keyName);\n          if (aclMap \u003d\u003d null) {\n            aclMap \u003d new HashMap\u003cKeyOpType, AccessControlList\u003e();\n            tempKeyAcls.put(keyName, aclMap);\n          }\n          aclMap.put(aclType, new AccessControlList(aclStr));\n          LOG.info(\"KEY_NAME \u0027{}\u0027 KEY_OP \u0027{}\u0027 ACL \u0027{}\u0027\",\n              keyName, aclType, aclStr);\n        }\n      }\n    }\n\n    keyAcls \u003d tempKeyAcls;\n    for (KeyOpType keyOp : KeyOpType.values()) {\n      if (!defaultKeyAcls.containsKey(keyOp)) {\n        String confKey \u003d KMSConfiguration.DEFAULT_KEY_ACL_PREFIX + keyOp;\n        String aclStr \u003d conf.get(confKey);\n        if (aclStr !\u003d null) {\n          if (aclStr.equals(\"*\")) {\n            LOG.info(\"Default Key ACL for KEY_OP \u0027{}\u0027 is set to \u0027*\u0027\", keyOp);\n          }\n          defaultKeyAcls.put(keyOp, new AccessControlList(aclStr));\n        }\n      }\n      if (!whitelistKeyAcls.containsKey(keyOp)) {\n        String confKey \u003d KMSConfiguration.WHITELIST_KEY_ACL_PREFIX + keyOp;\n        String aclStr \u003d conf.get(confKey);\n        if (aclStr !\u003d null) {\n          if (aclStr.equals(\"*\")) {\n            LOG.info(\"Whitelist Key ACL for KEY_OP \u0027{}\u0027 is set to \u0027*\u0027\", keyOp);\n          }\n          whitelistKeyAcls.put(keyOp, new AccessControlList(aclStr));\n        }\n      }\n    }\n  }",
      "path": "hadoop-common-project/hadoop-kms/src/main/java/org/apache/hadoop/crypto/key/kms/server/KMSACLs.java",
      "extendedDetails": {}
    },
    "b02a4b40610e93eef6559db09a11d287e859446d": {
      "type": "Ymultichange(Yrename,Ybodychange)",
      "commitMessage": "HADOOP-10758. KMS: add ACLs on per key basis. (tucu)\n",
      "commitDate": "10/09/14 2:26 PM",
      "commitName": "b02a4b40610e93eef6559db09a11d287e859446d",
      "commitAuthor": "Alejandro Abdelnur",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "HADOOP-10758. KMS: add ACLs on per key basis. (tucu)\n",
          "commitDate": "10/09/14 2:26 PM",
          "commitName": "b02a4b40610e93eef6559db09a11d287e859446d",
          "commitAuthor": "Alejandro Abdelnur",
          "commitDateOld": "03/09/14 3:08 PM",
          "commitNameOld": "d9a03e272adbf3e9fde501610400f18fb4f6b865",
          "commitAuthorOld": "Alejandro Abdelnur",
          "daysBetweenCommits": 6.97,
          "commitsBetweenForRepo": 62,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,17 +1,52 @@\n-  private void setACLs(Configuration conf) {\n-    Map\u003cType, AccessControlList\u003e tempAcls \u003d new HashMap\u003cType, AccessControlList\u003e();\n-    Map\u003cType, AccessControlList\u003e tempBlacklist \u003d new HashMap\u003cType, AccessControlList\u003e();\n-    for (Type aclType : Type.values()) {\n-      String aclStr \u003d conf.get(aclType.getAclConfigKey(), ACL_DEFAULT);\n-      tempAcls.put(aclType, new AccessControlList(aclStr));\n-      String blacklistStr \u003d conf.get(aclType.getBlacklistConfigKey());\n-      if (blacklistStr !\u003d null) {\n-        // Only add if blacklist is present\n-        tempBlacklist.put(aclType, new AccessControlList(blacklistStr));\n-        LOG.info(\"\u0027{}\u0027 Blacklist \u0027{}\u0027\", aclType, blacklistStr);\n+  private void setKeyACLs(Configuration conf) {\n+    Map\u003cString, HashMap\u003cKeyOpType, AccessControlList\u003e\u003e tempKeyAcls \u003d\n+        new HashMap\u003cString, HashMap\u003cKeyOpType,AccessControlList\u003e\u003e();\n+    Map\u003cString, String\u003e allKeyACLS \u003d\n+        conf.getValByRegex(Pattern.quote(KMSConfiguration.KEY_ACL_PREFIX));\n+    for (Map.Entry\u003cString, String\u003e keyAcl : allKeyACLS.entrySet()) {\n+      String k \u003d keyAcl.getKey();\n+      // this should be of type \"key.acl.\u003cKEY_NAME\u003e.\u003cOP_TYPE\u003e\"\n+      int keyNameStarts \u003d KMSConfiguration.KEY_ACL_PREFIX.length();\n+      int keyNameEnds \u003d k.lastIndexOf(\".\");\n+      if (keyNameStarts \u003e\u003d keyNameEnds) {\n+        LOG.warn(\"Invalid key name \u0027{}\u0027\", k);\n+      } else {\n+        String aclStr \u003d keyAcl.getValue();\n+        String keyName \u003d k.substring(keyNameStarts, keyNameEnds);\n+        String keyOp \u003d k.substring(keyNameEnds + 1);\n+        KeyOpType aclType \u003d null;\n+        try {\n+          aclType \u003d KeyOpType.valueOf(keyOp);\n+        } catch (IllegalArgumentException e) {\n+          LOG.warn(\"Invalid key Operation \u0027{}\u0027\", keyOp);\n+        }\n+        if (aclType !\u003d null) {\n+          // On the assumption this will be single threaded.. else we need to\n+          // ConcurrentHashMap\n+          HashMap\u003cKeyOpType,AccessControlList\u003e aclMap \u003d\n+              tempKeyAcls.get(keyName);\n+          if (aclMap \u003d\u003d null) {\n+            aclMap \u003d new HashMap\u003cKeyOpType, AccessControlList\u003e();\n+            tempKeyAcls.put(keyName, aclMap);\n+          }\n+          aclMap.put(aclType, new AccessControlList(aclStr));\n+          LOG.info(\"KEY_NAME \u0027{}\u0027 KEY_OP \u0027{}\u0027 ACL \u0027{}\u0027\",\n+              keyName, aclType, aclStr);\n+        }\n       }\n-      LOG.info(\"\u0027{}\u0027 ACL \u0027{}\u0027\", aclType, aclStr);\n     }\n-    acls \u003d tempAcls;\n-    blacklistedAcls \u003d tempBlacklist;\n+\n+    keyAcls \u003d tempKeyAcls;\n+    for (KeyOpType keyOp : KeyOpType.values()) {\n+      if (!defaultKeyAcls.containsKey(keyOp)) {\n+        String confKey \u003d KMSConfiguration.DEFAULT_KEY_ACL_PREFIX + keyOp;\n+        String aclStr \u003d conf.get(confKey);\n+        if (aclStr !\u003d null) {\n+          if (aclStr.equals(\"*\")) {\n+            LOG.info(\"Default Key ACL for  KEY_OP \u0027{}\u0027 is set to \u0027*\u0027\", keyOp);\n+          }\n+          defaultKeyAcls.put(keyOp, new AccessControlList(aclStr));\n+        }\n+      }\n+    }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void setKeyACLs(Configuration conf) {\n    Map\u003cString, HashMap\u003cKeyOpType, AccessControlList\u003e\u003e tempKeyAcls \u003d\n        new HashMap\u003cString, HashMap\u003cKeyOpType,AccessControlList\u003e\u003e();\n    Map\u003cString, String\u003e allKeyACLS \u003d\n        conf.getValByRegex(Pattern.quote(KMSConfiguration.KEY_ACL_PREFIX));\n    for (Map.Entry\u003cString, String\u003e keyAcl : allKeyACLS.entrySet()) {\n      String k \u003d keyAcl.getKey();\n      // this should be of type \"key.acl.\u003cKEY_NAME\u003e.\u003cOP_TYPE\u003e\"\n      int keyNameStarts \u003d KMSConfiguration.KEY_ACL_PREFIX.length();\n      int keyNameEnds \u003d k.lastIndexOf(\".\");\n      if (keyNameStarts \u003e\u003d keyNameEnds) {\n        LOG.warn(\"Invalid key name \u0027{}\u0027\", k);\n      } else {\n        String aclStr \u003d keyAcl.getValue();\n        String keyName \u003d k.substring(keyNameStarts, keyNameEnds);\n        String keyOp \u003d k.substring(keyNameEnds + 1);\n        KeyOpType aclType \u003d null;\n        try {\n          aclType \u003d KeyOpType.valueOf(keyOp);\n        } catch (IllegalArgumentException e) {\n          LOG.warn(\"Invalid key Operation \u0027{}\u0027\", keyOp);\n        }\n        if (aclType !\u003d null) {\n          // On the assumption this will be single threaded.. else we need to\n          // ConcurrentHashMap\n          HashMap\u003cKeyOpType,AccessControlList\u003e aclMap \u003d\n              tempKeyAcls.get(keyName);\n          if (aclMap \u003d\u003d null) {\n            aclMap \u003d new HashMap\u003cKeyOpType, AccessControlList\u003e();\n            tempKeyAcls.put(keyName, aclMap);\n          }\n          aclMap.put(aclType, new AccessControlList(aclStr));\n          LOG.info(\"KEY_NAME \u0027{}\u0027 KEY_OP \u0027{}\u0027 ACL \u0027{}\u0027\",\n              keyName, aclType, aclStr);\n        }\n      }\n    }\n\n    keyAcls \u003d tempKeyAcls;\n    for (KeyOpType keyOp : KeyOpType.values()) {\n      if (!defaultKeyAcls.containsKey(keyOp)) {\n        String confKey \u003d KMSConfiguration.DEFAULT_KEY_ACL_PREFIX + keyOp;\n        String aclStr \u003d conf.get(confKey);\n        if (aclStr !\u003d null) {\n          if (aclStr.equals(\"*\")) {\n            LOG.info(\"Default Key ACL for  KEY_OP \u0027{}\u0027 is set to \u0027*\u0027\", keyOp);\n          }\n          defaultKeyAcls.put(keyOp, new AccessControlList(aclStr));\n        }\n      }\n    }\n  }",
          "path": "hadoop-common-project/hadoop-kms/src/main/java/org/apache/hadoop/crypto/key/kms/server/KMSACLs.java",
          "extendedDetails": {
            "oldValue": "setACLs",
            "newValue": "setKeyACLs"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-10758. KMS: add ACLs on per key basis. (tucu)\n",
          "commitDate": "10/09/14 2:26 PM",
          "commitName": "b02a4b40610e93eef6559db09a11d287e859446d",
          "commitAuthor": "Alejandro Abdelnur",
          "commitDateOld": "03/09/14 3:08 PM",
          "commitNameOld": "d9a03e272adbf3e9fde501610400f18fb4f6b865",
          "commitAuthorOld": "Alejandro Abdelnur",
          "daysBetweenCommits": 6.97,
          "commitsBetweenForRepo": 62,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,17 +1,52 @@\n-  private void setACLs(Configuration conf) {\n-    Map\u003cType, AccessControlList\u003e tempAcls \u003d new HashMap\u003cType, AccessControlList\u003e();\n-    Map\u003cType, AccessControlList\u003e tempBlacklist \u003d new HashMap\u003cType, AccessControlList\u003e();\n-    for (Type aclType : Type.values()) {\n-      String aclStr \u003d conf.get(aclType.getAclConfigKey(), ACL_DEFAULT);\n-      tempAcls.put(aclType, new AccessControlList(aclStr));\n-      String blacklistStr \u003d conf.get(aclType.getBlacklistConfigKey());\n-      if (blacklistStr !\u003d null) {\n-        // Only add if blacklist is present\n-        tempBlacklist.put(aclType, new AccessControlList(blacklistStr));\n-        LOG.info(\"\u0027{}\u0027 Blacklist \u0027{}\u0027\", aclType, blacklistStr);\n+  private void setKeyACLs(Configuration conf) {\n+    Map\u003cString, HashMap\u003cKeyOpType, AccessControlList\u003e\u003e tempKeyAcls \u003d\n+        new HashMap\u003cString, HashMap\u003cKeyOpType,AccessControlList\u003e\u003e();\n+    Map\u003cString, String\u003e allKeyACLS \u003d\n+        conf.getValByRegex(Pattern.quote(KMSConfiguration.KEY_ACL_PREFIX));\n+    for (Map.Entry\u003cString, String\u003e keyAcl : allKeyACLS.entrySet()) {\n+      String k \u003d keyAcl.getKey();\n+      // this should be of type \"key.acl.\u003cKEY_NAME\u003e.\u003cOP_TYPE\u003e\"\n+      int keyNameStarts \u003d KMSConfiguration.KEY_ACL_PREFIX.length();\n+      int keyNameEnds \u003d k.lastIndexOf(\".\");\n+      if (keyNameStarts \u003e\u003d keyNameEnds) {\n+        LOG.warn(\"Invalid key name \u0027{}\u0027\", k);\n+      } else {\n+        String aclStr \u003d keyAcl.getValue();\n+        String keyName \u003d k.substring(keyNameStarts, keyNameEnds);\n+        String keyOp \u003d k.substring(keyNameEnds + 1);\n+        KeyOpType aclType \u003d null;\n+        try {\n+          aclType \u003d KeyOpType.valueOf(keyOp);\n+        } catch (IllegalArgumentException e) {\n+          LOG.warn(\"Invalid key Operation \u0027{}\u0027\", keyOp);\n+        }\n+        if (aclType !\u003d null) {\n+          // On the assumption this will be single threaded.. else we need to\n+          // ConcurrentHashMap\n+          HashMap\u003cKeyOpType,AccessControlList\u003e aclMap \u003d\n+              tempKeyAcls.get(keyName);\n+          if (aclMap \u003d\u003d null) {\n+            aclMap \u003d new HashMap\u003cKeyOpType, AccessControlList\u003e();\n+            tempKeyAcls.put(keyName, aclMap);\n+          }\n+          aclMap.put(aclType, new AccessControlList(aclStr));\n+          LOG.info(\"KEY_NAME \u0027{}\u0027 KEY_OP \u0027{}\u0027 ACL \u0027{}\u0027\",\n+              keyName, aclType, aclStr);\n+        }\n       }\n-      LOG.info(\"\u0027{}\u0027 ACL \u0027{}\u0027\", aclType, aclStr);\n     }\n-    acls \u003d tempAcls;\n-    blacklistedAcls \u003d tempBlacklist;\n+\n+    keyAcls \u003d tempKeyAcls;\n+    for (KeyOpType keyOp : KeyOpType.values()) {\n+      if (!defaultKeyAcls.containsKey(keyOp)) {\n+        String confKey \u003d KMSConfiguration.DEFAULT_KEY_ACL_PREFIX + keyOp;\n+        String aclStr \u003d conf.get(confKey);\n+        if (aclStr !\u003d null) {\n+          if (aclStr.equals(\"*\")) {\n+            LOG.info(\"Default Key ACL for  KEY_OP \u0027{}\u0027 is set to \u0027*\u0027\", keyOp);\n+          }\n+          defaultKeyAcls.put(keyOp, new AccessControlList(aclStr));\n+        }\n+      }\n+    }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void setKeyACLs(Configuration conf) {\n    Map\u003cString, HashMap\u003cKeyOpType, AccessControlList\u003e\u003e tempKeyAcls \u003d\n        new HashMap\u003cString, HashMap\u003cKeyOpType,AccessControlList\u003e\u003e();\n    Map\u003cString, String\u003e allKeyACLS \u003d\n        conf.getValByRegex(Pattern.quote(KMSConfiguration.KEY_ACL_PREFIX));\n    for (Map.Entry\u003cString, String\u003e keyAcl : allKeyACLS.entrySet()) {\n      String k \u003d keyAcl.getKey();\n      // this should be of type \"key.acl.\u003cKEY_NAME\u003e.\u003cOP_TYPE\u003e\"\n      int keyNameStarts \u003d KMSConfiguration.KEY_ACL_PREFIX.length();\n      int keyNameEnds \u003d k.lastIndexOf(\".\");\n      if (keyNameStarts \u003e\u003d keyNameEnds) {\n        LOG.warn(\"Invalid key name \u0027{}\u0027\", k);\n      } else {\n        String aclStr \u003d keyAcl.getValue();\n        String keyName \u003d k.substring(keyNameStarts, keyNameEnds);\n        String keyOp \u003d k.substring(keyNameEnds + 1);\n        KeyOpType aclType \u003d null;\n        try {\n          aclType \u003d KeyOpType.valueOf(keyOp);\n        } catch (IllegalArgumentException e) {\n          LOG.warn(\"Invalid key Operation \u0027{}\u0027\", keyOp);\n        }\n        if (aclType !\u003d null) {\n          // On the assumption this will be single threaded.. else we need to\n          // ConcurrentHashMap\n          HashMap\u003cKeyOpType,AccessControlList\u003e aclMap \u003d\n              tempKeyAcls.get(keyName);\n          if (aclMap \u003d\u003d null) {\n            aclMap \u003d new HashMap\u003cKeyOpType, AccessControlList\u003e();\n            tempKeyAcls.put(keyName, aclMap);\n          }\n          aclMap.put(aclType, new AccessControlList(aclStr));\n          LOG.info(\"KEY_NAME \u0027{}\u0027 KEY_OP \u0027{}\u0027 ACL \u0027{}\u0027\",\n              keyName, aclType, aclStr);\n        }\n      }\n    }\n\n    keyAcls \u003d tempKeyAcls;\n    for (KeyOpType keyOp : KeyOpType.values()) {\n      if (!defaultKeyAcls.containsKey(keyOp)) {\n        String confKey \u003d KMSConfiguration.DEFAULT_KEY_ACL_PREFIX + keyOp;\n        String aclStr \u003d conf.get(confKey);\n        if (aclStr !\u003d null) {\n          if (aclStr.equals(\"*\")) {\n            LOG.info(\"Default Key ACL for  KEY_OP \u0027{}\u0027 is set to \u0027*\u0027\", keyOp);\n          }\n          defaultKeyAcls.put(keyOp, new AccessControlList(aclStr));\n        }\n      }\n    }\n  }",
          "path": "hadoop-common-project/hadoop-kms/src/main/java/org/apache/hadoop/crypto/key/kms/server/KMSACLs.java",
          "extendedDetails": {}
        }
      ]
    },
    "d9a03e272adbf3e9fde501610400f18fb4f6b865": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10863. KMS should have a blacklist for decrypting EEKs. (asuresh via tucu)\n",
      "commitDate": "03/09/14 3:08 PM",
      "commitName": "d9a03e272adbf3e9fde501610400f18fb4f6b865",
      "commitAuthor": "Alejandro Abdelnur",
      "commitDateOld": "14/08/14 10:03 PM",
      "commitNameOld": "e86c9ef6517313aaa0e4575261a462f2f55d43dc",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 19.71,
      "commitsBetweenForRepo": 126,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,9 +1,17 @@\n   private void setACLs(Configuration conf) {\n     Map\u003cType, AccessControlList\u003e tempAcls \u003d new HashMap\u003cType, AccessControlList\u003e();\n+    Map\u003cType, AccessControlList\u003e tempBlacklist \u003d new HashMap\u003cType, AccessControlList\u003e();\n     for (Type aclType : Type.values()) {\n-      String aclStr \u003d conf.get(aclType.getConfigKey(), ACL_DEFAULT);\n+      String aclStr \u003d conf.get(aclType.getAclConfigKey(), ACL_DEFAULT);\n       tempAcls.put(aclType, new AccessControlList(aclStr));\n+      String blacklistStr \u003d conf.get(aclType.getBlacklistConfigKey());\n+      if (blacklistStr !\u003d null) {\n+        // Only add if blacklist is present\n+        tempBlacklist.put(aclType, new AccessControlList(blacklistStr));\n+        LOG.info(\"\u0027{}\u0027 Blacklist \u0027{}\u0027\", aclType, blacklistStr);\n+      }\n       LOG.info(\"\u0027{}\u0027 ACL \u0027{}\u0027\", aclType, aclStr);\n     }\n     acls \u003d tempAcls;\n+    blacklistedAcls \u003d tempBlacklist;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void setACLs(Configuration conf) {\n    Map\u003cType, AccessControlList\u003e tempAcls \u003d new HashMap\u003cType, AccessControlList\u003e();\n    Map\u003cType, AccessControlList\u003e tempBlacklist \u003d new HashMap\u003cType, AccessControlList\u003e();\n    for (Type aclType : Type.values()) {\n      String aclStr \u003d conf.get(aclType.getAclConfigKey(), ACL_DEFAULT);\n      tempAcls.put(aclType, new AccessControlList(aclStr));\n      String blacklistStr \u003d conf.get(aclType.getBlacklistConfigKey());\n      if (blacklistStr !\u003d null) {\n        // Only add if blacklist is present\n        tempBlacklist.put(aclType, new AccessControlList(blacklistStr));\n        LOG.info(\"\u0027{}\u0027 Blacklist \u0027{}\u0027\", aclType, blacklistStr);\n      }\n      LOG.info(\"\u0027{}\u0027 ACL \u0027{}\u0027\", aclType, aclStr);\n    }\n    acls \u003d tempAcls;\n    blacklistedAcls \u003d tempBlacklist;\n  }",
      "path": "hadoop-common-project/hadoop-kms/src/main/java/org/apache/hadoop/crypto/key/kms/server/KMSACLs.java",
      "extendedDetails": {}
    },
    "80d7f0911cf42eee001fe1a3d6958b82635df671": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10824. Refactor KMSACLs to avoid locking. (Benoy Antony via umamahesh)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1610969 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/07/14 4:24 AM",
      "commitName": "80d7f0911cf42eee001fe1a3d6958b82635df671",
      "commitAuthor": "Uma Maheswara Rao G",
      "commitDateOld": "05/05/14 2:43 PM",
      "commitNameOld": "17d4fbbf0af9b93de9502afb274e91533140d1c6",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 71.57,
      "commitsBetweenForRepo": 441,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,13 +1,9 @@\n   private void setACLs(Configuration conf) {\n-    lock.writeLock().lock();\n-    try {\n-      acls \u003d new HashMap\u003cType, AccessControlList\u003e();\n-      for (Type aclType : Type.values()) {\n-        String aclStr \u003d conf.get(aclType.getConfigKey(), ACL_DEFAULT);\n-        acls.put(aclType, new AccessControlList(aclStr));\n-        LOG.info(\"\u0027{}\u0027 ACL \u0027{}\u0027\", aclType, aclStr);\n-      }\n-    } finally {\n-      lock.writeLock().unlock();\n+    Map\u003cType, AccessControlList\u003e tempAcls \u003d new HashMap\u003cType, AccessControlList\u003e();\n+    for (Type aclType : Type.values()) {\n+      String aclStr \u003d conf.get(aclType.getConfigKey(), ACL_DEFAULT);\n+      tempAcls.put(aclType, new AccessControlList(aclStr));\n+      LOG.info(\"\u0027{}\u0027 ACL \u0027{}\u0027\", aclType, aclStr);\n     }\n+    acls \u003d tempAcls;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void setACLs(Configuration conf) {\n    Map\u003cType, AccessControlList\u003e tempAcls \u003d new HashMap\u003cType, AccessControlList\u003e();\n    for (Type aclType : Type.values()) {\n      String aclStr \u003d conf.get(aclType.getConfigKey(), ACL_DEFAULT);\n      tempAcls.put(aclType, new AccessControlList(aclStr));\n      LOG.info(\"\u0027{}\u0027 ACL \u0027{}\u0027\", aclType, aclStr);\n    }\n    acls \u003d tempAcls;\n  }",
      "path": "hadoop-common-project/hadoop-kms/src/main/java/org/apache/hadoop/crypto/key/kms/server/KMSACLs.java",
      "extendedDetails": {}
    },
    "17d4fbbf0af9b93de9502afb274e91533140d1c6": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-10433. Key Management Server based on KeyProvider API. (tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1592637 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "05/05/14 2:43 PM",
      "commitName": "17d4fbbf0af9b93de9502afb274e91533140d1c6",
      "commitAuthor": "Alejandro Abdelnur",
      "diff": "@@ -0,0 +1,13 @@\n+  private void setACLs(Configuration conf) {\n+    lock.writeLock().lock();\n+    try {\n+      acls \u003d new HashMap\u003cType, AccessControlList\u003e();\n+      for (Type aclType : Type.values()) {\n+        String aclStr \u003d conf.get(aclType.getConfigKey(), ACL_DEFAULT);\n+        acls.put(aclType, new AccessControlList(aclStr));\n+        LOG.info(\"\u0027{}\u0027 ACL \u0027{}\u0027\", aclType, aclStr);\n+      }\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void setACLs(Configuration conf) {\n    lock.writeLock().lock();\n    try {\n      acls \u003d new HashMap\u003cType, AccessControlList\u003e();\n      for (Type aclType : Type.values()) {\n        String aclStr \u003d conf.get(aclType.getConfigKey(), ACL_DEFAULT);\n        acls.put(aclType, new AccessControlList(aclStr));\n        LOG.info(\"\u0027{}\u0027 ACL \u0027{}\u0027\", aclType, aclStr);\n      }\n    } finally {\n      lock.writeLock().unlock();\n    }\n  }",
      "path": "hadoop-common-project/hadoop-kms/src/main/java/org/apache/hadoop/crypto/key/kms/server/KMSACLs.java"
    }
  }
}